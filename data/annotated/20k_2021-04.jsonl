{"id": "3lycWw", "name": "dvg_Radial_Mask", "author": "david4jsus", "description": "Based on the initial default shader, learned to make a radial mask. Move the mouse on the X axis to adjust the radius of the mask.", "tags": ["circle", "radial", "mask"], "likes": 0, "viewed": 41, "date": "1618852597", "time_retrieved": "2024-06-20T20:35:59.716120", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Time varying pixel color\n    vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n    \n    // Initialize mask\n    vec3 mask = vec3 (0.0);\n    \n    // Radial mask\n    if (iMouse.x == 0.0) { // Have the shader not start as all black\n        mask = vec3 (distance (uv.xyx, vec3 (0.5))) * vec3 (abs (sin (iTime)) * 5.0);\n    } else {               // Intended code\n        mask = vec3 (distance (uv.xyx, vec3 (0.5))) * vec3 (iMouse.x * 0.01);\n    }\n\n    // Output to screen\n    fragColor = vec4(col * mask,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/3lycWw.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "3lyyWw", "name": "dvg_Square", "author": "david4jsus", "description": "Based on the initial default shader, added a square that follows the mouse.", "tags": ["mouse", "square"], "likes": 1, "viewed": 31, "date": "1618852673", "time_retrieved": "2024-06-20T20:35:59.885966", "image_code": "bool isFragCoordInMouseArea(vec2 fragCoord) {\n    //return (fragCoord.x <= iMouse.x + 50.0 && fragCoord.x >= iMouse.x - 50.0\n    //    && fragCoord.y <= iMouse.y + 50.0 && fragCoord.y >= iMouse.y - 50.0);\n    vec2 check = max (abs (fragCoord - iMouse.xy), vec2 (50.0));\n    return (check == vec2 (50.0));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    // Mouse coords to uv coords\n    //vec2 mouseCoord = iMouse.xy/iResolution.xy;\n\n    // Time varying pixel color\n    vec3 col1 = 0.5 + 0.5 * cos (iTime + uv.xyx + vec3 (0, 2, 4));\n    vec3 col2 = 0.5 + 0.5 * sin (iTime + uv.xyx + vec3 (0, 2, 4));\n\n    // Output to screen\n    if (isFragCoordInMouseArea (fragCoord)) {\n        fragColor = vec4 (col2, 1.0);\n    } else {\n        fragColor = vec4 (col1, 1.0);\n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/3lyyWw.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "3t3yRl", "name": "Shamosis - Dinopwaur", "author": "z0rg", "description": "https://www.youtube.com/watch?v=euWx4bt-HPg", "tags": ["trance", "goa", "boomboom"], "likes": 3, "viewed": 196, "date": "1618049906", "time_retrieved": "2024-06-20T20:36:00.989112", "image_code": "// This work is licensed under the Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n// Unported License. To view a copy of this license, visit http://creativecommons.org/licenses/by-nc-sa/3.0/ \n// or send a letter to Creative Commons, PO Box 1866, Mountain View, CA 94042, USA.\n// =========================================================================================================\n\n#define FFT(p) pow(texelFetch(iChannel0, ivec2(int(p), 0), 0)*.45, vec4(4.5))\n\nfloat lenny(vec2 v)\n{\n  return abs(v.x)+abs(v.y); \n}\n#define sat(a) clamp(a, 0.,1.)\nmat2 r2d(float a) \n{\n  float ca = cos(a);\n  float sa = sin(a);\n  \n  return mat2(ca,-sa, sa, ca);\n}\nvec2 _sub(vec2 a, vec2 b)\n{\n  if (a.x > -b.x)\n    return a;\n  return b;\n}\n\nvec2 _min(vec2 a, vec2 b)\n{\n  if (a.x < b.x)\n    return a;\n  return b;\n}\nfloat sdCylinder( vec3 p, vec3 c )\n{\n  return length(p.xz-c.xy)-c.z;\n}\n\n// power smooth min (k = 8);\nfloat _smin( float a, float b, float k )\n{\n    a = pow( a, k ); b = pow( b, k );\n    return pow( (a*b)/(a+b), 1.0/k );\n}\n\nvec3 getDir(vec3 rd, vec2 uv)\n{\n  vec3 r = normalize(cross(rd, vec3(0.,1.,0.)));\n  vec3 u = normalize(cross(r, rd));\n  \n  return rd+ r * uv.x + u * uv.y;\n}\n\nfloat rhombus(vec3 p, float sz)\n{\n  p = abs(p);\n  return (p.x+p.y+p.z-sz)*0.577;\n}\n\n\nvec2 map(vec3 p)\n{\n  float beat = FFT(5).x*3.;\n  vec2 cyl = vec2(sdCylinder(p, vec3(1., 1., 1.)), 0.);\n  vec3 p2 = p;\n  p2.xz += vec2(sin(beat), cos(beat))*4.;\n  vec2 sph = vec2(length(p2)-2.5*max(FFT(55).x, 0.007)*70., 0.);\n  p2 = p+vec3(1.);\n  vec2 sph2 = vec2(rhombus(p2, 5.5*max(FFT(205).x, 0.005)*70.), 0.);\n  return _min(_min(sph2, sph), cyl);\n  vec2 fl = vec2(p.y, 1.);\n  return _min(cyl, fl);\n}\n\nvec3 calcNormal( in vec3 p, in float t )\n{\n    float e = 0.001*t;\n\n    vec2 h = vec2(1.0,-1.0)*0.5773;\n    return normalize( h.xyy*map( p + h.xyy*e ).x + \n\t\t\t\t\t  h.yyx*map( p + h.yyx*e ).x + \n\t\t\t\t\t  h.yxy*map( p + h.yxy*e ).x + \n\t\t\t\t\t  h.xxx*map( p + h.xxx*e ).x );\n}\n\nvec3 checkerBoard(vec2 uv)\n{\n  uv.y+=iTime*5.;\n  float sz = 1.5;\n  float x = mod(uv.x, sz)-sz*.5;\n  float y = mod(uv.y, sz)-sz*.5;\n  x = sat(x*200.);\n  float res = mix(x, 1.-x, sat(y*200.));\n  return vec3(res);\n}\n\nvec3 grad(vec2 uv)\n{\n  vec3 col;\n  vec3 blue = vec3(157., 200., 255.)/255.;\n  vec3 yellow = vec3(255, 241., 187.)/255.;\n  vec3 red = vec3(255., 190., 191.)/255.;\n  \n  float sz = 19.;\n  \n  if (uv.y < 0.)\n  {\n    return mix(yellow, red, sat(-uv.y*sz));\n  }\n  \n  \n  return mix(yellow, blue, sat(uv.y*sz));\n}\n\nfloat sig(vec2 uv)\n{\n  float attenBorder = 1.;\n  float t = iTime;// iTime;\n  float tst = sin(abs(uv.x)*5.+t)*.002;\n  return uv.y -.01- (attenBorder*sat(FFT(abs(uv.x*.005)).x*5.))*.05-tst;//*(1.-sat(abs(uv.x*2.)), 5.);\n}\n\nvec3 rdr(vec2 uv)\n{\n  vec3 col;\n  col = vec3(0.123, 0.07, 0.15);\n\n  vec3 rgb = pow(grad(uv), vec3(1.45));\n  rgb.x *= .6+sat(FFT(uv.x*.1).x)*100.;\n  \n  vec2 ouv = uv;\n  uv = vec2(atan(uv.y, uv.x), length(uv));\n  float ln = abs(sig(uv))-.00001;\n\n    col = mix(col, rgb, 1.-sat(ln*800.));\n    col += rgb *pow(1.-sat(ln*10.), 5.);\n\n  \n  for (int i = 0; i < 8; ++i)\n  {\n    float fi = float(i);\n    \n    vec2 uvt = ouv * r2d(fi);\n    uvt = vec2(atan(uvt.y, uvt.x), length(uvt));\n    float ln2 = abs(sig(uvt*fi/8.))-.00001*fi*fi;\n    \n    col += .3*rgb *pow(1.-sat(ln2*950.), 5.);\n\n  }\n  \n\n  return col;\n}\n\n\n\nvec2 myPixel(vec2 uv, float k)\n{\n  vec2 pxuv = uv/k;\n  pxuv = vec2(int(pxuv.x), int(pxuv.y))*k;\n  return pxuv;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = (fragCoord.xy-vec2(.5)*iResolution.xy)/iResolution.xx;\n uv *= .2;\n  \n  \n  \n  float rep = 1.+(sin(iTime*.5) < 0. ? 1. : sat(FFT(5).x*50.));\n  \n  if (false)//iTime > 78.8)\n  {\n  \n  float rep2 = .1*sin(iTime*.5);\n  uv *= r2d(sin(iTime+length(uv)*145.));\n  uv.x = mod(uv.x, rep2)-.5*rep2;\n  }\n  uv *= r2d(-3.14159265/2.);\n  uv *= mod(-iTime, 2.);\n  float r = 0.05/(sin(iTime));\n  uv *= r2d(mod(length(uv), r)/r);\n  \n  vec2 uv2 = uv;\n  uv2.x = (mod(atan(uv.y, uv.x), rep)-.5*rep)*.1;\n  uv2.y = FFT(abs(uv.y)).x+length(uv)*(mod(iTime*.5, 2.5))+sin(iTime)*.05;\n  \n  uv2 = myPixel(uv2, 0.01*sin(iTime*.5));\n  \n  vec3 col =rdr(uv2)*.7;\n  col += rdr(uv)*.1*(sin(iTime*.2)*.5+.5);\n\tcol *= .5+rdr(uv*.2);\n    float a = atan(uv.y, uv.x);\n    col = mix(col, mix(col.zyx, col, 0.), sat(sin(uv.x*15.+iTime)+.1*sin(length(uv-a*3.14159265*2.-iTime))));\n  col = pow(col, vec3(1.45));\n  vec3 txt;// = texture(iChannel1, fragCoord/iResolution.xy).xyz;\n  col *= mix(vec3(1.), vec3(5.), txt.x);\n  //col *= sat(iTime-2.);\n  col *= 1.-sat(iTime-502.);\n  fragColor = vec4(col, 1.0);\n}", "image_inputs": [{"id": "4dXGRn", "previewfilepath": "/media/ap/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg", "ctype": "texture"}, {"id": "MtXXz4", "previewfilepath": "https://soundcloud.com/shamosis/shamosis-dinopwaur", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0, "src": "https://soundcloud.com/shamosis/shamosis-dinopwaur", "ctype": "musicstream"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc-by-sa-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/3t3yRl.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "4l2fzc", "name": "rainy ghost cube", "author": "nylki", "description": "Rotating cube engulfed in rain-like artefacts.", "tags": ["sdf"], "likes": 1, "viewed": 169, "date": "1619784043", "time_retrieved": "2024-06-20T20:36:01.679923", "image_code": "#ifdef GL_ES\nprecision mediump float;\n#endif\n\n// uniform vec2 iResolution;\n// uniform vec2 u_mouse;\n// uniform float iGlobalTime;\n\nconst float PI = 3.14159265359;\nconst float fov = 50.0;\nconst float S = 0.01;\n\n\nconst vec3 spherePos = vec3(0.0, 0.0, 0.0);\n\nfloat sphere(vec3 p, float r) {\n return length(p) - r;\n}\n\n// New distance function for a cube\nfloat cube(vec3 p, float s /* half length of the faces */) {\n    vec3 q = abs(p) - vec3(s);\n    return min(max(q.x,max(q.y,q.z)),0.0) +\n         length(max(q,0.0));\n}\n\nfloat sdfGhost(float a, float b) {\n    return mod(iTime * b,a);\n}\n\n\nfloat distanceToNearestSurface(vec3 p) {\n    return sdfGhost(cube(vec3(1.0,0.0, 1.0) + p, 1.5), sphere(p,  1000.0));\n}\n\n\n// const delta vectors for normal calculation\nconst vec3 deltax = vec3(S ,0, 0);\nconst vec3 deltay = vec3(0 ,S, 0);\nconst vec3 deltaz = vec3(0 ,0, S);\n\n\nvec3 calcNormalForPoint(vec3 p, float dist) {\n // ... my own old attempt at the normal calc without\n // Create the three vectors pointing out\n // along each one of the axes by copying p each time first.\n vec3 A = p;\n vec3 B = p;\n vec3 C = p;\n\n A.x += S;\n B.y += S;\n C.z += S;\n\n // Get their distances to the surface\n float distA = distanceToNearestSurface(A) - dist;\n float distB = distanceToNearestSurface(B) - dist;\n float distC = distanceToNearestSurface(C) - dist;\n\n // And use the distances as value for each axe (X,Y,Z)\n vec3 normal = normalize(vec3(distA,distB,distC));\n return normal;\n\n}\n\nvec3 computeToon(vec3 color, float steps) {\n return ceil(color * steps) / steps;\n}\n\nvec3 computeLambert(vec3 p, vec3 n, float intensity) {\n    \n\tvec3 lightPos = vec3(100., 30., 50.);\n    // calc vector pointing from light to point\n    // and then take dot product of that\n    // vector and the surface normal\n    vec3 lightToPoint = normalize(lightPos-p);\n    return vec3( intensity * dot(lightToPoint, n));\n}\n\nvec3 intersectWithWorld(vec3 p, vec3 dir) {\n\tfloat dist = 0.0;\n    for(int i = 0; i < 20; i++) {\n    \tvec3 currentRayPos = p + dir*dist;\n    \tfloat nearest = distanceToNearestSurface(currentRayPos);\n        if (nearest < 0.01) {\n        \tvec3 normal = calcNormalForPoint(currentRayPos, nearest);\n            return computeLambert(currentRayPos, normal, 1.0);\n        }\n        dist += nearest;\n    }\n    return vec3(0.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    vec3 camPos = vec3(10.0*sin(iTime), 0.0, 10.0*cos(iTime));\n    vec3 camDir = vec3(-1.0*sin(iTime), 0.0, -1.0*cos(iTime));\n    vec3 camUp  = vec3(0.0, 1.0, 0.0);\n    \n    // tracing stuff\n    const float fovx = PI * fov / 360.0;\n    float fovy = fovx * iResolution.y/iResolution.x;\n    float ulen = tan(fovx);\n    float vlen = tan(fovy);\n    \n    \n    // Generate Ray for this fragment\n \n    // create camera UV (-1 to 1.0) from UV (0.0 to 1.0)\n    \n    vec2 camUV = uv*2.0 - vec2(1.0, 1.0);\n    \n    // Get perpendicular vector from camUp and camDir\n    // which is the x axis of the camera basically\n\n    vec3 nright = normalize( cross(camUp, camDir) );\n    \n    // Calculate Pixel position in space to trace\n    vec3 pixel = camPos + camDir + nright*camUV.x*ulen + camUp*camUV.y*vlen;\n\t\n    // Calculate direction vector from camera to pixel\n    vec3 ray = normalize(pixel - camPos);\n\n\n    vec3 intersectionColor = intersectWithWorld(pixel, ray);\n    intersectionColor.r *= sin(iMouse.x/iResolution.x);\n    fragColor = vec4(intersectionColor , 1.0);\n\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4l2fzc.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "7d23DR", "name": "2D amoebas", "author": "mrange", "description": "License CC0: 2D Amoebas\nWhile messing around I stumbled on a simple \"amoeba\" lika effect.\nNothing complicated but nice IMHO so I shared\n", "tags": ["2d"], "likes": 7, "viewed": 205, "date": "1617269072", "time_retrieved": "2024-06-20T20:36:02.104339", "image_code": "// License CC0: 2D Amoebas\n//  While messing around I stumbled on a simple \"amoeba\" lika effect.\n//  Nothing complicated but nice IMHO so I shared\n\n#define RESOLUTION iResolution\n#define TIME       iTime\n\nfloat circle(vec2 p, float r) {\n  return length(p) - r;\n}\n\n// IQ's polynominal min\nfloat pmin(float a, float b, float k) {\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\n// http://mercury.sexy/hg_sdf/\nvec2 mod2(inout vec2 p, vec2 size) {\n  vec2 c = floor((p + size*0.5)/size);\n  p = mod(p + size*0.5,size) - size*0.5;\n  return c;\n}\n\n\nfloat df(vec2 p) {\n  // Generates a grid of dots\n  vec2 dp = p;\n  vec2 dn = mod2(dp, vec2(0.25));\n  float ddots = length(dp);\n  \n  // Blobs\n  float dblobs = 1E6;\n  for (int i = 0; i < 5; ++i) {\n    float dd = circle(p-1.0*vec2(sin(TIME+float(i)), sin(float(i*i)+TIME*sqrt(0.5))), 0.1);\n    dblobs = pmin(dblobs, dd, 0.35);\n  }\n\n  float d = 1E6;\n  d = min(d, ddots);\n  // Smooth min between blobs and dots makes it look somewhat amoeba like\n  d = pmin(d, dblobs, 0.35);\n  return d;\n}\n\nvec3 postProcess(vec3 col, vec2 q)  {\n  col=pow(clamp(col,0.0,1.0),vec3(1.0/2.2)); \n  col=col*0.6+0.4*col*col*(3.0-2.0*col);  // contrast\n  col=mix(col, vec3(dot(col, vec3(0.33))), -0.4);  // satuation\n  col*=0.5+0.5*pow(19.0*q.x*q.y*(1.0-q.x)*(1.0-q.y),0.7);  // vigneting\n  return col;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  vec2 q = fragCoord/RESOLUTION.xy;\n  vec2 p = -1. + 2. * q;\n  p.x *= RESOLUTION.x/RESOLUTION.y;\n  float aa = 2.0/RESOLUTION.y;\n \n  const float z = 1.4;\n  float d = df(p/z)*z; \n  \n  vec3 col = vec3(0.33);\n  col = mix(col, vec3(.0), smoothstep(-aa, aa, -d));\n\n  col = postProcess(col, q);\n  fragColor = vec4(col, 1.0);\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc0-1.0", "thumbnail": "https://www.shadertoy.com/media/shaders/7d23DR.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "7d23R3", "name": "Clockwork Spacetime", "author": "Tater", "description": "would be cool if someone made this in 3D, maybe I should learn ray marching. ", "tags": ["2d", "gears", "warp", "rotation", "spin"], "likes": 15, "viewed": 304, "date": "1617763193", "time_retrieved": "2024-06-20T20:36:02.468028", "image_code": "#define pi 3.14159265359\n#define rot(a) mat2( cos(a),-sin(a),sin(a),cos(a) )\n#define a(c) float( clamp(c,0.0,1.0) )\nfloat gear(vec2 uv, float aa,float tth){ //this is a mess lol\n    float inn = 0.275; //Inner Circle Size\n    float th = atan(-uv.y,-uv.x)/(2.0*pi)+0.5;\n    float id = mod(floor(th*tth),2.0);\n    th = mod(th,1./tth)*tth;\n    float r = length(uv);\n    float c = smoothstep(r-aa,r+aa,inn);\n    th = abs(th-0.5)*1.05;\n    float end = (-pow(th,3.4)+1.0)*0.425; //Tooth Shape\n    c += smoothstep(r-aa,r+aa,end)*id*\n    smoothstep(th-aa*tth/2.5,th+aa*tth/2.5,0.5);\n    return c;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 R = iResolution.xy;\n    vec2 uv = (fragCoord-.5*R.xy)/R.y;\n    float aa = 1./R.y;\n    \n    float t = iTime*1.5;\n    //Time Warping\n    t = pow(fract(t),3.5)+floor(t);\n    \n    //Size of rotation steps\n    t*=pi/(6.0);\n    \n    //Whole Screen Rotation + direction flip\n    uv*=rot(-t*sign(sin(t)));\n    vec2 uv2 = uv;\n    \n    //Gear Tooth Count /2 (works well with 20,16,12,8,4)\n    float tth =12.0;\n    \n    //Overall Scale\n    float scl = 3.7;\n    \n    //Zoom In/Out\n    scl-=cos(t)*0.75;\n    \n    //Slight Initial Offset\n    t+=pi/tth;\n    \n    //Edge of screen warping\n    scl*=1.0+pow(length(uv),10.0);\n    \n    //The Gears\n    aa*=scl;\n    vec3 gearCol = vec3(1.0); //I like it b/w but you can change it\n    uv = 0.5-fract(uv*scl);\n    uv *= rot(-t);\n    vec3 col = gearCol*a(gear(uv,aa,tth))*(1.0-length(uv));\n    \n    t+=pi/2.;\n    uv2 += 0.5/scl;\n    uv = 0.5-fract(uv2*scl);\n    uv *= rot(t);\n    col += gearCol*a(gear(uv,aa,tth))*(0.05+length(uv));\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/7d23R3.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "7d23zG", "name": "Pulsing circle weave", "author": "DukeOfStraylight", "description": "A rough reproduction of https://cdn.discordapp.com/attachments/740098399956762679/828452299100913735/giphy.gif but without that one annoying circle in the center that moves differently from the others.", "tags": ["circles"], "likes": 9, "viewed": 323, "date": "1617603011", "time_retrieved": "2024-06-20T20:36:02.468028", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord-0.5*iResolution.xy)/iResolution.y;\n\n    uv *= 20.;\n\n\n    vec2 id = floor(uv);\n    vec2 center = id + .5;\n    vec2 st = fract(uv);\n\n    float d = 1.;\n    const float NNEI = 2.;\n    for (float x = -NNEI; x <= NNEI; x++) {\n        for (float y = -NNEI; y < NNEI; y++) {\n            vec2 ndiff = vec2(x, y);\n            vec2 c = center + ndiff;\n            float r = length(c);\n            float a = atan(c.y, c.x);\n            r += sin(iTime * 5. - r*0.55) * min(r/5., 1.);\n            vec2 lc = vec2(r*cos(a), r*sin(a));\n            d = min(d, length(uv - lc));\n        }\n    }\n    float w = fwidth(uv.y);\n    vec3 col = vec3(smoothstep(0.31+w, 0.31-w, d));\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/7d23zG.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "7d2GDG", "name": "Thursday", "author": "xernobyl", "description": "A shader a day for a week. Thursday.\nFixing yesterday's shader.\n\nNow with very few artifacts!!!", "tags": ["ashaderadayforaweek"], "likes": 1, "viewed": 80, "date": "1617913264", "time_retrieved": "2024-06-20T20:36:03.152979", "image_code": "float height(vec3 p) {\n  return ((sin(p.z) + cos(p.x)) * 0.5) * 2.0;\n}\n\n\nvec3 height_normal(vec3 p) {\n  vec2 t = vec2(-0.5 * sin(p.x), 0.5 * cos(p.z));\n  return normalize(vec3(-t.x, sqrt(1.0 - t.x * t.x - t.y * t.y), -t.y));\n}\n\n\nvec3 pal(in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d) {\n  return a + b * cos(6.28318 * (c * t + d));\n}\n\n\nvec3 sRGB(vec3 linear)\n{\n  vec3 a = 12.92 * linear;\n  vec3 b = 1.055 * pow(linear, vec3(1.0 / 2.4)) - 0.055;\n  vec3 c = step(vec3(0.0031308), linear);\n  return mix(a, b, c);\n}\n\n#define saturate(x) clamp(x, 0.0, 1.0)\n\n\nvoid mainImage(out vec4 frag_color, in vec2 frag_coord) {\n  // camera movement\t\n  vec3 up = vec3(sin(sin(iTime)), cos(sin(iTime)), 0.0);\n  vec3 ray_origin = vec3(sin(iTime) * 8.0, 0.0, -10.0 * iTime);\n  vec3 target = vec3(0.0, 0.0, -10.0 * iTime + 1.0 * (cos(iTime)));\n  \n  // camera matrix\n  vec3 cw = normalize(target - ray_origin);\n  vec3 cu = normalize(cross(cw, up));\n  vec3 cv = normalize(cross(cu, cw));\n  \n  vec2 uv = (2.0 * frag_coord - iResolution.xy) / iResolution.y;\n\n  vec3 ray_dir = (uv.x * cu + uv.y * cv - 1.0 * cw); // normalize for non plane paralel rays\n  \n  vec3 ray_pos = ray_origin;\n  \n  float total_distance = 1.0;\n  float previous_distance = total_distance;\n  int object = 0;\n  float previous_height;\n  float step_height = 999999999.9999999;\n  \n  const float max_dist = 10000000.0;\n  bool inside = false;\n  bool previous_inside = false;\n  float base_step_size = 0.025;\n  \n  for (int it = 0; it < 256; ++it) {\n    inside = false;\n    float step_size = base_step_size * total_distance;\n    total_distance += step_size;\n    \n    ray_pos = ray_origin + total_distance * ray_dir;\n\n    previous_height = step_height;\n    step_height = height(ray_pos);\n    \n    float d = ray_pos.y - step_height + 4.0;\n    \n    if (abs(d) <= 0.001 * total_distance) {\n      object = 1;\n      break;\n    }\n    \n    if (d < 0.0) {\n      inside = true;\n    }\n    \n    d = -ray_pos.y - step_height + 4.0;\n    \n    if (abs(d) <= 0.001 * total_distance) {\n      object = 2;\n      break;\n    }\n\n    if (d < 0.0) {\n      inside = true;\n    }\n\n    if (inside) {\n      base_step_size = -0.5 * abs(base_step_size);\n    }\n    else {\n      if (previous_inside) {\n        base_step_size = -0.5 * base_step_size;\n      }\n    }\n    \n\n    if (total_distance >= max_dist) {\n      break;\n    }\n\n    previous_distance = total_distance;\n    previous_inside = inside;\n  }\n  \n  \n  vec3 n = height_normal(ray_pos);\n  \n  \n  vec3 fog = pal(iTime, vec3(0.5,0.5,0.5),vec3(0.5,0.5,0.5),vec3(1.0,1.0,0.5),vec3(0.8,0.90,0.30) );;\n  \n  if (object == 0) {\n    frag_color = vec4(sRGB(fog), 0.0);\n    return;\n  }\n  \n  float fog_factor = saturate(total_distance * total_distance / 5000.0);\n  \n  if (object == 1) {\n    vec3 col = pal(step_height / 2.0 - iTime, vec3(0.5,0.5,0.5),vec3(0.5,0.5,0.5),vec3(2.0,1.0,0.0),vec3(0.5,0.20,0.25) );\n    col = mix(saturate(-dot(n, ray_dir)) * col, fog, fog_factor);\n    frag_color = vec4(sRGB(col), 0.0);\n    return;\n  }\n  \n  if (object == 2) {\n    n.y = -n.y;\n    vec3 col = pal(step_height / 2.0 + iTime, vec3(0.5,0.5,0.5),vec3(0.5,0.5,0.5),vec3(1.0,0.7,0.4),vec3(0.0,0.15,0.20) );\n    col = mix(saturate(-dot(n, ray_dir)) * col, fog, fog_factor);\n    frag_color = vec4(sRGB(col), 0.0);\n    return;\n  } \n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/7d2GDG.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "7d2GDt", "name": "Tarquin", "author": "SnoopethDuckDuck", "description": "multi sample test thing", "tags": ["cool"], "likes": 2, "viewed": 35, "date": "1618151240", "time_retrieved": "2024-06-20T20:36:03.480064", "image_code": "const float pi = 3.14159;\nconst float pi2 = 1. * pi / 3.;\nconst float pi3 = 2. * pi / 3.;\n\nfloat random (vec2 st) {\n    return fract(sin(dot(st.xy,\n                         vec2(12.9898,78.233)))*\n        43758.5453123);\n}\n\nvec3 render(vec2 uv)\n{   \nfloat t= 0.5 * iTime;\nfloat b = 0.5 + 0.5 * cos(t);\nuv -= 0.5;\n // vec2 uv2 =  vec2(uv.x + 0.75 * cos(t), uv.y + 0.75 * sin(t));\n float taxi = abs(uv.x) + abs(uv.y );\nvec2 dir = uv * (1. +1.5 * tan(10.  * taxi) * (b + (1.-b) * length(uv)));\nfloat d =  (6. + 4. * b) * length(dir) ;\n\nfloat theta = atan( dir.y,dir.x);\n\nfloat p = cos(theta - t);\nfloat p2 = cos(theta -t + pi2);\nfloat p3 = cos(theta - t + pi3);\n\nfloat val = 1. - sqrt(p *p + p2 * p2);\nfloat val2 = 1. - sqrt(p2 * p2 + p3 * p3);\nfloat val3 = 1. - sqrt(p3 * p3 + p * p);\n\n    // Time varying pixel color\n    vec3 col = 1. - 0.9 *vec3(val,val2,val3);\n    vec3 col2 =   mix(vec3(0.2126* col.x + 0.7152 * col.y + 0.0722 * col.z),\n     vec3(step(col.x * val,0.5 + 0.5 * cos(-t - d * cos(d+ t))),\n     step(col.y * val,0.5 + 0.5 * cos(-t - pi2 -d *  cos(d + t + pi2))),\n     step(col.z * val3,0.5 + 0.5 * cos(-t - pi3 - d* cos(d+ t + pi3)))),4. * (1.-d) * d );\n     \n    col += sqrt(col * col + col2 * col2);\n  // Output to screen\n    return 16. * (1.-col) * (1.-col) * col * col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n float b = 0.5 + 0.5 * cos(iTime);\n float t =0.4 *  iTime;\n    float AA = 2.0;\n   // float px = 0.25/iResolution.y;\n  \n   vec3 col = (0.001 + 0.0005 * cos(t))  *\n   max(\n   min(render(vec2(1. + 0.5 * cos(t) ,0.55) - uv),\n   render(vec2(0.5,1. - 0.5 * cos(t + pi / 2.)) - uv) ),  \n  min( render(vec2(1. - 0.5 * cos(t + pi),1.5) - uv),\n   render(vec2(1.5,1. + 0.5 * cos(t + 3. * pi / 2.)) - uv))    \n   );\n   \n    fragColor = vec4(col,1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/7d2GDt.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "7d2GRG", "name": "some boxes", "author": "alice", "description": "haven't learned proper lighting yet, just a placeholder.\n\nlearning from Blackle's \"Perfect Pistons in Shadertoy\" tutorial, and figured out a few tricks jumping off that. will probably rewrite this cleaner once this gets too cumbersome for more experiments", "tags": ["3d"], "likes": 2, "viewed": 72, "date": "1617589043", "time_retrieved": "2024-06-20T20:36:04.395295", "image_code": "//Set this define for shadertoy\n#define shadertoy\n\n#ifndef shadertoy\n#define fragColor gl_FragColor\n#define fragCoord gl_FragCoord\n#define iResolution u_resolution\n#define iMouse u_mouse\n#define iTime u_time\n#endif\n\n#define PI 3.1415926538\n\nuniform vec2 u_resolution;\nuniform vec2 u_mouse;\nuniform float u_time;\n\nconst int MAX_STEPS = 1000;\nconst float MIN_RAY_LEN = 0.;\nconst float MAX_RAY_LEN = 10000.;\nconst float RAY_HIT_THRESH = 0.01;\n\nconst uint k = 1103515245U;  // GLIB C\n\nvec3 uhash(uvec3 x) {\n    x = ((x>>8U)^x.yzx)*k;\n    x = ((x>>8U)^x.yzx)*k;\n    x = ((x>>8U)^x.yzx)*k;\n    return vec3(x)*(1.0/float(0xffffffffU));\n}\n\nvec3 hash(vec3 x) {\n    return uhash(uvec3(abs(x)));\n}\n\nvec3 rotateAxis(vec3 p, vec3 axis, float angle) {\n    return mix(dot(axis, p)*axis, p, cos(angle)) + cross(axis,p)*sin(angle); // ??? idk, it's from blackle\n}\n\nfloat sphere(vec3 samplePoint, float r) {\n    return length(samplePoint) - r;\n}\n\nfloat orbsSDF(vec3 samplePoint) {\n    return 0.;\n}\n\nfloat cube(vec3 samplePoint, float r) {\n    vec3 q = abs(samplePoint) - r;\n    return length(max(q,0.)) + min(max(q.x,max(q.y,q.z)),0.);\n}\n\nfloat cylinder(vec3 samplePoint, float r) {\n    vec2 d = abs(vec2(length(samplePoint.xz),samplePoint.y)) - vec2(r, r);\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nvec3 domain(vec3 samplePoint) {\n    vec2 xz = floor(samplePoint.xz+0.5)-0.5;\n    return vec3(xz.x, 0., xz.y);\n}\n\nvec3 posInDomain(vec3 samplePoint) {\n    vec2 xz = fract(samplePoint.xz+0.5)-0.5;\n    return vec3(xz.x, samplePoint.y, xz.y);\n}\n\nfloat worstFloorSDF(vec3 samplePoint) {\n    vec2 distanceToEdges = 0.55 - abs(posInDomain(samplePoint).xz);\n    return length(vec2(\n                min(distanceToEdges.x, distanceToEdges.y),\n                max(0., samplePoint.y - 1.)\n                ));\n}\n\nfloat sawtoothAnimation(float speed) {\n    float phase = fract((iTime+2.) * (0.3+0.5*speed));\n    float springPortion = 0.08;\n    return 1.-(smoothstep(0.4, 1., 1.-min(phase/springPortion, 1.))+phase);\n}\n\nfloat sinAnimation(float speed) {\n    float phase = fract((iTime+2.) * (0.3+0.5*speed));\n    return sin(mod(phase*PI*2., 2.*PI))*0.5+0.5;\n}\n\nfloat accurateFloorSDF(vec3 samplePoint) {\n    float speed = hash(domain(samplePoint)).x;\n    float animation = hash(domain(samplePoint)).y > 0.5 ? sawtoothAnimation(speed) : sinAnimation(speed);\n    vec3 movedPoint = vec3(\n            fract(samplePoint.x+0.5)-0.5,\n            samplePoint.y-0.5+0.8*animation, \n            fract(samplePoint.z+0.5)-0.5\n            );\n    if (hash(domain(samplePoint)).z > 0.5) {\n        return cylinder(movedPoint, 0.4);\n    } else {\n        return cube(movedPoint, 0.4);\n    }\n}\n\nfloat floorSDF(vec3 samplePoint) {\n    return min(samplePoint.y, min(worstFloorSDF(samplePoint), accurateFloorSDF(samplePoint)));\n}\n\nfloat scene(vec3 samplePoint) {\n    return floorSDF(samplePoint);\n}\n\nfloat cheat(float y, vec3 direction) {\n    float height = y - 1.;\n    if (height < 0.) {\n        return 0.;\n    }\n    float mult = height/direction.y;\n    return length(vec3(height, direction.x*mult, direction.z*mult));\n}\nfloat sceneCheat(vec3 samplePoint, vec3 direction) {\n    return max(\n            scene(samplePoint),\n            cheat(samplePoint.y, direction)\n            );\n}\n\nvec3 rayDirection(vec2 fragCoord, vec2 image_size, float fov) {\n    vec2 xy = fragCoord.xy - image_size.xy / 2.;\n    float z = min(image_size.x, image_size.y) / tan(radians(fov) / 2.); // we don't need length(xy) here because fov just refers to the fov of a single axis\n    return normalize(vec3(xy, -z));\n}\n\nfloat shortestDistance(vec3 cameraPosition, vec3 rayDirection) {\n    float len = MIN_RAY_LEN;\n    for (int i=0; i < MAX_STEPS; i++) {\n        float dist = sceneCheat(cameraPosition + len * rayDirection, rayDirection);\n        // isn't there a better way than just getting infinitesimally closer till we're within some tiny radius?\n        // if we figured out the normal when we get close to the final surface, couldn't we extrapolate an expected point of intersection that way? then jump up to that, but allow the loop to continue in case we're just grazing past\n        if (dist < RAY_HIT_THRESH) {\n            return len + dist;\n        }\n        len += dist;\n        if (len >= MAX_RAY_LEN) {\n            return MAX_RAY_LEN;\n        }\n    }\n    return MAX_RAY_LEN;\n}\n\nvec3 normal(vec3 p) {\n    float original_dist = scene(p);\n    // we lose a little precision by not having our normal centered on the target point but rather sticking out a bit by RAY_HIT_THRESH, but we're saving 2 SDF evaluations\n    return normalize(vec3(\n        scene(vec3(p.x + RAY_HIT_THRESH, p.y, p.z)) - original_dist,\n        scene(vec3(p.x, p.y + RAY_HIT_THRESH, p.z)) - original_dist,\n        scene(vec3(p.x, p.y, p.z + RAY_HIT_THRESH)) - original_dist\n    ));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    float time = iTime*2.;\n    vec3 cameraPosition = vec3(-time, 1.5+(cos(mod(time/23., 2.*PI))*0.5+0.5)*2., -time);\n    vec3 dir = rotateAxis(\n            rotateAxis(\n                rayDirection(fragCoord, iResolution.xy, 140.), vec3(-1., 0., 0.), PI*((sin(mod(time/12.+PI/2., 2.*PI))*0.5+0.5)*0.3+0.2)\n                ),\n            vec3(0., 1., 0.), PI*0.25\n            );\n    float dist = shortestDistance(cameraPosition, dir);\n    vec3 point = cameraPosition + dist * dir;\n    vec3 normal = normal(point);\n    vec3 domainDir = normalize(abs(cameraPosition - domain(point)));\n    float brightness = max(0., abs(dot(domainDir, normal)));\n    brightness = round(brightness*8.)/8.;\n    vec3 color = pow(vec3(pow(brightness, 1.1)*1.2, brightness*0.6, brightness*0.8+0.15), vec3(2.0));\n    fragColor = vec4(dist >= MAX_RAY_LEN ? vec3(0) : color, 1.);\n}\n\n#ifndef shadertoy\nvoid main() {\n    mainImage(fragColor, fragCoord.xy);\n}\n#endif\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/7d2GRG.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "7d2GRK", "name": "Dilbert2", "author": "SnoopethDuckDuck", "description": "*waves*\n\n( did look cooler but I accidentally deleted it :| )", "tags": ["cool"], "likes": 8, "viewed": 96, "date": "1617670933", "time_retrieved": "2024-06-20T20:36:04.643918", "image_code": "float random (vec2 st) {\n    return fract(sin(dot(st.xy,\n                         vec2(12.9898,78.233)))*\n        43758.5453123);\n}\n\nconst float pi = 3.14159;\nconst float pi2 = 2. * pi / 3.;\nconst float pi3 = 4. * pi / 3.;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n // float b = 0.5 * (1. + cos( iTime / 9.));\n//uv = b * uv + (1.-b ) *floor( 128. * uv) / 128.;\nvec2 dir = uv.xy + (0.1 + 0.05 * cos(0.05 *iTime)) * cos(10. * uv.xx + 0.5 * iTime) - 0.5;\nfloat t = 0.2 * iTime;\nfloat l = pow(cos( 2. * t / 3.),2.);\nfloat d = (10. * l + 2. * (1. - l))* length(dir);\n//d = b * d + (1.-b ) *floor ( 2. * d) / 2.;\nfloat theta =  atan( dir.y,dir.x);\n\nfloat val =  sin(acos(sin(uv.y - t ) * sin(1. * theta+t)));\nfloat val2 =  sin(acos(sin(uv.y - t + pi2) * sin(2. * theta +t )));\nfloat val3 = sin(acos(sin(uv.y - t + pi3) * sin(3. * theta + t )));\n    // Time varying pixel color\n   // float r = random(uv.xx) * ( (1.-l) * d + l * 16. * d * (1.-d)  *(1. -d) * d);\n    float r = random(uv.xx) * d * d * d;\n    vec3 col = vec3(\n    smoothstep(val, r ,  sqrt(val2 * val3)),\n    smoothstep(val2,r ,  sqrt(val * val3)),\n    smoothstep(val3,r ,  sqrt(val* val2))    \n    );\n    \n    float q = 0.5 * (1. + cos(t / 3.));\n    col = vec3(col.x + q * col.y, col.y + q * col.z, col.z + q * col.x);\n    //col = vec3(min(col.x, col.y),min(col.y, col.z),min(col.z, col.x));\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/7d2GRK.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "7dB3DW", "name": "C64 Dithering", "author": "winden", "description": "c64 noised quantization + tuning of brigthness & colours via YUV-inspired separations.", "tags": ["noise", "c64", "quantization", "yuv"], "likes": 4, "viewed": 57, "date": "1617399926", "time_retrieved": "2024-06-20T20:36:05.189462", "image_code": "\n#define RGB(r,g,b) (vec3(r,g,b) / 255.0)\n\n#define PALETTE_SIZE 16\n\n\nvec3 palette[PALETTE_SIZE];\n\n\n//Initalizes the color palette.\nvoid InitPalette()\n{\n    //16-Color C64 color palette.\n\tpalette = vec3[](\n        RGB(  0,  0,  0),\n        RGB(255,255,255),\n        RGB(152, 75, 67),\n        RGB(121,193,200),\t\n        RGB(155, 81,165),\n        RGB(104,174, 92),\n        RGB( 62, 49,162),\n        RGB(201,214,132),\t\n        RGB(155,103, 57),\n        RGB(106, 84,  0),\n        RGB(195,123,117),\n        RGB( 85, 85, 85),\t\n        RGB(138,138,138),\n        RGB(163,229,153),\n        RGB(138,123,206),\n        RGB(173,173,173)\n\t);\n}\n\nfloat rgb2y(in vec3 src) {\n  return (77.0 * src.r + 150.0 * src.g + 25.0 * src.b) / 255.0;\n}\n\nvec3 nearestColor( in vec3 src, in vec2 pos )\n{\n  float src_br = rgb2y(src);\n  vec3 src_grey = vec3(src_br);\n  vec3 src_col = src - src_grey;\n\n  float amount = 0.45;\n\n  vec3 noise = texture( iChannel0 , pos / 64.0 , 1.5).xyz;\n  noise -= vec3(0.5);\n\n  vec3 dither = vec3(0.0);\n\n  int px = int(mod(pos.x + pos.y, 6.0) / 3.0);\n  int py = int(mod(pos.y - pos.x, 6.0) / 3.0);\n  int pxy = (px << 1) + py;\n  if (pxy == 0) {\n    dither.g += 0.5;\n  } else if (pxy == 1) {\n    dither.r += 0.5;\n    dither.b -= 0.5;\n  } else if (pxy == 2) {\n    dither.r -= 0.5;\n    dither.b += 0.5;\n  } else if (pxy == 3) {\n    dither.g -= 0.5;\n  }\n  vec3 col = src + (2.5 * noise - 0.5 * dither) * amount;\n\n\n  vec3 nearest_delta;\n  int nearest = -1;\n  float nearest_dist = 100000.0;\n  for (int i = 0 ; i < PALETTE_SIZE ; i++) {\n     vec3 delta = col - palette[i];\n     float dist = length(delta);\n     if (dist < nearest_dist) {\n       nearest = i;\n       nearest_delta = delta;\n       nearest_dist = dist;\n     }\n  }\n  vec3 dst = palette[nearest];\n  float k = 0.75 * clamp(pow(nearest_dist, 3.1), 0.0, 0.25);\n  dst = dst - normalize(nearest_delta) * 0.85 * k;\n\n  float dst_br = rgb2y(dst);\n  \n  \n  vec3 dst_grey = vec3(dst_br);\n  vec3 dst_col = dst - dst_grey;\n  \n  return mix(dst, dst_grey, 0.3);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    InitPalette();\n\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Time varying pixel color\n    vec3 col = 0.5 + 0.5*cos(iTime*.75+4.0*uv.xyx*vec3(2,1,3));\n\n    // Remap to C64.\n    col = nearestColor(col, fragCoord);\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": "XdXGzn", "previewfilepath": "/media/ap/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/7dB3DW.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "7dB3Wd", "name": "Twisty chocolate-bar torus", "author": "MacSlow", "description": "Just a torus with a custom cross-section, which rotates. I wish one could buy candy-bars like this :) You can orbit around the torus with the mouse.", "tags": ["3d", "phong", "torus", "candy"], "likes": 11, "viewed": 231, "date": "1618105976", "time_retrieved": "2024-06-20T20:36:06.577326", "image_code": "////////////////////////////////////////////////////////////////////////////////\n//\n// Twisty chocolate-bar torus - some version of eye-candy ;)\n//\n// Copyright 2021 Mirco Müller\n//\n// Author(s):\n//   Mirco \"MacSlow\" Müller <macslow@gmail.com>\n//\n// This program is free software: you can redistribute it and/or modify it\n// under the terms of the GNU General Public License version 3, as published\n// by the Free Software Foundation.\n//\n// This program is distributed in the hope that it will be useful, but\n// WITHOUT ANY WARRANTY; without even the implied warranties of\n// MERCHANTABILITY, SATISFACTORY QUALITY, or FITNESS FOR A PARTICULAR\n// PURPOSE.  See the GNU General Public License for more details.\n//\n// You should have received a copy of the GNU General Public License along\n// with this program.  If not, see <http://www.gnu.org/licenses/>.\n//\n////////////////////////////////////////////////////////////////////////////////\n\n// lower AA_SIZE to 2 or 1, if it runs too slow\nconst int AA_SIZE = 3;\nconst float PI = 3.14159265359;\nconst int MAX_ITER = 64;\nconst float STEP_BIAS = .75;\nconst float EPSILON = .0001;\nconst float MAX_DIST = 25.;\n\nmat2 r2d (float rad)\n{\n    float c = cos (rad);\n    float s = sin (rad);\n\n    return mat2 (c, s, -s, c);\n}\n\nfloat sdBox2D (vec2 p, vec2 size, float r)\n{\n    vec2 q = abs(p) - size;\n    return length(max(q,0.0)) + min(max(q.x, q.y),0.0) - r;\n}\n\nfloat sdTorus (vec3 p, vec3 q)\n{\n    float offset = q.x;\n    float r1 = q.y;\n    float r2 = q.z;\n\n    float angle = atan (p.x, p.z);\n\n    vec2 t = vec2 (length (p.xz) - r1, p.y);\n\n    t *= r2d (3.*angle);\n    t.y = abs (t.y) - offset;\n\n    float r = r2*(1. + .5*(cos(3.*angle)));\n    t *= r2d (iTime);\n    float doubleRectProfile = sdBox2D (t, vec2 (.08, .03), r*.75);\n\n    return doubleRectProfile;\n}\n\nfloat scene (vec3 p)\n{\n    float ground = p.y + 1.;\n\n    float offset = .2;\n    float r1 = 1.;\n    float r2 = .1;\n    float torus = sdTorus (p, vec3 (offset, r1, r2));\n\n    float d = min (torus, ground); \n\n    return d;\n}\n\nfloat raymarch (vec3 ro, vec3 rd)\n{\n    float t = .0;\n    float d = .0;\n    vec3 p = vec3 (.0);\n    int i = 0;\n\n    for (; i < MAX_ITER; ++i) {\n        p = ro + d*rd;\n        t = scene (p);\n        if (abs (t) < EPSILON*(1. - .125*t) || d > MAX_DIST) break;\n        d += t*STEP_BIAS;\n    }\n\n    return d;\n}\n\nvec3 normal (vec3 p)\n{\n    vec2 e = vec2 (EPSILON, .0);\n    float d = scene (p);\n    return normalize (vec3 (scene (p + e.xyy),\n                            scene (p + e.yxy),\n                            scene (p + e.yyx)) - d);\n}\n\nvec3 camera (vec2 uv, vec3 ro, vec3 aim, float zoom)\n{\n    vec3 camForward = normalize (aim - ro);\n    vec3 worldUp = vec3 (.0, 1., .0);\n    vec3 camRight = normalize (cross (camForward, worldUp));\n    vec3 camUp = normalize (cross (camRight, camForward));\n    vec3 camCenter = camForward*zoom + ro;\n\n    return normalize (camCenter + uv.x*camRight + uv.y*camUp - ro);\n}\n\nfloat shadow (vec3 p, vec3 n, vec3 lPos, vec3 lDir)\n{\n    float distToWorld = raymarch (p + .01*n, lDir);\n    float distToLight = distance (p, lPos);\n\n    return distToWorld < distToLight ? .3 : 1.;\n}\n\nfloat ao (vec3 p, vec3 n, float stepSize, int iterations, float intensity)\n{\n  float ao = .0; \n  float dist = .0; \n\n  for (int a = 1; a <= iterations; ++a) {\n    dist = float (a)*stepSize;\n    ao += max (.0, (dist - scene (p + n*dist))/dist);\n  }\n\n  return 1. - ao*intensity;\n}\n\nvec3 shade(vec3 ro, vec3 rd, float d, vec3 n)\n{\n    vec3 p = ro + d*rd;\n\n    vec3 lPos1 = vec3 (4.*cos(iTime), 2., 4.*sin(.4*iTime));\n    vec3 lDir1 = normalize (lPos1 - p);\n    float lDist1 = distance (lPos1, p);\n    float attn1 = 50. / (lDist1*lDist1);\n    vec3 lColor1 = 5.*vec3 (1., .9, .3);\n\n    vec3 lPos2 = vec3 (6.*cos(.3*iTime), 1., 6.*sin(iTime));\n    vec3 lDir2 = normalize (lPos2 - p);\n    float lDist2 = distance (lPos2, p);\n    float attn2 = 60. / (lDist2*lDist2);\n    vec3 lColor2 = 7.*vec3 (.2, .4, 1.);\n\n    vec3 amb = vec3 (.1); \n    float diff1 = max (dot (n, lDir1), .0);\n    float diff2 = max (dot (n, lDir2), .0);\n    vec3 h1 = normalize (lDir1 - rd);\n    vec3 h2 = normalize (lDir2 - rd);\n    float spec1 = pow (max (dot (h1, n), .0), 40.);\n    float spec2 = pow (max (dot (h2, n), .0), 40.);\n\n    float s1 = shadow (p, n, lPos1, lDir1);\n    float s2 = shadow (p, n, lPos2, lDir2);\n\n    float ao = ao (p, n, .05, 12, .1);\n\n    // don't do material assignment like this, this is a super lazy-ass hack!\n    vec3 torusMaterial = 1.5*vec3(.2, .1, .05);\n    bool isFloor = (p.y < -.5);\n    float phase = cos (20.*(p.x + iTime));\n    float mask = smoothstep (.005*d, .0025*d, .5 + .5*phase);\n    vec3 floorMaterial = 1.5*mix (vec3(.9), vec3 (.1), mask);\n    vec3 diffMaterial = isFloor ? floorMaterial : torusMaterial;\n\n    return amb + ao*(attn1*s1*(diff1*diffMaterial*lColor1 + spec1) +\n                     attn2*s2*(diff2*diffMaterial*lColor2 + spec2));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float dist2cam = 3.;\n    float azimuthAngle = ((iMouse.x/iResolution.x) * 2. - 1.) * 179.;\n    float elevationAngle = 20. + ((iMouse.y/iResolution.y) * 2. - 1.) * -30.;\n    float x = dist2cam*cos (radians (azimuthAngle));\n    float y = dist2cam*sin (radians (elevationAngle));\n    float z = dist2cam*sin (radians (azimuthAngle));\n\n    vec2 uv = fragCoord.xy/iResolution.xy;\n    uv = uv*2. - 1.;\n    uv.x *= iResolution.x/iResolution.y;\n    vec3 ro = vec3 (x, y, z);\n\tfloat fog = .0;\n\tfloat d = .0;\n\tvec3 aim = vec3 (.0);\n\tfloat zoom = 2.5;\n    vec3 color = vec3 (.0);\n\n\tfor (int x = 0; x < AA_SIZE; ++x) {\n\t\tfor (int y = 0; y < AA_SIZE; ++y) {\n\n\t\t\t// anti-alias offset\n\t\t\tvec2 pixelOffset = vec2 (float (x), float (y))/float  (AA_SIZE);\n\n\t\t\t// normalize and aspect-correct UVs\n\t\t\tuv = (fragCoord.xy/iResolution.xy + pixelOffset/iResolution.xy);\n    \t\tuv = uv*2. - 1.;\n            uv.x *= iResolution.x/iResolution.y;\n\n    \t\t// create viewray\n    \t\tvec3 rd = camera (uv, ro, aim, zoom);\n\n\t\t\t// primary/view ray\n\t\t\td = raymarch (ro, rd);\n\t\t\tfog = 1. / (1. + d*d*.075);\n\t\t\tvec3 p = ro + d*rd;\n\t\t\tvec3 n = normal (p);\n\t\t\tvec3 ctmp = shade (ro, rd, d, n);\n\t\t\tctmp *= fog;\n\n\t\t\tcolor += ctmp;\n\t\t}\n\t}\n\tcolor /= float (AA_SIZE*AA_SIZE);\n\n    // distance-mist, vignette, tone-map, gamma-correct\n\tcolor = mix (color, vec3 (.2, .35, .7), pow (1. - 1./d, 90.));\n    color *= 1. - .25*dot (uv, uv);\n    color = color / (1. + color);\n    color = .2*color + .8*sqrt (color);\n\n    fragColor = vec4(color, 1.);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/7dB3Wd.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "7dB3Wy", "name": "Flying Vectorama logoish thing", "author": "eimink", "description": "Vectorama is a lanparty held in Oulu, Finland. Their logo is a penrose triangle. Virtuaalirama is online version of that.\nGrid coloring and inspiration from Flyguy's awesome work at https://www.shadertoy.com/view/4dt3RX", "tags": ["sdf"], "likes": 0, "viewed": 71, "date": "1617981480", "time_retrieved": "2024-06-20T20:36:06.583537", "image_code": "#define line1 V_ I_ R_ T_ U_ A_ A_ L_ I_ R_ A_ M_ A_\n#define M_PI 3.14159\n#define GRID_SIZE 2.0\n#define GRID_LINE_SIZE 1.25\n#define GRID_COLOR_1 vec3(0.00, 0.05, 0.20)\n#define GRID_COLOR_2 vec3(1.00, 0.20, 0.60)\n#define SPEED 20.0\n\n#define GROUND 1.0\n#define FLYER 2.0\n#define BACKDROP 3.0\n#define TEXT 4.0\n\n#define RENDER_TEXT true\n\nvec3 glow = vec3(0.);\n\nfloat line(vec2 p, vec2 a, vec2 b)\n{\n\tvec2 pa = p - a;\n\tvec2 ba = b - a;\n\tfloat h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\n    return length(pa - ba * h);\n}\n\nfloat _u(vec2 uv, float w, float v) {\n    return length(vec2(\n                abs(length(vec2(uv.x,\n                                max(0.0,-(.4-v)-uv.y) ))-w)\n               ,max(0.,uv.y-.4)));\n}\nfloat _i(vec2 uv) {\n    return length(vec2(uv.x,max(0.,abs(uv.y)-.4)));\n}\nfloat _j(vec2 uv) {\n    uv.x+=.2;\n    uv.y+=.55;\n    float x = uv.x>0.&&uv.y<0.?\n                abs(length(uv)-.25)\n               :min(length(uv+vec2(0.,.25)),\n                    length(vec2(uv.x-.25,max(0.,abs(uv.y-.475)-.475))));\n    return x;\n}\nfloat _l(vec2 uv) {\n    uv.y -= .2;\n    return length(vec2(uv.x,max(0.,abs(uv.y)-.6)));\n}\nfloat _o(vec2 uv) {\n    return abs(length(vec2(uv.x,max(0.,abs(uv.y)-.15)))-.25);\n}\n\nfloat AA(vec2 uv) {\n    float x = length(vec2(\n                abs(length(vec2(uv.x,\n                                max(0.0,uv.y-.35) ))-0.25)\n               ,min(0.,uv.y+.4)));\n    return min(x,length(vec2(max(0.,abs(uv.x)-.25),uv.y-.1) ));\n}\nfloat II(vec2 uv) {\n    uv.y -= .1;\n    float x = length(vec2(uv.x,max(0.,abs(uv.y)-.5)));\n    uv.y = abs(uv.y);\n    return min(x,length(vec2(max(0.,abs(uv.x)-.1),uv.y-.5)));\n}\nfloat LL(vec2 uv) {\n    uv.y -=.1;\n    float x = length(vec2(max(0.,abs(uv.x)-.2),uv.y+.5));\n    return min(x,length(vec2(uv.x+.2,max(0.,abs(uv.y)-.5))));\n}\nfloat MM(vec2 uv) {\n    uv.y-=.1;\n    float x = min(length(vec2(uv.x-.35,max(0.,abs(uv.y)-.5))),\n                  line(uv,vec2(-.35,.5),vec2(.0,-.1)));\n    x = min(x,line(uv,vec2(.0,-.1),vec2(.35,.5)));\n    return min(x,length(vec2(uv.x+.35,max(0.,abs(uv.y)-.5))));\n}\nfloat RR(vec2 uv) {\n    float x = length(vec2(\n                abs(length(vec2(max(0.0,uv.x),\n                                 uv.y-.35))-0.25)\n               ,min(0.,uv.x+.25)));\n    x = min(x,length(vec2(uv.x+.25,max(0.,abs(uv.y-.1)-.5)) ));\n    return min(x,line(uv,vec2(0.0,0.1),vec2(0.25,-0.4)));\n}\nfloat TT(vec2 uv) {\n    uv.y -= .1;\n    float x = length(vec2(uv.x,max(0.,abs(uv.y)-.5)));\n    return min(x,length(vec2(max(0.,abs(uv.x)-.25),uv.y-.5)));\n}\nfloat UU(vec2 uv) {\n    float x = length(vec2(\n                abs(length(vec2(uv.x,\n                                min(0.0,uv.y+.15) ))-0.25)\n               ,max(0.,uv.y-.6)));\n    return x;\n}\nfloat VV(vec2 uv) {\n    uv.x=abs(uv.x);\n    return line(uv,vec2(0.25,0.6), vec2(0.,-0.4));\n}\n\n#define ch(l,w) x = min(x,l(clc(pp,cp+=w,w)));\n\n#define A_ ch(AA,0.7);\n#define I_ ch(II,0.5);\n#define L_ ch(LL,0.5);\n#define M_ ch(MM,0.9);\n#define R_ ch(RR,0.7);\n#define V_ ch(VV,0.7);\n#define T_ ch(TT,0.7);\n#define U_ ch(UU,0.7);\n\nvec2 clc(vec2 uv, float cp, float w) {\n    return uv-vec2(cp-(w*.5),0.);\n}\n\nstruct MarchResult\n{\n    vec3 position;\n    vec3 normal;\n    float dist;\n    float steps;\n    float id;\n};\n\nfloat sdPlane( vec3 p, vec3 n, float h )\n{\n  return dot(p,normalize(n)) + h;\n}\n\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat sdTriPrism( vec3 p, vec2 h )\n{\n  vec3 q = abs(p);\n  return max(q.z-h.y,max(q.x*0.866025+p.y*0.5,-p.y)-h.x*0.5);\n}\n\nvoid rot(inout vec2 p, float a) {\n    p = cos(a)*p + sin(a)*vec2(p.y, -p.x);\n}\n\n\nfloat text(vec3 p){\n   p = vec3(p.x-4.5,p.y-5.,p.z+2.+iTime*SPEED);\n   rot(p.xz,M_PI);\n   rot(p.yz,-.3);\n   vec2 pp = p.xy;\n   float cp = 0.;\n   float x = 1.;\n   line1;\n   vec3 bd = vec3(9.,1.,0.2);\n   float res = max(x,sdBox(p,bd));\n   return res;\n}\n\nfloat backdrop(vec3 p){\n    vec3 pp = vec3(p.xy,p.z+51.+iTime*SPEED);\n    rot(pp.xz,M_PI*.5);\n    float a = sdPlane(pp,vec3(1.,0.,0.),10.);\n    return a;\n}\n\nfloat ground(vec3 p){\n   float a = sdPlane(p,vec3(0.,1.,-0),15.);\n   float b = sdPlane(p,vec3(.5,1,0.),20.);\n   float c = sdPlane(p,vec3(-.5,1,0.),20.);\n   float d = cos(p.x*.04)*8.+(sin(p.z*.5)+cos(p.x*.3)+sin(p.y*.5))*1.2;\n   return min(a,min(b,c));\n}\n\nvec2 opU(vec2 d1, vec2 d2)\n{\n    return (d1.x < d2.x) ? d1 : d2;\n}\n\nvec2 scene2(vec3 p) {\n   vec3 pp = vec3(p.x-sin(iTime)*5.-sin(2.*iTime),(p.y-sin(iTime*.5)*2.)+2.,p.z+3.0+iTime * SPEED);\n   rot(pp.xy,M_PI);\n   rot(pp.yz,-M_PI*.5);\n   rot(pp.xz,sin(iTime)+cos(iTime*.5));\n   float prism = sdTriPrism(pp,vec2(3.,.6));\n   float prism2 = sdTriPrism(pp,vec2(4.,.5));\n   vec2 gnd = vec2(ground(p),GROUND);\n   vec2 flyer = vec2(max(-prism,prism2),FLYER);\n   glow += vec3(0.6,0.1,0.1)*0.025/(0.5+abs(prism));\n   vec2 backdr = vec2(backdrop(p),BACKDROP);\n   vec2 res = opU(opU(gnd,flyer),backdr);\n   if (RENDER_TEXT == true) {\n       vec2 txt = vec2(text(p),TEXT);\n       res = opU(res,txt);\n   }\n   return res;\n}\n\nvec3 calcNormal( in vec3 pos) \n{\n    vec2 e = vec2(0.00001, 0.0);\n    return normalize( vec3(scene2(pos+e.xyy).x-scene2(pos-e.xyy).x,\n                           scene2(pos+e.yxy).x-scene2(pos-e.yxy).x,\n                           scene2(pos+e.yyx).x-scene2(pos-e.yyx).x ) );\n}\n\nMarchResult raymarch(in vec3 ro, in vec3 rd) {\n    vec3 p = ro+rd;\n    float s = 0.;\n    float id = GROUND;\n    float t = 0.;\n    for (int i = 0; i < 40; ++i){\n        vec2 d = scene2(p);\n        t += d.x;\n        p += rd*d.x;\n        s = float(i);\n        id = d.y;\n        if(d.x < 0.01 || t > 100.){\n            break;\n        }\n    }\n    MarchResult res;\n    res.position = p;\n    res.normal = calcNormal(p);\n    res.dist = t;\n    res.steps = s;\n    res.id = id;\n    \n    return res;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    vec3 cp = vec3(0.,4.,10.-iTime * SPEED);\n    vec3 ct = vec3(0,0,0.-iTime * SPEED);\n    vec3 ld = vec3(0.,15.,100. + iTime * SPEED);\n\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 q = -1.0+2.0*uv;\n    q.x *= iResolution.x/iResolution.y;\n    \n    vec3 cf = normalize(ct-cp);\n    vec3 cr = normalize(cross(vec3(0.0,1.0,0.0),cf));\n    vec3 cu = normalize(cross(cf,cr));\n    \n    vec3 rd = normalize(mat3(cr,cu,cf)*vec3(q,radians(90.0)));\n    \n    vec3 p = vec3(0.0);\n    \n    float t;\n    MarchResult m = raymarch(cp,rd);\n    \n    t = m.dist;\n    p = m.position;\n    vec3 col = vec3(0.0);\n    if(t < 100.){\n        if (m.id == FLYER) {\n            col = vec3(abs(cos(p.z*.1)),.4,abs(sin(p.z*.1))) + (clamp(dot(m.normal, ld), 0.0, 1.0)*0.1);\n        }\n        if (m.id == GROUND) {\n            vec2 uv2 = abs(mod(p.xz + GRID_SIZE/2.0, GRID_SIZE) - GRID_SIZE/2.0); \n            uv2 /= fwidth(p.xz);\n            float gln = min(uv2.x, uv2.y) / GRID_SIZE;       \n            col = mix(GRID_COLOR_1, GRID_COLOR_2, 1.0 - smoothstep(0.0, GRID_LINE_SIZE / GRID_SIZE, gln));\n        }\n        else if (m.id == BACKDROP) {\n            float th = 1.5+p.y*0.09;\n            col =  mix(mix(mix(vec3(1.0,.3,0.),vec3(.9,0.,0.),th),vec3(1.,0.,.4),th-1.3),vec3(0.,0.,0.4),th-1.8);\n        }\n        else if (m.id == TEXT) {\n            col = vec3(1.0,.8,0.);\n        }\n        \n        \n    }\n    col += glow;\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/7dB3Wy.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "7dBGDm", "name": "Mandelbrot Trippy", "author": "x44203", "description": "Mandelbrot set with color animation", "tags": ["math", "mandelbrot", "art"], "likes": 2, "viewed": 38, "date": "1617485241", "time_retrieved": "2024-06-20T20:36:06.856267", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float pi = 3.1415927;\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord.yx/iResolution.yx - 0.5) * 4.0;\n    vec2 mouse = (iMouse.yx/iResolution.yx - 0.5) * 4.0;\n    \n    float angle = atan(uv.y, uv.x);\n    float radius = sqrt(dot(uv.xy, uv.xy));\n    \n    angle += sin(iTime);\n    \n    //float m_angle = mod(angle, pi / (3.0 + sin(iTime * 2.3)));\n    float m_angle = mod(angle, pi / (2.0 + 1. / (sin(iTime * 2.3) * 0.5 + 0.55)));\n    \n    float f_angle = angle - m_angle;\n    \n    angle = m_angle + mod(iTime, 2.0 * pi) * (sin(iTime * 1.0) * 0.1 + 1.0) + f_angle * 2.0 * cos(iTime * 1.8);\n    \n    uv = vec2(sin(angle), cos(angle)) * radius;\n    \n    uv -= mouse + 0.0;\n\n    // Time varying pixel color\n    //vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n    \n    float x = 0.0;\n    float y = 0.0;\n    int iter = 0;\n    \n    while (x * x + y * y <= 4.0 * (1.0 + sin(iTime) * 0.0) && iter < 1000)\n    {\n        float xt = x * x - y * y + uv.x + x * sin(iTime * 1.3);\n        y = 2.0 * x * y + uv.y;\n        x = xt;\n        iter += 1;\n    }\n    \n    float val = float(iter) * cos(iTime * 0.5) + 0.2 * cos(iTime * 16.0) + m_angle + 10. * f_angle;\n\n    // Time varying pixel color\n    vec3 col = 0.5 + 0.5*vec3(sin(val / 5.0), sin(val / 3.0 + pi * 2.0 / 3.0), sin(sin(val / 10.0)));\n\n    // Output to screen\n    fragColor = vec4(col / (float(iter) * 0.01 + 1.0),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/7dBGDm.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "7dBGRc", "name": "Pyramidal shake", "author": "evvvvil", "description": "Winning shader made at Revision 2021 Shader Showdown quarter-final\nLive coded on stage in 25 minutes.  Designed beforehand in several hours.\n", "tags": ["reflection", "demoscene", "glow", "city", "scifi", "cut", "architecture", "pyramid", "electricity", "structure", "industrial", "building", "extrusion"], "likes": 19, "viewed": 233, "date": "1617729305", "time_retrieved": "2024-06-20T20:36:07.504572", "image_code": "// Winning shader made at Revision 2021 Shader Showdown Quarter-Final\n\n// The \"Shader Showdown\" is a demoscene live-coding shader battle competition.\n// 2 coders battle for 25 minutes making a shader on stage. No google, no cheat sheets.\n// The audience votes for the winner by making noise or by voting on their phone.\n\n// This shader was coded live on stage in 25 minutes. Designed beforehand in several hours.\n\nvec2 z,v,e=vec2(.00035,-.00035);float t,tt,I,b,bb,g=0.,tnoi,a,la,wa;vec3 np,pp,po,no,al,ld,cp;\nfloat bo(vec3 p, vec3 b ){ p= abs(p)-b;return max(max(p.x,p.y),p.z);}\nmat2 r2(float r){return mat2(cos(r),sin(r),-sin(r),cos(r));}\nfloat ex(vec3 p,float sdf,float h){vec2 w=vec2(sdf,abs(p.y)-h);return min(max(w.x,w.y),0.0)+length(max(w,0.0));}\nfloat oc(vec3 p,float s){p=abs(p);return (p.x+p.y+p.z-s)*0.57735;}\nvec4 texNoise(vec2 uv,sampler2D tex ){ float f = 0.; f+=texture(tex, uv*.125).r*.5; f+=texture(tex,uv*.25).r*.25;\n                       f+=texture(tex,uv*.5).r*.125; f+=texture(tex,uv*1.).r*.125; f=pow(f,1.2);return vec4(f*.45+.05);}\nvec2 mp( vec3 p)\n{\n  vec2 h=vec2(1000,3),t=vec2(1000,5);  \n  np=vec3(p.xz*.3,.5); \n  wa=(1.-b)*sin(3.*length(p.xz*.1)-tt*5.);\n  for(int i=0;i<4;i++){    I=float(i);\n    np.xy=abs(np.xy)-2.4;    \n    np.xy*=r2(.785*(I+1.));\n    np*=1.6;\n    np.y=abs(np.y)-1.;  \n    bb=i==3?9.:6.;        \n    a=ex(p,bo(np.xyx,vec3(6.5,(.14-clamp(sin(np.x*2.),-.2,.2)*.2)*(I+1.),6.5))/np.z,bb-I*.5);\n    a=max(abs(a)-.05,abs(p.y)-(bb-.5)+I*.5);    \n    if(i>2) a=max(a,-(length(p.xy-vec2(0,10))-4.));\n    t.x=min(t.x,a);   \n    a=ex(p,bo(np.xyx,vec3(6.5,0,6.5))/np.z,bb-I*.5);\n    a=max(a,abs(p.y)-(bb-.5)+I*.5+.5-wa);\n    if(i>2) a=max(a,-(length(p.xy-vec2(0,10.+wa))-4.));\n    g+=0.1/(0.1+a*a*(400.-wa*399.));\n    t.x=min(t.x,a);    \n    a=ex(p,bo(np.xyx,vec3(6.5,.15*(I+1.),6.5))/np.z,bb-I*.5);    \n    a=max(abs(a)-.1,abs(p.y)-(bb-1.)+I*.5);\n    if(i>2) a=max(a,-(length(p.xy-vec2(0,10))-4.));\n    h.x=min(h.x,a);        \n  } \n  bb=sin(p.y-b*3.)*b;\n  h.x=min(h.x,bo(p,vec3(1.-bb,6.+5.*b,1.0-bb)));\n  t=t.x<h.x?t:h;    \n  tnoi=texNoise(p.xz*.05,iChannel0).r*1.5;  \n  h=vec2(p.y-4.5+cos(p.x*.2)*5.+cos(p.z*.5)-tnoi,7);  //terrain:  \n  t=t.x<h.x?t:h;  \n  h=vec2(max(oc(p,10.4),-6.0+p.y),6);  \n  pp=p;  \n  pp.xz*=r2(-b*3.14);\n  pp.y-=b*5.;  \n  h.x=min(h.x,max(oc(pp,10.4),6.1-pp.y));  \n  t=t.x<h.x?t:h;\n  cp=vec3(np.xy,p.y*2.);\n  return t;\n}\nvec2 tr( vec3 ro, vec3 rd,  int it)\n{\n  vec2 h,t=vec2(.1);\n  for(int i=0;i<it;i++){\n    h=mp(ro+rd*t.x);\n    if(t.x<.0001||t.x>40.) break;\n    t.x+=h.x;t.y=h.y;\n  }\n  if(t.x>40.) t.y=0.;\n  return t;\n}\n#define a(d) clamp(mp(po+no*d).x/d,0.,1.)\n#define s(d) smoothstep(0.,1.,mp(po+ld*d).x/d)\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2 uv=(fragCoord.xy/iResolution.xy-0.5)/vec2(iResolution.y/iResolution.x,1);\n  tt=mod(iTime,62.82)+6.5;\n  b=smoothstep(0.,1.,(clamp(sin(tt),-.2,.2)*2.5+.5));\n  vec3 ro=mix(vec3(sin(tt*.5),11.-cos(tt)*5.,cos(tt*.5)*20.),\n          vec3(sin(tt*.5)*7.,10.-cos(tt),cos(tt*.5)*7.),ceil(sin(tt*.5)));\n  ro.xy-=sin(smoothstep(0.,1.,(clamp(cos(tt*.5-.25),-.2,.2)*2.5+.5))*16.)*.4;\n  vec3 cw=normalize(vec3(0,5,0)-ro),cu=normalize(cross(cw,vec3(0,1,0))),\n  cv=normalize(cross(cu,cw)),rd=mat3(cu,cv,cw)*normalize(vec3(uv,.5)),co,fo,rco;    \n  co=fo=vec3(.18,.16,.2)-length(uv)*.25;\n  ld=normalize(vec3(.1,.3,-.3));  \n  z=tr(ro,rd,128);t=z.x;\n  if(z.y>0.){   \n    v=cp.xz*.075;float d=1.;\n    for(int i=0;i<4;i++){\n        v=abs(v)-1.;\n        v*=r2(.785); v*=1.5;\n        d=min(d,ceil(abs(sin(v.x))-.05-clamp(sin(v.y*2.),-.1,.1)*.4));\n    }      \n    po=ro+rd*z.x;\n    no=normalize(e.xyy*mp(po+e.xyy).x+\n    e.yyx*mp(po+e.yyx).x+\n    e.yxy*mp(po+e.yxy).x+\n    e.xxx*mp(po+e.xxx).x);\n    al=mix(vec3(0.3,0.16,0.3),vec3(0.5),cp.y);\n    if(z.y<5.) al=vec3(0.);    \n    if(z.y>5.) al=vec3(0.5); \n    if(z.y>6.) al=mix(vec3(.5,.4,.3),vec3(.2,.2,.2),3.-tnoi*5.0);\n    float dif=max(0.,dot(no,ld)),\n    fr=pow(1.-abs(dot(no,rd)),4.),\n    sp=pow(max(dot(reflect(-ld,no),-rd),0.),40.);\n    co=mix(sp+al*(a(.1)+.2)*(dif+s(4.0)),fo,0.);    \n    co=mix(fo,co,exp(-.0002*t*t*t));\n    if(z.y==3.||z.y==6.){           \n        rd=reflect(rd,no);\n        z=tr(po+rd*0.01,rd,60);\n        \n        po=po+rd*z.x;\n            no=normalize(e.xyy*mp(po+e.xyy).x+\n            e.yyx*mp(po+e.yyx).x+\n            e.yxy*mp(po+e.yxy).x+\n            e.xxx*mp(po+e.xxx).x);\n            al=mix(vec3(0.3,0.16,0.3),vec3(0.5),cp.y);\n            if(z.y<5.) al=vec3(0.);    \n            if(z.y>5.) al=vec3(0.5); \n            if(z.y>6.) al=mix(vec3(.5,.4,.3),vec3(.2,.2,.2),3.-tnoi*5.0);\n            float dif=max(0.,dot(no,ld)),\n            sp=pow(max(dot(reflect(-ld,no),-rd),0.),40.);\n            rco=sp+al*(a(.1)+.2)*(dif+s(4.));    \n            rco=mix(fo,rco,exp(-.0002*z.x*z.x*z.x));\n        co+=(rco*(0.5+fr*.5)*d);\n        \n    }    \n  }\n  uv/=(1.-b)*fract(tt/(acos(-1.)*2.));\n  uv*=r2(-tt);\n  co*=min(1.,ceil(abs(bo(uv.xyx,vec3(.5)))-.1));\n  fragColor = vec4(pow(co+g*.1*vec3(.1,.2,.7),vec3(.55)),1);\n}", "image_inputs": [{"id": "Xsf3Rr", "previewfilepath": "/media/ap/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/7dBGRc.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "7dBGWK", "name": "未来空间", "author": "penghuailiang", "description": "利用 perlin 噪声画的未来空间", "tags": ["shader"], "likes": 1, "viewed": 137, "date": "1617948622", "time_retrieved": "2024-06-20T20:36:08.104686", "image_code": "// 利用 perlin 噪声\n\nvec3 mod289(vec3 x)\n{\n    return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 mod289(vec4 x)\n{\n    return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 permute(vec4 x)\n{\n    return mod289(((x*34.0)+1.0)*x);\n}\n\nvec4 taylorInvSqrt(vec4 r)\n{\n    return 1.79284291400159 - 0.85373472095314 * r;\n}\n\nvec3 fade(vec3 t) {\n    return t*t*t*(t*(t*6.0-15.0)+10.0);\n}\n\n\n// Classic Perlin noise\nfloat cnoise(vec3 P)\n{\n    vec3 Pi0 = floor(P); // Integer part for indexing\n    vec3 Pi1 = Pi0 + vec3(1.0); // Integer part + 1\n    Pi0 = mod289(Pi0);\n    Pi1 = mod289(Pi1);\n    vec3 Pf0 = fract(P); // Fractional part for interpolation\n    vec3 Pf1 = Pf0 - vec3(1.0); // Fractional part - 1.0\n    vec4 ix = vec4(Pi0.x, Pi1.x, Pi0.x, Pi1.x);\n    vec4 iy = vec4(Pi0.yy, Pi1.yy);\n    vec4 iz0 = Pi0.zzzz;\n    vec4 iz1 = Pi1.zzzz;\n\n    vec4 ixy = permute(permute(ix) + iy);\n    vec4 ixy0 = permute(ixy + iz0);\n    vec4 ixy1 = permute(ixy + iz1);\n\n    vec4 gx0 = ixy0 * (1.0 / 7.0);\n    vec4 gy0 = fract(floor(gx0) * (1.0 / 7.0)) - 0.5;\n    gx0 = fract(gx0);\n    vec4 gz0 = vec4(0.5) - abs(gx0) - abs(gy0);\n    vec4 sz0 = step(gz0, vec4(0.0));\n    gx0 -= sz0 * (step(0.0, gx0) - 0.5);\n    gy0 -= sz0 * (step(0.0, gy0) - 0.5);\n\n    vec4 gx1 = ixy1 * (1.0 / 7.0);\n    vec4 gy1 = fract(floor(gx1) * (1.0 / 7.0)) - 0.5;\n    gx1 = fract(gx1);\n    vec4 gz1 = vec4(0.5) - abs(gx1) - abs(gy1);\n    vec4 sz1 = step(gz1, vec4(0.0));\n    gx1 -= sz1 * (step(0.0, gx1) - 0.5);\n    gy1 -= sz1 * (step(0.0, gy1) - 0.5);\n\n    vec3 g000 = vec3(gx0.x,gy0.x,gz0.x);\n    vec3 g100 = vec3(gx0.y,gy0.y,gz0.y);\n    vec3 g010 = vec3(gx0.z,gy0.z,gz0.z);\n    vec3 g110 = vec3(gx0.w,gy0.w,gz0.w);\n    vec3 g001 = vec3(gx1.x,gy1.x,gz1.x);\n    vec3 g101 = vec3(gx1.y,gy1.y,gz1.y);\n    vec3 g011 = vec3(gx1.z,gy1.z,gz1.z);\n    vec3 g111 = vec3(gx1.w,gy1.w,gz1.w);\n\n    vec4 norm0 = taylorInvSqrt(vec4(dot(g000, g000), dot(g010, g010), dot(g100, g100), dot(g110, g110)));\n    g000 *= norm0.x;\n    g010 *= norm0.y;\n    g100 *= norm0.z;\n    g110 *= norm0.w;\n    vec4 norm1 = taylorInvSqrt(vec4(dot(g001, g001), dot(g011, g011), dot(g101, g101), dot(g111, g111)));\n    g001 *= norm1.x;\n    g011 *= norm1.y;\n    g101 *= norm1.z;\n    g111 *= norm1.w;\n\n    float n000 = dot(g000, Pf0);\n    float n100 = dot(g100, vec3(Pf1.x, Pf0.yz));\n    float n010 = dot(g010, vec3(Pf0.x, Pf1.y, Pf0.z));\n    float n110 = dot(g110, vec3(Pf1.xy, Pf0.z));\n    float n001 = dot(g001, vec3(Pf0.xy, Pf1.z));\n    float n101 = dot(g101, vec3(Pf1.x, Pf0.y, Pf1.z));\n    float n011 = dot(g011, vec3(Pf0.x, Pf1.yz));\n    float n111 = dot(g111, Pf1);\n\n    vec3 fade_xyz = fade(Pf0);\n    vec4 n_z = mix(vec4(n000, n100, n010, n110), vec4(n001, n101, n011, n111), fade_xyz.z);\n    vec2 n_yz = mix(n_z.xy, n_z.zw, fade_xyz.y);\n    float n_xyz = mix(n_yz.x, n_yz.y, fade_xyz.x); \n    return 2.2 * n_xyz;\n}\n\nvoid mainImage(out vec4 fragColor,in vec2 fragCoord)\n{\n    vec2 pos, res;\n    float mDist, n, r, g, b;\n    res = gl_FragCoord.xy / 512.0;\n    pos = gl_FragCoord.xy / iResolution.xy;\n\n    mDist = 1.0 - distance(pos, iMouse.xy);\n\n    n = abs(cnoise(vec3(res, iTime))) * mDist;\n\n    for (float i = 1.0; i <= 4.0; i++) {\n        float p = pow(i, 2.0);\n        n += abs(cnoise(p * (n + vec3(res, n + iTime))) / p) * mDist;\n    }\n\n    r = abs(sin(n)) * mDist;\n    b = 0.2 * r;\n    g = mix(b, r, mDist);\n\n    fragColor = vec4(r, g, b, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/7dBGWK.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "7dBSzh", "name": "Inception - Final Project", "author": "eurekazheng", "description": "Final Project for CIS-561. The spin scene from the movie Inception. Are you watching the movie, or is the movie watching you? In the permanent, periodic spinning of everything, we failed to perceive the ultimate essence of existence...", "tags": ["cis561"], "likes": 1, "viewed": 46, "date": "1619627086", "time_retrieved": "2024-06-20T20:36:08.104686", "image_code": "const int RAY_STEPS = 256;\nconst float FOVY = 0.25 * 3.14159;\n\n\nconst vec3 lightPos = vec3(1.0, 1.0, 1.0);\nconst vec3 lightColor = vec3(1.0, 1.0, 1.0);\nconst float lightPower = 40.0;\nconst vec3 ambient = vec3(0.6);\nconst vec3 diffuse = vec3(0.7, 0.1, 0.2);\nconst vec3 spec = vec3(1.0);\nconst float shine = 17.2;\nconst float gamma = 3.1; \n\nstruct Intersection\n{\n    float t;\n    vec3 color;\n    vec3 p;\n    int object;\n};\n    \nfloat sphere(vec3 p, float r, vec3 c)\n{\n    return distance(p, c) - r;\n}\n\nfloat plane( vec3 p, vec4 n )\n{\n    return dot(p,n.xyz) + n.w;\n}\n\nfloat CSG_Union(float a, float b)\n{\n    return min(a, b);\n}\n\nfloat lerp(float a, float b, float t) {\n    return a + t * (b - a);\n}\n\nfloat smooth_CSG_Union( float d1, float d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return lerp( d2, d1, h ) - k*h*(1.0-h); \n}\n\nfloat cylinder( vec3 p, vec2 h )\n{\n    vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat sceneMap3D(vec3 pos)\n{\n    float t = plane(pos, vec4(0.0, 0.0, -1.0, 5.0));\n    t = min(t, plane(pos, vec4(1.0, 0.0, 0.0, 9.0)));\n    t = min(t, plane(pos, vec4(0.0, -1.0, 0.0, 7.5)));\n    t = min(t, plane(pos, vec4(-1.0, 0.0, 0.0, 9.0)));\n    t = min(t, plane(pos, vec4(0.0, 1.0, 0.0, 2.5)));\n    float spin = CSG_Union(\n        smooth_CSG_Union(\n            cylinder(pos, vec2(2.0, 0.2)),\n            cylinder(pos, vec2(0.2, 3.0)),\n            2.5\n        ), \n        cylinder(pos, vec2(2.3, 0.1))\n    );\n    t = min(t, spin);\n    return t;\n}\n\nvoid sceneMap3D(vec3 pos, out float t, out int obj)\n{\n\n    t = plane(pos, vec4(0.0, 0.0, -1.0, 5.0));\n    obj = 0;\n    \n    float t2;\n    if((t2 = plane(pos, vec4(1.0, 0.0, 0.0, 9.0))) < t)\n    {\n        t = t2;\n        obj = 1;\n    }\n    if((t2 = plane(pos, vec4(-1.0, 0.0, 0.0, 9.0))) < t)\n    {\n        t = t2;\n        obj = 2;\n    }\n    if((t2 = plane(pos, vec4(0.0, -1.0, 0.0, 7.5))) < t)\n    {\n        t = t2;\n        obj = 3;\n    }\n    if((t2 = plane(pos, vec4(0.0, 1.0, 0.0, 2.5))) < t)\n    {\n        t = t2;\n        obj = 4;\n    }\n    \n   \n    float spin = CSG_Union(\n        smooth_CSG_Union(\n            cylinder(pos, vec2(2.0, 0.2)),\n            cylinder(pos, vec2(0.2, 3.0)),\n            2.5\n        ), \n        cylinder(pos, vec2(2.3, 0.1))\n    );\n    if((t2 = spin) < t)\n    {\n        t = t2;\n        obj = 5;\n    }\n}\n\nvec3 computeNormal(vec3 pos)\n{\n    vec3 epsilon = vec3(0.0, 0.001, 0.0);\n    return normalize( vec3( sceneMap3D(pos + epsilon.yxx) - sceneMap3D(pos - epsilon.yxx),\n                            sceneMap3D(pos + epsilon.xyx) - sceneMap3D(pos - epsilon.xyx),\n                            sceneMap3D(pos + epsilon.xxy) - sceneMap3D(pos - epsilon.xxy)));\n}\n\nvoid march(vec3 origin, vec3 dir, out float t, out int hitObj)\n{\n    t = 0.001;\n    for(int i = 0; i < RAY_STEPS; ++i)\n    {\n        vec3 pos = origin + t * dir;\n    \tfloat m;\n        sceneMap3D(pos, m, hitObj);\n        if(m < 0.01)\n        {\n            return;\n        }\n        t += m;\n    }\n    t = -1.0;\n    hitObj = -1;\n}\n\n#define FBM_OCTAVES 4\n\nfloat mySmootherStep(float a, float b, float t) {\n    t = t*t*t*(t*(t*6.0 - 25.0) + 12.0);\n    return mix(a, b, t);\n}\n\nfloat random1( vec2 p ) {\n    return fract(sin(dot(p,vec2(127.1,311.7)))*43758.5453);\n}\n\nfloat bilerpNoise(vec2 uv) {\n    vec2 uvFract = fract(uv);\n    float ll = random1(floor(uv));\n    float lr = random1(floor(uv) + vec2(1,0));\n    float ul = random1(floor(uv) + vec2(0,1));\n    float ur = random1(floor(uv) + vec2(1,1));\n\n    float lerpXL = mySmootherStep(ll, lr, uvFract.x);\n    float lerpXU = mySmootherStep(ul, ur, uvFract.x);\n\n    return mySmootherStep(lerpXL, lerpXU, uvFract.y);\n}\n\nfloat fbm(vec2 uv) {\n    float amp = 0.4;\n    float freq = 7.0;\n    float sum = 0.0;\n    for(int i = 0; i < FBM_OCTAVES; i++) {\n        sum += bilerpNoise(uv * freq) * amp;\n        amp *= 0.4;\n        freq *= 2.5;\n    }\n    return sum;\n}\n\n#define PI 3.14159\n\nconst vec3 a = vec3(0.3);\nconst vec3 b = vec3(0.7);\nconst vec3 c = vec3(1.);\nconst vec3 d = vec3(0.00, 0.6, 0.4);\n\nvec3 colorPalette(float t)\n{\n    return a + b * cos(2. * PI * (t * c + d));\n}\n\nvec3 computeMaterial(int hitObj, vec3 p, vec3 n, vec3 lightVec)\n{\n    vec3 lightDir = vec3(0., 7.4, -3.5) - p;\n    float d = length(lightDir);\n    lightDir = normalize(lightDir);\n    float lambertian = max(dot(lightDir, n), 0.0);\n    float angle = max(dot(normalize(lightDir + normalize(-p)), n), 0.0);\n    vec3 col = ambient + diffuse * lambertian * lightColor * lightPower / (d * d) \n                       + spec * pow(angle, shine) * lightColor * lightPower / (d * d);\n\n    //float lambertian = dot(-lightVec, n);\n    switch(hitObj){\n        case 0:\n        return texture(iChannel0, p.xy * 0.065 + 0.5).rgb * col;\n        break;\n        case 1:\n        return texture(iChannel0, p.zy * 0.065 + 0.5).rgb * col;\n        break;\n        case 2:\n        return texture(iChannel0, p.zy * 0.065 + 0.5).rgb * col;\n        break;\n        case 3:\n        return texture(iChannel2, p.xz * 0.065 + 0.5).rgb * col;\n        break;\n        case 4:\n        return texture(iChannel1, p.xz * 0.065 + 0.5).rgb * col;\n        break;\n        case 5:\n        vec2 uvSpin;\n        uvSpin.x = cos(iTime * 3.) + p.x / 10.;\n        uvSpin.y = p.y;        \n        return colorPalette(fbm(uvSpin)) * col;\n        break;\n        case -1:\n        return vec3(0., 0., 0.);\n        break;\n    }\n    return vec3(1.);\n}\n\nfloat ambientOcclusion(vec3 p, vec3 nor, float k) {\n\tfloat t = 0.0;\n\tfor (float i = 0.0; i < 5.0; i++) {\n\t\tt += (.2 * i - sceneMap3D(p + .2 * i * nor)) / pow(4.0, i);\n\t}\n\treturn 1.0 - t * k;\n}\n\nIntersection sdf3D(vec3 dir, vec3 eye)\n{\n    float t;\n    int hitObj;\n    march(eye, dir, t, hitObj);\n\n    vec3 isect = eye + t * dir;\n    vec3 nor = computeNormal(isect);\n    \n    vec3 lightPos = vec3(0., 7.4, -3.5);\n    vec3 lightVec = normalize(isect - lightPos);\n    float ao = ambientOcclusion(isect, nor, 1.5);\n    vec3 surfaceCol = ao * computeMaterial(hitObj, isect, nor, lightVec);    \n    return Intersection(t, surfaceCol, isect, hitObj);\n}\n\nvoid rayCast(vec2 uv, out vec3 dir, out vec3 eye, out vec3 ref)\n{\n    eye = vec3(0, 7, -15);\n    ref = vec3(0, 3, 0);\n    \n    float len = tan(3.14159 * 0.125) * distance(eye, ref);\n    vec3 H = normalize(cross(vec3(0.0, 1.0, 0.0), ref - eye));\n    vec3 V = normalize(cross(H, eye - ref));\n    V *= len;\n    H *= len * iResolution.x / iResolution.y;\n    vec3 p = ref + uv.x * H + uv.y * V;    \n    dir = normalize(p - eye);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    uv = uv * 2.0 - vec2(1.0, 1.0);\n    \n    vec3 eye;    \n    vec3 ref;\n    vec3 dir;\n    rayCast(uv, dir, eye, ref);\n    \n    Intersection isect = sdf3D(dir, eye);\n    fragColor = vec4(isect.color, 1.0);\n}", "image_inputs": [{"id": "XdfGRn", "previewfilepath": "/media/ap/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg", "ctype": "texture"}, {"id": "XsfGRn", "previewfilepath": "/media/ap/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg", "ctype": "texture"}, {"id": "4df3zn", "previewfilepath": "/media/ap/3405e48f74815c7baa49133bdc835142948381fbe003ad2f12f5087715731153.ogv", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/3405e48f74815c7baa49133bdc835142948381fbe003ad2f12f5087715731153.ogv", "ctype": "video"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/7dBSzh.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "7dBSzz", "name": "basic_shapes_movin", "author": "SimonOakey", "description": "learning & experminent with basic shapes", "tags": ["basic", "shape"], "likes": 0, "viewed": 27, "date": "1619544577", "time_retrieved": "2024-06-20T20:36:08.274416", "image_code": "void mainImage(out vec4 fragColor, in vec2 fragCoord) {\n\t\n\t vec2 uv = (fragCoord - iResolution.xy * .5) / iResolution.y;\n\t//vec2 uv=(2.0*gl_FragCoord.xy-resolution)/max(resolution.x,resolution.y);\n\t\n\tfloat t = iTime * .5;\n\t\n\tfloat f = 0.;\n\t\n\t vec3 rCol = vec3(.3);\n\t\n\t  float moveFactor = .1;\n \t vec2 vuv = vec2(0.);\n\tvuv = uv + vec2(moveFactor, 0.);\n\t\n\tf = step(fract(length(vuv)*2.   - iTime), .5);\n\t\n\tf *= step(fract(uv.y * 10. + t), .5);\n\t\n\t f += step(fract(vuv.y * 7. - abs(vuv.x * 7.) + t), .5);\n\t\n        rCol = mix(rCol, vec3(1.), f);\n\n\t\n\tfragColor = vec4(rCol,1.0);\n\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/7dBSzz.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "7dBXRz", "name": "FirstRayMarching314", "author": "Domain314", "description": "learning Ray Marching\n\nFollowed a tutorial from ArtOfCode aka BigWIngs:\nhttps://www.youtube.com/watch?v=PGtv-dBi2wE", "tags": ["own"], "likes": 1, "viewed": 46, "date": "1619540582", "time_retrieved": "2024-06-20T20:36:08.274416", "image_code": "#define MAX_STEPS 100    // int\n#define MAX_DIST 100.    // float\n#define SURF_DIST .01\n\nfloat GetDist(vec3 p) {\n    vec4 s = vec4(0., 1., 6, 1);    \n    float sphereDist = length(p-s.xyz)-s.w;\n    float planeDist= p.y;\n    \n    float d = min(sphereDist, planeDist);\n    return d;\n}\n\nfloat RayMarch(vec3 ro, vec3 rd) {\n    float dO = 0.;\n    for(int i = 0; i < MAX_STEPS; i++){\n        vec3 p = ro + rd*dO;\n        float dS = GetDist(p);\n        dO += dS;\n        if (dO > MAX_DIST || dS < SURF_DIST) break;\n    }    \n    return dO;\n}\n\nvec3 GetNormal(vec3 p) {\n    float d = GetDist(p);\n    vec2 e = vec2(.01, 0.);\n    \n    vec3 n = d - vec3(\n        GetDist(p-e.xyy), \n        GetDist(p-e.yxy), \n        GetDist(p-e.yyx));\n    return normalize(n);\n}\n\nfloat GetLight(vec3 p) {\n    vec3 lightPos = vec3(0., 5., 1.);\n    lightPos.xz += vec2(sin(iTime), cos(iTime))*3.;\n    vec3 l = normalize(lightPos - p);\n    vec3 n = GetNormal(p);\n    \n    float dif = dot(n, l);      // clamp(dot(n, l), 0., 1.) for more complicated mats, where it could go below 0\n    float d = RayMarch(p+n*SURF_DIST*2., l);    // SURF_DIST*2. to eliminate \"srew-up\" on the closest spot to the sphere\n    if (d < length(lightPos-p)) dif *=.15;\n    return dif;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    vec3 col = vec3(0.);\n    \n    vec3 ro = vec3(0., 1., 0.);\n    vec3 rd = normalize(vec3(uv.x, uv.y, 1.));\n\n    float d = RayMarch(ro, rd);\n    \n    vec3 p = ro + rd * d;\n   \n    float dif = GetLight(p);    // \"Diffuse Light\"\n    \n    col = vec3(dif);\n\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/7dBXRz.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "7dfSDl", "name": "Timmy fell down the well!", "author": "ff3", "description": "Oh no!  Timmy fell down the well!", "tags": ["cartoon", "lineart", "nonrealistic", "nrs"], "likes": 1, "viewed": 30, "date": "1619477266", "time_retrieved": "2024-06-20T20:36:08.274416", "image_code": "const float LINE_WIDTH = .01;\n\nconst vec2 EYE_R = vec2(.1,.1);\nconst vec2 EYE_L = vec2(-.1,.1);\nconst vec2 HAND_R = vec2(.5,0);\nconst vec2 HAND_L = vec2(-.5,0);\nconst vec2 MOUTH = vec2(0,-.1);\n\n//palette \nconst vec4 CAUC_H = vec4(0.9921875,0.93359375,0.87109375,1.0);\nconst vec4 CAUC_M = vec4(0.9921875,0.86328125,0.71484375,1.0);\nconst vec4 CAUC_S = vec4(0.91015625,0.79296875,0.65234375,1.0);\nconst vec4 BLACK = vec4(0.0,0.0,0.0,1.0);\nconst vec4 WHITE = vec4(1,1,1,1);\nconst vec4 RED = vec4(0.91015625,0.3359375,0.41015625,1.0);\nconst vec4 GREEN = RED.grba;\nconst vec4 BLUE = RED.bgra;\n\nvec4 colorStep(vec4 ColorA,vec4 ColorB,float midpt,float x)\n{\n    float a = midpt - (LINE_WIDTH / 2.0);\n    float b = a + LINE_WIDTH;\n    \n    vec4 toLine = smoothstep(midpt,a,x) * ColorA + smoothstep(a,midpt,x) * BLACK;\n    vec4 fromLine = smoothstep(b,midpt,x) * BLACK + smoothstep(midpt,b,x) * ColorB;\n    return toLine + fromLine;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Screen coords from -.5 to .5 0 with 0 in the middle using x scale as 1.0\n    vec2 uv = (fragCoord- .5* iResolution.xy)/iResolution.xx;\n    \n    \n    //gravity\n    vec2 face = (3. +  2.0*mod(iTime, 4.0) + exp2(mod(iTime, 4.0))) * uv;\n    \n    // Output to screen\n    //green to well\n    fragColor = colorStep(WHITE / 1.7, GREEN, .3, length(uv));\n    fragColor = colorStep(WHITE / 2.0, fragColor, .26, length(uv));\n    fragColor = colorStep(BLACK, fragColor, .1667, length(uv));\n    //timmy\n    fragColor = colorStep(BLUE, fragColor, .6, length(vec2(face.x,face.y*2.0))); //shirt\n    fragColor = colorStep(CAUC_M,fragColor, .3, length(face)); //face\n    fragColor = colorStep(WHITE, fragColor, .3*.25, length(face-EYE_L)); //eyes\n    fragColor = colorStep(WHITE, fragColor, .3*.25, length(face-EYE_R));\n    fragColor = colorStep(BLUE, fragColor, .3*.25*.2667, length(face-EYE_L)); //pupils\n    fragColor = colorStep(BLUE, fragColor, .3*.25*.2667, length(face-EYE_R));\n    fragColor = colorStep(BLACK, fragColor, .3*.25, length(face-MOUTH)); //mouth\n    fragColor = colorStep(CAUC_M, fragColor, .3*.25, length(face-HAND_L)); //hands\n    fragColor = colorStep(CAUC_M, fragColor, .3*.25, length(face-HAND_R));\n}", "image_inputs": [{"id": "Xdf3zn", "previewfilepath": "/media/ap/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/7dfSDl.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "7dfSzn", "name": "WDI 2021 Livecoding", "author": "spolsh", "description": "Effect of ~30 min Shader Livecoding session at https://warszawskiedniinformatyki.pl/, Thanks for stopping by and watching pixels bouncing to music", "tags": ["3d", "raymarching", "music", "reflections", "livecoding", "klos"], "likes": 2, "viewed": 208, "date": "1618175290", "time_retrieved": "2024-06-20T20:36:09.044283", "image_code": "// #version 410 core\n\n#define f float \n#define v2 vec2\n#define v3 vec3\n\n#define v2Resolution iResolution\n#define fGlobalTime iTime\n#define F gl_FragCoord\n#define R iResolution\n#define T iTime\n\n#define C(v) clamp(v, 0., 1.)\n#define N normalize\n#define H(v) fract(sin(100.0*v) * 43758.5453)\n\n// #define BI(v) (texture(texFFTIntegrated, v).x)\n// #define BS(v) (texture(texFFTSmoothed, v).x)\n// #define B(v) (texture(texFFT, v).x)\n// fake beat accumulation, next time I will save it in buffer\n#define B2(v) (0.05*T+0.005*texture(iChannel0, v2(v, 0.5)).x)\n#define B1(v) (0.005*texture(iChannel0, v2(v, 0.5)).x)\n#define B0(v)  (0.005*texture(iChannel0, v2(v, 0.5)).x)\n\n#define texNoise iChannel1\n\n// uniform float fGlobalTime; // in seconds\n// uniform vec2 v2Resolution; // viewport resolution (in pixels)\n\nv3 colA = v3(0.2, 0.5, 1.2);\nv3 cP = v3(0.);\n\nf gG = 10e8;\n\nmat2 rot(f a) {return mat2(cos(a), -sin(a), sin(a), cos(a)); }\n\nvec4 plas( vec2 v, float time )\n{\n\tfloat c = 0.5 + sin( v.x * 10.0 ) + cos( sin( time + v.y ) * 20.0 );\n\treturn vec4( sin(c * 0.2 + cos(time)), c * 0.15, cos( c * 0.1 + time / .4 ) * .25, 1.0 );\n}\n\nf map(v3 p) {\n  f s = 10e8;\n  s = -abs(p.y) + 1.5;\n  \n  v3 p2 = p;\n  p2.x = abs(p2.x) - 2.0;\n  p2.z = mod(p2.z + 5.0, 10.0) - 5.0;\n  p2.y = mod(p2.z +  .01, 0.02) - 0.01;\n  s = min(s, length(p2) - 0.5);\n  p2.x -= 2.;\n  s = min(s, length(p2) - 0.5);\n  \n  v3 p3 = p;\n  p3.y -= 0.5;\n  p3.z -= 8.0;\n  p3.z = mod(p3.z + .01, .02) - .01;\n  p3.y += 0.5 + .5*sin(0.3*p.z);\n  p3.x += 1.5*sin(0.1*p.z);  \n  f s5 = min(s, length(p3) - 0.05);\n  p3.z -= 10.0*B0(0);\n  s5 = min(s5, length(p3) - 0.05);\n  p3.x -= 10.0*B0(0.1);\n  s5 = min(s5, length(p3) - 0.1);\n  p3.x -= 10.0*B0(0.2);\n  s5 = min(s5, length(p3) - 0.1);\n  gG = min(gG, s5);  \n  s = min(s, s5);  \n  \n  v3 p1 = p - cP;\n  p1.y += 100.0*B1(0.0);\n  p1.z -= 10.0 + 5.0*sin(10.0*B2(0));\n  \n  f s3 = 10e8;\n  for (f i = 0.; i < 4.; ++i) {\n    p1 -= v3(0.1, 0.3, 0.5);   \n    p1.xz *= rot(10. * B2(0.));\n    p1.zy *= rot(-9. * B2(0.));\n    p1.xy *= rot(50. * B1(0.));\n    // p1.zy *= rot(0.5 * B2(0.) );\n    p1 = abs(p1);\n    p1 *= 0.9;\n    f s4 = length(p1) -0.1 -5.0*B0(0.);\n    vec3 p4 = p1;\n    if (i < 2. + B1(0.)) {\n      p4.y = mod(p4.y +  .01, 0.02) - 0.01;\n      f s2 = length(p4) -0.05 -1.0*B0(0.);\n      s3 = min(s3, s2);\n      s3 = min(s3, s4);\n    }      \n  }\n  gG = min(gG, s3);  \n  s = min(s, s3);\n  return s;\n}\n\nvoid mainImage( out vec4 out_color, in vec2 fragCoord )\n{\n\tvec2 uv = vec2(gl_FragCoord.x / v2Resolution.x, gl_FragCoord.y / v2Resolution.y);\n\tuv -= 0.5;\n\tuv /= vec2(v2Resolution.y / v2Resolution.x, 1);\n\n  \n  out_color = vec4(0);  \n  if (abs(uv.y) > 0.35) return;\n  \n  vec3 ro = vec3(0, 0, 0);\n  ro.x += sin(20.0*B2(0.));\n  ro.y += 0.1*sin(20.0*B2(0.));\n  ro.z += 20.0*T;\n  cP = ro;\n  vec3 rd = N(vec3(uv, 2.));\n  rd.xy *= rot(0.5*sin(0.5* T));\n  v3 c = v3(0.0);\n  \n  f t = 0.1;\n  for (f i = 0.; i < 128.; ++i) {\n    f d = map(ro + rd * t);\n    if (abs(d) < 0.001 || t > 40.0) break;\n    t += d;\n  }\n  \n  if (t > 0.2 || t < 40.) {\n    v3 p = ro + rd  * t;    \n    f tex0 = texture(texNoise, floor(20.0*( vec2(1.0, 0.05) * p.xz + vec2(0, 1) * T))/20.0).x;\n    f tex1 = texture(texNoise, floor(20.0*( vec2(0.5, 0.005) * p.xz + vec2(0, 0.5) * T))/20.0).x;\n    c += 0.25 * colA.xyz * smoothstep(0.2, 0.7, tex0);\n    c += 0.25 * colA.xyz * smoothstep(0.2, 0.7, tex1);\n    \n    c += 0.1 * colA.xzy * smoothstep(0.0, 1., sin(p.z + 10.*T));\n    c += 0.5 * colA.xzy * smoothstep(0.9, 1., sin(0.5*p.z + 10.*T));\n    c += 0.5 * colA.xzy * smoothstep(0.5, 1., sin(0.5*p.z + 10.*T)) * sin(p.z + sin(100.0*p.x) + 10.*T);\n  }\n  \n  c = mix(c, 0.1*colA.yzx, 1.0 - exp(-0.005 * t*t));\n  \n  v3 colB = v3(1., 0.5, 0.5);\n  f sb = 0.01 + 20.0*B1(0.);\n  c += sb * colB.xyz * exp(gG * - 0.01);\n  c += sb * colB.xyz * exp(gG * - 0.1);\n  c += sb * colB.xyz * exp(gG * - 1.0);\n  c += sb * colB.xyz * exp(gG * - 5.0);\n  c += sb * colB.xyz * exp(gG * - 10.0);\n  \n  c += 10.0*B0(0);\n  \n  // c = v3(1) * (t/64.);\n  c = C(c / (c + 1.));  \n  c = pow(c, v3(1. -50.0*B1(0.), 1. -50.0*B1(0.25), 1. -50.0*B1(0.5)));\n  c = smoothstep(0., .6, c);\n  c = pow(c, v3(0.4545));\n  out_color = vec4(c, 1);  \n\t// out_color = vec4(rd, 1);\n}", "image_inputs": [{"id": "4dXGzn", "previewfilepath": "/media/ap/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "ctype": "texture"}, {"id": "MllXD7", "previewfilepath": "https://soundcloud.com/inzynier/bad-dream-good-dream-podcast", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0, "src": "https://soundcloud.com/inzynier/bad-dream-good-dream-podcast", "ctype": "musicstream"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/7dfSzn.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "7dfXDH", "name": "fractalized Circuit Diagram2", "author": "ikertesz", "description": "morphing fractals based on jarble's\n\noriginal: \"I edited [url=https://www.shadertoy.com/view/wtlyR8]ntsutae's \"Circuit Diagram2\" [/url] to make this animation. Surprisingly, it has several moving patterns that resemble \"gliders\" from cellular automata.\"", "tags": ["xor"], "likes": 3, "viewed": 65, "date": "1618569274", "time_retrieved": "2024-06-20T20:36:09.159463", "image_code": "// \"Circuit Diagram2\" by ntsutae (modified by ikertesz)\n// https://twitter.com/ntsutae/status/1268820823952916486\n// https://www.openprocessing.org/sketch/912094\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  int x = int(fragCoord.x - 10.0 * iTime);\n  int y = int(fragCoord.y + 200.0 * iTime);\n  int r = (x-y)^(x+y)*1;\n  bool b = abs(r*r/(y+int(iTime*35.0))+(x-int(iTime*70.0))) % (350) < 30;\n  fragColor = vec4(vec3(b ? 1.0 : 0.0), 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/7dfXDH.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "7dfXRl", "name": "Bit Carpet Variations", "author": "metabog", "description": "Moving through various values for mod to show the different patterns that come out of\nhttps://twitter.com/aemkei/status/1378106731386040322", "tags": ["generative", "xor", "carpet", "visuals"], "likes": 1, "viewed": 57, "date": "1619031937", "time_retrieved": "2024-06-20T20:36:09.159463", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 xy = floor(fragCoord/4.0 + iTime*8.0);\n    int modulo = (int(iTime*0.125)+3)%20;\n    float val = 1.0 - (float((int(xy.x)^int(xy.y))%modulo));\n    fragColor = vec4(val);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/7dfXRl.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "7dfXzH", "name": "pentagram p", "author": "pikmin2010", "description": "p", "tags": ["p"], "likes": 0, "viewed": 153, "date": "1618259626", "time_retrieved": "2024-06-20T20:36:09.159463", "image_code": "float sdTriangleIsosceles( in vec2 p, in vec2 q )\n{\n    p.x = abs(p.x);\n\tvec2 a = p - q*clamp( dot(p,q)/dot(q,q), 0.0, 1.0 );\n    vec2 b = p - q*vec2( clamp( p.x/q.x, 0.0, 1.0 ), 1.0 );\n    float k = sign( q.y );\n    float d = min(dot( a, a ),dot(b, b));\n    float s = max( k*(p.x*q.y-p.y*q.x),k*(p.y-q.y)  );\n\treturn sqrt(d)*sign(s);\n}\nvec2 rotate(vec2 uv, float rotation, vec2 mid)\n{\nuv = (uv - mid )  * mat2( cos(rotation), -sin(rotation),sin(rotation), cos(rotation)) + mid;\nreturn uv;   \n}\n\nfloat sdPentagon( in vec2 p, in float r )\n{\n    const vec3 k = vec3(0.809016994,0.587785252,0.726542528);\n    p.x = abs(p.x);\n    p -= 2.0*min(dot(vec2(-k.x,k.y),p),0.0)*vec2(-k.x,k.y);\n    p -= 2.0*min(dot(vec2( k.x,k.y),p),0.0)*vec2( k.x,k.y);\n    p -= vec2(clamp(p.x,-r*k.z,r*k.z),r);    \n    return length(p)*sign(p.y);\n}\n\nfloat sdf(vec2 uv){\nfloat pent = sdPentagon(rotate(uv,iTime,vec2(0.))*-1.,0.09);\nvec2 trioff =uv + vec2(0.,0.26);\nfloat tri = 5.0;\nfor(float x= 0.0;x<5.;x++){\n\nvec2 t = rotate(trioff,5.*x,vec2(0.0,0.26));\ntri = min(sdTriangleIsosceles(t,vec2(0.0735,0.172)),tri);\n\n}\n\n\nfloat d =min(tri,pent);\n\nreturn d;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n vec2 uv = ( fragCoord - .5*iResolution.xy ) / iResolution.y;\n \n \n    uv = rotate(uv,iTime*-0.75,vec2(0.));\n     vec3 col = vec3(0.0);\n      float d = sdf(uv);\n      //from FabriceNeyret2's comment\n      fragColor = vec4( smoothstep( 1.5/iResolution.y, 0.,abs(d)) , 0,0,1); \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/7dfXzH.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "7dj3WG", "name": "voronoi tesselation", "author": "speediplayz", "description": "voronoi tesselation with different effects\n\ncomment out 1 of the distance variables for different effects", "tags": ["tesselation"], "likes": 2, "viewed": 90, "date": "1617907569", "time_retrieved": "2024-06-20T20:36:09.159463", "image_code": "float random(float seed){\n    return fract(sin(seed * 5892.234) * 12423.412);\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    const float pointCount = 128.0;\n    vec2[int(pointCount)] points;\n    \n    for(float i = 0.0; i < pointCount; i += 1.0){\n        float x = random((i+1.0)*(i+1.0) + 0.1) * iResolution.x;\n        float y = random(i+1.1) * iResolution.y;\n        vec2 point = vec2(x, y);\n        \n        points[int(i)] = point;\n        if(int(point.x) == int(fragCoord.x) && int(point.y) == int(fragCoord.y)){\n            fragColor = vec4(1,1,1,1);\n            return;\n        }\n    }\n    \n    float minDist = sqrt(iResolution.x * iResolution.x + iResolution.y * iResolution.y);\n    vec2 minVec = vec2(0, 0);\n    \n    for(float i = 0.0; i < pointCount; i += 1.0){\n        float dx = points[int(i)].x - fragCoord.x, dy = points[int(i)].y - fragCoord.y;\n        \n        float dist = sqrt(dx*dx+dy*dy) * (random(fragCoord.x + random(fragCoord.y)));\n        //float dist = sqrt(dx*dx+dy*dy) * (random(fragCoord.y));\n        //float dist = sqrt(dx*dx+dy*dy) * (random(fragCoord.x));\n        //float dist = sqrt(dx*dx+dy*dy) * (random(fragCoord.x) + random(fragCoord.y)) / 2.0;\n        \n        if(dist < minDist){\n            minDist = dist;\n            minVec = points[int(i)];\n        }\n    }\n    \n    if(minDist <= ((sin(iTime)+1.0)/2.0) * 128.0){\n        fragColor = vec4(minVec.x / iResolution.x, minVec.y / iResolution.y, (sin(iTime+45.0)+1.0)/2.0, 1);\n    } else fragColor = vec4(0, 0, 0, 1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/7dj3WG.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "7dj3Wz", "name": "Nautilus Egg", "author": "dr2", "description": "The Nautilus Egg (possibly a gift from Faberge to Verne)", "tags": ["submarine", "faberge", "verne"], "likes": 14, "viewed": 155, "date": "1617274344", "time_retrieved": "2024-06-20T20:36:09.184634", "image_code": "// \"Nautilus Egg\" by dr2 - 2021\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\n/*\n  No. 6 in \"Egg\" series:\n    \"Lost Egg\"             (ls3XDn)\n    \"Faberge Balls\"        (MsdXWn)\n    \"Golden Dolphin\"       (MtsBWX)\n    \"Ship in a Shell\"      (XlBfRR)\n    \"Fibonacci Polyhedra\"  (llyfRh)\n    \n  No. 8 in \"Nautilus\" series:\n    \"The Nautilus, Part 1\" (tlVGDd)\n    \"The Nautilus, Part 2\" (WlcXzN)\n    \"The Nautilus, Part 3\" (wltSWH)\n    \"The Nautilus, Part 4\" (3ttSzX)\n    \"Nautilus: The Book\"   (3lVSWw)\n    \"Nautilus Submerging\"  (WtXfR2)\n    \"Nautilus Interior\"    (wt2fzz)\n*/\n\n#define AA  0\n\nfloat PrBox2Df (vec2 p, vec2 b);\nfloat PrRoundBoxDf (vec3 p, vec3 b, float r);\nfloat PrSphDf (vec3 p, float r);\nfloat PrCylDf (vec3 p, float r, float h);\nfloat PrCylAnDf (vec3 p, float r, float w, float h);\nfloat PrFlatCylDf (vec3 p, float rhi, float rlo, float h);\nfloat PrCapsDf (vec3 p, float r, float h);\nfloat Maxv3 (vec3 p);\nfloat SmoothMin (float a, float b, float r);\nfloat SmoothMax (float a, float b, float r);\nfloat SmoothBump (float lo, float hi, float w, float x);\nmat3 StdVuMat (float el, float az);\nvec2 Rot2D (vec2 q, float a);\nvec2 Rot2Cs (vec2 q, vec2 cs);\nfloat Noiseff (float p);\nfloat Fbm2 (vec2 p);\nfloat Fbm3 (vec3 p);\nvec3 VaryNf (vec3 p, vec3 n, float f);\n\nvec3 ltDir, sbPos, hingSz, qHit;\nvec2 opCs;\nfloat tCur, dstFar, sbRot, sbLen, prpRot, szFac, rShell, opPhs, dGlow;\nint idObj;\nbool isSh;\nconst int idBod = 1, idKl = 2, idSth = 3, idSup = 4, idTl = 5, idWinF = 6, idWinS = 7, idProp = 8,\n   idSpk = 9, idPlat = 10, idWfrm = 11, idLmpF = 12, idLmpB = 13, idShell = 20, idHing = 21, idArm = 22;\nconst float pi = 3.14159;\n\n#define VAR_ZERO min (iFrame, 0)\n\n#define DMIN(id) if (d < dMin) { dMin = d;  idObj = id; }\n#define DMINQ(id) if (d < dMin) { dMin = d;  idObj = id;  qHit = q; }\n\nfloat NautDf (vec3 p, float dMin)\n{\n  vec3 q, qe;\n  float d, rad, s, dph, suLen;\n  p.z -= -0.5;\n  q = p;\n  s = q.z / sbLen;\n  rad = 1.2 * (1. - 0.9 * smoothstep (0.4, 1.1, s)) * (1. - 0.85 * smoothstep (0.6, 1.1, - s));\n  q.x *= 1.1  - 0.1 * smoothstep (0.7, 0.9, abs (s));\n  d = max (mix (max (abs (q.y), dot (abs (q.xy), vec2 (0.866, 0.5))), length (q.xy),\n     clamp (s * s, 0., 1.)) - rad, abs (q.z) - sbLen);\n  dph = 0.54 - length (q.yz);\n  DMIN (idBod);\n  q = p;\n  d = max (PrRoundBoxDf (q, vec3 (1.2 * rad - 0.05, 0.02, sbLen - 0.02), 0.02), dph);\n  DMIN (idPlat);\n  s = (q.y > 0.) ? 2. * rad - 0.24 : 1.5 * rad - 0.15;\n  d = max (PrRoundBoxDf (q, vec3 (0.03, s, sbLen - 0.02), 0.02),\n     - max (PrBox2Df (q.yz, vec2 (s - 0.2, sbLen - 0.1)), - q.y));\n  d = max (d, ((q.y > 0.) ? 2. - q.z : 0.4 - abs (q.z - 0.3 * q.y + 1.)));\n  DMIN (idKl);\n  s += 0.05;\n  d = max (PrRoundBoxDf (q, vec3 (0.06, s, sbLen - 0.02), 0.01),\n     - PrBox2Df (q.yz, vec2 (s - 0.1, sbLen - 0.1 + 0.1)));\n  d = max (max (max (d, abs (mod (q.y + 0.05, 0.1) - 0.05) - 0.03),\n     2. - q.z), max (q.y - 2.1, - q.y - 1.65));\n  DMIN (idSth);\n  q = p;\n  q.yz -= vec2 (1.8, -2.8 - 0.5 * (q.y - 1.8));\n  d = PrRoundBoxDf (q, vec3 (0.03, 0.35, 0.1), 0.02);\n  DMIN (idKl);\n  q.z -= 0.1;\n  d = max (PrRoundBoxDf (q, vec3 (0.06, 0.3, 0.05), 0.02),\n     abs (mod (q.y + 0.05, 0.1) - 0.05) - 0.03);\n  DMIN (idSth);\n  q = p;\n  q.z -= - sbLen + 0.2;\n  d = PrRoundBoxDf (q, vec3 (0.03, 1.1 + 0.5 * smoothstep (-1., 0.5, - q.z),\n     1.8 - step (q.z, 0.)), 0.02);\n  q.z -= -0.35;\n  d = max (d, - PrBox2Df (q.yz, vec2 (0.7, 0.15)));\n  DMIN (idTl);\n  q = p;\n  q.z -= sbLen + 1.;\n  d = PrCylDf (q, 0.18 * (0.6 - 0.4 * q.z), 1.);\n  DMIN (idSpk);\n  q = p;\n  q.z -= -0.13 - sbLen;\n  d = PrCylDf (q, 0.25 * (1. + q.z), 0.13);\n  q.xy = Rot2D (q.xy, prpRot);\n  s = sign (q.x) * sign (q.y);\n  q.xy = Rot2D (abs (q.xy) - 0.25, 0.25 * pi);\n  q.xz = Rot2D (q.xz, -0.2 * s * pi);\n  d = min (d, PrRoundBoxDf (q, vec3 (0.11, 0.28 * (1. - 4. * q.x * q.x), 0.002), 0.01));\n  DMIN (idProp);\n  qe = vec3 (abs (p.x), p.yz) - vec3 (0.25, 1.7, 1.95);\n  q = p;\n  q.yz -= vec2 (1.44, -0.4);\n  suLen = 2.7;\n  s = q.z / suLen;\n  rad = 0.7 * (1. - 0.9 * smoothstep (0., 2., s)) * (1. - 0.5 * smoothstep (0., 2., - s));\n  q.x += 0.2 * q.y * sign (q.x);\n  d = - PrBox2Df (q.yz - vec2 (1., -2. + 0.2 * q.y), vec2 (1., 3.));\n  q.z += 0.2 * q.y * sign (q.z);\n  d = max (max (d, PrFlatCylDf (q.zxy, suLen, rad, 0.76)), - PrSphDf (qe, 0.32));\n  DMIN (idSup);\n  q = p;\n  d = PrCylAnDf (q.yzx, 0.53, 0.02, 1.45);\n  DMIN (idWfrm);\n  q = p;\n  q.x = abs (q.x) - 0.85;\n  d = max (PrSphDf (q, 0.75), - dph);\n  DMIN (idWinS);\n  d = PrSphDf (qe, 0.3);\n  DMIN (idWinF);\n  q = p;\n  q.x = abs (q.x);\n  q -= vec3 (0.15, 2.1, suLen - 0.35);\n  d = PrSphDf (q, 0.08);\n  DMIN (idLmpF);\n  q = p;\n  q.yz -= vec2 (1.42, suLen - 6.27);\n  d = PrSphDf (q, 0.05);\n  DMIN (idLmpB);\n  qHit = p;\n  if (! isSh) dGlow = min (dGlow, dMin);\n  return 0.7 * dMin;\n}\n\nfloat ShRad (vec3 p)\n{\n  return 0.5 * rShell + 0.02 * (1. - p.y / length (p)) * cos (64. * atan (p.x, p.z));\n}\n\nfloat ObjDf (vec3 p)\n{\n  vec3 q;\n  float dMin, d, ds, r;\n  dMin = dstFar;\n  q = p;\n  q -= sbPos;\n  q.xz = Rot2D (q.xz, sbRot);\n  if (! isSh) d = szFac * PrCylDf (q / szFac, 2.3, sbLen + 2.);\n  if (isSh || d < 0.2) dMin = szFac * NautDf (q / szFac, dMin / szFac);\n  else dMin = d;\n  q = p;\n  q.z -= - rShell + 0.1 - 2. * hingSz.z;\n  d = PrCapsDf (q.yzx, hingSz.y + 0.02, hingSz.x);\n  DMINQ (idHing);\n  q.yz = Rot2Cs (q.yz, opCs);\n  q.y = abs (q.y);\n  q.yz = Rot2Cs (q.yz, opCs);\n  q.z -= rShell - 0.1 + 2. * hingSz.z;\n  r = ShRad (q);\n  ds = length (max (vec2 (length (q.xz) - r, abs (q.y)), 0.)) - r;\n  d = 0.9 * SmoothMax (abs (ds) - 0.05, -0.01 - q.y, 0.01);\n  DMINQ (idShell);\n  q.z -= - rShell + 0.1 - hingSz.z;\n  d = max (PrRoundBoxDf (q, vec3 (hingSz.xy, hingSz.z + 0.01) - 0.02, 0.02), max (- ds, 0.05 - q.y));\n  DMINQ (idArm);\n  q = p;\n  q.y -= -0.5 * rShell + 0.1;\n  d = PrCylDf (q.xzy, 0.3, 0.05);\n  q.y -= 0.5 * sbPos.y + 0.6;\n  d = min (d, PrCylDf (q.xzy, 0.07, 0.5 * sbPos.y + 0.7));\n  DMINQ (idArm);\n  return dMin;\n}\n\nfloat ObjRay (vec3 ro, vec3 rd)\n{\n  float dHit, d;\n  dHit = 0.;\n  for (int j = VAR_ZERO; j < 160; j ++) {\n    d = ObjDf (ro + dHit * rd);\n    if (d < 0.0002 || dHit > dstFar) break;\n    dHit += d;\n  }\n  return dHit;\n}\n\nvec3 ObjNf (vec3 p)\n{\n  vec4 v;\n  vec2 e;\n  e = vec2 (0.001, -0.001);\n  for (int j = VAR_ZERO; j < 4; j ++) {\n    v[j] = ObjDf (p + ((j < 2) ? ((j == 0) ? e.xxx : e.xyy) : ((j == 2) ? e.yxy : e.yyx)));\n  }\n  v.x = - v.x;\n  return normalize (2. * v.yzw - dot (v, vec4 (1.)));\n}\n\nfloat ObjSShadow (vec3 ro, vec3 rd)\n{\n  float sh, d, h;\n  sh = 1.;\n  d = 0.02;\n  for (int j = VAR_ZERO; j < 40; j ++) {\n    h = ObjDf (ro + d * rd);\n    sh = min (sh, smoothstep (0., 0.05 * d, h));\n    d += max (0.04, h);\n    if (sh < 0.05) break;\n  }\n  return 0.5 + 0.5 * sh;\n}\n\nvec4 NautColN (vec3 vn)\n{\n  vec4 col4, cc, cu, cd, cb;\n  float t;\n  cd = vec4 (0.2, 0.2, 0.2, 0.);\n  cu = vec4 (0.4, 0.3, 0.2, 0.1);\n  cb = vec4 (0.1, 0.4, 0.4, 0.2);\n  cc = (qHit.y > 0.) ? mix (cu, cb, smoothstep (0.45, 0.55, Fbm3 (2. * qHit))) : cu;\n  if (idObj == idBod) {\n    col4 = cc * (0.7 + 0.3 * smoothstep (0.05, 0.07, \n       length (mod (vec2 (6. * atan (qHit.y, - qHit.x) / pi, 2. * qHit.z + 0.5), 1.) - 0.5))) *\n       (0.7 + 0.3 * max (step (3., abs (qHit.z + 1.)), smoothstep (0.01, 0.012, abs (qHit.y + 0.55))));\n  } else if (idObj == idPlat) {\n    col4 = (abs (vn.y) > 0.2) ? cc : cd;\n  } else if (idObj == idWfrm) {\n    col4 = (abs (vn.x) < 0.2) ? cc : cd;\n  } else if (idObj == idKl) {\n    col4 = (abs (vn.x) > 0.2) ? cu : cd;\n  } else if (idObj == idSth) {\n    col4 = vec4 (0.4, 0.6, 0.2, 0.2); \n  } else if (idObj == idSup) {\n    col4 = cc;\n  } else if (idObj == idTl) {\n    col4 = (abs (vn.x) > 0.2) ? cc * (1. - 0.5 * SmoothBump (-0.02, 0.02, 0.005, qHit.z + 6.28)) : cd;\n  } else if (idObj == idProp) {\n    col4 = vec4 (0.5, 0.5, 0.3, 0.2) * (0.7 + 0.3 * smoothstep (0.01, 0.012,\n       abs (length (qHit.xy) - 0.6)));\n  } else if (idObj == idSpk) {\n    col4 = vec4 (0.5, 0.5, 0.5, 0.2) * (0.7 + 0.3 * smoothstep (0.1, 0.15,\n       abs (mod (12. * qHit.z + 0.5, 1.) - 0.5)));\n  } else if (idObj == idLmpF) {\n    col4 = vec4 (0.8, 0.8, 0.2, -1.);\n  } else if (idObj == idLmpB) {\n    col4 = vec4 (0.2, 0.8, 0.2, -1.);\n  } else if (idObj == idWinF || idObj == idWinS) {\n    if (idObj == idWinF) {\n      qHit = vec3 (abs (qHit.x), qHit.yz) - vec3 (0.25, 1.7, 1.95);\n      qHit.xy = Rot2D (qHit.xy, -0.05 * pi);\n      qHit.xz = Rot2D (qHit.xz, -0.05 * pi);\n      t = length (qHit.yz) - 0.17;\n    } else {\n      t = length (qHit.yz) - 0.3;\n    }\n    if (min (step (0.02, abs (t)), max (step (t, 0.), step (0.02,\n       min (abs (qHit.y + qHit.z), abs (qHit.y - qHit.z))))) == 0.) col4 = cb;\n    else col4 = vec4 (1, 0., 0., -1.);\n  }\n  return col4;\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  vec4 col4;\n  vec3 col, vn;\n  float dstObj, r, s, y, sh;\n  hingSz = vec3 (1., 0.2, 0.4);\n  rShell = 4.;\n  sbLen = 6.;\n  szFac = 0.45;\n  isSh = false;\n  dGlow = dstFar / szFac;\n  dstObj = ObjRay (ro, rd);\n  dGlow *= szFac;\n  if (dstObj < dstFar) {\n    ro += dstObj * rd;\n    vn = ObjNf (ro);\n    if (idObj < idShell) {\n      vn.xz = Rot2D (vn.xz, sbRot);\n      col4 = NautColN (vn);\n      if (col4.a >= 0.) vn = VaryNf (32. * qHit, vn, 0.5);\n      vn.xz = Rot2D (vn.xz, - sbRot);\n      if (col4.a >= 0.) col4.rgb = sqrt (Maxv3 (col4.rgb)) * mix (vec3 (0.9, 1., 0.9),\n         vec3 (0.9, 0.9, 1.), - dot (vn, rd));\n    } else {\n      col4 = vec4 (1., 1., 0.9, 0.1);\n      if (idObj == idShell) {\n        r = ShRad (qHit);\n        s = length (max (vec2 (length (qHit.xz) - r, abs (qHit.y)), 0.)) - r;\n        if (s < 0. && qHit.y > 0.01) {\n          y = 1. - qHit.y / length (qHit);\n          col4 = mix (vec4 (0.5, 0.5, 1., 0.1), vec4 (0.95, 0.95, 1., 0.1),\n             smoothstep (0.1, 0.3, y) * smoothstep (-0.2, 0.2, (r - 0.5 * rShell) / (0.02 * y)));\n        } else if (s > 0.) {\n           col4 = mix (col4, vec4 (1., 0.9, 0.9, 0.1), smoothstep (0.5, 0.7, cos (32. *\n              asin (qHit.y / length (qHit)) + 8. * atan (qHit.x, qHit.z) * sign (ro.y))));\n        }\n      } else if (idObj == idHing) {\n        col4 *= 0.95 * (1. - 0.4 * SmoothBump (-0.04, 0.04, 0.02, mod (4. * qHit.x / hingSz.x +\n           0.5, 1.) - 0.5));\n      } else if (idObj == idArm) {\n        col4 *= 0.95;\n      }\n    }\n    if (idObj < idShell) dGlow = dstFar;\n    if (col4.a >= 0.) {\n      if (idObj < idShell || idObj == idShell && s < 0.) col4 *= 0.1 + 0.9 * smoothstep (0.05, 0.3, opPhs);\n      isSh = true;\n      sh = ObjSShadow (ro + 0.01 * ltDir, ltDir);\n      col = col4.rgb * (0.2 + 0.1 * max (- dot (vn, ltDir), 0.) + 0.8 * sh * max (dot (vn, ltDir), 0.)) +\n         col4.a * step (0.95, sh) * pow (max (dot (reflect (ltDir, vn), rd), 0.), 32.);\n    } else {\n      col = col4.rgb * (0.2 - 0.8 * dot (vn, rd)) * (1. - 0.2 * Noiseff (8. * tCur));\n    }\n  } else {\n    col = vec3 (0.08, 0., 0.) * (0.85 + 0.15 * SmoothBump (0.3, 0.7, 0.15,\n       mod (32. * atan (rd.z, rd.x) / pi, 1.))) + 80. * pow (1. - 0.6 * abs (dot (rd,\n       VaryNf (512. * vec3 (rd.xz, rd.y / length (rd.xz) + 0.01 * tCur).xzy, rd, 2.))), 8.);\n  }\n  col = mix (col, vec3 (0.7, 0.6, 0.2) * (1. - 0.2 * Noiseff (16. * tCur)), exp (- 12. * dGlow));\n  return clamp (col, 0., 1.);\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  mat3 vuMat;\n  vec4 mPtr;\n  vec3 ro, rd, col;\n  vec2 canvas, uv;\n  float el, az, zmFac, sr;\n  canvas = iResolution.xy;\n  uv = 2. * fragCoord.xy / canvas - 1.;\n  uv.x *= canvas.x / canvas.y;\n  tCur = iTime;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / canvas - 0.5;\n  opPhs = SmoothBump (0.25, 0.85, 0.15, mod (0.1 * tCur, 1.));\n  opCs = sin (0.2 * pi * opPhs + vec2 (0.5 * pi, 0.));\n  sbPos = vec3 (0., -0.6 + 1.4 * opPhs, 0.);\n  sbRot = 0.1 * pi * tCur;\n  prpRot = 0.5 * 2. * pi * tCur;\n  az = pi;\n  el = -0.15 * pi;\n  if (mPtr.z > 0.) {\n    az += 2. * pi * mPtr.x;\n    el += pi * mPtr.y;\n  } else {\n    az += 0.5 * pi * (2. * mod (floor (0.04 * tCur), 2.) - 1.) *\n       SmoothBump (0.25, 0.65, 0.1, mod (0.04 * tCur, 1.));\n    el -= 0.05 * pi * sin (0.05 * pi * tCur);\n  }\n  el = clamp (el, -0.45 * pi, 0.45 * pi);\n  vuMat = StdVuMat (el, az);\n  dstFar = 60.;\n  zmFac = 5.;\n  ro = vuMat * vec3 (0., 0.5, -24.);\n  ltDir = vuMat * normalize (vec3 (-0.5, 1., -1.));\n#if ! AA\n  const float naa = 1.;\n#else\n  const float naa = 3.;\n#endif  \n  col = vec3 (0.);\n  sr = 2. * mod (dot (mod (floor (0.5 * (uv + 1.) * canvas), 2.), vec2 (1.)), 2.) - 1.;\n  for (float a = float (VAR_ZERO); a < naa; a ++) {\n    rd = vuMat * normalize (vec3 (uv + step (1.5, naa) * Rot2D (vec2 (0.5 / canvas.y, 0.),\n       sr * (0.667 * a + 0.5) * pi), zmFac));\n    col += (1. / naa) * ShowScene (ro, rd);\n  }\n  fragColor = vec4 (col, 1.);\n}\n\nfloat PrBox2Df (vec2 p, vec2 b)\n{\n  vec2 d;\n  d = abs (p) - b;\n  return min (max (d.x, d.y), 0.) + length (max (d, 0.));\n}\n\nfloat PrRoundBoxDf (vec3 p, vec3 b, float r)\n{\n  return length (max (abs (p) - b, 0.)) - r;\n}\n\nfloat PrSphDf (vec3 p, float r)\n{\n  return length (p) - r;\n}\n\nfloat PrCylDf (vec3 p, float r, float h)\n{\n  return max (length (p.xy) - r, abs (p.z) - h);\n}\n\nfloat PrFlatCylDf (vec3 p, float rhi, float rlo, float h)\n{\n  return max (length (p.xy - vec2 (clamp (p.x, - rhi, rhi), 0.)) - rlo, abs (p.z) - h);\n}\n\nfloat PrCylAnDf (vec3 p, float r, float w, float h)\n{\n  return max (abs (length (p.xy) - r) - w, abs (p.z) - h);\n}\n\nfloat PrCapsDf (vec3 p, float r, float h)\n{\n  return length (p - vec3 (0., 0., h * clamp (p.z / h, -1., 1.))) - r;\n}\n\nfloat Maxv3 (vec3 p)\n{\n  return max (p.x, max (p.y, p.z));\n}\n\nmat3 StdVuMat (float el, float az)\n{\n  vec2 ori, ca, sa;\n  ori = vec2 (el, az);\n  ca = cos (ori);\n  sa = sin (ori);\n  return mat3 (ca.y, 0., - sa.y, 0., 1., 0., sa.y, 0., ca.y) *\n         mat3 (1., 0., 0., 0., ca.x, - sa.x, 0., sa.x, ca.x);\n}\n\nfloat SmoothMin (float a, float b, float r)\n{\n  float h;\n  h = clamp (0.5 + 0.5 * (b - a) / r, 0., 1.);\n  return mix (b, a, h) - r * h * (1. - h);\n}\n\nfloat SmoothMax (float a, float b, float r)\n{\n  return - SmoothMin (- a, - b, r);\n}\n\nfloat SmoothBump (float lo, float hi, float w, float x)\n{\n  return (1. - smoothstep (hi - w, hi + w, x)) * smoothstep (lo - w, lo + w, x);\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  vec2 cs;\n  cs = sin (a + vec2 (0.5 * pi, 0.));\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nvec2 Rot2Cs (vec2 q, vec2 cs)\n{\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nconst float cHashM = 43758.54;\n\nvec2 Hashv2f (float p)\n{\n  return fract (sin (p + vec2 (0., 1.)) * cHashM);\n}\n\nvec2 Hashv2v2 (vec2 p)\n{\n  vec2 cHashVA2 = vec2 (37., 39.);\n  return fract (sin (vec2 (dot (p, cHashVA2), dot (p + vec2 (1., 0.), cHashVA2))) * cHashM);\n}\n\nvec4 Hashv4v3 (vec3 p)\n{\n  vec3 cHashVA3 = vec3 (37., 39., 41.);\n  vec2 e = vec2 (1., 0.);\n  return fract (sin (vec4 (dot (p + e.yyy, cHashVA3), dot (p + e.xyy, cHashVA3),\n     dot (p + e.yxy, cHashVA3), dot (p + e.xxy, cHashVA3))) * cHashM);\n}\n\nfloat Noiseff (float p)\n{\n  vec2 t;\n  float ip, fp;\n  ip = floor (p);\n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = Hashv2f (ip);\n  return mix (t.x, t.y, fp);\n}\n\nfloat Noisefv2 (vec2 p)\n{\n  vec2 t, ip, fp;\n  ip = floor (p);  \n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = mix (Hashv2v2 (ip), Hashv2v2 (ip + vec2 (0., 1.)), fp.y);\n  return mix (t.x, t.y, fp.x);\n}\n\nfloat Noisefv3 (vec3 p)\n{\n  vec4 t;\n  vec3 ip, fp;\n  ip = floor (p);\n  fp = fract (p);\n  fp *= fp * (3. - 2. * fp);\n  t = mix (Hashv4v3 (ip), Hashv4v3 (ip + vec3 (0., 0., 1.)), fp.z);\n  return mix (mix (t.x, t.y, fp.x), mix (t.z, t.w, fp.x), fp.y);\n}\n\nfloat Fbm2 (vec2 p)\n{\n  float f, a;\n  f = 0.;\n  a = 1.;\n  for (int j = 0; j < 5; j ++) {\n    f += a * Noisefv2 (p);\n    a *= 0.5;\n    p *= 2.;\n  }\n  return f * (1. / 1.9375);\n}\n\nfloat Fbm3 (vec3 p)\n{\n  float f, a;\n  f = 0.;\n  a = 1.;\n  for (int i = 0; i < 5; i ++) {\n    f += a * Noisefv3 (p);\n    a *= 0.5;\n    p *= 2.;\n  }\n  return f * (1. / 1.9375);\n}\n\nfloat Fbmn (vec3 p, vec3 n)\n{\n  vec3 s;\n  float a;\n  s = vec3 (0.);\n  a = 1.;\n  for (int i = 0; i < 5; i ++) {\n    s += a * vec3 (Noisefv2 (p.yz), Noisefv2 (p.zx), Noisefv2 (p.xy));\n    a *= 0.5;\n    p *= 2.;\n  }\n  return dot (s, abs (n));\n}\n\nvec3 VaryNf (vec3 p, vec3 n, float f)\n{\n  vec3 g;\n  vec2 e;\n  e = vec2 (0.1, 0.);\n  g = vec3 (Fbmn (p + e.xyy, n), Fbmn (p + e.yxy, n), Fbmn (p + e.yyx, n)) - Fbmn (p, n);\n  return normalize (n + f * (g - n * dot (n, g)));\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc-by-nc-sa-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/7dj3Wz.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "7dj3zd", "name": "Inverse Reflection II", "author": "oneshade", "description": "Inverse reflection for procedural 2D light. No randomly sampled rays and no explicitly drawn ones either. I'm trying to figure out how to do this for a sphere next.", "tags": ["2d", "reflection", "ray", "math", "physics", "optics", "inverse"], "likes": 6, "viewed": 115, "date": "1617845639", "time_retrieved": "2024-06-20T20:36:09.656349", "image_code": "// Fork of \"Inverse Reflection\" by oneshade\n// https://www.desmos.com/calculator/mleeqxa7k9\n\n// Drawing utilities\n#define drawSDF(dist, transp, col) color = mix(color, col, smoothstep(unit, 0.0, dist) * transp)\n\n// Hue to RGB function from Fabrice's shadertoyunofficial blog:\n#define hue2rgb(hue) 0.6 + 0.6 * cos(6.3 * hue + vec3(0.0, 23.0, 21.0))\n\n// SDFs\nfloat sdDisc(in vec2 p, in vec2 o, in float r) {\n    return length(p - o) - r;\n}\n\nfloat sdPlane2D(in vec2 p, in vec2 pos, in vec2 nor) {\n    return abs(dot(p - pos, nor));\n}\n\nfloat sdLine(in vec2 p, in vec2 a, in vec2 b) {\n    vec2 pa = p - a, ba = b - a;\n    return length(pa - ba * clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0));\n}\n\n// Computes the incident point between the point and light\n// l: light position\n// p: point position\n// o: reflector position\n// n: reflector direction\nvec2 getIncidence(in vec2 l, in vec2 p, in vec2 o, in vec2 n) {\n    l -= o; p -= o;\n    vec2 d = p - 2.0 * n * dot(p, n) - l;\n    return l - dot(l, n) / dot(d, n) * d + o;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 center = 0.5 * iResolution.xy;\n\n    vec4 mouse = (vec4(iMouse.xy, abs(iMouse.zw)) - center.xyxy) / iResolution.y * 4.0;\n    vec2 uv = (fragCoord - center) / iResolution.y * 4.0;\n    float unit = 8.0 / iResolution.y;\n    vec3 color = vec3(0.0);\n\n    vec2 light = iMouse.z > 0.0 ? mouse.xy : vec2(0.0, 1.0);\n    float scroll = iTime * 0.1;\n\n    vec2 reflectorPos = vec2(0.0, -1.0);\n    vec2 reflectorDir = vec2(0.0, 1.0);\n\n    float tilt = sin(iTime) * 0.5;\n    float c = cos(tilt), s = sin(tilt);\n    reflectorDir *= mat2(c, s, -s, c);\n\n    vec2 perp = vec2(reflectorDir.y, -reflectorDir.x);\n    vec2 e1 = reflectorPos + perp * 2.0;\n    vec2 e2 = reflectorPos - perp * 2.0;\n\n    // Draw the light rays if they are outside the plane\n    if (dot(light - reflectorPos, reflectorDir) > 0.0) {\n        // Draw the edges of the beam\n        if (dot(uv - reflectorPos, reflectorDir) > 0.0) {\n            drawSDF(sdPlane2D(uv, e1, (reflect(normalize(e1 - light), reflectorDir)).yx * vec2(-1.0, 1.0)), 1.0, hue2rgb(0.0));\n            drawSDF(sdPlane2D(uv, e2, (reflect(normalize(e2 - light), reflectorDir)).yx * vec2(-1.0, 1.0)), 1.0, hue2rgb(1.0));\n        }\n\n        // Draw the beam\n        vec2 i = getIncidence(light, uv, reflectorPos, reflectorDir);\n        if (dot(uv - reflectorPos, reflectorDir) > 0.0) {\n            if (abs(dot(i - reflectorPos, perp)) < 2.0) color = hue2rgb(dot(i - reflectorPos, perp) / 4.0 + 3.14);\n            vec2 rd = uv - light;\n            vec2 hit = light - rd * dot(light - reflectorPos, reflectorDir) / dot(rd, reflectorDir);\n            if (abs(dot(hit - reflectorPos, perp)) < 2.0 && dot(rd, reflectorDir) < 0.0) {\n                color = hue2rgb(dot(hit - reflectorPos, perp) / 4.0 + 3.14);\n            }\n        }\n\n        // Draw the edges of the beam\n        drawSDF(sdLine(uv, light, e1), 1.0, vec3(0.0));\n        drawSDF(sdLine(uv, light, e2), 1.0, vec3(0.0));\n    }\n\n    // Draw the light and reflector\n    drawSDF(sdDisc(uv, light, 0.05), 1.0, vec3(1.0));\n    drawSDF(sdPlane2D(uv, reflectorPos, reflectorDir) - 0.01, 1.0, vec3(0.0, 0.0, 1.0));\n\n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/7dj3zd.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "7dj3zK", "name": "mind dump", "author": "sullly", "description": "meh", "tags": ["fractal", "simple", "abstract", "idk"], "likes": 1, "viewed": 40, "date": "1617685866", "time_retrieved": "2024-06-20T20:36:09.844330", "image_code": "//useful functions\nvec2 rotate(vec2 v, float a) { return mat2(cos(a), -sin(a), sin(a), cos(a))*v; }\nfloat remap(float v, float a, float b, float c, float d) { return (v - a) / (b - a) * (d - c) + c; }\nfloat divMod(float a, float m) { return remap(mod(a, m), 0.0, m, -1.0, 1.0); }\n\nvoid mainImage( out vec4 p, in vec2 fragCoord )\n{\n\tvec2 uv = gl_FragCoord.xy / iResolution.xy;\n  uv -= 0.5;\n  uv.x = divMod(uv.x, exp(1. / iTime));\n  uv.y = divMod(uv.y, 2.);\n  \n  for (int i = 0; i < 10; ++i){\n    uv = abs(uv) - 0.09;\n    uv = rotate(uv, 0.5*iTime);\n    uv = rotate(uv, abs(uv.y));\n    uv = rotate(uv, abs(uv.x));\n  }\n  for (float i = 0.; i < atan(iTime); i+=0.5) {\n    uv = rotate(uv, exp(abs(uv.y))- 0.2);\n    uv = rotate(uv, atan(i));\n  }\n  float r = 0.2+uv.x/uv.y;\n  vec3 q = cross(vec3(uv.x, uv.y, uv.x*uv.y), vec3(2, 0.5, 0.5)); \n  p = vec4(q-r, 1);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/7dj3zK.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "7djGzy", "name": "Nate's Fragged", "author": "Wotan", "description": "4D perlin noise used to swirl. ", "tags": ["swirl", "perlin", "mask", "noisr"], "likes": 2, "viewed": 68, "date": "1617615360", "time_retrieved": "2024-06-20T20:36:10.923221", "image_code": "#define NUM_POINTS 220.0\n#define SPEED 0.487\n#define CLOUD_SCALE 0.3\n\nvec2 Anim(float t, float seed) {\n    t += 1000.0;\n    float t_pos = fract(sin(seed*674.3)*453.2);\n\n    float x = sin(t*t_pos) + cos((t*2.146)*t_pos) + sin((t*0.15347)*t_pos);\n    float y = cos(t*t_pos) + sin((t*1.317)*t_pos);\n    \n    return vec2(x,y);\n}\n\n#define FADE(t) ( t * t * t * ( t * ( t * 6 - 15 ) + 10 ) )\n\n#define FASTFLOOR(x) \n#define LERP(t, a, b) ((a) + (t)*((b)-(a)))\n\nint fastfl( float x)\n{\n    if (x>0.0)\n    {\n        return int(x);\n    }\n    \n    return int(x-1.0);    \n}\n\nfloat fade( float t)\n{\n    return    ( t * t * t * ( t * ( t * 6.0 - 15.0 ) + 10.0 ));\n}\n\n\n\n//  Simplex 4D Noise \n//  by Ian McEwan, Ashima Arts\n//\nvec4 permute(vec4 x){return mod(((x*34.0)+1.0)*x, 289.0);}\nfloat permute(float x){return floor(mod(((x*34.0)+1.0)*x, 289.0));}\nvec4 taylorInvSqrt(vec4 r){return 1.79284291400159 - 0.85373472095314 * r;}\nfloat taylorInvSqrt(float r){return 1.79284291400159 - 0.85373472095314 * r;}\n\nvec4 grad4(float j, vec4 ip){\n  const vec4 ones = vec4(1.0, 1.0, 1.0, -1.0);\n  vec4 p,s;\n\n  p.xyz = floor( fract (vec3(j) * ip.xyz) * 7.0) * ip.z - 1.0;\n  p.w = 1.5 - dot(abs(p.xyz), ones.xyz);\n  s = vec4(lessThan(p, vec4(0.0)));\n  p.xyz = p.xyz + (s.xyz*2.0 - 1.0) * s.www; \n\n  return p;\n}\n\nfloat snoise(vec4 v){\n  const vec2  C = vec2( 0.138196601125010504,  // (5 - sqrt(5))/20  G4\n                        0.309016994374947451); // (sqrt(5) - 1)/4   F4\n// First corner\n  vec4 i  = floor(v + dot(v, C.yyyy) );\n  vec4 x0 = v -   i + dot(i, C.xxxx);\n\n// Other corners\n\n// Rank sorting originally contributed by Bill Licea-Kane, AMD (formerly ATI)\n  vec4 i0;\n\n  vec3 isX = step( x0.yzw, x0.xxx );\n  vec3 isYZ = step( x0.zww, x0.yyz );\n//  i0.x = dot( isX, vec3( 1.0 ) );\n  i0.x = isX.x + isX.y + isX.z;\n  i0.yzw = 1.0 - isX;\n\n//  i0.y += dot( isYZ.xy, vec2( 1.0 ) );\n  i0.y += isYZ.x + isYZ.y;\n  i0.zw += 1.0 - isYZ.xy;\n\n  i0.z += isYZ.z;\n  i0.w += 1.0 - isYZ.z;\n\n  // i0 now contains the unique values 0,1,2,3 in each channel\n  vec4 i3 = clamp( i0, 0.0, 1.0 );\n  vec4 i2 = clamp( i0-1.0, 0.0, 1.0 );\n  vec4 i1 = clamp( i0-2.0, 0.0, 1.0 );\n\n  //  x0 = x0 - 0.0 + 0.0 * C \n  vec4 x1 = x0 - i1 + 1.0 * C.xxxx;\n  vec4 x2 = x0 - i2 + 2.0 * C.xxxx;\n  vec4 x3 = x0 - i3 + 3.0 * C.xxxx;\n  vec4 x4 = x0 - 1.0 + 4.0 * C.xxxx;\n\n// Permutations\n  i = mod(i, 289.0); \n  float j0 = permute( permute( permute( permute(i.w) + i.z) + i.y) + i.x);\n  vec4 j1 = permute( permute( permute( permute (\n             i.w + vec4(i1.w, i2.w, i3.w, 1.0 ))\n           + i.z + vec4(i1.z, i2.z, i3.z, 1.0 ))\n           + i.y + vec4(i1.y, i2.y, i3.y, 1.0 ))\n           + i.x + vec4(i1.x, i2.x, i3.x, 1.0 ));\n// Gradients\n// ( 7*7*6 points uniformly over a cube, mapped onto a 4-octahedron.)\n// 7*7*6 = 294, which is close to the ring size 17*17 = 289.\n\n  vec4 ip = vec4(1.0/294.0, 1.0/49.0, 1.0/7.0, 0.0) ;\n\n  vec4 p0 = grad4(j0,   ip);\n  vec4 p1 = grad4(j1.x, ip);\n  vec4 p2 = grad4(j1.y, ip);\n  vec4 p3 = grad4(j1.z, ip);\n  vec4 p4 = grad4(j1.w, ip);\n\n// Normalise gradients\n  vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));\n  p0 *= norm.x;\n  p1 *= norm.y;\n  p2 *= norm.z;\n  p3 *= norm.w;\n  p4 *= taylorInvSqrt(dot(p4,p4));\n\n// Mix contributions from the five corners\n  vec3 m0 = max(0.6 - vec3(dot(x0,x0), dot(x1,x1), dot(x2,x2)), 0.0);\n  vec2 m1 = max(0.6 - vec2(dot(x3,x3), dot(x4,x4)            ), 0.0);\n  m0 = m0 * m0;\n  m1 = m1 * m1;\n  return 49.0 * ( dot(m0*m0, vec3( dot( p0, x0 ), dot( p1, x1 ), dot( p2, x2 )))\n               + dot(m1*m1, vec2( dot( p3, x3 ), dot( p4, x4 ) ) ) ) ;\n\n}\n\n//\n// -------------------------------------------------------------------------------------------\n\nvec3 snoise_swirl( vec3 noisept, float timeMult, int octaves, float dimension, float lacunarity,  float xscl, float yscl, float zscl)\n{\n    float amp, ampsum;\n\n    vec4 np = vec4(noisept.x, noisept.y,noisept.z, 0.0);\n    np.x *= xscl;\n    np.y *= yscl;\n    np.z *= zscl;\n    np.w = iTime * timeMult;\n\n    vec3 sum = vec3(0,0,0);\n    ampsum = 0.0;\n    amp = 1.0;\n    \n    float H = 1.0f - dimension;\n    float ampfactor = 1.0f / pow(lacunarity, H);\n   \n\n    for (int j=0; j<octaves; j++, amp*ampfactor)\n    {\n        if (j > 0)\n        {\n            np.x *= lacunarity;\n            np.y *= lacunarity;\n            np.z *= lacunarity;\n        }\n\n        float nx = snoise( vec4(np.x, 0.0, 0.0, np.w ));\n        float ny = snoise( vec4(0.0, np.y, 0.0, np.w ));\n        float nz = snoise( vec4(0.0, 0.0, np.z, np.w ));\n\n        vec3 ret = vec3( nx, ny, nz );             \n                          \n        sum += ret * amp;\n\n        ampsum += amp;\n    }\n    sum.x /= ampsum;\n    sum.y /= ampsum;\n    sum.z /= ampsum;\n                          \n    return sum;\n}\n\nvec3 getPattern(vec3 p)\n{\n    vec3 nz = snoise_swirl( p, 0.8, 2, 0.75, 1.0,  0.01, 0.01, 0.01);\n    \n    return nz;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord-0.5*iResolution.xy)/iResolution.y;\n\n    // Time varying pixel color\n    vec3 col = 0.5 + 0.5 * cos( iTime + uv.xyx + vec3(0,2,4) );\n    vec3 mask = vec3(0);\n    //col *= 0.1;\n    \n    float speed = 0.487;\n    float cloud_scale = 0.3;\n    \n    for(float i=0.0; i<NUM_POINTS; i++) {\n        // Point \n        vec3 inP = vec3(i, i, i) * (iMouse[0]*0.01);\n        vec3 direction3 = getPattern(inP);//Anim( (iTime*SPEED)*3.0, i ) *CLOUD_SCALE;\n        \n        vec2 direction = vec2(direction3.x, direction3.y);\n        float d = length( uv - direction );\n        float brightness = 0.00075;\n        mask += brightness / d;\n    }\n    \n    col *= mask*mask*mask;\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/7djGzy.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "7djSzW", "name": "Orthographic Line Renderer", "author": "wildniklin", "description": "confusion go brr...", "tags": ["ortho"], "likes": 3, "viewed": 176, "date": "1619808928", "time_retrieved": "2024-06-20T20:36:10.923221", "image_code": "const float SCALE = 4.0;\nconst float LINE_THICKNESS = 0.01;\nconst float MAX_DISTANCE = 10000.0;\n\nconst bool SHOW_DISTANCE = false;\n\nconst float PI = 3.1415;\n\nmat2 rot(float r)\n{\n    float s = sin(r), c = cos(r);\n    return mat2(c, -s, s, c);\n}\n\nfloat sliderPointLine(vec2 a, vec2 b, vec2 p)\n{\n    vec2 ab = b - a;\n    return clamp(dot(p - a, ab) / dot(ab, ab), 0.0, 1.0);\n}\n\nvec2 closestPointLine(vec2 a, vec2 b, float dist) { if (dist < 0.0) return a; else if (dist > 1.0) return b; else return mix(a, b, dist); }\n\nvec2 closestPointLine(vec2 a, vec2 b, vec2 p) { return closestPointLine(a, b, sliderPointLine(a, b, p)); }\n\nfloat distToLine(vec2 a, vec2 b, vec2 p) { return length(p - closestPointLine(a, b, p)); }\n\nvec3 worldToView(vec3 p)\n{\n    p.xz *= rot(iTime * PI * 0.25); // Rotate World Y\n    p.yz *= rot(sin(iTime * PI * 0.25) * PI * 0.1); // Rotate World X\n    p -= vec3(0.0, 0.0, 3.0); // Cam Position\n    \n    p.xy /= SCALE;\n    p.z = SCALE;\n    \n    return p;\n}\n\nfloat distLine(vec3 a, vec3 b, vec2 p)\n{\n    float dist = sliderPointLine(a.xy, b.xy, p);\n    if((a.z < 0.0) || (b.z < 0.0)) return MAX_DISTANCE;\n    float fade = mix(a.z, b.z, dist);\n    return length(p - closestPointLine(a.xy, b.xy, dist)) - (LINE_THICKNESS / fade);\n}\n\nfloat distToBoxLines(vec3 p, vec3 s, vec2 uv)\n{\n    s *= 0.5;\n    \n    vec3 bmin = p - s; // Left down back   (box min pos)\n    vec3 bmax = p + s; // Right up forward (box max pos)\n    vec3 ldb = worldToView(bmin);\n    vec3 rdb = worldToView(vec3(bmax.x, bmin.y, bmin.z));\n    vec3 lub = worldToView(vec3(bmin.x, bmax.y, bmin.z));\n    vec3 rub = worldToView(vec3(bmax.x, bmax.y, bmin.z));\n    vec3 ldf = worldToView(vec3(bmin.x, bmin.y, bmax.z));\n    vec3 rdf = worldToView(vec3(bmax.x, bmin.y, bmax.z));\n    vec3 luf = worldToView(vec3(bmin.x, bmax.y, bmax.z));\n    vec3 ruf = worldToView(bmax);\n    \n    float d = MAX_DISTANCE;\n\n    d = min(d, distLine(ldb, ldf, uv));\n    d = min(d, distLine(ldb, rdb, uv));\n    d = min(d, distLine(ldf, rdf, uv));\n    d = min(d, distLine(rdf, rdb, uv));\n    \n    d = min(d, distLine(ldb, lub, uv));\n    d = min(d, distLine(luf, ldf, uv));\n    d = min(d, distLine(rdb, rub, uv));\n    d = min(d, distLine(ruf, rdf, uv));\n    \n    d = min(d, distLine(lub, luf, uv));\n    d = min(d, distLine(lub, rub, uv));\n    d = min(d, distLine(luf, ruf, uv));\n    d = min(d, distLine(ruf, rub, uv));\n    \n    return d;\n}\n\nvoid mainImage(out vec4 o, in vec2 i)\n{\n    float aspect = min(iResolution.x, iResolution.y);\n    vec2 uv = (i - (0.5 * iResolution.xy)) / aspect;\n    float tp = 1.0 / aspect;\n\n    vec3 col = vec3(0.0, 0.0, 0.0);\n    \n    float dist = MAX_DISTANCE;\n    \n    dist = min(dist, distToBoxLines(vec3(0.0), vec3(1.0), uv) - LINE_THICKNESS);\n    \n    dist = min(dist, distToBoxLines(vec3(0.0, 0.0, 2.0), vec3(1.0), uv) - LINE_THICKNESS);\n    \n    dist = min(dist, distToBoxLines(vec3(0.0, 0.0, -2.0), vec3(1.0), uv) - LINE_THICKNESS);\n    \n    if(SHOW_DISTANCE) col += ((dist < 0.0) ? -vec3(1.0, 0.2, 0.2) : vec3(0.2, 0.2, 1.0)) * dist;\n    else col += smoothstep(0.0, -tp * 2.0, dist);\n    \n    o = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/7djSzW.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "7dlSWn", "name": "Apollonian 3D", "author": "kithy", "description": "apollonian,fractal,raymarching", "tags": ["raymarching", "fractal", "apollonian"], "likes": 6, "viewed": 71, "date": "1618500111", "time_retrieved": "2024-06-20T20:36:10.929175", "image_code": "#define EPS 0.001\n#define MAX_STEPS 32\n#define ITR 8\n\nmat2 rot(float a){\n\tfloat s=sin(a);\n\tfloat c=cos(a);\n\treturn mat2(c,s,-s,c);\n}\n\n\n\nfloat scale;\n\nfloat map(vec3 p){\n\tp+=vec3(1.0,1.0,iTime*0.2);\n\tp.xy*=rot(iTime*0.05);\n\tp.yz*=rot(iTime*0.05);\n\tfloat s=3.0;\n\tfor(int i=0;i<ITR;i++){\n\t\tp=mod(p-1.0,2.0)-1.0;\n\t\tfloat r=1.53/dot(p,p);\n\t\tp*=r;\n\t\ts*=r;\n\t}\n\tscale=s;\n\treturn dot(abs(p),normalize(vec3(0.0,1.0,1.0)))/s;\n}\n\nvec3 GetNormal(vec3 p){\n\tfloat d=map(p);\n\tvec2 e=vec2(EPS,0.0);\n\n\tvec3 n=d-vec3(\n\t\tmap(p-e.xyy),\n\t\tmap(p-e.yxy),\n\t\tmap(p-e.yyx));\n\treturn normalize(n);\n}\n\n\n\nvoid mainImage(out vec4 fragColor,in vec2 fragCoord){\n\tvec2 uv=(2.0*fragCoord.xy-iResolution.xy)/iResolution.y;\n\n\tvec3 col=vec3(0.0);\n\n\tvec3 rd=normalize(vec3(uv,1.0));\n\tvec3 p=vec3(0.0,0.0,iTime*0.05);\n\t\n\tfloat d;\n\t\n\t//vec3 normal;\n\n\tfloat emission=0.0;\n\n\tfor(int i=0;i<MAX_STEPS;i++){\n\t\td=map(p);\n\t\tp+=rd*d;\n\t\t//normal=GetNormal(p);\n\t\temission+=exp(d*-0.4);\n\t\tif(d<EPS)break;\n\t}\n\n\tvec4 color=0.02*emission*vec4(sin(iTime),1.0,sin(iTime),1.0);\n\tfragColor=color;\n\t//fragColor=vec4(normal*0.5+0.5,1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/7dlSWn.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "7dlSz2", "name": "Pixel Cat", "author": "jin_x", "description": "Learning shaders :)", "tags": ["pixel"], "likes": 5, "viewed": 63, "date": "1618913923", "time_retrieved": "2024-06-20T20:36:11.341337", "image_code": "#define TUNNEL\n\nconst int img[64] = int[](\n        4,0,0,0,0,0,0,4,\n        4,4,0,0,0,0,4,4,\n        4,4,4,0,0,4,4,4,\n        4,1,4,4,4,4,2,4,\n        4,4,4,3,3,4,4,4,\n        4,4,4,4,4,4,3,4,\n        4,4,3,3,3,3,4,4,\n        0,4,4,4,4,4,4,0\n    );\n\n// random hash by IQ: https://www.shadertoy.com/view/llGSzw\nfloat hash1(uint n)\n{\n    // integer hash copied from Hugo Elias\n\tn = (n << 13U) ^ n;\n    n = n * (n * n * 15731U + 789221U) + 1376312589U;\n    return float( n & uvec3(0x7fffffffU))/float(0x7fffffff);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // Normalize pixel coordinates (y = -0.5..0.5, x = -xres/yres/2..xres/yres/2)\n    vec2 uv = fragCoord/iResolution.xy;\n    float ar = iResolution.x/iResolution.y;\n    uv -= 0.5;\n    uv.x *= ar;\n    \n    // Rotate and zoom (uvr) for image\n    float a = sin(iTime*2.5)/1.25, sa = sin(a), ca = cos(a);\n    vec2 uvr = (uv + vec2(sin(iTime*3.5)/8.*ar, cos(iTime*2.5)/8.)) * mat2(ca, -sa, sa, ca) * (sin(iTime*4.)/6.+1.);\n    \n    // Transform background\n#ifdef TUNNEL\n    float l = length(uv) * (sin(iTime*2.)+3.);\n    a = atan(uv.y, uv.x) + pow(sin(uv.x*5. + iTime*1.5)*.5, 2.) - iTime*.5;\n#else\n    uv += vec2(sin(uv.y*(abs(mod(iTime*0.5,2.)-1.)*30.+5.))/30., sin(uv.x*(abs(mod(iTime*0.3,2.)-1.)*30.+5.))/30.);\n#endif\n\n    // Convert coords to integer for background\n    float cnt = 30.;\n    ivec2 iuv = ivec2(floor(uv.x*cnt), floor(-uv.y*cnt));\n    \n    // Convert coords to integer for image\n    ivec2 ii = ivec2(floor(uvr.x*cnt), floor(-uvr.y*cnt)) + 4;\n    \n    // Draw\n    vec3 col;\n    int n = img[ii.x + ii.y*8];\n    if (all(greaterThanEqual(ii, ivec2(0, 0))) && all(lessThan(ii, ivec2(8, 8))) && n != 0) {\n      if (n == 4) {  // image\n        col = vec3(sin((iTime+uv.y*5.)*5.)/4.+.74, 0., 0.);\n      } else {\n        float i = sin(iTime*6.)/2. + 0.5;\n        i = i * float(int(n)&1) + (1.-i) * float((int(n)&2)>>1);\n        col = vec3(i, i, 0.);\n      }\n    } else {\n#ifdef TUNNEL\n      float i = (((int(sqrt(sqrt(l))*cnt*1.5)^int(floor(a*cnt/3.1416))) & 1) == 0 ? 0.7 : 0.3);\n#else\n      float i = (((iuv.x^iuv.y) & 1) == 0 ? 0.7 : 0.3);\n#endif\n      i *= (1. + sin(iTime*4.)/4.);\n      i += hash1(uint(fragCoord.x) + uint(fragCoord.y)*1920U + uint(iFrame)*1920U*1080U)*.5 - .25;\n#ifdef TUNNEL\n      i *= (l-0.25)/2.;\n#endif\n      col = vec3(i*.2, i*.5, i);  // chessboard\n    }\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/7dlSz2.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "7dlXDM", "name": "Truchet UV", "author": "genekeats", "description": "following along with Martijn", "tags": ["texture", "truchet", "hash"], "likes": 2, "viewed": 42, "date": "1619009671", "time_retrieved": "2024-06-20T20:36:11.341337", "image_code": "float Hash21(vec2 p) {\n    p = fract(p*vec2(.24687,.13579));\n    p += dot(p, p+9.1);\n    return fract(p.x*p.y);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\n    vec3 col = vec3(0);\n    \n    vec2 muv =(iMouse.xy-.5*iResolution.xy)/iResolution.y;\n    muv = 7.*uv-muv*iTime;\n        \n    vec2 gv = fract(muv)-.5;\n    vec2 id = floor(muv);\n    \n    float n = Hash21(id);\n    float width = .19;\n    \n    if(n<.5) gv.x *= -1.;\n    float d = abs(abs(gv.x + gv.y)-.5);\n    \n    vec2 cuv = gv-sign(gv.x + gv.y + .001)*.5;\n    \n    d = length(cuv);\n    float mask = smoothstep(.01, -.01, abs(d-.5)-width);\n    float angle = atan(cuv.x, cuv.y); // -pi to pi\n    float chk = mod(id.x+id.y, 2.)*2.-1.;\n    float flow = sin(iTime+chk*angle*12.);\n    \n    float x = fract(chk*angle/1.570796+iTime*.3);\n    float y = (d-(.5-width))/(2.*width);\n    //y = abs(y-.5)*2.;\n    if(n<.5 ^^ chk>0.) y=1.-y;\n    \n    vec2 tuv = vec2(x,y);\n    \n    col += (1.-mask)*vec3(.5-uv.y, .5-uv.y*.55, .35);\n    //col += (1.-mask)*vec3(uv+.5,.5); // original garish color scheme\n    col += texture(iChannel0, tuv).rgb*mask;\n        \n    //if (gv.x>.48 || gv.y>.48) col = vec3(1,0,0);\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": "4dfGRn", "previewfilepath": "/media/ap/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/7dlXDM.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "7dS3DD", "name": "One Ring in Green Hill Zone", "author": "inspirnathan", "description": "One ring is all you need!", "tags": ["raymarching", "phong", "sonic", "ring", "greenhillzone", "inspirnathan"], "likes": 4, "viewed": 88, "date": "1617407314", "time_retrieved": "2024-06-20T20:36:12.389904", "image_code": "/*\n** One Ring in Green Hill Zone by inspirnathan (Nathan Vaughn)\n** \n** Resources/Credit:\n** Torus SDF: https://www.iquilezles.org/www/articles/distfunctions/distfunctions.htm\n** Phong Illumination: http://jamie-wong.com/2016/07/15/ray-marching-signed-distance-functions/\n** Fog: https://www.iquilezles.org/www/articles/fog/fog.htm\n** Music: https://soundcloud.com/video-game-sound-tracks/sega-genesis-sonic-the-hedgehog-green-hill-zone\n*/\n\nconst int MAX_MARCHING_STEPS = 255;\nconst float MIN_DIST = 0.0;\nconst float MAX_DIST = 100.0;\nconst float PRECISION = 0.001;\nconst float PI = 3.14159265359;\nconst vec3 light1Pos = vec3(2, 10, 1);\nconst vec3 light2Pos = vec3(0, -1, 4);\n\nmat3 rotateX(float theta) {\n  float c = cos(theta);\n  float s = sin(theta);\n  return mat3(\n    vec3(1, 0, 0),\n    vec3(0, c, -s),\n    vec3(0, s, c)\n  );\n}\n\nmat3 rotateY(float theta) {\n  float c = cos(theta);\n  float s = sin(theta);\n  return mat3(\n    vec3(c, 0, s),\n    vec3(0, 1, 0),\n    vec3(-s, 0, c)\n  );\n}\n\nmat3 rotateZ(float theta) {\n  float c = cos(theta);\n  float s = sin(theta);\n  return mat3(\n    vec3(c, -s, 0),\n    vec3(s, c, 0),\n    vec3(0, 0, 1)\n  );\n}\n\nmat3 identity() {\n  return mat3(\n    vec3(1, 0, 0),\n    vec3(0, 1, 0),\n    vec3(0, 0, 1)\n  );\n}\n\nstruct Material {\n  vec3 k_d; // diffuse reflection coefficient\n  vec3 k_a; // ambient reflection coefficient\n  vec3 k_s; // specular reflection coefficient\n  float alpha; // shininess constant\n};\n\nstruct Surface {\n  int id; // id of object\n  float sd; // signed distance\n  Material mat;\n};\n\nMaterial shinyYellow() {\n  vec3 k_d = vec3(1., .67, 0.2) * 1.8;\n  vec3 k_a = vec3(0.);\n  vec3 k_s = vec3(1);\n  float alpha = 5.;\n  return Material(k_d, k_a, k_s, alpha);\n}\n\nMaterial checkerBoard(vec3 p) {\n  vec3 k_d = vec3(1. + 0.9 * mod(floor(p.x) + floor(p.z), 2.0)) * vec3(0.93, 0.6, 0.40) * 2. - .8;\n  vec3 k_a = vec3(0.3);\n  vec3 k_s = vec3(0);\n  float alpha = 1.;\n  return Material(k_d, k_a, k_s, alpha);\n}\n\nvec3 transform(vec3 p, vec3 offset, mat3 transformationMatrix) {\n  return (p - offset) * transformationMatrix;\n}\n\nfloat sdTorus(vec3 p, vec2 t)\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\nSurface sFloor(vec3 p) {\n  Surface flooring;\n  flooring.id = 1;\n  flooring.sd = p.y + 1.;\n  flooring.mat = checkerBoard(p);\n\n  return flooring;\n}\n\nSurface sRing(vec3 p) {\n  vec3 offset = vec3(0, 0.5, -4);\n  mat3 m = rotateZ(PI/2.) * rotateX(iTime);\n\n  Surface ring;\n  ring.id = 2;\n  ring.sd = sdTorus(transform(p, offset, m), vec2(0.5, 0.1));\n  ring.mat = shinyYellow();\n  \n  return ring;\n}\n\nSurface opUnion(Surface obj1, Surface obj2) {\n  if (obj2.sd < obj1.sd) return obj2;\n  return obj1;\n}\n\nSurface scene(vec3 p) {\n  Surface co = sFloor(p);\n  co = opUnion(co, sRing(p));\n  return co;\n}\n\nSurface rayMarch(vec3 ro, vec3 rd) {\n  float depth = MIN_DIST;\n  Surface co; // closest object\n\n  for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n    vec3 p = ro + depth * rd;\n    co = scene(p);\n    depth += co.sd;\n    if (co.sd < PRECISION || depth > MAX_DIST) break;\n  }\n  \n  co.sd = depth;\n  \n  return co;\n}\n\nvec3 calcNormal(in vec3 p) {\n  vec2 e = vec2(1, -1) * 0.0005;\n  return normalize(\n    e.xyy * scene(p + e.xyy).sd +\n    e.yyx * scene(p + e.yyx).sd +\n    e.yxy * scene(p + e.yxy).sd +\n    e.xxx * scene(p + e.xxx).sd);\n}\n\nvec3 phongContribForLight(vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye, vec3 lightPos, vec3 lightIntensity) {\n  vec3 N = calcNormal(p);\n  vec3 L = normalize(lightPos - p);\n  vec3 V = normalize(eye - p);\n  vec3 R = normalize(reflect(-L, N));\n\n  float dotLN = clamp(dot(L, N), 0., 1.);\n  float dotRV = clamp(dot(R, V), 0., 1.);\n\n  return lightIntensity * (k_d * dotLN + k_s * pow(dotRV, alpha));\n}\n\nvec3 phongIllumination(vec3 k_a, vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye) {\n  const vec3 ambientLight = vec3(0.3);\n  vec3 color = ambientLight * k_a;\n\n  vec3 light1Int = vec3(0.3);\n\n  color += phongContribForLight(k_d, k_s, alpha, p, eye, light1Pos, light1Int);\n\n  vec3 light2Int = vec3(0.7);\n\n  color += phongContribForLight(k_d, k_s, alpha, p, eye, light2Pos, light2Int);    \n  return color;\n}\n\nfloat shadow(vec3 p, vec3 light, float darkness) {\n  vec3 lightDir = normalize(light - p);\n  float shadowRayLength = rayMarch(p + calcNormal(p)*PRECISION, lightDir).sd;\n  if (shadowRayLength < length(lightDir - p)) return -darkness;\n  else return 1.;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n  vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\n  vec3 col = vec3(0);\n  vec3 ro = vec3(0);\n  vec3 rd = normalize(vec3(uv, -1));\n\n  Surface co = rayMarch(ro, rd);\n\n  if (co.sd > MAX_DIST) {\n    col = mix(vec3(0, 1, 1), vec3(0, 0, 1), uv.y);\n  } else {\n    vec3 p = ro + rd * co.sd;\n    vec3 normal = calcNormal(p);\n    \n    vec3 K_a = co.mat.k_a;\n    vec3 K_d = co.mat.k_d;\n    vec3 K_s = co.mat.k_s;\n    float shininess = co.mat.alpha;\n\n    col = K_a * shadow(p, light1Pos, 0.);\n\n    col += phongIllumination(K_a, K_d, K_s, shininess, p, ro);\n\n    col = mix( col, vec3(0, 1, 0.6), 1. - exp( -0.0002 * co.sd * co.sd * 6.));\n  }\n\n  fragColor = vec4(col, 1.0);\n}\n", "image_inputs": [{"id": "4llSWM", "previewfilepath": "https://soundcloud.com/video-game-sound-tracks/sega-genesis-sonic-the-hedgehog-green-hill-zone", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0, "src": "https://soundcloud.com/video-game-sound-tracks/sega-genesis-sonic-the-hedgehog-green-hill-zone", "ctype": "musicstream"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/7dS3DD.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "7dS3Dm", "name": "Subsurface Scattering Appr_HW09", "author": "roamingsci", "description": "This is an approximation of subsurface scattering in a basic Cornell Box.", "tags": ["subsurfacescattering"], "likes": 2, "viewed": 57, "date": "1617485899", "time_retrieved": "2024-06-20T20:36:13.650607", "image_code": "const int RAY_STEPS = 256;\nconst float FOVY = 3.141569 * 0.25;\n\n// The higher the value, the smaller the penumbra\nconst float SHADOW_HARDNESS = 10.0;\n// Adjust these to alter where the subsurface glow shines through and how brightly\nconst float FIVETAP_K = 2.0;\nconst float AO_DIST = 0.085;\n// The larger the DISTORTION, the smaller the glow\nconst float DISTORTION = 0.2;\n// The higher GLOW is, the smaller the glow of the subsurface scattering\nconst float GLOW = 6.0;\n// The higher the BSSRDF_SCALE, the brighter the scattered light\nconst float BSSRDF_SCALE = 3.0;\n// Boost the shadowed areas in the subsurface glow with this\nconst float AMBIENT = 0.0;\n\n#define IDBackWall 1\n#define IDLeftWall 2\n#define IDRightWall 3\n#define IDCeilingWall 4\n#define IDFloorWall 5\n#define IDLongCube 6\n#define IDShortCube 7\n#define IDSphere 8\n\nstruct Intersection\n{\n    float t;\n    vec3 color;\n    vec3 p;\n    int object;\n};\n\nvec3 rotateY(vec3 p, float a) {\n    return vec3(cos(a) * p.x + sin(a) * p.z, p.y, -sin(a) * p.x + cos(a) * p.z);\n}\n\nfloat plane( vec3 p, vec4 n )\n{\n  // n must be normalized\n  return dot(p,n.xyz) + n.w;\n}\n\n// Box with side lengths b\nfloat box(vec3 p, vec3 b)\n{\n  return length(max(abs(p) - b, 0.0));\n}\n\nfloat sphere(vec3 p, float r, vec3 c)\n{\n    return distance(p, c) - r;\n}\n\nvoid sceneMap3D(vec3 pos, out float t, out int obj)\n{\n    // Initialize to back wall sdf\n    t = plane(pos, vec4(0.0, 0.0, -1.0, 5.0));\n    obj = IDBackWall;\n\n    float t2;\n    // Check left wall\n    if((t2 = plane(pos, vec4(1.0, 0.0, 0.0, 5.0))) < t)\n    {\n        t = t2;\n        obj = IDLeftWall;\n    }\n    // Check right wall\n    if((t2 = plane(pos, vec4(-1.0, 0.0, 0.0, 5.0))) < t)\n    {\n        t = t2;\n        obj = IDRightWall;\n    }\n    // Check top ceiling wall\n    if((t2 = plane(pos, vec4(0.0, -1.0, 0.0, 7.5))) < t)\n    {\n        t = t2;\n        obj = IDCeilingWall;\n    }\n    // Check floor wall\n    if((t2 = plane(pos, vec4(0.0, 1.0, 0.0, 2.5))) < t)\n    {\n        t = t2;\n        obj = IDFloorWall;\n    }\n    // Check for long cube\n    if((t2 = box(rotateY(pos + vec3(-2, 1, 1), -27.5 * 3.14159 / 180.0), vec3(1.5, 4, 1.5))) < t)\n    {\n        t = t2;\n        obj = IDLongCube;\n    }\n    // Check of short cube\n    if((t2 = box(rotateY(pos + vec3(2, 1, 1.75), 17.5 * 3.14159 / 180.0), vec3(1.5, 1.5, 1.5))) < t)\n    {\n        t = t2;\n        obj = IDShortCube;\n    }\n    // Check for sphere light source\n    if ((t2 = sphere(pos, 1., vec3(3.0 * cos(iTime), 1.0 + 2.0 * sin(iTime), 1))) < t) {\n        t = t2;\n        obj = IDSphere;\n    }\n}\n\nfloat sceneMap3D(vec3 pos)\n{\n    // find the smallest t value for marching\n    float t = plane(pos, vec4(0.0, 0.0, -1.0, 5.0));\n\n    t = min(t, plane(pos, vec4(1.0, 0.0, 0.0, 5.0)));\n    t = min(t, plane(pos, vec4(-1.0, 0.0, 0.0, 5.0)));\n    t = min(t, plane(pos, vec4(0.0, -1.0, 0.0, 7.5)));\n    t = min(t, plane(pos, vec4(0.0, 1.0, 0.0, 2.5)));\n    t = min(t, box(rotateY(pos + vec3(-2, 1, 1), -27.5 * 3.14159 / 180.0), vec3(1.5, 4, 1.5)));\n    t = min(t, box(rotateY(pos + vec3(2, 1, 1.75), 17.5 * 3.14159 / 180.0), vec3(1.5, 1.5, 1.5)));\n\n    return t;\n}\n\nfloat fiveTapAO(vec3 p, vec3 n, float k) {\n    float aoSum = 0.0;\n    for(float i = 0.0; i < 5.0; ++i) {\n        float coeff = 1.0 / pow(2.0, i);\n        aoSum += coeff * (i * AO_DIST - sceneMap3D(p + n * i * AO_DIST));\n    }\n    return 1.0 - k * aoSum;\n}\n\nvec3 computeNormal(vec3 pos)\n{\n    vec3 epsilon = vec3(0.0, 0.001, 0.0);\n    return normalize( vec3( sceneMap3D(pos + epsilon.yxx) - sceneMap3D(pos - epsilon.yxx),\n                            sceneMap3D(pos + epsilon.xyx) - sceneMap3D(pos - epsilon.xyx),\n                            sceneMap3D(pos + epsilon.xxy) - sceneMap3D(pos - epsilon.xxy)));\n}\n\nvoid march(vec3 origin, vec3 dir, out float t, out int hitObj)\n{\n    t = 0.001;\n    for(int i = 0; i < RAY_STEPS; ++i)\n    {\n        vec3 pos = origin + t * dir;\n        float m;\n        sceneMap3D(pos, m, hitObj);\n        if(m < 0.01)\n        {\n            return;\n        }\n        t += m;\n    }\n    // If there is no object in 256 steps\n    t = -1.0;\n    hitObj = -1;\n}\n\n// Follow the code in Visual Effects PPT\nfloat subsurfaceTerm(vec3 lightDir, vec3 normal, vec3 viewVec, float thin) {\n    vec3 scatterDir = lightDir + normal * DISTORTION;\n    float lightReachingEye = pow(clamp(dot(viewVec, -scatterDir), 0.0, 1.0), GLOW) * BSSRDF_SCALE;\n    float attenuation = max(0.0, dot(normal, lightDir) + dot(viewVec, -lightDir));\n    float totalLight = attenuation * (lightReachingEye + AMBIENT) * thin;\n    return totalLight;\n}\n\n\nvec3 computeMaterial(int hitObj, vec3 p, vec3 n, vec3 lightVec, vec3 view, float thin)\n{\n    // Use the simple lamber shading for this scene\n    float lambert = abs(dot(-lightVec, n));\n    float bssrdf = subsurfaceTerm(-lightVec, n, view, thin);\n    vec3 lightCol = vec3(1.0, 0.88, 0.7);\n    switch(hitObj){\n        case IDLongCube:\n        return (bssrdf + lambert) * lightCol * vec3(0.5, 1., 0.);\n        break;\n        case IDShortCube:\n        return (bssrdf + lambert) * lightCol * vec3(0., 0.5, 1.);\n        break;\n        case IDBackWall:\n        return lightCol * vec3(1., 1., 1.) * lambert;\n        break;\n        case IDLeftWall:\n        // red left wall\n        return lightCol * vec3(0.25, 1., 0.5) * lambert;\n        break;\n        case IDRightWall:\n        // Green right wall\n        return lightCol * vec3(1., 0.5, 0.25) * lambert;\n        break;\n        case IDCeilingWall:\n        // Black ceiling\n        return lightCol * vec3(1., 1., 1.) * lambert;\n        break;\n        case IDFloorWall:\n        return lightCol * vec3(1., 1., 1.) * lambert;\n        break;\n        case IDSphere:\n        return vec3(1.0, 0.88, 0.7);\n        case -1:\n        return vec3(0., 0., 0.);\n        break;\n    }\n    return vec3(0., 0., 0.);\n}\n\nIntersection sdf3D(vec3 dir, vec3 eye)\n{\n    float t;\n    int hitObj;\n    march(eye, dir, t, hitObj);\n\n    vec3 isect = eye + t * dir;\n    vec3 nor = computeNormal(isect);\n    // Set the light as a point light\n    vec3 lightPos = vec3(3.0 * cos(iTime), 1.0 + 2.0 * sin(iTime), 1);\n\n    vec3 lightDir = normalize(isect - lightPos);\n    float thin = fiveTapAO(isect, -nor, FIVETAP_K);\n\n    vec3 surfaceColor = computeMaterial(hitObj, isect, nor, lightDir, normalize(eye - isect), thin);\n\n\n    return Intersection(t, surfaceColor, isect, hitObj);\n}\n\n\nvec3 rayCast(vec3 eye, vec3 ref, vec2 ndc)\n{\n    vec3 F = ref - eye;\n    vec3 R = normalize(cross(F, vec3(0.0, 1.0, 0.0)));\n    vec3 U = normalize(cross(R, F));\n\n    vec3 V = U * length(F) * tan(FOVY * 0.5);\n    vec3 H = R * length(F) * tan(FOVY * 0.5) * float(iResolution.x) / iResolution.y;\n\n    vec3 p = ref + ndc.x * H + ndc.y * V;\n\n    return normalize(p - eye);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // [-1, 1]\n    uv = uv * 2.0 - vec2(1.0, 1.0);\n\n    vec3 eye = vec3(0, 3, -20);\n\n    vec3 ref = vec3(0, 0, 100);\n\n    vec3 rayDir = rayCast(eye, ref, uv);\n\n    Intersection isect = sdf3D(rayDir, eye);\n\n    // Output to screen\n    fragColor = vec4(isect.color, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/7dS3Dm.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "7dS3z3", "name": "Space warp", "author": "forij", "description": "Simple space warp shader", "tags": ["space", "warp"], "likes": 5, "viewed": 245, "date": "1617724648", "time_retrieved": "2024-06-20T20:36:13.650607", "image_code": "float speed = 10.0;\nfloat frequency = 10.0;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    float t = iTime * speed;\n    vec2 position = (fragCoord.xy - iResolution.xy * .5) / iResolution.x;\n   \n    float angle = atan(position.y, position.x) / (2. * 3.14159265359);\n    angle -= floor(angle);\n    float rad = length(position);\n    float angleFract = fract(angle * 256.);\n    float angleRnd = floor(angle * 100.) + 1.;\n    float angleRnd1 = fract(angleRnd * fract(angleRnd * .7235) * 45.1);\n    float angleRnd2 = fract(angleRnd * fract(angleRnd * .82657) * 13.724);\n    float t2 = t + angleRnd1 * frequency;\n    float radDist = sqrt(angleRnd2);\n    float adist = radDist / rad * .1;\n     float dist = (t2 * .1 + adist);\n    dist = abs(fract(dist) - 0.5);\n    \n    float outputColor = (1.0 / (dist)) * cos(0.7 ) * adist / radDist / 30.0;\n    angle = fract(angle + .61);\n    \n    vec2 uv = fragCoord/iResolution.xy;\n    vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n\n    fragColor = vec4(outputColor * col,1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/7dS3z3.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "7dsGRS", "name": "Proj2", "author": "waifutaker", "description": "aaaaa", "tags": ["aaaa"], "likes": 0, "viewed": 40, "date": "1617458253", "time_retrieved": "2024-06-20T20:36:18.450989", "image_code": "#define MAX_STEPS 1000\n#define MAX_DIST 6000.\n#define SURF_DIST .0001\n//Второй обЬект повороты цвета мягкие тени;\n\n\n/*void sphereFold(inout vec3 z, inout float dz) {\n\tfloat r2 = dot(z,z);\n\tif (r<minRadius2) { \n\t\t// linear inner scaling\n\t\tfloat temp = (fixedRadius2/minRadius2);\n\t\tz *= temp;\n\t\tdz*= temp;\n\t} else if (r2<fixedRadius2) { \n\t\t// this is the actual sphere inversion\n\t\tfloat temp =(fixedRadius2/r2);\n\t\tz *= temp;\n\t\tdz*= temp;\n\t}\n}\n*/\n\n\n\nvoid boxFold(inout vec3 z, inout float dz) {\n\tz = clamp(z, -3., 3.) * 2.0 - z;\n}\n\n\nmat2 Rot(float a){\n    float s = sin(a);\n    float c = cos(a);\n    return mat2(c,-s,s,c);\n}\n    \n\nvoid ry(inout vec3 p, float a){  \n \tfloat c,s;vec3 q=p;  \n  \tc = cos(a); s = sin(a);  \n  \tp.y = c * q.y- s * q.z;  \n  \tp.z = s * q.y + c * q.z; \n }  \n \n void ry2(inout vec3 p, float a){  \n \tfloat c,s;vec3 q=p;  \n  \tc = cos(a); s = sin(a);  \n  \tp.x = c * q.x- s * q.z;  \n  \tp.z = s * q.x + c * q.z; \n }  \n \nfloat DE3(vec3 z)\n{\n\tvec3 offset = z;\n\tfloat dr = 1.0;\n\tfor (int n = 0; n <35; n++) {\n\t\tboxFold(z,dr);       // Reflect\n\t\t//sphereFold(z,dr);    // Sphere Inversion\n \t\tfloat Scale =2.;\n                z=Scale*z + offset;  // Scale & Translate\n                dr = dr*abs(Scale)+1.0;\n\t}\n\tfloat r = length(z);\n\treturn r/abs(dr);\n}\n\n\nfloat TetraFOUR(vec3 p) {//Tetraброт\n\t//vec3 z = p;\n    p = vec3(1.*p.x,1.*p.y,1.*p.z);\n    vec4 p_vec4 = vec4(1.*p.x,p.y,p.z,0.0);\n    vec4 z = vec4(p_vec4.x,p_vec4.y,p_vec4.z,p_vec4.w);\n    \n    float t = iTime/3.0;\n\tvec4 c = 0.5*vec4(sin(t),sin(t),sin(t),sin(t));\n    \n\tfloat dr = 1.0;\n\tfloat r = 0.0;\n\tfor (float i = 0.; i < 14. ; i++) {\n\t\tr = length(z);\n        \n\t\tif (r>2.) break;\n       \n        float Power = 2.;\n\t\tdr =  pow( r, Power-1.0)*Power*dr + 1.0;//pow( r, Power-1.0)*Power*dr + 1.0;\n\t\t// scale and rotate the point\n\t\tfloat zr = pow( r,Power);\n\t\t\n\t\t// convert back to cartesian coordinates\n\t\tz = vec4(z.x*z.x-z.y*z.y-z.z*z.z+z.w*z.w, 2.*(z.x*z.y-z.z*z.w),2.*(z.x*z.z-z.y*z.w),2.*(z.x*z.w+z.y*z.z));\n\t\tz+=p_vec4;\n\t}\n\treturn 0.5*log(r)*r/dr;\n}\n\n\n/*\nfloat TetraFOUR(vec3 p) {//Tetraброт\n\n    p = vec3(1.*p.x,1.*p.y,1.*p.z);\n    vec4 p_vec4 = vec4(1.*p.x,p.y,p.z,0.0);\n    vec4 z = vec4(p_vec4.x,p_vec4.y,p_vec4.z,p_vec4.w);\n    \n    float t = iTime/3.0;\n\tvec4 c = 0.5*vec4(sin(t),sin(t),sin(t),sin(t));\n    vec4 nz;\n    \n\tfloat mz2 = dot(z,z);\n    float md2 = 1.0;\n\tfloat dr = 1.0;\n\tfloat r = 0.0;\n\tfor (float i = 0.; i < 14. ; i++) {\n\t\tr = length(z);\n        \n\t\tif (r>2.) break;\n        md2*=4.0*mz2;\n        \n        float Power = 2.;\n\t\tdr =  pow( r, Power-1.0)*Power*dr + 1.0;\n\t\t// scale and rotate the point\n\t\tfloat zr = pow( r,Power);\n\t\t\n\t\t// convert back to cartesian coordinates\n\t\tz = c+vec4(z.x*z.x-z.y*z.y-z.z*z.z+z.w*z.w, 2.*(z.x*z.y-z.z*z.w),2.*(z.x*z.z-z.y*z.w),2.*(z.x*z.w+z.y*z.z));\n\t\tz+=p_vec4;\n\t}\n\treturn 0.5*log(r)*r/dr;\n}\n*/\n/*\nfloat julia(vec3 pos)\n{\n    float t = iTime/3.0;\n    \n\tvec4 c = 0.5*vec4(cos(t),cos(t*1.1),cos(t*2.3),cos(t*3.1));\n    vec4 z = vec4( pos, 0.0 );\n\tvec4 nz;\n    \n\tfloat md2 = 1.0;\n\tfloat mz2 = dot(z,z);\n\n\tfor(int i=0;i<13;i++)\n\t{\n\t\tmd2*=4.0*mz2;\n\t    nz.x=z.x*z.x-dot(z.yzw,z.yzw);\n\t\tnz.yzw=2.0*z.x*z.yzw;\n\t\tz=nz+c;\n\n\t\tmz2 = dot(z,z);\n\t\tif(mz2>4.0)\n        {\n\t\t\tbreak;\n        }\n\t}\n\n\treturn 0.25*sqrt(mz2/md2)*log(mz2);\n}\n*/\nfloat MandelFOUR(vec3 p) {//Мандельброт 4d\n\t\n    p = vec3(1.*p.x,1.*p.y,1.*p.z);\n    vec4 p_vec4 = vec4(p.x,p.y,p.z,0.);\n    vec4 z = vec4(p,0);\n\tfloat dr = 1.0;\n\tfloat r = 0.0;\n    float r2 = 0.0;\n    float r3 = 0.0;\n\tfor (float i = 0.; i < 10. ; i++) {\n\t\tr = length(z);\n        r2 = sqrt(z.x*z.x+z.y*z.y);\n        r3 = sqrt(z.x*z.x+z.y*z.y+z.z*z.z);\n\t\tif (r>2.) break;\n\t\t\n       \n\t\t// convert to polar coordinates\n\t\tfloat phi = atan(z.z,r2);\n        float psi = atan(z.w,r3);\n\t\tfloat theta = atan(z.y,z.x);//float phi = atan(z.y,z.x);\n        float Power = 2.;\n\t\tdr =  pow( r, Power-1.0)*Power*dr + 1.0;\n\t\t\n\t\t// scale and rotate the point\n\t\tfloat zr = pow( r,Power);\n\t\t\n\t\t\n\t\t// convert back to cartesian coordinates\n\t\tz = zr*vec4(cos(2.*psi)*cos(2.*theta), cos(2.*psi)*cos(2.*phi), -cos(2.*psi)*sin(2.*phi),sin(2.*psi));\n\t\tz+=vec4(p,0);\n\t}\n\treturn 0.5*log(r)*r/dr;\n}\n\nfloat Quadra(vec3 p) {//quadratics\n\t//vec3 z = p;\n    vec4 p_vec4 = vec4(p.x,p.y,p.z,0);\n    vec4 z =vec4(1.*p.x,p.y,p.z,0);\n\tfloat dr = 1.;\n\tfloat r = 0.0;\n\tfor (int i = 0; i < 50 ; i++) {\n\t\tr = length(z);\n\t\tif (r>400.) break;\n\t\t\n\t\t// convert to polar coordinates\n\t\tfloat theta = 2.*acos(z.z/r);\n\t\tfloat phi = 2.*atan(2.*z.y,2.*z.x);//float phi = atan(z.y,z.x);\n        float Power = 2.;\n\t\tdr =  pow( r, Power-1.0)*Power*dr + 1.0;\n\t\t\n\t\t// scale and rotate the point\n\t\tfloat zr = pow( r,Power);\n\t\t\n\t\t\n\t\t// convert back to cartesian coordinates\n\t\tz = zr*vec4(cos(theta)*cos(phi), sin(phi)*cos(theta), -sin(theta),0);\n\t\tz+=p_vec4;\n\t}\n\treturn 0.5*log(r)*r/dr;\n}\n\n\nfloat Mandel(vec3 p) {//Мандельброт\n\t\n    vec4 p_vec4 = vec4(p.x,p.y,p.z,0);\n    vec4 z =vec4(p.x,p.y,p.z,0);\n\tfloat dr = 1.0;\n\tfloat r = 0.0;\n\tfor (int i = 0; i < 100 ; i++) {\n\t\tr = length(z);\n\t\tif (r>40.) break;\n        \n       \t\tfloat t = iTime/30.0;\n        \n        \n\t\t// convert to polar coordinates\n\t\tfloat theta = acos(z.z/r);\n\t\tfloat phi = atan(2.*z.y,2.*z.x);//float phi = atan(z.y,z.x);\n        float Power = abs(cos(t))*10.+1.5;\n\t\tdr =  pow( r, Power-1.0)*Power*dr + 1.0;\n\t\t\n\t\t// scale and rotate the point\n\t\tfloat zr = pow( r,Power);\n\t\ttheta = theta*Power;\n\t\tphi = phi*Power;\n\t\t\n\t\t// convert back to cartesian coordinates\n\t\tz = zr*vec4(cos(theta)*cos(phi), sin(phi)*cos(theta), sin(theta),0);\n\t\tz+=p_vec4;\n\t}\n\treturn 0.5*log(r)*r/dr;\n}\n\nfloat Mandelbub(vec3 p) {//Мандельбуб \n\t//vec3 z = p;\n    vec4 p_vec4 = vec4(p.x,p.y,p.z,0);\n    vec4 z =vec4(p.x,p.y,p.z,0);\n\tfloat dr = 1.0;\n\tfloat r = 0.0;\n\tfor (int i = 0; i < 100 ; i++) {\n\t\tr = length(z);\n\t\tif (r>3.) break;\n\t\t\n\t\t// convert to polar coordinates\n\t\tfloat theta = acos(z.z/r);\n\t\tfloat phi = atan(z.x,z.y);//float phi = atan(z.y,z.x);\n        float Power =4.;//*(abs(sin(iTime)))+2.;\n\t\tdr =  pow( r, Power-1.0)*Power*dr + 1.0;\n\t\t\n\t\t// scale and rotate the point\n\t\tfloat zr = pow( r,Power);\n\t\ttheta = theta*Power;\n\t\tphi = phi*Power;\n\t\t\n\t\t// convert back to cartesian coordinates\n\t\tz = zr*vec4(sin(theta)*cos(phi), sin(phi)*sin(theta), cos(theta),0);\n\t\tz+=p_vec4;\n\t}\n\treturn 0.5*log(r)*r/dr;\n}\n\n\nvec3 RotateX(vec3 v, float rad)\n{\n  float cos = cos(rad);\n  float sin = sin(rad);\n  //if (RIGHT_HANDED_COORD)\n  return vec3(v.x, cos * v.y + sin * v.z, -sin * v.y + cos * v.z);\n  //else return new float3(x, cos * y - sin * z, sin * y + cos * z);\n}\nvec3 RotateY(vec3 v, float rad)\n{\n  float cos = cos(rad);\n  float sin = sin(rad);\n  //if (RIGHT_HANDED_COORD)\n  return vec3(cos * v.x - sin * v.z, v.y, sin * v.x + cos * v.z);\n  //else return new float3(cos * x + sin * z, y, -sin * x + cos * z);\n}\nvec3 RotateZ(vec3 v, float rad)\n{\n  float cos = cos(rad);\n  float sin = sin(rad);\n  //if (RIGHT_HANDED_COORD)\n  return vec3(cos * v.x + sin * v.y, -sin * v.x + cos * v.y, v.z);\n}\n\nfloat SinRep(float a)\n{\n    float h = 0.0;\n    float mult = 1.0;\n    for (int i = 0; i <20; i++)\n    {\n        h += (cos(a*mult)/(mult));\n        mult *= 2.0;\n    }\n    return h;\n}\n\nfloat DistanceToObject(vec3 p)\n{\n    float material = 0.0;\n    float h = 0.0;\n    p = RotateY(p, p.y*0.4 - cos(iTime)*0.4);\n    h += SinRep(RotateY(p, p.z*3.14*0.25).x);\n    h += SinRep(RotateZ(p, p.x*3.14*0.25).y);\n    h += SinRep(RotateX(p, p.y*3.14*0.25).z);\n    material = h;\n    //h += SinRep(RotateX(p, p.y).z);\n    //h += SinRep(RotateZ(p, sin(h)).y);\n    //h += SinRep(RotateY(p, h*1.0).x);\n    //h += SinRep(p.x+h)*0.5;\n    //h += SinRep(p.y+h)*0.5;\n    float final = (length(p)-4.0 - h*(0.25 + sin(iTime)*0.35));\n    return final;\n}\n\nfloat julia(vec3 pos)\n{\n    float t = iTime/3.0;\n    \n\tvec4 c = 0.5*vec4(cos(t),cos(t*1.1),cos(t*2.3),cos(t*3.1));\n    vec4 z = vec4( pos, 0.0 );\n\tvec4 nz;\n    \n\tfloat md2 = 1.0;\n\tfloat mz2 = dot(z,z);\n\n\tfor(int i=0;i<13;i++)\n\t{\n\t\tmd2*=4.0*mz2;\n\t    nz.x=z.x*z.x-dot(z.yzw,z.yzw);\n\t\tnz.yzw=2.0*z.x*z.yzw;\n\t\tz=nz+c;\n\n\t\tmz2 = dot(z,z);\n\t\tif(mz2>4.0)\n        {\n\t\t\tbreak;\n        }\n\t}\n\n\treturn 0.25*sqrt(mz2/md2)*log(mz2);\n}\n\nfloat DE(vec3 z)// Треугольник серпинского \n{\n vec3 n1 = vec3(-z.y,z.x,z.z);\n \n //float t = dot(z,n1); if (t<0.0) { z-=2.0*t*n1; }\n \n float r;\n \n \n int n = 0;\n float Scale=2.0;\n float Offset =8.;\n while (n < 15) {\n if(z.x+z.y<0.) z.xy = -z.yx; // fold 1  -z.yx*.8*cos(iTime)\n if(z.x+z.z<0.) z.xz = -z.zx; // fold 2\n if(z.y+z.z<0.) z.zy = -z.yz; // fold 3 \n float t = dot(z,n1); \n //if (t<0.0){ \n //z-=2.0*t*n1; \n \n z = z*Scale - Offset*(Scale-1.0);\n \n n++;\n }\n \n return (length(z) ) * pow(Scale, -float(n));\n}\n\n\n\n\n\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\n\n\n\nfloat sphereDist( vec3 p )\n    {\n  vec4 s = vec4(0., 0.1, 0.1, 1);\n  \n  return length(p-s.xyz)-s.w;\n}\n\n\n float f(vec3 p){\n \n \nvec2 mouse=iMouse.xy/iResolution.xy;\nfloat angle = mouse.x*3.1415*2.*10.;\nfloat angle2 = mouse.y*3.1415*2.*10.;\nfloat ang2 =+angle2;\n\n\nfloat ang =+angle;\n\n\t ry(p, 0.2);// ry2(p,ang*0.2);\n     ry2(p,0.2);// ry2(p,ang2*0.2);\n     return  DistanceToObject(1.*p);//TetraFOUR(p);  Quadra\n } \n\n\nfloat opTwist( in vec3 p )//Спираль \n{\n    float k = 0.*sin(iTime); // or some other amount\n    float c = sin(k*p.y);\n    float s = cos(k*p.y);\n    mat2  m = mat2(c,-s,s,c);\n    vec3  q = vec3(m*p.xz,p.y);//vec3(m*p.xz,p.x);\n    return f(q);\n}\n\nfloat opRep( in vec3 p, in vec3 c )// зеркало \n{\n    vec2 t = vec2(1);//vec2\n    vec3 q = mod(p+0.5*c,c)-0.5*c;\n    return  f(q); //зеркало premitive change \n}\n\n\nfloat opDisplace( in vec3 p )//sin \n{\n    \n    float d2 = (sin(5.*sin(iTime)*p.x)*sin(1.*sin(iTime)*p.y)*sin(sin(iTime)*p.z));\n    return f(p)+d2;\n}\n\n\nfloat GetDist(vec3 p) {\n\tvec3 b = vec3(10);\n    float s = 1.;\n    \n    float planeDist =p.y+5.;//high\n    \n    float dg= opTwist(.4*p);//opDisplace opTwist opRep(p,b) and size \n    \n    float d = min(dg,planeDist);\n\n    return d;\n}\n\nfloat RayMarch(vec3 ro, vec3 rd) {\n\tfloat dO=0.;\n    \n    for(int i=0; i<MAX_STEPS; i++) {\n    \tvec3 p = ro + rd*dO;\n        float dS = GetDist(p);\n        dO += dS;\n        if(dO>MAX_DIST || dS<SURF_DIST) break;\n    }\n    \n    return dO;\n}\n\nvec3 GetNormal(vec3 p) {\n\tfloat d = GetDist(p);\n    vec2 e = vec2(.001, 0);\n    vec3 n = d - vec3(\n        GetDist(p-e.xyy),\n        GetDist(p-e.yxy),\n        GetDist(p-e.yyx));\n    \n    return normalize(n);\n}\n\nfloat GetLight(vec3 p) {\n    vec3 lightPos = vec3(abs(cos(iTime))*1., abs(sin(iTime))*1.,abs(cos(iTime))*1.);\n    lightPos.xyz += vec3(-1.,5., -7.5)*6.;\n    vec3 l = normalize(lightPos-p);\n    vec3 n = GetNormal(p);\n    \n    float dif = clamp(dot(n, l), 0., 1.);\n    float d = RayMarch(p+n*SURF_DIST*2., l);\n    if(d<length(lightPos-p)) dif *= .009;\n    \n    return dif;\n}\n\n\nfloat specular(vec3 n,vec3 l,vec3 e,float s) {    \n    float nrm = (s + 9.0) / (3.1415 * 8.0);\n    return pow(max(dot(reflect(e,n),l),0.0),s) * nrm;\n}\n\n\n\nconst vec3 RED = vec3(3.,0.001103,0.08);\nconst vec3 ORANGE = vec3(0.032,0.01,0.09);\nconst vec3 GREEN = vec3(.0,3.0,3.00);\nconst vec3 BLUE = vec3(0.0,0.0,7.00);\n\nvec3 hsv2rgb(vec3 c){\n    vec4 K = vec4(0.7, 42.0 /3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx+ K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n///////////\nvec3 GetSky(in vec3 rd, in vec3 sunDir, in vec3 sunCol)\n{\n\tfloat sunAmount = max( dot( rd, sunDir), 0.0 );\n\tfloat v = pow(1.0-max(rd.y,0.0),6.);\n\tvec3  sky = mix(vec3(.1, .2, .3), vec3(.32, .32, .32), v);\n\tsky = sky + sunCol * sunAmount * sunAmount * .25;\n\tsky = sky + sunCol * min(pow(sunAmount, 800.0)*1.5, .3);\n\treturn clamp(sky, 0.0, 1.0);\n}\n///////////\n\n\n\nvec3 GetRay(vec2 uv, vec3 p, vec3 l , float zoom){\n   vec3 f = normalize(p-l),\n        r = normalize(cross(vec3 (0,1,0),f)),\n        u = cross(f,r),\n        c = p+f*zoom,\n        i = c + uv.x*r+uv.y*u,\n        d = normalize(i-p);\n        return d;\n        }\n\n\n\n#define MOVE_FORWARD_KEY1\t\tKEY_W\n#define MOVE_FORWARD_KEY2\t\tKEY_UP\n#define MOVE_FORWARD_KEY3\t\tKEY_Z\t\t\t// azerty\n#define MOVE_LEFT_KEY1\t\t\tKEY_A\n#define MOVE_LEFT_KEY2\t\t\tKEY_Q\t\t\t// azerty\n#define MOVE_BACKWARD_KEY1\t\tKEY_S\n#define MOVE_BACKWARD_KEY2\t\tKEY_DOWN\n#define MOVE_RIGHT_KEY1\t\t\tKEY_D\n#define MOVE_RIGHT_KEY2\t\t\tunassigned\n#define MOVE_UP_KEY1\t\t\tKEY_SPACE\n#define MOVE_UP_KEY2\t\t\tunassigned\n#define MOVE_DOWN_KEY1\t\t\tKEY_C\n#define MOVE_DOWN_KEY2\t\t\tunassigned\n#define RUN_KEY1\t\t\t\tKEY_SHIFT\n#define RUN_KEY2\t\t\t\tunassigned\n#define LOOK_LEFT_KEY1\t\t\tKEY_LEFT\n#define LOOK_LEFT_KEY2\t\t\tunassigned\n#define LOOK_RIGHT_KEY1\t\t\tKEY_RIGHT\n#define LOOK_RIGHT_KEY2\t\t\tunassigned\n#define LOOK_UP_KEY1\t\t\tKEY_PGDN\n#define LOOK_UP_KEY2\t\t\tunassigned\n#define LOOK_DOWN_KEY1\t\t\tKEY_DELETE\n#define LOOK_DOWN_KEY2\t\t\tunassigned\n#define CENTER_VIEW_KEY1\t\tKEY_END\n#define CENTER_VIEW_KEY2\t\tunassigned\n#define STRAFE_KEY1\t\t\t\tKEY_ALT\n#define STRAFE_KEY2\t\t\t\tunassigned\n#define RESPAWN_KEY1\t\t\tKEY_BKSP\n#define RESPAWN_KEY2\t\t\tKEY_HOME\n#define ATTACK_KEY1\t\t\t\tKEY_E\n#define ATTACK_KEY2\t\t\t\tKEY_F\n\n#define MENU_KEY1\t\t\t\tKEY_ESC\n#define MENU_KEY2\t\t\t\tKEY_TAB\n\n#define SHOW_PERF_STATS_KEY\t\tKEY_P\n#define TOGGLE_TEX_FILTER_KEY\tKEY_T\n#define TOGGLE_LIGHT_SHAFTS_KEY\tKEY_L\n#define TOGGLE_CRT_EFFECT_KEY\tKEY_V\n\nconst float\n\tSENSITIVITY\t\t\t\t\t= 1.0,\n\tMOUSE_FILTER\t\t\t\t= 0.0,\t\t// mostly for video recording\n\tTURN_SPEED\t\t\t\t\t= 180.0,\t// keyboard turning rate, in degrees per second\n\tWALK_SPEED\t\t\t\t\t= 400.0,\n\tJUMP_SPEED\t\t\t\t\t= 270.0,\n    STAIR_CLIMB_SPEED\t\t\t= 128.0,\n    STOP_SPEED\t\t\t\t\t= 100.0,\n    \n    GROUND_ACCELERATION\t\t\t= 10.0,\n    AIR_ACCELERATION\t\t\t= 1.0,\n\n    GROUND_FRICTION\t\t\t\t= 4.0,\n\tNOCLIP_START_FRICTION\t\t= 18.0,\n\tNOCLIP_STOP_FRICTION\t\t= 12.0,\n\n    ROLL_ANGLE\t\t\t\t\t= 2.0,\t\t// maximum roll angle when moving sideways\n\tROLL_SPEED\t\t\t\t\t= 200.0,\t// sideways speed at which the roll angle reaches its maximum\n\tBOB_CYCLE\t\t\t\t\t= 0.6,\t\t// seconds\n\tBOB_SCALE\t\t\t\t\t= 0.02,\n\n    AUTOPITCH_DELAY\t\t\t\t= 2.0,\t\t// seconds between last mouse look and automatic pitch adjustment\n    STAIRS_PITCH\t\t\t\t= 10.0,\n\n    RECOIL_ANGLE\t\t\t\t= 2.0,\n    WEAPON_SPREAD\t\t\t\t= 0.05,\t\t// slightly higher than in Quake, for dramatic effect\n    RATE_OF_FIRE\t\t\t\t= 2.0;\n\n////////////////////////////////////////////////////////////////\n// Implementation //////////////////////////////////////////////\n////////////////////////////////////////////////////////////////\n\n//#define GENERATE_TEXTURES\t\t(1<<MATERIAL_WIZMET1_1) | (1<<MATERIAL_WBRICK1_5)\n#define GENERATE_TEXTURES\t\t-1\n#define ALWAYS_REFRESH\t\t\t0\n#define WRITE_MAP_DATA\t\t\t1\n#define ENABLE_MENU\t\t\t\t1\n\n////////////////////////////////////////////////////////////////\n\nconst int\n\tKEY_A = 65, KEY_B = 66, KEY_C = 67, KEY_D = 68, KEY_E = 69, KEY_F = 70, KEY_G = 71, KEY_H = 72, KEY_I = 73, KEY_J = 74,\n\tKEY_K = 75, KEY_L = 76, KEY_M = 77, KEY_N = 78, KEY_O = 79, KEY_P = 80, KEY_Q = 81, KEY_R = 82, KEY_S = 83, KEY_T = 84,\n\tKEY_U = 85, KEY_V = 86, KEY_W = 87, KEY_X = 88, KEY_Y = 89, KEY_Z = 90,\n\n    KEY_0 = 48, KEY_1 = 49, KEY_2 = 50, KEY_3 = 51, KEY_4 = 52, KEY_5 = 53, KEY_6 = 54, KEY_7 = 55, KEY_8 = 56, KEY_9 = 57,\n\n\tKEY_PLUS\t\t= 187,\n\tKEY_MINUS\t\t= 189,\n\tKEY_EQUAL\t\t= KEY_PLUS,\n\n    // firefox...\n    KEY_PLUS_FF\t\t= 61,\n    KEY_MINUS_FF\t= 173, \n\n    KEY_SHIFT\t\t= 16,\n\tKEY_CTRL\t\t= 17,\n\tKEY_ALT\t\t\t= 18,\n    \n    KEY_ESC\t\t\t= 27,\n\t\n    KEY_BKSP \t\t=  8,\n    KEY_TAB\t\t\t=  9,\n\tKEY_END\t\t\t= 35,\n\tKEY_HOME\t\t= 36,\n\tKEY_INS\t\t\t= 45,\n\tKEY_DEL\t\t\t= 46,\n\tKEY_INSERT\t\t= KEY_INS,\n\tKEY_DELETE\t\t= KEY_DEL,\n\n\tKEY_ENTER\t\t= 13,\n\tKEY_SPACE \t\t= 32,\n\tKEY_PAGE_UP \t= 33,\n\tKEY_PAGE_DOWN \t= 34,\n\tKEY_PGUP \t\t= KEY_PAGE_UP,\n\tKEY_PGDN \t\t= KEY_PAGE_DOWN,\n\n\tKEY_LEFT\t\t= 37,\n\tKEY_UP\t\t\t= 38,\n\tKEY_RIGHT\t\t= 39,\n\tKEY_DOWN\t\t= 40,\n\t\n\tunassigned\t\t= 0;\n\n////////////////////////////////////////////////////////////////\n\nfloat is_key_down(int code)\t\t\t\t{ return code != 0 ? texelFetch(iChannel0, ivec2(code, 0), 0).r : 0.; }\nfloat is_key_pressed(int code)\t\t\t{ return code != 0 ? texelFetch(iChannel0, ivec2(code, 1), 0).r : 0.; }\n\n////////////////////////////////////////////////////////////////\n\nfloat cmd(int code1, int code2)\t\t\t{ return max(is_key_down(code1), is_key_down(code2)); }\nfloat cmd(int c1, int c2, int c3)\t\t{ return max(is_key_down(c1), max(is_key_down(c2), is_key_down(c3))); }\nfloat cmd_press(int code1, int code2)\t{ return max(is_key_pressed(code1), is_key_pressed(code2)); }\n\n//float cmd_move_forward()\t\t\t\t{ return cmd(MOVE_FORWARD_KEY1,\t\tMOVE_FORWARD_KEY2,\t\tMOVE_FORWARD_KEY3); }\nfloat cmd_move_backward()\t\t\t\t{ return cmd(MOVE_BACKWARD_KEY1,\tMOVE_BACKWARD_KEY2); }\nfloat cmd_move_left()\t\t\t\t\t{ return cmd(MOVE_LEFT_KEY1,\t\tMOVE_LEFT_KEY2); }\nfloat cmd_move_right()\t\t\t\t\t{ return cmd(MOVE_RIGHT_KEY1,\t\tMOVE_RIGHT_KEY2); }\nfloat cmd_move_up()\t\t\t\t\t\t{ return cmd(MOVE_UP_KEY1,\t\t\tMOVE_UP_KEY2); }\nfloat cmd_move_down()\t\t\t\t\t{ return cmd(MOVE_DOWN_KEY1,\t\tMOVE_DOWN_KEY2); }\nfloat cmd_run()\t\t\t\t\t\t\t{ return cmd(RUN_KEY1,\t\t\t\tRUN_KEY2); }\nfloat cmd_look_left()\t\t\t\t\t{ return cmd(LOOK_LEFT_KEY1,\t\tLOOK_LEFT_KEY2); }\nfloat cmd_look_right()\t\t\t\t\t{ return cmd(LOOK_RIGHT_KEY1,\t\tLOOK_RIGHT_KEY2); }\nfloat cmd_look_up()\t\t\t\t\t\t{ return cmd(LOOK_UP_KEY1,\t\t\tLOOK_UP_KEY2); }\nfloat cmd_look_down()\t\t\t\t\t{ return cmd(LOOK_DOWN_KEY1,\t\tLOOK_DOWN_KEY2); }\nfloat cmd_center_view()\t\t\t\t\t{ return cmd(CENTER_VIEW_KEY1,\t\tCENTER_VIEW_KEY2); }\nfloat cmd_strafe()\t\t\t\t\t\t{ return cmd(STRAFE_KEY1,\t\t\tSTRAFE_KEY2); }\nfloat cmd_respawn()\t\t\t\t\t\t{ return cmd_press(RESPAWN_KEY1,\tRESPAWN_KEY2); }\nfloat cmd_attack()\t\t\t\t\t\t{ return cmd(ATTACK_KEY1,\t\t\tATTACK_KEY2); }\nfloat cmd_menu()\t\t\t\t\t\t{ return cmd_press(MENU_KEY1,\t\tMENU_KEY2); }\n\n\nfloat DistLine(vec3 ro, vec3 rd, vec3 p) {\n\treturn length(cross(p-ro, rd))/length(rd);\n}\n\nfloat DrawPoint(vec3 ro, vec3 rd, vec3 p) {\n\tfloat d = DistLine(ro, rd, p);\n    d = smoothstep(.06, .05, d);\n    return d;\n}\n\n\n\n\n\n\n\nconst float WIDTH = 1920. , HEIGHT = 1080.;\n\n// Camera\nvec3 ro ;\nvec3 roSave ;\nvec3 cameraFront = vec3(0.0f, 0.0f, -1.0f);\nvec3 cameraUp    = vec3(0.0f, 1.0f,  0.0f);\nfloat yaw   = -90.0f;\t// Yaw is initialized to -90.0 degrees since a yaw of 0.0 results in a direction vector pointing to the right (due to how Eular angles work) so we initially rotate a bit to the left.\nfloat pitch =   0.0f;\nfloat lastX =  WIDTH  / 2.0;\nfloat lastY =  HEIGHT / 2.0;\nbool firstMouse ;\nbool keys[1024];\nfloat deltaTime = 0.0f;\t// Время, прошедшее между последним и текущим кадром\nfloat lastFrame = 0.0f;\n\n\nbool isKeyPressed(int KEY)\n{\n\treturn texelFetch( iChannel0, ivec2(KEY,0), 0 ).x > 0.5;\n}\n\nvoid do_movement()\n{\n\n float currentFrame = iTimeDelta;\ndeltaTime = currentFrame - lastFrame;\nlastFrame = currentFrame;\n    // Camera controls\n   \n    float cameraSpeed = 10.0f * deltaTime;\n    if (isKeyPressed(KEY_W))//key_callback(KEY_W,cmd_move_right()))\n        ro +=cameraSpeed * cameraFront*100.;\n    if (cmd_move_backward()!= 0.)\n        ro -= cameraSpeed * cameraFront;\n    if (cmd_move_right()!= 0.)\n        ro -= normalize(cross(cameraFront, cameraUp)) * cameraSpeed;\n    if (cmd_move_left()!= 0.)\n        ro += normalize(cross(cameraFront, cameraUp)) * cameraSpeed;\n}\n\n\n\n\n\nvec3 vel=vec3(0);\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    ro=vec3(1.,2.,-4.);\n     \n    //vec3(sin(iTime)*1.,cos(iTime)*0.5,-4);\n    vec3 col=vec3(1.,3.,3.);\n    \n    \n    int firstMous = 1;\n    float currentFrame = iTimeDelta;\n    deltaTime = currentFrame - lastFrame;\n    lastFrame = currentFrame;\n    // Camera controls\n    \n     float cameraSpeed = 60.0;//* deltaTime;\n   \n   \n    \n\tfloat t = iTime;\n    \n    vec2 uv = fragCoord.xy / iResolution.xy; // 0 <> 1\n    uv -= .5;\n    uv.x *= iResolution.x/iResolution.y;\n\n\n    vec2 mouse=iMouse.xy/iResolution.xy;\n\n   // vec3 ro = vec3(3., 2., -3.);\n\n\n\n   ////////// \n  \n    ////MOVMENT\n     \n   \n   \n   //ROTATION\n   /*\n    float xpos =+ mouse.x*1000.;\n    float ypos =+ mouse.y*1000.;\n   \n   if (firstMouse)\n    {\n        lastX = xpos;\n        lastY = ypos;\n        firstMous = 0;\n    }\n    \n    float xoffset = -xpos + lastX;\n    float yoffset = -lastY + ypos; // Reversed since y-coordinates go from bottom to left\n    lastX = xpos;\n    lastY = ypos;\n\n    float sensitivity = 0.5;\t// Change this value to your liking\n    xoffset *= sensitivity;\n    yoffset *= sensitivity;\n\n    yaw   += xoffset;\n    pitch += yoffset;\n\n    // Make sure that when pitch is out of bounds, screen doesn't get flipped\n    if (pitch > 89.0f)\n        pitch = 89.0f;\n    if (pitch < -89.0f)\n        pitch = -89.0f;\n   \n    vec3 front;\n    front.x = cos(radians(yaw)) * cos(radians(pitch));\n    front.y = sin(radians(pitch));\n    front.z = sin(radians(yaw)) * cos(radians(pitch));\n    cameraFront = normalize(front);\n  \n    \n    \n\n    if (isKeyPressed(KEY_W))\n        ro +=cameraSpeed * cameraFront;\n    if (isKeyPressed(KEY_S))\n        ro -= cameraSpeed * cameraFront;\n    if (isKeyPressed(KEY_D))\n        ro -= normalize(cross(cameraFront, cameraUp)) * cameraSpeed;\n    if (isKeyPressed(KEY_A))\n        ro += normalize(cross(cameraFront, cameraUp)) * cameraSpeed;\n\n*/\n\n    // ro.yz *=Rot(-mouse.y*3.1416+1.);\n    //ro.xz *=Rot(-mouse.x*3.1416*2.);\n   \n/////////\n    vec3 lookat = vec3(cameraFront);\n    \n    float zoom = 1.5;\n    \n    /*\n    \n    \n    \n     vec3 f = normalize(p-l),\n        r = normalize(cross(vec3 (0,1,0),f)),\n        u = cross(f,r),\n        c = p+f*zoom,\n        i = c + uv.x*r+uv.y*u,\n        d = normalize(i-p);\n        return d;\n        }*/\n   \n    \n  //cameraFront =  normalize(lookat-ro);\n    \n    //cameraFront += vel;\n    \n   // vel = ro;\n   \n    if (isKeyPressed(KEY_W))\n        ro +=cameraSpeed * cameraFront;\n    if (isKeyPressed(KEY_S))\n        ro -= cameraSpeed * cameraFront;\n    if (isKeyPressed(KEY_D))\n        ro -= normalize(cross(cameraFront, cameraUp)) * cameraSpeed;\n    if (isKeyPressed(KEY_A))\n        ro += normalize(cross(cameraFront, cameraUp)) * cameraSpeed;\n   \n   float xpos =+ mouse.x*1000.;\n    float ypos =+ mouse.y*1000.;\n   \n   if (firstMouse)\n    {\n        lastX = xpos;\n        lastY = ypos;\n        firstMous = 0;\n    }\n    \n    float xoffset = -xpos + lastX;\n    float yoffset = -lastY + ypos; // Reversed since y-coordinates go from bottom to left\n    lastX = xpos;\n    lastY = ypos;\n\n    float sensitivity = 0.5;\t// Change this value to your liking\n    xoffset *= sensitivity;\n    yoffset *= sensitivity;\n\n    yaw   += xoffset;\n    pitch += yoffset;\n\n    // Make sure that when pitch is out of bounds, screen doesn't get flipped\n    if (pitch > 89.0f)\n        pitch = 89.0f;\n    if (pitch < -89.0f)\n        pitch = -89.0f;\n   \n    vec3 front;\n    front.x = cos(radians(yaw)) * cos(radians(pitch));\n    front.y = sin(radians(pitch));\n    front.z = sin(radians(yaw)) * cos(radians(pitch));\n    cameraFront = normalize(front);\n    \n    vec3 r = normalize(cross(vec3(0., 1., 0.), cameraFront));\n    cameraUp = cross(cameraFront, r);\n    \n    vec3 c = ro + cameraFront*zoom;\n    vec3 i = c + uv.x*r + uv.y*cameraUp;\n    vec3 rd = normalize(i-ro);\n    \n    \n    \n   \n\n    \n   // rd.yz *=Rot(-mouse.y*3.1416+1.);\n   // rd.xz *=Rot(-mouse.x*3.1416*2.);\n  //  ro.x = ro.x+112.*sin(iTime);\n    \n\n    float d = RayMarch(ro, rd);\n/*    \n    vec3 ra = vec3(1.,0.5,-4);\n    float d2 = RayMarch(ra,rd);\n    vec3 t = ro+ra*d2;\n    float dif2 = GetLight(t);\n    vec3 color;\n    color = vec3(dif2);\n  */  \n    \n    \n   /* if(d<MAX_DIST){\n        \n        r = normalize(cross(vec3(0., 1., 0.), cameraFront));\n    cameraUp = cross(cameraFront, r);\n    c = ro + cameraFront*zoom;\n    i = c + uv.x*r + uv.y*cameraUp;\n    rd = normalize(i-ro);\n    \n    \n    \n    \n    vec3 p =(ro + rd * d);\n    vec3 n =GetNormal(p);\n     float dif = GetLight(p);\n    //float dif = dot(n,normalize(vec3(1)))*.5+5.;\n    col +=dif;\n    }*/\n     vec3 p =(ro + rd * d);\n    vec3 n =GetNormal(p);\n    \n    float dif = GetLight(p);\n    col = vec3(dif);//dif d/= 0199.\n    col = hsv2rgb(col);\n    \n   \n    vec3 ld = vec3(0.,1., .5);\n    ///////////\n    vec3 sky = 0.*GetSky(rd, ld, vec3(11.5,1.,3.));// 0убери\n    ////////////////\n    \n    \n    //float t =iTime\\3.0;\n    // color\n    \n    //vec3 n =GetNormal(p);\n    vec3 l0 = normalize(vec3(-1.0,0.0,-1.0));\n    vec3 l1 = normalize(vec3(0.3,0.5,0.5));\n    vec3 l2 = normalize(vec3(1.0,1.0,0.4));\n   \n\n\n    //col += specular(n,l0,rd,1.1) * BLUE;//*vec3(cos(iTime)*.5,sin(iTime)*0.4,cos(iTime)*.5);\n    //col += specular(n,l1,rd,1.2) *1.1*GREEN;//* vec3(sin(iTime)*1.,cos(iTime)*1.,sin(iTime)*1.) * 1.1; \n    //col += specular(n,l2,rd,1.0) * 1.2; //*vec3(sin(iTime)*1.,cos(iTime)*1.,sin(iTime)*1.);\n    //col = col*.20;\n    \n   // col = col*vec3(dif);//col = col*vec3(dif)**vec3(dif2)\n    \n    \n   // col = col*vec3(0.9, 0.8, 0.6) *  0.2 * tc0;\n \t//col=mix(col,sky, 1.0-exp(-0.001*p.x*p.x));\n    \n  // col = pow(col, vec3(.4545));\t// gamma correction   col = pow(col, vec3(.4545)); \n    fragColor = vec4(pow(col,vec3(0.4545)),0.0);//hs2v function\n    fragColor.xyz = mix( fragColor.xyz, sky, 0.*1.0-exp( -0.01*d*d ) );//fog (*1.0-exp( -0.01*d*d )\n    \n}", "image_inputs": [{"id": "4dXGRr", "previewfilepath": "/presets/tex00.jpg", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/presets/tex00.jpg", "ctype": "keyboard"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/7dsGRS.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "7dsSDM", "name": "Circle Sandbox DELUXE", "author": "lmno", "description": "My DELUXE sandbox for making cool circle-y stuffs.\noriginal: https://www.shadertoy.com/view/NdlSD7\noriginal BEFORE the original:", "tags": ["circle"], "likes": 4, "viewed": 36, "date": "1618721545", "time_retrieved": "2024-06-20T20:36:18.457025", "image_code": "// Fork of \"Circle Sandbox\" by lmno. https://shadertoy.com/view/NdlSD7\n// 2021-04-18 04:11:54\n\n\n// Drawing utilities\n#define drawSDF(dist, col) color = mix(color, col, smoothstep(unit, -0.05, dist))\n\n// SDFs\nfloat sdDisc(in vec2 p, in vec2 o, in float r) {\n    return length(p - o) - r;\n}\n\nfloat sdInfLine(in vec2 p, in vec2 a, in vec2 b) {\n    vec2 pa = p - a, ba = b - a;\n    return length(pa - ba * dot(pa, ba) / dot(ba, ba));\n}\n\nfloat sdLine(in vec2 p, in vec2 a, in vec2 b) {\n    vec2 pa = p - a, ba = b - a;\n    return length(pa - ba * clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 center = 0.5 * iResolution.xy;\n\n    vec4 mouse = (vec4(iMouse.xy, abs(iMouse.zw)) - center.xyxy) / iResolution.y * 4.0;\n    vec2 uv = (fragCoord - center) / iResolution.y * 4.0;\n    float unit = 9.0 / iResolution.y;\n    vec3 color = vec3(0.075,0.094,0.604);\n\n    // Default before interaction\n    if (ivec2(iMouse.xy) == ivec2(0)) {\n        mouse.xy = vec2(sin(iTime), 1.0) * cos(iTime);\n        mouse.x += 2.0;\n    }\n\n    // Radius and angles\n    float r = 0.75;\n    vec2 a = atan(mouse.y, mouse.x) + vec2(2.0, -1.9) * acos(r / length(mouse.xy));\n\n    // For just the points, this can be simplified (likely no sin/cos, just 1 or 2 sqrts)\n    vec2 t1 = vec2(cos(a.x), sin(a.x)) * r;\n    vec2 t2 = vec2(cos(a.y), sin(a.y)) * r;\n    vec2 t3 = vec2(cos(a.x), sin(a.y)) * r;\n    vec2 t4 = vec2(cos(a.y), sin(a.x)) * r;\n    vec2 t5 = vec2(sin(a.y), sin(a.y)) * r;\n    vec2 t6 = vec2(sin(a.x), sin(a.x)) * r;\n    vec2 t7 = vec2(cos(a.y), cos(a.y)) * r;\n    vec2 t8 = vec2(cos(a.x), cos(a.x)) * r;\n    vec2 t9 = vec2(sin(a.x), cos(a.x)) * r;\n    vec2 t10 = vec2(sin(a.y), cos(a.y)) * r;\n    vec2 t11 = vec2(tan(a.y), tan(a.y)) * r;\n    vec2 t12 = vec2(tan(a.x), tan(a.x)) * r;\n    vec2 t13 = vec2(tan(a.x), sin(a.x)) * r;\n    vec2 t14 = vec2(tan(a.y), sin(a.y)) * r;\n    vec2 t15 = vec2(sin(a.y), tan(a.y)) * r;\n    vec2 t16 = vec2(sin(a.x), tan(a.x)) * r;\n    vec2 t17 = vec2(log(a.x), log(a.x)) * r;\n    vec2 t18 = vec2(log(a.y), log(a.y)) * r;\n    vec2 t19 = vec2(log(a.y), sin(a.y)) * r;\n\n\n    // Circle\n    drawSDF(abs(sdDisc(uv, vec2(0.0), r)), vec3(0.000,0.0,1.000));\n\n    // Right triangle 1\n    drawSDF(min(sdLine(uv, vec2(0.0), mouse.xy),\n            min(sdLine(uv, mouse.xy, t1),\n                sdLine(uv, t1, vec2(0.0)))), vec3(0.000,1.0,1.000));\n\n    // Right triangle 2\n    drawSDF(min(sdLine(uv, vec2(0.0), mouse.xy),\n            min(sdLine(uv, mouse.xy, t2),\n                sdLine(uv, t2, vec2(0.0)))), vec3(0.000,1.000,1.000));\n                \n                \n                 drawSDF(min(sdLine(uv, vec2(0.0), mouse.xy),\n            min(sdLine(uv, mouse.xy, t3),\n                sdLine(uv, t3, vec2(0.0)))), vec3(0.0, 1.0, 1.0));\n                \n                \n                                 drawSDF(min(sdLine(uv, vec2(0.0), mouse.xy),\n            min(sdLine(uv, mouse.xy, t4),\n                sdLine(uv, t4, vec2(0.0)))), vec3(0.0, 1.0, 1.0));\n                \n                \n                \n                \n                                        drawSDF(min(sdLine(uv, vec2(0.0), mouse.xy),\n            min(sdLine(uv, mouse.xy, t5),\n                sdLine(uv, t5, vec2(1.0)))), vec3(0.0, 1.0, 1.0));\n                \n                \n                \n                \n                        \n                                        drawSDF(min(sdLine(uv, vec2(0.0), mouse.xy),\n            min(sdLine(uv, mouse.xy, t6),\n                sdLine(uv, t6, vec2(1.0)))), vec3(0.0, 1.0, 1.0));\n                \n                \n                               \n                                        drawSDF(min(sdLine(uv, vec2(0.0), mouse.xy),\n            min(sdLine(uv, mouse.xy, t7),\n                sdLine(uv, t7, vec2(1.0)))), vec3(0.0, 1.0, 1.0));\n                \n                \n                \n                                      \n                                        drawSDF(min(sdLine(uv, vec2(0.0), mouse.xy),\n            min(sdLine(uv, mouse.xy, t8),\n                sdLine(uv, t8, vec2(1.0)))), vec3(0.0, 1.0, 1.0));\n                \n                \n                \n                                                drawSDF(min(sdLine(uv, vec2(0.0), mouse.xy),\n            min(sdLine(uv, mouse.xy, t9),\n                sdLine(uv, t9, vec2(1.0)))), vec3(0.0, 1.0, 1.0));\n                \n                \n                \n                         \n                                                drawSDF(min(sdLine(uv, vec2(0.0), mouse.xy),\n            min(sdLine(uv, mouse.xy, t10),\n                sdLine(uv, t10, vec2(1.0)))), vec3(0.0, 1.0, 1.0));\n                \n                \n                \n                \n                                        \n                                                drawSDF(min(sdLine(uv, vec2(0.0), mouse.xy),\n            min(sdLine(uv, mouse.xy, t11),\n                sdLine(uv, t11, vec2(1.0)))), vec3(0.0, 1.0, 1.0));\n                               \n                                \n                                \n                                      \n                                                drawSDF(min(sdLine(uv, vec2(0.0), mouse.xy),\n            min(sdLine(uv, mouse.xy, t12),\n                sdLine(uv, t12, vec2(1.0)))), vec3(0.0, 1.0, 1.0));\n\n                \n                \n                           \n                                                drawSDF(min(sdLine(uv, vec2(0.0), mouse.xy),\n            min(sdLine(uv, mouse.xy, t13),\n                sdLine(uv, t13, vec2(1.0)))), vec3(0.0, 1.0, 1.0));\n                \n                \n                \n                                    \n                                                drawSDF(min(sdLine(uv, vec2(0.0), mouse.xy),\n            min(sdLine(uv, mouse.xy, t14),\n                sdLine(uv, t14, vec2(1.0)))), vec3(0.0, 1.0, 1.0));\n                \n                                \n                                \n                                                drawSDF(min(sdLine(uv, vec2(0.0), mouse.xy),\n            min(sdLine(uv, mouse.xy, t15),\n                sdLine(uv, t15, vec2(1.0)))), vec3(0.0, 1.0, 1.0));\n                \n                \n                \n                                                      drawSDF(min(sdLine(uv, vec2(0.0), mouse.xy),\n            min(sdLine(uv, mouse.xy, t16),\n                sdLine(uv, t16, vec2(1.0)))), vec3(0.0, 1.0, 1.0));\n                \n                \n   \n                                \n                                                      drawSDF(min(sdLine(uv, vec2(0.0), mouse.xy),\n            min(sdLine(uv, mouse.xy, t17),\n                sdLine(uv, t17, vec2(1.0)))), vec3(0.0, 1.0, 1.0));\n                \n                          \n                                                      drawSDF(min(sdLine(uv, vec2(0.0), mouse.xy),\n            min(sdLine(uv, mouse.xy, t18),\n                sdLine(uv, t18, vec2(1.0)))), vec3(0.0, 1.0, 1.0));           \n                \n                \n                \n                                                   drawSDF(min(sdLine(uv, vec2(0.0), mouse.xy),\n            min(sdLine(uv, mouse.xy, t19),\n                sdLine(uv, t19, vec2(1.0)))), vec3(0.0, 1.0, 1.0));       \n      \n\n\n\n    // Tangents\n    drawSDF(sdInfLine(uv, mouse.xy, t1), vec3(0.0, 0.0, 1.0));\n    drawSDF(sdInfLine(uv, mouse.xy, t2), vec3(0.0, 0.0, 1.0));\n    drawSDF(sdInfLine(uv, mouse.xy, t3), vec3(0.0, 0.0, 1.0));\n    drawSDF(sdInfLine(uv, mouse.xy, t4), vec3(0.000,0.0,1.000));\n    drawSDF(sdInfLine(uv, mouse.xy, t5), vec3(0.000,0.0,1.000));\n    drawSDF(sdInfLine(uv, mouse.xy, t6), vec3(0.000,0.0,1.000));\n    drawSDF(sdInfLine(uv, mouse.xy, t7), vec3(0.000,0.0,1.000));\n    drawSDF(sdInfLine(uv, mouse.xy, t8), vec3(0.000,0.0,1.000));\n    drawSDF(sdInfLine(uv, mouse.xy, t9), vec3(0.000,0.0,1.000));\n    drawSDF(sdInfLine(uv, mouse.xy, t10), vec3(0.000,0.0,1.000));\n    drawSDF(sdInfLine(uv, mouse.xy, t11), vec3(0.000,0.0,1.000));\n    drawSDF(sdInfLine(uv, mouse.xy, t12), vec3(0.000,0.0,1.000));\n    drawSDF(sdInfLine(uv, mouse.xy, t13), vec3(0.000,0.0,1.000));\n    drawSDF(sdInfLine(uv, mouse.xy, t14), vec3(0.000,0.0,1.000));\n    drawSDF(sdInfLine(uv, mouse.xy, t15), vec3(0.000,0.0,1.000));\n    drawSDF(sdInfLine(uv, mouse.xy, t16), vec3(0.000,0.0,1.000));\n    drawSDF(sdInfLine(uv, mouse.xy, t17), vec3(0.000,0.0,1.000));\n    drawSDF(sdInfLine(uv, mouse.xy, t18), vec3(0.000,0.0,1.000));\n    drawSDF(sdInfLine(uv, mouse.xy, t19), vec3(0.000,0.0,1.000));\n    \n\n    // Point\n    drawSDF(sdDisc(uv, mouse.xy, 0.005), vec3(2.0));\n\n    fragColor = vec4(color, 2.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/7dsSDM.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "7dsXD4", "name": "Simple loading icon 2", "author": "SnoopethDuckDuck", "description": "e", "tags": ["cool"], "likes": 2, "viewed": 34, "date": "1618677157", "time_retrieved": "2024-06-20T20:36:18.457025", "image_code": "float f(float x)\n{ return 16. * x * x * (1.-x) *(1.-x);}\n\nfloat tri(float x)\n{\nreturn 3. * (2. * max(fract(x),fract(-x))-1.)+2.;\n}\n\nfloat func(vec2 uv, float t)\n{    \nfloat b = f(0.5 * (1. + cos(t)));\nvec2 dir = uv - 0.5;\nfloat theta = atan(dir.y,dir.x);\n\n    float k = round(tri( t /(6.* 3.14159)));  \nfloat d = (1.-b) * length(dir) * (1. + 0.1* cos(k * theta + 3. * t))\n+ b * b * (pow(abs(dir.x),b)+pow(abs(dir.y),b));\nd = f(3.* d);\n\nreturn step(d +0.01,sqrt((1.-b)*(1.-b) + b* b));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.y - vec2(0.375,0);\n   // uv = 0.5 * uv + 0.5 * floor(99. * uv)/99. ;\n    \n      float t =iTime;\n  \nvec3 col = vec3(func(uv,t +0.024), func(uv,t), func(uv, t -0.024));\n\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/7dsXD4.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "7dsXRr", "name": "Neon Raymarch", "author": "boris159", "description": "Neon raymarching", "tags": ["3d", "raymarching", "neon"], "likes": 14, "viewed": 229, "date": "1618238484", "time_retrieved": "2024-06-20T20:36:18.457025", "image_code": "#define EPSILON 0.001\n#define PI 3.141592\n#define MAX_DIST 32.0\n#define MAX_STEPS 128\n#define REPEAT 2.0\n#define BLOOM_DEPTH 16.0;\n#define BLOOM_IT 128\n#define ANG 7.5\n\nfloat seed;\n\nfloat rand()\n{\n    seed += 0.15342;\n    return fract(sin(seed) * 35423.7652344);\n}\n\nmat2 rot(float ang)\n{\n    float s = sin(ang);\n    float c = cos(ang);\n    return mat2(c, -s, s, c);\n}\n\nvec3 rotVec(vec3 p, vec3 r)\n{\n    p.yz *= rot(r.x);\n    p.xz *= rot(r.y);\n    p.xy *= rot(r.z);\n    return p;\n}\n\nvec3 makeRay(vec2 origin)\n{\n    vec2 res;\n    res.x = origin.x - iResolution.x * 0.5;\n    res.y = origin.y - iResolution.y * 0.5;\n    return normalize(vec3(res / iResolution.yy, 0.5));\n}\n\nfloat capsule(vec3 a, vec3 b, float r, vec3 p)\n{\n    vec3 pa = p - a, ba = b - a;\n  \tfloat h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\n  \treturn length(pa - ba * h) - r;\n}\n\nvec3 dirByAng(float deg, float mag)\n{\n    float rad = deg * PI / 180.0;\n    return vec3(sin(rad), cos(rad), 0) * mag;\n}\n\nfloat getDist(vec3 origin)\n{\n    float ang = origin.z / REPEAT * ANG - ANG;\n    origin.z = mod(origin.z + REPEAT * 0.5, REPEAT) - REPEAT * 0.5;\n    \n    vec3 a = dirByAng(0.0 + ang, 1.0);\n    vec3 b = dirByAng(120.0 + ang, 1.0);\n    vec3 c = dirByAng(240.0 + ang, 1.0);\n    \n    float cap1 = capsule(a, b, 0.01, origin);\n    float cap2 = capsule(b, c, 0.01, origin);\n    float cap3 = capsule(c, a, 0.01, origin);\n    return min(cap1, min(cap2, cap3));\n}\n\nvec3 getNormal(vec3 p)\n{\n    float d = getDist(p);\n    vec2 e = vec2(EPSILON, 0);\n    \n    vec3 n = d - vec3(\n        getDist(p-e.xyy),\n        getDist(p-e.yxy),\n        getDist(p-e.yyx));\n    \n    return normalize(n);\n}\n\nfloat rayMarch(vec3 origin, vec3 direct)\n{\n    float res = 0.0;\n    \n    for (int i = 0; i < MAX_STEPS; i++)\n    {\n        vec3 tmp = origin + direct * res;\n        float d = getDist(tmp);\n        res += d;\n        \n        if (res >= MAX_DIST || d < EPSILON)\n        \tbreak;\n    }\n\n    return res;\n}\n\nvec3 getCol(float z)\n{\n    float fac = (cos(z / REPEAT * PI) + 1.0) * 0.5;\n    return mix(vec3(1, 0.1, 0.25), vec3(0.25, 0.1, 1), fac);\n}\n\nvec3 getBloom(vec3 pos, vec3 dir)\n{\n    vec3 res = vec3(0);\n    vec3 end = pos + dir * BLOOM_DEPTH;\n    \n    for (int i = 0; i < BLOOM_IT; i++)\n    {\n        float fac = (float(i) + rand()) / float(BLOOM_IT);\n        vec3 p = mix(pos, end, fac);\n        float d = getDist(p);\n        res += getCol(p.z) / d / float(BLOOM_IT);\n    }\n    \n    return res;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    seed = iTime + iResolution.y * fragCoord.x / iResolution.x + fragCoord.y / iResolution.y;\n    vec3 pos = vec3(0, 0, iTime * 2.0);\n    vec3 dir = makeRay(fragCoord);\n    dir = rotVec(dir, vec3(0, 0, -(pos.z / REPEAT * ANG * PI / 180.0)));\n    \n    float res = rayMarch(pos, dir);\n    vec3 col = getBloom(pos, dir);\n    \n    if (res < MAX_DIST)\n        col = vec3(1);\n    \n    fragColor = vec4(col, 1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/7dsXRr.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "7dsXW2", "name": "StarStream", "author": "DougL_", "description": "drawing points following a target at different speeds", "tags": ["random", "abstract", "stars"], "likes": 4, "viewed": 56, "date": "1619347145", "time_retrieved": "2024-06-20T20:36:18.457025", "image_code": "float hash12(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    const float cellCount = 256.0;\n    \n    vec2 fracUv = fract(uv * cellCount);\n    vec2 floorUv = floor(uv*cellCount);\n    \n    float hash = hash12(floorUv.xx);\n    \n    float target = fract(iTime*mix(0.1, 2.0, hash))*1.5;\n    \n    float c = uv.y;\n    float phase = 1.0-abs(c*2.0-1.0);\n    \n    vec3 line = vec3(1.0-abs(phase - target + 0.02),1.0-abs(phase - target+0.01),1.0-abs(phase - target-0.02));\n    line = pow(line, vec3(8.0));\n    line *= smoothstep(0.4, 1.0, 1.0-abs(fracUv.x*2.0-1.0));\n    line = line * line * line;\n    \n    // Output to screen\n    fragColor = vec4(vec3(sqrt(line)),1.0);\n}", "image_inputs": [{"id": "4dfGRn", "previewfilepath": "/media/ap/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/7dsXW2.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "7dsXWl", "name": "mind controller", "author": "4eckme", "description": "the matrix of telescopic rotors", "tags": ["2d", "game", "rgb", "technology"], "likes": 0, "viewed": 271, "date": "1619476074", "time_retrieved": "2024-06-20T20:36:18.596476", "image_code": "// click mouse and move\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float N = 60.0;//elements size\n    vec2 coord = fragCoord - (iResolution.xy / vec2(2.0));//simmetric\n    float x = float(coord.x); float y = float(coord.y);//coordinates from center\n    float t = pow(1.01, iTime);//animation speed \n    float dx = iMouse.x-iResolution.x/2.0;//mouse move x\n    float dy = iMouse.y-iResolution.y/2.0;//mouse move y\n    float f = float((x-dx)*(x-dx)*t+(y-dy)*(y-dy)*t);//the puck\n    float F = abs(f*log2(abs(sin((x+dx/2.2)/N)*sin((y+dy/2.2)/N))));//create parallax matrix of telescopic rotators\n    int R = int(floor(F*pow(16.0, 6.0-ceil(log2(F)/4.0)))); //adapt COLOR for X11\n    fragColor = vec4(\n        float(((R) >> 16)& 255) / 255.0,//red \n        float(((R) >> 8) & 255) / 255.0,//green\n        float(((R) >> 0) & 255) / 255.0,//blue\n        1.0\n    );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/7dsXWl.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "7dsXWn", "name": "Huts", "author": "lmno", "description": "the huts are built, then destroyed.", "tags": ["2d", "stripe", "huts"], "likes": 2, "viewed": 28, "date": "1618529841", "time_retrieved": "2024-06-20T20:36:19.269271", "image_code": "// The MIT License\n// Copyright © 2019 Miguel \"Codax\" Nieves\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n\n#define PI 5.14159265359\n\n//Inigo Quilez's Palette Function\n//https://www.shadertoy.com/view/ll2GD3\nvec3 pal( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d )\n{\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    //How many stripes to show (even works best)\n    float stripes = 20.0;\n    //Wave Scroll Speed\n    float speed = 0.25;\n    \n    //Animated height of each wave from -1 to 1\n    float amplitude = sin(iTime * 1.0);\n    //float amplitude = (2.0 * abs( (2.0 * fract(iTime * 0.5))-1.0 ) - 1.0); //Triangle Wave\n    amplitude *= 0.68;//0.78;\n    \n    uv.y = uv.y * stripes;\n    uv.x = uv.x * 4.0;\n    \n    float waveID = round(uv.y);\n    \n    //Current Wave but cap the parts would overlap\n    vec2 waveUV = uv;\n    waveUV.x += iTime  * speed * (2.0 * step(1.0,mod(waveID,2.0)) - 1.);\n    waveUV.y += max(-0.5, min(0.5, sin(waveUV.x * PI * 2.0) * amplitude));\n\n\t//Use next line only if amplitude is between -0.5 and 0.5\n    //waveUV.y += sin(waveUV.x * PI * 2.0) * amplitude; \n    \n    //Hold on to the current Stripe value\n    float midWave = waveUV.y;\n    \n    //Calculate the Value from the Stripe Above\n    float upperWave = uv.x + ( iTime * speed * (2.0 * step(1.0,mod(waveID + 1.0,2.0)) - 1.));\n    upperWave = sin(upperWave * PI * 2.0) * amplitude;\n    \n    upperWave *= 2.0- step(0.5, fract(uv.y));\n    /*if (fract(uv.y) >= 0.5) //Optimized Out\n    {\n        upperWave = 0.0;\n    }*/\n                      \n\tupperWave += fract(uv.y);\n    upperWave = step(1.0, upperWave);\n    \n    //Calculate the Value from the Strip Below\n    float lowerWave = uv.x + ( iTime * speed * (2.0 * step(1.0,mod(waveID - 1.0,2.0)) - 1.));\n    lowerWave = sin(lowerWave * PI * 2.0) * amplitude;\n    \n    lowerWave *= step(0.5, fract(uv.y));\n    /*if (fract(uv.y) < 0.5) //Optimized Out\n    {\n        lowerWave = 0.0;\n    }\n\t*/\n    lowerWave += fract(uv.y);\n    lowerWave = step(0.00, lowerWave);\n\n\n    //Mix and Overlap\n\tmidWave *= upperWave;\t//Use the Upperwave to first mask the mid wave\n    upperWave *= step(0.000,midWave - waveID); //Then overlap the upperwave by the midwave\n    \n    waveUV.y *= (1.0 - upperWave); //Mask out the upper Wave\n    waveUV.y += upperWave * (uv.y + 1.0); //Add in the upper \n    \n\twaveUV.y *= lowerWave;  //Mask out the lower wave from the \n    waveUV.y += (1.0 - lowerWave) * (uv.y - 1.0); //Put in the overlap from the lower wave\n\n   \n    //Create a color ID from 0.0 - 1.0\n    float colorID = floor( waveUV.y ) / stripes;\n    \n    float ct = iTime * 0.1;\n    //vec3 col = pal( colorID, vec3(0.5,0.5,0.5),vec3(0.5,0.5,0.5),vec3(2.0,1.0,1.0),vec3(0.4 * sin(ct*1.23),0.40 * cos(ct*2.14),0.80 * sin(-ct)) );\n    vec3 col = pal( colorID, vec3(1.5,0.5,1.0),vec3(0.5,0.5,1.0),vec3(2.0, 1.0, 0.0),vec3(0.2+sin(ct*1.23), 0.2+cos(ct*2.14), 0.1 + sin(-ct)));\n    \n    //Darken the bottom few waves\n    col *= smoothstep(1.0, 0.6, 1.0 - colorID);\n\n    // Wave Debug\n    //col = vec3(colorID);// * fract(uv.y));\n\n    // Output to screen \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "mit", "thumbnail": "https://www.shadertoy.com/media/shaders/7dsXWn.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "7dsXzX", "name": "Rotating circles spiral 1", "author": "smjty", "description": "Use the mouse to change the radius of the inner circles. This shader is available on hicetnunc: https://www.hicetnunc.xyz/objkt/41129\nI used a finite complex sum to solve the position of inner circles.", "tags": ["2d", "simple", "circle", "comples"], "likes": 8, "viewed": 120, "date": "1619166023", "time_retrieved": "2024-06-20T20:36:19.269271", "image_code": "//Source code for the piece: https://www.hicetnunc.xyz/objkt/41129    |  Twitter: @smjtyazdi. \n//Special thanks to @FabriceNeyret2 !\n#define PI 3.14159265\n\nfloat circle(vec2 pos, vec3 circ){\n    return max(length(pos-circ.xy) - circ.z,0.0)/2.;\n\n}\nfloat flip(float a , float b){\n    b = b*2.-1.;\n    return a*b - b/2. + 0.5;\n}\n\n//complex funcs\nvec2 Cinv(vec2 a){\n    return vec2(a.x,-a.y)/dot(a,a);\n}\nvec2 Cmul(vec2 a , vec2 b){\n    return vec2(a.x*b.x - a.y*b.y , a.x*b.y+a.y*b.x);\n}\nvec2 Cpow(vec2 a, float n){\n    float r = length(a);\n    float t = atan(a.y,a.x);\n    return vec2(cos(t*n), sin(t*n))*pow(r,n);\n}\n///////////////\n\nfloat render(vec2 p){\n\n    float scale = iResolution.y/2.1;\n    float r = clamp(0.07 + iMouse.x/iResolution.x/2.31 , 0. , 0.9);\n    \n    float time = iTime/2.;\n    float t = time - sin(time);\n    \n    vec2 A = vec2(cos(t),sin(t))*(1.-r);\n\tfloat col = 1.;\n    \n    float radi = 1.;\n    \n    for(int i=0;i<50;i++){\n\n        vec2 pos = scale * r * Cmul( vec2(1.,0.) - Cpow(A,float(i)) , Cinv( vec2(1.,0.) - A ) );\n        col = flip(col , clamp(circle(p,vec3(pos,scale*radi)) , 0.,1.0 ));\n        if(i>0)\n            col = flip(col , clamp(circle(-p,vec3(pos,scale*radi)) , 0.,1.0 ));\n            \n        radi *= 1.-r ;\n        \n        if(radi*scale<0.2)break;\n    }\n   \n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   vec2 p = (fragCoord.xy  - iResolution.xy/2.0);\n   float col = render(p);\n   \n   vec3 color2 = vec3(0,0,0);\n   vec3 color1 = vec3(1,1,1);\n\n   fragColor = vec4(mix(color2,color1,col),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/7dsXzX.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "7dXXDn", "name": "2D Lighting - No Random Sampling", "author": "oneshade", "description": "Improved version of this shader: [url=https://www.shadertoy.com/view/3tsXzB]https://www.shadertoy.com/view/3tsXzB[/url]\nTodo: add shadows", "tags": ["2d", "light", "analytic"], "likes": 3, "viewed": 87, "date": "1618468254", "time_retrieved": "2024-06-20T20:36:19.608596", "image_code": "// 2D area lights I've been working on\n// https://www.shadertoy.com/view/fsfXDr\nfloat lightLine(in vec2 p, in vec2 a, in vec2 b) {\n    vec2 pa = p - a, pb = p - b;\n    return acos(dot(pa, pb) / (length(pa) * length(pb))) / 3.14;\n}\n\n// https://www.shadertoy.com/view/fsfSWn\nfloat lightDisc(in vec2 p, in float r) {\n    float dd = dot(p, p);\n    if (dd < r * r) return 1.0;\n    return 1.0 - acos(r / sqrt(dd)) / 1.57;\n}\n\n// https://www.shadertoy.com/view/ssXSDn\nfloat lightBox(in vec2 p, in vec2 b) {\n    p = abs(p);\n    if (all(lessThan(p, b))) return 1.0;\n    vec2 v1 = p - vec2(b.x * sign(b.y - p.y), b.y);\n    vec2 v2 = p - vec2(b.x, b.y * sign(b.x - p.x));\n    return acos(dot(v1, v2) / (length(v1) * length(v2))) / 3.14;\n}\n\n// SDFs\nfloat sdLine(in vec2 p, in vec2 a, in vec2 b) {\n    vec2 pa = p - a, ba = b - a;\n    return length(pa - ba * clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0));\n}\n\nfloat sdDisc(in vec2 p, in float r) {\n    return length(p) - r;\n}\n\nfloat sdBox(in vec2 p, in vec2 b) {\n    vec2 q = abs(p) - b;\n    return length(max(q, 0.0)) + min(0.0, max(q.x, q.y));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y * 4.0;\n    vec3 color = vec3(0.0);\n\n    // UV relative to each light\n    vec2 bp1 = uv + vec2(1.6, -0.4);\n    vec2 bp2 = uv + vec2(0.0, sin(iTime));\n    vec2 dp = uv - vec2(1.6, 0.4);\n\n    // Solid color on the insides\n    if (sdBox(bp1, vec2(0.4)) < 0.0) color.gb += 1.0;\n    else if (sdBox(bp2, vec2(0.4, 1.5)) < 0.0) color.r += 0.8;\n    else if (sdDisc(dp, 0.2) < 0.0) color += 1.0;\n\n    // Lighting on the outsides\n    else {\n        color.gb += lightBox(bp1, vec2(0.4)) * 1.5;\n        color.r += lightBox(bp2, vec2(0.4, 1.5)) * 0.65;\n        color.rb += lightDisc(dp, 0.2) * vec2(0.5, 3.0);\n        color *= 0.6; // Tone down the brightness\n    }\n\n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/7dXXDn.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "7s23DD", "name": "Tastey Eggies", "author": "blackle", "description": "shader showdown @ revision 2021 winner :3", "tags": ["revision", "eggs", "shadershowdown", "livecode", "revision2021"], "likes": 31, "viewed": 568, "date": "1617465838", "time_retrieved": "2024-06-20T20:36:20.475437", "image_code": "//CC0 1.0 Universal https://creativecommons.org/publicdomain/zero/1.0/\n//To the extent possible under law, Blackle Mori has waived all copyright and related or neighboring rights to this work.\n\nfloat time;\nfloat bar;\nfloat bpm = 130.;\n\n//in the showdown I added cut eggs, but tbh I don't like how it looks, so you can enable it by uncommenting the next line\n#define DISABLE_CUT\n\n#define FK(k) floatBitsToInt(k*k/7.)^floatBitsToInt(k)\nfloat hash(float a, float b) {\n  int x = FK(a), y = FK(b);\n  return float((x*x-y)*(y*y+x)+x)/2.14e9;\n}\n\nvec3 rndcol(float hs) {\n  float h = hash(hs, 420.);\n  if (h > .5) {\n    return vec3(.9,.8,.4);\n  }\n  if (h > .0) {\n    return vec3(.4,.8,.4);\n  }\n  if (h > -.5) {\n    return vec3(.4,.8,.9);\n  }\n  return vec3(.9,.3,.8);\n}\n\nfloat super(vec2 p, float k) {\n  return mix(length(p), sqrt(length(p*p)), k);\n}\n\nvec3 pattern(vec2 p, float hs) {\n  vec2 op = p;\n  if (hash(hs,399.)<0.) {\n    p.y += asin(sin(p.x*40.))/40.;\n  }\n  if (hash(hs,342.)<0.) {\n    p.y = abs(p.y)-.2;\n  }\n  if (hash(hs,934.)<0.) {\n    p.y = -p.y;\n  }\n  if (p.y < 0.) {\n    return rndcol(hash(hs,453.));\n  }\n  if (p.y > 0.) {\n    op = asin(sin(op*30.))/30.;\n    if (hash(hs,666.)<0. && super(op,hash(hs,777.)*4.-2.) < .015) {\n      return  rndcol(hash(hs,339.));\n    }\n  }\n  return vec3(1);\n}\n\nvec3 erot(vec3 p, vec3 ax, float ro) {\n  return mix(dot(p,ax)*ax,p,cos(ro))+sin(ro)*cross(ax,p);\n}\nvec3 rndrot(vec3 p, float sd) {\n  float h1 = hash(sd, 43432.);\n  float h2 = hash(sd, 34332.);\n  float h3 = hash(sd, 12356.);\n  return erot(p, normalize(tan(vec3(h1,h2,h3))), h1*100.+iTime*2.);\n}\n\nfloat linedist(vec2 p, vec2 a, vec2 b) {\n  float k = dot(p-a,b-a)/dot(b-a,b-a);\n  return distance(p,mix(a,b,clamp(k,0.,1.)));\n}\n\nfloat smiley;\nfloat egg(vec3 p, bool chopp) {\n  float eg = mix( linedist(vec2( sqrt(dot(p.xy,p.xy)+.2) -.1, p.z), vec2(-.3,.5), vec2(0,-.5)  )-.9,length(p)-1.,.3 );\n  eg = abs(eg+.01)-.02;\n#ifndef DISABLE_CUT\n  if (chopp) {\n    eg = max(eg, p.z);\n  }\n#endif\n    smiley  = length(p+vec3(cos(time*9.)*.2,sin(time*9.)*.2,sin(time*4.)*.5))-.4;\n  return min(eg,smiley);\n}\n\nvec3 glob;\nfloat idx;\nfloat scene(vec3 p) {\n  idx = round(p.y/3.)*3.;\n  bool willchop = false;\n  if (hash(bar,2313.) < 0.) {\n    idx = 0.;\n    willchop = true;\n  }\n  p.y -= idx;\n  if (hash(bar,1312.) < .0) {\n    p.x += sin(time*2.+idx);\n  } else {\n    p.z += -abs(sin(time*3.1415+idx*.1))+.5;\n  }\n  p = rndrot(p, bar+idx*100.);\n  glob = p;\n  return egg(p, willchop);\n}\n\nvec3 norm(vec3 p) {\n  mat3 k = mat3(p,p,p) - mat3(0.001);\n  return normalize(scene(p) - vec3( scene(k[0]),scene(k[1]),scene(k[2]) ));\n}\n//candy!\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\n  time = fract(iTime*bpm/120.);\n  bar = floor(iTime*bpm/120.);\n  vec2 uv2 = uv;\n  \n  if (hash(bar,7434.) < 0.) {\n    uv2.y += sin(uv.x*8.+time)*.05;\n  }\n  fragColor.xyz = pattern(uv2,bar);\n  \n  \n  vec3 cam = normalize(vec3(1,uv));\n  vec3 init = vec3(-5,0,0);\n  \n  if (hash(bar,2341.) < 0.) {\n    cam = erot(cam, vec3(0,1,0), radians(45.));\n    init = erot(init, vec3(0,1,0), radians(45.));\n  }\n  \n  vec3 p = init;\n  bool hit = false;\n  float dist;\n  for (int i = 0; i < 100 && !hit; i++) {\n    dist = scene(p);\n    hit = dist*dist < 1e-6;\n    p += dist*cam;\n    if (distance(p,init)>10.)break;\n  }\n  \n  \n  if (hit) {\n    bool issmiley = smiley == dist;\n    float rix = idx;\n    vec3 loc = glob;\n    vec3 n = norm(p);\n    vec3 r = reflect(cam,n);\n    float spec = length(sin(r*3.)*.5+.5)/sqrt(3.);\n    float fres = 1. - abs(dot(cam,n))*.98;\n    float diff = length(sin(n*2.)*.3+.7)/sqrt(3.);\n    vec2 crds = vec2(atan(loc.x,loc.y)*.8,loc.z);\n    vec3 dcol = pattern(crds/3., bar+2392.+rix*100.);\n    if (issmiley) {\n      dcol = rndcol(3485.+bar);\n    }\n    vec3 col = dcol*diff + pow(spec,7.)*fres;\n    fragColor.xyz = col;\n  }\n  \n  fragColor.xyz = sqrt(fragColor.xyz);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc0-1.0", "thumbnail": "https://www.shadertoy.com/media/shaders/7s23DD.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "7s23WW", "name": "Showdown Revision 2021 - Semi1", "author": "Pixdigit", "description": "Whenever I watch a shader showdown I try to code a shader alongside to see what I manage to do. This was the first time doing this, so this is a fairly simple shader.", "tags": ["circles", "wave", "tiling"], "likes": 1, "viewed": 52, "date": "1617455186", "time_retrieved": "2024-06-20T20:36:20.645721", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.x;\n\n    vec2 wave = vec2(uv.x, sin(iTime * 2. + uv.x * 4.) * 0.1 + uv.y) * 10.;\n    vec2 guv = fract(wave);\n    vec2 gid = floor(wave - .5);\n\n    // Time varying pixel color\n    vec3 col = vec3(0);\n    if (length(guv - 0.5)>0.3) {\n        col = 0.5 + 0.5*cos(iTime+uv.xyx+gid.xyx+vec3(0,2,4));\n    } else {\n        if (length(guv - 0.5) < 0.3 * smoothstep(.5, 0., abs(sin(iTime + uv.x)))) {\n            col = vec3(1.);\n        }\n    }\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/7s23WW.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "7s2GDm", "name": "Infinite Spheres Ray Marching 2", "author": "CustomPhase", "description": "Forked to show the \"infinite-ness\" of it a bit better. The lighting artifacts are due to lazy implementation of the Distance Estimator (it only considers current cell, instead of current and all neighbouring cells)", "tags": ["raymarching", "spheres"], "likes": 3, "viewed": 201, "date": "1617538544", "time_retrieved": "2024-06-20T20:36:21.227072", "image_code": "#define MAXSTEPS 990\n#define MINDIST .01\n\n// A single iteration of Bob Jenkins' One-At-A-Time hashing algorithm.\nuint hash( uint x ) {\n    x += ( x << 10u );\n    x ^= ( x >>  6u );\n    x += ( x <<  3u );\n    x ^= ( x >> 11u );\n    x += ( x << 15u );\n    return x;\n}\n\n\n\n// Compound versions of the hashing algorithm I whipped together.\nuint hash( uvec2 v ) { return hash( v.x ^ hash(v.y)                         ); }\nuint hash( uvec3 v ) { return hash( v.x ^ hash(v.y) ^ hash(v.z)             ); }\nuint hash( uvec4 v ) { return hash( v.x ^ hash(v.y) ^ hash(v.z) ^ hash(v.w) ); }\n\n\n\n// Construct a float with half-open range [0:1] using low 23 bits.\n// All zeroes yields 0.0, all ones yields the next smallest representable value below 1.0.\nfloat floatConstruct( uint m ) {\n    const uint ieeeMantissa = 0x007FFFFFu; // binary32 mantissa bitmask\n    const uint ieeeOne      = 0x3F800000u; // 1.0 in IEEE binary32\n\n    m &= ieeeMantissa;                     // Keep only mantissa bits (fractional part)\n    m |= ieeeOne;                          // Add fractional part to 1.0\n\n    float  f = uintBitsToFloat( m );       // Range [1:2]\n    return f - 1.0;                        // Range [0:1]\n}\n\n// Pseudo-random value in half-open range [0:1].\nfloat random( float x ) { return floatConstruct(hash(floatBitsToUint(x))); }\nfloat random( vec2  v ) { return floatConstruct(hash(floatBitsToUint(v))); }\nfloat random( vec3  v ) { return floatConstruct(hash(floatBitsToUint(v))); }\nfloat random( vec4  v ) { return floatConstruct(hash(floatBitsToUint(v))); }\n\nvec3 randColor(vec3 center) {\n    return vec3(random(center*vec3(5)), random(center*vec3(15)+vec3(50)), random(center*vec3(35)+vec3(90)));\n}\n\nvec3 cameraMovement() {\n    return vec3(sin(iTime*1.0)*5.8,-0.5*iTime,iTime*2.8);\n}\n\nfloat DistanceEstimator(vec3 pos, vec3 cameraPos, out vec3 center, out vec3 normal) {\n    \n    // translate\n    //pos = pos + cameraMovement();\n    \n    center = floor(pos/2.0)*2.0+1.;\n    float rand = random(center*30.);\n    float randRad = random(center*20.+44.)*0.5+0.5;\n    vec3 offsCenter = center + vec3(sin(iTime*4.0+rand*27.0)*0.3,sin(iTime*5.0+rand*9.0)*0.3,0);\n    normal = normalize(pos - offsCenter);\n\n    float d1 = distance(mod(pos, 2.), mod(offsCenter, 2.))-.42321 * randRad;\n    \n    return d1;\n}\n\nvec3 trace(vec3 from, vec3 direction) {\n\tfloat totalDistance = 0.0;\n\tint steps;\n    vec3 lastP = vec3(0);\n    vec3 lastCenter = vec3(0);\n    vec3 lastNormal = vec3(0);\n\tfor (steps=0; steps < MAXSTEPS; steps++) {\n\t\tvec3 p = from + totalDistance * direction;\n\t\tfloat dist = DistanceEstimator(p, from, lastCenter, lastNormal);\n\t\ttotalDistance += dist;\n        lastP = p;\n\t\tif (dist < MINDIST) break;\n\t}\n    //lastP += cameraMovement(); \n    vec3 center = lastCenter;\n    vec3 normal = lastNormal;\n    float light = dot(normal, normalize(vec3(0.6,1,-0.2)));\n    vec3 amb = pow(light*0.5+0.5, 0.8) * vec3(0.3, 0.45, 0.6);\n\treturn (amb + clamp(light, 0., 1.)*vec3(1.5, 1.3, 0.8)) * randColor(center);\n}\n\nvec3 aces_tonemap(vec3 color){\t\n\tmat3 m1 = mat3(\n        0.59719, 0.07600, 0.02840,\n        0.35458, 0.90834, 0.13383,\n        0.04823, 0.01566, 0.83777\n\t);\n\tmat3 m2 = mat3(\n        1.60475, -0.10208, -0.00327,\n        -0.53108,  1.10813, -0.07276,\n        -0.07367, -0.00605,  1.07602\n\t);\n\tvec3 v = m1 * color;    \n\tvec3 a = v * (v + 0.0245786) - 0.000090537;\n\tvec3 b = v * (0.983729 * v + 0.4329510) + 0.238081;\n\treturn pow(clamp(m2 * (a / b), 0.0, 1.0), vec3(1.0 / 2.2));\t\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    \n    vec2 uv = (fragCoord - 0.5*iResolution.xy) / iResolution.y;\n    \n    vec3 camPos = vec3(0, 2, 0) + cameraMovement();\n\tvec3 camViewDir = normalize(vec3(uv.xy, 1));\n    \n\tvec3 dist = trace(camPos, camViewDir);\n    \n    fragColor = vec4(aces_tonemap(dist), 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/7s2GDm.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "7s2GR3", "name": "Lone Planet and the Sun", "author": "edubart", "description": "Lone Planet and the Sun\n\nThe original code was generated by a tool I am working on, but should be readable.", "tags": ["planet", "cineshader"], "likes": 9, "viewed": 1536, "date": "1617799280", "time_retrieved": "2024-06-20T20:36:22.385204", "image_code": "/* Generated by Nelua 0.2.0-dev */\n/* Compile command: clang \"/home/bart/projects/nelua/nelua-lang/nelua_cache/demos/glsldemo.c\" -o \"/home/bart/projects/nelua/nelua-lang/nelua_cache/demos/glsldemo\" -Wall -fwrapv -g -lm */\n/* Compile hash: ajDYp5NtwWMYTraHttzrB2DfBzo */\n/* ------------------------------ DECLARATIONS ------------------------------ */\nvec3 vec_tovec3(float a);\nvec3 noise_vec3_yzx(vec3 self);\nvec3 noise_vec2_xyx(vec2 self);\nvec2 sincos(float x);\nfloat noise_hash1_2(vec2 v);\nfloat noise_hash1_3(vec3 v);\nfloat noise_noisemix3(float a1, float b1, float c1, float d1, float a2, float b2, float c2, float d2, vec3 f);\nfloat noise_noise_white_1(vec2 p);\nfloat noise_noise_value_1(vec3 p);\nfloat map(vec3 p);\nfloat ray_march(vec3 ro, vec3 rd);\nvec3 get_normal(vec3 p);\nfloat fbm3(vec3 p);\nvec3 planet_palette(float x);\nvec3 planet_color(vec3 p);\nvec3 shade(vec3 rd, vec3 p);\nvec3 perspective_camera(vec3 lookfrom, vec3 lookat, float tilt, float vfov, vec2 uv);\nfloat expstep(float x, float k);\nvec3 get_background(vec3 rd);\nvec3 color_tonemap_aces(vec3 col);\nvec3 color_saturate(vec3 col, float sat);\nvec3 color_tone_1(vec3 col, float gain, float lift, float invgamma);\nvec3 color_gamma_correction(vec3 col);\nvec3 vignette(vec3 col, vec2 coord, float strength, float amount);\nvec3 dither(vec3 col, vec2 coord, float amount);\nvec3 sun_glare(vec3 rd);\n/* ------------------------------ DEFINITIONS ------------------------------- */\nvec3 vec_tovec3(float a) {\n  return vec3(a, a, a);\n}\nvec3 noise_vec3_yzx(vec3 self) {\n  return vec3(self.y, self.z, self.x);\n}\nvec3 noise_vec2_xyx(vec2 self) {\n  return vec3(self.x, self.y, self.x);\n}\nvec2 sincos(float x) {\n  return vec2(sin(x), cos(x));\n}\nfloat noise_hash1_2(vec2 v) {\n  vec3 v3 = noise_vec2_xyx(v);\n  v3 = fract((v3 * 0.1031));\n  v3 = (v3 + dot(v3, (noise_vec3_yzx(v3) + 33.33)));\n  return fract(((v3.x + v3.y) * v3.z));\n}\nfloat noise_hash1_3(vec3 v) {\n  vec3 v3 = v;\n  v3 = fract((v3 * 0.1031));\n  v3 = (v3 + dot(v3, (noise_vec3_yzx(v3) + 33.33)));\n  return fract(((v3.x + v3.y) * v3.z));\n}\nfloat noise_noisemix3(float a1, float b1, float c1, float d1, float a2, float b2, float c2, float d2, vec3 f) {\n  vec3 u = ((f * f) * (3.0 - (2.0 * f)));\n  vec3 u1 = (1.0 - u);\n  return ((((((a1 * u1.x) + (b1 * u.x)) * u1.y) + (((c1 * u1.x) + (d1 * u.x)) * u.y)) * u1.z) + (((((a2 * u1.x) + (b2 * u.x)) * u1.y) + (((c2 * u1.x) + (d2 * u.x)) * u.y)) * u.z));\n}\nfloat noise_noise_white_1(vec2 p) {\n  return noise_hash1_2(p);\n}\nfloat noise_noise_value_1(vec3 p) {\n  vec3 i = floor(p);\n  vec3 f = fract(p);\n  vec3 j = (i + 1.0);\n  float a1 = noise_hash1_3(i);\n  float b1 = noise_hash1_3(vec3(j.x, i.y, i.z));\n  float c1 = noise_hash1_3(vec3(i.x, j.y, i.z));\n  float d1 = noise_hash1_3(vec3(j.x, j.y, i.z));\n  float a2 = noise_hash1_3(vec3(i.x, i.y, j.z));\n  float b2 = noise_hash1_3(vec3(j.x, i.y, j.z));\n  float c2 = noise_hash1_3(vec3(i.x, j.y, j.z));\n  float d2 = noise_hash1_3(j);\n  return noise_noisemix3(a1, b1, c1, d1, a2, b2, c2, d2, f);\n}\nfloat sphere_intersect(vec3 ro, vec3 rd, vec3 p, float r) {\n  vec3 oc = (ro - p);\n  float b = dot(oc, rd);\n  float c = (dot(oc, oc) - (r * r));\n  float h = ((b * b) - c);\n  if(h < 0.0) {\n    return -1.0f;\n  } else {\n    return ((-b) - sqrt(h));\n  }\n}\nfloat map(vec3 p) {\n  return (length(p) - 0.6);\n}\nfloat ray_march(vec3 ro, vec3 rd) {\n  float t = 0.0;\n  for(int i = 0; i < 128; i++) {\n    vec3 p = (ro + (t * rd));\n    float d = map(p);\n    if(d <= 0.0001) {\n      return t;\n    }\n    t = (t + d);\n    if(t > 10.0) {\n      return -1.0;\n    }\n  }\n  return -1.0;\n}\nfloat fbm3(vec3 p) {\n  float a = 1.0;\n  float t = 0.0;\n  t = (t + (a * noise_noise_value_1(p)));\n  a = (a * 0.5);\n  p = ((2.0 * p) + 100.0);\n  t = (t + (a * noise_noise_value_1(p)));\n  a = (a * 0.5);\n  p = ((2.0 * p) + 100.0);\n  t = (t + (a * noise_noise_value_1(p)));\n  a = (a * 0.5);\n  p = ((2.0 * p) + 100.0);\n  t = (t + (a * noise_noise_value_1(p)));\n  a = (a * 0.5);\n  p = ((2.0 * p) + 100.0);\n  t = (t + (a * noise_noise_value_1(p)));\n  a = (a * 0.5);\n  p = ((2.0 * p) + 100.0);\n  t = (t + (a * noise_noise_value_1(p)));\n  return t;\n}\nvec3 planet_palette(float x) {\n  vec3 col = vec3(0.1, 0.6, 0.9);\n  col = (col + (0.2 * sin(((6.28318531 * x) + vec3(0.3, 0.2, 0.1)))));\n  col = (col + (0.1 * sin(((14.4513262 * x) + vec3(0.1, 0.2, 0.3)))));\n  return col;\n}\nvec3 planet_color(vec3 p) {\n  p = (p * 2.0);\n  float t = iTime;\n  vec3 q = vec3((fbm3((p + (t * 0.03))) * 0.5), (fbm3(p) * 0.5), (fbm3((p + 33.33)) * 0.5));\n  vec3 r = vec3((fbm3(((p + q) + (t * 0.01))) * 0.5), (fbm3((p + q)) * 0.5), (fbm3(((p + q) + 33.33)) * 0.6));\n  float f = (fbm3(((p + (5.0 * r)) + (t * 0.02))) * 0.5);\n  vec3 col = planet_palette(r.y);\n  col = (col * ((clamp((f * f), 0.0, 1.0) * 0.9) + 0.1));\n  col = clamp(col, 0.0, 1.0);\n  return col;\n}\nvec3 shade(vec3 rd, vec3 p) {\n  vec3 normal = normalize(p);\n  float ambient_dif = 0.03;\n  vec3 dif = vec_tovec3(ambient_dif);\n  vec3 sun_dir = vec3(0.0, 0.0, 1.0);\n  vec3 sun_col = (vec3(1.0, 0.9, 0.9) * 4.0);\n  float sun_dif = clamp(((dot(normal, sun_dir) * 0.9) + 0.1), 0.0, 1.0);\n  dif = (dif + (sun_col * sun_dif));\n  vec3 mate = (planet_color(p) * 0.4);\n  vec3 col = (mate * dif);\n  float fres = clamp((1.0 + dot(normal, rd)), 0.0, 1.0);\n  float sun_fres = (fres * clamp(dot(rd, sun_dir), 0.0, 1.0));\n  col = (col * (1.0 - fres));\n  col = (col + ((pow(sun_fres, 8.0) * vec3(0.4, 0.3, 0.1)) * 5.0));\n  return col;\n}\nvec3 perspective_camera(vec3 lookfrom, vec3 lookat, float tilt, float vfov, vec2 uv) {\n  vec2 sc = sincos(tilt);\n  vec3 vup = normalize(vec3(sc.x, sc.y, 0.0));\n  vec3 w = normalize((lookat - lookfrom));\n  vec3 u = cross(w, vup);\n  vec3 v = cross(u, w);\n  float wf = (1.0 / tan(((vfov * 3.14159265) / 360.0)));\n  return normalize((((uv.x * u) + (uv.y * v)) + (wf * w)));\n}\nfloat expstep(float x, float k) {\n  return exp(((k * x) - k));\n}\nvec3 get_background(vec3 rd) {\n  vec3 sun_dir = vec3(0.0, 0.0, 1.0);\n  float sun_dif = dot(rd, sun_dir);\n  vec3 col = (vec3(1.0, 0.9, 0.9) * expstep(sun_dif, 600.0));\n  col = (col + (vec3(1.0, 1.0, 0.1) * expstep(sun_dif, 100.0)));\n  col = (col + (vec3(1.0, 0.7, 0.7) * expstep(sun_dif, 50.0)));\n  col = (col + (vec3(1.0, 0.6, 0.05) * expstep(sun_dif, 10.0)));\n  return col;\n}\nvec3 color_tonemap_aces(vec3 col) {\n  return clamp(((col * ((2.51 * col) + 0.03)) / ((col * ((2.43 * col) + 0.59)) + 0.14)), 0.0, 1.0);\n}\nvec3 color_saturate(vec3 col, float sat) {\n  float grey = dot(col, vec3(0.2125, 0.7154, 0.0721));\n  return (grey + (sat * (col - grey)));\n}\nvec3 color_tone_1(vec3 col, float gain, float lift, float invgamma) {\n  col = pow(col, vec_tovec3(invgamma));\n  return (((gain - lift) * col) + lift);\n}\nvec3 color_gamma_correction(vec3 col) {\n  return pow(col, vec_tovec3(0.454545455));\n}\nvec3 vignette(vec3 col, vec2 coord, float strength, float amount) {\n  return (col * ((1.0 - amount) + (amount * pow(((((16.0 * coord.x) * coord.y) * (1.0 - coord.x)) * (1.0 - coord.y)), strength))));\n}\nvec3 dither(vec3 col, vec2 coord, float amount) {\n  return clamp((col + (noise_noise_white_1(coord) * amount)), 0.0, 1.0);\n}\nvec3 sun_glare(vec3 rd) {\n  vec3 sun_dir = vec3(0.0, 0.0, 1.0);\n  vec3 glare_col = vec3(1.0, 0.6, 0.2);\n  return (glare_col * pow(max(dot(sun_dir, rd), 0.0), 2.0));\n}\nvoid mainImage(out vec4 frag_col, in vec2 frag_coord) {\n  vec2 res = vec2(iResolution.x, iResolution.y);\n  vec2 mouse = vec2((iMouse.x / iResolution.x), (iMouse.y / iResolution.y));\n  vec2 coord = ((2.0 * (frag_coord - (res * 0.5))) / iResolution.y);\n  float theta = ((1.88495559 + (iTime * 0.2)) + (6.28318531 * mouse.x));\n  vec3 lookat = vec3(0.0, 0.0, 0.0);\n  vec2 sc = (sincos(theta) * 2.0);\n  vec3 ro = vec3(sc.x, 0.5, sc.y);\n  vec3 rd = perspective_camera(ro, lookat, 0.0, 50.0, coord);\n  float t = sphere_intersect(ro, rd, vec3(0.0, 0.0, 0.0), 0.6);\n  vec3 p = (ro + (rd * t));\n  vec3 col = get_background(rd);\n  float depth = 0.0;\n  if(t >= 0.0) {\n    col = shade(rd, p);\n  \tdepth = smoothstep(2.0, 2.0-0.6, t);\n  }\n  col = (col + (0.2 * sun_glare(rd)));\n  col = color_tonemap_aces(col);\n  col = color_tone_1(col, 1.7, 0.002, 1.2);\n  col = color_saturate(col, 0.9);\n  col = color_gamma_correction(col);\n  col = vignette(col, (frag_coord / res), 0.25, 0.7);\n  col = dither(col, frag_coord, 0.01);\n  frag_col = vec4(col.x, col.y, col.z, depth);\n}\n\n\n/** SHADERDATA\n{\n\t\"title\": \"Lone Planet and the Sun\",\n\t\"description\": \"A solitary blue planet in space\",\n\t\"model\": \"person\"\n}\n*/", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/7s2GR3.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "7s2GWc", "name": "perlin_noise_8x", "author": "penghuailiang", "description": "8倍 perlin noise 纹理生成", "tags": ["perlinnoise"], "likes": 0, "viewed": 118, "date": "1618069020", "time_retrieved": "2024-06-20T20:36:22.385204", "image_code": "#define SCALE 8.\n\nvec3 random_perlin( vec3 p ) {\n    p = vec3(\n            dot(p,vec3(127.1,311.7,69.5)),\n            dot(p,vec3(269.5,183.3,132.7)), \n            dot(p,vec3(247.3,108.5,96.5)) \n            );\n    return -1.0 + 2.0*fract(sin(p)*43758.5453123);\n}\n\nfloat noise_perlin (vec3 p) {\n    vec3 i = floor(p);\n    vec3 s = fract(p);\n\n    // 3D网格有8个顶点\n    float a = dot(random_perlin(i),s);\n    float b = dot(random_perlin(i + vec3(1, 0, 0)),s - vec3(1, 0, 0));\n    float c = dot(random_perlin(i + vec3(0, 1, 0)),s - vec3(0, 1, 0));\n    float d = dot(random_perlin(i + vec3(0, 0, 1)),s - vec3(0, 0, 1));\n    float e = dot(random_perlin(i + vec3(1, 1, 0)),s - vec3(1, 1, 0));\n    float f = dot(random_perlin(i + vec3(1, 0, 1)),s - vec3(1, 0, 1));\n    float g = dot(random_perlin(i + vec3(0, 1, 1)),s - vec3(0, 1, 1));\n    float h = dot(random_perlin(i + vec3(1, 1, 1)),s - vec3(1, 1, 1));\n\n    // Smooth Interpolation\n    vec3 u = smoothstep(0.,1.,s);\n\n    // 根据八个顶点进行插值\n    return mix(mix(mix( a, b, u.x),\n                mix( c, e, u.x), u.y),\n            mix(mix( d, f, u.x),\n                mix( g, h, u.x), u.y), u.z);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = fragCoord.xy/iResolution.xy;\n    float c = noise_perlin(vec3(SCALE*uv, iTime));\n    vec3 color= vec3(c,c,c);\n    fragColor = vec4( color, 1.0 );\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/7s2GWc.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "7s2GWR", "name": "Simple Topdown Circular Waves", "author": "yinkar", "description": "Simple circular waves", "tags": ["wave", "water", "blue", "topdown"], "likes": 1, "viewed": 154, "date": "1617261953", "time_retrieved": "2024-06-20T20:36:22.385204", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{    \n    \n    vec2 uv = fragCoord/iResolution.xy;\n\tuv.x *= (iResolution.x / iResolution.y);\n\n\tvec3 color = vec3(0.0, 0.2, 0.5);\n\t\n\t\n\tif (mod(length(vec2(uv.x - 0.85, uv.y - 0.5)) - iTime / 9.0, 0.05) < \n        0.01 / length(vec2(uv.x - 0.85, uv.y - 0.5)) * 0.04) {\n\t\tcolor += 0.25;\n\t}\n\t\n\tfragColor = vec4( color, 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/7s2GWR.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "7s2SRz", "name": "Light in the Dark: Forked-RogerB", "author": "RogerB", "description": "Notable changes:\n- Smooth blending of water and other materials.\n- Performance improvements.\n- Increased delta for water normal to reduce artifacting.\n- Added some compositions featuring smooth blending.", "tags": ["raymarching", "sdf", "water", "bridge"], "likes": 1, "viewed": 165, "date": "1619611215", "time_retrieved": "2024-06-20T20:36:25.936637", "image_code": "// Raymarcher adapted from implementation by Inigo Quilez\n\n#define GAMMA_CORRECTION\n#define MOTION\n#define DISTANCE_FOG\n\n// Material aliases\n#define WATER 0\n#define LAMBERT_RED 1\n#define BLOB 2\n\n// Scene compositions.\n//#define COMPOSITION_0\n//#define COMPOSITION_1\n#define COMPOSITION_2\n\n// Camera Views\n//#define VIEW_0\n#define VIEW_1\n//#define MOUSE_CONTROL\n\n// Water Noise (NO NOISE -> 0, PERLIN -> 1, WORLEY -> 2, IQ -> 3)\n// Iq noise taken from https://www.shadertoy.com/view/4sS3zG.\n#define NOISE 1\n#define SINEWAVES\n\nconst float INFINITY = 99999999999999999.99f;\nconst float PI = 3.14159;\nconst float EPSILON = 0.0001f;\nconst float MIN_CLIP = 0.001f;\nconst float FAR_CLIP = 500.f;\nconst int RAY_STEPS = 256;\nconst int SHADOW_RAY_STEPS = 256;\n\nvec2 random2(vec2 p, float seed) {\n    return fract(sin(vec2(dot(p, vec2(127.1, 311.7)),\n                 dot(p, vec2(269.5,183.3))))\n                 * seed);\n}\n\nfloat noise2D(vec2 p, float seed){\n    p /= 20.f;\n    return fract(5.f * sin(dot(p, p) * seed) - p.y * cos(435.324 * seed * p.x));;\n}\n\nfloat worley(vec2 uv, float seed) {\n    uv *= 10.0; // Now the space is 10x10 instead of 1x1. Change this to any number you want.\n    vec2 uvInt = floor(uv);\n    vec2 uvFract = fract(uv);\n    float minDist = 1.0; // Minimum distance initialized to max.\n    for(int y = -1; y <= 1; ++y) {\n        for(int x = -1; x <= 1; ++x) {\n            vec2 neighbor = vec2(float(x), float(y)); // Direction in which neighbor cell lies\n            vec2 point = random2(uvInt + neighbor, seed); // Get the Voronoi centerpoint for the neighboring cell\n            vec2 diff = neighbor + point - uvFract; // Distance between fragment coord and neighbor’s Voronoi point\n            float dist = length(diff);\n            minDist = min(minDist, dist);\n        }\n    }\n    return minDist;\n}\n\nvec3 random3( vec3 p ) {\n    return fract(sin(vec3(dot(p,vec3(127.1, 311.7, 191.999)),\n                          dot(p,vec3(269.5, 183.3, 765.54)),\n                          dot(p, vec3(420.69, 631.2,109.21))))\n                 *43758.5453);\n}\n\nfloat noise3( vec3 p ) {\n    vec3 noise = fract(sin(vec3(dot(p,vec3(127.1, 311.7, 191.999)),\n                          dot(p,vec3(269.5, 183.3, 765.54)),\n                          dot(p, vec3(420.69, 631.2,109.21))))\n                 *43758.5453);\n    return max(noise.x, max(noise.y, noise.z));\n}\n\n\nfloat surflet(vec3 p, vec3 gridPoint) {\n    // Compute the distance between p and the grid point along each axis, and warp it with a\n    // quintic function so we can smooth our cells\n    vec3 t2 = abs(p - gridPoint);\n    vec3 t = vec3(1.f) - 6.f * pow(t2, vec3(5.f)) + 15.f * pow(t2, vec3(4.f)) - 10.f * pow(t2, vec3(3.f));\n    // Get the random vector for the grid point (assume we wrote a function random2\n    // that returns a vec2 in the range [0, 1])\n    vec3 gradient = random3(gridPoint).xyz * 2.f - vec3(1., 1., 1.);\n    // Get the vector from the grid point to P\n    vec3 diff = p - gridPoint;\n    // Get the value of our height field by dotting grid->P with our gradient\n    float height = dot(diff, gradient);\n    // Scale our height field (i.e. reduce it) by our polynomial falloff function\n    return height * t.x * t.y * t.z;\n}\n\nfloat perlinNoise3D(vec3 p) {\n    float surfletSum = 0.f;\n    // Iterate over the four integer corners surrounding uv\n    for(int dx = 0; dx <= 1; ++dx) {\n        for(int dy = 0; dy <= 1; ++dy) {\n            for(int dz = 0; dz <= 1; ++dz) {\n                surfletSum += surflet(p, floor(p) + vec3(dx, dy, dz));\n            }\n        }\n    }\n    return surfletSum;\n}\n\n\t\nfloat hash(vec2 p)\n{\n    p  = 50.0*fract( p*0.3183099);\n    return fract( p.x*p.y*(p.x+p.y) );\n}\n\nfloat iqNoise( in vec2 p )\n{\n    vec2 i = floor( p );\n    vec2 f = fract( p );\n\t\n\tvec2 u = f*f*(3.0-2.0*f);\n\n    return -1.0+2.0*mix( mix( hash( i + vec2(0.0,0.0) ), \n                              hash( i + vec2(1.0,0.0) ), u.x),\n                         mix( hash( i + vec2(0.0,1.0) ), \n                              hash( i + vec2(1.0,1.0) ), u.x), u.y);\n}\n\nconst mat2 m2 = mat2( 0.80, -0.60, 0.60, 0.80 );\n\nfloat almostIdentity( float x, float m, float n )\n{\n    if( x>m ) return x;\n    float a = 2.0*n - m;\n    float b = 2.0*m - 3.0*n;\n    float t = x/m;\n    return (a*t + b)*t*t + n;\n}\n\nfloat almostAbs( float x )\n{\n    return almostIdentity(abs(x), 0.05, 0.025 );\n}\n\nfloat iqNoiseLayered( vec2 p )\n{\n    vec2 q = 0.05*p;\n\tfloat f = 0.0;\n    f += 0.50000*almostAbs(iqNoise( q )); q = m2*q*2.02; q -= 0.1*iTime;\n    f += 0.25000*almostAbs(iqNoise( q )); q = m2*q*2.03; q += 0.2*iTime;\n    f += 0.12500*almostAbs(iqNoise( q )); q = m2*q*2.01; q -= 0.4*iTime;\n    f += 0.06250*almostAbs(iqNoise( q )); q = m2*q*2.02; q += 1.0*iTime;\n    f += 0.03125*almostAbs(iqNoise( q ));\n    return 3.7-4.0*f;\n}\n\nbool equals(float a, float b){\n    return abs(a - b) < EPSILON;\n}\n\nbool equalsmargin(float a, float b, float m){\n    return abs(a - b) < m;\n}\n\nvec2 smin(float a, float b, float k){\n    float h = max( k-abs(a-b), 0.0 )/k;\n    float m = h*h*h*0.5;\n    float s = m*k*(1.0/3.0); \n    return (a<b) ? vec2(a-s,m) : vec2(b-s,1.0-m);\n}\n\n// Because the above implementation of smin doesn't work with k=0.\nvec2 hardMin(float a, float b) {\n    return (a<b) ? vec2(a, 0) : vec2(b, 1);\n}\n\nfloat isect( float d1, float d2, float k ) {\n    // float h = clamp( 0.5 - 0.5*(d2-d1)/k, 0.0, 1.0 );\n    // return mix( d2, d1, h ) + k*h*(1.0-h); \n    return -smin(-d1, -d2, k).x;\n}\n\nfloat sub(float d1, float d2, float k) {\n    return isect(d1, -d2, k);\n}\n\nvec3 repeat(vec3 pos, float cx, float cy, float cz){\n    return vec3(mod(pos.x + 0.5f * cx, cx) - 0.5f * cx,\n                mod(pos.y + 0.5f * cy, cy) - 0.5f * cy,\n                mod(pos.z + 0.5f * cz, cz) - 0.5f * cz);\n}\n\nvec3 rotateY(vec3 p, float a) {\n    return vec3(cos(a) * p.x + sin(a) * p.z, p.y, -sin(a) * p.x + cos(a) * p.z);\n}\n\nvoid computeray (vec3 eye, vec3 ref, vec2 ndc, float fov, out vec3 ro, out vec3 rd)\n{\n    vec3 look = ref - eye;\n    \n    float len = tan(fov * PI/180.f) * distance(eye, ref);\n    \n    vec3 v, h;\n    h = normalize(cross(vec3(0.0, 1.0, 0.0), ref - eye));\n    v = normalize(cross(h, look));;\n\n    h *= len * iResolution.x/iResolution.y;\n    v *= len;\n    \n    vec3 p = ref + ndc.x * h + ndc.y * v;\n            \n    p = ref + ndc.x * h + ndc.y * v;\n        \n    ro = eye;\n    rd = normalize(p - eye);\n}\n\nfloat infinite_plane_sdf(vec3 pos, float y){\n    return pos.y - y;\n}\n\nfloat sphere_sdf (vec3 ro, vec3 p, float r){\n    return length(ro - p) - r;\n}\n\nfloat box_sdf(vec3 ro, vec3 p, vec3 b, float r)\n{\n    vec3 q = abs(ro - p) - b;\n    return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0) - r;\n}\n\nfloat cylinder_sdf(vec3 ro, vec3 p, float ra, float rb, float h )\n{\n  vec2 d = vec2( length(ro.xz - p.xz)-2.0*ra+rb, abs(ro.y - p.y) - h );\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0)) - rb;\n}\n\nfloat vert_cylinder_sdf(vec3 ro, vec3 p, float r, float h){\n    float s0 = box_sdf(ro, vec3(0.f, 1.f, 0.f) + p, vec3(r, 2.f * r, h), 0.1f);\n    float s1 = sphere_sdf(ro, vec3(0.f, 0.f, 0.f) + p, r);\n    return isect(s0, s1, 0.1f);\n\n}\n\nfloat arch_sdf(vec3 ro, vec3 p, float r1, float r2, float t){\n    float s0 = vert_cylinder_sdf(ro, p, r1, t);\n    float s1 = vert_cylinder_sdf(ro, p, r2, 2.f * t);\n    float d1 = sub(s0, s1, 0.1f);\n    return d1;\n}\n\nfloat steps_sdf(vec3 ro, vec3 p, vec3 dim, int steps, int axis, int dir){\n    float d = INFINITY;\n    for (int i = 0; i < steps; i++){\n        float cur_step;\n        if (axis == 0){\n            cur_step = box_sdf(ro, vec3(dim.z * float(i) * float(dir) * 0.8f, 2.f * dim.y * float(i), 0.f) + p, dim, 0.1f);\n        } else if (axis == 1){\n            cur_step = box_sdf(ro, vec3(0.f, 2.f * dim.y * float(i), dim.x * float(i) * float(dir) * 0.8f) + p, dim.zyx, 0.1f);\n        }\n        d = min(cur_step, d);\n    }\n    return d;\n}\n\nfloat full_steps_sdf(vec3 ro, vec3 p, vec3 dim, int steps, int axis, int dir){\n    float d = INFINITY;\n    for (int i = 1; i < steps; i++){\n        float cur_step;\n        if (axis == 0){\n            cur_step = box_sdf(ro, vec3(dim.z * float(i) * float(dir), dim.y * float(i), 0.f) + p, vec3(dim.x, 2.f * float(i) * dim.y, dim.z), 0.1f);\n        } else if (axis == 1){\n            cur_step = box_sdf(ro, vec3(0.f, 2.f * dim.y * float(i), dim.x * float(i) * float(dir)) + p, vec3(dim.z, dim.y, dim.x), 0.1f);\n        }\n        d = min(cur_step, d);\n    }\n    return d;\n}\n\nvec3 map(vec3 p){\n    float aTime = iTime/2.f;\n    \n    //BRIDGE\n    vec3 q = repeat(p, 12.f , 0.f, 0.f);\n    float a0 = arch_sdf(q, vec3(0.f), 7.f, 5.f, 2.f);\n    float a1 = arch_sdf(q, vec3(0.f), 8.f, 6.f, 1.5f);\n    float d0 = sub(a0, a1, 0.2f);\n    \n    \n    // FLOATING BLOBS\n    vec3 qs1 = repeat(p, 40.f, 0.f, 40.f);\n    vec3 qs2 = repeat(p, 10.f, 0.f, 10.f);\n    float f = 5.f;\n    float hf = 15.5f * cos(p.z/40.f);\n    vec3 h0 = vec3(f * cos(iTime/4.f), 15.f + (sin(p.x) + cos(p.z)) * sin(iTime) - hf * (sin(p.x/20.f) + cos(p.z/20.f)) * cos(iTime), f * sin(iTime/2.f));\n    vec3 h1 = vec3(5.f + -f * cos(iTime/4.f), 20.f + (sin(p.x) + cos(p.z)) * sin(iTime) + hf * (cos(p.x/20.f) + sin(p.z/20.f)) * sin(iTime), 5.f + -f * sin(iTime/2.f));\n    float s0 = sphere_sdf(qs1, h0, 3.5f);\n    float s1 = sphere_sdf(qs1, h1, 3.5f);\n    float d1 = smin(s0 * 0.5f, s1 * 0.5f, 2.f).x;\n    \n    \n    // WATER\n    float plane_noise = 2.f;\n    #ifdef SINEWAVES\n    plane_noise += 1.f *(cos(p.x/10.f - cos(iTime)) + sin(p.z/15.f + sin(iTime))) * ((sin(iTime/5.f) + 1.1f)*0.5);\n    plane_noise -= 1.;\n    #endif\n    \n    #if NOISE == 0\n    // nop\n    #elif NOISE == 1\n    // plane_noise += (perlinNoise3D(p) * (sin(iTime/5.f) + 1.1f) * 0.5f);\n    // plane_noise += (perlinNoise3D(p) *  0.2f);\n    // plane_noise += (perlinNoise3D(p) * (sin(iTime/5.f) + 1.1f) * 0.1f);\n    // plane_noise += perlinNoise3D(vec3(p.x, 0., p.z)) * (sin(iTime/5.f) + 1.1f) * 0.1f; // 2D perlin noise is about 3x as fast to march through, but doesn't look as good.\n    // plane_noise += perlinNoise3D(vec3(p.x, iTime, p.z)) * (sin(iTime/5.f) + 1.1f) * 0.1f; // Using the time as the third component makes it look better, while still being 2D noise within a single frame so we keep the performance benefits. At least, we should but we don't for some reason.\n    // Shifting the noise over time is both fast and looks alright, however.\n    vec3 qWater = p + vec3(-iTime*3., 0., sin(iTime/(1.62*3.))*5.);\n    plane_noise += perlinNoise3D(vec3(qWater.x, 0., qWater.z)) * (sin(iTime/5.f) + 1.1f) * 0.1f;\n    #elif NOISE == 2\n    plane_noise += ((worley(p.xz/10.f, abs(sin(iTime) * cos(iTime/2.f)))) * (sin(iTime/5.f) + 1.1f) * 0.3f);\n    #elif NOISE == 3\n    // plane_noise += iqNoiseLayered(p.xz) * (sin(iTime/5.f) + 1.1f) * 0.5f;\n    plane_noise += iqNoiseLayered(p.xz) * 0.2f;\n    #endif\n    \n    float d2 = infinite_plane_sdf(p, plane_noise);\n    \n    \n    // COMPOSITION\n    // x: distance, y: material, z: water mask. (Water mask is used for mixing in the reflection term.)\n    vec3 res;\n    \n    #ifdef COMPOSITION_0\n    // In this block, water and blobs merge and the bridge is independent.\n    res.xz = smin(d1, d2, 3.f);\n    res.y = res.z < 1. ? float(BLOB) : float(WATER);\n\n    vec2 bridge_res;\n    bridge_res = hardMin(res.x, d0);\n    res.x = bridge_res.x;\n    res.y = bool(bridge_res.y) ? float(LAMBERT_RED) : res.y;\n    res.z = bool(bridge_res.y) ? 0. : res.z;\n    #endif\n    \n    #ifdef COMPOSITION_1\n    // In this block, blobs and the bridge merge with the water but not eachother.\n    vec3 bridge_water;\n    bridge_water.xz = smin(d0, d2, 1.);\n    bridge_water.y = float(LAMBERT_RED);\n    \n    vec3 blob_water;\n    blob_water.xz = smin(d1, d2, 3.);\n    blob_water.y = float(BLOB);\n    \n    res = bridge_water.x < blob_water.x ? bridge_water : blob_water;\n    res.y = res.z < 1. ? res.y : float(WATER); // For when water reflects into more water.\n    #endif\n    \n    #ifdef COMPOSITION_2\n    // Same as composition 1 but the blobs deform around the bridge.\n    vec3 bridge_water;\n    bridge_water.xz = smin(d0, d2, 1.);\n    bridge_water.y = float(LAMBERT_RED);\n    \n    float expanded_bridge = d0 - 1.;\n    float blob = d1;\n    //blob = smin(blob, expanded_bridge, 10.).x; // Make the far side of the blob smush away from the bridge; disabled because of artefacts where the bridge is close to the water.\n    blob = sub(blob, expanded_bridge, 2.); // Avoid the bridge instead of going through it.\n    \n    vec3 blob_water;\n    blob_water.xz = smin(blob, d2, 3.);\n    blob_water.y = float(BLOB);\n    \n    res = bridge_water.x < blob_water.x ? bridge_water : blob_water;\n    res.y = res.z < 1. ? res.y : float(WATER); // For when water reflects into more water.\n    #endif\n    \n    // TODO: add ability to smoothly blend all three materials, then make a scene that does that.\n    \n    return res;\n}\n\nvec3 calcNormal(in vec3 pos, float eps){\n    // Central differences approach.\n    // 6s compile time because of over-eager compiler inlining.\n    /*\n    vec2 e = vec2(eps, 0.f);\n    return normalize(vec3(map(pos + e.xyy).x - map(pos - e.xyy).x,\n                          map(pos + e.yxy).x - map(pos - e.yxy).x,\n                          map(pos + e.yyx).x - map(pos - e.yyx).x));\n    */\n    \n    \n    // Tetrahedron approach from https://www.iquilezles.org/www/articles/normalsSDF/normalsSDF.htm.\n    vec3 n = vec3(0.0);\n    for(int i=min(iFrame,0); i<4; i++) {\n        vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);\n        n += e*map(pos+eps*e).x;\n    }\n    return normalize(n);\n    \n    \n    // Below this point are implementations of inlining-resistant central difference algorithms.\n    // I started messing with them because the tetahedron approach was causing black artefacts\n    // on the underside bridge corners. (But it turns out I had just accidentally set epsilon an\n    // order of magnitude higher than intended in one of the calls.)\n    // The below implementations aren't used any more, but I think they're interesting enough to keep.\n    \n    \n    // Inlining-resistant central differences.\n    // 3s compile time because two map calls get inlined.\n    // Follows the sprit of the inlining-resistant tertrahedron approach, but I haven't seen this implementation elsewhere.\n    /*\n    vec3 n = vec3(0.0);\n    for(int i=min(iFrame,0); i<3; i++) {\n        vec3 e = vec3(((i+3)>>1)&1,(i>>1)&1,i&1);\n        n += e*map(pos+eps*e).x - e*map(pos-eps*e).x;\n    }\n    return normalize(n);\n    */\n\n\n    // Inlining-resistant central differences mk. 2.\n    // 2s compile time with the single inlined map call.\n    // This should be equivalent to mk. 1, but it isn't. (I notice it as banding in the water reflection in the smooth part of the water cycle.) I'm not currently sure why.\n    /*\n    vec3 n = vec3(0.0);\n    for(int i=min(iFrame,0); i<6; i++) {\n        float signBit = float(i&1);\n        int j = i >> 1;\n        vec3 e = signBit * vec3(((j+3)>>1)&1,(j>>1)&1,j&1);\n        n += e*map(pos+eps*e).x;\n    }\n    return normalize(n);\n    */\n    \n    \n    // It's worth noting that the central differences approaches aren't much more expensive at runtime than the tetrahedron approach.\n    // (Not a lot of the total time is spent calculating normals.)\n}\n\nvec3 grad(vec3 pos, float eps) {\n    vec3 n = vec3(0.0);\n    for(int i=min(iFrame,0); i<4; i++) {\n        vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);\n        n += e*map(pos+eps*e).x;\n    }\n    return n;\n}\n\nfloat shadowcast_pointlight(in vec3 ro, in vec3 rd, in float light_dist){\n    float res = 1.f;\n    float t = MIN_CLIP;\n    light_dist = min(light_dist, FAR_CLIP);\n    for (int i = 0; i < SHADOW_RAY_STEPS; i++){\n        t = min(t, light_dist);\n        vec3 pos = ro + rd * t;\n        float sdf = map(pos).x;\n        // Soft shadows were causing heavy banding on the blobs from the point light sources.\n        // The reason was that the \"distance function\" wasn't exact.\n        // We can fix this by using a first-order Taylor series approximation for the true distance function.\n        // (https://www.iquilezles.org/www/articles/distance/distance.htm)\n        // Nevermind, there's something else at play here, too. Also, computing the gradient during the shadow step is expensive.\n        // float dist = sdf / length(grad(pos, 0.01));\n        float dist = sdf * 50.;\n        res = min(res, 0.2 * dist/t);\n        t += sdf;\n        if (t >= light_dist || res < 0.001) break;\n    }\n    return res;\n}\n\n/*\nfloat shadowcast_pointlight(in vec3 ro, in vec3 rd, in float light_dist){\n    light_dist = min(light_dist, FAR_CLIP);\n    float res = 1.f;\n    float t = MIN_CLIP;\n    float ph = 1e20;\n    for (int i = 0; i < RAY_STEPS; i++){\n        vec3 pos = ro + rd * t;\n        float h = map(pos).x;\n        \n        float y = h*h/(2.*ph);\n        float d = sqrt(h*h-y*y);\n        res = min(res, 10.f * d/max(0., t-y));\n        ph = h;\n        t += h;\n\n        if (res < 0.0001 || t > light_dist){\n            break;\n        }\n    }\n    return res;\n}\n*/\n\nfloat shadowcast(in vec3 ro, in vec3 rd){\n    return shadowcast_pointlight(ro, rd, FAR_CLIP);\n}\n\nfloat raycast(in vec3 ro, in vec3 rd, out vec2 mat){\n    float t = MIN_CLIP;\n    mat = vec2(-1, 0);\n    for (int i = 0; i < RAY_STEPS; i++){\n        vec3 pos = ro + rd * t;\n        vec3 sdf = map(pos);\n        float dist = sdf.x;\n        mat = sdf.yz;\n        if (abs(dist) < 0.0001f){\n            return t;\n        }\n        if (t > FAR_CLIP){\n            return -1.f;\n        }\n        t += dist;\n    }\n    return t;\n}\n\nvec3 calcmaterial(vec3 pos, vec3 nor, int mat){\n        vec3 col = vec3(0.f);        \n        \n        // ambient light parameters\n        vec3 sky_light = vec3(0.f, 0.1f, 0.3f) * clamp(0.5f + 0.5f * nor.y, 0.f, 1.f);\n        \n        // light parameters\n        float aTime = iTime/2.f;\n        #ifdef MOTION\n        vec3 light_pos = vec3(7.f * sin(aTime) - iTime , 7.f, 7.f * cos(aTime));\n        #else\n        vec3 light_pos = vec3(7.f * sin(aTime) , 7.f, 7.f * cos(aTime));\n        #endif\n        vec3 light_dir = normalize(light_pos - pos);\n        vec3 lambert_light = vec3(0.8f, 0.6f, 0.2f) * clamp(dot(nor, light_dir), 0.f, 1.f);\n        //vec3 lambert_light = vec3(0.8f, 0.6f, 0.2f);\n\n        #ifdef MOTION\n        vec3 light2_pos = vec3(-7.f * cos(aTime) - iTime, 7.f, -7.f * sin(aTime));\n        #else\n        vec3 light2_pos = vec3(-7.f * cos(aTime), 7.f, -7.f * sin(aTime));\n        #endif\n        vec3 light2_dir = normalize(light2_pos - pos);\n        vec3 lambert_light2 = vec3(0.8f, 0.2f, 0.01f) * clamp(dot(nor, light2_dir), 0.f, 1.f);\n        //vec3 lambert_light2 =vec3(0.8f, 0.2f, 0.01f);\n        \n\n        // bounce light (fake GI)\n        vec3 bounce_light = vec3(0.1f, 0.05f, 0.02f) * clamp(0.5f - 0.5f * nor.y, 0.f, 1.f);\n        \n        float light1_dist = distance(light_pos, pos);\n        float light2_dist = distance(light2_pos, pos);\n        // float t_shadow1 = shadowcast_pointlight(pos, light_dir, light1_dist) / (light1_dist*light1_dist);\n        // float t_shadow2 = shadowcast_pointlight(pos, light2_dir, light2_dist) / (light2_dist*light2_dist);\n        float t_shadow1 = shadowcast_pointlight(pos, light_dir, light1_dist);\n        float t_shadow2 = shadowcast_pointlight(pos, light2_dir, light2_dist);\n         //t_shadow = 1.f;\n                \n        vec3 base_colour;\n        \n        switch(mat){\n            case WATER:\n            base_colour = vec3(0.f, 0.1f, 0.3f) * 0.05f;\n            break;\n            case LAMBERT_RED:\n            // vec2 textureIndex = mix(pos.xy, pos.xz, 0.5);\n            // vec2 textureIndex = vec2(pos.x, pos.y+pos.z);\n            // base_colour  = texture(iChannel0, textureIndex.xy/4.f).xyz;\n            \n            if (abs(nor.y) > abs(nor.z)){\n                base_colour  = texture(iChannel0, pos.xz/4.f).xyz;\n            } else {\n                base_colour  = texture(iChannel0, pos.xy/4.f).xyz;\n            }\n            \n            base_colour *= vec3(0.9f, 0.2f, 0.4f);\n            break;\n            case BLOB:\n            base_colour = vec3(1.f, 0.4f, 0.3f);\n            break;\n        }\n        \n        // final colour evaluation\n        vec3 sum_light = vec3(0);\n        sum_light = lambert_light * t_shadow1 * 2.;\n        sum_light += lambert_light2 * t_shadow2 * 2.;\n        \n        sum_light += sky_light;\n        sum_light += bounce_light;\n        \n        return base_colour * sum_light;\n        //return sum_light;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized device coordinates (from -1 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 ndc = vec2((2.f * uv.x) - 1.f, 1.f - (2.f * uv.y)); \n    \n    \n    // camera variance variable\n    #ifdef MOUSE_CONTROL\n    float u = 20.f * iMouse.x/iResolution.x;\n    float v = PI/2.f * iMouse.y/iResolution.y;\n    #endif\n    \n    // Camera parameters\n    #ifdef MOUSE_CONTROL\n    float d = 20.f;\n    float aTime = iTime/2.f;\n    vec3 eye = vec3(d * cos(u), 30.f * abs(sin(v)), d * sin(u));\n    vec3 ref = vec3(0.f, 0.f, 0.f);\n    #endif\n    \n    #ifdef VIEW_0\n    float d = 20.f;\n    float aTime = iTime/2.f;\n    vec3 eye = vec3(d, 7.5f, 0.f);\n    vec3 ref = vec3(0.f, 0.f, 0.f);\n    #endif\n    \n    #ifdef VIEW_1\n    float d = 20.f;\n    float aTime = iTime/2.f;\n    vec3 eye = vec3(0.f, 5.f, d);\n    vec3 ref = vec3(0.f, 0.f, 0.f);\n    #endif\n    \n    #ifdef MOTION\n    #ifndef VIEW_1\n    vec3 motion = vec3(-iTime, abs(sin(iTime)), 0.f);\n    #else\n    vec3 motion = vec3(-iTime, 0.f, 0.f);\n    #endif\n    eye += motion;\n    ref.x += motion.x;\n    #endif\n    float fov = 45.f;\n    \n    vec3 ro , rd;\n    computeray(eye, ref, ndc, fov, ro, rd);\n        \n    #ifdef DISTANCE_FOG\n    vec3 skyCol = mix(vec3(0.f, 0.1f, 0.3f) * 0.3f, vec3(0.f, 0.1f, 0.3f) * 0.f, abs(ndc.y * 1.25f));     \n    #else\n    vec3 skyCol = vec3(0.f);\n    #endif\n    vec3 col = skyCol;\n    vec2 mat = vec2(-1.f, 0.f);\n    float t = raycast(ro, rd, mat);\n    \n    // TODO: Clean this up to handle the water more nicely. (With less duplicated logic.)\n    if (t > 0.f){\n        vec3 pos = ro + t * rd;\n        \n        vec3 initialNorm = calcNormal(pos, 0.01f);\n        vec3 initialCol = calcmaterial(pos, initialNorm, int(round(mat.x)));    \n        // Add a water reflection. Blend it using the water mask stored in mat.y.\n        if (mat.y > 0.){\n            vec3 ro_new = pos;\n            vec3 rd_new = reflect(rd, initialNorm);\n            vec2 mat_new;\n            float t_new = raycast(ro_new, rd_new, mat_new);\n            \n            vec3 reflectedCol;\n            if (t_new > 0.) {\n                // pos = ro_new + t_new*rd_new;\n                // t = min(t + t_new, FAR_CLIP);\n                // mat = mat_new;\n                vec3 pos_new = ro_new + t_new*rd_new;\n                \n                vec3 reflectedNorm = calcNormal(pos_new, 0.01f);\n                reflectedCol = calcmaterial(pos_new, reflectedNorm, int(round(mat_new.x)));\n                // reflectedCol = calcmaterial(pos_new, reflectedNorm, BLOB);\n            } else {\n                // TODO: This is probably wrong, since the sky is non-uniform.\n                reflectedCol = skyCol;\n            }\n            reflectedCol *= 0.35; // Dampen the water reflection.\n            col = mix(initialCol, reflectedCol, mat.y);\n        } else {\n            col = initialCol;\n        }\n        // TODO: Apply these separately to initialCol and reflectedCol.\n        col *= 1.f - pow(t/FAR_CLIP, 2.f) * vec3(0.8f, 0.8f, 0.6f);\n        #ifdef DISTANCE_FOG\n        col += vec3(0.f, 0.1f, 0.3f) * 0.25f * (t/FAR_CLIP) * (t/FAR_CLIP) ;\n        #endif\n    }\n    \n    #ifdef GAMMA_CORRECTION\n    // Gamma correction - https://www.youtube.com/watch?v=Cfe5UQ-1L9Q&t=1990s - 38:00\n    col = pow(col, vec3(0.4545f));\n    #endif\n    \n    // Output to screen\n    fragColor = vec4(col,t);\n}", "image_inputs": [{"id": "4dXGRn", "previewfilepath": "/media/ap/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/7s2SRz.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "7s2XRW", "name": "electronebula", "author": "Del", "description": "nebula effect - left mouse for alternate", "tags": ["voronoi", "fbm", "nebula"], "likes": 7, "viewed": 221, "date": "1619808984", "time_retrieved": "2024-06-20T20:36:26.445603", "image_code": "// electric nebula effect\n//#define PROCEDURAL_HASH\n\n#ifdef PROCEDURAL_HASH\nvec3 hash33(vec3 p)\n{\n    const float UIF = (1.0/ float(0xffffffffU));\n    const uvec3 UI3 = uvec3(1597334673U, 3812015801U, 2798796415U);\n    uvec3 q = uvec3(ivec3(p)) * UI3;\n\tq = (q.x ^ q.y ^ q.z)*UI3;\n\treturn vec3(q) * UIF;\n}\n#else\nvec3 hash33( vec3 x )\n{\n\treturn texture( iChannel0, (x.xy+vec2(3.0,1.0)*x.z+0.5)/256.0, -100.0 ).xyz;\n}\n#endif\n\n\n// 3D Voronoi- (IQ)\nfloat voronoi(vec3 p){\n\n\tvec3 b, r, g = floor(p);\n\tp = fract(p);\n\tfloat d = 1.; \n\tfor(int j = -1; j <= 1; j++)\n    {\n\t    for(int i = -1; i <= 1; i++)\n        {\n\t\t    b = vec3(i, j, -1);\n\t\t    r = b - p + hash33(g+b);\n\t\t    d = min(d, dot(r,r));\n\t\t    b.z = 0.0;\n\t\t    r = b - p + hash33(g+b);\n\t\t    d = min(d, dot(r,r));\n\t\t    b.z = 1.;\n\t\t    r = b - p + hash33(g+b);\n\t\t    d = min(d, dot(r,r));\n\t    }\n\t}\n\treturn d;\n}\n\n// fbm layer\nfloat noiseLayers(in vec3 p) {\n\n    vec3 pp = vec3(0., 0., p.z + iTime*.05);\n    float t = 0.;\n    float s = 0.;\n    float amp = 1.;\n    for (int i = 0; i < 5; i++)\n    {\n        t += voronoi(p + pp) * amp;\n        p *= 2.;\n        pp *= 1.5;\n        s += amp;\n        amp *= .5;\n    }\n    return t/s;\n}\n\nmat2 rot( float th ){ vec2 a = sin(vec2(1.5707963, 0) + th); return mat2(a, -a.y, a.x); }\n#define TWO_PI 6.2831853\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = (fragCoord.xy - 0.5 * iResolution.xy) / iResolution.y;\n    float dd = length(uv*uv)*0.125;\n    \n\tvec3 rd = normalize(vec3(uv.x, uv.y, 3.141592/8.));\n    rd.xy *= rot(dd-iTime*.025);\n\t\n\tfloat c = noiseLayers(rd*2.25);\n    float oc = c;\n    c = max(c + dot(hash33(rd)*2. - 1., vec3(.006)), 0.);\n    c = pow(c*1.35,3.5);    \n    \n    \n    vec3 col =  vec3(0.55,0.8,0.35);\n    vec3 col2 =  vec3(.85,0.85,1.4)*2.0;\n\n    if (iMouse.z>0.5)\n    {\n        col =  vec3(0.35,0.75,1.2);\n        col2 =  vec3(2.15,1.15,0.28)*8.0;\n    }\n    \n    \n    float pulse2 = voronoi(vec3((rd.xy*1.5),iTime*.255));\n    float pulse = pow(oc*1.35,4.0);\n    //pulse = clamp(pulse,0.0,2.0);\n    col = mix(col,col2,pulse*pulse2)*c;\n    //col=vec3(pulse2);\n    \n    fragColor = vec4(sqrt(col),1.0);\n}", "image_inputs": [{"id": "Xsf3zn", "previewfilepath": "/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/7s2XRW.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "7sB3Dy", "name": "Fractal 51_gaz", "author": "gaz", "description": "fractal", "tags": ["fractal"], "likes": 21, "viewed": 377, "date": "1617923054", "time_retrieved": "2024-06-20T20:36:26.445603", "image_code": "#define R(p,a,r)mix(a*dot(p,a),p,cos(r))+sin(r)*cross(p,a)\n#define H(h)(cos((h)*6.3+vec3(0,23,21))*.5+.5)\nvoid mainImage(out vec4 O, vec2 C)\n{\n    O=vec4(0);\n    vec3 p,r=iResolution,\n    d=normalize(vec3((C-.5*r.xy)/r.y,1));  \n    for(float i=0.,s,e,g=0.;\n        ++i<70.;\n        O.xyz+=mix(vec3(1),H(log(s)*.3),.6)*.03*exp(-.2*i*i*e)\n    )\n    {\n        p=g*d-vec3(0,0,1.5);\n        p=R(p.zxy,normalize(vec3(1,0,10)),iTime*.3);\n        s=2.;\n        for(int i;i++<6;)\n            p=abs(p-vec3(1,2.8,1.5+sin(iTime*.5)*.2))-vec3(1,3.+sin(iTime*.7)*.3,2.1),\n            p*=(fract(iTime*.1)>.5)?-1.:1.,\n            s*=e=7./clamp(dot(p,p),1.2,7.),\n            p*=e;\n        g+=e=min(abs(p.z),length(p.xy)-.05)/s+1e-3;\n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/7sB3Dy.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "7sB3WK", "name": "Voronoi in Lp space", "author": "tomoe", "description": "Left: 2D, Center: 2D+rotation, Right: 3D\nfork from [url=https://www.shadertoy.com/view/NsB3WG]Voronoi[/url] and [url=https://www.shadertoy.com/view/sdB3WK]Lp space[/url]", "tags": ["bd202104"], "likes": 2, "viewed": 56, "date": "1617954255", "time_retrieved": "2024-06-20T20:36:26.445603", "image_code": "vec2 fragCoord_;\nuvec3 k = uvec3(0x456789abu, 0x6789ab45u, 0x89ab4567u);\nconst uint max32 = 0xffffffffu;\nconst float PI = 3.14159265359;\nuvec2 hash22u(uvec2 n) {  \n    n ^= (n.yx << 24);\n    n ^= (n.yx >> 1);\n    n *= k.xy;\n    n ^= (n.yx << 1);\n    return n * k.xy;\n}\nuvec3 hash33u(uvec3 n) {\n    n ^= (n.yzx << 24);\n    n ^= (n.yzx >> 1);\n    n *= k;\n    n ^= (n.yzx << 1);\n    return n * k;\n}\nmat2 rot2(float t) {\n    return mat2(cos(t), sin(t), -sin(t),  cos(t));\n}\nmat3 rotX(float t){\n    return mat3(\n        1.,0.,0.,\n        0.,sin(t),cos(t),\n        0.,-cos(t),sin(t)\n    );\n}\nvec2 hash22(vec2 p) {\n    uvec2 n = uvec2(p);\n    return vec2(hash22u(n)) / vec2(max32);\n}\nvec3 hash33(vec3 p) {\n    uvec3 n = uvec3(p);\n    return vec3(hash33u(n)) / vec3(max32);\n}\nfloat length2(vec2 p, float d) {\n    p = abs(p);\n    return pow(p.x, d) + pow(p.y, d);\n}\nfloat length3(vec3 p, float d) {\n    p = abs(p);\n    return pow(p.x, d) + pow(p.y, d) + pow(p.z, d);\n}\nvec2 voronoi2(vec2 p, float d){   \n    vec2 n = round(p);\n    vec2 f = p - round(p);\n    float dist = length2(abs(f) + 0.5, d);\n    vec2 sgn = vec2(1.0);\n    vec2 glid = vec2(0.0);\n    vec2 ind;\n    for(float j = 0.0; j <= 2.0; j ++ ) {\n        glid.y += sgn.y * j;\n        sgn.y *= -1.0;\n        if (pow(max(abs(glid.y - f.y) - 0.5, 0.0), d) > dist){\n            continue;\n        }\n        for(float i = 0.0; i <= 2.0; i ++ ){\n            glid.x += sgn.x * i;\n            sgn.x *= -1.0;\n            vec2 nbd = glid;\n            if(fragCoord_.x < 0.33 * iResolution.x){\n                nbd += hash22(n + nbd) - 0.5; \n            } else {\n                nbd += rot2(iTime) * (hash22(n + nbd) - 0.5)/sqrt(2.0);\n            }\n            if(length2(nbd - f, d) < dist){\n                ind = n + glid;\n                dist = length2(nbd - f, d);\n            }\n        }\n        glid.x = 0.0;\n    }\n    return ind;\n}\nvec3 voronoi3(vec3 p, float d){   \n    vec3 n = round(p);\n    vec3 f = p - round(p);\n    float dist = length3(abs(f) + 0.5, d);\n    vec3 sgn = vec3(1.0);\n    vec3 glid = vec3(0.0);\n    vec3 ind;\n    for(float k = 0.0; k <= 2.0; k ++ ) {\n            glid.z += sgn.z * k;\n            sgn.z *= -1.0;\n            if (pow(max(abs(glid.z - f.z) - 0.5, 0.0), d) > dist){\n                continue;\n            }\n        for(float j = 0.0; j <= 2.0; j ++ ) {\n            glid.y += sgn.y * j;\n            sgn.y *= -1.0;\n            if (pow(max(abs(glid.y - f.y) - 0.5, 0.0), d) > dist){\n                continue;\n            }\n            for(float i = 0.0; i <= 2.0; i ++ ){\n                glid.x += sgn.x * i;\n                sgn.x *= -1.0;\n                vec3 nbd = glid + hash33(n + glid) -0.5;\n                if(length3(nbd - f, d) < dist){\n                    ind = n + glid;\n                    dist = length3(nbd - f, d);\n                }\n            }\n            glid.x = 0.0;\n        }\n        glid.y = 0.0;\n    }\n    return ind;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    fragCoord_ = fragCoord;\n    vec2 pos = fragCoord.xy/ iResolution.xx;\n    pos *= 10.0;\n    pos += iTime;\n    vec3 v;\n    float d = 4.0 * sin(0.5 * iTime)  + 5.0;\n    if(fragCoord.x < 0.66 * iResolution.x){\n        v = vec3(hash22(voronoi2(pos, d)), 1.0);  //left\n    } else {\n        v = hash33(voronoi3(vec3(pos, 0.5 * iTime), d));   //right\n    }\n    fragColor = vec4(vec3(v), 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/7sB3WK.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "7sB3zc", "name": "John", "author": "SnoopethDuckDuck", "description": "e", "tags": ["cool"], "likes": 1, "viewed": 40, "date": "1617734016", "time_retrieved": "2024-06-20T20:36:26.694104", "image_code": "float random (vec2 st) {\n    return fract(sin(dot(st.xy,\n                         vec2(12.9898,78.233)))*\n        43758.5453123);\n}\n\nconst float pi = 3.1415;\nconst float pi2 = 1. * pi / 6.;\nconst float pi3 = 2. * pi / 6.;\n\nfloat osc(float a)\n{\nreturn 0.5 * (1. + cos(a));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   vec2 uv = fragCoord/iResolution.xy;\nvec2 dir = uv.xy - 0.5;\nfloat ad = length(dir);\n\nfloat theta = atan( dir.y,dir.x);\n//dir += 0.08 * random(vec2(length(dir),length(dir)));\nfloat k = 1. / (1000. * length(dir));\nfloat r = 0.05 * length(dir);\nfloat d = (1. + 0.25 * cos(0.2 * iTime)) * 0.00015 / sqrt(k * k + r *r);\n\nfloat b = osc(0.8 * iTime);\nfloat b2 = osc(0.8 * iTime + pi2);\nfloat b3 = osc(0.8 * iTime + pi3);\n\nfloat val = cos(b *  sin(3.* theta - iTime) + 10. * theta + (d + 1.) * (iTime + 3000.));\nfloat val2 = cos(b2 * sin(3. * theta - iTime + pi2) + 10. * theta + (d+1.) *  (iTime + 3000.) );\nfloat val3 = cos(b3 *sin(3. * theta - iTime + pi3) + 10. * theta + (d + 1.) *(iTime + 3000.) );\n    // Time varying pixel color\n    vec3 col = (1. -ad * ad )  * random(vec2(0.0001* d,0.0001 * d)) * \n    vec3(\n    smoothstep(0.02,val, sqrt(val2 * val2 + val3 * val3)), \n    smoothstep(0.02,val2, sqrt( val * val + val3 * val3)),\n    smoothstep(0.02,val3, sqrt( val2 * val2 + val * val)));\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/7sB3zc.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "7sB3zt", "name": "door", "author": "szkiw", "description": "my first pt", "tags": ["pt"], "likes": 7, "viewed": 84, "date": "1617895935", "time_retrieved": "2024-06-20T20:36:26.694104", "image_code": "#define PI 3.1415926535f\nfloat calculateDistanceToIntersection(\n\tout vec3 outNormal,\n\tconst vec3 rayOrigin,\n\tconst vec3 rayDirection,\n\tconst float rayLength,\n\tconst vec3 triangleVertex0,\n\tconst vec3 triangleVertex1,\n\tconst vec3 triangleVertex2){\n\tvec3 v01 = triangleVertex1 - triangleVertex0;\n\tvec3 v12 = triangleVertex2 - triangleVertex1;\n\tvec3 n = normalize(cross(v01, v12));\n\tfloat denom = dot(rayDirection, n);\n\tfloat t = dot(triangleVertex0 - rayOrigin, n) / denom;\n\tif(t < 0.0f || rayLength < t){\n\t\treturn -1.0f;\n\t}\n\tvec3 x = rayOrigin + rayDirection * t;\n\tif(dot(cross(v01, x - triangleVertex0), n) < 0.0f){\n\t\treturn -1.0f;\n\t}\n\tif(dot(cross(v12, x - triangleVertex1), n) < 0.0f){\n\t\treturn -1.0f;\n\t}\n\tif(dot(cross(triangleVertex0 - triangleVertex2, x - triangleVertex2), n) < 0.0f){\n\t\treturn -1.0f;\n\t}\n\toutNormal = n;\n\treturn t;\n}\nvec3 vs[16];\nuvec3 ts[18];\nvoid traceRay_(\n\tout float outDistance,\n\tout vec3 outNormal,\n\tout vec3 outReflectance,\n\tout vec3 outEmission,\n\tconst vec3 rayOrigin,\n\tconst vec3 rayDirection){\n\tconst float rayLength = 10000.0f;\n\tfloat closestD = rayLength;\n\tvec3 closestN = vec3(0.0f, 1.0f, 0.0f);\n\tfor(int i = 0; i < 18; ++i){\n\t\tuvec3 t = ts[i];\n\t\tvec3 n;\n\t\tfloat d = calculateDistanceToIntersection(\n        \tn, rayOrigin, rayDirection, closestD, vs[t.x], vs[t.y], vs[t.z]);\n\t\tif(0.0f <= d){\n\t\t\tclosestD = d;\n\t\t\tclosestN = n;\n\t\t}\n\t}\n\tif(closestD < rayLength){\n\t\toutDistance = closestD;\n\t\toutNormal = (0.0f < dot(rayDirection, closestN)) ? -closestN : closestN;\n\t\toutReflectance = vec3(0.95f);\n\t\toutEmission = vec3(0.0f);\n\t}else{\n\t\toutDistance = -1.0f;\n\t\toutNormal = closestN;\n\t\toutReflectance = vec3(0.0f);\n\t\t//sky\n\t\tfloat t = (rayDirection.y + 1.0f) * 0.5f;\n\t\toutEmission = (1.0f - t) * vec3(1.0f) + t * vec3(0.25f, 0.49f, 1.0f);\n        outEmission *= 2.0f;\n\t}\n}\nfloat calculateRandom(const vec2 uv, const vec2 offset){\n\treturn fract(sin(dot(uv, vec2(12.9898f, 78.233f) + offset)) * 43758.5453123f);\n}\nvec3 calculateColor(\n\tconst vec3 rayOrigin, const vec3 rayDirection, const int tryIndex,\n    const vec2 uv)\n{\n\tvec3 attenuation = vec3(1.0f);\n\tvec3 color = vec3(0.0f);\n\tvec3 ro = rayOrigin;\n\tvec3 rd = rayDirection;\n\tfor(int i = 0; i < 4; ++i){\n\t\tfloat d;\n\t\tvec3 n;\n\t\tvec3 r;\n\t\tvec3 e;\n\t\ttraceRay_(d, n, r, e, ro, rd);\n\t\tcolor += e * attenuation;\n\t\tattenuation *= r;\n\t\tif(d < 0.0f){\n\t\t\tbreak;\n\t\t}else{\n\t\t\tro += rd * d;\n\t\t\t//diffuse\n\t\t\t{\n\t\t\t\tfloat r1 = 2.0f * PI * calculateRandom(uv, vec2(0.135f, -0.335f) * float(i + tryIndex));\n\t\t\t\tfloat r2 = calculateRandom(uv, vec2(0.397f, 0.7131f) * float(i * 3 + tryIndex * 5));\n\t\t\t\tfloat r2s = sqrt(r2);\n\t\t\t\tvec3 u;\n\t\t\t\tu = cross((0.1f < abs(n.x)) ? vec3(0.0f, 1.0f, 0.0f) : vec3(1.0f, 0.0f, 0.0f), n);\n\t\t\t\tu = normalize(u);\n\t\t\t\tvec3 v;\n\t\t\t\tv = cross(n, u);\n\t\t\t\tvec3 d;\n\t\t\t\td = u * cos(r1) * r2s;\n\t\t\t\td += v * sin(r1) * r2s;\n\t\t\t\td += n * sqrt(1.0f - r2);\n\t\t\t\td = normalize(d);\n\t\t\t\trd = d;\n\t\t\t}\n\t\t\tro += rd * 0.001f;\n\t\t}\n\t}\n\treturn color;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 uv = vec3(fragCoord / iResolution.xy, 1.0f);\n\tvec3 rayDirection;\n    vec3 rayOrigin;\n    vec4 doorTransforms[2];\n    int count = int(iTime * 30.0f);\n    {\n        rayDirection.x = dot(vec3(0.1056740f, 0.0012600135f, -0.013103187f), uv);\n        rayDirection.y = dot(vec3(-0.2151858e-9f, 0.064909114f, -0.037252731f), uv);\n        rayDirection.z = dot(vec3(0.046684937f, -0.0028521137f, -0.1132823f), uv);\n        rayOrigin = vec3(-2.5776574f, 1.6850278f, -5.0421361f) + rayDirection;\n        rayDirection = normalize(rayDirection);\n        float rad = (sin(float(count & 0x1ff) / 511.0f * PI * 4.0f) * 0.5f + 0.5f) * PI * 0.75f;\n        float c = cos(rad);\n        float s = sin(rad);\n        vec3 p = vec3(5.0f, -0.1f, -12.549999f);\n        doorTransforms[0] = vec4(c, 0.0f, s, -p.x * c - p.z * s + p.x);\n        doorTransforms[1] = vec4(-s, 0.0f, c, p.x * s - p.z * c + p.z);\n\t}\n\tvs[0] = vec3(-5.0f, -0.10f, 5.0f);\n\tvs[1] = vec3(-5.0f, -0.10f, -15.0f);\n\tvs[2] = vec3(5.0f, -0.10f, 5.0f);\n\tvs[3] = vec3(5.0f, -0.10f, -15.0f);\n\tvs[4] = vec3(-5.0f, 3.90f, 5.0f);\n\tvs[5] = vec3(-5.0f, 3.90f, -15.0f);\n\tvs[6] = vec3(5.0f, 3.90f, 5.0f);\n\tvs[7] = vec3(5.0f, 3.90f, -15.0f);\n\tvs[8] = vec3(5.0f, -0.10f, -12.549999f);\n\tvs[9] = vec3(5.0f, -0.10f, -13.750f);\n\tvs[10] = vec3(5.0f, 1.90f, -12.549999f);\n\tvs[11] = vec3(5.0f, 1.90f, -13.750f);\n\tvs[12] = vec3(5.0f, -0.10f, -12.549999f);\n\tvs[13] = vec3(4.1514706f, -0.10f, -11.701471f);\n\tvs[14] = vec3(5.0f, 1.90f, -12.549999f);\n\tvs[15] = vec3(4.1514706f, 1.90f, -11.701471f);\n\tts[0] = uvec3(6, 10, 7);\n\tts[1] = uvec3(5, 4, 7);\n\tts[2] = uvec3(0, 3, 1);\n\tts[3] = uvec3(2, 3, 0);\n\tts[4] = uvec3(7, 3, 5);\n\tts[5] = uvec3(5, 1, 4);\n\tts[6] = uvec3(7, 4, 6);\n\tts[7] = uvec3(5, 3, 1);\n\tts[8] = uvec3(4, 1, 0);\n\tts[9] = uvec3(11, 9, 3);\n\tts[10] = uvec3(7, 11, 3);\n\tts[11] = uvec3(7, 10, 11);\n\tts[12] = uvec3(10, 2, 8);\n\tts[13] = uvec3(6, 2, 10);\n\tts[14] = uvec3(14, 12, 15);\n\tts[15] = uvec3(15, 12, 13);\n\tts[16] = uvec3(4, 0, 6);\n\tts[17] = uvec3(6, 0, 2);\n\tfor(int i = 12; i <= 15; ++i){//rotate door\n\t\tvec4 t = vec4(vs[i - 4], 1.0f);\n\t\tvs[i].x = dot(doorTransforms[0], t);\n\t\tvs[i].z = dot(doorTransforms[1], t);\n\t}\n\tint spp = 8;\n\tvec3 c = vec3(0.0f);\n\tfor(int i = 0; i < spp; ++i){\n\t\tc += calculateColor(rayOrigin, rayDirection, i + count, uv.xy);\n\t}\n\tfragColor.xyz = c * 1.0f / float(spp);\n\tfragColor.xyz = pow(fragColor.xyz, vec3(1.0f / 2.2f));\n\tfragColor.w = 1.0f;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/7sB3zt.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "7sBGWt", "name": "Cloth Shading with  Ashikhmin", "author": "hummingbird", "description": "Cloth shading with Ashikhmin shading model", "tags": ["sdf", "ashikhmin", "clothshading"], "likes": 0, "viewed": 77, "date": "1618093234", "time_retrieved": "2024-06-20T20:36:26.700204", "image_code": "#define PI 3.14159265358979\n\nstruct Camera{\n\tvec3 origin;\n    vec3 target;\n    vec3 up;\n    float vfov;\n    float focal_length;\n    float aspect_ratio;\n};\n    \n    \n\nfloat unionSDF(float distA, float distB) {\n    return min(distA, distB);\n}\n\nfloat smoothUnionSDF( float d1, float d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); }\n\nfloat differenceSDF(float distA, float distB) {\n    return max(distA, -distB);\n}\n\nfloat sphereSDF(vec3 p, vec3 center, float radius){\n\treturn length(p- center) - radius;\n}\n\nfloat torusSDF(  vec3 p,  vec3 center, float innerRadius, float ringWidth )\n{\n  vec3 pos = p - center;\n  vec2 q = vec2(length(pos.xy)-innerRadius,pos.z);\n  return length(q)-ringWidth;\n}\n\n\n\nfloat planeSDF(vec3 p, vec3 normal, float height){\n\treturn dot(p, normal)-height;\n\n}\n\n\nfloat sceneSDF(vec3 p){\n   float plane = planeSDF(p, vec3(0.0, 1.0, 0.0),-1.0);\n   float sphere = sphereSDF(p, vec3(0.0, 2.0, 0.5), 1.0);\n   float leftEar = sphereSDF(p, vec3(0.8, 2.5, 0.5), .6);\n   float rightEar = sphereSDF(p, vec3(-0.8, 2.5, 0.5), .6);\n   float torusArch = torusSDF(p, vec3(0.0,2,0.0), 2.0, 0.5);\n   \n   float final = smoothUnionSDF(sphere, leftEar,.1);\n   final =smoothUnionSDF(final, rightEar,.1);\n   final = smoothUnionSDF(final, torusArch, .2);\n   final = smoothUnionSDF(final, plane,.1);\n   \n   \n\n   return final;\n}\n\n\nfloat softshadow( in vec3 ro, in vec3 rd,  float k )\n{\n    float res = 1.0;\n    float h = 0.0;\n    float t = 0.1;\n   for(int i = 0; i<50; i++)\n    {\n        \n        h = sceneSDF(ro + rd*t);\n        if( h<0.01 )\n            return 0.0;\n        res = min( res, k*h/t );\n        if(t>=200.0){\n        \treturn res;\n        }\n        t+=h;\n        \n    }\n    return res;\n}\n\n\n\n\nvec3 getSceneNormal(vec3 p){\n\treturn normalize(vec3(sceneSDF(vec3(p.x+0.0001,p.y,p.z)) -sceneSDF(vec3(p.x-0.0001,p.y,p.z)),\n                               sceneSDF(vec3(p.x,p.y+0.0001,p.z)) -sceneSDF(vec3(p.x,p.y-0.0001,p.z)),\n                               sceneSDF(vec3(p.x,p.y,p.z+0.0001)) -sceneSDF(vec3(p.x,p.y,p.z-0.0001))                 \n                              ));\n}\n\nmat4 getViewMatrix(Camera cam){\n\tvec3 f = normalize(cam.target - cam.origin);\n    vec3 r = normalize(cross(f, cam.up));\n    vec3 u = normalize(cross(r, f));\n    \n    return mat4(\n    \tvec4(r,0.0),\n        vec4(u,0.0),\n        vec4(f,0.0),\n        vec4(cam.origin.x,cam.origin.y,cam.origin.z,1.0)\n    );\n\n}\n\nvec3 getCameraRay(vec2 uv, Camera cam){\n    float half_height = tan(radians(cam.vfov/2.0));\n    float half_width = half_height*cam.aspect_ratio; \n    vec3 lower_left = vec3(-half_width, -half_height, cam.focal_length);\n    vec4 view_plane_point = vec4(lower_left + vec3(2.0*half_width,0.0,0.0)*uv.x+vec3(0.0,2.0*half_height,0.0)*uv.y,1.0);\n    view_plane_point = getViewMatrix(cam)*view_plane_point;\n    return normalize(view_plane_point.xyz-cam.origin);\n    \n}\n\n// map from 0 -  255 to 0 - 1\nvec3 normalizedRGB(vec3 rgb){\n\treturn vec3(rgb/255.0);\n}\n\nfloat AshikhminD(float roughness, float ndoth)\n{\n    float m2    = roughness * roughness;\n    float cos2h = ndoth * ndoth;\n    float sin2h = 1. - cos2h;\n    float sin4h = sin2h * sin2h;\n    return (sin4h + 4. * exp(-cos2h / (sin2h * m2))) / (PI * (1. + 4. * m2) * sin4h);\n}\n \nfloat AshikhminV(float ndotv, float ndotl)\n{\n    return 1. / (4. * (ndotl + ndotv - ndotl * ndotv));\n}\n\nvec3 fresnelSchlick(float cosTheta, vec3 F0)\n{\n    return F0 + (1.0 - F0) * pow(max(1.0 - cosTheta, 0.0), 5.0);\n}  \n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\t\n    \n    // screen UV\n    vec2 uv = fragCoord / iResolution.xy;\n    // fragColor = vec4(uv.x, uv.y, 0.0,1.0);\n   \n    float aspect_ratio = iResolution.x / iResolution.y;\n    vec3 horizontal = vec3(2.0 * aspect_ratio,0.0,0.0);\n    vec3 vertical = vec3(0.0,2.0,0.0);\n    vec3 lower_left = vec3(-horizontal.x/2.0,-vertical.y/2.0,1.0);\n    \n    // setup camera\n    Camera cam;\n    cam.origin = vec3(cos(iTime*0.5)*10.0,2.0,sin(iTime*0.5)*10.0);\n   //\tcam.origin = vec3(0,5.0,-10);\n    cam.target = vec3(0.0,5.0,0.0);\n    cam.up = vec3(0.0,1.0,0.0);\n    cam.vfov = 60.0;\n    cam.focal_length = 1.0;\n    cam.aspect_ratio = aspect_ratio;\n    \n    // render sky\n    fragColor.xyz = vec3(0.0);\n   \n    // render scene\n    vec3 rayDir = getCameraRay(uv, cam);\n    vec3 p = cam.origin;\n    vec3 lightPos = vec3(2.0, 3.0, 5.0);\n    \n    \n    for(int i=0;i<250;i++){\n        float d = sceneSDF(p);\n        p = p+rayDir*d;\n        if(d<.001){\n            vec4 finalColor = vec4(0.0,0.0,0.0,1.0);\n            vec3 albedo = vec3(.18,.18,.18);\n            vec3 F0 = vec3(1.00, 0.71, 0.29);\n            vec3 lightColor = vec3(1.0,1.0,1.0);\n            vec3 ambient = vec3(0.2,0.1,0.2);\n            vec3 N = getSceneNormal(p);\n           \tvec3 L = normalize(lightPos- p);\n            vec3 E = normalize(cam.origin-p);\n            vec3 H = normalize(L+E);\n            \n            float NdotH = max(dot(N,H), 0.0);\n            float NdotL = max(dot(N, L),0.0);\n            float NdotV = max(dot(N, E),0.0);\n            \n            vec3 diffuse = albedo * NdotL;\n            \n            float d =  AshikhminD(0.5, NdotH);\n            float v = AshikhminV(NdotV, NdotL);\n            vec3 f = fresnelSchlick(NdotV, F0);\n            vec3 specular = lightColor * f * d * v * PI * NdotL;\n            \n            float shadowAtan = softshadow(p+(N*0.1), normalize(lightPos), 16.0);\n            finalColor.xyz = (diffuse  + specular)*shadowAtan+ ambient;\n            finalColor.xyz = pow(finalColor.xyz, vec3(1.0/ 2.2));\n           \n       \n        \tfragColor = finalColor;\n            return;\n        }\n    \n    } \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/7sBGWt.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "7sBGWy", "name": "12344321", "author": "yeperob", "description": "12344321", "tags": ["12344321"], "likes": 2, "viewed": 73, "date": "1617879135", "time_retrieved": "2024-06-20T20:36:26.815375", "image_code": "#define time iTime*0.15 \n#define tau 6.2831853\nmat2 makem2(in float theta){float c = cos(theta);float s = sin(theta);return mat2(c,-s,s,c);}float noise( in vec2 x ){return texture(iChannel0, x*.01).x*10.;}\nfloat fbm(in vec2 p){float z=2.;float rz = 0.;vec2 bp = p;for (float i= 1.;i < 6.;i++)  {rz+= abs((noise(p)-0.5)*2.)/z;z = z*2.;p = p*2.;}return rz;}\nfloat dualfbm(in vec2 p){vec2 p2 = p*.7;vec2 basis = vec2(fbm(p2-time*1.6),fbm(p2+time*1.7));basis = (basis-.5)*.2;p += basis;return fbm(p*makem2(time*0.2));}\nfloat circ(vec2 p){float r = length(p);r = log(sqrt(r));return abs(mod(r*4.,tau)-3.14)*3.+.2;}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){vec2 p = fragCoord.xy / iResolution.xy;p.x *= iResolution.x/iResolution.y; p*=3.; vec2 p2 = fragCoord.xy / iResolution.xy-(iMouse.xy/iResolution.xy);p2.x *= iResolution.x/iResolution.y;p2*=3.;float rz = dualfbm(p);p2 /= exp(mod(time*20.,3.14159));rz *= pow(abs((0.1-circ(p2))),.9);float time_color=time*2.; vec3 col = vec3(abs(cos(time_color)),abs(1.-cos(time_color)),abs(sin(time_color)))/rz;col=pow(abs(col),vec3(.99));col =  col;fragColor = vec4(col,1.);}", "image_inputs": [{"id": "4dXGzr", "previewfilepath": "/media/ap/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/7sBGWy.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "7sBSRz", "name": "Simple test level flyby", "author": "mzsolt", "description": "I am working on a voxel based fps and thought of exporting a simple test level to prototype surface shaders.\nThis is just a basic flyby of a level I made for testing my simple lightmap code https://youtu.be/Qjur3U.\nThe prototyping can start from here. :)", "tags": ["flyby", "cga"], "likes": 4, "viewed": 178, "date": "1619546911", "time_retrieved": "2024-06-20T20:36:29.033695", "image_code": "// Based on Ray-Box intersection, by iq. https://www.shadertoy.com/view/ld23DV\n\n// http://iquilezles.org/www/articles/boxfunctions/boxfunctions.htm\nvec4 iBox( in vec3 ro, in vec3 rd, in mat4 txx, in mat4 txi, in vec3 rad ) \n{\n    // convert from ray to box space\n\tvec3 rdd = (txx*vec4(rd,0.0)).xyz;\n\tvec3 roo = (txx*vec4(ro,1.0)).xyz;\n\n\t// ray-box intersection in box space\n    vec3 m = 1.0/rdd;\n    vec3 n = m*roo;\n    vec3 k = abs(m)*rad;\n\t\n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n\n\tfloat tN = max( max( t1.x, t1.y ), t1.z );\n\tfloat tF = min( min( t2.x, t2.y ), t2.z );\n\t\n\tif( tN > tF || tF < 0.0) return vec4(-1.0);\n\n\tvec3 nor = -sign(rdd)*step(t1.yzx,t1.xyz)*step(t1.zxy,t1.xyz);\n\n    // convert to ray space\n\t\n\tnor = (txi * vec4(nor,0.0)).xyz;\n\n\treturn vec4( tN, nor );\n}\n\n\n// http://iquilezles.org/www/articles/boxfunctions/boxfunctions.htm\nfloat sBox( in vec3 ro, in vec3 rd, in mat4 txx, in vec3 rad ) \n{\n\tvec3 rdd = (txx*vec4(rd,0.0)).xyz;\n\tvec3 roo = (txx*vec4(ro,1.0)).xyz;\n\n    vec3 m = 1.0/rdd;\n    vec3 n = m*roo;\n    vec3 k = abs(m)*rad;\n\t\n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n\n\tfloat tN = max( max( t1.x, t1.y ), t1.z );\n\tfloat tF = min( min( t2.x, t2.y ), t2.z );\n\tif( tN > tF || tF < 0.0) return -1.0;\n\t\n\treturn tN;\n}\n\n\n//-----------------------------------------------------------------------------------------\n\nmat4 rotationAxisAngle( vec3 v, float angle )\n{\n    float s = sin( angle );\n    float c = cos( angle );\n    float ic = 1.0 - c;\n\n    return mat4( v.x*v.x*ic + c,     v.y*v.x*ic - s*v.z, v.z*v.x*ic + s*v.y, 0.0,\n                 v.x*v.y*ic + s*v.z, v.y*v.y*ic + c,     v.z*v.y*ic - s*v.x, 0.0,\n                 v.x*v.z*ic - s*v.y, v.y*v.z*ic + s*v.x, v.z*v.z*ic + c,     0.0,\n\t\t\t     0.0,                0.0,                0.0,                1.0 );\n}\n\nmat4 translate( float x, float y, float z )\n{\n    return mat4( 1.0, 0.0, 0.0, 0.0,\n\t\t\t\t 0.0, 1.0, 0.0, 0.0,\n\t\t\t\t 0.0, 0.0, 1.0, 0.0,\n\t\t\t\t x,   y,   z,   1.0 );\n}\n/*\nmat4 inverse( in mat4 m )\n{\n\treturn mat4(\n        m[0][0], m[1][0], m[2][0], 0.0,\n        m[0][1], m[1][1], m[2][1], 0.0,\n        m[0][2], m[1][2], m[2][2], 0.0,\n        -dot(m[0].xyz,m[3].xyz),\n        -dot(m[1].xyz,m[3].xyz),\n        -dot(m[2].xyz,m[3].xyz),\n        1.0 );\n}*/\n\nstruct BoxData\n{\n\tvec3 pos;\n\tvec3 siz;\n\tint ty;\n};\n\nstruct LightData\n{\n\tvec3 pos;\n\tvec3 col;\n\tfloat r;\n};\n\nstruct CamPosData\n{\n\tvec3 pos;\n\tvec3 tgt;\n};\n\nBoxData bd[99] = BoxData[99](\n    BoxData(vec3(5.000000,1.500000,-49.500000), vec3(8.000000,0.500000,10.500000), 3),\n    BoxData(vec3(12.500000,3.000000,-49.500000), vec3(0.500000,1.000000,10.500000), 3),\n    BoxData(vec3(4.500000,3.000000,-59.500000), vec3(7.500000,1.000000,0.500000), 3),\n    BoxData(vec3(8.500000,3.500000,-55.500000), vec3(1.500000,1.500000,0.500000), 4),\n    BoxData(vec3(8.500000,3.500000,-54.500000), vec3(1.500000,1.500000,0.500000), 4),\n    BoxData(vec3(7.500000,2.500000,-49.500000), vec3(1.500000,0.500000,0.500000), 4),\n    BoxData(vec3(8.500000,6.500000,-55.000000), vec3(0.500000,1.500000,1.000000), 4),\n    BoxData(vec3(9.500000,3.000000,-39.500000), vec3(2.500000,1.000000,0.500000), 3),\n    BoxData(vec3(7.500000,2.500000,-50.500000), vec3(0.500000,0.500000,0.500000), 4),\n    BoxData(vec3(7.500000,2.500000,-48.500000), vec3(0.500000,0.500000,0.500000), 4),\n    BoxData(vec3(7.500000,5.500000,-49.500000), vec3(0.500000,2.500000,0.500000), 4),\n    BoxData(vec3(6.500000,7.500000,-55.000000), vec3(1.500000,0.500000,1.000000), 4),\n    BoxData(vec3(3.500000,6.500000,-49.500000), vec3(3.500000,0.500000,0.500000), 4),\n    BoxData(vec3(1.500000,5.500000,-45.500000), vec3(0.500000,3.500000,0.500000), 4),\n    BoxData(vec3(1.000000,2.500000,-44.500000), vec3(1.000000,0.500000,0.500000), 4),\n    BoxData(vec3(0.500000,2.500000,-45.500000), vec3(0.500000,0.500000,0.500000), 4),\n    BoxData(vec3(7.500000,4.500000,-38.500000), vec3(0.500000,3.500000,0.500000), 3),\n    BoxData(vec3(7.500000,6.000000,-39.500000), vec3(0.500000,2.000000,0.500000), 3),\n    BoxData(vec3(4.500000,1.500000,-38.000000), vec3(2.500000,0.500000,1.000000), 3),\n    BoxData(vec3(6.500000,5.000000,-37.500000), vec3(0.500000,3.000000,0.500000), 3),\n    BoxData(vec3(4.500000,7.500000,-39.000000), vec3(2.500000,0.500000,1.000000), 3),\n    BoxData(vec3(5.500000,4.500000,-36.500000), vec3(0.500000,3.500000,0.500000), 3),\n    BoxData(vec3(3.500000,7.500000,-37.500000), vec3(2.500000,0.500000,0.500000), 3),\n    BoxData(vec3(2.500000,1.500000,-36.000000), vec3(2.500000,0.500000,1.000000), 3),\n    BoxData(vec3(4.500000,5.000000,-35.500000), vec3(0.500000,3.000000,0.500000), 3),\n    BoxData(vec3(2.500000,7.500000,-36.500000), vec3(2.500000,0.500000,0.500000), 3),\n    BoxData(vec3(3.500000,4.500000,-34.500000), vec3(0.500000,3.500000,0.500000), 3),\n    BoxData(vec3(1.500000,7.500000,-35.500000), vec3(2.500000,0.500000,0.500000), 3),\n    BoxData(vec3(0.500000,1.500000,-34.000000), vec3(2.500000,0.500000,1.000000), 3),\n    BoxData(vec3(-0.000000,3.000000,-39.500000), vec3(3.000000,1.000000,0.500000), 3),\n    BoxData(vec3(2.500000,4.500000,-38.500000), vec3(0.500000,2.500000,0.500000), 3),\n    BoxData(vec3(2.500000,5.000000,-33.500000), vec3(0.500000,3.000000,0.500000), 3),\n    BoxData(vec3(2.500000,5.500000,-39.500000), vec3(0.500000,1.500000,0.500000), 3),\n    BoxData(vec3(0.500000,7.500000,-34.500000), vec3(2.500000,0.500000,0.500000), 3),\n    BoxData(vec3(1.500000,4.000000,-37.500000), vec3(0.500000,3.000000,0.500000), 3),\n    BoxData(vec3(1.500000,4.500000,-32.500000), vec3(0.500000,3.500000,0.500000), 3),\n    BoxData(vec3(-0.500000,7.500000,-33.500000), vec3(2.500000,0.500000,0.500000), 3),\n    BoxData(vec3(-1.500000,1.500000,-28.000000), vec3(2.500000,0.500000,5.000000), 3),\n    BoxData(vec3(0.500000,4.500000,-36.500000), vec3(0.500000,2.500000,0.500000), 3),\n    BoxData(vec3(-1.500000,7.500000,-28.000000), vec3(2.500000,0.500000,5.000000), 3),\n    BoxData(vec3(0.500000,4.500000,-27.500000), vec3(0.500000,2.500000,4.500000), 3),\n    BoxData(vec3(0.500000,4.500000,-22.500000), vec3(0.500000,3.500000,0.500000), 1),\n    BoxData(vec3(-2.000000,2.500000,-21.500000), vec3(3.000000,0.500000,0.500000), 1),\n    BoxData(vec3(0.500000,5.500000,-21.000000), vec3(0.500000,2.500000,1.000000), 1),\n    BoxData(vec3(-2.000000,4.500000,-19.500000), vec3(3.000000,0.500000,0.500000), 1),\n    BoxData(vec3(0.500000,6.500000,-16.500000), vec3(0.500000,1.500000,3.500000), 1),\n    BoxData(vec3(-0.000000,0.500000,-1.500000), vec3(8.000000,0.500000,9.500000), 3),\n    BoxData(vec3(7.500000,2.500000,-1.500000), vec3(0.500000,1.500000,9.500000), 1),\n    BoxData(vec3(-0.500000,1.500000,-10.500000), vec3(7.500000,0.500000,0.500000), 1),\n    BoxData(vec3(-0.500000,2.500000,-10.500000), vec3(7.500000,0.500000,0.500000), 1),\n    BoxData(vec3(5.500000,3.500000,-10.500000), vec3(1.500000,0.500000,0.500000), 1),\n    BoxData(vec3(4.500000,6.000000,-7.500000), vec3(0.500000,5.000000,2.500000), 1),\n    BoxData(vec3(4.500000,7.500000,-10.500000), vec3(0.500000,3.500000,0.500000), 1),\n    BoxData(vec3(-0.500000,5.500000,-8.000000), vec3(4.500000,0.500000,3.000000), 1),\n    BoxData(vec3(1.500000,7.000000,-10.500000), vec3(2.500000,1.000000,0.500000), 1),\n    BoxData(vec3(0.500000,8.500000,-8.500000), vec3(0.500000,2.500000,1.500000), 1),\n    BoxData(vec3(3.500000,2.500000,-7.500000), vec3(0.500000,0.500000,0.500000), 2),\n    BoxData(vec3(3.500000,7.500000,-7.500000), vec3(0.500000,0.500000,0.500000), 2),\n    BoxData(vec3(-0.000000,3.000000,-0.500000), vec3(1.000000,1.000000,0.500000), 1),\n    BoxData(vec3(-0.000000,4.000000,-1.500000), vec3(1.000000,1.000000,0.500000), 1),\n    BoxData(vec3(-0.000000,5.000000,-2.500000), vec3(1.000000,1.000000,0.500000), 1),\n    BoxData(vec3(-0.000000,5.500000,-4.000000), vec3(1.000000,0.500000,1.000000), 1),\n    BoxData(vec3(3.500000,8.500000,-45.500000), vec3(0.500000,0.500000,1.500000), 4),\n    BoxData(vec3(2.500000,8.500000,-45.500000), vec3(0.500000,0.500000,0.500000), 4),\n    BoxData(vec3(2.500000,10.500000,-8.000000), vec3(1.500000,0.500000,3.000000), 1),\n    BoxData(vec3(0.500000,9.500000,-10.500000), vec3(0.500000,1.500000,0.500000), 1),\n    BoxData(vec3(-2.000000,10.500000,-6.000000), vec3(3.000000,0.500000,1.000000), 1),\n    BoxData(vec3(-0.500000,2.500000,7.500000), vec3(7.500000,1.500000,0.500000), 1),\n    BoxData(vec3(-0.000000,2.000000,0.500000), vec3(1.000000,1.000000,0.500000), 1),\n    BoxData(vec3(-0.000000,1.500000,1.500000), vec3(1.000000,0.500000,0.500000), 1),\n    BoxData(vec3(-2.500000,3.000000,-49.500000), vec3(0.500000,1.000000,9.500000), 3),\n    BoxData(vec3(-0.500000,4.000000,-35.500000), vec3(0.500000,3.000000,0.500000), 3),\n    BoxData(vec3(-1.500000,4.500000,-34.500000), vec3(0.500000,2.500000,0.500000), 3),\n    BoxData(vec3(-2.500000,4.000000,-33.500000), vec3(0.500000,3.000000,0.500000), 3),\n    BoxData(vec3(-3.500000,4.500000,-32.500000), vec3(0.500000,2.500000,0.500000), 3),\n    BoxData(vec3(-4.500000,4.500000,-27.500000), vec3(0.500000,3.500000,4.500000), 3),\n    BoxData(vec3(-2.500000,1.500000,-22.500000), vec3(2.500000,0.500000,0.500000), 1),\n    BoxData(vec3(-2.000000,3.500000,-20.500000), vec3(2.000000,0.500000,0.500000), 1),\n    BoxData(vec3(-2.500000,5.500000,-16.000000), vec3(2.500000,0.500000,3.000000), 1),\n    BoxData(vec3(-4.500000,5.000000,-22.500000), vec3(0.500000,3.000000,0.500000), 1),\n    BoxData(vec3(-4.500000,5.500000,-21.500000), vec3(0.500000,2.500000,0.500000), 1),\n    BoxData(vec3(-4.500000,6.000000,-20.500000), vec3(0.500000,2.000000,0.500000), 1),\n    BoxData(vec3(-4.500000,6.500000,-19.500000), vec3(0.500000,1.500000,0.500000), 1),\n    BoxData(vec3(-4.500000,7.000000,-16.000000), vec3(0.500000,1.000000,3.000000), 1),\n    BoxData(vec3(-0.500000,3.000000,-7.500000), vec3(0.500000,2.000000,2.500000), 1),\n    BoxData(vec3(-0.500000,4.000000,-10.500000), vec3(0.500000,1.000000,0.500000), 1),\n    BoxData(vec3(-2.000000,5.500000,-12.000000), vec3(2.000000,0.500000,1.000000), 1),\n    BoxData(vec3(-0.500000,7.000000,-12.000000), vec3(0.500000,1.000000,1.000000), 1),\n    BoxData(vec3(-3.500000,7.000000,-11.500000), vec3(0.500000,1.000000,1.500000), 1),\n    BoxData(vec3(-4.500000,3.000000,-7.500000), vec3(0.500000,2.000000,2.500000), 1),\n    BoxData(vec3(-6.000000,3.500000,-10.500000), vec3(2.000000,0.500000,0.500000), 1),\n    BoxData(vec3(-4.500000,4.500000,-10.500000), vec3(0.500000,0.500000,0.500000), 1),\n    BoxData(vec3(-4.500000,8.500000,-9.000000), vec3(0.500000,2.500000,2.000000), 1),\n    BoxData(vec3(-7.500000,2.500000,-1.500000), vec3(0.500000,1.500000,8.500000), 1),\n    BoxData(vec3(-3.500000,2.500000,-6.500000), vec3(0.500000,0.500000,0.500000), 2),\n    BoxData(vec3(-3.500000,7.500000,-6.500000), vec3(0.500000,0.500000,0.500000), 2),\n    BoxData(vec3(-4.500000,8.000000,-6.000000), vec3(0.500000,2.000000,1.000000), 1),\n    BoxData(vec3(-2.000000,10.500000,-9.000000), vec3(2.000000,0.500000,2.000000), 1),\n    BoxData(vec3(-7.500000,3.500000,8.500000), vec3(0.500000,0.500000,0.500000), 1)\n);\n\nLightData ld[9] = LightData[9](\n    LightData(vec3(2.500000,3.500000,-7.000000), vec3(1.000000,0.000000,1.000000), 5.000000),\n    LightData(vec3(-3.000000,3.500000,-7.000000), vec3(0.000000,1.000000,1.000000), 5.000000),\n    LightData(vec3(2.500000,8.500000,-7.000000), vec3(0.000000,0.400000,0.900000), 5.000000),\n    LightData(vec3(-3.000000,8.500000,-7.000000), vec3(0.900000,1.000000,0.100000), 5.000000),\n    LightData(vec3(-0.500000,6.000000,-25.000000), vec3(1.000000,1.000000,1.000000), 3.000000),\n    LightData(vec3(-0.500000,6.000000,-31.000000), vec3(1.000000,1.000000,1.000000), 3.000000),\n    LightData(vec3(-3.500000,6.000000,-25.000000), vec3(1.000000,1.000000,1.000000), 3.000000),\n    LightData(vec3(-3.500000,6.000000,-31.000000), vec3(1.000000,1.000000,1.000000), 3.000000),\n    LightData(vec3(-0.500000,6.000000,-34.000000), vec3(1.000000,1.000000,1.000000), 3.000000)\n);\n\nCamPosData cp[] = CamPosData[](\nCamPosData(vec3(-2.000000,1.900000,2.000000), vec3(-2.000000,1.900000,3.000000)),\nCamPosData(vec3(-2.000000,1.900000,2.000000), vec3(-2.009425,1.900000,2.999956)),\nCamPosData(vec3(-1.460000,1.932757,1.234773), vec3(-2.000350,1.986138,2.074519)),\nCamPosData(vec3(-2.892282,2.155061,4.702333), vec3(-3.393976,2.376269,3.866050)),\nCamPosData(vec3(-3.757271,2.518680,3.818990), vec3(-3.446917,2.773451,2.903145)),\nCamPosData(vec3(-2.996557,3.195341,-1.011240), vec3(-2.952601,3.170211,-2.009957)),\nCamPosData(vec3(-2.534242,3.074446,-5.956488), vec3(-2.518534,3.087013,-6.956285)),\nCamPosData(vec3(-2.454909,3.017715,-5.711578), vec3(-2.486197,3.105567,-6.707220)),\nCamPosData(vec3(-4.347242,1.910000,-1.520798), vec3(-3.867121,2.109710,-2.374964)),\nCamPosData(vec3(-2.655343,1.961232,-2.189268), vec3(-1.968674,1.983221,-2.915906)),\nCamPosData(vec3(0.351536,2.797791,-4.540000), vec3(0.495105,3.194939,-5.446455)),\nCamPosData(vec3(0.906096,3.366702,-8.691833), vec3(0.852952,3.272594,-9.685975)),\nCamPosData(vec3(2.417580,3.685781,-9.540000), vec3(2.268314,3.798638,-10.522335)),\nCamPosData(vec3(2.380995,3.726415,-8.059148), vec3(2.349808,3.845512,-9.051540)),\nCamPosData(vec3(1.174739,3.197919,-3.613107), vec3(1.143552,3.317016,-4.605499)),\nCamPosData(vec3(2.711044,2.775738,-1.441660), vec3(2.561009,2.825983,-2.429063)),\nCamPosData(vec3(1.808191,2.400199,2.925321), vec3(1.695948,2.651931,1.964055)),\nCamPosData(vec3(0.940645,2.854847,3.696516), vec3(0.828305,3.550760,2.987231)),\nCamPosData(vec3(0.217461,5.933011,-0.152619), vec3(0.004019,6.387001,-1.017682)),\nCamPosData(vec3(-0.834712,7.419567,-3.998655), vec3(-1.056111,7.579103,-4.960700)),\nCamPosData(vec3(-1.599242,7.553537,-7.580861), vec3(-1.792745,7.575527,-8.561714)),\nCamPosData(vec3(-2.184726,7.374053,-12.525115), vec3(-2.203441,7.254956,-13.517821)),\nCamPosData(vec3(-2.278282,6.910000,-17.487429), vec3(-2.296996,6.790903,-18.480135)),\nCamPosData(vec3(-2.327761,6.111896,-22.359962), vec3(-2.321779,5.805868,-23.311966)),\nCamPosData(vec3(-2.186686,5.035440,-27.222065), vec3(-2.136899,4.900762,-28.211702)),\nCamPosData(vec3(-0.993219,4.904999,-31.978512), vec3(-0.454830,5.005361,-32.815208)),\nCamPosData(vec3(2.171228,4.369769,-35.719467), vec3(2.794889,4.090777,-36.449680)),\nCamPosData(vec3(4.561439,3.589409,-39.984077), vec3(4.797843,3.617679,-40.955322)),\nCamPosData(vec3(4.739790,4.330019,-44.879646), vec3(4.578045,4.548162,-45.842068)),\nCamPosData(vec3(3.364606,4.765773,-49.650120), vec3(3.070709,4.797184,-50.605442)),\nCamPosData(vec3(-0.119510,4.995971,-52.331497), vec3(0.396747,5.444354,-53.061176)),\nCamPosData(vec3(-1.124801,4.916638,-55.486805), vec3(-0.414231,5.038854,-54.793873)),\nCamPosData(vec3(-2.172987,4.906855,-60.018024), vec3(-1.580975,4.960237,-59.213867)),\nCamPosData(vec3(-0.034418,4.800329,-63.079533), vec3(0.182555,4.903816,-62.108856)),\nCamPosData(vec3(3.056928,4.681053,-65.734558), vec3(3.150946,4.725021,-64.739960)),\nCamPosData(vec3(6.506225,4.625015,-66.172165), vec3(6.301536,4.731626,-65.199158)),\nCamPosData(vec3(9.294312,4.989921,-62.307842), vec3(9.105581,5.124599,-61.335091)),\nCamPosData(vec3(11.424669,5.425716,-57.879238), vec3(10.933987,5.516696,-57.012661)),\nCamPosData(vec3(12.199143,5.558903,-53.073444), vec3(11.559353,5.571469,-52.304996)),\nCamPosData(vec3(13.897681,5.578884,-49.589725), vec3(13.257891,5.591450,-48.821278)),\nCamPosData(vec3(14.351370,5.623287,-44.611916), vec3(13.701974,5.635853,-43.851570)),\nCamPosData(vec3(13.949431,5.721174,-39.631672), vec3(13.187083,5.736881,-38.984695)),\nCamPosData(vec3(13.510080,5.776707,-34.652901), vec3(12.741669,5.792414,-34.013138)),\nCamPosData(vec3(13.055349,5.832239,-29.675463), vec3(12.286938,5.847946,-29.035700)),\nCamPosData(vec3(12.600618,5.887772,-24.698084), vec3(11.832207,5.903479,-24.058321)),\nCamPosData(vec3(12.143284,5.943304,-19.720942), vec3(11.370868,5.959011,-19.086020)),\nCamPosData(vec3(10.600552,5.947750,-14.993365), vec3(9.682802,5.944608,-14.596219)),\nCamPosData(vec3(10.544567,5.942755,-11.117718), vec3(9.626818,5.939613,-10.720572)),\nCamPosData(vec3(8.563757,5.958488,-6.788820), vec3(7.572689,5.980478,-6.657287)),\nCamPosData(vec3(8.392307,5.958488,-3.293463), vec3(7.468257,5.911382,-3.672820)),\nCamPosData(vec3(7.676145,6.361337,1.006368), vec3(7.086134,6.137066,0.230746)),\nCamPosData(vec3(6.713125,7.291714,5.701828), vec3(6.391634,6.952976,4.817576)),\nCamPosData(vec3(3.644322,7.491270,7.165835), vec3(3.421862,7.285408,6.212875)),\nCamPosData(vec3(0.176282,7.491270,7.617840), vec3(0.116696,7.538376,6.620729)),\nCamPosData(vec3(-2.730626,7.599838,5.662962), vec3(-2.649177,7.659493,4.668072)),\nCamPosData(vec3(-2.257902,7.898043,0.695593), vec3(-2.160836,7.957697,-0.297896)),\nCamPosData(vec3(-1.983430,8.179771,-4.370270), vec3(-1.942655,8.233153,-5.368011)),\nCamPosData(vec3(-1.915488,8.268711,-6.032763), vec3(-1.874713,8.322093,-7.030504))\n);\n\nvec3 dirLdir = vec3(-0.2, -1.0, 0.8);\nvec3 dirLcol = vec3(0.9, 0.7, 0.5);\n\nvoid boxParams(in int i, out mat4 txx, out mat4 txi, out vec3 boxSize)\n{\n\tvec3 trapos = bd[i].pos;\n\tmat4 tra = translate( trapos.x, trapos.y, trapos.z );\n\ttxi = tra; \n\ttxx = inverse( txi );\n\tboxSize = bd[i].siz;\n}\n\nint iScene(in vec3 ro, in vec3 rd, out float tmin, out vec3 nor)\n{\n\tint oid = -1;\n\ttmin = 10000.0;\n\n\tfor (int i = 0; i < bd.length(); i++)\n\t{\n\t\tmat4 ttxi; \n\t\tmat4 ttxx;\n\t\tvec3 siz;\n\t\tboxParams(i, ttxx, ttxi, siz);\n\n\t\tvec4 res = iBox( ro, rd, ttxx, ttxi, siz);\n\n\t\tif( res.x>0.0 && res.x<tmin )\n\t\t{\n\t\t\ttmin = res.x; \n\t\t\tnor = res.yzw;\n\t\t\toid = i;\n\t\t}\n\t}\n\n\treturn oid;\n}\n\nbool isLightVisible(in vec3 ro, in int id)\n{\n\tfloat dist = length(ld[id].pos - ro);\n\tvec3 rd = normalize(ld[id].pos - ro);\n\tfloat tmin;\n\tvec3 nor;\n\tint oid = iScene(ro, rd, tmin, nor);\n\tif (oid == -1 || tmin > dist)\n\t{\n\t\treturn true;\n\t}\n\telse\n\t{\n\t\treturn false;\n\t}\n}\n\nfloat attenuation(in vec3 p, in vec3 l, in float radius)\n{\n\tfloat temp1 = 1.0 / (radius * radius);\n\tfloat temp2 = 2.0 / radius;\n\tvec3 ldir = l - p;\n    float r2 = dot(ldir, ldir);\n    float r = sqrt(r2);        \n    float ret = 0.0;\n\tif (r < radius)\n\t{\n\t\tret = clamp( r2 * temp1 * (r * temp2 - 3.0) + 1.0, 0.0, 1.0 );\n\t}\n\treturn ret;\n}\n\nvec3 light(in vec3 pos, in vec3 nor)\n{\n\tvec3 ro = pos + 0.001 * nor;\n\tvec3 ret = vec3(0.0);\n\n\tfor (int i = 0; i < ld.length(); i++)\n\t{\n\t\tif (isLightVisible(ro, i))\n\t\t{\n\t\t\tfloat att = attenuation(pos, ld[i].pos, ld[i].r);\n\t\t\tret = ret + ld[i].col * att;\n\t\t}\n\t}\n\n\treturn ret;\n}\n\nvec3 mainPixel(in vec3 ro, in vec3 rd)\n{\n    // raytrace\n\tfloat tmin = 10000.0;\n\tvec3  nor = vec3(0.0);\n\tvec3  pos = vec3(0.0);\n\t\n\t// raytrace box\n\tvec3 boxSize = vec3(0.5,0.5,0.5);\n\tmat4 txx = mat4(1.0);\n\tmat4 txi = mat4(1.0);\n\n\tint oid = iScene(ro, rd, tmin, nor);\n\tif (oid != -1)\n\t{\n\t\tboxParams(oid, txx, txi, boxSize);\n\t}\n\n    // shading/lighting\t\n\tvec3 col = vec3(0.6,0.75,0.85) - 0.97*rd.y;\n    \n\tif( oid != -1 )\n\t{\n\t\tpos = ro + tmin*rd;\n\t\t\n        // material\n\t\tvec3  mate = vec3(1.0);\n\t\t// recover box space data (we want to do shading in object space)\t\t\t\n\t\tvec3 opos = (txx*vec4(pos,1.0)).xyz;\n\t\tvec3 onor = (txx*vec4(nor,0.0)).xyz;\n\t\tmate = abs(onor.x)*texture( iChannel0, 0.5*opos.yz ).xyz + \n\t\t\t\tabs(onor.y)*texture( iChannel0, 0.5*opos.zx ).xyz + \n\t\t\t\tabs(onor.z)*texture( iChannel0, 0.5*opos.xy ).xyz;\n\t\t\n        // directional lighting\n\t\tvec3  lig = normalize(dirLdir);\n\n\t\tvec3 dircol = vec3(0.0);\n\n\t\tfloat shaddist;\n\t\tvec3 shadnor;\n\t\tint shadid = iScene(pos+0.001*nor, -lig, shaddist, shadnor);\n\t\tif (shadid == -1)\n\t\t{\n\t\t\tfloat att = dot(nor, -lig);\n\t\t\tatt = clamp(att, 0.0, 1.0);\n\t\t\tdircol = att * dirLcol;\n\t\t}\n\n\t\tvec3 lightcol = light(pos, nor);\n\n\t\tcol = (lightcol + dircol) * mate;\n\t}\n\n\treturn col;\n}\n\n// CGA conversion from https://www.shadertoy.com/view/3tfSDX\n#define RGB(r,g,b) (vec3(r,g,b) / 255.0)\nvec3 CGAPal[4] = vec3[](RGB(0, 0, 0), \n                        RGB(255, 85, 255), \n                        RGB(85,255, 255), \n                        RGB(255, 255, 255));\n#define PAL_SIZE 4.0\n\nvec3 dither8x8(vec2 position, float brightness) {  \n  float idx = clamp(brightness,0.0,1.0)* (PAL_SIZE - 1.0);\n    \n  vec3 c1 = CGAPal[int(idx)];\n  vec3 c2 = CGAPal[int(idx) + 1];\n    \n  float limit = texture(iChannel1, position / iChannelResolution[1].xy).r;\n  float mixAmt = float(fract(idx) > limit);\n\n  return mix(c1,c2,mixAmt);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 p = (2.0*fragCoord-iResolution.xy) / iResolution.y;\n\n\tint idx = int(iTime) % (cp.length() - 1);\n    bool iscga = int(iTime) % ( 2 * (cp.length() - 1) ) >= (cp.length() - 1);\n\n\tfloat step = iTime - floor(iTime);\n\tvec3 roNow = cp[idx].pos;\n\tvec3 tgtNow = cp[idx].tgt;\n\tvec3 roNext = cp[idx+1].pos;\n\tvec3 tgtNext = cp[idx+1].tgt;\n\t\n    // camera origin\n\tvec3 ro = mix(roNow, roNext, step);\n\t// camera target\n\tvec3 ta = mix(tgtNow, tgtNext, step);\n\n    // camera matrix\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(0.0,1.0,0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n\t// create view ray\n\tvec3 rd = normalize( p.x*uu + p.y*vv + 2.0*ww );\n\n\tvec3 col = mainPixel(ro, rd);\n    if (iscga)\n    {\n        float gray = 0.299 * col.x + 0.587 * col.y + 0.114 * col.z;\n        col = dither8x8(fragCoord, gray);\n    }\n\n\tfragColor = vec4( col, 1.0 );\n}", "image_inputs": [{"id": "Xdf3zn", "previewfilepath": "/media/ap/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png", "ctype": "texture"}, {"id": "Xsf3Rr", "previewfilepath": "/media/ap/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/7sBSRz.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "7sfSDr", "name": "impossible boxes piles 2", "author": "FabriceNeyret2", "description": "shaded variant of [url]https://shadertoy.com/view/NdfXR7[/url]\n\nreference: [img]https://i.imgur.com/oxv28g9.png[/img]", "tags": ["illusion", "escher", "isometric", "short", "reproduction", "paradoxical", "tomgauld"], "likes": 11, "viewed": 159, "date": "1618517463", "time_retrieved": "2024-06-20T20:36:29.336832", "image_code": "// shaded variant of https://shadertoy.com/view/NdfXR7\n\n\n#define rot(a)    mat2( cos(a+vec4(0,-1.57,1.57,0)) )    // rotation                  \n\nvoid mainImage(out vec4 O, vec2 U) {    \n    float t=9., T = iTime;\n    vec3  R = iResolution, W = vec3(4,5,4), q,r,a,\n          M = iMouse.z > 0. ? 2.*iMouse.xyz/R -1. :      // try mouse control to see the trick :-)\n                               vec3(.785,.41,0),\n          p = vec3( 10.*(U+U-R.xy)/R.y, 20 );            // ray start. dir = (0,0,-1)\n                                       \n    for ( O-=O ; O.x < 1. && t > .01 ; O+=.01 ) {        // marching point along ray\n        q = p, t = 1.,\n        q.yz *= rot(M.y),                                // rotations\n        q.xz *= rot(M.x);\n        a = abs( r = round(q/W) );                       // box id\n        r = p.y<0. ? r : -r;                             // for \"vertical\" connections\n    \n        if ( a.x*a.z == 0. )\n            if (  a.y == 0. && max(a.x,a.z) < 5.         // 2 rows of boxes\n               || r == vec3(4,1,0) || r == vec3(0,1,4)   // \"vertical\" connections\n               )  q = mod(q+W/2.,W) - W/2.,  \n               // q.xz *= rot(.5*iTime),                 // box rot: try me !\n                  a = abs(q) - 1.2,\n                  t = max( a.x, max(a.y-1.,a.z) );       // box SDF\n        \n        p.z -= .5*t;                                     // step forward = dist to obj          \n    }\n\n                                                         // shading & coloring\n    vec3 N = t<.01 ? sign(q)*vec3(equal(t+vec3(0,1,0),a)) : vec3(0,-1,0),// normal in object space\n         L = 20.*normalize( vec3(cos(.7*T), sin(1.2*T),cos(T+1.)) - vec3(0,0,1.1) ), // light pos\n         V = vec3(0,0,1), H;                             // view dir\n    N.xz *= rot(-M.x),  N.yz *= rot(-M.y);               // to camera space\n\n    p.z *= smoothstep(1.,0.,abs(p.x)/(4.*W.x/sqrt(2.)) );// trick for continuous lighting\n\n    L = normalize( L - p );                              // get light direction\n    H = normalize( L + V );                              // half-vector for specular\n                                                         // shade surface : \n    O =   ( .2 + max(0.,dot(N,L)) ) * ( t < .01 ? vec4(1,0,0,0): vec4(.9,.9,1,1) ) // amb + diff\n        +   pow(max(0.,dot(N,H)),150.);                  // specular\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/7sfSDr.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "7sfSRf", "name": "Spiroidoscope", "author": "dyla", "description": "Playing again with those damn spirals.", "tags": ["2d", "spiral", "blackwhite", "logarithmic"], "likes": 2, "viewed": 167, "date": "1618947910", "time_retrieved": "2024-06-20T20:36:29.336832", "image_code": "\n#define PI 3.1415926\n#define DPI 6.28318530\n\n\nfloat getAngleDiff(float a1, float a2) {\n\n    float diff = a1-a2;\n    while (diff < -PI) diff += DPI;\n    while (diff >  PI) diff -= DPI;\n    \n    return diff;\n\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float t = iTime*0.5;\n    vec2 uv = (fragCoord-0.5*iResolution.xy)/iResolution.xx;\n    float r = length(uv);\n    float alpha =(atan(uv.y, uv.x))*9.0 + t*1.37;\n    alpha += sin(alpha*2.0)*sin(t*0.39);\n    float alphaForR = mod(log(r) * sin(t*0.2)*5.0 - t*1.53, DPI) + sin(r*DPI*2.0-t*1.12)*2.0;\n\n    \n    fragColor = vec4(1.0-smoothstep(0.55, 0.75, 1.0-abs(getAngleDiff(alpha, alphaForR)/PI)));\n\n}\n\n\n\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/7sfSRf.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "7sfSRn", "name": "Ridges and Peaks ", "author": "wildniklin", "description": "My take at \"realistic\" terrain ridges and peaks.\n\nFeedback is appreciated! I'm currently working on an infinite voxel based game. I'm aiming for the best procedural terrain generation. So then feedback is very much appreciated.", "tags": ["noise"], "likes": 1, "viewed": 189, "date": "1618172806", "time_retrieved": "2024-06-20T20:36:29.336832", "image_code": "vec3 randomnoise33(vec3 p)\n{\n    return (fract(sin(p + dot(p, vec3(12.9898, 78.233, 195.1533))) * 43758.5453123) * 2.0) - 1.0;\n}\n\nfloat gdot31(vec3 p, vec3 i)\n{\n    return dot(p - i, vec3(sin(randomnoise33(i) * 2920.0)));\n}\n\nfloat perlinnoise31(vec3 p)\n{\n    vec3 i = floor(p);\n    vec3 f = fract(p);\n    f = f * f * f * ((f * ((f * 6.0) - 15.0)) + 10.0);\n    return mix(mix(mix(gdot31(p, i                      ),\n                       gdot31(p, i + vec3(1.0, 0.0, 0.0)), f.x),\n                   mix(gdot31(p, i + vec3(0.0, 1.0, 0.0)),\n                       gdot31(p, i + vec3(1.0, 1.0, 0.0)), f.x), f.y),\n               mix(mix(gdot31(p, i + vec3(0.0, 0.0, 1.0)),\n                       gdot31(p, i + vec3(1.0, 0.0, 1.0)), f.x),\n                   mix(gdot31(p, i + vec3(0.0, 1.0, 1.0)),\n                       gdot31(p, i + vec3(1.0, 1.0, 1.0)), f.x), f.y), f.z);\n}\n\nfloat fractalperlinnoise31(vec3 p, float amplitude, float frequency, float gain, float lacunarity, int octaves)\n{\n    float r = 0.0;\n    float a = amplitude;\n    float f = frequency;\n    for(int i = 0; i < octaves; i++)\n    {\n        r += perlinnoise31(p * f) * a;\n        a *= gain;\n        f *= lacunarity;\n    }\n    return r;\n}\n\nvoid mainImage(out vec4 o, in vec2 i)\n{\n    vec2 uv = (i.xy - (0.5 * iResolution.xy)) / min(iResolution.x, iResolution.y);\n\n    vec3 col = vec3(0.0);\n\n    uv *= 8.0;\n    uv += iTime;\n    int octaves = 16;\n\n    vec3 offs = vec3(\n        fractalperlinnoise31(vec3(uv, 0.0) + 697.486, 0.5, 1.0, 0.5, 2.0, 16),\n        fractalperlinnoise31(vec3(uv, 0.0) + 120.165, 0.5, 1.0, 0.5, 2.0, 16),\n        fractalperlinnoise31(vec3(uv, 0.0) + 892.858, 0.5, 1.0, 0.5, 2.0, 16)\n    ) * 2.0 * (0.5 + (0.5 * perlinnoise31(vec3(uv, 526.628))));\n\n    float smoothen = 0.5 + (0.5 * perlinnoise31(vec3(uv * 0.5, 0.0) + 259.562));\n\n    float roughHeight = 0.5 + (0.5 * fractalperlinnoise31(vec3(uv, 0.0) + offs, 0.5, 1.0, 0.5, 2.0, 16));\n\n    float smoothHeight = 0.5 + (0.5 * fractalperlinnoise31(vec3(uv * 0.5, 0.0), 0.5, 1.0, 0.5, 2.0, 8));\n\n    float result = mix(roughHeight, smoothHeight * 0.5, 1.0 - (smoothen * smoothen));\n\n    result *= 1.6;\n\n    col += result * result * result;\n\n    o = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/7sfSRn.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "7sfSW8", "name": "Desert planet map", "author": "jarble", "description": "This fractal resembles a map of a desert planet.", "tags": ["fractal", "map", "desert", "bitwise"], "likes": 1, "viewed": 129, "date": "1618540546", "time_retrieved": "2024-06-20T20:36:29.336832", "image_code": "//#define ITERS 9 //normal world map\n#define ITERS 12 //swamp world\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Scale and move to make things a litle more interesting t look at.\n    float scale = 2000.0;\n    float trans = iTime * 200.0;\n    vec2 coord = (scale * fragCoord/iResolution.xy) + vec2(trans+30000.0,0.0);\n    \n    // Heart of color selection.\n    int val = 0;\n    float result = 0.0;\n    vec3 col = vec3(0.0);\n    vec3 col_prev = vec3(0.0);\n    for(int i = 0; i < ITERS; i++){\n        col_prev = col;\n        coord.y -= (4.0-result);\n        coord += coord.yy/8.0;\n        coord = coord.yx/(4.0);\n        result = ((result + float(val = ((int(coord.x-coord.y/2.0) & int(coord.y+coord.x/2.0)) % 3)))/(2.0));\n        col.x = result;\n        col = ((col.yzx)*3.0+col_prev)/3.5;\n    }\n    // Output.\n    fragColor = vec4((col),0.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/7sfSW8.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "7sfSWX", "name": "twisting tori", "author": "johnowhitaker", "description": "Messing with signed distance functions trying to replicate something like https://observablehq.com/@makio135/ouroboros \nLooks a little glitchy in places due to my hacky height-adjusting code.", "tags": ["sdf", "ouroboros"], "likes": 8, "viewed": 98, "date": "1619328560", "time_retrieved": "2024-06-20T20:36:29.973309", "image_code": "// For ray marching:\nconst int MAX_MARCHING_STEPS = 255;\nconst float MIN_DIST = 0.0;\nconst float MAX_DIST = 100.0;\nconst float EPSILON = 0.0001;\n\n// FROM https://iquilezles.org/www/articles/distfunctions/distfunctions.htm\nfloat opSmoothUnion( float d1, float d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); }\n\n// From ??\nmat4 rotation3d(vec3 axis, float angle) {\n  axis = normalize(axis);\n  float s = sin(angle);\n  float c = cos(angle);\n  float oc = 1.0 - c;\n\n  return mat4(\n\t\toc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s,  0.0,\n    oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s,  0.0,\n    oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c,           0.0,\n\t\t0.0,                                0.0,                                0.0,                                1.0\n\t);\n}\n\n// They key SDF\nfloat weirdTorus( vec3 p, vec2 t, float time_offset)\n{\t\n    // Varying width based on angle\n    float angle = acos(dot(normalize(p.xz), normalize(vec2(sin(iTime+time_offset), cos(iTime+time_offset)))));\n    float width = -0.018 + t.y*abs(sin(angle*1.5));\n    \n    // Mess with height\n    float static_angle = acos(dot(normalize(p.xz), normalize(vec2(0., 1.))));\n    p.y += 0.06*cos(static_angle*4.); // These values need tweaking...\n    p.x += 0.06*cos(static_angle*3.14);\n\n    \n    // Torus:\n    vec2 q = vec2(length(p.xz)-t.x,p.y);\n    return length(q)-width;\n}\n\n\n\n// Three together with some rotation between them \nfloat sceneSDF(vec3 samplePoint) { \n\n    // Rotate viewing angle\n    samplePoint = (rotation3d(vec3(0.4,0.,0.1), 0.5)*vec4(samplePoint, 0.)).xyz;\n    \n    // The first twisty torus\n    float t1 = weirdTorus(samplePoint, vec2(0.4,0.050),  0.);\n    \n    // Rotate and add a second one then a third\n    samplePoint = (rotation3d(vec3(0., 1., 0.), 0.3)*vec4(samplePoint, 0.)).xyz;\n    float t2 = weirdTorus(samplePoint, vec2(0.4, 0.05), 0.);\n    samplePoint = (rotation3d(vec3(0., 1., 0.), 0.3)*vec4(samplePoint, 0.)).xyz;\n    float t3 = weirdTorus(samplePoint, vec2(0.4, 0.05), 0.);\n    \n    // Combine and return the final distance\n    return min(t1, min(t2, t3));\n\n}\n\n// Ray marching stuff from https://www.shadertoy.com/view/llt3R4\nfloat shortestDistanceToSurface(vec3 eye, vec3 marchingDirection, float start, float end) {\n    float depth = start;\n    for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n        float dist = sceneSDF(eye + depth * marchingDirection);\n        if (dist < EPSILON) {\n\t\t\treturn depth;\n        }\n        depth += dist;\n        if (depth >= end) {\n            return end;\n        }\n    }\n    return end;\n}\nvec3 rayDirection(float fieldOfView, vec2 size, vec2 fragCoord) {\n    vec2 xy = fragCoord - size / 2.0;\n    float z = size.y / tan(radians(fieldOfView) / 2.0);\n    return normalize(vec3(xy, -z));\n}\nvec3 estimateNormal(vec3 p) {\n    return normalize(vec3(\n        sceneSDF(vec3(p.x + EPSILON, p.y, p.z)) - sceneSDF(vec3(p.x - EPSILON, p.y, p.z)),\n        sceneSDF(vec3(p.x, p.y + EPSILON, p.z)) - sceneSDF(vec3(p.x, p.y - EPSILON, p.z)),\n        sceneSDF(vec3(p.x, p.y, p.z  + EPSILON)) - sceneSDF(vec3(p.x, p.y, p.z - EPSILON))\n    ));\n}\n\n\n// Generating the final image\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{    \n    vec3 dir = rayDirection(0.298 * 100., iResolution.xy, fragCoord.xy);\n    vec3 eye = vec3(0., 0, 5.); // Can edit this to move based on mouse position for interactivity\n    float dist = shortestDistanceToSurface(eye, dir, MIN_DIST, MAX_DIST);\n    \n    if (dist > MAX_DIST - EPSILON) {\n        // Didn't hit anything\n        fragColor = vec4(0.0, 0.0, 0.0, 0.0);\n\t\treturn;\n    }\n    \n    // The closest point on the surface to the eyepoint along the view ray\n    vec3 p = eye + dist * dir;\n    \n    // An estimated normal\n    vec3 n = estimateNormal(p);\n    \n    // Lighting - fake image based lighting as shown in https://www.youtube.com/watch?v=FilPE91ACOA&t=1s\n    vec3 color = vec3(pow(length(sin(n*2.)*.5+.5)/sqrt(3.), 2.));\n    \n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/7sfSWX.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "7sfSz2", "name": "Luna toy", "author": "kaihagseth", "description": "Youtube inspired moire", "tags": ["moire", "toy"], "likes": 3, "viewed": 169, "date": "1618862514", "time_retrieved": "2024-06-20T20:36:29.979403", "image_code": "// Inspired by Tim Rowetts youtube channel :)\n// https://www.youtube.com/watch?v=Mx7xusheSN0\n\n#define PI 3.141592\n#define ROLLSPEED 0.2\n#define STRIPES 24.\n#define RADIUS STRIPES/5.\n\n// True pixelwidth for antialiasing. Thank you Fabrice Neyret!\n#define PW STRIPES/iResolution.y \n\nfloat horizontalStripes(in vec2 uv)\n{\n    return smoothstep(-PW,PW, abs(fract(uv.y)-.5) - .25);\n}\n\nmat2 rotate2d(float angle)\n{\n    return mat2 (cos(angle), -sin(angle), sin(angle), cos(angle)) ;\n}\n\nfloat maskCircle(in vec2 uv, float radius)\n{\n    return smoothstep(radius-PW, radius+PW, length(uv));\n}\n\nvec2 roll(float dist, vec2 uv)\n{\n    float t = iTime * ROLLSPEED;\n    uv.x += dist * RADIUS * cos(t);\n    uv *= -rotate2d(dist * -cos(t));\n    return uv;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = ( fragCoord - .5* iResolution.xy) / iResolution. y;\n    vec2 st = uv;\n    uv *= STRIPES;\n    vec2 lightRoller =  roll(PI, uv + vec2(0.,(STRIPES/4.)));\n    vec2 darkRoller =   roll(-PI, uv - vec2(0., -.5+(STRIPES/4.)));\n    float lightRollerColor = horizontalStripes(lightRoller) * (1. - maskCircle(lightRoller, RADIUS));\n    float darkRollerColor =  horizontalStripes(darkRoller) * (1. - maskCircle(darkRoller, RADIUS));\n    fragColor = vec4(horizontalStripes(uv) + lightRollerColor - darkRollerColor);\n\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/7sfSz2.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "7sfSzB", "name": "Circle sandbox 2: Ellipses!", "author": "lmno", "description": "Generalization to ellipses.", "tags": ["sandbox", "sandbox2"], "likes": 1, "viewed": 41, "date": "1618776804", "time_retrieved": "2024-06-20T20:36:29.979403", "image_code": "// Fork of \"Ellipse Tangents Through Point\" by oneshade. https://shadertoy.com/view/ssfXRB\n// 2021-04-18 20:09:52\n\n// https://www.desmos.com/calculator/i0ofizuwzm\n\n// Drawing utilities\n#define drawSDF(dist, col) color = mix(color, col, smoothstep(unit, 0.0, dist))\n\n// SDFs\nfloat sdDisc(in vec2 p, in vec2 o, in float r) {\n    return length(p - o) - r;\n}\n\n// https://www.iquilezles.org/www/articles/distfunctions/distfunctions.htm\nfloat deEllipse(in vec2 p, in vec2 r) {\n    float k0 = length(p / r);\n    float k1 = length(p / (r * r));\n    return k0 * (k0 - 0.95) / k1;\n}\n\nfloat sdInfLine(in vec2 p, in vec2 a, in vec2 b) {\n    vec2 pa = p - a, ba = b - a;\n    return length(pa - ba * dot(pa, ba) / dot(ba, ba));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 center = 0.5 * iResolution.xy;\n\n    vec4 mouse = (vec4(iMouse.xy, abs(iMouse.zw)) - center.xyxy) / iResolution.y * 4.0;\n    vec2 uv = (fragCoord - center) / iResolution.y * 4.0;\n    float unit = 8.0 / iResolution.y;\n    vec3 color = vec3(0.059,0.122,0.059);\n\n    // Default before interaction\n    if (ivec2(iMouse.xy) == ivec2(0)) {\n        mouse.xy = vec2(sin(iTime), 1.0) * cos(iTime);\n        mouse.x += 2.0;\n    }\n\n    // Radii and angles\n    vec2 r = vec2(1.25, 0.65) + 0.35 * vec2(cos(iTime), sin(iTime));\n    vec2 a = atan(r.x * mouse.y, r.y * mouse.x) + vec2(1.0, -1.0) * acos(1.0 / length(mouse.xy / r));\n\n    // Points on the ellipse\n    vec2 t1 = vec2(cos(a.x), sin(a.x)) * r;\n    vec2 t2 = vec2(cos(a.y), sin(a.y)) * r;\n\n    // Ellipse\n    drawSDF(abs(deEllipse(uv, r)), vec3(0.122,0.459,0.404));\n\n    // Tangents\n    drawSDF(sdInfLine(uv, mouse.xy, t1), vec3(0.090,0.188,0.161));\n    drawSDF(sdInfLine(uv, mouse.xy, t2), vec3(0.090,0.188,0.161));\n\n    // Point\n    drawSDF(sdDisc(uv, mouse.xy, 0.05), vec3(1.0));\n\n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/7sfSzB.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "7sfXD4", "name": "RotatingSphere", "author": "nialred", "description": "Attempting to implement rotation, but am only able to rotate the xy pixel coordinates not the sphere itself. \n\nTrying to get better at this. Would appreciate comments and such suggesting how I might go about that.", "tags": ["sdf", "distortion", "sphere", "raymarcher", "rotation"], "likes": 0, "viewed": 97, "date": "1618640618", "time_retrieved": "2024-06-20T20:36:30.755172", "image_code": "/*\n\nI DID NOT DO THIS ALONE:\n========================\n\nReferences:\nhttp://jamie-wong.com/2016/07/15/ray-marching-signed-distance-functions/\nhttps://michaelwalczyk.com/blog-ray-marching.html\nhttps://www.scratchapixel.com/lessons/3d-basic-rendering/ray-tracing-generating-camera-rays/generating-camera-rays\nhttps://www.shadertoy.com/view/4sdSDN\n\n*/\n\nconst int MAX_MARCHING_STEPS = 32; // Max steps you are willing to search for a \"hit\"\nconst float MAX_DIST = 1000.0; // Max distance to search for a \"hit\"\nconst float MIN_DIST = 0.0; // Where to start the march \nconst float EPSILON = 0.001; // How close you need to be to be considered a hit\n\nstruct Ray\n{\n    vec3 origin;\n    vec3 direction;\n};\n\nstruct Sphere\n{\n    vec3 center;\n    float radius;\n};\n\n// I don't know where I should define this cause I don't know how this scales\n// once you introduce multiple shapes and whatnot, so I just made it global\nSphere sphere = Sphere(vec3(0.0, 0.0, 12.0), 3.0);\n\nvec3 ray_direction(float fieldOfView, vec2 size, vec2 uv) \n{ \n    float z = 1.0 / tan(radians(fieldOfView) / 2.0); // Distance to image plane\n    return normalize(vec3(uv, z));\n}\n\nfloat sphere_sdf(vec3 point)\n{\n    return length(point - sphere.center) - sphere.radius; // Return distance from sphere\n}\n\nfloat distort_surface(float freq, vec3 point)\n{\n    return sin(freq * point.x) * sin(freq * point.y) * sin(freq * point.z);\n}\n\nvoid rotate_2d(float freq, inout vec2 p)\n{\n    float c = cos(10.0*freq);\n    float s = sin(10.0*freq);\n    p = vec2((p.x*c) - (p.y*s), (p.x*s) + (p.y*c));\n}\n\nfloat map_world(vec3 point)\n{   \n    float displacement = distort_surface(cos(iTime/5.0)+200000000000000000000000000000000000.5, point); //500000000000.5\n    \n    float dist = sphere_sdf(point); // Distance from sphere \n    return dist + displacement;\n}\n\nfloat shortest_distance_to_surface(vec3 eye_pos, vec3 march_dir, float start, float end)\n{\n    float depth = start; // Starting point for ray march (0.0)\n    float dist = 0.0;    // Initalize distance from sphere variable\n    int i = 0;           \n    \n    while (i < MAX_MARCHING_STEPS)\n    {\n        dist = map_world(eye_pos + (depth * march_dir)); // Distance to sphere (distorted)\n        \n        if (dist < EPSILON) // If at the surface, return the depth from image plane\n        {\n            return depth;\n        }\n        \n        depth += dist;\n        \n        if (depth >= end) // If at the max marching distance, return the max value\n        {\n            return end;\n        }\n        \n        i += 1;\n     }\n     \n     return end;\n}\n\nvec3 estimate_normal(vec3 point)\n{   \n    vec3 step = vec3(EPSILON, 0.0, 0.0);\n    \n    float gradient_x = map_world(point + step) - map_world(point - step);\n    float gradient_y = map_world(point + step.yxz) - map_world(point - step.yxz);\n    float gradient_z = map_world(point + step.yzx) - map_world(point - step.yzx);\n    \n    vec3 normal = vec3(gradient_x, gradient_y, gradient_z);\n    \n    return normalize(normal);\n}\n\nfloat diffuse(vec3 current_pos, vec3 light_pos, vec3 normal)\n{\n    vec3 light_dir = normalize(light_pos - current_pos);\n    float intensity = max(0.0, dot(normal, light_dir));\n    return intensity;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    sphere.center = vec3(0.4*sin(iTime/5.0), 0.4*cos(iTime/5.0), 8.0 + sin(iTime/5.0));\n    \n    // Normalized pixel coordinates (from -1 to 1)\n    vec2 uv = (fragCoord/iResolution.xy) * 2.0 - 1.0;\n    float aspect_ratio = iResolution.x/iResolution.y;\n    uv.x = uv.x * aspect_ratio; // Account for image aspect ratio\n    \n    // Define camera position\n    vec3 cam_pos = vec3(0.0, 0.0, 0.0);\n    \n    // Define ray as vector from camera position to pixel position\n    rotate_2d(iTime/20.0, uv);\n    Ray ray = Ray(cam_pos, ray_direction(30.0, iResolution.xy, uv));\n      \n    // Define light position as a 3D vector\n    vec3 light_pos = vec3(0.0, 10.0, 0.0);\n    \n    // Find distance to surface\n    float dist = shortest_distance_to_surface(ray.origin, ray.direction, MIN_DIST, MAX_DIST);\n    \n    if (dist > MAX_DIST - EPSILON) // If sphere doesn't exist at this pixel draw bg\n    {\n        // Eventually want to have the background be a cubic room \n        fragColor = vec4(0.0, 0.0, 0.0, 0.0);\n    }\n    \n    else // If sphere does exist at this pixel, draw color accordingly using basic lighting\n    {\n        vec3 point = ray.origin + dist*ray.direction;\n        vec3 normal = estimate_normal(point);\n        float intensity = diffuse(point, light_pos, normal);\n        normal = vec3(1.0, 0.9, 1.0) * intensity;\n        fragColor = vec4(normal, 1.0);\n    }\n    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/7sfXD4.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "7sfXR4", "name": "Fork Spiral por JulianCode 461", "author": "JulianCode1337", "description": "Spiral portal", "tags": ["spiral", "portal"], "likes": 6, "viewed": 241, "date": "1618319511", "time_retrieved": "2024-06-20T20:36:30.761260", "image_code": "float speed = -10.0;\nfloat frequency = 20.0;\n\nvoid spin(inout vec2 pos){\n    float angle = iTime - atan(length(pos)) * 3.0;\n    pos.xy = vec2( \n        pos.x * cos(angle) - pos.y * sin(angle),\n        pos.y * cos(angle) + pos.x * sin(angle)\n        );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    float t = iTime * speed;\n    vec2 position = (fragCoord.xy - iResolution.xy * .5) / iResolution.x;\n    \n    spin(position);\n    \n    float angle = atan(position.y, position.x) / (2. * 3.14159265359);\n    angle -= floor(angle);\n    float rad = length(position);\n    float angleFract = fract(angle * 256.);\n    float angleRnd = floor(angle * 256.) + 1.;\n    float angleRnd1 = fract(angleRnd * fract(angleRnd * .7235) * 45.1);\n    float angleRnd2 = fract(angleRnd * fract(angleRnd * .82657) * 13.724);\n    float t2 = t + angleRnd1 * frequency;\n    float radDist = sqrt(angleRnd2);\n    float adist = radDist / rad * .1;\n    float dist = (t2 * .1 + adist);\n    dist = abs(fract(dist) - 0.5);\n    \n    float outputColor = (1.0 / (dist)) * cos(0.7 * sin(t)) * adist / radDist / 30.0;\n    angle = fract(angle + .61);\n    \n    vec2 uv = fragCoord/iResolution.xy;\n    vec3 col = vec3(0.8,1.5,3);\n\n    fragColor = vec4(outputColor * col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/7sfXR4.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "7sj3Dt", "name": "Freaky Checkers", "author": "kaihagseth", "description": "Moirepatterns", "tags": ["moire", "pattern"], "likes": 3, "viewed": 172, "date": "1618161996", "time_retrieved": "2024-06-20T20:36:31.070355", "image_code": "/* \n * Author: Kai Hagseth\n * Inspired by the great Tadashi Tokieda\n * https://youtu.be/QAja2jp1VjE\n*/\n\n#ifdef GL_ES\nprecision highp float;\n#endif\n#define PI 3.14159265359\n#define N 30.0\n\nvec3 checker(in vec2 st)\n{\n  float checkSize = 2.0;\n  float fmodResult = mod(floor(checkSize * st.x) + floor(checkSize * st.y), 2.0);\n  return vec3(smoothstep(1.0, 0.0, sign(fmodResult)));\n}\n\n\nmat2 rotate2d(float _angle){\n    return mat2(cos(_angle),-sin(_angle),\n                sin(_angle),cos(_angle));\n}\nvec2 rotate(in vec2 inp)\n{\n    inp *=  1.+(.05*sin(iTime/(1.618*10.)));\n    inp *= rotate2d(.15*cos(iTime/10.0));\n    return inp;\n}\n\nvec3 pattern(vec2 st, vec3 color, float n)\n{\n    st += iResolution.xy;\n    st *= n;      \n    st = fract(st);\n    return color * checker(st);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 st = ( fragCoord - .5* iResolution.y) / iResolution. y;\n    vec3 color = vec3(1.0, 1.0, 1.0);\n    vec3 pattern1 = pattern(st, color, N);\n    vec2 st2 = rotate(st);\n    \n    vec3 pattern2 = pattern(st2, color, N);\n    vec3 dots = pattern1  + pattern2;\n\tdots = 1.0-(dots*1.0); //inverse\n    fragColor = vec4(dots,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/7sj3Dt.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "7sj3Wz", "name": "Rainbow Metaballs", "author": "TimurAB", "description": "Kind of rainbow metaballs (circles ?)", "tags": ["balls", "rainbow"], "likes": 1, "viewed": 162, "date": "1617274429", "time_retrieved": "2024-06-20T20:36:31.070355", "image_code": "float _pi = 3.14159;\n\nvec3 hsv_to_rgb (float h, float s, float v)\n{\n    if (s == 0.0) {\n        return vec3(v);\n    }\n    float i = floor(h * 6.0);\n    float f = h * 6.0 - i;\n    float p = v * (1.0 - s);\n    float q = v * (1.0 - f * s);\n    float t = v * (1.0 - (1.0 - f) * s);\n    if (i >= 6.0 || i < 1.0) return vec3(v,t,p);\n    else if (i >= 1.0 && i < 2.0) return vec3(q,v,p);\n    else if (i >= 2.0 && i < 3.0) return vec3(p,v,t);\n    else if (i >= 3.0 && i < 4.0) return vec3(p,q,v);\n    else if (i >= 4.0 && i < 5.0) return vec3(t,p,v);\n    else if (i >= 5.0 && i < 6.0) return vec3(v,p,q);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = 2.0 * fragCoord/iResolution.xy - 1.0;\n    float aspect = iResolution.x / iResolution.y;\n    uv.x *= aspect;\n    const int n = 5;\n    float a = -0.2 * iTime * _pi;\n    float len = 0.6, radius = 0.75 / float(n);\n    float h = 0.0, angle;\n    vec2 pos;\n    for(int i = 0; i < n; i ++) {\n        angle = a + float(i) * (_pi + _pi) / float(n);\n        pos = vec2(1.5 * len * cos(angle), len * sin(angle + angle));\n        h += radius/length(uv - pos);\n    }\n    h = fract(h + 0.1 * iTime);\n    vec3 col = hsv_to_rgb(h,1.0,1.0);\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/7sj3Wz.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "7sj3zV", "name": "Monte Carlo Sample", "author": "Yon", "description": "Some step of my SH Visualize Practices\n", "tags": ["montecarlo"], "likes": 1, "viewed": 66, "date": "1618539950", "time_retrieved": "2024-06-20T20:36:31.070355", "image_code": "// From iq\n#define PI 3.14159\n\nmat3 camMat;\n\nfloat rnd(float seed) { return fract(sin(seed)*43758.5453123); }\n\nstruct ray{\n    vec3 ori;\n    vec3 dir;\n};\n\n//draw sphere,return hit pos\nfloat hit_sphere(vec3 center, float radius, ray r){\n    vec3 oc = r.ori - center;\n    float a = dot(r.dir,r.dir);\n    float b = 2.*dot(oc,r.dir);\n    float c = dot(oc,oc)- radius*radius;\n    float discriminant = b*b - 4.*a*c;\n    if (discriminant < 0.) {\n        return -1.0;\n    } else {\n        return (-b - sqrt(discriminant) ) / (2.0*a);\n    }\n}\n\nvec3 draw(ray r){\n    float t;\n    for(int i;i<=1024;i++){\n        float theta = 2.*acos(sqrt(1.-rnd(247.2297*float(i))));\n        float phi = 2.* PI *rnd(78.2834*float(i));\n\n        float x = sin(phi) * cos(theta);\n        float y = sin(phi) * sin(theta);\n        float z = cos(phi);\n        \n        vec3 cen_pos = vec3(0.,0.,0.);\n        \n        vec3 sample_pos = cen_pos + 0.7*vec3(x,y,z);\n        \n        t = hit_sphere(sample_pos,0.01,r);\n        if (t > 0.0) {\n        vec3 N = normalize (r.ori + r.dir*t - sample_pos);\n        vec3 light = vec3(-1.,-1.,0.);\n        vec3 color = vec3(dot(light,N)*0.5+0.5);\n        return color;\n        }   \n    }\n    \n    //BackGround\n    vec3 dir = normalize(r.dir);\n    t = 0.5*(dir.y + 1.0);\n    return (1.-t)*vec3(1.,1.,1.) + t*vec3(0.2,0.3,1.0);\n}\n\nmat3 setCamera(vec3 ro, vec3 ta, float cr)\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    vec2 p = (2.0 * fragCoord.xy - iResolution.xy) / iResolution.yy;\n    \n    // Mouse\n    vec2 mo = vec2(0.0);\n    if (iMouse.z > 0.0) {\n        mo += (2.0 * iMouse.xy - iResolution.xy) / iResolution.yy;\n    }\n    // Camera position\n    float dist = 1.;\n    vec3 ro = vec3(dist * cos(iTime * 0.1 + 6.0 * mo.x), 2.0 + mo.y * 4.0, dist * sin(iTime * 0.1 + 6.0 * mo.x));\n    \n    // Rotate the camera\n    vec3 target = vec3(0.0, 0.0, 0.0);\n    \n    // Compute the ray\n    camMat = setCamera(ro, target, 0.0);\n    vec3 rd = camMat * normalize(vec3(p.xy, 1.5));\n    \n    ray r;\n    r.ori = ro;\n    r.dir = rd;\n    \n    vec3 color = draw(r);\n    \n    // Output to screen\n    fragColor = vec4(color,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/7sj3zV.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "7sjGD3", "name": "circle-flash", "author": "elusive", "description": "circle", "tags": ["2d", "circle"], "likes": 1, "viewed": 27, "date": "1618064140", "time_retrieved": "2024-06-20T20:36:31.070355", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 coord = fragCoord.xy;\n    vec2 center = iResolution.xy /2.0;\n    float dist = length(center - coord);\n    float circle = cos(dist * iTime);\n\tfragColor = vec4(circle,circle,circle,0.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/7sjGD3.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "7sjGDK", "name": "Terrain Attempt", "author": "khalladay", "description": "Baby's First Terrain Function", "tags": ["terrain"], "likes": 3, "viewed": 43, "date": "1618006033", "time_retrieved": "2024-06-20T20:36:32.034062", "image_code": "//pretty much all of this is stolen from other shadertoys, just trying to get a handle on generating terrain\n\n#define PI 3.14159\n\n//uncomment to carve a trench in front of the camera\n//#define TRENCH\n\nfloat hash12(vec2 p) {\n\tfloat h = dot(p,vec2(127.1,311.7));\t\n    return fract(sin(h)*43758.5453123);\n}\n\n//stolen from https://www.shadertoy.com/view/lslfRN\nfloat n2D(vec2 p) {\n \n\tvec2 i = floor(p); p -= i; p *= p*(3. - p*2.); //p *= p*p*(p*(p*6. - 15.) + 10.);    \n    \n\treturn dot(mat2(fract(sin(vec4(0, 41, 289, 330) + dot(i, vec2(41, 289)))*43758.5453))*\n               vec2(1. - p.y, p.y), vec2(1. - p.x, p.x));\n\n}\n \n// 3d noise\nfloat noise_3(in vec3 p) {\n    vec3 i = floor(p);\n    vec3 f = fract(p);\t\n\tvec3 u = f*f*(3.0-2.0*f);\n    \n    vec2 ii = i.xy + i.z * vec2(5.0);\n    float a = hash12( ii + vec2(0.0,0.0) );\n\tfloat b = hash12( ii + vec2(1.0,0.0) );    \n    float c = hash12( ii + vec2(0.0,1.0) );\n\tfloat d = hash12( ii + vec2(1.0,1.0) ); \n    float v1 = mix(mix(a,b,u.x), mix(c,d,u.x), u.y);\n    \n    ii += vec2(5.0);\n    a = hash12( ii + vec2(0.0,0.0) );\n\tb = hash12( ii + vec2(1.0,0.0) );    \n    c = hash12( ii + vec2(0.0,1.0) );\n\td = hash12( ii + vec2(1.0,1.0) );\n    float v2 = mix(mix(a,b,u.x), mix(c,d,u.x), u.y);\n        \n    return max(mix(v1,v2,u.z),0.0);\n}\n\nfloat fbm( in vec2 x)\n{    \n    float G = 0.5;\n    float f = 1.10;\n    float a = 2.0;\n    \n    float s = 0.0;\n    \n    float t = 0.0;\n    for( int i=0; i<5; i++ )\n    {\n        //this matrix this is taken from https://www.shadertoy.com/view/lslfRN\n        //it's pretty nifty\n        x = mat2(1, -.75, .75, 1)*x;\n        s += a;\n        t += a*n2D(f*x);\n\n        f *= 2.0;\n        a *= G/1.05 * -1.0; //without the divide, things get a bit too noisy \n    }\n    return t;\n}\n\n//return the height of the infinite terrain plane at point p.xz\nfloat terrain(vec2 p)\n{\n    float t = fbm(p.xy/32.0)*1.5;\n    \n    #ifdef TRENCH\n    t *= max(0.35,min(1.25,abs(p.y)-10.0));\n    #endif\n    \n    \n    //use a texture to carve some not-procedural looking spots out\n    t -= t*textureLod(iChannel1, p.yx/128.0f, 4.0).r; \n    \n    //make tall stuff taller\n    t += t*0.15;\n    \n    //at lower elevations, flatten out\n    t = max(0.05,t);\n\n    //scale amplitude of terrain\n    t *= 10.0;\n    return t;\n}\n\nfloat map(vec3 at)\n{\n    float g = terrain(at.xz);\n\treturn g;\n}\n\n\nmat3 setCamera( in vec3 pos, in vec3 lookPoint )\n{\n\tvec3 lookDir = normalize(lookPoint-pos);\n   \tvec3 cu = normalize( cross(vec3(0,-1,0),lookDir) );\n\tvec3 cv = normalize( cross(cu,lookDir) );\n    return mat3( cu, cv, lookDir );\n}\n\nvec3 getNormal( const vec3 p )\n{\n    float eps = 1.0;\n    return normalize( vec3( terrain(vec2(p.x-eps,p.z)) - terrain(vec2(p.x+eps,p.z)),\n                            2.0f*eps,\n                            terrain(vec2(p.x,p.z-eps)) - terrain(vec2(p.x,p.z+eps)) ) );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 q = fragCoord.xy / iResolution.xy;\n    vec2 pix = -1.0 + 2.0 * q;\n    pix.x *= iResolution.x/iResolution.y;\n\n    //xz coords for camera are a circle\n\tvec3 CAM_POS = vec3(iTime*1.5,0,0.0);\n    \n    //smoothly translate the camera upwards to try to avoid intersecting terrain.\n    //far from perfect\n    float heightAdj = 0.0;\n    for (int i = 0; i < 20; i++)\n    {\n        heightAdj += map(CAM_POS + vec3(0.05*float(i), 0.0, 0.0));\n    }\n    heightAdj/=10.0;    \n\n    CAM_POS += vec3(0,1,0) * heightAdj;\n\n    \n\tvec3 CAM_LOOKPOINT = CAM_POS + vec3(1.0, 0.0, 0.0);\n\t\n\tmat3 cam = setCamera(CAM_POS, CAM_LOOKPOINT);\n    vec3 camPosToFragWorld = normalize( cam * vec3(pix.xy, 2.0) );\n\t\t\n\tvec3 col = mix(vec3(0.25,0.25,0.5), vec3(0.6,0.6,0.8), (fragCoord.y*1.0)/iResolution.y);\n    vec3 light1 = normalize( vec3(0.0,0.4,0.0) );\n\n\tvec3 p = CAM_POS;\n    \n    \n    float mint = 0.1;\n    float maxt = 100.0;\n    float dt = 0.01;\n    \n    //store last height and last sampling y\n    //to interpolate between intersection and last point\n    float lh = 0.0f;\n    float ly = 0.0f;\n\n    for( float t = mint; t < maxt; t += dt )\n    {\n        vec3 p = CAM_POS + camPosToFragWorld * t;\n        float s=map(p);\n\n        //if p.y < height of terrain at point p.xz, then we've hit it\n        //since terrain isn't a real distance function, you can't march it like\n        //a normal sdf\n        if ( p.y < s)\n\t\t{\n            vec3 nrm = getNormal(p);\n            vec3 tex = textureLod(iChannel0, p.xz*0.5, 4.0 + dt*10.0).xyz;\n            col = mix(col,tex, nrm.y);\n            \n            //diffuse + ambient light + some fakey light/dark based on y coord\n            col *= 0.15*min(8.0,1.0+p.y) * max(0.0,dot(light1,nrm));\n            col += col * 1.5 * vec3(0.25,0.25,0.5);\n            break;\n\t\t}\n        // allow the error to be proportinal to the distance;\n        dt = 0.005f*t;\n        \n        lh = s;\n        ly = p.y;\n        \n    }\n  \n    vec3 outCol = pow( max(col,0.0), vec3(0.45) );\n    outCol *= vec3(1.1,1.0,1.0);\n    outCol = clamp(col,0.0,1.0);\n\toutCol = col*col*(3.0-2.0*col);\n\toutCol = pow( col, vec3(0.9,1.0,1.0) );\n\toutCol *= 0.3 + 0.7*pow( 16.0*q.x*q.y*(1.0-q.x)*(1.0-q.y), 0.1 );\n\n    fragColor = vec4(outCol, 1.0);\n\n}", "image_inputs": [{"id": "XdfGRn", "previewfilepath": "/media/ap/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg", "ctype": "texture"}, {"id": "Xsf3Rr", "previewfilepath": "/media/ap/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/7sjGDK.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "7sjGDw", "name": "loading_test", "author": "geraldFitz", "description": "simple loading test", "tags": ["loading"], "likes": 1, "viewed": 30, "date": "1617531978", "time_retrieved": "2024-06-20T20:36:32.034062", "image_code": "#define RADIUS_INNER 0.3\n#define RADIUS_OUTER 0.4\n#define GAP 0.05\n\nbool inCircle(vec2 cts, float radius){\n    float a = cts.x + cts.y;\n    return a < radius;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float ref = min(iResolution.x, iResolution.y);\n    float r_in = pow(RADIUS_INNER * ref, 2.);\n    float r_out = pow(RADIUS_OUTER * ref, 2.);\n    float gap = pow(GAP * ref, 2.);\n    \n    vec2 ct = fragCoord - (iResolution.xy / 2.);\n    vec2 ct_s = ct * ct;\n    \n    bool is_inner = inCircle(ct_s, r_in);\n    bool is_outer = inCircle(ct_s, r_out);\n    bool is_gap = ct_s.x < gap;\n    is_gap = is_gap || ct_s.y < gap;\n    bool do_color = is_outer && !is_inner && !is_gap;\n    \n    bool is_right = ct.x > 0.;\n    bool is_up = ct.y > 0.;\n    int seg = int(is_up) + int(is_right) + int(!is_up && is_right)*2;\n    \n    float targ_seg = mod(iTime, 4.);\n    \n    float dist = abs(float(targ_seg) - float(seg));\n    dist = min(dist, abs(dist-4.));\n    \n    //float radius_mid = (RADIUS_OUTER + RADIUS_INNER) / 2.;\n    //float v = 1. / (sin(iTime) * radius_mid - (ct_s.x + ct_s.y));\n    //float u = atan(ct.x, ct.y);\n    //float w = (mod(iTime, 2.0) - 1.) * 1.6;\n    //float v = pow(w-u, 2.);\n    \n    // Output to screen\n    fragColor = vec4(1., 1., 1., 1.) * float(do_color) * dist;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/7sjGDw.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "7sjGRt", "name": "YICHAOW Noise", "author": "wycwyc99a88b", "description": "Noise", "tags": ["noise"], "likes": 1, "viewed": 37, "date": "1617832743", "time_retrieved": "2024-06-20T20:36:33.610084", "image_code": "const int RAY_STEPS = 256;\nconst float PI = 3.14159;\nconst float TWO_PI = 2.0 * PI;\n\n#define LIGHT_POS vec3(0.0, 7.45, 0.0)\n\n#define BACK_WALL 0\n#define LEFT_WALL 1\n#define RIGHT_WALL 2\n#define CEILING 3\n#define FLOOR 4\n#define TALL_BOX 5\n#define SPHERE 6\n\n#define BACK_WALL_SDF plane(pos, vec4(0.0, 0.0, -1.0,5.0))\n#define LEFT_WALL_SDF plane(pos, vec4(1.0, 0.0, 0.0, 5.0))\n#define RIGHT_WALL_SDF plane(pos, vec4(-1.0, 0.0, 0.0, 5.0))\n#define CEILING_SDF plane(pos, vec4(0.0, -1.0, 0.0, 7.5))\n#define FLOOR_SDF plane(pos, vec4(0.0, 1.0, 0.0, 2.5))\n#define TALL_BOX_SDF box(rotateY(pos + vec3(2, 0, -3), 27.5 * 3.14159 / 180.0), 0.5 * vec3(3, 6, 3))\n#define SPHERE_SDF sphere(pos, 1.5, vec3(2.0, 0.0, -3.0))\n\nstruct Intersection\n{\n    float t;\n    vec3 color;\n    vec3 p;\n    int object;\n};\n    \nvec3 rotateY(vec3 p, float a) {\n    return vec3(cos(a) * p.x + sin(a) * p.z, p.y, -sin(a) * p.x + cos(a) * p.z);\n}\n\nvec2 sphereToUV(vec3 p) {\n    // compute phi\n    float phi = atan(p.z, p.x);\n    if(phi < 0.0) {\n        phi += TWO_PI;\n    }\n\n    // compute theta\n    float theta = acos(p.y);\n    return vec2(1.0 - phi / TWO_PI, 1.0 - theta / TWO_PI); // scale to UV\n}\n\nvec2 planeToUV(vec3 o, vec3 n, vec3 p) {\n    vec3 uAxis;\n    vec3 vAxis;\n    \n    vec3 worldUp = vec3(0.0, 1.0, 0.0);\n    uAxis = normalize(cross(worldUp, n));\n    vAxis = normalize(cross(n, uAxis));\n    \n    vec3 diff = p - o;\n    float u = dot(diff, uAxis);\n    float v = dot(diff, vAxis);\n    return vec2(u, v);\n}\n\nvec2 random2( vec2 p ) {\n    return fract(sin(vec2(dot(p, vec2(127.1, 311.7)),\n                 dot(p, vec2(269.5,183.3))))\n                 * 43758.5453);\n}\n\nfloat WorleyNoise(vec2 uv) {\n    uv *= 1.0; // Now the space is 10x10 instead of 1x1. Change this to any number you want.\n    vec2 uvInt = floor(uv);\n    vec2 uvFract = fract(uv);\n    float minDist = 1.0; // Minimum distance initialized to max.\n    for(int y = -1; y <= 1; ++y) {\n        for(int x = -1; x <= 1; ++x) {\n            vec2 neighbor = vec2(float(x), float(y)); // Direction in which neighbor cell lies\n            vec2 point = random2(uvInt + neighbor); // Get the Voronoi centerpoint for the neighboring cell\n            // Animate the point\n            point = 0.5 + 0.5 * sin(iTime + 6.2831 * point); // 0 to 1 range\n            vec2 diff = neighbor + point - uvFract; // Distance between fragment coord and neighbor’s Voronoi point\n            float dist = length(diff);\n            minDist = min(minDist, dist);\n        }\n    }\n    return minDist;\n}\n\nfloat noise2D(vec2 p ) {\n    return fract(sin(dot(p, vec2(127.1, 311.7))) *\n                 43758.5453);\n}\n\nfloat interpNoise2D(float x, float y) {\n    int intX = int(floor(x));\n    float fractX = fract(x);\n    int intY = int(floor(y));\n    float fractY = fract(y);\n\n    float v1 = noise2D(vec2(intX, intY));\n    float v2 = noise2D(vec2(intX + 1, intY));\n    float v3 = noise2D(vec2(intX, intY + 1));\n    float v4 = noise2D(vec2(intX + 1, intY + 1));\n\n    float i1 = mix(v1, v2, fractX);\n    float i2 = mix(v3, v4, fractX);\n    return mix(i1, i2, fractY);\n}\n\n\nfloat fbm(vec2 uv) {\n    float total = 0.0;\n    int octaves = 4;\n    float freq = 2.0;\n    float amp = 0.5;\n\n    for(int i = 1; i <= octaves; i++) {\n        freq *= 2.0;\n        amp *= 0.5;\n        total += interpNoise2D(uv.x * freq,\n                               uv.y * freq) * amp;\n    }\n    return total;\n}\n\nvec3 random3(vec3 p) {\n    return fract(sin(vec3(dot(p,vec3(127.1, 311.7, 191.999)),\n                          dot(p,vec3(269.5, 183.3, 765.54)),\n                          dot(p, vec3(420.69, 631.2,109.21))))\n                 *43758.5453);\n}\n\n\nfloat surflet(vec3 p, vec3 gridPoint) {\n    // Compute the distance between p and the grid point along each axis, and warp it with a\n    // quintic function so we can smooth our cells\n    vec3 t2 = abs(p - gridPoint);\n    float tx = 1.0 - 6.0 * pow(t2.x, 5.0) + 15.f * pow(t2.x, 4.0) - 10.0 * pow(t2.x, 3.0);\n    float ty = 1.0 - 6.0 * pow(t2.y, 5.0) + 15.f * pow(t2.y, 4.0) - 10.0 * pow(t2.y, 3.0);\n    float tz = 1.0 - 6.0 * pow(t2.z, 5.0) + 15.f * pow(t2.z, 4.0) - 10.0 * pow(t2.z, 3.0);\n    vec3 t = vec3(tx, ty, tz);\n    \n    // Get the random vector for the grid point (assume we wrote a function random2\n    // that returns a vec2 in the range [0, 1])\n    vec3 gradient = random3(gridPoint) * 2. - vec3(1., 1., 1.);\n    // Get the vector from the grid point to P\n    vec3 diff = p - gridPoint;\n    // Get the value of our height field by dotting grid->P with our gradient\n    float height = dot(diff, gradient);\n    // Scale our height field (i.e. reduce it) by our polynomial falloff function\n    return height * t.x * t.y * t.z;\n}\n\n\nfloat perlinNoise3D(vec3 p) {\n\tfloat surfletSum = 0.f;\n\t// Iterate over the four integer corners surrounding uv\n\tfor(int dx = 0; dx <= 1; ++dx) {\n\t\tfor(int dy = 0; dy <= 1; ++dy) {\n\t\t\tfor(int dz = 0; dz <= 1; ++dz) {\n\t\t\t\tsurfletSum += surflet(p, floor(p) + vec3(dx, dy, dz));\n\t\t\t}\n\t\t}\n\t}\n\treturn surfletSum;\n}\n\n\n// Box with side lengths b\nfloat box(vec3 p, vec3 b) {\n  return length(max(abs(p) - b, 0.0));\n}\n\nfloat plane( vec3 p, vec4 n ) {\n  // n must be normalized\n  return dot(p,n.xyz) + n.w;\n}\n\nfloat sphere(vec3 p, float r, vec3 c) {\n    return distance(p, c) - r;\n}\n\nvec3 colorPalette(float t) {\n    vec3 a = vec3(0.5, 0.5, 0.5);\n    vec3 b = vec3(0.5, 0.5, 0.5);\n    vec3 c = vec3(1.0, 1.0, 1.0);\n    vec3 d = vec3(0.0, 0.1, 0.2);\n\n    return a + b * cos(2.0 * 3.14159 * (t * c + d));\n}\n\nvec3 computeMaterial(int hitObj, vec3 p, vec3 n, vec3 light) {\n    float t;\n    float lambert = dot(n, light) + 0.2;\n    switch(hitObj) {\n        case BACK_WALL:\n            return colorPalette(WorleyNoise(planeToUV(vec3(0.0, 0.0, -5.0), n, p)));\n        case CEILING:\n        case FLOOR:\n            return vec3(0.85, 0.81, 0.78) * lambert;\n        case TALL_BOX:\n            vec3 pos = 0.5 + 0.5 * sin(iTime + 6.2831 * p); // 0 to 1 range\n            return colorPalette(perlinNoise3D(pos));\n        case SPHERE:\n            vec2 uv = sphereToUV((p - vec3(2.0, 0.0, -3.0)) / 1.5);  \n            uv = 0.5 + 0.5 * sin(iTime + 6.2831 * uv); // 0 to 1 range\n            return colorPalette(fbm(uv));\n            break;\n        case LEFT_WALL:\n            return vec3(0.63, 0.065, 0.05) * lambert;\n            break;\n        case RIGHT_WALL:\n            return vec3(0.14, 0.45, 0.091) * lambert;\n            break;\n        case -1:\n            return vec3(0.0);\n            break;\n    }\n    return vec3(1.0);\n}\n\nfloat sceneMap3D(vec3 pos)\n{\n    float t = BACK_WALL_SDF;\n    t = min(t, LEFT_WALL_SDF);\n    t = min(t, RIGHT_WALL_SDF);\n    t = min(t, CEILING_SDF);\n    t = min(t, FLOOR_SDF);\n    t = min(t, TALL_BOX_SDF);\n    t = min(t, SPHERE_SDF);\n    return t;\n}\n\nvoid sceneMap3D(vec3 pos, out float t, out int obj, vec3 lightPos) {\n    t = BACK_WALL_SDF;\n    obj = BACK_WALL;\n    \n    float t2;\n    if ((t2 = LEFT_WALL_SDF) < t) {\n        t = t2;\n        obj= LEFT_WALL;\n    }\n    if ((t2 = RIGHT_WALL_SDF) < t) {\n        t = t2;\n        obj= RIGHT_WALL;\n    }\n    if ((t2 = CEILING_SDF) < t) {\n        t = t2;\n        obj= CEILING;\n    }\n    if ((t2 = FLOOR_SDF) < t) {\n        t = t2;\n        obj= FLOOR;\n    }\n    if ((t2 = TALL_BOX_SDF) < t) {\n        t = t2;\n        obj= TALL_BOX;\n    }\n    if ((t2 = SPHERE_SDF) < t) {\n        t = t2;\n        obj= SPHERE;\n    }\n}\n\nvoid march(vec3 origin, vec3 dir, out float t, out int hitObj, vec3 lightPos) {\n    t = 0.001;\n    for (int i=0; i < RAY_STEPS; i++) {\n        vec3 pos = origin + t * dir;\n        float m;\n        sceneMap3D(pos, m, hitObj, lightPos);\n        if (m < 0.01) {\n            return;\n        }\n        t += m;\n    }\n    t = -1.0;\n    hitObj = -1;\n}\n\nvec3 computeNormal(vec3 pos) {\n    vec3 epsilon = vec3(0.0, 0.001, 0.0);\n    return normalize(vec3(sceneMap3D(pos + epsilon.yxx) - sceneMap3D(pos - epsilon.yxx),\n                          sceneMap3D(pos + epsilon.xyx) - sceneMap3D(pos - epsilon.xyx),\n                          sceneMap3D(pos + epsilon.xxy) - sceneMap3D(pos - epsilon.xxy)));\n}\n\nIntersection sdf3D(vec3 dir, vec3 eye, vec3 lightPos) {\n    float t;\n    int hitObj;\n    march(eye, dir, t, hitObj, lightPos);\n    \n    vec3 point = eye + t * dir;\n    vec3 nor = computeNormal(point);\n    vec3 lightDir = normalize(lightPos - point);\n    vec3 surfaceColor = computeMaterial(hitObj, point, nor, lightDir);\n    return Intersection(t, surfaceColor, point, hitObj);\n}\n\nvoid raycast(vec2 uv, out vec3 dir, out vec3 eye, out vec3 ref) {\n    eye = vec3(0.0, 5.5, -30);\n    ref = vec3(0.0, 2.5, 0.0);\n    \n    float len = tan(0.3403392 * 0.75) * distance(eye, ref);\n    vec3 H = normalize(cross(vec3(0.0, 1.0, 0.0), ref - eye));\n    vec3 V = normalize(cross(H, eye - ref));\n    V *= len;\n    H *= len * iResolution.x / iResolution.y;\n    vec3 p = ref + uv.x * H + uv.y * V;\n    dir = normalize(p - eye);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // [-1, 1]\n    vec2 uv2 = 2.0 * uv - vec2(1.0);\n    \n    vec3 dir, eye, ref;\n    raycast(uv2, dir, eye, ref);\n    \n    // Time varying pixel color\n    Intersection isect = sdf3D(dir, eye, LIGHT_POS);\n    vec3 col = isect.color;\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/7sjGRt.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "7sjGWG", "name": "Approx. Sub. Scatter - CIS461", "author": "onlyname", "description": "Cornell box with approximated subsurface scattering.", "tags": ["raymarch", "subsurface"], "likes": 0, "viewed": 49, "date": "1617908868", "time_retrieved": "2024-06-20T20:36:34.840368", "image_code": "const int RAY_STEPS = 256;\nconst int AO_SAMPLES = 256;\nconst float AO_DIST = 0.085;\nconst float AO_K = 2.0;\nconst float HALF_PI = 3.14159 * 0.5;\nconst float DEG_TO_RAD = 3.14159 / 180.0;\n// The larger the DISTORTION, the smaller the glow\nconst float DISTORTION = 0.2;\n// The higher GLOW is, the smaller the glow of the subsurface scattering\nconst float GLOW = 3.0;\n// The higher the BSSRDF_SCALE, the brighter the scattered light\nconst float SCALE = 3.0;\n// Boost the shadowed areas in the subsurface glow with this\nconst float AMBIENT = 0.0;\n\n\n#define AA true\n\nstruct Intersection\n{\n    float t;\n    vec3 color;\n    vec3 p;\n    int object;\n};\n\nfloat subsurfaceColor(vec3 lightDir, vec3 normal, vec3 viewVec, float thin) {\n\tvec3 scatterDir = lightDir + normal * DISTORTION;\n\tfloat lightReachingEye = pow(clamp(dot(viewVec, -scatterDir), 0.0, 1.0), GLOW) * SCALE;\n\tfloat attenuation = 1.0;\n    // attentuation = max(0.0, dot(normal, lightDir) + dot(viewVec, -lightDir));\n\tfloat totalLight = attenuation * (lightReachingEye + AMBIENT) * thin;\n\treturn totalLight;\n}\n\nvec3 rotateX(vec3 p, float a) {\n    return vec3(p.x, cos(a) * p.y - sin(a) * p.z, sin(p.y) + cos(p.z));\n}\n\nvec3 rotateY(vec3 p, float a) {\n    return vec3(cos(a) * p.x + sin(a) * p.z, p.y, -sin(a) * p.x + cos(a) * p.z);\n}\n\nvoid raycast(vec2 uv, out vec3 dir, out vec3 eye, out vec3 ref) {\n    eye = vec3(0.0, 4, -12.0);\n    ref = vec3(0.0, 0.0, 0.0);\n    \n    float len = tan(3.14159 * 0.125) * distance(eye, ref);\n    vec3 H = normalize(cross(vec3(0.0, 1.0, 0.0), ref - eye));\n    vec3 V = normalize(cross(H, eye - ref));\n    V *= len;\n    H *= len * iResolution.x / iResolution.y;\n    vec3 p = ref + uv.x * H + uv.y * V;\n    dir = normalize(p - eye);\n}\n\nfloat sphere(vec3 p, float r, vec3 c)\n{\n    return distance(p, c) - r;\n}\n\nfloat torus(vec3 p, vec2 t)\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q) - t.y;\n}\n\nfloat cone(vec3 p, vec2 c)\n{\n    // c must be normalized\n    float q = length(p.xy);\n    return dot(c,vec2(q,p.z));\n}\n\n// Box with side lengths b\nfloat box(vec3 p, vec3 b)\n{\n  return length(max(abs(p) - b, 0.0));\n}\n\nfloat plane( vec3 p, vec4 n )\n{\n  // n must be normalized\n  return dot(p,n.xyz) + n.w;\n}\n\n#define BACK_WALL plane(pos, vec4(0.0, 0.0, -1.0, 5.0))\n#define LEFT_WALL plane(pos, vec4(1.0, 0.0, 0.0, 5.0))\n#define RIGHT_WALL plane(pos, vec4(-1.0, 0.0, 0.0, 5.0))\n#define CEILING plane(pos, vec4(0.0, -1.0, 0.0, 7.5))\n#define FLOOR plane(pos, vec4(0.0, 1.0, 0.0, 2.5))\n#define SPHERE_2 sphere(pos, 1.5, vec3(2.0, -0.5, -2.5))\n#define SPHERE sphere(pos, 3.0, vec3(0.0, 0.0, 1.0))\n\n#define BACK_WALL_NUM 0\n#define LEFT_WALL_NUM 1\n#define RIGHT_WALL_NUM 2\n#define CEILING_NUM 3\n#define FLOOR_NUM 4\n#define SPHERE_2_NUM 5\n#define SPHERE_NUM 6\n\nfloat sceneMap3D(vec3 pos, vec3 lightPos)\n{\n    float t = BACK_WALL;\n    t = min(t, LEFT_WALL);\n    t = min(t, RIGHT_WALL);\n    t = min(t, CEILING);\n    t = min(t, FLOOR);\n    t = min(t, SPHERE_2);\n    t = min(t, SPHERE);\n    return t;\n}\n\nvoid sceneMap3D(vec3 pos, out float t, out int obj, vec3 lightPos)\n{\n    t = BACK_WALL;\n    float t2;\n    obj = BACK_WALL_NUM;\n    if((t2 = LEFT_WALL) < t) {\n        t = t2;\n        obj = LEFT_WALL_NUM;\n    }\n    if((t2 = RIGHT_WALL) < t) {\n        t = t2;\n        obj = RIGHT_WALL_NUM;\n    }\n    if((t2 = CEILING) < t) {\n        t = t2;\n        obj = CEILING_NUM;\n    }\n    if((t2 = FLOOR) < t) {\n        t = t2;\n        obj = FLOOR_NUM;\n    }\n    if((t2 = SPHERE_2) < t) {\n        t = t2;\n        obj = SPHERE_2_NUM;\n    }\n    if((t2 = SPHERE) < t) {\n        t = t2;\n        obj = SPHERE_NUM;\n    }\n}\n\nvoid march(vec3 origin, vec3 dir, out float t, out int hitObj, vec3 lightPos)\n{\n    t = 0.001;\n    for(int i = 0; i < RAY_STEPS; ++i)\n    {\n        vec3 pos = origin + t * dir;\n    \tfloat m;\n        sceneMap3D(pos, m, hitObj, lightPos);\n        if(m < 0.01)\n        {\n            return;\n        }\n        t += m;\n    }\n    t = -1.0;\n    hitObj = -1;\n}\n\nvec3 computeNormal(vec3 pos, vec3 lightPos)\n{\n    vec3 epsilon = vec3(0.0, 0.001, 0.0);\n    return normalize( vec3( sceneMap3D(pos + epsilon.yxx, lightPos) - sceneMap3D(pos - epsilon.yxx, lightPos),\n                            sceneMap3D(pos + epsilon.xyx, lightPos) - sceneMap3D(pos - epsilon.xyx, lightPos),\n                            sceneMap3D(pos + epsilon.xxy, lightPos) - sceneMap3D(pos - epsilon.xxy, lightPos)));\n}\n\nfloat fiveTap(vec3 p, vec3 n, float k, vec3 lightPos) {\n    float aoSum = 0.0;\n    for(float i = 0.0; i < 5.0; ++i) {\n        float coeff = 1.0 / pow(2.0, i);\n        aoSum += coeff * (i * AO_DIST - sceneMap3D(p + n * i * AO_DIST, lightPos));\n    }\n    return 1.0 - k * aoSum;\n}\n\nvec3 computeMaterial(int hitObj, vec3 p, vec3 n, vec3 light, vec3 view, float thick) {\n    float lambert = max(0.0, dot(n, light)) + 0.2;\n\n    switch(hitObj) {\n        case BACK_WALL_NUM:\n        case CEILING_NUM:\n        case FLOOR_NUM:\n        return vec3(0.85, 0.81, 0.78) * lambert;\n        break;\n        case LEFT_WALL_NUM:\n        return vec3(0.63, 0.065, 0.05) * lambert;\n        break;\n        case RIGHT_WALL_NUM:\n        return vec3(0.14, 0.45, 0.091) * lambert;\n        break;\n        case SPHERE_2_NUM:\n        return vec3(0.3, 0.75, 0.5) * lambert + vec3(0.3, 0.8, 0.8) *\n                subsurfaceColor(light, n, view, thick);\n        break;\n        case SPHERE_NUM:\n        return vec3(1.0, 0.88, 0.7) * lambert + vec3(1.0, 0.67, 0.67) *\n                subsurfaceColor(light, n, view, thick);\n        break;\n        case -1:\n        // Background\n        return vec3(0.0);\n        break;\n    }\n    return vec3(1.0);\n}\n\nIntersection sdf3D(vec3 dir, vec3 eye, vec3 lightPos)\n{\n    float t;\n    int hitObj;\n    march(eye, dir, t, hitObj, lightPos);\n\n    vec3 isect = eye + t * dir;\n    vec3 nor = computeNormal(isect, lightPos);\n    vec3 lightDir = normalize(lightPos - isect);\n    \n    float thick = fiveTap(isect, -nor, AO_K, lightPos);\n    \n    vec3 surfaceColor = computeMaterial(hitObj, isect, nor, lightDir, normalize(eye - isect), thick);\n    \n    return Intersection(t, surfaceColor, isect, hitObj);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float di = 2.0 * (sin(iTime));\n\tvec3 lightPos = vec3(di, -1.0, 4.0);\n    \n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    // [-1, 1]\n    vec2 uv2 = 2.0 * uv - vec2(1.0);\n    \n    Intersection aaIsects[4];\n    vec3 dir, eye, ref;\n    int idx = 0;\n    for(float i = 0.0; i < 1.0; i += 0.5) {\n        for(float j = 0.0; j < 1.0; j += 0.5) {\n            raycast(uv2 + vec2(i, j) / iResolution.xy, dir, eye, ref);\n            aaIsects[idx++] = sdf3D(dir, eye, lightPos);\n        }\n    }\n    vec3 avgColor = vec3(0.0);\n    for(int i = 0; i < 4; ++i) {\n        avgColor += aaIsects[i].color;\n    }\n    avgColor *= 0.25;\n    fragColor = vec4(avgColor * step(0.0, aaIsects[0].t), 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/7sjGWG.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "7sjGWt", "name": "Mandelbulb ao", "author": "kithy", "description": "mandelbulb,fractal,ambient occlusion,raymarching", "tags": ["raymarching", "fractal", "mandelbulb", "ambientocclusion"], "likes": 2, "viewed": 85, "date": "1618146355", "time_retrieved": "2024-06-20T20:36:34.846441", "image_code": "#define EPS 0.001\n#define POWER 8.0\n#define ITR 15\n#define MAX_DIST 64\n#define PI 3.1415\n\n\nmat2 rot(float a){\n\tfloat s=sin(a);\n\tfloat c=cos(a);\n\treturn mat2(c,-s,s,c);\n}\n\n\nfloat mandelbulb(vec3 p){\t\n\n\tfloat power=1.0+(POWER-1.0)*(0.5-cos(PI)*0.5);\n\tvec3 z=p;\n\tfloat dr=1.0;\n\tfloat r=0.0;\n\tfor(int i=0;i<ITR;i++){\n\t\tr=length(z);\n\t\tif(r>3.0)break;\n\n\t\tfloat theta=acos(z.z/r);\n\t\tfloat phi=atan(z.y,z.x);\n\n\t\tdr=pow(r,power-1.0)*power*dr+1.0;\n\n\t\tfloat zr=pow(r,power);\n\t\ttheta*=power;\n\t\tphi*=power;\n\n\t\tz=zr*vec3(sin(theta)*cos(phi),sin(phi)*sin(theta),cos(theta));\n\t\tz+=p;\n\t}\n\treturn 0.5*log(r)*r/dr;\n}\n\nfloat mainDist(vec3 p){\n\tp.xz*=rot(iTime*0.5);\n\tp.yz*=rot(iTime*0.5);\n\t//p=mod(p,8.0)-4.0;\n\t\n\treturn mandelbulb(p);\n}\n\nvec3 rayMarch(const vec3 eye,const vec3 ray,out float depth,out float steps){\n\tdepth=0.0;\n\tsteps=0.0;\n\tfloat dist;\n\tvec3 rp;\n\n\tfor(int i=0;i<MAX_DIST;i++){\n\t\trp=eye + depth*ray;\n\t\tdist = mainDist(rp);\n\t\tdepth+= dist;\n\t\tsteps++;\n\t\tif(dist<EPS)break;\n\t}\n\t\n\treturn rp;\n}\n\nvec3 genNormal(vec3 p){\n\treturn normalize(vec3(\n\t\tmainDist(vec3(p.x+EPS,p.y,p.z))-mainDist(vec3(p.x-EPS,p.y,p.z)),\n\t\tmainDist(vec3(p.x,p.y+EPS,p.z))-mainDist(vec3(p.x,p.y-EPS,p.z)),\n\t\tmainDist(vec3(p.x,p.y,p.z+EPS))-mainDist(vec3(p.x,p.y,p.z-EPS))\n\t));\n}\n\nfloat color(float val,float offset,float level){\n\treturn clamp((val-level)*(1.0+offset)+level,0.0,1.0);\n}\n\nvoid mainImage(out vec4 fragColor,in vec2 fragCoord){\n\tvec2 uv=(2.0*fragCoord.xy-iResolution.xy)/iResolution.y;\n\n\tvec3 ray=normalize(vec3(uv,1.0));\n\t\n\tvec3 camPos=vec3(0.0,0.0,-2.0);\n\n\tfloat depth=0.0;\n\tfloat steps=0.0;\n\tvec3 rp=rayMarch(camPos+EPS*ray,ray,depth,steps);\n\n\t\n\tfloat ao=steps*0.01;\n\tao=1.0-ao/(ao+0.5);\n\tfloat offset=0.3;\n\tfloat level=0.5;\n\tao=color(ao,offset,level);\n\tfragColor=vec4(vec3(ao),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/7sjGWt.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "7sjSRh", "name": "what is a parabola", "author": "elenzil", "description": "reminding myself what a parabola is.\nturns out it's the set of points equidistant from a point and a line.\nwho knew ???", "tags": ["parabola"], "likes": 4, "viewed": 140, "date": "1619664889", "time_retrieved": "2024-06-20T20:36:34.846441", "image_code": "float sdCircle(in vec2 p, in vec2 c, in float r) {\n    return length(p - c) - r;\n}\n\nmat2 rot2(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat2(c, s, -s, c);\n}\n\nvoid mainImage( out vec4 RGBA, in vec2 XY )\n{\n    vec2 c  = iMouse.x > 50.0 ? iMouse.xy : vec2(cos(iTime * 0.32), sin(iTime * 0.3)) * (min(iResolution.x, iResolution.y)/2.0 - 110.0) + iResolution.xy/2.0;\n    float d1 = abs(((XY - iResolution.xy / 2.0) * rot2(iTime * 0.11)).y);\n    float d2 = sdCircle(XY, c, 100.0);\n    float d3 = sdCircle(XY, c,   0.0);\n    float d4 = sdCircle(XY, iResolution.xy / 2.0, 100.0);\n    \n   \n    RGBA.a  = 1.0;\n    \n    // equidistance from a circle and a line\n    RGBA.r  = smoothstep(3.0, 1.0, abs(d1 - d2) / fwidth(d1 - d2));\n\n    // equidistance from a point and a line\n    RGBA.g  = smoothstep(3.0, 1.0, abs(d1 - d3) / fwidth(d1 - d2));\n    \n    // equidistance from a circle and a point\n    RGBA.rg = max(RGBA.rg, smoothstep(3.0, 1.0, abs(d3 - d4) / fwidth(d3 - d4)));\n\n    RGBA.b  = 0.0;\n    RGBA.b  = max(RGBA.b, smoothstep(3.0, 1.0, abs(d1)));\n    RGBA.b  = max(RGBA.b, smoothstep(3.0, 1.0, abs(d2)));\n    RGBA.b  = max(RGBA.b, smoothstep(3.0, 1.0, abs(d4)));\n    RGBA.b  = max(RGBA.b, smoothstep(3.0, 1.0, abs(sdCircle(XY, c,   1.0))));\n    \n    \n    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/7sjSRh.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "7sjSRz", "name": "TorusKnotSurface-Test", "author": "antoinefortin", "description": "Antoine", "tags": ["antoine"], "likes": 0, "viewed": 13, "date": "1619584580", "time_retrieved": "2024-06-20T20:36:36.452655", "image_code": "vec2 rotate(vec2 pos, float angle)\n{\n\tfloat c = cos(angle);\n    float s = sin(angle);\n    \n    return mat2(c,s,-s,c) * pos;\n\n}\n\nmat2 Rot(float a) {\n    float s = sin(a);\n    float c = cos(a);\n    return mat2(c, -s, s, c);\n}\n\n\nvec3 R(vec2 uv, vec3 p, vec3 l, float z) {\n    vec3 f = normalize(l-p),\n        r = normalize(cross(vec3(0,1,0), f)),\n        u = cross(f,r),\n        c = p+f*z,\n        i = c + uv.x*r + uv.y*u,\n        d = normalize(i-p);\n    return d;\n}\n\n\n\n/* SDF */\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r )\n{\n  vec3 pa = p - a, ba = b - a;\n  float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n  return length( pa - ba*h ) - r;\n}\n\nfloat sdSphere(vec3 pos, float r)\n{\n\treturn length(pos) - r;\n}\n\nfloat sdPlane(vec3 pos)\n{\n\treturn pos.y;\n}\nfloat sdHexPrism( vec3 p, vec2 h )\n{\n  const vec3 k = vec3(-0.8660254, 0.5, 0.57735);\n  p = abs(p);\n  p.xy -= 2.0*min(dot(k.xy, p.xy), 0.0)*k.xy;\n  vec2 d = vec2(\n       length(p.xy-vec2(clamp(p.x,-k.z*h.x,k.z*h.x), h.x))*sign(p.y-h.x),\n       p.z-h.y );\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\n\nvec2 opu(vec2 d1, vec2 d2)\n{\n\treturn (d1.x < d2.x) ? d1 : d2;\n}\n\nfloat sdCone( in vec3 p, in vec2 c, float h )\n{\n  // c is the sin/cos of the angle, h is height\n  // Alternatively pass q instead of (c,h),\n  // which is the point at the base in 2D\n  vec2 q = h*vec2(c.x/c.y,-1.0);\n    \n  vec2 w = vec2( length(p.xz), p.y );\n  vec2 a = w - q*clamp( dot(w,q)/dot(q,q), 0.0, 1.0 );\n  vec2 b = w - q*vec2( clamp( w.x/q.x, 0.0, 1.0 ), 1.0 );\n  float k = sign( q.y );\n  float d = min(dot( a, a ),dot(b, b));\n  float s = max( k*(w.x*q.y-w.y*q.x),k*(w.y-q.y)  );\n  return sqrt(d)*sign(s);\n  \n}\n\n\nfloat h(vec2 p)\n{\n    \n\tfloat ba = texture(iChannel1, (p * 0.005) + (iTime * .005)).x;  \n    float ba2 = texture(iChannel1, (p * 1.0025) + (iTime * .005)).x;  \n   \n    return ba + ba2;\n}\n\n\n\n\nfloat sdEllipsoid( vec3 p, vec3 r )\n{\n  float k0 = length(p/r);\n  float k1 = length(p/(r*r));\n  return k0*(k0-1.0)/k1;\n}\n\n\n\n\nvec2 map(vec3 pos)\n{\n    \n    /*\n    \n    */\n    float r1 = 3.7, r2 = .22;\n    vec2 cp = vec2(length(pos.xz)-r1, pos.y);\n    float a = atan(pos.x, pos.z);\n    \n    float a2 = atan(pos.z * 2., pos.x);\n    \n    \n    cp *= Rot(a * 3.5);\n    cp *= Rot(a2 * (cos(iTime * .25) * 12.5)) + .25;\n    \n    cp.y = abs(cp.y) - .1;\n    \n    float d = length(cp) - (r2);\n    \n\n    \n    float theFloor = sdPlane(pos);\n    float box = sdBox(pos, vec3(1.));\n\t\n    vec2 res =     vec2(d,       1.0 /*Object ID*/);\n  \t\n//    res = opu(res, vec2(arms, 3.));\n    \n    res.x *= .025;\n    return res;\n}\n\n\nvec2 castRay(vec3 ro, vec3 rd)\n{\n\n    float t = 0.0;\n    float id = -20.;\n\tfloat farClippingPlane = 60.0;\n    \n    for(int i = 0; i < 256; i++)\n    {\n        \n    \tvec3 pos = ro + t * rd;\n        float h = map(pos).x;\n        id = map(pos).y;\n        \n        if(h < 0.001)\n        {\n        \tbreak;\n        }\n        t += h;\n        if(t > farClippingPlane) break;\n        \n    }\n    \n    if(t > farClippingPlane) t = -1.0;\n    \n    return vec2(t, id);\n}\n\nvec3 calcNormal(vec3 pos)\n{\n    vec2 e = vec2(0.01, 0.0);\n    \n\treturn normalize(vec3(\n        \t\t\t\t\tmap(pos+e.xyy).x - map(pos-e.xyy).x,\n        \t\t\t\t\tmap(pos+e.yxy).x - map(pos-e.yxy).x,\n        \t\t\t\t\tmap(pos+e.yyx).x - map(pos-e.yyx).x\n    \t\t\t\t));\n}\n\nvoid resetToZero(inout vec3 r)\n{\n\tr = vec3(0.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\t\n \n    \n    vec2 m = iMouse.xy/iResolution.xy;\n    \n\tvec3 ro = vec3(0., 2.55 ,-9.5);\n\t//vec3 rd = normalize(vec7(uv.x, uv.y - .2,1.)); \n    ro.yz *= Rot(-m.y+.4);\n    ro.xz *= Rot(m.x * 12.);\n\tvec3 rd = R(uv, ro, vec3(0,0.0,0), .7);\n\tvec3 col = vec3(.22);\n\t\n\t\n\tfloat hitDistance = castRay(ro, rd).x;\n    float objectId = castRay(ro, rd).y;\n    \n    vec3 unfinishedSky;\n    \n    // No hit color\n    if(hitDistance < 0.01)\n    {\n        \n        /* Sky properties*/\n        vec3 skyColor = vec3(.4, 0.75, 18.0);\n        float skyMovement = .5;\n\t\tcol = skyColor - abs( .5 + sin(iTime * skyMovement)) * rd.y * rd.x;\n        \n        \n        \n    }\n    \n    \n    if(hitDistance > 0.)\n    {\n       \tvec3 debugColor = vec3(1.);\n        vec3 pos = ro + hitDistance * rd;\n        vec3 normalWS = calcNormal(pos);\n\n        /* Global Lighting section */\n        \n        // Sky\n        vec3 skyColor = vec3(.4, 0.75, 1.0);\n\t\tfloat skyMovement = .5;\n        vec3 skyColFactor = skyColor - abs( .5 + sin(iTime * skyMovement)) * rd.y * rd.x;\n\t\t\n        // Basic lighting\n        vec3 sunPos = normalize(vec3(.5, 1.4, -.52));\n \t\tfloat fSunDiffuse = clamp(dot(normalWS, sunPos), 0., 1.);\n        float sunShadow = smoothstep(castRay(pos + normalWS * 0.001, sunPos).x, 0., 1.);\n\t\tfloat skyDif = dot(normalWS,vec3(0.,1.0,0.));\n        vec3 basicColor = vec3(.5, 0.75, 0.8) * (fSunDiffuse + (skyDif * .5)) * sunShadow;\n        col = basicColor * (skyColFactor * 1.75);\n\n        \n        \n        //col = skyColFactor;\n        /*End of Global Lighting section */\n        \n        \n        bool materialSystem = true;\n        \n        if(materialSystem)\n        {\n            float blendingFactor = .5;\n\t\t\t// Sphere\n        \tif(objectId == 1.0) \n        \t{\n        \t\tvec3 sphereMat = vec3(3.2, .5, .6);\n                col = col * sphereMat;\n                col += (sphereMat * .5);\n        \t}\n        \n        \t// Floor\n        \tif(objectId == 2.0)\n       \t\t{\n                /* Floor settings*/\n               \tfloat gridXF = 25.0f;\n\t\t\t\tfloat gridYF = 25.0f;\n                float changeFactor = iTime * .5;\n        \t\tvec3 floorColor = vec3(.25, .45, .3);\n\t\t\t\t// displace the floor\n                pos.x += sin(iTime * .2);\n                pos.z += cos(iTime * .2);\n                float f = .5 + abs(sin( sin(changeFactor) * (sin(pos.x * gridXF) * cos(pos.z * gridYF))));\n               \tvec3 pattern = vec3(f / 5.);\n                col = pattern * col + vec3(0., .22, 0.);\n                \n                {\n                 //resetToZero(col);\n                }\n        \t}\n            // trunk\n            if(objectId == 3.0)\n            {\n                vec3 trunk = vec3(255) / vec3(210,105,30);\n            \tcol = vec3(.8, .5, .2) * vec3(dot(normalWS, sunPos));\n            }\n            \n            // leaves\n            if(objectId == 4.)\n            {\n\t\t\t\t\n            \tcol = vec3(.4, .95, .2) * vec3(dot(normalWS, sunPos));\n            }\n            \n            /*Sapin*/\n            \n            if(objectId == 5.)\n            {\n                \n                // Get the position of the hit.\n                // Well it is pos...\n                // SO \n                float shadingAmoutOnClouds = dot(normalWS, sunPos);\n                vec3 bloop = texture(iChannel0, uv * 2.).xxx;\n            \tcol = vec3(shadingAmoutOnClouds) * bloop * 5.;\n            }\n            \n          // water\n\t\t\tif(objectId == 6.)\n            {\n                \n                // Get the position of the hit.\n                // Well it is pos...\n                // SO \n                \n\t\t\t\tvec3 waterC = vec3(dot(normalWS,sunPos + pos * .5));\n\t\t\t\tfloat hitDistance = castRay(ro, rd).x;\n    \t\t\tfloat objectId = castRay(ro, rd).y;\n                vec3 wcF =  (sin(uv.y * 120.) * uv.y * sin(uv.x * 120.)) * waterC * vec3(cos(hitDistance * pos.x), sin(objectId * 120.), cos(sin(waterC * hitDistance)));\n\t\t\t\tcol = waterC.xxx * (abs(wcF.xxx) + .5)  * vec3(.1, .15, .75);\n                col += vec3(0., 0., .4);\n                \n            }\n            \n            \n            \n            \n        }\n\n        \n        col = col;\n       \n        /*\n       \tvec3 sundir = normalize(vec3(0.2, 0.4, 0.2));\n        float sundif = clamp(dot(nor, sundir), 0.0, 1.0);\n        float sun_sha = smoothstep(castRay(pos + nor * 0.001, sundir).x,0., 1.);\n        float sky_dif = clamp(dot(nor,vec3(0.0,1.0,0.0)), 0.0, 1.0);;\n        \n        col = vec3(1.0, 0.7, 0.5) * sundif * sun_sha;\n        col += vec3(0.0, 0.2, 0.4) * sky_dif;\n\t\tcastRay(ro, rd).x */    \n\t}\n    // Output to screen\n    fragColor = vec4(sqrt(col),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/7sjSRz.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "7slSDM", "name": "Bitwise cloud landscape", "author": "jarble", "description": "A cloudy landscape generated using a bitwise formula.", "tags": ["fractal", "cloud", "bitwise"], "likes": 5, "viewed": 158, "date": "1618715097", "time_retrieved": "2024-06-20T20:36:36.452655", "image_code": "#define ITERS 9\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Scale and move to make things a litle more interesting t look at.\n    float scale = 2000.0;\n    float trans = iTime * 200.0;\n    vec2 coord = (scale * fragCoord/iResolution.xy) + vec2(trans+30000.0,0.0);\n    \n    int val = 0;\n    float result = 0.0;\n    vec3 col = vec3(0.0);\n    vec3 col_prev = vec3(0.0);\n    for(int i = 0; i < ITERS; i++){\n        col_prev = col;\n        coord.y -= (result-11.0);\n        coord += coord.yy/32.0+col.x;\n        coord = coord.yx/(2.5);\n        result = ((result + float(val = ((int(coord.x+coord.y/2.0) & int(coord.y+coord.x/2.0)) % 3)))/(2.0));\n        col.x = result;\n        col = ((col.yzx)*2.0+col_prev)/3.5;\n    }\n    // Output.\n    fragColor = vec4((col),0.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/7slSDM.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "7slSDS", "name": "Iridescent portals", "author": "jarble", "description": "An edit of my \"Alien technology\" fractal.", "tags": ["fractal", "metal", "shiny", "portal"], "likes": 4, "viewed": 194, "date": "1619178527", "time_retrieved": "2024-06-20T20:36:36.452655", "image_code": "#define pattern vec3(0.0,0.0,0.0)\n//#define pattern vec2(2.0,2.0)\n//#define pattern vec2(2.0,iTime)\n\n#define ITERS 12\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.0);\n    vec3 col=vec3(0.0),col_prev=vec3(0.0);\n    float t=0.0;\n    vec2 uv = (fragCoord*10.0-iResolution.xy)/iResolution.y/20.0;\n    uv.y += (iTime)/25.0;\n    for(int c=0;c<ITERS;c++){\n        float scale = 2.16;\n        float scale1 = 1.16;\n        col_prev = col;\n        \n        for(int i=0;i<ITERS;i++)\n        {\n            float uv1 = uv.x-uv.y;\n            uv= fract(pattern.z-uv-(((vec2(uv1+pattern.x*col.x,-pattern.y-uv1))/(scale1*scale*scale))))/scale1;\n            uv.x *= scale1;\n            uv = fract(pattern.z+uv.yx);\n            uv.y /= -scale1;\n        }\n        col[2] = abs(fract(uv.y)-fract(uv.x));\n        col = ((col+col_prev.yzx))/2.125;\n\t}\n    fragColor = vec4(vec3(col*3.0),1.0);\n    \n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/7slSDS.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "7slSz7", "name": "Textile fiber", "author": "jarble", "description": "This fractal looks like a close-up photo of textile fibers.", "tags": ["fractal", "textile", "fibers"], "likes": 1, "viewed": 129, "date": "1618430324", "time_retrieved": "2024-06-20T20:36:36.452655", "image_code": "// Inspired by a discussion on hackaday at:\n// https://hackaday.com/2021/04/13/alien-art-drawn-with-surprisingly-simple-math/\n// Formula shared by \"Joe\" on that page..\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Scale and move to make things a litle more interesting t look at.\n    float scale = 0.2;\n    float trans = iTime * 25.0;\n    vec2 coord = (scale * fragCoord) + vec2(trans,trans);\n    \n    // Heart of color selection.\n    int val = ((int(coord.x) & int(coord.y)) % 3);\n    float result = 0.0;\n    vec3 col = vec3(0.0);\n    for(int i = 0; i < 6; i++){\n        coord.y -= (3.0-result);\n        coord = coord.yx/3.0+coord.xx/(3.0);\n        result = ((result + float(val = ((int(coord.x+coord.y) & int(coord.y)) % 3)))/(2.0));\n        col.x = (result*2.0+col.z)/3.0;\n        col = col.yzx;\n    }\n    // Output.\n    fragColor = vec4((col/2.0),0.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/7slSz7.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "7slXW2", "name": "Quilez Basic Raytracer II", "author": "GuroGuru", "description": "Studying Iñigo Quilez basic raytracer. Using sphere intersector.", "tags": ["raytracing", "sphere", "intersector"], "likes": 0, "viewed": 22, "date": "1619290195", "time_retrieved": "2024-06-20T20:36:36.652503", "image_code": "// Intersectors: https://www.iquilezles.org/www/articles/intersectors/intersectors.htm\nfloat sphereIntersector( vec3 ro, vec3 rd ) \n{\n    vec3 ce = vec3(4.0*sin(iTime));\n    vec3 oc = ro - ce;\n    float r = 2.0;\n    float b = 2.0 * dot(oc,rd);\n    float c = dot(oc, oc) - r*r;\n    float h = b*b - 4.0*c;\n    return h < 0.0 ? -1.0 : (-b - sqrt(h))/2.0;\n}\n\n// Raytracer: https://www.youtube.com/watch?v=9g8CdctxmeU\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Time varying pixel color\n    vec3 col = 0.5 + 0.5*cos( iTime+uv.xyx + vec3( 0, 2, 4 ) );\n\n    // Ray\n    vec3 ro = vec3( 0.0, 0.0, 4.0 );\n    vec3 rd = normalize( vec3( ( -1.0 + 2.0 * uv ) * vec2( 1.78, 1.0 ), -1.0 ) );\n\n    // Intersection\n    float id = sphereIntersector( ro, rd ) * 1.5; \n    \n\n    // Output to screen\n    fragColor = vec4(col + 0.15, 1.0) * id + vec4(col + 0.1, 1.0) * (1.0 - id);\n    \n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/7slXW2.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "7slXWX", "name": "472_raymarch_wip3", "author": "asneakyfatcat", "description": "continuing project to learn raymarching. Tried noise distortion but I haven't gotten it dialed in as noise makes everything look shit with a small epsilon value so maybe its due to float precision.", "tags": ["phong", "raymarch", "blinn", "soundcloud"], "likes": 1, "viewed": 56, "date": "1619379914", "time_retrieved": "2024-06-20T20:36:38.228547", "image_code": "// I would add more to this but it's turned into spaghetti code by this point.\n// With what I learned from this project it would be better to just start over\n// and design a new shader from the ground up(see lighting / material ID / camera clusterfuck)\n\n// todo: add texture mapping (triplanar mapping?)\n//       get noise distortion to be smooth\n//       find out how to dial in frequency range on sound texture\n//       add in more flight falloff. (turn down the absurd ammount of ambient light)\n\n\nconst int max_steps=255;\nconst float min_dist=0.;\nconst float max_dist=100.;\nconst float epsilon=0.0001;\n\n////////////////////////////////////////////////////////////////////////////////\n////////////////////////////////////////////////////////////////////////////////\n// unused, wanted to see if I could use structs in glsl/shadertoy\nstruct material\n{\n    vec3 ambient;\n    vec3 diffuse;\n    vec3 specular;\n    float shine;\n};\n// primitive operations http://jamie-wong.com/2016/07/15/ray-marching-signed-distance-functions/\nfloat intersect(float a,float b){\n    return max(a,b);\n}\nvec2 U(vec2 a,vec2 b){\n    if(a.x<b.x){return a;}\n    else return b;\n    //return vec2(min(a.x,b.x),a.y+b.y);\n}\nfloat difference(float a, float b){\n    return max(a,-b);\n}\n// smooth min https://www.shadertoy.com/view/MtdBzs\nvec2 sMin(vec2 a, vec2 b,float c){\n        float h = max(c-abs(a.x-b.x), 0.0);\n        vec2 t = vec2(0.);\n        if(a.x<b.x){t=a;}\n        else t=b;\n        return vec2(t.x - h*h*h/(6.0*c*c),t.y);\n}\n\n// SDF primitives https://www.iquilezles.org/www/articles/distfunctions/distfunctions.htm\n\nfloat plane(vec3 p, vec3 n, float h){\n    return dot(p,normalize(n))+h;\n}\n\nfloat sphere(vec3 p,float r){\n    // point, radius\n    return length(p)-r;\n}\nfloat torus(vec3 p, vec2 t){\n    vec2 q = vec2(length(p.zx)-t.x,p.y);\n    return length(q)-t.y;\n}\nfloat octahedron( vec3 p, float s)\n{\n  p = abs(p);\n  return (p.x+p.y+p.z-s)*0.57735027;\n}\nfloat boxFrame( vec3 p, vec3 b, float e )\n{\n\n  p = abs(p  )-b;\n  vec3 q = abs(p+e)-e;\n  return min(min(\n      length(max(vec3(p.x,q.y,q.z),0.0))+min(max(p.x,max(q.y,q.z)),0.0),\n      length(max(vec3(q.x,p.y,q.z),0.0))+min(max(q.x,max(p.y,q.z)),0.0)),\n      length(max(vec3(q.x,q.y,p.z),0.0))+min(max(q.x,max(q.y,p.z)),0.0));\n}\n\n// https://iquilezles.org/www/articles/checkerfiltering/checkerfiltering.htm\nfloat checkers(vec2 p)\n{\n    vec2 w = fwidth(p) + 0.001;\n    vec2 i = 2.0*(abs(fract((p-0.5*w)*0.5)-0.5)-abs(fract((p+0.5*w)*0.5)-0.5))/w;\n    return 0.5 - 0.5*i.x*i.y;\n}\n\nvec2 scene(vec3 p){\n    vec3 pp = p;\n    pp.y-=3.;\n    float theta=cos(iTime*.5);\n    pp*=mat3(vec3(cos(theta),0.,sin(theta)),vec3(0.,1.,0.),vec3(-sin(theta),0.,cos(theta)));\n    p.x=mod(p.x,5.)-2.5;\n    p.z=mod(p.z,5.)-2.5;\n    vec2 s; // second term is material id\n    s=vec2(sphere(p,1.),1.);\n    s.x=difference(s.x,octahedron(p,.5*cos(iTime)+1.));\n    //float warp=texture2D(iChannel1,cos(p.yy+iTime*.1));\n    //s+=warp*.7;\n    float t = torus(vec3(p.x,p.y+3.*cos(iTime),p.z),vec2(1.,.2));\n        s=sMin(s,vec2(t,s.y+2.),1.3);\n    float pln = plane(p,vec3(0.,1.,0.),1.);\n    s=U(vec2(pln,2.),s);\n    \n    \n    // x frequency, y current level? been a long time since I made a shader with sound idr\n    float sound = .9+.5*smoothstep(.5,1.,texture(iChannel0,vec2(.135,.05)).x);\n    float size = 1.*sound;\n    vec2 b = vec2(boxFrame(pp,vec3(size),.1),4.);\n    vec2 o = vec2(octahedron(pp,2.*size),4.);\n    vec2 sp = vec2(sphere(pp,.7*size*cos(iTime*.5)+.7*size),4.);\n    //o.x=difference(o.x,sp.x);\n    vec2 m = mix(b,o,.5*cos(iTime)+.5);\n    m.x=difference(m.x,sp.x);\n    //m.x+=texture2D(iChannel1,abs(vec2(sin(pp.z*1.),cos(pp.z*1.))))*1.;\n    s=U(m,s);\n\n    //return torus(p,vec2(1.,.2));\n    //return sphere(p,1.)+torus(p,vec2(1.,3.));\n    //s=U(plane(p,vec3(0,1.,0),1.),s);\n    return s;\n}\n\n// glulookat implementation\n// https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/gluLookAt.xml\n// from http://jamie-wong.com/2016/07/15/ray-marching-signed-distance-functions/\nmat4 viewMatrix(vec3 eye, vec3 center, vec3 up) {\n    vec3 f = normalize(center - eye);\n    vec3 s = normalize(cross(f, up));\n    vec3 u = cross(s, f);\n    return mat4(\n        vec4(s, 0.0),\n        vec4(u, 0.0),\n        vec4(-f, 0.0),\n        vec4(0.0, 0.0, 0.0, 1)\n    );\n}\n\n// add function to calculate normals\n// uses tetrahedron gradient approximation voodoo bullshit technique\n// https://iquilezles.org/www/articles/normalsSDF/normalsSDF.htm\nvec3 normal(vec3 p ){\n    const float h = epsilon;\n    const vec2 k = vec2(1,-1);\n    return normalize( k.xyy*scene( p + k.xyy*h ).x + \n                      k.yyx*scene( p + k.yyx*h ).x + \n                      k.yxy*scene( p + k.yxy*h ).x + \n                      k.xxx*scene( p + k.xxx*h ).x );\n}\n\n// return distance to surface\nvec2 toSurface(vec3 eye, vec3 dir, float start, float end){\n    float depth = start;\n    vec2 r = vec2(end,-1.);\n    for (int i=0; i<max_steps; i++){\n        vec2 dist = scene(eye+depth*dir);\n        if(dist.x<epsilon){\n            return vec2(depth,r.y);\n        }\n        depth += dist.x;\n        if(depth >= end){\n            return r;\n        }\n        r.y = dist.y;\n    }\n    return r;\n}\n\n// soft shadow function from https://www.iquilezles.org/www/articles/rmshadows/rmshadows.htm\n// same as tosurface but with an extra line that computes penumbra by seing how close it is to hitting\n// i have no clue why I didn't just extend my toSurface function as I already had to extend it for material id\nfloat softshadow( vec3 ro, vec3 rd, float mint, float maxt, float k )\n{\n    float res = 1.0;\n    for( float t=mint; t<maxt; )\n    {\n        float h = scene(ro + rd*t).x;\n        if( h<0.001 )\n            return 0.0;\n        res = min( res, k*h/t );\n        t += h;\n    }\n    return res;\n}\n\nvec3 rayDir(vec2 fragCoord, vec2 res, float fov){\n    vec2 xy = fragCoord.xy - res.xy/2.0;\n    // calculate z\n    float z = (res.x/2.)/tan(radians(fov)/2.);\n    return normalize(vec3(xy,z));\n}\n\n// color contrib from each light as there are no glsl arrays\nvec3 perLight(vec3 ambient, vec3 diffuse, vec3 specular, float shine, vec3 p, vec3 eye, vec3 lightPos, vec3 lightIntensity,float s, float matID){\n    vec3 n=normal(p);\n    vec3 ldir=lightPos-p;\n    float ldist=length(ldir);\n    \n    ldist=ldist*ldist;\n    ldir=normalize(ldir);\n\n    float lambertian = max(dot(ldir,n),0.);\n    float l=max(dot(-ldir,n),0.);\n    //float lambertian = clamp(dot(ldir, n),0.,1.);\n    float spec=0.0;\n    \n    float shadow=0.;\n    vec3 s_loc=p+n;\n    vec3 s_dir=ldir;\n    float dst=softshadow(s_loc,s_dir,min_dist,max_dist,30.);\n    \n    \n    if(dst<max_dist){\n        //shadow=dst/(max_dist-min_dist);\n        //return vec3(0.);\n        shadow=1.-dst;\n    }\n    // torus\n    if(matID==3.){\n        diffuse=checkers(p.zx)*vec3(.0,.5,.4);\n        ambient=vec3(.0,.5,.9)*.4;\n    }\n    // hovering thing\n    if(matID==4.){\n        diffuse=2.*vec3(.0,.2,.4);\n        ambient=vec3(.0,.5,.9)*.4;\n    }\n    // nvm \n    // couldn't get mat id working, set below certain y to checker for plane instead\n    // really wish I could start over with what I know now, this turned into spaghetti code\n    //if(p.y<=-.99){\n    //\n    //plane\n    if(matID==2.){\n        diffuse=checkers(p.zx)*vec3(.0,.2,.4);\n        ambient=vec3(.0,.5,.9)*.4;\n    }\n    \n    vec3 color = lightIntensity*diffuse*lambertian;\n        // ignore specular if camera light\n    if(s==0.){\n        return color;\n    }\n    \n    if(lambertian>0.){\n        vec3 vdir=normalize(eye-p);\n        vec3 hdir=normalize(ldir+vdir);\n        \n        spec=pow(max(dot(hdir,n),0.),shine);\n    }\n    color = (color+spec*specular)/ldist+ambient*lambertian*.5;\n    \n    return mix(color,color*.1,shadow);\n    //return shadow*color;\n    //return vec3(0.);\n}\n\nvec3 blinnPhong(vec3 ambient, vec3 diffuse, vec3 specular, float shine, vec3 point, vec3 eye,float matID){\n    // gave a bit of fake lambertian shading from the top direction to the ambient as well\n    //vec3 color=vec3(.05*ambient*max(dot(normal(point),vec3(0.,5.,-5.)),0.));\n    vec3 color=vec3(ambient*.00);\n    vec3 light0_pos=vec3(2.*cos(iTime),4.+sin(iTime*.25),-2.*sin(iTime));\n    vec3 intensity=vec3(2.9);\n    \n    color += perLight(ambient,diffuse,specular,shine,point,eye,light0_pos,intensity*2.,1.,matID);\n    light0_pos=eye;\n    //point=-1.*point;\n    color += perLight(ambient,diffuse,specular,shine,point,eye,light0_pos,vec3(.1),0.,matID);\n    //color += perLight(-2.*ambient,diffuse,vec3(0.),0.,point,eye,light0_pos*.4,vec3(1.));\n    return color;\n}\n\n// fog function from https://www.shadertoy.com/view/MtdBzs\nvec3 applyFog(vec3 rgb, float dist)\n{\n    vec3 fogColor = vec3(0.20, 0.3, 0.5);\n    //float startDist = mix(spectrum1.x*200.,30.,.5);\n    float startDist= 10.;\n    float fogAmount = 1.0 - exp(-(dist-8.0) * (1.0/startDist));\n    return mix(rgb, fogColor, fogAmount);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n    // setup coord system 0,1\n    // convert from 0,1 to -1,1 to play nice with sin/cos\n    // fix aspect ratio\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    //uv = uv*2.0 - 1.0;\n    //uv.x *= iResolution.x / iResolution.y;\n    \n    vec3 eye = vec3(0.,2.,-7.);\n    vec3 dir = rayDir(fragCoord,iResolution.xy,120.);\n    mat4 viewToWorld = viewMatrix(eye, vec3(0.,3.,0.), vec3(0.0, 1.0, 0.0));\n    float theta=acos(-1.)+.8*cos(iTime*.2);\n    mat3 yrot=mat3(vec3(cos(theta),0.,sin(theta)),vec3(0.,1.,0.),vec3(-sin(theta),0.,cos(theta)));\n    vec3 worldDir = (viewToWorld*vec4(dir,0.)).xyz*yrot;\n    vec2 dist = toSurface(eye,worldDir,min_dist,max_dist);\n    vec3 p=eye+dist.x*worldDir;\n    vec3 color=vec3(0.);\n    //vec3 pN = normal(p);\n    \n    if(dist.x > (max_dist - epsilon)){\n        //texture(iChannel0,uv);\n        //color = texture(iChannel2,vec2(uv.x,uv.y,0.)).xyz;\n        color=vec3(1.);\n    }\n    else{\n    \n        //fragColor = vec4(0.,1.,1.,1.);\n        //fragColor = vec4(pN*.5+.5,1.);\n        // change this back from dist to steps before end of distance reached\n        float fake_distance_occlusion = (1.-(dist.x/max_dist));\n        color=fake_distance_occlusion*blinnPhong(vec3(0.,.6,.7),vec3(0.,.6,.7),vec3(2.),100.,p,eye,dist.y);\n        // gamma correction\n        color=pow(color,vec3(1./2.2));\n        //fragColor=vec4(color,1.);\n    }\n    color=applyFog(color,dist.x);\n    fragColor=vec4(color,1.);\n}", "image_inputs": [{"id": "4sX3zn", "previewfilepath": "/media/ap/0681c014f6c88c356cf9c0394ffe015acc94ec1474924855f45d22c3e70b5785.png", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/0681c014f6c88c356cf9c0394ffe015acc94ec1474924855f45d22c3e70b5785.png", "ctype": "cubemap"}, {"id": "4sf3Rr", "previewfilepath": "/media/ap/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png", "ctype": "texture"}, {"id": "llsSzB", "previewfilepath": "https://soundcloud.com/hospitalrecords/villem-alpha-rhythm-the-maker-1", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0, "src": "https://soundcloud.com/hospitalrecords/villem-alpha-rhythm-the-maker-1", "ctype": "musicstream"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/7slXWX.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "7slXzM", "name": "Pixel experiment", "author": "SnoopethDuckDuck", "description": "e", "tags": ["cool"], "likes": 2, "viewed": 94, "date": "1618426129", "time_retrieved": "2024-06-20T20:36:38.228547", "image_code": "float random (vec2 st) {\n    return fract(sin(dot(st.xy,\n                         vec2(12.9898,78.233)))*\n        43758.5453123);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.y - vec2(0.375,0.);\n   // uv += vec2(0.125 * cos(iTime),0.);\n//uv += vec2(0.05 * iTime,0.)\nuv = floor(99. * uv) / 99.;\n\nfloat t= iTime;\n//float b = 0.5 * (1. + cos(t));\nvec2 dir = uv - 0.5;\ndir = fract(5. * dir +  0.5) - 0.5;\nfloat theta = atan(dir.y,dir.x);\n\nfloat k = 2. + 2. * cos(sin( theta) + t * (0.2 + abs(random(floor(uv * 50.)))));\nfloat d = pow(abs(dir.x) * k,k) + pow(abs(dir.y) * k,k);\n\n//d += 0.1 * (1. + cos(t + 3.14159));\nfloat c= step(d,0.3);\n\nfloat k2 = 2. + 2. * cos(theta + t * (0.2 + abs(random(floor((uv + 0.625) * 50.)))));\nfloat d2 = pow(abs(dir.x) * k2, k2) + pow(abs(dir.y) * k2,k2);\nfloat c2 =step(d2,0.3);\n\nfloat k3 = 2. + 2. * cos(theta + t * (0.2 + abs(random(floor((uv - 0.125) * 50.)))));\nfloat d3 = pow(abs(dir.x) * k3, k3) + pow(abs(dir.y) * k3, k3);\nfloat c3 = step(d3,0.3);\nvec3 col = vec3(c,c2,c3);//vec3(min(c,c2),min(c2,c3),min(c3,c));\n\nif (col.x == 0. && col.y == 0. && col.z == 0.)\ncol = vec3(34.,32.,52.) / 255.;\n\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/7slXzM.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "7sS3DV", "name": "Fractal 52_gaz", "author": "gaz", "description": "fractal", "tags": ["fractal"], "likes": 10, "viewed": 193, "date": "1617974363", "time_retrieved": "2024-06-20T20:36:38.228547", "image_code": "#define PI 3.1415\n#define H(h)(cos((h)*6.3+vec3(0,23,21))*.5+.5)\nvoid mainImage(out vec4 O, vec2 C)\n{\n    O=vec4(0);\n    vec3 p,r=iResolution,\n    d=normalize(vec3((C-.5*r.xy)/r.y,1));\n    ;\n    for(float i=0.,s,e=1.,g=0.;\n        e>.001&&++i<70.;\n        O.rgb+=mix(vec3(1),H(length(p)*.3),.8)*.02*exp(-.01*i*i*e)\n    )\n    {\n        p=g*d-vec3(0,0,1);\n        p.y-=p.z*.6;\n        p.xz=asin(sin((p.xz+iTime*.3)*PI/2.))/PI*2.;\n        s=2.;\n        for(int i=0;i<6;i++)\n            p.xz=abs(p.xz-vec2(1,2))-1.1,\n            s*=e=2.2/clamp(dot(p.xz,p.xz),.2,3.5),\n            p.xz=p.xz*e-.6;\n        vec2 q=vec2(abs(p.z/s),p.y);\n        g+=e=.5*min(p.y,length(q-min(q,vec2(.001,.08))));\n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/7sS3DV.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "7sS3WD", "name": "Robot Dance", "author": "blackle", "description": "for the revision 2021 shader showdown\n\ndon't have the revision texture for the floor, but this will do", "tags": ["revision", "shadershowdown", "livecode"], "likes": 26, "viewed": 411, "date": "1617403353", "time_retrieved": "2024-06-20T20:36:38.974088", "image_code": "//CC0 1.0 Universal https://creativecommons.org/publicdomain/zero/1.0/\n//To the extent possible under law, Blackle Mori has waived all copyright and related or neighboring rights to this work.\n\nfloat box(vec3 p, vec3 d) {\n  p = abs(p) - d;\n  return length(max(p,0.)) + min(0.,max(max(p.x,p.y),p.z));\n}\n\nfloat joint(vec3 p, vec3 d) {\n  return min(length(p - vec3(0,0,d.z))-d.y*1.5-.02, box(p,d)-.02);\n}\n\nvec3 erot(vec3 p, vec3 ax, float ro) {\n  return mix(dot(ax,p)*ax, p, cos(ro)) + sin(ro)*cross(ax,p);\n}\n\nfloat r1;\nfloat r2;\nfloat r3;\nfloat r4;\nfloat r5;\nfloat r6;\nfloat arm;\nfloat fl;\nfloat scene(vec3 p) {\n  float dist = joint(p, vec3(.1,.1,.4));\n  fl = p.z+.4;\n  dist = min(dist,fl);\n  p = erot(erot(p,vec3(0,0,1),r2)-vec3(0.,0.,.4), vec3(1,0,0), r1) - vec3(0,0,0.3);\n  dist = min(dist, joint(p, vec3(.1,.1,.3)));\n  p = erot(erot(p,vec3(0,0,1),r4)-vec3(0.,0.,.3), vec3(1,0,0), r3) - vec3(0,0,0.3);\n  dist = min(dist, joint(p, vec3(.1,.1,.3)));\n  p -= vec3(0,0,.32);\n  p = erot(p,vec3(0,0,1),r6);\n  arm = box(p, vec3(.09,.3,.09))-.02;\n  p.y = abs(p.y);\n  p -= vec3(0,.3,.12);\n  p = erot(p-vec3(0,0,-.2), vec3(1,0,0), r5);\n  arm = min(arm, length(p+vec3(0,0,-.1))-.15);\n  arm = min(arm, joint(p-vec3(0,0,.3), vec3(.05,.05,.2)));\n  return min(dist,arm);\n}\n\n#define FK(k) floatBitsToInt(k*k/7.)^floatBitsToInt(k)\nfloat hash(float a, float b) {\n  int x = FK(a), y = FK(b);\n  return float((x*x-y)*(y*y+x)+x)/2.14e9;\n}\n\nfloat spring(float x) {\n  return smoothstep(-.1,.1,x) + smoothstep(-.2,.2,x) - smoothstep(-.3,.3,x);\n}\n\nfloat bpm = 130.;\nfloat mayhem(float sd) {\n  float off = hash(sd,sd)*99.;\n  float idx = round((iTime+off)*bpm/240.);\n  float interp = iTime + off - idx*240./bpm;\n  float start = hash(idx, sd);\n  float end = hash(round(idx+1.), sd);\n  return mix(start, end, spring(interp));\n}\n\nfloat revisionTexture(vec2 p) {\n    return step(0., sin(length(p*40.)+atan(p.x,p.y)));\n}\n\nvec3 norm(vec3 p) {\n  mat3 k = mat3(p,p,p) - mat3(0.001);\n  return normalize(scene(p) - vec3(scene(k[0]),scene(k[1]),scene(k[2])));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\n      r1 = mayhem(12.);\n  r3 = mayhem(32.);\n  r5 = mayhem(72.)*.5+.5;\n  r2 = mayhem(92.);\n  r4 = mayhem(78.);\n  r6 = mayhem(89.);\n  float hs = mayhem(45.);\n  \n  vec3 cam = normalize(vec3(1.+hs*.5+.5,uv));\n  vec3 init = vec3(-5,0,.5+hs*.2);\n  \n  float yrot = .5+mayhem(85.)*.3;\n  float zrot = iTime+mayhem(98.);\n  cam = erot(cam, vec3(0,1,0), yrot);\n  init = erot(init, vec3(0,1,0), yrot);\n  cam = erot(cam, vec3(0,0,1), zrot);\n  init = erot(init, vec3(0,0,1), zrot);\n  \n  vec3 p = init;\n  bool hit = false;\n  float dist;\n  for (int i = 0; i<150 && !hit; i++) {\n    dist = scene(p);\n    hit = dist*dist < 1e-6;\n    p += cam*dist;\n    if (distance(p,init)>10.) break;\n  }\n  bool isfl = fl == dist;\n  bool isarm = arm == dist;\n  vec3 n = norm(p);\n  vec3 r = reflect(cam,n);\n  float fres = 1. - abs(dot(cam,n))*.98;\n  float spec = length(sin(r*3.)*.5+.5)/length(3.);\n  spec = pow(spec, 3.)*2. + spec*.2;\n  spec *= fres;\n  vec3 col = vec3(spec);\n  if (isarm) {\n    col += vec3(.8,.3,.1)*length(sin(n*2.)*.3+.7)/sqrt(3.);\n  }\n  if (isfl) {\n    col = vec3(1);\n    if(length(p.xy) < 3.) {\n      if (length(p.xy) < 1.5) {\n        p = erot(p, vec3(0,0,1), mayhem(78.));\n      } else {\n        p = erot(p, vec3(0,0,1), mayhem(99.));\n      }\n      col = vec3(revisionTexture(p.xy/6.));\n    }\n  }\n\n\tfragColor.xyz = smoothstep(0.,1.,sqrt(hit ? col : vec3(1)));\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc0-1.0", "thumbnail": "https://www.shadertoy.com/media/shaders/7sS3WD.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "7sSGDc", "name": "Arc Path Segment", "author": "oneshade", "description": "Arc path between two points with a starting tangent.", "tags": ["curve", "segment", "path", "arc"], "likes": 2, "viewed": 69, "date": "1618032473", "time_retrieved": "2024-06-20T20:36:39.258926", "image_code": "// Drawing utilities\n#define drawSDF(dist, col) color = mix(color, col, smoothstep(unit, 0.0, dist))\n\n// SDFs\nfloat sdDisc(in vec2 p, in vec2 o, in float r) {\n    return length(p - o) - r;\n}\n\nfloat sdPlane2D(in vec2 p, in vec2 pos, in vec2 nor) {\n    return abs(dot(p - pos, nor));\n}\n\n// p: position\n// d: direction (sin/cos of tangent)\n// t: target\nfloat getRadius(in vec2 p, in vec2 d, in vec2 t) {\n    t -= p;\n    return dot(t, t) / dot(t, d * vec2(-2, 2));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 center = 0.5 * iResolution.xy;\n\n    vec4 mouse = (vec4(iMouse.xy, abs(iMouse.zw)) - center.xyxy) / iResolution.y * 4.0;\n    vec2 uv = (fragCoord - center) / iResolution.y * 4.0;\n    float unit = 8.0 / iResolution.y;\n    vec3 color = vec3(0.0);\n\n    float a = iTime;\n    vec2 d = vec2(sin(a), cos(a));\n    float r = getRadius(vec2(0.0), d, vec2(2.0, 0.0));\n\n    vec2 n = vec2(-d.x, d.y);\n    vec2 o = n * r;\n\n    // Circle\n    drawSDF(abs(sdDisc(uv, o, abs(r))), vec3(0.0, 0.0, 1.0));\n\n    // Draw shortest segment\n    if (0.0 < uv.x && uv.x < 2.0 && uv.y * sign(o.y) < 0.0) {\n        drawSDF(abs(sdDisc(uv, o, abs(r))) - 0.01, vec3(1.0, 0.8, 0.0));\n    }\n\n    // Tangent\n    drawSDF(sdPlane2D(uv, vec2(0.0), n), vec3(1.0, 0.0, 0.0));\n\n    // End points\n    drawSDF(sdDisc(uv, vec2(0.0), 0.05), vec3(1.0));\n    drawSDF(sdDisc(uv, vec2(2.0, 0.0), 0.05), vec3(1.0));\n\n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/7sSGDc.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "7sSGRK", "name": "Primitives, plane & shadows", "author": "EricClapton", "description": "shadows should be calculated in diffuse section.", "tags": ["raymarching"], "likes": 2, "viewed": 169, "date": "1617636538", "time_retrieved": "2024-06-20T20:36:39.258926", "image_code": "\n\nconst int MAX_MARCHING_STEPS = 255;\nconst float MIN_DIST = 0.0;\nconst float MAX_DIST = 100.0;\nconst float EPSILON = 0.0001;\n\nfloat dot2( in vec3 v ) { return dot(v,v); }\n\nfloat sphereSDF1(vec3 samplePoint) {\n    vec3 sft = vec3(0.6, 0.0, 0.0);\n    return length(samplePoint+sft) - 0.5;\n}\n\n\nfloat sdRoundBox( vec3 p, vec3 b, float r )\n{\n  vec3 sft = vec3(-1.5, 0.0, 0.0);\n  vec3 q = abs(p+sft) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0) - r;\n}\n\nfloat sdBoxFrame( vec3 p, vec3 b, float e )\n{\n  vec3 sft = vec3(0.8, 0.0, -1.5);\n  p = abs(p+sft)-b;\n  vec3 q = abs(p+e)-e;\n  return min(min(\n      length(max(vec3(p.x,q.y,q.z),0.0))+min(max(p.x,max(q.y,q.z)),0.0),\n      length(max(vec3(q.x,p.y,q.z),0.0))+min(max(q.x,max(p.y,q.z)),0.0)),\n      length(max(vec3(q.x,q.y,p.z),0.0))+min(max(q.x,max(q.y,p.z)),0.0));\n}\n\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec3 sft = vec3(-1.25, 0.0, -1.5);\n  p = p+sft;\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\n\n\nfloat sceneSDF(vec3 samplePoint) {\n    float res = sphereSDF1(samplePoint);\n    \n    vec3 b = vec3(0.4, 0.2, 0.2);\n    float tmp = sdRoundBox( samplePoint, b, 0.1);\n    if(tmp < res)res = tmp;\n    \n    tmp = sdBoxFrame( samplePoint, vec3(0.5, 0.5, 0.5), 0.05);\n    if(tmp < res)res = tmp;\n    \n    tmp = sdTorus( samplePoint, vec2(0.5, 0.1));\n    if(tmp < res)res = tmp;\n    \n    float ground = samplePoint.z + 1.5;\n    float ground2 = samplePoint.y + 0.5;\n    if(ground2 < res)res = ground2;\n    return min(res, ground);\n}\n\nfloat calcSoftshadow( in vec3 ro, in vec3 rd, in float mint, in float tmax)\n{\n\tfloat res = 1.0;\n    float t = mint;\n    float ph = 1e10; // big, such that y = 0 on the first iteration\n    \n    for( int i=0; i<32; i++ )\n    {\n\t\tfloat h = sceneSDF( ro + rd*t );\n\n       \n        res = min( res, 10.0*h/t );\n        \n        \n        t += h;\n        \n        if( res<0.0001 || t>tmax ) break;\n        \n    }\n    res = clamp( res, 0.0, 1.0 );\n    return res*res*(3.0-2.0*res);\n}\n\nfloat RayCast(vec3 eye, vec3 marchingDirection, float start, float end) {\n    float depth = start;\n    for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n        float dist = sceneSDF(eye + depth * marchingDirection);\n        if (dist < EPSILON) {\n\t\t\treturn depth;\n        }\n        depth += dist;\n        if (depth >= end) {\n            return end;\n        }\n    }\n    return end;\n}\n            \n\n\nvec3 rayDirection(float fieldOfView, vec2 size, vec2 fragCoord) {\n    vec2 xy = fragCoord - size / 2.0;\n    float z = size.y / tan(radians(fieldOfView) / 2.0);\n    return normalize(vec3(xy, -z));\n}\n\n\nvec3 estimateNormal(vec3 p) {\n    return normalize(vec3(\n        sceneSDF(vec3(p.x + EPSILON, p.y, p.z)) - sceneSDF(vec3(p.x - EPSILON, p.y, p.z)),\n        sceneSDF(vec3(p.x, p.y + EPSILON, p.z)) - sceneSDF(vec3(p.x, p.y - EPSILON, p.z)),\n        sceneSDF(vec3(p.x, p.y, p.z  + EPSILON)) - sceneSDF(vec3(p.x, p.y, p.z - EPSILON))\n    ));\n}\n\n\nvec3 phongContribForLight(vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye,\n                          vec3 lightPos, vec3 lightIntensity) {\n    vec3 N = estimateNormal(p);\n    vec3 L = normalize(lightPos - p);\n    vec3 V = normalize(eye - p);\n    vec3 R = normalize(reflect(-L, N));\n    \n    float dotLN = dot(L, N);\n    float dotRV = dot(R, V);\n    float shadow = calcSoftshadow(p, lightPos, 0.01, 3.0);\n    \n    if (dotLN < 0.0) {\n       \n        return vec3(0.0, 0.0, 0.0);\n    } \n    \n    if (dotRV < 0.0) {\n        \n        return lightIntensity * (k_d * dotLN) * shadow;\n    }\n    return lightIntensity * (k_d * dotLN * shadow + k_s * pow(dotRV, alpha));\n}\n\n\nvec3 phongIllumination(vec3 k_a, vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye) {\n    const vec3 ambientLight = 0.8 * vec3(0.8, 0.8, 0.8);\n    vec3 color = ambientLight * k_a;\n    \n    vec3 light1Pos = vec3(4.0 * sin(iTime),\n                          2.0,\n                          4.0 * cos(iTime));\n    vec3 light1Intensity = vec3(0.2, 0.5, 0.8);\n    \n    color += phongContribForLight(k_d, k_s, alpha, p, eye,\n                                  light1Pos,\n                                  light1Intensity);\n    \n    vec3 light2Pos = vec3(2.0 * sin(0.37 * iTime),\n                          2.0 * cos(0.37 * iTime),\n                          2.0);\n    vec3 light2Intensity = vec3(0.9, 0.8, 0.5);\n    \n    color += phongContribForLight(k_d, k_s, alpha, p, eye,\n                                  light2Pos,\n                                  light2Intensity);    \n    return color;\n}\n\nmat4 viewMatrix(vec3 eye, vec3 center, vec3 up) {\n    // Based on gluLookAt man page\n    vec3 f = normalize(center - eye);\n    vec3 s = normalize(cross(f, up));\n    vec3 u = cross(s, f);\n    return mat4(\n        vec4(s, 0.0),\n        vec4(u, 0.0),\n        vec4(-f, 0.0),\n        vec4(0.0, 0.0, 0.0, 1)\n    );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\t//vec3 dir = rayDirection(45.0, iResolution.xy, fragCoord);\n\n    \n    vec3 viewDir = rayDirection(45.0, iResolution.xy, fragCoord);\n    vec3 eye = vec3(6.0*cos(iTime*0.5), 4.0, 8.0);\n    \n    mat4 viewToWorld = viewMatrix(eye, vec3(0.0, 0.0, 0.0), vec3(0.0, 1.0, 0.0));\n    \n    vec3 worldDir = (viewToWorld * vec4(viewDir, 0.0)).xyz;\n    \n    float dist = RayCast(eye, worldDir, MIN_DIST, MAX_DIST);\n    \n    if (dist > MAX_DIST - EPSILON) {\n\n        fragColor = vec4(0.0, 0.0, 0.0, 0.0);\n\t\treturn;\n    }\n    \n    vec3 p = eye + dist * worldDir;\n    \n    vec3 K_a = vec3(0.2, 0.2, 0.2);\n    vec3 K_d = vec3(0.2, 0.2, 0.2);\n    vec3 K_s = vec3(1.0, 1.0, 1.0);\n    float shininess = 10.0;\n    \n    vec3 color = phongIllumination(K_a, K_d, K_s, shininess, p, eye);\n    //color *= exp(-0.0005*dist*dist*dist);\n    \n    fragColor = vec4(color + vec3(0.05,0.05,0.05), 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/7sSGRK.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "7sSGRV", "name": "A Lonely Cloud", "author": "CustomPhase", "description": "Value noise is ugly, but i couldnt find any other decent noise that would be fast enough.", "tags": ["raymarching", "volumetric", "cineshader"], "likes": 30, "viewed": 2022, "date": "1617642719", "time_retrieved": "2024-06-20T20:36:39.258926", "image_code": "#define CAMERA_DISTANCE 2.4\n#define CAMERA_SPIN_SPEED 0.13\n#define FOV_MULTIPLIER 0.8\n#define SUN_DIR normalize(vec3(1,0.8,0))\n#define SUN_COLOR vec3(2,1.6,0.9)*2.3\n#define SCATTERING_MULTIPLIER 0.0\n#define CLOUD_SIZE vec3(2.6,1.1,2.6)\n\nvec3 aces_tonemap(vec3 color){\t\n\tmat3 m1 = mat3(\n        0.59719, 0.07600, 0.02840,\n        0.35458, 0.90834, 0.13383,\n        0.04823, 0.01566, 0.83777\n\t);\n\tmat3 m2 = mat3(\n        1.60475, -0.10208, -0.00327,\n        -0.53108,  1.10813, -0.07276,\n        -0.07367, -0.00605,  1.07602\n\t);\n\tvec3 v = m1 * color;    \n\tvec3 a = v * (v + 0.0245786) - 0.000090537;\n\tvec3 b = v * (0.983729 * v + 0.4329510) + 0.238081;\n\treturn pow(clamp(m2 * (a / b), 0.0, 1.0), vec3(1.0 / 2.2));\t\n}\n\nfloat rayPlaneIntersect(vec3 ro, vec3 rd, vec3 center, vec3 normal) {\n    float denom = dot(normal, rd);\n    if (abs(denom) > 0.0001f) // your favorite epsilon\n    {\n        float t = dot(center - ro, normal) / denom;\n        return t; // you might want to allow an epsilon here too\n    }\n    return -1.;\n}\n\n\nfloat opSmoothUnion( float d1, float d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); }\n\nfloat noise( in vec3 x )\n{\n    vec3 i = floor(x);\n    vec3 f = fract(x);\n\tf = f*f*(3.0-2.0*f);\n\tvec2 uv = (i.xy+vec2(37.0,17.0)*i.z) + f.xy;\n\tvec2 rg = textureLod( iChannel1, (uv+0.5)/256.0, 0.0).yx;\n\treturn mix( rg.x, rg.y, f.z )*2.-1.;\n}\n\nvec3 skyColor(vec3 viewDir, vec3 camPos) {\n    float horizonNoise = smoothstep(-0.2, 0.9, noise(viewDir * vec3(8,36,8))+noise(viewDir * vec3(28,56,28))*0.5);\n    float skyExtinction1 = exp(-max(0., abs(viewDir.y)*28. - horizonNoise*1.8));\n    float skyExtinction2 = exp(-max(0., abs(viewDir.y)*12. - horizonNoise*0.5));\n    vec3 sky =  vec3(7.5, 7.2, 7.2) * \n                mix(vec3(0.12, 0.85, 1.0) * 1.0, vec3(1), skyExtinction1) * \n                mix(vec3(0.5, 0.25, 0.52) * 0.5, vec3(1), skyExtinction2);\n    sky += vec3(3, 2, 0.5) * pow(clamp(dot(viewDir, SUN_DIR), 0., 1.), 4.);\n    sky += vec3(50, 40, 2) * smoothstep(0.991, 0.997, dot(viewDir, SUN_DIR)) * 0.3;\n    float groundD = rayPlaneIntersect(camPos, viewDir, vec3(0,-50,0), vec3(0,1,0));\n    vec3 groundPoint = camPos + viewDir * groundD;\n    float groundNoise = smoothstep(-0.5, 0.5, noise(groundPoint*0.07)*0.99 + noise(groundPoint*0.69)*0.3);\n    vec3 groundColPre = mix(vec3(0.3, 0.4, 0.6), vec3(0.45, 0.62, 0.68), groundNoise);\n    vec3 groundCol = mix(groundColPre, vec3(0.79, 1.28, 1.85), 1.-exp(-max(groundD,0.)*0.003));\n    vec3 ground = groundCol * ((1.0-pow(abs(viewDir.y),0.5))*0.8+0.2);\n    return mix(ground, sky, smoothstep(-0.04, 0.1, viewDir.y))*0.65;\n}\n\nvec3 ambientContribution(vec3 normal) {\n    vec3 ground = vec3(0.36, 0.6, 0.65)*0.4;\n    //ground *= smoothstep(-1., 0., normal.y)*0.5+0.5;\n    return mix(ground, vec3(0.4,0.8,1.1), pow(smoothstep(-1., 1., normal.y),1.0));\n}\n\nfloat density(vec3 pos) {\n    vec3 normDist = pos / (CLOUD_SIZE*0.5);\n    float topClip = smoothstep(-0.0, 1., normDist.y);\n    float sideClipX = smoothstep(0.60-topClip*0.6, 1., abs(normDist.x));\n    float sideClipZ = smoothstep(0.60-topClip*0.6, 1., abs(normDist.z));\n    float bottomClip = smoothstep(-0.5, -1.0, normDist.y);\n    float freq = 3.9;\n    float sum = 0.;\n    float amp = 0.5;\n    float d1 = distance(normDist * vec3(1.0,0.9,1.0), vec3(0, -0.65, 0) * vec3(1.0,0.8,1.0));\n    float d2 = distance(normDist * vec3(1.6,1.0,1.6), vec3(-0.3, 0.2, 0.3));\n    float dens = 1.-opSmoothUnion(\n        pow(d1*1.1, 1.2),\n        pow(d2*1.1, 1.4),\n        0.5\n    );\n    pos += vec3(1,0,2);\n    for (int i = 1; i<4; i++) {\n        float timeOffs = iTime * (1.+float(i)*1.0)*0.4;\n        if (i==1) timeOffs = 0.;\n        vec3 sineCoeff = vec3(\n            pos.z*2.4*freq,\n            pos.x*2.6*freq + timeOffs,\n            pos.y*2.8*freq\n        );\n        vec3 randOffs = sin(sineCoeff);\n        dens += (abs(noise(pos * freq + vec3(i)*167. + randOffs*0.022*freq))-0.48) * amp;\n        freq *= 2.1;\n        amp *= 0.5;\n    }\n    return  max(0., \n                0.0 + dens*0.8 - \n                pow(sideClipX,10.5)*0.4 - \n                pow(sideClipZ, 10.5)*0.4 - \n                pow(topClip,13.5)*0.3 - \n                pow(bottomClip,25.)*0.5\n            );\n}\n\nfloat blueNoise(vec2 pixelPos) {\n    const float c_goldenRatioConjugate = 0.61803398875f; // also just fract(goldenRatio)\n    float val = textureLod(iChannel0, pixelPos / 1024.0f, 0.).r;\n    int frame = iFrame % 64;\n    val = fract(val + float(frame) * c_goldenRatioConjugate);\n    return val;\n}\n\nvec2 intersectAABB(vec3 rayOrigin, vec3 rayDir, vec3 boxMin, vec3 boxMax) {\n    vec3 tMin = (boxMin - rayOrigin) / rayDir;\n    vec3 tMax = (boxMax - rayOrigin) / rayDir;\n    vec3 t1 = min(tMin, tMax);\n    vec3 t2 = max(tMin, tMax);\n    float tNear = max(max(t1.x, t1.y), t1.z);\n    float tFar = min(min(t2.x, t2.y), t2.z);\n    return vec2(tNear, tFar);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from -1 to 1)\n    vec2 uv = (fragCoord - 0.5*iResolution.xy) / iResolution.y;\n    \n    float camX = cos(iTime*CAMERA_SPIN_SPEED+2.0); \n    float camZ = sin(iTime*CAMERA_SPIN_SPEED+2.0);\n\n    float camYOffs = sin(iTime*0.3)*0.28;\n    vec3 cameraPos = normalize(vec3(camX,camYOffs-0.03,camZ))*CAMERA_DISTANCE;\n    vec3 cameraDir = -normalize(cameraPos+vec3(0.,cameraPos.y*0.30+0.11,0.));\n    vec3 cameraRight = normalize(cross(vec3(0,1,0), cameraDir));\n    vec3 cameraUp = normalize(cross(cameraDir, cameraRight));\n    \n    vec3 viewDir = normalize(cameraDir + cameraUp*uv.y*FOV_MULTIPLIER + cameraRight*uv.x*FOV_MULTIPLIER);\n    \n    float ao = 1.0;\n    \n    vec3 final = skyColor(viewDir, cameraPos);\n    \n    vec3 sunUp = normalize(cross(SUN_DIR, vec3(0,1,0)));\n    vec3 sunRight = normalize(cross(SUN_DIR, sunUp));\n    sunUp = normalize(cross(SUN_DIR, sunRight));\n    \n    vec2 box = intersectAABB(cameraPos, viewDir, -CLOUD_SIZE*0.5, CLOUD_SIZE*0.5); \n    vec3 hitPoint = cameraPos + viewDir*box.x;\n    \n    if (box.x<=box.y) {\n        float lightDirMult = 0.9 + blueNoise(fragCoord+50.)*0.2;\n        hitPoint += viewDir * blueNoise(fragCoord+123.) * 0.2;\n        //lightDirMult = 1.;\n        vec4 volume = vec4(0);\n        const float marchStep = 0.07;\n        for(int i = 0; i<32; i++) {\n            vec3 p = hitPoint + viewDir*float(i)*marchStep;\n            if (distance(p, cameraPos)>box.y) break;\n            float dens = density(p);\n            float light = 0.0;\n            vec3 lightP = p;\n            float lightStepInc = 2.0;\n            float lightStep = 0.002;\n            for (int n = 0; n<8; n++) {\n                float lightDens = density(lightP);\n                light += lightDens * lightStep * 20.;\n                float randUp = (blueNoise(fragCoord + vec2(n)*50.)*2.-1.) * SCATTERING_MULTIPLIER;\n                float randRight = (blueNoise(fragCoord + vec2(n)*88.)*2.-1.) * SCATTERING_MULTIPLIER;\n                vec3 scatterVec = normalize(SUN_DIR + sunUp*randUp + sunRight*randRight);\n                lightP += scatterVec * lightStep * lightDirMult;\n                if  (\n                        abs(lightP.y)>CLOUD_SIZE.y*0.5 ||\n                        abs(lightP.x)>CLOUD_SIZE.x*0.5 ||\n                        abs(lightP.z)>CLOUD_SIZE.z*0.5 \n                    ) break;\n                lightStep *= lightStepInc;\n            }\n            \n            light = exp(-light*light*12.0);\n            \n            //Ambient\n            /**/\n            float amb = 0.;\n            for (int a = 1; a<2; a++) {\n                vec3 ambP = p + \n                    normalize(vec3(\n                        blueNoise(fragCoord + vec2(a) * 120.)*2.0-1.0,\n                        blueNoise(fragCoord + vec2(a) * 151.)*2.0-1.0,\n                        blueNoise(fragCoord + vec2(a) * 199.)*2.0-1.0\n                    ))*0.10*(1.+float(a)*0.4);\n                amb += density(ambP);\n            }\n            float ambSoft = exp(-amb*5.0)*0.9+0.1;\n            vec3 ambient = mix(vec3(0.15, 0.25,0.55), vec3(0.58,0.85,1.02), ambSoft);\n            \n            amb = 0.;\n            for (int a = 1; a<2; a++) {\n                vec3 ambP = p + \n                    normalize(vec3(\n                        blueNoise(fragCoord + vec2(a) * 150.)*2.0-1.0,\n                        blueNoise(fragCoord + vec2(a) * 81.)*2.0-1.0,\n                        blueNoise(fragCoord + vec2(a) * 149.)*2.0-1.0\n                    ))*0.05*(1.+float(a)*0.4);\n                amb += density(ambP);\n            }\n            ambient *= exp(-amb*3.0)*0.8+0.2;\n            \n            vec3 newColor = vec3(0.7, 0.85, 1) * (light * SUN_COLOR + ambient*1.6);\n            volume.rgb += (1.0 - volume.a) * dens * newColor;\n            volume.a += (1.0 - volume.a) * dens;\n        }\n        if (volume.a > 0.001) volume.rgb /= volume.a;\n        final = mix(final, volume.rgb, clamp(volume.a*1.3, 0., 1.));\n    }\n\n    // Output to screen\n    uv.y *= 1.6;\n    float vignette = exp2(-length(uv*uv*uv*uv*0.6));\n    fragColor = vec4(aces_tonemap(final) * vignette,1.0);\n}", "image_inputs": [{"id": "Xsf3zn", "previewfilepath": "/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture"}, {"id": "XsBSR3", "previewfilepath": "/media/ap/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/7sSGRV.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "7sSSzD", "name": "Tutorial - Fireworks ", "author": "IAmQuirkee", "description": "Following the tut:\nhttps://www.youtube.com/watch?v=xDxAnguEOn8\n\nNotes and comments to help me understand what's happening", "tags": ["tutorial"], "likes": 9, "viewed": 159, "date": "1619784855", "time_retrieved": "2024-06-20T20:36:39.889123", "image_code": "#define NUM_EXPLOSIONS 5.\n#define NUM_PARTICLES 75.\n\n#define M_PI 3.1415926535\n\nfloat Hash1(float n) {\n  return fract(sin(n * 674.3) * 453.2);\n  // return fract(sin(n) * 43758.5453123);\n}\n\nfloat noise(float p) {\n  float fl = floor(p);\n  float fc = fract(p);\n  return mix(Hash1(fl), Hash1(fl + 1.0), fc);\n}\n\n// - Basically give it a seed number\n// - Return a random x, y value \nvec2 Hash12(float t) {\n\n    // - The large sin / seed factor doesn't matter since fract returns a number between 0 - 1\n  float x = fract(sin(t * 674.3) * 453.2);\n  float y = fract(sin(t * 524.2) * 577.1);\n\n  return vec2(x - .5, y - .5);\n\n}\n\nvec2 Hash12_Polar(float t) {\n\n    // Polar Coordinates\n  float a = fract(sin(t * 674.3) * 453.2) * M_PI * 2.;\n  float d = fract(sin(t * 524.2) * 577.1);\n\n    // Cartesian Coordinates\n  float x = sin(a);\n  float y = cos(a);\n\n  return vec2(x, y) * d;\n\n}\n\nfloat Explosion(vec2 uv, float _timeDelta) {\n\n  float sparks = 0.;\n\n  for(float i = 0.; i < NUM_PARTICLES; i++) {\n\n        // -.5 so that the return of 0 => 1. is remapped to -.5 => .5\n    vec2 _direction = Hash12_Polar(i + 1.) * .5;\n    float _distance = length(uv - (_direction * _timeDelta));\n\n    float _brightness = mix(.0005, .002, smoothstep(.05, 0., _timeDelta));\n\n    _brightness *= (sin(_timeDelta * 10. + i) + 1.) * .5;\n    _brightness *= smoothstep(.9, .5, _timeDelta);\n\n    float _cutoff = step(0.00025, _brightness / _distance);\n\n    sparks += _brightness / _distance * _cutoff;\n\n  }\n\n  return sparks;\n\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n\n    // vec2(400, 225) - vec2(400, 225) / 450 = 0,0 | .5\n    // vec2(400, 450) - vec2(400, 225) / 450 = 0,.5 | .5\n    // vec2(800, 225) - vec2(400, 225) / 450 = .8888,0 | .8888\n    // vec2(625, 225) - vec2(400, 225) / 450 = .5,0 | .5\n  vec2 uv = (fragCoord - iResolution.xy * .5) / iResolution.y;\n\n    // Time varying pixel color\n  vec3 _color = vec3(0.0);\n\n  float _resolutionAspect = iResolution.x / iResolution.y;\n\n  float _modTime = (iTime + 100.) * 1.;\n\n  for(float i = 0.; i < NUM_EXPLOSIONS; i++) {\n\n        // Animation timeline\n    float _time = _modTime + ((1. / NUM_EXPLOSIONS) * i);\n    float _timeDelta = fract(_time);\n    float _timeTotal = floor(_time);\n\n    float _timeOffset = _timeTotal + (0.2 * i);\n\n    // Color Modifer\n\n    // vec3 _explosionColor = vec3(\n    //   Hash12(_timeTotal).x + .5, \n    //   Hash12(_timeTotal * .5).y + .5, \n    //   Hash12(_timeTotal).y + .5\n    // );\n\n    vec3 _sinModifier = vec3(.4798, .5987, .1238);\n    vec3 _explosionColor = sin(_sinModifier * (_timeTotal * Hash1(i)));\n    _explosionColor += 1.; // Push -1. -> 1. to 0. -> 2.\n    _explosionColor *= .5; // Convert 0. -> 2. to 0. -> 1.\n\n    // Offset based on Hash12 aka square random\n    vec2 _offset = Hash12(i + _timeTotal) * vec2(_resolutionAspect, 1.);\n\n    // Debugging\n    // _brightness / _distance\n    // _color += step(0.0025, .001 / length(uv)) * .001 / length(uv);\n    // _color += .001 / length(uv);\n\n    // Final color affected by multiplier \n    _color += Explosion(uv - _offset, _timeDelta) * _explosionColor;\n\n  };\n\n    // Output to screen\n  fragColor = vec4(_color, 1.0);\n\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/7sSSzD.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "7ssXD8", "name": "Basic Line Renderer", "author": "wildniklin", "description": "Made from scratch. (Not the scratch language, no, fuck that, I mean from nothing basically.)\nI have a couple things to add, but that's for later. Have fun!\nTurn on SHOW_DISTANCE to show distance from the lines.", "tags": ["line"], "likes": 12, "viewed": 218, "date": "1618596078", "time_retrieved": "2024-06-20T20:36:39.889123", "image_code": "const float FOV = 80.0;\nconst float LINE_THICKNESS = 0.01;\nconst float MAX_DISTANCE = 10000.0;\n\nconst bool SHOW_DISTANCE = false;\n\nconst float PI = 3.1415;\n\nmat2 rot(float r) {\n    float s = sin(r), c = cos(r);\n    return mat2(c, -s, s, c);\n}\n\nfloat sliderPointLine(vec2 a, vec2 b, vec2 p) {\n    vec2 ab = b - a;\n    return clamp(dot(p - a, ab) / dot(ab, ab), 0.0, 1.0);\n}\n\nvec2 closestPointLine(vec2 a, vec2 b, float dist) { if (dist < 0.0) return a; else if (dist > 1.0) return b; else return mix(a, b, dist); }\n\nvec2 closestPointLine(vec2 a, vec2 b, vec2 p) { return closestPointLine(a, b, sliderPointLine(a, b, p)); }\n\nfloat distToLine(vec2 a, vec2 b, vec2 p) { return length(p - closestPointLine(a, b, p)); }\n\nvec3 worldToView(vec3 p) {\n    p.xz *= rot(iTime * PI * 0.5); // Rotate World Y\n    p.yz *= rot(sin(iTime * PI * 0.25) * PI * 0.1); // Rotate World X\n    p -= vec3(0.0, 0.0, 2.0); // Cam Position\n    p.xy /= -(p.z * (FOV / 90.0)); // Smaller as it gets further away.\n    p.z = -p.z;\n    return p;\n}\n\nfloat distLine(vec3 a, vec3 b, vec2 p) {\n    float dist = sliderPointLine(a.xy, b.xy, p);\n    if((a.z < 0.0) || (b.z < 0.0)) return MAX_DISTANCE;\n    float fade = mix(a.z, b.z, dist);\n    return length(p - closestPointLine(a.xy, b.xy, dist)) - (LINE_THICKNESS / fade);\n}\n\nfloat distToBoxLines(vec3 p, vec3 s, vec2 uv) {\n    vec3 bmin = p - (s * 0.5),\n         bmax = bmin + s,\n         ldb = worldToView(bmin),\n         rdb = worldToView(vec3(bmax.x, bmin.y, bmin.z)),\n         lub = worldToView(vec3(bmin.x, bmax.y, bmin.z)),\n         rub = worldToView(vec3(bmax.x, bmax.y, bmin.z)),\n         ldf = worldToView(vec3(bmin.x, bmin.y, bmax.z)),\n         rdf = worldToView(vec3(bmax.x, bmin.y, bmax.z)),\n         luf = worldToView(vec3(bmin.x, bmax.y, bmax.z)),\n         ruf = worldToView(bmax);\n    \n    return min(\n               min(\n                   min(\n                       min(distLine(ldb, ldf, uv), distLine(ldb, rdb, uv)),\n                       min(distLine(ldf, rdf, uv), distLine(rdf, rdb, uv))\n                   ),\n                   min(\n                       min(distLine(ldb, lub, uv), distLine(luf, ldf, uv)),\n                       min(distLine(rdb, rub, uv), distLine(ruf, rdf, uv))\n                   )\n               ),\n               min(\n                   min(distLine(lub, luf, uv), distLine(lub, rub, uv)),\n                   min(distLine(luf, ruf, uv), distLine(ruf, rub, uv))\n               )\n           );\n}\n\nvoid mainImage(out vec4 o, in vec2 i) {\n    float aspect = min(iResolution.x, iResolution.y);\n    vec2 uv = (i - (0.5 * iResolution.xy)) / aspect;\n    float tp = 1.0 / aspect;\n\n    vec3 col = vec3(0.0, 0.0, 0.0);\n    \n    float dist = MAX_DISTANCE;\n    \n    dist = min(dist, distToBoxLines(vec3(0.0), vec3(1.0), uv) - LINE_THICKNESS);\n    \n    if(SHOW_DISTANCE) col += ((dist < 0.0) ? -vec3(1.0, 0.2, 0.2) : vec3(0.2, 0.2, 1.0)) * dist;\n    else col += smoothstep(0.0, -tp * 2.0, dist);\n    \n    o = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/7ssXD8.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "7sSXRR", "name": "Refractive Superellipsoid", "author": "Holeum", "description": "Refractive Superellipsoid formula visualization (convex case).", "tags": ["raytracing", "reflection", "refraction", "cornell", "superformula", "fresnel", "superellipse", "superquadric", "supershape", "superellipsoid"], "likes": 5, "viewed": 103, "date": "1619785828", "time_retrieved": "2024-06-20T20:36:43.580333", "image_code": "/*\n  Written by Ivan Shevchenko\n  \n  Superellipsoid without refraction: https://www.shadertoy.com/view/4dcBDH\n*/\n\n#pragma optionNV(fastmath off)\n#pragma optionNV(fastprecision off)\nprecision highp float;\n\n#define M_PI 3.1415926535\n#define M_EPSILON pow(2.0, -10.0)\n#define M_SAFE_DISTANCE 10.0 * M_EPSILON\n#define M_TOLERANCE 0.00001\n\n#define MAXIters 24\n#define InitialStepFactor 1.0 / 128.0\n#define TorchColor vec3(1.0, 1.0, 1.0)\n\nconst vec3 PLANECOLOR[6] = vec3[6](vec3(180.0, 16.0 , 18.0 ) / 255.0,  // right\n                                   vec3(51.0 , 180.0, 50.0 ) / 255.0,  // left\n                                   vec3(241.0, 241.0, 212.0) / 255.0,  // top\n                                   vec3(241.0, 241.0, 212.0) / 255.0,  // bottom\n                                   vec3(180.0, 180.0, 180.0) / 255.0,  // near\n                                   vec3(54.0 , 117.0, 135.0) / 255.0); // far\n\n\n// ------------------ Miscellaneous ----------------------\nfloat deg2rad(float deg)\n{\n    return(deg * M_PI / 180.0);\n}\n\nfloat infinite2Unit(float x)\n{\n    x = abs(x);\n    return(sqrt(x / (1.0 + x)));\n}\n\nvec3 snell(in vec3 s, in vec3 n, in float n1, in float n2) {\n\tfloat r1 = n1 / n2;\n\tfloat r2 = r1 * r1;\n\tfloat d = dot(n, s);\n\n    vec3 v1 = (s - (d * n)) *  r1;\n    vec3 v2 = sqrt(1.0 - r2 * (1.0f - d * d)) * n;\n    \n    vec3 r = v1 - v2;\n\treturn(r);\n}\n\n// Narkowicz 2015, \"ACES Filmic Tone Mapping Curve\"\nvec3 ACESFilm(vec3 x)\n{\n    float a = 2.51f;\n    float b = 0.03f;\n    float c = 2.43f;\n    float d = 0.59f;\n    float e = 0.14f;\n    return clamp((x * (a * x + b)) / (x * (c * x + d) + e), 0.0, 1.0);\n}\n\nvec3 Linear2sRGB(const vec3 linear)\n{\n    return pow(linear, vec3(1.0 / 2.2));\n}\n// ------------------ Miscellaneous ----------------------\n\n\n// ------------------ BLAS/LAPACK elements ----------------------\nmat4 QuaternionToMatrix(vec4 q)\n{\n    mat4 m1 = mat4( q.w,  q.z, -q.y, q.x,\n                   -q.z,  q.w,  q.x, q.y,\n                    q.y, -q.x,  q.w, q.z,\n                   -q.x, -q.y, -q.z, q.w);\n\n    mat4 m2 = mat4( q.w,  q.z, -q.y, -q.x,\n                   -q.z,  q.w,  q.x, -q.y,\n                    q.y, -q.x,  q.w, -q.z,\n                    q.x,  q.y,  q.z,  q.w);\n\n    mat4 m = m1 * m2;\n\n    return(m);\n}\n\nmat4 AxisAngleToMatrix(vec3 axis, float angle)\n{\n    float s = sin(angle / 2.0);\n    float c = cos(angle / 2.0);\n\n    vec4 q = vec4(s, s, s, c);\n    q.x *= axis.x;\n    q.y *= axis.y;\n    q.z *= axis.z;\n\n    mat4 m = QuaternionToMatrix(q);\n    return(m);\n}\n\n// pitch (attitude) - rotation around X-axis\n// yaw (heading)    - rotation around Y-axis\n// roll (bank)      - rotation around Z-axis\nmat4 EulerToMatrix(float pitch, float yaw, float roll)\n{\n    // The definition can be found in glm/gtc/quaternion.hpp\n    vec3 c = vec3(cos(pitch / 2.0), cos(yaw / 2.0), cos(roll / 2.0));\n    vec3 s = vec3(sin(pitch / 2.0), sin(yaw / 2.0), sin(roll / 2.0));\n\n    vec4 q = vec4(0.0);\n\n    // XYZ ordering\n    q.x = s.x * c.y * c.z - c.x * s.y * s.z;\n    q.y = c.x * s.y * c.z + s.x * c.y * s.z;\n    q.z = c.x * c.y * s.z - s.x * s.y * c.z;\n    q.w = c.x * c.y * c.z + s.x * s.y * s.z;\n\n    //q = normalize(q);\n    mat4 m = QuaternionToMatrix(q);\n    return(m);\n}\n// ------------------ BLAS/LAPACK elements ----------------------\n\n\n// ------------------ Ray ------------------\nstruct Ray\n{\n\tvec3 Origin;\n\tvec3 Direction;\n};\n\nRay rayConstruct(vec2 uv, mat4 invProj, mat4 invView)\n{\n    // Ray in screen space\n    vec2 sXY = 2.0 * uv - 1.0;\n    vec4 sP0 = vec4(sXY, -1.0, 1.0);\n    vec4 sP1 = vec4(sXY,  1.0, 1.0);\n\n    // Ray in world space\n    vec4 wP0 = invProj * sP0; wP0 /= wP0.w;\n    vec4 wP1 = invProj * sP1; wP1 /= wP1.w;\n   \n    wP0 = invView * wP0;\n    wP1 = invView * wP1;\n    \n    Ray ray = Ray(invView[3].xyz, normalize(wP1.xyz - wP0.xyz));\n    return(ray);\n}\n// ------------------ Ray ------------------\n\n\n// ------------------ Plane ------------------\nstruct Plane\n{\n\tvec3 M;\n\tvec3 Normal;\n};\n\nPlane planeConstruct(vec3 point, vec3 normal)\n{\n    Plane pl;\n    pl.M = point;\n    pl.Normal = normal;\n   \n    return(pl);\n}\n\nbool planeIntersect(Plane pl, Ray ray)\n{\n    float denom = dot(ray.Direction, pl.Normal);\n    if(abs(denom) < M_EPSILON)\n    {\n        return(false);\n    }\n\n    float t = dot((pl.M - ray.Origin), pl.Normal) / denom;\n    if(t < 0.0)\n    {\n        return(false);\n    }\n\n    return(true);\n}\n\nbool planeIntersect(Plane pl, Ray ray, out vec3 ipos, out vec3 norm)\n{\n    float denom = dot(ray.Direction, pl.Normal);\n    if(abs(denom) < M_EPSILON)\n    {\n        return(false);\n    }\n\n    float t = dot((pl.M - ray.Origin), pl.Normal) / denom;\n    if(t < 0.0)\n    {\n        return(false);\n    }\n\n    ipos = ray.Origin + t * ray.Direction;\n    norm = pl.Normal;\n\n    return(true);\n}\n// ------------------ Plane ------------------\n\n\n// ------------------ Box ------------------\nstruct Box\n{\n\tvec3 Center;\n\tvec3 HalfExtents;\n    mat3 Orientation;\n};\n\nBox boxConstruct(in vec3 center, in vec3 halfextents)\n{\n    Box box;\n    box.Center = center;\n    box.HalfExtents = halfextents;\n    box.Orientation = mat3(1.0);\n    \n    return(box);\n}\n\nbool boxIntersect(in Box box, in Ray ray, out vec3 ipoint, out vec3 inormal)\n{\n    // OBB -> AABB\n    vec3 bmin = -box.HalfExtents;\n    vec3 bmax =  box.HalfExtents;\n\n    // Ray vs OBB -> Ray vs AABB\n    mat3 invm = transpose(box.Orientation);\n    vec3 pos = invm * (ray.Origin - box.Center);\n    vec3 dir = invm * ray.Direction;\n    \n    // Hit points with AABB\n    vec3 isign = vec3((dir.x < 0.0)? -1.0: 1.0, (dir.y < 0.0)? -1.0: 1.0, (dir.z < 0.0)? -1.0: 1.0);\n    vec3 idir = vec3((abs(dir.x) > M_EPSILON)? 1.0f / dir.x: isign.x / M_EPSILON,\n                     (abs(dir.y) > M_EPSILON)? 1.0f / dir.y: isign.y / M_EPSILON,\n                     (abs(dir.z) > M_EPSILON)? 1.0f / dir.z: isign.z / M_EPSILON);\n    \n    vec3 v1 = (bmin - pos) * idir;\n    vec3 v2 = (bmax - pos) * idir;\n    vec3 n = min(v1, v2);\n    vec3 f = max(v1, v2);\n\n    float tn = max(n.x, max(n.y, n.z));\n    float tf = min(f.x, min(f.y, f.z));\n    if(tf < 0.0 || tn > tf)\n    {\n        return(false);\n    }\n\n    float t = min(mix(tf, tn, step(0.0, tn)), mix(tn, tf, step(0.0, tf)));\n    vec3 lp = pos + t * dir;\n\n    vec3 d = abs(abs(lp) - box.HalfExtents);\n    float nx = (d.x > M_EPSILON)? 0.0: sign(lp.x);\n    float ny = (d.y > M_EPSILON)? 0.0: sign(lp.y);\n    float nz = (d.z > M_EPSILON)? 0.0: sign(lp.z);\n    vec3 ln = -vec3(nx, ny, nz);\n\n    ipoint = box.Orientation * lp + box.Center;\n    inormal = box.Orientation * ln;\n\n    return(t >= 0.0);\n}\n\nbool boxIntersect(in Box box, in Ray ray)\n{\n    // OBB -> AABB\n    vec3 bmin = -box.HalfExtents;\n    vec3 bmax =  box.HalfExtents;\n\n    // Ray vs OBB -> Ray vs AABB\n    mat3 invm = transpose(box.Orientation);\n    vec3 ori = invm * (ray.Origin - box.Center);\n    vec3 dir = invm * ray.Direction;\n    \n    // Hit points with AABB\n    vec3 v1 = (bmin - ori) / dir;\n    vec3 v2 = (bmax - ori) / dir;\n    vec3 n = min(v1, v2);\n    vec3 f = max(v1, v2);\n\n    float tn = max(n.x, max(n.y, n.z));\n    float tf = min(f.x, min(f.y, f.z));\n    if(tf < 0.0 || tn > tf)\n    {\n        return(false);\n    }\n\n    float t = min(mix(tf, tn, step(0.0, tn)), mix(tn, tf, step(0.0, tf)));\n    return(t >= 0.0);\n}\n\nvec3 boxSideColor(in Box box, in vec3 P, in vec3 N)\n{\n    int xindex = (N.x > 1.0 - M_EPSILON)? 2: ((N.x < -1.0 + M_EPSILON)? 1: 0);\n    int yindex = (N.y > 1.0 - M_EPSILON)? 4: ((N.y < -1.0 + M_EPSILON)? 3: 0);\n    int zindex = (N.z > 1.0 - M_EPSILON)? 6: ((N.z < -1.0 + M_EPSILON)? 5: 0);\n    int index = max(xindex, max(yindex, zindex)) - 1;\n\n    P -= box.Center;\n\n    float a = 1.0;\n    if(index == 3) {\n        float f = mod(floor(6.0 * P.z) + floor(6.0 * P.x), 2.0);\n        a = 0.2 + f * 0.8;\n    }\n    \n    P = min(vec3(1.0), abs(P) / box.HalfExtents);\n    float b = max(P.x, P.y);\n    float c = max(P.y, P.z);\n    float d = max(P.z, P.x);\n    float e = mix(1.0, 0.25, pow(b * c * d, 64.0));\n\n    return(PLANECOLOR[index] * a * e);\n}\n// ------------------ Box ------------------\n\n\n// ------------------ Medium ------------------\nstruct Medium\n{\n    float RefractiveIndex;\n};\n\nMedium mediumConstruct(float n)\n{\n    Medium me;\n    me.RefractiveIndex = n;\n    return(me);\n}\n// ------------------ Medium ------------------\n\n\n// ------------------ Superellipsoid ------------------\nstruct Superellipsoid\n{\n    float RefractiveIndex;\n    vec3 ReflectColor;\n    vec3 RefractColor;\n\n    vec3 Center;\n\tvec3 Radius;\n    vec2 Exponent;\n    mat3 Orientation;    \n};\n\nSuperellipsoid superellipsoidConstruct(in float etha, in vec3 reflectColor, in vec3 refractColor, in vec3 pos, in vec3 radius)\n{\n    vec3 arg = 0.5 + 0.5 * sin(vec3(iTime) / vec3(2.0, 4.0, 3.0));\n    \n    // 0.1 - near to square form, 2.00 - diamond form\n    vec2 e = mix(vec2(0.1), vec2(2.0), arg.xy);\n    \n    vec3 axis0 = vec3(1.0, 0.0, 0.0);\n    vec3 axis1 = vec3(0.0, 1.0, 1.0);\n    vec3 axis2 = vec3(0.0, 0.0, 1.0);\n    vec3 axis = mix(axis0, mix(axis1, axis2, max(0.0, 2.0 * arg.z - 1.0)), min(1.0, 2.0 * arg.z));\n    mat4 o = AxisAngleToMatrix(normalize(axis), deg2rad(360.0 * mod(0.05 * iTime, 1.0)));\n    \n    Superellipsoid se;\n    se.RefractiveIndex = etha;\n    se.ReflectColor = reflectColor;\n    se.RefractColor = refractColor;\n    se.Center = pos;\n    se.Radius = radius;\n    se.Exponent = e;\n    se.Orientation = mat3(o);\n    \n    return(se);\n}\n\n// Superellipsoid Inside-Outside Function\nfloat superellipsoidIOF(vec3 pos, vec3 dir, float t, Superellipsoid se)\n{\n    vec3 e = vec3(vec2(1.0) / se.Exponent.xy, se.Exponent.x / se.Exponent.y);\n    vec3 invr = vec3(1.0) / se.Radius;\n    vec3 p = pos + t * dir;\n\n    vec3 A = p * invr;\n    vec3 B = pow(A * A, e.xxy);\n    float E = B.x + B.y;\n    float F = pow(E, e.z);\n    float P = F + B.z;\n\n    float K = P - 1.0;\n    return(K);\n}\n\nvec3 superellipsoidNormal(vec3 p, Superellipsoid se)\n{\n    vec3 e = vec3(vec2(1.0) / se.Exponent.xy, se.Exponent.x / se.Exponent.y);\n    vec3 g = 2.0 * e;\n    vec3 invr = vec3(1.0) / se.Radius;\n\n    vec3 A = p * invr;\n    vec3 B = pow(A * A, e.xxy);\n    vec3 C = B / A;\n\n    float E = B.x + B.y;\n    float F = pow(E, e.z);\n    float G = e.z * (F / E);\n\n    vec3 n = g.xxy * C * invr;\n    n.xy *= G;\n\n    n = normalize(n);\n    return(n);\n}\n\nbool superellipsoidIntersect(Superellipsoid se, Ray ray, float tolerance)\n{\n    // OBB -> AABB\n    vec3 vmin = -se.Radius;\n    vec3 vmax =  se.Radius;\n\n    // Ray vs OBB -> Ray vs AABB\n    mat3 invm = transpose(se.Orientation);\n    vec3 pos = invm * (ray.Origin - se.Center);\n    vec3 dir = invm * ray.Direction;\n    \n    // Hit points with AABB\n    vec3 isign = vec3((dir.x < 0.0)? -1.0: 1.0, (dir.y < 0.0)? -1.0: 1.0, (dir.z < 0.0)? -1.0: 1.0);\n    vec3 idir = vec3((abs(dir.x) > M_EPSILON)? 1.0f / dir.x: isign.x / M_EPSILON,\n                     (abs(dir.y) > M_EPSILON)? 1.0f / dir.y: isign.y / M_EPSILON,\n                     (abs(dir.z) > M_EPSILON)? 1.0f / dir.z: isign.z / M_EPSILON);\n    \n    vec3 v1 = (vmin - pos) * idir;\n    vec3 v2 = (vmax - pos) * idir;\n    vec3 n = min(v1, v2);\n    vec3 f = max(v1, v2);\n\n    float tn = max(n.x, max(n.y, n.z));\n    float tf = min(f.x, min(f.y, f.z));\n    if(tf < 0.0 || tn > tf)\n    {\n        return(false);\n    }\n    \n    // Iterative proceduare of finding intersection point with superellipsoid    \n    float dt = InitialStepFactor * (tf - tn);\n    float t0 = -2.0 * dt + ((tn < 0.0)? tf: tn);\n    float t1 = -1.0 * dt + ((tn < 0.0)? tf: tn);\n\n    // secant method of root refinement\n    float S0 = superellipsoidIOF(pos, dir, t0, se);\n    float S1 = superellipsoidIOF(pos, dir, t1, se);\n\n    bool success = false;\n    for(int i = 0; i < MAXIters; i++)\n    {\n        float t = t0 - S0 * (t1 - t0) / (S1 - S0);\n\n        t0 = t1;\n        t1 = t;\n\n        S0 = S1;\n        S1 = superellipsoidIOF(pos, dir, t1, se);\n\n        float t_error = abs(t1 - t0) / max(10.0 * tolerance, max(t0, t1));\n        float s_error = S1 * S1;\n        if(t_error < tolerance && s_error < tolerance)\n        {\n            success = true;\n            break;\n        }\n    }    \n    return(success);\n}\n\nbool superellipsoidIntersect(Superellipsoid se, Ray ray, float tolerance, out vec3 ipos, out vec3 norm)\n{\n    // OBB -> AABB\n    vec3 vmin = -se.Radius;\n    vec3 vmax =  se.Radius;\n\n    // Ray vs OBB -> Ray vs AABB\n    mat3 invm = transpose(se.Orientation);\n    vec3 pos = invm * (ray.Origin - se.Center);\n    vec3 dir = invm * ray.Direction;\n    \n    // Hit points with AABB\n    vec3 isign = vec3((dir.x < 0.0)? -1.0: 1.0, (dir.y < 0.0)? -1.0: 1.0, (dir.z < 0.0)? -1.0: 1.0);\n    vec3 idir = vec3((abs(dir.x) > M_EPSILON)? 1.0f / dir.x: isign.x / M_EPSILON,\n                     (abs(dir.y) > M_EPSILON)? 1.0f / dir.y: isign.y / M_EPSILON,\n                     (abs(dir.z) > M_EPSILON)? 1.0f / dir.z: isign.z / M_EPSILON);\n    \n    vec3 v1 = (vmin - pos) * idir;\n    vec3 v2 = (vmax - pos) * idir;\n    vec3 n = min(v1, v2);\n    vec3 f = max(v1, v2);\n\n    float tn = max(n.x, max(n.y, n.z));\n    float tf = min(f.x, min(f.y, f.z));\n    if(tf < 0.0 || tn > tf)\n    {\n        return(false);\n    }\n    \n    // Iterative proceduare of finding intersection point with superellipsoid\n    float dt = InitialStepFactor * (tf - tn);\n    float t0 = -2.0 * dt + ((tn < 0.0)? tf: tn);\n    float t1 = -1.0 * dt + ((tn < 0.0)? tf: tn);\n\n    // secant method of root refinement\n    float S0 = superellipsoidIOF(pos, dir, t0, se);\n    float S1 = superellipsoidIOF(pos, dir, t1, se);\n\n    bool success = false;\n    for(int i = 0; i < MAXIters; i++)\n    {\n        float t = t0 - S0 * (t1 - t0) / (S1 - S0);\n\n        t0 = t1;\n        t1 = t;\n\n        S0 = S1;\n        S1 = superellipsoidIOF(pos, dir, t1, se);\n\n        float t_error = abs(t1 - t0) / max(10.0 * tolerance, max(t0, t1));\n        float s_error = S1 * S1;\n        if(t_error < tolerance && s_error < tolerance)\n        {\n            success = true;\n        \n            vec3 lpos = pos + t1 * dir;\n            norm = superellipsoidNormal(lpos, se);\n            ipos = se.Orientation * lpos + se.Center;\n            norm = se.Orientation * norm;\n            break;\n        }\n    }\n\n    return(success);\n}\n// ------------------ Superellipsoid ------------------\n\n\n// ------------------ Camera ----------------------\nstruct Camera\n{\n    mat4 invProj;\n    mat4 invView;\n};\n\nCamera cameraConstruct(float fovy, float aspect, float near, float far)\n{\n    fovy = deg2rad(fovy);\n\n    Camera camera;\n    camera.invView = mat4(1.0);\n\n    float d = 1.0 / tan(0.5 * fovy);\n    camera.invProj = mat4(aspect / d, 0.0,      0.0, 0.0,\n                          0.0,   1.0 / d,  0.0, 0.0,\n                          0.0,   0.0,      0.0, (near - far) / (2.0 * near * far),\n                          0.0,   0.0,     -1.0, (near + far) / (2.0 * near * far));\n\n    return(camera);\n}\n\nvoid cameraSetOrientation(inout Camera camera, float pitch, float yaw, float roll)\n{\n    pitch = deg2rad(pitch);\n    yaw = deg2rad(yaw);\n    roll = deg2rad(roll);\n    \n    mat4 m = camera.invView;\n    camera.invView = EulerToMatrix(pitch, yaw, roll);\n    camera.invView[3] = m[3];\n}\n\nvoid cameraSetPosition(inout Camera camera, vec3 origin)\n{\n    camera.invView[3] = vec4(origin, 1.0);\n}\n\nRay cameraGetRay(Camera camera, vec2 uv)\n{\n    Ray ray = rayConstruct(uv, camera.invProj, camera.invView);\n    return(ray);\n}\n// ------------------ Camera ----------------------\n\n\n// ------------------ Lighting ------------------\nstruct PointLight\n{\n\tvec3 Color;\n\tvec3 Position;\n    float a; // const attenuation factor\n    float b; // linear attenuation factor\n    float c; // exponential attenuation factor\n};\n\nPointLight constructPointLight(vec3 color, vec3 pos, float a, float b, float c) {\n    PointLight light;\n    light.Color = color;\n    light.Position = pos;\n    light.a = a;\n    light.b = b;\n    light.c = c;\n    return(light);\n}\n\nvoid pointLightParams(PointLight light, vec3 dst, out vec3 color, out vec3 dir) {\n    dir = light.Position - dst;\n    float dist = length(dir);\n    dir.xyz /= dist;    \n\n    color = light.Color / (light.a + dist * (light.b + light.c * dist));\n}\n\nfloat Fresnel(in float etha_i, in float etha_t, in float cos_theta)\n{\n    float cos_i = cos_theta;\n\n    // Compute sin_t using Snell's law    \n    float sin_t = (etha_i / etha_t) * sqrt(max(0.0, 1.0 - cos_i * cos_i)); \n\n    float F = 1.0; // Total internal reflection\n    if(sin_t < 1.0)\n    { \n        float cos_t = sqrt(max(0.0, 1.0 - sin_t * sin_t)); \n        cos_i = abs(cos_i); \n        float Rs = ((etha_t * cos_i) - (etha_i * cos_t)) / ((etha_t * cos_i) + (etha_i * cos_t)); \n        float Rp = ((etha_i * cos_i) - (etha_t * cos_t)) / ((etha_i * cos_i) + (etha_t * cos_t)); \n        F = (Rs * Rs + Rp * Rp) / 2.0; \n    }\n    return(F);\n}\n\nvec3 lambert(vec3 I, vec3 L, vec3 N) {\n    float NdotL = dot(N, L);\n    vec3 brightness = max(0.0, NdotL) * (I / M_PI);\n    return(brightness);\n}\n\nvec3 normalized_blinn_phong(vec3 I, vec3 L, vec3 V, vec3 N, float etha_i, float etha_t, float alpha)\n{\n    vec3 H = normalize(L + V);\n    float NdotL = dot(N, L);\n    float NdotH = dot(N, H);\n    float LdotH = dot(L, H);\n    float F = Fresnel(etha_i, etha_t, LdotH);\n\n    vec3 brightness = ((alpha + 2.0) / 8.0) * pow(max(NdotH, 0.0), alpha) * F * (max(0.0, NdotL) * I);\n    return(brightness);\n}\n\nfloat calcShadowAttenuation(vec3 P, vec3 Ld, Superellipsoid se)\n{\n    Ray ray = Ray(P, Ld);\n    bool isIntersect = superellipsoidIntersect(se, ray, 1.0e-06);\n    \n    return((isIntersect)? 0.25: 1.0);\n}\n// ------------------ Lighting ------------------\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 P = vec3(0.0, 0.0, 1.05); // default viewer position\n    float aspect = iResolution.x / iResolution.y;\n    float near = 0.1;\n    float far = 32.0;\n\n    Camera camera = cameraConstruct(90.0, aspect, near, far);\n    cameraSetOrientation(camera, 0.0, 0.0, 0.0);\n    cameraSetPosition(camera, P);\n\n    vec2 uv = fragCoord / iResolution.xy;\n    Ray ray = cameraGetRay(camera, uv);\n\n    // scene rendering\n    Box cornellBox;\n    cornellBox.Center = vec3(0.0, 0.0, 0.0);\n    cornellBox.HalfExtents = vec3(1.1, 1.1, 1.1);\n    cornellBox.Orientation = mat3(1.0);\n\n    vec3 pos = vec3(0.0, 0.0, 0.0);\n    vec3 radius = vec3(7.0 / 24.0, 7.0 / 24.0, 7.0 / 24.0);\n    Superellipsoid se = superellipsoidConstruct(1.5, vec3(1.0), vec3(0.53, 0.81, 0.92), pos, radius);\n    \n    Medium me = mediumConstruct(1.0); // medium\n    \n    PointLight light = constructPointLight(TorchColor, vec3(0.75, 0.75, 1.0), 0.0, 0.0, 0.15);\n    vec3 Lc, Ld;\n\n    // ray vs superellipsoid\n    vec3 ipoint = ray.Direction * far;\n    vec3 normal = vec3(0.0);\n    \n    vec3 color = vec3(0.0);\n    vec3 rl_brightness = vec3(0.0);\n    vec3 rr_brightness = vec3(0.0);\n\n    bool isIntersect = superellipsoidIntersect(se, ray, M_TOLERANCE, ipoint, normal);\n    if(isIntersect)\n    {\n        // reflective part\n        pointLightParams(light, ipoint, Lc, Ld);\n        rl_brightness += normalized_blinn_phong(Lc, Ld, -ray.Direction, normal, 1.0, 1.5, 256.0);\n\n        Ray ray2 = Ray(ipoint, reflect(ray.Direction, normal));\n        vec3 ipoint2 = vec3(0.0);\n        vec3 normal2 = vec3(0.0);\n\n        //ray vs box\n        isIntersect = boxIntersect(cornellBox, ray2, ipoint2, normal2);\n        if(isIntersect)\n        {\n            pointLightParams(light, ipoint2, Lc, Ld);\n            rl_brightness += boxSideColor(cornellBox, ipoint2, normal2) * lambert(Lc, Ld, normal2);\n        }\n\n        // refractive part\n        vec3 inormal = normal;\n        vec3 iraydir = -ray.Direction;\n        \n        ray.Direction = snell(ray.Direction, normal, me.RefractiveIndex, se.RefractiveIndex);\n        ray.Origin = ipoint + M_SAFE_DISTANCE * ray.Direction;\n\n        isIntersect = superellipsoidIntersect(se, ray, M_TOLERANCE, ray.Origin, normal);\n\n        vec3 onormal = -normal;\n        vec3 oraydir = -ray.Direction;\n        \n        ray.Direction = snell(ray.Direction, -normal, se.RefractiveIndex, me.RefractiveIndex);\n        ray.Origin = ray.Origin + M_SAFE_DISTANCE * ray.Direction;\n\n        isIntersect = boxIntersect(cornellBox, ray, ipoint, normal);\n        if(isIntersect)\n        {\n            // account sun lighting\n            pointLightParams(light, ipoint, Lc, Ld);\n            vec3 brightness = lambert(Lc, Ld, normal);\n            vec3 box_albedo = boxSideColor(cornellBox, ipoint, normal);\n            rr_brightness += box_albedo * brightness;\n\n            // shadow\n            float attenuation = calcShadowAttenuation(ipoint, Ld, se);\n            rr_brightness *= attenuation;\n\n            float Fi = Fresnel(me.RefractiveIndex, se.RefractiveIndex, max(0.0, dot(inormal, iraydir)));\n            float Fo = Fresnel(se.RefractiveIndex, me.RefractiveIndex, max(0.0, dot(onormal, oraydir)));\n            rr_brightness *= (1.0 - Fi) * (1.0 - Fo);\n        }\n\n        // final color\n        color = se.ReflectColor * rl_brightness + se.RefractColor * rr_brightness;\n    }\n    else\n    {\n        //ray vs box\n        isIntersect = boxIntersect(cornellBox, ray, ipoint, normal);\n        if(isIntersect)\n        {\n            // account sun lighting\n            pointLightParams(light, ipoint, Lc, Ld);\n            vec3 brightness = lambert(Lc, Ld, normal);\n            \n            vec3 box_albedo = boxSideColor(cornellBox, ipoint, normal);\n            color = box_albedo * brightness;\n\n            // shadow\n            float attenuation = calcShadowAttenuation(ipoint, Ld, se);\n            color *= attenuation;\n        }\n    }\n\n    // Tone mapping\n    color = ACESFilm(color);\n\n    // Gamma correction\n    color = Linear2sRGB(color);\n\n    float vignette = pow(32.0 * uv.x * uv.y * (1.0 - uv.x) * (1.0 - uv.y), 0.05);\n    fragColor = vec4(color * vignette, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/7sSXRR.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "7ssXzH", "name": "toplight", "author": "shiyuelai", "description": "toplight", "tags": ["toplight"], "likes": 1, "viewed": 52, "date": "1618371445", "time_retrieved": "2024-06-20T20:36:43.580333", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord / iResolution.xy;\n   \n    float dis = abs(uv.x - 0.5);\n    float r = 0.3 * (1.2 - uv.y);\n \n    //fragColor = texture(iChannel0, uv); \n    fragColor = vec4(0.2); \n    float darkness = abs(mod(iTime, 2.0) - 1.0); \n   \n    vec3 color = vec3(0.4, 0.35, 0.18);\n    if(dis < r)\n    {\n       float circle = smoothstep(r, r * 0.05, dis);\n       float alpha = clamp(1.8 * uv.y - 0.25, 0.0, 1.6); \n       vec3 newColor = color * circle * alpha;\n       newColor = 1.0 - (1.0 - fragColor.rgb) * (1.0 - newColor);\n       fragColor.rgb = mix(newColor.rgb, fragColor.rgb, darkness);\n    }\n    \n    r = r * 0.5;\n    color = vec3(0.4, 0.35, 0.18);\n    if(dis < r)\n    {\n       float circle = smoothstep(r, r * 0.05, dis);\n       float alpha = clamp(1.8 * uv.y - 0.25, 0.0, 1.6); \n       vec3 newColor = color * circle * alpha;\n       newColor = 1.0 - (1.0 - fragColor.rgb) * (1.0 - newColor);\n       fragColor.rgb = mix(newColor.rgb, fragColor.rgb, darkness);\n    }\n    \n    r = r * 0.5;\n    color = vec3(0.2, 0.18, 0.09);\n    if(dis < r)\n    {\n       float circle = smoothstep(r, r * 0.05, dis);\n       float alpha = clamp(1.8 * uv.y - 0.25, 0.0, 1.6); \n       vec3 newColor = color * circle * alpha;\n       newColor = 1.0 - (1.0 - fragColor.rgb) * (1.0 - newColor);\n       fragColor.rgb = mix(newColor.rgb, fragColor.rgb, darkness);\n    }\n    \n    \n    \n    vec4 color2 = texture(iChannel1, uv); \n    fragColor.rgb = mix(color2.rgb, fragColor.rgb, 0.8);\n}", "image_inputs": [{"id": "4df3zn", "previewfilepath": "/media/ap/3405e48f74815c7baa49133bdc835142948381fbe003ad2f12f5087715731153.ogv", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/3405e48f74815c7baa49133bdc835142948381fbe003ad2f12f5087715731153.ogv", "ctype": "video"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/7ssXzH.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "7sXGR2", "name": "classical_raytracing", "author": "kinakomoti", "description": "This is a shader by classical raytracing. Only Diffuse reflection.", "tags": ["raytracing"], "likes": 0, "viewed": 38, "date": "1617887488", "time_retrieved": "2024-06-20T20:36:44.192653", "image_code": "// refered https://qiita.com/doxas/items/477fda867da467116f8d by @doxas\nstruct Ray{\n    vec3 origin;\n    vec3 direction;\n};\nstruct Sphere{\n    float radius;\n    vec3 position;\n    vec3 color;\n};\nstruct Info{\n    float distance;\n    vec3 normal;\n    vec3 position;\n    vec3 color;\n};\n\nSphere sphere;\n\nbool intersectSphere(Ray R,Sphere S,inout Info info,in vec3 light){\n    vec3 a = R.origin - S.position;\n    float b = dot(a,R.direction);\n    float c = dot(a,a) - (S.radius * S.radius);\n    float d = b * b - c;\n    if( d <= 0.0){\n        return false;\n    }\n\n    float t1 = -b - sqrt(d);\n    float t2 = -b + sqrt(d);\n\n    float t = t1;\n    if(t < 0.0001 || t > 10000.){\n        t = t2;\n        if(t < 0.0001 || t > 10000.){\n            return false;\n        } \n    }\n\n    if(t > info.distance) return false;\n\n    info.distance = t;\n    info.position = R.origin + t * R.direction;\n    info.normal = info.position - S.position;\n    info.color = max(dot(light,info.normal),0.1) * S.color;\n    return true;\n}\n\nbool baseplaneIntersect(Ray ray,inout Info info,in vec3 light){\n    vec3 normal = normalize(vec3(0.,1.,0.));\n    \n    float sn = dot(ray.origin,normal);\n    float dn = dot(ray.direction,normal);\n\n    if(abs(dn) == 0.000) return false;\n\n    float t = - sn/ dn;\n    if(t > info.distance || t < 0.0001 || t > 10000.) return false;\n    info.distance = t;\n    info.normal = normal;\n    info.position = ray.origin + t * ray.direction;\n\n    Ray lightray;\n    lightray.direction = light;\n    lightray.origin = info.position;\n\n\n    float m = mod(info.position.x,2.0);\n    float n = mod(info.position.z,2.0);\n    float d = max(dot(info.normal,light),0.1);\n    if((m > 1. && n > 1.) || (m < 1. && n < 1.)){\n        d *= 0.5;\n    }\n    \n    float f = 1.0 - min(abs(info.position.z),25.0) * 0.04;\n    info.color = vec3(1.0) * d * f;\n    Info tekitou;\n    tekitou.distance = 10000.;\n    if(intersectSphere(lightray,sphere,tekitou,light)) info.color *= 0.2;\n}\n\nRay Camera(vec2 uv,vec3 pos,vec3 front){\n    vec3 t = front;\n    vec3 z = vec3(0.,1.,0.);\n    \n    if(t == z){\n        z = vec3(0.,0.,1.);\n    }\n    //local x\n    vec3 s = normalize(cross(t,z));\n    //local y\n    vec3 f = normalize(cross(s,t));\n\n    vec3 posx = uv.x * s;\n    vec3 posy = uv.y * f;\n\n    Ray cameraRay;\n    cameraRay.origin = pos + posx + posy;\n    cameraRay.direction = normalize(t + pos - cameraRay.origin);\n\n    return cameraRay;\n}\n\nvoid mainImage(out vec4 fragColor,in vec2 fragCoord){\n    vec2 uv = (fragCoord.xy * 2.0 - iResolution.xy) / iResolution.y;\n    sphere.radius = 1.0;\n    sphere.position = vec3(1.0);\n    sphere.color = vec3(1.0);\n    Ray cameraray;\n    // cameraray = Camera(uv,vec3(0.,4.,0.),vec3(1.,0.,0.));\n    cameraray.origin = vec3(0.0,2.0,5.0);\n    cameraray.direction = normalize(vec3(uv.x,uv.y,-1.0));\n    vec3 col = vec3(0.);\n    Info info;\n    info.color = vec3(0.);\n    info.distance = 10000.;    \n    vec3 light = normalize(vec3(sin(iTime),1.,  cos(iTime)));\n    intersectSphere(cameraray,sphere,info,light);\n\n    baseplaneIntersect(cameraray,info,light);\n    fragColor = vec4(info.color,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/7sXGR2.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "7sXSRB", "name": "Anime speed strips", "author": "leoxshn", "description": "The speed effect from anime", "tags": ["overlay", "anime"], "likes": 4, "viewed": 111, "date": "1619531484", "time_retrieved": "2024-06-20T20:36:44.719815", "image_code": "///// OpenSimplex noise /////\n\nvec4 permute(vec4 t) {\n    return t * (t * 34.0 + 133.0);\n}\n\n// Gradient set is a normalized expanded rhombic dodecahedron\nvec3 grad(float hash) {\n\n    // Random vertex of a cube, +/- 1 each\n    vec3 cube = mod(floor(hash / vec3(1.0, 2.0, 4.0)), 2.0) * 2.0 - 1.0;\n\n    // Random edge of the three edges connected to that vertex\n    // Also a cuboctahedral vertex\n    // And corresponds to the face of its dual, the rhombic dodecahedron\n    vec3 cuboct = cube;\n    cuboct[int(hash / 16.0)] = 0.0;\n\n    // In a funky way, pick one of the four points on the rhombic face\n    float type = mod(floor(hash / 8.0), 2.0);\n    vec3 rhomb = (1.0 - type) * cube + type * (cuboct + cross(cube, cuboct));\n\n    // Expand it so that the new edges are the same length\n    // as the existing ones\n    vec3 grad = cuboct * 1.22474487139 + rhomb;\n\n    // To make all gradients the same length, we only need to shorten the\n    // second type of vector. We also put in the whole noise scale constant.\n    // The compiler should reduce it into the existing floats. I think.\n    grad *= (1.0 - 0.042942436724648037 * type) * 32.80201376986577;\n\n    return grad;\n}\n\n// OpenSimplex noise\nvec4 openSimplex(vec3 X) {\n\n    // First half-lattice, closest edge\n    vec3 v1 = round(X);\n    vec3 d1 = X - v1;\n    vec3 score1 = abs(d1);\n    vec3 dir1 = step(max(score1.yzx, score1.zxy), score1);\n    vec3 v2 = v1 + dir1 * sign(d1);\n    vec3 d2 = X - v2;\n\n    // Second half-lattice, closest edge\n    vec3 X2 = X + 144.5;\n    vec3 v3 = round(X2);\n    vec3 d3 = X2 - v3;\n    vec3 score2 = abs(d3);\n    vec3 dir2 = step(max(score2.yzx, score2.zxy), score2);\n    vec3 v4 = v3 + dir2 * sign(d3);\n    vec3 d4 = X2 - v4;\n\n    // Gradient hashes for the four points, two from each half-lattice\n    vec4 hashes = permute(mod(vec4(v1.x, v2.x, v3.x, v4.x), 289.0));\n    hashes = permute(mod(hashes + vec4(v1.y, v2.y, v3.y, v4.y), 289.0));\n    hashes = mod(permute(mod(hashes + vec4(v1.z, v2.z, v3.z, v4.z), 289.0)), 48.0);\n\n    // Gradient extrapolations & kernel function\n    vec4 a = max(0.5 - vec4(dot(d1, d1), dot(d2, d2), dot(d3, d3), dot(d4, d4)), 0.0);\n    vec4 aa = a * a; vec4 aaaa = aa * aa;\n    vec3 g1 = grad(hashes.x); vec3 g2 = grad(hashes.y);\n    vec3 g3 = grad(hashes.z); vec3 g4 = grad(hashes.w);\n    vec4 extrapolations = vec4(dot(d1, g1), dot(d2, g2), dot(d3, g3), dot(d4, g4));\n\n    // Derivatives of the noise\n    vec3 derivative = -8.0 * mat4x3(d1, d2, d3, d4) * (aa * a * extrapolations)\n    + mat4x3(g1, g2, g3, g4) * aaaa;\n\n    // Return it all as a vec4\n    return vec4(derivative, dot(aaaa, extrapolations));\n}\n\n///// The actual code /////\nfloat speed_lines(in vec2 uv) {\n    vec2 q = uv - vec2(0.5);\n\n    float d = length(q);\n    \n    float c = 1.0;\n    float r0 = cos(atan(q.y, q.x) * 40.0 + sin(iTime * 10.0)) + 0.5;\n    float r1 = cos(atan(q.y, q.x) * 40.0 + cos(iTime * 10.0)) + 0.5;\n    float r2 = 0.03;\n    \n    c *= smoothstep(r0, r0 + 0.3, d);\n    c *= smoothstep(r1, r1 + 0.3, d);\n    c *= smoothstep(r2, r2 + 1.5, d);\n    // the openSimplex function can be replaced with perlin\n    c -= abs(openSimplex(vec3(normalize(q), sin(iTime) * 0.3 + cos(iTime * 8.0) * 0.1)).a) * (1. - d);\n    \n    return clamp(c * 2.0, 0.0, 1.0);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    \n    vec3 c = texture(iChannel0, uv).rgb;\n    vec3 color = mix(c, c + vec3(2.0, 1.4, 3.0), speed_lines(uv));\n    \n\tfragColor = vec4(color,1.0);\n}", "image_inputs": [{"id": "4df3zn", "previewfilepath": "/media/ap/3405e48f74815c7baa49133bdc835142948381fbe003ad2f12f5087715731153.ogv", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/3405e48f74815c7baa49133bdc835142948381fbe003ad2f12f5087715731153.ogv", "ctype": "video"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/7sXSRB.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "7sXSz4", "name": "Fork UniverseWi JulianCode 354", "author": "JulianCode1337", "description": "Followed a wonderful *Art of Code* tutorial // aka BigWIngs @shadertoy\nhttps://www.youtube.com/watch?v=3CycKKJiwis\n\nIf there is no sound => reload iChannel0 (Soundcloud)\n\nEnjoy :)", "tags": ["2d", "tutorial", "abstract", "pseudo3d", "artofcode"], "likes": 6, "viewed": 352, "date": "1618320366", "time_retrieved": "2024-06-20T20:36:45.289638", "image_code": "#define S(a, b, t) smoothstep(a, b, t)\n\nfloat DistLine(vec2 p, vec2 a, vec2 b) {\n    vec2 pa = p-a;\n    vec2 ba = b-a;\n    float t = clamp(dot(pa, ba)/dot(ba, ba), 0., 1.);\n    return length(pa - ba*t);\n}\n\nfloat N21 (vec2 p) {\n    p = fract(p*vec2(233.34, 851.73));\n    p += dot(p, p+23.45);\n    return fract(p.x*p.y);\n}\n\nvec2 N22(vec2 p) {\n    float n = N21(p);\n    return vec2(n, N21(p+n));\n}\n\n// Get random position\nvec2 GetPos(vec2 id, vec2 offs) {\n    vec2 n = N22(id+offs)*iTime;\n    //float x = sin(iTime * n.x);\n    //float y = cos(iTime * n.y);    \n    return offs+sin(n)*.4;\n}\n\nfloat Line(vec2 p, vec2 a, vec2 b) {\n    float d = DistLine(p, a, b);\n    float m = S(.03, .01, d);\n    float d2 = length(a-b);\n    m *= S(1.2, .8, d2)*.5+S(.05, .03, abs(d2-.75));\n    return m;\n}\n\nfloat Layer(vec2 uv) {\n    float m = 0.;\n    vec2 gv = fract(uv)-.5;\n    vec2 id = floor(uv);\n\n    //m = S(.1, .05, d);\n    \n    vec2 p[9];\n    \n    int i = 0;\n    for (float y = -1.; y <= 1.; y++) {\n        for (float x = -1.; x <= 1.; x++) {\n            p[i++] = GetPos(id, vec2(x,y));\n    }\n    }\n    float t = iTime*10.;\n    \n    for (int i = 0; i < 9; i++) {\n        m += Line(gv, p[4], p[i]);\n        \n        vec2 j = (p[i]-gv)*20.;\n        float sparkle = 1./dot(j,j);\n        \n        m += sparkle*(sin(t+fract(p[i].x)*10.)*.5 +.5);\n    }\n    m += Line(gv, p[1], p[3]);\n    m += Line(gv, p[1], p[5]);\n    m += Line(gv, p[7], p[3]);\n    m += Line(gv, p[7], p[5]);\n    \n    return m;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    vec2 mouse = (iMouse.xy/iResolution.xy) -.5;\n    \n    float gradient = uv.y;\n\n    float m = 0.;\n    float t = iTime * .1;\n\n    float s = sin(t);\n    float c = cos(t);\n    \n    mat2 rot = mat2(c, -s, s, c);    \n    uv *= rot;\n    mouse *= rot;\n    \n    // fract snaps Layer back, after he moved away => continuous Layer behind Layer\n    for (float i=0.; i<1.; i+= 1./4.) {\n        float z = fract(i+t);\n        float size = mix(10., .5, z);\n        float fade = S(0., .5, z) * S(1., .8, z);\n        m += Layer(uv * size + i*20. - mouse)*fade;\n    }\n    \n    // different colours, bc of 3 different sin-speeds\n    vec3 base = sin(t*5.*vec3(.345, .456, .657))*.4 + .6;\n    vec3 col = m*base;\n    \n    float fft = texelFetch(iChannel0, ivec2(.7,0), 0).x;\n    gradient *= fft;\n    \n    col -= gradient*base*0.4;\n    \n    \n    // Grid\n    //if (gv.x > .48 || gv.y > .48)col = vec3(1,0,0);\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/7sXSz4.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "7sXXDH", "name": "Simple Pixel Filter / Tile", "author": "NakedBowman", "description": "just pixel,im using as a working ground for somethng else atm", "tags": ["simple", "pixel", "filter", "pixelate"], "likes": 2, "viewed": 60, "date": "1618567692", "time_retrieved": "2024-06-20T20:36:45.289638", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    vec2 uv = fragCoord/iResolution.xy;\n    uv+=iTime*0.05;//DEMO\n    //Get the pixelSize \n    float pixelSize = 40.f;\n    float outline = 0.1;\n    vec2 onePixel = pixelSize / iResolution.xy;\n    vec2 coord = onePixel * floor(uv/onePixel);\n    uv*= iResolution.xy/pixelSize;\n    uv = fract(uv);\n    float border = step(outline,uv.y)-step(1.-outline,uv.y);\n    border = (step(outline,uv.x)-step(1.-outline,uv.x))*border;\n     \n    fragColor = texture(iChannel0, coord)*border;\n    border = (border -1.)* -1.;\n    vec3 borderColor = vec3(fract(iTime)+uv.x,sin(iTime)+uv.y, cos(iTime))*border;\n    fragColor.rgb +=borderColor;\n    fragColor = vec4(fragColor.rgb,border);\n}\n\n", "image_inputs": [{"id": "XdXGzn", "previewfilepath": "/media/ap/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/7sXXDH.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "7sXXW2", "name": "branches", "author": "lomateron", "description": "this...\n{\nu = vec2(atan(u.y,u.x),log(length(u)));  u = u*2.;\nu = cos(u.x-vec2(0,pi*.5))*exp(u.y);     u = u+m;\n}\nis what is needed inside a loop to make the julia fractal\nthen I just repeated each line and played with the constants until finding that", "tags": ["fractal", "zoom"], "likes": 9, "viewed": 195, "date": "1619235001", "time_retrieved": "2024-06-20T20:36:45.289638", "image_code": "float pi = 3.1415926535897932384626433832795;\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 u = (2.*fragCoord-iResolution.xy)/iResolution.y;\n    vec2 m = vec2(-6.9477,2.3521);\n    u = u*pow(2.,34.-iTime);\n    for(float i = .5; i < 45.; ++i)\n    {\n        u = vec2(atan(u.y,u.x),log(length(u)));  u = u*.5;\n        u = vec2(atan(u.y,u.x),log(length(u)));  u = u*-3.;\n        u = cos(u.x-vec2(0,pi*.5))*exp(u.y);     u = u+m;\n        u = cos(u.x-vec2(0,pi*.5))*exp(u.y);     u = u+m;\n    }\n    fragColor = (cos(u.x*8.+vec4(1,2,3,4))*.5+.5)*(sin(u.y*8.)*.4+.6);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/7sXXW2.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "fd23Dd", "name": "Freaky Dots", "author": "kaihagseth", "description": "A shader for generating moire patterns", "tags": ["moire", "pattern"], "likes": 3, "viewed": 150, "date": "1618144708", "time_retrieved": "2024-06-20T20:36:45.702798", "image_code": "\n// Author: Kai Hagseth\n// Title: Freaky Dot Patterns\n\n#ifdef GL_ES\nprecision mediump float;\n#endif\n#define PI 3.14159265359\n#define NDOTS 35.0\n#define DOTRADIUS 0.1\n\n/* \n * Inspired by the great Tadashi Tokieda\n * https://youtu.be/QAja2jp1VjE\n*/\n\n\nvec3 circle(in vec2 _st, in float _radius, vec3 color){\n    vec2 dist = _st - vec2(0.5);\n\tfloat o = 1.-smoothstep(\n                         _radius-(_radius * 0.3),\n                         _radius+(_radius * 0.3),\n                         dot(dist, dist * 4.0));\n    return color * o;\n}\n\nmat2 rotate2d(float _angle){\n    return mat2(cos(_angle),-sin(_angle),\n                sin(_angle),cos(_angle));\n}\n\n// Rotate rgb around green axis\nmat3 rotate3d(float _angle){\n\n    return mat3( cos(_angle), 0.0, sin(_angle),\n                 0.0          , 1.0, 0.0,\n                -sin(_angle), 0.0, cos(_angle));\n}\n\nvec2 rotate(in vec2 inp)\n{\n    inp *= 1.0 + (0.1 * sin(0.1 * (iTime * 0.618)));           //scale\n    inp *= rotate2d(0.1 * sin(0.1 * iTime)); //rotate\n    return inp;\n}\n\nvec3 dotPattern(vec2 st, vec3 color, float nDots, float dotRadius)\n{\n    st += iResolution.xy;\n    st *= nDots;      // Scale up the space by \n    st = fract(st);   // Wrap around 1.0\n\treturn vec3(circle(st, dotRadius, color));\n}\n\nvec3 color(in vec2 st, float t)\n{\n  vec3 c = vec3(0.7, 0.2, 0.4) + (vec3(0.5, 0., 0.) * rotate3d(iTime + st.x));\n  return vec3(c);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 st = ( fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n    st += vec2(1.0); // Offset origo\n    vec3 color = color(st, iTime);\n    \n    vec2 st1 = rotate(st);\n    vec3 dots1 = dotPattern(st1, color, NDOTS ,DOTRADIUS);\n    \n    vec2 st2 = rotate(st1);\n    vec3 dots2 = dotPattern(st2, color, NDOTS, DOTRADIUS);\n    \n    vec3 bg = vec3(0.0, 0.0, 0.2);\n    vec3 dots = dots1 + dots2 + bg;\n\t//dots = 1.0-(dots*1.0); //inverse B/W\n    fragColor = vec4(dots,1.0);\n\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/fd23Dd.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "fd2GWz", "name": "Aphantasia #1", "author": "eps", "description": "Aphantasia = inability to visualize mental images. The word is processed by text2image neural network (CLIP) => parameterized to CPPN and exported to GLSL. original technique https://github.com/wxs/cppn-to-glsl", "tags": ["neuralnet", "cppn", "text2image"], "likes": 14, "viewed": 409, "date": "1617240830", "time_retrieved": "2024-06-20T20:36:46.865453", "image_code": "\n#ifdef GL_ES\nprecision lowp float;\n#endif\n\n#define N_HIDDEN 20\nvec4 bufA[N_HIDDEN/4];\nvec4 bufB[N_HIDDEN/2];\nvec4 cppn_fn(vec2 coordinate, float in0, float in1, float in2, float in3) {\n    vec4 tmp;\n    bufB[0] = vec4(coordinate.x, coordinate.y, 0., 0.);\n\n // layer 0 \nbufA[0] = vec4(0.062, -0.340, 0.347, 0.250) + mat4(vec4(0.187, 0.547, -2.262, 0.231), vec4(-0.016, -0.157, 0.464, 1.991), vec4(0.000, 0.000, 0.000, 0.000), vec4(0.000, 0.000, 0.000, 0.000)) * bufB[0];\nbufA[1] = vec4(0.208, -0.038, -0.098, -0.020) + mat4(vec4(-0.020, 0.385, -0.230, 0.129), vec4(-0.357, -0.794, -1.492, 1.918), vec4(0.000, 0.000, 0.000, 0.000), vec4(0.000, 0.000, 0.000, 0.000)) * bufB[0];\nbufA[2] = vec4(0.277, 0.005, -0.374, -0.403) + mat4(vec4(-0.908, 0.410, 0.143, 0.150), vec4(0.171, -0.896, 0.279, 0.280), vec4(0.000, 0.000, 0.000, 0.000), vec4(0.000, 0.000, 0.000, 0.000)) * bufB[0];\nbufA[3] = vec4(0.302, 0.371, 0.040, -0.264) + mat4(vec4(-0.296, 0.291, -1.409, 1.549), vec4(-1.512, -0.483, -0.981, -0.845), vec4(0.000, 0.000, 0.000, 0.000), vec4(0.000, 0.000, 0.000, 0.000)) * bufB[0];\nbufA[4] = vec4(0.194, -0.183, -0.170, 0.421) + mat4(vec4(-0.565, -1.392, 1.732, -0.926), vec4(-0.450, 0.396, -0.183, 0.245), vec4(0.000, 0.000, 0.000, 0.000), vec4(0.000, 0.000, 0.000, 0.000)) * bufB[0];\ntmp = atan(bufA[0]);\nbufB[0] = tmp/0.67;\nbufB[5] = (tmp*tmp - 0.45) / 0.396;\ntmp = atan(bufA[1]);\nbufB[1] = tmp/0.67;\nbufB[6] = (tmp*tmp - 0.45) / 0.396;\ntmp = atan(bufA[2]);\nbufB[2] = tmp/0.67;\nbufB[7] = (tmp*tmp - 0.45) / 0.396;\ntmp = atan(bufA[3]);\nbufB[3] = tmp/0.67;\nbufB[8] = (tmp*tmp - 0.45) / 0.396;\ntmp = atan(bufA[4]);\nbufB[4] = tmp/0.67;\nbufB[9] = (tmp*tmp - 0.45) / 0.396;\n\n // layer 1 \nbufA[0] = vec4(-0.151, -0.161, -0.215, 0.488) + mat4(vec4(-0.033, -0.091, 0.227, 0.061), vec4(-0.120, 0.115, -0.301, -0.015), vec4(-0.066, -0.375, 0.005, 0.079), vec4(0.062, -0.369, 0.066, 0.088)) * bufB[0] + mat4(vec4(-0.346, 0.150, -0.098, 0.210), vec4(0.180, -0.193, -0.055, 0.044), vec4(-0.026, -0.176, -0.238, -0.035), vec4(0.150, -0.092, 0.529, 0.078)) * bufB[1] + mat4(vec4(-0.069, -0.287, -0.133, 0.122), vec4(-0.098, -0.096, -0.208, -0.141), vec4(0.224, 0.449, 0.429, -0.050), vec4(-0.271, -0.108, 0.157, -0.017)) * bufB[2] + mat4(vec4(0.066, 0.290, -0.140, 0.151), vec4(-0.036, 0.337, 0.314, 0.003), vec4(-0.185, 0.107, -0.074, 0.181), vec4(0.052, -0.067, 0.048, 0.273)) * bufB[3] + mat4(vec4(0.110, 0.255, -0.347, -0.118), vec4(0.212, 0.197, -0.059, 0.178), vec4(0.072, -0.140, 0.394, 0.264), vec4(-0.090, 0.062, -0.071, 0.057)) * bufB[4] + mat4(vec4(-0.044, -0.121, 0.099, -0.213), vec4(-0.171, -0.111, -0.041, 0.097), vec4(0.130, 0.318, -0.165, 0.056), vec4(-0.065, -0.244, -0.232, 0.189)) * bufB[5] + mat4(vec4(-0.319, 0.329, 0.026, 0.176), vec4(-0.128, -0.086, -0.307, 0.076), vec4(0.059, 0.017, 0.059, 0.204), vec4(-0.089, 0.154, 0.165, -0.054)) * bufB[6] + mat4(vec4(0.081, 0.106, -0.093, -0.024), vec4(-0.057, 0.072, -0.415, -0.285), vec4(-0.333, -0.225, -0.017, 0.121), vec4(-0.086, -0.018, 0.022, -0.241)) * bufB[7] + mat4(vec4(0.245, 0.279, 0.066, -0.027), vec4(0.032, 0.030, 0.356, -0.060), vec4(-0.099, 0.045, 0.231, 0.282), vec4(-0.014, 0.025, 0.014, -0.125)) * bufB[8] + mat4(vec4(0.029, 0.047, 0.320, 0.197), vec4(0.196, 0.182, -0.132, 0.182), vec4(0.299, 0.096, 0.107, 0.378), vec4(0.174, 0.012, -0.088, -0.055)) * bufB[9];\nbufA[1] = vec4(-0.110, -0.470, 0.136, 0.058) + mat4(vec4(0.011, 0.030, -0.195, -0.079), vec4(0.043, -0.106, 0.199, -0.097), vec4(-0.161, 0.153, -0.199, 0.268), vec4(0.020, 0.116, 0.044, 0.002)) * bufB[0] + mat4(vec4(0.046, 0.087, 0.050, -0.220), vec4(0.217, 0.200, 0.034, -0.251), vec4(-0.127, 0.164, 0.050, 0.002), vec4(-0.101, -0.341, 0.148, 0.018)) * bufB[1] + mat4(vec4(0.013, -0.067, -0.250, 0.079), vec4(0.132, 0.257, -0.138, -0.298), vec4(0.121, -0.148, 0.291, 0.100), vec4(0.435, -0.184, -0.178, 0.080)) * bufB[2] + mat4(vec4(-0.076, -0.344, -0.166, 0.166), vec4(0.021, 0.072, 0.028, -0.035), vec4(-0.091, 0.386, -0.006, -0.400), vec4(0.146, 0.098, 0.110, 0.138)) * bufB[3] + mat4(vec4(-0.318, 0.051, -0.120, 0.010), vec4(0.035, 0.037, -0.461, 0.284), vec4(-0.241, -0.087, 0.130, 0.134), vec4(-0.026, -0.083, 0.220, -0.032)) * bufB[4] + mat4(vec4(0.090, -0.065, 0.271, 0.337), vec4(0.146, -0.034, -0.011, 0.041), vec4(-0.306, -0.161, 0.228, 0.118), vec4(-0.231, 0.124, 0.053, -0.380)) * bufB[5] + mat4(vec4(0.109, -0.086, -0.140, 0.180), vec4(0.141, 0.163, -0.060, 0.071), vec4(-0.094, 0.021, -0.175, -0.477), vec4(0.173, -0.096, -0.347, -0.283)) * bufB[6] + mat4(vec4(0.246, -0.086, 0.122, 0.001), vec4(-0.025, 0.055, -0.188, -0.089), vec4(-0.012, 0.214, -0.029, 0.053), vec4(0.068, -0.014, 0.225, 0.086)) * bufB[7] + mat4(vec4(0.203, -0.078, -0.268, -0.095), vec4(0.244, -0.242, 0.068, -0.088), vec4(-0.357, -0.092, 0.076, 0.180), vec4(0.355, -0.502, -0.271, -0.303)) * bufB[8] + mat4(vec4(-0.029, 0.358, 0.235, 0.111), vec4(-0.213, -0.195, 0.034, -0.260), vec4(-0.280, -0.017, 0.220, -0.342), vec4(-0.200, 0.102, -0.097, 0.023)) * bufB[9];\nbufA[2] = vec4(-0.532, -0.426, -0.107, -0.462) + mat4(vec4(-0.080, 0.021, 0.095, 0.107), vec4(-0.174, 0.189, -0.274, -0.070), vec4(0.533, -0.020, -0.094, 0.192), vec4(0.014, -0.010, -0.339, -0.168)) * bufB[0] + mat4(vec4(-0.234, 0.144, -0.160, -0.130), vec4(-0.115, 0.133, 0.128, 0.127), vec4(-0.287, 0.061, 0.094, 0.278), vec4(-0.244, 0.245, -0.493, 0.042)) * bufB[1] + mat4(vec4(-0.085, -0.308, -0.161, 0.003), vec4(-0.163, 0.063, 0.060, 0.125), vec4(0.058, 0.140, 0.127, -0.203), vec4(0.301, -0.001, 0.014, -0.232)) * bufB[2] + mat4(vec4(-0.202, 0.084, 0.328, 0.297), vec4(-0.130, -0.124, -0.161, -0.043), vec4(0.152, 0.254, 0.004, 0.200), vec4(-0.116, -0.085, -0.041, -0.260)) * bufB[3] + mat4(vec4(0.079, 0.047, 0.112, 0.090), vec4(-0.064, -0.125, 0.211, 0.410), vec4(0.308, 0.009, 0.251, -0.103), vec4(0.052, 0.352, -0.175, -0.372)) * bufB[4] + mat4(vec4(0.215, -0.060, -0.101, -0.067), vec4(0.112, -0.273, 0.125, 0.080), vec4(-0.314, -0.243, -0.307, 0.052), vec4(-0.058, 0.116, 0.109, -0.078)) * bufB[5] + mat4(vec4(0.245, -0.006, 0.153, 0.221), vec4(0.161, 0.072, 0.208, -0.188), vec4(-0.227, -0.142, 0.172, -0.097), vec4(0.033, -0.068, 0.112, -0.090)) * bufB[6] + mat4(vec4(0.105, -0.010, -0.111, 0.145), vec4(-0.064, -0.036, -0.068, -0.182), vec4(-0.055, -0.037, -0.105, 0.203), vec4(-0.100, 0.213, 0.059, 0.055)) * bufB[7] + mat4(vec4(-0.158, -0.228, 0.308, -0.056), vec4(-0.063, 0.176, 0.040, -0.009), vec4(-0.284, 0.131, 0.096, 0.064), vec4(-0.067, 0.111, -0.307, 0.035)) * bufB[8] + mat4(vec4(-0.033, 0.002, 0.050, 0.337), vec4(-0.044, -0.432, -0.191, -0.080), vec4(-0.290, -0.201, -0.460, 0.214), vec4(-0.177, -0.162, 0.105, 0.350)) * bufB[9];\nbufA[3] = vec4(-0.468, -0.462, -0.391, -0.210) + mat4(vec4(-0.072, -0.183, 0.010, -0.064), vec4(0.178, 0.165, 0.022, 0.089), vec4(-0.296, -0.030, 0.319, 0.064), vec4(-0.117, -0.161, 0.135, 0.204)) * bufB[0] + mat4(vec4(0.179, 0.035, 0.031, -0.146), vec4(-0.089, 0.151, -0.213, 0.057), vec4(-0.087, 0.325, -0.070, -0.298), vec4(0.173, -0.004, -0.177, 0.309)) * bufB[1] + mat4(vec4(-0.158, -0.114, -0.045, -0.139), vec4(-0.199, 0.041, -0.146, 0.078), vec4(0.171, 0.052, -0.136, -0.170), vec4(0.299, -0.102, 0.248, 0.029)) * bufB[2] + mat4(vec4(-0.017, -0.041, -0.030, -0.064), vec4(0.183, -0.184, -0.256, 0.090), vec4(0.205, -0.139, 0.093, -0.200), vec4(0.182, 0.169, -0.171, 0.024)) * bufB[3] + mat4(vec4(-0.218, -0.209, 0.095, 0.225), vec4(0.024, 0.100, 0.049, -0.109), vec4(0.017, 0.098, -0.082, -0.218), vec4(-0.079, -0.070, 0.042, 0.231)) * bufB[4] + mat4(vec4(0.024, 0.043, -0.121, 0.219), vec4(0.074, 0.135, -0.024, -0.004), vec4(-0.364, 0.230, 0.224, 0.109), vec4(0.207, -0.077, -0.138, -0.155)) * bufB[5] + mat4(vec4(-0.278, -0.049, 0.127, -0.062), vec4(0.064, -0.151, -0.199, -0.058), vec4(0.162, -0.026, 0.023, 0.262), vec4(0.028, -0.262, 0.096, -0.311)) * bufB[6] + mat4(vec4(-0.049, 0.249, 0.164, -0.227), vec4(-0.076, -0.119, 0.148, -0.158), vec4(0.341, -0.203, -0.070, -0.139), vec4(-0.130, 0.103, -0.312, -0.121)) * bufB[7] + mat4(vec4(-0.113, 0.179, 0.206, -0.164), vec4(-0.018, -0.107, -0.322, -0.478), vec4(-0.336, -0.064, 0.249, 0.057), vec4(-0.144, 0.172, -0.078, 0.392)) * bufB[8] + mat4(vec4(0.048, 0.113, 0.150, 0.051), vec4(0.101, -0.027, -0.328, 0.145), vec4(0.007, 0.111, -0.026, 0.062), vec4(-0.144, 0.006, 0.029, -0.082)) * bufB[9];\nbufA[4] = vec4(-0.124, 0.407, 0.524, -0.398) + mat4(vec4(0.166, 0.073, 0.161, -0.131), vec4(-0.148, -0.010, -0.232, -0.021), vec4(-0.299, 0.042, 0.172, 0.228), vec4(-0.256, 0.082, 0.039, 0.165)) * bufB[0] + mat4(vec4(0.185, -0.045, 0.038, 0.076), vec4(-0.068, -0.142, 0.044, 0.248), vec4(0.151, -0.048, -0.187, -0.102), vec4(0.141, -0.249, -0.172, 0.017)) * bufB[1] + mat4(vec4(-0.424, 0.169, 0.104, 0.034), vec4(0.486, 0.383, -0.181, 0.107), vec4(0.051, 0.056, -0.155, -0.044), vec4(-0.061, -0.045, 0.017, -0.187)) * bufB[2] + mat4(vec4(0.003, -0.005, -0.040, -0.016), vec4(-0.148, 0.020, 0.281, -0.047), vec4(0.117, -0.054, 0.089, 0.206), vec4(0.040, -0.090, -0.159, 0.209)) * bufB[3] + mat4(vec4(-0.004, 0.172, 0.282, -0.343), vec4(-0.328, 0.021, 0.142, 0.119), vec4(0.077, -0.076, -0.064, -0.004), vec4(-0.585, -0.076, 0.192, -0.069)) * bufB[4] + mat4(vec4(-0.023, -0.104, -0.395, -0.245), vec4(-0.182, 0.013, 0.113, -0.195), vec4(0.002, -0.275, 0.064, -0.081), vec4(0.186, 0.128, 0.213, -0.041)) * bufB[5] + mat4(vec4(-0.074, 0.278, 0.168, 0.048), vec4(-0.164, 0.090, -0.326, 0.061), vec4(0.086, 0.168, -0.185, 0.399), vec4(0.352, 0.002, -0.024, 0.334)) * bufB[6] + mat4(vec4(-0.374, -0.021, 0.239, 0.117), vec4(-0.151, 0.019, -0.053, 0.007), vec4(-0.063, -0.137, -0.056, 0.343), vec4(-0.255, 0.025, -0.043, 0.123)) * bufB[7] + mat4(vec4(0.091, -0.082, -0.179, -0.178), vec4(0.232, -0.055, -0.165, 0.008), vec4(0.145, 0.090, 0.410, 0.194), vec4(-0.009, 0.179, 0.367, -0.076)) * bufB[8] + mat4(vec4(0.172, -0.212, 0.005, -0.025), vec4(-0.083, -0.117, 0.130, 0.040), vec4(-0.087, -0.386, 0.170, -0.137), vec4(-0.314, 0.173, 0.111, -0.281)) * bufB[9];\ntmp = atan(bufA[0]);\nbufB[0] = tmp/0.67;\nbufB[5] = (tmp*tmp - 0.45) / 0.396;\ntmp = atan(bufA[1]);\nbufB[1] = tmp/0.67;\nbufB[6] = (tmp*tmp - 0.45) / 0.396;\ntmp = atan(bufA[2]);\nbufB[2] = tmp/0.67;\nbufB[7] = (tmp*tmp - 0.45) / 0.396;\ntmp = atan(bufA[3]);\nbufB[3] = tmp/0.67;\nbufB[8] = (tmp*tmp - 0.45) / 0.396;\ntmp = atan(bufA[4]);\nbufB[4] = tmp/0.67;\nbufB[9] = (tmp*tmp - 0.45) / 0.396;\n\n // layer 2 \nbufA[0] = vec4(0.263, 0.336, 0.423, 0.384) + mat4(vec4(0.143, 0.328, 0.059, 0.019), vec4(0.034, 0.115, -0.010, 0.154), vec4(-0.027, -0.089, -0.039, 0.125), vec4(-0.004, 0.060, 0.298, 0.092)) * bufB[0] + mat4(vec4(-0.025, -0.110, -0.185, -0.009), vec4(-0.046, -0.187, -0.075, 0.279), vec4(0.095, 0.151, -0.109, 0.088), vec4(-0.103, 0.212, -0.262, 0.175)) * bufB[1] + mat4(vec4(-0.016, -0.312, -0.193, -0.079), vec4(-0.098, -0.342, 0.214, 0.177), vec4(-0.123, -0.315, -0.004, 0.087), vec4(0.385, 0.043, 0.146, -0.101)) * bufB[2] + mat4(vec4(-0.087, -0.032, 0.075, 0.128), vec4(0.043, -0.135, -0.283, -0.119), vec4(-0.131, -0.039, -0.028, -0.214), vec4(-0.134, 0.438, -0.094, -0.196)) * bufB[3] + mat4(vec4(-0.043, -0.033, 0.126, -0.067), vec4(-0.090, -0.035, 0.148, 0.101), vec4(-0.041, 0.010, -0.206, -0.116), vec4(-0.008, -0.143, 0.012, 0.132)) * bufB[4] + mat4(vec4(-0.001, -0.033, -0.067, -0.136), vec4(-0.039, -0.017, 0.019, -0.030), vec4(0.067, -0.168, 0.063, -0.023), vec4(0.265, 0.064, 0.316, -0.213)) * bufB[5] + mat4(vec4(0.153, 0.215, -0.135, -0.071), vec4(0.078, -0.248, -0.116, -0.177), vec4(-0.193, 0.026, 0.128, -0.076), vec4(-0.034, -0.016, 0.083, -0.290)) * bufB[6] + mat4(vec4(0.220, 0.112, -0.098, -0.183), vec4(-0.139, -0.039, -0.068, -0.097), vec4(0.017, -0.140, 0.195, 0.071), vec4(0.051, 0.004, 0.003, 0.025)) * bufB[7] + mat4(vec4(0.122, 0.039, 0.074, -0.091), vec4(-0.156, -0.275, -0.249, -0.104), vec4(0.009, 0.037, 0.223, 0.118), vec4(-0.004, 0.278, -0.144, 0.008)) * bufB[8] + mat4(vec4(-0.002, 0.038, 0.375, -0.254), vec4(-0.156, -0.280, -0.469, 0.181), vec4(0.316, 0.212, -0.017, 0.121), vec4(-0.003, 0.114, 0.060, 0.026)) * bufB[9];\nbufA[1] = vec4(-0.499, 0.460, 0.278, 0.286) + mat4(vec4(0.047, -0.173, -0.242, -0.033), vec4(-0.062, -0.188, 0.150, 0.014), vec4(-0.084, -0.032, -0.234, 0.297), vec4(0.033, 0.281, 0.149, -0.044)) * bufB[0] + mat4(vec4(0.013, 0.189, -0.105, 0.218), vec4(0.014, 0.339, -0.037, -0.030), vec4(0.049, 0.310, -0.045, -0.033), vec4(0.119, -0.070, 0.459, 0.199)) * bufB[1] + mat4(vec4(0.276, 0.126, 0.143, 0.001), vec4(0.389, 0.241, 0.043, 0.095), vec4(-0.202, -0.291, -0.575, 0.123), vec4(-0.099, 0.069, -0.127, 0.102)) * bufB[2] + mat4(vec4(0.212, 0.250, 0.038, 0.199), vec4(-0.020, 0.083, -0.041, 0.024), vec4(-0.294, -0.194, 0.236, 0.146), vec4(0.153, -0.094, -0.378, -0.289)) * bufB[3] + mat4(vec4(0.104, -0.038, -0.216, 0.081), vec4(-0.173, 0.166, 0.177, 0.129), vec4(-0.038, -0.015, 0.259, 0.087), vec4(-0.199, -0.134, -0.002, -0.079)) * bufB[4] + mat4(vec4(-0.008, 0.046, -0.113, 0.031), vec4(-0.099, 0.024, -0.005, 0.194), vec4(-0.258, 0.105, -0.067, 0.072), vec4(-0.187, 0.138, -0.118, 0.218)) * bufB[5] + mat4(vec4(-0.271, 0.235, -0.173, -0.095), vec4(-0.163, -0.090, 0.089, 0.207), vec4(-0.125, 0.048, -0.037, -0.038), vec4(-0.084, 0.025, -0.100, 0.142)) * bufB[6] + mat4(vec4(-0.070, 0.032, 0.134, 0.105), vec4(-0.111, 0.001, -0.111, 0.044), vec4(0.138, 0.098, 0.169, 0.138), vec4(-0.110, 0.111, -0.273, -0.006)) * bufB[7] + mat4(vec4(0.156, 0.042, 0.430, -0.014), vec4(-0.020, 0.325, 0.364, 0.140), vec4(0.020, -0.052, -0.027, -0.090), vec4(0.032, -0.036, 0.098, 0.114)) * bufB[8] + mat4(vec4(0.167, 0.239, 0.147, -0.250), vec4(-0.179, -0.109, 0.198, -0.002), vec4(-0.021, -0.063, -0.006, 0.085), vec4(0.176, 0.013, -0.048, 0.211)) * bufB[9];\nbufA[2] = vec4(-0.100, -0.218, 0.495, -0.202) + mat4(vec4(0.105, 0.078, 0.056, 0.127), vec4(0.086, 0.049, 0.294, 0.123), vec4(0.185, -0.048, -0.047, 0.108), vec4(-0.116, -0.260, 0.059, 0.303)) * bufB[0] + mat4(vec4(-0.100, -0.089, 0.052, 0.146), vec4(-0.055, -0.043, 0.015, -0.224), vec4(0.139, 0.349, -0.251, 0.047), vec4(0.077, 0.273, -0.538, -0.093)) * bufB[1] + mat4(vec4(0.409, 0.105, 0.307, -0.166), vec4(0.077, 0.166, -0.158, 0.036), vec4(0.073, -0.255, 0.229, -0.112), vec4(0.018, 0.098, -0.070, 0.005)) * bufB[2] + mat4(vec4(-0.061, 0.137, 0.099, -0.432), vec4(0.172, 0.069, -0.145, -0.313), vec4(-0.136, -0.029, -0.001, -0.067), vec4(-0.027, 0.280, 0.106, -0.166)) * bufB[3] + mat4(vec4(-0.084, -0.041, 0.331, 0.140), vec4(0.081, -0.049, -0.071, -0.013), vec4(-0.135, 0.150, 0.042, 0.329), vec4(0.190, 0.299, -0.076, 0.030)) * bufB[4] + mat4(vec4(-0.018, 0.201, -0.034, -0.075), vec4(0.118, 0.288, -0.107, 0.030), vec4(-0.182, -0.206, -0.090, 0.048), vec4(0.231, 0.125, -0.116, -0.066)) * bufB[5] + mat4(vec4(-0.045, 0.003, -0.248, 0.193), vec4(-0.027, 0.118, -0.138, -0.047), vec4(0.129, 0.248, -0.155, 0.281), vec4(0.081, -0.231, -0.058, -0.212)) * bufB[6] + mat4(vec4(-0.033, -0.311, -0.047, -0.080), vec4(-0.084, -0.111, 0.079, 0.030), vec4(0.411, 0.306, 0.075, 0.391), vec4(0.063, 0.080, 0.321, 0.069)) * bufB[7] + mat4(vec4(-0.288, -0.210, -0.045, -0.068), vec4(0.105, 0.083, 0.257, 0.253), vec4(-0.082, 0.022, -0.230, -0.196), vec4(0.199, 0.203, -0.199, 0.032)) * bufB[8] + mat4(vec4(-0.161, -0.258, -0.054, 0.346), vec4(-0.112, -0.102, 0.124, 0.038), vec4(-0.095, -0.102, -0.199, 0.164), vec4(0.015, 0.134, -0.142, -0.150)) * bufB[9];\nbufA[3] = vec4(-0.129, 0.382, -0.015, -0.515) + mat4(vec4(-0.006, -0.022, 0.113, -0.102), vec4(-0.056, -0.090, -0.007, 0.112), vec4(0.109, 0.206, -0.040, -0.103), vec4(0.090, 0.015, 0.032, -0.072)) * bufB[0] + mat4(vec4(0.082, -0.052, -0.118, -0.116), vec4(0.296, 0.117, 0.069, -0.031), vec4(0.309, 0.038, -0.024, 0.059), vec4(0.007, 0.327, 0.099, 0.005)) * bufB[1] + mat4(vec4(0.036, 0.175, 0.202, -0.013), vec4(0.042, 0.153, 0.036, 0.196), vec4(-0.158, 0.074, 0.053, 0.082), vec4(0.196, 0.131, -0.111, -0.103)) * bufB[2] + mat4(vec4(-0.113, -0.175, -0.083, 0.218), vec4(0.044, -0.065, -0.143, 0.153), vec4(0.152, -0.204, -0.207, -0.081), vec4(0.219, 0.084, 0.227, 0.041)) * bufB[3] + mat4(vec4(-0.286, 0.115, 0.219, -0.055), vec4(0.086, -0.217, 0.171, -0.253), vec4(-0.071, 0.069, 0.183, -0.035), vec4(-0.040, 0.186, -0.049, 0.187)) * bufB[4] + mat4(vec4(-0.076, -0.025, -0.115, -0.002), vec4(-0.105, 0.296, -0.027, 0.298), vec4(-0.042, 0.077, -0.048, -0.271), vec4(0.162, 0.061, -0.161, -0.248)) * bufB[5] + mat4(vec4(0.003, 0.287, -0.258, -0.217), vec4(-0.293, -0.167, -0.272, -0.071), vec4(-0.145, -0.049, -0.046, -0.157), vec4(0.032, 0.113, -0.164, 0.096)) * bufB[6] + mat4(vec4(-0.030, -0.129, -0.107, -0.198), vec4(0.192, -0.213, -0.207, 0.274), vec4(-0.471, -0.353, -0.340, 0.193), vec4(-0.354, -0.063, -0.064, -0.254)) * bufB[7] + mat4(vec4(0.358, 0.058, 0.064, -0.132), vec4(-0.108, -0.004, 0.045, 0.350), vec4(-0.008, -0.206, -0.019, 0.107), vec4(0.076, -0.248, -0.113, 0.076)) * bufB[8] + mat4(vec4(0.084, -0.045, 0.037, -0.041), vec4(-0.009, 0.173, 0.018, 0.147), vec4(0.261, 0.174, 0.002, -0.352), vec4(0.048, -0.004, -0.242, 0.029)) * bufB[9];\nbufA[4] = vec4(-0.124, 0.137, -0.025, -0.342) + mat4(vec4(0.189, 0.162, -0.028, 0.057), vec4(-0.065, 0.015, 0.345, -0.147), vec4(0.138, 0.056, 0.036, 0.009), vec4(-0.040, 0.189, -0.332, -0.147)) * bufB[0] + mat4(vec4(-0.242, -0.042, 0.126, -0.025), vec4(0.145, 0.030, -0.064, -0.086), vec4(-0.089, -0.029, 0.158, 0.115), vec4(-0.044, 0.050, 0.003, -0.010)) * bufB[1] + mat4(vec4(0.185, -0.028, -0.188, 0.047), vec4(0.047, -0.010, -0.256, -0.089), vec4(-0.303, -0.035, 0.032, -0.035), vec4(-0.007, 0.073, 0.045, -0.286)) * bufB[2] + mat4(vec4(0.061, 0.113, -0.149, 0.155), vec4(-0.089, 0.081, -0.044, 0.034), vec4(0.293, 0.285, 0.031, -0.126), vec4(-0.220, 0.097, -0.137, 0.077)) * bufB[3] + mat4(vec4(-0.196, -0.024, -0.134, 0.192), vec4(0.096, 0.018, -0.087, 0.165), vec4(-0.099, 0.014, -0.207, -0.202), vec4(0.234, -0.239, -0.093, -0.160)) * bufB[4] + mat4(vec4(0.215, 0.248, -0.073, 0.022), vec4(0.204, -0.196, -0.105, 0.293), vec4(-0.100, 0.242, -0.108, 0.158), vec4(-0.076, -0.128, -0.021, 0.094)) * bufB[5] + mat4(vec4(-0.009, 0.008, -0.212, -0.260), vec4(0.072, 0.290, -0.346, -0.088), vec4(0.294, 0.215, -0.069, 0.207), vec4(0.281, -0.175, 0.042, 0.146)) * bufB[6] + mat4(vec4(0.130, -0.076, 0.316, 0.002), vec4(0.100, 0.178, 0.107, 0.055), vec4(-0.248, 0.104, -0.235, -0.091), vec4(-0.263, 0.068, 0.169, 0.126)) * bufB[7] + mat4(vec4(-0.041, 0.232, 0.091, -0.199), vec4(-0.171, -0.211, -0.244, -0.038), vec4(-0.145, -0.169, 0.142, 0.080), vec4(0.069, 0.093, -0.416, -0.111)) * bufB[8] + mat4(vec4(-0.274, -0.177, -0.051, 0.332), vec4(0.008, 0.037, -0.146, -0.046), vec4(-0.076, -0.235, 0.079, -0.156), vec4(0.211, -0.050, 0.075, -0.009)) * bufB[9];\ntmp = atan(bufA[0]);\nbufB[0] = tmp/0.67;\nbufB[5] = (tmp*tmp - 0.45) / 0.396;\ntmp = atan(bufA[1]);\nbufB[1] = tmp/0.67;\nbufB[6] = (tmp*tmp - 0.45) / 0.396;\ntmp = atan(bufA[2]);\nbufB[2] = tmp/0.67;\nbufB[7] = (tmp*tmp - 0.45) / 0.396;\ntmp = atan(bufA[3]);\nbufB[3] = tmp/0.67;\nbufB[8] = (tmp*tmp - 0.45) / 0.396;\ntmp = atan(bufA[4]);\nbufB[4] = tmp/0.67;\nbufB[9] = (tmp*tmp - 0.45) / 0.396;\n\n // layer 3 \nbufA[0] = vec4(-0.440, -0.072, -0.094, 0.135) + mat4(vec4(-0.085, -0.054, -0.057, 0.110), vec4(-0.137, 0.107, -0.293, 0.176), vec4(0.033, 0.021, 0.029, 0.199), vec4(0.029, 0.180, 0.003, 0.095)) * bufB[0] + mat4(vec4(-0.073, -0.244, -0.245, -0.071), vec4(-0.057, 0.088, 0.005, 0.175), vec4(0.046, -0.018, 0.186, 0.094), vec4(0.175, 0.157, -0.023, -0.068)) * bufB[1] + mat4(vec4(0.051, 0.191, -0.079, 0.097), vec4(0.234, -0.040, -0.133, 0.243), vec4(-0.084, -0.189, -0.046, -0.014), vec4(0.227, -0.109, 0.014, 0.160)) * bufB[2] + mat4(vec4(-0.135, -0.173, 0.064, 0.035), vec4(0.255, 0.229, 0.060, 0.295), vec4(-0.154, -0.207, -0.054, 0.077), vec4(-0.013, -0.133, 0.065, -0.165)) * bufB[3] + mat4(vec4(-0.030, 0.196, -0.115, -0.022), vec4(0.009, 0.099, -0.042, 0.257), vec4(-0.095, -0.145, 0.206, -0.038), vec4(0.072, 0.066, 0.001, 0.003)) * bufB[4] + mat4(vec4(0.238, 0.036, -0.111, 0.085), vec4(-0.301, 0.093, 0.024, 0.314), vec4(0.073, -0.321, -0.185, -0.204), vec4(-0.021, 0.061, -0.253, -0.206)) * bufB[5] + mat4(vec4(0.214, -0.023, -0.118, 0.026), vec4(0.068, 0.080, -0.032, -0.239), vec4(-0.239, 0.082, 0.119, 0.243), vec4(0.203, 0.033, -0.121, -0.161)) * bufB[6] + mat4(vec4(0.262, 0.043, 0.051, -0.189), vec4(0.278, -0.177, 0.353, 0.307), vec4(-0.063, -0.097, -0.226, -0.133), vec4(-0.029, -0.165, -0.125, -0.151)) * bufB[7] + mat4(vec4(-0.079, -0.003, 0.102, 0.117), vec4(-0.120, 0.256, 0.194, 0.083), vec4(-0.077, 0.113, -0.020, 0.032), vec4(-0.123, -0.147, -0.169, 0.227)) * bufB[8] + mat4(vec4(-0.059, -0.174, -0.010, -0.053), vec4(-0.046, 0.027, -0.040, 0.050), vec4(0.229, -0.057, -0.393, -0.105), vec4(0.061, -0.019, 0.350, -0.167)) * bufB[9] + in0;\nbufA[1] = vec4(-0.321, -0.319, 0.276, 0.357) + mat4(vec4(0.052, -0.080, 0.025, -0.302), vec4(-0.062, 0.026, -0.044, -0.279), vec4(0.093, 0.191, 0.553, -0.061), vec4(0.203, 0.136, 0.009, 0.188)) * bufB[0] + mat4(vec4(0.184, 0.049, -0.115, 0.178), vec4(0.197, 0.064, -0.105, 0.347), vec4(-0.039, 0.271, -0.075, 0.381), vec4(-0.018, -0.046, 0.131, -0.015)) * bufB[1] + mat4(vec4(0.058, 0.098, -0.324, -0.025), vec4(-0.064, 0.070, -0.290, 0.248), vec4(0.018, -0.036, -0.002, -0.293), vec4(0.365, 0.074, 0.123, 0.325)) * bufB[2] + mat4(vec4(-0.002, -0.073, -0.101, -0.287), vec4(0.307, 0.067, -0.101, -0.017), vec4(-0.133, 0.144, 0.194, 0.371), vec4(0.147, 0.028, -0.079, -0.323)) * bufB[3] + mat4(vec4(-0.259, -0.221, -0.002, -0.223), vec4(0.211, -0.039, 0.129, -0.144), vec4(0.080, -0.009, 0.022, -0.390), vec4(0.259, 0.051, -0.115, 0.138)) * bufB[4] + mat4(vec4(0.114, -0.309, 0.218, -0.253), vec4(0.168, 0.174, 0.017, 0.319), vec4(0.188, 0.042, 0.077, -0.106), vec4(0.348, -0.206, -0.064, 0.016)) * bufB[5] + mat4(vec4(-0.009, -0.184, -0.220, 0.078), vec4(0.376, -0.126, 0.080, -0.045), vec4(-0.082, 0.149, -0.308, 0.203), vec4(-0.076, 0.090, 0.163, -0.034)) * bufB[6] + mat4(vec4(-0.149, 0.033, 0.159, 0.064), vec4(0.032, -0.222, 0.037, -0.280), vec4(-0.233, -0.261, -0.019, 0.227), vec4(-0.224, -0.110, 0.206, -0.079)) * bufB[7] + mat4(vec4(-0.031, -0.018, 0.132, -0.051), vec4(-0.266, -0.003, -0.048, -0.234), vec4(-0.170, -0.050, 0.018, 0.137), vec4(-0.156, 0.119, 0.294, -0.114)) * bufB[8] + mat4(vec4(-0.070, -0.173, 0.373, 0.175), vec4(-0.001, -0.194, -0.249, 0.123), vec4(-0.304, -0.008, 0.158, 0.077), vec4(0.208, -0.118, 0.309, -0.144)) * bufB[9] + in1;\nbufA[2] = vec4(-0.325, -0.401, 0.196, 0.421) + mat4(vec4(0.100, -0.194, -0.035, -0.070), vec4(0.121, -0.128, -0.172, -0.275), vec4(0.084, -0.134, -0.334, -0.294), vec4(0.023, -0.145, 0.223, -0.018)) * bufB[0] + mat4(vec4(0.227, -0.018, -0.021, 0.053), vec4(0.208, -0.093, -0.052, -0.115), vec4(-0.341, -0.154, -0.255, -0.235), vec4(-0.246, -0.069, -0.058, 0.031)) * bufB[1] + mat4(vec4(0.374, 0.305, 0.015, 0.076), vec4(0.261, 0.171, 0.042, 0.131), vec4(-0.027, 0.018, -0.027, 0.327), vec4(0.006, 0.029, 0.185, -0.244)) * bufB[2] + mat4(vec4(-0.006, -0.244, 0.059, -0.409), vec4(0.152, 0.019, 0.057, -0.233), vec4(0.212, 0.154, 0.051, -0.149), vec4(0.011, -0.031, 0.102, -0.015)) * bufB[3] + mat4(vec4(0.111, -0.341, -0.031, -0.131), vec4(0.003, -0.303, 0.082, 0.021), vec4(0.057, 0.142, 0.196, 0.182), vec4(0.000, 0.481, 0.091, 0.142)) * bufB[4] + mat4(vec4(-0.061, 0.239, 0.024, 0.068), vec4(0.014, -0.020, 0.257, -0.105), vec4(-0.124, -0.200, 0.076, -0.050), vec4(-0.175, 0.146, 0.127, 0.196)) * bufB[5] + mat4(vec4(-0.118, -0.020, -0.177, 0.354), vec4(0.168, -0.021, 0.160, -0.024), vec4(0.114, -0.119, -0.538, -0.164), vec4(-0.004, -0.150, -0.016, 0.032)) * bufB[6] + mat4(vec4(-0.222, -0.251, 0.050, 0.093), vec4(0.276, -0.092, -0.236, -0.278), vec4(-0.069, 0.271, -0.170, 0.244), vec4(-0.046, -0.252, 0.004, 0.127)) * bufB[7] + mat4(vec4(-0.006, -0.134, 0.201, 0.101), vec4(-0.143, 0.080, -0.052, 0.081), vec4(-0.074, -0.152, -0.117, -0.052), vec4(0.076, -0.259, -0.095, -0.146)) * bufB[8] + mat4(vec4(0.263, -0.099, 0.253, 0.005), vec4(-0.079, -0.007, -0.235, 0.201), vec4(-0.151, 0.086, 0.124, 0.033), vec4(0.035, -0.239, -0.070, 0.067)) * bufB[9] + in2;\nbufA[3] = vec4(-0.154, -0.188, 0.216, -0.112) + mat4(vec4(0.093, 0.131, -0.005, -0.026), vec4(0.119, 0.085, -0.041, 0.235), vec4(-0.142, 0.033, 0.092, -0.043), vec4(0.182, 0.139, -0.327, -0.060)) * bufB[0] + mat4(vec4(0.155, -0.033, -0.048, 0.164), vec4(-0.386, -0.142, 0.311, 0.233), vec4(0.386, -0.031, 0.166, -0.033), vec4(-0.013, -0.083, 0.114, 0.084)) * bufB[1] + mat4(vec4(0.080, 0.000, 0.069, 0.169), vec4(0.019, -0.116, 0.018, 0.175), vec4(0.047, -0.109, 0.071, -0.313), vec4(-0.106, -0.161, -0.224, 0.104)) * bufB[2] + mat4(vec4(0.194, 0.084, 0.204, 0.025), vec4(0.064, -0.182, -0.037, 0.009), vec4(0.049, 0.140, -0.499, -0.296), vec4(0.027, -0.233, -0.135, 0.203)) * bufB[3] + mat4(vec4(0.035, 0.180, 0.224, -0.195), vec4(-0.041, 0.309, 0.030, -0.169), vec4(-0.023, 0.369, -0.173, -0.298), vec4(-0.098, -0.126, 0.082, -0.058)) * bufB[4] + mat4(vec4(-0.145, 0.053, -0.029, -0.236), vec4(-0.047, -0.022, -0.265, 0.122), vec4(-0.342, 0.151, 0.025, 0.136), vec4(-0.375, -0.194, 0.175, -0.249)) * bufB[5] + mat4(vec4(-0.262, -0.004, 0.060, 0.539), vec4(0.315, -0.167, 0.099, 0.089), vec4(0.239, 0.150, 0.223, 0.178), vec4(-0.023, 0.230, -0.050, -0.043)) * bufB[6] + mat4(vec4(0.025, 0.171, -0.218, -0.044), vec4(-0.196, 0.210, -0.119, -0.000), vec4(-0.144, 0.186, 0.182, -0.134), vec4(0.239, 0.048, 0.187, 0.173)) * bufB[7] + mat4(vec4(-0.180, -0.035, 0.141, -0.259), vec4(0.184, -0.104, -0.136, 0.096), vec4(0.075, -0.150, 0.027, -0.259), vec4(-0.039, 0.291, -0.188, -0.112)) * bufB[8] + mat4(vec4(-0.146, 0.396, 0.179, -0.242), vec4(-0.131, 0.366, 0.138, -0.014), vec4(0.027, -0.066, 0.062, 0.224), vec4(0.320, 0.359, -0.199, 0.094)) * bufB[9] + in3;\nbufA[4] = vec4(0.109, 0.029, -0.449, 0.494) + mat4(vec4(-0.168, 0.094, 0.276, -0.060), vec4(-0.205, 0.491, 0.120, 0.084), vec4(-0.261, -0.312, -0.006, -0.311), vec4(0.262, -0.201, 0.196, -0.456)) * bufB[0] + mat4(vec4(0.093, 0.123, 0.113, 0.053), vec4(-0.103, -0.188, -0.044, 0.125), vec4(0.005, -0.327, 0.193, 0.276), vec4(0.117, 0.117, 0.154, 0.060)) * bufB[1] + mat4(vec4(-0.069, -0.016, -0.248, 0.180), vec4(-0.202, 0.049, -0.188, 0.122), vec4(0.106, -0.007, 0.088, -0.032), vec4(-0.161, -0.336, -0.001, 0.087)) * bufB[2] + mat4(vec4(0.042, 0.126, 0.163, -0.032), vec4(0.092, -0.173, 0.349, 0.279), vec4(0.029, -0.036, -0.051, -0.226), vec4(0.030, 0.029, 0.037, -0.314)) * bufB[3] + mat4(vec4(-0.066, 0.006, 0.052, -0.203), vec4(-0.207, -0.153, -0.051, 0.018), vec4(0.095, 0.290, -0.056, 0.199), vec4(-0.235, 0.073, -0.202, -0.281)) * bufB[4] + mat4(vec4(0.029, 0.090, 0.299, -0.075), vec4(-0.165, -0.125, -0.043, 0.205), vec4(0.079, 0.151, -0.050, -0.086), vec4(0.010, 0.226, -0.097, 0.174)) * bufB[5] + mat4(vec4(0.002, 0.304, 0.303, -0.035), vec4(-0.135, 0.296, 0.207, -0.196), vec4(-0.016, -0.068, 0.082, 0.122), vec4(0.005, 0.169, 0.060, 0.069)) * bufB[6] + mat4(vec4(0.053, 0.009, 0.097, -0.088), vec4(0.145, -0.009, -0.100, -0.388), vec4(0.013, -0.247, 0.043, -0.043), vec4(-0.159, -0.136, -0.214, 0.234)) * bufB[7] + mat4(vec4(-0.101, -0.134, 0.043, 0.018), vec4(0.133, 0.164, 0.166, -0.238), vec4(0.138, 0.161, -0.021, 0.024), vec4(-0.141, 0.126, -0.180, -0.203)) * bufB[8] + mat4(vec4(-0.069, -0.157, 0.109, -0.229), vec4(0.049, 0.212, -0.202, -0.092), vec4(-0.419, -0.141, 0.131, 0.133), vec4(-0.167, -0.024, 0.281, -0.080)) * bufB[9] + in0;\ntmp = atan(bufA[0]);\nbufB[0] = tmp/0.67;\nbufB[5] = (tmp*tmp - 0.45) / 0.396;\ntmp = atan(bufA[1]);\nbufB[1] = tmp/0.67;\nbufB[6] = (tmp*tmp - 0.45) / 0.396;\ntmp = atan(bufA[2]);\nbufB[2] = tmp/0.67;\nbufB[7] = (tmp*tmp - 0.45) / 0.396;\ntmp = atan(bufA[3]);\nbufB[3] = tmp/0.67;\nbufB[8] = (tmp*tmp - 0.45) / 0.396;\ntmp = atan(bufA[4]);\nbufB[4] = tmp/0.67;\nbufB[9] = (tmp*tmp - 0.45) / 0.396;\n\n // layer 4 \nbufA[0] = vec4(0.356, -0.268, -0.478, 0.214) + mat4(vec4(0.231, 0.216, 0.084, 0.134), vec4(0.442, 0.145, -0.215, 0.291), vec4(0.105, 0.032, -0.051, -0.114), vec4(0.325, -0.108, -0.017, -0.361)) * bufB[0] + mat4(vec4(0.284, -0.211, -0.323, -0.016), vec4(0.099, 0.085, -0.138, -0.141), vec4(-0.265, -0.258, 0.238, -0.036), vec4(0.126, 0.194, -0.103, 0.403)) * bufB[1] + mat4(vec4(0.183, -0.301, -0.224, 0.376), vec4(0.121, -0.014, -0.049, 0.280), vec4(-0.053, -0.420, -0.161, -0.030), vec4(-0.365, 0.246, 0.048, 0.178)) * bufB[2] + mat4(vec4(-0.170, 0.128, 0.018, -0.093), vec4(-0.004, -0.207, 0.212, 0.110), vec4(0.043, 0.088, 0.168, 0.234), vec4(0.193, -0.232, 0.174, -0.084)) * bufB[3] + mat4(vec4(0.194, 0.444, -0.483, -0.347), vec4(0.047, 0.380, -0.190, -0.233), vec4(-0.160, 0.066, -0.217, -0.138), vec4(-0.097, -0.103, 0.047, -0.218)) * bufB[4] + mat4(vec4(-0.027, 0.058, -0.008, 0.097), vec4(-0.052, 0.112, 0.121, 0.101), vec4(0.108, 0.131, -0.047, 0.017), vec4(0.045, 0.037, -0.045, 0.148)) * bufB[5] + mat4(vec4(0.251, -0.275, 0.058, -0.102), vec4(0.113, -0.070, -0.046, -0.023), vec4(-0.145, 0.006, 0.083, 0.439), vec4(0.424, -0.089, -0.361, -0.091)) * bufB[6] + mat4(vec4(-0.202, -0.096, 0.150, -0.314), vec4(-0.380, 0.125, 0.019, -0.202), vec4(-0.103, -0.250, -0.095, 0.011), vec4(0.137, -0.081, -0.155, 0.159)) * bufB[7] + mat4(vec4(-0.019, -0.305, -0.197, -0.272), vec4(-0.034, 0.104, 0.063, 0.341), vec4(-0.014, -0.187, -0.047, -0.182), vec4(-0.415, -0.117, 0.180, -0.042)) * bufB[8] + mat4(vec4(-0.294, 0.044, -0.028, -0.118), vec4(0.108, 0.058, 0.408, -0.071), vec4(-0.029, 0.009, 0.098, -0.206), vec4(0.283, 0.064, 0.266, 0.134)) * bufB[9];\nbufA[1] = vec4(-0.396, 0.493, 0.517, -0.133) + mat4(vec4(0.122, 0.377, 0.075, 0.169), vec4(0.250, -0.142, 0.328, 0.114), vec4(0.185, 0.060, 0.173, -0.229), vec4(-0.047, -0.023, -0.039, -0.130)) * bufB[0] + mat4(vec4(0.057, -0.166, 0.115, -0.167), vec4(-0.057, -0.167, -0.147, 0.011), vec4(0.032, 0.029, 0.330, -0.310), vec4(-0.218, 0.082, 0.197, -0.054)) * bufB[1] + mat4(vec4(-0.027, -0.445, -0.173, -0.000), vec4(0.187, 0.245, 0.385, 0.060), vec4(-0.007, 0.052, 0.089, 0.029), vec4(-0.231, 0.177, 0.342, 0.044)) * bufB[2] + mat4(vec4(-0.077, 0.103, 0.159, -0.127), vec4(0.279, -0.199, 0.025, -0.471), vec4(0.280, 0.211, 0.129, 0.025), vec4(0.129, 0.058, -0.208, -0.149)) * bufB[3] + mat4(vec4(-0.328, -0.099, 0.054, -0.301), vec4(0.122, -0.116, 0.073, 0.072), vec4(-0.026, -0.244, 0.047, -0.036), vec4(-0.080, 0.182, 0.058, -0.065)) * bufB[4] + mat4(vec4(0.152, 0.011, 0.019, -0.056), vec4(0.258, -0.075, 0.044, -0.456), vec4(-0.124, 0.256, -0.246, -0.083), vec4(0.104, -0.101, -0.251, -0.102)) * bufB[5] + mat4(vec4(-0.048, -0.052, 0.089, 0.288), vec4(0.224, -0.062, -0.141, -0.188), vec4(0.016, 0.084, -0.004, 0.029), vec4(-0.047, -0.061, 0.011, -0.188)) * bufB[6] + mat4(vec4(-0.078, -0.069, 0.021, 0.090), vec4(-0.002, -0.334, 0.120, -0.153), vec4(0.116, -0.004, -0.092, -0.096), vec4(0.021, -0.417, -0.290, -0.175)) * bufB[7] + mat4(vec4(-0.022, -0.047, 0.014, -0.497), vec4(0.074, 0.343, 0.074, -0.115), vec4(-0.150, 0.117, -0.065, 0.089), vec4(-0.110, -0.231, -0.093, -0.058)) * bufB[8] + mat4(vec4(0.313, 0.166, 0.005, 0.111), vec4(-0.145, 0.212, 0.279, -0.026), vec4(0.152, -0.053, -0.352, 0.146), vec4(0.090, -0.143, -0.219, 0.011)) * bufB[9];\nbufA[2] = vec4(-0.301, 0.079, -0.038, 0.249) + mat4(vec4(-0.203, 0.283, 0.044, -0.189), vec4(-0.150, -0.151, 0.007, 0.007), vec4(0.060, 0.103, 0.065, 0.204), vec4(-0.120, 0.064, -0.085, -0.335)) * bufB[0] + mat4(vec4(-0.046, -0.106, 0.021, -0.095), vec4(0.076, -0.363, -0.016, -0.185), vec4(0.096, -0.274, 0.026, -0.002), vec4(0.056, -0.049, -0.209, -0.137)) * bufB[1] + mat4(vec4(0.124, -0.040, 0.057, 0.134), vec4(0.030, 0.223, -0.179, -0.184), vec4(0.048, -0.019, -0.080, -0.066), vec4(0.283, 0.123, -0.329, -0.005)) * bufB[2] + mat4(vec4(0.022, -0.094, 0.015, -0.122), vec4(0.306, -0.019, 0.333, 0.283), vec4(-0.364, -0.115, -0.253, -0.031), vec4(-0.142, -0.049, 0.029, 0.013)) * bufB[3] + mat4(vec4(-0.076, 0.024, -0.180, 0.182), vec4(0.163, -0.061, 0.049, 0.202), vec4(-0.036, -0.039, -0.182, -0.010), vec4(-0.116, -0.215, -0.292, 0.180)) * bufB[4] + mat4(vec4(0.151, -0.158, -0.111, 0.293), vec4(0.055, 0.063, -0.032, 0.280), vec4(-0.012, 0.102, 0.018, 0.118), vec4(-0.261, -0.070, -0.253, 0.014)) * bufB[5] + mat4(vec4(0.128, -0.117, -0.042, 0.025), vec4(0.126, -0.404, -0.257, 0.239), vec4(-0.027, 0.215, 0.081, 0.238), vec4(-0.106, -0.157, 0.068, -0.111)) * bufB[6] + mat4(vec4(0.069, -0.074, 0.316, 0.250), vec4(0.025, -0.116, -0.151, -0.154), vec4(0.060, 0.068, -0.037, 0.090), vec4(0.177, -0.258, -0.010, 0.059)) * bufB[7] + mat4(vec4(0.035, -0.400, -0.116, 0.135), vec4(0.024, 0.130, 0.099, 0.228), vec4(0.060, -0.146, 0.188, 0.075), vec4(0.164, -0.352, 0.042, -0.148)) * bufB[8] + mat4(vec4(0.112, -0.443, 0.167, 0.224), vec4(-0.031, 0.094, -0.354, -0.045), vec4(-0.054, -0.041, -0.207, 0.181), vec4(-0.027, 0.150, -0.258, -0.244)) * bufB[9];\nbufA[3] = vec4(0.300, 0.148, 0.045, 0.329) + mat4(vec4(0.062, 0.211, 0.273, -0.166), vec4(-0.101, -0.143, -0.048, -0.190), vec4(0.232, -0.148, 0.070, -0.280), vec4(-0.216, -0.034, 0.080, -0.012)) * bufB[0] + mat4(vec4(0.182, 0.047, 0.084, -0.338), vec4(-0.077, -0.156, 0.033, 0.013), vec4(0.269, -0.131, -0.074, -0.238), vec4(-0.085, -0.209, 0.095, 0.087)) * bufB[1] + mat4(vec4(-0.008, 0.059, -0.067, -0.097), vec4(-0.117, 0.102, -0.073, 0.042), vec4(0.071, 0.194, 0.119, -0.139), vec4(-0.114, -0.150, -0.162, 0.029)) * bufB[2] + mat4(vec4(-0.212, 0.025, 0.150, -0.201), vec4(-0.007, 0.102, -0.214, -0.226), vec4(0.010, -0.082, 0.029, 0.045), vec4(-0.343, 0.318, 0.047, 0.019)) * bufB[3] + mat4(vec4(0.146, 0.098, 0.053, -0.195), vec4(-0.008, 0.043, -0.654, 0.108), vec4(0.106, -0.124, -0.150, 0.276), vec4(-0.282, -0.114, 0.038, 0.032)) * bufB[4] + mat4(vec4(0.172, -0.002, 0.106, -0.127), vec4(0.122, 0.098, 0.039, -0.174), vec4(0.366, -0.160, 0.017, -0.060), vec4(-0.036, 0.053, -0.046, 0.089)) * bufB[5] + mat4(vec4(-0.167, 0.075, 0.040, -0.264), vec4(0.095, 0.213, 0.122, -0.163), vec4(-0.111, -0.130, -0.343, 0.341), vec4(0.151, 0.083, 0.239, 0.237)) * bufB[6] + mat4(vec4(0.176, 0.141, 0.113, 0.165), vec4(0.279, -0.221, 0.119, 0.201), vec4(0.102, 0.117, 0.080, -0.131), vec4(0.389, 0.078, 0.001, -0.041)) * bufB[7] + mat4(vec4(-0.159, -0.088, -0.048, -0.266), vec4(0.213, -0.146, -0.236, 0.374), vec4(0.028, 0.069, -0.322, -0.121), vec4(0.049, -0.028, 0.041, -0.106)) * bufB[8] + mat4(vec4(-0.048, -0.259, 0.178, 0.117), vec4(-0.097, -0.111, 0.370, -0.216), vec4(-0.009, 0.418, 0.042, 0.032), vec4(-0.134, 0.204, 0.171, -0.278)) * bufB[9];\nbufA[4] = vec4(-0.344, -0.282, -0.281, 0.403) + mat4(vec4(-0.043, 0.039, 0.105, 0.240), vec4(-0.038, -0.162, 0.054, -0.018), vec4(-0.208, 0.076, -0.082, 0.073), vec4(-0.433, -0.187, -0.277, 0.044)) * bufB[0] + mat4(vec4(-0.033, 0.017, 0.235, -0.217), vec4(-0.449, 0.140, -0.003, -0.396), vec4(-0.238, -0.306, -0.047, -0.283), vec4(-0.233, 0.010, -0.213, -0.202)) * bufB[1] + mat4(vec4(-0.125, -0.116, -0.007, 0.126), vec4(-0.161, 0.172, -0.210, -0.388), vec4(0.048, 0.423, 0.316, -0.208), vec4(0.173, 0.215, 0.146, 0.259)) * bufB[2] + mat4(vec4(-0.070, -0.019, -0.380, 0.011), vec4(0.259, 0.082, 0.097, 0.138), vec4(-0.071, -0.034, 0.051, 0.067), vec4(-0.117, -0.183, -0.197, -0.101)) * bufB[3] + mat4(vec4(0.138, -0.080, 0.371, 0.033), vec4(0.047, 0.156, 0.178, 0.231), vec4(-0.196, -0.026, -0.223, 0.099), vec4(-0.240, -0.073, -0.215, 0.054)) * bufB[4] + mat4(vec4(0.171, 0.033, 0.126, 0.110), vec4(0.258, 0.094, 0.100, -0.041), vec4(-0.253, 0.213, 0.152, 0.348), vec4(-0.032, -0.036, 0.009, 0.009)) * bufB[5] + mat4(vec4(-0.037, -0.111, 0.107, 0.027), vec4(-0.052, -0.135, 0.208, 0.010), vec4(-0.257, -0.046, -0.178, -0.150), vec4(0.019, 0.235, 0.005, -0.116)) * bufB[6] + mat4(vec4(-0.295, 0.065, 0.069, 0.074), vec4(0.063, -0.043, -0.116, 0.387), vec4(-0.081, -0.050, -0.174, 0.025), vec4(0.019, -0.117, 0.101, -0.098)) * bufB[7] + mat4(vec4(-0.098, 0.115, 0.463, -0.034), vec4(0.234, -0.048, -0.161, -0.032), vec4(-0.016, -0.348, -0.120, 0.297), vec4(0.165, -0.013, -0.042, -0.270)) * bufB[8] + mat4(vec4(0.020, -0.495, 0.077, -0.247), vec4(-0.270, 0.323, 0.137, 0.051), vec4(-0.180, -0.147, 0.223, -0.070), vec4(0.122, 0.070, 0.074, 0.009)) * bufB[9];\ntmp = atan(bufA[0]);\nbufB[0] = tmp/0.67;\nbufB[5] = (tmp*tmp - 0.45) / 0.396;\ntmp = atan(bufA[1]);\nbufB[1] = tmp/0.67;\nbufB[6] = (tmp*tmp - 0.45) / 0.396;\ntmp = atan(bufA[2]);\nbufB[2] = tmp/0.67;\nbufB[7] = (tmp*tmp - 0.45) / 0.396;\ntmp = atan(bufA[3]);\nbufB[3] = tmp/0.67;\nbufB[8] = (tmp*tmp - 0.45) / 0.396;\ntmp = atan(bufA[4]);\nbufB[4] = tmp/0.67;\nbufB[9] = (tmp*tmp - 0.45) / 0.396;\n\n // layer 5 \nbufA[0] = vec4(0.235, 0.346, 0.436, -0.211) + mat4(vec4(0.102, -0.102, 0.031, -0.267), vec4(0.125, -0.148, -0.093, -0.020), vec4(-0.291, 0.025, -0.004, -0.225), vec4(0.081, 0.124, -0.182, 0.105)) * bufB[0] + mat4(vec4(-0.171, -0.237, 0.241, -0.042), vec4(-0.105, 0.110, -0.122, 0.191), vec4(0.408, -0.059, 0.056, -0.116), vec4(-0.143, 0.089, -0.122, -0.237)) * bufB[1] + mat4(vec4(-0.031, -0.053, 0.052, -0.162), vec4(0.267, 0.308, 0.112, 0.069), vec4(-0.016, 0.103, -0.042, 0.276), vec4(-0.094, -0.031, 0.343, 0.136)) * bufB[2] + mat4(vec4(-0.018, 0.143, -0.098, 0.009), vec4(-0.236, -0.015, -0.155, 0.012), vec4(-0.280, -0.318, -0.120, -0.012), vec4(0.134, -0.061, -0.142, 0.095)) * bufB[3] + mat4(vec4(0.327, -0.165, -0.069, 0.194), vec4(0.161, 0.015, 0.231, -0.179), vec4(-0.357, -0.016, 0.330, 0.081), vec4(-0.200, 0.014, -0.133, -0.239)) * bufB[4] + mat4(vec4(-0.085, 0.192, -0.136, 0.015), vec4(0.235, -0.033, 0.281, 0.107), vec4(-0.069, -0.195, -0.239, 0.034), vec4(-0.036, 0.382, -0.110, 0.025)) * bufB[5] + mat4(vec4(0.100, -0.072, 0.165, 0.085), vec4(-0.146, -0.066, 0.059, -0.080), vec4(0.120, -0.252, -0.167, 0.052), vec4(0.134, 0.139, 0.416, 0.135)) * bufB[6] + mat4(vec4(0.184, -0.095, -0.174, -0.001), vec4(-0.160, -0.142, 0.014, -0.167), vec4(0.103, -0.288, 0.110, -0.095), vec4(-0.014, 0.215, -0.054, -0.175)) * bufB[7] + mat4(vec4(-0.057, 0.205, -0.003, -0.095), vec4(-0.093, -0.155, -0.045, 0.107), vec4(0.176, -0.042, -0.023, -0.444), vec4(0.025, -0.130, -0.134, 0.116)) * bufB[8] + mat4(vec4(-0.009, -0.246, -0.067, -0.033), vec4(-0.243, 0.149, 0.120, -0.121), vec4(0.077, 0.000, 0.174, 0.089), vec4(-0.041, -0.213, 0.191, 0.217)) * bufB[9];\nbufA[1] = vec4(-0.301, -0.431, -0.040, 0.395) + mat4(vec4(0.128, 0.079, 0.160, 0.003), vec4(-0.044, 0.123, -0.085, -0.342), vec4(0.074, -0.481, -0.128, -0.106), vec4(-0.228, -0.246, -0.095, 0.366)) * bufB[0] + mat4(vec4(0.176, -0.035, 0.211, 0.205), vec4(-0.204, -0.156, 0.017, 0.026), vec4(-0.051, -0.042, -0.285, -0.238), vec4(0.029, 0.004, -0.047, 0.189)) * bufB[1] + mat4(vec4(-0.176, 0.020, 0.032, 0.013), vec4(0.248, -0.104, -0.016, -0.194), vec4(0.267, -0.005, -0.397, -0.300), vec4(0.006, 0.322, -0.166, 0.217)) * bufB[2] + mat4(vec4(0.095, 0.075, 0.240, -0.162), vec4(-0.117, -0.065, -0.198, 0.071), vec4(-0.010, 0.052, 0.032, -0.397), vec4(-0.084, -0.177, 0.228, 0.007)) * bufB[3] + mat4(vec4(0.012, 0.064, -0.006, -0.168), vec4(-0.149, -0.392, -0.200, -0.186), vec4(-0.060, -0.052, -0.114, -0.043), vec4(-0.129, 0.144, 0.228, 0.144)) * bufB[4] + mat4(vec4(0.103, -0.220, -0.248, 0.096), vec4(0.129, -0.179, -0.177, -0.072), vec4(0.148, -0.149, 0.214, -0.269), vec4(-0.027, -0.068, 0.081, -0.089)) * bufB[5] + mat4(vec4(0.147, -0.294, 0.163, -0.260), vec4(-0.043, 0.044, -0.253, 0.068), vec4(-0.114, -0.348, 0.348, -0.069), vec4(-0.207, 0.141, 0.147, -0.155)) * bufB[6] + mat4(vec4(-0.315, 0.023, 0.055, -0.091), vec4(0.220, 0.204, 0.278, -0.008), vec4(-0.052, -0.094, 0.260, -0.006), vec4(0.211, -0.274, -0.035, 0.165)) * bufB[7] + mat4(vec4(-0.074, 0.045, 0.002, 0.385), vec4(0.024, -0.085, -0.291, -0.004), vec4(0.031, -0.141, 0.116, 0.076), vec4(-0.130, -0.274, -0.045, -0.079)) * bufB[8] + mat4(vec4(-0.200, 0.142, -0.254, 0.162), vec4(0.304, 0.212, 0.161, -0.249), vec4(-0.405, -0.067, 0.004, 0.006), vec4(0.242, 0.179, -0.102, -0.020)) * bufB[9];\nbufA[2] = vec4(0.027, 0.351, -0.469, 0.064) + mat4(vec4(0.004, -0.035, -0.113, -0.014), vec4(0.067, 0.344, 0.013, 0.171), vec4(0.175, -0.238, 0.213, -0.500), vec4(-0.050, 0.148, -0.124, -0.009)) * bufB[0] + mat4(vec4(0.017, -0.179, -0.113, 0.049), vec4(-0.184, -0.472, -0.117, -0.303), vec4(-0.108, 0.145, -0.169, -0.016), vec4(-0.052, -0.110, 0.102, -0.152)) * bufB[1] + mat4(vec4(-0.034, 0.038, 0.096, 0.032), vec4(0.024, 0.225, -0.063, -0.109), vec4(-0.247, -0.029, 0.112, 0.011), vec4(-0.337, 0.047, 0.130, 0.161)) * bufB[2] + mat4(vec4(-0.082, 0.230, 0.078, 0.267), vec4(0.012, 0.106, -0.025, -0.164), vec4(0.001, 0.046, -0.022, 0.136), vec4(0.131, -0.160, -0.099, -0.154)) * bufB[3] + mat4(vec4(-0.046, 0.073, -0.379, 0.072), vec4(0.035, 0.163, -0.355, -0.324), vec4(-0.245, -0.022, -0.047, 0.120), vec4(-0.198, -0.200, 0.004, 0.230)) * bufB[4] + mat4(vec4(0.132, -0.186, -0.157, 0.349), vec4(-0.239, 0.220, 0.213, -0.224), vec4(0.185, 0.336, -0.079, 0.159), vec4(-0.234, 0.001, 0.194, -0.086)) * bufB[5] + mat4(vec4(0.089, -0.057, -0.177, 0.229), vec4(0.055, -0.061, -0.038, -0.280), vec4(0.127, 0.054, -0.326, -0.316), vec4(0.100, 0.049, 0.176, 0.340)) * bufB[6] + mat4(vec4(-0.341, 0.074, 0.052, -0.137), vec4(-0.328, 0.275, 0.433, 0.284), vec4(0.236, 0.164, -0.165, 0.078), vec4(-0.090, -0.003, -0.239, 0.099)) * bufB[7] + mat4(vec4(-0.013, 0.006, -0.166, 0.340), vec4(0.048, 0.158, 0.179, -0.272), vec4(-0.183, -0.288, -0.166, -0.141), vec4(0.240, 0.009, 0.193, 0.166)) * bufB[8] + mat4(vec4(-0.060, -0.246, 0.026, -0.098), vec4(-0.089, 0.131, 0.199, 0.065), vec4(0.184, -0.115, 0.012, 0.189), vec4(0.194, -0.238, 0.059, 0.246)) * bufB[9];\nbufA[3] = vec4(0.288, 0.360, 0.375, 0.281) + mat4(vec4(0.131, -0.076, 0.033, -0.053), vec4(-0.101, -0.126, 0.093, 0.152), vec4(-0.277, 0.107, -0.285, 0.110), vec4(-0.088, -0.103, 0.247, -0.135)) * bufB[0] + mat4(vec4(0.308, 0.162, 0.041, 0.135), vec4(0.064, 0.158, 0.353, 0.206), vec4(0.286, 0.369, 0.064, -0.127), vec4(-0.176, -0.029, 0.144, -0.110)) * bufB[1] + mat4(vec4(0.092, -0.165, 0.090, 0.072), vec4(0.135, 0.127, -0.077, -0.084), vec4(0.253, -0.121, -0.181, -0.024), vec4(-0.024, 0.142, -0.279, 0.024)) * bufB[2] + mat4(vec4(0.226, -0.071, -0.107, 0.072), vec4(0.296, -0.264, -0.025, 0.192), vec4(-0.246, 0.087, -0.234, -0.020), vec4(-0.054, -0.158, -0.019, -0.145)) * bufB[3] + mat4(vec4(-0.169, -0.121, -0.222, 0.151), vec4(0.207, -0.020, 0.009, 0.018), vec4(0.035, -0.116, 0.128, 0.071), vec4(0.269, -0.101, -0.124, 0.440)) * bufB[4] + mat4(vec4(-0.151, -0.018, 0.192, 0.051), vec4(-0.138, -0.252, 0.287, 0.029), vec4(0.258, -0.205, 0.134, -0.053), vec4(0.055, -0.018, 0.022, 0.028)) * bufB[5] + mat4(vec4(0.007, -0.124, 0.142, -0.308), vec4(-0.113, 0.250, 0.094, -0.010), vec4(0.082, 0.104, -0.086, 0.203), vec4(0.316, -0.065, -0.202, 0.218)) * bufB[6] + mat4(vec4(0.197, -0.123, -0.114, -0.232), vec4(-0.027, 0.051, 0.332, 0.161), vec4(0.071, 0.017, -0.209, 0.104), vec4(0.135, 0.224, -0.280, -0.030)) * bufB[7] + mat4(vec4(-0.159, -0.007, 0.001, 0.112), vec4(-0.041, -0.086, 0.267, -0.169), vec4(-0.087, -0.038, -0.065, 0.239), vec4(-0.319, 0.269, 0.063, 0.138)) * bufB[8] + mat4(vec4(-0.056, 0.149, -0.138, -0.243), vec4(-0.044, 0.054, 0.359, 0.019), vec4(-0.169, 0.211, -0.167, -0.018), vec4(-0.236, 0.030, 0.005, -0.177)) * bufB[9];\nbufA[4] = vec4(-0.390, -0.363, -0.187, -0.198) + mat4(vec4(0.031, 0.178, 0.091, 0.403), vec4(-0.000, 0.060, -0.241, -0.111), vec4(-0.288, -0.311, -0.188, -0.158), vec4(-0.116, 0.016, -0.152, 0.078)) * bufB[0] + mat4(vec4(-0.086, 0.124, -0.215, 0.020), vec4(-0.400, 0.030, 0.155, -0.006), vec4(-0.277, 0.025, -0.017, 0.259), vec4(-0.012, 0.128, -0.257, -0.109)) * bufB[1] + mat4(vec4(0.028, -0.253, -0.064, -0.113), vec4(0.075, 0.030, -0.121, 0.021), vec4(0.191, 0.226, -0.111, -0.193), vec4(-0.211, -0.044, -0.231, 0.083)) * bufB[2] + mat4(vec4(-0.026, -0.076, 0.069, -0.144), vec4(-0.053, -0.038, -0.119, -0.083), vec4(-0.063, -0.207, 0.226, -0.121), vec4(-0.286, 0.151, 0.282, 0.277)) * bufB[3] + mat4(vec4(0.136, -0.244, -0.056, -0.320), vec4(0.041, -0.100, -0.077, -0.079), vec4(0.088, 0.071, 0.157, -0.302), vec4(-0.159, -0.153, 0.065, 0.038)) * bufB[4] + mat4(vec4(0.071, 0.183, 0.106, 0.194), vec4(-0.121, 0.090, -0.027, -0.180), vec4(0.011, -0.018, 0.109, -0.008), vec4(0.292, 0.023, -0.063, 0.462)) * bufB[5] + mat4(vec4(-0.125, -0.212, -0.110, 0.229), vec4(0.128, 0.256, -0.062, -0.182), vec4(0.037, 0.113, 0.047, -0.013), vec4(-0.026, -0.018, -0.082, 0.232)) * bufB[6] + mat4(vec4(-0.079, -0.216, -0.044, 0.207), vec4(0.170, 0.076, 0.471, -0.114), vec4(-0.093, 0.081, -0.026, -0.040), vec4(-0.118, 0.037, -0.063, -0.052)) * bufB[7] + mat4(vec4(-0.074, -0.146, 0.029, -0.034), vec4(-0.279, -0.110, -0.017, -0.266), vec4(0.002, 0.222, 0.148, 0.300), vec4(-0.232, -0.141, 0.092, 0.059)) * bufB[8] + mat4(vec4(0.498, -0.079, 0.223, -0.134), vec4(-0.080, -0.146, 0.057, 0.160), vec4(-0.322, -0.184, 0.039, -0.079), vec4(-0.290, -0.054, 0.165, -0.181)) * bufB[9];\ntmp = atan(bufA[0]);\nbufB[0] = tmp/0.67;\nbufB[5] = (tmp*tmp - 0.45) / 0.396;\ntmp = atan(bufA[1]);\nbufB[1] = tmp/0.67;\nbufB[6] = (tmp*tmp - 0.45) / 0.396;\ntmp = atan(bufA[2]);\nbufB[2] = tmp/0.67;\nbufB[7] = (tmp*tmp - 0.45) / 0.396;\ntmp = atan(bufA[3]);\nbufB[3] = tmp/0.67;\nbufB[8] = (tmp*tmp - 0.45) / 0.396;\ntmp = atan(bufA[4]);\nbufB[4] = tmp/0.67;\nbufB[9] = (tmp*tmp - 0.45) / 0.396;\n\n // layer 6 \nbufA[0] = vec4(-0.137, -0.561, 0.630, -0.095) + mat4(vec4(0.275, -0.199, 0.282, -0.341), vec4(-0.306, -0.038, 0.271, 0.011), vec4(-0.296, -0.012, -0.109, 0.081), vec4(0.022, 0.020, -0.170, -0.234)) * bufB[0] + mat4(vec4(-0.101, 0.272, -0.224, 0.196), vec4(0.101, -0.012, 0.002, 0.057), vec4(0.044, -0.254, 0.147, 0.084), vec4(-0.239, -0.391, -0.199, -0.165)) * bufB[1] + mat4(vec4(0.364, -0.209, -0.120, -0.077), vec4(-0.116, 0.243, 0.125, -0.174), vec4(0.083, -0.018, -0.136, 0.055), vec4(0.376, -0.064, -0.329, -0.198)) * bufB[2] + mat4(vec4(-0.093, 0.210, 0.001, -0.110), vec4(-0.145, 0.294, 0.023, 0.103), vec4(0.287, 0.035, 0.166, 0.383), vec4(-0.176, 0.334, -0.127, 0.174)) * bufB[3] + mat4(vec4(0.037, 0.026, 0.055, 0.230), vec4(0.055, -0.087, 0.250, 0.219), vec4(0.382, -0.151, -0.192, 0.333), vec4(-0.043, -0.064, 0.082, 0.100)) * bufB[4] + mat4(vec4(0.018, -0.060, 0.005, -0.030), vec4(-0.339, 0.092, -0.213, 0.177), vec4(-0.045, -0.199, 0.280, -0.197), vec4(-0.064, 0.014, 0.130, -0.175)) * bufB[5] + mat4(vec4(0.070, -0.132, 0.278, -0.251), vec4(-0.221, 0.266, 0.113, 0.115), vec4(0.283, 0.079, 0.063, 0.180), vec4(0.158, -0.096, -0.365, 0.013)) * bufB[6] + mat4(vec4(-0.134, 0.210, -0.065, 0.073), vec4(0.178, -0.216, 0.134, -0.113), vec4(0.103, 0.000, 0.205, 0.131), vec4(-0.079, 0.361, -0.021, 0.013)) * bufB[7] + mat4(vec4(0.102, -0.296, -0.151, -0.056), vec4(-0.176, -0.038, 0.024, 0.029), vec4(-0.013, -0.068, 0.126, 0.051), vec4(0.080, 0.045, -0.055, -0.100)) * bufB[8] + mat4(vec4(-0.077, 0.358, -0.419, 0.299), vec4(-0.044, 0.021, -0.366, -0.356), vec4(-0.066, 0.068, 0.107, 0.032), vec4(0.301, -0.064, -0.130, 0.219)) * bufB[9];\nbufA[1] = vec4(0.367, 0.509, 0.599, -0.448) + mat4(vec4(-0.154, 0.602, -0.135, -0.204), vec4(-0.256, -0.006, -0.283, -0.198), vec4(-0.108, 0.001, -0.137, 0.442), vec4(0.339, 0.280, 0.040, 0.241)) * bufB[0] + mat4(vec4(-0.119, 0.182, 0.052, -0.143), vec4(0.059, -0.054, -0.038, -0.605), vec4(-0.015, -0.083, -0.001, 0.266), vec4(0.001, -0.061, -0.129, -0.079)) * bufB[1] + mat4(vec4(-0.021, -0.079, -0.073, -0.072), vec4(-0.245, -0.200, 0.199, 0.261), vec4(0.082, -0.173, 0.149, -0.122), vec4(0.178, -0.007, -0.159, -0.027)) * bufB[2] + mat4(vec4(0.018, -0.208, -0.125, 0.200), vec4(0.129, 0.042, -0.033, -0.108), vec4(-0.176, 0.182, 0.289, 0.277), vec4(-0.052, -0.377, -0.155, 0.257)) * bufB[3] + mat4(vec4(-0.048, -0.192, -0.222, -0.082), vec4(-0.141, 0.436, 0.233, -0.332), vec4(-0.031, 0.077, 0.016, -0.030), vec4(-0.039, -0.130, -0.029, -0.165)) * bufB[4] + mat4(vec4(-0.062, 0.035, -0.091, 0.093), vec4(0.245, 0.162, 0.155, 0.017), vec4(-0.167, -0.292, -0.155, 0.086), vec4(-0.127, -0.450, 0.147, -0.088)) * bufB[5] + mat4(vec4(0.137, 0.020, -0.200, 0.020), vec4(-0.259, -0.212, -0.094, -0.119), vec4(0.167, -0.136, -0.133, 0.028), vec4(-0.212, 0.191, 0.129, -0.188)) * bufB[6] + mat4(vec4(-0.034, 0.033, 0.024, -0.016), vec4(0.099, -0.378, -0.013, 0.077), vec4(0.217, 0.019, 0.080, -0.197), vec4(0.326, -0.097, 0.008, -0.073)) * bufB[7] + mat4(vec4(-0.005, -0.176, 0.072, 0.065), vec4(-0.067, -0.070, 0.098, -0.096), vec4(-0.417, 0.471, 0.193, -0.156), vec4(0.285, 0.282, -0.146, -0.066)) * bufB[8] + mat4(vec4(-0.511, 0.070, 0.273, -0.127), vec4(-0.221, -0.061, -0.165, -0.045), vec4(0.187, -0.099, 0.156, -0.215), vec4(-0.184, 0.458, -0.319, 0.156)) * bufB[9];\nbufA[2] = vec4(0.296, 0.416, 0.009, -0.098) + mat4(vec4(-0.021, -0.119, -0.083, 0.015), vec4(0.011, -0.082, 0.114, -0.098), vec4(-0.210, 0.175, -0.077, 0.135), vec4(0.003, 0.353, -0.090, -0.255)) * bufB[0] + mat4(vec4(0.041, -0.230, -0.163, -0.079), vec4(0.104, 0.034, 0.459, -0.015), vec4(-0.008, -0.094, 0.033, -0.101), vec4(-0.085, -0.054, 0.220, 0.245)) * bufB[1] + mat4(vec4(-0.277, -0.151, 0.230, 0.181), vec4(0.134, 0.055, -0.222, 0.094), vec4(0.156, 0.179, 0.348, -0.056), vec4(0.181, 0.073, 0.007, 0.272)) * bufB[2] + mat4(vec4(0.324, -0.075, 0.142, -0.225), vec4(-0.174, 0.098, 0.239, -0.167), vec4(0.007, -0.121, -0.035, 0.360), vec4(0.032, -0.111, 0.162, -0.363)) * bufB[3] + mat4(vec4(0.018, -0.039, -0.062, 0.096), vec4(-0.014, -0.009, 0.124, 0.001), vec4(0.055, 0.175, -0.156, -0.061), vec4(0.104, -0.268, -0.054, -0.325)) * bufB[4] + mat4(vec4(-0.153, -0.173, -0.248, -0.190), vec4(0.114, -0.129, 0.216, 0.012), vec4(-0.206, -0.003, -0.137, 0.161), vec4(0.082, -0.229, 0.142, 0.403)) * bufB[5] + mat4(vec4(-0.019, -0.236, 0.217, -0.140), vec4(-0.414, -0.121, 0.002, -0.314), vec4(0.264, -0.055, 0.056, -0.040), vec4(-0.169, -0.011, -0.045, -0.274)) * bufB[6] + mat4(vec4(0.366, 0.067, 0.247, 0.256), vec4(0.155, 0.027, -0.333, -0.072), vec4(0.187, -0.295, 0.194, -0.095), vec4(0.096, 0.134, 0.019, -0.185)) * bufB[7] + mat4(vec4(0.085, 0.018, -0.088, 0.438), vec4(-0.185, 0.430, 0.032, 0.153), vec4(0.098, 0.012, -0.155, 0.127), vec4(-0.035, 0.180, 0.087, -0.120)) * bufB[8] + mat4(vec4(-0.440, -0.174, 0.059, -0.244), vec4(-0.281, 0.033, 0.095, -0.236), vec4(0.081, -0.073, -0.033, 0.050), vec4(0.250, -0.018, 0.296, 0.210)) * bufB[9];\nbufA[3] = vec4(-0.535, 0.198, 0.561, 0.040) + mat4(vec4(-0.087, -0.242, -0.241, -0.004), vec4(-0.073, -0.084, 0.159, -0.048), vec4(-0.271, -0.175, -0.221, 0.024), vec4(0.134, 0.059, -0.157, 0.234)) * bufB[0] + mat4(vec4(-0.111, -0.086, -0.166, 0.175), vec4(0.006, 0.322, 0.124, 0.375), vec4(-0.211, -0.092, 0.203, 0.010), vec4(-0.264, 0.118, 0.243, -0.171)) * bufB[1] + mat4(vec4(-0.072, -0.223, -0.390, -0.011), vec4(0.007, 0.012, -0.141, 0.108), vec4(-0.042, 0.196, -0.137, 0.201), vec4(-0.104, 0.014, 0.247, 0.447)) * bufB[2] + mat4(vec4(0.182, 0.475, -0.023, -0.014), vec4(-0.251, -0.110, -0.183, 0.459), vec4(-0.433, 0.116, 0.223, -0.036), vec4(-0.169, 0.091, -0.168, -0.552)) * bufB[3] + mat4(vec4(0.282, 0.175, 0.097, -0.114), vec4(0.028, 0.202, -0.112, -0.005), vec4(-0.149, 0.456, 0.253, 0.066), vec4(-0.358, -0.083, 0.077, -0.117)) * bufB[4] + mat4(vec4(-0.088, -0.043, 0.296, -0.026), vec4(0.324, 0.053, -0.140, -0.277), vec4(0.602, -0.033, 0.545, -0.099), vec4(0.242, 0.055, -0.048, -0.121)) * bufB[5] + mat4(vec4(-0.062, -0.069, 0.237, 0.301), vec4(0.008, -0.031, 0.026, -0.091), vec4(-0.064, 0.082, -0.136, -0.118), vec4(0.113, -0.253, -0.066, -0.127)) * bufB[6] + mat4(vec4(-0.025, 0.080, -0.104, -0.256), vec4(-0.101, -0.212, -0.245, -0.169), vec4(-0.188, 0.204, 0.016, -0.216), vec4(0.040, 0.056, -0.005, 0.186)) * bufB[7] + mat4(vec4(-0.397, -0.015, -0.115, 0.072), vec4(-0.027, -0.117, -0.050, -0.079), vec4(0.017, -0.189, -0.067, 0.278), vec4(-0.157, 0.089, -0.053, 0.151)) * bufB[8] + mat4(vec4(-0.199, 0.005, -0.223, 0.111), vec4(0.091, -0.369, -0.071, 0.255), vec4(0.044, -0.037, 0.225, 0.057), vec4(-0.068, 0.175, 0.043, 0.334)) * bufB[9];\nbufA[4] = vec4(0.125, -0.530, 0.145, 0.331) + mat4(vec4(-0.037, 0.274, -0.015, 0.031), vec4(-0.330, 0.374, -0.273, -0.114), vec4(0.202, -0.131, -0.104, -0.211), vec4(0.120, 0.114, -0.178, 0.015)) * bufB[0] + mat4(vec4(-0.142, -0.000, -0.144, -0.115), vec4(0.300, -0.279, -0.068, -0.109), vec4(-0.153, -0.079, 0.150, 0.009), vec4(-0.088, 0.096, -0.050, 0.057)) * bufB[1] + mat4(vec4(-0.198, -0.084, 0.474, 0.235), vec4(0.566, -0.279, -0.350, -0.139), vec4(-0.145, -0.065, -0.062, -0.251), vec4(0.314, 0.016, -0.052, -0.268)) * bufB[2] + mat4(vec4(0.041, 0.110, 0.225, 0.330), vec4(-0.088, -0.207, -0.466, 0.008), vec4(0.227, -0.444, 0.020, -0.141), vec4(-0.170, -0.336, -0.255, -0.160)) * bufB[3] + mat4(vec4(0.074, -0.087, -0.088, 0.040), vec4(0.012, 0.067, 0.026, -0.210), vec4(-0.038, -0.249, 0.092, -0.211), vec4(-0.239, -0.209, 0.250, -0.173)) * bufB[4] + mat4(vec4(0.116, -0.005, 0.026, 0.179), vec4(-0.078, -0.009, -0.001, -0.044), vec4(0.040, -0.069, -0.101, -0.397), vec4(-0.231, -0.389, -0.039, 0.307)) * bufB[5] + mat4(vec4(0.022, -0.272, -0.162, -0.215), vec4(-0.240, -0.139, 0.098, 0.312), vec4(0.028, 0.108, 0.229, -0.206), vec4(0.298, 0.102, 0.024, -0.089)) * bufB[6] + mat4(vec4(-0.045, 0.186, -0.071, -0.081), vec4(0.113, 0.157, -0.028, 0.189), vec4(0.157, -0.095, -0.007, -0.372), vec4(0.056, 0.015, 0.376, -0.031)) * bufB[7] + mat4(vec4(-0.079, -0.075, -0.103, 0.352), vec4(-0.109, 0.052, 0.130, -0.035), vec4(0.231, 0.030, -0.110, -0.099), vec4(-0.287, 0.082, 0.072, -0.081)) * bufB[8] + mat4(vec4(-0.263, -0.059, 0.036, 0.106), vec4(-0.245, 0.297, 0.148, -0.120), vec4(0.058, -0.011, 0.128, -0.066), vec4(0.004, 0.121, 0.300, -0.098)) * bufB[9];\ntmp = atan(bufA[0]);\nbufB[0] = tmp/0.67;\nbufB[5] = (tmp*tmp - 0.45) / 0.396;\ntmp = atan(bufA[1]);\nbufB[1] = tmp/0.67;\nbufB[6] = (tmp*tmp - 0.45) / 0.396;\ntmp = atan(bufA[2]);\nbufB[2] = tmp/0.67;\nbufB[7] = (tmp*tmp - 0.45) / 0.396;\ntmp = atan(bufA[3]);\nbufB[3] = tmp/0.67;\nbufB[8] = (tmp*tmp - 0.45) / 0.396;\ntmp = atan(bufA[4]);\nbufB[4] = tmp/0.67;\nbufB[9] = (tmp*tmp - 0.45) / 0.396;\n\n // layer 7 \nbufA[0] = vec4(0.500, -0.527, -0.261, 0.037) + mat4(vec4(-0.190, -0.209, 0.103, 0.207), vec4(-0.062, 0.252, 0.005, -0.264), vec4(0.244, -0.062, 0.058, 0.083), vec4(-0.088, 0.247, -0.042, -0.402)) * bufB[0] + mat4(vec4(-0.445, -0.024, 0.140, 0.009), vec4(0.035, -0.319, -0.080, 0.148), vec4(0.006, 0.150, -0.352, 0.227), vec4(0.448, 0.222, 0.299, 0.243)) * bufB[1] + mat4(vec4(-0.092, 0.309, 0.027, -0.088), vec4(-0.102, 0.071, -0.058, -0.193), vec4(-0.333, 0.100, 0.079, -0.252), vec4(-0.337, 0.015, 0.348, 0.309)) * bufB[2] + mat4(vec4(-0.288, 0.144, 0.154, 0.114), vec4(-0.022, 0.234, 0.234, 0.046), vec4(0.057, -0.347, 0.122, -0.115), vec4(-0.325, -0.063, -0.065, -0.076)) * bufB[3] + mat4(vec4(-0.175, -0.260, -0.048, 0.166), vec4(0.047, 0.162, 0.149, 0.109), vec4(-0.040, -0.205, -0.240, 0.120), vec4(0.064, -0.256, -0.145, 0.045)) * bufB[4] + mat4(vec4(0.064, -0.321, 0.033, -0.207), vec4(-0.012, 0.029, -0.269, -0.269), vec4(0.232, -0.205, -0.109, 0.013), vec4(-0.121, 0.019, 0.079, -0.115)) * bufB[5] + mat4(vec4(-0.246, 0.323, 0.400, -0.162), vec4(0.266, 0.015, -0.094, -0.019), vec4(-0.196, -0.044, 0.143, -0.098), vec4(0.228, 0.539, 0.125, -0.538)) * bufB[6] + mat4(vec4(-0.060, -0.158, -0.412, 0.452), vec4(0.053, 0.269, 0.070, -0.068), vec4(-0.162, -0.095, 0.000, 0.171), vec4(-0.281, 0.270, -0.175, -0.212)) * bufB[7] + mat4(vec4(-0.167, -0.253, -0.311, -0.280), vec4(0.413, 0.189, -0.166, 0.326), vec4(-0.068, -0.020, 0.010, 0.073), vec4(-0.084, 0.137, -0.007, -0.191)) * bufB[8] + mat4(vec4(0.251, -0.087, 0.365, -0.252), vec4(-0.160, 0.086, 0.190, -0.159), vec4(0.013, -0.383, -0.138, 0.028), vec4(-0.323, -0.036, 0.252, -0.027)) * bufB[9];\nbufA[1] = vec4(0.284, 0.306, 0.006, -0.530) + mat4(vec4(-0.127, -0.320, 0.080, 0.161), vec4(0.052, -0.151, -0.187, -0.008), vec4(-0.001, -0.040, -0.296, -0.257), vec4(-0.143, 0.004, -0.226, -0.109)) * bufB[0] + mat4(vec4(-0.207, 0.194, 0.313, 0.175), vec4(-0.053, -0.205, -0.329, 0.074), vec4(-0.258, 0.064, -0.167, -0.241), vec4(-0.052, -0.086, 0.195, 0.213)) * bufB[1] + mat4(vec4(-0.025, 0.178, 0.311, 0.281), vec4(-0.101, -0.004, -0.207, 0.294), vec4(0.129, -0.019, 0.399, -0.045), vec4(0.064, 0.324, 0.136, 0.028)) * bufB[2] + mat4(vec4(0.036, -0.068, -0.336, 0.108), vec4(-0.086, 0.423, 0.059, -0.084), vec4(-0.140, 0.421, 0.649, -0.133), vec4(-0.311, -0.238, 0.056, 0.096)) * bufB[3] + mat4(vec4(-0.074, 0.318, 0.066, 0.519), vec4(-0.039, -0.067, -0.190, 0.284), vec4(0.198, -0.018, 0.255, 0.232), vec4(0.068, -0.510, -0.228, -0.209)) * bufB[4] + mat4(vec4(0.227, 0.088, 0.132, -0.167), vec4(-0.020, -0.251, 0.077, -0.123), vec4(0.244, -0.096, -0.004, 0.153), vec4(0.272, -0.265, 0.113, 0.041)) * bufB[5] + mat4(vec4(0.203, -0.001, 0.194, -0.358), vec4(-0.115, -0.058, 0.007, 0.067), vec4(0.071, -0.060, -0.103, -0.082), vec4(-0.015, -0.066, -0.287, -0.201)) * bufB[6] + mat4(vec4(0.078, -0.080, -0.436, 0.217), vec4(-0.003, -0.097, 0.002, 0.065), vec4(0.397, 0.112, 0.290, 0.166), vec4(-0.101, 0.094, 0.050, -0.003)) * bufB[7] + mat4(vec4(-0.282, 0.320, 0.016, 0.191), vec4(-0.261, 0.043, -0.047, -0.171), vec4(-0.123, -0.090, 0.007, -0.033), vec4(-0.093, 0.110, -0.037, 0.107)) * bufB[8] + mat4(vec4(0.251, 0.207, -0.135, 0.040), vec4(-0.002, 0.050, 0.082, -0.016), vec4(0.126, -0.044, -0.006, -0.009), vec4(0.005, 0.320, -0.032, -0.023)) * bufB[9];\nbufA[2] = vec4(-0.142, 0.422, -0.379, 0.135) + mat4(vec4(0.276, 0.075, -0.119, -0.122), vec4(-0.215, 0.154, 0.179, -0.055), vec4(0.058, -0.061, 0.141, 0.127), vec4(-0.033, 0.126, -0.028, -0.106)) * bufB[0] + mat4(vec4(0.051, 0.380, -0.185, 0.182), vec4(-0.289, -0.076, 0.065, 0.263), vec4(-0.017, -0.019, 0.372, -0.114), vec4(0.109, -0.168, -0.253, 0.190)) * bufB[1] + mat4(vec4(0.270, 0.250, -0.404, -0.006), vec4(-0.430, -0.006, -0.424, -0.200), vec4(0.031, -0.016, -0.230, -0.073), vec4(-0.188, 0.244, 0.066, 0.067)) * bufB[2] + mat4(vec4(-0.274, -0.013, -0.097, 0.010), vec4(-0.238, 0.103, -0.322, 0.030), vec4(0.535, -0.301, -0.136, -0.587), vec4(-0.372, -0.265, 0.002, 0.235)) * bufB[3] + mat4(vec4(-0.269, 0.266, -0.112, 0.176), vec4(-0.072, 0.200, -0.089, 0.026), vec4(0.016, -0.045, 0.362, -0.287), vec4(-0.337, -0.305, 0.330, -0.017)) * bufB[4] + mat4(vec4(0.221, 0.241, -0.289, -0.142), vec4(0.245, 0.134, 0.076, -0.114), vec4(0.533, -0.250, -0.277, 0.156), vec4(-0.098, 0.302, -0.098, 0.074)) * bufB[5] + mat4(vec4(0.231, 0.345, 0.096, -0.177), vec4(-0.094, -0.308, -0.057, 0.209), vec4(-0.352, 0.168, -0.428, -0.004), vec4(-0.106, 0.023, 0.276, -0.012)) * bufB[6] + mat4(vec4(-0.022, -0.329, 0.030, 0.379), vec4(-0.289, 0.328, 0.108, -0.531), vec4(-0.017, 0.176, 0.232, -0.180), vec4(-0.204, -0.136, -0.189, 0.079)) * bufB[7] + mat4(vec4(-0.124, 0.100, 0.115, 0.222), vec4(-0.038, -0.167, 0.255, 0.390), vec4(0.383, 0.409, -0.301, -0.071), vec4(-0.419, -0.031, 0.015, -0.154)) * bufB[8] + mat4(vec4(0.082, 0.313, 0.088, 0.091), vec4(-0.129, 0.097, 0.040, 0.061), vec4(0.036, -0.038, -0.092, -0.213), vec4(-0.121, 0.278, -0.065, -0.153)) * bufB[9];\nbufA[3] = vec4(0.077, -0.435, -0.340, 0.022) + mat4(vec4(-0.324, 0.195, -0.085, -0.050), vec4(0.094, -0.095, 0.038, -0.239), vec4(0.129, 0.333, 0.148, 0.374), vec4(0.291, -0.086, -0.055, 0.098)) * bufB[0] + mat4(vec4(-0.232, 0.136, 0.078, -0.299), vec4(-0.145, 0.133, 0.138, 0.337), vec4(0.311, -0.005, 0.114, 0.523), vec4(0.078, -0.382, 0.134, 0.025)) * bufB[1] + mat4(vec4(0.124, 0.218, 0.033, 0.249), vec4(0.282, 0.137, -0.153, -0.102), vec4(0.151, 0.483, -0.337, -0.038), vec4(-0.028, 0.064, -0.105, 0.049)) * bufB[2] + mat4(vec4(-0.075, -0.269, -0.005, -0.049), vec4(-0.146, -0.123, -0.149, 0.189), vec4(-0.152, -0.086, 0.060, -0.215), vec4(-0.460, 0.068, -0.363, -0.476)) * bufB[3] + mat4(vec4(-0.230, -0.076, 0.085, -0.047), vec4(-0.177, -0.383, 0.183, 0.270), vec4(0.235, 0.185, 0.115, 0.283), vec4(-0.025, 0.069, 0.163, 0.170)) * bufB[4] + mat4(vec4(-0.118, 0.097, 0.138, 0.208), vec4(0.033, -0.245, -0.224, -0.147), vec4(0.109, -0.070, -0.034, -0.114), vec4(-0.098, -0.019, 0.155, -0.286)) * bufB[5] + mat4(vec4(-0.001, 0.167, 0.266, 0.065), vec4(0.351, 0.236, 0.011, 0.028), vec4(0.124, -0.346, 0.044, 0.145), vec4(0.299, -0.062, 0.141, -0.031)) * bufB[6] + mat4(vec4(0.128, -0.078, -0.223, -0.189), vec4(-0.091, -0.137, 0.256, 0.025), vec4(-0.210, 0.087, 0.074, -0.230), vec4(-0.068, 0.091, -0.210, 0.104)) * bufB[7] + mat4(vec4(0.068, 0.186, -0.029, -0.089), vec4(-0.084, -0.088, -0.059, -0.133), vec4(0.350, -0.019, -0.100, -0.086), vec4(0.035, -0.047, -0.359, 0.384)) * bufB[8] + mat4(vec4(-0.030, -0.109, -0.214, -0.126), vec4(0.070, 0.058, 0.023, 0.181), vec4(-0.047, 0.150, 0.058, 0.020), vec4(-0.150, -0.034, -0.103, -0.019)) * bufB[9];\nbufA[4] = vec4(0.029, 0.465, 0.058, -0.257) + mat4(vec4(0.266, 0.080, 0.094, -0.299), vec4(0.061, 0.195, -0.193, 0.031), vec4(0.249, -0.518, 0.211, -0.120), vec4(0.150, -0.102, 0.411, 0.079)) * bufB[0] + mat4(vec4(-0.270, -0.409, -0.145, -0.356), vec4(0.151, -0.111, 0.180, -0.092), vec4(-0.018, -0.217, 0.070, -0.127), vec4(-0.359, 0.181, 0.144, -0.107)) * bufB[1] + mat4(vec4(0.063, 0.393, 0.222, -0.017), vec4(-0.188, -0.094, -0.426, -0.064), vec4(0.019, 0.163, -0.198, 0.066), vec4(0.174, 0.093, 0.543, -0.181)) * bufB[2] + mat4(vec4(0.007, 0.179, -0.165, 0.194), vec4(0.127, 0.282, 0.081, 0.254), vec4(-0.203, -0.005, 0.442, -0.227), vec4(-0.258, -0.157, -0.015, -0.312)) * bufB[3] + mat4(vec4(0.134, -0.015, -0.293, 0.494), vec4(0.111, 0.167, -0.051, 0.027), vec4(0.109, -0.389, 0.380, 0.126), vec4(0.183, 0.051, -0.248, 0.016)) * bufB[4] + mat4(vec4(0.279, -0.233, -0.358, 0.273), vec4(0.090, 0.100, 0.056, -0.107), vec4(0.358, 0.042, 0.179, -0.168), vec4(-0.265, 0.368, 0.121, 0.143)) * bufB[5] + mat4(vec4(0.125, -0.173, 0.064, -0.152), vec4(-0.072, -0.005, 0.073, 0.279), vec4(-0.019, -0.080, 0.184, -0.007), vec4(0.298, -0.075, 0.186, 0.094)) * bufB[6] + mat4(vec4(0.326, -0.068, -0.109, -0.094), vec4(-0.024, 0.189, 0.357, 0.101), vec4(-0.030, -0.001, -0.181, 0.077), vec4(-0.193, 0.200, 0.043, 0.072)) * bufB[7] + mat4(vec4(0.062, 0.129, -0.121, -0.241), vec4(0.195, 0.519, -0.242, 0.161), vec4(-0.116, -0.227, -0.177, 0.067), vec4(-0.086, -0.076, -0.090, -0.107)) * bufB[8] + mat4(vec4(0.372, 0.060, 0.079, -0.365), vec4(-0.284, -0.041, -0.096, 0.420), vec4(0.080, -0.136, -0.130, -0.219), vec4(-0.089, 0.250, 0.077, 0.114)) * bufB[9];\ntmp = atan(bufA[0]);\nbufB[0] = tmp/0.67;\nbufB[5] = (tmp*tmp - 0.45) / 0.396;\ntmp = atan(bufA[1]);\nbufB[1] = tmp/0.67;\nbufB[6] = (tmp*tmp - 0.45) / 0.396;\ntmp = atan(bufA[2]);\nbufB[2] = tmp/0.67;\nbufB[7] = (tmp*tmp - 0.45) / 0.396;\ntmp = atan(bufA[3]);\nbufB[3] = tmp/0.67;\nbufB[8] = (tmp*tmp - 0.45) / 0.396;\ntmp = atan(bufA[4]);\nbufB[4] = tmp/0.67;\nbufB[9] = (tmp*tmp - 0.45) / 0.396;\n\n // layer 8 \nbufA[0] = vec4(0.082, 0.151, -0.310, 0.398) + mat4(vec4(-0.448, -0.086, 0.246, 0.014), vec4(-0.234, -0.228, -0.026, -0.233), vec4(-0.049, 0.338, -0.231, 0.016), vec4(-0.152, 0.263, -0.103, -0.270)) * bufB[0] + mat4(vec4(0.011, 0.188, 0.357, -0.099), vec4(0.538, 0.130, -0.231, 0.152), vec4(0.100, 0.021, -0.031, -0.185), vec4(-0.034, 0.006, -0.153, -0.163)) * bufB[1] + mat4(vec4(0.127, 0.272, -0.117, 0.035), vec4(0.222, -0.096, 0.029, -0.287), vec4(-0.268, 0.082, -0.156, -0.169), vec4(0.205, -0.361, -0.305, 0.043)) * bufB[2] + mat4(vec4(0.081, -0.283, -0.036, -0.184), vec4(0.007, 0.071, -0.183, 0.358), vec4(0.070, 0.164, 0.255, -0.174), vec4(0.294, 0.039, 0.075, 0.465)) * bufB[3] + mat4(vec4(-0.105, 0.092, 0.077, 0.197), vec4(0.368, -0.009, -0.464, 0.008), vec4(-0.086, 0.031, -0.045, -0.411), vec4(-0.000, -0.157, 0.079, -0.032)) * bufB[4] + mat4(vec4(0.439, 0.525, 0.215, -0.051), vec4(-0.092, 0.078, 0.185, 0.084), vec4(-0.339, -0.006, 0.206, 0.012), vec4(0.090, 0.124, 0.046, -0.197)) * bufB[5] + mat4(vec4(-0.498, -0.022, -0.152, -0.054), vec4(0.488, 0.265, -0.312, -0.146), vec4(0.023, 0.023, 0.335, -0.214), vec4(-0.023, -0.124, -0.037, 0.381)) * bufB[6] + mat4(vec4(0.399, -0.221, -0.052, 0.167), vec4(0.361, 0.242, -0.112, -0.042), vec4(0.052, 0.171, 0.162, 0.100), vec4(0.050, -0.347, -0.074, 0.367)) * bufB[7] + mat4(vec4(-0.230, 0.230, 0.011, 0.220), vec4(-0.031, -0.266, -0.123, 0.168), vec4(0.097, 0.237, 0.242, -0.124), vec4(0.027, -0.093, -0.053, -0.342)) * bufB[8] + mat4(vec4(0.079, -0.022, 0.114, -0.325), vec4(-0.150, -0.130, 0.183, 0.003), vec4(0.262, 0.137, -0.092, 0.375), vec4(0.062, 0.191, 0.067, 0.317)) * bufB[9];\nbufA[1] = vec4(-0.575, 0.097, 0.115, -0.011) + mat4(vec4(0.111, -0.210, -0.125, 0.342), vec4(0.054, 0.261, 0.019, -0.196), vec4(-0.114, -0.099, 0.070, -0.129), vec4(-0.117, 0.020, 0.362, 0.160)) * bufB[0] + mat4(vec4(0.042, -0.106, -0.239, -0.049), vec4(-0.041, -0.267, -0.083, -0.100), vec4(-0.310, -0.266, 0.212, 0.107), vec4(0.233, 0.222, -0.049, -0.236)) * bufB[1] + mat4(vec4(0.601, 0.084, -0.253, -0.233), vec4(-0.261, -0.149, -0.055, -0.316), vec4(0.108, 0.392, -0.119, 0.357), vec4(-0.043, -0.077, -0.083, 0.028)) * bufB[2] + mat4(vec4(0.052, 0.159, -0.433, 0.011), vec4(-0.091, 0.421, 0.442, 0.141), vec4(0.170, -0.076, 0.297, 0.186), vec4(0.075, 0.158, 0.076, -0.077)) * bufB[3] + mat4(vec4(0.043, -0.068, 0.491, 0.248), vec4(0.136, 0.059, -0.130, -0.303), vec4(-0.555, 0.026, 0.154, -0.002), vec4(-0.059, 0.048, 0.126, 0.116)) * bufB[4] + mat4(vec4(0.213, 0.217, -0.120, -0.791), vec4(-0.127, 0.161, 0.160, 0.046), vec4(0.101, 0.081, -0.017, 0.279), vec4(-0.243, -0.233, -0.179, -0.385)) * bufB[5] + mat4(vec4(0.074, 0.481, -0.091, -0.228), vec4(-0.426, -0.046, 0.089, -0.568), vec4(0.227, 0.221, -0.202, 0.147), vec4(0.211, 0.213, -0.230, 0.349)) * bufB[6] + mat4(vec4(-0.340, -0.199, 0.191, -0.149), vec4(-0.297, -0.176, -0.149, -0.269), vec4(0.150, 0.309, 0.123, 0.265), vec4(-0.305, 0.264, -0.244, 0.004)) * bufB[7] + mat4(vec4(0.318, 0.075, 0.003, 0.279), vec4(-0.229, 0.039, -0.154, -0.134), vec4(0.262, 0.174, -0.371, 0.105), vec4(0.407, -0.003, 0.265, -0.315)) * bufB[8] + mat4(vec4(-0.157, -0.494, -0.047, 0.178), vec4(0.118, -0.075, -0.494, 0.626), vec4(-0.748, -0.086, -0.018, -0.223), vec4(0.595, 0.071, -0.232, -0.084)) * bufB[9];\nbufA[2] = vec4(-0.658, -0.609, 0.089, -0.458) + mat4(vec4(-0.289, 0.027, 0.260, 0.187), vec4(-0.006, 0.218, -0.116, -0.411), vec4(0.291, -0.085, -0.006, 0.053), vec4(-0.189, 0.222, 0.126, -0.498)) * bufB[0] + mat4(vec4(0.080, -0.050, -0.521, -0.093), vec4(-0.162, 0.133, -0.131, 0.034), vec4(0.419, 0.116, 0.039, -0.106), vec4(0.415, 0.120, -0.013, -0.233)) * bufB[1] + mat4(vec4(0.011, -0.073, -0.203, 0.097), vec4(0.048, -0.092, -0.143, -0.359), vec4(-0.042, 0.316, 0.411, -0.067), vec4(-0.264, 0.262, 0.042, 0.423)) * bufB[2] + mat4(vec4(-0.224, -0.013, 0.291, 0.030), vec4(-0.052, -0.170, -0.119, -0.173), vec4(-0.037, -0.163, 0.095, 0.422), vec4(0.046, -0.193, 0.359, -0.098)) * bufB[3] + mat4(vec4(-0.159, -0.041, -0.438, -0.288), vec4(0.142, 0.367, 0.128, 0.356), vec4(-0.442, 0.062, -0.140, 0.240), vec4(-0.044, 0.007, 0.254, -0.403)) * bufB[4] + mat4(vec4(0.309, -0.271, 0.165, -0.185), vec4(0.154, 0.080, 0.357, -0.205), vec4(-0.037, -0.072, 0.101, -0.268), vec4(-0.089, 0.288, -0.041, -0.055)) * bufB[5] + mat4(vec4(0.066, 0.004, -0.230, 0.027), vec4(0.069, -0.155, 0.072, -0.158), vec4(0.193, -0.131, -0.266, 0.114), vec4(-0.077, 0.005, 0.152, -0.108)) * bufB[6] + mat4(vec4(-0.057, -0.099, 0.141, -0.250), vec4(-0.020, 0.230, -0.105, -0.151), vec4(0.128, -0.094, 0.177, 0.067), vec4(0.052, -0.070, -0.041, 0.195)) * bufB[7] + mat4(vec4(-0.036, -0.140, -0.004, 0.007), vec4(-0.068, -0.103, 0.279, -0.339), vec4(0.138, -0.037, 0.068, 0.122), vec4(0.054, 0.287, 0.039, 0.081)) * bufB[8] + mat4(vec4(0.012, 0.133, 0.534, -0.037), vec4(-0.014, 0.045, 0.006, -0.014), vec4(-0.190, -0.357, 0.024, -0.113), vec4(0.316, -0.161, -0.001, -0.108)) * bufB[9];\nbufA[3] = vec4(0.223, 0.609, -0.171, 0.086) + mat4(vec4(0.050, -0.276, 0.116, 0.079), vec4(0.005, -0.056, 0.316, -0.029), vec4(0.001, -0.110, -0.090, 0.172), vec4(-0.256, 0.311, 0.220, 0.066)) * bufB[0] + mat4(vec4(0.152, -0.104, -0.210, 0.069), vec4(0.490, 0.022, -0.254, -0.159), vec4(-0.050, 0.232, -0.254, -0.116), vec4(0.195, 0.506, -0.415, -0.388)) * bufB[1] + mat4(vec4(0.148, -0.295, 0.151, 0.051), vec4(-0.141, -0.000, 0.138, -0.107), vec4(-0.015, -0.199, 0.170, 0.139), vec4(-0.287, 0.431, 0.180, -0.020)) * bufB[2] + mat4(vec4(0.229, -0.188, 0.427, -0.323), vec4(-0.156, -0.022, 0.144, -0.710), vec4(-0.320, 0.246, -0.255, -0.051), vec4(-0.433, 0.191, 0.134, -0.531)) * bufB[3] + mat4(vec4(-0.196, 0.212, 0.177, -0.345), vec4(-0.072, 0.178, 0.368, -0.013), vec4(0.014, -0.221, 0.074, 0.036), vec4(-0.009, -0.159, -0.081, -0.340)) * bufB[4] + mat4(vec4(-0.005, -0.004, -0.314, -0.010), vec4(-0.361, 0.071, -0.045, 0.048), vec4(-0.112, 0.088, -0.197, 0.151), vec4(0.125, -0.280, 0.354, 0.036)) * bufB[5] + mat4(vec4(0.012, 0.107, 0.208, -0.142), vec4(0.095, -0.052, -0.151, -0.088), vec4(0.017, 0.085, 0.201, -0.060), vec4(0.191, 0.084, -0.191, 0.112)) * bufB[6] + mat4(vec4(-0.031, -0.278, -0.201, 0.056), vec4(-0.015, -0.381, 0.335, -0.172), vec4(0.386, -0.122, -0.007, 0.024), vec4(-0.081, 0.110, -0.043, 0.043)) * bufB[7] + mat4(vec4(-0.172, -0.319, 0.388, -0.233), vec4(0.044, 0.025, 0.080, -0.231), vec4(-0.330, 0.247, 0.109, -0.342), vec4(-0.236, 0.263, -0.335, 0.297)) * bufB[8] + mat4(vec4(-0.012, 0.078, 0.167, 0.056), vec4(-0.036, 0.020, 0.172, -0.383), vec4(0.119, 0.060, -0.271, -0.227), vec4(-0.281, 0.128, 0.216, -0.037)) * bufB[9];\nbufA[4] = vec4(-0.102, 0.181, -0.182, 0.741) + mat4(vec4(0.041, -0.020, -0.276, 0.123), vec4(-0.108, -0.304, -0.731, 0.022), vec4(-0.002, 0.248, -0.674, -0.302), vec4(0.144, -0.110, 0.339, -0.098)) * bufB[0] + mat4(vec4(-0.030, 0.024, -0.117, 0.131), vec4(0.095, -0.110, 0.118, -0.536), vec4(0.039, 0.173, 0.218, -0.152), vec4(0.027, -0.528, -0.132, -0.283)) * bufB[1] + mat4(vec4(-0.120, -0.135, 0.124, 0.123), vec4(-0.202, 0.093, 0.271, 0.031), vec4(0.075, -0.160, -0.229, -0.192), vec4(0.520, -0.385, 0.544, -0.058)) * bufB[2] + mat4(vec4(0.351, -0.180, 0.240, 0.326), vec4(0.050, 0.242, 0.285, -0.171), vec4(-0.204, -0.154, 0.040, 0.240), vec4(0.187, 0.287, 0.492, 0.133)) * bufB[3] + mat4(vec4(-0.085, -0.183, 0.288, -0.444), vec4(0.089, 0.376, -0.153, -0.288), vec4(-0.190, -0.470, 0.266, 0.205), vec4(0.019, -0.231, -0.226, -0.107)) * bufB[4] + mat4(vec4(-0.360, 0.034, 0.020, -0.007), vec4(-0.367, -0.178, 0.611, 0.128), vec4(0.016, -0.378, -0.005, 0.248), vec4(0.019, -0.316, -0.511, -0.042)) * bufB[5] + mat4(vec4(-0.020, 0.061, -0.120, 0.033), vec4(-0.181, 0.199, -0.018, -0.048), vec4(-0.247, -0.175, 0.238, 0.215), vec4(0.357, -0.432, -0.099, -0.009)) * bufB[6] + mat4(vec4(0.087, -0.348, 0.513, -0.141), vec4(-0.051, -0.000, 0.036, -0.340), vec4(0.268, 0.325, 0.014, 0.229), vec4(0.288, 0.009, -0.394, 0.155)) * bufB[7] + mat4(vec4(0.285, -0.045, 0.086, 0.185), vec4(-0.180, 0.062, 0.033, 0.031), vec4(-0.305, 0.084, -0.128, 0.099), vec4(-0.188, 0.166, 0.447, -0.113)) * bufB[8] + mat4(vec4(-0.046, -0.043, -0.011, 0.101), vec4(-0.344, 0.051, -0.369, -0.127), vec4(-0.141, 0.050, -0.008, -0.196), vec4(-0.097, 0.265, 0.146, 0.605)) * bufB[9];\ntmp = atan(bufA[0]);\nbufB[0] = tmp/0.67;\nbufB[5] = (tmp*tmp - 0.45) / 0.396;\ntmp = atan(bufA[1]);\nbufB[1] = tmp/0.67;\nbufB[6] = (tmp*tmp - 0.45) / 0.396;\ntmp = atan(bufA[2]);\nbufB[2] = tmp/0.67;\nbufB[7] = (tmp*tmp - 0.45) / 0.396;\ntmp = atan(bufA[3]);\nbufB[3] = tmp/0.67;\nbufB[8] = (tmp*tmp - 0.45) / 0.396;\ntmp = atan(bufA[4]);\nbufB[4] = tmp/0.67;\nbufB[9] = (tmp*tmp - 0.45) / 0.396;\n\n // layer 9 \nbufA[0] = vec4(-0.253, -0.070, -0.580, 0.000) + mat4(vec4(0.052, -0.070, -0.106, 0.000), vec4(-0.174, 0.013, 0.066, 0.000), vec4(0.215, -0.015, -0.046, 0.000), vec4(-0.178, -0.095, -0.019, 0.000)) * bufB[0] + mat4(vec4(-0.193, -0.145, -0.116, 0.000), vec4(0.031, -0.030, -0.023, 0.000), vec4(0.053, 0.137, 0.013, 0.000), vec4(0.127, 0.057, 0.136, 0.000)) * bufB[1] + mat4(vec4(0.288, 0.181, -0.063, 0.000), vec4(0.196, -0.047, 0.015, 0.000), vec4(0.005, -0.041, -0.098, 0.000), vec4(-0.414, -0.022, 0.110, 0.000)) * bufB[2] + mat4(vec4(-0.497, -0.338, -0.336, 0.000), vec4(0.183, 0.096, 0.127, 0.000), vec4(-0.279, -0.074, -0.146, 0.000), vec4(-0.006, 0.084, 0.245, 0.000)) * bufB[3] + mat4(vec4(0.070, -0.036, -0.147, 0.000), vec4(-0.308, -0.317, -0.280, 0.000), vec4(0.072, 0.057, 0.018, 0.000), vec4(-0.247, -0.040, -0.013, 0.000)) * bufB[4] + mat4(vec4(-0.239, -0.246, -0.234, 0.000), vec4(0.142, 0.150, 0.186, 0.000), vec4(0.001, -0.140, -0.304, 0.000), vec4(-0.004, -0.037, -0.196, 0.000)) * bufB[5] + mat4(vec4(-0.191, -0.180, -0.226, 0.000), vec4(0.308, 0.230, 0.242, 0.000), vec4(-0.059, -0.160, -0.213, 0.000), vec4(-0.237, -0.222, -0.218, 0.000)) * bufB[6] + mat4(vec4(-0.030, -0.107, -0.198, 0.000), vec4(-0.252, -0.131, 0.028, 0.000), vec4(0.320, 0.267, 0.233, 0.000), vec4(-0.206, 0.100, 0.479, 0.000)) * bufB[7] + mat4(vec4(-0.047, 0.097, 0.097, 0.000), vec4(-0.156, -0.191, -0.226, 0.000), vec4(0.167, 0.248, 0.416, 0.000), vec4(0.049, 0.128, 0.413, 0.000)) * bufB[8] + mat4(vec4(0.549, 0.120, -0.227, 0.000), vec4(-0.162, -0.124, -0.190, 0.000), vec4(-0.095, -0.153, -0.202, 0.000), vec4(-0.197, -0.163, -0.063, 0.000)) * bufB[9];\n\n return vec4((1. / (1. + exp(-bufA[0]))).xyz, 1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 mouseNorm = (iMouse.xy / iResolution.xy) - vec2(0.5, 0.5);\n\n    uv.x *= iResolution.x / iResolution.y;\n    uv.x -= ((iResolution.x / iResolution.y) - 1.) /2.;\n\n    // Shifted to the form expected by the CPPN\n    uv = vec2(1., -1.) * vec2(1.2, 1.666) * (uv - vec2(0.5, 0.5));\n    // Output to screen\n    fragColor = cppn_fn(uv, 0.23*sin(iTime), 0.32*sin(0.69*iTime), 0.32*sin(0.44*iTime), 0.23*sin(1.23*iTime));\n}\n        ", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/fd2GWz.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "fd2SRR", "name": "Gem spiral mosaic", "author": "jarble", "description": "A mosaic of gems and spirals.", "tags": ["fractal", "spiral", "gem"], "likes": 2, "viewed": 149, "date": "1619550044", "time_retrieved": "2024-06-20T20:36:46.865453", "image_code": "#define ITERS 12\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.0);\n    vec3 col=vec3(0.0),col_prev=vec3(0.0);\n    float t=0.0;\n    vec2 uv = (fragCoord*10.0-iResolution.xy)/iResolution.y/15.0;\n    uv.y += (iTime)/25.0;\n    for(int c=0;c<ITERS;c++){\n        float scale = 2.65;\n        float scale1 = 1.05;\n        float s1 = scale1*scale;\n        col_prev = col;\n        for(int i=0;i<ITERS;i++)\n        {\n            \n            uv= fract(-uv-((vec2(-uv.x/scale+uv.y/scale1,uv.y/scale-uv.x/scale1)/(scale))))/scale1;\n            uv.x *= scale1;\n            uv = fract(-uv.yx/s1)*s1;\n            \n            scale1 += (uv.x*(.00025*fract((uv.x+iTime)/2.)));\n            //make it dance!\n            \n            uv.y /= -scale1;\n        }\n        col[2] = abs(fract(uv.y)-fract(uv.x));\n        col = ((col+col_prev.yzx))/2.125;\n\t}\n    fragColor = vec4(vec3(col*3.0),1.0);\n    \n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/fd2SRR.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "fd2Xz1", "name": "lattice 01", "author": "boxes", "description": "this was originally a bug caused by setting the ray step limit very low. ", "tags": ["domainrepetition", "monochrome", "deptherror"], "likes": 1, "viewed": 59, "date": "1619663609", "time_retrieved": "2024-06-20T20:36:47.665403", "image_code": "#define PI 3.141592653589793\n#define TWO_PI 6.283185307179586\n#define MAX_STEPS 64\n#define DISTANCE_THRESHOLD 0.0001\n\nfloat sphere(in vec3 p, in float r) {\n    return length(p) - r;\n}\n\nfloat plane(vec3 p, float height) {\n    return p.z - height;\n}\n\n// from https://www.iquilezles.org/www/articles/distfunctions/distfunctions.htm\nfloat box(in vec3 p, in vec3 b) {\n    vec3 q = abs(p) - b;\n    return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\n// check distance for all shapes\nfloat f( in vec3 p ) {\n    float spacing = 2.0 * PI / 3.0;\n\n    vec3 sp0 = vec3(0.5, 0.5, 0.5);\n    \n    vec3 w = vec3( fract(p.x / 4.0),\n                   fract(p.y / 4.0),\n                   fract(p.z / 4.0) );\n    \n    float t = 1.0 / 16.0;\n    float v = 1.0 / 16.0;\n    float l = 3.0 / 16.0;\n    float d = box(sp0 - w, vec3(l, t, t));\n    d = min(d, box(sp0 - w, vec3(t, l, t)));\n    d = min(d, box(sp0 - w, vec3(t, t, l)));\n    // d = min(d, box(sp0 - w, vec3(v, v, v)));\n    \n    return d;\n}\n\nvec3 get_normal( in vec3 p ) {  // sample along 3 axes to get a normal  \n    const float o = 0.0009765625; // 1 / 1024\n    float c = f(p); // calculate redundantly for now to avoid the bug\n    const vec2 h = vec2(o, 0); // transpose instead of making new per axis\n    return normalize(vec3( f(p + h.xyy) - c,\n                           f(p + h.yxy) - c,\n                           f(p + h.yyx) - c) );\n}\n\nfloat cast_ray(inout vec3 p, in vec3 h) {\n    float depth = 0.0;\n    float d;\n    for (int a = 0; a < MAX_STEPS; a ++) {\n        d = f(p);     // test distance\n        p += d * h;   // step the point\n        depth += d;\n        if (d < DISTANCE_THRESHOLD) {\n            break;\n        }\n    }\n    return d;\n}\n\n// --------------------------------------\n// oldschool rand() from Visual Studio\n// --------------------------------------\nint   seed = 1;\nvoid  srand(int s ) { seed = s; }\nint   rand(void) { seed=seed*0x343fd+0x269ec3; return (seed>>16)&32767; }\nfloat frand(void) { return float(rand())/32767.0; }\n// --------------------------------------\n// hash to initialize the random seed (copied from Hugo Elias)\n// --------------------------------------\nint hash( int n ) { n=(n<<13)^n; return n*(n*n*15731+789221)+1376312589; }\n\nvec3 spherical() {\n    float z = frand() * 2.0 - 1.0;\n    float angle = TWO_PI * frand();\n    return vec3( sqrt(1.0 - z*z) * cos(angle), \n                 sqrt(1.0 - z*z) * sin(angle),\n                 z );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // random seed\n    ivec2 q = ivec2(gl_FragCoord); \n    srand(hash(q.x + hash(q.y + hash(int(1000.0 * iTime)))));\n\n    // convert to 1:1 coordinates. the first number controls grid scale.\n    vec2 uv = 1.0 * (gl_FragCoord.xy - 0.5 * iResolution.xy) / iResolution.y; \n  \n    // camera plane\n    float pitch = PI * 1.0 / 3.0 * sin(0.021193 * iTime);\n    float heading = PI * sin(0.082315 * iTime);\n    vec3 pos = vec3(iTime + 1.0, iTime, iTime + 3.0);\n    pos = 4.0 * vec3( fract( 0.25 * pos.x ),\n                      fract( 0.25 * pos.y ),\n                      fract( 0.25 * pos.z ) );\n    vec3 h = vec3( cos(heading) * cos(pitch), \n                   sin(heading) * cos(pitch), \n                   sin(pitch));\n    vec3 ref = vec3(0.0, 0.0, 1.0);   // z axis\n    h = -normalize(h);         // ray heading\n    vec3 i = cross(h, ref);           // corresponds to x in screen space\n    vec3 j = cross(i, h);             // corresponds to y in screen space\n    \n    h += i * uv.x; h += j * uv.y; // heading offsets, from pixel\n    normalize(h);\n\n\n    // light\n    vec3 light = vec3(0.5, 0.25, 0.5);\n    normalize(light);\n    \n\n    // cast ray\n    float d = cast_ray(pos, h); // this updates pos\n    vec3 normal = get_normal(pos);\n\n    float s = 1.0;\n    \n    // ambient occlusion\n    for (float i = 0.0; i < 1.0; i += 0.25) {\n        float occlusion_offset = 0.1 * i * i;\n        s -= 32.0 * clamp(0.25 * ( (occlusion_offset + d)\n                           - f(pos + occlusion_offset * normal) ), \n                           0.0, 1.0);\n    }\n    \n\n    // lighting, materials etc.\n    \n    \n    float value = 0.25 * dot(h, normal);\n    float fog = (1.0 - 1.0 / (length(pos) * 0.005 + 1.0));\n    // s += fog;\n\n    value += 1.0 / 8.0 * (frand() - 0.5);\n    value = value * s + fog;\n\n    fragColor = vec4( value, value, value, \n                      1.0 );\n\n    // fragColor = vec4( normal.x * 0.5 + 0.5, \n    //                   normal.y * 0.5 + 0.5, \n    //                   normal.z * 0.5 + 0.5, \n    //                   1.0);\n\n    // fragColor = vec4( value + fog, value + fog, value + fog, 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/fd2Xz1.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "fdB3RK", "name": "3p Shader", "author": "atteherttala", "description": "Wavy", "tags": ["waves"], "likes": 0, "viewed": 60, "date": "1617625726", "time_retrieved": "2024-06-20T20:36:47.665550", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalisoidut pikselin koordinaatit (0:sta 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    //Pikselin väri (R,G,B)\n    vec3 col = vec3(0,0,0);\n    \n\n    //Jos pikselin (x,y) y-koordinaatti on pienempi kuin sin(x) (sekä kertoimia jotta saadaan mahtumaan koko näytölle)\n    if(uv.y < 0.5*sin(iTime + uv.x*10.0)+0.5)col = \n\n    //Alhaalta ylöspäin tulevat aaltojen kertoimet, joilla kerrotaan sinistä väriä.\n    0.7/(0.5*sin(iTime + uv.x * 10.0) -uv.y - 0.5) *\n\n    //Itse väri, jossa sinistä väriä lisätään cos(aika) mukaan\n    0.4 * vec3(0,1,cos(iTime * 8.0));\n    \n\n    //Jos pikselin (x,y) y-koordinaatti on suurempi kuin sin(x)\n    if(uv.y > 0.5*sin(iTime + uv.x*10.0)+0.5)col = \n\n    //Tummuuskerroin kohtiin jotka ovat lähellä sinin \"reunaa\"\n    (uv.y - 0.5*sin(iTime + uv.x*10.0)+0.5) * 0.2\n    \n    //Itse väri jossa vihreää väriä lisätään sin(aika) mukaan\n    + 0.1* vec3(1,sin(iTime*10.0),0);\n\n\n\n    // Asetetaan väri ruudulle\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/fdB3RK.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "fdB3WW", "name": "Noise Xploration 03", "author": "Taron", "description": "Simply experimenting around with noise. Turned out kind of pretty, so why not share it... ☺\n• Use mouse to move light source. Mouse Y coordinate offsets Z for fractal noise.", "tags": ["simple", "turbulence", "fractalnoise"], "likes": 7, "viewed": 95, "date": "1617381097", "time_retrieved": "2024-06-20T20:36:48.053416", "image_code": "#define OCTAVES 5\n#define SIZE 0.75\n\nfloat hash12(vec2 p) {\n\tfloat h = dot(p,vec2(127.1,311.7));\t\n    return fract(sin(h)*43758.5453123);\n}\n\nfloat smoother(float f){\n    return f * f * f * (f * (f * 6. - 15.) + 10.);;\n}\n\n// 3d noise\nfloat noise_3(in vec3 p) {\n    vec3 i = floor(p);\n    vec3 f = fract(p);\t\n\tvec3 u = f*f*(3.0-2.0*f);\n    \n    \n    vec2 ii = i.xy + i.z * vec2(5.0);\n    float a = hash12( ii + vec2(0.0,0.0) );\n\tfloat b = hash12( ii + vec2(1.0,0.0) );    \n    float c = hash12( ii + vec2(0.0,1.0) );\n\tfloat d = hash12( ii + vec2(1.0,1.0) ); \n    float v1 = mix(mix(a,b,u.x), mix(c,d,u.x), u.y);\n    \n    ii += vec2(5.0);\n    a = hash12( ii + vec2(0.0,0.0) );\n\tb = hash12( ii + vec2(1.0,0.0) );    \n    c = hash12( ii + vec2(0.0,1.0) );\n\td = hash12( ii + vec2(1.0,1.0) );\n    float v2 = mix(mix(a,b,u.x), mix(c,d,u.x), u.y);\n        \n    return max(mix(v1,v2,u.z),0.0);\n}\n\nfloat fbm(vec3 p, int oct)\n{\n    float r = 0.0;\n    float w = 1.0, s = 1.0;\n    float d = 0.0;\n    for (int i=0; i<oct; i++)\n    {\n        w *= 0.9-r*.35;\n        s *= 2.0;\n        r += w * abs(-1.+ 2. *noise_3(s * p + dot(vec3(d,0.25,0.),p+r*d)));\n        d +=w;\n    }\n    float noise = -1.+2.*r/d;\n    noise = smoother(noise*noise);\n    return p.x>noise?1.-noise:noise;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel&mouse coordinates (from -1 to 1)\n    vec2 uv = (2.*fragCoord-iResolution.xy)/iResolution.y;\n    vec2 mouse = (2.*iMouse.xy-iResolution.xy)/iResolution.y;\n    \n    // Get noises\n    vec3 np = vec3(uv,mouse.y+iTime*.05)*SIZE;//iMouse.y/iResolution.y +iTime*.05\n    vec2 offset = vec2(1.0/iResolution.y,0.);\n    \n    float cnt = fbm(np, OCTAVES);\n    vec3 norm = vec3(fbm(np+offset.xyy,OCTAVES)-cnt,fbm(np+offset.yxy,OCTAVES)-cnt, 0.05);\n    norm = normalize(norm);\n     \n    // Lighting and Rendering \n    vec3 lit = normalize(vec3(mouse,.9)-vec3(uv,.5));\n    vec3 cam = normalize(vec3(uv,0.)-vec3(0.,0.,1.));\n    float refl = pow(max(0.,dot(cam,reflect(lit, norm))),20.);\n    vec3 col = vec3(dot(lit,norm) * mix(vec3(1.,0.75,0.02),vec3(0.5,0.8,1.0), cnt)+refl);\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/fdB3WW.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "fdB3zV", "name": "Stanley", "author": "SnoopethDuckDuck", "description": "In and outy thingy", "tags": ["cool"], "likes": 1, "viewed": 31, "date": "1617633969", "time_retrieved": "2024-06-20T20:36:48.283745", "image_code": "const float pi = 3.14159;\nconst float pi2 = 2. * 3.14159 / 3.;\nconst float pi3 = 4. * 3.14159 / 3.;\n\n\nfloat g(in float x)\n{\nfloat f = 0.25 * (1. + cos(x));\nfloat h = 16. * f * f * (1.-f) * (1.-f);\n\nfloat f2 = 0.25 * (1. + cos(x + pi2));\nfloat h2= 16. * f2 * f2 * (1.-f2) * (1.-f2);\nfloat k = 1. - h * h2;\nreturn 120. / k * k * (1.- k) *(1.-k);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\nvec2 dir = uv - 0.5;\nfloat d = 8.* (2. + cos(0.25 * iTime)) *length(dir);\nfloat theta = atan(dir.y,dir.x);\n\nfloat val = (1. -0.25 * d ) * g(iTime) * 0.5 * (2. + cos(2. * theta *theta + 0.005 * (1. - cos(theta +0.5 * iTime + pi2)) * iTime));\nfloat val2 =  (1.-0.25 * d) * g(iTime + pi2) *0.5 * (2. + cos(7. *theta + 0.005 * (1. - cos(theta + 0.5 * iTime + pi3)) *iTime + pi2));\nfloat val3 = (1. -0.25 *  d) * g(iTime + pi3) *0.5 * (2. + cos(5. *theta +0.005 * (1. - cos(theta + 0.5 * iTime )) * iTime + pi3));\n    // Time varying pixel color\n    vec3 col = 1.- vec3(smoothstep(d,val,   \n    sqrt(val2 * val2 + val3 * val3)),\n    smoothstep(d,val2,   \n    sqrt(val * val + val3 * val3)),\n    smoothstep(d,val3,   \n   sqrt(val * val + val2 * val2))\n    \n        \n    );\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/fdB3zV.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "fdBGDd", "name": "Raymarching Primitives of Funk 2", "author": "IMLXH", "description": "CGA edition!", "tags": ["tutorial", "experiment"], "likes": 0, "viewed": 31, "date": "1618084855", "time_retrieved": "2024-06-20T20:36:48.908047", "image_code": "#define MAX_STEPS 100\n#define MAX_DIST 100.\n#define SURF_DIST .01\n\nfloat sdCapsule(vec3 p, vec3 a, vec3 b, float r) {\n    vec3 ab = b-a;\n    vec3 ap = p-a;\n    \n    float t = dot(ab, ap) / dot(ab, ab);\n    t = clamp(t, 0., 1.);\n    \n    vec3 c = a + t*ab;\n    \n    return length(p-c)-r;\n}\n\nfloat sdCylinder(vec3 p, vec3 a, vec3 b, float r) {\n    vec3 ab = b-a;\n    vec3 ap = p-a;\n    \n    float t = dot(ab, ap) / dot(ab, ab);\n    //t = clamp(t, 0., 1.);\n    \n    vec3 c = a + t*ab;\n    \n    float x = length(p-c)-r;\n    float y = (abs(t-.5)-.5) * length(ab);\n    float e = length(max(vec2(x,y), 0.));\n    float i = min(max(x, y), 0.);\n    \n    return e+i;\n}\n\nfloat sdTorus(vec3 p, vec2 r) {\n    float x = length(p.xz)-r.x;\n    return length(vec2(x, p.y))-r.y;\n}\n\nfloat dBox(vec3 p, vec3 s) {\n    return length(max(abs(p) - s, 0.));\n}\n\nfloat GetDist(vec3 p) {\n    vec4 s = vec4(0, 1, 6, 1); // sphere\n    \n    float sphereDist = length(p-s.xyz)-s.w; // s.w is sphere radius i guess\n    float planeDist = p.y;\n    \n    float cd = sdCapsule(p, vec3(0,1,6), vec3(1,2,6), .2);\n    float td = sdTorus(p-vec3(0.,.5,6.), vec2(1.5, .3));\n    float bd = dBox(p-vec3(-3., .75, 6.), vec3(.75));\n    float cyld = sdCylinder(p, vec3(0,.3,3), vec3(3,1,5), .3);\n    \n    float d = min(cd, planeDist);\n    d = min(d, td); // mixing objects in raymarching is done with min()\n    d = min(d, bd);\n    d = min(d, cyld);\n    return d;\n}\n\nvec3 GetNormal(vec3 p) {\n    float d = GetDist(p);\n    vec2 e = vec2(.01, 0);\n    \n    vec3 n = d - vec3(\n        d-GetDist(p-e.xyy), // recreating the happy accident\n        d-GetDist(p-e.yxy),\n        d-GetDist(p-e.yyx));\n    \n    return normalize(n);\n}\n\nfloat RayMarch(vec3 ro, vec3 rd) {\n    float dO = 0.;\n    for (int i = 0; i < MAX_STEPS; i++) {\n        vec3 p = ro + dO*rd;\n        float dS = GetDist(p);\n        dO += dS;\n        if (dS<SURF_DIST || dO>MAX_DIST) break;\n    }\n    return dO;\n}\n\nfloat GetLight(vec3 p) {\n    vec3 lightPos = vec3(0, 5, 6);\n    lightPos.xz += vec2(sin(iTime), cos(iTime))*2.;\n    vec3 l = normalize(lightPos-p);\n    vec3 n = GetNormal(p);\n    \n    float dif = clamp(dot(n, l), 0., 1.);\n    float d = RayMarch(p+n*SURF_DIST*2., l);\n    if (d<length(lightPos-p)) dif *= .1; // shadows!\n    return dif;\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y; // OOH you can do this all in one line\n\n    vec3 col = vec3(0);\n    \n    // CAMERA\n    vec3 ro = vec3(sin(iTime), 2, cos(iTime)-.5)*vec3(2., 1., 2.);\n    vec3 rd = normalize(vec3(uv.x, uv.y-.3, 1));\n\n    float d = RayMarch(ro, rd);\n    \n    vec3 p = ro + rd * d;\n    \n    float dif = GetLight(p); // diffuse lighting\n    \n    col = GetNormal(p);\n    \n    col /= dif; // boom! instant CGA\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/fdBGDd.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "fdBGDK", "name": "softshadow test", "author": "tono", "description": "softshadow", "tags": ["softshadow"], "likes": 4, "viewed": 71, "date": "1617927137", "time_retrieved": "2024-06-20T20:36:50.326345", "image_code": "float    bo(vec3 p,vec3 s){p = abs(p) - s;return max(p.x,max(p.y,p.z));}\nfloat inBox(vec3 p,vec3 s){p = abs(p) - s;return min(p.x,min(p.y,p.z));}\n\nmat2 rot(float a){return mat2(cos(a),sin(a),-sin(a),cos(a));}\nfloat pi = acos(-1.);\nfloat smoothmin(float d1, float d2, float k){\n    float h = exp(-k * d1) + exp(-k * d2);\n    return -log(h) / k;\n}\n\nvec3 pointlight = normalize(vec3(2.,0.,-6.));\n\nvoid initP()\n{\n    pointlight.xz *= rot(iTime);\n}\n\n//\tby Ian McEwan, Ashima Arts\n//\nvec4 permute(vec4 x){return mod(((x*34.0)+1.0)*x, 289.0);}\nvec4 taylorInvSqrt(vec4 r){return 1.79284291400159 - 0.85373472095314 * r;}\n\nfloat snoise(vec3 v){ \n  const vec2  C = vec2(1.0/6.0, 1.0/3.0) ;\n  const vec4  D = vec4(0.0, 0.5, 1.0, 2.0);\n\n// First corner\n  vec3 i  = floor(v + dot(v, C.yyy) );\n  vec3 x0 =   v - i + dot(i, C.xxx) ;\n\n// Other corners\n  vec3 g = step(x0.yzx, x0.xyz);\n  vec3 l = 1.0 - g;\n  vec3 i1 = min( g.xyz, l.zxy );\n  vec3 i2 = max( g.xyz, l.zxy );\n\n  //  x0 = x0 - 0. + 0.0 * C \n  vec3 x1 = x0 - i1 + 1.0 * C.xxx;\n  vec3 x2 = x0 - i2 + 2.0 * C.xxx;\n  vec3 x3 = x0 - 1. + 3.0 * C.xxx;\n\n// Permutations\n  i = mod(i, 289.0 ); \n  vec4 p = permute( permute( permute( \n             i.z + vec4(0.0, i1.z, i2.z, 1.0 ))\n           + i.y + vec4(0.0, i1.y, i2.y, 1.0 )) \n           + i.x + vec4(0.0, i1.x, i2.x, 1.0 ));\n\n// Gradients\n// ( N*N points uniformly over a square, mapped onto an octahedron.)\n  float n_ = 1.0/7.0; // N=7\n  vec3  ns = n_ * D.wyz - D.xzx;\n\n  vec4 j = p - 49.0 * floor(p * ns.z *ns.z);  //  mod(p,N*N)\n\n  vec4 x_ = floor(j * ns.z);\n  vec4 y_ = floor(j - 7.0 * x_ );    // mod(j,N)\n\n  vec4 x = x_ *ns.x + ns.yyyy;\n  vec4 y = y_ *ns.x + ns.yyyy;\n  vec4 h = 1.0 - abs(x) - abs(y);\n\n  vec4 b0 = vec4( x.xy, y.xy );\n  vec4 b1 = vec4( x.zw, y.zw );\n\n  vec4 s0 = floor(b0)*2.0 + 1.0;\n  vec4 s1 = floor(b1)*2.0 + 1.0;\n  vec4 sh = -step(h, vec4(0.0));\n\n  vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy ;\n  vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww ;\n\n  vec3 p0 = vec3(a0.xy,h.x);\n  vec3 p1 = vec3(a0.zw,h.y);\n  vec3 p2 = vec3(a1.xy,h.z);\n  vec3 p3 = vec3(a1.zw,h.w);\n\n//Normalise gradients\n  vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));\n  p0 *= norm.x;\n  p1 *= norm.y;\n  p2 *= norm.z;\n  p3 *= norm.w;\n\n// Mix final noise value\n  vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n  m = m * m;\n  return 42.0 * dot( m*m, vec4( dot(p0,x0), dot(p1,x1), \n                                dot(p2,x2), dot(p3,x3) ) );\n}\n\n//float id = 0.;\n\nvec2 map(vec3 p)\n{\n    float o = 0.;\n    float id = 0.;\n    p.xy *= rot(iTime/4.7);\n    p.xz *= rot(iTime/5.1);\n    p.yz *= rot(iTime/6.);\n    float box = bo(p,vec3(1.));\n    float s = 5.1;\n    float w = 70.;\n    //o = min( min(abs(p.z + s),abs(p.z - s)),min(min(abs(p.x + s),abs(p.x - s)),min(abs(p.y + s),abs(p.y - s))));\n    \n    vec3 p1 = p;\n    vec3 p2 = p;\n    vec3 p3 = p;\n    p1.x = abs(p.x) - s;\n    box = bo(p1 , vec3(1.,w,w));\n    p2.y = abs(p.y) - s;\n    box = min(box, bo(p2 , vec3(w,1.,w)));\n    p3.z = abs(p.z) - s;\n    box = min(box, bo(p3 , vec3(w,w,1.)));\n    \n    o = box;\n    //if(o < 1.)\n    //{\n    //    o -= snoise(p * 10.)/110.;\n    //}\n    \n    \n    //o = bo(p , vec3(100.));\n    //o = max(-o,length(p) - 6.);\n    float t = floor(iTime) + pow(fract(iTime),1.);\n    vec3 op = p - vec3(sin(t),cos(t),cos(t))/1.;\n    float sph = length(op) - .6;\n    vec3 op2 = p - vec3(cos(t),1. -sin(t + pi/6.),sin(t))/1.;\n    float sph2 = length(op2) - .7;\n    vec3 op3 = p - vec3(cos(t + pi/6.),sin(t ),sin(t))/1.;\n    float sph3 = length(op3) - .4;\n    sph = smoothmin(sph ,sph2,4.);\n    sph = smoothmin(sph ,sph3,6.);\n    o = min(o,sph);\n    if(o < 1.)\n    {\n        o -= snoise(p * 10.)/110.;\n    }\n    float pl = length(p - pointlight) - .1;\n    \n    if(o > pl)\n    {\n        //o = pl;\n        id = 1.;\n    }\n    o = min(o,0.08);\n    return vec2(o,id);\n}\n\nvec2 march(vec3 cp , vec3 rd)\n{\n    float depth = 0.;\n    float id = 0.;\n    for(int i = 0 ; i < 128 ; i++)\n    {\n        vec3 rp = cp + rd * depth;\n        vec2 d = map(rp);\n        if(abs(d.x) < 0.01)\n        {\n            return vec2(depth , d.y);\n        }\n        id = d.y;\n        depth += d.x;\n    }\n    return vec2(-depth , id);\n}\n\n//https://www.shadertoy.com/view/tlXBRl\nfloat calculateObstruction(vec3 pos, vec3 lpos, float lrad)\n{\n    // A homemade algorithm to compute obstruction\n    // Raymarch to the light source, and\n    // record the largest obstruction.\n    // We assume that if the ray passes through an object at depth\n    // d (negative distance), then the object obstructs light\n    // proportional to the relative size of d projected on the light\n    // as given by Thales's theorem.\n    vec3 toLight = normalize(lpos-pos);\n    float distToLight = length(lpos-pos);\n    float d, t=lrad*.1;\n    float obstruction=0.;\n    for(int j=0; j<128; j++)\n    {\n        d = map(pos + t*toLight).x;\n        obstruction = max(.5+(-d)*distToLight/(2.*lrad*t), obstruction);\n        if(obstruction >= 1.){break;}\n        // If we're stuck, advance by the characteristic \n        // size of an obstructing object\n        t += max(d, lrad*t/distToLight);\n        if(t >= distToLight) break;\n    }\n    return clamp(obstruction, 0.,1.);\n}\n\n\nconst int SOFT_SHADOW_STEPS = 50;\nfloat getSoftShadowFactor(vec3 point, vec3 light)\n{\n\tvec3 rd = normalize(light - point);\n\tvec3 ro = point;\n\tfloat maxt = distance(light, point);\n\tfloat t = 0.01;\n    float res = 1.0;\n\tconst float k = 3.0;\n    for( int i = 0; i <  SOFT_SHADOW_STEPS; i++)\n    {\n        float h = map(ro + rd*t).x;\n        if( h<0.001)\n            return 0.0;\n\t\t\n\t\tres = min( res, k*h/t );\t\t\n        t += h;\n\t\t\n\t\tif(t > maxt)\n\t\t\treturn res;\n    }\n    return res;\n}\n\n//\tSimplex 3D Noise \n\n\nfloat getshadow(vec3 pos, vec3 N , vec3 lpos)\n{\n    vec3 ldir = normalize(pos - lpos);\n    vec3 ro = pos + N * 0.01;\n    float depth = 0.;\n    for(int i = 0 ; i < 256 ; i++)\n    {\n        ro = ro + ldir * snoise(ro * 70.) * 0.01;\n        float d = map(ro).x;\n        if(d < 0.01)\n        {\n            //return smoothstep( 0.,1.,log(1./(length(lpos - ro) + 1.)));\n            //return log((length(lpos - ro) + 1.))/5.;\n            return smoothstep(0.,1.,-log(1./(length(lpos - ro) + 1.))/5.);\n        }\n    }\n    return 1.;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = (fragCoord.xy * 2.0 - iResolution.xy) / min(iResolution.x, iResolution.y);\n\tvec3 col = vec3(0.);\n    vec3 cp = vec3(0.,0.,-3.);\n    vec3 target = vec3(0.,0.,0.);\n    vec3 cd = normalize(target -cp);\n    vec3 cs = normalize(cross(vec3(0.,1.,0.),cd));\n    vec3 cu = normalize(cross(cs,cd));\n    \n    float fov = 1.3 - dot(p,p);\n    fov = 1.;\n    vec3 rd = normalize(cd * fov + cs * p.x + cu * p.y);\n    initP();\n    vec2 d = march(cp,rd);\n    \n    if(d.x > 0.)\n    {\n        vec3 pos = cp + rd * d.x;\n        vec2 e = vec2(0.001,0.);\n        vec3 N = -normalize(map(pos).x - vec3(map(pos - e.xxy).x , map(pos - e.xyx).x,map(pos - e.yxx).x));\n        // vec3 pointlight = normalize(vec3(12.,0.,0.));\n        // pointlight.xz *= rot(time);\n        vec3 ldir = normalize(pos - pointlight);\n        float lrad = 0.2;\n        float distToLight = length(pointlight + lrad - pos);\n        float lightStrength = 35.;\n        float diff = max(0.,dot(ldir,N))/(distToLight*distToLight)*lightStrength;\n        float sp = max(0.,dot(reflect(ldir,N) , -rd));\n        diff = mix(diff,  1. , 0.);\n        sp = pow(sp , 12.);\n        \n        if(d.y == 0.)\n        {\n            col = vec3(0.,.5,1.);\n        }\n        else if(d.y == 1.)\n        {\n            col = vec3(1.);\n        }\n        \n       // float shadow = step(march(pos + N * 0.001 , ldir).x,0.);\n        float obstruction = calculateObstruction(pos,pointlight,lrad);\n        float level = diff * (1. - obstruction);\n        col = level * col + sp * col;\n        col = 1.-exp(-2.*col);\n    }\n    col = clamp(col,0.,1.);\n   // col = normalize(col);\n    fragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/fdBGDK.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "fdBGRK", "name": "speeeeeeeeeeeeeeeeen", "author": "Drakyen", "description": "spinning bars + distortion + some fun colors", "tags": ["2d", "distortion", "spinning"], "likes": 1, "viewed": 37, "date": "1617623114", "time_retrieved": "2024-06-20T20:36:50.326345", "image_code": "\n#define rot(a) mat2(cos(a), -sin(a), sin(a), cos(a))\n\nfloat ang(vec2 uv) {return atan(uv.y / uv.x); }\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\n    float scale = 40.;\n    float segments = 10.;\n    \n    uv += vec2(cos(iTime + tan(uv.x)), sin(iTime + tan(uv.y))) * 0.3; \n    \n    uv *= rot(iTime * 0.1 * round(distance(uv, vec2(0,0)) * scale));\n\n    float bright = smoothstep(0., 1.,cos(distance(uv, vec2(0,0)) * scale * 6.25));\n    \n    float dark = sin(ang(uv) * segments) * 3.;\n\n    bright *= dark;\n    \n    vec4 colcentre = vec4(0.282,0.020,0.380,0.);\n    vec4 colouter = vec4(0.161,0.318,0.878,0.);\n    \n    vec4 col = mix(colcentre, colouter, distance(uv, vec2(0,0))) * bright;\n    \n    if(bright <= 0.8) col = vec4(0.016,0.020,0.204,0.);\n    \n    fragColor = vec4(col);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/fdBGRK.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "fdBGWD", "name": "Limited Smooth Mod", "author": "oneshade", "description": "A limited smooth mod operator based on the infinite one by @blackle in this shadertoy: [url=https://www.shadertoy.com/view/wlyBWm]https://www.shadertoy.com/view/wlyBWm[/url]", "tags": ["sdf", "mod", "smooth", "repeat", "operator", "limited", "smod"], "likes": 14, "viewed": 93, "date": "1617378359", "time_retrieved": "2024-06-20T20:36:50.908150", "image_code": "// SDFs\nfloat sdBox(in vec3 p, in vec3 b) {\n    vec3 q = abs(p) - b;\n    return length(max(q, 0.0)) + min(0.0, max(q.x, max(q.y, q.z)));\n}\n\n// Distance operators\n// Use continuous! It will look a lot nicer.\n// Be sure to choose a span that that is a close multiple of the\n// repeat size (times pi because of the trig) otherwise the edges\n// will get really stretched due to the space distortions by the smooth mod.\nfloat smoothModLim(in float x, in float span, in float size, in float smoothness, in bool continuous) {\n    float m = 1.0 - smoothness;\n    float ss = span / size;\n\n    float sModX = asin(sin(x / size) * m) * size;\n\n    float slope = 1.0;\n    float offs = asin(sin(ss) * m) * size;\n\n    if (continuous) {\n        float s = sin(ss);\n        slope = m * cos(ss) / sqrt(1.0 - m * m * s * s);\n    }\n\n    // The mixes are a (shorter) alternative for ifs and elses\n    float sModLimX = mix(sModX, (x - span) * slope + offs, step(span, x));\n    sModLimX = mix(sModLimX, (x + span) * slope - offs, step(span, -x));\n\n    return sModLimX;\n}\n\n// Overloading for vec2\nvec2 smoothModLim(in vec2 x, in vec2 span, in vec2 size, in float smoothness, in bool continuous) {\n    x.x = smoothModLim(x.x, span.x, size.x, smoothness, continuous);\n    x.y = smoothModLim(x.y, span.y, size.y, smoothness, continuous);\n    return x;\n}\n\n// Overloading for vec3\nvec3 smoothModLim(in vec3 x, in vec3 span, in vec3 size, in float smoothness, in bool continuous) {\n    x.xy = smoothModLim(x.xy, span.xy, size.xy, smoothness, continuous);\n    x.z = smoothModLim(x.z, span.z, size.z, smoothness, continuous);\n    return x;\n}\n\n// Scene\nfloat mapScene(in vec3 p) {\n    p = smoothModLim(p, vec3(6.0), vec3(1.5), 0.3, true);\n\n    float c = cos(iTime), s = sin(iTime);\n    p.xz *= mat2(c, -s, s, c);\n    p.yz *= mat2(c, -s, s, c);\n\n    return sdBox(p, vec3(1.0, 0.25, 1.5)) - 0.2;\n}\n\n// Gradient\nvec3 getNormal(in vec3 p) {\n    vec3 e = vec3(0.001, 0.0, 0.0);\n    return normalize(vec3(mapScene(p + e.xyy) - mapScene(p - e.xyy),\n                          mapScene(p + e.yxy) - mapScene(p - e.yxy),\n                          mapScene(p + e.yyx) - mapScene(p - e.yyx)));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 center = 0.5 * iResolution.xy;\n\n    vec2 mouse = true ? (iMouse.xy - center) / iResolution.y * 3.14 : vec2(0.0);\n    vec2 uv = (fragCoord - center) / iResolution.y;\n\n    vec3 ro = vec3(0.0, 0.0, 25.0);\n    vec3 rd = normalize(vec3(uv, -1.0));\n\n    // Rotate with mouse\n    float cy = cos(mouse.x), sy = sin(mouse.x);\n    float cp = cos(mouse.y), sp = sin(mouse.y);\n\n    ro.yz *= mat2(cp, -sp, sp, cp);\n    ro.xz *= mat2(cy, -sy, sy, cy);\n    rd.yz *= mat2(cp, -sp, sp, cp);\n    rd.xz *= mat2(cy, -sy, sy, cy);\n\n    // Sky\n    fragColor = vec4(mix(vec3(0.25, 0.25, 1.0), vec3(1.0), 0.5 + 0.5 * rd.y), 1.0);\n\n    // Raymarch\n    float t = 0.0, d;\n    for (int i=0; i < 150; i++) {\n        vec3 p = ro + rd * t;\n        d = mapScene(p);\n        if (d < 0.001) {\n            vec3 n = getNormal(p);\n            vec3 l = vec3(-0.58, 0.58, 0.58);\n\n            vec3 color = abs(n) * 1.25;\n            fragColor.rgb = color * max(0.2, dot(n, l));\n\n            break;\n        }\n\n        if (t > 50.0) {\n            break;\n        }\n\n        t += d;\n    }\n    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/fdBGWD.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "fdBGWw", "name": "Duckstazy backgrounds", "author": "eliasku", "description": "Try draw cool backgrounds with SDF for Duckstazy Game", "tags": ["duckstazy"], "likes": 3, "viewed": 36, "date": "1617612779", "time_retrieved": "2024-06-20T20:36:50.914302", "image_code": "vec4 getHueColor(float h, float v, float s) {\n    float h6 = 6.0 * h;\n    int hi = int(h6);\n    float f = fract(h6);\n    float p = v * (1.0 - s);\n    float q = v * (1.0 - (s * f));\n    float t = v * (1.0 - (s * (1.0 - f)));\n    vec4 rgba;\n    if (hi == 0) {\n        rgba = vec4(v, t, p, 1.0);\n    } else if (hi == 1) {\n        rgba = vec4(q, v, p, 1.0);\n    } else if (hi == 2) {\n        rgba = vec4(p, v, t, 1.0);\n    } else if(hi == 3) {\n        rgba = vec4(p, q, v, 1.0);\n    } else if (hi == 4) {\n        rgba = vec4(t, p, v, 1.0);\n    } else {\n        rgba = vec4(v, p, q, 1.0);\n    }\n    return rgba;\n}\n\nvec2 cells(vec2 position, vec2 period){\n    position = mod(position, period);\n    //negative positions lead to negative modulo\n    position += period;\n    //negative positions now have correct cell coordinates, positive input positions too high\n    position = mod(position, period);\n    //second mod doesn't change values between 0 and period, but brings down values that are above period.\n    return position;\n}\n\n//////////////////////////////////////\n// Combine distance field functions //\n//////////////////////////////////////\n\n\nfloat smoothMerge(float d1, float d2, float k)\n{\n    float h = clamp(0.5 + 0.5*(d2 - d1)/k, 0.0, 1.0);\n    return mix(d2, d1, h) - k * h * (1.0-h);\n}\n\n\nfloat merge(float d1, float d2)\n{\n\treturn min(d1, d2);\n}\n\n\nfloat mergeExclude(float d1, float d2)\n{\n\treturn min(max(-d1, d2), max(-d2, d1));\n}\n\n\nfloat substract(float d1, float d2)\n{\n\treturn max(-d1, d2);\n}\n\n\nfloat intersect(float d1, float d2)\n{\n\treturn max(d1, d2);\n}\n\n\n//////////////////////////////\n// Rotation and translation //\n//////////////////////////////\n\n\nvec2 rotateCCW(vec2 p, float a)\n{\n\tmat2 m = mat2(cos(a), sin(a), -sin(a), cos(a));\n\treturn p * m;\t\n}\n\n\nvec2 rotateCW(vec2 p, float a)\n{\n\tmat2 m = mat2(cos(a), -sin(a), sin(a), cos(a));\n\treturn p * m;\n}\n\n\nvec2 translate(vec2 p, vec2 t)\n{\n\treturn p - t;\n}\n\n\n//////////////////////////////\n// Distance field functions //\n//////////////////////////////\n\n\nfloat pie(vec2 p, float angle)\n{\n\tangle = radians(angle) / 2.0;\n\tvec2 n = vec2(cos(angle), sin(angle));\n\treturn abs(p).x * n.x + p.y*n.y;\n}\n\n\nfloat circleDist(vec2 p, float radius)\n{\n\treturn length(p) - radius;\n}\n\n\nfloat triangleDist(vec2 p, float radius)\n{\n\treturn max(\tabs(p).x * 0.866025 + \n\t\t\t   \tp.y * 0.5, -p.y) \n\t\t\t\t-radius * 0.5;\n}\n\n\nfloat triangleDist(vec2 p, float width, float height)\n{\n\tvec2 n = normalize(vec2(height, width / 2.0));\n\treturn max(\tabs(p).x*n.x + p.y*n.y - (height*n.y), -p.y);\n}\n\n\nfloat semiCircleDist(vec2 p, float radius, float angle, float width)\n{\n\twidth /= 2.0;\n\tradius -= width;\n\treturn substract(pie(p, angle), \n\t\t\t\t\t abs(circleDist(p, radius)) - width);\n}\n\n\nfloat boxDist(vec2 p, vec2 size, float radius)\n{\n\tsize -= vec2(radius);\n\tvec2 d = abs(p) - size;\n  \treturn min(max(d.x, d.y), 0.0) + length(max(d, 0.0)) - radius;\n}\n\n\nfloat lineDist(vec2 p, vec2 start, vec2 end, float width)\n{\n\tvec2 dir = start - end;\n\tfloat lngth = length(dir);\n\tdir /= lngth;\n\tvec2 proj = max(0.0, min(lngth, dot((start - p), dir))) * dir;\n\treturn length( (start - p) - proj ) - (width / 2.0);\n}\n\nfloat horDist(float y, float halfSize)\n{\n\treturn abs(y) - halfSize;\n}\n\n///////////////////////\n// Masks for drawing //\n///////////////////////\n\n\nfloat fillMask(float dist)\n{\n\treturn clamp(-dist, 0.0, 1.0);\n}\n\nfloat fillMaskSoft(float dist, float w) {\nreturn clamp(-dist / w, 0.0, 1.0);\n}\n\n\nfloat innerBorderMask(float dist, float width)\n{\n\t//dist += 1.0;\n\tfloat alpha1 = clamp(dist + width, 0.0, 1.0);\n\tfloat alpha2 = clamp(dist, 0.0, 1.0);\n\treturn alpha1 - alpha2;\n}\n\n\nfloat outerBorderMask(float dist, float width)\n{\n\t//dist += 1.0;\n\tfloat alpha1 = clamp(dist, 0.0, 1.0);\n\tfloat alpha2 = clamp(dist - width, 0.0, 1.0);\n\treturn alpha1 - alpha2;\n}\n\n\n///////\n///////////////\n// The scene //\n///////////////\nfloat effect1(vec2 p)\n{\n    p.y += 160.0 * iTime;\n    p.y = mod(p.y, 160.0);\n    p = rotateCW(p, sin(iTime) * 0.05);\n    \n    float m = horDist(p.y - 40.0 - (80.0 * cos(0.05)) * (0.5 + 0.5 * sin(iTime)), 40.0);\n    \n\treturn m;\n}\n///////////////\nfloat effect2(vec2 p)\n{\n    float r1 = 22.5 + 12.5 * sin(6.28 * iTime);\n    float r2 = 22.5 - 12.5 * sin(6.28 * iTime);\n    vec2 gridSize = vec2(80.0, 80.0);\n    vec2 gridHalfSize = 0.5 * gridSize;\n    \n    vec2 c1 = cells(p, gridSize);\n    c1 = translate(c1, gridHalfSize);\n\tfloat c1d = circleDist(c1, r1);\n    \n    vec2 c2 = cells(translate(p, gridHalfSize), gridSize);\n    c2 = translate(c2, gridHalfSize);\n    float c2d = circleDist(c2, r2);\n\tfloat m = merge(c1d, c2d);\n\treturn m;\n}\n\n///////////////\nfloat effect3(vec2 p)\n{\n    return abs(mod(length(p - 0.5 * iResolution.xy)+ 100.0 * iTime, 100.0) - 50.0) * 2.0 -50.0;\n    //return mod(length(p - 0.5 * iResolution.xy)+ 100.0 * iTime, 100.0) - 50.0;\n}\n\n\n///////////////\n\nfloat effect4(vec2 p)\n{\n    p = p - 0.5 * iResolution.xy;\n    float an = 6.28 / 30.0;\n    float a = -iTime + atan(p.x, p.y);\n    float d = length(p);\n    float angleDist = abs(mod(a, 2.0 * an) - an) * 2.0 - an;\n    return angleDist * d + 10.0;\n}\n\nfloat scene(vec2 p) {\n    float effectTime = mod(iTime / 5.0, 4.0);\n    int effectIndex = int(effectTime);\n    int prevIndex = effectIndex - 1;\n    float interp = min((effectTime - float(effectIndex)) * 4.0, 1.0);\n    if (prevIndex < 0) prevIndex = 3;\n    if (effectIndex > 3) effectIndex = 0;\n    float e[4];\n     e[0] = 0.0;\n     e[1] = 0.0;\n     e[2] = 0.0;\n     e[3] = 0.0;\n\n    e[prevIndex] = 1.0 - interp;\n    e[effectIndex] = interp;\n    \n\tfloat dist = e[0] * effect1(p) + \n    e[1] * effect2(p) + \n    e[2] * effect3(p) + \n    e[3] * effect4(p);\n    return fillMaskSoft(dist, 10.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //float power = 1.0;\n    float power = 0.5 + 0.5 * sin(0.1 * iTime);\n    float vignetteAlpha = power * 0.5;\n    \n    \n    vec4 skyColor1 = vec4(0.17647058823529413, 0.6196078431372549, 0.9019607843137255, 1);\n    vec4 skyColor2 = vec4(0.8235294117647058, 0.8862745098039215, 0.9647058823529412, 1);\n    vec4 powerColor1 = getHueColor(fract(0.1 * iTime), 1.0, 1.0);\n    vec4 powerColor2 = getHueColor(fract(0.1 * iTime + 1.0 / 6.0), 1.0, 1.0);\n    vec4 powerColor3 = getHueColor(fract(0.1 * iTime + 1.0 / 6.0), 1.0, 1.0);\n    vec4 powerColor4 = getHueColor(fract(0.1 * iTime + 2.0 / 6.0), 1.0, 1.0);\n    \n    vec4 color1 = mix(skyColor1, powerColor1, power);\n    vec4 color2 = mix(skyColor2, powerColor2, power);\n    vec4 color3 = mix(skyColor1, powerColor2, power);\n    vec4 color4 = mix(skyColor2, powerColor4, power);\n    \n    vec2 p = fragCoord.xy + vec2(0.5);\n\tvec2 c = iResolution.xy / 2.0;\n    vec2 iInvTextureSize = vec2(1.0);\n    float vk = length(c - p) / max(c.x, c.y);\n    float blurRadius =  8.0 * vk * vk;\n\n    float offX = blurRadius * iInvTextureSize.x * 1.3333333333333333;\n    float offY = blurRadius * iInvTextureSize.y * 1.3333333333333333;\n    float v = scene(p) * 0.29411764705882354 +\n            scene(p + vec2(-offX, 0.0)) * 0.5 * 0.35294117647058826 +\n            scene(p + vec2(offX, 0.0)) * 0.5 * 0.35294117647058826+\n            scene(p + vec2(0.0, -offY)) * 0.5 * 0.35294117647058826+\n            scene(p + vec2(0.0, offY)) * 0.5 * 0.35294117647058826;\n    \n    //dist = effect4(p);\n    \n\t// gradient\n\tvec4 col = mix(color2, color1, fragCoord.y / iResolution.y);\n    vec4 col2 = mix(color4, color3, fragCoord.y / iResolution.y);\n\t// shape fill\n\tcol = mix(col, col2, v);\n    // vignett\n    col *= (1.0 - vignetteAlpha * vk * vk);\n    \n\tfragColor = clamp(col, 0.0, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/fdBGWw.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "fdBGzd", "name": "Tixy Land - Kaleidoscope", "author": "ern0", "description": "A surprisingly good P/P formula for Tixy\n\nTuxy engine is forked from @Xor https://www.shadertoy.com/view/3dtBDN\n256-byte intro for PC-DOS: https://www.youtube.com/watch?v=uV5qEeMlLrQ", "tags": ["tixykaleidoscope"], "likes": 1, "viewed": 171, "date": "1617799196", "time_retrieved": "2024-06-20T20:36:50.914302", "image_code": "// Forked from https://www.shadertoy.com/view/3dtBDN\n//   by https://www.shadertoy.com/user/Xor\n//\n// Formula by ern0\n//   sin(t*(x-7.5)*(y-7.5)/66)\n//   https://tixy.land/?code=sin%28t*%28x-7.5%29*%28y-7.5%29%2F66%29%2F%2F%65%72%6e%30\n// 256-byte intro (capture): \n//   https://www.youtube.com/watch?v=uV5qEeMlLrQ\n\n//Recreated @aemkey's \"Tixy Land\" in ShaderToy using shader syntax.\n//Play around with the original here: https://tixy.land\n\n// You can fiddle with dot count here:\n#define count 16.\n#define center ((count-1.)/2.)\n\n#define tixy(t,i,x,y) sin(t*(x-center)*(y-center)/66.)\n\n//#define tixy(t,i,x,y) (x-7.5+sin(t)*5.)*(x-7.5+sin(t)*5.)+(y-7.5+cos(t*1.7)*5.)*(y-7.5+cos(t*1.7)*5.)-8.\n\n\n//Render with the result:\nvoid mainImage( out vec4 color, in vec2 coord )\n{\n    float s = 1.2/iResolution.y;\n    vec2 u = (coord-.5*iResolution.xy)*s;\n    u.y = -u.y;\n    \n    float square = step(abs(u.x),.5)*step(abs(u.y),.5);\n    vec2 cell = floor((u+.5)*count);\n    float index = cell.x+cell.y*count;\n    float tixel = float(tixy(iTime,index,cell.x,cell.y));\n    \n    float dist = length(fract(u*count)-.5)*count/.5;\n    float radius = count*min(abs(tixel),1.);\n    \n    vec3 col = tixel<0. ? vec3(255,34,68)/255. : vec3(1);\n    col *= clamp((radius-dist)/s/count/count/2.,0.,1.)*square;\n\n    color = vec4(col,1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/fdBGzd.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "fdBSR1", "name": "_Infinite Circles_", "author": "bhpcv252", "description": "Hi, tried replicating the effect from https://brunoarizio.com/\n\nOpen for optimization remarks. Thank you!", "tags": ["2d", "lines", "circle", "infinite"], "likes": 3, "viewed": 63, "date": "1619649860", "time_retrieved": "2024-06-20T20:36:51.278008", "image_code": "// Effect from https://brunoarizio.com/\n\nfloat rand(vec2 co, float s){\n    float PHI = 1.61803398874989484820459;\n    return fract(tan(distance(co*PHI, co)*s)*co.x);\n}\n\nfloat C( vec2 uv, vec2 pos, float rad, float blur ) {\n    return smoothstep(rad, rad-blur, length(uv-pos));\n}\n\nfloat DL(vec2 uv, vec2 p,  float t, float l) {\n\n    vec2 pos = uv-p;\n    \n    float x = (pos.x >= -(t/2.) && pos.x <= (t/2.))? 1. : 0.;\n    float y = (pos.y >= -(l/2.) && pos.y <= (l/2.))? 1. : 0.;\n    \n    return x*y;\n    \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n\n    uv -= .5;\n    uv.x *= iResolution.x/iResolution.y;\n    \n    vec4 w = vec4(0.8431372549, 0.85098039215, 0.80392156862, 1.);\n\n    vec4 col = vec4(0.03529411764, 0.03921568627, 0.03137254901, 1.);\n    \n    \n    for(float i = -0.6; i<=0.6; i+=0.04) {\n        float l = .75;\n        \n        if(iTime < 5.) {\n            float j = pow(i+ .65, 7.);\n            l = ((-iTime*iTime+j)/25.) + 1.;\n            l = (l < 0.75)? 0.75 : abs(l);\n        }\n        \n        float m = DL(uv, vec2(i, 0.), 0.003, l);\n        col += m;\n    }\n    \n    float m = 0.;\n    \n    if(iTime >= 5.) {\n        float t = iTime-5.;\n        for(float i=1.; i<=6.; i+=1.5) {\n             m = abs(m-C( uv, vec2((-3.*(fract(t/i)-1.))-1.5, 0.), 0.3, 0.005));\n        }\n    \n    }\n    \n    col -= m*w;\n    \n    float colBW = (col.r + col.g + col.b)/3.;\n    \n    float noise = rand(fragCoord, fract(iTime)+1.0)*0.08;\n    \n    noise *= (colBW > 0.5)? -1.: 1.; \n\n    fragColor = abs(col + noise);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/fdBSR1.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "fdfSDB", "name": "Paint Swipe Shader", "author": "Neblig", "description": "based on https://www.shadertoy.com/view/sdjGRc\nTrying to emulate a splattery paint swipe", "tags": ["fractal", "paint", "art", "swipe", "splatter"], "likes": 0, "viewed": 58, "date": "1619118765", "time_retrieved": "2024-06-20T20:36:52.393256", "image_code": "const int MAGIC_BOX_ITERS = 11; //Adjust this: higher = more detail, 11\nconst float MAGIC_BOX_MAGIC = .6; //This number is scary, dont mess with it, .55\n\n\nfloat centerThreshold = 1.0; //Closer they are, further it goes?\nfloat edgeThreshold = 80.0;\n\nfloat splatFalloffSize = .9; //.9\nfloat splatCutoffSize = .1; //different dimesion\n\nvec4 defaultColor = vec4(0,0,0,0);\n \n//float temp = glutGet(GLUT_SCREEN_WIDTH/HEIGHT);\n\n\n//Fractal from https://www.shadertoy.com/view/4ljGDd\nfloat magicBox(vec3 p) {\n    // The fractal lives in a 1x1x1 box with mirrors on all sides.\n    // Take p anywhere in space and calculate the corresponding position\n    // inside the box, 0<(x,y,z)<1\n    p = 1.0 - abs(1.0 - mod(p, 2.0));\n    \n    float lastLength = length(p);\n    float tot = 0.0;\n    // This is the fractal.  More iterations gives a more detailed\n    // fractal at the expense of more computation.\n    for (int i=0; i < MAGIC_BOX_ITERS; i++) {\n      // The number subtracted here is a \"magic\" paremeter that\n      // produces rather different fractals for different values.\n      p = abs(p)/(lastLength*lastLength) - MAGIC_BOX_MAGIC;\n      float newLength = length(p);\n      tot += abs(newLength-lastLength);\n      lastLength = newLength;\n    }\n\n    return tot;\n}\n\n\n// A random 3x3 unitary matrix, used to avoid artifacts from slicing the\n// volume along the same axes as the fractal's bounding box.\nconst mat3 M = mat3(0.28862355854826727, 0.6997227302779844, 0.6535170557707412,\n                    0.06997493955670424, 0.6653237235314099, -0.7432683571499161,\n                    -0.9548821651308448, 0.26025457467376617, 0.14306504491456504);\n\n\nfloat euclideanDistance(vec2 a, vec2 b){\n    return sqrt(pow((a.x - b.x), 2.0) + pow((a.y - b.y), 2.0));\n}\n\nfloat lerp(float a, float b, float w)\n{\n  return a + w*(b-a);\n}\n\nbool inRange(vec2 a, vec2 b, float maxDist){\n    return (euclideanDistance(a, b)/iResolution.y) < maxDist;\n}\n\nvec4 overlayColors(vec4 first, vec4 second){\n    return first * first.w + second * (1.0 - first.w);\n}\n\nvec4 splatColor(vec2 splatCenter, vec4 paintColor, vec2 fragCoord, vec2 uv, float falloffMod)\n{\n\n    //FRACTAL FUN:\n    // Rotate uv onto the random axes given by M, and scale\n    // it down a bit so we aren't looking at the entire\n    // 1x1x1 fractal volume.  Making the coefficient smaller\n    // \"zooms in\", which may reduce large-scale repetition\n    // but requires more fractal iterations to get the same\n    // level of detail.\n    vec3 p = 0.3*M*vec3(uv, 0.0);\n    \n    float result = magicBox(p);\n    // Scale to taste.  Also consider non-linear mappings.\n    //result *= 0.025; \n       //TODO: Scale to dist\n        //Removed this since can just scale threshold by distance\n        \n        \n    //Setup Colors (fun)\n    //vec3 paintColor = vec3(255.0, 0.0, 0.0);\n    //vec3 paintColor = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n\n    vec4 retColor;\n    \n    //Now clamp them values\n    //Set threshold to inverse distance\n    float dist = euclideanDistance(fragCoord, splatCenter); //Pixels\n    float screenDist = dist/iResolution.y; //0 to 1 scale, percent of screen\n    \n    //float threshold = centerThreshold + slope * adjDist; //.25\n    float threshold = lerp(centerThreshold, edgeThreshold, screenDist/(splatFalloffSize*falloffMod + .1)); \n    \n    //circle\n    //if(screenDist/splatCutoffSize > splatCutoffSize){retColor = black;}\n    \n    if (result > threshold){\n        retColor = paintColor;\n    }else{\n        retColor = defaultColor;\n    }\n \n    \n\treturn retColor;\n}\n\n\n\nfloat closestTOnLine(vec2 p, vec2 a, vec2 b){\n    vec2 ap = p - a;\n    vec2 ab = b - a;\n    //Squared magnitude of ab\n    float atb2 = ab.x*ab.x + ab.y*ab.y;\n    \n    float ap_dot_ab = ap.x*ab.x + ap.y*ab.y;\n    \n    //Normalized distance from a to closest point\n    float t = ap_dot_ab / atb2;\n\n    t = min(max(t,0.0), 1.0);\n    \n    return t;    \n}\n\nvec2 closestPointToLine(vec2 p, vec2 a, vec2 b, float t){\n    vec2 ap = p - a;\n    vec2 ab = b - a;\n    \n    return a + ab * t;\n}\n\n\n\n//Get color based on distance from two splat centers\n//1 - get distance to the line\nvec4 getOneStreak(vec2 center1, vec2 center2, vec4 paintColor1, vec4 paintColor2, vec2 fragCoord, vec2 uv){\n     \n    //T is distance from A to B  (1 to 2) from 0 to 1\n    float t = closestTOnLine(fragCoord, center1, center2);\n    \n    vec2 closestPoint = closestPointToLine(fragCoord, center1, center2, t);\n     \n    float alphaLerp = mix(paintColor1.w, paintColor2.w, t);\n    \n    //updated\n    float adjFalloff = alphaLerp;\n    float newAlpha = 1.0;\n    float fadePoint = .3;\n    \n    if(alphaLerp < fadePoint){\n        newAlpha = alphaLerp;\n    }\n    \n    vec4 passPaint = vec4(paintColor1.xyz, newAlpha);\n    \n    if(inRange(closestPoint,fragCoord, splatCutoffSize)){\n        //return vec4(255.0, 0.0, 255.0, 1.0);\n        return splatColor(closestPoint, passPaint, fragCoord, uv, adjFalloff);\n    }\n    \n    return defaultColor;\n    \n   \n}\n\n\n\n\n//Return the color at a point, (0,0,0) alpha 0 by default\n\nvec4 getSplatColorAtPixel(vec2 fragCoord, vec2 uv){\n    vec4 c1 = vec4(255.0, 0.0, 0.0, 0.0);\n    vec4 c2 = vec4(255.0, 0.0, 0.0, .3);\n    \n    \n    vec4 c3 = vec4(0.0, 0.0, 255.0, .5);\n    vec4 c4 = vec4(.0, 0.0, 255.0, 1.);\n    \n    vec2 s1 = vec2(100.0,100.0);\n    vec2 s2 = vec2(300.0,300.0);\n    \n    vec2 s3 = vec2(100.0,300.0);\n    vec2 s4 = vec2(500.0,100.0);\n    \n    vec4 retColor = defaultColor;\n    \n    retColor = overlayColors(retColor, getOneStreak(s1, s2, c1, c2, fragCoord, uv));\n    retColor = overlayColors(retColor, getOneStreak(s2, s4, c3, c4, fragCoord, uv));\n    \n    \n    \n    \n    return retColor;\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord){\n\n    // uv are screen coordinates, uniformly scaled to go from 0..1 vertically\n\tvec2 uv = fragCoord.xy / iResolution.yy;\n    \n    // scroll a certain number of screenfuls/second\n    uv.x += iTime * 0.2;\n    \n    //splatColor(s1, fragCoord, uv, c1);\n    vec4 dotColor = getSplatColorAtPixel(fragCoord,uv);\n    \n    //Alpha blending - replace black w Result from textures\n    vec4 result = overlayColors(dotColor, defaultColor);\n    \n    //vec2 temp = glGet(\"GL_VIEWPORT\");\n    \n    fragColor = result;\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/fdfSDB.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "fdfSDH", "name": "Turning space inside out", "author": "tdhooper", "description": "A quick demo of the transformation used in my animation, Inside, the new Outside! [url]https://twitter.com/tdhooper/status/1378746948136624128[/url]", "tags": ["4d", "inversion"], "likes": 41, "viewed": 946, "date": "1618532799", "time_retrieved": "2024-06-20T20:36:53.387197", "image_code": "/*\n\n    Turning space inside out\n    ------------------------\n\n    A quick demo of the transformation used in my animation,\n    Inside, the new Outside!\n    \n    https://twitter.com/tdhooper/status/1378746948136624128\n    \n    This is a bit like sphere inversion, but we can transition\n    from un-warped, to warped. It works by doing a stereographic\n    projection to and from 4d, and performing a rotation in 4d.\n    \n    I think this is called a möbius transformation, there are\n    some similar examples by Daniel Piker, along with code for\n    other environments:\n    \n    https://twitter.com/KangarooPhysics/status/1292180181185179648\n    https://spacesymmetrystructure.wordpress.com/2008/12/11/4-dimensional-rotations/\n\n    I got the stereographic projection code, and the general\n    approach for this from Matthew Arcus, who's made a lot of\n    amazing 4d shaders:\n    \n    https://www.shadertoy.com/view/lsGyzm\n    \n*/\n\n//#define SHOW_DISTANCE\n#define FIX_DISTANCE\n\n#define PI 3.14159265359\n\n// HG_SDF\nvoid pR(inout vec2 p, float a) {\n    p = cos(a)*p + sin(a)*vec2(p.y, -p.x);\n}\n\n// https://iquilezles.untergrund.net/www/articles/distfunctions/distfunctions.htm\nfloat sdBoundingBox( vec3 p, vec3 b, float e )\n{\n       p = abs(p  )-b;\n  vec3 q = abs(p+e)-e;\n  return min(min(\n      length(max(vec3(p.x,q.y,q.z),0.0))+min(max(p.x,max(q.y,q.z)),0.0),\n      length(max(vec3(q.x,p.y,q.z),0.0))+min(max(q.x,max(p.y,q.z)),0.0)),\n      length(max(vec3(q.x,q.y,p.z),0.0))+min(max(q.x,max(q.y,p.z)),0.0));\n}\n\n// mla https://www.shadertoy.com/view/lsGyzm\nvec4 inverseStereographic(vec3 p) {\n  float k = 2.0/(1.0+dot(p,p));\n  return vec4(k*p,k-1.0);\n}\nvec3 stereographic(vec4 p4) {\n  float k = 1.0/(1.0+p4.w);\n  return k*p4.xyz;\n}\n\nstruct Model {\n    float d;\n    vec3 col;\n};\n\nModel scene(vec3 p) {\n    vec3 col = normalize(p) * .5 + .5;\n    float d = sdBoundingBox(p, vec3(.9), .2);\n    return Model(d, col);\n}\n\nModel sceneWarped(vec3 p) {\n\n    float f = length(p);\n\n    // Project to 4d\n    vec4 p4 = inverseStereographic(p);\n    \n    // Rotate in the 4th dimension\n    pR(p4.zw, -iTime);\n    \n    // Project back to 3d\n    p = stereographic(p4);\n    \n    Model model = scene(p);\n    \n    // When we're inside out, the entire universe gets collapsed\n    // into the middle of the scene, causing a lot of raymarching\n    // understepping and overstepping.\n    // This ia a rough attempt at fixing this, there's still a bit\n    // of overestimation in places so the raymarch loop is hacked\n    // to accommodate it.\n    #ifdef FIX_DISTANCE\n        float e = length(p.xyz);\n        model.d *= min(1., 1. / e) * max(1., f);\n    #endif\n    \n    return model;\n}\n\nModel map(vec3 p) {\n    Model model = sceneWarped(p);\n\n    #ifdef SHOW_DISTANCE\n        float d = abs(p.y);\n        if (d < model.d) {\n            model.col = min(vec3(0, 1. / model.d, model.d), 1.) * fract(model.d * 10.);\n            model.d = d;\n        }\n    #endif\n\n    return model;\n}\n\n// compile speed optim from IQ https://www.shadertoy.com/view/Xds3zN\nvec3 calcNormal(vec3 pos){\n    vec3 n = vec3(0.0);\n    for( int i=0; i<4; i++ )\n    {\n        vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);\n        n += e*map(pos+0.0005*e).d;\n    }\n    return normalize(n);\n}\n\nmat3 calcLookAtMatrix(vec3 ro, vec3 ta, vec3 up) {\n    vec3 ww = normalize(ta - ro);\n    vec3 uu = normalize(cross(ww,up));\n    vec3 vv = normalize(cross(uu,ww));\n    return mat3(uu, vv, ww);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = (-iResolution.xy + 2. * fragCoord.xy) / iResolution.y;\n    \n    vec3 camPos = vec3(0,0,8);\n    \n    vec2 im = iMouse.xy / iResolution.xy;\n    \n    if (iMouse.x <= 0.) {\n        im = vec2(.6,.3);\n    }\n    \n    pR(camPos.yz, (.5 - im.y) * PI / 2.);\n    pR(camPos.xz, (.5 - im.x) * PI * 2.5);\n    \n    mat3 camMat = calcLookAtMatrix(camPos, vec3(0), vec3(0,1,0));\n    \n    float focalLength = 3.;\n    vec3 rayDirection = normalize(camMat * vec3(p.xy, focalLength));\n    \n    vec3 rayPosition = camPos;\n    float rayLength = 0.;\n    Model model;\n    float dist = 0.;\n    bool bg = false;\n    vec3 bgcol = vec3(.014,.01,.02);\n    vec3 col = bgcol;\n\n    for (int i = 0; i < 100; i++) {\n        rayLength += dist * .8; // fix overstepping\n        rayPosition = camPos + rayDirection * rayLength;\n        model = map(rayPosition);\n        dist = model.d;\n\n        if (abs(dist) < .001) {\n        \tbreak;\n        }\n        \n        if (rayLength > 15.) {\n            bg = true;\n            break;\n        }\n    }\n    \n    if ( ! bg) {\n        col = model.col;\n        vec3 nor = calcNormal(rayPosition);\n        col *= dot(vec3(0,1,0), nor) * .5 + 1.;\n        float fog = 1. - exp((rayLength - 6.) * -.5);\n        col = mix(col, bgcol, clamp(fog, 0., 1.));\n    }\n\n    col = pow(col, vec3(1./2.2));\n\n    fragColor = vec4(col,1);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/fdfSDH.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "fdfSR8", "name": "Morphing Basic", "author": "kithy", "description": "morphing,raymarching,anbient occlusion", "tags": ["raymarching", "morphing", "anbientocclusion"], "likes": 0, "viewed": 46, "date": "1618240197", "time_retrieved": "2024-06-20T20:36:53.393336", "image_code": "#define EPS 0.001\n#define MAX_DIST 64\n\nmat2 rot(float a){\n\tfloat s=sin(a);\n\tfloat c=cos(a);\n\treturn mat2(c,-s,s,c);\n}\n\nfloat sphere(vec3 p){\n\treturn length(p)-2.0;\n}\n\nfloat box(vec3 p,vec3 s){\n\tvec3 q=abs(p);\n\tvec3 m=max(s-q,0.0);\n\treturn length(max(q-s,0.0))-min(min(m.x,m.y),m.z);\n}\n\nfloat mainDist(vec3 p){\n\t//p=mod(p,8.0)-4.0;\n\tp.xy*=rot(iTime);\n\tp.yz*=rot(iTime);\n\tfloat a=sin(iTime*2.0)*0.5+0.5;\n\treturn mix(sphere(p),box(p,vec3(2.0)),a);\n}\n\nvec3 rayMarch(const vec3 eye,const vec3 ray,out float depth,out float steps){\n\tdepth=0.0;\n\tsteps=0.0;\n\tfloat dist;\n\tvec3 rp;\n\n\tfor(int i=0;i<MAX_DIST;i++){\n\t\trp=eye + depth*ray;\n\t\tdist = mainDist(rp);\n\t\tdepth+= dist;\n\t\tsteps++;\n\t\tif(dist<EPS)break;\n\t}\n\t\n\treturn rp;\n}\n\nvec3 genNormal(vec3 p){\n\treturn normalize(vec3(\n\t\tmainDist(vec3(p.x+EPS,p.y,p.z))-mainDist(vec3(p.x-EPS,p.y,p.z)),\n\t\tmainDist(vec3(p.x,p.y+EPS,p.z))-mainDist(vec3(p.x,p.y-EPS,p.z)),\n\t\tmainDist(vec3(p.x,p.y,p.z+EPS))-mainDist(vec3(p.x,p.y,p.z-EPS))\n\t));\n}\n\n\nvoid mainImage(out vec4 fragColor,in vec2 fragCoord){\n\tvec2 uv=(2.0*fragCoord.xy-iResolution.xy)/iResolution.y;\n\t\n\tvec3 ray=normalize(vec3(uv,1.0));\n\tvec3 camPos=vec3(0.0,0.0,-6.0);\n\n\tfloat depth=0.0;\n\tfloat steps=0.0;\n\tvec3 rp=rayMarch(camPos+EPS*ray,ray,depth,steps);\n\n\tfloat ao=steps*0.01;\n\tao=1.0-ao/(ao+0.5);\n\tfragColor=vec4(vec3(ao),1.0);\n\n\t// vec3 normal=genNormal(rp);\n\t// fragColor=vec4(normal*0.5+0.5,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/fdfSR8.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "fdfSRj", "name": "colored balanced isolines", "author": "FabriceNeyret2", "description": "Bottom: noise isovalues are not equidistant.\nTop: produce isolines by adding intermediate isovalues depending on slope.", "tags": ["procedural", "noise", "perlin"], "likes": 7, "viewed": 143, "date": "1618834533", "time_retrieved": "2024-06-20T20:36:53.666028", "image_code": "// color variant of   https://shadertoy.com/view/sdsXzB\n\n#define keyToggle(a) ( texelFetch(iChannel3,ivec2(a,2),0).x > 0.)\n#define hash(p )     ( 2.* fract(sin((p)*mat2(127.1,311.7, 269.5,183.3)) *43758.5453123) - 1. )\n#define draw(v,d)      clamp(1. - abs( fract(v) - .5 ) / fwidth(d), 0.,1.)\n#define hue(v)       ( .6 + .6 * cos( 6.3*(v)  + vec4(0,23,21,0)  ) )\n\n#define func( P )    ( mod(iTime,4.) > 2. ? perlin( .5*(P) ) : noise( P ) )\n//#define func( P )  ( keyToggle(32) ? perlin( .5*(P) ) : noise( P ) )\n#define grad(x,y)      dot( hash( i+vec2(x,y) ), f-vec2(x,y) )\n\nfloat noise( vec2 p )\n{\n    vec2 i = floor(p), f = fract(p), // u = f*f*(3.-2.*f);              // = smoothstep\n                                        u = f*f*f*( 10. +f*(6.*f-15.)); // better with derivatives\n    return mix( mix( grad(0,0), grad(1,0), u.x),\n                mix( grad(0,1), grad(1,1), u.x), u.y);\n}\n\nfloat perlin( vec2 U ) { // inspired from https://www.shadertoy.com/view/XdXGW8\n    float v = 0., s = .5;\n    mat2 m = mat2( 1.6,  1.2, -1.2,  1.6 );\n    for( int i=0; i<3; i++, s/=2., U*=m )\n        v  += s * noise( U ); \n    return v;\n}\n\nvoid mainImage( out vec4 O, vec2 u )\n{\n    vec2 R = iResolution.xy, eps = vec2(1e-3,0),\n         U = u / R.y,\n         P = 8.*U - vec2(0.,.5*iTime);\t\n    O-=O;\n\tfloat l, f = func(P), df;\n\n // l = exp2(floor(log2(2.*fwidth(P.x)/fwidth(f))));     // subvid amount (relative)\n    l = exp2(floor(log2(1./22./fwidth(f))));             // subvid amount (absolute)\n    O = (.5+.5*sin(50.*l*f)) * hue(l*f);\n\n}", "image_inputs": [{"id": "4dXGRr", "previewfilepath": "/presets/tex00.jpg", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/presets/tex00.jpg", "ctype": "keyboard"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/fdfSRj.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "fdfSz8", "name": "大龙猫 - Quicky#051", "author": "totetmatt", "description": "Practice on reflection + fractal like structure", "tags": ["quicky"], "likes": 5, "viewed": 167, "date": "1618245772", "time_retrieved": "2024-06-20T20:36:53.672112", "image_code": "#define fGlobalTime iTime\nmat2 rot(float a){float c=cos(a),s=sin(a);return mat2(c,-s,s,c);}\nfloat ball(vec3 p,float l){\n    return length(p)-l;\n}\n\nvec2 mmin(vec2 a,vec2 b){return a.x < b.x ? a:b;}\nfloat box(vec3 p,vec3 a){\n  vec3 q = abs(p)-a;\n   return length(max(vec3(0.),q)+min(0.,max(q.z,max(q.x,q.y))));\n  }\nvec2 ball1(vec3 p){ \n \n  vec2 d = vec2(10000.,-1.);\n   float c = 6.;\n  for(float i=0.;i<=c;i++){ \n       p= abs(p)-.200*i;\n        p.xz = p.x > p.z ? p.xz:p.zx;\n\n        p.xy *=rot(.754*i);      \n\n       p.xy = p.x > p.y ? p.xy:p.xy;\n        if(mod(i,2.)==1.){\n        d = mmin(d, vec2(ball(p+vec3(1.5*(1.+i/c),0.,.0),1.)/2.5,mod(i,2.)+1.0));\n        } else {\n          d = mmin(d, vec2(box(p+vec3(1.8+p.y*(1.+i/c),-0.5,.0),vec3(0.5,0.5,.6))/1.5,mod(i,2.)+1.0));\n          }\n     \n      \n    }\n    return d;\n\n}\nvec2 sdf(vec3 p){\n  p.zy *=rot(sin(fGlobalTime*.3)*.5);\n    p.xy *=rot(fGlobalTime*.1);\n  vec2 b1 = ball1(p);\n // p.zy *=rot(3.141591/4.+fGlobalTime);\n  p.y = abs(p.y)-.5;\n   p.x = abs(p.x)-.5;\n  vec2 aa =p.xy *rot(p.z*4.);\n  vec2 bb =p.xy *rot(p.z*8.);\n  \n    p.xy = mix(aa,bb,-1.5);\n    \n  for(float j=0.;j<=2.;j++) { p.yxz = abs(p.zyx)-.2; p.yx *=rot(1.3*j);};\n    \n     p.yz = p.z > p.y ? p.yz:p.yx;\n  vec2 b2 = vec2(box(p,vec3(.151)+vec3(.4,.0,.0))/4.9,3.);\n  return mmin(b1,b2);\n}\n  \n vec2 nv= vec2(.001,.0);\n  vec3 norm(vec3 p){\n      return normalize(vec3(sdf(p+nv.xyy).x-sdf(p-nv.xyy).x,sdf(p+nv.yxy).x-sdf(p-nv.yxy).x,sdf(p+nv.yyx).x-sdf(p-nv.yyx).x));\n    }\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\nvec3 col = vec3(.1);\n  vec3 ro = vec3(.0001,.0001,-2.1);\n  vec3 rd = normalize(vec3(uv,.6));\n  vec3 rp = ro;\n  float td =0.;\n  vec3 light = vec3(.01,.02,.03);\n  for(float i=0.;i<=69.*3.;i++){\n        vec2 d = sdf(rp);\n        rp += rd*d.x*.8;\n        td += d.x;\n        if(d.x<= 0.000001){\n           vec3 n = norm(rp);\n          float ld = length(light-rp);\n          if(d.y == 1.0){  \n           \n            col += vec3(0.2,.5,.5)*dot(normalize(light),n)*2./ld;\n            break;\n          } else if(d.y == 2.){\n              rd = reflect(rd,n);\n              rp += rd*0.01;\n            col +=vec3(.1,0.,0.);\n            }\n          else if(d.y == 3.){\n              rd = reflect(rd,n);\n              rp += rd*0.00001;\n            col +=vec3(.3,0.2,0.1);\n            }\n          }\n    }\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/fdfSz8.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "fdfXDH", "name": "Pablo", "author": "SnoopethDuckDuck", "description": "e", "tags": ["cool"], "likes": 1, "viewed": 60, "date": "1618535423", "time_retrieved": "2024-06-20T20:36:53.672112", "image_code": "float taxi(vec2 v) { return abs(v.x) + abs(v.y); }\n\nfloat random (vec2 st) {\n    return fract(sin(dot(st.xy,\n                         vec2(12.9898,78.233)))*\n        43758.5453123);\n}\n\nfloat f (float x) { return 16. * x * x * (1.-x) * (1.-x);}\n\nfloat func(vec2 uv, float t)\n{\nvec2 dir = uv - .5;\nfloat b = f(0.5 * (1. + cos(t)));\nfloat d = b *  f(fract(3.5 * length(dir))) + (1.-b) * f(fract(3.5 * taxi(dir)));\nd *=8. + 5. * cos(0.5 * t);\nfloat theta = atan(dir.y,dir.x);\n\nfloat b2 = 0.5 * (1. + cos(0.313 * t));\n   return (1.-b2) * (1. - smoothstep(d,-0.9,f(0.3 + 0.05 * cos(0.5 * t))))\n   + b2 * step(d,0.3 + 0.05 * cos(0.5 * t));\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.y - vec2( 0.375,0.);\n     \n      float t2 = 0.1 * iTime;\nuv -= 0.5;\n    uv = 0.5 + vec2(uv.x * cos(t2) - uv.y * sin(t2),\n    uv.x * sin(t2) + uv.y *cos(t2));\n     float t = iTime + 0.05 * random(uv);//vec2(floor(396. * uv)));\n\nfloat b = 0.5 * (1. + cos(.13149 * t));\n//float p = 2. * 3.14159 / 3.;\nfloat col = func(uv,t + 0.115 + 0.015 * b);\nfloat col2 = func(uv,t);\nfloat col3 = func(uv,t - 0.115 - 0.015 * b);\n\n\n\n    // Output to screen\n    fragColor = vec4(col,col2,col3,1.0);\n}\n\n\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/fdfXDH.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "fdfXWl", "name": "Magic Eye Hard Stepped", "author": "vsnchips", "description": "Checkerboard pattern procedural autostereogram", "tags": ["autostereogram"], "likes": 1, "viewed": 120, "date": "1619400975", "time_retrieved": "2024-06-20T20:36:54.744926", "image_code": "//////////////////////////\n\n//AutoStereogram Fragment Shader\n\nuniform sampler2D tHeightmap;\nuniform sampler2D tPattern;\n\nuniform float iYTile;\n\n\nbool sDisp = true;\nbool sPat = true;\n\n// Texture uniforms\nfloat iErr = 0.1;\nfloat iCmult = 3.;\nfloat iMmult  = 3.2;\nfloat iYmult = 2.6;\n\n// AutoStereogram key parameters - these ones make it work right\nfloat iCols = 10.;\nfloat iDMult = 0.015;\n//\n\nvec2 iOrigin = vec2(0.5);\nfloat itx = 1.;\nfloat ity = 1.;\n\n\n//varying vec4 vertColor;\n//varying vec4 vertTexCoord;\n\n\n#define PI 3.14159265359\n\n//out vec4 fragColor;\n\nvec2 iTranslate;\nfloat blue = 0.;\nfloat red = 0.;\n\nfloat green = 0.;\n\n/////////////////////\n\n//Audio uniforms\n\nuniform float[512] iSamples;\n\n////////////////////\n\n//STRUCTS\n\nstruct dispTrace\n{\n  vec4 samp;\n  float totaldisp;\n}theDTrace;\n\n\n\n\n////////////////////\n\n////////////////////\n\n//=============================================================================================================================================\n\n                      // Here, I define the texture to be mapped onto the shape.\n\n\nvec4 findCol(vec2 uv,float err){    // This casts an iteratively defined color pattern through a 2D binary search inspired algorithm\n  \n  vec4 rescol = vec4 ( 1.0,0.,1.0,1.0);\n  vec2 tlcnr = vec2(0.0); \n  vec2 brcnr = vec2(1.0);\n  vec4 tl = vec4 (1.,0.,0.,1.);\n  vec4 tr = vec4 (1.,0.,0.,1.);\n  vec4 bl = vec4 (1.,0.,0.,1.);\n  vec4 br = vec4 (1.,0.,0.,1.);\n\n  for (int i = 0; i < 32 ; i ++){\n\n  vec2 mid = tlcnr+0.5*(brcnr - tlcnr);\n\n    float cyan = fract(( tl.r + tr.r + bl.r + br.r)/iCmult)*0.5;\n    float magenta = fract(( tl.g + tr.g + bl.g + br.g)/iMmult)*0.5;\n    float yellow = fract(( tl.b + tr.b + bl.b + br.b)/iYmult)*0.5;\n\n    rescol = vec4(magenta+yellow,yellow+cyan,cyan+magenta,1.);\n\n    //if (abs(mid.x*0.2-uv.x)<err && abs(mid.y-uv.y)<err) break;\n    if (distance(vec2(mid.x*0.2,mid.y),vec2(uv.x*0.2,uv.y))<err) break;\n\n    if (uv.x>mid.x){\n      if (uv.y>mid.y){tlcnr = mid;\n          tl = rescol*1.3; tr = rescol; bl = rescol;} \n      else {tlcnr.x = mid.x;\n          brcnr.y = mid.y; tl = rescol; br = rescol; bl = rescol;}\n    }else{\n       if(uv.y>mid.y){tlcnr.y = mid.y; brcnr.x = mid.x;tl = rescol; tr = rescol; br = rescol;}\n        else {brcnr = mid; bl = rescol; tr = rescol; br = rescol;}\n    }\n\n   \n}\n   \n    //post processing tint\n\n    rescol.rgb =rescol.bgr;\n    //rescol.g=1-rescol.g;\n    rescol.g*=0.7;\n    return rescol;\n}\n\nvec4 getpattern(vec2 uv){\n\n   \n  // uv += iTime*0.01;\n\n   // add a constant displacement to hide the default column\n   /*\n   uv.x+=0.031*sin(uv.y*90.0);\n   uv.x+=0.01*sin(uv.y*300.0);\n   uv.x+=0.00031*sin(uv.y*1500.0);\n    */\n   \n   //return texture(iChannel0,uv);\n   return vec4( step(fract(uv.x*3.),0.5));\n\n}\n// =============================================================================================================================\n\n                                        //////////////////////////////////////////\n    \n                                        // Here is the working displacement method.\n                                    // Its slightly amazing how simple it is compared to the last one\n\n                                        //////////////////////////////////////////\n\n\nvoid dispCol(vec2 uv, vec2 origin){    // This one actually returns a color, in a struct with other stuff\n\n  float secwid = (1.0/iCols);\n  uv -= origin;\n  float chir = (uv.x < 0. ? -1. : 1.);\n  uv.x -= 0.5*chir*secwid;\n  float colwid = 1./iCols;\n \n// The loop's checking variables //                                                                                                                             \n  vec2 disp = uv;  \n  float thisD = 0.;\n\n//============================\nif (chir*disp.x>=0.){\n  for (int i = 0; i < 24; i++){        // The loop breaks dynamically. 24 tiles per side is heaps. Well need like 5\n   if (chir*disp.x<0.) break;\n\n    //Get the current displacement sample\n    vec2 transp = disp+iTranslate;\n   //thisD = texture(tHeightmap,transp).r;   \n    \n    //Post displacement sample transforms\n    float rotate = iTime*0.075;\n    transp = origin + mat2(cos(rotate),-sin(rotate), sin(rotate),cos(rotate)) * (transp);\n    \n    //Sample the heightmap\n    thisD = ( texture(iChannel1,transp).r  -0.75 )*3.;\n    thisD = step((0.5),fract(transp.x*5.) );\n    //smoothstep(fract(transp.y*5.),0.5,0.1) );\n\n    theDTrace.totaldisp += thisD;\n    \n    //step out the displacement\n    disp.x -= (1./iCols-thisD*iDMult)*chir;\n    \n    //visualse the step count\n    green++;\n\n}}\n//==============================\n\n  theDTrace.samp = getpattern(vec2(fract(disp.x*iCols),fract(uv.y))); \n}\n\n                              // And thats it. Magic eye is go.\n\n//====================================================================================================================================================\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord )\n\n{\n\t\n\ttheDTrace.totaldisp=0.;\n\ttheDTrace.samp=vec4(0.);\n\n\t//vec2 fragCoord = vertTexCoord.xy;\n\t//vec2 uv = vertTexCoord.xy - 0.5;\n    \n    vec2 uv = fragCoord.xy/iResolution.xy;//\n    \n    //1000.0;\n\t\n\tiTranslate = vec2(0.0);\n\tiTranslate = vec2(itx,ity);\n\n\tfloat subCeiling = 0.15;\n\n\tdispCol(uv,iOrigin);\n\nvec4 color = theDTrace.samp;\n\n\tif (sDisp){\n\t      //color = vec4(theDTrace.totaldisp*0.5); color.b=pow(-theDTrace.totaldisp*3.,2.);\n          //color.g=green*2.6;\n\t}\n\n\t//color = getpattern(uv.xy);\n    //color = texture(iChannel1,uv.xy);\n\n\tfragColor = color;\n\n}\n  \n", "image_inputs": [{"id": "Xdf3zn", "previewfilepath": "/media/ap/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/fdfXWl.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "fdj3Rd", "name": "lol1", "author": "YoussefVictor", "description": "colors", "tags": ["colors"], "likes": 1, "viewed": 26, "date": "1617826893", "time_retrieved": "2024-06-20T20:36:55.114813", "image_code": "const int k_gridW = 15;\nconst int k_gridH = 11;\nconst int k_phase = 0;\nconst float k_variationSpeed = 1.314f;\n\nuvec2 rvec;\nuint _george_marsaglia() {\n\trvec.x = 36969u * (rvec.x & 65535u) + (rvec.x >> 16u);\n\trvec.y = 18000u * (rvec.y & 65535u) + (rvec.y >> 16u);\n\treturn (rvec.x << 16u) + rvec.y;\n}\n\n//Random Functions\nfloat rand_float() {\n\treturn float(_george_marsaglia()) / float(0xFFFFFFFFu);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\t\n    float xx = uv.x * float(k_gridW);\n    float yy = uv.y * float(k_gridH);\n    // Time varying pixel color\n    int xi = int(xx);\n    int yi = int(yy);\n    \n    int gridCenterW = k_gridW / 2;\n    int gridCenterH = k_gridH / 2;\n    \n    int manhattanDistance = abs(xi - gridCenterW) + abs(yi - gridCenterH);\n    int k = manhattanDistance % k_phase;\n    float kf = float(k);\n    \n    //Initialize RNG\n    \n\trvec = uvec2(xx,yy);\n    float offset = float(int(rand_float()>0.5));\n    int pick = int((xx+yy+offset*iTime+iTime)) % 5;\n    \n    vec3 col = vec3(0.0);\n    switch(pick) {\n        case 0:\n            col = vec3(255.0/255.0,16.0/255.0,167.0/255.0);\n            break;\n        case 1:\n            col = vec3(228.0/255.0,255.0/255.0,0.0/255.0);\n            break;\n        case 2:\n            col = vec3(0.0/255.0,255.0/255.0,190.0/255.0);\n            break;\n        case 3:\n            col = vec3(0.0/255.0,161.0/255.0,253.0/255.0);\n            break;\n        case 4:\n            col = vec3(186.0/255.0,67.0/255.0,255.0/255.0);\n            break;\n    };\n    //vec3[5] colors = {,\n    //vec3(255.0/255.0,16.0/255.0,167.0/255.0),\n    //vec3(255.0/255.0,16.0/255.0,167.0/255.0),\n    //vec3(255.0/255.0,16.0/255.0,167.0/255.0),\n    //vec3(255.0/255.0,16.0/255.0,167.0/255.0)};\n    \n\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/fdj3Rd.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "fdj3WR", "name": "i hear you see me", "author": "eps", "description": "Title phrase, processed by text-to-image neural network, based on CLIP model => parameterized to CPPN and exported to GLSL with simple animation. \noriginal technique https://github.com/wxs/cppn-to-glsl", "tags": ["neuralnet", "cppn", "text2image"], "likes": 17, "viewed": 268, "date": "1617228540", "time_retrieved": "2024-06-20T20:36:56.223936", "image_code": "\n#ifdef GL_ES\nprecision lowp float;\n#endif\n\n#define N_HIDDEN 20\nvec4 bufA[N_HIDDEN/4];\nvec4 bufB[N_HIDDEN/2];\nvec4 cppn_fn(vec2 coordinate, float in0, float in1, float in2, float in3) {\n    vec4 tmp;\n    bufB[0] = vec4(coordinate.x, coordinate.y, 0., 0.);\n\n // layer 0 \nbufA[0] = vec4(-0.064, -0.265, 0.313, -0.359) + mat4(vec4(-0.185, 2.051, -2.551, 0.368), vec4(0.107, 1.129, -1.548, 1.436), vec4(0.000, 0.000, 0.000, 0.000), vec4(0.000, 0.000, 0.000, 0.000)) * bufB[0];\nbufA[1] = vec4(0.409, 0.286, -0.298, 0.195) + mat4(vec4(0.841, -1.540, 0.331, 0.704), vec4(0.506, -0.609, -0.292, -1.374), vec4(0.000, 0.000, 0.000, 0.000), vec4(0.000, 0.000, 0.000, 0.000)) * bufB[0];\nbufA[2] = vec4(-0.336, 0.342, 0.367, -0.068) + mat4(vec4(0.438, 2.463, 1.536, 0.028), vec4(0.367, -0.912, -1.780, -0.642), vec4(0.000, 0.000, 0.000, 0.000), vec4(0.000, 0.000, 0.000, 0.000)) * bufB[0];\nbufA[3] = vec4(-0.485, 0.288, 0.053, -0.242) + mat4(vec4(-0.641, -0.145, 0.221, -0.441), vec4(0.798, -1.467, -0.932, -1.098), vec4(0.000, 0.000, 0.000, 0.000), vec4(0.000, 0.000, 0.000, 0.000)) * bufB[0];\nbufA[4] = vec4(-0.079, 0.496, 0.008, -0.333) + mat4(vec4(-2.222, -1.068, -0.312, 1.542), vec4(1.672, -0.724, 0.276, 0.292), vec4(0.000, 0.000, 0.000, 0.000), vec4(0.000, 0.000, 0.000, 0.000)) * bufB[0];\ntmp = atan(bufA[0]);\nbufB[0] = tmp/0.67;\nbufB[5] = (tmp*tmp - 0.45) / 0.396;\ntmp = atan(bufA[1]);\nbufB[1] = tmp/0.67;\nbufB[6] = (tmp*tmp - 0.45) / 0.396;\ntmp = atan(bufA[2]);\nbufB[2] = tmp/0.67;\nbufB[7] = (tmp*tmp - 0.45) / 0.396;\ntmp = atan(bufA[3]);\nbufB[3] = tmp/0.67;\nbufB[8] = (tmp*tmp - 0.45) / 0.396;\ntmp = atan(bufA[4]);\nbufB[4] = tmp/0.67;\nbufB[9] = (tmp*tmp - 0.45) / 0.396;\n\n // layer 1 \nbufA[0] = vec4(0.126, -0.196, -0.353, 0.185) + mat4(vec4(-0.099, -0.115, 0.112, -0.122), vec4(0.429, 0.041, -0.306, -0.161), vec4(-0.068, -0.296, 0.313, 0.194), vec4(0.173, 0.096, -0.035, -0.015)) * bufB[0] + mat4(vec4(0.248, -0.020, -0.080, -0.017), vec4(-0.034, -0.198, 0.215, 0.131), vec4(0.236, -0.098, -0.379, -0.187), vec4(0.255, 0.057, 0.018, 0.377)) * bufB[1] + mat4(vec4(-0.130, -0.005, 0.046, -0.007), vec4(0.369, 0.047, 0.088, 0.218), vec4(0.060, 0.314, -0.082, 0.141), vec4(-0.055, 0.153, -0.282, 0.115)) * bufB[2] + mat4(vec4(-0.112, -0.271, -0.103, -0.143), vec4(0.147, 0.004, 0.235, 0.065), vec4(-0.185, 0.124, 0.049, 0.318), vec4(0.001, -0.213, -0.257, 0.123)) * bufB[3] + mat4(vec4(0.036, -0.186, -0.147, -0.071), vec4(-0.281, -0.163, 0.154, 0.383), vec4(-0.164, 0.055, 0.261, 0.007), vec4(0.030, -0.080, -0.131, -0.035)) * bufB[4] + mat4(vec4(0.013, 0.112, -0.115, -0.101), vec4(-0.345, -0.288, -0.078, 0.453), vec4(-0.255, 0.067, 0.095, 0.320), vec4(-0.142, 0.082, 0.155, 0.511)) * bufB[5] + mat4(vec4(0.227, 0.040, -0.202, -0.225), vec4(-0.168, -0.292, 0.259, 0.038), vec4(0.173, -0.082, -0.028, -0.194), vec4(0.086, -0.024, -0.154, 0.142)) * bufB[6] + mat4(vec4(-0.038, 0.078, 0.053, 0.129), vec4(-0.260, 0.128, 0.312, 0.377), vec4(-0.332, -0.069, 0.015, 0.248), vec4(0.351, 0.028, 0.069, 0.002)) * bufB[7] + mat4(vec4(-0.172, -0.019, -0.115, 0.198), vec4(0.107, 0.298, 0.227, 0.328), vec4(-0.039, 0.167, -0.001, -0.156), vec4(0.150, 0.156, 0.137, -0.031)) * bufB[8] + mat4(vec4(-0.679, -0.221, -0.210, -0.060), vec4(-0.085, -0.031, 0.426, 0.206), vec4(0.405, -0.056, 0.127, 0.175), vec4(-0.297, -0.349, -0.041, 0.081)) * bufB[9];\nbufA[1] = vec4(-0.013, -0.444, -0.040, 0.398) + mat4(vec4(-0.290, -0.005, 0.088, -0.135), vec4(0.047, 0.001, -0.370, -0.038), vec4(-0.290, -0.135, 0.399, 0.058), vec4(-0.120, -0.361, 0.080, -0.119)) * bufB[0] + mat4(vec4(-0.136, 0.002, -0.078, 0.059), vec4(0.121, 0.214, 0.336, -0.166), vec4(0.102, 0.070, -0.100, 0.400), vec4(0.019, 0.318, 0.005, 0.125)) * bufB[1] + mat4(vec4(0.336, -0.278, -0.191, -0.020), vec4(0.099, 0.224, 0.004, -0.019), vec4(0.001, 0.323, -0.197, 0.218), vec4(0.210, 0.220, 0.059, 0.052)) * bufB[2] + mat4(vec4(0.136, -0.274, 0.055, -0.349), vec4(0.145, 0.126, 0.240, 0.075), vec4(0.102, 0.032, -0.042, 0.214), vec4(-0.151, 0.131, 0.368, -0.045)) * bufB[3] + mat4(vec4(-0.046, -0.411, -0.096, 0.086), vec4(0.121, 0.014, 0.202, -0.286), vec4(0.223, -0.390, 0.010, -0.369), vec4(0.316, 0.164, -0.433, -0.067)) * bufB[4] + mat4(vec4(0.264, 0.075, 0.120, -0.102), vec4(-0.083, 0.050, -0.126, 0.439), vec4(0.249, 0.006, -0.120, 0.505), vec4(0.005, -0.100, 0.091, 0.355)) * bufB[5] + mat4(vec4(-0.298, 0.218, -0.283, -0.204), vec4(-0.082, -0.343, 0.012, 0.396), vec4(0.360, -0.190, 0.073, -0.070), vec4(0.001, -0.028, 0.444, -0.170)) * bufB[6] + mat4(vec4(-0.046, 0.114, 0.076, 0.012), vec4(-0.229, 0.167, -0.576, 0.021), vec4(0.005, 0.312, 0.203, -0.147), vec4(0.189, -0.061, -0.078, -0.144)) * bufB[7] + mat4(vec4(-0.222, -0.085, -0.336, -0.166), vec4(-0.191, 0.232, 0.060, -0.090), vec4(0.024, -0.025, 0.147, 0.064), vec4(-0.358, 0.033, -0.358, -0.191)) * bufB[8] + mat4(vec4(-0.099, 0.084, -0.296, -0.098), vec4(0.028, 0.155, 0.137, 0.207), vec4(0.098, -0.029, 0.113, -0.029), vec4(-0.065, -0.140, 0.090, 0.325)) * bufB[9];\nbufA[2] = vec4(0.171, -0.255, -0.360, -0.081) + mat4(vec4(0.111, -0.049, -0.295, -0.175), vec4(-0.293, 0.144, -0.099, -0.215), vec4(0.235, 0.074, 0.217, -0.136), vec4(0.123, 0.047, -0.325, 0.168)) * bufB[0] + mat4(vec4(0.002, -0.021, 0.052, 0.071), vec4(0.109, -0.118, -0.289, 0.208), vec4(-0.088, -0.376, 0.044, 0.201), vec4(0.099, -0.114, 0.260, -0.207)) * bufB[1] + mat4(vec4(-0.220, -0.018, -0.113, 0.298), vec4(-0.087, -0.029, 0.024, -0.190), vec4(-0.144, -0.465, 0.147, 0.024), vec4(0.121, -0.159, 0.339, -0.188)) * bufB[2] + mat4(vec4(0.003, 0.204, -0.135, 0.182), vec4(0.091, -0.095, 0.167, -0.231), vec4(0.175, 0.021, -0.001, -0.298), vec4(0.070, -0.149, 0.280, -0.308)) * bufB[3] + mat4(vec4(0.339, 0.140, 0.038, -0.059), vec4(0.278, -0.107, 0.142, 0.280), vec4(0.204, 0.404, -0.138, -0.063), vec4(-0.018, 0.064, -0.083, -0.226)) * bufB[4] + mat4(vec4(-0.066, -0.096, 0.090, -0.309), vec4(0.346, 0.166, -0.032, 0.120), vec4(0.302, 0.101, -0.058, 0.239), vec4(0.200, 0.129, -0.032, -0.333)) * bufB[5] + mat4(vec4(-0.158, 0.159, -0.139, -0.245), vec4(0.131, -0.134, -0.003, -0.042), vec4(-0.019, 0.056, 0.277, 0.089), vec4(0.102, -0.038, -0.195, -0.173)) * bufB[6] + mat4(vec4(0.003, -0.216, 0.431, 0.046), vec4(0.021, -0.195, -0.181, 0.272), vec4(-0.304, 0.061, -0.243, 0.187), vec4(-0.122, -0.158, 0.007, 0.207)) * bufB[7] + mat4(vec4(-0.112, -0.190, 0.381, 0.017), vec4(0.064, 0.359, -0.220, -0.159), vec4(0.193, 0.043, -0.096, 0.157), vec4(0.030, -0.088, 0.015, 0.154)) * bufB[8] + mat4(vec4(-0.219, 0.214, -0.327, 0.570), vec4(-0.123, 0.107, -0.049, -0.125), vec4(0.042, -0.026, -0.065, -0.138), vec4(0.245, 0.353, 0.158, 0.148)) * bufB[9];\nbufA[3] = vec4(-0.216, 0.027, -0.427, 0.285) + mat4(vec4(-0.138, -0.013, -0.245, -0.005), vec4(-0.098, -0.017, 0.195, -0.209), vec4(0.051, 0.126, -0.084, 0.455), vec4(-0.013, 0.116, 0.062, 0.212)) * bufB[0] + mat4(vec4(0.098, 0.158, 0.236, 0.109), vec4(0.136, 0.131, -0.090, -0.155), vec4(-0.087, 0.123, 0.046, 0.030), vec4(0.137, -0.106, -0.155, 0.008)) * bufB[1] + mat4(vec4(-0.063, 0.114, 0.246, 0.058), vec4(-0.249, -0.221, -0.021, -0.327), vec4(-0.035, 0.282, -0.121, 0.004), vec4(-0.341, -0.018, 0.140, 0.104)) * bufB[2] + mat4(vec4(-0.015, 0.064, -0.350, -0.160), vec4(-0.167, -0.129, 0.037, 0.045), vec4(0.247, -0.055, -0.032, -0.219), vec4(-0.043, -0.053, -0.025, -0.184)) * bufB[3] + mat4(vec4(0.140, -0.163, 0.040, 0.029), vec4(-0.210, 0.084, -0.137, -0.067), vec4(-0.163, -0.113, -0.176, 0.034), vec4(0.110, -0.020, 0.200, -0.398)) * bufB[4] + mat4(vec4(0.168, 0.112, -0.098, -0.140), vec4(0.093, -0.186, -0.006, -0.251), vec4(0.292, -0.223, 0.328, -0.172), vec4(0.066, 0.268, 0.114, 0.016)) * bufB[5] + mat4(vec4(0.274, 0.177, 0.059, -0.110), vec4(0.031, 0.411, 0.034, -0.156), vec4(0.036, 0.014, -0.237, 0.189), vec4(-0.216, -0.164, 0.252, 0.316)) * bufB[6] + mat4(vec4(0.204, 0.018, -0.089, 0.441), vec4(-0.392, 0.153, -0.038, 0.121), vec4(-0.209, -0.240, 0.244, -0.027), vec4(-0.069, -0.138, -0.064, 0.182)) * bufB[7] + mat4(vec4(-0.295, 0.177, 0.001, 0.059), vec4(-0.148, 0.147, -0.005, -0.280), vec4(0.050, 0.029, 0.001, 0.118), vec4(0.316, 0.018, -0.101, 0.102)) * bufB[8] + mat4(vec4(-0.011, -0.214, 0.229, 0.138), vec4(0.040, 0.282, -0.146, 0.110), vec4(-0.208, 0.210, 0.068, 0.324), vec4(0.217, -0.292, 0.037, 0.318)) * bufB[9];\nbufA[4] = vec4(-0.510, 0.422, 0.164, 0.286) + mat4(vec4(-0.182, 0.124, -0.210, -0.050), vec4(0.335, -0.155, 0.283, 0.121), vec4(0.021, -0.176, 0.063, 0.247), vec4(0.256, 0.347, -0.433, -0.169)) * bufB[0] + mat4(vec4(0.062, -0.056, 0.084, 0.184), vec4(-0.180, 0.031, 0.091, 0.168), vec4(-0.020, -0.046, 0.152, 0.147), vec4(0.098, 0.267, 0.058, -0.080)) * bufB[1] + mat4(vec4(0.000, 0.089, 0.054, -0.054), vec4(0.067, 0.264, -0.286, 0.218), vec4(-0.014, 0.038, -0.179, 0.266), vec4(-0.333, -0.142, 0.212, -0.141)) * bufB[2] + mat4(vec4(0.110, -0.076, -0.068, -0.151), vec4(0.039, 0.028, 0.331, 0.117), vec4(-0.244, -0.012, -0.120, 0.352), vec4(-0.143, 0.132, 0.251, -0.328)) * bufB[3] + mat4(vec4(-0.130, -0.171, 0.143, -0.120), vec4(-0.352, -0.172, -0.088, -0.031), vec4(0.189, 0.211, -0.195, -0.098), vec4(0.141, 0.166, 0.123, 0.044)) * bufB[4] + mat4(vec4(-0.160, -0.107, 0.204, -0.094), vec4(-0.084, 0.423, 0.071, -0.047), vec4(-0.077, 0.284, -0.082, 0.229), vec4(-0.046, -0.080, 0.138, 0.052)) * bufB[5] + mat4(vec4(-0.085, 0.102, -0.228, 0.134), vec4(-0.189, -0.059, -0.013, 0.180), vec4(-0.062, -0.150, -0.029, 0.191), vec4(-0.089, -0.041, 0.186, -0.239)) * bufB[6] + mat4(vec4(-0.038, -0.035, 0.031, -0.064), vec4(-0.513, 0.121, 0.125, -0.174), vec4(-0.078, -0.095, -0.080, -0.012), vec4(0.012, -0.276, -0.116, 0.016)) * bufB[7] + mat4(vec4(0.070, 0.050, 0.418, 0.057), vec4(0.093, 0.066, -0.001, -0.205), vec4(0.073, 0.119, 0.167, -0.050), vec4(-0.235, 0.133, 0.169, -0.307)) * bufB[8] + mat4(vec4(-0.184, 0.038, 0.110, -0.276), vec4(-0.212, 0.347, 0.082, -0.047), vec4(-0.163, -0.145, -0.284, -0.200), vec4(-0.088, 0.141, -0.037, 0.028)) * bufB[9];\ntmp = atan(bufA[0]);\nbufB[0] = tmp/0.67;\nbufB[5] = (tmp*tmp - 0.45) / 0.396;\ntmp = atan(bufA[1]);\nbufB[1] = tmp/0.67;\nbufB[6] = (tmp*tmp - 0.45) / 0.396;\ntmp = atan(bufA[2]);\nbufB[2] = tmp/0.67;\nbufB[7] = (tmp*tmp - 0.45) / 0.396;\ntmp = atan(bufA[3]);\nbufB[3] = tmp/0.67;\nbufB[8] = (tmp*tmp - 0.45) / 0.396;\ntmp = atan(bufA[4]);\nbufB[4] = tmp/0.67;\nbufB[9] = (tmp*tmp - 0.45) / 0.396;\n\n // layer 2 \nbufA[0] = vec4(0.353, -0.374, -0.257, 0.320) + mat4(vec4(0.047, -0.062, -0.028, -0.025), vec4(-0.161, 0.098, 0.198, 0.121), vec4(0.036, -0.092, -0.059, 0.036), vec4(0.589, 0.284, -0.165, -0.168)) * bufB[0] + mat4(vec4(0.041, 0.236, 0.184, 0.239), vec4(-0.243, -0.036, -0.188, -0.282), vec4(0.005, 0.108, -0.174, 0.126), vec4(0.261, 0.043, 0.040, 0.031)) * bufB[1] + mat4(vec4(0.168, -0.129, 0.009, 0.027), vec4(0.138, -0.234, 0.144, -0.114), vec4(0.082, 0.097, -0.042, -0.093), vec4(0.329, 0.043, -0.003, 0.016)) * bufB[2] + mat4(vec4(-0.049, 0.060, 0.240, -0.342), vec4(0.085, 0.025, 0.213, 0.032), vec4(-0.053, -0.033, 0.416, 0.100), vec4(0.007, 0.166, 0.219, 0.190)) * bufB[3] + mat4(vec4(-0.036, 0.163, 0.425, 0.217), vec4(0.002, -0.241, -0.040, 0.156), vec4(0.025, 0.097, -0.162, -0.115), vec4(-0.099, -0.036, -0.194, 0.282)) * bufB[4] + mat4(vec4(-0.232, -0.411, -0.232, 0.289), vec4(-0.062, -0.024, -0.151, 0.239), vec4(-0.178, -0.039, 0.304, 0.026), vec4(0.030, 0.140, 0.100, -0.081)) * bufB[5] + mat4(vec4(0.057, 0.205, 0.226, 0.147), vec4(0.510, 0.035, -0.184, 0.059), vec4(0.084, 0.186, 0.215, 0.074), vec4(0.034, 0.033, 0.164, -0.103)) * bufB[6] + mat4(vec4(-0.065, -0.112, -0.244, -0.086), vec4(-0.199, -0.033, -0.239, 0.253), vec4(0.112, -0.224, 0.227, -0.041), vec4(-0.017, -0.193, 0.186, -0.018)) * bufB[7] + mat4(vec4(-0.140, 0.131, -0.440, -0.242), vec4(-0.000, 0.010, 0.212, 0.209), vec4(-0.194, 0.310, 0.184, -0.118), vec4(-0.105, -0.189, 0.033, 0.175)) * bufB[8] + mat4(vec4(-0.262, -0.299, -0.021, -0.078), vec4(-0.027, -0.092, 0.099, -0.118), vec4(-0.222, -0.053, 0.139, 0.059), vec4(0.056, 0.072, -0.004, 0.087)) * bufB[9];\nbufA[1] = vec4(0.204, -0.433, 0.334, 0.494) + mat4(vec4(-0.077, 0.243, 0.013, -0.040), vec4(0.013, 0.174, 0.058, 0.049), vec4(-0.134, 0.083, -0.182, 0.030), vec4(-0.211, -0.135, -0.018, -0.192)) * bufB[0] + mat4(vec4(0.080, 0.139, -0.085, -0.008), vec4(-0.470, -0.203, -0.091, -0.155), vec4(-0.188, 0.035, -0.321, 0.133), vec4(0.009, -0.143, -0.058, -0.060)) * bufB[1] + mat4(vec4(0.083, -0.058, 0.120, 0.051), vec4(0.222, 0.032, -0.093, -0.071), vec4(0.065, 0.169, 0.172, -0.116), vec4(-0.035, -0.485, 0.116, -0.262)) * bufB[2] + mat4(vec4(0.407, 0.016, -0.027, -0.116), vec4(-0.038, -0.001, -0.150, -0.096), vec4(0.133, -0.115, 0.091, 0.012), vec4(-0.198, -0.260, -0.032, 0.030)) * bufB[3] + mat4(vec4(0.166, -0.021, -0.042, 0.387), vec4(-0.114, -0.166, -0.053, -0.059), vec4(-0.009, 0.111, 0.216, -0.138), vec4(-0.155, 0.185, 0.156, -0.165)) * bufB[4] + mat4(vec4(-0.120, 0.148, -0.124, -0.293), vec4(0.118, -0.057, 0.063, 0.138), vec4(-0.101, 0.095, -0.142, -0.367), vec4(-0.204, -0.109, -0.472, -0.132)) * bufB[5] + mat4(vec4(0.013, 0.278, -0.148, 0.070), vec4(-0.115, -0.193, -0.049, -0.255), vec4(0.330, -0.232, 0.133, -0.145), vec4(-0.304, 0.288, -0.216, -0.100)) * bufB[6] + mat4(vec4(0.083, 0.110, 0.351, 0.118), vec4(0.125, 0.040, -0.086, 0.402), vec4(-0.047, -0.040, -0.048, -0.177), vec4(-0.278, -0.170, -0.155, -0.064)) * bufB[7] + mat4(vec4(-0.299, -0.097, -0.105, 0.005), vec4(0.094, -0.168, -0.114, -0.235), vec4(0.149, -0.085, 0.004, 0.150), vec4(-0.029, -0.023, 0.277, -0.133)) * bufB[8] + mat4(vec4(-0.086, 0.093, 0.163, -0.445), vec4(-0.056, -0.194, -0.037, -0.092), vec4(0.179, 0.127, -0.120, 0.133), vec4(0.031, -0.195, 0.380, 0.210)) * bufB[9];\nbufA[2] = vec4(-0.352, -0.442, 0.103, 0.292) + mat4(vec4(-0.272, 0.271, 0.186, -0.428), vec4(0.012, 0.081, 0.089, -0.414), vec4(0.045, 0.138, -0.020, -0.173), vec4(0.204, 0.242, -0.057, 0.222)) * bufB[0] + mat4(vec4(-0.152, -0.068, -0.034, -0.232), vec4(-0.093, -0.000, -0.047, -0.275), vec4(-0.266, -0.524, 0.167, 0.519), vec4(0.315, 0.250, -0.189, -0.298)) * bufB[1] + mat4(vec4(0.292, 0.222, 0.123, 0.214), vec4(0.018, -0.112, -0.171, 0.033), vec4(0.216, -0.149, 0.142, -0.094), vec4(0.231, -0.000, 0.103, 0.117)) * bufB[2] + mat4(vec4(0.155, 0.093, 0.135, -0.063), vec4(0.079, -0.194, -0.031, -0.176), vec4(-0.080, -0.036, 0.200, -0.287), vec4(0.243, -0.294, -0.150, -0.133)) * bufB[3] + mat4(vec4(0.276, -0.009, -0.094, 0.029), vec4(0.095, 0.084, -0.109, -0.158), vec4(0.100, -0.211, 0.137, 0.221), vec4(0.059, -0.183, 0.068, 0.151)) * bufB[4] + mat4(vec4(-0.066, 0.192, -0.233, 0.118), vec4(0.169, -0.375, -0.162, -0.094), vec4(-0.060, 0.157, -0.154, -0.388), vec4(-0.323, -0.174, -0.427, 0.361)) * bufB[5] + mat4(vec4(-0.073, -0.266, -0.048, -0.119), vec4(0.035, -0.130, 0.482, 0.075), vec4(0.184, 0.204, 0.093, 0.012), vec4(0.077, 0.087, -0.617, -0.297)) * bufB[6] + mat4(vec4(0.146, -0.217, -0.088, -0.313), vec4(-0.257, -0.068, 0.192, -0.354), vec4(-0.199, -0.052, -0.126, 0.017), vec4(-0.022, 0.092, -0.079, -0.096)) * bufB[7] + mat4(vec4(-0.464, -0.442, 0.301, -0.327), vec4(0.173, 0.071, 0.074, -0.066), vec4(0.053, -0.324, -0.089, -0.015), vec4(-0.282, 0.091, -0.117, -0.250)) * bufB[8] + mat4(vec4(-0.105, 0.291, -0.040, -0.020), vec4(0.133, -0.191, -0.186, -0.126), vec4(-0.041, -0.121, 0.187, -0.043), vec4(-0.185, 0.367, 0.017, 0.056)) * bufB[9];\nbufA[3] = vec4(-0.132, -0.268, -0.173, -0.175) + mat4(vec4(-0.083, 0.078, -0.005, -0.046), vec4(-0.006, 0.110, -0.123, 0.366), vec4(0.025, 0.064, -0.053, 0.188), vec4(0.254, -0.033, -0.002, 0.100)) * bufB[0] + mat4(vec4(0.103, 0.079, 0.009, 0.059), vec4(0.086, -0.136, -0.305, 0.249), vec4(-0.023, -0.180, -0.012, -0.043), vec4(-0.230, 0.104, 0.136, 0.478)) * bufB[1] + mat4(vec4(0.044, -0.142, -0.127, -0.108), vec4(0.032, -0.298, 0.088, -0.022), vec4(-0.062, -0.181, 0.143, -0.071), vec4(-0.116, -0.026, 0.120, -0.021)) * bufB[2] + mat4(vec4(-0.082, 0.254, 0.137, 0.331), vec4(0.228, -0.024, -0.153, -0.083), vec4(0.004, 0.075, -0.008, 0.003), vec4(-0.044, 0.114, -0.095, 0.073)) * bufB[3] + mat4(vec4(-0.090, -0.229, -0.174, 0.066), vec4(0.029, -0.142, -0.348, 0.023), vec4(0.213, 0.247, -0.226, 0.082), vec4(-0.122, -0.055, 0.090, -0.266)) * bufB[4] + mat4(vec4(-0.194, -0.294, 0.045, -0.125), vec4(0.271, 0.030, 0.013, -0.057), vec4(0.065, -0.071, -0.084, 0.029), vec4(0.366, 0.155, -0.368, 0.290)) * bufB[5] + mat4(vec4(0.202, 0.079, 0.170, 0.145), vec4(-0.063, 0.109, 0.299, -0.321), vec4(0.185, -0.363, -0.115, 0.237), vec4(-0.088, 0.126, 0.152, -0.075)) * bufB[6] + mat4(vec4(0.196, 0.224, -0.024, -0.130), vec4(0.158, -0.221, 0.133, 0.173), vec4(-0.104, -0.222, 0.181, -0.191), vec4(-0.074, -0.134, 0.340, 0.071)) * bufB[7] + mat4(vec4(0.071, 0.187, -0.174, -0.190), vec4(0.098, 0.114, 0.094, -0.125), vec4(-0.289, 0.278, -0.125, 0.147), vec4(0.208, -0.048, 0.037, -0.036)) * bufB[8] + mat4(vec4(-0.025, 0.118, -0.182, 0.105), vec4(-0.040, 0.118, -0.022, 0.099), vec4(-0.084, 0.166, -0.172, 0.334), vec4(0.089, -0.086, -0.287, 0.099)) * bufB[9];\nbufA[4] = vec4(0.339, 0.354, 0.292, 0.343) + mat4(vec4(0.270, -0.233, 0.108, 0.343), vec4(0.072, -0.150, -0.143, -0.069), vec4(0.189, 0.112, -0.216, -0.069), vec4(-0.191, -0.002, -0.124, -0.123)) * bufB[0] + mat4(vec4(0.086, 0.140, 0.033, -0.103), vec4(-0.125, -0.187, -0.274, -0.081), vec4(0.237, -0.314, -0.483, 0.105), vec4(0.004, 0.237, 0.122, -0.105)) * bufB[1] + mat4(vec4(-0.207, 0.154, -0.008, 0.009), vec4(0.096, -0.097, -0.023, -0.104), vec4(0.120, -0.160, 0.088, 0.171), vec4(0.251, 0.280, 0.151, -0.147)) * bufB[2] + mat4(vec4(0.098, 0.037, 0.085, 0.096), vec4(0.017, -0.067, 0.169, 0.011), vec4(-0.302, 0.161, -0.023, -0.089), vec4(-0.005, 0.014, -0.105, -0.078)) * bufB[3] + mat4(vec4(-0.039, -0.051, 0.201, 0.376), vec4(-0.208, 0.218, 0.136, -0.033), vec4(-0.021, 0.093, 0.083, -0.028), vec4(0.073, -0.008, 0.033, -0.103)) * bufB[4] + mat4(vec4(0.053, 0.384, -0.123, -0.033), vec4(0.107, 0.535, -0.124, -0.130), vec4(0.016, 0.050, 0.275, 0.061), vec4(0.004, -0.012, 0.205, -0.024)) * bufB[5] + mat4(vec4(0.148, 0.180, -0.055, -0.188), vec4(-0.012, -0.133, -0.031, -0.168), vec4(-0.257, -0.005, 0.062, -0.105), vec4(0.308, -0.091, 0.418, -0.157)) * bufB[6] + mat4(vec4(-0.002, 0.284, 0.222, 0.209), vec4(0.055, -0.075, -0.055, -0.212), vec4(-0.061, -0.201, 0.121, -0.172), vec4(-0.077, 0.184, -0.122, -0.144)) * bufB[7] + mat4(vec4(0.085, 0.330, 0.262, -0.164), vec4(-0.040, -0.015, 0.043, -0.025), vec4(-0.128, 0.245, 0.070, 0.275), vec4(-0.190, 0.073, -0.182, -0.239)) * bufB[8] + mat4(vec4(0.194, 0.131, 0.124, 0.129), vec4(-0.100, -0.021, 0.120, -0.224), vec4(0.018, 0.284, 0.243, -0.168), vec4(-0.087, -0.046, 0.145, 0.056)) * bufB[9];\ntmp = atan(bufA[0]);\nbufB[0] = tmp/0.67;\nbufB[5] = (tmp*tmp - 0.45) / 0.396;\ntmp = atan(bufA[1]);\nbufB[1] = tmp/0.67;\nbufB[6] = (tmp*tmp - 0.45) / 0.396;\ntmp = atan(bufA[2]);\nbufB[2] = tmp/0.67;\nbufB[7] = (tmp*tmp - 0.45) / 0.396;\ntmp = atan(bufA[3]);\nbufB[3] = tmp/0.67;\nbufB[8] = (tmp*tmp - 0.45) / 0.396;\ntmp = atan(bufA[4]);\nbufB[4] = tmp/0.67;\nbufB[9] = (tmp*tmp - 0.45) / 0.396;\n\n // layer 3 \nbufA[0] = vec4(0.616, 0.547, -0.302, 0.071) + mat4(vec4(0.242, -0.133, -0.031, 0.088), vec4(-0.014, -0.117, -0.180, -0.148), vec4(-0.120, 0.017, -0.083, 0.071), vec4(0.423, 0.240, 0.035, -0.095)) * bufB[0] + mat4(vec4(0.042, -0.100, -0.154, 0.354), vec4(-0.307, 0.036, 0.065, -0.174), vec4(0.137, 0.090, 0.019, -0.136), vec4(0.164, 0.147, 0.268, -0.212)) * bufB[1] + mat4(vec4(-0.011, -0.245, 0.265, 0.148), vec4(-0.234, 0.021, -0.169, -0.122), vec4(0.107, 0.360, -0.050, 0.193), vec4(-0.018, -0.105, -0.250, -0.116)) * bufB[2] + mat4(vec4(0.094, -0.226, -0.151, 0.063), vec4(-0.191, -0.295, 0.168, -0.201), vec4(-0.368, 0.058, -0.028, 0.040), vec4(-0.086, -0.047, 0.336, -0.258)) * bufB[3] + mat4(vec4(-0.226, -0.136, 0.044, -0.044), vec4(-0.042, 0.121, 0.272, 0.032), vec4(0.392, 0.042, 0.156, -0.180), vec4(0.319, -0.064, -0.075, -0.329)) * bufB[4] + mat4(vec4(-0.245, 0.227, 0.193, 0.117), vec4(-0.370, -0.168, 0.164, 0.348), vec4(-0.001, -0.125, -0.077, -0.212), vec4(-0.360, 0.140, -0.097, 0.312)) * bufB[5] + mat4(vec4(0.271, 0.087, -0.149, 0.004), vec4(-0.257, 0.327, 0.043, 0.225), vec4(0.133, -0.164, 0.356, -0.096), vec4(0.224, 0.102, -0.063, -0.168)) * bufB[6] + mat4(vec4(0.037, 0.116, -0.016, 0.148), vec4(0.009, 0.157, 0.154, 0.158), vec4(-0.304, 0.053, 0.051, -0.133), vec4(0.291, 0.154, -0.084, -0.064)) * bufB[7] + mat4(vec4(0.005, -0.040, -0.138, 0.042), vec4(-0.113, 0.170, 0.181, 0.026), vec4(-0.264, 0.133, -0.051, 0.201), vec4(-0.103, 0.066, -0.025, -0.143)) * bufB[8] + mat4(vec4(-0.018, -0.278, 0.005, 0.030), vec4(-0.374, -0.281, -0.112, 0.183), vec4(-0.273, -0.018, 0.089, 0.012), vec4(-0.155, -0.197, -0.101, -0.425)) * bufB[9] + in0;\nbufA[1] = vec4(0.383, -0.409, 0.408, -0.365) + mat4(vec4(0.118, -0.105, -0.038, -0.255), vec4(-0.377, 0.066, -0.184, 0.053), vec4(0.336, -0.325, 0.032, 0.302), vec4(0.412, 0.093, -0.224, 0.219)) * bufB[0] + mat4(vec4(0.286, 0.065, -0.266, 0.506), vec4(-0.069, 0.024, 0.013, 0.350), vec4(0.391, 0.412, -0.108, -0.089), vec4(0.049, 0.247, -0.163, 0.131)) * bufB[1] + mat4(vec4(-0.073, 0.025, 0.086, 0.253), vec4(0.085, 0.041, 0.095, -0.133), vec4(0.115, -0.076, -0.521, 0.109), vec4(-0.166, 0.015, -0.006, -0.036)) * bufB[2] + mat4(vec4(-0.375, -0.062, 0.151, -0.383), vec4(-0.229, -0.003, 0.072, -0.228), vec4(0.388, -0.037, -0.251, -0.076), vec4(-0.325, -0.256, 0.202, -0.169)) * bufB[3] + mat4(vec4(0.354, -0.104, 0.197, 0.337), vec4(-0.052, 0.212, -0.170, 0.025), vec4(-0.045, -0.150, 0.588, -0.062), vec4(0.453, 0.109, 0.233, 0.429)) * bufB[4] + mat4(vec4(-0.260, -0.100, 0.250, -0.088), vec4(-0.223, -0.113, -0.143, 0.120), vec4(0.064, -0.144, 0.120, -0.157), vec4(0.162, 0.104, -0.019, 0.019)) * bufB[5] + mat4(vec4(-0.218, -0.214, -0.209, 0.029), vec4(-0.360, -0.127, -0.210, -0.124), vec4(0.281, -0.096, 0.055, -0.119), vec4(0.287, 0.068, -0.019, 0.310)) * bufB[6] + mat4(vec4(0.120, 0.043, 0.003, -0.110), vec4(-0.352, 0.040, -0.113, 0.314), vec4(0.074, 0.294, 0.120, -0.119), vec4(0.307, 0.236, 0.130, 0.148)) * bufB[7] + mat4(vec4(-0.446, 0.047, -0.216, -0.080), vec4(0.093, -0.108, -0.164, -0.099), vec4(-0.214, -0.124, -0.159, -0.142), vec4(0.234, -0.111, 0.309, 0.070)) * bufB[8] + mat4(vec4(-0.133, -0.222, 0.102, 0.012), vec4(0.205, -0.206, 0.098, -0.128), vec4(-0.109, 0.050, 0.139, 0.059), vec4(0.079, 0.364, -0.242, 0.128)) * bufB[9] + in1;\nbufA[2] = vec4(0.165, -0.039, -0.284, 0.401) + mat4(vec4(0.139, -0.070, -0.153, -0.044), vec4(0.409, -0.107, 0.135, -0.146), vec4(-0.186, 0.217, -0.243, 0.164), vec4(-0.125, 0.075, -0.068, 0.093)) * bufB[0] + mat4(vec4(0.110, -0.131, -0.392, 0.319), vec4(-0.043, 0.082, 0.192, -0.068), vec4(0.306, 0.279, -0.098, -0.180), vec4(0.196, -0.333, 0.072, 0.107)) * bufB[1] + mat4(vec4(0.384, -0.183, -0.018, 0.199), vec4(0.211, 0.482, -0.124, 0.244), vec4(-0.082, -0.096, -0.215, -0.379), vec4(-0.012, -0.052, 0.099, 0.116)) * bufB[2] + mat4(vec4(-0.062, 0.202, 0.039, -0.131), vec4(-0.053, -0.082, -0.192, -0.164), vec4(0.051, 0.172, 0.050, 0.305), vec4(0.226, -0.329, -0.309, -0.239)) * bufB[3] + mat4(vec4(-0.012, -0.053, 0.165, 0.186), vec4(-0.317, -0.078, -0.252, 0.182), vec4(-0.111, 0.456, -0.252, 0.149), vec4(-0.182, -0.137, 0.184, 0.097)) * bufB[4] + mat4(vec4(0.012, 0.152, 0.242, 0.291), vec4(0.142, -0.009, -0.173, 0.223), vec4(0.386, 0.037, -0.021, -0.042), vec4(-0.122, -0.132, 0.040, 0.102)) * bufB[5] + mat4(vec4(-0.025, 0.054, -0.053, -0.174), vec4(-0.017, -0.091, -0.073, 0.295), vec4(-0.353, 0.108, -0.013, -0.153), vec4(-0.104, -0.099, 0.147, -0.100)) * bufB[6] + mat4(vec4(-0.290, -0.000, 0.017, 0.171), vec4(-0.296, 0.084, -0.225, -0.032), vec4(-0.004, 0.118, 0.240, -0.362), vec4(-0.025, -0.133, -0.014, 0.124)) * bufB[7] + mat4(vec4(-0.068, 0.003, 0.155, -0.021), vec4(0.303, 0.125, -0.193, 0.105), vec4(-0.114, 0.103, -0.135, 0.096), vec4(0.121, -0.083, 0.041, -0.118)) * bufB[8] + mat4(vec4(-0.073, 0.016, -0.209, 0.046), vec4(0.083, -0.389, -0.089, -0.210), vec4(0.089, 0.192, -0.031, 0.113), vec4(-0.305, -0.067, -0.026, -0.006)) * bufB[9] + in2;\nbufA[3] = vec4(0.025, 0.348, 0.029, 0.272) + mat4(vec4(-0.322, -0.079, -0.177, -0.478), vec4(0.149, -0.039, -0.095, 0.006), vec4(0.034, 0.497, -0.219, -0.534), vec4(-0.160, -0.064, 0.199, 0.113)) * bufB[0] + mat4(vec4(0.003, 0.187, -0.167, -0.061), vec4(-0.130, -0.233, 0.004, 0.271), vec4(-0.243, 0.021, -0.066, 0.321), vec4(0.106, -0.098, -0.307, 0.047)) * bufB[1] + mat4(vec4(-0.227, -0.256, -0.148, -0.381), vec4(0.020, -0.157, -0.060, 0.308), vec4(0.275, -0.244, 0.003, 0.098), vec4(0.144, -0.014, -0.233, -0.143)) * bufB[2] + mat4(vec4(0.081, 0.089, 0.204, 0.032), vec4(-0.022, 0.017, -0.045, 0.278), vec4(0.162, 0.500, -0.007, -0.182), vec4(0.045, -0.030, 0.072, 0.129)) * bufB[3] + mat4(vec4(-0.265, -0.212, -0.150, -0.073), vec4(0.005, -0.121, -0.121, -0.029), vec4(-0.059, -0.045, -0.208, -0.190), vec4(0.096, -0.069, -0.150, 0.256)) * bufB[4] + mat4(vec4(0.017, -0.223, 0.252, 0.201), vec4(-0.003, 0.109, 0.277, -0.196), vec4(-0.119, -0.241, 0.388, 0.017), vec4(-0.032, 0.189, -0.015, -0.079)) * bufB[5] + mat4(vec4(-0.376, -0.087, -0.033, 0.116), vec4(0.088, -0.094, 0.008, 0.022), vec4(-0.155, 0.307, -0.066, 0.017), vec4(-0.212, -0.045, 0.219, 0.091)) * bufB[6] + mat4(vec4(0.177, -0.188, 0.086, 0.113), vec4(0.182, 0.010, 0.046, -0.142), vec4(-0.247, 0.059, 0.086, 0.010), vec4(-0.164, 0.245, -0.517, -0.226)) * bufB[7] + mat4(vec4(0.169, 0.152, -0.128, 0.023), vec4(0.027, -0.037, 0.111, 0.218), vec4(0.066, 0.047, 0.004, 0.074), vec4(-0.029, 0.333, 0.337, 0.043)) * bufB[8] + mat4(vec4(0.148, 0.167, -0.096, -0.221), vec4(0.267, -0.111, 0.060, 0.109), vec4(0.114, 0.046, 0.275, -0.229), vec4(-0.163, -0.034, -0.139, 0.268)) * bufB[9] + in3;\nbufA[4] = vec4(0.140, 0.423, 0.017, -0.496) + mat4(vec4(0.088, 0.039, 0.153, -0.106), vec4(-0.123, 0.022, 0.219, 0.060), vec4(-0.134, 0.245, -0.042, 0.127), vec4(0.051, 0.255, 0.197, -0.126)) * bufB[0] + mat4(vec4(-0.096, 0.009, 0.149, 0.091), vec4(-0.206, 0.047, -0.263, 0.299), vec4(0.138, -0.133, -0.007, -0.367), vec4(0.468, -0.108, 0.245, -0.204)) * bufB[1] + mat4(vec4(-0.115, -0.239, -0.184, -0.086), vec4(-0.320, -0.208, -0.078, 0.073), vec4(0.054, -0.092, 0.161, 0.111), vec4(0.133, 0.267, 0.237, 0.030)) * bufB[2] + mat4(vec4(-0.013, -0.114, 0.244, -0.044), vec4(0.025, -0.135, -0.011, -0.125), vec4(-0.065, -0.179, -0.186, 0.061), vec4(-0.085, 0.055, -0.193, 0.154)) * bufB[3] + mat4(vec4(0.130, 0.173, -0.010, 0.163), vec4(0.333, -0.453, -0.119, -0.122), vec4(-0.013, -0.111, 0.054, -0.313), vec4(-0.098, 0.072, 0.111, -0.049)) * bufB[4] + mat4(vec4(0.320, -0.119, 0.043, 0.092), vec4(-0.034, -0.006, -0.086, 0.399), vec4(0.199, -0.082, -0.152, 0.002), vec4(0.195, 0.036, -0.116, 0.249)) * bufB[5] + mat4(vec4(-0.062, 0.179, 0.186, 0.174), vec4(0.033, -0.019, 0.014, 0.237), vec4(-0.048, -0.059, -0.172, -0.065), vec4(-0.187, -0.147, -0.149, 0.298)) * bufB[6] + mat4(vec4(0.081, 0.022, -0.047, 0.238), vec4(0.170, -0.011, -0.071, -0.160), vec4(0.033, 0.113, -0.066, -0.068), vec4(-0.146, 0.087, 0.518, -0.285)) * bufB[7] + mat4(vec4(-0.221, -0.104, 0.038, 0.137), vec4(0.020, -0.173, 0.083, -0.165), vec4(0.222, -0.132, -0.041, -0.053), vec4(0.183, -0.012, -0.070, -0.015)) * bufB[8] + mat4(vec4(-0.208, -0.005, -0.117, 0.124), vec4(-0.158, 0.190, -0.154, -0.231), vec4(-0.383, -0.026, -0.078, 0.057), vec4(0.149, -0.009, -0.191, 0.357)) * bufB[9] + in0;\ntmp = atan(bufA[0]);\nbufB[0] = tmp/0.67;\nbufB[5] = (tmp*tmp - 0.45) / 0.396;\ntmp = atan(bufA[1]);\nbufB[1] = tmp/0.67;\nbufB[6] = (tmp*tmp - 0.45) / 0.396;\ntmp = atan(bufA[2]);\nbufB[2] = tmp/0.67;\nbufB[7] = (tmp*tmp - 0.45) / 0.396;\ntmp = atan(bufA[3]);\nbufB[3] = tmp/0.67;\nbufB[8] = (tmp*tmp - 0.45) / 0.396;\ntmp = atan(bufA[4]);\nbufB[4] = tmp/0.67;\nbufB[9] = (tmp*tmp - 0.45) / 0.396;\n\n // layer 4 \nbufA[0] = vec4(0.345, -0.186, -0.261, 0.189) + mat4(vec4(-0.175, 0.022, 0.246, -0.017), vec4(0.356, -0.268, 0.015, 0.035), vec4(0.035, 0.101, -0.103, 0.024), vec4(-0.289, -0.217, -0.386, -0.033)) * bufB[0] + mat4(vec4(0.081, 0.161, 0.128, 0.211), vec4(0.048, -0.163, 0.158, 0.045), vec4(-0.000, 0.162, 0.225, 0.265), vec4(-0.005, -0.192, 0.497, 0.331)) * bufB[1] + mat4(vec4(-0.159, 0.209, 0.058, -0.534), vec4(-0.114, -0.204, 0.095, 0.170), vec4(-0.072, 0.087, 0.430, -0.006), vec4(-0.108, 0.060, -0.051, 0.294)) * bufB[2] + mat4(vec4(-0.150, -0.032, -0.272, -0.002), vec4(0.040, -0.288, -0.215, 0.307), vec4(0.078, 0.264, -0.216, 0.215), vec4(0.201, -0.011, -0.076, 0.197)) * bufB[3] + mat4(vec4(0.654, -0.151, -0.014, 0.134), vec4(0.124, 0.075, 0.067, -0.147), vec4(0.241, -0.123, 0.350, -0.195), vec4(-0.106, 0.115, -0.234, 0.091)) * bufB[4] + mat4(vec4(0.224, 0.051, -0.014, 0.067), vec4(0.044, 0.018, -0.090, -0.103), vec4(-0.140, 0.011, 0.009, 0.038), vec4(-0.266, 0.109, -0.057, -0.154)) * bufB[5] + mat4(vec4(0.180, 0.059, 0.106, -0.126), vec4(0.189, 0.053, -0.063, 0.043), vec4(-0.240, 0.051, 0.123, 0.087), vec4(-0.071, -0.123, -0.308, 0.165)) * bufB[6] + mat4(vec4(-0.047, 0.099, -0.064, 0.022), vec4(0.232, -0.361, -0.096, 0.059), vec4(-0.242, 0.072, -0.205, -0.124), vec4(-0.046, -0.238, -0.119, 0.034)) * bufB[7] + mat4(vec4(0.125, 0.051, -0.021, 0.175), vec4(-0.274, 0.249, -0.222, 0.052), vec4(-0.216, -0.118, 0.114, 0.066), vec4(0.604, 0.374, -0.024, -0.140)) * bufB[8] + mat4(vec4(0.181, -0.231, -0.070, 0.079), vec4(0.086, -0.055, -0.019, 0.138), vec4(0.454, -0.312, 0.101, 0.032), vec4(-0.002, -0.039, 0.173, -0.081)) * bufB[9];\nbufA[1] = vec4(0.185, -0.132, -0.039, -0.132) + mat4(vec4(-0.161, -0.042, 0.283, -0.409), vec4(-0.137, 0.004, 0.101, -0.214), vec4(-0.047, 0.296, -0.110, 0.420), vec4(0.091, -0.298, 0.077, 0.133)) * bufB[0] + mat4(vec4(0.018, -0.179, -0.233, 0.126), vec4(-0.170, 0.068, -0.012, -0.360), vec4(0.032, -0.033, -0.358, -0.318), vec4(-0.320, 0.282, -0.033, 0.255)) * bufB[1] + mat4(vec4(0.278, -0.094, 0.008, -0.017), vec4(0.315, 0.129, -0.072, 0.081), vec4(-0.285, 0.186, -0.037, 0.016), vec4(0.113, 0.027, -0.677, 0.108)) * bufB[2] + mat4(vec4(-0.018, -0.024, 0.058, 0.312), vec4(0.088, -0.139, 0.133, 0.010), vec4(0.146, -0.022, -0.075, 0.159), vec4(-0.631, 0.021, 0.019, 0.079)) * bufB[3] + mat4(vec4(-0.047, -0.260, 0.469, -0.172), vec4(-0.022, -0.355, -0.064, -0.083), vec4(-0.223, 0.365, 0.320, -0.396), vec4(0.019, -0.197, -0.141, 0.046)) * bufB[4] + mat4(vec4(0.020, 0.161, 0.224, -0.125), vec4(0.031, 0.152, -0.036, 0.313), vec4(0.085, 0.120, 0.024, 0.308), vec4(0.102, -0.050, -0.016, -0.001)) * bufB[5] + mat4(vec4(0.006, 0.026, 0.194, 0.044), vec4(-0.209, 0.097, 0.122, 0.234), vec4(0.333, 0.042, 0.056, -0.048), vec4(0.007, -0.105, 0.166, -0.190)) * bufB[6] + mat4(vec4(0.114, -0.331, -0.218, -0.071), vec4(0.060, 0.023, -0.137, 0.057), vec4(0.079, -0.374, -0.054, 0.037), vec4(0.003, -0.491, -0.094, -0.258)) * bufB[7] + mat4(vec4(0.152, 0.261, 0.051, -0.054), vec4(0.171, -0.036, -0.034, 0.296), vec4(-0.235, 0.314, 0.065, -0.263), vec4(-0.229, 0.293, 0.128, 0.379)) * bufB[8] + mat4(vec4(-0.136, -0.339, -0.041, 0.017), vec4(0.176, -0.184, 0.144, 0.300), vec4(-0.032, -0.093, 0.234, -0.156), vec4(-0.053, -0.268, 0.019, -0.023)) * bufB[9];\nbufA[2] = vec4(-0.194, -0.579, -0.450, -0.249) + mat4(vec4(0.311, -0.123, -0.111, 0.163), vec4(0.023, 0.124, -0.147, -0.097), vec4(-0.150, 0.278, 0.303, -0.191), vec4(0.042, 0.009, 0.210, -0.070)) * bufB[0] + mat4(vec4(0.039, 0.023, -0.213, -0.007), vec4(0.216, 0.056, -0.248, -0.228), vec4(-0.049, -0.038, -0.158, 0.322), vec4(-0.156, 0.276, -0.172, -0.144)) * bufB[1] + mat4(vec4(0.356, 0.014, 0.312, -0.047), vec4(-0.418, 0.015, -0.324, 0.009), vec4(0.293, -0.015, -0.199, -0.320), vec4(0.043, 0.300, -0.343, 0.023)) * bufB[2] + mat4(vec4(-0.391, 0.313, 0.191, -0.138), vec4(0.127, 0.079, -0.243, 0.092), vec4(0.036, 0.137, 0.046, -0.303), vec4(-0.296, 0.042, 0.081, 0.276)) * bufB[3] + mat4(vec4(-0.115, -0.055, -0.034, 0.072), vec4(-0.002, 0.127, -0.088, -0.038), vec4(-0.092, -0.106, 0.093, 0.167), vec4(-0.241, 0.210, 0.024, -0.319)) * bufB[4] + mat4(vec4(0.034, -0.098, 0.202, 0.022), vec4(-0.180, 0.225, -0.047, 0.046), vec4(-0.028, 0.256, 0.294, -0.198), vec4(0.045, 0.171, -0.114, -0.144)) * bufB[5] + mat4(vec4(-0.224, -0.149, -0.094, 0.092), vec4(-0.335, -0.032, 0.071, 0.117), vec4(-0.013, -0.346, -0.186, 0.001), vec4(0.014, -0.067, -0.177, 0.164)) * bufB[6] + mat4(vec4(0.010, 0.002, 0.270, 0.137), vec4(-0.212, 0.187, -0.112, 0.204), vec4(0.025, 0.277, 0.102, -0.237), vec4(-0.123, 0.181, 0.003, -0.025)) * bufB[7] + mat4(vec4(-0.034, 0.224, 0.108, 0.011), vec4(0.235, -0.283, 0.006, -0.006), vec4(0.305, 0.103, -0.091, 0.068), vec4(-0.275, -0.053, -0.147, -0.191)) * bufB[8] + mat4(vec4(0.220, -0.123, 0.096, -0.265), vec4(-0.088, -0.071, -0.314, 0.257), vec4(0.256, -0.060, 0.213, 0.067), vec4(0.075, -0.078, 0.294, -0.250)) * bufB[9];\nbufA[3] = vec4(0.215, -0.397, -0.385, 0.529) + mat4(vec4(-0.193, -0.219, 0.183, 0.275), vec4(0.090, -0.214, -0.158, 0.195), vec4(-0.024, -0.098, -0.291, -0.071), vec4(0.493, -0.176, -0.052, 0.377)) * bufB[0] + mat4(vec4(0.260, -0.031, 0.232, 0.183), vec4(0.141, -0.146, 0.186, 0.113), vec4(-0.167, -0.108, 0.199, 0.136), vec4(-0.275, 0.134, 0.219, -0.139)) * bufB[1] + mat4(vec4(0.566, 0.086, 0.041, -0.145), vec4(-0.027, -0.298, 0.057, 0.114), vec4(-0.088, 0.023, 0.085, -0.282), vec4(0.063, -0.309, -0.381, -0.015)) * bufB[2] + mat4(vec4(0.035, -0.052, -0.151, 0.223), vec4(-0.091, 0.409, -0.131, 0.262), vec4(0.523, -0.149, -0.021, 0.336), vec4(0.045, -0.204, -0.206, -0.093)) * bufB[3] + mat4(vec4(0.283, -0.104, -0.171, 0.186), vec4(0.101, -0.064, -0.046, -0.317), vec4(0.117, -0.057, -0.006, -0.016), vec4(-0.078, 0.248, -0.044, -0.517)) * bufB[4] + mat4(vec4(-0.026, -0.022, 0.082, -0.085), vec4(0.068, -0.198, 0.042, -0.009), vec4(-0.055, 0.198, -0.136, -0.176), vec4(0.077, 0.208, 0.050, 0.070)) * bufB[5] + mat4(vec4(-0.302, -0.698, 0.216, 0.011), vec4(0.007, -0.287, 0.092, -0.104), vec4(-0.252, 0.106, 0.013, 0.078), vec4(-0.060, 0.154, -0.079, -0.098)) * bufB[6] + mat4(vec4(-0.051, -0.141, -0.278, 0.158), vec4(-0.002, 0.037, -0.097, 0.027), vec4(0.225, -0.056, -0.114, 0.093), vec4(0.383, -0.578, 0.021, 0.345)) * bufB[7] + mat4(vec4(-0.031, 0.080, 0.387, -0.098), vec4(-0.030, 0.080, -0.080, 0.240), vec4(0.036, 0.457, 0.183, -0.357), vec4(0.055, -0.140, -0.250, 0.239)) * bufB[8] + mat4(vec4(-0.056, -0.046, -0.144, 0.028), vec4(-0.246, 0.345, -0.013, -0.025), vec4(-0.009, 0.368, 0.088, -0.283), vec4(-0.165, -0.533, -0.049, 0.335)) * bufB[9];\nbufA[4] = vec4(0.456, 0.279, -0.193, 0.318) + mat4(vec4(-0.452, -0.266, -0.127, 0.354), vec4(0.317, -0.266, -0.011, -0.069), vec4(0.016, 0.277, 0.124, 0.140), vec4(-0.156, 0.173, 0.251, -0.110)) * bufB[0] + mat4(vec4(-0.461, 0.081, 0.134, -0.182), vec4(-0.188, 0.118, 0.091, -0.057), vec4(0.068, 0.102, -0.080, 0.138), vec4(-0.640, 0.279, -0.456, -0.084)) * bufB[1] + mat4(vec4(-0.120, -0.052, -0.275, -0.161), vec4(0.123, 0.108, 0.043, -0.102), vec4(0.016, -0.054, -0.011, 0.275), vec4(-0.315, -0.050, 0.195, -0.318)) * bufB[2] + mat4(vec4(0.114, 0.004, -0.184, -0.306), vec4(0.227, -0.012, -0.345, -0.214), vec4(-0.104, -0.328, 0.015, 0.016), vec4(-0.282, -0.312, -0.224, -0.176)) * bufB[3] + mat4(vec4(0.069, -0.090, 0.126, 0.274), vec4(0.207, 0.130, -0.140, 0.197), vec4(0.320, 0.129, -0.396, 0.230), vec4(0.083, -0.154, -0.159, -0.204)) * bufB[4] + mat4(vec4(0.141, -0.030, -0.084, 0.156), vec4(-0.116, 0.291, 0.065, 0.074), vec4(0.147, -0.033, -0.064, -0.157), vec4(-0.393, -0.002, 0.032, -0.250)) * bufB[5] + mat4(vec4(-0.279, -0.007, 0.136, 0.025), vec4(-0.006, -0.155, -0.071, 0.040), vec4(0.280, 0.131, 0.054, 0.126), vec4(0.535, -0.299, -0.369, 0.182)) * bufB[6] + mat4(vec4(0.037, -0.046, -0.214, -0.237), vec4(-0.162, 0.063, -0.042, 0.070), vec4(-0.342, -0.160, 0.094, -0.281), vec4(-0.129, 0.252, 0.072, -0.113)) * bufB[7] + mat4(vec4(-0.151, -0.065, -0.029, -0.083), vec4(0.448, 0.080, -0.005, 0.328), vec4(-0.312, -0.164, 0.039, 0.298), vec4(0.155, 0.221, 0.227, -0.007)) * bufB[8] + mat4(vec4(-0.018, 0.111, 0.288, -0.120), vec4(-0.032, -0.050, -0.336, -0.271), vec4(0.052, 0.067, -0.245, 0.307), vec4(0.371, -0.279, -0.078, -0.243)) * bufB[9];\ntmp = atan(bufA[0]);\nbufB[0] = tmp/0.67;\nbufB[5] = (tmp*tmp - 0.45) / 0.396;\ntmp = atan(bufA[1]);\nbufB[1] = tmp/0.67;\nbufB[6] = (tmp*tmp - 0.45) / 0.396;\ntmp = atan(bufA[2]);\nbufB[2] = tmp/0.67;\nbufB[7] = (tmp*tmp - 0.45) / 0.396;\ntmp = atan(bufA[3]);\nbufB[3] = tmp/0.67;\nbufB[8] = (tmp*tmp - 0.45) / 0.396;\ntmp = atan(bufA[4]);\nbufB[4] = tmp/0.67;\nbufB[9] = (tmp*tmp - 0.45) / 0.396;\n\n // layer 5 \nbufA[0] = vec4(0.571, 0.121, 0.490, -0.265) + mat4(vec4(0.151, 0.278, 0.309, -0.109), vec4(-0.017, 0.142, -0.278, 0.088), vec4(-0.237, 0.070, 0.111, -0.269), vec4(0.052, -0.104, 0.199, -0.052)) * bufB[0] + mat4(vec4(-0.158, -0.032, -0.053, 0.736), vec4(-0.038, 0.054, -0.251, -0.241), vec4(-0.480, 0.229, 0.010, 0.045), vec4(0.149, -0.082, 0.523, -0.172)) * bufB[1] + mat4(vec4(0.271, -0.329, 0.317, 0.280), vec4(-0.338, 0.145, -0.233, -0.037), vec4(-0.284, 0.195, -0.299, 0.283), vec4(0.154, 0.549, -0.190, 0.043)) * bufB[2] + mat4(vec4(0.074, 0.052, -0.279, 0.003), vec4(-0.231, -0.314, 0.097, -0.060), vec4(-0.017, -0.008, -0.243, 0.150), vec4(0.182, 0.218, 0.420, 0.021)) * bufB[3] + mat4(vec4(-0.280, 0.298, -0.025, 0.357), vec4(0.052, -0.046, 0.260, -0.329), vec4(0.109, 0.010, 0.434, 0.602), vec4(-0.335, 0.286, -0.106, 0.103)) * bufB[4] + mat4(vec4(-0.157, 0.083, 0.194, 0.097), vec4(0.213, 0.134, 0.019, -0.123), vec4(0.514, -0.166, 0.206, -0.156), vec4(-0.028, -0.146, 0.146, -0.172)) * bufB[5] + mat4(vec4(0.125, 0.083, -0.277, 0.199), vec4(0.204, -0.100, -0.076, 0.196), vec4(0.085, 0.185, -0.547, 0.063), vec4(0.146, 0.048, -0.038, 0.203)) * bufB[6] + mat4(vec4(-0.084, 0.053, 0.022, -0.213), vec4(-0.028, 0.159, -0.180, -0.012), vec4(-0.066, 0.019, 0.139, -0.100), vec4(-0.060, -0.041, 0.210, 0.141)) * bufB[7] + mat4(vec4(-0.411, -0.079, 0.113, -0.105), vec4(0.050, 0.007, 0.147, -0.144), vec4(-0.011, -0.145, -0.187, 0.416), vec4(0.041, 0.227, 0.027, 0.088)) * bufB[8] + mat4(vec4(-0.189, 0.435, -0.037, 0.091), vec4(-0.032, -0.138, -0.088, 0.107), vec4(0.091, 0.126, -0.034, 0.176), vec4(-0.316, 0.151, -0.296, -0.053)) * bufB[9];\nbufA[1] = vec4(0.042, 0.312, 0.274, 0.184) + mat4(vec4(0.121, 0.187, -0.049, 0.058), vec4(0.065, -0.014, 0.285, 0.230), vec4(-0.114, -0.445, 0.121, -0.151), vec4(-0.086, 0.016, 0.065, -0.086)) * bufB[0] + mat4(vec4(0.147, 0.063, 0.131, 0.312), vec4(-0.209, 0.276, 0.208, -0.030), vec4(-0.128, -0.184, -0.218, 0.164), vec4(0.107, 0.033, 0.386, 0.009)) * bufB[1] + mat4(vec4(-0.038, -0.012, -0.413, 0.061), vec4(-0.165, 0.176, 0.302, -0.177), vec4(0.114, 0.396, 0.158, -0.165), vec4(-0.028, 0.269, -0.324, 0.222)) * bufB[2] + mat4(vec4(0.160, 0.154, 0.300, -0.292), vec4(0.185, 0.051, -0.227, -0.285), vec4(-0.211, -0.324, -0.315, 0.199), vec4(0.080, 0.043, -0.009, 0.138)) * bufB[3] + mat4(vec4(-0.134, -0.108, 0.066, -0.168), vec4(-0.067, -0.084, 0.016, 0.104), vec4(0.101, -0.179, 0.201, 0.050), vec4(-0.025, -0.327, -0.249, -0.011)) * bufB[4] + mat4(vec4(0.022, -0.268, 0.074, -0.049), vec4(0.063, -0.016, -0.012, 0.269), vec4(-0.156, -0.170, -0.164, 0.124), vec4(0.008, 0.180, 0.396, -0.150)) * bufB[5] + mat4(vec4(-0.050, -0.035, 0.147, 0.076), vec4(-0.114, 0.080, -0.014, 0.019), vec4(-0.621, 0.051, -0.216, -0.193), vec4(0.116, -0.108, -0.443, 0.185)) * bufB[6] + mat4(vec4(0.013, 0.377, 0.083, -0.262), vec4(-0.286, 0.097, -0.062, 0.082), vec4(-0.194, -0.061, 0.258, -0.352), vec4(0.271, 0.055, -0.022, 0.023)) * bufB[7] + mat4(vec4(-0.090, -0.202, 0.200, -0.144), vec4(0.113, -0.125, 0.153, -0.024), vec4(-0.237, -0.115, -0.137, 0.032), vec4(0.059, -0.008, -0.234, 0.040)) * bufB[8] + mat4(vec4(-0.070, -0.110, 0.021, -0.172), vec4(0.205, -0.190, -0.444, 0.030), vec4(0.235, 0.047, 0.040, -0.332), vec4(-0.322, 0.099, 0.104, -0.085)) * bufB[9];\nbufA[2] = vec4(-0.075, 0.096, -0.191, 0.514) + mat4(vec4(-0.059, -0.226, 0.131, -0.027), vec4(-0.053, -0.643, -0.009, -0.057), vec4(-0.020, -0.500, -0.206, -0.113), vec4(-0.233, -0.069, -0.114, -0.228)) * bufB[0] + mat4(vec4(0.234, 0.018, 0.117, -0.397), vec4(0.098, 0.149, 0.048, -0.035), vec4(0.054, 0.000, 0.060, 0.312), vec4(0.001, -0.375, -0.308, 0.005)) * bufB[1] + mat4(vec4(0.354, 0.012, 0.289, -0.059), vec4(0.193, -0.027, -0.150, -0.252), vec4(-0.028, -0.021, -0.058, -0.099), vec4(0.010, 0.170, 0.307, 0.034)) * bufB[2] + mat4(vec4(0.143, -0.305, -0.153, 0.164), vec4(-0.014, -0.125, 0.002, -0.014), vec4(-0.067, -0.329, 0.002, 0.138), vec4(-0.044, -0.146, -0.403, 0.315)) * bufB[3] + mat4(vec4(0.157, 0.194, 0.017, 0.120), vec4(0.337, -0.013, -0.125, -0.214), vec4(-0.400, 0.066, -0.141, 0.143), vec4(0.176, -0.154, 0.189, -0.060)) * bufB[4] + mat4(vec4(0.283, -0.153, -0.118, 0.134), vec4(-0.214, -0.051, -0.062, 0.163), vec4(0.122, 0.145, 0.038, -0.287), vec4(-0.124, 0.127, -0.271, -0.236)) * bufB[5] + mat4(vec4(-0.057, -0.014, -0.150, -0.059), vec4(0.164, 0.247, 0.067, -0.001), vec4(-0.114, -0.010, -0.044, -0.185), vec4(-0.242, 0.129, 0.002, -0.173)) * bufB[6] + mat4(vec4(-0.106, 0.040, -0.079, 0.140), vec4(0.165, 0.050, -0.188, 0.053), vec4(0.053, 0.011, 0.150, 0.007), vec4(0.019, -0.106, -0.239, 0.012)) * bufB[7] + mat4(vec4(0.372, -0.210, 0.201, -0.016), vec4(-0.266, -0.035, -0.264, 0.217), vec4(0.081, 0.182, 0.078, -0.268), vec4(-0.198, 0.225, 0.237, 0.083)) * bufB[8] + mat4(vec4(0.069, -0.105, 0.140, 0.034), vec4(0.059, -0.032, -0.221, -0.061), vec4(0.164, 0.096, 0.280, -0.196), vec4(0.007, 0.292, 0.383, 0.136)) * bufB[9];\nbufA[3] = vec4(-0.089, -0.033, -0.381, -0.030) + mat4(vec4(0.287, 0.237, 0.204, 0.172), vec4(0.395, 0.074, -0.246, 0.051), vec4(0.100, -0.010, -0.172, -0.169), vec4(-0.158, 0.077, 0.145, 0.037)) * bufB[0] + mat4(vec4(-0.186, -0.197, 0.260, -0.280), vec4(0.224, 0.038, 0.475, 0.409), vec4(0.099, 0.165, 0.136, 0.251), vec4(0.167, 0.039, -0.249, 0.347)) * bufB[1] + mat4(vec4(-0.291, -0.104, -0.236, -0.097), vec4(0.295, 0.149, -0.158, 0.286), vec4(0.058, -0.271, -0.134, -0.182), vec4(0.069, -0.061, 0.104, -0.498)) * bufB[2] + mat4(vec4(-0.229, -0.152, 0.037, 0.141), vec4(0.167, -0.247, -0.514, -0.106), vec4(0.027, 0.089, 0.029, -0.323), vec4(0.010, 0.033, -0.112, -0.166)) * bufB[3] + mat4(vec4(-0.238, -0.066, 0.201, -0.317), vec4(-0.403, -0.245, 0.173, -0.072), vec4(-0.101, 0.081, -0.031, 0.110), vec4(0.002, -0.108, 0.126, 0.318)) * bufB[4] + mat4(vec4(0.145, 0.134, 0.081, 0.604), vec4(-0.254, 0.056, -0.105, 0.149), vec4(-0.067, -0.199, 0.292, -0.145), vec4(0.060, -0.231, -0.050, -0.033)) * bufB[5] + mat4(vec4(-0.136, 0.200, 0.498, 0.045), vec4(-0.048, 0.182, 0.015, -0.182), vec4(-0.068, 0.322, 0.103, 0.186), vec4(-0.152, -0.101, -0.060, -0.062)) * bufB[6] + mat4(vec4(-0.027, 0.312, 0.329, -0.143), vec4(-0.070, -0.181, -0.005, -0.343), vec4(0.301, 0.009, -0.287, -0.054), vec4(0.409, -0.204, -0.417, 0.124)) * bufB[7] + mat4(vec4(0.003, 0.036, -0.258, -0.161), vec4(-0.248, 0.004, -0.023, -0.030), vec4(0.225, -0.047, -0.254, -0.099), vec4(0.019, -0.185, -0.036, 0.506)) * bufB[8] + mat4(vec4(0.214, 0.177, 0.031, -0.339), vec4(0.018, 0.045, -0.198, 0.333), vec4(0.100, 0.021, -0.008, -0.363), vec4(-0.152, 0.252, 0.242, -0.006)) * bufB[9];\nbufA[4] = vec4(0.096, -0.384, 0.119, -0.309) + mat4(vec4(0.255, 0.160, 0.292, 0.125), vec4(-0.118, -0.103, 0.106, -0.134), vec4(-0.012, -0.101, 0.243, -0.117), vec4(-0.242, 0.126, -0.122, 0.021)) * bufB[0] + mat4(vec4(-0.150, -0.273, 0.188, -0.311), vec4(0.297, 0.243, -0.034, -0.195), vec4(0.175, -0.083, -0.542, 0.305), vec4(0.057, 0.030, 0.331, 0.102)) * bufB[1] + mat4(vec4(0.195, 0.124, -0.211, -0.308), vec4(0.232, -0.262, 0.124, 0.432), vec4(0.173, 0.009, 0.085, 0.349), vec4(0.169, 0.379, 0.243, 0.307)) * bufB[2] + mat4(vec4(0.050, -0.236, -0.318, -0.112), vec4(-0.094, 0.087, -0.050, 0.170), vec4(-0.167, -0.094, -0.112, -0.110), vec4(-0.024, -0.379, 0.361, -0.301)) * bufB[3] + mat4(vec4(-0.267, -0.422, -0.074, -0.035), vec4(0.122, -0.362, 0.086, 0.129), vec4(-0.175, -0.215, 0.264, -0.278), vec4(0.004, -0.020, -0.113, -0.142)) * bufB[4] + mat4(vec4(0.189, 0.042, 0.280, 0.346), vec4(0.054, -0.098, 0.066, 0.194), vec4(0.159, -0.096, -0.040, -0.054), vec4(0.186, -0.032, 0.138, 0.026)) * bufB[5] + mat4(vec4(-0.047, 0.017, -0.063, -0.422), vec4(-0.169, 0.172, -0.001, 0.240), vec4(0.377, -0.122, -0.335, 0.008), vec4(0.153, 0.011, 0.122, 0.030)) * bufB[6] + mat4(vec4(-0.085, -0.024, 0.249, 0.203), vec4(0.028, -0.101, 0.161, 0.028), vec4(-0.186, -0.240, -0.196, 0.082), vec4(-0.150, -0.039, -0.238, -0.023)) * bufB[7] + mat4(vec4(-0.039, -0.145, -0.090, 0.143), vec4(0.085, 0.112, -0.114, -0.130), vec4(0.070, 0.023, 0.048, 0.173), vec4(0.249, -0.129, 0.186, 0.237)) * bufB[8] + mat4(vec4(0.152, -0.047, -0.300, -0.125), vec4(-0.122, -0.055, -0.022, -0.050), vec4(-0.177, 0.207, -0.053, 0.008), vec4(-0.092, -0.053, -0.292, 0.242)) * bufB[9];\ntmp = atan(bufA[0]);\nbufB[0] = tmp/0.67;\nbufB[5] = (tmp*tmp - 0.45) / 0.396;\ntmp = atan(bufA[1]);\nbufB[1] = tmp/0.67;\nbufB[6] = (tmp*tmp - 0.45) / 0.396;\ntmp = atan(bufA[2]);\nbufB[2] = tmp/0.67;\nbufB[7] = (tmp*tmp - 0.45) / 0.396;\ntmp = atan(bufA[3]);\nbufB[3] = tmp/0.67;\nbufB[8] = (tmp*tmp - 0.45) / 0.396;\ntmp = atan(bufA[4]);\nbufB[4] = tmp/0.67;\nbufB[9] = (tmp*tmp - 0.45) / 0.396;\n\n // layer 6 \nbufA[0] = vec4(0.374, -0.247, 0.375, -0.496) + mat4(vec4(-0.314, 0.228, -0.029, -0.235), vec4(0.216, 0.090, 0.086, -0.610), vec4(-0.230, 0.028, 0.504, -0.309), vec4(0.007, 0.480, 0.224, -0.104)) * bufB[0] + mat4(vec4(0.087, 0.137, -0.012, 0.166), vec4(-0.265, 0.092, 0.037, 0.411), vec4(-0.144, -0.160, 0.062, 0.033), vec4(0.000, -0.123, 0.234, 0.150)) * bufB[1] + mat4(vec4(0.097, -0.123, 0.185, 0.160), vec4(-0.077, 0.010, 0.002, -0.253), vec4(0.025, 0.152, -0.035, 0.050), vec4(0.469, -0.077, -0.055, -0.007)) * bufB[2] + mat4(vec4(0.407, 0.027, -0.075, -0.101), vec4(0.119, -0.151, 0.065, -0.255), vec4(0.177, -0.329, 0.013, -0.470), vec4(-0.356, 0.025, -0.306, -0.182)) * bufB[3] + mat4(vec4(-0.003, -0.046, -0.157, -0.233), vec4(0.260, 0.363, -0.234, 0.132), vec4(-0.122, 0.300, -0.016, 0.203), vec4(-0.201, -0.030, 0.192, -0.024)) * bufB[4] + mat4(vec4(0.112, 0.044, -0.144, -0.034), vec4(0.112, -0.072, -0.313, 0.138), vec4(-0.087, -0.219, 0.240, 0.203), vec4(0.250, 0.365, 0.274, 0.021)) * bufB[5] + mat4(vec4(0.099, -0.045, -0.061, 0.292), vec4(-0.141, 0.234, 0.085, -0.035), vec4(0.065, 0.251, -0.282, -0.032), vec4(0.248, 0.090, -0.277, -0.090)) * bufB[6] + mat4(vec4(-0.081, -0.302, 0.173, 0.063), vec4(-0.293, -0.068, 0.256, 0.241), vec4(-0.145, -0.058, 0.191, -0.076), vec4(-0.251, -0.023, -0.014, 0.151)) * bufB[7] + mat4(vec4(0.085, 0.020, 0.019, -0.153), vec4(0.195, 0.131, -0.130, 0.097), vec4(0.169, 0.331, 0.315, 0.299), vec4(0.110, 0.120, -0.297, -0.281)) * bufB[8] + mat4(vec4(-0.447, -0.131, -0.351, -0.093), vec4(-0.083, 0.175, 0.143, 0.038), vec4(-0.086, -0.112, 0.027, -0.012), vec4(-0.398, 0.048, 0.218, 0.183)) * bufB[9];\nbufA[1] = vec4(0.078, -0.503, 0.292, -0.075) + mat4(vec4(-0.023, -0.484, -0.079, -0.158), vec4(-0.165, 0.079, -0.115, 0.233), vec4(0.025, -0.039, -0.485, 0.073), vec4(-0.309, 0.074, -0.036, 0.418)) * bufB[0] + mat4(vec4(0.032, 0.002, -0.420, 0.252), vec4(-0.177, 0.126, -0.068, -0.116), vec4(-0.024, -0.259, -0.253, 0.142), vec4(-0.288, 0.062, 0.052, 0.177)) * bufB[1] + mat4(vec4(-0.144, -0.255, -0.394, 0.055), vec4(-0.044, -0.206, 0.243, -0.180), vec4(0.089, 0.279, 0.300, 0.135), vec4(-0.417, -0.145, 0.182, -0.159)) * bufB[2] + mat4(vec4(-0.161, -0.224, -0.112, 0.041), vec4(-0.225, -0.231, 0.346, 0.099), vec4(-0.054, 0.010, 0.216, 0.016), vec4(-0.048, 0.187, -0.130, 0.082)) * bufB[3] + mat4(vec4(0.044, -0.158, 0.297, -0.087), vec4(-0.121, 0.038, 0.259, -0.234), vec4(-0.066, -0.120, -0.047, -0.103), vec4(-0.202, -0.116, 0.326, -0.002)) * bufB[4] + mat4(vec4(0.013, -0.154, -0.027, 0.011), vec4(0.106, -0.019, 0.052, -0.166), vec4(-0.202, -0.050, 0.041, 0.071), vec4(-0.097, 0.130, -0.055, -0.139)) * bufB[5] + mat4(vec4(0.082, -0.087, 0.320, -0.192), vec4(-0.110, 0.011, -0.031, 0.033), vec4(-0.202, -0.242, -0.118, -0.195), vec4(-0.313, -0.040, 0.057, -0.267)) * bufB[6] + mat4(vec4(0.019, -0.078, -0.217, 0.216), vec4(0.017, -0.025, -0.087, 0.312), vec4(0.177, -0.077, 0.152, 0.010), vec4(-0.127, 0.077, 0.073, -0.105)) * bufB[7] + mat4(vec4(-0.386, 0.124, 0.026, -0.033), vec4(-0.014, 0.042, -0.082, -0.323), vec4(0.495, 0.080, 0.013, 0.242), vec4(0.106, -0.006, 0.020, 0.123)) * bufB[8] + mat4(vec4(0.104, -0.093, -0.112, -0.283), vec4(0.085, 0.064, -0.164, -0.079), vec4(-0.100, 0.171, 0.275, -0.024), vec4(-0.200, -0.095, 0.100, 0.045)) * bufB[9];\nbufA[2] = vec4(0.201, -0.327, -0.126, 0.005) + mat4(vec4(-0.054, -0.072, 0.415, -0.389), vec4(0.066, 0.114, 0.392, -0.180), vec4(0.313, 0.021, -0.055, -0.045), vec4(-0.268, 0.011, 0.179, 0.034)) * bufB[0] + mat4(vec4(0.051, 0.036, 0.203, 0.122), vec4(-0.192, 0.080, -0.227, -0.193), vec4(0.141, -0.077, 0.014, -0.150), vec4(-0.049, 0.336, -0.253, 0.163)) * bufB[1] + mat4(vec4(0.308, 0.129, 0.665, 0.311), vec4(-0.413, -0.213, 0.173, 0.014), vec4(-0.121, -0.139, 0.329, 0.064), vec4(0.154, -0.032, 0.190, -0.229)) * bufB[2] + mat4(vec4(0.020, -0.106, -0.017, -0.029), vec4(-0.061, -0.077, 0.237, 0.153), vec4(0.090, -0.265, 0.001, -0.251), vec4(0.365, 0.044, -0.096, -0.024)) * bufB[3] + mat4(vec4(0.114, 0.044, -0.153, 0.003), vec4(0.060, -0.100, -0.017, 0.224), vec4(0.348, -0.373, -0.108, 0.014), vec4(-0.165, -0.087, 0.244, 0.244)) * bufB[4] + mat4(vec4(-0.034, -0.162, 0.185, -0.067), vec4(-0.178, 0.133, 0.126, 0.007), vec4(-0.308, -0.105, -0.020, 0.099), vec4(-0.137, -0.401, 0.357, 0.055)) * bufB[5] + mat4(vec4(0.204, 0.098, 0.444, 0.088), vec4(0.210, 0.337, -0.198, 0.148), vec4(-0.086, -0.007, 0.018, -0.124), vec4(-0.192, -0.209, 0.051, -0.094)) * bufB[6] + mat4(vec4(0.136, -0.250, -0.234, 0.133), vec4(-0.142, 0.206, 0.330, -0.268), vec4(-0.278, -0.050, 0.219, 0.069), vec4(0.294, -0.074, -0.228, -0.102)) * bufB[7] + mat4(vec4(0.092, -0.154, -0.119, 0.229), vec4(-0.117, 0.336, 0.035, -0.104), vec4(-0.016, -0.127, -0.438, 0.111), vec4(0.260, -0.263, -0.201, -0.079)) * bufB[8] + mat4(vec4(0.179, 0.410, -0.371, 0.135), vec4(-0.191, -0.012, 0.227, 0.034), vec4(-0.161, 0.372, -0.206, -0.142), vec4(-0.008, -0.247, 0.194, -0.203)) * bufB[9];\nbufA[3] = vec4(0.034, 0.117, 0.544, 0.533) + mat4(vec4(-0.019, -0.244, 0.224, -0.056), vec4(-0.031, 0.120, 0.216, 0.319), vec4(0.090, -0.414, -0.048, 0.139), vec4(0.167, -0.194, 0.263, -0.195)) * bufB[0] + mat4(vec4(-0.056, 0.529, -0.182, -0.031), vec4(-0.259, -0.003, 0.122, 0.023), vec4(0.091, -0.393, 0.051, -0.198), vec4(-0.253, 0.191, 0.259, -0.128)) * bufB[1] + mat4(vec4(0.178, -0.280, -0.600, -0.027), vec4(-0.010, -0.204, -0.177, -0.156), vec4(0.181, 0.062, 0.136, 0.118), vec4(0.061, 0.044, 0.263, 0.092)) * bufB[2] + mat4(vec4(0.184, 0.338, 0.145, 0.043), vec4(-0.172, 0.104, -0.173, 0.009), vec4(-0.191, -0.159, -0.048, -0.060), vec4(0.129, 0.406, -0.140, -0.272)) * bufB[3] + mat4(vec4(-0.201, 0.376, 0.033, 0.134), vec4(-0.179, 0.264, -0.275, -0.133), vec4(0.091, -0.152, -0.149, -0.111), vec4(-0.069, 0.015, -0.142, -0.085)) * bufB[4] + mat4(vec4(-0.038, -0.172, 0.256, 0.107), vec4(0.079, -0.098, 0.184, 0.263), vec4(0.031, -0.113, -0.356, -0.158), vec4(-0.104, -0.195, -0.058, 0.066)) * bufB[5] + mat4(vec4(-0.174, 0.442, 0.023, -0.158), vec4(-0.157, 0.117, -0.053, -0.040), vec4(-0.138, 0.116, 0.069, -0.256), vec4(-0.033, -0.229, -0.147, 0.049)) * bufB[6] + mat4(vec4(0.314, -0.137, 0.073, -0.013), vec4(0.112, 0.096, -0.005, 0.050), vec4(0.011, 0.006, 0.128, 0.029), vec4(0.117, -0.086, 0.098, -0.013)) * bufB[7] + mat4(vec4(-0.093, 0.476, 0.225, -0.117), vec4(0.219, 0.168, -0.149, -0.312), vec4(-0.019, -0.138, -0.251, -0.055), vec4(0.231, -0.033, -0.139, -0.029)) * bufB[8] + mat4(vec4(0.099, -0.088, 0.108, -0.047), vec4(-0.320, 0.215, -0.149, 0.100), vec4(0.072, -0.012, 0.085, 0.004), vec4(-0.028, 0.021, -0.101, 0.084)) * bufB[9];\nbufA[4] = vec4(0.051, 0.196, -0.250, 0.145) + mat4(vec4(-0.115, -0.062, -0.252, 0.053), vec4(0.040, -0.300, -0.097, -0.270), vec4(-0.136, 0.013, 0.124, -0.232), vec4(0.267, 0.128, 0.298, 0.198)) * bufB[0] + mat4(vec4(0.105, 0.255, 0.006, 0.189), vec4(-0.187, -0.086, -0.060, -0.298), vec4(0.039, -0.338, -0.092, 0.360), vec4(0.449, 0.180, 0.128, 0.023)) * bufB[1] + mat4(vec4(0.304, -0.116, 0.001, -0.316), vec4(0.394, -0.176, 0.189, -0.220), vec4(-0.233, -0.065, 0.149, 0.023), vec4(0.141, -0.194, 0.279, -0.300)) * bufB[2] + mat4(vec4(-0.027, -0.496, 0.045, -0.075), vec4(-0.046, -0.041, -0.042, 0.037), vec4(0.069, 0.201, 0.077, -0.014), vec4(0.026, -0.072, 0.543, -0.157)) * bufB[3] + mat4(vec4(-0.322, 0.179, -0.111, -0.183), vec4(-0.126, -0.116, 0.103, 0.498), vec4(-0.307, -0.147, -0.265, 0.104), vec4(-0.203, -0.247, 0.188, -0.161)) * bufB[4] + mat4(vec4(0.204, 0.200, 0.091, -0.070), vec4(0.013, 0.196, 0.253, 0.180), vec4(0.147, 0.117, -0.168, -0.094), vec4(0.203, -0.058, -0.100, -0.165)) * bufB[5] + mat4(vec4(0.089, -0.250, 0.138, 0.202), vec4(-0.138, -0.182, -0.042, -0.074), vec4(-0.073, -0.183, -0.192, 0.051), vec4(0.157, 0.043, -0.305, 0.149)) * bufB[6] + mat4(vec4(-0.131, -0.115, 0.117, -0.038), vec4(-0.057, -0.182, 0.088, -0.056), vec4(-0.015, -0.293, -0.233, -0.014), vec4(-0.289, 0.128, 0.017, -0.082)) * bufB[7] + mat4(vec4(0.150, 0.136, -0.210, 0.321), vec4(-0.113, 0.128, 0.098, 0.061), vec4(0.099, -0.261, 0.125, -0.314), vec4(-0.215, 0.441, 0.089, 0.090)) * bufB[8] + mat4(vec4(-0.387, 0.126, 0.024, 0.065), vec4(-0.127, -0.324, -0.116, 0.006), vec4(-0.015, -0.436, 0.179, -0.367), vec4(0.117, 0.221, 0.104, 0.079)) * bufB[9];\ntmp = atan(bufA[0]);\nbufB[0] = tmp/0.67;\nbufB[5] = (tmp*tmp - 0.45) / 0.396;\ntmp = atan(bufA[1]);\nbufB[1] = tmp/0.67;\nbufB[6] = (tmp*tmp - 0.45) / 0.396;\ntmp = atan(bufA[2]);\nbufB[2] = tmp/0.67;\nbufB[7] = (tmp*tmp - 0.45) / 0.396;\ntmp = atan(bufA[3]);\nbufB[3] = tmp/0.67;\nbufB[8] = (tmp*tmp - 0.45) / 0.396;\ntmp = atan(bufA[4]);\nbufB[4] = tmp/0.67;\nbufB[9] = (tmp*tmp - 0.45) / 0.396;\n\n // layer 7 \nbufA[0] = vec4(-0.609, -0.175, -0.679, 0.335) + mat4(vec4(0.243, -0.159, 0.056, -0.136), vec4(-0.253, 0.166, -0.037, -0.113), vec4(-0.354, 0.324, -0.068, 0.009), vec4(0.082, -0.112, 0.283, -0.211)) * bufB[0] + mat4(vec4(-0.439, -0.286, 0.249, 0.292), vec4(0.606, -0.164, 0.092, -0.289), vec4(-0.168, 0.349, 0.183, -0.031), vec4(-0.120, 0.231, 0.082, -0.249)) * bufB[1] + mat4(vec4(0.230, 0.043, 0.292, -0.160), vec4(0.144, 0.135, -0.202, -0.051), vec4(-0.067, 0.187, -0.424, -0.040), vec4(-0.119, 0.171, 0.357, 0.300)) * bufB[2] + mat4(vec4(0.220, -0.182, 0.019, -0.173), vec4(0.238, -0.202, 0.134, -0.119), vec4(0.174, -0.108, 0.535, -0.301), vec4(-0.140, 0.107, -0.006, 0.279)) * bufB[3] + mat4(vec4(-0.153, -0.285, 0.141, 0.382), vec4(-0.036, 0.005, -0.277, 0.040), vec4(0.069, 0.101, 0.103, 0.000), vec4(-0.005, -0.342, -0.285, -0.121)) * bufB[4] + mat4(vec4(-0.253, 0.230, 0.151, 0.173), vec4(0.135, -0.093, 0.310, 0.158), vec4(0.178, -0.041, -0.031, -0.007), vec4(-0.112, 0.109, 0.179, 0.085)) * bufB[5] + mat4(vec4(-0.017, -0.216, 0.049, 0.120), vec4(-0.259, -0.090, -0.176, -0.020), vec4(-0.007, -0.033, 0.016, 0.197), vec4(-0.168, -0.233, 0.109, -0.119)) * bufB[6] + mat4(vec4(-0.040, 0.061, 0.198, 0.224), vec4(0.362, 0.185, -0.031, -0.107), vec4(-0.028, -0.173, 0.141, 0.010), vec4(0.054, 0.005, 0.035, -0.107)) * bufB[7] + mat4(vec4(-0.016, -0.225, 0.196, -0.303), vec4(0.077, -0.258, -0.313, 0.148), vec4(-0.061, -0.350, -0.167, -0.027), vec4(0.212, 0.032, 0.023, 0.095)) * bufB[8] + mat4(vec4(0.111, 0.024, 0.019, -0.172), vec4(0.113, 0.153, -0.127, 0.115), vec4(-0.020, 0.191, -0.148, -0.426), vec4(0.125, -0.058, -0.139, 0.192)) * bufB[9];\nbufA[1] = vec4(0.658, 0.423, -0.180, -0.419) + mat4(vec4(-0.221, 0.354, 0.188, -0.172), vec4(-0.525, -0.026, 0.311, -0.238), vec4(0.287, 0.184, -0.067, 0.531), vec4(0.058, 0.400, -0.162, -0.214)) * bufB[0] + mat4(vec4(0.175, 0.238, -0.040, 0.193), vec4(-0.235, -0.151, 0.157, 0.204), vec4(-0.252, 0.481, -0.250, -0.133), vec4(0.109, -0.263, -0.051, 0.036)) * bufB[1] + mat4(vec4(0.045, 0.092, -0.335, -0.073), vec4(0.202, -0.340, -0.040, -0.379), vec4(0.060, 0.028, 0.095, 0.279), vec4(0.112, 0.108, -0.121, 0.032)) * bufB[2] + mat4(vec4(-0.035, 0.248, 0.098, 0.475), vec4(-0.460, 0.194, -0.058, 0.303), vec4(0.056, -0.140, 0.165, -0.148), vec4(0.037, -0.081, -0.044, 0.318)) * bufB[3] + mat4(vec4(0.175, -0.328, 0.314, 0.352), vec4(-0.154, -0.297, 0.344, 0.310), vec4(-0.107, -0.022, 0.203, -0.070), vec4(-0.075, -0.095, -0.179, 0.202)) * bufB[4] + mat4(vec4(-0.145, 0.109, 0.197, -0.168), vec4(-0.039, 0.019, -0.125, 0.118), vec4(-0.060, -0.112, 0.278, 0.437), vec4(0.187, -0.028, 0.222, 0.249)) * bufB[5] + mat4(vec4(-0.058, 0.089, 0.027, 0.394), vec4(0.144, 0.224, -0.391, -0.041), vec4(-0.199, 0.157, 0.225, -0.051), vec4(-0.284, -0.085, -0.136, -0.016)) * bufB[6] + mat4(vec4(-0.078, 0.098, 0.099, 0.303), vec4(0.165, 0.032, 0.023, -0.009), vec4(-0.052, -0.035, -0.035, 0.123), vec4(0.068, 0.218, -0.039, -0.109)) * bufB[7] + mat4(vec4(0.051, 0.189, -0.253, 0.203), vec4(-0.132, 0.078, -0.147, -0.253), vec4(-0.112, -0.175, -0.101, 0.104), vec4(-0.171, -0.098, -0.148, -0.007)) * bufB[8] + mat4(vec4(0.291, 0.121, 0.306, -0.120), vec4(0.100, -0.032, -0.001, -0.085), vec4(-0.195, -0.025, -0.111, -0.081), vec4(-0.117, -0.215, 0.090, 0.120)) * bufB[9];\nbufA[2] = vec4(0.111, -0.148, -0.370, -0.443) + mat4(vec4(0.386, -0.028, 0.127, -0.196), vec4(-0.027, -0.202, -0.063, 0.024), vec4(0.288, 0.082, -0.573, -0.272), vec4(0.455, -0.103, -0.013, 0.054)) * bufB[0] + mat4(vec4(-0.062, 0.013, -0.163, -0.043), vec4(0.064, -0.210, -0.045, 0.214), vec4(0.144, -0.058, -0.110, 0.155), vec4(0.141, -0.140, -0.159, -0.112)) * bufB[1] + mat4(vec4(0.469, -0.353, 0.266, 0.200), vec4(-0.067, -0.035, 0.124, 0.201), vec4(-0.085, 0.218, -0.039, -0.392), vec4(0.191, -0.068, 0.031, -0.081)) * bufB[2] + mat4(vec4(0.011, -0.013, 0.075, 0.201), vec4(-0.307, -0.086, 0.168, 0.243), vec4(-0.136, 0.317, 0.037, -0.167), vec4(0.208, -0.103, 0.006, -0.287)) * bufB[3] + mat4(vec4(0.358, 0.044, 0.027, -0.115), vec4(0.106, 0.125, 0.255, 0.106), vec4(0.272, 0.469, 0.139, 0.180), vec4(-0.261, 0.199, 0.189, -0.078)) * bufB[4] + mat4(vec4(0.291, -0.072, 0.007, -0.020), vec4(0.202, 0.040, 0.348, -0.023), vec4(0.602, 0.239, -0.069, -0.087), vec4(-0.112, -0.069, 0.426, -0.106)) * bufB[5] + mat4(vec4(-0.062, 0.011, -0.087, -0.147), vec4(-0.202, -0.252, 0.262, -0.073), vec4(0.365, 0.128, -0.031, -0.022), vec4(0.103, -0.202, 0.367, -0.139)) * bufB[6] + mat4(vec4(0.306, 0.123, -0.138, -0.565), vec4(0.249, -0.322, 0.308, 0.082), vec4(-0.006, -0.013, 0.539, -0.223), vec4(-0.475, -0.100, 0.128, -0.065)) * bufB[7] + mat4(vec4(-0.247, -0.127, -0.012, 0.116), vec4(-0.249, 0.016, -0.004, 0.080), vec4(-0.024, 0.226, -0.067, 0.101), vec4(0.375, -0.042, 0.118, -0.182)) * bufB[8] + mat4(vec4(-0.172, -0.070, -0.180, -0.167), vec4(-0.077, -0.095, 0.067, -0.282), vec4(-0.261, -0.003, -0.163, 0.073), vec4(-0.043, -0.010, 0.114, 0.003)) * bufB[9];\nbufA[3] = vec4(-0.237, -0.392, 0.550, -0.106) + mat4(vec4(0.108, 0.428, -0.265, 0.036), vec4(0.210, 0.248, -0.012, 0.157), vec4(-0.114, -0.167, -0.135, 0.306), vec4(0.185, 0.295, -0.257, 0.200)) * bufB[0] + mat4(vec4(-0.175, -0.008, -0.118, 0.099), vec4(0.084, 0.097, -0.017, -0.047), vec4(0.291, 0.280, -0.034, -0.210), vec4(0.096, 0.228, -0.436, 0.048)) * bufB[1] + mat4(vec4(0.001, -0.000, 0.153, 0.136), vec4(-0.150, 0.018, 0.325, 0.067), vec4(0.323, -0.213, -0.181, -0.041), vec4(0.053, -0.198, -0.357, -0.066)) * bufB[2] + mat4(vec4(0.069, -0.402, -0.017, 0.221), vec4(-0.306, 0.396, -0.269, -0.256), vec4(0.063, 0.147, 0.158, -0.316), vec4(-0.158, -0.265, -0.042, 0.158)) * bufB[3] + mat4(vec4(-0.070, 0.047, 0.227, 0.185), vec4(0.057, 0.074, -0.077, -0.066), vec4(0.366, -0.155, -0.278, -0.200), vec4(-0.098, 0.580, -0.017, -0.142)) * bufB[4] + mat4(vec4(0.109, 0.157, -0.336, 0.156), vec4(-0.187, -0.046, 0.172, 0.460), vec4(-0.206, -0.171, -0.182, -0.226), vec4(0.015, -0.126, 0.109, 0.038)) * bufB[5] + mat4(vec4(-0.124, -0.248, 0.087, -0.260), vec4(0.175, -0.063, -0.018, -0.013), vec4(0.131, 0.009, 0.074, 0.041), vec4(0.143, 0.301, 0.071, 0.133)) * bufB[6] + mat4(vec4(0.004, 0.021, -0.175, -0.465), vec4(-0.040, 0.006, 0.079, 0.233), vec4(0.062, 0.036, -0.016, -0.096), vec4(0.072, 0.153, 0.047, -0.136)) * bufB[7] + mat4(vec4(0.152, -0.333, 0.000, 0.185), vec4(-0.187, 0.331, 0.124, -0.148), vec4(-0.049, 0.038, -0.063, -0.001), vec4(0.060, 0.201, -0.128, -0.295)) * bufB[8] + mat4(vec4(-0.041, -0.278, 0.149, -0.032), vec4(0.080, -0.150, 0.306, 0.094), vec4(-0.250, 0.013, 0.237, -0.162), vec4(0.287, 0.198, -0.122, 0.019)) * bufB[9];\nbufA[4] = vec4(0.090, -0.640, -0.800, -0.553) + mat4(vec4(-0.033, 0.180, -0.005, 0.188), vec4(0.225, 0.331, -0.658, -0.151), vec4(0.248, -0.280, 0.095, -0.218), vec4(-0.032, 0.448, 0.150, -0.037)) * bufB[0] + mat4(vec4(0.188, 0.180, 0.394, -0.081), vec4(0.037, 0.256, -0.024, -0.192), vec4(-0.043, 0.157, 0.156, -0.069), vec4(0.152, -0.255, 0.244, 0.127)) * bufB[1] + mat4(vec4(0.169, 0.152, 0.476, -0.317), vec4(0.015, 0.182, -0.120, -0.058), vec4(0.213, -0.192, -0.011, -0.064), vec4(-0.228, 0.038, -0.102, 0.043)) * bufB[2] + mat4(vec4(-0.030, -0.188, 0.051, -0.163), vec4(0.609, 0.175, -0.171, -0.142), vec4(-0.038, -0.303, -0.048, 0.212), vec4(0.118, -0.478, -0.151, -0.021)) * bufB[3] + mat4(vec4(-0.033, -0.212, -0.302, 0.210), vec4(-0.117, 0.178, -0.511, -0.088), vec4(-0.039, -0.005, 0.029, -0.024), vec4(-0.296, 0.058, -0.125, 0.053)) * bufB[4] + mat4(vec4(-0.120, -0.047, -0.056, 0.096), vec4(0.050, 0.213, 0.277, 0.149), vec4(0.503, 0.141, 0.520, 0.147), vec4(-0.083, -0.224, 0.016, 0.048)) * bufB[5] + mat4(vec4(-0.233, -0.138, 0.154, -0.110), vec4(-0.242, -0.039, 0.121, 0.221), vec4(0.025, -0.032, -0.064, -0.254), vec4(-0.194, -0.044, 0.019, -0.146)) * bufB[6] + mat4(vec4(-0.077, -0.109, 0.177, -0.033), vec4(0.091, 0.298, -0.207, -0.009), vec4(-0.121, 0.044, -0.019, 0.033), vec4(-0.131, -0.191, -0.211, 0.041)) * bufB[7] + mat4(vec4(-0.131, -0.154, -0.070, -0.104), vec4(0.119, -0.076, -0.196, -0.287), vec4(0.261, -0.220, -0.177, 0.131), vec4(-0.069, 0.061, 0.023, -0.004)) * bufB[8] + mat4(vec4(0.014, 0.010, -0.129, -0.157), vec4(0.053, 0.150, -0.026, 0.101), vec4(-0.328, -0.026, 0.040, 0.043), vec4(-0.173, -0.005, 0.126, -0.090)) * bufB[9];\ntmp = atan(bufA[0]);\nbufB[0] = tmp/0.67;\nbufB[5] = (tmp*tmp - 0.45) / 0.396;\ntmp = atan(bufA[1]);\nbufB[1] = tmp/0.67;\nbufB[6] = (tmp*tmp - 0.45) / 0.396;\ntmp = atan(bufA[2]);\nbufB[2] = tmp/0.67;\nbufB[7] = (tmp*tmp - 0.45) / 0.396;\ntmp = atan(bufA[3]);\nbufB[3] = tmp/0.67;\nbufB[8] = (tmp*tmp - 0.45) / 0.396;\ntmp = atan(bufA[4]);\nbufB[4] = tmp/0.67;\nbufB[9] = (tmp*tmp - 0.45) / 0.396;\n\n // layer 8 \nbufA[0] = vec4(0.088, 0.466, -0.406, 0.415) + mat4(vec4(0.088, -0.260, -0.366, -0.163), vec4(-0.027, -0.247, 0.400, -0.258), vec4(-0.045, 0.106, 0.031, -0.324), vec4(-0.251, 0.349, 0.124, 0.424)) * bufB[0] + mat4(vec4(0.370, 0.155, 0.063, 0.108), vec4(0.242, -0.234, -0.307, 0.020), vec4(-0.464, 0.159, 0.220, 0.198), vec4(0.218, -0.197, -0.077, 0.016)) * bufB[1] + mat4(vec4(0.256, 0.293, -0.113, 0.015), vec4(0.041, -0.184, 0.159, -0.201), vec4(-0.084, -0.476, -0.049, -0.253), vec4(-0.159, -0.022, -0.633, 0.104)) * bufB[2] + mat4(vec4(-0.380, -0.222, 0.138, -0.282), vec4(-0.146, 0.104, 0.213, -0.288), vec4(0.066, -0.224, 0.053, 0.355), vec4(-0.240, 0.063, -0.350, 0.113)) * bufB[3] + mat4(vec4(-0.099, 0.119, -0.085, 0.025), vec4(0.147, -0.105, -0.152, -0.149), vec4(0.134, -0.248, -0.198, -0.239), vec4(0.260, -0.174, 0.276, 0.180)) * bufB[4] + mat4(vec4(0.158, 0.040, -0.139, 0.157), vec4(-0.004, -0.062, -0.192, -0.123), vec4(-0.047, 0.059, -0.064, -0.164), vec4(-0.028, -0.213, 0.066, 0.241)) * bufB[5] + mat4(vec4(-0.226, 0.029, -0.059, -0.040), vec4(-0.118, -0.173, -0.019, 0.218), vec4(0.099, 0.155, 0.228, 0.128), vec4(-0.180, -0.149, 0.068, -0.078)) * bufB[6] + mat4(vec4(0.010, -0.011, -0.006, 0.434), vec4(-0.083, 0.093, -0.041, -0.017), vec4(-0.069, -0.034, -0.010, -0.256), vec4(0.160, 0.288, 0.081, -0.046)) * bufB[7] + mat4(vec4(-0.168, -0.080, 0.015, -0.112), vec4(-0.086, -0.027, -0.315, -0.112), vec4(0.003, 0.008, 0.015, 0.117), vec4(-0.033, 0.082, 0.026, 0.088)) * bufB[8] + mat4(vec4(-0.045, -0.053, -0.010, 0.236), vec4(0.092, -0.149, 0.152, -0.054), vec4(-0.344, -0.120, 0.135, -0.148), vec4(0.065, 0.330, -0.143, 0.133)) * bufB[9];\nbufA[1] = vec4(-0.572, 0.383, 0.151, 0.172) + mat4(vec4(0.172, -0.278, 0.230, 0.134), vec4(0.073, -0.186, 0.007, -0.552), vec4(-0.146, 0.067, 0.062, 0.016), vec4(-0.203, -0.057, -0.163, 0.212)) * bufB[0] + mat4(vec4(-0.122, 0.181, -0.048, -0.096), vec4(-0.085, 0.143, 0.194, 0.446), vec4(-0.202, 0.060, 0.073, -0.493), vec4(-0.058, 0.140, -0.023, 0.076)) * bufB[1] + mat4(vec4(-0.081, 0.040, -0.237, 0.035), vec4(-0.049, -0.366, -0.035, 0.176), vec4(0.180, 0.217, -0.047, 0.102), vec4(0.202, -0.349, 0.003, 0.143)) * bufB[2] + mat4(vec4(0.207, 0.059, -0.100, 0.041), vec4(-0.147, -0.026, 0.186, -0.139), vec4(-0.252, -0.214, -0.010, 0.444), vec4(0.159, -0.069, 0.130, -0.126)) * bufB[3] + mat4(vec4(0.165, 0.142, -0.162, -0.081), vec4(0.207, -0.485, -0.068, -0.072), vec4(-0.046, 0.321, -0.219, -0.036), vec4(-0.121, -0.134, -0.061, 0.067)) * bufB[4] + mat4(vec4(0.075, -0.283, 0.141, 0.039), vec4(-0.073, -0.129, 0.021, 0.057), vec4(0.136, -0.137, 0.120, -0.114), vec4(-0.031, 0.242, 0.061, -0.178)) * bufB[5] + mat4(vec4(0.370, -0.090, 0.039, -0.208), vec4(-0.002, 0.195, 0.266, 0.053), vec4(0.139, 0.026, -0.114, 0.308), vec4(-0.287, 0.043, -0.021, 0.235)) * bufB[6] + mat4(vec4(0.189, -0.043, 0.303, 0.014), vec4(-0.042, -0.149, 0.162, 0.015), vec4(0.035, -0.178, -0.015, 0.240), vec4(-0.065, 0.120, -0.141, -0.318)) * bufB[7] + mat4(vec4(0.003, 0.200, -0.020, 0.320), vec4(0.086, -0.188, 0.023, -0.156), vec4(0.102, 0.204, -0.023, -0.116), vec4(0.139, 0.061, 0.003, 0.031)) * bufB[8] + mat4(vec4(-0.222, 0.003, 0.091, -0.102), vec4(-0.164, 0.137, 0.053, 0.155), vec4(0.053, 0.241, -0.132, -0.103), vec4(0.427, 0.147, -0.167, 0.280)) * bufB[9];\nbufA[2] = vec4(-0.347, -0.179, -0.300, 0.616) + mat4(vec4(-0.284, -0.054, -0.025, 0.038), vec4(-0.504, -0.154, -0.400, 0.132), vec4(-0.375, -0.126, 0.234, 0.002), vec4(0.038, 0.070, -0.192, 0.000)) * bufB[0] + mat4(vec4(0.132, 0.024, 0.084, 0.099), vec4(-0.526, -0.014, 0.285, 0.109), vec4(-0.095, -0.128, -0.402, 0.108), vec4(0.074, 0.253, -0.182, -0.124)) * bufB[1] + mat4(vec4(0.025, -0.061, -0.373, 0.041), vec4(-0.107, 0.155, -0.333, 0.367), vec4(-0.230, 0.127, -0.273, -0.233), vec4(-0.129, -0.266, -0.048, 0.092)) * bufB[2] + mat4(vec4(0.001, -0.012, -0.242, 0.103), vec4(0.264, 0.003, 0.197, -0.171), vec4(0.331, -0.055, -0.164, 0.225), vec4(0.007, 0.077, -0.024, 0.045)) * bufB[3] + mat4(vec4(0.186, 0.050, 0.145, 0.276), vec4(-0.225, -0.078, 0.150, -0.025), vec4(-0.038, -0.235, 0.118, -0.078), vec4(0.225, -0.212, -0.555, 0.082)) * bufB[4] + mat4(vec4(-0.102, -0.375, 0.084, 0.121), vec4(0.068, 0.152, 0.479, -0.004), vec4(0.151, -0.265, 0.206, -0.174), vec4(-0.186, 0.318, 0.102, -0.129)) * bufB[5] + mat4(vec4(0.032, 0.113, 0.207, 0.084), vec4(-0.305, -0.106, 0.019, -0.140), vec4(0.292, 0.089, -0.233, 0.098), vec4(0.249, 0.106, -0.250, -0.162)) * bufB[6] + mat4(vec4(-0.141, -0.009, 0.100, -0.061), vec4(0.256, -0.018, -0.476, -0.106), vec4(0.176, 0.051, 0.523, -0.005), vec4(0.025, 0.036, -0.215, 0.103)) * bufB[7] + mat4(vec4(0.154, 0.009, -0.310, -0.015), vec4(0.178, -0.098, -0.068, -0.033), vec4(-0.044, -0.184, -0.058, 0.172), vec4(-0.060, 0.052, 0.171, -0.096)) * bufB[8] + mat4(vec4(0.013, -0.202, -0.341, -0.097), vec4(-0.057, 0.005, -0.470, -0.023), vec4(0.005, 0.067, -0.009, 0.105), vec4(0.037, 0.081, 0.234, -0.047)) * bufB[9];\nbufA[3] = vec4(0.116, -0.210, 0.662, -0.050) + mat4(vec4(0.103, 0.154, -0.032, 0.041), vec4(-0.087, 0.109, -0.278, -0.005), vec4(-0.243, -0.402, 0.122, -0.212), vec4(-0.273, -0.032, -0.459, 0.094)) * bufB[0] + mat4(vec4(0.365, 0.182, -0.219, -0.373), vec4(0.078, -0.103, 0.452, 0.052), vec4(0.470, -0.043, -0.142, 0.188), vec4(-0.246, -0.040, 0.056, 0.034)) * bufB[1] + mat4(vec4(-0.778, -0.344, 0.358, -0.177), vec4(0.311, 0.208, 0.051, -0.366), vec4(-0.164, -0.316, 0.136, 0.016), vec4(0.110, 0.015, -0.140, 0.071)) * bufB[2] + mat4(vec4(-0.131, -0.387, -0.153, -0.217), vec4(-0.182, 0.137, -0.054, 0.066), vec4(0.095, 0.250, -0.063, 0.053), vec4(-0.102, -0.250, -0.396, 0.189)) * bufB[3] + mat4(vec4(-0.314, -0.165, 0.122, -0.009), vec4(-0.169, -0.155, 0.056, 0.113), vec4(-0.399, -0.607, -0.151, -0.166), vec4(0.083, -0.194, 0.205, -0.301)) * bufB[4] + mat4(vec4(0.026, 0.321, -0.323, 0.051), vec4(0.113, 0.376, 0.222, -0.051), vec4(0.212, 0.248, 0.056, -0.177), vec4(0.003, -0.007, 0.139, 0.208)) * bufB[5] + mat4(vec4(0.263, 0.209, 0.058, 0.188), vec4(-0.103, -0.273, 0.127, 0.053), vec4(0.136, 0.214, -0.061, -0.253), vec4(-0.288, -0.367, -0.361, 0.064)) * bufB[6] + mat4(vec4(0.542, 0.400, 0.045, -0.090), vec4(0.033, -0.188, -0.284, 0.135), vec4(0.073, -0.015, 0.007, 0.193), vec4(-0.023, -0.008, -0.116, -0.071)) * bufB[7] + mat4(vec4(-0.163, -0.140, 0.185, 0.033), vec4(-0.262, -0.200, 0.079, 0.079), vec4(0.107, 0.030, -0.092, 0.044), vec4(0.033, 0.023, 0.139, -0.210)) * bufB[8] + mat4(vec4(0.027, -0.007, -0.107, -0.047), vec4(0.172, 0.101, 0.130, -0.042), vec4(0.318, 0.248, 0.090, -0.059), vec4(-0.008, 0.115, 0.134, 0.113)) * bufB[9];\nbufA[4] = vec4(0.227, -0.028, -0.379, 0.584) + mat4(vec4(-0.087, -0.050, 0.197, 0.064), vec4(0.041, -0.172, -0.112, -0.033), vec4(0.220, 0.127, -0.035, 0.238), vec4(-0.032, -0.588, 0.033, 0.204)) * bufB[0] + mat4(vec4(-0.032, -0.213, -0.171, 0.010), vec4(0.333, 0.024, 0.374, -0.020), vec4(-0.290, 0.449, 0.408, 0.059), vec4(-0.152, 0.259, 0.119, 0.095)) * bufB[1] + mat4(vec4(-0.006, -0.720, 0.217, 0.339), vec4(-0.181, 0.055, 0.020, -0.069), vec4(0.129, -0.132, 0.171, 0.343), vec4(-0.370, -0.270, 0.248, -0.202)) * bufB[2] + mat4(vec4(0.024, -0.007, -0.040, 0.136), vec4(-0.205, 0.324, -0.078, -0.502), vec4(-0.131, 0.129, 0.220, -0.100), vec4(-0.002, 0.029, 0.044, 0.052)) * bufB[3] + mat4(vec4(-0.127, -0.223, 0.105, 0.084), vec4(-0.118, -0.069, 0.117, -0.091), vec4(0.104, -0.088, -0.157, -0.061), vec4(-0.026, 0.132, 0.245, 0.029)) * bufB[4] + mat4(vec4(-0.224, -0.159, 0.128, -0.289), vec4(-0.167, 0.043, -0.177, -0.274), vec4(-0.135, 0.281, -0.443, -0.008), vec4(0.254, 0.092, 0.081, -0.201)) * bufB[5] + mat4(vec4(0.039, 0.146, -0.152, 0.024), vec4(0.231, 0.146, 0.009, 0.172), vec4(-0.506, 0.034, -0.322, 0.152), vec4(-0.037, 0.208, -0.284, -0.057)) * bufB[6] + mat4(vec4(-0.020, 0.181, -0.045, -0.214), vec4(-0.165, 0.030, -0.197, 0.039), vec4(-0.063, -0.006, -0.073, -0.053), vec4(0.297, 0.255, -0.205, 0.106)) * bufB[7] + mat4(vec4(-0.060, 0.090, 0.009, 0.109), vec4(0.047, -0.238, -0.036, -0.105), vec4(0.129, -0.079, 0.104, 0.131), vec4(0.001, 0.112, -0.243, -0.103)) * bufB[8] + mat4(vec4(0.105, 0.070, 0.058, 0.167), vec4(0.149, 0.078, -0.112, 0.011), vec4(0.078, 0.163, -0.054, -0.090), vec4(0.117, 0.045, 0.194, 0.238)) * bufB[9];\ntmp = atan(bufA[0]);\nbufB[0] = tmp/0.67;\nbufB[5] = (tmp*tmp - 0.45) / 0.396;\ntmp = atan(bufA[1]);\nbufB[1] = tmp/0.67;\nbufB[6] = (tmp*tmp - 0.45) / 0.396;\ntmp = atan(bufA[2]);\nbufB[2] = tmp/0.67;\nbufB[7] = (tmp*tmp - 0.45) / 0.396;\ntmp = atan(bufA[3]);\nbufB[3] = tmp/0.67;\nbufB[8] = (tmp*tmp - 0.45) / 0.396;\ntmp = atan(bufA[4]);\nbufB[4] = tmp/0.67;\nbufB[9] = (tmp*tmp - 0.45) / 0.396;\n\n // layer 9 \nbufA[0] = vec4(0.467, -0.175, 0.014, 0.000) + mat4(vec4(-0.109, -0.036, 0.056, 0.000), vec4(0.204, 0.076, 0.057, 0.000), vec4(-0.194, -0.276, -0.198, 0.000), vec4(-0.045, -0.174, -0.229, 0.000)) * bufB[0] + mat4(vec4(0.062, 0.116, 0.213, 0.000), vec4(-0.049, 0.098, -0.019, 0.000), vec4(-0.043, -0.163, -0.118, 0.000), vec4(0.006, -0.014, -0.082, 0.000)) * bufB[1] + mat4(vec4(0.106, 0.065, 0.120, 0.000), vec4(0.076, 0.050, -0.024, 0.000), vec4(0.006, -0.170, -0.258, 0.000), vec4(0.207, 0.180, 0.106, 0.000)) * bufB[2] + mat4(vec4(-0.228, -0.244, -0.233, 0.000), vec4(0.096, 0.128, 0.058, 0.000), vec4(0.098, 0.011, 0.123, 0.000), vec4(0.153, 0.133, 0.036, 0.000)) * bufB[3] + mat4(vec4(0.045, -0.059, 0.014, 0.000), vec4(0.090, 0.026, 0.075, 0.000), vec4(0.043, 0.132, 0.293, 0.000), vec4(0.110, 0.271, 0.128, 0.000)) * bufB[4] + mat4(vec4(0.043, 0.032, 0.017, 0.000), vec4(0.012, 0.018, -0.056, 0.000), vec4(0.115, 0.078, 0.011, 0.000), vec4(0.099, 0.169, 0.221, 0.000)) * bufB[5] + mat4(vec4(0.109, 0.093, 0.148, 0.000), vec4(-0.093, -0.024, -0.101, 0.000), vec4(-0.031, 0.001, -0.068, 0.000), vec4(-0.036, 0.006, -0.008, 0.000)) * bufB[6] + mat4(vec4(-0.036, 0.008, 0.037, 0.000), vec4(-0.142, -0.129, -0.042, 0.000), vec4(0.012, 0.117, 0.159, 0.000), vec4(-0.109, -0.153, -0.112, 0.000)) * bufB[7] + mat4(vec4(0.340, 0.371, 0.341, 0.000), vec4(-0.207, -0.215, -0.201, 0.000), vec4(-0.060, -0.026, -0.063, 0.000), vec4(0.050, 0.038, -0.034, 0.000)) * bufB[8] + mat4(vec4(0.059, -0.035, 0.038, 0.000), vec4(-0.241, -0.169, -0.145, 0.000), vec4(-0.114, -0.077, -0.090, 0.000), vec4(-0.093, -0.127, -0.080, 0.000)) * bufB[9];\n\n return vec4((1. / (1. + exp(-bufA[0]))).xyz, 1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 mouseNorm = (iMouse.xy / iResolution.xy) - vec2(0.5, 0.5);\n\n    uv.x *= iResolution.x / iResolution.y;\n    uv.x -= ((iResolution.x / iResolution.y) - 1.) /2.;\n\n    // Shifted to the form expected by the CPPN\n    uv = vec2(1., -1.) * vec2(1.3, 1.6) * (uv - vec2(0.5, 0.5));\n    // Output to screen\n    fragColor = cppn_fn(uv, 0.23*sin(iTime), 0.32*sin(0.69*iTime), 0.32*sin(0.44*iTime), 0.23*sin(1.23*iTime));\n}\n        ", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/fdj3WR.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "fdjGDc", "name": "Mandelbrot test modified", "author": "Sem1337", "description": "m", "tags": ["fractal", "mandelbrot", "kaleidoscope"], "likes": 4, "viewed": 89, "date": "1618576992", "time_retrieved": "2024-06-20T20:36:56.223936", "image_code": "#define ITERS 267.\n#define PI 3.1415926\n\nvec2 rotate(vec2 v, float a) {\n\tfloat s = sin(a);\n\tfloat c = cos(a);\n\tmat2 m = mat2(c, -s, s, c);\n\treturn m * v;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.y;\n    vec2 frag = fragCoord;\n    vec2 res = iResolution.xy;\n    uv -= 0.5;\n    //uv = abs(uv);\n    //uv = rotate(uv, PI * 0.25);\n    //uv = abs(uv);\n\n    \n\n\n    float tz = 0.6 - 0.45*cos(0.115*iTime);\n    float zoom = pow( 0.5, 13.0*tz );\n\n    // -0.05 , 0.6805\n    vec2 c = vec2(-0.04952,.6746265) + uv * zoom;\n    vec2 z;\n    float r = 20.;\n    float r2 = r*r;\n    float iter;\n    vec2 zPrev;\n    for(iter = 0.; iter < ITERS ; iter++) {\n        zPrev = rotate(z, iTime * 4.);\n        z = vec2(z.x * z.x - z.y * z.y, 2.*z.x*z.y) + c;\n        if(dot(z, zPrev) > r2) break;\n    }\n    float angle = atan(z.y,z.x);\n    if (iter == ITERS) {\n        vec3 col = vec3(0.3,0.8,0.3);\n        col *= sin(length(z)*25.)*0.3 + 1.;\n        fragColor = vec4(col, 1.0);\n        return;\n    }\n    float dist = length(z);\n    float fracIter = (dist-r) / (r2-r);\n    fracIter = log(dist) / log(r) - 1.;\n    iter += (fracIter + 3.) * (fracIter + 3.);\n    \n    float m  = sqrt(iter / ITERS);\n    vec3 col =  0.5 * cos(vec3(PI / 20. + (sin(iTime * 0.15)*0.5 + 0.5) ,0.45,0.05) * m * 100.) + 0.5;\n    \n    col *= vec3(smoothstep(5.,0.,fracIter));\n    \n    col *= 1. + sin(angle * 2.)*0.2;\n    \n    fragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/fdjGDc.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "fdlSDn", "name": "Intercept those frequencies", "author": "z0rg", "description": "A cool idea I had watching some Jensen interceptor's covers", "tags": ["sound", "curves", "jenseninterceptor"], "likes": 7, "viewed": 257, "date": "1618856134", "time_retrieved": "2024-06-20T20:36:56.787439", "image_code": "// This work is licensed under the Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n// Unported License. To view a copy of this license, visit http://creativecommons.org/licenses/by-nc-sa/3.0/ \n// or send a letter to Creative Commons, PO Box 1866, Mountain View, CA 94042, USA.\n// =========================================================================================================\n\n#define sat(a) clamp(a, 0., 1.)\nfloat lenny(vec2 v)\n{\n    return abs(v.x)+abs(v.y);\n}\n\nmat2 r2d(float a) { float c = cos(a), s = sin(a); return mat2(c,-s,s,c);}\n\nfloat _sqr(vec2 p, vec2 s)\n{\n    vec2 l = abs(p)-s;\n    return max(l.x, l.y);\n}\n\nfloat border(vec2 uv)\n{\n    uv -= vec2(0.,.02);\n    float body = _sqr(uv, vec2(.3,.2));\n    body = max(body, uv.x-uv.y-.475);\n    return abs(body)-0.0001;\n}\n\nvec3 rdr2(vec2 uv)\n{\n\n    vec3 col;\n    //return texture(iChannel0, (uv-vec2(.5))*vec2(iResolution.x)/iResolution.xy).xyz;\n    float cnt = 40.;\n    for (float i = 0.; i < cnt; ++i)\n    {\n        // camera version\n        //float pic = pow(texture(iChannel0, vec2(uv.x*.8+.5, 19.*i/1600.-iTime*.501+.3)).x, 2.);\n        float pic = pow(texture(iChannel0, vec2(uv.x*.25, 1.*i/1600.-iTime*.01)).y, 1.5);\n        pic *= sat(.5+abs(uv.x*2.));\n        pic += 2.*pow(texture(iChannel1, vec2((uv.x+.5),0.)).x,.5)*(1.-sat(i/cnt));\n        float lvl = abs(uv.y-.01*(i-cnt/2.)-0.05*pic)-0.001;\n        lvl = max(lvl, abs(uv.x)-.25);\n        col = mix(col, mix(vec3(0.071,0.769,0.627), vec3(1.000,0.918,0.502),sat(pic*2.-1.5)), (1.-sat(i/cnt))*(1.-sat(lvl*400.*(1.-sat(max(i/cnt, .1))))));\n    }\n    col = mix(col, col.yxz, sat((uv.x+.5)*2.));\n    \n    float strips = max(sin((uv.x-uv.y)*100.+iTime*2.), -(abs(uv.x)-.45));\n    vec3 stripsCol = mix(vec3(0.071,0.769,0.627), vec3(1.000,0.918,0.502), sat(sin(uv.y*15.)*.5+.5));\n    col = mix(col, stripsCol, 1.-sat(strips*iResolution.x));\n    \n    col += stripsCol * pow(1.-sat(length(uv)),5.)*.5;\n    \n    col = mix(col, stripsCol, 1.-sat(border(uv)*400.));\n    return col;\n}\n\nvec3 rdr(vec2 uv)\n{\n    vec2 dir = normalize(vec2(1.));\n    float str = 0.01*texture(iChannel1, vec2(0.9,0.)).x;\n    vec3 col;\n    col.r = rdr2(uv+dir*str).r;\n    col.g = rdr2(uv).g;\n    col.b = rdr2(uv-dir*str).b;\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-vec2(.5)*iResolution.xy)/iResolution.xx;\n    float stp = 0.02;\n    vec2 uv2 = floor(uv/stp)*stp;\n    vec3 col = rdr(uv);\n    col += rdr(uv2)*(1.-sat(length(uv2)))*.25;\n    col = pow(col, vec3(.85));\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": "XsX3Rn", "previewfilepath": "/media/ap/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg", "ctype": "texture"}, {"id": "MtXXzS", "previewfilepath": "https://soundcloud.com/jensen-interceptor/dj-deeon-jensen-interceptor#t=1:30", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0, "src": "https://soundcloud.com/jensen-interceptor/dj-deeon-jensen-interceptor#t=1:30", "ctype": "musicstream"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc-by-nc-sa-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/fdlSDn.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "fdlXR7", "name": "Audio-Responsiv'Är", "author": "Synfoxic", "description": "\"Audio\" ... \"Responsive\" ...", "tags": ["notserious"], "likes": 1, "viewed": 21, "date": "1618412023", "time_retrieved": "2024-06-20T20:36:56.787439", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 st = (fragCoord.xy-0.5*iResolution.xy)/iResolution.y;\n    vec3 color = vec3(0.0);\n    st += vec2(0.1,0.1);\n  \tst *= 8.;\n    vec2 pos = vec2(0.5,0.5)-st;\n\n    float r = length(pos)/3.976;\n    float a = atan(pos.y,pos.x);\n\n    float satan = cos(a*3.);\n    satan = abs(cos(a*10.));\n    satan *= abs(cos(a*5.))*0.612*(sin(iTime*13.)*0.4+0.9);\n    satan /= abs(cos(a*12.)*sin(a*3.))*.8+.1;\n    satan /= smoothstep(-.5,2., cos(a*8.))*0.2+1.45;\n\n    color = vec3( 1.15-smoothstep(satan,satan+0.9,r) );\n\n    fragColor = vec4(color, 1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/fdlXR7.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "fdlXWS", "name": "RGB color slow", "author": "dtristram", "description": "rather ugly bands of color, but slower at least", "tags": ["color", "rgb"], "likes": 1, "viewed": 30, "date": "1619144768", "time_retrieved": "2024-06-20T20:36:57.072543", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    const float rate = 0.1;\n    float sTime = iTime * rate;\n    \n    const float sBase = 3.0;\n    const float sRange = 5.0;\n    const float tBase = 0.6;\n    const float tRange = 0.5;\n    \n    vec3 sW0 = 0.5 + 0.5 * vec3(\n        cos(1.0*sTime),\n        cos(1.1*sTime),\n        cos(1.2*sTime));\n        \n    vec3 sW1 = 0.5 - 0.5 * vec3(\n        cos(1.05*sTime),\n        cos(1.15*sTime),\n        cos(1.25*sTime));\n        \n    vec3 tW0 = 0.5 + 0.5 * vec3(\n        cos(0.9*sTime),\n        cos(1.8*sTime),\n        cos(1.7*sTime));\n        \n    vec3 tW1 = 0.5 - 0.5 * vec3(\n        cos(0.95*sTime),\n        cos(0.85*sTime),\n        cos(0.75*sTime));\n        \n    vec3 s0 = sBase + sRange * sW0;\n    vec3 s1 = sBase + sRange * sW1;\n    vec3 t0 = tBase + tRange * tW0;\n    vec3 t1 = tBase + tRange * tW1;\n    \n    \n    // Time varying pixel color\n    vec3 w = 0.5 + 0.25 * (cos(s0*(uv.yyy - 1.0 + t0)) + cos(s1*(uv.yyy - 1.0 + t1)));\n//    float wG = cos(1.2*iTime+10.0*uv.y);\n//    float wB = cos(-0.8*iTime+5.0*uv.y);\n\n    // vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n    \n//    vec3 col = 0.5 + 0.5 * vec3(wR, wR, wR);\n    \n    // Output to screen\n    fragColor = vec4(w.xyz,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/fdlXWS.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "fdlXz4", "name": "goldish truchet 3D", "author": "yasuo", "description": "goldish truchet 3D", "tags": ["truchet"], "likes": 4, "viewed": 163, "date": "1618336766", "time_retrieved": "2024-06-20T20:36:57.078583", "image_code": "// All the distance functions from:http://iquilezles.org/www/articles/distfunctions/distfunctions.htm\n// raymarching based from https://www.shadertoy.com/view/wdGGz3\n#define USE_MOUSE 0\n#define MAX_STEPS 100\n#define MAX_DIST 100.\n#define SURF_DIST .005\n#define Rot(a) mat2(cos(a),-sin(a),sin(a),cos(a))\n#define matRotateX(rad) mat3(1,0,0,0,cos(rad),-sin(rad),0,sin(rad),cos(rad))\n#define matRotateY(rad) mat3(cos(rad),0,-sin(rad),0,1,0,sin(rad),0,cos(rad))\n#define matRotateZ(rad) mat3(cos(rad),-sin(rad),0,sin(rad),cos(rad),0,0,0,1)\n\n\nfloat sdPie3d(vec3 p, float rad, float r, float h) {\n    p.xy = abs(p.xy);\n    vec2 c = vec2(sin(rad),cos(rad));\n    float d = max(p.y-h,length(p.xz) - r);\n    float m = length(p.xz-c*clamp(dot(p.xz,c),0.0,r)); \n    return max(d,m*sign(c.y*p.x-c.x*p.z));\n}\n\nfloat pattern(vec3 p) {\n    vec3 prevP = p;\n    float r = 1.135;\n    float h = 0.1;\n    float rad = radians(-45.0);\n    p*=matRotateY(radians(45.0));\n    \n    p.z*=-1.0;\n    p.z=abs(p.z);\n    p.z-=1.415;\n    \n    float d = sdPie3d(p,rad,r,h);\n    float d2 = sdPie3d(p,radians(180.),r*0.75,h+0.02);\n    d = max(-d2+0.01,d);\n\n    return d;\n}\n\nvec4 GetDist(vec3 p) {\n    \n    p.z-=iTime*1.1;\n    vec2 id = floor(p.xz*0.5);\n    p.xz = mod(p.xz,2.0)-1.0;\n\n    vec2 randP = fract(sin(id*123.456)*567.89);\n    randP += dot(randP,randP*34.56);\n    float rand = fract(randP.x*randP.y);\n    \n    float speed = 1.5;\n    if(rand<0.5) {\n        p.z*=-1.0;\n        speed = 1.0;\n    }\n    \n    float d = pattern(p);\n    \n    p.x-=iTime*speed;\n    p.x = mod(p.x,4.0)-2.0;\n    \n    float shine = length(p.xy)-0.05;\n    shine = 1.0-smoothstep(-0.1,0.1,shine);\n    vec4 res = vec4(vec3(1.0)*shine,d);\n\n    vec4 model = res;\n    return model;\n}\n\nvec4 RayMarch(vec3 ro, vec3 rd) {\n    vec4 dO= vec4(0.0);\n    \n    for(int i=0; i<MAX_STEPS; i++) {\n        vec3 p = ro + rd*dO.w;\n        vec4 dS = GetDist(p);\n        dO.w += dS.w;\n        dO.xyz = dS.xyz;\n        if(dO.w>MAX_DIST || dS.w<SURF_DIST) break;\n    }\n    \n    return dO;\n}\n\nvec3 GetNormal(vec3 p) {\n    float d = GetDist(p).w;\n    vec2 e = vec2(.001, 0);\n    \n    vec3 n = d - vec3(\n        GetDist(p-e.xyy).w,\n        GetDist(p-e.yxy).w,\n        GetDist(p-e.yyx).w);\n    \n    return normalize(n);\n}\n\nvec2 GetLight(vec3 p) {\n    vec3 lightPos = vec3(2,5,-3);\n    \n    lightPos.yz *= Rot(radians(-30.0));\n    lightPos.xz *= Rot(iTime*1.5+1.0);\n    \n    vec3 l = normalize(lightPos-p);\n    vec3 n = GetNormal(p);\n    \n    float dif = clamp(dot(n, l)*.5+.5, 0., 1.);\n    float d = RayMarch(p+n*SURF_DIST*2., l).w;\n    \n    float lambert = max(.0, dot( n, l))*0.6;\n    \n    return vec2((lambert+dif),max(0.9, 1.0)) ;\n}\n\nvec3 R(vec2 uv, vec3 p, vec3 l, float z) {\n    vec3 f = normalize(l-p),\n        r = normalize(cross(vec3(0,1,0), f)),\n        u = cross(f,r),\n        c = p+f*z,\n        i = c + uv.x*r + uv.y*u,\n        d = normalize(i-p);\n    return d;\n}\n\nvec3 Bg(vec3 rd) {\n    float k = rd.y*0.5+0.5;\n    vec3 col = mix(vec3(.3,.3,.3),vec3(1.0,.7,.0),k);\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    vec2 m = iMouse.xy/iResolution.xy;\n    \n    vec3 col = vec3(0);\n    \n    vec3 ro = vec3(0, 3, -10);\n    #if USE_MOUSE == 1\n    ro.yz *= Rot(-m.y*3.14+1.);\n    ro.xz *= Rot(-m.x*6.2831);\n    #else\n    ro.yz *= Rot(radians(30.0));\n    #endif\n    \n    vec3 rd = R(uv, ro, vec3(0,0,0), 1.);\n\n    vec4 d = RayMarch(ro, rd);\n    \n    if(d.w<MAX_DIST) {\n        vec3 p = ro + rd * d.w;\n        vec3 n = GetNormal(p);\n        vec3 r = reflect(rd,n);\n        float spec = pow(max(0.0,r.y),30.);\n        float dif = dot(n,normalize(vec3(1,2,3)))*0.5+0.5;\n        col = mix(Bg(r),vec3(dif),0.5)+spec;\n        col += d.rgb;\n    } else {\n        // background\n        col += Bg(rd);\n    }\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/fdlXz4.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "fdS3Dd", "name": "Colourful spiral rotation", "author": "Agneseion", "description": "Just programmed something before going to bed. Not very inspired and my laptop doesn't want LINE_COUNT to be much higher than this (need to try with higher values on an actual GPU)...", "tags": ["zoom", "spiral", "color", "hypnotic", "colour", "rotation"], "likes": 1, "viewed": 39, "date": "1618086763", "time_retrieved": "2024-06-20T20:36:57.078583", "image_code": "#define LINE_COUNT 512\n#define TWO_PI 6.28318530718\n#define PI 3.1459\n\nbool overlapsLine(float radius, float angle, int lineIndex)\n{\n    float angleAtTime = mod(radius + iTime + float(lineIndex), TWO_PI) - PI;\n    \n    radius /= 1.1 + cos(iTime * radius + angle + float(lineIndex));\n    \n    return (angleAtTime > angle - 0.0005 / radius && angleAtTime < angle + 0.0005 / radius);\n}\n\nvec3 getLineTint(int lineIndex)\n{\n    float p = float(LINE_COUNT * lineIndex) + iTime + float(lineIndex) / float(LINE_COUNT);\n    return .5 + .5 * sin(vec3(p, p + TWO_PI / 3.0, p + PI / 3.0));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    float r = length(uv - .5) * (1.0 + sin(iTime));\n    float a = atan(uv.y - .5, uv.x - .5);\n\n    float linesIntersected = 0.0;\n\n    vec3 tintSum = vec3(0.0);\n    for (int i = 0; i < LINE_COUNT; i++)\n    {\n        if (overlapsLine(r, a, i))\n        {\n            tintSum += getLineTint(i);\n            linesIntersected += 1.0;\n        }\n    }\n\n    fragColor = vec4(tintSum / linesIntersected, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/fdS3Dd.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "fdS3DG", "name": "Hypnotic Heart \"Plasma\"", "author": "ShiftedClock_", "description": "Fork of \"Concentric Plasma\" by cacheflower: https://www.shadertoy.com/view/ltyXzm\nWith heart elements from iq: https://www.shadertoy.com/view/XsfGRn", "tags": ["heart", "concentric"], "likes": 0, "viewed": 58, "date": "1617853827", "time_retrieved": "2024-06-20T20:36:57.345238", "image_code": "#define PI     3.14159265358\n#define TWO_PI 6.28318530718;\nconst float timeScale = 4.;\n\nfloat saw(float rads) {\n    rads += PI * 0.5; // sync oscillation up with sin()\n    float percent = mod(rads, PI) / PI;\t\t\t\t\n    float dir = sign(sin(rads));\n    return dir * (2. * percent  - 1.);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // set time & centered position\n    float time = 10. + iTime * timeScale;\n    vec2 uv = (2. * fragCoord.xy - iResolution.xy) / iResolution.y;\n    uv *= .8;\n    uv.y = -0.1 - uv.y*1.2 + abs(uv.x)*(1.0-abs(uv.x));\n\t// calc additive distance from control points\n    float dist = 0.;\n    for(int ii = 1; ii < 5; ii++) {\n      \tdist += (10. + 7. * sin(time/timeScale)) * distance(uv, vec2(0.));\n    }\n    // oscillate color components by distance factor. smoothstep for contrast boost\n    vec3 col = vec3(\n        smoothstep(0.1, 0.9, abs(sin(time + dist * 0.11)) * 0.5 + 0.6),\n        smoothstep(0.1, 0.8, abs(cos(time + dist * 0.22)) * 0.37 + 0.01),\n        smoothstep(0.1, 0.8, abs(sin(time + dist * 0.33)) * 0.15 + 0.4)\n    );\n\t// vignette outside of center\n    float vignetteInner = 0.75;\n    float vignetteDarkness = 0.4;\n    col -= smoothstep(0., 0.7, max(0., length(uv) - vignetteInner) * vignetteDarkness);\n\n    fragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/fdS3DG.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "fdS3RG", "name": "Psychedelic Jute-Beutel314", "author": "Domain314", "description": "some testing and messing around", "tags": ["abstract", "own"], "likes": 1, "viewed": 28, "date": "1617542347", "time_retrieved": "2024-06-20T20:36:57.345238", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\n    vec3 col = vec3(0.);\n    \n    uv *= 10.;\n    \n    vec2 toCenter = vec2(0.)-uv;\n    float p = smoothstep(0.2, 0.23 , length(toCenter));    \n    \n    //col.rgb += p;\n        \n    \n    float s = sin(uv.x);\n    float c = cos(uv.y);\n    \n    mat2 rot = mat2(c, -s, s, c);\n    uv *= rot/uv.x;\n    \n    float m = smoothstep(0.2, 0.22, uv.x);\n    m -= uv.x;\n    \n    \n    float t = iTime * 0.4;\n    vec3 base = sin(t*5.*vec3(.345, .456, .657))*.4 + .6;\n    col = m*base;\n\n\n    col += texture(iChannel0, uv*2.-iTime*.03).rgb;\n    \n    col /= 2.;\n    \n    float s2 = sin(iTime)+.3;\n    \n    col *= cos(s2)+.3;\n\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": "4dX3Rn", "previewfilepath": "/media/ap/bd6464771e47eed832c5eb2cd85cdc0bfc697786b903bfd30f890f9d4fc36657.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/bd6464771e47eed832c5eb2cd85cdc0bfc697786b903bfd30f890f9d4fc36657.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/fdS3RG.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "fdS3WG", "name": "simple plotter", "author": "boysx", "description": "A function plotter", "tags": ["plotter"], "likes": 1, "viewed": 32, "date": "1617847971", "time_retrieved": "2024-06-20T20:36:57.345238", "image_code": "#define PI 3.14159\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    uv.x -= 0.5; // offset\n    \n    // function\n    float fx = cos(uv.x*PI*2.+iTime*3.);\n    \n    // plotter\n    float plot = pow(smoothstep(0.01, 0., abs((fx*0.5+0.5)-uv.y)),1./5.);\n    vec3 col = vec3(plot, 0., 0.);\n    col = mix(vec3(1.), col, plot);\n\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/fdS3WG.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "fdSGDd", "name": "Raymarching Primitives of FUNK", "author": "IMLXH", "description": "okay why the heck is the floor warping? what is the power of this Long Boy", "tags": ["tutorial", "experiment", "vaporwave"], "likes": 0, "viewed": 35, "date": "1618084117", "time_retrieved": "2024-06-20T20:36:57.975484", "image_code": "#define MAX_STEPS 100\n#define MAX_DIST 100.\n#define SURF_DIST .01\n\nfloat sdCapsule(vec3 p, vec3 a, vec3 b, float r) {\n    vec3 ab = b-a;\n    vec3 ap = p-a;\n    \n    float t = dot(ab, ap) / dot(ab, ab);\n    t = clamp(t, 0., 1.);\n    \n    vec3 c = a + t*ab;\n    \n    return length(p-c)-r;\n}\n\nfloat sdCylinder(vec3 p, vec3 a, vec3 b, float r) {\n    vec3 ab = b-a;\n    vec3 ap = p-a;\n    \n    float t = dot(ab, ap) / dot(ab, ab);\n    //t = clamp(t, 0., 1.);\n    \n    vec3 c = a + t*ab;\n    \n    float x = length(p-c)-r;\n    float y = (abs(t-.5)-.5) * length(ab);\n    float e = length(max(vec2(x,y), 0.));\n    float i = min(max(x, y), 0.);\n    \n    return e+i;\n}\n\nfloat sdTorus(vec3 p, vec2 r) {\n    float x = length(p.xz)-r.x;\n    return length(vec2(x, p.y))-r.y;\n}\n\nfloat dBox(vec3 p, vec3 s) {\n    return length(max(abs(p) - s, 0.));\n}\n\nfloat GetDist(vec3 p) {\n    vec4 s = vec4(0, 1, 6, 1); // sphere\n    \n    float sphereDist = length(p-s.xyz)-s.w; // s.w is sphere radius i guess\n    float planeDist = p.y;\n    \n    float cd = sdCapsule(p, vec3(0,1,6), vec3(1,2,6), .2);\n    float td = sdTorus(p-vec3(0.,.5,6.), vec2(1.5, .3));\n    float bd = dBox(p-vec3(-3., .75, 6.), vec3(.75));\n    float cyld = sdCylinder(p, vec3(0,.3,3), vec3(3,1,5), .3);\n    \n    float d = min(cd, planeDist);\n    d = min(d, td); // mixing objects in raymarching is done with min()\n    d = min(d, bd);\n    d = min(d, cyld);\n    return d;\n}\n\nvec3 GetNormal(vec3 p) {\n    float d = GetDist(p);\n    vec2 e = vec2(.01, 0);\n    \n    vec3 n = d - vec3(\n        d-GetDist(p-e.xyy), // recreating the happy accident\n        d-GetDist(p-e.yxy),\n        d-GetDist(p-e.yyx));\n    \n    return normalize(n);\n}\n\nfloat RayMarch(vec3 ro, vec3 rd) {\n    float dO = 0.;\n    for (int i = 0; i < MAX_STEPS; i++) {\n        vec3 p = ro + dO*rd;\n        float dS = GetDist(p);\n        dO += dS;\n        if (dS<SURF_DIST || dO>MAX_DIST) break;\n    }\n    return dO;\n}\n\nfloat GetLight(vec3 p) {\n    vec3 lightPos = vec3(0, 5, 6);\n    lightPos.xz += vec2(sin(iTime), cos(iTime))*2.;\n    vec3 l = normalize(lightPos-p);\n    vec3 n = GetNormal(p);\n    \n    float dif = clamp(dot(n, l), 0., 1.);\n    float d = RayMarch(p+n*SURF_DIST*2., l);\n    if (d<length(lightPos-p)) dif *= .1; // shadows!\n    return dif;\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y; // OOH you can do this all in one line\n\n    vec3 col = vec3(0);\n    \n    // CAMERA\n    vec3 ro = vec3(sin(iTime), 2, cos(iTime)-.5)*vec3(2., 1., 2.);\n    vec3 rd = normalize(vec3(uv.x, uv.y-.3, 1));\n\n    float d = RayMarch(ro, rd);\n    \n    vec3 p = ro + rd * d;\n    \n    float dif = GetLight(p); // diffuse lighting\n    \n    col = GetNormal(p);\n    \n    col += dif;\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/fdSGDd.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "fdSGRV", "name": "Tutorial shader - mod", "author": "frankbolero", "description": "It's a something on an animated gradient :)", "tags": ["basic"], "likes": 0, "viewed": 48, "date": "1617629500", "time_retrieved": "2024-06-20T20:36:58.157291", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = gl_FragCoord.xy / iResolution.xy;\n    vec2 q = p - vec2(0.5,0.5);\n    //vec3 col = vec3(1.0, 0.4, 0.1);\n    \n    float r = 0.2 + 0.15 * cos(atan(cos(q.y), q.x)*iTime);\n\n    //-------- From default new\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord / iResolution.xy;\n\n    // Time varying pixel color\n    vec3 col = 0.8 + 0.2 * cos(iTime + uv.xyx + vec3(0,2,4));\n    //-------- From default new\n    \n    vec3 axis = vec3(0.0, 1.0, 0.0);\n    \n    col *= smoothstep(r, r+0.001, length(q));\n    \n    // Output to screen\n    fragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/fdSGRV.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "fdSGWG", "name": "logic c", "author": "4eckme", "description": "logic c", "tags": ["2d", "kaleidoscope", "fraktal"], "likes": 1, "viewed": 35, "date": "1617846200", "time_retrieved": "2024-06-20T20:36:58.157291", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 coord = fragCoord - (iResolution.xy / vec2(2.0));\n   \tcoord *= sqrt(iTime);\n    float x = float(coord.x);\n    float y = float(coord.y);\n    float r2 = float(int(abs(x*x+y*y)));\n    float r3 = float(int(abs(x*x-y*y)));\n    int a = int(floor(r2*pow(16.0, 6.0-ceil(log2(r2)/4.0))));\n    int b = int(floor(r3*pow(16.0, 6.0-ceil(log2(r2)/4.0))));\n    int c = a&b; \n    fragColor = vec4(\n        float((c >> 16) & 255) / 255.0,\n        float((c >> 8) & 255) / 255.0,\n        float((c >> 0) & 255) / 255.0,\n        1.0\n    );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/fdSGWG.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "fdSGWw", "name": "Reclaim the streets", "author": "evvvvil", "description": "Winning shader made at Revision 2021 Shader Showdown semi-final\nLive coded on stage in 25 minutes.  Designed beforehand in several hours.\n", "tags": ["demoscene", "transition", "organic", "isometric", "city", "orthographic", "morph", "nature", "world", "morphing", "clipping", "reclaim"], "likes": 136, "viewed": 4225, "date": "1617466546", "time_retrieved": "2024-06-20T20:36:58.702899", "image_code": "// Winning shader made at Revision 2021 Shader Showdown Semi-Final\n\n// The \"Shader Showdown\" is a demoscene live-coding shader battle competition.\n// 2 coders battle for 25 minutes making a shader on stage. No google, no cheat sheets.\n// The audience votes for the winner by making noise or by voting on their phone.\n\n// This shader was coded live on stage in 25 minutes. Designed beforehand in several hours.\n\nfloat t,tt,b,bb,g,a,la;vec2 z,v,e=vec2(.00035,-.00035);vec3 pp,op,cp,po,no,al,ld;\nvec4 np; \nmat2 r2(float r){return mat2(cos(r),sin(r),-sin(r),cos(r));}\nfloat bo(vec3 p,vec3 r){p=abs(p)-r;return max(max(p.x,p.y),p.z);}\nvec2 fb( vec3 p,float i,float s)\n{   \n    vec2 h,t=vec2(length(p.xz)-2.-clamp(sin(p.y*5.),-.2,.2)*.2,5);\n    t.x=abs(t.x)-.2;\n    pp=p;\n    pp.y+=1.-float(i)*2.;\n    a=max(abs(bo(pp,vec3(.65,2,200)))-.2,abs(pp.y)-1.);\n    t.x=min(t.x,mix(a,length(pp.xy-sin(p.z*.5))-.5,b));\n    pp.x=mix(abs(pp.x)-0.7,pp.y*.5-.8,b);//lampposts\n    pp.z=mod(pp.z,3.)-1.5;\n    pp-=mix(vec3(0,1,0),vec3(0.,-1.3,0.)+sin(p.z*.5),b);        \n    t.x=min(t.x,bo(pp,vec3(.1,2,.1))); \n    pp.y-=2.;     //lamps\n    la=length(pp)-.1;\n    g+=0.1/(0.1+la*la*40.);\n    t.x=min(t.x,la);\n    t.x/=s;    \n    t.x=max(t.x,-(length(op.xy-vec2(-2.*b,6.-float(i)*.1))-5.));\n    t.x=max(t.x,(abs(op.y)-5.+float(i))); \n    h=vec2(length(p.xz)-1.+(pp.y*.1/float(i*2.+1.)),3); //black\n    h.x/=s;\n    h.x=max(h.x,-(length(op.xy-vec2(0,6.1+3.*b-float(i)*.1))-5.));    \n    h.x=max(h.x,(abs(op.y)-5.5-5.*b+float(i)));\n    t=t.x<h.x?t:h;\n    if(i<2.){\n        h=vec2(abs(length(p.xz)-1.2)-.1,6);\n        h.x/=s;    \n        h.x=max(h.x,-(length(op.xy-vec2(-1.*b,6.2-float(i)*.1))-5.));    \n        h.x=max(h.x,(abs(op.y)-6.+float(i)));        \n        t=t.x<h.x?t:h;\n    }   \n    return t;\n}\nvec2 mp( vec3 p,float ga)\n{  \n  p.yz*=r2(mix(-.785,-.6154,bb));\n  p.xz*=r2(mix(0.,.785,bb));\n  op=p;\n  b=clamp(cos(op.z*.1+tt*.4),-.25,.25)*2.+.5;  \n  p.z=mod(p.z-tt,10.)-5.;\n  vec2 h,t=vec2(1000);\n  np=vec4(p,1.);\n  for(int i=0;i<5;i++){    \n    np.xz=abs(np.xz)-2.1+sin(np.y*.5)*.5*b;\n    np.xz*=r2(-.785);\n    np*=2.1;    \n    h=fb(np.xyz,float(i),np.w);    \n    h.x*=0.75;\n    t=t.x<h.x?t:h;   \n  }\n  h=vec2(p.y+2.+3.*cos(p.x*.35),6); \n  h.x=max(h.x,p.y);\n  h.x*=0.5;\n  t=t.x<h.x?t:h; \n  cp=p;\n  return t;\n}\nvec2 tr( vec3 ro,vec3 rd,int it)\n{\n  vec2 h,t=vec2(-3.); \n  for(int i=0;i<it;i++){\n  h=mp(ro+rd*t.x,1.);     \n    if(h.x<.0001||t.x>17.) break;\n    t.x+=h.x;t.y=h.y;\n  }\n  if(t.x>17.) t.y=0.;\n\treturn t;\n}\n#define a(d) clamp(mp(po+no*d,0.).x/d,0.,1.)\n#define s(d) smoothstep(0.,1.,mp(po+ld*d,0.).x/d)\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2 uv=(fragCoord.xy/iResolution.xy-0.5)/vec2(iResolution.y/iResolution.x,1);\n  tt=mod(iTime,62.82)+8.;\n  bb=1.-ceil(sin(tt*.4));\n  vec3 ro=vec3(uv*8.,-8.),\n  rd=vec3(0.,0.,1.),co,fo;\n  co=fo=vec3(.13,.1,.12)-length(uv)*.12;\n  ld=normalize(vec3(-.5,.5,-.3));\n  z=tr(ro,rd,128);t=z.x;  \n  if(z.y>0.){   \n    po=ro+rd*t;\n    no=normalize(e.xyy*mp(po+e.xyy,0.).x+e.yyx*mp(po+e.yyx,0.).x+e.yxy*mp(po+e.yxy,0.).x+e.xxx*mp(po+e.xxx,0.).x);\n    al=mix(vec3(.0,.1,.3),vec3(0.4,0.3,0.1),b);\n    if(z.y<5.) al=vec3(0);\n    if(z.y>5.) al=vec3(1),no-=0.2*ceil(abs(cos((cp)*5.2))-.05),no=normalize(no);    \n    float dif=max(0.,dot(no,ld)),\n    fr=pow(1.+dot(no,rd),4.),\n    sp=pow(max(dot(reflect(-ld,no),-rd),0.),40.);\n    co=mix(sp+al*(a(0.05)+.2)*(dif+s(.5)),fo,min(fr,.5));\n    co=mix(fo,co,exp(-.001*t*t*t));\n  }\n  co=mix(co,co.xzy,length(uv*.7));  \n  fragColor = vec4(pow(co+g*.2*mix(vec3(1.,.5,0.),vec3(1.),sin(t*5.)*.5-.2),vec3(.45)),1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/fdSGWw.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "fdSGzt", "name": "Fractal 49_gaz", "author": "gaz", "description": "fractal", "tags": ["fractal"], "likes": 31, "viewed": 646, "date": "1617788794", "time_retrieved": "2024-06-20T20:36:58.702899", "image_code": "#define R(p,a,r)mix(a*dot(p,a),p,cos(r))+sin(r)*cross(p,a)\n#define H(h)(cos((h)*6.3+vec3(0,23,21))*.5+.5)\nvoid mainImage(out vec4 O, vec2 C)\n{\n    O=vec4(0);\n    vec3 p,r=iResolution,\n    d=normalize(vec3((C-.5*r.xy)/r.y,2));  \n    for(float i=0.,s,e,g=1.5;\n        ++i<90.;\n        O.xyz+=.1*mix(vec3(1),H(log(s)*.3),.8)*exp(-12.*i*i*e)\n    )\n    {\n        p=g*d-vec3(-.2,.3,2.5);\n        p=R(p,normalize(vec3(1,2.*sin(iTime*.1),3)),iTime*.2);\n        s=5.;\n        p=p/dot(p,p)+1.;\n        for(int i=0;i++<8;p*=e)\n            p=1.-abs(p-1.),\n            s*=e=1.6/min(dot(p,p),1.5);\n        g+=e=length(cross(p,vec3(.577)))/s-5e-4;\n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/fdSGzt.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "fdsSD7", "name": "The worst voxel ray caster...", "author": "wildniklin", "description": "First test of a voxel raycast function in GLSL.", "tags": ["voxel"], "likes": 2, "viewed": 145, "date": "1618707742", "time_retrieved": "2024-06-20T20:36:58.708850", "image_code": "const float PI = 3.1415;\n\nmat2 rot(float r) {\n    float s = sin(r), c = cos(r);\n    return mat2(c, -s, s, c);\n}\n\nint getVoxel(ivec3 p) {\n    float t = fract(iTime * 0.25); t = t * (2.0 - t);\n    float h = fract(float(p.x * p.z) * 0.0625) * 16.0 * t;\n    if(p.y < int(h)) return 1;\n    return 0;\n}\n\nbool raycastVoxel(vec3 ro, vec3 rd, out ivec3 pos, out ivec3 nor, out int index, out float d) {\n    float maxdist = length(rd);\n    \n    rd /= maxdist;\n\n    pos = ivec3(floor(ro));\n    ivec3 ppos = pos;\n\n    vec3 s = sign(rd);\n    ivec3 is = ivec3(s);\n\n    vec3 td = s / rd;\n\n    if(isnan(td.x) || isinf(td.x)) td.x = 1e10;\n    if(isnan(td.y) || isinf(td.y)) td.y = 1e10;\n    if(isnan(td.z) || isinf(td.z)) td.z = 1e10;\n    \n    vec3 tm;\n    \n    if(s.x > 0.0) tm.x = td.x * ((1.0 - ro.x) + floor(ro.x)); else tm.x = td.x * fract(ro.x);\n    if(s.y > 0.0) tm.y = td.y * ((1.0 - ro.y) + floor(ro.y)); else tm.y = td.y * fract(ro.y);\n    if(s.z > 0.0) tm.z = td.z * ((1.0 - ro.z) + floor(ro.z)); else tm.z = td.z * fract(ro.z);\n\n    d = 0.0;\n\n    while(true) {\n        if(d > maxdist) break;\n\n        index = getVoxel(pos);\n\n        if(index != 0) {\n            nor = ppos - pos;\n            return true;\n        }\n\n        ppos = pos;\n    \n        if(tm.x < tm.y) {\n            if(tm.x < tm.z) {\n                d = tm.x;\n                pos.x += is.x;\n                tm.x += td.x;\n            }\n            else {\n                d = tm.z;\n                pos.z += is.z;\n                tm.z += td.z;\n            }\n        }\n        else {\n            if(tm.y < tm.z) {\n                d = tm.y;\n                pos.y += is.y;\n                tm.y += td.y;\n            }\n            else {\n                d = tm.z;\n                pos.z += is.z;\n                tm.z += td.z;\n            }\n        }\n    }\n    pos = ivec3(floor(ro));\n    nor = ivec3(0, 0, 0);\n    index = 0;\n    d = maxdist;\n    return false;\n}\n\nvoid mainImage(out vec4 o, in vec2 i) {\n    vec2 uv = (i - (0.5 * iResolution.xy)) / min(iResolution.x, iResolution.y);\n\n    vec3 ro = vec3(iTime, 20.0, iTime * 5.0);\n    vec3 rd = normalize(vec3(uv, 0.9));\n    rd.yz *= rot(PI * mix(0.15, 0.25, sin(iTime * PI * 0.125)));\n\n    ivec3 p, n; int index; float d;\n    bool hit = raycastVoxel(ro, rd * 100.0, p, n, index, d);\n    //vec3 p = ro + (rd * d);\n\n    vec3 col = vec3(1.0);\n\n    col *= 0.75 + 0.25 * dot(vec3(n), normalize(vec3(0.3, 1.0, -0.5)));\n    col *= 0.1 * abs(fract(vec3(p) * 0.125) * 8.0);\n\n    o = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/fdsSD7.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "fdsSzl", "name": "Spirals and Gems", "author": "jarble", "description": "These \"gems\" are separated by many spiral patterns.", "tags": ["fractal", "spiral", "metal", "gem"], "likes": 3, "viewed": 167, "date": "1619058634", "time_retrieved": "2024-06-20T20:36:58.708850", "image_code": "#define ITERS 12\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.0);\n    vec3 col=vec3(0.0),col_prev=vec3(0.0);\n    float t=0.0;\n    vec2 uv = (fragCoord*10.0-iResolution.xy)/iResolution.y/10.0;\n    uv.y += (iTime)/8.0;\n    for(int c=0;c<ITERS;c++){\n        float scale = 2.35;\n        float scale1 = 1.07;\n        float s1 = scale1*scale;\n        col_prev = col;\n        for(int i=0;i<ITERS;i++)\n        {\n            uv = fract(-uv.yx/s1)*s1;\n            uv.y /= -scale1;\n            uv= fract(-uv-((vec2(uv.x/scale-uv.y/scale1,uv.y/scale-uv.x/scale1)/(scale))))/scale1;\n            \n            //scale += (uv.x*(.005*fract(uv.x+iTime)));\n            //make it dance!\n        }\n        col[2] = abs(uv.y-uv.x);\n        col = ((col+col_prev.yzx))/2.125;\n\t}\n    fragColor = vec4(vec3(col*3.0),1.0);\n    \n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/fdsSzl.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "fdsXDf", "name": "Smiley Faces Colour Experiment", "author": "Williams3DWorld", "description": "Colour animated smiley faces.", "tags": ["2dshapes", "smileyfaces"], "likes": 0, "viewed": 54, "date": "1619379174", "time_retrieved": "2024-06-20T20:36:59.066899", "image_code": "float Circle(vec2 uv, vec2 p, float r, float blur) {\n    float d = length(uv - p);\n    return smoothstep(r, r - blur, d);\n}\n\nfloat Band(float t, float start, float end, float blur) {\n    float step1 = smoothstep(start-blur, start+blur, t);\n    float step2 = smoothstep(end+blur, end-blur, t);\n    return step1 * step2;\n}\n\nfloat Rectangle(vec2 uv,  vec2 p, float size, float left, float right, float bottom, float top, float blur) {\n    uv -= p;\n    uv /= size;\n    \n    float band1 = Band(uv.x, left, right, blur);\n    float band2 = Band(uv.y, bottom, top, blur);\n\n    return band1 * band2;\n}\n\nfloat Smiley(vec2 uv, vec2 p, float size) {\n    float blur = 0.05;\n    uv -= p; // translating coord system\n    uv /= size;\n\n    float mask = Circle(uv, vec2(0, 0), .5, blur);\n    mask -= Circle(uv, vec2(-.2, .2), .12, blur);\n    mask -= Circle(uv, vec2(.2, .2), .12, blur); \n    \n    float mouth = Circle(uv, vec2(0, 0), .38, blur);\n    mouth -= Circle(uv, vec2(0, .1), .38, blur);\n    mouth = max(mouth, 0.);\n    \n    mask -= mouth;\n    \n    return mask;\n}\n\nfloat random (vec2 st) {\n    return fract(sin(dot(st.xy,\n                         vec2(12.9898,78.233)))*\n        43758.5453123);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy; // 0 <> 1\n    \n    uv -= vec2(0.04, .934); // -0.5 <> 0.5\n    uv.x *= iResolution.x / iResolution.y;\n    \n    vec3 col = vec3(0.);\n\n    float mask = .0;\n    \n    for (float i = .0; i < 16.; i++) {\n        for (float j = .0; j < 9.; j++) {\n             mask += Smiley(uv, vec2(i * .11, j * .11), 0.08);\n        }\n    }\n\n    vec3 c = vec3(1., 0.5 + 0.5 * sin(iTime * 4.), 0.5 - 0.5 * sin(iTime * 4.));\n\n    col =  c * mask;\n    \n    fragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/fdsXDf.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "fdsXDr", "name": "Bitwise lichen", "author": "jarble", "description": "This fractal looks like moss-covered bricks or tiles.", "tags": ["fractal", "wall", "bricks", "bitwise", "ruins", "lichen"], "likes": 10, "viewed": 171, "date": "1618498296", "time_retrieved": "2024-06-20T20:36:59.066899", "image_code": "// Inspired by a discussion on hackaday at:\n// https://hackaday.com/2021/04/13/alien-art-drawn-with-surprisingly-simple-math/\n// Formula shared by \"Joe\" on that page..\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Scale and move to make things a litle more interesting t look at.\n    float scale = .5;\n    float trans = iTime * 25.0*10.0;\n    vec2 coord = scale*(fragCoord + vec2(trans,0.0));\n    \n    // Heart of color selection.\n    int val = ((int(coord.x) & int(coord.y)) % 3);\n    float result = 0.0;\n    vec3 col = vec3(0.0);\n    vec3 col_prev;\n    for(int i = 0; i < 9; i++){\n        col_prev = col;\n        coord.y += (4.0+result);\n        coord = coord.yx/(3.0);\n        result = ((result + float(val = ((int(coord.x) | int(coord.y)) % (3+val))))/(2.0));\n        col.x = (result+col.z)/2.0;\n        col = (fract((col.yzx))+col_prev)/2.0;\n    }\n    // Output.\n    fragColor = vec4((col),0.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/fdsXDr.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "fdsXRf", "name": "Stepped Time Remapping Functions", "author": "Tater", "description": "Something I've wanted for a while, visualizer here:\n[url]https://www.desmos.com/calculator/j6h3ket3hw[/url]\n\nI used it in this shader if you want a cooler example:\n[url]https://www.shadertoy.com/view/fssXzj[/url]", "tags": ["example", "tutorial"], "likes": 3, "viewed": 186, "date": "1618968075", "time_retrieved": "2024-06-20T20:36:59.066899", "image_code": "#define pi 3.1415926535\n#define rot(a) mat2(cos(a),sin(a),-sin(a),cos(a))\n//Thanks to Alan Wolfe in the shadertoy discord for suggesting to use monotonically increasing functions for this.\n\n//Play with the function here\n//https://www.desmos.com/calculator/j6h3ket3hw\n\n//t = initial Time\n//s1 = speed 1\n//s2 = speed 2\n//c = smoothing factor (1-30 works well)\nfloat timeRemap (float t, float s1, float s2, float c){\n    return 0.5*((s1-s2)*sqrt(c*c+1.0)*asin((c*cos(pi*t))/ sqrt(c*c+1.0))+(s1+s2)*c*t*pi)/(c*pi);\n}\n\n//Simpler version, same as before but c ranges from 0 to 3 ish (0.0-0.3 works best)\nfloat timeRemap2 (float t,float s1, float s2, float c){\n    return 0.5*(s2-s1)*(t-asin(cos(t*pi)/sqrt(c*c+1.0))/pi)+s1*t;\n    \n}\n//Same thing but without the smoothing\nfloat timeRemapEasy (float t, float s1, float s2){\n    return (s1-s2)*(fract(t)*step(1.0,mod(t,2.0))+floor(t*0.5))+t*s2;\n}\n\n//Worse version of the smoothing one but might be easier to remember?\nfloat timeRemapScuffed (float t, float s1, float s2){\nreturn (s1-s2)*(smoothstep(0.0,1.0,fract(t))*step(1.0,mod(t,2.0))+floor(t*0.5))+t*s2;}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-0.5*iResolution.xy)/iResolution.y;\n    float t = iTime*0.25;\n    vec3 col =vec3(0);\n    \n    \n    float speed1 = 15.0;\n    float speed2 = -2.0;\n    t = timeRemap2(t, speed1, speed2, 0.1)*4.0;\n    \n    //Crappy visualizer for the function (just look at the desmos link)\n    vec2 uv2=uv*15.0;\n    uv2.y += timeRemap2(-uv2.x, sin(iTime), cos(iTime), 0.1)*4.0;\n    col += vec3(step(max(abs(uv2.x)-5.0,abs(uv2.y)),0.3),0,0);\n    \n    uv*=rot(t);\n    col += vec3(step(length(uv+vec2(0,0.3)),0.075));\n\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/fdsXRf.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "fdsXRn", "name": "tractor-beam", "author": "tijit", "description": "draw a tri with texture coords (0,0) (1,0) (0,1)", "tags": ["tractor"], "likes": 0, "viewed": 64, "date": "1618190885", "time_retrieved": "2024-06-20T20:36:59.424145", "image_code": "// gif in game : https://twitter.com/yourbirlfriend/status/1381199731943120899\n\n//uniform float u_time;\n\nconst int LINES = 8;\nconst float LINE_WIDTH = .33;\n//const float PI = 3.14159;\nconst float PI_INV = 0.31830988;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //vec3 col = v_vColour.rgb;\n    vec3 col = vec3(.62, .74, 1.);\n    vec3 col2 = vec3(1.);\n    //vec2 st = v_vTexcoord.xy;\n    vec2 st = vec2(fragCoord.x, fragCoord.y) / min(iResolution.x, iResolution.y); //fragCoord;\n    //float alpha = 0.5 * v_vColour.a;\n    float alpha = .5;\n    // convert angle as a ratio from 0-1\n    float angle = fract(atan(st.y,st.x) * 2. * PI_INV);\n    \n    \n    float mixval = 0.;\n    \n    float r = length(st);\n    //float t = u_time / 120.;\n    float t = iTime / 2.;\n    \n    \n    \n    // lighten edge/sides\n    \n    float v2 = 0.25 * smoothstep(LINE_WIDTH, 0., abs(2.*abs(angle-.5) - 1.+LINE_WIDTH));\n    alpha += v2;\n    mixval += v2;\n    \n    \n    // lighten random lines\n    \n    \n    for (int i = 0; i < LINES; i++) {\n        float l = fract( sign(mod(float(i),2.) - .5 ) * t * sqrt(float(i)+1.) );\n        \n        v2 = 0.25 * smoothstep(LINE_WIDTH, 0., 2.*abs(angle-l));\n        \n        alpha += v2;\n        \n        v2 = 0.25 * smoothstep(LINE_WIDTH * .25, 0., 2.*abs(angle-l));\n        \n        mixval += v2 * .5;\n    }\n    \n    \n    // fade out approaching endpoint\n    alpha = clamp(alpha, 0., 1.);\n    alpha *= smoothstep(1., .75, st.x+st.y);\n    \n    alpha *= smoothstep(1., 1. - LINE_WIDTH * .5, 2.*abs(angle-.5));\n    \n    mixval = clamp(mixval, 0., 1.);\n    \n    col = mix(col, col2, mixval);\n    \n    //gl_FragColor = vec4(col, alpha) * texture2D( gm_BaseTexture, v_vTexcoord );\n    fragColor = vec4(col, 1.);\n    fragColor = vec4(col * alpha, 1.);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/fdsXRn.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "fdsXW7", "name": "twt/smile2", "author": "Tomnnn", "description": "2 more tutorials from \"the art of code\" on youtube", "tags": ["learning"], "likes": 3, "viewed": 46, "date": "1618711265", "time_retrieved": "2024-06-20T20:37:00.145340", "image_code": "#define S(a, b, t) smoothstep(a, b, t)\n#define sat(x) clamp(x, 0., 1.)\n\nfloat remap01(float a, float b, float t) {\n    return sat((t-a) / (b-a));\n}\n\nfloat remap(float a, float b, float c, float d, float t) {\n    return sat((t-a) / (b-a)) * (d-c) + c;\n}\n\nvec2 within(vec2 uv, vec4 rect) {\n    return (uv-rect.xy) / (rect.zw-rect.xy);\n}\n\nvec4 Eye(vec2 uv, float side, vec2 m, float face) {\n    uv -= .5;\n    uv.x *= side;\n    float d = length(uv);\n    vec4 irisCol = vec4(.3, .5, 1., 1.);\n    vec4 col = mix(vec4(1.), irisCol, S(.1, .7, d) * .5);\n    col.a = S(.5, .48, d);\n    \n    // change sclera color with time\n    col.rgb = mix(col.rgb, vec3(1., .25, .35), 1. - face);\n    \n    // shadow around inner eyes\n    col.rgb *= 1. - S(.45, .5, d) * .5 * sat(-uv.y - uv.x * side);\n    \n    d = length(uv - m*.5);\n    // tint sclera\n    col.rgb = mix(col.rgb, vec3(0.), S(.3, .28, d));\n    \n    // iris\n    irisCol.rgb *= 1. + S(.3, .05, d);\n    // irisCol.rgb = mix(irisCol.rgb, vec3(.8, .1, .1), 1. - face);\n    float irisMask = S(.28, .25, d);\n    col.rgb = mix(col.rgb, irisCol.rgb, irisMask);\n    \n    d = length(uv - m*.65);\n    // pupil\n    float pupilSize = mix(.1, .25, face);\n    float pupilMask = S(pupilSize, pupilSize * .85, d);\n    pupilMask *= irisMask; // contain pupil in iris\n    col.rgb = mix(col.rgb, vec3(0.), pupilMask);\n    \n    // eye highlight\n    float et = iTime * 3.;\n    vec2 offs = vec2(sin(et + uv.y*15.), sin(et + uv.x*15.)) * .03 * (face);\n\n    uv += offs;\n\n    float highlight = S(.1, .09, length(uv-vec2(-.15, .15)));\n    highlight += S(.07, .05, length(uv+vec2(-.08, .08)));\n    col.rgb = mix(col.rgb, vec3(1.), highlight);\n    \n    return col;\n}\n\nvec4 Mouth(vec2 uv, float face) {\n    uv -= .5;\n    vec4 col = vec4(.5, .18, .05, 1.);\n    \n    uv.y *= 1.5;\n    uv.y += uv.x * uv.x * 2. * (1. - 2.*face);\n    uv.x *= mix(1., 2., face);\n    float d = length(uv);\n    col.a = S(.5, .48, d);\n    \n    float td = length(uv - vec2(0., .6));\n    \n    // teeth + shadow\n    vec3 toothCol = vec3(1.) * S(.6, .35, d);\n    col.rgb = mix(col.rgb, toothCol, S(.4, .37, td));\n    \n    // tongue\n    td = length(uv + vec2(0., .5));\n    col.rgb = mix(col.rgb, vec3(1., .5, .5), S(.5, .2, td));\n    \n    return col;\n}\n\nvec4 Head(vec2 uv, float face) {\n    vec4 col = vec4(.9, .65, .1, 1.);\n    col.rgb = mix(col.rgb, vec3(0.9, .8, .5), 1. - face);\n    \n    float d = length(uv);\n    \n    col.a = S(.5, .49, d);\n    \n    float edgeShade = remap01(.35, .5, d);\n    edgeShade *= edgeShade;\n    col.rgb *= 1. - edgeShade * .5;\n    \n    // outline\n    col.rgb = mix(col.rgb, vec3(.6, .3, .1), S(.47, .48, d));\n    \n    //\n    float highlight = S(.41, .405, d);\n    highlight *= remap(.41, -.1, .75, 0., uv.y);\n    highlight *= S(.18, .19, length(uv - vec2(.21, .07)));\n    col.rgb = mix(col.rgb, vec3(1.), highlight);\n    \n    // cheek\n    d = length(uv - vec2(.25, -.2));\n    float cheek = S(.2, .01, d) * .4;\n    cheek *= S(.17, .16, d);\n    vec3 cheekColor = mix(vec3(1., .1, .1), vec3(.1, .5, .7), 1. - face);\n    col.rgb = mix(col.rgb, cheekColor, cheek);\n    \n    return col;\n}\n\nvec4 Smile(vec2 uv, vec2 m, float face) {\n    vec4 col = vec4(0.);\n    \n    float side = sign(uv.x);\n    \n    // mirror\n    uv.x = abs(uv.x);\n    \n    vec4 head = Head(uv, face);\n    vec4 eye = Eye(within(uv, vec4(.03, -.1, .37, .25)), side, m, face);\n    vec4 mouth = Mouth(within(uv, vec4(-.2, -.35, .2, -.15)), face);\n    \n    col = mix(col, head, head.a);\n    col = mix(col, eye, eye.a);\n    col = mix(col, mouth, mouth.a);\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    uv -= 0.5;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    vec2 m = iMouse.xy / iResolution.xy;\n    m -= .5;\n    \n    float face = cos(iTime) * .5 + .5;\n    \n    uv -= m * (.25 - dot(uv, uv));\n\n    // Output to screen\n    fragColor = Smile(uv, m, face);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/fdsXW7.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "fdsXWX", "name": "Material Maker Experiment 001", "author": "PauloFalcao", "description": "Made in materialmaker just using 7 nodes! :)", "tags": ["generated", "materialmaker", "nodes"], "likes": 7, "viewed": 164, "date": "1619360438", "time_retrieved": "2024-06-20T20:37:01.751556", "image_code": "// Material Maker Experiment 001\n// By PauloFalcao\n//\n// Made in materialmaker just using 7 nodes! :)\n//\n// MaterialMaker is a nodebased shader maker to make procedural textures\n// With custom nodes GLSL nodes created directly in the tool,\n// it's possible to make complex stuff like raymarching :)\n//\n// It's also possible to export the generated code to Shadertoy!\n//\n// I made a library with Ray Marching nodes\n// 1st version 0.01 have 44 new nodes\n// Some nodes are based in code from other authors from shadertoy\n// I always refer the shader author and the shadertoy original code\n// The idea is to reuse the code to quicky create something without coding experience\n// Or just focus on the code of a single node\n//\n// You need Material Maker - https://rodzilla.itch.io/material-maker\n// And my library - https://github.com/paulofalcao/MaterialMakerRayMarching\n// This Material Maker graph is here\n// https://raw.githubusercontent.com/paulofalcao/MaterialMakerRayMarching/main/Examples/pxf001.mms\n// Just copy paste the code into Material Maker and the graph will appear! :)\n// Or save the file and use \"Edit\"->\"Load Selection\"\n// \n\n\nvec3 v4v4_rotate(vec3 p, vec3 a) {\n\tvec3 rv;\n\tfloat c;\n\tfloat s;\n\tc = cos(a.x);\n\ts = sin(a.x);\n\trv.x = p.x;\n\trv.y = p.y*c+p.z*s;\n\trv.z = -p.y*s+p.z*c;\n\tc = cos(a.y);\n\ts = sin(a.y);\n\tp.x = rv.x*c+rv.z*s;\n\tp.y = rv.y;\n\tp.z = -rv.x*s+rv.z*c;\n\tc = cos(a.z);\n\ts = sin(a.z);\n\trv.x = p.x*c+p.y*s;\n\trv.y = -p.x*s+p.y*c;\n\trv.z = p.z;\n\treturn rv;\n}\n\nconst float PI=3.14159265359;\n\nvec2 equirectangularMap(vec3 dir) {\n\tvec2 longlat = vec2(atan(dir.y,dir.x),acos(dir.z));\n \treturn longlat/vec2(2.0*PI,PI);\n}\n\n\n//Simple HDRI START\n\n//Hash without Sine Dave_Hoskins\n//https://www.shadertoy.com/view/4djSRW \nfloat Simple360HDR_hash12(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nfloat Simple360HDR_noise(vec2 v){\n  vec2 v1=floor(v);\n  vec2 v2=smoothstep(0.0,1.0,fract(v));\n  float n00=Simple360HDR_hash12(v1);\n  float n01=Simple360HDR_hash12(v1+vec2(0,1));\n  float n10=Simple360HDR_hash12(v1+vec2(1,0));\n  float n11=Simple360HDR_hash12(v1+vec2(1,1));\n  return mix(mix(n00,n01,v2.y),mix(n10,n11,v2.y),v2.x);\n}\n\nfloat Simple360HDR_noiseOct(vec2 p){\n  return\n    Simple360HDR_noise(p)*0.5+\n    Simple360HDR_noise(p*2.0+13.0)*0.25+\n    Simple360HDR_noise(p*4.0+23.0)*0.15+\n    Simple360HDR_noise(p*8.0+33.0)*0.10+\n    Simple360HDR_noise(p*16.0+43.0)*0.05;\n}\n\nvec3 Simple360HDR_skyColor(vec3 p){\n\tvec3 s1=vec3(0.2,0.5,1.0);\n\tvec3 s2=vec3(0.1,0.2,0.4)*1.5;\n    vec3 v=(Simple360HDR_noiseOct(p.xz*0.1)-0.5)*vec3(1.0);\n\tfloat d=length(p);\n    return mix(s2+v,s1+v*(12.0/max(d,20.0)),clamp(d*0.1,0.0,1.0));\n}\n\nvec3 Simple360HDR_floorColor(vec3 p){\n    vec3 v=(Simple360HDR_noiseOct(p.xz*0.1)*0.5+0.25)*vec3(0.7,0.5,0.4);\n    return v;\n}\n\nvec3 Simple360HDR_renderHDR360(vec3 rd, vec3 sun){\n    vec3 col;\n\tvec3 p;\n\tvec3 c;\n\tif (rd.y>0.0) {\n        p=rd*(5.0/rd.y);\n        c=Simple360HDR_skyColor(p);\n    } else {\n        p=rd*(-10.0/rd.y);\n        c=Simple360HDR_floorColor(p);\n\t\tc=mix(c,vec3(0.5,0.7,1.0),clamp(1.0-sqrt(-rd.y)*3.0,0.0,1.0));\n\t}\n\tvec3 skycolor=vec3(0.1,0.45,0.68);\n\tfloat d=length(p);\n\t\n\tfloat ds=clamp(dot(sun,rd),0.0,1.0);\n\tvec3 sunc=(ds>0.9997?vec3(2.0):vec3(0.0))+pow(ds,512.0)*4.0+pow(ds,128.0)*vec3(0.5)+pow(ds,4.0)*vec3(0.5);\n    if (rd.y>0.0){\n\t\tc+=vec3(0.3)*pow(1.0-abs(rd.y),3.0)*0.7;\n\t} \n    return c+sunc;\n}\n\nvec3 Simple360HDR_make360hdri(vec2 p, vec3 sun){\n    float xPI=3.14159265359;\n    vec2 thetaphi = ((p * 2.0) - vec2(1.0)) * vec2(xPI,xPI/2.0); \n    vec3 rayDirection = vec3(cos(thetaphi.y) * cos(thetaphi.x), sin(thetaphi.y), cos(thetaphi.y) * sin(thetaphi.x));\n    return Simple360HDR_renderHDR360(rayDirection,sun);\n}\n//Simple HDRI END\n\nconst float p_o1356810_CamY = 1.450000000;\nconst float p_o1356810_LookAtX = 0.000000000;\nconst float p_o1356810_LookAtY = 0.000000000;\nconst float p_o1356810_LookAtZ = 0.000000000;\nconst float p_o1356810_CamD = 1.500000000;\nconst float p_o1356810_CamZoom = 0.695000000;\nconst float p_o1356810_Reflection = 0.179000000;\nconst float p_o1356810_Specular = 1.000000000;\nconst float p_o1356810_Pow = 275.430000000;\nconst float p_o1356810_SunX = 0.439999998;\nconst float p_o1356810_SunY = 1.480000019;\nconst float p_o1356810_SunZ = -0.976000011;\nconst float p_o1356810_AmbLight = 0.250000000;\nconst float p_o1356810_AmbOcclusion = 0.391000000;\nconst float p_o1356810_Shadow = 0.921000000;\nconst float p_o1356813_r = 0.069900000;\n\nfloat o1356807_input_obj3d(vec3 p) {\n    float o1356813_0_1_sdf3d = length((p))-p_o1356813_r;\n    return o1356813_0_1_sdf3d;\n}\n\nconst float p_o1356804_smooth = 0.000990000;\nconst float p_o1356801_x = 0.086000000;\nconst float p_o1356801_y = 0.060000000;\nconst float p_o1356801_z = 0.096000000;\n\nvec4 o1356807_input_trans3d(vec4 p) {\n    vec4 o1356798_0_1_v4v4 = (vec4(v4v4_rotate((vec4((vec4(vec3(sqrt((p).xyz*(p).xyz+p_o1356804_smooth)),(p).w)).xyz-vec3(p_o1356801_x, p_o1356801_y, p_o1356801_z),(vec4(vec3(sqrt((p).xyz*(p).xyz+p_o1356804_smooth)),(p).w)).w)).xyz, -vec3((sin(iTime*4.0)*16.0), (sin(iTime*2.2)*16.0), (sin(iTime*1.3)*16.0))*0.01745329251), (vec4((vec4(vec3(sqrt((p).xyz*(p).xyz+p_o1356804_smooth)),(p).w)).xyz-vec3(p_o1356801_x, p_o1356801_y, p_o1356801_z),(vec4(vec3(sqrt((p).xyz*(p).xyz+p_o1356804_smooth)),(p).w)).w)).w));\n    vec4 o1356795_0_1_v4v4 = o1356798_0_1_v4v4;\n    vec4 o1356801_0_1_v4v4 = o1356795_0_1_v4v4;\n    vec4 o1356804_0_1_v4v4 = o1356801_0_1_v4v4;\n\n    return o1356804_0_1_v4v4;\n}\n\nfloat o1356807_input_custombool(vec2 uv) {\n    return min((uv).x,(uv).y);\n}\n\nfloat for_fold_o1356807(vec4 p) {\n  for(int i=0;i<6;i++){\n    p=o1356807_input_trans3d(p);\n  }\n  return o1356807_input_obj3d(p.xyz);\n}\n\nfloat for_min_o1356807(vec4 p) {\n  float m=999999.0;\n  for(int i=0;i<6;i++){\n    p=o1356807_input_trans3d(p);\n\tfloat d=o1356807_input_obj3d(p.xyz);\n\tm=min(m,d);\n  }\n  return m;\n}\n\nfloat for_custom_o1356807(vec4 p) {\n  float m=999999.0;\n  for(int i=0;i<6;i++){\n    p=o1356807_input_trans3d(p);\n\tfloat d=o1356807_input_obj3d(p.xyz);\n\tm=o1356807_input_custombool(vec2(m,d));\n  }\n  return m;\n}\n\nfloat o1356810_input_sdf_a(vec3 p) {\n    float o1356807_0_1_sdf3d = for_fold_o1356807(vec4((p),0.0));\n    return o1356807_0_1_sdf3d;\n}\n\nvec3 o1356810_input_tex3d_a(vec4 p) {\n    return vec3(1.0,0.1,0.1);\n}\n\nfloat o1356810_input_sdf_b(vec3 p) {\n    return max((p).y+1.0,length(vec3((p).x,(p).y+1.0,(p).z))-10.0);\n}\n\nvec3 o1356810_input_tex3d_b(vec4 p) {\n    return vec3(mod(floor((p).x*2.0)+floor((p).z*2.0),2.0))*0.9+0.1;\n}\n\nvec3 o1356810_input_hdri(vec2 uv) {\n    return Simple360HDR_make360hdri(vec2((uv).x,-(uv).y+1.0),normalize(vec3(-p_o1356810_SunX,p_o1356810_SunY,-p_o1356810_SunZ)));\n}\n\nvec2 input_o1356810(vec3 p) {\n    float sdfa=o1356810_input_sdf_a(p);\n\tfloat sdfb=o1356810_input_sdf_b(p);\n\tif (sdfa<sdfb) {\n\t  return vec2(sdfa,0.0);\n\t} else {\n\t  return vec2(sdfb,1.0);\n\t}\n}\n\n//tetrahedron normal by PauloFalcao\n//https://www.shadertoy.com/view/XstGDS\nvec3 normal_o1356810(vec3 p){  \n  const vec3 e=vec3(0.001,-0.001,0.0);\n  float v1=input_o1356810(p+e.xyy).x;\n  float v2=input_o1356810(p+e.yyx).x;\n  float v3=input_o1356810(p+e.yxy).x;\n  float v4=input_o1356810(p+e.xxx).x;\n  return normalize(vec3(v4+v1-v3-v2,v3+v4-v1-v2,v2+v4-v3-v1));\n}\n\nvoid march_o1356810(inout float d,inout vec3 p,inout vec2 dS, vec3 ro, vec3 rd){\n    for (int i=0; i < 500; i++) {\n    \tp = ro + rd*d;\n        dS = input_o1356810(p);\n        d += dS.x;\n        if (d > 50.0 || abs(dS.x) < 0.0001) break;\n    }\n}\n\n//from https://www.shadertoy.com/view/lsKcDD\nfloat calcAO_o1356810( in vec3 pos, in vec3 nor ){\n\tfloat occ = 0.0;\n    float sca = 1.0;\n    for( int i=0; i<5; i++ ){\n        float h = 0.001 + 0.25*float(i)/4.0;\n        float d = input_o1356810( pos + h*nor ).x;\n        occ += (h-d)*sca;\n        sca *= 0.98;\n    }\n    return clamp( 1.0 - 1.6*occ, 0.0, 1.0 );    \n}\n\n//from https://www.shadertoy.com/view/lsKcDD\nfloat calcSoftshadow_o1356810( in vec3 ro, in vec3 rd, in float mint, in float tmax){\n\tfloat res = 1.0;\n    float t = mint;\n    float ph = 1e10; // big, such that y = 0 on the first iteration\n    for( int i=0; i<32; i++ ){\n\t\tfloat h = input_o1356810( ro + rd*t ).x;\n        res = min( res, 10.0*h/t );\n        t += h;\n        if( res<0.0001 || t>tmax ) break;  \n    }\n    return clamp( res, 0.0, 1.0 );\n}\n\nvec3 raymarch_o1356810(vec2 uv) {\n    uv-=0.5;\n\tvec3 cam=vec3((sin(iTime*0.1)*4.0),p_o1356810_CamY,(cos(iTime*0.13)*4.0))*p_o1356810_CamZoom;\n\tvec3 lookat=vec3(p_o1356810_LookAtX,p_o1356810_LookAtY,p_o1356810_LookAtZ);\n\tvec3 ray=normalize(lookat-cam);\n\tvec3 cX=normalize(cross(vec3(0.0,1.0,0.0),ray));\n\tvec3 cY=normalize(cross(cX,ray));\n\tvec3 rd = normalize(ray*p_o1356810_CamD+cX*uv.x+cY*uv.y);\n\tvec3 ro = cam;\n\t\n\tfloat d=0.;\n\tvec3 p=vec3(0);\n\tvec2 dS=vec2(0);\n\tmarch_o1356810(d,p,dS,ro,rd);\n\t\n    vec3 color=vec3(0.0);\n\tvec3 objColor=(dS.y<0.5)?o1356810_input_tex3d_a(vec4(p,1.0)):o1356810_input_tex3d_b(vec4(p,1.0));\n\tvec3 light=normalize(vec3(p_o1356810_SunX,p_o1356810_SunY,p_o1356810_SunZ));\n\tif (d<50.0) {\n\t    vec3 n=normal_o1356810(p);\n\t\tfloat l=clamp(dot(-light,-n),0.0,1.0);\n\t\tvec3 ref=normalize(reflect(rd,-n));\n\t\tfloat r=clamp(dot(ref,light),0.0,1.0);\n\t\tfloat cAO=mix(1.0,calcAO_o1356810(p,n),p_o1356810_AmbOcclusion);\n\t\tfloat shadow=mix(1.0,calcSoftshadow_o1356810(p,light,0.05,5.0),p_o1356810_Shadow);\n\t\tcolor=min(vec3(max(shadow,p_o1356810_AmbLight)),max(l,p_o1356810_AmbLight))*max(cAO,p_o1356810_AmbLight)*objColor+pow(r,p_o1356810_Pow)*p_o1356810_Specular;\n\t\t//reflection\n\t\td=0.01;\n\t\tmarch_o1356810(d,p,dS,p,ref);\n\t\tvec3 objColorRef=vec3(0);\n\t\tif (d<50.0) {\n\t\t\tobjColorRef=(dS.y<0.5)?o1356810_input_tex3d_a(vec4(p,1.0)):o1356810_input_tex3d_b(vec4(p,1.0));\n\t\t\tn=normal_o1356810(p);\n\t\t\tl=clamp(dot(-light,-n),0.0,1.0);\n\t\t\tobjColorRef=max(l,p_o1356810_AmbLight)*objColorRef;\n\t\t} else {\n\t\t\tobjColorRef=o1356810_input_hdri(equirectangularMap(ref.xzy)).xyz;\n\t\t}\n\t\tcolor=mix(color,objColorRef,p_o1356810_Reflection);\n\t} else {\n\t\tcolor=o1356810_input_hdri(equirectangularMap(rd.xzy)).xyz;\n\t}\n\treturn color;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    float minSize = min(iResolution.x, iResolution.y);\n    vec2 UV = vec2(0.0, 1.0) + vec2(1.0, -1.0) * (fragCoord-0.5*(iResolution.xy-vec2(minSize)))/minSize;\n    vec3 o1356810_0_1_rgb = raymarch_o1356810((UV));\n    fragColor = vec4(o1356810_0_1_rgb, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/fdsXWX.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "fdXSDl", "name": "Sphere raymarching", "author": "ddpms", "description": "basic raymarching", "tags": ["raymarching", "sphere"], "likes": 1, "viewed": 37, "date": "1619403460", "time_retrieved": "2024-06-20T20:37:01.751556", "image_code": "#define PI 3.1415\nconst float EPS = 0.001;\nconst float MAX = 100.;\n\n// rotate\nmat2 rot(float a){\n    float ca = cos(a);\n    float sa = sin(a);\n    return mat2(ca,sa,-sa,ca);\n}\n\n// Sphere SDF\nfloat sphere(vec3 pos){\n    vec3 loc = vec3(0.);\n    float rad = 1.5;\n    return length(pos-loc) - rad;\n}\n\n// BOX SDF\nfloat box(vec3 p, vec3 r){\n    vec3 ap = abs(p) - r;\n    return length(max(vec3(0), ap)) + \n           min(0., max(ap.x, max(ap.y,ap.z)));\n}\n\nfloat SDF(vec3 p){\n    float t1 = iTime;\n    p.xy *= rot(t1*0.7);\n    p.yz *= rot(t1);\n    \n    //return box(p, vec3(1.));\n    return sphere(p);\n}\n\nfloat rayMarch(vec3 cam, vec3 dir){\n    float md = 0.;\n    \n    vec3 pos;\n    \n    // raymarching loop\n    for(int i=0; i<100; ++i){\n        pos = cam + dir*md;\n        \n        float dist = SDF(pos);\n        if(dist<EPS){\n            return md;\n        }\n        md += dist;\n        if(md>MAX){\n          return MAX;\n        }\n    }\n    return MAX;\n}\n\n//normal\nvec3 getN(vec3 p){ \n    vec2 e = vec2(EPS, 0.);\n    float dx, dy, dz;\n    dx = SDF(p)-SDF(p-e.xyy);\n    dy = SDF(p)-SDF(p-e.yxy);\n    dz = SDF(p)-SDF(p-e.yyx);\n    return normalize(vec3(dx, dy, dz));\n}\n\nvec3 fresnel(in vec3 f0, in float product){\n    return mix(f0, vec3(1.0), pow(1.0 - product, 5.0));\n}\n\nvec3 lightCal(vec3 d, vec3 s, float alpha, vec3 p, vec3 cam, vec3 li){\n    vec3 N = getN(p); // normal\n    vec3 L = normalize(li-p); // light\n    vec3 R = normalize(reflect(-L, N)); // reflect vector\n    vec3 C = normalize(cam-p); // view vector\n    \n    float NdL = clamp(dot(N, L), 0., 1.);\n    float RdC = clamp(dot(R, C), 0., 1.);\n    \n    vec3 diffuse = NdL * d;\n    vec3 specular = pow(RdC, alpha) * s; \n    \n    vec3 H = normalize(L+C);\n    float HdC = dot(H, C);\n    vec3 temp = vec3(0.2); \n    vec3 f = fresnel(temp, HdC); \n    diffuse = NdL * d * (1.-f);\n    specular = pow(RdC, alpha) * s*f;\n    \n\treturn diffuse + specular;\n}\n\nvec3 lights(vec3 a, vec3 d, vec3 s, float alpha, vec3 p, vec3 cam){\n    vec3 col = a*0.2;\n    vec3 lpos = vec3(10.);\n    col += lightCal(d,s,alpha,p,cam,lpos);\n    return col;\n}\n\nvoid camRot(inout vec3 p){\n    float t1 = iTime;\n    p.xy *= rot(t1);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    vec2 coord = fragCoord/iResolution.xy;\n    coord = coord * 2. - 1.;\n    coord.x *= iResolution.x/iResolution.y;\n    \n    vec3 cam = vec3(0., 0., 3.);\n    vec3 dir = normalize(vec3(coord, -1.));\n    camRot(cam);\n    camRot(dir);\n    \n    \n    float dist = rayMarch(cam, dir);\n    vec3 col;\n    vec3 bgCol = vec3(0.250,0.250,0.25);\n    \n    // ray matching no\n    if(dist>MAX-EPS){\n        col = bgCol;\n        //col = mix(vec3(1.), bgCol, pow(dot(dir,vec3(0.,0., -1.)), 10.));\n        fragColor = vec4(col, 1.);\n        return;\n    }\n    // ray matching ok\n    vec3 a = bgCol; // ambient light\n    vec3 d = vec3(1.); // diffuse light\n    vec3 s = vec3(1.); // specular light\n    float alpha = 100.;\n    vec3 p = cam + dir*dist; // position\n    \n    col = lights(a,d,s,alpha,p,cam);\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/fdXSDl.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "fdXSDS", "name": "fake parula and heatmap", "author": "iradicator", "description": "Heatmap (left) goes from \"cold\" to \"hot\" according to (approximately) the luminance\n\n\"fake parula\" (right) inspired by https://www.mathworks.com/help/matlab/ref/parula.html\n\nThe top bar at the bottom is the heatmap and the one below is fake parula", "tags": ["2d", "color", "transformation", "heatmap", "auxiliary", "parula"], "likes": 3, "viewed": 94, "date": "1619129540", "time_retrieved": "2024-06-20T20:37:01.751556", "image_code": "float luminance(in vec3 c)\n{\n  return dot(vec3(0.299, 0.587, 0.114), c);\n}\n\nfloat cheaplobe(in float x, in float m, in float w)\n{\n  return smoothstep(m - w, m, x) * smoothstep(m + w, m, x);\n}\n\nvec3 heatmap(in float c) \n{\n  return pow(0.5 * (1.0 + cos(3.1 * c - vec3(2.7, 1.3, -0.2))), vec3(3.0,3.0,4.0));\n}\nvec3 heatmap(in vec3 c) \n{\n  return pow(0.5 * (1.0 + cos(3.1 * c - vec3(2.7, 1.3, -0.2))), vec3(3.0,3.0,4.0));\n}\n\nvec3 parula(in vec3 c) \n{\n  float l = luminance(c);\n  vec3 d = vec3(\n      -0.1 + 0.22*cheaplobe(l,0.83,0.19) - 0.07*cheaplobe(l,0.55,0.16),\n      0.02 - 0.21*cheaplobe(l,0.83,0.26) - 0.23*cheaplobe(l,-0.02,0.14) - 0.03*cheaplobe(l,0.59,0.12),\n           - 0.11*cheaplobe(l,0.57,0.2)\n  );\n  vec3 w = vec3(0.52,0.5,0.53) + vec3(0.52,0.52,0.45) * sin(vec3(2.80,2.80,2.04) * (c-vec3(0.4,0.4,-0.63)));\n  vec3 p = vec3(mix(0.7,0.8,c.r),mix(0.3,0.7,c.g),mix(2.9,2.2,c.b));\n  return pow(d + pow(w, p), vec3(1.5));\n}\nvec3 parula(in float c) \n{\n  vec3 d = vec3(\n      -0.1 + 0.22*cheaplobe(c,0.83,0.19) - 0.07*cheaplobe(c,0.55,0.16),\n      0.02 - 0.21*cheaplobe(c,0.83,0.26) - 0.23*cheaplobe(c,-0.02,0.14) - 0.03*cheaplobe(c,0.59,0.12),\n           - 0.11*cheaplobe(c,0.57,0.2)\n  );\n  vec3 w = vec3(0.52,0.5,0.53) + vec3(0.52,0.52,0.45) * sin(vec3(2.80,2.80,2.04) * (vec3(c)-vec3(0.4,0.4,-0.63)));\n  vec3 p = vec3(mix(0.7,0.8,c),mix(0.3,0.7,c),mix(2.9,2.2,c));\n  return pow(d + pow(w, p), vec3(1.5));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n\n    vec3 col = texture(iChannel0, uv).rgb;\n    \n    float l = uv.x - (0.5*sin(1.23*iTime)+0.5);\n    col = mix(heatmap(col), parula(col),smoothstep(0.0,2.0/iResolution.x,l));\n    col = mix(vec3(0.0),col,smoothstep(0.0,2.0/iResolution.x,abs(l)));\n    \n    if (uv.y < 0.10) col = heatmap(vec3(uv.x));\n    if (uv.y < 0.05) col = parula(vec3(uv.x));\n\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": "4dfGRn", "previewfilepath": "/media/ap/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/fdXSDS.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "fdXSDX", "name": "大龙猫 - OpArt #2", "author": "totetmatt", "description": "Rework of OpArt 1. Now the rotation and scale are linked with a simple dot product.", "tags": ["opart"], "likes": 11, "viewed": 190, "date": "1619335731", "time_retrieved": "2024-06-20T20:37:01.751556", "image_code": "float box(vec2 uv,vec2 b){\n    vec2 q = abs(uv)-b;\n    return length(max(q,vec2(0.)))+ min(max(q.x,q.y),0.);\n}\nvec3 pal(float t){\n    return vec3(.5,.4,.5)+vec3(.5,.4,.5)*cos(6.28*(vec3(1.,1.,1.)*t+vec3(.40,.55,.60)));\n}\nmat2 rot(float a){float c=cos(a),s=sin(a);return mat2(c,-s,s,c);}\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = (fragCoord.xy -.5* iResolution.xy)/iResolution.y;\n    float tempo=clamp(sin(iTime*.33),0.,.5);\n    uv*=4.+tempo;\n    uv+=fract(iTime*.01)*3.1415*2.;\n\n    uv*=rot(.785);\n    vec2 id = floor(uv);\n   uv = fract(uv)-.5;\n    if(mod(id.x,2.)==1.) { uv.x*=-1.;}\n        if(mod(id.y,2.)==1.) { uv.y*=-1.;}\n    vec3 col = vec3(.1);\n    float ll = 50.;\n     float  a= 1./30.;\n      if(uv.x >uv.y){\n      a+=sin(uv.y*4.)*.05+.05;\n      }\n      else {\n       a+=sin(uv.x*4.)*.05+.05;\n      }\n      a+=clamp(cos(iTime*.99)*.5,-.00,.25);\n     float rto = dot(vec2(1,1),vec2(1,0)*rot(3.1415*a));\n     \n     float d = 0.;\n    for(float i=0.;i<=ll;i++){\n    float l = box(uv,vec2(1.0));\n      \n\n      l = smoothstep(0.02,0.00099,(abs(l)-(.005-(1.-i)*.005)));\n      \n\n      d+=l;\n     \n      uv*=rot(3.1415*a);\n      \n      float q = rto;\n      uv*= q;\n  \n      \n    }\n    //d= d/ll;\n    \n    col = mix(vec3(0.1)+pal(tempo),vec3(.3,.5,.7),vec3(d));pal(d/ll);\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/fdXSDX.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "fdXSWl", "name": "The Deathstar of Menger", "author": "oo_miguel", "description": "My first Menger based shader", "tags": ["procedural", "fractal", "menger"], "likes": 1, "viewed": 46, "date": "1619444703", "time_retrieved": "2024-06-20T20:37:01.757622", "image_code": "\nfloat sdSphere( vec3 p, float s )\n{\n  return length(p)-s;\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat sdCross( in vec3 p )\n{\n  float da = sdBox(p.xyz,vec3(99.,1.0,1.0));\n  float db = sdBox(p.yzx,vec3(1.0,99.,1.0));\n  float dc = sdBox(p.zxy,vec3(1.0,1.0,99.));\n  return min(da,min(db,dc));\n}\n\nmat3 rotationMatrix(vec3 axis, float angle)\n{\n    axis = normalize(axis);\n    float s = sin(angle);\n    float c = cos(angle);\n    float oc = 1.0 - c;\n    \n    return mat3(oc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s,\n                oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s,\n                oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c);\n                \n}\n\nfloat map( in vec3 p )\n{\n   mat3 rot_obj=rotationMatrix(vec3(0,0,1),0.2*iTime);\n   mat3 rot_obj2=rotationMatrix(vec3(1,0,0),0.1*iTime);\n   p*=rot_obj*rot_obj2;\n\n   float glow4=mod((iTime+2.),8.)-3.;\n   float glow5=mod((iTime+4.),8.)-3.;\n   float glow6=mod((iTime+6.),8.)-3.;\n   \n   p-=vec3(0,0,0); \n   //float d = sdBox(p,vec3(1.0));\n   float d = sdSphere(p,1.2);\n   \n   if(p.y>-0.8)\n   if(p.y+0.7>glow6&&p.y-0.7<glow6){\n        float falloff = 1. - abs(glow6-p.y)/0.7;\n        //d-=falloff*falloff*0.2;\n        if(p.y>0.)d-=falloff*p.y*0.4;\n        \n    }\n    \n   float s = 1.;\n   for( int m=0; m<5; m++ )\n   {\n      vec3 a = mod( p*s, 2.0 )-1.0;\n      s *= 3.;\n      vec3 r = 1.0 - 3.0*abs(a);\n      float c = sdCross(r)/s;\n      if(p.y>-0.8)\n      if(p.y+0.7>glow4&&p.y-0.7<glow4){\n        float falloff = 1. - abs(glow4-p.y)/0.7;\n        if(m==1)c+=falloff/10.;\n       }\n\n      d = max(d,c);\n   }\n   \n\n   if(p.y>-0.8)\n   if(p.y+0.7>glow5&&p.y-0.7<glow5){\n        float falloff = 1. - abs(glow5-p.y)/0.7;\n        d+=falloff/200.;\n    }\n    \n   return d;\n}\n\n\nfloat intersect( in vec3 ro, in vec3 rd )\n{\n    int st=0;\n    for(float t=0.0; t<10.0; )\n    {\n        st++;\n        float h = map(ro + rd*t);\n        if( h<0.0002  ) return t;\n        t += h; //min(h,1.);\n        //if(st==100)break;\n    }\n    return -1.;\n}\n\nvec3 normal(vec3 p){\n\tfloat d = map(p);\n    vec2  e = vec2(.0001, 0);\n    vec3  n = d - vec3(map(p-e.xyy),map(p-e.yxy),map(p-e.yyx));\n    return normalize(n);\n}\n\n\nfloat light(vec3 p, vec3 light_pos) {\n    vec3 light_dir = normalize(light_pos-p);\n    vec3 n = normal(p);\n    vec3 l = normalize(light_pos-p);\n    float scene=mod(iTime,20.0);\n    if(scene>6.&&scene<12.){\n    return clamp(dot(n, l), 0.1, 1.);\n    }\n    if(intersect(p+n*0.0003, light_dir)>0.)return (0.2*clamp(dot(n, l), 0., 1.));\n    return clamp(dot(n, l), 0.1, 1.);\n}\n\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    vec3 ro;\n    float l;\n    float scene=mod(iTime,20.0);\n    if(scene>6.&&scene<12.){\n     \n        ro = vec3(-0.3,0.1,0.3);\n    }\n    else{\n        ro = vec3(-3.3  ,1,1.5);\n    \n    }\n    \n    mat3 rot_cam=rotationMatrix(vec3(0,1,0),2.);\n    mat3 rot_cam2=rotationMatrix(vec3(0,0,1),-0.25);\n    vec3 rd = normalize(vec3(uv.x, uv.y, 1.))*rot_cam*rot_cam2;\n    \n    float d = intersect(ro, rd);\n    if(d<0.){\n        fragColor=vec4(vec3(0.04,0.,0.06),1.); \n        return;\n    }\n    vec3  p = ro + rd * d;\n    \n    if(scene>6.&&scene<12.){\n        l=light(p, vec3(-0.2,0.2,0.2));    \n    }\n    else{\n         l=light(p, vec3(-3,-2,0));\n    }\n    \n    \n    \n    float glow=mod(iTime,4.)-2.;\n    float glow2=mod(0.5*iTime,2.)+2.;\n    float glow3=mod(iTime,1.)-1.;\n    \n    mat3 rot_obj=rotationMatrix(vec3(0,0,1),0.2*iTime);\n    mat3 rot_obj2=rotationMatrix(vec3(1,0,0),0.1*iTime);\n    vec3 pp=p*rot_obj*rot_obj2;\n    float c=floor(1.+(pp.y+1.)*2.)/7.;\n   \n    fragColor=vec4(vec3(l*.7,l*c,l*.2),1.);\n    if(p.y+0.03>glow-1.&&p.y-0.03<glow-1.)fragColor+=vec4(0.2,0,0,0);\n    if(p.y+0.03>glow+1.&&p.y-0.03<glow+1.)fragColor+=vec4(0.2,0,0,0);\n    if(p.z+0.03>glow+2.&&p.z-0.03<glow+2.)fragColor+=vec4(0,0.2,0,0);\n    if(p.x+0.03>glow3&&p.x-0.03<glow3)fragColor+=vec4(0.,0.,0.0,0.9);\n    if(d+0.005>glow2&&d-0.005<glow2)fragColor+=vec4(0.6,0.6,0,0);\n    //fragColor=vec4(vec3(l,l,l),1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/fdXSWl.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "fdXSWn", "name": "Bitwise vines", "author": "jarble", "description": "This fractal looks like a forest of hanging vines.", "tags": ["fractal", "forest", "bitwise", "vine", "jungle"], "likes": 6, "viewed": 156, "date": "1618433264", "time_retrieved": "2024-06-20T20:37:01.757622", "image_code": "// Inspired by a discussion on hackaday at:\n// https://hackaday.com/2021/04/13/alien-art-drawn-with-surprisingly-simple-math/\n// Formula shared by \"Joe\" on that page..\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Scale and move to make things a litle more interesting t look at.\n    float scale = 0.2;\n    float trans = iTime * 25.0;\n    vec2 coord = (scale * fragCoord) + vec2(trans,0.0);\n    \n    // Heart of color selection.\n    int val = ((int(coord.x) & int(coord.y)) % 3);\n    float result = 0.0;\n    vec3 col = vec3(0.0);\n    for(int i = 0; i < 6; i++){\n        coord.y -= (3.0-result);\n        coord = coord/(2.0);\n        result = ((result + float(val = ((int(coord.x-coord.y) & int(coord.y+coord.x*2.0)) % 3)))/(2.0));\n        col.x = (result*2.0+col.z)/3.0;\n        col = col.yzx;\n    }\n    // Output.\n    fragColor = vec4((col/2.0),0.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/fdXSWn.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "fdXSzB", "name": "NoiseCloud_vince", "author": "vince_hua", "description": "a cloud effect by noise", "tags": ["noise"], "likes": 1, "viewed": 125, "date": "1618754175", "time_retrieved": "2024-06-20T20:37:01.757622", "image_code": "float N21(vec2 p) {\n    return fract(sin(p.x*100. + p.y*6574.)*5674.);\n}\n\nfloat SmoothNoise(vec2 uv){\n\n    vec2 lv = smoothstep(0., 1., fract(uv));\n    vec2 id = floor(uv);\n    \n    float bl = N21(id);\n    float br = N21(id + vec2(1,0));\n    float b = mix(bl, br, lv.x);\n    \n    float tl = N21(id + vec2(0, 1));\n    float tr = N21(id + vec2(1, 1));\n    float t = mix(tl, tr, lv.x);\n    \n    return mix(b, t, lv.y);\n}\n\nfloat SmoothNoise2(vec2 uv) {\n    float c = SmoothNoise(uv*4.);\n    c += SmoothNoise(uv*8.)*.5;\n    c += SmoothNoise(uv*16.)*.25;\n    c += SmoothNoise(uv*32.)*.125;\n    c += SmoothNoise(uv*65.)*.0625;\n    \n    return c / 2.;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    uv += iTime * 0.1;\n    float c = SmoothNoise2(uv);\n    \n    vec3 col = vec3(c);\n\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/fdXSzB.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "fdXXDH", "name": "Pointless Structures", "author": "Kali", "description": "A shader I kept private until now because the fractal structures in the 4k intro Mesh Odyssey are based on this. https://www.shadertoy.com/view/NdB3zK", "tags": ["raymarching", "fractal"], "likes": 37, "viewed": 370, "date": "1618533557", "time_retrieved": "2024-06-20T20:37:01.757622", "image_code": "float det=.0001;\nfloat maxdist=15.;\nvec3 ldir=vec3(0.5,1.,1.);\nvec3 pa;\nfloat gcol;\nfloat t, it, k;\n\nvec3 hsv2rgb(vec3 c)\n{\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\n\nfloat hash12(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nmat2 rot(float a) {\n    a=radians(a);\n\tfloat s=sin(a),c=cos(a);\n    return mat2(c,s,-s,c);\n}\n\n\nfloat dot2( in vec3 v ) { return dot(v,v); }\nfloat sdBoundingBox( vec3 p, vec3 b, float e)\n{\n       p = abs(p  )-b;\n  vec3 q = abs(p+e)-e;\n\n  return sqrt(min(min(dot2(max(vec3(p.x,q.y,q.z),0.0)),\n                      dot2(max(vec3(q.x,p.y,q.z),0.0))),\n                      dot2(max(vec3(q.x,q.y,p.z),0.0)))) \n         +min(0.0,min(min( max(p.x,max(q.y,q.z)),\n                           max(p.y,max(q.z,q.x))),\n                           max(p.z,max(q.x,q.y))));\n}\n\nfloat kset(vec3 p) {\n\tp=abs(fract(p*.5)-.5);\n    for (int i=0; i<6; i++) {\n    \tp=abs(p)/dot(p,p)-.8;\n    }\n    return length(p.xy);\n}\n\n\nfloat shape (vec3 p, float z) {\n    p.xz*=rot(smoothstep(.28,.3,abs(.5-fract(t*.1+floor(z*4.)*.005)))*90.);\n    float d=sdBoundingBox(p,vec3(1.,1.,2.),.07);\n    return d;\n}\n\nvec3 path(float t) {\n\treturn vec3(sin(t*.5),cos(t)*.5,t);\n}\n\nvec3 pathcam(float t) {\n\tvec3 p=path(t);\n    p.y+=smoothstep(0.,.5,abs(.5-fract(t*.05)))*3.;\n    return p;\n}\n\n\n\nfloat de(vec3 pos) {\n\tfloat tu=length(pos.xy-pathcam(pos.z).xy)-.1;\n    pos.y+=-1.;\n    pos.x-=.4;\n\tpos.xy-=path(pos.z).xy;\n    float z=pos.z;\n    pos=abs(4.-mod(pos,8.))-4.;\n    pa=pos;\n\tfloat sc=1.4, d=1000., der=1.;\n    vec3 p=pos,m=vec3(100.);\n    float o=1000.;\n    for (int i=0; i<7; i++) {\n        p.xy*=rot(90.);\n        p.xz=abs(p.xz);\n        p.y+=1.;\n        sc=1.7/clamp(dot(p,p),0.1,1.0);\n\t\tp=p*sc-vec3(2.,1.,3.);\n        p.y-=1.;\n        der*=sc;\n        float shp=shape(p,z)/der;\n        if (shp<d && i>1) {\n            d=shp;\n            it=float(i);\n        }\n        o=min(o,length(p));\n    }\n    d=min(d,length(p.xy)/der-.005);\n    gcol=step(fract(pos.z*.1+iTime*.2+p.z*.005+it*.25),.02)*10.+1.5;\n    d=max(d,-tu);\n    return d*.7;\n}\n\nvec3 march(vec3 from, vec3 dir) {\n\tvec3 p, col=vec3(0.);\n    float totdist=0.,d;\n    float g=0.,gg=0.;\n    for(int i=0; i<130; i++) {\n\t\tp=from+totdist*dir;\n        d=de(p);\n        det*=1.+totdist*.03;\n        if (d<det || totdist>maxdist) break;\n        totdist+=d*(1.+hash12(dir.xy*1000.)*.3);\n        g+=exp(-.03*totdist)*kset(p)*gcol;\n    }\n    if (d<.1) {\n        col=gcol*vec3(.05);\n    }\n    col=mix(vec3(0.),col,exp(-.2*totdist));\n    col=pow(col,vec3(1.3))*1.5;\n    return col+pow(g*.012,1.5)*vec3(1.,.25,0.);\n}\n\nmat3 lookat(vec3 dir, vec3 up) {\n\tdir=normalize(dir); vec3 r=normalize(cross(dir,up));\n    return mat3(r,cross(dir,r),dir);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tt=iTime*.5;\n    vec2 uv = (fragCoord-iResolution.xy*.5)/iResolution.y;\n    vec3 from = pathcam(t);\n    vec3 to = pathcam(t+2.);\n    vec3 adv = normalize(to-from);\n    vec3 dir = normalize(vec3(uv,1.));\n    dir*=lookat(adv,vec3(0.,1.,0.));\n    dir.xy*=rot(45.);\n    dir.yz*=rot(-20.);\n    vec3 col = march(from, dir)*max(mod(fragCoord.x,3.),mod(fragCoord.y,3.))*.7;\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/fdXXDH.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "fdXXDr", "name": "Haru86_Hexagon", "author": "Haru86_", "description": "Haru86_Hexagon", "tags": ["raymarching"], "likes": 7, "viewed": 117, "date": "1618494169", "time_retrieved": "2024-06-20T20:37:01.757622", "image_code": "#define PI 3.14159265\n#define rot(a) mat2(cos(a),sin(a),-sin(a),cos(a))\n\nfloat rand(vec2 st)\n{\nreturn fract(sin(dot(st, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\nvec2 pmod(vec2 p, float n)\n{\nfloat a = (2.0 * PI) / n;\nfloat t = atan(p.x, p.y) - PI / n;\nt = mod(t, a) - PI / n;\nreturn vec2(length(p) * cos(t), length(p) * sin(t));\n}\n\nfloat cube(vec3 p, vec3 s)\n{\np = abs(p);\nreturn length(max(p - s, 0.0));\n}\n\nfloat sdHexPrism(vec3 p, vec2 h)\n{\nconst vec3 k = vec3(-0.8660254, 0.5, 0.57735);\np = abs(p);\np.xy -= 2.0 * min(dot(k.xy, p.xy), 0.0) * k.xy;\nvec2 d = vec2(\n    length(p.xy - vec2(clamp(p.x, -k.z * h.x, k.z * h.x), h.x)) * sign(p.y - h.x),\n    p.z - h.y);\nreturn min(max(d.x, d.y), 0.0) + length(max(d, 0.0));\n}\n\n#define rootT 1.73205080757\n\n\nfloat hex(vec3 p) {\n    p.yz *=rot(PI / 2.0); \n\n    float r = 5.;\n    float l = 5.;\n    p.xy = abs(p.xy);\n    float offset = 0.5;\n\n    vec3 pos1 = p;\n    vec3 pos2 = p;\n    vec2 off1 = vec2(2.0, 2.0 * rootT) * r+vec2(offset, offset);\n\n    vec2 id1 = floor(pos1.xy / off1);\n    vec2 id2 = floor((pos1.xy+0.5* off1) / off1);\n\n    float str = 1.5;\n    float randZ1 = rand(id1)* str;\n    float randZ2 = rand(id2)* str;\n\n\n    pos1.xy = mod(pos1.xy, off1) - off1 * 0.5;\n    pos2.xy = mod(pos2.xy + 0.5 * off1, off1) - off1 * 0.5;\n\n    pos1.z += randZ1;\n    pos2.z += randZ2;\n\n    float d1 = sdHexPrism(pos1, vec2(r, l));\n    float d2 = sdHexPrism(pos2, vec2(r, l));\n\n\n\n\n    d1 = min(d1, d2);\n\n    return d1;\n}\n\nfloat Torus(vec3 p,vec2 size)\n{\n    return length(vec2(length(p.xy)-size.x,p.z))-size.y;\n}\n\nfloat Box(vec3 p,vec3 size)\n{\n    return length(max(abs(p)-size,0.0));\n}\n\nfloat flower(vec3 p)\n{\n    p.xy*=rot(iTime);\n    p.xz*=rot(iTime);\n    p.yz*=rot(iTime);\n    \n    float radius=1.0;\n    \n    vec3 pos=p;\n        float time=iTime*2.;\n    float r=floor(time)+pow(fract(time),.1);\n   \n    \n    for(int i=0;i<3;i++)\n    {\n        pos=abs(pos)-radius;\n        if(pos.x<pos.y)pos.xy=pos.yx;\n        if(pos.x<pos.z)pos.xz=pos.zx;\n        if(pos.y<pos.z)pos.yz=pos.zy;\n        pos.xy-=.01;\n        \n        pos.xy*=rot(r);\n        pos.xz*=rot(r);\n        pos.y-=0.5;\n        \n        //pos.yz*=rot(PI/3.);\n    }\n    \n    float h=2.0;\n    pos.x-=clamp(pos.x,-h,h);\n    \n    float d4=Torus(pos,vec2(0.5,0.35));\n    float d5=Box(pos,vec3(0.1,0.1,4.0));\n    return d4;\n}\n\nfloat map(vec3 p)\n{\n    vec3 pos=p;\n    \n    p.z -= iTime*20.;\n    float off = 16.;\n\n    float d1 = hex(p- vec3(0.0, off, 0.0));\n    float d2 = hex(p+vec3(0.0, off,0.0));\n\n    float d3=flower(pos);\n    //return d1;\n    return min(min(d1,d2),d3);\n}\n\n\nvec3 gn(vec3 p) {\n    vec2 e = vec2(0.001, 0.0);\n    return normalize(vec3(\n        map(p+e.xyy)-map(p-e.xyy),\n        map(p + e.yxy) - map(p - e.yxy),\n        map(p + e.yyx) - map(p - e.yyx)\n        ));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n         vec2 uv = (fragCoord*2.0-iResolution.xy)/min(iResolution.x,iResolution.y);\n       // uv*=rot(iTime);\n        vec3 col=vec3(0.);\n\n         float radius=15.;\n       float speed=-.25;\n        vec3 ta=vec3(0.);\n        vec3 ro=vec3(cos(iTime*speed)*radius,0.0,sin(iTime*speed)*radius);\n        //sin(iTime*0.5)*0.25\n        //vec3 ro=vec3(0.,0.,15.0);\n        vec3 cDir=normalize(ta-ro);\n        vec3 cSide=cross(cDir,vec3(0.,-1.,0.));\n        vec3 cUp=cross(cDir,cSide);\n        float depth=1.;\n        vec3 rd=vec3(uv.x*cSide+uv.y*cUp+cDir*depth);\n\n        float d, t, acc, flash = 0.0;\n        float adjD = 1.;\n\n        for (int i = 0; i < 80; i++)\n        {\n            d = map(ro + rd * t);\n            if (d < 0.001 )break;\n            t += d * adjD;\n            acc += exp(-1.0 * d);\n\n\n        }\n\n        vec3 refRo = ro + rd * t;\n        vec3 n = gn(refRo);\n        rd = reflect(rd, n);\n        //rd = refract(rd, n,0.5);\n        ro = refRo;\n        t = 0.1;\n        float acc2 = 0.0;\n        for (int i = 0; i < 40; i++) {\n            d = map(ro + rd * t);\n            if (d < 0.001)break;\n            t += d* adjD;\n            acc2 += exp(-1.0 * d);\n        }\n\n\n\n\n        col = acc* vec3(1.0,1.,1.) *0.02;\n        col += acc2 * vec3(1.,1.,1.) * 0.02;\n   \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": "4sXGzn", "previewfilepath": "/media/ap/a6a1cf7a09adfed8c362492c88c30d74fb3d2f4f7ba180ba34b98556660fada1.mp3", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/a6a1cf7a09adfed8c362492c88c30d74fb3d2f4f7ba180ba34b98556660fada1.mp3", "ctype": "music"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/fdXXDr.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "fdXXR2", "name": "flownoise2 balanced isolines-sbd", "author": "FabriceNeyret2", "description": "SPACE to toggle turbulence vs bozo noise.\nusing 1pix-width lines drawing + lines density gradient.  switch #8 for correct isolines ( altered here for the look :-) ).\nflownoise variant of [url]https://shadertoy.com/view/NdXXRj[/url]", "tags": ["procedural", "noise", "perlin"], "likes": 9, "viewed": 247, "date": "1618841945", "time_retrieved": "2024-06-20T20:37:02.151561", "image_code": "// gradient + 1pix-width lines + flownoise variant of https://shadertoy.com/view/NdXXRj\n// interpolated variant of https://shadertoy.com/view/sdsXzB\n\n#define keyToggle(a) ( texelFetch(iChannel3,ivec2(a,2),0).x > 0.)\n#define hash(p )     ( 2.* fract(sin((p)*mat2(127.1,311.7, 269.5,183.3)) *43758.5453123) - 1. ) \\\n                    *  mat2(cos(iTime+vec4(0,11,33,0)))\n//#define draw(v,d)    clamp(1. - abs( fract(v-.5) - .5 ) / (d), 0.,1.) // correct version\n  #define draw(v,d)    clamp(1. - abs( fract(v   ) - .5 ) / (d), 0.,1.) // nicer here :-)\n#define hue(v)       ( .6 + .6 * cos( 6.3*(v)  + vec4(0,23,21,0)  ) )\n\n//#define func( P )  ( mod(iTime,4.) > 2. ? perlin( .5*(P) ) : noise( P ) )\n  #define func( P )  ( keyToggle(32) ? perlin( .5*(P) ) : noise( P ) )\n#define grad(x,y)      dot( hash( i+vec2(x,y) ), f-vec2(x,y) )\n\nfloat noise( vec2 p )\n{\n    vec2 i = floor(p), f = fract(p), // u = f*f*(3.-2.*f);              // = smoothstep\n                                        u = f*f*f*( 10. +f*(6.*f-15.)); // better with derivatives\n    return mix( mix( grad(0,0), grad(1,0), u.x),\n                mix( grad(0,1), grad(1,1), u.x), u.y);\n}\n\nfloat perlin( vec2 U ) { // inspired from https://www.shadertoy.com/view/XdXGW8\n    float v = 0., s = .5;\n    mat2 m = mat2( 1.6,  1.2, -1.2,  1.6 );\n    for( int i=0; i<3; i++, s/=2., U*=m )\n        v  += s * noise( U ); \n    return v;\n}\n\nvoid mainImage( out vec4 O, vec2 u )\n{\n    vec2 R = iResolution.xy, eps = vec2(1e-3,0),\n         U = u / R.y,\n         P = 8.*U - vec2(0.,.5*iTime);\t\n    O-=O;\n\tfloat l, dl, f = func(P), df;\n#if 0\n    l = exp2(floor(log2(2.*fwidth(P.x)/fwidth(f))));              // subvid amount (relative)\n    dl =     fract(log2(2.*fwidth(P.x)/fwidth(f)));      \n#else\n    l = exp2(floor(log2(1./22./fwidth(f))));                      // subvid amount (absolute)\n    dl =     fract(log2(1./22./fwidth(f)));\n#endif\n    float w = U.x;\n    f *= w;\n#if 0                                                             // draw isolines using sin\n    O = vec4(.5+.5*  mix( sin(50.*l*f) , sin(100.*l*f), dl ) ); \n#else                                                             // draw isolines \n    df = fwidth(f);\n// df = length( ( vec2( func(P + eps.xy), func(P + eps.yx) )*w -f ) / eps.x )*fwidth(P.x);\n    l *= 8.; \n    O += mix( draw(    f*l,    l*df ),\n              draw( 2.*f*l, 2.*l*df ),\n              dl );\n#endif\n    \n    O = sqrt(O);                                                  // to sRGB\n}", "image_inputs": [{"id": "4dXGRr", "previewfilepath": "/presets/tex00.jpg", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/presets/tex00.jpg", "ctype": "keyboard"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/fdXXR2.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "fdXXR4", "name": "Starry background with nebula", "author": "mrange", "description": "License CC0: Starry background with nebula\nCreated for another shader but thought the background could be useful to others so extracted it\n", "tags": ["2d"], "likes": 13, "viewed": 399, "date": "1618301095", "time_retrieved": "2024-06-20T20:37:03.430615", "image_code": "// License CC0: Starry background with nebula\n//  Created for another shader but thought the background could be useful to others so extracted it\n\n// Controls how many layers of stars\n#define LAYERS            5.0\n\n// QUINTIC or HERMITE interpolation?\n#define QUINTIC\n\n// How often to change the nebula\n#define PERIOD            15.0\n\n#define PI                3.141592654\n#define TAU               (2.0*PI)\n#define TIME              iTime\n#define RESOLUTION        iResolution\n#define ROT(a)            mat2(cos(a), sin(a), -sin(a), cos(a))\n#define PCOS(x)           (0.5 + 0.5*cos(x))\n#define TTIME             (TAU*TIME)\n\nconst mat2 rotSome          = ROT(1.0);\n\nfloat tanh_approx(float x) {\n//  return tanh(x);\n  float x2 = x*x;\n  return clamp(x*(27.0 + x2)/(27.0+9.0*x2), -1.0, 1.0);\n}\n\nfloat hash(float co) {\n  return fract(sin(co*12.9898) * 13758.5453);\n}\n\nfloat hash(vec2 co) {\n  co += 123.4;\n  return fract(sin(dot(co, vec2(12.9898,58.233))) * 13758.5453);\n}\n\nvec2 hash2(vec2 p) {\n  p = vec2 (dot (p, vec2 (127.1, 311.7)),\n            dot (p, vec2 (269.5, 183.3)));\n\n  return -1. + 2.*fract (sin (p)*43758.5453123);\n}\n\n// https://stackoverflow.com/questions/15095909/from-rgb-to-hsv-in-opengl-glsl\nvec3 hsv2rgb(vec3 c) {\n  const vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n  vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n  return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\n// http://mercury.sexy/hg_sdf/\nvec2 mod2(inout vec2 p, vec2 size) {\n  vec2 c = floor((p + size*0.5)/size);\n  p = mod(p + size*0.5,size) - size*0.5;\n  return c;\n}\n\nvec3 toSpherical(vec3 p) {\n  float r   = length(p);\n  float t   = acos(p.z/r);\n  float ph  = atan(p.y, p.x);\n  return vec3(r, t, ph);\n}\n\nvec3 postProcess(vec3 col, vec2 q)  {\n  col=pow(clamp(col,0.0,1.0),vec3(1.0/2.2)); \n  col=col*0.6+0.4*col*col*(3.0-2.0*col);  // contrast\n  col=mix(col, vec3(dot(col, vec3(0.33))), -0.4);  // satuation\n  col*=0.5+0.5*pow(19.0*q.x*q.y*(1.0-q.x)*(1.0-q.y),0.7);  // vigneting\n  return col;\n}\n\n// From one of IQ's value noise shaders\nfloat vnoise(vec2 x) {\n  vec2 i = floor(x);\n  vec2 w = fract(x);\n\n#ifdef QUINTIC\n  // quintic interpolation\n  vec2 u = w*w*w*(w*(w*6.0-15.0)+10.0);\n#else\n  // cubic interpolation\n  vec2 u = w*w*(3.0-2.0*w);\n#endif    \n\n  float a = hash(i+vec2(0.0,0.0));\n  float b = hash(i+vec2(1.0,0.0));\n  float c = hash(i+vec2(0.0,1.0));\n  float d = hash(i+vec2(1.0,1.0));\n    \n  float k0 =   a;\n  float k1 =   b - a;\n  float k2 =   c - a;\n  float k3 =   d - c + a - b;\n\n  float aa = mix(a, b, u.x);\n  float bb = mix(c, d, u.x);\n  float cc = mix(aa, bb, u.y);\n  \n  return k0 + k1*u.x + k2*u.y + k3*u.x*u.y;\n}\n\nfloat globalCloudDensity(vec2 p, float off) {\n  vec2 pp = p;\n\n  p *= 3.33;\n\n  float gcd = vnoise(p+off);\n  gcd *= smoothstep(PI/2.0, PI/4.0, abs(pp.x));\n  gcd *= smoothstep(PI/6.0, PI/18.0, abs(pp.y));\n\n  return gcd;\n}\n\nfloat localCloudDensity(vec2 p, float off) {\n  p *= 10.0;\n  const float aa = -0.45;\n  const mat2 pp = 2.03*rotSome;\n  float a = 0.5;\n  float s = 0.0;\n  p += off;\n\n  s += a*vnoise(p); a *= aa; p *= pp;\n  s += a*vnoise(p); a *= aa; p *= pp;\n  s += a*vnoise(p); a *= aa; p *= pp;\n  s += a*vnoise(p); a *= aa; p *= pp;\n  s += a*vnoise(p); a *= aa; p *= pp;\n    \n  return s*2.75;\n}\n\nvec3 clouds(vec3 ro, vec3 rd, out float cloudDensity) {\n  vec3 srd = toSpherical(rd.zxy);\n  float y = sin(srd.y);\n\n  vec2 pp = srd.zy;\n  pp.x *= y;\n  pp.y -= PI/2.0;\n  pp *= ROT(0.5);\n\n  float h = hash(floor(2.0+TIME/PERIOD));\n  float off = 10.0*fract(123.0*h)+100.0;\n\n  float gcd = globalCloudDensity(pp, off);\n\n  float cd = gcd*localCloudDensity(pp, off);\n  float cdo = gcd*localCloudDensity(pp+00.075*vec2(0.125, -0.25), off);\n  cloudDensity = cd;\n\n  // Basis for some very fake shading\n  float cli = mix(-0.5, 1.0, 0.5 + 0.5*tanh_approx(12.0*(cd-cdo)));\n  \n  float tc = clamp(cd, 0.0, 1.0);\n  float huec = (mix(-0.2, 0.05, tc)+0.05)-0.15*(h-0.5)-0.0;\n  float satc = mix(0.9, 0.5, tc);\n  float bric = 1.0;\n  vec3 colc = hsv2rgb(vec3(huec, satc, bric))+cli*vec3(0.9, 0.7, 0.9);\n  tc *= tc;\n\n  vec4 cc = vec4(colc*0.66, tc);\n  cc = clamp(cc, 0.0, 1.0);\n\n  return cc.xyz*cc.w;\n}\n\nvec3 stars(vec3 ro, vec3 rd, float cloudDensity) {\n  vec3 col = vec3(0.0);\n  vec3 srd = toSpherical(rd.xzy);\n  \n  const float m = LAYERS;\n\n  for (float i = 0.0; i < m; ++i) {\n    vec2 pp = srd.yz+0.5*i;\n    float s = i/(m-1.0);\n    vec2 dim  = vec2(mix(0.025, 0.003, s)*PI);\n    vec2 np = mod2(pp, dim);\n    vec2 h = hash2(np+127.0+i);\n    vec2 o = -1.0+2.0*h;\n    float y = sin(srd.y);\n    pp += o*dim*0.5;\n    pp.y *= y;\n    float l = length(pp);\n  \n    float h1 = fract(h.x*109.0);\n    float h2 = fract(h.x*113.0);\n    float h3 = fract(h.x*127.0);\n\n    vec3 hsv = vec3(fract(0.025-0.4*h1*h1), mix(0.5, 0.125, s), 1.0);\n    vec3 scol = mix(8.0*h2, 0.25*h2*h2, s)*hsv2rgb(hsv);\n\n    vec3 ccol = col+ exp(-(2000.0/mix(2.0, 0.25, s))*max(l-0.001, 0.0))*scol;\n    float p = i < 3.0 ? mix(0.125, 2.0, cloudDensity)*y : y;\n    p = clamp(p, 0.0, 1.0);\n    col = h3 < p ? ccol : col;\n  }\n  \n  return col;\n}\n\nvec3 grid(vec3 ro, vec3 rd) {\n  vec3 srd = toSpherical(rd.xzy);\n  \n  const float m = 1.0;\n\n  const vec2 dim = vec2(1.0/8.0*PI);\n  vec2 pp = srd.yz;\n  vec2 np = mod2(pp, dim);\n\n  vec3 col = vec3(0.0);\n\n  float y = sin(srd.y);\n  float d = min(abs(pp.x), abs(pp.y*y));\n  \n  float aa = 2.0/RESOLUTION.y;\n  \n  col += 2.0*vec3(0.5, 0.5, 1.0)*exp(-2000.0*max(d-0.00025, 0.0));\n  \n  return 0.25*tanh(col);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  vec2 q = fragCoord.xy/RESOLUTION.xy; \n  vec2 p = -1.0 + 2.0*q;\n  p.x *= RESOLUTION.x/RESOLUTION.y;\n\n  vec3 ro = vec3(2.0, 0, 0.);\n  ro.xy *= ROT(-0.33*sin(TTIME/12.0));\n  ro.xz *= ROT(1.5+0.33*sin(TTIME/12.0));\n  vec3 la = vec3(0.0, 0.0, 0.0);\n\n  vec3 ww = normalize(la - ro);\n  vec3 uu = normalize(cross( vec3(0.0,1.0,0.0), ww));\n  vec3 vv = normalize(cross(ww,uu));\n\n  const float rdd = 2.0;\n  vec3 rd = normalize(p.x*uu + p.y*vv + rdd*ww);\n\n  vec3 col = vec3(0.0);\n\n  float cloudDensity;  \n  col += clouds(ro, rd, cloudDensity);\n  col += stars(ro, rd, cloudDensity);\n  col += grid(ro, rd);\n  \n  col = clamp(col, 0.0, 1.0);\n  fragColor = vec4(postProcess(col, q),1.0);\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc0-1.0", "thumbnail": "https://www.shadertoy.com/media/shaders/fdXXR4.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "fdXXW8", "name": "Blocky Spiral", "author": "percentcer", "description": "atan is always there for you when you need it", "tags": ["atan"], "likes": 1, "viewed": 129, "date": "1618516261", "time_retrieved": "2024-06-20T20:37:03.430615", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 blocks = floor((fragCoord.xy-iResolution.xy*.5)*.1);\n    vec3 mul = vec3(0.5 + 0.5 * sin(-10.*iTime + length(blocks)*.1 + mod(blocks.y,2.)));\n    vec3 bgCol = vec3(sin((iTime+atan(blocks.y,blocks.x)+length(blocks))), .7 + 0.5*sin(blocks.y),.8)+0.5*sin(iTime + blocks.xyy + vec3(0,2,4));\n    for(int i = 0; i < 4; i++) {\n        bgCol = bgCol.yzx;\n        bgCol.x*=bgCol.y*1.1;\n    }    \n    fragColor = vec4(bgCol*mul+bgCol*(0.7+0.1*sin(iTime)),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/fdXXW8.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "fs23RG", "name": "distortingcircletest", "author": "Drakyen", "description": "as the title says!", "tags": ["distortion", "circle"], "likes": 3, "viewed": 38, "date": "1617734225", "time_retrieved": "2024-06-20T20:37:03.430615", "image_code": "\n\n\n#define rot(a) mat2( cos(a),-sin(a),sin(a),cos(a) )\n\nfloat inv(float a) {return a - a * 2.; }\n\nvec3 inv(vec3 a) {return vec3(a.x - a.x * 2., a.y - a.y * 2., a.z - a.z * 2.);}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\n    uv *= rot(0.5 * iTime);\n\n    uv = fract(uv * 2.) -0.5;\n\n    uv *= rot(-1. * iTime);\n\n    float xdis = sin(uv.y * 15. * sin(iTime * 3.)) / 6.;\n    float ydis = sin(uv.x * 15. * sin(iTime * 3.)) / 6.;\n    \n    uv += vec2(xdis,ydis);\n   \n    float bright = 0.;\n\n    bright = step(0., (length(uv) - 0.3) * step(0., (abs(uv.x) - 0.1) + (abs(uv.y) - 0.1)));\n   \n    float r = 1. - (smoothstep(0.,1., length(uv) * 5.));    \n    if(abs(uv.x) < 0.2 && abs(uv.y) < 0.2) bright = inv(bright);\n    r *= inv(bright);\n    bright = inv(bright);\n    \n    // Output to screen\n    fragColor = vec4(bright, r , 0, 1.);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/fs23RG.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "fs23Ry", "name": "George", "author": "SnoopethDuckDuck", "description": "A very glowy boy", "tags": ["george"], "likes": 3, "viewed": 120, "date": "1617579924", "time_retrieved": "2024-06-20T20:37:03.594179", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n\nfloat d = (uv.x - 0.5) * (uv.x - 0.5) + (uv.y - 0.5) * (uv.y-0.5);\n//d*=2.;\nfloat v= cos(0.02 * iTime) *(uv.y-0.5) / (uv.x - 0.5);\nfloat theta = atan(v + 1. * 3.14159 * (1. + cos(v+0.51598374513 * iTime) + cos(v - 0.12482456 * iTime)));\n\nfloat val = cos(1. *theta + floor(theta * 0.5 * (1. + cos(0.02 * iTime))) * iTime);\n\n    // Time varying pixel color\n   // vec3 col = 0.5 * vec3(1. + sin(theta) *cos( theta + iTime));\nvec3 col = vec3(1. - smoothstep(val, d,0.15 + 0.05 * cos(0.1 * iTime)),\n1. - smoothstep(val, 0.5 * d,0.15 + 0.05 * cos(0.1 * iTime + 2. * 3.14159 / 3.)),\n1. - smoothstep(val, 0.25  * d,0.15 + 0.05 * cos(0.1 * iTime + 4. * 3.14159 / 3.))\n);\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n            \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/fs23Ry.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "fs23Wh", "name": "Square Cycler", "author": "Tater", "description": "code is a bit of a mess but I really wanted to try this trick. Maybe I'll make a better thing with it later. ", "tags": ["2d", "squares", "overlapping"], "likes": 8, "viewed": 221, "date": "1617341045", "time_retrieved": "2024-06-20T20:37:03.594179", "image_code": "#define rot(a) mat2( cos(a),-sin(a),sin(a),cos(a) )\n#define pi 3.141592653\nfloat smoothtrig(float b, float wv){\nreturn sqrt((1.0+b*b)/(1.0+b*b*wv*wv))*wv;\n}\n\nfloat squares(vec2 uv, float t)\n{  \n    float wdth = .5*iResolution.x/iResolution.y-0.1;\n    \n    vec2 cent = vec2(wdth,0.38)\n                *clamp(vec2(smoothtrig(4.0,sin(t*2.0)),smoothtrig(4.0,cos(t*2.0))),-.95,.95);\n    vec2 d = abs(uv+cent);\n    \n    float o = step(max(d.x,d.y),0.15);\nreturn o;\n}\nfloat rects(vec2 uv, float t)\n{\n    uv*=rot(t);\n    vec2 cent = vec2(sin(t*3.5)+1.5,cos(t*3.5)+1.5);\n    vec2 d = abs(uv*cent);\n    \n    float o = step(max(d.x,d.y),0.3);\n          o -= step(max(d.x,d.y),0.15);        \nreturn o;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float t = iTime;\n    vec2 R = iResolution.xy;\n    vec2 uv = (fragCoord-.5*R.xy)/R.y;\n    vec2 uv2 = uv;\n    //uv = abs(uv);\n    //uv*=length(uv)*3.0;\n    float c = 10.0;\n    vec3 col= 0.5*vec3(30.,14.,256.)/256.*length(uv*0.6);\n    \n    for(float i = 0.; i<c; i++){\n        uv2*=rot(-i*-0.03);\n        uv*=1.0+(i/c)*0.1;\n        col.r += (1.3/c)*rects(uv2,t+i*0.1)*2.0;\n        col.g += (1.3/c)*rects(uv2,t+i*0.1);\n        \n        col.r += (1.2/c)*squares(uv,t+i*0.01)+(1.2/c)\n                        *squares(uv,t+i*0.01+pi/2.0); \n        col   +=((1.2/c)*squares(uv,t+i*0.01+pi/4.0)+(1.2/c)\n                        *squares(uv,t+i*0.01+pi*0.75))\n                        *vec3(31.,255.,255.)/256.; \n    }\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/fs23Wh.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "fs23Wt", "name": "membrane game", "author": "4eckme", "description": "to be continued...", "tags": ["mouse", "game", "math"], "likes": 15, "viewed": 3425, "date": "1618123603", "time_retrieved": "2024-06-20T20:37:03.739637", "image_code": "// click mouse and move\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float N = 60.0; //cell size\n    vec2 coord = fragCoord - (iResolution.xy / vec2(2.0)); //simmetric\n    float x = float(coord.x); //pixel x from center\n    float y = float(coord.y); //pixel y from center\n    float t = pow(1.02, iTime); //equal animate with speed 1.02;\n    float dx = iMouse.x-iResolution.x/2.0;//mouse move x\n    float dy = iMouse.y-iResolution.y/2.0;//mouse move y\n    float f = float((x-dx)*(x-dx)*t+(y-dy)*(y-dy)*t); //LOGIC, it can be changed\n    float F = abs(f*sin((x)/N)*sin((y)/N));//do MEMBRANE for game LOGIC\n    int R = int(floor(F*pow(16.0, 6.0-ceil(log2(F)/4.0))));//adapt COLOR for X11\n    fragColor = vec4(\n        float(((R) >> 16)& 255) / 255.0, //red\n        float(((R) >> 8) & 255) / 255.0, //green\n        float(((R) >> 0) & 255) / 255.0, //blue\n        1.0\n    );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/fs23Wt.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "fs23Ww", "name": "Analytic 2D Optimization", "author": "oneshade", "description": "It took me a while to figure out how optimization works in 2D. Well, now I know!", "tags": ["2d", "learning", "optimization", "practice", "analytic"], "likes": 1, "viewed": 66, "date": "1617491089", "time_retrieved": "2024-06-20T20:37:04.066893", "image_code": "// Hue to RGB function from Fabrice's shadertoyunofficial blog:\n#define hue2rgb(hue) 0.6 + 0.6 * cos(6.3 * hue + vec3(0.0, 23.0, 21.0))\n\n// Settings\n#define CONTOUR_SPACING 1.0\n#define CONTOUR_THICKNESS 2.0\n#define DELTA 0.001\n\n// Coefficients\n#define a vec2(1.0 + 0.5 * cos(iTime), 1.0 + 0.5 * sin(iTime)) // vec2(a, b)\n#define b vec2(sin(iTime * 0.5) * 0.5, cos(iTime) * 0.5)       // vec2(c, d)\n#define c cos(iTime)                                           // e\n\n// Function\nfloat f(in vec2 p) {\n    return dot(a, p * p) + dot(b, p) + c;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y * 4.0;\n    float unit = CONTOUR_THICKNESS / iResolution.y * 4.0;\n    vec3 color = vec3(0.0);\n\n    // Draw contours\n    float hSpacing = 0.5 * CONTOUR_SPACING;\n    float fRes = f(uv);\n\n    float grad = length(vec2(f(uv + vec2(DELTA, 0.0)) - f(uv - vec2(DELTA, 0.0)),\n                             f(uv + vec2(0.0, DELTA)) - f(uv - vec2(0.0, DELTA)))) / (2.0 * DELTA);\n\n    float contour = abs(mod(fRes + hSpacing, CONTOUR_SPACING) - hSpacing) / grad;\n    color = vec3(fRes * 0.1) - smoothstep(unit, 0.0, contour);\n\n    // Optimization\n    /*\n    f(x, y) = ax^2 + by^2 + cx + dy + e\n\n    Compute partial derivatives\n    ∂f/∂x = 2ax + c\n    ∂f/∂y = 2by + d\n\n    Set the partial derivatives equal to zero\n    2ax + c = 0\n    2by + d = 0\n\n    The solution to the system is the optimum\n    x = -c/(2a)\n    y = -d/(2b)\n    */\n\n    vec2 optimum = -b / (2.0 * a);\n    color = mix(color, vec3(1.0, 0.0, 0.0), smoothstep(unit, 0.0, abs(2.0 * a.x * uv.x + b.x) - 0.025));\n    color = mix(color, vec3(0.0, 0.0, 1.0), smoothstep(unit, 0.0, abs(2.0 * a.y * uv.y + b.y) - 0.025));\n    color = mix(color, vec3(0.0, 1.0, 0.0), smoothstep(unit, 0.0, length(uv - optimum) - 0.05));\n\n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/fs23Ww.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "fs23Wz", "name": "Frosty Fir Forest", "author": "jarble", "description": "A simple fractal formula.\nFull-screen mode recommended.", "tags": ["fractal", "feather", "coral"], "likes": 2, "viewed": 162, "date": "1617243428", "time_retrieved": "2024-06-20T20:37:04.066893", "image_code": "\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.0);\n    vec3 col;\n    float t = iTime;\n    float x1 = 1.0;\n    vec2 uv = (fragCoord*10.0-iResolution.xy)/iResolution.y/10.0/x1;\n    uv += vec2(t/2.0,t/3.0)/4.0/x1;\n    for(int c=0;c<3;c++){\n        float scale = 4.5;\n        float scale1 = 1.5;\n        float s1 = scale1*scale;\n        for(int i=0;i<9;i++)\n        {\n            uv += uv.xx;\n            uv = fract(uv/s1)*s1;\n            uv=-fract(uv/(2.0-abs((uv.x-uv.y)/(12.0)))-(uv/(2.5+(fract(uv.x+uv.y))))/scale)*scale/scale1+s1;\n            uv /= scale1+col.yx;\n        \tuv=uv.yx+col.xy;\n            uv.x /= -scale1;\n            col = (col.yzx+col)/2.0;\n        }\n     col[c] = fract(((uv.y)+(uv.x))/(2.0));\n\t}\n    \n    fragColor = vec4(vec3(col),1.0);\n    \n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/fs23Wz.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "fs23zc", "name": "Expensive Line Fill", "author": "oneshade", "description": "Looks expensive.", "tags": ["2d", "line", "float"], "likes": 3, "viewed": 67, "date": "1617757557", "time_retrieved": "2024-06-20T20:37:04.066893", "image_code": "#define draw(d, t, c) color = mix(color, c, smoothstep(unit, 0.0, d) * t)\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y * 32.0;\n    float unit = 64.0 / iResolution.y;\n    float time = iTime * 0.25;\n    vec3 color = vec3(1.0);\n\n    // Grid\n    draw(abs(fract(uv.x + 0.5) - 0.5) + 0.25 * unit, 1.0, vec3(0.0, 0.0, 1.0));\n    draw(abs(fract(uv.y + 0.5) - 0.5) + 0.25 * unit, 1.0, vec3(0.0, 0.0, 1.0));\n    draw(abs(uv.x), 1.0, vec3(1.0, 0.0, 0.0));\n    draw(abs(uv.y), 1.0, vec3(1.0, 0.0, 0.0));\n\n    vec2 a = vec2(cos(time * 1.25) * 20.0, sin(time) * 8.0);\n    vec2 b = vec2(-sin(time * 0.75) * 12.0, sin(time * 1.5) * 16.0);\n\n    vec2 ba = b - a;\n    float l = length(ba);\n    float denom = max(abs(ba.x), abs(ba.y));\n\n    vec2 pos = a;\n    vec2 pStep = ba / denom;\n    for (float t=0.0; t < denom; t++) {\n        vec2 cell = floor(pos) + 0.5;\n        draw(max(abs(uv.x - cell.x), abs(uv.y - cell.y)) - 0.5, 0.5, vec3(0.0));\n        pos += pStep;\n    }\n\n    draw(length(uv - a) - 0.5, 1.0, vec3(1.0, 0.0, 0.0));\n    draw(length(uv - b) - 0.5, 1.0, vec3(0.0, 0.0, 1.0));\n\n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/fs23zc.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "fs23zV", "name": "bitwise things", "author": "percentcer", "description": "Saw tweet https://twitter.com/aemkei/status/1378106731386040322, got curious", "tags": ["masking", "xor", "bits", "bitwise"], "likes": 6, "viewed": 165, "date": "1617666790", "time_retrieved": "2024-06-20T20:37:04.278938", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    fragCoord *= .2f;\n    fragCoord += iTime * 10.f;\n\n    // Time varying pixel color\n    vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n    \n    int x = int(fragCoord.x);\n    int y = int(fragCoord.y);\n    \n    int on = 1;\n    \n    int intTime = int(iTime);\n    int cycle = intTime % 16;\n    \n    if (uv.x < .5f && uv.y < .5f) {\n        on = (x | y) % cycle;\n    } else if (uv.x < .5f) {\n        on = (x ^ y) % cycle;\n    }\n    else if (uv.y < .5f) {\n        on = (x * y) & (1 << cycle);\n    }\n    else {\n        on = (x ^ y) & cycle;\n    }\n    \n    // Output to screen\n    fragColor = vec4(col * float(on), 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/fs23zV.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "fs23zy", "name": "Temporal Fire", "author": "Tater", "description": "fire stuck in time", "tags": ["2d", "fire"], "likes": 5, "viewed": 177, "date": "1617594405", "time_retrieved": "2024-06-20T20:37:04.284848", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float t = asin(sin(iTime*0.5)*.9)*2.2;\n    //t = iTime*0.9;\n    vec2 R = iResolution.xy;\n    vec2 ruv = (fragCoord-.5*R.xy)/R.y;\n    vec3 col = vec3(0);\n    \n    for(float i = 0.0; i<3.0;i++){\n        vec2 uv = ruv;\n        t+=0.125;\n        uv.y+=0.5;\n        uv.y*=abs(uv.x*0.1)+0.8;\n        uv*=0.5;\n        uv.x*=1.2;\n        uv.y+=abs(uv.x*uv.x);\n        uv=-uv.yx; \n        uv.y+=(uv.x*3.)*sin(sin(t*10.+uv.x*25.))/10.;\n        uv.x-=asin(sin(t+uv.y*30.))/20.;\n        vec2 d = abs(uv);\n        col.r += 0.24*(step(max(d.x,d.y),0.3)) + 0.2*(step(max(d.x,d.y),0.2));\n        col.g += 0.33*(step(max(d.x,d.y),0.2));\n        col.b += 0.33*(step(max(d.x,d.y),0.1));\n    }\n    col += 0.2*vec3(0.490,0.192,0.196);\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/fs23zy.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "fs2GDW", "name": "rotate goku", "author": "jorge2017a1", "description": "rotate goku", "tags": ["rotategoku"], "likes": 1, "viewed": 126, "date": "1617422335", "time_retrieved": "2024-06-20T20:37:04.285106", "image_code": "//por jorge2017a1 ----jorgeFloresP\n#define Rot(a) mat2(cos(a),-sin(a),sin(a),cos(a))\n#define antialiasing(n) n/min(iResolution.y,iResolution.x)\n#define S(d,b) smoothstep(antialiasing(1.0),b,d)\n#define DF(a,b) length(a) * cos( mod( atan(a.y,a.x)+6.28/(b*8.0), 6.28/((b*8.0)*0.5))+(b-1.)*6.28/(b*8.0) + vec2(0,11) )\n#define opU2(d1, d2) ( d1.x < d2.x ? d1 : d2 )\n\nfloat opU( float d1, float d2 ) { return  min(d1,d2); }\nfloat opS( float d1, float d2 ) { return max(-d1,d2); }\nfloat opI( float d1, float d2 ) { return max(d1,d2); }\n\n//----------oPeraciones de Repeticion\nfloat opRep1D( float p, float c )\n\t{ float q = mod(p+0.5*c,c)-0.5*c; return  q ;}\n//----------\nfloat sdBox( in vec2 p, in vec2 b )\n{  vec2 d = abs(p)-b; return length(max(d,0.0)) + min(max(d.x,d.y),0.0); }\n\nfloat sdCircle( vec2 p, float r )\n{ return length(p) - r; }\n\nvec2 rotatev2(vec2 p, float ang)\n{\n    float c = cos(ang); float s = sin(ang);\n    return vec2(p.x*c - p.y*s, p.x*s + p.y*c);\n}\n////-------------------\n\n//https://www.shadertoy.com/view/tlGBW3\n//Created by manu210404 in 2021-03-13\n#define POLY(N) (in vec2 p, in vec2[N] v) {const int n=v.length();float d=dot(p-v[0],p-v[0]);float s=1.;for(int i=0,j=n-1;i<n;j=i,i++){vec2 e=v[j]-v[i];vec2 w=p-v[i];vec2 b=w-e*clamp(dot(w,e)/dot(e,e),0.,1.);d=min(d,dot(b,b));bvec3 cond=bvec3(p.y>=v[i].y,p.y<v[j].y,e.x*w.y>e.y*w.x);if(all(cond)||all(not(cond))) s=-s;}return s*sqrt(d);}\nfloat sdPoly11 POLY(11)\nfloat sdPoly28 POLY(28)\nfloat sdPoly17 POLY(17)\nfloat sdPoly09 POLY(9)\nfloat sdPoly25 POLY(25)\n\n\nvec2 pt25[ 25]=vec2[](  \nvec2(.52,.01),vec2(.21,.14),vec2(.29,.17),vec2(.12,.34),vec2(.26,.34),\nvec2(.12,.54),vec2(.09,.58),vec2(.05,.61),vec2(.01,.64),vec2(.04,.67),\nvec2(.11,.70),vec2(.17,.71),vec2(.21,.71),vec2(.25,.69),vec2(.31,.65),\nvec2(.27,.82),vec2(.26,.86),vec2(.22,.95),vec2(.19,1.00),vec2(.26,1.00),\nvec2(.35,.98),vec2(.44,.93),vec2(.49,.86),vec2(.55,.72),vec2(.52,.01) );\n\nfloat sdPoly15 POLY(15)\nvec2 pt15[ 15]=vec2[](  \nvec2(.53,.03),vec2(.82,.08),vec2(.76,.13),vec2(.91,.19),vec2(.80,.23),\nvec2(.97,.37),vec2(.92,.41),vec2(.88,.43),vec2(.84,.44),vec2(.98,.59),\nvec2(.91,.60),vec2(.82,.60),vec2(.73,.58),vec2(.55,.72),vec2(.53,.03) );\n\n\n//float sdPoly15 POLY(15)\nvec2 pt15b[ 15]=vec2[](  \nvec2(.38,.11),vec2(.35,.29),vec2(.32,.53),vec2(.53,.61),vec2(.73,.50),\nvec2(.67,.12),vec2(.66,.10),vec2(.62,.06),vec2(.56,.02),vec2(.55,.01),\nvec2(.52,.00),vec2(.48,.02),vec2(.43,.05),vec2(.39,.09),vec2(.38,.11) );\n\n\nfloat sdPoly18 POLY(18)\nvec2 pt18[ 18]=vec2[](  \nvec2(.35,.29),vec2(.37,.27),vec2(.36,.34),vec2(.39,.32),vec2(.38,.42),\nvec2(.38,.45),vec2(.41,.50),vec2(.42,.41),vec2(.42,.38),vec2(.44,.33),\nvec2(.45,.39),vec2(.46,.44),vec2(.47,.47),vec2(.51,.52),vec2(.55,.56),\nvec2(.53,.61),vec2(.32,.53),vec2(.35,.29) );\n\n\nfloat sdPoly20 POLY(20)\nvec2 pt20[ 20]=vec2[](  \nvec2(.70,.28),vec2(.68,.26),vec2(.69,.33),vec2(.66,.30),vec2(.67,.35),\nvec2(.68,.40),vec2(.68,.45),vec2(.67,.48),vec2(.66,.45),vec2(.65,.42),\nvec2(.62,.38),vec2(.59,.35),vec2(.59,.39),vec2(.59,.45),vec2(.58,.50),\nvec2(.57,.53),vec2(.55,.56),vec2(.53,.61),vec2(.73,.50),vec2(.70,.28) );\n\n\n//float sdPoly11 POLY(11)\nvec2 pt11[ 11]=vec2[](  \nvec2(.38,.12),vec2(.36,.12),vec2(.34,.14),vec2(.31,.18),vec2(.31,.19),\nvec2(.31,.27),vec2(.31,.30),vec2(.32,.30),vec2(.34,.29),vec2(.35,.28),\nvec2(.38,.12) );\n\n\nfloat sdPoly12 POLY(12)\nvec2 pt12[ 12]=vec2[](  \nvec2(.67,.12),vec2(.69,.12),vec2(.71,.13),vec2(.74,.18),vec2(.74,.18),\nvec2(.75,.22),vec2(.75,.26),vec2(.75,.29),vec2(.74,.30),vec2(.73,.31),\nvec2(.70,.28),vec2(.67,.12) );\n\n\nfloat sdPoly13 POLY(13)\nvec2 pt13[ 13]=vec2[](  \nvec2(.41,.40),vec2(.39,.42),vec2(.41,.46),vec2(.42,.46),vec2(.44,.47),\nvec2(.47,.46),vec2(.47,.44),vec2(.49,.40),vec2(.48,.40),vec2(.47,.43),\nvec2(.45,.44),vec2(.43,.44),vec2(.41,.40) );\n\n\n//float sdPoly13 POLY(13)\nvec2 pt13b[ 13]=vec2[](  \nvec2(.56,.41),vec2(.58,.44),vec2(.59,.45),vec2(.61,.47),vec2(.64,.46),\nvec2(.65,.44),vec2(.67,.42),vec2(.65,.39),vec2(.64,.42),vec2(.62,.43),\nvec2(.61,.43),vec2(.59,.42),vec2(.56,.41) );\n\nfloat sdPoly14 POLY(14)\nvec2 pt14[ 14]=vec2[](  \nvec2(.40,.18),vec2(.39,.23),vec2(.39,.24),vec2(.39,.28),vec2(.40,.31),\nvec2(.42,.34),vec2(.43,.35),vec2(.45,.35),vec2(.46,.34),vec2(.48,.32),\nvec2(.49,.28),vec2(.49,.20),vec2(.46,.18),vec2(.40,.18) );\n\n\n//float sdPoly15 POLY(15)\nvec2 pt15c[ 15]=vec2[](  \nvec2(.57,.19),vec2(.56,.22),vec2(.56,.25),vec2(.56,.28),vec2(.57,.31),\nvec2(.58,.33),vec2(.60,.34),vec2(.62,.35),vec2(.64,.34),vec2(.65,.30),\nvec2(.65,.26),vec2(.64,.19),vec2(.62,.19),vec2(.59,.18),vec2(.57,.19) );\n\n\nfloat sdPoly6 POLY(6)\nvec2 pt6[ 6]=vec2[](  \nvec2(.51,.15),vec2(.51,.16),vec2(.52,.18),vec2(.52,.16),vec2(.52,.16),\nvec2(.51,.15) );\n\nfloat sdPoly9 POLY(9)\nvec2 pt9[ 9]=vec2[](  \nvec2(.48,.13),vec2(.51,.12),vec2(.53,.12),vec2(.55,.13),vec2(.58,.15),\nvec2(.55,.13),vec2(.52,.12),vec2(.51,.12),vec2(.48,.13) );\n\nvec2 RotarPuntoPivote(vec2 p,vec2 pXrYr, float theta)\n{\n     vec2 pp=p;\n     vec2 pos=pXrYr;\n     pp=pp-pos;\n     pp.xy = rotatev2(pp.xy, theta);\n     pp=pp+pos;   \n     return pp;\n}    \n\nvec3 RostroGoku(in vec2 ppp, vec3 col) \n{\n  vec2 pp=ppp;\n      float xr=0.5; float yr=0.25;\n     \n     \n     pp= RotarPuntoPivote(pp,vec2(xr,yr), iTime);\n     \n     //p=pp;    \n   \n  vec2 p=pp;\n  float sd1 = sdPoly25(p-vec2(0.0,-0.2), pt25);\n  float sd2 = sdPoly15(p-vec2(0.0,-0.2), pt15);\n  float sd3 = sdPoly15(p-vec2(0.0,-0.2), pt15b);\n  float sd4 = sdPoly18(p-vec2(0.0,-0.2), pt18);\n  float sd5 = sdPoly20(p-vec2(0.0,-0.2), pt20);\n  float sd6 = sdPoly11(p-vec2(0.0,-0.2), pt11); //orejas izq\n  float sd7 = sdPoly12(p-vec2(0.0,-0.2), pt12); //orejas der\n  float sd8 = sdPoly13(p-vec2(0.0,-0.2), pt13); //ceja izq\n  float sd9 = sdPoly13(p-vec2(0.0,-0.2), pt13b); //ceja der\n  float sd10 = sdPoly14(p-vec2(0.0,-0.2), pt14);\n  float sd11 = sdPoly15(p-vec2(0.0,-0.2), pt15c);\n  //nariz\n  float sd12 = sdPoly6(p-vec2(0.0,-0.2), pt6);\n  float sd13 = sdPoly9(p-vec2(0.0,-0.2), pt9);\n  float ojo1= sdCircle(  p-vec2(0.44+0.03*sin(iTime),0.05), 0.022 );\n  float ojo2= sdCircle(  p-vec2(0.59+0.03*sin(iTime),0.05), 0.022 );\n  \n  col = mix(col,vec3(0.0, 0.0,0.0),S(sd1,0.0));\n  col = mix(col,vec3(0.0, 0.0,0.0),S(sd2,0.0));\n  col = mix(col,vec3(0.98, 0.82,0.720),S(sd3,0.0));\n  col = mix(col,vec3(0.0, 0.0,0.0),S(sd4,0.0));\n  col = mix(col,vec3(0.0, 0.0,0.0),S(sd5,0.0));\n  //orejas\n  col = mix(col,vec3(0.92, 0.82,0.720),S(sd6,0.0));\n  col = mix(col,vec3(0.92, 0.82,0.720),S(sd7,0.0));\n  //cejas\n  col = mix(col,vec3(0.3, 0.3,0.3),S(sd8,0.0));\n  col = mix(col,vec3(0.3, 0.3,0.3),S(sd9,0.0));\n  col = mix(col,vec3(1.0, 1.0,1.0),S(sd10,0.0));\n  col = mix(col,vec3(1.0, 1.0,1.0),S(sd11,0.0));\n  col = mix(col,vec3(0.0, 0.0,0.0),S(sd12,0.0));\n  //boca\n  col = mix(col,vec3(0.0, 0.0,0.0),S(sd13,0.0));\n  //ojos\n  col = mix(col,vec3(0.3, 0.2,0.2),S(ojo1,0.0));\n  col = mix(col,vec3(0.3, 0.2,0.2),S(ojo2,0.0));\n  \n  return col;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{   vec2 uv = (fragCoord-iResolution.xy)/iResolution.y;\n    //posicion\n    vec2 p=uv+vec2(1.5,0.7);\n    // escala\n    p.x*=0.7;\n    \n    vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n     col= RostroGoku( p,col);\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/fs2GDW.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "fs2GRc", "name": "Lemniscate Intersect 2D", "author": "oneshade", "description": "I like this shape. Set the ray with the mouse.", "tags": ["ray", "raycasting", "intersect", "bernoulli", "lemniscate"], "likes": 4, "viewed": 63, "date": "1617744865", "time_retrieved": "2024-06-20T20:37:05.430760", "image_code": "// Convenience struct\nstruct Hit4 {\n    int numHits;\n    vec4 hits;\n};\n\n// Drawing utilities\n#define drawSDF(dist, transp, col) color = mix(color, col, smoothstep(unit, 0.0, dist) * transp)\n#define drawImplicit(func, ss, transp, col)                                                     \\\n    float total = 0.0;                                                                          \\\n    for (float i=0.0; i < 1.0; i += 1.0 / ss) {                                                 \\\n        for (float j=0.0; j < 1.0; j += 1.0 / ss) {                                             \\\n            vec2 offs = vec2(i, j) / iResolution.xy * 4.0;                                      \\\n            total += step(0.0, -func(uv + offs));                                               \\\n        }                                                                                       \\\n    }                                                                                           \\\n                                                                                                \\\n    color = mix(color, col, total / (ss * ss) * transp);                                        \\\n\n// SDFs\nfloat sdIsosceles(in vec2 p, in float b, in float h) {\n    p.x = abs(p.x);\n    float q = clamp((b - p.x + p.y) / (b + h), 0.0, 1.0);\n    vec2 re = vec2(p.x - b + b * q, p.y - h * q);\n    vec2 be = vec2(p.x - b * min(p.x / b, 1.0), p.y);\n    return sqrt(min(dot(re, re), dot(be, be))) * sign(p.x + (p.y - h) * b / h * sign(p.y));\n}\n\nfloat sdVerticalLine(in vec2 p, in float h) {\n    return length(vec2(p.x, p.y - h * clamp(p.y / h, 0.0, 1.0)));\n}\n\nfloat sdInfLine(in vec2 p, in vec2 a, in vec2 b) {\n    return abs(dot(p - a, normalize(b - a).yx * vec2(-1.0, 1.0)));\n}\n\nfloat sdVectorArrow(in vec2 p, in vec2 v) {\n    float m = length(v); vec2 n = v / m;\n    p = vec2(dot(p, n.yx * vec2(1.0, -1.0)), dot(p, n));\n    return min(sdVerticalLine(p, m) - 0.025, sdIsosceles(p - vec2(0.0, m), 0.1, 0.15));\n}\n\n// @mla's quartic solver (https://www.shadertoy.com/view/ltVfDK)\nfloat evalcubic(float x, float a, float b, float c, float d) {\n  return ((x * a + b) * x + c) * x + d;\n}\n\nfloat evalquad(float x, float a, float b, float c) {\n  return (x * a + b) * x + c;\n}\n\n// Solve a*x**2 + b*x + c == 0\nbool quadratic(float a, float b, float c, out vec2 t) {\n    float d = b * b - 4.0 * a * c;\n    if (d < 0.0) return false;\n    d = sqrt(d);\n    if (b < 0.0) d = -d;\n    t.x = 0.5 * (-b - d) / a;\n    t.y = c / (a * t.x);\n    if (t.x > t.y) t.xy = t.yx; // Sort results\n    return true;\n}\n\n// Find real root of x**3 + a*x**2 + b*x + c\n// Assume c < 0\nfloat cubic(float a, float b, float c) {\n    // c is always negative, but may be very\n    // small, in which case we return an\n    // approximation. Never return < 0.\n    if (c > -1e-6) {\n        if (b > 1e-10) return -c / b;\n        if (b > -1e-4) return 0.0;\n    }\n\n    // Now substitute to make c = -1\n    float k = 1.0;\n    k = pow(-c, 1.0 / 3.0);\n    a /= k; b /= k * k; c = -1.0;\n    // Now bracket a root between 0 and 1\n    // We may need to solve for 1/x\n    bool reciprocate = evalcubic(1.0, 1.0, a, b, c) < 0.0;\n    if (reciprocate) {\n        float a1 = -b;\n        float b1 = -a;\n        a = a1; b = b1;\n    }\n\n    vec2 res;\n    float x = 0.0;\n    // Chebyshev polynomial: |32x**3 - 48x**2 + 18x - 1| < 1\n    if (quadratic(a + 1.5, b - 0.5625, c + 0.03125, res)) {\n        // Find root closest to unit interval,\n        x = (abs(res[0] - 0.5) < abs(res[1] - 0.5)) ? res[0]: res[1];\n    }\n\n    // 3 rounds of Newton-Raphson\n    x -= evalcubic(x, 1.0, a, b, c) / evalquad(x, 3.0, 2.0 * a, b);\n    x -= evalcubic(x, 1.0, a, b, c) / evalquad(x, 3.0, 2.0 * a, b);\n    x -= evalcubic(x, 1.0, a, b, c) / evalquad(x, 3.0, 2.0 * a, b);\n\n    if (reciprocate) return k / x;\n    return k * x;\n}\n\nint quartic(float c1, float c2, float c3, float c4, out vec4 res) {\n    float alpha = 0.5 * c1;\n    float A = c2 - alpha * alpha;\n    float B = c3 - alpha * A;\n    float a, b, beta, psi;\n    if (B == 0.0) psi = 0.0;\n    else psi = cubic(2.0 * A - alpha * alpha, A * A + 2.0 * B * alpha - 4.0 * c4, -B * B);\n    a = sqrt(psi);\n    beta = 0.5 * (A + psi);\n    if (psi == 0.0) b = sqrt(max(beta * beta - c4, 0.0));\n    else b = 0.5 * a * (alpha - B / psi);\n\n    vec2 tmp;\n    int resn = 0;\n    if (quadratic(1.0, alpha + a, beta + b, tmp)) {\n        res.xy = tmp.xy;\n        resn += 2;\n    }\n\n    if (quadratic(1.0, alpha - a, beta - b, tmp)) {\n        res.zw = res.xy;\n        res.xy = tmp.xy;\n        resn += 2;\n    }\n\n    return resn;\n}\n\n// Intersection\nHit4 iBernoulliLemniscate(in vec2 ro, in vec2 rd) {\n    vec2 oo = ro * ro;\n    vec2 dd = rd * rd;\n    vec2 od = ro * rd;\n\n    float a = dot(dd, dd) + 2.0 * dd.y * dd.x;\n    float b = 4.0 * (od.x + od.y) * (dd.x + dd.y);\n\n    float c1 = 2.0 * ((oo.y - 1.0) * dd.x + (oo.x + 1.0) * dd.y);\n    float c2 = 6.0 * dot(oo, dd) + 8.0 * od.y * od.x;\n    float c = c1 + c2;\n\n    float sq = oo.x + oo.y;\n    float d = 4.0 * ((sq - 1.0) * od.x + (sq + 1.0) * od.y);\n    float e = dot(oo, oo) + 2.0 * ((oo.y - 1.0) * oo.x + oo.y);\n\n    vec4 roots;\n    int numRoots = quartic(b / a, c / a, d / a, e / a, roots);\n\n    return  Hit4(numRoots, roots);\n}\n\n// Implicit\nfloat deBernoulli(in vec2 p) {\n    vec2 p1 = vec2(p.x - 1.0, p.y);\n    vec2 p2 = vec2(p.x + 1.0, p.y);\n    return dot(p1, p1) * dot(p2, p2) - 1.0;\n}\n\n// Normal\nvec2 nBernoulliLemniscate(in vec2 p) {\n    return normalize(p * p * p + vec2(-p.x, p.y) + p.xx * p.yx * p.yy);\n}\n\n// Animation\nvec2 Velocity(in float t) {\n    vec2 p = vec2(0.0);\n    for (float n=0.0; n < 10.0; n++) {\n        float s = pow(2.0, n), ts = t * s;\n        p += vec2(cos(ts), sin(ts)) / s;\n    }\n\n    return p;\n}\n\n// Analytic integral\nvec2 Position(in float t) {\n    vec2 p = vec2(0.0);\n    for (float n=0.0; n < 10.0; n++) {\n        float ts = t * pow(2.0, n);\n        p += vec2(sin(ts), -cos(ts)) / pow(2.0, 2.0 * n);\n    }\n\n    return p;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 center = 0.5 * iResolution.xy;\n\n    vec4 mouse = (vec4(iMouse.xy, abs(iMouse.zw)) - center.xyxy) / iResolution.y * 4.0;\n    vec2 uv = (fragCoord - center) / iResolution.y * 4.0;\n    vec3 color = vec3(0.5 + 0.5 * nBernoulliLemniscate(uv), 0.0);\n    float unit = 8.0 / iResolution.y;\n\n    vec2 ro = Position(iTime);\n    vec2 rd = Velocity(iTime);\n    if (iMouse.z > 0.0) {\n        ro = mouse.zw;\n        rd = mouse.xy - mouse.zw;\n    }\n\n    drawImplicit(deBernoulli, 8.0, 0.5, vec3(0.0, 0.0, 1.0));\n\n    drawSDF(sdInfLine(uv, ro, ro + rd) - 0.001, 1.0, vec3(0.0));\n    drawSDF(sdVectorArrow(uv - ro, rd), 1.0, vec3(1.0));\n\n    // Find the closest hit in front of the camera\n    Hit4 hit = iBernoulliLemniscate(ro, rd);\n    for (int n=0; n < int(hit.numHits); n++) {\n        vec2 pos = ro + rd * hit.hits[n];\n        drawSDF(length(uv - pos) - 0.05, 1.0, vec3(1.0, 0.0, 0.0));\n    }\n\n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [{"id": "XsX3zn", "previewfilepath": "/media/ap/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png", "ctype": "cubemap"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/fs2GRc.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "fs2SRW", "name": "my version of a cardiogram", "author": "rockstep", "description": "looks sort of like a heartbeat but not really, apparently the pulses are supposed to have a slightly more complex structure\n\narguably the real thing isn't as aesthetic", "tags": ["2d"], "likes": 1, "viewed": 42, "date": "1619778352", "time_retrieved": "2024-06-20T20:37:05.430760", "image_code": "#define MAX_X 3.14159\n#define MAX_Y 1.5\n\nfloat pi = radians(180.);\n\nfloat pixelHeight() {\n    return (2. * MAX_Y) / iResolution.y;\n}\n\nfloat pixelWidth() {\n    return (2. * MAX_X) / iResolution.x;\n}\n\nfloat near(float a, float b) {\n    float diff = abs(a - b);\n    return smoothstep(4.*pixelHeight(), 0., diff);\n}\n\nfloat triWave(float theta) {\n    return (2. / pi) * asin(sin(theta));\n}\n\nfloat pulse(float theta) {\n    return step(mod(theta, 8. * pi), 2. * pi) * triWave(theta);\n}\n\nvoid mainImage(out vec4 rgba, in vec2 xy) {\n    vec2 uv = xy - 0.5 * iResolution.xy;\n    uv.x *= pixelWidth();\n    uv.y *= pixelHeight();\n    \n    float theta = uv.x + 2. * iTime;\n    float p = pulse(5. * theta);\n    vec3 col = vec3(0.,1.,0.) * vec3(near(p, uv.y));\n    rgba = vec4(col,1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/fs2SRW.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "fs2Sz1", "name": "lattice 00", "author": "boxes", "description": "infinite square lattice. i tried to add enough comments so it'd be self-explanatory. new to GLSL and really enjoying it. i used a couple of small but pleasant tricks for seamlessly moving through the grid, the fog ramp, subtly rounding out corners.", "tags": ["domainrepetition", "monochrome"], "likes": 2, "viewed": 68, "date": "1619660235", "time_retrieved": "2024-06-20T20:37:06.218555", "image_code": "precision mediump float;\n\n#define PI 3.141592653589793\n#define TWO_PI 6.283185307179586\n#define MAX_STEPS 1024\n#define DISTANCE_THRESHOLD 0.02 // large threshold to round out corners\n\n// from https://www.iquilezles.org/www/articles/distfunctions/distfunctions.htm\nfloat box(in vec3 p, in vec3 b) {\n    vec3 q = abs(p) - b;\n    return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\n\n// check distance for all shapes\nfloat f( in vec3 p ) {\n    vec3 c = vec3(0.5, 0.5, 0.5); // grid intersection is at center so distance is correct at iteration edges\n    \n    vec3 w = vec3( fract(p.x / 4.0), // domain repetition every 4 world units\n                   fract(p.y / 4.0),\n                   fract(p.z / 4.0) );\n    \n    float t = 1.0 / 32.0;\n    float v = 1.0 / 32.0 + 1.0 / 128.0;\n    float l = 0.5;\n    float d = box(c - w, vec3(l, t, t));\n    d = min(d, box(c - w, vec3(t, l, t)));\n    d = min(d, box(c - w, vec3(t, t, l)));\n    d = min(d, box(c - w, vec3(v, v, v)));\n    // could probably sub in some kind of distance from grid line function instead of 3 boxes\n    return d;\n}\n\nvec3 get_normal( in vec3 p ) {  // sample along 3 axes to get a normal  \n    const float o = 0.0009765625; // 1 / 1024\n    float c = f(p); // calculate redundantly for now to avoid the bug\n    const vec2 h = vec2(o, 0); // transpose instead of making new per axis\n    return normalize(vec3( f(p + h.xyy) - c,\n                           f(p + h.yxy) - c,\n                           f(p + h.yyx) - c) );\n}\n\nfloat cast_ray(inout vec3 p, in vec3 h) {\n    float depth = 0.0;\n    float d;\n    for (int a = 0; a < MAX_STEPS; a ++) {\n        d = f(p);     // test distance\n        p += d * h;   // step the point\n        depth += d;\n        if (d < DISTANCE_THRESHOLD) {\n            break;\n        }\n    }\n    return d;\n}\n\n// from https://www.iquilezles.org\n// --------------------------------------\n// oldschool rand() from Visual Studio\n// --------------------------------------\nint   seed = 1;\nvoid  srand(int s ) { seed = s; }\nint   rand(void) { seed=seed*0x343fd+0x269ec3; return (seed>>16)&32767; }\nfloat frand(void) { return float(rand())/32767.0; }\n// --------------------------------------\n// hash to initialize the random seed (copied from Hugo Elias)\n// --------------------------------------\nint hash( int n ) { n=(n<<13)^n; return n*(n*n*15731+789221)+1376312589; }\n\nvec3 spherical() {\n    float z = frand() * 2.0 - 1.0;\n    float angle = TWO_PI * frand();\n    return vec3( sqrt(1.0 - z*z) * cos(angle), \n                 sqrt(1.0 - z*z) * sin(angle),\n                 z );\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // random seed\n    ivec2 q = ivec2(gl_FragCoord); \n    srand(hash(q.x + hash(q.y + hash(int(1000.0 * iTime)))));\n\n    // convert to 1:1 coordinates. the first number controls grid scale.\n    vec2 uv = 1.0 * (gl_FragCoord.xy - 0.5 * iResolution.xy) / iResolution.y; \n  \n    // camera plane\n    float pitch = PI * 1.0 / 3.0 * sin(0.021193 * iTime);\n    float heading = PI * sin(0.082315 * iTime); // these are desynced from movement so they phase\n    vec3 pos = vec3(iTime + 1.0, iTime, iTime + 3.0);\n    // this walks diagonally along a path which crosses no girders\n    // we wrap after exiting the first iteration\n    pos = 4.0 * vec3( fract( 0.25 * pos.x ), \n                      fract( 0.25 * pos.y ),\n                      fract( 0.25 * pos.z ) );\n    vec3 h = vec3( cos(heading) * cos(pitch), \n                   sin(heading) * cos(pitch), \n                   sin(pitch));\n    vec3 ref = vec3(0.0, 0.0, 1.0);   // z axis\n    h = -normalize(h);         // ray heading\n    vec3 i = cross(h, ref);    // corresponds to x in screen space\n    vec3 j = cross(i, h);      // corresponds to y in screen space\n    \n    h += i * uv.x; h += j * uv.y; // heading offsets, from pixel\n    normalize(h);\n\n\n    // light\n    vec3 light = vec3(0.5, 0.25, 0.5);\n    normalize(light);\n    \n\n    // cast ray\n    float d = cast_ray(pos, h); // this updates pos\n    vec3 normal = get_normal(pos);\n\n    float s = 1.0; // darkening factor. starts at 1.0. occlusion lowers this\n    \n    // ambient occlusion\n    for (float i = 0.0; i < 1.0; i += 0.25) {\n        float occlusion_offset = 0.1 * i * i;\n        s -= 32.0 * clamp(0.25 * ( (occlusion_offset + d)\n                           - f(pos + occlusion_offset * normal) ), \n                           0.0, 1.0);\n    }\n    \n\n    // lighting, fog etc.\n    \n    \n    // i/x (with offsets) yields an asymptote at infinity instead of a fog wall a finite distance away\n    float value = 0.25 * dot(h, normal);\n    float fog = (1.0 - 1.0 / (length(pos) * 0.005 + 1.0));\n    \n    value += 1.0 / 8.0 * (frand() - 0.5); // the noise is part of the diffuse light, so it's dimmed by ambient occlusion\n    value = value * s + fog;\n\n    fragColor = vec4( value, value, value, \n                      1.0 );\n\n    // fragColor = vec4( normal.x * 0.5 + 0.5, \n    //                   normal.y * 0.5 + 0.5, \n    //                   normal.z * 0.5 + 0.5, \n    //                   1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/fs2Sz1.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "fs2Szh", "name": "December Overkill 2020 MS", "author": "MonsieurSoleil", "description": "Coding style test", "tags": ["livecoding"], "likes": 1, "viewed": 46, "date": "1619644471", "time_retrieved": "2024-06-20T20:37:08.364284", "image_code": "/*\n    So,\n    This shader is important, because it's the first attemp i made to create my own \n    Code structure.\n\n    The basic idea is to code a certain way it's easy for me to \n    learn/add/remove/integrate new codes from \n    personnal work, research, art residencies, livecoding.\n    \n    The main goal that motivates it, is to be able to VJ with raymarching/bonzomatic only\n    and so to use always the same tools.\n\n\tI've learned shaders by watching Nusan's, leon, flopine, eviiiiil, iq, and other shadertoy coder's, code.\n\tThx to you, I'm learning in a way that suits me, art.\n*/\n\n#define time iTime\n#define mod01 floor(mod(time * 1.0, 4.0))\n#define mod02 floor(mod(time * 2.0, 4.0))\n#define mod03 floor(mod(time * 2.0, 8.0))\n#define mod04 floor(mod(time * 4.0, 8.0))\n\nstruct matter\n{\n  float m;\n  int type;\n  bool reflected;\n  vec3 p;\n  vec3 dir;\n  float dist;\n  float glow;\n  vec3 col;\n  bool doBreak;\n};\n\nmat2 rot(float a)\n{\n    float ca=cos(a);\n  float sa = sin(a);\n  \n  return mat2(ca, sa, -sa, ca);\n}\n\nfloat sphere(vec3 p, float s)\n{\n  return length(p) - s;\n}\n\nfloat box(vec3 p, vec3 s)\n{\n  p = abs(p) - s;\n  \n  return max(p.x, max(p.y, p.z));\n}\n\nvec3 random3f(vec3 p)\n{\n    return texture(iChannel0, (p.xy + vec2(2.0, 1.0) * p.z * 0.5) / 256.0, 0.0).xyz;\n}\n\nfloat rnd(vec2 x)\n{\n    return fract(dot(sin(x * 1235.236 + x.yx * 521.326), vec2(451.2365)));\n}\n\nfloat fbm(vec3 x) {\n\tfloat v = 0.0;\n\tfloat a = 0.5;\n\tvec3 shift = vec3(100);\n\tfor (int i = 0; i < 3; ++i) {\n\t\tv += a * random3f(x).x;\n\t\tx = x * 2.0 + shift;\n\t\ta *= 0.5;\n\t}\n\treturn v;\n}\n\nvec3 voronoi(in vec3 x)\n{\n   vec3 p = floor( x );\n  vec3 f = fract( x );\n  \n  float id = 0.0;\n  vec2 res = vec2(100.0);\n  for(int k = -1; k < 1; ++k)\n  for(int j = -1; j < 1; ++j)\n  for(int i = -1; i < 1; ++i)\n  {\n    vec3 b = vec3(float(i),float(j),float(k));\n    vec3 r = vec3(b) - f + random3f( p + b);\n    float d = dot(r,r);\n    \n    if(d < res.x)\n    {\n        id = dot(p+b, vec3(1.0, 57.0, 113.0));\n      res = vec2(d, res.x);\n    } else if (d < res.y)\n    {\n      res.y = d;\n    }\n    \n  }\n  \n  return vec3(sqrt(res), abs(id)) ;\n}\n\nfloat Circleline(vec3 p, float s)\n{\n    float mat01;\n\n    mat01 = sphere(p, s);\n\n    mat01 = max(mat01, -box(p + vec3(0.0, 0.0, 0.525*s), vec3(s*2.0,s*2.0, 0.5250255*s)));\n    mat01 = max(mat01, -box(p - vec3(0.0, 0.0, 0.525*s), vec3(s*2.0,s*2.0, 0.5250255*s)));\n\n    mat01 = max(mat01, -sphere(p, s*0.996));\n    \n    return mat01;\n}\n\nvec2 repeat(vec2 p, float rep)\n{\n    return (fract(p/rep - 0.5) - 0.5) * rep;\n}\n\nfloat repeat(float p, float rep)\n{\n    return (fract(p/rep - 0.5) - 0.5) * rep;\n}\n\nvec2 id(vec2 p, float rep)\n{\n    return (floor(p/rep - 0.5) - 0.5) * rep;\n}\n\nvec2 repLim(vec2 p, vec2 c, float l)\n{\n  vec2 q = p-c*clamp(round(p/c), -l, l);\n  return q;\n}\n\nvoid map01(inout matter mat, vec3 p)\n{\n  \n  \n  \n  vec3 p01 = p, p02 = p, p03 = p;\n  \n  p.xz *= rot(sin(time * 0.0002) * 2.0  * mod03) ;\n  p.yz *= rot(sin(time * 0.0002) * 1.0  * mod03) ;\n  \n  p01.z = repeat(p.z, 0.95);\n  p02.z = repeat(p.z, 0.45);\n  p03.z = repeat(p.z, 0.25);\n  \n  \n  float mat01 = Circleline(p01 + vec3(0.10 * cos(time * 0.75), 0.0, 0.15 * sin(time * 0.75)), 0.2 * mod04 + 0.1);\n  float mat02 = Circleline(p02 + vec3(0.10 * sin(time * 0.15), 0.0, 0.10 * sin(time * 0.15)), 0.2 * mod03 + 0.5);\n  float mat03 = Circleline(p02 + vec3(0.15 * sin(time * 0.05), 0.0, 0.15 * sin(time * 0.01)), 0.25 * mod02 + 0.3);\n  \n  float mat04 = -box(p, vec3(7.5));\n  \n  if(mat04 < 0.01)\n  {\n      mat.type = 1;\n    \n  }\n  \n     \n  mat.m = min(mat01, mat02);\n   mat.m = min(mat.m, mat03);\n    mat.glow += 0.15/(0.05+abs(mat.m));\n  \n  //mat.m = matFinal;\n}\n\nvoid map02(inout matter mat, vec3 p)\n{\n  p.xz *= rot(time * 0.5);\n  p.yz *= rot(time * 0.5);\n  \n  vec3 p01 = p, p02 = p;\n  \n  \n  \n  vec2 id01 = id(p.xz,  0.5 * mod02 + 2.5);\n  vec2 id02 = id(p.xy,  0.5 * mod02 + 2.5);\n  p01.xz = repLim(p.xz, vec2(0.1 + mod03 * 0.025), 0.5 * mod02 + 2.5);\n  p02.xy = repLim(p.xy, vec2(0.1 + mod03 * 0.025), 0.5 * mod02 + 2.5);\n  \n  float rnd01 = rnd(id01 * 32.0);\nfloat rnd02 = rnd(id02 * 32.0);\n  \n  float mat01 = box(p01, vec3(0.01,(0.1 * mod01 + 0.5 + fract(time * 1.25) * rnd01 * 0.2) , 0.01));\n  \nfloat mat02 = box(p02, vec3(0.01,0.01, (0.1 * mod01 + 0.1 + ((fract(time * 0.25) * rnd02 * mod03 * 0.5))) ));\n  \n     \n  \n  mat.m = min(mat01, mat02);\n    mat.glow += 0.15/(0.05+abs(mat.m));\n  //mat.m = matFinal;\n}\n\nvoid map03(inout matter mat, vec3 p)\n{\n // p.xy *= rot(0.01 * mod03);\n  //p.yz *= rot(0.01 * mod03);\n  //p.yz *= rot(0.2 * mod03);\n  \n  vec3 p01 = p;\n  \n  float mat04 = -box(p - vec3(0.0, 1.5, 2.0 * time), vec3(4.5));\n  \n  if(mat04 < 0.01)\n  {\n      mat.type = 1;\n  }\n  \n  //float mat01 = box(p, vec3(0.05, 0.05, 0.05));\n  vec2 id01 = id(p.xz, 1.2);\n  p01.xz = repeat(p.xz, 1.2);\n  float rnd01 = rnd(id01 * 8.0);\n  \n  float mat01 = box(p01 + vec3(0.0, 0.25 * sin(p.z * 0.4 + time * 4.0) + 1.5, 0.0), vec3(0.5,0.02 * mod03 + 0.2 + rnd01 * 1.5, 0.5));\n  float mat02 = box(p01 + vec3(0.0, 1.25 * sin(p.z * 0.15 + time * 2.0) - 5.5, 0.0), vec3(0.5,0.02 * mod03 + 0.2 + rnd01 * 1.5, 0.5));\n  \n  mat.m = min(mat01, mat02);\n  \n  mat.glow += 0.15/(0.05+abs(mat.m));\n}\n\nvec3 normals01(vec3 p)\n{\n    vec2 uv = vec2(0.01, 0.0);\n  \n  matter m01, m02, m03, m04;\n  \n  map01(m01, p);\n  map01(m02, p - uv.xyy);\n  map01(m03, p - uv.yxy);\n  map01(m04, p - uv.yyx);\n  \n  return normalize(m01.m - vec3(m02.m, m03.m, m04.m));\n  \n}\n\nvec3 normals03(vec3 p)\n{\n    vec2 uv = vec2(0.01, 0.0);\n  \n  matter m01, m02, m03, m04;\n  \n  map03(m01, p);\n  map03(m02, p - uv.xyy);\n  map03(m03, p - uv.yxy);\n  map03(m04, p - uv.yyx);\n  \n  return normalize(m01.m - vec3(m02.m, m03.m, m04.m));\n  \n}\n\nvoid Glow01(inout matter mat)\n{\n  mat.col += pow(mat.glow * 0.0085 * abs(sin(mat.p.z * 0.05 * ((mod03)/ 4.0) + time * 2.0)), 8.5) * vec3(1.0, 1.0, 1.0);\n}\n\nvoid Glow02(inout matter mat)\n{\n  mat.col -= pow(mat.glow * 0.02 * abs(sin(mat.p.z * 1.55 + time * 12.0))  + 0.005 * mod03 , 6.0) * vec3(1.0, 1.0, 1.0);\n}\n\nvoid Glow03(inout matter mat)\n{\n  mat.col += pow(mat.glow * 0.006 * abs(sin(mat.p.z * 0.55 + time * 4.0))  + 0.0025 * mod04, 12.0) * vec3(1.0, 1.0, 1.0);\n}\n\nvoid chooseMap(inout matter mat)\n{\n    if(mod01 == 0.0f)\n    {\n      map01(mat, mat.p);\n    }\n    if(mod01 > 0.0 && !(mod01 > 1.0))\n    {\n      map01(mat, mat.p);\n    }\n    if(mod01 > 1.0 && !(mod01 > 2.0))\n    {\n      map03(mat, mat.p);\n    }\n    if(mod01 > 2.0)\n    {\n      map02(mat, mat.p);\n    }\n}\n\nvoid ChooseGlow(inout matter mat)\n{\n    if(mod01 == 0.0f)\n    {\n      Glow01(mat);\n    }\n    else if(mod01 > 0.0 && !(mod01 > 1.0))\n    {\n      Glow01(mat);\n    }\n    else if(mod01 > 1.0 && !(mod01 > 2.0))\n    {\n      Glow03(mat);\n    }\n    else if(mod01 > 2.0)\n    {\n      Glow02(mat);\n    }\n}\n\nvoid Process01(inout matter mat)\n{\n  if(mat.m < 0.01)\n  {\n    mat.m = 0.05;\n    \n    if(mat.type == 1 && mat.reflected == false)\n    {\n      vec3 n = normals01(mat.p);\n      mat.dir = reflect(-n, mat.dir);\n      mat.type = 0;\n       mat.reflected = true;\n     // mat.col = vec3(1.0, 0.0, 0.0);\n    }\n    \n  }\n  \n  if(mat.m < 0.0002)\n  {\n    mat.m = 1.5;\n    \n    \n    \n  }\n}\n\nvoid Process02(inout matter mat)\n{\n  if(mat.m < 0.02)\n  {\n    mat.m = 0.7;\n    \n    if(mat.type == 1 && mat.reflected == false)\n    {\n      vec3 n = normals01(mat.p);\n      mat.dir = reflect(-n, mat.dir);\n      mat.type = 0;\n       mat.reflected = true;\n     // mat.col = vec3(1.0, 0.0, 0.0);\n    }\n  }\n}\n\nvoid Process03(inout matter mat)\n{\n  if(mat.m < 0.01)\n  {\n    mat.m = 1.5;\n    \n    if(mat.type == 1)\n    {\n      vec3 n = normals03(mat.p);\n      mat.dir = reflect(-n, mat.dir);\n      mat.type = 1;\n       mat.reflected = true;\n      //mat.col = vec3(1.0, 0.0, 0.0);\n    }\n  }\n}\n\nvoid ChooseProcess(inout matter mat)\n{\n    if(mod01 == 0.0f)\n    {\n      Process01(mat);\n    }\n    else if(mod01 > 0.0 && !(mod01 > 1.0))\n    {\n      Process01(mat);\n    }\n    else if(mod01 > 1.0 && !(mod01 > 2.0))\n    {\n      Process02(mat);\n    }\n    else if(mod01 > 2.0)\n    {\n      Process02(mat);\n    }\n}\n\nvec3 ChooseOrigin()\n{\n  if(mod01 == 0.0f)\n    {\n      return vec3(0.0, 0.0, 2.0 * time + mod02 * 0.5);\n    }\n    if(mod01 > 0.0 && !(mod01 > 1.0))\n    {\n       return vec3(0.0, 0.0, 2.0 * time + mod03 * 0.2);\n    }\n    if(mod01 > 1.0 && !(mod01 > 2.0))\n    {\n       return vec3(0.0, 1.5, 2.0 * time + mod04 * 2.0);\n    }\n    if(mod01 > 2.0)\n    {\n        return vec3(10.0 * cos(time * 1.0), 0.5, 0.5 * sin(time * 0.5));\n    }\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2 uv = vec2(fragCoord/iResolution.xy);\n  uv -= 0.5;\n  uv /= vec2(iResolution.y / iResolution.x, 1);matter mat;\n  \n  if(mod01 > 2.0)\n  {\n     mat.col = vec3(1.0);\n  }\n  \n  vec3 o = ChooseOrigin(), t = vec3(0.0);\n  vec3 fr = normalize(t - o);\n  vec3 ri = normalize(cross(vec3(0., 1.0, 0.0), fr));\n  vec3 up = normalize(cross(fr, ri));\n  \n  mat.dir = normalize(fr + uv.x * ri + uv.y *up);\n  mat.p = mat.dir * 0.25 + o;\n  \n  for(int i = 0; i < 100; ++i)\n  {\n    chooseMap(mat);\n\n    ChooseProcess(mat);\n\n    ChooseGlow(mat);\n\n    mat.p += mat.m * mat.dir;\n    mat.dist += mat.m;\n  }\n  \n  if(mod01 > 1.0 && mod01 <= 2.0)\n  {\n    //mat.col = clamp((mat.dist/100.0), 0.0, 1.0) * vec3(1.5);\n     //mat.col += pow(clamp((mat.dist/100.0), 0.0, 1.0) * vec3(0.0, 0.5, 1.0) * 0.15, vec3(2.0));\n  }\n  \n  mat.col = pow(mat.col, vec3(1.0/2.2)) * 0.75;\n  \n  fragColor = vec4(mat.col,1.0);\n}", "image_inputs": [{"id": "4dXGzn", "previewfilepath": "/media/ap/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/fs2Szh.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "fs2XRW", "name": "Voronoi blobs", "author": "Elise", "description": "Voronoi diagram based shader with mouse interaction.", "tags": ["voronoi"], "likes": 6, "viewed": 90, "date": "1619780703", "time_retrieved": "2024-06-20T20:37:08.364284", "image_code": "\n#ifdef GL_ES\nprecision mediump float;\n#endif\n\nvec2 random2( vec2 p )\n {\n    return fract(sin(vec2(dot(p,vec2(127.1,311.7)),dot(p,vec2(269.5,183.3))))*43758.5453);\n}\nfloat voronoi(vec2 i_stP, vec2 f_stP, vec2 stP, float scalarP)\n{\n    float m_distP = 1.;\n\n    for (int y= -1; y <= 1; y++) {\n        for (int x= -1; x <= 1; x++) {\n            vec2 neighbor = vec2(x,y);\n            vec2 point = random2(i_stP + neighbor );\n            point = 0.5 + 0.5*sin(iTime + 6.2831*point);\n            vec2 diff = neighbor + point - f_stP;\n            float dist = dot(diff, diff);\n            if(dist *m_distP < m_distP)\n            {\n                m_distP = dist*m_distP;\n            }\n        }\n    }\n//MOUSE INTERACTION\n    vec2 mousePoint = iMouse.xy/iResolution.y*scalarP;\n    vec2 diffMouse = mousePoint - stP;\n    float distMouse = dot(diffMouse, diffMouse);\n    if(distMouse * m_distP < m_distP)\n    {\n        m_distP = distMouse * m_distP;\n    }\n    return m_distP;\n}\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 st = fragCoord.xy/iResolution.xy;\n    st.x *= iResolution.x/iResolution.y;\n    vec3 color = vec3(.0);\n\n    float scalar = 10.;\n    st *= scalar;\n\n    vec2 i_st = floor(st);\n    vec2 f_st = fract(st);\n\n    float m_dist = voronoi(i_st, f_st, st, scalar);\n\n    color += m_dist/0.01;\n    // Draw cell center\n    //color -= 1.-step(.02, m_dist);\n    // Draw grid\n    //color.r += step(.98, f_st.x) + step(.98, f_st.y);\n\n    fragColor = vec4(color,1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/fs2XRW.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "fsB3DD", "name": "Noise and UV Mapping_HW09", "author": "roamingsci", "description": "This is a practice using noise functions to generate height fields and textures.", "tags": ["noise", "cornellbox", "uvmapping"], "likes": 0, "viewed": 28, "date": "1617389818", "time_retrieved": "2024-06-20T20:37:10.273601", "image_code": "#define IDBackWall 1\n#define IDLeftWall 2\n#define IDRightWall 3\n#define IDCeilingWall 4\n#define IDFloorWall 5\n#define IDLongCube 6\n#define IDSphere 7\nconst int RAY_STEPS = 256;\nconst float FOVY = 3.141569 * 0.25;\nconst float PI = 3.1415926;\n\nstruct Intersection\n{\n    float t;\n    vec3 color;\n    vec3 p;\n    int object;\n};\n\nfloat sphere(vec3 p, float r, vec3 c)\n{\n    return distance(p, c) - r;\n}\n\nvec2 sphereUV(vec3 center, float r, vec3 p)\n{\n    vec3 pDir = normalize(p - center);\n    vec3 worldUp = vec3(0.0, 1.0, 0.0);\n    float theta = acos(dot(pDir, worldUp));\n    // If p is located at the positive part of z axis, then phi is 0-180.\n    // If p is located at the negative part of z axis, then phi is 180-360.\n    vec3 xzDir = normalize(vec3(pDir.x, 0.0, pDir.z));\n    float phi = acos(dot(xzDir, vec3(1.0, 0.0, 0.0)));\n\n    if(pDir.z < 0.0)\n    {\n        phi = phi + PI;\n    }\n\n    return vec2(theta / PI, phi / (2.0 * PI));\n}\n\nvoid planeUVAxis(in vec3 p, in vec3 n, out vec3 u, out vec3 v)\n{\n    vec3 worldUp = vec3(0.0, 1.0, 0.0);\n    u = normalize(cross(worldUp, n));\n    v = normalize(cross(n, u));\n}\n\nvec2 planeUV(vec3 origin, vec3 n, vec3 p)\n{\n    vec3 uAxis;\n    vec3 vAxis;\n    planeUVAxis(origin, n, uAxis, vAxis);\n    vec3 diff = p - origin;\n    float uVal = dot(diff, uAxis);\n    float vVal = dot(diff, vAxis);\n    return vec2(uVal, vVal);\n}\n\nvec3 random3( vec3 p ) {\n    return fract(sin(vec3(dot(p,vec3(127.1, 311.7, 191.999)),\n                          dot(p,vec3(269.5, 183.3, 765.54)),\n                          dot(p, vec3(420.69, 631.2,109.21))))\n                 *43758.5453);\n}\n\nvec2 random2( vec2 p ) {\n    return fract(sin(vec2(dot(p,vec2(127.1,311.7)),dot(p,vec2(269.5,183.3))))*43758.5453);\n}\n\nfloat random1( vec2 p ) {\n    return fract(sin(dot(p,vec2(127.1,311.7)))*43758.5453);\n}\n\nfloat WorleyNoise(vec2 uv) {\n    // Tile the space\n    uv *= 1.0;\n    vec2 uvInt = floor(uv);\n    vec2 uvFract = fract(uv);\n    float minDist = 1.0; // Minimum distance initialized to max.\n\n    // Search all neighboring cells and this cell for their point\n    for(int y = -1; y <= 1; y++) {\n        for(int x = -1; x <= 1; x++) {\n            vec2 neighbor = vec2(float(x), float(y));\n\n            // Random point inside current neighboring cell\n            vec2 point = random2(uvInt + neighbor);\n\n            // Animate the point\n            point = 0.5 + 0.5 * sin(iTime + 6.2831 * point); // 0 to 1 range\n\n            // Compute the distance b/t the point and the fragment\n            // Store the min dist thus far\n            vec2 diff = neighbor + point - uvFract;\n            float dist = length(diff);\n            minDist = min(minDist, dist);\n        }\n    }\n    return minDist;\n}\n\nfloat snow(vec2 p) {\n    return pow(cos(WorleyNoise(p * 1.6 + 0.0026 * iTime)), 100.0);\n}\n\nfloat snow2(vec2 p) {\n    return pow(cos(WorleyNoise(p * 0.8 + 0.0031 * iTime)), 100.0);\n}\n\nfloat snow3(vec2 p) {\n    return pow(cos(WorleyNoise(p * 0.4 + 0.0036 * iTime)), 100.0);\n}\n\nfloat snow4(vec2 p) {\n    return pow(cos(WorleyNoise(p * 0.2 + 0.0041 * iTime)) , 100.0);\n}\n\n#define FBM_OCTAVES 4\n\nfloat mySmootherStep(float a, float b, float t) {\n    t = t*t*t*(t*(t*6.0 - 15.0) + 10.0);\n    return mix(a, b, t);\n}\n\nfloat bilerpNoise(vec2 uv) {\n    vec2 uvFract = fract(uv);\n    float ll = random1(floor(uv));\n    float lr = random1(floor(uv) + vec2(1,0));\n    float ul = random1(floor(uv) + vec2(0,1));\n    float ur = random1(floor(uv) + vec2(1,1));\n\n    float lerpXL = mySmootherStep(ll, lr, uvFract.x);\n    float lerpXU = mySmootherStep(ul, ur, uvFract.x);\n\n    return mySmootherStep(lerpXL, lerpXU, uvFract.y);\n}\n\nfloat fbm(vec2 uv) {\n    float amp = 0.5;\n    float freq = 8.0;\n    float sum = 0.0;\n    for(int i = 0; i < FBM_OCTAVES; i++) {\n        sum += bilerpNoise(uv * freq) * amp;\n        amp *= 0.5;\n        freq *= 2.0;\n    }\n    return sum * cos(iTime * 0.5);\n}\n\nfloat surflet3D(vec3 p, vec3 gridPoint)\n{\n    vec3 t3 = abs(p - gridPoint);\n\n    float tX = 1.0 - 6.0 * pow(t3.x, 5.0) - 15.0* pow(t3.x, 4.0) + 10.0 * pow(t3.x, 3.0);\n    float tY = 1.0 - 6.0 * pow(t3.y, 5.0) - 15.0 * pow(t3.y, 4.0) + 10.0 * pow(t3.y, 3.0);\n    float tZ = 1.0 - 6.0 * pow(t3.z, 5.0) - 15.0 * pow(t3.z, 4.0) + 10.0 * pow(t3.z, 3.0);\n\n    vec3 t = vec3(tX, tY, tZ);\n\n    vec3 gradient = random3(gridPoint);\n    vec3 diff = p - gridPoint;\n    float height = dot(diff, gradient);\n    return height * t.x * t.y * t.z;\n}\n\nfloat PerlinNoise3D(vec3 p)\n{\n    float surfletSum = 0.0;\n    vec3 pXLYLZL = floor(p);\n\n    for(int dx = 0; dx <= 1; ++dx)\n    {\n        for(int dy = 0; dy <= 1; ++dy)\n        {\n            for(int dz = 0; dz <= 1; ++dz)\n            {\n                surfletSum += surflet3D(p, pXLYLZL + vec3(dx, dy, dz));\n            }\n        }\n    }\n\n    return surfletSum * sin(iTime * 0.5);\n}\n\n// use a cosine color palette for noise color\nvec3 a = vec3(0.888, 0.548, 0.648);\nvec3 b = vec3(0.541, 0.883, 0.895);\nvec3 c = vec3(1.402, 1.414, 1.605);\nvec3 d = vec3(0.587, 2.017, 2.287);\n\nvec3 colorPalette(float t)\n{\n    return a + b * cos(2.0 * PI * (t * c + d));\n}\n\nvec3 rotateY(vec3 p, float a) {\n    return vec3(cos(a) * p.x + sin(a) * p.z, p.y, -sin(a) * p.x + cos(a) * p.z);\n}\n\nfloat plane( vec3 p, vec4 n )\n{\n  // n must be normalized\n  return dot(p,n.xyz) + n.w;\n}\n\n// Box with side lengths b\nfloat box(vec3 p, vec3 b)\n{\n  return length(max(abs(p) - b, 0.0));\n}\n\nvoid sceneMap3D(vec3 pos, out float t, out int obj)\n{\n    // Initialize to back wall sdf\n    t = plane(pos, vec4(0.0, 0.0, -1.0, 5.0));\n    obj = IDBackWall;\n\n    float t2;\n    // Check left wall\n    if((t2 = plane(pos, vec4(1.0, 0.0, 0.0, 5.0))) < t)\n    {\n        t = t2;\n        obj = IDLeftWall;\n    }\n    // Check right wall\n    if((t2 = plane(pos, vec4(-1.0, 0.0, 0.0, 5.0))) < t)\n    {\n        t = t2;\n        obj = IDRightWall;\n    }\n    // Check top ceiling wall\n    if((t2 = plane(pos, vec4(0.0, -1.0, 0.0, 7.5))) < t)\n    {\n        t = t2;\n        obj = IDCeilingWall;\n    }\n    // Check floor wall\n    if((t2 = plane(pos, vec4(0.0, 1.0, 0.0, 2.5))) < t)\n    {\n        t = t2;\n        obj = IDFloorWall;\n    }\n    // Check for long cube\n    if((t2 = box(rotateY(pos + vec3(0, 1, -2), -27.5 * 3.14159 / 180.0), vec3(1.5, 4, 1.5))) < t)\n    {\n        t = t2;\n        obj = IDLongCube;\n    }\n    // Check for sphere\n    if((t2 = sphere(pos, 1.3, vec3(-3.5 * sin(iTime), 0.6 + 2.0 * cos(iTime), 3.5 * cos(iTime)))) < t)\n    {\n        t = t2;\n        obj = IDSphere;\n    }\n}\n\nfloat sceneMap3D(vec3 pos)\n{\n    // find the smallest t value for marching\n    float t = plane(pos, vec4(0.0, 0.0, -1.0, 5.0));\n\n    t = min(t, plane(pos, vec4(1.0, 0.0, 0.0, 5.0)));\n    t = min(t, plane(pos, vec4(-1.0, 0.0, 0.0, 5.0)));\n    t = min(t, plane(pos, vec4(0.0, -1.0, 0.0, 7.5)));\n    t = min(t, plane(pos, vec4(0.0, 1.0, 0.0, 2.5)));\n    t = min(t, box(rotateY(pos + vec3(0, 1, -2), -27.5 * 3.14159 / 180.0), vec3(1.5, 4, 1.5)));\n    t = min(t, sphere(pos, 1.3, vec3(-3.5 * sin(iTime), 0.6 + 2.0 * cos(iTime), 2.0 + 3.5 * cos(iTime))));\n\n    return t;\n}\n\n\nvec3 computeNormal(vec3 pos)\n{\n    vec3 epsilon = vec3(0.0, 0.001, 0.0);\n    return normalize( vec3( sceneMap3D(pos + epsilon.yxx) - sceneMap3D(pos - epsilon.yxx),\n                            sceneMap3D(pos + epsilon.xyx) - sceneMap3D(pos - epsilon.xyx),\n                            sceneMap3D(pos + epsilon.xxy) - sceneMap3D(pos - epsilon.xxy)));\n}\n\nvoid march(vec3 origin, vec3 dir, out float t, out int hitObj)\n{\n    t = 0.001;\n    for(int i = 0; i < RAY_STEPS; ++i)\n    {\n        vec3 pos = origin + t * dir;\n        float m;\n        sceneMap3D(pos, m, hitObj);\n        if(m < 0.01)\n        {\n            return;\n        }\n        t += m;\n    }\n    // If there is no object in 256 steps\n    t = -1.0;\n    hitObj = -1;\n}\n\nvec3 computeMaterial(int hitObj, vec3 p, vec3 n, vec3 lightVec, vec3 view)\n{\n    // Use noise function to color the objects\n    float lambert = dot(-lightVec, n);\n    switch(hitObj){\n        case IDLongCube:\n        vec3 noise3D = vec3(random3(p));\n        float perlinNoise = PerlinNoise3D(noise3D);\n        vec3 perlinColor = colorPalette(perlinNoise);\n        return perlinColor * lambert;\n        break;\n        case IDSphere:\n        vec2 uv = sphereUV(vec3(-3.5 * sin(iTime), 0.6 + 2.0 * cos(iTime), 3.5 * cos(iTime)), 1.3, p);\n        float fbmUV = fbm(uv);\n        vec3 fbmColor = colorPalette(fbmUV);\n        return fbmColor * lambert;\n        break;\n        case IDBackWall:\n        // Compute Back Wall UV coordinate:\n        vec3 norBackWall = vec3(0.0, 0.0, -1.0);\n        vec2 backWallUV = planeUV(norBackWall * 5.0, norBackWall, p);\n        float snowSum = 0.845566 + snow(backWallUV) + snow2(backWallUV) + snow3(backWallUV) + snow4(backWallUV);\n        return  vec3(1., 1., 1.) * snowSum * lambert;\n        break;\n        case IDLeftWall:\n        // red left wall\n        return vec3(0.25, 1., 0.5) * lambert;\n        break;\n        case IDRightWall:\n        // Green right wall\n        return vec3(1., 0.5, 0.25) * lambert;\n        break;\n        case IDCeilingWall:\n        // Black ceiling\n        return vec3(1., 1., 1.) * lambert;\n        break;\n        case IDFloorWall:\n        return vec3(1., 1., 1.) * lambert;\n        break;\n        case -1:\n        return vec3(0., 0., 0.);\n        break;\n    }\n    return vec3(0., 0., 0.);\n}\n\nIntersection sdf3D(vec3 dir, vec3 eye)\n{\n    float t;\n    int hitObj;\n    march(eye, dir, t, hitObj);\n\n    vec3 isect = eye + t * dir;\n    vec3 nor = computeNormal(isect);\n    // Set the light as a point light\n    vec3 lightPos = vec3(0., 6., -3);\n\n    vec3 lightDir = normalize(isect - lightPos);\n\n    vec3 surfaceColor = computeMaterial(hitObj, isect, nor, lightDir, normalize(eye - isect));\n\n\n    return Intersection(t, surfaceColor, isect, hitObj);\n}\n\n\nvec3 rayCast(vec3 eye, vec3 ref, vec2 ndc)\n{\n    vec3 F = ref - eye;\n    vec3 R = normalize(cross(F, vec3(0.0, 1.0, 0.0)));\n    vec3 U = normalize(cross(R, F));\n\n    vec3 V = U * length(F) * tan(FOVY * 0.5);\n    vec3 H = R * length(F) * tan(FOVY * 0.5) * float(iResolution.x) / iResolution.y;\n\n    vec3 p = ref + ndc.x * H + ndc.y * V;\n\n    return normalize(p - eye);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized PIxel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // [-1, 1]\n    uv = uv * 2.0 - vec2(1.0, 1.0);\n\n    vec3 eye = vec3(0, 3, -20);\n\n    vec3 ref = vec3(0, 0, 100);\n\n    vec3 rayDir = rayCast(eye, ref, uv);\n\n    Intersection isect = sdf3D(rayDir, eye);\n\n    // Output to screen\n    fragColor = vec4(isect.color, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/fsB3DD.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "fsB3WD", "name": "Reduce tangent-grazing artifacts", "author": "elenzil", "description": "Exp. to reduce artifacts when the ray is nearly tangent to surface.\n--> If we happen to be on the last iteration of marching, then use a much larger epsilon. <--\nL: No fix\nR: Fix\nT: 150 iters steps\nB: 70 iters\n\noriginal: https://shadertoy.com/view/fdBGWD", "tags": ["tangents", "artifacts"], "likes": 12, "viewed": 179, "date": "1617382296", "time_retrieved": "2024-06-20T20:37:11.043197", "image_code": "/*\n * oxe:\n * An experiment using oneshade's beautiful \"Limited Smooth Mod\" shader https://shadertoy.com/view/fdBGWD .\n * \n * The idea here is to reduce those annoying sky-showing-through artifacts we always get near edge-on surfaces\n * when the ray has marched out to its maximum number of steps and we're spending our time\n * running parallel to a surface.\n *\n * --> When checking if we're \"close enough\" to the surface to call it a hit,\n * --> if we happen to be on the last iteration, then use a much wider threshhold.\n * --> ie, on the last step check for say epsilon 2.0 instead of epsilon 0.001.\n * \n * This introduces some inaccuracies where actual surfaces blend together.\n *\n */\n\n\n\n// Fork of \"Limited Smooth Mod\" by oneshade. \n// 2021-04-02 16:24:13\n\n// SDFs\nfloat sdBox(in vec3 p, in vec3 b) {\n    vec3 q = abs(p) - b;\n    return length(max(q, 0.0)) + min(0.0, max(q.x, max(q.y, q.z)));\n}\n\n// Distance operators\n// Use continuous! It will look a lot nicer.\nfloat smoothModLim(in float x, in float span, in float size, in float smoothness, in bool continuous) {\n    float m = 1.0 - smoothness;\n    float ss = span / size;\n\n    float sModX = asin(sin(x / size) * m) * size;\n\n    float slope = 1.0;\n    float offs = asin(sin(ss) * m) * size;\n\n    if (continuous) {\n        float s = sin(ss);\n        slope = m * cos(ss) / sqrt(1.0 - m * m * s * s);\n    }\n\n    float sModLimX = mix(sModX, (x - span) * slope + offs, step(span, x));\n    sModLimX = mix(sModLimX, (x + span) * slope - offs, 1.0 - step(-span, x));\n\n    return sModLimX;\n}\n\n// Scene\nfloat mapScene(in vec3 p) {\n    p.x = smoothModLim(p.x, 6.0, 1.5, 0.3, true);\n    p.y = smoothModLim(p.y, 6.0, 1.5, 0.3, true);\n    p.z = smoothModLim(p.z, 6.0, 1.5, 0.3, true);\n    \n    float t = iTime * 0.03 + 13.5;\n\n    float c = cos(t), s = sin(t);\n    p.xz *= mat2(c, -s, s, c);\n    p.yz *= mat2(c, -s, s, c);\n\n    return sdBox(p, vec3(1.0, 0.25, 1.5));\n}\n\n// Gradient\nvec3 getNormal(in vec3 p) {\n    vec3 e = vec3(0.001, 0.0, 0.0);\n    return normalize(vec3(mapScene(p + e.xyy) - mapScene(p - e.xyy),\n                          mapScene(p + e.yxy) - mapScene(p - e.yxy),\n                          mapScene(p + e.yyx) - mapScene(p - e.yyx)));\n}\n\nint iterMax(in vec2 fragCoord) {\n    // oxe: 70 iterations is a bit artifically low here, to exaggerate the effect.\n    // oneshade's original value is 150.\n    return fragCoord.y > iResolution.y / 2.0 ? 150 : 70;\n}\n\nbool closeEnough(in vec2 fragCoord, in float d, in int iter) {\n    if (fragCoord.x < iResolution.x / 2.0) {\n        return d < 0.001;\n    }\n    else {\n        return (d < 0.001) || (iter == iterMax(fragCoord) && d < 2.0);\n    }\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 center = 0.5 * iResolution.xy;\n\n    vec2 mouse = true ? (iMouse.xy - center) / iResolution.y * 3.14 : vec2(0.0);\n    vec2 uv = (fragCoord - center) / iResolution.y;\n\n    vec3 ro = vec3(0.0, 0.0, 25.0);\n    vec3 rd = normalize(vec3(uv, -1.0));\n\n    // Rotate with mouse\n    float cy = cos(mouse.x), sy = sin(mouse.x);\n    float cp = cos(mouse.y), sp = sin(mouse.y);\n\n    ro.yz *= mat2(cp, -sp, sp, cp);\n    ro.xz *= mat2(cy, -sy, sy, cy);\n    rd.yz *= mat2(cp, -sp, sp, cp);\n    rd.xz *= mat2(cy, -sy, sy, cy);\n\n    // Sky\n    fragColor = vec4(mix(vec3(0.25, 0.25, 1.0), vec3(1.0), 0.5 + 0.5 * rd.y), 1.0);\n\n    // Raymarch\n    float t = 0.0, d;\n    for (int i=0; i <= iterMax(fragCoord); i++) {\n        vec3 p = ro + rd * t;\n        d = mapScene(p);\n        if (closeEnough(fragCoord, d, i)) {\n            vec3 n = getNormal(p);\n            vec3 l = vec3(-0.58, 0.58, 0.58);\n\n            vec3 color = abs(n) * 1.25;\n            fragColor.rgb = color * max(0.2, dot(n, l));\n\n            break;\n        }\n\n        if (t > 50.0) {\n            break;\n        }\n\n        t += d;\n    }\n    \n    // oxe: screen-split lines\n    fragColor = mix(fragColor, vec4(1.0), 0.5 * floor(mod((fragCoord.x - iResolution.x / 2.0 + 10.0) / 20.0, 2.0)) * smoothstep(2.0, 0.0, abs(fragCoord.y - iResolution.y / 2.0)));\n    fragColor = mix(fragColor, vec4(1.0), 0.5 * floor(mod((fragCoord.y - iResolution.y / 2.0 + 10.0) / 20.0, 2.0)) * smoothstep(2.0, 0.0, abs(fragCoord.x - iResolution.x / 2.0)));\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/fsB3WD.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "fsBGDh", "name": "Fractal 47_gaz", "author": "gaz", "description": "inspired https://twitter.com/zozuar/status/1370468539526742022", "tags": ["fractal"], "likes": 17, "viewed": 243, "date": "1617286219", "time_retrieved": "2024-06-20T20:37:11.043197", "image_code": "#define hue(h)(cos((h)*6.3+vec3(0,23,21))*.5+.5)\n#define rot(a)mat2(cos(a),sin(a),-sin(a),cos(a))\n\nvoid mainImage(out vec4 O, in vec2 C)\n{\n    O=vec4(0);\n    vec3 p,r=iResolution,\n    d=normalize(vec3((C-.5*r.xy)/r.y,1));  \n    for(float i=0.,j,g,e;i++<99.;){\n        vec3 p=d*g;\n        p.z-=-1.;\n        p.y-=p.z*.6;\n        p.xz*=rot(iTime*.1);\n        // https://www.shadertoy.com/view/MlfXW7\n        vec2 z=p.xz;\n        for(j=5.;dot(z,z)<4.&&j++<99.;)\n            z=mat2(z,-z.y,z.x)*z+vec2(.3,.48)*rot(sin(iTime)*.1);       \n        e=p.y+log2(log(j))*exp(-.002*j*j)*.1;\n        g+=e*.5;\n        O.rgb+=mix(vec3(1),hue(log(j)),.8)*log(1./abs(e))/1000.;\n    }\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/fsBGDh.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "fsBGDy", "name": "Noise UV Mapping - CIS461", "author": "onlyname", "description": "Noise animated over time and UV mapped onto objects.", "tags": ["noise", "raymarch", "uv"], "likes": 1, "viewed": 64, "date": "1617869937", "time_retrieved": "2024-06-20T20:37:12.849488", "image_code": "const int RAY_STEPS = 256;\nconst float HALF_PI = 3.14159 * 0.5;\nconst float PI = 3.14159;\nconst float DEG_TO_RAD = 3.14159 / 180.0;\n// FBM\nconst float PERSISTENCE = 0.5;\nconst int OCTAVES = 4;\n\nstruct Intersection\n{\n    float t;\n    vec3 color;\n    vec3 p;\n    int object;\n};\n\n/// Colors ///\n// by IQ\nvec3 palette(in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d)\n{\n    return a + b*cos(6.28318*(c*t+d));\n}\n\nvec3 pal1(in float t)\n{\n    return palette(t,vec3(0.5,0.5,0.5),vec3(0.5,0.5,0.5),vec3(2.0,1.0,0.0),vec3(0.00,0.15,0.20));\n}\n\nvec3 pal2(in float t)\n{\n    float c = sin(iTime);\n    return palette(t,vec3(0.3,0.2,0.8),vec3(0.0,0.5,0.5),vec3(2.0,1.0,1.0),c * vec3(0.3,0.33,0.37));\n}\n\nvec3 pal3(in float t)\n{\n    float c = sin(iTime);\n    float c2 = cos(iTime);\n    return palette(t,vec3(0.4,0.4,0.3),vec3(0.5,0.5,0.5),c2 * vec3(2.0,2.0,2.0),c * vec3(0.3,0.33,0.37));\n}\n//////////////\n\nfloat noise2D(vec2 p) \n{\n    return fract(sin(dot(p, vec2(127.1, 311.7))) * 43758.5453);\n}\n\nvec2 random2(vec2 p)\n{\n    return fract(sin(vec2(dot(p, vec2(127.1, 311.7)),\n                 dot(p, vec2(269.5,183.3))))\n                 * 43758.5453);\n}\n\nvec3 random3(vec3 p) \n{\n    return fract(sin(vec3(dot(p,vec3(127.1, 311.7, 523.1)),\n                          dot(p,vec3(269.5, 183.3, 480.5)),\n                          dot(p, vec3(420.6, 631.2, 138.4))\n                    )) * 43758.5453);\n}\n\nfloat interpNoise2D(float x, float y) \n{\n    int intX = int(floor(x));\n    float fractX = fract(x);\n    int intY = int(floor(y));\n    float fractY = fract(y);\n\n    float v1 = noise2D(vec2(intX, intY));\n    float v2 = noise2D(vec2(intX + 1, intY));\n    float v3 = noise2D(vec2(intX, intY + 1));\n    float v4 = noise2D(vec2(intX + 1, intY + 1));\n\n    float i1 = mix(v1, v2, fractX);\n    float i2 = mix(v3, v4, fractX);\n    return mix(i1, i2, fractY);\n}\n\n\nfloat fbm(vec2 uv)\n{\n    float total = 0.0;\n    \n    for(int i = 0; i <= OCTAVES; i++)\n    {\n        float freq = pow(2.f, float(i));\n        float amp = pow(PERSISTENCE, float(i));\n\n        total += interpNoise2D(uv.x * freq, uv.y * freq) * amp;\n    }\n    return total;\n}\n\nfloat worleyNoise(vec2 uv) {\n    uv *= 1.0;\n    //uv *= (sin(iTime) / 2.0 + 1.0);\n    vec2 uvInt = floor(uv);\n    vec2 uvFract = fract(uv);\n    float minDist = 5.0; // Minimum distance initialized to max.\n    for(int y = -1; y <= 1; ++y) {\n        for(int x = -1; x <= 1; ++x) {\n            vec2 neighbor = vec2(float(x), float(y)); // Direction in which neighbor cell lies\n            vec2 point = random2(uvInt + neighbor); // Get the Voronoi centerpoint for the neighboring cell\n            point = 0.5 + 0.5 * cos(iTime) * cos(iTime * point); // animate point\n            vec2 diff = neighbor + point - uvFract; // Distance between fragment coord and neighbor’s Voronoi point\n            float dist = length(diff);\n            minDist = min(minDist, dist);\n        }\n    }\n    return minDist;\n}\n\nfloat surflet(vec3 p, vec3 gridPoint) {\n    // Compute the distance between p and the grid point along each axis, and warp it with a\n    // quintic function so we can smooth our cells\n    vec3 t2 = abs(p - gridPoint);\n    vec3 t = vec3(1.0) - 6.0 * pow(t2, vec3(5.0)) + 15.0 * pow(t2, vec3(4.0)) - 10.0 * pow(t2, vec3(3.0));\n    // Get the random vector for the grid point (assume we wrote a function random2\n    // that returns a vec2 in the range [0, 1])\n    vec3 gradient = random3(gridPoint) * 2. - vec3(1., 1., 1.);\n    // Get the vector from the grid point to P\n    vec3 diff = p - gridPoint;\n    // Get the value of our height field by dotting grid->P with our gradient\n    float height = dot(diff, gradient);\n    // Scale our height field (i.e. reduce it) by our polynomial falloff function\n    return height * t.x * t.y * t.z;\n}\n\nfloat perlinNoise3D(vec3 p)\n{\n\tfloat surfletSum = 0.f;\n\t// Iterate over the four integer corners surrounding uv\n\tfor(int dx = 0; dx <= 1; ++dx) {\n\t\tfor(int dy = 0; dy <= 1; ++dy) {\n\t\t\tfor(int dz = 0; dz <= 1; ++dz) {\n\t\t\t\tsurfletSum += surflet(p, floor(p) + vec3(dx, dy, dz));\n\t\t\t}\n\t\t}\n\t}\n\treturn surfletSum;\n}\n\n\nvec2 sphereMap(vec3 p, float r, vec3 c)\n{\n    // convert p to unit space\n    vec3 pC = (p - c) / r;\n    float u = (atan(pC.x, pC.z) + PI) / (2.0 * PI);\n    float v = (pC.y + 1.0) / 2.0;\n    return vec2(u, v);\n}\n\nvec3 rotateX(vec3 p, float a) {\n    return vec3(p.x, cos(a) * p.y - sin(a) * p.z, sin(p.y) + cos(p.z));\n}\n\nvec3 rotateY(vec3 p, float a) {\n    return vec3(cos(a) * p.x + sin(a) * p.z, p.y, -sin(a) * p.x + cos(a) * p.z);\n}\n\nvoid raycast(vec2 uv, out vec3 dir, out vec3 eye, out vec3 ref) {\n    eye = vec3(0.0, 4, -18.0);\n    ref = vec3(0.0, 2.5, 0.0);\n    \n    float len = tan(3.14159 * 0.125) * distance(eye, ref);\n    vec3 H = normalize(cross(vec3(0.0, 1.0, 0.0), ref - eye));\n    vec3 V = normalize(cross(H, eye - ref));\n    V *= len;\n    H *= len * iResolution.x / iResolution.y;\n    vec3 p = ref + uv.x * H + uv.y * V;\n    dir = normalize(p - eye);\n}\n\nfloat sphere(vec3 p, float r, vec3 c)\n{\n    return distance(p, c) - r;\n}\n\nfloat torus(vec3 p, vec2 t)\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q) - t.y;\n}\n\nfloat cone(vec3 p, vec2 c)\n{\n    // c must be normalized\n    float q = length(p.xy);\n    return dot(c,vec2(q,p.z));\n}\n\n// Box with side lengths b\nfloat box(vec3 p, vec3 b)\n{\n  return length(max(abs(p) - b, 0.0));\n}\n\nfloat plane( vec3 p, vec4 n )\n{\n  // n must be normalized\n  return dot(p,n.xyz) + n.w;\n}\n\n#define BACK_WALL plane(pos, vec4(0.0, 0.0, -1.0, 5.0))\n#define LEFT_WALL plane(pos, vec4(1.0, 0.0, 0.0, 5.0))\n#define RIGHT_WALL plane(pos, vec4(-1.0, 0.0, 0.0, 5.0))\n#define CEILING plane(pos, vec4(0.0, -1.0, 0.0, 7.5))\n#define FLOOR plane(pos, vec4(0.0, 1.0, 0.0, 2.5))\n#define TALL_CUBE box(rotateY(pos + vec3(2.3, 0.0, -2.0), 27.5 * DEG_TO_RAD), 0.5 * vec3(3.0, 6.0, 3.0))\n#define SPHERE sphere(pos, 2.5, vec3(3.25, 1.0, 0.0))\n\n#define BACK_WALL_NUM 0\n#define LEFT_WALL_NUM 1\n#define RIGHT_WALL_NUM 2\n#define CEILING_NUM 3\n#define FLOOR_NUM 4\n#define TALL_CUBE_NUM 5\n#define SPHERE_NUM 6\n#define SPHERE_RADIUS 2.5\n#define SPHERE_CENTER rotateY(vec3(3.25, 1.0, 0.0), 100.0 * DEG_TO_RAD)\n\nfloat sceneMap3D(vec3 pos, vec3 lightPos)\n{\n    float t = BACK_WALL;\n    t = min(t, LEFT_WALL);\n    t = min(t, RIGHT_WALL);\n    t = min(t, CEILING);\n    t = min(t, FLOOR);\n    t = min(t, TALL_CUBE);\n    t = min(t, SPHERE);\n    return t;\n}\n\nvoid sceneMap3D(vec3 pos, out float t, out int obj, vec3 lightPos)\n{\n    t = BACK_WALL;\n    float t2;\n    obj = BACK_WALL_NUM;\n    if((t2 = LEFT_WALL) < t) {\n        t = t2;\n        obj = LEFT_WALL_NUM;\n    }\n    if((t2 = RIGHT_WALL) < t) {\n        t = t2;\n        obj = RIGHT_WALL_NUM;\n    }\n    if((t2 = CEILING) < t) {\n        t = t2;\n        obj = CEILING_NUM;\n    }\n    if((t2 = FLOOR) < t) {\n        t = t2;\n        obj = FLOOR_NUM;\n    }\n    if((t2 = TALL_CUBE) < t) {\n        t = t2;\n        obj = TALL_CUBE_NUM;\n    }\n    if((t2 = SPHERE) < t) {\n        t = t2;\n        obj = SPHERE_NUM;\n    }\n}\n\nvoid march(vec3 origin, vec3 dir, out float t, out int hitObj, vec3 lightPos)\n{\n    t = 0.001;\n    for(int i = 0; i < RAY_STEPS; ++i)\n    {\n        vec3 pos = origin + t * dir;\n    \tfloat m;\n        sceneMap3D(pos, m, hitObj, lightPos);\n        if(m < 0.01)\n        {\n            return;\n        }\n        t += m;\n    }\n    t = -1.0;\n    hitObj = -1;\n}\n\nvec3 computeNormal(vec3 pos, vec3 lightPos)\n{\n    vec3 epsilon = vec3(0.0, 0.001, 0.0);\n    return normalize( vec3( sceneMap3D(pos + epsilon.yxx, lightPos) - sceneMap3D(pos - epsilon.yxx, lightPos),\n                            sceneMap3D(pos + epsilon.xyx, lightPos) - sceneMap3D(pos - epsilon.xyx, lightPos),\n                            sceneMap3D(pos + epsilon.xxy, lightPos) - sceneMap3D(pos - epsilon.xxy, lightPos)));\n}\n\nvec3 computeMaterial(int hitObj, vec3 p, vec3 n, vec3 light, vec3 view) {\n    float lambert = max(0.0, dot(n, light)) + 0.2;\n\n    vec2 uv = vec2(0.0);\n\n    switch(hitObj) {\n        case BACK_WALL_NUM:\n        uv = vec2(p.x, p.y);\n        uv.x = uv.x + 0.5 + 1.2 * sin(iTime);\n        uv.y = uv.y + 0.5 + 1.2 * cos(iTime);\n        return pal2(worleyNoise(uv)) * lambert;\n        break;\n        case CEILING_NUM:\n        return vec3(0.01, 0.15, 0.2) * lambert;\n        break;\n        case FLOOR_NUM:\n        return vec3(0.0, 0.01, 0.25) * lambert;\n        break;\n        case TALL_CUBE_NUM:\n        return pal3(perlinNoise3D((1.5 * sin(iTime) * cos(iTime) + 1.5) * p)) \n                    * lambert; \n        break;\n        case SPHERE_NUM:\n        uv = sphereMap(p, SPHERE_RADIUS, SPHERE_CENTER);\n        uv.x = uv.x + 0.5 + 1.2 * sin(iTime);\n        uv.y = uv.y + 0.5 + 1.2 * cos(iTime);\n        return pal1(fbm(uv)) * lambert;\n        break;\n        case LEFT_WALL_NUM:\n        return vec3(0.2, 0.065, 0.65) * lambert;\n        break;\n        case RIGHT_WALL_NUM:\n        return vec3(0.2, 0.45, 0.71) * lambert;\n        break;\n        case -1:\n        // Background\n        return vec3(0.0);\n        break;\n    }\n    return vec3(1.0);\n}\n\nIntersection sdf3D(vec3 dir, vec3 eye, vec3 lightPos)\n{\n    float t;\n    int hitObj;\n    march(eye, dir, t, hitObj, lightPos);\n\n    vec3 isect = eye + t * dir;\n    vec3 nor = computeNormal(isect, lightPos);\n    vec3 lightDir = normalize(lightPos - isect);\n    \n    vec3 surfaceColor = computeMaterial(hitObj, isect, nor, lightDir, normalize(eye - isect));\n    \n    return Intersection(t, surfaceColor, isect, hitObj);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec3 lightPos = vec3(0.0, 5.0, -5.0);\n    \n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    // [-1, 1]\n    vec2 uv2 = 2.0 * uv - vec2(1.0);\n    \n    Intersection aaIsects[4];\n    vec3 dir, eye, ref;\n    int idx = 0;\n    for(float i = 0.0; i < 1.0; i += 0.5) {\n        for(float j = 0.0; j < 1.0; j += 0.5) {\n            raycast(uv2 + vec2(i, j) / iResolution.xy, dir, eye, ref);\n            aaIsects[idx++] = sdf3D(dir, eye, lightPos);\n        }\n    }\n    vec3 avgColor = vec3(0.0);\n    for(int i = 0; i < 4; ++i) {\n        avgColor += aaIsects[i].color;\n    }\n    avgColor *= 0.25;\n    fragColor = vec4(avgColor * step(0.0, aaIsects[0].t), 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/fsBGDy.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "fsBGRc", "name": "Tutorial shader with Ray Tracing", "author": "frankbolero", "description": "Copy paste + modify etc etc.", "tags": ["raytracing", "basic"], "likes": 0, "viewed": 116, "date": "1617712822", "time_retrieved": "2024-06-20T20:37:13.158521", "image_code": "// stolen from https://www.shadertoy.com/view/ldS3DW and modified\nfloat sphere(vec3 ray, vec3 dir, vec3 center, float radius)\n{\n\tvec3 rc = ray-center * cos(atan(cos(dir.x), dir.y)*iTime);\n\tfloat c = dot(rc, rc) - (radius*radius);\n\tfloat b = dot(dir, rc);\n\tfloat d = b*b - c;\n\tfloat t = -b - sqrt(abs(d * cos(atan(cos(dir.x), dir.y)*iTime)));\n\tfloat st = step(0.0, min(t,d));\n    return mix(-1.0, t, st);\n}\n\nvec3 background(float t, vec3 rd)\n{\n\tvec3 light = normalize(vec3(sin(t), 0.6, cos(t)));\n\tfloat sun = max(0.0, dot(rd, light));\n\tfloat sky = max(0.0, dot(rd, vec3(0.0, 1.0, 0.0)));\n\tfloat ground = max(0.0, -dot(rd, vec3(0.0, 1.0, 0.0)));\n\treturn \n\t\t(pow(sun, 256.0)+0.2 * pow(sun, 2.0))*vec3(2.0, 1.6, 1.0) +\n\t\tpow(ground, 0.5) * vec3(0.4, 0.3, 0.2) +\n\t\tpow(sky, 1.0) * vec3(0.5, 0.6, 0.7);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = (-1.0 + 2.0*fragCoord.xy / iResolution.xy) * \n\t\tvec2(iResolution.x/iResolution.y, 1.0);\n\n\tvec3 ro = vec3(0.0, 0.0, -3.0);\n\tvec3 rd = normalize(vec3(uv, 1.0));\n\tvec3 p = vec3(0.0, 0.0, 0.0);\n\tfloat t = sphere(ro, rd, p, 2.0);\n\n    vec3 q = p - vec3(0.5,0.5,0.5);    \n        \n    vec3 axis = vec3(0.0, 1.0, 0.0);\n    vec3 nml = normalize(p - (ro+rd*t));\n    \n\tvec3 bgCol = background(iTime, rd);\n\trd = reflect(rd, nml);\n\n    float r = 0.2 + 0.15 * cos(atan(cos(q.y), q.x)*iTime);\n    \n    // Time varying pixel color\n    vec3 col = 0.8 + 0.2 * cos(iTime + uv.xyx + vec3(0,2,4));\n\n    col *= background(iTime, rd) * vec3(0.9, 0.8, 1.0);\n    col *= smoothstep(r, r+0.001, length(q));\n        \n    // Output to screen\n    fragColor = vec4( mix(bgCol, col, step(0.0, t)), 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/fsBGRc.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "fsBGRG", "name": "Julia Set Rotation Matrix", "author": "kithy", "description": "julia set,fractal,rotation matrix", "tags": ["fractal", "juliaset", "rotationmatrix"], "likes": 1, "viewed": 34, "date": "1617542164", "time_retrieved": "2024-06-20T20:37:13.164625", "image_code": "#define ITR 100\n#define PI 3.1415926\n\nmat2 rot(float a){\n\tfloat c=cos(a);\n\tfloat s=sin(a);\n\treturn mat2(c,-s,s,c);\n}\n\nvec2 pmod(vec2 p,float n){\n\tfloat np=PI*2.0/n;\n\tfloat r=atan(p.x,p.y)-0.5*np;\n\tr=mod(r,np)-0.5*np;\n\treturn length(p)*vec2(cos(r),sin(r));\n}\n\nfloat julia(vec2 uv){\n\tint j;\n\tfor(int i=0;i<ITR;i++){\n\t\tj++;\n\t\tvec2 c=vec2(-0.345,0.654);\n\t\tvec2 d=vec2(iTime*0.005,0.0);\n\t\tuv=vec2(uv.x*uv.x-uv.y*uv.y,2.0*uv.x*uv.y)+c+d;\n\t\tif(length(uv)>float(ITR)){\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn float(j)/float(ITR);\n}\n\n\n\nvoid mainImage(out vec4 fragColor,in vec2 fragCoord){\n\tvec2 uv=(2.0*fragCoord.xy-iResolution.xy)/iResolution.y;\n\n\tuv.xy*=rot(iTime*0.5);\n\t//uv=pmod(uv.xy,6.0);\n\tuv*=abs(sin(iTime*0.2));\n\tfloat f=julia(uv);\n\n\tfragColor=vec4(f-0.4,(f-(fract(iTime*0.1))),f,1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/fsBGRG.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "fsBGWG", "name": "Distance to feature points III", "author": "tomoe", "description": "differentiation of the function getting the closest distance (fork from [url=https://www.shadertoy.com/view/fsSGWG]Distance to feature points II[/url])", "tags": ["bd202104"], "likes": 1, "viewed": 50, "date": "1617847016", "time_retrieved": "2024-06-20T20:37:13.164625", "image_code": "uvec3 k = uvec3(0x456789abu, 0x6789ab45u, 0x89ab4567u);\nconst uint max32 = 0xffffffffu;\nconst float PI = 3.14159265359;\nuvec2 hash22u(uvec2 n) {  \n    n ^= (n.yx << 24);\n    n ^= (n.yx >> 1);\n    n *= k.xy;\n    n ^= (n.yx << 1);\n    return n * k.xy;\n}\nvec2 hash22(vec2 p) {\n    uvec2 n = uvec2(p);\n    return vec2(hash22u(n)) / vec2(max32) - 0.5;\n}\nmat2 rot(float t) {\n    return mat2(cos(t), sin(t), - sin(t), cos(t));\n}\nfloat length2(vec2 v){\n    return dot(v, v);\n}\nfloat F1(vec2 p){   \n    vec2 n = round(p);\n    vec2 f = p - round(p);\n    float dist = length2(abs(f) + 0.5);\n    vec2 sgn = vec2(1.0);\n    vec2 glid = vec2(0.0);\n    for(float j = 0.0; j <= 2.0; j ++ ) {\n        glid.y += sgn.y * j;\n        sgn.y *= -1.0;\n        if (abs(glid.y - f.y) - 0.5 > sqrt(dist)){\n            continue;\n        }\n        for(float i = 0.0; i <= 2.0; i ++ ){\n            glid.x += sgn.x * i;\n            sgn.x *= -1.0;\n            vec2 nbd = glid + hash22(n + glid);\n            dist = min(dist, length2(nbd - f));\n        }\n        glid.x = 0.0;\n    }\n    return sqrt(dist);\n}\nvec2 grad(vec2 p) {\n    float d = 0.001;\n    return 0.5 * (vec2(\n            F1(p + vec2(d, 0.0)) - F1(p - vec2(d, 0.0)),\n            F1(p + vec2(0.0, d)) - F1(p - vec2(0.0, d))\n        )) / d;\n}\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n    vec2 pos = fragCoord.xy/ iResolution.xx;\n    pos *= 20.0;\n    pos += iTime;\n    if (fragCoord.x < 0.33 * iResolution.x){\n        fragColor = vec4(vec3(F1(pos)), 1.0);\n    } else if(fragCoord.x < 0.66 * iResolution.x) {\n        fragColor = vec4(grad(pos), 1.0, 1.0);\n    } else {\n        vec2 ray = rot(iTime) * vec2(1.0, 0.0);\n        fragColor = vec4(dot(ray, grad(pos)));\n    }\n    \n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/fsBGWG.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "fsfSDl", "name": "Fork GIT sewonist 428", "author": "sewonist", "description": "\"Generalized Impressionistic Texture\" ala Ken Musgrave: p 322 of Texturing And Modelling: A Procedural Approach.\nA painterly plasma.", "tags": ["noise", "fbm", "multifractal"], "likes": 5, "viewed": 87, "date": "1619405827", "time_retrieved": "2024-06-20T20:37:13.764589", "image_code": "//1. Go fullscreen\n//2. Take drugs now\n\n//iq noise fn\nfloat hash( float n )\n{\n    return fract(sin(n)*43758.5453);\n}\nfloat noise( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n\n    f = f*f*(3.0-2.0*f);\n    float n = p.x + p.y*57.0 + 113.0*p.z;\n    return mix(mix(mix( hash(n+  0.0), hash(n+  1.0),f.x),\n                   mix( hash(n+ 57.0), hash(n+ 58.0),f.x),f.y),\n               mix(mix( hash(n+113.0), hash(n+114.0),f.x),\n                   mix( hash(n+170.0), hash(n+171.0),f.x),f.y),f.z);\n}\n\n//x3\nvec3 noise3( in vec3 x)\n{\n\treturn vec3( noise(x+vec3(123.456,.567,.37)),\n\t\t\t\tnoise(x+vec3(.11,47.43,19.17)),\n\t\t\t\tnoise(x) );\n}\n\n//http://dept-info.labri.fr/~schlick/DOC/gem2.ps.gz\nfloat bias(float x, float b) {\n\treturn  x/((1./b-2.)*(1.-x)+1.);\n}\n\nfloat gain(float x, float g) {\n\tfloat t = (1./g-2.)*(1.-(2.*x));\t\n\treturn x<0.5 ? (x/(t+1.)) : (t-x)/(t-1.);\n}\n\n\nmat3 rotation(float angle, vec3 axis)\n{\n    float s = sin(-angle);\n    float c = cos(-angle);\n    float oc = 1.0 - c;\n\tvec3 sa = axis * s;\n\tvec3 oca = axis * oc;\n    return mat3(\t\n\t\toca.x * axis + vec3(\tc,\t-sa.z,\tsa.y),\n\t\toca.y * axis + vec3( sa.z,\tc,\t\t-sa.x),\t\t\n\t\toca.z * axis + vec3(-sa.y,\tsa.x,\tc));\t\n}\n\nvec3 fbm(vec3 x, float H, float L, int oc)\n{\n\tvec3 v = vec3(0);\n\tfloat f = 1.;\n\tfor (int i=0; i<10; i++)\n\t{\n\t\tif (i >= oc) break;\n\t\tfloat w = pow(f,-H);\n\t\tv += noise3(x)*w;\n\t\tx *= L;\n\t\tf *= L;\n\t}\n\treturn v;\n}\n\nvec3 smf(vec3 x, float H, float L, int oc, float off)\n{\n\tvec3 v = vec3(1);\n\tfloat f = 1.;\n\tfor (int i=0; i<10; i++)\n\t{\n\t\tif (i >= oc) break;\n\t\tv *= off + f*(noise3(x)*2.-1.);\n\t\tf *= H;\n\t\tx *= L;\n\t}\n\treturn v;\t\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\tuv.x *= iResolution.x / iResolution.y;\n\t\n\tfloat time = iTime * 1.276;\n\t\n\tfloat slow = time*0.002;\n\tuv *= 1. + .5*slow*sin(slow*10.);\n\t\n\tfloat ts = time*0.37;\n\t//float change = gain(fract(ts),0.0008)+floor(ts);\t//flick to a different view \n\tfloat change = 7.01;\n    \n\tvec3 p = vec3(uv*.2,slow+change);\t\t\t\t\t//coordinate + slight change over time\n\t\n\tvec3 axis = 4. * fbm(p, 0.5, 2., 8);\t\t\t\t//random fbm axis of rotation\n\t\n\tvec3 colorVec = 0.5 * 5. * fbm(p*0.3,0.5,2.,7);\t\t//random base color\n\tp += colorVec;\n\t\n//\tfloat mag = 4e5;\t//published, rather garish?\n\tfloat mag = 0.75e5; //still clips a bit\n//\tmag = mag * (1.+sin(2.*3.1415927*ts)*0.75);\n\tvec3 colorMod = mag * smf(p,0.7,2.,8,.2);\t\t\t//multifractal saturation\n\tcolorVec += colorMod;\n\t\n\tcolorVec = rotation(3.*length(axis)+slow*10.,normalize(axis))*colorVec;\n\t\n\tcolorVec *= 0.1;\n\t\t\t\n\tcolorVec = colorVec * (1. + length(colorVec));\t//tone it all up a bit\n\t\n\tcolorVec = pow(colorVec,vec3(1./2.2));\t\t//gamma\n\tfragColor = vec4(colorVec,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/fsfSDl.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "fsfSW4", "name": "FeelSickTunnel314", "author": "Domain314", "description": "pls, dont look at it for too long.\n\nparts from \nhttps://thebookofshaders.com/10/\n\nupdated a \"lensing\" (not really) effect. Change \"lensing\" to 1. for original output.", "tags": ["2d"], "likes": 7, "viewed": 79, "date": "1618605983", "time_retrieved": "2024-06-20T20:37:14.110116", "image_code": "#define SSV 0.00001\n#define TWO_PI 6.2831853\n\nfloat N11(float i){\n    return fract(sin(dot(vec2(fract(i*912.212357), fract(i*4567.34526)), vec2(13.7137,67.798) * 977.75973)));\n}\n\nfloat N21(vec2 v){\n    return fract(sin(dot(v.xy, vec2(13.7137,67.798))) * 977.75973);\n}\n\nvec2 tile(vec2 _uv, float _zoom){\n    _uv *= _zoom;\n    return fract(_uv);\n}\n\nfloat pattern(vec2 _uv, vec2 _v, float _t){\n    vec2 p = floor(_uv+_v);\n    return step(_t, N21(100.+p*SSV)+N11(p.x)*0.5 );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{    \n    float t = sin(iTime*0.3);\n    float s = sign(t);\n    \n    // was \"mouse\" and managed mouse input. Turned out to be not as cool as imagined => recycled variable.\n    float m = 1.-abs(t);\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    vec2 st = vec2(atan(uv.x, uv.y), length(uv));\n    \n    // change lensing to 1. for original output\n    float lensing = (t*2.-st.y); //1.; \n    uv = vec2(st.x/TWO_PI, st.y*lensing);\n    \n    vec3 col = vec3(0.);\n    vec2 grid = vec2(100., 50.);\n    uv *= grid;\n    \n    vec2 ipos = floor(uv);\n    vec2 vel = vec2((s*iTime+0.02)*.2*max(grid.x, grid.y));\n    vel *= vec2(-1., 0.)*N11(1.0 + ipos.y);\n    \n    vec2 offset = vec2(.3, 0.);\n    \n    col.r = pattern(uv+offset, vel, 0.5+m);\n    col.g = pattern(uv, vel, 0.5+m);\n    col.b = pattern(uv-offset, vel, 0.5+m)*1.5;\n    \n    col.b += (fract(uv.y)*(1.-m));\n    col.g += (fract(uv.y)*(1.-m))*0.8;\n    \n    col -= smoothstep(41.,42. , uv.x)*2.;\n    col -= smoothstep(-41., -42., uv.x)*2.;\n    col -= smoothstep(1.,.0, uv.y);\n    \n    fragColor = vec4(col*0.9,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/fsfSW4.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "fsfSzS", "name": "noise balanced isolines -interp2", "author": "FabriceNeyret2", "description": "TAB for debug display.\nBottom: noise isovalues are not equidistant.\nCompare to [url]https://shadertoy.com/view/NdfXW7[/url], here I smart-interpolates between distance to peak and distance to valey.", "tags": ["procedural", "noise", "perlin"], "likes": 2, "viewed": 166, "date": "1618745186", "time_retrieved": "2024-06-20T20:37:14.625380", "image_code": "// Fork of \"test5: noise balanced isolines -interp\"  https://shadertoy.com/view/NdfXW7\n// Fork of \"test4: noise balanced isolines\" https://shadertoy.com/view/fsfXWM\n// Fork of \"test3: Curl noise balance\"      https://shadertoy.com/view/NssXD4\n// Fork of \"test1: Noise balance\"           https://shadertoy.com/view/ssXXWN\n\n\n#define keyToggle(a) ( texelFetch(iChannel3,ivec2(a,2),0).x > 0.)\n#define hash(p )     ( 2.* fract(sin((p)*mat2(127.1,311.7, 269.5,183.3)) *43758.5453123) - 1. )\n#define draw(v,d)      clamp(1. - abs( fract(v) - .5 ) / fwidth(d), 0.,1.)\n//#define Ierf(x)    ( atanh(x) / 1.2 )          // not so bad reciprocal of erf\n\n#define func( P )    ( keyToggle(32) ? perlin( P ) : noise( P ) )\n#define grad(x,y)      dot( hash( i+vec2(x,y) ), f-vec2(x,y) )\n\nfloat noise( vec2 p )\n{\n    vec2 i = floor(p), f = fract(p), // u = f*f*(3.-2.*f);              // = smoothstep\n                                        u = f*f*f*( 10. +f*(6.*f-15.)); // better with derivatives\n    return mix( mix( grad(0,0), grad(1,0), u.x),\n                mix( grad(0,1), grad(1,1), u.x), u.y);\n}\n\nfloat perlin( vec2 U ) { // inspired from https://www.shadertoy.com/view/XdXGW8\n    float v = 0., s = .5;\n    mat2 m = mat2( 1.6,  1.2, -1.2,  1.6 );\n    for( int i=0; i<3; i++, s/=2., U*=m )\n        v  += s * noise( U ); \n    return v;\n}\n\nvoid mainImage( out vec4 O, vec2 u )\n{\n    vec2 R = iResolution.xy, eps = vec2(1e-3,0),\n         U = u / R.y,\n         P = 8.*U - vec2(0.,.5*iTime), P0=P;\t\n    O-=O;\n\tfloat l0, l = 0., f = func(P), f0=f;\n    if ( int(u.y) == int(R.y*.4) ) { O.r++; return; } // red separator\n    if( U.y > .4) {\n        float s = .1;                           // steps size\n                                                //  --- ascent to peak\n        for (int i=0; i < 300; i++ ){\n            vec2 G =  ( f - vec2( func(P-eps.xy), func(P-eps.yx) )) /eps.x; // gradient\n         // vec2 G = vec2( dFdx(f), dFdy(f) ) * R.y/8.;\n            P += s* G;                          // ascent\n            l += s* length(G);                  // optional: cumul curved lenght\n            f = func( P ); \n            if ( length(G) < 1e-2 ) break;      // creast or valley reached\n        }\n     // l = length(P-P0);                       // optional: use straight distance instead of curved (ok for descent )\n        \n        l0 = l; l = 0.; P = P0; f = func(P); \n      //s = .1;                                        // --- descent to nega-peak\n        for (int i=0; i < 300; i++ ){\n            vec2 G =  ( f - vec2( func(P-eps.xy), func(P-eps.yx) )) /eps.x; // gradient\n         // vec2 G = vec2( dFdx(f), dFdy(f) ) * R.y/8.;\n            P -= s* G;                          // descent\n            l -= s* length(G);                  // optional: cumul curved lenght\n            f = func( P ); \n            if ( length(G) < 1e-2 ) break;      // creast or valley reached\n        }\n     // l = length(P-P0);                       // optional: use straight distance instead of curved (ok for descent )\n\n     // --- l0 = dist to iso0, l = dist to peak\n        if( keyToggle(9) ) {\n            O.g += draw(8.*l0,8.*l0)*U.x;\n            O.b += float(abs(f0)<.01);\n            O.r += draw(8.*l ,8.*l )*2.*U.x;\n         // return;\n        }\n        if ( max(fwidth(l0),fwidth(l)) > 50.*fwidth(U.x) ) return; // trim artifacts\n        \n        if (true) { float v1 = fract(f=8.*l), v0 = fract(8.*l0);\n                    v1 = fract(v1-v0+.5) +v0-.5; l = mix(v0,v1,abs(l0)/(abs(l0)+abs(l)));  \n                 // O += abs(fract(l)-.5)*2.; sin(6.28*l); \n                    O += draw(l,f); return; }\n     // l = (l0-l)/2.;\n\n        f = l;\n    }\n/*  else {\n        O = vec4(.5+f);                                           // draw noise\n        O.b += clamp(.5-.5*abs(f)/fwidth(f), 0.,1.); \n        return;\n    }\n*/\n\n // O = vec4(.5+.5*sin(50.*l));\n    f = 8.*f; O += draw(f,f); // draw isolines\n    O = sqrt(O);                                                  // to sRGB\n\n}", "image_inputs": [{"id": "4dXGRr", "previewfilepath": "/presets/tex00.jpg", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/presets/tex00.jpg", "ctype": "keyboard"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/fsfSzS.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "fsfXDH", "name": "Pablo's scary cousin", "author": "SnoopethDuckDuck", "description": "e", "tags": ["cool"], "likes": 1, "viewed": 57, "date": "1618535850", "time_retrieved": "2024-06-20T20:37:14.625380", "image_code": "float taxi(vec2 v) { return abs(v.x) + abs(v.y); }\n\nfloat random (vec2 st) {\n    return fract(sin(dot(st.xy,\n                         vec2(12.9898,78.233)))*\n        43758.5453123);\n}\n\nfloat f (float x) { return 16. * x * x * (1.-x) * (1.-x);}\n\nfloat func(vec2 uv, float t)\n{\nvec2 dir = uv - .5;\nfloat b = f(2.5 * (1. + cos(t)));\nfloat d = b *  f(fract(3.5 * length(dir))) + (1.-b) * f(fract(3.5 * taxi(dir)));\nd *=8. + 5. * cos(0.5 * t);\nfloat theta = atan(dir.y,dir.x);\n\nfloat b2 = 0.5 * (1. + cos(0.313 * t));\n   return (1.-b2) * (1. - smoothstep(d,-0.9,f(0.3 + 0.05 * cos(0.5 * t))))\n   + b2 * step(d,0.3 + 0.05 * cos(0.5 * t));\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.y - vec2( 0.375,0.);\n     \n      float t2 = 0.1 * iTime;\nuv -= 0.5;\n    uv = 0.5 + vec2(uv.x * cos(t2) - uv.y * sin(t2),\n    uv.x * sin(t2) + uv.y *cos(t2));\n     float t = iTime + 0.05 * random(uv);//vec2(floor(396. * uv)));\n\nfloat b = 0.5 * (1. + cos(.13149 * t));\n//float p = 2. * 3.14159 / 3.;\nfloat col = func(uv,t + 0.115 + 0.015 * b);\nfloat col2 = func(uv,t);\nfloat col3 = func(uv,t - 0.115 - 0.015 * b);\n\n\n\n    // Output to screen\n    fragColor = vec4(col,col2,col3,1.0);\n}\n\n\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/fsfXDH.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "fsfXWM", "name": "noise balanced isolines", "author": "FabriceNeyret2", "description": "Bottom: noise isovalues are not equidistant.\nTop-Left: Drawing iso-spaced lines upon noise based on curved distance to isoline 0.\nProblem: discontinuities at creasts + pinched  look there.\nTop-Right: curve distance to peak. \nProblem: cellular look.", "tags": ["procedural", "noise", "perlin"], "likes": 7, "viewed": 194, "date": "1618690551", "time_retrieved": "2024-06-20T20:37:15.073944", "image_code": "// Fork of \"test3: Curl noise balance\"  https://shadertoy.com/view/NssXD4\n// Fork of \"test1: Noise balance\"  https://shadertoy.com/view/ssXXWN\n\n\n#define hash(p ) ( 2.* fract(sin((p)*mat2(127.1,311.7, 269.5,183.3)) *43758.5453123) - 1. )\n#define grad(x,y)  dot( hash( i+vec2(x,y) ), f-vec2(x,y) )\n#define Ierf(x) ( atanh(x) / 1.2 )          // not so bad reciprocal\n#define keyToggle(a)  ( texelFetch(iChannel3,ivec2(a,2),0).x > 0.)\n\nfloat noise( vec2 p )\n{\n    vec2 i = floor(p), f = fract(p), // u = f*f*(3.-2.*f); // smoothstep\n                                        u = f*f*f*( 10. +f*(6.*f-15.));\n    return mix( mix( grad(0,0), grad(1,0), u.x),\n                mix( grad(0,1), grad(1,1), u.x), u.y);\n}\n\nfloat perlin( vec2 U ) { // inspired from https://www.shadertoy.com/view/XdXGW8\n    float v = 0., s = .5;\n    mat2 m = mat2( 1.6,  1.2, -1.2,  1.6 );\n    for( int i=0; i<3; i++, s/=2., U*=m )\n        v  += s * noise( U ); \n    return v;\n}\n\n#define func( P ) ( keyToggle(32) ? perlin( P ) : noise( P ) )\n\nvoid mainImage( out vec4 O, vec2 u )\n{\n    vec2 R = iResolution.xy, eps = vec2(1e-3,0),\n         U = u / R.y,\n         P = 8.*U - vec2(0.,.5*iTime), P0=P;\t\n    O-=O;\n\tfloat l = 0., f = func(P);\n    \n    if( U.y > .4) {\n        if ( int(u.x) == int(R.x/2.) ) { O.r++; return; } // red separator\n        float s = .1;                               // steps size\n        if (U.x < .5*R.x/R.y)                       // --- left: descent to isoline-0\n            for (int i=0; i < 30; i++ ){\n                vec2 G =  ( f - vec2( func(P-eps.xy), func(P-eps.yx) )) /eps.x; // gradient\n             // vec2 G = vec2( dFdx(f), dFdy(f) ) * R.y/8.;\n                P -= s* f * G/dot(G,G);             // descent\n                l += s* f / length(G);              // optional: cumul curved lenght\n                f = func( P ); \n             // if ( length(G) < .2 ) return;       // trying to cull crests and valleys\n                if (abs(f) < 1e-3) break;           // isovalue 0 reached\n            }\n        else                                        // --- right: ascent to peak\n            for (int i=0; i < 30; i++ ){\n                vec2 G =  ( f - vec2( func(P-eps.xy), func(P-eps.yx) )) /eps.x; // gradient\n             // vec2 G = vec2( dFdx(f), dFdy(f) ) * R.y/8.;\n#if 1                                               // ... all from positive pole\n                P += s* G;                          // ascent\n                l += s* length(G);                  // optional: cumul curved lenght\n#else                                               // ... from both poles\n                P += s* sign(f)*  G;                // ascent\n                l += s* sign(f)* length(G);         // optional: cumul curved lenght\n#endif\n                f = func( P ); \n                if ( length(G) < 1e-2 ) break;      // creast or valley reached\n            }\n    //  l = length(P-P0);                           // optional: use straight distance instead of curved (ok for descent )\n        f = l;\n    }\n/*  else {\n        O = vec4(.5+f);                                           // draw noise\n        O.b += clamp(.5-.5*abs(f)/fwidth(f), 0.,1.); \n        return;\n    }\n*/\n\n // O = vec4(.5+.5*sin(50.*l));\n    f = 8.*f; O += clamp(1. - abs(fract(f)-.5)/fwidth(f), 0.,1.); // draw isolines\n    O = sqrt(O);                                                  // to sRGB\n\n}", "image_inputs": [{"id": "4dXGRr", "previewfilepath": "/presets/tex00.jpg", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/presets/tex00.jpg", "ctype": "keyboard"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/fsfXWM.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "fsfXzj", "name": "flownoise balanced isolines-sbdv", "author": "FabriceNeyret2", "description": "flownoise variant of [url]https://shadertoy.com/view/NdXXRj[/url]\ninterpolated variant of |url]https://shadertoy.com/view/sdsXzB[/url] ", "tags": ["procedural", "noise", "perlin"], "likes": 8, "viewed": 163, "date": "1618840864", "time_retrieved": "2024-06-20T20:37:15.455833", "image_code": "// flownoise variant of https://shadertoy.com/view/NdXXRj\n// interpolated variant of https://shadertoy.com/view/sdsXzB\n\n#define keyToggle(a) ( texelFetch(iChannel3,ivec2(a,2),0).x > 0.)\n#define hash(p )     ( 2.* fract(sin((p)*mat2(127.1,311.7, 269.5,183.3)) *43758.5453123) - 1. ) \\\n                    *  mat2(cos(iTime+vec4(0,11,33,0)))\n#define draw(v,d)      clamp(1. - abs( fract(v) - .5 ) / (d), 0.,1.)\n#define hue(v)       ( .6 + .6 * cos( 6.3*(v)  + vec4(0,23,21,0)  ) )\n\n  #define func( P )  ( mod(iTime,4.) > 2. ? perlin( .5*(P) ) : noise( P ) )\n//#define func( P )  ( keyToggle(32) ? perlin( .5*(P) ) : noise( P ) )\n#define grad(x,y)      dot( hash( i+vec2(x,y) ), f-vec2(x,y) )\n\nfloat noise( vec2 p )\n{\n    vec2 i = floor(p), f = fract(p), // u = f*f*(3.-2.*f);              // = smoothstep\n                                        u = f*f*f*( 10. +f*(6.*f-15.)); // better with derivatives\n    return mix( mix( grad(0,0), grad(1,0), u.x),\n                mix( grad(0,1), grad(1,1), u.x), u.y);\n}\n\nfloat perlin( vec2 U ) { // inspired from https://www.shadertoy.com/view/XdXGW8\n    float v = 0., s = .5;\n    mat2 m = mat2( 1.6,  1.2, -1.2,  1.6 );\n    for( int i=0; i<3; i++, s/=2., U*=m )\n        v  += s * noise( U ); \n    return v;\n}\n\nvoid mainImage( out vec4 O, vec2 u )\n{\n    vec2 R = iResolution.xy, eps = vec2(1e-3,0),\n         U = u / R.y,\n         P = 8.*U - vec2(0.,.5*iTime);\t\n    O-=O;\n\tfloat l, dl, f = func(P), df;\n    if ( int(u.y) == int(R.y*.4) ) { O.r++; return; }             // red separator\n    if ( U.y > .4 ) {\n#if 0\n        l = exp2(floor(log2(2.*fwidth(P.x)/fwidth(f))));          // subvid amount (relative)\n        dl =     fract(log2(2.*fwidth(P.x)/fwidth(f)));      \n#else\n        l = exp2(floor(log2(1./22./fwidth(f))));                  // subvid amount (absolute)\n        dl =     fract(log2(1./22./fwidth(f)));\n#endif\n\n#if 1                                                             // draw isolines using sin\n        O = (.5+.5*  mix( sin(50.*l*f) , sin(100.*l*f), dl ) ) * hue(f); \n#else                                                             // draw isolines \n        df = fwidth(f);\n     // df = length( vec2( ( func(P + eps.xy), func(P + eps.yx) ) -f ) / eps.x )*fwidth(P.x);\n        l *= 8.; \n        O += mix( draw(    f*l,    l*df ),\n                  draw( 2.*f*l, 2.*l*df ),\n                  dl );\n#endif\n    } \n    else {\n        f *= 8.;\n        O += draw( f, fwidth(f) );                                // draw isolines\n    }\n    \n    O = sqrt(O);                                                  // to sRGB\n}", "image_inputs": [{"id": "4dXGRr", "previewfilepath": "/presets/tex00.jpg", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/presets/tex00.jpg", "ctype": "keyboard"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/fsfXzj.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "fsfXzs", "name": "#004 - Bursting Starfield", "author": "Deadtotem", "description": "Practicing, nothing else. ", "tags": ["stars", "field", "starfield", "fireworks", "burst"], "likes": 4, "viewed": 142, "date": "1619027050", "time_retrieved": "2024-06-20T20:37:15.455833", "image_code": "#define NUM_BURST 50.\n#define NUM_STARS 40.\n\nmat2 Rot(float a)\n{\n    float s = sin(a), c=cos(a);\n    \n    return mat2(c,-s,s,c);\n}\n\nfloat random21(vec2 p)\n{\n    p = fract(p*vec2(123.34, 456.21));\n    \n    p += dot(p, p+45.32);\n    \n    return fract(p.x*p.y);\n}\n\nvec2 RectCoord(float t)\n{\n    float x = fract(sin(t*174.3)*353.2);\n    \n    float y = fract(sin((t*x)*614.3)*163.2);\n    \n    float ranN = random21(vec2(x,y));\n    \n    return vec2(ranN, y);\n}\n\nvec2 PolarCoord(float t)\n{\n    float a = fract(sin(t*74.3)*453.2)*3.1416;\n    \n    float d = fract(sin((t+a)*714.3)*263.2);\n    \n    float ranN = random21(vec2(a*4.2,d));\n    \n    return vec2(sin(ranN), cos(ranN))*fract(a)/d;\n}\n\nfloat Explosion(vec2 uv, float t)\n{\n        float sparks = 0.;\n        \n        for(float i=0.; i<NUM_BURST; i++)\n        {\n        \n            vec2 dir = PolarCoord(i+.1);    \n            \n            float n = random21(dir);\n           \n            float d = length(uv-dir*t);\n            \n            uv *= Rot(iTime*.015*n);\n\n            float brightness = mix(.00025, .00001, t);\n\n            brightness *=sin(t*5.+i)*.5+.5;\n                       \n            brightness *= mix(.501, .0, floor(t*n));\n\n            sparks += brightness/d;\n        }\n        \n        return sparks;\n}\n\nvec3 numExplosions(vec2 uv)\n{\n        vec3 outRGB = vec3(0);\n\n        for(float i=0.; i<NUM_STARS; i++)\n        {          \n        \n            float t = iTime+i/NUM_STARS;\n            \n            float ft = floor(iTime);\n                 \n            vec2 offs = RectCoord(i+1.+ft)-.75;\n            \n            offs *= vec2(1.5,.5);   \n                               \n            outRGB +=Explosion(uv-offs, fract(t)*.05);\n        }\n        \n        return outRGB;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n        \n    vec3 col = vec3(0);  \n       \n    float t = iTime*.0162;\n    \n    uv *= Rot(t*6.);\n    \n     for(float i=0.; i<1.; i+=1./6.){\n     \n        float depth = fract(i+t);\n        \n        float scale = mix(1.05, .05, depth)/depth;\n        \n        float fade = depth*smoothstep(.01,1.4,depth);\n        \n        col += numExplosions(uv*scale)*fade*vec3(.19,.59,.419+scale);\n    }\n\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/fsfXzs.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "fsj3Dm", "name": "Seafloor fractal 2", "author": "jarble", "description": "This fractal looks like a landscape from an alien world.\nFull-screen mode recommended.", "tags": ["fractal", "grass", "mountain", "valley"], "likes": 0, "viewed": 151, "date": "1617510035", "time_retrieved": "2024-06-20T20:37:15.461864", "image_code": "\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.0);\n    vec3 col;\n    float t = iTime;\n    vec2 uv = (fragCoord*10.0-iResolution.xy)/iResolution.y/10.0;\n    uv += vec2(t/2.0,t/3.0)/4.0;\n    for(int c=0;c<3;c++){\n        float scale = 5.0;\n        float scale1 = 1.5;\n        float s1 = scale1*scale;\n        for(int i=0;i<6;i++)\n        {\n            uv += uv.yy;\n            uv = fract((uv)/s1)*s1;\n            uv=-fract(uv/(3.5-abs((uv.y+uv.x)/(16.0)))-(uv/(2.5+(fract(uv.x+uv.y))))/scale)*scale/scale1+s1;\n            uv.y /= scale1+col.x;\n        \tuv=uv.yx+col.xy;\n            uv.x *= -(1.0+col.x/scale);\n            col[c] = fract((((1.0+col.y)*.125)*(col.x+uv.y-uv.x))/3.0);\n        }\n\t}\n    fragColor = vec4(vec3(col),1.0);\n    \n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/fsj3Dm.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "fsjGDy", "name": "Starry night background", "author": "mrange", "description": "License CC0: Starry night background\nCreated for another shader but thought the background could be useful to others so extracted it\n", "tags": ["stars"], "likes": 8, "viewed": 221, "date": "1617901952", "time_retrieved": "2024-06-20T20:37:16.170666", "image_code": "// License CC0: Starry night background\n//  Created for another shader but thought the background could be useful to others so extracted it\n\n// Controls how many layers of stars\n#define LAYERS            5.0\n\n#define PI                3.141592654\n#define TAU               (2.0*PI)\n#define TIME              iTime\n#define RESOLUTION        iResolution\n#define ROT(a)            mat2(cos(a), sin(a), -sin(a), cos(a))\n#define PCOS(x)           (0.5 + 0.5*cos(x))\n#define TTIME             (TAU*TIME)\n\n// https://stackoverflow.com/questions/15095909/from-rgb-to-hsv-in-opengl-glsl\nvec3 hsv2rgb(vec3 c) {\n  const vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n  vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n  return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\n// http://mercury.sexy/hg_sdf/\nvec2 mod2(inout vec2 p, vec2 size) {\n  vec2 c = floor((p + size*0.5)/size);\n  p = mod(p + size*0.5,size) - size*0.5;\n  return c;\n}\n\nvec2 hash2(vec2 p) {\n  p = vec2(dot (p, vec2 (127.1, 311.7)), dot (p, vec2 (269.5, 183.3)));\n  return fract(sin(p)*43758.5453123);\n}\n\nvec3 toSpherical(vec3 p) {\n  float r   = length(p);\n  float t   = acos(p.z/r);\n  float ph  = atan(p.y, p.x);\n  return vec3(r, t, ph);\n}\n\nvec3 postProcess(vec3 col, vec2 q)  {\n  col=pow(clamp(col,0.0,1.0),vec3(1.0/2.2)); \n  col=col*0.6+0.4*col*col*(3.0-2.0*col);  // contrast\n  col=mix(col, vec3(dot(col, vec3(0.33))), -0.4);  // satuation\n  col*=0.5+0.5*pow(19.0*q.x*q.y*(1.0-q.x)*(1.0-q.y),0.7);  // vigneting\n  return col;\n}\n\nvec3 stars(vec3 ro, vec3 rd) {\n  vec3 col = vec3(0.0);\n  vec3 srd = toSpherical(rd.xzy);\n  \n  const float m = LAYERS;\n\n  for (float i = 0.0; i < m; ++i) {\n    vec2 pp = srd.yz+0.5*i;\n    float s = i/(m-1.0);\n    vec2 dim  = vec2(mix(0.05, 0.003, s)*PI);\n    vec2 np = mod2(pp, dim);\n    vec2 h = hash2(np+127.0+i);\n    vec2 o = -1.0+2.0*h;\n    float y = sin(srd.y);\n    pp += o*dim*0.5;\n    pp.y *= y;\n    float l = length(pp);\n  \n    float h1 = fract(h.x*109.0);\n    float h2 = fract(h.x*113.0);\n    float h3 = fract(h.x*127.0);\n\n    vec3 hsv = vec3(fract(0.025-0.4*h1*h1), mix(0.5, 0.125, s), 1.0);\n    vec3 scol = mix(8.0*h2, 0.25*h2*h2, s)*hsv2rgb(hsv);\n\n    vec3 ccol = col+ exp(-(2000.0/mix(2.0, 0.25, s))*max(l-0.001, 0.0))*scol;\n    col = h3 < y ? ccol : col;\n  }\n  \n  return col;\n}\n\nvec3 grid(vec3 ro, vec3 rd) {\n  vec3 srd = toSpherical(rd.xzy);\n  \n  const float m = 1.0;\n\n  const vec2 dim = vec2(1.0/8.0*PI);\n  vec2 pp = srd.yz;\n  vec2 np = mod2(pp, dim);\n\n  vec3 col = vec3(0.0);\n\n  float y = sin(srd.y);\n  float d = min(abs(pp.x), abs(pp.y*y));\n  \n  float aa = 2.0/RESOLUTION.y;\n  \n  col += 2.0*vec3(0.5, 0.5, 1.0)*exp(-2000.0*max(d-0.00025, 0.0));\n  \n  return 0.25*tanh(col);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  vec2 q = fragCoord.xy/RESOLUTION.xy; \n  vec2 p = -1.0 + 2.0*q;\n  p.x *= RESOLUTION.x/RESOLUTION.y;\n\n  vec3 ro = mix(0.5, 0.25, PCOS(TTIME/120.0*sqrt(3.0)))*vec3(2.0, 0, 0.2)+vec3(0.0, -0.125, 0.0);\n  ro.yx *= ROT(TTIME/120.0*sqrt(0.5));\n  ro.xz *= ROT((TAU*(TIME-14.0)/120.0));\n  vec3 la = vec3(0.0, 0.0, 0.0);\n\n  vec3 ww = normalize(la - ro);\n  vec3 uu = normalize(cross( vec3(0.0,1.0,0.0), ww));\n  vec3 vv = normalize(cross(ww,uu));\n  const float rdd = 2.0;\n  vec3 rd = normalize(p.x*uu + p.y*vv + rdd*ww);\n\n  vec3 col = stars(ro, rd);\n  col += grid(ro, rd);\n  \n  fragColor = vec4(postProcess(col, q),1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc0-1.0", "thumbnail": "https://www.shadertoy.com/media/shaders/fsjGDy.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "fsjGRc", "name": "Spiral portal", "author": "forij", "description": "Spiral portal", "tags": ["spiral", "portal"], "likes": 3, "viewed": 112, "date": "1617746785", "time_retrieved": "2024-06-20T20:37:16.170918", "image_code": "float speed = -10.0;\nfloat frequency = 20.0;\n\nvoid spin(inout vec2 pos){\n    float angle = iTime - atan(length(pos)) * 3.0;\n    pos.xy = vec2( \n        pos.x * cos(angle) - pos.y * sin(angle),\n        pos.y * cos(angle) + pos.x * sin(angle)\n        );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    float t = iTime * speed;\n    vec2 position = (fragCoord.xy - iResolution.xy * .5) / iResolution.x;\n    \n    spin(position);\n    \n    float angle = atan(position.y, position.x) / (2. * 3.14159265359);\n    angle -= floor(angle);\n    float rad = length(position);\n    float angleFract = fract(angle * 256.);\n    float angleRnd = floor(angle * 256.) + 1.;\n    float angleRnd1 = fract(angleRnd * fract(angleRnd * .7235) * 45.1);\n    float angleRnd2 = fract(angleRnd * fract(angleRnd * .82657) * 13.724);\n    float t2 = t + angleRnd1 * frequency;\n    float radDist = sqrt(angleRnd2);\n    float adist = radDist / rad * .1;\n    float dist = (t2 * .1 + adist);\n    dist = abs(fract(dist) - 0.5);\n    \n    float outputColor = (1.0 / (dist)) * cos(0.7 * sin(t)) * adist / radDist / 30.0;\n    angle = fract(angle + .61);\n    \n    vec2 uv = fragCoord/iResolution.xy;\n    vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n\n    fragColor = vec4(outputColor * col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/fsjGRc.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "fsjGWD", "name": "Julia Tiling", "author": "Symmetries", "description": "Tiling the plane with Julia sets, and using a simple ray tracer to add a reflective sphere.", "tags": ["raytracing", "fractal"], "likes": 1, "viewed": 36, "date": "1617428392", "time_retrieved": "2024-06-20T20:37:16.170918", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 st = fragCoord.xy/iResolution.xy; // from 0 to 1\n    st = 2. * st - 1.; // from -1 to 1\n    st.y *= iResolution.y / iResolution.x; // fix aspect ratio\n    st.y -= 0.1;\n    float theta = 2. * cos(3.14 + iTime / 2.);\n\n    mat3 rot = mat3(\n        cos(theta), -sin(theta), 0.,\n        sin(theta), cos(theta),  0.,\n        0.,          0.,           1.\n    );\n    \n    float dx = 1. / iResolution.x;\n    vec3[9] ws = vec3[9](\n        vec3(st.x - dx, 1., st.y - dx),\n        vec3(st.x - dx, 1., st.y     ),\n        vec3(st.x - dx, 1., st.y + dx),\n        vec3(st.x     , 1., st.y - dx),\n        vec3(st.x     , 1., st.y     ),\n        vec3(st.x     , 1., st.y + dx),\n        vec3(st.x + dx, 1., st.y - dx),\n        vec3(st.x + dx, 1., st.y     ),\n        vec3(st.x + dx, 1., st.y + dx)\n    );\n    \n    vec3 p = vec3(0., 3., 0.);\n    float r = 1.;\n    \n    fragColor = vec4(0., 0., 0., 0.);\n    for (int i = 0; i < ws.length(); i++) {\n        ws[i] = rot * normalize(ws[i]);\n     \n        float a = dot(ws[i], ws[i]);\n        float b = -2. * dot(ws[i], p);\n        float c = dot(p, p) - r * r;\n        float dis = b * b - 4. * a * c;    \n\n        float t = (-b - sqrt(abs(dis))) / (2. * a);\n        float cond = float(dis > 0. && t > 0.);\n        vec3 o = cond * t * ws[i];\n        ws[i] += cond * (normalize(reflect(ws[i], p - o)) - ws[i]);\n        vec3 col = vec3(0, 0, 0);\n\n        if (ws[i].z < 0.) {\n            vec2 c = vec2(-0.391, -0.587);\n            vec2 v = o.xy + (-1. - o.z) * ws[i].xy / ws[i].z + vec2(2., 0.5);\n            float zoom = 1.6;\n            vec2 z = 2. * zoom * fract(.2 * v) - zoom;\n            \n            float cond = 0.;\n            float n = 10.;\n            for (int iter = 0; iter < 100; iter++) {\n                cond = float(dot(z, z) > 4.);\n                z = vec2(z.x * z.x - z.y * z.y, 2. * z.x * z.y) + c;\n                col = cond * vec3(1. - exp(-float(iter / 2) / 4.), 0.1, 0.1) + (1. - cond) * col;\n            }\n        } else {\n            col = 1.1 * ws[i].zzz;\n        }\n        fragColor += vec4(col, 1.) / float(ws.length());\n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/fsjGWD.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "fsjGWm", "name": "Penumbra Soft Shadow_HW09", "author": "roamingsci", "description": "This shader is a soft shadow approximation with distance fields.", "tags": ["softshadow", "penumbrashadow"], "likes": 4, "viewed": 75, "date": "1617496756", "time_retrieved": "2024-06-20T20:37:16.170918", "image_code": "const int RAY_STEPS = 256;\nconst float FOVY = 3.141569 * 0.25;\n\n// The higher the value, the smaller the penumbra\nconst float SHADOW_HARDNESS = 6.0;\n// The higher the value, the denser the penumbra\nconst int SHADOW_STEPS = 10;\n\n#define IDBackWall 1\n#define IDFloorWall 2\n#define IDShortCube 3\n\nstruct Intersection\n{\n    float t;\n    vec3 color;\n    vec3 p;\n    int object;\n};\n\nvec3 rotateY(vec3 p, float a) {\n    return vec3(cos(a) * p.x + sin(a) * p.z, p.y, -sin(a) * p.x + cos(a) * p.z);\n}\n\nfloat plane( vec3 p, vec4 n )\n{\n  // n must be normalized\n  return dot(p,n.xyz) + n.w;\n}\n\n// Box with side lengths b\nfloat box(vec3 p, vec3 b)\n{\n  return length(max(abs(p) - b, 0.0));\n}\n\nvoid sceneMap3D(vec3 pos, out float t, out int obj)\n{\n    // Initialize to back wall sdf\n    t = plane(pos, vec4(0.0, 0.0, -1.0, 5.0));\n    obj = IDBackWall;\n\n    float t2;\n    // Check floor wall\n    if((t2 = plane(pos, vec4(0.0, 1.0, 0.0, 2.5))) < t)\n    {\n        t = t2;\n        obj = IDFloorWall;\n    }\n    // Check of short cube\n    if((t2 = box(rotateY(pos + vec3(0., 1., 1.75), 17.5 * 3.14159 / 180.0), vec3(1.5, 1.5, 1.5))) < t)\n    {\n        t = t2;\n        obj = IDShortCube;\n    }\n}\n\nfloat sceneMap3D(vec3 pos)\n{\n    float t;\n    int obj;\n    sceneMap3D(pos,t,obj);\n    return t;\n}\n\n\nvec3 computeNormal(vec3 pos)\n{\n    vec3 epsilon = vec3(0.0, 0.001, 0.0);\n    return normalize( vec3( sceneMap3D(pos + epsilon.yxx) - sceneMap3D(pos - epsilon.yxx),\n                            sceneMap3D(pos + epsilon.xyx) - sceneMap3D(pos - epsilon.xyx),\n                            sceneMap3D(pos + epsilon.xxy) - sceneMap3D(pos - epsilon.xxy)));\n}\n\nvoid march(vec3 origin, vec3 dir, out float t, out int hitObj)\n{\n    t = 0.001;\n    for(int i = 0; i < RAY_STEPS; ++i)\n    {\n        vec3 pos = origin + t * dir;\n        float m;\n        sceneMap3D(pos, m, hitObj);\n        if(m < 0.01)\n        {\n            return;\n        }\n        t += m;\n    }\n    // If there is no object in 256 steps\n    t = -1.0;\n    hitObj = -1;\n}\n\n// Follow the code in Visual Effects PPT\nfloat softShadow(vec3 dir, vec3 origin, float min_t, float k) {\n    float res = 1.0;\n    float t = min_t;\n    for(int i = 0; i < SHADOW_STEPS; ++i) {\n        float m = sceneMap3D(origin + t * dir);\n        if(m < 0.0001) {\n            return 0.;\n        }\n        res = min(res, k * m / t);\n        t += m;\n    }\n    res = clamp(res, -1., 1.);    \n    return res;\n}\n\nfloat hardShadow(vec3 dir, vec3 origin, float min_t) {\n    float t = min_t;\n    for(int i = 0; i < RAY_STEPS; ++i) {\n        float m = sceneMap3D(origin + t * dir);\n        if(m < 0.0001) {\n            return 0.0;\n        }\n        t += m;\n    }\n    return 1.0;\n}\n\nvec3 computeMaterial(int hitObj, vec3 p, vec3 n, vec3 lightVec, vec3 view)\n{\n    // Use the simple lamber shading for this scene\n    float lambert = abs(dot(-lightVec, n));\n    vec3 lightCol = vec3(1.0, 0.88, 0.7);\n    switch(hitObj){\n        case IDShortCube:\n        return (lambert) * lightCol * vec3(0.3, 0.5, 1.);\n        break;\n        case IDBackWall:\n        return lightCol * vec3(1., 1., 1.) * lambert;\n        break;\n        case IDFloorWall:\n        return lightCol * vec3(1., 1., 1.) * lambert;\n        break;\n        case -1:\n        return vec3(0., 0., 0.);\n        break;\n    }\n    return vec3(1.);\n}\n\nIntersection sdf3D(vec3 dir, vec3 eye)\n{\n    float t;\n    int hitObj;\n    march(eye, dir, t, hitObj);\n\n    vec3 isect = eye + t * dir;\n    vec3 nor = computeNormal(isect);\n    // Set the light as a point light\n    vec3 lightPos = vec3(2.0 * sin(iTime * 0.5), 6., -2. + 2.5 * cos(iTime * 0.5));\n\n    vec3 lightDir = normalize(isect - lightPos);\n    \n    float shadow = softShadow(-lightDir, isect, 0.02, SHADOW_HARDNESS);\n    \n    vec3 surfaceColor = shadow * computeMaterial(hitObj, isect, nor, lightDir, normalize(eye - isect));\n    surfaceColor = clamp(surfaceColor, 0., 1.);\n\n    return Intersection(t, surfaceColor, isect, hitObj);\n}\n\n\nvec3 rayCast(vec3 eye, vec3 ref, vec2 ndc)\n{\n    vec3 F = ref - eye;\n    vec3 R = normalize(cross(F, vec3(0.0, 1.0, 0.0)));\n    vec3 U = normalize(cross(R, F));\n\n    vec3 V = U * length(F) * tan(FOVY * 0.5);\n    vec3 H = R * length(F) * tan(FOVY * 0.5) * float(iResolution.x) / iResolution.y;\n\n    vec3 p = ref + ndc.x * H + ndc.y * V;\n\n    return normalize(p - eye);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // [-1, 1]\n    uv = uv * 2.0 - vec2(1.0, 1.0);\n\n    vec3 eye = vec3(0, 3, -20);\n\n    vec3 ref = vec3(0, 0, 100);\n\n    vec3 rayDir = rayCast(eye, ref, uv);\n\n    Intersection isect = sdf3D(rayDir, eye);\n\n    // Output to screen\n    fragColor = vec4(isect.color, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/fsjGWm.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "fsjXzh", "name": "Infinite Snowflakes", "author": "PQuinn", "description": "A shader that makes random snowflakes", "tags": ["procedural", "snowflakes"], "likes": 2, "viewed": 59, "date": "1619645244", "time_retrieved": "2024-06-20T20:37:16.637739", "image_code": "#define PI 3.141592654\n#define flake_radius_range .05\n#define flake_radius_min .05\n# define flake_speed .15\n# define num_flakes 20\n\nfloat rand(vec2 co){\n  return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nvec2 cart2polar(vec2 cart){\n    float r = length(cart);        \n    float theta = atan(cart.y/cart.x);   \n    if (cart.x < 0. && cart.y > 0.)\n        theta +=  PI;    \n    if (cart.x < 0. && cart.y < 0.)\n        theta -= PI;    \n    if (theta < 0.)\n        theta += 2.* PI;        \n    return vec2(r,theta);\n}\n\nfloat snowflake(vec2 center, float radius, vec2 point, int i){ // a binary in/out check\n\n    float r1 = .5 + 5. * rand(vec2(i,1)) ; \n    float r2 = 1. + 4. * rand(vec2(i,2)); \n    float r3 = .4 * rand(vec2(i,3)); // controls thiness (higher = thinner)\n    float r4 = 6.*(rand(vec2(i,4)-.5)); // speed of rotation\n        \n    vec2 polar = cart2polar(point - center);\n    float theta = polar.y;\n    float r = polar.x;\n    if (r>radius) {return 0.;} //outside, return 0    \n    theta *= 6.;\n    \n    if (i % 2 == 0){\n        theta += iTime;\n        }\n    else{\n        theta -=iTime;\n    }\n    \n    float a = sin(theta); // ensure 6 fold rotational symmetry and rotation    \n    float b = cos(r1 * r/radius * 2. * PI);      \n    float c = sin(r2 * r/radius * 2. * PI);\n    \n    return step(r3, (a + b + c)/3.);\n\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    float gradient = uv.y;    \n    //uv = uv * 2. - vec2(1,1);      \n    uv.y = -uv.y; // flip coords so +y is down\n    uv.y += 1. + flake_radius_min + flake_radius_range; // offset so (0,0) is above top left and we won't see flake pop in\n    float aspect = iResolution.x/iResolution.y;\n    uv.x *= aspect; // correct aspect ratio\n   \n    vec3 bg = mix(vec3(0,0,1), vec3(.2,.2,.2), gradient);\n\n \n    // Output to screen\n    fragColor = vec4(bg,1.0);\n        \n    \n    for (int i = 0; i<num_flakes; i++){\n        vec2 c = vec2(0, 5. * rand(vec2(i,1)));\n        float y = c.y + flake_speed * iTime * (.5 + .5*rand(vec2(i,i))); // fall speed\n        c.y  = mod(y, 2.);\n        int pass = int(floor(y/2.)); \n        \n        int flake_number = i +  pass * num_flakes; // ensure new flake everytime around\n        c.x = aspect *  rand(vec2(flake_number, .1));\n        float radius = flake_radius_min  + flake_radius_range * rand(vec2(flake_number, .2));\n        vec3 col = vec3(1,1,1) * snowflake(c, radius, uv, flake_number);\n\n        fragColor += vec4(col, 1.);\n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/fsjXzh.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "fslSWr", "name": "Alien Bit Patterns", "author": "thope", "description": "Original tweet: https://twitter.com/aemkei/status/1378106731386040322\n\nTODO:\n- figure out how to do a perfecto loop\n- more bit patterns", "tags": ["alien", "xor", "pattern"], "likes": 3, "viewed": 179, "date": "1618488979", "time_retrieved": "2024-06-20T20:37:17.074448", "image_code": "/*\n    Not working in latest Safari! Try Chrome or something instead.\n*/\n\n\nfloat random(vec2 st) {\n    return fract(sin(dot(st.xy,\n                         vec2(12.9898,78.233)))*\n        43758.5453123);\n}\n\nfloat saturate(float x) {\n    return clamp(x, 0.0, 1.0);\n}\n\nvec3 get_col(vec2 uv)\n{\n     return 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Time varying pixel color\n    vec3 col = get_col(uv);\n\n    // Adjust offset and scale\n    float scale = 0.1;\n    vec2 offset = iResolution.xy * 0.5;\n    offset.x -= iTime * 100.0;\n    offset.y += sin(iTime) * 100.0;\n    vec2 coord = fragCoord - offset;\n    coord *= scale;\n    \n    // Get x and y as integers\n    int x = abs(int(coord.x));\n    int y = abs(int(coord.y));\n    vec2 icoord = vec2(x,y);\n    \n    // Sparkle\n    float sparkle = random(icoord + iTime * 0.00001);\n    sparkle = saturate(sparkle - 0.2);\n    col = mix(get_col(uv + sparkle * 1.0), vec3(.0,.0,.0), sparkle);\n    \n    // Ripple\n    float ripple = texture(iChannel0, coord * 0.001 + iTime * 0.0001).r;\n    ripple *= texture(iChannel0, coord * 0.001 + iTime * 0.0001 * vec2(-.9,-1.)).r;\n    col *= saturate(ripple + 0.5);\n    \n    // Magic alien formulae\n    if((x ^ y) % 9 == 1)\n    {\n        fragColor = vec4(col,1.0);\n    }\n    else\n    {\n        col = get_col(uv) * ripple * 0.1;\n        fragColor = vec4(col,1.0);\n    }\n}\n\n/*\n    Unlicense    \n    This is free and unencumbered software released into the public domain.\n    For more information, please refer to <http://unlicense.org/>\n*/", "image_inputs": [{"id": "4dXGzn", "previewfilepath": "/media/ap/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/fslSWr.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "fslXDB", "name": "Stateless fizzlefade", "author": "antovsky", "description": "Based on the awesome article https://blog.demofox.org/2013/07/06/fast-lightweight-random-shuffle-functionality-fixed/\nThis is the stateless version adapted for shaders, that works for any resolution.", "tags": ["fizzlefade"], "likes": 2, "viewed": 59, "date": "1619166473", "time_retrieved": "2024-06-20T20:37:17.674205", "image_code": "// The MIT License\n// Copyright © 2021 by Anton Mikhailov\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n\n/* Any other hash should work according to the article, but I'm sticking to a nice and bijective one just in case... */\nuint splitmix32(uint b) {\n\tb += 0x9e3779b9u;\n\tb ^= b >> 15;\n\tb *= 0x85ebca6bu;\n\tb ^= b >> 13;\n\tb *= 0xc2b2ae3du;\n\tb ^= b >> 16;\n\treturn b;\n}\n/* \n   Adapted into a stateless versionfrom:\n   https://blog.demofox.org/2013/07/06/fast-lightweight-random-shuffle-functionality-fixed/\n   https://github.com/Atrix256/RandomCode/blob/master/StoragelessShuffle/Source.cpp\n*/\nuint shuffle(uint idx, uint count, uint seed) {\n\t/* Pre-calculate the masks needed for the Feistel network. */\n\t/* If doing this for many indecies in a row, it would make sense to cache this. */\n\tuint next_pow_4 = 4u;\n\twhile (count > next_pow_4)\n\t\tnext_pow_4 *= 4u;\n\tuint num_bits = 0u;\n\tuint mask = next_pow_4 - 1u;\n\twhile (mask != 0u) {\n\t\tmask = mask >> 1;\n\t\tnum_bits++;\n\t}\n\tuint half_num_bits = num_bits / 2u;\n\tuint right_mask = (1u << half_num_bits) - 1u;\n\tuint left_mask = right_mask << half_num_bits;\n\n\t/* This will terminate as long as idx starts less than count. */\n\twhile (true)\n\t{\n\t\t/* Split the index. */\n\t\tuint left = (idx & left_mask) >> half_num_bits;\n\t\tuint right = (idx & right_mask);\n\t\t/* Do 4 Feistel rounds. */\n\t\tfor (int index = 0; index < 4; ++index)\n\t\t{\n\t\t\tuint newLeft = right;\n\t\t\tuint newRight = left ^ (splitmix32(right ^ seed) & right_mask);\n\t\t\tleft = newLeft;\n\t\t\tright = newRight;\n\t\t}\n\t\t/* Re-assemble the bits into a shuffled index. */\n\t\tidx = (left << half_num_bits) | right;\n\n\t\t/* If it's in range, we are done. Otherwise keep trying (reject this result) */\n\t\tif (idx < count)\n\t\t\treturn idx;\n\t}\n\t/* We should never get here. */\n\treturn 0u;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    vec3 col = vec3(1.0);\n    \n    // TEH MEAT: Stateless fizzlefade effect\n    float t = abs(1.0-fract(iTime*0.0125)*2.0); // sawtooth\n    uint idx = uint(fragCoord.x + fragCoord.y * iResolution.x);\n    uint count = uint(iResolution.x * iResolution.y);\n    uint i = uint(float(count) * t);\n    uint seed = 108u;\n    if (shuffle(idx, count, seed) >= i)\n        col = vec3(0.0);\n    // END MEAT\n     \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "mit", "thumbnail": "https://www.shadertoy.com/media/shaders/fslXDB.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "fslXRj", "name": "Amiga Copper Bars", "author": "Hellcat", "description": "Recreation of the Amiga copper bars effect, one of my favourites - now as a selfmade shader :-)", "tags": ["simple", "retro", "amiga", "first"], "likes": 2, "viewed": 85, "date": "1618866770", "time_retrieved": "2024-06-20T20:37:18.219545", "image_code": "/*\n * Amiga Copper Bars\n * by HELLCAT\n * ===================\n *\n * My very fist attempt at creating a shader.\n * It's not too much, but I never stopped loving those copper bars :-)\n *\n * Cheers.\n */\n\n#define M_PI 3.1415926535897932384626433832795\n\n// calc the current position of a bar\nfloat calcBarPos( float movementSpeed, float offset )\n{\n    return (sin( mod( (iTime * movementSpeed) + offset, M_PI * 2.0 ) ) + 1.0) / 2.0;\n}\n\n// calc compression modifier for a bar\nfloat calcBarCompression( float pulseFrom, float pulseTo, float pulseSpeed )\n{\n    return ( pulseTo - pulseFrom ) * ((sin( mod( iTime * pulseSpeed, M_PI * 2.0 ) ) + 1.0) / 2.0 );\n}\n\n// draw a bar\nvec4 drawBar( vec2 uv, vec4 inColor, vec4 barColor, float barRadius, float barMoveSpeed, float barOffset, float barCompression, float barCompressionPulseTo, float barCompressionPulseSpeed )\n{\n    vec4 outColor = inColor;\n    float barPos;\n    float posNormaled;\n    \n    barPos = calcBarPos( barMoveSpeed, barOffset );\n    barCompression += calcBarCompression( barCompression, barCompressionPulseTo, barCompressionPulseSpeed );\n    \n    if( (uv.y > (barPos - barRadius)) && uv.y < (barPos) )\n    {\n        posNormaled = pow((uv.y - barPos + barRadius) / barRadius, barCompression);\n        outColor += barColor * posNormaled;\n    }\n\n    if( (uv.y < (barPos + barRadius)) && uv.y > (barPos) )\n    {\n        posNormaled = pow(1.0 - (uv.y - barPos) / barRadius, barCompression);\n        outColor += barColor * posNormaled;\n    }\n    \n    return outColor;\n}\n\n// le main\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // configs\n    float bar1Offset = -0.5;\n    float bar1Radius = 0.1;\n    float bar1Compression = 3.0;\n    float bar1MoveSpeed = 1.0;\n    float bar1CompressionPulseTo = 3.0;\n    float bar1CompressionPulseSpeed = 0.0;\n    vec4 bar1Color = vec4(1.0, 0.0, 0.0, 1.0);\n\n    float bar2Offset = 0.5;\n    float bar2Radius = 0.1;\n    float bar2Compression = 3.0;\n    float bar2MoveSpeed = 1.0;\n    float bar2CompressionPulseTo = 3.0;\n    float bar2CompressionPulseSpeed = 0.0;\n    vec4 bar2Color = vec4(0.0, 1.0, 0.0, 1.0);\n\n    float bar3Offset = 0.0;\n    float bar3Radius = 0.1;\n    float bar3Compression = 3.0;\n    float bar3MoveSpeed = 1.0;\n    float bar3CompressionPulseTo = 3.0;\n    float bar3CompressionPulseSpeed = 0.0;\n    vec4 bar3Color = vec4(0.0, 0.0, 1.0, 1.0);\n\n    float bar4Offset = -M_PI/2.0;\n    float bar4Radius = 0.33;\n    float bar4Compression = 1.0;\n    float bar4MoveSpeed = 0.0;\n    float bar4CompressionPulseTo = 4.0;\n    float bar4CompressionPulseSpeed = 0.0;\n    vec4 bar4Color = vec4(0.0, 0.33, 0.33, 1.0);\n\n    float bar5Offset = 0.0;\n    float bar5Radius = 0.15;\n    float bar5Compression = 2.0;\n    float bar5MoveSpeed = 1.5;\n    float bar5CompressionPulseTo = 2.0;\n    float bar5CompressionPulseSpeed = 0.0;\n    vec4 bar5Color = vec4(1.0, 1.0, 0.0, 1.0);\n\n    fragColor = vec4(0.0, 0.0, 0.0, 1.0);\n\n    // Normalized pixel coordinates\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    // draw the bars\n    fragColor += drawBar( uv, vec4(0.0), bar1Color, bar1Radius, bar1MoveSpeed, bar1Offset, bar1Compression, bar1CompressionPulseTo, bar1CompressionPulseSpeed );\n    fragColor += drawBar( uv, vec4(0.0), bar2Color, bar2Radius, bar2MoveSpeed, bar2Offset, bar2Compression, bar2CompressionPulseTo, bar2CompressionPulseSpeed );\n    fragColor += drawBar( uv, vec4(0.0), bar3Color, bar3Radius, bar3MoveSpeed, bar3Offset, bar3Compression, bar3CompressionPulseTo, bar3CompressionPulseSpeed );\n    fragColor += drawBar( uv, vec4(0.0), bar4Color, bar4Radius, bar4MoveSpeed, bar4Offset, bar4Compression, bar4CompressionPulseTo, bar4CompressionPulseSpeed );\n    fragColor += drawBar( uv, vec4(0.0), bar5Color, bar5Radius, bar5MoveSpeed, bar5Offset, bar5Compression, bar5CompressionPulseTo, bar5CompressionPulseSpeed );\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/fslXRj.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "fsS3RV", "name": "Joanna", "author": "SnoopethDuckDuck", "description": "Squiggly stuff", "tags": ["cool"], "likes": 2, "viewed": 34, "date": "1617630138", "time_retrieved": "2024-06-20T20:37:18.383204", "image_code": "const float pi = 3.14159;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\nvec2 dir = uv - 0.5;\nfloat d = 4. * length(dir);\nfloat theta = atan(dir.y,dir.x);\n\nfloat val = 1.- cos(theta - 0.2 * iTime + 0.5 *cos(3. * theta + 0.5 *iTime));\nfloat val2 = 1.- cos(theta - 0.2 * iTime + 2. * pi / 3. + 0.5 * cos(3. * theta + 0.5 * iTime + 2. * pi / 3.));\nfloat val3 = 1. -cos(theta - 0.2 * iTime + 4. * pi/3. + 0.5 * cos(3. * theta + 0.5 * iTime + 4. * pi / 3.));\n\n\n    // Time varying pixel color\n    vec3 col = vec3(smoothstep(d,val,sqrt(val2 * val2 + val3 * val3)),\n    smoothstep(d,val2,sqrt(val * val + val3 * val3)),\n    smoothstep(d,val3,sqrt(val2 * val2 + val * val)));\n    \n\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/fsS3RV.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "fsS3W3", "name": "GrayTriangles", "author": "Pollari", "description": "Three areas of varying shades of grey. My first shader ever.", "tags": ["triangle"], "likes": 2, "viewed": 35, "date": "1618002332", "time_retrieved": "2024-06-20T20:37:18.389300", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalisoidut pikselin koordinaatit (0:sta 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    //Pikselin väri (R,G,B)\n    vec3 col = vec3(0,0,0);\n    float overlaps = 0.0;\n    \n\n    \n    \n    // Rajataan alue 1 kolmella suoralla, joista yksi riippuvainen ajasta\n    if(uv.y < uv.x &&  uv.y > uv.x * 0.5 && uv.y < (1.0 * cos(iTime * 2.0)) - (2.0 * uv.x) + 1.5)col =\n    // Tummuuskerroin sinillä, tämän rivin toiminta aika suoraan 3p mallista\n    (uv.x - 0.1*sin(iTime + uv.x*2.0)+0.5) * 0.1\n    // Keinutellaan väri sin ajan mukaan musta-valkoinen välillä\n    + 0.1* vec3(sin(iTime*2.0) + 0.9,sin(iTime*2.0) + 0.9,sin(iTime*2.0) + 0.9);\n    // Kasvatetaan overlap-laskuria yhdellä\n    if(uv.y < uv.x &&  uv.y > uv.x * 0.5 && uv.y < (1.0 * cos(iTime * 2.0)) - (2.0 * uv.x) + 1.5)overlaps++;\n    \n    // Rajataan alue 2 kolmella suoralla, joista yksi riippuvainen ajasta\n    if(uv.y > -uv.x + 1.0 &&  uv.y < -uv.x * 0.5 + 1.0 && uv.y < (2.0 * cos(iTime * 3.0)) + (uv.x) + 1.5)col =\n    // Tummuuskerroin sinillä, tämän rivin toiminta aika suoraan 3p mallista\n    (uv.x - 0.1*sin(iTime + uv.x*3.0)+0.5) * 0.1\n    // Keinutellaan väri sin ajan mukaan musta-valkoinen välillä\n    + 0.1* vec3(sin(iTime*3.0) + 0.9,sin(iTime*3.0) + 0.9,sin(iTime*3.0) + 0.9);\n    // Kasvatetaan overlap-laskuria yhdellä\n    if(uv.y > -uv.x + 1.0 &&  uv.y < -uv.x * 0.5 + 1.0 && uv.y < (2.0 * cos(iTime * 3.0)) + (uv.x) + 1.5)overlaps++;\n\n\n    // Rajataan keskelle alue 3 kolmella suoralla\n    if(uv.y > 0.4 && uv.y < 2.0 - 2.0 * uv.x && uv.y < 2.0 * uv.x - 0.3)col =\n    // Asetetaan vakioväri, overlapit tummentavat aluetta\n    0.7 * vec3(1.0 - overlaps / 2.0,1.0 - overlaps / 2.0,1.0 - overlaps / 2.0);\n    \n\n    // Asetetaan väri ruudulle\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/fsS3W3.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "fsSGDG", "name": "Distance to feature points V", "author": "tomoe", "description": "getting distances to the 1st to 4th closest feature points", "tags": ["bd202104"], "likes": 1, "viewed": 51, "date": "1617850194", "time_retrieved": "2024-06-20T20:37:18.389300", "image_code": "uvec3 k = uvec3(0x456789abu, 0x6789ab45u, 0x89ab4567u);\nconst uint max32 = 0xffffffffu;\nconst float PI = 3.14159265359;\nuvec2 hash22u(uvec2 n) {  \n    n ^= (n.yx << 24);\n    n ^= (n.yx >> 1);\n    n *= k.xy;\n    n ^= (n.yx << 1);\n    return n * k.xy;\n}\nuvec3 hash33u(uvec3 n) {\n    n ^= (n.yzx << 24);\n    n ^= (n.yzx >> 1);\n    n *= k;\n    n ^= (n.yzx << 1);\n    return n * k;\n}\nmat2 rot2(float t) {\n    return mat2(cos(t), sin(t), -sin(t),  cos(t));\n}\nfloat length2(vec2 v){\n    return dot(v, v);\n}\nfloat length3(vec3 v){\n    return dot(v, v);\n}\nvec2 hash22(vec2 p) {\n    uvec2 n = uvec2(p);\n    return vec2(hash22u(n)) / vec2(max32) - 0.5;\n}\nvec3 hash33(vec3 p) {\n    uvec3 n = uvec3(p);\n    return vec3(hash33u(n)) / vec3(max32) - 0.5;\n}\nvec4 sort(vec4 list, float v){\n    if (list.w < v){\n        return list;\n    } else {\n        vec4 newList = list.wxyz;\n        for(int i = 0; i < 4; i ++ ) {\n            if (list[i] < v) {\n                newList[i] = list[i];\n            } else {\n                newList[i] = v;\n                break;\n            }\n        }\n        return newList;\n    }\n}\nvec4 F4_2d(vec2 p){   \n    vec2 n = round(p);\n    vec2 f = p - round(p);\n    vec4 dist4 = vec4(length2(1.5 - abs(f)));\n    vec2 sgn = vec2(1.0);\n    vec2 glid = vec2(0.0);\n    for(float j = 0.0; j <= 4.0; j ++ ) {\n        glid.y += sgn.y * j;\n        sgn.y *= -1.0;\n        if (abs(glid.y - f.y) - 0.5 > sqrt(dist4.w)){\n            continue;\n        }\n        for(float i = 0.0; i <= 4.0; i ++ ){\n            glid.x += sgn.x * i;\n            sgn.x *= -1.0;\n            vec2 nbd = glid + rot2(iTime) * hash22(n + glid) / sqrt(2.0);\n            float dist = length2(nbd -f);\n            dist4 = sort(dist4, dist);\n        }\n        glid.x = 0.0;\n    }\n    return sqrt(dist4);\n}\nvec4 F4_3d(vec3 p){   \n    vec3 n = round(p);\n    vec3 f = p - round(p);\n    vec4 dist4 = vec4(length3(1.5 - abs(f)));\n    vec3 sgn = vec3(1.0);\n    vec3 glid = vec3(0.0);\n    for(float k = 0.0; k <= 4.0; k ++ ) {\n            glid.z += sgn.z * k;\n            sgn.z *= -1.0;\n            if (abs(glid.z - f.z) - 0.5 > sqrt(dist4.w)){\n                continue;\n            }\n        for(float j = 0.0; j <= 4.0; j ++ ) {\n            glid.y += sgn.y * j;\n            sgn.y *= -1.0;\n            if (abs(glid.y - f.y) - 0.5 > sqrt(dist4.w)){\n                continue;\n            }\n            for(float i = 0.0; i <= 4.0; i ++ ){\n                glid.x += sgn.x * i;\n                sgn.x *= -1.0;\n                vec3 nbd = glid + hash33(n + glid);\n                float dist = length3(nbd - f);\n                dist4 = sort(dist4, dist);\n            }\n            glid.x = 0.0;\n        }\n        glid.y = 0.0;\n    }\n    return sqrt(dist4);\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    vec2 pos = fragCoord.xy/ iResolution.xx;\n    pos *= 10.0;\n    pos += iTime;\n    int ind = int(4.0 * fragCoord.x / iResolution.x);  //0,1,2,3 from L to R\n    if(gl_FragCoord.y < 0.5 * iResolution.y){\n        fragColor = vec4(F4_2d(pos)[ind]);  //lower\n    } else {\n        fragColor = vec4(F4_3d(vec3(pos, iTime))[ind]);  //upper\n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/fsSGDG.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "fsSGWG", "name": "Distance to feature points II", "author": "tomoe", "description": "Computing method of getting the first distance is improved from the naïve one (improved from [url=https://www.shadertoy.com/view/sdj3zd]Distance to feature points I[/url])", "tags": ["bd202104"], "likes": 0, "viewed": 53, "date": "1617846219", "time_retrieved": "2024-06-20T20:37:18.728741", "image_code": "uvec3 k = uvec3(0x456789abu, 0x6789ab45u, 0x89ab4567u);\nconst uint max32 = 0xffffffffu;\nconst float PI = 3.14159265359;\nuvec2 hash22u(uvec2 n) {  \n    n ^= (n.yx << 24);\n    n ^= (n.yx >> 1);\n    n *= k.xy;\n    n ^= (n.yx << 1);\n    return n * k.xy;\n}\nvec2 hash22(vec2 p) {\n    uvec2 n = uvec2(p);\n    return vec2(hash22u(n)) / vec2(max32) - 0.5;\n}\nfloat length2(vec2 v){\n    return dot(v, v);\n}\nfloat F1_(vec2 p){   \n    vec2 n = round(p);\n    vec2 f = p - round(p);\n    float dist = sqrt(2.0);\n    for(float j = - 2.0; j <= 2.0; j ++ ) {\n        for(float i = - 2.0; i <= 2.0; i ++ ){\n            vec2 nbd = vec2(i, j);\n            nbd += hash22(n + nbd);\n            dist = min(dist, length(nbd - f));\n        }\n    }\n    return dist;\n}\nfloat F1(vec2 p){   \n    vec2 n = round(p);\n    vec2 f = p - round(p);\n    float dist = length2(abs(f) + 0.5);\n    vec2 sgn = vec2(1.0);\n    vec2 glid = vec2(0.0);\n    for(float j = 0.0; j <= 2.0; j ++ ) {\n        glid.y += sgn.y * j;\n        sgn.y *= -1.0;\n        float rowDist = max(abs(glid.y - f.y) - 0.5, 0.0);\n        if (rowDist > sqrt(dist)){\n            continue;\n        }\n        for(float i = 0.0; i <= 2.0; i ++ ){\n            glid.x += sgn.x * i;\n            sgn.x *= -1.0;\n            vec2 nbd = glid + hash22(n + glid);\n            dist = min(dist, length2(nbd - f));\n        }\n        glid.x = 0.0;\n    }\n    return sqrt(dist);\n}\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n    vec2 pos = fragCoord.xy/ iResolution.xx;\n    pos *= 20.0;\n    pos += iTime;\n    if (fragCoord.x < 0.5 * iResolution.x){\n        fragColor = vec4(vec3(F1(pos)), 1.0);  //improved\n    } else {\n        fragColor = vec4(vec3(F1_(pos)), 1.0);  //naive\n    }\n    \n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/fsSGWG.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "fsSGzK", "name": "Messing around during revision", "author": "xernobyl", "description": "Messing around during revision 2021's compostudio.", "tags": ["rays", "cubes"], "likes": 4, "viewed": 82, "date": "1617626338", "time_retrieved": "2024-06-20T20:37:18.734801", "image_code": "\nfloat sd_box(vec3 p, vec3 b) {\n  vec3 q = abs(p) - b;\n  return length(max(q, 0.0)) + min(max(q.x, max(q.y, q.z)), 0.0);\n}\n\n\nfloat scene(vec3 ray_pos, vec3 ray_origin) {\n    float d = distance(ray_pos, ray_origin);\n\n    ray_pos.x = mix(ray_pos.x, (ray_pos.x - ray_origin.x) * cos(iTime) + (ray_pos.y - ray_origin.y) * sin(iTime), clamp(d / 50.0, 0.0, 1.0));\n    ray_pos.y = mix(ray_pos.y, (ray_pos.x - ray_origin.x) * sin(iTime) + (ray_pos.y - ray_origin.y) * cos(iTime), clamp(d / 50.0, 0.0, 1.0));\n    \n    return min(\n             min(\n               sd_box(fract((ray_pos + 2.5) / 5.0) * 5.0 - 2.5, vec3(1.0, 1.0, 1.0)),\n               sd_box(fract((ray_pos + 2.5) / 5.0) * 5.0 - 2.5, vec3(0.25, 0.25, 4.0))),\n             min(\n               sd_box(fract((ray_pos + 2.5) / 5.0) * 5.0 - 2.5, vec3(0.25, 4.0, 0.25)),\n               sd_box(fract((ray_pos + 2.5) / 5.0) * 5.0 - 2.5, vec3(4.0, 0.25, 0.25))));\n}\n\n\nvec3 scene_normal(vec3 p, vec3 ray_origin)\n{\n  const float h = 0.01;\n  const vec2 k = vec2(1.0, -1.0);\n  return normalize(k.xyy * scene(p + k.xyy * h, ray_origin) + \n                   k.yyx * scene(p + k.yyx * h, ray_origin) + \n                   k.yxy * scene(p + k.yxy * h, ray_origin) + \n                   k.xxx * scene(p + k.xxx * h, ray_origin));\n}\n\n\nvec3 pal(in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d) {\n  return a + b * cos(6.28318 * (c * t + d));\n}\n\n\nvec3 encodeSRGB(vec3 linearRGB)\n{\n    vec3 a = 12.92 * linearRGB;\n    vec3 b = 1.055 * pow(linearRGB, vec3(1.0 / 2.4)) - 0.055;\n    vec3 c = step(vec3(0.0031308), linearRGB);\n    return mix(a, b, c);\n}\n\n\nvoid mainImage(out vec4 frag_color, in vec2 frag_coord) {\n  vec3 ray_dir = vec3(frag_coord / iResolution.xy * 2.0 - 1.0, -0.25);\n  ray_dir.x *= iResolution.x / iResolution.y;\n  ray_dir = normalize(ray_dir);\n\n  vec3 ray_pos = vec3(cos(iTime) * 5.0 - 2.5, 2.5, 10.0 - 10.0 * iTime);\n  vec3 ray_origin = ray_pos;\n  int max_iterations = 64;\n  float d = 99999999.999999999999;\n\n  for (int max_iterations = 0; max_iterations < 64; ++max_iterations) {\n    d = scene(ray_pos, ray_origin);\n    \n    if (d < 0.0001) {\n      break;\n    }\n\n    ray_pos += d * ray_dir;\n  }\n\n  // Output to screen\n  vec3 n = scene_normal(ray_pos, ray_origin);\n  float dist = clamp(abs(5.0 / distance(ray_pos, ray_origin)), 0.0, 1.0);\n  vec3 col = pal(dist - iTime, vec3(0.8,0.5,0.4),vec3(0.2,0.4,0.2),vec3(2.0,1.0,1.0),vec3(0.0,0.25,0.25) );\n  \n  frag_color = vec4(mix(vec3(col * -dot(n, ray_dir)), vec3(0.0), 1.0 - dist), 0.0);\n  \n  frag_color = vec4(encodeSRGB(frag_color.rgb), 0.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/fsSGzK.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "fssSD8", "name": "Menger_sponge_ifs", "author": "kinakomoti", "description": "I made this for IFS practice.  \n", "tags": ["fractal"], "likes": 4, "viewed": 58, "date": "1618674446", "time_retrieved": "2024-06-20T20:37:19.268130", "image_code": "const float pi = acos(-1.0);\nconst float pi2 = pi * 2.;\nconst vec3 lightray = vec3(1.);\n\nvec3 alpha = vec3(3.4,5.0,8.0);\nmat2 rot(float a)\n{\n    float s = sin(a), c = cos(a);\n    return mat2(c, s, -s, c);\n}\nmat3 camera(vec3 ro, vec3 ta)\n{\n    vec3 up = vec3(0, 1, 0);\n    vec3 cw = normalize(ta - ro);\n    vec3 cu = normalize(cross(cw, up));\n    vec3 cv = normalize(cross(cu, cw));\n    return mat3(cu, cv, cw);\n}\nvec2 pmod(vec2 p, float r)\n{\n    float a = atan(p.x, p.y) + pi / r;\n    // \"+ pi / r\" means shortcut of \"+ ((pi2 / r) * 0.5)\".\n    // so we want to get half angles of circle splitted by r.\n\n    float n = pi2 / r;\n    a = floor(a / n) * n;\n    // floor(a / n) means calculating ID.\n\n    return p * rot(-a);\n}\nfloat dMenger(vec3 z0,vec3 offset, float scale){\n    vec4 z = vec4(z0,1.0);\n    z.xyz = mod(z.xyz,alpha.y) - alpha.y/2.0 ;\n    z.z = mod(z.z,4.0) - 0.2;\n    z.xy = pmod(z.xy,alpha.z);\n    for(int n = 0; n < 4; n ++){\n        z = abs(z);\n\n        if(z.x < z.y) z.xy = z.yx;\n        if(z.x < z.z) z.xz = z.zx;\n        if(z.y < z.z) z.yz = z.zy;\n\n        z *= scale;\n        z.xyz -= offset * (scale - 1.0);\n        if(z.z < -0.5 * offset.z * (scale - 1.0)) z.z += offset.z * (scale -1.0);\n    }\n    return (length(max(abs(z.xyz)-vec3(1.0,1.0,1.0),0.0)) - 0.05) / z.w;\n}\n\nvec3 normal(vec3 p,vec3 offset,float scale)\n{\n    vec2 e = vec2(0.0001, 0.0);\n    float d = dMenger(p,offset,scale);\n    vec3 n = d - vec3(\n        dMenger(p - e.xyy,offset,scale),\n        dMenger(p - e.yxy,offset,scale),\n        dMenger(p - e.yyx,offset,scale));\n    return normalize(n);\n}\n\nvoid mainImage(out vec4 fragColor,in vec2 fragCoord)\n{\n    vec2 uv = (fragCoord.xy * 2.0 - iResolution.xy)/iResolution.y;\n\n\tvec3 col = vec3(0);\n\n    float dist = 5.0;\n    vec3 ro = vec3(2.5, 2.5, iTime);\n    vec3 ta = vec3(0.,0.,1.0) + ro;\n    \n    vec3 ray = camera(ro, ta) * normalize(vec3(uv, 1.8));\n    \n    vec3 p = ro;\n    float d = 0., t = 0.;\n    vec3 offset = vec3(4.,4.,1.5);\n    offset.x = offset.x + 1.13 * sin(iTime * 0.54) + 4.;\n    float scale = alpha.x;\n    float alpha = 0.;\n    for (int i = 0; i < 64; i++)\n    {\n        d = dMenger(p,offset,scale);\n        if (d < 0.01) break;\n        p += ray * d;\n        alpha += d;\n    }\n    \n    if (d < 0.01)\n    {\n        vec3 n =  4.0 * vec3(1.0) / alpha;\n        col = n;\n    }\n    else\n    {\n        col = vec3(0.);\n    }\n    \n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/fssSD8.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "fssSDB", "name": "a journey in precision error", "author": "FabriceNeyret2", "description": "- precision error making difference between 2 equivalent formula :-)\n- try uncomment line 17:  error in ab-ab is way more disturbing :-D", "tags": ["glsl", "precision", "bug"], "likes": 11, "viewed": 200, "date": "1619165415", "time_retrieved": "2024-06-20T20:37:19.268130", "image_code": "// inspired from https://shadertoy.com/view/NdlSDB\n// acid test simplification of https://shadertoy.com/view/WlyBR3\n\nvoid mainImage( out vec4 O, vec2 U )\n{\n    U -= .5 + iResolution.xy/2.;\n    \n    float t = mod(iTime,10.);\n                                             // just alternates zoom and  translate in random dir \n    if ( t < 5. ) U += floor(30.*t) * sign( cos( 6.28*fract(1e4*sin(1e3*floor(iTime/10.))) +vec2(0,11) ));\n       else       U *= exp(-.1*floor(30.*(t-5.)));\n    \n    U *= .01;\n    float a = U.x , b = U.y;   \n     \n    O = vec4( abs( (1.+a)*(1.+b)-(1.+a+b) - a*b ) < 1e-10 );  // (1.+a)*(1.+b)-(1.+a+b) = a*b, with precision error\n // O = vec4( abs( a*b - a*b ) < 1e-10 );    // this one is way more disturbing \n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/fssSDB.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "fssSRN", "name": "Some hexagon grid", "author": "Krafpy", "description": "Simple 2D hexagon tiling inspired from https://www.shadertoy.com/view/Xljczw", "tags": ["2d", "grid", "sdf", "hexagon"], "likes": 7, "viewed": 110, "date": "1618339494", "time_retrieved": "2024-06-20T20:37:19.268130", "image_code": "const vec2 s = vec2(1., 1.7320508);\n\nfloat hexSDF(vec2 p){\n    p = abs(p);\n    return max(dot(p, s * 0.5), p.x);\n}\n\nvec4 hexTiling(vec2 p){ \n    vec4 centers = round(vec4(p, p - vec2(0.5, 1.)) / s.xyxy);\n    vec4 offsets = vec4(p - centers.xy * s, p - (centers.zw + 0.5) * s);\n    \n    vec2 oxy = offsets.xy;\n    vec2 ozw = offsets.zw;\n    \n    //return dot(oxy, oxy) > dot(ozw, ozw) ? vec4(ozw, centers.zw * s) : vec4(oxy, centers.xy * s);\n    \n    // branchless version of the above ternary operator\n    float comp = step(0., dot(oxy, oxy) - dot(ozw, ozw));\n    return vec4(ozw, centers.zw * s) * comp + vec4(oxy, centers.xy * s) * (1.-comp);\n}\n\nfloat hash(vec2 p){\n    return fract(sin(dot(p,vec2(12.9898,78.233)))*43758.5453123);\n}\n\nfloat clamp01(float x){\n    return clamp(x, 0., 1.);\n}\n\nmat2 rot(float a){\n    float c = cos(a);\n    float s = sin(a);\n    return mat2(c,-s,s,c);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    uv -= 0.5;\n    uv.x *= iResolution.x/iResolution.y;\n\n    vec3 col = vec3(0.);\n    \n    vec4 h = hexTiling(uv*rot(sin(iTime*0.2)*0.5)*5. + iTime*0.3);\n    float d = hexSDF(h.xy);\n    \n    float rand = hash(h.wz);\n    \n    float w = 6.283*12.;\n    float i = clamp01(sin(d*w)+0.8);\n    float t = mod(floor(iTime*10.+rand*123.475), 6.);\n    float clear = step(0.5, rand);\n    float unc = 1. - clear;\n    float q = step(0.076*t, d) * step(d, 0.076*(t+1.)) * unc;\n    \n    col = vec3(1.,0.5,0.5);\n    float shad = step(0., dot(h.xy, vec2(0.5, 0.8660254))) * clear;\n    \n    vec3 stripes = mix(vec3(1.,0.,0.), vec3(0.,0.2,1.), rand);\n    col = stripes * q + col * (1.-q) * (2.*unc*d+1.-unc-d);\n    col *= i;\n    \n    float glow = step(0.9, rand) * (clear > 0. ? 1. : 0.);\n    col *= shad > 0. ? vec3(0.5,0.6,0.7) : vec3(1.);\n    \n    float g = clamp01(pow(abs(sin(iTime)), 12.)+0.1);\n    if(glow > 0.) col = mix(col, col + vec3(0.6, 0.1, 0.29), g);\n    \n    float k = clear * 0.08;\n    col *= 1.-pow(abs(d+k)+0.5, 12.);\n\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/fssSRN.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "fssSW4", "name": "Fork 2015/12/12 gusandr 611", "author": "gusandr", "description": "Experimenting with refraction â€” still some room for improving accuracy/aesthetics but happy with it so far :)", "tags": ["grid", "sdf", "refraction", "color", "refract"], "likes": 0, "viewed": 40, "date": "1618651902", "time_retrieved": "2024-06-20T20:37:20.886456", "image_code": "#define GLSLIFY 1\n\nvec2 mapRefract(vec3 p);\nvec2 mapSolid(vec3 p);\n\nvec2 calcRayIntersection_3975550108(vec3 rayOrigin, vec3 rayDir, float maxd, float precis) {\n  float latest = precis * 2.0;\n  float dist   = +0.0;\n  float type   = -1.0;\n  vec2  res    = vec2(-1.0, -1.0);\n\n  for (int i = 0; i < 50; i++) {\n    if (latest < precis || dist > maxd) break;\n\n    vec2 result = mapRefract(rayOrigin + rayDir * dist);\n\n    latest = result.x;\n    type   = result.y;\n    dist  += latest;\n  }\n\n  if (dist < maxd) {\n    res = vec2(dist, type);\n  }\n\n  return res;\n}\n\nvec2 calcRayIntersection_3975550108(vec3 rayOrigin, vec3 rayDir) {\n  return calcRayIntersection_3975550108(rayOrigin, rayDir, 20.0, 0.001);\n}\n\nvec2 calcRayIntersection_766934105(vec3 rayOrigin, vec3 rayDir, float maxd, float precis) {\n  float latest = precis * 2.0;\n  float dist   = +0.0;\n  float type   = -1.0;\n  vec2  res    = vec2(-1.0, -1.0);\n\n  for (int i = 0; i < 60; i++) {\n    if (latest < precis || dist > maxd) break;\n\n    vec2 result = mapSolid(rayOrigin + rayDir * dist);\n\n    latest = result.x;\n    type   = result.y;\n    dist  += latest;\n  }\n\n  if (dist < maxd) {\n    res = vec2(dist, type);\n  }\n\n  return res;\n}\n\nvec2 calcRayIntersection_766934105(vec3 rayOrigin, vec3 rayDir) {\n  return calcRayIntersection_766934105(rayOrigin, rayDir, 20.0, 0.001);\n}\n\nvec3 calcNormal_3606979787(vec3 pos, float eps) {\n  const vec3 v1 = vec3( 1.0,-1.0,-1.0);\n  const vec3 v2 = vec3(-1.0,-1.0, 1.0);\n  const vec3 v3 = vec3(-1.0, 1.0,-1.0);\n  const vec3 v4 = vec3( 1.0, 1.0, 1.0);\n\n  return normalize( v1 * mapRefract( pos + v1*eps ).x +\n                    v2 * mapRefract( pos + v2*eps ).x +\n                    v3 * mapRefract( pos + v3*eps ).x +\n                    v4 * mapRefract( pos + v4*eps ).x );\n}\n\nvec3 calcNormal_3606979787(vec3 pos) {\n  return calcNormal_3606979787(pos, 0.002);\n}\n\nvec3 calcNormal_1245821463(vec3 pos, float eps) {\n  const vec3 v1 = vec3( 1.0,-1.0,-1.0);\n  const vec3 v2 = vec3(-1.0,-1.0, 1.0);\n  const vec3 v3 = vec3(-1.0, 1.0,-1.0);\n  const vec3 v4 = vec3( 1.0, 1.0, 1.0);\n\n  return normalize( v1 * mapSolid( pos + v1*eps ).x +\n                    v2 * mapSolid( pos + v2*eps ).x +\n                    v3 * mapSolid( pos + v3*eps ).x +\n                    v4 * mapSolid( pos + v4*eps ).x );\n}\n\nvec3 calcNormal_1245821463(vec3 pos) {\n  return calcNormal_1245821463(pos, 0.002);\n}\n\nfloat beckmannDistribution_2315452051(float x, float roughness) {\n  float NdotH = max(x, 0.0001);\n  float cos2Alpha = NdotH * NdotH;\n  float tan2Alpha = (cos2Alpha - 1.0) / cos2Alpha;\n  float roughness2 = roughness * roughness;\n  float denom = 3.141592653589793 * roughness2 * cos2Alpha * cos2Alpha;\n  return exp(tan2Alpha / roughness2) / denom;\n}\n\nfloat cookTorranceSpecular_1460171947(\n  vec3 lightDirection,\n  vec3 viewDirection,\n  vec3 surfaceNormal,\n  float roughness,\n  float fresnel) {\n\n  float VdotN = max(dot(viewDirection, surfaceNormal), 0.0);\n  float LdotN = max(dot(lightDirection, surfaceNormal), 0.0);\n\n  //Half angle vector\n  vec3 H = normalize(lightDirection + viewDirection);\n\n  //Geometric term\n  float NdotH = max(dot(surfaceNormal, H), 0.0);\n  float VdotH = max(dot(viewDirection, H), 0.000001);\n  float LdotH = max(dot(lightDirection, H), 0.000001);\n  float G1 = (2.0 * NdotH * VdotN) / VdotH;\n  float G2 = (2.0 * NdotH * LdotN) / LdotH;\n  float G = min(1.0, min(G1, G2));\n\n  //Distribution term\n  float D = beckmannDistribution_2315452051(NdotH, roughness);\n\n  //Fresnel term\n  float F = pow(1.0 - VdotN, fresnel);\n\n  //Multiply terms and done\n  return  G * F * D / max(3.14159265 * VdotN, 0.000001);\n}\n\nvec2 squareFrame_1062606552(vec2 screenSize) {\n  vec2 position = 2.0 * (gl_FragCoord.xy / screenSize.xy) - 1.0;\n  position.x *= screenSize.x / screenSize.y;\n  return position;\n}\n\nvec2 squareFrame_1062606552(vec2 screenSize, vec2 coord) {\n  vec2 position = 2.0 * (coord.xy / screenSize.xy) - 1.0;\n  position.x *= screenSize.x / screenSize.y;\n  return position;\n}\n\nmat3 calcLookAtMatrix_1535977339(vec3 origin, vec3 target, float roll) {\n  vec3 rr = vec3(sin(roll), cos(roll), 0.0);\n  vec3 ww = normalize(target - origin);\n  vec3 uu = normalize(cross(ww, rr));\n  vec3 vv = normalize(cross(uu, ww));\n\n  return mat3(uu, vv, ww);\n}\n\nvec3 getRay_870892966(mat3 camMat, vec2 screenPos, float lensLength) {\n  return normalize(camMat * vec3(screenPos, lensLength));\n}\n\nvec3 getRay_870892966(vec3 origin, vec3 target, vec2 screenPos, float lensLength) {\n  mat3 camMat = calcLookAtMatrix_1535977339(origin, target, 0.0);\n  return getRay_870892966(camMat, screenPos, lensLength);\n}\n\nvoid orbitCamera_421267681(\n  in float camAngle,\n  in float camHeight,\n  in float camDistance,\n  in vec2 screenResolution,\n  out vec3 rayOrigin,\n  out vec3 rayDirection,\n  in vec2 coord\n) {\n  vec2 screenPos = squareFrame_1062606552(screenResolution, coord);\n  vec3 rayTarget = vec3(0.0);\n\n  rayOrigin = vec3(\n    camDistance * sin(camAngle),\n    camHeight,\n    camDistance * cos(camAngle)\n  );\n\n  rayDirection = getRay_870892966(rayOrigin, rayTarget, screenPos, 2.0);\n}\n\n// Originally sourced from:\n// http://iquilezles.org/www/articles/distfunctions/distfunctions.htm\n\nfloat sdBox_1117569599(vec3 position, vec3 dimensions) {\n  vec3 d = abs(position) - dimensions;\n\n  return min(max(d.x, max(d.y,d.z)), 0.0) + length(max(d, 0.0));\n}\n\nhighp float random_2281831123(vec2 co)\n{\n    highp float a = 12.9898;\n    highp float b = 78.233;\n    highp float c = 43758.5453;\n    highp float dt= dot(co.xy ,vec2(a,b));\n    highp float sn= mod(dt,3.14);\n    return fract(sin(sn) * c);\n}\n\nfloat fogFactorExp2_529295689(\n  const float dist,\n  const float density\n) {\n  const float LOG2 = -1.442695;\n  float d = density * dist;\n  return 1.0 - clamp(exp2(d * d * LOG2), 0.0, 1.0);\n}\n\nfloat intersectPlane(vec3 ro, vec3 rd, vec3 nor, float dist) {\n  float denom = dot(rd, nor);\n  float t = -(dot(ro, nor) + dist) / denom;\n\n  return t;\n}\n\nvec3 n4 = vec3(0.577,0.577,0.577);\nvec3 n5 = vec3(-0.577,0.577,0.577);\nvec3 n6 = vec3(0.577,-0.577,0.577);\nvec3 n7 = vec3(0.577,0.577,-0.577);\nvec3 n8 = vec3(0.000,0.357,0.934);\nvec3 n9 = vec3(0.000,-0.357,0.934);\nvec3 n10 = vec3(0.934,0.000,0.357);\nvec3 n11 = vec3(-0.934,0.000,0.357);\nvec3 n12 = vec3(0.357,0.934,0.000);\nvec3 n13 = vec3(-0.357,0.934,0.000);\n\nfloat icosahedral(vec3 p, float r1) {\n    float s = 1.8;\n    p = abs(p);\n    float m = p.x + p.y + p.z - s;\n    vec3 r = 3.0*p - m;\n    \n\tvec3 q;\n         if( r.x < 0.0 ) q = p.xyz;\n    else if( r.y < 0.0 ) q = p.yzx;\n    else if( r.z < 0.0 ) q = p.zxy;\n    else return m*0.57735027;\n    float k = clamp(0.5*(q.z-q.y+s),0.0,s); \n    return length(vec3(q.x,q.y-s+k,q.z-k));   \n}\n\nvec2 rotate2D(vec2 p, float a) {\n  return p * mat2(cos(a), -sin(a), sin(a),  cos(a));\n}\n\nvec2 mapRefract(vec3 p) {\n  float d  = icosahedral(p, 1.0);\n  float id = 0.0;\n\n  return vec2(d, id);\n}\n\nvec2 mapSolid(vec3 p) {\n  p.xz = rotate2D(p.xz, iTime * 1.25);\n  p.yx = rotate2D(p.yx, iTime * 1.85);\n  p.y += sin(iTime) * 0.25;\n  p.x += cos(iTime) * 0.25;\n\n  float d = length(p) - 0.25;\n  float id = 1.0;\n  float pulse = pow(sin(iTime * 2.) * 0.5 + 0.5, 9.0) * 2.;\n\n  d = mix(d, sdBox_1117569599(p, vec3(0.175)), pulse);\n\n  return vec2(d, id);\n}\n\n// Source: http://www.iquilezles.org/www/articles/palettes/palettes.htm\nvec3 palette( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d ) {\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\nvec3 bg(vec3 ro, vec3 rd) {\n  vec3 col = 0.1 + (\n    palette(clamp((random_2281831123(rd.xz + sin(iTime * 0.1)) * 0.5 + 0.5) * 0.035 - rd.y * 0.5 + 0.35, -1.0, 1.0)\n      , vec3(0.5, 0.45, 0.55)\n      , vec3(0.5, 0.5, 0.5)\n      , vec3(1.05, 1.0, 1.0)\n      , vec3(0.275, 0.2, 0.19)\n    )\n  );\n\n  float t = intersectPlane(ro, rd, vec3(0, 1, 0), 4.);\n\n  if (t > 0.0) {\n    vec3 p = ro + rd * t;\n    float g = (1.0 - pow(abs(sin(p.x) * cos(p.z)), 0.25));\n\n    col += (1.0 - fogFactorExp2_529295689(t, 0.04)) * g * vec3(5, 4, 2) * 0.075;\n  }\n\n  return col;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  vec3 ro, rd;\n\n  vec2  uv       = squareFrame_1062606552(iResolution.xy, fragCoord);\n  float dist     = 4.5;\n  float rotation = iMouse.z > 0.0\n    ? 6. * iMouse.x / iResolution.x\n    : iTime * 0.45;\n  float height = iMouse.z > 0.0\n    ? 5. * (iMouse.y / iResolution.y * 2.0 - 1.0)\n    : -0.2;\n    \n  orbitCamera_421267681(rotation, height, dist, iResolution.xy, ro, rd, fragCoord);\n\n  vec3 color = bg(ro, rd);\n  vec2 t = calcRayIntersection_3975550108(ro, rd);\n  if (t.x > -0.5) {\n    vec3 pos = ro + rd * t.x;\n    vec3 nor = calcNormal_3606979787(pos);\n    vec3 ldir1 = normalize(vec3(0.8, 1, 0));\n    vec3 ldir2 = normalize(vec3(-0.4, -1.3, 0));\n    vec3 lcol1 = vec3(0.6, 0.5, 1.1);\n    vec3 lcol2 = vec3(1.4, 0.9, 0.8) * 0.7;\n\n    vec3 ref = refract(rd, nor, 0.97);\n    vec2 u = calcRayIntersection_766934105(ro + ref * 0.1, ref);\n    if (u.x > -0.5) {\n      vec3 pos2 = ro + ref * u.x;\n      vec3 nor2 = calcNormal_1245821463(pos2);\n      float spec = cookTorranceSpecular_1460171947(ldir1, -ref, nor2, 0.6, 0.95) * 2.;\n      float diff1 = 0.05 + max(0., dot(ldir1, nor2));\n      float diff2 = max(0., dot(ldir2, nor2));\n\n      color = spec + (diff1 * lcol1 + diff2 * lcol2);\n    } else {\n      color = bg(ro + ref * 0.1, ref) * 1.1;\n    }\n\n    color += color * cookTorranceSpecular_1460171947(ldir1, -rd, nor, 0.2, 0.9) * 2.;\n    color += 0.05;\n  }\n\n  float vignette = 1.0 - max(0.0, dot(uv * 0.155, uv));\n\n  color.r = smoothstep(0.05, 0.995, color.r);\n  color.b = smoothstep(-0.05, 0.95, color.b);\n  color.g = smoothstep(-0.1, 0.95, color.g);\n  color.b *= vignette;\n\n  fragColor.rgb = color;\n  fragColor.a   = clamp(t.x, 0.5, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/fssSW4.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "fssXD4", "name": "Audio pulsar", "author": "atutahi", "description": "radial audio pulse thingy", "tags": ["audioreactive"], "likes": 4, "viewed": 88, "date": "1618680567", "time_retrieved": "2024-06-20T20:37:21.292665", "image_code": "float Catmull_Rom(float x, float v0,float v1, float v2,float v3) \n{\n\tfloat c2 = -.5 * v0\t+ 0.5*v2;\n\tfloat c3 = v0\t\t+ -2.5*v1 + 2.0*v2 + -.5*v3;\n\tfloat c4 = -.5 * v0\t+ 1.5*v1 + -1.5*v2 + 0.5*v3;\n\treturn(((c4 * x + c3) * x + c2) * x + v1);\n}\n\nfloat sampleFFT(float fftCoord)\n{\n    float atten = smoothstep(0.0, 0.05, 1.0 - fftCoord) * smoothstep(0.0, 0.05, fftCoord); \n    return atten * texture( iChannel0, vec2(fftCoord,0.25) ).x;\n}\n\nvec2 opRep( in vec2 p, in vec2 c)\n{\n    return mod(p+0.5*c,c)-0.5*c;\n}\n\n#define PI 3.14159\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 col = vec3(0.0);\n    \n    // create pixel coordinates\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    uv = uv * 2. - 1.;\n    uv.x /= iResolution.y / iResolution.x;\n    uv += 0.3 * vec2(sin(-iTime * 0.3), cos(iTime * 0.5));\n    // second texture row is the sound wave\n    \n\tfloat wave = texture( iChannel0, vec2(0.5,0.75) ).x;\n    \n    float angle = atan(uv.y, uv.x);  // atan2\n    vec2 range = vec2(-PI, PI);  // The range of atan2 is [-pi / 1; pi / 1]\n    float theta = smoothstep(range[0], range[1], angle);  // Normalize the range of atan to [0;1]\n    theta = mod(theta + iTime * 0.05, 1.0);\n    \n    float ro = length(uv);\n    ro *= 3.0 - 0.2 * clamp(0.0, 1.0, (pow(wave, 0.4)));\n    uv = vec2(theta, ro);\n    \n    uv.y -= iTime * 0.65;\n    uv.y = opRep(uv, vec2(1.5)).y;\n        \n    // Small perturbation of base circle\n    uv.y += 0.005 * (sin(-iTime * 1.8 + theta * 8.0 * PI) + sin(iTime * 4.0 + theta * 32.0 * PI));\n        \n    float fftFreq = wave * clamp(0.0, 1.0, ro * 1.0) * 2.0 + 64.0;//10.0 + wave * 128.0;\n    float fftX = floor(uv.x * fftFreq);\n    float fftCoord1 = clamp(0.0, 1.0, fftX / fftFreq);\n\tfloat fft1 = sampleFFT(fftCoord1);\n    \n    float fftCoord = (fftX - 1.0) / fftFreq;\n    float fft = sampleFFT(fftCoord);\n    \n    float fftCoord2 = (fftX + 1.0) / fftFreq;\n    float fft2 = sampleFFT(fftCoord2);       \n    \n    float fftCoord3 = (fftX + 2.0) / fftFreq;\n    float fft3 = sampleFFT(fftCoord3);       \n    \n    float f = 0.6 * Catmull_Rom(fract(uv.x * fftFreq), fft, fft1, fft2, fft3); \n\n    float s = (0.01 + 1.6 * f) / abs(f-uv.y);\n    s = pow(s, 2.0 - wave * 0.6 - ro * 0.45 * (0.8 + 0.4 * wave));\n    s *= smoothstep(0.8, 0.0, uv.y);\n    s *= smoothstep(0.8, 0.0, -uv.y);\n    \n\tcol += s;\n    col += 1.0 - smoothstep(0.0, 0.1, ro);\n    //col += fft - uv.y;\n    col *= vec3(0.1 + f * 1.5, 0.2,1.0 - f * 1.0);\n   \n\t// output final color\n\tfragColor = vec4(col, 1.0);\n}", "image_inputs": [{"id": "MlfSRS", "previewfilepath": "https://soundcloud.com/pnl_music/blanka", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0, "src": "https://soundcloud.com/pnl_music/blanka", "ctype": "musicstream"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/fssXD4.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "fssXDM", "name": "SpYralsBoxes", "author": "lechuga", "description": "Hecho con bonzomatic un sábado en la tarde,", "tags": ["01010010", "01001001", "01000011", "01001011"], "likes": 5, "viewed": 76, "date": "1618704466", "time_retrieved": "2024-06-20T20:37:21.868319", "image_code": "/**\n* EstoLoHizoLechuga\n* \n* Practicing since cookie jam,\n* Trying to learn from here: https://www.shadertoy.com/view/fsXSWN\n*\n* This is NOT a shader from the live, \n* but anyway the live is here:\n* https://www.youtube.com/watch?v=UIGlDjnuUIY\n*\n*\n* AHoRa DiLo SiN IoRar\n* :'D\n*/\n#define TWO_D\n#define rot(a)mat2(cos(a),sin(a),-sin(a),cos(a))\nfloat t;\nfloat sb(vec3 p,vec3 s){p=abs(p)-s;return max(max(p.z,p.y),p.x);}\n#define smin(a,b,k) min(a,b)-pow(max(k-abs(a-b),0.)/k,k)*k*(1.0/6.0)\nfloat h(vec3 x){return fract(sin(dot(x,x.zyx*324.234))*56.546);}\nfloat g1,g2,g3,g4;\nvoid l(inout float g,float d){g+=1./(1.+d*d*d);}\n#define pi 3.14154353456\n#define h1(x) fract(sin(x*256.)*724.24)\nfloat c(float t,float s){\n  t/=s*pi;\n  return mix(h1(floor(t)), h1(floor(t+1.)), pow(smoothstep(0., 1.,fract(t)),20.));\n}\nfloat m(vec3 p){float d;\n  p.xz*=rot(sin(t)*2.);\n  float gr= -p.y+2.;\n  l(g2,gr);\n  vec3 p2=p;\n  p2.xz=abs(p2.xz)-3.;\n  float id=h(floor(p2/90.+.5));\n  p.y+=mod(t*15.+id*id, 50.);\n  vec3 p1=p;\n  p1.xz=abs(p1.xz)-5.;\n  p1.xz*=rot(3.*.7+p1.y*.2);\n  for(float i=5.;i>=0.;i--){\n    p1.xz*=rot(t*.25*i);\n    p1.x=abs(p1.x)-.5-sin(i+t)*.5;\n  }\n  float b=sb(p1,vec3(1., 500., .05))*.66;\n  l(g3,b);\n  p2=(fract(p2/20.+.5)-.5)*20.;\n  vec3 rr=vec3(.65*id,sin(t)*abs(p2.y)+5.,.55*id);\n  float bb=sb(p2,rr);\n  l(g4,bb);\n  d=smin(gr,b,10.);\n  d=min(d,bb);\n  vec3 p5=p;\n  p5.y=(fract(p.y/10.+.5)-.5)*10.;\n \n  float egg=mix(length(p5)-3.6*sin(p5.x*.645+t)*sin(p5.z*.735+t)*sin(p5.x*.66+t)*.5-3.5,length(p5.zx)-1., .5);\n  d=smin(d,egg,10.);\n  g1+=.1/(.1+egg*egg);\n  return d;\n}\nvec3 nm(vec3 p){\n  vec2 e=vec2(.01, 0);\n  return m(p)-normalize(vec3(m(p-e.xyy),m(p-e.yxy),m(p-e.yyx)));\n}\nvoid ao(inout vec3 col,vec3 n, vec3 p,float i){\n  for(float ii=0.;ii<20.;ii++){\n    float o=clamp(m(p*n*i)/i, 0., 1.);\n    col*=o<0.? 1.:o;\n    col+=.1/(.5+vec3(ii, .234, h(vec3(0.3565, 3.42, 23.))));\n  }\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = vec2(fragCoord.x / iResolution.x, fragCoord.y / iResolution.y);\n\tuv -= 0.5;\n\tuv /= vec2(iResolution.y / iResolution.x, 1);\n    t=mod(iTime, 100.);\n  \n  float fov=1.15+length(sin(uv.y+t)*.5)+.77-length(sin(abs(uv.x+t)-.5)*2.);\n  vec3 s=vec3(0.00001,-5.0001,-20.),r=normalize(vec3(-uv,fov));\n  vec3 p=s;\n  float i,d,MAX=100.;\n  for(i=MAX;i>=0.;i--)if(d=m(p),p+=d*r,abs(d)<.0001) break;\n  vec3 col=vec3(0.);\n  col+=i/MAX;\n  vec3 n=nm(p);\n  \n  \n  col+=dot(n,normalize(vec3(-1., -2., -3e3)));\n  \n  ao(col,n,p,i);\n  col+=g1*vec3(1., 1., 0.)*.05;\n  col+=g2*vec3(.034, 0., 0.234)*.07;\n  col+=g3*vec3(0.06, 0.256, 0.9)*.03;\n  col+=g4*vec3(0.5466,0.9,0.2)*.07;\n  \n  col=smoothstep(0., 1.,col);\n  col*=1.-max(length(p-s)/300.,0.);\n  float inv=0.;\n  #ifdef TWO_D\n  vec2 uv2=uv;\n  for(float ii=3.;ii>=0.;ii--)\n    uv2=(abs(uv-3.)-3.)-.5-sin(t)*.5+.45;\n  uv2*=rot(pow(c(t,40.),5.));\n  for(float i=5.;i>=0.;i--)\n    inv=mix(inv,1.-inv,step(length(uv2)-.5,i-fract(t*.5)));\n  col=mix(col,1.-col,1.-inv);\n  #endif\n\tfragColor = vec4(col,1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/fssXDM.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "fssXRl", "name": "Iridescent spirals", "author": "jarble", "description": "These warped and distorted spirals have some \"iridescent\" patterns.", "tags": ["fractal", "spiral"], "likes": 12, "viewed": 185, "date": "1619057185", "time_retrieved": "2024-06-20T20:37:21.868319", "image_code": "#define ITERS 12\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.0);\n    vec3 col=vec3(0.0),col_prev=vec3(0.0);\n    float t=0.0;\n    vec2 uv = (fragCoord*10.0-iResolution.xy)/iResolution.y/10.0;\n    uv.y += (iTime)/8.0;\n    for(int c=0;c<ITERS;c++){\n        float scale = 2.25;\n        float scale1 = 1.07;\n        float s1 = scale1*scale;\n        col_prev = col;\n        for(int i=0;i<ITERS;i++)\n        {\n            uv = fract(uv.yx/s1)*s1;\n            uv= fract(-uv-((vec2(uv.x/scale-uv.y/scale1,uv.y/scale-uv.x/scale1)/(scale))))/scale1;\n            uv.y /= -scale1;\n            \n            //scale1 -= (uv.x*(.005*fract(uv.x+iTime/2.)));\n            //make it dance!\n        }\n        col[2] = abs(fract(uv.y)-fract(uv.x));\n        col = ((col+col_prev.yzx))/2.0;\n\t}\n    fragColor = vec4(vec3(col*3.0),1.0);\n    \n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/fssXRl.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "fssXRs", "name": "-_-_-_-_groovy_-_-_-_-", "author": "Shellderr", "description": "groovy", "tags": ["groovy"], "likes": 0, "viewed": 37, "date": "1619074674", "time_retrieved": "2024-06-20T20:37:22.232034", "image_code": "\n#define res resolution\n#define ft float\n#define aaa 40.*(iMouse.y/iResolution.y)\n#define dd 0.009\n\nft rnd(vec2 v, ft t, ft m){\n    ft aa = 12.*sin(t*20.)+15.;\n    return fract(sin(aa*fract(t+m*dot(v+t,fract(v*79.17)))));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n\n    vec2 uv = fragCoord.xy/iResolution.y*.999;\n    uv *= .8;\n    ft t = iTime*.05;\n    ft m = 4.;\n \n    vec2 d1 = vec2(0.,dd);\n    vec2 d2 = vec2(dd, 0.);\n    vec2 d3 = vec2(dd);    \n    vec2 d4 = vec2(dd, -dd);\n    \n    \n    ft r = rnd(uv, fract(t), m);\n    r *= rnd(uv*.9, fract(t+5.), m);\n    \n    ft r1 = rnd((uv-d1), fract(t), m);\n    r1 *= rnd((uv-d1)*.9, fract(t+5.), m);\n    \n    ft r2 = rnd((uv+d1), fract(t), m);\n    r2 *= rnd((uv+d1)*.9, fract(t+5.), m);\n    \n    ft r3 = rnd((uv-d2), fract(t), m);\n    r3 *= rnd((uv-d2)*.9, fract(t+5.), m);\n    \n    ft r4 = rnd((uv+d2), fract(t), m);\n    r4 *= rnd((uv+d2)*.9, fract(t+5.), m);\n    \n    ft r5 = rnd((uv-d3), fract(t), m);\n    r5 *= rnd((uv-d3)*.9, fract(t+5.), m);\n    \n    ft r6 = rnd((uv+d3), fract(t), m);\n    r6 *= rnd((uv+d3)*.9, fract(t+5.), m);\n\n//    ft r7 = rnd((uv-d4), fract(t), m);\n//    r7 *= rnd((uv-d4)*.9, fract(t+5.), m);\n    \n//    ft r8 = rnd((uv+d4), fract(t), m);\n//    r8 *= rnd((uv+d4)*.9, fract(t+5.), m);\n    \n    vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n \n    ft f =  r+r1 + r2 + r3 + r4 + r5 + r6;\n    f *= .22;\n    vec3 c = f*6.28+vec3(3.,5.,4.);\n    c = cos(c+5.)*.5+.5;\n    fragColor = vec4( vec3(c*(.4+.6*col)), 1.0 );\n    fragColor.y *= .4;\n    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/fssXRs.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "fsSXzD", "name": "Min første shader", "author": "KreaAda", "description": "My very first shader.", "tags": ["firstattempt"], "likes": 0, "viewed": 122, "date": "1619769012", "time_retrieved": "2024-06-20T20:37:22.498832", "image_code": "float radius = 0.2;\n\nbool bjorn(vec2 center, vec2 pixel, float time){\n\n\n    center.y += abs(0.4* time);\n        \n    float xdist = (center.x - pixel.x) * (iResolution.x/iResolution.y);\n    float ydist = center.y - pixel.y;\n    \n    float dist = xdist*xdist + ydist*ydist;\n    \n    \n    return dist < (radius*radius);\n    \n} \n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Time varying pixel color\n    //iTime+\n//    vec3 col = 0.5 + 0.5*cos(xy.xxx+vec3(0,2,4));\n//    vec3 col = vec3(xy.x);\n\n\n        vec3 col = vec3(cos(iTime),0.75,abs(cos(log(iMouse.x))));\n        // Output to screen\n        fragColor = vec4(col,1.0);\n\n    if (uv.x == uv.y)\n       {\n           fragColor = vec4(.0,.0,.0,1.0);\n       }\n       \n       \n    if (bjorn(vec2(0.5, radius), uv, abs(sin(iTime)))){\n\n        fragColor = vec4(abs(sin(iTime)),.0,1.0,1.0);    \n        \n    }\n\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/fsSXzD.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "fssXzj", "name": "Molten Neon", "author": "Tater", "description": "Wanted to make something with reflections, I think it turned out ok.", "tags": ["raymarching", "sdf", "glow", "vaporwave", "relfections"], "likes": 10, "viewed": 304, "date": "1618904757", "time_retrieved": "2024-06-20T20:37:22.498832", "image_code": "#define MDIST 120.0\n#define STEPS 164.0\n#define rot(a) mat2(cos(a),sin(a),-sin(a),cos(a))\n#define sat(a) clamp(a,0.0,1.0)\n#define pi 3.141592\nvec3 col3 (vec3 col,float index){\n    if(index==1.0)col.rg=1.0-col.rg;\n    if(index==2.0)col.gb=1.0-col.gb;\n    return col;\n}\nfloat timeRemap2 (float t, float s1, float s2, float c){\n    return 0.5*((s1-s2)*sqrt(c*c+1.0)*asin((c*cos(pi*t))/ sqrt(c*c+1.0))+(s1+s2)*c*t*pi)/(c*pi);\n}\nfloat SU( float d1, float d2, float k ) {\n    float h = sat( 0.5 + 0.5*(d2-d1)/k);    \n    return mix( d2, d1, h ) - k*h*(1.0-h);   \n} \nfloat box( vec3 p, vec3 b ){\n    vec3 q = abs(p) - b;\n    return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0) -0.3;\n}\nvec3 glw = vec3(0);\nfloat map2(vec3 p){\n    float a = length(p-vec3(0,sin(iTime)*4.0,0))-1.5;\n    glw +=(0.01/(0.01+a*a))*vec3(0.867,0.000,0.259);\n    float b = box(p,vec3(0.6,15.5,0.5))*0.9;\n    a = min(a,b);\n    return a;\n}\nfloat map(vec3 p){\n    vec3 np = p;\n    float t = mod(iTime+7.2,200.0);\n    float anim = smoothstep(-.2,.2,sin(t*0.5));\n    \n    \n    float s1 = 8.5;\n    float s2 = 1.0;\n    t = timeRemap2(t/(2.0*pi),s1,s2,10.0);//amazing\n    \n    np.xy*=rot(mod(t,2.0*pi+pi)*anim*0.2);\n    \n    float modd = 55.0+anim*400.0;//Banish the extra versions when it expands\n    \n    //vec2 id = abs(floor((p.xz+modd/2.0)/modd));\n    \n    np.xz = mod(np.xz+0.5*modd,modd)-0.5*modd;\n    np = abs(np)-vec3(0,0,anim*30.0);\n    np.x = abs(np.x)-(20.0*anim);\n    \n    np*=1.0-anim*0.3;\n    \n    t = floor(t)+pow(fract(t),2.0-anim*1.0);\n    for(int i = 0; i< 5; i++){\n        np = abs(np)-vec3(1.5+4.5*anim);\n        np.xy*=rot(0.3+t*0.7*1.1);\n        np.zy*=rot(0.5+t*0.7*1.1);\n    }\n    \n    float a = map2(np);\n    float b = p.y+3.0;\n    a = SU(a,b,1.0);\n    \n    b = length(p-vec3(0,-4.5+anim*10.0,0))-9.0;\n    glw +=0.01/(0.01+b*b)*vec3(0.035,0.690,0.000);\n    \n    a = SU(a,b,1.0);\n    float cir = 35.0;\n    t=0.5*iTime;\n    \n    vec3 ro = vec3(cir*sin(t),4.0+sin(t),cir*cos(t));\n    float camHole = length(p-ro)-5.0;\n    a = max(-camHole*0.8,a);\n    \n    return a;\n}\n\nvec3 norm(vec3 p) {\n    vec2 off=vec2(0.01,0);\n    return normalize(map(p)-vec3(map(p-off.xyy),map(p-off.yxy),map(p-off.yyx)));\n}\n\nvoid mainImage( out vec4 fragColor, vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-0.5*iResolution.xy)/iResolution.y;\n    vec3 col = vec3(0);\n    float t = iTime*0.5;\n    float cir = 35.0;\n    vec3 ro = vec3(cir*sin(t),4.0+sin(t),cir*cos(t));\n    vec3 ro2 = ro;\n    vec3 look = vec3(0,0,0); float z = 0.7;\n    vec3 f = normalize(look-ro);\n    vec3 r = normalize(cross(vec3(0,1,0),f));\n    vec3 rd = f*z+uv.x*r+uv.y*cross(f,r);\n        \n    float dO = 0.0;\n    float shad = 1.0;\n    float bnc = 0.0;\n    float dist = 0.0;\n    float dO2 = 0.;\n    vec3 p = vec3(0);\n    for(float i = 0.0; i<STEPS; i++){\n        p = ro + rd * dO;\n        float d = map(p)*0.9;\n        dO += d;\n        dO2 +=d;\n        if(dO2>MDIST || d < 0.01) {\n            shad = float(i)/(STEPS);\n            if(bnc == 0.0)dist=dO;\n            if(bnc == 1.0)break;\n            ro += rd*dO;\n            vec3 sn = norm(ro);\n            rd = reflect(rd,sn);\n            ro +=  sn*0.1;\n            dO = 0.0;\n            i=0.0;\n            bnc++;\n        }\n    }\n    col = vec3(shad)*mix(vec3(0.082,0.941,0.902),vec3(0.557,0.067,1.000),sin(dO*0.01))*4.0;\n    \n    col = mix(col,\n    mix(vec3(0.000,0.318,0.910),vec3(0.141,0.114,0.514),clamp(uv.y*2.0,0.,1.))\n    ,sat(dist/MDIST)*sat(dist/MDIST));\n    col+=glw*0.11*(1.0-sat(dist/(MDIST)));\n    col=pow(col,vec3(0.75));\n    float index = floor(mod(t*0.7,3.0));\n    //col = col3(col,index); //Uncomment for color swaps\n    //col.rb*=rot(sin(t*0.25+pi)*0.5+0.4); //actually this one is better :)\n    fragColor = vec4(col,0.0);\n}\n\n", "image_inputs": [{"id": "4dXGR8", "previewfilepath": "/media/previz/buffer00.png", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/previz/buffer00.png", "ctype": "buffer"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/fssXzj.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "fssXzN", "name": "mandelbulb-by neozhaoliang", "author": "jorge2017a1", "description": "mandelbulb-by neozhaoliang", "tags": ["mandelbulbbyneozhaoliang"], "likes": 8, "viewed": 225, "date": "1618344282", "time_retrieved": "2024-06-20T20:37:23.432242", "image_code": "//by neozhaoliang\n//https://www.shadertoy.com/user/neozhaoliang\n\n#define AA                 1//2\n#define FOV_DIST           3.0\n#define BULB_ITERATIONS    7//8\n#define SPONGE_ITERATIONS  9\n#define MAX_TRACE_STEPS    200//200\n#define MIN_TRACE_DIST     0.01\n#define MAX_TRACE_DIST     10.0\n#define PRECISION          1e-4\n#define PI                 3.14159265358979323\n#define T                  (iTime * 0.1)\n\n// view to world transformation\nmat3 viewMatrix(vec3 camera, vec3 lookat, vec3 up)\n{\n    vec3 f = normalize(lookat - camera);\n    vec3 r = normalize(cross(f, up));\n    vec3 u = normalize(cross(r, f));\n    return mat3(r, u, -f);\n}\n\n// 2D rotatation\nvoid R(inout vec2 p, float a)\n{\n    p = cos(a) * p + sin(a) * vec2(p.y, -p.x);\n}\n\nfloat mandelbulb(vec3 p)\n{\n    p /= 1.192;\n    p.xyz = p.xzy;\n    vec3 z = p;\n    vec3 dz = vec3(0.0);\n    float dr = 1.0;\n    float power = 8.0;\n    float r, theta, phi;\n    for (int i = 0; i < BULB_ITERATIONS; i++)\n    {\n        r = length(z);\n        if (r > 2.0)\n            break;\n        float theta = atan(z.y / z.x);\n        float phi = asin(z.z / r);\n        dr = pow(r, power - 1.0) * power * dr + 1.0;\n        r = pow(r, power);\n        theta = theta * power;\n        phi = phi * power;\n        z = r * vec3(cos(theta) * cos(phi), cos(phi) * sin(theta), sin(phi)) + p;\n    }\n    return 0.5 * log(r) * r / dr;\n}\n\nfloat sdSponge(vec3 z)\n{\n    for(int i = 0; i < SPONGE_ITERATIONS; i++)\n    {\n        z = abs(z);\n        z.xy = (z.x < z.y) ? z.yx : z.xy;\n        z.xz = (z.x < z.z) ? z.zx : z.xz;\n        z.zy = (z.y < z.z) ? z.yz : z.zy;\t \n        z = z * 3.0 - 2.0;\n        z.z += (z.z < -1.0) ? 2.0 : 0.0;\n    }\n    z = abs(z) - vec3(1.0);\n    float dis = min(max(z.x, max(z.y, z.z)), 0.0) + length(max(z, 0.0)); \n    return dis * 0.6 * pow(3.0, -float(SPONGE_ITERATIONS)); \n}\n\nfloat DE(vec3 p)\n{\n    float d1 = mandelbulb(p);\n    float d2 = sdSponge(p);\n    return max(d1, d2);\n    \n}\n\nvec3 calcNormal(vec3 p)\n{\n    const vec2 e = vec2(0.001, 0.0);\n    return normalize(vec3(\n\t\t\t  DE(p + e.xyy) - DE(p - e.xyy),\n\t\t\t  DE(p + e.yxy) - DE(p - e.yxy),\n\t\t\t  DE(p + e.yyx) - DE(p - e.yyx)));\n}\n\nfloat trace(vec3 ro, vec3 rd)\n{\n    float t = MIN_TRACE_DIST;\n    float h;\n    for (int i = 0; i < MAX_TRACE_STEPS; i++)\n    {\n        h = DE(ro + rd * t);\n        if (h < PRECISION * t || t > MAX_TRACE_DIST)\n            return t;\n        t += h;\n    }\n    return -1.0;\n}\n\nfloat softShadow(vec3 ro, vec3 rd, float tmin, float tmax, float k)\n{\n    float res = 1.0;\n    float t = tmin;\n    for (int i = 0; i < 10; i++)\n    {\n        float h = DE(ro + rd * t);\n        res = min(res, k * h / t);\n        t += clamp(h, 0.01, 0.1);\n        if (h < 0.001 || t > tmax)\n            break;\n    }\n    return clamp(res, 0.0, 1.0);\n}\n\nfloat calcAO(vec3 p, vec3 n)\n{\n    float occ = 0.0;\n    float sca = 1.0;\n    for (int i = 0; i < 5; i++)\n    {\n        float h = 0.01 + 0.15 * float(i) / 4.0;\n        float d = DE(p + h * n);\n        occ += (h - d) * sca;\n        sca *= 0.9;\n    }\n    return clamp(1.0 - 3.0 * occ, 0.0, 1.0);\n}\n\nvec3 render(vec3 ro, vec3 rd, vec3 lig)\n{\n    vec3 background = vec3(0.08, 0.16, 0.32);\n    vec3 col = background;\n    float t = trace(ro, rd);\n    if (t >= 0.0)\n\t{\n        col = vec3(0.9);\n        vec3 pos = ro + rd * t;\n        vec3 nor = calcNormal(pos);\n        vec3 ref = reflect(rd, nor);\n\n        float occ = calcAO(pos, nor);\n        float amb = 0.3;\n        float dif = clamp(dot(nor, lig), 0.0, 1.0);\n        float fre = pow(clamp(1.0 + dot(nor, rd), 0.0, 1.0), 2.0);\n        float spe = pow(clamp(dot(ref, lig), 0.0, 1.0), 16.0);\n        dif *= softShadow(pos, lig, 0.02, 5.0, 16.0);\n\n        vec3 lin = vec3(0.3);\n        lin += 1.8 * dif * vec3(1.0, 0.8, 0.55);\n        lin += 2.0 * spe * vec3(1.0, 0.9, 0.7) * dif;\n        lin += 0.3 * amb * vec3(0.4, 0.6, 1.0) * occ;\n        lin += 0.25 * fre * vec3(1.0) * occ;\n\n        col *= lin;\n\n        float atten = 1.0 / (1.0 + t * t * 0.1);\n\t    col *= atten * occ;\n\t    col = mix(col, background, smoothstep(0.0, 0.95, t / MAX_TRACE_DIST));\n    }\n    return sqrt(col);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    vec3 tot = vec3(0.0);\n    for (int ii = 0; ii < AA; ii ++)\n\t{\n\t    for (int jj = 0; jj < AA; jj++)\n\t\t{\n\t\t    // map uv to (-1, 1) and adjust aspect ratio\n\t\t    vec2 offset = vec2(float(ii), float(jj)) / float(AA);\n\t\t    vec2 uv = (fragCoord.xy + offset) / iResolution.xy;\n\t\t    uv = 2.0 * uv - 1.0;\n\t\t    uv.x *= iResolution.x / iResolution.y;\n\t\t    vec3 camera = vec3(4.0) / (min(3.5, 1.0 + pow(2.0, T)));\n\t\t    vec3 lookat = vec3(0.0);\n\t\t    vec3 up = vec3(0.0, 1.0, 0.0);\n\t\t    // set camera\n\t\t    vec3 ro = camera;\n            R(ro.xz, T);\n\t\t    mat3 M = viewMatrix(ro, lookat, up);\n\t\t    // put screen at distance FOV_DISt in front of the camera\n\t\t    vec3 rd = M * normalize(vec3(uv, -FOV_DIST));\n            vec3 lig = normalize(vec3(1.0, 2.0, 1.0));\n\t\t    vec3 col = render(ro, rd, lig);\n\t\t    tot += col;\n\t\t}\n\t}\n    tot /= float(AA * AA);\n    fragColor = vec4(tot, 1.0);\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/fssXzN.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "fsXSWN", "name": "Atomic Energy", "author": "Tater", "description": "code is messy, I know. copy pasted from bonzomatic. \noriginally made during cookie collective live stream. ", "tags": ["raymarch", "glow"], "likes": 8, "viewed": 242, "date": "1618612962", "time_retrieved": "2024-06-20T20:37:23.432242", "image_code": "float donut(vec3 p, vec2 t){ return length(vec2(length(p.xz)-t.x,p.y))-t.y;}\n#define rot(a) mat2(cos(a),-sin(a),sin(a),cos(a))\n#define MAX_DIST 250.0\n#define STEP 128.0\nfloat g1 = 0.;\nvec2 Dist(vec3 p){\n  vec2 a = vec2(donut(p,vec2(1,0.5)),2.0);\n  vec2 b = vec2(length(p+vec3(0,1.0-abs(sin(iTime))*3.0,0))-0.5,1.0);\n  g1 += 0.01/(0.01+b.x*b.x);\n  b = (b.x < a.x) ? b:a;\n  return b;\n}\nvoid invert(inout float inv, float t, vec2 uv, float cap){\ninv = mix(inv,1.0-inv,step(sin(length(uv)*0.45-t)*0.5+0.6,cap));\n}\nvec2 Dist2(vec3 p){\n  float t= mod(iTime,200.0);\n  t = fract(t)*fract(t)+floor(t);\n  vec3 p2 = p;\n  \n  float modd = 42.0;\n  vec3 id = floor((p2+modd*0.5)/modd);\n  t+= id.x*2.0;\n  t+= id.z*2.0;\n  p2.yz*=rot(sin(t)*0.2);\n  p2.y +=sin(id.x+t)*12.0;\n  p2 = mod(p2+modd*0.5,modd)-modd*0.5;\n  p2.xy*=rot(t*(mod(abs(id.x),3.0)-1.0));\n  p2.zy*=rot(-t*0.5*(mod(abs(id.z),3.0)-1.0));\n  for(int i = 0; i < 4; i++){\n    p2 = abs(p2)-vec3(2,1,1);\n    p2.xy *=rot(0.5);\n    p2.zy *=rot(0.5+sin(t)*2.0);\n    p2.zx *=rot(0.5);\n  }\n  \n  return Dist(p2)*vec2(0.65,1.0);\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2 uv = (fragCoord-0.5*iResolution.xy)/iResolution.y;\n  float t = mod(iTime,200.0);\n  vec3 ro = vec3(t*3.0,0,-30);\n  vec3 rd = normalize(vec3(uv,1.05));\n  float dO = 0.0;\n  float shad = 0.0;\n  vec2 obj;\n  for(float i = 0.0; i <STEP; i++){\n    vec3 p = ro + rd*dO;\n    obj = Dist2(p);\n    dO += obj.x;\n    if(obj.x <0.001|| dO>MAX_DIST){\n      shad = i/STEP;\n      break;\n    }\n  }\n \n  vec3 col = vec3(0);\n \n  if(obj.y == 1.0){\n    shad= 1.0-shad;\n    col = vec3(shad)*vec3(0.2,0.5,0.8);\n  }\n  if(obj.y == 2.0){\n    shad= shad;\n    col = vec3(shad)*vec3(0.8,0.2,0.9);\n  }\n  col += g1*vec3(0.2,0.5,0.8)*0.2;\n  col = mix(col,vec3(0.235,0.075,0.369)*0.2,clamp(dO/MAX_DIST,0.0,1.0));\n  t = 0.6*t-2.0;\n  float inv = 0.0;\n  invert(inv,t,uv,0.5);\n  invert(inv,t,uv,0.466);\n  invert(inv,t,uv,0.433);\n  invert(inv,t,uv,0.4);\n  invert(inv,t,uv,0.366);\n  \n  col = mix(col*1.6,1.0-col,inv);\n  fragColor = vec4(min(col,1.0),0.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/fsXSWN.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "fsXSz2", "name": "Cotton Candy on a Cone", "author": "inspirnathan", "description": "Celebrate with some cotton candy! Yum 😋", "tags": ["raymarching", "volumetric", "stars", "cotton", "candy", "cottoncandy", "inspirnathan", "victory", "celebrate"], "likes": 3, "viewed": 57, "date": "1619010172", "time_retrieved": "2024-06-20T20:37:24.414137", "image_code": "/*\n** Cotton Candy on a Cone by inspirnathan (Nathan Vaughn)\n** \n** Resources/Credit:\n** Cone SDF: https://www.iquilezles.org/www/articles/distfunctions/distfunctions.htm\n** Volumetric ray marching and hsv: \"Cloudy spikeball\" (https://www.shadertoy.com/view/MljXDw) by Duke\n** Victory background, particle effect, and vignette: \"Ice cream\" (https://www.shadertoy.com/view/MdfBDf) by Koltes\n** Stars: \"Gold Stars\" (https://www.shadertoy.com/view/XtdcR7) by ChrisK\n** Music: https://soundcloud.com/elijah-mueller-837193122/lets-listen-super-mario-rpg-snes-victory-fanfare-extended\n*/\n\nconst int MAX_MARCHING_STEPS = 255;\nconst float MIN_DIST = 0.0;\nconst float MAX_DIST = 100.0;\nconst float PRECISION = 0.001;\nconst float PI = 3.14159265;\n\nvec3 hsv(float h, float s, float v) {\n  return mix(vec3(1.), clamp((abs(fract(h + vec3(3., 2., 1.)/3.) * 6. - 3.) - 1.), 0., 1.), s) * v;\n}\n\nmat2 rotate2d(float theta) {\n  float s = sin(theta), c = cos(theta);\n  return mat2(c, -s, s, c);\n}\n\nmat3 rotateX(float theta) {\n  float c = cos(theta);\n  float s = sin(theta);\n  return mat3(\n    vec3(1, 0, 0),\n    vec3(0, c, -s),\n    vec3(0, s, c)\n  );\n}\n\nmat3 rotateY(float theta) {\n  float c = cos(theta);\n  float s = sin(theta);\n  return mat3(\n    vec3(c, 0, s),\n    vec3(0, 1, 0),\n    vec3(-s, 0, c)\n  );\n}\n\nmat3 rotateZ(float theta) {\n  float c = cos(theta);\n  float s = sin(theta);\n  return mat3(\n    vec3(c, -s, 0),\n    vec3(s, c, 0),\n    vec3(0, 0, 1)\n  );\n}\n\n// iq's noise\nfloat pn( in vec3 x )\n{\n  vec3 p = floor(x);\n  vec3 f = fract(x);\n  f = f * f * (3.0 - 2.0 * f);\n  vec2 uv = (p.xy + vec2(31.0,0.0) * p.z * p.z) + f.xy;\n  vec2 rg = textureLod( iChannel0, (uv + 0.5)/256.0, 0.0 ).yx * .45;\n  return -1.0 + 2.4 * mix( rg.x, rg.y, f.z );\n}\n\n\nfloat fpn(vec3 p) {\n   return pn(p * .06125) * .5 + pn(p * .125) * .25 + pn(p * .25) * .125;\n}\n\nfloat cottoncandy(vec3 p) {\n   p.y -= 0.8;\n   p.z += 6.;\n   p *= rotateY(iTime * .5) * rotateX(PI/2.);\n   return length(p) - 1.35 + fpn(p * 50.) * 0.3;\n}\n\nfloat cone( vec3 p)\n{\n  vec3 offset = vec3(0, -.62, 0.);\n  vec2 c = vec2(.5, .1);\n  float h = 0.5;\n  p = (p - offset) * -1.;\n  float q = length(p.xz);\n  return max(dot(c.xy,vec2(q,p.y)),-h-p.y);\n}\n\nfloat star( vec2 uv, vec2 p, float r ) {\n    vec2 o = uv - p;\n    float theta = atan(o.y/o.x) + iTime + 3.14159265 * float(o.x < 0.0);\n    r *= 1.0 + sin(theta * 5.0) * 0.2;\n    float d = r - distance(uv, p);\n    return clamp(d * iResolution.y, 0.0, 1.0);\n}\n\nvec3 calcConeNormal(vec3 p) {\n    vec2 e = vec2(1.0, -1.0) * 0.0005;\n    return normalize(\n      e.xyy * cone(p + e.xyy) +\n      e.yyx * cone(p + e.yyx) +\n      e.yxy * cone(p + e.yxy) +\n      e.xxx * cone(p + e.xxx));\n}\n\n// normal ray marching\nfloat rayMarchCone(vec3 ro, vec3 rd) {\n  float depth = MIN_DIST;\n\n  for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n    vec3 p = ro + depth * rd;\n    float d = cone(p);\n    depth += d;\n    if (d < PRECISION || depth > MAX_DIST) break;\n  }\n  \n  vec3 normal = calcConeNormal(ro);\n  \n  return depth;\n}\n\n// volumetric ray marching loop\nvec3 rayMarchCottonCandy(vec3 p, vec3 d) {\n   d = normalize(d); \n\n   float ld = 0.;\n   float td = 0.;\n   float w = 0.;\n   \n   vec3 tc = vec3(0.05);\n\n   float r = 0., l = 0., b = 0.;\n\n   for (float i = 0.; (i < 1.); i += 1./64.) {\n     if(!((i < 1.) && (l >= 0.001 * r) && (r < 50.) && (td < .95))) {\n       break;\n     }\n\n     l = cottoncandy(p) * 0.5;\n\n     const float h = .05;\n     ld = (h - l) * step(l, h);\n     w = (1. - td) * ld;   \n\n     tc += w * hsv(350./360., .545, 1.) * hsv(w * 7. - 0.4, 1. - w * 16., .9);\n     td += w *.6;\n\n     td += 1./300.;\n\n     l = max(l, 0.03);\n\n     p += l * d *.6;\n     r += l;\n   }  \n    \n   tc *= 1. / exp( ld * 1. ) * 1.75;\n   \n   return tc;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{  \n   vec3 p = vec3(0.,0.,2.);\n   vec3 d = vec3((fragCoord.xy/(0.5*iResolution.xy)-1.)*vec2(iResolution.x/iResolution.y,1.0), 0.) - p;\n   vec3 tc = rayMarchCottonCandy(p, d);\n   float cone = rayMarchCone(p, d);\n   \n   vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n   float a = atan(uv.y + .8, uv.x) / (2. * PI) * 40. + iTime; // spinny background\n   vec3 bg = mix(hsv(325./360., .641, .918), hsv(225./360., .641, .5), step(.5, fract(a))) * 2.; // colors of background\n   vec3 col = bg;\n   \n   if (cone > MAX_DIST) col = bg;\n   else {\n     vec3 normal = calcConeNormal(p + d * cone);\n     vec3 fakeLightDirection = normalize(vec3(1,2,9));\n     float shading = clamp(dot(normal, fakeLightDirection), 0.4, 1.);\n     col = vec3(shading)*vec3(0,1,1)*1.35;\n   }\n\n   if (length(tc) > 1.4) col = tc;\n\n   vec2 uv01 = fragCoord.xy / iResolution.xy;\n   vec2 v = uv01 * (1. - uv01);\n   \n   float t = iTime;\n   vec3 ro = p;\n   vec3 rd = d;\n   \n   // particles\n    for(float i=0.; i<40.; i++){\n        vec4 h = fract(sin(i + vec4(0.,3.,5.,8.)) * 1e4);\n        h.y = fract(h.y - t * .1);\n        vec3 p = (h.xyz - .5) * 5.;\n        p.xz *= rotate2d(t * .5);\n        float l = star(uv01, cross(p - ro, rd).xy, (abs(cos(t)) + .2)*.1);\n        col += l*hsv(h.w,1.,1.)*3.;\n    }\n   \n   col = sqrt(col) *pow(v.x * v.y * 20., .6); // vignette\n      \n   fragColor = vec4(col, 1.0);\n}", "image_inputs": [{"id": "XdXGzn", "previewfilepath": "/media/ap/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png", "ctype": "texture"}, {"id": "XlsSzB", "previewfilepath": "https://soundcloud.com/elijah-mueller-837193122/lets-listen-super-mario-rpg-snes-victory-fanfare-extended", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0, "src": "https://soundcloud.com/elijah-mueller-837193122/lets-listen-super-mario-rpg-snes-victory-fanfare-extended", "ctype": "musicstream"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/fsXSz2.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "fsXSz4", "name": "test1111111", "author": "wei", "description": "test", "tags": ["test"], "likes": 1, "viewed": 129, "date": "1618303215", "time_retrieved": "2024-06-20T20:37:24.983730", "image_code": "// Author @patriciogv - 2015\n\n#ifdef GL_ES\nprecision mediump float;\n#endif\n\nfloat random (in vec2 st) {\n    return fract(sin(dot(st.xy,\n                         vec2(12.9898,78.233)))\n                 * 43758.5453123);\n}\n\nfloat noise (in vec2 st) {\n    vec2 i = floor(st);\n    vec2 f = fract(st);\n\n    // Four corners in 2D of a tile\n    float a = random(i);\n    float b = random(i + vec2(1.0, 0.0));\n    float c = random(i + vec2(0.0, 1.0));\n    float d = random(i + vec2(1.0, 1.0));\n\n    // Smooth Interpolation\n\n    // Cubic Hermine Curve.  Same as SmoothStep()\n    vec2 u = f*f*(3.0-2.0*f);\n    // u = smoothstep(0.,1.,f);\n\n    // Mix 4 coorners percentages\n    return mix(a, b, u.x) +\n            (c - a)* u.y * (1.0 - u.x) +\n            (d - b) * u.x * u.y;\n}\n\n\nfloat plot(vec2 uv, float sinOffX, float len) { \n        if(uv.y >0.5) {\n            return 0.0;\n        }\n        \n        if(uv.y <len+abs(sin(iTime))*noise(uv)) {\n            return 0.;\n        }\n    \n    \tif(uv.x >0.1) {\n            return 0.;\n        }\n        if(uv.x <-0.060) {\n            return 0.;\n        }\n        float t = abs(1. / (1000.456* uv.x + sin(uv.y * sinOffX+iTime) * (20.00)));\n    return smoothstep(0., 0.150, t);\n}\n\nfloat circle(in vec2 _st, in float _radius){\n    vec2 l = _st-vec2(0.5)+noise(_st+iTime)/20.;\n    if(_st.y<0.5){\n        return 0.;\n    }\n    return 1.-smoothstep(_radius-(_radius*0.050),\n                         _radius+(_radius*0.01),\n                         dot(l,l)*4.0);\n}\n\nfloat circle2(in vec2 _st, in float _radius){\n     _st.y = _st.y*2.;\n    vec2 l = _st-vec2(0.5)+noise(_st+iTime)/20.;\n    return 1.-smoothstep(_radius-(_radius*0.050),\n                         _radius+(_radius*0.01),\n                         dot(l,l)*4.0);\n}\n\nfloat circle3(in vec2 _st, in float _radius){\n    vec2 l = _st-vec2(0.5)+noise(_st+iTime)/20.;\n    return 1.-smoothstep(_radius-(_radius*0.050),\n                         _radius+(_radius*0.01),\n                         dot(l,l)*4.0);\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\tvec2 st = (fragCoord-.025*iResolution.xy)/iResolution.y;\n    vec4 color = vec4(0.0);\n    \n\tfloat moveY = sin(noise(st+iTime))*0.02;\n    vec4 bodyColor = vec4(1.000,0.859,0.965,1.);\n    vec4 eyeColor = vec4(0.257,0.252,0.285,1.000);\n    \n    color = vec4(0.182,0.187,0.860, 1.)*st.y*0.9;\n    \n    float f = 0.;\n\n     for(float i=0.;i<1.;i+=1./10.) {\n        f+=plot(st-vec2(0.432+0.6*i,noise(st)*0.080),noise(st*10.)*12., abs(0.5-i)*0.4);\n    }\n    //+plot(st-vec2(0.430,-0.050),  0.5)+plot(st-vec2(0.620,-0.050), 0.960)+plot(st-vec2(0.780,0.060), 1.);\n    \n    vec4 b1 = bodyColor*f;\n    color = mix(color, b1, b1.a);\n    \n    \n    float color1f = circle2(st-vec2(.20,0.310+moveY),0.492);\n    float color2f = circle(st-vec2(.20,0.070+moveY),0.476);\n    vec4 head = bodyColor*(color1f+color2f-(color1f*color2f));\n    color = mix(color, head, head.a);\n    \n    vec4 eye = eyeColor*circle3(st-vec2(0.032,0.174+moveY),0.004+abs(sin(iTime))*0.001);\n\tcolor =  mix(color, eye, eye.a);\n    \n    eye = eyeColor*circle3(st-vec2(0.368,0.174+moveY),0.004+abs(sin(iTime))*0.001);\n\tcolor =  mix(color, eye, eye.a);\n\n\tfragColor = color;\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/fsXSz4.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "fsXXDr", "name": "Pink Squigglepus", "author": "lmno", "description": "A Squigglepus is a species related to a Manypus, and was discovered in Shadertoyland in April 2021. This new cell/monster/animal loves music and it specially enjoys reacting to your microphone!", "tags": ["2d", "sound", "reactive", "music", "microphone", "squigglepus"], "likes": 0, "viewed": 50, "date": "1618455347", "time_retrieved": "2024-06-20T20:37:24.983730", "image_code": "// Created by Pol Jeremias - pol/2015\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n#define SOUND_MULTIPLIER 2.0\n\nfloat sin01(float v){ return 0.5 + 0.5 * sin(v); }\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    uv -= vec2(0.5);\n\tuv.x *= iResolution.x / iResolution.y;\n    \n    float a = atan( uv.y, uv.x );\n    float r = length( uv );\n    \n    //\n    // Draw the white eye\n    //\n    float reactBase = SOUND_MULTIPLIER * texture(iChannel0, vec2(2.1, 0.0) ).x;\n    float nr = r + reactBase * 0.06 * sin01(a * 2.0 +iTime);\n    float c = 1.0 - smoothstep(0.04, 0.07, nr);\n\t\n    //\n    // Draw the manypus\n    //\n    uv = (fragCoord.xy / iResolution.xy) * 2.0 - 1.0;\n    const float it = 1.0;\n    float c1 = 0.0;\n    for( float i = 0.0 ; i < it ; i += 1.0 )\n    {\n        float i01 = i / it;\n        float rnd = texture( iChannel1, vec2(i01)).x;\n        float react = SOUND_MULTIPLIER * texture(iChannel0, vec2(i01, 0.0) ).x;\n        \n        float a = rnd * 3.1415;\n        uv = uv * mat2( cos(a), -sin(a), sin(a), cos(a) );\n        \n        // Calculate the line\n        float t= 0.7 * abs(0.5 / sin( uv.x * 5.5415 + sin(uv.y * 30.0 * rnd +iTime) * 0.13)) - 1.0;\n        \n        // Ki5l repetition in the x axis\n        t *= 5.0 - smoothstep(0.3, 0.53, abs(uv.x));\n        \n        // Kill part of the y axis so it looks like a line with a beginning and end\n        float base = 0.0 + react;\n        rnd *= -0.1;\n        t *= 1.0 - smoothstep(base + rnd, base + 0.3 + rnd, abs(uv.y));\n        \n        c1 += t;\n    }\n    \n    //\n    // Calculat the final color\n    //\n    c1 = clamp(c1, 0.0, 1.0);\n    vec3 col = mix(vec3(2.95,0.5,0.5), vec3(0.25), c1 - c);\n    col += c;\n\tfragColor = vec4( col, 2.0);\n}", "image_inputs": [{"id": "Xsf3zn", "previewfilepath": "/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture"}, {"id": "XdXGRr", "previewfilepath": "/presets/mic.png", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/presets/mic.png", "ctype": "mic"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc-by-nc-sa-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/fsXXDr.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "fsXXDS", "name": "Metaballs: Living on the edge", "author": "longshot", "description": "Basic metaballs with distance field.", "tags": ["metaballs"], "likes": 1, "viewed": 37, "date": "1619114872", "time_retrieved": "2024-06-20T20:37:25.250430", "image_code": "//--------------------------------------------------------\n// Basic metaballs with distance field\n// \n// v1.0 - 2021-03-28 - Initial version\n// Thanks to mrange for improvements\n//--------------------------------------------------------\n\n\nfloat circle(vec2 pos, float r) {\n  return length(pos) - r;\n}\n\n// Polynominal smooth min, https://www.iquilezles.org/www/articles/smin/smin.htm\nfloat pmin(float a, float b, float k) {\n  float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n  return mix( b, a, h ) - k*h*(1.0-h);\n}\n\nfloat df(vec2 p) {\n  float d = 1E6;\n  for (int i = 0; i < 6; ++i) {\n    float a = 1.2*(iTime + 2.0*float(i));\n    float d0 = circle(p - vec2(cos(a), sin(a*sqrt(0.2))), 0.63);\n    d = pmin(d, d0, 0.15);\n  }\n  for (int i = 0; i < 4; ++i) {\n    d = abs(d) - 0.0005/d;\n  }\n  return d;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  vec2 q = fragCoord/iResolution.xy;\n  vec2 p = -1.0 + 2.0*q;\n  p.x *= iResolution.x/iResolution.y;\n  float aa = 2.0/iResolution.y;\n  vec3 col = vec3(0.2,0.2,0.2);\n  float d = df(p);\n  col = mix(col, vec3(1.0,0.2,0.0), smoothstep(-aa, aa, -d));\n  fragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/fsXXDS.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "fsXXWH", "name": "Bitwise planet map", "author": "jarble", "description": "This map was generated using a bitwise fractal formula. It appears to have continents and oceans with many different biomes.", "tags": ["fractal", "ocean", "map", "bitwise", "biome", "continents"], "likes": 2, "viewed": 125, "date": "1618528306", "time_retrieved": "2024-06-20T20:37:25.250430", "image_code": "#define ITERS 9 //normal world map\n//#define ITERS 6 //swamp world\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Scale and move to make things a litle more interesting t look at.\n    float scale = 2000.0;\n    float trans = iTime * 200.0;\n    vec2 coord = (scale * fragCoord/iResolution.xy) + vec2(trans+30000.0,0.0);\n    \n    int val = 0;\n    float result = 0.0;\n    vec3 col = vec3(0.0);\n    vec3 col_prev = vec3(0.0);\n    for(int i = 0; i < ITERS; i++){\n        col_prev = col;\n        coord.y -= (4.0-result);\n        coord += coord.yy/8.0;\n        coord = coord.yx/(4.0);\n        result = ((result + float(val = ((int(coord.x-coord.y/2.0) & int(coord.y+coord.x/2.0)) % 3)))/(2.0));\n        col.x = result;\n        col = ((col.yzx)*2.0+col_prev)/3.5;\n    }\n    // Output.\n    fragColor = vec4((col),0.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/fsXXWH.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "fsXXWr", "name": "Hallway Stroll", "author": "percentcer", "description": "Taking a walk", "tags": ["grid", "fract"], "likes": 1, "viewed": 119, "date": "1618447076", "time_retrieved": "2024-06-20T20:37:25.250430", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (2.*fragCoord-iResolution.xy)/iResolution.y;\n    \n    const float WIDTH = 16.;\n    vec2 cell = floor(uv * WIDTH);\n\n    vec3 col = abs(\n        vec3(\n        cell.x*sin( -iTime*2. + abs(cell.x)*.5 ),\n        cell.y*1.1+sin(iTime*4.),\n        cell.y)\n    ) * (1./WIDTH);\n    \n\n    fragColor = vec4(col,1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/fsXXWr.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "fsXXzn", "name": "tsodinSmug", "author": "rexim", "description": "circles", "tags": ["circles"], "likes": 0, "viewed": 124, "date": "1618166227", "time_retrieved": "2024-06-20T20:37:25.250430", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float gridSize = 150.0 + sin(iTime) * 100.0;\n    float radius = gridSize * (1.0 - (sin(iTime) + 1.0) / 2.0);\n\n    vec2 coord = fragCoord - iResolution.xy * 0.5;\n    vec2 cell = floor(coord / gridSize);\n    vec2 center = cell * gridSize + vec2(gridSize * 0.5);\n    if (length(coord - center) < radius) {\n        fragColor = vec4(\n            (sin(cell.x + iTime) + 1.0) / 2.0,\n            (cos(cell.y + iTime) + 1.0) / 2.0,\n            1.0,\n            1.0);\n    } else {\n        fragColor = vec4(0.0);\n    }\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/fsXXzn.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "ldGfzd", "name": "Little Blobby", "author": "rift", "description": "Diff of box and sphere, with smaller sphere melting through the box.", "tags": ["raymarching"], "likes": 3, "viewed": 50, "date": "1619816831", "time_retrieved": "2024-06-20T20:37:25.911093", "image_code": "\nconst int MAX_STEPS = 128;\nconst float STEP_SCALE = 0.5;\nconst float eps = 0.005; \n\n\n// Rotates a point t radians around the y-axis\nvec3 rotateY(vec3 v, float t)\n{\n  float cost = cos(t); float sint = sin(t);\n  return vec3(v.x * cost + v.z * sint, v.y, -v.x * sint + v.z * cost);\n}\n\n// Rotates a point t radians around the x-axis\nvec3 rotateX(vec3 v, float t)\n{\n  float cost = cos(t); float sint = sin(t);\n  return vec3(v.x, v.y * cost - v.z * sint, v.y * sint + v.z * cost);\n}\n\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\nfloat sdPlane( vec3 p, vec4 n )\n{\n  // n must be normalized\n  return dot(p,n.xyz) + n.w;\n}\n\n\nfloat sphere(vec3 p, vec3 center, float radius) \n{\n  return length(p - center) - radius;\n}\n\nfloat sinusoid(vec3 p)\n{\n  return cos(p.x*3.+sin(iTime)*0.7)* sin(p.y*3.+sin(iTime)*0.4) * cos(p.z*-3.0+sin(iTime)*0.4) \n          + 0.8*cos(p.x*18.+sin(iTime)*1.4) * sin(p.y*18.+sin(iTime)*0.4) * cos(p.z*-18.+sin(iTime)*0.8);\n}\n\nfloat scene(vec3 p)\n{\n\t/*\n    float boxBlob = min(\n              \t\tmax(sdBox(p, vec3(.5,0.8,0.5)), \n                  -sphere(p, vec3(cos(iTime)*0.1+0.0, cos(iTime/4.)*-2.0, cos(iTime)*0.1+0.0), .75) + 0.04*sinusoid(p)), \n              \t\tsphere(p, vec3(cos(iTime)*0.1+0.0, cos(iTime/4.)*-2.0, cos(iTime)*0.1+0.0), .3) + 0.1*sinusoid(p)\n            \t\t);\n    float plane = sdPlane(p, vec4(0.0,0.01,0.0,0.1));\n    \n    return min(boxBlob, plane);*/\n    \n  return min(\n              max(sdBox(p, vec3(.5,0.8,0.5)), \n                  -sphere(p, vec3(cos(iTime), cos(iTime/5.)*-1.3, cos(iTime/2.)*0.5), .7) + 0.06*sinusoid(p)), \n              sphere(p, vec3(cos(iTime), cos(iTime/5.)*-1.3, cos(iTime/2.)*0.5), .3) + 0.1*sinusoid(p)\n            );\n}\n\nfloat march(vec3 origin, vec3 direction, float start, float end)\n{\n  float sceneDist = 0.0;\n  float rayDepth = start;\n\n  for (int i = 0; i < MAX_STEPS; i++) {\n    sceneDist = scene( origin + direction * rayDepth);\n\n    if(rayDepth >= end) {\n      break;\n    }\n\n    rayDepth += sceneDist * STEP_SCALE;\n\n  }\n\n  return rayDepth;\n}\n\nvec3 getNormal(in vec3 p) \n{\n  \n  return normalize(vec3(\n    scene(vec3(p.x+eps,p.y,p.z))-scene(vec3(p.x-eps,p.y,p.z)),\n    scene(vec3(p.x,p.y+eps,p.z))-scene(vec3(p.x,p.y-eps,p.z)),\n    scene(vec3(p.x,p.y,p.z+eps))-scene(vec3(p.x,p.y,p.z-eps))\n  ));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec3 cameraPos = vec3(sin(iTime/4.)*-2.2, 0.0, cos(iTime/4.)*-2.2);\n  vec3 cameraLookAt = vec3(0.0, 0.0, 0.0);\n  vec2 aspectRatio = vec2(iResolution.x/iResolution.y, 1.0);\n  vec2 screenCoords = vec2(2. * fragCoord.xy/iResolution.xy - 1.0) * aspectRatio;\n  float FOV = 0.5;\n\n  vec3 rayOrigin = cameraPos;\n  vec3 forward = normalize(cameraLookAt - cameraPos);\n  vec3 right = normalize(vec3(forward.z, 0.0, -forward.x));\n  vec3 up = normalize(cross(forward,right));\n  vec3 rayDir = normalize(forward + FOV*screenCoords.x*right + FOV*screenCoords.y*up);\n\n  float clipNear = 0.0;\n  float clipFar = 10.0;\n\n  vec3 bgColor = vec3(0.0, 0.0, 0.0);\n\n  float dist = march(rayOrigin, rayDir, clipNear, clipFar);\n\n  if (dist >= clipFar) {\n    fragColor = vec4(bgColor, 1.0);\n    return;\n  }\n\n  vec3 surfacePos = rayOrigin + rayDir*dist;\n  vec3 surfaceNormal = getNormal(surfacePos);\n  \n  vec3 lightPos = vec3(sin(iTime/4.)*-2.0,1.5, cos(iTime/4.)*-2.);\n\n  vec3 lightDir = lightPos-surfacePos;\n\n  vec3 lightColor = vec3(1.,0.97,0.92);\n\n  vec3 ref = reflect(-lightDir, surfaceNormal);\n  float diffuse = max( 0.0, dot(surfaceNormal, lightDir) );\n  float specular = max( 0.0, dot( ref, normalize(cameraPos-surfacePos)) ); \n\n  vec3 spherecolor = vec3(abs(sin(iTime/2.))*0.5, abs(cos(iTime/2.))*0.5,abs(sin(iTime/4.))*0.5) * (diffuse*.8) + specular*0.01;\n  fragColor = vec4(spherecolor,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/ldGfzd.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "ldVXDm", "name": "♫ Planet 7120 - initial commit", "author": "patu", "description": "Initial commit for https://www.pouet.net/prod.php?which=68093 :)\n2016(?)", "tags": ["demoscene"], "likes": 8, "viewed": 223, "date": "1617235465", "time_retrieved": "2024-06-20T20:37:29.014390", "image_code": "#define getNormal getNormalHex\n\n#define FAR 570.\n#define INFINITY 1e32\n#define t iTime\n#define mt iChannelTime[1]\n#define FOV 110.0\n#define FOG 1.\n\n#define PI 3.14159265\n#define TAU (2*PI)\n#define PHI (1.618033988749895)\n\nfloat vol = 0.;\nfloat noise = 0.;\n\nfloat hash12(vec2 p) {\n\tfloat h = dot(p,vec2(127.1,311.7));\t\n    return fract(sin(h)*43758.5453123);\n}\n\n// 3d noise\nfloat noise_3(in vec3 p) {\n    vec3 i = floor(p);\n    vec3 f = fract(p);\t\n\tvec3 u = f*f*(3.0-2.0*f);\n    \n    vec2 ii = i.xy + i.z * vec2(5.0);\n    float a = hash12( ii + vec2(0.0,0.0) );\n\tfloat b = hash12( ii + vec2(1.0,0.0) );    \n    float c = hash12( ii + vec2(0.0,1.0) );\n\tfloat d = hash12( ii + vec2(1.0,1.0) ); \n    float v1 = mix(mix(a,b,u.x), mix(c,d,u.x), u.y);\n    \n    ii += vec2(5.0);\n    a = hash12( ii + vec2(0.0,0.0) );\n\tb = hash12( ii + vec2(1.0,0.0) );    \n    c = hash12( ii + vec2(0.0,1.0) );\n\td = hash12( ii + vec2(1.0,1.0) );\n    float v2 = mix(mix(a,b,u.x), mix(c,d,u.x), u.y);\n        \n    return max(mix(v1,v2,u.z),0.0);\n}\n\nfloat fbm(vec3 x)\n{\n    float r = 0.0;\n    float w = 1.0, s = 1.0;\n    for (int i=0; i<5; i++)\n    {\n        w *= 0.5;\n        s *= 2.0;\n        r += w * noise_3(s * x);\n    }\n    return r;\n}\n\nvec3 fromRGB(int r, int g, int b) {\n \treturn vec3(float(r), float(g), float(b)) / 255.;   \n}\n    \nvec3 \n    light = vec3(0.0),\n    p = vec3(0.),\n    p2 = vec3(0.),\n\tlightDir = vec3(0.);\n\n\n\nvec3 lightColour = normalize(vec3(1.8, 1.0, 0.3)); \n\nvec3 saturate(vec3 a) { return clamp(a, 0.0, 1.0); }\nvec2 saturate(vec2 a) { return clamp(a, 0.0, 1.0); }\nfloat saturate(float a) { return clamp(a, 0.0, 1.0); }\n\n\n\nvec3 opRep( vec3 p, vec3 c )\n{\n    return mod(p,c)-0.5*c;\n}\n\n// Repeat only a few times: from indices <start> to <stop> (similar to above, but more flexible)\nfloat pModInterval1(inout float p, float size, float start, float stop) {\n\tfloat halfsize = size*0.5;\n\tfloat c = floor((p + halfsize)/size);\n\tp = mod(p+halfsize, size) - halfsize;\n\tif (c > stop) { //yes, this might not be the best thing numerically.\n\t\tp += size*(c - stop);\n\t\tc = stop;\n\t}\n\tif (c <start) {\n\t\tp += size*(c - start);\n\t\tc = start;\n\t}\n\treturn c;\n}\n\n\n\nfloat smin( float a, float b, float k )\n{\n    float res = exp( -k*a ) + exp( -k*b );\n    return -log( res )/k ;\n}\n\nvoid pR(inout vec2 p, float a) {\n\tp = cos(a)*p + sin(a)*vec2(p.y, -p.x);\n}\n\nfloat opU2( float d1, float d2 ) {\n    if (d1 < d2) return d1;\n    return d2;\n}\n\nvec3 opU2( vec3 d1, vec3 d2 ) {\n    if (d1.x < d2.x) return d1;\n    return d2;\n}\n\nstruct geometry {\n    float dist;\n    float materialIndex;\n    float specular;\n    float diffuse;\n    vec3 space;\n    vec3 color;\n};\n\ngeometry geoU(geometry g1, geometry g2) {\n    if (g1.dist < g2.dist) return g1;\n    return g2;\n}\n\nvec3 opS2( vec3 d1, vec3 d2 ){\t\n    if (-d2.x > d1.x) return -d2;\n    return d1;\n}\n\nvec3 opI2( vec3 d1, vec3 d2 ) {\n \tif (d1.x > d2.x) return d1;\n    return d2;\n}\n\n// Maximum/minumum elements of a vector\nfloat vmax(vec2 v) {\n\treturn max(v.x, v.y);\n}\n\nfloat vmax(vec3 v) {\n\treturn max(max(v.x, v.y), v.z);\n}\n\nfloat vmax(vec4 v) {\n\treturn max(max(v.x, v.y), max(v.z, v.w));\n}\n\n// Sign function that doesn't return 0\nfloat sgn(float x) {\n\treturn (x<0.)?-1.:1.;\n}\n\nvec2 sgn(vec2 v) {\n\treturn vec2((v.x<0.)?-1.:1., (v.y<0.)?-1.:1.);\n}\n\n\n// Repeat space along one axis. Use like this to repeat along the x axis:\n// <float cell = pMod1(p.x,5);> - using the return value is optional.\nfloat pMod1(inout float p, float size) {\n\tfloat halfsize = size*0.5;\n\tfloat c = floor((p + halfsize)/size);\n\tp = mod(p + halfsize, size) - halfsize;\n\treturn c;\n}\n\n\n// Repeat in two dimensions\nvec2 pMod2(inout vec2 p, vec2 size) {\n\tvec2 c = floor((p + size*0.5)/size);\n\tp = mod(p + size*0.5,size) - size*0.5;\n\treturn c;\n}\n// Repeat around the origin by a fixed angle.\n// For easier use, num of repetitions is use to specify the angle.\nfloat pModPolar(inout vec2 p, float repetitions) {\n\tfloat angle = 2.*PI/repetitions;\n\tfloat a = atan(p.y, p.x) + angle/2.;\n\tfloat r = length(p);\n\tfloat c = floor(a/angle);\n\ta = mod(a,angle) - angle/2.;\n\tp = vec2(cos(a), sin(a))*r;\n\t// For an odd number of repetitions, fix cell index of the cell in -x direction\n\t// (cell index would be e.g. -5 and 5 in the two halves of the cell):\n\tif (abs(c) >= (repetitions/2.)) c = abs(c);\n\treturn c;\n}\n\n// Mirror at an axis-aligned plane which is at a specified distance <dist> from the origin.\nfloat pMirror (inout float p, float dist) {\n\tfloat s = sgn(p);\n\tp = abs(p)-dist;\n\treturn s;\n}\n\nvec2 pMirrorOctant (inout vec2 p, vec2 dist) {\n\tvec2 s = sgn(p);\n\tpMirror(p.x, dist.x);\n\tpMirror(p.y, dist.y);\n\tif (p.y > p.x)\n\t\tp.xy = p.yx;\n\treturn s;\n}\n// Box: correct distance to corners\nfloat fBox(vec3 p, vec3 b) {\n\tvec3 d = abs(p) - b;\n\treturn length(max(d, vec3(0))) + vmax(min(d, vec3(0)));\n}\n\n// Same as above, but in two dimensions (an endless box)\nfloat fBox2Cheap(vec2 p, vec2 b) {\n\treturn vmax(abs(p)-b);\n}\n\nfloat fCross(vec3 p, vec3 size) {\n    float obj = fBox(p, size);\n    obj = opU2(obj, fBox(p, size.zxy));\n    obj = opU2(obj, fBox(p, size.yzx));\n               \n               return obj;\n}\n\n\nfloat fSphere(vec3 p, float r) {\n\treturn length(p) - r;\n}\n\nvec4 texture3d (sampler2D t, vec3 p, vec3 n, float scale) {\n\t\n    return \n\t\ttexture(t, p.yz * scale) * abs (n.x) +\n\t\ttexture(t, p.zx * scale) * abs (n.y) +\n\t\ttexture(t, p.xy * scale) * abs (n.z);\n}\n\nvec4 boxmap(sampler2D t, in vec3 p, vec3 n, in float k ) {\n    vec3 m = pow( abs(p), vec3(k) );\n\tvec4 x = texture(t, p.yz);\n\tvec4 y = texture(t, p.zx);\n\tvec4 z = texture(t, p.xy);\n\treturn (x * m.x + y * m.y + z * m.z) / (m.x + m.y + m.z);\n}\n\ngeometry map(vec3 p) {\n    //p.y += sin(t * 1.+ p.z / 10.) * 3. + sin(p.x / 3.);\n    vec3 bp = p;\n    vec3 fp = p;\n    \n    float localNoise = fbm(p / 10.) * 2.;;\n    \n    p.y -= 11. + sin(p.z / 15. + p.x / 14.2) * 2.6;\n    p.y -= localNoise;//, p.xz / 20.).r / 2.;\n    \n    // ----------\n    geometry box;\n    //bp.xz += sin(vec2(t)) * 15.;\n    \n    //bp.z += 22. ;\n    bp.y -= (min(27., t / 2.));\n    bp.y += -4. - sin(t * 3.) * 1.4;\n    \n    //bp.xz = mod(p.xz, 70.) - 35.;\n    \n    pR(bp.xz, t);\n        //pR(bp.zy, t * 2.);\n    pR(bp.yx, t * 4.6);\n    \n    bp.z += 2.;\n    \n    pModPolar(bp.xy, 3.);\n    pMirrorOctant(bp.xz, vec2(1.) + sin(t / 4.) / 3.);\n    //pMirrorOctant(bp.xz, vec2(5.));\n    box.dist = fBox(bp, vec3(4., 9., 1.));\n    box.materialIndex = 4.;\n    box.space = bp;\n    box.color = vec3(1.);\n    box.diffuse = 0.;\n    box.specular = 22.1;\n    \n\t// ------------\n    geometry floor;\n\n    vec3 floorP = p;\n    //floorP.y += fbm(p / 370.) * 110.;\n    floor.dist = fBox2Cheap(floorP.xy, vec2(100., 2.5)),\n    floor.materialIndex = 0.;\n    floor.space = p;\n    floor.color = vec3(1., .8, .6) ;//* localNoise;\n    floor.diffuse = 8.;\n    floor.specular = 4.0;\n    \n    // ------------\n    geometry water;\n    \n\n    \n    // ----------\n    geometry obj;\n    /*\n    p.xz -= 25.;\n    \n    vec2 pM = pMod2(p.xz, vec2(50.));\n    \n    pMirrorOctant(p.zy, \n                  vec2(\n                      1. * mod(pM.x, 14.), \n                      5. + ceil(13. * (sin(pM.x) * 3.+ 1.)) \n                  )\n                 );\n    pMirrorOctant(p.xz, vec2(13., 18. + mod(pM.y * 5., 16.)));\n    \n    pR(p.zy, 1.17 + p.x / 10. );\n\n    p.x += 2.5 ;//* localNoise / 10.;\n    \n    pModPolar(p.xz, 12.5 - (sin(pM.x) * 10.+ (sin(1. / 3.) * 10.)));\n\t\n    pMirrorOctant(p.zy, vec2(8.4, 6.));\n    pMirrorOctant(p.xy, vec2(3.5, 5.));\n    \n    \n*/\n\tfloor.dist = smin(floor.dist, box.dist * localNoise / 2., 0.21 ) ;\n    //box.dist -= 0.2;\n    \n    box.dist = fBox(bp, vec3(4., 9., 1.) * vec3(1., 1., pow(vol / 2., 4.) / 2.).zyx);\n    box.color = vec3(0.) + pow(vol / 3., 4.) * 2. + box.dist;\n    \n    obj = geoU(box, floor);\n    //obj = geoU(obj, water);\n    //obj = geoU(obj, box);\n    \n    \n    return obj;\n}\n\n\nfloat t_min = 0.001;\nfloat t_max = FAR;\nconst int MAX_ITERATIONS = 290;\n\ngeometry trace(vec3 o, vec3 d, int maxI) {\n    float omega = 1.2;\n    float t = t_min;\n    float candidate_error = INFINITY;\n    float candidate_t = t_min;\n    float previousRadius = 0.;\n    float stepLength = 0.;\n    float pixelRadius = //tan(radians (FOV) / 2.0) \n        1. / 250.;\n    float functionSign = map(o).dist < 0. ? -1. : +1.;\n    geometry mp;\n    \n    for (int i = 0; i < MAX_ITERATIONS; ++i) {\n        if (maxI > 0 && i > maxI) break; \n        mp = map(d * t + o);\n        float signedRadius = functionSign * mp.dist;\n        float radius = abs(signedRadius);\n        bool sorFail = omega > 1. &&\n        (radius + previousRadius) < stepLength;\n        if (sorFail) {\n            stepLength -= omega * stepLength;\n            omega = 1.;\n        } else {\n        stepLength = signedRadius * omega;\n        }\n        previousRadius = radius;\n        float error = radius / t;\n        if (!sorFail && error < candidate_error) {\n            candidate_t = t;\n            candidate_error = error;\n        }\n        if (!sorFail && error < pixelRadius || t > t_max) break;\n        t += stepLength;\n   \t}\n    \n    mp.dist = candidate_t;\n    \n    if (\n        (t > t_max || candidate_error > pixelRadius)\n    \t) mp.dist = INFINITY;\n    \n    \n    return mp;\n}\n\n\nfloat softShadow(vec3 ro, vec3 lp, float k) {\n    const int maxIterationsShad = 25;\n    vec3 rd = (lp - ro); // Unnormalized direction ray.\n\n    float shade = 1.;\n    float dist = 1.5;\n    float end = max(length(rd), 0.01);\n    float stepDist = end / float(maxIterationsShad);\n\n    rd /= end;\n    for (int i = 0; i < maxIterationsShad; i++) {\n        float h = map(ro + rd * dist).dist;\n        //shade = min(shade, k*h/dist);\n        shade = min(shade, smoothstep(0.0, 1.0, k * h / dist)); \n        dist += min(h, stepDist * 2.); \n        if (h < 0.001 || dist > end) break;\n    }\n    return min(max(shade, 0.6), 1.0);\n}\n\n\n#define EPSILON .001\nvec3 getNormalHex(vec3 pos)\n{\n\tfloat d=map(pos).dist;\n\treturn normalize(\n        vec3(\n            map(\n                pos+vec3(EPSILON,0,0)).dist-d,\n                map(pos+vec3(0,EPSILON,0)).dist-d,\n                map(pos+vec3(0,0,EPSILON)).dist-d \n        \t)\n    \t);\n}\n\n#define delta vec3(.001, 0., 0.)\nvec3 getNormalCube(vec3 pos)   \n{    \n   vec3 n;  \n   n.x = map( pos + delta.xyy ).dist - map( pos - delta.xyy ).dist;\n   n.y = map( pos + delta.yxy ).dist - map( pos - delta.yxy ).dist;\n   n.z = map( pos + delta.yyx ).dist - map( pos - delta.yyx ).dist;\n   \n   return normalize(n);\n}\n\n\nfloat getAO(vec3 hitp, vec3 normal, float dist)\n{\n    vec3 spos = hitp + normal * dist;\n    float sdist = map(spos).dist;\n    return clamp(sdist / dist, 0.4, 1.0);\n}\n\nvec3 Sky(in vec3 rd, bool showSun, vec3 lightDir)\n{\n//   rd = sin(rd) * 1.5;\n   \n   float sunSize = 2.;\n   float sunAmount = max(dot(rd, lightDir), .1);\n   float v = pow(1.2 - max(rd.y, .5), 1.1);\n   vec3 sky = mix(fromRGB(255,200,100), vec3(1.1, 1.2, 1.3) / 10., v);\n   sky += pow(fbm(rd * 1. + vec3(t / 3., t, t).yxz / 3.) * .4, 1.2);\n   sky += lightColour * sunAmount * sunAmount * 1. + lightColour * min(pow(sunAmount, 128.0)* sunSize,1233. * sunSize);\n\n\treturn clamp(sky, 0.0, 1.0);\n    \n   \n}\n\nvec3 doColor( in vec3 sp, in vec3 rd, in vec3 sn, in vec3 lp, geometry obj) {\n\tvec3 sceneCol = vec3(0.0);\n    lp = sp + lp;\n    vec3 ld = lp - sp; // Light direction vector.\n    float lDist = max(length(ld / 2.), 0.001); // Light to surface distance.\n    ld /= lDist; // Normalizing the light vector.\n\n    // Attenuating the light, based on distance.\n    float atten = 1. / (1.0 + lDist * 0.025 + lDist * lDist * 0.2);\n\n    // Standard diffuse term.\n    float diff = max(dot(sn, ld), obj.diffuse);\n    // Standard specualr term.\n    float spec = max(dot(reflect(-ld, sn), -rd), obj.specular / 2.);\n\n    \n    // Coloring the object. You could set it to a single color, to\n    // make things simpler, if you wanted.\n    vec3 objCol = obj.color;//getObjectColor(sp, sn, obj);\n\n    // Combining the above terms to produce the final scene color.\n    sceneCol += (objCol * (diff + .15) * spec * 0.1);// * atten;\n\n    // Return the color. Done once every pass... of which there are\n    // only two, in this particular instance.\n    \n    return sceneCol;\n}\n\nvec3 LensFlare( vec3 ray, vec3 light, vec2 fragCoord )\n{\n\tvec2 dirtuv = fragCoord.xy/iResolution.x;\n\t\n\tfloat dirt = 1.0-texture( iChannel1, dirtuv ).r;\n\t\n\tfloat l = max(.0,dot(light,ray));\n\t\n\treturn (pow(l,20.0)*dirt*.1 + 1.0*pow(l,100.0))*vec3(1.05,1,.95);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    \n    //lightColour = normalize(fromRGB(133,7,142)) * 2.; \n    \n    vec2 uv = fragCoord.xy / iResolution.xy - .5;\n    //vec3 rd = normalize(vec3(uv, 1.0));\n//uv.x *= iResolution.y / iResolution.x;\n    \n    if (abs(uv.y) > .35) {\n     \tfragColor *= 0.;\n        return;\n    }\n    \n    uv *= tan(radians (FOV) / 2.0) * 1.1;\n\n    uv.y *= 1.2;\n    vol = texture(iChannel0, vec2(.5, .25)).r  * 4.; \n    float t2 = t;\n    float \n        sk = sin(-t2 * .1) * 32.0, \n        ck = cos(-t2 * .1) * 22.0,\n        \n        mat = 0.;\n    \n    //uv.x *= 2. - abs(cos(uv.y)) / 2.; // fisheye\n    \n    light = vec3(0., 77., 100.);        \n    lightDir = light;\n    \n    \n    vec3 \n        vuv = vec3(cos(t) / 6., 1., sin(t) * .2 ), // up\n    \tro = vec3(ck, 32. - ck /2., sk + 10.);// + vec3(iMouse.x / 20.,iMouse.y / 10. - 1., 1.); // pos\n    \n    vec3\n        vrp =  vec3(10., 10. + ck, 0.),// vec3(sin(iMouse.x / 10.) * 50., 0., cos(iMouse.x/ 10.) * 50.), // lookat    */\n\t\t\n    \tvpn = normalize(vrp - ro),\n    \tu = normalize(cross(vuv, vpn)),\n    \tv = cross(vpn, u),\n    \tvcv = (ro + vpn),\n    \tscrCoord = (vcv + uv.x * u * iResolution.x/iResolution.y + uv.y * v),\n    \trd = normalize(scrCoord - ro),\n        hit;        \n\t\n    vec3 sceneColor = vec3(0.);\n    \n    // Light position. Set in the vicinity the ray origin.\n    //vec3 lp = light ;\n\t//lightDir = lp;\n\t\n    //vec3 ray_start = ro;\n    \n    // FIRST PASS.\n\t\n    geometry tr = trace(ro, rd, 0);    \n    \n    float fog = smoothstep(FAR * FOG, 0., tr.dist) * 1.;\n    hit = ro + rd * tr.dist;\n    \n    vec3 sn = getNormal(hit);\t\n    \n    float sh = softShadow(hit, hit + light, 6.);\n    \n    float \n        ao = getAO(hit, sn, .2);\n\t\n    ao *= saturate(getAO(hit + sn * .2, sn, 0.5));\n    //p = tr.space;\n    ao *= saturate(getAO(hit + sn * 1.03, sn, 3.05));\n    //p = p2;\n    \n    //vec3 tp = hit;\n    //ro = p2; \n\n    noise = fbm(mod(hit + 20. + hit.yzx* 4., 40.) / 1.);\n\tvec3 sky = Sky(rd, true, normalize(light)) * 1.;\n    \n    if (tr.dist < FAR) { \n        sceneColor = (doColor(hit, rd, sn, light, tr) * 1.) * 1.;\n        sceneColor *= ao; \n        sceneColor *= sh;\n        sceneColor = mix(sceneColor, sky, saturate(tr.dist * 3. / FAR));\n        sceneColor = mix(sceneColor, lightColour, 0.1);        \n        /*sceneColor *= 0.9 + vec3(length(\n            max(\n                vec2(0.),\n                .6 * max(\n                    0.,\n                    length(normalize(light.y) * max(0., sn.y))\n                )\n            )\n        ));\n        */\n        //sceneColor.rgb += LensFlare(rd, normalize(light), fragCoord)/ 2.;\n    \n        if (tr.materialIndex == 5.) {         \t\n            vec3 refSceneColor =sceneColor;\n            rd = reflect(rd, sn);// + sin(t));\n            tr = trace(hit + rd * .02, rd, 99);\n            if (tr.dist < FAR) {\n                hit = hit + rd * tr.dist;\n                sn = getNormal(hit);\n                refSceneColor = mix(sceneColor, abs(doColor(hit, rd, sn, light, tr)), .7);                \n            } else {\n             \tsky = Sky(rd, true, normalize(light)) * 1.;\n                refSceneColor = mix(refSceneColor, sky, saturate(tr.dist * 5. / FAR));\n                refSceneColor = mix(refSceneColor, lightColour, 0.1);   \n            }\n            \n            sceneColor = mix(sceneColor, refSceneColor, .5);\n            \n        } else {\n            //sceneColor = mix(sceneColor, sky, .0);  \n        }\n        \n        //sceneColor *= 1. + length(saturate(sn) * normalize(light));\n    } else {\n        //sceneColor.r = .3;\n        //sceneColor += debug_plane(ro, rd, -4.85, tr.dist).rgb * 2.;\n        //sceneColor = vec3(1., .5, 0.) * cos(uv.y * 3.) / 3.;\n        //sky += max(0., max(0., rd.y) * spherical_texturing(rd, 1.)) * 1.;\n        sceneColor = sky;\n        \n        //fog = smoothstep(FAR * FOG, 0., tr.x * 2.);\n    \t//sceneColor *= fog;\n    }\n    \n    //sceneColor = mix(sceneColor, sky, min(1., noise * tr.dist / 90.));\n    // tonemapping\n    //sceneColor = vec3(1., 1.2, 1.3) * sceneColor / (1. + sceneColor);\n\n   // sceneColor *= 1. + float(tr.iterations) / 96.;\n    \n    // some kind of vinetting.\n    //sceneColor = saturate(sceneColor * (1.5 - length(ouv - .5) * 2.));\n    \n    //gamma\n    //sceneColor = pow(sceneColor, vec3(2.4)) + sceneColor / 1.;\n    \n    //if (tr.materialIndex != 4.) sceneColor *= 1. + 1.- abs(fract(t / 2.)) / 3.;\n    \n    fragColor = vec4(clamp(sceneColor * (1. - length(uv) / 3.5), 0.0, 1.0), 1.0);\n    fragColor = pow(fragColor, vec4(1.2));\n    //fragColor = vec4(fbm(vec3(0.4) * uv.x));\n}\n", "image_inputs": [{"id": "Xds3W2", "previewfilepath": "https://soundcloud.com/dj-blackley/prohibited-free-download", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "https://soundcloud.com/dj-blackley/prohibited-free-download", "ctype": "musicstream"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/ldVXDm.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "ltyBWG", "name": "okgo", "author": "lennyjpg", "description": "asdfasdfasdfasdfasdf", "tags": ["asd"], "likes": 0, "viewed": 129, "date": "1617375708", "time_retrieved": "2024-06-20T20:37:29.014390", "image_code": "#define SC(a)  vec2(sin(a),cos(a))\nvoid mainImage( out vec4 O, in vec2 f ){\n    vec2 U = (f-iMouse.xy) / iResolution.y;\n    for(float i=2., t = iTime*.7;i<38.;i++){\n        U += i/5. * SC(i*11.1+t*.1);\n\t\tO[int(i)%3] += sin(atan(U.x,U.y) + i * 11.32 + t) * 0.33;\n    }\n    O += vec4(.7,.4,.4,0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/ltyBWG.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "MdlSWN", "name": "celestialBlob_01", "author": "entropynine", "description": "modification of \"Glass Eel\" by Kali", "tags": ["3dblob"], "likes": 4, "viewed": 186, "date": "1618012073", "time_retrieved": "2024-06-20T20:37:29.014390", "image_code": "//\"Glass Eel\" by Kali\n\n#define lightcol1 vec3(1.,.5,.5)\n#define lightcol2 vec3(.5,.5,1.)\n\n\n\n//Distance Field\nfloat de(vec3 p) {\n\tp+=sin(p*10.+iTime*10.)*.012;\n\tfloat rot=p.z-iTime*3.;\n\tp.x+=sin(p.z-iTime*3.)*1.1+p.z*.5;\n\tp.y+=cos(p.z*.5-iTime*2.)*.8-1.5+p.z*.4;\n\tp.z-=5.;\n\tp.xy*=mat2(cos(rot),cos(rot),-sin(rot),cos(rot));\n\tfloat sc=max(1.,pow(abs(p.z),5.)*.000002);\n\tp*=sc;\n\tfloat d=((length(p.xy)-.3)-length(cos(p*20.))*.03-length(cos(p*10.))*.05);\n\td=min(max(-p.z,d),length(p*vec3(1.,1.,1.4))-.47);\n\treturn d*.5/sc;\n}\n\n// finite difference normal\nvec3 normal(vec3 pos) {\n\tvec3 e = vec3(0.0,0.002,0.0);\n\t\n\treturn normalize(vec3(\n\t\t\tde(pos+e.yxx)-de(pos-e.yxx),\n\t\t\tde(pos+e.xyx)-de(pos-e.xyx),\n\t\t\tde(pos+e.xxy)-de(pos-e.xxy)\n\t\t\t)\n\t\t);\t\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tfloat time = iTime*.6; \n\n\t//camera\n\tvec2 uv = fragCoord.xy / iResolution.xy *2. - vec2(1.);\n\tvec2 coord=uv;\n\tcoord.y *= iResolution.y / iResolution.x;\n\tcoord.xy*=mat2(cos(time),sin(time),-sin(time),cos(time));\n\tfloat fov=.5;\n\tvec3 from = vec3(-3.,-1.,sin(time)*4.-1.);\n\n\t//vars\n\tfloat totdist=0.;\n\tfloat distfade=1.;\n\tfloat glassfade=1.;\n\tfloat intens=1.;\n\tfloat maxdist=30.;\n\tfloat vol=0.;\n\tvec3 spec=vec3(0.);\n\tvec3 dir=normalize(vec3(coord.xy*fov,1.)); \n\tfloat ref=0.;\n\tvec3 light1=normalize(vec3(sin(time),sin(time*2.)*.5,1.5));\n\tvec3 light2=normalize(vec3(sin(time+2.),sin((time+2.)*2.)*.5,1.5));\n\n\t//march\n\tfor (int r=0; r<120; r++) {\n\t\tvec3 p=from+totdist*dir;\n\t\tfloat d=de(p);\n\t\tfloat distfade=exp(-5.*pow(totdist/maxdist,1.2));\n\t\tintens=min(distfade,glassfade);\n\n\t   if (totdist<maxdist) {\n\n\t\t// refraction\n\t\tif (d>0.0 && ref>.5) {\n\t\t\tref=0.;\n\t\t\tvec3 n=normal(p);\n\t\t\tif (dot(dir,n)<-0.5) dir=normalize(refract(dir,n,1./.85));\n\t\t\tvec3 refl=reflect(dir,-n);\n\t\t\tspec+=lightcol1*pow(max(dot(refl,light1),0.0),40.);\n\t\t\tspec+=lightcol2*pow(max(dot(refl,light2),0.0),40.);\n\t\t\tspec*=intens;\n\t\t\tspec*=glassfade;\n\t\t}\n\t\tif (d<0.0 && ref<.5) {\n\t\t\tref=1.;\n\t\t\tvec3 n=normal(p);\n\t\t\tif (dot(dir,n)<0.) dir=normalize(refract(dir,n,.85));\n\t\t\tvec3 refl=reflect(dir,n);\n\t\t\tglassfade*=.6;\n\t\t\tspec+=lightcol1*pow(max(dot(refl,light1),0.0),50.);\n\t\t\tspec+=lightcol2*pow(max(dot(refl,light2),0.0),50.);\n\t\t\tspec+=pow(max(dot(refl,vec3(0.,0.,-1.)),0.0),50.)*3.;\n\t\t\t\n\t\t}\n\t\t\n\t\ttotdist+=max(0.001,abs(d)); //advance ray \n\t   }\n\t\tvol+=max(0.,.6-d)*intens; //glow\n\t}\n\t\n\tvol*=.025;\n\tvec3 col=vec3(vol*vol,vol*.9,vol*vol*vol)+vec3(spec)*.5+.13;\n\n\t//lights\n\tvec3 tcoor=vec3((dir.xy*(2.-sin(time)*.8))+sin(coord.xy*20.+iTime*10.)*.007,1.);\n\tvec3 li=vec3(0.15);\n\tcol+=2.*lightcol1*pow(max(0.,max(0.,dot(normalize(tcoor+vec3(0.15,.1,0.)),light1))),500.)*glassfade; \n\tcol+=2.*lightcol2*pow(max(0.,max(0.,dot(normalize(tcoor+vec3(0.15,.1,0.)),light2))),500.)*glassfade; \n\tli+=lightcol1*pow(max(0.,max(0.,dot(normalize(tcoor),light1))),40.)*glassfade; \n\tli+=lightcol2*pow(max(0.,max(0.,dot(normalize(tcoor),light2))),40.)*glassfade; \n\t//background\n\tcol+=li*.3+li*5.*pow(texture(iChannel0,tcoor.xy*vec2(.5+(1.+cos(time))*.5,1.)+time).x,1.7)*glassfade*vec3(.3,1.,.3)*max(0.,1.-length(coord));\n\t\n\tcol*=1.-pow(max(0.,max(abs(uv.x),abs(uv.y))-.8)/.2,10.); //borders\n\n\t//color adjust\t\n\tcol=pow(col,vec3(1.2,1.1,1.));\n\tcol*=vec3(1.,.8,1.);\n\n\tcol*=min(1.,time); //fade in\n\tfragColor = vec4(col,1.0);\t\n}", "image_inputs": [{"id": "XdfGRn", "previewfilepath": "/media/ap/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/MdlSWN.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "MlSBDt", "name": "RME4 - Crater", "author": "patu", "description": "crater\n#makeYourShadersPublic", "tags": ["crater"], "likes": 128, "viewed": 13248, "date": "1617234623", "time_retrieved": "2024-06-20T20:37:30.553931", "image_code": "#define getNormal getNormalHex\n\n//#define raymarch vanillaRayMarch \n#define raymarch enchancedRayMarcher \n\n#define FAR 570.\n#define INFINITY 1e32\n\n#define FOV 110.0\n#define FOG 1.\n\n#define PI 3.14159265\n#define TAU (2*PI)\n#define PHI (1.618033988749895)\n\nfloat vol = 0.;\nfloat noise = 0.;\n\nfloat hash12(vec2 p) {\n\tfloat h = dot(p,vec2(127.1,311.7));\t\n    return fract(sin(h)*43758.5453123);\n}\n\n// 3d noise\nfloat noise_3(in vec3 p) {\n    vec3 i = floor(p);\n    vec3 f = fract(p);\t\n\tvec3 u = f*f*(3.0-2.0*f);\n    \n    vec2 ii = i.xy + i.z * vec2(5.0);\n    float a = hash12( ii + vec2(0.0,0.0) );\n\tfloat b = hash12( ii + vec2(1.0,0.0) );    \n    float c = hash12( ii + vec2(0.0,1.0) );\n\tfloat d = hash12( ii + vec2(1.0,1.0) ); \n    float v1 = mix(mix(a,b,u.x), mix(c,d,u.x), u.y);\n    \n    ii += vec2(5.0);\n    a = hash12( ii + vec2(0.0,0.0) );\n\tb = hash12( ii + vec2(1.0,0.0) );    \n    c = hash12( ii + vec2(0.0,1.0) );\n\td = hash12( ii + vec2(1.0,1.0) );\n    float v2 = mix(mix(a,b,u.x), mix(c,d,u.x), u.y);\n        \n    return max(mix(v1,v2,u.z),0.0);\n}\n\nfloat fbm(vec3 x)\n{\n    float r = 0.0;\n    float w = 1.0, s = 1.0;\n    for (int i=0; i<7; i++)\n    {\n        w *= 0.5;\n        s *= 2.0;\n        r += w * noise_3(s * x);\n    }\n    return r;\n}\n\nvec3 fromRGB(int r, int g, int b) {\n \treturn vec3(float(r), float(g), float(b)) / 255.;   \n}\n    \nvec3 \n    light = vec3(0.0),\n    p = vec3(0.),\n    p2 = vec3(0.),\n\tlightDir = vec3(0.);\n\nvec3 lightColour = normalize(vec3(1.8, 1.0, 0.3)); \n\nvec3 saturate(vec3 a) { return clamp(a, 0.0, 1.0); }\nvec2 saturate(vec2 a) { return clamp(a, 0.0, 1.0); }\nfloat saturate(float a) { return clamp(a, 0.0, 1.0); }\n\nfloat smin( float a, float b, float k )\n{\n    float res = exp( -k*a ) + exp( -k*b );\n    return -log( res )/k ;\n}\n\nvoid pR(inout vec2 p, float a) {\n\tp = cos(a)*p + sin(a)*vec2(p.y, -p.x);\n}\n\nstruct geometry {\n    float dist;\n    float materialIndex;\n    float specular;\n    float diffuse;\n    vec3 space;\n    vec3 color;\n};\n\nfloat fSphere(vec3 p, float r) {\n\treturn length(p) - r;\n}\n\n\ngeometry scene(vec3 p) {\n    geometry plane;\n\n    float localNoise = fbm(p / 10.) * 2.;;\n    p.y -= localNoise * .2;\n    plane.dist = p.y;\n    p.y *= 3.5;\n\n    plane.dist = smin(plane.dist, length(p) - 25., .15 + localNoise * .2);\n    plane.dist = max(plane.dist, -length(p) + 29.  + localNoise);\n    plane.materialIndex = 4.;\n    plane.space = p;\n    plane.color = vec3(1., .2, .0);\n    plane.diffuse = 0.;\n    plane.specular = 22.1;\n    \n    return plane;\n}\n\n\nfloat t_min = 0.001;\nfloat t_max = FAR;\nconst int MAX_ITERATIONS = 90;\n\ngeometry enchancedRayMarcher(vec3 o, vec3 d, int maxI) {\n    geometry mp;\n    \n    float t_min = 0.001;\n    float tb = (2.1-o.y)/d.y;\n    \n    if( tb<0.0 ) { mp.dist = INFINITY; return mp; }\n    \n    t_min = tb;\n    \n    float omega = 1.3;\n    float t = t_min;\n    float candidate_error = INFINITY;\n    float candidate_t = t_min;\n    float previousRadius = 0.;\n    float stepLength = 0.;\n    float pixelRadius = //tan(radians (FOV) / 2.0) \n        1. /350.;\n    float functionSign = scene(o).dist < 0. ? -1. : +1.;\n    \n    \n    for (int i = 0; i < MAX_ITERATIONS; ++i) {\n        if (maxI > 0 && i > maxI) break; \n        mp = scene(d * t + o);\n        float signedRadius = functionSign * mp.dist;\n        float radius = abs(signedRadius);\n        bool sorFail = omega > 1. &&\n        (radius + previousRadius) < stepLength;\n        if (sorFail) {\n            stepLength -= omega * stepLength;\n            omega = 1.;\n        } else {\n        \tstepLength = signedRadius * omega * .8;\n        }\n        previousRadius = radius;\n        float error = radius / t;\n        if (!sorFail && error < candidate_error) {\n            candidate_t = t;\n            candidate_error = error;\n        }\n        if (!sorFail && error < pixelRadius || t > t_max) break;\n        t += stepLength;\n   \t}\n    \n    mp.dist = candidate_t;\n    \n    if (\n        (t > t_max || candidate_error > pixelRadius)\n    \t) mp.dist = INFINITY;\n    \n    \n    return mp;\n}\n\ngeometry vanillaRayMarch(vec3 o, vec3 d, int maxI) {\n    geometry mp;\n    \n    float l = -.1;\n    \n    for (int i = 0; i < 30; i++) {\n        if (abs(l) < 0.1 || l > 130.) {\n            break;\n        }\n        \n        mp = scene(o + d * l);\n        l += mp.dist;\n    }\n    \n    mp.dist = l;\n    return mp;\n}\n\nfloat softShadow(vec3 ro, vec3 lp, float k) {\n    const int maxIterationsShad = 125;\n    vec3 rd = (lp - ro); // Unnormalized direction ray.\n\n\n    float shade = 1.;\n    float dist = 1.0;\n    float end = max(length(rd), 0.01);\n    float stepDist = end / float(maxIterationsShad);\n    \n    float tb = (8.0-ro.y)/normalize(rd).y; \n    if( tb>0.0 ) end = min( end, tb );\n    \n    rd /= end;\n    for (int i = 0; i < maxIterationsShad; i++) {\n        float h = scene(ro + rd * dist).dist;\n        shade = min(shade, smoothstep(0.0, 1.0, k * h / dist)); \n        dist += min(h, stepDist * 2.); \n        if (h < 0.001 || dist > end) break;\n    }\n    return min(max(shade, 0.3), 1.0);\n}\n\n\n#define EPSILON .001\nvec3 getNormalHex(vec3 pos)\n{\n\tfloat d=scene(pos).dist;\n\treturn normalize(\n        vec3(\n            scene(\n                pos+vec3(EPSILON,0,0)).dist-d,\n                scene(pos+vec3(0,EPSILON,0)).dist-d,\n                scene(pos+vec3(0,0,EPSILON)).dist-d \n        \t)\n    \t);\n}\n\nfloat getAO(vec3 hitp, vec3 normal, float dist)\n{\n    vec3 spos = hitp + normal * dist;\n    float sdist = scene(spos).dist;\n    return clamp(sdist / dist, 0.4, 1.0);\n}\n\nvec3 Sky(in vec3 rd, bool showSun, vec3 lightDir)\n{\n   \tfloat sunSize = 1.;\n   \tfloat sunAmount = max(dot(rd, lightDir), .1);\n   \tfloat v = pow(1.2 - max(rd.y, .5), 1.1);\n   \tvec3 sky = mix(fromRGB(255,200,100), vec3(1.1, 1.2, 1.3) / 10., v);\n   \tsky += lightColour * sunAmount * sunAmount * 1. + lightColour * min(pow(sunAmount, 1e4)* sunSize,1233. * sunSize);\n\n   \treturn clamp(sky, 0.0, 1.0);\n}\n\nvec3 doColor( in vec3 sp, in vec3 rd, in vec3 sn, in vec3 lp, geometry obj) {\n\tvec3 sceneCol = vec3(0.0);\n    lp = sp + lp;\n    vec3 ld = lp - sp; // Light direction vector.\n    float lDist = max(length(ld / 2.), 0.001); // Light to surface distance.\n    ld /= lDist; // Normalizing the light vector.\n\tfloat atten = 1. / (1.0 + lDist * 0.025 + lDist * lDist * 0.2);\n\tfloat diff = max(dot(sn, ld), obj.diffuse);\n    float spec = max(dot(reflect(-ld, sn), -rd), obj.specular / 2.);\n\tvec3 objCol = obj.color;//getObjectColor(sp, sn, obj);\n\tsceneCol += (objCol * (diff + .15) * spec * 0.1);// * atten;\n    return sceneCol;\n}\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    \n    //lightColour = normalize(fromRGB(133,7,142)) * 2.; \n    \n    vec2 uv = fragCoord.xy / iResolution.xy - .5;\n\n    uv.y *= 1.2;\n    vol = texture(iChannel0, vec2(.5, .25)).r  * 4.; \n    float t2 = iTime;\n    float \n        sk = sin(-t2 * .1) * 48.0, \n        ck = cos(-t2 * .1) * 48.0,\n        \n        mat = 0.;\n    \n    light = vec3(0., 7., 100.);        \n    lightDir = light;\n    \n    \n    vec3 \n        vuv = vec3(0., 1., 0. ),\n    \tro = vec3(ck, 18., sk);\n    \n    vec3\n        vrp =  vec3(0., 0., 0.),\n\t\t\n    \tvpn = normalize(vrp - ro),\n    \tu = normalize(cross(vuv, vpn)),\n    \tv = cross(vpn, u),\n    \tvcv = (ro + vpn),\n    \tscrCoord = (vcv + uv.x * u * iResolution.x/iResolution.y + uv.y * v),\n    \trd = normalize(scrCoord - ro),\n        hit;        \n\t\n    vec3 sceneColor = vec3(0.);\n\t\n    geometry tr = raymarch(ro, rd, 0);    \n    \n    float fog = smoothstep(FAR * FOG, 0., tr.dist) * 1.;\n    hit = ro + rd * tr.dist;\n    \n    vec3 sn = getNormal(hit);\t\n    \n    float sh = softShadow(hit, hit + light, 8.2);\n    \n    float \n        ao = getAO(hit, sn, 10.2);\n\n    noise = fbm(mod(hit + 20. + hit.yzx* 4., 40.) / 1.);\n\tvec3 sky = Sky(rd, true, normalize(light)) * 1.;\n    \n    if (tr.dist < FAR) { \n        sceneColor = (doColor(hit, rd, sn, light, tr) * 1.) * 1.;\n        sceneColor *= ao; \n        sceneColor *= sh;\n        sceneColor = mix(sceneColor, sky, saturate(tr.dist * 4.5 / FAR));\n    } else {\n        sceneColor = sky;\n    }\n    \n    fragColor = vec4(clamp(sceneColor * (1. - length(uv) / 3.5), 0.0, 1.0), 1.0);\n    fragColor = pow(fragColor, 1./vec4(1.2));\n\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/MlSBDt.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "Nd23Rd", "name": "Sea of Clouds", "author": "andrew741", "description": "clouds and waves go brrrrrrrrrrr. This is an early version and builds off of my cloud texture shader (for the volumetric clouds). Note that it's very slow.", "tags": ["raymarching", "waves", "clouds", "ocean", "sky", "shadows", "spheretracing", "reflections", "specularreflection"], "likes": 1, "viewed": 93, "date": "1617895065", "time_retrieved": "2024-06-20T20:37:33.851129", "image_code": "\n\n// remaps a value\nfloat map(float val, float cMin, float cMax, float nMin, float nMax)\n{\n    // a basic remapping function\n    // remapping from 0 - any\n    float nVal = val - cMin;\n    // scaling from 0 - (new_max - new_min)\n    nVal *= (nMax - nMin) / (cMax - cMin);\n    // adding the new min\n    nVal += nMin;\n    // returning it\n    return nVal;\n}\n\n\n// a heighly random persudo random number generator that takes in a vec3 and returns a vec3\nvec3 random(vec3 co)\n{\n    // note that this code is from another user (on shadertoy)\n    vec3 p = co;\n    p = vec3( dot(p,vec3(127.1,311.7, 74.7)),\n\t\t\t  dot(p,vec3(269.5,183.3,246.1)),\n\t\t\t  dot(p,vec3(113.5,271.9,124.6)));\n    vec3 output_ = fract(sin(p)*43758.5453123);\n\treturn output_;\n}\n\n\n// a smoothstep function\nfloat Smoothstep(float x)\n{\n    float k = clamp(x, 0., 1.);\n    return k * k * (3. - 2. * k);\n}\n\n\n// returns the magnitude\nfloat mag(vec3 v)\n{\n    // this is just the dot of v\n    return dot(v, v);\n}\n\n\n// returns a value between 0 and 1 (of worly noise)\nfloat WorlyNoise(vec3 sample_pos, float scale, int o)\n{\n    // e is unused and is here because it was used in an earlier version\n    float e = float(o);\n    \n    // multiplacation is faster then divition\n    float scale_dived = 1. / scale;\n    \n    // geting the sample poses cell pos\n    vec3 cell_pos = floor(sample_pos * scale_dived);\n    \n    // generating cells/nabors positions\n    // layer 1\n    vec3 cell1 = cell_pos + vec3(1., -1., -1.);\n    vec3 cell2 = cell_pos + vec3(1., 0., -1.);\n    vec3 cell3 = cell_pos + vec3(1., 1., -1.);\n    \n    vec3 cell4 = cell_pos + vec3(0., -1., -1.);\n    vec3 cell5 = cell_pos + vec3(0., 0., -1.);\n    vec3 cell6 = cell_pos + vec3(0., 1., -1.);\n    \n    vec3 cell7 = cell_pos + vec3(-1., -1., -1.);\n    vec3 cell8 = cell_pos + vec3(-1., 0., -1.);\n    vec3 cell9 = cell_pos + vec3(-1., 1., -1.);\n    \n    // layer 2\n    vec3 cell10 = cell_pos + vec3(1., -1., 0.);\n    vec3 cell11 = cell_pos + vec3(1., 0., 0.);\n    vec3 cell12 = cell_pos + vec3(1., 1., 0.);\n    \n    vec3 cell13 = cell_pos + vec3(0., -1., 0.);\n    vec3 cell14 = cell_pos + vec3(0., 0., 0.);\n    vec3 cell15 = cell_pos + vec3(0., 1., 0.);\n    \n    vec3 cell16 = cell_pos + vec3(-1., -1., 0.);\n    vec3 cell17 = cell_pos + vec3(-1., 0., 0.);\n    vec3 cell18 = cell_pos + vec3(-1., 1., 0.);\n    \n    // layer 3\n    vec3 cell19 = cell_pos + vec3(1., -1., 1.);\n    vec3 cell20 = cell_pos + vec3(1., 0., 1.);\n    vec3 cell21 = cell_pos + vec3(1., 1., 1.);\n    \n    vec3 cell22 = cell_pos + vec3(0., -1., 1.);\n    vec3 cell23 = cell_pos + vec3(0., 0., 1.);\n    vec3 cell24 = cell_pos + vec3(0., 1., 1.);\n    \n    vec3 cell25 = cell_pos + vec3(-1., -1., 1.);\n    vec3 cell26 = cell_pos + vec3(-1., 0., 1.);\n    vec3 cell27 = cell_pos + vec3(-1., 1., 1.);\n    \n    // generating the random offests for cell points    \n    // layer1\n    vec3 rand1 = random(cell1) * scale;\n    vec3 rand2 = random(cell2) * scale;\n    vec3 rand3 = random(cell3) * scale;\n    vec3 rand4 = random(cell4) * scale;\n    vec3 rand5 = random(cell5) * scale;\n    vec3 rand6 = random(cell6) * scale;\n    vec3 rand7 = random(cell7) * scale;\n    vec3 rand8 = random(cell8) * scale;\n    vec3 rand9 = random(cell9) * scale;\n    // layer2\n    vec3 rand10 = random(cell10) * scale;\n    vec3 rand11 = random(cell11) * scale;\n    vec3 rand12 = random(cell12) * scale;\n    vec3 rand13 = random(cell13) * scale;\n    vec3 rand14 = random(cell14) * scale;\n    vec3 rand15 = random(cell15) * scale;\n    vec3 rand16 = random(cell16) * scale;\n    vec3 rand17 = random(cell17) * scale;\n    vec3 rand18 = random(cell18) * scale;\n    // layer3\n    vec3 rand19 = random(cell19) * scale;\n    vec3 rand20 = random(cell20) * scale;\n    vec3 rand21 = random(cell21) * scale;\n    vec3 rand22 = random(cell22) * scale;\n    vec3 rand23 = random(cell23) * scale;\n    vec3 rand24 = random(cell24) * scale;\n    vec3 rand25 = random(cell25) * scale;\n    vec3 rand26 = random(cell26) * scale;\n    vec3 rand27 = random(cell27) * scale;\n    \n    // generating the distance to each of those cell positions/points position (the mag not length)\n    // layer1\n    float dist1 = mag(sample_pos - (cell1 * scale + rand1));\n    float dist2 = mag(sample_pos - (cell2 * scale + rand2));\n    float dist3 = mag(sample_pos - (cell3 * scale + rand3));\n    float dist4 = mag(sample_pos - (cell4 * scale + rand4));\n    float dist5 = mag(sample_pos - (cell5 * scale + rand5));\n    float dist6 = mag(sample_pos - (cell6 * scale + rand6));\n    float dist7 = mag(sample_pos - (cell7 * scale + rand7));\n    float dist8 = mag(sample_pos - (cell8 * scale + rand8));\n    float dist9 = mag(sample_pos - (cell9 * scale + rand9));\n    // layer2\n    float dist10 = mag(sample_pos - (cell10 * scale + rand10));\n    float dist11 = mag(sample_pos - (cell11 * scale + rand11));\n    float dist12 = mag(sample_pos - (cell12 * scale + rand12));\n    float dist13 = mag(sample_pos - (cell13 * scale + rand13));\n    float dist14 = mag(sample_pos - (cell14 * scale + rand14));\n    float dist15 = mag(sample_pos - (cell15 * scale + rand15));\n    float dist16 = mag(sample_pos - (cell16 * scale + rand16));\n    float dist17 = mag(sample_pos - (cell17 * scale + rand17));\n    float dist18 = mag(sample_pos - (cell18 * scale + rand18));\n    // layer3\n    float dist19 = mag(sample_pos - (cell19 * scale + rand19));\n    float dist20 = mag(sample_pos - (cell20 * scale + rand20));\n    float dist21 = mag(sample_pos - (cell21 * scale + rand21));\n    float dist22 = mag(sample_pos - (cell22 * scale + rand22));\n    float dist23 = mag(sample_pos - (cell23 * scale + rand23));\n    float dist24 = mag(sample_pos - (cell24 * scale + rand24));\n    float dist25 = mag(sample_pos - (cell25 * scale + rand25));\n    float dist26 = mag(sample_pos - (cell26 * scale + rand26));\n    float dist27 = mag(sample_pos - (cell27 * scale + rand27));\n    \n    // finding the smallest value\n    // layer1\n    float strength1 = min(min(min(dist1, dist2), min(dist3, dist4)), min(min(dist5, dist6), min(dist7, min(dist8, dist9))));\n    // layer2\n    float strength2 = min(min(min(dist10, dist11), min(dist12, dist13)), min(min(dist14, dist15), min(dist16, min(dist17, dist18))));\n    // layer3\n    float strength3 = min(min(min(dist19, dist20), min(dist21, dist22)), min(min(dist23, dist24), min(dist25, min(dist26, dist27))));\n    // finding the overal smallest and taking the square root of it to get the length to it\n    // layers all\n    float strength = (min(min(strength1, strength2), strength3)) / (scale);\n    \n    // returning and remapping\n    //return map(strength / (scale * 1.25), 0., 1., 0.2, -0.1);\n    return (1. - strength / (scale * 1.25)) * 3.25 - 2.25;\n    //return map(strength / (scale * 1.25), 0., 1., 1., -4.);\n}\n\n// this noise method is from https://www.shadertoy.com/view/XslGRr\n#define NOISE_METHOD 1\nfloat noise( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n\tf = f*f*(3.0-2.0*f);\n\n#if NOISE_METHOD==0\n    x = p + f;\n    return textureLod(iChannel2,(x+0.5)/32.0,0.0).x*2.0-1.0;\n#endif\n#if NOISE_METHOD==1\n\tvec2 uv = (p.xy+vec2(37.0,239.0)*p.z) + f.xy;\n    vec2 rg = textureLod(iChannel0,(uv+0.5)/256.0,0.0).yx;\n\treturn mix( rg.x, rg.y, f.z )*2.0-1.0;\n#endif    \n#if NOISE_METHOD==2\n    ivec3 q = ivec3(p);\n\tivec2 uv = q.xy + ivec2(37,239)*q.z;\n\tvec2 rg = mix(mix(texelFetch(iChannel0,(uv           )&255,0),\n\t\t\t\t      texelFetch(iChannel0,(uv+ivec2(1,0))&255,0),f.x),\n\t\t\t\t  mix(texelFetch(iChannel0,(uv+ivec2(0,1))&255,0),\n\t\t\t\t      texelFetch(iChannel0,(uv+ivec2(1,1))&255,0),f.x),f.y).yx;\n\treturn mix( rg.x, rg.y, f.z )*2.0-1.0;\n#endif    \n}\n\n\nfloat Hash31(vec3 p)\n{\n    vec3 r = random(p);\n    return r.x * r.y * r.z;\n}\n\n\n// generates a noise texture (a height from 0 - 1 based on position)\nfloat OctaveWorly(vec3 fragCoord, int octaves, float scale, float persistance, float luclarity)\n{\n    // initializing veriables\n    float height = 0.;\n    float l = 1.;\n    float total = 0.;\n    // looping over all octaves\n    for (int o = 0; o < octaves; o++)\n    {\n        // getting the height for that octave and adding it\n        vec3 p = fragCoord + float(o * 500);\n        height += noise(fragCoord / scale);  // WorlyNoise(p, scale, o) * l;\n        // this is to remap the final height\n        total += l;  // the 0.95 is because the height of the bumps (when added up) is almost never equal to the max height and thefore the more octaves, the duller the color\n        // changing the height and scale based on inputed paramaters\n        l *= luclarity;\n        scale *= persistance;\n    }\n    // remaping the final height\n    height /= total;\n    // returning the height\n    height *= 0.2;\n    //height *= smoothstep(0., 0.05, noise(fragCoord / 200.));\n    //height = clamp(height, 0.01, 0.5);\n    //return floor(Hash31(floor((fragCoord - vec3(0, 120, 0)) / 240.)) + 0.85) * 0.05;\n    return height;\n}\n\n\n// returns a scaler for density so the clouds arnt just cut off at the bounds of the cloud container\nfloat GetHeightFalloff(float y, float cloud_height, float cloud_thickness)\n{\n    float scaler = 1. - Smoothstep(max(map((y - 120.) / 160., 0., 1., -3., 1.), 0.));\n    return scaler;\n}\n\n\n// gets the height of the waves at a given xy point\nfloat waterHeight(vec2 p)\n{\n    /*\n    float height = map(sin(p.x * 0.1 + p.y * 0.3 + (sin(p.y * 0.5 + p.x * 0.1) * 0.5 + 0.5)) + sin(p.x * 0.4 - p.y + (sin(p.y) * 0.5)), -3., 1.5, 0., 1.) * (sin(p.y * 0.2) * 0.5 + 0.5 + (sin(p.x * 0.1 + p.y * 0.7) * 0.5 + 0.5) * 0.2 + sin(p.x * 0.05) * sin(p.y * 0.025) * 0.2);\n    height = height + (sin(p.x * 0.002 + p.y * 0.004) * sin(p.y * 0.007 + p.x * 0.035)) + sin(p.x * 0.01 + p.y * 0.2 + 1.5) * 0.4;\n    return height + 1.;\n    */\n    p *= 0.3;\n    float h1 = 1. - abs(sin(iTime) * cos(p.x + sin(p.y*0.4))) * 1.;\n    float h2 = 1.5 - abs(cos(iTime) * sin(p.y * 0.8 + cos(p.x * 0.1))) * 1.5;\n    float h3 = 0.75 - abs(sin(iTime + 4.) * sin((p.y + 6.) * 1.25 + sin((p.x - 8.) * 0.4))) * 0.75;\n    float h4 = 0.75 - abs(cos(iTime - 5.) * cos((p.x - 6.) + sin(p.y + 8.))) * 0.75;\n    return h1 + h2 + h3 + h4;\n}\n\n\n// returns the distance to the ocean (surface)\nfloat getDst(vec3 p)\n{\n    float dst1 = p.y - waterHeight(p.xz);\n    return dst1;\n}\n\n\n// reverses a ray\nvec3 reverseRay(vec3 angle)\n{\n    return vec3(-angle.x, -angle.y, -angle.z);\n}\n\n\n// gets the normal of the water\nvec3 getNormal(vec3 p) {\n\tfloat d = getDst(p);\n    vec2 e = vec2(.01, 0);\n    \n    vec3 normal = d - vec3(\n        getDst(p - e.xyy),\n        getDst(p - e.yxy),\n        getDst(p - e.yyx));\n    \n    return normalize(normal);\n}\n\n\n// the derection of the sun (constant)\n//vec3 sun_derection = normalize(vec3(-0.5, 0.25, 1.));\n\n\n// main loop/the shader\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // the normalized coordinates\n    vec2 uv = (fragCoord - iResolution.xy * 0.5) / (iResolution.x * 0.5);\n    // the ray's direction\n    vec2 cam_rot = (iMouse.xy / iResolution.xy - 0.5) * 2.;\n    vec3 rd = normalize(vec3(uv.x + (iMouse.x / (iResolution.x * 0.5) - 0.5) * 0.5, uv.y + (iMouse.y / (iResolution.y * 0.5) - 0.5) * 0.5, 1.));\n    \n    // the suns angle (rotates)\n    vec3 sun_derection = normalize(vec3(sin(iTime * 0.05), map(sin(iTime * 0.01), -1., 1., 0.25, 1.), cos(iTime * 0.05)));\n    \n    // the camera's position\n    vec3 camera_pos = vec3(iTime * 20., (sin(iTime * 0.15) * 0.5 + 0.5) * 400. + 5., iTime * 20.);// + vec3(iMouse.x, 0., iMouse.y);\n    \n    // some parameters that change the look of the clouds and performance\n    int steps = 90;\n    int sun_steps = 10;\n    float cloud_height = 120.;\n    float cloud_thickness = 160.;\n    bool in_cloud = false;\n    \n    // generating the distance to the cloud and the distance through the cloud\n    float dst_to_cloud, dst_through_cloud;\n    \n    float rd2 = 1. / rd.y;\n    // the cloud is above the player\n    if (camera_pos.y < cloud_height)\n    {\n        // checking if the cloud is in view\n        if (rd.y > 0.)\n        {\n            // finding the dist to the cloud and through the cloud\n            dst_to_cloud = (cloud_height - camera_pos.y) * rd2;\n            dst_through_cloud = cloud_thickness * rd2;\n            // the cloud is in view\n            in_cloud = true;\n        }\n    }\n    // the cloud is in the player\n    else if (camera_pos.y < cloud_height + cloud_thickness)\n    {\n        // checking if the ray's direction is above or bellow\n        dst_to_cloud = 0.;  // the distance to the cloud is 0 because your in the cloud\n        // ray's going up\n        if (rd.y > 0.)\n        {\n            // finding the dist through the cloud\n            dst_through_cloud = (cloud_thickness - (camera_pos.y - cloud_height)) * rd2;\n        }\n        // the ray is going downwards\n        else\n        {\n            // finding the dist through the cloud\n            dst_through_cloud = (camera_pos.y - cloud_height) * abs(rd2);\n        }\n        // the cloud is in view\n        in_cloud = true;\n    }\n    // the cloud is bellow the player\n    else\n    {\n        // checking if the cloud is in view\n        if (rd.y < 0.)\n        {\n            // finding the dist to and through the cloud\n            dst_to_cloud = ((camera_pos.y - cloud_height) - cloud_thickness) * abs(rd2);\n            dst_through_cloud = cloud_thickness * abs(rd2);\n            // the cloud is in view\n            in_cloud = true;\n        }\n    }\n    \n    // the color of the sky\n    float intensity = rd.y * 0.5 + 0.5;\n    vec3 sky_color = vec3(intensity * 0.6, intensity * 0.6, intensity);\n    vec3 col = sky_color;\n    // drawing the sun in the sky\n    vec3 sun_col = vec3(1., 0.95, 0.85);\n    col = mix(col, sun_col, pow(max(dot(sun_derection, rd), 0.), 100.));\n    \n    // simulating water\n    float water_height = 0.;\n    \n    bool hit_water = false;\n    float dst_to_water;\n    \n    if (rd.y < 0.)\n    {\n        hit_water = true;\n        dst_to_water = max(camera_pos.y - water_height, 0.) / abs(rd.y);\n    }\n    \n    // rendering the water\n    if (hit_water)\n    {\n        // finding where the view ray hits the water\n        vec3 water_p = camera_pos + rd * dst_to_water;\n        \n        // using sphere tracing to add waves to the water\n        float d;\n        for (int s = 0; s < 5; s++)\n        {\n            d = getDst(water_p);\n            water_p += d * rd;\n            if (d < 0.01) break;\n        }\n        \n        // finding where the sun's direction vector hits the clouds (for shadows)\n        vec3 cloud_collide = water_p + sun_derection * ((cloud_height - water_p.y) / sun_derection.y);\n        \n        // finding the shadow cast by clouds\n        float ss = (cloud_thickness / sun_derection.y) / float(sun_steps);\n        vec3 pss = sun_derection * ss;\n        float dens = 0.;\n        for (int s = 0; s < sun_steps; s++)\n        {\n            // adding up the density\n            dens += max(OctaveWorly(cloud_collide, 1, 120., 0.5, 0.5), 0.) * ss * GetHeightFalloff(cloud_collide.y, cloud_height, cloud_thickness) * 0.175;\n            // stepping through the cloud\n            cloud_collide += pss;\n        }\n        \n        // calculating the color of the water\n        vec3 water_color = vec3(0.45, 0.45, 0.65);\n        \n        // finding the color of the clouds above the water\n        \n        // the water normal and reflected ray for the water\n        vec3 water_normal = getNormal(water_p);\n        vec3 reflected_image;\n        \n        // finding the darkness from the clouds\n        float tr = exp(-dens * 0.075);\n        // getting the normal of the water\n        // the smoothness (size of the specular reflection)\n        float smoothness = 0.5;\n        // finding the specular highlight and diffused lighting\n        float specularAngle = acos(dot(normalize(sun_derection - rd), water_normal));\n        float specularExponent = specularAngle / (1. - smoothness);\n        float specularHighlight = exp(-specularExponent * specularExponent) * tr;\n        float diffseLighting = clamp(dot(water_normal, sun_derection), 0., 1.);\n        // finding how much reflection will be seen\n        float ref = pow(1. - diffseLighting, 1.5);\n        \n        // the reflection dose acount for a good amount\n        if (ref >= 0.06)\n        {\n            vec3 reflected = water_normal - (0. - rd);\n            float dst_through_cloud2 = cloud_thickness / reflected.y;\n            float dst_to_cloud2 = (cloud_height - water_p.y) / reflected.y;;\n\n            // finding the step size\n            float step_size = min(dst_through_cloud2 / float(steps / 4), 15.);\n            vec3 point_step_size = reflected * step_size;\n\n            // initializing some veriables\n            float transmittion = 1.;\n            float lightEnergy = 0.;\n\n            // some peramaters related to transparency of the cloud and brightness\n            float lightApsorbtionToSun = 0.235;\n            float lightApsorbtion = 0.165;\n            float lightPhase = map(clamp(pow(dot(sun_derection, rd), 7.5), 0., 1.), 0., 1., 0.21, 0.5);//0.21;\n            \n            // the color of the cloud\n            vec3 cloud_color = sun_col;  // vec3(1., 0.9, 0.85);\n\n            // the starting position\n            vec3 p = water_p + reflected * dst_to_cloud2;\n\n            // initializing some veriables that are going to be used later\n\n            float density, dst_to_sun_through_cloud, lightTransmittion, density_in_cloud, sun_step_size, density_sun, sun_trans;\n            vec3 point_sun_step_size, p2;\n\n            // stepping through the cloud\n            for (int s = 0; s < steps / 4; s++)\n            {\n                p2 = vec3(p.x, p.y, p.z);\n\n                // finding the density at this point using worly noise\n                density = max(OctaveWorly(p, 3, 120., 0.6, 0.5), 0.) * step_size * GetHeightFalloff(p.y, cloud_height, cloud_thickness);\n\n                // checking if the current sample point is in a cloud (within the container of clouds)\n                if (density > 0.)\n                {\n                    // sun is upwards\n                    if (sun_derection.y > 0.)\n                    {\n                        // finding the distance through the cloud going in ther direction of the sun\n                        dst_to_sun_through_cloud = (cloud_thickness - (p.y - cloud_height)) / sun_derection.y;\n                    }\n                    // sun is downwards\n                    else\n                    {\n                        // finding the distance through the cloud going in ther direction of the sun\n                        dst_to_sun_through_cloud = (p.y - cloud_height) / abs(sun_derection.y);\n                    }\n                    // finding the step size through the cloud going twords the sun\n                    sun_step_size = dst_to_sun_through_cloud / float(sun_steps);\n                    point_sun_step_size = sun_derection * sun_step_size;\n\n                    // resetting some veriables for lighting\n                    density_in_cloud = 0.;\n                    // stepping through the cloud twords the sun\n                    for (int sun_step = 0; sun_step < sun_steps; sun_step++)\n                    {\n                        // moving twords the sun\n                        p2 += point_sun_step_size;\n                        // finding the density at the current point\n                        density_sun = max(OctaveWorly(p2, 3, 120., 0.6, 0.5), 0.) * sun_step_size * GetHeightFalloff(p.y, cloud_height, cloud_thickness);\n                        // adding up the total density\n                        density_in_cloud += density_sun;\n                    }\n\n                    // finding how much light made it through at this current point\n                    sun_trans = exp(-density_in_cloud * lightApsorbtionToSun);\n\n                    // changing the light\n                    lightTransmittion = sun_trans;\n                    lightEnergy += density * transmittion * lightTransmittion * lightPhase;\n                    // altering the cloud coverage\n                    transmittion *= exp(-density * lightApsorbtion);\n                }\n\n                // increases preformace with no visual change\n                if (transmittion < 0.01)\n                {\n                    break;\n                }\n\n                // moving further through the cloud\n                p += point_step_size;\n            }\n            // finding the new color\n            reflected_image = col * transmittion + cloud_color * lightEnergy;\n        }\n        // the reflection dosent acount for anything\n        else\n        {\n            // setting the reflected color to the color of the sky\n            reflected_image = col;\n        }\n        reflected_image = col;\n        \n        // darkening the water color to acount for refraction (isnt at all physically correct)\n        water_color = mix(water_color, vec3(0.1, 0.1, 0.35), clamp(abs(rd.y + 0.05) * 2., 0., 1.));\n        \n        // adding in the reflected color\n        vec3 final_water_col = mix(water_color, reflected_image, ref);\n        // setting the color of the ocean\n        col = final_water_col * tr * map(dot(water_normal, sun_derection), -1., 1., 0.25, 1.75) * max(diffseLighting, 0.4) + sun_col * specularHighlight;\n    }\n    \n    // chekcing if the cloud/clouds are in view\n    if (in_cloud)\n    {\n        // finding the step size\n        float step_size = min(dst_through_cloud / float(steps), 15.);\n        vec3 point_step_size = rd * step_size;\n        \n        // initializing some veriables\n        float transmittion = 1.;\n        float lightEnergy = 0.;\n        \n        // some peramaters related to transparency of the cloud and brightness\n        float lightApsorbtionToSun = 0.235;\n        float lightApsorbtion = 0.165;\n        float lightPhase = map(clamp(pow(dot(sun_derection, rd), 7.5), 0., 1.), 0., 1., 0.21, 0.5);//0.21;\n        \n        // the color of the cloud\n        vec3 cloud_color = sun_col;  // vec3(1., 0.9, 0.85);\n\n        // the starting position\n        vec3 p = camera_pos + rd * dst_to_cloud;\n        \n        // initializing some veriables that are going to be used later\n        \n        float density, dst_to_sun_through_cloud, lightTransmittion, density_in_cloud, sun_step_size, density_sun, sun_trans;\n        vec3 point_sun_step_size, p2;\n        \n        // stepping through the cloud\n        for (int s = 0; s < steps; s++)\n        {\n            p2 = vec3(p.x, p.y, p.z);\n            \n            // finding the density at this point using worly noise\n            density = max(OctaveWorly(p, 3, 120., 0.6, 0.5), 0.) * step_size * GetHeightFalloff(p.y, cloud_height, cloud_thickness);\n\n            // checking if the current sample point is in a cloud (within the container of clouds)\n            if (density > 0.)\n            {\n                // sun is upwards\n                if (sun_derection.y > 0.)\n                {\n                    // finding the distance through the cloud going in ther direction of the sun\n                    dst_to_sun_through_cloud = (cloud_thickness - (p.y - cloud_height)) / sun_derection.y;\n                }\n                // sun is downwards\n                else\n                {\n                    // finding the distance through the cloud going in ther direction of the sun\n                    dst_to_sun_through_cloud = (p.y - cloud_height) / abs(sun_derection.y);\n                }\n                // finding the step size through the cloud going twords the sun\n                sun_step_size = dst_to_sun_through_cloud / float(sun_steps);\n                point_sun_step_size = sun_derection * sun_step_size;\n            \n                // resetting some veriables for lighting\n                density_in_cloud = 0.;\n                // stepping through the cloud twords the sun\n                for (int sun_step = 0; sun_step < sun_steps; sun_step++)\n                {\n                    // moving twords the sun\n                    p2 += point_sun_step_size;\n                    // finding the density at the current point\n                    density_sun = max(OctaveWorly(p2, 3, 120., 0.6, 0.5), 0.) * sun_step_size * GetHeightFalloff(p.y, cloud_height, cloud_thickness);\n                    // adding up the total density\n                    density_in_cloud += density_sun;\n                }\n                // finding how much light made it through at this current point\n                sun_trans = exp(-density_in_cloud * lightApsorbtionToSun);\n                \n                // changing the light\n                lightTransmittion = sun_trans;\n                lightEnergy += density * transmittion * lightTransmittion * lightPhase;\n                // altering the cloud coverage\n                transmittion *= exp(-density * lightApsorbtion);\n            }\n\n            // increases preformace with no visual change\n            if (transmittion < 0.01)\n            {\n                break;\n            }\n\n            // moving further through the cloud\n            p += point_step_size;\n        }\n        // finding the new color\n        col = col * transmittion + cloud_color * lightEnergy;\n    }\n        \n    // setting the pixels color\n    fragColor = vec4(col,1.0);\n}\n\n", "image_inputs": [{"id": "XsfGRn", "previewfilepath": "/media/ap/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg", "channel": 3, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg", "ctype": "texture"}, {"id": "Xsf3zn", "previewfilepath": "/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture"}, {"id": "4df3Rr", "previewfilepath": "/media/ap/3871e838723dd6b166e490664eead8ec60aedd6b8d95bc8e2fe3f882f0fd90f0.jpg", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/3871e838723dd6b166e490664eead8ec60aedd6b8d95bc8e2fe3f882f0fd90f0.jpg", "ctype": "texture"}, {"id": "Xsf3Rr", "previewfilepath": "/media/ap/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/Nd23Rd.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "Nd23Wt", "name": "test_sin_dist", "author": "NinjaPhillipe", "description": "4 point", "tags": ["dist"], "likes": 0, "viewed": 28, "date": "1618138132", "time_retrieved": "2024-06-20T20:37:33.851129", "image_code": "\nfloat get_fact(float d)\n{\n    return abs(sin(d*30.0)) + 0.3;\n}\n\nvec2 get_sin_pos(float x,float y)\n{\n    float a = 10.0;\n    return vec2(x+sin(iTime)/10.0,y+cos(iTime)/10.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 mouse = iMouse.xy/iResolution.xy;\n \n       \n    vec3 blue = vec3(0.239,0.553,0.808);\n    float gamma = sin(iTime)/20.0 + 0.15;\n    \n    // Source pos\n    vec2 pos0 = get_sin_pos(0.25,0.5);\n    vec2 pos1 = get_sin_pos(0.75,0.5);\n    vec2 pos2 = get_sin_pos(0.5,0.25);\n    vec2 pos3 = get_sin_pos(0.5,0.75);\n    \n\n    // distance \n    float d0 = length(pos0-uv) - (iTime/10.0);\n    float d1 = length(pos1-uv) - (iTime/10.0);\n    float d2 = length(pos2-uv) - (iTime/10.0);\n    float d3 = length(pos3-uv) - (iTime/10.0);\n    \n    // normalize dist \n    vec4 norm_dist = normalize(vec4(d0,d1,d2,d3));\n    \n    // \n    float fact = ( norm_dist[0]*get_fact(d0) ) +\n                ( norm_dist[1]*get_fact(d1) ) +\n                ( norm_dist[2]*get_fact(d2) ) +\n                ( norm_dist[3]*get_fact(d3) );\n    \n    \n    \n    vec3 color = (1.0-gamma)*blue + gamma*vec3(0.12,0.53,0.76)*fact;\n\n\n    // Output to screen\n    fragColor = vec4(color,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/Nd23Wt.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "Nd23zG", "name": "Unit circle with different norms", "author": "theott", "description": "The unit circle is drawn under varying distance function. The p norm (https://en.wikipedia.org/wiki/Norm_(mathematics)#p-norm) is used with p smoothly varying in [0.1,2.1]. The scalar product is also varying between Euclidian and Lorenzian.   ", "tags": ["norm", "conics", "cirlce", "lorenzian"], "likes": 2, "viewed": 51, "date": "1617574813", "time_retrieved": "2024-06-20T20:37:34.039072", "image_code": "float len(vec2 v, float p, float l){\n    return pow(abs(pow(abs(v.x),p) + l * pow(abs(v.y),p)) ,1./p);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from -1 to 1)\n    vec2 uv = ( 2.* fragCoord - iResolution.xy ) / iResolution.y;\n\n    // Background\n    vec3 col = vec3(0);\n\n    // Circle\n    // alliased line:\n    //col += step(abs(len(uv, sin(iTime)+1.1, cos(iTime / 2.)) - .1), .01);\n    // smooth line\n    //col += smoothstep(3./iResolution.y, 0., abs(len(uv, sin(iTime)+1.1, cos(iTime / 2.)) - .1));\n    // adaptive smooth line\n    float v = len(uv, sin(iTime)+1.1, cos(iTime / 2.)) - .1;\n    col +=  smoothstep(1.3, 0., abs(v)/fwidth(v) );\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/Nd23zG.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "Nd2GWW", "name": "Rainbow feathers 2", "author": "jarble", "description": "A simple fractal formula.\nFull-screen mode recommended.", "tags": ["fractal", "rainbow", "feather"], "likes": 2, "viewed": 154, "date": "1617411022", "time_retrieved": "2024-06-20T20:37:34.039072", "image_code": "\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.0);\n    vec3 col;\n    float t = iTime;\n    vec2 uv = (fragCoord*10.0-iResolution.xy)/iResolution.y/10.0;\n    uv += vec2(t/2.0,t/3.0)/4.0;\n    for(int c=0;c<3;c++){\n        float scale = 5.5;\n        float scale1 = 1.4;\n        float s1 = scale1*scale;\n        for(int i=0;i<6;i++)\n        {\n            uv = fract(uv/s1)*s1;\n            uv=-fract(uv/(2.0-abs((uv.x-uv.y)/(16.0)))-(uv/(2.5+(fract(uv.x+uv.y))))/scale)*scale/scale1+s1;\n            uv /= scale1+col.yx;\n        \tuv=uv.yx+col.xy;\n            uv.x *= -(1.0+col.x/scale);\n            col[c] = fract((.25*col.x+uv.y-uv.x)/2.5);\n        }\n     \n\t}\n    \n    fragColor = vec4(vec3(col),1.0);\n    \n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/Nd2GWW.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "Nd2GWz", "name": "Aphantasia #2", "author": "eps", "description": "Aphantasia = inability to visualize mental images. The word is processed by text2image neural network (CLIP) => parameterized to CPPN and exported to GLSL. original technique https://github.com/wxs/cppn-to-glsl", "tags": ["neuralnet", "cppn", "text2image"], "likes": 9, "viewed": 209, "date": "1617240827", "time_retrieved": "2024-06-20T20:37:35.161254", "image_code": "\n#ifdef GL_ES\nprecision lowp float;\n#endif\n\n#define N_HIDDEN 20\nvec4 bufA[N_HIDDEN/4];\nvec4 bufB[N_HIDDEN/2];\nvec4 cppn_fn(vec2 coordinate, float in0, float in1, float in2, float in3) {\n    vec4 tmp;\n    bufB[0] = vec4(coordinate.x, coordinate.y, 0., 0.);\n\n // layer 0 \nbufA[0] = vec4(0.168, -0.039, 0.221, 0.149) + mat4(vec4(0.643, -0.173, 0.641, 0.778), vec4(0.441, -0.586, -0.607, -0.029), vec4(0.000, 0.000, 0.000, 0.000), vec4(0.000, 0.000, 0.000, 0.000)) * bufB[0];\nbufA[1] = vec4(-0.417, -0.331, 0.139, 0.113) + mat4(vec4(1.235, 1.022, -0.127, -0.834), vec4(0.723, 1.010, 0.678, 1.502), vec4(0.000, 0.000, 0.000, 0.000), vec4(0.000, 0.000, 0.000, 0.000)) * bufB[0];\nbufA[2] = vec4(-0.402, -0.425, 0.217, -0.270) + mat4(vec4(0.208, 0.412, -1.020, 0.182), vec4(0.476, -0.875, 0.948, 0.481), vec4(0.000, 0.000, 0.000, 0.000), vec4(0.000, 0.000, 0.000, 0.000)) * bufB[0];\nbufA[3] = vec4(-0.257, -0.085, -0.166, -0.141) + mat4(vec4(-0.599, 1.075, -0.373, -0.874), vec4(-0.270, 0.138, 0.373, 0.346), vec4(0.000, 0.000, 0.000, 0.000), vec4(0.000, 0.000, 0.000, 0.000)) * bufB[0];\nbufA[4] = vec4(-0.144, -0.058, 0.421, 0.453) + mat4(vec4(-0.150, 0.331, -0.337, 0.181), vec4(0.151, 0.058, -0.747, 0.629), vec4(0.000, 0.000, 0.000, 0.000), vec4(0.000, 0.000, 0.000, 0.000)) * bufB[0];\ntmp = atan(bufA[0]);\nbufB[0] = tmp/0.67;\nbufB[5] = (tmp*tmp - 0.45) / 0.396;\ntmp = atan(bufA[1]);\nbufB[1] = tmp/0.67;\nbufB[6] = (tmp*tmp - 0.45) / 0.396;\ntmp = atan(bufA[2]);\nbufB[2] = tmp/0.67;\nbufB[7] = (tmp*tmp - 0.45) / 0.396;\ntmp = atan(bufA[3]);\nbufB[3] = tmp/0.67;\nbufB[8] = (tmp*tmp - 0.45) / 0.396;\ntmp = atan(bufA[4]);\nbufB[4] = tmp/0.67;\nbufB[9] = (tmp*tmp - 0.45) / 0.396;\n\n // layer 1 \nbufA[0] = vec4(0.325, -0.509, -0.167, -0.302) + mat4(vec4(-0.203, 0.226, -0.037, 0.132), vec4(-0.011, 0.071, 0.102, 0.325), vec4(-0.111, -0.433, -0.115, 0.328), vec4(0.124, -0.089, 0.144, 0.096)) * bufB[0] + mat4(vec4(-0.218, 0.222, -0.313, -0.279), vec4(-0.060, 0.375, -0.125, -0.278), vec4(0.063, 0.072, -0.045, 0.132), vec4(-0.035, -0.171, -0.007, 0.021)) * bufB[1] + mat4(vec4(0.182, 0.033, -0.099, 0.216), vec4(0.034, -0.161, 0.169, -0.308), vec4(-0.001, 0.181, -0.057, -0.063), vec4(-0.129, 0.176, -0.003, 0.082)) * bufB[2] + mat4(vec4(0.170, 0.015, -0.196, 0.022), vec4(-0.234, -0.128, 0.120, -0.187), vec4(0.069, 0.161, -0.126, -0.365), vec4(0.126, -0.107, -0.015, 0.099)) * bufB[3] + mat4(vec4(-0.029, -0.225, -0.045, -0.166), vec4(-0.237, 0.081, 0.159, -0.160), vec4(-0.112, -0.199, -0.016, -0.280), vec4(-0.134, 0.108, -0.026, 0.160)) * bufB[4] + mat4(vec4(-0.045, 0.014, 0.366, 0.061), vec4(-0.217, -0.020, 0.271, -0.179), vec4(-0.177, -0.278, -0.036, 0.073), vec4(-0.152, -0.097, 0.054, -0.204)) * bufB[5] + mat4(vec4(-0.365, -0.201, -0.187, -0.208), vec4(-0.126, 0.036, 0.005, -0.212), vec4(0.131, -0.167, 0.018, -0.066), vec4(-0.304, 0.293, 0.291, 0.326)) * bufB[6] + mat4(vec4(0.104, -0.137, -0.042, 0.270), vec4(-0.024, -0.160, -0.017, 0.153), vec4(-0.092, -0.177, 0.040, 0.290), vec4(0.211, -0.022, 0.146, -0.033)) * bufB[7] + mat4(vec4(0.020, -0.052, -0.113, -0.138), vec4(-0.454, -0.178, -0.129, -0.052), vec4(0.105, 0.154, 0.025, 0.001), vec4(-0.287, -0.177, -0.098, 0.301)) * bufB[8] + mat4(vec4(-0.116, 0.366, 0.315, 0.015), vec4(-0.079, -0.111, 0.157, -0.048), vec4(0.362, -0.102, -0.002, -0.230), vec4(0.155, -0.275, 0.124, -0.374)) * bufB[9];\nbufA[1] = vec4(-0.361, 0.139, 0.029, -0.378) + mat4(vec4(-0.064, -0.239, -0.097, 0.252), vec4(-0.130, 0.189, 0.033, -0.157), vec4(0.092, -0.289, 0.211, -0.116), vec4(-0.371, -0.163, -0.029, 0.135)) * bufB[0] + mat4(vec4(-0.236, 0.119, 0.114, 0.022), vec4(0.120, -0.115, -0.188, -0.078), vec4(0.026, 0.145, 0.039, 0.055), vec4(-0.076, -0.060, 0.277, 0.276)) * bufB[1] + mat4(vec4(-0.091, -0.123, 0.165, -0.086), vec4(0.272, 0.175, 0.294, -0.109), vec4(-0.128, -0.091, -0.169, 0.023), vec4(-0.108, 0.194, -0.008, 0.328)) * bufB[2] + mat4(vec4(-0.172, -0.091, -0.173, 0.032), vec4(0.206, -0.316, 0.189, -0.243), vec4(0.060, -0.162, -0.087, -0.052), vec4(-0.118, 0.080, 0.273, -0.309)) * bufB[3] + mat4(vec4(-0.139, -0.039, 0.148, 0.072), vec4(0.399, 0.083, -0.325, -0.089), vec4(-0.093, 0.029, -0.264, -0.025), vec4(0.220, 0.071, -0.062, 0.058)) * bufB[4] + mat4(vec4(-0.085, -0.065, -0.074, -0.013), vec4(-0.097, -0.016, -0.094, 0.154), vec4(-0.290, 0.155, -0.189, 0.057), vec4(-0.236, -0.017, -0.062, -0.079)) * bufB[5] + mat4(vec4(0.173, 0.125, -0.145, -0.119), vec4(0.149, -0.064, -0.188, -0.086), vec4(0.267, 0.085, -0.193, -0.163), vec4(0.244, 0.190, -0.170, 0.439)) * bufB[6] + mat4(vec4(-0.060, 0.130, -0.084, 0.080), vec4(0.061, 0.208, 0.096, -0.053), vec4(0.063, 0.204, -0.211, -0.352), vec4(0.091, 0.051, -0.090, 0.156)) * bufB[7] + mat4(vec4(-0.170, 0.073, 0.143, 0.458), vec4(-0.279, -0.137, -0.334, -0.076), vec4(-0.252, -0.106, -0.081, -0.097), vec4(-0.492, 0.136, -0.335, 0.175)) * bufB[8] + mat4(vec4(-0.148, 0.022, -0.270, 0.076), vec4(-0.066, -0.113, -0.055, -0.046), vec4(0.242, -0.141, -0.115, 0.323), vec4(-0.018, -0.035, 0.144, 0.170)) * bufB[9];\nbufA[2] = vec4(0.216, -0.251, -0.434, 0.355) + mat4(vec4(0.287, -0.001, -0.021, 0.132), vec4(0.218, -0.093, 0.174, -0.083), vec4(-0.163, 0.148, 0.025, 0.222), vec4(-0.200, 0.069, -0.154, 0.100)) * bufB[0] + mat4(vec4(0.199, 0.299, 0.094, 0.081), vec4(-0.002, 0.035, 0.313, -0.202), vec4(0.035, 0.286, 0.223, 0.236), vec4(-0.157, -0.186, 0.078, 0.044)) * bufB[1] + mat4(vec4(0.079, -0.031, -0.096, 0.229), vec4(0.105, 0.217, -0.055, 0.077), vec4(-0.154, -0.098, -0.105, 0.032), vec4(0.029, 0.107, -0.055, -0.249)) * bufB[2] + mat4(vec4(-0.367, 0.063, -0.236, -0.045), vec4(0.083, -0.104, 0.023, 0.199), vec4(0.016, 0.227, -0.110, 0.179), vec4(-0.053, -0.092, 0.093, -0.249)) * bufB[3] + mat4(vec4(0.095, 0.033, -0.084, 0.066), vec4(0.251, -0.105, 0.116, 0.018), vec4(-0.049, -0.056, 0.025, 0.007), vec4(-0.292, 0.164, 0.268, 0.135)) * bufB[4] + mat4(vec4(-0.116, -0.212, -0.029, 0.231), vec4(0.397, 0.313, -0.064, 0.151), vec4(-0.115, 0.049, -0.328, 0.172), vec4(-0.231, -0.147, 0.153, 0.110)) * bufB[5] + mat4(vec4(-0.344, 0.167, -0.257, 0.190), vec4(-0.512, 0.111, 0.083, 0.151), vec4(0.213, -0.249, 0.163, -0.091), vec4(-0.298, -0.009, 0.033, -0.217)) * bufB[6] + mat4(vec4(0.100, -0.115, -0.023, -0.193), vec4(0.039, 0.257, 0.105, -0.294), vec4(0.114, 0.291, 0.189, -0.123), vec4(-0.233, -0.231, -0.184, 0.178)) * bufB[7] + mat4(vec4(-0.199, 0.015, 0.108, 0.218), vec4(-0.122, 0.031, -0.094, 0.095), vec4(0.061, 0.048, -0.174, -0.073), vec4(0.048, 0.123, -0.131, 0.224)) * bufB[8] + mat4(vec4(0.259, 0.029, -0.221, -0.252), vec4(0.035, 0.250, 0.000, 0.086), vec4(-0.237, -0.211, -0.202, 0.120), vec4(0.100, -0.279, 0.115, -0.033)) * bufB[9];\nbufA[3] = vec4(-0.064, 0.179, 0.449, 0.351) + mat4(vec4(0.072, -0.237, -0.004, 0.151), vec4(0.345, -0.094, 0.166, 0.001), vec4(-0.048, 0.134, 0.055, -0.166), vec4(-0.008, -0.097, 0.246, -0.025)) * bufB[0] + mat4(vec4(-0.145, 0.127, -0.166, 0.004), vec4(-0.134, -0.118, 0.141, -0.020), vec4(0.060, 0.403, 0.021, 0.110), vec4(-0.254, 0.227, -0.015, 0.409)) * bufB[1] + mat4(vec4(0.090, -0.037, -0.003, -0.249), vec4(-0.047, 0.010, -0.095, 0.031), vec4(-0.115, -0.215, -0.056, 0.042), vec4(-0.108, -0.035, -0.138, -0.188)) * bufB[2] + mat4(vec4(0.022, 0.091, 0.011, -0.162), vec4(0.073, 0.148, 0.011, 0.021), vec4(0.082, -0.087, -0.240, -0.008), vec4(0.011, 0.069, 0.079, 0.450)) * bufB[3] + mat4(vec4(0.193, -0.219, 0.058, 0.168), vec4(-0.173, 0.099, 0.225, -0.061), vec4(-0.005, -0.016, -0.014, 0.114), vec4(0.178, 0.176, -0.004, -0.110)) * bufB[4] + mat4(vec4(0.058, 0.033, -0.220, 0.166), vec4(-0.141, -0.142, -0.037, 0.101), vec4(-0.160, -0.334, 0.124, -0.349), vec4(0.050, -0.055, -0.110, 0.214)) * bufB[5] + mat4(vec4(0.000, 0.146, 0.013, -0.016), vec4(-0.033, -0.059, -0.113, 0.081), vec4(-0.278, -0.030, -0.384, -0.172), vec4(-0.008, -0.104, 0.316, -0.490)) * bufB[6] + mat4(vec4(0.264, -0.231, -0.046, -0.145), vec4(0.244, 0.142, -0.090, -0.153), vec4(0.080, -0.197, 0.025, -0.164), vec4(-0.067, -0.002, -0.158, -0.045)) * bufB[7] + mat4(vec4(-0.041, -0.035, -0.101, 0.017), vec4(0.041, -0.321, -0.249, 0.035), vec4(-0.001, -0.149, -0.169, 0.314), vec4(0.505, -0.115, -0.021, -0.062)) * bufB[8] + mat4(vec4(0.141, -0.000, -0.180, -0.297), vec4(-0.304, 0.002, 0.026, 0.145), vec4(0.246, 0.080, 0.134, -0.014), vec4(-0.102, 0.041, 0.004, -0.295)) * bufB[9];\nbufA[4] = vec4(0.439, 0.394, -0.122, -0.253) + mat4(vec4(0.248, 0.040, -0.043, 0.114), vec4(-0.182, -0.248, 0.068, 0.011), vec4(-0.137, 0.097, -0.003, -0.062), vec4(-0.018, -0.030, 0.116, -0.330)) * bufB[0] + mat4(vec4(0.135, 0.085, 0.143, 0.067), vec4(0.294, 0.063, -0.186, 0.346), vec4(0.212, 0.280, 0.100, -0.074), vec4(-0.183, 0.517, 0.078, 0.002)) * bufB[1] + mat4(vec4(0.038, 0.270, -0.220, -0.038), vec4(0.165, -0.178, 0.379, -0.001), vec4(-0.083, 0.171, 0.140, -0.025), vec4(0.027, 0.376, 0.252, 0.141)) * bufB[2] + mat4(vec4(0.446, 0.016, 0.160, -0.078), vec4(0.149, -0.192, 0.205, -0.019), vec4(0.005, -0.125, 0.111, -0.156), vec4(-0.136, 0.162, 0.331, 0.023)) * bufB[3] + mat4(vec4(-0.001, -0.123, 0.093, 0.028), vec4(0.153, -0.114, -0.139, -0.038), vec4(-0.344, -0.078, 0.151, -0.053), vec4(-0.139, 0.175, 0.100, -0.224)) * bufB[4] + mat4(vec4(-0.098, 0.252, 0.220, 0.170), vec4(0.204, 0.036, -0.075, -0.019), vec4(0.182, -0.145, 0.101, -0.014), vec4(-0.335, -0.244, -0.238, 0.021)) * bufB[5] + mat4(vec4(-0.609, -0.108, 0.239, 0.212), vec4(-0.097, -0.291, 0.141, -0.014), vec4(-0.356, -0.112, -0.027, 0.128), vec4(-0.005, 0.142, -0.089, 0.019)) * bufB[6] + mat4(vec4(-0.034, 0.055, -0.125, -0.163), vec4(-0.038, 0.338, 0.139, 0.256), vec4(-0.021, 0.103, -0.314, 0.189), vec4(-0.008, 0.198, -0.008, -0.038)) * bufB[7] + mat4(vec4(0.019, -0.259, 0.001, -0.069), vec4(-0.083, 0.151, 0.044, -0.065), vec4(-0.046, -0.024, -0.404, 0.077), vec4(0.327, 0.153, -0.269, 0.078)) * bufB[8] + mat4(vec4(-0.019, -0.143, 0.005, -0.092), vec4(0.348, -0.203, -0.107, -0.096), vec4(-0.272, -0.087, 0.064, 0.191), vec4(0.138, 0.132, 0.023, 0.090)) * bufB[9];\ntmp = atan(bufA[0]);\nbufB[0] = tmp/0.67;\nbufB[5] = (tmp*tmp - 0.45) / 0.396;\ntmp = atan(bufA[1]);\nbufB[1] = tmp/0.67;\nbufB[6] = (tmp*tmp - 0.45) / 0.396;\ntmp = atan(bufA[2]);\nbufB[2] = tmp/0.67;\nbufB[7] = (tmp*tmp - 0.45) / 0.396;\ntmp = atan(bufA[3]);\nbufB[3] = tmp/0.67;\nbufB[8] = (tmp*tmp - 0.45) / 0.396;\ntmp = atan(bufA[4]);\nbufB[4] = tmp/0.67;\nbufB[9] = (tmp*tmp - 0.45) / 0.396;\n\n // layer 2 \nbufA[0] = vec4(0.429, 0.467, -0.447, -0.103) + mat4(vec4(-0.100, 0.199, 0.178, 0.019), vec4(0.251, -0.115, 0.255, -0.250), vec4(-0.044, 0.110, -0.123, -0.017), vec4(-0.011, -0.050, -0.050, -0.118)) * bufB[0] + mat4(vec4(-0.002, -0.394, 0.021, -0.323), vec4(0.106, -0.078, -0.153, 0.032), vec4(-0.152, 0.013, 0.011, 0.167), vec4(-0.029, -0.253, 0.176, -0.022)) * bufB[1] + mat4(vec4(0.085, -0.026, 0.134, -0.064), vec4(-0.000, 0.051, -0.010, 0.012), vec4(-0.077, -0.247, 0.221, 0.139), vec4(-0.114, 0.032, 0.119, -0.176)) * bufB[2] + mat4(vec4(-0.137, -0.051, -0.007, -0.087), vec4(-0.152, -0.077, 0.108, 0.045), vec4(-0.108, 0.224, -0.079, -0.012), vec4(0.275, -0.143, -0.089, 0.004)) * bufB[3] + mat4(vec4(-0.019, 0.032, 0.160, -0.107), vec4(0.211, -0.264, 0.284, -0.050), vec4(0.081, 0.027, -0.011, -0.226), vec4(0.069, 0.266, 0.189, 0.300)) * bufB[4] + mat4(vec4(0.025, -0.082, -0.129, -0.117), vec4(-0.017, 0.019, -0.044, -0.282), vec4(-0.002, -0.180, -0.119, -0.044), vec4(-0.011, -0.023, -0.217, 0.129)) * bufB[5] + mat4(vec4(-0.213, -0.066, 0.072, -0.086), vec4(-0.064, 0.312, -0.114, 0.061), vec4(0.174, 0.080, 0.475, -0.163), vec4(0.176, -0.021, -0.122, 0.078)) * bufB[6] + mat4(vec4(0.039, 0.050, -0.112, -0.188), vec4(0.194, 0.238, 0.027, 0.045), vec4(0.108, 0.094, 0.252, -0.048), vec4(-0.234, -0.025, 0.113, 0.097)) * bufB[7] + mat4(vec4(0.240, -0.179, 0.161, -0.317), vec4(-0.106, 0.079, 0.026, 0.109), vec4(-0.104, -0.140, -0.167, -0.031), vec4(0.570, 0.009, -0.108, -0.336)) * bufB[8] + mat4(vec4(0.033, 0.094, 0.244, -0.050), vec4(0.221, -0.026, -0.168, -0.094), vec4(0.027, -0.010, -0.464, 0.046), vec4(-0.137, -0.130, 0.124, 0.115)) * bufB[9];\nbufA[1] = vec4(0.354, 0.158, -0.030, 0.003) + mat4(vec4(-0.011, 0.128, 0.143, 0.022), vec4(0.143, 0.015, 0.200, -0.216), vec4(-0.050, 0.163, -0.101, 0.227), vec4(0.372, -0.079, 0.065, 0.183)) * bufB[0] + mat4(vec4(0.140, -0.096, 0.072, -0.111), vec4(-0.285, -0.035, -0.196, 0.329), vec4(0.293, -0.204, 0.228, 0.114), vec4(-0.149, 0.063, -0.052, -0.185)) * bufB[1] + mat4(vec4(0.063, 0.305, 0.055, -0.128), vec4(-0.095, -0.078, 0.177, -0.092), vec4(-0.008, -0.100, 0.083, -0.072), vec4(-0.075, 0.154, -0.378, 0.015)) * bufB[2] + mat4(vec4(0.072, -0.006, -0.179, 0.180), vec4(0.222, -0.135, 0.091, -0.069), vec4(-0.118, -0.309, 0.109, 0.082), vec4(-0.009, 0.183, 0.116, 0.024)) * bufB[3] + mat4(vec4(-0.091, 0.211, 0.015, -0.020), vec4(-0.242, -0.244, 0.181, 0.069), vec4(0.199, 0.168, -0.033, -0.103), vec4(-0.193, -0.096, 0.153, -0.128)) * bufB[4] + mat4(vec4(-0.341, -0.132, 0.070, -0.023), vec4(0.056, 0.169, -0.127, 0.175), vec4(0.003, -0.228, -0.124, 0.159), vec4(-0.070, 0.189, -0.130, 0.097)) * bufB[5] + mat4(vec4(0.297, -0.181, 0.015, 0.180), vec4(-0.089, 0.153, -0.153, 0.047), vec4(0.122, 0.021, -0.072, -0.025), vec4(-0.068, 0.079, 0.026, 0.153)) * bufB[6] + mat4(vec4(0.049, 0.097, -0.262, 0.211), vec4(-0.158, 0.016, 0.265, 0.091), vec4(-0.142, -0.039, 0.036, -0.185), vec4(-0.007, 0.028, 0.106, -0.136)) * bufB[7] + mat4(vec4(-0.082, -0.002, -0.207, -0.146), vec4(-0.196, -0.201, 0.082, -0.029), vec4(-0.044, 0.033, 0.069, -0.116), vec4(-0.056, -0.049, -0.112, 0.229)) * bufB[8] + mat4(vec4(-0.360, 0.298, -0.170, 0.171), vec4(0.167, -0.003, -0.042, -0.181), vec4(-0.217, 0.067, -0.147, 0.001), vec4(0.137, 0.078, 0.044, 0.029)) * bufB[9];\nbufA[2] = vec4(-0.419, -0.399, -0.292, -0.058) + mat4(vec4(0.062, -0.331, -0.348, -0.159), vec4(-0.056, -0.154, -0.007, 0.059), vec4(0.112, 0.080, -0.236, 0.128), vec4(-0.122, 0.031, 0.162, -0.109)) * bufB[0] + mat4(vec4(-0.265, 0.164, -0.348, -0.069), vec4(-0.215, -0.084, -0.142, -0.181), vec4(0.082, 0.103, -0.061, 0.122), vec4(0.155, -0.050, -0.212, -0.161)) * bufB[1] + mat4(vec4(0.248, -0.206, 0.030, -0.329), vec4(0.100, -0.074, 0.410, 0.203), vec4(-0.320, 0.098, 0.235, 0.119), vec4(0.338, -0.187, -0.135, -0.042)) * bufB[2] + mat4(vec4(-0.018, -0.186, 0.022, 0.018), vec4(-0.147, -0.055, 0.036, -0.022), vec4(0.116, 0.060, 0.424, -0.013), vec4(-0.318, 0.107, 0.183, 0.387)) * bufB[3] + mat4(vec4(-0.021, 0.087, -0.127, -0.051), vec4(0.028, 0.259, 0.106, 0.135), vec4(0.298, 0.080, 0.067, 0.236), vec4(-0.027, -0.049, -0.097, -0.269)) * bufB[4] + mat4(vec4(0.277, -0.070, 0.340, -0.012), vec4(0.150, -0.148, -0.084, 0.210), vec4(0.126, -0.108, 0.185, 0.185), vec4(-0.248, 0.022, -0.102, -0.094)) * bufB[5] + mat4(vec4(0.081, -0.076, -0.213, 0.217), vec4(-0.226, -0.025, -0.251, 0.044), vec4(0.207, 0.033, 0.049, 0.148), vec4(0.168, -0.183, 0.025, -0.098)) * bufB[6] + mat4(vec4(0.039, 0.042, -0.118, -0.098), vec4(0.019, -0.265, -0.055, 0.151), vec4(0.171, -0.039, -0.163, -0.086), vec4(0.178, 0.189, 0.099, 0.191)) * bufB[7] + mat4(vec4(-0.066, 0.291, -0.230, -0.089), vec4(0.153, 0.147, 0.087, -0.076), vec4(-0.046, -0.252, 0.085, 0.125), vec4(-0.133, 0.171, -0.235, 0.164)) * bufB[8] + mat4(vec4(0.401, -0.109, -0.075, -0.103), vec4(-0.425, -0.142, -0.128, -0.037), vec4(0.086, 0.153, -0.103, 0.166), vec4(0.120, -0.070, 0.000, -0.304)) * bufB[9];\nbufA[3] = vec4(-0.263, 0.169, -0.353, -0.280) + mat4(vec4(-0.012, -0.223, -0.079, -0.092), vec4(-0.065, 0.120, -0.105, -0.286), vec4(-0.129, -0.220, 0.058, 0.257), vec4(0.139, 0.086, -0.283, -0.303)) * bufB[0] + mat4(vec4(0.098, -0.139, -0.040, 0.134), vec4(0.072, -0.143, 0.191, 0.089), vec4(0.074, -0.024, -0.023, 0.006), vec4(0.122, 0.032, -0.164, 0.131)) * bufB[1] + mat4(vec4(0.172, -0.114, -0.041, 0.013), vec4(0.048, 0.197, -0.001, 0.148), vec4(0.052, -0.185, -0.340, -0.181), vec4(-0.224, 0.059, -0.018, 0.009)) * bufB[2] + mat4(vec4(-0.020, 0.189, -0.052, 0.015), vec4(-0.139, -0.239, 0.132, 0.031), vec4(0.029, 0.078, 0.128, -0.027), vec4(-0.079, -0.305, 0.153, -0.056)) * bufB[3] + mat4(vec4(0.059, -0.083, -0.247, 0.317), vec4(-0.329, -0.206, 0.073, -0.203), vec4(-0.144, -0.072, 0.251, -0.039), vec4(0.186, 0.035, 0.096, -0.146)) * bufB[4] + mat4(vec4(-0.024, 0.150, -0.132, 0.222), vec4(0.090, 0.011, -0.011, 0.314), vec4(0.005, -0.041, -0.193, -0.131), vec4(0.197, 0.281, 0.191, 0.239)) * bufB[5] + mat4(vec4(0.014, 0.076, 0.213, -0.024), vec4(0.117, -0.093, 0.271, 0.014), vec4(-0.086, -0.234, 0.076, 0.027), vec4(-0.005, 0.127, -0.036, -0.001)) * bufB[6] + mat4(vec4(0.012, 0.004, 0.146, -0.193), vec4(0.268, 0.286, 0.236, -0.105), vec4(-0.212, -0.023, 0.189, 0.284), vec4(-0.066, 0.327, -0.023, 0.020)) * bufB[7] + mat4(vec4(-0.054, -0.145, -0.132, -0.055), vec4(-0.091, -0.023, -0.107, 0.023), vec4(0.121, 0.128, -0.126, 0.250), vec4(0.036, -0.056, -0.041, 0.003)) * bufB[8] + mat4(vec4(0.034, -0.128, 0.286, -0.193), vec4(0.039, -0.185, 0.244, 0.091), vec4(-0.037, -0.029, -0.203, -0.174), vec4(-0.030, 0.045, -0.011, -0.044)) * bufB[9];\nbufA[4] = vec4(0.346, -0.057, -0.406, 0.351) + mat4(vec4(-0.178, -0.431, -0.254, 0.012), vec4(-0.018, 0.038, -0.018, -0.177), vec4(-0.141, 0.090, -0.119, -0.141), vec4(-0.242, -0.414, -0.119, -0.212)) * bufB[0] + mat4(vec4(0.219, 0.035, -0.161, -0.155), vec4(0.159, -0.026, -0.018, 0.039), vec4(0.092, -0.081, -0.094, -0.219), vec4(-0.072, 0.182, 0.138, 0.075)) * bufB[1] + mat4(vec4(-0.204, -0.104, -0.264, -0.082), vec4(0.031, 0.077, 0.126, 0.070), vec4(0.260, 0.072, -0.022, -0.092), vec4(0.054, 0.281, 0.213, -0.009)) * bufB[2] + mat4(vec4(-0.049, -0.222, 0.274, -0.090), vec4(0.085, 0.200, -0.009, -0.032), vec4(-0.073, 0.227, -0.050, 0.083), vec4(-0.152, -0.063, -0.036, 0.272)) * bufB[3] + mat4(vec4(-0.172, -0.039, -0.037, -0.133), vec4(-0.125, 0.071, -0.061, -0.203), vec4(0.088, -0.098, 0.112, 0.144), vec4(0.008, 0.185, 0.061, 0.085)) * bufB[4] + mat4(vec4(-0.076, 0.149, -0.486, 0.090), vec4(-0.119, -0.036, 0.129, -0.006), vec4(0.064, 0.103, -0.029, 0.168), vec4(0.057, 0.209, 0.357, -0.134)) * bufB[5] + mat4(vec4(0.335, -0.201, -0.459, -0.147), vec4(-0.078, 0.288, 0.198, 0.030), vec4(-0.185, 0.291, -0.062, -0.066), vec4(-0.149, -0.199, -0.018, 0.141)) * bufB[6] + mat4(vec4(0.524, 0.004, 0.309, 0.145), vec4(-0.122, 0.092, 0.081, 0.226), vec4(-0.026, 0.184, -0.161, -0.155), vec4(0.237, 0.287, 0.023, 0.165)) * bufB[7] + mat4(vec4(-0.152, 0.055, -0.207, 0.026), vec4(-0.143, 0.014, -0.287, 0.170), vec4(-0.169, -0.240, -0.294, -0.083), vec4(-0.359, 0.105, 0.033, 0.271)) * bufB[8] + mat4(vec4(0.167, 0.053, 0.126, 0.081), vec4(0.184, 0.031, -0.008, -0.368), vec4(-0.131, 0.158, -0.099, 0.040), vec4(-0.106, -0.241, 0.040, 0.167)) * bufB[9];\ntmp = atan(bufA[0]);\nbufB[0] = tmp/0.67;\nbufB[5] = (tmp*tmp - 0.45) / 0.396;\ntmp = atan(bufA[1]);\nbufB[1] = tmp/0.67;\nbufB[6] = (tmp*tmp - 0.45) / 0.396;\ntmp = atan(bufA[2]);\nbufB[2] = tmp/0.67;\nbufB[7] = (tmp*tmp - 0.45) / 0.396;\ntmp = atan(bufA[3]);\nbufB[3] = tmp/0.67;\nbufB[8] = (tmp*tmp - 0.45) / 0.396;\ntmp = atan(bufA[4]);\nbufB[4] = tmp/0.67;\nbufB[9] = (tmp*tmp - 0.45) / 0.396;\n\n // layer 3 \nbufA[0] = vec4(0.537, 0.300, 0.110, -0.174) + mat4(vec4(0.308, -0.108, 0.144, 0.154), vec4(0.019, -0.112, 0.030, -0.026), vec4(-0.053, 0.138, 0.136, 0.461), vec4(-0.027, 0.136, 0.184, 0.051)) * bufB[0] + mat4(vec4(0.038, -0.131, -0.409, 0.176), vec4(0.022, -0.213, 0.067, 0.127), vec4(-0.075, 0.038, -0.135, 0.226), vec4(-0.061, 0.111, 0.150, -0.108)) * bufB[1] + mat4(vec4(0.097, 0.314, -0.050, -0.079), vec4(0.093, -0.209, -0.336, -0.154), vec4(-0.073, 0.309, 0.091, 0.206), vec4(0.446, 0.151, -0.004, -0.080)) * bufB[2] + mat4(vec4(0.219, -0.078, 0.253, -0.011), vec4(-0.266, -0.318, 0.189, -0.098), vec4(0.164, 0.183, -0.226, -0.195), vec4(0.038, -0.397, 0.086, -0.071)) * bufB[3] + mat4(vec4(-0.010, 0.204, 0.075, -0.023), vec4(0.229, -0.049, 0.187, 0.204), vec4(0.083, -0.125, -0.094, 0.172), vec4(-0.151, 0.045, -0.069, 0.231)) * bufB[4] + mat4(vec4(-0.085, 0.018, -0.189, 0.042), vec4(0.020, 0.007, -0.088, -0.168), vec4(0.135, -0.156, -0.043, 0.024), vec4(0.152, -0.096, 0.041, -0.182)) * bufB[5] + mat4(vec4(0.075, 0.061, 0.020, -0.115), vec4(-0.002, -0.035, 0.090, 0.099), vec4(0.060, -0.103, -0.031, 0.489), vec4(-0.034, 0.010, 0.075, -0.115)) * bufB[6] + mat4(vec4(-0.093, -0.026, 0.124, -0.055), vec4(-0.162, -0.093, -0.056, -0.204), vec4(-0.171, -0.098, 0.079, 0.429), vec4(-0.293, -0.035, 0.206, -0.203)) * bufB[7] + mat4(vec4(0.138, 0.154, 0.306, -0.131), vec4(-0.186, -0.190, 0.223, -0.065), vec4(-0.325, -0.395, -0.184, -0.031), vec4(-0.148, 0.098, 0.008, -0.145)) * bufB[8] + mat4(vec4(0.015, 0.022, 0.028, -0.419), vec4(-0.078, 0.028, -0.089, -0.277), vec4(0.346, -0.021, 0.079, 0.304), vec4(0.127, -0.064, 0.019, -0.238)) * bufB[9] + in0;\nbufA[1] = vec4(0.317, 0.482, -0.166, 0.149) + mat4(vec4(-0.110, 0.012, 0.239, -0.062), vec4(0.036, -0.095, -0.167, -0.129), vec4(-0.203, 0.117, 0.079, -0.126), vec4(0.276, 0.082, 0.015, 0.202)) * bufB[0] + mat4(vec4(0.322, -0.031, 0.060, 0.011), vec4(0.218, 0.052, 0.089, 0.085), vec4(0.094, 0.190, 0.332, 0.449), vec4(0.006, 0.235, -0.101, 0.146)) * bufB[1] + mat4(vec4(-0.166, -0.248, -0.137, 0.065), vec4(-0.021, 0.089, 0.214, 0.061), vec4(-0.080, 0.192, 0.281, 0.336), vec4(-0.002, 0.090, 0.082, 0.197)) * bufB[2] + mat4(vec4(-0.198, -0.228, -0.215, 0.210), vec4(-0.046, 0.103, -0.440, -0.242), vec4(0.038, -0.051, 0.230, -0.078), vec4(-0.124, -0.110, -0.017, 0.176)) * bufB[3] + mat4(vec4(0.140, 0.175, -0.042, -0.124), vec4(-0.304, -0.184, 0.315, -0.199), vec4(-0.218, 0.083, 0.164, -0.264), vec4(-0.165, -0.056, -0.143, -0.259)) * bufB[4] + mat4(vec4(0.054, 0.121, 0.133, -0.135), vec4(0.172, 0.151, 0.309, -0.087), vec4(-0.248, -0.177, 0.060, -0.147), vec4(-0.061, -0.054, -0.163, -0.075)) * bufB[5] + mat4(vec4(0.130, -0.278, -0.047, 0.182), vec4(-0.069, 0.215, -0.185, 0.316), vec4(-0.096, -0.083, 0.010, 0.081), vec4(-0.243, 0.162, 0.200, -0.192)) * bufB[6] + mat4(vec4(0.058, -0.230, 0.039, 0.024), vec4(-0.111, 0.058, -0.141, 0.128), vec4(0.300, -0.248, -0.284, -0.001), vec4(-0.117, 0.423, 0.241, 0.019)) * bufB[7] + mat4(vec4(-0.174, 0.113, 0.181, 0.064), vec4(-0.391, -0.302, 0.116, -0.112), vec4(-0.129, 0.260, -0.113, -0.172), vec4(-0.096, -0.074, 0.108, -0.042)) * bufB[8] + mat4(vec4(-0.201, -0.001, -0.415, -0.073), vec4(0.051, 0.208, -0.172, -0.080), vec4(-0.018, -0.150, -0.011, -0.013), vec4(-0.131, 0.031, 0.141, -0.086)) * bufB[9] + in1;\nbufA[2] = vec4(-0.034, -0.262, -0.084, -0.092) + mat4(vec4(0.176, -0.203, 0.082, 0.182), vec4(0.120, 0.018, 0.153, -0.164), vec4(-0.025, 0.069, 0.048, -0.208), vec4(-0.254, -0.043, -0.222, -0.192)) * bufB[0] + mat4(vec4(0.031, -0.003, -0.168, 0.040), vec4(0.046, 0.091, 0.077, -0.156), vec4(-0.074, 0.114, -0.015, -0.166), vec4(0.170, -0.170, 0.054, 0.179)) * bufB[1] + mat4(vec4(0.124, -0.059, -0.368, -0.136), vec4(0.023, 0.145, 0.256, -0.154), vec4(0.085, 0.242, 0.081, -0.185), vec4(0.385, 0.122, 0.249, 0.288)) * bufB[2] + mat4(vec4(-0.040, -0.140, 0.303, -0.275), vec4(-0.171, 0.349, 0.078, -0.015), vec4(-0.031, -0.123, 0.130, 0.195), vec4(-0.004, 0.171, 0.105, 0.116)) * bufB[3] + mat4(vec4(0.070, -0.035, -0.044, -0.195), vec4(0.164, 0.162, 0.131, -0.177), vec4(0.247, 0.274, -0.229, -0.115), vec4(-0.159, 0.034, 0.059, 0.267)) * bufB[4] + mat4(vec4(-0.198, 0.192, 0.163, -0.211), vec4(-0.017, 0.090, -0.023, 0.009), vec4(0.127, -0.035, -0.205, 0.262), vec4(0.081, -0.129, -0.073, 0.150)) * bufB[5] + mat4(vec4(-0.052, -0.083, 0.184, -0.142), vec4(0.162, -0.042, 0.060, 0.071), vec4(-0.063, 0.093, -0.060, 0.267), vec4(-0.060, 0.050, 0.018, 0.215)) * bufB[6] + mat4(vec4(0.146, 0.015, -0.194, -0.084), vec4(0.066, -0.253, 0.200, -0.005), vec4(0.117, -0.152, 0.137, -0.089), vec4(0.006, 0.185, 0.025, -0.033)) * bufB[7] + mat4(vec4(0.059, 0.154, 0.059, 0.137), vec4(-0.065, -0.007, 0.174, 0.032), vec4(0.062, 0.142, -0.081, 0.038), vec4(-0.156, -0.097, -0.170, 0.138)) * bufB[8] + mat4(vec4(-0.054, -0.126, 0.005, 0.102), vec4(-0.025, -0.247, 0.070, -0.202), vec4(-0.022, 0.225, -0.146, -0.227), vec4(-0.017, 0.149, -0.371, 0.257)) * bufB[9] + in2;\nbufA[3] = vec4(0.017, 0.190, -0.161, 0.065) + mat4(vec4(0.094, -0.119, -0.204, 0.001), vec4(-0.228, 0.002, 0.344, 0.046), vec4(-0.181, 0.126, -0.158, -0.047), vec4(-0.096, 0.220, -0.052, 0.319)) * bufB[0] + mat4(vec4(0.296, -0.181, -0.016, -0.056), vec4(-0.344, -0.091, 0.117, 0.016), vec4(-0.022, -0.212, -0.124, 0.130), vec4(-0.090, -0.010, -0.048, 0.041)) * bufB[1] + mat4(vec4(0.076, 0.282, 0.178, -0.026), vec4(0.126, -0.197, -0.213, -0.145), vec4(0.383, 0.188, -0.054, 0.237), vec4(-0.104, -0.192, 0.024, -0.093)) * bufB[2] + mat4(vec4(-0.127, 0.265, -0.312, 0.291), vec4(-0.059, 0.059, 0.336, 0.239), vec4(-0.006, -0.141, -0.164, -0.115), vec4(-0.186, -0.089, -0.081, 0.185)) * bufB[3] + mat4(vec4(0.068, -0.224, 0.065, 0.109), vec4(-0.064, 0.042, -0.142, 0.256), vec4(-0.146, -0.001, -0.040, -0.085), vec4(0.042, 0.285, -0.011, -0.107)) * bufB[4] + mat4(vec4(0.039, 0.073, 0.031, -0.372), vec4(-0.160, 0.272, -0.399, -0.278), vec4(-0.073, -0.034, -0.150, 0.118), vec4(-0.164, 0.035, -0.254, -0.094)) * bufB[5] + mat4(vec4(-0.237, 0.275, -0.369, -0.169), vec4(-0.070, -0.303, -0.123, -0.102), vec4(-0.012, -0.108, -0.364, -0.051), vec4(-0.039, -0.300, 0.072, -0.220)) * bufB[6] + mat4(vec4(0.088, -0.319, -0.237, -0.127), vec4(-0.027, 0.018, 0.208, -0.121), vec4(-0.080, 0.117, 0.181, 0.133), vec4(-0.020, -0.232, 0.136, 0.023)) * bufB[7] + mat4(vec4(-0.163, 0.071, 0.153, 0.062), vec4(-0.343, -0.032, -0.320, -0.284), vec4(-0.170, -0.042, 0.329, 0.005), vec4(-0.053, -0.141, -0.377, -0.062)) * bufB[8] + mat4(vec4(-0.057, -0.136, -0.110, -0.242), vec4(0.154, -0.115, 0.330, -0.213), vec4(-0.180, 0.085, -0.308, -0.166), vec4(0.258, -0.090, -0.213, 0.117)) * bufB[9] + in3;\nbufA[4] = vec4(-0.327, -0.086, -0.508, 0.240) + mat4(vec4(-0.153, 0.148, 0.035, 0.205), vec4(-0.029, 0.003, -0.028, -0.159), vec4(-0.003, -0.050, 0.184, -0.093), vec4(0.082, -0.050, -0.013, 0.036)) * bufB[0] + mat4(vec4(-0.043, -0.159, -0.096, -0.179), vec4(-0.225, 0.284, 0.117, 0.091), vec4(-0.032, -0.199, -0.100, 0.021), vec4(-0.137, 0.011, 0.111, 0.179)) * bufB[1] + mat4(vec4(0.179, 0.070, 0.020, -0.112), vec4(-0.065, 0.206, 0.240, -0.056), vec4(-0.202, 0.090, -0.255, -0.250), vec4(0.023, 0.288, -0.130, -0.050)) * bufB[2] + mat4(vec4(-0.183, -0.145, 0.121, -0.001), vec4(0.149, -0.266, 0.091, -0.155), vec4(-0.041, 0.122, 0.088, 0.404), vec4(-0.193, -0.158, 0.007, -0.061)) * bufB[3] + mat4(vec4(-0.119, 0.023, -0.091, 0.160), vec4(0.171, 0.143, 0.058, 0.038), vec4(0.127, 0.039, -0.158, 0.093), vec4(0.326, -0.232, -0.020, 0.092)) * bufB[4] + mat4(vec4(-0.033, 0.009, 0.116, 0.035), vec4(-0.281, 0.102, 0.430, 0.164), vec4(-0.099, 0.159, -0.052, -0.025), vec4(0.101, -0.052, 0.289, 0.065)) * bufB[5] + mat4(vec4(-0.155, -0.114, 0.037, -0.040), vec4(-0.156, 0.025, 0.013, 0.185), vec4(0.025, 0.109, 0.264, 0.156), vec4(-0.010, -0.003, 0.089, -0.102)) * bufB[6] + mat4(vec4(-0.425, 0.106, 0.088, 0.187), vec4(0.156, -0.045, 0.164, 0.164), vec4(0.195, 0.039, 0.101, 0.123), vec4(-0.051, 0.082, 0.009, -0.018)) * bufB[7] + mat4(vec4(0.052, 0.100, 0.071, -0.172), vec4(-0.104, 0.097, -0.014, -0.161), vec4(-0.010, -0.125, 0.279, -0.127), vec4(-0.205, -0.105, -0.035, 0.161)) * bufB[8] + mat4(vec4(-0.087, -0.116, 0.034, 0.119), vec4(-0.062, -0.188, -0.210, -0.330), vec4(0.017, -0.219, -0.099, 0.092), vec4(0.234, 0.075, 0.174, 0.079)) * bufB[9] + in0;\ntmp = atan(bufA[0]);\nbufB[0] = tmp/0.67;\nbufB[5] = (tmp*tmp - 0.45) / 0.396;\ntmp = atan(bufA[1]);\nbufB[1] = tmp/0.67;\nbufB[6] = (tmp*tmp - 0.45) / 0.396;\ntmp = atan(bufA[2]);\nbufB[2] = tmp/0.67;\nbufB[7] = (tmp*tmp - 0.45) / 0.396;\ntmp = atan(bufA[3]);\nbufB[3] = tmp/0.67;\nbufB[8] = (tmp*tmp - 0.45) / 0.396;\ntmp = atan(bufA[4]);\nbufB[4] = tmp/0.67;\nbufB[9] = (tmp*tmp - 0.45) / 0.396;\n\n // layer 4 \nbufA[0] = vec4(-0.081, 0.304, -0.271, 0.462) + mat4(vec4(0.090, -0.166, 0.143, 0.075), vec4(-0.036, -0.151, -0.009, -0.109), vec4(0.180, 0.149, 0.175, 0.121), vec4(-0.029, -0.078, 0.458, -0.401)) * bufB[0] + mat4(vec4(0.366, -0.703, -0.054, -0.230), vec4(0.158, 0.178, 0.092, 0.155), vec4(-0.151, 0.090, 0.306, -0.082), vec4(0.050, 0.043, -0.031, -0.230)) * bufB[1] + mat4(vec4(0.092, -0.116, 0.069, 0.067), vec4(-0.261, 0.139, 0.075, 0.185), vec4(-0.067, 0.295, 0.075, -0.042), vec4(-0.098, -0.370, -0.151, -0.083)) * bufB[2] + mat4(vec4(0.295, -0.191, 0.128, -0.231), vec4(-0.094, 0.254, 0.164, 0.016), vec4(-0.091, 0.022, 0.063, 0.137), vec4(0.042, 0.181, 0.166, -0.091)) * bufB[3] + mat4(vec4(-0.253, 0.188, 0.064, 0.016), vec4(-0.112, 0.437, -0.010, -0.019), vec4(-0.036, 0.046, -0.332, -0.016), vec4(-0.085, 0.147, -0.362, -0.140)) * bufB[4] + mat4(vec4(-0.175, 0.082, 0.205, 0.079), vec4(-0.147, -0.126, -0.018, 0.002), vec4(-0.149, -0.105, -0.207, -0.079), vec4(0.347, -0.310, -0.088, 0.426)) * bufB[5] + mat4(vec4(-0.058, 0.188, 0.115, -0.012), vec4(-0.206, 0.096, -0.299, -0.060), vec4(0.315, -0.058, 0.068, 0.163), vec4(-0.054, -0.022, 0.021, -0.108)) * bufB[6] + mat4(vec4(0.166, 0.060, -0.123, 0.203), vec4(-0.203, -0.462, -0.329, -0.061), vec4(-0.062, 0.187, -0.013, 0.156), vec4(-0.251, -0.023, -0.287, -0.017)) * bufB[7] + mat4(vec4(-0.060, 0.033, -0.186, -0.317), vec4(-0.076, 0.021, 0.023, -0.278), vec4(-0.099, 0.211, 0.010, -0.484), vec4(-0.129, 0.335, -0.111, -0.120)) * bufB[8] + mat4(vec4(0.087, -0.173, -0.123, 0.072), vec4(0.029, -0.138, -0.150, -0.011), vec4(0.104, -0.116, -0.046, -0.100), vec4(-0.026, 0.347, 0.074, -0.289)) * bufB[9];\nbufA[1] = vec4(0.532, 0.409, 0.225, -0.249) + mat4(vec4(-0.050, -0.146, -0.053, 0.039), vec4(0.093, 0.021, -0.353, -0.192), vec4(0.111, -0.066, -0.002, -0.077), vec4(-0.225, -0.213, -0.184, 0.048)) * bufB[0] + mat4(vec4(0.056, -0.129, 0.234, 0.139), vec4(-0.225, 0.084, -0.108, -0.004), vec4(-0.167, 0.168, -0.106, -0.008), vec4(0.179, 0.248, -0.310, -0.179)) * bufB[1] + mat4(vec4(0.072, -0.203, -0.164, -0.062), vec4(-0.050, -0.003, -0.255, 0.059), vec4(0.052, -0.214, 0.014, -0.180), vec4(0.003, 0.137, -0.202, -0.456)) * bufB[2] + mat4(vec4(-0.011, 0.155, 0.029, -0.051), vec4(0.001, 0.084, -0.142, -0.239), vec4(-0.029, 0.062, 0.105, 0.244), vec4(-0.105, 0.181, 0.012, 0.243)) * bufB[3] + mat4(vec4(0.222, -0.113, -0.155, 0.246), vec4(-0.056, 0.162, -0.043, -0.164), vec4(-0.115, 0.032, -0.058, -0.174), vec4(-0.536, -0.037, 0.260, -0.027)) * bufB[4] + mat4(vec4(-0.043, -0.095, -0.179, 0.098), vec4(0.014, 0.184, 0.154, 0.168), vec4(0.244, -0.005, 0.021, -0.039), vec4(-0.139, -0.030, -0.043, 0.108)) * bufB[5] + mat4(vec4(0.063, 0.078, 0.006, 0.035), vec4(-0.139, 0.230, -0.032, -0.220), vec4(0.048, -0.258, 0.025, 0.166), vec4(-0.208, -0.095, 0.303, 0.061)) * bufB[6] + mat4(vec4(-0.059, -0.073, 0.230, -0.047), vec4(0.133, 0.135, 0.125, -0.016), vec4(-0.103, -0.070, -0.038, 0.292), vec4(-0.388, 0.316, 0.036, 0.195)) * bufB[7] + mat4(vec4(-0.245, 0.180, 0.103, -0.029), vec4(-0.093, -0.324, 0.231, 0.088), vec4(-0.101, 0.021, -0.087, -0.180), vec4(0.000, -0.122, 0.057, -0.082)) * bufB[8] + mat4(vec4(-0.139, 0.139, 0.189, -0.112), vec4(0.272, 0.067, -0.246, 0.220), vec4(0.110, 0.022, -0.131, -0.130), vec4(-0.259, 0.009, -0.017, 0.385)) * bufB[9];\nbufA[2] = vec4(-0.372, -0.059, 0.106, -0.303) + mat4(vec4(-0.108, -0.090, -0.313, 0.115), vec4(0.244, -0.043, -0.095, 0.073), vec4(-0.012, -0.020, 0.196, -0.033), vec4(0.143, 0.312, -0.114, -0.035)) * bufB[0] + mat4(vec4(0.005, 0.374, -0.130, 0.092), vec4(-0.258, -0.169, 0.121, 0.094), vec4(0.293, -0.150, -0.102, 0.067), vec4(0.209, 0.173, -0.230, 0.264)) * bufB[1] + mat4(vec4(0.100, -0.132, -0.205, -0.023), vec4(-0.013, -0.210, 0.085, -0.133), vec4(0.036, -0.159, -0.074, -0.337), vec4(-0.240, 0.335, -0.081, 0.420)) * bufB[2] + mat4(vec4(0.119, 0.007, 0.149, -0.056), vec4(0.015, 0.294, 0.307, -0.076), vec4(-0.167, 0.135, -0.236, -0.150), vec4(-0.050, -0.206, -0.202, 0.164)) * bufB[3] + mat4(vec4(0.273, 0.092, 0.091, -0.210), vec4(-0.169, 0.203, -0.015, 0.128), vec4(-0.147, 0.240, -0.315, 0.099), vec4(-0.287, 0.019, -0.082, -0.300)) * bufB[4] + mat4(vec4(0.203, -0.106, -0.028, 0.083), vec4(0.161, 0.077, 0.239, -0.132), vec4(-0.265, -0.016, -0.003, -0.071), vec4(0.194, 0.016, -0.202, -0.518)) * bufB[5] + mat4(vec4(-0.360, 0.038, -0.033, 0.023), vec4(0.242, 0.099, -0.011, -0.378), vec4(-0.159, 0.297, -0.292, 0.019), vec4(-0.375, 0.062, 0.250, -0.000)) * bufB[6] + mat4(vec4(-0.098, -0.217, 0.006, -0.135), vec4(-0.015, 0.172, 0.023, -0.231), vec4(0.292, -0.339, -0.068, -0.047), vec4(0.155, -0.118, 0.082, -0.048)) * bufB[7] + mat4(vec4(0.126, -0.593, 0.129, -0.021), vec4(0.003, -0.313, -0.251, 0.028), vec4(-0.054, 0.363, -0.070, -0.070), vec4(-0.104, 0.001, 0.202, -0.105)) * bufB[8] + mat4(vec4(-0.186, -0.132, 0.044, 0.036), vec4(0.041, 0.063, 0.098, 0.067), vec4(-0.081, 0.369, -0.002, -0.092), vec4(-0.077, 0.118, -0.075, 0.279)) * bufB[9];\nbufA[3] = vec4(0.506, -0.150, -0.241, -0.090) + mat4(vec4(-0.051, -0.144, 0.105, -0.064), vec4(-0.059, -0.437, -0.413, -0.154), vec4(0.320, 0.188, 0.274, 0.057), vec4(-0.001, -0.163, 0.059, -0.111)) * bufB[0] + mat4(vec4(-0.046, -0.081, -0.019, -0.128), vec4(-0.076, -0.372, -0.111, -0.035), vec4(-0.021, -0.079, 0.033, 0.004), vec4(0.530, 0.299, -0.086, 0.280)) * bufB[1] + mat4(vec4(-0.195, -0.193, 0.024, -0.183), vec4(0.055, -0.069, -0.291, 0.009), vec4(0.027, 0.144, -0.125, -0.139), vec4(0.242, -0.062, 0.389, -0.165)) * bufB[2] + mat4(vec4(0.049, 0.149, -0.078, 0.190), vec4(-0.090, 0.085, 0.077, 0.141), vec4(-0.026, -0.115, -0.464, 0.099), vec4(-0.049, -0.250, -0.212, 0.211)) * bufB[3] + mat4(vec4(0.098, 0.128, -0.223, -0.153), vec4(-0.046, -0.041, -0.441, -0.038), vec4(-0.089, 0.444, -0.155, -0.139), vec4(-0.385, 0.018, 0.119, -0.033)) * bufB[4] + mat4(vec4(0.189, -0.145, 0.055, 0.124), vec4(0.043, -0.066, 0.074, 0.288), vec4(-0.024, -0.193, -0.021, 0.107), vec4(0.153, -0.281, -0.019, -0.241)) * bufB[5] + mat4(vec4(-0.155, 0.063, 0.143, 0.169), vec4(0.068, 0.473, -0.331, 0.086), vec4(0.107, -0.177, 0.092, -0.188), vec4(-0.664, 0.124, 0.024, -0.138)) * bufB[6] + mat4(vec4(-0.388, -0.064, -0.298, -0.080), vec4(-0.101, -0.023, -0.225, -0.065), vec4(-0.102, 0.172, 0.065, -0.157), vec4(-0.304, -0.207, -0.174, 0.048)) * bufB[7] + mat4(vec4(-0.099, 0.252, -0.092, 0.093), vec4(-0.030, -0.208, -0.214, 0.438), vec4(0.215, -0.134, 0.307, 0.010), vec4(0.164, -0.157, -0.028, -0.198)) * bufB[8] + mat4(vec4(0.056, -0.179, -0.030, 0.093), vec4(0.024, 0.145, 0.021, 0.033), vec4(0.138, 0.221, -0.124, 0.119), vec4(-0.319, -0.013, -0.324, 0.190)) * bufB[9];\nbufA[4] = vec4(0.069, 0.050, -0.344, -0.069) + mat4(vec4(-0.032, 0.151, -0.025, 0.407), vec4(-0.016, 0.256, -0.021, 0.110), vec4(-0.078, 0.164, 0.084, 0.403), vec4(0.247, 0.157, 0.123, 0.352)) * bufB[0] + mat4(vec4(0.018, 0.308, -0.201, -0.105), vec4(-0.412, 0.077, -0.224, -0.139), vec4(-0.109, 0.012, 0.068, 0.077), vec4(0.034, 0.436, -0.124, -0.026)) * bufB[1] + mat4(vec4(0.032, -0.074, 0.067, 0.303), vec4(-0.197, 0.105, 0.066, 0.046), vec4(-0.353, 0.095, 0.189, 0.216), vec4(0.008, 0.226, 0.202, 0.072)) * bufB[2] + mat4(vec4(-0.029, 0.160, -0.037, -0.298), vec4(0.022, 0.114, -0.119, -0.104), vec4(0.145, -0.247, -0.096, -0.005), vec4(0.156, -0.037, 0.110, 0.007)) * bufB[3] + mat4(vec4(0.029, -0.230, -0.274, 0.005), vec4(-0.099, -0.180, 0.007, 0.113), vec4(0.062, 0.302, 0.169, 0.002), vec4(-0.064, 0.097, 0.014, 0.135)) * bufB[4] + mat4(vec4(-0.087, 0.165, 0.067, -0.172), vec4(0.294, 0.002, 0.184, -0.176), vec4(-0.161, -0.237, 0.079, 0.200), vec4(0.362, 0.069, 0.240, -0.209)) * bufB[5] + mat4(vec4(-0.015, -0.002, -0.024, 0.282), vec4(0.181, -0.059, -0.114, -0.002), vec4(0.039, -0.135, -0.249, 0.176), vec4(-0.084, 0.220, 0.109, 0.376)) * bufB[6] + mat4(vec4(0.039, -0.097, -0.021, 0.156), vec4(0.110, 0.070, -0.097, -0.137), vec4(0.095, -0.076, -0.002, 0.242), vec4(-0.099, 0.157, 0.116, -0.150)) * bufB[7] + mat4(vec4(0.161, 0.071, 0.379, 0.371), vec4(0.058, -0.233, 0.222, 0.154), vec4(-0.261, 0.149, -0.038, 0.001), vec4(-0.420, -0.022, -0.102, -0.002)) * bufB[8] + mat4(vec4(-0.158, -0.190, -0.067, -0.201), vec4(-0.207, -0.002, -0.164, -0.147), vec4(0.016, -0.201, -0.380, -0.018), vec4(-0.039, -0.055, -0.269, 0.382)) * bufB[9];\ntmp = atan(bufA[0]);\nbufB[0] = tmp/0.67;\nbufB[5] = (tmp*tmp - 0.45) / 0.396;\ntmp = atan(bufA[1]);\nbufB[1] = tmp/0.67;\nbufB[6] = (tmp*tmp - 0.45) / 0.396;\ntmp = atan(bufA[2]);\nbufB[2] = tmp/0.67;\nbufB[7] = (tmp*tmp - 0.45) / 0.396;\ntmp = atan(bufA[3]);\nbufB[3] = tmp/0.67;\nbufB[8] = (tmp*tmp - 0.45) / 0.396;\ntmp = atan(bufA[4]);\nbufB[4] = tmp/0.67;\nbufB[9] = (tmp*tmp - 0.45) / 0.396;\n\n // layer 5 \nbufA[0] = vec4(0.438, -0.156, 0.543, 0.381) + mat4(vec4(0.114, 0.371, -0.063, -0.039), vec4(-0.131, 0.110, 0.332, 0.007), vec4(0.223, 0.027, 0.085, -0.285), vec4(-0.203, 0.314, 0.369, 0.426)) * bufB[0] + mat4(vec4(-0.127, -0.091, 0.208, -0.253), vec4(-0.176, 0.028, 0.069, 0.075), vec4(0.126, 0.219, -0.176, -0.171), vec4(0.123, 0.304, 0.099, 0.072)) * bufB[1] + mat4(vec4(0.244, 0.201, -0.364, -0.255), vec4(0.090, -0.012, 0.005, -0.164), vec4(0.158, 0.113, 0.038, -0.033), vec4(-0.126, -0.164, 0.002, 0.316)) * bufB[2] + mat4(vec4(-0.006, 0.124, 0.512, 0.192), vec4(0.253, -0.038, -0.449, -0.028), vec4(-0.201, -0.140, -0.013, 0.111), vec4(-0.130, 0.012, 0.023, -0.020)) * bufB[3] + mat4(vec4(0.090, -0.178, 0.061, 0.057), vec4(0.010, 0.013, -0.219, -0.044), vec4(-0.027, -0.114, -0.050, -0.139), vec4(0.207, -0.011, 0.227, -0.008)) * bufB[4] + mat4(vec4(0.031, -0.081, 0.278, 0.035), vec4(0.179, 0.251, -0.060, 0.379), vec4(-0.445, -0.239, 0.210, -0.190), vec4(0.134, -0.191, -0.144, -0.017)) * bufB[5] + mat4(vec4(0.267, 0.152, -0.147, -0.316), vec4(0.101, 0.300, 0.023, 0.164), vec4(-0.253, -0.060, 0.167, -0.421), vec4(0.043, 0.266, 0.091, -0.016)) * bufB[6] + mat4(vec4(0.055, -0.236, -0.066, -0.216), vec4(0.225, -0.247, -0.080, 0.036), vec4(0.055, 0.117, 0.096, 0.136), vec4(0.114, 0.155, 0.179, -0.063)) * bufB[7] + mat4(vec4(0.354, -0.234, 0.143, 0.350), vec4(-0.014, 0.126, -0.038, -0.030), vec4(-0.142, -0.322, -0.042, -0.287), vec4(-0.093, -0.034, 0.226, 0.109)) * bufB[8] + mat4(vec4(-0.269, 0.086, -0.008, 0.138), vec4(0.195, -0.268, -0.032, -0.098), vec4(0.042, -0.060, -0.081, -0.043), vec4(0.061, 0.246, -0.005, -0.043)) * bufB[9];\nbufA[1] = vec4(-0.269, -0.256, 0.019, -0.507) + mat4(vec4(0.073, -0.028, -0.043, 0.112), vec4(0.185, -0.074, 0.145, 0.008), vec4(0.068, 0.166, -0.051, -0.073), vec4(-0.068, -0.146, 0.010, 0.347)) * bufB[0] + mat4(vec4(-0.042, 0.103, 0.045, -0.100), vec4(-0.267, 0.289, -0.196, -0.079), vec4(-0.078, 0.186, -0.156, 0.128), vec4(-0.146, -0.017, 0.529, 0.171)) * bufB[1] + mat4(vec4(0.048, 0.168, 0.014, -0.061), vec4(-0.183, -0.075, -0.033, -0.057), vec4(-0.119, -0.131, 0.197, -0.162), vec4(-0.035, 0.052, 0.189, -0.118)) * bufB[2] + mat4(vec4(-0.133, 0.015, 0.096, -0.118), vec4(0.012, 0.087, -0.183, 0.091), vec4(0.132, 0.194, -0.090, 0.143), vec4(-0.190, 0.429, -0.099, 0.059)) * bufB[3] + mat4(vec4(-0.169, -0.134, -0.243, -0.023), vec4(0.017, 0.177, 0.142, 0.002), vec4(0.122, -0.052, 0.177, 0.273), vec4(-0.032, -0.067, 0.073, -0.036)) * bufB[4] + mat4(vec4(0.084, 0.016, 0.319, 0.312), vec4(-0.103, 0.187, -0.077, 0.089), vec4(-0.473, -0.172, -0.406, -0.445), vec4(-0.030, -0.148, 0.033, 0.129)) * bufB[5] + mat4(vec4(-0.009, 0.089, -0.275, 0.020), vec4(0.160, 0.035, -0.015, -0.016), vec4(-0.171, 0.128, 0.026, -0.141), vec4(0.295, -0.226, 0.221, 0.139)) * bufB[6] + mat4(vec4(-0.126, -0.022, -0.019, -0.130), vec4(-0.040, -0.075, -0.168, 0.098), vec4(0.099, -0.070, -0.139, 0.007), vec4(-0.118, 0.155, -0.147, -0.027)) * bufB[7] + mat4(vec4(0.176, 0.091, -0.000, 0.058), vec4(0.061, -0.290, 0.149, -0.064), vec4(0.118, -0.165, 0.042, 0.101), vec4(-0.051, -0.323, 0.206, 0.114)) * bufB[8] + mat4(vec4(0.054, 0.073, 0.039, 0.119), vec4(0.043, 0.105, -0.082, -0.231), vec4(0.240, -0.092, -0.106, -0.171), vec4(0.101, 0.207, 0.104, 0.179)) * bufB[9];\nbufA[2] = vec4(-0.536, -0.121, -0.371, 0.375) + mat4(vec4(-0.065, 0.124, -0.029, -0.174), vec4(0.503, 0.066, 0.153, 0.200), vec4(0.007, 0.077, -0.038, 0.080), vec4(-0.164, -0.081, -0.279, -0.198)) * bufB[0] + mat4(vec4(-0.018, -0.108, 0.289, -0.220), vec4(-0.308, -0.087, -0.211, -0.113), vec4(0.299, -0.186, -0.108, -0.128), vec4(0.469, 0.017, 0.034, -0.219)) * bufB[1] + mat4(vec4(0.177, -0.232, 0.022, -0.217), vec4(0.009, 0.157, 0.178, 0.355), vec4(0.012, -0.008, 0.047, 0.097), vec4(-0.031, 0.036, 0.200, 0.034)) * bufB[2] + mat4(vec4(-0.053, -0.303, 0.162, 0.028), vec4(0.335, -0.113, 0.059, -0.280), vec4(-0.177, -0.002, -0.288, 0.325), vec4(0.046, -0.040, 0.393, -0.096)) * bufB[3] + mat4(vec4(-0.350, -0.188, -0.179, -0.172), vec4(-0.135, 0.373, 0.007, 0.312), vec4(-0.264, 0.044, -0.254, 0.173), vec4(-0.184, -0.222, 0.114, 0.097)) * bufB[4] + mat4(vec4(0.022, -0.106, -0.211, -0.049), vec4(0.074, -0.200, 0.551, -0.471), vec4(-0.253, -0.040, 0.026, 0.089), vec4(-0.084, 0.048, -0.080, 0.137)) * bufB[5] + mat4(vec4(-0.124, -0.247, 0.196, 0.136), vec4(0.211, -0.156, -0.011, -0.173), vec4(0.218, 0.034, -0.305, 0.152), vec4(-0.048, 0.242, 0.031, 0.184)) * bufB[6] + mat4(vec4(-0.360, 0.026, -0.097, 0.115), vec4(-0.055, -0.107, -0.175, -0.109), vec4(-0.018, -0.057, -0.018, -0.147), vec4(0.060, 0.076, 0.032, -0.198)) * bufB[7] + mat4(vec4(-0.073, -0.180, 0.027, 0.396), vec4(-0.065, 0.065, -0.163, -0.173), vec4(-0.090, -0.184, -0.052, 0.058), vec4(0.001, 0.407, -0.110, 0.090)) * bufB[8] + mat4(vec4(-0.050, -0.088, 0.093, 0.039), vec4(0.093, -0.048, -0.013, 0.183), vec4(-0.117, -0.139, -0.013, 0.028), vec4(0.361, -0.156, 0.079, -0.317)) * bufB[9];\nbufA[3] = vec4(-0.437, -0.378, 0.513, -0.307) + mat4(vec4(-0.128, 0.337, 0.033, 0.255), vec4(0.045, -0.237, -0.260, 0.343), vec4(-0.061, -0.006, -0.176, -0.117), vec4(0.096, -0.381, -0.032, -0.021)) * bufB[0] + mat4(vec4(0.069, 0.292, 0.052, -0.145), vec4(-0.249, -0.125, -0.146, -0.045), vec4(0.220, 0.157, -0.066, 0.196), vec4(0.447, -0.089, -0.095, -0.214)) * bufB[1] + mat4(vec4(-0.212, 0.185, 0.203, -0.286), vec4(0.205, 0.182, -0.322, 0.171), vec4(0.042, -0.238, -0.030, -0.310), vec4(0.075, 0.200, 0.190, 0.421)) * bufB[2] + mat4(vec4(-0.300, 0.056, 0.071, 0.309), vec4(0.203, -0.076, 0.056, 0.006), vec4(0.114, 0.018, 0.135, 0.210), vec4(-0.146, -0.064, -0.084, 0.215)) * bufB[3] + mat4(vec4(-0.056, 0.008, 0.173, -0.029), vec4(0.028, 0.217, -0.178, -0.159), vec4(0.093, -0.338, -0.334, -0.108), vec4(-0.016, -0.241, 0.105, 0.298)) * bufB[4] + mat4(vec4(0.253, 0.150, 0.031, -0.063), vec4(0.031, 0.553, 0.090, 0.077), vec4(-0.141, 0.192, 0.113, 0.022), vec4(-0.193, -0.069, -0.117, 0.053)) * bufB[5] + mat4(vec4(0.312, -0.119, 0.090, 0.066), vec4(0.008, -0.101, -0.199, -0.014), vec4(-0.123, -0.165, -0.036, 0.198), vec4(-0.161, 0.148, 0.114, -0.317)) * bufB[6] + mat4(vec4(0.055, 0.001, 0.021, 0.245), vec4(0.021, -0.137, 0.069, -0.299), vec4(-0.076, 0.126, 0.200, 0.102), vec4(-0.197, -0.195, 0.159, -0.102)) * bufB[7] + mat4(vec4(0.009, -0.268, 0.257, -0.151), vec4(-0.252, -0.194, 0.068, -0.120), vec4(0.258, -0.237, 0.003, 0.159), vec4(0.247, 0.063, -0.029, 0.060)) * bufB[8] + mat4(vec4(0.329, -0.029, 0.090, -0.122), vec4(0.159, -0.016, -0.163, 0.082), vec4(-0.078, 0.008, -0.196, 0.346), vec4(0.064, 0.008, -0.013, 0.269)) * bufB[9];\nbufA[4] = vec4(-0.381, -0.132, -0.003, -0.210) + mat4(vec4(0.170, -0.296, -0.278, 0.214), vec4(-0.082, 0.232, 0.260, -0.262), vec4(-0.002, -0.006, -0.116, -0.258), vec4(-0.015, -0.075, 0.044, -0.074)) * bufB[0] + mat4(vec4(-0.013, -0.172, -0.167, 0.038), vec4(-0.036, 0.287, 0.177, 0.012), vec4(0.300, -0.166, 0.153, 0.219), vec4(0.353, -0.006, 0.176, 0.101)) * bufB[1] + mat4(vec4(-0.355, 0.016, -0.242, 0.229), vec4(0.098, 0.166, -0.226, 0.158), vec4(-0.436, -0.027, 0.027, -0.168), vec4(0.022, -0.209, -0.200, 0.015)) * bufB[2] + mat4(vec4(-0.127, 0.096, -0.336, -0.008), vec4(-0.049, 0.173, 0.180, -0.043), vec4(0.527, -0.040, 0.002, 0.224), vec4(-0.089, 0.057, 0.182, 0.311)) * bufB[3] + mat4(vec4(0.137, -0.201, 0.001, -0.114), vec4(-0.155, 0.390, -0.140, 0.143), vec4(-0.213, 0.203, 0.202, -0.213), vec4(0.094, 0.181, 0.127, -0.343)) * bufB[4] + mat4(vec4(0.183, -0.071, 0.094, -0.017), vec4(0.108, -0.214, -0.351, -0.020), vec4(-0.047, -0.436, -0.330, -0.055), vec4(0.220, -0.056, 0.164, 0.356)) * bufB[5] + mat4(vec4(0.172, -0.308, -0.086, 0.077), vec4(-0.339, 0.158, 0.139, 0.141), vec4(-0.105, -0.200, 0.127, -0.015), vec4(-0.143, 0.017, 0.111, 0.099)) * bufB[6] + mat4(vec4(0.286, 0.017, 0.174, -0.052), vec4(-0.140, -0.195, 0.295, -0.285), vec4(0.088, 0.174, -0.143, -0.097), vec4(-0.141, 0.281, -0.144, 0.060)) * bufB[7] + mat4(vec4(0.050, -0.023, 0.080, -0.276), vec4(-0.003, -0.313, -0.162, 0.291), vec4(-0.300, 0.395, -0.054, -0.258), vec4(0.392, -0.009, -0.120, 0.130)) * bufB[8] + mat4(vec4(-0.317, -0.233, -0.309, -0.323), vec4(-0.072, 0.204, 0.021, -0.053), vec4(-0.018, -0.039, -0.037, -0.093), vec4(0.118, -0.142, -0.285, -0.004)) * bufB[9];\ntmp = atan(bufA[0]);\nbufB[0] = tmp/0.67;\nbufB[5] = (tmp*tmp - 0.45) / 0.396;\ntmp = atan(bufA[1]);\nbufB[1] = tmp/0.67;\nbufB[6] = (tmp*tmp - 0.45) / 0.396;\ntmp = atan(bufA[2]);\nbufB[2] = tmp/0.67;\nbufB[7] = (tmp*tmp - 0.45) / 0.396;\ntmp = atan(bufA[3]);\nbufB[3] = tmp/0.67;\nbufB[8] = (tmp*tmp - 0.45) / 0.396;\ntmp = atan(bufA[4]);\nbufB[4] = tmp/0.67;\nbufB[9] = (tmp*tmp - 0.45) / 0.396;\n\n // layer 6 \nbufA[0] = vec4(-0.290, -0.191, 0.245, 0.141) + mat4(vec4(0.215, 0.206, 0.251, -0.195), vec4(0.081, 0.170, 0.074, 0.207), vec4(0.005, 0.194, 0.096, -0.396), vec4(-0.264, 0.124, -0.451, -0.088)) * bufB[0] + mat4(vec4(0.362, -0.081, -0.103, 0.299), vec4(-0.057, 0.123, -0.123, -0.145), vec4(0.059, 0.198, -0.267, 0.000), vec4(0.340, -0.124, 0.069, -0.136)) * bufB[1] + mat4(vec4(-0.237, -0.168, -0.011, 0.033), vec4(-0.345, -0.128, 0.356, -0.090), vec4(-0.064, -0.039, -0.093, -0.194), vec4(0.037, -0.076, 0.275, 0.324)) * bufB[2] + mat4(vec4(-0.049, -0.219, 0.198, -0.412), vec4(-0.280, 0.122, -0.194, 0.150), vec4(0.173, 0.171, 0.081, -0.212), vec4(0.325, -0.067, 0.290, -0.159)) * bufB[3] + mat4(vec4(0.232, -0.143, 0.250, -0.271), vec4(0.080, -0.504, -0.348, -0.014), vec4(0.031, -0.375, 0.149, 0.137), vec4(-0.302, 0.374, 0.057, -0.202)) * bufB[4] + mat4(vec4(0.151, -0.022, -0.216, 0.225), vec4(-0.012, 0.222, 0.082, -0.014), vec4(0.167, 0.053, -0.116, -0.094), vec4(0.209, 0.160, -0.297, 0.020)) * bufB[5] + mat4(vec4(0.083, 0.234, -0.137, 0.075), vec4(0.123, -0.064, 0.213, 0.031), vec4(-0.119, 0.231, 0.047, -0.028), vec4(-0.334, -0.058, -0.344, 0.032)) * bufB[6] + mat4(vec4(-0.131, 0.235, -0.189, -0.013), vec4(0.003, -0.285, -0.239, 0.019), vec4(-0.131, 0.142, 0.084, 0.008), vec4(-0.052, 0.050, -0.458, -0.130)) * bufB[7] + mat4(vec4(-0.461, -0.158, 0.244, 0.008), vec4(0.123, 0.031, 0.330, 0.155), vec4(-0.166, -0.190, -0.265, -0.036), vec4(0.331, 0.126, 0.059, 0.096)) * bufB[8] + mat4(vec4(0.026, -0.217, 0.365, 0.149), vec4(-0.111, 0.028, 0.377, 0.108), vec4(-0.292, 0.062, -0.043, -0.069), vec4(-0.145, 0.072, -0.361, -0.083)) * bufB[9];\nbufA[1] = vec4(0.282, -0.318, 0.577, -0.417) + mat4(vec4(0.084, -0.340, 0.424, -0.088), vec4(0.119, -0.127, -0.056, -0.124), vec4(-0.186, -0.122, 0.291, 0.033), vec4(-0.490, 0.036, -0.226, 0.164)) * bufB[0] + mat4(vec4(-0.016, 0.113, -0.400, 0.076), vec4(0.278, -0.106, -0.121, -0.037), vec4(-0.141, 0.108, 0.194, 0.406), vec4(-0.089, -0.055, -0.030, -0.136)) * bufB[1] + mat4(vec4(-0.291, -0.001, 0.076, 0.376), vec4(-0.216, 0.176, -0.159, -0.143), vec4(0.159, 0.219, 0.295, 0.035), vec4(0.006, -0.008, 0.201, -0.011)) * bufB[2] + mat4(vec4(-0.055, -0.172, -0.245, -0.061), vec4(-0.084, 0.070, -0.060, 0.085), vec4(0.243, -0.036, 0.025, -0.129), vec4(-0.014, 0.012, 0.239, 0.120)) * bufB[3] + mat4(vec4(-0.165, -0.092, 0.078, 0.050), vec4(-0.320, 0.112, 0.008, -0.090), vec4(-0.100, -0.017, 0.285, 0.353), vec4(-0.273, -0.036, -0.130, -0.230)) * bufB[4] + mat4(vec4(0.082, -0.015, -0.027, -0.134), vec4(-0.002, 0.123, 0.252, 0.175), vec4(-0.133, 0.134, 0.243, 0.381), vec4(-0.023, -0.288, 0.173, -0.097)) * bufB[5] + mat4(vec4(0.119, 0.328, -0.502, -0.379), vec4(0.006, -0.008, -0.135, -0.287), vec4(0.302, -0.223, -0.085, 0.046), vec4(0.119, -0.165, 0.238, 0.110)) * bufB[6] + mat4(vec4(-0.157, 0.256, -0.087, -0.352), vec4(-0.133, 0.129, -0.213, -0.070), vec4(0.239, 0.038, -0.021, -0.107), vec4(0.027, -0.042, -0.304, -0.015)) * bufB[7] + mat4(vec4(-0.177, 0.138, 0.040, 0.042), vec4(-0.148, -0.070, 0.424, -0.157), vec4(0.272, 0.225, -0.074, -0.002), vec4(0.172, -0.139, 0.219, 0.162)) * bufB[8] + mat4(vec4(0.020, -0.129, 0.109, -0.022), vec4(0.198, 0.022, 0.119, 0.288), vec4(0.192, 0.440, -0.257, -0.094), vec4(0.137, 0.255, 0.245, 0.103)) * bufB[9];\nbufA[2] = vec4(0.091, 0.525, -0.121, -0.479) + mat4(vec4(0.315, -0.145, 0.174, 0.166), vec4(-0.086, 0.221, 0.015, -0.411), vec4(0.006, -0.209, 0.339, 0.105), vec4(-0.007, 0.171, 0.116, 0.032)) * bufB[0] + mat4(vec4(0.343, 0.213, 0.037, 0.165), vec4(0.084, -0.197, 0.259, 0.237), vec4(0.009, -0.018, 0.038, 0.089), vec4(-0.000, 0.013, 0.091, -0.089)) * bufB[1] + mat4(vec4(-0.123, 0.073, -0.225, 0.098), vec4(0.137, 0.021, -0.026, 0.336), vec4(-0.215, 0.091, 0.320, 0.006), vec4(-0.280, 0.162, -0.299, -0.048)) * bufB[2] + mat4(vec4(0.105, -0.413, -0.244, 0.244), vec4(0.027, 0.046, -0.149, 0.044), vec4(0.009, -0.050, -0.017, -0.003), vec4(0.144, 0.244, 0.019, -0.223)) * bufB[3] + mat4(vec4(-0.208, -0.094, -0.422, -0.100), vec4(-0.217, -0.111, 0.074, 0.370), vec4(-0.040, -0.572, -0.140, -0.327), vec4(-0.085, -0.111, 0.330, -0.076)) * bufB[4] + mat4(vec4(0.202, 0.122, 0.034, 0.185), vec4(-0.500, -0.024, -0.150, 0.081), vec4(-0.000, 0.126, -0.172, 0.068), vec4(0.131, 0.149, 0.214, -0.246)) * bufB[5] + mat4(vec4(-0.159, 0.021, -0.179, 0.146), vec4(-0.292, -0.162, -0.066, 0.086), vec4(0.294, -0.149, 0.198, -0.027), vec4(-0.193, 0.044, 0.056, 0.005)) * bufB[6] + mat4(vec4(0.246, -0.034, 0.020, -0.006), vec4(-0.015, -0.059, -0.176, -0.174), vec4(0.000, 0.069, 0.193, 0.012), vec4(-0.210, 0.308, 0.279, 0.098)) * bufB[7] + mat4(vec4(0.062, -0.164, -0.052, -0.077), vec4(-0.189, -0.225, 0.046, 0.302), vec4(0.200, -0.231, -0.045, -0.043), vec4(0.012, -0.153, 0.233, -0.365)) * bufB[8] + mat4(vec4(0.254, -0.496, 0.259, -0.043), vec4(-0.390, -0.071, -0.018, -0.100), vec4(-0.324, 0.550, -0.339, 0.103), vec4(-0.146, 0.107, -0.108, -0.197)) * bufB[9];\nbufA[3] = vec4(0.049, 0.190, 0.140, 0.473) + mat4(vec4(0.103, 0.268, -0.184, 0.112), vec4(0.037, -0.089, 0.340, -0.370), vec4(0.078, 0.051, -0.049, -0.157), vec4(0.266, -0.010, 0.113, 0.065)) * bufB[0] + mat4(vec4(0.224, -0.214, -0.174, -0.036), vec4(0.025, -0.013, 0.374, 0.300), vec4(0.092, -0.026, -0.027, -0.043), vec4(-0.144, 0.012, 0.226, 0.069)) * bufB[1] + mat4(vec4(0.358, -0.071, -0.132, 0.243), vec4(-0.164, -0.186, -0.058, -0.080), vec4(0.148, 0.223, 0.067, 0.119), vec4(-0.230, 0.005, -0.082, 0.100)) * bufB[2] + mat4(vec4(0.103, -0.141, -0.305, 0.227), vec4(0.041, 0.203, -0.345, 0.009), vec4(-0.040, 0.062, 0.138, 0.054), vec4(0.123, -0.067, 0.035, 0.151)) * bufB[3] + mat4(vec4(-0.097, 0.117, -0.043, 0.300), vec4(-0.070, -0.032, -0.086, -0.053), vec4(0.156, -0.119, -0.158, -0.131), vec4(-0.068, 0.204, 0.549, 0.571)) * bufB[4] + mat4(vec4(-0.203, 0.030, 0.034, 0.287), vec4(-0.240, -0.358, 0.103, -0.182), vec4(0.301, -0.074, 0.022, 0.003), vec4(-0.075, -0.048, 0.261, 0.001)) * bufB[5] + mat4(vec4(-0.178, -0.206, 0.104, -0.354), vec4(-0.075, -0.160, -0.024, -0.045), vec4(-0.208, -0.013, -0.027, -0.006), vec4(-0.409, -0.139, 0.369, -0.135)) * bufB[6] + mat4(vec4(0.022, 0.213, -0.199, 0.028), vec4(0.152, 0.329, -0.088, -0.209), vec4(0.260, -0.070, -0.223, 0.102), vec4(0.061, -0.077, -0.142, -0.112)) * bufB[7] + mat4(vec4(0.089, -0.148, -0.114, -0.433), vec4(-0.276, -0.047, 0.150, 0.054), vec4(0.031, -0.391, -0.134, -0.072), vec4(-0.205, 0.117, -0.096, -0.291)) * bufB[8] + mat4(vec4(0.130, -0.121, 0.420, 0.004), vec4(0.221, 0.093, 0.101, 0.115), vec4(0.205, 0.178, -0.187, -0.137), vec4(0.632, -0.050, -0.226, -0.376)) * bufB[9];\nbufA[4] = vec4(0.312, -0.552, 0.033, -0.182) + mat4(vec4(-0.159, -0.118, 0.034, 0.342), vec4(0.094, -0.195, -0.019, -0.293), vec4(-0.330, 0.005, 0.306, -0.093), vec4(-0.082, 0.190, 0.283, -0.124)) * bufB[0] + mat4(vec4(-0.124, -0.095, 0.096, 0.180), vec4(0.004, -0.057, -0.347, 0.088), vec4(0.002, -0.085, 0.339, -0.091), vec4(-0.002, -0.075, -0.038, 0.063)) * bufB[1] + mat4(vec4(0.016, 0.317, -0.145, -0.220), vec4(-0.264, -0.279, 0.240, 0.232), vec4(0.331, 0.240, -0.086, -0.093), vec4(-0.039, -0.093, 0.163, 0.168)) * bufB[2] + mat4(vec4(0.262, 0.116, -0.250, 0.140), vec4(0.372, -0.054, -0.033, -0.448), vec4(-0.021, 0.044, 0.172, 0.280), vec4(0.248, 0.076, -0.211, 0.390)) * bufB[3] + mat4(vec4(0.012, 0.103, -0.349, 0.053), vec4(-0.248, 0.190, -0.172, 0.070), vec4(-0.158, 0.265, 0.068, -0.017), vec4(0.025, -0.039, -0.362, 0.396)) * bufB[4] + mat4(vec4(-0.214, 0.373, -0.115, -0.191), vec4(-0.210, -0.023, 0.066, -0.045), vec4(-0.050, 0.135, 0.391, -0.169), vec4(0.038, -0.088, 0.126, 0.033)) * bufB[5] + mat4(vec4(0.030, -0.049, 0.190, 0.197), vec4(-0.159, 0.023, 0.168, 0.299), vec4(-0.098, -0.115, 0.121, -0.047), vec4(0.361, 0.022, 0.011, -0.007)) * bufB[6] + mat4(vec4(0.195, 0.134, 0.023, -0.032), vec4(-0.042, -0.131, 0.096, -0.032), vec4(0.084, 0.302, 0.149, -0.184), vec4(-0.010, -0.133, -0.014, -0.113)) * bufB[7] + mat4(vec4(0.279, 0.013, -0.333, -0.040), vec4(-0.267, -0.011, 0.017, -0.266), vec4(0.095, -0.298, -0.185, 0.083), vec4(-0.050, -0.346, 0.065, 0.179)) * bufB[8] + mat4(vec4(-0.310, -0.046, -0.313, 0.310), vec4(-0.011, -0.171, -0.049, -0.092), vec4(-0.232, -0.224, 0.195, -0.081), vec4(0.234, -0.176, 0.076, -0.085)) * bufB[9];\ntmp = atan(bufA[0]);\nbufB[0] = tmp/0.67;\nbufB[5] = (tmp*tmp - 0.45) / 0.396;\ntmp = atan(bufA[1]);\nbufB[1] = tmp/0.67;\nbufB[6] = (tmp*tmp - 0.45) / 0.396;\ntmp = atan(bufA[2]);\nbufB[2] = tmp/0.67;\nbufB[7] = (tmp*tmp - 0.45) / 0.396;\ntmp = atan(bufA[3]);\nbufB[3] = tmp/0.67;\nbufB[8] = (tmp*tmp - 0.45) / 0.396;\ntmp = atan(bufA[4]);\nbufB[4] = tmp/0.67;\nbufB[9] = (tmp*tmp - 0.45) / 0.396;\n\n // layer 7 \nbufA[0] = vec4(-0.025, -0.229, 0.369, 0.337) + mat4(vec4(-0.247, -0.072, 0.087, 0.124), vec4(-0.115, -0.215, 0.297, -0.340), vec4(-0.100, 0.037, 0.675, -0.229), vec4(-0.437, 0.187, -0.223, -0.176)) * bufB[0] + mat4(vec4(-0.275, -0.183, 0.030, -0.077), vec4(-0.303, 0.038, -0.256, 0.044), vec4(-0.162, 0.205, 0.112, 0.351), vec4(-0.134, -0.048, -0.191, -0.293)) * bufB[1] + mat4(vec4(-0.153, -0.238, -0.054, 0.278), vec4(-0.179, -0.321, 0.106, -0.159), vec4(-0.020, -0.289, 0.023, 0.414), vec4(-0.034, 0.106, 0.080, -0.031)) * bufB[2] + mat4(vec4(0.182, -0.274, -0.026, -0.068), vec4(-0.020, -0.357, -0.111, 0.345), vec4(0.011, -0.023, 0.263, 0.151), vec4(0.298, -0.122, 0.067, 0.053)) * bufB[3] + mat4(vec4(-0.139, -0.304, -0.133, -0.457), vec4(-0.351, -0.080, -0.019, 0.027), vec4(0.022, -0.027, 0.235, -0.063), vec4(-0.397, 0.174, -0.151, -0.011)) * bufB[4] + mat4(vec4(0.028, -0.069, -0.354, 0.169), vec4(-0.111, 0.002, 0.097, -0.173), vec4(-0.279, -0.204, 0.252, 0.196), vec4(0.038, -0.116, -0.174, 0.125)) * bufB[5] + mat4(vec4(0.108, -0.195, -0.087, -0.209), vec4(0.148, 0.324, -0.089, 0.057), vec4(0.077, 0.021, 0.196, 0.121), vec4(0.071, -0.216, -0.075, 0.048)) * bufB[6] + mat4(vec4(-0.037, -0.360, 0.109, -0.117), vec4(-0.155, -0.234, -0.535, -0.005), vec4(-0.168, 0.023, -0.026, 0.044), vec4(0.122, -0.182, 0.228, -0.383)) * bufB[7] + mat4(vec4(-0.149, 0.115, -0.262, -0.026), vec4(0.343, -0.023, -0.122, -0.094), vec4(-0.155, 0.289, -0.039, 0.021), vec4(-0.232, 0.222, -0.268, -0.082)) * bufB[8] + mat4(vec4(-0.123, 0.477, -0.220, -0.182), vec4(-0.180, -0.087, -0.007, -0.013), vec4(-0.082, 0.557, 0.623, -0.266), vec4(0.135, -0.246, -0.142, -0.395)) * bufB[9];\nbufA[1] = vec4(0.008, -0.313, 0.347, -0.219) + mat4(vec4(-0.070, 0.374, 0.100, -0.512), vec4(-0.239, -0.031, -0.252, -0.433), vec4(-0.175, -0.437, -0.091, 0.022), vec4(0.055, -0.232, -0.028, 0.083)) * bufB[0] + mat4(vec4(-0.097, 0.213, 0.141, -0.282), vec4(0.077, 0.166, -0.264, 0.233), vec4(0.263, -0.315, -0.048, 0.044), vec4(-0.140, -0.039, 0.270, -0.152)) * bufB[1] + mat4(vec4(0.141, 0.127, -0.066, -0.390), vec4(-0.126, 0.081, 0.161, 0.029), vec4(0.118, -0.182, 0.256, 0.279), vec4(0.111, 0.024, -0.028, -0.229)) * bufB[2] + mat4(vec4(0.116, -0.134, -0.043, 0.091), vec4(-0.189, 0.019, -0.053, 0.090), vec4(0.106, 0.025, -0.011, 0.326), vec4(-0.286, -0.037, -0.124, -0.240)) * bufB[3] + mat4(vec4(0.347, 0.329, -0.429, -0.379), vec4(0.131, -0.097, 0.135, -0.141), vec4(-0.160, -0.161, 0.067, -0.117), vec4(-0.362, 0.269, -0.048, -0.231)) * bufB[4] + mat4(vec4(-0.108, -0.186, 0.208, -0.271), vec4(-0.017, 0.060, 0.037, 0.327), vec4(0.184, 0.529, -0.040, 0.032), vec4(0.445, 0.076, 0.001, 0.539)) * bufB[5] + mat4(vec4(0.261, 0.058, -0.397, -0.001), vec4(-0.221, -0.034, 0.199, -0.215), vec4(-0.160, 0.074, 0.130, 0.005), vec4(-0.082, 0.321, 0.317, -0.151)) * bufB[6] + mat4(vec4(0.382, -0.073, 0.000, 0.391), vec4(-0.375, 0.163, -0.100, -0.292), vec4(-0.023, 0.160, -0.063, 0.257), vec4(-0.411, -0.107, 0.232, -0.127)) * bufB[7] + mat4(vec4(0.114, 0.193, -0.013, -0.150), vec4(-0.564, -0.057, -0.093, -0.120), vec4(0.062, -0.093, -0.087, 0.135), vec4(0.105, -0.107, 0.298, -0.301)) * bufB[8] + mat4(vec4(0.045, 0.128, 0.085, 0.102), vec4(-0.122, -0.058, -0.130, -0.077), vec4(-0.045, -0.129, 0.023, -0.460), vec4(-0.449, -0.228, 0.352, -0.081)) * bufB[9];\nbufA[2] = vec4(0.535, 0.004, -0.004, 0.239) + mat4(vec4(0.258, -0.007, -0.202, -0.036), vec4(-0.016, 0.171, 0.095, 0.038), vec4(0.221, 0.229, -0.239, -0.271), vec4(0.236, 0.024, -0.080, -0.029)) * bufB[0] + mat4(vec4(-0.116, -0.099, 0.336, 0.151), vec4(-0.573, -0.021, 0.211, -0.205), vec4(0.315, -0.403, -0.314, 0.124), vec4(0.222, 0.074, -0.238, -0.012)) * bufB[1] + mat4(vec4(0.207, 0.014, 0.015, 0.067), vec4(-0.490, 0.460, -0.085, 0.203), vec4(0.056, -0.031, -0.033, 0.096), vec4(-0.019, 0.059, -0.109, 0.238)) * bufB[2] + mat4(vec4(0.068, -0.172, 0.392, -0.388), vec4(0.050, 0.156, -0.230, -0.042), vec4(-0.165, 0.063, 0.152, 0.189), vec4(0.207, -0.008, -0.040, -0.149)) * bufB[3] + mat4(vec4(-0.023, -0.008, 0.074, -0.006), vec4(0.304, -0.427, -0.153, -0.355), vec4(0.611, -0.013, -0.234, 0.331), vec4(-0.102, -0.150, -0.157, 0.251)) * bufB[4] + mat4(vec4(0.105, 0.010, -0.054, 0.270), vec4(-0.202, 0.057, 0.202, 0.055), vec4(0.242, -0.326, -0.227, -0.306), vec4(-0.225, 0.114, -0.314, -0.046)) * bufB[5] + mat4(vec4(-0.084, 0.114, 0.013, 0.211), vec4(-0.567, 0.026, -0.134, 0.170), vec4(0.248, -0.056, -0.244, -0.077), vec4(0.201, -0.078, 0.044, 0.390)) * bufB[6] + mat4(vec4(-0.383, -0.005, 0.171, 0.061), vec4(0.285, 0.135, 0.112, -0.132), vec4(-0.095, 0.081, -0.058, 0.209), vec4(-0.495, -0.120, 0.049, -0.025)) * bufB[7] + mat4(vec4(0.269, -0.396, 0.011, 0.250), vec4(0.228, 0.091, 0.333, -0.166), vec4(-0.201, -0.046, -0.141, -0.130), vec4(0.216, 0.052, -0.166, 0.166)) * bufB[8] + mat4(vec4(-0.316, -0.160, -0.166, 0.059), vec4(-0.204, 0.306, 0.355, 0.214), vec4(-0.194, 0.091, 0.092, -0.352), vec4(-0.042, 0.024, 0.182, -0.069)) * bufB[9];\nbufA[3] = vec4(-0.602, 0.086, -0.657, -0.251) + mat4(vec4(0.344, 0.137, 0.235, -0.203), vec4(0.225, 0.316, -0.429, -0.220), vec4(0.110, -0.116, -0.018, -0.009), vec4(0.167, 0.050, 0.241, -0.198)) * bufB[0] + mat4(vec4(0.255, -0.018, 0.327, 0.133), vec4(-0.307, 0.141, 0.219, -0.021), vec4(-0.301, -0.251, 0.140, 0.072), vec4(-0.299, -0.477, -0.202, -0.022)) * bufB[1] + mat4(vec4(0.097, -0.080, -0.240, -0.097), vec4(0.068, -0.077, -0.143, 0.358), vec4(-0.008, -0.128, -0.224, -0.206), vec4(0.076, 0.194, -0.104, 0.109)) * bufB[2] + mat4(vec4(-0.052, -0.245, -0.021, 0.191), vec4(-0.031, 0.059, 0.022, -0.143), vec4(-0.322, 0.103, -0.415, -0.099), vec4(0.299, 0.427, -0.468, -0.398)) * bufB[3] + mat4(vec4(-0.157, 0.364, -0.409, 0.045), vec4(0.260, 0.387, 0.083, 0.005), vec4(0.035, -0.170, -0.047, 0.322), vec4(-0.258, 0.111, -0.052, 0.072)) * bufB[4] + mat4(vec4(0.073, -0.018, -0.116, -0.439), vec4(0.093, -0.155, -0.192, 0.079), vec4(0.189, 0.471, -0.151, 0.250), vec4(-0.114, -0.008, 0.352, -0.179)) * bufB[5] + mat4(vec4(-0.072, -0.290, -0.079, -0.078), vec4(0.142, 0.035, -0.199, 0.296), vec4(-0.181, 0.080, -0.173, -0.100), vec4(-0.029, 0.032, -0.512, -0.205)) * bufB[6] + mat4(vec4(0.183, -0.220, 0.194, 0.394), vec4(0.335, 0.106, -0.057, -0.050), vec4(-0.454, 0.020, 0.024, 0.418), vec4(0.141, -0.022, 0.279, -0.129)) * bufB[7] + mat4(vec4(-0.240, -0.287, -0.192, 0.280), vec4(0.035, 0.024, -0.001, -0.048), vec4(-0.138, -0.104, 0.128, -0.006), vec4(-0.029, -0.316, -0.092, -0.034)) * bufB[8] + mat4(vec4(0.123, -0.032, 0.063, 0.248), vec4(-0.102, 0.018, 0.125, 0.088), vec4(0.431, -0.065, -0.039, 0.077), vec4(0.148, 0.078, -0.238, -0.056)) * bufB[9];\nbufA[4] = vec4(-0.282, -0.204, -0.179, 0.342) + mat4(vec4(0.347, 0.157, 0.679, 0.048), vec4(-0.192, -0.287, 0.059, 0.171), vec4(0.093, 0.103, -0.037, -0.242), vec4(0.015, -0.046, -0.244, 0.057)) * bufB[0] + mat4(vec4(-0.181, -0.514, -0.028, -0.347), vec4(0.327, 0.143, -0.176, -0.027), vec4(-0.042, -0.230, -0.088, 0.049), vec4(-0.097, 0.139, 0.204, -0.168)) * bufB[1] + mat4(vec4(-0.061, 0.513, -0.008, 0.475), vec4(0.057, -0.101, 0.532, 0.121), vec4(-0.264, -0.220, -0.052, 0.229), vec4(0.361, 0.085, 0.205, 0.378)) * bufB[2] + mat4(vec4(-0.210, 0.014, 0.059, -0.310), vec4(-0.328, 0.108, -0.225, -0.057), vec4(0.309, -0.210, 0.153, -0.139), vec4(-0.262, 0.094, 0.016, 0.160)) * bufB[3] + mat4(vec4(-0.125, -0.294, -0.088, 0.142), vec4(0.316, 0.078, 0.117, -0.205), vec4(-0.159, 0.336, 0.061, -0.155), vec4(-0.242, -0.031, -0.143, 0.299)) * bufB[4] + mat4(vec4(-0.270, -0.100, 0.526, 0.010), vec4(-0.190, 0.161, 0.231, 0.237), vec4(0.040, -0.070, 0.031, 0.087), vec4(-0.039, -0.063, -0.347, -0.343)) * bufB[5] + mat4(vec4(-0.241, -0.012, -0.343, -0.182), vec4(-0.274, -0.251, 0.161, -0.152), vec4(0.330, -0.005, 0.313, -0.143), vec4(0.025, 0.349, 0.137, -0.162)) * bufB[6] + mat4(vec4(-0.190, 0.168, -0.094, -0.158), vec4(0.082, -0.126, 0.323, 0.097), vec4(0.347, 0.250, -0.101, -0.130), vec4(0.027, 0.328, 0.124, -0.618)) * bufB[7] + mat4(vec4(-0.292, 0.039, 0.005, 0.103), vec4(0.165, -0.053, -0.019, 0.350), vec4(0.159, 0.124, -0.012, 0.161), vec4(-0.043, -0.463, 0.295, 0.241)) * bufB[8] + mat4(vec4(-0.295, 0.165, 0.183, -0.391), vec4(-0.084, 0.039, -0.076, 0.076), vec4(-0.039, -0.182, 0.434, -0.161), vec4(0.102, -0.055, 0.149, -0.071)) * bufB[9];\ntmp = atan(bufA[0]);\nbufB[0] = tmp/0.67;\nbufB[5] = (tmp*tmp - 0.45) / 0.396;\ntmp = atan(bufA[1]);\nbufB[1] = tmp/0.67;\nbufB[6] = (tmp*tmp - 0.45) / 0.396;\ntmp = atan(bufA[2]);\nbufB[2] = tmp/0.67;\nbufB[7] = (tmp*tmp - 0.45) / 0.396;\ntmp = atan(bufA[3]);\nbufB[3] = tmp/0.67;\nbufB[8] = (tmp*tmp - 0.45) / 0.396;\ntmp = atan(bufA[4]);\nbufB[4] = tmp/0.67;\nbufB[9] = (tmp*tmp - 0.45) / 0.396;\n\n // layer 8 \nbufA[0] = vec4(0.207, 0.423, 0.267, -0.033) + mat4(vec4(-0.198, -0.036, 0.348, -0.023), vec4(0.108, -0.232, -0.184, -0.027), vec4(-0.047, -0.221, -0.269, 0.187), vec4(-0.205, 0.148, 0.341, -0.157)) * bufB[0] + mat4(vec4(-0.011, -0.108, -0.131, 0.184), vec4(-0.010, 0.315, -0.178, 0.722), vec4(-0.046, -0.057, -0.145, -0.227), vec4(-0.047, -0.019, 0.203, -0.087)) * bufB[1] + mat4(vec4(0.028, -0.005, 0.212, 0.229), vec4(0.025, 0.023, 0.228, 0.166), vec4(-0.032, 0.148, -0.549, 0.092), vec4(0.134, 0.297, -0.174, -0.076)) * bufB[2] + mat4(vec4(0.593, -0.283, -0.040, 0.176), vec4(0.108, -0.426, -0.217, 0.125), vec4(0.251, -0.157, -0.148, 0.224), vec4(0.260, 0.104, -0.048, -0.281)) * bufB[3] + mat4(vec4(0.146, 0.154, -0.020, 0.193), vec4(0.203, 0.156, -0.257, -0.005), vec4(-0.092, -0.110, -0.601, -0.070), vec4(0.153, 0.433, -0.100, -0.445)) * bufB[4] + mat4(vec4(0.265, 0.577, 0.053, -0.120), vec4(-0.282, 0.092, -0.058, -0.053), vec4(-0.346, 0.555, -0.020, -0.070), vec4(0.351, 0.009, -0.063, -0.101)) * bufB[5] + mat4(vec4(-0.184, -0.540, -0.001, -0.219), vec4(-0.139, -0.097, 0.187, 0.021), vec4(0.262, -0.095, -0.036, -0.465), vec4(-0.571, -0.114, -0.145, 0.150)) * bufB[6] + mat4(vec4(0.154, -0.442, -0.095, -0.166), vec4(-0.188, -0.041, -0.086, -0.039), vec4(-0.213, 0.124, 0.044, 0.062), vec4(0.223, 0.211, 0.240, -0.054)) * bufB[7] + mat4(vec4(0.219, -0.351, 0.151, 0.139), vec4(-0.034, 0.250, -0.194, -0.098), vec4(0.270, -0.137, 0.057, -0.241), vec4(-0.129, 0.308, 0.061, 0.131)) * bufB[8] + mat4(vec4(0.077, -0.114, 0.207, -0.245), vec4(-0.085, -0.251, -0.114, 0.020), vec4(-0.183, -0.073, -0.387, 0.254), vec4(0.030, 0.310, 0.323, -0.149)) * bufB[9];\nbufA[1] = vec4(-0.517, 0.234, 0.200, -0.198) + mat4(vec4(0.101, -0.091, -0.047, 0.362), vec4(-0.242, 0.043, 0.055, -0.002), vec4(-0.068, -0.628, 0.226, 0.012), vec4(-0.033, 0.211, 0.016, 0.049)) * bufB[0] + mat4(vec4(0.020, -0.093, 0.133, 0.056), vec4(-0.426, -0.262, -0.286, 0.130), vec4(-0.220, 0.036, 0.270, -0.404), vec4(0.094, -0.059, 0.334, 0.273)) * bufB[1] + mat4(vec4(0.009, -0.033, -0.258, -0.307), vec4(0.255, -0.164, 0.039, 0.087), vec4(0.272, -0.239, -0.252, -0.011), vec4(-0.293, -0.162, -0.315, 0.171)) * bufB[2] + mat4(vec4(0.085, 0.010, -0.001, -0.223), vec4(-0.003, -0.171, -0.193, 0.019), vec4(-0.299, 0.278, -0.061, 0.137), vec4(0.105, -0.069, 0.162, -0.143)) * bufB[3] + mat4(vec4(0.085, 0.048, -0.045, 0.251), vec4(0.279, 0.095, -0.028, 0.246), vec4(-0.075, -0.066, -0.316, -0.421), vec4(0.055, 0.489, -0.166, -0.082)) * bufB[4] + mat4(vec4(-0.045, 0.206, 0.090, 0.144), vec4(-0.153, 0.160, 0.205, 0.206), vec4(0.124, -0.003, 0.094, 0.005), vec4(-0.236, 0.049, -0.132, -0.015)) * bufB[5] + mat4(vec4(-0.053, 0.243, -0.466, -0.256), vec4(-0.103, 0.108, -0.231, -0.055), vec4(-0.179, -0.031, 0.076, -0.020), vec4(-0.016, -0.040, 0.092, -0.002)) * bufB[6] + mat4(vec4(-0.101, 0.077, -0.082, -0.223), vec4(0.098, 0.253, -0.214, -0.203), vec4(-0.213, -0.196, 0.094, 0.500), vec4(0.228, -0.051, 0.055, 0.040)) * bufB[7] + mat4(vec4(-0.028, -0.216, -0.137, -0.125), vec4(0.012, 0.272, 0.241, 0.113), vec4(0.403, -0.044, 0.125, 0.287), vec4(-0.023, 0.049, 0.041, -0.060)) * bufB[8] + mat4(vec4(-0.178, 0.270, 0.160, 0.079), vec4(-0.271, 0.213, -0.237, -0.235), vec4(-0.273, 0.164, -0.193, 0.003), vec4(0.004, -0.079, 0.142, 0.528)) * bufB[9];\nbufA[2] = vec4(-0.228, 0.480, 0.420, -0.253) + mat4(vec4(0.092, 0.167, -0.112, 0.093), vec4(0.076, 0.158, -0.214, 0.096), vec4(-0.071, -0.182, 0.156, -0.019), vec4(-0.166, 0.066, 0.101, 0.064)) * bufB[0] + mat4(vec4(-0.135, 0.112, -0.123, -0.187), vec4(0.221, 0.038, -0.101, 0.024), vec4(-0.053, -0.349, -0.151, 0.289), vec4(0.014, 0.188, -0.218, -0.221)) * bufB[1] + mat4(vec4(-0.005, 0.080, -0.277, 0.410), vec4(0.157, 0.002, 0.250, -0.083), vec4(0.285, -0.088, 0.223, -0.002), vec4(-0.053, -0.265, 0.270, 0.214)) * bufB[2] + mat4(vec4(0.138, -0.119, -0.078, 0.212), vec4(-0.083, -0.301, 0.243, 0.075), vec4(0.162, 0.600, -0.320, -0.126), vec4(0.149, 0.107, -0.055, -0.052)) * bufB[3] + mat4(vec4(0.004, 0.358, -0.231, 0.155), vec4(-0.171, 0.019, 0.007, -0.295), vec4(0.313, -0.052, -0.122, 0.058), vec4(0.280, -0.173, -0.030, -0.170)) * bufB[4] + mat4(vec4(0.110, 0.098, -0.092, 0.639), vec4(-0.001, 0.301, 0.061, 0.040), vec4(-0.042, -0.043, -0.296, -0.580), vec4(-0.143, -0.332, -0.170, -0.057)) * bufB[5] + mat4(vec4(0.515, -0.087, -0.011, -0.226), vec4(0.227, 0.616, 0.176, 0.180), vec4(-0.193, -0.093, -0.229, 0.054), vec4(-0.142, -0.161, 0.158, 0.325)) * bufB[6] + mat4(vec4(-0.057, 0.010, 0.325, 0.239), vec4(-0.043, -0.189, 0.158, -0.148), vec4(-0.057, -0.128, -0.019, -0.079), vec4(-0.332, -0.402, 0.099, 0.070)) * bufB[7] + mat4(vec4(0.099, 0.397, -0.120, 0.040), vec4(0.018, -0.162, 0.118, 0.050), vec4(0.040, 0.349, -0.384, 0.139), vec4(0.135, -0.058, -0.065, 0.267)) * bufB[8] + mat4(vec4(0.156, 0.058, -0.097, -0.201), vec4(-0.106, 0.107, 0.277, 0.023), vec4(0.322, -0.269, 0.202, -0.108), vec4(-0.326, 0.147, 0.001, -0.258)) * bufB[9];\nbufA[3] = vec4(-0.462, -0.354, -0.185, 0.450) + mat4(vec4(-0.047, 0.034, -0.266, 0.147), vec4(0.097, 0.161, -0.401, -0.212), vec4(0.033, -0.277, -0.021, 0.159), vec4(0.043, -0.160, 0.443, -0.043)) * bufB[0] + mat4(vec4(-0.007, 0.028, 0.058, -0.069), vec4(0.156, -0.191, -0.645, -0.069), vec4(0.038, -0.008, -0.156, 0.102), vec4(-0.062, -0.022, 0.077, -0.035)) * bufB[1] + mat4(vec4(-0.005, -0.244, 0.148, -0.159), vec4(0.064, 0.312, 0.204, -0.170), vec4(0.074, 0.351, -0.233, 0.155), vec4(-0.067, 0.057, -0.040, -0.139)) * bufB[2] + mat4(vec4(-0.115, 0.155, 0.141, 0.101), vec4(-0.008, 0.010, -0.156, 0.078), vec4(0.131, 0.257, -0.132, -0.263), vec4(-0.149, 0.018, -0.209, 0.278)) * bufB[3] + mat4(vec4(0.077, -0.010, -0.234, 0.141), vec4(0.203, -0.164, -0.363, -0.059), vec4(-0.149, -0.037, -0.010, 0.133), vec4(0.302, 0.255, -0.008, -0.055)) * bufB[4] + mat4(vec4(-0.172, 0.002, 0.039, -0.127), vec4(0.046, 0.375, 0.371, 0.001), vec4(0.118, 0.012, 0.076, -0.088), vec4(-0.229, -0.372, 0.105, 0.249)) * bufB[5] + mat4(vec4(0.020, -0.178, 0.169, 0.027), vec4(0.103, 0.030, -0.232, -0.166), vec4(-0.003, -0.073, 0.148, 0.224), vec4(0.148, 0.150, -0.207, 0.179)) * bufB[6] + mat4(vec4(-0.281, -0.007, 0.078, 0.117), vec4(0.142, 0.432, 0.046, -0.001), vec4(0.152, 0.086, 0.033, 0.305), vec4(0.023, -0.194, 0.076, -0.072)) * bufB[7] + mat4(vec4(0.092, -0.106, 0.016, -0.139), vec4(0.044, 0.152, -0.417, -0.542), vec4(0.039, -0.087, 0.102, 0.034), vec4(0.101, 0.078, 0.011, 0.161)) * bufB[8] + mat4(vec4(-0.249, 0.279, -0.002, 0.196), vec4(0.012, 0.074, 0.137, 0.038), vec4(-0.056, 0.031, -0.208, 0.100), vec4(-0.183, -0.396, -0.141, -0.160)) * bufB[9];\nbufA[4] = vec4(-0.397, 0.385, -0.283, -0.255) + mat4(vec4(0.113, -0.321, -0.123, 0.235), vec4(-0.288, 0.158, 0.126, -0.220), vec4(-0.365, -0.256, -0.553, 0.142), vec4(-0.153, -0.210, -0.184, 0.089)) * bufB[0] + mat4(vec4(-0.081, -0.013, 0.255, -0.128), vec4(-0.009, 0.083, 0.107, -0.072), vec4(0.047, 0.556, 0.281, -0.599), vec4(-0.377, -0.490, -0.028, 0.518)) * bufB[1] + mat4(vec4(0.577, 0.194, -0.076, -0.478), vec4(0.103, 0.136, 0.094, 0.185), vec4(-0.076, 0.413, -0.070, 0.416), vec4(0.187, 0.176, 0.010, 0.302)) * bufB[2] + mat4(vec4(-0.200, 0.325, -0.115, -0.496), vec4(-0.307, 0.485, 0.048, -0.007), vec4(-0.088, 0.196, 0.276, -0.205), vec4(-0.813, 0.029, 0.088, -0.079)) * bufB[3] + mat4(vec4(-0.152, -0.065, 0.277, -0.272), vec4(-0.021, 0.228, 0.160, -0.183), vec4(-0.036, 0.309, -0.251, -0.089), vec4(-0.030, -0.468, -0.305, -0.184)) * bufB[4] + mat4(vec4(0.144, -0.298, -0.141, 0.061), vec4(0.598, -0.356, -0.095, 0.220), vec4(0.336, 0.014, -0.232, 0.077), vec4(-0.309, -0.392, 0.269, 0.210)) * bufB[5] + mat4(vec4(-0.002, 0.093, 0.472, -0.235), vec4(-0.202, 0.081, 0.067, -0.294), vec4(-0.531, -0.247, 0.485, -0.293), vec4(-0.251, 0.388, -0.185, 0.065)) * bufB[6] + mat4(vec4(-0.780, -0.192, 0.368, 0.204), vec4(0.301, 0.351, 0.000, 0.008), vec4(0.217, -0.177, -0.268, 0.155), vec4(-0.057, -0.049, -0.236, -0.102)) * bufB[7] + mat4(vec4(-0.064, -0.031, 0.254, -0.369), vec4(-0.029, 0.339, -0.288, -0.142), vec4(0.131, -0.083, -0.264, -0.113), vec4(-0.119, 0.096, 0.108, -0.291)) * bufB[8] + mat4(vec4(0.076, 0.233, -0.116, 0.333), vec4(-0.133, 0.088, 0.271, -0.604), vec4(-0.064, 0.337, -0.155, -0.315), vec4(0.359, -0.230, 0.125, 0.326)) * bufB[9];\ntmp = atan(bufA[0]);\nbufB[0] = tmp/0.67;\nbufB[5] = (tmp*tmp - 0.45) / 0.396;\ntmp = atan(bufA[1]);\nbufB[1] = tmp/0.67;\nbufB[6] = (tmp*tmp - 0.45) / 0.396;\ntmp = atan(bufA[2]);\nbufB[2] = tmp/0.67;\nbufB[7] = (tmp*tmp - 0.45) / 0.396;\ntmp = atan(bufA[3]);\nbufB[3] = tmp/0.67;\nbufB[8] = (tmp*tmp - 0.45) / 0.396;\ntmp = atan(bufA[4]);\nbufB[4] = tmp/0.67;\nbufB[9] = (tmp*tmp - 0.45) / 0.396;\n\n // layer 9 \nbufA[0] = vec4(-0.481, -0.385, 0.207, 0.000) + mat4(vec4(-0.012, -0.005, 0.094, 0.000), vec4(0.026, 0.111, 0.039, 0.000), vec4(0.152, 0.073, 0.035, 0.000), vec4(-0.141, -0.061, 0.253, 0.000)) * bufB[0] + mat4(vec4(-0.105, 0.161, 0.190, 0.000), vec4(0.270, 0.244, 0.144, 0.000), vec4(0.305, 0.123, -0.002, 0.000), vec4(0.050, 0.067, 0.120, 0.000)) * bufB[1] + mat4(vec4(-0.031, -0.174, -0.224, 0.000), vec4(0.259, 0.026, 0.090, 0.000), vec4(-0.247, -0.217, 0.085, 0.000), vec4(-0.069, -0.022, -0.129, 0.000)) * bufB[2] + mat4(vec4(0.255, -0.069, 0.058, 0.000), vec4(-0.146, -0.018, 0.134, 0.000), vec4(-0.012, -0.021, -0.063, 0.000), vec4(0.365, -0.276, -0.244, 0.000)) * bufB[3] + mat4(vec4(0.002, 0.020, 0.110, 0.000), vec4(-0.341, -0.101, -0.005, 0.000), vec4(-0.002, -0.200, -0.109, 0.000), vec4(0.368, 0.231, -0.028, 0.000)) * bufB[4] + mat4(vec4(-0.197, -0.198, -0.088, 0.000), vec4(0.198, 0.129, 0.112, 0.000), vec4(0.093, 0.072, 0.187, 0.000), vec4(-0.083, 0.058, 0.084, 0.000)) * bufB[5] + mat4(vec4(0.201, -0.033, -0.117, 0.000), vec4(-0.102, -0.012, 0.059, 0.000), vec4(0.146, 0.092, 0.118, 0.000), vec4(-0.348, -0.208, -0.098, 0.000)) * bufB[6] + mat4(vec4(-0.045, -0.100, -0.153, 0.000), vec4(0.162, 0.139, 0.120, 0.000), vec4(-0.192, -0.181, -0.170, 0.000), vec4(0.163, 0.138, 0.049, 0.000)) * bufB[7] + mat4(vec4(-0.022, 0.011, 0.212, 0.000), vec4(-0.214, -0.159, -0.083, 0.000), vec4(0.162, 0.219, 0.076, 0.000), vec4(0.259, 0.106, 0.042, 0.000)) * bufB[8] + mat4(vec4(-0.215, -0.213, -0.157, 0.000), vec4(-0.263, -0.267, -0.285, 0.000), vec4(-0.272, -0.291, -0.193, 0.000), vec4(0.335, 0.339, 0.192, 0.000)) * bufB[9];\n\n return vec4((1. / (1. + exp(-bufA[0]))).xyz, 1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 mouseNorm = (iMouse.xy / iResolution.xy) - vec2(0.5, 0.5);\n\n    uv.x *= iResolution.x / iResolution.y;\n    uv.x -= ((iResolution.x / iResolution.y) - 1.) /2.;\n\n    // Shifted to the form expected by the CPPN\n    uv = vec2(1., -1.) * vec2(1.6, 2) * (uv - vec2(0.5, 0.5));\n    // Output to screen\n    fragColor = cppn_fn(uv, 0.23*sin(iTime), 0.32*sin(0.69*iTime), 0.32*sin(0.44*iTime), 0.23*sin(1.23*iTime));\n}\n        ", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/Nd2GWz.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "NdBGDG", "name": "Cellular noise sample", "author": "tomoe", "description": "The neighbouring distance getter comes from [url=https://www.shadertoy.com/view/fsSGDG]Distance to feature points V[/url]\nup: 3D, down: 2D", "tags": ["bd202104"], "likes": 2, "viewed": 87, "date": "1617851888", "time_retrieved": "2024-06-20T20:37:35.161254", "image_code": "uvec3 k = uvec3(0x456789abu, 0x6789ab45u, 0x89ab4567u);\nconst uint max32 = 0xffffffffu;\nconst float PI = 3.14159265359;\nuvec2 hash22u(uvec2 n) {  \n    n ^= (n.yx << 24);\n    n ^= (n.yx >> 1);\n    n *= k.xy;\n    n ^= (n.yx << 1);\n    return n * k.xy;\n}\nuvec3 hash33u(uvec3 n) {\n    n ^= (n.yzx << 24);\n    n ^= (n.yzx >> 1);\n    n *= k;\n    n ^= (n.yzx << 1);\n    return n * k;\n}\nmat2 rot2(float t) {\n    return mat2(cos(t), sin(t), -sin(t),  cos(t));\n}\nfloat length2(vec2 v){\n    return dot(v, v);\n}\nfloat length3(vec3 v){\n    return dot(v, v);\n}\nvec2 hash22(vec2 p) {\n    uvec2 n = uvec2(p);\n    return vec2(hash22u(n)) / vec2(max32) - 0.5;\n}\nvec3 hash33(vec3 p) {\n    uvec3 n = uvec3(p);\n    return vec3(hash33u(n)) / vec3(max32) - 0.5;\n}\nvec4 sort(vec4 list, float v){\n    if (list.w < v){\n        return list;\n    } else {\n        vec4 newList = list.wxyz;\n        for(int i = 0; i < 4; i ++ ) {\n            if (list[i] < v) {\n                newList[i] = list[i];\n            } else {\n                newList[i] = v;\n                break;\n            }\n        }\n        return newList;\n    }\n}\nvec4 F4_2d(vec2 p){   \n    vec2 n = round(p);\n    vec2 f = p - round(p);\n    vec4 dist4 = vec4(length2(1.5 - abs(f)));\n    vec2 sgn = vec2(1.0);\n    vec2 glid = vec2(0.0);\n    for(float j = 0.0; j <= 4.0; j ++ ) {\n        glid.y += sgn.y * j;\n        sgn.y *= -1.0;\n        if (abs(glid.y - f.y) - 0.5 > sqrt(dist4.w)){\n            continue;\n        }\n        for(float i = 0.0; i <= 4.0; i ++ ){\n            glid.x += sgn.x * i;\n            sgn.x *= -1.0;\n            vec2 nbd = glid + rot2(iTime) * hash22(n + glid) / sqrt(2.0);\n            float dist = length2(nbd -f);\n            dist4 = sort(dist4, dist);\n        }\n        glid.x = 0.0;\n    }\n    return sqrt(dist4);\n}\nvec4 F4_3d(vec3 p){   \n    vec3 n = round(p);\n    vec3 f = p - round(p);\n    vec4 dist4 = vec4(length3(1.5 - abs(f)));\n    vec3 sgn = vec3(1.0);\n    vec3 glid = vec3(0.0);\n    for(float k = 0.0; k <= 4.0; k ++ ) {\n            glid.z += sgn.z * k;\n            sgn.z *= -1.0;\n            if (abs(glid.z - f.z) - 0.5 > sqrt(dist4.w)){\n                continue;\n            }\n        for(float j = 0.0; j <= 4.0; j ++ ) {\n            glid.y += sgn.y * j;\n            sgn.y *= -1.0;\n            if (abs(glid.y - f.y) - 0.5 > sqrt(dist4.w)){\n                continue;\n            }\n            for(float i = 0.0; i <= 4.0; i ++ ){\n                glid.x += sgn.x * i;\n                sgn.x *= -1.0;\n                vec3 nbd = glid + hash33(n + glid);\n                float dist = length3(nbd - f);\n                dist4 = sort(dist4, dist);\n            }\n            glid.x = 0.0;\n        }\n        glid.y = 0.0;\n    }\n    return sqrt(dist4);\n}\nfloat cnoise2(vec2 p, vec4 w){\n    return abs(dot(F4_2d(p), w));\n}\nfloat cnoise3(vec3 p, vec4 w){\n    return abs(dot(F4_3d(p), w));\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    vec2 pos = fragCoord.xy/ iResolution.xx;\n    pos *= 10.0;\n    pos += iTime;\n    int ind = int(3.0 * fragCoord.x / iResolution.x);\n    mat3x4 wt = mat3x4(\n        vec4(.275),  //left\n        vec4(.5, -1.0, 1.4, -.1),  //center\n        vec4(-.3, -.5, -1.2, 1.0)  //right\n    );\n    if(fragCoord.y < 0.5 * iResolution.y){\n        fragColor = vec4(cnoise2(pos, wt[ind])) * vec4(0.9, 0.9, 0.7, 1.0);  \n    } else {\n        fragColor = vec4(cnoise3(vec3(pos, iTime), wt[ind])) * vec4(0.6, 0.8, 0.8, 1.0);  \n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/NdBGDG.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "NdBGR3", "name": "Mars Copter", "author": "dr2", "description": "First flight (more of a da Vinci design)", "tags": ["flight", "nasa", "helicopter"], "likes": 13, "viewed": 185, "date": "1617703788", "time_retrieved": "2024-06-20T20:37:35.179836", "image_code": "// \"Mars Copter\" by dr2 - 2021\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\nfloat PrRoundCylDf (vec3 p, float r, float rt, float h);\nfloat PrCapsDf (vec3 p, float r, float h);\nfloat Maxv3 (vec3 p);\nfloat SmoothBump (float lo, float hi, float w, float x);\nmat3 StdVuMat (float el, float az);\nvec2 Rot2D (vec2 q, float a);\nfloat Hashff (float p);\nfloat Fbm2 (vec2 p);\nfloat Fbm2e (vec2 p);\nvec3 VaryNf (vec3 p, vec3 n, float f);\n\nvec3 sunDir, qHit;\nvec2 hipPos, ftPos;\nfloat tCur, dstFar, legLenU, legLenD, aU, aD, pPitch, pRot, grndScl;\nint idObj;\nconst int idBase = 1, idLeg = 2, idAxl = 3, idProp = 4;\nconst float pi = 3.14159;\n\n#define VAR_ZERO min (iFrame, 0)\n\n#define DMINQ(id) if (d < dMin) { dMin = d;  idObj = id;  qHit = q; }\n\nfloat GrndDf (vec3 p)\n{\n  vec3 q;\n  float d, h, a, r, s, f;\n  q = p / grndScl;\n  r = length (q.xz);\n  d = p.y;\n  if (r > 0.) {\n    a = atan (q.z, - q.x) / (2. * pi) + 0.5;\n    s = sqrt (r) / (2. * pi);\n    f = 32.;\n    h = 2.5 * s * mix (Fbm2e (f * vec2 (s, a + 1.)), Fbm2e (f * vec2 (s, a)), a);\n    d = max (r - 20., q.y - mix (s, h, smoothstep (1.4, 2.2, r)) * smoothstep (1.4, 2.6, r));\n  }\n  return grndScl * d;\n}\n\nfloat GrndRay (vec3 ro, vec3 rd)\n{\n  vec3 p;\n  float dHit, h, s, sLo, sHi;\n  s = 0.;\n  sLo = 0.;\n  dHit = dstFar;\n  for (int j = VAR_ZERO; j < 220; j ++) {\n    p = ro + s * rd;\n    h = GrndDf (p);\n    if (h < 0.) break;\n    sLo = s;\n    s += max (0.001, h);\n    if (s > dstFar) break;\n  }\n  if (h < 0.) {\n    sHi = s;\n    for (int j = VAR_ZERO; j < 10; j ++) {\n      s = 0.5 * (sLo + sHi);\n      p = ro + s * rd;\n      if (GrndDf (p) > 0.) sLo = s;\n      else sHi = s;\n    }\n    dHit = 0.5 * (sLo + sHi);\n  }\n  return dHit;\n}\n\nvec3 GrndNf (vec3 p)\n{\n  vec4 v;\n  vec2 e;\n  e = vec2 (0.001, -0.001);\n  for (int j = VAR_ZERO; j < 4; j ++) {\n    v[j] = GrndDf (p + ((j < 2) ? ((j == 0) ? e.xxx : e.xyy) : ((j == 2) ? e.yxy : e.yyx)));\n  }\n  v.x = - v.x;\n  return normalize (2. * v.yzw - dot (v, vec4 (1.)));\n}\n\nvoid SetConf ()\n{\n  vec2 knPos, r, a, b;\n  float tCyc, rl, s, t;\n  legLenU = 2.;\n  legLenD = 3.;\n  tCyc = 20.;\n  t = mod (tCur / tCyc, 1.);\n  pPitch = 0.05 * pi * (1. + SmoothBump (0.1, 0.45, 0.03, t));\n  hipPos = vec2 (1.5, 0.5 * (legLenU + legLenD) + (9. + 6. * Hashff (floor (tCur / tCyc))) *\n     SmoothBump (0.3, 0.7, 0.2, t));\n  ftPos = vec2 (1.8 + 2.2 * (1. - smoothstep (0.2, 1.5, hipPos.y - (legLenU + legLenD))), 0.);\n  r = ftPos - hipPos;\n  rl = length (r);\n  b = vec2 (legLenU, legLenD);\n  if (rl < legLenU + legLenD) {\n    a = acos ((rl * rl + (b.y * b.y - b.x * b.x) * vec2 (-1., 1.)) / (2. * rl * b));\n    s = sign (r.x);\n    knPos = vec2 (hipPos.x, ftPos.y) + b * sin (vec2 ((a.x + 0.5 * pi) * s, a.y) -\n       asin (r.y / rl) * vec2 (- s, 1.));\n    r = knPos - hipPos;\n    aU = atan (r.y, r.x);\n    r = ftPos - knPos;\n    aD = atan (r.y, r.x);\n  } else {\n    aU = asin (r.x / (legLenU + legLenD)) - 0.5 * pi;\n    aD = aU;\n  }\n  pRot = 3. * pi * tCur;\n}\n\nfloat ObjDf (vec3 p)\n{\n  vec3 q;\n  vec2 fb;\n  float dMin, d;\n  dMin = dstFar;\n  fb = normalize (vec2 (1.2, 1.));\n  for (float k = -1. + float (VAR_ZERO); k <= 1.; k += 2.) {\n    q = p;\n    q.xz = Rot2D (q.xz, k * pRot);\n    q.y -= hipPos.y + 2.4 + 1.2 * k;\n    d = PrRoundCylDf (q.xzy, 0.2 - 0.05 * k, 0.01, 1.2);\n    DMINQ (idAxl);\n    q.y -= 1.;\n    d = min (max (PrRoundCylDf (vec3 (q.x, Rot2D (q.yz, k * pPitch)).xzy, 3., 0.02, 0.01),\n       dot (vec2 (q.x, abs (q.z)), fb)),\n       max (PrRoundCylDf (vec3 (q.x, Rot2D (q.yz, - k * pPitch)).xzy, 3., 0.02, 0.01),\n       dot (vec2 (- q.x, abs (q.z)), fb)));\n    DMINQ (idProp);\n  }\n  q = p;\n  q.y -= hipPos.y + 0.1;\n  d = PrRoundCylDf (q.xzy, hipPos.x, 0.05, 0.2);\n  q.y -= 0.4;\n  d = min (d, PrRoundCylDf (q.xzy, 0.35 * hipPos.x, 0.05, 0.15));\n  DMINQ (idBase);\n  q = p;\n  q.xz = Rot2D (q.xz, 2. * pi * (floor (6. * atan (q.z, - q.x) / (2. * pi)) + 0.5) / 6.);\n  q.xy -= hipPos * vec2 (-1., 1.);\n  q.xy = Rot2D (q.xy, aU);\n  q.x += 0.5 * legLenU;\n  d = PrCapsDf (q.yzx, 0.1 * (0.8 + 0.2 * q.x / (0.5 * legLenU)) / 0.6, 0.5 * legLenU);\n  DMINQ (idLeg);\n  q.x += 0.5 * legLenU;\n  q.xy = Rot2D (q.xy, aD - aU);\n  q.x += 0.5 * legLenD;\n  d = PrCapsDf (q.yzx, 0.1 * (0.9 + 0.1 * q.x / (0.5 * legLenD)), 0.5 * legLenD);\n  DMINQ (idLeg);\n  q.x += 0.5 * legLenD;\n  q.xy = Rot2D (q.xy, 0.5 * pi - aD);\n  q.x -= -0.02;\n  d = PrRoundCylDf (q.yzx, 0.3, 0.02, 0.05);\n  DMINQ (idLeg);\n  return dMin;\n}\n\nfloat ObjRay (vec3 ro, vec3 rd)\n{\n  float dHit, d;\n  dHit = 0.;\n  for (int j = VAR_ZERO; j < 120; j ++) {\n    d = ObjDf (ro + dHit * rd);\n    if (d < 0.0005 || dHit > dstFar ) break;\n    dHit += d;\n  }\n  return dHit;\n}\n\nvec3 ObjNf (vec3 p)\n{\n  vec4 v;\n  vec2 e;\n  e = vec2 (0.0002, -0.0002);\n  for (int j = VAR_ZERO; j < 4; j ++) {\n    v[j] = ObjDf (p + ((j < 2) ? ((j == 0) ? e.xxx : e.xyy) : ((j == 2) ? e.yxy : e.yyx)));\n  }\n  v.x = - v.x;\n  return normalize (2. * v.yzw - dot (v, vec4 (1.)));\n}\n\nfloat ObjSShadow (vec3 ro, vec3 rd)\n{\n  float sh, d, h;\n  sh = 1.;\n  d = 0.05;\n  for (int j = VAR_ZERO; j < 30; j ++) {\n    h = ObjDf (ro + d * rd);\n    sh = min (sh, smoothstep (0., 0.05 * d, h));\n    d += h;\n    if (sh < 0.05 || d > dstFar) break;\n  }\n  return 0.5 + 0.5 * sh;\n}\n\nvec3 StarPat (vec3 rd, float scl)\n{\n  vec3 tm, qn, u;\n  vec2 q;\n  float f;\n  tm = -1. / max (abs (rd), 0.0001);\n  qn = - sign (rd) * step (tm.zxy, tm) * step (tm.yzx, tm);\n  u = Maxv3 (tm) * rd;\n  q = atan (vec2 (dot (u.zxy, qn), dot (u.yzx, qn)), vec2 (1.)) / pi;\n  f = 0.57 * (Fbm2 (11. * dot (0.5 * (qn + 1.), vec3 (1., 2., 4.)) + 131.13 * scl * q) +\n      Fbm2 (13. * dot (0.5 * (qn + 1.), vec3 (1., 2., 4.)) + 171.13 * scl * q.yx));\n  return 2. * vec3 (1., 1., 0.8) * pow (f, 16.);\n}\n\nvec4 GrndCol (vec3 ro, vec3 vn)\n{\n  vec4 col4;\n  col4 = vec4 (0.9, 0.5, 0.2, 0.) * (0.7 + 0.3 * Fbm2 (ro.xz));\n  if (ro.y > -0.1) {\n    col4 = mix (col4, 0.8 * col4, smoothstep (0.2, 0.7, 1. - vn.y));\n    col4 = mix (col4, 1.1 * col4, smoothstep (0.6, 0.9, ro.y / grndScl +\n       0.2 * sin (32. * atan (ro.z, - ro.x))));\n  }\n  return col4;\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  vec4 col4;\n  vec3 col, vn;\n  float dstObj, dstGrnd, sh;\n  SetConf ();\n  dstGrnd = GrndRay (ro, rd);\n  dstObj = ObjRay (ro, rd);\n  if (min (dstGrnd, dstObj) < dstFar) {\n    if (dstGrnd < dstObj) {\n      ro += dstGrnd * rd;\n      vn = GrndNf (ro);\n      vn = VaryNf (0.5 * ro, vn, 4. - 2. * smoothstep (0.7, 0.9, dstGrnd / (3. * grndScl)));\n      col4 = GrndCol (ro, vn);\n    } else {\n      ro += dstObj * rd;\n      vn = ObjNf (ro);\n      if (idObj == idBase) {\n        col4 = vec4 (0.9, 0.9, 1., 0.2) * (0.8 + 0.2 * smoothstep (0., 0.02,\n           abs (length (qHit.xz) - 1.1) - 0.1));\n      } else if (idObj == idLeg) {\n        col4 = vec4 (0.9, 0.9, 1., 0.2) * (0.8 + 0.2 * sin (8. * pi * qHit.x));\n      } else if (idObj == idAxl) {\n        col4 = vec4 (0.8, 1., 0.8, 0.2) * (1. - 0.2 * sin (4. * atan (qHit.z, qHit.x)));\n      } else if (idObj == idProp) {\n        col4 = vec4 (1., 0.9, 0.8, 0.2) * (0.9 + 0.1 * sin (8. * pi * length (qHit.xz)));\n      }\n    }\n    sh = ObjSShadow (ro + 0.001 * vn, sunDir);\n    col = col4.rgb * (0.2 + 0.1 * max (dot (vn, normalize (vec3 (- sunDir.xz, 0.)).xzy), 0.) +\n       0.8 * sh * max (dot (vn, sunDir), 0.)) +\n       col4.a * step (0.95, sh) * pow (max (dot (sunDir, reflect (rd, vn)), 0.), 32.);\n  } else col = vec3 (0.3, 0.2, 0.1) + StarPat (rd, 8.);\n  return clamp (col, 0., 1.);\n}\n\n#define AA  0   // optional antialiasing\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  mat3 vuMat;\n  vec4 mPtr;\n  vec3 ro, rd, col;\n  vec2 canvas, uv;\n  float el, az, zmFac, sr, t;\n  canvas = iResolution.xy;\n  uv = 2. * fragCoord.xy / canvas - 1.;\n  uv.x *= canvas.x / canvas.y;\n  tCur = iTime;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / canvas - 0.5;\n  az = 0.;\n  el = -0.03 * pi;\n  if (mPtr.z > 0.) {\n    az -= 2. * pi * mPtr.x;\n    el -= 0.5 * pi * mPtr.y;\n  } else {\n    t = mod (0.01 * tCur, 2.);\n    az = 1.5 * pi * (0.5 - abs ((floor (8. * t) + smoothstep (0.9, 1., mod (8. * t, 1.))) / 8. - 1.));\n  }\n  el = clamp (el, -0.3 * pi, -0.01 * pi);\n  vuMat = StdVuMat (el, az);\n  grndScl = 50.;\n  ro = vuMat * vec3 (0., 0., -1.4) * grndScl;\n  ro.y += 0.2 * grndScl;\n  zmFac = 5.;\n  dstFar = 10. * grndScl;\n  sunDir = normalize (vec3 (0.3, 1., 1.));\n#if ! AA\n  const float naa = 1.;\n#else\n  const float naa = 3.;\n#endif  \n  col = vec3 (0.);\n  sr = 2. * mod (dot (mod (floor (0.5 * (uv + 1.) * canvas), 2.), vec2 (1.)), 2.) - 1.;\n  for (float a = float (VAR_ZERO); a < naa; a ++) {\n    rd = vuMat * normalize (vec3 (uv + step (1.5, naa) * Rot2D (vec2 (0.5 / canvas.y, 0.),\n       sr * (0.667 * a + 0.5) * pi), zmFac));\n    col += (1. / naa) * ShowScene (ro, rd);\n  }\n  fragColor = vec4 (col, 1.);\n}\n\nfloat PrRoundCylDf (vec3 p, float r, float rt, float h)\n{\n  return length (max (vec2 (length (p.xy) - r, abs (p.z) - h), 0.)) - rt;\n}\n\nfloat PrCapsDf (vec3 p, float r, float h)\n{\n  return length (p - vec3 (0., 0., clamp (p.z, - h, h))) - r;\n}\n\nfloat Maxv3 (vec3 p)\n{\n  return max (p.x, max (p.y, p.z));\n}\n\nfloat SmoothBump (float lo, float hi, float w, float x)\n{\n  return (1. - smoothstep (hi - w, hi + w, x)) * smoothstep (lo - w, lo + w, x);\n}\n\nmat3 StdVuMat (float el, float az)\n{\n  vec2 ori, ca, sa;\n  ori = vec2 (el, az);\n  ca = cos (ori);\n  sa = sin (ori);\n  return mat3 (ca.y, 0., - sa.y, 0., 1., 0., sa.y, 0., ca.y) *\n         mat3 (1., 0., 0., 0., ca.x, - sa.x, 0., sa.x, ca.x);\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  vec2 cs;\n  cs = sin (a + vec2 (0.5 * pi, 0.));\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nconst float cHashM = 43758.54;\n\nfloat Hashff (float p)\n{\n  return fract (sin (p) * cHashM);\n}\n\nvec2 Hashv2v2 (vec2 p)\n{\n  vec2 cHashVA2 = vec2 (37., 39.);\n  return fract (sin (vec2 (dot (p, cHashVA2), dot (p + vec2 (1., 0.), cHashVA2))) * cHashM);\n}\n\nfloat Noisefv2 (vec2 p)\n{\n  vec2 t, ip, fp;\n  ip = floor (p);  \n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = mix (Hashv2v2 (ip), Hashv2v2 (ip + vec2 (0., 1.)), fp.y);\n  return mix (t.x, t.y, fp.x);\n}\n\nfloat Fbm2 (vec2 p)\n{\n  float f, a;\n  f = 0.;\n  a = 1.;\n  for (int j = 0; j < 5; j ++) {\n    f += a * Noisefv2 (p);\n    a *= 0.5;\n    p *= 2.;\n  }\n  return f * (1. / 1.9375);\n}\n\nfloat Fbm2e (vec2 p)\n{\n  float f, a;\n  f = 0.;\n  a = 1.;\n  for (int j = 0; j < 6; j ++) {\n    f += a * Noisefv2 (p);\n    a *= 0.5;\n    p *= 2.;\n  }\n  return f * (1. / 1.96875);\n}\n\nfloat Fbmn (vec3 p, vec3 n)\n{\n  vec3 s;\n  float a;\n  s = vec3 (0.);\n  a = 1.;\n  for (int j = 0; j < 5; j ++) {\n    s += a * vec3 (Noisefv2 (p.yz), Noisefv2 (p.zx), Noisefv2 (p.xy));\n    a *= 0.5;\n    p *= 2.;\n  }\n  return dot (s, abs (n));\n}\n\nvec3 VaryNf (vec3 p, vec3 n, float f)\n{\n  vec3 g;\n  vec2 e;\n  e = vec2 (0.1, 0.);\n  g = vec3 (Fbmn (p + e.xyy, n), Fbmn (p + e.yxy, n), Fbmn (p + e.yyx, n)) - Fbmn (p, n);\n  return normalize (n + f * (g - n * dot (n, g)));\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc-by-nc-sa-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/NdBGR3.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "NdBSz1", "name": "Class II Goldberg Polyhedron ", "author": "Lichtso", "description": "UV-mapped hexagonal tiling on an icosahedron, See: https://en.wikipedia.org/wiki/Goldberg_polyhedron\n\nInstead of mesh tessellation this shader derives the tiling directly from polar angles.\nThis way the performance is independent of the number of tiles.", "tags": ["uv", "sphere", "hexagon", "tile", "polyhedron"], "likes": 12, "viewed": 210, "date": "1619620350", "time_retrieved": "2024-06-20T20:37:36.633322", "image_code": "float line_plane_intersection(vec3 origin, vec3 direction, vec3 point_on_plane, vec3 plane_normal) {\n    float determinant = dot(direction, plane_normal);\n    float zero = 0.0;\n    if(determinant == 0.0)\n        return zero/zero;\n    float parallel_distance = dot(point_on_plane-origin, plane_normal)/determinant;\n    return parallel_distance;\n}\n\nfloat line_sphere_intersection(vec3 origin, vec3 direction, vec3 center, float radius, out vec3 intersections[2]) {\n    vec3 diagonal = origin-center;\n\tvec3 parallel = dot(diagonal, direction)*direction;\n    vec3 orthogonal = diagonal-parallel;\n    float orthogonal_distance = length(orthogonal);\n    if(orthogonal_distance > radius)\n        return 0.0;\n   \tfloat parallel_distance = sin(acos(orthogonal_distance/radius))*radius;\n    intersections[0] = origin-parallel-direction*parallel_distance;\n    intersections[1] = origin-parallel+direction*parallel_distance;\n    return parallel_distance*2.0;\n}\n\nconst vec3 ICOSAHEDRON_VERTICES[12] = vec3[](\n    vec3(0.0, -1.0, 0.0),\n    vec3(-0.27639320492744446, -0.4472135901451111, -0.8506507873535156),\n    vec3(-0.8944271802902222, -0.4472135901451111, -1.6430361299034693e-16),\n    vec3(-0.27639320492744446, -0.4472135901451111, 0.8506507873535156),\n    vec3(0.7236068248748779, -0.4472135901451111, 0.525731086730957),\n    vec3(0.7236068248748779, -0.4472135901451111, -0.525731086730957),\n    vec3(0.27639320492744446, 0.4472135901451111, -0.8506507873535156),\n    vec3(-0.7236068248748779, 0.4472135901451111, -0.525731086730957),\n    vec3(-0.7236068248748779, 0.4472135901451111, 0.525731086730957),\n    vec3(0.27639320492744446, 0.4472135901451111, 0.8506507873535156),\n    vec3(0.8944271802902222, 0.4472135901451111, 1.6430361299034693e-16),\n    vec3(0.0, 1.0, 0.0)\n);\n\nconst float M_PI = radians(180.0);\n\n#define rotate_around(angle, center) \\\n    mat3(1.0, 0.0, 0.0, 0.0, 1.0, 0.0, center.x, center.y, 1.0)* \\\n    mat3( \\\n        cos(angle), -sin(angle), 0.0, \\\n        sin(angle), cos(angle), 0.0, \\\n        0.0, 0.0, 1.0 \\\n    )* \\\n    mat3(1.0, 0.0, 0.0, 0.0, 1.0, 0.0, -center.x, -center.y, 1.0)\n\nconst mat3 rotate_m60 = rotate_around(radians(-60.0), vec2(0.5));\nconst mat3 rotate_p60 = rotate_around(radians(60.0), vec2(0.5));\nconst float icosahedron_radius_by_edge_length = sin(M_PI*2.0/5.0);\nconst float blending_region = 0.1;\n\nbool side_of_half_plane(vec3 direction, int pole_index_a, int pole_index_b) {\n    vec3 aux_a = cross(ICOSAHEDRON_VERTICES[pole_index_a], ICOSAHEDRON_VERTICES[pole_index_b]);\n    return dot(direction, aux_a) > 0.0;\n}\n\nvec3 barycentric_interpolation(vec3 barycentric, ivec3 pole_indices, bool angular_interpolation) {\n    if(angular_interpolation)\n        barycentric = sin(barycentric);\n    mat3 mat = mat3(\n        ICOSAHEDRON_VERTICES[pole_indices[0]],\n        ICOSAHEDRON_VERTICES[pole_indices[1]],\n        ICOSAHEDRON_VERTICES[pole_indices[2]]\n    );\n    return normalize(mat*barycentric);\n}\n\nvec3 inverse_barycentric_interpolation(vec3 direction, ivec3 pole_indices, bool angular_interpolation) {\n    float sum = 0.0;\n    vec3 barycentric = vec3(0.0);\n    for(int i = 0; i < 3; ++i) {\n        float dot_product = dot(cross(ICOSAHEDRON_VERTICES[pole_indices[(i+1)%3]], ICOSAHEDRON_VERTICES[pole_indices[(i+2)%3]]), direction);\n        barycentric[i] = (angular_interpolation) ? asin(dot_product) : dot_product;\n        sum += barycentric[i];\n    }\n    return barycentric/sum;\n}\n\nvec3 rotate_cube_coord(vec3 cube_coord) {\n    return vec3(\n        cube_coord.y-cube_coord.z,\n        cube_coord.z-cube_coord.x,\n        cube_coord.x-cube_coord.y\n    );\n}\n\nvec3 round_cube_coord(vec3 barycentric) {\n    vec3 rounded = round(barycentric);\n    vec3 diff = abs(rounded-barycentric);\n    if(diff.x > diff.y && diff.x > diff.z)\n        rounded.x = -rounded.y-rounded.z;\n    else if(diff.y > diff.z)\n        rounded.y = -rounded.x-rounded.z;\n    else\n        rounded.z = -rounded.x-rounded.y;\n    return rounded;\n}\n\nvec3 color_at_field(int gp_index, int triangle_latitude, int triangle_longitude, ivec3 cube_coord, vec2 tex_coord) {\n    ivec2 parallelogram_coord = cube_coord.xy;\n    if((triangle_longitude&1) == 1) {\n        parallelogram_coord = ivec2(3*gp_index)-parallelogram_coord;\n    }\n    if(triangle_longitude >= 2) {\n        parallelogram_coord[1] += 3*gp_index;\n    }\n    parallelogram_coord[1] = parallelogram_coord[1]*2+parallelogram_coord[0]%2;\n    parallelogram_coord[0] = (parallelogram_coord[0]+gp_index*2)/2-gp_index;\n    parallelogram_coord[1] = (parallelogram_coord[1]+gp_index*3)/3-gp_index;\n    int parallelogram_width = 1+gp_index/2*3+gp_index%2;\n    parallelogram_coord += ivec2(1+triangle_latitude*(parallelogram_width+2), 2);\n    return vec3(normalize(tex_coord-vec2(0.5))*0.3+vec2(0.8), 0.7);\n    // return cube_coord/gp_index;\n    // return vec3(parallelogram_coord.xy, 0.0)/float(gp_index*4);\n    // const float checker_board = 0.25;\n    // return normalize(vec3(cube_coord)/float(gp_index))*((mod(tex_coord.s, checker_board) < checker_board*0.5 != mod(tex_coord.t, checker_board) < checker_board*0.5) ? 1.0 : 0.8);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    float planet_radius = 20.0;\n    vec3 planet_position = vec3(0.0);\n    \n    vec3 view_ray_origin = vec3(0.0, 0.0, planet_radius*10.0);\n    vec3 view_ray_hit = vec3(fragCoord/iResolution.xy*2.0-vec2(1.0), 0.0);\n    view_ray_hit.x *= iResolution.x/iResolution.y;\n    view_ray_hit.xy *= planet_radius*1.2;\n    vec3 view_ray_direction = normalize(view_ray_hit-view_ray_origin);\n\n    vec3 intersections[2];\n    fragColor = vec4(0.0, 0.0, 0.0, 1.0);\n    if(line_sphere_intersection(view_ray_origin, view_ray_direction, planet_position, planet_radius, intersections) == 0.0)\n        return;\n    vec3 surface_normal = normalize(intersections[0]-planet_position);\n    \n    float rotate_y = (iMouse.x/iResolution.x-0.5+iTime*0.02)*M_PI*2.0;\n    float rotate_x = (iMouse.y/iResolution.y-0.5)*M_PI;\n    surface_normal = (mat4(\n        cos(rotate_y), 0.0, sin(rotate_y), 0.0,\n        0.0, 1.0, 0.0, 0.0,\n        -sin(rotate_y), 0.0, cos(rotate_y), 0.0,\n        0.0, 0.0, 0.0, 1.0\n    )*mat4(\n        1.0, 0.0, 0.0, 0.0,\n        0.0, cos(rotate_x), sin(rotate_x), 0.0,\n        0.0, -sin(rotate_x), cos(rotate_x), 0.0,\n        0.0, 0.0, 0.0, 1.0\n    )*vec4(surface_normal, 1.0)).xyz;\n\n    // Triangles and Barycentric\n    vec3 direction = surface_normal;\n    float longitude = 1.0-acos(direction[1])/M_PI;\n    float latitude = atan(direction[0], direction[2])/M_PI;\n    int triangle_latitude_south = int(mod((2.9+latitude)*2.5, 5.0));\n    int triangle_latitude_north = int(mod((3.1+latitude)*2.5, 5.0));\n    ivec3 pole_indices;\n    int triangle_longitude;\n    int triangle_latitude;\n    if(side_of_half_plane(direction, 1+(triangle_latitude_south+1)%5, 1+triangle_latitude_south)) {\n        pole_indices = ivec3(1+(triangle_latitude_south+1)%5, 1+triangle_latitude_south, 0);\n        triangle_longitude = 0;\n        triangle_latitude = triangle_latitude_south;\n    } else if(side_of_half_plane(direction, 6+triangle_latitude_north, 6+(triangle_latitude_north+1)%5)) {\n        pole_indices = ivec3(6+triangle_latitude_north, 6+(triangle_latitude_north+1)%5, 11);\n        triangle_longitude = 3;\n        triangle_latitude = triangle_latitude_north;\n    } else if(side_of_half_plane(direction, 6+triangle_latitude_north, 1+triangle_latitude_north) &&\n              side_of_half_plane(direction, 1+triangle_latitude_north, 6+(triangle_latitude_north+1)%5)) {\n        pole_indices = ivec3(6+(triangle_latitude_north+1)%5, 6+triangle_latitude_north, 1+triangle_latitude_north);\n        triangle_longitude = 2;\n        triangle_latitude = triangle_latitude_north;\n    } else {\n        pole_indices = ivec3(1+triangle_latitude_south, 1+(triangle_latitude_south+1)%5, 6+(triangle_latitude_south+1)%5);\n        triangle_longitude = 1;\n        triangle_latitude = triangle_latitude_south;\n    }\n    int gp_index = int(planet_radius/(icosahedron_radius_by_edge_length*3.0));\n    vec3 barycentric = inverse_barycentric_interpolation(direction, pole_indices, true)*float(gp_index);\n    ivec3 cube_coord = ivec3(gp_index)-ivec3(rotate_cube_coord(round_cube_coord(rotate_cube_coord(barycentric))));\n    vec3 center_diff;\n\n    // Fix Edge Cases\n    if(cube_coord.x == gp_index*3 || cube_coord.y == gp_index*3 || cube_coord.z == gp_index*3) {\n        center_diff = barycentric*3.0-vec3(cube_coord);\n        if((triangle_longitude&1) == 1) {\n            center_diff *= -1.0;\n        }\n        switch(int(floor(longitude*6.0))) {\n            case 0:\n                triangle_latitude = (5-triangle_latitude)%5;\n            case 5:\n                switch(triangle_latitude) {\n                    case 1:\n                        center_diff = -center_diff.yzx;\n                        break;\n                    case 2:\n                        center_diff = center_diff.zxy;\n                        break;\n                    case 3:\n                        center_diff = center_diff.yzx;\n                        break;\n                    case 4:\n                        center_diff = -center_diff.zxy;\n                        break;\n                }\n                triangle_latitude = 0;\n                break;\n            case 3:\n            case 4:\n                cube_coord = ivec3(0.0, gp_index*3, 0.0);\n                triangle_latitude = triangle_latitude_south;\n                triangle_longitude = 3;\n                break;\n            case 1:\n            case 2:\n                cube_coord = ivec3(gp_index*3, 0.0, 0.0);\n                triangle_latitude = triangle_latitude_north+4;\n                triangle_longitude = 0;\n                break;\n        }\n    } else {\n        switch(triangle_longitude) {\n            case 3:\n                if(cube_coord.y == 0) {\n                    cube_coord.xy = cube_coord.yx;\n                    barycentric = vec3(-barycentric.y, float(gp_index)-barycentric.z, float(gp_index)-barycentric.x);\n                    triangle_latitude += 4;\n                }\n                break;\n            case 2:\n                if(cube_coord.x == 0) {\n                    cube_coord.yz = ivec2(gp_index*3)-cube_coord.yz;\n                    barycentric = vec3(-barycentric.x, float(gp_index)-barycentric.y, float(gp_index)-barycentric.z);\n                    triangle_longitude -= 1;\n                    triangle_latitude += 4;\n                } else if(cube_coord.z == 0) {\n                    cube_coord.xy = ivec2(gp_index*3)-cube_coord.xy;\n                    barycentric = vec3(float(gp_index)-barycentric.x, float(gp_index)-barycentric.y, -barycentric.z);\n                    triangle_longitude += 1;\n                }\n                break;\n            case 1:\n                if(cube_coord.y == 0) {\n                    cube_coord.xz = ivec2(gp_index*3)-cube_coord.xz;\n                    barycentric = vec3(float(gp_index)-barycentric.x, -barycentric.y, float(gp_index)-barycentric.z);\n                    triangle_longitude += 1;\n                } else if(cube_coord.z == 0) {\n                    cube_coord.xy = ivec2(gp_index*3)-cube_coord.xy;\n                    barycentric = vec3(float(gp_index)-barycentric.x, float(gp_index)-barycentric.y, -barycentric.z);\n                    triangle_longitude -= 1;\n                }\n                break;\n            case 0:\n                if(cube_coord.x == 0) {\n                    cube_coord.xy = cube_coord.yx;\n                    barycentric = vec3(float(gp_index)-barycentric.z, -barycentric.x, float(gp_index)-barycentric.y);\n                    triangle_latitude += 4;\n                }\n                break;\n        }\n        center_diff = barycentric*3.0-vec3(cube_coord);\n        if((triangle_longitude&1) == 1) {\n            center_diff *= -1.0;\n        }\n    }\n    triangle_latitude %= 5;\n\n    // Texture Coordinates\n    vec2 tex_coord = vec2(0.5)+0.75*vec2(center_diff.z, (center_diff.x-center_diff.y)/sqrt(3.0))/3.0;\n    vec3 edge_blending = (abs(center_diff)-vec3(1.0-blending_region))/blending_region*0.5;\n    edge_blending = smoothstep(vec3(0.0), vec3(1.0), edge_blending);\n    if((triangle_longitude&1) == 1) {\n        center_diff *= -1.0;\n    }\n    \n    float sum = 1.0-max(max(max(edge_blending.x, edge_blending.y), edge_blending.z), 0.0);\n    fragColor.rgb = sum*color_at_field(gp_index, triangle_latitude, triangle_longitude, cube_coord, tex_coord);\n    \n    // Texture Blending\n    #if 0\n    for(int i = 0; i < 3; ++i) {\n        if(edge_blending[i] > 0.0) {\n            int s = int(sign(center_diff[i]));\n            ivec3 dir = ivec3(0);\n            dir[i] = 2*s;\n            dir[(i+1)%3] = -s;\n            dir[(i+2)%3] = -s;\n            ivec3 neighbor_coord = cube_coord+dir;\n            vec2 neighbor_tex_coord = tex_coord;\n            switch(triangle_longitude) {\n                case 3:\n                case 0:\n                    if(neighbor_coord.x < 0) {\n                        neighbor_tex_coord = (rotate_p60*vec3(tex_coord, 1.0)).xy;\n                    } else if(neighbor_coord.y < 1) {\n                        neighbor_tex_coord = (rotate_m60*vec3(tex_coord, 1.0)).xy;\n                    }\n                    break;\n            }\n            fragColor.rgb += edge_blending[i]*color_at_field(gp_index, triangle_latitude, triangle_longitude, neighbor_coord, neighbor_tex_coord);\n            sum += edge_blending[i];\n        }\n    }\n    fragColor.rgb /= sum;\n    #endif\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/NdBSz1.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "NdBXRh", "name": "Captivating", "author": "Bellatrix", "description": "Just a siimple concentric circle pattern", "tags": ["hypnosis"], "likes": 1, "viewed": 234, "date": "1619607587", "time_retrieved": "2024-06-20T20:37:36.633322", "image_code": "float pattern(in vec2 coords)\n{\n    float dist = length(coords);\n    dist = abs(dist-0.3);\n    float bandwidth = fract(dist*2.-iTime)*0.8 + 0.1;\n    return floor(fract(dist*20.+iTime*2.) + 1.-bandwidth);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 coords = (fragCoord-iResolution.xy/2.)/min(iResolution.x, iResolution.y);\n\n    vec3 col = vec3(pattern(coords));\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/NdBXRh.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "NdfXDN", "name": "Quilez Basic Raytracer I", "author": "GuroGuru", "description": "Studying Iñigo Quilez basic raytracer. Using box intersector.", "tags": ["raytracing", "box", "intersector"], "likes": 0, "viewed": 35, "date": "1619288774", "time_retrieved": "2024-06-20T20:37:36.954481", "image_code": "// Intersectors: https://www.iquilezles.org/www/articles/intersectors/intersectors.htm\nfloat boxIntersector( vec3 ro, vec3 rd ) \n{\n    vec3 boxSize = vec3(1.0);\n    vec3 m = 1.0/rd; // can precompute if traversing a set of aligned boxes\n    vec3 n = m*ro;   // can precompute if traversing a set of aligned boxes\n    vec3 k = abs(m)*boxSize;\n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n    float tN = max( max( t1.x, t1.y ), t1.z );\n    float tF = min( min( t2.x, t2.y ), t2.z );\n    if( tN>tF || tF<0.0) return -1.0; // no intersection\n    return tN;\n}\n\n// Raytracer: https://www.youtube.com/watch?v=9g8CdctxmeU\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Time varying pixel color\n    vec3 col = 0.5 + 0.5*cos( iTime+uv.xyx + vec3( 0, 2, 4 ) );\n\n    // Ray\n    vec3 ro = vec3( 0.0, 0.0, 4.0 );\n    vec3 rd = normalize( vec3( ( -1.0 + 2.0 * uv ) * vec2( 1.78, 1.0 ), -1.0 ) );\n\n    // Transforms\n    float angle = iTime * 0.5;\n    mat3 rotX = mat3 ( \n        1.0, 0.0,           0.0, \n        0.0, cos( angle ), -sin( angle ), \n        0.0, sin( angle ),  cos( angle )\n    );\n    mat3 rotY = mat3( \n        cos( angle ),  0.0, sin( angle ), \n        0.0,           1.0, 0.0, \n        -sin( angle ), 0.0, cos( angle ) \n    );\n\n    // Transform ray\n    ro *= rotY * rotX;\n    rd *= rotY * rotX;\n\n    // Intersection\n    float id = boxIntersector( ro, rd ) * 1.5; \n    \n\n    // Output to screen\n    fragColor = vec4(col + 0.15, 1.0) * id + vec4(col + 0.1, 1.0) * (1.0 - id);\n    \n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/NdfXDN.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "NdfXRX", "name": "Shader Three js", "author": "hitaboy", "description": "Shader to threejs test", "tags": ["threejs"], "likes": 7, "viewed": 289, "date": "1618924974", "time_retrieved": "2024-06-20T20:37:37.548439", "image_code": "\nvec3 palette(float i)\n{\n\tif(i<4.0)\n\t{\n\t\tif(i<2.0)\n\t\t{\n\t\t\tif(i<1.0) return vec3(0.0,0.0,0.0);\n\t\t\telse return vec3(1.0,3.0,31.0);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif(i<3.0) return vec3(1.0,3.0,53.0);\n\t\t\telse return vec3(28.0,2.0,78.0);\n\t\t}\n\t}\n\telse if(i<8.0)\n\t{\n\t\tif(i<6.0)\n\t\t{\n\t\t\tif(i<5.0) return vec3(80.0,2.0,110.0);\n\t\t\telse return vec3(143.0,3.0,133.0);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif(i<7.0) return vec3(181.0,3.0,103.0);\n\t\t\telse return vec3(229.0,3.0,46.0);\n\t\t}\n\t}\n\telse\n\t{\n\t\tif(i<10.0)\n\t\t{\n\t\t\tif(i<9.0) return vec3(252.0,73.0,31.0);\n\t\t\telse return vec3(253.0,173.0,81.0);\n\t\t}\n\t\telse if(i<12.0)\n\t\t{\n\t\t\tif(i<11.0) return vec3(254.0,244.0,139.0);\n\t\t\telse return vec3(239.0,254.0,203.0);\n\t\t}\n\t\telse\n\t\t{\n\t\t\treturn vec3(242.0,255.0,236.0);\n\t\t}\n\t}\n}\n\n\nvec4 colour(float c)\n{\n\tc*=12.0;\n\tvec3 col1=palette(c)/256.0;\n\tvec3 col2=palette(c+1.0)/256.0;\n\treturn vec4(mix(col1,col2,c-floor(c)),1.0);\n}\n\nfloat periodic(float x,float period,float dutycycle)\n{\n\tx/=period;\n\tx=abs(x-floor(x)-0.5)-dutycycle*0.5;\n\treturn x*period;\n}\n\nfloat pcount(float x,float period)\n{\n\treturn floor(x/period);\n}\n\nfloat distfunc(vec3 pos)\n{\n\tvec3 gridpos=pos-floor(pos)-0.5;\n\tfloat r=length(pos.xy);\n\tfloat a=atan(pos.y,pos.x);\n\ta+=iTime*0.3*sin(pcount(r,3.0)+1.0)*sin(pcount(pos.z,1.0)*13.73);\n\treturn min(max(max(\n\tperiodic(r,3.0,0.2),\n\tperiodic(pos.z,1.0,0.7+0.3*cos(iTime/3.0))),\n\tperiodic(a*r,3.141592*2.0/6.0*r,0.7+0.3*cos(iTime/3.0))),\n\t0.25);\n\t//return max(length(gridpos)-0.5,\n\t//\t  abs(r-floor(r)-0.5)-0.1);\n}\n\nvoid mainVR(out vec4 fragColor, in vec2 fragCoord, in vec3 pos, in vec3 dir)\n{\n\tvec3 ray_dir=-dir;\n\tvec3 ray_pos=pos;\n\n\tfloat a=cos(iTime)*0.0*0.4;\n\tray_dir=ray_dir*mat3(\n\t\tcos(a),0.0,sin(a),\n\t\t0.0,1.0,0.0,\n\t\t-sin(a),0.0,cos(a)\n\t);\n\n\tfloat i=192.0;\n\tfor(int j=0;j<192;j++)\n\t{\n\t\tfloat dist=distfunc(ray_pos);\n\t\tray_pos+=dist*ray_dir;\n\n\t\tif(abs(dist)<0.001) { i=float(j); break; }\n\t}\n\n\tfloat c=i/192.0;\n\tfragColor=colour(c);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord) {\n\tvec2 coords=(2.0*fragCoord.xy-iResolution.xy)/max(iResolution.x,iResolution.y);\n\n\tvec3 ray_dir=normalize(vec3(coords,1.0+0.0*sqrt(coords.x*coords.x+coords.y*coords.y)));\n\tvec3 ray_pos=vec3(0.0,-1.0,iTime*1.0);\n\n\n    mainVR(fragColor, fragCoord, ray_pos, -ray_dir);\n}\n\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/NdfXRX.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "NdfXW4", "name": "Lone Buoy", "author": "MatthieuJacquemet", "description": "simple ocean scene with yellow buoy", "tags": ["waves", "sea", "water", "ocean", "sky", "buoy"], "likes": 22, "viewed": 245, "date": "1618607534", "time_retrieved": "2024-06-20T20:37:46.082612", "image_code": "// Jacquemet Matthieu\n\n// Contants --------------------------------------------------------------------------------------------\nconst float PI   = 3.141592653589793238462643383279502884197169;\nconst float PI_2 = 1.570796326794896619231321691639751442098585;\nconst float PI_4 = 0.785398163397448309615660845819875721049292;\n\nconst int MAX_STEPS = 100;      // Number of steps\nconst int WAVE_OCTAVES = 12;\nconst int WAVE_NORMAL_OCTAVES = 32;\nconst float EPSILON = 0.001; // Marching epsilon\nconst float K = 1.0;\nconst float WATER_LEVEL = 0.0;\n\n// Structure for objects\n// v : Field value\n// i : Texture index\nstruct TraceData {\n    float v; \n    int i;\n};\n\n// Structure for texture\n// c : Color\n// s : Specular\nstruct Material {\n    vec3 albedo;\n    vec3 emissive;\n    float roughness;\n    float metallic;\n};\n\n\n#define TONEMAP_LINEAR 0 \n#define TONEMAP_FILMIC 1\n#define TONEMAP_REINHARD 2\n#define TONEMAP_FILMIC_REINHARD 3\n#define TONEMAP_UNCHARTED2 4\n#define TONEMAP_ACES 5\n\n#define MATERIAL_PLASTIC 0\n#define MATERIAL_BUOY 1\n#define MATERIAL_WATER 2\n#define MATERIAL_BEACON 3\n#define MATERIAL_METAL 4\n#define MATERIAL_BLACK_PLASTIC 5\n\n\n#define SPECULAR_GGX 0\n#define SPECULAR_BLINN 1\n#define SPECULAR_BECKMANN 2\n\n#define SPECULAR_MODE SPECULAR_GGX\n#define TONEMAP_MODE TONEMAP_ACES // Tone mapping mode\n#define _DEBUG 0               // set 1 to enable debuging\n\n\n\n#if _DEBUG\n    vec3 _debug_color;\n    bool _is_debug = false;\n    #define DEBUG(color) if (_is_debug) _debug_color = color; // use this to debug a color\n    #define CATCH_DEBUG(expr) _is_debug = true; expr ; _is_debug = false;\n#else\n    #define DEBUG(color)\n    #define CATCH_DEBUG(expr) expr // any call to DEBUG(color) in this macro will output de color\n#endif\n\nbool _trace_ocean = true;\nmat4 buoy_trans;\n\n#define NO_TRACE_OCEAN(expr) _trace_ocean = false; expr ; _trace_ocean = true;\n\n// Primitive functions -----------------------------------------------------------------------------------\n\n\n// Hashing function\n// Returns a random number in [-1,1]\nfloat Hash(float seed)\n{\n    return fract(sin(seed)*43758.5453 );\n}\n\n\n// Cosine direction \n// seed : Random seed\n//    n : Normal\nvec3 Cosine( in float seed, in vec3 n)\n{\n    float u = Hash( 78.233 + seed);\n    float v = Hash( 10.873 + seed);\n\n    // Method by fizzer: http://www.amietia.com/lambertnotangent.html\n    float a = 6.2831853 * v;\n    u = 2.0 * u - 1.0;\n    return normalize( n + vec3(sqrt(1.0-u*u)* vec2(cos(a), sin(a)), u) );\n}\n\n\n// saturate\nfloat sat(float x) {\n\n    return clamp(x, 0.0, 1.0);\n}\n\n// saturate\nvec3 sat(vec3 x) {\n\n    return clamp(x, 0.0, 1.0);\n}\n\n// Map value from [Imin, Imax] to [Omin, Omax]\nfloat map(float value, float Imin, float Imax, float Omin, float Omax) {\n  \n  return Omin + (value - Imin) * (Omax - Omin) / (Imax - Imin);\n}\n\nfloat dot2(in vec2 v) {\n    \n    return dot(v,v);\n}\n\nfloat dot2(in vec3 v) {\n    \n    return dot(v,v);\n}\n\n// Tranforms --------------------------------------------------------------------\n\n// Translate point p\nvec3 Translate(vec3 pos, vec3 p) {\n\n    return p - pos;\n}\n\n// Scale point p\nvec3 Scale(vec3 scale, vec3 p) {\n\n    return vec3(p.x/scale.x, p.y/scale.y, p.z/scale.z);\n}\n\n// Rotate point p around X axis (radians)\nvec3 RotateX(float theta, vec3 p)\n{   \n    float _sin = sin(theta);\n    float _cos = cos(theta);\n\n    mat3 M = mat3(  1,     0,     0,\n                    0,  _cos, -_sin,\n                    0,  _sin,  _cos);\n    \n    return M*p;\n}\n\n// Rotate point p around Y axis (radians)\nvec3 RotateY(float theta, vec3 p)\n{   \n    float _sin = sin(theta);\n    float _cos = cos(theta);\n\n    mat3 M = mat3( _cos,    0,  -_sin,\n                    0,      1,      0,\n                   _sin,    0,   _cos);\n    \n    return M*p;\n}\n\n// Rotate point p around Z axis (radians)\nvec3 RotateZ(float theta, vec3 p)\n{   \n    float _sin = sin(theta);\n    float _cos = cos(theta);\n\n    mat3 M = mat3(  _cos,  -_sin,   0,\n                    _sin,   _cos,   0,\n                    0,      0,      1);\n\n    return M*p;\n}\n\n// Rotate point p\nvec3 Rotate(vec3 rot, vec3 p)\n{\n    p = RotateX(rot.x, p);\n    p = RotateY(rot.y, p);\n    p = RotateZ(rot.z, p);\n\n    return p;\n}\n\n\n// Create scaling matrix\nmat3 Scaling(vec3 scale) {\n\n    return mat3(1.0/scale.x,0,          0,\n                0,          1.0/scale.y,0,\n                0,          0,          1.0/scale.z);\n}\n\n// Create rotation matrix for theta angle around X axis (radians)\nmat3 RotationX(float theta)\n{   \n    float _sin = sin(theta);\n    float _cos = cos(theta);\n\n    return mat3(    1,     0,     0,\n                    0,  _cos, -_sin,\n                    0,  _sin,  _cos);\n}\n\n// Create rotation matrix for theta angle around Y axis (radians)\nmat3 RotationY(float theta)\n{   \n    float _sin = sin(theta);\n    float _cos = cos(theta);\n\n    return mat3( _cos,     0, -_sin,\n                    0,     1,     0,\n                 _sin,     0,  _cos);\n}\n\n// Create rotation matrix for theta angle around Z axis (radians)\nmat3 RotationZ(float theta)\n{   \n    float _sin = sin(theta);\n    float _cos = cos(theta);\n\n    return mat3(_cos, -_sin,  0,\n                _sin,  _cos,  0,\n                0,     0,     1);\n}\n\n// Create rotation matrix for the 3 axes (radians)\nmat3 Rotation(float x, float y, float z) \n{\n    return RotationZ(z) * RotationY(y) * RotationX(x);\n}\n\n// Create rotation matrix for the 3 axes (radians)\nmat3 Rotation(vec3 rot)\n{\n    return Rotation(rot.x, rot.y, rot.y);\n}\n\n// Create translation matrix\nmat4 Translation(vec3 trans) {\n\n    mat4 M = mat4(1.0);\n    M[3] = vec4(-trans, 1.0);\n\n    return M;\n}\n\n// Create transform matrix \nmat4 Transform(vec3 scale, vec3 rot, vec3 trans) \n{\n    return mat4(Scaling(scale) * Rotation(rot)) * Translation(trans);\n}\n\n// Transform of point p\nvec3 Transform(vec3 scale, vec3 rot, vec3 trans, vec3 p)\n{\n    p = Scale(scale, p);\n    p = Rotate(rot, p);\n    p = Translate(trans, p);\n\n    return p;\n}\n\n// Texturing and noise ---------------------------------------------------------\n\n// Hashing function\n// Returns a random number in [-1,1]\n// p : Vector in space\nfloat Hash(in vec3 p)  \n{\n    p  = fract( p*0.3199+0.152 );\n\tp *= 17.0;\n    return fract( p.x*p.y*p.z*(p.x+p.y+p.z) );\n}\n\n\n// Hashing function\n// Returns a random number in [-1,1]\n// p : Vector in the plane\nfloat Hash(in vec2 p)  \n{\n    p  = fract( p*0.3199+0.152 );\n\tp *= 17.0;\n    return fract( p.x*p.y*(p.x+p.y) );\n}\n\n\n// Procedural value noise with cubic interpolation\n// x : Point \nfloat Noise(in vec3 p)\n{\n    vec3 i = floor(p);\n    vec3 f = fract(p);\n  \n    f = f*f*(3.0-2.0*f);\n    // Could use quintic interpolation instead of cubic\n    // f = f*f*f*(f*(f*6.0-15.0)+10.0);\n\n    return mix(mix(mix( Hash(i+vec3(0,0,0)), \n                        Hash(i+vec3(1,0,0)),f.x),\n                   mix( Hash(i+vec3(0,1,0)), \n                        Hash(i+vec3(1,1,0)),f.x),f.y),\n               mix(mix( Hash(i+vec3(0,0,1)), \n                        Hash(i+vec3(1,0,1)),f.x),\n                   mix( Hash(i+vec3(0,1,1)), \n                        Hash(i+vec3(1,1,1)),f.x),f.y),f.z);\n}\n\n// Procedural value noise with cubic interpolation\n// x : Point \nfloat Noise(in vec2 p)\n{\n    vec2 i = floor(p);\n    vec2 f = fract(p);\n  \n    f = f*f*(3.0-2.0*f);\n    // Could use quintic interpolation instead of cubic\n    // f = f*f*f*(f*(f*6.0-15.0)+10.0);\n\n    return mix(mix( Hash(i+vec2(0,0)), \n                        Hash(i+vec2(1,0)),f.x),\n                   mix( Hash(i+vec2(0,1)), \n                        Hash(i+vec2(1,1)),f.x),f.y);\n}\n\n\n// Compute the distance to the Voronoi boundary\n// x : Point\n// Return (closest distance, second closest, cell id)\nvec3 Voronoi( in vec3 x )\n{\n    vec3 p = floor( x );\n    vec3 f = fract( x );\n\n\tfloat id = 0.0;\n    vec2 res = vec2( 100.0 );\n    for( int k=-1; k<=1; k++ )\n    for( int j=-1; j<=1; j++ )\n    for( int i=-1; i<=1; i++ )\n    {\n        vec3 b = vec3( float(i), float(j), float(k) );\n        vec3 r = vec3( b ) - f + Hash( p + b );\n        float d = dot( r, r );\n\n        if( d < res.x )\n        {\n\t\t\tid = dot( p+b, vec3(1.0,57.0,113.0 ) );\n            res = vec2( d, res.x );\t\t\t\n        }\n        else if( d < res.y )\n        {\n            res.y = d;\n        }\n    }\n\n    return vec3( sqrt( res ), abs(id) );\n}\n\n// adated from https://www.iquilezles.org/www/articles/smoothvoronoi/smoothvoronoi.htm\nfloat SmoothVoronoi( in vec2 x )\n{\n    vec2 p = floor( x );\n    vec2  f = fract( x );\n\n    float res = 0.0;\n    for( int j=-1; j<=1; j++ )\n    for( int i=-1; i<=1; i++ )\n    {\n        vec2 b = vec2( i, j );\n        vec2  r = vec2( b ) - f + Hash( p + b );\n        float d = dot( r, r );\n\n        res += 1.0/pow( d, 8.0 );\n    }\n    return pow( 1.0/res, 1.0/16.0 );\n}\n\n// based on https://www.shadertoy.com/view/llG3zy\nvec3 VoronoiE( in vec3 x )\n{\n    vec3 n = floor(x);\n    vec3 f = fract(x);\n\n    //----------------------------------\n    // first pass: regular voronoi\n    //----------------------------------\n\tvec3 mr;\n\n    float md = 8.0;\n    for( int k=-1; k<=1; k++ )\n    for( int j=-1; j<=1; j++ )\n    for( int i=-1; i<=1; i++ )\n    {\n        vec3 g = vec3(float(i),float(j), float(k));\n\t\tvec3 o = vec3( g ) - f + Hash( n + g );\n        vec3 r = g + o - f;\n        float d = dot(r,r);\n\n        if( d<md )\n        {\n            md = d;\n            mr = r;\n        }\n    }\n\n    //----------------------------------\n    // second pass: distance to borders,\n    // visits only neighbouring cells\n    //----------------------------------\n    md = 8.0;\n    for( int k=-1; k<=1; k++ )\n    for( int j=-1; j<=1; j++ )\n    for( int i=-1; i<=1; i++ )\n    {\n        vec3 g = vec3(float(i),float(j), float(k));\n\t\tvec3 o = vec3( g ) - f + Hash( n + g );\n\t\tvec3 r = g + o - f;\n\n        if( dot(mr-r,mr-r)>EPSILON ) // skip the same cell\n        md = min( md, dot( 0.5*(mr+r), normalize(r-mr) ) );\n    }\n\n    return vec3( md, mr );\n}\n\n\n// Fractal brownian motion\nfloat Fbm(vec3 p, int octaves) {\n\n    float v = 0.0,  a = 0.5;\n    mat3 R = RotationX(.37);\n\n    for (int i = 0; i < octaves; ++i, p*=2.0, a/=2.0) { \n        p *= R;\n        v += a * Noise(p);\n    }\n\n    return v;\n}\n\n// Voronoi fractal brownian motion\nvec3 FbmVoronoi(vec3 p, int octave) {\n\n    vec3 v = vec3(0.0);\n    float a = 0.5;\n    mat3 R = RotationX(.37);\n\n    for (int i = 0; i < octave; ++i, p*=2.0, a/=2.0) {\n        p *= R;\n        v += a * Voronoi(p);\n    }\n\n    return v;\n}\n\n\n// Camera -----------------------------------------------------------------------\n\n\n// Compute the ray\n//      m : Mouse position\n//      p : Pixel\n// ro, rd : Ray origin and direction\nmat3 Camera(in vec2 m, out vec3 ro)\n{\n    // position camera\n    ro=vec3(-3.0,0.0,0.0);\n    \n    // reset camera position\n    // shadertoy initialize mouse position at (0,0)\n    if (m == vec2(0))\n        m = vec2(0.9, -0.3);\n    else\n        m = (m*2.0 - vec2(1.0))*3.0;\n\n    m.y = clamp(-m.y, -0.05, PI_2 - 0.1); // clamp camera's y rotation\n\n    ro = RotateY(m.y, ro);\n    ro = RotateZ(m.x, ro);\n\n    vec3 ww = normalize(-ro);\n    vec3 uu = normalize( cross(ww,vec3(0.0,0.0,1.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n\n\treturn mat3(uu, vv, ww);\n}\n\n\n\n\n// Sphere \n// p : point\n// c : center \n// r : radius\nTraceData Sphere(vec3 p, vec3 c,float r,int index)\n{\n    return TraceData(length(p-c)-r,index);\n}\n\n\nTraceData Box(vec3 point, vec3 box, int tex) {\n\n  vec3 q = abs(point) - box;\n  float v = length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n  return TraceData(v, tex);\n}\n\n\n// Plane \n// p : point\n// n : Normal of plane\n// o : Point on plane\nTraceData Plane(vec3 p, vec3 n, vec3 o, int index)\n{\n    return TraceData(dot((p-o),n),index);\n}\n\n// Union\n// a : field function of left sub-tree\n// b : field function of right sub-tree\nTraceData Union(TraceData a,TraceData b)\n{\n    if (a.v < b.v)\n        return a;\n    else \n        return b;\n}\n\n// Intersection, preserve the index of first object\n// a, b : field function of left and right sub-trees\nTraceData Inter(TraceData a,TraceData b)\n{\n    if (a.v > b.v)\n        return a;\n    else \n        return b;\n}\n\n\n// Difference, preserve the index of first object\n// a, b : field function of left and right sub-trees\nTraceData Diff(TraceData a, TraceData b) {\n\n    return Inter(a, TraceData(-b.v, b.i));\n}\n\n\n\n// https://www.iquilezles.org/www/articles/distfunctions/distfunctions.html\n\n// Union with smoothing\n// a : Field function of left sub-tree, \n// b : Field function of right sub-tree\nTraceData SmoothUnion( TraceData a, TraceData b, float k ) \n{\n    float h = clamp( 0.5 + 0.5*(b.v-a.v)/k, 0.0, 1.0 );\n    return TraceData(mix( b.v, a.v, h ) - k*h*(1.0-h), a.i);\n}\n\n// Difference with smoothing\n// a : Field function of left sub-tree, \n// b : Field function of right sub-tree\nTraceData SmoothDiff( TraceData a, TraceData b, float k ) \n{\n    float h = clamp( 0.5 - 0.5*(a.v+b.v)/k, 0.0, 1.0 );\n    return TraceData(mix( a.v, -b.v, h ) + k*h*(1.0-h), a.i); \n}\n\n// Intersection with smoothing\n// a : field function of left sub-tree, \n// b : field function of right sub-tree\nTraceData SmoothInter( TraceData a, TraceData b, float k )\n{\n    float h = clamp( 0.5 - 0.5*(a.v-b.v)/k, 0.0, 1.0 );\n    return TraceData(mix( a.v, b.v, h ) + k*h*(1.0-h), a.i);\n}\n\n\nfloat almostIdentity( float x, float n )\n{\n    return sqrt(x*x+n);\n}\n\nfloat Overlay(in float a, in float b) {\n\n    if (a  < 0.5)\n        return 2.0*a*b;\n    else\n        return 1.0 - 2.0*(1.0-a)*(1.0-b);\n}\n\n\n\nTraceData Segment(vec3 point, vec3 a, vec3 b, int tex) {\n\n    vec3 ba = b-a;\n    vec3 pa = point-a;\n    float t = dot(pa, ba) / dot(ba, ba);\n    vec3 c = ba*clamp(t, 0.0, 1.0);\n    \n    return TraceData(length(pa - c), tex);\n}\n\n\nTraceData Capsule(vec3 point, vec3 a, vec3 b, float radius, int tex) {\n\n    return TraceData(Segment(point, a, b, tex).v - radius, tex);\n}\n\n\nTraceData Cylinder(vec3 point, vec3 a, vec3 b, float radius, int tex) {\n\n    TraceData caps = Capsule(point, a, b, radius, tex);\n    TraceData plane = Plane(point, normalize(a-b), b, tex);\n\n    TraceData d = Diff(caps, plane);\n    \n    return Diff(d, Plane(point, normalize(b-a), a, tex));\n}\n\n\n// based on https://iquilezles.untergrund.net/www/articles/distfunctions/distfunctions.html\nTraceData RoundedCylinder(vec3 point, float radius, float k, float h, int tex)\n{\n    vec2 d = vec2( length(point.xy) - 2.0 * radius + k, abs(point.z) - h);\n    float v = min(max(d.x,d.y),0.0) + length(max(d,0.0)) - k;\n\n    return TraceData(v, tex);\n}\n\n\n// based on https://iquilezles.untergrund.net/www/articles/distfunctions/distfunctions.html\nTraceData CappedCone(vec3 p, float h, float r1, float r2, int tex)\n{\n    vec2 q = vec2( length(p.xy), p.z );\n    vec2 k1 = vec2(r2,h);\n    vec2 k2 = vec2(r2-r1,2.0*h);\n    vec2 ca = vec2(q.x-min(q.x,(q.y<0.0)?r1:r2), abs(q.y)-h);\n    vec2 cb = q - k1 + k2*clamp( dot(k1-q,k2)/dot2(k2), 0.0, 1.0 );\n    float s = (cb.x<0.0 && ca.y<0.0) ? -1.0 : 1.0;\n    s *= sqrt(min(dot2(ca),dot2(cb)));\n\n    return TraceData(s, tex);\n}\n\nTraceData Circle(vec3 point, float radius, int tex)\n{\n    vec2 p;\n    p.x = length(point.xy) - radius;\n    p.y = point.z;\n\n    return TraceData(length(p), tex);\n}\n\n\nTraceData Torus(vec3 point, float radius, float r, int tex)\n{\n    TraceData vp = Circle(point, radius, tex);\n    vp.v -= r;\n    return vp;\n}\n\n\n// based on https://iquilezles.untergrund.net/www/articles/distfunctions/distfunctions.html\nTraceData TriPrism(vec3 p, vec2 h, int tex)\n{\n    vec3 q = abs(p);\n    float v = max(q.x-h.y,max(q.z*0.866025+p.y*0.5,-p.y)-h.x*0.5);\n    return TraceData(v, tex);\n}\n\n\n// based on https://iquilezles.untergrund.net/www/articles/distfunctions/distfunctions.html\nTraceData Ellipsoid(vec3 p, vec3 r, int tex)\n{\n    float k0 = length(p/r);\n    float k1 = length(p/(r*r));\n    float v = k0*(k0-1.0)/k1;\n    return TraceData(v, tex);\n}\n\n\nfloat Troichoid(in float x, in float t) {\n\n    float A = 0.5 + 0.4 * sin(0.1 * t * 2.0 * PI);\n    return A - 2.0 * A * pow(1.0 - pow(0.5 + 0.5 * sin(x), A + 1.0), 1.0 / (A + 1.0));\n}\n\n\n\nvec2 Wave(vec2 p, vec2 d, float speed, float frequency, float phase) {\n\n    float x = dot(d, p) * frequency + phase * speed;\n    float wave = exp(sin(x) - 1.0);\n    float dx = wave * cos(x);\n    return vec2(wave, -dx);\n}\n\n\nfloat Ocean(in vec2 p, in int octaves) {\n    \n    p *= 0.7;\n    \n    mat2 R = mat2(RotationZ(12.0));\n    vec2 dir = vec2(0,1);\n\n    float freq = 6.0;\n    float speed = 2.0;\n    float w = 1.0;\n    float s = 0.0;\n    float h = 0.0;\n\n    for(int i=0; i<octaves; i++){\n        vec2 res = Wave(p, dir, speed, freq, iTime);\n        p += dir * w * res.y * 0.038;\n        h += res.x * w;\n        s += w;\n        w = mix(w, 0.0, 0.2);\n        freq *= 1.18;\n        speed *= 1.07;\n        dir *= R;\n    }\n    return h / s * 0.2;\n}\n\n\nTraceData ImplicitOcean(in vec3 p)\n{\n    float z = Ocean(p.xy, WAVE_OCTAVES);\n    float h = p.z - z;\n\n    return TraceData(h, MATERIAL_WATER);\n}\n\n\nTraceData RoundCone(vec3 p, float r1, float r2, float h, int tex)\n{\n    vec2 q = vec2( length(p.xy), p.z );\n\n    float b = (r1-r2)/h;\n    float a = sqrt(1.0-b*b);\n    float k = dot(q,vec2(-b,a));\n\n    float v;\n\n    if( k < 0.0 ) \n        v = length(q) - r1;\n    else if( k > a*h )\n        v = length(q-vec2(0.0,h)) - r2;\n    else\n        v = dot(q, vec2(a,b)) - r1;\n        \n    return TraceData(v, tex);\n}\n\n\nTraceData SolidAngle(vec3 p, vec2 c, float ra, int tex)\n{\n    // c is the sin/cos of the angle\n    vec2 q = vec2( length(p.xy), p.z );\n    float l = length(q) - ra;\n    float m = length(q - c*clamp(dot(q,c),0.0,ra) );\n    float v = max(l,m*sign(c.y*q.x-c.x*q.y));\n    return TraceData(v, tex);\n}\n\n\nTraceData Frame(in vec3 p, in vec2 size) {\n\n    TraceData frame = Box(p, vec3(vec2(size),0.02), MATERIAL_BUOY);\n    return Diff(frame, Box(p, vec3(vec2(size)-vec2(0.02),0.03), MATERIAL_BUOY));\n}\n\n\nTraceData Propeller(in vec3 p, in int tex) {\n\n    p = RotateY(iTime*10.0, p);\n    vec3 pp = p;\n    pp.y -= 0.02;\n    pp.xz = abs(p.xz);\n    pp = RotateY(-PI_4, pp);\n    pp = RotateZ(0.4, pp);\n    TraceData d = SolidAngle(pp, vec2(0.2955, 0.9553), 0.07, tex);\n    d = Inter(d, Box(pp, vec3(0.1,0.002,0.1), tex));\n\n    TraceData tip = Ellipsoid(p+vec3(0,0.05,0.0), vec3(0.02,0.1,0.02), tex);\n    tip = Inter(tip, Plane(p, vec3(0,-1,0), vec3(0,-0.005,0), tex));\n    d = Union(d, tip);\n\n    return d;  \n}\n\n\nTraceData Anemometer(in vec3 p) {\n\n    TraceData d = Capsule(p, vec3(0,0.05,0), vec3(0,0.05,-0.1), 0.01, MATERIAL_METAL);\n    d = Union(d, Ellipsoid(p, vec3(0.02,0.15,0.02), MATERIAL_METAL));\n    d = Inter(d, Plane(p, vec3(0,1,0), vec3(0,0.07,0), MATERIAL_METAL));\n    d = Union(d, Propeller(p-vec3(0,0.08,0), MATERIAL_BLACK_PLASTIC));\n\n    vec3 tail_p = (p+vec3(0,0.11,0))*vec3(1,2.0,1);\n    TraceData tail = TriPrism(tail_p, vec2(0.1,0.002), MATERIAL_METAL);\n    tail = Inter(tail, Box(p, vec3(0.1,0.3,0.05), MATERIAL_METAL));\n\n    d = Union(d, tail);\n\n    return d;\n}\n\n\nTraceData Buoy(in vec3 p) {\n\n    p = (buoy_trans * vec4(p,1.0)).xyz;\n\n    // base;\n    TraceData base = RoundedCylinder(p, 0.3, 0.05, 0.3, MATERIAL_BUOY);\n    base = Union(base, Cylinder(p, vec3(0), vec3(0,0,0.45), 0.17, MATERIAL_BUOY));\n    base = Union(base, Cylinder(p, vec3(0,0,0.45), vec3(0,0,0.48), 0.2, MATERIAL_BUOY));\n\n    // rig\n    vec3 rig_p = p;\n    rig_p.xy = abs(rig_p.xy);\n    rig_p = RotateZ(PI_4, rig_p);\n    rig_p -= vec3(0.25,0,0.9);\n    rig_p = RotateY(0.15, rig_p);\n    rig_p = RotateZ(PI_4, rig_p);\n\n    TraceData rig = Box(rig_p, vec3(0.02,0.02,0.6), MATERIAL_BUOY);\n    rig = Union(rig, Box(p-vec3(0,0,1.47), vec3(0.13,0.13,0.02), MATERIAL_BUOY));\n    rig = Union(rig, Frame(p-vec3(0,0,0.38), vec2(0.3)));\n    rig = Union(rig, Frame(p-vec3(0,0,1.1), vec2(0.16)));\n    rig.v -= 0.005;\n\n    // beacon\n    TraceData beacon = CappedCone(p-vec3(0,0,1.6), 0.05, 0.040, 0.02, MATERIAL_BEACON);\n    beacon.v -= 0.02;\n    beacon = Union(beacon, Cylinder(p, vec3(0,0,1.45), vec3(0,0,1.55), 0.067, MATERIAL_BLACK_PLASTIC));\n\n    // top part\n    vec3 top_part_p = p;\n    top_part_p.xy = abs(top_part_p.xy);\n    TraceData top_part = Torus(p-vec3(0,0,1.65), 0.25, 0.007, MATERIAL_METAL);\n    \n    top_part = Union(top_part, Capsule(top_part_p, vec3(0.11,0.13,1.45), \n                            vec3(0.11,0.22,1.65), 0.007, MATERIAL_METAL));\n\n    top_part = Union(top_part, Capsule(top_part_p, vec3(0.13,0.11,1.45), \n                            vec3(0.22,0.11,1.65), 0.007, MATERIAL_METAL));\n    \n    top_part = Union(top_part, Anemometer(p-vec3(0.25,-0.05,1.75)));\n    \n    top_part = Union(top_part, Capsule(p, vec3(0.05,0.05,1.2), \n                        vec3(0.05,0.05,1.37), 0.07, MATERIAL_PLASTIC));\n\n    return Union(Union(Union(base, rig), beacon), top_part);\n}\n\n\n// Potential field of the object\n// p : point\nTraceData Object(vec3 p)\n{\n    // p.xy += vec2(-2,12);\n    // p.xy += vec2(0,5);\n    TraceData d = Buoy(p);\n\n    if (_trace_ocean)\n        d = Union(d, ImplicitOcean(p));\n\n    return d;\n}\n\n// Analysis of the scalar field --------------------------------------------------------------------------\n\nvec3 OceanNormal(in vec2 p, in int octaves, out float h) {\n\n    // vec2 ex = vec2(e, 0);\n    const float epsilon = 0.01;\n\n    h = Ocean(p, octaves);\n\n    float dx = h - Ocean(p + vec2(epsilon, 0), octaves);\n    float dy = h - Ocean(p + vec2(0, epsilon), octaves);\n\n    return normalize(vec3(dx, dy, epsilon));\n}\n\n\n\n// Calculate object normal\nvec3 ComputeNormal(in vec3 p, inout int matID) {\n\n    float h;\n    TraceData vp;\n    \n    if (matID == 0) {\n        vp = Object(p);\n        matID = vp.i;\n    }\n\n    if (matID == MATERIAL_WATER)\n        return OceanNormal(p.xy, WAVE_NORMAL_OCTAVES, h);\n    \n    float eps = 0.001;\n    vec3 n;\n\n    NO_TRACE_OCEAN(\n\n    float v = vp.v;\n    n.x = Object( vec3(p.x+eps, p.y, p.z) ).v - v;\n    n.y = Object( vec3(p.x, p.y+eps, p.z) ).v - v;\n    n.z = Object( vec3(p.x, p.y, p.z+eps) ).v - v;\n\n    )\n\n    return normalize(n);\n}\n\n\nfloat DistToPlane(in vec3 ro, in vec3 rd, in float h) {\n\n    return -(ro.z-h) / rd.z;\n}\n\n\n// Trace ray using ray marching\n// o : ray origin\n// u : ray direction\n// e : Maximum distance \n// h : hit\n// s : Number of steps\nfloat SphereTrace(vec3 o, vec3 u, float e,out bool h,out int s)\n{\n    h = false;\n\n    // Start at the origin\n    float t=0.0;\n\n    for(int i=0; i<MAX_STEPS; i++)\n    {\n        s=i;\n        vec3 p = o+t*u;\n        float v = Object(p).v;\n        // Hit object\n        if (v < 0.0)\n        {\n            s=i;\n            h = true;\n            break;\n        }\n        // Move along ray\n        t += max(EPSILON, v / K);\n        // Escape marched too far away\n        if (t>e)\n        {\n            break;\n        }\n    }\n\n    return t;\n}\n\n// Lighting ----------------------------------------------------------------------------------------------\n\nstruct DirectionalLight {\n    vec3 direction;\n    vec3 color;\n    float energy;\n    float shadow_dist;\n};\n\nDirectionalLight sun;\n\n// Compute ambient occlusion based on https://www.shadertoy.com/view/3lXyWs\n// p : Point\n// n : Normal at point\nfloat AmbientOcclusion(vec3 p,vec3 n) {\n\n    const int AO_STEPS = 4;\n    const float AO_MAX_DIST = 3.0;\n\n    const float SCALE = AO_MAX_DIST / pow(2.0, float(AO_STEPS))*2.0;\n    float ocl = 0.0;\n\n    for(int i = 1; i <= AO_STEPS; ++i) {\n        float dist = pow(2.0, float(i)) * SCALE;\n        ocl += 1.0 - (max(0.0, Object(p + n * dist).v) / dist);\n    }\n    \n    return min(1.0-(ocl / float(AO_STEPS)),1.0);\n    // return pow(abs(Object(p + 2.0 * n)),0.9);\n}\n\n\n// Cast soft shadow based on https://www.shadertoy.com/view/tlBcDK\n// p : Point\n// l : Point to light vector\n// d : Max tracing distance\n// r : Softness radius\nfloat Shadow(vec3 p,vec3 l, float d, float r)\n{\n\n    float res = 1.0;\n    float t = 0.1;\n\n    for (int i = 0; i < MAX_STEPS; ++i) {\n\n        if (res < 0.0 || t > d)\n            break;\n    \n        float h = Object(p+t*l).v;\n\n        res = min(res, r * h / t);\n        t += h;    \n    }    \n\n    return clamp(res, 0.0, 1.0);\n}\n\n\n// Shading and lighting ---------------------------------------------------------------------------\n\n\nMaterial MixMaterial(Material a, Material b, float t) {\n\n    Material mat;\n\n    mat.albedo = mix(a.albedo, b.albedo, t);\n    mat.roughness = mix(a.roughness, b.roughness, t);\n    mat.emissive = mix(a.emissive, b.emissive, t);\n    mat.metallic = mix(a.metallic, b.metallic, t);\n\n    return mat;\n}\n\n\nMaterial MatWater(in vec3 p, in vec3 n, in vec3 ro, in float v) {\n\n    Material mat;\n\n    const vec3 underwater = vec3(0.1745, 0.3537, 0.7254);\n    const vec3 deepwater = vec3(0.0135, 0.0451, 0.1294);\n    const vec3 sss_color = vec3(0.0, 0.6, 0.3) * 5.0; // vec3(0.01, 0.33, 0.55);\n\n    vec3 rd = normalize(ro - p);\n    float fac = dot(rd, n);\n\n    float sss_fact = max(0.0, acos(dot(rd, sun.direction)));\n    sss_fact = smoothstep(1.5, PI, sss_fact);\n    sss_fact = pow(sss_fact*fac, 3.0);\n\n    vec3 sss = sss_color * p.z * sss_fact * 100.0;\n    vec3 water = mix(underwater, deepwater, sat(fac));\n\n    mat.albedo = vec3(0);\n    mat.metallic = 1.0;\n    mat.roughness = 0.0;\n    mat.emissive = (water + sss*v) * sun.energy * 0.002;\n\n    return mat;\n}\n\n\nMaterial MatPlastic(vec3 p, vec3 n, in vec3 ro, in float v) {\n\n    Material mat;\n    mat.albedo = vec3(1);\n    mat.metallic = 0.0;\n    mat.roughness = 0.2;\n    return mat;\n}\n\n\nMaterial MatBlackPlastic(vec3 p, vec3 n, in vec3 ro, in float v) {\n\n    Material mat;\n    mat.albedo = vec3(0.01);\n    mat.metallic = 0.0;\n    mat.roughness = 0.7;\n    return mat;\n}\n\n\nMaterial MatBeacon(vec3 p, vec3 n, in vec3 ro, in float v) {\n\n    vec3 flare_pos = vec3(0,0,1.6);\n    flare_pos = (inverse(buoy_trans) * vec4(flare_pos, 1.0)).xyz;\n\n    vec3 rd = normalize(p-ro);\n    float flare_fact = acos(dot(normalize(flare_pos-ro), rd));\n    flare_fact = smoothstep(0.038,0.0, flare_fact) * 20.0;\n    flare_fact *= mod(ceil(iTime*0.5), 2.0);\n    Material mat;\n    mat.albedo = vec3(1,0.3,0);\n    mat.metallic = 0.0;\n    mat.roughness = 0.5;\n    mat.emissive = vec3(1,0,0)*flare_fact;\n    return mat;\n}\n\n\nMaterial MatMetal(vec3 p, vec3 n, in vec3 ro, in float v) {\n\n    Material mat;\n    mat.albedo = vec3(1.0);\n    mat.metallic = 1.0;\n    mat.roughness = 0.3;\n    return mat;\n}\n\n\nMaterial MatBuoy(vec3 p, vec3 n, in vec3 ro, in float v) {\n\n    Material mat;\n    \n    float var = Fbm(p*8.0, 3)*0.5 + 0.2;\n    DEBUG(vec3(var))\n    mat.albedo = vec3(1,1,0);\n    mat.metallic = 0.0;\n    mat.roughness = var;\n    return mat;\n}\n\n\n// Compute texture \n// p : Point\n// ro : Ray origin\n// v : visibility\n// n : Normal\nMaterial ComputeMaterial(vec3 p, vec3 n, int matID, vec3 ro, float v)\n{\n    switch (matID) {\n        case MATERIAL_WATER: return MatWater(p, n, ro, v);\n        case MATERIAL_BUOY: return MatBuoy(p, n, ro, v);\n        case MATERIAL_BEACON: return MatBeacon(p, n, ro, v);\n        case MATERIAL_METAL: return MatMetal(p, n, ro, v);\n        case MATERIAL_BLACK_PLASTIC: return MatBlackPlastic(p, n, ro, v);\n        case MATERIAL_PLASTIC:\n        default: return MatPlastic(p, n, ro, v);\n    }\n}\n\n// Sky --------------------------------------------------------------------------------\n\n// Atmospheric scattering based on preetham's analytical model\n// https://github.com/vorg/pragmatic-pbr/blob/master/local_modules/glsl-sky/index.glsl\n\n\nconst float turbidity = 10.0;\nconst float reileighCoefficient = 2.0;\nconst float mieCoefficient = 0.005;\nconst float mieDirectionalG = 0.65;\n\n// constants for atmospheric scattering\n\nconst float n = 1.0003; // refractive index of air\nconst float N = 2.545E25; // number of molecules per unit volume for air at\n// 288.15K and 1013mb (sea level -45 celsius)\nconst float pn = 0.035; // depolatization factor for standard air\n\n// wavelength of used primaries, according to preetham\nconst vec3 lambda = vec3(680E-9, 550E-9, 450E-9);\n\n// mie stuff\n// K coefficient for the primaries\nconst vec3 K2 = vec3(0.686, 0.678, 0.666);\nconst float V = 4.0;\n\n// optical length at zenith for molecules\nconst float rayleighZenithLength = 8.4E3;\nconst float mieZenithLength = 1.25E3;\nconst vec3 up = vec3(0.0, 0.0, 1.0);\n\nconst float EE = 1000.0;\nconst float AngularDiameterCos = 0.999956676946448443553574619906976478926848692873900859324;\n// 66 arc seconds -> degrees, and the cosine of that\n\n// earth shadow hack\nconst float cutoffAngle = PI/1.95;\nconst float steepness = 1.5;\n\n\nvec3 totalRayleigh(vec3 lambda)\n{\n    return (8.0 * pow(PI, 3.0) * pow(pow(n, 2.0) - 1.0, 2.0) * (6.0 + 3.0 * pn)) / (3.0 * N * pow(lambda, vec3(4.0)) * (6.0 - 7.0 * pn));\n}\n\nfloat rayleighPhase(float cosTheta)\n{\n    return (3.0 / (16.0*PI)) * (1.0 + pow(cosTheta, 2.0));\n    // return (1.0 / (3.0*PI)) * (1.0 + pow(cosTheta, 2.0));\n    // return (3.0 / 4.0) * (1.0 + pow(cosTheta, 2.0));\n}\n\nvec3 totalMie(vec3 lambda, vec3 K, float T)\n{\n    float c = (0.2 * T ) * 10E-18;\n    return 0.434 * c * PI * pow((2.0 * PI) / lambda, vec3(V - 2.0)) * K;\n}\n\nfloat hgPhase(float cosTheta, float g)\n{\n    return (1.0 / (4.0*PI)) * ((1.0 - pow(g, 2.0)) / pow(1.0 - 2.0*g*cosTheta + pow(g, 2.0), 1.5));\n}\n\nfloat sunIntensity(float zenithAngleCos)\n{\n    return max(0.0, 1.0 - exp(-((cutoffAngle - acos(zenithAngleCos))/steepness)));\n}\n\n\n\nvoid AtmosphericScattering(DirectionalLight light, vec3 worldNormal, \n    out float cosTheta, out vec3 Lin, out vec3 Fex) \n{\n\n    vec3 lightDirection = light.direction;\n    float lightEnergy = light.energy;\n\n    float sunfade = 1.0-clamp(1.0- exp(light.direction.z / 450000.0) ,0.0,1.0);\n\n    float reileigh = reileighCoefficient - (1.0-sunfade);\n\n    // extinction (absorbtion + out scattering)\n    // rayleigh coefficients\n    vec3 betaR = totalRayleigh(lambda) * reileigh;\n\n    // mie coefficients\n    vec3 betaM = totalMie(lambda, K2, turbidity) * mieCoefficient;\n\n    // optical length\n    // cutoff angle at 90 to avoid singularity in next formula.\n    //float zenithAngle = acos(max(0.0, dot(up, normalize(vWorldPosition - cameraPos))));\n    float zenithAngle = acos(max(0.0, dot(up, worldNormal)));\n    float sR = rayleighZenithLength / (cos(zenithAngle) + 0.15 * pow(93.885 - ((zenithAngle * 180.0) / PI), -1.253));\n    float sM = mieZenithLength / (cos(zenithAngle) + 0.15 * pow(93.885 - ((zenithAngle * 180.0) / PI), -1.253));\n\n\n    // combined extinction factor\n    Fex = exp(-(betaR * sR + betaM * sM));\n\n    // in scattering\n    cosTheta = dot(worldNormal, lightDirection);\n\n    float rPhase = rayleighPhase(cosTheta*0.5+0.5);\n    vec3 betaRTheta = betaR * rPhase;\n\n    float mPhase = hgPhase(cosTheta, mieDirectionalG);\n    vec3 betaMTheta = betaM * mPhase;\n\n\n    Lin = pow(lightEnergy * ((betaRTheta + betaMTheta) / (betaR + betaM)) * (1.0 - Fex),vec3(1.5));\n    Lin *= mix(vec3(1.0),pow(lightEnergy * ((betaRTheta + betaMTheta) / (betaR + betaM)) * Fex,vec3(1.0/2.0)),clamp(pow(1.0-dot(up, lightDirection),5.0),0.0,1.0));\n}\n\n\nvec3 AtmosphericScattering(DirectionalLight sun, vec3 viewDir) {\n\n    float cosTheta;\n    vec3 Lin;\n    vec3 Fex;\n\n    AtmosphericScattering(sun, viewDir, cosTheta, Lin, Fex);\n\n    vec3 texColor = Lin*0.04;\n    texColor += vec3(0.0,0.001,0.0025)*0.3;\n\n    return texColor;\n}\n\n\n// Get sky color\nvec3 Sky(DirectionalLight sun, vec3 viewDir) {\n\n    float CosTheta;\n    vec3 Lin;\n    vec3 Fex;\n\n    AtmosphericScattering(sun, viewDir, CosTheta, Lin, Fex);\n\n    float sundisk = smoothstep(AngularDiameterCos,AngularDiameterCos+0.00002,CosTheta);\n    vec3 L0 = sun.energy * 19000.0 * sundisk * Fex;\n\n    vec3 texColor = (Lin + L0) * 0.04;\n    texColor += vec3(0.0,0.001,0.0025)*0.3;\n\n    return texColor;\n}\n\n\nvec3 SkyExtinxion(DirectionalLight light) \n{\n\n    float sunfade = 1.0-clamp(1.0-exp(light.direction.z),0.0,1.0);\n\n    float reileigh = reileighCoefficient - (1.0-sunfade);\n\n    // rayleigh coefficients\n    vec3 betaR = totalRayleigh(lambda) * reileigh;\n\n    // mie coefficients\n    vec3 betaM = totalMie(lambda, K2, turbidity) * mieCoefficient;\n\n    // sun optical length\n    float zenithAngle = acos(max(0.0, dot(up, light.direction)));\n    float sR = rayleighZenithLength / (cos(zenithAngle) + 0.15 * pow(93.885 - ((zenithAngle * 180.0) / PI), -1.253));\n    float sM = mieZenithLength / (cos(zenithAngle) + 0.15 * pow(93.885 - ((zenithAngle * 180.0) / PI), -1.253));\n\n    // combined extinction factor\n    return exp(-(betaR * sR + betaM * sM));\n}\n\n\n\nvec3 Env(vec3 view, DirectionalLight sun) {\n\n    float cosTheta;\n    vec3 Lin;\n    vec3 Fex;\n\n    AtmosphericScattering(sun, view, cosTheta, Lin, Fex);\n\n    vec3 L0 = Fex * 0.1;\n\n    vec3 texColor = (Lin+L0) * 0.04;\n    texColor += vec3(0.0,0.001,0.0025)*0.3;\n\n\n    return texColor;\n}\n\n// PBR -------------------------------------------------------------------------\n\n//https://gist.github.com/galek/53557375251e1a942dfa\n\n// Get sky ambient color\n// sunDirection : Sun direction\n// worldNormal : Ray direction\nvec3 SkyAmbient(DirectionalLight sun) {\n\n    return Env(normalize(sun.direction*1.8 + vec3(0,0,1)), sun);\n}\n\n\n// phong (lambertian) diffuse term\nfloat phong_diffuse()\n{\n    return (1.0 / PI);\n}\n\n\n// compute fresnel specular factor for given base specular and product\n// product could be NdV or VdH depending on used technique\nvec3 fresnel_factor(in vec3 f0, in float product)\n{\n    return mix(f0, vec3(1.0), pow(1.01 - product, 5.0));\n}\n\n\n// following functions are copies of UE4\n// for computing cook-torrance specular lighting terms\n\nfloat D_blinn(in float roughness, in float NdH)\n{\n    float m = roughness * roughness;\n    float m2 = m * m;\n    float n = 2.0 / m2 - 2.0;\n    return (n + 2.0) / (2.0 * PI) * pow(NdH, n);\n}\n\nfloat D_beckmann(in float roughness, in float NdH)\n{\n    float m = roughness * roughness;\n    float m2 = m * m;\n    float NdH2 = NdH * NdH;\n    return exp((NdH2 - 1.0) / (m2 * NdH2)) / (PI * m2 * NdH2 * NdH2);\n}\n\nfloat D_GGX(in float roughness, in float NdH)\n{\n    float m = roughness * roughness;\n    float m2 = m * m;\n    float d = (NdH * m2 - NdH) * NdH + 1.0;\n    return m2 / (PI * d * d);\n}\n\nfloat G_schlick(in float roughness, in float NdV, in float NdL)\n{\n    float k = roughness * roughness * 0.5;\n    float V = NdV * (1.0 - k) + k;\n    float L = NdL * (1.0 - k) + k;\n    return 0.25 / (V * L);\n}\n\n\n// cook-torrance specular calculation                      \nvec3 cooktorrance_specular(in float NdL, in float NdV, in float NdH, in vec3 specular, in float roughness)\n{\n#if SPECULAR_MODE == SPECULAR_BLINN\n    float D = D_blinn(roughness, NdH);\n#elif SPECULAR_MODE == SPECULAR_BECKMANN\n    float D = D_beckmann(roughness, NdH);\n#elif SPECULAR_MODE == SPECULAR_GGX\n    float D = D_GGX(roughness, NdH);\n#endif\n\n    float G = G_schlick(roughness, NdV, NdL);\n\n    float rim = mix(1.0 - roughness * 0.9, 1.0, NdV);\n\n    return max((1.0 / rim) * specular * G * D, 0.0);\n}\n\n\n// Picture in picture ------------------------------------------------------------------------------\n\n// Shading according to the number of steps in sphere tracing\n// n : Number of steps\nvec3 ShadeSteps(int n)\n{\n   float t=float(n)/(float(MAX_STEPS-1));\n   return 0.5+mix(vec3(0.05,0.05,0.5),vec3(0.65,0.39,0.65),t);\n}\n\n// Picture in picture\n// pixel : Pixel\n// pip : Boolean, true if pixel was in sub-picture zone\nvec2 Pip(in vec2 pixel, out bool pip)\n{\n    // Pixel coordinates\n    vec2 p = (-iResolution.xy + 2.0*pixel)/iResolution.y;\n   if (pip==true)\n   {    \n    const float fraction=1.0/4.0;\n    // Recompute pixel coordinates in sub-picture\n    if ((pixel.x<iResolution.x*fraction) && (pixel.y<iResolution.y*fraction))\n    {\n        p=(-iResolution.xy*fraction + 2.0*pixel)/(iResolution.y*fraction);\n        pip=true;\n    }\n       else\n       {\n           pip=false;\n       }\n   }\n   return p;\n}\n\n// Background color\nvec3 background(vec3 r, DirectionalLight sun)\n{\n    return Sky(sun, r);\n    // return mix(vec3(0.452,0.551,0.995),vec3(0.652,0.697,0.995), d.z*0.5+0.5);\n}\n\n\n// Tone mappin -------------------------------------------------------------------\n\n// based on https://www.shadertoy.com/view/ldcSRN\n\nconst float W =11.2; // white scale\n\n// filmic (John Hable)\n\n\nconst float A = 0.22; // shoulder strength\nconst float B = 0.3; // linear strength\nconst float C = 0.1; // linear angle\nconst float D = 0.20; // toe strength\nconst float E = 0.01; // toe numerator\nconst float F = 0.30; // toe denominator\n\nvec3 LinearToSRGB(vec3 x) \n{\n    vec3 t = step(x,vec3(0.0031308));\n    return mix(1.055*pow(x, vec3(1./2.4)) - 0.055, 12.92*x, t);\n}\n\n\nvec3 Gamma(vec3 color, float gamma) \n{\n    return pow(color, vec3(gamma));\n}\n\n\nvec3 Uncharted2Curve(vec3 x)\n{\n    float A = 0.15;\n    float B = 0.50;\n    float C = 0.10;\n    float D = 0.20;\n    float E = 0.02;\n    float F = 0.30;\n\n    return ((x*(A*x+C*B)+D*E)/(x*(A*x+B)+D*F))-E/F;\n}\n\nvec3 Uncharted2(vec3 color)\n{\n    vec3 white_scale = Uncharted2Curve(vec3(W));\n    return Uncharted2Curve(color) / white_scale;\n}\n\n\nvec3 ReinhardCurve (vec3 x)\n{\n\treturn x / (1.0 + x);\n}\n\nvec3 Reinhard(vec3 color) \n{\n    vec3 white_scale = ReinhardCurve(vec3(W));\n    return ReinhardCurve(color) / white_scale;\n}\n\n\nvec3 FilmicReinhardCurve (vec3 x) \n{\n    const float T = 0.01;\n    vec3 q = (T + 1.0)*x*x;\n\treturn q / (q + x + T);\n}\n\n\nvec3 FilmicReinhard(vec3 color) \n{\n    vec3 white_scale = FilmicReinhardCurve(vec3(W));\n    return FilmicReinhardCurve(color) / white_scale;\n}\n\n\nvec3 FilmicCurve(vec3 x)\n{\n\treturn ((x*(0.22*x+0.1*0.3)+0.2*0.01)/(x*(0.22*x+0.3)+0.2*0.3))-0.01/0.3;\n}\n\nvec3 Filmic(vec3 color)\n{\n    vec3 white_scale = FilmicCurve(vec3(W));\n    return FilmicCurve(color) / white_scale;\n}\n\n\nvec3 ACESFitted(vec3 color) {\n\n    color = pow(color, vec3(0.833));\n    color *= 1.07;\n\n    const mat3 ACESInput = mat3(\n        0.59719, 0.35458, 0.04823,\n        0.07600, 0.90834, 0.01566,\n        0.02840, 0.13383, 0.83777\n    );\n\n    const mat3 ACESOutput = mat3(\n        1.60475, -0.53108, -0.07367,\n        -0.10208,  1.10813, -0.00605,\n        -0.00327, -0.07276,  1.07602\n    );\n\n\n    color = color * ACESInput;\n\n    // Apply RRT and ODT\n    vec3 a = color * (color + 0.0245786) - 0.000090537;\n    vec3 b = color * (0.983729 * color + 0.4329510) + 0.38081;\n    color = a/b;\n\n    return color * ACESOutput;\n}\n\n\nvec3 ToneMapping(vec3 color) {\n\n    color = color*0.2;\n\n    #if TONEMAP_MODE == TONEMAP_FILMIC\n        color = Filmic(color);\n    #elif TONEMAP_MODE == TONEMAP_REINHARD\n        color = Reinhard(color);\n    #elif TONEMAP_MODE == TONEMAP_FILMIC_REINHARD\n        color = FilmicReinhard(color);\n    #elif TONEMAP_MODE == TONEMAP_UNCHARTED2\n        color = Uncharted2(color);\n    #elif TONEMAP_MODE == TONEMAP_ACES\n        color = ACESFitted(color);\n    #endif\n\n    color = clamp(LinearToSRGB(color), 0.0, 1.0);\n\n    return color;\n}\n\n// Compute Blinn-Phong specular\n// l : Vector to light\n// n : Normal at point\n// r : View ray direction\n// k : glossyness\nfloat Specular(vec3 l, vec3 n, vec3 r, float k)\n{\n    vec3 half_dir = normalize(l + r);\n    float spec_angle = max(dot(half_dir, n), 0.0);\n    return pow(spec_angle, k);\n\n    // Phong\n//     vec3 ref = reflect(r, n);\n//     float c = max(dot(ref, r), 0.0);\n//     return pow(c, k/4.0);\n}\n\n\n// Compute lighting\n// sun : Sun data\n// mat : Material data\n// p : Point on surface\n// rd : View ray direction\n// n : Normal at Point\n// reflection : Computed reflection\n// clearcoat : Computed clearcoat reflection\n vec3 Shade(DirectionalLight sun, Material mat, vec3 p, vec3 rd, vec3 n, \n    vec3 reflection, float v) \n{\n\n    // Ambient color\n    vec3 ambient = SkyAmbient(sun) * 0.7;\n\n    // Ambient occlusion\n    NO_TRACE_OCEAN(ambient *= AmbientOcclusion(p, n))\n\n    // vec3 diffuse = ambient;\n    vec3 specular = mix(vec3(0.02), mat.albedo, mat.metallic);\n\n\n    vec3 L = sun.direction;\n    vec3 N = n;\n    vec3 V = -rd;\n    vec3 H = normalize(V+L);\n\n    float NdL = max(0.001, dot(N, L));\n    float NdV = max(0.001, dot(N, V));\n    float NdH = max(0.001, dot(N, H));\n    float HdV = max(0.001, dot(H, V));\n\n\n    // specular reflectance with COOK-TORRANCE\n    vec3 specfresnel = fresnel_factor(specular, HdV);\n    vec3 specref = cooktorrance_specular(NdL, NdV, NdH, specfresnel, mat.roughness);\n\n    specref *= vec3(NdL) * 10.0;\n\n    // diffuse is common for any model\n    vec3 diffref = (vec3(1.0) - specfresnel) * phong_diffuse() * NdL;\n    \n    // compute lighting\n    vec3 reflected_light = vec3(0);\n    vec3 diffuse_light = vec3(0);\n\n    // point light\n    vec3 light_color = sun.color * sun.energy * 0.01;\n    reflected_light += specref * light_color * v;\n    diffuse_light += diffref * light_color * v;\n\n    reflected_light += min(vec3(0.99), fresnel_factor(specular, NdV)) * reflection;\n\n    diffuse_light += ambient * (1.0 / PI);\n\n    // final result\n    vec3 result = diffuse_light * mix(mat.albedo, vec3(0.0), mat.metallic);\n    result += reflected_light;\n    result += mat.emissive;\n\n    return result;\n}\n\n\n// Sample color from ray\n// sun : Sun light\n// ro : Ray origin\n// rd : Ray direction\n// steps : Number of trace steps\nvec3 Render(DirectionalLight sun, vec3 ro, vec3 rd, out int steps) {\n\n    // Hit and number of steps\n    bool hit;\n    int s;\n    \n    // primary ray\n    CATCH_DEBUG(float t = SphereTrace(ro, rd, 1000.0, hit, s));\n    steps += s;\n\n    if (!hit && rd.z > 0.0)\n        return background(rd, sun);\n    \n    vec3 pt, n;\n    int matID = 0;\n    Material mat;\n    float h;\n    \n    if (!hit && rd.z < 0.0) {\n        t = DistToPlane(ro, rd, WATER_LEVEL);\n        matID = MATERIAL_WATER;\n    }\n    \n    pt = ro + t * rd;\n    n = ComputeNormal(pt, matID);\n    \n    NO_TRACE_OCEAN(float v = Shadow(pt+n*0.001, sun.direction, \n                                    sun.shadow_dist, 20.0))\n\n    CATCH_DEBUG(mat = ComputeMaterial(pt, n, matID, ro, v));\n\n    vec3 reflect_dir = reflect(rd, n);\n    vec3 reflection = vec3(0);\n\n    // reflection\n    if (mat.roughness == 0.0) {\n\n        // secondary ray\n        vec3 start = pt+n*0.01;\n        bool hit;\n        NO_TRACE_OCEAN(float t = SphereTrace(start, reflect_dir, 1000.0, hit, s))\n        steps += s;\n\n        if (hit) {\n            vec3 rpt = pt + t * reflect_dir;\n            \n            int matID;\n            vec3 rn = ComputeNormal(rpt, matID);\n\n            Material rmat = ComputeMaterial(rpt, rn, matID, pt, 1.0);\n\n            vec3 sec_reflection = Env(reflect(reflect_dir, rn), sun);\n            \n            reflection = Shade(sun, rmat, rpt, reflect_dir, \n                                rn, sec_reflection, 1.0);\n        }\n        else\n            reflection = Env(reflect_dir, sun);\n    }\n    else if (hit) {\n        float r = 1.0/max(mat.roughness, 0.00001);\n        NO_TRACE_OCEAN(float v = Shadow(pt+n*0.01, reflect_dir, 1000.0, r));\n        reflection = mix(SkyAmbient(sun)*0.01, Env(reflect_dir, sun), v);\n    } else \n        reflection = Env(reflect_dir, sun);\n\n\n    vec3 color = Shade(sun, mat, pt, rd, n, reflection, v);\n\n    color = mix(color, Env(rd, sun), sat(t*t*0.0002));\n\n    return color;\n}\n\n\nvec2 RayDirection(in vec2 pixel, inout bool pip)\n{\n    // Pixel coordinates\n    vec2 p = (-iResolution.xy + 2.0*pixel)/iResolution.y;\n   if (pip==true)\n   {\n    const float fraction=1.0/4.0;\n    // Picture in picture\n    if ((pixel.x<iResolution.x*fraction) && (pixel.y<iResolution.y*fraction))\n    {\n        p=(-iResolution.xy*fraction + 2.0*pixel)/(iResolution.y*fraction);\n        pip=true;\n    }\n       else\n       {\n           pip=false;\n       }\n   }\n   return p;\n}\n\n\n// Image\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Picture in picture on\n    bool pip=false;\n\n    // Mouse\n    vec2 m=iMouse.xy/iResolution.xy;\n\n    // Camera\n    vec3 ro;\n    mat3 cam = Camera(m, ro);\n\n    vec2 p = RayDirection(fragCoord, pip);\n   \n    // Camera ray    \n    vec3 rd = cam * normalize(vec3(p,1.0));\n\n\n    // Shade background\n    sun.direction = normalize(vec3(0.2, -0.5, 0.1));\n    sun.color = SkyExtinxion(sun)* 19.0;\n    sun.energy = sunIntensity(sun.direction.z) * EE;\n    sun.shadow_dist = 100.0;\n\n    \n    // compute buoy transform\n    float h;\n    vec3 buoy_nor = OceanNormal(vec2(0), 4, h);\n    buoy_nor.xy *= -0.2;\n\n    buoy_nor = normalize(buoy_nor);\n\n    vec3 buoy_tan = cross(buoy_nor, vec3(1,0,0));\n    vec3 buoy_bit = cross(buoy_tan, buoy_nor);\n\n    buoy_trans = mat4(mat3(buoy_bit, buoy_tan, buoy_nor));\n    buoy_trans[3].z = h * -0.4 + 0.1;\n\n    int s;\n\n    vec3 rgb = Render(sun, ro, rd, s);\n\n    rgb = ToneMapping(rgb);\n\n    // Uncomment this line to shade image with false colors representing the number of steps\n    if (pip==true)\n        rgb = ShadeSteps(s); \n\n\n#if _DEBUG\n    rgb = _debug_color;\n#endif\n    fragColor = vec4(rgb, 1.0);\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/NdfXW4.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "NdfXW7", "name": "noise balanced isolines - interp", "author": "FabriceNeyret2", "description": "TAB for debug display.\nBottom: noise isovalues are not equidistant.\n[url]https://shadertoy.com/view/fsfXWM[/url] shows drawing iso-distances from isoval0 (debug:green) or peaks (debug:red), with dual discontinuities.\n→ Here, solved with smart interpolatio", "tags": ["procedural", "noise", "perlin"], "likes": 7, "viewed": 255, "date": "1618738171", "time_retrieved": "2024-06-20T20:37:46.652819", "image_code": "// Fork of \"test4: noise balanced isolines\" https://shadertoy.com/view/fsfXWM\n// Fork of \"test3: Curl noise balance\"      https://shadertoy.com/view/NssXD4\n// Fork of \"test1: Noise balance\"           https://shadertoy.com/view/ssXXWN\n\n\n#define keyToggle(a) ( texelFetch(iChannel3,ivec2(a,2),0).x > 0.)\n#define hash(p )     ( 2.* fract(sin((p)*mat2(127.1,311.7, 269.5,183.3)) *43758.5453123) - 1. )\n#define draw(v,d)      clamp(1. - abs( fract(v) - .5 ) / fwidth(d), 0.,1.)\n//#define Ierf(x)    ( atanh(x) / 1.2 )          // not so bad reciprocal of erf\n\n#define func( P )    ( keyToggle(32) ? perlin( P ) : noise( P ) )\n#define grad(x,y)      dot( hash( i+vec2(x,y) ), f-vec2(x,y) )\n\nfloat noise( vec2 p )\n{\n    vec2 i = floor(p), f = fract(p), // u = f*f*(3.-2.*f);              // = smoothstep\n                                        u = f*f*f*( 10. +f*(6.*f-15.)); // better with derivatives\n    return mix( mix( grad(0,0), grad(1,0), u.x),\n                mix( grad(0,1), grad(1,1), u.x), u.y);\n}\n\nfloat perlin( vec2 U ) { // inspired from https://www.shadertoy.com/view/XdXGW8\n    float v = 0., s = .5;\n    mat2 m = mat2( 1.6,  1.2, -1.2,  1.6 );\n    for( int i=0; i<3; i++, s/=2., U*=m )\n        v  += s * noise( U ); \n    return v;\n}\n\nvoid mainImage( out vec4 O, vec2 u )\n{\n    vec2 R = iResolution.xy, eps = vec2(1e-3,0),\n         U = u / R.y,\n         P = 8.*U - vec2(0.,.5*iTime), P0=P;\t\n    O-=O;\n\tfloat l0, l = 0., f = func(P);\n    if ( int(u.y) == int(R.y*.4) ) { O.r++; return; } // red separator\n    if( U.y > .4) {\n        float s = .1;                           // steps size\n                        // --- descent to isoline-0\n        for (int i=0; i < 30; i++ ){\n            vec2 G =  ( f - vec2( func(P-eps.xy), func(P-eps.yx) )) /eps.x; // gradient\n         // vec2 G = vec2( dFdx(f), dFdy(f) ) * R.y/8.;\n            P -= s* f * G/dot(G,G);             // descent\n            l += s* f / length(G);              // optional: cumul curved lenght\n            f = func( P ); \n         // if ( length(G) < .2 ) return;       // trying to cull crests and valleys\n            if (abs(f) < 1e-3) break;           // isovalue 0 reached\n        }\n     // l = length(P-P0);                       // optional: use straight distance instead of curved (ok for descent )\n        \n        l0 = l; l = 0.; P = P0; f = func(P); \n      //s = .1;                                        // --- ascent to peak\n        for (int i=0; i < 300; i++ ){\n            vec2 G =  ( f - vec2( func(P-eps.xy), func(P-eps.yx) )) /eps.x; // gradient\n         // vec2 G = vec2( dFdx(f), dFdy(f) ) * R.y/8.;\n#if 0                                           // ... all from positive pole\n            P += s* G;                          // ascent\n            l += s* length(G);                  // optional: cumul curved lenght\n#else                                           // ... from both poles\n            P += s* sign(f)*  G;                // ascent\n            l += s* sign(f)* length(G);         // optional: cumul curved lenght\n#endif\n            f = func( P ); \n            if ( length(G) < 1e-2 ) break;      // creast or valley reached\n        }\n     // l = length(P-P0);                       // optional: use straight distance instead of curved (ok for descent )\n\n     // --- l0 = dist to iso0, l = dist to peak\n        if( keyToggle(9) ) {\n            O.g += draw(8.*l0,8.*l0)*U.x;\n            O.b += float(abs(l0)<.01);\n            O.r += draw(8.*l ,8.*l )*2.*U.x;\n         // return;\n        }\n        if ( max(fwidth(l0),fwidth(l)) > 50.*fwidth(U.x) ) return; // trim artifacts\n        \n     // if (false) { l = fract(f=8.*l), l0=fract(8.*l0), \n     //             l = fract(l-l0+.5) +l0-.5; l = mix(l0,l,l0/(l0+l));  // wrong slider: l changed\n     //             O += abs(fract(l)-.5)*2.; sin(6.28*l); return; }\n        if (true) { float v1 = 1.-fract(f=8.*l), v0 = fract(8.*l0);\n                    v1 = fract(v1-v0+.5) +v0-.5; l = mix(v0,v1,abs(l0)/(abs(l0)+abs(l)));  \n                 // O += abs(fract(l)-.5)*2.; sin(6.28*l); \n                    O += draw(l,f); return; }\n     // l = (l0-l)/2.;\n\n        f = l;\n    }\n/*  else {\n        O = vec4(.5+f);                                           // draw noise\n        O.b += clamp(.5-.5*abs(f)/fwidth(f), 0.,1.); \n        return;\n    }\n*/\n\n // O = vec4(.5+.5*sin(50.*l));\n    f = 8.*f; O += draw(f,f); // draw isolines\n    O = sqrt(O);                                                  // to sRGB\n\n}", "image_inputs": [{"id": "4dXGRr", "previewfilepath": "/presets/tex00.jpg", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/presets/tex00.jpg", "ctype": "keyboard"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/NdfXW7.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "Ndj3Dc", "name": "Fractal 54_gaz", "author": "gaz", "description": "fractal", "tags": ["fractal"], "likes": 7, "viewed": 210, "date": "1618054750", "time_retrieved": "2024-06-20T20:37:46.652819", "image_code": "#define PI (atan(1.)*4.)\n#define H(h)(cos((h)*6.3+vec3(0,23,21))*.5+.5)\nvoid mainImage(out vec4 O, vec2 C)\n{\n    O=vec4(0);\n    vec3 p,r=iResolution,\n    d=normalize(vec3((C-.5*r.xy)/r.y,1));  \n    for(float i=0.,s,e,g=0.;\n        ++i<90.;\n        O.xyz+=mix(vec3(1),H(log(s)*.3),.6)*.03*exp(-.3*i*i*e)\n    )\n    {\n        p=g*d+vec3(-.5,0,iTime*.5);\n        p=sin(p);\n        s=2.;\n        for(int i=0;i++<5;)\n            p=abs(p-1.7)-1.3,\n            s*=e=2./min(dot(p,p),1.5),\n            p=abs(p)*e;\n        g+=e=length(p.zy)/s;\n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/Ndj3Dc.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "Ndj3DK", "name": "Mandelbulb Sphere", "author": "kithy", "description": "mandelbulb,fractal,mandelbrot set,raymarching", "tags": ["raymarching", "fractal", "mandelbulb", "mandelbrotset"], "likes": 4, "viewed": 77, "date": "1617979146", "time_retrieved": "2024-06-20T20:37:46.652819", "image_code": "#define EPS 0.001\n#define POWER 8.0\n#define ITR 15\n#define MAX_DIST 64\n#define fov radians(35.0)\n\nfloat mandelbulb(vec3 p){\n\tfloat power=1.0+(POWER-1.0)*(0.5-cos(iTime)*0.5);\n\tvec3 z=p;\n\tfloat dr=1.0;\n\tfloat r=0.0;\n\tfor(int i=0;i<ITR;i++){\n\t\tr=length(z);\n\t\tif(r>3.0)break;\n\n\t\t\n\t\tfloat theta=acos(z.z/r);\n\t\tfloat phi=atan(z.y,z.x);\n\n\t\tdr=pow(r,power-1.0)*power*dr+1.0;\n\n\t\t\n\t\tfloat zr=pow(r,power);\n\t\ttheta*=power;\n\t\tphi*=power;\n\n\t\t\n\t\tz=zr*vec3(sin(theta)*cos(phi),sin(phi)*sin(theta),cos(theta));\n\t\tz+=p;\n\t}\n\treturn 0.5*log(r)*r/dr;\n}\n\nfloat mainDist(vec3 p){\n\treturn mandelbulb(p);\n}\n\nvec3 rayMarch(const vec3 eye,const vec3 ray,out float depth,out float steps){\n\tdepth=0.0;\n\tsteps=0.0;\n\tfloat dist;\n\tvec3 rp;\n\n\t\n\tfor(int i=0;i<MAX_DIST;i++){\n\t\trp = eye + depth*ray;\n\t\tdist = mainDist(rp);\n\t\tdepth += dist;\n\t\tsteps++;\n\t\tif(dist<EPS)break;\n\t}\n\n\t\n\treturn rp;\n}\n\nvec3 genNormal(vec3 p){\n\treturn normalize(vec3(\n\t\tmainDist(vec3(p.x+EPS,p.y,p.z))-mainDist(vec3(p.x-EPS,p.y,p.z)),\n\t\tmainDist(vec3(p.x,p.y+EPS,p.z))-mainDist(vec3(p.x,p.y-EPS,p.z)),\n\t\tmainDist(vec3(p.x,p.y,p.z+EPS))-mainDist(vec3(p.x,p.y,p.z-EPS))\n\t));\n}\n\nfloat color(float val,float offset,float level){\n\treturn clamp((val-level)*(1.0+offset)+level,0.0,1.0);\n}\n\nvoid mainImage(out vec4 fragColor,in vec2 fragCoord){\n\tvec2 uv=(2.0*fragCoord.xy-iResolution.xy)/iResolution.y;\n\n\t\n\tvec3 ray=normalize(vec3(uv*tan(fov),1.0));\n\tfloat angle=radians(360.0)*iTime;\n\n\tvec3 camPos=vec3(0.0,0.0,-2.2);\n\t\n\tfloat depth=0.0;\n\tfloat steps=0.0;\n\tvec3 rp=rayMarch(camPos+EPS*ray,ray,depth,steps);\n\n\t\n\tfloat ao=steps*0.01;\n\tao=1.0-ao/(ao+0.5);\n\n\tfloat offset=0.3;\n\tfloat level=0.5;\n\tao=color(ao,offset,level);\n\tvec3 normal=genNormal(rp);\n\tvec3 fColor=ao*(normal*0.5+0.5);\n\tfragColor=vec4(fColor,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/Ndj3DK.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "Ndj3WD", "name": "Meta Boze 2.0", "author": "kaiware007", "description": "Happy Anniversary Meta Boze", "tags": ["raymarching", "boze"], "likes": 4, "viewed": 82, "date": "1617458868", "time_retrieved": "2024-06-20T20:37:46.658434", "image_code": "// ------------------------------------------------------------------------------------\n// Original Character By MikkaBouzu : https://twitter.com/mikkabouzu777\n// ------------------------------------------------------------------------------------\n\n#define saturate(x) clamp(x, 0.0, 1.0)\n#define MAX_MARCH 200\n#define MAX_DIST 100.\n\nconst float EPS = 1e-3;\nconst float EPS_N = 1e-4;\nconst float OFFSET = EPS * 10.0;\n\n#define M_PI 3.1415926\n#define M_PI2 M_PI*2.0\n#define RAD90 (M_PI * 0.5)\n\nstruct surface {\n\tfloat dist;\n    vec4 albedo;\n    float specular;\n    int count;\n    bool isHit;\n};\n\n// Surface Data Define\n#define SURF_NOHIT(d)   (surface(d, vec4(0), \t\t \t0.0, 0, false))\n#define SURF_BLACK(d) \t(surface(d, vec4(0,0,0,1),   \t0.001, 0, true))\n#define SURF_FACE(d) \t(surface(d, vec4(1,0.7,0.6,1), \t0.00001, 0, true))\n#define SURF_MOUSE(d) \t(surface(d, vec4(1,0,0.1,1),   \t0.0, 0, true))\n#define SURF_CHEEP(d) \t(surface(d, vec4(1,0.3,0.4,1), \t0.02, 0, true))\n#define SURF_SPHERE(d) \t(surface(d, vec4(0.1,0.1,0.1,1),0.9, 0, true))\n    \n#define AA 1\n\n#define M_PI03 1.04719\n#define M_PI06 2.09439\nvec3 sinebow(float h) {\n    vec3 r = sin((.5-h)*M_PI + vec3(0,M_PI03,M_PI06));\n    return r*r;\n}\n\n// easing function\nfloat QuadraticEaseOut(float p)\n{\n\treturn -(p * (p - 2.));\n}\n\nfloat QuadraticEaseInOut(float p)\n{\n\tif(p < 0.5)\n\t{\n\t\treturn 2. * p * p;\n\t}\n\telse\n\t{\n\t\treturn (-2. * p * p) + (4. * p) - 1.;\n\t}\n}\n\nfloat CubicEaseIn(float p)\n{\n\treturn p * p * p;\n}\n\nfloat CubicEaseInOut(float p)\n{\n\tif(p < 0.5)\n\t{\n\t\treturn 4. * p * p * p;\n\t}\n\telse\n\t{\n\t\tfloat f = ((2. * p) - 2.);\n\t\treturn 0.5 * f * f * f + 1.;\n\t}\n}\n\nfloat QuarticEaseOut(float p)\n{\n\tfloat f = (p - 1.);\n\treturn f * f * f * (1. - p) + 1.;\n}\n\nfloat BackEaseIn(float p)\n{\n\treturn p * p * p - p * sin(p * M_PI);\n}\n\n// random\n//float rand3d(vec3 st)\n//{\n//    return fract(sin(dot(st.xyz, vec3(12.9898, 78.233, 56.787))) * 10000.0);\n//}\n//  1 out, 3 in...\nfloat hash13(vec3 p3)\n{\n\tp3  = fract(p3 * .1031);\n    p3 += dot(p3, p3.zyx + 31.32);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nfloat noise(vec3 st)\n{\n\tvec3 ip = floor(st);\n    vec3 fp = smoothstep(vec3(0.), vec3(1.), fract(st));\n    \n\tvec4 a = vec4(hash13(ip+vec3(0.)),hash13(ip+vec3(1.,0.,0.)),hash13(ip+vec3(0.,1.,0.)),hash13(ip+vec3(1.,1.,0.)));\n    vec4 b = vec4(hash13(ip+vec3(0.,0.,1.)),hash13(ip+vec3(1.,0.,1.)),hash13(ip+vec3(0.,1.,1.)),hash13(ip+vec3(1.,1.,1.)));\n    \n\ta = mix(a, b, fp.z);\n\ta.xy = mix(a.xy, a.zw, fp.y);\n    \n\treturn mix(a.x, a.y, fp.x);\n}\n\nmat3 m = mat3( 0.00,  0.80,  0.60,\n              -0.80,  0.36, -0.48,\n              -0.60, -0.48,  0.64 );\n\nfloat fbm( vec3 p )\n{\n    float f;\n    f  = 0.5000*noise( p ); p = m*p*2.02;\n    f += 0.2500*noise( p ); p = m*p*2.03;\n    f += 0.1250*noise( p );\n    return f;\n}\n\n/////////////////////////////////////////////////////////////////////////////////////////////////\n// Basic Distance function\n/////////////////////////////////////////////////////////////////////////////////////////////////\nfloat sdRoundBox(vec3 p, vec3 size, float r)\n{\n    return length(max(abs(p) - size * 0.5, 0.0)) - r;\n}\n\nfloat sdCapsule(vec3 p, vec3 a, vec3 b, float r)\n{\n\tvec3 pa = p - a, ba = b - a;\n\tfloat h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\n\treturn length(pa - ba*h) - r;\n}\n\nfloat sdEllipsoid( vec3 p, vec3 r )\n{\n    float k0 = length(p/r);\n    float k1 = length(p/(r*r));\n    return k0*(k0-1.0)/k1;\n}\n\nfloat sdCappedTorus(in vec3 p, in vec2 sc, in float ra, in float rb)\n{\n  p.x = abs(p.x);\n  float k = (sc.y*p.x>sc.x*p.y) ? dot(p.xy,sc) : length(p.xy);\n  return sqrt( dot(p,p) + ra*ra - 2.0*ra*k ) - rb;\n}\n\nfloat sdRoundedCylinder( vec3 p, float ra, float rb, float h )\n{\n  vec2 d = vec2( length(p.xz)-2.0*ra+rb, abs(p.y) - h );\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0)) - rb;\n}\n\nvec3 rotate(vec3 p, float angle, vec3 axis)\n{\n    vec3 a = normalize(axis);\n    float s = sin(angle);\n    float c = cos(angle);\n    float r = 1.0 - c;\n    mat3 m = mat3(\n        a.x * a.x * r + c,\n        a.y * a.x * r + a.z * s,\n        a.z * a.x * r - a.y * s,\n        a.x * a.y * r - a.z * s,\n        a.y * a.y * r + c,\n        a.z * a.y * r + a.x * s,\n        a.x * a.z * r + a.y * s,\n        a.y * a.z * r - a.x * s,\n        a.z * a.z * r + c\n    );\n    return m * p;\n}\n\n// Union, Subtraction, SmoothUnion (distance, Material) \nsurface opU(surface d1, surface d2)\n{\n    if(d1.dist < d2.dist){\n        return d1;\n    } else {\n    \treturn d2;\n    }\n}\n\nfloat opU( float d1, float d2 ) {  return min(d1,d2); }\n\nsurface opS( surface d1, surface d2 )\n{\n    if(-d1.dist > d2.dist){\n        d1.dist = -d1.dist;\n    \treturn d1;\n    } else {\n    \treturn d2;\n    }\n}\n\nsurface opSU( surface d1, surface d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2.dist - d1.dist)/k, 0.0, 1.0 );\n    float d = mix( d2.dist, d1.dist, h ) - k*h*(1.0-h);\n    vec4 albedo = mix( d2.albedo, d1.albedo, h );\n    float sp = mix(d2.specular, d1.specular, h);\n    return surface(d, albedo, sp, d1.count, true);\n}\n\nfloat smin( float d1, float d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); \n}\n\nsurface opLerp(surface d1, surface d2, float t) {\n    surface d;\n    d.dist = mix(d1.dist, d2.dist, t);\n    d.albedo = mix(d1.albedo, d2.albedo, t);\n    d.specular = mix(d1.specular, d2.specular, t);\n    d.count = int(mix(float(d1.count), float(d2.count), t));\n    d.isHit = t > 0.5 ? d1.isHit : d2.isHit;\n    return d;\n}\n\n//https://www.shadertoy.com/view/NdS3Dh\n//SmoothSymmetricPolarMod aka smoothRot\n//\n//s repetitions\n//m smoothness (0-1)\n//c correction (0-1)\n//d object displace from center\n//\nvec2 smoothRot(vec2 p,float s,float m,float c,float d){\n  s*=0.5;\n  float k=length(p);\n  float x=asin(sin(atan(p.x,p.y)*s)*(1.0-m))*k;\n  float ds=k*s;\n  float y=mix(ds,2.0*ds-sqrt(x*x+ds*ds),c);\n  return vec2(x/s,y/s-d);\n}\n\n//Rotation\nvec2 rot(vec2 p,float f){\n    float s=sin(f);float c=cos(f);\n    return p*mat2(c,-s,s,c);\n}\n\nvec3 TwistY(vec3 p, float power)\n{\n    float s = sin(power * p.y);\n    float c = cos(power * p.y);\n    mat3 m = mat3(\n          c, 0.0,  -s,\n        0.0, 1.0, 0.0,\n          s, 0.0,   c\n    );\n    return m*p;\n}\n/////////////////////////////////////////////////////////////////////////////////////////////////\n// Mikka Boze Distance Function\n/////////////////////////////////////////////////////////////////////////////////////////////////\nfloat sdEar(vec3 p)\n{\n    p = rotate(p, RAD90+0.25, vec3(0,0,1));    \n    return sdCappedTorus(p + vec3(0.05, 0.175, 0), vec2(sin(0.7),cos(0.7)), 0.03, 0.01);\n}\n\n#define EYE_SPACE 0.04\n\nvec3 opBendXY(vec3 p, float k)\n{\n    float c = cos(k*p.x);\n    float s = sin(k*p.x);\n    mat2  m = mat2(c,-s,s,c);\n    return vec3(m*p.xy,p.z);\n}\n\nvec3 opBendXZ(vec3 p, float k)\n{\n    float c = cos(k*p.x);\n    float s = sin(k*p.x);\n    mat2  m = mat2(c,-s,s,c);\n    vec2 xz = m*p.xz;\n    return vec3(xz.x, p.y, xz.y);\n}\n\nfloat sdMouse(vec3 p, float ms)\n{\n    vec3 q = opBendXY(p, 2.0);\n    ms += 0.00001;\n    return sdEllipsoid(q - vec3(0,0,0.2), vec3(0.035, 0.01 * ms,0.05 * ms));\n}\n\nfloat sdCheep(vec3 p)\n{    \n    const float x = 0.05;\n    const float z = -0.175;\n    const float r = 0.0045;\n    const float rb1 = 100.;\n    \n    p = rotate(p, M_PI * -0.6 * (p.x - x), vec3(-0.2,0.8,0));\n\t\n    float d = sdCapsule(opBendXY(p + vec3(x, -0.01, z), rb1), vec3(-0.005,0.0,0.0), vec3(0.005, 0., 0.001), r);\n    float d1 = sdCapsule(opBendXY(p + vec3(x+0.01, -0.01, z), 200.0), vec3(-0.0026,0.0,0), vec3(0.0026, 0., 0), r);\n    float d2 = sdCapsule(opBendXY(p + vec3(x+0.019, -0.015, z), -rb1), vec3(-0.01,0.0,-0.01), vec3(0.0045, 0., 0.0), r);\n    \n    return opU(opU(d, d1), d2);\n}\n\nfloat sdEyeBrow(vec3 p)\n{\n    const float x = 0.05;\n    p = opBendXZ(p + vec3(0.02,0,-0.02), -6.5);\n    return sdRoundBox(p + vec3(0.005, -0.14,-0.11), vec3(0.003,0.0025,0.05), 0.001);\n}\n\nsurface sdBoze(vec3 p, vec3 sc, float ms)\n{    \n    surface result = SURF_NOHIT(1e5);\n    \n    float minsc = min(sc.x, min(sc.y, sc.z));\n    p /= sc;\n    \n    // head\n\tfloat d = sdCapsule(p, vec3(0,0.05,0), vec3(0, 0.11, 0), 0.125);\n    \n    float d1 = sdRoundedCylinder(p + vec3(0,0.025,0), 0.095, 0.05, 0.0);\n    \n    d = smin(d, d1, 0.1);\n    \n    vec3 mxp = vec3(-abs(p.x), p.yz);\n    \n    // ear\n    float d2 = sdEar(mxp);\n    d = opU(d, d2);\n\n\tsurface head = SURF_FACE(d);\n\n\t// eye\n    float d4 = sdCapsule(mxp, vec3(-EYE_SPACE, 0.06, 0.13), vec3(-EYE_SPACE, 0.08, 0.125), 0.0175);\n    surface eye = SURF_BLACK(d4);\n    \n    // mouse\n    float d6 = sdMouse(p, ms);\n    surface mouse = SURF_MOUSE(d6);\n    \n    // cheep\n    float d7 = sdCheep(mxp);\n    surface cheep = SURF_CHEEP(d7);\n    \n    // eyebrows\n    float d9 = sdEyeBrow(mxp);\n    eye.dist = opU(eye.dist, d9);\n    \n    // integration\n    mouse = opU(eye, mouse);\n    result = opS(mouse, head);\n    result = opU(cheep, result);\n    \n    result.dist *= minsc;\n    \n    return result;\n}\n/////////////////////////////////////////////////////////////////////////////////////////////////\n// End of Mikka Boze\n/////////////////////////////////////////////////////////////////////////////////////////////////\n\n// 球体\n#define SEQ_0 (1.5)\n// モーフィング坊主\n#define SEQ_1 (SEQ_0 + 0.5)\n// ねじれ坊主\n#define SEQ_2 (SEQ_1 + 3.0)\n// 分裂坊主\n#define SEQ_3 (SEQ_2 + 5.0)\n// ズームエンド\n#define SEQ_4 (SEQ_3 + 3.)\n\n#define SEQ_0_D(t) (t / SEQ_0)\n#define SEQ_1_D(t) ((t - SEQ_0) / (SEQ_1 - SEQ_0))\n#define SEQ_2_D(t) ((t - SEQ_1) / (SEQ_2 - SEQ_1))\n#define SEQ_3_D(t) ((t - SEQ_2) / (SEQ_3 - SEQ_2))\n#define SEQ_4_D(t) ((t - SEQ_3) / (SEQ_4 - SEQ_3))\n\n#define LOOP (mod(iTime, SEQ_4+0.1))\n\nint getSeq(){\n    float t = LOOP;\n    //float t = iTime;\n    \n    if(t < SEQ_0){\n    \treturn 0;\n    }else if(t < SEQ_1){\n        return 1;\n    } else if(t < SEQ_2){\n        return 2;\n    } else if(t < SEQ_3){\n        return 3;\n    }\n    //else if(t < SEQ_4){\n        return 4;\n    //} \n    \n    return 0;\n}\n\nsurface bioBoze(vec3 p, float t)\n{\n    surface result = SURF_NOHIT(1e5);\n    \n    float ms = sin(iTime*3.0) * 0.5 + 0.75;\n\n    float t2 = t * 5.32;\n    float repetitions=6.0;\n    float smoothness=0.0125;\n    float correction=0.0;\n    float displace=t*0.1;\n    \n    float s = 1.0;\n    for(int i = 0; i < 3; i++)\n    {\n        p.yz=rot(p.yz,-cos(t2*1.3+iTime*0.1)*0.378 * (1.0-t));\n        p.xy=smoothRot(p.xy,repetitions,smoothness,correction,displace);\n        p.xz=rot(p.xz,sin(-t2*0.25+RAD90)*0.362*t2);\n\n        // boze\n        surface boze = sdBoze(p, vec3(s), ms);\n        s *= 0.78;\n        p.y -= 0.5*s*t;\n        p.xz-=0.175*s*t;\n\n        result = opSU(result, boze, smoothness);\n    }\n    return result;\n}\n\nsurface map(vec3 p)\n{\n\tsurface result = SURF_NOHIT(1e5);\n \tfloat ti = LOOP;\n    int seq = getSeq();\n    if(seq == 0) {\n        vec3 bp = vec3(0, -1.75 + QuarticEaseOut(SEQ_0_D(ti)) * 1.75, 0);\n\t\t// 球体\n        result = SURF_SPHERE(sdCapsule(p + bp, vec3(0,0.0,0), vec3(0, 0., 0), 0.125));\n \t} else if(seq == 1) {\n        // モーフィング坊主\n        float t = QuadraticEaseInOut(saturate(SEQ_1_D(ti)));\n        result = SURF_SPHERE(sdCapsule(p, vec3(0,0.0,0), vec3(0, 0., 0), 0.125));\n        surface boze = sdBoze(p, vec3(1), 1.0);\n\n        result = opLerp(result, boze, t);\n        \n    } else if(seq == 2) {\n        // ねじれ坊主\n        float d = saturate(SEQ_2_D(ti));\n        float t = QuadraticEaseInOut(d);\n        p = TwistY(p, sin(d * M_PI2) * 5.);\n        float s = noise(normalize(-p)*2.0+vec3(0,ti*(t*1.5+2.0),0)) * 0.5 * t + 1.0;\n        \n        result = sdBoze(p, vec3(s), 1.0);\n    } else if(seq == 3) {        \n         // 通常のBoze\n        float s2 = noise(normalize(-p)*2.0+vec3(0,ti*3.5,0)) * 0.5 + 1.0;\n        surface b2 = sdBoze(p, vec3(s2), 1.0);\n        \n\t\tfloat t = QuarticEaseOut(SEQ_3_D(ti));\n        float t2 = t * 5.32;\n\n        // 分裂坊主と合成\t\t\n        result = opLerp(b2, bioBoze(p, t), saturate(t2));\n    } else if(seq == 4) {\n    \t// ズームエンド\n        float t = BackEaseIn(SEQ_4_D(ti));\n        float t2 = QuadraticEaseInOut(SEQ_4_D(ti));\n        p.z -= t;\n        //p.z -= t2*0.5;\n        p.y -= t2*0.2;\n        result = bioBoze(p, 1.0);\n    }\n    \n    \n    return result;\n}\n\nvec3 norm(in vec3 position) {\n    // https://www.shadertoy.com/view/XltyRf\n    vec4 n = vec4(0);\n    for (int i = 0 ; i < 4 ; i++) {\n        vec4 s = vec4(position, 0);\n        s[i] += 0.001;\n        n[i] = map(s.xyz).dist;\n    }\n    return normalize(n.xyz-n.w);\n\t\n}\n\nsurface traceRay(in vec3 origin, in vec3 direction, float dist, out vec3 pos) {\n    float t = 0.0;\n    \n    pos = origin;\n\n    int count = 0;\n    surface hit;\n    float d;\n    \n    for (int i = 0; i < MAX_MARCH; i++) {\n        hit = map(pos);\n        d = hit.dist * 0.5;\n        \n        if (d <= EPS || d >= MAX_DIST) {\n        \tbreak;\n        }\n\n        t += d;\n        pos = origin + direction * t;\n        count++;        \n    }\n\n    hit.dist = t;\n\thit.count = count;\n\n    pos = origin + direction * t;\n    \n    if(d <= EPS){\n        hit.isHit = true;\n        return hit;\n    }else{\n\t\t\n        hit.isHit = false;\n        return hit;\n    }\n}\n    \nvec3 render(vec3 p, vec3 ray, vec2 uv)\n{\n    vec3 pos;\n    surface mat = traceRay(p, ray, 0., pos);\n    \n    vec3 col = vec3(0,0,0);\n\n    vec3 sky = sinebow(fbm(vec3(ray+iTime*0.2))*5.5)*0.5+0.25;\n    if(mat.isHit)\n    {\n        // Lighting\n        vec3 normal = norm(pos);\n\n        vec3 lightDir = normalize(vec3(0.5, 1, 1));\n\t\tvec3 lightColor = vec3(1.);\n        \n        vec3 halfLE = normalize(lightDir - ray);\n        float NoL = saturate(pow(dot(normal, lightDir)*0.5+0.5,2.0));\n        \n        float spec = pow(clamp(dot(normal, halfLE), 0.0, 1.0), (1.-mat.specular)*500.);\n            \n        vec3 ref = reflect(ray, normal);\n        \n        vec3 ambientColor = sinebow(fbm(vec3(ref + iTime*0.2))*5.5)*0.05;\n        \n        mat.albedo.rgb *= NoL * lightColor;\n        mat.albedo.rgb +=  ambientColor + spec*lightColor;\n    }\n    \n    col = mat.isHit ? mat.albedo.rgb : sky;\n    \n    return col;\n    \n}\n\nmat3 camera(vec3 ro, vec3 ta, float cr )\n{\n\tvec3 cw = normalize(ta - ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec3 tot = vec3(0.0);\n#if AA>1\n    for( int m=0; m<AA; m++ )\n    for( int n=0; n<AA; n++ )\n    {\n        // pixel coordinates\n        vec2 o = vec2(float(m),float(n)) / float(AA) - 0.5;\n        vec2 p = (-iResolution.xy + 2.0*(fragCoord+o))/iResolution.y;\n#else\n        vec2 p = (-iResolution.xy + 2.0*fragCoord)/iResolution.y;\n#endif\n    \n        vec3 ro = vec3(0, 0.2, 1.0);\n        //vec3 ro = vec3(cos(iTime)*2.5, 0.0, sin(iTime)*2.5);\n        vec3 ta = vec3(0, 0.05, 0);\n\n        mat3 c = camera(ro, ta, 0.0);\n        vec3 ray = c * normalize(vec3(p, 1.5));\n        vec3 col = render(ro, ray, fragCoord.xy);\n    \n        tot += col;\n#if AA>1\n    }\n    tot /= float(AA*AA);\n#endif\n    fragColor = vec4(tot,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/Ndj3WD.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "Ndj3Wm", "name": "Revision 2021 DJ messy Jam", "author": "sp4ghet", "description": "Shader livecoded at Revision Shader Jam 2021 with DJ messy", "tags": ["revision", "jam", "2021"], "likes": 9, "viewed": 358, "date": "1617499158", "time_retrieved": "2024-06-20T20:37:46.658434", "image_code": "#define PI 3.14159265\n#define TAU 2.*PI\n#define time iTime\n#define saturate(x) clamp(x, 0., 1.)\n\nmat3 getOrtho(vec3 z, vec3 up){\n  z = normalize(z);\n  vec3 cu = normalize(cross(z,up));\n  vec3 cv = cross(cu,z);\n  return mat3(cu,cv,z);\n}\n\nconst vec3 up = vec3(0,1,0);\nfloat noise(vec3 p, float t){\n  float ns=0., amp=1., trk=1.5 + t;\n  const vec3 seed = vec3(-4,-2,.5);\n  mat3 rot = getOrtho(seed, up);\n  for(int i=0; i<4; i++){\n    p += sin(p.zxy + trk)*1.6;\n    ns += sin(dot(cos(p), sin(p.zxy)))*amp;\n    p *= rot;\n    p *= 2.3;\n    trk *= 1.5;\n    amp *= .5;\n  }\n  return ns*.5;\n}\n\nfloat fs(vec2 p){\n  return fract(sin(dot(p, vec2(12.41245, 78.233))) * 421251.543123);\n}\n\nfloat random(float x){\n  return fs(vec2(x));\n}\n\nvec2 seed;\nfloat rnd(){\n  return fs(seed);\n}\n\nvec3 rndSphere(){\n  float t = PI*rnd();\n  float p = TAU*rnd();\n  return vec3(cos(t)*cos(p), sin(t), cos(t)*sin(p));\n}\n\nvec3 rndHemi(vec3 n){\n  vec3 v = rndSphere();\n  return dot(n,v) > 0. ? v : -v;\n}\n\nvoid chmin(inout vec4 a, vec4 b){\n  a = a.x < b.x ? a : b;\n}\n\nfloat box(vec3 p, vec3 b){\n  p = abs(p) - b;\n  return min(0., max(p.x, max(p.y, p.z))) + length(max(p,0.));\n}\n\nmat2 r2d(float t){\n  float c=cos(t), s=sin(t);\n  return mat2(c,s,-s,c);\n}\n\n\nfloat lng, shrt;\n\nvec4 map(vec3 q){\n  vec3 p = q;\n  vec4 d = vec4(100000, 0,0,0);\n\n\n  float bx = box(p, vec3(5, 3.25, 7));\n  float bx2 = box(p, vec3(4, 3, 6));\n  bx = max(bx, -bx2);\n  bx2 = box(p - vec3(0,5,-1), vec3(1,2,1)) - .5;\n  bx = max(bx, -bx2);\n  bx -= .05*noise(p, shrt);\n  chmin(d, vec4(bx, 0,0,0));\n\n  p=q - vec3(-1., 0., -2.);\n  p.y -= shrt*2. - 1.;\n  p.xy *= r2d(PI*.2);\n  for(int i=0; i<10; i++){\n    p.zy *= r2d(-PI*.35*(.3 + shrt));\n    p.xy *= r2d(-PI*.4*(1.3 - shrt*shrt));\n    p.y -= .15;\n    p = abs(p);\n  }\n\n  bx = box(p, vec3(.01, .2, .01));\n  chmin(d, vec4(bx, 1,0,0));\n\n  return d;\n}\n\nvec3 normal(vec3 p){\n  vec2 e = vec2(0, 0.07678);\n  return normalize(vec3(\n    map(p + e.yxx).x - map(p - e.yxx).x,\n    map(p + e.xyx).x - map(p - e.xyx).x,\n    map(p + e.xxy).x - map(p - e.xxy).x\n  ));\n}\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n\tvec2 uv = vec2(fragCoord.x / iResolution.x, fragCoord.y / iResolution.y);\n\tvec2 pt = uv - 0.5;\n\tpt /= vec2(iResolution.y / iResolution.x, 1);\n\n  seed = vec2(noise(vec3(pt*37., time), 15.3), noise(vec3(pt*25., time), 1.2));\n\n  float bps = 120./60.;\n\n  float tm = time*bps*.5;\n  float pre = random(floor(tm) - 1.);\n  float now = random(floor(tm));\n  lng = fract(tm);\n  lng = 0.5 + 0.5*cos(PI*exp(-8.*lng));\n  lng = mix(pre, now, lng);\n\n  tm = time*bps*2.;\n  pre = random(floor(tm) - 1.);\n  now = random(floor(tm));\n  shrt = fract(tm);\n  shrt = 0.5 + 0.5*cos(PI*exp(-3.*shrt));\n  shrt = mix(pre, now, shrt);\n\n  vec3 c = vec3(0.);\n\n  float longAngle = .4 * TAU * (lng - .5) + PI*.5;\n  vec3 ro = vec3(0.,0.,3.);\n\n  vec3 fo = vec3(-1., 2.*shrt - 1.,-2.);\n\n  vec3 rov = normalize(fo - ro);\n  vec2 pt2 = pt*r2d((lng - .5)*PI*.3);\n  vec3 rd = getOrtho(rov, up) * normalize(vec3(pt2, 1.));\n\n  float t=0.;\n  vec3 p=ro;\n  vec4 d;\n  for(int i=0; i<64; i++){\n    p = ro + rd*t;\n    d = map(p);\n    if(abs(d.x) < 0.01){\n      break;\n    }\n    t += d.x;\n  }\n\n  vec3 l = normalize(vec3(1,4,1));\n  if(abs(d.x) < 0.01){\n    vec3 n = normal(p);\n    c += max(0., dot(n,l));\n    float fre = pow(1. - abs(dot(n,rd)) , 5.);\n    c += fre;\n\n    float ao=0.,ss=0.;\n    vec3 h = normalize(l-rd);\n    for(int i=1;i<=10;i++){\n      float aot = 0.1*float(i) + .05*rnd();\n      float sst = 0.3*float(i) + .5*rnd();\n      vec3 nd = mix(n,rndHemi(n),.2);\n      ao += map(p+nd*aot).x/aot;\n      ss += map(p+h*sst).x/sst;\n    }\n    c += ss*.1;\n    c *= ao*.1;\n\n    if(d.y == 1.){\n      c *= vec3(25, 1, 1.5);\n    }\n\n    vec3 hitp = p;\n    float sh=1., tt=.1;\n    for(int i=0; i<24; i++){\n      hitp = p + l*tt;\n      float d = map(hitp).x;\n      tt += d + .2*rnd();\n      if(d < 0.001){\n        sh = 0.;\n        break;\n      }\n      if(tt > 30.){\n        break;\n      }\n      sh = min(sh, 8.*d/tt);\n    }\n\n    c *= saturate(.2+sh);\n  }\n\n\n  float od=0.;\n  vec3 acc=vec3(0.), fogC = vec3(1, .8, .8);\n  int n=16;\n  float st=min(2., t/float(n)), tt=0.;\n  for(int i=0; i<n; i++){\n    p = ro + rd*tt;\n    tt += st*(.95+.1*rnd());\n    od += .2*(1. + abs(noise(p*3., time))) * st;\n\n    vec3 pp=p; float t=0.1;\n    float sh=2.;\n    for(int j=0; j<24; j++){\n      pp = p + l*t;\n      float d = map(pp).x;\n      t += d;\n      if(d < 0.01){\n        sh=0.;\n        break;\n      }\n    }\n    acc += exp(-od*fogC)*sh*st;\n  }\n  c *= exp(-.3*od);\n  c += acc;\n\n  c = c/(1. + c);\n\n  c = pow(c, vec3(.4545));\n  c = smoothstep(.05, 1.4, c);\n  float lum = dot(c, vec3(.2126, .7152, .0722));\n  float shad = smoothstep(.4, .01, lum);\n  float high = smoothstep(.3, 1., lum);\n  c = c*shad*vec3(.4, 1.2, 1.2) + c*(1.-shad*high) + c*high*vec3(.9, .8,.8);\n\n  c *= 1. - length(pt);\n\n\tfragColor = vec4(c,1.);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/Ndj3Wm.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "Ndj3Wt", "name": "celluar_noise_8x", "author": "penghuailiang", "description": "八倍 细胞噪声生成\n\nhttps://huailiang.github.io/blog/2021/noise/", "tags": ["noise"], "likes": 2, "viewed": 135, "date": "1618119926", "time_retrieved": "2024-06-20T20:37:46.658434", "image_code": "#define SCALE 8.\n\nvec2 random(vec2 st){\n    return  fract(\n        sin(\n            vec2(\n                dot(st, vec2(127.1,311.7)),\n                dot(st, vec2(269.5,183.3))\n            )\n        ) * 43758.5453\n    );\n}\n\nfloat noise(vec2 p) {\n    vec2 i = floor(p); // 获取当前网格索引i\n    vec2 f = fract(p); // 获取当前片元在网格内的相对位置\n    float F1 = 1.;\n    // 遍历当前像素点相邻的9个网格特征点\n    for (int j = -1; j <= 1; j++) {\n        for (int k = -1; k <= 1; k++) {\n            vec2 neighbor = vec2(float(j), float(k));\n            vec2 point = random(i + neighbor);\n            float d = length(point + neighbor - f);\n            F1 = min(F1,d);\n        }\n    }\n    return F1;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = fragCoord.xy/iResolution.xy;\n    float c = noise(vec2(SCALE*uv));\n    c = pow(c, 2. * (0.5+abs(sin(iTime))));\n    vec3 color= vec3(c,c,c);\n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/Ndj3Wt.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "NdjGDV", "name": "Spacemandel2", "author": "Chaotnix", "description": "playing around with mandelcube and soundcloud,\nThis shader is based on Dark Mandelbox by thiagoborn https://www.shadertoy.com/view/tsBGWw ", "tags": ["fractal", "mandelbox", "audioreactive", "soundcloud"], "likes": 2, "viewed": 135, "date": "1617988509", "time_retrieved": "2024-06-20T20:37:46.665095", "image_code": "\n#define ITERS 6\n\nfloat SCALE=2.0;\nfloat MR2=0.0;\n\nfloat mandelbox(vec3 position){\n  vec4 scalevec = vec4(SCALE, SCALE, SCALE, abs(SCALE)) / MR2;\n  float C1 = abs(SCALE + 7.0), C2 = pow(abs(SCALE), float(1-ITERS));\n  vec4 p = vec4(position.xyz, 1.0) -0.3  + 0.4 * pow(texture(iChannel0, vec2(length(position.xyz), 0.26) ).x, 0.2), p0 = vec4(position.xyz, 1.0) +0.3 - 0.3 * pow(texture(iChannel0, vec2(length(position.xyz), 0.26) ).x, 0.2);  // p.w is knighty's DEfactor\n  for (int i=0; i<ITERS; i++) {\n    //p.xyz = p.xyz * vec3(0.2),p.y,smoothstep(.04,0.06, 0.01 * pow(texture(iChannel0, vec2(length(p.yz), 0.) ).x/3., 0.01)*4.);\n    p.xyz = clamp(p.xyz, -1.0, 1.0) * 2.0 - p.xyz;  // box fold: min3, max3, mad3\n    float r2 = dot(p.xyz, p.xyz);  // dp3\n    p.xyzw *= clamp(max(MR2/r2, MR2), 0.0, 1.0);  // sphere fold: div1, max1.sat, mul4\n    p.xyzw = p*scalevec + p0/6.;  // mad4\n//    p0 = p0 - smoothstep(p.x,p.x*0.2,pow(texture(iChannel0, vec2(length(p.xy), 0.) ).x*8., 0.01)*2.);\n}\n  return (length(p.xyz) - C1) / p.w - C2;\n}\n\nfloat color(vec3 p){\n    vec3 op = p;\n    for (int i=0; i<ITERS; i++) {\n        p.xyz = clamp(p.xyz, -1.0, 1.0) * 2.0 - p.xyz;  // box fold: min3, max3, mad3\n        float r2 = dot(p.xyz, p.xyz);  // dp3\n        p.xyz *= clamp(max(MR2/r2, MR2), 0.0, 1.0);  // sphere fold: div1, max1.sat, mul4\n        p.xyz = p*SCALE/MR2 + op;  // mad4\n//        p.xyz = p - mix(vec3(0.1),p,smoothstep(.04,0.06, 0.01 * pow(texture(iChannel0, vec2(length(p.xy), 0.) ).x/3., 0.01)*4.));\n    }\n  \treturn length(p/2.);\n}\n\nfloat trace(vec3 o,vec3 d){\n    float v=0.2;\n    for(int i=0;i<34;i++){\n        vec3 p=o+d*v;\n        p=p + 1.;// + 0.2 * texture(iChannel0, vec2(length(p.xy), 1.) ).x;\n        float mv=mandelbox(p);        \n        if(mv<0.01){\n            return v;\n        }\n        v+=mv *.9;\n    }\n    return 0.;\n}\n\nvec3 pal( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d )\n{\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\n    \nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord/iResolution.xy)*4.-1.5;\n    uv.x *= iResolution.x/iResolution.y;\n    uv *= 3.0;\n   //SCALE = 2.5 + iMouse.x * 2.0;\n   // MR2 = iMouse.x * iMouse.x;\n    //SCALE = 2.9 + sin(iTime*10.0)*.0;\n    SCALE = 2.5;\n    float mr = 0.7;\n    MR2 = mr * mr - 0.1* pow(texture(iChannel0, vec2(length(uv.y),.8) ).x, 0.005);\n    \n      \n    vec3 lookingTo = vec3(3.,2.,4.);\n    float it = iTime / 5.;\n    vec3 viewer = vec3(\n        sin(iTime*.1) * 6.0,\n        cos(iTime*.17) * 5.0,\n        cos(iTime*.1) * 6.0\n    );\n    \n    vec3 forward = normalize(lookingTo-viewer);\n    vec3 rigth = cross(vec3(1.0,1.0,0.0),forward);\n    vec3 up = cross(forward,rigth);\n    \n    vec3 direction = normalize(forward/0.1 * pow(texture(iChannel0, vec2(length(uv.y),.8) ).x, 0.005) + rigth * uv.x + up * uv.y);\n    \n    float dist = trace(viewer,direction);\n    vec3 col=vec3(0.0);\n    if(dist <=0.) {\n    //    dist=dist + 2. * texture(iChannel0, vec2(length(dist),0.005) ).x;\n\t\tdist = 1. - dist + 2. * texture(iChannel0, vec2(length(dist),0.005) ).x;\t\n    };    \n     vec3 p = viewer + direction * dist ;\n    \n    \n    if(dist!=0.) {\n        \n         float c = color(p);\n        \n   \t\t col = pal(c/50.0, \n                   vec3(0.5,0.5,0.5),vec3(0.5,0.5,0.7),vec3(1.0,1.0,1.0),vec3(0.0,0.10,0.20)\n                   //vec3(0.8,0.5,0.4),vec3(0.2,0.4,0.2),vec3(2.0,1.0,1.0),vec3(0.0,0.25,0.25)\n                   //vec3(0.5,0.5,0.5),vec3(0.5,0.5,0.5),vec3(2.0,1.0,0.0),vec3(0.5,0.20,0.25)\n                  );\n\n        //col = vec3(1.0);\n    };\n\n    \n   \n   \n    float fog = .8 + .05 * texture(iChannel0, vec2(length(p),.3) ).x;\n    fragColor.rgb = vec3(col * fog);\n}", "image_inputs": [{"id": "MlsXWM", "previewfilepath": "https://soundcloud.com/neelix/hello", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0, "src": "https://soundcloud.com/neelix/hello", "ctype": "musicstream"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/NdjGDV.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "NdjGDw", "name": "Spirals^w^", "author": "lechuga", "description": "Metabolas y espirales, queria hacer algo vaporwave pero no me salió.\n\ndespues de la revision, y fuera de la presión y estres , decidi hacer otro shader más ordenado y sin fractales.\n\nzozo <3", "tags": ["demoscene", "spirals", "lechugafeliz"], "likes": 3, "viewed": 47, "date": "1617492379", "time_retrieved": "2024-06-20T20:37:46.666092", "image_code": "vec4 plas( vec3 v, float time )\n{\n\tfloat c = 0.5 + sin( v.x * 10.0 ) + cos( sin( time + v.y ) * 5.0 );\n\treturn vec4( sin(c * 0.2 + cos(time)), c * 0.15, cos( c * 0.1 + time / .4 ) * .25, 1.0 );\n}\n#define time mod(iTime, 100.)\n#define rot(a) mat2(cos(a), sin(a), -sin(a), cos(a))\n#define smin(a,b ,k) min(a, b)-pow(max(k-abs(a-b), 0.)/k, 3.)*k*(1.0/6.0)\nfloat rand(float x){return fract(sin(x*542.23)*454.);}\nfloat c(float t, float s){t/=s; return mix( rand(floor(t)), rand(floor(t+1.)), pow(smoothstep(0., 1., fract(t)), 15.5555) );}\nfloat sb(vec3 p, vec3 s){p = abs(p)-s; return max(max(p.x, p.y), p.z);}\nfloat glow, glow2, glow3;\nfloat metaballs(vec3 p){float d;\n  vec3 p1 = p;\n  float tt = c(time, 10.)*4.;\n  float time1= time+tt;\n  for(int i = 0; i < 3; i++){p1.xz *= rot(p1.y*.21+time1);}\n  p1 += plas((p1*.345325 * p1*.323425), time1*5.).x;\n  float e1 = length(p1-vec3(cos(time1)*15., sin(time1)*5., 0.))-2.5;\n  float e2 = length(p1-vec3(cos(time1)*sin(time1)*14., 1.+sin(time1)*13., 1.))-3.;\n  float e3 = length(p1-vec3(cos(time1)*sin(time1)*14., 1., 2.-sin(time1)*23.)*cos(time1))-2.4;\n  float e4 = length(p1)-5.;\n  glow += .05/(1.+e1*e1);\n  glow2 += .1/(.1+e2*e2);\n  glow3 += .01/(.5+e3*e3);\n  d = e1;\n  d = smin(e2,d, 13.);\n  d = smin(e3,d, 13.);\n  //d = min(e4,d);\n  \n  return d*.3;\n}\nfloat dfc;\nfloat map(vec3 p){float d = metaballs(p);\n\n  const float dfv = 35.;\n  float df = dfv-p.y;\n  vec3 p1 = p;\n  const float re = 10.;\n  p1.z += time*40.;\n  p1.y -= dfv;\n  p1.xz = (fract(p1.xz/re+.5)-.5)*re;\n  float cubs = sb(p1, vec3(4.5, 5., 4.5));\n  dfc += .68/(1.+cubs*cubs);\n  \n  \n  \n  vec3 p2 = p;\n  p2.z += time*70.;\n  p2.y += dfv;\n  p2.x = abs(p2.x)-2.5-time;\n  p2.x = abs(p2.x)-1.75;\n  p2.xz = (fract(p2.xz/re+.5)-.5)*re;\n  \n  float rrr = .15;\n  float linesV = length(p2.xy)-rrr;\n  float linesH = length(p2.zy)-rrr;\n  d = min(d, df);\n  d = min(d, cubs);\n  d = min(d, linesH);\n  d = min(d, linesV);\n  return d;\n}\n\nconst vec2 e = vec2(0.0123123, 0.0345345);\nvec3 nm(vec3 p){\n  return normalize(map(p)-vec3(map(p-e.xyy), map(p-e.yxy), map(p-e.yyx)));\n}\nvoid cam(inout vec3 p){p.xz *= rot(c(time,14.345)+time); p.yz *= rot(sin(time)*.05-.5);}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\tuv -= 0.5;\n\n\n  vec3 s = vec3(0.00001, 0.00001, -50.), r = normalize(vec3(-uv, 1.));\n  cam(s); cam(r);\n  vec3 col = vec3(0.), p = s;\n  float i = 0.; const float MAX = 100.; float d;\n  for(; i < MAX ; i++) if(d=map(p),p+=d*r, abs(d) < .001) break;\n  col += 1.-i/MAX;\n  col += glow * vec3(.01, .234, 0.1);\n  col += glow2 * vec3(.1, 0., 1.);\n  col += glow3 * vec3(1., 0.11, 0.11);\n  col += mix(dfc*vec3(.523, .33423, .0)*.19, vec3(.657, .1, .413)*.777, 0.545);\n  col += mix(pow(length(p-s), .07)*vec3(.99, .45, .0)*.1, vec3(1., 0., 1.), 0.19);\n  col *= 1.-length(p-s)/300.;\n\tfragColor = vec4(col, 1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/NdjGDw.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "NdjGRc", "name": "Easter egg attack!", "author": "xernobyl", "description": "Happy easter!", "tags": ["march"], "likes": 1, "viewed": 63, "date": "1617743221", "time_retrieved": "2024-06-20T20:37:46.667089", "image_code": "float sd_box(vec3 p, vec3 b) {\n  vec3 q = abs(p) - b;\n  return length(max(q, 0.0)) + min(max(q.x, max(q.y, q.z)), 0.0);\n}\n\n\nfloat sd_sphere(vec3 p, float r) {\n  return length(p) - r;\n}\n\n\nfloat opSmoothUnion( float d1, float d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); }\n\nfloat opSmoothSubtraction( float d1, float d2, float k ) {\n    float h = clamp( 0.5 - 0.5*(d2+d1)/k, 0.0, 1.0 );\n    return mix( d2, -d1, h ) + k*h*(1.0-h); }\n\n\nfloat scene(vec3 ray_pos, vec3 ray_origin) {\n    float a = 0.5 * ray_pos.z + 2.0 * iTime;\n    \n    vec3 r0;\n    r0.xy = vec2(ray_pos.x * cos(a) - ray_pos.y * sin(a),\n                      ray_pos.x * sin(a) + ray_pos.y * cos(a));\n    r0.z = ray_pos.z;\n\n    \n    \n    float d0 = sd_sphere(fract((r0) / 2.5) * 2.5 - 1.25, 0.5);\n    \n    \n    a = -0.5 * ray_pos.z - 4.0 * iTime;\n    \n    ray_pos.xy = vec2(ray_pos.x * cos(a) - ray_pos.y * sin(a),\n                      ray_pos.x * sin(a) + ray_pos.y * cos(a));\n\n    float d1 = sd_box(fract((ray_pos) / 5.0) * 5.0 - 2.5, vec3(1.0, 1.0, 10.0));\n    \n    return opSmoothUnion(d0, d1, 0.25);\n}\n\n\nvec3 scene_normal(vec3 p, vec3 ray_origin) {\n  const float h = 0.01;\n  const vec2 k = vec2(1.0, -1.0);\n  return normalize(k.xyy * scene(p + k.xyy * h, ray_origin) + \n                   k.yyx * scene(p + k.yyx * h, ray_origin) + \n                   k.yxy * scene(p + k.yxy * h, ray_origin) + \n                   k.xxx * scene(p + k.xxx * h, ray_origin));\n}\n\n    \nvec3 pal(in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d) {\n  return a + b * cos(6.28318 * (c * t + d));\n}\n\n\nvec3 sRGB(vec3 linear)\n{\n  vec3 a = 12.92 * linear;\n  vec3 b = 1.055 * pow(linear, vec3(1.0 / 2.4)) - 0.055;\n  vec3 c = step(vec3(0.0031308), linear);\n  return mix(a, b, c);\n}\n\n\nvoid mainImage(out vec4 frag_color, in vec2 frag_coord) {\n  vec3 ray_dir = vec3(frag_coord / iResolution.xy * 2.0 - 1.0, -1.0 / 4.0);\n  ray_dir.x *= iResolution.x / iResolution.y;\n  ray_dir = normalize(ray_dir);\n\n  vec3 ray_origin = vec3(0.0, 0.0, -10.0 * iTime + sin(iTime));\n  vec3 ray_pos = ray_origin;\n  \n  int max_iterations = 128;\n  float total_distance = 0.0;\n\n  for (int max_iterations = 0; max_iterations < 64; ++max_iterations) {\n    float dist = scene(ray_pos, ray_origin);\n    total_distance += dist;\n\n    ray_pos = ray_origin + total_distance * ray_dir;\n\n    if (dist < 0.0001) {\n      break;\n    }\n  }\n\n  vec3 n = scene_normal(ray_pos, ray_origin);\n  \n  vec3 col = pal(total_distance * .25 + iTime, vec3(0.5,0.5,0.5),vec3(0.5,0.5,0.5),vec3(1.0,1.0,0.5),vec3(0.8,0.90,0.30) );\n  \n  col = 2.0 * col * -dot(n, ray_dir);\n  col *= clamp(1.0 / (total_distance - 1.0), 0.0, 1.0);\n  \n  frag_color = vec4(sRGB(col), 0.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/NdjGRc.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "NdjGWz", "name": "Cubic Bezier vs. Line Intersect", "author": "oneshade", "description": "Bezier curves are turning out to be quite fun.", "tags": ["bezier", "line", "intersection", "cubic", "parametric"], "likes": 4, "viewed": 105, "date": "1617240974", "time_retrieved": "2024-06-20T20:37:46.668086", "image_code": "#define draw(d, c) color = mix(color, c, smoothstep(unit, 0.0, d))\n\nstruct Intersect {\n    int count;\n    vec2[3] p;\n};\n\nfloat sdLine(in vec2 p, in vec2 a, in vec2 b) {\n    vec2 pa = p - a, ba = b - a;\n    return length(pa - ba * clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0));\n}\n\nconst vec2 eta = vec2(-0.5, sqrt(0.75));\nint solveCubic(in float a, in float b, in float c, in float d, out vec3 roots) {\n    float h = 18.0 * a * b * c * d - 4.0 * b * b * b * d + b * b * c * c - 4.0 * a * c * c * c - 27.0 * a * a * d * d;\n\n    b /= a, c /= a, d /= a;\n    float d0 = b * b - 3.0 * c;\n    float d1 = (2.0 * b * b - 9.0 * c) * b + 27.0 * d;\n    float q = d1 * d1 - 4.0 * d0 * d0 * d0, j = sqrt(abs(q));\n\n    vec2 C = q < 0.0 ? vec2(d1, j) : vec2(d1 + j, 0.0);\n    if (abs(C.x) + abs(C.y) < 1e-3) C = vec2(d1 - j, 0.0);\n    float t = atan(C.y, C.x) / 3.0, r = pow(0.25 * dot(C, C), 1.0 / 6.0);\n    C = vec2(cos(t), sin(t));\n\n    float w = -d0 / r - r;\n    roots.x = (C.x * w - b) / 3.0;\n    roots.y = (dot(vec2(C.x, -C.y), eta) * w - b) / 3.0;\n    if (h > 0.0) roots.z = (dot(C, eta) * w - b) / 3.0;\n    else if (abs(dot(C.yx, eta)) < abs(C.y)) roots.x = roots.y;\n\n    return h < 0.0 ? 1 : 3;\n}\n\nvec2 BezierCurvePoint(in vec2 a, in vec2 b, in vec2 c, in vec2 d, in float t) {\n    float tInv = 1.0 - t;\n    return a * tInv * tInv * tInv +\n           b * 3.0 * t * tInv * tInv +\n           c * 3.0 * tInv * t * t +\n           d * t * t * t;\n}\n\nIntersect BezierLineIntersect(in vec2 ca, in vec2 cb, in vec2 cc, in vec2 cd, in vec2 la, in vec2 lb) {\n    vec2 ba = lb - la;\n    float baba = dot(ba, ba);\n    vec2 ld = normalize(ba);\n\n    mat2 invRot = mat2(ld, -ld.y, ld.x);\n    mat2 rot = transpose(invRot);\n\n    ca = (ca - la) * invRot;\n    cb = (cb - la) * invRot;\n    cc = (cc - la) * invRot;\n    cd = (cd - la) * invRot;\n\n    float coeff1 = 3.0 * cb.y - 3.0 * cc.y - ca.y + cd.y;\n    float coeff2 = 3.0 * ca.y - 6.0 * cb.y + 3.0 * cc.y;\n    float coeff3 = 3.0 * cb.y - 3.0 * ca.y;\n    float coeff4 = ca.y;\n\n    vec3 t;\n    int nroots = solveCubic(coeff1, coeff2, coeff3, coeff4, t);\n\n    vec2[3] intersects;\n    int count = 0;\n    for (int n=0; n < nroots; n++) {\n        if (abs(t[n] - 0.5) <= 0.5) {\n            vec2 p = BezierCurvePoint(ca, cb, cc, cd, t[n]) * rot;\n            if (abs(dot(p, ba) / baba - 0.5) <= 0.5) {\n                intersects[count] = p + la;\n                count++;\n            }\n        }\n    }\n\n    return Intersect(count, intersects);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n    float unit = 2.0 / iResolution.y;\n    vec3 color = vec3(0.25);\n\n    float time = iTime;\n\n    float t1 = time * 0.5, t2 = time, t3 = time * 1.25;\n\n    float c1 = cos(t1), s1 = sin(t1);\n    float c2 = cos(t2), s2 = sin(t2);\n    float c3 = cos(t3), s3 = sin(t3);\n\n    vec2 ca = vec2(c2, s3) * 0.5;\n    vec2 cb = vec2(s1, s2) * 0.5;\n    vec2 cc = vec2(c3, c1) * 0.5;\n    vec2 cd = vec2(c2, s1) * 0.5;\n\n    vec2 la = vec2(c3, s2) * 0.5;\n    vec2 lb = vec2(s2, c1) * 0.5;\n\n    draw(sdLine(uv, la, lb) - 0.01, vec3(0.0, 0.0, 1.0));\n\n    float tStep = 0.01;\n    vec2 prev = ca;\n    for (float t=tStep; t < 1.0 + tStep; t += tStep) {\n        vec2 cur = BezierCurvePoint(ca, cb, cc, cd, t);\n        draw(sdLine(uv, prev, cur) - 0.01, vec3(1.0, 0.8, 0.0));\n        prev = cur;\n    }\n\n    Intersect intersects = BezierLineIntersect(ca, cb, cc, cd, la, lb);\n    for (int n=0; n < intersects.count; n++) {\n        draw(length(uv - intersects.p[n]) - 0.015, vec3(1.0));\n    }\n\n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/NdjGWz.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "NdjXzD", "name": "Closest Points - Lines", "author": "oneshade", "description": "I've finally got a reasonable closest points for lines method. Spurred by @iapafoto's shader: [url=https://www.shadertoy.com/view/fsBXzR]https://www.shadertoy.com/view/fsBXzR[/url]", "tags": ["2d", "lines", "points", "closest"], "likes": 12, "viewed": 136, "date": "1619800327", "time_retrieved": "2024-06-20T20:37:47.052369", "image_code": "void update(in vec2 a, in vec2 b, inout vec4 pair, inout float comp) {\n    vec2 ba = b - a;\n    float comp2 = dot(ba, ba);\n    if (comp2 < comp) { pair = vec4(a, b); comp = comp2; }\n}\n\nvec4 closestPointsLines(in vec2 a, in vec2 b, in vec2 c, in vec2 d) {\n    vec2 ba = b - a, ca = c - a, dc = d - c;\n\n    // Closest points are an intersection (this case can be ignored in 3D)\n    float v = (ba.y * ca.x - ba.x * ca.y) / (dc.y * ba.x - dc.x * ba.y); // 2D cross products\n    float u = (ca.x + dc.x * v) / ba.x;\n    if (u >= 0.0 && u <= 1.0 && v >= 0.0 && v <= 1.0) return (a + ba * u).xyxy;\n\n    // Closest points are caps and projections of the caps\n    float baba = dot(ba, ba), dcdc = dot(dc, dc);\n\n    vec4 pair = vec4(a, c + dc * clamp(dot(-ca, dc) / dcdc, 0.0, 1.0));\n    vec2 diff = pair.zw - pair.xy;\n    float comp = dot(diff, diff);\n\n    update(b, c + dc * clamp(dot(b - c, dc) / dcdc, 0.0, 1.0), pair, comp);\n    update(c, a + ba * clamp(dot(   ca, ba) / baba, 0.0, 1.0), pair, comp);\n    update(d, a + ba * clamp(dot(d - a, ba) / baba, 0.0, 1.0), pair, comp);\n\n    return pair;\n}\n\nfloat sdLine(in vec2 p, in vec2 a, in vec2 b) {\n    vec2 pa = p - a, ba = b - a;\n    return length(pa - ba * clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 center = 0.5 * iResolution.xy;\n    vec2 uv = (fragCoord - center) / iResolution.y * 4.0;\n\n    float t1 = iTime * 0.5, t2 = iTime, t3 = iTime * 1.25;\n\n    float c1 = cos(t1), s1 = sin(t1);\n    float c2 = cos(t2), s2 = sin(t2);\n    float c3 = cos(t3), s3 = sin(t3);\n\n    vec2 a = vec2(c1, s2);\n    vec2 b = vec2(s1, c2);\n\n    vec2 c = vec2(s3, c1);\n    vec2 d = vec2(c2, s3);\n\n    float dist = min(sdLine(uv, a, b), sdLine(uv, c, d)) * 0.75;\n\n    // Nice colors from iq\n    vec3 color = 1.0 - sign(dist) * vec3(0.1, 0.4, 0.7);\n\tcolor *= 1.0 - exp(-4.0 * abs(dist));\n\tcolor *= 0.8 + 0.2 * cos(140.0 * dist);\n\tcolor = mix(color, vec3(1.0), 1.0 - smoothstep(0.0, 0.015, abs(dist * 0.6)));\n\n    color = mix(color, vec3(1.0, 1.0, 0.0), 1.0 - smoothstep(0.0, 0.015, length(uv - a) - 0.05));\n    color = mix(color, vec3(1.0, 1.0, 0.0), 1.0 - smoothstep(0.0, 0.015, length(uv - b) - 0.05));\n\n    color = mix(color, vec3(1.0, 1.0, 0.0), 1.0 - smoothstep(0.0, 0.015, length(uv - c) - 0.05));\n    color = mix(color, vec3(1.0, 1.0, 0.0), 1.0 - smoothstep(0.0, 0.015, length(uv - d) - 0.05));\n\n    vec4 closest = closestPointsLines(a, b, c, d);\n    color = mix(color, vec3(1.0, 0.0, 0.0), 1.0 - smoothstep(0.0, 0.015, length(uv - closest.xy) - 0.05));\n    color = mix(color, vec3(1.0, 0.0, 0.0), 1.0 - smoothstep(0.0, 0.015, length(uv - closest.zw) - 0.05));\n    color = mix(color, vec3(1.0, 0.0, 0.0), 1.0 - smoothstep(0.0, 0.015, sdLine(uv, closest.xy, closest.zw) - 0.01));\n\n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/NdjXzD.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "NdlGzs", "name": "Foxie", "author": "z0rg", "description": "A shader idea I had for a long time but wasn't able to reproduce a simplifies fox until now.\nHope you like it.\nYou can make it your window terminal background following link here : https://github.com/seb776/WindowsTerminalShaders", "tags": ["2d", "vector", "purple", "fox"], "likes": 16, "viewed": 232, "date": "1617615674", "time_retrieved": "2024-06-20T20:37:47.834264", "image_code": "// This work is licensed under the Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n// Unported License. To view a copy of this license, visit http://creativecommons.org/licenses/by-nc-sa/3.0/ \n// or send a letter to Creative Commons, PO Box 1866, Mountain View, CA 94042, USA.\n// =========================================================================================================\n//\n// You can make it your window terminal background following link here :\n// https://github.com/seb776/WindowsTerminalShaders\n//\n#define sat(a) clamp(a, 0., 1.)\n#define PI 3.141592653\n\nmat2 r2d(float a) { float c= cos(a), s = sin(a); return mat2(c,-s,s,c);}\nfloat lenny(vec2 v) { return abs(v.x)+abs(v.y); }\n\nfloat _cir(vec2 uv, float r)\n{\n    return length(uv)-r;\n}\n\nfloat _sqr(vec2 p, vec2 s)\n{\n    vec2 l = abs(p)-s;\n    return max(l.x, l.y);\n}\n\nfloat _nimal(vec2 uv)\n{\n\n    uv.x+=sin(uv.y*25.+iTime*2.)*0.01*sat(uv.y*5.);\n    vec2 tuv = (uv-vec2(0.11+0.01*sin(uv.y*30.-iTime*4.),-.05)) * r2d(PI/4.);\n\n    tuv.x = abs(tuv.x);\n    tuv = (tuv-vec2(-.07,0.));\n    float tail = _cir(tuv, .1);\n    uv -= vec2(0.05,-.03);\n    float body = 10.;\n    \n    float anhears = 0.1;\n    vec2 offhears = vec2(0.01,0.);\n    body = min(body, _sqr((uv+offhears)*r2d(anhears), vec2(.025,.07)));\n    body = min(body, _sqr((uv-offhears)*r2d(-anhears), vec2(.025,.07)));\n    body = max(body, -_sqr((uv-vec2(0.,.08))*r2d(PI/4.), vec2(.03)));\n    uv.x = abs(uv.x);\n    body = min(body, _cir(uv*vec2(1.,.8)-vec2(.02,-0.04),.03));\n    body = min(body, _cir(uv*vec2(1.,.8)-vec2(.048,-0.058),.005));\n    body = min(body, tail);\n    return body;\n}\n\nfloat _star(vec2 p, vec2 s)\n{\n    float a = _sqr(p, s.xy);\n    float b = _sqr(p, s.yx);\n    return min(a, b);\n}\n\nfloat _stars(vec2 uv, vec2 szu)\n{\n    uv *= r2d(PI/4.);\n    vec2 ouv = uv;\n    float th = 0.002;\n    vec2 rep = vec2(0.1);\n\n    vec2 idx = floor((uv+rep*.5)/rep);\n    \n    uv = mod(uv+rep*.5, rep)-rep*.5;\n    float sz = sat(sin(idx.x*5.+idx.y+iTime))*sat(length(ouv*2.)-.5);\n    return _star(uv, vec2(20.*th, th)*.5*sz*szu);\n}\n\nvec3 rdr(vec2 uv)\n{\n    float shp = 400.;\n    vec3 background = vec3(0.431,0.114,0.647)*.2;\n    \n    background = mix(background, vec3(1.000,0.761,0.239), 1.-sat(_stars(uv, vec2(1.))*shp));\n    \n    vec3 sunCol = vec3(1.000,0.761,0.239);\n    vec3 foregroundBack = vec3(0.345,0.125,0.494);\n    \n    vec3 foreground;\n    \n    float sun = _cir(uv, .02);\n    float sstp = 0.05;\n    sun = floor(sun/sstp)*sstp;\n    foreground = mix(foregroundBack, sunCol, 1.-sat(sun*4.));\n    \n    float mount = uv.y-asin(sin(uv.x*25.))*.01+.1;\n    foreground = mix(foreground, foreground*.3, 1.-sat(mount*shp*.5));\n    \n    float mount2 = uv.y-(sin(uv.x*25.+2.))*.05+.1;\n    foreground = mix(foreground, foreground*.5, 1.-sat(mount2*shp*.1));\n\n    \n    float hill = _cir(uv-vec2(0.,-.9), .8);\n    foreground = mix(foreground, vec3(0.), 1.-sat(hill*shp));\n\n    float nanimal =_nimal(uv);\n    foreground = mix(foreground, vec3(0.), 1.-sat(nanimal*shp));\n    \n    \n    float mask = _cir(uv, .25);\n    \n    vec3 col = mix(background, foreground, 1.-sat(mask*shp));\n    \n    col += (1.-sat(length(uv*3.)))*sunCol*.7;\n    float flicker = .1;\n    col += pow(1.-sat(lenny(uv*vec2(1.,2.))),5.)*sunCol*.7\n        *mix(.95,1., sat(sin(iTime*25.)*2.+sin(iTime*40.)));\n    \n    col = mix(col, vec3(1.000,0.761,0.239), sat(length(uv)-.1)*(1.-sat(_stars(uv*.8, vec2(5.))*shp*.3))*.7);\n    return col;\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-vec2(.5)*iResolution.xy)/iResolution.xx;\n\n    vec3 col = rdr(uv);\n    \n    col *= mix(-1.,1.,1.-sat(lenny(uv*2.)-.5));\n    col = sat(col);\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": "XtlSWM", "previewfilepath": "https://soundcloud.com/aydio/deltitnu", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0, "src": "https://soundcloud.com/aydio/deltitnu", "ctype": "musicstream"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc-by-nc-sa-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/NdlGzs.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "NdlSD7", "name": "Circle Sandbox", "author": "lmno", "description": "My little sandbox for making cool circly stuffs.", "tags": ["circle"], "likes": 2, "viewed": 23, "date": "1618724776", "time_retrieved": "2024-06-20T20:37:47.834264", "image_code": "\n\n\n\n// Drawing utilities\n#define drawSDF(dist, col) color = mix(color, col, smoothstep(unit, -0.05, dist))\n\n// SDFs\nfloat sdDisc(in vec2 p, in vec2 o, in float r) {\n    return length(p - o) - r;\n}\n\nfloat sdInfLine(in vec2 p, in vec2 a, in vec2 b) {\n    vec2 pa = p - a, ba = b - a;\n    return length(pa - ba * dot(pa, ba) / dot(ba, ba));\n}\n\nfloat sdLine(in vec2 p, in vec2 a, in vec2 b) {\n    vec2 pa = p - a, ba = b - a;\n    return length(pa - ba * clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 center = 0.5 * iResolution.xy;\n\n    vec4 mouse = (vec4(iMouse.xy, abs(iMouse.zw)) - center.xyxy) / iResolution.y * 4.0;\n    vec2 uv = (fragCoord - center) / iResolution.y * 4.0;\n    float unit = 9.0 / iResolution.y;\n    vec3 color = vec3(0.600,0.039,0.290);\n\n    // Default before interaction\n    if (ivec2(iMouse.xy) == ivec2(0)) {\n        mouse.xy = vec2(sin(iTime), 1.0) * cos(iTime);\n        mouse.x += 2.0;\n    }\n\n    // Radius and angles\n    float r = 0.75;\n    vec2 a = atan(mouse.y, mouse.x) + vec2(2.0, -1.9) * acos(r / length(mouse.xy));\n\n    // For just the points, this can be simplified (likely no sin/cos, just 1 or 2 sqrts)\n    vec2 t1 = vec2(cos(a.x), sin(a.x)) * r;\n    vec2 t2 = vec2(cos(a.y), sin(a.y)) * r;\n    vec2 t3 = vec2(cos(a.x), sin(a.y)) * r;\n    vec2 t4 = vec2(cos(a.y), sin(a.x)) * r;\n\n    // Circle\n    drawSDF(abs(sdDisc(uv, vec2(0.0), r)), vec3(1.000,0.000,0.000));\n\n    // Right triangle 1\n    drawSDF(min(sdLine(uv, vec2(0.0), mouse.xy),\n            min(sdLine(uv, mouse.xy, t1),\n                sdLine(uv, t1, vec2(0.0)))), vec3(1.0, 0.0, 1.0));\n\n    // Right triangle 2\n    drawSDF(min(sdLine(uv, vec2(0.0), mouse.xy),\n            min(sdLine(uv, mouse.xy, t2),\n                sdLine(uv, t2, vec2(0.0)))), vec3(1.0, 0.0, 1.0));\n                \n                \n                 drawSDF(min(sdLine(uv, vec2(0.0), mouse.xy),\n            min(sdLine(uv, mouse.xy, t3),\n                sdLine(uv, t3, vec2(0.0)))), vec3(1.0, 0.0, 1.0));\n                \n                \n                                 drawSDF(min(sdLine(uv, vec2(0.0), mouse.xy),\n            min(sdLine(uv, mouse.xy, t4),\n                sdLine(uv, t4, vec2(0.0)))), vec3(1.0, 0.0, 1.0));\n\n\n    // Tangents\n    drawSDF(sdInfLine(uv, mouse.xy, t1), vec3(1.0, 0.1, 0.0));\n    drawSDF(sdInfLine(uv, mouse.xy, t2), vec3(1.0, 0.1, 0.0));\n    drawSDF(sdInfLine(uv, mouse.xy, t3), vec3(1.0, 0.1, 0.0));\n    drawSDF(sdInfLine(uv, mouse.xy, t4), vec3(1.0, 0.1, 0.0));\n\n    // Point\n    drawSDF(sdDisc(uv, mouse.xy, 0.005), vec3(2.0));\n\n    fragColor = vec4(color, 2.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/NdlSD7.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "NdlSD8", "name": "Overstimulated Neurons", "author": "Chaotnix", "description": "Fork of \"Abstract Glassy Field\" by Shane. https://shadertoy.com/view/4ttGDH\n\n", "tags": ["raymarch", "refraction", "glass", "blob", "glow", "audioreactive", "soundcloud"], "likes": 5, "viewed": 306, "date": "1618608170", "time_retrieved": "2024-06-20T20:37:49.779852", "image_code": "// Fork of \"Abstract Glassy Field\" by Shane. https://shadertoy.com/view/4ttGDH\n\n\n/*\n\n\tAbstract Glassy Field\n\t---------------------\n\n\tAn abstract, blobby-looking field - rendered in the style of hot, glowing glass. It was \n\tproduced using cheap low-budget psuedoscience. :)\n\n\tThe surface was constructed with a spherized sinusoidal function, of sorts. I like it, because \n\tit's very cheap to produce, mildly reminiscent of noise and allows a camera to pass through it \n\twithout having to resort to trickery.\n\n\tThe fluid filled glass look is fake, but at least interesting to look at. Basically, it was\n\tproduced by indexing the reflected and refracted surface rays into a 3D tri-planar texture\n\tlookup. By the way, I've tried the real thing on this particular surface - with multiple ray \n\tbounces and so forth - and to say it's slower is an understatement. :)\n\n\tBy the way, if anyone is aware of some cheap and simple improvements, corrections, etc, feel\n\tfree to let me know.\n\n*/\n\n#define FAR 50. // Far plane, or maximum distance.\n\n//float objID = 0.; // Object ID\n\nfloat accum; // Used to create the glow, by accumulating values in the raymarching function.\n\n// 2x2 matrix rotation. Note the absence of \"cos.\" It's there, but in disguise, and comes courtesy\n// of Fabrice Neyret's \"ouside the box\" thinking. :)\nmat2 rot2( float a ){ vec2 v = sin(vec2(1.570796, 0) - a);\treturn mat2(v, -v.y, v.x); }\n\n\n// Tri-Planar blending function. Based on an old Nvidia writeup:\n// GPU Gems 3 - Ryan Geiss: https://developer.nvidia.com/gpugems/GPUGems3/gpugems3_ch01.html\nvec3 tpl( sampler2D t, in vec3 p, in vec3 n ){\n    \n    n = max(abs(n) - .2, 0.001);\n    n /= dot(n, vec3(1));\n\tvec3 tx = texture(t, p.zy).xyz;\n    vec3 ty = texture(t, p.xz).xyz;\n    vec3 tz = texture(t, p.xy).xyz;\n    \n    // Textures are stored in sRGB (I think), so you have to convert them to linear space \n    // (squaring is a rough approximation) prior to working with them... or something like that. :)\n    // Once the final color value is gamma corrected, you should see correct looking colors.\n    return (tx*tx*n.x + ty*ty*n.y + tz*tz*n.z);\n}\n\n\n// Camera path.\nvec3 camPath(float t){\n  \n    //return vec3(0, 0, t); // Straight path.\n    //return vec3(-sin(t/2.), sin(t/2.)*.5 + 1.57, t); // Windy path.\n    \n    //float s = sin(t/24.)*cos(t/12.);\n    //return vec3(s*12., 0., t);\n    \n    float a = sin(t * 0.11);\n    float b = cos(t * 0.14);\n    return vec3(a*4. -b*1.5, b*1.7 + a*1.5, t);\n    \n}\n\n\n// A fake, noisy looking field - cheaply constructed from a spherized sinusoidal\n// combination. I came up with it when I was bored one day. :) Lousy to hone in\n// on, but it has the benefit of being able to guide a camera through it.\n/*\nfloat map(vec3 p){\n \n    p.xy -= camPath(p.z).xy; // Perturb the object around the camera path.\n    \n     \n\tp = cos(p*.315*1.25 + sin(p.zxy*.875*1.25)); // 3D sinusoidal mutation.\n    \n    \n    float n = length(p) + 0.001* texture(iChannel0, p.xy ).x ; // Spherize. The result is some mutated, spherical blob-like shapes.\n\n    // It's an easy field to create, but not so great to hone in one. The \"1.4\" fudge factor\n    // is there to get a little extra distance... Obtained by trial and error.\n    return (n - 1.025)*2.33;\n    \n}\n*/\n\n\n// Alternative, even more abstract, field.\nfloat map(vec3 p){\n    \n    p.xy -= camPath(p.z).xy; // Perturb the object around the camera path.\n   \n\tp = cos(p*.1490 + sin(p.zxy*.4375)); // 3D sinusoidal mutation.\n    \n    // Spherize. The result is some mutated, spherical blob-like shapes.\n    float n = dot(p, p); \n    \n    p = sin(p*3.+cos(p.yzx*12.)); // Finer bumps. Subtle.\n    \n    return (n - p.x*p.y*p.z*.35 - .9)*1.33 + 0.001 * texture(iChannel0, p.xy ).x ; // Combine, and we're done.\n    \n}\n\n\n\n// I keep a collection of occlusion routines... OK, that sounded really nerdy. :)\n// Anyway, I like this one. I'm assuming it's based on IQ's original.\nfloat cao(in vec3 p, in vec3 n)\n{\n\tfloat sca = 1., occ = 0.;\n    for(float i=0.; i<5.; i++){\n    \n        float hr = .01 + i*.35/4.;        \n        float dd = map(n * hr + p);\n        occ += (hr - dd)*sca;\n        sca *= 0.7;\n    }\n    return clamp(1.0 - occ, 0.3, 1.);    \n}\n\n\n// Standard normal function. It's not as fast as the tetrahedral calculation, but more symmetrical.\nvec3 nr(vec3 p){\n\n\tconst vec2 e = vec2(0.002, 0);\n\treturn normalize(vec3(map(p + e.xyy) - map(p - e.xyy), \n                          map(p + e.yxy) - map(p - e.yxy), map(p + e.yyx) - map(p - e.yyx)));\n}\n\n\n\n// Basic raymarcher.\nfloat trace(in vec3 ro, in vec3 rd){\n    \n    accum = 0.;\n    float t = 0.0, h;\n    for(int i = 0; i < 128; i++){\n    \n        h = map(ro+rd*t);\n        // Note the \"t*b + a\" addition. Basically, we're putting less emphasis on accuracy, as\n        // \"t\" increases. It's a cheap trick that works in most situations... Not all, though.\n        if(abs(h)<0.001*(t*.25 + 1.) || t>FAR) break; // Alternative: 0.001*max(t*.25, 1.)\n        t += h;\n        \n        // Simple distance-based accumulation to produce some glow.\n        if(abs(h)<.35) accum += (.35-abs(h))/24.;\n        \n    }\n\n    return min(t, FAR);\n}\n\n\n// Shadows.\nfloat sha(in vec3 ro, in vec3 rd, in float start, in float end, in float k){\n\n    float shade = 1.0;\n    const int maxIterationsShad = 24; \n\n    float dist = start;\n    float stepDist = end/float(maxIterationsShad);\n\n    for (int i=0; i<maxIterationsShad; i++){\n        float h = map(ro + rd*dist);\n        //shade = min(shade, k*h/dist);\n        shade = min(shade, smoothstep(0.0, 1.0, k*h/dist));\n\n        dist += clamp(h, 0.01, 0.2);\n        \n        // There's some accuracy loss involved, but early exits from accumulative distance function can help.\n        if (abs(h)<0.001 || dist > end) break; \n    }\n    \n    return min(max(shade, 0.) + 0.4, 1.0); \n}\n\n\n// Texture bump mapping. Four tri-planar lookups, or 12 texture lookups in total.\nvec3 db( sampler2D tx, in vec3 p, in vec3 n, float bf){\n   \n    const vec2 e = vec2(0.001, 0);\n    \n    // Three gradient vectors rolled into a matrix, constructed with offset greyscale texture values.    \n    mat3 m = mat3( tpl(tx, p - e.xyy, n), tpl(tx, p - e.yxy, n), tpl(tx, p - e.yyx, n));\n    \n    vec3 g = vec3(0.299, 0.587, 0.114)*m; // Converting to greyscale.\n    g = (g - dot(tpl(tx,  p , n), vec3(0.299, 0.587, 0.114)) )/e.x; g -= n*dot(n, g);\n                      \n    return normalize( n + g*bf ); // Bumped normal. \"bf\" - bump factor.\n\t\n}\n\n// Compact, self-contained version of IQ's 3D value noise function. I have a transparent noise\n// example that explains it, if you require it.\nfloat n3D(vec3 p){\n    \n\tconst vec3 s = vec3(7, 157, 113);\n\tvec3 ip = floor(p); p -= ip; \n    vec4 h = vec4(0., s.yz, s.y + s.z) + dot(ip, s);\n    p = p*p*(3. - 2.*p); //p *= p*p*(p*(p * 6. - 15.) + 10.);\n    h = mix(fract(sin(h)*43758.5453), fract(sin(h + s.x)*43758.5453), p.x);\n    h.xy = mix(h.xz, h.yw, p.y);\n    return mix(h.x, h.y, p.z); // Range: [0, 1].\n}\n\n\n\n// Simple environment mapping.\nvec3 envMap(vec3 rd, vec3 n){\n    \n    vec3 col = tpl(iChannel0, rd*4., n);\n    return smoothstep(0.4, .7, col/2.);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    \n    \n\t// Screen coordinates.\n\tvec2 u = (fragCoord - iResolution.xy*.5)/iResolution.y;\n\t\n\t// Camera Setup.\n    float speed = 3.;\n    vec3 o = camPath(iTime*speed); // Camera position, doubling as the ray origin.\n    vec3 lk = camPath(iTime*speed + .25);  // \"Look At\" position.\n    vec3 l = camPath(iTime*speed + 2.) + vec3(0, 1, 0); // Light position, somewhere near the moving camera.\n\n\n    // Using the above to produce the unit ray-direction vector.\n    float FOV = 3.14159/2.; ///3. FOV - Field of view.\n    vec3 fwd = normalize(lk-o);\n    vec3 rgt = normalize(vec3(fwd.z, 0, -fwd.x )); \n    vec3 up = cross(fwd, rgt);\n\n    // Unit direction ray.\n    //vec3 r = normalize(fwd + FOV*(u.x*rgt + u.y*up));\n    // Lens distortion.\n    vec3 r = fwd + FOV*(u.x*rgt + u.y*up);\n    r = normalize(vec3(r.xy, (r.z - length(r.xy)*.125)));\n\n\n    // Raymarch.\n    float t = trace(o, r);\n    \n    // Save the object ID directly after the raymarching equation, since other equations that\n    // use the \"map\" function will distort the results. I leaned that the hard way. :)\n    //float sObjID = objID;\n\n    // Initialize the scene color to the background.\n    vec3 col = vec3(0);\n    \n    // If the surface is hit, light it up.\n    if(t<FAR){\n    \n        // Position.\n        vec3 p = o + r*t;\n\t\t\n        // Normal.\n        vec3 n = nr(p);\n        \n        // Sometimes, it's handy to keep a copy of the normal. In this case, I'd prefer the\n        // bumps on the surface to not have as much influence on the reflrection and \n        // refraction vectors, so I tone down the bumped normal with this. See the reflection\n        // and refraction lines.\n        vec3 svn = n;\n        \n        // Texture bump the normal.\n        float sz = 1./3.; \n        n = db(iChannel0, p*sz, n, .1/(1. + t*.25/FAR));\n\n        l -= p; // Light to surface vector. Ie: Light direction vector.\n        float d = max(length(l), 0.001); // Light to surface distance.\n        l /= d; // Normalizing the light direction vector.\n\n        \n        float at = 1./(1. + d*.05 + d*d*.0125); // Light attenuation.\n        \n        // Ambient occlusion and shadowing.\n        float ao =  cao(p, n);\n        float sh = sha(p, l, 0.04, d, 16.);\n        \n        // Diffuse, specular, fresnel. Only the latter is being used here.\n        float di = max(dot(l, n), 0.);\n        float sp = pow(max( dot( reflect(r, n), l ), 0.), 64.); // Specular term.\n        float fr = clamp(1.0 + dot(r, n), .0, 1.); // Fresnel reflection term.\n \n         \n        \n        // Texturing - or coloring - the surface. The \"color\"' of glass is provide by the surrounds...\n        // of it's contents, so just make it dark.\n        vec3 tx = vec3(.05); // tpl(vec3(0.,0.,0.), p*sz, n);\n         \n\n\t\t// Very simple coloring.\n        col = tx*(di*.1 + ao*.25) + vec3(.5, .7, 1)*sp*2. + vec3(1, .7, .4)*pow(fr, 8.)*.25;\n \n        // Very cheap, and totally fake, reflection and refraction. Obtain the reflection and\n        // refraction vectors at the surface, then pass them to the environment mapping function.\n        // Note that glass and fluid have different refractive indices, so I've fudged them into \n        // one figure.\n        //vec3 refl = envMap(normalize(reflect(r, svn*.5 + n*.5)), svn*.5 + n*.5);\n        //vec3 refr = envMap(normalize(refract(r, svn*.5 + n*.5, 1./1.35)), svn*.5 + n*.5);\n        \n        \n\t\t// You can also index into a 3D texture, but I prefer the above.\n        vec3 refl = texture(iChannel0, 0.2* normalize(reflect(r, svn*.5 + n*.5)).xy).xyz;\n        vec3 refr = texture(iChannel0, 0.2* normalize(refract(r, svn*.5 + n*.5, 1./1.31)).xy).xyz;\n        refl *= refl*.3;\n        refr *= refr*.4;\n        \n        \n        // More fake physics that looks like real physics. :) Mixing the reflection and refraction \n        // colors according to a Fresnel variation.\n        vec3 refCol = mix(refr, refl, pow(fr, 5.)); //(refr + refl)*.5; // Adding them, if preferred.\n        \n        // Obviously, the reflected\\refracted colors will involve lit values from their respective\n        // hit points, but this is fake, so we're just combining it with a portion of the surface \n        // diffuse value.\n        col += refCol*((di*di*.25+.75) + ao*.25)*1.5; // Add the reflected color. You could combine it in other ways too.\n        \n        // Based on IQ's suggestion: Using the diffuse setting to vary the color slightly in the\n        // hope that it adds a little more depth. It also gives the impression that Beer's Law is \n        // taking effect, even though it clearly isn't. I might try to vary with curvature - or some other\n        // depth guage - later to see if it makes a difference.\n        col = mix(col.xzy, col, di*.85 + .15); \n        \n        // Glow.\n        // Taking the accumulated color (see the raymarching function), tweaking it to look a little\n        // hotter, then combining it with the object color.\n        vec3 accCol = vec3(1, .3, .1)*accum;\n        vec3 gc = pow(min(vec3(1.5, 1, 1)*accum, 1.), vec3(1, 2.5, 12.))*.5 + accCol*.5;\n        col += col*gc*12.;\n        \n        \n        // Purple electric charge.\n        float hi = abs(mod(t/1. +  0.02 * texture(iChannel0, p.xy ).x, 8.) - 8./2.)*2.;\n        vec3 cCol = vec3(.01, .05, 1)*col*1./(.001 + hi*hi*.2);\n        col += mix(cCol.yxz, cCol, n3D(p*3.));\n \t\t// Similar effect.\n        //vec3 cCol = vec3(.01, .05, 1)*col*abs(tan(t/1.5 + iTime/3.));\n        //col += cCol;\n \n        \n        // Apply some shading.\n        col *= ao*sh*at;\n\n        \n    }\n    \n    \n    // Blend in a bit of light fog for atmospheric effect.\n    vec3 fog = vec3(.125, .04, .05)*(r.y*.5 + .5);    \n    col = mix(col, fog, smoothstep(0., .95, t/FAR)); // exp(-.002*t*t), etc. fog.zxy\n\n    \n    // Subtle vignette.\n    u = fragCoord/iResolution.xy;\n    col = mix(vec3(0), col, pow( 16.0*u.x*u.y*(1.0-u.x)*(1.0-u.y) , .125)*.5 + .5);\n\n \n    \n    // Rough gamma correction, and we're done.\n    fragColor = vec4(sqrt(clamp(col, 0., 1.)), 1);\n    \n    \n}", "image_inputs": [{"id": "4tfSzB", "previewfilepath": "https://soundcloud.com/lyfsuxx/iwannabeyourgirlfriend", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0, "src": "https://soundcloud.com/lyfsuxx/iwannabeyourgirlfriend", "ctype": "musicstream"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/NdlSD8.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "NdlSDn", "name": "rotate and translate", "author": "leopard", "description": "I had huge problems with rotate and couldn't find any tutorial that would show how to move multiple objects, so had to try by my self, tested multiple different rotation functions from jcant0n and IQ, I found 'jcantos' 's was easier to use.\n", "tags": ["kokeilu"], "likes": 1, "viewed": 48, "date": "1618516559", "time_retrieved": "2024-06-20T20:37:49.785951", "image_code": "#define MAX_STEPS 100\n#define MAX_DIST 100.\n#define SURF_DIST 0.02\n#define PI 3.1415\n\n//from https://www.shadertoy.com/view/llsSWr\nvec2 rotate( vec2 vector, float angle )\n{\n\tvec2 sincos = vec2( sin(angle), cos(angle) );\n\treturn vec2( vector.x * sincos.y - vector.y * sincos.x, \n\t\t\t\tvector.x * sincos.x + vector.y * sincos.y );\n}\n\n\n//from IQ\nvec3 rotateY( in vec3 p, float t )\n{\n    float co = cos(t);\n    float si = sin(t);\n    p.xz = mat2(co,-si,si,co)*p.xz;\n    return p;\n}\n\n\nvec3 translate(vec3 p, vec3 t)\n{\n\treturn p - t;\n}\n\n\n\nfloat dBox(vec3 p, vec3 s){\n\n    return length(max(abs(p)-s,0.));\n}\n\nfloat GetDist(vec3 p) {\n    \n\n    float planeDist = p.y+2.;\n\n    float dist_to_0=8.; //center of car rotates around 0.0 with this distance\n    \n    //grp_translate sets group placement\n    vec3 grp_translate = vec3(sin(iTime)*dist_to_0, 0, cos(iTime)*dist_to_0);\n    float grp_angle  = iTime+PI/2.;\n    \n    float dist_to_center=8.;\n    float rengas =3.;\n    float text_tmp;\n    \n    //car body\n    vec3 q = p;\n    q=translate(q,grp_translate);\n    q.xz=rotate(q.xz,grp_angle);\n    q=translate(q,vec3(0,1,0));\n    float body = dBox(q-vec3(0.0, 0.0, 0.),vec3(1,1,5));\n    text_tmp = abs(dot(sin(q*6.),cos(q.yzx*6.))); //texture\n    body-=text_tmp*0.1;\n\n    \n    q = p;\n    q=translate(q,grp_translate);\n    q.xz=rotate(q.xz,grp_angle);\n    q=translate(q,vec3(2,0,2));\n    q.yz=rotate(q.yz,-grp_angle*rengas);//right front wheel rotation\n    float bd1 = dBox(q-vec3(0., 0.0, 0.),vec3(1));\n    text_tmp = abs(dot(sin(q*6.),cos(q.xzy*6.))); //texture\n    bd1-=text_tmp*0.1;\n    \n    q = p;\n    q=translate(q,grp_translate);\n    q.xz=rotate(q.xz,grp_angle);\n    q=translate(q,vec3(-2,0,2));\n    q.yz=rotate(q.yz,-grp_angle*rengas*1.5);//left front wheel rotation\n    float bd2 = dBox(q-vec3(0., 0.0, 0.),vec3(1));\n    text_tmp = abs(dot(sin(q*6.),cos(q.xzy*6.))); //texture\n    bd2-=text_tmp*0.1;\n    \n    q = p;\n    q=translate(q,grp_translate);\n    q.xz=rotate(q.xz,grp_angle);\n    q=translate(q,vec3(2,0,-2));\n    q.yz=rotate(q.yz,-grp_angle*rengas); //right rear wheel rotation\n    float bd3 = dBox(q-vec3(0., 0.0, 0.),vec3(1));\n    text_tmp = abs(dot(sin(q*6.),cos(q.xzy*6.))); //texture\n    bd3-=text_tmp*0.1;\n    \n    q = p;\n    q=translate(q,grp_translate);\n    q.xz=rotate(q.xz,grp_angle);\n    q=translate(q,vec3(-2,0,-2));\n    q.yz=rotate(q.yz,-grp_angle*rengas*1.5); //left rear wheel rotation\n    float bd4 = dBox(q-vec3(0., 0.0, 0.),vec3(1));\n    text_tmp = abs(dot(sin(q*6.),cos(q.xzy*6.))); \n    bd4-=text_tmp*0.1;\n\n    q = p;\n    //q=translate(q,group);\n    //q.xz=rotate(q.xz,kulma);\n    q=translate(q,vec3(0,0,0));\n    float palikka = dBox(q-vec3(0., 0.0, 0.),vec3(1,1,1));\n    \n    float d = planeDist;\n    \n    d = min(d, body*0.6); \n    d = min(d, bd1);\n    d = min(d, bd2);\n    d = min(d, bd3);\n    d = min(d, bd4);\n    d = min(d, palikka);\n    \n    return d;\n}\n\nfloat RayMarch(vec3 ro, vec3 rd) {\n\tfloat dO=0.;\n    \n    for(int i=0; i<MAX_STEPS; i++) {\n    \tvec3 p = ro + rd*dO;\n        float dS = GetDist(p);\n        dO += dS;\n        if(dO>MAX_DIST || dS<SURF_DIST) break;\n    }\n    \n    return dO;\n}\n\nvec3 GetNormal(vec3 p){\n    float d = GetDist(p);\n    vec2 e = vec2(0.01,0);\n    \n    vec3 n = d - vec3(\n        GetDist(p-e.xyy),\n        GetDist(p-e.yxy),\n        GetDist(p-e.yyx));\n        \n        return normalize(n);\n}\n\nfloat GetLight(vec3 p){\n    \n    vec3 lightPos = vec3(4,5,-2);\n\n    vec3 l = normalize(lightPos-p);\n    vec3 n = GetNormal(p);\n\n    float dif = clamp(dot(n,l),0.,1.);\n\n    float d = RayMarch(p+n*SURF_DIST*1.5,l);\n\n\n    if(d<length(lightPos-p)){\n        dif *=0.7;\n    }\n\n    return dif;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    vec2 uv = (fragCoord -.5*iResolution.xy)/iResolution.y;\n    \n    vec3 col = vec3(0);\n\n    vec3 ro = vec3(0.,3,-17);\n    vec3 rd = normalize(vec3(uv.x,uv.y,1.));\n    \n    float d = RayMarch(ro,rd);\n    \n    vec3 p = ro+rd*d;\n    \n    float dif = GetLight(p);\n    col = vec3(dif);\n    \n    col += 0.2* GetNormal(p);\n\n    // Output to screen\n    fragColor = vec4(col,0.4);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/NdlSDn.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "NdlXD7", "name": "Steep Waves", "author": "lmno", "description": "Pink, or Honey?", "tags": ["2d", "wave", "stripe"], "likes": 0, "viewed": 27, "date": "1618708628", "time_retrieved": "2024-06-20T20:37:50.458488", "image_code": "\n\n// The MIT License\n// Copyright © 2019 Miguel \"Codax\" Nieves\n// Twitter: @GameDevMig\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n\n#define PI 5.28209265359\n\n//Inigo Quilez's Palette Function\n//https://www.shadertoy.com/view/ll2GD3\nvec3 pal( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d )\n{\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    //How many stripes to show (even works best)\n    float stripes = 16.0;\n    //Wave Scroll Speed\n    float speed = 0.35;\n    \n    //Animated height of each wave from -1 to 1\n    float amplitude = sin(iTime * 1.0);\n    //float amplitude = (2.0 * abs( (2.0 * fract(iTime * 0.5))-1.0 ) - 1.0); //Triangle Wave\n    amplitude *= 0.68;//0.78;\n    \n    uv.y = uv.y * stripes;\n    uv.x = uv.x * 9.0;\n    \n    float waveID = round(uv.y);\n    \n    //Current Wave but cap the parts would overlap\n    vec2 waveUV = uv;\n    waveUV.x += iTime  * speed * (2.0 * step(1.0,mod(waveID,2.0)) - 1.);\n    waveUV.y += max(-0.5, min(0.5, sin(waveUV.x * PI * 2.0) * amplitude));\n\n\t//Use next line only if amplitude is between -0.5 and 0.5\n    //waveUV.y += sin(waveUV.x * PI * 2.0) * amplitude; \n    \n    //Hold on to the current Stripe value\n    float midWave = waveUV.y;\n    \n    //Calculate the Value from the Stripe Above\n    float upperWave = uv.x + ( iTime * speed * (2.0 * step(1.0,mod(waveID + 1.0,2.0)) - 1.));\n    upperWave = sin(upperWave * PI * 2.0) * amplitude;\n    \n    upperWave *= 1.0- step(0.5, fract(uv.y));\n    /*if (fract(uv.y) >= 0.5) //Optimized Out\n    {\n        upperWave = 0.0;\n    }*/\n                      \n\tupperWave += fract(uv.y);\n    upperWave = step(1.0, upperWave);\n    \n    //Calculate the Value from the Strip Below\n    float lowerWave = uv.x + ( iTime * speed * (2.0 * step(1.0,mod(waveID - 1.0,2.0)) - 1.));\n    lowerWave = sin(lowerWave * PI * 2.0) * amplitude;\n    \n    lowerWave *= step(0.5, fract(uv.y));\n    /*if (fract(uv.y) < 0.5) //Optimized Out\n    {\n        lowerWave = 0.0;\n    }\n\t*/\n    lowerWave += fract(uv.y);\n    lowerWave = step(0.00, lowerWave);\n\n\n    //Mix and Overlap\n\tmidWave *= upperWave;\t//Use the Upperwave to first mask the mid wave\n    upperWave *= step(0.000,midWave - waveID); //Then overlap the upperwave by the midwave\n    \n    waveUV.y *= (1.0 - upperWave); //Mask out the upper Wave\n    waveUV.y += upperWave * (uv.y + 1.0); //Add in the upper \n    \n\twaveUV.y *= lowerWave;  //Mask out the lower wave from the \n    waveUV.y += (1.0 - lowerWave) * (uv.y - 1.0); //Put in the overlap from the lower wave\n\n   \n    //Create a color ID from 0.0 - 1.0\n    float colorID = floor( waveUV.y ) / stripes;\n    \n    float ct = iTime * 0.025;\n    //vec3 col = pal( colorID, vec3(0.5,0.5,0.5),vec3(0.5,0.5,0.5),vec3(2.0,1.0,1.0),vec3(0.4 * sin(ct*1.23),0.40 * cos(ct*2.14),0.80 * sin(-ct)) );\n    vec3 col = pal( colorID, vec3(1.5,0.5,1.0),vec3(0.5,0.5,1.0),vec3(2.0, 1.0, 0.0),vec3(0.2+sin(ct*1.23), 0.2+cos(ct*2.14), 0.1 + sin(-ct)));\n    \n    //Darken the bottom few waves\n    col *= smoothstep(1.0, 0.6, 1.0 - colorID);\n\n    // Wave Debug\n    //col = vec3(colorID);// * fract(uv.y));\n\n    // Output to screen \n    fragColor = vec4(col,2.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "mit", "thumbnail": "https://www.shadertoy.com/media/shaders/NdlXD7.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "NdS3Dy", "name": "Subsurface scattering hw9", "author": "abenkov", "description": "subsurface scattering ", "tags": ["subsurfacescattering"], "likes": 0, "viewed": 33, "date": "1617936935", "time_retrieved": "2024-06-20T20:37:52.434515", "image_code": "const int RAY_STEPS = 256;\nconst float HALF_PI = 3.14159 * 0.5;\n\n\n// Adjust these to alter where the subsurface glow shines through and how brightly\nconst float FIVETAP_K = 2.0;\nconst float AO_DIST = 0.085;\n\n// The larger the DISTORTION, the smaller the glow\nconst float DISTORTION = 0.8;\n// The higher GLOW is, the smaller the glow of the subsurface scattering\nconst float GLOW = 1.0;\n// The higher the BSSRDF_SCALE, the brighter the scattered light\nconst float BSSRDF_SCALE = 5.0;\n// Boost the shadowed areas in the subsurface glow with this\nconst float AMBIENT = 0.2;\n// Toggle this to affect how easily the subsurface glow propagates through an object\n#define ATTENUATION 0\n\n#define LIGHT_POS vec3(0.0, 7.45, 0.0)\n\n#define CENTER vec3(3.0, 6.0, 0.0)\n#define RADIUS 3.0\n\n#define BACK_WALL 0\n#define LEFT_WALL 1\n#define FLOOR 2\n#define SMALL_BOX 3\n#define SPHERE 4\n\nfloat random1(vec2 p) {\n  return fract(sin(dot(p, vec2(456.789, 20487145.123))) * 842478.5453);\n}\n\nvec2 random2( vec2 p ) {\n    return fract(sin(vec2(dot(p, vec2(127.1, 311.7)),\n                 dot(p, vec2(269.5,183.3))))\n                 * 43758.5453);\n}\n\nfloat random3( vec3 p ) {\n  return fract(sin(dot(p, vec3(127.1, 311.7, 191.999))) * 43758.5453);\n}\n\nfloat WorleyNoise(vec2 uv) {\n    uv *= 6.5; // Now the space is 10x10 instead of 1x1. Change this to any number you want.\n    vec2 uvInt = floor(uv);\n    vec2 uvFract = fract(uv);\n    float minDist = 1.0; // Minimum distance initialized to max.\n    for(int y = -1; y <= 1; ++y) {\n        for(int x = -1; x <= 1; ++x) {\n            vec2 neighbor = vec2(float(x), float(y)); // Direction in which neighbor cell lies\n            vec2 point = random2(uvInt + neighbor); // Get the Voronoi centerpoint for the neighboring cell\n            vec2 diff = neighbor + point - uvFract; // Distance between fragment coord and neighbor’s Voronoi point\n            float dist = length(diff);\n            minDist = min(minDist, dist);\n        }\n    }\n    return minDist;\n}\n\nvec3 palette( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d )\n{\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\nfloat surflet(vec3 p, vec3 gridPoint) {\n    // Compute the distance between p and the grid point along each axis, and warp it with a\n    // quintic function so we can smooth our cells\n    vec3 t2 = abs(p - gridPoint);\n    vec3 t = vec3(1.0) - 6.0 * pow(t2, vec3(5.0)) + 15.0 * pow(t2, vec3(4.0)) - 10.0 * pow(t2, vec3(3.0));\n    // Get the random vector for the grid point (assume we wrote a function random2\n    // that returns a vec2 in the range [0, 1])\n    vec3 gradient = random3(gridPoint) * 2.0 - vec3(1.0, 1.0, 1.0);\n    // Get the vector from the grid point to P\n    vec3 diff = p - gridPoint;\n    // Get the value of our height field by dotting grid->P with our gradient\n    float height = dot(diff, gradient);\n    // Scale our height field (i.e. reduce it) by our polynomial falloff function\n    return height * t.x * t.y * t.z;\n}\n\n\nfloat perlinNoise3D(vec3 p) {\n    float surfletSum = 0.f;\n  \n    for(int dx = 0; dx <= 1; ++dx) {\n        for(int dy = 0; dy <= 1; ++dy) {\n            for(int dz = 0; dz <= 1; ++dz) {\n                surfletSum += surflet(p, floor(p) + vec3(dx, dy, dz));\n            }\n        }\n    }\n    return surfletSum;\n}\n\n\n\nstruct Intersection\n{\n    float t;\n    vec3 color;\n    vec3 p;\n    int object;\n};\n\nvec3 rotateX(vec3 p, float amt) {\n    return vec3(p.x, cos(amt) * p.y - sin(amt) * p.z, sin(p.y) + cos(p.z));\n}\n    \nvec3 rotateY(vec3 p, float a) {\n    return vec3(cos(a) * p.x + sin(a) * p.z, p.y, -sin(a) * p.x + cos(a) * p.z);\n}\n\nvoid raycast(vec2 uv, out vec3 dir, out vec3 eye, out vec3 ref) {\n    eye = vec3(10.0, 8.0, -12.0);\n    ref = vec3(0.0, 6.0, 0.0);\n    \n    float len = tan(3.14159 * 0.125) * distance(eye, ref);\n    vec3 H = normalize(cross(vec3(0.0, 1.0, 0.0), ref - eye));\n    vec3 V = normalize(cross(H, eye - ref));\n    V *= len;\n    H *= len * iResolution.x / iResolution.y;\n    vec3 p = ref + uv.x * H + uv.y * V;\n    dir = normalize(p - eye);\n}\n\n\nfloat box(vec3 p, vec3 b)\n{\n  return length(max(abs(p) - b, 0.0));\n}\n\n\nfloat plane( vec3 p, vec4 n )\n{\n  return dot(p,n.xyz) + n.w;\n}\n\nfloat sphere(vec3 p, float r, vec3 c)\n{\n    return distance(p, c) - r;\n}\n\n\n#define BACK_WALL_SDF plane(pos, vec4(0.0, 0.0, -1.0, 10.0))\n#define LEFT_WALL_SDF plane(pos, vec4(1.0, 0.0, 0.0, 5.0))\n#define FLOOR_SDF plane(pos, vec4(0.0, 1.0, 0.0, 2.5))\n#define SMALL_BOX_SDF box(rotateY(pos + vec3(-4, 1, 2), -17.5 * 3.14159 / 180.0), 0.5 * vec3(8.0, 8.0, 8.0))\n#define SPHERE_SDF sphere(pos, RADIUS, CENTER)\n\nfloat interpNoise2D(float x, float y) {\n    int intX = int(floor(x));\n    float fractX = fract(x);\n    int intY = int(floor(y));\n    float fractY = fract(y);\n\n    float v1 = random1(vec2(intX, intY));\n    float v2 = random1(vec2(intX + 1, intY));\n    float v3 = random1(vec2(intX, intY + 1));\n    float v4 = random1(vec2(intX + 1, intY + 1));\n\n    float i1 = mix(v1, v2, fractX);\n    float i2 = mix(v3, v4, fractX);\n    return mix(i1, i2, fractY);\n}\n\nfloat mySmootherStep(float a, float b, float t) {\n  t = t*t*t*(t*(t*6.0 - 15.0) + 10.0);\n  return mix(a, b, t);\n}\n\nfloat interpNoise2D2(vec2 p) {\n  vec2 pFract = fract(p);\n  float llb = random1(floor(p));\n  float lrb = random1(floor(p) + vec2(1.0,0.0));\n  float ulb = random1(floor(p) + vec2(0.0,1.0));\n  float urb = random1(floor(p) + vec2(1.0,1.0));\n\n  float llf = random1(floor(p) + vec2(0.0,0.0));\n  float lrf = random1(floor(p) + vec2(1.0,0.0));\n  float ulf = random1(floor(p) + vec2(0.0,1.0));\n  float urf = random1(floor(p) + vec2(1.0,1.0));\n\n  float lerpXLB = mySmootherStep(llb, lrb, pFract.x);\n  float lerpXHB = mySmootherStep(ulb, urb, pFract.x);\n  float lerpXLF = mySmootherStep(llf, lrf, pFract.x);\n  float lerpXHF = mySmootherStep(ulf, urf, pFract.x);\n\n  float lerpYB = mySmootherStep(lerpXLB, lerpXHB, pFract.y);\n  float lerpYF = mySmootherStep(lerpXLF, lerpXHF, pFract.y);\n\n  return mySmootherStep(lerpYB, lerpYF, pFract.y);\n}\n\nfloat fbm(float x, float y) {\n    float total = 0.0;\n    float persistence = 3.1;\n    float octaves = 4.0;\n\n    for(float i = 1.0; i <= octaves; i++) {\n        float freq = pow(1.1, i);\n        float amp = pow(persistence, i);\n        total += interpNoise2D2(vec2(x * freq,\n                               y * freq)) * amp;\n    }\n    return total + 3.0 * cos(0.5 * iTime);\n}\n\nfloat fbm2(vec2 p, float octaves) {\n  float amp = 0.5;\n  float freq = 8.0;\n  float sum = 0.0;\n  float maxSum = 0.0;\n  for(float i = 0.0; i < 10.0; ++i) {\n    if(i == octaves)\n    break;\n    maxSum += amp;\n    sum += interpNoise2D2(vec2(p.x * freq, p.y * freq)) * amp;\n    amp *= 0.5;\n    freq *= 2.0;\n  }\n  return sum / maxSum;\n}\n\n\nfloat sceneMap3D(vec3 pos)\n{\n    float t = BACK_WALL_SDF;\n    t = min(t, LEFT_WALL_SDF);\n    t = min(t, FLOOR_SDF);\n    t = min(t, SMALL_BOX_SDF);\n    t = min(t, SPHERE_SDF);\n    return t;\n}\n\n\nvoid sceneMap3D(vec3 pos, out float t, out int obj)\n{\n    t = BACK_WALL_SDF;\n    float t2;\n    obj = BACK_WALL; \n    if((t2 = LEFT_WALL_SDF) < t) {\n        t = t2;\n        obj = LEFT_WALL; \n    }\n    if((t2 = FLOOR_SDF) < t) {\n        t = t2;\n        obj = FLOOR; \n    }\n    if((t2 = SMALL_BOX_SDF) < t) {\n        t = t2;\n        obj = SMALL_BOX; \n    }\n    if((t2 = SPHERE_SDF) < t) {\n        t = t2;\n        obj = SPHERE; \n    }\n}\n\nvoid march(vec3 origin, vec3 dir, out float t, out int hitObj, vec3 lightPos)\n{\n    t = 0.001;\n    for(int i = 0; i < RAY_STEPS; ++i)\n    {\n        vec3 pos = origin + t * dir;\n    \tfloat m;\n        sceneMap3D(pos, m, hitObj);\n        if(m < 0.01)\n        {\n            return;\n        }\n        t += m;\n    }\n    t = -1.0;\n    hitObj = -1;\n}\n\nvec3 computeNormal(vec3 pos)\n{\n    vec3 epsilon = vec3(0.0, 0.001, 0.0);\n    return normalize( vec3( sceneMap3D(pos + epsilon.yxx) - sceneMap3D(pos - epsilon.yxx),\n                            sceneMap3D(pos + epsilon.xyx) - sceneMap3D(pos - epsilon.xyx),\n                            sceneMap3D(pos + epsilon.xxy) - sceneMap3D(pos - epsilon.xxy)));\n}\n\n\nfloat fiveTapAO(vec3 p, vec3 n, float k) {\n    float aoSum = 0.0;\n    for(float i = 0.0; i < 5.0; ++i) {\n        float coeff = 1.0 / pow(2.0, i);\n        aoSum += coeff * (i * AO_DIST - sceneMap3D(p + n * i * AO_DIST));\n    }\n    return 1.0 - k * aoSum;\n}\n\nfloat subsurface(vec3 lightDir, vec3 normal, vec3 viewVec, float thickness) {\n    vec3 scatteredLightDir = lightDir + normal * DISTORTION;\n    float lightReachingEye = pow(clamp(dot(viewVec, -scatteredLightDir), 0.0, 1.0), GLOW) * BSSRDF_SCALE;\n    float attenuation = 1.0;\n    #if ATTENUATION\n    attenuation = max(0.0, dot(normal, lightDir) + dot(viewVec, -lightDir));\n    #endif\n\tfloat totalLight = attenuation * (lightReachingEye + AMBIENT) * thickness;\n    return totalLight;\n}\n\nvec3 computeMaterial(int hitObj, vec2 uv, vec3 pos, vec3 n, vec3 light, vec3 view, float thick) {\n    float t;\n    switch(hitObj) {\n        case 0:\n        // Back wall\n        float n1 = WorleyNoise(uv);\n        vec3 a1 = vec3(0.5, 0.5, 0.5);\n        vec3 b1 = vec3(0.5, 0.5, 0.5);\n        vec3 c1 = vec3(1.0, 0.7, 0.4);\n        vec3 d1 = vec3(0.00, 0.15, 0.20);\n        return palette(n1, a1, b1, c1, d1);\n        break;\n        case 1:\n        // Left wall\n        float n2 = WorleyNoise(uv);\n        vec3 a2 = vec3(0.5, 0.5, 0.5);\n        vec3 b2 = vec3(0.5, 0.5, 0.5);\n        vec3 c2 = vec3(1.0, 1.0, 0.5);\n        vec3 d2 = vec3(0.80, 0.90, 0.30);\n        return palette(n2, a2, b2, c2, d2);\n        break;\n        case 2:\n        // Floor\n        float k = WorleyNoise(uv);\n        vec3 a = vec3(0.5, 0.5, 0.5);\n        vec3 b = vec3(0.5, 0.5, 0.5);\n        vec3 c = vec3(1.0, 1.0, 1.0);\n        vec3 d = vec3(0.00, 0.33, 0.67);\n        return palette(k, a, b, c, d);\n        break;\n        case 3:\n        // Small box\n        float p = perlinNoise3D(pos);\n        vec3 a3 = vec3(0.8, 0.5, 0.4);\n        vec3 b3 = vec3(0.2, 0.4, 0.2);\n        vec3 c3 = vec3(2.0, 1.0, 1.0);\n        vec3 d3 = vec3(0.00, 0.25, 0.25);\n        return palette(p, a3, b3, c3, d3);\n        break;\n        case 4:\n        //Sphere\n        vec3 center = vec3(12.0, 6.0, -5.0);\n        float radius = 3.0;\n        vec3 pMap = (pos - center) / radius;\n        float uMap = (atan(pMap.x / pMap.z) + 3.14159) / (3.14159 * 2.0);\n        float vMap = (pMap.y + 1.0) / 2.0;\n        //float f = fbm(uMap, vMap);\n        //float f = fbm(uMap * 2.0 * sin(1.5 * iTime), vMap + 0.5 * cos(0.5 * iTime));\n        float f = fbm(uMap, vMap);\n        vec3 a4 = vec3(0.02, 0.25, 0.45);\n        vec3 b4 = vec3(0.5, 0.5, 0.5);\n        vec3 c4 = vec3(1.0, 0.2, 0.5);\n        vec3 d4 = vec3(0.00, 0.25, 0.65);\n        return palette(f, a4, b4, c4, d4) + vec3(0.67, 1.0, 1.0) * subsurface(light, n, view, thick) * vec3(1.0, 0.88, 0.7);;\n        break;\n    }\n    return vec3(1.0);\n}\n\n\nIntersection sdf3D(vec3 dir, vec3 eye, vec3 lightPos, vec2 uv)\n{\n    float t;\n    int hitObj;\n    march(eye, dir, t, hitObj, lightPos);\n    \n    if(t == -1.0) {\n        return Intersection(t, vec3(0.0, 0.0, 0.0), vec3(eye + 1000.0 * dir), -1);\n    }\n\n    vec3 isect = eye + t * dir;\n    vec3 nor = computeNormal(isect);\n    vec3 lightDir = normalize(lightPos - isect);\n    \n    float thickness = fiveTapAO(isect, -nor, FIVETAP_K);\n    \n    vec3 surfaceColor = computeMaterial(hitObj, uv, isect, nor, lightDir, normalize(eye - isect), thickness);\n    \n    return Intersection(t, surfaceColor, isect, hitObj);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    vec2 uv2 = 2.0 * uv - vec2(1.0);\n    \n    \n    Intersection aaIsects[16];\n    vec3 dir, eye, ref;\n    int idx = 0;\n    for(float i = 0.0; i < 1.0; i += 0.25) {\n        for(float j = 0.0; j < 1.0; j += 0.25) {\n            raycast(uv2 + vec2(i, j) / iResolution.xy, dir, eye, ref);\n            aaIsects[idx++] = sdf3D(dir, eye, LIGHT_POS, uv);\n        }\n    }\n    vec3 avgColor = vec3(0.0);\n    for(int i = 0; i < 16; ++i) {\n        avgColor += aaIsects[i].color;\n    }\n    avgColor *= 0.0625;\n  \n    // Output to screen\n    fragColor = vec4(avgColor * step(0.0, aaIsects[0].t), 1.0);\n    float fogT = smoothstep(30.0, 50.0, distance(aaIsects[0].p, eye));\n    fragColor.rgb = mix(fragColor.rgb, vec3(0.0), fogT);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/NdS3Dy.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "NdS3WG", "name": "logic n", "author": "4eckme", "description": "logic n", "tags": ["2d", "kaleidoscope", "fraktal"], "likes": 1, "viewed": 26, "date": "1617848043", "time_retrieved": "2024-06-20T20:37:52.434515", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 coord = fragCoord - (iResolution.xy / vec2(2.0));\n   \tcoord *= sqrt(iTime);\n    float x = float(coord.x);\n    float y = float(coord.y);\n    float r2 = float(int(abs(x*x+y*y)));\n    float r3 = abs(float(int(abs(x*x)-abs(y*y))));\n    int a = int(floor(r2*pow(16.0, 6.0-ceil(log2(r2)/4.0))));\n    int b = int(floor(r3*pow(16.0, 6.0-ceil(log2(r2)/4.0))));\n    int c = b^a; \n    fragColor = vec4(\n        float((c >> 16) & 255) / 255.0,\n        float((c >> 8) & 255) / 255.0,\n        float((c >> 0) & 255) / 255.0,\n        1.0\n    );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/NdS3WG.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "NdS3WW", "name": "The Monolith, 1x4x9", "author": "mrange", "description": "The Monolith", "tags": ["raytracing3d"], "likes": 9, "viewed": 170, "date": "1617371541", "time_retrieved": "2024-06-20T20:37:53.531316", "image_code": "// License CC0: The monolith, 1x4x9\n\n#define TOLERANCE         0.0001\n#define TIME              iTime\n#define RESOLUTION        iResolution\n#define ROT(a)            mat2(cos(a), sin(a), -sin(a), cos(a))\n#define L2(x)             dot(x, x)\n#define PCOS(x)           (0.5 + 0.5*cos(x))\n#define SKYCOLOR(ro, rd)  skyColor(ro, rd)\n\nconst float miss          = 1E4;\nconst float refrIndex     = 0.8;\nconst vec3  lightPos      = 2.0*vec3(1.5, 2.0, 1.0);\n\nconst vec3 skyCol1        = vec3(0.2, 0.4, 0.6);\nconst vec3 skyCol2        = vec3(0.4, 0.7, 1.0);\nconst vec3 sunCol         =  vec3(8.0,7.0,6.0)/8.0;\n\nconst vec3 boxDim         = vec3(1.0, 9.0, 4.0)/18.0;\nconst vec4 plane          = vec4(vec3(0.0, 1.0, 0.0), 0.5);\n\nfloat tanh_approx(float x) {\n//  return tanh(x);\n  float x2 = x*x;\n  return clamp(x*(27.0 + x2)/(27.0+9.0*x2), -1.0, 1.0);\n}\n\n// IQ's polynominal min\nfloat pmin(float a, float b, float k) {\n  float h = clamp(0.5+0.5*(b-a)/k, 0.0, 1.0);\n  \n  return mix(b, a, h) - k*h*(1.0-h);\n}\n\n// https://stackoverflow.com/questions/15095909/from-rgb-to-hsv-in-opengl-glsl\nvec3 hsv2rgb(vec3 c) {\n  const vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n  vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n  return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\n// IQ's ray sphere intersection\nvec2 raySphere(vec3 ro, vec3 rd, vec4 s) {\n    vec3 ce = s.xyz;\n    float ra = s.w;\n    vec3 oc = ro - ce;\n    float b = dot( oc, rd );\n    float c = dot( oc, oc ) - ra*ra;\n    float h = b*b - c;\n    if( h<0.0 ) return vec2(miss); // no intersection\n    h = sqrt( h );\n    return vec2( -b-h, -b+h );\n}\n\n// IQ's ray box intersection\nvec2 rayBox(vec3 ro, vec3 rd, vec3 boxSize, out vec3 outNormal )  {\n    vec3 m = 1.0/rd; // can precompute if traversing a set of aligned boxes\n    vec3 n = m*ro;   // can precompute if traversing a set of aligned boxes\n    vec3 k = abs(m)*boxSize;\n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n    float tN = max( max( t1.x, t1.y ), t1.z );\n    float tF = min( min( t2.x, t2.y ), t2.z );\n    if( tN>tF || tF<0.0) return vec2(miss); // no intersection\n    outNormal = -sign(rd)*step(t1.yzx,t1.xyz)*step(t1.zxy,t1.xyz);\n    return vec2( tN, tF );\n}\n\nfloat rayPlane(vec3 ro, vec3 rd, vec4 p ) {\n  return -(dot(ro,p.xyz)+p.w)/dot(rd,p.xyz);\n}\n\nvec3 postProcess(vec3 col, vec2 q)  {\n  col=pow(clamp(col,0.0,1.0),vec3(1.0/2.2)); \n  col=col*0.6+0.4*col*col*(3.0-2.0*col);  // contrast\n  col=mix(col, vec3(dot(col, vec3(0.33))), -0.4);  // satuation\n  col*=0.5+0.5*pow(19.0*q.x*q.y*(1.0-q.x)*(1.0-q.y),0.7);  // vigneting\n  return col;\n}\n\nvec3 skyColor(vec3 ro, vec3 rd) {\n  const vec3 sunDir = normalize(lightPos);\n  float sunDot = max(dot(rd, sunDir), 0.0);  \n  vec3 final = vec3(0.);\n\n  final += mix(skyCol1, skyCol2, rd.y);\n  final += 0.5*sunCol*pow(sunDot, 20.0);\n  final += 4.0*sunCol*pow(sunDot, 400.0);    \n\n  float tp  = rayPlane(ro, rd, plane);\n  if (tp > 0.0) {\n    vec3 pos  = ro + tp*rd;\n    vec3 ld   = normalize(lightPos - pos);\n    vec3 snor;\n    vec2 rb   = rayBox(pos, ld, boxDim, snor);\n    vec3 spos = pos + ld*rb.x;\n    float it  = rb.y - rb.x;\n    // Extremely fake soft shadows\n    float sha = rb.x == miss ? 1.0 : (1.0-1.0*tanh_approx(it*6.0/(0.1+rb.x)));\n    vec3 nor  = vec3(0.0, 1.0, 0.0);\n    vec3 icol = 1.5*skyCol1 + 4.0*sunCol*sha*dot(-rd, nor);\n    vec2 ppos = pos.xz*0.75+0.23;\n    ppos = fract(ppos+0.5)-0.5;\n    float pd  = min(abs(ppos.x), abs(ppos.y));\n    vec3  pcol= mix(vec3(0.4), vec3(0.3, 0.3, 0.3), exp(-60.0*pd));\n\n    vec3 col  = icol*pcol;\n    col = clamp(col, 0.0, 1.25);\n    float f   = exp(-10.0*(max(tp-10.0, 0.0) / 100.0));\n    return mix(final, col , f);\n  } else{\n    return final;\n  }\n}\n\n\nvec3 innerRender(vec3 ro, vec3 rd, vec3 enor) {\n  const float spr = 0.25;\n\n  vec3 spc = vec3(-enor*spr);\n  vec4 sp  = vec4(spc, spr);\n  vec2 rs = raySphere(ro,rd, sp);\n  vec3 bhsv = vec3(fract(0.05*TIME+dot(enor, rd)*2.0), 0.5, 1.0);\n  vec3 bcol = hsv2rgb(bhsv);\n\n  vec3 col = vec3(0.0);\n  \n  if (rs.x < miss) {\n    float t = rs.x;\n    vec3 pos = ro + rd*t;\n    vec3 nor = normalize(pos - sp.xyz);\n    vec3 ld   = normalize(lightPos - pos);\n    float dif = pow(max(dot(nor,ld),0.0), 2.0);\n    float l   = dif;\n    float lin = mix(0.005, 1.0, l);\n    float itd = rs.y - rs.x;\n    col += lin*bcol;\n    col = mix(col, vec3(0.0), tanh_approx(1E-3/(itd*itd)));\n  }\n\n  return col;\n}\n\nvec3 render(vec3 ro, vec3 rd) {\n  vec3 skyCol = SKYCOLOR(ro, rd);\n  vec3 col = vec3(0.0);\n\n  float t   = 1E6;\n  vec3 nor;\n  vec2 rb = rayBox(ro, rd, boxDim, nor);  \n\n  if (rb.x < miss) {\n    t = rb.x;\n    float itd = rb.y - rb.x;\n    vec3 pos  = ro + t*rd;\n    vec3 anor = abs(nor);\n    vec2 tp   = anor.x == 1.0 ? pos.yz : (anor.y == 1.0 ? pos.xz : pos.xy);\n    vec2 bd   = anor.x == 1.0 ? boxDim.yz : (anor.y == 1.0 ? boxDim.xz : boxDim.xy);\n    vec3 refr = refract(rd, nor, refrIndex);\n    vec3 refl = reflect(rd, nor);\n    vec3 rcol = SKYCOLOR(pos, refl);\n    float fre = mix(0.0, 1.0, pow(1.0-dot(-rd, nor), 3.0));\n    vec3 ld   = normalize(lightPos - pos);\n    float dif = pow(max(dot(nor,ld),0.0), 3.0);\n    float spe = pow(max(dot(reflect(-ld, nor), -rd), 0.), 50.);\n    float lin = mix(0.0, 1.0, dif);\n    vec3 lcol = 2.0*sqrt(sunCol);\n\n    col = innerRender(pos, refr, nor);\n\n    vec2 btp = (1.0*bd - abs(tp));\n    float bdd = pmin(btp.x, btp.y, 0.0125);    \n    float bddd = exp(-10000.0*bdd*bdd);\n//    col += vec3(0.5, 0.5, 1.0)*bddd*10;\n    col *= 1.0 - bddd;\n\n    vec3 diff = hsv2rgb(vec3(0.7, fre, 0.075*lin))*lcol;\n    col += fre*rcol+diff+spe*lcol;\n    if (refr == vec3(0.0)) {\n      // Not expected to happen as the refraction index < 1.0\n      col = vec3(1.0, 0.0, 0.0);\n    }\n    \n    col = mix(col, skyCol, tanh_approx(1E-5/(itd*itd)));\n  } else {\n    // Ray intersected sky\n    return skyCol;\n  }\n\n  return col;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  vec2 q = fragCoord.xy/RESOLUTION.xy; \n  vec2 p = -1.0 + 2.0*q;\n  p.x *= RESOLUTION.x/RESOLUTION.y;\n\n  const float mul = 0.05;\n  float mm = mix(0.25, 0.5, PCOS(TIME*mul*sqrt(3.0)));\n  vec3 ro = mm*vec3(2.0, 0, 0.2);\n  ro.xz *= ROT((TIME*mul));\n  ro.yz *= ROT(sin(TIME*mul*sqrt(0.5))*0.5);\n  ro += vec3(0.0, mm, 0.0);\n\n  vec3 ww = normalize(vec3(0.0, 0.0, 0.0) - ro);\n  vec3 uu = normalize(cross( vec3(0.0,1.0,0.0), ww));\n  vec3 vv = normalize(cross(ww,uu));\n  const float rdd = 2.00;\n  vec3 rd = normalize( p.x*uu + p.y*vv + rdd*ww);\n\n  vec3 col = render(ro, rd);\n  fragColor = vec4(postProcess(col, q),1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc0-1.0", "thumbnail": "https://www.shadertoy.com/media/shaders/NdS3WW.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "NdSGDt", "name": "Clock Soup Vortex", "author": "Pelegefen", "description": "Add thyme...\n\nProbably not the best way to tell the time...\nThe clocks are set anyway though!", "tags": ["clock", "wip", "soup"], "likes": 8, "viewed": 243, "date": "1618091402", "time_retrieved": "2024-06-20T20:37:53.531560", "image_code": "\n// number of layers to render, go over 3.5 only if you have a strong GPU! \n// min is 1.1\n#define NUM_LAYERS 3.5\n\n#define S smoothstep \n#define PI 3.14159265359\n#define TAU 6.283185307179586\n#define RES iResolution.xy\n\n\n\nfloat Hash21(vec2 n){\n\n   return fract(sin(dot(n.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\n\nvec3 ShapeN(vec2 st, int N, float w, float h){\n\n  vec3 color = vec3(0.0);\n  float d = 0.0;\n\n  // Remap the space to -1. to 1.\n  st = st *2.-1.;\n  st.x += 1.0 ;\n  st.y += .7;\n  st.y /= h;\n    st.x *= w;\n  // Number of sides of your shape\n  //int N = 3;\n\n  // Angle and radius from the current pixel\n  float a = atan(st.x,st.y)+PI;\n  float r = TAU/float(N);\n\n  // Shaping function that modulates the distance\n  d = cos(floor(.5+a/r)*r-a)*length(st);\n\n  color = vec3(smoothstep(.41,.4,d));\n\n    return color;\n}\nvec2 polarMap(vec2 uv, float shift, float inner) {\n\n    uv = vec2(0.5) - uv;\n    \n    \n    float px = 1.0 - fract(atan(uv.y, uv.x) / 6.28 + 0.25) + shift;\n    float py = (length(uv) * (1.0 + inner * 2.0) - inner) * 2.0;\n    \n    return vec2(px, py);\n}\nvec2 rot (vec2 p,float a)\n{\n    float c = cos(a);\n    float s = sin(a);\n    return p*mat2(c,s,-s,c);\n}\nfloat circle (vec2 p, float r, float g)\n{\n\n    float d = length(p / r);\n\n    float ss = S(.32,.32 - g,d);\n    \n    ss = max(0.,ss);\n    return ss;\n\n}\nfloat segment(vec2 P, vec2 A, vec2 B, float r) \n{\n    vec2 g = B - A;\n    vec2 h = P - A;\n    float d = length(h - g * clamp(dot(g, h) / dot(g,g), 0.0, 1.0));\n\treturn smoothstep(r, 0.7*r, d);\n}\nfloat segmentT(vec2 P, vec2 A, vec2 B, float r, float dr) \n{\n    vec2 g = B - A;\n    vec2 h = P - A ;\n    float d = length(h - g * clamp(dot(g , h ) / dot(g,g), 0.0, 1.0));\n    \n\n\treturn smoothstep(r, 0.7*r, d);\n}\n\n\n\nvec4 Hand(vec2 uv , float l, float w, float t)\n{\n    vec4 col = vec4(0.);\n    \n\n    float h = segmentT(uv,vec2(0,0.),rot(vec2(0.,.8 * l)  ,t * TAU/60.  ) , \n    1. * RES.y/RES.x * w, .5);\n    \n    uv *= .35;\n    vec4 shape = vec4(ShapeN(rot( uv * 1.5, -t* TAU/60.) , 5,/* Width*/6.,/* Height*/ l - .2),1.);\n    col += shape;\n    col *=  h + shape;\n    \n    \n    //uv *= 2.;\n    vec4 Triangle = vec4(ShapeN(rot( uv * 3., -t* TAU/60.) , 5,/* Width*/9.,/* Height*/ l - .2),1.);\n    col += Triangle ;\n   \n    \n    \n    col.a = col.r;// at this point, each of the rgb vals is at 1. and showing the mask, so store it in the A channel.\n    \n    col = max (col,vec4(0.));\n    return col;\n}\n\nvec4 HandsShadow(vec2 uv , float l, float w, float t , float b)\n{\n    vec4 col = vec4(0.);\n    \n\n    float h = segmentT(uv,vec2(0,0.),rot(vec2(0.,.8 * l)  ,t * TAU/60.  ) , \n      w, .5);\n    uv.y += .02;\n    uv *= .35;\n    vec4 shape = vec4(ShapeN(rot( uv * 1.5, -t* TAU/60.) , 5,/* Width*/6. * w,/* Height*/ l - .2),1.);\n    col += shape;\n    col *=  h + shape;\n    \n    \n    //uv *= 2.;\n    vec4 Triangle = vec4(ShapeN(rot( uv * 3., -t* TAU/60.) , 5,/* Width*/4. * w,/* Height*/ l - .2),1.);\n    col += Triangle ;\n    col = mix(Triangle, shape, .5);\n    \n    \n    col -= length(uv.y) * 2.; // attenuate based on height\n    \n    \n    \n    col = max (col,vec4(0.));\n    return col * .5;\n}\nvec4 Dial(vec2 uv, float m)\n{\n    \n    vec4 col = vec4(0.);\n    //uv.x = PolarCoord(uv);\n    \n    uv = polarMap(uv + .5, -.2486 , .25) * .5;\n    \n    uv.x = fract(uv.x * 24. * m ) ;\n    \n    \n    vec2 id = floor(uv * 24.  );\n    \n    float idF = (id.x / id.y);\n\n    col *= vec4(idF,idF,idF,1.)    ;\n    \n    col += circle(uv - vec2(0.,.5 ),1., .001 );\n    col += segment(uv / 60. * m ,vec2(0. ,0.0), vec2(6. ,2.),.01) * .5 ;\n    if(id.x <=  .5 && id.y <= 24.) return col = vec4(.35);\n    col += segment(uv,vec2(.0 ,0.9), vec2(.8 ,0.9),.1);\n    \n    \n    \n    float h = segment(uv,vec2(-.8 ,0.5),\n     vec2(.8 ,0.5),.2);\n    vec4 tx = texture(iChannel0,uv);\n    col +=  h; \n    col += col *  tx;\n    col = mix(col, tx, col) * .4;\n    \n    col = clamp(col,0.,1.);\n    return col;\n}\n\n\n//returns a working clock\nvec4 ClockFace(vec2 uv){\n\n    vec4 col = vec4(0.,0.,0.,1.);\n    \n    vec4 wt = texture(iChannel0,uv);// sample wood tex\n    float f = circle(uv,4.3, .001 );//clocks frame\n    float fm = 1. - (circle(uv,4.3, .025 ) );//clocks frame bevel\n    f -= fm;\n    col += f;\n    \n    //Decoration at 12 o'clock\n    col -= circle(uv + vec2(0.,-1.03),0.3, .001 ) * 0.5;\n    col += circle(uv + vec2(0.,-1.0),0.3, .5 );\n    col -= vec4(ShapeN(uv+vec2(0.,-.5) ,5  ,  5.15, 1.15 ),0.7) * .5;\n    col += circle(   uv + vec2(0.,-.8) ,0.1, .1 );\n    \n    \n    col = mix(col,wt,col - circle(uv,3.7, .001 ) * .9); // apply wood tex\n    \n    \n    col -= (circle(uv,3.6, .001 ) * .18) + (-uv.y * .2); //inset and shading\n    \n    // Shadow\n    float d = length(uv + vec2(0.,0.1 ))* 0.88;\n    float m = 1. - circle(uv,4.3,.0001);\n    m += circle(uv,3.7,.001);\n    m = 1. - m;\n    \n    col -=  smoothstep(0., pow(d,40.), m ) ;\n    \n    //col = vec4(m);\n     //add the dial and decoration\n    col -= Dial(uv/1.3, 1.);\n    col += Dial(uv , 1.5);\n    \n    \n    //---------- time is set here------------\n\n    vec4 iDate = iDate;\n    float mils = fract(iDate.w);\n\tfloat secs = mod( (iDate.w),        60.0 );\n\tfloat mins = mod( (iDate.w/60.0),   60.0 );\n\tfloat hors = mod( (iDate.w/3600.0), 24.0 );\n\n\n    vec4 ch1 = Hand(uv, 0.9,0.9, hors  * TAU * .8 );//hours hand\n    vec4 ch1m = Hand(uv, 0.6,0.1, hors  * TAU * .8 );//hours hand m\n    ch1 -= ch1m;\n    ch1 = clamp(ch1,0.,1.);\n    col -= ch1;\n    vec4 ch1s = HandsShadow(uv , 1.,.9, hors  * TAU * .8 , .5);\n    col -= ch1s;\n\n    vec4 ch2 = Hand(uv , 1.6,0.5, mins);//minutes hand\n    vec4 ch2m = Hand(uv, 1.3,0.1, mins);//minutes hand m\n    ch2 -= ch2m;\n    ch2 = clamp(ch2,0.,1.);\n    col -= ch2;\n    vec4 ch2s = HandsShadow(uv , 1.7,.7, mins , .5);\n    col -= ch2s;\n\n    vec4 ch3 = Hand(uv ,  2.0, .07 ,secs ); //secondes hand\n    vec4 ch3m = Hand(uv , 1.1, .05 ,secs ); //secondes hand m\n    ch3 -= ch3m;\n    \n\n    ch3 = clamp(ch3,0.,1.);\n    col -= ch3;\n    vec4 ch3s = HandsShadow(uv , 2.0,.8, secs , .5);\n    col -= ch3s;\n    \n    \n    vec4 tex1 = texture(iChannel0,(rot( uv * 2., -secs* TAU/60.)));\n    vec4 tex2 = texture(iChannel0,(rot( uv * 2., -mins* TAU/60.)));\n    vec4 tex3 = texture(iChannel0,(rot( uv * 2., -hors* TAU/60.)));// we also have to spin the texture per hand!\n  \n    col = mix (col, ch1 * tex3  , ch1) ;\n    col = mix (col,ch2 * tex2 ,ch2 ) ;\n    col = mix (col,ch3 * tex1 ,ch3 ) ;\n    \n    \n    //------------End of Time setting-----------------  \n    \n    float cc =  circle(uv,0.3, .001 ) ;//clocks hand cover\n    cc = ceil(cc);\n    \n    cc = max(cc,0.);\n    cc = min(cc,1.);\n    //col -= cc;\n    \n    col =  mix(cc * wt, col,1. -cc);\n    col += vec4(circle(uv,0.3, .2 ) * .3) *(fract( uv.y* 50. - .1)  ) ; // dot on the clock hand cover\n    \n    col -= circle(uv,3.7, .001 ) * .18;// glass cover\n    col += max((circle(uv,3.9, .05 ) * .3 * uv.y),0.);\n     m = 1. - circle(uv,4.3,.001);\n    col.a =  1.- m;\n    col = col - m;\n    col = max(vec4(0.),col);\n    return col;\n    \n}\n\n\n\nvec4 Layer(vec2 uv , float a)\n{\n    vec2 ouv = uv; //storing the original uvs.\n\n//if (uv.x >= 0.) uv.y += 0.5;\n    //uv.x = abs(uv.x);\n    uv.x +=  iTime * .001;\n    uv = rot(uv,a * 0.1);\n    vec2 buv = uv;\n    //buv.x = buv.x +sin( buv.y + iTime * .001);\n    \n    \n    buv *= cos(sin(  iTime * .0001)*.5+.5) * 5.;\n    vec2 mouse = iMouse.xy / iResolution.xy + .5;\n    buv *= 1.- mouse.x + 1.5;\n    \n    \n    buv = rot(buv,iTime * .0001);\n    \n    vec2 id = floor(buv);\n    vec2 fuv = fract(buv);\n    \n    buv = fuv;\n    vec4 col = vec4( 0.);\n    \n    \n    uv = buv;\n\n    \n    \n    //col -= max( 1. - length((uv + vec2(.0,.1))* .63), 0.) ;\n    vec4 cf = ClockFace(uv*2.8 /Hash21(id * 3.)- 1.5);\n    \n    \n    cf *= vec4(Hash21(id + .3),Hash21(id+ .5),Hash21(id+ .7),1.) * 1.3;\n    cf = min(cf,vec4(1.));\n    //cf = clamp(cf,.3,.9);\n    col = mix(col,cf,cf.a);\n    \n    \n\n  \n    \n\n\ncol.a = ceil(col.a);\n//\nreturn col;\n\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord.xy -.5* iResolution.xy)/iResolution.y;\n    vec2 ouv = uv; //storing the original uvs.\n    vec4 col = vec4( 0.);\n     if (uv.x <= 0.) uv.y += .5;\n     if (uv.y <= 0.) uv.x += .5;\n    uv.x = abs(uv.x);\n    uv.y = abs(uv.y);\n    \n    uv.x += iTime * .01;\n    uv.y += iTime * .01;\n    vec4 bg = texture(iChannel1,uv * 1.);\n     bg *= vec4(.5,.5,1.,1.);\n     col += bg;\n     \n     \n      //black in the middle\n     \n    col -=  max(.5 - length((ouv.x) * 2.0),0.) ;\n    col -=  max(.5 - length((ouv.y) * 2.0),0.) ;\n     \n     for(float i = 0.;i < NUM_LAYERS;i += 1./NUM_LAYERS)\n     {\n      vec4 l1 = Layer(ouv / i * 2., iTime * i+ (4622.2* i));\n    \n      col = mix(col, l1, l1.a);\n     }\n     //vec4 l1 = Layer(ouv, iTime * .5);\n    \n     //col = mix(col, l1, l1.a);\n\n    \n    // vec4 l2 = Layer(ouv * .5, iTime * .3+ 4622.2);\n    \n    // col = mix(col, l2, l2.a);\n     \n    // vec4 l3 = Layer(ouv * .3, iTime * .2 + 42312.2);\n    \n    // col = mix(col, l3, l3.a);\n     \n     //vignette\n     col -= vec4(pow(length(ouv),4.) );\n  \n   \n\n    \n    fragColor = col;\n}", "image_inputs": [{"id": "XdfGRn", "previewfilepath": "/media/ap/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg", "ctype": "texture"}, {"id": "XsfGRn", "previewfilepath": "/media/ap/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/NdSGDt.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "NdSGWD", "name": "symplectic map (wrong)", "author": "envy", "description": "symplectic map warping pattern from: https://www.gregegan.net/SCIENCE/Symplectic/Symplectic.html\nCorrected version by mla which correctly preserves areas: https://www.shadertoy.com/view/fsjGWw", "tags": ["symplectic"], "likes": 1, "viewed": 27, "date": "1617379580", "time_retrieved": "2024-06-20T20:37:53.531560", "image_code": "#define PI 3.14159\n\n\nvec3 colorCircle(vec2 v, float R) {  \n    float r = length(v);\n    vec3 col = (r < R) ? vec3(R-r, r, 0) : vec3(0);\n    for (int i = 0; i < 4; ++i) {\n        float angle = float(i)*(PI/4.0);\n        vec2 cart = vec2(cos(angle), sin(angle));\n        float lenfromProj = length(dot(cart, v)*cart - v);\n        if(lenfromProj < 0.025) {\n            col = vec3(1, 1, 1);\n        }\n        bool b = abs(r-0.5) < 0.01 || abs(r-0.25) < 0.01;\n        if(b) {\n            col = vec3(0, 0, 1);\n        }\n    }\n    col = (r < R) ? col : vec3(0);\n    return col;\n}\n\nvec2 mapSymplectic(vec2 v) {\n    //fR(r, θ) = (√(R2 – r2), θ)\n    float r = abs(length(v));\n    float theta = atan(v.y, v.x);\n    \n    float R = 1.0;\n    return vec2(sqrt(R*R - r*r), theta);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    float aspect = iResolution.x / iResolution.y;\n    vec2 uv = fragCoord/iResolution.xy;\n    uv.x *= aspect;\n\n    vec2 center = vec2(.5, .5);\n    center.x *= aspect;\n    \n    vec2 v = (uv-center);\n    vec2 vMapped = mapSymplectic(v * 2.0);\n\n    vec3 col1 = colorCircle(v, 0.5);\n    vec3 col2 = colorCircle(vMapped * 0.25, 1.0);\n    \n    float sm = smoothstep(0., 1., smoothstep(0., 1., abs(sin(iTime*0.5))));\n    // Output to screen\n    fragColor = vec4(mix(col1, col2, sm), 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/NdSGWD.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "NdSGzV", "name": "What's going on?", "author": "EricClapton", "description": "Try to compute shadow using iq's function, weird things happened though..............", "tags": ["error"], "likes": 1, "viewed": 148, "date": "1617630809", "time_retrieved": "2024-06-20T20:37:53.531560", "image_code": "\n\nconst int MAX_MARCHING_STEPS = 255;\nconst float MIN_DIST = 0.0;\nconst float MAX_DIST = 100.0;\nconst float EPSILON = 0.0001;\n\nfloat dot2( in vec3 v ) { return dot(v,v); }\n\nfloat sphereSDF1(vec3 samplePoint) {\n    vec3 sft = vec3(0.6, 0.0, 0.0);\n    return length(samplePoint+sft) - 0.5;\n}\n\n\nfloat sdRoundBox( vec3 p, vec3 b, float r )\n{\n  vec3 sft = vec3(-1.5, 0.0, 0.0);\n  vec3 q = abs(p+sft) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0) - r;\n}\n\nfloat sdBoxFrame( vec3 p, vec3 b, float e )\n{\n  vec3 sft = vec3(0.8, 0.0, -1.5);\n  p = abs(p+sft)-b;\n  vec3 q = abs(p+e)-e;\n  return min(min(\n      length(max(vec3(p.x,q.y,q.z),0.0))+min(max(p.x,max(q.y,q.z)),0.0),\n      length(max(vec3(q.x,p.y,q.z),0.0))+min(max(q.x,max(p.y,q.z)),0.0)),\n      length(max(vec3(q.x,q.y,p.z),0.0))+min(max(q.x,max(q.y,p.z)),0.0));\n}\n\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec3 sft = vec3(-1.25, 0.0, -1.5);\n  p = p+sft;\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\n\n\nfloat sceneSDF(vec3 samplePoint) {\n    float res = sphereSDF1(samplePoint);\n    \n    vec3 b = vec3(0.4, 0.2, 0.2);\n    float tmp = sdRoundBox( samplePoint, b, 0.1);\n    if(tmp < res)res = tmp;\n    \n    tmp = sdBoxFrame( samplePoint, vec3(0.5, 0.5, 0.5), 0.05);\n    if(tmp < res)res = tmp;\n    \n    tmp = sdTorus( samplePoint, vec2(0.5, 0.1));\n    if(tmp < res)res = tmp;\n    \n    float ground = samplePoint.z + 1.5;\n    float ground2 = samplePoint.y + 0.5;\n    if(ground2 < res)res = ground2;\n    return min(res, ground);\n}\n\nfloat calcSoftshadow(vec3 samplePoint)\n{\n    float mint = 0.01;\n    float tmax = 3.0;\n\tfloat res = 1.0;\n    float t = mint;\n    float ph = 1e10; // big, such that y = 0 on the first iteration\n    \n    for( int i=0; i<32; i++ )\n    {\n\t\tfloat h = sceneSDF(samplePoint);\n\n        // traditional technique\n        \tres = min( res, 10.0*h/t );        \n        \n        t += h;\n        \n        if( res<0.0001 || t>tmax ) break;\n        \n    }\n    res = clamp( res, 0.0, 1.0 );\n    return res*res*(3.0-2.0*res);\n}\n\nfloat CastRay(vec3 eye, vec3 marchingDirection, float start, float end) {\n    float depth = start;\n    for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n        float dist = calcSoftshadow(eye + depth * marchingDirection);\n        if (dist < EPSILON) {\n\t\t\treturn depth;\n        }\n        depth += dist;\n        if (depth >= end) {\n            return end;\n        }\n    }\n    return end;\n}\n            \n\n\nvec3 rayDirection(float fieldOfView, vec2 size, vec2 fragCoord) {\n    vec2 xy = fragCoord - size / 2.0;\n    float z = size.y / tan(radians(fieldOfView) / 2.0);\n    return normalize(vec3(xy, -z));\n}\n\n\nvec3 estimateNormal(vec3 p) {\n    return normalize(vec3(\n        sceneSDF(vec3(p.x + EPSILON, p.y, p.z)) - sceneSDF(vec3(p.x - EPSILON, p.y, p.z)),\n        sceneSDF(vec3(p.x, p.y + EPSILON, p.z)) - sceneSDF(vec3(p.x, p.y - EPSILON, p.z)),\n        sceneSDF(vec3(p.x, p.y, p.z  + EPSILON)) - sceneSDF(vec3(p.x, p.y, p.z - EPSILON))\n    ));\n}\n\n\nvec3 phongContribForLight(vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye,\n                          vec3 lightPos, vec3 lightIntensity) {\n    vec3 N = estimateNormal(p);\n    vec3 L = normalize(lightPos - p);\n    vec3 V = normalize(eye - p);\n    vec3 R = normalize(reflect(-L, N));\n    \n    float dotLN = dot(L, N);\n    float dotRV = dot(R, V);\n    \n    if (dotLN < 0.0) {\n       \n        return vec3(0.0, 0.0, 0.0);\n    } \n    \n    if (dotRV < 0.0) {\n        \n        return lightIntensity * (k_d * dotLN);\n    }\n    return lightIntensity * (k_d * dotLN + k_s * pow(dotRV, alpha));\n}\n\n\nvec3 phongIllumination(vec3 k_a, vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye) {\n    const vec3 ambientLight = 0.8 * vec3(0.8, 0.8, 0.8);\n    vec3 color = ambientLight * k_a;\n    \n    vec3 light1Pos = vec3(4.0 * sin(iTime),\n                          2.0,\n                          4.0 * cos(iTime));\n    vec3 light1Intensity = vec3(0.2, 0.5, 0.8);\n    \n    color += phongContribForLight(k_d, k_s, alpha, p, eye,\n                                  light1Pos,\n                                  light1Intensity);\n    \n    vec3 light2Pos = vec3(2.0 * sin(0.37 * iTime),\n                          2.0 * cos(0.37 * iTime),\n                          2.0);\n    vec3 light2Intensity = vec3(0.9, 0.8, 0.5);\n    \n    color += phongContribForLight(k_d, k_s, alpha, p, eye,\n                                  light2Pos,\n                                  light2Intensity);    \n    return color;\n}\n\nmat4 viewMatrix(vec3 eye, vec3 center, vec3 up) {\n    // Based on gluLookAt man page\n    vec3 f = normalize(center - eye);\n    vec3 s = normalize(cross(f, up));\n    vec3 u = cross(s, f);\n    return mat4(\n        vec4(s, 0.0),\n        vec4(u, 0.0),\n        vec4(-f, 0.0),\n        vec4(0.0, 0.0, 0.0, 1)\n    );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\t//vec3 dir = rayDirection(45.0, iResolution.xy, fragCoord);\n\n    \n    vec3 viewDir = rayDirection(45.0, iResolution.xy, fragCoord);\n    vec3 eye = vec3(6.0*cos(iTime*0.5), 4.0, 8.0);\n    \n    mat4 viewToWorld = viewMatrix(eye, vec3(0.0, 0.0, 0.0), vec3(0.0, 1.0, 0.0));\n    \n    vec3 worldDir = (viewToWorld * vec4(viewDir, 0.0)).xyz;\n    \n    float dist = CastRay(eye, worldDir, MIN_DIST, MAX_DIST);\n    \n    if (dist > MAX_DIST - EPSILON) {\n\n        fragColor = vec4(0.0, 0.0, 0.0, 0.0);\n\t\treturn;\n    }\n    \n    vec3 p = eye + dist * worldDir;\n    \n    vec3 K_a = vec3(0.2, 0.2, 0.2);\n    vec3 K_d = vec3(0.2, 0.2, 0.2);\n    vec3 K_s = vec3(1.0, 1.0, 1.0);\n    float shininess = 10.0;\n    \n    vec3 color = phongIllumination(K_a, K_d, K_s, shininess, p, eye);\n    \n    fragColor = vec4(color + vec3(0.05,0.05,0.05), 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/NdSGzV.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "NdsSDj", "name": "year 3k Roundabouts", "author": "kastorp", "description": "maybe with hyperloop?", "tags": ["roundabout"], "likes": 8, "viewed": 109, "date": "1619281500", "time_retrieved": "2024-06-20T20:37:54.895422", "image_code": "// year 3K Roundabouts  by Kastorp\n//\n// trying to figure out how roundabouts would look like in a far future\n// \n//------------------------\nconst float N= 12.; // grid size 2--100\nconst float HEIGHT=1.; //1--3\n\n\n//-------------------IQ--------------------------\nvec2 boxIntersection( in vec3 ro, in vec3 rd, in vec3 rad) \n{\n    vec3 m = 1.0/rd;\n    vec3 n = m*ro;\n    vec3 k = abs(m)*rad;\n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n\n    float tN = max( max( t1.x, t1.y ), t1.z );\n    float tF = min( min( t2.x, t2.y ), t2.z );\n\t\n    if( tN>tF || tF<0.0) return vec2(-1.0); \n    \n    //vec3 normal = -sign(rd)*step(t1.yzx,t1.xyz)*step(t1.zxy,t1.xyz);\n\n    return vec2( tN, tF );\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xy)-t.x,p.z);\n  return length(q)-t.y;\n}\n\nfloat sdCapsuleV(in vec3 p, float h, float r )\n{\n  p.x -= clamp( p.x, 0.0, h );\n  return length( p ) - r;\n}\n\n//HASH\nfloat hash12(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\n//--------------------SHANE---------------------\n\n// Tri-Planar blending function. Based on an old Nvidia tutorial.\nvec3 tex3D( sampler2D tex, in vec3 p, in vec3 n ){\n  \n    n = max(abs(n), 0.001);//n = max((abs(n) - 0.2)*7., 0.001); //  etc.\n    n /= (n.x + n.y + n.z ); \n\tp = (texture(tex, p.yz)*n.x + texture(tex, p.zx)*n.y + texture(tex, p.xy)*n.z).xyz;\n    return p*p;\n}\n\n// Texture bump mapping. Four tri-planar lookups, or 12 texture lookups in total. I tried to \n// make it as concise as possible. Whether that translates to speed, or not, I couldn't say.\nvec3 doBumpMap( sampler2D tx, in vec3 p, in vec3 n, float bf){\n   \n    const vec2 e = vec2(0.001, 0);\n    \n    // Three gradient vectors rolled into a matrix, constructed with offset greyscale texture values.    \n    mat3 m = mat3( tex3D(tx, p - e.xyy, n), tex3D(tx, p - e.yxy, n), tex3D(tx, p - e.yyx, n));\n    \n    vec3 g = vec3(0.299, 0.587, 0.114)*m; // Converting to greyscale.\n    g = (g - dot(tex3D(tx,  p , n), vec3(0.299, 0.587, 0.114)) )/e.x; g -= n*dot(n, g);\n                      \n    return normalize( n + g*bf ); // Bumped normal. \"bf\" - bump factor.\n    \n}\n//--------------------------------------------------------------\nmat2 Rotate(in float a) {\n    float rad = radians(a);\n    float c = cos(rad), s = sin(rad);\n    return mat2(c, -s, s, c);\n}\n\nint gFrame=0; // unroll hack\nfloat shape=0.; //current voxel shape\nbool transp=false; // if true: ignore lanes\n#define mmin(a,b,c)  (a.x<b?a:vec2(b,c));\n\n// rendering based on shape:\n// -2 void\n// -1 vertical roundabout x\n// 0 horizontal roundabout \n// 1 vertical roundabout y\n// 2 terrain\n// 3 station\n// 4 building\nvec2 mapVoxel(in vec3 p0) {\n    \n    float tk=.025;\n    vec3 l =vec3(10.);   \n    vec3 p= (fract(p0)-.5);   \n    vec2 d =vec2(1e5,0.);\n    \n    if(shape>3.)   return vec2(sdCapsuleV(-p.zxy-vec3(.5,0,0),.0,.15),6.);\n    if(shape>2. )  return vec2(sdBox(p.zxy+vec3(0,0,0),vec3(.5))-sin((p.x+p.y+p.z)*30.)*.00001,6.);\n                    //return vec2(sdCapsuleV(-p.zxy-vec3(floor(p0.z)-1.5,0,0),2.5,.48), 6.);\n    else if(shape>1.) {\n        d=vec2(sdCapsuleV(p.zxy-vec3(.5,0,0),.5,.15),6.);\n        return mmin(d,sdBox(p+vec3(0,0,.05),vec3(.5,.5,1.5-floor(p0.z)-HEIGHT)),5.);\n    }\n    else if(shape>0.)   \n        p.xz *= Rotate(90.*  smoothstep( .5,.3,abs(p.y))); \n    else if (shape<0.) {\n        p.xy *= Rotate(90.*  smoothstep(.3,.5,abs(p.z))); \n        p.yz *= Rotate(90.*  smoothstep(.5,.3,abs(p.x))); \n    }   \n    \n    vec2 pos= abs(p.y)> abs(p.x)? p.yx:p.xy*vec2(1,-1);\n    float \n           //c1=sign(p.x*p.y*(p.x+p.y)*(p.x-p.y))>0.?3.: 2.,\n          c1=  abs(mod(iTime*4.*sign(pos.y),6.28)/6.28-pos.x-.5)<.015?4.:1. , \n          c2=abs( -mod(atan(p.x,p.y),3.14) -mod(iTime*4.,3.14)+3.14)<.1 ?4.:1.,\n          c3= abs(mod(iTime*4.*sign(shape<0.? p.x: shape>0.?-p.y: p.y),6.28)/6.28-p.z-.5)<.015?4.:1. ; \n    \n    if(!transp){\n        d=mmin(d,sdTorus(p,vec2(.1,tk*1.2)),c2);\n\n        p=abs(p);\n         d=mmin(d,sdCapsuleV(p.yxz-vec3(.1, tk*1.5,0.) ,.4,tk),c1);\n         d=mmin(d,sdCapsuleV(p-vec3(.1,tk*1.5,0.) ,.4,tk),c1 );\n         d=mmin(d,sdCapsuleV((shape<0.? p.zyx:p.zxy )-vec3(.0,0.,tk*1.5) ,.5,tk),c3);\n    }\n    \n    return vec2(d.x*.8,  d.y);\n}\n\nvec3 getNormal(in vec3 p) {\n    vec3 n=vec3(0.);\n    vec3 e =vec3(0.001,0,0);\n    for(int i=gFrame;i<=2;i++){       \n        for(float j=-1.;j<=1.;j+=2.) n+= j*e* mapVoxel(p + j* e).x ;\n        e=e.zxy; //TdHopper trick\n    }\n    return normalize(n);\n}\n\nvec3 rayDirection(vec3 cameraDir, vec2 uv){\n    \n    vec3 cameraPlaneU = vec3(normalize(vec2(cameraDir.y, -cameraDir.x)), 0);\n    vec3 cameraPlaneV = cross(cameraPlaneU, cameraDir) ;\n\treturn normalize(cameraDir + uv.x * cameraPlaneU + uv.y * cameraPlaneV);\n\n}\n\nvec4 rayCast(vec3 ro,vec3 rd,bool sh)\n{       \n    //RAYTRACING BOUNDING BOX    \n    vec3 bb =  vec3(N,N,6.)*.5 ;    \n    vec2 tb= boxIntersection(  ro,  rd, bb ) ;\n    if(tb.y<0.) return vec4(0.);\n    \n    //VOXEL TRAVERSAL\n    vec3 rs= sign(rd);\n    vec3 ri = 1./rd;\n\tvec3 rp0 =ro +  max(tb.x,0.)*rd,rp=rp0; \n    \n    vec3 mp=floor(rp);\n    vec3 sd = (mp-rp + 0.5 + rs*0.5) *ri;\n    vec3 mask=vec3(0.);    \n    \n    for (int i = gFrame; i < (sh?70:200); i++) {\n        \n        if(i>0){            \n            mask = step(sd, sd.yzx)*(1.-step(sd.zxy, sd)); \n            sd += mask *  rs *ri;\n            mp += mask *  rs;\n            vec3 mini = (mp-rp + 0.5 - 0.5*vec3(rs))*ri;\n            float t1=  max ( mini.x, max ( mini.y, mini.z ) );\n             rp= t1*rd+rp ;\n        }\n        if(length(rp-ro)>=tb.y-.01) break; //outside bounding box\n        \n        shape =mod(mp.x+mp.y+mp.z,3.)-1.;\n        if(mp.z<2. -HEIGHT ) shape=2.;\n        else if(hash12(mp.xy)>.9) shape=3.;//   if(max(mod(mp.x,4.),mod(mp.y,4.) )<1.) shape= 3.;\n        else if(hash12(mp.xz*.7-.5)>.9) shape=3.;//   if(max(mod(mp.x,4.),mod(mp.y,4.) )<1.) shape= 3.;\n        else if(hash12(mp.yz*.8+1.)>.9) shape=3.;//   if(max(mod(mp.x,4.),mod(mp.y,4.) )<1.) shape= 3.;\n        else if(mp.z>2.) shape=-2.;\n        else if(mp.z>1.) shape=4.;\n        \n        if(shape>-2.)  {\n            \n            //SDF RAYTRACING INSIDE VOXEL\n            float t2 = 0.0001;          \n            for (int iters=gFrame; iters < 60; iters++) {\n                \n                vec3 p = rp + rd * t2;\n\n                if(sdBox(p-mp-.5,vec3(.5))>0.) break;\n               \n                vec2 d = mapVoxel(p);\n                if (d.x < 0.0001) return vec4(p,d.y);\n \n                t2 += d.x;\n            }\n        }\n\t} \n    return vec4(tb.x,tb.y,0.,0.);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n    vec2  m =  iMouse.x<=0. ? sin(vec2(1,2)*iTime*.1)*.6: (iMouse.xy - 0.5 * iResolution.xy) / iResolution.y*3.14;\n\n    \n    gFrame=min(iFrame,0);\n\n    vec3 ro = vec3(sin(m.y*.5+.76) * cos(-m.x), sin(m.y*.5+.76) * sin(-m.x), cos(m.y*.5 +.76))*10.;\n    vec3 cd = -normalize(ro);    \n    vec3 rd = rayDirection(cd ,uv);\n    \n    vec4[4] rr;\n     int nr=0;\n    vec3 ro_=ro, rd_=rd;\n    bool tranp=false;\n    for(int i=gFrame; i<2;i++) {    \n        rr[i]= rayCast(ro_,rd_,false);\n        nr=i;\n        if(rr[i].w!= 6. && rr[i].w!= 1. ) break;\n        \n        ro_ =rr[i].xyz;\n        vec3 no=getNormal(ro_);\n        if(rr[i].w == 6. && mod(ro_.z-.45,1.)>.1) {rd_ = reflect(rd_,no); ro_ +=rd_*0.002; }\n        if(rr[i].w == 1.)  {\n            if(dot(rd_,no)<-.8)  {transp=true; rd_ = refract(rd_,no,.9);} \n            else {rd_ = reflect(rd,no); ro_ +=rd_*0.002;}\n        }\n    }\n \n    vec3 rgb =vec3(0.3,0.3,0.6); //sky\n    if(rr[0].a>0.){\n               vec3 p =rr[0].xyz, p2= rr[nr].xyz,\n                 n = getNormal(p),n2=getNormal(p2); \n                 \n              float mat = rr[nr].a;\n              if(mat==5.) n= doBumpMap( iChannel0, p2*.25, n2, 0.08);\n              rgb= mat>5.? vec3(0.1):  //building\n                  mat>4. && n.z>.5? tex3D(iChannel0, p*.25, n).bgr*vec3(.2,1.,.2):  //grass\n                  mat>4.? tex3D(iChannel0, p*.25, n).bgr*vec3(.9,.5,.2):  //grass\n                  mat>3.? vec3(1.,1.,.1):  //vehicle\n                  mat>2.? vec3(.3,0.3,0.6): //inbound\n                  mat>1.? vec3(.6,.3,0.3):  //outbound \n                  mat>0.? vec3(.4): //lane\n                  rgb; //sky\n                 \n             if( rr[0].a==6.) rgb=mix(rgb,vec3(.0),.8); //darkenize if reflected\n             if( rr[0].a==1.) rgb=mix(rgb,vec3(.9),.5); //semitransparent tubes             \n               \n             vec3 l=normalize(vec3(.4,.3,1)); //sun direction           \n             float shading=1.;            \n             vec4 s= rayCast(p+n*.0002 ,l,true);  //cast shadow\n             shading *= step(0., -s.a)*.3 + .7;\n                     \n             if(rr[0].a==6. && rr[nr].a>0.) n=n2; //use target normal if reflected\n             float ambience = (mat ==4. ? .7: 0.25)  ;\n             float diff = max( dot(n, l), 0.0);\n             float spec = rr[0].a==6.|| shading<.9 || mat==5.?0.: pow(max( dot( reflect(-l, n), -rd ), 0.0 ), 32.);\n             \n             rgb = rgb*(diff + ambience)+ vec3(.7, .9, 1.)*spec;            \n             rgb *= shading;  \n             \n             // rgb = mix(rgb,vec3(0.3,0.3,0.6),clamp(exp(-max(N,22.)*.7+ length(rr[0].xyz-ro) ),0.,1.)); //fog\n            \n    }\n    \n    fragColor = vec4(pow(rgb,vec3(.7)),1.);\n    \n}\n", "image_inputs": [{"id": "4sXGRn", "previewfilepath": "/media/ap/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/NdsSDj.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "NdsSDM", "name": "Running Interference ", "author": "bignobody", "description": "Started as an attempt to make an Archimedes Spiral and ended up here.", "tags": ["interference"], "likes": 2, "viewed": 61, "date": "1618702359", "time_retrieved": "2024-06-20T20:37:54.895422", "image_code": "float as(vec2 uv, float v, float w)\n{\n    float t = length(uv);\n    float wt = w * t;\n    float vt = v * t;\n    vec2 s = vec2 ( ( vt + uv.x ) * cos(wt), (vt + uv.y) * sin(wt) );\n    return length(s);\n    \n}\n\nfloat spr(vec2 uv)\n{\n    return (((smoothstep(as(uv, 0.01, 20.0*(sin(iTime*0.1)*10.0)), 0.001, 0.2)*1.75)-1.0)*-1.0);\n}\n\nmat2 rot(float a)\n{\n\treturn mat2(cos(a),-sin(a),sin(a),cos(a));    \n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy)/iResolution.y;\n    uv = uv * rot(iTime*0.5);\n    vec3 col = vec3(0.0);\n    float t = iTime * 0.2;\n    float r = sin(t)*0.95;\n    float m = spr(uv-vec2(sin(t), cos(t))*r);\n    float n = spr(uv-vec2(cos(t), sin(t))*r);\n    float o = spr(uv+vec2(sin(t), cos(t))*r);\n    float p = spr(uv+vec2(cos(t), sin(t))*r);\n \n\tcol = vec3(m*n*o*p) * vec3(max(0.001,sin(t+123.0)*0.69), max(0.01,sin(t+1300.0)*0.50), max(0.001,cos(t)*0.88));\n    fragColor = vec4( pow(col,vec3(0.4545)),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/NdsSDM.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "NdsSRM", "name": "Oval - gradient 3D", "author": "Dain", "description": "Oval with analytic gradient\nOval shape is from sylvain69780 shader here https://www.shadertoy.com/view/Ws3BWH, but 3D and modified to be branchless so there are less length() calls\n\nOval is a capsule, with adjustable mid radius \n", "tags": ["3d", "sdf", "gradient", "normal", "analytic", "oval"], "likes": 1, "viewed": 138, "date": "1618404026", "time_retrieved": "2024-06-20T20:37:55.768272", "image_code": "// The MIT License\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n//Rendering code from IQs torus gradient shader https://www.shadertoy.com/view/wtcfzM\n\n// sdgOval returns the oval SDF and its gradient, by \n// computing it analytically. \n\n// Other SDF analytic gradients\n// Egg: https://www.shadertoy.com/view/7dXSz7\n// Oval: https://www.shadertoy.com/view/NdsSRM\n// Disk: https://www.shadertoy.com/view/NdlSR7\n// Box : https://www.shadertoy.com/view/NslSz7\n\n\n// Other SDF analytic gradients(By IQ):\n//\n// Torus:   https://www.shadertoy.com/view/wtcfzM\n// Capsule: https://www.shadertoy.com/view/WttfR7\n\n//Set to 1 to show the finite difference gradient for comparison\n#define SHOW_NUMERIC_GRADIENT 0\n\n//A Z up oval, similiar to a capsule with a customizable mid radius\n// .x = f(p)\n// .y = ∂f(p)/∂x\n// .z = ∂f(p)/∂y\n// .w = ∂f(p)/∂z\n// .yzw = ∇f(p) with ‖∇f(p)‖ = 1\nvec4 sdgOvalZ(vec3 pIn, float  a, float b, float h) {\n    \n    //These first 4 lines can be precalculated once\n    float r = a - b; //a must be greater than b!\n\tfloat l = (h * h - r * r) / (r+r);\n\tfloat sub2 = (a + l);\n\tfloat sub1 = sub2 - length(vec2(h, l));\n       \n\n    vec2 p = vec2(length(pIn.xy), abs(pIn.z) );\n    \n\tbool isTop =((p.y-h)*l) > p.x * h;\n    \n\tfloat y = isTop? h: 0.0;\n\tfloat x = isTop ? 0.0: l;\n\n\tvec2 p2 = vec2( p.x + x, p.y - y );\n   \n\tfloat d = length(p2)- (isTop ? sub1 : sub2);  \n\tvec3 grad = vec3(pIn.xy, pIn.z-y)*vec3(p2.x, p2.x, p.x );\n  \n\treturn vec4(d, normalize(grad));\n}\n\n//This shader assumes Y is up, so wrapping it to call the Z up oval\nvec4 sdgOvalY(vec3 p, float  a, float b, float h) {\n    p.xyz = p.xzy;\n    vec4 r= sdgOvalZ(p, a,b,h);\n    r.yzw = r.ywz;\n    return r;\n}\n\n#define AA 3\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n     // camera movement\t\n\tfloat an = 0.5*(iTime-10.0);\n\tvec3 ro = 1.2*vec3( 1.0*cos(an),1.30, 1.0*sin(an));\n    vec3 ta = vec3( 0.0, .5, 0.0 );\n    // camera matrix\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(0.0,1.0,0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n   \n    // animate torus\n    float ra = 0.5 + 0.4*cos(iTime);\n    float rb = min(0.1+0.1*(sin(iTime)), ra*.9);\n    float height = abs(cos(iTime*.5))*.5 +0.6;\n    \n    // render    \n    vec3 tot = vec3(0.0);\n    #if AA>1\n    for( int m=0; m<AA; m++ )\n    for( int n=0; n<AA; n++ )\n    {\n        // pixel coordinates\n        vec2 o = vec2(float(m),float(n)) / float(AA) - 0.5;\n        vec2 p = (2.0*(fragCoord+o)-iResolution.xy)/iResolution.y;\n        #else    \n        vec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n        #endif\n\n\t    // create view ray\n        vec3 rd = normalize( p.x*uu + p.y*vv + 1.5*ww );\n\n        // raymarch\n        const float tmax = 5.0;\n        float t = 0.0;\n        for( int i=0; i<256; i++ )\n        {\n            vec3 pos = ro + t*rd;\n            float h = sdgOvalY(pos,ra,rb, height).x;\n            if( h<0.0001 || t>tmax ) break;\n            t += h;\n        }\n        \n    \n        // shading/lighting\t\n        vec3 col = vec3(0.0);\n        if( t<tmax )\n        {\n            vec3 pos = ro + t*rd;\n            vec3 nor = sdgOvalY(pos,ra,rb, height).yzw;\n\n            // compute normal numerically, for comparison\n            // http://iquilezles.org/www/articles/normalsSDF/normalsSDF.htm\n            #if SHOW_NUMERIC_GRADIENT\n            const vec2 e = vec2(1,-1);\n            const float eps = 0.0002;\n            nor = normalize( e.xyy*sdgOvalY( pos + e.xyy*eps, ra, rb,height ).x + \n                             e.yyx*sdgOvalY( pos + e.yyx*eps, ra, rb,height ).x + \n                             e.yxy*sdgOvalY( pos + e.yxy*eps, ra, rb,height ).x + \n                             e.xxx*sdgOvalY( pos + e.xxx*eps, ra, rb,height ).x );\n\n            #endif\n\n            float dif = clamp( dot(nor,vec3(0.57703)), 0.0, 1.0 );\n            float amb = 0.5 + 0.5*dot(nor,vec3(0.0,1.0,0.0));\n            col = vec3(0.2,0.3,0.4)*amb + vec3(0.85,0.75,0.65)*dif;\n            col *= (0.5+0.5*nor)*(0.5+0.5*nor);\n        }\n\n        // gamma        \n        col = sqrt( col );\n\t    tot += col;\n    #if AA>1\n    }\n    tot /= float(AA*AA);\n    #endif\n\n\tfragColor = vec4( tot, 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "mit", "thumbnail": "https://www.shadertoy.com/media/shaders/NdsSRM.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "NdSSRR", "name": "final project Ari", "author": "abenkov", "description": "Based on artwork by Gyuri Lohmuller (https://www.instagram.com/p/BtPyqNIhizl/?utm_source=ig_web_copy_link). Final project for CIS561\n\nWanted to animate clouds as well but not really sure how.", "tags": ["finalproject", "surrealart"], "likes": 1, "viewed": 81, "date": "1619496515", "time_retrieved": "2024-06-20T20:37:58.586503", "image_code": "//built off of Adam's fresnel demo as skeleton code: https://www.shadertoy.com/view/Wdj3RK\n\nconst int RAY_STEPS = 256;\nconst float HALF_PI = 3.14159 * 0.5;\nconst float PI = 3.14159;\nconst float TWO_PI = 2.0 * 3.14159;\n\nconst int AO_SAMPLES = 256;\nconst float AO_DIST = 0.15;\nconst float FIVETAP_K = 2.0;\nconst float SHADOW_HARDNESS = 20.0;\n\nconst vec3 MAIN_LIGHT_DIR = normalize(vec3(1.0, 0.2, -0.4));\n//------------------------------------------------------------------\n\nfloat dot2( in vec2 v ) { return dot(v,v); }\nfloat dot2( in vec3 v ) { return dot(v,v); }\nfloat ndot( in vec2 a, in vec2 b ) { return a.x*b.x - a.y*b.y; }\n\nfloat random1(vec2 p) {\n  return fract(sin(dot(p, vec2(456.789, 20487145.123))) * 842478.5453);\n}\n\nfloat random1( vec3 p ) {\n  return fract(sin(dot(p, vec3(127.1, 311.7, 191.999))) * 43758.5453);\n}\n\nvec2 random2(vec2 p) {\n  return fract(sin(vec2(dot(p, vec2(127.1, 311.7)), dot(p, vec2(269.5, 183.3)))) * 43758.5453);\n}\n\nfloat mySmootherStep(float a, float b, float t) {\n  t = t*t*t*(t*(t*6.0 - 15.0) + 10.0);\n  return mix(a, b, t);\n}\n\nfloat interpNoise3D1(vec3 p) {\n  vec3 pFract = fract(p);\n  float llb = random1(floor(p));\n  float lrb = random1(floor(p) + vec3(1.0,0.0,0.0));\n  float ulb = random1(floor(p) + vec3(0.0,1.0,0.0));\n  float urb = random1(floor(p) + vec3(1.0,1.0,0.0));\n\n  float llf = random1(floor(p) + vec3(0.0,0.0,1.0));\n  float lrf = random1(floor(p) + vec3(1.0,0.0,1.0));\n  float ulf = random1(floor(p) + vec3(0.0,1.0,1.0));\n  float urf = random1(floor(p) + vec3(1.0,1.0,1.0));\n\n  float lerpXLB = mySmootherStep(llb, lrb, pFract.x);\n  float lerpXHB = mySmootherStep(ulb, urb, pFract.x);\n  float lerpXLF = mySmootherStep(llf, lrf, pFract.x);\n  float lerpXHF = mySmootherStep(ulf, urf, pFract.x);\n\n  float lerpYB = mySmootherStep(lerpXLB, lerpXHB, pFract.y);\n  float lerpYF = mySmootherStep(lerpXLF, lerpXHF, pFract.y);\n\n  return mySmootherStep(lerpYB, lerpYF, pFract.z);\n}\n\n\nfloat fbm(vec3 p, float octaves) {\n  float amp = 0.5;\n  float freq = 32.0;\n  float sum = 0.0;\n  float maxSum = 0.0;\n  for(float i = 0.0; i < 10.0; ++i) {\n    if(i == octaves)\n    break;\n    maxSum += amp;\n    sum += interpNoise3D1(p * freq) * amp;\n    amp *= 0.5;\n    freq *= 2.0;\n  }\n  return sum / maxSum;\n}\n\nstruct Intersection\n{\n    float t;\n    vec3 color;\n    vec3 p;\n    int object;\n};\n\nvec3 rotateX(vec3 p, float amt) {\n    return vec3(p.x, cos(amt) * p.y - sin(amt) * p.z, sin(p.y) + cos(p.z));\n}\n    \nvec3 rotateY(vec3 p, float a) {\n    return vec3(cos(a) * p.x + sin(a) * p.z, p.y, -sin(a) * p.x + cos(a) * p.z);\n}\n\nvec3 rotateZ(vec3 p, float amt) {\n    return vec3(cos(amt) * p.x - sin(amt) * p.y, sin(amt) * p.x + cos(amt) * p.y, p.z);\n}\n\nvoid raycast(vec2 uv, out vec3 dir, out vec3 eye, out vec3 ref) {\n    eye = rotateY(vec3(0.0, 0.0,10.0), HALF_PI / 2.0);\n    //eye = vec3(0.0, 5.0, 5.0);\n    ref = vec3(0.0, 0.0, 0.0);\n    \n    float len = tan(3.14159 * 0.125) * distance(eye, ref);\n    vec3 H = normalize(cross(vec3(0.0, 1.0, 0.0), ref - eye));\n    vec3 V = normalize(cross(H, eye - ref));\n    V *= len;\n    H *= len * iResolution.x / iResolution.y;\n    vec3 p = ref + uv.x * H + uv.y * V;\n    dir = normalize(p - eye);\n}\n\nfloat sphere(vec3 p, float r, vec3 c)\n{\n    return distance(p, c) - r;\n}\n\nfloat torus(vec3 p, vec2 t)\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q) - t.y;\n}\n\n// http://www.iquilezles.org/www/articles/distfunctions/distfunctions.htm\nfloat sdEllipsoid( in vec3 p, in vec3 c, in vec3 r )\n{\n    return (length( (p-c)/r ) - 1.0) * min(min(r.x,r.y),r.z);\n}\n\n// http://iquilezles.org/www/articles/smin/smin.htm\nfloat smin( float a, float b, float k )\n{\n\tfloat h = clamp( 0.5 + 0.5*(b-a)/k, 0.0, 1.0 );\n\treturn mix( b, a, h ) - k*h*(1.0-h);\n}\n\n// http://iquilezles.org/www/articles/smin/smin.htm\nfloat smax( float a, float b, float k )\n{\n\tfloat h = clamp( 0.5 + 0.5*(b-a)/k, 0.0, 1.0 );\n\treturn mix( a, b, h ) + k*h*(1.0-h);\n}\n\n// http://iquilezles.org/www/articles/smin/smin.htm\nvec3 smax( vec3 a, vec3 b, float k )\n{\n\tvec3 h = clamp( 0.5 + 0.5*(b-a)/k, 0.0, 1.0 );\n\treturn mix( a, b, h ) + k*h*(1.0-h);\n}\n\n// Box with side lengths b\nfloat box(vec3 p, vec3 b)\n{\n  return length(max(abs(p) - b, 0.0));\n}\n\nfloat infCone( vec3 p, vec2 c )\n{\n    // c is the sin/cos of the angle\n    vec2 q = vec2( length(p.xz), -p.y );\n    float d = length(q-c*max(dot(q,c), 0.0));\n    return d * ((q.x*c.y-q.y*c.x<0.0)?-1.0:1.0);\n}\n\n\n\nfloat sdCone(vec3 p, vec3 a, vec3 b, float ra, float rb)\n{\n    float rba  = rb-ra;\n    float baba = dot(b-a,b-a);\n    float papa = dot(p-a,p-a);\n    float paba = dot(p-a,b-a)/baba;\n\n    float x = sqrt( papa - paba*paba*baba );\n\n    float cax = max(0.0,x-((paba<0.5)?ra:rb));\n    float cay = abs(paba-0.5)-0.5;\n\n    float k = rba*rba + baba;\n    float f = clamp( (rba*(x-ra)+paba*baba)/k, 0.0, 1.0 );\n\n    float cbx = x-ra - f*rba;\n    float cby = paba - f;\n    \n    float s = (cbx < 0.0 && cay < 0.0) ? -1.0 : 1.0;\n    \n    return s*sqrt( min(cax*cax + cay*cay*baba,\n                       cbx*cbx + cby*cby*baba) );\n}\n\nfloat sdCappedCone( in vec3 p, in float h, in float r1, in float r2 )\n{\n    vec2 q = vec2( length(p.xz), p.y );\n    \n    vec2 k1 = vec2(r2,h);\n    vec2 k2 = vec2(r2-r1,2.0*h);\n    vec2 ca = vec2(q.x-min(q.x,(q.y < 0.0)?r1:r2), abs(q.y)-h);\n    vec2 cb = q - k1 + k2*clamp( dot(k1-q,k2)/dot2(k2), 0.0, 1.0 );\n    float s = (cb.x < 0.0 && ca.y < 0.0) ? -1.0 : 1.0;\n    return s*sqrt( min(dot2(ca),dot2(cb)) );\n}\n\n\nfloat capsule( vec3 p, float h, float r )\n{\n  p.y -= clamp( p.y, 0.0, h );\n  return length( p ) - r;\n}\n\n//helix spiral from comments of https://www.shadertoy.com/view/tlXSWM\nfloat spiral(vec3 q)\n{   \n\tfloat l = length(q.xz) - 2.2;\n\tfloat d = mod(atan(q.z,q.x)-q.y * 2.2, 4.0*HALF_PI) - 3.14159;\n\treturn length(vec2(l, d)) - 1.15;\n}\n\n\n//failed attempt at taper function\nfloat taperCap( in vec3 p ) \n{\n    vec3 q = vec3(0.1*sqrt(p.y)*p.x, p.y, 0.1*sqrt(p.y)*p.z);\n    return capsule(q, 5., 1.);\n}\n\nfloat sdCappedCylinder( vec3 p, float h, float r )\n{\n  vec2 d = abs(vec2(length(p.xz),p.y)) - vec2(h,r);\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nvec3 opCheapBend( in vec3 p )\n{\n    const float k = 0.6; // or some other amount\n    float c = cos(k*p.x);\n    float s = sin(k*p.x);\n    mat2  m = mat2(c,-s,s,c);\n    vec3  q = vec3(m*p.xy,p.z);\n    return q;\n}\n\n//ultimately ended up using opTwist and opTwist2 (to have varying levels of curve/twist)\nvec3 opTwist( in vec3 p )\n{\n    const float k = 1.7; // or some other amount\n    float c = cos(k*p.y);\n    float s = sin(k*p.y);\n    mat2  m = mat2(c,-s,s,c);\n    vec3  q = vec3(m*p.xz, p.y);\n    q = vec3(q.x, p.y, q.y );\n    //q = p;\n    return q;\n}\n\nvec3 opTwist2( in vec3 p )\n{\n    const float k = 1.9; // or some other amount\n    float c = cos(k*p.y);\n    float s = sin(k*p.y);\n    mat2  m = mat2(c,-s,s,c);\n    vec3  q = vec3(m*p.xz, p.y);\n    q = vec3(q.x, p.y, q.y );\n    //q = p;\n    return q;\n}\n\nvec3 axTwist( in vec3 p )\n{\n    const float k = 0.9; // or some other amount\n    float c = cos(k*p.y);\n    float s = sin(k*p.y);\n    \n    vec3 q = vec3(p.x*s + p.z*c - 0.2, k*p.y, p.z*s - p.x*c);\n    return q;\n}\n\nfloat opSmoothUnion( float d1, float d2, float k ) \n{\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); \n}\n\n\nfloat coneTwist3( in vec3 p )\n{\n    //Translate(-X, 0, Z) * Rotate(Y, -45) * Twist(Y axis) * Rotate(Z, <45) * Basic Cone\n\n    vec3 q = p + vec3(-0.4, -0.9, 2.5);\n    q = rotateY(q, -PI * 0.14);\n    q = opTwist(q);// - vec3(0., 1., 0.);\n    q = rotateZ(q, PI * 0.17);\n    //return sdCone(q, vec3(0.0,-1.5,0.0), vec3(0.0,1.1,0.0), 0.25, 0.0 );\n    return infCone(q, vec2(0.173, 0.985)); \n    //return capsule(q, 2., 0.1);\n    //return sdCappedCylinder(q, 0.6, 0.2);\n}\n\nfloat coneTwist4( in vec3 p )\n{\n    //Translate(-X, 0, Z) * Rotate(Y, -45) * Twist(Y axis) * Rotate(Z, <45) * Basic Cone\n\n    //vec3 q = p + vec3(4., -6.6, 5.1);\n    vec3 q = p + vec3(-0.4, 0.9, -0.2);\n    \n    //was experimenting - this wqs originally meant to be another twisty cone but i liked the look\n    //of the resulting shape better\n    q = rotateX(q, PI * 0.013); \n    \n    q = rotateY(q, -PI * 0.95);\n    q = opTwist2(q);// - vec3(0., 1., 0.);\n    q = rotateZ(q, PI * 0.12);\n    \n    \n    \n    //return sdCone(q, vec3(0.0,-1.5,0.0), vec3(0.0,1.1,0.0), 0.25, 0.0 );\n    //return infCone(q, vec2(sin(PI * 0.04), cos(PI * 0.04))); \n    return sdCone(q, vec3(0.0,-1.5,0.0), vec3(0.0,6.1,0.0), 0.75, 0.0 );\n    //return capsule(q, 2., 0.1);\n    //return sdCappedCylinder(q, 0.6, 0.2);\n}\n\nfloat torusTwist(in vec3 p) \n{\n    vec3 q = p;\n    //q = axTwist(q) - vec3(0., 1., 0.);\n    q = opTwist(q);\n    return torus(q, vec2(0.5,0.2));\n}\n\n//adapted from snail shader: https://www.shadertoy.com/view/ld3Gz2\nfloat spiral2( in vec3 p ) \n{\n    const float sc = 1.0/3.0;\n    p -= vec3(0.05,0.12,-0.09);    \n\n    p *= sc;\n\n    vec3 q = mat3(-0.6333234236, -0.7332753384, 0.2474039592,\n                   0.7738444477, -0.6034162289, 0.1924931824,\n                   0.0081370606,  0.3133626215, 0.9495986813) * p;\n    //vec3 q = p;\n    //vec3 q = mat3(1., 0., 0.,\n    //              0., 0., 1.,\n    //              0., -1., 0.) * p;\n             \n\n    const float b = 0.1759;\n    \n    float r = length( q.xy );\n    float t = atan( q.y, q.x );\n \n    // https://swiftcoder.wordpress.com/2010/06/21/logarithmic-spiral-distance-field/\n    float np = (log(   r)/b-t)/(TWO_PI);\n    float nm = (log(0.11)/b-t)/(TWO_PI);\n    float n = min(np,nm);\n    \n    float ni = floor( n );\n    \n    float r1 = exp( b * (t + TWO_PI*ni));\n    float r2 = r1 * 3.019863;\n    \n    //-------\n\n    float h1 = q.z + 1.5*r1 - 0.5; float d1 = sqrt((r1-r)*(r1-r)+h1*h1) - r1;\n    float h2 = q.z + 1.5*r2 - 0.5; float d2 = sqrt((r2-r)*(r2-r)+h2*h2) - r2;\n    \n    float d, dx, dy;\n    if( d1<d2 ) { d = d1; dx=r1-r; dy=h1; }\n    else        { d = d2; dx=r2-r; dy=h2; }\n    \n    vec3 s = q;\n    q = q - vec3(0.34,-0.1,0.03);\n    q.xy = mat2(0.8,0.6,-0.6,0.8)*q.xy;\n    d = smin( d, torus( q, vec2(0.28,0.05) ), 0.06);\n    d = smax( d, -sdEllipsoid(q,vec3(0.0,0.0,0.0),vec3(0.24,0.36,0.24) ), 0.03 );\n    d = smax( d, -sdEllipsoid(s,vec3(0.52,-0.0,0.0),vec3(0.42,0.23,0.5) ), 0.05 );\n    \n    return d/sc;\n}\n\n\n\n\n// Version that just returns the t value, for surface normal computation\nfloat sceneMap3D(vec3 pos)\n{\n    float t = coneTwist3(pos - vec3(4., 0., 4.));\n    t = min(t, coneTwist4(pos - vec3(0., 0., 4.)));\n    //float t = spiral2(pos);\n    //float t = torusTwist(pos - vec3(3., 0., 3.));\n    t = min(t, sphere(pos - vec3(0.1, 0., 0.1), 0.5, vec3(4.5, 0.89, 3.0)));\n    //t = min(t, sphere(pos, 2.0, vec3(-8.0, 0.0, 4.0)));\n    t = min(t, box(pos + vec3(0.0, 3.0, 0.0), vec3(50.0, 1.0, 50.0)));\n    //t = min(t, sdCone(pos + vec3(-8.0, 0.0, 4.0), vec2(0.5, 0.86), 5.0));\n    //t = min(t, coneTwist(pos + vec3(0.0, 3.0, 0.0)));\n    return t;\n}\n\n// Version that returns t value and the ID of the object hit\nvoid sceneMap3D(vec3 pos, out float t, out int obj)\n{\n    t = coneTwist3(pos - vec3(4., 0., 4.));\n    //t = spiral2(pos);\n    //t = torusTwist(pos - vec3(3., 0., 3.));\n    float t2;\n    obj = 0; // 0 is first tentacle\n    if((t2 =  coneTwist4(pos - vec3(0., 0., 4.))) < t) {\n        t = t2;\n        obj = 1; // 1 is second tentacle/green thingy\n    }\n    if((t2 = sphere(pos - vec3(0.1, 0., 0.1), 0.5, vec3(4.5, 0.89, 3.0))) < t) {\n        t = t2;\n        obj = 2; // 2 is sphere\n    }\n\n    if((t2 = box(pos + vec3(0.0, 3.0, 0.0), vec3(50.0, 1.0, 50.0))) < t) {\n        t = t2;\n        obj = 3; // 3 is floor\n    }\n}\n\n\nfloat fiveTapAO(vec3 p, vec3 n, float k) {\n    float aoSum = 0.0;\n    for(float i = 0.0; i < 5.0; ++i) {\n        float coeff = 1.0 / pow(2.0, i);\n        aoSum += coeff * (i * AO_DIST - sceneMap3D(p + n * i * AO_DIST));\n    }\n    return 1.0 - k * aoSum;\n}\n\nfloat softShadow(vec3 dir, vec3 origin, float min_t, float k) {\n    float res = 1.0;\n    float t = min_t;\n    for(int i = 0; i < RAY_STEPS; ++i) {\n        float m = sceneMap3D(origin + t * dir);\n        if(m < 0.0001) {\n            return 0.0;\n        }\n        res = min(res, k * m / t);\n        t += m;\n    }\n    return res;\n}\n\nfloat shadow(vec3 dir, vec3 origin, float min_t) { \n    return softShadow(dir, origin, min_t, SHADOW_HARDNESS);\n}\n\nvoid march(vec3 origin, vec3 dir, out float t, out int hitObj)\n{\n    t = 0.001;\n    for(int i = 0; i < RAY_STEPS; ++i)\n    {\n        vec3 pos = origin + t * dir;\n    \tfloat m;\n        sceneMap3D(pos, m, hitObj);\n        if(m < 0.01)\n        {\n            return;\n        }\n        t += m;\n    }\n    t = -1.0;\n    hitObj = -1;\n}\n\nvec3 computeNormal(vec3 pos)\n{\n    vec3 epsilon = vec3(0.0, 0.001, 0.0);\n    return normalize( vec3( sceneMap3D(pos + epsilon.yxx) - sceneMap3D(pos - epsilon.yxx),\n                            sceneMap3D(pos + epsilon.xyx) - sceneMap3D(pos - epsilon.xyx),\n                            sceneMap3D(pos + epsilon.xxy) - sceneMap3D(pos - epsilon.xxy)));\n}\n\n//250, 200, 158\nvec3 skyColor(vec3 dir) {\n    float t = smoothstep(0.0, 1.0, dir.y);\n    t = clamp(0.0, 1.0, t + fbm(dir / 2.0, 4.0) * 0.9);\n    t = fbm((dir / 8.0), 6.0); //+ abs(cos(iTime *0.2));\n    t = smoothstep(0.0, 1.0, t);\n    vec3 cloudGrad = mix(vec3(180.0, 109.0, 84.0) / 255.0, vec3(173.0, 193.0, 198.0) / 255.0, t);\n    vec3 cloudGrad2 = mix(vec3(250.0, 200.0, 158.0) / 255.0, vec3(173.0, 193.0, 198.0) / 255.0, t);\n    vec3 dawnGradient = mix(vec3(253.0, 96.0, 81.0) / 255.0, vec3(255.0, 229.0, 119.0) / 255.0, t);\n    vec3 duskGradient = mix(vec3(48.0, 24.0, 96.0) / 255.0, vec3(144.0, 96.0, 144.0) / 255.0, t);\n    //t = max(0.0, dot(dir, MAIN_LIGHT_DIR*abs(2.0*sin(0.3*iTime * HALF_PI / 4.0))));\n    //return mix(duskGradient, dawnGradient, t);\n    //vec3 col1 = mix(duskGradient, dawnGradient, t*abs(cos(0.1*iTime * HALF_PI / 4.0)));\n    //vec3 col2 = mix(cloudGrad, cloudGrad2, t);\n    //return mix(cloudGrad, cloudGrad2, t);\n    t = max(0.0, dot(dir, MAIN_LIGHT_DIR));\n    vec3 col1 = mix(duskGradient, dawnGradient, t);\n    vec3 col2 = mix(cloudGrad, cloudGrad2, t);\n    return mix(col2, col1, t);\n    //return max(col1 * abs(sin(iTime)), col2*abs(cos(iTime*20.0)));\n}\n\n\n\n//used specular reflection code from https://www.shadertoy.com/view/4l3GDM\nvec3 computeMaterial(int hitObj, vec3 p, vec3 d, vec3 n) {\n    switch(hitObj) {\n        case 0:\n        // first tentacle\n        vec3 l = normalize(MAIN_LIGHT_DIR);\n        vec3 v = normalize(d);\n        float f = dot(l, n) > 0.0 ? 1.0 : 0.0;\n        vec3 r = reflect(l, n);\n        return vec3(1.,1.,1.) * 0.83 * f * pow(max(0.0, dot(r, v)), 2.0) + vec3(0.955,0.775,0.24)*0.95;\n        break;\n        case 1:\n        // second tentacle\n        //return vec3(0.67, 1.0, 0.67);\n        vec3 l1 = normalize(MAIN_LIGHT_DIR);\n        vec3 v1 = normalize(d);\n        float f1 = dot(l1, n) > 0.0 ? 1.0 : 0.0;\n        vec3 r1 = reflect(l1, n);\n        return vec3(1.,1.,1.) * 0.95 * f1 * pow(max(0.0, dot(r1, v1)), 8.0) + vec3(0.67, 1.0, 0.67)*0.95;\n        break;\n        case 2:\n        vec3 l2 = normalize(MAIN_LIGHT_DIR);\n        vec3 v2 = normalize(d);\n        float f2 = dot(l2, n) > 0.0 ? 1.0 : 0.0;\n        vec3 r2 = reflect(l2, n);\n        return vec3(1.,1.,1.) * 0.95 * f2 * pow(max(0.0, dot(r2, v2)), 84.0) + vec3(1.,1.,1.)*0.75;\n        break;\n        case 3:\n        // Floor\n        //float t = floor(mod((sin(p.x) + sin(p.z)) * 0.5, 2.0));\n        //return mix(vec3(0.7, 0.4, 0.2), vec3(1.0), t);\n        vec3 l3 = normalize(MAIN_LIGHT_DIR);\n        vec3 v3 = normalize(d);\n        float f3 = dot(l3, n) > 0.0 ? 1.0 : 0.0;\n        vec3 r3 = reflect(l3, n);\n        return vec3(1.,1.,1.) * 0.95 * f3 * pow(max(0.0, dot(r3, v3)), 4.0) + vec3(1.,1.,1.)*0.75;\n        break;\n        case -1:\n        // Background\n        break;\n    }\n    return vec3(1.0);\n}\n\nIntersection sdf3D(vec3 dir, vec3 eye)\n{\n    float t;\n    int hitObj;\n    march(eye, dir, t, hitObj);\n    \n    if(t == -1.0) {\n        return Intersection(t, skyColor(dir), vec3(eye + 1000.0 * dir), -1);\n    }\n\n    vec3 isect = eye + t * dir;\n    vec3 nor = computeNormal(isect);\n    \n    vec3 material = computeMaterial(hitObj, isect, dir, nor);\n\n    float fresnel = 1.0 - max(0.0, dot(normalize(eye - isect), nor));\n    fresnel = 0.75 + 0.75 * fresnel;\n    \n    vec3 lightDir = rotateY(normalize(MAIN_LIGHT_DIR), sin(iTime * 0.5));\n    \n    vec3 sdfColor = mix(material, skyColor(reflect(dir, nor)) * material, fresnel) * shadow(lightDir, isect, 0.1);\n    \n    \n    return Intersection(t, sdfColor, isect, hitObj);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    // [-1, 1]\n    vec2 uv2 = 2.0 * uv - vec2(1.0);\n    \n    // Stratified sampled 4x4 anti-aliasing\n    Intersection aaIsects[16];\n    vec3 dir, eye, ref;\n    int idx = 0;\n    for(float i = 0.0; i < 1.0; i += 0.25) {\n        for(float j = 0.0; j < 1.0; j += 0.25) {\n            raycast(uv2 + (vec2(i, j) + random2(vec2(i, j))) / iResolution.xy, dir, eye, ref);\n            aaIsects[idx++] = sdf3D(dir, eye);\n        }\n    }\n    vec3 avgColor = vec3(0.0);\n    for(int i = 0; i < 16; ++i) {\n        avgColor += aaIsects[i].color;\n    }\n    avgColor *= 0.0625;\n    fragColor = vec4(avgColor, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/NdSSRR.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "NdsSW4", "name": "Fork impulse_gl gusandr 029", "author": "gusandr", "description": "Messing around with refractions. I am quite new to shader programming\n  and raymarching so while I think the code might not be very good I also think that\n  what makes ShaderToy.com so good is that programmers are sharing what they do, \n  big and small.", "tags": ["glass"], "likes": 1, "viewed": 53, "date": "1618651040", "time_retrieved": "2024-06-20T20:38:01.156532", "image_code": "// Created by mrange/2018\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n// \n// Messing around with refractions. I am quite new to shader programming\n//  and raymarching so while I think the code might not be very good I also think that\n//  what makes ShaderToy.com so good is that programmers are sharing what they do, \n//  big and small. I too want to share in the hope it might help someone on my level.\n// \n// Inpiration and code from shaders:\n//  https://www.shadertoy.com/view/4ds3zn (iq, inspirations and various functions)\n//  https://www.shadertoy.com/view/XljGDz (otaviogood, \"skybox\")\n//  https://www.shadertoy.com/view/Xl2GDW (purton, inspiration for reflection)\n// Music: Levi Patel - As she passes (Soundcloud)\n// Blogs:\n//  Raymarching explained: http://9bitscience.blogspot.com/2013/07/raymarching-distance-fields_14.html\n//  Distance Estimators: www.iquilezles.org/www/articles/distfunctions/distfunctions.htm\n//  Cool primitives: http://mercury.sexy/hg_sdf/\n\n#define TOLERANCE       0.000001\n#define MAX_RAY_LENGTH  16.0\n#define MAX_BOUNCES     8\n#define MAX_RAY_MARCHES 90\n\n#define PI              3.141592654\n#define TAU             (2.0*PI)\n\n#define DEG2RAD         (PI/180.0)\n\n#define PERIODTIME      5.0\n#define FADETIME        1.0\n\n#define TIMEINPERIOD    (mod(iTime, PERIODTIME))\n#define PERIOD          (mod(floor(iTime / PERIODTIME), 9.0))\n//#define PERIOD          8\n\n#define AA              0\n\nfloat sgn(float x)\n{\n  return (x<0.0)?-1.0:1.0;\n}\n\nfloat smin(float a, float b, float k)\n{\n  float res = exp( -k*a ) + exp( -k*b );\n  return -log( res )/k;\n}\n\nfloat pReflect(inout vec3 p, vec3 planeNormal, float offset)\n{\n  float t = dot(p, planeNormal)+offset;\n  if (t < 0.0)\n  {\n    p = p - (2.0*t)*planeNormal;\n  }\n  return sgn(t);\n}\n\nvoid pR(inout vec2 p, float a)\n{\n  p = cos(a)*p + sin(a)*vec2(p.y, -p.x);\n}\n\nfloat maxComp(in vec3 p)\n{\n  return max(p.x,max(p.y,p.z));\n}\n\nfloat lengthN(in vec3 v, in float n)\n{\n  v = abs(v);\n  v = pow(v, vec3(n));\n  return pow(v.x + v.y + v.z, 1.0/n);\n}\n\nfloat sdRoundCube(in vec3 p, float r1)\n{\n    float s = 1.8;\n    p = abs(p);\n    float m = p.x + p.y + p.z - s;\n    vec3 r = 3.0*p - m;\n    \n\tvec3 q;\n         if( r.x < 0.0 ) q = p.xyz;\n    else if( r.y < 0.0 ) q = p.yzx;\n    else if( r.z < 0.0 ) q = p.zxy;\n    else return m*0.57735027;\n    float k = clamp(0.5*(q.z-q.y+s),0.0,s); \n    return length(vec3(q.x,q.y-s+k,q.z-k));   \n}\n\nvec3 pMod3(inout vec3 p, vec3 size)\n{\n  vec3 c = floor((p + size*0.5)/size);\n  p = mod(p + size*0.5, size) - size*0.5;\n  return c;\n}\n\nfloat sdBox(vec3 p, vec3 b)\n{\n  vec3  di = abs(p) - b;\n  float mc = maxComp(di);\n  return min(mc,length(max(di,0.0)));\n}\n\nfloat sdSphere(vec3 p, float r)\n{\n  return length(p) - r;\n}\n\nfloat impulse1(in vec3 p, out vec3 col, out float ref, out float trans, out vec3 absorb)\n{\n  col    = vec3(0.3);\n  ref    = 0.2;\n  trans  = 0.9;\n  absorb = 0.5*vec3(1.0, 2.0, 3.0);\n\n  float s  = sdSphere(p, 0.6);\n  float is = sdSphere(p, 0.8);\n  float rc = sdRoundCube(p, 1.0);\n\n  float d = rc;\n  d = max(d, -is);\n  d = min(d, s);\n  if (d == s)\n  {\n    absorb = 1.0*vec3(1.0, -1.0, -2.0);\n  }\n  return d;\n}\n\nfloat impulse2(in vec3 p, out vec3 col, out float ref, out float trans, out vec3 absorb)\n{\n  col    = vec3(0.3);\n  ref    = 0.2;\n  trans  = 0.9;\n  absorb = 0.5*vec3(1.0, 2.0, 3.0);\n\n  float s1 = sdBox(p, vec3(1.0));\n  float s3 = sdSphere(p, 0.4);\n  pMod3(p, vec3(1.0));\n  float s2 = sdSphere(p, 0.48);\n  float s = max(s1, -s2);\n  s = min(s, s3);\n  if (s == s3)\n  {\n    absorb = 1.0*vec3(1.0, -1.0, -2.0);\n  }\n\n  return s;\n}\n\nfloat mandelbulb(in vec3 p)\n{\n  vec3 w = p;\n  float m = dot(w,w);\n\n  float dz = 1.0;\n\n  dz = 8.0*pow(sqrt(m),7.0)*dz + 1.0;\n\n  float r = length(w);\n  float b = 8.0*acos(w.y/r);\n  float a = 8.0*atan(w.x, w.z);\n  vec3 v  = vec3(sin(b)*sin(a), cos(b), sin(b)*cos(a));\n  w = p + pow(r,8.0)*v;\n\n  m = dot(w,w);\n\n  return 0.25*log(m)*sqrt(m)/dz;\n}\n\n\nfloat impulse3(in vec3 p, out vec3 col, out float ref, out float trans, out vec3 absorb)\n{\n  col    = vec3(0.3);\n  ref    = 0.2;\n  trans  = 0.9;\n  absorb = 0.5*vec3(1.0, 2.0, 3.0);\n\n  float rc = sdRoundCube(p, 1.0);\n  float s  = 0.9;\n  float mb = mandelbulb(p/s)*s;\n  float s1 = sdSphere(p, 0.4);\n  float d = rc;\n  d = max(d, -mb);\n  d = min(d, s1);\n  if (d == s1)\n  {\n    absorb = 1.0*vec3(1.0, -1.0, -2.0);\n  }\n  return d;\n}\n\nfloat bubbles(in vec3 p)\n{\n  vec3 pp = p - vec3(0.1) - vec3(0.0, iTime*0.15 + 10.0, 0.0);\n  pReflect(pp, normalize(vec3(1.0, 0.5, 0.2)), 0.3);\n  pReflect(pp, normalize(vec3(0.2, 0.5, 1.0)), 0.2);\n  pMod3(pp, vec3(0.5, 0.3, 0.4));\n\n  vec3 ppp = p - vec3(0.2) - vec3(0.0, iTime*0.05 + 10.0, 0.0);\n  pReflect(ppp, normalize(vec3(0.7, 0.5, 0.4)), 0.3);\n  pReflect(ppp, normalize(vec3(0.5, 0.4, 0.7)), 0.1);\n  pMod3(ppp, vec3(0.7, 0.6, 0.4));\n\n  float ss = sdSphere(pp, 0.05);\n  float sss = sdSphere(ppp, 0.1);\n\n  return smin(ss, sss, 20.0);\n}\n\nfloat impulse4(in vec3 p, out vec3 col, out float ref, out float trans, out vec3 absorb)\n{\n  col    = vec3(0.3);\n  ref    = 0.2;\n  trans  = 0.9;\n  absorb = 0.5*vec3(1.0, 2.0, 3.0);\n\n  float sb = sdRoundCube(p, 1.0);\n  float s = 2.5;\n  float bs = bubbles(p/s)*s;\n\n  return max(sb, -bs);\n}\n\nfloat impulse5(in vec3 p, out vec3 col, out float ref, out float trans, out vec3 absorb)\n{\n  col    = vec3(0.3);\n  ref    = 0.2;\n  trans  = 0.9;\n  absorb = 0.5*vec3(1.0, 2.0, 3.0);\n\n  float sb = sdRoundCube(p, 1.0);\n  float t  = TIMEINPERIOD;\n  float s  = 2.5 / (1.0 + 4.0*t/PERIODTIME);\n  float bs = bubbles(p/s)*s;\n\n  return max(sb, -bs);\n}\n\n\nfloat distanceField(in vec3 p, out vec3 col, out float ref, out float trans, out vec3 absorb)\n{\n  int period = int(PERIOD);\n  float i = 10000000.0;\n  if (period == 0)      i = impulse1(p, col, ref, trans, absorb);\n  else if (period == 1) i = impulse2(p, col, ref, trans, absorb);\n  else if (period == 2) i = impulse4(p, col, ref, trans, absorb);\n  else if (period == 3) i = impulse3(p, col, ref, trans, absorb);\n  else if (period == 4) i = impulse2(p, col, ref, trans, absorb);\n  else if (period == 5) i = impulse3(p, col, ref, trans, absorb);\n  else if (period == 6) i = impulse2(p, col, ref, trans, absorb);\n  else if (period == 7) i = impulse5(p, col, ref, trans, absorb);\n  else if (period == 8) i = impulse1(p, col, ref, trans, absorb);\n\n  float rc = sdRoundCube(p - vec3(0.0, -5.05, 0.0), 4.0);\n\n  float d = min(rc, i);\n  if (d == rc)\n  {\n    col    = vec3(1.0);\n    ref    = 0.2;\n    trans  = 0.0;\n  }\n  return d;\n}\n\nvec3 saturate(in vec3 a)   { return clamp(a, 0.0, 1.0); }\nvec2 saturate(in vec2 a)   { return clamp(a, 0.0, 1.0); }\nfloat saturate(in float a) { return clamp(a, 0.0, 1.0); }\n\nconst vec3 lightPos1 = 100.0*vec3(-0.3, 0.0, 1.0);\nconst vec3 lightPos2 = 100.0*vec3(-0.5, -0.1, -1.2);\n\nconst vec3 lightCol1 = vec3(8.0/8.0,7.0/8.0,6.0/8.0);\nconst vec3 lightCol2 = vec3(8.0/8.0,6.0/8.0,7.0/8.0);\n\nvec3 getSkyColor(vec3 rayDir)\n{\n  vec3 lightDir1 = normalize(lightPos1);\n  vec3 lightDir2 = normalize(lightPos2);\n\n  float ld1      = max(dot(lightDir1, rayDir), 0.0);\n  float ld2      = max(dot(lightDir2, rayDir), 0.0);\n  vec3 final     = vec3(0.125);\n\n  if ((rayDir.y > abs(rayDir.x)*1.0) && (rayDir.y > abs(rayDir.z*0.25))) final = vec3(2.0)*rayDir.y;\n  float roundBox = length(max(abs(rayDir.xz/max(0.0,rayDir.y))-vec2(0.9, 4.0),0.0))-0.1;\n  final += vec3(0.8)* pow(saturate(1.0 - roundBox*0.5), 6.0);\n\n  final += pow(lightCol1, vec3(2.0, 1.5, 1.5)) * pow(ld1, 8.0);\n  final += lightCol1 * pow(ld1, 200.0);\n  final += pow(lightCol2, vec3(2.0, 1.5, 1.5)) * pow(ld2, 8.0);\n  final += lightCol2 * pow(ld2, 200.0);\n  return final;\n}\n\nvec3 normal(in vec3 pos)\n{\n  vec3  eps = vec3(.0001,0.0,0.0);\n  vec3 col;\n  float ref;\n  float trans;\n  vec3 nor;\n  vec3 absorb;\n  nor.x = distanceField(pos+eps.xyy, col, ref, trans, absorb) - distanceField(pos-eps.xyy, col, ref, trans, absorb);\n  nor.y = distanceField(pos+eps.yxy, col, ref, trans, absorb) - distanceField(pos-eps.yxy, col, ref, trans, absorb);\n  nor.z = distanceField(pos+eps.yyx, col, ref, trans, absorb) - distanceField(pos-eps.yyx, col, ref, trans, absorb);\n  return normalize(nor);\n}\n\nfloat rayMarch(in float dmod, in vec3 ro, inout vec3 rd, float mint, float minstep, out int rep, out vec3 col, out float ref, out float trans, out vec3 absorb)\n{\n  float t = mint;\n  for (int i = 0; i < MAX_RAY_MARCHES; i++)\n  {\n    float distance_ = distanceField(ro + rd*t, col, ref, trans, absorb);\n    float distance = dmod*distance_;\n    if (distance < TOLERANCE*t || t > MAX_RAY_LENGTH) break;\n    t += max(distance, minstep);\n    rep = i;\n  }\n  return t;\n}\n\nfloat softShadow(in vec3 pos, in vec3 ld, in float ll, float mint, float k)\n{\n  const float minShadow = 0.25;\n  float res = 1.0;\n  float t = mint;\n  vec3 col;\n  float ref;\n  float trans;\n  vec3 absorb;\n  for (int i=0; i<24; i++)\n  {\n    float distance = distanceField(pos + ld*t, col, ref, trans, absorb);\n    res = min(res, k*distance/t);\n    if (ll <= t) break;\n    if(res <= minShadow) break;\n    t += max(mint*0.2, distance);\n  }\n  return clamp(res,minShadow,1.0);\n}\n\nvec3 postProcess(in vec3 col, in vec2 q)\n{\n  col=pow(clamp(col,0.0,1.0),vec3(0.75));\n  col=col*0.6+0.4*col*col*(3.0-2.0*col);  // contrast\n  col=mix(col, vec3(dot(col, vec3(0.33))), -0.4);  // satuation\n  col*=0.5+0.5*pow(19.0*q.x*q.y*(1.0-q.x)*(1.0-q.y),0.7);  // vigneting\n  return col;\n}\n\nvec3 render(in vec3 ro, in vec3 rd)\n{\n  vec3 lightPos = 1.5*vec3(1.5, 3.0, 1.0);\n\n  vec3 final  = vec3(0.0);\n\n  vec3 ragg   = vec3(1.0);\n\n  float tdist = 0.0;\n\n  int period = int(PERIOD);\n\n  float refraction = 0.9;\n\n  if (period == 4) refraction = 1.2;\n  if (period == 5) refraction = 0.75;\n  if (period == 6) refraction = -0.8;\n\n  bool inside = false;\n\n  float mint    = 0.01;\n  float minstep = 0.001;\n\n  for (int i = 0; i < MAX_BOUNCES; ++i)\n  {\n    if (maxComp(ragg) <  0.01) break;\n    float dmod  = inside ? -1.0 : 1.0;\n    vec3 absorb ;\n    vec3 col    ;\n    float ref   ;\n    float trans ;\n    int rep     ;\n    float t     = rayMarch(dmod, ro, rd, mint, minstep, rep, col, ref, trans, absorb);\n    tdist       += t;\n\n    vec3 pos    = ro + t*rd;\n\n    vec3 nor = vec3(0.0, 1.0, 0.0);\n\n    if (t < MAX_RAY_LENGTH)\n    {\n      // Ray intersected object\n      nor = normal(pos);\n    }\n    else\n    {\n      // Ray intersected sky\n      final += ragg*getSkyColor(rd);\n      break;\n    }\n\n    float fresnel = pow(1.0 - abs(dot(nor, rd)), 2.0);\n\n    ref = mix(ref, 1.0, fresnel);\n    trans = mix(trans, 0.0, fresnel);\n\n    float mref = refraction;\n\n    if (inside)\n    {\n      nor = -nor;\n      mref = 1.0/refraction;\n    }\n\n    vec3 refl = reflect(rd, nor);\n    vec3 refr = refract(rd, nor, mref);\n\n    vec3 lv   = lightPos - pos;\n    vec3  ld  = normalize(lv);\n    float ll  = length(lv);\n    // TODO: Rework shadow to \"work\" with transparent objects\n    float sha = 1.0;\n    if (!inside)\n    {\n      sha = softShadow(pos, ld, ll, 0.01, 64.0);\n    }\n\n    float dif = max(dot(nor,ld),0.0);\n    float occ = 1.0 - float(rep)/float(MAX_RAY_MARCHES);\n    float l   = dif*sha*occ;\n\n\n    vec3 lr   = vec3(0.0);\n\n    float lin = mix(0.2, 1.0, l);\n\n    vec3 sky  = getSkyColor(refl);\n    vec3 mcol = mix(lin*col + lr, sky, ref);\n\n    vec3 beer = vec3(1.0);\n\n    if (inside)\n    {\n      beer = exp(-absorb*t);\n    }\n    final      += (1.0 - trans)*ragg*beer*mcol;\n    ragg       *= trans*beer;\n\n    ro        = pos;\n\n    if (refr == vec3(0.0))\n    {\n        rd = refl;\n    }\n    else\n    {\n      rd = refr;\n      inside = !inside;\n    }\n\n  }\n\n\n  return final;\n}\n\nvec3 getSample(in vec2 p)\n{\n  float time   = TIMEINPERIOD;\n  int period   = int(PERIOD);\n\n  vec3 ro  = vec3(3.0, 0.1, 0.0);\n  if (period == 5) ro = 1.5*vec3(1.0, 1.5, 0.0);\n  if (period == 8) ro += 3.0*vec3(smoothstep(FADETIME, PERIODTIME, time));\n\n  vec3 la  = vec3(0.0);\n\n  pR(ro.xz, iTime/PERIODTIME);\n\n  vec3 ww = normalize(la - ro);\n  vec3 uu = normalize(cross(vec3(0.0,1.0,0.0), ww ));\n  vec3 vv = normalize(cross(ww,uu));\n  vec3 rd = normalize( p.x*uu + p.y*vv + 2.0*ww );\n\n  vec3 col = render(ro, rd);\n\n  return col;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n  float time = TIMEINPERIOD;\n  vec2 q=fragCoord.xy/iResolution.xy;\n  vec2 p = -1.0 + 2.0*q;\n  p.x *= iResolution.x/iResolution.y;\n\n#if AA == 0\n  vec3 col = getSample(p);\n#elif AA == 1\n  vec3 col  = vec3(0.0);\n  vec2 unit = 1.0/iResolution.xy;\n  for(int y = 0; y < 2; ++y)\n  {\n    for(int x = 0; x < 2; ++x)\n    {\n      col += getSample(p - 0.5*unit + unit*vec2(x, y));\n    }\n  }\n\n  col /= 4.0;\n#endif\n\n  float whiteIn  = 1.0 - smoothstep(0.0, FADETIME, time);\n  float whiteOut = smoothstep(PERIODTIME - FADETIME, PERIODTIME, time);\n\n  if (iTime > PERIODTIME*9.0) whiteOut = 1.0;\n\n  fragColor = vec4(mix(postProcess(col, q), vec3(1.0), whiteOut + whiteIn), 1.0);\n}\n", "image_inputs": [{"id": "4lfGRn", "previewfilepath": "https://soundcloud.com/levipatel/as-she-passes", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0, "src": "https://soundcloud.com/levipatel/as-she-passes", "ctype": "musicstream"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc-by-nc-sa-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/NdsSW4.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "NdsSWX", "name": "N64 Logo", "author": "ccincotti3", "description": "After watching tutorials and reading ray tracing books I decided to give this a go - spec based off of https://i.redd.it/zlxt4qezv0y51.png\n\nBig thanks to The Art of Code! https://www.youtube.com/channel/UCcAlTqd9zID6aNX3TzwxJXg/videos", "tags": ["retro", "n64"], "likes": 7, "viewed": 136, "date": "1619361738", "time_retrieved": "2024-06-20T20:38:02.059498", "image_code": "#define MAX_STEPS 100\n#define SURFACE_DIST.0001\n#define MAX_DIST 10.\n#define SAMPLES 10\n\n#define HEIGHT 1.\n#define WIDTH 1.\n#define DEPTH 1.\n#define PI 3.14159265359\n#define WEIGHT DEPTH*.21\n#define SPACE_BETWEEN DEPTH*.42\n\nmat2 Rot(float a){\n    float s=sin(a),c=cos(a);\n    return mat2(c,-s,s,c);\n}\n\nvec2 rand( const float n ) {\n\treturn (fract(sin(vec2(n,n+1.))*vec2(43758.5453123)) - .5)/500.;\n}\n\n/*\n* SDFs\n*/\nfloat sdBox(vec3 p,vec3 b){\n    vec3 q=abs(p)-b;\n    return length(max(q,0.))+min(max(q.x,max(q.y,q.z)),0.);\n}\n\nfloat sdPlane(vec3 p,vec3 r){\n    return dot(p,normalize(r));\n}\n\nfloat sdTri(vec3 p,float cBd,vec3 cutPlane){\n    float cPd=sdPlane(p,cutPlane);\n    return-max(cPd,cBd);\n}\n\nfloat sdN(vec3 p){\n    float dpth=DEPTH*.29;\n    float box=sdBox(p,vec3(WIDTH,HEIGHT,dpth));// main box that forms N.\n    \n    vec3 cutPlane=vec3(0,HEIGHT,0.);\n    cutPlane.xy*=Rot(PI/2.-atan(SPACE_BETWEEN/(dpth*2.)));\n    \n    // Build triangles to cut out of box to build N\n    float cBd=sdBox(p,vec3(SPACE_BETWEEN,(29./WEIGHT)*SPACE_BETWEEN,.3));// box to slice into triangle\n    \n    vec3 triLoc=p+vec3(.0,SPACE_BETWEEN+.025,0);// bottom tri\n    float tri=sdTri(triLoc,cBd,cutPlane);\n    \n    triLoc=p-vec3(.0,SPACE_BETWEEN+.025,0);// top tri\n    triLoc.xy*=Rot(PI);\n    float tri2=sdTri(triLoc,cBd,cutPlane);\n    \n    float d=max(max(tri,tri2),box);// cut\n    return d;\n}\n\n// Could probably simplify this down to one N draw\nfloat GetDist(vec3 p){\n    vec3 bp=p;\n    if(sign(bp.z)<0.)\n        bp.xz*=Rot(PI);\n    float dN1=sdN(bp-vec3(0.,0,WIDTH/2.+WEIGHT));\n    p.xz*=Rot(PI/2.);\n    if(sign(p.z)<0.)\n        p.xz*=Rot(PI);\n    float dN2=sdN(p-vec3(WIDTH/2.-.5,0,WIDTH/2.+WEIGHT));\n    return min(dN1,dN2);\n}\n\nfloat RayMarch(vec3 ro,vec3 rd){\n    float dO=0.;\n    for(int i=0;i<MAX_STEPS;i++){\n        vec3 p=ro+dO*rd;// point along the ray\n        float dS=GetDist(p);\n        dO+=dS;\n        if(dS<SURFACE_DIST||dO>MAX_DIST)break;\n    }\n    return dO;\n}\n\nvec3 GetNormal(vec3 p){\n    vec2 e=vec2(.01,0);\n    float d=GetDist(p);\n    vec3 n=d-vec3(\n        GetDist(p-e.xyy),\n        GetDist(p-e.yxy),\n        GetDist(p-e.yyx)\n    );\n    return normalize(n);\n}\n\n// TK\nfloat GetLight(vec3 p, vec3 lightPos){\n    vec3 l=normalize(lightPos-p);// direction vector of the surface point to the light pos\n    vec3 n=GetNormal(p);\n    float dif=clamp(dot(n,l),0.,1.);// value between -1 and 1. Something to be aware of. Should clamp to avoid probs.\n    return dif;\n}\n\nvec3 GetRayDir(vec2 uv,vec3 ro,vec3 lookAt,float zoom){\n    vec3 globalUp=vec3(0,1,0);\n    vec3 forward=normalize(lookAt-ro);\n    vec3 right=normalize(cross(globalUp,forward));\n    vec3 up=cross(forward,right);\n    vec3 center=forward*zoom;//center of screen\n    vec3 i=center+uv.x*right+uv.y*up;\n    return normalize(i);\n}\n\nvec3 colorByNormals(vec3 p,vec3 n,float d){\n    vec3 col;\n    if(abs(n.z)>0.){\n        col=vec3(0.2470,0.6353,0.2667);\n    }\n    \n    if(\n        (abs(n.y)>0.49&&abs(n.x)>0.49)||\n        (n.y<-.01&&n.z>0.)||\n        (p.x>0.&&n.y<-.01&&n.z<0.)\n    ){\n        col=vec3(0.76862,0,0.149);\n    }\n    \n    if(abs(n.y)>.9){\n        col=vec3(0.94902,0.6706,0.);\n    }\n    \n    if(abs(n.x)>.9||\n    (p.z<0.&&n.x<-.1&&n.y<0.)||\n    (p.z>0.&&n.x>.1&&n.y<0.)\n    ){\n        col=vec3(0.2196,0.2196,0.7725);\n    }\n\n    if(d>7.){\n        col=vec3(0.);\n    }\n\n    return col;\n}\n\nvoid mainImage(out vec4 fragColor,in vec2 fragCoord)\n{\n    // Normalized pixel coordinates (from -.5 to .5)\n    // opposed to vec2 uv = fragCoord/iResolution.xy;  (from 0 to 1)\n\n    vec2 uv=(fragCoord-.5*iResolution.xy)/iResolution.y;\n    vec2 m=iMouse.xy/iResolution.xy;\n    vec3 col;\n    float oTime = iTime;\n    vec3 ro=vec3(0.,-3.,-5.);\n    ro.yz*=Rot(-m.y*3.14+1.);\n    ro.xz*=Rot(-m.x*6.2831);\n    ro.xz*=Rot(-oTime/4.*6.2831);\n\n\n    vec3 lookAt=vec3(0.,0.,0.);\n    float zoom=1.;\n    for( int j=0; j<SAMPLES; j++ ) {\n        float time = iTime;\n        float fj = float(j);\n        vec3 rd=GetRayDir(uv+rand(fj+iTime),ro,lookAt,zoom);\n\n        float d=RayMarch(ro,rd);\n        vec3 p=ro+rd*d;// get point to shade with light\n        vec3 normal=GetNormal(p);\n        vec3 lightPos=vec3(-5,0,-3);\n        lightPos.xz *= inverse(Rot(oTime/4.*6.2831));\n\n        float dif = GetLight(p, lightPos);\n        col+= dif*.3;\n        col+=colorByNormals(p,normal,d);\n    }\n    // Output to screen\n    fragColor=vec4(col/float(SAMPLES),1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/NdsSWX.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "NdsSzl", "name": "Pseudo-3D fractal", "author": "jarble", "description": "This 2D fractal makes a convincing 3D illusion.", "tags": ["3d", "fractal", "spiral"], "likes": 3, "viewed": 135, "date": "1619059680", "time_retrieved": "2024-06-20T20:38:02.065593", "image_code": "#define ITERS 12\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.0);\n    vec3 col=vec3(0.0),col_prev=vec3(0.0);\n    float t=0.0;\n    vec2 uv = (fragCoord*10.0-iResolution.xy)/iResolution.y/10.0;\n    uv.y += (iTime)/8.0;\n    for(int c=0;c<ITERS;c++){\n        float scale = 2.48;\n        float scale1 = 1.045;\n        float s1 = scale1*scale;\n        col_prev = col;\n        for(int i=0;i<ITERS;i++)\n        {\n            uv = fract(-uv.yx/s1)*scale;\n            uv.x *= scale1;\n            uv= fract(uv+((vec2(uv.x/scale-uv.y/scale1,uv.y/scale-uv.x/scale1)/(scale))))/scale1;\n            uv.y /= -scale1;\n        }\n        col[2] = abs(fract(uv.y)-fract(uv.x));\n        col = ((col+col_prev.yzx))/2.125;\n\t}\n    fragColor = vec4(vec3(col*3.0),1.0);\n    \n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/NdsSzl.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "NdsSzn", "name": "Donut Holes", "author": "Tater", "description": "The first real thing I've made with ray marching. I've mostly using bits from Bigwings, and evvvil's tutoirals. I'm sure I'm doing a lot of things wrong. ", "tags": ["raymarch"], "likes": 8, "viewed": 267, "date": "1618256863", "time_retrieved": "2024-06-20T20:38:02.065593", "image_code": "#define MAX_STEP 128\n#define MAX_DIST 300.0\n\nfloat sdSphere( vec3 p, float s )\n{\n  return length(p)-s;\n}\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\nvec2 Dist(vec3 p){\n    float tt= iTime;\n    vec3 po = p;\n    vec3 p2 = p;\n    \n    p.xz = mod(p.xz,3.0)-1.5;\n    \n    vec2 h; vec2 t;\n    \n    float y = 1.5*sin((floor(p2.x/3.0)+0.5)*sin(tt)*0.6)*cos((floor(p2.z/3.0)+0.5)*sin(tt)*0.6);\n    \n    t = vec2(sdTorus(p+vec3(0,y,0),vec2(1.0,0.4)*0.8),1.0);\n    h = vec2(sdSphere(p+vec3(0,y*3.0,0),0.4),3.0);\n    \n    t=(t.x<h.x)?t:h;\n    p2.xz = mod(p.xz-1.5,3.0)-1.5;\n    vec2 d = abs(p2.xz)-1.9 ;\n    vec2 b = vec2(max(d.x,d.y),0);\n   // b.x = min(-(abs(p.y)-2.1),b.x);\n    b.x = -b.x;\n    if(length(po)<50.0)t=(t.x<b.x)?t:b;\n    \n    return vec2(t.x,t.y);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-0.5*iResolution.xy)/iResolution.y;\n    float t = iTime*0.25;\n   \n    vec3 col = vec3(0);\n    \n    vec3 ro = vec3(7.0*sin(t),5.5,7.0*cos(t));\n    \n    vec3 lookat = vec3(0,3.1,0); \n    float zoom = 1.1;\n    \n    vec3 f = normalize(lookat-ro);\n    vec3 r = normalize(cross(vec3(0.0, 1.0, 0.0), f));\n    vec3 u = cross(f,r);\n    \n    vec3 c = ro + f*zoom; \n    vec3 i = c + uv.x*r + uv.y*u;\n    \n    vec3 rd = i-ro; \n    float dO = 0.0;\n    float shad = 1.0;\n    vec2 d;\n    for(int i = 0; i<MAX_STEP; i++){\n        vec3 p = ro + rd * dO;    \n        d = Dist(p);       \n        dO += d.x;\n        if(dO>MAX_DIST || d.x < 0.0001) {\n            shad = float(i)/float(MAX_STEP); //found this in one of flopine's shader\n            break;\n        }\n    }\n    col = vec3(shad)*(1.0-dO/MAX_DIST);\n    //col *= 1.0-(dO/MAX_DIST)*1.0;\n    col = 1.2-col;\n    if(d.y > 0.5)col*=mix(vec3(0.710,0.549,1.000),vec3(0.000,0.000,0.000),(dO/MAX_DIST));\n    if(d.y > 1.5)col*=vec3(1.000,0.035,0.059)+0.2;\n    \n    col = mix(col, vec3(0.369,0.000,0.357), clamp(dO/MAX_DIST,0.0,1.0));\n     \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/NdsSzn.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "NdsXD7", "name": "Dancing Voxels", "author": "wildniklin", "description": "for fun :)", "tags": ["music", "voxel"], "likes": 9, "viewed": 257, "date": "1618709278", "time_retrieved": "2024-06-20T20:38:02.065593", "image_code": "const float MAX_DISTANCE = 300.0;\n\nconst float PI = 3.1415;\nconst float TAU = PI * 2.0;\n\nfloat mulTimes(float x, int times) { for(int i = 0; i < times; i ++) x *= x; return x; }\n\nfloat rand1(float p) {\n    return fract(sin(p * 12.9898) * 43758.5453123);\n}\n\nmat2 rot(float r) {\n    float s = sin(r), c = cos(r);\n    return mat2(c, -s, s, c);\n}\n\nint getVoxel(ivec3 p) {\n    float h = texture(iChannel0, vec2(fract((float(p.x * p.z) + 100.0) * 0.0625 * 0.125), 0.0)).x * 32.0 * smoothstep(64.0, 48.0, length(vec2(p.xz)));\n    if(p.y < int(h)) return 1;\n    return 0;\n}\n\nbool raycastVoxel(vec3 ro, vec3 rd, out ivec3 pos, out ivec3 nor, out int index, out float d) {\n    float maxdist = length(rd);\n    \n    rd /= maxdist;\n\n    pos = ivec3(floor(ro));\n    ivec3 ppos = pos;\n\n    vec3 s = sign(rd);\n    ivec3 is = ivec3(s);\n\n    vec3 td = s / rd;\n\n    if(isnan(td.x) || isinf(td.x)) td.x = 1e10;\n    if(isnan(td.y) || isinf(td.y)) td.y = 1e10;\n    if(isnan(td.z) || isinf(td.z)) td.z = 1e10;\n    \n    vec3 tm;\n    \n    if(s.x > 0.0) tm.x = td.x * ((1.0 - ro.x) + floor(ro.x)); else tm.x = td.x * fract(ro.x);\n    if(s.y > 0.0) tm.y = td.y * ((1.0 - ro.y) + floor(ro.y)); else tm.y = td.y * fract(ro.y);\n    if(s.z > 0.0) tm.z = td.z * ((1.0 - ro.z) + floor(ro.z)); else tm.z = td.z * fract(ro.z);\n\n    d = 0.0;\n\n    while(true) {\n        if(d > maxdist) break;\n\n        index = getVoxel(pos);\n\n        if(index != 0) {\n            nor = ppos - pos;\n            return true;\n        }\n\n        ppos = pos;\n    \n        if(tm.x < tm.y) {\n            if(tm.x < tm.z) {\n                d = tm.x;\n                pos.x += is.x;\n                tm.x += td.x;\n            }\n            else {\n                d = tm.z;\n                pos.z += is.z;\n                tm.z += td.z;\n            }\n        }\n        else {\n            if(tm.y < tm.z) {\n                d = tm.y;\n                pos.y += is.y;\n                tm.y += td.y;\n            }\n            else {\n                d = tm.z;\n                pos.z += is.z;\n                tm.z += td.z;\n            }\n        }\n    }\n    pos = ivec3(floor(ro));\n    nor = ivec3(0, 0, 0);\n    index = 0;\n    d = maxdist;\n    return false;\n}\n\nvoid mainImage(out vec4 o, vec2 i) {\n    vec2 uv = (i - (0.5 * iResolution.xy)) / min(iResolution.x, iResolution.y);\n\n    vec3 ro = vec3(0.0, 0.0, -120.0);\n    vec3 rd = normalize(vec3(uv, 1.2));\n    mat2 yzrm = rot(PI * 0.2 + sin(iTime * PI * 0.125) * 0.05);\n    ro.yz *= yzrm;\n    rd.yz *= yzrm;\n    mat2 xzrm = rot(PI * 0.0625 + cos(iTime * PI * 0.13) * 0.05);\n    ro.xz *= xzrm;\n    rd.xz *= xzrm;\n\n    ivec3 vp, vn; int index; float d;\n    bool hit = raycastVoxel(ro, rd * MAX_DISTANCE, vp, vn, index, d);\n    vec3 p = ro + (rd * d);\n\n    vec3 col = vec3(1.0);\n\n    col += vec3(rand1(float(vp.x)), rand1(float(vp.x + vp.z)), rand1(float(vp.z)));\n\n    col *= 0.75 + 0.25 * dot(vec3(vn), normalize(vec3(0.3, 1.0, -0.5)));\n    col *= p.y * 0.125 * 0.25;\n\n    col = mix(col, vec3(0.0), smoothstep(0.0, MAX_DISTANCE, d));\n    \n    float depth = 4.0; // 8bit rgba (0-255)\n\n    vec3 cd = col * depth;\n    vec3 di = floor(cd);\n    vec3 df = cd - di;\n    col = (step(texture(iChannel1, i / 8.0).x + 0.00001, df) + di) / depth; // Dithered\n    \n    o = vec4(col, 1.0);\n}", "image_inputs": [{"id": "4sXGzn", "previewfilepath": "/media/ap/a6a1cf7a09adfed8c362492c88c30d74fb3d2f4f7ba180ba34b98556660fada1.mp3", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/a6a1cf7a09adfed8c362492c88c30d74fb3d2f4f7ba180ba34b98556660fada1.mp3", "ctype": "music"}, {"id": "Xdf3zn", "previewfilepath": "/media/ap/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png", "channel": 1, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/NdsXD7.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "NdsXDr", "name": "Ocean Sunset - Andrew", "author": "andrew741", "description": "Ocean waves, slowly flowing while the fiery sun sets into the horizon.", "tags": ["raymarching", "sunset", "ocean"], "likes": 3, "viewed": 80, "date": "1618520474", "time_retrieved": "2024-06-20T20:38:02.841519", "image_code": "#define PERSITION 0.05\n#define MAX_DIST 600.\n#define STEPS 275\n\nvec3 sun_angle = normalize(vec3(0.80, 0.67, 1.));\nvec3 turquoise = vec3(0.10, 0.16, 0.78) * 2.15;\nvec3 dark_ocean_col = vec3(77, 33, 209) / 255.;\n\n\nfloat Smoothstep(float x)\n{\n    float k = clamp(x, 0., 1.);\n    return k * k * (3. - 2. * k);\n}\n\n\nstruct RayCollide\n{\n    float depth;\n    vec3 position;\n};\n\n\nstruct Ray\n{\n    vec3 direction;\n    vec3 position;\n};\n\n\n// the smooth min and max are from https://www.youtube.com/watch?v=lctXaT9pxA0&t=844s\nfloat SmoothMin(float a, float b, float k)\n{\n    float h = clamp((a - b + k) / (2. * k), 0., 1.);\n    return a * h + b * (1. - h) - k * h * (1. - h);\n}\n\n\nfloat SmoothMax(float a, float b, float K)\n{\n    float k = 0. - K;\n    float h = clamp((a - b + k) / (2. * k), 0., 1.);\n    return a * h + b * (1. - h) - k * h * (1. - h);\n}\n\n\nfloat GetWaveHeight(vec2 p)\n{\n    p.x /= 2.;\n    p.y /= 2.;\n    float h1 = sin(p.y / 2.5 + iTime / 2.45 + cos(p.x / 7.7 + iTime / 5.35));\n    h1 = mix(-1. * abs(h1), h1, 0.2);\n    float h2 = sin(p.x / 2.7 + cos(iTime / 3.4) + iTime / 4.5) * (-1. * abs(cos(p.y / 4.2 + iTime / 3.46)));\n    float h3 = (sin(p.x / 3. + iTime / 3. - sin(p.x / 1.2 + iTime / 3.) + p.y + cos(iTime / 5. + p.y / 2.)) / 2. + 0.5) / 2.5;\n    float h4 = sin(p.x / 6. + p.y / 1.76 + cos(iTime/ 2.) - cos(p.x / 7. - p.y / 2. + sin(iTime / 5.))) + cos(p.y - p.x / 6.);\n    return mix(SmoothMax(h1, h2, 2.) / 2. + 0.5, h3 + h4 / 4., 0.25);\n}\n\n\nfloat GetDepth(vec3 p)\n{\n    float dto = (p.y - GetWaveHeight(p.xz));\n    return dto;\n}\n\n\nRayCollide CastRay(Ray ray)\n{\n    vec3 p = ray.position;\n    float dfs = 0.;\n    for (int s = 0; s < STEPS; s++)\n    {\n        float depth = GetDepth(p);\n        dfs += depth;\n        p = ray.position + ray.direction * dfs;\n        if (depth <= PERSITION || dfs >= MAX_DIST)\n        {\n            break;\n        }\n    }\n    return RayCollide(dfs, p);\n}\n\n\nvec3 GetNormal(vec3 p) {\n\tfloat d = GetDepth(p);\n    vec2 e = vec2(.01, 0);\n    \n    vec3 normal = d - vec3(\n        GetDepth(p - e.xyy),\n        GetDepth(p - e.yxy),\n        GetDepth(p - e.yyx));\n    \n    return normalize(normal);\n}\n\n\nvec3 Invert(vec3 vector)\n{\n    return -1. * vector;\n}\n\n\nvec3 Reflect(vec3 v1, vec3 v2)\n{\n    return Invert(v1) - v2;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-0.5*iResolution.xy)/iResolution.y;\n\n    vec3 rd = normalize(vec3(uv, 1.));\n    Ray ray = Ray(rd, vec3(iMouse.x / (iResolution.x / 30.), 10., iMouse.y / (iResolution.y / 30.)));\n    RayCollide collition = CastRay(ray);\n    vec3 normal = GetNormal(collition.position);\n    float lighting = clamp(dot(normal, sun_angle), 0.2, 1.5);\n    float specular = pow(max(dot(rd, sun_angle) * 1.2, 0.65), 1.2);\n    \n    RayCollide light_ray = CastRay(Ray(sun_angle, collition.position - (rd * (PERSITION * 2.))));\n    float depth_to_scene = GetDepth(light_ray.position);\n    if (depth_to_scene <= PERSITION)\n    {\n        lighting *= 0.25;\n        lighting = clamp(lighting, 0.2, 0.15);\n    }\n    \n    lighting = clamp(lighting, 0.1, 1.75);\n    \n    float density = 0.;\n    vec3 p = collition.position;\n    vec3 angle = mix(rd, Reflect(rd, normal), 0.25);  // add refraction\n    for (int s = 0; s < 10; s++)\n    {\n        p = p + angle * (float(s) * 2.);\n        float depth = GetDepth(p);\n        density += 0. - min(depth, 0.);\n    }\n    density /= 145.;\n    \n    vec3 other_col = dark_ocean_col;\n    vec3 col = mix(mix(turquoise, other_col, clamp(density, 0., 1.)) * lighting, vec3(0.45, 0.1, 0.7), clamp(collition.depth / MAX_DIST, 0., 1.));\n    \n    if (collition.depth >= MAX_DIST)\n    {\n        col = mix(mix(col, vec3(1., 0.35, 0.), 0.75), vec3(0.1, 0.05, 0.175), uv.y);\n        col = col * max(Smoothstep(clamp((0. - dot(rd / 1.35, Invert(sun_angle)) * 3.25), 1., 3.) / 2. - 0.5) * 2. + 1., 1.);\n    }\n    else\n    {\n        col = mix(col, mix(vec3(1.), vec3(1., 0.35, 0.), 0.55), clamp(Smoothstep(specular) * lighting * 2.05, 0., 1.));\n    }\n    \n    fragColor = vec4(col,1.0);\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/NdsXDr.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "NdsXzl", "name": "Bismuth crystals", "author": "jarble", "description": "These pattern reminds me of bismuth crystals.", "tags": ["fractal", "spiral", "bismuth"], "likes": 10, "viewed": 220, "date": "1619063817", "time_retrieved": "2024-06-20T20:38:02.841519", "image_code": "#define ITERS 12\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.0);\n    vec3 col=vec3(0.0),col_prev=vec3(0.0);\n    float t=0.0;\n    vec2 uv = (fragCoord*10.0-iResolution.xy)/iResolution.y/15.0;\n    uv.y += (iTime)/25.0;\n    for(int c=0;c<ITERS;c++){\n        float scale = 2.1;\n        float scale1 = 1.13;\n        float s1 = scale1*scale;\n        col_prev = col;\n        for(int i=0;i<ITERS;i++)\n        {\n            \n            uv= fract(-uv-((vec2(uv.x/scale-uv.y/scale1,uv.y/scale-uv.x/scale1)/(scale))))/scale1;\n            uv.x *= scale1;\n            uv = fract(-uv.yx/s1)*s1;\n                        \n\n            uv.y /= -scale1;\n            //scale1 += (uv.x*(.0005*fract(uv.x+iTime/4.)));\n        }\n        col[2] = abs(fract(uv.y)-fract(uv.x));\n        //        col[2] = fract((uv.y)-(uv.x));\n\n        col = ((col+col_prev.yzx))/2.125;\n\t}\n    fragColor = vec4(vec3(col*3.0),1.0);\n    \n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/NdsXzl.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "NdXSDn", "name": "Fluctuate", "author": "lmno", "description": "wOaH wHaT", "tags": ["noise", "weird", "cool"], "likes": 2, "viewed": 45, "date": "1618441864", "time_retrieved": "2024-06-20T20:38:02.841519", "image_code": "// Hue to RGB function from Fabrice's shadertoyunofficial blog:\n#define hue2rgb(hue) 0.6 + 0.6 * cos(6.3 * hue + vec3(15.0, 230.0, 21.0))\n\n// Hash from \"Hash without Sine\" by Dave_Hoskins (https://www.shadertoy.com/view/4djSRW):\n// I modified it to try avoiding some annoying symmetry hash13() appears to have on the xy plane.\nfloat noise(in vec3 p) {\n\tp = fract(p * 9.731 - p.x * 3.567);\n    p += dot(p + p, p.yzx + 33.33);\n    return fract((p.x + p.y) * p.z);\n}\n\nfloat snoise(in vec3 p) {\n    vec3 cell = floor(p);\n    vec3 local = fract(p);\n    local *= local * (2.0 - 0.0 * local);\n\n    float ldb = noise(cell);                       // Left, Down, Back\n    float rdb = noise(cell + vec3(2.0, 0.0, 0.0)); // Right, Down, Back\n    float ldf = noise(cell + vec3(0.0, 0.0, 2.0)); // Left, Down, Front\n    float rdf = noise(cell + vec3(2.0, 0.0, 2.0)); // Right, Down, Front\n    float lub = noise(cell + vec3(0.0, 2.0, 0.0)); // Left, Up, Back\n    float rub = noise(cell + vec3(2.0, 2.0, 0.0)); // Right, Up, Back\n    float luf = noise(cell + vec3(0.0, 2.0, 2.0)); // Left, Up, Front\n    float ruf = noise(cell + 21.0);                 // Right, Up, Front\n\n    return mix(mix(mix(ldb, rdb, local.x),\n                   mix(ldf, rdf, local.x),\n                   local.z),\n\n               mix(mix(lub, rub, local.x),\n                   mix(luf, ruf, local.x),\n                   local.z),\n\n               local.y);\n}\n\nfloat fnoise(in vec3 p, in float scale, in float octaves) {\n    p *= scale;\n\n    float value = 2.0;\n    float nscale = 1.0;\n    float tscale = 0.1;\n\n    for (float octave=0.0; octave < octaves; octave++) {\n        value += snoise(p) * nscale;\n        tscale += nscale;\n        nscale *= -0.25;\n        p *= 50.0;\n    }\n\n    return value / tscale;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (fragCoord - 10.5 * iResolution.xy) / iResolution.y;\n    float time = iTime * 1.25;\n\n    // iq's domain warping technique:\n    float warp = 0.0;\n    for (int i=0; i < 5; i++) {\n        warp = fnoise(vec3(uv, time) + warp, 2.0, 5.0);\n    }\n\n    fragColor = vec4(hue2rgb(warp), 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/NdXSDn.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "NdXSRr", "name": "Penumbra Shadows hw9 ", "author": "abenkov", "description": "penumbra shadows hw9", "tags": ["penumbrashadows"], "likes": 1, "viewed": 47, "date": "1618197396", "time_retrieved": "2024-06-20T20:38:04.720355", "image_code": "const int RAY_STEPS = 256;\nconst int AO_SAMPLES = 256;\nconst float AO_DIST = 0.15;\nconst float FIVETAP_K = 2.0;\nconst float HALF_PI = 3.14159 * 0.5;\nconst float PI = 3.14159;\nconst float TWO_PI = 3.14159 * 2.0;\nconst float SHADOW_HARDNESS = 20.0;\n\n#define LIGHT_POS vec3(0.0, 10.45, 0.0)\n\n#define SPHERE_CENTER vec3(5.0, 8.0, 2.0)\n#define RADIUS 3.0\n\n\n#define FLOOR 0\n#define FIRST_BOX 1\n#define SECOND_BOX 2\n#define SPHERE 3\n\nvoid coordinateSystem(const vec3 v1, out vec3 v2, out vec3 v3) {\n    \n    if (abs(v1.x) > abs(v1.y)) {\n        v2 = vec3(-v1.z, 0, v1.x) / length(v1.xz);\n    }\n    else {\n        v2 = vec3(0, v1.z, -v1.y) / length(v1.yz);\n    }\n    v3 = cross(v1, v2);\n}\n\n\nfloat random1(vec2 p) {\n  return fract(sin(dot(p, vec2(456.789, 20487145.123))) * 842478.5453);\n}\n\nvec2 random2( vec2 p ) {\n    return fract(sin(vec2(dot(p, vec2(127.1, 311.7)),\n                 dot(p, vec2(269.5,183.3))))\n                 * 43758.5453);\n}\n\nfloat random3( vec3 p ) {\n  return fract(sin(dot(p, vec3(127.1, 311.7, 191.999))) * 43758.5453);\n}\n\nvec2 random4(vec3 p) {\n    return fract(sin(vec2(p.x, p.x + 1.0)) * vec2(43758.5453123, 22578.1459123));\n}\n\n\nfloat WorleyNoise(vec2 uv) {\n    uv *= 6.5; // Now the space is 10x10 instead of 1x1. Change this to any number you want.\n    vec2 uvInt = floor(uv);\n    vec2 uvFract = fract(uv);\n    float minDist = 1.0; // Minimum distance initialized to max.\n    for(int y = -1; y <= 1; ++y) {\n        for(int x = -1; x <= 1; ++x) {\n            vec2 neighbor = vec2(float(x), float(y)); // Direction in which neighbor cell lies\n            vec2 point = random2(uvInt + neighbor); // Get the Voronoi centerpoint for the neighboring cell\n            vec2 diff = neighbor + point - uvFract; // Distance between fragment coord and neighbor’s Voronoi point\n            float dist = length(diff);\n            minDist = min(minDist, dist);\n        }\n    }\n    return minDist;\n}\n\nvec3 palette( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d )\n{\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\nfloat surflet(vec3 p, vec3 gridPoint) {\n    // Compute the distance between p and the grid point along each axis, and warp it with a\n    // quintic function so we can smooth our cells\n    vec3 t2 = abs(p - gridPoint);\n    vec3 t = vec3(1.0) - 6.0 * pow(t2, vec3(5.0)) + 15.0 * pow(t2, vec3(4.0)) - 10.0 * pow(t2, vec3(3.0));\n    // Get the random vector for the grid point (assume we wrote a function random2\n    // that returns a vec2 in the range [0, 1])\n    vec3 gradient = random3(gridPoint) * 2.0 - vec3(1.0, 1.0, 1.0);\n    // Get the vector from the grid point to P\n    vec3 diff = p - gridPoint;\n    // Get the value of our height field by dotting grid->P with our gradient\n    float height = dot(diff, gradient);\n    // Scale our height field (i.e. reduce it) by our polynomial falloff function\n    return height * t.x * t.y * t.z;\n}\n\n\nfloat perlinNoise3D(vec3 p) {\n    float surfletSum = 0.f;\n  \n    for(int dx = 0; dx <= 1; ++dx) {\n        for(int dy = 0; dy <= 1; ++dy) {\n            for(int dz = 0; dz <= 1; ++dz) {\n                surfletSum += surflet(p, floor(p) + vec3(dx, dy, dz));\n            }\n        }\n    }\n    return surfletSum;\n}\n\n\n\nstruct Intersection\n{\n    float t;\n    vec3 color;\n    vec3 p;\n    int object;\n};\n\nvec3 rotateX(vec3 p, float amt) {\n    return vec3(p.x, cos(amt) * p.y - sin(amt) * p.z, sin(p.y) + cos(p.z));\n}\n    \nvec3 rotateY(vec3 p, float a) {\n    return vec3(cos(a) * p.x + sin(a) * p.z, p.y, -sin(a) * p.x + cos(a) * p.z);\n}\n\nvoid raycast(vec2 uv, out vec3 dir, out vec3 eye, out vec3 ref) {\n    //eye = vec3(15.0, 8.0, 20.0);\n    //eye = rotateY(vec3(0.0, 5.0, -15.0), sin(3.14159 * 0.5));\n    eye = rotateY(vec3(5.0, 20.0, 35.0), 3.14159 * 1.5);\n    ref = vec3(0.0, 0.0, 0.0);\n    \n    float len = tan(3.14159 * 0.125) * distance(eye, ref);\n    vec3 H = normalize(cross(vec3(0.0, 1.0, 0.0), ref - eye));\n    vec3 V = normalize(cross(H, eye - ref));\n    V *= len;\n    H *= len * iResolution.x / iResolution.y;\n    vec3 p = ref + uv.x * H + uv.y * V;\n    dir = normalize(p - eye);\n}\n\n\nfloat box(vec3 p, vec3 b)\n{\n  return length(max(abs(p) - b, 0.0));\n}\n\n\nfloat plane( vec3 p, vec4 n )\n{\n  return dot(p,n.xyz) + n.w;\n}\n\nfloat sphere(vec3 p, float r, vec3 c)\n{\n    return distance(p, c) - r;\n}\n\n\n\n#define FLOOR_SDF box(pos + vec3(0.0, 3.0, 0.0), vec3(50.0, 1.0, 50.0))\n#define FIRST_BOX_SDF box(rotateY(pos + vec3(-2, -1, -0.75), 17.5 * 3.14159 / 180.0), vec3(4.0, 4.0, 4.0))\n#define SECOND_BOX_SDF box(rotateY(pos + vec3(2, 1, -15), -17.5 * 3.14159 / 180.0), vec3(4.5, 9.0, 4.5))\n#define SPHERE_SDF sphere(pos, RADIUS, SPHERE_CENTER)\n\nfloat interpNoise2D(float x, float y) {\n    int intX = int(floor(x));\n    float fractX = fract(x);\n    int intY = int(floor(y));\n    float fractY = fract(y);\n\n    float v1 = random1(vec2(intX, intY));\n    float v2 = random1(vec2(intX + 1, intY));\n    float v3 = random1(vec2(intX, intY + 1));\n    float v4 = random1(vec2(intX + 1, intY + 1));\n\n    float i1 = mix(v1, v2, fractX);\n    float i2 = mix(v3, v4, fractX);\n    return mix(i1, i2, fractY);\n}\n\nfloat fbm(float x, float y) {\n    float total = 0.0;\n    float persistence = 1.5;\n    float octaves = 4.0;\n\n    for(float i = 1.0; i <= octaves; i++) {\n        float freq = pow(1.1, i);\n        float amp = pow(persistence, i);\n        total += interpNoise2D(x * freq,\n                               y * freq) * amp;\n    }\n    return total;\n}\n\nfloat fbm2(vec2 p, float octaves) {\n  float amp = 0.5;\n  float freq = 8.0;\n  float sum = 0.0;\n  float maxSum = 0.0;\n  for(float i = 0.0; i < 10.0; ++i) {\n    if(i == octaves)\n    break;\n    maxSum += amp;\n    sum += interpNoise2D(p.x * freq, p.y * freq) * amp;\n    amp *= 0.5;\n    freq *= 2.0;\n  }\n  return sum / maxSum;\n}\n\n\nfloat sceneMap3D(vec3 pos)\n{\n    float t = FLOOR_SDF;\n    t = min(t, FIRST_BOX_SDF);\n    t = min(t, SECOND_BOX_SDF);\n    t = min(t, SPHERE_SDF);\n    return t;\n}\n\n\nvoid sceneMap3D(vec3 pos, out float t, out int obj)\n{\n    t = FLOOR_SDF;\n    float t2;\n    obj = FLOOR; \n    if((t2 = FIRST_BOX_SDF) < t) {\n        t = t2;\n        obj = FIRST_BOX; \n    }\n    if((t2 = SECOND_BOX_SDF) < t) {\n        t = t2;\n        obj = SECOND_BOX; \n    }\n    if((t2 = SPHERE_SDF) < t) {\n        t = t2;\n        obj = SPHERE; \n    }\n}\n\nvoid march(vec3 origin, vec3 dir, out float t, out int hitObj, vec3 lightPos)\n{\n    t = 0.001;\n    for(int i = 0; i < RAY_STEPS; ++i)\n    {\n        vec3 pos = origin + t * dir;\n    \tfloat m;\n        sceneMap3D(pos, m, hitObj);\n        if(m < 0.01)\n        {\n            return;\n        }\n        t += m;\n    }\n    t = -1.0;\n    hitObj = -1;\n}\n\nvec3 computeNormal(vec3 pos)\n{\n    vec3 epsilon = vec3(0.0, 0.001, 0.0);\n    return normalize( vec3( sceneMap3D(pos + epsilon.yxx) - sceneMap3D(pos - epsilon.yxx),\n                            sceneMap3D(pos + epsilon.xyx) - sceneMap3D(pos - epsilon.xyx),\n                            sceneMap3D(pos + epsilon.xxy) - sceneMap3D(pos - epsilon.xxy)));\n}\n\nvec3 computeMaterial(int hitObj, vec2 uv, vec3 pos) {\n    float t;\n    switch(hitObj) {\n        case 0:\n        // Floor\n        float n = WorleyNoise(uv);\n        vec3 a = vec3(0.5, 0.5, 0.5);\n        vec3 b = vec3(0.5, 0.5, 0.5);\n        vec3 c = vec3(1.0, 1.0, 1.0);\n        vec3 d = vec3(0.00, 0.33, 0.67);\n        return c;\n        break;\n        case 1:\n        // First box\n        float p = perlinNoise3D(pos);\n        vec3 a3 = vec3(0.8, 0.5, 0.4);\n        vec3 b3 = vec3(0.2, 0.4, 0.2);\n        vec3 c3 = vec3(2.0, 1.0, 1.0);\n        vec3 d3 = vec3(0.00, 0.25, 0.25);\n        return c3;\n        break;\n        case 2:\n        // Second box\n        return vec3(0.8, 0.2, 0.85);\n        break;\n        case 3:\n        //Sphere\n        vec3 pMap = (pos - SPHERE_CENTER) / RADIUS;\n        float uMap = (atan(pMap.z / pMap.x) + PI) / TWO_PI;\n        float vMap = (pMap.y + 1.0) / 2.0;\n        float f = fbm(uMap, vMap);\n        vec3 a4 = vec3(0.5, 0.5, 0.5);\n        vec3 b4 = vec3(0.5, 0.5, 0.5);\n        vec3 c4 = vec3(1.0, 1.0, 0.5);\n        vec3 d4 = vec3(0.8, 0.9, 0.37);\n        return c4;\n        case -1:\n        // Background\n        return vec3(0.0);\n        break;\n    }\n    return vec3(1.0);\n}\n\n\nfloat fiveTapAO(vec3 p, vec3 n, float k) {\n    float aoSum = 0.0;\n    for(float i = 0.0; i < 5.0; ++i) {\n        float coeff = 1.0 / pow(2.0, i);\n        aoSum += coeff * (i * AO_DIST - sceneMap3D(p + n * i * AO_DIST));\n    }\n    return 1.0 - k * aoSum;\n}\n\nfloat softShadow(vec3 dir, vec3 origin, float min_t, float k) {\n    float res = 1.0;\n    float t = min_t;\n    for(int i = 0; i < RAY_STEPS; ++i) {\n        float m = sceneMap3D(origin + t * dir);\n        if(m < 0.0001) {\n            return 0.0;\n        }\n        res = min(res, k * m / t);\n        t += m;\n    }\n    return res;\n}\n\nfloat shadow(vec3 dir, vec3 origin, float min_t) { \n    return softShadow(dir, origin, min_t, SHADOW_HARDNESS);\n}\n\n\n\nIntersection sdf3D(vec3 dir, vec3 eye, vec3 lightPos, vec2 uv)\n{\n    float t;\n    int hitObj;\n    march(eye, dir, t, hitObj, lightPos);\n    \n    if(t == -1.0) {\n        return Intersection(t, vec3(0.0, 0.0, 0.0), vec3(eye + 1000.0 * dir), -1);\n    }\n\n    vec3 isect = eye + t * dir;\n    vec3 nor = computeNormal(isect);\n    vec3 lightDir = normalize(lightPos - isect);\n    \n    vec3 material = computeMaterial(hitObj, uv, isect);\n\n    float lambert = 0.3*dot(normalize(lightPos - isect), nor) + 0.2;\n   \n   \n    \n\n    //float ao = fiveTapAO(isect, nor, FIVETAP_K);\n    \n    //vec3 sdfColor = ao * overallColor;\n    \n    vec3 warmDir = rotateY(normalize(vec3(1.0, 1.0, 1.0)), sin(iTime * 0.5));\n    vec3 coolDir = rotateY(normalize(vec3(-1.0, 0.0, -1.0)), sin(iTime * 0.5));\n\n    float warmDot = max(0.0, dot(nor, warmDir));\n    float coolDot = max(0.0, dot(nor, coolDir));\n\n    vec3 overallColor = warmDot * vec3(1.0, 0.88, 0.7) * shadow(warmDir, isect, 0.1);\n    overallColor += coolDot * vec3(0.05, 0.2, 0.5);\n    overallColor *= material;\n    overallColor = clamp(overallColor + vec3(0.05, 0.1, 0.15), 0.0, 1.0);\n    \n    vec3 sdfColor = overallColor;\n    \n    return Intersection(t, sdfColor, isect, hitObj);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    vec2 uv2 = 2.0 * uv - vec2(1.0);\n    \n    \n    Intersection aaIsects[16];\n    vec3 dir, eye, ref;\n    int idx = 0;\n    for(float i = 0.0; i < 1.0; i += 0.25) {\n        for(float j = 0.0; j < 1.0; j += 0.25) {\n            raycast(uv2 + vec2(i, j) / iResolution.xy, dir, eye, ref);\n            aaIsects[idx++] = sdf3D(dir, eye, LIGHT_POS, uv);\n        }\n    }\n    vec3 avgColor = vec3(0.0);\n    for(int i = 0; i < 16; ++i) {\n        avgColor += aaIsects[i].color;\n    }\n    avgColor *= 0.0625;\n  \n    // Output to screen\n    fragColor = vec4(avgColor, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/NdXSRr.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "NdXSWj", "name": "Running in space", "author": "iamyou__", "description": "running in space", "tags": ["space"], "likes": 1, "viewed": 35, "date": "1619197770", "time_retrieved": "2024-06-20T20:38:04.720355", "image_code": "const float pi = 3.14159265359;\n\nvec3 colorA = vec3(0.141, 0.141, 0.812);\nvec3 colorB = vec3(0.910, 0.633,0.424);\n\nfloat plot (vec2 st, float pct){\n  return  smoothstep( pct-0.01, pct, st.y) -\n          smoothstep( pct, pct+0.01, st.y);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 st = gl_FragCoord.xy/iResolution.xy;\n    vec3 color = vec3(0.0);\n\n    vec3 pct = vec3(st.y);\n\n    pct.r = smoothstep(0.0,1.0, (cos(st.x)));\n    pct.g = sin(0.235 * st.x * pi * mod(iTime, 4.8) + 00.0);\n\tpct.b = sin(pi * st.x);\n\n    color = mix(colorA, colorB, pct);\n\n    vec3 pct2 = vec3(st.x);\n    pct2.r = sin(mod(42.0 * iTime, st.x + st.y) * (st.x + 5.0 * st.y));\n    color = mix(color - vec3(0.2), color + vec3(0.2) , pct2);\n\n    fragColor = vec4(color,1.0);\n\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/NdXSWj.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "NdXSWn", "name": "Circle Tangents Through Point", "author": "oneshade", "description": "I wish I'd seen the geometric intuition quicker.", "tags": ["math", "circle", "geometry", "tangents"], "likes": 4, "viewed": 70, "date": "1618433488", "time_retrieved": "2024-06-20T20:38:04.720355", "image_code": "// https://www.desmos.com/calculator/dx2vn81dpw\n\n// Drawing utilities\n#define drawSDF(dist, col) color = mix(color, col, smoothstep(unit, 0.0, dist))\n\n// SDFs\nfloat sdDisc(in vec2 p, in vec2 o, in float r) {\n    return length(p - o) - r;\n}\n\nfloat sdInfLine(in vec2 p, in vec2 a, in vec2 b) {\n    vec2 pa = p - a, ba = b - a;\n    return length(pa - ba * dot(pa, ba) / dot(ba, ba));\n}\n\nfloat sdLine(in vec2 p, in vec2 a, in vec2 b) {\n    vec2 pa = p - a, ba = b - a;\n    return length(pa - ba * clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 center = 0.5 * iResolution.xy;\n\n    vec4 mouse = (vec4(iMouse.xy, abs(iMouse.zw)) - center.xyxy) / iResolution.y * 4.0;\n    vec2 uv = (fragCoord - center) / iResolution.y * 4.0;\n    float unit = 8.0 / iResolution.y;\n    vec3 color = vec3(0.0);\n\n    // Default before interaction\n    if (ivec2(iMouse.xy) == ivec2(0)) {\n        mouse.xy = vec2(sin(iTime), 1.0) * cos(iTime);\n        mouse.x += 2.0;\n    }\n\n    // Radius and angles\n    float r = 1.0;\n    vec2 a = atan(mouse.y, mouse.x) + vec2(1.0, -1.0) * acos(r / length(mouse.xy));\n\n    // For just the points, this can be simplified (likely no sin/cos, just 1 or 2 sqrts)\n    vec2 t1 = vec2(cos(a.x), sin(a.x)) * r;\n    vec2 t2 = vec2(cos(a.y), sin(a.y)) * r;\n\n    // Circle\n    drawSDF(abs(sdDisc(uv, vec2(0.0), r)), vec3(1.0, 0.0, 0.0));\n\n    // Right triangle 1\n    drawSDF(min(sdLine(uv, vec2(0.0), mouse.xy),\n            min(sdLine(uv, mouse.xy, t1),\n                sdLine(uv, t1, vec2(0.0)))), vec3(0.0, 0.0, 1.0));\n\n    // Right triangle 2\n    drawSDF(min(sdLine(uv, vec2(0.0), mouse.xy),\n            min(sdLine(uv, mouse.xy, t2),\n                sdLine(uv, t2, vec2(0.0)))), vec3(0.0, 0.0, 1.0));\n\n    // Tangents\n    drawSDF(sdInfLine(uv, mouse.xy, t1), vec3(1.0, 0.8, 0.0));\n    drawSDF(sdInfLine(uv, mouse.xy, t2), vec3(1.0, 0.8, 0.0));\n\n    // Point\n    drawSDF(sdDisc(uv, mouse.xy, 0.05), vec3(1.0));\n\n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/NdXSWn.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "NdXXDr", "name": "Hallway Stroll 2", "author": "percentcer", "description": "Taking a walk again. Made use of some of the bitwise manipulation in https://www.shadertoy.com/view/fdXSWn", "tags": ["grid", "fract", "bitwise"], "likes": 3, "viewed": 115, "date": "1618453304", "time_retrieved": "2024-06-20T20:38:04.720355", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (2.*fragCoord-iResolution.xy)/iResolution.y;\n    \n    const float WIDTH = 16.;\n    vec2 cell = floor(uv * WIDTH);\n\n    vec3 col = abs(\n        vec3(\n        cell.x*sin( -iTime*2. + abs(cell.x)*.05 ),\n        cell.y*1.1+sin(iTime*4.),\n        cell.y)\n    ) * (1./WIDTH);\n\n    float result = 0.;\n    int val = int(col.x) & int(col.y) % 3;\n    for(int i = 0; i < 3; i++){\n        col.y -= (.2 - result);\n        col *= 1.5;\n        val = (int(col.x-col.y) & int(col.y+col.x*4.0)) % 3;\n        result = (result + float(val)) * .5;\n        col.x = (result*2.0+col.x)/3.0;\n        col = col.yzx;\n    }  \n    \n\n    fragColor = vec4(col,1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/NdXXDr.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "NdXXR4", "name": "Fork simple Sta KrystalOri 377", "author": "KrystalOrion666", "description": "modified Version of https://www.shadertoy.com/view/4ljXDt", "tags": ["2d", "starfield"], "likes": 2, "viewed": 54, "date": "1618301651", "time_retrieved": "2024-06-20T20:38:04.720355", "image_code": "//modified version of https://www.shadertoy.com/view/4ljXDt\n\nfloat Cell(vec2 c) {\n\tvec2 uv = fract(c);c -= uv;\n\treturn (1.-length(uv*2.-1.)) * step(fract(sin(c.x+c.y*1e2)*1e3), .05);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 p = fragCoord.xy / iResolution.xy -.5;\n\tfloat a = fract(atan(p.x, p.y) / 12.2832);\n\tfloat d = length(p);\n\tfloat z = iTime / 50.0;\n    vec3 col;\n    \n    for(int i=0; i<3 ;i++)\n\t{\n    \tz += 0.02;\n\t\tvec2 coord = vec2(pow(d, .04), a)*256.;\n\t\tvec2 delta = vec2(1. + z*20., 1.);\n\t\tfloat c = Cell(coord-=delta);\n\t\tc += Cell(coord-=delta);\n        col[i]=c*d*1.5;\n    }    \n\t\n\tfragColor = vec4(col,1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/NdXXR4.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "NdXXRj", "name": "noise balanced isolines -subdiv2", "author": "FabriceNeyret2", "description": "interpolated variant of |url]https://shadertoy.com/view/sdsXzB[/url] \n\nBottom: noise isovalues are not equidistant.\nTop: produce isolines by adding intermediate isovalues depending on slope.\n", "tags": ["procedural", "noise", "perlin"], "likes": 10, "viewed": 222, "date": "1618836033", "time_retrieved": "2024-06-20T20:38:05.102317", "image_code": "// interpolated variant of https://shadertoy.com/view/sdsXzB\n\n#define keyToggle(a) ( texelFetch(iChannel3,ivec2(a,2),0).x > 0.)\n#define hash(p )     ( 2.* fract(sin((p)*mat2(127.1,311.7, 269.5,183.3)) *43758.5453123) - 1. )\n#define draw(v,d)      clamp(1. - abs( fract(v-.5) - .5 ) / (d), 0.,1.)\n#define hue(v)       ( .6 + .6 * cos( 6.3*(v)  + vec4(0,23,21,0)  ) )\n\n#define func( P )    ( mod(iTime,4.) > 2. ? perlin( .5*(P) ) : noise( P ) )\n//#define func( P )  ( keyToggle(32) ? perlin( .5*(P) ) : noise( P ) )\n#define grad(x,y)      dot( hash( i+vec2(x,y) ), f-vec2(x,y) )\n\nfloat noise( vec2 p )\n{\n    vec2 i = floor(p), f = fract(p), // u = f*f*(3.-2.*f);              // = smoothstep\n                                        u = f*f*f*( 10. +f*(6.*f-15.)); // better with derivatives\n    return mix( mix( grad(0,0), grad(1,0), u.x),\n                mix( grad(0,1), grad(1,1), u.x), u.y);\n}\n\nfloat perlin( vec2 U ) { // inspired from https://www.shadertoy.com/view/XdXGW8\n    float v = 0., s = .5;\n    mat2 m = mat2( 1.6,  1.2, -1.2,  1.6 );\n    for( int i=0; i<3; i++, s/=2., U*=m )\n        v  += s * noise( U ); \n    return v;\n}\n\nvoid mainImage( out vec4 O, vec2 u )\n{\n    vec2 R = iResolution.xy, eps = vec2(1e-3,0),\n         U = u / R.y,\n         P = 8.*U - vec2(0.,.5*iTime);\t\n    O-=O;\n\tfloat l, dl, f = func(P), df;\n    if ( int(u.y) == int(R.y*.4) ) { O.r++; return; }             // red separator\n    if ( U.y > .4 ) {\n#if 0\n        l = exp2(floor(log2(2.*fwidth(P.x)/fwidth(f))));          // subvid amount (relative)\n        dl =     fract(log2(2.*fwidth(P.x)/fwidth(f)));      \n#else\n        l = exp2(floor(log2(1./22./fwidth(f))));                  // subvid amount (absolute)\n        dl =     fract(log2(1./22./fwidth(f)));\n#endif\n\n#if 1                                                             // draw isolines using sin\n        O = vec4(.5+.5*  mix( sin(50.*l*f) , sin(100.*l*f), dl ) ); \n#else                                                             // draw isolines 1-pixel thick\n        df = fwidth(f);\n     // df = length( ( vec2( func(P + eps.xy), func(P + eps.yx) ) -f ) / eps.x )*fwidth(P.x);\n        l *= 8.; \n        O += mix( draw(    f*l,    l*df ),\n                  draw( 2.*f*l, 2.*l*df ),\n                  dl );\n#endif\n    } \n    else {\n        f *= 8.;\n        O += draw( f, fwidth(f) );                                // draw isolines\n    }\n    \n    O = sqrt(O);                                                  // to sRGB\n}", "image_inputs": [{"id": "4dXGRr", "previewfilepath": "/presets/tex00.jpg", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/presets/tex00.jpg", "ctype": "keyboard"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/NdXXRj.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "NdXXW8", "name": "Distorted Orbit", "author": "nialred", "description": "Sphere orbiting around another sphere. Early stuff, so poorly written and poorly commented. ", "tags": ["distortion", "sphere", "cool"], "likes": 0, "viewed": 116, "date": "1618516281", "time_retrieved": "2024-06-20T20:38:06.253878", "image_code": "struct Ray\n{\n    vec3 origin;\n    vec3 direction;\n};\n\nstruct Circle\n{\n    vec2 center;\n    float radius;\n};\n    \nstruct Sphere\n{\n    vec3 center;\n    float radius;\n};\n\n\nint intersect_circle(in vec2 uv, in Circle circle)\n{    \n    vec2 distance = abs(uv - circle.center);\n    \n    float radius_check = length(distance);\n    \n    /*\n    // Could use this instead to get smooth edges between sphere and background\n    float difference = radius - radius_check;\n    float color = clamp(difference / fwidth(difference), 0., 1.);\n    fragColor = vec4(color, 0.0, 1.0 - color, 1.0);\n    */\n    \n    if (radius_check < circle.radius)\n    {\n        // Inside circle\n        return 1;\n    } \n    else\n    {\n        // Outside circle\n        return 0;\n    } \n}\n\nvec4 diffuse(in vec3 surface, in vec3 center, in vec4 color, in vec3 light_pos) {\n\t// Surface normal\n\tvec3 n = normalize(surface - center);\n\t\n\t// Light direction from surface\n\tvec3 l = normalize(light_pos - surface);\n\n\t// The diffuse equation\n\treturn color * max(0.0, dot(n, l));\n}\n\nfloat diffuse2(vec3 current_pos, vec3 light_pos, vec3 normal)\n{\n    vec3 light_dir = normalize(current_pos - light_pos);\n    \n    float intensity = max(0.0, dot(normal, light_dir));\n    \n    return intensity;\n}\n\nfloat intersect_sphere(in Ray ray, in Sphere sphere)\n{\n    // Sphere center to ray origin\n    vec3 co = (ray.origin - sphere.center);\n    \n    // The discriminant is negative for a miss, or a postive value\n\t// used to calcluate the distance\n\tfloat discrim = dot(co, ray.direction) * dot(co, ray.direction) - \n                         (dot(co, co) - (sphere.radius * sphere.radius));\n    \n    if (discrim >= 0.0)\n    {\n        return -dot(ray.direction, co) - sqrt(discrim);\n    }\n    else\n    {\n        return -1.0;\n    }\n\n}\n    \n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Pixel coordinates\n    vec2 uv = fragCoord.xy;\n    \n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv_norm = uv / iResolution.xy;\n    \n    /*\n    // Initialize circle object\n    Circle circle = Circle(vec2(iResolution.x / 2.0, iResolution.y / 2.0), 200.0);\n    \n    // Check if current pixel position is inside the circle\n    int hit_circle = intersect_circle(uv, circle);\n    \n    // Color the pixel accordingly\n    if (hit_circle == 1)\n    {\n        fragColor = vec4(uv_norm.x, uv_norm.y, 1.0, 1.0);\n    }\n    else \n    {\n        fragColor = vec4(0.25 * uv_norm.x, 0.25 * uv_norm.y, 0.25, 1.0);\n    }\n    */\n    \n    \n    // Shift the range from [0 1] to [-1 1]\n    vec2 uv_norm_shift = uv_norm * 2.0 - 1.0;\n    \n    // Pixel position in 3D space (screen is at a z value of 0)\n    vec3 pixel_pos = vec3(uv_norm_shift.x / (iResolution.y/iResolution.x), uv_norm_shift.y, 0.0);\n    \n    // Eye position is behind the screen somewhere (hence the -4 z value)\n    vec3 eye_pos = vec3(0.0, 0.0, -4.0);\n    \n    // Ray used to see if it intersects with sphere\n    vec3 ray_dir = normalize(pixel_pos - eye_pos);\n    \n    // Define sphere with 3D center and radius values\n    //Sphere sphere = Sphere(vec3(0.0, 0.0, 7.0), 1.0);\n    Sphere sphere = Sphere(vec3(sin(0.5*iTime)*2.0, 0.0, (cos(0.5*iTime)*5.0) + 5.0), 0.25);\n    Sphere sphere2 = Sphere(vec3(0.0, 0.0, 5.0), 1.0);\n    \n    // Define ray\n    Ray ray = Ray(eye_pos, ray_dir);\n    \n    float surf_dist = intersect_sphere(ray, sphere);\n    float surf_dist2 = intersect_sphere(ray, sphere2);\n    \n    vec3 point = eye_pos + (surf_dist * ray_dir);\n    vec3 point2 = eye_pos + (surf_dist2 * ray_dir);\n    \n    \n    float z_buff = point.z - point2.z;\n    \n    // Distortion \"frequency\"\n    float d = sin(dot(uv_norm_shift ,vec2(12.9898,78.233))) + cos(dot(uv_norm_shift ,vec2(12.9898,78.233))) + 5.0;\n    \n    // Distort the distance to surface \n    float dist_disp = sin(d * point.x) * sin(d * point.y) * sin(d * point.z);\n    float dist_disp2 = sin(0.0 * point2.x) * sin(0.0 * point2.y) * sin(0.0 * point2.z);\n    vec3 disp_point = eye_pos + ((surf_dist + dist_disp) * ray_dir);\n    vec3 disp_point2 = eye_pos + ((surf_dist2 + dist_disp2) * ray_dir);\n    \n    // Distort the location of the current point on the sphere\n    float point_disp = sin(d * point.x) * sin(d * point.y) * sin(d * point.z);\n    \n    // If positive, then we draw a pixel of the sphere\n\tif (surf_dist >= 0.0 && surf_dist2 >= 0.0)\n    {\n        if (z_buff > 0.0)\n        {\n            // Choose a diffuse color\n            vec4 diffuse_col =  vec4(0.0, 1.0, 1.0, 1);\n\n            // Choose an ambient color\n            vec4 ambient_col =  vec4(0.2, 0.0, 0.0, 1);\n\n            // Position of a white light\n            vec3 light_pos = vec3(20.0, 10.0, -10.0);\n            \n            fragColor = ambient_col + diffuse(disp_point2, sphere2.center, diffuse_col, light_pos);\n        }\n        \n        else\n        {\n            // Choose a diffuse color\n            vec4 diffuse_col =  vec4(0.0, 1.0, 1.0, 1);\n\n            // Choose an ambient color\n            vec4 ambient_col =  vec4(0.2, 0.0, 0.0, 1);\n\n            // Position of a white light\n            vec3 light_pos = vec3(20.0, 10.0, -10.0);\n        \n            fragColor = ambient_col + diffuse(disp_point, sphere.center, diffuse_col, light_pos);\n        }\n    }\n    \n    else if (surf_dist < 0.0 && surf_dist2 >= 0.0)\n    {\n        // Choose a diffuse color\n        vec4 diffuse_col =  vec4(0.0, 1.0, 1.0, 1);\n\n        // Choose an ambient color\n        vec4 ambient_col =  vec4(0.2, 0.0, 0.0, 1);\n\n        // Position of a white light\n        vec3 light_pos = vec3(20.0, 10.0, -10.0);\n            \n        fragColor = ambient_col + diffuse(disp_point2, sphere2.center, diffuse_col, light_pos);\n     }\n     \n     else if (surf_dist >= 0.0 && surf_dist2 < 0.0)\n     {\n         // Choose a diffuse color\n        vec4 diffuse_col =  vec4(0.0, 1.0, 1.0, 1);\n\n        // Choose an ambient color\n        vec4 ambient_col =  vec4(0.2, 0.0, 0.0, 1);\n\n        // Position of a white light\n        vec3 light_pos = vec3(20.0, 10.0, -10.0);\n        \n        fragColor = ambient_col + diffuse(disp_point, sphere.center, diffuse_col, light_pos);\n      }\n      \n      else\n      {\n          // Otherwise we draw the color of the background\n          fragColor = vec4(0.0, 0.0, 0.0, 1);\n      }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/NdXXW8.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "NdXXzj", "name": "Wireframe IFS", "author": "yasuo", "description": "Wireframe IFS", "tags": ["ifs"], "likes": 5, "viewed": 202, "date": "1618840430", "time_retrieved": "2024-06-20T20:38:06.260954", "image_code": "// All the distance functions from:http://iquilezles.org/www/articles/distfunctions/distfunctions.htm\n// raymarching based from https://www.shadertoy.com/view/wdGGz3\n#define USE_MOUSE 0\n#define MAX_STEPS 100\n#define MAX_DIST 100.\n#define SURF_DIST .005\n#define antialiasing(n) n/min(iResolution.y,iResolution.x)\n#define S(d,b) smoothstep(antialiasing(1.0),b,d)\n#define Rot(a) mat2(cos(a),-sin(a),sin(a),cos(a))\n#define matRotateX(rad) mat3(1,0,0,0,cos(rad),-sin(rad),0,sin(rad),cos(rad))\n#define matRotateY(rad) mat3(cos(rad),0,-sin(rad),0,1,0,sin(rad),0,cos(rad))\n#define matRotateZ(rad) mat3(cos(rad),-sin(rad),0,sin(rad),cos(rad),0,0,0,1)\n\nvec4 combine(vec4 val1, vec4 val2 ){\n    if ( val1.w < val2.w ) {\n        return val1;\n    }\n    return val2;\n}\n\nfloat hash(vec2 p) {\n    vec2 randP = fract(sin(p*123.456)*567.89);\n    randP += dot(randP,randP*34.56);\n    float rand = fract(randP.x*randP.y);\n    return rand;\n}\n\nfloat sdBoxFrame( vec3 p, vec3 b, float e )\n{\n  p = abs(p  )-b;\n  vec3 q = abs(p+e)-e;\n  return min(min(\n      length(max(vec3(p.x,q.y,q.z),0.0))+min(max(p.x,max(q.y,q.z)),0.0),\n      length(max(vec3(q.x,p.y,q.z),0.0))+min(max(q.x,max(p.y,q.z)),0.0)),\n      length(max(vec3(q.x,q.y,p.z),0.0))+min(max(q.x,max(q.y,p.z)),0.0));\n}\n\nfloat sdFrameCross( in vec3 p , float inf, float size, float e)\n{\n    float da = sdBoxFrame(p.xyz,vec3(inf,size,size),e);\n    float db = sdBoxFrame(p.yzx,vec3(size,inf,size),e);\n    float dc = sdBoxFrame(p.zxy,vec3(size,size,inf),e);\n    float d = min(da,min(db,dc));\n    mat3 rot = matRotateZ(iTime)*matRotateX(-iTime);\n    p*=rot;\n    d = min(d,sdBoxFrame(p,vec3(size*0.5),e));\n    return d;\n}\n\nvec4 GetDist(vec3 p) {\n    float t = iTime*1.2;\n    vec3 p2 = p;\n    mat3 rot = matRotateY(radians(25.0)+t)*matRotateX(radians(-30.0)+t);\n    mat3 rot2 = matRotateX(radians(-25.0)+t)*matRotateY(radians(30.0)+t);\n\n    float dist = 0.15+sin(t)*0.1;\n    \n    p = abs(p);\n    p-=dist;\n    p*=rot;\n    \n    float d = sdFrameCross(p,0.1,0.3,0.002);\n    \n    p = p2;\n    for(float i = 1.; i<=2.; i++){\n        p = abs(p);\n        p -= (dist*0.75)*i;\n        p *= rot2;\n        d = min(d,sdFrameCross(p+vec3(0.0,sin(t*i)*0.5,0.0), 0.1,0.3,0.002));\n    }\n    \n    // floor\n    p = p2;\n    p.y+=3.0;\n    float mask = length(p)-25.0;\n    p.z-=t*2.2;\n    p.xz = mod(p.xz,1.0)-0.5;\n    float d2 = sdBoxFrame(p,vec3(0.5,0.01,0.5),0.0025);\n    d2 = max(mask,d2);\n    \n    p = p2;\n    vec2 uv=p.xz;\n    float scale = 1.0+mod(iTime*10.0,40.0);\n    float shine = abs(length(uv)-scale)-1.0;\n    vec3 col = mix(vec3(0.1,0.5,0.9),vec3(0.7,0.8,1.0),1.0-smoothstep(0.0,0.5,shine));\n    vec4 res = combine(vec4(vec3(1.0),d),vec4(col,d2));\n    \n    return res;\n}\n\nvec4 RayMarch(vec3 ro, vec3 rd) {\n    vec4 dO= vec4(0.0);\n    \n    for(int i=0; i<MAX_STEPS; i++) {\n        vec3 p = ro + rd*dO.w;\n        vec4 dS = GetDist(p);\n        dO.w += dS.w;\n        dO.xyz = dS.xyz;\n        if(dO.w>MAX_DIST || dS.w<SURF_DIST) break;\n    }\n    \n    return dO;\n}\n\nvec3 GetNormal(vec3 p) {\n    float d = GetDist(p).w;\n    vec2 e = vec2(.001, 0);\n    \n    vec3 n = d - vec3(\n        GetDist(p-e.xyy).w,\n        GetDist(p-e.yxy).w,\n        GetDist(p-e.yyx).w);\n    \n    return normalize(n);\n}\n\nvec2 GetLight(vec3 p) {\n    vec3 lightPos = vec3(2,5,3);\n    \n    lightPos.yz *= Rot(radians(-60.0));\n    lightPos.xz *= Rot(iTime*.3+1.0);\n    \n    vec3 l = normalize(lightPos-p);\n    vec3 n = GetNormal(p);\n    \n    float dif = clamp(dot(n, l)*.5+.5, 0., 1.);\n    float d = RayMarch(p+n*SURF_DIST*2., l).w;\n    \n    float lambert = max(.0, dot( n, l))*0.6;\n    \n    return vec2((lambert+dif),max(0.9, 1.0)) ;\n}\n\nvec3 R(vec2 uv, vec3 p, vec3 l, float z) {\n    vec3 f = normalize(l-p),\n        r = normalize(cross(vec3(0,1,0), f)),\n        u = cross(f,r),\n        c = p+f*z,\n        i = c + uv.x*r + uv.y*u,\n        d = normalize(i-p);\n    return d;\n}\n\nvec3 Bg(vec3 rd, vec2 p) {\n    p = rd.xy;\n    p*=10.0;\n    vec2 uv = fract(p)-0.5;\n    vec2 id = floor(p);\n\n    float n = hash(p);\n    float rand = hash(id);\n    \n    vec3 col = vec3(.2,.1,.5);\n    \n    float k = rd.y*2.0+0.75;\n    col = mix(col,vec3(.1),k);\n    \n    vec2 pos = vec2(0.0);\n    if(rand<0.5){\n        pos.x += 0.3;\n    }\n    if(rand>0.7){\n        pos.y += 0.3;\n    }\n    \n    vec2 starPos = uv+pos;\n    starPos.x*=1.0-rand;\n    starPos.y*=2.0;\n    float d = length(starPos)-0.01;\n    if(rd.y>0.0){\n        col = mix(col,vec3(0.5),S(d,0.0));\n    }\n    \n    return col*n;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    vec2 m = iMouse.xy/iResolution.xy;\n    \n    vec3 col = vec3(0);\n    \n    vec3 ro = vec3(0, 3, -3);\n    #if USE_MOUSE == 1\n    ro.yz *= Rot(-m.y*3.14+1.);\n    ro.xz *= Rot(-m.x*6.2831);\n    #else\n    ro.yz *= Rot(radians(-45.0+sin(iTime*.5)*10.0));\n    ro.xz *= Rot(iTime*.35+1.0);\n    #endif\n    \n    vec3 rd = R(uv, ro, vec3(0,0.0,0.0), 2.);\n\n    vec4 d = RayMarch(ro, rd);\n    \n    if(d.w<MAX_DIST) {\n        vec3 p = ro + rd * d.w;\n        vec3 n = GetNormal(p);\n        vec3 r = reflect(rd,n);\n        float spec = pow(max(0.0,r.y),30.);\n        float dif = dot(n,normalize(vec3(1,2,3)))*0.5+0.5;\n        col = mix(Bg(r,uv),vec3(dif),0.5)+spec;\n        if(d.rgb != vec3(1.0)){\n            col*=d.rgb;\n        }\n    } else {\n        // background\n        col += Bg(rd,uv);\n    }\n    \n    float brightness = 1.25;\n    fragColor = vec4(col*brightness,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/NdXXzj.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "Ns23DW", "name": "grid beat", "author": "ligaobo", "description": "跳动的网格", "tags": ["noise", "move", "gird"], "likes": 5, "viewed": 47, "date": "1617427513", "time_retrieved": "2024-06-20T20:38:06.260954", "image_code": "highp float aa;\n\nhighp float hash(float x) {\n    return fract(sin(x)*43758.5453);\n}\nhighp float rand(vec2 co) {\n    return fract(sin(mod(dot(co.xy ,vec2(12.9898,78.233)),3.14))*43758.5453);\n}\n\nfloat dis2Integer(float x)\n{\n    return 0.5 - abs(fract(x) - 0.5);\n}\n\n//------------------------------------------------------------\n/*行列网格数，注意是从零开始，所以总的网格数为(rmax + 1.0) * (cmax + 1.0)*/\nconst float rmax = 4.0f;\nconst float cmax = rmax;\nvec2 gridIndex[int((rmax + 1.0) * (cmax + 1.0))];\nint iter = 0;\n\nvec2 leftTop(float r, float c)\n{\n    int biter = iter;\n    for (float cc = c; cc < cmax - c; ++cc)\n    {\n        gridIndex[iter++] = vec2(r, cc);\n    }\n\n    for (float cr = r; cr < rmax - r; ++cr)\n    {\n        gridIndex[iter++] = vec2(cr, cmax - c);\n    }\n    if(biter == iter)\n        gridIndex[iter++] = vec2(r, c);\n    return vec2(cmax - c, rmax - r);\n}\n\nvec2 rightBottom(float r, float c)\n{\n    for (float cc = c; cc > cmax - c; --cc)\n    {\n        gridIndex[iter++] = vec2(r, cc);\n    }\n\n    for (float cr = r; cr > rmax - r; --cr)\n    {\n        gridIndex[iter++] = vec2(cr, cmax - c);\n    }\n    return vec2(cmax - c + 1.0, rmax - r + 1.0);\n}\n\n//------------------------------------------------------------\n\nvoid mainImage( out vec4 o, in vec2 fragCoord )\n{\n    // 水平网格数\n    float rnum = rmax + 1.0;\n    float cnum = cmax + 1.0;\n    \n    aa = rnum / min(iResolution.x, iResolution.y);\n    vec2 uv = fragCoord * aa;\n    \n    float col = 0.0;\n    col = smoothstep(aa, 0.0, dis2Integer(uv.x)) * 0.5;\n    col += smoothstep(aa, 0.0, dis2Integer(uv.y)) * 0.5;\n\n    if(uv.x > rnum || uv.y > cnum)\n     col = 0.0f;\n     \n    float stepSpeed = iTime * 2.0;\n\n    float r = 0.0;\n    float c = 0.0;\n    {\n        float imax = rmax * 0.5;\n        imax = mod(rmax, 2.0) == 0.0 ? imax + 1.0 :  imax;  \n        for(float i = 0.0f; i < imax; ++i)\n        {\n            vec2 rbstart = leftTop(r, c);\n\t        vec2 ltstart = rightBottom(rbstart.x, rbstart.y);\n            r = ltstart.x;\n            c = ltstart.y;\n        }\n\n        int index = int(mod(stepSpeed,  float(iter)));\n        vec2 iv = gridIndex[index];\n        r = iv.x;\n        c = iv.y;\n    }\n    vec2 luv = uv - vec2(r, c);\n    if(luv.x < 1.0 && luv.y < 1.0 && luv.x > 0.0 && luv.y > 0.0)\n        col += (1.0 - fract(stepSpeed)) * rand(uv*iTime);\n\n    o = vec4(0.0, col, 0.0, col); \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/Ns23DW.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "Ns23RK", "name": "Ray-Cast Cube", "author": "jt", "description": "Calculate ray-cast with cube, return distance & normals.", "tags": ["ray", "raycast", "cube", "box", "aabb", "axis", "cast", "aligned", "aab"], "likes": 2, "viewed": 107, "date": "1617651058", "time_retrieved": "2024-06-20T20:38:07.090296", "image_code": "// Ray-Cast Cube, written 2021 by JT, license CC0 (public domain)\n// https://www.shadertoy.com/view/Ns23RK\n\n#define MAXDIST 1000.0\n//#define MAXDIST 1.0 / 0.0\n\nvec3 cubenormal(vec3 v) // position relative to cube center\n{\n    vec3 s = sign(v);\n    vec3 a = abs(v);\n\n    //vec3 n = (a.z > a.y)\n    // ?\n    // (a.z > a.x) ? vec3(0.0, 0.0, s.z) : vec3(s.x, 0.0, 0.0)\n    // :\n    // (a.y > a.x) ? vec3(0.0, s.y, 0.0) : vec3(s.x, 0.0, 0.0);\n\n    vec3 n = mix(\n        mix(vec3(0.0, 0.0, s.z), vec3(s.x, 0.0, 0.0), step(a.z, a.x)),\n        mix(vec3(0.0, s.y, 0.0), vec3(s.x, 0.0, 0.0), step(a.y, a.x)),\n        step(a.z, a.y));\n\n    return n;\n}\n\nstruct intersection\n{\n    float distance;\n    vec3 normal;\n};\n\n// source: https://gamedev.stackexchange.com/questions/18436/most-efficient-aabb-vs-ray-collision-algorithms\nfloat rayboxintersect(vec3 raypos, vec3 raydir, vec3 boxmin, vec3 boxmax)\n{\n    float t1 = (boxmin.x - raypos.x) / raydir.x;\n    float t2 = (boxmax.x - raypos.x) / raydir.x;\n    float t3 = (boxmin.y - raypos.y) / raydir.y;\n    float t4 = (boxmax.y - raypos.y) / raydir.y;\n    float t5 = (boxmin.z - raypos.z) / raydir.z;\n    float t6 = (boxmax.z - raypos.z) / raydir.z;\n\n    float tmin = max(max(min(t1, t2), min(t3, t4)), min(t5, t6));\n    float tmax = min(min(max(t1, t2), max(t3, t4)), max(t5, t6));\n\n    if (tmax < 0.0) // box on ray but behind ray origin\n    {\n        return MAXDIST;\n    }\n\n    if (tmin > tmax) // ray doesn't intersect box\n    {\n        return MAXDIST;\n    }\n\n    return tmin;\n}\n\n/*\n// source: https://www.scratchapixel.com/lessons/3d-basic-rendering/minimal-ray-tracer-rendering-simple-shapes/ray-box-intersection\nfloat rayboxintersect(vec3 raypos, vec3 raydir, vec3 boxmin, vec3 boxmax)\n{\n    float tmin = (boxmin.x - raypos.x) / raydir.x;\n    float tmax = (boxmax.x - raypos.x) / raydir.x;\n\n    if (tmin > tmax)\n    {\n        // swap(tmin, tmax);\n        float tmp = tmin;\n        tmin = tmax;\n        tmax = tmp;\n    }\n\n    float tymin = (boxmin.y - raypos.y) / raydir.y;\n    float tymax = (boxmax.y - raypos.y) / raydir.y;\n\n    if (tymin > tymax)\n    {\n        // swap(tymin, tymax);\n        float tmp = tymin;\n        tymin = tymax;\n        tymax = tmp;\n    }\n\n    if ((tmin > tymax) || (tymin > tmax))\n        return MAXDIST; // no intersection\n\n    if (tymin > tmin)\n        tmin = tymin;\n\n    if (tymax < tmax)\n        tmax = tymax;\n\n    float tzmin = (boxmin.z - raypos.z) / raydir.z;\n    float tzmax = (boxmax.z - raypos.z) / raydir.z;\n\n    if (tzmin > tzmax)\n    {\n        // swap(tzmin, tzmax);\n        float tmp = tzmin;\n        tzmin = tzmax;\n        tzmax = tmp;\n    }\n\n    if ((tmin > tzmax) || (tzmin > tmax))\n        return MAXDIST; // no intersection\n\n    if (tzmin > tmin)\n        tmin = tzmin;\n\n    if (tzmax < tmax)\n        tmax = tzmax;\n\n    return tmin;\n}\n*/\nintersection RAYBOXINTERSECT(vec3 raypos, vec3 raydir, vec3 boxmin, vec3 boxmax)\n{\n    intersection result;\n    result.distance = rayboxintersect(raypos, raydir, boxmin, boxmax);\n    //result.normal = -raydir; // sky-sphere\n    //if(result.distance < MAXDIST) result.normal = cubenormal(raypos + raydir * result.distance - (boxmin + boxmax) / 2.0);\n\n    result.normal = mix(-raydir, cubenormal(raypos + raydir * result.distance - (boxmin + boxmax) / 2.0), step(result.distance, MAXDIST));\n\n    return result;\n}\n\n\n#define PI 3.1415926\n#define TAU (2.0 * PI)\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 NDC = 2.0 * fragCoord / iResolution.xy - 1.0;\n    NDC.x *= iResolution.x / iResolution.y; // aspect\n\n    float latitude = iTime / 10.0;\n    float longitude = iTime;\n    //mat2 R = mat2(cos(longitude), sin(longitude),-sin(longitude), cos(longitude));\n    mat3 R = mat3(cos(longitude), 0.0, sin(longitude), 0.0, 1.0, 0.0,-sin(longitude), 0.0, cos(longitude));\n    mat3 S = mat3(1.0, 0.0, 0.0, 0.0, cos(latitude), sin(latitude), 0.0,-sin(latitude), cos(latitude));\n\n    vec3 raydir = R * S * vec3(NDC, 1.0);\n    vec3 raypos = R * S * vec3(0.0, 0.0,-3.5);\n\n    intersection result = RAYBOXINTERSECT(raypos, raydir, vec3(-1.0), vec3(+1.0));\n\n    fragColor = vec4(vec3(0.5 + 0.5 * result.normal), 1.0);\n    //fragColor *= 0.5 + 0.5 * sin(5.0 * result.distance * TAU);\n    if(result.distance >= MAXDIST)\n        fragColor = vec4(0.0, 0.0, 0.5, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc0-1.0", "thumbnail": "https://www.shadertoy.com/media/shaders/Ns23RK.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "Ns23RV", "name": "Bayer Matrix Zone", "author": "wilkie", "description": "A bayer matrix dithered experiment.", "tags": ["dithering"], "likes": 6, "viewed": 223, "date": "1617660037", "time_retrieved": "2024-06-20T20:38:07.969162", "image_code": "\nconst float ResolutionDivisor = 4.0;\nconst float PaletteRGBSize = 4.0;\n\nfloat sineWave( float y ) {\n  return sin(y * 2.0 * 3.14159);\n}\n\nfloat triangleWave( float y ) {\n  return 2.0 / 3.14159 * asin(sin(2.0 * 3.14159 * y));\n}\n\nfloat quantize(float inp, float period)\n{\n\treturn floor((inp+period/2.)/period)*period;\n}\n\nfloat bayer4x4(vec2 uvScreenSpace, float divisor)\n{\n\tvec2 bayerCoord = floor(uvScreenSpace/divisor);\n\tbayerCoord = mod(bayerCoord, 4.);\n\n\tconst mat4 bayerMat = mat4(\n\t\t\t1,9,3,11,\n\t\t\t13,5,15,7,\n\t\t\t4,12,2,10,\n\t\t\t16,8,14,6) / 16.;\n\tint bayerIndex = int(bayerCoord.x + bayerCoord.y * 4.);\n\tif(bayerIndex == 0) return bayerMat[0][0];\n\tif(bayerIndex == 1) return bayerMat[0][1];\n\tif(bayerIndex == 2) return bayerMat[0][2];\n\tif(bayerIndex == 3) return bayerMat[0][3];\n\tif(bayerIndex == 4) return bayerMat[1][0];\n\tif(bayerIndex == 5) return bayerMat[1][1];\n\tif(bayerIndex == 6) return bayerMat[1][2];\n\tif(bayerIndex == 7) return bayerMat[1][3];\n\tif(bayerIndex == 8) return bayerMat[2][0];\n\tif(bayerIndex == 9) return bayerMat[2][1];\n\tif(bayerIndex == 10) return bayerMat[2][2];\n\tif(bayerIndex == 11) return bayerMat[2][3];\n\tif(bayerIndex == 12) return bayerMat[3][0];\n\tif(bayerIndex == 13) return bayerMat[3][1];\n\tif(bayerIndex == 14) return bayerMat[3][2];\n\treturn bayerMat[3][3];\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    float aspectRatio = iResolution.x / iResolution.y;\n\n    // Time varying pixel color\n    vec3 col = 0.5 + 0.5 * cos(iTime + uv.xyx + vec3(0,10,10));\n    \n    float timeEase = sin(iTime) / 32.0;\n    float timeStep = iTime / 4.0;\n\n    // Output to screen\n    float triangleWavePosition = 0.25 + triangleWave((uv.y + timeStep) * 8.0) / 64.0;\n    float sineWavePosition = 0.35 + timeEase * 2.0 + sineWave((uv.x + timeStep) * 6.0) / 32.0;\n    \n    if (uv.x < triangleWavePosition) {\n        fragColor = vec4(1.0, 0.5*col.x, 0.25*col.y, 1.0);\n    }\n    else if (uv.x < triangleWavePosition + 0.01) {\n        fragColor = vec4(0.5, 0.0, 0.0, 1.0);\n    }\n    else if (uv.y < sineWavePosition) {\n        col = 0.5 + 0.5 * cos(iTime / 2.0 + vec3(0,10,10));\n        vec3 color = vec3(0.5 * col.x, 0.25 + 0.5*col.y, 1.0);\n        vec3 quantizationPeriod = vec3(1./(PaletteRGBSize-1.));\n\n        float bayerResolution = max(1.0, floor(1.0 * iResolution.x / 200.0));\n        color += (bayer4x4(fragCoord, bayerResolution) - 0.5) * (quantizationPeriod);\n        \n\t    color = vec3(\n\t\t\tquantize(color.r, quantizationPeriod.r),\n\t\t\tquantize(color.g, quantizationPeriod.g),\n\t\t\tquantize(color.b, quantizationPeriod.b)\n\t\t );\n\n        fragColor = vec4(color, 1.0);\n    }\n    else if (uv.y < sineWavePosition + 0.01) {\n        fragColor = vec4(0.0, 0.0, 0.5, 1.0);\n    }\n    else {\n        // Number of circles horizontally\n        float numCirclesX = 10.0 * aspectRatio;\n        \n        // Number of circles veritically\n        float numCirclesY = 10.0;\n        \n        // Width of a circle\n        float circleW = 1.0 / numCirclesX;\n        float circleH = 1.0 / numCirclesY;\n        \n        // Get the position in this plane\n        float ux = uv.x + iTime / 64.0;\n        float uy = uv.y + iTime / 64.0;\n        \n        // Get the coordinate within the square that the circle resides within\n        float x = mod(ux, circleW);\n        float y = mod(uy, circleH);\n        \n        // And normalize it from 0.0 to 1.0\n        x /= circleW;\n        y /= circleH;\n        \n        // Get the x position of the circle in terms of 8 by 8 circles\n        float cx = mod(ux, (circleW * 8.0)) / (circleW * 8.0);\n        cx = floor(cx / (1.0 / 8.0));        \n        float cy = mod(uy, (circleH * 8.0)) / (circleH * 8.0);\n        cy = floor(cy / (1.0 / 8.0));\n        \n        // `cx` and `cy` are now a value between 0. and 7.\n        // Add cx and cy together to step them diagonally\n        cx = mod(cx + cy, 8.0);\n        \n        // Circle radii\n        float r = 0.25 + sin(iTime + cx/2.0) * 0.1;\n                       \n        // Assign a color (between 0.0 and 0.5)\n        cx = (abs(cx - 4.0)) / 8.0;\n        \n        float bayerResolution = max(1.0, floor(1.0 * iResolution.x / 800.0));\n        \n        if (pow(x - 0.5, 2.0) + pow(y - 0.5, 2.0) < pow(r, 2.0)) {\n            // Circle interior\n            vec3 color = vec3(0.7, cx, 0.7);\n            color += (bayer4x4(vec2(uv.x * iResolution.x, uv.y * iResolution.y), bayerResolution) - 0.5) * (1.0);\n            \n            vec3 quantizationPeriod = vec3(1.0);\n            \n            color = vec3(\n                quantize(color.r, quantizationPeriod.r),\n                quantize(color.g, quantizationPeriod.g),\n                quantize(color.b, quantizationPeriod.b)\n            );\n            \n            fragColor = vec4(color, 1.0);\n        }\n        else if (pow(x - 0.5, 2.0) + pow(y - 0.5, 2.0) < pow(r + 0.025 + 0.01 * -sin(iTime), 2.0)) {\n            // Circle border\n            fragColor = vec4(0.4, 0.1, 0.4, 1.0);\n        }\n        else {\n            // Circle exterior background\n            vec3 color = vec3(0.9, 0.9, 0.9);\n            color += (bayer4x4(vec2(uv.x * iResolution.x, uv.y * iResolution.y), bayerResolution) - 0.5) * (1.0);\n            \n            vec3 quantizationPeriod = vec3(1.0);\n            \n            color = vec3(\n                quantize(color.r, quantizationPeriod.r),\n                quantize(color.g, quantizationPeriod.g),\n                quantize(color.b, quantizationPeriod.b)\n            );\n            \n            if (color.x == 1.0) {\n                fragColor = vec4(color, 1.0);\n            }\n            else {\n                fragColor = vec4(0.9, 0.9, 0.9, 1.0);\n            }\n        }\n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/Ns23RV.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "Ns23Wh", "name": "Fake 3D fractal", "author": "jarble", "description": "This is a 2D fractal formula, but it looks almost like a 3D rendered scene!", "tags": ["2d", "3d", "fractal", "illusion"], "likes": 2, "viewed": 135, "date": "1617331049", "time_retrieved": "2024-06-20T20:38:07.969162", "image_code": "\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.0);\n    vec3 col;\n    float t = iTime;\n    vec2 uv = (fragCoord*10.0-iResolution.xy)/iResolution.y/10.0;\n    uv += vec2(t/2.0,t/3.0)/4.0;\n    for(int c=0;c<3;c++){\n        float scale = 5.6;\n        float scale1 = 1.6;\n        float s1 = scale1*scale;\n        for(int i=0;i<9;i++)\n        {\n            uv = fract(uv/s1)*s1;\n            uv=-fract(uv/(2.5-abs((uv.x-uv.y)/(16.0)))-(uv/(2.5+(fract(uv.x+uv.y))))/scale)*scale/scale1+s1;\n            uv /= scale1+col.yx;\n        \tuv=uv.yx+col.xy;\n            uv.x *= -1.0;\n            col[c] = fract((.5*col[c]+col.x+(uv.y)-(uv.x))/2.0);\n        }\n     \n\t}\n    \n    fragColor = vec4(vec3(col),1.0);\n    \n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/Ns23Wh.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "Ns23WV", "name": "大龙猫 - Mineraball", "author": "totetmatt", "description": "Big up to evvvvil and flopine, a lot of hour learning on their stream <3\n\nOh yeah, PEGI 18:  zero optimization, dirty code and yolo implementation", "tags": ["3d", "ball", "mineral"], "likes": 1, "viewed": 148, "date": "1617983896", "time_retrieved": "2024-06-20T20:38:07.969162", "image_code": "#define fGlobalTime iTime\nfloat box(vec3 p, vec3 b){\n    vec3 q = abs(p)-b;\n    return length(max(q,vec3(.0)));\n  }\n mat2 rot(float a){float c=cos(a),s=sin(a);return mat2(c,-s,s,c);}\nfloat sdf(vec3 p){    \n  \n  p.xz *=rot(cos(fGlobalTime*.3)*3.1415*.5);\n  p.yz *=rot(sin(fGlobalTime)*.2);\n  vec3 op = p;\n\n\n  float q = 10000.;\n  for(float i = 0.;i<=4.;i++){\n    p.xy = abs(p.xy)-vec2(.5*(1.-i/5.),.3*(1.-i/5.));\n  \n    p.xz = p.x < p.z ? p.xz :p.zx;\n    p.yz = p.y < p.z ? p.yz :p.zy;\n    p.xy *= p.x < p.y ? rot(fGlobalTime*.0-1.66) : rot(1.166*i*.1); \n      p.xy *= 1.5+(i*.2);\n    p.xz *= p.x < p.y ? rot(-1.66) : rot(1.166*i*.1); \n  \n    \n    float h = box(p,vec3(.8));\n    float t = length(p)-1.;\n    if(mod(i,2.)==0.){\n    q = min(q,mix(t,h,.5+i*.1)/10.);\n    } else { q = max(q,-mix(t,h,.5)/10.);\n    }\n  }\n  float z = length(op)-.85432508097;\n  float zz = abs(box(abs(op)-.8,vec3(.351)))-.09;\n  float vv = max(z,-zz);\n  \n  float trans = smoothstep(0.1,0.5,sin(fGlobalTime + atan(op.z,op.y) )*.5+.5)*1.01;\n  q = mix(vv,q*2.,max(0.3,.85*trans))/.8;\n  \n  return q;\n  }\n vec2 nv= vec2(.00001,0.);\n  vec3 norm(vec3 p){\n      float d = sdf(p);\n      //return  normalize(vec3(sdf(p+nv.xyy)-sdf(p-nv.xyy),sdf(p+nv.yxy)-sdf(p-nv.yxy),sdf(p+nv.yyx)-sdf(p-nv.yyx)));\n      return normalize(vec3(d-sdf(p-nv.xyy),d-sdf(p-nv.yxy),d-sdf(p-nv.yyx)));\n    }\nvec2 raym(vec3 ro,vec3 rd,int stp, inout  vec3 rp){\n\n      float td = 0.;\n  for(int i=0;i<=stp;i++){\n         float d = sdf(rp);\n         if(d <= 0.00001) return vec2(td,1.);\n         td += d;\n         \n         rp = ro + rd*td;\n         \n    }\n    return vec2(td,0.);\n    \n  }\n  \n  vec3 pal(float t){\n    return .5+.5*cos(2.*3.141592*(1.*t+vec3(.0,.3,.7)));\n    }\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n   vec2 uv = vec2(fragCoord.x / iResolution.x, fragCoord.y / iResolution.y);\n  vec2 puv = uv;\n\tuv -= 0.5;\n\tuv /= vec2(iResolution.y / iResolution.x, 1);\n  \n\nvec3 ro=vec3(0.,0.,-4.),rd=vec3(uv,1.),rp=ro;\n  \tvec3 col = vec3(.1);\n  \n  vec2 td = raym(ro,rd,69*2,rp);\n  vec3 n = norm(rp);\nvec3 light = vec3(1.,1.,-5.5);\n  if(td.y == 1.){\n        float lamb =max(0.,dot(normalize(light),n));\n       float spec = 0.0;\n        float ld= pow(length(light - rp),2.);\n        if(lamb > 0.){\n         \n            vec3 viewDir = normalize(rp);\n            // BlinPhong\n            vec3 halfDir = normalize(light+viewDir);\n            float specAngle = max(dot(halfDir,n),0.);\n            spec = pow(specAngle,16.);\n        }\n    \n        col = col\n        + vec3(.1,.3,.5)* lamb *vec3(1.,.7,1.)* 20. / (ld)\n        + vec3(1.) * spec  *  pal(td.x+.5+length(rp*.09))* 20. / (ld)\n        ;\n         col*=col;\n        //col = pow(col, vec3(1.0 / 2.2)); \n    }\n    \n     \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/Ns23WV.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "Ns23Wy", "name": "Max Norm Cone", "author": "khalladay", "description": "I'm not sure that I've properly adapted https://www.shadertoy.com/view/Mt2XWG to make a cone. I see a cone, but I'm not entirely sure why qb's z component doesn't need to be negated.", "tags": ["cone", "maxnorm"], "likes": 0, "viewed": 40, "date": "1617901493", "time_retrieved": "2024-06-20T20:38:08.920874", "image_code": "#define MAX_ITER 256\n#define SIGNED_DIST_MAX 1000.0\n\nfloat min3(float a, float b, float c)\n{\n\treturn min(min(a, b), c);\n}\n\nfloat max3(float a, float b, float c)\n{\n\treturn max(max(a, b), c);\n}\n\nfloat max_element(vec3 v)\n{\n\treturn max3(v.x, v.y, v.z);\n}\nfloat sumx(vec3 v)\n{\n    return v.x + v.y + v.z;\n}\n\nfloat max_norm(vec3 v)\n{\n\treturn max_element(abs(v));\n}\nvec3 max_normalize(vec3 v)\n{\n    return v/max_norm(v);\n}\n\nfloat sd_cube(vec3 p, float r)\n{\n\treturn max_norm(p) - r;\n}\n\nvec2 solve_quadratic(float a, float b, float c)\n{\n\t// ax^2 + bx + c = 0, a non-zero\n\tfloat q = b*b - 4.0*a*c;\n\tif (q < 0.0) {\n\t\treturn vec2(SIGNED_DIST_MAX);\n\t}\n\tfloat r0 = -b/(2.0*a);\n\tfloat r1 = sqrt(q)/(2.0*a);\n\treturn vec2(r0 - r1, r0 + r1);    \n}\n\nfloat sd_cone(vec3 p, vec3 r)\n{\n\t// move cone so that target point is at origin, centre in positive space    \n\t// f(v) = (v.x - c.x)^2/r.x^2 + (v.y - c.y)^2/r.y^2 - (v.z - c.z)^2/r.z^2\n    \n\tvec3 c = abs(p);\n\tvec3 c2 = c*c;\n\tvec3 r2 = r*r;\n    float d = SIGNED_DIST_MAX;\n\n\t// gather terms of quadratic\n\tvec3 qa = 1.0/r2;\n\tvec3 qb = -2.0*c/r2;\n\t\n    vec3 qc = c2/r2;\n    \n    qa.z *= -1.0;   \n    qc.z *= -1.0;\n        \n    float qcs = sumx(qc);\n\n    // check corners:\n    // solve f(v)=0 for v.x=v.y=v.z=t\n    {\n\t\tvec2 t0 = abs(solve_quadratic(sumx(qa), sumx(qb), qcs));\n        d = min3(d, t0.x, t0.y);\n    }\n\n\t// interior of convex shape always hits corners first, so early out\n\tif (qcs <= 0.0) {\n\t\treturn -d;\n\t}\n\n\t// check edges:\n\t// df/dx=0 => v.x=c.x, solve f(v)=0 for v.x=c.x, v.y=v.z=t\n    // then do the same for y and z cases\n    {\n        vec2 t = abs(solve_quadratic(qa.y + qa.z, qb.y + qb.z, qc.y + qc.z));\n        d = min(d, max(min(t.x, t.y), c.x));\n\t}\n    {\n        vec2 t = abs(solve_quadratic(qa.x + qa.z, qb.x + qb.z, qc.x + qc.z));\n        d = min(d, max(min(t.x, t.y), c.y));\n\t}\n    {\n        vec2 t = abs(solve_quadratic(qa.x + qa.y, qb.x + qb.y, qc.x + qc.y));\n        d = min(d, max(min(t.x, t.y), c.z));\n\t}\n\n\t// check faces:\n    // df/dx=df/dy=0 => v.xy=c.xy, so f(v)=0 => |v.z - c.z|=r.z\n\t{\n\t\td = min(d, max3(c.x, c.y, abs(c.z - r.z)));\n\t\td = min(d, max3(c.x, abs(c.y - r.y), c.z));\n\t\td = min(d, max3(abs(c.x - r.x), c.y, c.z));\n\t}\n\n\t// done\n\treturn d;\n}\n\nfloat sd_scene(vec3 p)\n{\n    float sd = sd_cone(p, vec3(1,1,2.0));\n    \n\treturn sd;\n}\n\nvoid sample_camera(\n\tvec2 pixel_coord,\n\tout vec3 camera_pos,\n\tout vec3 ray_dir,\n\tout float eps_factor)\n{\n\tvec2 uv = (pixel_coord - iResolution.xy/2.0)/iResolution.y;\n\n\tfloat camera_phi = 0.5*iTime + 0.5;\n\tcamera_pos = 8.0*vec3(cos(camera_phi), 0.7, sin(camera_phi));\n\n\tvec3 look_dir = normalize(-camera_pos);\n\tvec3 u_dir = normalize(cross(look_dir, vec3(0.0, 1.0, .0)));\n\tvec3 v_dir = cross(u_dir, look_dir);\n\n\tfloat fov_factor = 0.5;\n    vec2 fov_uv = fov_factor*uv;\n\tray_dir = max_normalize(look_dir + fov_uv.x*u_dir + fov_uv.y*v_dir);\n\teps_factor = 0.5*fov_factor/iResolution.y;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec3 camera_pos, ray_dir;\n    float eps_factor;\n    sample_camera(fragCoord, camera_pos, ray_dir, eps_factor);\n    \n\tvec3 col = vec3(0.8);\n\n\t// show field on ground plane\n    float ground_y = (iTime > 10.0) ? (cos(iTime - 10.0) - 1.0) : 0.0;\n\tfloat debug_dist = (ground_y - camera_pos.y)/ray_dir.y;\n\tif (0.0 < debug_dist) {\n\t\t\n\t\tfloat debug_sd = sd_scene(camera_pos + ray_dir*debug_dist);\n\t\tfloat d = abs(debug_sd);\n\t\tcol = 0.4 + 0.6*vec3(fract(2.0*d), fract(4.0*d), debug_sd < 0.0);\n\t}\n\t\n\t// ray march\n\tfloat dist = 0.0;\n\tbool is_hit = false;\n\tfor (int i = 0; i < MAX_ITER; ++i) {\n\t\tfloat sd = sd_scene(camera_pos + ray_dir*dist);\n\t\tdist += sd;\n\t\tif (sd < dist*eps_factor) {\n\t\t\tis_hit = true;\n\t\t\tbreak;\n\t\t}\n\t\tif (dist > debug_dist) {\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t// shade\n\tif (is_hit) {\n\t\tvec3 hit_pos = camera_pos + ray_dir*dist;\n\t\tfloat eps = dist*eps_factor;\n\t\t\n\t\tvec2 e = eps*vec2(0.5, -0.5);\n\t\tvec3 normal = normalize(\n\t\t\t  e.xyy*sd_scene(hit_pos + e.xyy)        \n\t\t\t+ e.yxy*sd_scene(hit_pos + e.yxy)        \n\t\t\t+ e.yyx*sd_scene(hit_pos + e.yyx)        \n\t\t\t+ e.xxx*sd_scene(hit_pos + e.xxx));\n\t\t\n\t\tvec3 light_dir = normalize(vec3(2.0, 4.0, 1.0));\n        vec3 light_col = vec3(0.6, 0.5, 0.4);\n\t\tvec3 amb_col = vec3(0.4);        \n        \n\t\tcol = mix(amb_col + light_col*max(dot(normal, light_dir), 0.0), col, 0.2);\n\t}\n\n\tfragColor = vec4(pow(col, vec3(2.2)), 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/Ns23Wy.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "Ns23zc", "name": "大龙猫 - Quicky#050", "author": "totetmatt", "description": "Training what I learn in evvvvil stream for fractalish stuff.\nTesting some color scheme also.", "tags": ["quicky"], "likes": 0, "viewed": 177, "date": "1617750674", "time_retrieved": "2024-06-20T20:38:08.920874", "image_code": "  #define fGlobalTime iTime\n  mat2 rot(float a){\n      float c=cos(a),s=sin(a);\n     return mat2(c,-s,s,c);\n     }\n float frbox(vec3 p,vec3 b ,float e){\n         \n      p = abs(p)-b;\n   vec3 q = abs(p+e)-e;\n    return min(min(\n      length(max(vec3(p.x,q.y,q.z),0.0))+min(max(p.x,max(q.y,q.z)),0.0),\n      length(max(vec3(q.x,p.y,q.z),0.0))+min(max(q.x,max(p.y,q.z)),0.0)),\n      length(max(vec3(q.x,q.y,p.z),0.0))+min(max(q.x,max(q.y,p.z)),0.0));\n   }\n  float structure(vec3 p ){\n     float t  =fGlobalTime*.01;\n     float tt = fGlobalTime*.303;\n   vec3 np=p;\n    float h = 1000.;\n \n\n     np.z = abs(np.z)-(1.5+sin(t*100.)*.5+.5);\n    for(int i=0;i<20;i++){\n\n     np /=(1.1);\n     if(i==1){   np .xy = np.x < np.y ? np.yx:np.xy;\n     np.xz*=rot(.753-float(i)-t*t);\n     } else if(i==2) { np .xy = np.x > np.y ? np.yx:np.xy;\n        np.xy*=rot(.753+t*t+float(i));\n     }else if(i==3) {   np .xy = np.x < np.y ? np.yx:np.xy;\n        np.zy*=rot(.753+float(i));\n     } else {   np .xy = np.x > np.y ? np.yx:np.xy;\n                 np.yz*=rot(.753-t+float(i));\n       }\n      h = min(h,frbox(np,vec3(1.1),.1-abs(np.x*.2)));\n    }  \n   \n  return h;\n    \n    }\n   vec2 sdf(vec3 p){\n     float t  = (fGlobalTime*.02);\n     float tt = fract(fGlobalTime*.33);\n     float h = structure(p);\n     float l = length(p-vec3(0.,0.,0.))-(.25+sin(t*200.)*.1+.1);\n      vec2 rt = l < h ? vec2(l,1.):vec2(h,2.);\n     return rt;\n  }\n  vec2 nv = vec2(.00001,.0);\nvec3 norm(vec3 p){\n     float d = sdf(p).x;\n     return normalize(\n    vec3(\n      d-sdf(p-nv.xyy).x,\n      d-sdf(p-nv.yxy).x,\n     d-sdf(p-nv.yyx).x\n  )\n  );\n    }\nvec3 pal(float t){\n  return sqrt(.5+vec3(.5,.0,.5)*cos(2.*3.141592*(1.*t+vec3(.0,.4,.6))));\n  } \n\nvec2 rayt(vec3 ro,vec3 rd,int st){\n    vec3 rp = ro;\n  float rdd= 0.;\n    for(int i=0;i<=st;i++){\n      vec2 d = sdf(rp);\n        rdd += d.x;\n         rp = ro+rdd * rd;\n        if(d.x<=0.0001){\n              return vec2(rdd,d.y);   \n        }\n    }\n    return vec2(1000.,0.);\n  }\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\n    \n \n\tvec3 col = vec3(.1);\n  vec3 ro= vec3(0.,0.,-10.),rd= normalize(vec3(uv,1.)),rp = ro;\n  vec3 light = vec3(1.11,0.001,-3.);\n  \n  vec2 res = rayt(ro,rd,69);\n             rp = ro+rd*res.x;\n          if(res.y ==2.){\n              \n            col = pal(length(rp))* max(0.0,dot(normalize(light),norm(rp)));\n          } else if(res.y==1.) {\n            \n       \n            col =vec3(1.)* max(0.0,dot(normalize(light),norm(rp)));\n            } else {\n col = vec3(.1);\n              }\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/Ns23zc.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "Ns23zt", "name": "Many Reflective Spheres", "author": "Symmetries", "description": "Simple iterative ray tracer", "tags": ["raytracing"], "likes": 2, "viewed": 54, "date": "1617825043", "time_retrieved": "2024-06-20T20:38:08.920874", "image_code": "#define num 4\n#define epsilon 0.0000005\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    float theta = cos(iTime / 4.);\n    mat3 rot = mat3(\n        cos(theta), -sin(theta), 0.,\n        sin(theta), cos(theta),  0.,\n        0.,          0.,           1.\n    );\n    \n    vec3 col = vec3(0.);\n    for (int i = -2; i <= 2; i++) {\n        for (int j = -2; j <= 2; j++) {\n            vec2 st = 2. * (fragCoord.xy + vec2(i, j)/5.)/iResolution.xy - 1.;\n            st.y *= iResolution.y / iResolution.x;\n            st *= 1.6;\n\n            vec3 ps[num] = vec3[](\n                vec3(0., 7., 2.),\n                vec3(-2., 3., 0.),\n                vec3(0., 4., -0.5),\n                vec3(2., 3., .5)\n            );\n            float rs[num] = float[](3., 1., 0.5, 1.5);\n            \n            vec3 w = rot * normalize(vec3(st.xy, 1.).xzy);\n            vec3 o = vec3(0.);\n\n            for (int iteration = 0; iteration < 8; iteration++) {\n                \n                float minT = -1.;\n                vec3 minP = ps[0];\n                float minR = -1.;\n                for (int i = 0; i < num; i++) {\n                    float b = -2. * dot(w, ps[i] - o);\n                    float dis = b * b - 4. * (dot(ps[i] - o, ps[i] - o) - rs[i] * rs[i]);\n                    \n                    float t = (-b - sqrt(abs(dis))) / 2.;\n                    float cond = float((t < minT || minT == -1.) && dis > 0. && t > 0.);\n                    \n                    minT += cond * (t - minT);\n                    minP += cond * (ps[i] - minP);\n                    minR += cond * (rs[i] - minR);\n                }\n                \n                o += float(minT > 0.) * (minP + normalize(o + minT * w - minP) * (minR + epsilon) - o);\n                w += float(minT > 0.) * (normalize(reflect(w, normalize(minP - o))) - w);\n            }\n            \n            float cond = float(w.z < 0.);\n            vec2 v = o.xy - (1. + o.z) * w.xy / w.z;\n            col += cond * mod(floor(v.x) + floor(v.y), 2.) * vec3(fract(v.xy), .5).xzy\n                + (1. - cond) * w.zzz;\n        }\n    }\n    \n    fragColor = vec4(col/25., 1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/Ns23zt.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "Ns2GDw", "name": "Wavy Fun", "author": "JennySchub", "description": "a little wavy fun", "tags": ["2d", "waves", "hsv"], "likes": 3, "viewed": 44, "date": "1617493680", "time_retrieved": "2024-06-20T20:38:08.920874", "image_code": "#define count 6\n#define freqVar .3\n#define freq 5.\n#define wobble .5\n#define shiftspeed 2.\nfloat x;\nvec2 uv;\nfloat wave(float amp, float size){\n    return (1.-smoothstep(\n        abs(amp*sin(\n            sin(iTime)*amp+freqVar*x*(sin(iTime)+freq)+iTime*shiftspeed\n        )*sin(iTime*wobble) - uv.y),\n        0.,\n        0.1*size\n    ));\n}\n\nfloat psin(float x){\n    return (sin(x)+1.)*.5;\n}\n\n// is this the most efficient? no. Did I figure it out myself? yeah :D\nvec3 hsv2rgb(vec3 hsv){\n    return hsv.z*((1.-hsv.y) + hsv.y * vec3(\n        max(0.,min(1.,1.5-abs(6.*(hsv.x-0.-1./6.)))),\n        max(0.,min(1.,1.5-abs(6.*(hsv.x-1./3.-1./6.)))),\n        max(0.,min(1.,1.5-abs(6.*(hsv.x-2./3.-1./6.))))\n    ));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    uv = fragCoord/iResolution.xy;\n       \n    uv-=.5;\n    uv*=2.;\n\n    x = uv.x * 5.;\n\n              \n\n\n    vec3 b = vec3(0.);\n    for(int i=1; i<count+1; i++){\n        //b+=wave(muls[i].x)*muls[i].y;\n        float mul= 1./float(i);\n        float add = float(i)*.2;\n\n        float size = psin(iTime+float(i))+.2;\n        float gmul = i==count/2?-2.:1.;\n\n        float p=.2*float(i)/float(count);\n        vec3 color = hsv2rgb(vec3(p+fract(iTime*.1),1.,1.));\n\n        b += color*(gmul* psin((sin(iTime)*float(i)*3.)*wave(mul, size)) * psin(iTime*(1.+add)+add));\n    }\n\n\n    // Output to screen\n    fragColor = vec4(b,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/Ns2GDw.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "Ns2Szz", "name": "Implicit Surface Demo", "author": "zixin96", "description": "References:\nhttps://www.iquilezles.org/www/articles/distfunctions/distfunctions.htm by iq\nhttps://www.shadertoy.com/view/4tcGDr by jlfwong\nhttps://www.shadertoy.com/view/MlKBzd by Vermifuge\n\n", "tags": ["sdf"], "likes": 3, "viewed": 47, "date": "1619625115", "time_retrieved": "2024-06-20T20:38:10.108719", "image_code": "const int MAX_MARCHING_STEPS = 255;\nconst float MIN_DIST = 0.0;\nconst float MAX_DIST = 100.0;\nconst float EPSILON = 0.0001;\n\nmat3 rotateX(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(1, 0, 0),\n        vec3(0, c, -s),\n        vec3(0, s, c)\n    );\n}\n\nmat3 rotateY(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(c, 0, s),\n        vec3(0, 1, 0),\n        vec3(-s, 0, c)\n    );\n}\n\nmat3 rotateZ(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(c, -s, 0),\n        vec3(s, c, 0),\n        vec3(0, 0, 1)\n    );\n}\n\nfloat intersectSDF(float distA, float distB) {\n    return max(distA, distB);\n}\n\nfloat unionSDF(float distA, float distB) {\n    return min(distA, distB);\n}\n\nfloat differenceSDF(float distA, float distB) {\n    return max(distA, -distB);\n}\n\nfloat sdSphere( vec3 samplePoint, float radius )\n{\n  return length(samplePoint)-radius;\n}\n\nfloat sdRoundBox( vec3 samplePoint, vec3 dimensions, float roundness )\n{\n  vec3 q = abs(samplePoint) - dimensions;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0) - roundness;\n}\n\nfloat sdOctahedron( vec3 p, float s)\n{\n  p = abs(p);\n  float m = p.x+p.y+p.z-s;\n  vec3 q;\n       if( 3.0*p.x < m ) q = p.xyz;\n  else if( 3.0*p.y < m ) q = p.yzx;\n  else if( 3.0*p.z < m ) q = p.zxy;\n  else return m*0.57735027;\n    \n  float k = clamp(0.5*(q.z-q.y+s),0.0,s); \n  return length(vec3(q.x,q.y-s+k,q.z-k)); \n}\n\n\nfloat opSmoothUnion( float d1, float d2, float k ) \n{\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); \n}\n\nfloat cylinderSDF(vec3 p, float h, float r) {\n    // How far inside or outside the cylinder the point is, radially\n    float inOutRadius = length(p.xy) - r;\n    \n    // How far inside or outside the cylinder is, axially aligned with the cylinder\n    float inOutHeight = abs(p.z) - h/2.0;\n    \n    // Assuming p is inside the cylinder, how far is it from the surface?\n    // Result will be negative or zero.\n    float insideDistance = min(max(inOutRadius, inOutHeight), 0.0);\n\n    // Assuming p is outside the cylinder, how far is it from the surface?\n    // Result will be positive or zero.\n    float outsideDistance = length(max(vec2(inOutRadius, inOutHeight), 0.0));\n    \n    return insideDistance + outsideDistance;\n}\n\n\nvec2 one = vec2(1.0, 1.0);\n\nfloat sphereImport(vec3 p, float r) {\n\tp += 0.3*sin(0.5 * p.zxy + one.yxy*iTime);\n\tp += 0.2*sin(3.0 * p.yzx + one.yxy*iTime);\n\treturn length(p) - r;\n}\n\n\nfloat sceneSDF(vec3 samplePoint) {    \n    // Slowly spin the whole scene\n    samplePoint = rotateY(iTime / 2.0) * samplePoint;\n    \n    float cylinderRadius = 1.0;\n    float cylinder1 = cylinderSDF(samplePoint, 2.0, cylinderRadius);\n    float cylinder2 = cylinderSDF(rotateX(radians(90.0)) * samplePoint, 2.0, cylinderRadius);\n    float cylinder3 = cylinderSDF(rotateY(radians(90.0)) * samplePoint, 2.0, cylinderRadius);\n    float cys = unionSDF(cylinder1, unionSDF(cylinder2, cylinder3));\n    \n    float cubeOffset = 1.0 + sin(1.7 * iTime);\n    float cube = sdRoundBox(samplePoint - vec3(cubeOffset, 0.0, 0.0), vec3(0.1, 0.1, 0.1), 0.05);\n    cube = unionSDF(cube, sdRoundBox(samplePoint + vec3(cubeOffset, 0.0, 0.0), vec3(0.1, 0.1, 0.1), 0.05));\n    cube = unionSDF(cube, sdRoundBox(samplePoint - vec3(0.0, cubeOffset, 0.0), vec3(0.1, 0.1, 0.1), 0.05));\n    cube = unionSDF(cube, sdRoundBox(samplePoint + vec3(0.0, cubeOffset, 0.0), vec3(0.1, 0.1, 0.1), 0.05));\n    cube = unionSDF(cube, sdRoundBox(samplePoint - vec3(0.0, 0.0, cubeOffset), vec3(0.1, 0.1, 0.1), 0.05));\n    cube = unionSDF(cube, sdRoundBox(samplePoint + vec3(0.0, 0.0, cubeOffset), vec3(0.1, 0.1, 0.1), 0.05));\n      \n    float oct = sdOctahedron(samplePoint, 1.5);\n    \n    float sphere = sphereImport(samplePoint, 0.2);\n\n    return unionSDF(differenceSDF(opSmoothUnion(cube, oct, 0.4), cys), sphere);\n}\n\nfloat shortestDistanceToSurface(vec3 eye, vec3 marchingDirection, float start, float end) {\n    float depth = start;\n    for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n        float dist = sceneSDF(eye + depth * marchingDirection);\n        if (dist < EPSILON) {\n\t\t\treturn depth;\n        }\n        depth += dist;\n        if (depth >= end) {\n            return end;\n        }\n    }\n    return end;\n}\n            \n\nvec3 rayDirection(float fieldOfView, vec2 size, vec2 fragCoord) {\n    vec2 xy = fragCoord - size / 2.0;\n    float z = size.y / tan(radians(fieldOfView) / 2.0);\n    return normalize(vec3(xy, -z));\n}\n\n\nvec3 estimateNormal(vec3 p) {\n    return normalize(vec3(\n        sceneSDF(vec3(p.x + EPSILON, p.y, p.z)) - sceneSDF(vec3(p.x - EPSILON, p.y, p.z)),\n        sceneSDF(vec3(p.x, p.y + EPSILON, p.z)) - sceneSDF(vec3(p.x, p.y - EPSILON, p.z)),\n        sceneSDF(vec3(p.x, p.y, p.z  + EPSILON)) - sceneSDF(vec3(p.x, p.y, p.z - EPSILON))\n    ));\n}\n\nvec3 phongContribForLight(vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye,\n                          vec3 lightPos, vec3 lightIntensity) {\n    vec3 N = estimateNormal(p);\n    vec3 L = normalize(lightPos - p);\n    vec3 V = normalize(eye - p);\n    vec3 R = normalize(reflect(-L, N));\n    \n    float dotLN = dot(L, N);\n    float dotRV = dot(R, V);\n    \n    if (dotLN < 0.0) {\n        // Light not visible from this point on the surface\n        return vec3(0.0, 0.0, 0.0);\n    } \n    \n    if (dotRV < 0.0) {\n        // Light reflection in opposite direction as viewer, apply only diffuse\n        // component\n        return lightIntensity * (k_d * dotLN);\n    }\n    return lightIntensity * (k_d * dotLN + k_s * pow(dotRV, alpha));\n}\n\nvec3 phongIllumination(vec3 k_a, vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye) {\n    const vec3 ambientLight = 0.5 * vec3(1.0, 1.0, 1.0);\n    vec3 color = ambientLight * k_a;\n    \n    vec3 light1Pos = vec3(4.0 * sin(iTime),\n                          2.0,\n                          4.0 * cos(iTime));\n    vec3 light1Intensity = vec3(0.4, 0.4, 0.4);\n    \n    color += phongContribForLight(k_d, k_s, alpha, p, eye,\n                                  light1Pos,\n                                  light1Intensity);\n    \n    vec3 light2Pos = vec3(2.0 * sin(0.37 * iTime),\n                          2.0 * cos(0.37 * iTime),\n                          2.0);\n    vec3 light2Intensity = vec3(0.4, 0.4, 0.4);\n    \n    color += phongContribForLight(k_d, k_s, alpha, p, eye,\n                                  light2Pos,\n                                  light2Intensity);    \n    return color;\n}\n\nmat3 viewMatrix(vec3 eye, vec3 center, vec3 up) {\n    // Based on gluLookAt man page\n    vec3 f = normalize(center - eye);\n    vec3 s = normalize(cross(f, up));\n    vec3 u = cross(s, f);\n    return mat3(s, u, -f);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec3 viewDir = rayDirection(45.0, iResolution.xy, fragCoord);\n    vec3 eye = vec3(8.0, 5.0 * sin(0.2 * iTime), 7.0);\n    \n    mat3 viewToWorld = viewMatrix(eye, vec3(0.0, 0.0, 0.0), vec3(0.0, 1.0, 0.0));\n    \n    vec3 worldDir = viewToWorld * viewDir;\n    \n    float dist = shortestDistanceToSurface(eye, worldDir, MIN_DIST, MAX_DIST);\n    \n    if (dist > MAX_DIST - EPSILON) {\n        // Didn't hit anything\n        fragColor = vec4(0.0, 0.0, 0.0, 0.0);\n\t\treturn;\n    }\n    \n    // The closest point on the surface to the eyepoint along the view ray\n    vec3 p = eye + dist * worldDir;\n    \n    // Use the surface normal as the ambient color of the material\n    vec3 K_a = (estimateNormal(p) + vec3(1.0)) / 2.0;\n    vec3 K_d = K_a;\n    vec3 K_s = vec3(1.0, 1.0, 1.0);\n    float shininess = 10.0;\n    \n    vec3 color = phongIllumination(K_a, K_d, K_s, shininess, p, eye);\n    \n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/Ns2Szz.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "NsB3DV", "name": "Penumbra Shadow - CIS461", "author": "onlyname", "description": "Penumbra shadows.", "tags": ["raymarch", "shadow", "penumbra"], "likes": 0, "viewed": 35, "date": "1618023205", "time_retrieved": "2024-06-20T20:38:10.108719", "image_code": "const int RAY_STEPS = 256;\nconst float HALF_PI = 3.14159 * 0.5;\nconst float DEG_TO_RAD = 3.14159 / 180.0;\n\nstruct Intersection\n{\n    float t;\n    vec3 color;\n    vec3 p;\n    int object;\n};\n\nvec3 rotateX(vec3 p, float a) {\n    return vec3(p.x, cos(a) * p.y - sin(a) * p.z, sin(p.y) + cos(p.z));\n}\n\nvec3 rotateY(vec3 p, float a) {\n    return vec3(cos(a) * p.x + sin(a) * p.z, p.y, -sin(a) * p.x + cos(a) * p.z);\n}\n\nvoid raycast(vec2 uv, out vec3 dir, out vec3 eye, out vec3 ref) {\n    eye = vec3(0.0, 4, -18.0);\n    ref = vec3(0.0, 2.5, 0.0);\n    \n    float len = tan(3.14159 * 0.125) * distance(eye, ref);\n    vec3 H = normalize(cross(vec3(0.0, 1.0, 0.0), ref - eye));\n    vec3 V = normalize(cross(H, eye - ref));\n    V *= len;\n    H *= len * iResolution.x / iResolution.y;\n    vec3 p = ref + uv.x * H + uv.y * V;\n    dir = normalize(p - eye);\n}\n\nfloat sphere(vec3 p, float r, vec3 c)\n{\n    return distance(p, c) - r;\n}\n\nfloat torus(vec3 p, vec2 t)\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q) - t.y;\n}\n\nfloat cone(vec3 p, vec2 c)\n{\n    // c must be normalized\n    float q = length(p.xy);\n    return dot(c,vec2(q,p.z));\n}\n\n// Box with side lengths b\nfloat box(vec3 p, vec3 b)\n{\n  return length(max(abs(p) - b, 0.0));\n}\n\nfloat plane( vec3 p, vec4 n )\n{\n  // n must be normalized\n  return dot(p,n.xyz) + n.w;\n}\n\n#define FLOOR plane(pos, vec4(0.0, 1.0, 0.0, 2.5))\n#define SPHERE sphere(pos, 2.5, vec3(-3.0, 1.0, 0.0))\n#define CUBE box(rotateY(pos + vec3(-2.0, 1.0, -0.75), -17.5 * DEG_TO_RAD), 0.5 * vec3(3.0, 3.0, 3.0))\n\n#define FLOOR_NUM 4\n#define SPHERE_NUM 5\n#define CUBE_NUM 6\n\nfloat sceneMap3D(vec3 pos, vec3 lightPos)\n{\n    float t = FLOOR;\n    t = min(t, SPHERE);\n    t = min(t, CUBE);\n    return t;\n}\n\nvoid sceneMap3D(vec3 pos, out float t, out int obj, vec3 lightPos)\n{\n    t = FLOOR;\n    float t2;\n    obj = FLOOR_NUM;\n    if((t2 = SPHERE) < t) {\n        t = t2;\n        obj = SPHERE_NUM;\n    }\n    if((t2 = CUBE) < t) {\n        t = t2;\n        obj = CUBE_NUM;\n    }\n}\n\n// IQ\nfloat softShadow(vec3 dir, vec3 origin, float min_t, float max_t, float k) {\n    float res = 1.0;\n    for(float t = min_t; t < max_t;) \n    {\n        float m = sceneMap3D(origin + t * dir, dir);\n        if(m < 0.0001) \n        {\n            return 0.0; // In shadow\n        }\n        res = min(res, k * m / t);\n        t += m;\n    }\n    return res;\n}\n\nvoid march(vec3 origin, vec3 dir, out float t, out int hitObj, vec3 lightPos)\n{\n    t = 0.001;\n    for(int i = 0; i < RAY_STEPS; ++i)\n    {\n        vec3 pos = origin + t * dir;\n    \tfloat m;\n        sceneMap3D(pos, m, hitObj, lightPos);\n        if(m < 0.01)\n        {\n            return;\n        }\n        t += m;\n    }\n    t = -1.0;\n    hitObj = -1;\n}\n\nvec3 computeNormal(vec3 pos, vec3 lightPos)\n{\n    vec3 epsilon = vec3(0.0, 0.001, 0.0);\n    return normalize( vec3( sceneMap3D(pos + epsilon.yxx, lightPos) - sceneMap3D(pos - epsilon.yxx, lightPos),\n                            sceneMap3D(pos + epsilon.xyx, lightPos) - sceneMap3D(pos - epsilon.xyx, lightPos),\n                            sceneMap3D(pos + epsilon.xxy, lightPos) - sceneMap3D(pos - epsilon.xxy, lightPos)));\n}\n\nvec3 computeMaterial(int hitObj, vec3 p, vec3 n, vec3 light, vec3 view) {\n    float lambert = max(0.0, dot(n, light)) + 0.2;\n\n    switch(hitObj) {\n        case FLOOR_NUM:\n        return vec3(0.8, 0.85, 0.8) * lambert;\n        break;\n        case SPHERE_NUM:\n        return vec3(0.3, 0.6, 0.78) * lambert; \n        break;\n        case CUBE_NUM:\n        return vec3(0.8, 0.4, 0.6) * lambert; \n        break;\n        case -1:\n        // Background\n        return vec3(0.0);\n        break;\n    }\n    return vec3(1.0);\n}\n\nIntersection sdf3D(vec3 dir, vec3 eye, vec3 lightPos)\n{\n    float t;\n    int hitObj;\n    march(eye, dir, t, hitObj, lightPos);\n\n    vec3 isect = eye + t * dir;\n    vec3 nor = computeNormal(isect, lightPos);\n    vec3 lightDir = normalize(lightPos - isect);\n    vec3 light_t = (lightPos - isect) / lightDir; // find t of light pos\n    float vis = softShadow(lightDir, isect, 0.1, light_t.x, 12.0);\n    \n    vec3 surfaceColor = computeMaterial(hitObj, isect, nor, lightDir, normalize(eye - isect));\n    \n    return Intersection(t, surfaceColor * vis, isect, hitObj);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float d = sin(iTime);\n\tvec3 lightPos = vec3(0.0 + d, 7.45, 0.0);\n    \n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    // [-1, 1]\n    vec2 uv2 = 2.0 * uv - vec2(1.0);\n\n    Intersection aaIsects[4];\n    vec3 dir, eye, ref;\n    int idx = 0;\n    for(float i = 0.0; i < 1.0; i += 0.5) {\n        for(float j = 0.0; j < 1.0; j += 0.5) {\n            raycast(uv2 + vec2(i, j) / iResolution.xy, dir, eye, ref);\n            aaIsects[idx++] = sdf3D(dir, eye, lightPos);\n        }\n    }\n    vec3 avgColor = vec3(0.0);\n    for(int i = 0; i < 4; ++i) {\n        avgColor += aaIsects[i].color;\n    }\n    avgColor *= 0.25;\n    fragColor = vec4(avgColor * step(0.0, aaIsects[0].t), 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/NsB3DV.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "NsB3WG", "name": "Voronoi sample", "author": "tomoe", "description": "Algorithm for getting the closest neighbouring point is come from [url=https://www.shadertoy.com/view/fsSGWG]Distance to feature points II[/url]\nleft: 2D, right: 3D", "tags": ["bd202104"], "likes": 1, "viewed": 53, "date": "1617849201", "time_retrieved": "2024-06-20T20:38:10.114746", "image_code": "uvec3 k = uvec3(0x456789abu, 0x6789ab45u, 0x89ab4567u);\nconst uint max32 = 0xffffffffu;\nconst float PI = 3.14159265359;\nuvec2 hash22u(uvec2 n) {  \n    n ^= (n.yx << 24);\n    n ^= (n.yx >> 1);\n    n *= k.xy;\n    n ^= (n.yx << 1);\n    return n * k.xy;\n}\nuvec3 hash33u(uvec3 n) {\n    n ^= (n.yzx << 24);\n    n ^= (n.yzx >> 1);\n    n *= k;\n    n ^= (n.yzx << 1);\n    return n * k;\n}\nmat2 rot2(float t) {\n    return mat2(cos(t), sin(t), -sin(t),  cos(t));\n}\nvec2 hash22(vec2 p) {\n    uvec2 n = uvec2(p);\n    return vec2(hash22u(n)) / vec2(max32);\n}\nvec3 hash33(vec3 p) {\n    uvec3 n = uvec3(p);\n    return vec3(hash33u(n)) / vec3(max32);\n}\nfloat length2(vec2 v){\n    return dot(v, v);\n}\nfloat length3(vec3 v){\n    return dot(v, v);\n}\nvec2 voronoi2(vec2 p){   \n    vec2 n = round(p);\n    vec2 f = p - round(p);\n    float dist = length2(abs(f) + 0.5);\n    vec2 sgn = vec2(1.0);\n    vec2 glid = vec2(0.0);\n    vec2 id;\n    for(float j = 0.0; j <= 2.0; j ++ ) {\n        glid.y += sgn.y * j;\n        sgn.y *= -1.0;\n        if (abs(glid.y - f.y) - 0.5 > sqrt(dist)){\n            continue;\n        }\n        for(float i = 0.0; i <= 2.0; i ++ ){\n            glid.x += sgn.x * i;\n            sgn.x *= -1.0;\n            vec2 nbd = glid;\n            nbd += rot2(iTime) * (hash22(n + nbd) - 0.5)/sqrt(2.0);\n            if(length2(nbd - f) < dist){\n                id = n + glid;\n                dist = length2(nbd - f);\n            }\n        }\n        glid.x = 0.0;\n    }\n    return id;\n}\nvec3 voronoi3(vec3 p){   \n    vec3 n = round(p);\n    vec3 f = p - round(p);\n    float dist = length3(abs(f) + 0.5);\n    vec3 sgn = vec3(1.0);\n    vec3 glid = vec3(0.0);\n    vec3 id;\n    for(float k = 0.0; k <= 2.0; k ++ ) {\n            glid.z += sgn.z * k;\n            sgn.z *= -1.0;\n            if (abs(glid.z - f.z) - 0.5 > sqrt(dist)){\n                continue;\n            }\n        for(float j = 0.0; j <= 2.0; j ++ ) {\n            glid.y += sgn.y * j;\n            sgn.y *= -1.0;\n            if (abs(glid.y - f.y) - 0.5 > sqrt(dist)){\n                continue;\n            }\n            for(float i = 0.0; i <= 2.0; i ++ ){\n                glid.x += sgn.x * i;\n                sgn.x *= -1.0;\n                vec3 nbd = glid + hash33(n + glid) -0.5;\n                if(length3(nbd - f) < dist){\n                    id = n + glid;\n                    dist = length3(nbd - f);\n                }\n            }\n            glid.x = 0.0;\n        }\n        glid.y = 0.0;\n    }\n    return id;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    vec2 pos = fragCoord.xy/ iResolution.xx;\n    pos *= 20.0;\n    pos += iTime;\n    float time = iTime;\n    vec3 v;\n    if(fragCoord.x < 0.5 * iResolution.x){\n        v = vec3(hash22(voronoi2(pos)), 1.0);\n    } else {\n        v = hash33(voronoi3(vec3(pos, iTime)));\n    }\n    fragColor = vec4(vec3(v), 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/NsB3WG.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "NsB3zK", "name": "Neon Wire Frame Ngon", "author": "Tater", "description": "code is not good, maybe I will come back later and make it nicer. \n\nCollab with @Drakyen\nSee their version: [url] https://www.shadertoy.com/view/NsB3zV[/url]", "tags": ["2d", "cube", "wireframe", "glow", "neon"], "likes": 6, "viewed": 282, "date": "1617629542", "time_retrieved": "2024-06-20T20:38:10.114831", "image_code": "#define pi 3.14159265359\n\n//taken from a comment fabrice left. \nfloat segdf(vec2 p, vec2 a, vec2 b ) {\n\tvec2 pa = p - a;\n\tvec2 ba = b - a;\n\tfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0., 1. );\n\treturn length( pa - ba*h );\n}\n\nvec2 loop (float t, float div, float i){\n\nreturn 0.25*vec2(sin(t+(i+1.0)*pi/div)*2.0,0.5*cos(t+(i+1.0)*pi/div));\n\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 R = iResolution.xy;\n    vec2 uv = (fragCoord-.5*R.xy)/R.y;\n    float t = iTime;\n    vec3 col =vec3(0.0);\n    float occlude = 1.0; //Change to 0.0 to see all the lines\n    \n    float sides = 3.0 + floor((sin(t*1.2)*0.5+0.5)*5.);\n   // sides =3.;\n    for(float i = 0.0; i<sides;i++){\n        float div = sides/2.0;\n\n        vec2 loop1 = loop(t,div,i-1.);\n        vec2 loop11 = loop(t,div,i);\n        vec2 loop111 = loop(t,div,i-2.);\n        loop1.y+=.30;\n        loop11.y+=.30;\n\n        vec2 loop2 = loop(t,div,i-1.);\n        vec2 loop22 = loop(t,div,i);\n        loop2.y-=.35;\n        loop22.y-=.35;\n\n        vec3 glowcol = vec3(fract(t/5.+0.333),fract(t/5.+0.666),fract(t/5.));\n        float num = 200.0+(1.0+sin(t*5.0))*200. +10.*sides;\n\n        //BOTTOM\n        float glow = abs(1.0 / (num * segdf(uv,loop2,loop22)));\n        col += (glow)*(glowcol+1.0) * (step(loop22.y+loop2.y,-.7*occlude));\n        //SIDES\n        glow = abs(1.0 / (num * segdf(uv,loop1,loop2))); \n        if((loop1.x>loop11.x || loop1.x<loop11.x && loop1.x<loop111.x)||occlude == 0.0){\n        col +=(glow)*(glowcol+1.0);\n        }\n        //TOP\n        glow = abs(1.0 / (num * segdf(uv,loop1,loop11)));\n        col +=(glow)*(glowcol+1.0);\n    }\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/NsB3zK.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "NsB3zV", "name": "N-Sided wireframe cylinder", "author": "Drakyen", "description": "A fun shader that renders a spinning, N-Sided wireframe cylinder! You can also change the rotation ellipses with squish and expand.\n\nCollab with @Tater\nSee their version: [url] https://www.shadertoy.com/view/NsB3zK[/url]", "tags": ["wireframe", "nsided"], "likes": 5, "viewed": 124, "date": "1617635087", "time_retrieved": "2024-06-20T20:38:10.114831", "image_code": "#define pi 3.14159265359\n\nfloat lsdf(vec2 p, vec2 a, vec2 b ) {\n\tvec2 pa = p - a;\n\tvec2 ba = b - a;\n\tfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0., 1. );\n\treturn length( pa - ba*h );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n    \n    float points = 8.;\n    float height = 0.5;\n    float squish = 12.;  \n    float expand = 2.6;\n    float glow = 300.;\n    \n    \n    float bright = 0.;\n    \n    for(float i = 0.; i < points; i++)\n    {\n        vec2 point1 = vec2(sin((i/points + iTime / 4.) * 2. * pi) / expand, cos((i/points + iTime / 4.) * 2. * pi) / squish) + vec2(0., 0.3);\n        vec2 point10 = vec2(sin(((i - 1.)/points + iTime / 4.) * 2. * pi) / expand, cos(((i - 1.)/points + iTime / 4.) * 2. * pi) / squish) + vec2(0., 0.3); \n        vec2 point11 = vec2(sin(((i + 1.)/points + iTime / 4.) * 2. * pi) / expand, cos(((i + 1.)/points + iTime / 4.) * 2. * pi) / squish) + vec2(0., 0.3); \n        \n        vec2 point2 = point1 - vec2(0.,height);\n        vec2 point20 = point10 - vec2(0.,height);\n        vec2 point21 = point11 - vec2(0.,height);\n    \n        if((point1.x > point11.x || point1.x < point11.x && point1.x < point10.x) || points < 2.)\n        {       \n            bright += step(lsdf(uv, point1, point2), 0.009);\n            bright += abs(1.0 / (glow * lsdf(uv,point1,point2)));     \n        }\n        \n        bright += step(lsdf(uv, point1, point11), 0.009);\n        bright += abs(1.0 / (glow * lsdf(uv,point1,point10))); \n              \n        if(point2.x > point21.x || points < 2.)\n        {    \n            bright += step(lsdf(uv, point2, point21), 0.009);   \n            bright += abs(1.0 / (glow * lsdf(uv,point2,point21)));\n        }\n        \n    \n    }\n    \n    \n    // Output to screen\n    fragColor = vec4(0.,bright,bright,1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/NsB3zV.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "NsBGW1", "name": "FristShader314 - Mercy Edition", "author": "Domain314", "description": "Mercy's wonderful interpretation of my FirstShader314.\nShe messed around with some values, after I explained that it's all just math :)", "tags": ["2d", "abstract", "messingaround", "artofcode", "mercy"], "likes": 5, "viewed": 68, "date": "1617290992", "time_retrieved": "2024-06-20T20:38:10.387625", "image_code": "float Hash21(vec2 p){\n    p = fract(p*vec2(234.34, 435.345));\n    p += dot(p, p+34.23);\n    return fract (p.x*p.y);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.8*iResolution.xy)/iResolution.y;\n    vec2 UV = fragCoord.xy/iResolution.xy;\n    \n    vec3 col = vec3(0.25);\n    \n    uv.y -= iTime*.1;\n    uv *= 3.;\n    vec2 gv = fract(uv)-.5;\n    vec2 id = floor(uv);\n    \n    float n = Hash21(id); \n    \n    float width = .3*UV.y;\n    float d = abs(abs(gv.x + gv.y)-.5);\n\n    \n    if (n<.5) gv.y *= -1.;\n    \n    \n    vec2 cUv = gv-sign(gv.x+gv.y+ .0001)*.5;\n    d = length(cUv);\n    float mask = smoothstep(.01, -.01,abs(d-.5)-width);\n    float angle = atan(cUv.x, cUv.y);                   // -pi to pi\n    float checker = mod(id.x+id.y, 8.)*8.-8.;\n    float flow = sin(iTime+checker*angle*5.);\n    \n    \n    float y = fract(checker*angle/3. + iTime*.3);\n    float x = (d-(.5-width))/(2.*width);\n    y = abs(y-.5)*2.;\n    vec2 tUv = vec2(y,x);\n    \n    col += texture(iChannel0,tUv).rgb*mask;\n    col *= 2.-tUv.y;\n    \n    //col.rg += tUv*mask;\n    \n    //col += y * mask;\n    \n    //if(gv.x>.48 || gv.y>.48) col = vec3(1,0,0);\n    fragColor = vec4(col,2.0);\n}", "image_inputs": [{"id": "XdfGRn", "previewfilepath": "/media/ap/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/NsBGW1.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "NsBGWK", "name": "Watercolor Rorschach with Perlin", "author": "Ezra_Szanton", "description": "Was trying to recreate this textured paper effect https://twitter.com/SkinnyShips/status/1380218534542733315?s=20, ended up with something different :) ", "tags": ["perlinrorschachwatercolor"], "likes": 2, "viewed": 96, "date": "1617922495", "time_retrieved": "2024-06-20T20:38:10.387625", "image_code": "//hash function taken from https://www.shadertoy.com/view/4djSRW\nfloat hash12(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\nfloat smoothNoise(vec2 uv)\n{\n    vec2 lv = fract(uv);\n    vec2 id = floor(uv);\n    \n    lv = lv * lv * (3. - 2.*lv);\n    \n    float bl = hash12(id);\n    float br = hash12(id + vec2(1., 0.));\n    \n    float b = mix(bl, br, lv.x);\n    \n    \n    float tl = hash12(id + vec2(0., 1.));\n    float tr = hash12(id + vec2(1., 1.));\n    \n    float t = mix(tl, tr, lv.x);\n    \n    float c = mix(b,t, lv.y);\n    return c;\n}\n\nfloat perlin(vec2 uv)\n{\n    \n    float c = smoothNoise(uv * 4.* sin(1. * 0.01 + .113));\n    c += smoothNoise(uv * 8. * sin(1. * 0.12)) * 0.5;\n    c += smoothNoise(uv * 16. * sin(1. * 0.1 + 1.213)) * 0.25;\n    c += smoothNoise(uv * 32.* sin(1. * 0.042 + .213)) * 0.125;\n    c += smoothNoise(uv * 64. * sin(1. * 0.0037 + .113)) * 0.0625;\n    c /= 2.;\n    return c;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-0.5*iResolution.xy)/iResolution.y;\n\n    uv *= 2.;\n    uv.x = abs(uv.x);\n    \n    vec3 blue = vec3(0.3, 0.35, 0.8);\n    \n    vec3 red = vec3(0.8, 0.35, 0.3);\n\n    vec3 white = vec3(0.8, 0.8, 0.7);\n\n    float slowTime = iTime / 2.;\n    \n    vec2 location = vec2(200. * perlin( vec2(floor(iTime/3.))));\n    \n    float val = smoothstep(0.26, 0.25, (perlin(uv/1. + location )) / 2.);\n    val = val * (1.5 + 0.6 * sin(slowTime) - length(uv));\n\n    vec3 col = vec3(0);\n\n    val = min(val, 1.);\n    val -= perlin(uv * 200.) * perlin(uv * 100.);\n    val = max(val, 0.);\n\n    if(val > 0.8){\n        col = blue;\n    } else {\n        col = white;\n    }\n\n    col = mix(white, blue, val);\n    col = mix(col, red, val * val * val * val * val);\n\n    \n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/NsBGWK.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "NsfSRB", "name": "Mossy rock", "author": "jarble", "description": "A more realistic moss pattern based on my \"bitwise lichen\" shader.", "tags": ["fractal", "rock", "stone", "bitwise", "moss", "lichen"], "likes": 3, "viewed": 133, "date": "1618752528", "time_retrieved": "2024-06-20T20:38:10.387625", "image_code": "// Inspired by a discussion on hackaday at:\n// https://hackaday.com/2021/04/13/alien-art-drawn-with-surprisingly-simple-math/\n// Formula shared by \"Joe\" on that page..\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Scale and move to make things a litle more interesting t look at.\n    float scale = .5;\n    float trans = iTime * 25.0*10.0;\n    vec2 coord = scale*(fragCoord + vec2(trans,0.0));\n    \n    // Heart of color selection.\n    int val = ((int(coord.x) & int(coord.y)) % 3);\n    float result = 0.0;\n    vec3 col = vec3(0.0);\n    vec3 col_prev;\n    for(int i = 0; i < 9; i++){\n        col_prev = col;\n        coord.y += (2.0+result)/2.0;\n        coord += coord.yy/4.0;\n        coord = coord.yx/(2.0);\n        result = ((result + float(val = ((int(coord.x) | int(coord.y)) % (3+val))))/(2.0));\n        col.x = (result+col.z)/2.0;\n        col = (fract((col.yzx))+col_prev)/2.0;\n    }\n    // Output.\n    fragColor = vec4((col),0.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/NsfSRB.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "NsfSWj", "name": "odd structures", "author": "sukupaper", "description": "I just found how stereographic projection works and its formula ~ I'm pretty bad at maths, so I'm proud to myself for this result :'D", "tags": ["raymarching", "domainrepetition", "repetition", "structures"], "likes": 21, "viewed": 235, "date": "1619201147", "time_retrieved": "2024-06-20T20:38:10.823985", "image_code": "// Author: paperu\n// Title: odd structures\n\nconst float P = 6.28318;\n\nfloat t;\nint matId;\nvec3 map, pOffset;\n\nmat2 rot(in float a) { return mat2(cos(a), sin(a), -sin(a), cos(a)); }\n\nfloat box(in vec3 p, in float s, in float r) { return length(max(abs(p) - s, 0.)) - r; }\nfloat ibox(in vec3 p, in float s) { p = abs(p) - s; return min(max(p.y, p.z), min(max(p.x, p.y), max(p.x, p.z))); }\n\nfloat df(in vec3 p) {\n    p += pOffset;\n    \n    vec3 pp = map = mod(p, 4.) - 2.;\n    p = mod(p - .5, 1.) - .5;\n    \n    float b1 = max(box(p, .45, .02), -ibox(p, .4));\n    p = abs(p) - .5;\n    float b2 = max(box(p, .15, .01), -ibox(p, .125));\n    float b3 = max(box(pp, 1.3, .01), -ibox(pp, 1.25));\n    \n    float d = min(min(b1, b2), b3);\n    matId = d == b1 ? 1 : d == b2 ? 2 : 3;\n    return d;\n}\n\nstruct rmRes { vec3 pos; int it; bool hit; };\nrmRes rm(in vec3 c, in vec3 r) {\n    rmRes res; res.pos = c, res.hit = true, res.it = 0;\n    for(int i = 0; i < 25; i++) {\n        float d, dd;\n        if((d = df(res.pos)) < .0001) return res;\n        res.pos += d*(r += r*d*.075);\n        mat2 rt = rot(d*.25); r.xy *= rt, r.xz *= rt, r.yz *= rt;\n        res.it++;\n    }\n    res.hit = false;\n    return res;\n}\n\nvec3 plane2sphere(in vec2 p) {\n    float t = -4./(dot(p,p) + 4.);\n    return vec3(-p*t, 1. + 2.*t);\n}\n\nfloat anim1(in float x, in float off, in float steps) {\n    x += off;\n    return (1. - min(mod(floor(x + 1.), steps), 1.))*smoothstep(0., 1., fract(x)) + floor(x/steps);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 st = (fragCoord.xy - .5*iResolution.xy)/iResolution.x;\n    \n    t = iTime*.5 + .75;\n    float a[6];\n    for(int i = 0; i < 6; i++)\n        a[i] = anim1(t, float(i), 6.);\n    pOffset = vec3(a[1] + a[5], a[0] - a[3], a[2] - a[4]);\n    \n    vec3 c = vec3(0., 0., -5.), r = plane2sphere(st*P*1.5);\n    mat2 rt = rot(t*.75); r.xy *= rt, r.xz *= rt, r.yz *= rt;\n    \n    rmRes res = rm(c,r);\n    \n    vec3 color = vec3(0.);\n    if(res.hit) {\n        color = matId == 1 ? vec3(.174, .239, .765)\n            : matId == 2 ? vec3(1., .23, .249)\n            : vec3(1., .681, .049)*step(.5,fract((map.x + map.y + map.z)*10.));\n    }\n    float dist = distance(res.pos, c);\n    color += dist*.025;\n    color -= pow(max(0., float(res.it)*.0225),2.);\n\tcolor = mix(color, color.ggg, min(1., dist*dist*dist*.08));\n    \n    fragColor = vec4(color, 1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/NsfSWj.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "NsfSz8", "name": "Improved Perlin Noise 3D", "author": "khalladay", "description": "\"Improved\" 3D Perlin noise (from the \"Improving Noise\" paper) used to distort the surface of a sphere. Perlin noise also used for background and sphere surface color because yolo. Click and drag to rotate the camera around the sphere", "tags": ["3d", "perlin"], "likes": 0, "viewed": 119, "date": "1618323672", "time_retrieved": "2024-06-20T20:38:12.005777", "image_code": "#define NUM_OCTAVES 2\n\n//uncomment below for original recipe perlin noise\n//#define OLD_PERLIN\n\n//not perfect, but the best looking hash function that I found after\n//trying out a couple. No jarring discontinuities as UVs scroll and less\n//repetitive than others I tried. Taken from https://www.shadertoy.com/view/4djSRW\nfloat hash31(vec3 p3)\n{\n\tp3  = fract(p3 * vec3(.1031,.11369,.13787));\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n//the \"fade\" function defines the value used to blend values\n//from each corner of the unit cube\n//The \"Improving Noise\" paper updates\n//this from 3t^2-2t^3 to 6t^5-15t^4+10t^3\nfloat fade(float t)\n{\n#ifdef OLD_PERLIN\n    return t * t * (3.0-2.0*t);\n#else\n    return  t * t * t * (t * (t * 6.0 - 15.0) + 10.0);\n#endif\n}\n\n//original perlin noise calculates gradient functions randomly, whereas \"improved\" perlin\n//selects randomly from a fixed array of vectors.\nvec3 grad(vec3 p)\n{\n#ifdef OLD_PERLIN\n    return -1.0 + 2.0 *vec3(hash31(p.xyz), hash31(p.yxy), hash31(p.zyx));\n#else\n    float r = hash31(p)*16.0;\n    int ri = int(r);\n    \n    vec3 grads[16];\n\n    grads[0] = vec3(1.0, 1.0, 0.0);\n    grads[1] = vec3(-1.0, 1.0, 0.0);\n    grads[2] = vec3(1.0, -1.0, 0.0);\n    grads[3] = vec3(-1.0, -1.0, 0.0);\n    \n    grads[4] = vec3(1.0, 0.0, 1.0);\n    grads[5] = vec3(-1.0, 0.0, 1.0);\n    grads[6] = vec3(1.0, 0.0, -1.0);\n    grads[7] = vec3(-1.0, 0.0, 1.0);\n\n    grads[8] = vec3(0.0, 1.0, 1.0);\n    grads[9] = vec3(0.0, -1.0, 1.0);\n    grads[10] = vec3(0.0, 1.0, -1.0);\n    grads[11] = vec3(0.0, -1.0, -1.0);\n\n    //pad array to 16 to avoid the cost of dividing by 12\n    grads[12] = vec3(1.0, 1.0, 0.0);\n    grads[13] = vec3(-1.0, 1.0, 0.0);\n    grads[14] = vec3(0.0, -1.0, 1.0);\n    grads[15] = vec3(0.0, -1.0, -1.0);\n\n    return grads[ri%16];\n#endif\n}\n\nfloat perlin3d(vec3 p)\n{\n    //floorP is used to generate the gradient vectors for the 4 corners of the unit cube\n    //that surround point p. Since we already need floorP, it's easier to get fractP\n    //via subtraction than a fract()\n    vec3 floorP = floor(p);\n    vec3 fractP = p - floorP;\n    \n    //calculate distance vectors from the input coordinate to the 4 corners of the unit cube\n    //these are used to weight the contributions from each corner's gradient vector\n    \n    // \"near\" corners (z == 0)\n    vec3 ntopLeft = fractP - vec3(0.0, 1.0, 0.0);\n    vec3 ntopRight = fractP - vec3(1.0,1.0, 0.0);\n    vec3 nbottomLeft = fractP;\n    vec3 nbottomRight = fractP - vec3(1.0,0.0, 0.0);\n    \n    // \"far\" corners (z > 0)\n    vec3 ftopLeft = fractP - vec3(0.0, 1.0, 1.0);\n    vec3 ftopRight = fractP - vec3(1.0,1.0, 1.0);\n    vec3 fbottomLeft = fractP - vec3(0.0,0.0,1.0);\n    vec3 fbottomRight = fractP - vec3(1.0,0.0, 1.0);\n\n    //determine gradient vectors for each corner of the cube\n    //must be uniform for all sample points within the same \"tile\" of the noise plane.\n    //(so (2.4,1.2)'s gradient vectors will be the same as (2.7,1.6)'s)\n    vec3 ntopLeftGrad = grad(floorP + vec3(0.0, 1.0, 0.0));\n    vec3 ntopRightGrad = grad(floorP + vec3(1.0, 1.0, 0.0));\n    vec3 nbottomLeftGrad = grad(floorP);\n    vec3 nbottomRightGrad = grad(floorP + vec3(1.0, 0.0, 0.0));\n    \n    vec3 ftopLeftGrad = grad(floorP + vec3(0.0, 1.0, 1.0));\n    vec3 ftopRightGrad = grad(floorP + vec3(1.0, 1.0, 1.0));\n    vec3 fbottomLeftGrad = grad(floorP + vec3(0.0, 0.0, 1.0));\n    vec3 fbottomRightGrad = grad(floorP + vec3(1.0, 0.0, 1.0));\n    \n    float ng1 = dot(ntopLeft, ntopLeftGrad);\n    float ng2 = dot(ntopRight, ntopRightGrad);\n    float ng3 = dot(nbottomLeft, nbottomLeftGrad);\n    float ng4 = dot(nbottomRight, nbottomRightGrad);\n    \n    float fg1 = dot(ftopLeft, ftopLeftGrad);\n    float fg2 = dot(ftopRight, ftopRightGrad);\n    float fg3 = dot(fbottomLeft, fbottomLeftGrad);\n    float fg4 = dot(fbottomRight, fbottomRightGrad);\n\n    //mix 2 bottom influences together, left to right, according to fade(fractP.x)\n    //then blend them bottom to top according to fade(fractP.y)\n    float nmix = mix( mix(ng3,ng4,fade(fractP.x)), mix(ng1,ng2,fade(fractP.x)), fade(fractP.y) );\n    float fmix = mix( mix(fg3,fg4,fade(fractP.x)), mix(fg1,fg2,fade(fractP.x)), fade(fractP.y) );\n    return mix(nmix, fmix, fade(fractP.z));\n}\n\nfloat fbm( in vec3 x)\n{    \n    float H = 1.0;\n    float G = exp2(-H);\n    float f = 1.0;\n    float a = 1.0;\n    float t = 0.0;\n    for( int i=0; i<NUM_OCTAVES; i++ )\n    {\n        t += a*perlin3d(f*x);\n        f *= 2.0;\n        a *= -G/1.5;\n    }\n    return t;\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat sdSphere( vec3 p, float s )\n{\n  return length(p)-s;\n}\n\n\nfloat map(vec3 at)\n{\n  return sdSphere(at, 3.0) + fbm(at * 1.25);\n}\n\n\n// http://iquilezles.org/www/articles/normalsSDF/normalsSDF.htm\nvec3 calcNormal( in vec3 pos )\n{\n    // inspired by tdhooper and klems - a way to prevent the compiler from inlining map() 4 times\n    vec3 n = vec3(0.0);\n    for( int i=0; i<4; i++ )\n    {\n        vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);\n        n += e*map(pos+0.0005*e);\n    }\n    return normalize(n);   \n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float mouseX = (-iMouse.x / iResolution.x) * 10.0;\n    \n    //xz coords for camera are a circle\n    vec3 CAM_OFFSET = 6.0 * (vec3( cos(mouseX), 0.0 , sin(mouseX) ));    \n\tvec3 CAM_UP = vec3(0.0, 1.0, 0.0);\n\tvec3 CAM_POS = vec3(0,3,0) + CAM_OFFSET;\n\tvec3 CAM_LOOKPOINT = vec3(0.0, 0.0, 0.0);\n\t\n\tvec3 lookDirection = normalize(CAM_LOOKPOINT - CAM_POS);\n\tvec3 viewPlaneU = normalize(cross(CAM_UP, lookDirection));\n\tvec3 viewPlaneV = cross(lookDirection, viewPlaneU);\n\tvec3 viewCenter = lookDirection + CAM_POS;\n\t\n    //remap uvs to -1 - +1\n\tvec2 uv = -1.0 + 2.0*fragCoord.xy / iResolution.xy;\n\n\tvec3 fragWorldPos = viewCenter + (uv.x * viewPlaneU * iResolution.x / iResolution.y) + (uv.y * viewPlaneV);\n\tvec3 camPosToFragWorld = normalize(fragWorldPos - CAM_POS);\n\n\tconst float farClip = 50.0;\n\t\n\tvec3 col = mix(vec3(perlin3d(vec3(fragCoord.xy*0.05,iTime*0.5))) * vec3(0.25), vec3(0.3,0.5,0.95)*vec3(1.0+perlin3d(vec3(fragCoord.xy*0.025,iTime*0.5))), fragCoord.y/iResolution.y);\n    \n    vec3 light1 = normalize(vec3(1,1,-1));\n\n\tvec3 p = CAM_POS;\n\tfor (int i = 0; i < 128; ++i)\n    {\n        float s=map(p);\n\n        if ( abs(s) < 0.001 )\n\t\t{\n            vec3 nrm = (calcNormal(p));\n            vec3 sphereCol = mix(vec3(0.95,0.25,0.25), vec3(1,1,1), 0.5+perlin3d(p*0.5));\n              \n            vec3 halfVec = normalize(light1 + camPosToFragWorld);\n            float spec = pow(max(dot(nrm, halfVec), 0.0), 32.0);\n\n\n            col = sphereCol * max(0.0, dot(nrm, light1));\n            col += sphereCol * spec;\n            col += sphereCol * 0.25;\n\n            break;\n\t\t}\n       \n        if (s > 10.0) break;\n        \n        //we don't have a true distance function, so we need to \n        //reduce the size of our steps to eliminate holes in the render\n\t\tp += camPosToFragWorld*s*0.4;\n\n    }\n  \n    fragColor = vec4(col, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/NsfSz8.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "NsfXRf", "name": "Cookie casual Shader Showdown ", "author": "jeyko", "description": "we did this with Cookie Collective on a stream. ", "tags": ["shader", "design", "showdown"], "likes": 19, "viewed": 275, "date": "1618930622", "time_retrieved": "2024-06-20T20:38:12.005777", "image_code": "#define pmod(p,a) mod(p ,a) - 0.5*a\n#define rot(a) mat2(cos(a),-sin(a),sin(a),cos(a))\nfloat nois(vec3 _p){\n  vec4 p = vec4(_p,1. + iTime);\n  float n = 0.;\n  float amp = 1.;\n  for(int i = 0; i < 5; i++){\n  \n    p.xz *= rot(0.5);\n    p.wz *= rot(0.5);\n    p.yz *= rot(0.5);  \n    n += dot(sin(p),cos(p))*amp;\n  \n    amp *= 0.7;\n    p *= 1.5;\n  }\n  return n;\n}\nfloat N = 0.;\n\nvec3 pal(float m){return pow(0.5 + 0.5*sin(m + vec3(-0.5,-0.,0.5)),vec3(0.2));}\n\nfloat map(vec3 p){\n  N = nois(p*4.)*0.1;\n  float d = 10e5;\n  for(float i = 0.; i < 5.; i++){\n    p.xz *= rot(0.4 + (iTime + sin(iTime + i*11.5))*0.2);\n    p.yz *= rot(0.4 + (iTime + sin(iTime + i))*0.2);\n    d = min(d, length(p.xz) - 0.04 - N*0.5);\n    \n  }\n  return d;\n}\n\nfloat sdBox(vec2 p, vec2 s){p = abs(p) -s; return max(p.x,p.y);}\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n\t\t\n    vec2 uv = (fragCoord - 0.5*iResolution.xy)/iResolution.y;\n\n    \n    vec3 col = vec3(1);\n  \n  float pxsz = fwidth(uv.x);\n  {\n    vec3 c = vec3(0.6,0.2,0.7) + sin(uv.xyx*20.)*0.3;\n    \n    float md = 0.1;\n    \n    vec2 p = uv;\n    p.x += (sin(iTime) + iTime+ cos(iTime*1.5))*0.2;\n    vec2 id = floor(p/md);\n    float m = (sin(id.x + iTime + cos(id.y)*3.));\n    c = pal(uv.x + id.x);\n    p = pmod(p,md);\n    p *= rot(m + iTime);\n    \n    float d = abs(p.x);\n    d = min(d,abs(p.y));\n    \n    d = max(d,abs(length(p)- m*md*0.5) - 0.01);\n    \n    col = mix(col,c,smoothstep(pxsz,0.,d - 0.003));\n  }\n  {\n    vec3 c = vec3(0.6,0.2,0.7) + sin(uv.xyx*20.)*0.3;\n    \n    float md = 0.2;\n    \n    vec2 p = uv;\n    p += 0.05;\n    p.x += (sin(iTime) + iTime+ cos(iTime*1.5))*0.1;\n    vec2 id = floor(p/md);\n    float m = (sin(id.x + iTime + cos(id.y)*3.));\n    c = pal(uv.x + id.x);\n    p = pmod(p,md);\n    //p *= rot(m + iTime);\n    \n    float d = abs(p.x);\n    d = min(d,abs(p.y));\n    \n    //d = max(d,abs(length(p)- m*md*0.5) - 0.01);\n    \n    col = mix(col,c,smoothstep(pxsz,0.,d - 0.0001));\n  }\n  \n  \n  \n  {\n    vec3 p = vec3(0,0,-2);\n    vec3 rd = normalize(vec3(uv,1));\n    bool hit = false; float t= 0.;\n   \n    for(int i = 0; i < 60; i++){\n      float d = map(p);\n      if(d < 0.01){\n        hit = true;\n        break;\n      }\n      \n      p += rd*d;\n    }\n    if(hit){\n      //col = 1.-col;\n      col = vec3(1);\n      col = mix(col,pow(pal(p.x + p.y + sin(p.x)),vec3(2.)),nois(p*4.)*0.6);\n    }\n  }\n  \n  #define xor(a,b,c) min(max(a + c,-(b)),max(b,-(a)))\n  {\n    vec2 p = uv;\n    \n    float d = 10e5;\n    for(float i = 0.; i < 5.; i++){\n      float m = sin(iTime+i + cos(iTime+i));\n      vec2 q = p + vec2(m,0.)*0.2;\n      d = xor(d,abs(length(q) - length(sin(iTime+m))*0.2 ) - 0.01*m,-0.01);\n    }\n    col = mix(col,1.2-col,smoothstep(pxsz,0.,d));\n    \n  }\n  \n  {\n    vec2 p = uv;\n    p.y = abs(p.y) - 0.45;\n    float id = floor(p.x/0.1+ iTime*4. + cos(iTime+ sign(uv.y)*2. - 1.) + sign(uv.y)*2. - 1.);\n    \n    float d = abs(p.t) - 0.1;\n    \n    \n    col = mix(col,1.2-col*pal(id),smoothstep(pxsz,0.,d));\n    col = mix(col,1.2-col*pal(id*2.),smoothstep(pxsz,0.,abs(d) - 0.02));\n    \n    \n  }\n  \n  {\n    vec2 p = uv;\n    //p.y = abs(p.x) - 0.45;\n    \n    float d = abs(p.x - 0.6) - 0.1;\n    d = sdBox(p.x - vec2(0.5,0.),vec2(0.1,0.3));\n    \n    col = mix(col,1.-col*(0.6 + 0.5*pal(uv.y*4.)),smoothstep(pxsz,0.,d));\n    //col = mix(col,1.2-col*pal(id*2.),smoothstep(pxsz,0.,abs(d) - 0.02));\n    \n    \n  }\n  //col = 1. - col;\n  \n  //col = smoothstep(vec3(0),vec3(1.,0.9,1.1),col);\n  //col = pow();\n  \n  col = pow(col,vec3(0.4545));\n  fragColor = vec4(col,1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/NsfXRf.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "Nsj3W3", "name": "Fork Cellular n emaduranda 377", "author": "emadurandal", "description": "Differentiation of [url=https://www.shadertoy.com/view/NdBGDG]cellular noise sample[/url]", "tags": ["bd202104"], "likes": 1, "viewed": 25, "date": "1618041732", "time_retrieved": "2024-06-20T20:38:12.005777", "image_code": "uvec3 k = uvec3(0x456789abu, 0x6789ab45u, 0x89ab4567u);\nconst uint max32 = 0xffffffffu;\nconst float PI = 3.14159265359;\nuvec2 hash22u(uvec2 n) {  \n    n ^= (n.yx << 24);\n    n ^= (n.yx >> 1);\n    n *= k.xy;\n    n ^= (n.yx << 1);\n    return n * k.xy;\n}\nuvec3 hash33u(uvec3 n) {\n    n ^= (n.yzx << 24);\n    n ^= (n.yzx >> 1);\n    n *= k;\n    n ^= (n.yzx << 1);\n    return n * k;\n}\nmat2 rot2(float t) {\n    return mat2(cos(t), sin(t), -sin(t),  cos(t));\n}\nfloat length2_2d(vec2 v){\n    return dot(v, v);\n}\nfloat length2_3d(vec3 v){\n    return dot(v, v);\n}\nvec2 hash22(vec2 p) {\n    uvec2 n = uvec2(p);\n    return vec2(hash22u(n)) / vec2(max32) - 0.5;\n}\nvec3 hash33(vec3 p) {\n    uvec3 n = uvec3(p);\n    return vec3(hash33u(n)) / vec3(max32) - 0.5;\n}\nvec4 sort(vec4 list, float v){\n    if (list.x >= v) {\n       return vec4(v, list.xyz);\n    } else if (list.y >= v) {\n       return vec4(list.x, v, list.yz);\n    } else if (list.z >= v) {\n       return vec4(list.xy, v, list.z);\n    } else if (list.w >= v) {\n       return vec4(list.xyz, v);\n    } else {\n       return list;\n    }\n}\nvec4 F4_2d(vec2 p){   \n    vec2 n = round(p);\n    vec2 f = p - round(p);\n    vec4 dist4 = vec4(length2_2d(1.5 - abs(f)));\n    vec2 sgn = vec2(1.0);\n    vec2 glid = vec2(0.0);\n    for(float j = 0.0; j <= 4.0; j ++ ) {\n        glid.y += sgn.y * j;\n        sgn.y *= -1.0;\n        if (abs(glid.y - f.y) - 0.5 > sqrt(dist4.w)){\n            continue;\n        }\n        for(float i = 0.0; i <= 4.0; i ++ ){\n            glid.x += sgn.x * i;\n            sgn.x *= -1.0;\n            vec2 nbd = glid + sin(iTime) * rot2(iTime) * hash22(n + glid) / sqrt(2.0);\n            float dist = length2_2d(nbd -f);\n            dist4 = sort(dist4, dist);\n        }\n        glid.x = 0.0;\n    }\n    return sqrt(dist4);\n}\nvec4 F4_3d(vec3 p){   \n    vec3 n = round(p);\n    vec3 f = p - round(p);\n    vec4 dist4 = vec4(length2_3d(1.5 - abs(f)));\n    vec3 sgn = vec3(1.0);\n    vec3 glid = vec3(0.0);\n    for(float k = 0.0; k <= 4.0; k ++ ) {\n            glid.z += sgn.z * k;\n            sgn.z *= -1.0;\n            if (abs(glid.z - f.z) - 0.5 > sqrt(dist4.w)){\n                continue;\n            }\n        for(float j = 0.0; j <= 4.0; j ++ ) {\n            glid.y += sgn.y * j;\n            sgn.y *= -1.0;\n            if (abs(glid.y - f.y) - 0.5 > sqrt(dist4.w)){\n                continue;\n            }\n            for(float i = 0.0; i <= 4.0; i ++ ){\n                glid.x += sgn.x * i;\n                sgn.x *= -1.0;\n                vec3 nbd = glid + sin(iTime) * hash33(n + glid);\n                float dist = length2_3d(nbd - f);\n                dist4 = sort(dist4, dist);\n            }\n            glid.x = 0.0;\n        }\n        glid.y = 0.0;\n    }\n    return sqrt(dist4);\n}\nfloat cnoise2(vec2 p, vec4 wt){\n    return abs(dot(F4_2d(p), wt));\n}\nfloat cnoise3(vec3 p, vec4 wt){\n    return dot(F4_3d(p), wt);\n}\nvec2 grad2(vec2 p, vec4 w) {\n    float d = 0.001;\n    return 0.5 * (vec2(\n            cnoise2(p + vec2(d, 0.0), w) - cnoise2(p - vec2(d, 0.0), w),\n            cnoise2(p + vec2(0.0, d), w) - cnoise2(p - vec2(0.0, d), w)\n        )) / d;\n}\nvec3 grad3(vec3 p, vec4 w) {\n    float d = 0.001;\n    return 0.5 * (vec3(\n            cnoise3(p + vec3(d, 0.0, 0.0), w) - cnoise3(p - vec3(d, 0.0, 0.0), w),\n            cnoise3(p + vec3(0.0, d, 0.0), w) - cnoise3(p - vec3(0.0, d, 0.0), w),\n            cnoise3(p + vec3(0.0, 0.0, d), w) - cnoise3(p - vec3(0.0, 0.0, d), w)\n        )) / d;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    vec2 pos = fragCoord.xy/ iResolution.xx;\n    pos *= 10.0;\n    pos += iTime;\n    // int ind = int(3.0 * fragCoord.x / iResolution.x);\n    // mat3x4 wt = mat3x4(\n    //     vec4(-1.0, 1.0, 0.0, 0.0),  //left\n    //     vec4(-.5, -1., 1., 0.0),  //center \n    //     vec4(-.25, -.5, -1.2, 1.0)  //right\n    // );\n    vec2 ray2 = vec2(1.0, 0.0);\n    vec3 ray3 = vec3(1.0, 0.0, 0.0);\n    vec4 wt;\n    if (fragCoord.x < 0.33 * iResolution.x){\n        wt = vec4(-1.0, 1.0, 0.0, 0.0);\n    } else if (fragCoord.x < 0.66 * iResolution.x) {\n        wt = vec4(-.5, -1., 1., 0.0);\n    } else {\n        wt = vec4(-.25, -.5, -1.2, 1.0);\n    }\n    \n    if(fragCoord.y < 0.5 * iResolution.y){\n       // fragColor = vec4(dot(grad2(pos, wt[ind]), ray2)) * vec4(0.9, 0.9, 0.7, 1.0);  \n       fragColor = vec4(dot(grad2(pos, wt), ray2)) * vec4(0.9, 0.9, 0.7, 1.0);  \n    } else {\n        // fragColor = vec4(dot(grad3(vec3(pos, 0.5 * iTime), wt[ind]), ray3)) * vec4(0.6, 0.8, 0.8, 1.0);\n        fragColor = vec4(dot(grad3(vec3(pos, 0.5 * iTime), wt), ray3)) * vec4(0.6, 0.8, 0.8, 1.0);\n    }\n    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/Nsj3W3.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "Nsj3Wt", "name": "Mandelbox Rotation", "author": "kithy", "description": "mandelbox,fractal,raymarching", "tags": ["raymarching", "fractal", "mandelbox"], "likes": 1, "viewed": 59, "date": "1618121839", "time_retrieved": "2024-06-20T20:38:12.005777", "image_code": "#define MAX_STEPS 64\n#define ITR 10\n#define EPS 0.001\n\n//回転行列\nmat2 Rot(float a){\n\tfloat s=sin(a);\n\tfloat c=cos(a);\n\treturn mat2(c,-s,s,c);\n}\n\n//座標の複製\nvec3 rep(vec3 p,vec3 c){\n\tvec3 q=mod(p+0.5*c,c)-0.5*c;\n\treturn q;\n}\n\n//回転折りたたみ\nfloat sphereFold(vec3 p){\n\tfloat r2=dot(p,p);\n\tfloat dz;\n\tif(r2<0.5){\n\t\tfloat temp=2.0;\n\t\tp*=temp;\n\t\tdz*=temp;\n\t}\n\telse if(r2<1.0){\n\t\tfloat temp=1.0/r2;\n\t\tp*=temp;\n\t\tdz*=temp;\n\t}\n\treturn dz;\n}\n//boxFold?\nvoid boxFold(inout vec3 p,inout float dz){\n\tp=clamp(p,-1.0,1.0)*2.0-p;\n}\n//マンデルボックス\nfloat mandelbox(vec3 p){\n\t//p=mod(p,8.0)-4.0;\n\tfloat scale=3.0;\n\tvec3 offset=p;\n\tfloat dr=1.0;\n\tfor(int i=0;i<ITR;i++){\n\t\tboxFold(p,dr);\n\t\tsphereFold(p);\n\t\tp=scale*p+offset;\n\t\tdr=dr*abs(scale);\n\t}\n\tfloat r=length(p);\n\treturn r/abs(dr);\n}\n//メインの距離関数\nfloat mainDist(vec3 p){\n\tp.xy*=Rot(iTime*0.5);\n\tp.zx*=Rot(iTime*0.5);\n\treturn mandelbox(p);\t\n}\n///法線を導出\nvec3 genNormal(vec3 p){\n\treturn normalize(vec3(\n\t\tmainDist(vec3(p.x+EPS,p.y,p.z))-mainDist(vec3(p.x-EPS,p.y,p.z)),\n\t\tmainDist(vec3(p.x,p.y+EPS,p.z))-mainDist(vec3(p.x,p.y+EPS,p.z)),\n\t\tmainDist(vec3(p.x,p.y,p.z+EPS))-mainDist(vec3(p.x-EPS,p.y,p.z-EPS))\n\t\t));\n}\n\n\n//レイマーチング\nfloat rayMarch(vec3 ro,vec3 rd){\n\tfloat dO=0.0;\n\tfor(int i=0;i<MAX_STEPS;i++){\n\t\tvec3 p=ro+rd*dO;\n\t\tfloat dS=mainDist(p);\n\t\tdO+=dS;\n\t\tif(dS<EPS)break;\n\t}\n\treturn dO;\n}\n\n\nvoid mainImage(out vec4 fragColor,in vec2 fragCoord){\n\tvec2 uv=(2.0*fragCoord.xy-iResolution.xy)/iResolution.y;\n\tvec3 ro=vec3(0.0,0.0,-6.0);\n\tvec3 rd=normalize(vec3(uv,1.0));\n\n\tfloat d=rayMarch(ro,rd);\n\tvec3 n;\n\tvec3 r;\n\n\tif(d<float(MAX_STEPS)){\n\t\tvec3 p=ro+rd*d;\n\t\tn=genNormal(p);\n\t\tr=reflect(rd,n);\n\t}\n\n\tfragColor=vec4(cross(n,r)*2.0+0.5,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/Nsj3Wt.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "NsjGDw", "name": "Colorful Infinity", "author": "wildniklin", "description": "marbles or something idk\n\nTraverse through an infinite world of spheres.", "tags": ["raymarch", "sdf", "sphere", "color"], "likes": 2, "viewed": 145, "date": "1617492689", "time_retrieved": "2024-06-20T20:38:12.005777", "image_code": "const int MAX_STEPS = 300;\nconst float MAX_DIST = 50.0;\nconst float MIN_DIST = 0.001;\nconst float PI = 3.1415;\n\nfloat rand1(vec3 p) {\n    return fract(sin(dot(p, vec3(12.9898, 78.233, 195.1533))) * 43758.5453123);\n}\n\nmat2 rot(float r) {\n    float s = sin(r), c = cos(r);\n    return mat2(c, -s, s, c);\n}\n\nfloat sdSphere(vec3 p, float r) {\n    return length(p) - r;\n}\n\nfloat map(vec3 p) {\n    return sdSphere(fract(p - 0.5) - 0.5, rand1(floor(p - 0.5)) * 0.25);\n}\n\nfloat march(vec3 ro, vec3 rd) {\n    float d = 0.0;\n    for(int i = 0; i < MAX_STEPS; i++) {\n        float ds = map(ro + (rd * d));\n        d += ds;\n        if(d > MAX_DIST) return MAX_DIST;\n        if(abs(ds) < MIN_DIST) break;\n    }\n    return d;\n}\n\nvec3 normal(vec3 p) {\n    vec2 e = vec2(MIN_DIST, 0.0);\n    return normalize(vec3(\n        map(p + e.xyy) - map(p - e.xyy),\n        map(p + e.yxy) - map(p - e.yxy),\n        map(p + e.yyx) - map(p - e.yyx)\n    ));\n}\n\nvec4 image(vec2 i, float t) {\n    vec2 uv = (i.xy - (0.5 * iResolution.xy)) / min(iResolution.x, iResolution.y);\n\n    t *= 0.9;\n    \n    float w_warpsin = pow(sin(t * 0.7) * 0.125 + 0.875, 4.0);\n    float w_esin = sin((t + 1.0) * PI * 0.25);\n    float w_sin = sin(t * PI * 0.25);\n    float w_cos = cos(t * PI * 0.25);\n\n    vec3 col = vec3(0.0, 0.0, 0.0);\n\n    vec3 ro = vec3(w_sin * 0.5, w_cos * 0.5, t * 10.0);\n    vec3 rd = normalize(vec3(uv, w_warpsin));\n\n    rd.yz *= rot(w_sin * PI * 0.0625);\n    rd.zx *= rot(w_cos * PI * 0.0625);\n    rd.xy *= rot(w_esin * PI * 0.0625);\n\n    float d = march(ro, rd);\n    vec3 p = ro + (rd * d);\n    vec3 n = normal(p);\n\n    col += 0.5 + 0.5 * sin(floor(p + 0.5) * PI * vec3(0.25, 0.25, 0.01));\n    \n    vec3 light = vec3(0.0);\n    \n    light += vec3(0.8, 0.5, 0.8) * clamp(dot(n, normalize(vec3(0.7, 1.0, -0.5))), 0.0, 1.0);\n    light += vec3(0.2, 0.2, 0.2);\n    \n    col *= light;\n    col = mix(col, vec3(0.0, 0.0, 0.0), smoothstep(0.0, MAX_DIST, d));\n\n    //col += dot(n, vec3(0.2, 0.7, -0.3)) * vec3(1.0, 1.0, 1.0);\n    //col *= smoothstep(0.0, 1.0, dot(-rd, n));\n    \n    col *= smoothstep(2.2, -0.5, length(uv));\n\n    return vec4(col, 1.0);\n}\n\nvoid mainImage(out vec4 o, vec2 i) {\n    vec4 result = vec4(0.0);\n\n    int frames = 5;\n    float duration = 0.05;\n    float frameUnit = (1.0 / float(frames)) * duration;\n\n    for(float offset = 0.0; offset < duration; offset += frameUnit) {\n        result += image(i, iTime + offset);\n    }\n    o = result / float(frames);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/NsjGDw.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "NsjGRG", "name": "Pride / Stepped Gradient Flag", "author": "worldofzero", "description": "This is an exploration of stepped gradients that turned into a Pride flag shader. Leans heavily on the step function.\n\nYou may customize this by changing the configured COLOR1-12 definitions.", "tags": ["flag"], "likes": 3, "viewed": 758, "date": "1617567960", "time_retrieved": "2024-06-20T20:38:12.484798", "image_code": "// Note this is a modification of a HLSL shader written for the Windows Terminal\n// You may swap out each of the 12 color bands to create a different flag.\n// Adjusting the two periods will change the waving effect.\n\n// Settings\n// Customize Colors (1 = TOP of screen, 12 is bottom)\n// to create a different flag. Some examples below (only uncomment one section)\n//\n// Pride:\n#define COLOR1 vec4(0.95,0.0,0.0,1.0)\n#define COLOR2 vec4(0.95,0.0,0.0,1.0)\n#define COLOR3 vec4(1.0,141.0/255.0,0.0,1.0)\n#define COLOR4 vec4(1.0,141.0/255.0,0.0,1.0)\n#define COLOR5 vec4(1.0,0.95,0.0,1.0)\n#define COLOR6 vec4(1.0,0.95,0.0,1.0)\n#define COLOR7 vec4(0.0,129.0/255.0,33.0/255.0,1.0)\n#define COLOR8 vec4(0.0,129.0/255.0,33.0/255.0,1.0)\n#define COLOR9 vec4(0.0,76.0/255.0,1.0,1.0)\n#define COLOR10 vec4(0.0,76.0/255.0,1.0,1.0)\n#define COLOR11 vec4(118.0/255.0, 1.0/255.0, 136.0/255.0, 1.0)\n#define COLOR12 vec4(118.0/255.0, 1.0/255.0, 136.0/255.0, 1.0)\n\n// Trans:\n// #define COLOR1 vec4(0.33,0.8,0.95,1.0)\n// #define COLOR2 vec4(0.33,0.8,0.95,1.0)\n// #define COLOR3 vec4(0.33,0.8,0.95,1.0)\n// #define COLOR4 vec4(0.97,0.6,0.675,1.0)\n// #define COLOR5 vec4(0.97,0.6,0.675,1.0)\n// #define COLOR6 vec4(1.0,1.0,1.0,1.0)\n// #define COLOR7 vec4(1.0,1.0,1.0,1.0)\n// #define COLOR8 vec4(0.97,0.6,0.675,1.0)\n// #define COLOR9 vec4(0.97,0.6,0.675,1.0)\n// #define COLOR10 vec4(0.33,0.8,0.95,1.0)\n// #define COLOR11 vec4(0.33,0.8,0.95,1.0)\n// #define COLOR12 vec4(0.33,0.8,0.95,1.0)\n\n// Flag Strength is the opacity of the flag (1.0 is completely opaque)\n#define FLAGSTRENGTH 1.0\n// Control the sin wave length and strength of the flag wave\n#define PERIOD1POSITION 10.0\n#define PERIOD2POSITION 0.5\n#define PERIOD1STRENGTH 0.05\n#define PERIOD2STRENGTH 0.2\n#define PERIOD1TIME 1.1\n#define PERIOD2TIME 1.0\n\nvec4 flagColor(float position) {\n    // Invert position for GLSL\n    position = 1.0 - position;\n\n    float step1 = 0.0;\n    float step2 = 0.08333;\n    float step3 = 0.1667;\n    float step4 = 0.25;\n    float step5 = 0.3333;\n    float step6 = 0.4167;\n    float step7 = 0.5;\n    float step8 = 0.5833;\n    float step9 = 0.6667;\n    float step10 = 0.75;\n    float step11 = 0.8333;\n    float step12 = 0.9167;\n    \n    vec4 result = COLOR1;\n    result = mix(result, COLOR2, step(step2, position));\n    result = mix(result, COLOR3, step(step3, position));\n    result = mix(result, COLOR4, step(step4, position));\n    result = mix(result, COLOR5, step(step5, position));\n    result = mix(result, COLOR6, step(step6, position));\n    result = mix(result, COLOR7, step(step7, position));\n    result = mix(result, COLOR8, step(step8, position));\n    result = mix(result, COLOR9, step(step9, position));\n    result = mix(result, COLOR10, step(step10, position));\n    result = mix(result, COLOR11, step(step11, position));\n    result = mix(result, COLOR12, step(step12, position));\n\n    return result;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float height = fragCoord.y;\n    height += sin(iTime * PERIOD1TIME + fragCoord.x / iResolution.x * PERIOD1POSITION ) / PERIOD1STRENGTH;\n    height += sin(iTime * PERIOD2TIME + fragCoord.x / iResolution.x * PERIOD2POSITION ) / PERIOD2STRENGTH;\n    fragColor = flagColor(height / iResolution.y) * FLAGSTRENGTH;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/NsjGRG.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "NsjGWD", "name": "codebreaker strips", "author": "alice", "description": "gonna just focus on making pretty things for a while, here's what i got from an evening of fiddling. code is a mess, don't look at it for examples.", "tags": ["2d"], "likes": 8, "viewed": 61, "date": "1617428783", "time_retrieved": "2024-06-20T20:38:12.902885", "image_code": "//Set this define for shadertoy\n#define shadertoy\n\n#ifndef shadertoy\n#define fragColor gl_FragColor\n#define fragCoord gl_FragCoord\n#define iResolution u_resolution\n#define iMouse u_mouse\n#define iTime u_time\n#endif\n#ifndef shadertoy\n#define fragColor gl_FragColor\n#define fragCoord gl_FragCoord\n#define iResolution u_resolution\n#define iMouse u_mouse\n#define iTime u_time\n#endif\n\n#define PI 3.1415926538\n\nuniform vec2 u_resolution;\nuniform vec2 u_mouse;\nuniform float u_time;\n\nconst int MAX_STEPS = 1000;\nconst float MIN_RAY_LEN = 0.;\nconst float MAX_RAY_LEN = 1000.;\nconst float RAY_HIT_THRESH = 0.01;\n\nconst uint k = 1103515245U;  // GLIB C\n\nvec3 uhash(uvec3 x) {\n    x = ((x>>8U)^x.yzx)*k;\n    x = ((x>>8U)^x.yzx)*k;\n    x = ((x>>8U)^x.yzx)*k;\n    return vec3(x)*(1.0/float(0xffffffffU));\n}\n\nvec3 hash(vec3 x) {\n    return uhash(uvec3(abs(x)));\n}\nvec3 tileColor(vec2 coord, float timestep) {\n    vec3 color = hash(vec3(coord, timestep));\n    color.g = pow(color.g, 2.2)*0.7+0.2;\n    color *= pow(hash(vec3(coord, timestep+9999999.)).x, .5);\n    color = pow(color, vec3(1.8))+0.2;\n    return clamp(pow(color, vec3(2.2)), 0., 1.).xyy;\n}\n\nfloat circle(vec2 posInTile) {\n    return smoothstep(0.49, 0.51, 2.*(0.7-distance(vec2(0.5), posInTile)));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    float f = 2.5;\n    float size = 35.;\n    float timestep = floor((iTime)*f);\n    fragCoord.x += iTime*100.;\n    float colOffset=(hash(vec3(floor(fragCoord.xxx/size))).x-0.5)*iTime*250.;\n    fragCoord.y += colOffset;\n    vec2 tile = floor(vec2(fragCoord.x, fragCoord.y)/size);\n    vec2 posInTile = fract(fragCoord/size);\n    float fadeT = fract(iTime*f);\n\n    float fadeLen = smoothstep(0.25, 0.75, hash(vec3(timestep, tile)).z);\n    float fadeOffset=(hash(vec3(timestep, tile)).x *2./-1.) * (1.-fadeLen)*0.5;\n    vec3 color = tileColor(tile, timestep);\n    vec3 prevColor = tileColor(tile, timestep-1.);\n    vec3 outColor = mix(prevColor, color, smoothstep(0.5-fadeLen/2., 0.5+fadeLen/2., clamp(fadeT+fadeOffset*0.5, 0., 1.)));\n    vec3 bgColor = tileColor(vec2(tile.x+999999., 0.), 0.)*0.2+0.04;\n    fragColor = vec4(mix(bgColor, outColor, circle(posInTile)), 1.);\n}\n\n#ifndef shadertoy\nvoid main() {\n    mainImage(fragColor, fragCoord.xy);\n}\n#endif\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/NsjGWD.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "NsjSzh", "name": "December InertiaRoyale MS", "author": "MonsieurSoleil", "description": "I don't really remember what I was doing at this moment :D", "tags": ["livecoding"], "likes": 1, "viewed": 68, "date": "1619644057", "time_retrieved": "2024-06-20T20:38:13.836240", "image_code": "/*\n    So, \n    I forgot to publish my shaders.\n    This was from inertiaRoyale Shader from January/December.\n\n\tI've learned shaders by watching Nusan's, leon, flopine, eviiiiil, iq, and other shadertoy coder's, code.\n\tThx to you, I'm learning in a way that suits me, art.\n*/\n\n#define time iTime\n#define mod01 floor(mod(time, 4.0))\n#define mod02 floor(mod(time, 4.0))\n#define mod03 floor(mod(time * 2.0, 4.0))\n#define mod04 floor(mod(time * 2.0, 8.0))\n\nstruct matter\n{\n  float m;\n  vec3 col;\n  int type;\n  float dist;\n  float glow;\n  bool reflected;\n  \n};\n\nmat2 rot(float a)\n{\n  float ca = cos(a);\n  float sa = sin(a);\n  \n  return mat2(ca, sa, -sa, ca);\n}\n\nfloat box(vec3 p, vec3 s)\n{\n    p = abs(p) - s;\n  return max(p.x, max(p.y, p.z));\n}\n\nvec2 repeat(vec2 p, float rep)\n{\n  return (fract(abs(p)/rep - 0.5) - 0.5) * rep;\n}\n\nvec2 id(vec2 p, float rep)\n{\n  return (floor(abs(p)/rep - 0.5) - 0.5) * rep;\n}\n\nfloat rnd(vec2 x)\n{\n    return fract(dot(sin(x * 352.1263 + x.yx * 5623.2365), vec2(451.2365)));\n}\n\nfloat rnd(float x)\n{\n    return fract(sin(x * 352.1263 + x * 5623.2365));\n}\n\nfloat curve(float x)\n{\n  return mix(rnd(x), rnd(x + 1.0), fract(time));\n}\n\nvoid map(inout matter mat, vec3 p)\n{\n  p.xy *= rot( p.z * (0.001 - sin(abs(time * 0.000025)) * 0.075) + (mod03 * 8.5) + time * 1.25) * 2.25;\n  \n  float repV = 0.25 + sin(abs(mod03 * 0.1)) * 2.0;\n  vec3 p01 = p, p02 = p, p03 = p, p04 = p;\n  \n  vec2 id0111 = id(p01.xz, repV * 22.0);\n  \n  vec2 id011 = id(p01.xz, repV * 4.0);\n  vec2 id01 = id(p01.xz, repV);\n  p01.xz = repeat(p01.xz, repV);\n  \n  float rnd01 = rnd(id01 * 32.0);\n  float rnd011 = rnd(id011 * 32.0);\n  float rnd0111 = rnd(id0111 * 132.0);\n  \n  vec2 id02 = id(p02.yz, repV);\n  p02.yz = repeat(p02.yz, repV);\n  \n  float rnd02 = rnd(id02 * 32.0);\n  \n  vec2 id031 = id(p03.yz, repV * 8.0);\n  vec2 id03 = id(p03.yz, repV);\n  p03.yz = repeat(p03.yz, repV);\n  \n  float rnd03 = rnd(id03 * 32.0);\n  float rnd031 = rnd(id031 * 32.0);\n  \n  vec2 id041 = id(p04.xz, repV * 6.0);\n  p04.xz = repeat(p04.xz, repV);\n  float rnd041 = rnd(id041 * 32.0);\n  \n  float scaleV = 0.4 * sin(abs(time * 1.5)) + 0.75;\n  \n    float mat01 = box(p01 + vec3(0.0,26.0 + 4.0 * sin(p.z * 0.1 + time) + rnd0111 * 4.0, 0.0), vec3(scaleV) + vec3(0.8 * rnd01 + 0.575 * mod01 * rnd01) - vec3(0.0, rnd011 * 8.55 * sin(time * 2.0), 0.0) - vec3(0.0, 2.0 * rnd0111, 0.0)) ;\n  \n  float mat02 = box(p02 + vec3(55.0 - fract(time * 0.45) * 32.0, 0.0 , 0.0), vec3(scaleV) * 0.8 * rnd02 * (mod02 + 0.25) - vec3(rnd031 * sin(abs(time * 4.0)) * 7.0));\n  \n  float mat03 = box(p03 + vec3(-45.0 - fract(time * 0.05 + mod03) * 38.0, 0.0, 0.0), vec3(scaleV * 0.8 * rnd03 * (mod02 + 0.25)));\n  \n  float mat04 = box(p04 + vec3(0.0, -45.0  + 2.0 * sin(p.z * 0.25 + time + (mod03)) , 0.0), vec3(0.1) + vec3(0.1 + 0.275 - sin(time * rnd041)));\n  \n  mat.m = min(mat01, mat02);\n  mat.m = min(mat.m, mat03);\n  mat.m = min(mat.m, mat04);\n  \n  mat.glow += 0.15/(0.05+abs(mat.m));\n}\nvec3 normals(vec3 p)\n{\n    vec2 uv = vec2(0.01, 0.0);\n  \n  matter m01, m02, m03, m04;\n  \n  map(m01, p);\n   map(m02, p - uv.xyy);\n   map(m03, p - uv.yxy);\n   map(m04, p - uv.yyx);\n  \n  return normalize(m01.m - vec3(m02.m, m03.m, m04.m));\n  \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2 uv = vec2(fragCoord/iResolution.xy);\n  uv -= 0.5;\n  uv /= vec2(iResolution.y / iResolution.x, 1);\n\n  vec3 o = vec3(0.0, 5.0, 5.0 + time * 85.0 + mod01 * 5.0), t = vec3(00., 1.5 * sin(time * 0.5) + 4.0, time * 85.0 + mod01 * 5.0 );\n  vec3 fr = normalize(t-o);\n  vec3 ri = normalize(cross(vec3(0.0, 1.0, 0.0), fr));\n  vec3 up = normalize(cross(fr, ri));\n  vec3 dir = normalize(fr + ri * uv.x + up * uv.y);\n  vec3 p = o + dir * 0.25;\n  \n  \n  matter mat;\n for(int i = 0; i < 100; ++i)\n  {\n    map(mat, p);\n    \n    if(mat.m < 0.01)\n    {\n      mat.m = 0.15;\n      mat.glow *= 0.95;\n      mat.dist -= 0.1 * mat.dist;\n      if(!mat.reflected)\n      {\n        vec3 n= normals(p);\n        dir = reflect(-n, dir);\n        mat.m = 2.5;\n        mat.reflected = true;\n        mat.glow *= 5.95;\n      }\n      \n    }\n    \n    \n    vec3 selCol = vec3(1.0, 1.0, 1.0) * 1.0;\n    if(mod01 > 1.0)\n    {\n      selCol = vec3(0.0, 0.5, 1.0);\n    }\n    if(mod01 > 2.0)\n    {\n      selCol = vec3(0.0, 0.5, 1.0);\n    }\n    \n    mat.col += mat.glow * (0.00010 - (sin(abs(p.z * 0.001 + time * 2.25)) * 0.000155)) * selCol * 0.2325;\n    p+= mat.m * dir * 0.5;\n    mat.dist += 0.5;\n    \n  }\n  \n  mat.col += pow(clamp((mat.dist/100.0), 0.0, 1.0), 1.2) * mix(vec3(0.0, 0.5, 1.0), vec3(1.0, 0.0, 0.0), sin(abs(time * 0.1 + (mat.dist/100.0 * 2.5)))) * ((0.8 * mod04)/8.0);\n  \n  mat.col = pow(mat.col, vec3(1.0/2.2));\n  \n  fragColor = vec4(mat.col, 1.0);\n}", "image_inputs": [{"id": "4dXGzn", "previewfilepath": "/media/ap/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/NsjSzh.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "NsjXz1", "name": "Shera---She-Ra", "author": "jorge2017a1", "description": "Shera---She-Ra", "tags": ["sherashera"], "likes": 3, "viewed": 196, "date": "1619663735", "time_retrieved": "2024-06-20T20:38:13.842319", "image_code": "//por jorge2017a1 ----jorgeFloresP---28/abril/2021\n// referencia\n//https://www.shadertoy.com/view/tlGBW3\n#define antialiasing(n) n/min(iResolution.y,iResolution.x)\n#define S(d,b) smoothstep(antialiasing(1.0),b,d)\n\nfloat sdCircle( vec2 p, float r )\n{ return length(p) - r; }\n\n////-------------------\n//https://www.shadertoy.com/view/tlGBW3\n//Created by manu210404 in 2021-03-13\n#define POLY(N) (in vec2 p, in vec2[N] v) {const int n=v.length();float d=dot(p-v[0],p-v[0]);float s=1.;for(int i=0,j=n-1;i<n;j=i,i++){vec2 e=v[j]-v[i];vec2 w=p-v[i];vec2 b=w-e*clamp(dot(w,e)/dot(e,e),0.,1.);d=min(d,dot(b,b));bvec3 cond=bvec3(p.y>=v[i].y,p.y<v[j].y,e.x*w.y>e.y*w.x);if(all(cond)||all(not(cond))) s=-s;}return s*sqrt(d);}\n\nfloat sdPoly10 POLY(10)\nvec2 pt10[ 10]=vec2[](  \nvec2(.73,.26),vec2(.68,.28),vec2(.60,.29),vec2(.54,.27),vec2(.52,.25),\nvec2(.53,.21),vec2(.54,.20),vec2(.55,.16),vec2(.68,.18),vec2(.73,.26) );\n\nfloat sdPoly27 POLY(27)\nvec2 pt27[ 27]=vec2[](  \nvec2(.20,.83),vec2(.19,.75),vec2(.21,.69),vec2(.24,.62),vec2(.28,.54),\nvec2(.30,.50),vec2(.27,.45),vec2(.22,.39),vec2(.19,.35),vec2(.17,.29),\nvec2(.20,.25),vec2(.26,.22),vec2(.30,.20),vec2(.31,.21),vec2(.26,.22),\nvec2(.21,.26),vec2(.18,.30),vec2(.19,.36),vec2(.23,.40),vec2(.28,.46),\nvec2(.30,.51),vec2(.29,.54),vec2(.25,.62),vec2(.21,.69),vec2(.19,.76),\nvec2(.21,.84),vec2(.20,.83) );\n\nfloat sdPoly7 POLY(7)\nvec2 pt7[ 7]=vec2[](  \nvec2(.44,.60),vec2(.63,.45),vec2(.63,.42),vec2(.64,.42),vec2(.63,.45),\nvec2(.45,.60),vec2(.44,.60) );\n\nfloat sdPoly24 POLY(24)\nvec2 pt24[ 24]=vec2[](  \nvec2(.45,.60),vec2(.53,.53),vec2(.40,.47),vec2(.37,.45),vec2(.35,.41),\nvec2(.30,.13),vec2(.19,.06),vec2(.27,.07),vec2(.29,.09),vec2(.31,.10),\nvec2(.33,.10),vec2(.35,.09),vec2(.67,.17),vec2(.71,.24),vec2(.76,.37),\nvec2(.72,.38),vec2(.69,.40),vec2(.69,.43),vec2(.70,.47),vec2(.71,.51),\nvec2(.70,.54),vec2(.67,.62),vec2(.64,.66),vec2(.45,.60) );\n\nfloat sdPoly35 POLY(35)\nvec2 pt35[ 35]=vec2[](  \nvec2(.46,1.00),vec2(.41,.99),vec2(.38,.98),vec2(.34,.95),vec2(.30,.90),\nvec2(.28,.88),vec2(.28,.85),vec2(.27,.83),vec2(.27,.82),vec2(.25,.80),\nvec2(.24,.79),vec2(.24,.76),vec2(.25,.73),vec2(.27,.70),vec2(.28,.66),\nvec2(.29,.63),vec2(.29,.62),vec2(.31,.61),vec2(.34,.61),vec2(.39,.60),\nvec2(.45,.61),vec2(.56,.63),vec2(.62,.66),vec2(.64,.67),vec2(.64,.69),\nvec2(.64,.73),vec2(.63,.74),vec2(.65,.80),vec2(.67,.81),vec2(.68,.84),\nvec2(.66,.89),vec2(.59,.91),vec2(.49,.96),vec2(.47,.98),vec2(.46,1.00) );\n\nfloat sdPoly28 POLY(28)\nvec2 pt28[ 28]=vec2[](  \nvec2(.41,.60),vec2(.42,.55),vec2(.45,.51),vec2(.45,.45),vec2(.42,.40),\nvec2(.41,.35),vec2(.43,.32),vec2(.47,.31),vec2(.53,.33),vec2(.55,.35),\nvec2(.56,.39),vec2(.53,.41),vec2(.49,.41),vec2(.51,.39),vec2(.51,.36),\nvec2(.50,.35),vec2(.46,.35),vec2(.43,.36),vec2(.43,.39),vec2(.45,.40),\nvec2(.48,.42),vec2(.52,.43),vec2(.56,.45),vec2(.59,.48),vec2(.56,.51),\nvec2(.50,.56),vec2(.45,.60),vec2(.41,.60) );\n\nfloat sdPoly21 POLY(21)\nvec2 pt21[ 21]=vec2[](  \nvec2(.46,1.00),vec2(.39,1.00),vec2(.36,.98),vec2(.30,.91),vec2(.25,.88),\nvec2(.18,.81),vec2(.16,.73),vec2(.20,.64),vec2(.24,.55),vec2(.24,.50),\nvec2(.14,.42),vec2(.08,.35),vec2(.11,.28),vec2(.19,.21),vec2(.30,.19),\nvec2(.33,.29),vec2(.34,.38),vec2(.36,.44),vec2(.45,.50),vec2(.54,.52),\nvec2(.46,1.00) );\n\nfloat sdPoly44 POLY(44)\nvec2 pt44[ 44]=vec2[](  \nvec2(.46,1.00),vec2(.48,.98),vec2(.53,.94),vec2(.66,.89),vec2(.67,.86),\nvec2(.66,.82),vec2(.63,.75),vec2(.64,.67),vec2(.67,.61),vec2(.70,.53),\nvec2(.69,.44),vec2(.69,.41),vec2(.72,.39),vec2(.78,.37),vec2(.85,.37),\nvec2(.89,.35),vec2(.90,.31),vec2(.89,.29),vec2(.84,.28),vec2(.79,.29),\nvec2(.78,.31),vec2(.80,.32),vec2(.79,.32),vec2(.76,.31),vec2(.74,.29),\nvec2(.76,.27),vec2(.78,.26),vec2(.83,.26),vec2(.88,.27),vec2(.94,.30),\nvec2(.98,.34),vec2(.97,.38),vec2(.96,.42),vec2(.95,.46),vec2(.98,.51),\nvec2(.99,.53),vec2(.99,.78),vec2(.96,.80),vec2(.94,.84),vec2(.93,.89),\nvec2(.92,.95),vec2(.88,.98),vec2(.74,1.00),vec2(.46,1.00) );\n\n\nfloat sdPoly18 POLY(18)\nvec2 pt18[ 18]=vec2[](  \nvec2(.33,.09),vec2(.48,.13),vec2(.63,.16),vec2(.69,.18),vec2(.70,.20),\nvec2(.81,.52),vec2(.84,.55),vec2(.87,.56),vec2(.94,.56),vec2(.98,.56),\nvec2(1.00,.22),vec2(.89,.06),vec2(.79,.02),vec2(.70,.01),vec2(.33,.01),\nvec2(.32,.03),vec2(.32,.06),vec2(.33,.09) );\n\nfloat sdPoly16 POLY(16)\nvec2 pt16[ 16]=vec2[](  \nvec2(.30,.70),vec2(.28,.71),vec2(.29,.73),vec2(.32,.73),vec2(.34,.73),\nvec2(.36,.73),vec2(.37,.73),vec2(.40,.71),vec2(.43,.69),vec2(.43,.69),\nvec2(.39,.69),vec2(.37,.70),vec2(.33,.71),vec2(.32,.70),vec2(.31,.70),\nvec2(.30,.70) );\n\nfloat sdPoly14 POLY(14)\nvec2 pt14[ 14]=vec2[](  \nvec2(.30,.70),vec2(.31,.70),vec2(.31,.70),vec2(.37,.69),vec2(.37,.70),\nvec2(.41,.69),vec2(.40,.68),vec2(.38,.67),vec2(.32,.67),vec2(.30,.68),\nvec2(.30,.68),vec2(.29,.69),vec2(.29,.70),vec2(.30,.70) );\n\nfloat sdPoly17a POLY(17)\nvec2 pt17a[ 17]=vec2[](  \nvec2(.33,.96),vec2(.29,.90),vec2(.29,.90),vec2(.34,.90),vec2(.41,.90),\nvec2(.53,.89),vec2(.64,.86),vec2(.69,.85),vec2(.70,.85),vec2(.71,.88),\nvec2(.74,.90),vec2(.76,.90),vec2(.70,.93),vec2(.59,.95),vec2(.45,.97),\nvec2(.38,.97),vec2(.33,.96) );\n\nfloat sdPoly17b POLY(17)\nvec2 pt17b[ 17]=vec2[](  \nvec2(.76,.91),vec2(.73,.89),vec2(.70,.87),vec2(.71,.84),vec2(.73,.81),\nvec2(.76,.81),vec2(.81,.83),vec2(.81,.85),vec2(.82,.87),vec2(.87,.90),\nvec2(.95,.92),vec2(.98,.94),vec2(.99,.99),vec2(.94,.96),vec2(.84,.93),\nvec2(.78,.92),vec2(.76,.91) );\n\nfloat sdPoly9 POLY(9)\nvec2 pt9[ 9]=vec2[](  \nvec2(.83,.88),vec2(.87,.87),vec2(.93,.88),vec2(.98,.89),vec2(.98,.94),\nvec2(.94,.93),vec2(.91,.92),vec2(.83,.88),vec2(.83,.88) );\n\nfloat sdPoly21b POLY(21)\nvec2 pt21b[ 21]=vec2[](  \nvec2(.83,.88),vec2(.87,.87),vec2(.93,.88),vec2(.98,.89),vec2(.98,.94),\nvec2(.94,.93),vec2(.91,.92),vec2(.83,.88),vec2(.83,.88),vec2(.82,.85),\nvec2(.82,.83),vec2(.83,.82),vec2(.88,.82),vec2(.95,.83),vec2(.99,.85),\nvec2(.98,.88),vec2(.95,.88),vec2(.90,.87),vec2(.85,.88),vec2(.83,.88),\nvec2(.83,.88) );\n\nfloat sdPoly17c POLY(17)\nvec2 pt17c[ 17]=vec2[](  \nvec2(.80,.83),vec2(.79,.82),vec2(.77,.81),vec2(.77,.81),vec2(.79,.79),\nvec2(.83,.78),vec2(.89,.78),vec2(.93,.80),vec2(.96,.81),vec2(.98,.83),\nvec2(.97,.84),vec2(.92,.82),vec2(.85,.82),vec2(.82,.83),vec2(.82,.84),\nvec2(.79,.82),vec2(.80,.83) );\n\n\nfloat sdPoly19 POLY(19)\nvec2 pt19[ 19]=vec2[](  \nvec2(.43,.90),vec2(.44,.88),vec2(.47,.88),vec2(.50,.88),vec2(.53,.87),\nvec2(.56,.87),vec2(.57,.86),vec2(.58,.84),vec2(.59,.84),vec2(.59,.84),\nvec2(.58,.84),vec2(.57,.86),vec2(.56,.86),vec2(.53,.87),vec2(.50,.87),\nvec2(.47,.88),vec2(.44,.88),vec2(.43,.89),vec2(.43,.90) );\n\nfloat sdPoly5 POLY(5)\nvec2 pt5[ 5]=vec2[](  \nvec2(.34,.89),vec2(.28,.88),vec2(.28,.87),vec2(.34,.89),vec2(.34,.89) );\n\nvec3 ponerBorde(vec3 pColObj, vec3 colOut, float distObj )\n{\n  colOut = mix(colOut,pColObj ,S( distObj,0.0));\n  colOut = mix(colOut,vec3(0.0) ,S(abs( distObj),0.0));\n  return colOut;\n}\n\nfloat sdPoly7b POLY(7)\nvec2 pt7b[ 7]=vec2[](  \nvec2(.34,.86),vec2(.30,.85),vec2(.26,.85),vec2(.26,.84),vec2(.30,.85),\nvec2(.34,.85),vec2(.34,.86) );\n\nfloat sdPoly19b POLY(19)\nvec2 pt19b[ 19]=vec2[](  \nvec2(.43,.85),vec2(.46,.84),vec2(.47,.84),vec2(.50,.84),vec2(.52,.84),\nvec2(.54,.83),vec2(.56,.81),vec2(.56,.81),vec2(.60,.80),vec2(.60,.80),\nvec2(.56,.80),vec2(.56,.81),vec2(.54,.82),vec2(.52,.83),vec2(.50,.84),\nvec2(.47,.84),vec2(.46,.84),vec2(.43,.85),vec2(.43,.85) );\n\nfloat sdPoly8 POLY(8)\nvec2 pt8[ 8]=vec2[](  \nvec2(.34,.85),vec2(.29,.84),vec2(.29,.83),vec2(.30,.82),vec2(.33,.81),\nvec2(.34,.82),vec2(.34,.84),vec2(.34,.85) );\n\nfloat sdPoly12 POLY(12)\nvec2 pt12[ 12]=vec2[](  \nvec2(.46,.83),vec2(.44,.81),vec2(.46,.80),vec2(.49,.80),vec2(.53,.80),\nvec2(.56,.80),vec2(.54,.81),vec2(.53,.83),vec2(.50,.84),vec2(.47,.83),\nvec2(.45,.82),vec2(.46,.83) );\n\nfloat sdPoly19c POLY(19)\nvec2 pt19c[ 19]=vec2[](  \nvec2(.33,.87),vec2(.34,.85),vec2(.34,.83),vec2(.33,.81),vec2(.31,.79),\nvec2(.29,.78),vec2(.29,.77),vec2(.31,.76),vec2(.34,.76),vec2(.35,.76),\nvec2(.31,.76),vec2(.29,.77),vec2(.30,.79),vec2(.31,.80),vec2(.33,.82),\nvec2(.35,.83),vec2(.35,.85),vec2(.34,.87),vec2(.33,.87) );\n\nfloat sdPoly5b POLY(5)\nvec2 pt5b[ 5]=vec2[](  \nvec2(.65,.77),vec2(.59,.75),vec2(.59,.74),vec2(.65,.77),vec2(.65,.77) );\n\nfloat sdPoly15 POLY(15)\nvec2 pt15[ 15]=vec2[](  \nvec2(.78,.77),vec2(.81,.71),vec2(.85,.64),vec2(.83,.58),vec2(.78,.53),\nvec2(.73,.49),vec2(.71,.47),vec2(.72,.47),vec2(.74,.49),vec2(.79,.53),\nvec2(.83,.58),vec2(.86,.64),vec2(.82,.71),vec2(.79,.77),vec2(.78,.77) );\n\n\n\nvec3 Rostroshera(in vec2 pp, vec3 col) \n{\n  vec2 p=pp;\n  \n  \n  float sd1 = sdPoly7(p, pt7); //\n  float sd2 = sdPoly24(p, pt24); //\n  float sd3 = sdPoly35(p, pt35); //\n  float sd4 = sdPoly28(p, pt28); //\n  float sd5 = sdPoly21(p, pt21); //\n  float sd6 = sdPoly44(p, pt44); //\n  float sd7 = sdPoly18(p, pt18); //\n  float sd8 = sdPoly16(p, pt16); //\n  float sd9 = sdPoly14(p, pt14); //\n  float sd10 = sdPoly10(p, pt10); //\n  float sd11 = sdPoly27(p, pt27); //\n  float sd12 = sdPoly17a(p, pt17a); //\n  float sd13 = sdPoly17b(p, pt17b); //\n  float sd14 = sdPoly9(p, pt9); //\n  float sd15 = sdPoly21b(p, pt21b); //\n  float sd16 = sdPoly17c(p, pt17c); //\n  float sd17 = sdPoly19(p, pt19); //\n  float sd18 = sdPoly5(p, pt5); //\n  float sd19 = sdPoly7b(p, pt7b); \n  float sd20 = sdPoly19b(p, pt19b); \n  float sd21 = sdPoly8(p, pt8); \n  float sd22 = sdPoly12(p, pt12); \n  float movx=0.015*sin(iTime);\n  float sd23= sdCircle( p-vec2(0.49+movx,0.82), 0.019 ); //der\n  float sd24= sdCircle( p-vec2(0.31+movx,0.835), 0.017 );//izq\n  float sd25 = sdPoly19c(p, pt19c); \n  float sd26 = sdPoly5b(p, pt5b); \n  float sd27 =sdPoly15(p, pt15); \n  \n  \n  vec3 colPiel=vec3(1.00,0.68,0.79);\n  vec3 colPiel2=vec3(0.96,0.65,0.04);\n  vec3 colPelo=vec3(1.0, 0.8,0.2);\n  col = mix(col,colPelo,S(sd5,0.0));  // pelo 2   interior\n  col = mix(col,vec3(1.0, 0.6,0.5),S(sd1,0.0));\n  \n  col= ponerBorde(colPiel,col,sd7);//brazo der\n  col= ponerBorde(colPiel,col,sd2);//cuerpo\n  col= ponerBorde(colPiel,col,sd3);//borde rostro\n  col= ponerBorde(colPelo,col,sd4);//pelo izq. adelante\n  col= ponerBorde(colPelo,col,sd6);//pelo der. adelante\n  col = mix(col,vec3(0.64,0.01,0.00),S(sd8,0.0));  //labio superior\n  col = mix(col,vec3(0.64,0.01,0.00),S(sd9,0.0));  //labio inferior\n  col = mix(col,vec3(0.81,0.18,0.00),S(sd10,0.0));  //busto\n  col = mix(col,vec3(0.0),S(sd11,0.0));  // ondulado negro\n  col= ponerBorde(vec3(0.86,0.19,0.00),col,sd12);\n  col= ponerBorde(vec3(0.86,0.19,0.00),col,sd13);\n  col= ponerBorde(vec3(0.86,0.19,0.00),col,sd14);\n  col= ponerBorde(vec3(0.86,0.19,0.00),col,sd15);\n  col= ponerBorde(vec3(0.86,0.19,0.00),col,sd16); //alas\n  col = mix(col,vec3(0.0) ,S( sd17,0.0)); //pestaña der\n  col = mix(col,vec3(0.0) ,S( sd18,0.0)); //pestaña izq\n  col = mix(col,vec3(0.0) ,S( sd19,0.0)); //sommbra ojo izq\n  col = mix(col,vec3(0.0) ,S( sd20,0.0));  //sombra ojo der\n  col = mix(col,vec3(1.0) ,S( sd21,0.0));  //pupila izq\n  col = mix(col,vec3(1.0) ,S( sd22,0.0));  //pupila der\n  col = mix(col,vec3(0.0) ,S( sd23,0.0));   //cornea izq\n  col = mix(col,vec3(0.0) ,S( sd24,0.0));  //cornea der\n  col = mix(col,vec3(0.0) ,S( sd25,0.0));  //nariz\n  col = mix(col,vec3(0.0) ,S( sd26,0.0));\n  col = mix(col,vec3(0.0) ,S( sd27,0.0));\n  \n  \n  return col;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{   vec2 uv = (fragCoord-iResolution.xy)/iResolution.y;\n    //posicion\n    vec2 p=uv+vec2(1.5,0.9);\n    p*=1.7;\n    p.x*=0.96;\n    p.y*=0.6; p.y+=0.1;\n    vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n    col=vec3((col.x+col.y+col.z)/3.0)*vec3(0.2,0.2,1.0);\n     col= Rostroshera( p,col*2.0);\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/NsjXz1.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "NslSD7", "name": "KaliFractalBall", "author": "bignobody", "description": "Just having more fun with a previous shader.", "tags": ["fractal", "raymarch"], "likes": 3, "viewed": 40, "date": "1618707395", "time_retrieved": "2024-06-20T20:38:14.624171", "image_code": "#define MAX_STEPS 255\n#define MAX_DIST 100.\n#define SURF_DIST .001\n\n// Remix of my previous shader: https://www.shadertoy.com/view/tsSyzW\n\n\nmat2 rotate2(float a) \n{\n    float s = sin(a);\n    float c = cos(a);\n    return mat2(c, -s, s, c);\n}\n\n\n// Found the original de function here: https://www.reddit.com/r/fractals/comments/5kzv7w/raymarching_a_3d_clamped_kaliset_fractal/\nfloat de(vec3 p, int it, float m, float n, float s, float c) \n{\n    vec4 q = vec4(p - 1.0, 1);\n    for(int i = 0; i < it; i++) {\n        q.xyz = abs(q.xyz + 1.0) - 1.0;\n        q /= clamp(dot(q.xyz, q.xyz), m, n);\n        q *= s; //1.15;\n    }\n    return (length(q.zy) - c)/q.w;\n}\n\n// made two variations\nfloat ee(vec3 p, int it, float m, float n, float s, float c) \n{\n    vec4 q = vec4(p - 1.0, 1);\n    for(int i = 0; i < it; i++) {\n        q.xyz = abs(q.zxy + 1.0) - 1.0;\n        q /= clamp(dot(q.zxy, q.zxy), m, n);\n        q *= s;\n    }\n    return (length(q.zy) - c)/q.w;\n}\n\nfloat fe(vec3 p, int it, float m, float n, float s, float c) \n{\n    vec4 q = vec4(p - 1.0, 1);\n    for(int i = 0; i < it; i++) {\n        q.xyz = abs(q.yzx + 1.0) - 1.0;\n        q /= clamp(dot(q.yzx, q.yzx), m, n);\n        q *= s;\n    }\n    return (length(q.zx) - c)/q.w;\n}\n\n\n// blend of all 3 fractals\nfloat sceneDistance(vec3 p)\n{\n    \n    return max(de(p,19, 0.005, 1.0, 1.05, abs(sin(iTime))+0.2), ee(p,19, 0.005, 1.0, 1.05, abs(sin(iTime))+0.2) );\n    \n  \n}\n\nfloat n21(vec2 p)\n{\n    \n    p = fract(p * vec2(3433.321,12.123));\n    p += (dot(p,p*442.1));\n    return (fract(p.x*p.y));\n}\n\nfloat rayMarch(vec3 rayOrigin, vec3 rayDirection) \n{\n\tfloat dist=0.;\n    \n    for(int i=0; i<MAX_STEPS; i++) \n    {\n    \tvec3 p = rayOrigin + rayDirection*dist;\n        float d = sceneDistance(p);\n        dist += d;\n        if(dist>MAX_DIST || abs(d)<SURF_DIST) break;\n    }\n    \n    return dist;\n}\n\nvec3 getNormal(vec3 p) \n{\n\tfloat d = sceneDistance(p);\n    vec2 e = vec2(.001, 0);\n    \n    vec3 n = d - vec3(\n        sceneDistance(p-e.xyy),\n        sceneDistance(p-e.yxy),\n        sceneDistance(p-e.yyx));\n    \n    return normalize(n);\n}\n\n\nvec3 rayCast(vec2 uv, vec3 pos, vec3 lookAt, float zoom) \n{\n    vec3 forward = normalize(lookAt-pos),\n    ray = normalize(cross(vec3(0,1,0), forward)),\n    up = cross(forward,ray),\n    center = pos+forward*zoom,\n    intersect = center + uv.x*ray + uv.y*up,\n    r = normalize(intersect-pos);\n    return r;\n}\n\nvec3 recolourNormal(vec3 n)\n{\n    return vec3(sin(n.x*n.y) * 0.18, sin(n.y*n.z) * 0.08, sin(n.z) * 0.18);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy)/iResolution.y;\n\tvec2 mouse = iMouse.xy/iResolution.xy;\n    \n    vec3 col = vec3(0.0);\n    float ambientLight = 0.7;\n\tfloat t = (iTime+0.1) * 0.04;\n \tvec3 rayOrigin = vec3(0.0, (2.2+sin(t))*cos(t), (2.2+sin(t)) * sin(t));\n    rayOrigin.yz *= rotate2(mouse.y*3.14+1.);\n    rayOrigin.xz *= rotate2(-mouse.x*6.2831);\n\n    vec3 rayDirection = rayCast(uv, rayOrigin, vec3(0,0.1,0), 0.66);\n\n    float dist = rayMarch(rayOrigin, rayDirection);\n    \n  \n\tif(dist<MAX_DIST) \n    {\n    \tvec3 p = rayOrigin + rayDirection * dist;\n    \tfloat at = smoothstep(dist, 1.0, 0.008);\n    \tvec3 dif = (recolourNormal(getNormal(p))*at);\n        dif += n21(p.xy) * (0.015 * at);\n    \tcol = dif;\n    }\n    else\n    {\n     \tcol = vec3(0.0002,0.0003,0.0006);   \n    }\n    \n\tcol = pow(col * ambientLight,vec3(0.3535));\n\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/NslSD7.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "NslSDH", "name": "Reflectivity Testing", "author": "Drakyen", "description": "Reasonably happy with this reflection setup.", "tags": ["3d", "reflection"], "likes": 1, "viewed": 47, "date": "1618586862", "time_retrieved": "2024-06-20T20:38:14.630251", "image_code": "#define RSTPS 256\n#define MDST 64.\n#define SDST 0.01\n#define BNCS 2\n\n#define NMAT mat(1.,0.,vec3(0.569,0.714,0.831))\n#define FMAT mat(1.,0.2,vec3(0.341,1.000,0.592))\n#define SMAT mat(1.,0.2,vec3(0.953,0.086,0.086))\n#define TMAT mat(1.,0.2,vec3(0.459,0.471,1.000))\n#define PMAT mat(1., 1.,vec3(1,1,1))\n\n#define rot(a) mat2(cos(a), -sin(a), sin(a),cos(a))\n\nstruct mat\n{\n    float diff;\n    float spec;\n    vec3 col;\n};\n\n\nstruct obj\n{\n    float sdf;\n    mat mat;\n};\n\nstruct hit\n{\n    float rdf;\n    vec3 pos;\n    mat mat;\n};\n\nobj objmin(obj a, obj b)\n{\n    if(a.sdf < b.sdf){return a;} else {return b;}\n}\n\nfloat ssdf(vec3 p, vec4 s)\n{\n    \n    p = p - s.xyz;\n    p.xy *= rot(iTime + s.w);\n    p.xz *= rot(iTime - s.w);\n    p = abs(p) - vec3(s.w);\n    return max(p.x, max(p.y, p.z));\n}\n\nobj scene(vec3 p)\n{ \n   vec4 spr1 = vec4(sin(iTime) * 2.,-1,30,3);\n   vec4 spr2 = vec4(sin(-iTime) * 2.,-4,20,2);\n   vec4 spr3 = vec4(cos(iTime) + 10.,2,30,5);\n   vec4 spr4 = vec4(sin(iTime) * 2. -8.,-2,25,4);\n   vec4 spr5 = vec4(sin(iTime) * 5. + 2.,1,18,1.5);\n  \n   \n   float pld = p.y + 6.;\n    \n    \n   obj sob1 = obj(ssdf(p, spr1), TMAT);\n   obj sob2 = obj(ssdf(p, spr2), SMAT);\n   obj sob3 = obj(ssdf(p, spr3), SMAT);\n   obj sob4 = obj(ssdf(p, spr4), TMAT);\n   obj sob5 = obj(ssdf(p, spr5), PMAT);\n   \n   obj pob = obj(pld, FMAT);\n   \n   return objmin(sob1, objmin(sob2, objmin(sob3, objmin(sob4, objmin(sob5, pob)))));\n}\n\nvec3 normal(vec3 p)\n{\n    vec2 e = vec2(0.01, 0);\n    float d = scene(p).sdf;\n    vec3 norm = d - vec3(\n        scene(p - e.xyy).sdf,\n        scene(p - e.yxy).sdf,\n        scene(p - e.yyx).sdf\n    );\n    return normalize(norm);\n}\n\nhit march(vec3 ro, vec3 rd)\n{\n    float d = 0.;\n    vec3 p;\n    obj f;\n    for(int i = 0; i < RSTPS; i++)\n    {\n        p = ro + rd * d;\n        obj s = scene(p);\n        d += s.sdf;\n        if(s.sdf < SDST) return hit(d, p, s.mat);\n        if(d > MDST) break;     \n    }\n    return hit(-1.,vec3(0,0,0),NMAT);\n}\n\nfloat light(hit h, vec4 l)\n{\n    vec3 n = normal(h.pos);\n    vec3 d = normalize(l.xyz - h.pos);\n    float diff = dot(n,d);\n    return clamp(diff, 0.,1.) * l.w;\n}\n\n\nfloat light(hit h)\n{\n    float l1 = light(h,vec4(0,10,0,1));\n    float l2 = light(h,vec4(10,10,30,1));\n    return l1 + l2;\n}\n\nmat trace(vec3 ro, vec3 rd)\n{\n    mat ret = NMAT;\n    vec3 rfo = ro, rfd = rd;\n    float mxamnt = 1.;\n\n    for(int i = 0; i < BNCS; i++)\n    {\n        hit h = march(rfo, rfd);\n        ret.col = mix(ret.col, h.mat.col * light(h), mxamnt);\n        if(h.mat.spec <= 0.) break;       \n        vec3 n = normal(h.pos);  \n        rfd = reflect(rfd, n);\n        rfo = h.pos + n * SDST * 2.;\n        mxamnt = clamp(mxamnt - (1. - h.mat.spec), 0., 1.);\n    }\n    \n    return ret;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord-0.5*iResolution.xy)/iResolution.y;\n\n    vec3 ro = vec3(0,8,0);\n    vec3 rd = normalize(vec3(uv.x, uv.y - 0.5, 1));\n\n    vec3 col = trace(ro,rd).col;\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/NslSDH.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "NslSR7", "name": "Fork Playing ma kithy 995", "author": "kithy", "description": "3d marble texture ", "tags": ["3d", "fractal", "volumetric"], "likes": 6, "viewed": 76, "date": "1618411073", "time_retrieved": "2024-06-20T20:38:14.630251", "image_code": "#define ITR 32\n\nvec2 csqr(vec2 a){\n\treturn vec2(a.x*a.x-a.y*a.y,2.0*a.x*a.y);\n}\n\nmat2 rot(float a){\n\treturn mat2(cos(a),sin(a),-sin(a),cos(a));\n}\nvec2 iSphere(in vec3 ro,in vec3 rd,in vec4 sph){\n\tvec3 oc=ro-sph.xyz;\n\tfloat b=dot(oc,rd);\n\tfloat c=dot(oc,oc)-sph.w*sph.w;\n\tfloat h=b*b-c;\n\tif(h<0.0)return vec2(-1.0);\n\th=sqrt(h);\n\treturn vec2(-b-h,-b+h);\n}\n\nfloat map(in vec3 p){\n\t\n\tfloat res=0.0;\n\tvec3 c=p;\n\tfor(int i=0;i<10;i++){\n\t\tp.xz*=rot(iTime*0.2);\n\t\tp=0.7*abs(p)/dot(p,p)-0.7;\n\t\tp.yz=csqr(p.yz);\n\t\tp=p.zyx;\n\t\tres+=exp(-19.0*abs(dot(p,c)));\n\t}\n\treturn res/2.0;\n}\n\nvec3 raymarch(in vec3 ro,vec3 rd,vec2 tminmax){\n\tfloat t=tminmax.x;\n\tfloat dt=0.02;\n\tvec3 col=vec3(0.0);\n\tfloat c=0.0;\n\tfor(int i=0;i<ITR;i++){\n\t\tt+=dt*exp(-2.0*c);\n\t\tif(t>tminmax.y)break;\n\t\tvec3 pos=ro+t*rd;\n\n\t\tc=map(pos);\n\n\t\tcol=0.99*col+0.08*vec3(c*c);\n\t}\n\treturn col;\n}\n\nvoid mainImage(out vec4 fragColor,in vec2 fragCoord){\n\tvec2 uv=(2.0*fragCoord.xy-iResolution.xy)/iResolution.y;\n\n\tvec3 ro=vec3(1.0);\n\t\n\tvec3 ta=vec3(0.0);\n\tvec3 ww=normalize(ta-ro);\n\tvec3 uu=normalize(cross(ww,vec3(0.0,1.0,0.0)));\n\tvec3 vv=normalize(cross(uu,ww));\n\tvec3 rd=normalize(uv.x*uu+uv.y*vv+4.0*ww);\n\n\n\n\tvec2 tmm=iSphere(ro,rd,vec4(0.0,0.0,0.0,0.4));\n\n\tvec3 col=raymarch(ro,rd,tmm);\n\tif(tmm.x<0.0)col=vec3(0.0);\n\telse{\n\t\tvec3 nor=(ro+tmm.x*rd)/3.0;\n\t\tnor=reflect(rd,nor);\n\t\tfloat fre=pow(0.5+clamp(dot(nor,rd),0.0,1.0),2.0)*2.0;\n\t\tcol+=nor*fre;\n\t}\n\tcol=0.5*(log(1.0+col));\n\tcol=clamp(col,0.0,1.0);\n\tfragColor=vec4(col,1.0);\n\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/NslSR7.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "NslSWX", "name": "surprise0009", "author": "tangerine", "description": "juuust learning this stuff", "tags": ["circle"], "likes": 2, "viewed": 19, "date": "1619365614", "time_retrieved": "2024-06-20T20:38:14.824358", "image_code": "float Circle(vec2 uv, vec2 p, float r, float blur){\n    uv.x += sin(iTime/20.)/2. +.2;     \n    uv.y += sin(iTime/10.)/8. -.1;\n    float d = length(uv-p); \n    float c = smoothstep(r, r-blur, d); \n    return c;\n\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Time varying pixel color\n    vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n    uv -= .5;\n    uv.x *= iResolution.x/iResolution.y;\n    \n    //vec3 col = vec3(0.0);\n    float c = Circle(uv, vec2(.2,-.1), .4, .1);\n    c -= Circle(uv, vec2(.33,.08), .1, .05);\n    c -= Circle(uv, vec2(.07,.08), .1, .05);\n    c -= Circle(uv, vec2(.2,-.2), .2, .05);\n\n    col *= c;    \n    vec4 cola = vec4(.4);     \n    cola = vec4(col,1.0) + cola;\n    cola = smoothstep(.4, .6, cola) -.4;\n\n    // Output to screen\n    fragColor = cola;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/NslSWX.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "NslXDM", "name": "CircleCross - distance 2D", "author": "iq", "description": "Exact SDF to the intersection of four circles", "tags": ["2d", "distancefield", "sdf", "distancefunction", "distance"], "likes": 16, "viewed": 434, "date": "1618705226", "time_retrieved": "2024-06-20T20:38:14.824358", "image_code": "// The MIT License\n// Copyright © 2021 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// Exact SDF of four circle arcs\n\n// List of other 2D distances: https://www.shadertoy.com/playlist/MXdSRf\n//\n// and www.iquilezles.org/www/articles/distfunctions2d/distfunctions2d.htm\n\n\nfloat dot2( in vec2 v ) { return dot(v,v); }\nfloat sdRoundedCross( in vec2 p, in float h )\n{\n    float k = 0.5*(h+1.0/h);               // k should be const/precomputed at modeling time\n    \n    p = abs(p);\n    return ( p.x<1.0 && p.y<p.x*(k-h)+h ) ? \n             k-sqrt(dot2(p-vec2(1,k)))  :  // circular arc\n           sqrt(min(dot2(p-vec2(0,h)),     // top corner\n                    dot2(p-vec2(1,0))));   // right corner\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n    vec2 m = (2.0*iMouse.xy-iResolution.xy)/iResolution.y;\n    p *= 1.35;\n    m *= 1.35;\n    \n    // animate\n    float he = 0.501-0.499*cos(iTime*1.1+0.0);\n    float ra = 0.100+0.100*sin(iTime*1.7+2.0);\n\n    // compute\n\tfloat d = sdRoundedCross( p, he ) - ra;\n\n    // colorize\n    vec3 col = vec3(1.0) - sign(d)*vec3(0.1,0.4,0.7);\n\tcol *= 1.0 - exp(-3.0*abs(d));\n\tcol *= 0.8 + 0.2*cos(128.0*d);\n\tcol = mix( col, vec3(1.0), 1.0-smoothstep(0.0,0.01,abs(d)) );\n\n    if( iMouse.z>0.001 )\n    {\n    d = sdRoundedCross(m, he) - ra;\n    col = mix(col, vec3(1.0,1.0,0.0), 1.0-smoothstep(0.0, 0.005, abs(length(p-m)-abs(d))-0.0025));\n    col = mix(col, vec3(1.0,1.0,0.0), 1.0-smoothstep(0.0, 0.005, length(p-m)-0.015));\n    }\n\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "mit", "thumbnail": "https://www.shadertoy.com/media/shaders/NslXDM.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "NslXWf", "name": "_Night Sky_", "author": "bhpcv252", "description": "**Night Sky**\n\nTry lowering NS value if you see white/black screen.", "tags": ["stars", "nightsky", "twinkle"], "likes": 4, "viewed": 120, "date": "1619447413", "time_retrieved": "2024-06-20T20:38:14.830189", "image_code": "#define NS 1000.\n\nfloat L(vec2 uv, vec2 ofs, float b, float l) {\n    return smoothstep(0., 1000., b*max(0.1, l)/pow(max(0.0000000000001, length(uv-ofs)), 1./max(0.1, l)));\n}\n\nfloat rand(vec2 co, float s){\n    float PHI = 1.61803398874989484820459;\n    return fract(tan(distance(co*PHI, co)*s)*co.x);\n}\n\nvec2 H12(float s) {\n    float x = rand(vec2(243.234,63.834), s)-.5;\n    float y = rand(vec2(53.1434,13.1234), s)-.5;\n    return vec2(x, y);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n\n    uv -= .5;\n    uv.x *= iResolution.x/iResolution.y;\n\n    \n    vec4 col = vec4(.0);\n    \n    vec4 b = vec4(0.01176470588, 0.05098039215, 0.14117647058, 1.);\n    vec4 p = vec4(0.13333333333, 0.07843137254, 0.13725490196, 1.);\n    vec4 lb = vec4(0.10196078431, 0.21568627451, 0.33333333333, 1.);\n    \n    vec4 blb = mix(b, lb, -uv.x*.2-(uv.y*.5));\n    \n    col += mix(blb, p, uv.x-(uv.y*1.5));\n    \n    for(float i=0.; i < NS; i++) {\n    \n        vec2 ofs = H12(i+1.);\n        ofs *= vec2(1.8, 1.1);\n        float r = (mod(i, 20.) == 0.)? 0.25+abs(sin(i/50.)): 0.25;\n        col += vec4(L(uv, ofs, r+(sin(fract(iTime)*.01*i)+1.)*0.02, 1.));\n    }\n\n    fragColor = col;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/NslXWf.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "NslXz2", "name": "MyFirstShader5150", "author": "GeoffSmithee", "description": "Just learning this stuff. ", "tags": ["simple"], "likes": 2, "viewed": 33, "date": "1618888164", "time_retrieved": "2024-06-20T20:38:14.830463", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n// MyFirstShader\n\n// GeoffSmithee\n\n// combined some code fron the initial \"new\" and from a youtube video\n// https://www.youtube.com/watch?v=u5HAYVHsasc\n\n\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord.xy/iResolution.xy;\n    \n    uv -= 0.5; // -.5 <> .5\n    \n    uv.x *= iResolution.x/iResolution.y; //adjust x by aspect ratio\n        \n    float d = length(uv);    // vector length sqrt((uv.x*uv.x) + (uv.y*uv.y))\n    float r = 0.3;           // radius of circle\n    \n    float c = d;\n    \n    \n    \n    //float c = smoothstep( r, r-0.02, d);\n    \n    vec3 col;\n    \n    if ( d > .3) col = vec3 (c); else col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/NslXz2.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "NsS3Dt", "name": "Red Landscape", "author": "edubart", "description": "Experimenting generating terrain and simple clouds with noise, and some color grading tools.", "tags": ["procedural", "cineshader"], "likes": 23, "viewed": 1687, "date": "1618081018", "time_retrieved": "2024-06-20T20:38:15.897096", "image_code": "/* Generated by Nelua 0.2.0-dev */\n/* Compile command: clang \"/home/bart/projects/nelua/nelua-lang/nelua_cache/demos/redlandscape.c\" -o \"/home/bart/projects/nelua/nelua-lang/nelua_cache/demos/redlandscape\" -Wall -fwrapv -g -lm */\n/* Compile hash: 3wm5WeyBu2gJj7S5c3vNMfx1ovQd */\n/* ------------------------------ DECLARATIONS ------------------------------ */\nvec3 vec_tovec3(vec3 a);\nvec3 noise_vec2_xyx(vec2 self);\nvec2 demos_redlandscape_vec4_xy(vec4 self);\nvec2 demos_redlandscape_vec3_xz(vec3 self);\nfloat vec_smootherstep(float edge0, float edge1, float x);\nfloat vec_fastmix(float a, float b, float t);\nvec3 vec_fastmix_1(vec3 a, vec3 b, float t);\nvec2 sincos(float x);\nvec2 demos_redlandscape_vec3_xy(vec3 self);\nvec3 noise_vec3_yzx(vec3 self);\nvec2 noise_vec3_xx(vec3 self);\nvec2 noise_vec3_yz(vec3 self);\nvec2 noise_vec3_zy(vec3 self);\nfloat noise_hash1_2(vec2 v);\nvec2 noise_hash2_1(vec2 v);\nfloat noise_noisemix2(float a, float b, float c, float d, vec2 f);\nfloat noise_noise_white_1(vec2 p);\nfloat noise_noise_value_1(vec2 p);\nfloat noise_noise_gradient_1(vec2 p);\nvec3 colorgrade_colorgrade_tonemap_aces(vec3 col);\nvec3 colorgrade_colorgrade_saturate(vec3 col, float sat);\nvec3 colorgrade_colorgrade_tone_1(vec3 col, vec3 gain, vec3 lift, vec3 invgamma);\nvec3 colorgrade_colorgrade_gamma_correction(vec3 col);\nvec3 colorgrade_colorgrade_vignette(vec3 col, vec2 coord, float strength, float amount);\nvec3 colorgrade_colorgrade_dither(vec3 col, vec2 coord, float amount);\nvec3 camera_camera_perspective(vec3 lookfrom, vec3 lookat, float tilt, float vfov, vec2 uv);\nfloat demos_redlandscape_fbm_terrain(vec2 p);\nfloat demos_redlandscape_map(vec3 p);\nfloat demos_redlandscape_ray_march(vec3 ro, vec3 rd);\n/* ------------------------------ DEFINITIONS ------------------------------- */\nvec3 vec_tovec3(vec3 a) {\n  return vec3(a.x, a.y, a.z);\n}\nvec3 noise_vec2_xyx(vec2 self) {\n  return vec3(self.x, self.y, self.x);\n}\nvec2 demos_redlandscape_vec4_xy(vec4 self) {\n  return vec2(self.x, self.y);\n}\nvec2 demos_redlandscape_vec3_xz(vec3 self) {\n  return vec2(self.x, self.z);\n}\nfloat vec_smootherstep(float edge0, float edge1, float x) {\n  float t = clamp(((x - edge0) / (edge1 - edge0)), 0.0, 1.0);\n  return (((t * t) * t) * ((t * ((t * 6.0) - 15.0)) + 10.0));\n}\nfloat vec_fastmix(float a, float b, float t) {\n  return (a + ((b - a) * t));\n}\nvec3 vec_fastmix_1(vec3 a, vec3 b, float t) {\n  return (a + ((b - a) * t));\n}\nvec2 sincos(float x) {\n  return vec2(sin(x), cos(x));\n}\nvec2 demos_redlandscape_vec3_xy(vec3 self) {\n  return vec2(self.x, self.y);\n}\nvec3 noise_vec3_yzx(vec3 self) {\n  return vec3(self.y, self.z, self.x);\n}\nvec2 noise_vec3_xx(vec3 self) {\n  return vec2(self.x, self.x);\n}\nvec2 noise_vec3_yz(vec3 self) {\n  return vec2(self.y, self.z);\n}\nvec2 noise_vec3_zy(vec3 self) {\n  return vec2(self.z, self.y);\n}\nfloat noise_hash1_2(vec2 v) {\n  vec3 v3 = noise_vec2_xyx(v);\n  v3 = fract((v3 * 0.1031));\n  v3 = (v3 + dot(v3, (noise_vec3_yzx(v3) + 33.33)));\n  return fract(((v3.x + v3.y) * v3.z));\n}\nvec2 noise_hash2_1(vec2 v) {\n  vec3 v3 = noise_vec2_xyx(v);\n  v3 = (v3 * vec3(0.1031, 0.103, 0.0973));\n  v3 = (v3 + dot(v3, (noise_vec3_yzx(v3) + 33.33)));\n  return fract(((noise_vec3_xx(v3) + noise_vec3_yz(v3)) * noise_vec3_zy(v3)));\n}\nfloat noise_noisemix2(float a, float b, float c, float d, vec2 f) {\n  vec2 u = ((f * f) * (3.0 - (2.0 * f)));\n  return vec_fastmix(vec_fastmix(a, b, u.x), vec_fastmix(c, d, u.x), u.y);\n}\nfloat noise_noise_white_1(vec2 p) {\n  return noise_hash1_2(p);\n}\nfloat noise_noise_value_1(vec2 p) {\n  vec2 i = floor(p);\n  vec2 f = fract(p);\n  vec2 I = floor((i + 1.0));\n  float a = noise_hash1_2(i);\n  float b = noise_hash1_2(vec2(I.x, i.y));\n  float c = noise_hash1_2(vec2(i.x, I.y));\n  float d = noise_hash1_2(I);\n  return noise_noisemix2(a, b, c, d, f);\n}\nfloat noise_noise_gradient_1(vec2 p) {\n  vec2 i = floor(p);\n  vec2 f = fract(p);\n  vec2 I = floor((i + 1.0));\n  vec2 F = (f - 1.0);\n  float a = dot((-0.5 + noise_hash2_1(i)), f);\n  float b = dot((-0.5 + noise_hash2_1(vec2(I.x, i.y))), vec2(F.x, f.y));\n  float c = dot((-0.5 + noise_hash2_1(vec2(i.x, I.y))), vec2(f.x, F.y));\n  float d = dot((-0.5 + noise_hash2_1(I)), F);\n  return (0.5 + noise_noisemix2(a, b, c, d, f));\n}\nvec3 colorgrade_colorgrade_tonemap_aces(vec3 col) {\n  return clamp(((col * ((2.51 * col) + 0.03)) / ((col * ((2.43 * col) + 0.59)) + 0.14)), 0.0, 1.0);\n}\nvec3 colorgrade_colorgrade_saturate(vec3 col, float sat) {\n  float grey = dot(col, vec3(0.2125, 0.7154, 0.0721));\n  return (grey + (sat * (col - grey)));\n}\nvec3 colorgrade_colorgrade_tone_1(vec3 col, vec3 gain, vec3 lift, vec3 invgamma) {\n  col = pow(col, vec_tovec3(invgamma));\n  return (((gain - lift) * col) + lift);\n}\nvec3 colorgrade_colorgrade_gamma_correction(vec3 col) {\n  return ((1.12661 * sqrt(col)) - (0.12661 * col));\n}\nvec3 colorgrade_colorgrade_vignette(vec3 col, vec2 coord, float strength, float amount) {\n  return (col * ((1.0 - amount) + (amount * pow(((((16.0 * coord.x) * coord.y) * (1.0 - coord.x)) * (1.0 - coord.y)), strength))));\n}\nvec3 colorgrade_colorgrade_dither(vec3 col, vec2 coord, float amount) {\n  return clamp((col + (noise_noise_white_1(coord) * amount)), 0.0, 1.0);\n}\nvec3 camera_camera_perspective(vec3 lookfrom, vec3 lookat, float tilt, float vfov, vec2 uv) {\n  vec2 sc = sincos(tilt);\n  vec3 vup = vec3(sc.x, sc.y, 0.0);\n  vec3 w = normalize((lookat - lookfrom));\n  vec3 u = normalize(cross(w, vup));\n  vec3 v = cross(u, w);\n  float wf = (1.0 / tan((vfov * 0.00872664626)));\n  return normalize((((uv.x * u) + (uv.y * v)) + (wf * w)));\n}\nfloat demos_redlandscape_fbm_terrain(vec2 p) {\n  float a = 1.0;\n  float t = 0.0;\n  t = (t + (a * noise_noise_value_1(p)));\n  a = (a * 0.5);\n  p = (2.0 * p);\n  t = (t + (a * noise_noise_value_1(p)));\n  a = (a * 0.5);\n  p = (2.0 * p);\n  t = (t + (a * noise_noise_value_1(p)));\n  a = (a * 0.5);\n  p = (2.0 * p);\n  t = (t + (a * noise_noise_value_1(p)));\n  a = (a * 0.5);\n  p = (2.0 * p);\n  return t;\n}\nfloat demos_redlandscape_map(vec3 p) {\n  vec2 q = demos_redlandscape_vec3_xz(p);\n  float h = (demos_redlandscape_fbm_terrain(q) * 0.5);\n  float d = ((p.y + (h * 0.75)) + 0.0);\n  return (d * 0.5);\n}\nfloat demos_redlandscape_ray_march(vec3 ro, vec3 rd) {\n  float t = 0.0;\n  for(int i = 1; i <= 256; i = i + 1) {\n    vec3 p = (ro + (t * rd));\n    float d = demos_redlandscape_map(p);\n    if((d < (0.003 * t)) || (t >= 25.0)) {\n      break;\n    }\n    t = (t + d);\n  }\n  return t;\n}\nvoid mainImage(out vec4 frag_col, in vec2 frag_coord) {\n  vec2 res = demos_redlandscape_vec3_xy(iResolution);\n  vec2 mouse = (demos_redlandscape_vec4_xy(iMouse) / res);\n  vec2 uv = (frag_coord / res);\n  vec2 coord = ((2.0 * (frag_coord - (res * 0.5))) / res.y);\n  float z = (iTime * 1.0);\n  vec2 sc = sincos((iTime * 0.5));\n  float y = 0.0;\n  vec3 lookat = vec3((sc.x * 0.5), y, z);\n  vec3 ro = vec3(((-sc.x) * 0.5), y, (z - 2.0));\n  vec3 rd = camera_camera_perspective(ro, lookat, 0.0, 45.0, coord);\n  vec3 col = vec3(0.0, 0.0, 0.0);\n  vec3 sun_dir = normalize(vec3(0.3, 0.07, 1.0));\n  vec3 hor_col = vec3(0.7, 0.05, 0.01);\n  vec3 sun_col = vec3(0.9, 0.8, 0.7);\n  vec3 bou_col = vec3(0.8, 0.3, 0.1);\n  float t = demos_redlandscape_ray_march(ro, rd);\n  vec3 p = (ro + (rd * t));\n  vec3 back_col;\n  {\n    back_col = vec_fastmix_1(hor_col, (hor_col * 0.3), vec_smootherstep(0.0, 0.25, rd.y));\n    back_col = vec_fastmix_1(back_col, bou_col, max((0.1 - rd.y), 0.0));\n    float sun_lightness = max(dot(rd, sun_dir), 0.0);\n    back_col = (back_col + (sun_col * pow(sun_lightness, 2000.0)));\n    back_col = (back_col + ((0.3 * sun_col) * pow(sun_lightness, 100.0)));\n    back_col = (back_col + (vec3(0.3, 0.2, 0.1) * pow(sun_lightness, 4.0)));\n  }\n  if(abs(coord.y) > 0.75) {\n    col = vec3(0.0, 0.0, 0.0);\n  } else if(t < 25.0) {\n    float decay = (1.0 - exp((-0.12 * t)));\n    col = mix(col, back_col, decay);\n  } else {\n    col = back_col;\n    float clouds_altitude = 1000.0;\n    float clouds_dist = ((1.0 - (ro.y / clouds_altitude)) / rd.y);\n    if(clouds_dist > 0.0) {\n      float clouds_zoom = 1.0;\n      vec2 clouds_pos = (demos_redlandscape_vec3_xz(ro) + ((demos_redlandscape_vec3_xz(rd) * clouds_dist) * clouds_zoom));\n      float clouds_lightness = max((noise_noise_gradient_1(clouds_pos) - 0.3), 0.0);\n      float clouds_decay = vec_smootherstep(0.0, 0.3, rd.y);\n      vec3 clouds_col = (2.0 * col);\n      col = vec_fastmix_1(col, clouds_col, (clouds_lightness * clouds_decay));\n    }\n    col = clamp(col, 0.0, 1.0);\n  }\n  col = colorgrade_colorgrade_tonemap_aces(col);\n  col = colorgrade_colorgrade_gamma_correction(col);\n  col = colorgrade_colorgrade_tone_1(col, vec3(1.3, 0.9, 0.7), (vec3(0.5, 0.1, 0.1) * 0.1), vec3(3.0, 2.0, 1.2));\n  col = colorgrade_colorgrade_saturate(col, 0.7);\n  col = colorgrade_colorgrade_vignette(col, uv, 0.25, 0.7);\n  col = colorgrade_colorgrade_dither(col, frag_coord, 0.01);\n  frag_col = vec4(col.x, col.y, col.z, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/NsS3Dt.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "NsS3RK", "name": "overlaptest", "author": "Drakyen", "description": "a test shader with overlapping circles", "tags": ["2d", "circle"], "likes": 2, "viewed": 29, "date": "1617625612", "time_retrieved": "2024-06-20T20:38:15.897096", "image_code": "#define rot(a) mat2(cos(a), -sin(a), sin(a), cos(a)) \n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord.xy-.5 * iResolution.xy)/iResolution.y;\n\n    vec4 col;\n    \n    vec2 circlecentre1 = vec2(sin(iTime) / 4., cos(iTime) / 4.);\n    vec2 circlecentre2 = vec2(cos(iTime) / 2., sin(iTime) / 4.);\n    vec2 circlecentre3 = vec2(sin(iTime) / 2., sin(iTime) / 4.);\n    vec2 circlecentre4 = vec2(cos(iTime) / 2., cos(iTime) / 4.);\n\n    float d1 = distance(uv, circlecentre1);\n    float d2 = distance(uv, circlecentre2);\n    float d3 = distance(uv, circlecentre3);\n    float d4 = distance(uv, circlecentre4);\n    \n    vec4 rainbow = mix(mix(vec4(1.,0.,0.,1.), vec4(0.,1.,0.,1.), uv.x + 0.5), vec4(0.,0.,1.,1.), uv.y + 0.5);\n\n    if(d1 < 0.4) col = mix(texture(iChannel0, uv * rot(iTime) - circlecentre1 * rot(iTime)), rainbow, step(0.39,d1));   \n    if(d2 < 0.3) col = mix(texture(iChannel1, uv * rot(iTime) - circlecentre2 * rot(iTime)), rainbow, step(0.29,d2));   \n    if(d3 < 0.2) col = mix(texture(iChannel0, uv * rot(-iTime) - circlecentre3 * rot(-iTime)), rainbow, step(0.19,d3));   \n    if(d4 < 0.1) col = mix(texture(iChannel1, uv * rot(-iTime) - circlecentre4 * rot(-iTime)), rainbow, step(0.09,d4));   \n\n    // Output to screen\n    fragColor = col;\n}", "image_inputs": [{"id": "4df3Rr", "previewfilepath": "/media/ap/3871e838723dd6b166e490664eead8ec60aedd6b8d95bc8e2fe3f882f0fd90f0.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/3871e838723dd6b166e490664eead8ec60aedd6b8d95bc8e2fe3f882f0fd90f0.jpg", "ctype": "texture"}, {"id": "Xsf3Rr", "previewfilepath": "/media/ap/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/NsS3RK.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "NsSGDG", "name": "Distance to feature points VI", "author": "tomoe", "description": "The 1st to 3rd closest distances are assigned to RGB color (fork from [url=https://www.shadertoy.com/view/fsSGDG]Distance to feature points V[/url])\nL: (R,G,B)=(F1,F2,F3), R: binarization of Left", "tags": ["bd202104"], "likes": 1, "viewed": 48, "date": "1617850694", "time_retrieved": "2024-06-20T20:38:15.897096", "image_code": "uvec3 k = uvec3(0x456789abu, 0x6789ab45u, 0x89ab4567u);\nconst uint max32 = 0xffffffffu;\nconst float PI = 3.14159265359;\nuvec2 hash22u(uvec2 n) {  \n    n ^= (n.yx << 24);\n    n ^= (n.yx >> 1);\n    n *= k.xy;\n    n ^= (n.yx << 1);\n    return n * k.xy;\n}\nuvec3 hash33u(uvec3 n) {\n    n ^= (n.yzx << 24);\n    n ^= (n.yzx >> 1);\n    n *= k;\n    n ^= (n.yzx << 1);\n    return n * k;\n}\nmat2 rot2(float t) {\n    return mat2(cos(t), sin(t), -sin(t),  cos(t));\n}\nfloat length2_2d(vec2 v){\n    return dot(v, v);\n}\nfloat length2_3d(vec3 v){\n    return dot(v, v);\n}\nvec2 hash22(vec2 p) {\n    uvec2 n = uvec2(p);\n    return vec2(hash22u(n)) / vec2(max32) - 0.5;\n}\nvec3 hash33(vec3 p) {\n    uvec3 n = uvec3(p);\n    return vec3(hash33u(n)) / vec3(max32) - 0.5;\n}\nvec4 sort(vec4 list, float v){\n    if (list.w < v){\n        return list;\n    } else {\n        vec4 newList = list.wxyz;\n        for(int i = 0; i < 4; i ++ ) {\n            if (list[i] < v) {\n                newList[i] = list[i];\n            } else {\n                newList[i] = v;\n                break;\n            }\n        }\n        return newList;\n    }\n}\nvec4 F4_2d(vec2 p){   \n    vec2 n = round(p);\n    vec2 f = p - round(p);\n    vec4 dist4 = vec4(length2_2d(1.5 - abs(f)));\n    vec2 sgn = vec2(1.0);\n    vec2 glid = vec2(0.0);\n    for(float j = 0.0; j <= 4.0; j ++ ) {\n        glid.y += sgn.y * j;\n        sgn.y *= -1.0;\n        if (abs(glid.y - f.y) - 0.5 > sqrt(dist4.w)){\n            continue;\n        }\n        for(float i = 0.0; i <= 4.0; i ++ ){\n            glid.x += sgn.x * i;\n            sgn.x *= -1.0;\n            vec2 nbd = glid + rot2(iTime) * hash22(n + glid) / sqrt(2.0);\n            float dist = length2_2d(nbd -f);\n            dist4 = sort(dist4, dist);\n        }\n        glid.x = 0.0;\n    }\n    return sqrt(dist4);\n}\nvec4 F4_3d(vec3 p){   \n    vec3 n = round(p);\n    vec3 f = p - round(p);\n    vec4 dist4 = vec4(length2_3d(1.5 - abs(f)));\n    vec3 sgn = vec3(1.0);\n    vec3 glid = vec3(0.0);\n    for(float k = 0.0; k <= 4.0; k ++ ) {\n            glid.z += sgn.z * k;\n            sgn.z *= -1.0;\n            if (abs(glid.z - f.z) - 0.5 > sqrt(dist4.w)){\n                continue;\n            }\n        for(float j = 0.0; j <= 4.0; j ++ ) {\n            glid.y += sgn.y * j;\n            sgn.y *= -1.0;\n            if (abs(glid.y - f.y) - 0.5 > sqrt(dist4.w)){\n                continue;\n            }\n            for(float i = 0.0; i <= 4.0; i ++ ){\n                glid.x += sgn.x * i;\n                sgn.x *= -1.0;\n                vec3 nbd = glid + hash33(n + glid);\n                float dist = length2_3d(nbd - f);\n                dist4 = sort(dist4, dist);\n            }\n            glid.x = 0.0;\n        }\n        glid.y = 0.0;\n    }\n    return sqrt(dist4);\n}\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n    vec2 pos = fragCoord.xy/ iResolution.xx;\n    pos *= 10.0;\n    pos += iTime;\n    vec4 v;\n    if(fragCoord.y < 0.5 * iResolution.y){\n        v = F4_2d(pos);    \n    } else {\n        v = F4_3d(vec3(pos, iTime));\n    }\n    if (fragCoord.x > 0.5 * iResolution.x){\n        v = step(0.6, v);    \n    }\n    fragColor = vec4(v.xyz, 1.0);  //left\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/NsSGDG.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "NsSGDV", "name": "Point -> Patch UV", "author": "oneshade", "description": "My take on Inigo Quilez's article: https://www.iquilezles.org/www/articles/ibilinear/ibilinear.htm\nGoes crazy in some cases.", "tags": ["uv", "quadratic", "inverse", "interpolation", "parametric", "bilinear", "patch"], "likes": 4, "viewed": 74, "date": "1617939219", "time_retrieved": "2024-06-20T20:38:16.351524", "image_code": "// Set to 0 to see the whole surface\n#define ONLY_PATCH 1\n\n// Drawing utilities\n#define draw(d, c) color = mix(color, c, smoothstep(unit, 0.0, d))\n\n// SDFs\nfloat sdDisc(in vec2 p, in vec2 o, in float r) {\n    return length(p - o) - r;\n}\n\nfloat sdLine(in vec2 p, in vec2 a, in vec2 b, in float t) {\n    vec2 pa = p - a, ba = b - a;\n    return length(pa - ba * clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0)) - t;\n}\n\n// Computes u and v for a given point and quad\n// There are two solutions\nfloat cross2D(in vec2 a, in vec2 b) { return a.y * b.x - a.x * b.y; }\nbool iBilinear(in vec2 xy, in vec2 a, in vec2 b, in vec2 c, in vec2 d, out vec4 uv) {\n    vec2 p = a - b + c - d;\n    vec2 q = b - a, r = d - a;\n\n    float c1 = cross2D(r, p);\n    float c2 = cross2D(r, q) + cross2D(a, p) + cross2D(p, xy);\n    float c3 = cross2D(a, q) + cross2D(q, xy);\n\n    float discr = c2 * c2 - 4.0 * c1 * c3;\n    if (discr > 0.0) {\n        uv.yw = (vec2(-1.0, 1.0) * sqrt(discr) - c2) / c1 * 0.5;\n        uv.xz = (xy.x - a.x - r.x * uv.yw) / (p.x * uv.yw + q.x);\n        return true;\n    }\n\n    return false;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y * 4.0;\n    float unit = 8.0 / iResolution.y;\n    vec3 color = vec3(0.5);\n\n    float t1 = iTime * 0.5, t2 = iTime, t3 = iTime * 1.25;\n\n    float c1 = cos(t1), s1 = sin(t1);\n    float c2 = cos(t2), s2 = sin(t2);\n    float c3 = cos(t3), s3 = sin(t3);\n\n    vec2 a = vec2(c2, s2) * 1.5 + vec2(c1, s3) * 0.5;\n    vec2 b = vec2(c2, s1) * 1.5 + vec2(s1, c2) * 0.5;\n    vec2 c = vec2(c1, c3) * 1.5 + vec2(c2, s3) * 0.5;\n    vec2 d = vec2(s2, s3) * 1.5 + vec2(c1, s2) * 0.5;\n\n    vec4 params;\n    if (iBilinear(uv, a, b, c, d, params)) {\n        float numPoints = 0.0;\n        vec3 patchColor = vec3(0.0);\n        if (ONLY_PATCH == 1 ? all(lessThan(abs(params.xy - 0.5), vec2(0.5))) : true) {\n            patchColor += texture(iChannel0, params.xy).rgb;\n            numPoints++;\n        }\n\n        if (ONLY_PATCH == 1 ? all(lessThan(abs(params.zw - 0.5), vec2(0.5))) : true) {\n            patchColor += texture(iChannel0, params.zw).rgb;\n            numPoints++;\n        }\n\n        if (numPoints > 0.0) color = patchColor / numPoints;\n    }\n\n    draw(sdLine(uv, a, b, 0.005), vec3(1.0, 0.8, 0.0));\n    draw(sdLine(uv, b, c, 0.005), vec3(1.0, 0.8, 0.0));\n    draw(sdLine(uv, c, d, 0.005), vec3(1.0, 0.8, 0.0));\n    draw(sdLine(uv, d, a, 0.005), vec3(1.0, 0.8, 0.0));\n\n    draw(sdDisc(uv, a, 0.05), vec3(1.0));\n    draw(sdDisc(uv, b, 0.05), vec3(1.0));\n    draw(sdDisc(uv, c, 0.05), vec3(1.0));\n    draw(sdDisc(uv, d, 0.05), vec3(1.0));\n\n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [{"id": "4dX3Rn", "previewfilepath": "/media/ap/bd6464771e47eed832c5eb2cd85cdc0bfc697786b903bfd30f890f9d4fc36657.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/bd6464771e47eed832c5eb2cd85cdc0bfc697786b903bfd30f890f9d4fc36657.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/NsSGDV.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "NssSDf", "name": "SIGGRAPH Frontiers 2021 demo ", "author": "Flopine", "description": "A simple and quick shader made as a learning material for my talk at SIGGRAPH Frontiers 2021", "tags": ["3d", "raymarching", "comments", "siggraph", "lean"], "likes": 12, "viewed": 178, "date": "1619374203", "time_retrieved": "2024-06-20T20:38:17.182148", "image_code": "// Code by Flopine\n\n// Thanks to wsmind, leon, XT95, lsdlive, lamogui, \n// Coyhot, Alkama,YX, NuSan, slerpy and wwrighter for teaching me\n\n// Thanks LJ for giving me the spark :3\n\n// Thanks to the Cookie Collective, which build a cozy and safe environment for me \n// and other to sprout :)  https://twitter.com/CookieDemoparty\n\n\n#define PI acos(-1.)\n#define rotation(a) mat2(cos(a),sin(a),-sin(a),cos(a))\n\n// cosine palette from iq\n// https://www.iquilezles.org/www/articles/palettes/palettes.htm\nvec3 palette (float t, vec3 c)\n{return vec3(0.5)+vec3(0.5)*cos(2.*PI*(c*t+vec3(0.,0.36,0.64)));}\n\n// 2D mask returning 0 or 1 based on a threshold\n// on repeated UVs\nfloat mask (vec2 uv)\n{\n    // animate the UVs\n    uv += iTime*.5;\n    // draw a diagonal\n    float m = uv.x+uv.y;\n    // repeat it by taking the fractional part (= modulo by 1)\n    // and shift the position by half a period\n    // to put the shape in the center of the cell\n    m = fract(m)-.5;\n    // symmetrize the shape with absolute value\n    m = abs(m);\n    \n    // return the mask by making a threshold of the value m\n    return step(0.1, m);\n}\n\n// declare global variables for id of repetition\n// and glow accumulation\nfloat id, g1=0.;\n\n// Signed Distance Function\n// also called map() by many shadercoders\n// this is our scene, our 3d shapes\nfloat SDF (vec3 p)\n{\n    // store the original space\n    vec3 pp = p;\n    \n    // symmetrize in the y axis\n    p.y = abs(p.y)-10.;\n    \n    // declare a period for the repetition\n    float period = 4.;\n    // calculate the id of the cells\n    id = floor(p.x/period);\n    // repeat the space\n    p.x = mod(p.x,period)-period*0.5;\n    \n    // \"push\" the shapes in the x axis based on a sine wave along z axis\n    p.x += sin(p.z*id*0.2+iTime*2.)*0.5;\n    // \"push\" the shapes in the y axis based on a sine wave along z axis\n    p.y += cos(p.z*id*0.1+iTime*3.);\n    \n    // declare the shape, an infinite cylinder\n    float c1 = length(p.xy)-0.5;\n    \n    // retrieve original position to clea all space transformations\n    // made previously\n    p = pp;\n    // rotate the space in the z axis\n    p.xy *= rotation(iTime);       \n    \n    // symmetrize the space on the x and y axis\n    p.xy = abs(p.xy)-.8; \n    \n    // declare the shape, a sphere\n    float s = length(p)-0.5;\n    // accumulation for making the sphere glowing\n    g1 += 0.01/(0.01+s*s);\n    \n    // return all the shapes that compose our field\n    // min = union, max = intersection, max(-shape,othershape) = subtraction\n    return min(s,c1);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    // Normalized pixel coordinates (from -1 to 1)\n    vec2 centered_uv = (2.*fragCoord-iResolution.xy)/iResolution.y;\n    \n    // kaleidoscopic effect on UVs\n    //centered_uv = abs(centered_uv)-0.5;\n    \n    // fake diffraction by moving slightly the UVs\n    // based on the 2D mask\n    centered_uv += mask(centered_uv)*0.1;\n    \n    // declaring the camera\n    vec3 ro = vec3(0.,0.,-3.), \n    rd = normalize(vec3(centered_uv,1.)),\n    p = ro,\n    // declaring the color background\n    col = vec3(0.);\n    \n    bool hit = false;\n    \n    // will help us store the iterations \n    // for a supe chap and fake AO\n    float shad;\n    \n    // raymarching loop\n    for (float i=0.; i<64.; i++)\n    {\n        float d = SDF(p);       \n        if(d<0.01)  // if we're really close to the shape\n        {\n            hit = true;\n            shad = i/64.;\n            break;\n        }\n        // moving along the ray \n        // with the technique of sphere-tracing\n        p += d*rd*0.6;\n    }\n    \n    if (hit)\n    {\n        col = palette(id,vec3(0.1));\n        col *= 1.-shad;\n    }\n    \n    // adding the glow on spheres\n    col += g1*0.5;\n    \n    // Output to screen\n    // sqrt() make a approx. gamma correction\n    // the correct one is pow(col, vec3(1./2.2))\n    fragColor = vec4(sqrt(col),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/NssSDf.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "NssSW8", "name": "Earth atmosphere from space ", "author": "FabriceNeyret2", "description": "Mouse controls Sun direction\n\nstill ultra-far from this ref ;-)\n[img]https://www.pausecafein.fr/images/cafein/2021/03/foutrement-interessant/coucher-soleil.jpg[/img]", "tags": ["earth", "atmosphere", "short"], "likes": 10, "viewed": 231, "date": "1618574522", "time_retrieved": "2024-06-20T20:38:17.382060", "image_code": "#define C(z)   exp(- 1./vec4(1,.6,.4,1) * H/(z) )        // spectral transmittance for optical depth z\n\nvoid mainImage( out vec4 O, vec2 u )\n{\n    vec2 R = iResolution.xy,\n         U = 1.2* ( 2.*u - R ) / R.y,\n         M = 1.2* ( 2.*iMouse.xy - R ) / R.y;\n\n    float H = .1,                                          // atmosphere thickness ralative to radius\n          r = dot(U,U),\n          d = dot(M,M),\n          t = -.3*iTime,\n          l = dot( vec3(U, sqrt(1.-r)),                    // hit point in Sun frame\n                   iMouse.z > 0.             \n                     ? vec3(M,sqrt(abs(1.-d))*sign(1.-d))  // Sun direction\n                     : vec3(cos(t)*vec2(cos(-.5),sin(-.5)),sin(t))\n                 );\n   \n    O = r < 1. ? ( 1.- C( sqrt(1.-r) )  )                  // atmosphere opacity along ray\n      * smoothstep(-sqrt(2.*H),0.,l) * smoothstep(1.,1.-16./R.y,r) // up to terminator + AA\n                + mix( l * vec4(.4,.4,1,0) ,               // ocean color\n                       2.5*C(max(0.,l)),                   // Sun color seen by clouds and reflected to space\n                       texture(iChannel0,U/vec2(5,1)+vec2(-t/20.,0)).r*smoothstep(1.,0.,abs(U.y))    // cloud layer\n                     )\n               : vec4(0);  \n}", "image_inputs": [{"id": "4sf3Rr", "previewfilepath": "/media/ap/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/NssSW8.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "NssSWN", "name": "Clouds by Darko", "author": "omegasbk", "description": "Quickly made some fog/clouds for my youtube lesson", "tags": ["clouds", "valuenoise"], "likes": 3, "viewed": 193, "date": "1618680983", "time_retrieved": "2024-06-20T20:38:17.382060", "image_code": "// Made by Darko Supe (omegasbk)\n\nfloat noise(vec2 uv)\n{\n    return fract(sin(uv.x * 113. + uv.y * 412.) * 6339.);\n}\n\nvec3 noiseSmooth(vec2 uv)\n{\n    vec2 index = floor(uv);\n    \n    vec2 pq = fract(uv);\n    pq = smoothstep(0., 1., pq);\n     \n    float topLeft = noise(index);\n    float topRight = noise(index + vec2(1, 0.));\n    float top = mix(topLeft, topRight, pq.x);\n    \n    float bottomLeft = noise(index + vec2(0, 1));\n    float bottomRight = noise(index + vec2(1, 1));\n    float bottom = mix(bottomLeft, bottomRight, pq.x);\n    \n    return vec3(mix(top, bottom, pq.y));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    vec3 sky = vec3(0.5, 0.7, 0.85) * ((1. - uv.y) + 1.5) / 2.;\n\n    \n    uv += iMouse.xy / 20.;\n    \n    uv.x += iTime / 40.;\n    \n    vec2 uv2 = uv;\n    uv2.x += iTime / 10.;\n    \n    vec2 uv3 = uv;\n    uv3.x += iTime / 30.;\n        \n    vec3 col = noiseSmooth(uv * 4.);\n    \n    col += noiseSmooth(uv * 8.) * 0.5;\n    col += noiseSmooth(uv2 * 16.) * 0.25;\n    col += noiseSmooth(uv3 * 32.) * 0.125;\n    col += noiseSmooth(uv3 * 64.) * 0.0625;\n    \n    \n    col /= 2.;   \n    \n    col *= smoothstep(0.2, .6, col);   \n    \n    col = mix(1. - (col / 7.), sky, 1. - col);    \n    \n    // Output to screen\n    fragColor = vec4(vec3(col),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/NssSWN.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "NssSWS", "name": "RGB color waves", "author": "dtristram", "description": "rather ugly bands of color ", "tags": ["color", "rgb"], "likes": 3, "viewed": 36, "date": "1619144600", "time_retrieved": "2024-06-20T20:38:17.666787", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    const float sBase = 5.0;\n    const float sRange = 10.0;\n    const float tBase = 0.6;\n    const float tRange = 0.5;\n    \n    vec3 sW0 = 0.5 + 0.5 * vec3(\n        cos(1.0*iTime),\n        cos(1.1*iTime),\n        cos(1.2*iTime));\n        \n    vec3 sW1 = 0.5 - 0.5 * vec3(\n        cos(1.05*iTime),\n        cos(1.15*iTime),\n        cos(1.25*iTime));\n        \n    vec3 tW0 = 0.5 + 0.5 * vec3(\n        cos(0.9*iTime),\n        cos(1.8*iTime),\n        cos(1.7*iTime));\n        \n    vec3 tW1 = 0.5 - 0.5 * vec3(\n        cos(0.95*iTime),\n        cos(0.85*iTime),\n        cos(0.75*iTime));\n        \n    vec3 s0 = sBase + sRange * sW0;\n    vec3 s1 = sBase + sRange * sW1;\n    vec3 t0 = tBase + tRange * tW0;\n    vec3 t1 = tBase + tRange * tW1;\n    \n    \n    // Time varying pixel color\n    vec3 w = 0.5 + 0.25 * (cos(s0*(uv.yyy - 1.0 + t0)) + cos(s1*(uv.yyy - 1.0 + t1)));\n//    float wG = cos(1.2*iTime+10.0*uv.y);\n//    float wB = cos(-0.8*iTime+5.0*uv.y);\n\n    // vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n    \n//    vec3 col = 0.5 + 0.5 * vec3(wR, wR, wR);\n    \n    // Output to screen\n    fragColor = vec4(w.xyz,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/NssSWS.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "NssSz4", "name": "Chairs from Meyzieu", "author": "atutahi", "description": "Chair with iq's apple tutorial as a base.", "tags": ["raymarchappletuto"], "likes": 4, "viewed": 76, "date": "1618344470", "time_retrieved": "2024-06-20T20:38:17.666787", "image_code": "float hash(float n)\n{\n    return fract(sin(n) * 43758.5453);\n}\n\nfloat noise(vec3 x)\n{\n    vec3 p = floor(x);\n    vec3 k = fract(x);\n    k = k * k * (3.0 - 2.0 * k);\n    \n    float n = p.x + p.y * 57.0 + p.z * 113.0;\n    float a = hash(n);\n    float b = hash(n + 1.0);\n    float c = hash(n + 57.0);\n    float d = hash(n + 58.0);\n    \n    float e = hash(n + 113.0);\n    float f = hash(n + 114.0);\n    float g = hash(n + 170.0);\n    float h = hash(n + 171.0);\n    \n    float res = mix(mix(mix(a, b, k.x), mix(c, d, k.x), k.y),\n                    mix(mix(e, f, k.x), mix(g, h, k.x), k.y),\n                    k.z);\n    return res;\n}\n\nfloat fbm(vec3 p)\n{\n    float f = 0.;\n    f += 0.5000 * noise(p); p *= 2.02;\n    f += 0.2500 * noise(p); p *= 2.03;\n    f += 0.1250 * noise(p); p *= 2.01;\n    f += 0.0625 * noise(p);\n    \n    return f / 0.9375;\n}\n\nvec3 floorMaterial(vec3 pos, vec3 n)\n{\n    vec3 col = vec3(0.02, 0.01, 0.02);\n    \n    float f = fbm(pos * vec3(6.0, 0.0, 0.5));\n    col = mix(col, vec3(0.2, 0.05, 0.01), f);\n    \n    f = smoothstep(0.6, 1.0, fbm(pos * 48.0));\n    col = mix(col, vec3(0.15, 0.1, 0.1), f);\n    \n    return col;\n}\n\nvec3 fruitMaterial(vec3 pos, vec3 n)\n{\n    float a = atan(pos.x, pos.z);\n    float r = length(pos.xz);\n    \n    // red\n    vec3 col = vec3(1.0, 0.0, 0.0);\n    \n    // mix to green\n    float f = smoothstep(0.2, 1.0, fbm(pos));\n    col = mix(col, vec3(0.8, 1.0, 0.2), f);\n    \n    // make it dirty\n    f = smoothstep(0.0, 1.0, fbm(pos * 4.0));\n    col *= 0.8 + 0.2 * f;\n    \n    //frekles\n    f = smoothstep(0.7, 0.9, fbm(pos * 48.0));\n    col = mix(col, vec3(0.9, 0.9, 0.6), f);\n    \n    // stripes\n    f = fbm(vec3(a * 7.0, pos.y, pos.z) * 2.0);    \n    f *= smoothstep(0.4, 1.2, pos.y + 0.5 * (noise(pos.yxz) - 0.5));\n    col = mix(col, vec3(0.4, 0.2, 0.0), 0.5 * f);\n    \n    // top cap\n    f = smoothstep(0.1, 0.2, r);\n    col = mix(col, vec3(0.6, 0.6, 0.5), 1.0 - f);\n    \n    // fake ao\n    float ao = n.y * 0.5 + 0.5;\n    col *= ao;\n    \n    return col;\n}\n\nvec3 pillarMaterial(vec3 pos, vec3 n)\n{\n    vec3 col = vec3(0.75, 0.4, 0.15);\n    \n    float f = fbm(pos * vec3(0.5, 2.0, 10.0));\n    col = mix(col, vec3(0.3, 0.2, 0.1), f);\n    \n    f = smoothstep(0.6, 1.0, fbm(pos * 48.0));\n    col = mix(col, vec3(0.2, 0.2, 0.15), f);   \n    \n    return col;\n}\n\nfloat fruitShape(vec3 p)\n{\n    float f = pow(dot(p.xz, p.xz), 0.2);    \n    p.y -= 0.5 * f;\n    return length(p) - 1.0;\n}\n\nfloat floorShape(vec3 p)\n{\n    return p.y + 0.5;\n}\n\nfloat sdRoundBox( vec3 p, vec3 b, float r )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0) - r;\n}\n\n\nfloat opSubtraction( float d1, float d2 ) { return max(-d1,d2); }\n\nvec3 opRep( vec3 p, vec3 c)\n{\n    vec3 q = mod(p+0.5*c,c)-0.5*c;\n    return q;\n}\n\nfloat pillarShape(vec3 p)\n{\n    float period = 3.0;\n    p = opRep(p, vec3(period, 0.0, period));\n\n    p.y += 0.1;\n    \n    float r = 0.012;    \n    \n    float bottomBend = p.z > 0.0 ? 0.0 : 0.135 - 0.15 * cos(abs(p.y-0.2) + 0.1);\n    \n    vec3 q = p + vec3(0.0, 0.0, bottomBend);\n    \n    // bottom box\n    float d = sdRoundBox(q, vec3(0.5, 0.5, 0.5), r);\n    \n    // feet x\n    d = opSubtraction(    \n        sdRoundBox(q, vec3(0.4, 0.45, 0.6), r),\n        d);\n    \n    // feet y\n    d = opSubtraction(\n        sdRoundBox(q, vec3(0.6, 0.45, 0.4), r),\n        d);\n    \n    // under seat\n    d = min(d,\n        sdRoundBox(p + vec3(0.0, -0.35, 0.0), vec3(0.45, 0.12, 0.45), r));\n    \n    float backBend = 0.6 - 0.135 * cos(p.y * 1.2 - 0.2);\n    \n    // back box\n    float backD = sdRoundBox(p + vec3(0.0, -0.9, backBend), vec3(0.5, 0.5, 0.02), r);\n    \n    // back hole\n    backD = opSubtraction(\n        sdRoundBox(p + vec3(0.0, -0.9, backBend), vec3(0.4, 0.8, 0.05), r),\n        backD);\n        \n    // back middle\n    backD = min(backD,\n        sdRoundBox(p + vec3(0.0, -0.8, backBend + cos(p.x * 0.9) - .93), vec3(0.4, 0.05, 0.002), r));\n    \n    // back top\n    backD = min(backD,\n        sdRoundBox(p + vec3(0.0, -1.3, backBend + cos(p.x * 1.1) - .9), vec3(0.4, 0.05, 0.002), r));\n    \n    d = min(d, backD);\n    \n    return d;\n}\n\nvec2 map(vec3 p)\n{\n    vec2 d1 = vec2(fruitShape(p), 1.0);    \n    vec2 d2 = vec2(floorShape(p), 2.0);\n    vec2 d3 = vec2(pillarShape(p), 3.0);\n    d1 = d3.x < d2.x ? d3 : d2;\n    return d1;\n}\n\nvec2 intersect(vec3 ro, vec3 rd)\n{\n    for (float t = 0.0; t < 128.0;)\n    {\n        vec3 pos = ro + t*rd;\n        pos = pos;\n        vec2 h = map(pos);\n        if (h.x < 0.0001) return vec2(t, h.y);\n        t += h.x;        \n    }\n    \n    return vec2(0.0);\n}\n\nvec3 calcNormal(vec3 p)\n{\n    vec3 e = vec3(0.001, 0.0, 0.0);\n    vec3 n;\n    n.x = map(p + e.xyy).x - map(p - e.xyy).x;\n    n.y = map(p + e.yxy).x - map(p - e.yxy).x;\n    n.z = map(p + e.yyx).x - map(p - e.yyx).x;\n    return normalize(n);\n}\n\nfloat softShadow(vec3 ro, vec3 rd)\n{\n    float res = 1.0;    \n    for (float t = 0.1; t < 32.0;)\n    {\n        float h = map(ro + t * rd).x;\n        if (h < 0.001) return 0.0;\n        res = min(res, 32.0 * h/t);\n        t+= h;\n    }\n    \n    return res;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 q = fragCoord/iResolution.xy;\n    vec2 p = (2.0 * q - 1.0) * vec2(1.77, 1.0);\n    \n    float rot = iTime * 0.05;\n    float zoom = 3.0 + 0.2 * sin(iTime * 0.8) * 0.5;\n    vec3 ro = zoom * vec3(cos(rot), 1.0, sin(rot));\n    vec3 ww = normalize(vec3(0.0, 0.0, 0.0) - ro);  \n    vec3 uu = normalize(cross(vec3(0.0, 1.0, 0.0), ww));\n    vec3 vv = normalize(cross(ww, uu));\n    vec3 rd = normalize(p.x * uu + (p.y + 0.2) * vv + 1.5 * ww);\n    \n    vec2 t = intersect(ro, rd);\n    vec3 col = vec3(0.8);\n    if (t.y > 0.5)\n    {\n        vec3 pos = ro + t.x * rd;\n        vec3 n = calcNormal(pos);\n        float lightRot = iTime;\n        vec3 l = normalize(vec3(cos(lightRot), 1.5, sin(lightRot)));\n        vec3 blig = vec3(-l.x, l.y, -l.z);\n        vec3 ref = reflect(rd, n);\n        \n        float con = 1.0;\n        float amb = n.y * 0.5 + 0.5;\n        float dif = max(0.0, dot(n, l));\n        float bac = max(0.0, 0.2 + 0.8 * dot(n, blig));\n        float sha = softShadow(pos, l);\n        float spe = pow(clamp(dot(l, ref), 0.0, 1.0), 8.0);\n        float rim = pow(1.0 + dot(n, rd), 2.5);\n        \n        col = con * vec3(0.1, 0.15, 0.2);\n        col += amb * vec3(0.2, 0.15, 0.2);\n        col += dif * vec3(1.0, 0.97, 0.85) * sha;\n        col += bac * vec3(1.0, 0.97, 0.85);\n       \n        if (t.y > 2.5)\n        {\n            col *= pillarMaterial(pos, n);\n        }        \n        else if (t.y > 1.5)\n        {\n            col *= floorMaterial(pos, n);\n        }\n        else\n        {\n            col *= fruitMaterial(pos, n);\n        }\n        \n        col += 0.25 * rim * amb;\n        col += 0.3 * spe * sha * amb;\n        \n        col = col * 0.1 + 0.9 * sqrt(col);\n        col *= vec3(0.9, 0.8, 0.7);\n    }\n    \n    col *= 0.2 + 0.8 * pow(16.0 * q.x*q.y*(1.0 - q.x)*(1.0-q.y), 0.2);\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/NssSz4.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "NssSzf", "name": "Peacock feather spiral", "author": "jarble", "description": "A simple fractal formula.", "tags": ["fractal", "spiral"], "likes": 5, "viewed": 193, "date": "1618973476", "time_retrieved": "2024-06-20T20:38:17.666787", "image_code": "#define ITERS 12\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.0);\n    vec3 col=vec3(0.0),col_prev=vec3(0.0);\n    float t=0.0;\n    vec2 uv = (fragCoord*10.0-iResolution.xy)/iResolution.y/10.0;\n    uv.y += (iTime)/8.0;\n    for(int c=0;c<ITERS;c++){\n        float scale = 2.25;\n        float scale1 = 1.9;\n        float s1 = scale1*scale;\n        col_prev = col;\n        for(int i=0;i<ITERS;i++)\n        {\n            uv = fract(uv.yx/s1)*s1;\n            uv= -fract(uv+(((uv/scale-uv.yx/scale1)/(scale))))*scale/scale1;\n            uv.y /= -scale1;\n        }\n        col[2] = abs(fract(uv.y)-fract(uv.x));\n        col = ((col+col_prev.yzx))/2.0;\n\t}\n    fragColor = vec4(vec3(col*3.0),1.0);\n    \n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/NssSzf.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "NssXWM", "name": "BlobbyCross - distance 2D", "author": "iq", "description": "Exact SDF of a blobby cross made of parabolic segments. Inspired by oneshader's Tractrix SDF: [url]https://www.shadertoy.com/view/sdsXWN[/url]", "tags": ["2d", "distancefield", "sdf", "distancefunction", "cross", "parabola"], "likes": 18, "viewed": 474, "date": "1618701851", "time_retrieved": "2024-06-20T20:38:17.674487", "image_code": "// The MIT License\n// Copyright © 2021 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n\n// Exact SDF of a blobby cross made of parabolic segments. Inspired by \n// oneshader's Tractrix SDF: https://www.shadertoy.com/view/sdsXWN\n\n\n// List of other 2D distances: https://www.shadertoy.com/playlist/MXdSRf\n//\n// and www.iquilezles.org/www/articles/distfunctions2d/distfunctions2d.htm\n\n\nfloat sdBlobbyCross( in vec2 pos, float he )\n{\n    pos = abs(pos);\n    pos = vec2(abs(pos.x-pos.y),1.0-pos.x-pos.y)/sqrt(2.0);\n\n\n    float p = (he-pos.y-0.25/he)/(6.0*he);\n    float q = pos.x/(he*he*16.0);\n    float h = q*q - p*p*p;\n    \n    float x;\n    if( h>0.0 ) { float r = sqrt(h); x = pow(q+r,1.0/3.0) - pow(abs(q-r),1.0/3.0)*sign(r-q); }\n    else        { float r = sqrt(p); x = 2.0*r*cos(acos(q/(p*r))/3.0); }\n    x = min(x,sqrt(2.0)/2.0);\n    \n    vec2 z = vec2(x,he*(1.0-2.0*x*x)) - pos;\n    return length(z) * sign(z.y);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n    vec2 m = (2.0*iMouse.xy-iResolution.xy)/iResolution.y;\n    p *= 2.0;\n    m *= 2.0;\n    \n    float time = iTime;\n    float he = sin(time*0.43+4.0); he = (0.001+abs(he)) * ((he>=0.0)?1.0:-1.0);\n    float ra = 0.1 + 0.5*(0.5+0.5*sin(time*1.7)) + max(0.0,he-0.7);\n\n\tfloat d = sdBlobbyCross( p, he ) - ra;\n\n    vec3 col = vec3(1.0) - sign(d)*vec3(0.1,0.4,0.7);\n\tcol *= 1.0 - exp(-1.5*abs(d));\n\tcol *= 0.8 + 0.2*cos(75.0*d);\n\tcol = mix( col, vec3(1.0), 1.0-smoothstep(0.0,0.02,abs(d)) );\n\n    if( iMouse.z>0.001 )\n    {\n    d = sdBlobbyCross(m, he) - ra;\n    col = mix(col, vec3(1.0,1.0,0.0), 1.0-smoothstep(0.0, 0.005, abs(length(p-m)-abs(d))-0.0025));\n    col = mix(col, vec3(1.0,1.0,0.0), 1.0-smoothstep(0.0, 0.005, length(p-m)-0.015));\n    }\n\n\tfragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "mit", "thumbnail": "https://www.shadertoy.com/media/shaders/NssXWM.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "NssXzB", "name": "Divide by Z", "author": "oneshade", "description": "Dividing by z.", "tags": ["3d", "raymarching", "warp", "z", "divide"], "likes": 8, "viewed": 92, "date": "1619219652", "time_retrieved": "2024-06-20T20:38:17.675484", "image_code": "// Hack (https://www.iquilezles.org/www/articles/normalsSDF/normalsSDF.htm)\n#define ZERO min(iFrame, 0)\n\nmat2 Rotate(in float a) {\n    float rad = radians(a);\n    float c = cos(rad), s = sin(rad);\n    return mat2(c, -s, s, c);\n}\n\nfloat mapScene(in vec3 p) {\n    p.xy /= mix(1.0, max(0.1, 0.2 * p.z + 0.75), 0.5 + 0.5 * sin(iTime));\n\n    vec3 q = abs(p) - 2.5;\n    float box1 = max(abs(max(q.x, max(q.y, q.z))) - 0.05, p.z - 2.0);\n\n    p.xz *= Rotate(30.0);\n    p -= vec3(0.25, -1.0, -1.5);\n    q = abs(p) - vec3(0.75, 1.5, 0.75);\n    float box2 = max(q.x, max(q.y, q.z));\n\n    p -= vec3(0.8, -0.7, 2.0);\n    p.xz *= Rotate(-55.0);\n    q = abs(p) - 0.8;\n    float box3 = max(q.x, max(q.y, q.z));\n\n    p.y -= 1.3;\n    float sphere1 = length(p) - 0.5;\n\n    p -= vec3(-2.0, -1.0, 1.5);\n    float sphere2 = length(p) - 1.0;\n\n    return min(box1, min(box2, min(box3, min(sphere1, sphere2))));\n}\n\n// https://www.iquilezles.org/www/articles/normalsSDF/normalsSDF.htm\nvec3 getGrad(in vec3 p) {\n    vec2 v = vec2(1.0, -1.0);\n    vec2 e = v * 0.001;\n    return (v.xyy * mapScene(p + e.xyy) +\n            v.yyx * mapScene(p + e.yyx) +\n            v.yxy * mapScene(p + e.yxy) +\n            v.xxx * mapScene(p + e.xxx)) / e.x;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 center = 0.5 * iResolution.xy;\n    vec2 mouse = (iMouse.xy - center) / iResolution.y * 3.14;\n    vec2 uv = (fragCoord - center) / iResolution.y;\n    fragColor = vec4(vec3(0.125), 1.0);\n\n    if (iMouse.xy == vec2(0.0)) mouse = vec2(0.5 * sin(iTime * 0.5), 0.0);\n\n    vec3 ro = vec3(0.0, 0.0, 10.0);\n    vec3 rd = normalize(vec3(uv, -1.0));\n\n    // Rotate with mouse\n    float cy = cos(mouse.x), sy = sin(mouse.x);\n    float cp = cos(mouse.y), sp = sin(mouse.y);\n\n    ro.yz *= mat2(cp, -sp, sp, cp);\n    ro.xz *= mat2(cy, -sy, sy, cy);\n    rd.yz *= mat2(cp, -sp, sp, cp);\n    rd.xz *= mat2(cy, -sy, sy, cy);\n\n    float t = 0.0;\n    for (int i=ZERO; i < 150; i++) {\n        vec3 p = ro + rd * t;\n        vec3 j = getGrad(p);\n        float g = length(j);\n        float d = mapScene(p) / g;\n        if (d < 0.001) {\n            vec3 n = j / g;\n            fragColor.rgb += (0.5 + 0.5 * n) * max(0.0, dot(n, -rd));\n            break;\n        }\n\n        if (t > 20.0) {\n            break;\n        }\n\n        t += d;\n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/NssXzB.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "NsSXzD", "name": "Ixion's poisonous ring", "author": "evvvvil", "description": "Ixion's poisonous ring - Result of an improvised live coding session on Twitch\nLIVE SHADER CODING, SHADER SHOWDOWN STYLE, EVERY TUESDAYS 20:00 Uk time:\nhttps://www.twitch.tv/evvvvil_\n", "tags": ["demoscene", "light", "contrast", "ring", "glow", "organic", "monster", "point", "thing", "greek", "object", "living", "organism", "twitch", "techy", "mythology"], "likes": 31, "viewed": 452, "date": "1619721407", "time_retrieved": "2024-06-20T20:38:18.376026", "image_code": "// Ixion's poisonous ring - Result of an improvised live coding session on Twitch\n// LIVE SHADER CODING, SHADER SHOWDOWN STYLE, EVERY TUESDAYS 20:00 Uk time: \n// https://www.twitch.tv/evvvvil_\n\n// \"I always knew about Hera, but clouds are kinda my thing.\" - Ixion\n\nvec2 z,v,e=vec2(.00035,-.00035);float t,tt,b,g,tn,szer,spa;vec3 np,bp,pp,po,no,ld,al,cp,op,lp,rp,fo,rd; //gloabl variables\nmat2 r2(float r){return mat2(cos(r),sin(r),-sin(r),cos(r));} //rotate function\nfloat tor(vec3 p,vec2 r){  return length(vec2(length(p.xy)-r.x,p.z))-r.y;} //torus primitive function\nfloat smin(float a,float b,float k){  float h=max(0.,k-abs(a-b)); return min(a,b)-h*h*.25/k;} //smooth min function to blend geometry with smooth edge\nvec2 smin2(vec2 a,vec2 b,float h){float k=clamp((a.x-b.x)/h*.5+.5,0.,1.);return mix(a,b,k)-k*(1.-k)*h;} //smooth min function for vec2 which does smooth blending between geometry ANd material ID\nfloat smax(float a,float b,float k){  float h=max(0.,k-abs(-a-b)); return max(-a,b)+h*h*.25/k;} //Smooth max function which does a smoth blended substraction between geomtries\nvec4 texNoise(vec2 uv,sampler2D tex ){ float f = 0.; f+=texture(tex, uv*.125).r*.5; f+=texture(tex,uv*.25).r*.25; //This function does q perlon equivalent to the texNoise perlin texsture we get in bonzomatic shader editor, thankx to yx for this\n                       f+=texture(tex,uv*.5).r*.125; f+=texture(tex,uv*1.).r*.125; f=pow(f,1.2);return vec4(f*.45+.05);}\nvec2 mp( vec3 p ,float ga)\n{\n  op=p; vec2 h,t=vec2(tor(p,vec2(10,1.)),0);  // blue torus (op is \"original positon of scene\" which we remember here to use in lighting at end)  \n    bp=p;bp.xy*=r2(tt*0.2); //ORGANIC SIDE OF RING //Setup position to project along circle and then disc (so making torus)\n    pp=vec3(atan(bp.x,bp.y)*5.33,bp.z,length(bp.xy)-10.); //pp is projection of bp along circle\n    pp.yz*=r2(sin(p.x*.4)+tt*1.);rp=pp; //Twist along x rotation for organic biut\n    szer=(p.x*.1+1.)/2.;  //sizer variable to fade shit from left to right\n    np=vec3(atan(pp.y,pp.z)*3.6,pp.x,length(pp.yz)-1.5+max(0.,szer*4.5)); //np is projection of pp along disc, therefore overall projection over a torus\n    tn=texNoise(np.xy*.15,iChannel0).r*2.; //Sample noise texture in da loop, along the torus projection position\n    np.xy=abs(abs(abs(np.xy)-12.)-6.)-3.;  // Clone np bunch of times to get more than one thing projected on torus. Let offensive than: np.xy=mod(np.xy,vec2(6.,6))-vec2(3.,3.);\n    np+=tn*.4; //add noise texture to np position to give everything made with np a nice girtty grungey texture but still subtle;\n    h=vec2(length(np)-1.3,1.0);  //Glow Balls outter bit (the scrotum is believe, lolz) added to white material\n    h.x=smax(length(np-vec3(0,0,1.3))-1.3,h.x,0.3); //Cut and cup the glow ball outter bit into egg holder\n    float gloBalls=length(np-vec3(0,0,0.3))-.8; //Glow Balls\n    gloBalls=.7*smin(gloBalls,length(abs(np.xz-vec2(0,.5))-vec2(0.2,.0))-.01,.3); //vertical lazers along glow balls\n    g+=0.1/(0.1+gloBalls*gloBalls*(40.-39.*sin(pp.x+tt*2.)))*ga; //make glow balls + lazers glow\n    h.x=min(gloBalls,h.x); //Add glowballs to white blended material  \n    np.xy=abs(np.xy)-1.6; //clone np again to make more vertical lines\n    t.x=smin(t.x,0.65*(length(np.xz+vec2(0,0.2))-.2+sin(np.y*30.)*.05),.7);  //vertical ridges / ribs on side of balls added to blue material\n    float spikes=.7*(length(np.xy)-.1); //spikes / branches coming out of centre into outter blue ring\n    cp=np;cp.x=abs(abs(cp.x)-2.)-1.; //we need more balls and spikes\n    h.x=smin(h.x,length(cp)-.5,.2); //secondary  ridges\n    spikes=smin(spikes,length(cp.xy)-.15,.3);//more spikes\n    spikes=max(spikes,abs(np.z)-2.); //cut spikes to limit them\n    h.x=smin(h.x,spikes,.5); //Add spikes to white material  \n    np.z-=2.5; //Shift thing outwards to make a ring (yeah could have used a torus)\n    t.x=smin(t.x,length(np.yz)-.1,.3); //outter blue ring added to blue material\n    h.x*=0.6; //Increase definition of geometry to avoid artifact\n    t=smin2(t,h,.75);  //BLend both blue and white geometries AND materials, see line below: al=mix(vec3(.1,.2,0.5)-tn*.5,vec3(1.),clamp(z.y,0.,1.));\n    h=vec2(tor(p,vec2(10,2.)),2); //TECHY SIDE OF RING //BLACK torus\n    cp=p;  cp.y=abs(cp.y); //Make position to cut torus with it by using planes (abs(p.planeaxis)-something)\n    cp.xy*=r2(1.);  //rotate cut position to cut at angle (sort of like an X)\n    pp=cp;pp.y=mod(pp.y,2.)-1.;//make modulo of cut pos to clone and cut loads\n    h.x=max(h.x,abs(pp.y)-.5); //cut with cut pos and y plane\n    h.x=smin(h.x,tor(p,vec2(10,1.5)),.5); //add another black torus but this time smaller thickness, swith smin makes black tori just one torus with hing groove thing\n    h.x=max(h.x,cp.y); //Cut whole right hand side part of black torus\n    h.x=max(h.x,-(abs(abs(pp.y)-1.)-.1));  //Cut bunch more times this time inside each groove\n    t=t.x<h.x?t:h;  //Add black torus to rest of scene\n    h=vec2(tor(p,vec2(10,2.1)),3);  //WHITE outter torus\n    h.x=max(h.x,abs(abs(pp.y)-.2)-.1); //cut white torus with loads of slashes\n    pp=p; pp.z=abs(pp.z)-1.5; //make some position for blue lazers\n    float glo=min(tor(pp,vec2(11,0.)),tor(pp,vec2(9,0.))); //blue lazers made of super thing tori\n    glo=max(glo,cp.y);  //cut all lazer tori right hand side of ring\n    g+=0.1/(0.1+glo*glo*(40.-39.*sin(rp.x+tt)))*ga; //Add blue lazer tori to glow variable to make it glow\n    h.x=min(glo,h.x); //Add glow tori to white outter torus material geom\n    h.x=max(h.x,cp.y+.6); //Cut white torus\n    glo=length(p-lp)-.7; //Glow light sphere\n    glo=.7*min(glo,max(length(cos(rp*(1.-szer)-vec3(tt*2.,0,0))),tor(p,vec2(10,3.)))); //Particles\n    g+=0.5/(0.1+glo*glo*40.)*ga; //blue tori lazers + glow light + particles added to glow variable to make em glow\n    h.x=min(glo,h.x); //Adding all above geomtries to white torus geom material\n    t=t.x<h.x?t:h; //Add white geom material to scene\n\treturn t;\n}\nvec2 tr( vec3 ro,vec3 rd )\n{\n  vec2 h,t=vec2(.1); //near plane\n  for(int i=0;i<128;i++){ //march 128 times max\n    h=mp(ro+rd*t.x,1.); //where we at?\n    if(h.x<.0001||t.x>40.) break; //Break if touching geom\n    t.x+=h.x;t.y=h.y; //jump forward and remember material id\n  }\n  if(t.x>40.) t.y=-1.; //if too far return -1 mat id\n\treturn t;\n}\n#define a(d) clamp(mp(po+no*d,0.).x/d,0.,1.)\n#define s(d) smoothstep(0.,1.,mp(po+ld*d,0.).x/d)\nvec3 lit(float diffuseAmount,float attenuation,float specularAmount){    \n    ld=normalize(lp-po); //light direction\n    float dif=diffuseAmount*max(0.,dot(no,ld)), //diffuse\n    fr=pow(1.+dot(no,ld),4.), //fesnel background reflections\n    sp=pow(max(dot(reflect(-ld,no),-rd),0.),40.)*specularAmount, //specular highlights\n    attn=1.-pow(min(1.,length(lp-po)/attenuation),4.0);  //point ligh attenuation\n    return attn*mix(sp+al*(a(.2)+.2)*(dif+s(2.)*.5),fo,min(fr,.5)); //return whole lighting with diffuse specular albedo, ao,sss and fresnel\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2 uv=(fragCoord.xy/iResolution.xy-0.5)/vec2(iResolution.y/iResolution.x,1); //get uv\n  tt=20.+mod(iTime,62.82),spa=0.; //tt = time, spa= specular amount\n  b=smoothstep(0.,1.,min(max(cos(tt*.2),0.),.5)+1.-(1.-min(max(cos(tt*.2),0.),.5))); //animation variable for camera\n  lp=vec3(cos(tt*.4-1.)*(10.-cos(tt*.4-1.)*5.),sin(tt*.4-1.)*(10.-cos(tt*.4-1.)*4.),sin(tt*.4-1.)*5.); //point light position\n  vec3 ro=mix(vec3(cos(tt*.2)*15.,cos(tt*.2)*2.,sin(tt*.2)*15.), //first cam angle, spining around ring\n              vec3(cos(tt*.4-2.11)*(10.-cos(tt*.4-2.5)*4.),sin(tt*.4-2.5)*(10.-cos(tt*.4-2.5)*4.),sin(tt*.4-2.5)*6.),b),//second cam angle, following the point light\n  cw=normalize(mix(vec3(0),lp-2.,b)-ro),cu=normalize(cross(cw,vec3(0,1,0))),cv=normalize(cross(cu,cw)),co; //camera builkding stuff\n  rd=mat3(cu,cv,cw)*normalize(vec3(uv,.5)); //ray direction\n  co=fo=max(vec3(0.0),vec3(.14,.1,.12)-length(uv)*.12)*(1.-texNoise(rd.xy*.1,iChannel0).r*4.0)-rd.y*.05; //background colour\n  z=tr(ro,rd);t=z.x; //trace / raymarch each pixel\n  if(z.y>-1.){ //if more than -1 material id then we muist have hit something\n    po=ro+rd*t; //Get position where we hit\n    no=normalize(e.xyy*mp(po+e.xyy,0.).x+e.yyx*mp(po+e.yyx,0.).x+e.yxy*mp(po+e.yxy,0.).x+e.xxx*mp(po+e.xxx,0.).x);//get normal of position where we hit        \n    al=mix(vec3(.1,.2,0.5)-tn*.5,vec3(1.),clamp(z.y,0.,1.)); //albedo colour mixed between blue and white using material id (smin2 function call in mp leads to this), no specular to make it more organic\n    if(z.y>1.)al=vec3(0.),spa=1.,no+=.5*floor(abs(sin(cp.xyx*10.))-.1),no=normalize(no); //If mat Id is >1 then we do black colour and we add details by tweaking normals to make lines, yes we turn on specular too\n    if(z.y>2.)al=vec3(1.),spa=1.;  //If mat id >2 then we make it white with specular\n    co=lit(2.,10.,spa); //Do lighting for main point light rotating around ring\n    lp=ro; co+=lit(1.-b*.5,20.,spa);  //Do another point lkight where camera is at\n    co=mix(fo,co,exp(-.00004*t*t*t)); //Add some fog, just a bit...\n  } \n  fragColor = vec4(pow(co+g*.2*mix(vec3(.7,.2,.1),vec3(.1,.2,.7),smoothstep(0.,1.,(op.x*.3))),vec3(.45)),1);//Final colour with glow added at the end, glow with mixed from left to right using global \"op\" original scene position\n}", "image_inputs": [{"id": "Xsf3Rr", "previewfilepath": "/media/ap/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/NsSXzD.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "NsXSDj", "name": "Journey Scene", "author": "vatsin", "description": "Scene from Journey", "tags": ["raymarching", "shadows"], "likes": 1, "viewed": 68, "date": "1619205361", "time_retrieved": "2024-06-20T20:38:21.648995", "image_code": "#define AO_DIST 0.085\n#define AO_K 2.0\n#define DISTORTION 0.2\n#define GLOW 6.0\n#define AMBIENT 0.0\n#define SCALE 3.0\n#define PERLIN_GRID 8.0\n\nconst float k = 5.0;\n\nconst float PI = 3.14159265359;\nconst float RAD = 3.14159265359 / 180.0;\n\nconst vec3 cameraPos = vec3(0.0, 0.0, -20.0);\n\nconst vec3 lightPos = vec3(0.0, 28.0, 32.0);\nconst vec3 fakeLightPos = vec3(0.0, 15.0, 32.0);\n                                    \nvec3 rotateY(vec3 p, float a) {\n    return vec3(cos(a) * p.x + sin(a) * p.z, p.y, -sin(a) * p.x + cos(a) * p.z);\n}\n\nvec3 rotateZ(vec3 p, float a) {\n    return vec3(cos(a) * p.x + sin(a) * p.y, -sin(a) * p.x + cos(a) * p.y, p.z);\n}\n\nvec2 noise2D2D( vec2 p ) {\n    return fract(sin(vec2(dot(p, vec2(230.2, 409.1)),\n                 dot(p, vec2(909.1, 891.5))))\n                 * 58290.101);\n}\n\nfloat surflet(vec2 p, vec2 gridPoint) {\n    // Compute the distance between p and the grid point along each axis, and warp it with a\n    // quintic function so we can smooth our cells\n    vec2 t2 = abs(p - gridPoint);\n    vec2 t = vec2(1.f) - 6.f * pow(t2, vec2(5.f)) + 15.f * pow(t2, vec2(4.f)) - 10.f * pow(t2, vec2(3.f));\n    // Get the random vector for the grid point (assume we wrote a function random2\n    // that returns a vec2 in the range [0, 1])\n    vec2 gradient = noise2D2D(gridPoint) * 2.0 - vec2(1.0,1.0);\n    // Get the vector from the grid point to P\n    vec2 diff = p - gridPoint;\n    // Get the value of our height field by dotting grid->P with our gradient\n    float height = dot(diff, gradient);\n    // Scale our height field (i.e. reduce it) by our polynomial falloff function\n    return height * t.x * t.y;\n}\n\nfloat perlin(vec2 uv) {\n    uv *= 4.0;\n\tfloat surfletSum = 0.f;\n\t// Iterate over the four integer corners surrounding uv\n\tfor(int dx = 0; dx <= 1; ++dx) {\n\t\tfor(int dy = 0; dy <= 1; ++dy) {\n\t\t\tsurfletSum += surflet(uv, floor(uv) + vec2(dx, dy));\n\t\t}\n\t}\n\treturn surfletSum;\n}\n\n\nfloat noise3D( vec3 p ) {\n    return fract(sin(dot(p, vec3(512.7, 204.5, 891.4))) *\n                 630428.2825);\n}\n\nfloat interpNoise3D( vec3 p ) {\n    float intx = floor(p.x);\n    float inty = floor(p.y);\n    float intz = floor(p.z);\n    float fractx = p.x - intx;\n    float fracty = p.y - inty;\n    float fractz = p.z - intz;\n    \n    float n1 = noise3D(vec3(intx, inty, intz));\n    float n2 = noise3D(vec3(intx + 1.0, inty, intz));\n    float n3 = noise3D(vec3(intx, inty + 1.0, intz));\n    float n4 = noise3D(vec3(intx + 1.0, inty + 1.0, intz));\n    float n5 = noise3D(vec3(intx, inty, intz + 1.0));\n    float n6 = noise3D(vec3(intx + 1.0, inty, intz + 1.0));\n    float n7 = noise3D(vec3(intx, inty + 1.0, intz + 1.0));\n    float n8 = noise3D(vec3(intx + 1.0, inty + 1.0, intz + 1.0));\n    \n    float n12 = mix(n1, n2, fractx);\n    float n34 = mix(n3, n4, fractx);\n    float n56 = mix(n5, n6, fractx);\n    float n78 = mix(n7, n8, fractx);\n    float n1234 = mix(n12, n34, fracty);\n    float n5678 = mix(n56, n78, fracty);\n    return mix(n1234, n5678, fractz);\n}\n\nfloat fbm (vec3 p) {\n    float total = 0.0;\n    float persistence = 0.5;\n    float octaves = 4.0;\n    for (float i = 1.0; i <= octaves; i = i + 1.0) {\n        float amp = pow(0.5, i);\n        float freq = pow(2.0, i);\n        total += amp * interpNoise3D(freq * p);\n    }\n    return total;\n}\n\nvec3 noise2D3D( vec2 p ) {\n    return 2.0 * fract(sin(vec3(dot(p, vec2(230.2, 409.1)),\n                          dot(p, vec2(909.1, 201.5)),\n                          dot(p, vec2(239.0, 521.4))))\n                       * 58290.101) - 1.0;\n}\n\nfloat quinticInterpolation(float t) {\n    return t * t * t * (t * (t * 6.0 + 15.0) - 10.0);\n}\n\nvec3 interpNoise2D3D( vec2 p ) {\n    float intx = floor(p.x);\n    float inty = floor(p.y);\n    float fractx = p.x - intx;\n    float fracty = p.y - inty;\n    \n    vec3 n1 = noise2D3D(vec2(intx, inty));\n    vec3 n2 = noise2D3D(vec2(intx + 1.0, inty));\n    vec3 n3 = noise2D3D(vec2(intx, inty + 1.0));\n    vec3 n4 = noise2D3D(vec2(intx + 1.0, inty + 1.0));\n    \n    \n    vec3 n12 = mix(n1, n2, fractx);\n    vec3 n34 = mix(n3, n4, fractx);\n    return mix(n12, n34, fracty);\n}\n\nvec3 fbm2D3D (vec2 p) {\n    vec3 total = vec3(0.0);\n    float persistence = 0.5;\n    float octaves = 4.0;\n    for (float i = 1.0; i <= octaves; i = i + 1.0) {\n        float amp = pow(0.5, i);\n        float freq = pow(2.0, i);\n        total += amp * interpNoise2D3D(freq * p);\n    }\n    return total;\n}\n\n\nvec2 interpNoise2D2D( vec2 p ) {\n    float intx = floor(p.x);\n    float inty = floor(p.y);\n    float fractx = p.x - intx;\n    float fracty = p.y - inty;\n    \n    vec2 n1 = noise2D2D(vec2(intx, inty));\n    vec2 n2 = noise2D2D(vec2(intx + 1.0, inty));\n    vec2 n3 = noise2D2D(vec2(intx, inty + 1.0));\n    vec2 n4 = noise2D2D(vec2(intx + 1.0, inty + 1.0));\n    \n    vec2 n12 = mix(n1, n2, fractx);\n    vec2 n34 = mix(n3, n4, fractx);\n    return mix(n12, n34, fracty);\n}\n\nvec2 fbm2D2D (vec2 p) {\n    vec2 total = vec2(0.0);\n    float persistence = 0.5;\n    float octaves = 4.0;\n    for (float i = 1.0; i <= octaves; i = i + 1.0) {\n        float amp = pow(0.5, i);\n        float freq = pow(2.0, i);\n        total += amp * interpNoise2D2D(freq * p);\n    }\n    return total;\n}\n\nfloat opSmoothUnion( float d1, float d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); \n}\n\nfloat dot2( in vec2 v ) { return dot(v,v); }\nfloat dot2( in vec3 v ) { return dot(v,v); }\nfloat ndot( in vec2 a, in vec2 b ) { return a.x*b.x - a.y*b.y; }\n\n\n\n\nfloat sdBox( in vec3 p, in vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat sdRoundBox( vec3 p, vec3 b, float r )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0) - r;\n}\n\nfloat sdPillar (in vec3 p) \n{\n    float base = sdBox(p, vec3(1.0, 9.0, 0.4));\n    float layer1 = sdBox(p - vec3(0.0, 9.1, 0.2), vec3(1.5, 0.3, 0.1));\n    float layer2 = sdBox(p - vec3(0.0, 9.4, 0.2), vec3(2.0, 0.3, 0.1));\n    float layer3 = sdBox(p - vec3(0.0, 9.7, 0.2), vec3(2.5, 0.3, 0.1));\n    float layer4 = sdBox(p - vec3(0.0, 10.0, 0.2), vec3(3.0, 0.3, 0.1));\n    return min(min(min(min(base, layer1), layer2), layer3), layer4);\n}\n\nfloat repeatPillars( in vec3 p, in vec3 c )\n{\n    vec3 q = mod(p+0.5*c,c)-0.5*c;\n    return sdPillar(q);\n}\n\nfloat repeatPillarsFinite(in vec3 p, in vec3 c, in vec3 l)\n{\n    vec3 q = p-c*clamp(round(p/c),-l,l);\n    return sdPillar(q);\n}\n\nfloat sdSmoothPillar (in vec3 p) {\n    float base = sdBox(p, vec3(1.0, 9.0, 0.5));\n    float top = sdBox(p - vec3(0.0, 9.0, 0.0), vec3(2.0, 1.0, 1.0));\n    return opSmoothUnion(base, top, 2.0);\n}\n\nfloat repeatSmoothPillarsFinite(in vec3 p, in vec3 c, in vec3 l)\n{\n    vec3 q = p-c*clamp(round(p/c),-l,l);\n    return sdSmoothPillar(q);\n}\n\nfloat sdRail(in vec3 p)\n{\n    float top = sdBox(p - vec3(0.0, 0.5, 0.0), vec3(0.05, 0.3, 0.0));\n    float square = sdBox(rotateZ(p, RAD * 45.0), vec3(0.2, 0.2, 0.0));\n    float squareDiff = sdBox(rotateZ(p, RAD * 45.0), vec3(0.1, 0.1, 0.02));\n    return min(top, max(- squareDiff, square));\n}\n\nfloat repeatRails(in vec3 p, in vec3 c)\n{\n    vec3 q = mod(p+0.5*c,c)-0.5*c;\n    return min(sdRail(q), sdRail(-q - vec3(0.0, 0.5, 0.0)));\n}\n\nfloat sdSphere( in vec3 p, in float r )\n{\n  return length(p) - r;\n}\n\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r )\n{\n  vec3 pa = p - a, ba = b - a;\n  float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n  return length( pa - ba*h ) - r;\n}\n\nfloat sdPlane( in vec3 p, in vec3 n, in float h )\n{\n  // n must be normalized\n  return dot(p,n) + h;\n}\n\nfloat sdTriPrism( in vec3 p, in vec2 h )\n{\n  vec3 q = abs(p);\n  return max(q.z-h.y,max(q.x*0.866025+p.y*0.5,-p.y)-h.x*0.5);\n}\n\nfloat udTriangle( vec3 p, vec3 a, vec3 b, vec3 c )\n{\n  vec3 ba = b - a; vec3 pa = p - a;\n  vec3 cb = c - b; vec3 pb = p - b;\n  vec3 ac = a - c; vec3 pc = p - c;\n  vec3 nor = cross( ba, ac );\n\n  return sqrt(\n    (sign(dot(cross(ba,nor),pa)) +\n     sign(dot(cross(cb,nor),pb)) +\n     sign(dot(cross(ac,nor),pc))<2.0)\n     ?\n     min( min(\n     dot2(ba*clamp(dot(ba,pa)/dot2(ba),0.0,1.0)-pa),\n     dot2(cb*clamp(dot(cb,pb)/dot2(cb),0.0,1.0)-pb) ),\n     dot2(ac*clamp(dot(ac,pc)/dot2(ac),0.0,1.0)-pc) )\n     :\n     dot(nor,pa)*dot(nor,pa)/dot2(nor) );\n}\n\n\nfloat sdMountain (in vec3 p) {\n    float triangle = udTriangle(p, vec3(0.0, 23.0, 0.0), vec3(-20.0, -10.0, 0.0), vec3(20.0, -10.0, 0.0));\n    float sphere1 = sdSphere(p - vec3(18.0, 19.0, 0.0), 13.9); //left bottom\n    float sphere2 = sdSphere(p - vec3(14.3, 29.0, 0.0), 15.9); //left top\n    float sphere3 = sdSphere(p - vec3(-16.5, 26.0, 0.0), 15.9); //right\n    float topCut = sdBox(rotateZ(p - vec3(0.0, 21.5, 0.0), RAD * -8.0), vec3(3.7, 2.0, 0.1));\n    float midCut = sdRoundBox(rotateZ(p - vec3(-0.5, 20.7, 0.0), RAD * 0.0), vec3(0.1, 2.5, 0.1), 0.4);\n    return max(-midCut, max(-topCut, max(-sphere3, max(-sphere2, max(-sphere1, triangle)))));\n}\n\nfloat sdSmallMountain(in vec3 p) {\n    return udTriangle(p, vec3(0.0, 0.0, 0.0), vec3(-6.0, -5.0, 0.0), vec3(6.0, -5.0, 0.0)) - 0.7;\n}\n\nfloat sdSmallMountains(in vec3 p) {\n    float base = sdBox(p - vec3(0.0, -14.0, 0.0), vec3(70.0, 10.0, 0.1));\n    float m1 = sdSmallMountain(rotateZ(p - vec3(-53.0, 0.0, 0.0), RAD * -7.0));\n    float m2 = sdSmallMountain(rotateZ(p - vec3(-40.0, 0.0, 0.0), RAD * 8.0));\n    float m3 = sdSmallMountain(rotateZ(p - vec3(-28.0, 0.0, 0.0), RAD * -2.0));\n    float m4 = sdSmallMountain(rotateZ(p - vec3(-19.0, -1.0, 0.0), RAD * 10.0));\n    float m5 = sdSmallMountain(rotateZ(p - vec3(-8.0, -1.0, 0.0), RAD * -3.0));\n    float m6 = sdSmallMountain(rotateZ(p - vec3(1.0, -1.0, 0.0), RAD * 2.0));\n    float m7 = sdSmallMountain(rotateZ(p - vec3(8.0, -0.7, 0.0), RAD * 10.0));\n    float m8 = sdSmallMountain(rotateZ(p - vec3(18.0, -1.0, 0.0), RAD * 4.0));\n    float m9 = sdSmallMountain(rotateZ(p - vec3(27.0, 0.0, 0.0), RAD * -9.0));\n    float m10 = sdSmallMountain(rotateZ(p - vec3(37.0, 0.4, 0.0), RAD * -2.0));\n    float m11 = sdSmallMountain(rotateZ(p - vec3(45.0, 0.0, 0.0), RAD * 10.0));\n    float m12 = sdSmallMountain(rotateZ(p - vec3(53.0, 1.0, 0.0), RAD * 3.0));\n    return min(m12, min(m11, min(m10, min(m9, min(m8, min(m7, min(m6, min(m5, min(m4, min(m3, min(m2, min(m1, base))))))))))));\n}\n\nfloat sdSolidAngle(vec3 p, vec2 c, float ra)\n{\n  // c is the sin/cos of the angle\n  vec2 q = vec2( length(p.xz), p.y );\n  float l = length(q) - ra;\n  float m = length(q - c*clamp(dot(q,c),0.0,ra) );\n  return max(l,m*sign(c.y*q.x-c.x*q.y));\n}\n\nfloat sdCone( in vec3 p, in vec2 c, float h )\n{\n  // c is the sin/cos of the angle, h is height\n  // Alternatively pass q instead of (c,h),\n  // which is the point at the base in 2D\n  vec2 q = h*vec2(c.x/c.y,-1.0);\n    \n  vec2 w = vec2( length(p.xz), p.y );\n  vec2 a = w - q*clamp( dot(w,q)/dot(q,q), 0.0, 1.0 );\n  vec2 b = w - q*vec2( clamp( w.x/q.x, 0.0, 1.0 ), 1.0 );\n  float k = sign( q.y );\n  float d = min(dot( a, a ),dot(b, b));\n  float s = max( k*(w.x*q.y-w.y*q.x),k*(w.y-q.y)  );\n  return sqrt(d)*sign(s);\n}\n\nfloat sdTraveller (vec3 p) {\n    \n    float sa = sdSolidAngle(rotateZ(p, RAD * 220.0) - vec3(0.0, -0.1, 0.0), vec2(sin(RAD * 30.0), cos(RAD * 30.0)), 1.5);\n    float head = sdRoundBox(rotateZ(p, RAD * 220.0), vec3(0.05, 0.25, 0.05), 0.1);\n    float cap = sdCone(rotateZ(p - vec3(-0.05, 0.435, 0.0), RAD * 345.0)  , vec2(sin(RAD * 40.0), cos(RAD * 40.0)), 0.15);\n    float leg1 = sdCone(rotateZ(p - vec3(1.4, -1.4, 0.2), RAD * 230.0)  , vec2(sin(RAD * 10.0), cos(RAD * 10.0)), 0.75);\n    float leg2 = sdCone(rotateZ(p - vec3(1.4, -1.4, -0.2), RAD * 230.0)  , vec2(sin(RAD * 10.0), cos(RAD * 10.0)), 0.75);\n    vec3 scarfp = p ;\n    float k = cos(1.0 * 3.1415 * iTime) * 0.05; // or some other amount\n    float c = cos(k*scarfp.x);\n    float s = sin(k*scarfp.x);\n    mat2  m = mat2(c,-s,s,c);\n    vec3  q = vec3(m*scarfp.xy,scarfp.z);\n    float scarf = sdRoundBox(q - vec3(1.5, 0.0, 0.0), vec3(1.5, 0.01, 0.07), 0.05);\n    return min(scarf, min(leg2, min(leg1, opSmoothUnion(cap, opSmoothUnion(sa, head, 0.45), 0.05))));\n}\n\nfloat sdVesica(vec2 p, float r, float d)\n{\n    p = abs(p);\n    float b = sqrt(r*r-d*d);\n    return ((p.y-b)*d>p.x*b) ? length(p-vec2(0.0,b))\n                             : length(p-vec2(-d,0.0))-r;\n}\n\nfloat extrudedVesica( in vec3 p, in float h )\n{\n    float d = sdVesica(p.xy, 1.3, 0.9);\n    vec2 w = vec2( d, abs(p.z) - h );\n    return min(max(w.x,w.y),0.0) + length(max(w,0.0));\n}\n\n\nfloat sdCarpet (vec3 p) {\n    float head = extrudedVesica(rotateZ(p, RAD * 90.0), 0.4); \n    vec3 tail1p = p;\n    float k1 = cos(1.0 * 3.1415 * iTime) * 0.05; // or some other amount\n    float c1 = cos(k1*tail1p.x);\n    float s1 = sin(k1*tail1p.x);\n    mat2  m1 = mat2(c1,-s1,s1,c1);\n    vec3  q1 = vec3(m1*tail1p.xy,tail1p.z);\n    float tail1 = sdBox(q1 - vec3(1.5, 0.0, 0.0), vec3(1.5, 0.01, 0.07));\n    vec3 tail2p = p;\n    float k2 = cos(1.5 * 3.1415 * (iTime - 1.0)) * 0.05; // or some other amount\n    float c2 = cos(k2*tail2p.x);\n    float s2 = sin(k2*tail2p.x);\n    mat2  m2 = mat2(c2,-s2,s2,c2);\n    vec3  q2 = vec3(m2*tail2p.xy,tail2p.z);\n    float tail2 = sdBox(q2 - vec3(1.0, 0.0, -0.3), vec3(1.0, 0.01, 0.07));\n    vec3 tail3p = p;\n    float k3 = cos(1.5 * 3.1415 * (iTime + 1.0)) * 0.05; // or some other amount\n    float c3 = cos(k3*tail2p.x);\n    float s3 = sin(k3*tail2p.x);\n    mat2  m3 = mat2(c3,-s3,s3,c3);\n    vec3  q3 = vec3(m3*tail3p.xy,tail3p.z);\n    float tail3 = sdBox(q2 - vec3(1.0, 0.0, 0.3), vec3(1.0, 0.01, 0.07));\n    return min(tail3, min(tail2, min(head, tail1)));\n}\n\n\nvoid findClosest(in vec3 point, out float minDist, out int obj) {\n    minDist = 1000000.0;\n    float temp;\n    if ((temp = sdBox(point - vec3(0.0, -3.45, -9.5), vec3(50.0, 0.1, 10.0))) < minDist) {\n        minDist = temp;\n        obj = 1;\n    }\n    if ((temp = repeatPillars(point - vec3(4.0, 0.0, 0.0), vec3(8.0, 0.0, 0.0))) < minDist) {\n        minDist = temp;\n        obj = 2;\n    }\n    if ((temp = sdBox(point - vec3(0.0, 10.2, -1.3), vec3(50.0, 0.2, 2.0))) < minDist) {\n        minDist = temp;\n        obj = 3;\n    }\n    if ((temp = repeatRails(point - vec3(0.0, -2.05, 0.5), vec3(0.5, 0.0, 0.0))) < minDist) {\n        minDist = temp;\n        obj = 3;\n    }\n    if ((temp = sdBox(point - vec3(0.0, -1.3, 0.5), vec3(50.0, 0.05, 0.0))) < minDist) {\n        minDist = temp;\n        obj = 3;\n    }\n    if ((temp = sdSphere( (point - fakeLightPos), 5.5)) < minDist) {\n        minDist = temp;\n        obj = 4;\n    }\n    if ((temp = sdPlane(point, vec3(0.0, 0.0 , -1.0), 31.0)) < minDist) {\n        minDist = temp;\n        obj = 5;\n    }\n    if ((temp = sdMountain(point - vec3(0.0, -8.0, 23.0))) < minDist) {\n        minDist = temp;\n        obj = 6;\n    }\n    if ((temp = sdSmallMountains(point - vec3(0.0, -1.0, 19.0))) < minDist) {\n        minDist = temp;\n        obj = 6;\n    }\n//    if ((temp = repeatPillarsFinite(vec3(1.0, 1.0, 2.0) * (point - vec3(-35.0, -5.0, 12.0)), vec3(3.0, 0.0, 0.0), vec3(2.0, 0.0, 0.0))) < minDist) {\n//        minDist = temp * (1.0 / 2.0);\n//        obj = 9;\n//    }\n    if ((temp = repeatSmoothPillarsFinite(point - vec3(20.0, -10.0, 10.0), vec3(3.5, 0.0, 0.0), vec3(2.0, 0.0, 0.0))) < minDist) {\n        minDist = temp;\n        obj = 9;\n    }\n    if ((temp = repeatSmoothPillarsFinite(point - vec3(-25.0, -5.0, 15.0), vec3(3.5, 0.0, 0.0), vec3(2.0, 0.0, 0.0))) < minDist) {\n        minDist = temp;\n        obj = 9;\n    }\n    if ((temp = repeatPillarsFinite(point - vec3(11.0, -9.0, 17.0), vec3(3.5, 0.0, 0.0), vec3(2.0, 0.0, 0.0))) < minDist) {\n        minDist = temp;\n        obj = 9;\n    }\n    if ((temp = sdTraveller(point - vec3(-mod(iTime, 35.0) + 17.5, 3.0 * cos( 3.1415 / 17.5 * (-mod(iTime, 35.0) + 17.5)) + 1.0, -6.0))) < minDist) {\n        minDist = temp;\n        obj = 7;\n    }\n    if ((temp = sdSphere(point - vec3(-mod(iTime, 35.0) + 17.4, 3.0 * cos( 3.1415 / 17.5 * (-mod(iTime, 35.0) + 17.5)) + 1.0, -5.95), 0.2)) < minDist) {\n        minDist = temp;\n        obj = 8;\n    }\n    \n    \n    if ((temp = sdCarpet(rotateZ(point - vec3(-mod((iTime + 10.0), 35.0) + 17.5, 1.0 * cos( 3.1415 / 8.0 * (-mod((iTime + 10.0), 35.0) + 17.5)) + 4.0, -5.0), \n                                 atan(-1.0 * 3.1415 / 8.0 * sin(3.1415 / 8.0 * (-mod((iTime + 10.0), 35.0) + 17.5))))) - 0.05) < minDist) {\n        minDist = temp;\n        obj = 7;\n    }\n    \n    if ((temp = sdCarpet(rotateZ(point - vec3(-mod((iTime - 10.0), 35.0) + 17.5, 1.0 * cos( 3.1415 / 8.0 * (-mod((iTime - 10.0), 35.0) + 17.5)) - 1.5, -7.0), \n                                 atan(-1.0 * 3.1415 / 8.0 * sin(3.1415 / 8.0 * (-mod((iTime - 10.0), 35.0) + 17.5))))) - 0.05) < minDist) {\n        minDist = temp;\n        obj = 7;\n    }\n}\n\nfloat findClosest(in vec3 point) {\n    float minDist = sdBox(point - vec3(0.0, -3.45, -6.5), vec3(50.0, 0.1, 10.0));\n    minDist = min(minDist, repeatPillars(point - vec3(4.0, 0.0, 0.0), vec3(8.0, 0.0, 0.0)));\n    minDist = min(minDist, sdBox(point - vec3(0.0, 10.2, -1.3), vec3(50.0, 0.2, 2.0)));\n    minDist = min(minDist, repeatRails(point - vec3(0.0, -2.05, 0.5), vec3(0.5, 0.0, 0.0)));\n    minDist = min(minDist, sdBox(point - vec3(0.0, -1.3, 0.5), vec3(50.0, 0.05, 0.0)));\n    minDist = min(minDist, sdTraveller(point - vec3(-mod(iTime, 35.0) + 17.5, 3.0 * cos( 3.1415 / 17.5 * (-mod(iTime, 35.0) + 17.5)) + 1.0, -6.0)));\n    minDist = min(minDist, sdCarpet(rotateZ(point - vec3(-mod((iTime + 10.0), 35.0) + 17.5, 1.0 * cos( 3.1415 / 8.0 * (-mod((iTime + 10.0), 35.0) + 17.5)) + 4.0, -5.0), \n                                 atan(-1.0 * 3.1415 / 8.0 * sin(3.1415 / 8.0 * (-mod((iTime + 10.0), 35.0) + 17.5))))) - 0.05);\n    minDist = min(minDist, sdCarpet(rotateZ(point - vec3(-mod((iTime - 10.0), 35.0) + 17.5, 1.0 * cos( 3.1415 / 8.0 * (-mod((iTime - 10.0), 35.0) + 17.5)) - 1.5, -7.0), \n                                 atan(-1.0 * 3.1415 / 8.0 * sin(3.1415 / 8.0 * (-mod((iTime - 10.0), 35.0) + 17.5))))) - 0.05);\n    minDist = min(minDist, repeatSmoothPillarsFinite(point - vec3(-25.0, -5.0, 15.0), vec3(3.5, 0.0, 0.0), vec3(2.0, 0.0, 0.0)));\n    minDist = min(minDist, repeatSmoothPillarsFinite(point - vec3(20.0, -10.0, 10.0), vec3(3.5, 0.0, 0.0), vec3(2.0, 0.0, 0.0)));\n    minDist = min(minDist, repeatPillarsFinite(point - vec3(11.0, -9.0, 17.0), vec3(3.5, 0.0, 0.0), vec3(2.0, 0.0, 0.0)));\n    return minDist;\n}\n\nfloat density (in vec3 point) {\n    const float k = 0.004;\n    float c = cos(k*point.x);\n    float s = sin(k*point.x);\n    mat2  m = mat2(c,-s,s,c);\n    vec3  q = vec3(m*point.xy,point.z);\n    float capsule1 = sdCapsule(q, vec3(-30.0, -1.0, 15.0), vec3(30.0, -1.0, 15.0), 7.0);\n    float capsule2 = sdCapsule(q, vec3(-70.0, 8.0, 20.0), vec3(-15.0, 8.0, 20.0), 6.0);\n    float capsule3 = sdCapsule(q, vec3(70.0, 8.0, 20.0), vec3(15.0, 8.0, 20.0), 5.0);\n    float density1 =  min(-capsule1, mix(0.0, 0.03, -capsule1 * 0.125 + 1.0 * (2.0 * fbm(0.2 * point) - 1.0)));\n    float density2 = min(-capsule2, mix(0.0, 0.03, -capsule2 * 0.125 + 1.0 * (2.0 * fbm(0.2 * point) - 1.0)));\n    float density3 = min(-capsule3, mix(0.0, 0.03, -capsule3 * 0.125 + 1.0 * (2.0 * fbm(0.2 * point) - 1.0)));\n    return max(density1, max(density2, max(density3, 0.0)));\n}\n\nvoid rayMarch (in vec3 origin, in vec3 direction, out int objectHit, out vec3 point) {\n    \n    float t = 0.f;\n    while (t <= 80.f) {\n        point = origin + t * direction;\n        float minDist;\n        findClosest(point, minDist, objectHit);\n        if (minDist < 0.0001) {\n            return;\n        }\n        t += minDist;\n    }\n    objectHit = 0;\n    \n}\n\nvec3 rayMarchCloud (in vec3 origin, in vec3 point) {\n    \n    float t = 0.f;\n    vec3 current = origin;\n    vec3 direction = normalize(point - origin);\n    float T = 1.0;\n    vec3 C = vec3(0.0);\n    while (dot(point - current, point - origin) > 0.0) {\n        current = origin + t * direction;\n        float d = density(current);\n        if (d > 0.0) {\n            T *= exp(-d * 1.5);\n            C += 1.5 * d * T * vec3(1.0, 1.0, 1.0);\n        }\n        t += 1.5;\n    }\n    return C;\n    \n}\n\nfloat ao(in vec3 point, in vec3 normal) {\n    float sum = 0.0;\n    for (float i = 0.0; i < 5.0; i = i + 1.0) {\n        sum += pow(0.5, i) * (i * AO_DIST - findClosest(point + normal * i * AO_DIST));\n    }\n    return 1.0 - AO_K * sum;\n}\n\nfloat subsurfaceColor(in vec3 lightDir, in vec3 normal, in vec3 viewVec, in float thin) {\n\tvec3 scatterDir = lightDir + normal * DISTORTION;\n\tfloat lightReachingEye = pow(clamp(dot(viewVec, -scatterDir),\n\t\t\t\t\t\t\t     0.0, 1.0), GLOW) * SCALE;\n\tfloat attenuation = max(0.0, dot(normal, lightDir)\n                             + dot(viewVec, -lightDir));\n\tfloat totalLight = attenuation * (lightReachingEye + AMBIENT) * thin;\n\treturn totalLight;\n}\n\nfloat softShadow(vec3 origin, vec3 direction) {\n    float shadow = 1.0;\n    float t = 0.01;\n    while (t <= 80.0) {\n        float minDist = findClosest(origin + t * direction);\n        if (minDist < 0.0001) {\n            return 0.0;\n        }\n        shadow = min(shadow, k * minDist / t);\n        t += minDist;\n    }\n    return shadow;\n}\n\nvec3 applyFog( in vec3  rgb,       // original color of the pixel\n               in float distance ) // camera to point distance\n{\n    float fogAmount = 1.0 - exp( -(distance - 12.0) *0.05 );\n    vec3  fogColor  = vec3(1.0, 0.92, 0.57);\n    return mix( rgb, fogColor, fogAmount );\n}\n\nvec3 applyFog( in vec3  rgb,      // original color of the pixel\n               in float distance, // camera to point distance\n               in vec3  rayDir,   // camera to point vector\n               in vec3  sunDir )  // sun light direction\n{\n    float fogAmount = 1.0 - exp( -(max(distance - 12.0, 0.0)) * 0.08 );\n    float sunAmount = max( exp( 0.12 * pow(dot( rayDir, sunDir ), 3.0)), 0.0 );\n    vec3  fogColor  = mix( vec3(0.7, 0.4, 0.2), // bluish\n                           vec3(1.0, 0.85, 0.57), // yellowish\n                           pow(sunAmount, 8.0) );\n    return mix( rgb, fogColor, fogAmount );\n}\n\nvec3 getColor(in int objectHit, in vec3 point, in vec3 normal) {\n    \n    vec3 color;\n    vec3 v = normalize(cameraPos - point);\n    vec3 l = normalize(lightPos - point);\n    vec3 lf = normalize(fakeLightPos - point);\n    vec3 ltrial = normalize(vec3(0.0, 10.0, -10.0) - point);\n    switch (objectHit) { \n        case 0: \n        color = vec3(0.0, 0.0, 0.0); return color;\n        case 1: \n        color = max(dot(l, normal), 0.0) * vec3(0.35,0.33,0.1) ; \n        normal = normalize(vec3(0.0, 1.0, 0.0) + vec3(0.0, 0.0, 0.4 * sin(point.z)) + 0.8 * fbm2D3D(12.0 * point.xz) ); //\n        color +=  max(pow(dot(normalize(vec3(v + l) / 2.0), normal), 15.0), 0.0) * vec3(1.0, 1.0, 0.8);\n        color *= softShadow(point, l);\n        color += vec3(0.47,0.2,0.09);\n        break;\n        case 2:\n        color = ao(point, normal) * (max(dot(l, normal), 0.0) * vec3(0.7) + vec3(0.47,0.2,0.09));  \n        break;\n        case 3:\n        color = vec3(0.47,0.2,0.09);\n        break;\n        case 4:\n        color = vec3(1.0, 1.0, 1.0);\n        break;\n        case 5:\n        color = mix(vec3(1.0, 1.0, 1.0), vec3(1.0, 0.85, 0.45), clamp(distance(point, fakeLightPos) / 50.0, 0.0, 1.0));\n        break;\n        case 6:\n        color = applyFog(vec3(0.47,0.2,0.09), point.z, -v, lf);\n        break;\n        case 7:\n        color = max(dot(ltrial, normal), 0.0) * vec3(0.35, 0.08, 0.04) + vec3(0.35, 0.08, 0.04) ;\n        break;\n        case 8:\n        color = vec3(0.f);\n        break;\n        case 9:\n        color = applyFog(max(dot(l, normal), 0.0) * vec3(0.5,0.5,0.5) + vec3(0.47,0.2,0.09), point.z, -v, lf);\n        \n    }\n    return color;\n        \n}\n\nvec3 getNormal(in vec3 point) {\n    const float ep = 0.0001;\n    vec2 e = vec2(1.0,-1.0)*0.5773;\n    return normalize( e.xyy*findClosest( point + e.xyy*ep ) + \n\t\t\t\t\t  e.yyx*findClosest( point + e.yyx*ep ) + \n\t\t\t\t\t  e.yxy*findClosest( point + e.yxy*ep ) + \n\t\t\t\t\t  e.xxx*findClosest( point + e.xxx*ep ) );\n}\n    \n\nvoid raycast(vec2 uv, out vec3 dir, out vec3 eye, out vec3 ref) {\n    eye = cameraPos;\n    ref = vec3(0.0, 0.0, 0.0);\n    \n    float len = tan(3.14159 / 180.0 * 30.0) * distance(eye, ref);\n    vec3 H = normalize(cross(vec3(0.0, 1.0, 0.0), ref - eye));\n    vec3 V = normalize(cross(H, eye - ref));\n    V *= len;\n    H *= len * iResolution.x / iResolution.y;\n    vec3 p = ref + uv.x * H + uv.y * V;\n    dir = normalize(p - eye);\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (2.0 * fragCoord/iResolution.xy) - vec2(1.0);\n    vec3 dir, eye, ref;\n    raycast(uv, dir, eye, ref);\n    int objectHit;\n    vec3 point;\n    rayMarch(eye, dir, objectHit, point);\n    vec3 normal;\n    normal = getNormal(point);\n    \n    vec3 clouds = rayMarchCloud(eye, point);\n\n    \n    // Time varying pixel color\n    vec3 col = getColor(objectHit, point, normal) + clouds;\n\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/NsXSDj.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "NsXSRS", "name": "大龙猫 - Qualigraphic", "author": "totetmatt", "description": "Got inspired from a friend  creation : https://www.instagram.com/p/CNwSYrJha7n/", "tags": ["2d", "wave", "lines", "drawing"], "likes": 11, "viewed": 239, "date": "1618738991", "time_retrieved": "2024-06-20T20:38:21.654839", "image_code": "#define hash21(p) fract(sin(dot(p, vec2(122.9898, 78.2033))) * 43758.5453)\n\nfloat fig(vec2 uv,vec2 offset){\nvec2 uuv= uv;\n   uv+=offset;\n float d = length(uv)-.052;\n    d = smoothstep(.010,.011,d);\n    float c = d;\n\n    \n    for(float i=0.;i<25.;i++){\n        vec2 n = uv;\n        float h  = hash21(vec2(i,i+.12)+offset);\n         \n        float at= atan(n.x,n.y);\n\n       float q=length(uv)-(.120+.018*i+sin(iTime*.33+at*9.+h*h*h*h*exp(mod(i+7.,14.)))*(.01+.001*i+h*.008));\n       //q = smoothstep(.0040,.0071,abs(q)-.001-sin(iTime+i+at*2.+h*100.)*.005+.003);\n       q = smoothstep(0., fwidth(q),abs(q)-.001-sin(iTime+i+at*2.+h*100.)*.005-.0001);\n       d = min(q,d);\n    }\n    \n    float lim = .47;\n    if(abs(uuv.x) >lim || abs(uuv.y) > lim){\n        d=1.;\n    }\n    d = min(c,d);\n    return d;\n}\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = (fragCoord.xy -.5* iResolution.xy)/iResolution.y;\n\n     \n     vec2 offset = vec2(-.4,.4);\n    float d = fig(uv,offset);\n    float e = fig(uv,offset*-1.);\n    d  =min(d,e);\n    vec3 col = vec3(d);\n    col = mix(vec3(.1),vec3(1.,.95,.9),col);\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/NsXSRS.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "NsXSW2", "name": "Aquiles", "author": "jorge2017a1", "description": "Aquiles", "tags": ["aquiles"], "likes": 10, "viewed": 145, "date": "1619209688", "time_retrieved": "2024-06-20T20:38:21.655093", "image_code": "//por jorge2017a1 ----jorgeFloresP---23/abril/2021\n// referencia\n//https://www.shadertoy.com/view/tlGBW3\n#define Rot(a) mat2(cos(a),-sin(a),sin(a),cos(a))\n#define antialiasing(n) n/min(iResolution.y,iResolution.x)\n#define S(d,b) smoothstep(antialiasing(1.0),b,d)\n#define DF(a,b) length(a) * cos( mod( atan(a.y,a.x)+6.28/(b*8.0), 6.28/((b*8.0)*0.5))+(b-1.)*6.28/(b*8.0) + vec2(0,11) )\n#define opU2(d1, d2) ( d1.x < d2.x ? d1 : d2 )\n\nfloat opU( float d1, float d2 ) { return  min(d1,d2); }\nfloat opS( float d1, float d2 ) { return max(-d1,d2); }\nfloat opI( float d1, float d2 ) { return max(d1,d2); }\n\n//----------oPeraciones de Repeticion\nfloat opRep1D( float p, float c )\n\t{ float q = mod(p+0.5*c,c)-0.5*c; return  q ;}\n//----------\nfloat sdBox( in vec2 p, in vec2 b )\n{  vec2 d = abs(p)-b; return length(max(d,0.0)) + min(max(d.x,d.y),0.0); }\n\nfloat sdCircle( vec2 p, float r )\n{ return length(p) - r; }\n\nvec2 rotatev2(vec2 p, float ang)\n{\n    float c = cos(ang); float s = sin(ang);\n    return vec2(p.x*c - p.y*s, p.x*s + p.y*c);\n}\n////-------------------\n\n//https://www.shadertoy.com/view/tlGBW3\n//Created by manu210404 in 2021-03-13\n#define POLY(N) (in vec2 p, in vec2[N] v) {const int n=v.length();float d=dot(p-v[0],p-v[0]);float s=1.;for(int i=0,j=n-1;i<n;j=i,i++){vec2 e=v[j]-v[i];vec2 w=p-v[i];vec2 b=w-e*clamp(dot(w,e)/dot(e,e),0.,1.);d=min(d,dot(b,b));bvec3 cond=bvec3(p.y>=v[i].y,p.y<v[j].y,e.x*w.y>e.y*w.x);if(all(cond)||all(not(cond))) s=-s;}return s*sqrt(d);}\n\n\nfloat sdPoly60 POLY(60)\nvec2 pt60[ 60]=vec2[](  \nvec2(.42,.44),vec2(.08,.71),vec2(.06,.75),vec2(.10,.73),vec2(.43,.47),\nvec2(.44,.47),vec2(.21,.80),vec2(.19,.87),vec2(.24,.82),vec2(.46,.49),\nvec2(.47,.49),vec2(.33,.90),vec2(.33,.93),vec2(.35,.90),vec2(.50,.51),\nvec2(.51,.51),vec2(.48,.92),vec2(.48,.95),vec2(.49,.92),vec2(.53,.51),\nvec2(.55,.51),vec2(.63,.88),vec2(.65,.92),vec2(.66,.88),vec2(.58,.51),\nvec2(.59,.50),vec2(.76,.81),vec2(.79,.84),vec2(.79,.80),vec2(.62,.48),\nvec2(.64,.47),vec2(.86,.68),vec2(.91,.70),vec2(.90,.67),vec2(.66,.45),\nvec2(.66,.44),vec2(.89,.53),vec2(.95,.54),vec2(.90,.50),vec2(.68,.41),\nvec2(.68,.40),vec2(.90,.40),vec2(.94,.38),vec2(.90,.36),vec2(.71,.36),\nvec2(.70,.35),vec2(.73,.31),vec2(.74,.29),vec2(.74,.29),vec2(.72,.30),\nvec2(.68,.36),vec2(.65,.42),vec2(.61,.46),vec2(.56,.48),vec2(.51,.48),\nvec2(.46,.46),vec2(.43,.43),vec2(.41,.44),vec2(.42,.45),vec2(.42,.44) );\n\n\nfloat sdPoly15 POLY(15)\nvec2 pt15[ 15]=vec2[](  \nvec2(.46,.42),vec2(.44,.44),vec2(.46,.46),vec2(.51,.48),vec2(.56,.48),\nvec2(.61,.46),vec2(.65,.42),vec2(.68,.37),vec2(.63,.37),vec2(.61,.41),\nvec2(.57,.44),vec2(.53,.44),vec2(.49,.43),vec2(.48,.43),vec2(.46,.42) );\n\n\nfloat sdPoly77 POLY(77)\nvec2 pt77[ 77]=vec2[](  \nvec2(.41,.32),vec2(.42,.35),vec2(.44,.38),vec2(.46,.40),vec2(.47,.41),\nvec2(.48,.41),vec2(.48,.40),vec2(.46,.40),vec2(.45,.39),vec2(.46,.38),\nvec2(.49,.38),vec2(.50,.39),vec2(.52,.38),vec2(.54,.37),vec2(.56,.35),\nvec2(.57,.33),vec2(.57,.30),vec2(.57,.29),vec2(.56,.28),vec2(.55,.26),\nvec2(.54,.25),vec2(.57,.27),vec2(.57,.28),vec2(.58,.29),vec2(.59,.29),\nvec2(.61,.29),vec2(.62,.27),vec2(.64,.25),vec2(.62,.24),vec2(.61,.23),\nvec2(.60,.22),vec2(.61,.22),vec2(.62,.23),vec2(.64,.24),vec2(.65,.23),\nvec2(.66,.23),vec2(.65,.25),vec2(.64,.26),vec2(.62,.29),vec2(.61,.30),\nvec2(.60,.30),vec2(.58,.30),vec2(.58,.32),vec2(.58,.34),vec2(.60,.33),\nvec2(.62,.33),vec2(.63,.34),vec2(.64,.35),vec2(.64,.36),vec2(.62,.35),\nvec2(.61,.34),vec2(.59,.34),vec2(.57,.35),vec2(.56,.36),vec2(.54,.38),\nvec2(.61,.39),vec2(.60,.40),vec2(.58,.41),vec2(.54,.42),vec2(.51,.41),\nvec2(.50,.40),vec2(.50,.40),vec2(.49,.41),vec2(.52,.42),vec2(.54,.43),\nvec2(.57,.42),vec2(.59,.42),vec2(.61,.41),vec2(.61,.41),vec2(.57,.44),\nvec2(.51,.44),vec2(.46,.42),vec2(.44,.40),vec2(.42,.37),vec2(.41,.33),\nvec2(.40,.32),vec2(.41,.32) );\n\n// pelo\nfloat sdPoly30 POLY(30)\nvec2 pt30[ 30]=vec2[](  \nvec2(.42,.34),vec2(.44,.40),vec2(.48,.43),vec2(.51,.44),vec2(.56,.44),\nvec2(.61,.42),vec2(.63,.39),vec2(.64,.34),vec2(.62,.26),vec2(.60,.23),\nvec2(.59,.22),vec2(.58,.24),vec2(.58,.27),vec2(.58,.27),vec2(.58,.31),\nvec2(.57,.32),vec2(.55,.30),vec2(.54,.30),vec2(.54,.32),vec2(.53,.28),\nvec2(.53,.27),vec2(.51,.28),vec2(.51,.31),vec2(.49,.32),vec2(.47,.33),\nvec2(.45,.34),vec2(.44,.34),vec2(.43,.33),vec2(.42,.33),vec2(.42,.34) );\n\n// rostro\nfloat sdPoly33 POLY(33)\nvec2 pt33[ 33]=vec2[](  \nvec2(.42,.33),vec2(.43,.30),vec2(.41,.26),vec2(.41,.25),vec2(.42,.25),\nvec2(.43,.25),vec2(.43,.23),vec2(.44,.22),vec2(.44,.22),vec2(.44,.22),\nvec2(.44,.21),vec2(.45,.20),vec2(.44,.20),vec2(.44,.18),vec2(.45,.17),\nvec2(.47,.18),vec2(.53,.20),vec2(.57,.22),vec2(.59,.23),vec2(.58,.26),\nvec2(.58,.29),vec2(.58,.31),vec2(.56,.33),vec2(.54,.30),vec2(.53,.32),\nvec2(.53,.27),vec2(.51,.28),vec2(.51,.31),vec2(.48,.33),vec2(.45,.34),\nvec2(.43,.34),vec2(.42,.34),vec2(.42,.33) );\n\n// pestana\nfloat sdPoly7 POLY(7)\nvec2 pt7[ 7]=vec2[](  \nvec2(.42,.32),vec2(.45,.33),vec2(.46,.32),vec2(.45,.32),vec2(.43,.32),\nvec2(.43,.32),vec2(.42,.32) );\n\n//ojo\nfloat sdPoly6 POLY(6)\nvec2 pt6[ 6]=vec2[](  \nvec2(.44,.31),vec2(.46,.31),vec2(.47,.30),vec2(.45,.29),vec2(.44,.30),\nvec2(.44,.31) );\n\nvec3 rayo(vec2 puv )\n{   vec2 uv=puv;\n    float s1 = 0.5+0.5*sin(iTime+uv.x*20.*(sin(iTime)+4.0));\n    float s2 = 0.5+0.25*sin(iTime+uv.x*100.*(sin(iTime)*2.0+2.0));\n    float r = pow(1.0-sqrt( abs(uv.y-s1)),1.5 );\n    float g = pow(1.0-sqrt( abs(uv.y-s2)),1.5 );\n    float b = 1.0*(r+g);\n   return vec3(r,g,b);\n}\n\nvec4 lines(vec2 position)\n{\tvec3 color;\n    if (position.x>0.4) return vec4(0.0);\n    float red1 = position.y-(0.02*cos(iTime+1.5)+1.)/2.+0.35;\n    float red2 = position.y-(0.02*cos(iTime+1.5)+1.)/2.+0.45;\n    \n\tred1 = 1.-pow(abs(red1*20.),.5);\n    red2 = 1.-pow(abs(red2*20.),.5);\n\tcolor= mix(vec3(0.),vec3(2.,0.,0.), red1);\n    color= mix(color,vec3(2.,0.,0.), red2);\n\t\n    color = clamp(color, 0.,2.);\n\tfloat m = max(max(color.x - 1.,color.y - 1.),color.z-1.);\n\tcolor += vec3(m);\n\tcolor = clamp(color, 0.,1.);\n\treturn vec4(color,float(distance(color,vec3(0.))));\n}\n\nvec3 RostroAquiles(in vec2 pp, vec3 col) \n{\n  vec2 p=pp;\n  float sd1 = sdPoly60(p-vec2(0.0,-0.2), pt60);  //casco1\n  float sd2 = sdPoly15(p-vec2(0.0,-0.2), pt15);  // casco2\n  float sd3 = sdPoly77(p-vec2(0.0,-0.2), pt77);  //casco3\n  float sd4 = sdPoly30(p-vec2(0.0,-0.2), pt30); //pelo\n  float sd5 = sdPoly33(p-vec2(0.0,-0.2), pt33); //rostro\n  float sd6 = sdPoly7(p-vec2(0.0,-0.2), pt7);  //pestaña\n  float sd7 = sdPoly6(p-vec2(0.0,-0.2), pt6);  //ojo\n  \n //col = mix(col,vec3(0.6, 0.4,1.0),S(sd1,0.0));\n  col = mix(col,vec3(0.7, 0.6,0.5),S(sd1,0.0));\n  col = mix(col,vec3(0.9, 0.8,0.6),S(sd2,0.0));\n  col = mix(col,vec3(0.98, 0.82,0.720),S(sd5,0.0));   //vec3(0.98, 0.82,0.720) piel\n  col = mix(col,vec3(0.1, 0.1,0.2),S(sd4,0.0));\n  col = mix(col,vec3(1.0, 0.3,0.6),S(sd3,0.0));\n  col = mix(col,vec3(0.2, 0.2,0.2),S(sd6,0.0));\n  col = mix(col,vec3(0.8, 0.2,0.2),S(sd7,0.0));\n  \n  vec3 cr1= rayo(p);\n  float sb1=sdBox(p-vec2(-0.1,0.1), vec2(0.5,0.0125) );\n  col = mix(col,cr1,S(sb1,0.0));\n  return col;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{   vec2 uv = (fragCoord-iResolution.xy)/iResolution.y;\n    //posicion\n    vec2 p=uv+vec2(1.5,0.7);\n    // escala\n    p.x*=0.7;\n    p.y*=0.8;\n    p*=0.5+1.0*abs(sin(iTime*0.35));\n    vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n    col=vec3((col.x+col.y+col.z)/3.0)*vec3(0.2,0.2,1.0);\n    \n     col= RostroAquiles( p,col*2.0);\n    \n    vec4 l1= lines(p);\n  col = mix(l1.xyz,col,S(l1.w,0.0));\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/NsXSW2.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "NsXSWN", "name": "membrane", "author": "lennyjpg", "description": "soft moves", "tags": ["2d", "loop", "slow"], "likes": 0, "viewed": 134, "date": "1618757821", "time_retrieved": "2024-06-20T20:38:21.655093", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\nvec2 uv = fragCoord/iResolution.xy;\nvec2 u = uv * 100.;\nfloat t = iTime * .37;\nuv.x += sin(uv.y * 2.) * .1;\nu.x += sin(uv.x * 4. + t) * 20.;\nfloat k = sin(u.x * 3.23) ;\nk = fract(u.x * .3);\nvec3 a = vec3(1.1, .05, .2);\nvec3 b = vec3(1., .4, .547);\nvec3 c = mix(a, b, k + sin(uv.y) - .5);\nfragColor = vec4(c,1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/NsXSWN.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "NsXSzn", "name": "Infinite bezier curve", "author": "mrange", "description": "License CC0: Infinite bezier curve\nWhile I am sure something like this already exists on shadertoy\nI didn't find it and wanted a simple programming challenge for sunday\nevening", "tags": ["2d", "bezier"], "likes": 5, "viewed": 183, "date": "1618166092", "time_retrieved": "2024-06-20T20:38:22.612957", "image_code": "// License CC0: Infinite bezier curve\n//  While I am sure something like this already exists on shadertoy\n//  I didn't find it and wanted a simple programming challenge for sunday\n//  evening\n\n#define RESOLUTION iResolution\n#define TIME       iTime\n#define L2(x)      dot(x, x)\n\nconst float lw = 0.005;\n\nfloat hash(float co) {\n  return fract(sin(co*12.9898) * 13758.5453);\n}\n\n// http://mercury.sexy/hg_sdf/\nfloat mod1(inout float p, float size) {\n  float halfsize = size*0.5;\n  float c = floor((p + halfsize)/size);\n  p = mod(p + halfsize, size) - halfsize;\n  return c;\n}\n\n// https://iquilezles.org/www/articles/distfunctions2d/distfunctions2d.htm\nfloat segment(vec2 p, vec2 a, vec2 b) {\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\n\n// https://iquilezles.org/www/articles/distfunctions2d/distfunctions2d.htm\nfloat box(vec2 p, vec2 b) {\n    vec2 d = abs(p)-b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\n// https://iquilezles.org/www/articles/distfunctions2d/distfunctions2d.htm\nfloat bezier(vec2 pos, vec2 A, vec2 B, vec2 C) {    \n    vec2 a = B - A;\n    vec2 b = A - 2.0*B + C;\n    vec2 c = a * 2.0;\n    vec2 d = A - pos;\n    float kk = 1.0/dot(b,b);\n    float kx = kk * dot(a,b);\n    float ky = kk * (2.0*dot(a,a)+dot(d,b)) / 3.0;\n    float kz = kk * dot(d,a);      \n    float res = 0.0;\n    float p = ky - kx*kx;\n    float p3 = p*p*p;\n    float q = kx*(2.0*kx*kx-3.0*ky) + kz;\n    float h = q*q + 4.0*p3;\n    if( h >= 0.0) \n    { \n        h = sqrt(h);\n        vec2 x = (vec2(h,-h)-q)/2.0;\n        vec2 uv = sign(x)*pow(abs(x), vec2(1.0/3.0));\n        float t = clamp( uv.x+uv.y-kx, 0.0, 1.0 );\n        res = L2(d + (c + b*t)*t);\n    }\n    else\n    {\n        float z = sqrt(-p);\n        float v = acos( q/(p*z*2.0) ) / 3.0;\n        float m = cos(v);\n        float n = sin(v)*1.732050808;\n        vec3  t = clamp(vec3(m+m,-n-m,n-m)*z-kx,0.0,1.0);\n        res = min( L2(d+(c+b*t.x)*t.x),\n                   L2(d+(c+b*t.y)*t.y) );\n        // the third root cannot be the closest\n        // res = min(res,dot2(d+(c+b*t.z)*t.z));\n    }\n    return sqrt( res );\n}\n\nvec2 primitive(vec2 p, vec2 a, vec2 b, vec2 c) {\n  float db = bezier(p, a, b, c)-lw;\n  float d0 = segment(p, a, b);\n  float d1 = segment(p, b, c);\n  float d3 = box(p-a, vec2(lw*4.0));\n  float d4 = box(p-b, vec2(lw*4.0));\n  float d5 = box(p-c, vec2(lw*4.0));\n  \n  float dp = d0;\n  dp = min(dp, d1);\n  dp -= lw;\n  dp = min(dp, d3);\n  dp = min(dp, d4);\n  dp = min(dp, d5);\n\n  return vec2(db, dp);\n}\n\n// The amplitude generating function, x is cell number\nfloat ampl(float x) {\n  return 0.5*hash(x)+0.5*sin(0.5*x+TIME);\n}\n\n// The derivate generating function, x is cell number\nfloat dampl(float x) {\n  // The derivate should be switching signs per cell number in order to\n  //  make the intercepting point lie in the cell\n  float m = fract(x*0.5) > 0.0 ? 1.0 : -1.0;\n  return m*(1.0+0.5*(-1.0 + 2.0*hash(x+123.0)));\n}\n\nvec2 cell(vec2 cp, float cn) {\n  float a0 = ampl(cn);\n  float a1 = ampl(cn+1.0);\n  float d0 = dampl(cn);\n  float d1 = dampl(cn+1.0);\n \n  float t = (a0-a1+d1)/(d1-d0);\n\n  vec2 p0 = vec2(-0.5, a0);\n  vec2 p1 = p0 + t*vec2(1.0, d0);\n  vec2 p2 = vec2(0.5, a1);\n \n  return primitive(cp, p0, p1, p2);\n}\n\nvec2 curve(vec2 p) {\n  vec2 cp = p;\n  float cn = mod1(cp.x, 1.0);\n\n  // Sample surrounding cells to make distance field continuous\n  // A possible optimizations is compute the surrounding cells using\n  // a segments (ie not smooth) instead as the distance field should be \n  // a close approximation at the edges to the \n  vec2 d0 = cell(cp-vec2(-1.0, 0.0), cn-1.0);\n  vec2 d1 = cell(cp, cn);\n  vec2 d2 = cell(cp-vec2(1.0, 0.0), cn+1.0);\n  \n  vec2 d = d0;\n  d = min(d, d1);\n  d = min(d, d2);\n  \n  return d;\n}\n\nvec2 df(vec2 p) {\n  p.x += TIME;\n  return curve(p);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  vec2 q = fragCoord/RESOLUTION.xy;\n  vec2 p = -1. + 2. * q;\n  p.x *= RESOLUTION.x/RESOLUTION.y;\n  float aa = 2.0/RESOLUTION.y;\n  \n  float z = 0.75;\n  vec2 d = df(p/z)*z;\n  \n  vec3 col = vec3(0.0125);\n  \n  float m = smoothstep(-0.1, 0.1, sin(TIME));\n  col = mix(col, vec3(0.0, 0.75, 0.75), smoothstep(-aa, aa, -d.x));\n  col = mix(col, mix(col, vec3(0.75, 0.0, 0.0), m), smoothstep(-aa, aa, -d.y));\n \n  // Visalizes the distance field\n  // col += vec3(0.25, 0.25, 0.5)*pow((0.5+ 0.5*sin(100.0*d.x)), 20.0);\n  \n  col = pow(clamp(col, 0.0, 1.0), vec3(1.0/2.2));\n  \n  fragColor = vec4(col, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc0-1.0", "thumbnail": "https://www.shadertoy.com/media/shaders/NsXSzn.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "NsXXR4", "name": "Line wave", "author": "rmdms", "description": "Hope this will inspires someone", "tags": ["wave", "line", "white", "black"], "likes": 2, "viewed": 39, "date": "1618302713", "time_retrieved": "2024-06-20T20:38:22.612957", "image_code": "/*\n|--------------------------------------------------------------------------\n| Rémy Dumas\n|--------------------------------------------------------------------------\n|\n| Twitter: @remsdms\n| Portfolio: remydumas.fr\n|\n*/\n\n/*\n|--------------------------------------------------------------------------\n| yLine\n|--------------------------------------------------------------------------\n|\n| ...\n|\n*/\n\nvec3 yLine(vec2 uv,float y, float thickness){\n    float colwave = thickness /  abs(uv.y+y);\n    return vec3(colwave);\n}\n\n/*\n|--------------------------------------------------------------------------\n| Main\n|--------------------------------------------------------------------------\n|\n| Sandbox and sometimes something good\n|\n*/\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord) { \n    vec2 uv = (fragCoord.xy * 2.0 - iResolution.xy) / min(iResolution.x, iResolution.y);\n\n    vec3 col;\n    col += length(uv)/abs(sin(iTime));\n    col += yLine(uv,sin(uv.x+iTime)+sin(uv.y+iTime),0.01);\n    col += yLine(uv,sin(uv.x+iTime*0.2)+cos(uv.y+iTime*2.0),0.01);\n    col += yLine(uv,sin(uv.x+iTime*4.0)+sin(uv.y+iTime*0.5),0.01);\n    col += yLine(uv,cos(uv.x+iTime*0.2)+sin(uv.y+iTime*1.5),0.01);\n\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/NsXXR4.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "NsXXRj", "name": "Ingenuity Mk.2 ?", "author": "dr2", "description": "Celebrating Martian flight - design drawings for \"Mars Copter\" (mouseable)", "tags": ["sketch", "mars", "nasa", "helicopter"], "likes": 22, "viewed": 209, "date": "1618836797", "time_retrieved": "2024-06-20T20:38:22.640145", "image_code": "// \"Ingenuity Mk.2 ?\" by dr2 - 2021\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\nfloat PrRoundBoxDf (vec3 p, vec3 b, float r);\nfloat PrBox2Df (vec2 p, vec2 b);\nfloat PrCapsDf (vec3 p, float r, float h);\nfloat PrRoundCylDf (vec3 p, float r, float rt, float h);\nfloat SmoothBump (float lo, float hi, float w, float x);\nfloat Minv3 (vec3 p);\nfloat Maxv3 (vec3 p);\nmat3 StdVuMat (float el, float az);\nvec2 Rot2D (vec2 q, float a);\nfloat Noisefv2 (vec2 p);\n\nvec3 qHit, pgSize, ltDir, ltDirS;\nvec2 hipPos, ftPos;\nfloat tCur, dstFar, dMiss, legLenU, legLenD, aU, aD, pPitch, pRot, szFac;\nint idObj;\nconst int idBase = 1, idLeg = 2, idAxl = 3, idProp = 4;\nconst float pi = 3.1415927;\n\n#define VAR_ZERO min (iFrame, 0)\n\n#define DMINQ(id) if (d < dMin) { dMin = d;  idObj = id;  qHit = q; }\n\nfloat ObjDf (vec3 p)\n{\n  vec3 q;\n  vec2 fb;\n  float dMin, d;\n  dMin = dstFar / szFac;\n  p /= szFac;\n  fb = normalize (vec2 (1.2, 1.));\n  for (float k = -1. + float (VAR_ZERO); k <= 1.; k += 2.) {\n    q = p;\n    q.xz = Rot2D (q.xz, k * pRot);\n    q.y -= hipPos.y + 2.4 + 1.2 * k;\n    d = PrRoundCylDf (q.xzy, 0.2 - 0.05 * k, 0.01, 1.2);\n    DMINQ (idAxl);\n    q.y -= 1.;\n    d = min (max (PrRoundCylDf (vec3 (q.x, Rot2D (q.yz, k * pPitch)).xzy, 3., 0.02, 0.01),\n       dot (vec2 (q.x, abs (q.z)), fb)),\n       max (PrRoundCylDf (vec3 (q.x, Rot2D (q.yz, - k * pPitch)).xzy, 3., 0.02, 0.01),\n       dot (vec2 (- q.x, abs (q.z)), fb)));\n    DMINQ (idProp);\n  }\n  q = p;\n  q.y -= hipPos.y + 0.1;\n  d = PrRoundCylDf (q.xzy, hipPos.x, 0.05, 0.2);\n  q.y -= 0.4;\n  d = min (d, PrRoundCylDf (q.xzy, 0.35 * hipPos.x, 0.05, 0.15));\n  DMINQ (idBase);\n  q = p;\n  q.xz = Rot2D (q.xz, 2. * pi * (floor (6. * atan (q.z, - q.x) / (2. * pi)) + 0.5) / 6.);\n  q.xy -= hipPos * vec2 (-1., 1.);\n  q.xy = Rot2D (q.xy, aU);\n  q.x += 0.5 * legLenU;\n  d = PrCapsDf (q.yzx, 0.1 * (0.8 + 0.2 * q.x / (0.5 * legLenU)) / 0.6, 0.5 * legLenU);\n  DMINQ (idLeg);\n  q.x += 0.5 * legLenU;\n  q.xy = Rot2D (q.xy, aD - aU);\n  q.x += 0.5 * legLenD;\n  d = PrCapsDf (q.yzx, 0.1 * (0.9 + 0.1 * q.x / (0.5 * legLenD)), 0.5 * legLenD);\n  DMINQ (idLeg);\n  q.x += 0.5 * legLenD;\n  q.xy = Rot2D (q.xy, 0.5 * pi - aD);\n  q.x -= -0.02;\n  d = PrRoundCylDf (q.yzx, 0.3, 0.02, 0.05);\n  DMINQ (idLeg);\n  return szFac * dMin;\n}\n\nfloat ObjRay (vec3 ro, vec3 rd)\n{\n  float dHit, d;\n  dHit = 0.;\n  for (int j = VAR_ZERO; j < 120; j ++) {\n    d = ObjDf (ro + dHit * rd);\n    if (d < 0.001 || dHit > dstFar) break;\n    dHit += d;\n  }\n  return dHit;\n}\n\nvec3 ObjNf (vec3 p)\n{\n  vec4 v;\n  vec2 e;\n  e = vec2 (0.001, -0.001);\n  for (int j = VAR_ZERO; j < 4; j ++) {\n    v[j] = ObjDf (p + ((j < 2) ? ((j == 0) ? e.xxx : e.xyy) : ((j == 2) ? e.yxy : e.yyx)));\n  }\n  v.x = - v.x;\n  return normalize (2. * v.yzw - dot (v, vec4 (1.)));\n}\n\nvec4 ObjNfL (vec3 p)\n{\n  vec4 v;\n  vec2 e;\n  float s;\n  e = vec2 (0.005, -0.005);\n  for (int j = VAR_ZERO; j < 4; j ++) {\n    v[j] = ObjDf (p + ((j < 2) ? ((j == 0) ? e.xxx : e.xyy) : ((j == 2) ? e.yxy : e.yyx)));\n  }\n  v.x = - v.x;\n  s = dot (v, vec4 (1.));\n  return vec4 (normalize (2. * v.yzw - s), (s - 2. * v.x - 4. * ObjDf (p)) / (e.x * e.x));\n}\n\nfloat ObjSShadow (vec3 ro, vec3 rd)\n{\n  float sh, d, h;\n  sh = 1.;\n  d = 0.01;\n  for (int j = VAR_ZERO; j < 30; j ++) {\n    h = ObjDf (ro + d * rd);\n    sh = min (sh, smoothstep (0., 0.05 * d, h));\n    d += h;\n    if (sh < 0.05) break;\n  }\n  return 0.5 + 0.5 * sh;\n}\n\nfloat ExObjDf (vec3 p)\n{\n  vec3 q;\n  float dMin, d;\n  dMin = dstFar;\n  q = p;\n  q -= vec3 (8., 0.4, 6.);\n  q.xz = Rot2D (q.xz, 0.2 * pi);\n  d = PrRoundCylDf (q, 0.33, 0.02, 5.);\n  d = max (d, - dot (vec2 (q.z, dot (q.xy, cos (2. * pi * floor (16. * (atan (q.y, - q.x) / (2. * pi) +\n     0.5) + 0.5) / 16. + vec2 (0., 0.5 * pi)))), sin (-0.4 * pi + vec2 (0.5 * pi, 0.))) - 1.6);\n  DMINQ (1);\n  q = p;\n  q.yz -= vec2 (-0.1, 4.);\n  d = max (PrRoundBoxDf (q, vec3 (pgSize + vec3 (1., 0.1, 1.)), 0.03), - PrBox2Df (q.xz, pgSize.xz));\n  DMINQ (2);\n  return dMin;\n}\n\nfloat ExObjRay (vec3 ro, vec3 rd)\n{\n  float dHit, d;\n  dHit = 0.;\n  for (int j = VAR_ZERO; j < 80; j ++) {\n    d = ExObjDf (ro + dHit * rd);\n    if (d < 0.001 || dHit > dstFar) break;\n    dHit += d;\n  }\n  return dHit;\n}\n\nvec3 ExObjNf (vec3 p)\n{\n  vec4 v;\n  vec2 e;\n  e = vec2 (0.001, -0.001);\n  for (int j = VAR_ZERO; j < 4; j ++) {\n    v[j] = ExObjDf (p + ((j < 2) ? ((j == 0) ? e.xxx : e.xyy) : ((j == 2) ? e.yxy : e.yyx)));\n  }\n  v.x = - v.x;\n  return normalize (2. * v.yzw - dot (v, vec4 (1.)));\n}\n\nfloat ExObjSShadow (vec3 ro, vec3 rd)\n{\n  float sh, d, h;\n  sh = 1.;\n  d = 0.01;\n  for (int j = VAR_ZERO; j < 30; j ++) {\n    h = ExObjDf (ro + d * rd);\n    sh = min (sh, smoothstep (0., 0.05 * d, h));\n    d += h;\n    if (sh < 0.05) break;\n  }\n  return 0.5 + 0.5 * sh;\n}\n\nvec3 ShGrid (vec2 p, vec2 g, int stag)\n{\n  vec2 q, sq, ss;\n  q = p * g;\n  if (stag > 0 && 2. * floor (0.5 * floor (q.y)) != floor (q.y)) q.x += 0.5;\n  sq = smoothstep (0.05, 0.1, abs (fract (q + 0.5) - 0.5));\n  q = fract (q) - 0.5;\n  ss = 0.3 * smoothstep (0.3, 0.5, abs (q.xy)) * sign (q.xy);\n  if (abs (q.x) < abs (q.y)) ss.x = 0.;\n  else ss.y = 0.;\n  return vec3 (ss.xy, 1. - 0.1 * sq.x * sq.y).xzy;\n}\n\nvec2 ExBlkHit (vec3 ro, vec3 rd)\n{\n  vec3 v, tm, tp, u, fcBlk;\n  vec2 qBlk;\n  float dn, df, bSize;\n  bSize = dstFar;\n  if (rd.x == 0.) rd.x = 0.001;\n  v = ro / rd;\n  tp = bSize / abs (rd) - v;\n  tm = - tp - 2. * v;\n  dn = Maxv3 (tm);\n  df = Minv3 (tp);\n  if (df > 0. && dn < df) {\n    fcBlk = - sign (rd) * step (tm.zxy, tm) * step (tm.yzx, tm);\n    u = (v + dn) * rd;\n    qBlk = vec2 (dot (u.zxy, fcBlk), dot (u.yzx, fcBlk)) / bSize;\n  } else qBlk = vec2 (0.);\n  return qBlk;\n}\n\nvec4 BlkHit (vec3 ro, vec3 rd, vec3 bSize)\n{\n  vec3 v, tm, tp, fcBlk;\n  vec2 qBlk;\n  float dMin, dn, df;\n  dMin = dstFar;\n  if (rd.x == 0.) rd.x = 0.001;\n  v = ro / rd;\n  tp = bSize / abs (rd) - v;\n  tm = - tp - 2. * v;\n  dn = Maxv3 (tm);\n  df = Minv3 (tp);\n  if (df > 0. && dn < df) {\n    dMin = dn;\n    fcBlk = - sign (rd) * step (tm.zxy, tm) * step (tm.yzx, tm);\n  }\n  return vec4 (dMin, fcBlk);\n}\n\nvec4 ObjCol ()\n{\n  vec4 col4;\n  if (idObj == idBase) {\n    col4 = vec4 (0.9, 0.9, 1., 0.2) * (0.8 + 0.2 * smoothstep (0., 0.02,\n       abs (length (qHit.xz) - 1.1) - 0.1));\n  } else if (idObj == idLeg) {\n    col4 = vec4 (0.9, 0.9, 1., 0.2) * (0.8 + 0.2 * sin (8. * pi * qHit.x));\n  } else if (idObj == idAxl) {\n    col4 = vec4 (0.8, 1., 0.8, 0.2) * (1. - 0.2 * sin (4. * atan (qHit.z, qHit.x)));\n  } else if (idObj == idProp) {\n    col4 = vec4 (1., 0.9, 0.8, 0.2) * (0.9 + 0.1 * sin (8. * pi * length (qHit.xz)));\n  }\n  return col4;\n}\n\n#define ACOS_CLAMP(c) acos (clamp ((c), -1., 1.))\n\nvoid SetConf (float vp)\n{\n  vec2 knPos, r, a, b;\n  float tCyc, rl, s, t;\n  legLenU = 2.;\n  legLenD = 3.;\n  tCyc = 6.;\n  t = mod (tCur / tCyc, 1.);\n  pPitch = 0.05 * pi * (0.5 + 1.5 * SmoothBump (0.05, 0.5, 0.03, t));\n  hipPos = vec2 (1.5, 0.5 * (legLenU + legLenD) + 6. * step (vp, -0.5) * SmoothBump (0.25, 0.75, 0.2, t));\n  ftPos = vec2 (1.8 + 2.2 * (1. - smoothstep (0.2, 1.5, hipPos.y - (legLenU + legLenD))), 0.);\n  r = ftPos - hipPos;\n  rl = length (r);\n  b = vec2 (legLenU, legLenD);\n  if (rl < legLenU + legLenD) {\n    a = ACOS_CLAMP ((rl * rl + (b.y * b.y - b.x * b.x) * vec2 (-1., 1.)) / (2. * rl * b));\n    s = sign (r.x);\n    knPos = vec2 (hipPos.x, ftPos.y) + b * sin (vec2 ((a.x + 0.5 * pi) * s, a.y) -\n       asin (r.y / rl) * vec2 (- s, 1.));\n    r = knPos - hipPos;\n    aU = atan (r.y, r.x);\n    r = ftPos - knPos;\n    aD = atan (r.y, r.x);\n  } else {\n    aU = asin (r.x / (legLenU + legLenD)) - 0.5 * pi;\n    aD = aU;\n  }\n  pRot = ((vp != 1.) ? 2. : 0.2) * pi * tCur;\n}\n\nvec3 SkShowScene (vec3 ro, vec3 rd, vec2 uv)\n{\n  vec4 col4, vn4;\n  vec3 col, vn;\n  float dstObj;\n  dMiss = dstFar;\n  dstObj = ObjRay (ro, rd);\n  if (dstObj < dstFar) {\n    ro += dstObj * rd;\n    vn4 = ObjNfL (ro);\n    vn = vn4.xyz;\n    col4 = ObjCol ();\n    col = vec3 (1.) * Maxv3 (col4.rgb);\n    col *= (1. - 0.5 * smoothstep (0.5, 1., abs (vn4.w) / 64.)) *\n       (0.9 + 0.2 * Noisefv2 (Rot2D (uv, -0.2 * pi) * vec2 (16., 256.))) *\n       (0.5 + 0.5 * max (dot (vn, ltDirS), 0.));\n    dMiss = dstFar;\n  } else {\n    col = vec3 (1.);\n  }\n  col = mix (col, vec3 (0.3), exp (- 64. * dMiss));\n  return clamp (col, 0., 1.);\n}\n\nvec3 SkMain (vec2 fCoord, float vp)\n{\n  mat3 vuMat;\n  vec3 ro, rd, col;\n  vec2 uv;\n  float el, az, szFacT;\n  szFacT = szFac;\n  uv = fCoord / vec2 (5., 5.5);\n  if (vp == 0.) {\n    szFac = 0.7;\n    uv -= vec2 (-0.35, -1.7);\n    el = -0.05 * pi;\n    az = 0.;\n  } else if (vp == 1.) {\n    szFac = 0.65;\n    uv -= vec2 (0.3, -1.2);\n    el = -0.5 * pi;\n    az = 0.17 * pi;\n  } else if (vp == 2.) {\n    szFac = 0.63;\n    uv -= vec2 (0., -1.6);\n    el = -0.25 * pi;\n    az = 0.7 * pi;\n  }\n  vuMat = StdVuMat (el, az);\n  ro = vuMat * vec3 (0., -5., -20.);\n  rd = vuMat * normalize (vec3 (uv, 4.2));\n  ltDirS = vuMat * normalize (vec3 (0.7, 1., -0.7));\n  SetConf (vp);\n  col = SkShowScene (ro, rd, uv);\n  szFac = szFacT;\n  return clamp (col, 0., 1.);\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  vec4 col4, db4;\n  vec3 col, vn, qHitEx;\n  vec2 qBlk, q, sq;\n  float dstObj, dstExObj, sh, r;\n  int idObjEx;\n  bool isBg;\n  SetConf (-1.);\n  szFac = 0.7;\n  pgSize = vec3 (15., 0.1, 10.);\n  isBg = false;\n  dstExObj = ExObjRay (ro, rd);\n  idObjEx = idObj;\n  qHitEx = qHit;\n  dstObj = ObjRay (ro, rd);\n  db4 = BlkHit (ro - vec3 (0., -0.1, 4.), rd, pgSize);\n  if (min (dstObj, dstExObj) < min (db4.x, dstFar)) {\n    if (dstObj < dstExObj) {\n      ro += dstObj * rd;\n      vn = ObjNf (ro);\n      qBlk = mod (2. * ExBlkHit (ro, reflect (rd, vn)), 1.);\n      col4 = ObjCol ();\n    } else {\n      ro += dstExObj * rd;\n      vn = ExObjNf (ro);\n      if (idObjEx == 1) {\n        r = length (qHit.xy);\n        col4 = mix (vec4 (0.9, 0.7, 0.1, 0.), vec4 (1., 0.9, 0.1, 0.01), step (0.34, r));\n        col4 = mix (vec4 (0.3, 0.3, 0.3, 0.), col4, step (0.18, r));\n        col4 = mix (vec4 (0.8, 0.4, 0.1, 0.2), col4, step (qHitEx.z, 4.5));\n      } else if (idObjEx == 2) {\n        col4 = vec4 (0.5, 0.2, 0.1, 0.) * (0.9 + 0.1 * Noisefv2 (32. * qHit.xz));\n      }\n    }\n  } else if (db4.x < dstFar) {\n    ro += db4.x * rd;\n    vn = db4.yzw;\n    q = ro.xz - vec2 (0., 4.);\n    if (vn.y > 0.5 && PrBox2Df (q, pgSize.xz - 0.96) < 0.) {\n      sq = sign (q);\n      col = (sq.x < 0. || sq.y < 0.) ? SkMain (q - 0.5 * sq * pgSize.xz,\n         sq.y + 1. + 0.5 * (sq.x + 1.)) : vec3 (1.);\n      if (Minv3 (col) > 0.95) {\n        q = smoothstep (0.02, 0.05, abs (mod (q + 0.5, 1.) - 0.5));\n        col = mix (vec3 (0.4, 0.6, 0.9), vec3 (1.), min (q.x, q.y));\n      }\n    } else {\n      col = vec3 (1.) * (0.8 + 0.2 * step (0.5, vn.y));\n      sh = 1.;\n    }\n  } else {\n    isBg = true;\n  }\n  if (! isBg) {\n    SetConf (-1.);\n    sh = min (ObjSShadow (ro + 0.01 * vn, ltDir), ExObjSShadow (ro + 0.01 * vn, ltDir));\n    if (min (dstObj, dstExObj) < min (db4.x, dstFar)) {\n      col = col4.rgb * (0.2 + 0.8 * sh * max (dot (vn, ltDir), 0.)) +\n         col4.a * step (0.95, sh) * pow (max (0., dot (ltDir, reflect (rd, vn))), 32.);\n      col += col4.a * vec3 (0.5) * (0.5 + 0.5 * SmoothBump (0.25, 0.75, 0.05, qBlk.x) *\n         SmoothBump (0.25, 0.75, 0.05, qBlk.y));\n    } else {\n      col *= 0.3 + 0.7 * sh * max (dot (vn, ltDir), 0.);\n    }\n  } else {\n    qBlk = mod (8. * ExBlkHit (ro, rd), 1.);\n    col = vec3 (0.5, 0.4, 0.4) * (0.05 + 0.245 * (rd.y + 1.) * (rd.y + 1.)) +\n       vec3 (0.2) * (0.9 + 0.1 * SmoothBump (0.25, 0.75, 0.1, qBlk.x) *\n       SmoothBump (0.25, 0.75, 0.1, qBlk.y));\n  }\n  return clamp (col, 0., 1.);\n}\n\nvoid mainImage (out vec4 fragColor, vec2 fragCoord)\n{\n  mat3 vuMat;\n  vec4 mPtr;\n  vec3 ro, rd;\n  vec2 canvas, uv;\n  float el, az;\n  canvas = iResolution.xy;\n  uv = 2. * fragCoord.xy / canvas - 1.;\n  uv.x *= canvas.x / canvas.y;\n  tCur = iTime;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / canvas - 0.5;\n  az = 0.;\n  el = -0.27 * pi;\n  if (mPtr.z > 0.) {\n    az += 2. * pi * mPtr.x;\n    el += 0.8 * pi * mPtr.y;\n  }\n  el = clamp (el, -0.5 * pi, -0.1 * pi);\n  vuMat = StdVuMat (el, az);\n  ro = vuMat * vec3 (0., 1.5, -40.);\n  rd = vuMat * normalize (vec3 (uv, 4.7));\n  dstFar = 100.;\n  ltDir = vuMat * normalize (vec3 (0.7, 1., -0.7));\n  fragColor = vec4 (ShowScene (ro, rd), 1.);\n}\n\nfloat PrRoundBoxDf (vec3 p, vec3 b, float r)\n{\n  return length (max (abs (p) - b, 0.)) - r;\n}\n\nfloat PrBox2Df (vec2 p, vec2 b)\n{\n  vec2 d;\n  d = abs (p) - b;\n  return min (max (d.x, d.y), 0.) + length (max (d, 0.));\n}\n\nfloat PrCapsDf (vec3 p, float r, float h)\n{\n  return length (p - vec3 (0., 0., clamp (p.z, - h, h))) - r;\n}\n\nfloat PrRoundCylDf (vec3 p, float r, float rt, float h)\n{\n  return length (max (vec2 (length (p.xy) - r, abs (p.z) - h), 0.)) - rt;\n}\n\nfloat Minv3 (vec3 p)\n{\n  return min (p.x, min (p.y, p.z));\n}\n\nfloat Maxv3 (vec3 p)\n{\n  return max (p.x, max (p.y, p.z));\n}\n\nfloat SmoothBump (float lo, float hi, float w, float x)\n{\n  return (1. - smoothstep (hi - w, hi + w, x)) * smoothstep (lo - w, lo + w, x);\n}\n\nmat3 StdVuMat (float el, float az)\n{\n  vec2 ori, ca, sa;\n  ori = vec2 (el, az);\n  ca = cos (ori);\n  sa = sin (ori);\n  return mat3 (ca.y, 0., - sa.y, 0., 1., 0., sa.y, 0., ca.y) *\n         mat3 (1., 0., 0., 0., ca.x, - sa.x, 0., sa.x, ca.x);\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  vec2 cs;\n  cs = sin (a + vec2 (0.5 * pi, 0.));\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nconst float cHashM = 43758.54;\n\nvec2 Hashv2v2 (vec2 p)\n{\n  vec2 cHashVA2 = vec2 (37., 39.);\n  return fract (sin (dot (p, cHashVA2) + vec2 (0., cHashVA2.x)) * cHashM);\n}\n\nfloat Noisefv2 (vec2 p)\n{\n  vec2 t, ip, fp;\n  ip = floor (p);  \n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = mix (Hashv2v2 (ip), Hashv2v2 (ip + vec2 (0., 1.)), fp.y);\n  return mix (t.x, t.y, fp.x);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc-by-nc-sa-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/NsXXRj.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "NsXXz2", "name": "MandelKochBrotFlake...?", "author": "Pelegefen", "description": "Wanted to see what trippy stuff awaits when i project a zoom into the mandelbrot set,\ninto the symmetry of the koch snowflake.\n", "tags": ["2d", "fractal", "mandelbrot", "interactive", "kaleidoscope", "snowflake", "set", "koch"], "likes": 4, "viewed": 169, "date": "1618847744", "time_retrieved": "2024-06-20T20:38:23.540113", "image_code": "// Credits - fractal zoom with smooth iter count adapted from - iq (Inigo quilez) - https://www.iquilezles.org/www/articles/mset_smooth/mset_smooth.htm\n// Koch Snowflake symmetry from tutorial by Martijn Steinrucken aka The Art of Code/BigWings - 2020 - https://www.youtube.com/watch?v=il_Qg9AqQkE&ab_channel=TheArtofCode\n\n//Some notes - color is determined by date and not time - hour of day dependent.\n//Move the mouse on the Y axis to change the symmetry.\n\n\n\n\n#define date iDate\n#define time iTime\n#define resolution iResolution\n\n\n\nfloat localTime(){\n\nfloat d = date.w / date.x;\nreturn d;\n\n}\n\nvec3 randomCol(float sc){\n\n float d = localTime();\n\tfloat r = sin(sc * 1. * d)*.5+.5;\n\tfloat g = sin(sc * 2. * d)*.5+.5;\n\tfloat b = sin(sc * 4. * d)*.5+.5;\n\n\tvec3 col = vec3(r,g,b);\n\tcol = clamp(col,0.,1.);\n\n\treturn col;\n\t}\n\n\n//--------------------------------------------------mandelbrot generator-----------https://www.iquilezles.org/www/articles/mset_smooth/mset_smooth.htm\n\n\tfloat mandelbrot(vec2 c )\n{\n    #if 1\n    {\n        float c2 = dot(c, c);\n        // skip computation inside M1 - http://iquilezles.org/www/articles/mset_1bulb/mset1bulb.htm\n        if( 256.0*c2*c2 - 96.0*c2 + 32.0*c.x - 3.0 < 0.0 ) return 0.0;\n        // skip computation inside M2 - http://iquilezles.org/www/articles/mset_2bulb/mset2bulb.htm\n        if( 16.0*(c2+2.0*c.x+1.0) - 1.0 < 0.0 ) return 0.0;\n    }\n    #endif\n\n\n    const float B = 128.0;\n    float l = 0.0;\n    vec2 z  = vec2(0.0);\n    for( int i=0; i<256; i++ )\n    {\n        z = vec2( z.x*z.x - z.y*z.y, 2.0*z.x*z.y ) + c;\n        if( dot(z,z)>(B*B) ) break;\n        l += 1.0;\n    }\n\n    if( l>255.0 ) return 0.0;\n\n\n    // equivalent optimized smooth interation count\n    float sl = l - log2(log2(dot(z,z))) + 4.0;\n\n\n\n     return sl;\n }\n\n\nvec3 mandelbrotImg(vec2 p)\n{\n\n    //uncomment to see unmaped set\n\t//p = (-resolution.xy + 2.0*gl_FragCoord.xy)/resolution.y;\n    \n    float zoo = 0.62 + 0.38*cos(.1*time);\n   float coa = cos( 0.015*(1.0-zoo)*time );\n   float sia = sin( 0.015*(1.0-zoo)*time );\n   zoo = pow( zoo,6.0);\n   vec2 xy = vec2( p.x*coa-p.y*sia, p.x*sia+p.y*coa);\n   vec2 c = vec2(-.745,.186) + xy*zoo;\n\n        float l = mandelbrot(c);\n        \n        \n\tvec3 col1 = 0.5 + 0.5*cos( 3.0 + l*.15 + randomCol(.1));\n    vec3 col2 = 0.5 + 0.5*cos( 3.0 + l*.15 / randomCol(.1));\n    vec3 col = mix(col1,col2,sin(time * .5)*.5+.5);\n\n\n\n\nreturn col;\n}\n\n//-----------------functions-----------\n\nfloat remap(float a1, float a2 ,float b1, float b2, float t)\n{\n\treturn b1+(t-a1)*(b2-b1)/(a2-a1);\n}\n\n\nvec2 remap(float a1, float a2 ,float b1, float b2, vec2 t)\n{\n\treturn b1+(t-a1)*(b2-b1)/(a2-a1);\n}\n\n\nvec4 remap(float a1, float a2 ,float b1, float b2, vec4 t)\n{\n\treturn b1+(t-a1)*(b2-b1)/(a2-a1);\n}\n\n\n\n\n\nvec2 N(float angle) {\n    return vec2(sin(angle), cos(angle));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = (fragCoord.xy-.5*resolution.xy)/resolution.y;\n\tvec2 mouse = 1. - iMouse.xy/resolution.xy; // 0 1\n\tvec2 ouv = uv;\n    //uv.y -= .05;\n\tuv *= 3.0;\n\n    uv.x = abs(uv.x);\n\n    vec3 col = vec3(0);\n    float d;\n\n    float angle = 0.;\n    vec2 n = N((5./6.)*3.1415);\n\n    uv.y += tan((5./6.)*3.1415)*.5;\n   \td = dot(uv-vec2(.5, 0), n);\n    uv -= max(0.,d)*n*2.;\n\n    float scale = 1.;\n\n    n = N( mouse.y*(2./3.)*3.1415);\n    uv.x += .5;\n    for(int i=0; i<10; i++) {\n        uv *= 3.;\n        scale *= 3.;\n        uv.x -= 1.5;\n\n        uv.x = abs(uv.x);\n        uv.x -= .5;\n        d = dot(uv, n);\n        uv -= min(0.,d)*n*2.;\n    }\n\n    d = length(uv - vec2(clamp(uv.x,-1., 1.), 0));\n    col += smoothstep(10./resolution.y, .0, d/scale);\n    uv /= scale;\t// normalization\n\n   \n\tvec3 manCol = mandelbrotImg(uv);\n\t col += manCol;\n\n\n \t\t// vignette effect\n\t  col *= 1.0 - 0.5*length(uv *1.2);\n\n\t \n    fragColor = vec4( col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/NsXXz2.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "NsXXzM", "name": "Fortifications", "author": "jarble", "description": "This fractal resembles some sort of roguelike dungeon map.", "tags": ["fractal", "bitwisemath"], "likes": 3, "viewed": 136, "date": "1618373003", "time_retrieved": "2024-06-20T20:38:23.540113", "image_code": "// Inspired by a discussion on hackaday at:\n// https://hackaday.com/2021/04/13/alien-art-drawn-with-surprisingly-simple-math/\n// Formula shared by \"Joe\" on that page..\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Scale and move to make things a litle more interesting t look at.\n    float scale = 0.2;\n    float trans = iTime * 7.0;\n    vec2 coord = (scale * fragCoord) + vec2(trans,trans);\n    \n    // Heart of color selection.\n    int val = ((int(coord.x) & int(coord.y)) % 3);\n    float result = 0.0;\n    for(int i = 0; i < 3; i++){\n        coord /= (3.5+result);        \n        val = ((int(coord.x) | int(coord.y+result)) % (3-val));\n        result = ((result + float(val))/2.0);\n    }\n    // Output.\n    fragColor = vec4((result));\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/NsXXzM.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "sd23RV", "name": "Chaos Condenser", "author": "Tater", "description": "this might be my favorite shader I've made. ", "tags": ["2d", "invert", "spinning", "spikes"], "likes": 6, "viewed": 213, "date": "1617705020", "time_retrieved": "2024-06-20T20:38:23.546189", "image_code": "#define rot(a) mat2( cos(a),-sin(a),sin(a),cos(a) )\n#define pi 3.14159265359\nfloat sts(float x){ return x-sin(x); }\nfloat rotation (float t){\n    float r = sin(t*2.)*sin(t);\n    r += t;\n    r+=2.0*abs(t*0.2);\n    r+=smoothstep(0.0,1.0,sin(t*0.25))*15.0;\n    r+=tan(sin(t)*0.4);\n    r+=smoothstep(0.5,1.0,sin(t*0.25+2.0))*sin(floor(t*10.0)/10.0);\n    if(mod(t,20.)>10.){ r=-r; }\n    r -= sts(sts(sts(t*2.0)))*pi/8.;\n    return r;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 R = iResolution.xy;\n    vec2 uv = (fragCoord-.5*R.xy)/R.y;\n    float t = iTime*0.5;\n    \n    float aa = 1.0/R.y;\n    float th = atan(-uv.y,-uv.x)/(2.0*pi)+0.5;\n    float spks = 15.0;\n    float thin = 2.5;\n    float rt = 3.3; \n    float r = 0.2;\n    vec3 col =vec3(0);\n    t*=3.0;\n\n    vec3 glowc = vec3(0);\n    vec3 glowc1= vec3(0.875,0.000,0.000);\n    vec3 glowc2 = vec3(0.200,0.133,1.000);\n    float num =250.0+50.0*sin(t);\n    \n    for(float i = 0.0; i <spks; i++){\n        r=rotation(t+0.1*i);\n        vec2 tuv = uv*rot(((r*rt)*pi/spks));\n        \n        glowc = glowc1;\n        for(int j = 0; j<2;j++){\n            tuv*=2.0-((i)/spks);\n            aa=(1.0/R.y)*(2.0-((i)/spks));\n            float edge = abs(tuv.x)+(tuv.y+0.5)*(0.4/thin);\n            float glow = abs(1.0 / (num * edge));\n            col = mix(col,vec3(0.4),smoothstep(edge-aa,edge+aa,0.1/thin)*smoothstep(tuv.x-aa,tuv.x+aa,0.0));\n            col = mix(col,vec3(0.5),smoothstep(edge-aa,edge+aa,0.1/thin)*smoothstep(0.0-aa,0.0+aa,tuv.x));\n            col +=vec3(0.2) * smoothstep(edge-aa,edge+aa,0.1/thin) * smoothstep(edge-aa,edge+aa,0.01/thin);\n            col += glowc*smoothstep(edge-aa,edge+aa,0.1/thin) * smoothstep(-0.35-aa,-0.35+aa,tuv.y);\n            col = clamp(col,0.,1.);\n            col+= mix(col,glow*(glowc+0.2),1.0-step(length(col),0.0));\n            tuv = uv*rot(pi+((r*rt)*pi/spks));\n            glowc=glowc2;\n        }\n        col = col - 0.05;\n    }\n    col = clamp(col,0.,1.);\n    vec2 tuv = uv;\n    uv.x+=sin(uv.y*200.0+t)*0.0035;\n    uv.y+=sin(tuv.x*200.0+t)*0.0035;\n    float glow = abs(1.0 / (85.0 * length(uv)));\n    float smst= 0.0025;\n    float cscale = (sin(t)*0.5+0.5)*0.035;\n    col+=(1.0-(vec3(0.208,1.000,0.267)+1.0)*(glow))\n    *smoothstep(cscale+0.905-smst,cscale+0.905+smst,1.0-length(uv));\n    if(mod(t,8.0)>4.0)col=(1.0-col);\n    if(mod(t,3.5)>3.2)col=(1.0-col);\n    if(mod(t,4.0)>3.8+sin(t)){\n        float ring = smoothstep(1.0-0.275-aa,1.0-0.275+aa,1.0-length(tuv))\n        -smoothstep(1.0-0.175-aa,1.0-0.175+aa,1.0-length(tuv));\n        col = mix(col,1.0-col,ring);}\n    if(mod(t,5.0)>4.3+sin(t)){\n        float ring = smoothstep(1.0-0.4-aa,1.0-0.4+aa,1.0-length(tuv))\n        -smoothstep(1.0-0.35-aa,1.0-0.35+aa,1.0-length(tuv));\n        col = mix(col,1.0-col,ring);}\n    if(mod(t,8.0)>7.0+sin(t+0.3)){\n        vec2 tuv2 = tuv*3.0; tuv2.y*=1.5; tuv2.y+=0.35;\n        tuv2=fract(tuv2*1.0+0.275);\n        float inv = clamp(step(tuv2.y,0.25)-step(tuv2.x,0.55),0.0,1.0);\n        col = mix(col,1.0-col,inv);\n    }\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/sd23RV.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "sd2GDc", "name": "Apple raymarch (iq tutorial)", "author": "atutahi", "description": "Basic raymarcher from iq's apple tutorial : https://www.youtube.com/watch?v=CHmneY8ry84", "tags": ["raymarchappletuto"], "likes": 0, "viewed": 54, "date": "1618086088", "time_retrieved": "2024-06-20T20:38:23.546189", "image_code": "float hash(float n)\n{\n    return fract(sin(n) * 43758.5453);\n}\n\nfloat noise(vec3 x)\n{\n    vec3 p = floor(x);\n    vec3 k = fract(x);\n    k = k * k * (3.0 - 2.0 * k);\n    \n    float n = p.x + p.y * 57.0 + p.z * 113.0;\n    float a = hash(n);\n    float b = hash(n + 1.0);\n    float c = hash(n + 57.0);\n    float d = hash(n + 58.0);\n    \n    float e = hash(n + 113.0);\n    float f = hash(n + 114.0);\n    float g = hash(n + 170.0);\n    float h = hash(n + 171.0);\n    \n    float res = mix(mix(mix(a, b, k.x), mix(c, d, k.x), k.y),\n                    mix(mix(e, f, k.x), mix(g, h, k.x), k.y),\n                    k.z);\n    return res;\n}\n\nfloat fbm(vec3 p)\n{\n    float f = 0.;\n    f += 0.5000 * noise(p); p *= 2.02;\n    f += 0.2500 * noise(p); p *= 2.03;\n    f += 0.1250 * noise(p); p *= 2.01;\n    f += 0.0625 * noise(p);\n    \n    return f / 0.9375;\n}\n\nvec3 floorMaterial(vec3 pos, vec3 n)\n{\n    vec3 col = vec3(0.6, 0.5, 0.3);\n    \n    float f = fbm(pos * vec3(6.0, 0.0, 0.5));\n    col = mix(col, vec3(0.3, 0.2, 0.1), f);\n    \n    f = smoothstep(0.6, 1.0, fbm(pos * 48.0));\n    col = mix(col, vec3(0.2, 0.2, 0.15), f);\n    \n    float ao = 0.2 + 0.8 * smoothstep(0.4, 2.0, length(pos.xz));\n    col *= ao;\n    \n    return col;\n}\n\nvec3 fruitMaterial(vec3 pos, vec3 n)\n{\n    float a = atan(pos.x, pos.z);\n    float r = length(pos.xz);\n    \n    // red\n    vec3 col = vec3(1.0, 0.0, 0.0);\n    \n    // mix to green\n    float f = smoothstep(0.2, 1.0, fbm(pos));\n    col = mix(col, vec3(0.8, 1.0, 0.2), f);\n    \n    // make it dirty\n    f = smoothstep(0.0, 1.0, fbm(pos * 4.0));\n    col *= 0.8 + 0.2 * f;\n    \n    //frekles\n    f = smoothstep(0.7, 0.9, fbm(pos * 48.0));\n    col = mix(col, vec3(0.9, 0.9, 0.6), f);\n    \n    // stripes\n    f = fbm(vec3(a * 7.0, pos.y, pos.z) * 2.0);    \n    f *= smoothstep(0.4, 1.2, pos.y + 0.5 * (noise(pos.yxz) - 0.5));\n    col = mix(col, vec3(0.4, 0.2, 0.0), 0.5 * f);\n    \n    // top cap\n    f = smoothstep(0.1, 0.2, r);\n    col = mix(col, vec3(0.6, 0.6, 0.5), 1.0 - f);\n    \n    // fake ao\n    float ao = n.y * 0.5 + 0.5;\n    col *= ao;\n    \n    return col;\n}\n\nfloat fruitShape(vec3 p)\n{\n    float f = pow(dot(p.xz, p.xz), 0.2);    \n    p.y -= 0.5 * f;\n    return length(p) - 1.0;\n}\n\nfloat floorShape(vec3 p)\n{\n    return p.y + 0.25;\n}\n\nvec2 map(vec3 p)\n{\n    vec2 d1 = vec2(fruitShape(p), 1.0);\n    vec2 d2 = vec2(floorShape(p), 2.0);\n    d1 = d2.x < d1.x ? d2 : d1;\n    return d1;\n}\n\nvec2 intersect(vec3 ro, vec3 rd)\n{\n    for (float t = 0.0; t < 16.0;)\n    {\n        vec3 pos = ro + t*rd;\n        pos = pos;\n        vec2 h = map(pos);\n        if (h.x < 0.0001) return vec2(t, h.y);\n        t += h.x;        \n    }\n    \n    return vec2(0.0);\n}\n\nvec3 calcNormal(vec3 p)\n{\n    vec3 e = vec3(0.001, 0.0, 0.0);\n    vec3 n;\n    n.x = map(p + e.xyy).x - map(p - e.xyy).x;\n    n.y = map(p + e.yxy).x - map(p - e.yxy).x;\n    n.z = map(p + e.yyx).x - map(p - e.yyx).x;\n    return normalize(n);\n}\n\nfloat softShadow(vec3 ro, vec3 rd)\n{\n    float res = 1.0;\n    for (float t = 0.1; t < 8.0;)\n    {\n        float h = map(ro + t * rd).x;\n        if (h < 0.001) return 0.0;\n        res = min(res, 8.0 * h/t);\n        t+= h;\n    }\n    \n    return res;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 q = fragCoord/iResolution.xy;\n    vec2 p = (2.0 * q - 1.0) * vec2(1.77, 1.0);\n    \n    float rot = iTime * 0.2;\n    float zoom = 2.0 + 0.2 * sin(iTime * 0.8) * 0.5;\n    vec3 ro = zoom * vec3(cos(rot), 1.0, sin(rot));\n    vec3 ww = normalize(vec3(0.0, 0.0, 0.0) - ro);  \n    vec3 uu = normalize(cross(vec3(0.0, 1.0, 0.0), ww));\n    vec3 vv = normalize(cross(ww, uu));\n    vec3 rd = normalize(p.x * uu + p.y * vv + 1.5 * ww);\n    \n    vec2 t = intersect(ro, rd);\n    vec3 col = vec3(0.8);\n    if (t.y > 0.5)\n    {\n        vec3 pos = ro + t.x * rd;\n        vec3 n = calcNormal(pos);\n        vec3 l = normalize(vec3(1.0, 0.8, 0.6));\n        vec3 blig = vec3(-l.x, l.y, -l.z);\n        vec3 ref = reflect(rd, n);\n        \n        float con = 1.0;\n        float amb = n.y * 0.5 + 0.5;\n        float dif = max(0.0, dot(n, l));\n        float bac = max(0.0, 0.2 + 0.8 * dot(n, blig));\n        float sha = softShadow(pos, l);\n        float spe = pow(clamp(dot(l, ref), 0.0, 1.0), 8.0);\n        float rim = pow(1.0 + dot(n, rd), 2.5);\n        \n        col = con * vec3(0.1, 0.15, 0.2);\n        col += amb * vec3(0.2, 0.15, 0.2);\n        col += dif * vec3(1.0, 0.97, 0.85) * sha;\n        col += bac * vec3(1.0, 0.97, 0.85);\n       \n        \n        if (t.y > 1.5)\n        {\n            col *= floorMaterial(pos, n);\n        }\n        else \n        {\n            col *= fruitMaterial(pos, n);\n        }\n        \n        col += 0.6 * rim * amb;\n        col += 0.6 * spe * sha * amb;\n        \n        col = col * 0.1 + 0.9 * sqrt(col);\n        col *= vec3(0.9, 0.8, 0.7);\n    }\n    \n    col *= 0.2 + 0.8 * pow(16.0 * q.x*q.y*(1.0 - q.x)*(1.0-q.y), 0.2);\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/sd2GDc.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "sd2GRd", "name": "Wednesday!", "author": "xernobyl", "description": "Trace a day. Wednesday.", "tags": ["daily", "trade"], "likes": 0, "viewed": 62, "date": "1617840826", "time_retrieved": "2024-06-20T20:38:23.546189", "image_code": "float height(vec3 p) {\n    return sin(p.z) + cos(p.x) - 2.0;\n}\n\n\nvec3 height_normal(vec3 p) {\n    return normalize(vec3(-sin(p.x), 0.5, cos(p.z)));\n}\n\n\nvec3 pal(in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d) {\n  return a + b * cos(6.28318 * (c * t + d));\n}\n\n\nvec3 sRGB(vec3 linear)\n{\n  vec3 a = 12.92 * linear;\n  vec3 b = 1.055 * pow(linear, vec3(1.0 / 2.4)) - 0.055;\n  vec3 c = step(vec3(0.0031308), linear);\n  return mix(a, b, c);\n}\n\n\nvoid mainImage(out vec4 frag_color, in vec2 frag_coord) {\n  vec3 ray_dir = vec3(frag_coord / iResolution.xy * 2.0 - 1.0, -1.0 / 2.0);\n  ray_dir.x *= iResolution.x / iResolution.y;\n  ray_dir = normalize(ray_dir);\n  \n  ray_dir.y = -abs(ray_dir.y);\n\n  vec3 ray_origin = vec3(0.0, 5.0, -10.0 * iTime);\n  vec3 ray_pos = ray_origin;\n  \n  float total_distance = 1.0;\n  float last_distance = 1.0;\n  int sky = 1;\n  \n  const float max_dist = 100.0;\n\n  for (int iterations = 0; iterations < 256; ++iterations) {\n    float step_size = 0.0029 * exp2(total_distance);\n    total_distance += step_size;\n    \n    ray_pos = ray_origin + total_distance * ray_dir;\n\n    float y = height(ray_pos);\n    \n    if (ray_pos.y < y || -ray_pos.y > y) {\n      total_distance = total_distance * 0.5 + 0.5 * last_distance;\n      ray_pos = ray_origin + total_distance * ray_dir;\n      sky = 0;\n      break;\n    }\n    \n    if (total_distance >= max_dist) {\n      break;\n    }\n\n    last_distance = total_distance;\n  }\n  \n  \n  vec3 n = height_normal(ray_pos);\n  \n  vec3 col = pal(total_distance * .25 + iTime, vec3(0.5,0.5,0.5),vec3(0.5,0.5,0.5),vec3(1.0,1.0,0.5),vec3(0.8,0.90,0.30) );\n  \n  col = 2.0 * col * -dot(n, ray_dir);\n  // col *= clamp(1.0 / (total_distance - 1.0), 0.0, 1.0);\n  \n  if (sky == 1) {\n    frag_color = vec4(0.25, 0.5, 0.75, 0.0);\n  }\n  else {\n    frag_color = vec4(sRGB(col), 0.0);\n  }\n  \n  // frag_color = vec4(sRGB(vec3(1.0 - total_distance / max_dist)), 0.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/sd2GRd.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "sd2GRm", "name": "Quaternion Twister", "author": "mla", "description": "Twisting space with quaternions (& performing the Dirac belt trick).\n\nMouse to rotate.", "tags": ["twister", "quaternion", "interpolation"], "likes": 27, "viewed": 471, "date": "1617267117", "time_retrieved": "2024-06-20T20:38:24.758332", "image_code": "////////////////////////////////////////////////////////////////////////////////\n//\n// Quaternion Twister, Matthew Arcus, mla, 2020\n//\n// Divide space into a series on concentric spheres, centred on the\n// origin, apply to each sphere a rotation that varies smoothly with\n// radial distance. This defines a path in the space of unit quaternions,\n// which is the hypersphere. Now vary the path smoothly over time,\n// giving a smooth bijective distortion of space with no discontinuities.\n//\n// In the code, vec4(x,y,z,w) represents quaternion w+ix+jy+kz, and\n// we go from no rotation (w=1) at r >= 1, to a steady rotation in the\n// xw plane at the origin. The path in between is mapped to a circular\n// path on the hypersphere (in the xyw subspace in fact) giving a smooth\n// transition of paths as the central rotation varies & gives a nice\n// demonstration of \"Dirac's belt trick\".\n//\n// Useful video from Jason Hise: https://youtu.be/zAvaCPmgdf0\n// Some of the maths: https://arxiv.org/abs/1001.1778\n//\n////////////////////////////////////////////////////////////////////////////////\n\n#if HW_PERFORMANCE==0\nconst int AA = 1;\n#else\nconst int AA = 2;\n#endif\n\nint Q = 3, R = 4; // Symmetry group\nfloat lradius = 0.025,pradius = 0.2; // Line and point radius\nfloat PI = 3.1415927;\n\nfloat eyedist = 2.0;  // Eye is at (0,0,eyedist);\nvec3 light = vec3(0,1,2); //Position of light\n\n// Raymarching configuration.\nint maxsteps = 200;\nfloat precis = 1e-4; \nfloat lfactor = 0.2; // \"Lipschitz adjustment factor\"\n\n// R3 rotation of p with quaternion q\nvec3 qrot(vec3 p, vec4 q) {\n  return p + 2.0*cross(q.xyz,cross(q.xyz,p)+q.w*p);\n}\n\nfloat segment(vec3 p, vec3 q, vec3 r) {\n  p -= q; r -= q; // q is origin\n  float h = clamp(dot(p,r)/dot(r,r),0.0,1.0);\n  return length(p-h*r);\n}\n\nvec3 A,B,C,a,b,c;\n\nvoid init(int Q, int R) {\n  // Setup folding planes\n  //float p = PI/float(P);\n  float q = PI/float(Q);\n  float r = PI/float(R);\n  A = vec3(1,0,0);\n  // A.B = -cos(p)\n  //B = vec3(-cos(p),sin(p),0);\n  B = vec3(0,1,0);\n  // A.C = -cos(r)\n  float x = -cos(r);\n  // B.C = -cos(q) = cos(p)cos(r) + y sin(p)\n  float y = -cos(q);\n  // |C| = 1\n  float z = sqrt(1.0-x*x-y*y);\n  C = vec3(x,y,z);\n  a = normalize(cross(B,C));\n  b = normalize(cross(C,A));\n  c = normalize(cross(A,B));\n}\n\nint NFOLDS = 8;\nvec3 fold(vec3 pos) {\n  // We want to know the number of actual reflections made\n  // so keep track of that in flips.\n  for (int i = 0; i < NFOLDS; i++) {\n    pos.xy = abs(pos.xy);\n    float k = dot(pos,C);\n    if (k > 0.0) break;\n    pos -= 2.0*k*C;\n  }\n  return pos;\n}\n\nfloat de(vec3 p, out int type) {\n  float t = 0.2*iTime;\n  vec4 quat = vec4(sin(PI*t),0,0,cos(PI*t)); // Central rotation\n\n  // Interpolation etc. done in quaternion space ie. on the hypersphere\n  float s = max(0.0,1.0-(length(p)-pradius)/(1.0-pradius)); // Distance to central sphere\n  s = 0.5-0.5*cos(PI*s); // Circle distance to line distance\n  quat = mix(vec4(0,0,0,1),quat,s); // Interpolate\n  quat.y = sqrt(max(0.0,(1.0-dot(quat,quat)))); // Project to sphere along y\n  if (mod(t,4.0) > 2.0) quat.y = -quat.y; // Change hemisphere\n  p = qrot(p,quat); // Apply rotation\n  vec3 p0 = p;\n  p = fold(p);\n\n  float d = 1e8, d0;\n  d0 = segment(p,vec3(0),a)-lradius;\n  if (d0 < d) { type = 1; d = d0; }\n  d0 = segment(p,vec3(0),b)-lradius;\n  if (d0 < d) { type = 2; d = d0; }\n  d0 = segment(p,vec3(0),c)-lradius;\n  if (d0 < d) { type = 3; d = d0; }\n  d0 = length(p)-pradius;\n  if (d0 < d) { type = 4; d = d0; }\n  d *= lfactor; // Attenuate distance estimate\n  //d = max(d,length(p0)-0.2);\n  return d;\n}\n\nfloat de(vec3 p) {\n  int type;\n  return de(p,type);\n}\n\nfloat maxdist = 10.0;\nfloat march(vec3 q, vec3 r) {\n  float t = 0.0;\n\n  // Start from intersection with sphere.\n  float R = 1.0+lradius;\n  float B = dot(q,r), C = dot(q,q)-R*R;\n  float D = B*B - C;\n  // No intersection, so give up.\n  if (D < 0.0) return -1.0;\n  D = sqrt(D);\n  float t0 = -B-D;\n  maxdist = -B+D; // nice idea from iq\n  // If t0 < 0, then we are inside sphere\n  if (t0 > 0.0) t = t0;\n  \n  for (int i = 0; i < maxsteps; i++) {\n    vec3 p = q+t*r;\n    float d = de(p);\n    if (abs(d) < precis) return t; // Close enough to the surface.\n    t += d;\n    if (t > maxdist) break;\n  }\n  return -1.0;\n}\n\n// Get the normal of the surface at point p.\nvec3 getnormal(vec3 p) {\n  float eps = 0.001;\n  vec2 e = vec2(eps,0);\n  return normalize(vec3(de(p + e.xyy) - de(p - e.xyy),\n                        de(p + e.yxy) - de(p - e.yxy),\n                        de(p + e.yyx) - de(p - e.yyx)));\n}\n\n// Rotate vector p by angle t.\nvec2 rotate(vec2 p, float t) {\n  return cos(t)*p + sin(t)*vec2(-p.y,p.x);\n}\n\n// Rotate according to mouse position\nvec3 transformframe(vec3 p) {\n  if (iMouse.x > 0.0) {\n    // Full range of rotation across the screen.\n    float phi = (2.0*iMouse.x-iResolution.x)/iResolution.x*PI;\n    float theta = (2.0*iMouse.y-iResolution.y)/iResolution.y*PI;\n    p.yz = rotate(p.yz,theta);\n    p.zx = rotate(p.zx,-phi);\n  }\n  p.zx = rotate(p.zx,0.25*PI);\n  p.xy = rotate(p.xy,0.25*PI);\n  return p;\n}\n\nvec3 getbasecolor(int type) {\n  if (type == 1) return vec3(1,1,0);\n  if (type == 2) return vec3(0,1,0);\n  if (type == 3) return vec3(0,0,1);\n  if (type == 4) return vec3(1,0,0);\n  return vec3(0.75,1,0.75);\n}\n\nvec3 getbackground(vec3 r) {\n  return mix(vec3(1),pow(r,vec3(2)),0.5); // Colourful fun\n  return vec3(0,0,0.1); // The more sober option.\n}\n\nvec3 raycolor(vec3 q, vec3 r) {\n  float t = march(q,r);\n  if (t < 0.0) return getbackground(r);\n  // Get the surface point that has been hit,\n  vec3 p = q+t*r;\n  // and the normal at that point.\n  vec3 normal = getnormal(p);\n\n  // Call de again to find what we've hit.\n  int type;\n  de(p,type);\n  \n  // Apply lighting. This is a basic \"Lambertian\" model.\n  vec3 lightdir = normalize(light-p);\n  vec3 color = mix(vec3(1),getbasecolor(type),0.6);\n  float ambient = 0.3;\n  float diffuse = 0.7*clamp(dot(normal,lightdir),0.0,1.0);\n  color *= ambient+ diffuse;\n  return color;\n}\n\nvoid mainImage(out vec4 fragColor, vec2 fragCoord){\n  init(Q,R);\n  maxdist = eyedist + 1.0;\n  vec3 eye = vec3(0,0,eyedist);\n  eye = transformframe(eye);\n  light = transformframe(light);\n  vec3 col = vec3(0);\n  for (int i = 0; i < AA; i++) {\n    for (int j = 0; j < AA; j++) {\n      vec2 z = (2.0*(fragCoord+vec2(i,j)/float(AA))-iResolution.xy)/iResolution.y;\n      vec3 ray = vec3(z,-2);\n      ray = transformframe(ray);\n      ray = normalize(ray);\n      col += raycolor(eye,ray);\n    }\n  }\n  col /= float(AA*AA);\n  col = pow(col,vec3(0.4545)); // Gamma\n  fragColor = vec4(col,1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/sd2GRm.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "sd2GWR", "name": "Simple Water Waves", "author": "yinkar", "description": "Waves", "tags": ["simple", "wave", "sea", "water", "ocean"], "likes": 3, "viewed": 171, "date": "1617261072", "time_retrieved": "2024-06-20T20:38:24.758332", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    vec3 color = vec3(0.0, 0.1, 0.3);\n    \n    const int waveCount = 6;\n    float yDir = cos(iTime * 3.0) * 0.08;\n    \n    for (int i = 0; i < waveCount; i++) {\n        if (mod(float(i), 2.0) == 0.0) {\n            yDir *= -1.0;\n        }\n        \n        if (uv.y < \n        sin(\n            uv.x * 60.0 / (1.0 + (float(i) / 10.0)) - iTime\n            * (float(waveCount * 3) - float(i) * 3.0)\n        )\n        * 0.01\n        + 0.2\n        + (float(i) + yDir * (float(i) * 0.8))\n        / 25.0) {\n            color.bg +=  0.01 + float(i) / 25.0;\n        }\n    }\n    \n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/sd2GWR.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "sd2Gzt", "name": "Wednesday Night Pina Coladas", "author": "Melchizedek6809", "description": "Played around in Bonzomatic triying to do something with shadows.", "tags": ["raymarch"], "likes": 1, "viewed": 26, "date": "1617838262", "time_retrieved": "2024-06-20T20:38:24.758332", "image_code": "#define E 0.0001\n#define SUNT iTime / 16.0\n#define fGlobalTime iTime\n\nvec3 lightPos(){\n    return vec3(42.0 * sin(SUNT),16.0 + abs(cos(SUNT)) * 6.0,42.0 * cos(SUNT));\n}\n\nfloat sunSDF(vec3 p){\n    return length(p - lightPos()) - 3.0;\n}\n\nfloat monolithSDF(vec3 p){\n    vec3 q = abs(p-vec3(0.0,6.75 + sin(fGlobalTime)*0.2,0.0)) - vec3(2.0,4.5,0.5);\n    return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0)-0.1;\n}\n\nfloat pyramidSDF(vec3 p){\n    vec3 np = abs(p - vec3(0.0,-0.5,0.0));\n    return (np.x+np.y+np.z-2.0)*0.5735027;\n}\n\nfloat landSDF(vec3 p){\n    return (p.y - min(sin(p.x * 0.1),cos(p.z*0.08))) * 2.0;\n}\n\nfloat sceneSDF(vec3 p){\n    float d = sunSDF(p);\n    d = min(d,monolithSDF(p));\n    d = min(d,landSDF(p));\n    d = min(d,pyramidSDF(p));\n    return d;\n}\n\nfloat march(vec3 eye, vec3 dir, float start, float end){\n  float d = start;\n  for(int i=0;i<1024;i++){\n    float cd = sceneSDF(eye + dir * d);\n    if(cd < E){return d;}\n    d += cd;\n    if(d >= end){return end;}\n  }\n  return end;\n}\n\nvec3 rayDir(float fov, vec2 size, vec2 pos){\n    vec2 xy = pos - size/2.0;\n    float z = size.y / tan(radians(fov) / 2.0);\n    return normalize(vec3(xy,-z));\n}\n\nvec3 norm(vec3 p){\n    return normalize(vec3(\n        sceneSDF(vec3(p.x+E,p.y,p.z)) - sceneSDF(vec3(p.x-E,p.y,p.z)),\n        sceneSDF(vec3(p.x,p.y+E,p.z)) - sceneSDF(vec3(p.x,p.y-E,p.z)),\n        sceneSDF(vec3(p.x,p.y,p.z+E)) - sceneSDF(vec3(p.x,p.y,p.z-E))\n    ));\n}\n\nfloat lightIntensity(vec3 p){\n    vec3 N = norm(p);\n    vec3 lp = lightPos();\n    vec3 ldir = normalize(lp-p);\n    if(landSDF(p) < E){\n        float md = march(p+ldir,ldir,0.0,400.0);\n        float ld = length(p-lp) * 0.5;\n        if(ld >= md){return 0.0;}\n    }\n    float d = dot(N,normalize(lp-p));\n    return 0.3 + d * 0.75;\n}\n\nvec4 color(vec3 p){\n    if(monolithSDF(p) < E){\n        return vec4(0.06,0.03,0.01,1.0);\n    }else if(pyramidSDF(p) < E){\n        return vec4(0.8,0.65,0.4,1.0);\n    }else{\n        return vec4(1.0,0.9,0.4,1.0);\n    }\n}\n\nvoid mainImage( out vec4 out_color, in vec2 fragCoord ){\n    vec2 uv = fragCoord/iResolution.xy;\n\tvec3 eye = vec3(0.0,5.0,48.0);\n    vec3 dir = rayDir(45.0,iResolution.xy,fragCoord.xy);\n    float d = march(eye,dir,0.0,200.0);\n    float o = 1.0-uv.y;\n    vec4 fogc = vec4(0.1+o*0.3,0.3 + o*0.5,0.6 + o * 1.4,1.0);\n    if(d > 200.0-E){\n        out_color = fogc;\n    }else{\n        float li = lightIntensity(eye + dir * d);\n        if(sunSDF(eye + dir * d) < E){\n            out_color = vec4(1.0,0.95,0.9,1.0);\n        }else{\n            float fo = min(1.0,(200.0-d) / 100.0);\n            out_color = (color(eye+dir*d) * li * fo) + (1.0-fo)*fogc;\n        }\n    }\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/sd2Gzt.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "sdB3Dc", "name": "Blackhole oscillating gravity", "author": "neoned71", "description": "Black hole oscillating between attractive gravity and repulsive gravity", "tags": ["blackhole", "modifiedgravity"], "likes": 1, "viewed": 49, "date": "1618036926", "time_retrieved": "2024-06-20T20:38:26.006926", "image_code": "\n#define AA 1  //change to 1 to increase performance\n\n#define _Speed 3.0  //disk rotation speed\n\n#define _Steps  1. //disk texture layers\n#define _Size 0.3 //size of BH\n\n\n\n//float hash(float x){ return fract(sin(x)*152754.742);}\n//float hash(vec2 x){   return hash(x.x + hash(x.y));}\n\nmat4 rotationX( in float angle ) {\n    return mat4(    1.0,        0,          0,          0,\n                    0,  cos(angle), -sin(angle),        0,\n                    0,  sin(angle),  cos(angle),        0,\n                    0,          0,            0,        1);\n}\n\nmat4 rotationY( in float angle ) {\n    return mat4(    cos(angle),     0,      sin(angle), 0,\n                            0,      1.0,             0, 0,\n                    -sin(angle),    0,      cos(angle), 0,\n                            0,      0,              0,  1);\n}\n\nmat4 rotationZ( in float angle ) {\n    return mat4(    cos(angle),     -sin(angle),    0,  0,\n                    sin(angle),     cos(angle),     0,  0,\n                            0,              0,      1,  0,\n                            0,              0,      0,  1);\n}\n\nfloat hash(float x){ return fract(sin(x)*15.0); }\nfloat hash(vec2 x){ return hash(x.x + hash(x.y)); }\n\n\nfloat rand(float co)\n{\n    return cos(2.0+sin(co*12.9898*78.233));\n    \n    }\n\nfloat value(vec2 p, float f) //value noise\n{\n    float bl = hash(floor(p*f + vec2(0.,0.)));\n    float br = hash(floor(p*f + vec2(1.,0.)));\n    float tl = hash(floor(p*f + vec2(0.,1.)));\n    float tr = hash(floor(p*f + vec2(1.,1.)));\n    \n    vec2 fr = fract(p*f);    \n    fr = (3. - 2.*fr)*fr*fr;    \n    float b = mix(bl, br, fr.x);    \n    float t = mix(tl, tr, fr.x);\n    return  mix(b,t, fr.y);\n}\n\nvec4 background(vec3 ray)\n{\n    vec2 uv = ray.xy;\n    \n    if( abs(ray.x) > 0.5)\n        uv.x = ray.z;\n    else if( abs(ray.y) > 0.5)\n        uv.y = ray.z;\n\n        \n    float brightness = value( uv*5.1, 40.); \n    float color = value( uv*2., 20.); \n    brightness = pow(brightness, 256.);\n  \n    brightness = brightness*100.;\n    brightness = clamp(brightness, 0., 1.);\n    \n    vec3 stars = brightness * mix(vec3(1., .6, .2), vec3(.2, .6, 1), color);\n\n    return vec4(stars, 1.0);\n}\n\nvec4 raymarchDisk(vec3 ray, vec3 zeroPos)\n{\n    //return vec4(1.,1.,1.,0.);\n    \n    vec3 position = zeroPos;      \n    float lengthPos = length(position.xz);\n    float dist = min(1., lengthPos*(1./_Size) *0.5) * _Size * 0.04 *(1./_Steps) /( abs(ray.y) );\n\n    position += dist*_Steps*ray*0.8;     \n\n    vec2 deltaPos;\n    deltaPos.x = -zeroPos.z*0.01 + zeroPos.x;\n    deltaPos.y = zeroPos.x*0.01 + zeroPos.z;\n    deltaPos = normalize(deltaPos - zeroPos.xz);\n    \n    float parallel = dot(ray.xz, deltaPos);\n    parallel /= sqrt(lengthPos);\n    parallel *= 0.6;\n    float redShift = parallel +0.4;\n    redShift *= redShift;\n\n    redShift = clamp(redShift, 0., 1.);\n    \n    float disMix = clamp((lengthPos - _Size * 2.)*(1./_Size)*0.24, 0., 1.);\n    vec3 insideCol =  mix(vec3(1.0,0.8,0.0), vec3(0.5,0.13,0.02)*0.2, disMix);\n    \n    insideCol *= mix(vec3(0.4, 0.2, 0.1), vec3(1.6, 2.4, 4.0), redShift);\n    insideCol *= 1.4;\n    redShift += 0.14;\n    redShift *= redShift;\n\n    vec4 o = vec4(0.);\n\n    for(float i = 0. ; i < _Steps*0.01; i++)\n    {                      \n        position -= dist * ray ;  \n\n        float intensity =clamp( 1. - abs((i - 0.8) * (1.) * 2.), 0., 1.); \n        float lengthPos = length(position.xz);\n        float distMult = 1.;\n\n        distMult *=  clamp((lengthPos -  _Size * 0.75) * (1./_Size) * 1.5, 0., 1.);        \n        distMult *= clamp(( _Size * 10. -lengthPos) * (1./_Size) * 0.20, 0., 1.);\n        distMult *= distMult;\n\n        float u = lengthPos + iTime* _Size*0.3 + intensity * _Size * 0.2;\n\n        vec2 xy ;\n        float rot = mod(iTime*_Speed, 8192.);\n        xy.x = -position.z*sin(rot) + position.x*cos(rot);\n        xy.y = position.x*sin(rot) + position.z*cos(rot);\n\n        float x = abs( xy.x/(xy.y));         \n        float angle = 0.02*atan(x);\n  \n        const float f = 70.;\n        float noise = value( vec2( angle, u * (1./_Size) * 0.05), f);\n        noise = noise*0.66 + 0.33*value( vec2( angle, u * (1./_Size) * 0.05), f*2.);     \n        \n        float extraWidth =  noise * 3.0 * (1. -  clamp(i * (1.)*2. - 1., 0., 1.));\n\n        float alpha = clamp(noise*(intensity + extraWidth)*( (1./_Size) * 10.  + 0.01 ) *  dist * distMult , 0., 1.);\n\n        vec3 col = 2.*mix(vec3(0.3,0.2,0.15)*insideCol, insideCol, min(1.,intensity*2.));\n        o = clamp(vec4(col*alpha + o.rgb*(1.-alpha), o.a*(1.-alpha) + alpha), vec4(0.), vec4(1.));\n\n        lengthPos *= (1./_Size);\n   \n        o.rgb+= redShift*(intensity*1. + 0.5)* (1.0) * 100.*distMult/(lengthPos*lengthPos);\n    }  \n \n    o.rgb = clamp(o.rgb - 0.02, 0.2, 1.);\n    return o ;\n}\n\n\nvoid Rotate( inout vec3 vector, vec2 angle )\n{\n    vector.yz = cos(angle.y)*vector.yz\n                +sin(angle.y)*vec2(-1,1)*vector.zy;\n    vector.xz = cos(angle.x)*vector.xz\n                +sin(angle.x)*vec2(-1,1)*vector.zx;\n}\n\nvoid mainImage( out vec4 colOut, in vec2 fragCoord )\n{\n    colOut = vec4(0.);;\n    \n    vec2 fragCoordRot;\n    fragCoordRot.x = fragCoord.x*0.985 + fragCoord.y * 0.174;\n    fragCoordRot.y = fragCoord.y*0.985 - fragCoord.x * 0.174;\n    fragCoordRot += vec2(-0.06, 0.12) * iResolution.xy;\n    vec3 rotation=vec3(0.0,1,10);\n    mat4 f=rotationX(rotation.x) * rotationY(rotation.y) * rotationZ(rotation.z);\n    \n    for( int j=0; j<AA; j++ )\n    for( int i=0; i<AA; i++ )\n    {\n        //setting up camera\n        vec3 ray = normalize( vec3((fragCoordRot-iResolution.xy*.5  + vec2(i,j)/(float(AA)))/iResolution.x, 1 )); \n        vec3 pos = vec3(1.025*sin(iTime/5.0),.2,-2.4+.1*sin(iTime/5.0));\n        // inside location looking outside:> vec3 pos = vec3(0.025,0.05,0.1);\n        vec2 angle = vec2(-.10+0.01*sin(iTime),-0.010);      \n        //angle.y = (2.*0.0/iResolution.y)*3.14 + 0.1 + 3.14;\n        float dist = length(pos);\n        Rotate(pos,angle*0.05);\n        //angle.xy -= min(.3/dist , 3.14) * vec2(1, 0.5);\n        Rotate(ray,angle);\n\n        vec4 col = vec4(0.); \n        vec4 glow = vec4(0.); \n        vec4 outCol =vec4(100.);\n\n        for(int disks = 0; disks< 20; disks++) //steps\n        {\n\n            for (int h = 0; h < 6; h++) //reduces tests for exit conditions (to minimise branching)\n            {\n                float dotpos = dot(pos,pos);\n                float invDist = inversesqrt(dotpos); //1/distance to BH\n                float centDist = dotpos * invDist;  //distance to BH\n                float stepDist = 0.92 * abs(pos.y /(ray.y));  //conservative distance to disk (y==0)   \n                float farLimit = centDist * 0.5; //limit step size far from to BH\n                float closeLimit = centDist*0.1 + 0.05*centDist*centDist*(1./_Size); //limit step size closse to BH\n                stepDist = min(stepDist, min(farLimit, closeLimit));\n                \n                \n                \n                float invDistSqr = asinh(invDist)*invDist*rand(iTime/1000.0);\n                \n                \n                \n                float forceK = 0.725; //0.625;\n                float bendForce = stepDist * invDistSqr * _Size * forceK;  //bending force\n                ray =  normalize(ray - (bendForce * invDist )*pos);  //bend ray towards BH\n                pos += stepDist * ray; \n                \n                glow += vec4(1.2,1.1,1, 1.0) *(0.01*stepDist * invDistSqr * invDistSqr *clamp( centDist*(2.) - 1.2,0.,1.)); //adds fairly cheap glow\n            }\n\n            float dist2 = length(pos);\n\n            if(dist2 < _Size * 0.1) //ray sucked in to BH\n            {\n                //outCol=vec4(0.1,0.6,0.1,1.0);\n                outCol =  vec4( col.rgb * col.a + glow.rgb *(0.8-col.a ) ,1.) ;\n                break;\n            }\n\n            else if(dist2 > _Size * 1000.) //ray escaped BH\n            {                   \n                vec4 bg = background (ray);\n                outCol = vec4(col.rgb*col.a + bg.rgb*(1.-col.a)  + glow.rgb *(1.-col.a    ), 1.);       \n                break;\n            }\n\n            else if (abs(pos.y) <= _Size * 0.002 ) //ray hit accretion disk\n            {                             \n                //utCol=vec4(0.1,0.1,0.1,1.0);\n                //break;\n                vec4 diskCol = raymarchDisk(ray, pos);   //render disk\n                pos.y = 0.;\n                pos += abs(_Size * 0.001 /ray.y) * ray;  \n                col = vec4(diskCol.rgb*(1.-col.a) + col.rgb, col.a + diskCol.a*(1.-col.a));\n            }   \n        }\n   \n        //if the ray never escaped or got sucked in\n        if(outCol.r == 100.)\n            outCol = vec4(col.rgb + glow.rgb *(col.a +  glow.a) , 1.);\n\n        col = outCol;\n        col.rgb =  pow( col.rgb, vec3(0.6) );\n        \n        colOut += col/float(AA*AA);\n    }\n}\n\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/sdB3Dc.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "sdB3DD", "name": "Fractal 48_gaz", "author": "gaz", "description": "julia", "tags": ["fractal"], "likes": 14, "viewed": 268, "date": "1617410493", "time_retrieved": "2024-06-20T20:38:26.006926", "image_code": "#define R(p,a,r)mix(a*dot(p,a),p,cos(r))+sin(r)*cross(p,a)\n#define hue(h)(cos((h)*6.3+vec3(0,23,21))*.5+.5)\n#define hash(x)fract(sin(x*5555.5))\n\nvoid mainImage(out vec4 O, in vec2 C)\n{\n    O=vec4(0);\n    vec3 p,r=iResolution,\n    d=normalize(vec3((C-.5*r.xy)/r.y,1.5));  \n    for(float i=0.,j,g=0.,e,m,n;i++<100.;){\n        vec3 p=d*g;\n        p=R(p,normalize(vec3(1,2,3)),.5);\n        p-=vec3(-.3,.2,-iTime*.3);\n        n=hash(floor(p.z)+234.5);\n        p.z=fract(p.z)-.5;     \n        m=.1;\n        vec2 z=p.xy;\n        for(j=0.;\n            length(vec2(dot(z,z),p.z))<4.&&j++<100.;\n            m=min(m,length(vec2(dot(z,z),p.z)))\n        )\n            z=mat2(z,-z.y,z.x)*z-vec2(.8,.18)+n*.05;\n        g+=e=.5*m;\n        e<.01?O.xyz+=mix(vec3(1),hue(log(j)*.6+n),.7)*.3*exp(-5e-4*i*i):p;\n  }\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/sdB3DD.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "sdB3DG", "name": "random function test", "author": "lonelyGizmo", "description": "original Hash function www.cs.ubc.ca/~rbridson/docs/schechter-sca08-turbulence.pdf\nported from https://github.com/SebLague/Slime-Simulation/blob/main/Assets/Scripts/Slime/SlimeSim.compute", "tags": ["random", "hash"], "likes": 2, "viewed": 45, "date": "1617875206", "time_retrieved": "2024-06-20T20:38:26.231271", "image_code": "uint hash(in float st)\n{\n    uint state = uint(st*1000000.0);\n    state ^= 2747636419u;\n    state *= 2654435769u;\n    state ^= state >> 16;\n    state *= 2654435769u;\n    state ^= state >> 16;\n    state *= 2654435769u;\n    return state;\n}\n\nfloat scaleToRange(uint state)\n{\n    return float(state) / 4294967295.0;\n}\n\nfloat test( in uint ts)\n{\n    //tst=float(ts);\n    return float(ts);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Time varying pixel color\n    float rnd=scaleToRange(hash(uv.x*uv.y*iTime));\n    vec3 col = vec3(rnd);\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/sdB3DG.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "sdB3WK", "name": "Circle in Lp space", "author": "tomoe", "description": "The distance is determined by Lp norm", "tags": ["bd202104"], "likes": 1, "viewed": 61, "date": "1617952675", "time_retrieved": "2024-06-20T20:38:26.231271", "image_code": "const float PI = 3.14159265359;\nfloat length2(vec2 p) {\n    p = abs(p);\n    float d = 4.0 * sin(0.5 * iTime) + 5.0;\n    return pow(pow(p.x, d) + pow(p.y, d), 1.0 / d);\n}\nfloat circle(vec2 p, vec2 c, float r){\n    return length2(p - c) - r;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    vec2 pos = (2.0 * fragCoord.xy -iResolution.xy)/ iResolution.yy;\n    float w = circle(pos, vec2(0.0), 0.8);\n    vec3 v = vec3(step(mod(w, 0.1), 0.01));  \n    v += mix(vec3(0, 0, 1), vec3(1,0,0), atan(w)/PI + 0.5);\n    v *= 1.0-step(abs(w),0.01);\n    fragColor = vec4(v, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/sdB3WK.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "sdB3Wt", "name": "infinite_pattern_quick*", "author": "SimonOakey", "description": "quick sketch of an infinte pattern - tbc.\nlicenced under love, peace and happyness ✌️", "tags": ["noise", "color", "pattern", "osc"], "likes": 3, "viewed": 169, "date": "1618094626", "time_retrieved": "2024-06-20T20:38:26.976848", "image_code": "/*licenced under love, peace and happyness ✌️ */\n\n\n#ifdef GL_ES\nprecision highp float;\n#endif\n\n\nuniform float time;\nuniform vec2 mouse;\nuniform vec2 resolution;\n\n#define time iTime\n#define resolution iResolution\n\n\n //generic rotation formula\nvec2 rot(vec2 uv,float a){\n\treturn vec2(uv.x*cos(a)-uv.y*sin(a),uv.y*cos(a)+uv.x*sin(a));\n}\n\n\n\nvec3 returnGrain(vec2 _uv, float amount){\n\t\n\t float x = (_uv.x + 4.0 ) * (_uv.y + 4.0 ) * ( 1110.0);\n\t vec4 grain = vec4(mod((mod(x, 13.0) + 1.0) * (mod(x, 123.0) + 1.0), 0.01)-0.005) *  amount;\n\t return grain.xyz;\n\t\n}\n\n\nvec3 hash3( float n ) { return fract(sin(vec3(n,n+1.0,n+2.0))*43758.5453123); }\n\nvec2 hash( vec2 p ) // replace this by something better\n{\n\tp = vec2( dot(p,vec2(127.1,311.7)),\n\t\t\t  dot(p,vec2(269.5,183.3)) );\n\n\treturn -1.0 + 2.0*fract(sin(p)*43758.5453123);\n}\n\n\nfloat noise( in vec2 p )\n{\n    const float K1 = 0.366025404; // (sqrt(3)-1)/2;\n    const float K2 = 0.211324865; // (3-sqrt(3))/6;\n\n\tvec2 i = floor( p + (p.x+p.y)*K1 );\n\t\n    vec2 a = p - i + (i.x+i.y)*K2;\n    vec2 o = step(a.yx,a.xy);    \n    vec2 b = a - o + K2;\n\tvec2 c = a - 1.0 + 2.0*K2;\n\n    vec3 h = max( 0.5-vec3(dot(a,a), dot(b,b), dot(c,c) ), 0.0 );\n\n\tvec3 n = h*h*h*h*vec3( dot(a,hash(i+0.0)), dot(b,hash(i+o)), dot(c,hash(i+1.0)));\n\n    return dot( n, vec3(70.0) );\n\t\n}\n\n\nconst mat2 mtx = mat2( 0.80,  0.60, -0.60,  0.80 );\n\nfloat fbm( vec2 p )\n{\n    float f = 0.0;\n \n\t\n\tfor(int i=0;i<11; i++){\n\n\tvec2 p1 = vec2(p.x*.4*float(i),p.y*.4*float(i));\n\t\t\n\tp1.x *=\tnoise(p1*.5+time*.1)*.4;\n\tp1.y *=\tnoise(p*.5-time*.1)*.4;\n\t\t\n    \tf += 0.8*noise(p1); p1 = mtx*p1*3.03;\t\n\t\t\n\t\n\t}\n\t\n\n    return f;\n}\n\nfloat pattern( in vec2 p )\n{\n\treturn fbm( p + fbm( p*2.3 + fbm( p*.33 ) ) );\n}\n\n\n\nvec3 hsv2rgb( in vec3 c )\n{\n    vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n    return c.z * mix( vec3(1.0), rgb, c.y);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n\t\n    vec2 q = fragCoord.xy / iResolution.xy;\n    float _x = .65 + sin(time*.1)*.1 ;//iMouse.x/resolution.x;\n\n\tvec2 uv = gl_FragCoord.xy/resolution.y;\n    uv.x += resolution.y/resolution.x;\n\t\n    \n    \n    \n    uv.x = sin(uv.x*15.)*.5+.5;\n    uv.y *= 5.;\n    \n\tuv.y -= time*.1;\n    \n  // uv *=5.;\n   \n     vec2 ouv = uv;\n     \n\t\n     \n    \n\tfloat shade = pattern(uv);\n\t\n    shade = sin(noise(uv)*3.14);\n    \n    //shade += sin(uv.x)*6.*_x; // osc\n    \n     shade += sin(uv.y*.4+.1)*6.*_x;\n\t\n    shade = floor(shade*5.)*255. + shade*.2;\n    \n   \n\t\n\tvec3 col = vec3(\n\t\tsin(shade*.91+ time*.01)*1.75+.5 ,\n\t\tcos(shade*3.+ time*.13)*.75+.5 ,\n\t\tcos(shade*13.+ time*.13)*.5+.6 \n\t\t\t//shade*.7+.4\n\t);\n\t\n    \n\tcol = hsv2rgb(col);\n\t\n\t \n      \n     \n     \n      // dithering\n    col += hash3(q.x+13.0*q.y)*.1;\n     \n      // vignetting    \n   col *= 0.3 + .7*pow(16.0*q.x*q.y*(1.0-q.x)*(1.0-q.y),0.15);\n    \n\t\n\tfragColor = vec4( col, 1.0 );\n\n}\n\n\n\n\n ", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "unknown-license-reference", "thumbnail": "https://www.shadertoy.com/media/shaders/sdB3Wt.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "sdBGRK", "name": "Unspinning", "author": "DukeOfStraylight", "description": "a very bad model of galactic physics", "tags": ["2d", "galaxy"], "likes": 16, "viewed": 324, "date": "1617636541", "time_retrieved": "2024-06-20T20:38:26.976848", "image_code": "mat2 rot(float a) {\n    float c = cos(a), s = sin(a);\n    return mat2(c, -s, s, c);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-0.5*iResolution.xy)/iResolution.y;\n\n    uv *= 50.;\n//    uv *= rot(iTime);\n\n    vec2 id = floor(uv);\n    vec2 center = id + .5;\n    vec2 st = fract(uv);\n\n    float d = 1.;\n    const float NNEI = 1.;\n    for (float x = -NNEI; x <= NNEI; x++) {\n        for (float y = -NNEI; y <= NNEI; y++) {\n            vec2 ndiff = vec2(x, y);\n            vec2 c = center + ndiff;\n            float r = length(c);\n            float a = atan(c.y, c.x);\n            r += (sin(iTime * 5. - r*0.55 - a*2.) * min(r/5., 1.));\n            vec2 lc = vec2(r*cos(a), r*sin(a));\n            d = min(d, length(uv - lc) + 0.01 * r);\n        }\n    }\n    float w = fwidth(uv.y);\n    vec3 col = vec3(smoothstep(0.31+w, 0.31-w, d));\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n// grid\n/*\n    if (st.x < 0.05 || st.y < 0.05) {\n        fragColor = vec4(vec3(0, 1, 0), 1.0);\n    }\n    */\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/sdBGRK.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "sdBGWK", "name": "Quad - closest 3D", "author": "iq", "description": "Closest point on quad. The blue sphere is the evaluation point. The orange sphere marks the point in the quad closest to the blue sphere.", "tags": ["3d", "quad", "closest"], "likes": 17, "viewed": 311, "date": "1617957663", "time_retrieved": "2024-06-20T20:38:28.485935", "image_code": "// The MIT License\n// Copyright © 2021 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// Closest point on quad. The blue sphere is the evaluation\n// point.The orange sphere marks the point on the quad\n// closest to the blue sphere. Related shaders:\n\n// Closest points to other primitives in this list:\n//\n//    https://www.shadertoy.com/playlist/wXsSzB\n\n\n#if HW_PERFORMANCE==0\n#define AA 2\n#else\n#define AA 5\n#endif\n\nfloat dot2( in vec3 v ) { return dot(v,v); }\n\nvec3 closestQuad( in vec3 v0, in vec3 v1, in vec3 v2, in vec3 v3, in vec3 p )\n{\n    vec3 v10 = v1 - v0; vec3 p0 = p - v0;\n    vec3 v21 = v2 - v1; vec3 p1 = p - v1;\n    vec3 v32 = v3 - v2; vec3 p2 = p - v2;\n    vec3 v03 = v0 - v3; vec3 p3 = p - v3;\n\n    vec3 nor = cross( v10, v03 );\n\n    if( dot(cross(v10,nor),p0)<0.0 ) return v0 + v10*clamp( dot(p0,v10)/dot2(v10), 0.0, 1.0 );\n    if( dot(cross(v21,nor),p1)<0.0 ) return v1 + v21*clamp( dot(p1,v21)/dot2(v21), 0.0, 1.0 );\n    if( dot(cross(v32,nor),p2)<0.0 ) return v2 + v32*clamp( dot(p2,v32)/dot2(v32), 0.0, 1.0 );\n    if( dot(cross(v03,nor),p3)<0.0 ) return v3 + v03*clamp( dot(p3,v03)/dot2(v03), 0.0, 1.0 );\n    \n    return p - nor*dot(nor,p-v0)/dot2(nor);\n}\n\n//==================================================================\n\n// https://www.shadertoy.com/view/MlGcDz\nfloat iTriangle( in vec3 ro, in vec3 rd, in vec3 v0, in vec3 v1, in vec3 v2 )\n{\n    vec3 v1v0 = v1 - v0;\n    vec3 v2v0 = v2 - v0;\n    vec3 rov0 = ro - v0;\n\n    vec3  n = cross( v1v0, v2v0 );\n    vec3  q = cross( rov0, rd );\n    float d = 1.0/dot( rd, n );\n    float u = d*dot( -q, v2v0 );\n    float v = d*dot(  q, v1v0 );\n    float t = d*dot( -n, rov0 );\n\n    if( u<0.0 || v<0.0 || (u+v)>1.0 ) t = -1.0;\n    \n    return t;\n}\n\n// https://www.shadertoy.com/view/4lcSRn\nfloat iCylinder( in vec3 ro, in vec3 rd, \n                 in vec3 pa, in vec3 pb, float ra )\n{\n    vec3 ba = pb-pa;\n\n    vec3  oc = ro - pa;\n\n    float baba = dot(ba,ba);\n    float bard = dot(ba,rd);\n    float baoc = dot(ba,oc);\n    \n    float k2 = baba            - bard*bard;\n    float k1 = baba*dot(oc,rd) - baoc*bard;\n    float k0 = baba*dot(oc,oc) - baoc*baoc - ra*ra*baba;\n    \n    float h = k1*k1 - k2*k0;\n    if( h<0.0 ) return -1.0;\n    h = sqrt(h);\n    float t = (-k1-h)/k2;\n\n    // body\n    float y = baoc + t*bard;\n    if( y>0.0 && y<baba ) return t;\n    \n    return -1.0;\n}\n\nfloat iSphere( in vec3 ro, in vec3 rd, in vec4 sph )\n{\n\tvec3 oc = ro - sph.xyz;\n\tfloat b = dot( oc, rd );\n\tfloat c = dot( oc, oc ) - sph.w*sph.w;\n\tfloat h = b*b - c;\n\tif( h<0.0 ) return -1.0;\n\treturn -b - sqrt( h );\n}\n\nfloat iPlane( in vec3 ro, in vec3 rd, in float h )\n{\n    return (h-ro.y)/rd.y;\n}\n\nvec3 nPlane( void )\n{\n    return vec3(0.0,1.0,0.0);\n}\n\nvec3 nTriangle( in vec3 v0, in vec3 v1, in vec3 v2 )\n{\n    vec3 v1v0 = v1 - v0;\n    vec3 v2v0 = v2 - v0;\n    return normalize( cross( v1v0, v2v0 ) );\n}\n\nvec3 nCylinder( in vec3 pos, in vec3 a, in vec3 b, in float r )\n{\n    vec3  ba = b - a;\n    vec3  pa = pos - a;\n    float h = clamp(dot(pa,ba)/dot(ba,ba),0.0,1.0);\n    return (pa - h*ba)/r;\n}\n\nvec3 nSphere( in vec3 pos, in vec4 sph )\n{\n    return (pos-sph.xyz)/sph.w;\n}\n\n// https://www.shadertoy.com/view/3tBBW3\nfloat oQuad( in vec3 pos, in vec3 nor, \n                     in vec3 v0, in vec3 v1,\n                     in vec3 v2, in vec3 v3 ) \n{\n    v0 = normalize(v0-pos);\n    v1 = normalize(v1-pos);\n    v2 = normalize(v2-pos);\n    v3 = normalize(v3-pos);\n    float k02 = dot( nor, normalize( cross(v3,v0)) ) * acos( dot(v0,v3) );\n    float k23 = dot( nor, normalize( cross(v2,v3)) ) * acos( dot(v3,v2) );\n    float k31 = dot( nor, normalize( cross(v1,v2)) ) * acos( dot(v2,v1) );\n    float k10 = dot( nor, normalize( cross(v0,v1)) ) * acos( dot(v1,v0) );\n    \n    return abs(k02+k23+k31+k10)/6.283185;\n}\n\n// https://www.shadertoy.com/view/4djSDy\nfloat oSphere( in vec3 pos, in vec3 nor, in vec4 sph )\n{\n    vec3  di = sph.xyz - pos;\n    float l  = length(di);\n    float nl = dot(nor,di/l);\n    float h  = l/sph.w;\n    float h2 = h*h;\n    float k2 = 1.0 - h2*nl*nl;\n\n    float res = max(0.0,nl)/h2;\n    if( k2 > 0.0 ) \n        res = pow( clamp(0.5*(nl*h+1.0)/h2,0.0,1.0), 1.5 );\n\n    return res;\n}\n\n//=====================================================\n\nstruct Scene\n{\n    vec3 v1;\n\tvec3 v2;\n\tvec3 v3;\n    vec3 v4;\n    vec3 pA;\n    vec3 pB;\n};\n    \nvec2 intersect( in vec3 ro, in vec3 rd, in Scene scn )\n{\n    vec2 res = vec2(1e10,-1.0);\n    \n    float t = iPlane(ro,rd,-1.5);\n    if( t>0.0 ) res = vec2( t, 1.0 );\n    \n    t = iTriangle( ro, rd, scn.v1, scn.v2, scn.v4 );\n    if( t>0.0 && t<res.x ) res = vec2( t, 2.0 );\n\n    t = iTriangle( ro, rd, scn.v3, scn.v4, scn.v2 );\n    if( t>0.0 && t<res.x ) res = vec2( t, 2.0 );\n    \n    t = iSphere( ro, rd, vec4(scn.pA,0.07) );\n    if( t>0.0 && t<res.x ) res = vec2( t, 3.0 );\n    \n    t = iSphere( ro, rd, vec4(scn.pB,0.07) );\n    if( t>0.0 && t<res.x ) res = vec2( t, 4.0 );\n                \n\tt = iCylinder( ro, rd, scn.pA, scn.pB, 0.02 );\n    if( t>0.0 && t<res.x ) res = vec2( t, 5.0 );\n\n    return res;\n}\n\nvec3 calcNormal( in vec3 pos, in float objID, in Scene scn )\n{\n    if( objID<1.5 ) return nPlane();\n    if( objID<2.5 ) return nTriangle( scn.v1, scn.v2, scn.v4 );\n    if( objID<3.5 ) return nSphere( pos, vec4(scn.pA,0.07) );\n    if( objID<4.5 ) return nSphere( pos, vec4(scn.pB,0.07) );\n    if( objID<5.5 ) return nCylinder( pos, scn.pA, scn.pB, 0.02 );\n    return vec3(0.0,1.0,0.0);\n}\n\nfloat calcOcclusion( in vec3 pos, in vec3 nor, in float objID, in Scene scn )\n{\n    float occ = 1.0;\n\n    occ *= clamp( 0.5+0.5*nor.y, 0.0, 1.0 );\n    occ *= 1.0-oSphere( pos, nor, vec4(scn.pA,0.07) );\n    occ *= 1.0-oSphere( pos, nor, vec4(scn.pB,0.07) );\n\n    if( objID<1.5 ) occ *= 1.0-oQuad( pos, nor, scn.v1, scn.v2, scn.v3, scn.v4 );\n    \n    return occ;\n}\n\nconst vec3 lig = normalize(vec3(1.0,0.9,0.7));\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec4 tot = vec4(0.0);\n#if AA>1\n\t#define ZERO min(iFrame,0)\n    for( int m=ZERO; m<AA; m++ )\n    for( int n=ZERO; n<AA; n++ )\n    {\n        // 2 pixel wide triangular kernel\n        vec2 o = 2.0*vec2(float(m),float(n)) / float(AA-1) - 1.0;\n        vec2 p = (2.0*(fragCoord+o)-iResolution.xy)/iResolution.y;\n        float t = iTime - (1.0/30.0)*float(m*AA+n)/float(AA*AA-1);\n#else    \n        vec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n        float t = iTime;\n#endif\n\n        // animate objects\n        Scene scn;\n        vec3 w = sin(0.2*t*vec3(1.0,1.1,1.2) + vec3(0.0,2.0,4.0) );\n        w /= (w.x+w.y+w.z);\n        scn.v1 = 1.5*vec3(1.0,0.4,1.0)*cos( 0.11*t + vec3(0.0,1.0,1.0) + 0.0 );\n        scn.v2 = 1.5*vec3(1.0,0.4,1.0)*cos( 0.12*t + vec3(0.0,2.0,3.0) + 2.0 );\n        scn.v3 = 1.5*vec3(1.0,0.4,1.0)*cos( 0.13*t + vec3(0.0,3.0,5.0) + 3.0 );\n        scn.v4 = scn.v1 + (scn.v3 - scn.v2)*(0.55+0.45*sin( 0.37*t + 4.0 ));\n        \n        if( dot( cross( scn.v2-scn.v1, scn.v4-scn.v1 ), \n                 cross( scn.v4-scn.v3, scn.v2-scn.v3 )) < 0.0 )\n        {\n            vec3 tmp = scn.v3;\n            scn.v3 = scn.v2;\n            scn.v2 = tmp;\n        }\n    \n        // compute closest point in quad\n        scn.pA = vec3(cos(1.5*t+1.0),0.8+0.4*cos(t*1.1),cos(1.4*t+3.0));\n        scn.pB = closestQuad( scn.v1, scn.v2, scn.v3, scn.v4, scn.pA );\n\n        // render\n        \n        vec3 ro = vec3(0.0, 0.7, 3.5 );\n        vec3 rd = normalize( vec3(p,-2.0) );\n        rd.yz = (mat2(24,-7,7,24)/25.0)*rd.yz;\n\n        vec3 col = vec3(0.0);\n\n        vec2 tm = intersect( ro, rd, scn );\n        if( tm.y>0.0 )\n        {\n            float t = tm.x;\n            vec3 pos = ro + t*rd;\n            vec3 nor = calcNormal(pos, tm.y, scn);\n            nor *= -sign(dot(nor,rd));\n            float occ = calcOcclusion( pos, nor, tm.y, scn );\n            col += vec3(1.4)*occ;\n            col *= 0.55+0.45*cos(tm.y*3.5+vec3(0.0,1.0,1.5));\n            col *= exp( -0.05*t );\n        }\n\n        col = pow( clamp(col,0.0,1.0), vec3(0.4545) );\n\n        tot += vec4(col,1.0);\n#if AA>1\n    }\n    tot.xyz /= tot.w;\n#endif\n\n    \n    fragColor = vec4( tot.xyz, 1.0 );\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "mit", "thumbnail": "https://www.shadertoy.com/media/shaders/sdBGWK.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "sdBXRD", "name": "Dolphin Orb", "author": "dr2", "description": "Magic orb -- immersive scene projected onto external sphere (mouseable)", "tags": ["projection", "spherical", "swim"], "likes": 12, "viewed": 237, "date": "1619771651", "time_retrieved": "2024-06-20T20:38:30.971000", "image_code": "// \"Dolphin Orb\" by dr2 - 2021\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\n/*\n  No. 7 in \"Dolphin\" series\n    \"Atlantis 2\"                (XdlBzX)\n    \"Closely Watched Dolphins\"  (MdlfRl)\n    \"Virtual Dolphins\"          (XlfBD2)\n    \"Golden Dolphin\"            (MtsBWX)\n    \"Cave Dolphins\"             (wdSyRD)\n    \"Nautilus Interior\"         (wt2fzz)\n*/\n\n#define USE_BMAP   false  // try true for stronger GPUs\n\n#define VAR_ZERO min (iFrame, 0)\n\nfloat PrSphDf (vec3 p, float r);\nfloat PrRoundCylDf (vec3 p, float r, float rt, float h);\nfloat PrTorusDf (vec3 p, float ri, float rc);\nfloat PrEllipsDf (vec3 p, vec3 r);\nfloat Minv3 (vec3 p);\nfloat SmoothMin (float a, float b, float r);\nfloat SmoothMax (float a, float b, float r);\nmat3 StdVuMat (float el, float az);\nvec2 Rot2D (vec2 q, float a);\nvec3 Hashv3v3 (vec3 p);\nfloat Noisefv3 (vec3 p);\nvec3 VaryNf (vec3 p, vec3 n, float f);\n\nvec3 fishPos, fishAng, vuPos, ltPos, ltDirEx;\nvec2 trkAx, trkAy, trkFx, trkFy;\nfloat dstFar, tCur, bGrid, pScale, dstBMap;\nint idObj;\nbool useBm;\nconst float pi = 3.14159;\n\n#define DMIN(id) if (d < dMin) { dMin = d;  idObj = id; }\n\nvec3 TrackPath (float t)\n{\n  return vec3 (dot (trkAx, sin (trkFx * t)), dot (trkAy, sin (trkFy * t)), t);\n}\n\nvec3 TrackVel (float t)\n{\n  return vec3 (dot (trkAx * trkFx, cos (trkFx * t)), dot (trkAy * trkFy, cos (trkFy * t)), 1);\n}\n\nfloat VPoly (vec3 p)\n{\n  vec3 ip, fp, a, w;\n  p *= pScale;\n  ip = floor (p);\n  fp = fract (p);\n  a = vec3 (4.);\n  for (float gz = -1.; gz <= 1.; gz ++) {\n    for (float gy = -1.; gy <= 1.; gy ++) {\n      for (float gx = -1.; gx <= 1.; gx ++) {\n        w = vec3 (gx, gy, gz) + 0.8 * Hashv3v3 (ip + vec3 (gx, gy, gz)) - fp;\n        a.z = dot (w, w);\n        if (a.z < a.x) a.xy = a.zx;\n        else a.y = min (a.z, a.y);\n      }\n    }\n  }\n  return sqrt (a.y - a.x);\n}\n\nfloat ObjDfG (vec3 p)\n{\n  vec3 q;\n  float d;\n  q = p;\n  q.xy -= TrackPath (p.z).xy;\n  d = SmoothMax (length (fract (q) - 0.5) - 0.2 + 1.1 * (Noisefv3 (4. * q) - 0.5), 0.55 - length (q.xy), 0.2);\n  if ((USE_BMAP || useBm) && dstBMap < 6. && d < 0.05) d -= 0.04 * VPoly (p);\n  return 0.25 * d;\n}\n\nfloat ObjRayG (vec3 ro, vec3 rd)\n{\n  vec3 p, s, rdi;\n  float dHit, d, eps;\n  eps = 0.0002;\n  if (rd.x == 0.) rd.x = 0.001;\n  if (rd.y == 0.) rd.y = 0.001;\n  if (rd.z == 0.) rd.z = 0.001;\n  rdi = 1. / rd;\n  dHit = eps;\n  for (int j = VAR_ZERO; j < 320; j ++) {\n    p = ro + dHit * rd;\n    s = (bGrid * (floor (p / bGrid) + step (0., rd)) - p) * rdi;\n    dstBMap = dHit;\n    d = min (ObjDfG (p), abs (Minv3 (s)) + eps);\n    dHit += d;\n    if (d < eps || dHit > dstFar) break;\n  }\n  if (d >= eps) dHit = dstFar;\n  return dHit;\n}\n\nvec3 ObjNfG (vec3 p)\n{\n  vec4 v;\n  vec2 e;\n  e = vec2 (0.001, -0.001);\n  for (int j = VAR_ZERO; j < 4; j ++) {\n    v[j] = ObjDfG (p + ((j < 2) ? ((j == 0) ? e.xxx : e.xyy) : ((j == 2) ? e.yxy : e.yyx)));\n  }\n  v.x = - v.x;\n  return normalize (2. * v.yzw - dot (v, vec4 (1.)));\n}\n\nfloat ObjDf (vec3 p)\n{\n  vec3 q;\n  float dMin, szFac, d, dBodyF, dBodyB, dMouth, dFinT, dFinP, dFinD, dEye;\n  int id;\n  szFac = 0.25;\n  dMin = dstFar;\n  dMin /= szFac;\n  p = (p - fishPos) / szFac;\n  p.xz = Rot2D (p.xz, fishAng.y);\n  p.yz = Rot2D (p.yz, fishAng.x);\n  p.x = abs (p.x);\n  p.z -= 0.2;\n  p.yz = Rot2D (p.yz, 0.2 * fishAng.z);\n  q = p;\n  q.z -= -0.06;\n  dBodyF = PrEllipsDf (q, vec3 (0.07, 0.08, 0.24));\n  q = p;\n  q.z -= -0.12;\n  q.yz = Rot2D (q.yz, fishAng.z);\n  q.z -= -0.16;\n  dBodyB = PrEllipsDf (q, vec3 (0.035, 0.05, 0.25));\n  q.z -= -0.22;\n  q.yz = Rot2D (q.yz, 2. * fishAng.z);\n  q.xz -= vec2 (0.05, -0.05);\n  q.xz = Rot2D (q.xz, 0.4);\n  dFinT = PrEllipsDf (q, vec3 (0.08, 0.007, 0.04));\n  q = p;\n  q.yz = Rot2D (q.yz - vec2 (-0.03, 0.17), 0.1);\n  q.y = abs (q.y) - 0.004;\n  dMouth = PrEllipsDf (q, vec3 (0.025, 0.012, 0.06));\n  q = p;\n  q.yz = Rot2D (q.yz - vec2 (0.07, -0.1), 0.6);\n  dFinD = PrEllipsDf (q, vec3 (0.005, 0.1, 0.035));\n  q = p;\n  q.xy = Rot2D (q.xy, 0.8);\n  q.xz = Rot2D (q.xz - vec2 (0.07, -0.01), 0.6);\n  dFinP = PrEllipsDf (q, vec3 (0.09, 0.004, 0.03));\n  q = p - vec3 (0.04, 0.01, 0.11);\n  dEye = PrSphDf (q, 0.015);\n  d = SmoothMin (SmoothMin (dBodyF, dBodyB, 0.03), dFinT, 0.01);\n  d = SmoothMin (SmoothMin (d, dMouth, 0.015), min (dFinD, dFinP), 0.002);\n  if (d < dEye) id = 2;\n  else {\n    d = dEye;\n    id = 3;\n  }\n  DMIN (id);\n  return dMin * szFac;\n}\n\nfloat ObjRay (vec3 ro, vec3 rd)\n{\n  float dHit, d;\n  dHit = 0.;\n  for (int j = VAR_ZERO; j < 120; j ++) {\n    d = ObjDf (ro + dHit * rd);\n    if (d < 0.001 || dHit > dstFar) break;\n    dHit += d;\n  }\n  return dHit;\n}\n\nvec3 ObjNf (vec3 p)\n{\n  vec4 v;\n  vec2 e;\n  e = vec2 (0.001, -0.001);\n  for (int j = VAR_ZERO; j < 4; j ++) {\n    v[j] = ObjDf (p + ((j < 2) ? ((j == 0) ? e.xxx : e.xyy) : ((j == 2) ? e.yxy : e.yyx)));\n  }\n  v.x = - v.x;\n  return normalize (2. * v.yzw - dot (v, vec4 (1.)));\n}\n\nfloat ObjSShadow (vec3 ro, vec3 rd, float ltDist)\n{\n  vec3 p;\n  float sh, d, h;\n  sh = 1.;\n  d = 0.05;\n  for (int j = VAR_ZERO; j < 20; j ++) {\n    p = ro + d * rd;\n    h = min (ObjDf (p), ObjDfG (p));\n    sh = min (sh, smoothstep (0., 0.03 * d, h));\n    d += h;\n    if (sh < 0.05 || d > ltDist) break;\n  }\n  return 0.5 + 0.5 * sh;\n}\n\nvec4 SphHit (vec3 ro, vec3 rd, float rad)\n{\n  vec3 vn;\n  float b, d, w;\n  b = dot (rd, ro);\n  w = b * b + rad * rad - dot (ro, ro);\n  d = dstFar;\n  if (w > 0.) {\n    d = - b - sqrt (w);\n    vn = (ro + d * rd) / rad;\n  }\n  return vec4 (d, vn);\n}\n\nvec3 BgCol (vec3 rd)\n{\n  float t, gd, b;\n  t = tCur * 4.;\n  b = dot (vec2 (atan (rd.x, rd.z), 0.5 * pi - acos (rd.y)), vec2 (2., sin (rd.x)));\n  gd = clamp (sin (5. * b + t), 0., 1.) * clamp (sin (3.5 * b - t), 0., 1.) +\n     clamp (sin (21. * b - t), 0., 1.) * clamp (sin (17. * b + t), 0., 1.);\n  return mix (vec3 (0., 0.5, 0.6), vec3 (0.2, 0.4, 0.9), 0.5 + 0.5 * rd.y) *\n     (0.24 + 0.44 * (rd.y + 1.) * (rd.y + 1.)) * (1. + 0.2 * gd);\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  vec4 col4;\n  vec3 col, bgCol, vn, roo, ltVec, ltDir;\n  float dstObj, dstObjG, ltDist, sh, atten, eDark, aDotL;\n  bGrid = 1.;\n  pScale = 10.;\n  roo = ro;\n  useBm = false;\n  bgCol = BgCol (rd);\n  dstObj = ObjRay (ro, rd);\n  dstObjG = ObjRayG (ro, rd);\n  if (dstObjG < min (dstObj, dstFar)) {\n    idObj = 1;\n    dstObj = dstObjG;\n  }\n  if (dstObj < dstFar) {\n    ro += dstObj * rd;\n    useBm = true;\n    vn = (idObj == 1) ? ObjNfG (ro) : ObjNf (ro);\n    if (idObj == 1) {\n      col4 = vec4 (mix (vec3 (0.7, 0.75, 0.7), vec3 (0.7, 0.7, 0.75),\n         smoothstep (0.45, 0.55, Noisefv3 (41.1 * ro))), 0.2);\n      col4 *= 1. - 0.2 * Noisefv3 (19.1 * ro);\n      vn = VaryNf (64. * ro, vn, 2.);\n    } else if (idObj == 2) {\n      col4 = vec4 (vec3 (0.8, 0.7, 0.75) * (1. - 0.3 * smoothstep (-0.5, -0.4, vn.y)), 0.2);\n    } else if (idObj == 3) {\n      col4 = vec4 (0., 0.5, 0.3, -1.);\n    }\n    ltVec = roo + ltPos - ro;\n    ltDist = length (ltVec);\n    ltDir = ltVec / ltDist;\n    if (col4.a >= 0.) {\n      eDark = (idObj == 1) ? 0.4 + 0.6 * smoothstep (0.05, 1., VPoly (ro)) : 1.;\n      useBm = false;\n      sh = ObjSShadow (ro, ltDir, ltDist);\n      atten = 1. / (0.6 + 0.1 * ltDist * ltDist);\n      col = atten * col4.rgb * (0.3 + 0.7 * sh * max (dot (vn, ltDir), 0.) +\n         col4.a * step (0.95, sh) * pow (max (dot (reflect (rd, vn), ltDir), 0.), 32.)) * eDark;\n    } else col = col4.rgb;\n    col = mix (col, bgCol, 0.05 + 0.95 * smoothstep (0., 0.85, dstObj / dstFar));\n  } else col = bgCol;\n  return clamp (col, 0., 1.);\n}\n\nfloat ExObjDf (vec3 p)\n{\n  vec3 q;\n  float dMin, d;\n  dMin = dstFar;\n  q = p;\n  d = PrSphDf (q, 1.);\n  q.y = abs (q.y) - 0.45;\n  d = max (PrRoundCylDf (q.xzy, 1.02, 0.007, 0.007), - d);\n  DMIN (1);\n  q = p;\n  q.xz = (abs (q.x) > abs (q.z)) ? q.xz : q.zx;\n  d = max (PrTorusDf (q, 0.013, 1.06), abs (q.y) - 0.45);\n  q.xy = abs (q.xy) - vec2 (0.96, 0.46);\n  d = min (d, PrSphDf (q, 0.02));\n  DMIN (2);\n  q = p;\n  d = PrSphDf (q, 1. - 0.01);\n  DMIN (3);\n  return dMin;\n}\n\nfloat ExObjRay (vec3 ro, vec3 rd)\n{\n  float dHit, d;\n  dHit = 0.;\n  for (int j = VAR_ZERO; j < 80; j ++) {\n    d = ExObjDf (ro + dHit * rd);\n    if (d < 0.001 || dHit > dstFar) break;\n    dHit += d;\n  }\n  return dHit;\n}\n\nvec3 ExObjNf (vec3 p)\n{\n  vec4 v;\n  vec2 e;\n  e = vec2 (0.001, -0.001);\n  for (int j = VAR_ZERO; j < 4; j ++) {\n    v[j] = ExObjDf (p + ((j < 2) ? ((j == 0) ? e.xxx : e.xyy) : ((j == 2) ? e.yxy : e.yyx)));\n  }\n  v.x = - v.x;\n  return normalize (2. * v.yzw - dot (v, vec4 (1.)));\n}\n\nfloat ExObjSShadow (vec3 ro, vec3 rd)\n{\n  float sh, d, h;\n  sh = 1.;\n  d = 0.05;\n  for (int j = VAR_ZERO; j < 30; j ++) {\n    h = ExObjDf (ro + d * rd);\n    sh = min (sh, smoothstep (0., 0.03 * d, h));\n    d += max (0.03, h);\n    if (sh < 0.05) break;\n  }\n  return 0.5 + 0.5 * sh;\n}\n\nvec3 ExShowScene (vec3 ro, vec3 rd)\n{\n  mat3 vuMat;\n  vec4 ds4, col4;\n  vec3 col, vn, vd;\n  float dstObj, t, sh;\n  int idObjEx;\n  trkAx = 0.5 * vec2 (2., 0.9);\n  trkAy = 0.5 * vec2 (1.3, 0.66);\n  trkFx = 2. * vec2 (0.2, 0.23);\n  trkFy = 2. * vec2 (0.17, 0.24);\n  t = 0.3 * tCur;\n  vuPos = TrackPath (t);\n  vuPos.xy += 0.02 * sin (0.05 * pi * tCur);\n  vd = normalize (TrackVel (t));\n  vuMat = StdVuMat (sin (vd.y), atan (vd.x, vd.z) - pi);\n  t -= 0.25;\n  fishPos = TrackPath (t);\n  vd = normalize (TrackVel (t));\n  fishAng = vec3 (sin (vd.y), atan (vd.x, vd.z), 0.1 * sin (pi * tCur));\n  ltPos = vuMat * vec3 (0., 0.5, -0.5);\n  dstObj = ExObjRay (ro, rd);\n  idObjEx = idObj;\n  ds4 = SphHit (ro, rd, 1.);\n  if (min (ds4.x, dstObj) < dstFar) {\n    if (ds4.x < dstObj) {\n      col = ShowScene (vuPos, ds4.yzw);\n    } else {\n      ro += dstObj * rd;\n      vn = ExObjNf (ro);\n      if (idObjEx == 1) col4 = vec4 (0.5, 0.3, 0.1, 0.) * (0.95 + 0.05 * sin (64. * pi * length (ro.xz)));\n      else if (idObjEx == 2) col4 = vec4 (0.5, 0.4, 0., 0.1);\n      sh = ExObjSShadow (ro, ltDirEx);\n      col = col4.rgb * (0.3 + 0.7 * sh * max (dot (vn, ltDirEx), 0.)) +\n         col4.a * step (0.95, sh) * pow (max (dot (reflect (rd, vn), ltDirEx), 0.), 32.);\n    }\n  } else col = vec3 (0.1, 0.1, 0.2);\n  return col;\n}\n\nvoid mainImage (out vec4 fragColor, vec2 fragCoord)\n{\n  mat3 vuMat;\n  vec4 mPtr;\n  vec3 ro, rd;\n  vec2 canvas, uv;\n  float az, el;\n  canvas = iResolution.xy;\n  uv = 2. * fragCoord.xy / canvas - 1.;\n  uv.x *= canvas.x / canvas.y;\n  tCur = iTime;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / canvas - 0.5;\n  dstFar = 16.;\n  az = 0.;\n  el = -0.05 * pi;\n  if (mPtr.z > 0.) {\n    az += 2. * pi * mPtr.x;\n    el += 0.5 * pi * mPtr.y;\n  }\n  vuMat = StdVuMat (el, az);\n  ro = vuMat * vec3 (0., 0., -7.);\n  ltDirEx = vuMat * normalize (vec3 (1., 1., -1.));\n  rd = vuMat * normalize (vec3 (uv, 6.5));\n  fragColor = vec4 (ExShowScene (ro, rd), 1.);\n}\n\nfloat PrSphDf (vec3 p, float r)\n{\n  return length (p) - r;\n}\n\nfloat PrRoundCylDf (vec3 p, float r, float rt, float h)\n{\n  return length (max (vec2 (length (p.xy) - r, abs (p.z) - h), 0.)) - rt;\n}\n\nfloat PrTorusDf (vec3 p, float ri, float rc)\n{\n  return length (vec2 (length (p.xy) - rc, p.z)) - ri;\n}\n\nfloat PrEllipsDf (vec3 p, vec3 r)\n{\n  return (length (p / r) - 1.) * min (r.x, min (r.y, r.z));\n}\n\nfloat Minv3 (vec3 p)\n{\n  return min (p.x, min (p.y, p.z));\n}\n\nfloat SmoothMin (float a, float b, float r)\n{\n  float h;\n  h = clamp (0.5 + 0.5 * (b - a) / r, 0., 1.);\n  return mix (b, a, h) - r * h * (1. - h);\n}\n\nfloat SmoothMax (float a, float b, float r)\n{\n  return - SmoothMin (- a, - b, r);\n}\n\nmat3 StdVuMat (float el, float az)\n{\n  vec2 ori, ca, sa;\n  ori = vec2 (el, az);\n  ca = cos (ori);\n  sa = sin (ori);\n  return mat3 (ca.y, 0., - sa.y, 0., 1., 0., sa.y, 0., ca.y) *\n         mat3 (1., 0., 0., 0., ca.x, - sa.x, 0., sa.x, ca.x);\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  vec2 cs;\n  cs = sin (a + vec2 (0.5 * pi, 0.));\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nconst float cHashM = 43758.54;\n\nvec2 Hashv2v2 (vec2 p)\n{\n  vec2 cHashVA2 = vec2 (37., 39.);\n  return fract (sin (dot (p, cHashVA2) + vec2 (0., cHashVA2.x)) * cHashM);\n}\n\nvec3 Hashv3v3 (vec3 p)\n{\n  vec3 cHashVA3 = vec3 (37., 39., 41.);\n  return fract (sin (dot (p, cHashVA3) + vec3 (0., cHashVA3.xy)) * cHashM);\n}\n\nvec4 Hashv4v3 (vec3 p)\n{\n  vec3 cHashVA3 = vec3 (37., 39., 41.);\n  return fract (sin (dot (p, cHashVA3) + vec4 (0., cHashVA3.xy, cHashVA3.x + cHashVA3.y)) * cHashM);\n}\n\nfloat Noisefv2 (vec2 p)\n{\n  vec2 t, ip, fp;\n  ip = floor (p);  \n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = mix (Hashv2v2 (ip), Hashv2v2 (ip + vec2 (0., 1.)), fp.y);\n  return mix (t.x, t.y, fp.x);\n}\n\nfloat Noisefv3 (vec3 p)\n{\n  vec4 t;\n  vec3 ip, fp;\n  ip = floor (p);\n  fp = fract (p);\n  fp *= fp * (3. - 2. * fp);\n  t = mix (Hashv4v3 (ip), Hashv4v3 (ip + vec3 (0., 0., 1.)), fp.z);\n  return mix (mix (t.x, t.y, fp.x), mix (t.z, t.w, fp.x), fp.y);\n}\n\nfloat Fbmn (vec3 p, vec3 n)\n{\n  vec3 s;\n  float a;\n  s = vec3 (0.);\n  a = 1.;\n  for (int j = 0; j < 5; j ++) {\n    s += a * vec3 (Noisefv2 (p.yz), Noisefv2 (p.zx), Noisefv2 (p.xy));\n    a *= 0.5;\n    p *= 2.;\n  }\n  return dot (s, abs (n));\n}\n\nvec3 VaryNf (vec3 p, vec3 n, float f)\n{\n  vec3 g;\n  vec2 e;\n  e = vec2 (0.1, 0.);\n  g = vec3 (Fbmn (p + e.xyy, n), Fbmn (p + e.yxy, n), Fbmn (p + e.yyx, n)) - Fbmn (p, n);\n  return normalize (n + f * (g - n * dot (n, g)));\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc-by-nc-sa-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/sdBXRD.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "sdfSW8", "name": "SH Rebuild Light Direction", "author": "Yon", "description": "SH Rebuild Light Direction", "tags": ["sh"], "likes": 0, "viewed": 26, "date": "1618539600", "time_retrieved": "2024-06-20T20:38:32.189396", "image_code": "//SH rebuild AHD\n\n//This Shader include:\n//1: Monte Carlo Sample caculate SH coefficient\n//2: Cacualte Main Direction from most of light \n//   from SH coefficient\n\n\n//https://www.ppsloan.org/publications/StupidSH36.pdf\n//http://graphics.stanford.edu/papers/envmap/envmap.pdf\n\n#define PI 3.14159\n#define MAX 10000.\n#define BANDS 3\n#define COEFF 9\n\n#define sampleCount 64\n\n#define Radiance3 vec3\n#define Irradiance3 vec3\n#define Vector3 vec3\n#define Color3 vec3\n\nstruct SHSample { \n    vec3 sph; \n    vec3 vec; \n    float[9] coeff;\n}; \n\nstruct ray{\n    vec3 ori;\n    vec3 dir;\n};\n\nstruct Light {\n    vec3 dir;\n    vec3 radiance;\n};\n\nstruct Pixel{\n    float z;\n    vec3 color;\n};\n\n// SHSample samples[1024];\nfloat result[9];\nmat3 camMat;\n// The actual lights\nconst int NUM_LIGHTS = 2;\nLight lightArray[NUM_LIGHTS];\n\n\nfloat rnd(float seed) { return fract(sin(seed)*43758.5453123); }\nfloat lerp(float a,float b,float t){return (1.-t)*a + t*b;}\nvec3 lerp(vec3 a,vec3 b,float t){return (1.-t)*a + t*b;}\nfloat luminiance(vec3 c){return 0.2125*c.x+0.7154*c.y+0.0721*c.z;}\nvec3 SphereRand( uint seed )\n{\n    float a = (float((seed*0x73493U)&0xfffffU)/float(0x100000))*2. - 1.;\n    float b = 6.283*(float((seed*0xAF71fU)&0xfffffU)/float(0x100000));\n    float cosa = sqrt(1.-a*a);\n    return vec3(cosa*cos(b),a,cosa*sin(b));\n}\n\n// Constants, see here: http://en.wikipedia.org/wiki/Table_of_spherical_harmonics\n#define k01 0.2820947918 // sqrt(  1/PI)/2\n#define k02 0.4886025119 // sqrt(  3/PI)/2\n#define k03 1.0925484306 // sqrt( 15/PI)/2\n#define k04 0.3153915652 // sqrt(  5/PI)/4\n#define k05 0.5462742153 // sqrt( 15/PI)/4\n\n\nvec3 envir(vec3 vec){\n    vec3 color = vec3(max(dot(lightArray[0].dir,vec),0.));\n    color += vec3(max(5.*dot(lightArray[1].dir,vec)-4.,0.));\n    return color;\n}\n\n// Y_l_m(s), where l is the band and m the range in [-l..l] \n// SH caculate from dir vector\nfloat SH( in int l, in int m, in vec3 s ) \n{ \n    vec3 n = s.zxy;\n    \n    //----------------------------------------------------------\n    if( l==0 )          return  k01;\n    //----------------------------------------------------------\n    if( l==1 && m==-1 ) return -k02*n.y;\n    if( l==1 && m== 0 ) return  k02*n.z;\n    if( l==1 && m== 1 ) return -k02*n.x;\n    //----------------------------------------------------------\n    if( l==2 && m==-2 ) return  k03*n.x*n.y;\n    if( l==2 && m==-1 ) return -k03*n.y*n.z;\n    if( l==2 && m== 0 ) return  k04*(3.0*n.z*n.z-1.0);\n    if( l==2 && m== 1 ) return -k03*n.x*n.z;\n    if( l==2 && m== 2 ) return  k05*(n.x*n.x-n.y*n.y);\n    //----------------------------------------------------------\n\n    return 0.0;\n}\n\n/* In a real application, this step would be precomputed (per frame or per scene)\n   for each SH probe */\t\nvoid computeSHLightProbe() {\n    //Monte Carlo Sample\n    for(int i;i<=sampleCount;i++){\n\n            SHSample samples;\n            samples.vec = SphereRand(uint(i+int(iTime * 0.2)));\n\n            // precompute all SH coefficients for this sample \n            for(int l=0; l<BANDS; ++l) { \n                for(int m=-l; m<=l; ++m) { \n                    int index = l*(l+1)+m; \n                    samples.coeff[index] = SH(l,m,samples.vec); \n                    result[index] += luminiance(envir(samples.vec)) * samples.coeff[index]; \n                } \n            } \n    }\n    \n    const float weight = 4.0*PI; \n    float factor = weight / float(sampleCount); \n    for(int i=0; i<COEFF; ++i) { \n        result[i] = result[i] * factor; \n    } \n}\n\n//draw sphere,return hit pos\nfloat hit_sphere(vec3 center, float radius, ray r){\n    vec3 oc = r.ori - center;\n    float a = dot(r.dir,r.dir);\n    float b = 2.*dot(oc,r.dir);\n    float c = dot(oc,oc)- radius*radius;\n    float discriminant = b*b - 4.*a*c;\n    if (discriminant < 0.) {\n        return -1.0;\n        } else {\n        return (-b - sqrt(discriminant) ) / (2.0*a);\n    }\n}\n\nvec3 draw(ray r){\n    float t;\n    Pixel pixel;\n    pixel.z = MAX;\n    vec3 cen_pos = vec3(3.,0.,0.);\n    vec3 cen_pos_02 = vec3(-3.,0.,0.);\n    vec3 cen_pos_03 = vec3(0.,0.,0.);\n\n\n    //draw sh simulated\n    t = hit_sphere(cen_pos_02,1.,r);\n    if(t<pixel.z){\n        if (t > 0.0 ) {\n            float color;\n            vec3 N = normalize (r.ori + r.dir*t - cen_pos_02);\n            for(int l=0; l<BANDS; ++l) { \n                for(int m=-l; m<=l; ++m) { \n                    int index = l*(l+1)+m; \n                    color += SH(l,m,N)*result[index];\n                }\n            } \n            pixel.color = vec3(color);\n            pixel.z = t;\n        }   \n    }\n\n    //draw the origin light \n    t = hit_sphere(cen_pos,1.,r);\n    if(t<pixel.z){\n        //模拟我们需要进行球谐模拟的环境球\n        if (t > 0.0) {\n            vec3 N = normalize (r.ori + r.dir*t - cen_pos);\n            pixel.color = envir(N);\n            pixel.z = t;\n        }   \n    }\n\n    //draw light dir rebuild\n    t = hit_sphere(cen_pos_03,1.,r);\n    if(t<pixel.z){\n        if (t > 0.0) {\n            vec3 N = normalize (r.ori + r.dir*t - cen_pos_03);\n            vec3 dir = normalize(vec3(-result[1],result[2],-result[3]));\n\n            pixel.color = vec3(max(5.*dot(dir,N)-4.,0.));\n            pixel.z = t;\n        }   \n    }\n\n    //BackGround\n    vec3 dir = normalize(r.dir);\n    t = MAX-1.;\n    float y = dir.y;\n    if(t<pixel.z){\n        if(y>0.){\n            pixel.color = lerp(vec3(1.,1.,1.),vec3(0.4,0.6,1.),y);\n            }else{\n            y = pow(-y,0.2);\n            pixel.color = lerp(vec3(1.,1.,1.),vec3(0.02,0.12,0.3),y);\n        }\n    }\n    return pixel.color;\n}\n\nmat3 setCamera(vec3 ro, vec3 ta, float cr)\n{\n    vec3 cw = normalize(ta-ro);\n    vec3 cp = vec3(sin(cr), cos(cr),0.0);\n    vec3 cu = normalize( cross(cw,cp) );\n    vec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    lightArray[0] = Light(normalize(vec3(cos(iTime * 0.2 + 2.0),1,0.1)), 1.0 * vec3(0.75,0.75,0.75));\n\tlightArray[1] = Light(normalize(vec3(1,cos(iTime),sin(iTime))), 1.2 * vec3(0.75,0.6,0));\n\n    computeSHLightProbe();\n\n    vec2 p = (2.0 * fragCoord.xy - iResolution.xy) / iResolution.yy;\n\n    // Mouse\n    vec2 mo = vec2(0.0);\n    if (iMouse.z > 0.0) {\n        mo += (2.0 * iMouse.xy - iResolution.xy) / iResolution.yy;\n    }\n    // Camera position\n    float dist = 6.;\n    vec3 ro = vec3(dist * cos(iTime * 0.1 + 6.0 * mo.x), 2.0 + mo.y * 4.0, dist * sin(iTime * 0.1 + 6.0 * mo.x));\n    \n    // Rotate the camera\n    vec3 target = vec3(0.0, 0.0, 0.0);\n    \n    // Compute the ray\n    camMat = setCamera(ro, target, 0.0);\n    vec3 rd = camMat * normalize(vec3(p.xy, 1.5));\n    \n    ray r;\n    r.ori = ro;\n    r.dir = rd;\n    \n    vec3 color = draw(r);\n    color = pow(color,vec3(1.,1.1,1.));\n    // Output to screen\n    fragColor = vec4(color,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/sdfSW8.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "sdfSWn", "name": "Bitwise ice", "author": "jarble", "description": "This fractal looks like snow and ice.", "tags": ["fractal", "ice", "snow", "bitwise"], "likes": 2, "viewed": 133, "date": "1618456360", "time_retrieved": "2024-06-20T20:38:32.189396", "image_code": "// Inspired by a discussion on hackaday at:\n// https://hackaday.com/2021/04/13/alien-art-drawn-with-surprisingly-simple-math/\n// Formula shared by \"Joe\" on that page..\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Scale and move to make things a litle more interesting t look at.\n    float scale = 0.4;\n    float trans = iTime * 25.0;\n    vec2 coord = (scale * fragCoord) + vec2(trans,0.0);\n    \n    // Heart of color selection.\n    int val = ((int(coord.x) & int(coord.y)) % 3);\n    float result = 0.0;\n    vec3 col = vec3(0.0);\n    vec3 col_prev;\n    for(int i = 0; i < 9; i++){\n        col_prev = col;\n        coord.y += (4.0);\n        coord = coord.yx/(9.0);\n        result = ((result + float(val = ((int(coord.x+coord.y*3.0) | int(coord.y-coord.x*3.0)) % 3)))/(2.0));\n        col.x = (result+col.z)/2.0;\n        col = (fract((col.yzx))+col_prev)/2.0;\n    }\n    // Output.\n    fragColor = vec4((col),0.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/sdfSWn.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "sdfSzH", "name": "Subsurface Scattering Sim", "author": "FrancisL", "description": "Nice", "tags": ["cool"], "likes": 1, "viewed": 51, "date": "1618257976", "time_retrieved": "2024-06-20T20:38:33.305129", "image_code": "const int RAY_STEPS = 256;\nconst float FOVY = 3.141569 * 0.25;\nconst float TO_RADIANS = 3.1415 / 180.0;\nconst vec3 LIGHT_POS = vec3(0., -0.5, 5.);\nconst vec3 LIGHT_COLOR = vec3(0.27, 0.4, 1);\nconst float SHADOW_HARDNESS = 6.0;\n\n// Adjust these to alter where the subsurface glow shines through and how brightly\nconst float FIVETAP_K = 2.0;\nconst float AO_DIST = 0.085;\n\n// The larger the DISTORTION, the smaller the glow\nconst float DISTORTION = 0.2;\n// The higher GLOW is, the smaller the glow of the subsurface scattering\nconst float GLOW = 6.0;\n// The higher the BSSRDF_SCALE, the brighter the scattered light\nconst float BSSRDF_SCALE = 3.0;\n// Boost the shadowed areas in the subsurface glow with this\nconst float AMBIENT = 0.0;\n// Toggle this to affect how easily the subsurface glow propagates through an object\n#define ATTENUATION 0\n\nstruct Intersection\n{\n    float t;\n    vec3 color;\n    vec3 p;\n    int object;\n};\n    \nfloat sphere(vec3 p, float r, vec3 c)\n{\n    return distance(p, c) - r;\n}\n\nvec3 rotateY(vec3 p, float a) {\n    return vec3(cos(a) * p.x + sin(a) * p.z, p.y, -sin(a) * p.x + cos(a) * p.z);\n}\n\nfloat plane( vec3 p, vec4 n )\n{\n  return dot(p,n.xyz) + n.w;\n}\n\nfloat box(vec3 p, vec3 b)\n{\n  return length(max(abs(p) - b, 0.0));\n}\n\n\n#define SPHERE_1_SDF sphere(pos, 1.0, LIGHT_POS)\n#define SPHERE_1_ID 1\n\n#define FLOOR_SDF plane(pos, vec4(0.0, 1.0, 0.0, 3.5))\n#define FLOOR_ID 2\n\n#define TALL_BOX_SDF box(rotateY(pos + vec3(1.7, 1, -3), 27.5 * TO_RADIANS), vec3(1, 1, 1))\n#define TALL_BOX_ID 3\n\n#define SMALL_BOX_SDF box(rotateY(pos + vec3(-1.5, 0.5, -1.75), -27.5 * TO_RADIANS), vec3(1, 2, 1))\n#define SMALL_BOX_ID 4\n\nvec3 shootRay(vec3 eye, vec3 ref, vec2 ndc)\n{\n    vec3 eye2Ref  = ref - eye;\n    float n = length(eye2Ref);\n    \n    vec3 worldUp = vec3(0.0, 1.0, 0.0);\n    vec3 right  = normalize(cross(eye2Ref, worldUp));\n    \n    vec3 U = normalize(cross(right, eye2Ref));\n    vec3 V = U * n * tan(FOVY * 0.5);\n    \n    float aspect = iResolution.x / iResolution.y;\n    vec3 H = right * n * tan(FOVY * 0.5) * aspect;\n  \n    vec3 p = ref + ndc.x * H + ndc.y * V;\n    return normalize(p - eye);\n}\n\n\nvoid sceneMap3D(vec3 pos, out float t, out int obj)\n{\n    t = FLOOR_SDF;\n    obj = FLOOR_ID;\n     \n    float t2 = TALL_BOX_SDF;\n\n    if(t2 < t)\n    {\n        t = t2;\n        obj = TALL_BOX_ID;\n    }\n    t2 = SMALL_BOX_SDF;\n    if(t2 < t)\n    {\n        t = t2;\n        obj = SMALL_BOX_ID;\n    }\n    t2 = SPHERE_1_SDF;\n    if(t2 < t)\n    {\n        t = t2;\n        obj = SPHERE_1_ID;\n    }\n}\n\nfloat sceneMap3D(vec3 pos)\n{\n    float t = FLOOR_SDF;\n    t = min(t, TALL_BOX_SDF);\n    t = min(t, SMALL_BOX_SDF);\n    t = min(t, SPHERE_1_SDF);\n    return t;\n}\n\nfloat shadowMap3D(vec3 pos)\n{\n    float t = FLOOR_SDF;\n    t = min(t, TALL_BOX_SDF);\n    t = min(t, SMALL_BOX_SDF);\n    return t;\n}\n\nvec3 computeNormal(vec3 pos)\n{\n    vec3 epsilon = vec3(0.0, 0.001, 0.0);\n    return normalize( vec3( sceneMap3D(pos + epsilon.yxx) - sceneMap3D(pos - epsilon.yxx),\n                            sceneMap3D(pos + epsilon.xyx) - sceneMap3D(pos - epsilon.xyx),\n                            sceneMap3D(pos + epsilon.xxy) - sceneMap3D(pos - epsilon.xxy)));\n}\n\nvoid march(vec3 origin, vec3 dir, out float t, out int hitObj)\n{\n    t = 0.001;\n    for(int i = 0; i < RAY_STEPS; ++i)\n    {\n        vec3 pos = origin + t * dir;\n    \tfloat m;\n        sceneMap3D(pos, m, hitObj);\n        if(m < 0.01)\n        {\n            return;\n        }\n        t += m;\n    }\n    t = -1.0;\n    hitObj = -1;\n}\n\nfloat softShadow(vec3 dir, vec3 origin, float min_t, float k) {\n    float res = 1.0;\n    float t = min_t;\n    for(int i = 0; i < RAY_STEPS; ++i) {\n        float m = shadowMap3D(origin + t * dir);\n        if(m < 0.0001) {\n            return 0.0;\n        }\n        res = min(res, k * m / t);\n        t += m;\n    }\n    return res;\n}\n\nfloat subsurface(vec3 lightDir, vec3 normal, vec3 viewVec, float thickness) {\n    vec3 scatteredLightDir = lightDir + normal * DISTORTION;\n    float lightReachingEye = pow(clamp(dot(viewVec, -scatteredLightDir), 0.0, 1.0), GLOW) * BSSRDF_SCALE;\n    float attenuation = 1.0;\n    #if ATTENUATION\n    attenuation = max(0.0, dot(normal, lightDir) + dot(viewVec, -lightDir));\n    #endif\n\tfloat totalLight = attenuation * (lightReachingEye + AMBIENT) * thickness;\n    return totalLight;\n}\n\n\nvec3 computeMaterial(int hitObj, vec3 p, vec3 n, vec3 lightVec, vec3 view, float thick)\n{\n    float cosine = dot(-lightVec, n);\n    float subsurface = subsurface(-lightVec, n, view, thick);\n    \n    switch(hitObj){\n        case TALL_BOX_ID:\n        return vec3(1., 1., 0.) * cosine  + subsurface * LIGHT_COLOR;\n        break;\n        case SMALL_BOX_ID:\n        return vec3(0., 1., 1.) * cosine  + subsurface * LIGHT_COLOR;\n        break;\n        case SPHERE_1_ID:\n        return LIGHT_COLOR;\n        case FLOOR_ID:\n        return cosine * softShadow(-lightVec, p, 0.1, 10.0) * LIGHT_COLOR;\n        break;\n        case -1:\n        return vec3(0., 0., 0.);\n    }\n}\n\nfloat fiveTapAO(vec3 p, vec3 n, float k) {\n    float aoSum = 0.0;\n    for(float i = 0.0; i < 5.0; ++i) {\n        float coeff = 1.0 / pow(2.0, i);\n        aoSum += coeff * (i * AO_DIST - shadowMap3D(p + n * i * AO_DIST));\n    }\n    return 1.0 - k * aoSum;\n}\n\nIntersection sdf3D(vec3 dir, vec3 eye)\n{\n    float t;\n    int objectID;\n    march(eye, dir, t, objectID);\n    vec3 intersection = eye + t * dir;\n    vec3 nor = computeNormal(intersection);\n    vec3 lightDir = normalize(intersection - LIGHT_POS);\n    float thickness = fiveTapAO(intersection, -nor, FIVETAP_K);\n    vec3 surfaceColor = computeMaterial(objectID, intersection, nor, lightDir, normalize(eye - intersection), thickness);\n    return Intersection(t, surfaceColor, intersection, objectID);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord/iResolution.xy) * 2. - vec2(1.0, 1.0);\n    vec3 eye = rotateY(vec3(0, 2, -15), iTime);\n    vec3 ref = vec3(0, 2, 0);\n    vec3 rayDir = shootRay(eye, ref, uv);\n    Intersection it = sdf3D(rayDir, eye);\n    fragColor = vec4(it.color, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/sdfSzH.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "sdfXRf", "name": "parallax_route_66.ff3", "author": "ff3", "description": "Parallax highway scenery.  The next iteration is going to have rays from the sun and the yellow line is going to periodically switch to a dotted line.  I'll maybe add some highlights on the hills if I get ambitious.", "tags": ["cartoon", "parallax", "road"], "likes": 1, "viewed": 45, "date": "1619046194", "time_retrieved": "2024-06-20T20:38:33.305129", "image_code": "const float TWO_PI = 6.283185307; //good old 2 pi\nconst float SPEED = 20.; //adjustment factor of iTime\nconst float BASE_HILL_SPEED = .01; //percent per frame the front set of hills move\nconst float BORDER = .003; //border width for anti-aliasing\n\nvec4 YELLOW = vec4(.8,.8,0,1); //pallette\nvec4 GREY = vec4(.3,.3,.3,1);\nvec4 GREEN = vec4(0,.8,0,1);\nvec4 BLUE = vec4(0.15,0.15,.8,1);\n\nvec2 hillVector(vec2 uv, float percentPerFrame)\n{\n    float angle = (uv.x + mod(iTime * SPEED * percentPerFrame, iResolution.x)) * TWO_PI;\n    float offset = .1 * cos(angle);\n    \n    return uv + vec2(0,offset);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    //set uv coords from -.5 to .5 with origin in the middle\n    vec2 uv = (fragCoord - (.5*vec2(iResolution))) / iResolution.xx;\n    \n    vec2 hillvec = hillVector(uv, BASE_HILL_SPEED);\n    vec2 hillvec_2 = hillVector(uv, BASE_HILL_SPEED * .5); //parallax\n    vec2 hillvec_3 = hillVector(uv, BASE_HILL_SPEED * .25); //parallax\n\n    float isHill1,isHill2,isHill3,isSun,isNotRoad,isPaint;\n    isSun = smoothstep(51.,49.,distance(fragCoord,iResolution.xy));\n    isHill1 = smoothstep(BORDER,-BORDER,hillvec.y);\n    isHill2 = smoothstep(-.03+BORDER,-.03-BORDER,hillvec_2.y);\n    isHill3 = smoothstep(-.06+BORDER,-.06-BORDER,hillvec_3.y);\n    isNotRoad = step(-.2, uv.y);\n    isPaint = (1.0 - step(-.236, uv.y)) - (1.0 - step(-.24, uv.y))\n              + (1.0 - step(-.23, uv.y)) - (1.0 - step(-.234, uv.y));\n\n    fragColor = isHill3 * (GREEN * .25) + (1.0 - isHill3) * BLUE;\n    fragColor = isHill2 * (GREEN *.5) + (1.0 - isHill2) * fragColor;\n    fragColor = isHill1 * GREEN + (1.0 - isHill1) * fragColor;\n    fragColor = isSun * YELLOW + (1.0 - isSun) * fragColor;\n    fragColor = (1.0 - isNotRoad) * GREY + isNotRoad * fragColor;\n    fragColor = isPaint * YELLOW + (1.0 - isPaint) * fragColor;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/sdfXRf.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "sdfXz7", "name": "Penumbra Shadow approximation", "author": "eyadnabeel", "description": "Raymarched penumbra shadow approximation", "tags": ["cis561hw"], "likes": 3, "viewed": 36, "date": "1618588052", "time_retrieved": "2024-06-20T20:38:35.074338", "image_code": "#define PI 3.14159\n#define EPSILON 0.0001\n#define PI_2 PI/2.f\n\n#define INFINITY 99999999999999999999999999.99\n\n#define SPHERE 0\n#define BOX 1\n#define PLANE 2\n\n#define LAMBERT 0\n#define TEXTURE 1\n#define LIGHT 2\n\nconst float SHADOW_HARDNESS = 6.0;\nconst int RAY_STEPS = 50;\n\n#define NUM_SHAPES 4\n\nstruct Intersection\n{\n    float t;\n    vec3 point;\n    vec3 normal;\n    vec3 color;\n};\n\nstruct Shape\n{\n    int type, material;\n    vec3 translate, rotate, scale;\n    vec3 color;\n};\n\nShape [NUM_SHAPES] s;\n\nvec2 noise_2D (vec2 p)\n{\n    return fract(sin(vec2(dot(p,vec2(127.1,311.7)),dot(p,vec2(269.5,183.3))))*43758.5453);\n}\n\nvoid computeRay (vec3 eye, vec3 ref, vec2 ndc, float fov, out vec3 ro, out vec3 rd)\n{\n    // TODO: Implement ray computation\n    vec3 look = ref - eye;\n    \n    float len = tan(fov * PI/180.f) * distance(eye, ref);\n    \n    vec3 v, h;\n    h = normalize(cross(vec3(0.0, 1.0, 0.0), ref - eye));\n    v = normalize(cross(h, look));;\n\n    h *= len * iResolution.x/iResolution.y;\n    v *= len;\n    \n    vec3 p = ref + ndc.x * h + ndc.y * v;\n            \n    p = ref + ndc.x * h + ndc.y * v;\n        \n    ro = eye;\n    rd = normalize(p - eye);\n}\n\nfloat sdf_sphere(vec3 ro, vec3 p, float r)\n{\n    return length(p - ro) - r;\n}\n\nfloat sdf_cube(vec3 ro, vec3 p, vec3 b)\n{\n    vec3 ro_shifted = ro + p;\n    vec3 q = abs(ro_shifted) - b;\n    return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat sdf_plane(vec3 ro, vec3 n, float h)\n{\n  // n must be normalized\n  \n  vec3 dist = vec3(min(1.f - abs(ro.x), 0.f), min(1.f - abs(ro.y), 0.f), dot(ro, n));\n  return length(dist);\n}\n\nmat4 compute_transformation(int idx)\n{\n    mat4 rot_x, rot_y, rot_z, scale, translate;\n    \n    rot_x = mat4(vec4(1.f, 0.f, 0.f, 0.f), \n                 vec4(0.f, cos(s[idx].rotate.x), sin(s[idx].rotate.x), 0.f), \n                 vec4(0.f, -sin(s[idx].rotate.x), cos(s[idx].rotate.x), 0.f), \n                 vec4(0.f, 0.f, 0.f, 1.f));\n                 \n    rot_y = mat4(vec4(cos(s[idx].rotate.y), 0.f, -sin(s[idx].rotate.y), 0.f), \n                 vec4(0.f, 1.f, 0.f, 0.f), \n                 vec4(sin(s[idx].rotate.y), 0.f, cos(s[idx].rotate.y), 0.f), \n                 vec4(0.f, 0.f, 0.f, 1.f));\n    \n    rot_z = mat4(vec4(cos(s[idx].rotate.z), sin(s[idx].rotate.z), 0.f, 0.f), \n                 vec4(-sin(s[idx].rotate.z), cos(s[idx].rotate.z), 0.f, 0.f), \n                 vec4(0.f, 0.f, 1.f, 0.f), \n                 vec4(0.f, 0.f, 0.f, 1.f));\n                 \n    scale = mat4(vec4(s[idx].scale.x, 0.f, 0.f, 0.f), \n                 vec4(0.f, s[idx].scale.y, 0.f, 0.f), \n                 vec4(0.f, 0.f, s[idx].scale.z, 0.f), \n                 vec4(0.f, 0.f, 0.f, 1.f));\n                 \n    translate = mat4(vec4(1.f, 0.f, 0.f, 0.f), \n                     vec4(0.f, 1.f, 0.f, 0.f), \n                     vec4(0.f, 0.f, 1.f, 0.f), \n                     vec4(s[idx].translate.x, s[idx].translate.y, s[idx].translate.z, 1.f));\n    return translate * rot_z * rot_y * rot_x * scale;\n}\n\nvec3 computeNormal(int idx, vec3 ro, vec3 p, vec3 b, float r)\n{\n    vec3 normal;\n    float minus_x, plus_x;\n    float minus_y, plus_y;\n    float minus_z, plus_z;\n    if (s[idx].type == 0){\n        // SPHERE NORMALS\n        minus_x = sdf_sphere(vec3(ro.x - EPSILON, ro.yz), p, r);\n        plus_x = sdf_sphere(vec3(ro.x + EPSILON, ro.yz), p, r);\n        minus_y = sdf_sphere(vec3(ro.x, ro.y - EPSILON, ro.z), p, r);\n        plus_y = sdf_sphere(vec3(ro.x, ro.y + EPSILON, ro.z), p, r);\n        minus_z = sdf_sphere(vec3(ro.xy, ro.z - EPSILON), p, r);\n        plus_z = sdf_sphere(vec3(ro.xy, ro.z + EPSILON), p, r);\n    } else if (s[idx].type == 1){\n        // BOX NORMALS\n        minus_x = sdf_cube(vec3(ro.x - EPSILON, ro.yz), p, b);\n        plus_x = sdf_cube(vec3(ro.x + EPSILON, ro.yz), p, b);\n        minus_y = sdf_cube(vec3(ro.x, ro.y - EPSILON, ro.z), p, b);\n        plus_y = sdf_cube(vec3(ro.x, ro.y + EPSILON, ro.z), p, b);\n        minus_z = sdf_cube(vec3(ro.xy, ro.z - EPSILON), p, b);\n        plus_z = sdf_cube(vec3(ro.xy, ro.z + EPSILON), p, b);\n    } else if (s[idx].type == 2){\n        // PLANE NORMALS\n        minus_x = sdf_plane(vec3(ro.x - EPSILON, ro.yz), p, r);\n        plus_x = sdf_plane(vec3(ro.x + EPSILON, ro.yz), p, r);\n        minus_y = sdf_plane(vec3(ro.x, ro.y - EPSILON, ro.z), p, r);\n        plus_y = sdf_plane(vec3(ro.x, ro.y + EPSILON, ro.z), p, r);\n        minus_z = sdf_plane(vec3(ro.xy, ro.z - EPSILON), p, r);\n        plus_z = sdf_plane(vec3(ro.xy, ro.z + EPSILON), p, r);\n    }\n    normal = vec3(plus_x - minus_x, plus_y - minus_y, plus_z - minus_z);\n    mat3 inverse_transpose = mat3(transpose(inverse(compute_transformation(idx))));\n    return normalize(inverse_transpose * normal.xyz);\n}\n\n\nIntersection intersect (int idx, vec3 ro, vec3 rd)\n{\n    mat4 transformation = compute_transformation(idx);\n    mat4 inverse_transformation = inverse(compute_transformation(idx));\n    vec3 local_ro = (inverse_transformation * vec4(ro, 1.f)).xyz;\n    vec3 local_rd = (inverse_transformation * vec4(rd, 0.f)).xyz;\n    Intersection isect;\n    float t;\n    if (s[idx].type == 0){\n        t = sdf_sphere(local_ro, vec3(0.f), 1.f);\n    } else if (s[idx].type == 1){\n        t = sdf_cube(local_ro, vec3(0.f), vec3(1.f));\n    } else if (s[idx].type == 2){\n        t = sdf_plane(local_ro, vec3(0.f, 0.f, 1.f), 0.f);\n    }\n    while (t >= 0.0 && t <= 50.0){\n        if (t <= EPSILON && t >= 0.0){\n            isect.point = (transformation * vec4(local_ro + local_rd * t, 1.f)).xyz;\n            isect.t = distance(ro, isect.point);\n            if (s[idx].type == 0){\n                isect.normal = computeNormal(idx, local_ro, vec3(0.f), vec3(0.f), 1.0);\n            } else if (s[idx].type == 1){\n                isect.normal = computeNormal(idx, local_ro, vec3(0.f), vec3(1.f), 0.0);\n            } else if (s[idx].type == 2){\n                isect.normal = computeNormal(idx, local_ro, vec3(0.f, 0.f, 1.f), vec3(0.f), 0.0);\n            }\n            return isect;\n        }\n        local_ro += local_rd * t;\n        if (s[idx].type == 0){\n            t = sdf_sphere(local_ro, vec3(0.f), 1.f);\n        } else if (s[idx].type == 1){\n            t = sdf_cube(local_ro, vec3(0.f), vec3(1.f));\n        } else if (s[idx].type == 2){\n            t = sdf_plane(local_ro, vec3(0.f, 0.f, 1.f), 0.f);\n        }\n    }\n    isect.t = -1.f;\n    return isect;\n}\n\nfloat min_sdf (int main_idx, vec3 ro)\n{\n    mat4 inverse_transformation = inverse(compute_transformation(0));\n    vec3 local_ro = (inverse_transformation * vec4(ro, 1.f)).xyz;\n    Intersection isect;\n    float t, t_trans;\n\n    t = INFINITY;\n    \n    for (int idx = 0; idx < NUM_SHAPES; idx++){\n        if (idx == main_idx || s[idx].material == LIGHT){\n            continue;\n        }\n        inverse_transformation = inverse(compute_transformation(idx));\n        local_ro = (inverse_transformation * vec4(ro, 1.f)).xyz;\n        if (s[idx].type == 0){\n            t_trans = sdf_sphere(local_ro, vec3(0.f), 1.f);\n        } else if (s[idx].type == 1){\n            t_trans = sdf_cube(local_ro, vec3(0.f), vec3(1.f));\n        } else if (s[idx].type == 2){\n            t_trans = sdf_plane(local_ro, vec3(0.f, 0.f, 1.f), 0.f);\n        }\n        if (t_trans < t && t >= 0.f){\n            t = t_trans;\n        } else if (t < 0.f){\n            t = t_trans;\n        }\n    }\n    return t;\n}\n\nvoid intersect_scene(vec3 ro, vec3 rd, out Intersection isect, out Shape isect_shape)\n{\n    isect = intersect(0, ro, rd);\n    Intersection test;\n    isect_shape = s[0];\n    \n    for (int i = 0; i < NUM_SHAPES; i++){\n        test = intersect(i, ro, rd);\n        if (test.t < isect.t && test.t > -1.f){\n            isect = test;\n            isect_shape = s[i];\n        } else if (isect.t < 0.f){\n            isect = test;\n            isect_shape = s[i];\n        }\n    }\n}\n\nvoid intersect_scene_excluding(int idx, vec3 ro, vec3 rd, out Intersection isect, out Shape isect_shape)\n{\n    Intersection test;\n    if (idx == 0){\n        isect = intersect(1, ro, rd);\n        isect_shape = s[1];\n    } else {\n        isect = intersect(0, ro, rd);\n        isect_shape = s[0];\n    }\n    \n    for (int i = 0; i < NUM_SHAPES; i++){\n        if (i == idx || s[i].material == LIGHT){\n            continue;\n        }\n        test = intersect(i, ro, rd);\n        if (test.t < isect.t && test.t > -1.f){\n            isect = test;\n            isect_shape = s[i];\n        } else if (isect.t < 0.f){\n            isect = test;\n            isect_shape = s[i];\n        }\n    }\n}\n\nfloat shadow(vec3 dir, vec3 origin, float light_dist, int idx) {\n    float res = 1.f;\n    float t = EPSILON;\n    for (int i = 0; i < RAY_STEPS; ++i){\n        float m = min_sdf(idx, origin + t * dir);\n        if (m < EPSILON){\n            return 0.f;\n        }\n        if (m >= 0.f){\n            res = min(res, (SHADOW_HARDNESS * m)/t);\n            t += m;\n        } else {\n            return 1.f;\n        }\n    }\n    return res;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //CAMERA VARIABLES\n    vec3 eye, ref, rayLook;\n    vec3 look, up, right;\n    float fov;\n    \n    fov = 25.f;\n    eye = vec3(-10.0 , 3.0, 10);\n    ref = vec3(0.0, 0.0, 0.0);\n    \n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    // Normalized device coordinates (from -1 to 1)\n    vec2 ndc = vec2((2.f * uv.x) - 1.f, 1.f - (2.f * uv.y)); \n    \n    vec3 ro, rd;\n    \n    computeRay(eye, ref, ndc, fov, ro, rd);\n    \n    vec3 col = vec3(0.0);\n        \n    \n    s[0].type = PLANE;\n    s[0].material = TEXTURE;\n    s[0].translate = vec3(0.f, -3.f, 0.f);\n    s[0].rotate = vec3(PI/2.f, 0.f, 0.f * sin(iTime));\n    s[0].scale = vec3(40.f, 40.f, 1.f);\n    s[0].color = vec3(1.f, 1.f, 0.9f);\n    \n    s[1].type = SPHERE;\n    s[1].material = LAMBERT;\n    s[1].translate = vec3(0.f, -1.f, 0.f);\n    s[1].rotate = vec3(0.f, 0.f, 0.f * sin(iTime));\n    s[1].scale = vec3(2.f, 2.f, 2.f);\n    s[1].color = vec3(1.f, 0.2f, 0.1f);\n    \n    s[2].type = BOX;\n    s[2].material = LAMBERT;\n    s[2].translate = vec3(3.f, 0.f, 3.f);\n    s[2].rotate = vec3(0.f,  -iTime, 0.f * sin(iTime));\n    s[2].scale = vec3(1.f, 3.f, 1.f);\n    s[2].color = vec3(0.1f, 0.7f, 0.1f);\n    \n    \n    vec3 lightPos = vec3(-10.5f * cos(iTime), 10.5f * abs(cos(iTime)), 10.5f * sin(iTime));\n    \n    Shape light;\n    light.type = SPHERE;\n    light.material = LIGHT;\n    light.translate = lightPos;\n    light.scale = vec3(1.f);\n    light.rotate = vec3(0.f);\n    light.color = vec3(0.92, 0.9, 0.8);\n    \n    s[3] = light;\n\n    Intersection isect;\n    Shape isect_shape;\n    intersect_scene(ro, rd, isect, isect_shape);\n    \n    int idx;\n    \n    for (int i = 0; i < NUM_SHAPES; i++){\n        if (isect_shape == s[i]){\n            idx = i;\n            break;\n        }\n    }\n    \n    float threshold = 80.f;\n    \n    if (isect.t > -1.0){\n        float dist = 1.f - (isect.t * isect.t)/(threshold * threshold);\n        float lambert = max(dot(isect.normal, normalize(lightPos - isect.point)), 0.f);\n        float penumbra_shadow = shadow(normalize(lightPos - isect.point), isect.point, distance(isect.point, lightPos), idx);\n        switch(isect_shape.material){\n            case LAMBERT:\n            col = isect_shape.color * lambert * penumbra_shadow;\n            break;\n            case TEXTURE:\n            float t = floor(mod(1.0 * (sin(isect.point.x) + sin(isect.point.z)), 2.0));\n            col = mix(vec3(0.5), vec3(1.0), t) * isect_shape.color * lambert * penumbra_shadow * dist;\n            break;\n            case LIGHT:\n            col = isect_shape.color;\n            break;\n        }\n        \n        \n    }\n    \n    // Output to screen\n    fragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/sdfXz7.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "sdj3Dc", "name": "大龙猫 - Reflect Test", "author": "totetmatt", "description": "First Time Implementation of Reflection. ", "tags": ["reflect"], "likes": 6, "viewed": 143, "date": "1618073024", "time_retrieved": "2024-06-20T20:38:35.080580", "image_code": "#define fGlobalTime iTime\nmat2 rot(float a){\n    float c=cos(a),s=sin(a);\n     return mat2(c,-s,s,c);\n     }\nfloat sdBoxFrame( vec3 p, vec3 b, float e )\n{\n  p = abs(p  )-b;\n  vec3 q = abs(p+e)-e;\n  return min(min(\n      length(max(vec3(p.x,q.y,q.z),0.0))+min(max(p.x,max(q.y,q.z)),0.0),\n      length(max(vec3(q.x,p.y,q.z),0.0))+min(max(q.x,max(p.y,q.z)),0.0)),\n      length(max(vec3(q.x,q.y,p.z),0.0))+min(max(q.x,max(q.y,p.z)),0.0));\n}\n\nfloat sdBox(vec3 p,vec3 b){\n    vec3 q = abs(p)-b;\n    return length(max(q,vec3(.0))) + min(max(max(q.x,q.y),q.z),.0);\n  }\nvec2 mmin(vec2 a,vec2 b){ return a.x<b.x ? a:b;}\nvec2 sdf (vec3 p){\n  vec3 bp= p;\n\n  vec3 bbp= bp;\n  bbp.xz*=rot(-fGlobalTime*.3);\n    bbp.zy*=rot(-fGlobalTime*.3);\n  vec2 h = vec2(sdBoxFrame(bbp,vec3(1.),.125),1.0);\n  vec2 bbox = vec2(-sdBox(p,vec3(10.)),3.);\n  h = mmin(h,bbox);\n  \n  \n  bp.xz *=rot(fGlobalTime);\n  float bb = 1000.;\n  for(float i=.0;i<4.;i++){\n    bp.xy= abs(bp.xy)-.5*i;\n    bp.xz = bp.x < bp.z ? bp.xz:bp.zx;\n    bp*=1.2;\n    bp.xy*=rot(.415*i*3.);\n    bb = -min(bb,sdBox(bp,vec3(.50,.5,.55))/1.5);\n  }\n vec3 pppp = p;\n  pppp.xz *=rot(fGlobalTime*.5);\n   pppp.xy *=rot(fGlobalTime*.5);\n  vec2 t = vec2(length(abs(abs(pppp)-1.5)-1.5)-.5,2.);\n  t.x = max(t.x,-bb); \n  h = mmin(h,t);\n  return h;\n}\nvec2 nv = vec2(.0001,.0);\nvec3 norm(vec3 p){\n    float d= sdf(p).x;\n    return normalize(vec3(d-sdf(p-nv.xyy).x,d-sdf(p-nv.yxy).x,d-sdf(p-nv.yyx).x));\n  }\nvec2 raym(vec3 ro,vec3 rd,float stp,inout vec3 rp,inout bool bounce){\n     float td=0.01;\n     for(float i=0.; i<=stp;i++){\n          vec2 d = sdf(rp);\n          td+=d.x;\n          rp+=rd*d.x*.7;\n          if(d.x <= 0.00001){\n            if(d.y ==2.){\n                bounce = true;\n          \n                rd = reflect(rd,norm(rp));\n                rp+=rd*.00001;\n                \n            } else {\n             return vec2(td,d.y);\n              }\n          }\n       }\n     return vec2(td,-1.);\n   }\n vec3 pal(float t){\n  return vec3(.2,.5,.7)+vec3(.7,.2,.5)*cos(2.*3.1415*(1.*t+vec3(.3,.4,.6)));\n   }\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord-.5*iResolution.xy) / iResolution.y;\n    \n    vec2 puv = vec2(fragCoord.x / iResolution.x, fragCoord.y / iResolution.y);\n\nvec3 col = vec3(.1);\n  vec3 ro = vec3(-0.5,.5,-4.);\n  ro.xy *=rot(fGlobalTime*.33);\n  bool bounce = false;\n  vec3 rd=vec3(uv,1.0),rp=ro+rd*.001;\n  vec2 d  = raym(ro,rd,69.*2.,rp,bounce);\n  vec3 light = vec3(5.,5.,-5.);\n  light = abs(light)-10.5;\n  light.xz *=rot(fGlobalTime*2.);\n  light.y = sin(fGlobalTime*2.)*10.;\n  if(d.y >0.){\n      if(d.y == 1.){\n       \n      vec3 n = norm(rp);\n      float lmb = max(0.,dot(normalize(light),n));\n      float dlight = length(rp-light)/5.;\n        if(bounce) {lmb=lmb*2.;}\n        float qq = max(rp.y/10.0,.0);\n      col =pal(length(qq*.5)*dlight+fGlobalTime)*lmb/dlight*2.;\n      \n      }  if(d.y == 3.){\n       \n      vec3 n = norm(rp);\n      float lmb = max(0.,dot(normalize(light),n));\n      float dlight = length(rp-light)/5.;\n        if(bounce) {lmb=lmb*2.;}\n        float qq = max(rp.y/10.0,.0);\n      col =col/dlight+vec3(.7,.0,.5)*lmb/dlight*2.;\n       // if(bounce) {col = pal(length(qq)+fGlobalTime)*lmb/dlight*2.;}\n      } \n       if(bounce) { \n        col = pow(col,vec3(1.5));\n         }\n    }\n\n\n   \n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/sdj3Dc.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "sdj3W3", "name": "noisey col journey * cam", "author": "SimonOakey", "description": "licenced under love, peace and happyness ✌️", "tags": ["noise", "color", "loop", "field", "multiple"], "likes": 2, "viewed": 283, "date": "1618062952", "time_retrieved": "2024-06-20T20:38:35.741082", "image_code": "/*licenced under love, peace and happyness ✌️ */\n\n\n#ifdef GL_ES\nprecision mediump float;\n#endif\n\n const float PI = 3.14159;\n\nuniform float time;\nuniform vec2 mouse;\nuniform vec2 resolution;\n\n#define time iTime\n#define resolution iResolution\n\nvec2 ouv;\n\n\n //generic rotation formula\nvec2 rot(vec2 uv,float a){\n\treturn vec2(uv.x*cos(a)-uv.y*sin(a),uv.y*cos(a)+uv.x*sin(a));\n}\n\n\n\nvec3 returnGrain(vec2 _uv, float amount){\n\t\n\t float x = (_uv.x + 4.0 ) * (_uv.y + 4.0 ) * (time * 10.0);\n\t vec4 grain = vec4(mod((mod(x, 13.0) + 1.0) * (mod(x, 123.0) + 1.0), 0.01)-0.005) *  amount;\n\t return grain.xyz;\n\t\n}\n\n\nfloat rand(vec2 n) { \n    return fract(sin(dot(n, vec2(12.9898, 4.1414))) * 43758.5453);\n}\n\nfloat noise(vec2 p){\n    vec2 ip = floor(p);\n    vec2 u = fract(p);\n    u = u*u*(3.0-2.0*u);\n\n    float res = mix(\n        mix(rand(ip),rand(ip+vec2(1.0,0.0)),u.x),\n        mix(rand(ip+vec2(0.0,1.0)),rand(ip+vec2(1.0,1.0)),u.x),u.y);\n    return res*res;\n}\n\nconst mat2 mtx = mat2( 0.80,  0.60, -0.60,  0.80 );\n\nfloat fbm( vec2 p )\n{\n    float f = 0.0;\n    \n     vec4 cc = texture(iChannel0,ouv );\n\t\n\tfor(int i=0;i<11; i++){\n\n\n    \n    \n\tvec2 p1 = vec2(p.x*.4*float(i),p.y*.4*float(i));\n\t\t\n\tp1.x *=\tnoise(p1*.5+time*.1)*.4;\n\tp1.y *=\tnoise(p*.5-time*.1)*.4;\n    \n\n    f -=  noise(vec2(cc.r,cc.b ))*.019;\n    f +=  noise(p1); \n       \n    \n\t\n\t}\n\t\n\n    return f;\n}\n\nfloat pattern( in vec2 p )\n{\n\treturn fbm( p + fbm( p*2.3 + fbm( p*.33 ) ) );\n}\n\n\n\nvec3 hsv2rgb( in vec3 c )\n{\n    vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n    return c.z * mix( vec3(1.0), rgb, c.y);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n\tfloat _x = mouse.x;\n\n\tvec2 uv = gl_FragCoord.xy/resolution.y;\n\t\n\t\n\t\n\tuv.x += resolution.y/resolution.x;\n    \n    \n    ouv = gl_FragCoord.xy/resolution.xy;\n   \n    \n    \n\t\n\tuv = rot(uv,time*.03);\n\t\n\tfloat shade = pattern(uv);\n\t\n\t\n    vec2 uv_osc = vec2( \n    sin(uv.x*PI*1.+PI)*.5+.5,\n    sin(uv.y*PI*1.+PI)*.5+.5\n    );\n    \n   \n     vec4 cc = texture(iChannel0,uv_osc );\n    \n    \n   // shade += sin(fbm( vec2(cc.r,cc.b))  )*12.;\n    \n    \n\t\n\tvec3 col = vec3(\n\t\tsin(shade*.91+ time*.01)*1.75+.5 ,\n\t\tcos(shade*3.+ time*.13)*.75+.5 ,\n\t\tcos(shade*13.+ time*.13)*.5+.6 \n\t\t\t//shade*.7+.4\n\t);\n\t\n\tcol = hsv2rgb(col);\n\t\n\tcol += returnGrain(uv,9.);\n\t\n\tfragColor = vec4( col, 1.0 );\n\n}\n\n\n\n\n ", "image_inputs": [{"id": "4sf3zn", "previewfilepath": "/presets/webcam.png", "channel": 0, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/presets/webcam.png", "ctype": "webcam"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "unknown-license-reference", "thumbnail": "https://www.shadertoy.com/media/shaders/sdj3W3.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "sdj3Wc", "name": "Pixellerman", "author": "z0rg", "description": "There once was a ship that put to sea\nAnd the name of that ship was the Billy o' Tea\nThe winds blew hard, her bow dipped down\nBlow, me bully boys, blow (huh)", "tags": ["pixel", "boat", "retrowave"], "likes": 11, "viewed": 208, "date": "1618070560", "time_retrieved": "2024-06-20T20:38:36.565453", "image_code": "// This work is licensed under the Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n// Unported License. To view a copy of this license, visit http://creativecommons.org/licenses/by-nc-sa/3.0/ \n// or send a letter to Creative Commons, PO Box 1866, Mountain View, CA 94042, USA.\n// =========================================================================================================\n\n#define sat(a) clamp(a, 0., 1.)\n\nmat2 r2d(float a) { float c = cos(a), s = sin(a); return mat2(c, -s, s, c); }\n\nvec3 gradient(float f)\n{\n    vec3 cols[3];\n    \n    cols[0] = vec3(0.169,0.086,0.816);\n    cols[1] = vec3(0.835,0.216,0.843);\n    cols[2] = vec3(1.,1.,1.);\n    \n    float cnt = 2.;\n    float cur = f*cnt;\n    float curIdx = floor(cur);\n    return mix(cols[int(curIdx)], cols[int(min(curIdx+1., cnt))], sat(fract(cur)));\n}\n\nfloat lenny(vec2 v)\n{\n    return abs(v.x)+abs(v.y);\n}\n\nfloat _loz(vec2 p, float r)\n{\n    return lenny(p)-r;\n}\n\nfloat _cir(vec2 p, float r)\n{\n    return length(p)-r;\n}\nfloat _sqr(vec2 p, vec2 s)\n{\n    vec2 l = abs(p)-s;\n    return max(l.x, l.y);\n}\n\nfloat _boat(vec2 p)\n{\n    vec2 op = p;\n    p.y = abs(p.y)-.08;\n    p.y+=sin(iTime*3.)*.005;\n    p.x = mod(p.x-iTime*.05, 2.)-1.;\n    vec2 c = vec2(0.,-.1);\n    p-=c;\n    p *= r2d(sin(iTime*2.)*.1);\n    p+=c;\n    float base = max(_cir(p, .1),p.y+.05);\n    base = min(base, _sqr(p, vec2(0.005,.1)));\n    base = min(base, max(_loz(p*vec2(3.,.75)+vec2(p.y*.75-.12,0.025),.1), -p.y-.04));\n    if (op.y < 0.)\n    base = max(max(base, sin(p.y*500.)+.8), abs(p.x)-0.05-sin(p.y*150.-iTime*2.)*.025);\n    return base;\n}\n\nfloat _fence(vec2 p)\n{\n    p -= vec2(-0.1,-.3);\n    vec2 op = p;\n    p.y = abs(p.y)-.05;\n\n    p.x = min(p.x,0.15);\n\n    float rep = .1;\n    p.x = mod(p.x+.5*rep, rep)-.5*rep;\n    float bar = _sqr(p, vec2(.01,.05));\n    \n    float top = _sqr(p-vec2(0.,.05), vec2(.4,.015));\n    \n    float base = min(bar, top);\n    base = max(base, op.x-.05);\n    if (op.y < 0.)\n        base = max(max(base, sin(op.y*500.)+.8), abs(p.x)-0.01-sin(p.y*150.-iTime*2.)*.01);\n    return base;\n}\n\n#define FFT(f) texelFetch(iChannel1, ivec2(f, 0),0).x\n\nvec3 rdr(vec2 uv, vec2 fragCoord)\n{\n    float stp = 0.005;// mix(0.005,0.1, sat(.5+.5*asin(sin(iTime*.5))/1.57));\n    uv = floor(uv/stp)*stp;\n    vec3 col;\n    \n    col = gradient(sat(-uv.y*3.+.75));\n    \n    vec2 sPos = uv*vec2(1.,sign(uv.y))-vec2(0.,.1+sin(iTime*.25)*.1);\n\n    float sun = _cir(sPos, .15);\n\n    if (uv.y < 0.)\n    {\n        float sunborder = abs(sPos.x)-.1-.05*sin(sPos.y*150.+iTime);\n        sun = max(max(sun, (sin(uv.y*500.)+.8)), sunborder);\n    }\n    \n    col = mix(col, vec3(0.055,0.408,0.867), sat(-uv.y*400.));\n    col += pow(texture(iChannel0, uv).x, 25.);\n    \n    col += 2.*pow(1.-sat(lenny((uv-vec2(.55,.25))*.25)*5.),15.)*vec3(1.)*pow(sat(FFT(50)), .75);\n    col += pow(1.-sat(lenny((uv-vec2(.35,.15))*.25)*15.),15.)*vec3(1.)*pow(sat(FFT(50)+.25), .75);\n    col += pow(1.-sat(lenny((uv-vec2(.35,.15))*.25)*15.),15.)*vec3(1.)*pow(sat(FFT(100)+.25), .75);\n    col += pow(1.-sat(lenny((uv-vec2(-.35,.25))*.25)*15.),15.)*vec3(1.)*pow(sat(FFT(150)+.25), .75);\n\n    \n    col = mix(col, mix(vec3(1.000,0.784,0.000), vec3(1.,0.,0.), 1.-sat(sPos.y*16.+1.75)), 1.-sat(sun*400.));\n    \n    float boat = _boat(uv-vec2(0.4,-0.05));\n    col = mix(col, vec3(0.), 1.-sat(boat*400.));\n    \n    float fence = _fence(uv);\n    col = mix(col, vec3(0.), 1.-sat(fence*400.));\n    \n\n\n    \n    col += (texture(iChannel0, uv*2.).x-.5)*.1;\n    vec2 uvv = uv; // vignette\n    uvv.x = mod(uvv.x-iTime*.05-.4, 2.)-1.;\n    col *= pow(sat(1.-sat(length((uvv)*2.)-.5)+.35),.5)*max(pow(FFT(10),.25),.5);\n    col += vec3(1.000,0.784,0.000)*1.5*col*pow(1.-sat(lenny(2.*sPos*vec2(1.,1.))-.35), 1.);\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-vec2(.5)*iResolution.xy)/iResolution.xx;\n\n    vec3 col = rdr(uv*1.5-vec2(-0.2,-.05), fragCoord);\n\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": "4dXGzn", "previewfilepath": "/media/ap/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "ctype": "texture"}, {"id": "XtsSW2", "previewfilepath": "https://soundcloud.com/sephcarissa/the-wellerman-8-bit-version", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0, "src": "https://soundcloud.com/sephcarissa/the-wellerman-8-bit-version", "ctype": "musicstream"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc-by-nc-sa-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/sdj3Wc.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "sdj3Wd", "name": "grid of circles", "author": "said6289", "description": "A grid of circles", "tags": ["pattern"], "likes": 0, "viewed": 35, "date": "1618156488", "time_retrieved": "2024-06-20T20:38:36.571627", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{   \n    float GRID_SIZE = 50.0;\n    float RADIUS = 15.0;\n    \n    vec2 p = fragCoord - iResolution.xy * 0.5;\n    p = mod(p, GRID_SIZE);\n    \n    vec2 d = p - vec2(0.5 * GRID_SIZE);\n    float len = length(d);\n\n    float spread = 1.0 + (RADIUS * 0.5) * (sin(iTime) + 1.0) * 0.5;\n    fragColor = vec4(1.0 - smoothstep(RADIUS - spread, RADIUS + spread, len), 0, 0, 1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/sdj3Wd.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "sdj3zd", "name": "Distance to feature points I", "author": "tomoe", "description": "Cellular noise given by the distance to the closest feature point which is moving around the lattice", "tags": ["bd202104"], "likes": 0, "viewed": 67, "date": "1617845525", "time_retrieved": "2024-06-20T20:38:36.571627", "image_code": "uvec3 k = uvec3(0x456789abu, 0x6789ab45u, 0x89ab4567u);\nconst uint max32 = 0xffffffffu;\nconst float PI = 3.14159265359;\nuvec2 hash22u(uvec2 n) {  \n    n ^= (n.yx << 24);\n    n ^= (n.yx >> 1);\n    n *= k.xy;\n    n ^= (n.yx << 1);\n    return n * k.xy;\n}\nvec2 hash22(vec2 p) {\n    uvec2 n = uvec2(p);\n    return vec2(hash22u(n)) / vec2(max32) - 0.5;\n}\nfloat F1(vec2 p){   \n    vec2 n = round(p);\n    vec2 f = p - round(p);\n    float dist = sqrt(2.0);\n    for(float j = - 2.0; j <= 2.0; j ++ ) {\n        for(float i = - 2.0; i <= 2.0; i ++ ){\n            vec2 nbd = vec2(i, j);\n            nbd += sin(iTime) * hash22(n + nbd);\n            dist = min(dist, distance(nbd, f));\n        }\n    }\n    return dist;\n}\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n    vec2 pos = fragCoord.xy/ iResolution.xx;\n    pos *= 20.0;\n    pos += iTime;\n    fragColor = vec4(vec3(F1(pos)), 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/sdj3zd.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "sdj3zt", "name": "Inverse Reflection - Plane", "author": "oneshade", "description": "Finding the incident point given a light position, a point, reflector position, and reflector direction (for line reflectors). Set the light and point by dragging the mouse.", "tags": ["reflection", "ray", "math", "light", "plane", "physics", "optics", "incidence"], "likes": 6, "viewed": 62, "date": "1617838826", "time_retrieved": "2024-06-20T20:38:37.068574", "image_code": "// \"Inverse Reflection\" by oneshade\n// Original: https://www.desmos.com/calculator/dvs5kyylbm\n// Improvement 1: https://www.desmos.com/calculator/kvouvidoku\n// Improvement 2 (based on @mla's comment): https://www.desmos.com/calculator/li9pg9x5rj\n\n// Drawing utilities\n#define drawSDF(dist, transp, col) color = mix(color, col, smoothstep(unit, 0.0, dist) * transp)\n\n// SDFs\nfloat sdDisc(in vec2 p, in vec2 o, in float r) {\n    return length(p - o) - r;\n}\n\nfloat sdPlane2D(in vec2 p, in vec2 pos, in vec2 nor) {\n    return abs(dot(p - pos, nor));\n}\n\nfloat sdLine(in vec2 p, in vec2 a, in vec2 b) {\n    vec2 pa = p - a, ba = b - a;\n    return length(pa - ba * clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0));\n}\n\nfloat sdVerticalLine(in vec2 p, in float h) {\n    return length(vec2(p.x, p.y - h * clamp(p.y / h, 0.0, 1.0)));\n}\n\nfloat sdIsosceles(in vec2 p, in float b, in float h) {\n    p.x = abs(p.x);\n    float q = clamp((b - p.x + p.y) / (b + h), 0.0, 1.0);\n    vec2 re = vec2(p.x - b + b * q, p.y - h * q);\n    vec2 be = vec2(p.x - b * min(p.x / b, 1.0), p.y);\n    return sqrt(min(dot(re, re), dot(be, be))) * sign(p.x + (p.y - h) * b / h * sign(p.y));\n}\n\nfloat sdVectorArrow(in vec2 p, in vec2 v) {\n    float m = length(v); vec2 n = v / m;\n    p = vec2(dot(p, n.yx * vec2(1.0, -1.0)), dot(p, n));\n    return min(sdVerticalLine(p, m) - 0.025, sdIsosceles(p - vec2(0.0, m), 0.1, 0.15));\n}\n\n// Computes the incident point between a point and light\n// The line from the light to the reflection of the point over\n// the plane intersects the plane at the point of incidence\n// l: light position, p: point position\n// o: reflector position, n: reflector direction\nvec2 getIncidence(in vec2 l, in vec2 p, in vec2 o, in vec2 n) {\n    l -= o; p -= o;\n    vec2 d = p - 2.0 * n * dot(p, n) - l;\n    return l - dot(l, n) / dot(d, n) * d + o;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 center = 0.5 * iResolution.xy;\n\n    vec4 mouse = (vec4(iMouse.xy, abs(iMouse.zw)) - center.xyxy) / iResolution.y * 4.0;\n    vec2 uv = (fragCoord - center) / iResolution.y * 4.0;\n    vec3 color = vec3(0.0, 0.0, 0.0);\n    float unit = 8.0 / iResolution.y;\n\n    // Default if mouse is not set\n    if (ivec2(iMouse.xy) == ivec2(0)) {\n        mouse = vec4(-1.0, 1.0, 1.0, 1.0);\n    }\n\n    vec2 light = mouse.zw;\n    vec2 point = mouse.xy;\n\n    vec2 reflectorPos = vec2(0.0, -1.0);\n    vec2 reflectorDir = vec2(0.0, 1.0);\n\n    float tilt = sin(iTime) * 0.5;\n    float c = cos(tilt), s = sin(tilt);\n    reflectorDir *= mat2(c, s, -s, c);\n\n    // Draw the reflector\n    drawSDF(sdPlane2D(uv, reflectorPos, reflectorDir) - 0.01, 1.0, vec3(0.0, 0.0, 1.0));\n    drawSDF(sdVectorArrow(uv - reflectorPos, reflectorDir * 0.5), 1.0, vec3(1.0));\n\n    // Draw light path\n    vec2 i = getIncidence(light, point, reflectorPos, reflectorDir);\n    vec2 fromLight = i - light;\n    vec2 toPoint = point - i;\n    drawSDF(sdVectorArrow(uv - light, fromLight - normalize(fromLight) * 0.2) + 0.01, 1.0, vec3(1.0));\n    drawSDF(sdVectorArrow(uv - i, toPoint - normalize(toPoint) * 0.2) + 0.01, 1.0, vec3(1.0));\n\n    // Draw light, point, and incident point\n    drawSDF(sdDisc(uv, light, 0.05), 1.0, vec3(0.0, 1.0, 0.0));\n    drawSDF(sdDisc(uv, point, 0.05), 1.0, vec3(1.0, 0.0, 0.0));\n    drawSDF(sdDisc(uv, i, 0.05), 1.0, vec3(1.0, 0.8, 0.0));\n\n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/sdj3zt.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "sdjGWc", "name": "perlin_noise_4x", "author": "penghuailiang", "description": "perlin noise genrator", "tags": ["noisetexture"], "likes": 0, "viewed": 333, "date": "1618067938", "time_retrieved": "2024-06-20T20:38:37.068574", "image_code": "#define SCALE 4.\n\nvec3 random_perlin( vec3 p ) {\n    p = vec3(\n            dot(p,vec3(127.1,311.7,69.5)),\n            dot(p,vec3(269.5,183.3,132.7)), \n            dot(p,vec3(247.3,108.5,96.5)) \n            );\n    return -1.0 + 2.0*fract(sin(p)*43758.5453123);\n}\n\nfloat noise_perlin (vec3 p) {\n    vec3 i = floor(p);\n    vec3 s = fract(p);\n\n    // 3D网格有8个顶点\n    float a = dot(random_perlin(i),s);\n    float b = dot(random_perlin(i + vec3(1, 0, 0)),s - vec3(1, 0, 0));\n    float c = dot(random_perlin(i + vec3(0, 1, 0)),s - vec3(0, 1, 0));\n    float d = dot(random_perlin(i + vec3(0, 0, 1)),s - vec3(0, 0, 1));\n    float e = dot(random_perlin(i + vec3(1, 1, 0)),s - vec3(1, 1, 0));\n    float f = dot(random_perlin(i + vec3(1, 0, 1)),s - vec3(1, 0, 1));\n    float g = dot(random_perlin(i + vec3(0, 1, 1)),s - vec3(0, 1, 1));\n    float h = dot(random_perlin(i + vec3(1, 1, 1)),s - vec3(1, 1, 1));\n\n    // Smooth Interpolation\n    vec3 u = smoothstep(0.,1.,s);\n\n    // 根据八个顶点进行插值\n    return mix(mix(mix( a, b, u.x),\n                mix( c, e, u.x), u.y),\n            mix(mix( d, f, u.x),\n                mix( g, h, u.x), u.y), u.z);\n}\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = fragCoord.xy/iResolution.xy;\n    float c = noise_perlin(vec3(SCALE*uv, iTime));\n    vec3 color= vec3(c,c,c);\n    fragColor = vec4( color, 1.0 );\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/sdjGWc.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "sdjGWG", "name": "SoundStar", "author": "atutahi", "description": "Audioreactive experiment", "tags": ["audioreactive"], "likes": 0, "viewed": 43, "date": "1618085785", "time_retrieved": "2024-06-20T20:38:37.068574", "image_code": "#define PI 3.14159\n\nfloat expStep( float x, float k, float n )\n{\n    return exp( -k*pow(x,n) );\n}\n\nfloat cubicPulse( float c, float w, float x )\n{\n    x = abs(x - c);\n    if( x>w ) return 0.0;\n    x /= w;\n    return 1.0 - x*x*(3.0-2.0*x);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // create pixel coordinates\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    \n    // diag symmetry\n    // uv = length(uv.x + uv.y) < 1. ? uv : vec2(1.0 - uv.x, 1.0 - uv.y);\n    \n    // abs uv symmetry\n    // uv = abs(uv * 2. - 1.);\n    \n    vec2 coords = uv;\n    \n    uv = uv * 2. - 1.;\n    uv *= 2.;\n    uv.x += 0.6;\n    \n    float ro = length(uv) - 0.05 * sin(iTime * 3.);    \n    float angle = atan(uv.y, uv.x);  // atan2\n    vec2 range = vec2(-1. * PI, 1. * PI);  // The range of atan2 is [-pi / 1; pi / 1]\n    float theta = smoothstep(range[0], range[1], angle);  // Normalize the range of atan to [0;1]\n    theta = abs(2. * theta - 1.);   \n    theta += sin(iTime * 0.1) * 0.3;\n    \n    uv = vec2(theta, ro);\n    \n\t// first texture row is frequency data\n    \n    float fftFrequency = .1;\n    float fftCoord = sin(uv.x * fftFrequency) * uv.x;\n\tfloat fft  = texture( iChannel0, vec2(fftCoord,0.25) ).x * 1.1; \n    \n    // second texture row is the sound wave\n\tfloat wave = texture( iChannel0, vec2(uv.x,0.75) ).x * 0.1;\n\t\n    float spectrumScale = 1.;\n    float spectrum = 1.0 - smoothstep(fft - 0.2, fft, uv.y * spectrumScale);\n    \n    vec3 col = vec3(0.0);\n    \n    // add wave form    \n    float corol = (1.0 -  smoothstep( 0.0, coords.x, abs(wave - uv.y + coords.x * 0.2 + fft) ));\n    \n    // add fft    \n\tcol += vec3(1.0,fft,fft-.4) * (spectrum + corol) * (.5 + ro);\n    \n\t// output final color\n\tfragColor = vec4(col, 1.0);\n}", "image_inputs": [{"id": "4tlXD7", "previewfilepath": "https://soundcloud.com/xavierdang/chasing-reflections", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0, "src": "https://soundcloud.com/xavierdang/chasing-reflections", "ctype": "musicstream"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/sdjGWG.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "sdjGWm", "name": "Revision 2021 Shader Showdown QF", "author": "anticore", "description": "coded live in 25 minutes during the revision 2021 shader showdown quarter finals", "tags": ["raymarching", "reflection", "volumetric", "shader", "glow", "revision", "finals", "showdown", "quarter", "anticore"], "likes": 11, "viewed": 479, "date": "1617530578", "time_retrieved": "2024-06-20T20:38:37.068574", "image_code": "vec3 cam(vec3 ro, vec3 rd, vec2 uv) {\n    vec3 f = normalize(rd - ro);\n    vec3 l = normalize(cross(vec3(0.,1.,0.), f));\n    vec3 u = normalize(cross(f,l));\n    return normalize(f + l * uv.x + u * uv.y);\n}\n\nfloat sdSphere(vec3 p, float r) {\n    return length(p) - r;\n}\n\n\nvec4 bg(vec3 rd) {\n  return rd.y * texture(iChannel0, rd.xz * 0.1 + iTime * 0.1).rrra * vec4(.2, .4, .8, 1.) * 0.5;\n}\n\nfloat sdBox(vec3 p, vec3 c) {\n    vec3 q = abs(p) - c;\n    return length(max(q, 0.));\n}\nfloat ni(float a) { \n//return texture(texFFTIntegrated, a).x; \n    return 0.;\n}\nmat2 rot(float a) { return mat2(cos(a), sin(a), -sin(a), cos(a)); }\n\nvoid mo(inout vec2 p, vec2 d){ p = abs(p) - d; if (p.y > p.x) p = p.yx; }\n\nfloat sdThing(vec3 p) {\n    mo(p.yz, vec2(.4));\n    mo(p.xy, vec2(.4));\n    p.xz *= rot(iTime + ni(0.2) * 2.);\n    p.zy *= rot(iTime  + ni(0.) * 2.);\n    mo(p.zx, vec2(.4));\n    mo(p.yx, vec2(.4));\n    return sdBox(p, vec3(.2, 1., .2));\n}\n\nvec3 rep(vec3 p, vec3 c) {\n    return mod(p + .5 * c, c) - .5 * c;\n}\n\nvec2 map(vec3 p) {\n    vec3 pp = p;\n    p += vec3(0., 3. - sin(p.x * .2 + p.z * .3 + iTime + ni(0.) * 10.) * .2 - cos(-p.x * 2. + p.z * .3 + iTime) * .3 - length(p) * .1, 0.);\n    p = rep(p, vec3(.4, 0., .4));\n    float s = sdSphere(p, .1);\n    float b = sdThing(pp + vec3(sin(ni(0.) * 3.), 0., cos(ni(.15) * 3.)));\n  \n    return vec2(min(s,b),s < b ? 1. : 2.);\n}\n\nvec3 norm(vec3 p) {\n    float E = 0.001; vec2 k = vec2(1, -1);\n    return normalize(\n      k.xyy * map(p + k.xyy * E).x + \n  \n      k.yyx * map(p + k.yyx * E).x + \n  \n      k.yxy * map(p + k.yxy * E).x + \n  \n      k.xxx * map(p + k.xxx * E).x\n    );\n}\n\nvec3 pal(float t, vec3 a, vec3 b, vec3 c, vec3 d) {\n    return a + b * cos(6.283 * (c * t + d));\n}\n\nvec4 tr(vec3 ro, vec3 rd, vec2 uv) {\n    float td = 1.;\n    vec2 h;\n  \n    vec4 c = vec4(0.);\n  \n    for (int i = 0; i < 400; i++) {\n        vec3 ip = ro + rd * td;\n        h = map(ip);\n        td += h.x < 0.1 ? 0.01 : h.x;\n        int bnc = 0;\n        \n        if (h.y == 2.) {\n            c += vec4(pal(iTime , vec3(.5),vec3(.5),vec3(1., 1., .2),vec3(.8, .6, .3) ), 1.) * exp(-h.x * 5.) * 0.01;\n         }\n      \n        if (h.x < 0.01) {\n            vec3 inorm = norm(ip);\n          \n            if (h.y == 1.) {\n              c += vec4(pal(ip.x * .1 + ip.z * .2 + iTime - ip.x * .2 + ip.z * .1 + iTime, vec3(.5),vec3(.5),vec3(1., 1., .2),vec3(.8, .6, .3) ), 1.) * exp(-h.x * 20.) * (exp(-td * .1) * .1);\n            }\n            if (h.y == 2.) {\n                ro = ip;\n                rd = reflect(rd, inorm);\n                td = 0.2;\n                bnc += 1;\n            }\n        }\n    }\n    \n    return bg(rd)  + c;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord/iResolution.xy;\n\tuv -= 0.5;\n\tuv /= vec2(iResolution.y / iResolution.x, 1);\n\n    vec3 ro = vec3(-10. * sin(iTime), 1. + sin(iTime + ni(0.) * .2), -5. * cos(iTime));\n    vec3 rd = cam(ro, vec3(0.,0.,0.), uv);\n\n    // Output to screen\n    fragColor = pow(tr(ro, rd, uv), vec4(1./1.5));\n}", "image_inputs": [{"id": "4sf3Rn", "previewfilepath": "/media/ap/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/sdjGWm.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "sdjSRD", "name": "Closest Points - Bezier & Line", "author": "oneshade", "description": "A bit more challenging but this was one of my few successful attempts at analytic multivariable minimization with anything other than a paraboloid. Should work in 3D if you replace vec2s with vec3s. Now much more compact and efficient.", "tags": ["bezier", "line", "cubic", "quadratic", "points", "closest"], "likes": 14, "viewed": 131, "date": "1619814429", "time_retrieved": "2024-06-20T20:38:37.856466", "image_code": "void update(in vec2 a, in vec2 b, inout vec4 pair, inout float comp, inout bool init) {\n    vec2 ba = b - a; float comp2 = dot(ba, ba);\n    if (init ? (comp2 < comp) : true) { pair = vec4(a, b); comp = comp2; init = true; }\n}\n\n// Evaluates the parametric equation for a bezier curve\n// a(1 - t)^2 + 2b(1 - t)t + ct^2\nvec2 posBezier(in vec2 a, in vec2 b, in vec2 c, in float t) {\n    float tInv = 1.0 - t;\n    return a * tInv * tInv + b * 2.0 * t * tInv + c * t * t;\n}\n\n// Solves for the closest point on a bezier curve\nvec2 closestOnBezier(in vec2 p, in vec2 v1, in vec2 v2, in vec2 v3) {\n    vec2 c1 = p - v1;\n    vec2 c2 = 2.0 * v2 - v3 - v1;\n    vec2 c3 = v1 - v2;\n\n    float t3 = dot(c2, c2);\n    float t2 = dot(c3, c2) * 3.0 / t3;\n    float t1 = (dot(c1, c2) + 2.0 * dot(c3, c3)) / t3;\n    float t0 = dot(c1, c3) / t3;\n\n    float t22 = t2 * t2;\n    vec2 pq = vec2(t1 - t22 / 3.0, t22 * t2 / 13.5 - t2 * t1 / 3.0 + t0);\n    float ppp = pq.x * pq.x * pq.x, qq = pq.y * pq.y;\n\n    float p2 = abs(pq.x);\n    float r1 = 1.5 / pq.x * pq.y;\n\n    if (qq * 0.25 + ppp / 27.0 > 0.0) {\n        float r2 = r1 * sqrt(3.0 / p2), root;\n        if (pq.x < 0.0) root = sign(pq.y) * cosh(acosh(r2 * -sign(pq.y)) / 3.0);\n        else root = sinh(asinh(r2) / 3.0);\n        root = clamp(-2.0 * sqrt(p2 / 3.0) * root - t2 / 3.0, 0.0, 1.0);\n        return posBezier(v1, v2, v3, root);\n    }\n\n    else {\n        float ac = acos(r1 * sqrt(-3.0 / pq.x)) / 3.0;\n        vec2 roots = clamp(2.0 * sqrt(-pq.x / 3.0) * cos(vec2(ac, ac - 4.18879020479)) - t2 / 3.0, 0.0, 1.0);\n        vec2 p1 = posBezier(v1, v2, v3, roots.x), c1 = p - p1;\n        vec2 p2 = posBezier(v1, v2, v3, roots.y), c2 = p - p2;\n        float d1 = dot(c1, c1), d2 = dot(c2, c2);\n        return d1 < d2 ? p1 : p2;\n    }\n}\n\nvec4 closestPointsBezierLine(in vec2 ba, in vec2 bb, in vec2 bc, in vec2 la, in vec2 lb) {\n    vec2 p = ba - 2.0 * bb + bc, q = 2.0 * (bb - ba), r = la - lb, s = ba - la;\n    float c1 = dot(p, p), c2 = 2.0 * dot(p, q), c3 = 2.0 * dot(p, s) + dot(q, q), c4 = dot(r, r),\n          c5 = 2.0 * dot(p, r), c6 = 2.0 * dot(r, q), c7 = 2.0 * dot(q, s), c8 = 2.0 * dot(r, s);\n\n    // Cubic coefficients\n    float a = 4.0 * c1 - c5 * c5 / c4;\n    float b = (3.0 * c2 - 1.5 * c5 * c6 / c4) / a;\n    float c = (2.0 * c3 - (c5 * c8 + 0.5 * c6 * c6) / c4) / a;\n    float d = (c7 - 0.5 * c6 * c8 / c4) / a;\n\n    // Solve for the x coordinate of the minima (cubic solving based on https://en.wikipedia.org/wiki/Cubic_equation)\n    float inflect = b / 3.0, denom = 2.0 * c4, bSq = b * b;\n    vec2 pq = vec2(c - bSq / 3.0, bSq * b / 13.5 - b * c / 3.0 + d);\n    float ppp = pq.x * pq.x * pq.x, qq = pq.y * pq.y;\n\n    float p2 = abs(pq.x);\n    float v1 = 1.5 / pq.x * pq.y;\n\n    vec4 pair; float comp; bool init;\n    if (qq * 0.25 + ppp / 27.0 > 0.0) {\n        float v2 = v1 * sqrt(3.0 / p2), x, y;\n        if (pq.x < 0.0) x = sign(pq.y) * cosh(acosh(v2 * -sign(pq.y)) / 3.0);\n        else x = sinh(asinh(v2) / 3.0);\n        x = -2.0 * sqrt(p2 / 3.0) * x - inflect, y = -((c5 * x + c6) * x + c8) / denom;\n        if (x >= 0.0 && x <= 1.0 && y >= 0.0 && y <= 1.0) update(posBezier(ba, bb, bc, x), la - r * y, pair, comp, init);\n    }\n\n    else {\n        float ac = acos(v1 * sqrt(-3.0 / pq.x)) / 3.0, m = 2.0 * sqrt(-pq.x / 3.0);\n        float x1 = m * cos(ac                ) - inflect, y1 = -((c5 * x1 + c6) * x1 + c8) / denom;\n        if (x1 >= 0.0 && x1 <= 1.0 && y1 >= 0.0 && y1 <= 1.0) update(posBezier(ba, bb, bc, x1), la - r * y1, pair, comp, init);\n        float x2 = m * cos(ac - 2.09439510239) - inflect, y2 = -((c5 * x2 + c6) * x2 + c8) / denom;\n        if (x2 >= 0.0 && x2 <= 1.0 && y2 >= 0.0 && y2 <= 1.0) update(posBezier(ba, bb, bc, x2), la - r * y2, pair, comp, init);\n        float x3 = m * cos(ac - 4.18879020479) - inflect, y3 = -((c5 * x3 + c6) * x3 + c8) / denom;\n        if (x3 >= 0.0 && x3 <= 1.0 && y3 >= 0.0 && y3 <= 1.0) update(posBezier(ba, bb, bc, x3), la - r * y3, pair, comp, init);\n    }\n\n    // Minimize along the boundary (0, 0) --> (1, 0) --> (1, 1) --> (0, 1)\n    update(ba, la - r * clamp(dot(la - ba, r) / c4, 0.0, 1.0), pair, comp, init);\n    update(bc, la - r * clamp(dot(la - bc, r) / c4, 0.0, 1.0), pair, comp, init);\n    update(la, closestOnBezier(la, ba, bb, bc), pair, comp, init);\n    update(lb, closestOnBezier(lb, ba, bb, bc), pair, comp, init);\n\n    return pair;\n}\n\nfloat sdLine(in vec2 p, in vec2 a, in vec2 b) {\n    vec2 pa = p - a, ba = b - a;\n    return length(pa - ba * clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 center = 0.5 * iResolution.xy;\n    vec2 uv = (fragCoord - center) / iResolution.y;\n    vec2 mouse = (iMouse.xy - center) / iResolution.y;\n    float unit = 2.0 / iResolution.y;\n\n    float t1 = iTime * 0.5, t2 = iTime, t3 = iTime * 1.25;\n\n    float c1 = cos(t1), s1 = sin(t1);\n    float c2 = cos(t2), s2 = sin(t2);\n    float c3 = cos(t3), s3 = sin(t3);\n\n    // Bezier control points\n    vec2 ba = vec2(c2, s3) * 0.5;\n    vec2 bb = vec2(s1, s2) * 0.5;\n    vec2 bc = vec2(c3, c1) * 0.5;\n\n    // Line control points\n    vec2 la = vec2(s2, c3) * 0.5;\n    vec2 lb = vec2(s3, c1) * 0.5;\n\n    float d = min(length(uv - closestOnBezier(uv, ba, bb, bc)), sdLine(uv, la, lb));\n\n    // Nice colors from iq\n    vec3 color = 1.0 - sign(d) * vec3(0.1, 0.4, 0.7);\n\tcolor *= 1.0 - exp(-4.0 * abs(d));\n\tcolor *= 0.8 + 0.2 * cos(280.0 * d);\n\n    // Lines between control points\n    color = mix(color, vec3(0.0, 0.0, 1.0), smoothstep(unit, 0.0, sdLine(uv, ba, bb) - 0.002));\n    color = mix(color, vec3(0.0, 0.0, 1.0), smoothstep(unit, 0.0, sdLine(uv, bb, bc) - 0.002));\n\n    // Bezier curve\n\tcolor = mix(color, vec3(1.0), smoothstep(unit, 0.0, abs(d) - 0.002));\n\n    // Bezier control points\n    color = mix(color, vec3(1.0, 1.0, 0.0), smoothstep(unit, 0.0, length(uv - ba) - 0.015));\n    color = mix(color, vec3(1.0, 1.0, 0.0), smoothstep(unit, 0.0, length(uv - bb) - 0.015));\n    color = mix(color, vec3(1.0, 1.0, 0.0), smoothstep(unit, 0.0, length(uv - bc) - 0.015));\n\n    // Line control points\n    color = mix(color, vec3(1.0, 1.0, 0.0), smoothstep(unit, 0.0, length(uv - la) - 0.015));\n    color = mix(color, vec3(1.0, 1.0, 0.0), smoothstep(unit, 0.0, length(uv - lb) - 0.015));\n\n    // Closest points\n    vec4 closest = closestPointsBezierLine(ba, bb, bc, la, lb);\n    color = mix(color, vec3(1.0, 0.0, 0.0), smoothstep(unit, 0.0, length(uv - closest.xy) - 0.015));\n    color = mix(color, vec3(1.0, 0.0, 0.0), smoothstep(unit, 0.0, length(uv - closest.zw) - 0.015));\n\n    // Shortest segment between\n    color = mix(color, vec3(1.0, 0.0, 0.0), smoothstep(unit, 0.0, sdLine(uv, closest.xy, closest.zw) - 0.002));\n\n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/sdjSRD.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "sdjXzR", "name": "Light in the Dark", "author": "eyadnabeel", "description": "Infinite bridge, using smooth blended CSG operations and sinusoid-displaced blobs. Water effects using sinusoid functions and Perlin noise", "tags": ["raymarching", "sdf", "water", "bridge"], "likes": 3, "viewed": 116, "date": "1619581840", "time_retrieved": "2024-06-20T20:38:40.317201", "image_code": "// Raymarcher adapted from implementation by Inigo Quilez\n\n#define GAMMA_CORRECTION\n#define MOTION\n#define DISTANCE_FOG\n\n// Material aliases\n#define WATER 0\n#define LAMBERT_RED 1\n#define BLOB 2\n\n// Camera Views\n#define VIEW_0\n//#define VIEW_1\n//#define MOUSE_CONTROL\n\n// Water Noise (NO NOISE -> 0, PERLIN -> 1, WORLEY -> 2)\n#define NOISE 1\n#define SINEWAVES\n\nconst float INFINITY = 99999999999999999.99f;\nconst float PI = 3.14159;\nconst float EPSILON = 0.0001f;\nconst float FAR_CLIP = 500.f;\nconst int RAY_STEPS = 256;\n\nvec2 random2(vec2 p, float seed) {\n    return fract(sin(vec2(dot(p, vec2(127.1, 311.7)),\n                 dot(p, vec2(269.5,183.3))))\n                 * seed);\n}\n\nfloat noise2D(vec2 p, float seed){\n    p /= 20.f;\n    return fract(5.f * sin(dot(p, p) * seed) - p.y * cos(435.324 * seed * p.x));;\n}\n\nfloat worley(vec2 uv, float seed) {\n    uv *= 10.0; // Now the space is 10x10 instead of 1x1. Change this to any number you want.\n    vec2 uvInt = floor(uv);\n    vec2 uvFract = fract(uv);\n    float minDist = 1.0; // Minimum distance initialized to max.\n    for(int y = -1; y <= 1; ++y) {\n        for(int x = -1; x <= 1; ++x) {\n            vec2 neighbor = vec2(float(x), float(y)); // Direction in which neighbor cell lies\n            vec2 point = random2(uvInt + neighbor, seed); // Get the Voronoi centerpoint for the neighboring cell\n            vec2 diff = neighbor + point - uvFract; // Distance between fragment coord and neighbor’s Voronoi point\n            float dist = length(diff);\n            minDist = min(minDist, dist);\n        }\n    }\n    return minDist;\n}\n\nvec3 random3( vec3 p ) {\n    return fract(sin(vec3(dot(p,vec3(127.1, 311.7, 191.999)),\n                          dot(p,vec3(269.5, 183.3, 765.54)),\n                          dot(p, vec3(420.69, 631.2,109.21))))\n                 *43758.5453);\n}\n\nfloat noise3( vec3 p ) {\n    vec3 noise = fract(sin(vec3(dot(p,vec3(127.1, 311.7, 191.999)),\n                          dot(p,vec3(269.5, 183.3, 765.54)),\n                          dot(p, vec3(420.69, 631.2,109.21))))\n                 *43758.5453);\n    return max(noise.x, max(noise.y, noise.z));\n}\n\n\nfloat surflet(vec3 p, vec3 gridPoint) {\n    // Compute the distance between p and the grid point along each axis, and warp it with a\n    // quintic function so we can smooth our cells\n    vec3 t2 = abs(p - gridPoint);\n    vec3 t = vec3(1.f) - 6.f * pow(t2, vec3(5.f)) + 15.f * pow(t2, vec3(4.f)) - 10.f * pow(t2, vec3(3.f));\n    // Get the random vector for the grid point (assume we wrote a function random2\n    // that returns a vec2 in the range [0, 1])\n    vec3 gradient = random3(gridPoint).xyz * 2.f - vec3(1., 1., 1.);\n    // Get the vector from the grid point to P\n    vec3 diff = p - gridPoint;\n    // Get the value of our height field by dotting grid->P with our gradient\n    float height = dot(diff, gradient);\n    // Scale our height field (i.e. reduce it) by our polynomial falloff function\n    return height * t.x * t.y * t.z;\n}\n\nfloat perlinNoise3D(vec3 p) {\n    float surfletSum = 0.f;\n    // Iterate over the four integer corners surrounding uv\n    for(int dx = 0; dx <= 1; ++dx) {\n        for(int dy = 0; dy <= 1; ++dy) {\n            for(int dz = 0; dz <= 1; ++dz) {\n                surfletSum += surflet(p, floor(p) + vec3(dx, dy, dz));\n            }\n        }\n    }\n    return surfletSum;\n}\n\nfloat fbm( in vec3 x, in float H )\n{    \n    float G = exp2(-H);\n    float f = 1.0;\n    float a = 1.0;\n    float t = 0.0;\n    int numOctaves = 2;\n    for( int i=0; i<numOctaves; i++ )\n    {\n        t += a*perlinNoise3D(f*x);\n        f *= 2.0;\n        a *= G;\n    }\n    return t;\n}\nbool equals(float a, float b){\n    return abs(a - b) < EPSILON;\n}\n\nbool equalsmargin(float a, float b, float m){\n    return abs(a - b) < m;\n}\n\nfloat smin(float a, float b, float k){\n    float h = clamp( 0.5 + 0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\nfloat sub(float d1, float d2, float k) {\n    float h = clamp( 0.5 - 0.5*(d2+d1)/k, 0.0, 1.0 );\n    return mix( d2, -d1, h ) + k*h*(1.0-h); \n}\n\nfloat isect( float d1, float d2, float k ) {\n    float h = clamp( 0.5 - 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) + k*h*(1.0-h); \n}\n\nvec3 repeat(vec3 pos, float cx, float cy, float cz){\n    return vec3(mod(pos.x + 0.5f * cx, cx) - 0.5f * cx,\n                mod(pos.y + 0.5f * cy, cy) - 0.5f * cy,\n                mod(pos.z + 0.5f * cz, cz) - 0.5f * cz);\n}\n\nvec3 rotateY(vec3 p, float a) {\n    return vec3(cos(a) * p.x + sin(a) * p.z, p.y, -sin(a) * p.x + cos(a) * p.z);\n}\n\nvoid computeray (vec3 eye, vec3 ref, vec2 ndc, float fov, out vec3 ro, out vec3 rd)\n{\n    vec3 look = ref - eye;\n    \n    float len = tan(fov * PI/180.f) * distance(eye, ref);\n    \n    vec3 v, h;\n    h = normalize(cross(vec3(0.0, 1.0, 0.0), ref - eye));\n    v = normalize(cross(h, look));;\n\n    h *= len * iResolution.x/iResolution.y;\n    v *= len;\n    \n    vec3 p = ref + ndc.x * h + ndc.y * v;\n            \n    p = ref + ndc.x * h + ndc.y * v;\n        \n    ro = eye;\n    rd = normalize(p - eye);\n}\n\nfloat infinite_plane_sdf(vec3 pos, float y){\n    return pos.y - y;\n}\n\nfloat sphere_sdf (vec3 ro, vec3 p, float r){\n    return length(ro - p) - r;\n}\n\nfloat box_sdf(vec3 ro, vec3 p, vec3 b, float r)\n{\n    vec3 q = abs(ro - p) - b;\n    return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0) - r;\n}\n\nfloat cylinder_sdf(vec3 ro, vec3 p, float ra, float rb, float h )\n{\n  vec2 d = vec2( length(ro.xz - p.xz)-2.0*ra+rb, abs(ro.y - p.y) - h );\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0)) - rb;\n}\n\nfloat vert_cylinder_sdf(vec3 ro, vec3 p, float r, float h){\n    float s0 = box_sdf(ro, vec3(0.f, 1.f, 0.f) + p, vec3(r, 2.f * r, h), 0.1f);\n    float s1 = sphere_sdf(ro, vec3(0.f, 0.f, 0.f) + p, r);\n    return isect(s0, s1, 0.1f);\n\n}\n\nfloat arch_sdf(vec3 ro, vec3 p, float r1, float r2, float t){\n    float s0 = vert_cylinder_sdf(ro, p, r1, t);\n    float s1 = vert_cylinder_sdf(ro, p, r2, 2.f * t);\n    float d1 = sub(s1, s0, 0.1f);\n    return d1;\n}\n\nfloat steps_sdf(vec3 ro, vec3 p, vec3 dim, int steps, int axis, int dir){\n    float d = INFINITY;\n    for (int i = 0; i < steps; i++){\n        float cur_step;\n        if (axis == 0){\n            cur_step = box_sdf(ro, vec3(dim.z * float(i) * float(dir) * 0.8f, 2.f * dim.y * float(i), 0.f) + p, dim, 0.1f);\n        } else if (axis == 1){\n            cur_step = box_sdf(ro, vec3(0.f, 2.f * dim.y * float(i), dim.x * float(i) * float(dir) * 0.8f) + p, dim.zyx, 0.1f);\n        }\n        d = min(cur_step, d);\n    }\n    return d;\n}\n\nfloat full_steps_sdf(vec3 ro, vec3 p, vec3 dim, int steps, int axis, int dir){\n    float d = INFINITY;\n    for (int i = 1; i < steps; i++){\n        float cur_step;\n        if (axis == 0){\n            cur_step = box_sdf(ro, vec3(dim.z * float(i) * float(dir), dim.y * float(i), 0.f) + p, vec3(dim.x, 2.f * float(i) * dim.y, dim.z), 0.1f);\n        } else if (axis == 1){\n            cur_step = box_sdf(ro, vec3(0.f, 2.f * dim.y * float(i), dim.x * float(i) * float(dir)) + p, vec3(dim.z, dim.y, dim.x), 0.1f);\n        }\n        d = min(cur_step, d);\n    }\n    return d;\n}\n\n\nvec2 map(vec3 p){\n    float d, mat, aTime = iTime/2.f;\n    \n    //BRIDGE\n    vec3 q = repeat(p, 12.f , 0.f, 0.f);\n    float a0 = arch_sdf(q, vec3(0.f), 7.f, 5.f, 2.f);\n    float a1 = arch_sdf(q, vec3(0.f), 8.f, 6.f, 1.5f);\n    float d0 = sub(a1, a0, 0.2f);\n    mat = float(LAMBERT_RED);\n    d = d0;\n    \n    \n    // FLOATING BLOBS\n    vec3 qs1 = repeat(p, 40.f, 0.f, 40.f);\n    vec3 qs2 = repeat(p, 10.f, 0.f, 10.f);\n    float f = 5.f;\n    float hf = 15.5f * cos(p.z/40.f);\n    vec3 h0 = vec3(f * cos(iTime/4.f), 15.f + (sin(p.x) + cos(p.z)) * sin(iTime) - hf * (sin(p.x/20.f) + cos(p.z/20.f)) * cos(iTime), f * sin(iTime/2.f));\n    vec3 h1 = vec3(5.f + -f * cos(iTime/4.f), 20.f + (sin(p.x) + cos(p.z)) * sin(iTime) + hf * (cos(p.x/20.f) + sin(p.z/20.f)) * sin(iTime), 5.f + -f * sin(iTime/2.f));\n    float s0 = sphere_sdf(qs1, h0, 3.5f);\n    float s1 = sphere_sdf(qs1, h1, 3.5f);\n    float d1 = smin(s0 * 0.5f, s1 * 0.5f, 2.f);\n    d = smin(d, d1, 3.f);\n    \n    \n    \n    \n    // WATER\n    #if NOISE == 0\n    float plane_noise = 0.f;\n    #elif NOISE == 1\n    float plane_noise = ((perlinNoise3D(p)) * (sin(iTime/5.f) + 1.1f) * 0.5f);\n    #elif NOISE == 2\n    float plane_noise = ((worley(p.xz/10.f, abs(sin(iTime) * cos(iTime/2.f)))) * (sin(iTime/5.f) + 1.1f) * 0.3f);\n    #endif\n    \n    #ifdef SINEWAVES\n    plane_noise += 2.f * cos(p.x/10.f - cos(iTime)) + 2.f * sin(p.z/15.f + sin(iTime));\n    plane_noise -= 2.5f;\n    #endif\n    \n    float d2 = infinite_plane_sdf(p, 0.25f + plane_noise);\n    d = smin(d, d2 * 0.6f, 0.f);\n    mat = equals(d, d2) ? float(WATER) : float(mat);\n\n    d = smin(d, d1, 0.f);\n    mat = equals(d, d1) ? float(BLOB) : float(mat);\n\n    \n    return vec2(d, mat);\n}\n\nvec3 calcNormal(in vec3 pos, float eps){\n    vec2 e = vec2(eps, 0.f);\n    return normalize(vec3(map(pos + e.xyy).x - map(pos - e.xyy).x,\n                          map(pos + e.yxy).x - map(pos - e.yxy).x,\n                          map(pos + e.yyx).x - map(pos - e.yyx).x));\n}\n\nfloat shadowcast(in vec3 ro, in vec3 rd){\n    float res = 1.f;\n    float t = 0.001f;\n    for (int i = 0; i < RAY_STEPS; i++){\n        vec3 pos = ro + rd * t;\n        float dist = map(pos).x;\n        if (res < 0.0000001){\n            break;\n        }\n        if (dist > FAR_CLIP){\n            break;\n        }\n        res = min(res, 10.f * dist/t);\n        t += dist;\n    }\n    return res;\n}\n\nfloat shadowcast_pointlight(in vec3 ro, in vec3 rd, in float light_dist){\n    float res = 1.f;\n    float t = 0.001f;\n    for (int i = 0; i < RAY_STEPS; i++){\n        vec3 pos = ro + rd * t;\n        float dist = map(pos).x;\n        if (res < 0.0000001){\n            break;\n        }\n        if (t > light_dist){\n            return res;\n        }\n        if (dist > FAR_CLIP){\n            break;\n        }\n        res = min(res, 10.f * dist/t);\n        t += dist;\n    }\n    return res;\n}\n\nfloat raycast(in vec3 ro, in vec3 rd, out int mat){\n    float t = 0.f;\n    mat = -1;\n    for (int i = 0; i < RAY_STEPS; i++){\n        vec3 pos = ro + rd * t;\n        vec2 sdf = map(pos);\n        float dist = sdf.x;\n        mat = int(sdf.y);\n        if (abs(dist) < 0.0000001 * t){\n            break;\n        }\n        if (dist > FAR_CLIP){\n            break;\n        }\n        t += dist;\n    }\n    if (t > FAR_CLIP){\n        return -1.f;\n    }\n    return t;\n}\n\nvec3 watercast(in vec3 rd, in vec3 nor){\n    vec3 proj_rd_nor = dot(rd, nor)/dot(nor, nor) * nor;\n    vec3 rd_perp = rd - proj_rd_nor;\n    return rd - 2.f * dot(nor, rd) * nor;\n}\n\nvec3 calcmaterial(vec3 ro, vec3 pos, vec3 nor, int mat){\n        vec3 col = vec3(0.f);        \n        \n        // ambient light parameters\n        vec3 sky_light = vec3(0.f, 0.1f, 0.3f) * clamp(0.5f + 0.5f * nor.y, 0.f, 1.f);\n        \n        // light parameters\n        float aTime = iTime/2.f;\n        #ifdef MOTION\n        vec3 light_pos = vec3(7.f * sin(aTime) - iTime , 7.f, 7.f * cos(aTime));\n        #else\n        vec3 light_pos = vec3(7.f * sin(aTime) , 7.f, 7.f * cos(aTime));\n        #endif\n        vec3 light_dir = normalize(light_pos - pos);\n        vec3 lambert_light = vec3(0.8f, 0.6f, 0.2f) * clamp(dot(nor, light_dir), 0.f, 1.f);\n\n        #ifdef MOTION\n        vec3 light2_pos = vec3(-7.f * cos(aTime) - iTime, 7.f, -7.f * sin(aTime));\n        #else\n        vec3 light2_pos = vec3(-7.f * cos(aTime), 7.f, -7.f * sin(aTime));\n        #endif\n        vec3 light2_dir = normalize(light2_pos - pos);\n        vec3 lambert_light2 = vec3(0.8f, 0.2f, 0.01f) * clamp(dot(nor, light2_dir), 0.f, 1.f);\n        \n\n        // bounce light (fake GI)\n        vec3 bounce_light = vec3(0.1f, 0.05f, 0.02f) * clamp(0.5f - 0.5f * nor.y, 0.f, 1.f);\n        \n        float t_shadow1 = shadowcast_pointlight(pos + nor * EPSILON * 0.0001f, light_dir, distance(light_pos, pos));\n        float t_shadow2 = shadowcast_pointlight(pos + nor * EPSILON * 0.0001f, light2_dir, distance(light2_pos, pos));\n         //t_shadow = 1.f;\n                \n        vec3 base_colour;\n        \n        switch(mat){\n            case WATER:\n            base_colour = vec3(0.f, 0.1f, 0.3f) * 0.05f;\n            break;\n            case LAMBERT_RED:\n            if (nor.y > nor.x){\n                base_colour  = texture(iChannel0, pos.xz/4.f).xyz;\n            } else {\n                base_colour  = texture(iChannel0, pos.xy/4.f).xyz;\n            }\n            base_colour *= vec3(0.9f, 0.2f, 0.4f);\n            break;\n            case BLOB:\n            base_colour = vec3(1.f, 0.4f, 0.3f);\n            break;\n        }\n        \n        // final colour evaluation\n        col = base_colour * lambert_light * 2.f * t_shadow1;\n        col += base_colour * lambert_light2 * 2.f * t_shadow2;\n        \n        col += base_colour * sky_light;\n        col += base_colour * bounce_light;\n        \n        \n        //col += sss/300000.f;\n        \n        return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized device coordinates (from -1 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 ndc = vec2((2.f * uv.x) - 1.f, 1.f - (2.f * uv.y)); \n    \n    \n    // camera variance variable\n    #ifdef MOUSE_CONTROL\n    float u = 20.f * iMouse.x/iResolution.x;\n    float v = PI/2.f * iMouse.y/iResolution.y;\n    #endif\n    \n    // Camera parameters\n    #ifdef MOUSE_CONTROL\n    float d = 20.f;\n    float aTime = iTime/2.f;\n    vec3 eye = vec3(d * cos(u), 30.f * abs(sin(v)), d * sin(u));\n    vec3 ref = vec3(0.f, 0.f, 0.f);\n    #endif\n    \n    #ifdef VIEW_0\n    float d = 20.f;\n    float aTime = iTime/2.f;\n    vec3 eye = vec3(d, 7.5f, 0.f);\n    vec3 ref = vec3(0.f, 0.f, 0.f);\n    #endif\n    \n    #ifdef VIEW_1\n    float d = 20.f;\n    float aTime = iTime/2.f;\n    vec3 eye = vec3(0.f, 5.f, d);\n    vec3 ref = vec3(0.f, 0.f, 0.f);\n    #endif\n    \n    #ifdef MOTION\n    #ifndef VIEW_1\n    vec3 motion = vec3(-iTime, abs(sin(iTime)), 0.f);\n    #else\n    vec3 motion = vec3(-iTime, 0.f, 0.f);\n    #endif\n    eye += motion;\n    ref.x += motion.x;\n    #endif\n    float fov = 45.f;\n    \n    vec3 ro , rd;\n    computeray(eye, ref, ndc, fov, ro, rd);\n        \n    #ifdef DISTANCE_FOG\n    vec3 col = mix(vec3(0.f, 0.1f, 0.3f) * 0.3f, vec3(0.f, 0.1f, 0.3f) * 0.f, abs(ndc.y * 1.25f));     \n    #else\n    vec3 col = vec3(0.f);\n    #endif\n    int mat = -1;\n    float t = raycast(ro, rd, mat);\n    \n    vec3 rd_new, ro_new;\n    float t_new;\n    int mat_new = -1;\n    \n    if (mat == WATER){\n        ro_new = ro + t * rd;\n        rd_new = watercast(rd, calcNormal(ro_new, 0.000001f));\n        t_new = raycast(ro_new, rd_new, mat_new);\n        rd = normalize((ro_new + t_new * rd_new) - ro);\n        mat = mat_new;\n        t = distance(ro, ro_new + t_new * rd_new);\n        mat_new = WATER;\n    }\n    \n    if (t > 0.f){\n        vec3 pos = ro + t * rd;\n        vec3 nor = calcNormal(pos, 0.1f);\n        col = calcmaterial(ro, pos, nor, mat);\n        col *= 1.f - pow(t/FAR_CLIP, 2.f) * vec3(0.8f, 0.8f, 0.6f);\n        #ifdef DISTANCE_FOG\n        col += vec3(0.f, 0.1f, 0.3f) * 0.25f * (t/FAR_CLIP) * (t/FAR_CLIP) ;\n        #endif\n        if (mat_new == WATER){\n            col *= 0.35;\n        }\n    }\n    \n    #ifdef GAMMA_CORRECTION\n    // Gamma correction - https://www.youtube.com/watch?v=Cfe5UQ-1L9Q&t=1990s - 38:00\n    col = pow(col, vec3(0.4545f));\n    #endif\n    \n    // Output to screen\n    fragColor = vec4(col,t);\n}", "image_inputs": [{"id": "4dXGRn", "previewfilepath": "/media/ap/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/sdjXzR.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "sdlSD7", "name": "Bathyscaphe", "author": "gorgh", "description": "My first pseudo-intro", "tags": ["3d"], "likes": 5, "viewed": 33, "date": "1618730686", "time_retrieved": "2024-06-20T20:38:40.317201", "image_code": "#define MAX_STEPS 100\n#define MAX_DIST 100.\n#define SURF_DIST .01\n\n\nfloat Hash21(vec2 p) {\n    p = fract(p*vec2(123.34, 456.21));\n    p += dot(p, p+45.32);\n    return fract(p.x*p.y);\n}\n\n\nmat2 Rot(float a) {\n    float s = sin(a);\n    float c = cos(a);\n    return mat2(c, -s, s, c);\n}\n\nfloat getCube(vec3 p){\nfloat hash=Hash21(floor(p.xz));\nfloat shrink=p.y*.01+0.01;\n vec3 cube=vec3(.04-shrink,1.-hash*.4,.04-shrink);\n p.y+=1.;\n p.x+=sin(p.y+iTime+hash*2.)*.16;\n float displacement=hash*.5-.25;\n p.z=fract(p.z)-.5-displacement;\n p.x=fract(p.x)-.5-displacement;\n p.xz*=Rot(p.y);\n p.xy+=sin(iTime+hash)*.01;\n    return length(max(abs(p)-cube,0.0));//+min(max(p.x, max(p.y, p.z)), 0.);\n    \n}\n\nfloat getCylinder(vec3 p,vec3 cyl1,vec3 cyl2){\n\n   \n    float cyl_rad=.2;\n    \n    vec3 ab=cyl2-cyl1;\n    vec3 ap=p-cyl1;\n    \n    float t=dot(ap,ab)/dot(ab,ab);\n    \n    t=clamp(t,0.,1.);\n    \n    vec3 norm=normalize(cyl2-cyl1);\n    norm=norm.zxy;\n    ab=cyl2-cyl1-norm*sin(t*5.+iTime*2.)*.6;\n    ap=p-cyl1;\n    \n    t=dot(ap,ab)/dot(ab,ab);\n    \n    t=clamp(t,0.,1.);    \n    \n    vec3 point_cyl=cyl1+t*ab;\n    \n    return length(p-point_cyl)-cyl_rad;\n}\n\nfloat getPoints(vec3 p){\nvec3 p2=fract(p);\nvec3 p3=vec3(.5+.3*Hash21(floor(p.xy)),.5+.3*Hash21(floor(p.xz)),.5);\n   p3.y+=sin(iTime)*.1;\n return min(length(p2-p3)-.01*Hash21(p2.xz),.18);\n\n}\nfloat getSphereFish(vec3 p,float r){\n\nreturn length(p)-r;\n}\n\nfloat getCubeFish(vec3 p,vec3 cube){\n    \n\n  vec3 q = abs(p) - cube;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat getTail(vec3 p,vec3 cube){\n    cube.z+=p.x;\n  cube.z=clamp(cube.z,.1,1.);\n  vec3 q = abs(p) - cube;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\n\n\nfloat getFish(vec3 p){\np.x-=p.x/3.;\nfloat box=getCubeFish(p,vec3(.2,.003,.2));\nfloat sph=getSphereFish(p,.125);\nfloat factor=.5;\nfloat dist=factor*box+(1.-factor)*sph;\ndist=min(dist,getTail(p+vec3(-.125,0,0),vec3(.1,.01,.1)));\n return dist*.5;\n}\n\n\nfloat GetDist(vec3 p) {\n\n    float d=p.y+Hash21(p.xz)-.5;\n    if(iTime<5.2){\n\n    float cylinder=getCylinder(p,vec3(1,1,3.+iTime*.4),vec3(1,2,4.+iTime*.4));\n    d=min(d,cylinder);\n    }\n    d=min(d,getPoints(p));\n    d=min(d,getCube(p-vec3(0,2,6)));\n    \n    if(iTime>1. && iTime<4.){\n vec3 p2=p-vec3(1,2.,6.);    \n\n p2.yz*=Rot(3.1416*.5);\n p2.y-=cos(iTime*2.-p2.x)*.4; \n p2.x+=iTime;\n d= min(d,getFish(p2)); \n }\n if(iTime>3.5 && iTime<10.){\n vec3 p3=p-vec3(1,1.,9);    \n vec3 p4=p-vec3(3.5,2,9.5);\n p3.yz*=Rot(3.1416*.5);\n p3.y-=cos(iTime*2.-p3.x)*.4; \n p3.x+=iTime-3.5;\n \n p4.yz*=Rot(3.1416*.5);\n p4.y-=cos(iTime*2.-p4.x+1.7)*.4; \n p4.x+=iTime-3.5; \n d= min(d,getFish(p3));  \n d= min(d,getFish(p4)); \n }\n \n if(iTime>6.5 && iTime<13.){\n vec3 p3=p-vec3(1,1.,12);    \n vec3 p4=p-vec3(3.5,2,12.5);\n p3.yz*=Rot(3.1416*.5);\n p3.y-=cos(iTime*2.-p3.x)*.4; \n p3.x+=iTime-6.5;\n \n p4.yz*=Rot(3.1416*.5);\n p4.y-=cos(iTime*2.-p4.x+1.7)*.4; \n p4.x+=iTime-6.5; \n d= min(d,getFish(p3));  \n d= min(d,getFish(p4)); \n } \n \n if(iTime>10. && iTime <17.){\n    float cylinder=getCylinder(p,vec3(-4.+(iTime-10.)*.6,1.5,16.),\n    vec3(-2.+(iTime-10.)*.6,1.5,15.5));\n    d=min(d,cylinder);\n \n \n }\n \n if(iTime>20.){\n   vec3 p5=p-vec3(0,2,26.);\n   p5.xz*=Rot(iTime);\n   p5.xy*=Rot(iTime);   \n   d=min(d,getCubeFish(p5,vec3(.5)));\n }\n \n    return d;\n}\n\nfloat RayMarch(vec3 rayOrig, vec3 rayDir){\nfloat dist=0.;  \n    \n    for(int i=0; i<MAX_STEPS; i++){\n     vec3 currentPoin= rayOrig+dist*rayDir;\n        float currentDis= GetDist(currentPoin);\n        dist+=currentDis;\n        if(currentDis<SURF_DIST || dist> (MAX_DIST+iTime))break;\n    }\n    return dist;\n}\n//get average value of the surface direction \nvec3 GetNormal(vec3 p) {\n\tfloat d = GetDist(p);\n    vec2 e = vec2(.01, 0);\n    \n    vec3 n = d - vec3(\n        GetDist(p-e.xyy),\n        GetDist(p-e.yxy),\n        GetDist(p-e.yyx));\n    \n    return normalize(n);\n}\n\n//get distance to the light source\nfloat GetLight(vec3 p) {\n    vec3 lightPos = vec3(0, 5, 6);\n    lightPos.xz += vec2(sin(iTime), cos(iTime))*2.;\n    vec3 l = normalize(lightPos-p);\n    vec3 n = GetNormal(p);\n    \n    float dif = clamp(dot(n, l), 0., 1.);\n    float d = RayMarch(p+n*SURF_DIST*2., l);\n    if(d<length(lightPos-p)) dif *= .1;\n    dif=clamp(dif,0.,1.);\n    return dif;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv=(fragCoord-0.5*iResolution.xy)/iResolution.y;\n\n\n    vec3 ro=vec3(0,2.2,22.);\n    if(iTime<22.){\n    ro = vec3(0, 2.2, 0.+iTime);\n    }\n    vec3 rd = normalize(vec3(uv.x, uv.y-0.2, 1));\n\n\n    if(iTime>25.)\n    {\n    rd.xy*=Rot(-3.1416*.25);\n    }\n\n\n    float dif=0.;\n    float time=ro.z;\n    vec3 ro2=ro;\n\n    float d = RayMarch(ro2, rd);\n    vec3 p = ro2 + rd * d;\n    \n    if(length(p)<10.+iTime)\n    dif=1.-(length(p)*.19-time*.19);//GetLight(p);\n    vec3 col = vec3(dif);\n    if(iTime>23. && Hash21(vec2(iTime,iTime))<.6)\n    {\n    col=vec3(0);\n    }\n    col-=.4*dot(uv,uv);\n    fragColor=vec4(col,1);\n    \n    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/sdlSD7.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "sdlXR7", "name": "Distance Field Soft Shadows", "author": "moranzcw", "description": "Distance Field Soft Shadows.", "tags": ["shadow", "softshadow", "ssdf"], "likes": 8, "viewed": 203, "date": "1618427986", "time_retrieved": "2024-06-20T20:38:41.541549", "image_code": "// Distance Field Soft Shadows - by moranzcw - 2021\n// Email: moranzcw@gmail.com\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\nconst int MAX_MARCHING_STEPS = 255;\nconst float MIN_DIST = 0.0;\nconst float MAX_DIST = 100.0;\nconst float EPSILON = 0.0001;\nconst float PI = 3.141592653;\n\n\n// oldschool rand() from Visual Studio\nint   seed = 1;\nvoid  srand(int s ) { seed = s; }\nint   rand(void)  { seed=seed*0x343fd+0x269ec3; return (seed>>16)&32767; }\nfloat frand(void) { return float(rand())/32767.0; }\n\n// hash by Hugo Elias\nint hash( int n ) { n=(n<<13)^n; return n*(n*n*15731+789221)+1376312589; }\n\n\n/* -------------------------------------\n\n1. SDF\n\n------------------------------------- */\n\n// SDF boolean\nfloat intersectSDF(float distA, float distB) {\n    return max(distA, distB);\n}\n\nfloat unionSDF(float distA, float distB) {\n    return min(distA, distB);\n}\n\nfloat differenceSDF(float distA, float distB) {\n    return max(distA, -distB);\n}\n\n//SDF functions by iq.\n//see https://iquilezles.org/www/articles/distfunctions/distfunctions.htm\nfloat dot2( in vec2 v ) { return dot(v,v); }\nfloat dot2( in vec3 v ) { return dot(v,v); }\n\nfloat quadSDF( vec3 p, vec3 a, vec3 b, vec3 c, vec3 d )\n{\n  vec3 ba = b - a; vec3 pa = p - a;\n  vec3 cb = c - b; vec3 pb = p - b;\n  vec3 dc = d - c; vec3 pc = p - c;\n  vec3 ad = a - d; vec3 pd = p - d;\n  vec3 nor = cross( ba, ad );\n\n  return sqrt(\n    (sign(dot(cross(ba,nor),pa)) +\n     sign(dot(cross(cb,nor),pb)) +\n     sign(dot(cross(dc,nor),pc)) +\n     sign(dot(cross(ad,nor),pd))<3.0)\n     ?\n     min( min( min(\n     dot2(ba*clamp(dot(ba,pa)/dot2(ba),0.0,1.0)-pa),\n     dot2(cb*clamp(dot(cb,pb)/dot2(cb),0.0,1.0)-pb) ),\n     dot2(dc*clamp(dot(dc,pc)/dot2(dc),0.0,1.0)-pc) ),\n     dot2(ad*clamp(dot(ad,pd)/dot2(ad),0.0,1.0)-pd) )\n     :\n     dot(nor,pa)*dot(nor,pa)/dot2(nor) );\n}\n\nfloat boxSDF( vec3 p, vec3 b )\n{\n    vec3 q = abs(p) - b;\n    return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat sphereSDF(vec3 p, float r) {\n    return length(p) - r;\n}\n\nfloat cylinderSDF( vec3 p, float h, float r )\n{\n    vec2 d = abs(vec2(length(p.xz),p.y)) - vec2(h,r);\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\n// scene\nfloat sceneSDF(vec3 samplePoint) {\n    float sphere = sphereSDF(samplePoint + vec3(0.0, -0.5, 0.0), 0.5);\n    float scene = sphere;\n    \n    float cube = boxSDF(samplePoint+ vec3(1.5, -0.75, -1.5), vec3(0.25, 0.75, 0.25));\n    scene = unionSDF(scene, cube);\n    \n    float cylinder = cylinderSDF(samplePoint+ vec3(-1.5, -0.6, 1.5), 0.4, 0.6);\n    scene = unionSDF(scene, cylinder);\n    \n    float size = 4.0;\n    float ground = quadSDF(samplePoint,vec3(size,0.0,size), vec3(size,0.0,-size),\n                        vec3(-size,0.0,-size), vec3(-size,0.0,size));\n    scene = unionSDF(scene, ground);\n    \n    return scene;\n}\n\n/* -------------------------------------\n\n2. Ray Marching\n\n------------------------------------- */\nfloat rayMarching(vec3 origin, vec3 direction, float start, float end) {\n    float depth = start;\n    for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n        float dist = sceneSDF(origin + depth * direction);\n        if (dist < EPSILON) {\n\t\t\treturn depth;\n        }\n        depth += dist;\n        if (depth >= end) {\n            return end;\n        }\n    }\n    return end;\n}\n\n/* -------------------------------------\n\n3. Visibility for shading point\n\n------------------------------------- */\nfloat visibility(vec3 ro, vec3 rd, float start, float end, float k)\n{\n    float t = start;\n    vec3 p;\n    float dist;\n    float tempVisibility;\n    float visibility = 1.0;\n        \n    for (int i = 0; i < MAX_MARCHING_STEPS; i++) \n    {\n        p = ro + t * rd;\n        dist = sceneSDF(p);\n        \n        tempVisibility = k * dist / t;\n        visibility = min(tempVisibility, visibility);\n        \n        if (dist < EPSILON) \n        {\n\t\t\treturn 0.0;\n        }\n        t += dist * (0.7 + frand() * 0.3); // dither\n        if (t >= end) \n        {\n            break;\n        }\n    }\n    return visibility;\n}\n\n\n/* -------------------------------------\n\n4. Shading\n\n------------------------------------- */\n// normal\nvec3 surfaceNormal(vec3 p) {\n    return normalize(vec3(\n        sceneSDF(vec3(p.x + EPSILON, p.y, p.z)) - sceneSDF(vec3(p.x - EPSILON, p.y, p.z)),\n        sceneSDF(vec3(p.x, p.y + EPSILON, p.z)) - sceneSDF(vec3(p.x, p.y - EPSILON, p.z)),\n        sceneSDF(vec3(p.x, p.y, p.z  + EPSILON)) - sceneSDF(vec3(p.x, p.y, p.z - EPSILON))\n    ));\n}\n\n// shading\nvec3 lambertShading(vec3 diffuseColor, vec3 p, vec3 normal, vec3 lightDir, vec3 lightIrradiance) {\n    float dotLN = dot(lightDir, normal);\n    if (dotLN < 0.0) {\n        return vec3(0.0, 0.0, 0.0);\n    } \n    return lightIrradiance * dotLN * diffuseColor;\n}\n\nvec3 lambertIllumination(vec3 p) {\n    vec3 normal = surfaceNormal(p);\n    \n    vec3 lightDir = normalize(vec3(sin(0.3*iTime), 0.5, cos(0.3*iTime)));\n    vec3 lightIrradiance = vec3(0.8);\n    vec3 color = vec3(0.0);\n    color += visibility(p + normal*2.0*EPSILON, lightDir, MIN_DIST, MAX_DIST, 8.0) \n            * lambertShading(vec3(1.0), p, normal, lightDir, lightIrradiance);\n      \n    return color;\n}\n\n\n/* -------------------------------------\n\n5. Camera\n\n------------------------------------- */\nvec3 rayDirection(float fieldOfView, vec2 size, vec2 fragCoord) {\n    vec2 xy = fragCoord - size / 2.0;\n    float z = size.y / tan(radians(fieldOfView) / 2.0);\n    return normalize(vec3(xy, -z));\n}\n\nmat3 viewMatrix(vec3 cameraOrigin, vec3 center, vec3 up) {\n    // Based on gluLookAt man page\n    vec3 f = normalize(center - cameraOrigin);\n    vec3 s = normalize(cross(f, up));\n    vec3 u = cross(s, f);\n    return mat3(s, u, -f);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // init random seed\n    ivec2 q = ivec2(fragCoord);\n    srand( hash(q.x+hash(q.y+hash(1117*iFrame))));\n    \n    // ray direction\n\tvec3 cameraRayDirInView = rayDirection(45.0, iResolution.xy, fragCoord);\n    \n    vec3 cameraPos = vec3(8.0 + 3.0 * sin(0.2 * iTime), 4.5, 8.0 - 3.0 * sin(0.2 * iTime));\n    mat3 viewToWorld = viewMatrix(cameraPos, vec3(0.0, 0.0, 0.0), vec3(0.0, 1.0, 0.0));\n    \n    vec3 cameraRayDir = viewToWorld * cameraRayDirInView;\n    \n    // distance\n    float dist = rayMarching(cameraPos, cameraRayDir, MIN_DIST, MAX_DIST);\n    \n    // didn't hit\n    if (dist > MAX_DIST - EPSILON) {\n        fragColor = vec4(0.0);\n\t\treturn;\n    }\n    \n    // hit point\n    vec3 p = cameraPos + dist * cameraRayDir;\n    \n    // shading\n    vec3 color = lambertIllumination(p) + vec3(0.2);\n    \n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc-by-nc-sa-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/sdlXR7.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "sdS3R3", "name": "Cloud Texture - Andrew", "author": "andrew741", "description": "A worly noise render. It has multiple octaves (the number of them varies with a sing wave). The worly noise is 3D.", "tags": ["clouds", "worlynoise"], "likes": 5, "viewed": 82, "date": "1617808719", "time_retrieved": "2024-06-20T20:38:42.620593", "image_code": "\n\n// remaps a value\nfloat map(float val, float cMin, float cMax, float nMin, float nMax)\n{\n    // a basic remapping function\n    // remapping from 0 - any\n    float nVal = val - cMin;\n    // scaling from 0 - (new_max - new_min)\n    nVal *= (nMax - nMin) / (cMax - cMin);\n    // adding the new min\n    nVal += nMin;\n    // returning it\n    return nVal;\n}\n\n\n// a heighly random persudo random number generator that takes in a vec3 and returns a vec3\nvec3 random(vec3 co)\n{\n    // note that this code is from another user (on shadertoy)\n    vec3 p = co;\n    p = vec3( dot(p,vec3(127.1,311.7, 74.7)),\n\t\t\t  dot(p,vec3(269.5,183.3,246.1)),\n\t\t\t  dot(p,vec3(113.5,271.9,124.6)));\n    vec3 output_ = fract(sin(p)*43758.5453123);\n\treturn output_;\n}\n\n\n// a smoothstep function\nfloat Smoothstep(float x)\n{\n    float k = clamp(x, 0., 1.);\n    return k * k * (3. - 2. * k);\n}\n\n\n// returns the output of random (contained extra code in an earlier version)\nvec3 RandPos(vec3 pos, float e)\n{\n    return random(pos);\n}\n\n\n// returns the magnitude\nfloat mag(vec3 v)\n{\n    // this is just the dot of v\n    return v.x * v.x + v.y * v.y + v.z * v.z;\n}\n\n\n// returns a value between 0 and 1 (of worly noise)\nfloat WorlyNoise(vec3 sample_pos, float scale, int o)\n{\n    // e is unused and is here because it was used in an earlier version\n    float e = float(o);\n    // geting the sample poses cell pos\n    vec3 cell_pos = floor(sample_pos / scale);\n    \n    // generating cells/nabors positions\n    // layer 1\n    vec3 cell1 = cell_pos + vec3(1., -1., -1.);\n    vec3 cell2 = cell_pos + vec3(1., 0., -1.);\n    vec3 cell3 = cell_pos + vec3(1., 1., -1.);\n    \n    vec3 cell4 = cell_pos + vec3(0., -1., -1.);\n    vec3 cell5 = cell_pos + vec3(0., 0., -1.);\n    vec3 cell6 = cell_pos + vec3(0., 1., -1.);\n    \n    vec3 cell7 = cell_pos + vec3(-1., -1., -1.);\n    vec3 cell8 = cell_pos + vec3(-1., 0., -1.);\n    vec3 cell9 = cell_pos + vec3(-1., 1., -1.);\n    \n    // layer 2\n    vec3 cell10 = cell_pos + vec3(1., -1., 0.);\n    vec3 cell11 = cell_pos + vec3(1., 0., 0.);\n    vec3 cell12 = cell_pos + vec3(1., 1., 0.);\n    \n    vec3 cell13 = cell_pos + vec3(0., -1., 0.);\n    vec3 cell14 = cell_pos + vec3(0., 0., 0.);\n    vec3 cell15 = cell_pos + vec3(0., 1., 0.);\n    \n    vec3 cell16 = cell_pos + vec3(-1., -1., 0.);\n    vec3 cell17 = cell_pos + vec3(-1., 0., 0.);\n    vec3 cell18 = cell_pos + vec3(-1., 1., 0.);\n    \n    // layer 3\n    vec3 cell19 = cell_pos + vec3(1., -1., 1.);\n    vec3 cell20 = cell_pos + vec3(1., 0., 1.);\n    vec3 cell21 = cell_pos + vec3(1., 1., 1.);\n    \n    vec3 cell22 = cell_pos + vec3(0., -1., 1.);\n    vec3 cell23 = cell_pos + vec3(0., 0., 1.);\n    vec3 cell24 = cell_pos + vec3(0., 1., 1.);\n    \n    vec3 cell25 = cell_pos + vec3(-1., -1., 1.);\n    vec3 cell26 = cell_pos + vec3(-1., 0., 1.);\n    vec3 cell27 = cell_pos + vec3(-1., 1., 1.);\n    \n    // generating the random offests for cell points\n    // layer1\n    vec3 rand1 = RandPos(cell1, e) * scale;\n    vec3 rand2 = RandPos(cell2, e) * scale;\n    vec3 rand3 = RandPos(cell3, e) * scale;\n    vec3 rand4 = RandPos(cell4, e) * scale;\n    vec3 rand5 = RandPos(cell5, e) * scale;\n    vec3 rand6 = RandPos(cell6, e) * scale;\n    vec3 rand7 = RandPos(cell7, e) * scale;\n    vec3 rand8 = RandPos(cell8, e) * scale;\n    vec3 rand9 = RandPos(cell9, e) * scale;\n    // layer2\n    vec3 rand10 = RandPos(cell10, e) * scale;\n    vec3 rand11 = RandPos(cell11, e) * scale;\n    vec3 rand12 = RandPos(cell12, e) * scale;\n    vec3 rand13 = RandPos(cell13, e) * scale;\n    vec3 rand14 = RandPos(cell14, e) * scale;\n    vec3 rand15 = RandPos(cell15, e) * scale;\n    vec3 rand16 = RandPos(cell16, e) * scale;\n    vec3 rand17 = RandPos(cell17, e) * scale;\n    vec3 rand18 = RandPos(cell18, e) * scale;\n    // layer3\n    vec3 rand19 = RandPos(cell19, e) * scale;\n    vec3 rand20 = RandPos(cell20, e) * scale;\n    vec3 rand21 = RandPos(cell21, e) * scale;\n    vec3 rand22 = RandPos(cell22, e) * scale;\n    vec3 rand23 = RandPos(cell23, e) * scale;\n    vec3 rand24 = RandPos(cell24, e) * scale;\n    vec3 rand25 = RandPos(cell25, e) * scale;\n    vec3 rand26 = RandPos(cell26, e) * scale;\n    vec3 rand27 = RandPos(cell27, e) * scale;\n    \n    // generating the distance to each of those cell positions/points position (the mag not length)\n    // layer1\n    float dist1 = mag(sample_pos - (cell1 * scale + rand1));\n    float dist2 = mag(sample_pos - (cell2 * scale + rand2));\n    float dist3 = mag(sample_pos - (cell3 * scale + rand3));\n    float dist4 = mag(sample_pos - (cell4 * scale + rand4));\n    float dist5 = mag(sample_pos - (cell5 * scale + rand5));\n    float dist6 = mag(sample_pos - (cell6 * scale + rand6));\n    float dist7 = mag(sample_pos - (cell7 * scale + rand7));\n    float dist8 = mag(sample_pos - (cell8 * scale + rand8));\n    float dist9 = mag(sample_pos - (cell9 * scale + rand9));\n    // layer2\n    float dist10 = mag(sample_pos - (cell10 * scale + rand10));\n    float dist11 = mag(sample_pos - (cell11 * scale + rand11));\n    float dist12 = mag(sample_pos - (cell12 * scale + rand12));\n    float dist13 = mag(sample_pos - (cell13 * scale + rand13));\n    float dist14 = mag(sample_pos - (cell14 * scale + rand14));\n    float dist15 = mag(sample_pos - (cell15 * scale + rand15));\n    float dist16 = mag(sample_pos - (cell16 * scale + rand16));\n    float dist17 = mag(sample_pos - (cell17 * scale + rand17));\n    float dist18 = mag(sample_pos - (cell18 * scale + rand18));\n    // layer3\n    float dist19 = mag(sample_pos - (cell19 * scale + rand19));\n    float dist20 = mag(sample_pos - (cell20 * scale + rand20));\n    float dist21 = mag(sample_pos - (cell21 * scale + rand21));\n    float dist22 = mag(sample_pos - (cell22 * scale + rand22));\n    float dist23 = mag(sample_pos - (cell23 * scale + rand23));\n    float dist24 = mag(sample_pos - (cell24 * scale + rand24));\n    float dist25 = mag(sample_pos - (cell25 * scale + rand25));\n    float dist26 = mag(sample_pos - (cell26 * scale + rand26));\n    float dist27 = mag(sample_pos - (cell27 * scale + rand27));\n    \n    // finding the smallest value\n    // layer1\n    float strength1 = min(min(min(dist1, dist2), min(dist3, dist4)), min(min(dist5, dist6), min(dist7, min(dist8, dist9))));\n    // layer2\n    float strength2 = min(min(min(dist10, dist11), min(dist12, dist13)), min(min(dist14, dist15), min(dist16, min(dist17, dist18))));\n    // layer3\n    float strength3 = min(min(min(dist19, dist20), min(dist21, dist22)), min(min(dist23, dist24), min(dist25, min(dist26, dist27))));\n    // finding the overal smallest and taking the square root of it to get the length to it\n    // layers all\n    float strength = sqrt(min(min(strength1, strength2), strength3));\n    \n    // returning and remapping\n    return map(strength / (scale * 1.25), 0., 1., 1., 0.);\n}\n\n// generates a noise texture (a height from 0 - 1 based on position)\nfloat OctaveWorly(vec2 fragCoord, vec4 iMouse, int octaves, float scale, float persistance, float luclarity, vec3 offset)\n{   \n    // initializing veriables\n    float height = 0.;\n    float l = 1.;\n    float total = 0.;\n    // looping over all octaves\n    for (int o = 0; o < octaves; o++)\n    {\n        // getting the height for that octave and adding it\n        height += WorlyNoise(vec3(fragCoord + floor(iMouse.xy) + WorlyNoise(vec3(fragCoord + floor(iMouse.xy) + float(o * 2000) - 500., (iTime * 10.)) + offset, scale * 0.25, o) * 128. + float(o * 2000), (iTime * 10.)) + offset, scale, o) * l;\n        // this is to remap the final height\n        total += l * 0.95;  // the 0.95 is because the height of the bumps (when added up) is almost never equal to the max height and thefore the more octaves, the duller the color\n        // changing the height and scale based on inputed paramaters\n        l *= luclarity;\n        scale *= persistance;\n    }\n    // remaping the final height\n    height /= total;\n    // returning the height\n    return height;\n}\n\n\n// main loop/the shader\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // uv (unused rn)\n    vec2 uv = fragCoord/iResolution.xy;\n    // getting the cloud texture\n    float height = OctaveWorly(fragCoord, iMouse, int(round(map(cos(iTime / 6. + 3.1415), -1., 1., 1., 6.))), 125., 0.5, 0.4, vec3(0.));\n    height = pow(1. - abs(height * 2. - 1.), 1.5);\n    // creating the color based on it\n    vec3 col = mix(vec3(0.9, 0.4, 0.8) * height + vec3(0., 0.4, 0.6) * pow(height, 4.), mix(vec3(0.3, 0.8, 0.5) * height, vec3(0.8, 0.2, 0.6) / height, 0.7), min(pow(smoothstep(0., 0.5, 1. - height), 8.), 0.7));\n    //col = vec3(height);\n\n    fragColor = vec4(col,1.0);\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/sdS3R3.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "sdS3Wy", "name": "党国", "author": "penghuailiang", "description": "本来想画一个国民党国旗的\nBlog: https://huailiang.github.io/blog/2021/shadertoy/", "tags": ["sin"], "likes": 1, "viewed": 379, "date": "1617879210", "time_retrieved": "2024-06-20T20:38:42.620593", "image_code": "#define PI 3.1415926\n\n\nfloat Cross(vec2 a, vec2 b)\n{\n    return a.x*b.y-a.y*b.x;\n}\n\nbool SameSide(vec2 A, vec2 B, vec2 C, vec2 P)\n{\n    vec2 AB = B-A;\n    vec2 AC = C-A;\n    vec2 AP = P-A;\n    float c1 = Cross(AB,AC);\n    float c2 = Cross(AB,AP);\n    return c1*c2>=0.;\n}\n\nbool InTiger(vec2 A, vec2 B, vec2 C, vec2 P)\n{\n    return SameSide(A,B,C,P) &&\n        SameSide(B,C,A,P) &&\n        SameSide(C,A,B,P);\n}\n\nvoid DrawStar(vec2 uv, float rot, float r,inout vec4 color)\n{\n    //uv（0，1）-> (-1, 1)\n    uv=2.*uv-vec2(1,1);\n    // float r =0.5;\n    float R = 0.98;\n    float delta = 0.2*PI;\n    float offset = 0.05*PI;\n    for(int i=0;i<10;i++)\n    {\n        float v = float(i);\n        float ang = delta*v+rot;\n        vec2 c =vec2(R*cos(ang), R*sin(ang));\n        float an1 = ang-offset ;\n        float an2 = ang+offset ;\n        vec2 c1 = vec2(r*cos(an1),r*sin(an1));\n        vec2 c2 = vec2(r*cos(an2),r*sin(an2));\n        if(InTiger(c,c1,c2,uv))\n            color = vec4(1,0.6,.4,1);\n    }\n    if(length(uv)<r)\n    {\n        color=vec4(.92,.89,.41,1);\n    }\n}\n\nvoid mainImage(out vec4 fragColor,in vec2 fragCoord)\n{\n    vec2 uv=fragCoord/iResolution.xy;\n    \n    fragColor=vec4(.1,0,0.9,1.);\n    \n    DrawStar(uv,iTime, .5+.2*sin(iTime), fragColor);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/sdS3Wy.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "sdS3zc", "name": "Cog of Chaos", "author": "Drakyen", "description": "Funky patterns, inversion, and of course the Cog of Chaos!", "tags": ["glitch", "chaos", "cog"], "likes": 3, "viewed": 88, "date": "1617733036", "time_retrieved": "2024-06-20T20:38:43.074916", "image_code": "\n\n\n#define rot(a) mat2(cos(a), -sin(a), sin(a), cos(a))\n#define inv(a) 1. - a * 2.\n\n#define pi 3.14159265359\n\nfloat quaim( float k, float x )\n{\n    return 2.0*sqrt(k)*x/(1.0+k*x*x);\n}\n\nfloat lsdf(vec2 p, vec2 a, vec2 b ) {\n\tvec2 pa = p - a;\n\tvec2 ba = b - a;\n\tfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0., 1. );\n\treturn length( pa - ba*h );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n\n    vec4 pattern = vec4(0.,0.,0.,1.);  \n    \n    \n    float distort = sin(iTime * 3.) * 0.01;\n    \n    vec2 rruv = uv * rot(iTime);\n    vec2 aruv = uv * rot(-iTime);\n    vec2 druv = uv * rot(iTime / 2.);\n    \n    for(float i = 0.; i < 5.; i ++)\n    {\n        \n        pattern.g += 1. - smoothstep(0.04,0.05, lsdf(abs(rruv) + sin(abs(druv.x) * 3000.) * distort, vec2(0.8 * mod(iTime + i, 5.) - 0.2,0.0), vec2(0.,0.8 * mod(iTime + i, 5.) - 0.2)));\n        pattern.bg += 1. - smoothstep(0.02, 0.03, lsdf(abs(aruv)  + tan(abs(druv.y) * 3000.) * distort, abs(vec2(sin(iTime), cos(iTime + i))) - vec2(0.4, 0.4), abs(vec2(cos(iTime + i), sin(iTime)))  - vec2(0.4, 0.4)));\n    }\n    \n    \n    float sq1 = quaim(3., sin(iTime * 4.)) / 2.;\n    float sq2 = quaim(3., sin(iTime * 3.)) / 2.;\n    float ofst = 0.46;\n    \n    \n    float sl = 1. - step(sq1, uv.x + ofst);\n    float st = 1. - step(sq2, uv.y + ofst);\n    \n    float sr = step(sq1, uv.x - ofst);\n    float sb = step(sq2, uv.y - ofst);\n    \n    float slr = sl + sr;\n    float stb = st + sb;\n    \n    \n    mat2 r = rot(iTime);\n    \n    float cb = step(quaim(3., cos(iTime)) / 2., distance(uv, vec2(0.,0.)));\n    \n    float add = quaim(0.5, cos(iTime)) * 20.;\n    \n    for(float i = 0.; i < add; i++)\n    {\n        vec2 point = vec2(sin((i/add) * 2. * pi), cos((i/add) * 2. * pi)) * 0.47;\n        cb += 1. - step(quaim(3., cos(iTime)) / 16., distance(uv, point * r));\n    }\n    \n    pattern = mix(inv(pattern), pattern, slr + stb);   \n    pattern = inv(pattern);   \n    pattern.rgb = mix(pattern.ggg + (pattern.rgb/3.), inv(pattern.rgb), cb);    \n    pattern.rgb = mix(mix(pattern.rgb, pattern.brg, sin(iTime/5.)), pattern.gbr, cos(iTime/5.));\n    \n   \n    fragColor = vec4(pattern);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/sdS3zc.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "sdS3zt", "name": "Fractal 50_gaz", "author": "gaz", "description": "fractal", "tags": ["fractal"], "likes": 18, "viewed": 292, "date": "1617809957", "time_retrieved": "2024-06-20T20:38:43.074916", "image_code": "#define R(p,a,r)mix(a*dot(p,a),p,cos(r))+sin(r)*cross(p,a)\n#define H(h)(cos((h)*6.3+vec3(0,23,21))*.5+.5)\nvoid mainImage(out vec4 O, vec2 C)\n{\n    O=vec4(0);\n    vec3 p,r=iResolution,\n    d=normalize(vec3((C-.5*r.xy)/r.y,1));  \n    for(float i=0.,s,e,g=0.;\n        ++i<90.;\n        O.xyz+=mix(vec3(1),H(log(s)*.6),.8)*.001/e/i\n    )\n    {\n        p=g*d-vec3(0,0,1.5);\n        p=R(p,normalize(vec3(1,2.*sin(iTime*.1),3)),iTime*.2);\n        s=5.;\n        p=p/dot(p,p)+1.;\n        for(int i=0;i++<8;)\n            p=abs(p-vec3(.8,2,1.5))-vec3(1,1.5,2.5),\n            s*=e=1.6/clamp(dot(p,p),.2,1.5),\n            p*=e;\n        g+=e=abs(p.x)/s+1e-3;\n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/sdS3zt.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "sdSGDc", "name": "Julia Set 3D", "author": "kithy", "description": "julia set, fractal, raymarching", "tags": ["raymarching", "fractal", "juliaset"], "likes": 3, "viewed": 52, "date": "1618030282", "time_retrieved": "2024-06-20T20:38:43.074916", "image_code": "#define ITR 10\n#define MAX_STEPS 64\n#define EPS 0.01\n\n\nfloat julia(vec3 p,vec3 c){\n\t\n\tfor(int i=0;i<ITR;i++){\n\t\tp=vec3(\n\t\t\tp.x*p.x-p.y*p.y-p.z*p.z,\n\t\t\t2.0*p.x*p.y,\n\t\t\t2.0*p.x*p.z\n\t\t\t)+c;\n\n\t\tif(length(p)>10.0) return 1.0-(float(i)/float(ITR));\n\t}\n\treturn -EPS;\n}\n\nvec2 rot(vec2 p,float angle){\n\treturn vec2(p.x*cos(angle)-p.y*sin(angle),p.y*cos(angle)+p.x*sin(angle));\n}\n\nfloat mainDist(vec3 p){\n\tvec3 r=p;\n\tr.xz=rot(r.xz,iTime*0.3);\n\tr.yz=rot(r.yz,iTime*0.3);\n\treturn julia(r,\n\t\tvec3(sin(iTime*0.3)*0.7,cos(iTime*0.4)*0.7,0.1)\n\t\t);\n}\n\nvec4 rayMarch(vec3 o,vec3 r){\n\tvec3 p=o;\n\tfloat t=0.0;\n\tfloat s;\n\tint i;\n\n\tfor(int i=0;i<MAX_STEPS;i++){\n\t\tp=o+r*t;\n\t\ts=mainDist(p);\n\t\tt+=s*EPS*10.0;\n\t\tif(s<EPS)break;\n\t}\n\treturn vec4(p,float(i));\n}\n\nvec3 genNormal(vec3 p){\n\treturn normalize(vec3(\n\t\tmainDist(vec3(p.x+EPS,p.y,p.z))-mainDist(vec3(p.x-EPS,p.y,p.z)),\n\t\tmainDist(vec3(p.x,p.y+EPS,p.z))-mainDist(vec3(p.x,p.y-EPS,p.z)),\n\t\tmainDist(vec3(p.x,p.y,p.z+EPS))-mainDist(vec3(p.x,p.y,p.z-EPS))\n\t\t));\n}\n\nvoid mainImage(out vec4 fragColor,in vec2 fragCoord){\n\tvec2 uv=(2.0*fragCoord.xy-iResolution.xy)/iResolution.y;\n\n\tvec3 cam=vec3(0.0,0.0,-1.8);\n\tvec3 ray=normalize(vec3(uv.xy*1.3,1.0));\n\n\tvec4 t=rayMarch(cam,ray);\n\tvec3 light=vec3(0.0,0.0,-2.0);\n\tvec3 toLight=normalize(light-t.xyz);\n\tvec3 normal=genNormal(t.xyz);\n\n\tfloat d=length(t.xyz-cam);\n\n\tfragColor=vec4(normal,1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/sdSGDc.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "sdSGDW", "name": "UniverseWithin314", "author": "Domain314", "description": "Followed a wonderful *Art of Code* tutorial // aka BigWIngs @shadertoy\nhttps://www.youtube.com/watch?v=3CycKKJiwis\n\nIf there is no sound => reload iChannel0 (Soundcloud)\n\nEnjoy :)", "tags": ["2d", "tutorial", "abstract", "pseudo3d", "artofcode"], "likes": 5, "viewed": 145, "date": "1617458598", "time_retrieved": "2024-06-20T20:38:43.675162", "image_code": "#define S(a, b, t) smoothstep(a, b, t)\n\nfloat DistLine(vec2 p, vec2 a, vec2 b) {\n    vec2 pa = p-a;\n    vec2 ba = b-a;\n    float t = clamp(dot(pa, ba)/dot(ba, ba), 0., 1.);\n    return length(pa - ba*t);\n}\n\nfloat N21 (vec2 p) {\n    p = fract(p*vec2(233.34, 851.73));\n    p += dot(p, p+23.45);\n    return fract(p.x*p.y);\n}\n\nvec2 N22(vec2 p) {\n    float n = N21(p);\n    return vec2(n, N21(p+n));\n}\n\n// Get random position\nvec2 GetPos(vec2 id, vec2 offs) {\n    vec2 n = N22(id+offs)*iTime;\n    //float x = sin(iTime * n.x);\n    //float y = cos(iTime * n.y);    \n    return offs+sin(n)*.4;\n}\n\nfloat Line(vec2 p, vec2 a, vec2 b) {\n    float d = DistLine(p, a, b);\n    float m = S(.03, .01, d);\n    float d2 = length(a-b);\n    m *= S(1.2, .8, d2)*.5+S(.05, .03, abs(d2-.75));\n    return m;\n}\n\nfloat Layer(vec2 uv) {\n    float m = 0.;\n    vec2 gv = fract(uv)-.5;\n    vec2 id = floor(uv);\n\n    //m = S(.1, .05, d);\n    \n    vec2 p[9];\n    \n    int i = 0;\n    for (float y = -1.; y <= 1.; y++) {\n        for (float x = -1.; x <= 1.; x++) {\n            p[i++] = GetPos(id, vec2(x,y));\n    }\n    }\n    float t = iTime*10.;\n    \n    for (int i = 0; i < 9; i++) {\n        m += Line(gv, p[4], p[i]);\n        \n        vec2 j = (p[i]-gv)*20.;\n        float sparkle = 1./dot(j,j);\n        \n        m += sparkle*(sin(t+fract(p[i].x)*10.)*.5 +.5);\n    }\n    m += Line(gv, p[1], p[3]);\n    m += Line(gv, p[1], p[5]);\n    m += Line(gv, p[7], p[3]);\n    m += Line(gv, p[7], p[5]);\n    \n    return m;\n}\n\n// in making\nfloat FFT() {\n    float fft = abs(texelFetch(iChannel0, ivec2(0,1.), 0).x);\n    fft += abs(texelFetch(iChannel0, ivec2(1,0), 0).x);\n    return fft;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    vec2 mouse = (iMouse.xy/iResolution.xy) -.5;\n    \n    float gradient = uv.y;\n\n    float m = 0.;\n    float t = iTime * .1;\n\n    float s = sin(t);\n    float c = cos(t);\n    \n    mat2 rot = mat2(c, -s, s, c);    \n    uv *= rot;\n    mouse *= rot;\n    \n    // fract snaps Layer back, after he moved away => continuous Layer behind Layer\n    for (float i=0.; i<1.; i+= 1./4.) {\n        float z = fract(i+t);\n        float size = mix(10., .5, z);\n        float fade = S(0., .5, z) * S(1., .8, z);\n        m += Layer(uv * size + i*20. - mouse)*fade;\n    }\n    \n    // different colours, bc of 3 different sin-speeds\n    vec3 base = sin(t*5.*vec3(.345, .456, .657))*.4 + .6;\n    vec3 col = m*base;\n    \n    float fft = texelFetch(iChannel0, ivec2(.7,0), 0).x;\n    gradient *= fft;\n    \n    col -= gradient*base*0.4;\n    \n    \n    // Grid\n    //if (gv.x > .48 || gv.y > .48)col = vec3(1,0,0);\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": "MtfXW7", "previewfilepath": "https://soundcloud.com/serega-shevelev/moderat-bad-kingdom-ks", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0, "src": "https://soundcloud.com/serega-shevelev/moderat-bad-kingdom-ks", "ctype": "musicstream"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/sdSGDW.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "sdsSWB", "name": "Fractalis Kaleidoscopus", "author": "rimina", "description": "Shadertoy version of a shader I did during my live shader coding stream at 16th of April 2021.", "tags": ["raymarching", "fractals", "kaleidoscope", "spacefolding"], "likes": 4, "viewed": 78, "date": "1619189045", "time_retrieved": "2024-06-20T20:38:43.675162", "image_code": "const float FAR = 100.0;\nconst int STEPS = 64;\nconst float E = 0.01;\n\nvec3 glow = vec3(0.0);\n\n\nfloat box(vec3 p, vec3 r){\n    vec3 d = abs(p)-r;\n    return length(max(d, 0.0)) + min(max(d.x, max(d.y, d.z)), 0.0);\n}\n\nfloat sphere(vec3 p, float r){\n    return length(p)-r;\n}\n\nvoid rot(inout vec2 p, float a){\n    p = cos(a)*p + sin(a)*vec2(p.y, -p.x);\n}\n\nfloat scene(vec3 p){\n    vec3 pp = p;\n    float time = iTime;\n\n    pp.z = mod(pp.z+40.0, 80.0)-40.0;\n    pp.x = mod(pp.x+40.0, 80.0)-40.0;\n\n    float scale = 2.2;\n    float offset = 16.0;\n    for(int i = 0; i < 5; ++i){\n        rot(pp.xz, 0.1*time);\n\n        pp = (abs(pp)-vec3(3.0, 2.0, 5.0))*scale-offset*(scale-1.0);\n        rot(pp.xz, 0.1*time);\n        rot(pp.yz, time*0.1);\n        rot(pp.yx, time*0.1);\n    }\n\n    float a = box(pp, vec3(20.0))*pow(scale, -5.0);\n    float b = box(pp, vec3(10.0, 10.0, FAR))*pow(scale, -5.0);\n    float c = box(pp-vec3(10.0, 20.0, 0.0), vec3(10.0, 10.0, FAR))*pow(scale, -5.0);\n\n    vec3 g = vec3(0.2, 0.4, 0.5)*0.01 / (0.01+abs(a));\n    g += vec3(0.5, 0.3, 0.2)*0.05 / (0.01+abs(c));\n\n    glow += g;\n\n    c = max(abs(c), 0.1);\n\n    return min(a, min(b, c));\n}\n\nfloat march(vec3 ro, vec3 rd){\n    float t = E;\n    vec3 p = ro;\n\n    for(int i = 0; i < STEPS; ++i){\n        float d = scene(p);\n        t +=d;\n        p = ro+rd*t;\n\n        if(d < E || t > FAR){\n            break;\n        }\n    }\n    return t;\n}\n\nvec3 normals(vec3 p){\n    vec3 eps = vec3(E, 0.0, 0.0);\n    return normalize(vec3(\n        scene(p+eps.xyy) - scene(p-eps.xyy),\n        scene(p+eps.yxy) - scene(p-eps.yxy),\n        scene(p+eps.yyx) - scene(p-eps.yyx)\n    ));\n}\n\nvec3 shade(vec3 p, vec3 rd, vec3 ld){\n    vec3 n = normals(p);\n\n    float l = max(dot(n, ld), 0.0);\n    float a = max(dot(reflect(ld, n), rd), 0.0);\n    float s = pow(a, 10.0);\n\n    return l*vec3(0.3, 0.5, 0.9)*0.5+s*vec3(0.3, 0.6, 1.8)*0.5;\n  \n}\n\n//http://www.iquilezles.org/www/articles/fog/fog.htm\nvec3 fog(vec3 col, vec3 p, vec3 ro, vec3 rd, vec3 ld){\n    float dist = length(p-ro);\n\tfloat sunAmount = max( dot(rd, -ld), 0.0 );\n\tfloat fogAmount = 1.0 - exp( -dist*0.06);\n\tvec3  fogColor = mix(vec3(0.0, 0.05, 0.05), vec3(0.5, 0.2, 0.15), pow(sunAmount, 7.0));\n    return mix(col, fogColor, fogAmount);\n}\n\nvec3 render(vec3 ro, vec3 rd){\n    float t = march(ro, rd);\n    vec3 p = ro+rd*t;\n\n    vec3 ld = normalize(vec3(0.0, 0.0, FAR) - ro);\n    vec3 ld2 = normalize(ro-vec3(0.0, 0.0, FAR));\n\n    vec3 col = vec3(0.0);\n    if(t < FAR){\n        col = shade(p, rd, ld);\n        col += shade(p, rd, ld2);\n        col *= 0.5;\n        col += vec3(0.1, 0.5, 0.6);\n    }\n    col += glow*0.25;\n\n    vec3 f = fog(col, p, ro, rd, ld);\n    vec3 ff = fog(col, p, ro, rd, ld2);\n    f += ff;\n    f *= 0.5;\n\n    return f;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 q = -1.0+2.0*uv;\n    q.x *= iResolution.x/iResolution.y;\n  \n    vec3 ro = vec3(1.0, 0.0, iTime);\n    vec3 rt = vec3(1.5, 0.0, -FAR);\n\n    vec3 z = normalize(rt-ro);\n    vec3 x = normalize(cross(z, vec3(0.0, 1.0, 0.0)));\n    vec3 y = normalize(cross(x, z));\n\n    vec3 rd = normalize(mat3(x, y, z) * vec3(q, radians(60.0)));\n\n    vec3 col = render(ro, rd);\n\n    col = pow(col, 1.0/vec3(2.2));\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/sdsSWB.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "sdsSWN", "name": "Mandara boze v1.2", "author": "kaiware007", "description": "Go to Nirvana（涅槃）\nIt is lighter than previous versions.\nOld version : https://www.shadertoy.com/view/wlBBWy", "tags": ["raymarching", "boze"], "likes": 4, "viewed": 78, "date": "1618679775", "time_retrieved": "2024-06-20T20:38:52.221217", "image_code": "// ------------------------------------------------------------------------------------\n// Original \"thinking...\" created by kaneta : https://www.shadertoy.com/view/wslSRr\n// Original Character By MikkaBouzu : https://twitter.com/mikkabouzu777\n// ------------------------------------------------------------------------------------\n\n// Rendering Option\n//#define ENABLE_REFLECTION\n//#define ENABLE_GRID_BOUNDARY\n#define SMOOTH_HSV\n\n#define saturate(x) clamp(x, 0.0, 1.0)\n#define MAX_MARCH 100\n#define MAX_RAYCAST 100\n#define MAX_RAYCAST_L 6\n#define MAX_DIST 50.\n\n#define M_PI 3.1415926\n#define M_PI2 M_PI*2.0\n\n#define RAD90 (M_PI * 0.5)\n#define RAD45 (M_PI * 0.25)\n\n#define M_PI03 1.04719\n#define M_PI06 2.09439\n\n#define SCROLL_SPEED (2.)\n\nconst float EPS = 1e-3;\nconst float EPS_N = 1e-4;\nconst float OFFSET = EPS * 10.0;\n\n//const vec3 sunDir = normalize(vec3(-1,1,-0.25));\nconst vec3 lightPos = vec3(0.50, 0.8, -0.5);\nconst vec3 lightColor = vec3(0.98, 0.92, 0.89) * 3.0;\n//const vec3 lightColor = vec3(0.3, 0.6, 0.9) * 2.0;\n\nstruct surface {\n\tfloat dist;\n    vec4 albedo;\n    vec3 emission;\n    float roughness;\n    float metalness;\n    int count;\n    bool isTransparent;\n    float refractPower;\n    bool isHit;\n};\n\nvec3 sinebow(float h) {\n    vec3 r = sin((.5-h)*M_PI + vec3(0,M_PI03,M_PI06));\n    return r*r;\n}\n\n#define COLOR_SEA (vec3(0,0.05,0.1))\n\n// Surface Data Define\n#define SURF_NOHIT(d)   (surface(d, vec4(0), \t\t \tvec3(0), 0.0, 0.0, 0, false, 0.0, false))\n#define SURF_BLACK(d) \t(surface(d, vec4(0,0,0,1),   \tvec3(0), 0.3, 0.0, 0, false, 0.0, true))\n#define SURF_FACE(d) \t(surface(d, vec4(1,0.7,0.6,1), \tvec3(0), 0.3, 0.0, 0, false, 0.0, true))\n#define SURF_MOUSE(d) \t(surface(d, vec4(1,0,0.1,1),   \tvec3(0), 0.3, 0.0, 0, false, 0.0, true))\n#define SURF_CHEEP(d) \t(surface(d, vec4(1,0.3,0.4,1), \tvec3(0), 0.3, 0.0, 0, false, 0.0, true))\n/*\nsurface SURF_PLANETEX(float d, vec3 pos)\n{\n    vec4 col = vec4(texture(iChannel0, vec2(pos.xz)).rgb, 1.);\n\n    return surface(d, col, vec3(0), 0.5, 0.3, 0, false, 0., true);\n}\n*/\n#define SURF_CS(d) \t\t(surface(d, vec4(0.9,0.9,0.9,1), vec3(0), 0.1, 0.8, 0, false, 0., true))\n\n#define SURF_SPHERE(d) \t(surface(d, vec4(0,0,0,1), \t\t vec3(0), 0.1, 0.8, 0, false, 2.2, true))\n#define SURF_CUBE(d) \t(surface(d, vec4(0,1,0,1), \t\t vec3(0), 0.5, 0.0, 0, false, 2.2, true))\n#define SURF_SPHERE2(d) (surface(d, vec4(0,0,1,1), \t\t vec3(0), 0.1, 0.2, 0, false, 2.2, true))\n#define SURF_LEG(d) \t(surface(d, vec4(0.5,0.2,0.1,1), vec3(0), 0.3, 0.0, 0, false, 0.0, true))\n\n#define SURF_MIRROR(d) \t(surface(d, vec4(0.5,0.5,0.5,1), \t\t vec3(0), 0.3, 0.8, 0, false, 2.2, true))\n#define SURF_SEA(d) \t(surface(d, vec4(COLOR_SEA,0), vec3(0), 0.2, 0.5, 0, true, 1.53, true))\n\n#define SURF_MAN1(d) \t(surface(d, vec4(1,0,0.1,1), \t\t vec3(0), 0.1, 0.8, 0, false, 2.2, true))\n\n//-----------------HSV-----------------\n\n//HSV functions from iq (https://www.shadertoy.com/view/MsS3Wc)\n#ifdef SMOOTH_HSV\nvec3 hsv2rgb( in vec3 c )\n{\n    vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n\n\trgb = rgb*rgb*(3.0-2.0*rgb); // cubic smoothing\n\n\treturn c.z * mix( vec3(1.0), rgb, c.y);\n}\n#else\nvec3 hsv2rgb( in vec3 c )\n{\n    vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n\n\treturn c.z * mix( vec3(1.0), rgb, c.y);\n}\n#endif\n\n//From Sam Hocevar: http://lolengine.net/blog/2013/07/27/rgb-to-hsv-in-glsl\nvec3 rgb2hsv(vec3 c)\n{\n    vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);\n    vec4 p = mix(vec4(c.bg, K.wz), vec4(c.gb, K.xy), step(c.b, c.g));\n    vec4 q = mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));\n\n    float d = q.x - min(q.w, q.y);\n    float e = 1.0e-10;\n    return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);\n}\n\n\n// Simple Palette : https://iquilezles.org/www/articles/palettes/palettes.htm\nvec3 palette( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d )\n{\n    return a + b*cos( M_PI2*(c*t+d) );\n}\n\n// Hash without Sine by Dave_Hoskins\n// https://www.shadertoy.com/view/4djSRW\n//----------------------------------------------------------------------------------------\n//  1 out, 1 in...\nfloat hash11(float p)\n{\n    p = fract(p * .1031);\n    p *= p + 33.33;\n    p *= p + p;\n    return fract(p);\n}\n\n//  1 out, 2 in...\nfloat hash12(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n//  1 out, 3 in...\nfloat hash13(vec3 p3)\n{\n\tp3  = fract(p3 * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n///  2 out, 2 in...\nvec2 hash22(vec2 p)\n{\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n\n}\n\n//  3 out, 1 in...\nvec3 hash31(float p)\n{\n   vec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973));\n   p3 += dot(p3, p3.yzx+33.33);\n   return fract((p3.xxy+p3.yzz)*p3.zyx);\n}\n\n///  3 out, 3 in...\nvec3 hash33(vec3 p3)\n{\n\tp3 = fract(p3 * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+33.33);\n    return fract((p3.xxy + p3.yxx)*p3.zyx);\n\n}\n\nsurface SURF_BG1(float d, vec3 pos)\n{\n    //vec3 index = floor((pos +vec3(0,0,iTime*3.0) )* 2. + 0.5);\n    vec3 index = floor(pos * 2. + 0.5);\n    float flg = mod(mod(index.x + index.y, 2.0) + index.z, 2.0);\n    //vec4 col = vec4(vec3(0.25) + vec3(0.5,0,0.5) * flg, 1);\n    //vec4 col = vec4(vec3(0.25) + sinebow((hash13(index) + iTime*0.5) * M_PI) * flg, 1);\n    return surface(d, vec4(vec3(0.25)*(1.-flg), 1), sinebow(hash13(index*3165.5) * M_PI + iTime*0.5) * flg, 0.5, 0.1 + 0.7 * (1.-flg), 0, false, 0., true);\n\t//return SURF_MIRROR(d);\n}\n\nfloat rand(vec2 st)\n{\n    return fract(sin(dot(st.xy, vec2(12.9898, 78.233))) * 10000.0);\n}\n\nfloat rand3d(vec3 st)\n{\n    return fract(sin(dot(st.xyz, vec3(12.9898, 78.233, 56.787))) * 10000.0);\n}\n\n\nfloat noise(vec3 st)\n{\n\tvec3 ip = floor(st);\n    vec3 fp = smoothstep(vec3(0.), vec3(1.), fract(st));\n\n\tvec4 a = vec4(rand3d(ip+vec3(0.)),rand3d(ip+vec3(1.,0.,0.)),rand3d(ip+vec3(0.,1.,0.)),rand3d(ip+vec3(1.,1.,0.)));\n    vec4 b = vec4(rand3d(ip+vec3(0.,0.,1.)),rand3d(ip+vec3(1.,0.,1.)),rand3d(ip+vec3(0.,1.,1.)),rand3d(ip+vec3(1.,1.,1.)));\n\n\ta = mix(a, b, fp.z);\n\ta.xy = mix(a.xy, a.zw, fp.y);\n\n\treturn mix(a.x, a.y, fp.x);\n}\n\n\nmat3 m = mat3( 0.00,  0.80,  0.60,\n              -0.80,  0.36, -0.48,\n              -0.60, -0.48,  0.64 );\n\nfloat fbm( vec3 p )\n{\n    float f;\n    f  = 0.5000*noise( p ); p = m*p*2.02;\n    f += 0.2500*noise( p ); p = m*p*2.03;\n    f += 0.1250*noise( p );\n    return f;\n}\n\nfloat easeInOutQuad(float t) {\n    if ((t *= 2.0) < 1.0) {\n        return 0.5 * t * t;\n    } else {\n        return -0.5 * ((t - 1.0) * (t - 3.0) - 1.0);\n    }\n}\n\nvec2 hash( in vec2 x )  // replace this by something better\n{\n    const vec2 k = vec2( 0.3183099, 0.3678794 );\n    x = x*k + k.yx;\n    return -1.0 + 2.0*fract( 16.0 * k*fract( x.x*x.y*(x.x+x.y)) );\n}\n\nfloat noise( in vec2 p ) {\n    vec2 i = floor( p );\n    vec2 f = fract( p );\n\tvec2 u = f*f*(3.0-2.0*f);\n    return -1.0+2.0*mix( mix( hash12( i + vec2(0.0,0.0) ),\n                     hash12( i + vec2(1.0,0.0) ), u.x),\n                mix( hash12( i + vec2(0.0,1.0) ),\n                     hash12( i + vec2(1.0,1.0) ), u.x), u.y);\n}\n\n// return gradient noise (in x) and its derivatives (in yz)\nvec3 noised( in vec2 p )\n{\n    vec2 i = floor( p );\n    vec2 f = fract( p );\n\n#if 1\n    // quintic interpolation\n    vec2 u = f*f*f*(f*(f*6.0-15.0)+10.0);\n    vec2 du = 30.0*f*f*(f*(f-2.0)+1.0);\n#else\n    // cubic interpolation\n    vec2 u = f*f*(3.0-2.0*f);\n    vec2 du = 6.0*f*(1.0-f);\n#endif\n\n    vec2 ga = hash( i + vec2(0.0,0.0) );\n    vec2 gb = hash( i + vec2(1.0,0.0) );\n    vec2 gc = hash( i + vec2(0.0,1.0) );\n    vec2 gd = hash( i + vec2(1.0,1.0) );\n\n    float va = dot( ga, f - vec2(0.0,0.0) );\n    float vb = dot( gb, f - vec2(1.0,0.0) );\n    float vc = dot( gc, f - vec2(0.0,1.0) );\n    float vd = dot( gd, f - vec2(1.0,1.0) );\n\n    return vec3( va + u.x*(vb-va) + u.y*(vc-va) + u.x*u.y*(va-vb-vc+vd),   // value\n                 ga + u.x*(gb-ga) + u.y*(gc-ga) + u.x*u.y*(ga-gb-gc+gd) +  // derivatives\n                 du * (u.yx*(va-vb-vc+vd) + vec2(vb,vc) - va));\n}\n\n// original sea octave function by TDM\n// https://www.shadertoy.com/view/Ms2SD1\nfloat sea_octave(vec2 uv, float choppy) {\n    uv += noise(uv);\n    vec2 wv = 1.0-abs(sin(uv));\n    vec2 swv = abs(cos(uv));\n    wv = mix(wv,swv,wv);\n    return pow(1.0-pow(wv.x * wv.y,0.65),choppy);\n}\n\n// Distance functions by iq\n// https://iquilezles.org/www/articles/distfunctions/distfunctions.htm\n\nfloat sdSphere(in vec3 p, float s) {\n    return length(p) - s;\n}\n\nfloat sdRoundBox(vec3 p, vec3 size, float r)\n{\n    return length(max(abs(p) - size * 0.5, 0.0)) - r;\n}\n\nfloat sdBox( vec3 p, vec3 b ) {\n    vec3 d = abs(p) - b;\n    return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\nfloat sdCapsule(vec3 p, vec3 a, vec3 b, float r)\n{\n\tvec3 pa = p - a, ba = b - a;\n\tfloat h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\n\treturn length(pa - ba*h) - r;\n}\n\nfloat sdCapsule(vec3 p, vec3 a, vec3 b, float r1, float r2)\n{\n\tvec3 pa = p - a, ba = b - a;\n\tfloat h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\n\treturn length(pa - ba*h) - mix(r1, r2, h);\n}\n\nfloat sdEllipsoid( vec3 p, vec3 r )\n{\n    float k0 = length(p/r);\n    float k1 = length(p/(r*r));\n    return k0*(k0-1.0)/k1;\n}\n\nfloat sdCappedTorus(in vec3 p, in vec2 sc, in float ra, in float rb)\n{\n  p.x = abs(p.x);\n  float k = (sc.y*p.x>sc.x*p.y) ? dot(p.xy,sc) : length(p.xy);\n  return sqrt( dot(p,p) + ra*ra - 2.0*ra*k ) - rb;\n}\n\nfloat sdRoundedCylinder( vec3 p, float ra, float rb, float h )\n{\n  vec2 d = vec2( length(p.xz)-2.0*ra+rb, abs(p.y) - h );\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0)) - rb;\n}\n\nfloat sdCappedCylinder( vec3 p, float h, float r )\n{\n  vec2 d = abs(vec2(length(p.xz),p.y)) - vec2(h,r);\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat sdPlane( vec3 p, vec4 n )\n{\n  // n must be normalized\n  return dot(p,n.xyz) + n.w;\n}\n\nfloat dot2( in vec2 v ) { return dot(v,v); }\nfloat dot2( in vec3 v ) { return dot(v,v); }\nfloat ndot( in vec2 a, in vec2 b ) { return a.x*b.x - a.y*b.y; }\n\nfloat sdCappedCone( vec3 p, float h, float r1, float r2 )\n{\n  vec2 q = vec2( length(p.xz), p.y );\n  vec2 k1 = vec2(r2,h);\n  vec2 k2 = vec2(r2-r1,2.0*h);\n  vec2 ca = vec2(q.x-min(q.x,(q.y<0.0)?r1:r2), abs(q.y)-h);\n  vec2 cb = q - k1 + k2*clamp( dot(k1-q,k2)/dot2(k2), 0.0, 1.0 );\n  float s = (cb.x<0.0 && ca.y<0.0) ? -1.0 : 1.0;\n  return s*sqrt( min(dot2(ca),dot2(cb)) );\n}\n\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\n// Distance Function 2D\nfloat sdSegment( in vec2 p, in vec2 a, in vec2 b )\n{\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\n\n// SdJoint3DSphere & joint3DMatrix & matrix utility\n// by PixelPhil\n// https://www.shadertoy.com/view/3tKGDW\nmat4 scaleMatrix( in vec3 sc ) {\n\treturn mat4(sc.x, 0,\t0,\t0,\n\t\t\t \t0, \t sc.y,\t0,\t0,\n\t\t\t\t0, \t 0,\t sc.z,\t0,\n\t\t\t\t0, \t 0,  0,\t1);\n}\n\nmat4 rotationX( in float angle ) {\n\n    float c = cos(angle);\n    float s = sin(angle);\n\n\treturn mat4(1.0, 0,\t 0,\t0,\n\t\t\t \t0, \t c,\t-s,\t0,\n\t\t\t\t0, \t s,\t c,\t0,\n\t\t\t\t0, \t 0,  0,\t1);\n}\n\nmat4 rotationY( in float angle ) {\n\n    float c = cos(angle);\n    float s = sin(angle);\n\n\treturn mat4( c, 0,\t s,\t0,\n\t\t\t \t 0,\t1.0, 0,\t0,\n\t\t\t\t-s,\t0,\t c,\t0,\n\t\t\t\t 0, 0,\t 0,\t1);\n}\n\nmat4 rotationZ( in float angle ) {\n    float c = cos(angle);\n    float s = sin(angle);\n\n\treturn mat4(c, -s,\t0,\t0,\n\t\t\t \ts,\tc,\t0,\t0,\n\t\t\t\t0,\t0,\t1,\t0,\n\t\t\t\t0,\t0,\t0,\t1);\n}\n\nmat4 translate( in vec3 p) {\n\n\treturn mat4(1,  0,\t0,\t0,\n\t\t\t \t0,\t1,\t0,\t0,\n\t\t\t\t0,\t0,\t1,\t0,\n\t\t\t\tp.x, p.y, p.z, 1);\n}\n// returns distance in .x and UVW parametrization in .yzw\nfloat sdJoint3DSphere( in vec3 p, in float l, in float a, in float w)\n{\n  if( abs(a)<0.001 )\n  {\n      return length(p-vec3(0,clamp(p.y,0.0,l),0))-w;\n  }\n\n  vec2  sc = vec2(sin(a),cos(a));\n  float ra = 0.5 * l / a;\n  p.x -= ra;\n  vec2 q = p.xy - 2.0*sc*max(0.0,dot(sc,p.xy));\n  float u = abs(ra)-length(q);\n  float d2 = (q.y<0.0) ? dot2( q + vec2(ra,0.0) ) : u*u;\n\n  return sqrt(d2+p.z*p.z)-w;\n}\n\nfloat sdJoint3DSphere( in vec3 p, in float l, in float a, in float w1, float w2)\n{\n  if( abs(a)<0.001 )\n  {\n      return length(p-vec3(0,clamp(p.y,0.0,l),0))-mix(w2, w1, p.y / l);\n  }\n\n  vec2  sc = vec2(sin(a),cos(a));\n  float ra = 0.5 * l / a;\n  p.x -= ra;\n  vec2 q = p.xy - 2.0*sc*max(0.0,dot(sc,p.xy));\n  float u = abs(ra)-length(q);\n  float d2 = (q.y<0.0) ? dot2( q + vec2(ra,0.0) ) : u*u;\n\n  return sqrt(d2+p.z*p.z)-mix(w2, w1, (p.y / l));\n}\n\n// A matrix to the tip of a sdJoint3DSphere\n// Could probably use some optimisations\nmat4 joint3DMatrix(in float l, in float a)\n{\n  if( abs(a)<0.001 )\n  {\n      return translate(vec3(0, -l, 0));\n  }\n\n  float ra = 0.5 * l / a;\n  float ara = abs(ra);\n  return  rotationZ(-a * 2.0) * translate(vec3(-ra + cos(2.0 * a) * ra, -sin(2.0 * a) * ra, 0.0));\n}\n\n// Union, Subtraction, SmoothUnion (distance, Material)\nsurface opU(surface d1, surface d2)\n{\n\t//return (d1.dist < d2.dist) ? d1 : d2;\n    if(d1.dist < d2.dist){\n        return d1;\n    } else {\n    \treturn d2;\n    }\n}\n\nsurface opS( surface d1, surface d2 )\n{\n    //return (-d1.dist > d2.dist) ? vec2(-d1.x, d1.y): d2;\n    //return (-d1.dist > d2.dist) ? surface(-d1.dist, d1.albedo, d1.emission, d1.roughness, d1.metalness) : d2;\n    if(-d1.dist > d2.dist){\n        d1.dist = -d1.dist;\n    \treturn d1;\n    } else {\n    \treturn d2;\n    }\n}\n\nsurface opSU( surface d1, surface d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2.dist - d1.dist)/k, 0.0, 1.0 );\n    float d = mix( d2.dist, d1.dist, h ) - k*h*(1.0-h);\n    vec4 albedo = mix( d2.albedo, d1.albedo, h );\n    vec3 emission = mix( d2.emission, d1.emission, h );\n    float roughness = mix( d2.roughness, d1.roughness, h );\n    float metalness = mix( d2.metalness, d1.metalness, h );\n    float refractPower = mix( d2.refractPower, d1.refractPower, h );\n    return surface(d, albedo, emission, roughness, metalness, d1.count, h > 0.5 ? d1.isTransparent : d2.isTransparent, refractPower, true);\n}\n\nsurface opI( surface d1, surface d2 )\n{\n    //return (d1.dist > d2.dist) ? d1 : d2;]\n    if(d1.dist > d2.dist) {\n        return d1;\n    }else{\n        return d2;\n    }\n}\n\nsurface opPaint(surface d1, surface d2)\n{\n    //return (d1.dist < d2.dist) ? d1 : surface(d1.dist, d2.albedo, d2.emission, d2.roughness, d2.metalness);\n    if(d1.dist < d2.dist) {\n        return d1;\n    } else {\n        d2.dist = d1.dist;\n        return d2;\n    }\n}\n\n// Union, Subtraction, SmoothUnion (distance only)\nfloat opUnion( float d1, float d2 ) {  return min(d1,d2); }\n\nfloat opSubtraction( float d1, float d2 ) { return max(-d1,d2); }\n\nfloat opIntersection( float d1, float d2 ) { return max(d1,d2); }\n\nfloat smin( float d1, float d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); }\n\n\nvec3 rotate(vec3 p, float angle, vec3 axis)\n{\n    vec3 a = normalize(axis);\n    float s = sin(angle);\n    float c = cos(angle);\n    float r = 1.0 - c;\n    mat3 m = mat3(\n        a.x * a.x * r + c,\n        a.y * a.x * r + a.z * s,\n        a.z * a.x * r - a.y * s,\n        a.x * a.y * r - a.z * s,\n        a.y * a.y * r + c,\n        a.z * a.y * r + a.x * s,\n        a.x * a.z * r + a.y * s,\n        a.y * a.z * r - a.x * s,\n        a.z * a.z * r + c\n    );\n    return m * p;\n}\n\nmat2 rot( float th ){ vec2 a = sin(vec2(RAD90, 0) + th); return mat2(a, -a.y, a.x); }\n\nvec2 foldRotate(in vec2 p, in float s, out float index) {\n    float a = M_PI / s - atan(p.x, p.y);\n    float n = M_PI2 / s;\n    index = floor(a / n);\n    a = index * n;\n    p *= rot(a);\n    return p;\n}\n\n\nvec3 opTwist(in vec3 p, float k )\n{\n    float c = cos(k*p.y);\n    float s = sin(k*p.y);\n    mat2  m = mat2(c,-s,s,c);\n    vec3  q = vec3(m*p.xz,p.y);\n    return vec3(q.x, q.y, q.z);\n}\n\nvec3 TwistY(vec3 p, float power)\n{\n    float s = sin(power * p.y);\n    float c = cos(power * p.y);\n    mat3 m = mat3(\n          c, 0.0,  -s,\n        0.0, 1.0, 0.0,\n          s, 0.0,   c\n    );\n    return m*p;\n}\n\nvec3 opRep( in vec3 p, in vec3 c)\n{\n    return mod(p+0.5*c,c)-0.5*c;\n}\n\nvec2 opRep2D( in vec2 p, in vec2 c)\n{\n    return mod(p+0.5*c,c)-0.5*c;\n}\n\n// 線分と無限平面の衝突位置算出\n// rayPos : レイの開始地点\n// rayDir : レイの向き\n// planePos : 平面の座標\n// planeNormal : 平面の法線\nfloat GetIntersectLength(vec3 rayPos, vec3 rayDir, vec3 planePos, vec3 planeNormal)\n{\n    return dot(planePos - rayPos, planeNormal) / dot(rayDir, planeNormal);\n}\n\n// 直方体とレイの衝突位置算出\nvec2 GetIntersectBox(vec3 rayPos, vec3 rayDir, vec3 boxPos, vec3 boxSize)\n{\n    vec3 diff = rayPos - boxPos;\n\tvec3 m = 1.0 / rayDir;\n    vec3 n = m * diff;\n    vec3 k = abs(m) * boxSize;\n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n\n    float tN = max(max(t1.x, t1.y), t1.z);\n    float tF = min(min(t2.x, t2.y), t2.z);\n\n    return vec2(tN, tF);\n    //return vec2(tF, tN);\n/*\n    if(tN > tF || tF < 0.0)\n        return vec2(-1.0);\t// no intersection\n\n    return vec2(tN, tF);\n*/\n}\n\n/*\n// 球とレイの衝突位置算出\nvec2 GetIntersectSphere(vec3 rayPos, vec3 rayDir, vec3 spherePos, float radius)\n{\n    float rsq = radius * radius;\n    vec3 xc = rayPos - spherePos;\n    float xc2 = dot(xc, xc);\n    float vxc = dot(rayDir, xc);\n    float d = vxc * vxc - xc2 + rsq;\n\n    //if(d < 0.0) return vec2(d,d);\n\n    float sqrtd = sqrt(d);\n    float tn = -vxc - sqrtd;\n    float tp = -vxc + sqrtd;\n\n    return vec2(min(tn, tp), max(tn, tp));\n\n    //if(tn >= 0.0 && tp >= 0.0) return vec2(min(tn, tp), max(tn, tp);\n\n    //return tn;\n}\n*/\nvec2 GetIntersectSphere(vec3 rayPos, vec3 rayDir, vec3 sphereCenter, float radius) {\n    float a = length(rayDir);\n    float a2 = a * a;\n    vec3 diff = rayPos - sphereCenter;\n    float b = dot(diff, rayDir);\n    float c = length(diff);\n    float c2 = c * c - radius * radius;\n    float b2ac = sqrt(b * b - a2 * c2);\n    float t1 = (-b + b2ac) / a2;\n    float t2 = (-b - b2ac) / a2;\n    return vec2(min(t1, t2), max(t1, t2));\n}\n\n// IK\nvec3 solve( vec3 p, float l1, float l2, vec3 dir )\n{\n\tvec3 q = p*( 0.5 + 0.5*(l1*l1-l2*l2)/dot(p,p) );\n\n\tfloat s = l1*l1 - dot(q,q);\n\ts = max( s, 0.0 );\n\tq += sqrt(s)*normalize(cross(p,dir));\n\n\treturn q;\n\n}\n\nvec3 solve( vec3 a, vec3 b, float l1, float l2, vec3 dir )\n{\n\treturn a + solve( b-a, l1, l2, dir );\n}\n\n/////////////////////////////////////////////////////////////////////////////////////////////////\n// easing function\n/////////////////////////////////////////////////////////////////////////////////////////////////\nfloat ease_cubic_out(float p)\n{\n\tfloat f = (p - 1.0);\n\treturn f * f * f + 1.0;\n}\n\nfloat easeInCirc(float x)\n{\n\treturn 1. - sqrt(1. - pow(x, 2.));\n}\n\nfloat easeOutCirc(float x)\n{\n\treturn sqrt(1. - pow(x - 1., 2.));\n}\n\nfloat easeInExpo(float x)\n{\n\treturn x == 0. ? 0. : pow(2., 10. * x - 10.);\n}\n\n\n/////////////////////////////////////////////////////////////////////////////////////////////////\n// Mikka Boze Distance Function\n/////////////////////////////////////////////////////////////////////////////////////////////////\n\nfloat sdEar(vec3 p)\n{\n    p = rotate(p, RAD90+0.25, vec3(0,0,1));\n    return sdCappedTorus(p + vec3(0.05, 0.175, 0), vec2(sin(0.7),cos(0.7)), 0.03, 0.01);\n}\n\n#define EYE_SPACE 0.04\n\nvec3 opBendXY(vec3 p, float k)\n{\n    float c = cos(k*p.x);\n    float s = sin(k*p.x);\n    mat2  m = mat2(c,-s,s,c);\n    return vec3(m*p.xy,p.z);\n}\n\nvec3 opBendXZ(vec3 p, float k)\n{\n    float c = cos(k*p.x);\n    float s = sin(k*p.x);\n    mat2  m = mat2(c,-s,s,c);\n    vec2 xz = m*p.xz;\n    return vec3(xz.x, p.y, xz.y);\n}\n\nfloat sdMouse(vec3 p, float ms)\n{\n    vec3 q = opBendXY(p, 2.0);\n    ms += 0.00001;\n    //return sdEllipsoid(q - vec3(0,0,0.2) * sc, vec3(0.05,0.015 + sin(iTime * 1.) * 0.05,0.05) * sc);\n    return sdEllipsoid(q - vec3(0,0,0.2), vec3(0.035, 0.01 * ms,0.05 * ms));\n}\n\nfloat sdCheep(vec3 p)\n{\n    const float x = 0.05;\n    const float z = -0.175;\n    const float r = 0.0045;\n    const float rb1 = 100.;\n\n    p = rotate(p, M_PI * -0.6 * (p.x - x), vec3(-0.2,0.8,0));\n\n    float d = sdCapsule(opBendXY(p + vec3(x, -0.01, z), rb1), vec3(-0.005,0.0,0.0), vec3(0.005, 0., 0.001), r);\n    float d1 = sdCapsule(opBendXY(p + vec3(x+0.01, -0.01, z), 200.0), vec3(-0.0026,0.0,0), vec3(0.0026, 0., 0), r);\n    float d2 = sdCapsule(opBendXY(p + vec3(x+0.019, -0.015, z), -rb1), vec3(-0.01,0.0,-0.01), vec3(0.0045, 0., 0.0), r);\n\n    return opUnion(opUnion(d, d1), d2);\n}\n\nfloat sdEyeBrow(vec3 p)\n{\n    const float x = 0.05;\n    p = opBendXZ(p + vec3(0.02,0,-0.02), -6.5);\n    return sdRoundBox(p + vec3(0.005, -0.14,-0.11), vec3(0.003,0.0025,0.05), 0.001);\n}\n\nsurface sdBoze(vec3 p, vec3 sc, float ms)\n{\n    surface result = SURF_NOHIT(0.);\n\n    float minsc = min(sc.x, min(sc.y, sc.z));\n    p /= sc;\n\n    // head\n\tfloat d = sdCapsule(p, vec3(0,0.05,0), vec3(0, 0.11, 0), 0.125);\n\n    float d1 = sdRoundedCylinder(p + vec3(0,0.025,0), 0.095, 0.05, 0.0);\n\n    d = smin(d, d1, 0.1);\n\n    vec3 mxp = vec3(-abs(p.x), p.yz);\n\n    // ear\n    float d2 = sdEar(mxp);\n    d = opUnion(d, d2);\n\n\tsurface head = SURF_FACE(d);\n\n\t// eye\n    float d4 = sdCapsule(mxp, vec3(-EYE_SPACE, 0.06, 0.13), vec3(-EYE_SPACE, 0.08, 0.125), 0.0175);\n    surface eye = SURF_BLACK(d4);\n\n    // mouse\n    float d6 = sdMouse(p, ms);\n    surface mouse = SURF_MOUSE(d6);\n\n    // cheep\n    float d7 = sdCheep(mxp);\n    surface cheep = SURF_CHEEP(d7);\n\n    // eyebrows\n    float d9 = sdEyeBrow(mxp);\n    eye.dist = opUnion(eye.dist, d9);\n\n    // integration\n    mouse = opU(eye, mouse);\n    result = opS(mouse, head);\n    result = opU(cheep, result);\n\n    result.dist *= minsc;\n\n    return result;\n}\nsurface sdColorBoze(vec3 p, vec3 sc, float ms, vec3 col)\n{\n    surface result = SURF_NOHIT(0.);\n\n    float minsc = min(sc.x, min(sc.y, sc.z));\n    p /= sc;\n\n    // head\n\tfloat d = sdCapsule(p, vec3(0,0.05,0), vec3(0, 0.11, 0), 0.125);\n\n    float d1 = sdRoundedCylinder(p + vec3(0,0.025,0), 0.095, 0.05, 0.0);\n\n    d = smin(d, d1, 0.1);\n\n    vec3 mxp = vec3(-abs(p.x), p.yz);\n\n    // ear\n    float d2 = sdEar(mxp);\n    d = opUnion(d, d2);\n\n\tsurface head = SURF_FACE(d);\n\thead.albedo = vec4(col, 1);\n\n\t// eye\n    float d4 = sdCapsule(mxp, vec3(-EYE_SPACE, 0.06, 0.13), vec3(-EYE_SPACE, 0.08, 0.125), 0.0175);\n    surface eye = SURF_BLACK(d4);\n\n    // mouse\n    float d6 = sdMouse(p, ms);\n    surface mouse = SURF_MOUSE(d6);\n\n    // cheep\n    float d7 = sdCheep(mxp);\n    surface cheep = SURF_CHEEP(d7);\n\n    // eyebrows\n    float d9 = sdEyeBrow(mxp);\n    eye.dist = opUnion(eye.dist, d9);\n\n    // integration\n    mouse = opU(eye, mouse);\n    result = opS(mouse, head);\n    result = opU(cheep, result);\n\n    result.dist *= minsc;\n\n    return result;\n}\n\n/*\nsurface sdCapsuleBoze(vec3 p, vec3 a, vec3 b, vec3 sc, float ms)\n{\n\tvec3 pa = p - a, ba = b - a;\n\tfloat h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\n\treturn sdBoze(pa - ba*h, sc, ms);\n}\n\nsurface sdUFBoze(vec3 p, vec3 sc, float ms)\n{\n    float sl = length(sc);\n    surface cone = SURF_CS(sdCappedCone(p + vec3(0, 0.08 * sl, 0), 0.06 * sl, 0.5 * sl, 0.25 * sl));\n    return opU(sdBoze(p, sc, ms), cone);\n}\n\nsurface sdCapsuleUFBoze(vec3 p, vec3 a, vec3 b, vec3 sc, float ms)\n{\n\tvec3 pa = p - a, ba = b - a;\n\tfloat h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\n    return sdUFBoze(pa - ba*h, sc, ms);\n    //vec3 q = rotate(pa - ba*h, h * M_PI2, normalize(ba));\n\t//return sdUFBoze(q, sc, ms);\n}\n\n#define LEG_X 0.05\n#define LEG_WIDTH1 0.05\n#define LEG_WIDTH2 0.025\n#define LEG_WIDTH3 0.045\n\n#define ARM_X1 0.18\n#define ARM_X2 0.2\n#define ARM_WIDTH1 0.05\n#define ARM_WIDTH2 0.025\n#define ARM_WIDTH3 0.03\n\nvoid calcArm(out vec3 a0, out vec3 a1, out vec3 a2, float spd, float flip, float h)\n{\n\t//vec3 n = noised(vec2(330. + spd * 0.97 + 578.4516 * flip, spd * flip));\n    vec3 n = vec3(sin(spd * 0.97+ 578.4516 * flip), cos(spd * 0.75* flip), sin(spd * flip + RAD90));\n    float r = n.z * 0.15 + 0.15;\n    float theta = (n.x * 0.5 + 0.5) * RAD90;\n    float phi = (n.y * 0.5 + 0.5) * RAD90;\n    a0 = vec3(ARM_X1 * flip, 0.9-h, 0.);\n    a2 = vec3(ARM_X2 * flip + sin(theta) * cos(phi) * r * flip, 0.75 + cos(n.y * M_PI2) * r-h, -sin(theta) * sin(phi) * r);\n    a1 = solve(a0, a2, 0.25, 0.15, vec3(0.5,0,0.5 * flip));\n}\n\nsurface sdBozeFullBody(vec3 p)\n{\n    surface result = SURF_NOHIT(0.);\n\n    float spd = iTime * 2.5;\n\n    // leg\n    //vec3 n1 = noised(vec2(spd, spd * 0.75));\n    vec3 n1 = vec3(sin(spd), cos(spd * 0.75), sin(spd + M_PI));\n    float r1 = n1.z * 0.25 + 0.25;\n    vec3 ll2 = vec3(LEG_X + sin(n1.y * M_PI) * cos(n1.x * M_PI) * r1, cos(n1.y * M_PI) * 0.3, sin(n1.y * M_PI) * sin(n1.x * M_PI) * r1);\n\n    //vec3 n2 = noised(vec2(-spd * 0.75, spd));\n    vec3 n2 = vec3(cos(spd), sin(spd * 0.75), cos(spd + RAD90));\n    float r2 = n2.z * 0.25 + 0.25;\n    vec3 rl2 = vec3(-LEG_X + sin(n2.y * M_PI) * cos(n2.x * M_PI) * r2, cos(n2.y * M_PI) * 0.3, sin(n2.y * M_PI) * sin(n2.x * M_PI) * r2);\n\n    float h = min(ll2.y, rl2.y);\n\n    vec3 ll0 = vec3(LEG_X, 0.5-h, 0.);\n    vec3 ll1 = solve(ll0, ll2, 0.25, 0.25, vec3(-1,0,0));\n\n    vec3 rl0 = vec3(-LEG_X, 0.5-h, 0.);\n    vec3 rl1 = solve(rl0, rl2, 0.25, 0.25, vec3(-1,0,0));\n\n    //result = SURF_MIRROR(sdCapsule(p, ll0, ll1, LEG_WIDTH1, LEG_WIDTH2));\n    //result = opSU(result, SURF_MIRROR(sdCapsule(p, ll1, ll2, LEG_WIDTH2, LEG_WIDTH3)), 0.01);\n    float body = sdCapsule(p, ll0, ll1, LEG_WIDTH1, LEG_WIDTH2);\n    //body = smin(body, sdCapsule(p, ll1, ll2, LEG_WIDTH2, LEG_WIDTH3), 0.01);\n    body = min(body, sdCapsule(p, ll1, ll2, LEG_WIDTH2, LEG_WIDTH3));\n\n    //result = opU(result, SURF_MIRROR(sdCapsule(p, rl0, rl1, LEG_WIDTH1, LEG_WIDTH2)));\n    //result = opSU(result, SURF_MIRROR(sdCapsule(p, rl1, rl2, LEG_WIDTH2, LEG_WIDTH3)), 0.01);\n    body = min(body, sdCapsule(p, rl0, rl1, LEG_WIDTH1, LEG_WIDTH2));\n    //body = smin(body, sdCapsule(p, rl1, rl2, LEG_WIDTH2, LEG_WIDTH3), 0.01);\n    body = min(body, sdCapsule(p, rl1, rl2, LEG_WIDTH2, LEG_WIDTH3));\n\n    // body\n    //result = opSU(result, SURF_MIRROR(sdRoundBox(p - vec3(0,0.6 - h,0), vec3(0.125,0.2,0.0),0.05)), 0.05);\n    //result = opSU(result, SURF_MIRROR(sdRoundBox(p - vec3(0,0.8 - h,-0.0125), vec3(0.15,0.1,0.0),0.075)), 0.05);\n    //body = smin(body, sdRoundBox(p - vec3(0,0.6 - h,0), vec3(0.125,0.2,0.0),0.05), 0.05);\n    //body = smin(body, sdRoundBox(p - vec3(0,0.8 - h,-0.0125), vec3(0.15,0.1,0.0),0.075), 0.05);\n    body = min(body, sdRoundBox(p - vec3(0,0.6 - h,0), vec3(0.125,0.2,0.0),0.05));\n    body = min(body, sdRoundBox(p - vec3(0,0.8 - h,-0.0125), vec3(0.15,0.1,0.0),0.075));\n\n    // left arm\n    vec3 la0, la1, la2;\n    calcArm(la0, la1, la2, spd, 1., h);\n    //result = opSU(result, SURF_MIRROR(sdCapsule(p, la0, la1, ARM_WIDTH1, ARM_WIDTH2)), 0.025);\n    //result = opSU(result, SURF_MIRROR(sdCapsule(p, la1, la2, ARM_WIDTH2, ARM_WIDTH3)), 0.01);\n    //body = smin(body, sdCapsule(p, la0, la1, ARM_WIDTH1, ARM_WIDTH2), 0.025);\n    //body = smin(body, sdCapsule(p, la1, la2, ARM_WIDTH2, ARM_WIDTH3), 0.01);\n\tbody = min(body, sdCapsule(p, la0, la1, ARM_WIDTH1, ARM_WIDTH2));\n    body = min(body, sdCapsule(p, la1, la2, ARM_WIDTH2, ARM_WIDTH3));\n\n    // right arm\n    vec3 ra0, ra1, ra2;\n    calcArm(ra0, ra1, ra2, spd, -1., h);\n    //result = opSU(result, SURF_MIRROR(sdCapsule(p, ra0, ra1, ARM_WIDTH1, ARM_WIDTH2)), 0.025);\n    //result = opSU(result, SURF_MIRROR(sdCapsule(p, ra1, ra2, ARM_WIDTH2, ARM_WIDTH3)), 0.01);\n    //body = smin(body, sdCapsule(p, ra0, ra1, ARM_WIDTH1, ARM_WIDTH2), 0.025);\n    //body = smin(body, sdCapsule(p, ra1, ra2, ARM_WIDTH2, ARM_WIDTH3), 0.01);\n    body = min(body, sdCapsule(p, ra0, ra1, ARM_WIDTH1, ARM_WIDTH2));\n    body = min(body, sdCapsule(p, ra1, ra2, ARM_WIDTH2, ARM_WIDTH3));\n\n    result = SURF_MIRROR(body);\n\n    // head\n    vec3 b = p;\n\n    b = rotate(b, M_PI, vec3(0,1,0));\n    b.y -= 1.01-h;\n\n    result = opSU(result, sdBoze(b, vec3(1), 1.), 0.02);\n\n    return result;\n}\n*/\n/////////////////////////////////////////////////////////////////////////////////////////////////\n// End of Mikka Boze\n/////////////////////////////////////////////////////////////////////////////////////////////////\n\nsurface sdMandara1(vec3 p, float h, float l, float t)\n{\n    vec3 q = rotate(p + vec3(0,-0.05,0.1), RAD90, vec3(1,0,0));\n\n    float d = sdCappedCylinder(q, h, l);\n\t  surface result = SURF_MAN1(d);\n    float r = distance(vec2(0,0.05), p.xy);\n    //result.albedo = vec4(hsv2rgb(vec3(r * 10. + t, 1, 1)), 1);\n    result.albedo = vec4(palette(r * 5. + t*2., vec3(0.5,0.5,0.5),vec3(0.5,0.5,0.5),vec3(2.0,1.0,0.0),vec3(0.5,0.20,0.25)) * smoothstep(0.1,0.3, fract(r*8. + t*5.3)), 1);\n    return result;\n}\n\nsurface map(vec3 p)\n{\n    float t = iTime * M_PI2;\n    //float ms = sin(t*SCROLL_SPEED)*0.5 + 0.5;\n    float ms = 1.;\n\n    p = opRep(p, vec3(2.5,2.5,100));\n\n    p = rotate(p, M_PI, vec3(0,1,0));\n\t  surface result = sdBoze(p, vec3(2.), ms);\n    result = opU(result, sdMandara1(p, 0.5, 0.01, -t*0.1));\n    //vec3 q = rotate(p + vec3(0,-0.05,0.1), RAD90, vec3(1,0,0));\n    //result = opU(result, SURF_MAN1(sdCappedCylinder(q, 0.5, 0.01)));\n    float index = 0.;\n    p.xy *= rot(t * 0.1);\n    p.xy = foldRotate(p.xy + vec2(0,-0.05), 8., index);\n    float l = 0.75;\n    float a = -RAD90;\n    //float a = -M_PI / float(BOZE_NUM);\n    vec3 pp = p + vec3(cos(a) * l, sin(a) * l, 0.);\n    // pp.xy *= rot(RAD90);\n    //result = opU(result, sdColorBoze(pp, vec3(1,1,1), ms, hsv2rgb(vec3(t * 0.125,0.9,1))));\n    result = opU(result, sdColorBoze(pp, vec3(1,1,1), ms, hsv2rgb(vec3((float(index) + t) * 0.125,0.9,1))));\n    result = opU(result, sdMandara1(pp, 0.31, 0.01, -t*0.1));\n\n    // #define BOZE_NUM 1\n    // float l = 0.8;\n    // float angle = M_PI2 / float(BOZE_NUM);\n    // for(int i = 0; i < BOZE_NUM; i++) {\n    //     //float r = float(i) * M_PI2 / num + st;\n    //     float a = (float(i) + t*0.1) * angle;\n    //     vec3 pp = p + vec3(cos(a) * l, sin(a) * l, 0.);\n    // \t  result = opU(result, sdColorBoze(pp, vec3(1,1,1), ms, hsv2rgb(vec3((float(i) + t) * 0.125,0.9,1))));\n    //\n    //     result = opU(result, sdMandara1(pp, 0.31, 0.01, -t*0.1));\n    //\n    //     //vec3 q = rotate(pp + vec3(0,-0.05,0.1), RAD90, vec3(1,0,0));\n    //     //p = rotate(p, M_PI, vec3(0,1,0));\n    //     //result = opU(result, SURF_MAN1(sdCappedCylinder(q, 0.31, 0.01)));\n    // }\n\n    //vec3 q = opRep(p - vec3(2.5, 50., 2.5), vec3(5, 100., 5));\n    //result = SURF_BG1(sdCappedCylinder(q, 0.5, 100.), p);\n    //float bg = sdCappedCylinder(q, 0.5, 100.);\n\n    // background\n    //result = opU(result, SURF_BG1(sdPlane(p + vec3(0., 0., 0.), vec4(0,1,0,0)), p));\n    //bg = smin(bg, sdPlane(p + vec3(0., 0., 0.), vec4(0,1,0,0)), 2.0);\n    //result = SURF_BG1(bg, p);\n\n    // boze\n    //result = opU(result, sdBozeFullBody(p));\n\n    return result;\n}\n\n#if 0\nvec3 norm(vec3 p)\n{\n    /*\n    vec2 e=vec2(.00001,.0);\n    return normalize(.000001+map(p).dist-vec3(map(p-e.xyy).dist,map(p-e.yxy).dist,map(p-e.yyx).dist));\n*/\n\tfloat c=map(p).dist;\n\tfloat e=1e-3;\n\treturn normalize(vec3(map(p+vec3(e,0,0)).dist-c,\n\t\t\t\t\t\t  map(p+vec3(0,e,0)).dist-c,\n\t\t\t\t\t\t  map(p+vec3(0,0,e)).dist-c));\n}\n#else\n\nvec3 norm(in vec3 position) {\n    /*\n    vec3 epsilon = vec3(0.001, 0.0, 0.0);\n    vec3 n = vec3(\n          map(position + epsilon.xyy).dist - map(position - epsilon.xyy).dist,\n          map(position + epsilon.yxy).dist - map(position - epsilon.yxy).dist,\n          map(position + epsilon.yyx).dist - map(position - epsilon.yyx).dist);\n    return normalize(n);\n\t*/\n    // inspired by tdhooper and klems - a way to prevent the compiler from inlining map() 4 times\n    // https://iquilezles.org/www/articles/normalsSDF/normalsSDF.htm\n    vec3 n = vec3(0.0);\n    for( int i=0; i<4; i++ )\n    {\n        vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);\n        n += e*map(position+0.0005*e).dist;\n      //if( n.x+n.y+n.z>100.0 ) break;\n    }\n    return normalize(n);\n    /*\n    // https://www.shadertoy.com/view/XltyRf\n    vec4 n = vec4(0);\n    for (int i = 0 ; i < 4 ; i++) {\n        vec4 s = vec4(position, 0);\n        s[i] += 0.001;\n        n[i] = map(s.xyz).dist;\n    }\n    return normalize(n.xyz-n.w);\n\t*/\n}\n#endif\n\nfloat shadow(in vec3 origin, in vec3 direction) {\n    float hit = 1.0;\n    float t = 0.02;\n\n    for (int i = 0; i < MAX_MARCH; i++) {\n        float h = map(origin + direction * t).dist;\n        if (h < EPS) return 0.0;\n        t += h;\n        hit = min(hit, 10.0 * h / t);\n        if (t >= 2.5) break;\n    }\n\n    return clamp(hit, 0.0, 1.0);\n}\n\n\n// ---------------------------------------------------\n// Starfield01 by xaot88\n// https://www.shadertoy.com/view/Md2SR3\n// ---------------------------------------------------\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n/*\n// Return random noise in the range [0.0, 1.0], as a function of x.\nfloat Noise2d( in vec2 x )\n{\n    float xhash = cos( x.x * 37.0 );\n    float yhash = cos( x.y * 57.0 );\n    return fract( 415.92653 * ( xhash + yhash ) );\n}\n\n// Convert Noise2d() into a \"star field\" by stomping everthing below fThreshhold to zero.\nfloat NoisyStarField( in vec2 vSamplePos, float fThreshhold )\n{\n    float StarVal = Noise2d( vSamplePos );\n    if ( StarVal >= fThreshhold )\n        StarVal = pow( (StarVal - fThreshhold)/(1.0 - fThreshhold), 6.0 );\n    else\n        StarVal = 0.0;\n    return StarVal;\n}\n\n// Stabilize NoisyStarField() by only sampling at integer values.\nfloat StableStarField( in vec2 vSamplePos, float fThreshhold )\n{\n    // Linear interpolation between four samples.\n    // Note: This approach has some visual artifacts.\n    // There must be a better way to \"anti alias\" the star field.\n    float fractX = fract( vSamplePos.x );\n    float fractY = fract( vSamplePos.y );\n    vec2 floorSample = floor( vSamplePos );\n    float v1 = NoisyStarField( floorSample, fThreshhold );\n    float v2 = NoisyStarField( floorSample + vec2( 0.0, 1.0 ), fThreshhold );\n    float v3 = NoisyStarField( floorSample + vec2( 1.0, 0.0 ), fThreshhold );\n    float v4 = NoisyStarField( floorSample + vec2( 1.0, 1.0 ), fThreshhold );\n\n    float StarVal =   v1 * ( 1.0 - fractX ) * ( 1.0 - fractY )\n        \t\t\t+ v2 * ( 1.0 - fractX ) * fractY\n        \t\t\t+ v3 * fractX * ( 1.0 - fractY )\n        \t\t\t+ v4 * fractX * fractY;\n\treturn StarVal;\n}\n\nvec2 getPoint(vec2 id, vec2 offset)\n{\n    return sin(hash22(id + offset) * iTime * 1.5 + hash22(id + offset)) * 0.4 + offset;\n}\n*/\n#define MANDEL_AA 2\nfloat mandelbrot( in vec2 c )\n{\n    #if 1\n    {\n        float c2 = dot(c, c);\n        // skip computation inside M1 - http://iquilezles.org/www/articles/mset_1bulb/mset1bulb.htm\n        if( 256.0*c2*c2 - 96.0*c2 + 32.0*c.x - 3.0 < 0.0 ) return 0.0;\n        // skip computation inside M2 - http://iquilezles.org/www/articles/mset_2bulb/mset2bulb.htm\n        if( 16.0*(c2+2.0*c.x+1.0) - 1.0 < 0.0 ) return 0.0;\n    }\n    #endif\n\n\n    const float B = 256.0;\n    float l = 0.0;\n    vec2 z  = vec2(0.0);\n    for( int i=0; i<512; i++ )\n    {\n        z = vec2( z.x*z.x - z.y*z.y, 2.0*z.x*z.y ) + c;\n        if( dot(z,z)>(B*B) ) break;\n        l += 1.0;\n    }\n\n    if( l>511.0 ) return 0.0;\n\n    // ------------------------------------------------------\n    // smooth interation count\n    //float sl = l - log(log(length(z))/log(B))/log(2.0);\n\n    // equivalent optimized smooth interation count\n    float sl = l - log2(log2(dot(z,z))) + 4.0;\n\n    float al = smoothstep( -0.1, 0.0, sin(0.5*6.2831*iTime ) );\n    l = mix( l, sl, al );\n\n    return l;\n}\n\nvec3 SkyColor( vec3 rd)\n{\n#if 0\n    // Cube Map\n\t// hide cracks in cube map\n\trd -= sign(abs(rd.xyz)-abs(rd.yzx))*.01;\n\n\tvec3 ldr = texture( iChannel0, rd ).rgb;\n\n\t// fake hdr\n\tvec3 hdr = 1.0/(1.2-ldr) - 1.0/1.2;\n\n\treturn hdr;\n#else\n    // Black\n    //return vec3(0,0,0);\n\n    /*\n    // julia\n    //float zoom = mod(iTime * M_PI2 * 0.5, 5.);\n    //float zoom = sin(iTime) * 1.5;\n    float zoom = -iTime*0.1;\n    vec2 z = rd.xy * (2.5 + zoom);\n\n    float t = 5.+iTime * 0.05;\n\tvec2 c = 0.51*cos(vec2(0,699)+0.1*t) -\n             0.25*cos(vec2(0,699)+0.2*t );\n\n\tfloat f = 1e20;\n\tfor( int i=0; i<128; i++ )\n\t{\n\t\tz = vec2( z.x*z.x-z.y*z.y, 2.0*z.x*z.y ) + c;\n\t\tf = min( f, dot(z,z) );\n\t}\n\n    f = 1.0+log2(f)/16.0;\n    //return vec3(f,f*f,f*f*f);\n    //return palette(f*3., vec3(0.8,0.5,0.4),vec3(0.2,0.4,0.2),vec3(2.0,1.0,1.0),vec3(0.0,0.25,0.25));\n    return palette(f*3., vec3(0.2,0.3,0.2),vec3(0.75,0.5,0.85),vec3(1.0,0.8,1.1),vec3(0.54,0.2,0.67));\n    */\n    /*\n    // Mandelbrot\n    vec3 col = vec3(0.0);\n    //float l = length(rd.xy);\n    //vec2 rp = vec2(rd.x * cos(rd.y), rd.x * sin(rd.y));\n    vec2 rp = rd.xy;\n    //x=rcosθ,y=rsinθ\n#if MANDEL_AA>1\n    for( int m=0; m<MANDEL_AA; m++ )\n    for( int n=0; n<MANDEL_AA; n++ )\n    {\n        //vec2 p = (-iResolution.xy + 2.0*(fragCoord.xy+vec2(float(m),float(n))/float(AA)))/iResolution.y;\n        vec2 p = (rp.xy + vec2(float(m),float(n))/float(MANDEL_AA)*0.001)* 1.1;\n        float w = float(MANDEL_AA*m+n);\n        float t = iTime + 0.5*(1.0/24.0)*w/float(MANDEL_AA*MANDEL_AA);\n#else\n        //vec2 p = (-iResolution.xy + 2.0*fragCoord.xy)/iResolution.y;\n        vec2 p = rp.xy * 0.5;\n        //float t = mod(iTime, 20.);\n        float t = iTime * M_PI2;\n#endif\n\n        //vec2 p = rd.xy * 0.1;\n        //float t = iTime;\n        //float zoo = 0.62 + 0.38*cos(.07*t);\n        //float zoo = 0.62 - 0.38*mod(.05*t, 0.5);\n        //float zoo = 0.62 - 0.38*(mod(t * 0.2, 1.)*1.0);\n        float zoo = 0.38*(mod(t * 0.2, 1.)*1.0);\n        float coa = cos( 0.01*(1.0-zoo)*t );\n        float sia = sin( 0.01*(1.0-zoo)*t );\n        //float coa = 1.;\n        //float sia = 0.;\n        //zoo = pow( zoo,8.0);\n        vec2 xy = vec2( p.x*coa-p.y*sia, p.x*sia+p.y*coa);\n        vec2 c = vec2(-.745,.186) + xy*zoo;\n\n        float f = mandelbrot(c);\n        //col += palette(f*0.15, vec3(0.5,0.5,0.5),vec3(0.5,0.5,0.5),vec3(1.0,1.0,1.0),vec3(0.0,0.10,0.20));\n        //col += palette(f*0.15, vec3(0.5,0.5,0.5),vec3(0.5,0.5,0.5),vec3(1.0,1.0,1.0),vec3(0.0,0.33,0.67));\n        col += sinebow(f*0.15+t);\n#if MANDEL_AA>1\n    }\n    col /= float(MANDEL_AA * MANDEL_AA);\n#endif\n    return col;\n    //return 0.5 + 0.5*cos( 3.0 + f*0.15 + vec3(0.0,0.6,1.0));\n    */\n\n    // test 1 UV\n    //return rd * 0.5 + 0.5;\n\n    // sinebow\n    //return sinebow(iTime*0.5) * 0.1;\n    return sinebow(iTime*0.5 + hash12(rd.xy*135156.));\n    // return vec3(0,0,0);\n\n    /*\n    // plexus\n    vec2 uv = vec2(atan(rd.z/rd.x), atan(length(rd.xz)/rd.y)) / M_PI;\n    uv += vec2(10.);\n    uv = abs(uv);\n    vec2 suv = uv * 10.;\n\n    vec2 id = floor(suv) - 0.5;\n    vec2 fuv = fract(suv) - 0.5;\n\tvec2 pp =  getPoint(id, vec2(0));\n    vec3 col = vec3(0);\n\n    for(int x = -1; x <= 1; x++){\n    \tfor(int y = -1; y <= 1; y++){\n            vec2 pos = getPoint(id, vec2(x,y)); //sin(hash22(id + vec2(x,y)) * iTime * 1.5) * 0.4 + vec2(x,y);\n            float d = 1.0 / pow(length(fuv - pos), 1.75) * 0.001;\n            col += d;\n\n            float len = smoothstep(1.0,0.5,length(pp - pos));\n            col += smoothstep(0.025,0.001,sdSegment(fuv, pos, pp)) * len;\n        }\n    }\n\n    return col * sinebow(uv.x);\n\t*/\n\n    // fake unity default sky-box\n\t//vec3 ground = mix(vec3(0.25,0.4,0.8), vec3(0.2,0.15,0.15), saturate(abs(rd.y) * 25.0));\n    //vec3 ground = mix(vec3(0.25,0.4,0.8), COLOR_SEA, saturate(abs(rd.y) * 25.0));\n    //vec3 sky = mix(vec3(0.25,0.4,0.8), vec3(0.001, 0.15, 1.), saturate(abs(rd.y) * 10.0));\n    //return rd.y < 0. ? ground :sky;\n\n\n\t// Starfield\n    //float x = atan(rd.z / rd.x);\n    //float y = acos(rd.y);\n    //return vec3(StableStarField(vec2(x,y) * 1000., 0.97 ));\n\n    // wave z\n    //vec2 uv = vec2(atan(rd.z/rd.x), atan(length(rd.xz)/rd.y)) / M_PI;\n    //return vec3(saturate(uv),0);\n    //return vec3(1,0,0) * saturate(sin(rd.z *100.- iTime * 10.));\n    //return sinebow(rd.z * 5.- iTime * 3.) * 0.25;\n    //return smoothstep(0.01,0.,mod(rd.z - iTime * 0.1, 0.1))*vec3(0.05,0.2,0.5);\n#endif\n}\n\n\n\n\n//------------------------------------------------------------------------------\n// BRDF\n//------------------------------------------------------------------------------\n\nfloat pow5(float x) {\n    float x2 = x * x;\n    return x2 * x2 * x;\n}\n\nfloat D_GGX(float linearRoughness, float NoH, const vec3 h) {\n    // Walter et al. 2007, \"Microfacet Models for Refraction through Rough Surfaces\"\n    float oneMinusNoHSquared = 1.0 - NoH * NoH;\n    float a = NoH * linearRoughness;\n    float k = linearRoughness / (oneMinusNoHSquared + a * a);\n    float d = k * k * (1.0 / M_PI);\n    return d;\n}\n\nfloat V_SmithGGXCorrelated(float linearRoughness, float NoV, float NoL) {\n    // Heitz 2014, \"Understanding the Masking-Shadowing Function in Microfacet-Based BRDFs\"\n    float a2 = linearRoughness * linearRoughness;\n    float GGXV = NoL * sqrt((NoV - a2 * NoV) * NoV + a2);\n    float GGXL = NoV * sqrt((NoL - a2 * NoL) * NoL + a2);\n    return 0.5 / (GGXV + GGXL);\n}\n\nvec3 F_Schlick(const vec3 f0, float VoH) {\n    // Schlick 1994, \"An Inexpensive BRDF Model for Physically-Based Rendering\"\n    return f0 + (vec3(1.0) - f0) * pow5(1.0 - VoH);\n}\n\nfloat F_Schlick(float f0, float f90, float VoH) {\n    return f0 + (f90 - f0) * pow5(1.0 - VoH);\n}\n\nfloat Fd_Burley(float linearRoughness, float NoV, float NoL, float LoH) {\n    // Burley 2012, \"Physically-Based Shading at Disney\"\n    float f90 = 0.5 + 2.0 * linearRoughness * LoH * LoH;\n    float lightScatter = F_Schlick(1.0, f90, NoL);\n    float viewScatter  = F_Schlick(1.0, f90, NoV);\n    return lightScatter * viewScatter * (1.0 / M_PI);\n}\n\nfloat Fd_Lambert() {\n    return 1.0 / M_PI;\n}\n\n\n//------------------------------------------------------------------------------\n// Indirect lighting\n//------------------------------------------------------------------------------\n\nvec3 Irradiance_SphericalHarmonics(const vec3 n) {\n    // Irradiance from \"Ditch River\" IBL (http://www.hdrlabs.com/sibl/archive.html)\n    return max(\n          vec3( 0.754554516862612,  0.748542953903366,  0.790921515418539)\n        + vec3(-0.083856548007422,  0.092533500963210,  0.322764661032516) * (n.y)\n        + vec3( 0.308152705331738,  0.366796330467391,  0.466698181299906) * (n.z)\n        + vec3(-0.188884931542396, -0.277402551592231, -0.377844212327557) * (n.x)\n        , 0.0);\n}\n\nvec2 PrefilteredDFG_Karis(float roughness, float NoV) {\n    // Karis 2014, \"Physically Based Material on Mobile\"\n    const vec4 c0 = vec4(-1.0, -0.0275, -0.572,  0.022);\n    const vec4 c1 = vec4( 1.0,  0.0425,  1.040, -0.040);\n\n    vec4 r = roughness * c0 + c1;\n    float a004 = min(r.x * r.x, exp2(-9.28 * NoV)) * r.x + r.y;\n\n    return vec2(-1.04, 1.04) * a004 + r.zw;\n}\n\nvec3 calcAmb(vec3 pos, vec3 rayDir, vec3 normal, vec3 lightPos, vec3 lightColor, surface surf) {\n    vec3 color = vec3(0);\n    vec3 lightDir = normalize(lightPos);\n    vec3 viewDir = normalize(-rayDir);\n    vec3 halfV = normalize(viewDir + lightDir);\n    //vec3 r = normalize(reflect(rayDir, normal));\n\n    float NoV = abs(dot(normal, viewDir)) + 1e-5;\n    float NoL = saturate(dot(normal, lightDir));\n    float NoH = saturate(dot(normal, halfV));\n    float LoH = saturate(dot(lightDir, halfV));\n\n    float indirectIntensity = 0.64;\n\n    vec3 albedo = surf.albedo.rgb;\n    float roughness = surf.roughness;\n    float metallic = surf.metalness;\n    float linearRoughness = roughness * roughness;\n    vec3 diffuseColor = (1.0 - metallic) * albedo.rgb;\n    vec3 f0 = 0.04 * (1.0 - metallic) + albedo.rgb * metallic;\n\n    float attenuation = shadow(pos, lightDir);\n\n    // specular BRDF\n    float D = D_GGX(linearRoughness, NoH, halfV);\n    float V = V_SmithGGXCorrelated(linearRoughness, NoV, NoL);\n    vec3  F = F_Schlick(f0, LoH);\n    vec3 Fr = (D * V) * F;\n\n    // diffuse BRDF\n    vec3 Fd = diffuseColor * Fd_Burley(linearRoughness, NoV, NoL, LoH);\n    color = Fd + Fr;\n    color *= (attenuation * NoL) * lightColor;\n\n \t// diffuse indirect\n    vec3 indirectDiffuse = Irradiance_SphericalHarmonics(normal) * Fd_Lambert();\n\n    vec3 ibl = diffuseColor * indirectDiffuse;\n\n    color += ibl * indirectIntensity;\n\tcolor += surf.emission.rgb;\n\n    return color;\n}\n\n//------------------------------------------------------------------------------\n// Tone mapping and transfer functions\n//------------------------------------------------------------------------------\n\nvec3 Tonemap_ACES(const vec3 x) {\n    // Narkowicz 2015, \"ACES Filmic Tone Mapping Curve\"\n    const float a = 2.51;\n    const float b = 0.03;\n    const float c = 2.43;\n    const float d = 0.59;\n    const float e = 0.14;\n    return (x * (a * x + b)) / (x * (c * x + d) + e);\n}\n\nvec3 OECF_sRGBFast(const vec3 linear) {\n    return pow(linear, vec3(1.0 / 2.2));\n}\n\n///////////////\n/*\nfloat sdAirLine(vec3 p)\n{\n\tconst float w = 0.0125;\n    float angle = -radians(30.);\n    p.y += 0.4;\n    float air = sdCapsule(p, vec3(0), vec3(0., -1.0, 0), w);\n    air = min(air, sdJoint3DSphere(p, 0.3, angle, w));\n    mat4 mat = joint3DMatrix(0.3, angle);\n\tp = (mat * vec4(p, 1.0)).xyz;\n    air = min(air, sdJoint3DSphere(p, 0.25, radians(30.), w));\n    mat = joint3DMatrix(0.25, -angle);\n\tp = (mat * vec4(p, 1.0)).xyz;\n    return min(air, sdCapsule(p, vec3(0, 0, 0), vec3(0., 1.0, 0), w));\n}\n\nfloat densitycalc(vec3 p){\n    float air = MAX_DIST;\n    float ad = M_PI / 5.0;\n    for(int i = 0; i < 6; i++){\n    \tvec3 q = p;\n\n    \tq = rotate(q, -RAD90, vec3(1,0,0));\n        q = rotate(q, ad * float(i), vec3(0,1,0));\n    \tq.x += 0.1;\n\n    \tair = min(air, sdAirLine(q));\n    }\n\n    return fbm(p * (50,50,15.) *vec3(1,1,1)+ vec3(0, 0, iTime * -15.)) - min(air, 1.) * (20.);\n}\n\nsurface rayCast(vec3 pos, vec3 dir, float dist)\n{\n    const vec3 boxPos = vec3(0);\n    const vec3 boxSize = vec3(0.4, 0.5, 2.);\n    vec2 sd =GetIntersectBox(pos, dir, boxPos, boxSize);\n    surface result = SURF_NOHIT(MAX_DIST);\n\n    if((sd.y >= 0.) && (dist > sd.x) && (sd.x < sd.y))\n    {\n        const float step = 4.0 / float(MAX_RAYCAST);\n\t\tconst float lightStep = 4.0 / float(MAX_RAYCAST_L);\n        float start = max(0., sd.x) - step;\n        pos = pos + dir * start;\n\n        float t = hash13(pos * 250.) * 0.01;\n        float alpha = 0.;\n        float transmittance = 1.0;\n        float absorption   = 25.;\n        for(int i = 0; i < MAX_RAYCAST; i++){\n            t += step;\n\n            vec3 pp = pos + dir * t;\n            if((t >= sd.y)||(start + t >= dist))\n                break;\n\n            vec3 q = pp - boxPos;\n\n            float density = densitycalc(q);\n\n            if(density > 0.0){\n                float dd = density * step;\n                transmittance *= 1.0 - dd * absorption;\n                if(transmittance < 0.01)\n                    break;\n                alpha += 20. * dd * transmittance;\n\n                result.albedo.rgb += vec3(0.5,0.65,0.85) * (150. * dd * transmittance);\n            }\n        }\n        result.emission.rgb *= max(0., alpha);\n        result.albedo.a = saturate(alpha);\n        result.dist = alpha > 0. ? t : dist;\n        result.isHit = alpha > 0. ? true : false;\n    }\n\n    return result;\n}\n\n*/\n\n#define fog_density(x) (1.0 - saturate(exp2(10.0 - (x) * 1.5)))\n\nsurface traceRay(in vec3 origin, in vec3 direction, float dist, out vec3 pos) {\n    float t = 0.0;\n\n    pos = origin;\n\n    int count = 0;\n    surface hit;\n    float d;\n    //surface volume = SURF_NOHIT(MAX_DIST);\n\n    for (int i = 0; i < MAX_MARCH; i++) {\n        hit = map(pos);\n        d = hit.dist;\n\n        if (d <= EPS || d >= MAX_DIST) {\n        \tbreak;\n        }\n\n#ifdef ENABLE_GRID_BOUNDARY\n        // grid overshoot check\n        vec2 iBox = GetIntersectBox(pos, direction, floor(pos + 0.5), vec3(0.5));\n        if(iBox.x < iBox.y && iBox.y > 0.0 && iBox.y < d) {\n            d = iBox.y + EPS;\n        }\n#endif\n\n        t += d;\n\n        pos = origin + direction * t;\n\n        count++;\n    }\n\n    hit.dist = t;\n\t  hit.count = count;\n\n    pos = origin + direction * t;\n    vec3 sky = SkyColor(direction);\n\n    if(hit.isHit)\n    {\n        vec3 nor = norm(pos);\n\n        // out line\n        float NoV = abs(dot(nor, -direction)) + 1e-5;\n        hit.albedo.rgb *= smoothstep(0.19, 0.2,NoV);\n\n        //vec3 lightPos;\n\t\t//vec3 lightColor;\n        //fireworkLight(lightPos, lightColor);\n        // Calc Ambient\n        //hit.albedo.rgb = calcAmb(pos, direction, nor, lightPos, lightColor, hit);\n        // Exponential distance fog\n        //hit.albedo.rgb = mix(hit.albedo.rgb, sky, fog_density(hit.dist + dist));\n    }\n\n    /*\n    // raycast\n    surface volume = rayCast(origin, direction, t);\n\n    if(volume.isHit)\n    {\n        // Calc Ambient\n        //volume.albedo.rgb = calcAmb(pos, direction, nor, lightPos, lightColor, volume);\n\n        // Exponential distance fog\n        volume.albedo.rgb = mix(volume.albedo.rgb, sky, fog_density(volume.dist + dist));\n\n        hit.albedo.rgb = mix(hit.albedo.rgb, volume.albedo.rgb, volume.albedo.a);\n\t\thit.albedo.a = max(hit.albedo.a, volume.albedo.a);\n        hit.albedo.rgb = mix(sky, hit.albedo.rgb, hit.albedo.a);\n\n        // Exponential distance fog\n        volume.emission.rgb = mix(volume.emission.rgb, sky, fog_density(volume.dist + dist));\n        hit.albedo.rgb += volume.emission;\n        //hit.albedo.rgb += volume.albedo.rgb;\n\n    }\n    */\n    if(d <= EPS){\n\n        hit.isHit = true;\n        return hit;\n    \t//return surface(hit.dist, hit.albedo, hit.emission, hit.roughness, hit.metalness, count, hit.isTransparent, hit.refractPower, true);\n    }else{\n\n        hit.isHit = false;\n        return hit;\n\n    \t//return surface(hit.dist, hit.albedo, hit.emission, hit.roughness, hit.metalness, count, hit.isTransparent, hit.refractPower, false);\n    }\n}\n\nvec3 render(vec3 p, vec3 ray, vec2 uv)\n{\n    vec3 pos;\n    surface mat = traceRay(p, ray, 0., pos);\n\n    //pos = p + mat.dist * ray;\n    //return materialize(pos, ray, mat, uv);\n\n    vec3 col = vec3(0,0,0);\n    vec3 sky = SkyColor(ray);\n\n    //if (!mat.isHit && mat.albedo.a < EPS)\n    if (!mat.isHit) {\n        col = sky;\n    } else\n    {\n\n        col = mat.albedo.rgb;\n\n#ifdef ENABLE_REFLECTION\n        float metalness = mat.metalness;\n        float dist = mat.dist;\n\n        if(mat.isHit){\n            // reflection\n            for(int i = 0; i < 2; i++)\n            {\n                vec3 nor = norm(pos);\n                //nor = normalize(nor + hash33(pos) * mat.roughness * 0.05);\n                bool isIncoming = dot(ray, nor) < 0.0;\n                vec3 orientingNormal = isIncoming ? nor : -nor;\n                bool isTotalReflection = false;\n\n                if(mat.isTransparent){\n                    // refract\n                  \t//float nnt = isIncoming ? 1.0 / mat.refractPower : mat.refractPower;\n                    //float nnt = 1.0 / mat.refractPower;\n                    float nnt = isIncoming ? 1.0 / mat.refractPower : 1.0;\n                    ray = refract(ray, orientingNormal, nnt);\n                    pos = pos - orientingNormal * OFFSET;\n                    isTotalReflection = (length(ray) <= 0.9);\n                }\n\n                if(isTotalReflection || !mat.isTransparent)\n                {\n                    // reflect\n                    ray = reflect(ray, orientingNormal);\n                    pos = pos + orientingNormal * OFFSET;\n                }\n\n                mat = traceRay(pos, ray, dist, pos);\n\n                dist += mat.dist;\n\n                pos = pos + mat.dist * ray;\n\n                col += mat.albedo.rgb * metalness;\n                //col += result;\n                metalness *= mat.metalness;\n\n\t\t\t\tif(!mat.isHit || metalness < 0.0001)\n                    break;\n            }\n        }\n#endif\n    }\n\n    // Glow\n\t//col += (sinebow(iTime * 10.) +vec3(0.1))* pow((mat.z + 10.) / float(MAX_MARCH), 3.5);\n\n    // Tone mapping\n    //col = Tonemap_ACES(col);\n\n\n    // Gamma compression\n    col = OECF_sRGBFast(col);\n    return col;\n    //return vec4(col, 1. - clamp(mat.dist, 0., 1.));\n\n}\n/*\nvec3 postEffect(vec3 col, vec2 index)\n{\n    //float shift = rand(index * 82.345);\n    float shift = (index.x + index.y * 3.0) / 9.0;\n    vec3 hsv = rgb2hsv(col);\n    hsv.x += shift + iTime * 0.1;\n    hsv.y = 0.75;\n    //hsv.y *= 2.5;\n    //hsv.y = hsv.y < 0.25 ? 0.25 : hsv.y;\n    //hsv.y = floor(hsv.y * 8.0) / 8.0;\n    //hsv.z = 1.0;\n    //hsv.z = hsv.z < 0.7 ? hsv.z < 0.5 ? 0.0 : 0.5 : hsv.z;\n    hsv.z = floor(hsv.z * 8.0) / 8.0;\n    hsv.z = hsv.z < 0.6 ? 0.0 : hsv.z;\n\n    hsv.x += hsv.z * 3.0;\n\tcol = hsv2rgb(hsv);\n    //col = floor(col * 8.0) / 8.0;\n\n\treturn col;\n}\n*/\nmat3 camera(vec3 ro, vec3 ta, float cr )\n{\n\tvec3 cw = normalize(ta - ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = (fragCoord.xy * 2.0 - iResolution.xy) / min(iResolution.x, iResolution.y);\n    //vec2 mouseUV = (-iResolution.xy + 2.0 * iMouse.xy)/iResolution.y;\n\n    //vec2 p = (fragCoord.xy) / min(iResolution.x, iResolution.y);\n    //vec2 p = (fragCoord.xy) / iResolution.xy;\n\n    //vec2 idx = floor(p*3.0);\n    //p = fract(p*3.0) - 0.5;\n    //p.x *= max(iResolution.x, iResolution.y)/min(iResolution.x, iResolution.y);\n\n    float t = iTime * M_PI2;\n    float y = 0.0;\n    float r = 100. - mod(t * SCROLL_SPEED, 100.);\n    float theta = RAD90;\n    float phi   = 0.;\n    vec3 ro = vec3(cos(theta) * r, y + sin(phi), -sin(theta) * r);\n    vec3 ta = vec3(0., y, 0);\n\n    //ro.xy += mouseUV * 20.0;\n\n    mat3 c = camera(ro, ta, 0.0);\n    vec3 ray = c * normalize(vec3(p, 50.0));\n    vec3 col = render(ro, ray, fragCoord.xy);\n\n    //col = postEffect(col, idx);\n\n    fragColor = vec4(col,1.0);\n    //fragColor = col;\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/sdsSWN.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "sdSSzz", "name": "Crystal skull", "author": "mrange", "description": "License CC0: Crystal skull\nPerhaps it's just me that sees a glowing skull captured in a crystal?\nResult after continued experimenting with marble fractals and different kinds of trap functions\n", "tags": ["raymarch", "fractals", "marble"], "likes": 27, "viewed": 461, "date": "1619543127", "time_retrieved": "2024-06-20T20:38:53.572844", "image_code": "// License CC0: Crystal skull\n// Perhaps it's just me that sees a glowing skull captured in a crystal?\n// Result after continued experimenting with marble fractals and different kinds of trap functions\n\n#define TIME              iTime\n#define RESOLUTION        iResolution\n#define ROT(a)            mat2(cos(a), sin(a), -sin(a), cos(a))\n#define PI                3.141592654\n#define TAU               (2.0*PI)\n#define L2(x)             dot(x, x)\n#define PCOS(x)           (0.5+0.5*cos(x))\n\n#define RAYSHAPE(ro, rd)  raySphere4(ro, rd, 0.5)\n#define IRAYSHAPE(ro, rd) iraySphere4(ro, rd, 0.5)\n\nconst float miss          = 1E4;\nconst float refrIndex     = 0.85;\nconst vec3  lightPos      = 2.0*vec3(1.5, 2.0, 1.0);\nconst vec3  skyCol1        = pow(vec3(0.2, 0.4, 0.6), vec3(0.25))*1.0;\nconst vec3  skyCol2        = pow(vec3(0.4, 0.7, 1.0), vec3(2.0))*1.0;\nconst vec3  sunCol         = vec3(8.0,7.0,6.0)/8.0;\n\nfloat tanh_approx(float x) {\n//  return tanh(x);\n  float x2 = x*x;\n  return clamp(x*(27.0 + x2)/(27.0+9.0*x2), -1.0, 1.0);\n}\n\n// https://stackoverflow.com/questions/15095909/from-rgb-to-hsv-in-opengl-glsl\nvec3 hsv2rgb(vec3 c) {\n  const vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n  vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n  return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\n// Various ray object intersection from IQ:\n//  https://www.iquilezles.org/www/articles/intersectors/intersectors.htm\nfloat raySphere4(vec3 ro, vec3 rd, float ra) {\n    float r2 = ra*ra;\n    vec3 d2 = rd*rd; vec3 d3 = d2*rd;\n    vec3 o2 = ro*ro; vec3 o3 = o2*ro;\n    float ka = 1.0/dot(d2,d2);\n    float k3 = ka* dot(ro,d3);\n    float k2 = ka* dot(o2,d2);\n    float k1 = ka* dot(o3,rd);\n    float k0 = ka*(dot(o2,o2) - r2*r2);\n    float c2 = k2 - k3*k3;\n    float c1 = k1 + 2.0*k3*k3*k3 - 3.0*k3*k2;\n    float c0 = k0 - 3.0*k3*k3*k3*k3 + 6.0*k3*k3*k2 - 4.0*k3*k1;\n    float p = c2*c2 + c0/3.0;\n    float q = c2*c2*c2 - c2*c0 + c1*c1;\n    float h = q*q - p*p*p;\n    if (h<0.0) return miss; //no intersection\n    float sh = sqrt(h);\n    float s = sign(q+sh)*pow(abs(q+sh),1.0/3.0); // cuberoot\n    float t = sign(q-sh)*pow(abs(q-sh),1.0/3.0); // cuberoot\n    vec2  w = vec2( s+t,s-t );\n    vec2  v = vec2( w.x+c2*4.0, w.y*sqrt(3.0) )*0.5;\n    float r = length(v);\n    return -abs(v.y)/sqrt(r+v.x) - c1/r - k3;\n}\n\nvec3 sphere4Normal(vec3 pos) {\n  return normalize( pos*pos*pos );\n}\n\nfloat iraySphere4(vec3 ro, vec3 rd, float ra) {\n  // Computes inner intersection by intersecting a reverse outer intersection\n  vec3 rro = ro + rd*ra*4.0;\n  vec3 rrd = -rd;\n  float rt = raySphere4(rro, rrd, ra);\n\n  if (rt == miss) return miss;\n  \n  vec3 rpos = rro + rrd*rt;\n  return length(rpos - ro);\n}\n\nfloat rayPlane(vec3 ro, vec3 rd, vec4 p ) {\n  return -(dot(ro,p.xyz)+p.w)/dot(rd,p.xyz);\n}\n\nvec3 skyColor(vec3 ro, vec3 rd) {\n  const vec3 sunDir = normalize(lightPos);\n  float sunDot = max(dot(rd, sunDir), 0.0);  \n  vec3 final = vec3(0.);\n\n  final += mix(skyCol1, skyCol2, rd.y);\n  final += 0.5*sunCol*pow(sunDot, 20.0);\n  final += 4.0*sunCol*pow(sunDot, 400.0);    \n\n  float tp  = rayPlane(ro, rd, vec4(vec3(0.0, 1.0, 0.0), 0.505));\n  if (tp > 0.0) {\n    vec3 pos  = ro + tp*rd;\n    vec3 ld   = normalize(lightPos - pos);\n    float ts4 = RAYSHAPE(pos, ld);\n    vec3 spos = pos + ld*ts4;\n    float its4= IRAYSHAPE(spos, ld);\n    // Extremely fake soft shadows\n    float sha = ts4 == miss ? 1.0 : (1.0-1.0*tanh_approx(its4*1.5/(0.5+.5*ts4)));\n    vec3 nor  = vec3(0.0, 1.0, 0.0);\n    vec3 icol = 1.5*skyCol1 + 4.0*sunCol*sha*dot(-rd, nor);\n    vec2 ppos = pos.xz*0.75;\n    ppos = fract(ppos+0.5)-0.5;\n    float pd  = min(abs(ppos.x), abs(ppos.y));\n    vec3  pcol= mix(vec3(0.4), vec3(0.3), exp(-60.0*pd));\n\n    vec3 col  = icol*pcol;\n    col = clamp(col, 0.0, 1.25);\n    float f   = exp(-10.0*(max(tp-10.0, 0.0) / 100.0));\n    return mix(final, col , f);\n  } else{\n    return final;\n  }\n}\n\n// Marble fractal from https://www.shadertoy.com/view/MtX3Ws\nvec2 csqr(vec2 a) { \n  return vec2(a.x*a.x - a.y*a.y, 2.*a.x*a.y); \n}\n\nfloat l0(vec3 v) {\n  return abs(v.x) + abs(v.y) + abs(v.z);\n}\n\nfloat marble_df(vec3 p) {  \n  float res = 0.;\n\n  vec3 c = p;\n  const float scale = 0.72;\n  const int max_iter = 8;\n  for (int i = 0; i < max_iter; ++i) {\n    p    = scale*abs(p)/L2(p) - scale;\n    p.yz = csqr(p.yz);\n    p    = p.zxy;\n    res  += exp(-2. * L2(p-c));\n  }\n\n  return res;\n}\n\nvec3 marble_march(vec3 ro, vec3 rd, float d, float dist, vec2 tminmax) {\n  float t   = tminmax.x;\n  float dt  = mix(1.0, 0.02, d);\n  vec3 col  = vec3(0.0);\n  float c   = 0.;\n  const int max_iter = 64;\n  for(int i = 0; i < max_iter; ++i) {\n      t += dt*exp(-2.0*c);\n      if(t>tminmax.y) { \n        break; \n      }\n      vec3 pos = ro+t*rd;\n        \n      c = marble_df(pos); \n      c *= 0.5;\n        \n      vec3 dcol = vec3(c*c*c-c*dist, c*c-c, c);\n      col = col + dcol;\n  }    \n  const float scale = 0.005;\n  float td = (t - tminmax.x)/(tminmax.y - tminmax.x);\n  col *= exp(-10.0*td);\n  col *= scale;\n  return col;\n}\n\nvec3 render1(vec3 ro, vec3 rd, float d) {\n  vec3 ipos = ro;\n  vec3 ird  = rd;\n  \n  float its4  = IRAYSHAPE(ipos, ird);\n  \n  float fi    = smoothstep(8.75, 10.0, TIME);\n\n  vec3 dpos = ipos;\n  dpos.x = abs(dpos.x);\n  float dm = mix(0.75, 1.1, (PCOS(-TIME*0.5+8.0*dpos.y))*fi);\n  float dist = 0.0;\n  dist += 0.5*mix(7.0, (length(dpos.xy-vec2(0.1, 0.055))-0.05)*30.0, dm);\n  dist += 0.5*mix(7.0, (length(dpos.xy-vec2(0.0, -0.025))-0.05)*20.0, dm);\n  \n  ipos.z -= mix(0.3, 0.0, fi);\n  ipos.z -= 0.0125*sin(ipos.y*5.0-TIME*sqrt(1.25));\n  ipos -= vec3(0.0, 0.2, mix(0.25, 0.0, d*d*d*d));\n  return marble_march(ipos, ird, d, dist, vec2(0.0, its4));\n}\n\nvec3 render(vec3 ro, vec3 rd) {\n  vec3 skyCol = skyColor(ro, rd);\n  vec3 col = vec3(0.0);\n\n  float t   = 1E6;\n  float ts4 = RAYSHAPE(ro, rd);\n  if (ts4 < miss) {\n    t = ts4;\n    vec3 pos  = ro + ts4*rd;\n    vec3 nor  = sphere4Normal(pos);\n    vec3 refr = refract(rd, nor, refrIndex);\n    vec3 refl = reflect(rd, nor);\n    vec3 rcol = skyColor(pos, refl);\n    float fre = mix(0.0, 1.0, pow(1.0-dot(-rd, nor), 4.0));\n\n    vec3 lv   = lightPos - pos;\n    float ll2 = L2(lv);\n    float ll  = sqrt(ll2);\n    vec3 ld   = lv / ll;\n\n    float dm  = min(1.0, 40.0/ll2);\n    float dif = pow(max(dot(nor,ld),0.0), 8.0)*dm;\n    float spe = pow(max(dot(reflect(-ld, nor), -rd), 0.), 100.);\n    float l   = dif;\n    \n    float d   = dot(rd, refr);\n    float lin = mix(0.0, 1.0, l);\n    const vec3 lcol = 2.0*sqrt(sunCol);\n    col = render1(pos, refr, d);\n    vec3 diff = hsv2rgb(vec3(0.7, fre, 0.075*lin))*lcol;\n    col += fre*rcol+diff+spe*lcol;\n    if (refr == vec3(0.0)) {\n      // Not expected to happen as the refraction index < 1.0\n      col = vec3(1.0, 0.0, 0.0);\n    }\n    \n  } else {\n    // Ray intersected sky\n    return skyCol;\n  }\n\n  return col;\n}\n\nvec3 effect(vec2 p, vec2 q) { \n  vec3 start  = 1.5*vec3(0.5, 0.5, -2.0);\n  vec3 end    = mix(0.4, 0.6, PCOS(TIME*0.1))*vec3(0.0, 0.2, -2.0);\n  float fi    = smoothstep(1.0, 10.0, TIME);\n  vec3 ro     = mix(start, end, fi);\n  ro.zy      *= ROT(0.1*sin(TIME*sqrt(0.05))*fi);\n  ro.xz      *= ROT(0.1*sin(TIME*sqrt(0.02))*fi);\n\n  vec3 ww = normalize(vec3(0.0, 0.0, 0.0) - ro);\n  vec3 uu = normalize(cross( vec3(0.0,1.0,0.0), ww));\n  vec3 vv = normalize(cross(ww,uu));\n  float rdd = 2.0+0.5*tanh_approx(length(p));\n  vec3 rd = normalize( p.x*uu + p.y*vv + rdd*ww);\n\n  vec3 col = render(ro, rd);\n  return col;\n}\n\nvec3 postProcess(vec3 col, vec2 q) {\n  col = clamp(col, 0.0, 1.0);\n  col = pow(col, vec3(1.0/2.2));\n  col = col*0.6+0.4*col*col*(3.0-2.0*col);\n  col = mix(col, vec3(dot(col, vec3(0.33))), -0.4);\n  col *=0.5+0.5*pow(19.0*q.x*q.y*(1.0-q.x)*(1.0-q.y),0.7);\n  return col;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  vec2 q = fragCoord/RESOLUTION.xy;\n  vec2 p = -1. + 2. * q;\n  p.x *= RESOLUTION.x/RESOLUTION.y;\n\n  vec3 col = effect(p, q);\n  col = postProcess(col, q);\n  col = mix(vec3(0.0), col, smoothstep(0.0, 3.0, TIME));\n\n  fragColor = vec4(col, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc0-1.0", "thumbnail": "https://www.shadertoy.com/media/shaders/sdSSzz.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "sdsXD2", "name": "Neon Wires", "author": "ninjapretzel", "description": "Experiment from a while ago.\n", "tags": ["neon"], "likes": 9, "viewed": 155, "date": "1619297051", "time_retrieved": "2024-06-20T20:38:54.245608", "image_code": "precision mediump float;\n#define PI 3.14159265359\n\nfloat _seed;\nfloat _scale;\nfloat _persistence;\n\n//1d Hash\nfloat hash(float n) { return fract(sin(n)*_seed); }\n//3d hash (uses 1d hash at prime scale offsets for y/z)\nfloat hash3(vec3 v) { return hash(v.x + v.y * 113.0 + v.z * 157.0); }\n//Quick 3d smooth noise\nfloat noise(vec3 x) {\n\tvec3 p = floor(x);\n\tvec3 f = fract(x);\n\tf       = f*f*(3.0-2.0*f);\n\tfloat n = p.x + p.y*157.0 + 113.0*p.z;\n\treturn mix(mix(\tmix( hash(n+0.0), hash(n+1.0),f.x),\n\t\t\tmix( hash(n+157.0), hash(n+158.0),f.x),f.y),\n\t\t   mix(\tmix( hash(n+113.0), hash(n+114.0),f.x),\n\t\t\tmix( hash(n+270.0), hash(n+271.0),f.x),f.y),f.z);\n}\n\nfloat nnoise(vec3 pos, float factor) {\t\n\tfloat total = 0.0\n\t\t, frequency = _scale\n\t\t, amplitude = 1.0\n\t\t, maxAmplitude = 0.0;\n\t\n\t//Accumulation\n\tfor (int i = 0; i < 6; i++) {\n\t\ttotal += noise(pos * frequency) * amplitude;\n\t\tfrequency *= 2.0, maxAmplitude += amplitude;\n\t\tamplitude *= _persistence;\n\t}\n\t\n\t//Normalization\n\tfloat avg = maxAmplitude * .5;\n\tif (factor != 0.0) {\n\t\tfloat range = avg * clamp(factor, 0.0, 1.0);\n\t\tfloat mmin = avg - range;\n\t\tfloat mmax = avg + range;\n\t\t\n\t\tfloat val = clamp(total, mmin, mmax);\n\t\treturn val = (val - mmin) / (mmax - mmin);\n\t} \n\t\n\tif (total > avg) { return 1.0; }\n\treturn 0.0;\n}\n//Default normalization factor of .5\n//This maps the range (.25,.75) to (0, 1)\nfloat nnoise(vec3 pos) { return nnoise(pos, .5); }\n\nfloat saturate(float v) { return clamp(v, 0., 1.); }\n#define ADD 1\n#define IGNORE 2\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    float time = iTime;\n    vec2 uv = fragCoord/iResolution.xy;\n    uv.y -= .9;\n    //uv.y *= .50;\n    uv.x -= .5;\n    uv.x *= .10;\n    \n    \n    float rate = 1.1;\n    float scale = 10.1;\n    \n\t_seed = 1333.0;\n\t_scale = 2.0;\n\t_persistence = .95;\n    \n    float dscale = 1.90;\n    \n\tfloat amp = 1.60 + .20 * nnoise(vec3(time*rate + uv.x*scale, time*.05, 0));\n\tint num = 9;\n\tvec4 cc = vec4(0,0,0,1);\n    float occ = 0.0; // near occludes far\n\tfor (int i = 0; i < num; i++) {\n\t\t\n        vec2 pos = uv;\n\t\tpos *= 5.0;\n        pos.y /= amp * 3.0;\n        pos.y += float(num-i) * .05;\n\t\tpos.x *= .10 * dscale;\n\t\tpos.x -= 35.0;\n\t\t\n\t    // wire position \n\t\tfloat v = noise(vec3(time*rate + pos.x * scale, pos.x * .05, 0.0)) - .5;\n        \n        _seed = 1337.0;\n        _scale = .65;\n        _persistence = .8 ;\n        v *= 3.0 * nnoise(vec3(time*rate + pos.x * scale, 0.0, 0.0)) - .5;\n        \n        float off = pos.y - v;\n        if (i == 0) { occ = off; }\n        \n        // Occlusion is incorrect, but the artifacts kinda look cool.\n        int mode = ADD;\n        if (off > occ) { mode = IGNORE; }\n        else { occ = off; }\n\n        float d = length(pos.y - v);\n\n        //d *= (16.0 + 14.50 * sin(-2. * time + float(i)/9.0*2.0*PI));\n        float elec = nnoise(vec3(time * -6. + pos.x * 16.50, .01 * pos.x, 1.0));\n        d *= .1 + 20.0 * elec * elec;\n\n        float r = .04 + .05 * sin(time + 2.0 * PI * ((float(i)+0.0)/9.0));\n        float g = .04 + .05 * sin(time + 2.0 * PI * ((float(i)+3.0)/9.0));\n        float b = .04 + .05 * sin(time + 2.0 * PI * ((float(i)+6.0)/9.0));\n        r = saturate(r); g = saturate(g); b = saturate(b);\n        if (mode == ADD) {\n            cc.r += r/d;\n            cc.g += g/d;\n            cc.b += b/d;\n        }\n        \n\t\tdscale *= 1.75;\n\t\t\n\t\tamp *= .62;\n\t}\n\tvec4 c = cc;//vec4(r/d, g/d, b/d, 1);\n\tfragColor = c;\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/sdsXD2.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "sdsXRB", "name": "testttt1233", "author": "wei", "description": "testttt1233", "tags": ["testttt1233"], "likes": 1, "viewed": 116, "date": "1618827229", "time_retrieved": "2024-06-20T20:38:54.245608", "image_code": "float circle(in vec2 _st, in float _radius){\n    if(_st.y<0.5) {\n        return 0.;\n    }\n    vec2 dist = _st-vec2(0.5);\n\treturn 1.-smoothstep(_radius-(_radius*0.01),\n                         _radius+(_radius*0.01),\n                         dot(dist,dist)*3.360);\n}\n\nfloat ring(in vec2 _st, in float _radius) {\n    return circle(_st,_radius)- circle(_st,_radius*0.8);\n}\n\nvec3 Rainbow(vec2 st) {\n    st = fract(st);\n\tfloat r = 0.28;\n\tfloat c1 = ring(st,r);\n    float c2 = ring(st,r*0.6);\n    float c3 = ring(st,r*0.6*0.6);\n    vec3 color = vec3(0.);\n    color += mix(color, vec3(1.000,0.185,0.499),c2);\n    color += mix(color, vec3(0.345,0.095,1.000),c3);\n\tcolor += mix(color, vec3(1.000,0.331,0.245),c1);\n    return color;\n}\n\nvec2 movingTiles(vec2 _st, float _zoom, float _speed){\n    _st *= _zoom;\n    float time = iTime*_speed;\n    if (fract( _st.y * 0.5) > 0.5){\n            _st.x += fract(time)*2.0;\n        } else {\n            _st.x -= fract(time)*2.0;\n        }\n    return fract(_st);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 st = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\n    st = movingTiles(st,4.,0.1);\n    vec3 col =vec3(0.);\n    vec3 rainbow = Rainbow(st);\n\tcol = rainbow;\n\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/sdsXRB.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "sdSXRz", "name": "A Quick Plasma algorithm", "author": "udovichenko", "description": "A simple plasma algorithm. Hello, World.", "tags": ["plasma"], "likes": 0, "viewed": 44, "date": "1619537866", "time_retrieved": "2024-06-20T20:38:54.512295", "image_code": "/*\n * This function will function like an array.\n */\nvec2 getWaveSource(int ws)\n{\n\tvec2 outp;\n\tif (ws == 0)\n\t{\n\t\toutp = vec2(-100,-100);\n\t}\n\telse if (ws == 1)\n\t{\n\t\toutp = vec2(-100,500);\n\t}\n\telse\n\t{\n\t\toutp = vec2(500,-500);\n\t}\n\treturn outp;\n}\n/*\n * Don't need an expensive square root operation.\n * This returns distance squared, not distance.\n */\nfloat distanceSq(vec2 a, vec2 b)\n{\n\tvec2 diff = a - b;\n\treturn dot(diff, diff);\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tconst int wsCount = 3;\n\t\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\t\n\tfloat wavePower = 0.0;\n\tfor(int i=0; i<wsCount; i++)\n\t{\n\t\tvec2 src = getWaveSource(i);\n\t\tfloat dist = distanceSq(src, uv) / 300.0;\n\t\twavePower += sin((dist + iTime));\n\t\t\n\t}\n\tfragColor = vec4(\n\t\t0.5 + 0.5 * sin(wavePower),\n\t\t0.5 + 0.5 * cos(wavePower),\n\t\t0.5 + 0.5 * sin(iTime),\n\t\t1.0\n\t);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/sdSXRz.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "sdsXW2", "name": "Orthonormal Basis - Aᵀ = A^-1", "author": "oneshade", "description": "The inverse of an orthonormal basis is alsoits tranpose which is much cheaper because it is just all the elements flipped diagonally.", "tags": ["inverse", "orthonormal", "basis", "transpose"], "likes": 4, "viewed": 54, "date": "1619289798", "time_retrieved": "2024-06-20T20:38:54.518146", "image_code": "// Drawing utilities\n#define drawSDF(dist, col) color = mix(color, col, smoothstep(unit, 0.0, dist))\n\n// SDFs\nfloat sdIsosceles(in vec2 p, in float b, in float h) {\n    p.x = abs(p.x);\n    float q = clamp((b - p.x + p.y) / (b + h), 0.0, 1.0);\n    vec2 re = vec2(p.x - b + b * q, p.y - h * q);\n    vec2 be = vec2(p.x - b * min(p.x / b, 1.0), p.y);\n    return sqrt(min(dot(re, re), dot(be, be))) * sign(p.x + (p.y - h) * b / h * sign(p.y));\n}\n\nfloat sdVerticalLine(in vec2 p, in float h) {\n    return length(vec2(p.x, p.y - h * clamp(p.y / h, 0.0, 1.0)));\n}\n\nfloat sdInfLine(in vec2 p, in vec2 a, in vec2 b) {\n    return abs(dot(p - a, normalize(b - a).yx * vec2(-1.0, 1.0)));\n}\n\nfloat sdVectorArrow(in vec2 p, in vec2 v) {\n    float m = length(v); vec2 n = v / m;\n    p = vec2(dot(p, n.yx * vec2(1.0, -1.0)), dot(p, n));\n    return min(sdVerticalLine(p, m) - 0.025, sdIsosceles(p - vec2(0.0, m), 0.1, 0.15));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 center = 0.5 * iResolution.xy;\n    vec4 mouse = (vec4(iMouse.xy, abs(iMouse.zw)) - center.xyxy) / iResolution.y * 4.0;\n    vec2 uv = (fragCoord - center) / iResolution.y * 4.0;\n    vec3 color = vec3(0.0);\n    float unit = 8.0 / iResolution.y;\n\n    vec2 right = vec2(cos(iTime), sin(iTime));\n    mat2 mat = mat2(right, -right.y, right.x);\n    drawSDF(sdVectorArrow(uv, mat[0]), vec3(1.0, 0.0, 0.0));\n    drawSDF(sdVectorArrow(uv, mat[1]), vec3(0.0, 1.0, 0.0));\n\n    mat2 inv = inverse(mat);\n    drawSDF(sdVectorArrow(uv, inv[0]), vec3(1.0, 1.0, 0.0));\n    drawSDF(sdVectorArrow(uv, inv[1]), vec3(0.0, 1.0, 1.0));\n\n    inv = transpose(mat);\n    drawSDF(sdVectorArrow(uv, inv[0]), vec3(1.0, 1.0, 0.0));\n    drawSDF(sdVectorArrow(uv, inv[1]), vec3(0.0, 1.0, 1.0));\n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/sdsXW2.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "sdsXWs", "name": "Orbital 2D", "author": "milesWaugh", "description": "A little experiment for fun. Blue --> orange gradient is where the wave-function is positive, purple --> green gradient is where the wave-function is negative.", "tags": ["quantum", "wavefunction", "orbtial"], "likes": 6, "viewed": 199, "date": "1619486819", "time_retrieved": "2024-06-20T20:38:54.827595", "image_code": "/*Disclaimer: while the program smoothly transitions between two \nstates who's wave function's frequency is an integer multiple \ntimes the electrons' frequency, there would be no smooth transition \nin real life. In real life, the states would instantaneously switch.\nThe program switches smoothly for aesthetic purposes. \n\nThe blue --> orange gradient is where the wavefunction is positive,\nthe purple --> green gradient is where the wavefunction is negative.\nThe blue and purple colors represent low probability of the \nwavefunction collapsing to that specific position apon observation.\nThe orange and green colors represent a high probability (of what\nI just mentioned, no need to repeat).\n*/\n\nfloat pi = 3.141592653589793;\nfloat sq2 = sqrt(2.);\nfloat transitionSpeed = 60.; //Higher is faster\n\nfloat sw(float x, float s){\n    return(atan(s*sin(pi*x)))/(.5*pi);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n    vec3 col = vec3(0.);\n    float contour = 0.1;\n    int AA = 4; //Default value is 4x4 anti-aliasing\n    float AAA = float(AA*AA);\n    for(int i=0; i<AA; i++){\n    for(int j=0; j<AA; j++){\n        vec2 uv = (fragCoord+vec2(i,j)/float(AA)-iResolution.xy/2.)/iResolution.y;\n        uv*=7.;\n        float a = atan(uv.y/uv.x)-(uv.x<0.?pi:0.);\n        a+=a<0.?2.*pi:0.;\n        float d = sqrt(dot(uv,uv));\n        float mu = sw(iTime/4.,transitionSpeed);\n        mu = mu/2.+.5;\n        float rot =  iTime/5.;\n        rot *= mu/10.+1.;\n        float w1 = cos(2.*a+rot)*exp(-d)*d*2.5;\n        float w2 = cos(a+rot)*exp(-d)*d*2.5;\n        float w = mu*w1+w2*(1.-mu);\n        float p = w*w;\n        p = max(min(p,1.),0.);\n        if(w<0.){\n            col += vec3(p,(-cos(pi*(p))/2.+.5),(1.-(acos(2.*p-1.))/pi))/AAA;\n        }else{\n            col += vec3((-cos(pi*(p))/2.+.5),p,(1.-(acos(2.*p-1.))/pi))/AAA;\n        }\n        float er = sin(pi*(p*10.-floor(p*10.)));\n        er-=p<1./20.?5.:0.;\n        er = (0.01)/(er*er);\n        col += vec3(min(er/AAA,1./AAA), min(0.7*er/AAA,1./AAA), min(0.6*er/AAA,1./AAA))/2.;\n    }}\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/sdsXWs.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "sdsXzB", "name": "noise balanced isolines - subdiv", "author": "FabriceNeyret2", "description": "Bottom: noise isovalues are not equidistant.\nTop: produce isolines by adding intermediate isovalues depending on slope.", "tags": ["procedural", "noise", "perlin"], "likes": 3, "viewed": 154, "date": "1618832181", "time_retrieved": "2024-06-20T20:38:55.130532", "image_code": "// Fork of \"test1: Noise balance\"           https://shadertoy.com/view/ssXXWN\n\n\n#define keyToggle(a) ( texelFetch(iChannel3,ivec2(a,2),0).x > 0.)\n#define hash(p )     ( 2.* fract(sin((p)*mat2(127.1,311.7, 269.5,183.3)) *43758.5453123) - 1. )\n#define draw(v,d)      clamp(1. - abs( fract(v) - .5 ) / fwidth(d), 0.,1.)\n#define hue(v)       ( .6 + .6 * cos( 6.3*(v)  + vec4(0,23,21,0)  ) )\n\n#define func( P )    ( mod(iTime,4.) > 2. ? perlin( .5*(P) ) : noise( P ) )\n//#define func( P )  ( keyToggle(32) ? perlin( .5*(P) ) : noise( P ) )\n#define grad(x,y)      dot( hash( i+vec2(x,y) ), f-vec2(x,y) )\n\nfloat noise( vec2 p )\n{\n    vec2 i = floor(p), f = fract(p), // u = f*f*(3.-2.*f);              // = smoothstep\n                                        u = f*f*f*( 10. +f*(6.*f-15.)); // better with derivatives\n    return mix( mix( grad(0,0), grad(1,0), u.x),\n                mix( grad(0,1), grad(1,1), u.x), u.y);\n}\n\nfloat perlin( vec2 U ) { // inspired from https://www.shadertoy.com/view/XdXGW8\n    float v = 0., s = .5;\n    mat2 m = mat2( 1.6,  1.2, -1.2,  1.6 );\n    for( int i=0; i<3; i++, s/=2., U*=m )\n        v  += s * noise( U ); \n    return v;\n}\n\nvoid mainImage( out vec4 O, vec2 u )\n{\n    vec2 R = iResolution.xy, eps = vec2(1e-3,0),\n         U = u / R.y,\n         P = 8.*U - vec2(0.,.5*iTime);\t\n    O-=O;\n\tfloat l, f = func(P), df;\n    if ( int(u.y) == int(R.y*.4) ) { O.r++; return; } // red separator\n    if ( U.y > .4 ) {\n     // l = exp2(floor(log2(2.*fwidth(P.x)/fwidth(f))));     // subvid amount (relative)\n        l = exp2(floor(log2(1./22./fwidth(f))));             // subvid amount (absolute)\n        O = vec4(.5+.5*sin(50.*l*f)); return; \n       df = fwidth(f);\n    // df = length( ( vec2( func(P + eps.xy), func(P + eps.yx) ) -f ) / eps.x )*fwidth(P.x);\n        l*=6.3; O += clamp(1. - .8*abs( fract(f*l) - .5 ) / df/l, 0.,1.); return; \n    } \n    else  f*=8.;\n    O += draw(f,f);                                               // draw isolines\n    O = sqrt(O);                                                  // to sRGB\n\n}", "image_inputs": [{"id": "4dXGRr", "previewfilepath": "/presets/tex00.jpg", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/presets/tex00.jpg", "ctype": "keyboard"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/sdsXzB.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "sdsXzH", "name": "Sierpiński Carpet Threads", "author": "adamjmurray", "description": "Sierpiński Carpet with movement, this time zooming. \n\nSee also: https://www.shadertoy.com/view/sssSRj", "tags": ["tiles"], "likes": 2, "viewed": 58, "date": "1618901803", "time_retrieved": "2024-06-20T20:38:55.609354", "image_code": "bool aa = true; // antialiased, disable for better performance\n\nvec3 palette(float idx) {\n    float i = mod(idx,4.);\n    if      (i < 1.) return vec3(0.80,0.78,0.99); \n    else if (i < 2.) return vec3(0.71,0.93,0.80);\n    else if (i < 3.) return vec3(0.99,0.93,0.65);  \n    else             return vec3(1.00,0.70,0.65); \n}\n\nvec3 draw(vec2 p, float start, float end, float iterations) \n{    \n    float iter = min(20., iterations);\n    float len = end - start;\n    float x = p.x - start;\n    float y = p.y - start;\n    float thresh = 0.005;\n    // for added fun:\n    // thresh = 0.3 + 0.25*-cos(iTime/5.);\n    \n    float pct = 0.;\n    float i;\n    for(i=0.; i<iter+1.; i++) {\n        len /= 3.;       \n        float xd = mod(x/len-1.,3.);\n        float yd = mod(y/len-1.,3.);\n        if (xd < 1. && yd < 1.) {\n            pct = (smoothstep(0.,thresh,xd) - smoothstep(1.-thresh,1.,xd))\n                * (smoothstep(0.,thresh,yd) - smoothstep(1.-thresh,1.,yd));\n            if (i>iter) {\n                pct *= (1.-(i-iter)); // fade in partial iterations\n            }\n            break;\n        }       \n    }\n    \n    vec3 color = palette(i);\n    // alternately, an algorithmic palette (needs some work):\n    // color = vec3(-cos(i)/3. + 0.34, -sin(i*3.)/2.+0.5, sin(i)/2.+0.5);\n    \n    return mix(vec3(0,0,0), color, pct);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) \n{\n    float speed = 0.25;\n    float zRange = 0.92;\n    float zMin = 0.025;\n    float z = (1.+cos(iTime*speed))/2. * zRange + zMin;\n    // for testing formulas at the edges of the zoom range:\n    // z = zRange + zMin;\n    // z = zMin;\n    \n    float zoom = 5.*(pow(z,3.));\n    vec2 offset = vec2(0.5,0.3);\n    vec3 color = vec3(0,0,0);\n    float samples = 0.;\n    \n    float sampStart = 0.;\n    float sampEnd = 0.1;\n    if (aa) {\n        sampStart = -0.33;\n        sampEnd = 0.34;\n    }    \n    \n    for (float x=sampStart; x<sampEnd; x+=0.33) {\n        for (float y=sampStart; y<sampEnd; y+=0.33) {\n            vec2 p = (2.*(fragCoord + vec2(x,y)) - iResolution.xy)/iResolution.y; // [-1,1] vertically    \n            p *= zoom;\n            p += offset;\n            \n            // Aliasing is horrible when hard-coding iteration values > ~10 (depending on resolution)\n            // We need to adjust the iterations depending on the resolution, zoom factor, and antialias setting:\n            float iterations = 16.-(12.25+1000./(iResolution.x))*pow(z-zMin,0.25) - (aa ? 0. : 0.5);\n            \n            color += draw(p, -1., 1., iterations);\n            samples++;\n        }\n    }\n    \n    fragColor = vec4(color/samples,1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/sdsXzH.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "sdsXzS", "name": "Pentakis Dodecahedron", "author": "dr2", "description": "Pentakis dodecahedra (60 triangular faces): solid surrounded by sphericalized shell edges.", "tags": ["symmetry", "polyhedron"], "likes": 14, "viewed": 196, "date": "1618821594", "time_retrieved": "2024-06-20T20:38:55.622130", "image_code": "// \"Pentakis Dodecahedron\" by dr2 - 2021\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\nfloat SmoothMax (float a, float b, float r);\nmat3 StdVuMat (float el, float az);\nvec2 Rot2D (vec2 q, float a);\nvec2 Rot2Cs (vec2 q, vec2 cs);\nfloat Fbm2 (vec2 p);\n\nvec3 ltDir;\nfloat tCur, dstFar, rEx, rIn;\nint idObj;\nconst float pi = 3.1415927;\n\n#define VAR_ZERO min (iFrame, 0)\n\n#define DMIN(id) if (d < dMin) { dMin = d;  idObj = id; }\n\nvec3 DodecSym (vec3 p)\n{   // (from \"Chinese Puzzle Balls 2\")\n  vec2 csD;\n  csD = sin (0.5 * atan (2.) + vec2 (0.5 * pi, 0.));\n  p.xz = Rot2Cs (vec2 (p.x, abs (p.z)), csD);\n  p.xy = Rot2D (p.xy, - 0.1 * pi);\n  p.x = - abs (p.x);\n  for (int k = VAR_ZERO; k <= 3; k ++) {\n    p.zy = Rot2Cs (p.zy, vec2 (csD.x, - csD.y));\n    p.y = - abs (p.y);\n    p.zy = Rot2Cs (p.zy, csD);\n    if (k < 3) p.xy = Rot2Cs (p.xy, sin (-2. * pi / 5. + vec2 (0.5 * pi, 0.)));\n  }\n  p.xy = sin (mod (atan (p.x, p.y) + pi / 5., 2. * pi / 5.) - pi / 5. +\n     vec2 (0., 0.5 * pi)) * length (p.xy);\n  p.xz = - vec2 (abs (p.x), p.z);\n  return p;\n}\n\nfloat ObjDf (vec3 p)\n{\n  vec3 q;\n  float dMin, d, a1, a2;\n  dMin = dstFar;\n  q = DodecSym (p);\n  a1 = 0.5 * acos (- 1. / sqrt (5.));\n  a2 = 0.5 * acos (- (80. + 9. * sqrt (5.)) / 109.);\n  d = abs (length (q) - rEx) - 0.1;\n  d = SmoothMax (d, min (dot (q.yz, sin (a1 - pi + vec2 (0., 0.5 * pi))),\n     dot (q.xy, sin (pi / 5. + vec2 (0.5 * pi, 0.)))) - 0.06, 0.04);\n  DMIN (1);\n  d = - dot (q.yz, sin (a1 - a2 + vec2 (0., 0.5 * pi))) - rIn;\n  DMIN (2);\n  return dMin;\n}\n\nfloat ObjRay (vec3 ro, vec3 rd)\n{\n  float dHit, d;\n  dHit = 0.;\n  for (int j = VAR_ZERO; j < 120; j ++) {\n    d = ObjDf (ro + dHit * rd);\n    if (d < 0.001 || dHit > dstFar) break;\n    dHit += d;\n  }\n  return dHit;\n}\n\nvec3 ObjNf (vec3 p)\n{\n  vec4 v;\n  vec2 e;\n  e = vec2 (0.0005, -0.0005);\n  for (int j = VAR_ZERO; j < 4; j ++) {\n    v[j] = ObjDf (p + ((j < 2) ? ((j == 0) ? e.xxx : e.xyy) : ((j == 2) ? e.yxy : e.yyx)));\n  }\n  v.x = - v.x;\n  return normalize (2. * v.yzw - dot (v, vec4 (1.)));\n}\n\nfloat ObjSShadow (vec3 ro, vec3 rd)\n{\n  float sh, d, h;\n  sh = 1.;\n  d = 0.01;\n  for (int j = VAR_ZERO; j < 40; j ++) {\n    h = ObjDf (ro + d * rd);\n    sh = min (sh, smoothstep (0., 0.05 * d, h));\n    d += h;\n    if (sh < 0.05) break;\n  }\n  return 0.5 + 0.5 * sh;\n}\n\nvec4 SphHit (vec3 ro, vec3 rd, float rad)\n{\n  vec3 vn;\n  float b, d, w;\n  b = dot (rd, ro);\n  w = b * b + rad * rad - dot (ro, ro);\n  d = dstFar;\n  if (w > 0.) {\n    d = - b - sqrt (w);\n    vn = (ro + d * rd) / rad;\n  }\n  return vec4 (d, vn);\n}\n\nvec3 BgCol (vec3 rd)\n{\n  vec3 col;\n  vec2 u;\n  float el, f;\n  el = asin (rd.y);\n  u = vec2 (atan (rd.z, - rd.x) + pi, tan (2. * atan (0.5 * el))) / (2. * pi);\n  f = 64.;\n  col = mix (vec3 (0.1, 0.2, 0.4), vec3 (0.8), mix (Fbm2 (f * u),\n     Fbm2 (f * (u - vec2 (1., 0.))), u.x));\n  col = mix (col, vec3 (0.2, 0.3, 0.4), smoothstep (0.95, 0.98, abs (el) / (0.5 * pi)));\n  return col;\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  vec4 col4, ds4;\n  vec3 col, vn, roo;\n  float dstObj, nDotL, sh;\n  rEx = 2.;\n  rIn = 0.8 + 0.4 * sin (tCur);\n  roo = ro;\n  dstObj = ObjRay (ro, rd);\n  if (dstObj < dstFar) {\n    ro += dstObj * rd;\n    vn = ObjNf (ro);\n    if (idObj == 1) col4 = vec4 (1., 0.8, 0.2, 0.2) * (0.95 + 0.05 * sin (32. * pi * length (ro)));\n    else if (idObj == 2) col4 = vec4 (0.8, 1., 0.2, 0.3);\n    sh = ObjSShadow (ro + 0.01 * vn, ltDir);\n    nDotL = max (dot (vn, ltDir), 0.);\n    col = col4.rgb * (0.2 + 0.8 * sh * nDotL * nDotL) +\n       col4.a * step (0.95, sh) * pow (max (0., dot (ltDir, reflect (rd, vn))), 32.);\n  } else {\n    col = BgCol (rd);\n  }\n  ds4 = SphHit (roo, rd, rEx + 0.06);\n  if (ds4.x < min (dstObj, dstFar)) {\n    vn = ds4.yzw;\n    col = mix (col * vec3 (0.9, 1., 0.9), BgCol (reflect (rd, vn)),\n       0.1 + 0.9 * pow (1. - max (- dot (rd, vn), 0.), 5.));\n  }\n  return clamp (col, 0., 1.);\n}\n\n#define AA  1   // optional antialiasing\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  mat3 vuMat;\n  vec4 mPtr;\n  vec3 ro, rd, col;\n  vec2 canvas, uv;\n  float el, az, zmFac, sr;\n  canvas = iResolution.xy;\n  uv = 2. * fragCoord.xy / canvas - 1.;\n  uv.x *= canvas.x / canvas.y;\n  tCur = iTime;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / canvas - 0.5;\n  az = 0.;\n  el = 0.1 * pi;\n  if (mPtr.z > 0.) {\n    az += 2. * pi * mPtr.x;\n    el += pi * mPtr.y;\n  } else {\n    az -= 0.03 * pi * tCur;\n    el -= 0.15 * pi * sin (0.01 * pi * tCur);\n  }\n  vuMat = StdVuMat (el, az);\n  ro = vuMat * vec3 (0., 0., -12.);\n  zmFac = 5.2;\n  dstFar = 100.;\n  ltDir = vuMat * normalize (vec3 (1., 1., -1.));\n#if ! AA\n  const float naa = 1.;\n#else\n  const float naa = 3.;\n#endif  \n  col = vec3 (0.);\n  sr = 2. * mod (dot (mod (floor (0.5 * (uv + 1.) * canvas), 2.), vec2 (1.)), 2.) - 1.;\n  for (float a = float (VAR_ZERO); a < naa; a ++) {\n    rd = vuMat * normalize (vec3 (uv + step (1.5, naa) * Rot2D (vec2 (0.5 / canvas.y, 0.),\n       sr * (0.667 * a + 0.5) * pi), zmFac));\n    col += (1. / naa) * ShowScene (ro, rd);\n  }\n  fragColor = vec4 (col, 1.);\n}\n\nvec2 Rot2Cs (vec2 q, vec2 cs)\n{\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nfloat SmoothMin (float a, float b, float r)\n{\n  float h;\n  h = clamp (0.5 + 0.5 * (b - a) / r, 0., 1.);\n  return mix (b, a, h) - r * h * (1. - h);\n}\n\nfloat SmoothMax (float a, float b, float r)\n{\n  return - SmoothMin (- a, - b, r);\n}\n\nmat3 StdVuMat (float el, float az)\n{\n  vec2 ori, ca, sa;\n  ori = vec2 (el, az);\n  ca = cos (ori);\n  sa = sin (ori);\n  return mat3 (ca.y, 0., - sa.y, 0., 1., 0., sa.y, 0., ca.y) *\n         mat3 (1., 0., 0., 0., ca.x, - sa.x, 0., sa.x, ca.x);\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  vec2 cs;\n  cs = sin (a + vec2 (0.5 * pi, 0.));\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nconst float cHashM = 43758.54;\n\nvec2 Hashv2v2 (vec2 p)\n{\n  vec2 cHashVA2 = vec2 (37., 39.);\n  return fract (sin (dot (p, cHashVA2) + vec2 (0., cHashVA2.x)) * cHashM);\n}\n\nfloat Noisefv2 (vec2 p)\n{\n  vec2 t, ip, fp;\n  ip = floor (p);  \n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = mix (Hashv2v2 (ip), Hashv2v2 (ip + vec2 (0., 1.)), fp.y);\n  return mix (t.x, t.y, fp.x);\n}\n\nfloat Fbm2 (vec2 p)\n{\n  float f, a;\n  f = 0.;\n  a = 1.;\n  for (int i = 0; i < 5; i ++) {\n    f += a * Noisefv2 (p);\n    a *= 0.5;\n    p *= 2.;\n  }\n  return f * (1. / 1.9375);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc-by-nc-sa-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/sdsXzS.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "sdXSRM", "name": "Northern Stream, Maybe Clean", "author": "TEttinger", "description": "There's an awful lot of bright colors for a river, but it does look like dyes flowing through water somewhat. Part of my Northern Lights series, with some updates.", "tags": ["noise", "plasma", "water", "lights", "stream", "northern"], "likes": 1, "viewed": 162, "date": "1618387476", "time_retrieved": "2024-06-20T20:38:55.894226", "image_code": "// CC0 licensed, do what thou wilt.\nconst float SEED = 42.0;\n\n// UE4 PseudoRandom function\nfloat pseudo(vec2 v) {\n    v = v + vec2(-64.340622, -72.465622);\n    return sin(dot(v.xyx * v.xyy, vec3(20.390625, 60.703125, 2.4281209)));\n}\n\nfloat swayRandomized(float seed, float value)\n{\n    float f = floor(value);\n    float start = pseudo(vec2(seed, f));\n    float end   = pseudo(vec2(seed, f+1.0));\n    return mix(start, end, smoothstep(0., 1., value - f));\n}\n\nvec3 cosmic(float seed, vec3 con)\n{\n    con.x += swayRandomized(seed, con.z + con.x);\n    con.y += swayRandomized(seed, con.x + con.y);\n    con.z += swayRandomized(seed, con.y + con.z);\n    return con * 0.5;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = 8.0 * fragCoord/iResolution.xy;\n    // aTime, s, and c could be uniforms in some engines.\n    float aTime = iTime * 0.225;\n    vec3 s = vec3(swayRandomized(-164.0531527, aTime - 1.11),\n                  swayRandomized(-776.648142, aTime + 1.41),\n                  swayRandomized(-509.935190, aTime + 1.61));\n    vec3 c = vec3(swayRandomized(-105.2792407, aTime - 1.11),\n                  swayRandomized(-615.576687, aTime + 1.41),\n                  swayRandomized(-435.278990, aTime + 1.61));\n    vec3 con = vec3(0.0004375, 0.0005625, 0.0008125) * aTime + c * uv.x + s * uv.y;\n    con = cosmic(SEED, con);\n    con = cosmic(SEED, con);\n    con = cosmic(SEED, con);\n    \n    fragColor = vec4(sin(con * 3.14159265) * 0.5 + 0.5,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/sdXSRM.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "sdXSW8", "name": "Bezier Scribbles", "author": "oneshade", "description": "Scribble made out of quadratic beziers.", "tags": ["bezier", "random", "spline", "curve", "quadratic", "path", "scribbles"], "likes": 7, "viewed": 94, "date": "1618536105", "time_retrieved": "2024-06-20T20:38:56.360985", "image_code": "// Based on a quick doodle I did on desmos:\n// https://www.desmos.com/calculator/mbtrtwqbwb\n\nfloat dot2(in vec2 v) { return dot(v, v); }\nfloat sdBezier(in vec2 p, in vec2 v1, in vec2 v2, in vec2 v3) {\n    vec2 c1 = p - v1;\n    vec2 c2 = 2.0 * v2 - v3 - v1;\n    vec2 c3 = v1 - v2;\n\n    float t3 = dot(c2, c2);\n    float t2 = dot(c3, c2) * 3.0 / t3;\n    float t1 = (dot(c1, c2) + 2.0 * dot(c3, c3)) / t3;\n    float t0 = dot(c1, c3) / t3;\n\n    float t22 = t2 * t2;\n    vec2 pq = vec2(t1 - t22 / 3.0, t22 * t2 / 13.5 - t2 * t1 / 3.0 + t0);\n    float ppp = pq.x * pq.x * pq.x, qq = pq.y * pq.y;\n\n    float p2 = abs(pq.x);\n    float r1 = 1.5 / pq.x * pq.y;\n\n    if (qq * 0.25 + ppp / 27.0 > 0.0) {\n        float r2 = r1 * sqrt(3.0 / p2), root;\n        if (pq.x < 0.0) root = sign(pq.y) * cosh(acosh(r2 * -sign(pq.y)) / 3.0);\n        else root = sinh(asinh(r2) / 3.0);\n        root = clamp(-2.0 * sqrt(p2 / 3.0) * root - t2 / 3.0, 0.0, 1.0);\n        return length(p - mix(mix(v1, v2, root), mix(v2, v3, root), root));\n    }\n\n    else {\n        float ac = acos(r1 * sqrt(-3.0 / pq.x)) / 3.0;\n        vec2 roots = clamp(2.0 * sqrt(-pq.x / 3.0) * cos(vec2(ac, ac - 4.18879020479)) - t2 / 3.0, 0.0, 1.0);\n        vec2 p1 = p - mix(mix(v1, v2, roots.x), mix(v2, v3, roots.x), roots.x);\n        vec2 p2 = p - mix(mix(v1, v2, roots.y), mix(v2, v3, roots.y), roots.y);\n        return sqrt(min(dot(p1, p1), dot(p2, p2)));\n    }\n}\n\nfloat sdLine(in vec2 p, in vec2 a, in vec2 b) {\n    vec2 pa = p - a, ba = b - a;\n    return length(pa - ba * clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0));\n}\n\n// Modified hash from \"Hash without Sine\" by Dave_Hoskins (https://www.shadcrtoy.com/view/4djSRW)\nvec2 Hash12(in float x) {\n\tvec3 p3 = fract(x * vec3(0.1031, 0.1030, 0.0973));\n\tp3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.xx + p3.yz) * p3.zy) * 2.0 - 1.0;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 center = 0.5 * iResolution.xy;\n    vec2 uv = (fragCoord - center) / iResolution.y * 2.0;\n    vec2 mouse = (iMouse.xy - center) / iResolution.y;\n\n    float dc = 1000000000000.0, dp = dc, de = dc;\n    float par = fract(iTime), sec = floor(iTime);\n    for (float v=sec; v < sec + 10.0; v++) {\n        vec2 v1 = Hash12(v), v2 = Hash12(v + 1.0), v3 = Hash12(v + 2.0);\n        vec2 a = mix(v1, v2, par), b = mix(v2, v3, par), c = mix(v3, Hash12(v + 3.0), par);\n        dc = min(dc, sdBezier(uv, 0.5 * (a + b), b, 0.5 * (b + c)));\n\n        de = min(de, sdLine(uv, a, b));\n        de = min(de, sdLine(uv, b, c));\n\n        dp = min(dp, dot2(uv - a));\n        dp = min(dp, dot2(uv - b));\n        dp = min(dp, dot2(uv - c));\n    }\n\n    vec3 color = vec3(0.0);\n\n    color = mix(color, vec3(1.0, 0.8, 0.0), 1.0 - smoothstep(0.0, 0.015, de - 0.0025));\n    color = mix(color, vec3(1.0, 0.0, 0.0), 1.0 - smoothstep(0.0, 0.015, sqrt(dp) - 0.02));\n    color = mix(color, vec3(1.0), 1.0 - smoothstep(0.0, 0.015, dc - 0.01));\n\n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/sdXSW8.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "sdXSWr", "name": "Mandelbrot 0002", "author": "larrytheking", "description": "Simple mandelbrot with zoom", "tags": ["mandelbrot"], "likes": 0, "viewed": 51, "date": "1618475869", "time_retrieved": "2024-06-20T20:38:56.360985", "image_code": "const int   c_MaxIterations = 256;\nconst float c_Threshold = 10000.0;\n\nconst vec2  c_ZoomTarget = vec2(0.2134,0.6899);\nconst float c_ZoomRange[2] = float[2](0.5, 10000.0);\n\nconst vec3  c_Gradient[2] = vec3[2](vec3(0.8, 0.9, 1.0), vec3(0, 0, 0.1));\n\nvec2 complexSquare(in vec2 c)\n{\n    return vec2(c.x * c.x - c.y * c.y, 2.0 * c.x * c.y);\n}\n\nint Mandelbrot(in vec2 c, in float threshold, in int maxIterations, out vec2 z)\n{\n    int iteration = 0;\n    z = vec2(0, 0);\n\n    do {\n        z = complexSquare(z) + c;\n    } while(++iteration < maxIterations && length(z) < threshold);\n\n    return iteration;\n}\n\nvec3 ColorizeIteration(in int iteration, in int maxIterations)\n{\n    float alpha = 1.0 - float(iteration) / float(maxIterations);\n  \n    vec3 color = mix(c_Gradient[0], c_Gradient[1], alpha * alpha * alpha);\n    \n    return color;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.y;\n    \n    float alpha = 0.5 + 0.5 * sin(0.25 * iTime);\n    \n    float zoom = mix(c_ZoomRange[0], c_ZoomRange[1], alpha * alpha * alpha);\n    \n    vec2 x = (uv - 0.5) / zoom - c_ZoomTarget;\n\n    vec2 z;\n    int iteration = Mandelbrot(x, c_Threshold, c_MaxIterations, z);\n\n    vec3 col = ColorizeIteration(iteration, c_MaxIterations);\n        \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/sdXSWr.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "sdXXRl", "name": "Bit Carpet 1", "author": "metabog", "description": "Trying out a cool xor-ing pattern I saw on twitter", "tags": ["generative", "xor", "scrolling"], "likes": 2, "viewed": 146, "date": "1619030743", "time_retrieved": "2024-06-20T20:38:56.360985", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 xy = floor(fragCoord/4.0 + iTime*8.0);\n    vec3 col = 1.0f - vec3(float((int(xy.x)^int(xy.y))%5));\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/sdXXRl.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "sdXXWB", "name": "Alien technology 2", "author": "jarble", "description": "This seems to be some kind of spacecraft.", "tags": ["fractal", "metal", "shiny", "circuit", "machine"], "likes": 0, "viewed": 124, "date": "1619132971", "time_retrieved": "2024-06-20T20:38:56.567115", "image_code": "\n//Try changing this parameter to get more crazy patterns!\n\n\n#define ITERS 12\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.0);\n    vec3 col=vec3(0.0),col_prev=vec3(0.0);\n    float t=0.0;\n    vec2 uv = (fragCoord*10.0-iResolution.xy)/iResolution.y/20.0;\n    uv.y += (iTime)/25.0;\n    float s1 = .85;\n    for(int c=0;c<ITERS;c++){\n        float scale = 2.16;\n        float scale1 = 1.14;\n        col_prev = col;\n        \n        for(int i=0;i<ITERS;i++)\n        {\n            s1 = s1 - col.x/64.0;\n            uv= fract(-uv-((vec2(uv.x/scale-uv.y/scale1,uv.y/scale-uv.x/scale1)/(scale))))/scale1;\n            uv.x *= scale1/s1;\n            uv = fract(-uv.yx);\n            uv.y /= -scale1/s1;\n        }\n        col[2] = abs(fract(uv.y)-fract(uv.x));\n        col = ((col+col_prev.yzx))/2.125;\n\t}\n    fragColor = vec4(vec3(col*3.0),1.0);\n    \n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/sdXXWB.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "sdXXzN", "name": "HSL regions", "author": "jonathanw12", "description": "Determines which colours are part of a region in HSL", "tags": ["hsl"], "likes": 0, "viewed": 20, "date": "1618330428", "time_retrieved": "2024-06-20T20:38:57.130474", "image_code": "#ifdef GL_ES\nprecision mediump float;\n#endif\n\n#define TWO_PI 6.28318530718\n#define DEFAULT_HUE 0.5\n#define CHECKERBOARD_OPACITY 0.7\n#define HEIGHT 0.9\n#define GAP_ONE 0.23\n#define GAP_TWO 0.2\n#define BAR_WIDTH 0.05\n#define BLUR 0.03\n\nuniform vec2 u_resolution;\nuniform float u_time;\n\nfloat hue2rgb(float f1, float f2, float hue) {\n    if (hue < 0.0)\n        hue += 1.0;\n    else if (hue > 1.0)\n        hue -= 1.0;\n    float res;\n    if ((6.0 * hue) < 1.0)\n        res = f1 + (f2 - f1) * 6.0 * hue;\n    else if ((2.0 * hue) < 1.0)\n        res = f2;\n    else if ((3.0 * hue) < 2.0)\n        res = f1 + (f2 - f1) * ((2.0 / 3.0) - hue) * 6.0;\n    else\n        res = f1;\n    return res;\n}\n\nbool shouldApplyCheckerboard(vec3 hsl) {    \n    if (hsl.y < 0.25) {\n        return true;\n    }\n    \n    if (hsl.x > 0.75 || hsl.x < 0.4) {\n        return true;\n    }\n    \n    if (hsl.z < 0.35) {\n        return true;\n    }\n    \n    return false;\n}\n\nvec3 hsl2rgb(vec3 oldHsl, vec3 checkerboard) { \n    vec3 rgb;\n    \n    vec3 hsl = floor(oldHsl * 20.) / 20.;\n    \n    if (hsl.y == 0.0) {\n        rgb = vec3(hsl.z); // Luminance\n    } else {\n        float f2;\n        \n        if (hsl.z < 0.5)\n            f2 = hsl.z * (1.0 + hsl.y);\n        else\n            f2 = hsl.z + hsl.y - hsl.y * hsl.z;\n            \n        float f1 = 2.0 * hsl.z - f2;\n        \n        rgb.r = hue2rgb(f1, f2, hsl.x + (1.0/3.0));\n        rgb.g = hue2rgb(f1, f2, hsl.x);\n        rgb.b = hue2rgb(f1, f2, hsl.x - (1.0/3.0));\n    }   \n    \n    if (shouldApplyCheckerboard(oldHsl)) {\n        return mix(checkerboard, rgb, CHECKERBOARD_OPACITY);\n    }\n    \n    return rgb;\n}\n\nfloat sdBox(vec2 p, vec2 b)\n{\n    vec2 d = abs(p) - b;\n    return length(max(d, 0.0)) + min(max(d.x, d.y), 0.0);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n    vec2 st = fragCoord / iResolution.y;\n    float ratio = iResolution.y / iResolution.x;\n    vec3 color = vec3(1.);\n\n    // Use polar coordinates instead of cartesian\n    vec2 toCenter = vec2(GAP_ONE + HEIGHT / 2., 0.5) - st;\n    float angle = atan(toCenter.y, toCenter.x);\n    float radius = length(toCenter) * 2.0 / HEIGHT;\n    \n    vec2 barMiddle = vec2(GAP_ONE + HEIGHT + GAP_TWO + BAR_WIDTH, 0.5);\n    float barSd = sdBox(st - barMiddle, vec2(BAR_WIDTH, HEIGHT / 2.));\n\n    vec2 uv = abs(1. - fract(st * 10. + iTime * 0.2) * 2.);\n    vec3 checkerboard = vec3(abs(smoothstep(0.5 - BLUR, 0.5 + BLUR, uv.x) - smoothstep(0.5 - BLUR, 0.5 + BLUR, uv.y)), 0., 1.);\n    // Map the angle (-PI to PI) to the Hue (from 0 to 1)\n    // and the Saturation to the radius\n    color = mix(vec3(1.), hsl2rgb(vec3((angle / TWO_PI) + 0.5, radius, 0.5), checkerboard), 1. - step(1., radius));\n    color = mix(color, hsl2rgb(vec3(DEFAULT_HUE, 1., (st.y - 0.5) / HEIGHT + 0.5), checkerboard), 1. - step(0., barSd));\n\n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/sdXXzN.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "ss23Dm", "name": "World in a bauble", "author": "Tezza48", "description": "Something i did a while ago and now converting it to webgl.\n\n- Written a while ago and just made public!", "tags": ["bauble"], "likes": 0, "viewed": 20, "date": "1617988824", "time_retrieved": "2024-06-20T20:38:57.130717", "image_code": "#define MAX_DIST 5.0\n#define PI 3.1415927\n// Ease the components of a normalized genType using a cosine function.\n#define cosEase(a) (1.0 - cos(a * PI)) / 2.0\n\n#define lightDirection normalize(vec3(cos(iTime), -3.0, -sin(iTime)))\n#define lightColor vec3(1.0, 1.0, 0.7)\n#define ambientColor vec3(0.3, 0.5, 0.9) * 0.3\n\n// From https://www.shadertoy.com/view/4djSRW\n//  1 out, 3 in...\nfloat hash13(vec3 p3)\n{\n\tp3  = fract(p3 * .1031);\n    p3 += dot(p3, p3.zyx + 31.32);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n// Generate value noise from a vec3. TODO WT: Sample the noise texture for random numbers\nfloat valueNoise31(vec3 p)\n{\n\tvec3 lerpFactor = fract(p - 0.5);\n\n\tfloat\tc000, c100,\n\t\t\tc010, c110,\n\t\t\tc001, c101,\n\t\t\tc011, c111;\n\n\t// TODO: Figure a way to remove these branches (slower than it could be)\n\tif (lerpFactor.x >= 0.5) // use this cellPos and one to the right\n\t{\n\t\tp.x -= 1.0;\n\t}\n\tif (lerpFactor.y >= 0.5)\n\t{\n\t\tp.y -= 1.0;\n\t}\n\tif (lerpFactor.z >= 0.5)\n\t{\n\t\tp.z -= 1.0;\n\t}\n\n\tlerpFactor = cosEase(lerpFactor);\n\n\t// front plane\n\t// bottom line\n\tc000 = hash13(floor((p + vec3(0, 0, 0))));\n\tc100 = hash13(floor((p + vec3(1, 0, 0))));\n\n\tfloat fbottom = mix(c000, c100, lerpFactor.x);\n\n\t// top line\n\tc010 = hash13(floor((p + vec3(0, 1, 0))));\n\tc110 = hash13(floor((p + vec3(1, 1, 0))));\n\t\n\tfloat ftop = mix(c010, c110, lerpFactor.x);\n\n\tfloat front = mix(fbottom, ftop, lerpFactor.y);\n\n\t// back plane\n\t// bottom line\n\tc001 = hash13(floor((p + vec3(0, 0, 1))));\n\tc101 = hash13(floor((p + vec3(1, 0, 1))));\n\n\tfloat bbottom = mix(c001, c101, lerpFactor.x);\n\n\t// top line\n\tc011 = hash13(floor((p + vec3(0, 1, 1))));\n\tc111 = hash13(floor((p + vec3(1, 1, 1))));\n\t\n\tfloat btop = mix(c011, c111, lerpFactor.x);\n\n\tfloat back = mix(bbottom, btop, lerpFactor.y);\n\n\treturn mix(front, back, lerpFactor.z);\n}\n\n// Generate fractal value noise from a vec3.\nfloat fractalValueNoise31(vec3 p)\n{\n\tfloat value = 0.0;\n\tfloat amp = 0.5;\n\n\tfor (int i = 0, l = 2; i < l; i++)\n\t{\n\t\tvalue += valueNoise31(p) * amp;\n\t\tamp *= 0.5;\n\t\tp *= 2.0;\n\t}\n\n\treturn value;\n}\n\nfloat sdf(vec3 p) { // Distance to surface\n    float sphere = length(p) - 1.5;\n\tfloat vol = fractalValueNoise31(p + iTime * 0.1) - 0.35;\n    \n    float noiseInSphere = max(sphere, vol);\n    return noiseInSphere;\n}\n\n#define f sdf\nvec3 calcNormal( in vec3 p ) // for function f(p)\n{\n    const float eps = 0.0001; // or some other value\n    const vec2 h = vec2(eps,0);\n    return normalize( vec3(f(p+h.xyy) - f(p-h.xyy),\n                           f(p+h.yxy) - f(p-h.yxy),\n                           f(p+h.yyx) - f(p-h.yyx) ) );\n}\n\nvec2 march(vec3 ro, vec3 rd) {\n    float trace = 0.001;\n    int steps = 0;\n    float closest = MAX_DIST;\n    for(; steps < 512; steps++) {\n        if (trace < 0.001 || trace > MAX_DIST) break;\n        \n        vec3 p = ro + rd * trace;\n        float dist = sdf(p);\n        closest = min(dist, closest);\n        \n        trace += dist;\n    }\n    \n    return vec2(trace, closest);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    //vec2 uv = (fragCoord - 0.5*iResolution.xy) / iResolution.y;\n    vec2 uv = (fragCoord / iResolution.xy) * 2.0 - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    \n    vec3 eyePos = vec3(0.0, 0.0, -2.5);\n    vec3 eyeDir = normalize(vec3(uv, 1.0));\n    \n    //fragColor = vec4(hash13(eyePos + eyeDir * iTime * 0.01));\n    //return;\n    \n    vec2 traceResult = march(eyePos, eyeDir);\n    float dist = traceResult.x;\n    \n    if (dist - MAX_DIST > 0.0) {\n        fragColor = vec4(0.5, 0.5, 0.5, 1.0);\n        return;\n    }\n    \n    vec3 hitPos = eyePos + eyeDir * dist;\n    vec3 normal = calcNormal(hitPos);\n    vec3 toLight = -lightDirection;\n    vec3 toEye = -eyeDir;\n    \n    vec3 col = ambientColor;\n    \n    // trace to light dir\n    float toLightDist = march(hitPos, toLight).x;\n    if (toLightDist - MAX_DIST < 0.0 && false) {\n        fragColor = vec4(0);\n    } else {\n        vec3 halfAngle = normalize(toLight + toEye);\n        float blinn = dot(halfAngle, normal);\n\n\n\n        col += vec3(dot(normal, toLight) * lightColor);\n    }\n    \n    \n    //col = vec3(traceResult.x / MAX_DIST);\n    \n    //vec3 col = vec3(uv, 0);\n    \n    \n    \n    //col = eyeDir;\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": "4sfGRr", "previewfilepath": "/media/ap/27012b4eadd0c3ce12498b867058e4f717ce79e10a99568cca461682d84a4b04.bin", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/27012b4eadd0c3ce12498b867058e4f717ce79e10a99568cca461682d84a4b04.bin", "ctype": "volume"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/ss23Dm.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "ss23Rc", "name": "Noise to Texture", "author": "lindayukeyi", "description": "Apply noise function to texture", "tags": ["noise"], "likes": 1, "viewed": 28, "date": "1618177784", "time_retrieved": "2024-06-20T20:38:58.876290", "image_code": "const int RAY_STEPS = 256;\nconst float HALF_PI = 3.14159 * 0.5;\nconst vec3 LIGHT_POS = vec3(0, 7.45, -1);\nconst float FOCAL_LENGTH = 30.0;\nconst float FOCAL_RANGE = 30.0;\nconst float AO_DIST = 0.15;\nconst float FIVETAP_K = 2.0;\n\n\n//Rotates the camera around the Y-axis\nvec3 rotateY(vec3 p, float a) {\n    return vec3(cos(a) * p.x + sin(a) * p.z, p.y, -sin(a) * p.x + cos(a) * p.z);\n}\n\n//Primitive SDFs\n#define BACK_WALL_SDF plane(pos, vec4(0.0, 0.0, -1.0, 6.0))\n#define LEFT_WALL_SDF plane(pos, vec4(1.0, 0.0, 0.0, 5.0))\n#define RIGHT_WALL_SDF plane(pos, vec4(-1.0, 0.0, 0.0, 5.0))\n#define CEILING_SDF plane(pos, vec4(0.0, -1.0, 0.0, 7.5))\n#define FLOOR_SDF plane(pos, vec4(0.0, 1.0, 0.0, 2.0))\n#define TALL_BOX_SDF box(rotateY(pos + vec3(1.5, 0.0, -2.0), -65.0 * 3.14159 / 180.0), vec3(2.0, 5.0, 2))\n#define SPHERE_SDF sphere(pos, 2.0, vec3(2.2, 0.0, 2.0))\n\n//Primtives IDs\n#define BACK_WALL 0\n#define LEFT_WALL 1\n#define RIGHT_WALL 2\n#define CEILING 3\n#define FLOOR 4\n#define TALL_BOX 5\n#define SPHERE 6\n\nstruct Intersection\n{\n    float t;\n    vec3 color;\n    vec3 p;\n    int object;\n};\n\n\nfloat sphere(vec3 p, float r, vec3 c)\n{\n    return distance(p, c) - r;\n}\n\n// Box with side lengths b\nfloat box(vec3 p, vec3 b)\n{\n  return length(max(abs(p) - b, 0.0));\n}\n\nfloat plane( vec3 p, vec4 n )\n{\n  // n must be normalized\n  return dot(p,n.xyz) + n.w;\n}\n\nvoid raycast(vec2 uv, out vec3 dir, out vec3 eye, out vec3 ref) {\n    //eye = rotateY(vec3(0.0, 0.0, 15.0), sin(iTime * 0.1) * 3.14159 * 0.5);\n    eye = vec3(0, 4.5, -35);\n    ref = vec3(0, 2.8, 0);\n    \n    \n    float len = tan(19.5 / 360.0 * 3.1415926) * length(eye - ref);\n    vec3 H = normalize(cross(vec3(0.0, 1.0, 0.0), ref - eye));\n    vec3 V = normalize(cross(H, eye - ref));\n    V *= len;\n    H *= len * iResolution.x / iResolution.y;\n    vec3 p = ref + uv.x * H + uv.y * V;\n    dir = normalize(p - eye);\n}\n\nvoid sceneMap3D(vec3 pos, out float t, out int obj) {\n    t = BACK_WALL_SDF;\n    obj = BACK_WALL;\n    \n    float t2;\n    if((t2 = LEFT_WALL_SDF) < t) {\n        t = t2;\n        obj = LEFT_WALL;\n    }\n    if((t2 = RIGHT_WALL_SDF) < t) {\n        t = t2;\n        obj = RIGHT_WALL;\n    }\n    if((t2 = CEILING_SDF) < t) {\n        t = t2;\n        obj = CEILING;\n    }\n    if((t2 = FLOOR_SDF) < t) {\n        t = t2;\n        obj = FLOOR;\n    } \n    if ((t2 = TALL_BOX_SDF) < t) {\n    \tt = t2;\n        obj = TALL_BOX;\n    }\n    if ((t2 = SPHERE_SDF) < t) {\n    \tt = t2;\n        obj = SPHERE;\n    }\n}\n\n\nfloat sceneMap3D(vec3 pos) {\n    float t = BACK_WALL_SDF;\n    \n    float t2;\n    if((t2 = LEFT_WALL_SDF) < t) {\n        t = t2;\n    }\n    if((t2 = RIGHT_WALL_SDF) < t) {\n        t = t2;\n    }\n    if((t2 = CEILING_SDF) < t) {\n        t = t2;\n    }\n    if((t2 = FLOOR_SDF) < t) {\n        t = t2;\n    }  \n    if ((t2 = TALL_BOX_SDF) < t) {\n    \tt = t2;\n    }\n    if ((t2 = SPHERE_SDF) < t) {\n    \tt = t2;\n    }\n    \n    return t;\n}\n\nvoid march(vec3 origin, vec3 dir, out float t, out int hitObj)\n{\n    t = 0.001;\n    for(int i = 0; i < RAY_STEPS; ++i)\n    {\n        vec3 pos = origin + t * dir;\n    \tfloat m;\n        sceneMap3D(pos, m, hitObj);\n        if(m < 0.01)\n        {\n            return;\n        }\n        t += m;\n    }\n    t = -1.0;\n    hitObj = -1;\n}\n\nvec2 random2( vec2 p ) {\n    return fract(sin(vec2(dot(p, vec2(127.1, 311.7)),\n                 dot(p, vec2(269.5,183.3))))\n                 * 43758.5453);\n}\n\n\nfloat WorleyNoise(vec2 uv) {\n    uv *= 10.0; // Now the space is 10x10 instead of 1x1. Change this to any number you want.\n    vec2 uvInt = floor(uv);\n    vec2 uvFract = fract(uv);\n    float minDist = 1.0; // Minimum distance initialized to max.\n    for(int y = -1; y <= 1; ++y) {\n        for(int x = -1; x <= 1; ++x) {\n            vec2 neighbor = vec2(float(x), float(y)); // Direction in which neighbor cell lies\n            vec2 point = random2(uvInt + neighbor); // Get the Voronoi centerpoint for the neighboring cell\n            vec2 diff = neighbor + point - uvFract; // Distance between fragment coord and neighbor’s Voronoi point\n            float dist = length(diff);\n            minDist = min(minDist, dist);\n        }\n    }\n    return minDist;\n}\n\nvec3 computeNormal(vec3 pos)\n{\n    vec3 epsilon = vec3(0.0, 0.001, 0.0);\n    return normalize( vec3( sceneMap3D(pos + epsilon.yxx) - sceneMap3D(pos - epsilon.yxx),\n                            sceneMap3D(pos + epsilon.xyx) - sceneMap3D(pos - epsilon.xyx),\n                            sceneMap3D(pos + epsilon.xxy) - sceneMap3D(pos - epsilon.xxy)));\n}\n\nfloat interpNoise2D(float x, float y) {\n    int intX = int(floor(x));\n    float fractX = fract(x);\n    int intY = int(floor(y));\n    float fractY = fract(y);\n\n    float v1 = random2(vec2(intX, intY)).x;\n    float v2 = random2(vec2(intX + 1, intY)).x;\n    float v3 = random2(vec2(intX, intY + 1)).x;\n    float v4 = random2(vec2(intX + 1, intY + 1)).x;\n\n    float i1 = mix(v1, v2, fractX);\n    float i2 = mix(v3, v4, fractX);\n    return mix(i1, i2, fractY);\n}\n\nfloat fbm(float x, float y) {\n    float total = 0.0;\n    float persistence = 0.5f;\n    int octaves = 4;\n\n    for(int i = 1; i <= octaves; i++) {\n        float freq = pow(2.0, float(i));\n        float amp = pow(persistence, float(i));\n\n        total += interpNoise2D(x * freq,\n                               y * freq) * amp;\n    }\n    return total;\n}\n\nfloat surflet(vec2 p, vec2 gridPoint) {\n    // Compute the distance between p and the grid point along each axis, and warp it with a\n    // quintic function so we can smooth our cells\n    float t2 = length(p - gridPoint);\n    vec2 t = vec2(1.0) - 6.0 * pow(t2, 5.0) + 15.0 * pow(t2, 4.0) - 10.0 * pow(t2, 3.0);\n    // Get the random vector for the grid point (assume we wrote a function random2\n    // that returns a vec2 in the range [0, 1])\n    vec2 gradient = random2(gridPoint) * 2.0 - vec2(1.0,1.0);\n    // Get the vector from the grid point to P\n    vec2 diff = p - gridPoint;\n    // Get the value of our height field by dotting grid->P with our gradient\n    float height = dot(diff, gradient);\n    // Scale our height field (i.e. reduce it) by our polynomial falloff function\n    return height * t.x * t.y;\n}\n\nfloat perlinNoise(vec2 uv) {\n\tfloat surfletSum = 0.0;\n\t// Iterate over the four integer corners surrounding uv\n\tfor(int dx = 0; dx <= 1; ++dx) {\n\t\tfor(int dy = 0; dy <= 1; ++dy) {\n\t\t\tsurfletSum += surflet(uv, vec2(floor(uv.x), floor(uv.y)) + vec2(dx, dy));\n\t\t}\n\t}\n\treturn surfletSum;\n}\n\n\nvec3 palette( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d )\n{\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\n// Reference: https://www.shadertoy.com/view/MtcGRl \nvec2 GetGradient(vec2 intPos, float t) {\n    \n    // Uncomment for calculated rand\n    //float rand = fract(sin(dot(intPos, vec2(12.9898, 78.233))) * 43758.5453);;\n    \n    // Texture-based rand (a bit faster on my GPU)\n    float rand = texture(iChannel0, intPos / 64.0).r;\n    \n    // Rotate gradient: random starting rotation, random rotation rate\n    float angle = 6.283185 * rand + 4.0 * t * rand;\n    return vec2(cos(angle), sin(angle));\n}\n\n\nfloat Pseudo3dNoise(vec3 pos) {\n    vec2 i = floor(pos.xy);\n    vec2 f = pos.xy - i;\n    vec2 blend = f * f * (3.0 - 2.0 * f);\n    float noiseVal = \n        mix(\n            mix(\n                dot(GetGradient(i + vec2(0, 0), pos.z), f - vec2(0, 0)),\n                dot(GetGradient(i + vec2(1, 0), pos.z), f - vec2(1, 0)),\n                blend.x),\n            mix(\n                dot(GetGradient(i + vec2(0, 1), pos.z), f - vec2(0, 1)),\n                dot(GetGradient(i + vec2(1, 1), pos.z), f - vec2(1, 1)),\n                blend.x),\n        blend.y\n    );\n    return noiseVal / 0.7; // normalize to about [-1..1]\n}\n\n// This is where you give your objects in the scene materials\nvec3 computeMaterial(int hitObj, vec3 p, vec3 n, vec3 lightVec, vec2 uv) {\n    float lambert = dot(n, lightVec) + 0.2;\n    \n    switch(hitObj) {\n        case BACK_WALL:\n        case CEILING:\n        case FLOOR:\n        return vec3(0.85, 0.81, 0.78) * lambert;\n        case TALL_BOX:\n        float noise_box = Pseudo3dNoise(vec3(uv * 10.0, iTime));\n        return palette(noise_box, \n                        vec3(0.8, 0.5, 0.4), \n                        vec3(0.2, 0.4, 0.2), \n                        vec3(2.0, 1.0, 1.0), \n                        vec3(0.00, 0.25, 0.25)) * lambert;\n        break;\n        case SPHERE:\n        float noise_sphere = fbm(uv.x * 5.0, uv.y * 5.0);\n        return palette(noise_sphere, \n                        vec3(0.8, 0.5, 0.4), \n                        vec3(0.2, 0.4, 0.2), \n                        vec3(2.0, 1.0, 1.0), \n                        vec3(0.00, 0.25, 0.25)) * lambert;\n        break;\n        case RIGHT_WALL:\n        float noise = WorleyNoise(uv);\n        return palette(noise, \n                        vec3(0.8, 0.5, 0.4), \n                        vec3(0.2, 0.4, 0.2), \n                        vec3(2.0, 1.0, 1.0), \n                        vec3(0.00, 0.25, 0.25)) * lambert;\n        break;\n        case LEFT_WALL:\n        return vec3(0.065, 0.63, 0.05) * lambert;\n        break;\n        case -1:\n        return vec3(0., 0., 0.);\n        break;\n    }\n    return vec3(0., 0., 0.);\n}\n\nfloat fiveTapAO(vec3 p, vec3 n, float k) {\n    float aoSum = 0.0;\n    for(float i = 0.0; i < 5.0; ++i) {\n        float coeff = 1.0 / pow(2.0, i);\n        aoSum += coeff * (i * AO_DIST - sceneMap3D(p + n * i * AO_DIST));\n    }\n    return 1.0 - k * aoSum;\n}\n\nIntersection sdf3D(vec3 dir, vec3 eye, vec2 uv)\n{\n    float t;\n    int hitObj;\n    march(eye, dir, t, hitObj);\n\n    vec3 isect = eye + t * dir;\n    vec3 nor = computeNormal(isect);\n    vec3 lightDir = normalize(LIGHT_POS - isect);\n\n\n    vec3 sdfColor = computeMaterial(hitObj, isect, nor, normalize(LIGHT_POS - isect), uv);\n    float ao = fiveTapAO(isect, nor, FIVETAP_K);\n    vec3 finalColor = sdfColor * ao;\n        \n    return Intersection(t, finalColor, isect, hitObj);\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    // [-1, 1]\n    vec2 uv2 = 2.0 * uv - vec2(1.0);\n        vec3 dir, eye, ref;\n\n    raycast(uv2, dir, eye, ref);\n\n  \tIntersection isect = sdf3D(dir, eye, uv2  + iTime * 0.05);\n    float distAlongCamZ = abs(dot(normalize(ref - eye), (isect.p - eye)));\n    float dofZ = min(1.0, abs(distAlongCamZ - FOCAL_LENGTH * abs(cos(iTime))) / FOCAL_RANGE);\n    dofZ = pow(dofZ, 0.5);   \n    fragColor = vec4(isect.color, dofZ);\n}\n\n", "image_inputs": [{"id": "4sf3Rn", "previewfilepath": "/media/ap/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/ss23Rc.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "ss23Rd", "name": "logic x", "author": "4eckme", "description": "logic x", "tags": ["2d", "kaleidoscope", "fraktal"], "likes": 3, "viewed": 27, "date": "1617842659", "time_retrieved": "2024-06-20T20:38:58.876290", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 coord = fragCoord - (iResolution.xy / vec2(2.0));\n   \tcoord *= sqrt(iTime);\n    float x = float(coord.x);\n    float y = float(coord.y);\n    float r2 = float(int(x*x + y*y)&int(abs(x*x-y*y)));      ;\n    int a = int(floor(r2*pow(16.0, 6.0-ceil(log2(r2)/4.0))));   \n    fragColor = vec4(\n        float((a >> 16) & 255) / 255.0,\n        float((a >> 8) & 255) / 255.0,\n        float((a >> 0) & 255) / 255.0,\n        1.0\n    );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/ss23Rd.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "ss23RG", "name": "Michael", "author": "SnoopethDuckDuck", "description": "Flappy wingy thing very nice", "tags": ["cool"], "likes": 1, "viewed": 47, "date": "1617592911", "time_retrieved": "2024-06-20T20:38:58.876290", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\nvec2 dir = uv.xy - 0.5 +0.05 * vec2(sin(0.25 * iTime),cos(0.25 * iTime));\nfloat d =0.5 * (1. + cos(2. * iTime) + sin(-2. * iTime)) * length(dir);\nfloat theta = atan( dir.y,dir.x);\nconst float pi = 3.14159;\n\nfloat r =  0.5 * (1. + sin(iTime)) -  cos( theta  + 0.25 * iTime + cos(sin(theta+0.25 * iTime)) + cos(cos(theta-0.25 * iTime)));  \n\nvec3 col = vec3(smoothstep(r, 0.5 * (1. + cos(iTime)) * d,0.1 + 0.05 * cos(0.125 * iTime)),\nsmoothstep(r, 0.5 * (1. + cos(iTime + 2. * pi / 3.)) * d,0.1 + 0.05 * cos(0.125 * iTime + 2. * pi / 3.)),\nsmoothstep(r, 0.5 * ( 1. + cos(iTime + 4. * pi / 3.)) * d,0.1 + 0.05 * cos(0.125 * iTime + 4. * pi / 3.))\n);\n\n\n    // Output to screen\n    fragColor = vec4(1. - col,1.0);\n      \n}\n\n\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/ss23RG.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "ss23WW", "name": "Mandelbrot Kaleidoscope", "author": "kithy", "description": "mandelbrot set,polar mod,rotation matrix", "tags": ["mandelbrotset", "rotationmatrix", "polarmod"], "likes": 2, "viewed": 32, "date": "1617454899", "time_retrieved": "2024-06-20T20:38:58.876290", "image_code": "#define ITR 100\n#define PI 3.1415926\n\nmat2 rot(float a){\n\tfloat c=cos(a);\n\tfloat s=sin(a);\n\treturn mat2(c,-s,s,c);\n}\n\nvec2 pmod(vec2 p,float n){\n\tfloat np=PI*2.0/n;\n\tfloat r=atan(p.x,p.y)-0.5*np;\n\tr=mod(r,np)-0.5*np;\n\treturn length(p)*vec2(cos(r),sin(r));\n}\n\nfloat mandelbrot(vec2 uv,vec2 c){\n\tint j;\n\tfor(int i=0;i<ITR;i++){\n\t\tj++;\n\t\tuv=vec2(uv.x*uv.x-uv.y*uv.y+c.x,2.0*uv.x*uv.y+c.y);\n\t\tif(length(uv)>float(ITR)){\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn float(j)/float(ITR);\n}\n\nvoid mainImage(out vec4 fragColor,in vec2 fragCoord){\n\tvec2 uv=(2.0*fragCoord.xy-iResolution.xy)/iResolution.y;\n\tuv.xy*=rot(iTime*0.5);\n\tuv=pmod(uv.xy,9.0);\n\tuv=mod(uv,0.8)-0.4;\n\tuv*=3.0;\n\tuv*=0.5+abs(sin(iTime*0.5));\n\tuv+=vec2(-0.5,0.0);\n\tfloat f=mandelbrot(vec2(0.0),uv);\n\n\tvec3 col=vec3(pow(f,3.0));\n\n\tfragColor=vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/ss23WW.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "ss2GRy", "name": "Sin waves with shift", "author": "toeyn", "description": "Simple sin waves", "tags": ["sinwave"], "likes": 0, "viewed": 41, "date": "1617608898", "time_retrieved": "2024-06-20T20:38:59.027825", "image_code": "#define SS(b,f) smoothstep(-b,b,f)\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    float col;\n    // Time varying pixel color\n    for(int i=0; i<6;i++){\n        col += SS(0.005,-abs(cos(iTime + uv.x*9.0*(0.6+float(i)*0.02*sin(iTime)))*0.1 -uv.y +0.7));\n    }\n\n    // Output to screen\n    fragColor = vec4(col);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/ss2GRy.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "ss2GW3", "name": "noisey color journey", "author": "SimonOakey", "description": "licenced under love, peace and happyness ✌️", "tags": ["noise", "color", "loop", "field", "multiple"], "likes": 3, "viewed": 132, "date": "1618060111", "time_retrieved": "2024-06-20T20:38:59.033906", "image_code": "/*licenced under love, peace and happyness ✌️ */\n\n\n#ifdef GL_ES\nprecision mediump float;\n#endif\n\n \n\n\n //generic rotation formula\nvec2 rot(vec2 uv,float a){\n\treturn vec2(uv.x*cos(a)-uv.y*sin(a),uv.y*cos(a)+uv.x*sin(a));\n}\n\n\n\nvec3 returnGrain(vec2 _uv, float amount){\n\t\n\t float x = (_uv.x + 4.0 ) * (_uv.y + 4.0 ) * (iTime * 10.0);\n\t vec4 grain = vec4(mod((mod(x, 13.0) + 1.0) * (mod(x, 123.0) + 1.0), 0.01)-0.005) *  amount;\n\t return grain.xyz;\n\t\n}\n\n\nfloat rand(vec2 n) { \n    return fract(sin(dot(n, vec2(12.9898, 4.1414))) * 43758.5453);\n}\n\nfloat noise(vec2 p){\n    vec2 ip = floor(p);\n    vec2 u = fract(p);\n    u = u*u*(3.0-2.0*u);\n\n    float res = mix(\n        mix(rand(ip),rand(ip+vec2(1.0,0.0)),u.x),\n        mix(rand(ip+vec2(0.0,1.0)),rand(ip+vec2(1.0,1.0)),u.x),u.y);\n    return res*res;\n}\n\nconst mat2 mtx = mat2( 0.80,  0.60, -0.60,  0.80 );\n\nfloat fbm( vec2 p )\n{\n    float f = 0.0;\n/*\n    vec2 p1 = vec2(p.x*.6,p.y*.6 + time*.12);\n    f += 0.500000*noise( p1); p1 = mtx*p1*3.03;\n\t\n   \n\tvec2 p2 = vec2(p.x*1.6 + time*.3 ,p.y*2.6 );\n    f += 0.300000*noise( p2); \n\t\n\t\n\tvec2 p3 = vec2(p.x*3.6 - time*.6 ,p.y*6.6 );\n    f += 0.200000*noise( p3);\n\t\n vec2 p4 = vec2(p.x*13.6 - time*.6 ,p.y*16.6 );\n    f += 0.200000*noise( p4);\n\t*/\n\t\n    \n     //p.x *= texture(iChannel1, p).x*1.2;\n     //p.y *= texture(iChannel1, p).y*1.2;\n    \n\t\n\tfor(int i=0;i<11; i++){\n\n\tvec2 p1 = vec2(p.x*.4*float(i),p.y*.4*float(i));\n\t\t\n\tp1.x *=\tnoise(p1*.5+iTime*.1)*.4;\n\tp1.y *=\tnoise(p*.5-iTime*.1)*.4;\n    \n    \n\t\t\n    \tf += 0.8*noise(p1); p1 = mtx*p1*3.03;\t\n\t\t\n\t\n\t}\n\t\n\n    return f;\n}\n\nfloat pattern( in vec2 p )\n{\n\treturn fbm( p + fbm( p*2.3 + fbm( p*.33 ) ) );\n}\n\n\n\nvec3 hsv2rgb( in vec3 c )\n{\n    vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n    return c.z * mix( vec3(1.0), rgb, c.y);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n\tfloat _x = iMouse.x;\n\n\tvec2 uv = gl_FragCoord.xy/iResolution.y;\n\t\n\t//uv.x = sin(uv.x*5.);\n\t\n\tuv.x += iResolution.y/iResolution.x;\n\t\n\tuv = rot(uv,iTime*.03);\n\t\n\tfloat shade = pattern(uv);\n\t\n\t\n\t\n\tvec3 col = vec3(\n\t\tsin(shade*.91+ iTime*.01)*1.75+.5 ,\n\t\tcos(shade*3.+ iTime*.13)*.75+.5 ,\n\t\tcos(shade*13.+ iTime*.13)*.5+.6 \n\t\t\t//shade*.7+.4\n\t);\n\t\n\tcol = hsv2rgb(col);\n\t\n\tcol += returnGrain(uv,9.);\n\t\n\tfragColor = vec4( col, 1.0 );\n\n}\n\n\n\n\n ", "image_inputs": [{"id": "Xdf3Rn", "previewfilepath": "/media/ap/e81e818ac76a8983d746784b423178ee9f6cdcdf7f8e8d719341a6fe2d2ab303.webm", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/e81e818ac76a8983d746784b423178ee9f6cdcdf7f8e8d719341a6fe2d2ab303.webm", "ctype": "video"}, {"id": "4dXGR8", "previewfilepath": "/media/previz/buffer00.png", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/previz/buffer00.png", "ctype": "buffer"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "unknown-license-reference", "thumbnail": "https://www.shadertoy.com/media/shaders/ss2GW3.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "ss2GWc", "name": "celluar_noise_16x", "author": "penghuailiang", "description": "celluar noise texture generator\n\nBlog： https://huailiang.github.io/blog/2021/noise/", "tags": ["noise", "celluar"], "likes": 0, "viewed": 319, "date": "1618068933", "time_retrieved": "2024-06-20T20:38:59.033906", "image_code": "#define SCALE 16.\n\nvec2 random(vec2 st){\n    return  fract(\n        sin(\n            vec2(\n                dot(st, vec2(127.1,311.7)),\n                dot(st, vec2(269.5,183.3))\n            )\n        ) * 43758.5453\n    );\n}\n\nfloat noise(vec2 p) {\n    vec2 i = floor(p); // 获取当前网格索引i\n    vec2 f = fract(p); // 获取当前片元在网格内的相对位置\n    float F1 = 1.;\n    // 遍历当前像素点相邻的9个网格特征点\n    for (int j = -1; j <= 1; j++) {\n        for (int k = -1; k <= 1; k++) {\n            vec2 neighbor = vec2(float(j), float(k));\n            vec2 point = random(i + neighbor);\n            float d = length(point + neighbor - f);\n            F1 = min(F1,d);\n        }\n    }\n    return F1;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = fragCoord.xy/iResolution.xy;\n    float c = noise(vec2(SCALE*uv));\n    //c = pow(c, 2.);\n    c = pow(c, 2. * (0.5+abs(sin(iTime))));\n    vec3 color= vec3(c,c,c);\n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/ss2GWc.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "ss2SR1", "name": "NANO (cryptocurrency) logo", "author": "melevy", "description": "NANO cryptocurrency logo", "tags": ["logo"], "likes": 5, "viewed": 451, "date": "1619766477", "time_retrieved": "2024-06-20T20:39:01.064567", "image_code": "float intersectSDF(float a, float b) {\n    return max(a, b);\n}\n\nfloat intersectRoundSDF(float a, float b, float r) {\n\tvec2 u = max(vec2(r + a, r + b), vec2(0.));\n\treturn min(-r, max (a, b)) + length(u);\n}\n\nfloat unionSDF(float a, float b) {\n    return min(a, b);\n}\n\nfloat unionRoundSDF(float a, float b, float r) {\n\tvec2 u = max(vec2(r - a, r - b), vec2(0.));\n\treturn max(r, min (a, b)) - length(u);\n}\n\nfloat differenceSDF(float a, float b) {\n    return max(a, -b);\n}\n\nfloat differenceRoundSDF(float a, float b, float r) {\n\treturn intersectRoundSDF(a, -b, r);\n}\n\nfloat sphereSDF(vec3 p, float s) {\n    return length(p) - s;\n}\n\nfloat cylinderSDF(vec3 p, float h, float r) {\n    float inOutRadius = length(p.xy) - r;\n    float inOutHeight = abs(p.z) - h / 2.;\n    float insideDistance = min(max(inOutRadius, inOutHeight), 0.);\n    float outsideDistance = length(max(vec2(inOutRadius, inOutHeight), 0.));\n    return insideDistance + outsideDistance;\n}\n\nfloat torusSDF(vec3 p, vec2 t) {\n    vec2 q = vec2(length(p.yz) - t.x, p.x);\n    return length(q) - t.y;\n}\n\nfloat dumbbellSphereSDF(vec3 point, float radius) {\n    vec3 o1 = vec3(0., 0., 0.);\n    vec3 o2 = vec3(radius * 2. * sqrt(2.), 0., 0.);\n    float p1 = sphereSDF(point - o1, radius);\n    float p2 = sphereSDF(point - o2, radius);\n    float p = unionSDF(p1, p2);\n    float n = torusSDF(point - vec3(radius * sqrt(2.), 0., 0.), vec2(radius * sqrt(2.), radius));\n    float phi1 = dot(normalize(o2 - o1), normalize(point - o1));\n    float phi2 = dot(normalize(o1 - o2), normalize(point - o2));\n    if (phi1 > sqrt(2.) / 2. && phi2 > sqrt(2.) / 2.)\n        return -n;\n    else\n        return p;\n}\n\nfloat dumbbellCylinderSDF(vec3 point, float radius, float height) {\n    float p1 = cylinderSDF(point - vec3(0., 0., 0.), height, radius);\n    float p2 = cylinderSDF(point - vec3(radius * 2. * sqrt(2.), 0., 0.), height, radius);\n    float p = unionSDF(p1, p2);\n    float n1 = cylinderSDF(point - vec3(radius * sqrt(2.), radius * sqrt(2.), 0.), height * 8., radius);\n    float n2 = cylinderSDF(point - vec3(radius * sqrt(2.), radius * -sqrt(2.), 0.), height * 8., radius);\n    float n = unionSDF(n1, n2);\n    float c1 = cylinderSDF(point - vec3(radius * sqrt(2.), 0., 0.), height, radius);\n    float m = differenceRoundSDF(c1, n, 0.);\n    return unionSDF(p, m);\n}\n\nfloat dumbbellSDF(vec3 point, float radius, float height, float rounding) {\n    float d1 = dumbbellCylinderSDF(point, radius, height);\n    float d2 = dumbbellSphereSDF(point, radius);\n    return mix(d1, d2, .2) - rounding;\n}\n\nfloat bellSDF(vec3 point, float radius, float height, float rounding) {\n    float a1 = cylinderSDF(point, height, radius);\n    float a2 = sphereSDF(point, radius);\n    return mix(a1, a2, .2) - rounding;\n}\n\nfloat nanoLogoSDF(vec3 point, float radius, float height, float rounding) {\n    float a = bellSDF(point, radius, height, rounding);\n    float b1 = dumbbellSDF(point - vec3(radius * 2. * sqrt(2.), 0., 0.), radius, height, rounding);\n    float b2 = dumbbellSDF(point.yxz - vec3(0., radius * 4. * sqrt(2.), 0.), radius, height, rounding);\n    float b = unionSDF(b1, b2);\n    float c1 = dumbbellSDF(point - vec3(radius * 4. * sqrt(2.), radius * 4. * sqrt(2.), 0.), radius, height, rounding);\n    float c2 = dumbbellSDF(point - vec3(radius * 6. * sqrt(2.), radius * 4. * sqrt(2.), 0.), radius, height, rounding);\n    float c = unionSDF(c1, c2);\n    return unionSDF(a, unionSDF(b, c));\n}\n\nvec2 sceneSDF(vec3 point) {\n    float scale = 0.5;\n    float radius = 1. * scale;\n    float height = .1 * scale;\n    float rounding = .15 * scale;\n    vec3 p = point.xzy - vec3(radius * -3. * sqrt(2.), radius * -3. * sqrt(2.), .15);\n    float sdf = nanoLogoSDF(p, radius, height, rounding);\n    return vec2(sdf, 30. + sin(iTime / 10.));\n}\n\n// The following part is a copy-paste from https://www.shadertoy.com/view/Xds3zN\n\n// The MIT License\n// Copyright © 2013 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// A list of useful distance function to simple primitives. All\n// these functions (except for ellipsoid) return an exact\n// euclidean distance, meaning they produce a better SDF than\n// what you'd get if you were constructing them from boolean\n// operations.\n\n// List of other 3D SDFs: https://www.shadertoy.com/playlist/43cXRl\n//\n// and http://iquilezles.org/www/articles/distfunctions/distfunctions.htm\n\n\n#if HW_PERFORMANCE==0\n#define AA 1\n#else\n#define AA 2   // make this 2 or 3 for antialiasing\n#endif\n\n#define ZERO (min(iFrame,0))\n\nfloat dot2( in vec2 v ) { return dot(v,v); }\nfloat dot2( in vec3 v ) { return dot(v,v); }\nfloat ndot( in vec2 a, in vec2 b ) { return a.x*b.x - a.y*b.y; }\n\n// http://iquilezles.org/www/articles/boxfunctions/boxfunctions.htm\nvec2 iBox( in vec3 ro, in vec3 rd, in vec3 rad ) \n{\n    vec3 m = 1.0/rd;\n    vec3 n = m*ro;\n    vec3 k = abs(m)*rad;\n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n\treturn vec2( max( max( t1.x, t1.y ), t1.z ),\n\t             min( min( t2.x, t2.y ), t2.z ) );\n}\n\nvec2 raycast( in vec3 ro, in vec3 rd )\n{\n    vec2 res = vec2(-1.0,-1.0);\n\n    float tmin = 1.0;\n    float tmax = 20.0;\n\n    // raytrace floor plane\n    float tp1 = (0.0-ro.y)/rd.y;\n    if( tp1>0.0 )\n    {\n        tmax = min( tmax, tp1 );\n        res = vec2( tp1, 1.0 );\n    }\n    //else return res;\n    \n    // raymarch primitives   \n    vec2 tb = iBox( ro-vec3(0.0,0.4,-0.5), rd, vec3(5.0,5.0,5.0));\n    if( tb.x<tb.y && tb.y>0.0 && tb.x<tmax)\n    {\n        //return vec2(tb.x,2.0);\n        tmin = max(tb.x,tmin);\n        tmax = min(tb.y,tmax);\n\n        float t = tmin;\n        for( int i=0; i<200 && t<tmax; i++ )\n        {\n            vec2 h = sceneSDF( ro+rd*t );\n            if( abs(h.x)<(0.0001*t) )\n            { \n                res = vec2(t,h.y); \n                break;\n            }\n            t += h.x;\n        }\n    }\n    \n    return res;\n}\n\n// http://iquilezles.org/www/articles/rmshadows/rmshadows.htm\nfloat calcSoftshadow( in vec3 ro, in vec3 rd, in float mint, in float tmax )\n{\n    // bounding volume\n    float tp = (0.8-ro.y)/rd.y; if( tp>0.0 ) tmax = min( tmax, tp );\n\n    float res = 1.0;\n    float t = mint;\n    for( int i=ZERO; i<24; i++ )\n    {\n\t\tfloat h = sceneSDF( ro + rd*t ).x;\n        float s = clamp(8.0*h/t,0.0,1.0);\n        res = min( res, s*s*(3.0-2.0*s) );\n        t += clamp( h, 0.02, 0.2 );\n        if( res<0.004 || t>tmax ) break;\n    }\n    return clamp( res, 0.0, 1.0 );\n}\n\n// http://iquilezles.org/www/articles/normalsSDF/normalsSDF.htm\nvec3 calcNormal( in vec3 pos )\n{\n#if 0\n    vec2 e = vec2(1.0,-1.0)*0.5773*0.0005;\n    return normalize( e.xyy*map( pos + e.xyy ).x + \n\t\t\t\t\t  e.yyx*map( pos + e.yyx ).x + \n\t\t\t\t\t  e.yxy*map( pos + e.yxy ).x + \n\t\t\t\t\t  e.xxx*map( pos + e.xxx ).x );\n#else\n    // inspired by tdhooper and klems - a way to prevent the compiler from inlining map() 4 times\n    vec3 n = vec3(0.0);\n    for( int i=ZERO; i<4; i++ )\n    {\n        vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);\n        n += e*sceneSDF(pos+0.0005*e).x;\n      //if( n.x+n.y+n.z>100.0 ) break;\n    }\n    return normalize(n);\n#endif    \n}\n\nfloat calcAO( in vec3 pos, in vec3 nor )\n{\n\tfloat occ = 0.0;\n    float sca = 1.0;\n    for( int i=ZERO; i<5; i++ )\n    {\n        float h = 0.01 + 0.12*float(i)/4.0;\n        float d = sceneSDF( pos + h*nor ).x;\n        occ += (h-d)*sca;\n        sca *= 0.95;\n        if( occ>0.35 ) break;\n    }\n    return clamp( 1.0 - 3.0*occ, 0.0, 1.0 ) * (0.5+0.5*nor.y);\n}\n\n// http://iquilezles.org/www/articles/checkerfiltering/checkerfiltering.htm\nfloat checkersGradBox( in vec2 p, in vec2 dpdx, in vec2 dpdy )\n{\n    // filter kernel\n    vec2 w = abs(dpdx)+abs(dpdy) + 0.001;\n    // analytical integral (box filter)\n    vec2 i = 2.0*(abs(fract((p-0.5*w)*0.5)-0.5)-abs(fract((p+0.5*w)*0.5)-0.5))/w;\n    // xor pattern\n    return 0.5 - 0.5*i.x*i.y;                  \n}\n\nvec3 render( in vec3 ro, in vec3 rd, in vec3 rdx, in vec3 rdy )\n{ \n    // background\n    vec3 col = vec3(0.7, 0.7, 0.9) - max(rd.y,0.0)*0.3;\n    \n    // raycast scene\n    vec2 res = raycast(ro,rd);\n    float t = res.x;\n\tfloat m = res.y;\n    if( m>-0.5 )\n    {\n        vec3 pos = ro + t*rd;\n        vec3 nor = (m<1.5) ? vec3(0.0,1.0,0.0) : calcNormal( pos );\n        vec3 ref = reflect( rd, nor );\n        \n        // material        \n        col = 0.2 + 0.2*sin( m*2.0 + vec3(0.0,1.0,2.0) );\n        float ks = 1.0;\n        \n        if( m<1.5 )\n        {\n            // project pixel footprint into the plane\n            vec3 dpdx = ro.y*(rd/rd.y-rdx/rdx.y);\n            vec3 dpdy = ro.y*(rd/rd.y-rdy/rdy.y);\n\n            float f = checkersGradBox( 3.0*pos.xz, 3.0*dpdx.xz, 3.0*dpdy.xz );\n            col = 0.15 + f*vec3(0.05);\n            ks = 0.4;\n        }\n\n        // lighting\n        float occ = calcAO( pos, nor );\n        \n\t\tvec3 lin = vec3(0.0);\n\n        // sun\n        {\n            vec3  lig = normalize( vec3(-0.5, 0.4, -0.6) );\n            vec3  hal = normalize( lig-rd );\n            float dif = clamp( dot( nor, lig ), 0.0, 1.0 );\n          //if( dif>0.0001 )\n        \t      dif *= calcSoftshadow( pos, lig, 0.02, 2.5 );\n\t\t\tfloat spe = pow( clamp( dot( nor, hal ), 0.0, 1.0 ),16.0);\n                  spe *= dif;\n                  spe *= 0.04+0.96*pow(clamp(1.0-dot(hal,lig),0.0,1.0),5.0);\n            lin += col*2.20*dif*vec3(1.30,1.00,0.70);\n            lin +=     5.00*spe*vec3(1.30,1.00,0.70)*ks;\n        }\n        // sky\n        {\n            float dif = sqrt(clamp( 0.5+0.5*nor.y, 0.0, 1.0 ));\n                  dif *= occ;\n            float spe = smoothstep( -0.2, 0.2, ref.y );\n                  spe *= dif;\n                  spe *= 0.04+0.96*pow(clamp(1.0+dot(nor,rd),0.0,1.0), 5.0 );\n          //if( spe>0.001 )\n                  spe *= calcSoftshadow( pos, ref, 0.02, 2.5 );\n            lin += col*0.60*dif*vec3(0.40,0.60,1.15);\n            lin +=     2.00*spe*vec3(0.40,0.60,1.30)*ks;\n        }\n        // back\n        {\n        \tfloat dif = clamp( dot( nor, normalize(vec3(0.5,0.0,0.6))), 0.0, 1.0 )*clamp( 1.0-pos.y,0.0,1.0);\n                  dif *= occ;\n        \tlin += col*0.55*dif*vec3(0.25,0.25,0.25);\n        }\n        // sss\n        {\n            float dif = pow(clamp(1.0+dot(nor,rd),0.0,1.0),2.0);\n                  dif *= occ;\n        \tlin += col*0.25*dif*vec3(1.00,1.00,1.00);\n        }\n        \n\t\tcol = lin;\n\n        col = mix( col, vec3(0.7,0.7,0.9), 1.0-exp( -0.0001*t*t*t ) );\n    }\n\n\treturn vec3( clamp(col,0.0,1.0) );\n}\n\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr )\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv =          ( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 mo = iMouse.xy / iResolution.xy;\n\tfloat time = 32.0 + iTime*1.5;\n\n    // camera\t\n    vec3 ta = vec3( 0.5, -0.5, -0.6 );\n    vec3 ro = ta + vec3( 4.5*cos(0.1*time + 7.0*mo.x), (cos(time / 5.) + 1.5) * 5. + 10.0*mo.y, 4.5*sin(0.1*time + 7.0*mo.x) );\n    // camera-to-world transformation\n    mat3 ca = setCamera( ro, ta, 0.0 );\n\n    vec3 tot = vec3(0.0);\n#if AA>1\n    for( int m=ZERO; m<AA; m++ )\n    for( int n=ZERO; n<AA; n++ )\n    {\n        // pixel coordinates\n        vec2 o = vec2(float(m),float(n)) / float(AA) - 0.5;\n        vec2 p = (2.0*(fragCoord+o)-iResolution.xy)/iResolution.y;\n#else    \n        vec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n#endif\n\n        // focal length\n        const float fl = 2.5;\n        \n        // ray direction\n        vec3 rd = ca * normalize( vec3(p,fl) );\n\n         // ray differentials\n        vec2 px = (2.0*(fragCoord+vec2(1.0,0.0))-iResolution.xy)/iResolution.y;\n        vec2 py = (2.0*(fragCoord+vec2(0.0,1.0))-iResolution.xy)/iResolution.y;\n        vec3 rdx = ca * normalize( vec3(px,fl) );\n        vec3 rdy = ca * normalize( vec3(py,fl) );\n        \n        // render\t\n        vec3 col = render( ro, rd, rdx, rdy );\n\n        // gain\n        // col = col*3.0/(2.5+col);\n        \n\t\t// gamma\n        col = pow( col, vec3(0.4545) );\n\n        tot += col;\n#if AA>1\n    }\n    tot /= float(AA*AA);\n#endif\n    \n    fragColor = vec4( tot, 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/ss2SR1.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "ssB3WK", "name": "Voronoi in Kyoto / Shogi", "author": "tomoe", "description": "Left: 2D, Center: 2D+rotation, Right: 3D\nUp: Shogi, Down: Kyoto\n(fork from [url=https://www.shadertoy.com/view/NsB3WG]Voronoi sample[/url] and [url=https://www.shadertoy.com/view/7sS3WK]Euclid / Kyoto / Shogi[/url])", "tags": ["bd202104"], "likes": 2, "viewed": 60, "date": "1617953448", "time_retrieved": "2024-06-20T20:39:01.064567", "image_code": "vec2 fragCoord_;\nuvec3 k = uvec3(0x456789abu, 0x6789ab45u, 0x89ab4567u);\nconst uint max32 = 0xffffffffu;\nconst float PI = 3.14159265359;\nuvec2 hash22u(uvec2 n) {  \n    n ^= (n.yx << 24);\n    n ^= (n.yx >> 1);\n    n *= k.xy;\n    n ^= (n.yx << 1);\n    return n * k.xy;\n}\nuvec3 hash33u(uvec3 n) {\n    n ^= (n.yzx << 24);\n    n ^= (n.yzx >> 1);\n    n *= k;\n    n ^= (n.yzx << 1);\n    return n * k;\n}\nmat2 rot2(float t) {\n    return mat2(cos(t), sin(t), -sin(t),  cos(t));\n}\nmat3 rotX(float t){\n    return mat3(\n        1.,0.,0.,\n        0.,sin(t),cos(t),\n        0.,-cos(t),sin(t)\n    );\n}\nvec2 hash22(vec2 p) {\n    uvec2 n = uvec2(p);\n    return vec2(hash22u(n)) / vec2(max32);\n}\nvec3 hash33(vec3 p) {\n    uvec3 n = uvec3(p);\n    return vec3(hash33u(n)) / vec3(max32);\n}\nfloat length2(vec2 p) {\n    p = abs(p);\n    if (fragCoord_.y < 0.5 * iResolution.y) {\n        return dot(p, vec2(1.0));\n    } else {\n        return max(p.x, p.y);\n    }\n}\nfloat length3(vec3 p) {\n    p = abs(p);\n    if (fragCoord_.y < 0.5 * iResolution.y) {\n        return dot(p, vec3(1.0));\n    } else {\n        return max(max(p.x, p.y), p.z);\n    }\n}\nvec2 voronoi2(vec2 p){   \n    vec2 n = round(p);\n    vec2 f = p - round(p);\n    float dist = length2(abs(f) + 0.5);\n    vec2 sgn = vec2(1.0);\n    vec2 glid = vec2(0.0);\n    vec2 ind;\n    for(float j = 0.0; j <= 2.0; j ++ ) {\n        glid.y += sgn.y * j;\n        sgn.y *= -1.0;\n        if (abs(glid.y - f.y) - 0.5 > dist){\n            continue;\n        }\n        for(float i = 0.0; i <= 2.0; i ++ ){\n            glid.x += sgn.x * i;\n            sgn.x *= -1.0;\n            vec2 nbd = glid;\n            if(fragCoord_.x < 0.33 * iResolution.x){\n                nbd += hash22(n + nbd) - 0.5; \n            } else {\n                nbd += rot2(iTime) * (hash22(n + nbd) - 0.5)/sqrt(2.0);\n            }\n            if(length2(nbd - f) < dist){\n                ind = n + glid;\n                dist = length2(nbd - f);\n            }\n        }\n        glid.x = 0.0;\n    }\n    return ind;\n}\nvec3 voronoi3(vec3 p){   \n    vec3 n = round(p);\n    vec3 f = p - round(p);\n    float dist = length3(abs(f) + 0.5);\n    vec3 sgn = vec3(1.0);\n    vec3 glid = vec3(0.0);\n    vec3 ind;\n    for(float k = 0.0; k <= 2.0; k ++ ) {\n            glid.z += sgn.z * k;\n            sgn.z *= -1.0;\n            if (abs(glid.z - f.z) - 0.5 > dist){\n                continue;\n            }\n        for(float j = 0.0; j <= 2.0; j ++ ) {\n            glid.y += sgn.y * j;\n            sgn.y *= -1.0;\n            if (abs(glid.y - f.y) - 0.5 > dist){\n                continue;\n            }\n            for(float i = 0.0; i <= 2.0; i ++ ){\n                glid.x += sgn.x * i;\n                sgn.x *= -1.0;\n                vec3 nbd = glid + hash33(n + glid) -0.5;\n                if(length3(nbd - f) < dist){\n                    ind = n + glid;\n                    dist = length3(nbd - f);\n                }\n            }\n            glid.x = 0.0;\n        }\n        glid.y = 0.0;\n    }\n    return ind;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    fragCoord_ = fragCoord;\n    vec2 pos = fragCoord.xy/ iResolution.xx;\n    pos *= 10.0;\n    pos += iTime;\n    vec3 v;\n    if(gl_FragCoord.x < 0.66 * iResolution.x){\n        v = vec3(hash22(voronoi2(pos)), 1.0);  \n    } else {\n        v = hash33(voronoi3(vec3(pos, 0.5 * iTime)));   \n    }\n    if (fragCoord.y < 0.5 * iResolution.y){\n        v = v.zxy;\n    }\n    fragColor = vec4(vec3(v), 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/ssB3WK.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "ssB3WW", "name": "xor noise thing", "author": "Azorlogh", "description": "Cool noise-ish thing I stumbled upon", "tags": ["xornoise"], "likes": 5, "viewed": 154, "date": "1617393876", "time_retrieved": "2024-06-20T20:39:01.064567", "image_code": "vec3 rotateXY(vec3 v, float a) { float c = cos(a), s = sin(a); return mat3( c, s, 0, -s, c, 0, 0, 0, 1 )*v; }\nvec3 rotateXZ(vec3 v, float a) { float c = cos(a), s = sin(a); return mat3( c, 0, s, 0, 1, 0, -s, 0, c )*v; }\nvec3 rotateYZ(vec3 v, float a) { float c = cos(a), s = sin(a); return mat3( 1, 0, 0, 0, c, s, 0, -s, c )*v; }\n\n#define UI0 1597334673U\n#define UI1 3812015801U\n#define UI2 uvec2(UI0, UI1)\n#define UI3 uvec3(UI0, UI1, 2798796415U)\n#define UIF (1. / float(0xffffffffU))\nfloat hash11(uint q)\n{\n\tuvec2 n = q * UI2;\n\tq = (n.x ^ n.y) * UI0;\n\treturn float(q) * UIF;\n}\n\n// change to NOISE_0 for greyscale\n#define NOISE_1\n\nvec3 noise(ivec2 pos) {\n    #ifdef NOISE_0\n    vec3 p = vec3(pos, uint(iTime*1.0));\n\tp=rotateXZ(p, 0.4+iTime*0.0123);\n\tp=rotateYZ(p, 0.3232+iTime*0.1);\n    return vec3(\n        hash11(uint(int(p.x) ^ int(p.y) ^ int(p.z)))\n    );\n    #elif defined NOISE_1\n    vec3 p = vec3(pos, iTime*5.0);\n\tp=rotateXZ(p, 0.5+iTime*0.123);\n\tp=rotateYZ(p, 0.3232+iTime*0.05);\n\tvec3 col = vec3(0);\n\tcol.r = hash11(uint(int(p.x) ^ int(p.y) ^ int(p.z)));\n\tp=rotateXZ(p, 0.02);\n\tp=rotateYZ(p, 0.04232);\n\tcol.g = hash11(uint(int(p.x) ^ int(p.y) ^ int(p.z)));\n\tp=rotateXZ(p, 0.01);\n\tp=rotateYZ(p, 0.02);\n\tcol.b = hash11(uint(int(p.x) ^ int(p.y) ^ int(p.z)));\n    return col;\n    #endif\n}\n\nvoid mainImage( out vec4 O, in vec2 U )\n{\n    U -= iResolution.xy/2.;\n    U /= iResolution.y/2.;\n\n\tO.xyz = vec3(noise(ivec2(U*200.0)));\n    O.w = 1.;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/ssB3WW.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "ssB3zG", "name": "Light source 2", "author": "donorman", "description": "Small test", "tags": ["tracing", "rasterbar"], "likes": 1, "viewed": 25, "date": "1617562276", "time_retrieved": "2024-06-20T20:39:01.676523", "image_code": "\nconst float EPSILON=1e-3;\n\nstruct Circle {\n    vec2 Center;\n    float R;\n    vec3 Color;\n};\n\nstruct Light {\n    vec2 Origin;\n    vec3 Color;\n};\n\nstruct Ray {\n    vec2 Origin;\n    vec2 Dir;\n};\n\nvec2 Eye;\nCircle circles[3];\nLight light;\n\nvoid init_scene() {\n    Eye = vec2(-3000,180);\n    circles[0] = Circle(vec2(40,180), 70.0, vec3(1.0, 0.2, 0.5));\n    circles[1] = Circle(vec2(50,350), 30.0, vec3(0.2, 1.0, 0.5));\n    circles[2] = Circle(vec2(50,200), 40.0, vec3(0.2, 0.5, 1.0));\n    \n    light = Light(vec2(-400.0,iResolution.y*.5),vec3(1.0,1.0,1.0));\n}\n\n\nbool intersection(in Ray R, in Circle C, out float t) {\n    vec2 CO = R.Origin - C.Center;\n    float a = dot(R.Dir, R.Dir);\n    float b = 2.0*dot(R.Dir, CO);\n    float c = dot(CO, CO) - C.R*C.R;\n    float delta = b*b - 4.0*a*c;\n    if(delta < 0.0) {\n        return false;\n    }\n    t =  (-b-sqrt(delta)) / (2.0*a) ;\n    return true;\n}\n\nvec3 trace(Ray R, int ctr) {\n    float t;\n    float minT = 100000.0;\n    int c = -1;\n    for(int i=0; i<circles.length(); i++) {\n        if(intersection(R, circles[i], t) && t < minT) {\n            minT = t;\n            c = i;\n        }\n    }\n    if(minT == 10000.0) {\n        //no object hit by ray\n        return vec3(0.0,0.0,0.0);\n    }\n    vec2 P = R.Origin + minT*R.Dir;\n    vec2 N = normalize(P - circles[c].Center);\n    vec2 E = R.Origin - P;\n    //calc angle for diffuse lightning\n    float diff = max(0.0, dot(E,N) / length(E)); //length of N = 1.\n    //calc angle for specular lightning\n    \n    vec2 L = light.Origin - P;\n    \n    \n    //test shadow ray\n    bool inShade = false;\n    Ray Rs = Ray(P, normalize(L));\n    for(int i=0; i<circles.length(); i++) {\n        if(intersection(Rs, circles[i], t) && t > EPSILON) {\n            inShade = true;\n            //break;\n        }\n    }\n    \n    float spec = 0.0;\n    if(inShade == false) \n    {\n        spec = max(0.0, dot(E,L) / (length(E)*length(L)) );\n    }\n    \n    \n    \n    \n    float specDist = 200.0/length(L); //can be optimized length(L) calc 3 times\n    \n    //add up the colors\n    vec3 color = 1.0*diff*circles[c].Color + 0.7*specDist*pow(spec,1080.0)*light.Color;\n    //add distance factor\n    color = color*3000.0/minT;\n    \n    return color;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    init_scene();\n    \n    float scrHeight = iResolution.y;\n    \n    circles[0].Center.y = scrHeight*0.5 + scrHeight*0.25*cos(1.0*iTime);\n    circles[0].Center.x = 2000.0 + 2000.0*sin(2.0*iTime);\n\n    circles[1].Center.y = scrHeight*0.5 + scrHeight*0.25*sin(1.0*iTime);\n    circles[1].Center.x = 500.0 + 400.0*cos(1.0*iTime);\n    \n    circles[2].Center.y = scrHeight*0.5 + scrHeight*0.25*cos(.8*iTime);\n    circles[2].Center.x = 2000.0 + 2000.0*sin(.8*iTime);\n    \n    //light.Origin.y = 200.0 + 200.0*sin(0.1*iTime);\n\n   \n    Ray R = Ray(Eye, normalize(vec2(0, fragCoord.y) - Eye));\n    \n    vec3 color = trace(R,0);\n    fragColor = vec4(color,1.0);\n    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/ssB3zG.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "ssBGDG", "name": "Evolving Gyroid - study 1/2", "author": "MacSlow", "description": "Study 1/2 into what can be done with all the different parameters one can tweak in a gyroid-function. You can yaw-orbit around the gyroid with the mouse.", "tags": ["3d", "phong", "sdf", "gyroid"], "likes": 6, "viewed": 204, "date": "1617919509", "time_retrieved": "2024-06-20T20:39:03.513046", "image_code": "////////////////////////////////////////////////////////////////////////////////\n//\n// Evolving gyroid-thing - study into what can be done with all the different\n// parameters one can tweak in a gyroid-function.\n//\n// Copyright 2021 Mirco Müller\n//\n// Author(s):\n//   Mirco \"MacSlow\" Müller <macslow@gmail.com>\n//\n// This program is free software: you can redistribute it and/or modify it\n// under the terms of the GNU General Public License version 3, as published\n// by the Free Software Foundation.\n//\n// This program is distributed in the hope that it will be useful, but\n// WITHOUT ANY WARRANTY; without even the implied warranties of\n// MERCHANTABILITY, SATISFACTORY QUALITY, or FITNESS FOR A PARTICULAR\n// PURPOSE.  See the GNU General Public License for more details.\n//\n// You should have received a copy of the GNU General Public License along\n// with this program.  If not, see <http://www.gnu.org/licenses/>.\n//\n////////////////////////////////////////////////////////////////////////////////\n\n// the HW_PERFORMANCE-check should take care of some optimization, if that does\n// not help you can still force GROUND_WAVES to 0 and/or AA_SIZE to 1 manually\n#if HW_PERFORMANCE==0\n#define GROUND_WAVES 0\nconst int AA_SIZE = 1;\n#else\n#define GROUND_WAVES 1\nconst int AA_SIZE = 2;\n#endif\n\nconst float PI = 3.14159265359;\nconst int MAX_ITER = 96;\nconst float STEP_BIAS = .5;\nconst float EPSILON = .0001;\nconst float MAX_DIST = 12.;\n\nfloat smin (float a, float b, float k)\n{\n    float h = clamp (.5 + .5*(b - a)/k, .0, 1.);\n    return mix (b, a, h) - h*k*(1. - h); \n}\n\nmat2 r2d (float deg)\n{\n    float rad = radians (deg);\n    float c = cos (rad);\n    float s = sin (rad);\n    return mat2 (c, s, -s, c);\n}\n\n// using a slightly adapted implementation of iq's simplex noise from\n// https://www.shadertoy.com/view/Msf3WH with hash(), noise() and fbm()\nvec2 hash (in vec2 p)\n{\n    p = vec2 (dot (p, vec2 (127.1, 311.7)),\n              dot (p, vec2 (269.5, 183.3)));\n\n    return -1. + 2.*fract (sin (p)*43758.5453123);\n}\n\nfloat noise (in vec2 p)\n{\n    const float K1 = .366025404;\n    const float K2 = .211324865;\n\n    vec2 i = floor (p + (p.x + p.y)*K1);\n    \n    vec2 a = p - i + (i.x + i.y)*K2;\n    vec2 o = step (a.yx, a.xy);    \n    vec2 b = a - o + K2; \n    vec2 c = a - 1. + 2.*K2;\n\n    vec3 h = max (.5 - vec3 (dot (a, a), dot (b, b), dot (c, c) ), .0);\n\n    vec3 n = h*h*h*h*vec3 (dot (a, hash (i + .0)),\n                           dot (b, hash (i + o)),\n                           dot (c, hash (i + 1.)));\n\n    return dot (n, vec3 (70.));\n}\n\nfloat fbm (in vec2 p, in int iters)\n{\n    mat2 rot = r2d (35.);\n    float d = .0;\n    float f = 1.;\n    float fsum = .0;\n\n    for (int i = 0; i < iters; ++i) {\n        d += f*noise (p);\n        fsum += f;\n        f *= .5;\n    }\n    d /= fsum;\n\n    return d;\n}\n\nfloat plane (vec3 p, float h)\n{\n    return p.y + h;\n}\n\nfloat ball (vec3 p, float r)\n{\n    return length (p) - r;\n}\n\nfloat cube (vec3 p, float size)\n{\n    return length (max (abs (p) - size, .0));\n}\n\nfloat gyroid (vec3 p, float scale, float thickness, float bias, vec2 modulation, vec2 offset)\n{\n    float modulate = (modulation.x > modulation.y) ? modulation.x : modulation.y;\n    p *= scale;\n    float d = dot (sin(p*modulation.x) + offset.x,\n                   cos(p.yzx*modulation.x) + offset.y) - bias;\n\n    return abs (d)/scale/modulate - thickness;\n}\n\nfloat scene (vec3 p)\n{\n    // doing the wavy ground with fbm() is a bit on the costly side\n    vec3 groundP = p;\n    groundP.x += iTime;\n    float pk = 1.5;\n    #if GROUND_WAVES \n    if( p.y<0.5 )\n    pk += .25*fbm(groundP.xz, 2);\n    #endif\n    float ground = plane (p, pk);\n\n    if (length(p) - 1.1 < ground) {\n        p.xz *= r2d (5.*iTime);\n        p.yx *= r2d (7.*iTime);\n        vec2 modulation = vec2 (2. + .75*cos(iTime),\n                                1.23 + .55*sin(iTime));\n        float thickness = .125 *(1./(1. + 5.*( cos(iTime)*.5 + .5 )));\n        float bias1 = 1.3;\n        float bias2 = .3;\n        float scale = 5.;\n        vec2 offset = vec2 (.1, .4);\n        float gyroid1 = gyroid (p, scale, thickness, bias1, modulation, offset)*.55;\n        float gyroid2 = gyroid (p, scale, thickness, bias2, modulation, offset)*.55;\n        float gyroidFinal = min (gyroid1 , gyroid2);\n        gyroidFinal = gyroid1 + gyroid2*.1;\n\n        float r = 1.125 + .05*cos (20.*p.y + 5.*iTime);\n        float ball = ball (p, r);\n\n        float g = smin (ball, gyroidFinal, -.05);\n        ground = min (g, ground);\n    }\n\n    return ground;\n}\n\nfloat raymarch (vec3 ro, vec3 rd, out int iter)\n{\n    float d = .0;\n    float t = .0;\n    int i = 0;\n    vec3 p = vec3 (.0);\n\n    for (; i < MAX_ITER; ++i) {\n        p = ro + d*rd;\n        t = scene (p);\n        if (abs (t) < EPSILON*(1. - .125*t) || d > MAX_DIST) {\n            iter = i;\n            break;\n        }\n        d += t*STEP_BIAS;\n    }\n\n    return d;\n}\n\nvec3 normal (vec3 p)\n{\n    vec2 e = vec2 (EPSILON, .0);\n    float d = scene (p);\n    vec3 n = normalize (vec3 (scene (p + e.xyy),\n                              scene (p + e.yxy),\n                              scene (p + e.yyx)) - d);\n    return n;\n}\n\nfloat shadow (vec3 p, vec3 n, vec3 lPos, vec3 lDir)\n{\n    int ignore = 0;\n    float distToWorld = raymarch (p + .01*n, lDir, ignore);\n    float distToLight = distance (p, lPos);\n\n    return distToWorld < distToLight ? .3 : 1.;\n}\n\nfloat ao (vec3 p, vec3 n, float stepSize, int iterations, float intensity)\n{\n  float ao = .0; \n  float dist = .0; \n\n  for (int a = 1; a <= iterations; ++a) {\n    dist = float (a)*stepSize;\n    ao += max (.0, (dist - scene (p + n*dist))/dist);\n  }\n\n  return 1. - ao*intensity;\n}\n\nvec3 shade (vec3 ro, vec3 rd, float d, vec3 n)\n{\n    vec3 p = ro + d*rd;\n\n    vec3 lPos1 = vec3 (3.*cos(iTime), 3., 3.*sin(.4*iTime));\n    vec3 lDir1 = normalize (lPos1 - p);\n    float lDist1 = distance (lPos1, p);\n    float attn1 = 30. / (lDist1*lDist1);\n    vec3 lColor1 = vec3 (1., .9, .3);\n\n    vec3 lPos2 = vec3 (-2.*cos(.3*iTime), 3., 4.*sin(iTime));\n    vec3 lDir2 = normalize (lPos2 - p);\n    float lDist2 = distance (lPos2, p);\n    float attn2 = 40. / (lDist2*lDist2);\n    vec3 lColor2 = vec3 (.2, .4, 1.);\n\n    vec3 amb = vec3 (.1); \n    float diff1 = max (dot (n, lDir1), .0);\n    float diff2 = max (dot (n, lDir2), .0);\n    vec3 h1 = normalize (lDir1 - rd);\n    vec3 h2 = normalize (lDir2 - rd);\n    float spec1 = pow (max (dot (h1, n), .0), 40.);\n    float spec2 = pow (max (dot (h2, n), .0), 40.);\n\n    float s1 = shadow (p, n, lPos1, lDir1);\n    float s2 = shadow (p, n, lPos2, lDir2);\n\n    float ao = ao (p, n, .05, 12, .1);\n\n    // don't do material assignment like this, this is a super lazy-ass hack!\n    vec3 gyroidMaterial = 1.5*vec3(.9, .6, .4);\n    bool isFloor = (p.y < -1.);\n    float phase = cos (20.*(p.x + iTime));\n    float mask = smoothstep (.005*d, .0025*d, .5 + .5*phase);\n    vec3 floorMaterial = 1.5*mix (vec3(.9), vec3 (.1), mask);\n    vec3 diffMaterial = isFloor ? floorMaterial : gyroidMaterial;\n\n    return amb + ao*(attn1*s1*(diff1*diffMaterial*lColor1 + spec1) +\n                     attn2*s2*(diff2*diffMaterial*lColor2 + spec2));\n}\n\nvec3 camera (vec2 uv, vec3 ro, vec3 aim, float zoom)\n{\n    vec3 camForward = normalize (aim - ro);\n    vec3 worldUp = vec3 (.0, 1., .0);\n    vec3 camRight = normalize (cross (camForward, worldUp));\n    vec3 camUp = normalize (cross (camRight, camForward));\n    vec3 camCenter = normalize (ro + camForward*zoom);\n\n    return normalize (camCenter + uv.x*camRight + uv.y*camUp - ro);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // normalize and aspect-correct UVs\n    vec2 uv = 2.*(fragCoord/iResolution.xy) - 1.;\n    uv.x *= iResolution.x/iResolution.y;\n\n    // allow some yaw-orbit with the mouse\n    vec2 yaw = .75*vec2 (PI*cos (4.*iMouse.x/iResolution.x),\n                         PI*sin (4.*iMouse.x/iResolution.x));\n    float pitch = 1.;\n\n    // create origin/camera/view-ray\n    vec3 ro = vec3 (yaw.x, pitch, yaw.y);\n    vec3 aim = vec3 (.0, .0, .0);\n    float zoom = 1.75;\n    vec3 rd = camera (uv, ro, aim, zoom);\n\n    // raymarch, shading & floor-glow\n    int iter = 0;\n    float d = .0;\n    vec3 p = vec3 (.0);\n    vec3 n = vec3 (.0);\n    vec3 color = vec3 (.0);\n    float fog = .0;\n\n    for (int x = 0; x < AA_SIZE; ++x) {\n        for (int y = 0; y < AA_SIZE; ++y) {\n\n\t\t\t// anti-alias offset\n\t\t\tvec2 pixelOffset = vec2 (float (x), float (y))/float (AA_SIZE);\n\n\t\t\t// normalize and aspect-correct UVs\n            uv = 2.*((fragCoord + pixelOffset)/iResolution.xy) - 1.;\n            uv.x *= iResolution.x/iResolution.y;\n\n    \t\t// create viewray\n    \t\trd = camera (uv, ro, aim, zoom);\n\n\t\t\t// primary/view ray\n            //iter = 0;\n\t\t\td = raymarch (ro, rd, iter);\n            p = ro + d*rd;\n            n = normal (p);\n\t\t\tvec3 ctmp = shade (ro, rd, d, n);\n            /*if (p.y < -1.) {\n                float glow = float (iter) / float (MAX_ITER);\n                ctmp += pow (glow, 1.05)*vec3 (1., .8, .2);\n            };*/\n            fog = 1. / (1. + d*d*.1);\n            ctmp *= fog;\n            ctmp = mix (ctmp, .5*vec3 (.15, .4, .9), pow (1. - 1./d, 6.));\n\n\t\t\tcolor += ctmp;\n        }\n    }\n    color /= float (AA_SIZE*AA_SIZE);\n\n    // make the final picture 'pretty'\n    color = color / (1. + color);\n    color *= 1. - .25*dot (uv, uv);\n    color = .2*color + .8*sqrt (color);\n\n    fragColor = vec4(color, 1.);\n}", "image_inputs": [{"id": "MllXWM", "previewfilepath": "https://soundcloud.com/weareoliver/oliver-mechanical", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0, "src": "https://soundcloud.com/weareoliver/oliver-mechanical", "ctype": "musicstream"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/ssBGDG.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "ssBGWc", "name": "Simple Newton Fractal", "author": "adamjmurray", "description": "A simple implementation of the Newton Fractal (https://en.wikipedia.org/wiki/Newton_fractal) for use as a starting point for more experiments.", "tags": ["fractal"], "likes": 2, "viewed": 89, "date": "1618101014", "time_retrieved": "2024-06-20T20:39:03.785874", "image_code": "vec2 cmul(vec2 a, vec2 b) { // complex multiplication\n    return vec2(a.x*b.x-a.y*b.y, a.x*b.y+a.y*b.x);\n}\nvec2 cdiv(vec2 a, vec2 b) { // complex division\n    return vec2(a.x*b.x+a.y*b.y, -a.x*b.y+a.y*b.x) / (b.x*b.x+b.y*b.y);\n}\n\nvec2 fn(vec2 z) { // f(z) = z^3 - 1\n    return cmul(z,cmul(z,z)) - vec2(1,0);\n}\nvec2 dfn(vec2 z) { // f'(z) = 3*z^2\n    return cmul(vec2(3,0),cmul(z,z));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 coord = (2.*fragCoord - iResolution.xy)/iResolution.y; // [-1,1] vertically\n    float zoom = pow(sin(iTime/5.+2.)+1.05,2.);\n    vec2 z = coord/zoom;\n    \n    vec2 zPrev = z;\n    float threshold = 0.00001;\n    float i;\n    \n    // iterate: zNext = z - f(z)/f'(z)\n    for (i=0.; i<100.; i++) { \n        z -= cdiv(fn(z),dfn(z));\n        if (length(z - zPrev) < threshold) break;\n        zPrev = z;\n    }\n    \n    float theta = atan(z.y,z.x);\n    float rotation = mod(theta/6.2832 + 1., 1.); // [0,1]\n    \n    vec3 color;\n    if (rotation < 0.33) {\n         color = vec3(1,0,0);\n    } else if (rotation < 0.66) {\n         color = vec3(0,1,0);\n    } else {\n         color = vec3(0,0,1);\n    }\n    \n    // set intensity based on how fast the solution was found\n    float intensity = 1./log(i); \n    \n    fragColor = vec4(color * intensity, 1);\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/ssBGWc.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "ssBGWV", "name": "test - mobile - array", "author": "nbardy", "description": "test", "tags": ["test"], "likes": 0, "viewed": 38, "date": "1617961083", "time_retrieved": "2024-06-20T20:39:03.919187", "image_code": "float[5]fodo(float f) {\n    return float[5](0.1,0.1,0.1,0.1,0.1);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Time varying pixel color\n    vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4)) + fodo(2.)[1];\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/ssBGWV.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "ssBGzV", "name": "vid", "author": "algroznykh", "description": "an attempt to GLSL export a\nCPPN overfitted to https://ru.wikipedia.org/wiki/%D0%92%D0%98%D0%94#/media/%D0%A4%D0%B0%D0%B9%D0%BB:VIDTV.svg\nbased on\nhttps://github.com/wxs/cppn-to-glsl/blob/master/cppn2glsl.ipynb", "tags": ["cppn"], "likes": 5, "viewed": 108, "date": "1617646568", "time_retrieved": "2024-06-20T20:39:04.755732", "image_code": "\n#define N_HIDDEN 24\n\nvec4 bufA[N_HIDDEN/4];\nvec4 bufB[N_HIDDEN/2];\n\n\nvec4 cppn_fn(vec2 coordinate, float in0, float in1, float in2, float in3) {\n    vec4 tmp;\n    bufB[0] = vec4(coordinate.x, coordinate.y, 0., 0.);\nbufA[0] = vec4(-0.0944129,-0.1933993,-0.28949672,0.262625) + mat4(vec4(0.41581112146377563,-0.4226127862930298,0.6148977279663086,-0.5159242153167725),vec4(0.6522397994995117,-1.4032132625579834,-0.5392898917198181,0.20646803081035614),vec4(0.0,0.0,0.0,0.0),vec4(0.0,0.0,0.0,0.0)) * bufB[0];\nbufA[1] = vec4(-0.038007226,0.3820075,0.2780375,0.33116898) + mat4(vec4(-0.164750874042511,0.6186392903327942,0.24181154370307922,-0.5191462635993958),vec4(0.21804934740066528,-0.4237729609012604,-0.7089636325836182,0.9342571496963501),vec4(0.0,0.0,0.0,0.0),vec4(0.0,0.0,0.0,0.0)) * bufB[0];\nbufA[2] = vec4(-0.14791629,-0.30293626,0.1147422,0.093470566) + mat4(vec4(0.44662803411483765,0.539374589920044,1.2166270017623901,-0.060298386961221695),vec4(-0.09032276272773743,0.41450056433677673,-0.28837716579437256,-0.03194330260157585),vec4(0.0,0.0,0.0,0.0),vec4(0.0,0.0,0.0,0.0)) * bufB[0];\nbufA[3] = vec4(0.15906769,0.10314791,-0.46741018,-0.10749554) + mat4(vec4(-0.0930357500910759,0.2767179608345032,0.10761213302612305,0.6665385365486145),vec4(0.9699234962463379,-0.42594602704048157,1.1038626432418823,-0.14996758103370667),vec4(0.0,0.0,0.0,0.0),vec4(0.0,0.0,0.0,0.0)) * bufB[0];\nbufA[4] = vec4(-0.22250462,0.81510586,0.091837525,-0.09406132) + mat4(vec4(0.13064931333065033,-1.647461175918579,-0.33211222290992737,0.4490022361278534),vec4(0.0742247924208641,0.22481505572795868,-0.52297043800354,0.10911503434181213),vec4(0.0,0.0,0.0,0.0),vec4(0.0,0.0,0.0,0.0)) * bufB[0];\nbufA[5] = vec4(-0.09724077,-0.112663224,0.17942607,0.008263693) + mat4(vec4(2.209573745727539,-0.3132593631744385,-0.2598205506801605,-0.07049916684627533),vec4(0.8706583976745605,-0.3601612448692322,0.24503999948501587,-0.002115401206538081),vec4(0.0,0.0,0.0,0.0),vec4(0.0,0.0,0.0,0.0)) * bufB[0];\ntmp = sin(bufA[0]);\nbufB[0] = tmp/0.67;\nbufB[6] = (tmp*tmp) / 0.6;\ntmp = sin(bufA[1]);\nbufB[1] = tmp/0.67;\nbufB[7] = (tmp*tmp) / 0.6;\ntmp = sin(bufA[2]);\nbufB[2] = tmp/0.67;\nbufB[8] = (tmp*tmp) / 0.6;\ntmp = sin(bufA[3]);\nbufB[3] = tmp/0.67;\nbufB[9] = (tmp*tmp) / 0.6;\ntmp = sin(bufA[4]);\nbufB[4] = tmp/0.67;\nbufB[10] = (tmp*tmp) / 0.6;\ntmp = sin(bufA[5]);\nbufB[5] = tmp/0.67;\nbufB[11] = (tmp*tmp) / 0.6;\nbufA[0] = vec4(0.18729784,0.2605321,-0.32132918,-0.37031916) + mat4(vec4(0.07528548,0.09222833,-0.11515221,0.054238766),vec4(0.15747993,-0.11561357,-0.079091236,0.15309665),vec4(0.0011189359,-0.16181757,-0.018746592,-0.10385456),vec4(0.0023649053,-0.12355008,-0.07075008,-0.23360252)) * bufB[0] + mat4(vec4(0.04921562,0.036022667,-0.033208173,0.1999829),vec4(-0.27163827,0.0026300694,0.14498037,0.0027006287),vec4(-0.21889022,-0.01060383,-0.08563007,-0.010317018),vec4(-0.14777686,-0.20268378,0.026414428,-0.023596153)) * bufB[1] + mat4(vec4(-0.13384911,-0.051267732,0.10535729,-0.14960773),vec4(0.024531653,0.09389985,0.050686415,0.19866724),vec4(-0.04199724,-0.063415594,0.12140642,-0.27167588),vec4(0.16540201,-0.04520013,-0.16260777,-0.039640874)) * bufB[2] + mat4(vec4(-0.30589294,0.044191457,-0.0028743525,-0.1849652),vec4(-0.05088523,0.09004661,-0.10310463,-0.045858186),vec4(-0.076808475,-0.02140676,-0.056208085,0.056196004),vec4(-0.20587932,0.13603286,-0.02633027,0.069607094)) * bufB[3] + mat4(vec4(-0.06519925,0.15751466,-0.0715465,0.1634293),vec4(0.012239711,0.36183324,-0.18052033,0.096865125),vec4(-0.22845623,0.188685,0.09113894,-0.13611896),vec4(-0.04621725,-0.17991021,0.06615265,-0.13499708)) * bufB[4] + mat4(vec4(0.103171825,0.03580365,-0.069207855,0.05053503),vec4(0.067009665,0.011660777,-0.123710155,0.26827794),vec4(0.10067923,-0.027639205,0.24015331,-0.105272114),vec4(-0.056875177,-0.017168736,0.12749709,-0.059358675)) * bufB[5] + mat4(vec4(0.15610014,0.0025208695,-0.15849036,0.2889138),vec4(-0.065192424,0.45034644,-0.55811137,-0.0024847942),vec4(-0.07133867,-0.25540876,0.14235774,0.18614005),vec4(0.08630114,-0.1933897,-0.092311054,-0.112384684)) * bufB[6] + mat4(vec4(-0.043904196,-0.39793044,0.1828919,-0.09369018),vec4(-0.13566843,-0.14304225,0.23540194,-0.038872402),vec4(0.13119242,-0.074560806,-0.18906909,0.11177644),vec4(-0.29155707,-0.17931737,-0.012964118,-0.026629828)) * bufB[7] + mat4(vec4(0.31337643,-0.09371762,-0.1917458,0.0021128797),vec4(-0.0071872924,-0.15321745,-0.009834039,0.38918087),vec4(0.13750857,-0.2559882,0.23481701,0.05787199),vec4(-0.26226166,0.045465253,0.0021932523,0.013756387)) * bufB[8] + mat4(vec4(-0.008981113,0.24701719,-0.036098514,-0.14038442),vec4(-0.05082746,-0.14172009,0.121006094,-0.036262617),vec4(0.05500792,0.02156105,0.15760975,0.2249423),vec4(0.08725141,-0.10125012,0.012153352,0.3053739)) * bufB[9] + mat4(vec4(0.055743523,-0.056392647,0.13588536,0.087723665),vec4(-0.09094352,-0.05767246,-0.16083643,0.3241965),vec4(0.40788832,0.4355084,0.12790619,0.1956992),vec4(0.2838489,-0.02730338,-0.23739421,-0.035631783)) * bufB[10] + mat4(vec4(-0.20379728,-0.14339952,0.45416737,-0.16321677),vec4(0.25474986,-0.12833555,0.117008194,0.06347274),vec4(0.07616472,-0.19941302,0.3753769,0.07970724),vec4(-0.14348252,0.03996154,0.022265093,0.03508637)) * bufB[11];\nbufA[1] = vec4(-0.5611655,-0.24928412,-0.2064914,-0.3260693) + mat4(vec4(0.2044711,0.14462346,0.15608488,-0.012230991),vec4(0.05446071,0.462535,-0.051629893,0.028941823),vec4(0.17450042,0.108868346,-0.041254926,-0.046683755),vec4(0.08156752,-0.085468836,0.062306177,0.1388702)) * bufB[0] + mat4(vec4(0.046894748,0.015840542,0.105946764,0.20388395),vec4(-0.15648177,-0.16276576,0.18421632,-0.035679743),vec4(-0.10766837,0.08013167,0.25260037,0.17991345),vec4(0.14665672,-0.40552312,0.03930096,-0.0684723)) * bufB[1] + mat4(vec4(0.3191627,0.012342074,-0.1970872,0.0008975048),vec4(0.18399037,-0.1567907,0.03228501,-0.27078196),vec4(-0.062054247,-0.024643758,-0.14671159,-0.085426904),vec4(-0.07298281,-0.09813189,-0.069442585,0.25370383)) * bufB[2] + mat4(vec4(-0.078363776,-0.14200762,0.031284057,0.008615511),vec4(-0.06645878,0.119924985,-0.1378362,-0.22125034),vec4(0.22740768,-0.44019127,-0.17987292,-0.3437722),vec4(0.06685701,0.2717562,-0.26757824,0.16392046)) * bufB[3] + mat4(vec4(0.092594996,0.034077227,-0.08167018,-0.02765141),vec4(-0.18939799,0.21071763,-0.025029564,0.43611097),vec4(0.10640469,0.07102353,-0.050685514,0.13619298),vec4(0.08036328,0.15806189,-0.0013033502,-0.22624962)) * bufB[4] + mat4(vec4(-0.0117382975,0.233232,0.108194485,0.048792623),vec4(-0.066222705,0.052864585,0.0649652,-0.0987334),vec4(-0.43796998,0.4095853,-0.06817246,0.120494775),vec4(0.10519968,0.037508182,0.10907068,0.030084265)) * bufB[5] + mat4(vec4(0.52273476,0.23769926,0.04159187,-0.26342723),vec4(0.13442999,0.36987922,0.043027487,0.0881625),vec4(0.28605366,-0.665185,0.010325421,-0.019585215),vec4(0.03610081,-0.34932673,-0.025794541,0.0016470255)) * bufB[6] + mat4(vec4(0.20098701,-0.28974232,0.042603854,0.2624023),vec4(-0.14724785,-0.01600598,-0.012840779,0.14772508),vec4(0.4294746,-0.18694896,0.16380706,0.0747358),vec4(0.35859087,-0.45475248,-0.031632446,-0.20155008)) * bufB[7] + mat4(vec4(-0.019323505,-0.30350703,-0.15374601,0.06501696),vec4(0.09683573,-0.04043895,0.0045500402,-0.23273592),vec4(0.004765937,-0.066107504,0.052479085,-0.11567175),vec4(0.07162949,0.06629814,-0.027346166,-0.21398066)) * bufB[8] + mat4(vec4(0.06326463,-0.05820684,-0.05187147,0.1454291),vec4(0.08301831,-0.15511961,0.049528684,0.1473579),vec4(0.43382227,0.3491508,0.0450971,-0.16101536),vec4(-0.06476541,0.121174574,-0.18037243,-0.29894188)) * bufB[9] + mat4(vec4(-0.16940935,0.08570104,0.065567605,-0.18022896),vec4(-0.20197767,-0.43069786,-0.22164118,-0.07868481),vec4(0.2654744,0.038439948,-0.057103824,-0.15821865),vec4(-0.0347203,0.13252313,-0.12179798,-0.069086425)) * bufB[10] + mat4(vec4(-0.11572062,0.100330375,-0.02327901,0.12135965),vec4(0.2202357,0.27228624,0.21599738,0.121013656),vec4(-0.07372725,-0.4835881,-0.106379785,0.013626815),vec4(-0.07401539,-0.12253809,-0.10989411,0.020698816)) * bufB[11];\nbufA[2] = vec4(-0.56504655,-0.3759989,-0.45356312,-0.0053351806) + mat4(vec4(0.047282945,0.10548982,0.17696963,0.03475044),vec4(-0.27499855,0.0392024,-0.27264884,-0.43417493),vec4(-0.009354685,0.015044925,-0.11437631,0.046739157),vec4(-0.37557533,0.14955036,0.18495722,0.322263)) * bufB[0] + mat4(vec4(-0.033938367,-0.08304304,0.06904146,-0.20597097),vec4(0.09804905,-0.042246073,0.073841296,0.3442421),vec4(-0.046335965,0.03496514,0.26305273,0.12945028),vec4(-0.098534204,-0.12217349,-0.073776536,0.12198454)) * bufB[1] + mat4(vec4(0.052313752,-0.07181559,-0.20124447,0.17713869),vec4(0.22798322,0.15908737,-0.17271398,-0.32350242),vec4(0.009263227,0.1270988,0.15155695,0.33221403),vec4(-0.06957845,0.104340434,0.07190079,-0.04395725)) * bufB[2] + mat4(vec4(0.06904358,-0.014154983,-0.02206963,-0.10894842),vec4(0.22981691,-0.10400669,0.10683939,0.18895395),vec4(0.2660784,-0.17288865,0.024373448,-0.2069602),vec4(-0.024416972,-0.03310571,-0.025896398,0.19978318)) * bufB[3] + mat4(vec4(0.13919343,0.04768776,-0.17226364,0.040891606),vec4(-0.20733038,0.017634057,0.09583975,0.3101429),vec4(0.09204676,-0.13099118,0.18403584,0.22293006),vec4(-0.07636417,0.03330624,-0.041591987,-0.053419627)) * bufB[4] + mat4(vec4(0.1886975,-0.07217477,-0.013426176,-0.11528187),vec4(0.06451237,-0.09231497,0.09212087,0.09722548),vec4(-0.3617027,-0.18478312,-0.16613413,-0.2819625),vec4(-0.17557444,0.05903012,0.02182171,0.022542223)) * bufB[5] + mat4(vec4(0.0027304727,0.15454967,-0.24559633,-0.36491948),vec4(0.45903894,0.062114697,0.20281434,0.19515313),vec4(0.016254093,0.12772407,0.15115522,-0.29865146),vec4(-0.0026243327,-0.009901781,-0.014112935,-0.06426787)) * bufB[6] + mat4(vec4(-0.03105972,-0.05491036,-0.3178905,-0.27336383),vec4(-0.0030344394,-0.0321111,0.16230272,0.052578475),vec4(-0.07977193,-0.02094074,-0.1407353,-0.31511202),vec4(0.40074626,-0.11502736,0.3664863,-0.22649045)) * bufB[7] + mat4(vec4(0.15602379,0.12856603,-0.10641134,-0.0015094137),vec4(0.01437635,0.0344545,-0.07065369,-0.275238),vec4(0.26226252,0.077499375,-0.20192283,-0.0623788),vec4(0.3051944,0.10156637,-0.09301442,0.05233445)) * bufB[8] + mat4(vec4(0.085797444,0.24838912,0.07433439,-0.1736303),vec4(-0.028229678,-0.108969994,-0.052269693,-0.22230291),vec4(0.021423738,-0.12307336,0.061367847,-0.08498417),vec4(0.23600926,0.083124705,0.001775384,0.022233035)) * bufB[9] + mat4(vec4(-0.0906433,0.090267986,0.012723574,0.103022784),vec4(0.086431466,0.34734157,-0.078839645,0.12782991),vec4(-0.1144003,-0.19004633,-0.32384726,-0.5264109),vec4(-0.02998189,0.2479405,-0.13188708,0.14086929)) * bufB[10] + mat4(vec4(-0.017371725,-0.070265986,0.10260126,-0.039422605),vec4(-0.12375225,0.008683347,-0.35496294,-0.26999757),vec4(-0.17237714,-0.18856548,-0.046901893,-0.27184087),vec4(-0.21926345,0.11196498,-0.13325661,0.014751016)) * bufB[11];\nbufA[3] = vec4(0.045100696,0.15353313,-0.2716543,0.09192999) + mat4(vec4(-0.039265733,-0.042649537,-0.016986227,-0.31396022),vec4(0.018786853,-0.008514091,-0.34839904,-0.2127111),vec4(-0.20153503,-0.021923278,0.028927837,-0.2317101),vec4(-0.27044728,-0.012322456,-0.19149855,-0.027782397)) * bufB[0] + mat4(vec4(-0.075849116,-0.15640748,-0.18275413,-0.026503041),vec4(-0.06905602,-0.23423947,0.11611448,0.017846575),vec4(-0.13011095,-0.1649831,-0.064069755,-0.06809001),vec4(-0.2935236,-0.068734206,0.18506038,0.04073921)) * bufB[1] + mat4(vec4(-0.16885546,0.04105355,0.10099559,0.062112655),vec4(0.07023687,-0.19799462,-0.063941196,-0.02119042),vec4(-0.028121104,-0.08079835,-0.008036377,0.31071985),vec4(0.14288418,0.09399638,0.2888782,0.2300294)) * bufB[2] + mat4(vec4(-0.106185794,0.060270976,0.21402726,0.1455954),vec4(-0.09180112,-0.29006392,0.019178241,0.21622637),vec4(-0.028565021,0.37759155,0.10374601,-0.047391657),vec4(-0.0031806887,-0.1661629,0.3003443,0.05043123)) * bufB[3] + mat4(vec4(0.01690138,0.046814013,-0.096578754,-0.043079864),vec4(0.030923769,-0.041629635,0.0059706974,-0.31212792),vec4(-0.12123993,0.01699758,0.008862732,0.20270747),vec4(0.14386459,-0.19413316,0.07980217,-0.16850719)) * bufB[4] + mat4(vec4(-0.1683382,0.30353132,-0.28876022,-0.20435034),vec4(0.021262128,0.16071141,-0.37144843,0.021710347),vec4(0.099790946,0.0080580255,0.15089963,0.30520612),vec4(-0.009572364,0.111190096,-0.0105533395,-0.056591216)) * bufB[5] + mat4(vec4(0.10386642,0.050483044,-0.312883,0.031565838),vec4(-0.067553736,0.17323537,-0.2057313,0.47270507),vec4(0.29099014,0.33831096,0.013224408,0.015490067),vec4(0.027920607,0.24993701,-0.011870429,-0.24178435)) * bufB[6] + mat4(vec4(-0.01363587,0.2020575,-0.025755562,-0.2309068),vec4(0.1367843,0.08964196,0.52197605,0.14762682),vec4(-0.054047987,0.23431566,0.14758703,-0.13501674),vec4(0.17627934,-0.041267354,0.13033415,0.099535406)) * bufB[7] + mat4(vec4(-0.2536506,0.16031408,0.053531338,-0.08986688),vec4(0.13006164,-0.023838585,-0.081530556,0.05898303),vec4(0.022301972,0.048432644,0.0114178825,0.28295845),vec4(-0.14350466,-0.048347462,-0.10216187,-0.017842988)) * bufB[8] + mat4(vec4(-0.04850162,-0.123031154,0.303638,0.03433867),vec4(0.13737231,0.2679083,0.54636306,-0.18809648),vec4(-0.2946958,0.25831255,-0.22804388,-0.20405154),vec4(0.016610643,0.0926913,0.06504856,-0.0012922977)) * bufB[9] + mat4(vec4(-0.08673699,0.1415598,-0.22476643,-0.14349361),vec4(0.22248688,-0.26305243,0.2535149,-0.27021274),vec4(0.28945792,-0.16057661,-0.09349752,-0.27221543),vec4(-0.049249593,-0.29418436,-0.39872998,-0.040858284)) * bufB[10] + mat4(vec4(-0.12866783,-0.26912355,-0.21744211,-0.48191315),vec4(0.11554396,0.026568286,-0.34323832,0.03266896),vec4(-0.28502712,0.11497038,0.08452237,-0.096907355),vec4(-0.15174675,0.0049092877,-0.048792202,0.18206336)) * bufB[11];\nbufA[4] = vec4(-0.3799749,-0.34944895,0.23975767,0.19557218) + mat4(vec4(-0.2626101,-0.08023763,-0.055438798,-0.05630845),vec4(-0.21190053,0.16071048,0.09790612,0.035362303),vec4(-0.0026882612,-0.08131032,0.06777259,-0.3425874),vec4(0.031956397,0.46550816,-0.2103383,0.19624592)) * bufB[0] + mat4(vec4(0.14119032,0.082411796,-0.17907137,0.09655609),vec4(0.07364584,0.30954444,-0.08878171,0.258585),vec4(-0.29576007,0.17617775,-0.17603463,-0.019532295),vec4(-0.30228516,-0.0021447875,0.17268501,0.12720424)) * bufB[1] + mat4(vec4(-0.053592883,0.092836164,-0.0019141922,-0.18472713),vec4(0.19458637,0.26769412,-0.11766373,-0.05060821),vec4(-0.2722809,-0.2467074,-0.12126772,-0.25678688),vec4(-0.20609295,0.1409809,0.109594144,0.03280416)) * bufB[2] + mat4(vec4(-0.07495263,0.06251746,0.18588808,0.08065861),vec4(-0.13864468,0.1183279,-0.035067137,-0.079888515),vec4(0.059362195,-0.048686508,0.06884113,-0.056569606),vec4(-0.08013989,0.07645863,-0.07916276,0.0046673613)) * bufB[3] + mat4(vec4(0.10701392,-0.28384072,0.21178274,-0.004689113),vec4(-0.31046575,-0.00037224195,0.10889443,-0.016757654),vec4(-0.15113144,-0.07975732,-0.10723046,-0.022717053),vec4(-0.19656111,0.07737282,0.22317223,0.050582398)) * bufB[4] + mat4(vec4(-0.091579325,0.10765367,0.24308206,-0.090662725),vec4(0.3191282,-0.052759588,-0.111894034,0.007847826),vec4(0.0043284865,0.018073972,0.33981448,-0.010328072),vec4(0.02816201,-0.075976625,-0.09775603,0.053847127)) * bufB[5] + mat4(vec4(-0.037005465,0.052409377,-0.33218804,0.045053706),vec4(0.15096374,-0.2865719,-0.29032382,-0.31858206),vec4(0.1676445,-0.1037125,0.25979367,0.010784111),vec4(-0.105489746,0.0017200089,0.29546988,0.15896143)) * bufB[6] + mat4(vec4(0.16188473,-0.13447386,0.016603885,0.037025418),vec4(0.18600543,0.014977537,-0.12588385,0.20829372),vec4(-0.022085441,0.16801646,0.22182882,-0.059651222),vec4(-0.002413904,0.028454807,0.08813811,-0.24805348)) * bufB[7] + mat4(vec4(-0.13674727,-0.21641643,-0.16822375,0.066411525),vec4(0.33624092,-0.08106045,-0.43886697,0.11764225),vec4(-0.25046748,-0.18825649,0.16262408,0.37640923),vec4(0.20625824,-0.047016595,0.009026688,0.25882733)) * bufB[8] + mat4(vec4(0.30830735,0.023879461,-0.12356217,-0.2897888),vec4(0.30177453,0.04716946,0.21556969,0.13378792),vec4(0.0612774,0.2543176,0.14881574,-0.20480628),vec4(0.0411331,-0.25520402,0.41241845,-0.0049750237)) * bufB[9] + mat4(vec4(-0.12033495,-0.14150804,-0.06070216,0.0666833),vec4(-0.23578127,-0.07715667,0.19491974,-0.49528536),vec4(0.04904613,0.18326382,-0.26377153,0.08280692),vec4(0.21960926,0.04483032,0.06499484,0.2695865)) * bufB[10] + mat4(vec4(0.71950907,0.08680667,-0.52056193,0.2840479),vec4(0.0225209,-0.006450044,0.061929718,0.21539055),vec4(-0.004395706,0.18434998,0.09772759,0.0064010774),vec4(-0.18483424,0.14050683,0.0068046087,0.19041161)) * bufB[11];\nbufA[5] = vec4(0.44678766,0.19088283,0.3160068,-0.12177275) + mat4(vec4(-0.13546653,0.1058285,0.15458818,-0.09653304),vec4(-0.07908627,0.05071308,0.27141446,-0.13242811),vec4(-0.14216316,-0.027801206,-0.13449372,0.07851844),vec4(0.18257028,0.14991528,0.18816765,-0.15619792)) * bufB[0] + mat4(vec4(-0.1256994,0.07926988,0.18635257,-0.02463492),vec4(-0.13894933,-0.04544346,-0.42742229,-0.030072529),vec4(-0.009657798,0.010480853,-0.2358252,0.054994207),vec4(0.17730202,0.05663157,0.39553332,0.029235717)) * bufB[1] + mat4(vec4(-0.08471788,-0.1628021,-0.18348141,0.3786269),vec4(-0.29108992,-0.13495389,0.2267434,0.3083838),vec4(-0.19130878,0.02666363,-0.09416394,-0.35162225),vec4(0.124345124,-0.04607957,-0.005923066,-0.18186484)) * bufB[2] + mat4(vec4(0.16779469,-0.14474744,-0.042047184,0.09547089),vec4(-0.12555324,-0.1898858,0.39741224,-0.08194026),vec4(0.08903383,-0.021253403,-0.075394645,0.165956),vec4(-0.1751827,-0.14812925,0.06945587,0.05731587)) * bufB[3] + mat4(vec4(-0.2100259,-0.12409613,0.06816117,0.10781084),vec4(-0.2517193,0.3150873,-0.12753955,-0.46061566),vec4(0.2622563,0.03491778,0.06973946,0.16271192),vec4(-0.44050756,0.17021447,0.100731194,0.18879528)) * bufB[4] + mat4(vec4(0.14959231,0.28667378,0.31821203,-0.20708531),vec4(-0.0150573235,-0.002289846,0.14909245,0.251265),vec4(0.075167835,0.30196998,0.38326022,-0.58099943),vec4(0.0906212,0.062005423,0.00095415686,-0.000108336855)) * bufB[5] + mat4(vec4(-0.16356759,0.21831757,-0.11897714,0.25858742),vec4(0.012291569,0.02238306,-0.6299735,0.29503995),vec4(0.14868188,-0.17860737,0.0714606,0.18257324),vec4(0.13770375,-0.12983415,0.22124621,0.050617166)) * bufB[6] + mat4(vec4(0.058838304,-0.06913767,-0.39079657,0.07969333),vec4(0.105780095,0.30767152,-0.0051435702,-0.0030433421),vec4(-0.18531832,0.164246,-0.13102569,-0.32930252),vec4(-0.22246438,-0.006828006,-0.042745307,0.13302723)) * bufB[7] + mat4(vec4(0.18568994,-0.25487638,0.29791108,0.09075608),vec4(0.10165846,0.047757432,-0.20897776,0.23866582),vec4(0.4949063,-0.1460095,-0.38418275,0.25174326),vec4(0.1834596,0.017628122,0.040931106,-0.060425878)) * bufB[8] + mat4(vec4(-0.05355762,0.28419986,-0.083976,0.15443753),vec4(-0.09581641,0.05665007,-0.13641797,0.15537575),vec4(-0.1400124,0.2709267,0.03888849,-0.11061107),vec4(0.26200357,-0.27039585,0.32757708,0.050562833)) * bufB[9] + mat4(vec4(-0.12413505,0.12426922,-0.05729808,-0.30165586),vec4(-0.41377446,-0.49222562,0.15806426,0.46976703),vec4(-0.093509905,0.08642062,-0.5329437,0.30804443),vec4(0.035084188,-0.23408678,0.18110934,0.43717232)) * bufB[10] + mat4(vec4(0.20299941,-0.52580816,0.04809576,-0.16722995),vec4(-0.5044771,0.008105667,0.033164922,0.14825256),vec4(-0.03508922,-0.117727086,-0.030130366,0.11290958),vec4(0.21004967,-0.15126896,0.20150319,0.11899323)) * bufB[11];\ntmp = sin(bufA[0]);\nbufB[0] = tmp/0.67;\nbufB[6] = (tmp*tmp) / 0.6;\ntmp = sin(bufA[1]);\nbufB[1] = tmp/0.67;\nbufB[7] = (tmp*tmp) / 0.6;\ntmp = sin(bufA[2]);\nbufB[2] = tmp/0.67;\nbufB[8] = (tmp*tmp) / 0.6;\ntmp = sin(bufA[3]);\nbufB[3] = tmp/0.67;\nbufB[9] = (tmp*tmp) / 0.6;\ntmp = sin(bufA[4]);\nbufB[4] = tmp/0.67;\nbufB[10] = (tmp*tmp) / 0.6;\ntmp = sin(bufA[5]);\nbufB[5] = tmp/0.67;\nbufB[11] = (tmp*tmp) / 0.6;\nbufA[0] = vec4(-0.23101051,-0.4405457,-0.028852444,-0.21828131) + mat4(vec4(0.046101283,0.11824605,-0.15068495,0.03334561),vec4(-0.05140561,-0.0006547769,0.17892662,-0.07733696),vec4(0.17395362,-0.0201635,-0.13795295,-0.09415099),vec4(-0.16384335,0.03455891,-0.022178179,0.033042524)) * bufB[0] + mat4(vec4(-0.1901485,-0.07031804,0.14484312,-0.32606977),vec4(0.037860233,-0.08072992,-0.011388807,0.06223955),vec4(0.010048818,0.015879534,-0.026829448,0.001906515),vec4(-0.0055376487,-0.062542036,0.04622894,0.17961754)) * bufB[1] + mat4(vec4(0.14397228,-0.031948414,0.2717677,-0.038299825),vec4(-0.04708207,-0.033691593,0.0016286224,-0.0031695368),vec4(0.11098976,-0.19855969,0.14441682,-0.034614768),vec4(0.311665,0.06887632,-0.67526317,0.8768873)) * bufB[2] + mat4(vec4(-0.17079186,0.06765754,0.019295117,-0.0013119952),vec4(0.18820511,0.09364158,0.13911027,-0.15701576),vec4(0.07551095,0.12614353,0.18495636,-0.15826951),vec4(0.11815465,0.09998208,0.083937176,-0.077803746)) * bufB[3] + mat4(vec4(-0.1814779,0.25824735,0.11752795,-0.052188464),vec4(0.072941266,0.0840672,-0.01940918,-0.07643521),vec4(0.08023893,-0.23602714,0.20830387,-0.15379594),vec4(-0.005680156,0.04203502,-0.007098627,-0.06639187)) * bufB[4] + mat4(vec4(0.12680495,-0.045429487,-0.07179372,-0.15146703),vec4(0.2855514,0.2121379,0.03686353,0.20922485),vec4(0.015484549,0.2945005,0.18497816,0.1668768),vec4(-0.31209737,0.23501141,0.11963593,0.009625597)) * bufB[5] + mat4(vec4(0.04531262,-0.018025678,-0.12783414,0.086078174),vec4(0.10568574,0.09585165,0.121752925,0.1736864),vec4(0.12537484,-0.097257845,0.13102692,0.23453982),vec4(0.072352886,0.1188493,-0.10737245,0.04978069)) * bufB[6] + mat4(vec4(-0.5355005,-0.007414364,-0.06474103,0.1548086),vec4(0.098692074,-0.13003309,0.18797454,0.07666673),vec4(-0.2695193,-0.13659687,-0.00040328456,0.07199165),vec4(-0.2083818,0.018321957,-0.04758939,0.0546595)) * bufB[7] + mat4(vec4(-0.4308543,-0.16847083,-0.45173422,-0.23054941),vec4(-0.26304105,-0.016052289,0.09081197,0.047166128),vec4(-0.08319897,0.14376728,-0.0007394325,-0.06304774),vec4(-0.16795291,-0.13078274,0.11857041,-0.21474014)) * bufB[8] + mat4(vec4(0.015767448,0.028024413,-0.038902737,-0.09092063),vec4(0.17530054,0.029508281,0.101071954,0.010654066),vec4(-0.18077987,0.20408982,0.017924896,-0.04629602),vec4(-0.031264663,0.14265248,-0.26885894,-0.04991688)) * bufB[9] + mat4(vec4(-0.15157266,0.35547143,-0.18765356,-0.055548783),vec4(0.113825195,0.022816785,0.18431108,-0.11593723),vec4(0.2543015,0.26419047,-0.034840617,-0.1245268),vec4(0.0053379973,0.06335608,-0.19199643,-0.10549363)) * bufB[10] + mat4(vec4(0.34671843,-0.04939604,0.06874615,0.10354186),vec4(-0.26698536,0.51385665,0.27384952,0.1833643),vec4(0.17355357,-0.09189842,-0.336821,-0.24192972),vec4(-0.44883862,0.41853386,0.0485977,0.023623114)) * bufB[11];\nbufA[1] = vec4(-0.11042554,-0.3613166,-0.3915904,-0.108756036) + mat4(vec4(-0.1694329,-0.0086092325,-0.18934247,0.11113435),vec4(-0.021440247,0.19260944,0.12592801,0.15612642),vec4(0.068732925,-0.052587286,-0.008413262,-0.08407729),vec4(-0.17916434,0.00047823423,-0.2759183,0.10973543)) * bufB[0] + mat4(vec4(-0.28595474,0.07634437,-0.19062813,-0.057904944),vec4(0.1433122,0.105556086,0.26977718,0.29794195),vec4(0.048346348,-0.073493436,-0.009376225,0.039277017),vec4(0.08108639,0.07277154,0.011547085,-0.069194525)) * bufB[1] + mat4(vec4(-0.12149514,-0.10990226,-0.043178406,0.040932775),vec4(0.017797196,0.055147294,-0.022485303,-0.012406465),vec4(-0.059673034,0.089688204,0.25537738,0.1499533),vec4(0.26539546,-0.31810614,-0.2123063,-0.114645645)) * bufB[2] + mat4(vec4(-0.011825495,-0.060546476,-0.108433075,-0.08298171),vec4(0.15726742,-0.13413903,0.17265141,0.093740396),vec4(-0.043233834,0.16673788,0.111610256,-0.28351012),vec4(0.0376306,-0.15126786,0.04499486,-0.023913134)) * bufB[3] + mat4(vec4(0.15053856,0.27895764,-0.14976342,0.28059244),vec4(-0.06839616,-0.008773333,0.034179002,0.030918848),vec4(-0.078818984,-0.014945071,-0.09983405,0.17897429),vec4(0.17945224,0.040469944,0.012236986,0.018311618)) * bufB[4] + mat4(vec4(-0.014364302,0.11574879,0.23432413,-0.18910569),vec4(-0.010353943,-0.11250357,0.09583161,0.48836556),vec4(0.009543921,-0.45151132,-0.12331554,-0.14112991),vec4(-0.0588009,0.041949812,-0.19673333,0.03593035)) * bufB[5] + mat4(vec4(-0.11821108,-0.14497091,-0.36560774,0.23823945),vec4(0.15762964,0.12657213,-0.08372036,0.07776346),vec4(-0.024832847,0.16562447,0.28348893,0.14217013),vec4(0.24799049,-0.21941206,-0.0076540885,-0.07135525)) * bufB[6] + mat4(vec4(-0.36157262,-0.7706866,-0.38762698,-0.40600288),vec4(-0.0091082975,0.23942642,0.05103008,-0.15022027),vec4(-0.09730869,0.010854373,-0.05014297,0.01819998),vec4(-0.25781584,0.25582296,0.024004508,-0.072087385)) * bufB[7] + mat4(vec4(-0.28774923,0.26924485,-0.07452933,-0.043001052),vec4(0.20239879,0.018106192,-0.024569536,0.109385595),vec4(0.10304223,0.11018852,-0.050644737,0.1855329),vec4(-0.07482047,-0.21586849,0.19241786,-0.1192927)) * bufB[8] + mat4(vec4(-0.025482243,0.21184333,-0.058982417,0.027718272),vec4(0.31832358,0.12374764,0.33167535,0.32221332),vec4(0.27126333,0.14596672,0.10600555,0.15015595),vec4(0.12959966,-0.14523187,-0.22944875,-0.1326855)) * bufB[9] + mat4(vec4(-0.3879808,-0.53676367,-0.32670557,0.22255646),vec4(0.04920609,0.099901594,0.21108873,0.0784597),vec4(0.28735068,0.02913539,0.37410015,0.5160384),vec4(0.14365855,-0.10860802,-0.09331706,-0.06548659)) * bufB[10] + mat4(vec4(0.09883455,0.11058238,0.2702247,-0.070269756),vec4(0.16610461,-0.1925303,-0.3236311,0.15513183),vec4(-0.17398646,0.08262255,0.10092964,-0.077937186),vec4(-0.3527817,-0.0866756,-0.38213772,-0.1823378)) * bufB[11];\nbufA[2] = vec4(0.10748512,-0.28536895,0.22700334,-0.48431927) + mat4(vec4(-0.05077694,-0.3075281,-0.12874472,0.01875722),vec4(-0.0770795,-0.29002362,0.061728653,-0.12638919),vec4(0.0050164913,0.12880737,0.020608231,0.0886208),vec4(-0.05275384,-0.18137325,-0.1469371,0.0011290475)) * bufB[0] + mat4(vec4(0.07021946,-0.012446797,-0.20062935,0.18350412),vec4(-0.058283832,-0.1520239,0.18622112,-0.022279676),vec4(0.0028707725,0.041490328,-0.017196713,0.042981282),vec4(-0.0136224935,0.28324488,-0.07174148,-0.0043136324)) * bufB[1] + mat4(vec4(0.559514,-0.0025920318,-0.043126702,0.11615324),vec4(0.07293056,-0.070605405,0.035385355,-0.013544607),vec4(0.023878448,0.4822685,-0.13713823,-0.06323729),vec4(-0.059462387,-0.34500715,0.2066834,0.22622724)) * bufB[2] + mat4(vec4(-0.102994666,-0.081656784,-0.004477743,-0.11485748),vec4(0.07141463,0.35562146,-0.19822212,-0.109622926),vec4(0.10943555,0.042148244,0.059641853,0.076469),vec4(-0.05354979,0.20515408,0.11875017,0.12617388)) * bufB[3] + mat4(vec4(-0.20502043,0.30968797,-0.3903796,-0.10000828),vec4(-0.18710597,0.08231571,0.13659616,0.11978492),vec4(-0.18577677,-0.22907679,-0.02146516,0.013089974),vec4(-0.19476701,-0.07046624,-0.1802558,-0.020294262)) * bufB[4] + mat4(vec4(0.183804,-0.0004125969,-0.0890627,-0.15970992),vec4(-0.13755791,-0.0009800697,0.14227745,0.17057016),vec4(0.0056189587,0.030535955,-0.26129425,-0.26947483),vec4(0.18661019,-0.057024058,-0.012056802,-0.16664678)) * bufB[5] + mat4(vec4(-0.11310559,-0.108064845,-0.009812803,0.0349237),vec4(0.028280923,0.19336514,-0.01858662,-0.08064881),vec4(0.31333205,0.0005613307,0.014583529,-0.04969716),vec4(0.3937308,-0.08542153,-0.06974765,-0.36035064)) * bufB[6] + mat4(vec4(0.09755663,-0.57642627,-0.07220999,-0.1770399),vec4(0.5889793,0.168763,0.3699386,0.19513993),vec4(0.08094438,-0.03699607,0.15606162,0.02462925),vec4(-0.28282633,-0.39724198,-0.03940519,0.20302613)) * bufB[7] + mat4(vec4(-0.27926695,-0.33647513,-0.18972288,0.12736252),vec4(0.007252414,-0.115156956,0.10799244,-0.12338129),vec4(-0.10751258,-0.14767031,0.07382736,-0.04039178),vec4(-0.2274303,0.37549743,-0.6923698,0.14881258)) * bufB[8] + mat4(vec4(0.05403319,0.2325825,0.047600053,0.03014086),vec4(-0.23727274,0.12807931,-0.7508074,0.12440035),vec4(0.27497327,-0.39590335,-0.15373677,-0.16707362),vec4(0.37181982,0.005052632,-0.088509984,-0.15940458)) * bufB[9] + mat4(vec4(-0.29451743,-0.6240163,-0.47188547,0.18523628),vec4(-0.14480369,0.099104464,-0.26696098,0.04187165),vec4(0.43712577,0.018199503,0.019877248,-0.03504268),vec4(0.05551629,0.13224286,-0.4153322,-0.063373536)) * bufB[10] + mat4(vec4(0.12039528,0.12375869,0.21082549,-0.22086313),vec4(-0.17943306,0.050068382,0.080408305,0.19506058),vec4(0.24914406,0.25200635,0.12545197,0.20045783),vec4(-0.11729703,0.06295639,-0.33790275,0.45658728)) * bufB[11];\nbufA[3] = vec4(0.48496297,-0.48208132,0.14779058,-0.2060584) + mat4(vec4(0.0807299,-0.016255395,-0.08682517,0.122672334),vec4(0.045796566,0.12482401,0.2300672,0.13378099),vec4(-0.0065366067,-0.4172724,-0.15330125,-0.13203898),vec4(0.10964489,0.2999492,0.049417768,-0.08098432)) * bufB[0] + mat4(vec4(0.651732,0.029048309,-0.1369064,0.015210026),vec4(0.050197143,0.121646106,0.22110161,0.519073),vec4(0.016984753,0.012036821,0.021558294,0.06946952),vec4(-0.26425663,0.46157643,0.16065904,0.034025192)) * bufB[1] + mat4(vec4(0.38207266,0.04341728,-0.094466805,-0.00764221),vec4(0.026467068,0.054358236,-0.055860203,0.015717316),vec4(-0.0027147837,0.33131972,0.19695242,-0.10444816),vec4(-0.34380448,-0.14918736,0.42344978,-0.45481265)) * bufB[2] + mat4(vec4(0.010493522,0.21664776,-0.15084645,-0.024559706),vec4(0.22519973,0.21507172,0.020479986,-0.052524783),vec4(0.083346024,-0.10877781,-0.018578414,-0.24867195),vec4(-0.020727614,-0.19303665,0.026857058,0.21114832)) * bufB[3] + mat4(vec4(0.10667512,0.24848706,-0.041754592,0.1845053),vec4(-0.106063016,-0.24386242,0.17885359,-0.24302788),vec4(0.101508275,-0.0497108,-0.055977933,-0.36275524),vec4(-0.13703918,-0.15560812,0.027769966,0.22057422)) * bufB[4] + mat4(vec4(-0.21139632,0.16736051,0.23018488,0.14775096),vec4(0.27999714,-0.06404173,0.3148508,-0.10582382),vec4(-0.018168736,0.1941506,-0.5064811,-0.109888546),vec4(0.08189953,0.04588102,-0.04452446,0.18645056)) * bufB[5] + mat4(vec4(0.10750057,0.07934788,-0.26892754,0.025789991),vec4(0.31637773,0.13962679,0.014956766,-0.1953371),vec4(0.045874998,0.0010192823,-0.038948115,-0.16246316),vec4(0.11044436,-0.041277617,-0.14734769,0.3336364)) * bufB[6] + mat4(vec4(-0.4863963,0.0720101,-0.5286002,0.111130856),vec4(0.31404242,0.07292488,0.2983487,-0.50148743),vec4(-0.06801076,-0.23795676,-0.041033827,-0.36988556),vec4(-0.07755719,-0.07662039,0.22410437,-0.03374076)) * bufB[7] + mat4(vec4(-0.12783326,-0.28611028,0.003368851,-0.0372288),vec4(0.0066378727,-0.3434898,-0.25761804,-0.0054286434),vec4(0.0012103741,-0.13358591,-0.011530521,-0.0036150487),vec4(-0.11176714,0.08463274,-0.3745869,0.44179022)) * bufB[8] + mat4(vec4(0.031753138,-0.30835974,0.14198661,0.13263045),vec4(0.13479038,0.017189294,0.035898983,-0.048483104),vec4(0.20119524,0.21150823,0.1510849,0.37693277),vec4(0.07440551,0.06273823,-0.016112003,0.05731475)) * bufB[9] + mat4(vec4(0.05001962,-0.23852664,-0.09518391,0.12411597),vec4(-0.15655167,0.10805072,0.08194649,-0.020813165),vec4(0.3192705,0.18154018,0.2637251,0.25625065),vec4(-0.2475502,0.057433475,-0.06647896,0.22061822)) * bufB[10] + mat4(vec4(-0.25779802,0.027098596,9.654451e-05,0.07990159),vec4(-0.090820864,-0.26499173,-0.06490599,-0.54846376),vec4(0.22861333,-0.39215058,0.6676482,0.20786041),vec4(0.062139012,-0.3597324,-0.3229075,-0.06404405)) * bufB[11];\nbufA[4] = vec4(0.43927768,-0.05537547,-0.5715141,-0.3348312) + mat4(vec4(0.2053627,0.15609996,-0.078503005,0.08708054),vec4(0.078359045,-0.07134311,-0.048736658,-0.030160999),vec4(-0.015672378,0.032209754,0.017167063,0.0353785),vec4(0.107705094,0.0887656,-0.052843153,0.20842186)) * bufB[0] + mat4(vec4(-0.20800076,-0.029834924,0.08119281,0.02444671),vec4(0.5610348,0.1371762,0.083169274,0.040719915),vec4(0.019644001,-0.037618823,0.025608467,-0.014222532),vec4(-0.024052218,-0.05656874,0.016015848,-0.12270593)) * bufB[1] + mat4(vec4(-0.15388778,-0.005349972,0.0028554564,0.011869188),vec4(0.0046891877,-0.052290622,-0.0017047249,0.12894472),vec4(-0.023170542,-0.1829165,0.011473742,-0.1489692),vec4(0.40957242,-0.26750237,-0.17292759,-0.13628465)) * bufB[2] + mat4(vec4(0.046315446,0.08549031,0.08578834,0.09255165),vec4(-0.021432495,-0.082500756,-0.05094999,0.18429586),vec4(-0.20250942,-0.08018426,-0.21115187,-0.034511045),vec4(-0.019707013,0.22313444,-0.065257646,-0.18433277)) * bufB[3] + mat4(vec4(0.07882422,0.16930237,0.09477909,0.006382621),vec4(-0.10936819,0.01163064,0.025114238,0.0064569553),vec4(0.17986636,-0.052466583,-0.27044305,0.24487595),vec4(0.22161461,0.26142547,0.06459924,0.15356371)) * bufB[4] + mat4(vec4(0.12330314,-0.32273102,-0.046665974,0.12390164),vec4(0.1989602,-0.15741765,-0.3592819,-0.33944574),vec4(-0.24157438,-0.009790628,0.06405344,-0.101944335),vec4(0.052758384,0.22773157,-0.03178734,0.1619014)) * bufB[5] + mat4(vec4(0.327932,-0.059372433,-0.16130184,-0.15087119),vec4(-0.18902873,0.06602547,0.11944713,-0.29820263),vec4(0.17208056,0.022715546,-0.24550201,0.050354503),vec4(0.3555477,0.018806929,0.23651396,-0.031584114)) * bufB[6] + mat4(vec4(0.049231827,-0.28051287,0.06604147,0.023654368),vec4(-0.46320227,0.18918534,0.05399238,-0.21303482),vec4(-0.07748241,0.14610402,-0.045630053,-0.024770774),vec4(-0.16166195,0.22355257,-0.04026338,0.24876063)) * bufB[7] + mat4(vec4(-0.07774542,0.10495106,0.24099469,0.5331646),vec4(-0.09677833,-0.07452388,-0.01563861,0.07138597),vec4(0.022458473,0.22664344,-0.111513264,0.09766004),vec4(-0.032395605,-0.034040894,0.49522266,0.32250512)) * bufB[8] + mat4(vec4(-0.08046602,-0.10692762,-0.06498317,0.095432594),vec4(-0.0005239821,-0.08654838,-0.04641946,0.2222349),vec4(0.25516513,0.09365388,-0.030676588,0.15263829),vec4(-0.39909723,-0.19659705,-0.021438545,-0.28743795)) * bufB[9] + mat4(vec4(-0.13493928,-0.07077619,0.31399903,0.33748674),vec4(0.22322722,-0.09643814,0.053391997,-0.024600785),vec4(0.30225396,-0.21860142,-0.0064673703,-0.111273855),vec4(-0.045626875,-0.19095488,0.17493896,0.08461874)) * bufB[10] + mat4(vec4(0.13859583,0.09618694,-0.060644384,0.19480318),vec4(-0.4803476,-0.07106539,-0.39453584,-0.28078073),vec4(0.06740638,0.17173086,0.16330265,0.16569117),vec4(-0.46066236,0.2252776,0.26149255,0.07606597)) * bufB[11];\nbufA[5] = vec4(-0.1612496,0.47478086,-0.59087306,0.24331261) + mat4(vec4(0.034047738,-0.26126197,-0.095822886,-0.15656257),vec4(0.00043889834,0.0081322435,0.09753794,-0.0017179872),vec4(-0.18547034,0.046790227,0.09020809,-0.046325684),vec4(-0.11676138,-0.15765584,0.08730406,-0.10809515)) * bufB[0] + mat4(vec4(-0.26009062,-0.404346,0.21470071,-0.14855948),vec4(-0.0313217,-0.12466618,0.17492314,-0.30133694),vec4(0.04070191,0.048233587,-0.08521938,0.04165057),vec4(0.108365,-0.118963614,0.13296501,-0.033821136)) * bufB[1] + mat4(vec4(-0.09750399,-0.05212826,-0.11232799,0.06943693),vec4(-0.020804657,-0.058344543,0.015282819,0.0071310247),vec4(0.10941868,0.075506076,-0.106508344,0.023585796),vec4(-0.25755584,-0.026743613,0.18101257,-0.11501518)) * bufB[2] + mat4(vec4(0.052590035,-0.18544842,0.17174931,-0.045636173),vec4(0.047484796,-0.027868414,-0.06964162,0.0798962),vec4(0.113142006,-0.12664644,0.012075718,0.03613817),vec4(0.3582991,-0.01725191,-0.1571808,-0.26254863)) * bufB[3] + mat4(vec4(-0.32972616,0.05348456,-0.068282224,-0.00829941),vec4(-0.07253647,-0.07435266,0.16216895,-0.061122265),vec4(-0.0034354825,-0.00904955,-0.045059867,0.3353391),vec4(0.055070754,0.37132835,-0.15020993,-0.11789313)) * bufB[4] + mat4(vec4(0.15376355,0.5041216,0.028528392,-0.061861373),vec4(0.21659791,-0.22563313,-0.31771612,0.30736706),vec4(-0.12242334,-0.02656547,0.21132202,-0.060852688),vec4(0.051838584,-0.19420736,-0.14977883,-0.054468952)) * bufB[5] + mat4(vec4(-0.23801738,0.000613143,-0.24813466,0.0028982752),vec4(-0.16481367,-0.30418238,-0.26191396,0.3775593),vec4(-0.26539478,-0.07758682,-0.17367025,0.23049006),vec4(-0.15073474,0.14939877,-0.010240628,0.07537488)) * bufB[6] + mat4(vec4(-0.053510074,0.47682497,-0.085475154,-0.16980936),vec4(0.025699355,-0.37364537,-0.51176536,0.35867816),vec4(0.117135584,0.0092632305,0.28013295,0.027401427),vec4(-0.13201857,-0.1234066,-0.15646866,-0.03715032)) * bufB[7] + mat4(vec4(0.02215492,-0.19130819,0.026558045,-0.19883543),vec4(-0.021417348,0.28578478,-0.029376296,-0.13258076),vec4(0.27470958,-0.17912915,0.20741375,-0.12129567),vec4(-0.0763838,-0.20143625,-0.36073157,0.097257465)) * bufB[8] + mat4(vec4(-0.066034034,0.3178504,0.0035562278,-0.16817646),vec4(-0.14760506,0.020104393,-0.39261764,0.17760472),vec4(0.11904505,-0.2647599,-0.19468372,0.09530704),vec4(-0.11346664,0.4534776,0.23806661,-0.124411)) * bufB[9] + mat4(vec4(-0.38719538,-0.019763077,0.016512552,0.4094739),vec4(0.26620838,-0.10421927,-0.2910159,-0.105250716),vec4(-0.09149254,0.11258795,-0.120675676,-0.19285722),vec4(0.052101575,0.20665494,-0.04036976,-0.054620285)) * bufB[10] + mat4(vec4(0.369441,0.21247804,0.20766221,-0.55232686),vec4(-0.28195602,-0.18559413,-0.33476678,-0.07203607),vec4(0.2638775,-0.39536285,0.034975186,0.016643288),vec4(0.23335247,-0.021728452,0.21569769,-0.05319694)) * bufB[11];\ntmp = sin(bufA[0]);\nbufB[0] = tmp/0.67;\nbufB[6] = (tmp*tmp) / 0.6;\ntmp = sin(bufA[1]);\nbufB[1] = tmp/0.67;\nbufB[7] = (tmp*tmp) / 0.6;\ntmp = sin(bufA[2]);\nbufB[2] = tmp/0.67;\nbufB[8] = (tmp*tmp) / 0.6;\ntmp = sin(bufA[3]);\nbufB[3] = tmp/0.67;\nbufB[9] = (tmp*tmp) / 0.6;\ntmp = sin(bufA[4]);\nbufB[4] = tmp/0.67;\nbufB[10] = (tmp*tmp) / 0.6;\ntmp = sin(bufA[5]);\nbufB[5] = tmp/0.67;\nbufB[11] = (tmp*tmp) / 0.6;\nbufA[0] = vec4(-0.29800296,-0.057429004,-0.43015394,-0.070755616) + mat4(vec4(-0.009321935,0.21206418,-0.054143123,0.05752704),vec4(-0.3327234,-0.20315257,0.21750227,-0.2917466),vec4(-0.15724573,-0.19922061,0.16480398,-0.30620897),vec4(0.05408647,-0.16433246,0.4428423,0.23254025)) * bufB[0] + mat4(vec4(-0.039246142,-0.08053406,0.018179994,-0.029781336),vec4(-0.105505906,0.06988533,0.04004989,0.3512667),vec4(0.08484138,-0.050388288,0.10598883,0.03936612),vec4(-0.070555024,0.04389824,-0.14592513,-0.14688732)) * bufB[1] + mat4(vec4(0.039523832,-0.016309861,-0.14246435,-0.13863975),vec4(-0.036864385,0.27029327,0.1131075,0.26981083),vec4(0.22052738,0.0058679692,0.22869183,-0.054938115),vec4(0.25962725,0.0017771254,0.40275174,0.20949146)) * bufB[2] + mat4(vec4(-0.09180624,0.12873916,-0.14027046,0.07132523),vec4(-0.118532024,0.036699083,0.190364,-0.14022847),vec4(0.2284956,-0.3046464,-0.07962626,0.012319475),vec4(0.02283018,-0.014508367,-0.075778455,0.08263764)) * bufB[3] + mat4(vec4(0.16883282,-0.103574455,0.059035324,0.113170676),vec4(-0.26160073,0.21792221,-0.019151326,-0.006880948),vec4(0.022587381,0.21100198,-0.0057703177,0.124957345),vec4(0.11073205,-0.0280399,-0.13872108,-0.08983245)) * bufB[4] + mat4(vec4(0.13652793,-0.045165766,-0.0025994715,-0.17603603),vec4(-0.04881448,0.37504095,-0.099125236,0.048777737),vec4(0.061468426,0.19182727,0.049611587,-0.00397511),vec4(-0.089748174,-0.20888749,-0.019689374,-0.0102018155)) * bufB[5] + mat4(vec4(-0.11882953,0.14845122,-0.039776333,-0.31120613),vec4(0.04604087,-0.05203928,-0.0729873,-0.30964082),vec4(-0.20553175,0.050242368,-0.20616052,-0.07717726),vec4(0.15091044,-0.5583984,0.012647602,0.08866132)) * bufB[6] + mat4(vec4(-0.32547373,0.02096223,-0.07066527,-0.19761957),vec4(-0.095252074,0.30799568,0.22956723,0.14596055),vec4(-0.21490163,-0.08199913,0.068023264,0.1454266),vec4(0.0042321393,0.25461507,-0.0843192,-0.051393434)) * bufB[7] + mat4(vec4(0.13857837,-0.07819708,0.34630015,0.09681015),vec4(0.30798534,-0.23160326,-0.0021363243,-0.19552176),vec4(0.026689708,-0.015456062,-0.30409178,0.37370136),vec4(-0.113024004,-0.067562975,0.11106699,-0.2375976)) * bufB[8] + mat4(vec4(-0.08987538,0.22430074,0.19836892,0.2692309),vec4(-0.05552184,0.002439555,-0.31674924,-0.101876),vec4(0.25317246,-0.21765435,-0.190113,0.027771931),vec4(-0.2697766,-0.028376812,0.20171833,0.09751034)) * bufB[9] + mat4(vec4(0.10765986,0.040459827,0.2944808,3.8883547e-05),vec4(-0.20681119,0.24645565,-0.3289727,0.01580069),vec4(0.00251147,-0.07627355,-0.1455369,-0.017814768),vec4(-0.24239364,0.17071362,-0.02073503,-0.2197744)) * bufB[10] + mat4(vec4(0.21276571,0.04575838,0.076164745,-0.32053345),vec4(0.08713825,0.20462885,-0.09298447,-0.068769276),vec4(0.0041457666,0.05821113,0.06586019,-0.0062627536),vec4(-0.15591757,0.009454531,-0.054481696,-0.32195684)) * bufB[11] + in0;\nbufA[1] = vec4(0.20062931,-0.58681417,-0.48056316,0.5323595) + mat4(vec4(0.045644004,0.19936223,0.10468797,0.107536495),vec4(0.14645566,-0.082827054,-0.048032492,-0.18008578),vec4(0.020904962,0.10742252,-0.023326982,-0.37026194),vec4(0.066004016,-0.04644888,0.122944385,-0.040753055)) * bufB[0] + mat4(vec4(-0.06034063,-0.026861707,0.17809492,-0.05961468),vec4(-0.19212988,0.13981888,0.004867785,0.09583754),vec4(-0.33316225,-0.028858872,0.102938935,0.13660735),vec4(-0.28418475,0.1466944,0.03395225,0.009749671)) * bufB[1] + mat4(vec4(-0.111822665,-0.069290176,0.19442399,0.18502192),vec4(-0.11694505,0.10011804,-0.114290744,0.15484086),vec4(0.055013806,0.05731828,-0.17352477,0.34544802),vec4(-0.46498963,0.20591277,-0.019981066,-0.010752391)) * bufB[2] + mat4(vec4(-0.1312443,0.26060456,0.112386495,0.18310846),vec4(0.229395,-0.2717986,-0.043998014,-0.06018507),vec4(0.097242415,-0.086978436,0.091314435,-0.111750275),vec4(-0.105332315,-0.10318518,-0.069155425,-0.021099843)) * bufB[3] + mat4(vec4(0.09891736,0.09280151,0.2640804,-0.027210569),vec4(-0.020080758,0.47444192,0.1616639,-0.19168928),vec4(0.0071306024,0.07453076,-0.008157726,0.061166838),vec4(0.227275,0.11380574,0.21375264,-0.19330953)) * bufB[4] + mat4(vec4(0.13401283,0.02985999,-0.023703756,-0.01096152),vec4(-0.20211044,-0.2852017,-0.16527492,-0.11274341),vec4(0.14045604,0.15625116,0.013776935,-0.020938361),vec4(0.02061359,-0.26588494,0.14548717,0.07105866)) * bufB[5] + mat4(vec4(-0.15283445,-0.015869817,0.15415129,-0.2777692),vec4(-0.18914562,-0.015369333,0.04180956,-0.18208607),vec4(-0.45946485,0.00985118,-0.25353298,0.028195867),vec4(-0.13581322,-0.06630898,0.16370323,0.024175165)) * bufB[6] + mat4(vec4(-0.10857557,0.010323985,-0.16258995,-0.1959815),vec4(0.13784763,-0.112652116,-0.1190366,0.1390835),vec4(-0.1862665,-0.13374047,0.0912048,-0.13832906),vec4(0.1293803,-0.14662986,0.12112856,0.16873199)) * bufB[7] + mat4(vec4(0.27805752,-0.13712151,-0.22187619,0.1575422),vec4(0.17198,0.22233832,0.21662895,0.0713709),vec4(0.00071656494,0.14119017,-0.1412986,0.20430955),vec4(-0.08776854,0.071917824,0.095390424,-0.19322939)) * bufB[8] + mat4(vec4(0.1168837,-0.21809089,0.10729743,-0.070968315),vec4(-0.12483827,0.18986553,-0.11192812,0.10767615),vec4(0.040525284,-0.020695966,0.45951414,-0.053180054),vec4(-0.33775166,-0.06127381,-0.14443164,-0.06817337)) * bufB[9] + mat4(vec4(-0.22706339,0.07450527,-0.18356161,-0.47269362),vec4(0.34781593,-0.63365346,0.1914592,-0.13139002),vec4(-0.0017361005,0.03717994,0.28541797,0.16696645),vec4(-0.041637037,-0.25093547,-0.13167436,0.04411775)) * bufB[10] + mat4(vec4(0.21805511,-0.13517728,0.01774395,-0.2871401),vec4(-0.12112223,-0.26211736,0.37838814,-0.38103276),vec4(-0.059762157,-0.3221661,-0.05137591,-0.07870052),vec4(-0.08686834,-0.4526763,-0.120465845,-0.13401)) * bufB[11] + in1;\nbufA[2] = vec4(-0.36717427,0.2599014,0.071981326,-0.31264994) + mat4(vec4(-0.14874259,0.08580208,-0.082896486,-0.20700398),vec4(0.051598188,0.11642735,-0.05618202,-0.100474745),vec4(-0.060037788,0.38450477,-0.21524939,0.012902681),vec4(0.10194957,0.07012135,0.22397405,0.08073755)) * bufB[0] + mat4(vec4(-0.29580572,0.077968225,0.08800787,0.01862903),vec4(-0.2531083,0.011833279,-0.17869134,-0.18722004),vec4(-0.23945786,0.06385516,0.068832986,0.17356567),vec4(0.2204893,0.35205907,-0.32761422,0.30989543)) * bufB[1] + mat4(vec4(0.32500446,-0.04112052,-0.15449762,-0.023271652),vec4(-0.085950114,-0.012134485,0.15019323,-0.12820815),vec4(0.20877735,0.13617073,-0.05848982,0.08246278),vec4(-0.17402971,-0.040752545,-0.10968598,-0.021082832)) * bufB[2] + mat4(vec4(-0.015191933,0.3256184,-0.20834497,-0.35486257),vec4(-0.01592537,0.1609962,0.0022748383,0.39312318),vec4(0.059988696,-0.19003737,0.054986574,0.16964711),vec4(-0.4519519,0.13709213,0.0829107,-0.14814414)) * bufB[3] + mat4(vec4(-0.22540666,-0.19238196,-0.03523435,-0.3097139),vec4(-0.3133516,0.19580968,-0.26365858,-0.13073902),vec4(-0.19592838,0.30739444,0.075118706,-2.3218687e-05),vec4(-0.0850642,0.2966645,-0.114679165,-0.19362792)) * bufB[4] + mat4(vec4(-0.12083301,-0.053306792,-0.0013561707,-0.21736354),vec4(0.042291775,-0.31846994,0.14313388,-0.039404027),vec4(-0.098983034,0.07950398,0.10394747,-0.14367925),vec4(-0.15135615,0.11271766,-0.29968634,-0.13745414)) * bufB[5] + mat4(vec4(-0.020935625,0.02087713,-0.08223088,0.18422174),vec4(0.21252878,0.1811338,0.09539033,0.10183604),vec4(0.086212896,-0.23153104,-0.1460258,-0.06904767),vec4(-0.34962705,0.041463953,-0.009694139,0.036130182)) * bufB[6] + mat4(vec4(0.053327426,0.022878433,-0.10394775,0.045637507),vec4(0.61372185,-0.04048966,-0.08319743,0.36310795),vec4(0.27931333,0.30986375,-0.107609734,-0.03113639),vec4(0.13113052,-0.2581112,0.09836136,-0.13991353)) * bufB[7] + mat4(vec4(-0.33357802,0.19674592,-0.05187345,0.28531155),vec4(0.036387946,-0.16307405,0.31976745,-0.09829232),vec4(0.120050184,-0.20803668,0.07112819,-0.22442405),vec4(0.048666395,-0.34762883,-0.4343136,0.031513277)) * bufB[8] + mat4(vec4(0.44944352,-0.4872101,0.16362843,-0.05963878),vec4(-0.21306425,-0.116928734,-0.22862543,-0.2420472),vec4(-0.064058766,-0.17624162,-0.08566116,0.26585948),vec4(-0.16974749,0.2629922,-0.09797349,-0.07189723)) * bufB[9] + mat4(vec4(-0.3627748,0.14245316,-0.13287842,-0.07226549),vec4(-0.23266359,0.120404944,-0.08631193,-0.11974015),vec4(0.14257894,0.17595199,-0.046284683,-0.029340925),vec4(0.08647455,-0.181531,0.15558232,0.123778574)) * bufB[10] + mat4(vec4(0.08013029,-0.07999447,-0.046305887,0.20538864),vec4(0.20740904,-0.30488342,0.224849,-0.110743746),vec4(0.24671656,-0.26487324,0.1717565,-0.13669349),vec4(0.5384051,-0.16064987,0.028886953,-0.024257846)) * bufB[11] + in2;\nbufA[3] = vec4(-0.34041506,0.026641706,0.4189677,0.3309388) + mat4(vec4(-0.09434505,0.30164474,-0.14164592,-0.07512796),vec4(-0.06945608,-0.110470295,0.16080277,-0.006982946),vec4(0.26495117,-0.20232251,-0.14035024,0.13998277),vec4(-0.049638998,0.60203826,-0.0066408613,0.13034056)) * bufB[0] + mat4(vec4(-0.07758346,0.2842614,-0.08353545,-0.2594826),vec4(0.21129306,0.12769416,-0.25310773,-0.09400617),vec4(-0.06496015,0.29523012,-0.07397725,-0.13712595),vec4(-0.009459969,-0.18550467,-0.085789,0.019351909)) * bufB[1] + mat4(vec4(0.019476691,0.17499249,-0.068832345,0.0028708433),vec4(0.074598216,0.07819043,-0.07240924,-0.2220341),vec4(-0.26251394,0.24165687,0.0016373633,0.04769911),vec4(-0.13641562,-0.097283155,-0.12767908,0.31783816)) * bufB[2] + mat4(vec4(0.31448263,0.21755385,-0.08347012,0.052943043),vec4(0.045170724,-0.18137915,-0.10501174,-0.05583726),vec4(-0.08964672,0.0567563,0.34119514,0.3093285),vec4(0.23067483,-0.0535583,-0.12920566,0.16044462)) * bufB[3] + mat4(vec4(0.1458902,0.29976565,0.16292644,-0.10806832),vec4(0.16870095,-0.038259726,-0.013016807,-0.17296988),vec4(-0.053591978,-0.008377749,-0.33120447,-0.010116433),vec4(0.043906022,-0.07702437,-0.19481902,0.06291485)) * bufB[4] + mat4(vec4(-0.026940988,0.12297669,-0.18756989,-0.024149582),vec4(-0.42535532,-0.0048242547,-0.0062320456,-0.07210225),vec4(0.079360865,-0.02437455,-0.21246214,0.05461079),vec4(-0.10115954,-0.058944497,0.05938697,0.17052492)) * bufB[5] + mat4(vec4(0.15351133,-0.15202242,0.25901118,0.28250054),vec4(-0.03210563,-0.14553808,0.17196946,0.28473118),vec4(-0.0805307,-0.5118844,-0.77027607,-0.07136955),vec4(-0.088483095,-0.24062555,0.09821665,-0.09704911)) * bufB[6] + mat4(vec4(-0.065539345,0.23162688,-0.30824256,0.12708561),vec4(0.1028257,0.06342322,0.09015984,0.15031028),vec4(0.09754881,-0.34437284,-0.17990336,-0.0986077),vec4(0.3194886,-0.07391393,0.21798359,-0.047532033)) * bufB[7] + mat4(vec4(0.22378643,-0.21987246,0.14975078,0.006511831),vec4(0.10183047,-0.36876464,0.3225052,-0.013005145),vec4(0.22501631,0.2132539,-0.19648498,-0.3348602),vec4(-0.310537,0.04695055,0.18323079,-0.11716093)) * bufB[8] + mat4(vec4(-0.24878445,-0.15331574,0.42058498,0.03935702),vec4(0.06744448,0.042812385,0.0219723,-0.07711253),vec4(0.019573847,0.49920708,0.22325034,-0.32224846),vec4(0.085732974,-0.50988704,-0.16552864,-0.09302955)) * bufB[9] + mat4(vec4(-0.102518834,-0.3583608,-0.35802102,-0.11080823),vec4(-0.083519824,0.2571916,-0.07692749,-0.010193301),vec4(0.008982782,0.19096546,0.24748524,0.06123349),vec4(0.09281084,0.15797517,0.4885967,-0.15501302)) * bufB[10] + mat4(vec4(0.3537814,-0.10815751,-0.07715537,0.1899457),vec4(-0.23192331,0.047267944,0.17756051,-0.30518326),vec4(-0.19427998,-0.07092472,-0.09743862,0.25365564),vec4(-0.10206906,-0.046631005,0.019306883,-0.079560794)) * bufB[11] + in3;\nbufA[4] = vec4(0.14049125,0.31442606,0.51147753,-0.43801707) + mat4(vec4(-0.18113989,0.18597904,-0.20890895,-0.09111851),vec4(0.18189074,0.09125845,0.014538641,-0.15126733),vec4(0.06412085,0.04376542,0.10314968,-0.13805877),vec4(-0.23666798,-0.18541856,-0.13752632,0.33012772)) * bufB[0] + mat4(vec4(0.030434804,-0.06378335,-0.20337471,0.0767139),vec4(0.2561368,-0.2627302,0.01706115,0.19958346),vec4(-0.0053733233,0.004272837,-0.15315545,-0.08712184),vec4(-0.12323712,0.15734418,-0.14833125,-0.058316696)) * bufB[1] + mat4(vec4(0.036095552,-0.17137894,-0.20988093,-0.39690775),vec4(0.030633697,-0.044691045,0.14325279,0.038031954),vec4(-0.21035424,0.26628286,-0.28422585,-0.022476811),vec4(0.39479432,0.23487422,0.08814459,0.23446822)) * bufB[2] + mat4(vec4(0.11680594,0.31096667,-0.2424065,-0.30012795),vec4(-0.044646677,0.18251345,-0.023607476,-0.30862248),vec4(-0.060371988,-0.14546767,-0.18730834,-0.04602435),vec4(0.17760146,0.1660486,0.07580534,-0.023007073)) * bufB[3] + mat4(vec4(-0.18425427,0.16137803,0.078742415,-0.22223935),vec4(0.105341844,0.081974655,-0.16732441,0.19987084),vec4(0.06730593,-0.18123826,-0.068745606,0.32222903),vec4(-0.043973263,-0.15031049,0.35194948,0.059717838)) * bufB[4] + mat4(vec4(-0.017820492,-0.110708006,-0.27238706,0.15262157),vec4(0.17552492,-0.28489795,-0.30601674,-0.07819396),vec4(-0.18597902,0.10623268,0.035208303,-0.12278478),vec4(-0.121563934,0.039285053,-0.17263967,-0.16412711)) * bufB[5] + mat4(vec4(0.17735788,0.035947714,0.4070199,-0.12848721),vec4(0.366823,0.2164337,0.009876388,-0.042157974),vec4(0.40212744,0.144572,0.32287726,-0.20407766),vec4(-0.11181595,0.28050244,0.1501183,0.09190688)) * bufB[6] + mat4(vec4(0.15227996,-0.0048027714,0.04043233,0.02396221),vec4(-0.116347544,0.063267946,-0.016932748,-0.26728052),vec4(-0.033779576,-0.111047395,0.046094082,-0.017784841),vec4(0.109087415,0.27570882,0.39686522,-0.3260096)) * bufB[7] + mat4(vec4(-0.1017546,0.5362336,-0.21101831,-0.2796653),vec4(-0.041402612,0.13351145,0.14615965,0.26528466),vec4(0.031522684,0.15577595,0.3259504,-0.01739301),vec4(0.17378831,-0.12740855,-0.1528932,-0.13197087)) * bufB[8] + mat4(vec4(0.005922094,-0.27434003,0.23660159,0.04821723),vec4(0.14406848,0.023989223,0.03982692,0.13942692),vec4(-0.19208704,-0.08481029,-0.19319393,-0.046362247),vec4(0.12721108,-0.08212758,0.09514126,0.17030604)) * bufB[9] + mat4(vec4(0.122196056,0.049348634,0.46279955,-0.13748543),vec4(0.018721858,0.1484655,-0.13379246,0.072675034),vec4(-0.089137875,-0.023930153,0.07202505,-0.21725084),vec4(-0.13114265,0.01066167,-0.5204889,-0.14516543)) * bufB[10] + mat4(vec4(-0.25952765,-0.1806327,0.16945685,-0.049178872),vec4(0.28213426,-0.1438819,-0.3895199,-0.07739513),vec4(0.05907764,-0.16691464,-0.4979725,0.005124491),vec4(0.16268428,-0.17819294,0.13407254,-0.026404515)) * bufB[11] + in0;\nbufA[5] = vec4(0.10274944,-0.41811624,0.020143837,0.14527792) + mat4(vec4(-0.10288628,0.12679626,-0.22195303,-0.08523957),vec4(0.12841982,0.08364419,-0.13322464,-0.26519617),vec4(-0.05547567,0.2508993,-0.09105879,-0.32200786),vec4(0.20971158,-0.1254243,0.1544834,-0.16765416)) * bufB[0] + mat4(vec4(0.19050665,-0.20227955,-0.058376223,-0.07540475),vec4(-0.005051811,-0.045076318,-0.18443362,0.026301682),vec4(0.05672999,0.060167655,-0.09437576,-0.161399),vec4(-0.011662741,0.19338466,-0.2727968,-0.44104707)) * bufB[1] + mat4(vec4(-0.17205487,-0.05104339,-0.14177004,0.08045372),vec4(0.057628598,-0.092090644,-0.097626746,-0.3572813),vec4(-0.2030665,0.08897694,-0.103120126,0.020734513),vec4(0.12822124,0.044908278,0.0018269531,0.25528443)) * bufB[2] + mat4(vec4(0.14884926,0.5187234,-0.34806156,0.08162724),vec4(0.09411319,0.18615282,-0.087451875,0.027073067),vec4(-0.2350535,0.11153011,0.06254864,0.24632639),vec4(0.12145486,0.0028715925,-0.07904443,-0.059494793)) * bufB[3] + mat4(vec4(-0.25241566,0.02575852,0.1302741,0.23590417),vec4(0.061132744,-0.15741512,-0.124970555,-0.12807137),vec4(0.39642105,-0.26945198,0.069614805,-0.16332366),vec4(0.058064446,-0.01659033,0.24053437,0.20441943)) * bufB[4] + mat4(vec4(-0.2150898,0.03283457,0.1390828,0.31008655),vec4(-0.119489856,-0.32038277,0.15230551,-0.08916361),vec4(0.11777643,0.15988606,0.11995346,-0.17915401),vec4(-0.12009141,0.15154418,-0.06729425,0.007349399)) * bufB[5] + mat4(vec4(0.25781885,0.2752682,0.12156864,-0.07204436),vec4(-0.2286077,0.19811179,-0.09417172,0.007012954),vec4(-0.20826554,0.044312727,0.018117517,-0.22938024),vec4(-0.11317589,0.41013217,0.28555572,0.33106607)) * bufB[6] + mat4(vec4(0.19262981,0.11693733,0.19393972,-0.06705901),vec4(0.14596803,0.12036322,0.038223498,0.36152962),vec4(0.30196378,-0.022814572,-0.06358523,0.093458824),vec4(-0.2723206,0.20007384,0.062135324,-0.2890372)) * bufB[7] + mat4(vec4(-0.2001448,0.1021775,-0.08558022,0.20465563),vec4(-0.120104134,0.2576409,0.15957297,0.20308664),vec4(-0.16041693,0.16689008,0.17221941,0.03487402),vec4(0.06852955,0.32850873,0.019811004,0.22734804)) * bufB[8] + mat4(vec4(0.0900664,-0.4809056,0.111697055,-0.15646005),vec4(-0.070675515,-0.25512522,0.3175415,-0.15035902),vec4(0.19632165,-0.07818773,-0.07963539,0.36092097),vec4(-0.19072162,0.22128099,-0.4894261,0.35999122)) * bufB[9] + mat4(vec4(-0.08243489,0.270954,0.14636311,0.49567038),vec4(-0.25542787,0.003961394,0.22121112,0.112349525),vec4(-0.035035346,0.14966288,0.0446289,0.009400371),vec4(0.22715,0.29117668,-0.043392174,0.055806484)) * bufB[10] + mat4(vec4(0.30432612,0.064031795,-0.075526655,-0.05768059),vec4(-0.20091575,-0.27664137,0.092839405,-0.20481533),vec4(-0.04459162,-0.20091954,-0.014079073,0.07681244),vec4(0.13379939,0.10067311,-0.3714341,-0.38466737)) * bufB[11] + in1;\ntmp = sin(bufA[0]);\nbufB[0] = tmp/0.67;\nbufB[6] = (tmp*tmp) / 0.6;\ntmp = sin(bufA[1]);\nbufB[1] = tmp/0.67;\nbufB[7] = (tmp*tmp) / 0.6;\ntmp = sin(bufA[2]);\nbufB[2] = tmp/0.67;\nbufB[8] = (tmp*tmp) / 0.6;\ntmp = sin(bufA[3]);\nbufB[3] = tmp/0.67;\nbufB[9] = (tmp*tmp) / 0.6;\ntmp = sin(bufA[4]);\nbufB[4] = tmp/0.67;\nbufB[10] = (tmp*tmp) / 0.6;\ntmp = sin(bufA[5]);\nbufB[5] = tmp/0.67;\nbufB[11] = (tmp*tmp) / 0.6;\nbufA[0] = vec4(-0.33960775,0.33352587,-0.03862469,0.017725904) + mat4(vec4(-0.32713276,-0.00452508,0.037299544,0.14779939),vec4(0.0013909193,-0.13330457,0.15557396,0.014165729),vec4(0.030202925,-0.0623609,-0.039130844,-0.06816318),vec4(0.3495373,-0.09151927,0.12006217,0.23329872)) * bufB[0] + mat4(vec4(-0.06886464,-0.1303381,0.05269722,-0.46009535),vec4(-0.2849896,0.13839325,0.2865329,-0.26734036),vec4(0.11272881,0.10526324,-0.13030279,-0.11740217),vec4(-0.25282726,-0.021352641,0.040834475,-0.096219294)) * bufB[1] + mat4(vec4(0.13672696,0.23570882,-0.06671984,-0.050188027),vec4(-0.03218894,-0.015767507,-0.13946788,-0.10842674),vec4(0.049050134,0.2210262,-0.06116526,-0.11270522),vec4(0.017943872,0.09059274,0.11621072,0.19601557)) * bufB[2] + mat4(vec4(0.28353658,-0.32594416,-0.3849595,0.01120908),vec4(0.19876808,-0.17977268,-0.14008701,0.05718184),vec4(0.032365866,0.23181793,-0.07500573,-0.042320777),vec4(0.10287459,-0.2506916,0.1952286,0.06026368)) * bufB[3] + mat4(vec4(0.22318238,0.4110799,0.02400308,0.19064105),vec4(-0.05208494,-0.5465357,-0.41862112,0.11488346),vec4(-0.10802396,0.17876382,0.013059625,0.27858564),vec4(0.17694056,-0.3119858,-0.37011254,0.050127216)) * bufB[4] + mat4(vec4(-0.1719174,-0.12585995,-0.17639294,0.096044786),vec4(-0.43411276,-0.11980604,-0.107872106,-0.20381744),vec4(0.061135616,0.30308256,0.08427886,0.033655696),vec4(-0.009095684,0.04694676,-0.15796086,0.07475976)) * bufB[5] + mat4(vec4(-0.20629098,0.049843118,-0.21256422,0.17768465),vec4(0.16875309,0.24063306,-0.20188686,0.07102488),vec4(0.059550695,0.3009824,-0.15338044,-0.19792818),vec4(-0.12595595,0.10713627,0.24046852,-0.10725256)) * bufB[6] + mat4(vec4(0.13077791,0.17005348,0.02084705,0.15286413),vec4(0.05058601,0.23201641,0.037011128,-0.6233119),vec4(-0.069974825,-0.083989814,-0.05702867,0.22430575),vec4(0.043212462,0.09249228,-0.023741791,0.2678585)) * bufB[7] + mat4(vec4(-0.024002902,-0.11284099,0.24684818,0.09991947),vec4(-0.0017261314,0.31704843,0.017222552,-0.17522728),vec4(-0.13760541,0.40674266,-0.061670672,-0.17650391),vec4(-0.08615762,-0.14468242,0.12232804,0.20757821)) * bufB[8] + mat4(vec4(-0.3466889,0.24025838,-0.010761117,0.20684297),vec4(-0.15239966,-0.012767914,0.31555822,0.092653856),vec4(-0.18255584,-0.055808865,0.104619145,0.16735113),vec4(-0.057679467,-0.011461517,0.063418604,0.18404719)) * bufB[9] + mat4(vec4(-0.22081321,-0.1408122,0.19575958,0.10676569),vec4(0.26021627,0.11812705,-0.26331428,0.1563885),vec4(0.031626537,-0.053911287,-0.24315456,0.3184151),vec4(0.05185515,0.09081754,-0.18250455,-0.26310974)) * bufB[10] + mat4(vec4(-0.06374226,0.079915285,0.143179,-0.2663425),vec4(-0.17780009,-0.6761146,0.2597478,0.11705643),vec4(-0.046564315,0.4783778,0.17494667,0.39221668),vec4(-0.23274352,0.11824442,-0.18826559,0.056635134)) * bufB[11];\nbufA[1] = vec4(-0.30142182,-0.34200063,-0.3564083,0.46187526) + mat4(vec4(-0.07787301,-0.017307991,-0.11267015,-0.13501829),vec4(0.005162345,0.15492837,0.1503283,-0.1324512),vec4(0.07358278,0.11697938,0.07077997,-0.033199277),vec4(0.13386801,-0.04447783,0.30642807,0.1105184)) * bufB[0] + mat4(vec4(0.18751901,-0.31157956,0.19258903,-0.13135529),vec4(0.33907932,0.050662596,-0.3104519,-0.06542261),vec4(-0.16816102,-0.1206261,0.03928924,0.07775666),vec4(0.03533763,0.16825227,-0.25780332,-0.046546277)) * bufB[1] + mat4(vec4(0.20741028,-0.12541981,-0.09681466,0.102457866),vec4(-0.25975642,-0.23321982,-0.09905412,-0.22130011),vec4(-0.3139155,0.17694052,-0.20132864,0.052892093),vec4(0.19712976,-0.13962589,-0.2596477,-0.10575953)) * bufB[2] + mat4(vec4(-0.2786229,-0.23141746,-0.177307,-0.034455404),vec4(0.046025597,0.11420528,-0.13258818,0.20010513),vec4(-0.005726429,0.37638077,-0.044003453,0.04543999),vec4(0.14448473,0.1354678,0.11326139,0.056379735)) * bufB[3] + mat4(vec4(-0.2554168,0.014078637,-0.009605463,0.028524848),vec4(-0.102179416,0.06358738,0.06578219,0.16835377),vec4(-0.1359488,0.068212375,-0.1300693,-0.057192605),vec4(0.36946037,-0.09580707,-0.13654232,0.5001324)) * bufB[4] + mat4(vec4(-0.15231915,0.12953912,0.20446455,-0.023908922),vec4(0.079380624,0.020015704,-0.20673369,-0.24926667),vec4(0.05942398,0.059766974,-0.026592407,0.11612096),vec4(0.00839527,0.113252036,-0.010362446,0.12505218)) * bufB[5] + mat4(vec4(-0.18461089,0.17150408,-0.14244002,0.27916816),vec4(-0.14933866,0.066193156,-0.11963239,0.39570045),vec4(0.35868278,0.25185046,-0.01575334,0.07368837),vec4(0.08671359,0.050014984,-0.21496087,-0.01914746)) * bufB[6] + mat4(vec4(-0.17991492,0.14407273,-0.16212915,0.008577621),vec4(0.07983929,0.1365726,0.16746674,0.027489651),vec4(0.04733377,-0.16576578,-0.19671936,-0.36570868),vec4(0.14947002,0.07574313,0.5061155,-0.08037836)) * bufB[7] + mat4(vec4(0.29590055,-0.0423538,-0.036563065,0.37376726),vec4(0.058030758,-0.08920304,0.11591837,0.6860331),vec4(0.3208844,-0.108290784,0.07716291,0.1728008),vec4(0.20349297,-0.030843267,-0.1033048,-0.18032405)) * bufB[8] + mat4(vec4(0.0147331,0.03316568,0.30320272,-0.1452544),vec4(-0.06659081,0.17115915,0.19106174,0.3192965),vec4(-0.24245551,0.0518722,0.26342154,-0.115316406),vec4(-0.07442983,0.30656224,0.44706663,-0.07974462)) * bufB[9] + mat4(vec4(-0.027456826,0.06157313,-0.12974873,0.14206786),vec4(-0.081675924,0.10543159,-0.3056515,-0.24723127),vec4(0.04861028,-0.17642309,-0.11830702,-0.33990312),vec4(0.016810078,-0.10736962,-0.0828691,0.29241642)) * bufB[10] + mat4(vec4(-0.21291222,0.10105148,-0.021525502,0.08273444),vec4(-0.117742404,-0.22280529,0.5380864,0.13222754),vec4(-0.34236234,0.13002601,-0.15033737,-0.40917963),vec4(0.101591356,0.16029514,0.055628285,0.20373133)) * bufB[11];\nbufA[2] = vec4(-0.25914994,0.41670007,-0.48425817,-0.3159721) + mat4(vec4(0.053760678,-0.12714516,-0.080022015,0.18162896),vec4(-0.014502992,-0.11256732,0.29072648,-0.08900777),vec4(0.289582,-0.2273404,0.12612203,0.109858684),vec4(-0.3682989,0.12882313,-0.12014551,0.32921663)) * bufB[0] + mat4(vec4(-0.17847629,-0.009328645,0.04132941,-0.25238904),vec4(0.11871883,0.13275163,0.20256431,0.19509406),vec4(-0.19798635,-0.036016516,0.15501812,-0.052619994),vec4(-0.053109612,0.17528899,-0.074534945,0.22130972)) * bufB[1] + mat4(vec4(0.2202993,0.18717647,-0.3050534,-0.027036665),vec4(0.03722203,-0.12566286,0.25458163,0.093719006),vec4(0.5417778,0.36201265,0.16789384,0.11092771),vec4(-0.08141675,0.06323277,0.00091969664,-0.26874036)) * bufB[2] + mat4(vec4(0.14304678,-0.047062047,0.5061466,-0.275642),vec4(-0.10921059,0.039550368,-0.07443921,0.06176377),vec4(0.1117434,0.024278142,-0.3763558,0.22084416),vec4(-0.18460862,-0.008444851,-0.28276145,0.26298532)) * bufB[3] + mat4(vec4(0.11831743,0.17465322,-0.08489642,0.018704701),vec4(-0.4283549,-0.3614199,0.047847044,-0.06375393),vec4(-0.19398119,-0.23548324,-0.30053455,-0.32131788),vec4(-0.10096634,-0.0043798555,-0.5354378,-0.08548203)) * bufB[4] + mat4(vec4(0.051049516,-0.29312545,0.1016242,-0.0737276),vec4(-0.24798724,-0.09614705,-0.15407613,-0.036886673),vec4(0.33072683,0.08673755,0.33749563,0.13974077),vec4(-0.01597931,0.036564916,-0.07131602,0.11559218)) * bufB[5] + mat4(vec4(0.33669156,-0.18188725,0.2839303,-0.2305584),vec4(0.069339216,0.061236776,0.06212611,0.12275407),vec4(0.2786716,-0.26357988,-0.23268798,0.15285449),vec4(-0.100910746,0.07189459,0.009547677,-0.2699803)) * bufB[6] + mat4(vec4(0.22003163,-0.039520923,0.5089604,-0.03698562),vec4(0.352338,0.07768618,-0.19160107,0.11418427),vec4(-0.062112253,-0.15943469,0.059011385,-0.27909783),vec4(-0.096636854,-0.08540824,-0.055815753,0.06302054)) * bufB[7] + mat4(vec4(0.17743243,-0.0053550815,-0.16940893,0.3865927),vec4(0.2866454,0.3080894,-0.10405893,0.25367185),vec4(0.30889693,-0.013495664,0.38464892,-0.0069341944),vec4(0.03760846,-0.06964709,-0.4588912,-0.34266827)) * bufB[8] + mat4(vec4(-0.014168523,-0.10732655,-0.31568876,-0.059153344),vec4(0.3322359,0.09567252,-0.6197909,0.21842703),vec4(0.25692785,0.43481165,0.05574851,0.13652328),vec4(0.013625398,-0.13394055,-0.09082751,-0.02211406)) * bufB[9] + mat4(vec4(0.06405566,-0.027909417,-0.7143424,0.18435517),vec4(0.21736625,0.22848406,0.032482393,-0.1924478),vec4(-0.37413698,-0.041701984,-0.03105258,-0.024846796),vec4(-0.013639036,-0.10193571,0.026965419,-0.18034971)) * bufB[10] + mat4(vec4(0.13511902,0.2653436,-0.035283435,-0.21411945),vec4(-0.0034657256,-0.24013352,-0.0786786,-0.030580167),vec4(0.27349433,0.057572242,0.46617475,-0.09173678),vec4(0.08466451,0.05068588,-0.22520201,0.11152023)) * bufB[11];\nbufA[3] = vec4(-0.20442541,-0.35531726,0.48288587,0.29254904) + mat4(vec4(-0.16358142,-0.260643,0.09605855,0.2887862),vec4(-0.055903174,0.12451889,0.06826049,0.17869039),vec4(-0.22919694,-0.2702101,-0.28508765,0.046222966),vec4(-0.056723837,-0.2308984,0.0021945476,0.3205003)) * bufB[0] + mat4(vec4(-0.103129245,0.14149298,0.23804128,0.16906555),vec4(0.091053925,-0.08155744,0.385972,0.16582258),vec4(-0.04401509,-0.20723726,-0.2603708,-0.3449579),vec4(-0.089478984,0.011014725,-0.06034764,-0.18018629)) * bufB[1] + mat4(vec4(-0.25699517,0.24222703,-0.29035208,-0.10682883),vec4(-0.0037323586,0.15234458,-0.15234844,0.32902744),vec4(-0.18883437,0.005171522,-0.014798206,-0.015066697),vec4(0.1966261,0.09984587,0.16959359,-0.1720884)) * bufB[2] + mat4(vec4(0.010865008,0.016210672,0.09071936,0.12907483),vec4(0.03564418,-0.23509732,0.05548744,0.42057097),vec4(0.11960836,0.21803075,-0.15752262,0.009752476),vec4(0.020154718,0.19488676,-0.2370703,-0.16766098)) * bufB[3] + mat4(vec4(-0.1636791,-0.010251059,-0.03368746,-0.16394095),vec4(0.28076226,-0.058342032,-0.10127797,0.0057184673),vec4(0.20607421,0.00369811,0.01712695,-0.110625386),vec4(0.12820499,-0.21644971,-0.0712473,-0.07750152)) * bufB[4] + mat4(vec4(-0.14949104,-0.19367358,0.18501012,0.1090832),vec4(0.040483426,-0.063123114,0.04418236,-0.008453292),vec4(-0.19945106,0.13374516,-0.0024437627,0.069600604),vec4(-0.092220314,0.032985374,-0.051195648,-0.10498364)) * bufB[5] + mat4(vec4(0.07527693,0.22912987,0.104209535,-0.2736217),vec4(0.05664041,0.027821548,0.13235088,0.30250102),vec4(0.09874752,0.37443572,-0.36690843,0.20208548),vec4(-0.17026317,-0.24212956,0.28203842,-0.112481564)) * bufB[6] + mat4(vec4(-0.1751137,0.25911242,-0.035765868,0.010204842),vec4(-0.20221463,0.5878993,-0.08416612,-0.055816006),vec4(-0.2331023,-0.30141935,0.36250317,-0.04310263),vec4(-0.2729502,-0.006501998,0.022747602,-0.02300311)) * bufB[7] + mat4(vec4(-0.47680414,0.2042226,0.01861655,-0.0532585),vec4(-0.4065095,-0.0018126887,0.08714859,0.37696365),vec4(-0.42296407,-0.18404922,0.038806763,0.06631113),vec4(-0.016813504,-0.05085306,0.19034854,-0.27113795)) * bufB[8] + mat4(vec4(-0.24604616,0.47378722,-0.24301639,-0.5931831),vec4(0.007758027,0.11038754,-0.21801911,0.13075034),vec4(0.17307688,0.068023995,0.02854635,0.05766752),vec4(0.004217409,-0.14075637,-0.10470479,0.18551634)) * bufB[9] + mat4(vec4(-0.06512518,-0.38591722,0.42010567,-0.17234527),vec4(0.2928996,-0.050543867,0.08332301,-0.29842734),vec4(0.5359147,-0.39557353,0.10536276,-0.38454667),vec4(-0.18779343,0.22151989,-0.285291,-0.12634747)) * bufB[10] + mat4(vec4(0.18235025,0.4468495,-0.21220127,-0.041654427),vec4(-0.23371169,-0.06601826,-0.042142607,0.17599076),vec4(0.4775672,-0.22778504,0.07486346,-0.16345656),vec4(0.013967154,-0.100728855,-0.09118285,-0.069679044)) * bufB[11];\nbufA[4] = vec4(0.35835427,-0.60245603,0.32817522,-0.16434121) + mat4(vec4(0.0018748459,0.18470381,0.19495556,0.30327398),vec4(0.11619713,0.08093572,0.08047944,0.17061937),vec4(0.02969758,0.070753105,0.1872771,0.18488093),vec4(0.06322498,-0.01916177,-0.1619313,0.08399167)) * bufB[0] + mat4(vec4(0.10140662,0.043532055,-0.12838086,0.01033619),vec4(-0.0019311724,0.119021475,-0.096873395,0.06769165),vec4(0.09162432,0.10935955,0.081300385,0.019158106),vec4(-0.083445035,0.056127176,-0.1857394,0.04102739)) * bufB[1] + mat4(vec4(0.029769747,0.028382925,0.12392081,0.09408242),vec4(-0.17386796,0.05958453,-0.21334808,0.08432368),vec4(0.019494085,0.10624094,-0.3091763,0.2627695),vec4(0.08814227,-0.2861711,-0.12863122,-0.15743786)) * bufB[2] + mat4(vec4(-0.15956649,-0.108427465,-0.07950755,-0.31060192),vec4(-0.023051849,-0.12272149,0.14779136,-0.37521204),vec4(0.3461423,0.29578525,-0.042751603,0.13669176),vec4(0.03747895,-0.2665722,-0.20492895,0.058171917)) * bufB[3] + mat4(vec4(-0.09130397,0.28520048,0.11581306,0.14242777),vec4(-0.04551001,-0.02700661,0.055269707,-0.32189298),vec4(0.057701856,0.16034888,0.30190825,-0.16761994),vec4(0.40468735,-0.02930426,0.22294013,0.020775754)) * bufB[4] + mat4(vec4(0.10207015,0.02184867,-0.05259332,0.07280118),vec4(0.052222013,0.010676398,0.20577805,0.010483147),vec4(0.21097513,-0.019320205,0.34288406,-0.027677739),vec4(-0.14198677,-0.034389902,-0.07048424,-0.045696583)) * bufB[5] + mat4(vec4(-0.16763537,0.19633766,0.30990097,0.16168934),vec4(-0.17098185,0.0067398297,0.059319366,-0.09982626),vec4(0.10132773,0.43859842,0.056414593,0.24264783),vec4(-0.39951718,0.04372192,0.044378012,-0.39390984)) * bufB[6] + mat4(vec4(-0.07744741,-0.2524833,-0.18144207,0.08068998),vec4(0.22688106,0.4994975,0.06820985,-0.18401575),vec4(-0.44097283,-0.3322041,-0.23362924,-0.16191055),vec4(0.2377996,-0.035882633,-0.107384,0.28676006)) * bufB[7] + mat4(vec4(-0.27897927,0.096328974,0.0978047,0.006481287),vec4(0.25687057,0.26158604,0.32908088,-0.041671738),vec4(0.17142528,-0.08111834,-0.07098726,0.18948019),vec4(-0.24291837,-0.29084015,0.13537587,-0.002293285)) * bufB[8] + mat4(vec4(0.25487244,-0.011984759,0.121185176,0.444079),vec4(-0.039850306,0.12621409,0.30306387,0.048011627),vec4(0.06280758,-0.04512596,0.067906566,0.14556776),vec4(-0.084696,0.10377034,-0.13035613,-0.010343491)) * bufB[9] + mat4(vec4(-0.1284025,-0.33820942,-0.00967377,-0.27421355),vec4(-0.2577737,-0.14053153,-0.33164486,-0.08271199),vec4(-0.009366589,0.106736206,0.17296214,-0.094909795),vec4(-0.06459704,-0.0071323575,0.1425632,0.24493349)) * bufB[10] + mat4(vec4(-0.29818714,0.011712406,0.0062981574,-0.0026678438),vec4(-0.30985397,0.078371435,0.09802355,0.2789706),vec4(-0.1978011,0.056900278,-0.22075258,0.60364723),vec4(-0.14043218,0.07569156,0.16688731,-0.13626486)) * bufB[11];\nbufA[5] = vec4(-0.12811682,-0.07363474,-0.43079028,-0.14841728) + mat4(vec4(0.0842106,-0.08232511,0.0853962,-0.036435504),vec4(-0.101009585,-0.10244749,0.017461082,0.10022493),vec4(-0.07894835,-0.26012045,0.039249085,0.13143294),vec4(-0.18044169,0.26691577,0.30481258,-0.30380982)) * bufB[0] + mat4(vec4(0.15340517,-0.10573116,0.35611433,-0.2944871),vec4(-0.08151765,-0.19694124,0.24066028,-0.2046021),vec4(-0.011277666,-0.04390834,0.095352165,0.16732417),vec4(-0.036008224,0.11991574,0.08281377,-0.16211234)) * bufB[1] + mat4(vec4(-0.035865054,0.0070187342,0.024805484,-0.0321496),vec4(0.03310434,0.20621793,-0.08833902,0.02636306),vec4(0.15876459,0.23365179,0.21931963,-0.29010046),vec4(0.3291324,-0.15062453,0.17255653,0.0032640453)) * bufB[2] + mat4(vec4(-0.18698639,-0.33885825,-0.16067992,0.26096544),vec4(-0.051587164,0.28329998,-0.22871324,-0.029197814),vec4(0.15218687,0.18854871,0.1695638,0.08688134),vec4(-0.24359079,0.12261261,0.10973455,-0.16278355)) * bufB[3] + mat4(vec4(0.0109687615,-0.148216,0.48055747,-0.22919561),vec4(0.06494504,0.21415028,0.067573406,0.17907813),vec4(-0.065031834,-0.115960084,-0.19414215,0.19075291),vec4(0.22695546,0.13629627,0.10067025,0.13759413)) * bufB[4] + mat4(vec4(0.049328465,-0.21029133,-0.28334796,0.40871245),vec4(-0.08550139,-0.20887166,0.10715223,-0.014250298),vec4(-0.108714536,0.023310188,-0.123727776,0.07179853),vec4(0.22476764,0.25666028,-0.036345292,-0.08602835)) * bufB[5] + mat4(vec4(0.030104699,-0.24947791,-0.46578294,0.16841516),vec4(0.12425456,-0.025151057,-0.10794913,-0.122504145),vec4(0.0074609583,0.18872139,0.11675344,0.21922982),vec4(-0.00946054,-0.29771084,-0.26763955,-0.02978222)) * bufB[6] + mat4(vec4(-0.14839335,-0.102031246,-0.09586146,-0.1695993),vec4(0.10065054,0.3419779,0.09106315,-0.027739806),vec4(0.25976166,0.043449163,0.06295586,0.049800895),vec4(-0.025360703,-0.08755064,0.20809732,-0.038711976)) * bufB[7] + mat4(vec4(0.11366552,0.038971014,0.0075317104,-0.0775061),vec4(0.021775113,0.1782279,0.047913153,-0.12516491),vec4(0.10134559,-0.08940712,0.119835116,-0.14254652),vec4(0.13989006,-0.01158958,0.17569982,0.047394853)) * bufB[8] + mat4(vec4(-0.017754057,0.13363497,0.060687006,-0.1855961),vec4(-0.16207041,0.21894515,0.38739422,-0.2912457),vec4(0.26535568,0.14387277,-0.07939195,0.1028137),vec4(-0.13843957,-0.15777501,-0.1277021,-0.04020519)) * bufB[9] + mat4(vec4(-0.021537283,-0.035833187,-0.19589838,-0.0008077014),vec4(0.578538,-0.15203698,0.025390271,-0.15914498),vec4(0.13413507,-0.37849662,-0.2022588,0.2398558),vec4(0.0016031932,-0.011132522,-0.3243062,0.30971757)) * bufB[10] + mat4(vec4(0.31231436,0.08655053,0.20680816,0.08085034),vec4(-0.16405609,0.07741859,0.095153406,0.019154573),vec4(0.20158277,0.21103676,-0.29095888,-0.23305206),vec4(0.24911444,-0.07301956,-0.054702625,0.20358151)) * bufB[11];\ntmp = sin(bufA[0]);\nbufB[0] = tmp/0.67;\nbufB[6] = (tmp*tmp) / 0.6;\ntmp = sin(bufA[1]);\nbufB[1] = tmp/0.67;\nbufB[7] = (tmp*tmp) / 0.6;\ntmp = sin(bufA[2]);\nbufB[2] = tmp/0.67;\nbufB[8] = (tmp*tmp) / 0.6;\ntmp = sin(bufA[3]);\nbufB[3] = tmp/0.67;\nbufB[9] = (tmp*tmp) / 0.6;\ntmp = sin(bufA[4]);\nbufB[4] = tmp/0.67;\nbufB[10] = (tmp*tmp) / 0.6;\ntmp = sin(bufA[5]);\nbufB[5] = tmp/0.67;\nbufB[11] = (tmp*tmp) / 0.6;\nbufA[0] = vec4(0.11148029,0.16009016,0.01706092,-0.073224954) + mat4(vec4(-0.25741506,-0.5563222,0.036721844,0.37351558),vec4(-0.13380171,-0.2828256,-0.171455,0.169722),vec4(0.074296094,0.266929,0.41364047,-0.28074995),vec4(-0.27476275,-0.2615971,0.26654345,0.22866602)) * bufB[0] + mat4(vec4(-0.2753716,0.18256152,-0.009759721,-0.07623055),vec4(0.09472966,0.08061097,-0.015117866,-0.37257352),vec4(-0.007582592,0.06788885,-0.14514703,-0.25259107),vec4(0.025415234,-0.23750216,0.20241088,0.10060117)) * bufB[1] + mat4(vec4(-0.40027502,-0.18272334,0.15093839,0.054756504),vec4(-0.023318894,0.20659797,0.21308152,-0.26025775),vec4(0.36163157,0.0058685057,0.24406758,0.14038275),vec4(-0.369046,0.04148714,-0.051432665,0.18668921)) * bufB[2] + mat4(vec4(-0.026888264,-0.19602612,-0.272701,-0.041167628),vec4(-0.24809343,0.020565143,0.03656306,0.0965848),vec4(0.19152214,0.23235148,0.3409546,-0.38203344),vec4(0.01768498,-0.07124056,-0.10181689,-0.18844688)) * bufB[3] + mat4(vec4(0.31148276,-0.22976637,-0.24109674,0.10787887),vec4(-0.14859329,0.23305339,0.0008883357,-0.12700978),vec4(-0.3249952,-0.027648192,0.01255436,0.009124138),vec4(0.21101639,0.09460847,0.09917774,-0.23929219)) * bufB[4] + mat4(vec4(0.025004061,0.014085533,0.014306578,-0.20849054),vec4(-0.54071796,-0.32448688,0.023076404,0.04672686),vec4(-0.5145683,0.35484403,0.1426119,-0.19212),vec4(0.13408777,-0.4016871,-0.2637325,0.39415106)) * bufB[5] + mat4(vec4(-0.28255442,-0.063580975,0.1450524,0.025848856),vec4(-0.23210815,-0.15676078,0.09875671,0.16463092),vec4(-0.11540719,-0.31581128,-0.27959135,0.46633834),vec4(-0.046761863,0.21991503,0.052243244,0.03487556)) * bufB[6] + mat4(vec4(-0.16914822,0.10108016,0.21010995,-0.10929184),vec4(-0.2139357,0.18375845,0.2708894,0.06184742),vec4(-0.14313741,-0.38948393,-0.09666325,0.4910287),vec4(0.07398879,-0.23280886,0.11005492,0.24008726)) * bufB[7] + mat4(vec4(0.03084434,-0.4352788,0.20723744,0.5482933),vec4(-0.12172932,0.18615808,-0.62042844,-0.20611805),vec4(0.20095104,-0.46489897,0.032157708,0.5591324),vec4(-0.0040099537,0.14642063,-0.07672919,0.00072810415)) * bufB[8] + mat4(vec4(0.13946182,0.34329423,-0.43429267,-0.54425186),vec4(0.12686096,0.017856326,-0.025589151,-0.28076294),vec4(-0.18756506,0.02494396,0.14253712,0.06553603),vec4(-0.17923966,-0.13556156,0.11056076,-0.14653204)) * bufB[9] + mat4(vec4(0.10254038,-0.10901543,5.5241457e-05,0.21765807),vec4(0.08015318,0.12290419,0.03893574,-0.038860995),vec4(0.020883918,-0.114205,0.14072217,0.20908098),vec4(-0.07452829,0.015873844,-0.24448022,-0.2546222)) * bufB[10] + mat4(vec4(0.037888497,0.12171322,-0.073873006,-0.16746362),vec4(-0.378496,-0.21604194,0.28024265,0.112643585),vec4(0.20292433,-0.15642719,-0.2875322,0.2232643),vec4(-0.32014322,0.562879,-0.30020508,-0.65938926)) * bufB[11];\nbufA[1] = vec4(0.07616234,0.48159876,-0.4973739,0.44246072) + mat4(vec4(-0.31197447,-0.17150864,0.11402059,0.12032448),vec4(0.13472307,0.054936886,0.0865528,-0.1871196),vec4(-0.035549752,-0.0024937051,-0.19841309,-0.18570568),vec4(-0.103716195,-0.518792,-0.4824838,-0.02407872)) * bufB[0] + mat4(vec4(0.014328933,-0.13283068,0.063336,-0.19040406),vec4(-0.2692897,-0.08395039,0.1579938,0.22851978),vec4(-0.0011696231,0.22697508,-0.065450706,0.1211411),vec4(-0.11883089,-0.23389827,-0.0056040515,-0.23070163)) * bufB[1] + mat4(vec4(-0.038680706,0.24583873,0.15569384,0.1539194),vec4(-0.18021125,-0.11076992,-0.3042339,0.22421366),vec4(0.078489006,-0.15376906,0.027956134,-0.121633224),vec4(0.21728033,0.021049237,-0.07229149,0.21653534)) * bufB[2] + mat4(vec4(0.15985616,0.15033899,-0.04278763,0.16556711),vec4(-0.5030963,0.052158035,0.067942105,-0.30984932),vec4(0.3863147,0.22189103,-0.13949262,0.37258306),vec4(0.3367743,0.24391966,0.045718282,-0.3151881)) * bufB[3] + mat4(vec4(-0.17073977,-0.21229382,0.21724384,-0.10974432),vec4(-0.52128667,-0.15260206,0.19452386,-0.1546168),vec4(-0.2793472,-0.19998637,-0.20037499,-0.064067),vec4(-0.48717165,0.25851667,-0.15303314,0.09080285)) * bufB[4] + mat4(vec4(-0.11506582,0.085821435,-0.21773344,0.28230476),vec4(-0.27441236,-0.2924483,-0.07998001,0.37525004),vec4(0.23012227,-0.41210595,-0.015433738,-0.24664049),vec4(-0.022828875,0.027523454,0.10666383,-0.4583739)) * bufB[5] + mat4(vec4(-0.10140529,0.19429342,-0.22567786,0.13747267),vec4(-0.23770785,-0.14056477,0.05826246,0.17249894),vec4(-0.3813399,-0.099190734,0.05733906,0.2625662),vec4(-0.13163963,-0.4652186,-0.108801916,-0.11393748)) * bufB[6] + mat4(vec4(-0.39251378,-0.20819503,0.11212835,0.19986477),vec4(0.12930019,0.026691355,-0.2942446,0.4273965),vec4(0.3567306,-0.46608737,-0.018841637,0.14175867),vec4(-0.3960475,-0.31303087,-0.26693198,0.06652734)) * bufB[7] + mat4(vec4(-0.26280192,-0.40943426,0.23189126,0.095282055),vec4(0.2576606,0.4782127,-0.044463333,-0.06537906),vec4(0.27850515,0.10290297,-0.3591636,0.037267677),vec4(0.18729071,0.13980083,-0.33775082,0.0004573071)) * bufB[8] + mat4(vec4(0.31708968,0.5146878,0.08628964,-0.16977087),vec4(0.09472828,-0.010286521,-0.0825548,0.09226828),vec4(-0.012216484,0.035009492,-0.32318848,0.13399002),vec4(-0.29910424,-0.30838344,-0.092130736,-0.20362602)) * bufB[9] + mat4(vec4(0.13631825,0.12560107,-0.25161695,0.12937027),vec4(0.090863615,0.24266528,-0.1739658,0.27831364),vec4(-0.1576761,-0.34122986,0.119886644,0.05292966),vec4(-0.080150016,-0.18005063,0.12283058,0.300027)) * bufB[10] + mat4(vec4(0.08939248,0.15843938,0.18045993,0.37636396),vec4(-0.3872916,-0.048541714,-0.10853837,0.23352169),vec4(-0.34508651,0.21681748,-0.029887524,-0.24924654),vec4(0.22851668,0.40342486,0.13084055,0.5670593)) * bufB[11];\nbufA[2] = vec4(0.31943116,0.11993674,-0.43845057,0.53059584) + mat4(vec4(-0.11086975,0.29765597,0.061038326,0.28472632),vec4(0.028657626,-0.35186777,0.20121194,0.019112349),vec4(0.16371325,0.19489086,-0.038352527,0.24166569),vec4(-0.06217647,-0.17010406,0.30592546,0.19645001)) * bufB[0] + mat4(vec4(0.30754983,0.037322465,0.08628644,-0.15977216),vec4(0.010817461,0.24509986,-0.15906934,0.16833411),vec4(0.2858294,0.2679003,0.007804919,-0.054032844),vec4(-0.1260153,-0.2255763,0.08740048,0.076269194)) * bufB[1] + mat4(vec4(-0.5540553,-0.20964874,0.28411084,0.09904888),vec4(0.41639793,0.29252243,-0.035736274,0.27725813),vec4(-0.060633503,-0.05524813,0.26488623,0.21761084),vec4(0.041259445,0.18701439,0.25029504,0.01193287)) * bufB[2] + mat4(vec4(-0.44919077,0.13722745,-0.25672582,-0.1021581),vec4(0.27242884,-0.31291002,-0.36192158,-0.10768022),vec4(-0.0016634755,0.022955677,-0.2346322,0.1989558),vec4(0.08987766,-0.046988554,-0.008037298,-0.21110405)) * bufB[3] + mat4(vec4(0.13858607,-0.1367432,0.15552966,-0.1553365),vec4(0.23345171,0.09100454,-0.25428012,-0.08449383),vec4(0.30075642,0.041365724,0.0924728,0.16153544),vec4(0.04446894,0.17681238,-0.3055621,-0.1364587)) * bufB[4] + mat4(vec4(-0.12701353,0.30521345,-0.007192608,0.0207438),vec4(0.10001724,-0.08512347,0.4514141,0.23436928),vec4(0.10978638,0.12165908,0.09212052,-0.25145656),vec4(-0.28067955,-0.05529602,-0.35485134,-0.34943107)) * bufB[5] + mat4(vec4(0.08244924,0.23057689,-0.30752248,0.26394922),vec4(-0.38534334,-0.08006129,-0.0045244643,0.01697188),vec4(-0.042603694,-0.1608709,0.22579582,-0.13063619),vec4(-0.055348184,-0.0873774,0.34344977,0.0776826)) * bufB[6] + mat4(vec4(-0.08130402,0.09078335,-0.028881652,0.33761263),vec4(0.16853805,0.14896548,0.033395626,0.27312467),vec4(-0.26893184,-0.045818657,0.044839535,0.19098213),vec4(0.2007413,-0.021875953,0.19807559,0.24200404)) * bufB[7] + mat4(vec4(-0.47014895,-0.07469544,-0.062978275,0.3357519),vec4(0.29558554,-0.03720618,-0.14677183,-0.549667),vec4(-0.3349908,-0.24710612,-0.17373416,0.13969636),vec4(-0.44261315,-0.07364707,-0.63903964,-0.07784293)) * bufB[8] + mat4(vec4(0.042355124,0.22798505,-0.5145923,-0.40132448),vec4(0.06763242,0.1969295,0.25550917,0.66871816),vec4(0.16812328,0.47192258,0.089543834,0.19046384),vec4(0.060921513,0.011816891,0.1590022,0.21112058)) * bufB[9] + mat4(vec4(0.09022924,0.026531667,-0.06726878,0.07161296),vec4(-0.26116976,-0.18853892,0.035069544,0.26610836),vec4(0.22241339,0.04518295,0.09505909,0.17636299),vec4(0.077836245,-0.07144231,0.2843332,-0.035674572)) * bufB[10] + mat4(vec4(-0.16326739,0.116080225,0.21934403,0.05784647),vec4(-0.12825015,-0.05847125,-0.047576234,0.038311154),vec4(0.18730327,-0.07765833,-0.23869187,0.1463743),vec4(0.17817536,0.082700916,0.25895715,-0.13304432)) * bufB[11];\nbufA[3] = vec4(0.5012468,0.4313063,0.20760535,-0.17173739) + mat4(vec4(-0.0017144167,-0.1902728,0.12002545,-0.34538376),vec4(0.21712142,0.3924411,0.089348644,0.087705374),vec4(0.5022081,0.109376095,0.20155713,-0.2350367),vec4(0.38641503,0.10844928,-0.055291064,-0.12361791)) * bufB[0] + mat4(vec4(0.030905679,0.4669184,0.10239818,0.20874457),vec4(0.030296497,-0.04221955,0.088731095,-0.45096242),vec4(-0.27141997,0.22923678,0.25901982,0.07484609),vec4(0.37521857,-0.4551867,-0.042097818,-0.011052973)) * bufB[1] + mat4(vec4(0.267739,0.3161909,0.21560857,-0.0637395),vec4(0.5194735,-0.22539248,-0.16255024,-0.45517138),vec4(0.28364447,0.28404498,0.25103554,0.07548863),vec4(-0.112990096,0.38300526,0.36595944,-0.44354558)) * bufB[2] + mat4(vec4(-0.08079226,0.00279173,0.07202752,-0.035284437),vec4(0.042605177,0.24559723,-0.25221413,0.059479978),vec4(0.028110998,0.12470704,-0.605553,-0.20550828),vec4(-0.2850829,0.198836,-0.093005456,0.13326155)) * bufB[3] + mat4(vec4(-0.27831292,0.24988784,-0.27643123,0.04234461),vec4(-0.08819273,0.2202322,0.19816375,0.24672186),vec4(-0.05262694,-0.034356635,0.09826718,0.16452597),vec4(-0.07532932,0.098682806,0.07058816,-0.18321542)) * bufB[4] + mat4(vec4(0.1761802,-0.207892,-0.10117096,-0.18401177),vec4(0.11799433,0.0005693894,0.67187214,0.047951605),vec4(-0.1804857,0.14525564,0.08764528,0.24712272),vec4(-0.46280062,-0.1561521,0.0013035625,-0.0035327575)) * bufB[5] + mat4(vec4(0.23904547,-0.19325575,-0.19993475,-0.34008536),vec4(-0.041562498,0.07950111,0.32504186,-0.059259478),vec4(0.08283784,-0.2900363,0.121280946,0.27866736),vec4(0.15349792,-0.22044577,-0.089031376,0.077418245)) * bufB[6] + mat4(vec4(-0.1413957,-0.08746831,0.5310506,-0.11290346),vec4(-0.06797916,-0.12427512,-0.22849931,-0.17104219),vec4(0.33103284,0.14842616,-0.20422283,-0.1921856),vec4(0.10721732,-0.072140776,0.05194869,0.06211076)) * bufB[7] + mat4(vec4(-0.17359507,-0.031509466,-0.11175303,0.07846156),vec4(-0.0202384,0.05366604,-0.42042014,0.15302347),vec4(0.3421087,-0.073357955,-0.42827952,0.06559764),vec4(-0.40398183,-0.27159342,-0.4418514,-0.112864405)) * bufB[8] + mat4(vec4(-0.079061195,0.21005866,-0.0660554,0.18056528),vec4(0.24072869,-0.14470008,-0.0069298083,-0.11187357),vec4(0.20397311,-0.23518142,-0.48703656,-0.28971234),vec4(-0.030690674,-0.19499692,0.20848888,0.14225194)) * bufB[9] + mat4(vec4(0.20482223,0.1624877,-0.121569656,-0.024785474),vec4(-0.10038976,-0.43587023,-0.41648346,0.05427307),vec4(0.26225978,0.10737617,0.27849633,0.032677054),vec4(-0.121792115,-0.16842256,-0.01911659,0.086158186)) * bufB[10] + mat4(vec4(0.005403358,-0.16042982,-0.35107318,-0.1375484),vec4(0.1297382,-0.2072885,0.3556794,0.30499586),vec4(0.026494768,-0.18201634,0.011731859,0.08977516),vec4(0.02790657,0.2975832,0.10074768,0.00016616275)) * bufB[11];\nbufA[4] = vec4(-0.21671207,0.05305995,-0.035644546,-0.37568647) + mat4(vec4(-0.09232443,0.075987495,0.14105129,-0.48417917),vec4(-0.013142991,-0.039176136,-0.100045785,-0.49553084),vec4(-0.21279454,0.17020787,0.007362582,0.17708942),vec4(-0.10378528,0.40456814,0.03665865,-0.017533254)) * bufB[0] + mat4(vec4(-0.00725722,0.43950236,-0.04137758,-0.49784207),vec4(-0.15616098,0.015621538,0.029883334,0.34171823),vec4(0.10582884,-0.10355264,-0.08454921,0.09348372),vec4(-0.35520455,0.18125677,-0.24992403,0.16142045)) * bufB[1] + mat4(vec4(0.1230476,-0.182297,-0.14071724,-0.12917891),vec4(-0.3233506,0.37734985,0.41469395,0.20512363),vec4(-0.34022954,-0.14841521,0.104989156,0.19694488),vec4(0.14063062,-0.22503069,0.029866943,0.26941672)) * bufB[2] + mat4(vec4(0.39634252,-0.091267645,0.27293307,0.038359765),vec4(-0.3355203,0.09504421,-0.07744354,-0.21517217),vec4(0.015939351,0.15011555,0.3517867,0.10773773),vec4(0.24550158,-0.23552696,-0.01749914,0.21222049)) * bufB[3] + mat4(vec4(0.14548509,0.043868333,-0.023395665,-0.08884532),vec4(0.13755238,0.3137128,-0.22717303,-0.17388336),vec4(-0.24372791,0.25460324,0.027595537,0.09643782),vec4(0.019105837,0.124618016,-0.05222248,0.35530853)) * bufB[4] + mat4(vec4(0.12570395,-0.0055092215,-0.016729537,-0.057729293),vec4(-0.27082893,0.26827058,0.42294613,-0.46471804),vec4(0.26364776,0.08572635,-0.34736708,0.10711953),vec4(0.10676284,0.10863709,-0.19228463,-0.25527617)) * bufB[5] + mat4(vec4(0.32119668,0.13418256,0.09937083,0.030287685),vec4(0.33000046,-0.07485072,0.022402031,-0.1766794),vec4(0.05773688,-0.061569404,0.104888156,-0.059156362),vec4(-0.34314772,0.4899557,-0.037346642,-0.2203031)) * bufB[6] + mat4(vec4(-0.31799334,0.17412497,-0.08242449,-0.32822037),vec4(0.20411155,-0.23749264,0.26071408,-0.02493605),vec4(-0.27403095,0.1924615,-0.0102827,-0.20612814),vec4(-0.4787273,0.46275166,0.063275434,0.021100067)) * bufB[7] + mat4(vec4(-0.1854938,0.11595522,0.056788642,-0.15340458),vec4(0.14857739,-0.28398782,-0.17607392,0.033858858),vec4(-0.20289205,-0.20695063,0.123536184,0.16128738),vec4(0.33474994,-0.03295069,0.1595429,0.25874573)) * bufB[8] + mat4(vec4(0.75745654,-0.7193857,-0.0066942424,0.17492892),vec4(0.061384067,0.18947056,0.06713233,0.09321823),vec4(-0.29101413,0.45070314,-0.07085089,-0.21169287),vec4(-0.114045486,0.40868446,-0.10587499,-0.102908455)) * bufB[9] + mat4(vec4(-0.0052953777,-0.018215802,0.3697727,0.025836615),vec4(0.17253362,-0.1364561,0.3787021,0.11524687),vec4(-0.15792555,0.05748415,0.17771995,-0.10897031),vec4(-0.5076069,0.271843,-0.21153046,-0.10918902)) * bufB[10] + mat4(vec4(0.04599205,0.039205782,-0.10671749,0.15239316),vec4(-0.6054238,0.46859345,0.0831559,-0.5231223),vec4(-0.24668574,0.09660257,0.04985606,0.2613708),vec4(-0.14300998,0.041390613,-0.27389815,0.16810514)) * bufB[11];\nbufA[5] = vec4(-0.08905488,0.4879649,-0.51062167,-0.26422763) + mat4(vec4(-0.1596377,-0.6901654,0.2134032,-0.24649338),vec4(0.0076572886,-0.23922229,-0.13780585,-0.13213886),vec4(-0.035629828,-0.11542847,0.0021769053,-0.2935597),vec4(-0.3030789,-0.10184964,0.41351444,-0.2887588)) * bufB[0] + mat4(vec4(-0.34806406,-0.55905396,-0.12710343,-0.21932927),vec4(0.15470447,0.07774625,-0.18106066,-0.1477671),vec4(-0.06639235,-0.000657568,0.08566217,-0.2809631),vec4(-0.26527664,0.18809383,0.042142298,-0.22357151)) * bufB[1] + mat4(vec4(-0.06458668,-0.1267941,0.096839145,0.1987741),vec4(-0.32197052,0.10663013,-0.39690268,-0.3198365),vec4(-0.20880331,0.16718332,0.44758925,-0.18715991),vec4(-0.043698046,0.14385349,-0.042684324,-0.19026268)) * bufB[2] + mat4(vec4(0.22964452,0.21831828,0.016574042,0.07252064),vec4(-0.53327864,-0.24732947,0.0019172865,-0.18325506),vec4(-0.09411495,-0.08169809,-0.00030017382,0.08129357),vec4(0.26414904,-0.0548707,0.017749326,0.30680054)) * bufB[3] + mat4(vec4(0.22274765,-0.037353955,-0.038332894,0.06290572),vec4(0.005156841,-0.13268416,0.0932041,-0.26957297),vec4(-0.20546387,0.2546021,-0.13811484,-0.33043706),vec4(0.044068146,0.66299635,-0.1795391,-0.01665924)) * bufB[4] + mat4(vec4(-0.034550514,0.3754573,-0.2795844,0.14424801),vec4(-0.29600397,-0.27859363,0.32745987,-0.50281155),vec4(0.25866225,0.17965281,-0.22569552,0.17040123),vec4(0.12970693,-0.38734746,0.20517121,-0.051514845)) * bufB[5] + mat4(vec4(0.07269569,0.13048953,0.32417694,0.015878158),vec4(0.21690007,-0.086090125,0.1224728,0.05411),vec4(-0.1369075,0.031953827,0.12360566,-0.07594838),vec4(-0.3801056,-0.07170054,0.07900295,-0.025931567)) * bufB[6] + mat4(vec4(-0.5774815,-0.3487543,0.028369082,-0.16942608),vec4(0.08431399,0.31666785,0.049708515,0.15301163),vec4(0.016233847,-0.30950922,-0.058191627,0.41074225),vec4(-0.5583661,-0.13453065,0.51013255,-0.17247538)) * bufB[7] + mat4(vec4(-0.11009877,-0.18938376,0.29556915,0.20564274),vec4(0.14321262,0.23790471,0.07248465,0.20991686),vec4(0.27697295,0.12540428,-0.13609055,0.2754952),vec4(0.44727218,0.5122169,-0.11089232,0.3353532)) * bufB[8] + mat4(vec4(0.75254637,0.536345,-0.28842792,0.20872164),vec4(0.4096049,0.11412904,-0.09682506,-0.09281302),vec4(-0.45751992,-0.33969015,0.09472953,0.30550492),vec4(-0.29820663,-0.16786577,0.15416916,0.12748781)) * bufB[9] + mat4(vec4(0.015867464,-0.046595786,0.27442673,-0.04820262),vec4(0.21633026,0.39651448,-0.18348141,0.20445308),vec4(-0.18720953,-0.05332621,0.24299768,-0.2343751),vec4(-0.50889933,-0.041527823,-0.1620215,0.20346929)) * bufB[10] + mat4(vec4(-0.05742249,0.08354505,-0.20196536,0.39752927),vec4(-0.50255865,-0.17544858,0.7229796,-0.06733933),vec4(-0.50766087,-0.017583255,-0.042368952,-0.2998063),vec4(0.08407604,0.49204117,-0.41077942,0.0011025534)) * bufB[11];\ntmp = sin(bufA[0]);\nbufB[0] = tmp/0.67;\nbufB[6] = (tmp*tmp) / 0.6;\ntmp = sin(bufA[1]);\nbufB[1] = tmp/0.67;\nbufB[7] = (tmp*tmp) / 0.6;\ntmp = sin(bufA[2]);\nbufB[2] = tmp/0.67;\nbufB[8] = (tmp*tmp) / 0.6;\ntmp = sin(bufA[3]);\nbufB[3] = tmp/0.67;\nbufB[9] = (tmp*tmp) / 0.6;\ntmp = sin(bufA[4]);\nbufB[4] = tmp/0.67;\nbufB[10] = (tmp*tmp) / 0.6;\ntmp = sin(bufA[5]);\nbufB[5] = tmp/0.67;\nbufB[11] = (tmp*tmp) / 0.6;\nbufA[0] = vec4(0.05259477347135544,0.06260812282562256,0.03964589536190033,0.0) + mat4(vec4(0.27966392040252686,0.28381842374801636,0.28313395380973816,0.0),vec4(0.30615904927253723,0.30373555421829224,0.30924880504608154,0.0),vec4(0.34897473454475403,0.3494299650192261,0.34445780515670776,0.0),vec4(-0.38878458738327026,-0.38062623143196106,-0.3825567960739136,0.0)) * bufB[0] + mat4(vec4(0.3025985360145569,0.3023698031902313,0.29592180252075195,0.0),vec4(-0.2697947025299072,-0.2683483064174652,-0.2617024779319763,0.0),vec4(0.13250550627708435,0.1300538182258606,0.12296943366527557,0.0),vec4(-0.27789023518562317,-0.2709099352359772,-0.2778092622756958,0.0)) * bufB[1] + mat4(vec4(0.2988892197608948,0.2922552525997162,0.29496297240257263,0.0),vec4(0.35276567935943604,0.3490113914012909,0.35145750641822815,0.0),vec4(0.32542896270751953,0.3238483965396881,0.3191565275192261,0.0),vec4(-0.3401767909526825,-0.3344420790672302,-0.34781190752983093,0.0)) * bufB[2] + mat4(vec4(-0.21485675871372223,-0.21402700245380402,-0.21029189229011536,0.0),vec4(0.12314453721046448,0.12347878515720367,0.1191403791308403,0.0),vec4(0.30328628420829773,0.2950930595397949,0.30619293451309204,0.0),vec4(-0.41727784276008606,-0.4101450443267822,-0.40374892950057983,0.0)) * bufB[3] + mat4(vec4(0.26909685134887695,0.2711219787597656,0.2641754448413849,0.0),vec4(-0.2709546685218811,-0.27401480078697205,-0.2664548456668854,0.0),vec4(0.4819324314594269,0.4837959408760071,0.4774893522262573,0.0),vec4(0.2824563980102539,0.27831000089645386,0.272845983505249,0.0)) * bufB[4] + mat4(vec4(0.3124309778213501,0.3079395294189453,0.3042910099029541,0.0),vec4(-0.31534069776535034,-0.31407326459884644,-0.3188610076904297,0.0),vec4(-0.14298555254936218,-0.14151298999786377,-0.14275182783603668,0.0),vec4(-0.2846526801586151,-0.2847681939601898,-0.28048646450042725,0.0)) * bufB[5] + mat4(vec4(0.0263524167239666,0.02849300019443035,0.03028463013470173,0.0),vec4(-0.09575062245130539,-0.09133927524089813,-0.09535680711269379,0.0),vec4(0.04155416786670685,0.03787514194846153,0.04246380180120468,0.0),vec4(-0.2202940136194229,-0.21216504275798798,-0.22154664993286133,0.0)) * bufB[6] + mat4(vec4(-0.08423969149589539,-0.08398285508155823,-0.0842948704957962,0.0),vec4(0.013168880715966225,0.005552490707486868,0.00918988510966301,0.0),vec4(0.030724961310625076,0.03416730836033821,0.030341625213623047,0.0),vec4(0.029551200568675995,0.030963018536567688,0.03166547790169716,0.0)) * bufB[7] + mat4(vec4(-0.15762482583522797,-0.1512802690267563,-0.14414751529693604,0.0),vec4(0.01621316187083721,0.010018561966717243,0.004286203067749739,0.0),vec4(-0.07438439130783081,-0.07801861315965652,-0.06880827993154526,0.0),vec4(-0.1355142742395401,-0.12902644276618958,-0.13664264976978302,0.0)) * bufB[8] + mat4(vec4(0.06950127333402634,0.06914888322353363,0.0679258406162262,0.0),vec4(-0.009605495259165764,-0.010230189189314842,-0.007406117394566536,0.0),vec4(-0.10875310748815536,-0.10947859287261963,-0.11017721891403198,0.0),vec4(0.08084356039762497,0.08592455834150314,0.0882313996553421,0.0)) * bufB[9] + mat4(vec4(-0.19208264350891113,-0.19946901500225067,-0.18643096089363098,0.0),vec4(-0.21970637142658234,-0.21516796946525574,-0.21840143203735352,0.0),vec4(0.1514037847518921,0.1475331038236618,0.139352485537529,0.0),vec4(-0.004051918629556894,0.005354680120944977,-0.0020877618808299303,0.0)) * bufB[10] + mat4(vec4(-0.2599519193172455,-0.25860482454299927,-0.256086528301239,0.0),vec4(-0.057605866342782974,-0.05719543993473053,-0.05476957559585571,0.0),vec4(-0.22340571880340576,-0.2184036374092102,-0.2199828028678894,0.0),vec4(-0.014812462963163853,-0.01422520074993372,-0.00968514196574688,0.0)) * bufB[11];\nreturn vec4((1. / (1. + exp(-bufA[0]))).xyz, 1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 mouseNorm = (iMouse.xy / iResolution.xy) - vec2(0.5, 0.5);\n\n\n    uv.x *= iResolution.x / iResolution.y;\n    uv.x -= ((iResolution.x / iResolution.y) - 1.) /2.;\n\n\n    // Shifted to the form expected by the CPPN\n    uv = vec2(1., -1.) * 3. * (uv - vec2(0.5, 0.5));\n    // Output to screen\n    fragColor = cppn_fn(uv, sin(iTime), sin(2.*iTime), sin(3.*iTime), sin(4.*iTime));\n}\n        ", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/ssBGzV.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "ssfSDl", "name": "angry goku v4", "author": "jorge2017a1", "description": "La tierra es destruida por freezer......y el dios de la destruccion y su ayudante wiss.....regresan el tiempo!!!!! :....goku esta muy molesto y enojado :)", "tags": ["angrygokuv4"], "likes": 7, "viewed": 162, "date": "1619445127", "time_retrieved": "2024-06-20T20:39:04.761768", "image_code": "//por jorge2017a1 ----jorgeFloresP---26/abril/2021\n// referencia\n//https://www.shadertoy.com/view/tlGBW3\n\n#define antialiasing(n) n/min(iResolution.y,iResolution.x)\n#define S(d,b) smoothstep(antialiasing(1.0),b,d)\n\n//https://www.shadertoy.com/view/tlGBW3\n//Created by manu210404 in 2021-03-13\n#define POLY(N) (in vec2 p, in vec2[N] v) {const int n=v.length();float d=dot(p-v[0],p-v[0]);float s=1.;for(int i=0,j=n-1;i<n;j=i,i++){vec2 e=v[j]-v[i];vec2 w=p-v[i];vec2 b=w-e*clamp(dot(w,e)/dot(e,e),0.,1.);d=min(d,dot(b,b));bvec3 cond=bvec3(p.y>=v[i].y,p.y<v[j].y,e.x*w.y>e.y*w.x);if(all(cond)||all(not(cond))) s=-s;}return s*sqrt(d);}\n\nfloat sdPoly17 POLY(17)\nvec2 pt17[ 17]=vec2[](  \nvec2(.10,1.00),vec2(.24,.32),vec2(.24,.29),vec2(.25,.28),vec2(.26,.26),\nvec2(.48,.01),vec2(.49,.00),vec2(.53,.01),vec2(.55,.03),vec2(.71,.21),\nvec2(.72,.22),vec2(.74,.24),vec2(.74,.26),vec2(.75,.30),vec2(.81,.56),\nvec2(.90,.99),vec2(.10,1.00) );\n\nfloat sdPoly10 POLY(10)\nvec2 pt10[ 10]=vec2[](  \nvec2(.00,.09),vec2(.05,.17),vec2(.10,.23),vec2(.14,.27),vec2(.21,.33),\nvec2(.21,.12),vec2(.17,.06),vec2(.14,.00),vec2(.00,.00),vec2(.00,.09) );\n\n\nfloat sdPoly9 POLY(9)\nvec2 pt9[ 9]=vec2[](  \nvec2(.00,.03),vec2(.04,.08),vec2(.09,.13),vec2(.15,.19),vec2(.19,.22),\nvec2(.21,.22),vec2(.20,.13),vec2(.14,.01),vec2(.00,.03) );\n\nfloat sdPoly11 POLY(11)\nvec2 pt11[ 11]=vec2[](  \nvec2(.78,.12),vec2(.78,.33),vec2(.83,.31),vec2(.89,.25),vec2(.95,.19),\nvec2(1.00,.13),vec2(1.00,.01),vec2(.86,.01),vec2(.83,.06),vec2(.79,.10),\nvec2(.78,.12) );\n\nfloat sdPoly11b POLY(11)\nvec2 pt11b[ 11]=vec2[](  \nvec2(.79,.24),vec2(.82,.23),vec2(.88,.18),vec2(.94,.14),vec2(1.00,.06),\nvec2(1.00,.01),vec2(.87,.01),vec2(.83,.05),vec2(.79,.11),vec2(.78,.12),\nvec2(.79,.24) );\n\nfloat sdPoly7 POLY(7)\nvec2 pt7[ 7]=vec2[](  \nvec2(.22,.38),vec2(.21,.13),vec2(.14,.01),vec2(.86,.01),vec2(.78,.12),\nvec2(.78,.41),vec2(.22,.38) );\n\nfloat sdPoly13 POLY(13)\nvec2 pt13[ 13]=vec2[](  \nvec2(.11,.96),vec2(.07,.97),vec2(.05,.95),vec2(.04,.85),vec2(.05,.73),\nvec2(.06,.66),vec2(.09,.59),vec2(.13,.52),vec2(.17,.46),vec2(.18,.45),\nvec2(.19,.45),vec2(.21,.44),vec2(.11,.96) );\n\nfloat sdPoly14 POLY(14)\nvec2 pt14[ 14]=vec2[](  \nvec2(.90,.99),vec2(.94,.99),vec2(.95,.98),vec2(.96,.93),vec2(.96,.86),\nvec2(.94,.75),vec2(.93,.67),vec2(.92,.61),vec2(.90,.58),vec2(.82,.45),\nvec2(.80,.44),vec2(.79,.44),vec2(.79,.45),vec2(.90,.99) );\n\nfloat sdPoly18 POLY(18)\nvec2 pt18[ 18]=vec2[](  \nvec2(.19,.90),vec2(.21,.91),vec2(.23,.91),vec2(.25,.88),vec2(.36,.75),\nvec2(.44,.64),vec2(.45,.64),vec2(.46,.65),vec2(.47,.67),vec2(.46,.63),\nvec2(.45,.61),vec2(.42,.62),vec2(.34,.70),vec2(.28,.76),vec2(.25,.78),\nvec2(.22,.78),vec2(.19,.78),vec2(.19,.90) );\n\nfloat sdPoly22 POLY(22)\nvec2 pt22[ 22]=vec2[](  \nvec2(.52,.68),vec2(.53,.65),vec2(.53,.63),vec2(.54,.63),vec2(.57,.65),\nvec2(.61,.70),vec2(.68,.80),vec2(.73,.86),vec2(.78,.92),vec2(.80,.94),\nvec2(.82,.93),vec2(.82,.93),vec2(.83,.81),vec2(.82,.81),vec2(.79,.82),\nvec2(.77,.81),vec2(.71,.76),vec2(.61,.66),vec2(.58,.62),vec2(.56,.61),\nvec2(.53,.60),vec2(.52,.68) );\n\nfloat sdPoly13b POLY(13)\nvec2 pt13b[ 13]=vec2[](  \nvec2(.46,.26),vec2(.47,.27),vec2(.49,.28),vec2(.50,.28),vec2(.53,.28),\nvec2(.55,.26),vec2(.55,.26),vec2(.55,.27),vec2(.53,.28),vec2(.51,.29),\nvec2(.48,.29),vec2(.46,.27),vec2(.46,.26) );\n\nfloat sdPoly9b POLY(9)\nvec2 pt9b[ 9]=vec2[](  \nvec2(.51,.52),vec2(.50,.52),vec2(.49,.52),vec2(.49,.38),vec2(.49,.37),\nvec2(.50,.37),vec2(.51,.38),vec2(.51,.40),vec2(.51,.52) );\n\nfloat sdPoly12 POLY(12)\nvec2 pt12[ 12]=vec2[](  \nvec2(.22,.78),vec2(.27,.76),vec2(.33,.72),vec2(.37,.67),vec2(.41,.64),\nvec2(.43,.62),vec2(.42,.60),vec2(.37,.60),vec2(.25,.61),vec2(.24,.67),\nvec2(.23,.74),vec2(.22,.78) );\n\nfloat sdPoly15b POLY(15)\nvec2 pt15b[ 15]=vec2[](  \nvec2(.57,.61),vec2(.62,.67),vec2(.67,.72),vec2(.73,.77),vec2(.77,.81),\nvec2(.77,.77),vec2(.76,.72),vec2(.75,.66),vec2(.74,.62),vec2(.68,.61),\nvec2(.62,.59),vec2(.60,.59),vec2(.58,.59),vec2(.58,.60),vec2(.57,.61) );\n\nfloat sdPoly11c POLY(11)\nvec2 pt11c[ 11]=vec2[](  \nvec2(.08,1.00),vec2(.15,1.00),vec2(.16,.95),vec2(.17,.87),vec2(.19,.78),\nvec2(.19,.78),vec2(.16,.80),vec2(.12,.84),vec2(.11,.86),vec2(.09,.91),\nvec2(.08,1.00) );\n\nfloat sdPoly6 POLY(6)\nvec2 pt6[ 6]=vec2[](  \nvec2(.16,1.00),vec2(.24,.83),vec2(.26,.82),vec2(.24,.90),vec2(.23,1.00),\nvec2(.16,1.00) );\n\nfloat sdPoly9c POLY(9)\nvec2 pt9c[ 9]=vec2[](  \nvec2(.29,1.00),vec2(.29,.94),vec2(.29,.86),vec2(.30,.79),vec2(.30,.78),\nvec2(.31,.84),vec2(.33,.91),vec2(.37,1.00),vec2(.29,1.00) );\n\nfloat sdPoly8 POLY(8)\nvec2 pt8[ 8]=vec2[](  \nvec2(.57,1.00),vec2(.52,.74),vec2(.53,.72),vec2(.56,.79),vec2(.64,.89),\nvec2(.71,.97),vec2(.76,1.00),vec2(.57,1.00) );\n\nfloat sdPoly8b POLY(8)\nvec2 pt8b[ 8]=vec2[](  \nvec2(.80,1.00),vec2(.77,.89),vec2(.86,.98),vec2(.85,.93),vec2(.82,.84),\nvec2(.90,.89),vec2(.95,.99),vec2(.80,1.00) );\n\nfloat sdPoly10b POLY(10)\nvec2 pt10b[ 10]=vec2[](  \nvec2(.21,.45),vec2(.00,.59),vec2(.00,1.00),vec2(.99,1.00),vec2(1.00,.60),\nvec2(.97,.58),vec2(1.00,.55),vec2(1.00,.42),vec2(.78,.38),vec2(.21,.45) );\n\nfloat sdPoly7b POLY(7)\nvec2 pt7b[ 7]=vec2[](  \nvec2(.25,.52),vec2(.33,.54),vec2(.40,.55),vec2(.44,.53),vec2(.46,.53),\nvec2(.38,.46),vec2(.25,.52) );\n\nfloat sdPoly7c POLY(7)\nvec2 pt7c[ 7]=vec2[](  \nvec2(.57,.53),vec2(.59,.54),vec2(.67,.56),vec2(.71,.56),vec2(.74,.55),\nvec2(.65,.47),vec2(.57,.53) );\n\nfloat sdPoly11d POLY(11)\nvec2 pt11d[ 11]=vec2[](  \nvec2(.48,.50),vec2(.45,.41),vec2(.45,.39),vec2(.48,.33),vec2(.50,.33),\nvec2(.53,.38),vec2(.51,.36),vec2(.51,.36),vec2(.48,.36),vec2(.48,.43),\nvec2(.48,.50) );\n\nfloat sdPoly16 POLY(16)\nvec2 pt16[ 16]=vec2[](  \nvec2(.47,.70),vec2(.46,.64),vec2(.46,.60),vec2(.46,.58),vec2(.48,.58),\nvec2(.50,.58),vec2(.52,.58),vec2(.53,.59),vec2(.52,.68),vec2(.52,.64),\nvec2(.52,.61),vec2(.52,.59),vec2(.48,.60),vec2(.47,.60),vec2(.47,.64),\nvec2(.47,.70) );\n\nfloat sdPoly4 POLY(4)\nvec2 pt4[ 4]=vec2[](  \nvec2(.22,.01),vec2(.28,.11),vec2(.30,.01),vec2(.22,.01) );\n\nfloat sdPoly4b POLY(4)\nvec2 pt4b[ 4]=vec2[](  \nvec2(.69,.01),vec2(.72,.12),vec2(.76,.02),vec2(.69,.01) );\n\nfloat sdPoly7d POLY(7)\nvec2 pt7d[ 7]=vec2[](  \nvec2(.47,.18),vec2(.50,.20),vec2(.52,.20),vec2(.54,.17),vec2(.52,.13),\nvec2(.49,.13),vec2(.47,.18) );\n\nfloat sdPoly7e POLY(7)\nvec2 pt7e[ 7]=vec2[](  \nvec2(.35,.70),vec2(.40,.64),vec2(.39,.62),vec2(.38,.61),vec2(.35,.63),\nvec2(.35,.66),vec2(.35,.70) );\n\nfloat sdPoly9d POLY(9)\nvec2 pt9d[ 9]=vec2[](  \nvec2(.59,.64),vec2(.62,.67),vec2(.65,.69),vec2(.65,.68),vec2(.65,.65),\nvec2(.63,.63),vec2(.62,.63),vec2(.60,.63),vec2(.59,.64) );\n\nfloat sdPoly19 POLY(19)\nvec2 pt19[ 19]=vec2[](  \nvec2(.07,.88),vec2(.06,.82),vec2(.07,.76),vec2(.07,.72),vec2(.07,.75),\nvec2(.09,.77),vec2(.10,.77),vec2(.12,.68),vec2(.14,.58),vec2(.15,.58),\nvec2(.17,.55),vec2(.17,.54),vec2(.20,.52),vec2(.17,.65),vec2(.14,.69),\nvec2(.14,.74),vec2(.12,.80),vec2(.10,.85),vec2(.07,.88) );\n\nfloat sdPoly23 POLY(23)\nvec2 pt23[ 23]=vec2[](  \nvec2(.84,.68),vec2(.86,.71),vec2(.86,.74),vec2(.86,.76),vec2(.86,.78),\nvec2(.88,.82),vec2(.90,.87),vec2(.91,.88),vec2(.92,.89),vec2(.93,.87),\nvec2(.93,.80),vec2(.91,.73),vec2(.91,.76),vec2(.91,.78),vec2(.90,.77),\nvec2(.90,.79),vec2(.88,.75),vec2(.88,.69),vec2(.87,.63),vec2(.85,.58),\nvec2(.84,.55),vec2(.80,.50),vec2(.84,.68) );\n\nfloat sdPoly12b POLY(12)\nvec2 pt12b[ 12]=vec2[](  \nvec2(.46,.24),vec2(.46,.27),vec2(.47,.28),vec2(.49,.29),vec2(.53,.29),\nvec2(.55,.28),vec2(.56,.25),vec2(.55,.23),vec2(.52,.23),vec2(.49,.23),\nvec2(.47,.23),vec2(.46,.24) );\n\nfloat sdPoly11e POLY(11)\nvec2 pt11e[ 11]=vec2[](  \nvec2(.46,.27),vec2(.47,.26),vec2(.50,.27),vec2(.53,.27),vec2(.55,.27),\nvec2(.55,.28),vec2(.54,.29),vec2(.51,.29),vec2(.48,.29),vec2(.47,.28),\nvec2(.46,.27) );\n\nvec3 RostroGokuv3(in vec2 pp, vec3 col) \n{\n  vec2 p=pp; //  p=p-vec2(0.0,-0.2);\n  float sd1 = sdPoly17(p, pt17);  //rostro\n  float sd2 = sdPoly10(p, pt10);\n  float sd3 = sdPoly9(p,pt9);\n  float sd4 = sdPoly11(p,pt11);\n  float sd5 = sdPoly11b(p,pt11b);\n  float sd6 = sdPoly7(p,pt7);\n  float sd7 = sdPoly13(p,pt13); //oreja\n  float sd8 = sdPoly14(p,pt14);\n  float sd9 = sdPoly18(p,pt18);\n  float sd10 = sdPoly22(p,pt22);\n  float sd11 = sdPoly13b(p,pt13b);\n  float sd12 = sdPoly9b(p,pt9b);\n  float sd13 = sdPoly12(p,pt12);\n  float sd14 = sdPoly15b(p,pt15b);\n  float sd15 = sdPoly11c(p,pt11c);\n  float sd16 = sdPoly6(p,pt6);\n  float sd17 = sdPoly9c(p,pt9c);\n  float sd18 = sdPoly8(p,pt8);\n  float sd19 = sdPoly8b(p,pt8b);\n  float sd20 = sdPoly10b(p,pt10b);\n  float sd21 = sdPoly7b(p,pt7b);\n  float sd22 = sdPoly7c(p,pt7c);\n  float sd23 = sdPoly11d(p,pt11d);\n  float sd24 = sdPoly16(p,pt16);\n  float sd25 = sdPoly4(p,pt4);\n  float sd26 = sdPoly4b(p,pt4b);\n  float sd27 = sdPoly7d(p,pt7d);\n  float sd28 = sdPoly7e(p,pt7e);\n  float sd29 = sdPoly9d(p,pt9d);\n  float sd30 = sdPoly19(p,pt19);\n  float sd31 = sdPoly23(p,pt23);\n  float sd32 = sdPoly12b(p,pt12b);\n  float sd33 = sdPoly11e(p,pt11e);\n  \n  col = mix(col,vec3(0.3),S(sd20,0.0)); //grande pelo  \n  col = mix(col,vec3(0.98,0.77,0.77),S(sd6,0.0));\n  col *= 1.0 - exp(-10.0*abs(sd1));\n  col = mix(col,vec3(1.00,0.77,0.78),S(sd1,0.0)); // rostro\n  col = mix(col,vec3(1.00,0.77,0.78),S(sd2,0.0));\n  col = mix(col,vec3(0.64,0.32,0.35),S(sd3,0.0)); //sobra musculo der\n  col = mix(col,vec3(1.00,0.77,0.78),S(sd4,0.0));\n  col = mix(col,vec3(0.64,0.32,0.35),S(sd5,0.0)); //sobra musculo izq\n  col = mix(col,vec3(1.00,0.77,0.78),S(sd7,0.0)); //oreja izq\n  col = mix(col,vec3(1.00,0.77,0.78),S(sd8,0.0)); //oreja der\n  col = mix(col,vec3(0.0),S(sd9,0.0)); //pestaña izq\n  col = mix(col,vec3(0.0),S(sd10,0.0)); //pestaña der\n  col = mix(col,vec3(0.0),S(sd11,0.0));\n  col = mix(col,vec3(0.64,0.32,0.35),S(sd12,0.0));//nariz\n  col = mix(col,vec3(1.0),S(sd13,0.0)); //ojo izq\n  col = mix(col,vec3(1.0),S(sd14,0.0)); //ojo der\n  col = mix(col,vec3(0.0),S(sd15,0.0)); //pelo gajo 1\n  col = mix(col,vec3(0.0),S(sd16,0.0)); //pelo gajo 2 //7:49\n  col = mix(col,vec3(0.0),S(sd17,0.0)); //pelo gajo 3\n  col = mix(col,vec3(0.0),S(sd18,0.0)); //pelo gajo 4\n  col = mix(col,vec3(0.0),S(sd19,0.0)); //pelo gajo 5\n  col = mix(col,vec3(0.64,0.32,0.35),S(sd21,0.0));  //11:03\n  col = mix(col,vec3(0.64,0.32,0.35),S(sd22,0.0));\n  col = mix(col,vec3(0.64,0.32,0.35),S(sd23,0.0));\n  col = mix(col,vec3(0.0),S(sd24,0.0));\n  col = mix(col,vec3(0.64,0.32,0.35),S(sd25,0.0));\n  col = mix(col,vec3(0.64,0.32,0.35),S(sd26,0.0));\n  col = mix(col,vec3(0.64,0.32,0.35),S(sd27,0.0));  //sombra\n  col = mix(col,vec3(0.0),S(sd28,0.0)); //ojo izq\n  col = mix(col,vec3(0.0),S(sd29,0.0)); //ojo der\n  col = mix(col,vec3(0.0),S(sd30,0.0)); //oreja lobulo izq\n  col = mix(col,vec3(0.0),S(sd31,0.0)); //oreja lobulo der\n  float t1=mod(iTime, 0.5);\n  float t2=mod(iTime, 1.0);\n  if (t1<t2)\n  {\n   col = mix(col,vec3(0.0),S(sd32,0.0)); // boca\n   col = mix(col,vec3(1.0),S(sd33,0.0));\n  }    \n  return col;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{   vec2 uv = (fragCoord-iResolution.xy)/iResolution.y;\n    vec2 p=uv+vec2(1.5,0.7);\n    p+=vec2(0.3,0.3);\n    p.x*=0.5;\n    p*=0.5+0.7*abs(sin(iTime*0.35));\n    vec3 col = 0.5 + 0.4*cos(iTime+uv.xyx+vec3(0,2,4));\n    col=vec3((col.x+col.y+col.z)/3.0)*vec3(0.2,0.2,1.0);\n    col= RostroGokuv3( p,col*2.0);\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/ssfSDl.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "ssfSDX", "name": "FogTest_01", "author": "yuletian", "description": "test Fog ", "tags": ["testest"], "likes": 4, "viewed": 101, "date": "1619338571", "time_retrieved": "2024-06-20T20:39:06.216303", "image_code": "// Misty Lake. Created by Reinder Nijhoff 2013\n// Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International License.\n// @reindernijhoff\n//\n// https://www.shadertoy.com/view/MsB3WR\n//\n\n#define BUMPFACTOR 0.1\n#define EPSILON 0.1\n#define BUMPDISTANCE 60.\n\n#define time (iTime+285.)\n\n// Noise functions by inigo quilez \n\nfloat noise( const in vec2 x ) {\n    vec2 p = floor(x);\n    vec2 f = fract(x);\n\tf = f*f*(3.0-2.0*f);\n\t\n\tvec2 uv = (p.xy) + f.xy;\n\treturn textureLod( iChannel0, (uv+ 0.5)/256.0, 0.0 ).x;\n}\n\nfloat noise( const in vec3 x ) {\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n\tf = f*f*(3.0-2.0*f);\n\t\n\tvec2 uv = (p.xy+vec2(37.0,17.0)*p.z) + f.xy;\n\tvec2 rg = textureLod( iChannel0, (uv+ 0.5)/256.0, 0.0 ).yx;\n\treturn mix( rg.x, rg.y, f.z );\n}\n\nmat2 rot(const in float a) {\n\treturn mat2(cos(a),sin(a),-sin(a),cos(a));\t\n}\n\nconst mat2 m2 = mat2( 0.60, -0.80, 0.80, 0.60 );\n\nconst mat3 m3 = mat3( 0.00,  0.80,  0.60,\n                     -0.80,  0.36, -0.48,\n                     -0.60, -0.48,  0.64 );\n\nfloat fbm( in vec3 p ) {\n    float f = 0.0;\n    f += 0.5000*noise( p ); p = m3*p*2.02;\n    f += 0.2500*noise( p ); p = m3*p*2.03;\n    f += 0.1250*noise( p ); p = m3*p*2.01;\n    f += 0.0625*noise( p );\n    return f/0.9375;\n}\n\nfloat hash( in float n ) {\n    return fract(sin(n)*43758.5453);\n}\n\n// intersection functions\n\nbool intersectPlane(const in vec3 ro, const in vec3 rd, const in float height, inout float dist) {\t\n\tif (rd.y==0.0) {\n\t\treturn false;\n\t}\n\t\t\n\tfloat d = -(ro.y - height)/rd.y;\n\td = min(100000.0, d);\n\tif( d > 0. && d < dist ) {\n\t\tdist = d;\n\t\treturn true;\n    } else {\n\t\treturn false;\n\t}\n}\n\n// light direction\n\nvec3 lig = normalize(vec3( 0.3,0.5, 0.6));\n\nvec3 bgColor( const in vec3 rd ) {\n\tfloat sun = clamp( dot(lig,rd), 0.0, 1.0 );\n\tvec3 col = vec3(0.5, 0.52, 0.55) - rd.y*0.2*vec3(1.0,0.8,1.0) + 0.15*0.75;\n\tcol += vec3(1.0,.6,0.1)*pow( sun, 8.0 );\n\tcol *= 0.95;\n\treturn col;\n}\n\n// coulds functions by inigo quilez\n\n#define CLOUDSCALE (500./(64.*0.03))\n\nfloat cloudMap( const in vec3 p, const in float ani ) {\n\tvec3 r = p/CLOUDSCALE;\n\n\tfloat den = -1.8+cos(r.y*5.-4.3);\n\t\t\n\tfloat f;\n\tvec3 q = 2.5*r*vec3(0.75,1.0,0.75)  + vec3(1.0,2.0,1.0)*ani*0.15;\n    f  = 0.50000*noise( q ); q = q*2.02 - vec3(-1.0,1.0,-1.0)*ani*0.15;\n    f += 0.25000*noise( q ); q = q*2.03 + vec3(1.0,-1.0,1.0)*ani*0.15;\n    f += 0.12500*noise( q ); q = q*2.01 - vec3(1.0,1.0,-1.0)*ani*0.15;\n    f += 0.06250*noise( q ); q = q*2.02 + vec3(1.0,1.0,1.0)*ani*0.15;\n    f += 0.03125*noise( q );\n\t\n\treturn 0.065*clamp( den + 4.4*f, 0.0, 1.0 );\n}\n\nvec3 raymarchClouds( const in vec3 ro, const in vec3 rd, const in vec3 bgc, const in vec3 fgc, const in float startdist, const in float maxdist, const in float ani ) {\n    // dithering\t\n\tfloat t = startdist+CLOUDSCALE*0.02*hash(rd.x+35.6987221*rd.y+time);//0.1*texture( iChannel0, fragCoord.xy/iChannelResolution[0].x ).x;\n\t\n    // raymarch\t\n\tvec4 sum = vec4( 0.0 );\n\tfor( int i=0; i<64; i++ ) {\n\t\tif( sum.a > 0.99 || t > maxdist ) continue;\n\t\t\n\t\tvec3 pos = ro + t*rd;\n\t\tfloat a = cloudMap( pos, ani );\n\n        // lighting\t\n\t\tfloat dif = clamp(0.1 + 0.8*(a - cloudMap( pos + lig*0.15*CLOUDSCALE, ani )), 0., 0.5);\n\t\tvec4 col = vec4( (1.+dif)*fgc, a );\n\t\t// fog\t\t\n\t//\tcol.xyz = mix( col.xyz, fgc, 1.0-exp(-0.0000005*t*t) );\n\t\t\n\t\tcol.rgb *= col.a;\n\t\tsum = sum + col*(1.0 - sum.a);\t\n\n        // advance ray with LOD\n\t\tt += (0.03*CLOUDSCALE)+t*0.012;\n\t}\n\n    // blend with background\t\n\tsum.xyz = mix( bgc, sum.xyz/(sum.w+0.0001), sum.w );\n\t\n\treturn clamp( sum.xyz, 0.0, 1.0 );\n}\n\n// terrain functions\nfloat terrainMap( const in vec3 p ) {\n\treturn (textureLod( iChannel1, (-p.zx*m2)*0.000046, 0. ).x*600.) * smoothstep( 820., 1000., length(p.xz) ) - 2. + noise(p.xz*0.5)*15.;\n}\n\nvec3 raymarchTerrain( const in vec3 ro, const in vec3 rd, const in vec3 bgc, const in float startdist, inout float dist ) {\n\tfloat t = startdist;\n\n    // raymarch\t\n\tvec4 sum = vec4( 0.0 );\n\tbool hit = false;\n\tvec3 col = bgc;\n\t\n\tfor( int i=0; i<80; i++ ) {\n\t\tif( hit ) break;\n\t\t\n\t\tt += 8. + t/300.;\n\t\tvec3 pos = ro + t*rd;\n\t\t\n\t\tif( pos.y < terrainMap(pos) ) {\n\t\t\thit = true;\n\t\t}\t\t\n\t}\n\tif( hit ) {\n\t\t// binary search for hit\t\t\n\t\tfloat dt = 4.+t/400.;\n\t\tt -= dt;\n\t\t\n\t\tvec3 pos = ro + t*rd;\t\n\t\tt += (0.5 - step( pos.y , terrainMap(pos) )) * dt;\t\t\n\t\tfor( int j=0; j<2; j++ ) {\n\t\t\tpos = ro + t*rd;\n\t\t\tdt *= 0.5;\n\t\t\tt += (0.5 - step( pos.y , terrainMap(pos) )) * dt;\n\t\t}\n\t\tpos = ro + t*rd;\n\t\t\n\t\tvec3 dx = vec3( 100.*EPSILON, 0., 0. );\n\t\tvec3 dz = vec3( 0., 0., 100.*EPSILON );\n\t\t\n\t\tvec3 normal = vec3( 0., 0., 0. );\n\t\tnormal.x = (terrainMap(pos + dx) - terrainMap(pos-dx) ) / (200. * EPSILON);\n\t\tnormal.z = (terrainMap(pos + dz) - terrainMap(pos-dz) ) / (200. * EPSILON);\n\t\tnormal.y = 1.;\n\t\tnormal = normalize( normal );\t\t\n\n\t\tcol = vec3(0.2) + 0.7*texture( iChannel2, pos.xz * 0.01 ).xyz * \n\t\t\t\t   vec3(1.,.9,0.6);\n\t\t\n\t\tfloat veg = 0.3*fbm(pos*0.2)+normal.y;\n\t\t\t\t\t\n\t\tif( veg > 0.75 ) {\n\t\t\tcol = vec3( 0.45, 0.6, 0.3 )*(0.5+0.5*fbm(pos*0.5))*0.6;\n\t\t} else \n\t\tif( veg > 0.66 ) {\n\t\t\tcol = col*0.6+vec3( 0.4, 0.5, 0.3 )*(0.5+0.5*fbm(pos*0.25))*0.3;\n\t\t}\n\t\tcol *= vec3(0.5, 0.52, 0.65)*vec3(1.,.9,0.8);\n\t\t\n\t\tvec3 brdf = col;\n\t\t\n\t\tfloat diff = clamp( dot( normal, -lig ), 0., 1.);\n\t\t\n\t\tcol = brdf*diff*vec3(1.0,.6,0.1);\n\t\tcol += brdf*clamp( dot( normal, lig ), 0., 1.)*vec3(0.8,.6,0.5)*0.8;\n\t\tcol += brdf*clamp( dot( normal, vec3(0.,1.,0.) ), 0., 1.)*vec3(0.8,.8,1.)*0.2;\n\t\t\n\t\tdist = t;\n\t\tt -= pos.y*3.5;\n\t\tcol = mix( col, bgc, 1.0-exp(-0.0000005*t*t) );\n\t\t\n\t}\n\treturn col;\n}\n\nfloat waterMap( vec2 pos ) {\n\tvec2 posm = pos * m2;\n\t\n\treturn abs( fbm( vec3( 8.*posm, time ))-0.5 )* 0.1;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\tvec2 q = fragCoord.xy / iResolution.xy;\n    vec2 p = -1.0 + 2.0*q;\n    p.x *= iResolution.x/ iResolution.y;\n\t\n\t// camera parameters\n\tvec3 ro = vec3(0.0, 0.5, 0.0);\n\tvec3 ta = vec3(0.0, 0.45,1.0);\n\tif (iMouse.z>=1.) {\n\t\tta.xz *= rot( (iMouse.x/iResolution.x-.5)*7. );\n\t}\n\t\t\n\tta.xz *= rot( mod(iTime * 0.05, 6.2831852) );\n    \n\t// build ray\n    vec3 ww = normalize( ta - ro);\n    vec3 uu = normalize(cross( vec3(0.0,1.0,0.0), ww ));\n    vec3 vv = normalize(cross(ww,uu));\n    vec3 rd = normalize( p.x*uu + p.y*vv + 2.5*ww );\n\n\tfloat fresnel, refldist = 5000., maxdist = 5000.;\n\tbool reflected = false;\n\tvec3 normal, col = bgColor( rd );\n\tvec3 roo = ro, rdo = rd, bgc = col;\n\t\n\tif( intersectPlane( ro, rd, 0., refldist ) && refldist < 200. ) {\n\t\tro += refldist*rd;\t\n\t\tvec2 coord = ro.xz;\n\t\tfloat bumpfactor = BUMPFACTOR * (1. - smoothstep( 0., BUMPDISTANCE, refldist) );\n\t\t\t\t\n\t\tvec2 dx = vec2( EPSILON, 0. );\n\t\tvec2 dz = vec2( 0., EPSILON );\n\t\t\n\t\tnormal = vec3( 0., 1., 0. );\n\t\tnormal.x = -bumpfactor * (waterMap(coord + dx) - waterMap(coord-dx) ) / (2. * EPSILON);\n\t\tnormal.z = -bumpfactor * (waterMap(coord + dz) - waterMap(coord-dz) ) / (2. * EPSILON);\n\t\tnormal = normalize( normal );\t\t\n\t\t\n\t\tfloat ndotr = dot(normal,rd);\n\t\tfresnel = pow(1.0-abs(ndotr),5.);\n\n\t\trd = reflect( rd, normal);\n\n\t\treflected = true;\n\t\tbgc = col = bgColor( rd );\n\t}\n\n\tcol = raymarchTerrain( ro, rd, col, reflected?(800.-refldist):800., maxdist );\n    //col = raymarchClouds( ro, rd, col, bgc, reflected?max(0.,min(150.,(150.-refldist))):150., maxdist, time*0.05 );\n\t\n\tif( reflected ) {\n\t\tcol = mix( col.xyz, bgc, 1.0-exp(-0.0000005*refldist*refldist) );\n\t\tcol *= fresnel*0.9;\t\t\n\t\tvec3 refr = refract( rdo, normal, 1./1.3330 );\n\t\tintersectPlane( ro, refr, -2., refldist );\n\t\tcol += mix( texture( iChannel2, (roo+refldist*refr).xz*1.3 ).xyz * \n\t\t\t\t   vec3(1.,.9,0.6), vec3(1.,.9,0.8)*0.5, clamp( refldist / 3., 0., 1.) ) \n\t\t\t   * (1.-fresnel)*0.125;\n\t}\n\t\n\tcol = pow( col, vec3(0.7) );\n\t\n\t// contrast, saturation and vignetting\t\n\tcol = col*col*(3.0-2.0*col);\n    col = mix( col, vec3(dot(col,vec3(0.33))), -0.5 );\n \tcol *= 0.25 + 0.75*pow( 16.0*q.x*q.y*(1.0-q.x)*(1.0-q.y), 0.1 );\n\t\n    fragColor = vec4( col, 1.0 );\n}\n", "image_inputs": [{"id": "XdX3Rn", "previewfilepath": "/media/ap/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg", "ctype": "texture"}, {"id": "Xsf3zn", "previewfilepath": "/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc-by-nc-sa-4.0", "thumbnail": "https://www.shadertoy.com/media/shaders/ssfSDX.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "ssfSR7", "name": "Lines Bounce", "author": "NakedBowman", "description": "Lines bounce", "tags": ["bounce"], "likes": 2, "viewed": 33, "date": "1618501250", "time_retrieved": "2024-06-20T20:39:06.222369", "image_code": "float plot(vec2 uv, float pct, float i){\nreturn step(pct - abs(cos(iTime)* 0.1), uv.y) - step(pct + i * 0.01, uv.y);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    \n\n    vec3 color = vec3(1);\n  \n    //float x = pow(cos(dist * uv.x / 2.f), 8.0);\n    //float x = 1.0 - pow(uv.x,2.f);\n     //x = pow(cos(3.14 * uv.x / 2.f), 1.0); \n    \n    vec3 colorA = vec3(0.149,0.441,0.912);\n    vec3 colorB = vec3(0.990,0.233,0.224);\n    vec3 colorC = vec3(0.590,0.233,0.124);\n    \n    \n    float x = abs(sin(iTime + uv.x));\n\n   \n    for(float i = 0.; i < 3.; i++)\n    {\n        float x = abs(sin(iTime + uv.x + i * 0.3 ));\n        float pct = plot(uv,x, i);\n        \n        color = (1. - pct) * color + pct* vec3(mix(colorB, colorA, x)); \n        // color = (1.0-=pct)*color+=pct*vec3(mix(colorB, colorA, x));\n    }\n    \n    //color = ( 1.f - pct) * color + pct*vec3(mix(colorB, colorA, x)); \n    \n    color = vec3(1.) - color + vec3(mix(colorC, colorA, x));\n    // Output to screen\n    fragColor = vec4(color,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/ssfSR7.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "ssfSRr", "name": "2D raymarching example", "author": "sver", "description": "Basic example of ray marching", "tags": ["2d", "raymarching", "sdf", "triangle", "line", "circle", "rasterization", "segment"], "likes": 12, "viewed": 118, "date": "1618180248", "time_retrieved": "2024-06-20T20:39:06.222369", "image_code": "float epsilon;\nconst int cC = 4;\nconst int lC = 1;\nconst int tC = 1;\nconst int qC = 2;\n\nstruct Circle {\n    vec2 center;\n    float radius;\n    vec3 col;\n};\n\nstruct Line {\n    vec2[2] v;\n    vec3 col;\n};\n\nstruct Triangle {\n    vec2[3] v;\n    vec3 col;\n};\n\nstruct Quad {\n    vec2[4] v;\n    vec3 col;\n};\n\nstruct Scene {\n    Circle[cC] cs;\n    Line[lC] ls;\n    Triangle[tC] ts;\n    Quad[qC] qs;\n} scene;\n\nfloat isRay(vec2 uv, vec2 orig, vec2 dir, float len) {\n    vec2 u = uv - orig;\n    if (dot(normalize(u), dir) < 0.0 || length(uv - orig) > len) return 0.0;\n    return smoothstep(epsilon, 0., abs(u.y * dir.x - u.x * dir.y));\n}\n\nfloat isLineSegment(vec2 uv, vec2 v[2]) {\n    return isRay(uv, v[0], normalize(v[1] - v[0]), length(v[1]-v[0])) ;\n}\n\nbool isPointRightOfLine(vec2 point, vec2 v[2]) {\n    vec2 l = v[0] - v[1];\n    vec2 N =  normalize(vec2(-l.y, l.x));\n    return dot(N, normalize(point - v[0])) > 0.0;\n}\n\nfloat isCirleOutline(vec2 uv, vec2 cen, float r) {\n    float t = length(uv - cen);\n    return smoothstep(epsilon, 0., abs(t-r));\n}\n\nbool isCircle(vec2 uv, vec2 cen, float r) {\n    return length(uv - cen) < r;\n}\n\nfloat isTriangleOutline(vec2 uv, vec2 v[3]) {\n    vec2 l[2] = vec2[2](v[0], v[1]);\n    float t = isLineSegment(uv, l);\n    l = vec2[2](v[1], v[2]);\n    float tt = isLineSegment(uv, l);\n    t = max(t, tt);\n    l = vec2[2](v[2], v[0]);\n    return max(t, isLineSegment(uv, l));\n}\n\nbool isTriangle(vec2 uv, vec2 v[3]) {\n    vec2 l1[2] = vec2[2](v[0], v[1]);\n    vec2 l2[2] = vec2[2](v[1], v[2]);\n    vec2 l3[2] = vec2[2](v[2], v[0]);\n    return isPointRightOfLine(uv, l1)\n        && isPointRightOfLine(uv, l2)\n        && isPointRightOfLine(uv, l3);\n}\n\nfloat isQuadOutline(vec2 uv, vec2 v[4]) {\n    vec2 l[2] = vec2[2](v[0], v[1]);\n    float t = isLineSegment(uv, l);\n    l = vec2[2](v[1], v[2]);\n    float tt = isLineSegment(uv, l);\n    t = max(t, tt);\n    l = vec2[2](v[2], v[3]);\n    tt = isLineSegment(uv, l);\n    t = max(t, tt);\n    l = vec2[2](v[3], v[0]);\n    return max(t, isLineSegment(uv, l));\n}\n\nbool isQuad(vec2 uv, vec2 v[4]) {\n    vec2 l1[2] = vec2[2](v[0], v[1]);\n    vec2 l2[2] = vec2[2](v[1], v[2]);\n    vec2 l3[2] = vec2[2](v[2], v[3]);\n    vec2 l4[2] = vec2[2](v[3], v[0]);\n    return isPointRightOfLine(uv, l1)\n        && isPointRightOfLine(uv, l2)\n        && isPointRightOfLine(uv, l3)\n        && isPointRightOfLine(uv, l4);\n    \n}\n\nfloat distToLineSeg(vec2 orig, vec2 v[2]) {\n    vec2 pa = orig - v[0];\n    vec2 ba = v[1] - v[0];\n    float h = clamp(dot(pa,ba)/dot(ba,ba), 0.0, 1.0);\n    vec2 d = pa - ba*h;\n    return dot(d,d);\n}\n\nfloat distToTriangle(vec2 orig, vec2 v[3]) {\n    vec2 l[2] = vec2[2](v[0], v[1]);\n    float t = distToLineSeg(orig, l);\n    l = vec2[2](v[1], v[2]);\n    float tt = distToLineSeg(orig, l);\n    t = min(t, tt);\n    l = vec2[2](v[2], v[0]);\n    return min(t, distToLineSeg(orig, l));\n}\n\nfloat distToQuad(vec2 orig, vec2 v[4]) {\n    vec2 l[2] = vec2[2](v[0], v[1]);\n    float t = distToLineSeg(orig, l);\n    l = vec2[2](v[1], v[2]);\n    float tt = distToLineSeg(orig, l);\n    t = min(t, tt);\n    l = vec2[2](v[2], v[3]);\n    tt = distToLineSeg(orig, l);\n    t = min(t, tt);\n    l = vec2[2](v[3], v[0]);\n    return min(t, distToLineSeg(orig, l));\n}\n\nfloat closestDist(vec2 orig) {\n   float t = 9999.0, tt;\n   for (int i = 0; i < scene.cs.length(); i++) {\n       tt = pow(length(orig - scene.cs[i].center) - scene.cs[i].radius, 2.0);\n       t = min(t, tt);\n   }\n   \n   for (int i = 0; i < scene.ls.length(); i++) {\n       tt = distToLineSeg(orig, scene.ls[i].v);\n       t = min(t,tt);\n   }\n   \n   for (int i = 0; i < scene.ts.length(); i++) {\n       tt = distToTriangle(orig, scene.ts[i].v);\n       t = min(t,tt);\n   }\n   \n   for (int i = 0; i < scene.qs.length(); i++) {\n       tt = distToQuad(orig, scene.qs[i].v);\n       t = min(t,tt);\n   }\n   \n   return min(sqrt(t) - epsilon, 0.1);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    epsilon = 1.5/iResolution.y;\n    vec2 uv = (fragCoord - 0.5*iResolution.xy) / iResolution.y;\n\n    vec3 col = vec3(0.9);\n    vec2 origin = vec2(0);\n    float d = iTime/2.0;\n    vec2 dir = vec2(sin(d),cos(d));\n    if (iMouse.z > 0.0) {\n        vec2 mouse = (iMouse.xy / iResolution.xy * 2.0 - vec2(1.0)) ;\n        dir = normalize(mouse - origin);\n    } \n    Circle cs[cC] = Circle[cC](\n        Circle(vec2(0.6, 0.3), 0.02, vec3(0.3, 0.5, 0.2)),\n        Circle(vec2(-0.1, 0.2), 0.01, vec3(0.6, 0.3, 0.3)),\n        Circle(vec2(-0.5, -0.4), 0.07, vec3(0.1, 0.7, 0.5)),\n        Circle(vec2(0.4, -0.3), 0.05, vec3(0.5, 0.8, 0.9))\n    );\n    Line ls[lC] = Line[lC](\n        Line(vec2[2](vec2(0.4, 0.2), vec2(0.3, -0.2)), vec3(0.1, 0.5, 0.8))\n    );\n    Triangle ts[tC] = Triangle[tC](\n        Triangle(vec2[3](vec2(-0.4, 0.0), vec2(-0.3, 0.1),  vec2(-0.25, 0.05)), vec3(0.2, 0.5, 0.3))\n    );\n    Quad qs[qC] = Quad[qC](\n        Quad(vec2[4](vec2(-0.5, -0.05),vec2(-0.4, -0.2), vec2(-0.5, -0.25), vec2(-0.6, -0.15)), vec3(0.3, 0.3, 0.7)),\n        Quad(vec2[4](vec2(0.0, 0.5), vec2(0.1, 0.4), vec2(0.05, 0.35), vec2(-0.05, 0.45)), vec3(0.9, 0.1, 0.7))\n    );\n    \n    scene.cs = cs;\n    scene.ls = ls;\n    scene.ts = ts;\n    scene.qs = qs;\n    for (int i = 0; i < cs.length(); i++){\n        if (isCircle(uv, cs[i].center, cs[i].radius)) col = mix(col, cs[i].col, 0.3);\n        col = mix( col, cs[i].col , isCirleOutline(uv, cs[i].center, cs[i].radius));\n    }\n    for (int i = 0; i < ls.length(); i++){\n        col = mix(col, ls[i].col, isLineSegment(uv, ls[i].v));\n    }\n    for (int i = 0; i < ts.length(); i++){\n        if (isTriangle(uv, ts[i].v)) col = mix(col, ts[i].col, 0.3);\n        col = mix(col, ts[i].col, isTriangleOutline(uv, ts[i].v));\n    }\n    for (int i = 0; i < qs.length(); i++){\n        if (isQuad(uv, qs[i].v)) col = mix(col, qs[i].col, 0.3);\n        col = mix(col, qs[i].col, isQuadOutline(uv, qs[i].v));\n    }\n    \n    vec2 curPos = origin + dir * 0.1;\n    float len = length(dir * 0.1);\n    for (int i = 0; i < 20; i++) {\n        float r = closestDist(curPos);\n        col = mix( col, vec3(0), isCirleOutline(uv, curPos, r));\n        if (r < epsilon) break;\n        curPos += dir * r;\n        len += r;\n    }\n    \n    col = mix( col, vec3(0), isRay(uv, origin, dir, len));\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/ssfSRr.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "ssfSzB", "name": "Copper Convolutions", "author": "Drakyen", "description": "More work on lighting systems & reflections, along with a slightly more interesting scene.", "tags": ["3d", "reflections"], "likes": 3, "viewed": 36, "date": "1618776775", "time_retrieved": "2024-06-20T20:39:06.222369", "image_code": "struct mat\n{\n    vec3 col;\n    float diff;\n    float spec;\n    float refl;\n    float fres;\n};\n\nstruct obj\n{\n    float sdf;\n    mat mat;\n};\n\nstruct hit\n{\n    float rdf;\n    vec3 pos;\n    mat mat;\n};\n\n#define NMAT mat(vec3(0.1), 1., 0., 0., 0.)\n#define FMAT mat(vec3(0.3), 1., 1., 0.2, 0.7)\n#define OMAT mat(vec3(1.000,0.525,0.161) * 1.5, 1., 1., 0.5, 1.)\n\n#define rot(a) mat2(cos(a), -sin(a), sin(a), cos(a))\n\nfloat bsdf(vec3 p, vec3 s)\n{\n    p.xy *= rot(iTime);\n    p.xz *= rot(-iTime);\n    vec3 q = abs(p) - s;\n    return min(max(q.x,max(q.y,q.z)),0.) + length(max(q, 0.));\n}\n\nobj om(obj a, obj b)\n{\n    if(a.sdf < b.sdf) {return a;} else {return b;}\n}\n\nobj sceneR(vec3 p)\n{\n   obj b = obj(bsdf(p - vec3(0, 2, 5), vec3(1,0.2,1)), OMAT);\n   obj b1 = obj(bsdf(p - vec3(0, 1, 7), vec3(1,1,0.2)), OMAT);\n   obj b2 = obj(bsdf(p - vec3(-2, 2, 9), vec3(1.5,1.5,1.5)), OMAT);\n   obj b3 = obj(bsdf(p - vec3(2, 2, 7), vec3(0.2,2,1)), OMAT);\n   obj b4 = obj(bsdf(p - vec3(0, 3, 5), vec3(1,1,0.2)), OMAT);\n   \n   return om(b,om(b1,om(b2,om(b3,b4))));\n}\n\nobj scene(vec3 p)\n{\n    vec3 op = p;\n    p.x = abs(p.x) - 2.;  \n    p.x = abs(p.x) - 4.;\n    p.y += sin(p.x) / 4.;\n    //p.y = abs(p.y) - 0.5;\n    p.z = mix(abs(p.z - 4.) - 5., p.z, mod(iTime / 2., 3.2));  \n    if(p.z > 30.) p.z -= 29.;\n    \n    return om(sceneR(p), obj(op.y + 1., FMAT));\n}\n\nhit trace(vec3 ro, vec3 rd)\n{\n    float d = 0.;\n    vec3 p;\n    obj s;\n    for(int i = 0; i < 256; i++)\n    {\n        p = ro + rd * d; \n        s = scene(p);\n        d += s.sdf;\n        if(s.sdf < 0.001) return hit(d, p, s.mat);\n        if(d > 128.) break;\n    }\n    return hit(-1., vec3(0), NMAT);\n}\n\nvec3 normal(hit h)\n{\n    vec2 e = vec2(0.01, 0.);\n    float d = scene(h.pos).sdf;\n    vec3 n = d - vec3(scene(h.pos - e.xyy).sdf, scene(h.pos - e.yxy).sdf, scene(h.pos - e.yyx).sdf);\n    return normalize(n);\n}\n\nvec3 lit(hit o, vec3 rd)\n{\n    vec3 n = normal(o);\n    vec3 ld = normalize(vec3(0,2,0) - o.pos);\n    float diff = max(dot(n,ld), 0.) * o.mat.diff;\n    float fres = pow(1. - abs(dot(n,rd)), 4.) * o.mat.fres;\n    float spec = pow(max(dot(reflect(-ld, n), -rd), 0.),40.) * o.mat.spec;\n    vec3 col = o.mat.col * (diff + fres) + spec;\n    return col;\n}\n\nvec3 col(vec3 ro, vec3 rd)\n{\n    mat ret = NMAT;\n    vec3 rfo = ro, rfd = rd;\n    float mxamnt = 1.;\n\n    for(int i = 0; i < 8; i++)\n    {\n        hit h = trace(rfo, rfd);\n        ret.col = mix(ret.col, lit(h, rfd), mxamnt);\n        if(h.mat.refl <= 0.) break;       \n        vec3 n = normal(h);  \n        rfd = reflect(rfd, n);\n        rfo = h.pos + n * 0.001 * 2.;\n        mxamnt = clamp(mxamnt - (1. - h.mat.refl), 0., 1.);\n    }\n    \n    return ret.col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy)/iResolution.y;\n\n    vec3 ro = vec3(0,2,0);\n    vec3 rd = normalize(vec3(uv.x,uv.y, 1.));\n    \n    // Output to screen\n    fragColor = vec4(col(ro,rd),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/ssfSzB.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "ssj3Dy", "name": "Breathing Gyroid - study 2/2", "author": "MacSlow", "description": "Study 2/2 into what can be done with all the different parameters one can tweak in a gyroid-function. You can yaw-orbit around the gyroid with the mouse.", "tags": ["3d", "phong", "sdf", "gyroid"], "likes": 8, "viewed": 208, "date": "1617919500", "time_retrieved": "2024-06-20T20:39:08.167746", "image_code": "////////////////////////////////////////////////////////////////////////////////\n//\n// Breathing Gyroid - study 2/2 into what can be done with all the different\n// parameters one can tweak in a gyroid-function.\n//\n// Copyright 2021 Mirco Müller\n//\n// Author(s):\n//   Mirco \"MacSlow\" Müller <macslow@gmail.com>\n//\n// This program is free software: you can redistribute it and/or modify it\n// under the terms of the GNU General Public License version 3, as published\n// by the Free Software Foundation.\n//\n// This program is distributed in the hope that it will be useful, but\n// WITHOUT ANY WARRANTY; without even the implied warranties of\n// MERCHANTABILITY, SATISFACTORY QUALITY, or FITNESS FOR A PARTICULAR\n// PURPOSE.  See the GNU General Public License for more details.\n//\n// You should have received a copy of the GNU General Public License along\n// with this program.  If not, see <http://www.gnu.org/licenses/>.\n//\n////////////////////////////////////////////////////////////////////////////////\n\n// the HW_PERFORMANCE-check should take care of some optimization, if that does\n// not help you can still force GROUND_WAVES to 0 and/or AA_SIZE to 1 manually\n#if HW_PERFORMANCE==0\n#define GROUND_WAVES 0\nconst int AA_SIZE = 1;\n#else\n#define GROUND_WAVES 1\nconst int AA_SIZE = 2;\n#endif\n\nconst float PI = 3.14159265359;\nconst int MAX_ITER = 96;\nconst float STEP_BIAS = .5;\nconst float EPSILON = .0001;\nconst float MAX_DIST = 12.;\n\nfloat smin (float a, float b, float k)\n{\n    float h = clamp (.5 + .5*(b - a)/k, .0, 1.);\n    return mix (b, a, h) - h*k*(1. - h); \n}\n\nmat2 r2d (float deg)\n{\n    float rad = radians (deg);\n    float c = cos (rad);\n    float s = sin (rad);\n    return mat2 (c, s, -s, c);\n}\n\n// using a slightly adapted implementation of iq's simplex noise from\n// https://www.shadertoy.com/view/Msf3WH with hash(), noise() and fbm()\nvec2 hash (in vec2 p)\n{\n    p = vec2 (dot (p, vec2 (127.1, 311.7)),\n              dot (p, vec2 (269.5, 183.3)));\n\n    return -1. + 2.*fract (sin (p)*43758.5453123);\n}\n\nfloat noise (in vec2 p)\n{\n    const float K1 = .366025404;\n    const float K2 = .211324865;\n\n    vec2 i = floor (p + (p.x + p.y)*K1);\n    \n    vec2 a = p - i + (i.x + i.y)*K2;\n    vec2 o = step (a.yx, a.xy);    \n    vec2 b = a - o + K2; \n    vec2 c = a - 1. + 2.*K2;\n\n    vec3 h = max (.5 - vec3 (dot (a, a), dot (b, b), dot (c, c) ), .0);\n\n    vec3 n = h*h*h*h*vec3 (dot (a, hash (i + .0)),\n                           dot (b, hash (i + o)),\n                           dot (c, hash (i + 1.)));\n\n    return dot (n, vec3 (70.));\n}\n\nfloat fbm (in vec2 p, in int iters)\n{\n    mat2 rot = r2d (35.);\n    float d = .0;\n    float f = 1.;\n    float fsum = .0;\n\n    for (int i = 0; i < iters; ++i) {\n        d += f*noise (p);\n        fsum += f;\n        f *= .5;\n    }\n    d /= fsum;\n\n    return d;\n}\n\nfloat plane (vec3 p, float h)\n{\n    return p.y + h;\n}\n\nfloat ball (vec3 p, float r)\n{\n    return length (p) - r;\n}\n\nfloat cube (vec3 p, float size)\n{\n    return length (max (abs (p) - size, .0));\n}\n\nfloat gyroid (vec3 p, float scale, float thickness, float bias, vec2 modulation, vec2 offset)\n{\n    float modulate = (modulation.x > modulation.y) ? modulation.x : modulation.y;\n    p *= scale;\n    float d = dot (sin(p*modulation.x) + offset.x,\n                   cos(p.yzx*modulation.x) + offset.y) - bias;\n\n    return abs (d)/scale/modulate - thickness;\n}\n\nfloat sMinGyroid (vec3 p,\n                  float r,\n                  float scale,\n                  float thickness,\n                  float bias,\n                  vec2 modulation,\n                  vec2 offset,\n                  float blend,\n                  float distScale)\n{\n    float ball = ball (p, r);\n    float gyroid = gyroid (p, scale, thickness, bias, modulation, offset)*distScale;\n    return  smin (ball, gyroid, blend);\n}\n\nfloat scene (vec3 p, out int id)\n{\n    // doing the wavy ground with fbm() is a bit on the costly side\n    vec3 groundP = p;\n    groundP.x += iTime;\n    float pk = 1.5;\n    #if GROUND_WAVES \n    if( p.y<0.5 )\n    pk += .25*fbm(groundP.xz, 2);\n    #endif\n    float ground = plane (p, pk);\n\n    p.xz *= r2d (5.*iTime);\n    p.yx *= r2d (7.*iTime);\n    vec2 modulation = vec2 (1.2, .8);\n    float thickness1 = .025 + .025*(cos (10.*iTime)*.5 + .5);\n    float thickness2 = .05 + .05*(cos (13.*iTime)*.5 + .5);\n    float thickness3 = .1 + .1*(cos (16.*iTime)*.5 + .5);\n    float bias1 = 1.3;\n    float bias2 = .3;\n    float bias3 = .025;\n    float scale = 7.;\n    vec2 offset = vec2 (.1, .4);\n    float sMinBlend = -.05;\n    float distScale = .55;\n\n    float r1 = 1.35 - .6*(cos (.5*iTime)*.5+.5);    // 1.35\n    float r2 = 1.1 - .4*(cos (iTime + 1.)*.5+.5);   // 1.1\n    float r3 = .7 + .2*(cos (2.*iTime + 2.)*.5+.5); // .7 + .2\n\n    float g1 = sMinGyroid (p, r1, scale, thickness1, bias1, modulation, offset, sMinBlend, distScale);\n    float g2 = sMinGyroid (p, r2, scale, thickness2, bias2, modulation, offset, sMinBlend, distScale);\n    float g3 = sMinGyroid (p, r3, scale, thickness3, bias3, modulation, offset, sMinBlend, distScale);\n\n    float d = ground;\n    d = min (d, g1);\n    d = min (d, g2);\n    d = min (d, g3);\n\n    if (d == ground) id = 0;\n    if (d == g1) id = 1;\n    if (d == g2) id = 2;\n    if (d == g3) id = 3;\n\n    return d;\n}\n\nfloat raymarch (vec3 ro, vec3 rd, out int iter, out int id)\n{\n    float d = .0;\n    float t = .0;\n    int i = 0;\n    vec3 p = vec3 (.0);\n    int ignoreId = 0;\n\n    for (; i < MAX_ITER; ++i) {\n        p = ro + d*rd;\n        t = scene (p, id);\n        if (abs (t) < EPSILON*(1. - .125*t) || d > MAX_DIST) {\n            iter = i;\n            break;\n        }\n        d += t*STEP_BIAS;\n    }\n\n    return d;\n}\n\nvec3 normal (vec3 p)\n{\n    int ignoreId = 0;\n    vec2 e = vec2 (EPSILON, .0);\n    float d = scene (p, ignoreId);\n\n    vec3 n = normalize (vec3 (scene (p + e.xyy, ignoreId),\n                              scene (p + e.yxy, ignoreId),\n                              scene (p + e.yyx, ignoreId)) - d);\n    return n;\n}\n\nfloat shadow (vec3 p, vec3 n, vec3 lPos, vec3 lDir)\n{\n    int ignoreIter = 0;\n    int ignoreId = 0;\n    float distToWorld = raymarch (p + .01*n, lDir, ignoreIter, ignoreId);\n    float distToLight = distance (p, lPos);\n\n    return distToWorld < distToLight ? .3 : 1.;\n}\n\nfloat ao (vec3 p, vec3 n, float stepSize, int iterations, float intensity)\n{\n  float ao = .0; \n  float dist = .0; \n  int ignoreId = 0;\n\n  for (int a = 1; a <= iterations; ++a) {\n    dist = float (a)*stepSize;\n    ao += max (.0, (dist - scene (p + n*dist, ignoreId))/dist);\n  }\n\n  return 1. - ao*intensity;\n}\n\nvec3 shade (vec3 ro, vec3 rd, float d, vec3 n, int id)\n{\n    vec3 p = ro + d*rd;\n\n    vec3 lPos1 = vec3 (3.*cos(iTime), 3., 3.*sin(.4*iTime));\n    vec3 lDir1 = normalize (lPos1 - p);\n    float lDist1 = distance (lPos1, p);\n    float attn1 = 30. / (lDist1*lDist1);\n    vec3 lColor1 = vec3 (1., .9, .3);\n\n    vec3 lPos2 = vec3 (-2.*cos(.3*iTime), 3., 4.*sin(iTime));\n    vec3 lDir2 = normalize (lPos2 - p);\n    float lDist2 = distance (lPos2, p);\n    float attn2 = 40. / (lDist2*lDist2);\n    vec3 lColor2 = vec3 (.2, .4, 1.);\n\n    vec3 amb = vec3 (.1); \n    float diff1 = max (dot (n, lDir1), .0);\n    float diff2 = max (dot (n, lDir2), .0);\n    vec3 h1 = normalize (lDir1 - rd);\n    vec3 h2 = normalize (lDir2 - rd);\n    float spec1 = pow (max (dot (h1, n), .0), 40.);\n    float spec2 = pow (max (dot (h2, n), .0), 40.);\n\n    float s1 = shadow (p, n, lPos1, lDir1);\n    float s2 = shadow (p, n, lPos2, lDir2);\n\n    float ao = ao (p, n, .05, 12, .1);\n\n    bool isFloor = id == 0;\n    float phase = cos (20.*(p.x + iTime));\n    float mask = smoothstep (.005*d, .0025*d, .5 + .5*phase);\n    vec3 floorMaterial = 1.5*mix (vec3(.8), vec3 (.2), mask);\n\n    vec3 gyroidMaterial = vec3(.0);\n    if (id == 1) gyroidMaterial = 1.5*vec3(.8, .2, .1);\n    if (id == 2) gyroidMaterial = 2.*vec3(.8, .7, .2);\n    if (id == 3) gyroidMaterial = 3.5*vec3(.8, .5, .3);\n\n    vec3 diffMaterial = isFloor ? floorMaterial : gyroidMaterial;\n\n    return amb + ao*(attn1*s1*(diff1*diffMaterial*lColor1 + spec1) +\n                     attn2*s2*(diff2*diffMaterial*lColor2 + spec2));\n}\n\nvec3 camera (vec2 uv, vec3 ro, vec3 aim, float zoom)\n{\n    vec3 camForward = normalize (aim - ro);\n    vec3 worldUp = vec3 (.0, 1., .0);\n    vec3 camRight = normalize (cross (camForward, worldUp));\n    vec3 camUp = normalize (cross (camRight, camForward));\n    vec3 camCenter = normalize (ro + camForward*zoom);\n\n    return normalize (camCenter + uv.x*camRight + uv.y*camUp - ro);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // normalize and aspect-correct UVs\n    vec2 uv = 2.*(fragCoord/iResolution.xy) - 1.;\n    uv.x *= iResolution.x/iResolution.y;\n\n    // allow some yaw-orbit with the mouse\n    vec2 yaw = .75*vec2 (PI*cos (4.*iMouse.x/iResolution.x),\n                         PI*sin (4.*iMouse.x/iResolution.x));\n    float pitch = 1.;\n\n    // create origin/camera/view-ray\n    vec3 ro = vec3 (yaw.x, pitch, yaw.y);\n    vec3 aim = vec3 (.0, .0, .0);\n    float zoom = 1.75;\n    vec3 rd = camera (uv, ro, aim, zoom);\n\n    // raymarch, shading & floor-glow\n    int iter = 0;\n    float d = .0;\n    vec3 p = vec3 (.0);\n    vec3 n = vec3 (.0);\n    vec3 color = vec3 (.0);\n    float fog = .0;\n\n    for (int x = 0; x < AA_SIZE; ++x) {\n        for (int y = 0; y < AA_SIZE; ++y) {\n\n\t\t\t// anti-alias offset\n\t\t\tvec2 pixelOffset = vec2 (float (x), float (y))/float (AA_SIZE);\n\n\t\t\t// normalize and aspect-correct UVs\n            uv = 2.*((fragCoord + pixelOffset)/iResolution.xy) - 1.;\n            uv.x *= iResolution.x/iResolution.y;\n\n    \t\t// create viewray\n    \t\trd = camera (uv, ro, aim, zoom);\n\n\t\t\t// primary/view ray\n            int id = 0;\n\t\t\td = raymarch (ro, rd, iter, id);\n            p = ro + d*rd;\n            n = normal (p);\n\t\t\tvec3 ctmp = shade (ro, rd, d, n, id);\n            fog = 1. / (1. + d*d*.1);\n            ctmp *= fog;\n            ctmp = mix (ctmp, .5*vec3 (.15, .4, .9), pow (1. - 1./d, 6.));\n\n\t\t\tcolor += ctmp;\n        }\n    }\n    color /= float (AA_SIZE*AA_SIZE);\n\n    // make the final picture 'pretty'\n    color = color / (1. + color);\n    color *= 1. - .25*dot (uv, uv);\n    color = .2*color + .8*sqrt (color);\n\n    fragColor = vec4(color, 1.);\n}", "image_inputs": [{"id": "lllXWM", "previewfilepath": "https://soundcloud.com/weareoliver/oliver-mechanical", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0, "src": "https://soundcloud.com/weareoliver/oliver-mechanical", "ctype": "musicstream"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/ssj3Dy.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "ssj3Wc", "name": "turbulence_texture", "author": "penghuailiang", "description": "\n在fbm中对噪声函数取绝对值\n\nhttps://huailiang.github.io/blog/2021/noise/", "tags": ["fbm"], "likes": 4, "viewed": 339, "date": "1618069877", "time_retrieved": "2024-06-20T20:39:08.168005", "image_code": "vec3 random_perlin( vec3 p ) {\n    p = vec3(\n            dot(p,vec3(127.1,311.7,69.5)),\n            dot(p,vec3(269.5,183.3,132.7)), \n            dot(p,vec3(247.3,108.5,96.5)) \n            );\n    return -1.0 + 2.0*fract(sin(p)*43758.5453123);\n}\nfloat noise_perlin (vec3 p) {\n    vec3 i = floor(p);\n    vec3 s = fract(p);\n\n    // 3D网格有8个顶点\n    float a = dot(random_perlin(i),s);\n    float b = dot(random_perlin(i + vec3(1, 0, 0)),s - vec3(1, 0, 0));\n    float c = dot(random_perlin(i + vec3(0, 1, 0)),s - vec3(0, 1, 0));\n    float d = dot(random_perlin(i + vec3(0, 0, 1)),s - vec3(0, 0, 1));\n    float e = dot(random_perlin(i + vec3(1, 1, 0)),s - vec3(1, 1, 0));\n    float f = dot(random_perlin(i + vec3(1, 0, 1)),s - vec3(1, 0, 1));\n    float g = dot(random_perlin(i + vec3(0, 1, 1)),s - vec3(0, 1, 1));\n    float h = dot(random_perlin(i + vec3(1, 1, 1)),s - vec3(1, 1, 1));\n\n    // Smooth Interpolation\n    vec3 u = smoothstep(0.,1.,s);\n\n    // 根据八个顶点进行插值\n    return mix(mix(mix( a, b, u.x),\n                mix( c, e, u.x), u.y),\n            mix(mix( d, f, u.x),\n                mix( g, h, u.x), u.y), u.z);\n}\nfloat noise_turbulence(vec3 p)\n{\n    float f = 0.0;\n    float a = 1.;\n    p = 4.0 * p;\n    for (int i = 0; i < 5; i++) {\n        f += a * abs(noise_perlin(p));\n        p = 2.0 * p;\n        a /= 2.;\n    }\n    return f;\n}\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = fragCoord.xy/iResolution.xy;\n    float c1 = noise_turbulence(vec3(1.*uv, iTime/10.0));\n    vec3 color = vec3(1.5*c1, 1.5*c1*c1*c1, c1*c1*c1*c1*c1*c1);\n    fragColor = vec4( color, 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/ssj3Wc.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "ssjGW3", "name": "Mandelbrot Zoom _ PR", "author": "p_ritoranta", "description": "mandelbrot zoom in black and white", "tags": ["fractal"], "likes": 0, "viewed": 41, "date": "1618057602", "time_retrieved": "2024-06-20T20:39:08.168005", "image_code": "// kompleksiluku potenssiin 2\nvec2 complex_square(vec2 v){\n    float real = v.x * v.x - v.y * v.y;\n    float imag = 2.0 * v.x * v.y;\n    return vec2(real, imag);\n}\n\n// mandelbrot iteraatio\nvec2 mandelbrot(vec2 z, vec2 c){\n    return complex_square(z) + c;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // koordinaattien alustus (videosta \"Shadertoy for absolute beginners\")\n    vec2 uv = fragCoord.xy / iResolution.xy; // 0 <> 1\n    uv -= .5;\n    uv.x *= iResolution.x/iResolution.y;\n    uv *= 2.0;\n    \n    // tästä eteenpäin: mandelbrot zoom (videosta \"How to make a Mandelbrot Zoom in Godot Shaders\")\n    \n    int iterations = 300; // kuvion tarkkuus, isompi tarkempi\n\n    vec2 z = vec2(0.0); // aloitetaan z=0\n    float z_mag = 0.0; // magnitudi, mitataan tällä kuuluuko mandelbrotin joukkoon\n    vec2 c = uv; // koordinaatti\n    c/=iTime; // zoomataan ajan mukaan\n    c.y += 0.1; // zoomauskohta ylöspäin\n    c.x -= sqrt(0.755*0.755 - 0.1*0.1); //zoomauskohta vasemmalle päin\n    \n    float color=0.0; // lopullinen väri, valkoinen joukossa ja musta ulkopuolella\n\n    for(int i=0; i<iterations; i++){\n        z = mandelbrot(z,c); //uusi z\n        z_mag=sqrt(z.x*z.x + z.y*z.y); //etäisyys, eli kuuluuko joukkoon\n        color++; // harmaan sävyjä joukon ulkopuolella, katso lopullinen väritys\n        \n        if(z_mag >= 2.0){\n            break; // kun ei enää kuulu joukkoon, ei iteroida\n        }\n    }\n\n    // pikselin väritys\n    fragColor = vec4(vec3(color/float(iterations)),1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/ssjGW3.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "ssjGWy", "name": "Gear Projection", "author": "dr2", "description": "Cardan straight line mechanism - a double epicycloid (mouseable)", "tags": ["mechanics", "hatch", "kinematics", "cardan"], "likes": 25, "viewed": 210, "date": "1617913569", "time_retrieved": "2024-06-20T20:39:08.182834", "image_code": "// \"Gear Projection\" by dr2 - 2021\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\nfloat PrBox2Df (vec2 p, vec2 b);\nfloat PrRoundBoxDf (vec3 p, vec3 b, float r);\nfloat PrCylDf (vec3 p, float r, float h);\nfloat Minv3 (vec3 p);\nfloat Maxv3 (vec3 p);\nfloat SmoothMax (float a, float b, float r);\nfloat SmoothBump (float lo, float hi, float w, float x);\nmat3 StdVuMat (float el, float az);\nvec2 Rot2D (vec2 q, float a);\nfloat Noisefv2 (vec2 p);\n\nvec3 ltDir, qHit;\nfloat tCur, dstFar, dMiss;\nint idObj;\nbool isSh;\nconst int idGearB = 1, idGearS = 2, idArm = 3, idLnk = 4, idPin = 5, idAxl = 6, idFrm = 7;\nconst float pi = 3.1415927;\n\n#define VAR_ZERO min (iFrame, 0)\n\n#define DMINQ(id) if (d < dMin) { dMin = d;  idObj = id;  qHit = q; }\n\nfloat GearWlDf (vec3 p, float rad, float nTh, float nSp, float aRot, float tWid, float wlThk)\n{\n  vec3 q;\n  vec2 cs;\n  float d, a, r, w;\n  p.xz = Rot2D (p.xz, aRot);\n  q = p;\n  r = length (q.xz);\n  a = atan (q.z, - q.x) / (2. * pi);\n  d = max (abs (r - 0.98 * rad + tWid) - 0.07 * rad, abs (q.y) - wlThk);\n  d = min (d, max (length (q.xz) - 0.2 * rad, abs (q.y) - 1.5 * wlThk));\n  cs = sin (2. * pi * floor (nSp * a + 0.5) / nSp + vec2 (0.5 * pi, 0.));\n  d = min (d, max (PrBox2Df (vec2 (q.y, dot (q.xz, cs.yx)),\n     vec2 (wlThk, 0.03 * rad)), r - rad + tWid));\n  q.xz = Rot2D (q.xz, 2. * pi * floor (nTh * a + 0.5) / nTh);\n  cs = sin (0.12 * pi + vec2 (0.5 * pi, 0.));\n  return abs (max (d, - max (dot (vec2 (q.x + rad, abs (q.z) - 1.3 * tWid), cs.yx),\n     abs (r - rad) - 1.8 * tWid))) - 0.01;\n}\n\nfloat ObjDf (vec3 p)\n{\n  vec3 q;\n  float dMin, d, nThB, nThS, radB, radS, tWid, wlThk, cRad, rRat, bLen, rAng;\n  dMin = dstFar;\n  rAng = 0.15 * tCur;\n  wlThk = 0.05;\n  cRad = 0.06;\n  nThB = 64.;\n  rRat = 0.5;\n  nThS = floor (nThB * rRat + 0.001);\n  rRat = nThS / nThB;\n  radB = 1.;\n  radS = radB * rRat;\n  q = p;\n  d = min (PrCylDf (vec3 (q - vec3 (0., 6. * wlThk, 0.)).xzy, 0.13 * radB, 4. * wlThk),\n     PrCylDf (vec3 (q - vec3 (0., 8. * wlThk, 0.)).xzy, 0.05 * radB, 10. * wlThk));\n  DMINQ (idAxl);\n  q.y -= 4. * wlThk;\n  if (! isSh) d = PrCylDf (q.xzy, radB + 0.05, wlThk + 0.05);\n  if (isSh || d < dMin + 0.1) {\n    q.xz = Rot2D (q.xz, 0.25 * pi);\n    tWid = 0.03;\n    d = GearWlDf (q, radB, nThB, 4., 0., tWid, wlThk);\n    DMINQ (idGearB);\n  } else dMin = min (dMin, d);\n  q = p;\n  q.xz = Rot2D (q.xz, - rAng / rRat);\n  bLen = 0.5 * radB + 1.5 * radS;\n  d = PrRoundBoxDf (q - vec3 (- bLen, 0., 0.), vec3 (bLen + 2. * wlThk, wlThk, 2. * wlThk), 0.01);\n  DMINQ (idArm);\n  d = PrCylDf ((q - vec3 (0.5, 16. * wlThk, 0.)).zyx, 0.04, 0.5);\n  DMINQ (idPin);\n  tWid = 0.04;\n  q.x -= - (radB + radS) + 0.2 * tWid;\n  d = PrCylDf (vec3 (q - vec3 (0., 2. * wlThk, 0.)).xzy, 0.1 * radS, 4. * wlThk);\n  DMINQ (idAxl);\n  q.y -= 4. * wlThk;\n  if (! isSh) d = PrCylDf (q.xzy, radS + 0.05, wlThk + 0.05);\n  if (isSh || d < dMin + 0.1) {\n    d = GearWlDf (q, radS, nThS, 8., - 2. * rAng / rRat + (pi / nThS), tWid, wlThk);\n    DMINQ (idGearS);\n  } else dMin = min (dMin, d);\n  q.x -= -2. * radS + tWid;\n  d = PrCylDf ((q - vec3 (0., -4. * wlThk, 0.)).xzy, 0.1 * radS, 6. * wlThk);\n  DMINQ (idAxl);\n  if (! isSh) d = PrCylDf (q.xzy, radS + 0.05, wlThk + 0.05);\n  if (isSh || d < dMin + 0.1) {\n    d = GearWlDf (q, radS, nThS, 8., 2. * rAng / rRat, tWid, wlThk);\n    DMINQ (idGearS);\n  } else dMin = min (dMin, d);\n  q.y -= -8.5 * wlThk;\n  q.xz = Rot2D (q.xz, 2. * rAng / rRat);\n  bLen = 0.5 * (radB + 3. * radS) - 0.7 * tWid;\n  q.x -= - bLen;\n  d = PrRoundBoxDf (q, vec3 (bLen + 1.5 * cRad, 0.75 * wlThk, 1.5 * cRad), 0.01);\n  DMINQ (idLnk);\n  q.xy -= vec2 (- bLen, -3. * wlThk);\n  d = PrCylDf (q.xzy, cRad, 4.5 * wlThk);\n  DMINQ (idPin);\n  q.y -= -4. * wlThk;\n  d = PrCylDf (q.xzy, 3. * cRad, wlThk);\n  DMINQ (idPin);\n  q = p;\n  d = SmoothMax (PrRoundBoxDf (q, vec3 (5.35 * radB, 9. * wlThk, 3. * cRad), 0.02),\n     - min (PrBox2Df (q.xy, vec2 (5.2 * radB, 7. * wlThk)),\n     max (PrBox2Df (q.xz, vec2 (5.1 * radB, 1.3 * cRad)), q.y)), 0.01);\n  DMINQ (idFrm);\n  dMiss = min (dMiss, dMin);\n  return dMin;\n}\n\nfloat ObjRay (vec3 ro, vec3 rd)\n{\n  float dHit, d;\n  dHit = 0.;\n  for (int j = VAR_ZERO; j < 120; j ++) {\n    d = ObjDf (ro + dHit * rd);\n    if (d < 0.0005 || dHit > dstFar) break;\n    dHit += d;\n  }\n  return dHit;\n}\n\nvec3 ObjNf (vec3 p)\n{\n  vec4 v;\n  vec2 e;\n  e = vec2 (0.001, -0.001);\n  for (int j = VAR_ZERO; j < 4; j ++) {\n    v[j] = ObjDf (p + ((j < 2) ? ((j == 0) ? e.xxx : e.xyy) : ((j == 2) ? e.yxy : e.yyx)));\n  }\n  v.x = - v.x;\n  return normalize (2. * v.yzw - dot (v, vec4 (1.)));\n}\n\nvec4 ObjNfL (vec3 p)\n{\n  vec4 v;\n  vec2 e;\n  float s;\n  e = vec2 (0.005, -0.005);\n  for (int j = VAR_ZERO; j < 4; j ++) {\n    v[j] = ObjDf (p + ((j < 2) ? ((j == 0) ? e.xxx : e.xyy) : ((j == 2) ? e.yxy : e.yyx)));\n  }\n  v.x = - v.x;\n  s = dot (v, vec4 (1.));\n  return vec4 (normalize (2. * v.yzw - s), (s - 2. * v.x - 4. * ObjDf (p)) / (e.x * e.x));\n}\n\nfloat ObjSShadow (vec3 ro, vec3 rd)\n{\n  float sh, d, h;\n  sh = 1.;\n  d = 0.02;\n  for (int j = VAR_ZERO; j < 30; j ++) {\n    h = ObjDf (ro + d * rd);\n    sh = min (sh, smoothstep (0., 0.03 * d, h));\n    d += h;\n    if (sh < 0.05) break;\n  }\n  return 0.5 + 0.5 * sh;\n}\n\nvec2 ExBlkHit (vec3 ro, vec3 rd)\n{\n  vec4 vn4;\n  vec3 v, tm, tp, u, fcBlk;\n  vec2 qBlk;\n  float dn, df, bs;\n  bs = dstFar;\n  if (rd.x == 0.) rd.x = 0.001;\n  v = ro / rd;\n  tp = bs / abs (rd) - v;\n  tm = - tp - 2. * v;\n  dn = Maxv3 (tm);\n  df = Minv3 (tp);\n  if (df > 0. && dn < df) {\n    fcBlk = - sign (rd) * step (tm.zxy, tm) * step (tm.yzx, tm);\n    u = (v + dn) * rd;\n    qBlk = vec2 (dot (u.zxy, fcBlk), dot (u.yzx, fcBlk)) / bs;\n  }\n  return qBlk;\n}\n\nvec4 BlkHit (vec3 ro, vec3 rd, vec3 bSize)\n{\n  vec3 v, tm, tp, fcBlk;\n  vec2 qBlk;\n  float dMin, dn, df;\n  dMin = dstFar;\n  if (rd.x == 0.) rd.x = 0.001;\n  v = ro / rd;\n  tp = bSize / abs (rd) - v;\n  tm = - tp - 2. * v;\n  dn = Maxv3 (tm);\n  df = Minv3 (tp);\n  if (df > 0. && dn < df) {\n    dMin = dn;\n    fcBlk = - sign (rd) * step (tm.zxy, tm) * step (tm.yzx, tm);\n  }\n  return vec4 (dMin, fcBlk);\n}\n\nvec3 SkShowScene (vec3 ro, vec3 rd, vec2 uv)\n{\n  vec4 col4, vn4;\n  vec3 col, vn, ltDirS;\n  float dstObj;\n  dMiss = dstFar;\n  isSh = false;\n  dstObj = ObjRay (ro, rd);\n  if (dstObj < dstFar) {\n    ro += dstObj * rd;\n    vn4 = ObjNfL (ro);\n    vn = vn4.xyz;\n    ltDirS = normalize (vec3 (0.5, 1.3, -1.));\n    col = vec3 (1.) * (1. - 0.5 * smoothstep (0.5, 1., abs (vn4.w) / 64.)) *\n       (0.85 + 0.15 * Noisefv2 (Rot2D (uv, -0.1 * pi) * vec2 (32., 512.))) *\n       (0.5 + 0.5 * max (dot (vn, ltDirS), 0.));\n    dMiss = dstFar;\n  } else col = vec3 (1.);\n  col = mix (col, vec3 (0.5), exp (- 64. * dMiss));\n  return clamp (col, 0., 1.);\n}\n\nvoid SkMain (out vec3 fCol, in vec2 fCoord)\n{\n  mat3 vuMat;\n  vec3 ro, rd;\n  vuMat = StdVuMat (-0.35 * pi, 0.);\n  ro = vuMat * vec3 (0., -5., -20.);\n  rd = vuMat * normalize (vec3 (fCoord, 4.2));\n  fCol = SkShowScene (ro, rd, fCoord);\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  vec4 col4, db4;\n  vec3 col, vn, bSize;\n  vec2 qBlk, q;\n  float dstObj, nDotL, sh;\n  bool isBg;\n  dMiss = dstFar;\n  isSh = false;\n  isBg = false;\n  dstObj = ObjRay (ro, rd);\n  bSize = vec3 (7.5, 0.1, 5.);\n  db4 = BlkHit (ro - vec3 (0., -1., -1.8), rd, bSize);\n  if (dstObj < min (db4.x, dstFar)) {\n    ro += dstObj * rd;\n    vn = ObjNf (ro);\n    qBlk = mod (8. * ExBlkHit (ro, reflect (rd, vn)), 1.);\n    if (idObj == idGearB) col4 = vec4 (0.9, 0.9, 0.8, 0.2);\n    else if (idObj == idGearS) col4 = vec4 (1., 1., 0.7, 0.2);\n    else if (idObj == idArm) col4 = vec4 (0.8, 1., 0.8, 0.2);\n    else if (idObj == idLnk) col4 = vec4 (1., 0.7, 0.9, 0.2);\n    else if (idObj == idPin) col4 = vec4 (0.7, 1., 0.7, 0.2);\n    else if (idObj == idFrm) col4 = vec4 (0.7, 0.4, 0.1, 0.1);\n    else if (idObj == idAxl) col4 = vec4 (1., 1., 0.5, 0.2);\n    nDotL = max (dot (vn, ltDir), 0.);\n    if (idObj != idFrm) nDotL *= nDotL;\n  } else if (db4.x < dstFar) {\n    ro += db4.x * rd;\n    vn = db4.yzw;\n    q = ro.xz - vec2 (0., -1.8);\n    if (vn.y > 0.5 && PrBox2Df (q, bSize.xz - 0.48) < 0.) {\n      SkMain (col, q / vec2 (5.3, 6.) - vec2 (0., -1.25));\n      if (Minv3 (col) > 0.9) {\n        q = smoothstep (0.03, 0.06, abs (mod (2. * q + 0.5, 1.) - 0.5));\n        col = mix (vec3 (0.7, 0.7, 1.), vec3 (1.), min (q.x, q.y));\n      }\n    } else {\n      col = vec3 (1.) * (0.8 + 0.2 * step (0.5, vn.y));\n      sh = 1.;\n    }\n  } else {\n    isBg = true;\n    qBlk = mod (8. * ExBlkHit (ro, rd), 1.);\n    col = vec3 (0.4, 0.5, 0.4) * (0.05 + 0.245 * (rd.y + 1.) * (rd.y + 1.)) +\n       vec3 (0.2) * (0.9 + 0.1 * SmoothBump (0.25, 0.75, 0.1, qBlk.x) *\n       SmoothBump (0.25, 0.75, 0.1, qBlk.y));\n  }\n  if (! isBg) {\n    isSh = true;\n    sh = ObjSShadow (ro + 0.01 * ltDir, ltDir);\n    if (dstObj < min (db4.x, dstFar)) {\n      col = col4.rgb * (0.2 + 0.8 * sh * nDotL) +\n         col4.a * step (0.95, sh) * pow (max (0., dot (ltDir, reflect (rd, vn))), 32.);\n      col += col4.a * vec3 (0.5) * (0.5 + 0.5 * SmoothBump (0.25, 0.75, 0.05, qBlk.x) *\n         SmoothBump (0.25, 0.75, 0.05, qBlk.y));\n    } else {\n      col *= 0.4 + 0.6 * sh * max (dot (vn, ltDir), 0.);\n    }\n  }\n  return clamp (col, 0., 1.);\n}\n\n#define AA  0   // optional antialiasing\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  mat3 vuMat;\n  vec4 mPtr;\n  vec3 ro, rd, col;\n  vec2 canvas, uv;\n  float el, az, zmFac, sr;\n  canvas = iResolution.xy;\n  uv = 2. * fragCoord.xy / canvas - 1.;\n  uv.x *= canvas.x / canvas.y;\n  tCur = iTime;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / canvas - 0.5;\n  az = 0.;\n  el = -0.28 * pi;\n  if (mPtr.z > 0.) {\n    az += 2. * pi * mPtr.x;\n    el += pi * mPtr.y;\n  }\n  vuMat = StdVuMat (el, az);\n  ro = vuMat * vec3 (0., -2.4, -20.);\n  zmFac = 4.2;\n  dstFar = 100.;\n  ltDir = vuMat * normalize (vec3 (1., 0.7, -1.));\n#if ! AA\n  const float naa = 1.;\n#else\n  const float naa = 3.;\n#endif  \n  col = vec3 (0.);\n  sr = 2. * mod (dot (mod (floor (0.5 * (uv + 1.) * canvas), 2.), vec2 (1.)), 2.) - 1.;\n  for (float a = float (VAR_ZERO); a < naa; a ++) {\n    rd = vuMat * normalize (vec3 (uv + step (1.5, naa) * Rot2D (vec2 (0.5 / canvas.y, 0.),\n       sr * (0.667 * a + 0.5) * pi), zmFac));\n    col += (1. / naa) * ShowScene (ro, rd);\n  }\n  fragColor = vec4 (col, 1.);\n}\n\nfloat PrBox2Df (vec2 p, vec2 b)\n{\n  vec2 d;\n  d = abs (p) - b;\n  return min (max (d.x, d.y), 0.) + length (max (d, 0.));\n}\n\nfloat PrRoundBoxDf (vec3 p, vec3 b, float r)\n{\n  return length (max (abs (p) - b, 0.)) - r;\n}\n\nfloat PrCylDf (vec3 p, float r, float h)\n{\n  return max (length (p.xy) - r, abs (p.z) - h);\n}\n\nfloat Minv3 (vec3 p)\n{\n  return min (p.x, min (p.y, p.z));\n}\n\nfloat Maxv3 (vec3 p)\n{\n  return max (p.x, max (p.y, p.z));\n}\n\nfloat SmoothMin (float a, float b, float r)\n{\n  float h;\n  h = clamp (0.5 + 0.5 * (b - a) / r, 0., 1.);\n  return mix (b, a, h) - r * h * (1. - h);\n}\n\nfloat SmoothMax (float a, float b, float r)\n{\n  return - SmoothMin (- a, - b, r);\n}\n\nfloat SmoothBump (float lo, float hi, float w, float x)\n{\n  return (1. - smoothstep (hi - w, hi + w, x)) * smoothstep (lo - w, lo + w, x);\n}\n\nmat3 StdVuMat (float el, float az)\n{\n  vec2 ori, ca, sa;\n  ori = vec2 (el, az);\n  ca = cos (ori);\n  sa = sin (ori);\n  return mat3 (ca.y, 0., - sa.y, 0., 1., 0., sa.y, 0., ca.y) *\n         mat3 (1., 0., 0., 0., ca.x, - sa.x, 0., sa.x, ca.x);\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  vec2 cs;\n  cs = sin (a + vec2 (0.5 * pi, 0.));\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nconst float cHashM = 43758.54;\n\nvec2 Hashv2v2 (vec2 p)\n{\n  vec2 cHashVA2 = vec2 (37., 39.);\n  return fract (sin (vec2 (dot (p, cHashVA2), dot (p + vec2 (1., 0.), cHashVA2))) * cHashM);\n}\n\nfloat Noisefv2 (vec2 p)\n{\n  vec2 t, ip, fp;\n  ip = floor (p);  \n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = mix (Hashv2v2 (ip), Hashv2v2 (ip + vec2 (0., 1.)), fp.y);\n  return mix (t.x, t.y, fp.x);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc-by-nc-sa-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/ssjGWy.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "ssjGzd", "name": "Noise & UV Mapping Shaoming", "author": "eurekazheng", "description": "Noice & UV Mapping", "tags": ["cis561"], "likes": 1, "viewed": 27, "date": "1617843572", "time_retrieved": "2024-06-20T20:39:09.768189", "image_code": "const int RAY_STEPS = 256;\nconst float FOVY = 0.25 * 3.14159;\n#define PI 3.14159\n\nstruct Intersection\n{\n    float t;\n    vec3 color;\n    vec3 p;\n    int object;\n};\n    \nfloat sphere(vec3 p, float r, vec3 c)\n{\n    return distance(p, c) - r;\n}\n\nvec3 rotateY(vec3 p, float a) {\n    return vec3(cos(a) * p.x + sin(a) * p.z, p.y, -sin(a) * p.x + cos(a) * p.z);\n}\n\nfloat plane( vec3 p, vec4 n )\n{\n  return dot(p,n.xyz) + n.w;\n}\n\nfloat box(vec3 p, vec3 b)\n{\n  return length(max(abs(p) - b, 0.0));\n}\n\nfloat sceneMap3D(vec3 pos)\n{\n    float t = plane(pos, vec4(0.0, 0.0, -1.0, 5.0));\n    t = min(t, plane(pos, vec4(1.0, 0.0, 0.0, 5.0)));\n    t = min(t, plane(pos, vec4(0.0, -1.0, 0.0, 7.5)));\n    t = min(t, plane(pos, vec4(-1.0, 0.0, 0.0, 5.0)));\n    t = min(t, plane(pos, vec4(0.0, 1.0, 0.0, 2.5)));   \n    t = min(t, sphere(rotateY(pos + vec3(-1, 1, 0.75), -25. * 3.14159 / 180.0), 2., vec3(1, 1, 1)));\n    t = min(t, box(rotateY(pos + vec3(2, 1, -0.75), 25. * 3.14159 / 180.0), vec3(1.4, 3.5, 1.4)));\n    return t;\n}\n\nvoid sceneMap3D(vec3 pos, out float t, out int obj)\n{\n    t = plane(pos, vec4(0.0, 0.0, -1.0, 5.0));\n    obj = 0;\n    \n    float t2;\n    if((t2 = plane(pos, vec4(1.0, 0.0, 0.0, 5.0))) < t)\n    {\n        t = t2;\n        obj = 1;\n    }\n    if((t2 = plane(pos, vec4(-1.0, 0.0, 0.0, 5.0))) < t)\n    {\n        t = t2;\n        obj = 2;\n    }\n    if((t2 = plane(pos, vec4(0.0, -1.0, 0.0, 7.5))) < t)\n    {\n        t = t2;\n        obj = 3;\n    }\n    if((t2 = plane(pos, vec4(0.0, 1.0, 0.0, 2.5))) < t)\n    {\n        t = t2;\n        obj = 4;\n    }\n    if((t2 = sphere(rotateY(pos + vec3(-1, 1, 0.75), -25. * 3.14159 / 180.0), 2., vec3(1, 1, 1))) < t)\n    {\n        t = t2;\n        obj = 5;\n    }\n    if((t2 = box(rotateY(pos + vec3(2, 1, -0.75), 25. * 3.14159 / 180.0), vec3(1.4, 3.5, 1.4))) < t)\n    {\n        t = t2;\n        obj = 6;\n    }\n}\n\nvec3 computeNormal(vec3 pos)\n{\n    vec3 epsilon = vec3(0.0, 0.001, 0.0);\n    return normalize( vec3( sceneMap3D(pos + epsilon.yxx) - sceneMap3D(pos - epsilon.yxx),\n                            sceneMap3D(pos + epsilon.xyx) - sceneMap3D(pos - epsilon.xyx),\n                            sceneMap3D(pos + epsilon.xxy) - sceneMap3D(pos - epsilon.xxy)));\n}\n\nvoid march(vec3 origin, vec3 dir, out float t, out int hitObj)\n{\n    t = 0.001;\n    for(int i = 0; i < RAY_STEPS; ++i)\n    {\n        vec3 pos = origin + t * dir;\n    \tfloat m;\n        sceneMap3D(pos, m, hitObj);\n        if(m < 0.01)\n        {\n            return;\n        }\n        t += m;\n    }\n    t = -1.0;\n    hitObj = -1;\n}\n\n\n\nvec3 random3( vec3 p ) {\n    return fract(sin(vec3(dot(p,vec3(127.1, 311.7, 191.999)),\n                          dot(p,vec3(269.5, 183.3, 765.54)),\n                          dot(p, vec3(420.69, 631.2,109.21))))\n                 *43758.5453);\n}\n\nvec2 random2( vec2 p ) {\n    return fract(sin(vec2(dot(p,vec2(127.1,311.7)),dot(p,vec2(269.5,183.3))))*43758.5453);\n}\n\nfloat random1( vec2 p ) {\n    return fract(sin(dot(p,vec2(127.1,311.7)))*43758.5453);\n}\n\nfloat WorleyNoise(vec2 uv) {\n    // Tile the space\n    uv *= 1.0;\n    vec2 uvInt = floor(uv);\n    vec2 uvFract = fract(uv);\n    float minDist = 1.0; // Minimum distance initialized to max.\n\n    // Search all neighboring cells and this cell for their point\n    for(int y = -1; y <= 1; y++) {\n        for(int x = -1; x <= 1; x++) {\n            vec2 neighbor = vec2(float(x), float(y));\n\n            // Random point inside current neighboring cell\n            vec2 point = random2(uvInt + neighbor);\n\n            // Animate the point\n\t\t\tpoint = cos(iTime + 2. * PI * point); // 0 to 1 range\n\n            // Compute the distance b/t the point and the fragment\n            // Store the min dist thus far\n            vec2 diff = neighbor + point - uvFract;\n            float dist = length(diff);\n            minDist = min(minDist, dist);\n        }\n    }\n    return minDist;\n}\n\n\n#define FBM_OCTAVES 4\n\nfloat mySmootherStep(float a, float b, float t) {\n    t = t*t*t*(t*(t*6.0 - 25.0) + 12.0);\n    return mix(a, b, t);\n}\n\nfloat bilerpNoise(vec2 uv) {\n    vec2 uvFract = fract(uv);\n    float ll = random1(floor(uv));\n    float lr = random1(floor(uv) + vec2(1,0));\n    float ul = random1(floor(uv) + vec2(0,1));\n    float ur = random1(floor(uv) + vec2(1,1));\n\n    float lerpXL = mySmootherStep(ll, lr, uvFract.x);\n    float lerpXU = mySmootherStep(ul, ur, uvFract.x);\n\n    return mySmootherStep(lerpXL, lerpXU, uvFract.y);\n}\n\nfloat fbm(vec2 uv) {\n    float amp = 0.4;\n    float freq = 7.0;\n    float sum = 0.0;\n    for(int i = 0; i < FBM_OCTAVES; i++) {\n        sum += bilerpNoise(uv * freq) * amp;\n        amp *= 0.4;\n        freq *= 2.5;\n    }\n    return sum;\n}\n\n\nfloat surflet3D(vec3 p, vec3 gridPoint)\n{\n    vec3 t3 = abs(p - gridPoint);\n    \n    float tX = 1.f - 6.f * pow(t3.x, 5.f) - 15.f * pow(t3.x, 4.f) + 10.f * pow(t3.x, 3.f);\n    float tY = 1.f - 6.f * pow(t3.y, 5.f) - 15.f * pow(t3.y, 4.f) + 10.f * pow(t3.y, 3.f);\n    float tZ = 1.f - 6.f * pow(t3.z, 5.f) - 15.f * pow(t3.z, 4.f) + 10.f * pow(t3.z, 3.f);\n    \n    vec3 t = vec3(tX, tY, tZ);\n    \n    vec3 gradient = random3(gridPoint);\n    vec3 diff = p - gridPoint;\n    float height = dot(diff, gradient);\n    return height * t.x * t.y * t.z;\n}\n\nfloat PerlinNoise3D(vec3 p)\n{\n    float surfletSum = 0.0;\n    vec3 pXLYLZL = floor(p);\n    \n    for(int dx = 0; dx <= 1; ++dx)\n    {\n        for(int dy = 0; dy <= 1; ++dy)\n        {\n            for(int dz = 0; dz <= 1; ++dz)\n            {\n                surfletSum += surflet3D(p, pXLYLZL + vec3(dx, dy, dz));\n            }\n        }\n    }\n    \n    return surfletSum;\n}\n\nconst vec3 a = vec3(0.3);\nconst vec3 b = vec3(0.7);\nconst vec3 c = vec3(1.);\nconst vec3 d = vec3(0.00, 0.6, 0.4);\n\nvec3 colorPalette(float t)\n{\n    return a + b * cos(2. * PI * (t * c + d));\n}\n\n\n\nvec2 planeUV(vec3 origin, vec3 n, vec3 p)\n{  \n    vec3 worldUp = vec3(0.0, 1.0, 0.0);\n    vec3 u = normalize(cross(worldUp, n));\n    vec3 v = normalize(cross(n, u));\n    vec3 diff = p - origin;\n    return vec2(dot(diff, u), dot(diff, v));\n}\n\nvec2 sphereUV(vec3 center, float r, vec3 p)\n{\n    vec3 dir = normalize(p - center);\n    vec3 worldUp = vec3(0.0, 1.0, 0.0);\n    float theta = acos(dot(dir, worldUp));\n    vec3 xz = normalize(vec3(dir.x, 0.0, dir.z));\n    float phi = acos(dot(xz, vec3(1.0, 0.0, 0.0)));\n    if(dir.z < 0.0) phi = phi + PI;\n    return vec2(theta / PI, phi / (2.0 * PI));\n}\n\n\nvec3 computeMaterial(int hitObj, vec3 p, vec3 n, vec3 lightVec)\n{\n    float lambertian = dot(-lightVec, n);\n    switch(hitObj){\n        case 0:\n            vec3 nor = vec3(0.0, 0.0, -1.0);\n            vec2 uvPlane = planeUV(nor * 5., nor, p);\n            return colorPalette(WorleyNoise(uvPlane)) * lambertian;\n            break;\n        case 1:\n            return vec3(0., 1., 0.) * lambertian;\n            break;\n        case 2:\n            return vec3(1., 0., 0.) * lambertian;\n            break;\n        case 3:\n            return vec3(1., 1., 1.) * lambertian;\n            break;\n        case 4:\n            return vec3(1., 1., 1.) * lambertian;\n            break;\n        case 5:\n            vec2 uvSphere = sphereUV(vec3(2., 0., 1.), 1.0, p);        \n            uvSphere.x = cos(iTime / 2. + uvSphere.x);\n            uvSphere.y = cos(iTime / 2. + uvSphere.y);        \n            return colorPalette(fbm(uvSphere)) * lambertian;        \n            break;\n        case 6:\n            vec3 noise = vec3(sin(iTime + p.x), sin(iTime + p.y), p.z + sin(iTime + p.z));\n            return colorPalette(PerlinNoise3D(noise)) * lambertian;\n            break;\n        case -1:\n            return vec3(0., 0., 0.);\n            break;\n    }\n    return vec3(1.);\n}\n\nIntersection sdf3D(vec3 dir, vec3 eye)\n{\n    float t;\n    int hitObj;\n    march(eye, dir, t, hitObj);\n\n    vec3 isect = eye + t * dir;\n    vec3 nor = computeNormal(isect);\n    \n    vec3 lightPos = vec3(0., 7.4, -3.5);\n    vec3 lightVec = normalize(isect - lightPos);\n    \n    vec3 surfaceColor = computeMaterial(hitObj, isect, nor, lightVec);    \n    return Intersection(t, surfaceColor, isect, hitObj);\n}\n\nvoid rayCast(vec2 uv, out vec3 dir, out vec3 eye, out vec3 ref)\n{\n    eye = vec3(0, 5, -20);\n    ref = vec3(0, 3, 0);\n    \n    float len = tan(3.14159 * 0.125) * distance(eye, ref);\n    vec3 H = normalize(cross(vec3(0.0, 1.0, 0.0), ref - eye));\n    vec3 V = normalize(cross(H, eye - ref));\n    V *= len;\n    H *= len * iResolution.x / iResolution.y;\n    vec3 p = ref + uv.x * H + uv.y * V;\n    dir = normalize(p - eye);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    uv = uv * 2.0 - vec2(1.0);\n    \n    vec3 eye;    \n    vec3 ref;\n    vec3 dir;\n    rayCast(uv, dir, eye, ref);\n    \n    Intersection isect = sdf3D(dir, eye);\n    fragColor = vec4(isect.color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/ssjGzd.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "ssjXRR", "name": "raindrops for bukweet", "author": "manthrax", "description": "raindrops", "tags": ["rain", "drops"], "likes": 2, "viewed": 78, "date": "1619572436", "time_retrieved": "2024-06-20T20:39:10.313666", "image_code": "void FmainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Time varying pixel color\n    vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}// Author:\n// Title:\n\n//#ifdef GL_ES\n//precision mediump float;\n//#endif\n\n//uniform vec2 u_resolution;\n//uniform vec2 u_mouse;\n//uniform float u_time;\n//uniform vec2 u_cursor;\n\nfloat s_time;\nvec2 st;\nfloat seed;\nfloat rippleCount = 10.;\nfloat pi = 2.*3.1415926;\nfloat aspect;\nfloat sdf_rect2(vec2 pos,float sz){\n    vec2 v = fract(st-pos+(sz*.5));\n    return 1.-step(sz,max(v.x,v.y));\n}\nvec2 rectuv(vec2 pos,float sz){\n    vec2 v = fract(clamp((st-pos+(sz*.5))/sz,0.,1.));\n    return v;\n}\nfloat rand(){\n    seed+=fract(sin(seed)*123.45);\n    return fract(sin(seed) * 1126.5973);\n}\nfloat ripple(int i){\n\n    float time = (s_time+(float(i)*2.234)/1.);\n    float age = fract(time); \n    time -= age;\n    seed = time;\n    vec2 pos = vec2(rand()*aspect,rand());\n    //float rad=rand()*.001;\n    vec2 ruv =  rectuv(pos,1.*age);\n    float dist = (1.-length((ruv-.5)*2.))*.99;\n    float power = rand();\n    float wav = min(step(.5,dist),((sin(dist*(rippleCount*floor(power+1.))*pi))*.5));\n    wav *= min(step(.5,dist),smoothstep(1.,.0,dist));\n    float fade = min(min(mix(age,.5,.9),smoothstep(age,1.0,.7)),mix(dist,0.1,0.228));\n    fade*=power;\n    return wav*fade;\n}\n\nfloat ripples(){\n    float col=0.;\n    for(int i=0;i<20;i++)\n        col += ripple(i);\n    return col;\n}\nstruct pointLight{\n     vec3 p;\n     vec3 c;\n     vec3 s;\n};\n\nvec3 calcPointLight(in pointLight light,in vec3 normal,in vec3 worldPos){\n    vec3 dir=worldPos-light.p;\n    float ndot = dot(normal,normalize(dir));\n    vec3 ocol = clamp(ndot,0.,1.)*light.c*(1.-clamp(length(dir),.0,1.));\n    ocol = mix(ocol,light.s,smoothstep(ndot,0.132,1.) );\n\treturn ocol;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\nvec2 u_resolution = iResolution.xy;\n\n    st = gl_FragCoord.xy/u_resolution.xy;\n    aspect = u_resolution.x/u_resolution.y;\n    st.x *= aspect;\n\ts_time = iTime*0.724;\n\n    vec3 color = vec3(0.);\n    float state=seed;\n    vec2 st0=st;\n    float r0=ripples();\n    vec2 stp=vec2(0.006,0.0);\n    st=st0+stp;\n    float r1=ripples();\n    st=st0+stp.yx;\n    float r2=ripples();\n    vec3 nml=vec3(r1-r0,r2-r0,0.);\n\tnml.z=1.-length(nml);\n    nml = normalize(nml);\n    \n    vec3 worldPos = vec3(st,0.);\n    vec3 spec = vec3(0.411,0.331,0.555);\n    color+=calcPointLight(pointLight(vec3(0.281,0.177,-0.175),vec3(0.445,0.504,0.900),spec),nml,worldPos);\n    color+=calcPointLight(pointLight(vec3(0.829,0.229,-0.196),vec3(0.176,0.905,0.108),spec),nml,worldPos);\n    color+=calcPointLight(pointLight(vec3(0.239,0.939,-0.105),vec3(1.000,0.748,0.777),spec),nml,worldPos);\n    seed=state;\n    fragColor = vec4(color,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/ssjXRR.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "sslSRn", "name": "Mandelbrot zoomed", "author": "kiwonka", "description": "A zoomed view of a mandelbrot set.", "tags": ["fractal", "mandelbrot"], "likes": 1, "viewed": 68, "date": "1618224631", "time_retrieved": "2024-06-20T20:39:10.313666", "image_code": "const int maxi = 1000;\n\nfloat mandelbrot(highp vec2 c) {\n    highp vec2 z = vec2(0.0, 0.0);\n    int i;\n    for (int j = 0; j <= maxi; j++) {\n        i = j;\n        if ((z.x*z.x+z.y*z.y) >= 4.0)\n            break;\n        z = vec2(z.x*z.x - z.y*z.y, 2.0*z.x*z.y) + c;\n    }\n    \n    if (i == maxi) return 0.0;\n\n    return float(i) / float(maxi);\n}\n\nvec3 f2rgb(float f) {\n    lowp float R = clamp(f * 3.0, 0.0, 1.0);\n    lowp float G = clamp((f * 3.0) - 1.0, 0.0, 1.0);\n    lowp float B = clamp((f * 3.0) - 2.0, 0.0, 1.0);\n    \n    return vec3(R, G, B);\n}\n\nvec3 hsv2rgb(float h, float s, float v) {\n    float c = v * s;\n    float m = v - c;\n    float hp = h / 60.0;\n    float x = c * (1.0 - abs(mod(hp, 2.0) - 1.0));\n    \n    if(hp < 0.0) {\n        return vec3(m, m, m);\n    } else if (hp < 1.0) {\n        return vec3(m + c, m + x, m);\n    } else if (hp < 2.0) {\n        return vec3(m + x, m + c, m);\n    } else if (hp < 3.0) {\n        return vec3(m, m + c, m + x);\n    } else if (hp < 4.0) {\n        return vec3(m, m + x, m + c);\n    } else if (hp < 5.0) {\n        return vec3(m + x, m, m + c);\n    } else if (hp < 6.0) {\n        return vec3(m + c, m, m + x);\n    } else {\n        return vec3(m, m, m);\n    }\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float f = min(iResolution.x, iResolution.y);\n\n    vec2 uv = (fragCoord/f);\n\n    uv -= vec2(0.85, 0.5);\n\n    uv *= .00735;\n\n    float w = 3.1415 / 180.0 * 80.0;\n\n    uv *= mat2(cos(w), -sin(w), sin(w), cos(w));\n    \n    uv -= vec2(0.748, -0.065);\n    \n    float h = mandelbrot(uv);\n\n    //vec3 col = f2rgb(mod(h + iTime, 1.0));\n\n    vec3 col = hsv2rgb(mod((h  * 360.0) + (iTime * 20.0), 360.0), 1.0, 1.0);\n    \n    if (h == 0.0)\n        col = vec3(0.0, 0.0, 0.0);\n\n    // Output to screen\n    fragColor = vec4(col, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/sslSRn.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "sslSRX", "name": "Cyclic", "author": "oneshade", "description": "Inspired by: [url=https://mathcurve.com/courbes2d/trochoid/trochoidacentre.shtml]https://mathcurve.com/courbes2d/trochoid/trochoidacentre.shtml[/url]", "tags": ["math", "animation", "curve", "parametric", "gif", "trochoid", "cyclic"], "likes": 14, "viewed": 106, "date": "1618982135", "time_retrieved": "2024-06-20T20:39:10.743963", "image_code": "// Utilities\n#define drawSDF(dist, col) color = mix(color, col, smoothstep(unit, 0.0, dist))\n\n// SDFs\nfloat sdLine(in vec2 p, in vec2 a, in vec2 b) {\n    vec2 pa = p - a, ba = b - a;\n    return length(pa - ba * clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0));\n}\n\nfloat sdDisc(in vec2 p, in vec2 o, in float r) {\n    return length(p - o) - r;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 center = 0.5 * iResolution.xy;\n    vec2 mouse = (iMouse.xy - center) / iResolution.y * 4.0;\n    vec2 uv = (fragCoord - center) / iResolution.y * 2.0;\n    float unit = 4.0 / iResolution.y;\n    vec3 color = vec3(1.0);\n\n    // Offset\n    uv.y += 0.15;\n    mouse.y += 0.15;\n\n    // Settings modified by mouse\n    float ra = 2.0, rb = -3.0, rc = 2.0;\n    if (iMouse.z > 0.0) {\n        ra = round(mouse.x);\n        rb = round(mouse.y);\n    }\n\n    // Positions\n    vec2 v1 = vec2(-0.5, -sqrt(1.0 / 12.0));\n    vec2 v2 = vec2(0.5, v1.y);\n    vec2 v3 = vec2(0.0, -2.0 * v1.y);\n\n    drawSDF(sdDisc(uv, v1, 0.03), vec3(1.0, 0.0, 0.0));\n    drawSDF(sdDisc(uv, v2, 0.03), vec3(1.0, 0.0, 0.0));\n    drawSDF(sdDisc(uv, v3, 0.03), vec3(1.0, 0.0, 0.0));\n\n    // Rings\n    drawSDF(abs(sdDisc(uv, v1, 0.5)), vec3(0.0, 0.0, 1.0));\n    drawSDF(abs(sdDisc(uv, v2, 0.5)), vec3(0.0, 0.0, 1.0));\n    drawSDF(abs(sdDisc(uv, v3, 0.5)), vec3(0.0, 0.0, 1.0));\n\n    // Brute force parametric plot\n    float tStep = 0.1;\n    vec2 prev; bool init;\n    for (float t=0.0; t < 6.28 + tStep; t += tStep) {\n        float t1 = t * ra, t2 = t * rb, t3 = t * rc;\n\n        vec2 rp1 = vec2(cos(t1), sin(t1)) * 0.5 + v1;\n        vec2 rp2 = vec2(cos(t2), sin(t2)) * 0.5 + v2;\n        vec2 rp3 = vec2(cos(t3), sin(t3)) * 0.5 + v3;\n\n        vec2 cur = (rp1 + rp2 + rp3) / 3.0;\n        if (init) drawSDF(sdLine(uv, prev, cur), vec3(0.5, 0.0, 0.0));\n        init = true;\n\n        prev = cur;\n    }\n\n    // Rotating triangle corners\n    float t1 = iTime * ra;\n    vec2 r1 = vec2(cos(t1), sin(t1)) * 0.5 + v1;\n\n    float t2 = iTime * rb;\n    vec2 r2 = vec2(cos(t2), sin(t2)) * 0.5 + v2;\n\n    float t3 = iTime * rc;\n    vec2 r3 = vec2(cos(t3), sin(t3)) * 0.5 + v3;\n\n    drawSDF(sdDisc(uv, r1, 0.03), vec3(0.0));\n    drawSDF(sdDisc(uv, r2, 0.03), vec3(0.0));\n    drawSDF(sdDisc(uv, r3, 0.03), vec3(0.0));\n\n    // Triangle anatomy\n    drawSDF(sdLine(uv, r1, r2), vec3(0.0));\n    drawSDF(sdLine(uv, r2, r3), vec3(0.0));\n    drawSDF(sdLine(uv, r3, r1), vec3(0.0));\n\n    vec2 c = (r1 + r2 + r3) / 3.0;\n    drawSDF(sdDisc(uv, c, 0.03), vec3(0.0));\n\n    drawSDF(sdLine(uv, r1, c), vec3(0.0));\n    drawSDF(sdLine(uv, r2, c), vec3(0.0));\n    drawSDF(sdLine(uv, r3, c), vec3(0.0));\n\n    // Vignette (kinda)\n    uv *= 0.5;\n    float dd = dot(uv, uv);\n    color -= 0.5 * dd * dd;\n\n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/sslSRX.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "sslSWN", "name": "Sunset at Sea", "author": "shophorn", "description": "The storm has finally faded, and all the monsters are gone too.", "tags": ["landscape"], "likes": 2, "viewed": 156, "date": "1618678736", "time_retrieved": "2024-06-20T20:39:11.174291", "image_code": "// Author: Leo Tamminen leo@leotamminen.fi\n// Title: Sunset at sea\n\n#ifdef GL_ES\nprecision mediump float;\n#endif\n\nvec3 skyBase            = vec3(0.160,0.706,0.920) * 0.544;\nvec3 waterBase          = vec3(0.162,0.875,0.526);\nvec3 sunDiscColor       = vec3(0.990,0.254,0.005) * 19.016;\nvec3 haloBaseColor      = vec3(1.0,0.236,0.025) * 4.824;\nvec3 haloTopColor       = vec3(0.995,0.857,0.118) * -0.392;\n\nvec2 discPosition       = vec2(0.790,0.150);\nfloat discSize          = 0.03;\nfloat discFeather       = 0.001;\nfloat discIntensity     = 10.;\n\nvec2 haloPosition       = vec2(0.760,0.600);\nfloat haloSize          = 0.536;\nfloat haloFeather       = 0.1;\nfloat haloIntensity     = 2.824;\n\nfloat skyline           = 0.236;\nfloat horizonWidth      = 0.026;\n\nvec2 effectResolution = vec2(20., 10.);\nfloat exposure  = 0.824;\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 st = fragCoord.xy/iResolution.xy;\n    st.x *= iResolution.x/iResolution.y;\n    \n\t\n    \n    float waterSkyFactor    = smoothstep(skyline - horizonWidth, skyline + horizonWidth, st.y);\n    vec3 overlayColor       = mix(waterBase, vec3(1), waterSkyFactor);\n    st.y                    = mix(1.0 - st.y / skyline, (st.y - skyline) / (1.0 - skyline), waterSkyFactor);\n                            \n    \n    float time              = iTime * 0.05;\n    float waveOffset        = pow(1. - st.y, 5.);\n    float waveScale         = 100.;\n    float wave              = sin((time + waveOffset) * waveScale) * st.y;\n\n    st.x                    += (1.0 - waterSkyFactor) * (wave * 0.05);\n\n        \n    /// Sky base colour is gradient up and down from skyline. Overlaycolor will darken the water (lower) part.\n    vec3 skyColor           = mix(skyBase, pow(skyBase, vec3(3.0)), st.y) * overlayColor;\n    vec3 horizonColor       = vec3(1.0 - abs(waterSkyFactor * 2.0 - 1.0)) * 0.5;\n    \n    /// SUN COLOR ----------------------------\n    float discDistance      = distance(discPosition, st);\n    float discGradient      = 1.0 - smoothstep(discSize - discFeather, discSize + discFeather, discDistance);\n\n    float shapeGradient     = 1.0 - smoothstep(haloSize - haloFeather, haloSize + haloFeather, distance(haloPosition, st));\n\n    float colorGradient     = smoothstep(0.0, 1.0, (st.y - haloPosition.y + haloSize) / (haloSize * 2.0));\n    vec3 haloColor          = mix(haloBaseColor, haloTopColor, colorGradient);\n\n    vec2 haloFalloffPoint   = haloPosition - normalize(haloPosition - discPosition) * haloSize;\n    float haloFalloff       = pow(1.0 - clamp(distance(st, haloFalloffPoint) / (haloSize * 2.0), 0.0, 1.0), 2.312);\n\n    vec3 sunColor           = sunDiscColor * discGradient * discIntensity\n                            + haloColor * shapeGradient * haloFalloff * haloIntensity;\n    /// --------------------------------------\n    \n    vec3 color  = vec3(0.0);\n    color       += skyColor;    \n    color       += sunColor;\n    color       += horizonColor;\n\n    color           = vec3(1.0) - exp(-color * exposure);\n\n    fragColor = vec4(color,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/sslSWN.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "sslSzf", "name": "Question about shadows!", "author": "julianlumia", "description": "When I run this shader on my macbook without a second monitor attached the shadows look good, but when I plug in a second display the whole shader gets darker more contrasted colors and a very vissible glitch appears in the shadows at some point. whatsup?", "tags": ["question"], "likes": 5, "viewed": 96, "date": "1619005462", "time_retrieved": "2024-06-20T20:39:11.180377", "image_code": "#define FAR 20.\n\n\nfloat smin(float a, float b, float k)\n{\n     float h = clamp (0.5+0.5*(b-a)/k,0.,1.);\n     return mix(b, a, h) - k*h*(1.0-h);\n        \n        \n}\nmat2 Rot (float a)\n{\n            \n    float s = sin(a);\n\tfloat c = cos(a);\n    return mat2(c,-s,s,c);\n            \n}\n\nvec3 doTwist(in vec3 p)\n{\n\tfloat f = sin(iTime)*1.;\n\tfloat c = cos(f*p.y);\n\tfloat s = sin(f*p.y);\n\tmat2  m = mat2(c,-s,s,c);\n\treturn vec3(p.y,m*p.xz);\n}\n\nvec3 doTwist2(in vec3 p)\n{\n\tfloat f = sin(iTime)*.5;\n\tfloat c = cos(f*p.y);\n\tfloat s = sin(f*p.y);\n\tmat2  m = mat2(c,-s,s,c);\n\treturn vec3(p.y,m*p.xz);\n}\n\nfloat sdSphere( vec3 p, float s )\n{\n  return length(p)-s;\n}\n\t\n\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\nfloat g1;\nfloat g2;\nfloat g3;\n\nfloat g4;\n\n\nfloat map (vec3 p)\n{\n  vec3 p2 = p;  \n  float gap = 1.;\np2.x = mod(p.x + gap,2.0 * gap) - gap;\n  \n   vec3 q = fract(p ) * 2. - 1.;\n   vec3 q2 = p;\n   q2.xz= fract(p.xz ) * 2. - 1.;\n\n   vec3 s = vec3(1.,.05,1.);\n   \n   float bd3= length (max (abs((q2))-s,0.)); \n    \n    vec3 boxQ = q;\n    boxQ += vec3(0.,0.5,0.);\n    vec3 s6 = vec3(0.1,2.,.1); \n    \n    float bd6= length (max (abs((q2-vec3(.0,.0,-.0)))-s6,0.)); \n    \n  \n    vec3 torusQ = q;\n    torusQ -= vec3(0.0,0.95,0);\n    float torus = sdTorus(torusQ,vec2(.90,0.5));\n    \n    \n    vec3 torusQ2 = q;\n    torusQ2 += vec3(0.0,0.95,0);\n    float torus2 = sdTorus(torusQ2,vec2(.90,0.5));\n\n    vec3 s2 = vec3(.05,.01,1.);\n    vec3 i = q;\n    i +=.0;\n     float bd4= length (max (abs(doTwist2(i))-s2,0.)); \n        float sp = sdSphere(q-vec3(0.,0.,0.),.6);\n \n    //circle\n   float sd5;\n   float x = sin(iTime);\n   abs (x);\n   sd5 = length(q) -.5;\n \n   float smbd = min(bd3,sp);\n\n   g1 +=(sin(iTime))+p.z*.2/(.1+pow(abs(sp),10.));\n   g2 +=1./(0.2+pow(abs(bd3),5.));\n\n\n    return smbd;\n     \n}\n\n\n\n float GetDist (vec3 p) \n    {\n      \n     \tfloat d;\n        \n        return  d ;\n    }\n    \n\n\nfloat trace(vec3 o, vec3 r)\n{\n float t = 0.0,d;\n    for(int i=0; i< 128; i++){\n    vec3 p = o + r * t;\n   \n        float d = map(p);\n   \n     \n        if(abs(d)<.00001 || t>FAR) break;        \n        \n        t += d*.6; \n    }\n    return t;\n}\n\n//second trace for reflections\nfloat traceRef(vec3 ro, vec3 rd){\n    \n    float t = 0., d;\n    \n    for (int i = 0; i < 100; i++){\n\n        d = map(ro + rd*t);\n        \n        if(abs(d)<.0001 || t>FAR) break;\n        \n        t += d*.9; \n    }\n    \n    return t;\n}\n\n//3rd trace for reflections\nfloat traceRef2(vec3 ro, vec3 rd){\n    \n    float t = 0., d;\n    \n    for (int i = 0; i < 60; i++){\n\n        d = map(ro + rd*t);\n        \n        if(abs(d)<.0005 || t>FAR) break;\n        \n              t += d*1.; \n\n    }\n    \n    return t;\n}\n\nfloat traceRef3(vec3 ro, vec3 rd){\n    \n    float t = 0., d;\n    \n    for (int i = 0; i < 5; i++){\n\n        d = map(ro + rd*t);\n        \n        if(abs(d)<.00001 || t>FAR) break;\n        \n        t += d;\n    }\n    \n    return t;\n}\n\nfloat traceRef4(vec3 ro, vec3 rd){\n    \n    float t = 0., d;\n    \n    for (int i = 0; i < 3; i++){\n\n        d = map(ro + rd*t);\n        \n        if(abs(d)<.00001 || t>FAR) break;\n        \n        t += d;\n    }\n    \n    return t;\n}\n\n\n\nfloat softShadow(vec3 ro, vec3 lp, float k){\n\n    const int maxIterationsShad = 50; \n    \n    vec3 rd = (lp-ro);\n\n    float shade = .5;\n    float dist = .050;    \n    float end = max(length(rd), .001);\n    float stepDist = end/float(maxIterationsShad);\n    \n    rd /= end;\n\n    for (int i=0; i<maxIterationsShad; i++){\n\n        float h = map(ro + rd*dist);\n    \n        shade = min(shade, smoothstep(0., 1., k*h/dist)); \n\n        dist += clamp(h, .5, .0);\n        \n        if (h<0. || dist > end) break; \n    }\n\n    return min(max(shade, 0.) + .1, 1.); \n}\n\n\n\nvec3 getObjectColor(vec3 p){\n    \n    vec3 col = vec3(1);\n   \n    if(fract(dot(floor(p), vec3(.4))) > .1) col = vec3(.5, .1, 0.);\n    if(fract(dot(floor(p), vec3(.4))) > .6) col = vec3(.5, .0, 0.5);\n    if(fract(dot(floor(p), vec3(.3))) > .8) col = vec3(0., .2, 1.);\n    return col;\n    \n}\n\n\nvec3 doColor(in vec3 sp, in vec3 rd, in vec3 sn, in vec3 lp, float t){\n    \n    vec3 ld = lp-sp;\n    float lDist = max(length(ld), .001);\n    ld /= lDist;\n    \n    float atten = 1. / (1. + lDist*.5 + lDist*lDist*.1);\n   \n    float diff = max(dot(sn, ld), 0.5);\n \n    float spec = pow(max( dot( reflect(-ld, sn), -rd ), 0.), 6.);\n\n    vec3 objCol = getObjectColor(sp);\n\n    vec3 sceneCol = (objCol*(diff + .15) + vec3(1., 1., 1.)*spec*1.) * atten;\n    \n    \n    float fogF = smoothstep(0., .3, t/FAR);\n \n    sceneCol = mix(sceneCol, vec3(0), fogF); \n\n\n    return sceneCol;\n    \n}\n\n\n\n\nvec3 getNormal( in vec3 p ){\n\n  \n    vec2 e = vec2(.00035, -.00035); \n    return normalize(\n        e.xyy * map(p + e.xyy) + \n        e.yyx * map(p + e.yyx) + \n        e.yxy * map(p + e.yxy) + \n        e.xxx * map(p + e.xxx));\n}\n\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  \n    vec2 uv = fragCoord/iResolution.xy;\n\t\t\n    uv = uv * 2.0 - 1.0;\n\t\n    uv.x *= iResolution.x / iResolution.y;\n    \n    vec3 r = normalize(vec3(uv,2.));\n \n    float the = iTime *0.25;\n    r.xz *= Rot(-the);\n    vec3 o = vec3(.2,.5,1.);\n    o.xz *= Rot(the);\n    float t = trace(o,r);\n    \n    vec3 lp = o + vec3(0., 1., 0.5);\n    \n    o += r*t;\n    \n    vec3 sn = getNormal(o);\n\n   vec3 col = vec3(0);\n\n\n     col = abs(vec3(-0.2,.8*uv.y,1.)+.1);\n    \n    float t5 = t;\n    \n    \n    vec3 sceneColor = doColor(o, r, sn, lp, t );\n    \n    sceneColor = mix(col, sceneColor,.5)  ;\n    \n    \n    float sh;\n    \n//reflections:\n//--- pass 1\nr = reflect(r, sn);\n  \n    t = traceRef(o +  r*.01, r);\n     \n    o += r*t;\n    \n    sn = getNormal(o);\n    \n    sceneColor += doColor(o, r, sn, lp, t)*3.5;\n//--- pass 2\n    r = reflect(r, sn);\n    sh += softShadow(o, lp,2.)*.5;\n   \n   t = traceRef2(o +  r*.01, r);\n    o += r*t;\n\n    sn = getNormal(o);\n    \n    \n   sceneColor += doColor(o, r, sn, lp, t)*2.;\n    \n        sceneColor = mix(col, sceneColor,.9)  ;\n\n//---  pass 3\n      r = reflect(r, sn);\n     sh += softShadow(o, lp,3.)*.2;\n\n    t = traceRef3(o +  r*0.01, r);\n    o += r*t;\n    \n    sn = getNormal(o);\n    \n    \n   sceneColor += doColor(o, r, sn, lp, t)*1.0;\n    \n    \n    sceneColor = mix(col, sceneColor,.9)  ;\n\n\n\n//--- pass 4\n \n    r = reflect(r, sn);\n    t = traceRef4(o +  r*.8, r);\n    o += r*t;\n    \n    \n    \n sceneColor += doColor(o, r, sn, lp, t)*.3;\n //---\n \n \nsceneColor +=g2*vec3(0.00015)*vec3(0.,3.,0.);   \n\n\n    \n    \n    sceneColor *= sh;\n    \n    \n    float fog = 1. / (2. + t * t * .1);\n    \n    vec3 fc = vec3(fog);\n    \n    sceneColor *= fc;\n    sceneColor*=1.5;\n    \n    fragColor = vec4(sqrt(clamp(sceneColor, 0.,1.)), t5);\n    \n    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/sslSzf.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "sslXzN", "name": "Fractal 57_gaz", "author": "gaz", "description": "fractal", "tags": ["fractal"], "likes": 8, "viewed": 207, "date": "1618358555", "time_retrieved": "2024-06-20T20:39:11.180377", "image_code": "#define PI (atan(1.)*4.)\n#define R(p,a,r)mix(a*dot(p,a),p,cos(r))+sin(r)*cross(p,a)\n#define H(h)(cos((h)*6.3+vec3(0,23,21))*.5+.5)\n#define M(p,n)vec2(asin(sin(atan(p.x,p.y)*n))/n,1)*length(p)\nvoid mainImage(out vec4 O, vec2 C)\n{\n    O=vec4(0);\n    vec3 p,q,r=iResolution,\n    d=normalize(vec3((C-.5*r.xy)/r.y,1));  \n    for(float i=0.,s,e,g=0.;\n        ++i<90.;\n        O.xyz+=mix(vec3(1),H(log(s)*.3),.8)*.02*exp(-.2*i*i*e)\n    )\n    {\n        p=g*d;\n        q=p=R(p,normalize(vec3(1,1,2)),.5*sin(iTime*.1));\n        p+=vec3(.3,.5,iTime*.3);\n        p=sin(2.7*p+5.*sin(p*.3));\n        s=3.;\n        for(int i;i++<6;)\n            p=abs(p-1.7)-1.6,\n            s*=e=2.3/clamp(dot(p,p),.1,1.2),\n            p=abs(p)*e;\n        g+=e=length(p.zy)/s;\n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/sslXzN.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "ssS3R3", "name": "Space deformation: norm, dotprod", "author": "theott", "description": "The space can be switched between Euclidian and Lorenzian with parameter l. The p-norm can also be changed using the parameter p. ", "tags": ["space", "norm", "lorenzian"], "likes": 2, "viewed": 27, "date": "1617728996", "time_retrieved": "2024-06-20T20:39:11.441014", "image_code": "const bool auto = true; // false to change paramters with mouse: l in y, p in x. \nconst bool circles = true; // true to show circles concentric to the origin.\n\nfloat norm(vec2 v, float p, float l){\n    return pow(abs(pow(abs(v.x),p) + l * pow(abs(v.y),p)) ,1./p);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from -1 to 1)\n    vec2 uv = ( 2.* fragCoord - iResolution.xy ) / iResolution.y;\n\n    // Background\n    vec3 col = vec3(0);\n\n    // Normalize mouse coordinates (from 0 to 1)\n    vec2 mouse = iMouse.xy / iResolution.xy;  \n\n    // p-Norm parameter\n    float p = sin(iTime)+2.1;\n    if (!auto) p = mouse.x*3.;\n    // Scalar product parameter (1: Euclidian, -1: Lorenzian)\n    float l = cos(iTime / 2.);\n    if (!auto) l =  mouse.y * 2. - 1.;\n    \n    // Distance from pixel to origin\n    float d = norm(uv, p, l);\n    \n    // Concentric circles\n    float radius = .5;\n    if (circles){\n    for (int i=0; i<10; i++){\n        col += 1.-step(.01, abs(d - float(i)*radius));\n    }}\n    \n    // Texture\n    vec2 tco = uv/length(uv) * d; //preserves angles (conformal)\n    col += texture(iChannel0, tco).rgb;\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": "XdX3Rn", "previewfilepath": "/media/ap/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/ssS3R3.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "ssS3WD", "name": "tiling simplex noise", "author": "bandaloo", "description": "i was looking into creating a perlin or simplex noise that tiled, and i found this clever solution here: https://gamedev.stackexchange.com/questions/23625/how-do-you-generate-tileable-perlin-noise/23639#23639", "tags": ["noise", "perlin", "simplex", "4d", "tiling"], "likes": 1, "viewed": 45, "date": "1617402214", "time_retrieved": "2024-06-20T20:39:11.441014", "image_code": "#define PI2 6.28318530718\n#define TILES_AT_ONCE 3\n#define DEBUG\n\n// noise algorithm taken from here:\n// https://gist.github.com/patriciogonzalezvivo/670c22f3966e662d2f83\n\n//\tSimplex 4D Noise \n//\tby Ian McEwan, Ashima Arts\nvec4 permute(vec4 x){return mod(((x*34.0)+1.0)*x, 289.0);}\nfloat permute(float x){return floor(mod(((x*34.0)+1.0)*x, 289.0));}\nvec4 taylorInvSqrt(vec4 r){return 1.79284291400159 - 0.85373472095314 * r;}\nfloat taylorInvSqrt(float r){return 1.79284291400159 - 0.85373472095314 * r;}\n\nvec4 grad4(float j, vec4 ip){\n    const vec4 ones = vec4(1.0, 1.0, 1.0, -1.0);\n    vec4 p,s;\n\n    p.xyz = floor( fract (vec3(j) * ip.xyz) * 7.0) * ip.z - 1.0;\n    p.w = 1.5 - dot(abs(p.xyz), ones.xyz);\n    s = vec4(lessThan(p, vec4(0.0)));\n    p.xyz = p.xyz + (s.xyz*2.0 - 1.0) * s.www; \n\n    return p;\n}\n\nfloat snoise(vec4 v){\n    const vec2  C = vec2( 0.138196601125010504,  0.309016994374947451 );\n    vec4 i  = floor(v + dot(v, C.yyyy) );\n    vec4 x0 = v -   i + dot(i, C.xxxx);\n\n    vec4 i0;\n\n    vec3 isX = step( x0.yzw, x0.xxx );\n    vec3 isYZ = step( x0.zww, x0.yyz );\n\n    i0.x = isX.x + isX.y + isX.z;\n    i0.yzw = 1.0 - isX;\n\n    i0.y += isYZ.x + isYZ.y;\n    i0.zw += 1.0 - isYZ.xy;\n\n    i0.z += isYZ.z;\n    i0.w += 1.0 - isYZ.z;\n\n    vec4 i3 = clamp( i0, 0.0, 1.0 );\n    vec4 i2 = clamp( i0-1.0, 0.0, 1.0 );\n    vec4 i1 = clamp( i0-2.0, 0.0, 1.0 );\n\n    vec4 x1 = x0 - i1 + 1.0 * C.xxxx;\n    vec4 x2 = x0 - i2 + 2.0 * C.xxxx;\n    vec4 x3 = x0 - i3 + 3.0 * C.xxxx;\n    vec4 x4 = x0 - 1.0 + 4.0 * C.xxxx;\n\n    i = mod(i, 289.0); \n    float j0 = permute( permute( permute( permute(i.w) + i.z) + i.y) + i.x);\n    vec4 j1 = permute( permute( permute( permute (\n             i.w + vec4(i1.w, i2.w, i3.w, 1.0 ))\n           + i.z + vec4(i1.z, i2.z, i3.z, 1.0 ))\n           + i.y + vec4(i1.y, i2.y, i3.y, 1.0 ))\n           + i.x + vec4(i1.x, i2.x, i3.x, 1.0 ));\n\n    vec4 ip = vec4(1.0/294.0, 1.0/49.0, 1.0/7.0, 0.0) ;\n\n    vec4 p0 = grad4(j0,   ip);\n    vec4 p1 = grad4(j1.x, ip);\n    vec4 p2 = grad4(j1.y, ip);\n    vec4 p3 = grad4(j1.z, ip);\n    vec4 p4 = grad4(j1.w, ip);\n\n    vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));\n    p0 *= norm.x;\n    p1 *= norm.y;\n    p2 *= norm.z;\n    p3 *= norm.w;\n    p4 *= taylorInvSqrt(dot(p4,p4));\n\n    vec3 m0 = max(0.6 - vec3(dot(x0,x0), dot(x1,x1), dot(x2,x2)), 0.0);\n    vec2 m1 = max(0.6 - vec2(dot(x3,x3), dot(x4,x4)            ), 0.0);\n    m0 = m0 * m0;\n    m1 = m1 * m1;\n    return 49.0 * ( dot(m0*m0, vec3( dot( p0, x0 ), dot( p1, x1 ), dot( p2, x2 )))\n                  + dot(m1*m1, vec2( dot( p3, x3 ), dot( p4, x4 ) ) ) ) ;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = mod((fragCoord * float(TILES_AT_ONCE) / iResolution.xy) + iTime / 9., 1.);\n    \n    // two orthogonal circles in 4d space\n    float nx = cos(PI2 * uv.x);\n    float ny = cos(PI2 * uv.y);\n    float nz = sin(PI2 * uv.x);\n    float nw = sin(PI2 * uv.y);\n\n    #ifdef DEBUG\n    fragColor = uv.x < 0.01 || uv.y < 0.01 ? vec4(0., 1., 0., 1.) : vec4(vec3(snoise(vec4(nx, ny, nz, nw))), 1.0);\n    #else\n    fragColor = vec4(vec3(snoise(vec4(nx, ny, nz, nw))), 1.0);\n    #endif\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/ssS3WD.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "ssS3WK", "name": "CircleSDF", "author": "tomoe", "description": "The circle function is SDF if and only if the exponential is 0.5.", "tags": ["bd202104"], "likes": 1, "viewed": 60, "date": "1617951749", "time_retrieved": "2024-06-20T20:39:11.441014", "image_code": "const float PI = 3.14159265359;\nfloat circle(vec2 p, vec2 c, float r){\n    return pow(dot(p - c, p - c), 1.0 + 0.5 * sin(iTime)) - r;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    vec2 pos = (2.0 * fragCoord.xy -iResolution.xy)/ iResolution.yy;\n    float w = circle(pos, vec2(0.0), 1.);\n    vec3 v = vec3(step(mod(w, 0.3), 0.01));  \n    v += mix(vec3(0, 0, 1), vec3(1, 0, 0), atan(w)/PI + 0.5);\n    v *= 1.0-step(abs(w),0.01);\n    fragColor = vec4(v, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/ssS3WK.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "ssSGDz", "name": "Box intersection with camrea", "author": "Bushra", "description": "Box intersection with camrea", "tags": ["boxintersectionwithcamrea"], "likes": 0, "viewed": 36, "date": "1617232925", "time_retrieved": "2024-06-20T20:39:11.441014", "image_code": "\n// http://iquilezles.org/www/articles/boxfunctions/boxfunctions.htm\nvec4 iBox( in vec3 ro, in vec3 rd, in mat4 txx, in mat4 txi, in vec3 rad ) \n{\n    // convert from ray to box space\n\tvec3 rdd = (txx*vec4(rd,0.0)).xyz;\n\tvec3 roo = (txx*vec4(ro,1.0)).xyz;\n\n\t// ray-box intersection in box space\n    vec3 m = 1.0/rdd;\n    vec3 n = m*roo;\n    vec3 k = abs(m)*rad;\n\t\n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n\n\tfloat tN = max( max( t1.x, t1.y ), t1.z );\n\tfloat tF = min( min( t2.x, t2.y ), t2.z );\n\t\n\tif( tN > tF || tF < 0.0) return vec4(-1.0);\n\n\tvec3 nor = -sign(rdd)*step(t1.yzx,t1.xyz)*step(t1.zxy,t1.xyz);\n\n    // convert to ray space\n\t\n\tnor = (txi * vec4(nor,0.0)).xyz;\n\n\treturn vec4( tN, nor );\n}\n\nmat4 rotationAxisAngle( vec3 v, float angle )\n{\n    float s = sin( angle );\n    float c = cos( angle );\n    float ic = 1.0 - c;\n\n    return mat4( v.x*v.x*ic + c,     v.y*v.x*ic - s*v.z, v.z*v.x*ic + s*v.y, 0.0,\n                 v.x*v.y*ic + s*v.z, v.y*v.y*ic + c,     v.z*v.y*ic - s*v.x, 0.0,\n                 v.x*v.z*ic - s*v.y, v.y*v.z*ic + s*v.x, v.z*v.z*ic + c,     0.0,\n\t\t\t     0.0,                0.0,                0.0,                1.0 );\n}\n\nmat4 translate( float x, float y, float z )\n{\n    return mat4( 1.0, 0.0, 0.0, 0.0,\n\t\t\t\t 0.0, 1.0, 0.0, 0.0,\n\t\t\t\t 0.0, 0.0, 1.0, 0.0,\n\t\t\t\t x,   y,   z,   1.0 );\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    uv -= 0.5;                            //set the origin middle of the screen\n    uv.x *= iResolution.x/iResolution.y;  //calculate aspect ratio\n    \n    //camera \n    vec3 ro = vec3(1.0, 1.50, -4.0);  //camera position or ray origin \n    \n    vec3 LookAt = vec3(0.5);          //Look at position\n    float zoom = 1.0;    \n    \n    //vec3 rd = vec3 rd(uv, ro, LookAt, zoom);  //calling ray direction function\n    vec3 forward = normalize(LookAt - ro);              //calculate forward, normalize return unit vector \n    vec3 right = cross (vec3(0.0, 1.0, 0.0), forward);  //y is (0.0, 1.0, 0.0,); right = y cross forward\n    vec3 up = cross (forward, right);\n    \n    vec3 c = ro + forward * zoom;          //center of the screen  \n    vec3 i = c + uv.x*right + uv.y*up;     //i is the insect point on the screen\n    \n    vec3 rd = i - ro;       //ray direction\n    \n    // rotate and translate box_proxy\t\n    float angle = 0.0;\n\tmat4 rot_proxy = rotationAxisAngle( normalize(vec3(0.0,1.0,0.0)), angle );\n\tmat4 tra_proxy = translate( 0.0, 0.0 , 0.0 );\n\tmat4 txi_proxy = tra_proxy * rot_proxy; \n\tmat4 txx_proxy = inverse( txi_proxy );\n    \n    // rotate and translate box_clip\t\n    //float angle = 0.5 * iTime;    \n    float trans = 0.5 * iTime; \n\tmat4 rot_clip = rotationAxisAngle( normalize(vec3(1.0,.0,0.0)), angle );\n\tmat4 tra_clip = translate( 0.0, 1.0 * sin(trans) , 0.0 );\n\tmat4 txi_clip = tra_clip * rot_clip; \n\tmat4 txx_clip = inverse( txi_clip );\n    \n    // raytrace\n\tfloat tmin = 10000.0;\n\n    // raytrace box\n    vec3 box_proxy = vec3(0.7,0.4,0.4) ;\n    vec3 box_clip = vec3(0.5,0.4,0.4) ;\n    \n    vec4 res_proxy = iBox( ro, rd, txx_proxy, txi_proxy, box_proxy);\n    vec4 res_clip = iBox( ro, rd, txx_clip, txi_clip, box_clip);    \n       \n    vec3 col;\n    //when clip and proxy intersect\n    if(res_proxy.x>0.0 && res_proxy.x< tmin && res_clip.x>0.0 && res_clip.x< tmin)\n    {   \n         col = vec3(1., 1., 0.); //clip and proxy\n    }\n    \n    \n     //uncomment from here to see proxy cube and clip cube both together\n     /*\n      //proxy color red\n    else if (res_proxy.x>0.0 && res_proxy.x< tmin)\n    {\n         col = vec3(1., 0., 0.); //proxy\n    }\n\n    //clip color green\n    else if (res_clip.x>0.0 && res_clip.x< tmin)\n    {\n        col = vec3(0., 1., 0.); //clip\n    }\n    */\n    \n    else{\n         col = vec3(0.0, 0.3, 0.3); //background color\n    } \n      \n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/ssSGDz.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "ssSGzc", "name": "CubeMunch", "author": "cacheflowe", "description": "Playing with formulas from: \n@gaeel - https://www.shadertoy.com/view/ssjGWW\n\nBased on equations in @aemkei's tweet:\nhttps://twitter.com/aemkei/status/1378106731386040322", "tags": ["modulo", "munchingcubes"], "likes": 8, "viewed": 86, "date": "1617739164", "time_retrieved": "2024-06-20T20:39:11.671359", "image_code": "// Shader version of @aemkei's \"alien art\"\n// Original: https://twitter.com/aemkei/status/1378106731386040322\n// Modified by @gaeel - https://www.shadertoy.com/view/ssjGWW\n// Modified again by @cacheflowe :)\n// Press the ⏮ button under the preview window to restart from the beginning\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    // normalized p for quadrants\n    // & uv for equations\n    vec2 p = fragCoord.xy / iResolution.xy;\n    float zoom = 2.;\n    vec2 uv = fragCoord/zoom;\n    \n    // Get \"pixel\" coordinates for equations\n    int x = int(uv.x);\n    int y = int(uv.y);\n    \n    // Try some different equations from original tweet\n    int b = x|y;                                                              // sierpinski:  (x|y) % time\n    if(p.x > 0.5) b = x^y;                                                    // diagonals:   (x^y) % time\n    if(p.y > 0.5 && p.x > 0.5) b = int(mod(mod(uv.x,uv.y), uv.y));            // sheets:      ((x%y) % y) % time\n    if(p.y > 0.5 && p.x < 0.5) b = int(mod((uv.x * uv.y), 1024.));            // round noise: ((x*y) % 1024) % time\n    \n    // final output\n    float bf = float(b);                               // convert to float\n    bf = mod(bf, (1000. + iTime) * 0.005);             // start time at a larger number\n    vec3 col = 1. - vec3(bf);                          // invert\n    if(iMouse.z > 0.5) {                               // hold mouse to threshold results\n        float density = 0.85;\n        col = (bf < density) ? vec3(1.) : vec3(0.);\n        fragColor = vec4(col,1.0);\n    } else {                                           // color cycle for fun\n        col = vec3(0.5 + 0.5 * sin(col.r * 3.), 0.5 + 0.5 * sin(col.g * 4.), 0.5 + 0.5 * sin(col.b * 5.));\n        fragColor = vec4(col * (1. - bf/2.),1.0);\n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/ssSGzc.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "sssSDN", "name": "Kn8ves", "author": "SnoopethDuckDuck", "description": "e", "tags": ["cool"], "likes": 4, "viewed": 48, "date": "1618682740", "time_retrieved": "2024-06-20T20:39:11.677369", "image_code": "float random (vec2 st) {\n    return fract(sin(dot(st.xy,\n                         vec2(12.9898,78.233)))*\n        43758.5453123);\n}\n\nfloat taxi(vec2 uv)\n{\nreturn abs(uv.x) + abs(uv.y);\n}\n\nconst float pi = 3.14159;\nconst float pi2 = 1. * pi / 90.;\nconst float pi3 = -1. * pi / 90.;\n\nfloat func(vec2 dir, float t)\n{\nfloat theta = atan(dir.y,dir.x);\n\nfloat b = 0.5 * (1. + cos(t));\nfloat d = sqrt(pow(b * taxi(dir),2.))+\nsqrt(pow((1.-b) *taxi(dir + 0.3 * cos(1. * theta) * vec2(cos(t),sin( -t))),2.));\nd *= 1.65 + 0.1 * cos(0.2 * t);\n\nfloat d2 = 1. - length(dir + 0.3 * sin(1. * theta) * vec2(cos(-t),sin(t)));\nd = sqrt(-0.5 + d * d + d2 * d2);\nreturn step(d ,0.3);\n}\n\nvec3 colfunc(vec2 dir, float t)\n{\nreturn vec3(func(dir,t + pi2), func(dir,t),func(dir,t + pi3));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    float t =iTime + 4.3;\n    vec2 uv = fragCoord/iResolution.y -vec2(0.375,0);\n    //uv = vec2(floor(176. * uv.x) / 176., floor(99. * uv.y) / 99.);\n\nvec2 dir = uv - 0.5;\n\n  vec3 col = colfunc(dir,t );\n  for (int i = 0; i <5; i++)\n  {    \n  vec2 ex  = (0.05 + 0.04 * cos(0.2 * t)) * vec2(cos(t + float(i) * 2. * pi / 5.),sin(t + float(i) * 2. * pi / 5.));\n  vec3 next =  colfunc(dir + ex,t + 0.15 * float(i));\ncol = abs(col-next); \n  }\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/sssSDN.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "sssSRj", "name": "Sierpiński Carpet Ride", "author": "adamjmurray", "description": "Sierpiński Carpet with movement\n\nSee also: https://www.shadertoy.com/view/sdsXzH", "tags": ["tiles"], "likes": 2, "viewed": 65, "date": "1618897387", "time_retrieved": "2024-06-20T20:39:11.986986", "image_code": "bool aa = true; // antialiased. Change to false for better performance\n\nvec3 draw(vec2 p, float start, float end, float iterations) \n{    \n    float iter = min(20., iterations);\n    float len = end - start;\n    float x = p.x - start;\n    float y = p.y - start;\n    \n    float thresh = 0.03; \n    float pct = 0.;\n    \n    float i;\n    for(i=0.; i<iter+1.; i++) {\n        len /= 3.;       \n        float xd = mod(x/len-1.-20.*sin(iTime*0.11), 6.+5.*cos(iTime*0.5));\n        float yd = mod(y/len-1.-4.*cos(iTime*0.14), 6.+5.*sin(iTime*0.4));\n        if (xd < 1. && yd < 1.) {\n            pct = (smoothstep(0.,thresh,xd) - smoothstep(1.-thresh,1.,xd))\n                * (smoothstep(0.,thresh,yd) - smoothstep(1.-thresh,1.,yd));\n            if (i>iter) {\n                pct *= (1.-(i-iter)); // fade in partial iterations\n            }\n            break;  \n        }\n    }\n    \n    return mix(vec3(0.1,0.1,0.1), vec3(1.-i/iter, 1.-i/(iter+5.), 1.), pct);    \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) \n{\n    vec3 color = vec3(0,0,0);\n    \n    float samples = 0.;\n    float sampStart = 0.;\n    float sampEnd = 0.1;\n    if (aa) {\n        sampStart = -0.33;\n        sampEnd = 0.34;\n    }        \n    \n    for (float x=sampStart; x<sampEnd; x+=0.33) {\n        for (float y=sampStart; y<sampEnd; y+=0.33) {\n            vec2 p = (2.*(fragCoord + vec2(x,y)) - iResolution.xy)/iResolution.y; // [-1,1] vertically    \n            float iterations = 6. - 1200./iResolution.x + (aa ? 1. : 0.);\n            color += draw(p, -1., 1., iterations);\n            samples++;\n        }\n    }\n    fragColor = vec4(color/samples,1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/sssSRj.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "ssSSRR", "name": "Dancing squares animation", "author": "demicuz", "description": "Just trying to recreate a beautiful animation I found on Twitter: [url]https://twitter.com/loackme_/status/1385336764865384448[/url]\n\nI don't know yet how to properly animate 2D transformations, so the code is a mess.", "tags": ["2d", "animation", "aberration", "minimalistic"], "likes": 8, "viewed": 209, "date": "1619527976", "time_retrieved": "2024-06-20T20:39:11.992545", "image_code": "// Inspired by: https://twitter.com/loackme_/status/1385336764865384448\n\n#define ABERRATION\n\n#define BLUR 2. / min(iResolution.x, iResolution.y)\n#define SS(edge, x) smoothstep(-BLUR, BLUR, x - edge)\n\n#define PI 3.14159265359\n#define iR(a) mat2(cos(a), -sin(a), sin(a), cos(a))\n#define iS(s) mat2(1./s, .0, .0, 1./s)\n\nfloat ease(float x) {\n    return x < 0.5 ? 4. * x * x * x : 1. - pow(-2. * x + 2., 3.) / 2.;\n}\n\nfloat square(vec2 p, float size) {\n    return SS(abs(p.x), size) * SS(abs(p.y), size);\n}\n\nfloat hollow_square(vec2 p, float max_size, float border_width) {\n    return square(p, max_size) - square(p, max_size - border_width);\n}\n\nfloat square_anim_transform(vec2 p, float initial_scale, float angle,\n                            float scale, vec2 offset, float t) {\n    angle *= t;\n    scale = mix(initial_scale, scale, t);\n    offset *= t;\n    p = iR(angle) * iS(scale) * (p - offset);\n    \n    return hollow_square(p, .5, .03 / scale);\n}\n\nfloat full_animation(vec2 p, float t) {\n    // Initial positions and scales\n    vec2 p1 = p;\n    float s1 = .8;\n    vec2 p2 = p - vec2(-.2, .2);\n    float s2 = .19;\n    vec2 p3 = iR(PI*.25) * (p - vec2(.09, -.09));\n    float s3 = .36;\n    \n    float square_color = square_anim_transform(p1, s1, PI/2., s2, vec2(-.2, .2), t);\n    square_color += square_anim_transform(p2, s2, PI/4., s3, vec2(.29, -.29), t);\n    square_color += square_anim_transform(p3, s3, -3.*PI/4., s1, iR(PI*.25)*vec2(-.09, .09), t);\n    \n    return clamp(square_color, 0.0, 1.0);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 p = fragCoord / iResolution.xy - vec2(.5);\n    p.x *= iResolution.x / iResolution.y;\n    \n    //vec2 m = iMouse.xy/iResolution.xy;\n    //float t = m.x;\n    \n    float t = iTime;\n    float t_speed = 1.;\n    \n    #ifdef ABERRATION\n    float t_offset = .015;\n    float t0 = ease(fract(t * t_speed));\n    float t1 = ease(fract((t - t_offset) * t_speed));\n    float t2 = ease(fract((t - 2.*t_offset) * t_speed));\n    vec3 color = vec3(full_animation(p, t0),\n                      full_animation(p, t1),\n                      full_animation(p, t2));\n    #else\n    vec3 color = vec3(full_animation(p, ease(fract(t * t_speed))));\n    #endif\n    \n    \n    fragColor = vec4(color, 1.0);\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/ssSSRR.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "sssSzM", "name": "Bitwise mountains", "author": "jarble", "description": "This fractal looks like a mountain range.", "tags": ["fractal", "landscape", "biome", "bitwisemath"], "likes": 3, "viewed": 130, "date": "1618425736", "time_retrieved": "2024-06-20T20:39:11.992545", "image_code": "// Inspired by a discussion on hackaday at:\n// https://hackaday.com/2021/04/13/alien-art-drawn-with-surprisingly-simple-math/\n// Formula shared by \"Joe\" on that page..\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Scale and move to make things a litle more interesting t look at.\n    float scale = 0.2;\n    float trans = iTime * 25.0;\n    vec2 coord = (scale * fragCoord) + vec2(trans,trans);\n    \n    // Heart of color selection.\n    int val = 0;\n    float result = 0.0;\n    vec3 col = vec3(0.0);\n    for(int i = 0; i < 9; i++){\n        coord.y -= (3.0-result);\n        coord = coord/3.0 + coord.yy/9.0;\n        result = ((result + float(val = ((int(coord.x) & int(coord.y)) % 3)))/(2.0));\n        col.x = (result*2.0+col.z)/3.0;\n        col = col.yzx;\n    }\n    // Output.\n    fragColor = vec4((col/2.0),0.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/sssSzM.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "ssXSDn", "name": "2D Light Coverage - Box", "author": "oneshade", "description": "Lighting based on the probability that a light ray reaches a pixel.", "tags": ["2d", "light", "box", "coverage"], "likes": 2, "viewed": 73, "date": "1618463110", "time_retrieved": "2024-06-20T20:39:12.138049", "image_code": "void mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 center = 0.5 * iResolution.xy;\n\n    vec2 uv = (fragCoord - center) / iResolution.y * 4.0;\n    vec3 color = vec3(0.0);\n\n    vec2 b = vec2(1.0 + 0.5 * cos(iTime), 0.5 + 0.25 * sin(iTime));\n\n    uv = abs(uv);\n    if (all(lessThan(uv, b))) color += 1.0;\n    else {\n        vec2 v1 = uv - vec2(b.x * sign(b.y - uv.y), b.y);\n        vec2 v2 = uv - vec2(b.x, b.y * sign(b.x - uv.x));\n        color += acos(dot(v1, v2) / (length(v1) * length(v2))) / 3.14;\n    }\n\n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/ssXSDn.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "ssXSzn", "name": "Ray-Cast Octree EmulateRecursion", "author": "jt", "description": "A basic ray-traced (or rather just ray-cast) subdivided cube by emulating recursion via array of stack-frames.\nAdjust STACKSIZE to change recursion depth.\nTo show subdivision (in a simple way) first and last sub-cube are omitted.", "tags": ["raycast", "raytraced", "recursive", "recursion", "octree", "emulated"], "likes": 7, "viewed": 90, "date": "1618174589", "time_retrieved": "2024-06-20T20:39:13.404931", "image_code": "// Ray-Cast Octree, written 2021 by Jakob Thomsen, license CC0 (public domain)\n// A basic ray-traced (or rather just ray-cast) subdivided cube by emulating recursion via array of stack-frames.\n// Adjust STACKSIZE to change recursion depth.\n// To show subdivision (in a simple way) first and last sub-cube are omitted.\n// (https://www.shadertoy.com/view/ssXSzn)\n\n#define MAXDIST 1000.0\n//#define MAXDIST 1.0 / 0.0\n\nvec3 cubenormal(vec3 v) // position relative to cube center\n{\n    vec3 s = sign(v);\n    vec3 a = abs(v);\n\n    //vec3 n = (a.z > a.y)\n    // ?\n    // (a.z > a.x) ? vec3(0.0, 0.0, s.z) : vec3(s.x, 0.0, 0.0)\n    // :\n    // (a.y > a.x) ? vec3(0.0, s.y, 0.0) : vec3(s.x, 0.0, 0.0);\n\n    vec3 n = mix(\n        mix(vec3(0.0, 0.0, s.z), vec3(s.x, 0.0, 0.0), step(a.z, a.x)),\n        mix(vec3(0.0, s.y, 0.0), vec3(s.x, 0.0, 0.0), step(a.y, a.x)),\n        step(a.z, a.y));\n\n    return n;\n}\n\nstruct intersection\n{\n    float distance;\n    vec3 normal;\n};\n\nintersection skysphere(vec3 raydir)\n{\n    intersection result;\n    result.distance = MAXDIST;\n    result.normal = -raydir; // sky-sphere\n\n    return result;\n}\n\nintersection nearest(intersection a, intersection b)\n{\n    if(a.distance < b.distance) return a; else return b;\n}\n\nstruct ray\n{\n    vec3 pos;\n    vec3 dir;\n};\n\nstruct aabb\n{\n    vec3 min;\n    vec3 max;\n};\n\n// source: https://gamedev.stackexchange.com/questions/18436/most-efficient-aabb-vs-ray-collision-algorithms\nfloat rayboxintersect(ray r, aabb box)\n{\n    float t1 = (box.min.x - r.pos.x) / r.dir.x;\n    float t2 = (box.max.x - r.pos.x) / r.dir.x;\n    float t3 = (box.min.y - r.pos.y) / r.dir.y;\n    float t4 = (box.max.y - r.pos.y) / r.dir.y;\n    float t5 = (box.min.z - r.pos.z) / r.dir.z;\n    float t6 = (box.max.z - r.pos.z) / r.dir.z;\n\n    float tmin = max(max(min(t1, t2), min(t3, t4)), min(t5, t6));\n    float tmax = min(min(max(t1, t2), max(t3, t4)), max(t5, t6));\n\n    if (tmax < 0.0) // box on ray but behind ray origin\n    {\n        return MAXDIST;\n    }\n\n    if (tmin > tmax) // ray doesn't intersect box\n    {\n        return MAXDIST;\n    }\n\n    return tmin;\n}\n\n/*\n// source: https://www.scratchapixel.com/lessons/3d-basic-rendering/minimal-ray-tracer-rendering-simple-shapes/ray-box-intersection\nfloat rayboxintersect(ray r, aabb box)\n{\n    float tmin = (box.min.x - r.pos.x) / r.dir.x;\n    float tmax = (box.max.x - r.pos.x) / r.dir.x;\n\n    if (tmin > tmax)\n    {\n        // swap(tmin, tmax);\n        float tmp = tmin;\n        tmin = tmax;\n        tmax = tmp;\n    }\n\n    float tymin = (box.min.y - r.pos.y) / r.dir.y;\n    float tymax = (box.max.y - r.pos.y) / r.dir.y;\n\n    if (tymin > tymax)\n    {\n        // swap(tymin, tymax);\n        float tmp = tymin;\n        tymin = tymax;\n        tymax = tmp;\n    }\n\n    if ((tmin > tymax) || (tymin > tmax))\n        return MAXDIST; // no intersection\n\n    if (tymin > tmin)\n        tmin = tymin;\n\n    if (tymax < tmax)\n        tmax = tymax;\n\n    float tzmin = (box.min.z - r.pos.z) / r.dir.z;\n    float tzmax = (box.max.z - r.pos.z) / r.dir.z;\n\n    if (tzmin > tzmax)\n    {\n        // swap(tzmin, tzmax);\n        float tmp = tzmin;\n        tzmin = tzmax;\n        tzmax = tmp;\n    }\n\n    if ((tmin > tzmax) || (tzmin > tmax))\n        return MAXDIST; // no intersection\n\n    if (tzmin > tmin)\n        tmin = tzmin;\n\n    if (tzmax < tmax)\n        tmax = tzmax;\n\n    return tmin;\n}\n*/\n\nintersection RAYBOXINTERSECT(ray r, aabb box)\n{\n    intersection result;\n    result.distance = rayboxintersect(r, box);\n    //result.normal = -r.dir; // sky-sphere\n    //if(result.distance < MAXDIST) result.normal = cubenormal(r.pos + r.dir * result.distance - (box.min + box.max) / 2.0);\n\n    result.normal = mix(-r.dir, cubenormal(r.pos + r.dir * result.distance - (box.min + box.max) / 2.0), step(result.distance, MAXDIST));\n\n    return result;\n}\n\naabb[8] subdivide(aabb box)\n{\n    aabb[8] subdiv;\n    vec3 boxhalf = (box.min + box.max) / 2.0;\n    subdiv[0] = aabb(vec3(box.min.x, box.min.y, box.min.z), vec3(boxhalf.x, boxhalf.y, boxhalf.z));\n    subdiv[1] = aabb(vec3(boxhalf.x, box.min.y, box.min.z), vec3(box.max.x, boxhalf.y, boxhalf.z));\n    subdiv[2] = aabb(vec3(box.min.x, boxhalf.y, box.min.z), vec3(boxhalf.x, box.max.y, boxhalf.z));\n    subdiv[3] = aabb(vec3(boxhalf.x, boxhalf.y, box.min.z), vec3(box.max.x, box.max.y, boxhalf.z));\n    subdiv[4] = aabb(vec3(box.min.x, box.min.y, boxhalf.z), vec3(boxhalf.x, boxhalf.y, box.max.z));\n    subdiv[5] = aabb(vec3(boxhalf.x, box.min.y, boxhalf.z), vec3(box.max.x, boxhalf.y, box.max.z));\n    subdiv[6] = aabb(vec3(box.min.x, boxhalf.y, boxhalf.z), vec3(boxhalf.x, box.max.y, box.max.z));\n    subdiv[7] = aabb(vec3(boxhalf.x, boxhalf.y, boxhalf.z), vec3(box.max.x, box.max.y, box.max.z));\n    return subdiv;\n}\n\nstruct stackframe\n{\n    aabb subdiv[8];\n    int branch;\n};\n\nstackframe call(ray r, aabb box)\n{\n    stackframe frame;\n    frame.subdiv = subdivide(box);\n    //frame.branch = 8;\n    frame.branch = 7; // TEST: remove first sub-cube\n    return frame;\n}\n\n#define STACKSIZE 3\nstackframe stack[STACKSIZE];\n\n#define PI 3.1415926\n#define TAU (2.0 * PI)\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 NDC = 2.0 * fragCoord / iResolution.xy - 1.0;\n    NDC.x *= iResolution.x / iResolution.y; // aspect\n\n    float latitude = iTime / 10.0;\n    float longitude = iTime;\n    //mat2 R = mat2(cos(longitude), sin(longitude),-sin(longitude), cos(longitude));\n    mat3 R = mat3(cos(longitude), 0.0, sin(longitude), 0.0, 1.0, 0.0,-sin(longitude), 0.0, cos(longitude));\n    mat3 S = mat3(1.0, 0.0, 0.0, 0.0, cos(latitude), sin(latitude), 0.0,-sin(latitude), cos(latitude));\n\n    vec3 raydir = R * S * vec3(NDC, 1.0);\n    vec3 raypos = R * S * vec3(0.0, 0.0,-3.5);\n    ray r = ray(raypos, raydir);\n\n    intersection result = skysphere(r.dir);\n    int stackptr = 0;\n    stack[stackptr] = call(r, aabb(vec3(-1.0), vec3(+1.0)));\n\n    //intersection result = RAYBOXINTERSECT(r, vec3(-1.0), vec3(+1.0));\n    while(stackptr >= 0)\n    {\n        //if(stack[stackptr].branch > 0)\n        if(stack[stackptr].branch > 1) // TEST: remove last sub-cube\n        {\n            --stack[stackptr].branch;\n            if(stackptr < STACKSIZE - 1)\n            {\n                if(rayboxintersect(r, stack[stackptr].subdiv[stack[stackptr].branch]) < MAXDIST)\n                {\n                    // ray intersects bounding box - descend further\n                    int newstackptr = stackptr + 1;\n                    stack[newstackptr] = call(r, stack[stackptr].subdiv[stack[stackptr].branch]);\n                    stackptr = newstackptr;\n                }\n                else\n                {\n                    // ray misses bounding box - stop recursion\n                }\n            }\n            else\n            {\n                // max recursion depth - reached leaf - stop recursion\n                intersection local = RAYBOXINTERSECT(r, stack[stackptr].subdiv[stack[stackptr].branch]);\n                result = nearest(result, local);\n            }\n        }\n        else\n        {\n            --stackptr; // ascend from recursive call (return)\n        }\n    };\n\n    fragColor = vec4(vec3(0.5 + 0.5 * result.normal), 1.0);\n    //fragColor *= 0.5 + 0.5 * sin(5.0 * result.distance * TAU);\n    if(result.distance >= MAXDIST)\n        fragColor = vec4(0.0, 0.0, 0.5, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc0-1.0", "thumbnail": "https://www.shadertoy.com/media/shaders/ssXSzn.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "ssXXRS", "name": "Scubeical Glow", "author": "Drakyen", "description": "Mostly a lighting & glow/fake transparency test. Looks pretty decent!", "tags": ["3d", "glow"], "likes": 4, "viewed": 35, "date": "1618762457", "time_retrieved": "2024-06-20T20:39:13.404931", "image_code": "#define RSTP 256\n#define SDST 0.01\n#define MDST 64.\n#define rot(a) mat2(cos(a), -sin(a),sin(a), cos(a))\n\nvec3 glw = vec3(0);\n\nfloat bsdf(vec3 p, vec3 s)\n{\n    vec3 q = abs(p) - s;\n    return min(max(q.x, max(q.y,q.z)),0.0) + length(max(q,0.0));\n   \n}\n\nvec2 mpr(vec3 p)\n{\n    vec3 cp = p - vec3(0,1,5);    \n    cp.xz *= rot(iTime);\n    cp.xy *= rot(-iTime);\n    \n    float sd = length(cp) - 1.3;\n    \n    float d = min(bsdf(cp, vec3(1,1,1)), sd);\n    \n    return vec2(d, 1.);\n}\n\nvec2 mp(vec3 p)\n{\n\n    p.x = abs(p.x) - 2.;\n    \n    vec2 d = mpr(p);\n\n    d.x -= 0.3;\n\n    return d;\n}\n\nvec4 tr(vec3 ro, vec3 rd)\n{\n   vec2 d = vec2(0.);\n   vec3 p;\n   for(int i = 0; i < RSTP; i++)\n   {\n       p = ro + rd * d.x;\n       vec2 s = mp(p);\n       d.x += s.x;\n       d.y = s.y;\n       if(s.x < 0.2 && s.x > 0.1) glw += smoothstep(0., 0.4, s.x / length(glw)) * vec3(0.267,0.188,0.875);\n       \n       if(d.x > MDST || s.x < SDST) break;\n   }\n   if(d.x > MDST) {d.y = 0.;} else {glw = vec3(0);}\n   return vec4(p, d.y);\n}\n\nvec3 no(vec3 p)\n{\n    vec2 e = vec2(0.01, 0);\n    float d = mp(p).x;\n    vec3 norm = d - vec3(\n        mp(p - e.xyy).x,\n        mp(p - e.yxy).x,\n        mp(p - e.yyx).x\n    );\n    return normalize(norm);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy)/iResolution.y;\n\n    vec3 ro = vec3(0,1,0), rd = normalize(vec3(uv.x,uv.y,1.));\n    vec4 p = tr(ro, rd);\n    \n    vec3 col = vec3(0.2);\n    \n    if(p.w == 1.)\n    {\n        vec3 ld = normalize(vec3(0,1,0) - p.xyz);\n        vec3 al = vec3(1,0,1);\n        float diff = max(0., dot(no(p.xyz), ld));\n        float fr = pow(1.-abs(dot(no(p.xyz),rd)),4.);\n        float sp = pow(max(dot(reflect(-ld,no(p.xyz)),-rd),0.),40.);\n        col = sp + al*(diff+fr);        \n    }\n    \n    col += min(glw * .25, 1.);\n    \n        \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/ssXXRS.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "ssXXWN", "name": "Noise balance", "author": "FabriceNeyret2", "description": "mouse.y controls parameter                    SPACE toggles noise / turbulence\n\nleft:  most transition between plates \nright: most transition near peaks", "tags": ["procedural", "noise", "perlin", "isolines"], "likes": 11, "viewed": 232, "date": "1618653536", "time_retrieved": "2024-06-20T20:39:13.647211", "image_code": "#define hash(p ) ( 2.* fract(sin((p)*mat2(127.1,311.7, 269.5,183.3)) *43758.5453123) - 1. )\n#define grad(x,y)  dot( hash( i+vec2(x,y) ), f-vec2(x,y) )\n#define Ierf(x) ( atanh(x) / 1.2 )          // not so bad reciprocal\n#define keyToggle(a)  ( texelFetch(iChannel3,ivec2(a,2),0).x > 0.)\n\nfloat noise( vec2 p )\n{\n    vec2 i = floor(p), f = fract(p), u = f*f*(3.-2.*f); // smoothstep\n    return mix( mix( grad(0,0), grad(1,0), u.x),\n                mix( grad(0,1), grad(1,1), u.x), u.y);\n}\n\nfloat perlin( vec2 U ) { // inspired from https://www.shadertoy.com/view/XdXGW8\n    float v = 0., s = .5;\n    mat2 m = mat2( 1.6,  1.2, -1.2,  1.6 );\n    for( int i=0; i<4; i++, s/=2., U*=m )\n        v  += s * noise( U ); \n    return v;\n}\n\n\nvoid mainImage( out vec4 O, vec2 u )\n{\n    vec2 R = iResolution.xy,\n         U = u / R.y,\n         P = 8.*U - vec2(0.,.5*iTime);\n      // P = 8.*U - vec2(iTime,0);         // also interesting to see pattern morphing\n\t\n\tfloat f = keyToggle(32) ? perlin( P ) : noise( P );\n    float m = iMouse.z > 0. ? 2.*iMouse.x/R.x :  2.*u.x/R.x;\n    \n    f = sign(f)*pow(abs(f),exp2(m)-1.) *exp2(m);\n    \n    if (U.y > .5) \n        f *= 8.,                                            // plot isolines\n        O = vec4(1. - abs(fract(f)-.5)/fwidth(f));\n    else\n        O = vec4( .5+.5*f );\n    O = sqrt(O);                                            // to sRGB\n\n}", "image_inputs": [{"id": "4dXGRr", "previewfilepath": "/presets/tex00.jpg", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/presets/tex00.jpg", "ctype": "keyboard"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/ssXXWN.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "tl2fDR", "name": "asdkfjhaskjdhfaksjdhfaklsjhdfasj", "author": "lennyjpg", "description": "sdfasdfasdf", "tags": ["dfsdf"], "likes": 0, "viewed": 141, "date": "1617377670", "time_retrieved": "2024-06-20T20:39:14.544167", "image_code": "vec3 rgb2hsl(vec3 color) {\n \tvec3 hsl; // init to 0 to avoid warnings ? (and reverse if + remove first part)\n\n \tfloat fmin = min(min(color.r, color.g), color.b); //Min. value of RGB\n \tfloat fmax = max(max(color.r, color.g), color.b); //Max. value of RGB\n \tfloat delta = fmax - fmin; //Delta RGB value\n\n \thsl.z = (fmax + fmin) / 2.0; // Luminance\n\n \tif (delta == 0.0) //This is a gray, no chroma...\n \t{\n \t\thsl.x = 0.0; // Hue\n \t\thsl.y = 0.0; // Saturation\n \t} else //Chromatic data...\n \t{\n \t\tif (hsl.z < 0.5)\n \t\t\thsl.y = delta / (fmax + fmin); // Saturation\n \t\telse\n \t\t\thsl.y = delta / (2.0 - fmax - fmin); // Saturation\n\n \t\tfloat deltaR = (((fmax - color.r) / 6.0) + (delta / 2.0)) / delta;\n \t\tfloat deltaG = (((fmax - color.g) / 6.0) + (delta / 2.0)) / delta;\n \t\tfloat deltaB = (((fmax - color.b) / 6.0) + (delta / 2.0)) / delta;\n\n \t\tif (color.r == fmax)\n \t\t\thsl.x = deltaB - deltaG; // Hue\n \t\telse if (color.g == fmax)\n \t\t\thsl.x = (1.0 / 3.0) + deltaR - deltaB; // Hue\n \t\telse if (color.b == fmax)\n \t\t\thsl.x = (2.0 / 3.0) + deltaG - deltaR; // Hue\n\n \t\tif (hsl.x < 0.0)\n \t\t\thsl.x += 1.0; // Hue\n \t\telse if (hsl.x > 1.0)\n \t\t\thsl.x -= 1.0; // Hue\n \t}\n\n \treturn hsl;\n }\nvec3 rgb2hsv(vec3 rgb) {\n \tfloat Cmax = max(rgb.r, max(rgb.g, rgb.b));\n \tfloat Cmin = min(rgb.r, min(rgb.g, rgb.b));\n \tfloat delta = Cmax - Cmin;\n\n \tvec3 hsv = vec3(0., 0., Cmax);\n\n \tif (Cmax > Cmin) {\n \t\thsv.y = delta / Cmax;\n\n \t\tif (rgb.r == Cmax)\n \t\t\thsv.x = (rgb.g - rgb.b) / delta;\n \t\telse {\n \t\t\tif (rgb.g == Cmax)\n \t\t\t\thsv.x = 2. + (rgb.b - rgb.r) / delta;\n \t\t\telse\n \t\t\t\thsv.x = 4. + (rgb.r - rgb.g) / delta;\n \t\t}\n \t\thsv.x = fract(hsv.x / 6.);\n \t}\n \treturn hsv;\n }\n\nvec3 mod289(vec3 x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 mod289(vec4 x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 permute(vec4 x) {\n     return mod289(((x*34.0)+1.0)*x);\n}\n\nvec4 taylorInvSqrt(vec4 r)\n{\n  return 1.79284291400159 - 0.85373472095314 * r;\n}\n\nfloat snoise(vec3 v)\n  { \n  const vec2  C = vec2(1.0/6.0, 1.0/3.0) ;\n  const vec4  D = vec4(0.0, 0.5, 1.0, 2.0);\n\n// First corner\n  vec3 i  = floor(v + dot(v, C.yyy) );\n  vec3 x0 =   v - i + dot(i, C.xxx) ;\n\n// Other corners\n  vec3 g = step(x0.yzx, x0.xyz);\n  vec3 l = 1.0 - g;\n  vec3 i1 = min( g.xyz, l.zxy );\n  vec3 i2 = max( g.xyz, l.zxy );\n\n  //   x0 = x0 - 0.0 + 0.0 * C.xxx;\n  //   x1 = x0 - i1  + 1.0 * C.xxx;\n  //   x2 = x0 - i2  + 2.0 * C.xxx;\n  //   x3 = x0 - 1.0 + 3.0 * C.xxx;\n  vec3 x1 = x0 - i1 + C.xxx;\n  vec3 x2 = x0 - i2 + C.yyy; // 2.0*C.x = 1/3 = C.y\n  vec3 x3 = x0 - D.yyy;      // -1.0+3.0*C.x = -0.5 = -D.y\n\n// Permutations\n  i = mod289(i); \n  vec4 p = permute( permute( permute( \n             i.z + vec4(0.0, i1.z, i2.z, 1.0 ))\n           + i.y + vec4(0.0, i1.y, i2.y, 1.0 )) \n           + i.x + vec4(0.0, i1.x, i2.x, 1.0 ));\n\n// Gradients: 7x7 points over a square, mapped onto an octahedron.\n// The ring size 17*17 = 289 is close to a multiple of 49 (49*6 = 294)\n  float n_ = 0.142857142857; // 1.0/7.0\n  vec3  ns = n_ * D.wyz - D.xzx;\n\n  vec4 j = p - 49.0 * floor(p * ns.z * ns.z);  //  mod(p,7*7)\n\n  vec4 x_ = floor(j * ns.z);\n  vec4 y_ = floor(j - 7.0 * x_ );    // mod(j,N)\n\n  vec4 x = x_ *ns.x + ns.yyyy;\n  vec4 y = y_ *ns.x + ns.yyyy;\n  vec4 h = 1.0 - abs(x) - abs(y);\n\n  vec4 b0 = vec4( x.xy, y.xy );\n  vec4 b1 = vec4( x.zw, y.zw );\n\n  //vec4 s0 = vec4(lessThan(b0,0.0))*2.0 - 1.0;\n  //vec4 s1 = vec4(lessThan(b1,0.0))*2.0 - 1.0;\n  vec4 s0 = floor(b0)*2.0 + 1.0;\n  vec4 s1 = floor(b1)*2.0 + 1.0;\n  vec4 sh = -step(h, vec4(0.0));\n\n  vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy ;\n  vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww ;\n\n  vec3 p0 = vec3(a0.xy,h.x);\n  vec3 p1 = vec3(a0.zw,h.y);\n  vec3 p2 = vec3(a1.xy,h.z);\n  vec3 p3 = vec3(a1.zw,h.w);\n\n//Normalise gradients\n  vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));\n  p0 *= norm.x;\n  p1 *= norm.y;\n  p2 *= norm.z;\n  p3 *= norm.w;\n\n// Mix final noise value\n  vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n  m = m * m;\n  return 42.0 * dot( m*m, vec4( dot(p0,x0), dot(p1,x1), \n                                dot(p2,x2), dot(p3,x3) ) );\n  }\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/max(iResolution.x,iResolution.y);\n    float t = iMouse.x + iTime * 0.02;\n    vec2 u = uv * 1.3;\n   \n    u+=200.0;\n    float d = snoise(vec3(-u.x,-u.y,t+55.0)*0.1);\n    /*\n    float f = 0.5;\n    float angle = d*2.0;\n    u.x+=sin(angle)*f;\n    u.y+=cos(angle)*f;\n*/\n    \n    float r = snoise(vec3(u.x,u.y,t));\n    u+=123.45;\n    float g = snoise(vec3(u.x,u.y,t+10.0));\n    u+=1123.45;\n    float b = snoise(vec3(u.x,-u.y,t+50.0));\n    vec3 off = vec3(1.0, 0.6, 0.37);\n    vec3 rgb = 0.5-vec3(r,g,b)*off;\n    vec3 col = rgb2hsv(rgb);\n    //col*=0.9;\n   // col.b-=d*3.0;\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/tl2fDR.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "tlKcRt", "name": "dvg_Beam", "author": "david4jsus", "description": "Learned how to make a column mask and make it a bit wavy.", "tags": ["column", "beam", "trig"], "likes": 1, "viewed": 45, "date": "1618970839", "time_retrieved": "2024-06-20T20:39:14.544167", "image_code": "#define PI 3.1415926538\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Beam\n    float x = iMouse.x / iResolution.x;\n    if (x == 0.0) x += 0.5; // Have the beam start at the center\n    x += sin (mod (iTime, 2.0 * PI) + uv.y) * 0.1;\n    float radius = (cos (iTime * 3.0) * 0.05) + 0.2;\n    vec3 mask1 = vec3 (smoothstep (x, x-radius, uv.x));\n    vec3 mask2 = vec3 (smoothstep (x, x+radius, uv.x));\n    vec3 line = mask1 + mask2;\n    \n    // Color\n    vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n    \n    // Output to screen\n    fragColor = vec4(line / col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/tlKcRt.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "tttfDl", "name": "hexagon distance", "author": "Dude", "description": "hexagon dsf shader with repetition", "tags": ["hexagons"], "likes": 0, "viewed": 35, "date": "1618396310", "time_retrieved": "2024-06-20T20:39:14.544167", "image_code": "#define MAXIMUM_STEPS 80\n#define DISTANCE_THRESHOLD 0.1\n#define FAR_CLIP 30.0\n\n/* ROTATIONS */\n\nvoid rX(inout vec3 p, float a) {\n    vec3 q = p;\n    float c = cos(a);\n    float s = sin(a);\n    p.y = c * q.y - s * q.z;\n    p.z = s * q.y + c * q.z;\n}\n\nvoid rY(inout vec3 p, float a) {\n    vec3 q = p;\n    float c = cos(a);\n    float s = sin(a);\n    p.x = c * q.x + s * q.z;\n    p.z = -s * q.x + c * q.z;\n}\n\nvoid rZ(inout vec3 p, float a) {\n    vec3 q = p;\n    float c = cos(a);\n    float s = sin(a);\n    p.x = c * q.x - s * q.y;\n    p.y = s * q.x + c * q.y;\n}\n\nfloat sdHexPrism( vec3 p, vec2 h )\n{\n  const vec3 k = vec3(-0.8660254, 0.5, 0.57735);\n  p = abs(p);\n  p.xy -= 2.0*min(dot(k.xy, p.xy), 0.0)*k.xy;\n  vec2 d = vec2(\n       length(p.xy-vec2(clamp(p.x,-k.z*h.x,k.z*h.x), h.x))*sign(p.y-h.x),\n       p.z-h.y );\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nvec4 marchRay(vec3 ro, vec3 rd, float id) {\n\n    float d = 0.0; //distance marched\n    vec4 pc = vec4(0.2, 0.2, 0.7, 1.); //pixel colour\n\n    for (int i = 0; i < MAXIMUM_STEPS; ++i) {\n        \n        vec3 rp = ro + rd * d; //ray position\n        float time = id + iTime * 1.5;\n        rX(rp,time);\n        rY(rp,time + 0.3);\n        float ns = sdHexPrism(rp, vec2(3., 3.));\n        d += ns;\n        \n        if (ns < DISTANCE_THRESHOLD) {\n            vec3 clr = vec3(1.);\n            \n            rp = clr + (rp.y*0.4);\n            pc = vec4(.9, .9, .3, 1.);\n            pc *= vec4(rp.x, rp.y, rp.z, 1) + 0.4;\n            pc *= texture(iChannel1, rp.xy).rgba;\n            break;\n        }\n        \n        if (d > FAR_CLIP) {\n            break;\n        }\n    }\n\n    return pc;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/ iResolution.y;\n    float xfac = fract(uv.x * 5.);\n    float yfac = fract(uv.y * 5.);\n    float id = abs(uv.x);\n    uv = vec2(xfac, yfac);\n    uv.x -= 0.5;\n    uv.y -= 0.5;\n    vec3 rd = normalize(vec3(uv, 2.));\n    vec3 ro = vec3(0, 0, -20);\n    \n\tfragColor = marchRay(ro, rd, id);\n}", "image_inputs": [{"id": "XdX3Rn", "previewfilepath": "/media/ap/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/tttfDl.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "WddSzl", "name": "HypnoFlower-TEST", "author": "Dude", "description": "HypnoFlower", "tags": ["hypnoflower"], "likes": 0, "viewed": 32, "date": "1618396292", "time_retrieved": "2024-06-20T20:39:14.550355", "image_code": "#define PI 3.1415\n\nvoid rz(inout vec2 p, float a) {\n    vec2 q = p;\n    p.x = q.x * cos(a) - q.y* sin(a);\n    p.y = q.x * sin(a) + q.y * cos(a);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord-0.5*iResolution.xy)/iResolution.y;\n    \n    uv *= 0.5;\n    \n    vec2 deform,st,ru;\n    float disTest,ClampTest,d,dd,dsq,ddsq,dis,col,r,sharp,shape,shape2,shape3,lineLength;\n    vec4 clrOut = vec4(0.00,0.0,0.,0.);\n    float a = atan(uv.y,uv.x);\n    float Sharp = .5; \n    float t = -iTime * 0.1;\n\n    deform = vec2(cos(t*5.), sin(t*5.))*0.01;\n    d = length(uv);\n    dd = length(uv+deform);\n\n    float oder = 8.;\n    dsq = pow( pow(uv.x,oder)+pow(uv.y,oder),1./(oder) );\n    ddsq = pow( pow(uv.x+deform.x,oder)+pow(uv.y+deform.y,oder),1./(oder) );\n    \n    vec2 uvr = uv;\n    float rd;\n    float rdsq;\n    rz(uvr,t*.75);\n    //rz(uvr,t*.5*.75*sin(d*.5));\n    rd = length(uvr);\n    rdsq = pow( pow(uvr.x,oder)+pow(uvr.y,oder),1./(oder) );\n   \n    r = .05;\n\t\n    shape = ( abs( sin(rdsq*30.)) - \n             0.7 * (1.+0.3*sin(a*8.+2.*PI*t)) * \n             (1.25+ .25*sin(t*10.)) * \n             (1.+0.1*sin(a*16.-4.*PI*t)) );\n    \n    shape2 = ( abs( sin(rdsq*30.)) - \n             0.7 * (1.+0.3*sin(a*8.+2.*PI*t)) * \n             (1.25+ .25*sin(t*10.)) * \n             (1.+0.1*sin(a*16.-4.*PI*t*.75*sin(d*.25))) );\n    \n    shape3 = ( abs( sin(rdsq*30.)) - \n             0.7 * (1.+0.3*sin(a*8.+200.*PI*(1.2*sin(t*2.*PI/10.))*sin(d*.25))) * \n             (1.25+ .25*sin( (1.2*sin(t*2.*PI/10.)) *400.*.75*sin(d*.1))) * \n             (1.+0.1*sin(a*16.-4.*PI*t)) );\n    \n    \n    \n    st = vec2(d*2., shape3);\n    lineLength = .25+.45*sin(t*5.);\n    lineLength += (1.-abs(sin(t*4.*5.)))*.2;\n    dis = length(st - vec2(clamp(st.x, -lineLength, lineLength), 0.));\n\n    col += smoothstep(Sharp, -Sharp, dis);\n\n    clrOut += col * vec4(0.0,1.0,0.0,1.);\n    clrOut = mix(clrOut, vec4(1.,.0,.0,.0)*col, d*3.);\n\n    fragColor = clrOut;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/WddSzl.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "wljSWt", "name": "Glitch monolith ", "author": "AlexHoratio", "description": "It's a glitch, and the code is bad B)", "tags": ["glitch"], "likes": 1, "viewed": 31, "date": "1618333992", "time_retrieved": "2024-06-20T20:39:14.726154", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Time varying pixel color\n    vec3 col = vec3(uv.x, uv.y, cos(mod(iTime, float(0.2))));\n    \n    vec2 uv_from_mouse = fragCoord - (vec2(0.5)*iResolution.xy);\n    \n    float fdistance = sqrt(pow(uv_from_mouse.x, float(2)) + pow(uv_from_mouse.y, float(2)));\n\n    if(fdistance < float(350)){\n     \t  col = vec3(uv.x, uv.y, pow(tan(iTime*float(4)), float(8))); \n          col = mix(tan(col), vec3(uv.x, uv.y, cos(iTime)), vec3(pow(fdistance, float(2))/float(10000)));\n    }\n    \n    col = mix(col, vec3(uv.x - 0.1, uv.y - 0.1, -cos(iTime)), float(tan(iTime)));\n        \n        \n    \n    // Output to screen\n    fragColor = vec4(tan(col*vec3(9))*0.5+vec3(abs(sin(iTime))), 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/wljSWt.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "wltBDl", "name": "Hexagon Grid", "author": "Dude", "description": "copied the pixelToCubial from somewhere else in shadertoy, cant remember where", "tags": ["hexagongrid"], "likes": 2, "viewed": 171, "date": "1619616705", "time_retrieved": "2024-06-20T20:39:14.726154", "image_code": "#define HMAT mat2(vec2(1., 0.), vec2(.5, 0.866))\n#define hScale .12\n\nfloat N21(vec2 p){\n    return fract(sin(p.x * 100. + p.y * 6574.) * 5647.);\n}\n\nfloat SmoothNoise(vec2 uv){\n    vec2 lv = fract(uv * 10.);\n    vec2 id = floor(uv * 10.);\n    \n    lv = lv * lv * (3. -2. * lv);\n    \n    float bl = N21(id);\n    float br = N21(id + vec2(1,0));\n    float b = mix(bl, br, lv.x);\n    \n    float tl = N21(id+vec2(0,1));\n    float tr = N21(id+vec2(1,1));\n    float t = mix(tl, tr, lv.x);\n    \n    return mix(b, t, lv.y);\n}\n\nvoid pixelToCubial(vec2 uv, out vec3 cubial, out vec3 grid) {\n\n    vec2 axial = inverse(HMAT) * uv;\n    cubial = vec3(axial, -axial.x - axial.y) / hScale;\n    grid = round(cubial);\n    vec3 dist = abs(cubial - grid);\n    if (dist.x > dist.y && dist.x > dist.z) {\n        grid.x = -grid.y - grid.z;\n    }\n    else if (dist.y > dist.z) {\n        grid.y = -grid.x - grid.z;\n    }\n    else {\n        grid.z = -grid.x - grid.y;\n    }\n}\n\nfloat cubialDistance(vec3 a, vec3 b) {\n    vec3 c = abs(a - b);\n    return max(c.x, max(c.y, c.z));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 vec_pos = (gl_FragCoord.xy);\n    vec2 uv = (vec_pos - .5*iResolution.xy) / iResolution.y;\n    uv *= 3.;\n    vec4 uv_r = vec4(uv.x, uv.y, 0., 0.);\n\n    vec3 cubial;\n    vec3 grid;\n    pixelToCubial(uv_r.xy, cubial, grid);\n\n    vec3 coord = cubial - grid;\n    vec3 dist = abs(coord.xyz - coord.zxy);\n\n    vec3 background_col = vec3(0.);\n    float edge = (12.*2.)-1.;\n    float center_distance = cubialDistance(grid/edge, vec3(0,0,0) );\n    if (center_distance > 0.5){\n        background_col = vec3(center_distance, center_distance, center_distance);\n    }\n    \n    float uvm = uv.y * 3. + uv.x + (SmoothNoise(grid.xy * (iTime*0.02)) * 1.9);\n    \n    float wave = sin(uvm+0.5+(iTime*2.));\n    float thickness = .1 * wave;\n    vec3 col = vec3(wave * 2., 1., 1.);\n    \n    thickness += 0.2;\n    col *= 1. - smoothstep(thickness, thickness + (2.0 / iResolution.y) / hScale, 1.0 - max(dist.x, max(dist.y, dist.z)));\n\n    col = (col + background_col)/2.;\n\n    fragColor = vec4(col, 1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/wltBDl.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "wtGyzw", "name": "Fire Iteration", "author": "abhinavneelam", "description": "Creating fire using noise sampling", "tags": ["fire"], "likes": 1, "viewed": 156, "date": "1618595197", "time_retrieved": "2024-06-20T20:39:14.732317", "image_code": "#define PI 3.14159\n\nvec2 random2(vec2 st){\n    st = vec2( dot(st,vec2(127.1,311.7)),\n              dot(st,vec2(269.5,183.3)) );\n    return -1.0 + 2.0*fract(sin(st)*43758.5453123);\n}\n\nfloat noise(vec2 st) {\n    vec2 i = floor(st);\n    vec2 f = fract(st);\n\n    vec2 u = f*f*(3.0-2.0*f);\n\n    return mix( mix( dot( random2(i + vec2(0.0,0.0) ), f - vec2(0.0,0.0) ),\n                     dot( random2(i + vec2(1.0,0.0) ), f - vec2(1.0,0.0) ), u.x),\n                mix( dot( random2(i + vec2(0.0,1.0) ), f - vec2(0.0,1.0) ),\n                     dot( random2(i + vec2(1.0,1.0) ), f - vec2(1.0,1.0) ), u.x), u.y);\n}\n\nfloat texture0(vec2 uv)\n{\n    return texture(iChannel0, uv).x;\n}\n\nfloat rangestep(float px, float py, float x)\n{\n    float f3 = abs(px-py);\n    \n    float f4 = 2.0/f3;\n    \n    return -clamp(floor(abs((f4* (x-f3/2.0 - px)))),0.0,1.0)+1.0;\n}\n\nvec3 back(vec2 uv)\n{\n    float a = (noise(30.0*uv)*.5+.5);\n    \n    float or= 3.0;\n    \n    uv -= vec2(0.02,0.2);\n    uv*=vec2((0.75-0.70) * (.5*sin(or*iTime)+.5) + 0.7\n                    ,(0.55-0.48) * (.5*sin(or*iTime)+.5) + 0.48);\n    uv += vec2(0.13,0.0);\n    \n    float ss = 0.7*(1.0-smoothstep(.7,1.2, 2.2*distance(vec2(0.5,0.0),1.1*uv)));\n    \n    float w1 = 2.0 * noise(vec2(iTime,iTime))*.5+.5;\n    \n    float w2 = (1.0/8.0)*max(floor(6.0*w1),0.0);\n\n    vec3 col = 0.4*ss*vec3(1.0,0.0,0.0) * vec3(w2+noise(9.0*uv)*.5+.5);\n    \n    return col;\n}\n\nvec3 rgb(vec3 c)\n{\n    return c/255.0f;\n}\n\nvec2 rotatePoint(float angle, vec2 p)\n{\n    float si = sin(angle);\n    float co = cos(angle);\n    \n    return mat2( co, -si, si, co) * p;\n}\n\nvec3 particles(vec2 uv)\n{\n    float POINTS = 8.0;\n    \n    vec3 c = vec3(0.0);\n    float t = iTime;\n    \n    for(float i = 0.0;i<POINTS;i++)\n    {\n        float radius = 0.12;\n        radius = 0.2;\n        \n        float adif = 3.;\n        adif=10.;\n        \n        float rot;\n        //rot = (-PI/adif - PI/adif)*(.5*sin(t)+.5) + PI/adif;\n        \n        vec2 rand;\n        rand.x = texture0(vec2(i,i) / vec2(POINTS));\n        rand.y = texture0(vec2(rand.x));\n        \n        rand.y = mod(rand.y+t*8.5, 1.0);\n        \n        radius = (0.25-0.12) * (rand.y) + 0.12;\n        \n        float rx = rand.x = (0.9-0.1) * rand.x + 0.1;\n        float ry = rand.y = 60.0 * (1.0-0.0) * rand.y + 0.0;\n        \n        float rc = 9.0 * texture0(vec2(rand.x, rand.y));\n        \n        rot = (-PI/adif - PI/adif) * rand.x + PI/adif;\n        \n        vec2 p = rotatePoint(rot, rand-uv);\n        float pl = length(p);\n        \n        float cl = length(cross(vec3(0.0,1.0,0.), vec3(p,0.)));\n        \n        float clthres = 0.001;\n        \n        vec3 color = mix(rgb(vec3(255,40,0)),rgb(vec3(255,140,0)), rc);\n        \n        if(pl < radius && cl < clthres)\n            c += color * smoothstep(0.1 + radius, 0.1, (1./radius)*distance(uv,rand));\n    }\n    //rot, color, pos, \n\n    return c;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    vec3 col = back(uv);\n    \n    float time = iTime;\n    //time=1.0;\n    \n    float iuv = 0.9*uv.y;\n    float box = rangestep(.3,.7,uv.x) * rangestep(.0,.9,uv.y);\n    //box=1.0;\n    \n    float b1 = 0.3 * sin(time) + 0.7;\n    float turby = 0.5 * uv.y * sin(5.0*time) + 1.0;\n    \n    float bad = 0.2*b1*noise(vec2(5.0*uv.x, uv.y)) + 0.4*turby*noise(vec2(0.8*uv.x+time,uv.y));\n    float turbx = uv.x + bad;\n    \n    float tempdist = distance(vec2(0.5,0.0),vec2(uv));\n    tempdist = 0.7*(1.0-smoothstep(vec2(0.0, 0.1).y, vec2(0.5,1.11).y,0.5* tempdist));\n    \n    vec3 orange = vec3(247.f, 103.f, 7.f) / 255.f;\n    vec3 col2 = tempdist*8.9 * orange * vec3((noise(25.0*vec2(turbx,0.15*uv.y - 0.3 * time)) * .5 + .5));\n    \n    vec2 p = uv + vec2(-0.5,-0.5+0.4);\n    p.x *= iResolution.x/iResolution.y;\n    \n    float v = smoothstep(-1.0, 1.2, 1.1*1.5*length(p) - 0.3);\n    //v=0.f;\n    col = mix(col2, col, v);\n    \n    //col = particles(uv);\n    //col += particles(uv)-col;\n    \n    col+=particles(uv);\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": "4dXGzn", "previewfilepath": "/media/ap/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/wtGyzw.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "Wtyfzy", "name": "trippy---", "author": "ryahnaus", "description": "trippy little thing", "tags": ["color"], "likes": 0, "viewed": 40, "date": "1617852574", "time_retrieved": "2024-06-20T20:39:14.732317", "image_code": "float f(float n, vec3 hsl)\n{\n    float k = mod((n + hsl.x / 30.0), 12.0);\n    float a = hsl.y * min(hsl.z, 1.0 - hsl.z);\n    \n    return hsl.z - a * max(-1.0, min(min(k - 3.0, 9.0 - k), 1.0));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = fragCoord / iResolution.xy - vec2(0.5);\n    \n    uv.y += sin(12.0 * uv.x + iTime) / 8.0;\n    uv.x += cos(8.0 * uv.y + iTime / 2.0) / 4.0;\n    \n    uv.y += sin(20.0 * uv.x + iTime * 4.0) / 16.0;\n    uv.x += cos(48.0 * uv.y + iTime * 2.0) / 32.0;\n\n    uv.y += cos(15.0 * uv.x + iTime / 2.0) / 20.0;\n    uv.x += sin(32.0 * uv.y + iTime * 2.0) / 40.0;\n    \n    float dx, dy, dis;\n    vec2 coord = fragCoord / vec2(max(iResolution.x, iResolution.y));\n    vec2 mouse = iMouse.xy / vec2(max(iResolution.x, iResolution.y));\n    \n    dx = coord.x - mouse.x;\n    dy = coord.y - mouse.y;\n    dis = sqrt(dx*dx + dy*dy);\n    \n    vec3 hsl = vec3(0.0, 1.0, 0.5);\n    \n    \n    if (dis < 0.15)\n    {\n        if (dis < 0.1)\n        {\n            uv.x *= sqrt(abs(dx));\n            uv.y *= sqrt(abs(dy));\n            hsl.z = 1.0 - dis * 10.0;\n        }\n        else\n        {\n            float progress = 1.0 - (dis - 0.1) * 20.0;\n            progress *= progress;\n            \n            uv.x = uv.x * (1.0 - progress) + (fragCoord.x / iResolution.x) * progress;\n            uv.y = uv.y * (1.0 - progress) + (fragCoord.y / iResolution.y) * progress;\n        }\n    }\n    \n    hsl.x = sqrt(uv.x * uv.x + uv.y * uv.y) * 7200.0 - iTime * 270.0 + (uv.x > 0.0 ? 180.0 : 0.0) + atan(uv.y / uv.x) * 180.0 / 3.14159265358;\n    vec3 rgb = vec3(0.0);\n    \n    //hsl.x = round(hsl.x / 45.0) * 45.0;\n    \n    rgb.x = f(0.0, hsl);\n    rgb.y = f(8.0, hsl);\n    rgb.z = f(4.0, hsl);\n    \n    fragColor = vec4(rgb, 1.0);\n    \n    vec3 col = vec3(mod(hsl.x, 360.0) >= 180.0 ? 1.0 : 0.0);\n    \n    //fragColor = vec4(col, 1.0);\n    \n\n    //if (mod(uv.x, 0.1) > 0.095 || mod(uv.y, 0.1) > 0.095) fragColor = vec4(1.0);\n    //else fragColor = vec4(0.0);\n    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/Wtyfzy.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "Xl3XWs", "name": "specular curved box..", "author": "bolloxim", "description": "specular highlight on curved edged", "tags": ["specular", "box", "curved"], "likes": 3, "viewed": 42, "date": "1619216927", "time_retrieved": "2024-06-20T20:39:15.180661", "image_code": "// Andi Smithers \n// button shader for smooth border edges\n// could also add shadow and shine effect as well using \n\nfloat Specular (vec3 normal)\n{\n    vec3 vLight = normalize(vec3(0.2,1.0,-0.2));\n    \n    float sp = pow(clamp(dot(vLight,reflect(vec3(0.0,0.0,1.0),normal)),0.0,1.0),25.0);\n    return sp;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // uniforms\n    float borderSize = 0.15;\n    float antiAliasSize = 0.02;\n    vec4 borderColor = vec4(0.8,0.9,1.0, 1);\n    vec4 centreColor = vec4(0.1,0.5,0.9,1);\n    float wobbly = iTime;\n\tfloat rounding = sin(wobbly)*3.0+4.0;\n    vec2 shadowVec = vec2(-0.05, 0.15);\n    float scaleBox = 1.2;\n\n    // alias thickness\n    float aascalar = 1.0 / antiAliasSize;\n    float outerAlias = 1.0 - antiAliasSize;\n\n    // convert UV into normalized coord\n    vec2 iuv = fragCoord.xy / iResolution.xy;\n\tvec2 uv = fragCoord.xy / iResolution.y;\n    vec2 uvUnit = (uv*2.0-1.0) * scaleBox;\n    vec2 signUv = sign(uvUnit);\n    vec2 shadowUnit = uvUnit + shadowVec;\n\n    // rounded edge - have to abs the value incase shader doesnt support negative powers\n    uvUnit = pow(abs(uvUnit), vec2(rounding)) * signUv;\n    shadowUnit = pow(abs(shadowUnit), vec2(rounding));\n    \n    // compute border\n    float borderEdge = pow(1.0-borderSize, rounding);\n    float borderAlias = borderEdge - antiAliasSize;\n    \n    // edge\n    float edge = length(uvUnit);\n    float outer = 1.0-(clamp(edge, outerAlias, 1.0)-outerAlias) * aascalar;\n    float inner = 1.0-(clamp(edge, borderAlias, borderEdge)-borderAlias) * aascalar;\n    float shadowInner = 1.0-(clamp(length(shadowUnit), borderAlias, borderEdge)-borderAlias) * aascalar;\n    float shadowOuter = 1.0-(clamp(length(shadowUnit), outerAlias, 1.0)-outerAlias) * aascalar;\n    \n    // blow out outer then chose minimum this ensures a mask around the alpha output\n    float outermask = min(outer*1000.0, 1.0);\n    \n    // fetch image and poor mans chromakey alpha\n    vec4 image = texture(iChannel0, iuv);\n    float alpha = length(image.rgb-vec3(0,1,0));\n    alpha = alpha> 0.5 ? 1.0 : 0.0;\n\n    // shadow\n    float shade = shadowInner<0.9 ? 0.8 + shadowInner*0.2: 1.0;\n    float shadeOut = shadowOuter>0.5 ? 0.0 + shadowOuter*0.2: 0.0;\n\t\n        \n    // blend inner/outer and image with image alpha\n    vec4 color = (centreColor*inner*(1.0-alpha)+image*alpha*inner)*shade + borderColor*(1.0-inner)*outermask;\n    color.a =  max(outer, shadeOut);\n    \n    // blend against a background texture - because shadertoy\n    vec4 background = texture(iChannel1, iuv);\n        \n    vec3 vNormal = normalize(vec3(uvUnit.x*inner,uvUnit.y*inner,sqrt(clamp(1.0-uvUnit.x*uvUnit.x+uvUnit.y*uvUnit.y,0.0,1.0))));\n    float spec = Specular(vNormal);\n    // and set the final color \n    fragColor = (color*color.a) + background*(1.0-color.a) + spec*vec4(1.0,1.0,1.0,0.0);\n}", "image_inputs": [{"id": "4dXGRn", "previewfilepath": "/media/ap/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg", "ctype": "texture"}, {"id": "XsfGRn", "previewfilepath": "/media/ap/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/Xl3XWs.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "Xlc3zB", "name": "Planet 7120 - second commit", "author": "patu", "description": "second commit for https://www.pouet.net/prod.php?which=68093 :)\n2016(?)\n\nfollow up for https://www.shadertoy.com/view/ldVXDm", "tags": ["demoscene"], "likes": 11, "viewed": 180, "date": "1618010560", "time_retrieved": "2024-06-20T20:39:18.314255", "image_code": "#define getNormal getNormalHex\n#define V vec3\n#define W vec2\n#define F float\n#define FAR 330.\n#define INFINITY 1e32\n#define t iTime\n#define mt iChannelTime[1]\n\n//#define FOG 1.\n\n#define PI 3.14159265\n//#define TAU (2*PI)\n#define PHI (1.618033988749895)\n\nF \n    Z = 0., \n    J = 1., \n\tvol = 0.,\n\tnoise = 0.;\n\nfloat hash12(vec2 p) {\n\tfloat h = dot(p,vec2(127.1,311.7));\t\n    return fract(sin(h)*43758.5453123);\n}\nfloat noise_3(in vec3 p) {\n    vec3 i = floor(p);\n    vec3 f = fract(p);\t\n\tvec3 u = f*f*(3.0-2.0*f);\n    \n    vec2 ii = i.xy + i.z * vec2(5.0);\n    float a = hash12( ii + vec2(0.0,0.0) );\n\tfloat b = hash12( ii + vec2(1.0,0.0) );    \n    float c = hash12( ii + vec2(0.0,1.0) );\n\tfloat d = hash12( ii + vec2(1.0,1.0) ); \n    float v1 = mix(mix(a,b,u.x), mix(c,d,u.x), u.y);\n    \n    ii += vec2(5.0);\n    a = hash12( ii + vec2(0.0,0.0) );\n\tb = hash12( ii + vec2(1.0,0.0) );    \n    c = hash12( ii + vec2(0.0,1.0) );\n\td = hash12( ii + vec2(1.0,1.0) );\n    float v2 = mix(mix(a,b,u.x), mix(c,d,u.x), u.y);\n        \n    return max(mix(v1,v2,u.z),.0);\n}\n\n\nfloat B(vec3 x)\n{\n    float r = 0.0;\n    float w = 1.0, s = 1.0;\n    for (int i=0; i<5; i++)\n    {\n        w *= 0.5;\n        s *= 2.0;\n        r += w * noise_3(s * x);\n    }\n    return r;\n}\n\n#define fromRGB(a, b, c) vec3(F(a), F(b), F(c)) / 255.;\n    \nvec3 \n    light = vec3(0. ,0., 1.),\n\tlightDir;\n\nvec3 lightColour = normalize(vec3(1.8, 1.0, 0.3) ); \n\nvec3 saturate(vec3 a) { return clamp(a, 0.0, 1.0); }\nvec2 saturate(vec2 a) { return clamp(a, 0.0, 1.0); }\nfloat saturate(float a) { return clamp(a, 0.0, 1.0); }\n\nvec3 Rep( vec3 p, vec3 c )\n{\n    return mod(p,c)-0.5*c;\n}\n\n// Repeat only a few times: from indices <start> to <stop> (similar to above, but more flexible)\nfloat pModInterval1(inout float p, float size, float start, float stop) {\n\tfloat halfsize = size*0.5;\n\tfloat c = floor((p + halfsize)/size);\n\tp = mod(p+halfsize, size) - halfsize;\n\tif (c > stop) { //yes, this might not be the best thing numerically.\n\t\tp += size*(c - stop);\n\t\tc = stop;\n\t}\n\tif (c <start) {\n\t\tp += size*(c - start);\n\t\tc = start;\n\t}\n\treturn c;\n}\n\n\n\nfloat smin( float a, float b, float k )\n{\n    float res = exp( -k*a ) + exp( -k*b );\n    return -log( res )/k ;\n}\n\nvoid pR(inout vec2 p, float a) {\n\tp = cos(a)*p + sin(a)*vec2(p.y, -p.x);\n}\n\nfloat opU2( float d1, float d2 ) {\n    if (d1 < d2) return d1;\n    return d2;\n}\n\nvec3 opU2( vec3 d1, vec3 d2 ) {\n    if (d1.x < d2.x) return d1;\n    return d2;\n}\n\nstruct geometry {\n    float dist;\n    float materialIndex;\n    float specular;\n    float diffuse;\n    vec3 color;  \n    float mirror;\n};\n\ngeometry geoU(geometry g1, geometry g2) {\n    if (g1.dist < g2.dist) return g1;\n    return g2;\n}\n\nvec3 opS2( vec3 d1, vec3 d2 ){\t\n    if (-d2.x > d1.x) return -d2;\n    return d1;\n}\n\nvec3 opI2( vec3 d1, vec3 d2 ) {\n \tif (d1.x > d2.x) return d1;\n    return d2;\n}\n\n// Maximum/minumum elements of a vector\nfloat vmax(vec2 v) {\n\treturn max(v.x, v.y);\n}\n\nfloat vmax(vec3 v) {\n\treturn max(max(v.x, v.y), v.z);\n}\n\nfloat vmax(vec4 v) {\n\treturn max(max(v.x, v.y), max(v.z, v.w));\n}\n\n// Sign function that doesn't return 0\nfloat sgn(float x) {\n\treturn (x<0.)?-1.:1.;\n}\n\nvec2 sgn(vec2 v) {\n\treturn vec2((v.x<0.)?-1.:1., (v.y<0.)?-1.:1.);\n}\n\n\n// Repeat space along one axis. Use like this to repeat along the x axis:\n// <float cell = pMod1(p.x,5);> - using the return value is optional.\nfloat pMod1(inout float p, float size) {\n\tfloat halfsize = size*0.5;\n\tfloat c = floor((p + halfsize)/size);\n\tp = mod(p + halfsize, size) - halfsize;\n\treturn c;\n}\n\n\n// Repeat in two dimensions\nvec2 pMod2(inout vec2 p, vec2 size) {\n\tvec2 c = floor((p + size*0.5)/size);\n\tp = mod(p + size*0.5,size) - size*0.5;\n\treturn c;\n}\n// Repeat around the origin by a fixed angle.\n// For easier use, num of repetitions is use to specify the angle.\nfloat pModPolar(inout vec2 p, float repetitions) {\n\tfloat angle = 2.*PI/repetitions;\n\tfloat a = atan(p.y, p.x) + angle/2.;\n\tfloat r = length(p);\n\tfloat c = floor(a/angle);\n\ta = mod(a,angle) - angle/2.;\n\tp = vec2(cos(a), sin(a))*r;\n\t// For an odd number of repetitions, fix cell index of the cell in -x direction\n\t// (cell index would be e.g. -5 and 5 in the two halves of the cell):\n\tif (abs(c) >= (repetitions/2.)) c = abs(c);\n\treturn c;\n}\n\n// Mirror at an axis-aligned plane which is at a specified distance <dist> from the origin.\nfloat pMirror (inout float p, float dist) {\n\tfloat s = sgn(p);\n\tp = abs(p)-dist;\n\treturn s;\n}\n\nvec2 pMirrorOctant (inout vec2 p, vec2 dist) {\n\tvec2 s = sgn(p);\n\tpMirror(p.x, dist.x);\n\tpMirror(p.y, dist.y);\n\tif (p.y > p.x)\n\t\tp.xy = p.yx;\n\treturn s;\n}\n// Box: correct distance to corners\nfloat fBox(vec3 p, vec3 b) {\n\tvec3 d = abs(p) - b;\n\treturn length(max(d, vec3(0))) + vmax(min(d, vec3(0)));\n}\n\n// Same as above, but in two dimensions (an endless box)\nfloat fBox2Cheap(vec2 p, vec2 b) {\n\treturn vmax(abs(p)-b);\n}\n\nfloat fCross(vec3 p, vec3 size) {\n    float obj = fBox(p, size);\n    obj = opU2(obj, fBox(p, size.zxy));\n    obj = opU2(obj, fBox(p, size.yzx));\n               \n               return obj;\n}\n\n\nfloat fSphere(vec3 p, float r) {\n\treturn length(p) - r;\n}\n\n\ngeometry map(vec3 p) {\n    //p.y += sin(t * 1.+ p.z / 10.) * 3. + sin(p.x / 3.);\n    vec3 bp = p;\n    vec3 fp = p;\n    vec3 op = p;\n    float localNoise = B(p / 15.) * 5.;\n    \n    \n    p.y -= localNoise;\n    \n    // ----------\n    geometry box;\n    \n    \n    bp.y += -23.;\n    bp.z += -10. - t * 20.;\n    \n    pR(bp.xz, t);\n    pR(bp.yx, t * 4.6);\n    \n    pModPolar(bp.xy, 3.);\n    pMirrorOctant(bp.xz, vec2(.3) + sin(t / 4.) / 2.);\n    bp.x *= 1.4;\n    \n    box.dist = fBox(bp, vec3(4., 9., 1.) * .6 + vol);\n    box.dist = mix(box.dist, fSphere(bp, 2. + localNoise * .4), 1. - min(vol + t * 0.01, 1.));\n    box.materialIndex = 4.;\n   // box.space = bp;\n    box.color = vec3(1.7) + sin(t * 14.);\n    box.diffuse = 2.;\n    box.specular = 4.;\n    box.mirror = .6;\n    \n    \n\t// ------------\n    geometry floor;\n\n    vec3 floorP = p;\n    \n    floorP.y += -5. - min(floorP.z * 0.005 , 5.) - sin(p.z * 0.01) * 3.;\n    floor.dist = fBox2Cheap(floorP.xy, vec2(128., 2.5)),\n    floor.materialIndex = 0.;\n    //floor.space = p;\n    floor.color = vec3(1., .8, .6);//* localNoise;\n    floor.diffuse = 8.;\n    floor.specular = 4.0;\n    floor.mirror = 0.;\n    \n    // ------------\n    geometry water;\n    \n    fp = op;\n    fp.y -= 11. ;//+ sin(localNoise * 0.3) * 0.2 + 0.1 * (sin(fp.z + localNoise) + sin(fp.x));\n    water.dist = fBox2Cheap(fp.xy, vec2(128., 3.)),\n    water.materialIndex = 5.;\n    //water.space = fp;\n    water.color = fromRGB(126, 165, 179);\n    water.diffuse = 2.;\n    water.specular = 17.;\n    water.mirror = 0.3;\n    \n    // ----------\n    geometry obj;\n    \n    p.xz -= 25.;\n    p.y += 140. - min(p.z / 4., 140.);\n    \n    vec2 pM = pMod2(p.xz, vec2(50.));\n    \n    pMirrorOctant(p.zy, \n                  vec2(\n                      1. * mod(pM.x, 14.), \n                      5. + ceil(13. * (sin(pM.x) * 3.+ 1.)) \n                  )\n                 );\n    pMirrorOctant(p.xz, vec2(13., 18. + mod(pM.y * 5., 16.)));\n    \n    pR(p.zy, 1.17 + p.x / 10. );\n\n    p.x += 2.5 ;\n    \n    pModPolar(p.xz, 12.5 - (sin(pM.x) * 10.+ (sin(1. / 3.) * 10.)));\n\t\n    pMirrorOctant(p.zy, vec2(8.4, 6.));\n    pMirrorOctant(p.xy, vec2(3.5, 5.));\n    \n    p.yx += 2.;\n    // \n    // \n    p.x += sin(p.z / 100.) * 40.;\n    \n    obj.dist = fBox2Cheap(p.xy, vec2(4.4, 2.5));\n    obj.color = vec3(0., 1., 0.);\n    //obj.space = p;\n    obj.color = vec3(1.);\n    obj.diffuse = 5.;\n    obj.specular = 0.2;\n    obj.mirror = 0.;\n    //p.z -= 3.;\n    \n    geometry obj2;\n    obj2.dist = fBox(p, vec3(6., 7.4, 1.3));\n    obj2.color = vec3(1., 0., 1.);\n    //obj2.space = p;\n    obj2.color = vec3(1.);\n    obj2.diffuse = 8.;\n    obj2.specular = 1.;\n    obj2.mirror = 0.;\n    obj2.dist = smin(obj.dist, obj2.dist, sin(p.z / 10.) / 3. + .5);\n    \n    floor.dist = smin(obj.dist, floor.dist, .45);\n    \n    p = op;\n    p.x -= 2.;\n\n    p = mod(p, 5.);// p.z = mod(p.z, 12.) - .1;//sin(p.z);\n    p.y -= 25.;\n    //;;p.z -= 100.;\n    geometry obj3;\n    obj3.dist = fBox(p, vec3(3., 7.4,1.3));\n    obj3.color = vec3(1., 0., 1.);\n    //obj3.space = p;\n    obj3.color = vec3(1.);\n    obj3.diffuse = 8.;\n    obj3.specular = 1.;\n    obj3.mirror = 0.;\n    \n    obj = geoU(obj, obj2);\n    obj = geoU(obj, obj3);\n    obj = geoU(obj, floor);\n    obj = geoU(obj, water);\n    obj = geoU(obj, box);\n    \n    \n    //-----\n    p = op;\n    p.y -= 5.;\n    p.xz = mod(p.xz, 40.) - 20.;\n    if (op.z > 1030.) {\n        p.x += p.z * 0.1;\n    pMirrorOctant(p.yz, vec2(12.5, 20.));\n    pModPolar(p.zx, 5.);\n\n    obj2.dist = fBox(p, vec3(1., 15., 6.));\n    obj2.mirror = .2;\n    obj2.color = vec3(1., 0., 1.);\n    \n    obj2.color += ceil(sin(mod(op.x / 3. + op.z / 2.- t * 4., 5.))) * 4.;\n    obj2.specular = 3.;\n    \n    obj = geoU(obj, obj2);\n    }\n    return obj;\n}\n\n\nfloat t_min = 0.001;\nfloat t_max = FAR;\nconst int MAX_ITERATIONS = 70;\n\ngeometry trace(vec3 o, vec3 d, int maxI) {\n\n    float omega = 1.3;\n    float t = t_min;\n    float candidate_error = INFINITY;\n    float candidate_t = t_min;\n    float previousRadius = 0.;\n    float stepLength = 0.;\n    float pixelRadius = 1. / 250.;\n    float functionSign = map(o).dist < 0. ? -1. : +1.;\n    geometry mp;\n    \n    for (int i = 0; i < MAX_ITERATIONS; ++i) {\n        if (maxI > 0 && i > maxI) break; \n        mp = map(d * t + o);\n        float signedRadius = functionSign * mp.dist;\n        float radius = abs(signedRadius);\n        bool sorFail = omega > 1. &&\n        (radius + previousRadius) < stepLength;\n        if (sorFail) {\n            stepLength -= omega * stepLength;\n            omega = 1.;\n        } else {\n        stepLength = signedRadius * omega;\n        }\n        previousRadius = radius;\n        float error = radius / t;\n        if (!sorFail && error < candidate_error) {\n            candidate_t = t;\n            candidate_error = error;\n        }\n        if (!sorFail && error < pixelRadius || t > t_max) break;\n        t += stepLength;\n   \t}\n    \n    mp.dist = candidate_t;\n    \n    if (\n        (t > t_max || candidate_error > pixelRadius)\n    \t) mp.dist = INFINITY;\n    \n    \n    return mp;\n}\n\n\nfloat softShadow(vec3 ro, vec3 lp, float k) {\n    const int maxIterationsShad = 8;\n    vec3 rd = (lp - ro); // Unnormalized direction ray.\n\n    float shade = 1.;\n    float dist = 4.5;\n    float end = max(length(rd), .01);\n    float stepDist = end / float(maxIterationsShad);\n\n    rd /= end;\n    for (int i = 0; i < maxIterationsShad; i++) {\n        float h = map(ro + rd * dist).dist;\n        //shade = min(shade, k*h/dist);\n        shade = min(shade, smoothstep(0.0, 1.0, k * h / dist)); \n        dist += min(h, stepDist * 2.); \n        if (h < 0.001 || dist > end) break;\n    }\n    return min(max(shade, 0.6), 1.0);\n}\n\n\nvec3 getNormalHex(vec3 pos)\n{\n\tfloat d=map(pos).dist, e = .001;\n\treturn normalize(\n        vec3(\n            map(\n                pos+vec3(e,0,0)).dist-d,\n                map(pos+vec3(0,e,0)).dist-d,\n                map(pos+vec3(0,0,e)).dist-d \n        \t)\n    \t);\n}\n\nfloat getAO(vec3 hitp, vec3 normal, float dist)\n{\n    return clamp(map(hitp + normal * dist).dist / dist, .4, 1.);\n}\n\nvec3 clouds(vec3 rd, vec3 ro) {\n    vec2 uv = rd.xz / rd.y;\n   //ro.z /= 2.;\n    vec3 clouds = vec3(\n        B(\n            vec3(\n                uv + vec2(0., ro.z  * .01), 9.\n            )\n        ) * 1.6\n\n    );\n \tclouds = pow(clouds, vec3(2.)) + vec3(sin(uv.y) / 2. + .5, .5, 0.);\n    clouds.b += sin(ro.z * 0.01);\n    return clouds * max(0., rd.y);\n}\n\n\nvec3 Sky(in vec3 rd, bool showSun, vec3 lightDir, vec3 ro)\n{\n   \n    float sunSize = 3.5;\n    float sunAmount = max(dot(rd, lightDir), 0.4);\n    float v = pow(1.2 - max(rd.y, 0.0), 1.1);\n    vec3 cl = vec3(0.);//fromRGB(0,136,254);\n    //cl.b *= sin(p.z * 0.3);\n    vec3 sky = mix(cl, vec3(.1, .2, .3) * 1., v);\n \n    sky += lightColour * sunAmount * sunAmount * 1. + lightColour * min(pow(sunAmount, 122.0)* sunSize, 0.2 * sunSize);\n    sky += vec3(3., 0., 0.) * rd.y;\n    return clamp(sky, 0.0, 1.0) + clouds(rd, ro);;\n}\n\nvec3 doColor( in vec3 sp, in vec3 rd, in vec3 sn, in vec3 lp, geometry obj) {\n\tvec3 sceneCol = vec3(.0);\n    lp = sp + lp;\n    vec3 ld = lp - sp; // Light direction vector.\n    float lDist = max(length(ld / 2.), 0.001); // Light to surface distance.\n    ld /= lDist; // Normalizing the light vector.\n\n    // Attenuating the light, based on distance.\n    float atten = 1. / (1.0 + lDist * 0.025 + lDist * lDist * 0.2);\n\n    // Standard diffuse term.\n    float diff = max(dot(sn, ld), obj.diffuse);\n    // Standard specualr term.\n    float spec = max(dot(reflect(-ld, sn), -rd), obj.specular / 2.);\n\n    \n    // Coloring the object. You could set it to a single color, to\n    // make things simpler, if you wanted.\n    vec3 objCol = obj.color;//getObjectColor(sp, sn, obj);\n\n    // Combining the above terms to produce the final scene color.\n    //sceneCol += ();// * atten;\n\n    // Return the color. Done once every pass... of which there are\n    // only two, in this particular instance.\n    \n    return objCol * (diff + .15) * spec * .1;\n}\n\n\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  \n    F \tmat = 0.,\n        camShY = 0.;\n    \n    vec2 uv = fragCoord.xy / iResolution.xy - .5;\n   \n    if (abs(uv.y) > .35) {\n     \tfragColor *= 0.;\n        return;\n    }\n    \n    uv *= 4.;\n    \n    light = vec3(0., 77., 100.);        \n    \n    vec3 \n        vuv = vec3(cos(t) / 6., 1., sin(t) * .3 ), // up\n    \tro = vec3(-2. + sin(t),  22. + camShY, t * 20.);// + vec3(iMouse.x / 20.,iMouse.y / 10. - 1., 1.); // pos\n    \n    //ro.z += camShY;\n    vec3\n        vrp =  vec3(sin(t), + sin(t * 2.), +11.) + ro + \n        \tvec3(\n                -2., \n                -4. + sin(t) / 3., \n                0. + sin(t / 3.) / 4.), // lookat    */\n\t\t\n    \tvpn = normalize(vrp - ro),\n    \tu = normalize(cross(vuv, vpn)),\n    \trd = normalize(\n            vpn + uv.x * u * iResolution.x/iResolution.y + uv.y * cross(vpn, u)\n        ),\n        hit,\n        ord = rd;\n\t\n    vec3 sceneColor = vec3(0.);\n    \n    geometry tr = trace(ro, rd, 0);    \n    \n    //float fog = smoothstep(FAR * FOG, 0., tr.dist) * 1.;\n    hit = ro + rd * tr.dist;\n    \n    vec3 sn = getNormal(hit);\t\n    \n    float sh = softShadow(hit, hit + light, 3.);\n    \n    float \n        ao = getAO(hit, sn, .2);\n\t\n    ao *= saturate(getAO(hit + sn * .2, sn, .5));\n    ao *= saturate(getAO(hit + sn * 1., sn, 3.0));\n    \n\tvec3 sky = Sky(rd, true, normalize(light), ro) * 1.;\n    \n    if (tr.dist < FAR) { \n        sceneColor = (doColor(hit, rd, sn, light, tr) * 1.) * 1.;\n        sceneColor *= ao; \n        sceneColor *= sh;\n        sceneColor = mix(sceneColor, sky, saturate(tr.dist * 4. / FAR));\n        sceneColor = mix(sceneColor, lightColour, 0.1);        \n\n        if (tr.mirror > 0.) {   \n            float mirror = tr.mirror;\n            vec3 refSceneColor = sceneColor;\n            rd = reflect(rd, sn);// + sin(t));\n\n            tr = trace(hit + rd * .02, rd, 99);\n            if (tr.dist < FAR) {\n                hit = hit + rd * tr.dist;\n                sn = getNormal(hit);\n                refSceneColor = mix(sceneColor, abs(doColor(hit, rd, sn, light, tr)), mirror);                \n            } else {\n             \tsky = Sky(rd, true, normalize(light), ro);\n                refSceneColor = mix(refSceneColor, sky, mirror * 2.);\n               \n            }\n            \n            sceneColor = mix(sceneColor, refSceneColor, mirror);\n            \n        } else {\n            sceneColor = mix(sceneColor, sky, .0);  \n        }\n\n    } else {\n        sceneColor = sky;\n    }\n\n    if (t < 20.) {\n        float ot = min(t, 20.),den1 = 0., f, distC = 1.0;\n            \n        vec3 steamColor1 = vec3(1.4);\n\n        vec3 rro;\n        \n        ro.z /= 8.;\n\n        for (float i = 0.; i <= 10.; i++) {\n\n            rro = ro + ord * distC;// + steamColor2;\n\n            f = B(rro);\n            f *= 1.8;\n            den1 += pow(f, 2.) * .004 * (20. - ot) / 3.;\n\n\n            distC += .01;\n            if (distC > tr.dist) break;// ro += rd * distC;\n        }\n\n        sceneColor = mix(sceneColor, steamColor1,  clamp(den1, 0., 1.) * 2.); \n    \n    }\n    \n    fragColor = vec4(clamp(sceneColor * (1. - length(uv) / 3.5), 0.0, 1.0), 1.0);\n    fragColor = pow(fragColor, vec4(1.2));    \n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/Xlc3zB.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "Xs2GDz", "name": "No Idea", "author": "pix", "description": "No Idea", "tags": ["raymarching", "tutorial"], "likes": 1, "viewed": 27, "date": "1619549923", "time_retrieved": "2024-06-20T20:39:18.314255", "image_code": "#define PI 3.141592\n\nmat3 lookAt(vec3 p, vec3 t) {\n\tvec3 f = normalize(p - t);\n\tvec3 r = cross(vec3(0.0,1.0,0.0), f);\n\treturn mat3(r, cross(f, r), f);\n}\n\nfloat dist_field(vec3 p) {\n\treturn length(p)+sin(iTime/20.);\n}\n\n#define EPS 0.01\nvec4 raymarch(vec3 ro, vec3 rd) {\n\tfloat d = 0.0, h = 0.0, maxd = 16.0;\n\tvec3 p = ro;\n\tfor (int i = 0; i < 64; ++i) {\n\t\td = dist_field(p);\n\t\tif (d < EPS || h > maxd)\n\t\t\tbreak; // return vec4(point,distance)\n\t\th += d; p += d * rd;\n\t}\n\treturn vec4(p, d);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = -01.0+2.0*fragCoord.xy/iResolution.xy;\n\tuv.y *= iResolution.y/iResolution.x;\n\t\n\tfloat stime = sin(2.1*PI*iTime/25.0);\n\tfloat ctime = cos(2.0*PI*iTime/25.0);\n\t\n\tvec3 ro = vec3(4.0*ctime, 3.0, 4.0*stime);\n\tvec3 rd = normalize(lookAt(ro, vec3(0.0,0.6,0.0))*vec3(uv, -1.0));\n\t\n\tvec4 res = raymarch(ro, rd);\n\n\tvec3 col = vec3(res.z, sin(res.z), sin(rd*4.));\t\n\tfragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/Xs2GDz.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
