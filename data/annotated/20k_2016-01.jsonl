{"id": "4dc3Rl", "name": "Cellquilt", "author": "narobins", "description": "voronoi cell division", "tags": ["voronoi", "test", "cellnoise"], "likes": 8, "viewed": 144, "date": "1451671476", "time_retrieved": "2024-06-20T18:29:41.190184", "image_code": "//* Click to set zoom center *//\n\n\nconst vec4 c1 = vec4(0.3, 0.2, 0.7, 1.0); // top left\nconst vec4 c2 = vec4(0.3, 0.1, 0.2, 1.0); // top right\nconst vec4 c3 = vec4(0.8, 0.3, 0.0, 1.0); // bottom right\nconst vec4 c4 = vec4(0.6, 0.7, 0.9, 1.0); // bottom left\n\nconst float shadowStrength = 0.7;\nconst float shadowAmp1 = 8.0; // distance from center of cell\nconst float shadowAmp2 = 3.0; // distance from center of second-closest cell\n\nconst vec2 sections = vec2(4.0, 2.5);\nconst float zs = 0.5; // zoom speed\nconst float za = 2.0; // zoom amount\n\nconst bool drawpts = false;\n\nfloat rand(vec2 co);\nvec2 findPt(vec2 coord);\nvec4 closestPt(vec2 coord);\nvec2 unNorm(vec2 co);\nvec4 lerpColor(vec2 c);\nvec4 randomColor();\nvec2 getTransform();\nvec2 transformCoords(vec2 co);\nvec2 unTransformCoords(vec2 co);\nvec2 getCenter();\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = transformCoords(fragCoord.xy / iResolution.xy);\n    vec2 id = floor(uv);\n    \n    vec4 pt = closestPt(uv.xy);\n    vec2 p1 = unTransformCoords(pt.xy);\n    vec2 p2 = unTransformCoords(pt.zw);\n\n    fragColor = lerpColor(p1) * vec4(0.8, 1.5, 0.9, 1.0);\n    \n    float res = iResolution.x / getTransform().x;\n    vec4 shadow = vec4(1.0) \n        - vec4(shadowStrength) *  \n        (shadowAmp1 * distance(unNorm(p1), fragCoord.xy) - \n        shadowAmp2 * distance(unNorm(p2), fragCoord.xy)) / res;\n\tfragColor *= shadow;\n    \n    if (drawpts && distance(unNorm(p1), unNorm(fragCoord.xy / iResolution.xy)) < 0.9) {\n     \tfragColor = vec4(1.0);   \n    }\n}\n\nvec2 getCenter()\n{\n    return iMouse.xy / iResolution.xy;\n}\n\nvec4 closestPt(vec2 co)\n{\n    vec2 pt1 = vec2(-1000.0, -1000.0);\n    vec2 pt2 = vec2(-1000.0, -1000.0);\n    vec2 pt;\n\n    vec2 id = floor(co * sections);\n\n    const int min = -1;\n    const int max = 1;\n    float dist;\n    \n    for (int xi = min; xi <= max; xi++) {\n        for (int yi = min; yi <= max; yi++) {\n            pt = (findPt(id + vec2(float(xi), float(yi)))) / sections;\n            dist = distance(unNorm(pt), unNorm(co));\n            if (dist < distance(unNorm(pt1), unNorm(co))) {\n\t\t\t\tpt2 = pt1;             \n                pt1 = pt;\n            } else if (dist < distance(unNorm(pt2), unNorm(co))) {\n            \tpt2 = pt;\n            }\n        }\n    }\n    return vec4(pt1.xy, pt2.xy);\n}\n\nvec2 getTransform()\n{\n    return vec2(1.0 + za * \n             (sin(float(iTime) * zs) / 2.0 + 0.5));\n}\n\nvec2 transformCoords(vec2 co)\n{\n    vec2 ctr = getCenter();\n    return (co - ctr) * \n        getTransform()\n        + ctr;\n}\n\nvec2 unTransformCoords(vec2 co)\n{\n    vec2 ctr = getCenter();\n    return (co - ctr) / \n\t\tgetTransform()\n        + ctr;\n}\n\nvec2 unNorm(vec2 co)\n{\n \treturn co * iResolution.xy; \n}\n\nfloat rand(vec2 co){\n    return fract(sin(dot(co.xy, vec2(12.9898,78.233))) * 43758.5453);\n}\n\nvec2 findPt(vec2 coord)\n{\n \treturn coord + vec2(rand(coord), rand(coord + vec2(1.0, 1.0)));     \n}\n\nvec4 lerpColor(vec2 c)\n{\n \treturn (1.0 - c.x) * (c.y * c1 + (1.0 - c.y) * c4) +\n    \t   c.x * (c.y * c2 + (1.0 - c.y) * c3); \n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4dc3Rl.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "4dc3W2", "name": "Untitled 04", "author": "floz", "description": "Untitled 04 - \nWeek1 - Shader everyday (style)", "tags": ["raymarching", "landscape", "morphing", "surrealist"], "likes": 12, "viewed": 343, "date": "1452156801", "time_retrieved": "2024-06-20T18:29:43.511629", "image_code": "#define PI 3.141592654\n#define EPSILON 0.0000001\n#define AMPLITUDE 0.52\n#define SPEED 0.05\n\n//------------------------------------------------------------------ VISUAL QUALITY\n#define RAYMARCHING_STEP 65\n#define RAYMARCHING_JUMP 1.\n\n//------------------------------------------------------------------ DEBUG\n//#define RENDER_DEPTH\n//#define RENDER_NORMAL\n//#define RENDER_AO\n\n//------------------- FORMULAS/MAGIC\n\nvec4 vec4pow( in vec4 v, in float p ) {\n    // Don't touch alpha (w), we use it to choose the direction of the shift\n    // and we don't want it to go in one direction more often than the other\n    return vec4(pow(v.x,p),pow(v.y,p),pow(v.z,p),v.w); \n}\n\nvec4 permute(vec4 x){return mod(x*x*34.0+x,289.);}\n\nfloat snoise(vec3 v){\n  const vec2  C = vec2(0.166666667, 0.33333333333) ;\n  const vec4  D = vec4(0.0, 0.5, 1.0, 2.0);\n  vec3 i  = floor(v + dot(v, C.yyy) );\n  vec3 x0 = v - i + dot(i, C.xxx) ;\n  vec3 g = step(x0.yzx, x0.xyz);\n  vec3 l = 1.0 - g;\n  vec3 i1 = min( g.xyz, l.zxy );\n  vec3 i2 = max( g.xyz, l.zxy );\n  vec3 x1 = x0 - i1 + C.xxx;\n  vec3 x2 = x0 - i2 + C.yyy;\n  vec3 x3 = x0 - D.yyy;\n  i = mod(i,289.);\n  vec4 p = permute( permute( permute(\n\t  i.z + vec4(0.0, i1.z, i2.z, 1.0 ))\n\t+ i.y + vec4(0.0, i1.y, i2.y, 1.0 ))\n\t+ i.x + vec4(0.0, i1.x, i2.x, 1.0 ));\n  vec3 ns = 0.142857142857 * D.wyz - D.xzx;\n  vec4 j = p - 49.0 * floor(p * ns.z * ns.z);\n  vec4 x_ = floor(j * ns.z);\n  vec4 x = x_ *ns.x + ns.yyyy;\n  vec4 y = floor(j - 7.0 * x_ ) *ns.x + ns.yyyy;\n  vec4 h = 1.0 - abs(x) - abs(y);\n  vec4 b0 = vec4( x.xy, y.xy );\n  vec4 b1 = vec4( x.zw, y.zw );\n  vec4 s0 = floor(b0)*2.0 + 1.0;\n  vec4 s1 = floor(b1)*2.0 + 1.0;\n  vec4 sh = -step(h, vec4(0.0));\n  vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy ;\n  vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww ;\n  vec3 p0 = vec3(a0.xy,h.x);\n  vec3 p1 = vec3(a0.zw,h.y);\n  vec3 p2 = vec3(a1.xy,h.z);\n  vec3 p3 = vec3(a1.zw,h.w);\n  vec4 norm = inversesqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));\n  p0 *= norm.x;\n  p1 *= norm.y;\n  p2 *= norm.z;\n  p3 *= norm.w;\n  vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n  m = m * m * m;\n  return .5 + 12.0 * dot( m, vec4( dot(p0,x0), dot(p1,x1),dot(p2,x2), dot(p3,x3) ) );\n}\n\n// Maximum/minumum elements of a vector\nfloat vmax(vec2 v) {\n\treturn max(v.x, v.y);\n}\n\nfloat vmax(vec3 v) {\n\treturn max(max(v.x, v.y), v.z);\n}\n\nfloat vmax(vec4 v) {\n\treturn max(max(v.x, v.y), max(v.z, v.w));\n}\n\nfloat hash( float n ){//->0:1\n\treturn fract(sin(n)*3538.5453);\n}\n\nfloat smin( float a, float b )\n{\n    float k = .1;\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\nfloat displacement( vec3 p, float v ) {\n  float f = iTime * -0.5 + sin( iTime * 2. ) * 1.4;\n  return sin( 20. * sin( cos( f ) ) *p.x)*sin( 10. *sin( cos( f ) ) *p.y)*sin( 30. * sin( cos( f ) ) *p.z);\n}\n\n// Repeat around the origin by a fixed angle.\n// For easier use, num of repetitions is use to specify the angle.\nfloat pModPolar(inout vec2 p, float repetitions) {\n\tfloat angle = 2.*PI/repetitions;\n\tfloat a = atan(p.y+0.0000001, p.x+0.0000001) + angle/2.;\n\tfloat r = length(p);\n\tfloat c = floor(a/angle);\n\ta = mod(a,angle) - angle/2.;\n\tp = vec2(cos(a), sin(a))*r + 0.0000001;\n\t// For an odd number of repetitions, fix cell index of the cell in -x direction\n\t// (cell index would be e.g. -5 and 5 in the two halves of the cell):\n\tif (abs(c) >= (repetitions/2.)) c = abs(c);\n\treturn c;\n}\n\n// Repeat space along one axis. Use like this to repeat along the x axis:\n// <float cell = pMod1(p.x,5);> - using the return value is optional.\nfloat pMod1(inout float p, float size) {\n\tfloat halfsize = size*0.5;\n\tfloat c = floor((p + halfsize)/size);\n\tp = mod(p + halfsize, size) - halfsize;\n\treturn c;\n}\n\nvec2 pMod2(inout vec2 p, vec2 size) {\n\tvec2 c = floor((p + size*0.5)/size);\n\tp = mod(p + size*0.5,size) - size*0.5;\n\treturn c;\n}\n\nfloat opS( float d1, float d2 )\n{\n    return max(-d1,d2);\n}\n\nfloat opU( float d1, float d2 )\n{\n    return min(d1,d2);\n}\n\nvec3 postEffects( in vec3 col, in vec2 uv, in float time )\n{    \n\t// vigneting\n    col *= .9 + .2 * snoise( vec3( sin( iTime + uv.x ), cos( iTime + uv.y ), 0. ) );\n\tcol *= 0.4+0.6*pow( 16.0*uv.x*uv.y*(1.0-uv.x)*(1.0-uv.y), 0.5 );\n    col += col * .1 * snoise( vec3( -uv.x * 400., uv.y * 400. , iTime * 2. ) );\n    \n    return col;\n}\n\n//------------------- CAMERA STUFF\n\nvec3 orbit(float phi, float theta, float radius)\n{\n\treturn vec3(\n\t\tradius * sin( phi ) * cos( theta ),\n\t\tradius * cos( phi ),\n\t\tradius * sin( phi ) * sin( theta )\n\t);\n}\n\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr )\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n\treturn mat3( cu, cv, cw );\n}\n\n//------------------- PRIMITIVES\n\nvec2 rotate2D(vec2 p, float a) {\n return p * mat2(cos(a), -sin(a), sin(a),  cos(a));\n}\n\nfloat pyramid( vec3 p, float h) {\n\tvec3 q=abs(p);\n\treturn max(-p.y, (q.x*1.5+q.y *.75+q.z*1.5-h)/3.0 );\n}\n\nfloat sphere( vec3 p, float r ) {\n\treturn length( p ) - r;\n}\n\n// Box: correct distance to corners\nfloat fBox(vec3 p, vec3 b) {\n\tvec3 d = abs(p) - b;\n\treturn length(max(d, vec3(0))) + vmax(min(d, vec3(0)));\n}\n\nfloat dot2( in vec3 v ) { return dot(v,v); }\nfloat udTriangle( vec3 p, vec3 a, vec3 b, vec3 c )\n{\n    vec3 ba = b - a; vec3 pa = p - a;\n    vec3 cb = c - b; vec3 pb = p - b;\n    vec3 ac = a - c; vec3 pc = p - c;\n    vec3 nor = cross( ba, ac );\n\n    return sqrt(\n    (sign(dot(cross(ba,nor),pa)) +\n     sign(dot(cross(cb,nor),pb)) +\n     sign(dot(cross(ac,nor),pc))<2.0)\n     ?\n     min( min(\n     dot2(ba*clamp(dot(ba,pa)/dot2(ba),0.0,1.0)-pa),\n     dot2(cb*clamp(dot(cb,pb)/dot2(cb),0.0,1.0)-pb) ),\n     dot2(ac*clamp(dot(ac,pc)/dot2(ac),0.0,1.0)-pc) )\n     :\n     dot(nor,pa)*dot(nor,pa)/dot2(nor) );\n}\n\n\n//------------------- MAP\n\nfloat map( in vec3 p ) {\n    vec3 np = vec3( p.x, p.y + .5, p.z );\n    vec3 q1 = np;\n    \n    //q1.xy = rotate2D( q1.xy, cos( iTime * -0.5 + p.y ) + sin( iTime * 2. + p.x ) * 0.4 );\n    float p1 = pyramid( q1, 3. );\n    \n    vec3 q2 = np;\n    q2.z += .05;\n    float p2 = pyramid( q2, 3. );\n    \n    float r = opS( p1, p2 );\n    \n    q1.y += -.065;\n    q1.z += -.085;\n    p1 = pyramid( q1, 2.5 );\n    \n    r = opU( r, p1 );\n    \n    vec3 pSph = np;\n    pSph.y -= 1.95;\n    float sphA = sphere( pSph, 3. );\n    pSph.z += 1.5;\n    float sphB = sphere( pSph, 2.5 );\n    float sph = opS( sphA, sphB );\n    pSph.y += -.5;\n    pSph.z += 2.05;\n    sphB = sphere( pSph, 2.5 );\n    sph = opS( sphB, sph );\n    \n    //r = sph;\n    //r = opU( r, sph );\n    r = smin( r, sph );\n    \n    float f = p.y - .4;\n    //r = opU( r, f );\n    \n    float k = 1.15;\n    float h = clamp( 0.5 + 0.5 * ( r - f ) / k, 0.0, 1.0 );\n    \n    r = mix( r, f, h ) - k*h*( 1.0 - h );\n    \n    k = 1.5;\n    h = clamp( 0.5 + 0.5 * ( r - f ) / k, 0.0, 1.0 );\n    r = mix( r, sph, h ) - k*h*( 1.0 - h );\n    \n    k = 0.5;\n    f = p.y - .4;\n    r = mix( r, f, h ) - k*h*( 1.0 - h );\n    r = mix( r, f, h ) - k*h*( 1.0 - h );\n    \n    q1 = np;\n    q1.x -= 2.25;\n    q1.y -= 3.0 - cos( iTime ) * .5;   \n    q1.xz = rotate2D(q1.xz, iTime * 2. + sin(iTime * 2. - p.x ) * 2.);\n    q1.xy = rotate2D(q1.xy, PI);\n    p1 = pyramid( q1, .25 );\n    q1 = np;\n    q1.x -= 2.25;\n    q1.y -= 3.0 - cos( iTime ) * .5;   \n    q1.xz = rotate2D(q1.xz, iTime * 2. + sin(iTime * 2. - p.x ) * 2.);\n    p2 = pyramid( q1, .25 );\n    float pr = opU( p1, p2 );\n    r = opU( r, pr );\n    \n    q1 = np;\n    q1.x += 2.25;\n    q1.y -= 3.0 - sin( iTime + .2 ) * .5;   \n    q1.xz = rotate2D(q1.xz, iTime * 2. + sin(iTime * 2. + p.x ) * 2.);\n    q1.xy = rotate2D(q1.xy, PI);\n    p1 = pyramid( q1, .25 );\n    q1 = np;\n    q1.x += 2.25;\n    q1.y -= 3.0 - sin( iTime + .2 ) * .5;   \n    q1.xz = rotate2D(q1.xz, iTime * 2. + sin(iTime * 2. + p.x ) * 2.);\n    p2 = pyramid( q1, .25 );\n    pr = opU( p1, p2 );\n    r = opU( r, pr );\n    \n    q1 = np;\n    vec2 idx = pMod2( q1.xz, vec2( 1.5, 1.5 ) );\n    q1.y +=  .5 * ( sin( idx.y ) * cos( idx.x * .5 ) );\n    q1.xz = rotate2D(q1.xz, cos( idx.x ) * 2. + sin( idx.y ) * 2. );\n    p1 = pyramid( q1, 1.25 );\n    //r = opU( r, p1 );\n    \n    k = 0.25;\n    h = clamp( 0.5 + 0.5 * ( r - p1 ) / k, 0.0, 1.0 );\n    r = mix( r, p1, h ) - k*h*( 1.0 - h );\n    //r = mix( r, f, h ) - k*h*( 1.0 - h );\n    \n    \n    return r;\n}\n\n//------------------- RAYMARCHING\n\n#ifdef RENDER_DEPTH\nfloat castRay( in vec3 ro, in vec3 rd, inout float depth ) {\n#else\nfloat castRay( in vec3 ro, in vec3 rd ) {\n#endif\n    float t = 0.;\n    float res;\n    for( int i = 0; i < RAYMARCHING_STEP; i++ ) {\n        vec3 pos = ro + rd * t;\n        res = map( pos );\n        if( res < .01 || t > 100. ) break;\n        t += res * RAYMARCHING_JUMP;\n        #ifdef RENDER_DEPTH\n\t\tdepth += 1./float(RAYMARCHING_STEP);\n\t\t#endif\n    }\n    return t;\n}\n\nvec3 calcNormal(vec3 pos) {\n    float eps = 0.001;\n\tconst vec3 v1 = vec3( 1.0,-1.0,-1.0);\n\tconst vec3 v2 = vec3(-1.0,-1.0, 1.0);\n\tconst vec3 v3 = vec3(-1.0, 1.0,-1.0);\n\tconst vec3 v4 = vec3( 1.0, 1.0, 1.0);\n\treturn normalize( v1 * map( pos + v1*eps ) +\n    \t              v2 * map( pos + v2*eps ) +\n        \t          v3 * map( pos + v3*eps ) +\n            \t      v4 * map( pos + v4*eps ) );\n}\n\nfloat calcAO( in vec3 p, in vec3 n, float maxDist, float falloff ){\n\tfloat ao = 0.0;\n\tconst int nbIte = 6;\n\tfor( int i=0; i<nbIte; i++ )\n\t{\n\t\tfloat l = hash(float(i))*maxDist;\n\t\tvec3 rd = n*l;\n\t\tao += (l - map( p + rd )) / pow(1.+l, falloff);\n\t}\n\treturn clamp( 1.-ao/float(nbIte), 0., 1.);\n}\n\n// calculate local thickness\n// base on AO but : inverse the normale & inverse the color\nfloat thickness( in vec3 p, in vec3 n, float maxDist, float falloff )\n{\n\tfloat ao = 0.0;\n\tconst int nbIte = 6;\n\tfor( int i=0; i<nbIte; i++ )\n\t{\n\t\tfloat l = hash(float(i))*maxDist;\n\t\tvec3 rd = -n*l;\n\t\tao += (l + map( p + rd )) / pow(1.+l, falloff);\n\t}\n\treturn clamp( 1.-ao/float(nbIte), 0., 1.);\n}\n    \nvec3 sundir = normalize( vec3(-1.5,2.,-1.5) );\n\nvec3 addLight( in vec3 posLight, in vec3 colLight, in vec3 nor, in vec3 pos, in vec3 ref, in float radius, in float specRatio ) {\n    float thi = thickness(pos, nor, 6., 1.5);\n    \n    float intens = max( dot( nor, posLight ), 0. );\n    float dist = length( posLight - pos );\n    float att = clamp(1.0 - dist*dist/(radius*radius), 0.0, 1.0);\n    att *= att;\n    float specular = pow( clamp( dot( ref, posLight ), 0., 1.0 ), 16. );\n    vec3 col = colLight * intens * att;\n    col += specular * .5 * att * specRatio * thi;\n    return col;\n}\n    \nvec3 addLight2( in vec3 posLight, in vec3 colLight, in vec3 nor, in vec3 pos, in vec3 ref, in float radius ) {\n    float thi = thickness(pos, nor, 6., 1.5);\n    \n    float intens = max( dot( nor, posLight ), 0. );\n    float dist = length( posLight - pos );\n    float att = clamp(1.0 - dist*dist/(radius*radius), 0.0, 1.0);\n    att *= att;\n    vec3 col = colLight * intens * att;\n    col += .5 * att * thi;\n    return col;\n}   \n    \nvec3 render( in vec3 ro, in vec3 rd, in vec2 uv ) {\n\tvec3 col = vec3( 1., .0, 1. );\n    \n    float sun = clamp( dot(sundir,rd), 0.0, 1.0 );\n    vec3 colBg = vec3(0.0, 0., 0.) - rd.y*0.2*vec3(1., 1., 0.) + 0.15*0.5;\n\tcolBg += 0.2*vec3(1.0,0.,0.1)*pow( sun, 2.0 );\n    //colBg = vec3(cos( uv.y * uv.x ) * .1,cos( uv.y ) * .25,sin( uv.x ) + cos( uv.y ) * .5 ) / 5.;\n    \n    //colBg = vec3( 0.18, 0., 1. );\n    \n    #ifdef RENDER_DEPTH\n\tfloat depth = 0.;\n    float t = castRay( ro, rd, depth );\n    #else\n    float t = castRay( ro, rd );\n    #endif\n    \n    #ifdef RENDER_DEPTH\n    return vec3( depth / 5., depth, depth );\n    #endif\n    \n    vec3 pos = ro + t * rd;\n    vec3 nor = calcNormal( pos );\n    \n    #ifdef RENDER_NORMAL\n    return nor;\n    #endif\n    \n    float ao = calcAO( pos, nor, 10., 1.2 );\n    #ifdef RENDER_AO\n    return vec3( ao );\n    #endif\n    \n    //vec3 light = vec3( 1.5, 1., 1. );\n    \n    vec3 ref = reflect( rd, nor );\n    \n    col = colBg;\n    // top blue light\n    col += addLight( vec3( .3, 5.,1. ), vec3( .498, .898, .952 ), nor, pos, ref, 6., 1. );\n    // right green dark\n    col += addLight( vec3( 4.2, 1.5, 1. ), vec3( 0.06, .407, .27 ), nor, pos, ref, 6.25, 0. );\n    // bottom right blue light\n    col += addLight( vec3( 5., -2., 1.85 ), vec3( 0.082, .443, .541 ), nor, pos, ref, 6., 0. );\n    // bottom left red\n    col += addLight( vec3( -4., 0., 1.85 ), vec3( 0.79, .168, .015 ), nor, pos, ref, 6., 0.25 );\n    \n    col += addLight( vec3( 0., 1.5, 1.5 ), vec3( 1., .0, 0. ), nor, pos, ref, 3.5, 0.5 );\n    \n    col += .35 * addLight( vec3( 0.21, 2.85, .0 ), vec3( 1., 0.79, .16 ), nor, pos, ref, 4., .0 );\n   \n    col += 1.1 * vec3( 1., 0.4, 0.2 ) * abs( pow( sun, 3. ) );\n    //col += 2.1 * vec3( 1., 0.79, .16 ) * abs( pow( sun, 3. ) );\n    col *= ao;\n    \n    vec3 fog = vec3( EPSILON );\n    col = mix( col, colBg, 1. - exp( -.0155 * t * t ) );   \n    \n    col = col;\n    \n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 p = -1. + 2. * uv;\n    p.x *= iResolution.x / iResolution.y;\n    \n    //vec2 m = iMouse.xy/iResolution.xy;\n    \n    // Camera\n\t//vec3 ro = orbit( PI/2. - 3.2,PI/2.,-1.8 );\n\t//vec3 ta  = vec3( EPSILON, +.4, .5 );\n    float radius = 4.6;\n    vec3 ro = orbit(PI/2.-.5,PI/2. + iTime * .85,radius);\n    vec3 ta = vec3( EPSILON );\n    ta.y = 1.;\n   \n    // Camera to world transformation\n    mat3 ca = setCamera( ro, ta, EPSILON );\n    \n    // Ray direction\n    vec3 rd = ca * normalize( vec3( p.xy, 1. ) );\n    \n    // Raymarching\n    vec3 c = render( ro, rd, uv );\n    c.r = smoothstep(0.0, 1.0, c.r);\n\tc.g = smoothstep(0.0, 1.0, c.g - 0.1);\n\tc.b = smoothstep(-0.3, 1.3, c.b);\n    c = postEffects( c, uv, 0. );\n    fragColor = vec4( c, 1. );\n}", "image_inputs": [{"id": "lsX3z4", "previewfilepath": "https://soundcloud.com/tycho/elsewhere-burning-man-sunrise-set-2015", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "https://soundcloud.com/tycho/elsewhere-burning-man-sunrise-set-2015", "ctype": "musicstream"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4dc3W2.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "4dd3D2", "name": "Gradient Etude I", "author": "lowww", "description": "This was the result of two problems I tried to fix for a commercial project. First, I'm drawing a gradient with 4 distinct colours, and secondly I'm adding another gradient with transparency and variable height on top of it.", "tags": ["gradient"], "likes": 4, "viewed": 731, "date": "1452265545", "time_retrieved": "2024-06-20T18:29:43.511629", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = fragCoord.xy / iResolution.xy;\n\n    float scaleY = 0.5 + 0.5 * sin(iTime);\n\n    // quad background gradient colors\n    vec3 bl = vec3(0.21568627450980393, 0.396078431372549, 0.5764705882352941);\n    vec3 br = vec3(0.29411764705882354, 0.44313725490196076, 0.5607843137254902);\n    vec3 tl = vec3(0.34509803921568627, 0.7529411764705882, 0.6901960784313725);\n    vec3 tr = vec3(0.37254901960784315, 0.7803921568627451, 0.6941176470588235);\n\n    // quad background gradient\n    vec3 bg = mix(\n        mix(bl, br, uv.x),\n        mix(tl, tr, uv.x),\n        uv.y\n    );\n\n    // blend second gradient\n    vec4 gradient = mix(vec4(0.882, 0.458, 0.439, 1.0), vec4(0.764, 0.643, 0.807, 0.0), min(1.0, uv.y / scaleY));\n\n    // change height or second gradient\n    vec4 col = mix( mix(vec4(bg, 1.), gradient, gradient.a), vec4(bg, 1.), smoothstep(scaleY-0.00001, scaleY, uv.y));\n\n    fragColor = col;\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4dd3D2.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "4dd3Rl", "name": "Stockholms Ström", "author": "trapcode", "description": "Attempt to recreate the water in Stockholms Ström (\"ström\" means current - it's a chaotic patch of water)", "tags": ["fractal", "noise", "water"], "likes": 154, "viewed": 10987, "date": "1451771241", "time_retrieved": "2024-06-20T18:29:45.632998", "image_code": "// Stockholms Ström\n// by Peder Norrby / Trapcode in 2016\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n\n\nmat3 rotationMatrix(vec3 axis, float angle)\n{\n    axis = normalize(axis);\n    float s = sin(angle);\n    float c = cos(angle);\n    float oc = 1.0 - c;\n    \n    return mat3(oc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s,  \n                oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s,  \n                oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c          );\n                                          \n}\n\n\n//\n// Description : Array and textureless GLSL 2D/3D/4D simplex \n//               noise functions.\n//      Author : Ian McEwan, Ashima Arts.\n//  Maintainer : ijm\n//     Lastmod : 20110822 (ijm)\n//     License : Copyright (C) 2011 Ashima Arts. All rights reserved.\n//               Distributed under the MIT License. See LICENSE file.\n//               https://github.com/ashima/webgl-noise\n// \n\n\nvec3 mod289(vec3 x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 mod289(vec4 x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 permute(vec4 x) {\n     return mod289(((x*34.0)+1.0)*x);\n}\n\nvec4 taylorInvSqrt(vec4 r)\n{\n  return 1.79284291400159 - 0.85373472095314 * r;\n}\n\nfloat noise(vec3 v)\n  { \n  const vec2  C = vec2(1.0/6.0, 1.0/3.0) ;\n  const vec4  D = vec4(0.0, 0.5, 1.0, 2.0);\n\n// First corner\n  vec3 i  = floor(v + dot(v, C.yyy) );\n  vec3 x0 =   v - i + dot(i, C.xxx) ;\n\n// Other corners\n  vec3 g = step(x0.yzx, x0.xyz);\n  vec3 l = 1.0 - g;\n  vec3 i1 = min( g.xyz, l.zxy );\n  vec3 i2 = max( g.xyz, l.zxy );\n\n  //   x0 = x0 - 0.0 + 0.0 * C.xxx;\n  //   x1 = x0 - i1  + 1.0 * C.xxx;\n  //   x2 = x0 - i2  + 2.0 * C.xxx;\n  //   x3 = x0 - 1.0 + 3.0 * C.xxx;\n  vec3 x1 = x0 - i1 + C.xxx;\n  vec3 x2 = x0 - i2 + C.yyy; // 2.0*C.x = 1/3 = C.y\n  vec3 x3 = x0 - D.yyy;      // -1.0+3.0*C.x = -0.5 = -D.y\n\n// Permutations\n  i = mod289(i); \n  vec4 p = permute( permute( permute( \n             i.z + vec4(0.0, i1.z, i2.z, 1.0 ))\n           + i.y + vec4(0.0, i1.y, i2.y, 1.0 )) \n           + i.x + vec4(0.0, i1.x, i2.x, 1.0 ));\n\n// Gradients: 7x7 points over a square, mapped onto an octahedron.\n// The ring size 17*17 = 289 is close to a multiple of 49 (49*6 = 294)\n  float n_ = 0.142857142857; // 1.0/7.0\n  vec3  ns = n_ * D.wyz - D.xzx;\n\n  vec4 j = p - 49.0 * floor(p * ns.z * ns.z);  //  mod(p,7*7)\n\n  vec4 x_ = floor(j * ns.z);\n  vec4 y_ = floor(j - 7.0 * x_ );    // mod(j,N)\n\n  vec4 x = x_ *ns.x + ns.yyyy;\n  vec4 y = y_ *ns.x + ns.yyyy;\n  vec4 h = 1.0 - abs(x) - abs(y);\n\n  vec4 b0 = vec4( x.xy, y.xy );\n  vec4 b1 = vec4( x.zw, y.zw );\n\n  //vec4 s0 = vec4(lessThan(b0,0.0))*2.0 - 1.0;\n  //vec4 s1 = vec4(lessThan(b1,0.0))*2.0 - 1.0;\n  vec4 s0 = floor(b0)*2.0 + 1.0;\n  vec4 s1 = floor(b1)*2.0 + 1.0;\n  vec4 sh = -step(h, vec4(0.0));\n\n  vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy ;\n  vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww ;\n\n  vec3 p0 = vec3(a0.xy,h.x);\n  vec3 p1 = vec3(a0.zw,h.y);\n  vec3 p2 = vec3(a1.xy,h.z);\n  vec3 p3 = vec3(a1.zw,h.w);\n\n//Normalise gradients\n  vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));\n  p0 *= norm.x;\n  p1 *= norm.y;\n  p2 *= norm.z;\n  p3 *= norm.w;\n\n// Mix final noise value\n  vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n  m = m * m;\n  return 42.0 * dot( m*m, vec4( dot(p0,x0), dot(p1,x1), \n                                dot(p2,x2), dot(p3,x3) ) );\n  }\n\n\n\n/*\nmat4 rotationMatrix(vec3 axis, float angle)\n{\n    axis = normalize(axis);\n    float s = sin(angle);\n    float c = cos(angle);\n    float oc = 1.0 - c;\n    \n    return mat4(oc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s,  0.0,\n                oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s,  0.0,\n                oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c,           0.0,\n                0.0,                                0.0,                                0.0,                                1.0);\n}*/\n\n\n\nfloat fnoise( vec3 p)\n{\n    mat3 rot = rotationMatrix( normalize(vec3(0.0,0.0, 1.0)), 0.5*iTime);\n    mat3 rot2 = rotationMatrix( normalize(vec3(0.0,0.0, 1.0)), 0.3*iTime);\n    float sum = 0.0;\n    \n    vec3 r = rot*p;\n    \n    float add = noise(r);\n    float msc = add+0.7;\n   \tmsc = clamp(msc, 0.0, 1.0);\n    sum += 0.6*add;\n    \n    p = p*2.0;\n    r = rot*p;\n    add = noise(r);\n \n    add *= msc;\n    sum += 0.5*add;\n    msc *= add+0.7;\n   \tmsc = clamp(msc, 0.0, 1.0);\n    \n    p.xy = p.xy*2.0;\n    p = rot2 *p;\n    add = noise(p);\n    add *= msc;\n    sum += 0.25*abs(add);\n    msc *= add+0.7;\n   \tmsc = clamp(msc, 0.0, 1.0);\n \n    p = p*2.0;\n  //  p = p*rot;\n    add = noise(p);// + vec3(iTime*5.0, 0.0, 0.0));\n    add *= msc;\n    sum += 0.125*abs(add);\n    msc *= add+0.2;\n   \tmsc = clamp(msc, 0.0, 1.0);\n\n    p = p*2.0;\n  //  p = p*rot;\n    add = noise(p);\n    add *= msc;\n    sum += 0.0625*abs(add);\n    //msc *= add+0.7;\n   \t//msc = clamp(msc, 0.0, 1.0);\n\n    \n    return sum*0.516129; // return msc as detail measure?\n}\n\nfloat getHeight(vec3 p) // x,z,time\n{\n    \n \treturn 0.3-0.5*fnoise( vec3(0.5*(p.x + 0.0*iTime), 0.5*p.z,  0.4*iTime) );   \n}\n\n#define box_y 1.0\n#define box_x 2.0\n#define box_z 2.0\n#define bg vec4(0.0, 0.0, 0.0, 1.0)\n#define step 0.3\n#define red vec4(1.0, 0.0, 0.0, 1.0)\n#define PI_HALF 1.5707963267949\n\nvec4 getSky(vec3 rd)\n{\n    if (rd.y > 0.3) return vec4(0.5, 0.8, 1.5, 1.0); // bright sky\n    if (rd.y < 0.0) return vec4(0.0, 0.2, 0.4, 1.0); // no reflection from below\n    \n    if (rd.z > 0.9 && rd.x > 0.3) {\n    \tif (rd.y > 0.2) return 1.5*vec4(2.0, 1.0, 1.0, 1.0); // red houses\n    \treturn 1.5*vec4(2.0, 1.0, 0.5, 1.0); // orange houses\n    } else return vec4(0.5, 0.8, 1.5, 1.0 ); // bright sky\n}\n\n\nvec4 shadeBox(vec3 normal, vec3 pos, vec3 rd)\n{\n    float deep = 1.0+0.5*pos.y;\n    \n    vec4 col = deep*0.4*vec4(0.0, 0.3, 0.4, 1.0);\n    \n    return col;\n \n}\n\nvec4 shade(vec3 normal, vec3 pos, vec3 rd)\n{\n    float ReflectionFresnel = 0.99;\n   \tfloat fresnel = ReflectionFresnel*pow( 1.0-clamp(dot(-rd, normal), 0.0, 1.0), 5.0) + (1.0-ReflectionFresnel);\n    vec3 refVec = reflect(rd, normal);\n    vec4 reflection = getSky(refVec);\n    \n    //vec3 sunDir = normalize(vec3(-1.0, -1.0, 0.5));\n    //float intens = 0.5 + 0.5*clamp( dot(normal, sunDir), 0.0, 1.0);\n    \n    float deep = 1.0+0.5*pos.y;\n    \n    vec4 col = fresnel*reflection;\n    col += deep*0.4*vec4(0.0, 0.3, 0.4, 1.0);\n    \n    return clamp(col, 0.0, 1.0);\n}\n\nvec4 intersect_box(vec3 ro, vec3 rd) // no top and bottom, just sides!\n{\n    //vec3 normal;\n    float t_min = 1000.0;\n    vec3 t_normal;\n\n    // x = -box_x plane\n    float t = (-box_x -ro.x) / rd.x;\n    vec3 p = ro + t*rd;\n\n    if (p.y > -box_y && p.z < box_z && p.z > -box_z) {\n        t_normal = vec3(-1.0, 0.0, 0.0);\n        t_min = t;\n        //if (dot(normal, rd) > PI_HALF ) return red;//shadeBox(normal, p, rd);\n    }\n\n    \n    // x = +box_x plane\n    //box_x = ro.x + t*rd.x\n    //t*rd.x = box_x - ro.x\n   // t = (box_x - ro.x)/rd.x\n    \n    t = (box_x -ro.x) / rd.x;\n    p = ro + t*rd;\n\n    if (p.y > -box_y && p.z < box_z && p.z > -box_z) {\n        if (t < t_min) {\n        \tt_normal = vec3(1.0, 0.0, 0.0);\n\t\t\tt_min = t;\n        }\n    }\n\n    // z = -box_z plane\n\tt = (-box_z -ro.z) / rd.z;\n    p = ro + t*rd;\n    \n    if (p.y > -box_y && p.x < box_x && p.x > -box_x) {\n        \n        if (t < t_min) {\n        \tt_normal = vec3(0.0, 0.0, -1.0);\n            t_min = t;\n        }\n    }\n    \n    // z = +box_z plane\n\tt = (box_z -ro.z) / rd.z;\n    p = ro + t*rd;\n    \n    if (p.y > -box_y && p.x < box_x && p.x > -box_x) {\n        \n        if (t < t_min) {\n        \tt_normal = vec3(0.0, 0.0, 1.0);\n            t_min = t;\n        }\n    }\n    \n    \n    if (t_min < 1000.0) return shadeBox(t_normal, ro + t_min*rd, rd);\n    \n    \n    return bg;\n}\n\n\n\nvec4 trace_heightfield( vec3 ro, vec3 rd)\n{\n    \n    // intersect with max h plane, y=1\n    \n    //ro.y + t*rd.y = 1.0;\n    //t*rd.y = 1.0 - ro.y;\n    float t = (1.0 - ro.y) / rd.y;\n    \n    if (t<0.0) return red;\n    \n    vec3 p = ro + t*rd;\n    \n    if (p.x < -2.0 && rd.x <= 0.0) return bg;\n    if (p.x >  2.0 && rd.x >= 0.0) return bg;\n    if (p.z < -2.0 && rd.z <= 0.0) return bg;\n    if (p.z >  2.0 && rd.z >= 0.0) return bg;\n   \n    \n    //float h = getHeight(p);\n    float h, last_h;\n    bool not_found = true;\n    vec3 last_p = p;\n    \n    for (int i=0; i<20; i++) {\n        \n        p += step*rd;\n    \n    \th = getHeight(p);\n        \n        if (p.y < h) {not_found = false; break;} // we stepped through\n        last_h = h;\n        last_p = p;\n    }\n    \n    if (not_found) return bg;\n \n \t// refine interection\n    float dh2 = h - p.y;\n    float dh1 = last_p.y - last_h;\n \tp = last_p + rd*step/(dh2/dh1+1.0);\n   \n    // box shenanigans\n    if (p.x < -2.0) {\n        if (rd.x <= 0.0) return bg; \n        return intersect_box(ro, rd);\n    }\n    if (p.x >  2.0) {\n        if (rd.x >= 0.0) return bg;\n        return intersect_box(ro, rd);\n    }\n    if (p.z < -2.0) {\n        if (rd.z <= 0.0) return bg; \n        return intersect_box(ro, rd);\n    }\n    if (p.z >  2.0) {\n        if (rd.z >= 0.0) return bg;\n        return intersect_box(ro, rd);\n    }\n    \n    vec3 pdx = p + vec3( 0.01, 0.0,  0.00);\n    vec3 pdz = p + vec3( 0.00, 0.0,  0.01);\n    \n    float hdx = getHeight( pdx );\n    float hdz = getHeight( pdz );\n   \th = getHeight( p );\n    \n    p.y = h;\n    pdx.y = hdx;\n    pdz.y = hdz;\n    \n    vec3 normal = normalize(cross( p-pdz, p-pdx)) ;\n    \n \treturn shade(normal, p, rd);\n}\n\n\n// Shadertoy camera code by iq\n\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr ) \n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = (-iResolution.xy + 2.0*fragCoord.xy)/ iResolution.y;\n    vec2 m = iMouse.xy/iResolution.xy;\n    \n    m.y += 0.3;\n    m.x += 0.72;\n    \n    //m.y = clamp(m.y, 0.2, 2.0);\n    //m.x = clamp(m.x, 1.15, 1.6);\n    \n    // camera\n    vec3 ro = 9.0*normalize(vec3(sin(5.0*m.x), 1.0*m.y, cos(5.0*m.x))); // positon\n\tvec3 ta = vec3(0.0, -1.0, 0.0); // target\n    mat3 ca = setCamera( ro, ta, 0.0 );\n    // ray\n    vec3 rd = ca * normalize( vec3(p.xy,4.0));\n    \n    \n    fragColor = trace_heightfield( ro, rd );\n}\n\n// untested VR hook\nvoid mainVR( out vec4 fragColor, in vec2 fragCoord, in vec3 fragRayOri, in vec3 fragRayDir )\n{\n    fragColor = trace_heightfield( fragRayOri, fragRayDir );\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc-by-nc-sa-3.0 AND proprietary-license", "thumbnail": "https://www.shadertoy.com/media/shaders/4dd3Rl.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "4dfXW4", "name": "Feature Extraction", "author": "paniq", "description": "using techniques described in https://www.graphics.rwth-aachen.de/media/papers/feature1.pdf and http://www.sandboxie.com/misc/isosurf/isosurfaces.html to identify and extract surface features", "tags": ["mattdamon"], "likes": 11, "viewed": 803, "date": "1453087464", "time_retrieved": "2024-06-20T18:29:49.542538", "image_code": "// marching cube on dual grid visualization\n// -- @paniq\n\n#define GRIDRES 10\n\n#ifdef GLSLSANDBOX\n#ifdef GL_ES\nprecision mediump float;\n#endif\nuniform float time;\nuniform vec2 mouse;\nuniform vec2 resolution;\n#define iTime time\n#define iResolution resolution\n#endif\n\n// interface\n//////////////////////////////////////////////////////////\n\n// set color source for stroke / fill / clear\nvoid set_source_rgba(vec4 c);\nvoid set_source_rgba(float r, float g, float b, float a);\nvoid set_source_rgb(vec3 c);\nvoid set_source_rgb(float r, float g, float b);\nvoid set_source(sampler2D image);\n\n// set line width in normalized units for stroke\nvoid set_line_width(float w);\n// set line width in pixels for stroke\nvoid set_line_width_px(float w);\n// set blur strength for strokes in normalized units\nvoid set_blur(float b);\n\n// add a circle path at P with radius R\nvoid circle(vec2 p, float r);\nvoid circle(float x, float y, float r);\n// add a rectangle at O with size S\nvoid rectangle(vec2 o, vec2 s);\nvoid rectangle(float ox, float oy, float sx, float sy);\n\n// set starting point for curves and lines to P\nvoid move_to(vec2 p);\nvoid move_to(float x, float y);\n// draw straight line from starting point to P,\n// and set new starting point to P\nvoid line_to(vec2 p);\nvoid line_to(float x, float y);\n// draw quadratic bezier curve from starting point\n// over B1 to B2 and set new starting point to B2\nvoid curve_to(vec2 b1, vec2 b2);\nvoid curve_to(float b1x, float b1y, float b2x, float b2y);\n// connect current starting point with first\n// drawing point.\nvoid close_path();\n\n// clear screen in the current source color\nvoid clear();\n// fill paths and clear the path buffer\nvoid fill();\n// fill paths and preserve them for additional ops\nvoid fill_preserve();\n// stroke paths and clear the path buffer\nvoid stroke_preserve();\n// stroke paths and preserve them for additional ops\nvoid stroke();\n// clears the path buffer\nvoid new_path();\n\n// return rgb color for given hue (0..1)\nvec3 hue(float hue);\n// return rgb color for given hue, saturation and lightness\nvec3 hsl(float h, float s, float l);\nvec4 hsl(float h, float s, float l, float a);\n\n// rotate the context by A in radians\nvoid rotate(float a);\n// uniformly scale the context by S\nvoid scale(float s);\n// translate the context by offset P\nvoid translate(vec2 p);\nvoid translate(float x, float y);\n// clear all transformations for the active context\nvoid identity_matrix();\n// transform the active context by the given matrix\nvoid transform(mat3 mtx);\n// set the transformation matrix for the active context\nvoid set_matrix(mat3 mtx);\n\n// represents the current drawing context\n// you usually don't need to change anything here\nstruct Context {\n    vec2 position;\n    float scale;\n    float shape;\n    float line_width;\n    vec2 blur;\n    vec4 source;\n    vec2 start_pt;\n    vec2 last_pt;\n};\n    \n// save current source color, stroke width and starting\n// point from active context.\nContext save();\n// restore source color, stroke width and starting point\n// to a context previously returned by save()\nvoid restore(Context ctx);\n\n// draws a half-transparent debug gradient for the\n// active path\nvoid debug_gradient();\n\nvoid paint();\n\n// implementation\n//////////////////////////////////////////////////////////\n\nvec2 aspect;\nvec2 uv;\nvec2 position;\nfloat ScreenH;\nfloat AA;\nfloat AAINV;\n\n//////////////////////////////////////////////////////////\n\nfloat det(vec2 a, vec2 b) { return a.x*b.y-b.x*a.y; }\n\n//////////////////////////////////////////////////////////\n\nvec3 hue(float hue) {\n    return clamp( \n        abs(mod(hue * 6.0 + vec3(0.0, 4.0, 2.0), 6.0) - 3.0) - 1.0, \n        0.0, 1.0);\n}\n\nvec3 hsl(float h, float s, float l) {\n    vec3 rgb = hue(h);\n    return l + s * (rgb - 0.5) * (1.0 - abs(2.0 * l - 1.0));\n}\n\nvec4 hsl(float h, float s, float l, float a) {\n    return vec4(hsl(h,s,l),a);\n}\n\n//////////////////////////////////////////////////////////\n\n#define DEFAULT_SHAPE_V 1e+20\n    \nContext _stack;\n\nvoid init (vec2 fragCoord) {\n    aspect = vec2(iResolution.x / iResolution.y, 1.0);\n    ScreenH = min(iResolution.x,iResolution.y);\n    AA = ScreenH*0.4;\n    AAINV = 1.0 / AA;\n    \n    uv = fragCoord.xy / iResolution.xy;\n    \n     position = (uv*2.0-1.0)*aspect;\n    _stack = Context(\n        position, 1.0,\n        DEFAULT_SHAPE_V,\n        1.0,\n        vec2(AA,0.0),\n        vec4(vec3(0.0),1.0),\n        vec2(0.0),\n        vec2(0.0)\n    );\n}\n\nvec3 _color = vec3(1.0);\n\nContext save() {\n    return _stack;\n}\n\nvoid restore(Context ctx) {\n    // preserve shape\n    float shape = _stack.shape;\n    _stack = ctx;\n    _stack.shape = shape;\n}\n\nmat3 mat2x3_invert(mat3 s)\n{\n    float d = det(s[0].xy,s[1].xy);\n    d = (d != 0.0)?(1.0 / d):d;\n\n    return mat3(\n        s[1].y*d, -s[0].y*d, 0.0,\n        -s[1].x*d, s[0].x*d, 0.0,\n        det(s[1].xy,s[2].xy)*d,\n        det(s[2].xy,s[0].xy)*d,\n        1.0);\n}\n\nvoid identity_matrix() {\n    _stack.position = position;\n    _stack.scale = 1.0;\n}\n\nvoid set_matrix(mat3 mtx) {\n    mtx = mat2x3_invert(mtx);\n    _stack.position = (mtx * vec3(position,1.0)).xy;\n    _stack.scale = length(vec2(mtx[0].x,mtx[1].y));\n}\n\nvoid transform(mat3 mtx) {\n    mtx = mat2x3_invert(mtx);\n    _stack.position = (mtx * vec3(_stack.position,1.0)).xy;\n    vec2 u = vec2(mtx[0].x, mtx[1].x);\n    _stack.scale *= length(u);\n}\n\nvoid rotate(float a) {\n    float cs = cos(a), sn = sin(a);\n    transform(mat3(\n        cs, sn, 0.0,\n        -sn, cs, 0.0,\n        0.0, 0.0, 1.0));\n}\n\nvoid scale(float s) {\n    transform(mat3(s,0.0,0.0,0.0,s,0.0,0.0,0.0,1.0));\n}\n\nvoid translate(vec2 p) {\n    transform(mat3(1.0,0.0,0.0,0.0,1.0,0.0,p.x,p.y,1.0));\n}\n\nvoid translate(float x, float y) { translate(vec2(x,y)); }\n\nvoid clear() {\n    _color = mix(_color, _stack.source.rgb, _stack.source.a);\n}\n\nvoid add(float d) {\n    _stack.shape = min(_stack.shape, d / _stack.scale);\n}\n\nvoid new_path() {\n    _stack.shape = DEFAULT_SHAPE_V;\n}\n\nvoid debug_gradient() {\n    _color = mix(_color, \n        hsl(_stack.shape * 6.0, \n            1.0, (_stack.shape>=0.0)?0.5:0.3), \n        0.5);\n}\n\nvoid set_blur(float b) {\n    if (b == 0.0) {\n        _stack.blur = vec2(AA, 0.0);\n        return;\n    }\n    float a = 1.0 / max(AAINV, b);\n    _stack.blur = vec2(\n        a,\n        0.0); // 0 = blur ends at outline, 1 = blur starts at outline\n}\n\nvoid fill_preserve() {\n    float w = clamp(-_stack.shape*AA, 0.0, 1.0);\n    _color = mix(_color, _stack.source.rgb, w * _stack.source.a);\n}\n\nvoid fill() {\n    fill_preserve();\n    new_path();\n}\n\nvoid set_line_width(float w) {\n    _stack.line_width = w;\n}\n\nvoid set_line_width_px(float w) {\n    _stack.line_width = w*_stack.scale/AA;\n}\n\nvoid stroke_preserve() {\n    float w = abs(_stack.shape)- _stack.line_width/_stack.scale;\n    vec2 blur = _stack.blur;// / _stack.scale;\n    w = clamp(-w*blur.x + blur.y, 0.0, 1.0);\n    _color = mix(_color, _stack.source.rgb, w * _stack.source.a);\n}\n\nvoid stroke() {\n    stroke_preserve();\n    new_path();\n}\n\nvoid set_source_rgba(vec4 c) {\n    _stack.source = c;\n}\n\nvoid set_source_rgba(float r, float g, float b, float a) { \n    set_source_rgba(vec4(r,g,b,a)); }\n\nvoid set_source_rgb(vec3 c) {\n    set_source_rgba(vec4(c,1.0));\n}\n\nvoid set_source_rgb(float r, float g, float b) { set_source_rgb(vec3(r,g,b)); }\n\nvoid set_source(sampler2D image) {\n    set_source_rgba(texture(image, _stack.position));\n}\n\nvoid rectangle(vec2 o, vec2 s) {\n    s*=0.5;\n    o = o - _stack.position + s;\n    vec2 d = abs(o) - s;\n    add(min(max(d.x,d.y),0.0) + length(max(d,0.0)));\n}\n\nvoid rectangle(float ox, float oy, float sx, float sy) {\n    rectangle(vec2(ox,oy), vec2(sx,sy));\n}\n\nvoid circle(vec2 p, float r) {\n    add(length(_stack.position - p) - r);\n}\nvoid circle(float x, float y, float r) { circle(vec2(x,y),r); }\n\nvoid move_to(vec2 p) {\n    _stack.start_pt = p;\n    _stack.last_pt = p;\n}\n\nvoid move_to(float x, float y) { move_to(vec2(x,y)); }\n\n// stroke only\nvoid line_to(vec2 p) {\n    vec2 pa = _stack.position - _stack.last_pt;\n    vec2 ba = p - _stack.last_pt;\n    float h = clamp(dot(pa, ba)/dot(ba,ba), 0.0, 1.0);\n    add(length(pa - ba*h));\n    \n    _stack.last_pt = p;\n}\n\nvoid line_to(float x, float y) { line_to(vec2(x,y)); }\n\nvoid close_path() {\n    line_to(_stack.start_pt);\n}\n\n// from \"Random-access rendering of general vector graphics\"\n// by Nehab and Hoppe\n// only quadratic, not cubic\nvoid curve_to(vec2 b1, vec2 b2)\n{\n    vec2 b0 = _stack.last_pt - _stack.position;\n\t_stack.last_pt = b2;\n    b1 -= _stack.position;\n    b2 -= _stack.position;\n    float a=det(b0,b2), b=2.0*det(b1,b0), d=2.0*det(b2,b1);\n    float f=b*d-a*a;\n    vec2 d21=b2-b1, d10=b1-b0, d20=b2-b0;\n    vec2 gf=2.0*(b*d21+d*d10+a*d20);\n    gf=vec2(gf.y,-gf.x);\n    vec2 pp=-f*gf/dot(gf,gf);\n    vec2 d0p=b0-pp;\n    float ap=det(d0p,d20), bp=2.0*det(d10,d0p);\n    float t=clamp((ap+bp)/(2.0*a+b+d), 0.0, 1.0);\n    add(length(mix(mix(b0,b1,t),mix(b1,b2,t),t)));\n}\n\nvoid curve_to(float b1x, float b1y, float b2x, float b2y) {\n    curve_to(vec2(b1x,b1y),vec2(b2x,b2y));\n}\n\n//////////////////////////////////////////////////////////\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    init(fragCoord);\n    \n    paint();\n    \n    fragColor = vec4(_color.xyz, 1.0);\n}\n\n#ifdef GLSLSANDBOX\nvoid main() {\n    mainImage(gl_FragColor, gl_FragCoord.xy);\n}\n#endif\n\n//////////////////////////////////////////////////////////\n\nfloat box(vec3 p, vec3 size) {\n\tvec3 d = abs(p) - size;\n    \n\tvec3 dm = max(d, 0.0);\n    \n    return min(max(d.x,max(d.y,d.z)),0.0) + length(dm);\n}\n\nfloat sphere(vec3 p, float r) {\n\treturn length(p) - r;\n}\n\nfloat plane(vec3 p, vec4 n) {\n\treturn dot(p,n.xyz) - n.w;\n}\n\n// c must be normalized\nfloat cone(vec3 p, vec2 a, float l) {\n    return max(max(a.x*length(p.xy)+a.y*p.z, p.z), abs(p.z)-l);\n}\n\n\nvec3 rotate(vec3 p, float a) {\n\tfloat sa = sin(a);\n\tfloat ca = cos(a);\n\treturn vec3(\n\t\tp.x*ca - p.z*sa,\n\t\t0.0,\n\t\tp.x*sa + p.z*ca\n\t);\n}\n\n#if 0 // R functions\n\nfloat r_min(float a, float b) {\n\treturn a + b - sqrt(a*a+b*b);\n}\n\nfloat r_max(float a, float b) {\n\treturn a + b + sqrt(a*a+b*b);\n}\n\n\n#else // boolean\n\nfloat r_min(float a, float b) {\n\treturn min(a,b);\n}\n\nfloat r_max(float a, float b) {\n\treturn max(a,b);\n}\n\n#endif\n\nfloat map(vec3 p) {\n\tfloat w = plane(p, vec4(0.0,0.0,1.0,-0.6));\n\tfloat s = sphere(p - vec3(1.0,0.0,0.0), 0.5);\n\tfloat s2 = sphere(p - vec3(0.67,0.0,0.0), 0.2);\n\tfloat c = cone(p - vec3(-0.5,0.0,-0.3), normalize(vec2(1.0,0.5)), 0.5);\n\tfloat b = box(rotate(p - vec3(-0.5,0.0,0.2),iTime), vec3(0.3,1.0,0.1));\n\treturn r_min(b, r_min(c, r_min(r_max(s,-s2),w)));\n}\n\nfloat map(vec2 p) {\n\treturn map(vec3(p.x, 0.0, p.y));\n}\n\nvec3 grad0(vec3 p, float e) {\n\tvec2 d = vec2(0.0, e);\n\treturn -vec3(\n\t\tmap(p + d.yxx) - map(p - d.yxx),\n\t\tmap(p + d.xyx) - map(p - d.xyx),\n\t\tmap(p + d.xxy) - map(p - d.xxy));\n}\n\nconst float ERR = 1e-2;\nvec3 grad(vec3 p) {\n\treturn grad0(p,ERR) / (2.0 * ERR);\n}\n\n\nvec2 grad2d(vec3 p) {\n\tvec2 d = vec2(0.0, 1e-3);\n\treturn normalize(vec2(\n\t\tmap(p + d.yxx) - map(p - d.yxx),\n\t\tmap(p + d.xxy) - map(p - d.xxy)));\n}\n\nvec2 grad2d(vec2 p) {\n\treturn grad2d(vec3(p.x,0.0,p.y));\n}\n\nvoid arrow(vec2 u, vec2 n) {\n\tvec2 o = vec2(n.y, -n.x);\n\tmove_to(u);\n\tu += n;\n\tline_to(u);\n\tmove_to(u - o*0.2);\n\tline_to(u + o*0.2);\n\tline_to(u + n*0.4);\n\tclose_path();\n}\n\nfloat mlen(vec2 c) {\n\tc = abs(c);\n\treturn max(c.x, c.y);\n}\n\nfloat mlen(vec3 c) {\n\tc = abs(c);\n\treturn max(c.x, max(c.y, c.z));\n}\n\nbool gravitymarch(vec3 ro, float maxt, out vec3 p) {\n\tfloat precis = 0.001;\n\tfloat h = 1000.0;\n\tp = ro;\n\tfor(int i = 0; i < 5; i++) {\n\t\tif(abs(h) < precis || length(p - ro) > maxt) break;\n\t\th = map(p);\n\t\tvec2 n = grad2d(p);\n\t\tp.xz -= n*h;\n\t}\t\n\treturn (abs(h) < precis);\n}\n\n\n\nvec3 sigcolor(float k) {\n\treturn hue(clamp(-k,-1.0,1.0)*0.3333+0.6667);\n}\n\n// minimal SVD implementation for calculating feature points from hermite data\n// works in C++ and GLSL\n\n// public domain\n\n#define USE_GLSL 1\n\n#define DEBUG_SVD 0\n\n#define SVD_NUM_SWEEPS 10\n\n// GLSL prerequisites\n\n#define IN(t,x) in t x\n#define OUT(t, x) out t x\n#define INOUT(t, x) inout t x\n#define rsqrt inversesqrt\n\n#define SWIZZLE_XYZ(v) v.xyz\n\n// SVD\n////////////////////////////////////////////////////////////////////////////////\n\nconst float Tiny_Number = 1.e-20;\n\nvoid givens_coeffs_sym(float a_pp, float a_pq, float a_qq, OUT(float,c), OUT(float,s)) {\n    if (a_pq == 0.0) {\n        c = 1.0;\n        s = 0.0;\n        return;\n    }\n    float tau = (a_qq - a_pp) / (2.0 * a_pq);\n    float stt = sqrt(1.0 + tau * tau);\n    float tan = 1.0 / ((tau >= 0.0) ? (tau + stt) : (tau - stt));\n    c = rsqrt(1.0 + tan * tan);\n    s = tan * c;\n}\n\nvoid svd_rotate_xy(INOUT(float,x), INOUT(float,y), IN(float,c), IN(float,s)) {\n    float u = x; float v = y;\n    x = c * u - s * v;\n    y = s * u + c * v;\n}\n\nvoid svd_rotateq_xy(INOUT(float,x), INOUT(float,y), INOUT(float,a), IN(float,c), IN(float,s)) {\n    float cc = c * c; float ss = s * s;\n    float mx = 2.0 * c * s * a;\n    float u = x; float v = y;\n    x = cc * u - mx + ss * v;\n    y = ss * u + mx + cc * v;\n}\n\nvoid svd_rotate01(INOUT(mat3,vtav), INOUT(mat3,v)) {\n    if (vtav[0][1] == 0.0) return;\n    \n    float c, s;\n    givens_coeffs_sym(vtav[0][0], vtav[0][1], vtav[1][1], c, s);\n    svd_rotateq_xy(vtav[0][0],vtav[1][1],vtav[0][1],c,s);\n    svd_rotate_xy(vtav[0][2], vtav[1][2], c, s);\n    vtav[0][1] = 0.0;\n    \n    svd_rotate_xy(v[0][0], v[0][1], c, s);\n    svd_rotate_xy(v[1][0], v[1][1], c, s);\n    svd_rotate_xy(v[2][0], v[2][1], c, s);\n}\n\nvoid svd_rotate02(INOUT(mat3,vtav), INOUT(mat3,v)) {\n    if (vtav[0][2] == 0.0) return;\n    \n    float c, s;\n    givens_coeffs_sym(vtav[0][0], vtav[0][2], vtav[2][2], c, s);\n    svd_rotateq_xy(vtav[0][0],vtav[2][2],vtav[0][2],c,s);\n    svd_rotate_xy(vtav[0][1], vtav[1][2], c, s);\n    vtav[0][2] = 0.0;\n    \n    svd_rotate_xy(v[0][0], v[0][2], c, s);\n    svd_rotate_xy(v[1][0], v[1][2], c, s);\n    svd_rotate_xy(v[2][0], v[2][2], c, s);\n}\n\nvoid svd_rotate12(INOUT(mat3,vtav), INOUT(mat3,v)) {\n    if (vtav[1][2] == 0.0) return;\n    \n    float c, s;\n    givens_coeffs_sym(vtav[1][1], vtav[1][2], vtav[2][2], c, s);\n    svd_rotateq_xy(vtav[1][1],vtav[2][2],vtav[1][2],c,s);\n    svd_rotate_xy(vtav[0][1], vtav[0][2], c, s);\n    vtav[1][2] = 0.0;\n    \n    svd_rotate_xy(v[0][1], v[0][2], c, s);\n    svd_rotate_xy(v[1][1], v[1][2], c, s);\n    svd_rotate_xy(v[2][1], v[2][2], c, s);\n}\n\nvoid svd_solve_sym(IN(mat3,a), OUT(vec3,sigma), INOUT(mat3,v)) {\n    // assuming that A is symmetric: can optimize all operations for \n    // the upper right triagonal\n    mat3 vtav = a;\n    // assuming V is identity: you can also pass a matrix the rotations\n    // should be applied to\n    // U is not computed\n    for (int i = 0; i < SVD_NUM_SWEEPS; ++i) {\n        svd_rotate01(vtav, v);\n        svd_rotate02(vtav, v);\n        svd_rotate12(vtav, v);\n    }\n    sigma = vec3(vtav[0][0],vtav[1][1],vtav[2][2]);    \n}\n\nfloat svd_invdet(float x, float tol) {\n    return (abs(x) < tol || abs(1.0 / x) < tol) ? 0.0 : (1.0 / x);\n}\n\nvoid svd_pseudoinverse(OUT(mat3,o), IN(vec3,sigma), IN(mat3,v)) {\n    float d0 = svd_invdet(sigma[0], Tiny_Number);\n    float d1 = svd_invdet(sigma[1], Tiny_Number);\n    float d2 = svd_invdet(sigma[2], Tiny_Number);\n    o = mat3(v[0][0] * d0 * v[0][0] + v[0][1] * d1 * v[0][1] + v[0][2] * d2 * v[0][2],\n             v[0][0] * d0 * v[1][0] + v[0][1] * d1 * v[1][1] + v[0][2] * d2 * v[1][2],\n             v[0][0] * d0 * v[2][0] + v[0][1] * d1 * v[2][1] + v[0][2] * d2 * v[2][2],\n             v[1][0] * d0 * v[0][0] + v[1][1] * d1 * v[0][1] + v[1][2] * d2 * v[0][2],\n             v[1][0] * d0 * v[1][0] + v[1][1] * d1 * v[1][1] + v[1][2] * d2 * v[1][2],\n             v[1][0] * d0 * v[2][0] + v[1][1] * d1 * v[2][1] + v[1][2] * d2 * v[2][2],\n             v[2][0] * d0 * v[0][0] + v[2][1] * d1 * v[0][1] + v[2][2] * d2 * v[0][2],\n             v[2][0] * d0 * v[1][0] + v[2][1] * d1 * v[1][1] + v[2][2] * d2 * v[1][2],\n             v[2][0] * d0 * v[2][0] + v[2][1] * d1 * v[2][1] + v[2][2] * d2 * v[2][2]);\n}\n\nvoid svd_solve_ATA_ATb(\n    IN(mat3,ATA), IN(vec3,ATb), OUT(vec3,x)\n) {\n    mat3 V = mat3(1.0);\n    vec3 sigma;\n    \n    svd_solve_sym(ATA, sigma, V);\n    \n    mat3 Vinv;\n    svd_pseudoinverse(Vinv, sigma, V);\n    x = Vinv * ATb;\n}\n\nvec3 svd_vmul_sym(IN(mat3,a), IN(vec3,v)) {\n    return vec3(\n        dot(a[0],v),\n        (a[0][1] * v.x) + (a[1][1] * v.y) + (a[1][2] * v.z),\n        (a[0][2] * v.x) + (a[1][2] * v.y) + (a[2][2] * v.z)\n    );\n}\n\n// QEF\n////////////////////////////////////////////////////////////////////////////////\n\nvoid qef_add(\n    IN(vec3,n), IN(vec3,p),\n    INOUT(mat3,ATA), \n    INOUT(vec3,ATb),\n    INOUT(vec4,pointaccum))\n{\n    ATA[0][0] += n.x * n.x;\n    ATA[0][1] += n.x * n.y;\n    ATA[0][2] += n.x * n.z;\n    ATA[1][1] += n.y * n.y;\n    ATA[1][2] += n.y * n.z;\n    ATA[2][2] += n.z * n.z;\n\n    float b = dot(p, n);\n    ATb += n * b;\n    pointaccum += vec4(p,1.0);\n}\n\nfloat qef_calc_error(IN(mat3,A), IN(vec3, x), IN(vec3, b)) {\n    vec3 vtmp = b - svd_vmul_sym(A, x);\n    return dot(vtmp,vtmp);\n}\n\nfloat qef_solve(\n    IN(mat3,ATA), \n    IN(vec3,ATb),\n    IN(vec4,pointaccum),\n    OUT(vec3,x)\n) {\n    vec3 masspoint = SWIZZLE_XYZ(pointaccum) / pointaccum.w;\n    ATb -= svd_vmul_sym(ATA, masspoint);\n    svd_solve_ATA_ATb(ATA, ATb, x);\n    float result = qef_calc_error(ATA, x, ATb);\n    \n    x += masspoint;\n        \n    return result;\n}\n\nvoid find_contours(vec4 rc) {\n\tvec2 p[4];\n\tvec2 c[4];\n\tfloat d[4];\n\tfloat z[4];\n\tp[0] = rc.xy;\t\n\tp[1] = rc.zy;\t\n\tp[2] = rc.zw;\t\n\tp[3] = rc.xw;\t\n\tfor (int i = 0; i < 4; ++i) {\n\t\td[i] = map(p[i]);\n\t}\n\t\n\tz[0] = (-d[0] / (d[1]-d[0]));\n\tz[1] = (-d[1] / (d[2]-d[1]));\n\tz[2] = (-d[2] / (d[3]-d[2]));\n\tz[3] = (-d[3] / (d[0]-d[3]));\n\t\n\tc[0] = p[0] + (p[1]-p[0])*z[0];\n\tc[1] = p[1] + (p[2]-p[1])*z[1];\n\tc[2] = p[2] + (p[3]-p[2])*z[2];\n\tc[3] = p[3] + (p[0]-p[3])*z[3];\n\t\n\tvec2 mp[4];\n\tvec2 mg[4];\n\tint mc = 0;\n\t\n    mat3 ATA = mat3(0.0);\n    vec3 ATb = vec3(0.0);\n    vec4 pointaccum = vec4(0.0);\n    \n\tfor (int i = 0; i < 4; ++i) {\n\t\tif (z[i] < 0.0 || z[i] > 1.0) continue;\n\t\t\n\t\tfor (int k = 0; k < 4; ++k) {\n\t\t\tif (k != mc) continue;\n\t\t\tmp[k] = c[i];\n\t\t\tvec2 g = grad2d(c[i]);\n\t\t\tmg[k] = g;\n\t\t\tarrow(c[i], g*0.1);\n\t\t\tstroke();\n\t\t\tmc += 1;\n            \n            qef_add(\n                vec3(g,0.0), vec3(c[i],0.0),\n                ATA, ATb, pointaccum);\n\t\t\tbreak;\n\t\t}\n\t}\n\t\n\tconst float O_sharp = 0.9;\n\tfloat min_ma = 1e+20;\n\tvec2 n0,n1;\n\t\n\t\n\tfor (int i = 0; i < 4; ++i) {\n\t\tfor (int j=0; j < 4; ++j) {\n\t\t\tif (i >= mc || j >= mc) continue;\n\t\t\tfloat ma = dot(mg[i].xy,mg[j].xy);\n\t\t\tif (ma < min_ma) {\n\t\t\t\tmin_ma = ma;\n\t\t\t\tn0 = mg[i];\n\t\t\t\tn1 = mg[j];\n\t\t\t}\n\t\t}\n\t}\n\t\n\tif (min_ma < O_sharp) {\n \t\tvec3 x;\n        qef_solve(ATA, ATb, pointaccum, x);\n        \n        set_source_rgb(vec3(1.0,0.0,0.0));\n\t\tcircle(x.x, x.y, 0.01);\n\t\tstroke();\n        \n\t\tset_source_rgb(vec3(0.5,1.0,0.5));\n\t} else {\n\t\tset_source_rgb(vec3(1.0,1.0,0.5));\n\t}\n\t\n\trectangle(rc.xy, rc.zw-rc.xy);\n\tstroke();\n\t\n\t\n}\n\nvoid paint() {\n\tvec3 mp = vec3(position.x,0.0,position.y);\n    vec2 ms = ((iMouse.xy/iResolution.xy)*2.0-1.0) * aspect;\n\n\t// clear screen\n\t\n\tset_source_rgb(vec3(0.0,0.0,0.5));\n\tclear();\n\n\tset_line_width_px(1.0);\n\t\n\tfloat d = map(mp);\n\t_stack.shape = d;\n\tset_source_rgb(vec3(1.0));\n\t//fill_preserve();\n\tstroke();\n\t\n\tset_source_rgb(vec3(0.5,0.5,1.0));\n\tset_line_width_px(1.0);\n\tfor (int i = 0; i < 5; ++i) {\n\t\t_stack.shape = d-float(i)*0.05-mod(iTime*0.01,0.05);\n\t\tstroke();\n\t}\n\t\n\tfloat fc = 0.05;\n\tvec4 rc = vec4(ms - fc, ms + fc);\n\t\n\tfind_contours(rc);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4dfXW4.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "4dK3DR", "name": "Directional StarField", "author": "vamoss", "description": "Todo\nParalax\nRemove cumulative iGlobalTime in animate formula", "tags": ["star", "field", "velocity"], "likes": 2, "viewed": 246, "date": "1454076573", "time_retrieved": "2024-06-20T18:29:49.542538", "image_code": "#define SMOOTH(r,R) (1.0-smoothstep(R-1.0,R+1.0, r))\n#define M_PI 3.1415926535897932384626433832795\n#define blue3 vec3(0.35,0.76,0.83)\n\nfloat line(vec2 origin, vec2 destiny, float radius, float angle, float lineWidth)\n{\n    vec2 d = origin - destiny;\n    float r = sqrt( dot( d, d ) );\n    if(r<radius)\n    {\n        vec2 p = vec2(sin(angle+M_PI/2.0),\n                            -cos(angle+M_PI/2.0));\n        float l = length( d - p*clamp( dot(d,p)/dot(p,p), 0.0, 1.0) );\n    \treturn 1.0-smoothstep(0.0,lineWidth, l);//return SMOOTH(l/1000.0,lineWidth/100.0);\n    }\n    else return 0.0;\n}\n\nvec2 tile (vec2 _st, float _zoom) {\n    _st *= _zoom;\n    _st.x += step(1., mod(_st.y,2.0)) * 0.5;\n    return fract(_st);\n}\n\nfloat random (vec2 st) {\n    return fract(sin(dot(st.xy, vec2(12.9898,78.233)))*43758.5453123);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 col = vec3(0.0);\n    \n    //line stroke\n    float lineWidth = 0.05;\n    \n    //line origin and destiny\n    vec2 origin = vec2(0.5, 0.5);\n\tvec2 dest = iMouse.xy/iResolution.xy/2.0+origin/2.0;\n    \n\tvec2 uv = fragCoord.xy/iResolution.xy;\n    \n    //animate\n    uv = mod(( (iTime * 10.0 * (dest - origin) )+uv), 1.0);\n    \n    //randomize\n    float rnd1 = random(floor(uv*8.0))*8.0;\n    float tileSize = 6.0+rnd1;\n    float rnd = random(floor(uv*tileSize))/8.0;\n    \n    //tile\n    uv = tile(uv,tileSize);\n    \n    uv += rnd;\n    \n    //line angle and lenght\n    float angle = atan((dest.y-origin.y),(dest.x-origin.x));\n    float lineLenght = distance(dest, origin)*10.0;\n    \n\tvec3 color = vec3(0.0);\n    \n    //draw line\n    color += line(uv, origin, lineLenght, angle, lineWidth) * blue3;\n\t\n    fragColor = vec4(color,1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4dK3DR.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "4dK3Wh", "name": "Even More Even More Spirals", "author": "vox", "description": "Even More Spirals", "tags": ["evenmorespirals"], "likes": 7, "viewed": 179, "date": "1454255931", "time_retrieved": "2024-06-20T18:29:49.542538", "image_code": "\n#define ShaderTime iTime\n\nfloat PI = 3.14159265359;\n\nfloat saw(float x)\n{\n    return acos(cos(x))/3.14;\n}\nvec2 saw(vec2 x)\n{\n    return acos(cos(x))/3.14;\n}\n\nvec2 spiral(vec2 uv)\n{\n    float turns = 4.0+float(int(1.0*saw(ShaderTime*.321)));\n    float r = pow(log(length(uv)+1.)+1.0, 1.25+.25*sin(ShaderTime*.7654))+ShaderTime;\n    float theta = atan(uv.y, uv.x)*turns;\n    return vec2(saw(r*PI+theta/turns*float(int(1.0*saw(ShaderTime*.543)))), saw(theta+ShaderTime*1.1));\n}\n\nvec4 draw(vec2 uv)\n{\n\tif(abs(abs(saw(uv.x*(1.5+sin(ShaderTime*.654321))*PI+ShaderTime*.7654321)*2.0-1.0)-abs(uv.y)) < .5)\n\t\treturn vec4(1.0-abs(abs(saw(uv.x*(1.5+sin(ShaderTime*.654321))*PI+ShaderTime*.7654321)*2.0-1.0)-abs(uv.y))/.5)*uv.x;\n\telse\n\t\treturn vec4(0.0);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    float scale = (22.0+11.0*sin(ShaderTime*.1234))*PI;\n    uv = spiral(uv*scale-scale/2.0);\n    vec4 screen = draw(uv)*clamp(saw(ShaderTime*1.45678), 0.0, 1.0);\n\n    uv = saw(uv*PI*2.0);\n\n    scale = (40.0+20.0*sin(ShaderTime*.234))*PI;\n    uv = spiral(uv*scale-scale/2.0);\n    screen += draw(uv)*clamp(saw(ShaderTime*1.2345678), 0.0, 1.0);\n\n    screen.x *= 2.0*PI;\n    fragColor = clamp(screen.x, 0.0, 1.0)*vec4(vec3(sin(ShaderTime*5.0+0.0+screen.x),\n                                                    sin(ShaderTime*5.0+4.0*PI/3.0+screen.x),\n                                                    sin(ShaderTime*5.0+2.0*PI/3.0+screen.x))*.5+.5,\n                                               1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4dK3Wh.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "4dt3RX", "name": "Sunset In a Cyber World", "author": "Flyguy", "description": " A retro futuristic scene based off this image by Katie Mackowick: http://katiemackowick.com/work/collage-2/landscape", "tags": ["raymarching", "grid", "retro"], "likes": 87, "viewed": 5070, "date": "1451763450", "time_retrieved": "2024-06-20T18:29:51.039471", "image_code": "//Raymarch settings\n\n#define MIN_DIST 0.001\n#define MAX_DIST 32.0\n#define MAX_STEPS 96\n#define STEP_MULT 0.9\n#define NORMAL_OFFS 0.01\n#define FOCAL_LENGTH 0.8\n\n//Scene settings\n\n//#define SHOW_RAY_COST\n\n//Colors\n#define SKY_COLOR_1 vec3(0.60,0.00,0.00)\n#define SKY_COLOR_2 vec3(1.00,0.50,0.00)\n\n#define SUN_COLOR_1 vec3(1.00, 0.00, 0.00)\n#define SUN_COLOR_2 vec3(1.00, 1.00, 0.00)\n\n#define GRID_COLOR_1 vec3(0.00, 0.05, 0.20)\n#define GRID_COLOR_2 vec3(1.00, 0.20, 0.60)\n\n#define WATER_COLOR vec3(0.50, 1.00, 2.90)\n\n//Parameters\n#define GRID_SIZE 0.20\n#define GRID_LINE_SIZE 1.25\n\n#define WATER_LEVEL 0.20\n#define WATER_FOG_SIZE 0.05\n\n#define SUN_DIRECTION vec3( 0.10,-1.00,-0.03)\n\n#define CLOUD_SCROLL vec2(0.002, 0.001)\n#define CLOUD_BLUR 2.0\n#define CLOUD_SCALE vec2(0.04, 0.10)\n\n#define MOUNTAIN_SCALE 6.0\n#define MOUNTAIN_SHIFT 5.3\n\n//Color modes\n//vec3(#,#,#) Number of bits per channel\n\n//24 bit color\n#define RGB888 vec3(8,8,8)\n//16 bit color\n#define RGB565 vec3(5,6,5)\n#define RGB664 vec3(6,6,4)\n//8 bit color\n#define RGB332 vec3(3,3,2)\n#define RGB242 vec3(2,4,2)\n#define RGB222 vec3(2,2,2) //+2 unused\n\n//#define DITHER_ENABLE\n#define COLOR_MODE RGB242\n\n//Object IDs\n#define SKYDOME 0.\n#define FLOOR 1.\n#define RIVER 2.\n\nfloat pi = atan(1.0) * 4.0;\nfloat tau = atan(1.0) * 8.0;\n\nvec3 dither(vec3 color, vec3 bits, vec2 pixel)\n{\n    vec3 cmax = exp2(bits)-1.0;\n    \n    vec3 dithfactor = mod(color, 1.0 / cmax) * cmax;\n    float dithlevel = texture(iChannel2,pixel / iChannelResolution[2].xy).r;\n    \n    vec3 cl = floor(color * cmax)/cmax;\n    vec3 ch = ceil(color * cmax)/cmax;\n    \n    return mix(cl, ch, step(dithlevel, dithfactor));\n}\n\nstruct MarchResult\n{\n    vec3 position;\n    vec3 normal;\n    float dist;\n    float steps;\n    float id;\n};\n\n//Returns a rotation matrix for the given angles around the X,Y,Z axes.\nmat3 Rotate(vec3 angles)\n{\n    vec3 c = cos(angles);\n    vec3 s = sin(angles);\n    \n    mat3 rotX = mat3( 1.0, 0.0, 0.0, 0.0,c.x,s.x, 0.0,-s.x, c.x);\n    mat3 rotY = mat3( c.y, 0.0,-s.y, 0.0,1.0,0.0, s.y, 0.0, c.y);\n    mat3 rotZ = mat3( c.z, s.z, 0.0,-s.z,c.z,0.0, 0.0, 0.0, 1.0);\n\n    return rotX * rotY * rotZ;\n}\n\n//==== Distance field operators/functions by iq. ====\nvec2 opU(vec2 d1, vec2 d2)\n{\n    return (d1.x < d2.x) ? d1 : d2;\n}\n\nvec2 opS(vec2 d1, vec2 d2)\n{\n    return (-d1.x > d2.x) ? d1*vec2(-1,1) : d2;\n}\n\nvec2 sdSphere(vec3 p, float s, float id)\n{\n  return vec2(length(p) - s, id);\n}\n\nvec2 sdPlane(vec3 p, vec4 n, float id)\n{\n  // n must be normalized\n  return vec2(dot(p,n.xyz) + n.w, id);\n}\n\nvec2 sdColumn(vec3 p, float r, float id)\n{\n    return vec2(((abs(p.x)+abs(p.y))-r)/sqrt(2.0), id);\n}\n\nvec2 dfRiver(vec3 p, float id)\n{\n    float offs = sin(p.y)*0.15 + sin(p.y * 0.2);\n    \n    return sdColumn(p.xzy + vec3(offs,0,0), 0.4, id);\n}\n\n//Distance to the scene\nvec2 Scene(vec3 p)\n{\n    vec2 d = vec2(MAX_DIST, SKYDOME);\n    \n    d = opU(sdPlane(p, vec4(0, 0,-1, 0), FLOOR), d);\n    \n    d = opS(dfRiver(p, RIVER), d);\n    \n\treturn d;\n}\n\n//Surface normal at the current position\nvec3 Normal(vec3 p)\n{\n    vec3 off = vec3(NORMAL_OFFS, 0, 0);\n    return normalize\n    ( \n        vec3\n        (\n            Scene(p + off.xyz).x - Scene(p - off.xyz).x,\n            Scene(p + off.zxy).x - Scene(p - off.zxy).x,\n            Scene(p + off.yzx).x - Scene(p - off.yzx).x\n        )\n    );\n}\n\n//Raymarch the scene with the given ray\nMarchResult MarchRay(vec3 orig,vec3 dir)\n{\n    float steps = 0.0;\n    float dist = 0.0;\n    float id = 0.0;\n    \n    for(int i = 0;i < MAX_STEPS;i++)\n    {\n        vec2 object = Scene(orig + dir * dist);\n        \n        //Add the sky dome and have it follow the camera.\n        object = opU(object, -sdSphere(dir * dist, MAX_DIST, SKYDOME));\n        \n        dist += object.x * STEP_MULT;\n        \n        id = object.y;\n        \n        steps++;\n        \n        if(abs(object.x) < MIN_DIST * dist)\n        {\n            break;\n        }\n    }\n    \n    MarchResult result;\n    \n    result.position = orig + dir * dist;\n    result.normal = Normal(result.position);\n    result.dist = dist;\n    result.steps = steps;\n    result.id = id;\n    \n    return result;\n}\n\n//Scene texturing/shading\nvec3 Shade(MarchResult hit, vec3 direction, vec3 camera)\n{\n    vec3 color = vec3(0.0);\n\n    if(hit.id == FLOOR)\n    {\n        vec2 uv = abs(mod(hit.position.xy + GRID_SIZE/2.0, GRID_SIZE) - GRID_SIZE/2.0); \n        \n        uv /= fwidth(hit.position.xy);\n        \n        float riverEdge = dfRiver(hit.position, 0.0).x / fwidth(hit.position.xy).x;\n                                                       \n        float gln = min(min(uv.x, uv.y), riverEdge) / GRID_SIZE;\n        \n    \tcolor = mix(GRID_COLOR_1, GRID_COLOR_2, 1.0 - smoothstep(0.0, GRID_LINE_SIZE / GRID_SIZE, gln));\n    } \n    \n    if(hit.id == RIVER)\n    {\n        vec2 uv = vec2(hit.position.z, abs(mod(hit.position.y + GRID_SIZE/2.0, GRID_SIZE) - GRID_SIZE/2.0)); \n        uv /= fwidth(hit.position.xy);\n        \n        float gln = min(uv.x, uv.y) / GRID_SIZE;\n        \n    \tcolor = mix(GRID_COLOR_1, GRID_COLOR_2, 1.0 - smoothstep(0.0, GRID_LINE_SIZE / GRID_SIZE, gln));\n    }\n    \n    //Distance fog\n    color *= 1.0 - smoothstep(0.0, MAX_DIST*0.9, hit.dist);\n    \n    //Water\n    float waterMix = smoothstep(WATER_LEVEL - WATER_FOG_SIZE, WATER_LEVEL + WATER_FOG_SIZE, hit.position.z);\n    \n    color = mix(color, WATER_COLOR, waterMix);  \n    \n    if(hit.id == SKYDOME)\n    {\n        //Sky gradient\n        //Causes weird position-colored artefacts around the horizon (AMD R9 270)\n        //color = mix(SKY_COLOR_1, SKY_COLOR_2, -hit.position.z/16.0);\n    \tcolor += mix(SKY_COLOR_1, SKY_COLOR_2, -hit.position.z/16.0);\n        \n        //Sun\n        vec3 sunDir = normalize(SUN_DIRECTION);\n        \n        float sun = smoothstep(0.950, 0.952, dot(direction, sunDir));\n        \n        vec3 sunCol = mix(SUN_COLOR_1, SUN_COLOR_2, -hit.position.z/16.0);\n\n        color = mix(color, sunCol, sun);\n        \n        //Clouds\n        vec2 cloudUV = CLOUD_SCALE * direction.xy / dot(direction, vec3(0, 0,-1));\n        cloudUV += CLOUD_SCROLL * iTime;\n        \n        color *= smoothstep(0.5, 0.3, texture(iChannel1, cloudUV, CLOUD_BLUR).r) * 0.5 + 0.5;\n        \n        //Mountains\n        float a = atan(hit.position.y, hit.position.x)/tau + 0.5;\n        a -= 3.28;\n        \n        float mountains = MOUNTAIN_SCALE * texture(iChannel0, vec2(a, 0.1),-99.0).r - hit.position.z - MOUNTAIN_SHIFT;\n        \n        color = mix(color, vec3(0.0), 1.0 - smoothstep(0.6, 0.7, mountains));  \n    }\n    \n    return color;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 res = iResolution.xy / iResolution.y;\n\tvec2 uv = fragCoord.xy / iResolution.y;\n    \n    //Camera stuff   \n    vec3 angles = vec3(0);\n    \n    //Auto mode\n    if(iMouse.xy == vec2(0,0))\n    {\n        angles.y = tau * (1.8 / 8.0);\n        angles.x = tau * (3.9 / 8.0) + sin(iTime * 0.1) * 0.3;\n    }\n    else\n    {    \n    \tangles = vec3((iMouse.xy / iResolution.xy) * pi, 0);\n        angles.xy *= vec2(2.0, 1.0);\n    }\n    \n    angles.y = clamp(angles.y, 0.0, 15.5 * tau / 64.0);\n    \n    mat3 rotate = Rotate(angles.yzx);\n    \n    vec3 orig = vec3(0, 0,-2) * rotate;\n    \n    vec3 dir = normalize(vec3(uv - res / 2.0, FOCAL_LENGTH)) * rotate;\n    \n    //Ray marching\n    MarchResult hit = MarchRay(orig, dir);\n    \n    //Shading\n    vec3 color = Shade(hit, dir, orig);\n    \n    #ifdef SHOW_RAY_COST\n    color = mix(vec3(0,1,0), vec3(1,0,0), hit.steps / float(MAX_STEPS));\n    #endif\n    \n    #ifdef DITHER_ENABLE\n    color = dither(color, COLOR_MODE, fragCoord);\n    #endif\n    \n\tfragColor = vec4(color, 1.0);\n}", "image_inputs": [{"id": "4sfGRn", "previewfilepath": "/media/ap/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg", "ctype": "texture"}, {"id": "Xdf3zn", "previewfilepath": "/media/ap/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png", "channel": 2, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png", "ctype": "texture"}, {"id": "4sf3Rr", "previewfilepath": "/media/ap/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4dt3RX.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "4dt3W2", "name": "Untitled 05", "author": "floz", "description": "Untitled 05 - \nWeek1 - Shader everyday (style)", "tags": ["geometry"], "likes": 5, "viewed": 337, "date": "1452274657", "time_retrieved": "2024-06-20T18:29:53.609464", "image_code": "#define PI 3.141592654\n#define EPSILON 0.0000001\n#define AMPLITUDE 0.52\n#define SPEED 0.05\n\n//------------------------------------------------------------------ VISUAL QUALITY\n#define RAYMARCHING_STEP 24\n#define RAYMARCHING_JUMP 1.\n\n//------------------------------------------------------------------ DEBUG\n//#define RENDER_DEPTH\n//#define RENDER_NORMAL\n//#define RENDER_AO\n\n//------------------- FORMULAS/MAGIC\n\nvec4 vec4pow( in vec4 v, in float p ) {\n    // Don't touch alpha (w), we use it to choose the direction of the shift\n    // and we don't want it to go in one direction more often than the other\n    return vec4(pow(v.x,p),pow(v.y,p),pow(v.z,p),v.w); \n}\n\nvec4 permute(vec4 x){return mod(x*x*34.0+x,289.);}\n\nfloat snoise(vec3 v){\n  const vec2  C = vec2(0.166666667, 0.33333333333) ;\n  const vec4  D = vec4(0.0, 0.5, 1.0, 2.0);\n  vec3 i  = floor(v + dot(v, C.yyy) );\n  vec3 x0 = v - i + dot(i, C.xxx) ;\n  vec3 g = step(x0.yzx, x0.xyz);\n  vec3 l = 1.0 - g;\n  vec3 i1 = min( g.xyz, l.zxy );\n  vec3 i2 = max( g.xyz, l.zxy );\n  vec3 x1 = x0 - i1 + C.xxx;\n  vec3 x2 = x0 - i2 + C.yyy;\n  vec3 x3 = x0 - D.yyy;\n  i = mod(i,289.);\n  vec4 p = permute( permute( permute(\n\t  i.z + vec4(0.0, i1.z, i2.z, 1.0 ))\n\t+ i.y + vec4(0.0, i1.y, i2.y, 1.0 ))\n\t+ i.x + vec4(0.0, i1.x, i2.x, 1.0 ));\n  vec3 ns = 0.142857142857 * D.wyz - D.xzx;\n  vec4 j = p - 49.0 * floor(p * ns.z * ns.z);\n  vec4 x_ = floor(j * ns.z);\n  vec4 x = x_ *ns.x + ns.yyyy;\n  vec4 y = floor(j - 7.0 * x_ ) *ns.x + ns.yyyy;\n  vec4 h = 1.0 - abs(x) - abs(y);\n  vec4 b0 = vec4( x.xy, y.xy );\n  vec4 b1 = vec4( x.zw, y.zw );\n  vec4 s0 = floor(b0)*2.0 + 1.0;\n  vec4 s1 = floor(b1)*2.0 + 1.0;\n  vec4 sh = -step(h, vec4(0.0));\n  vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy ;\n  vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww ;\n  vec3 p0 = vec3(a0.xy,h.x);\n  vec3 p1 = vec3(a0.zw,h.y);\n  vec3 p2 = vec3(a1.xy,h.z);\n  vec3 p3 = vec3(a1.zw,h.w);\n  vec4 norm = inversesqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));\n  p0 *= norm.x;\n  p1 *= norm.y;\n  p2 *= norm.z;\n  p3 *= norm.w;\n  vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n  m = m * m * m;\n  return .5 + 12.0 * dot( m, vec4( dot(p0,x0), dot(p1,x1),dot(p2,x2), dot(p3,x3) ) );\n}\n\n// Maximum/minumum elements of a vector\nfloat vmax(vec2 v) {\n\treturn max(v.x, v.y);\n}\n\nfloat vmax(vec3 v) {\n\treturn max(max(v.x, v.y), v.z);\n}\n\nfloat vmax(vec4 v) {\n\treturn max(max(v.x, v.y), max(v.z, v.w));\n}\n\nfloat hash( float n ){//->0:1\n\treturn fract(sin(n)*3538.5453);\n}\n\nfloat smin( float a, float b )\n{\n    float k = .1;\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\nfloat displacement( vec3 p, float v ) {\n  float f = iTime * -0.5 + sin( iTime * 2. ) * 1.4;\n  return sin( 20. * sin( cos( f ) ) *p.x)*sin( 10. *sin( cos( f ) ) *p.y)*sin( 30. * sin( cos( f ) ) *p.z);\n}\n\n// Repeat around the origin by a fixed angle.\n// For easier use, num of repetitions is use to specify the angle.\nfloat pModPolar(inout vec2 p, float repetitions) {\n\tfloat angle = 2.*PI/repetitions;\n\tfloat a = atan(p.y+0.0000001, p.x+0.0000001) + angle/2.;\n\tfloat r = length(p);\n\tfloat c = floor(a/angle);\n\ta = mod(a,angle) - angle/2.;\n\tp = vec2(cos(a), sin(a))*r + 0.0000001;\n\t// For an odd number of repetitions, fix cell index of the cell in -x direction\n\t// (cell index would be e.g. -5 and 5 in the two halves of the cell):\n\tif (abs(c) >= (repetitions/2.)) c = abs(c);\n\treturn c;\n}\n\n// Repeat space along one axis. Use like this to repeat along the x axis:\n// <float cell = pMod1(p.x,5);> - using the return value is optional.\nfloat pMod1(inout float p, float size) {\n\tfloat halfsize = size*0.5;\n\tfloat c = floor((p + halfsize)/size);\n\tp = mod(p + halfsize, size) - halfsize;\n\treturn c;\n}\n\nvec2 pMod2(inout vec2 p, vec2 size) {\n\tvec2 c = floor((p + size*0.5)/size);\n\tp = mod(p + size*0.5,size) - size*0.5;\n\treturn c;\n}\n\n// Repeat only a few times: from indices <start> to <stop> (similar to above, but more flexible)\nfloat pModInterval1(inout float p, float size, float start, float stop) {\n\tfloat halfsize = size*0.5;\n\tfloat c = floor((p + halfsize)/size);\n\tp = mod(p+halfsize, size) - halfsize;\n\tif (c > stop) { //yes, this might not be the best thing numerically.\n\t\tp += size*(c - stop);\n\t\tc = stop;\n\t}\n\tif (c <start) {\n\t\tp += size*(c - start);\n\t\tc = start;\n\t}\n\treturn c;\n}\n\nfloat opS( float d1, float d2 )\n{\n    return max(-d1,d2);\n}\n\nfloat opU( float d1, float d2 )\n{\n    return min(d1,d2);\n}\n\nvec3 postEffects( in vec3 col, in vec2 uv, in float time )\n{    \n\t// vigneting\n    col *= .9 + .2 * snoise( vec3( sin( iTime + uv.x ), cos( iTime + uv.y ), 0. ) );\n\tcol *= 0.4+0.6*pow( 16.0*uv.x*uv.y*(1.0-uv.x)*(1.0-uv.y), 0.5 );\n    col += col * .1 * snoise( vec3( -uv.x * 400., uv.y * 400. , iTime * 2. ) );\n    \n    return col;\n}\n\n//------------------- CAMERA STUFF\n\nvec3 orbit(float phi, float theta, float radius)\n{\n\treturn vec3(\n\t\tradius * sin( phi ) * cos( theta ),\n\t\tradius * cos( phi ),\n\t\tradius * sin( phi ) * sin( theta )\n\t);\n}\n\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr )\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n\treturn mat3( cu, cv, cw );\n}\n\n//------------------- PRIMITIVES\n\nvec2 rotate2D(vec2 p, float a) {\n return p * mat2(cos(a), -sin(a), sin(a),  cos(a));\n}\n\nfloat pyramid( vec3 p, float h) {\n\tvec3 q=abs(p);\n\treturn max(-p.y, (q.x*1.5+q.y *.75+q.z*1.5-h)/3.0 );\n}\n\nfloat sphere( vec3 p, float r ) {\n\treturn length( p ) - r;\n}\n\nfloat udRoundBox( vec3 p, vec3 b, float r )\n{\n  return length(max(abs(p)-b,0.0))-r;\n}\n\n// Box: correct distance to corners\nfloat fBox(vec3 p, vec3 b) {\n\tvec3 d = abs(p) - b;\n\treturn length(max(d, vec3(0))) + vmax(min(d, vec3(0)));\n}\n\n\n//------------------- MAP\n\nfloat opTwist( vec3 p )\n{\n    float c = cos(20.0*p.y);\n    float s = sin(20.0*p.y);\n    mat2  m = mat2(c,-s,s,c);\n    vec3  q = vec3(m*p.xz,p.y);\n    return udRoundBox( q, vec3( 2.5, .025, 0.005 ), .05 );\n}\n\nfloat opCheapBend( vec3 p )\n{\n    float c = cos(20.0*p.y);\n    float s = sin(20.0*p.y);\n    mat2  m = mat2(c,-s,s,c);\n    vec3  q = vec3(m*p.xy,p.z);\n    return udRoundBox( q, vec3( 2.5, .025, 0.005 ), .05 );\n}\n\nfloat repeatObj1( vec3 p ) {\n    \n    float res;\n    \n    vec3 op = p;\n\n    float idx1 = pModPolar( op.xy, 8. );\n    op.x -= 3.;\n    op.xy = rotate2D( op.xy, PI * .5 + sin( idx1 + iTime + p.x ) * .15 );\n    \n    float idx2 = pModInterval1( op.y, .22, -2., 2. );\n    op.z += sin( idx2 + p.x + iTime ) * .1;\n    op.xy = rotate2D( op.xy, PI * .05 * sin( idx2 ) );\n    //op.zy = rotate2D( op.zy, PI * sin( idx2 ) );\n    \n    float idx3 = pModInterval1( op.z, .17, -2., 2. );\n    op.xy = rotate2D( op.xy, PI * .05 * sin( idx3 ) );\n    \n    float idx4 = pModInterval1( op.x, .15, -2., 2. );\n    op.xy = rotate2D( op.xy, PI * .05 * sin( idx4 ) );\n    \n    float obj = fBox( op, vec3( .5, .025, 0.005 ) );\n    return obj;\n    \n}\n\nfloat repeatObj2( vec3 p ) {\n    \n    float res;\n    \n    vec3 op = p;\n\n    //op.xy = rotate2D( op.xy, PI  );\n    float idx1 = pModPolar( op.xy, 24. );\n    op.x -= 3.5;\n    op.xy = rotate2D( op.xy, PI * .5 );// + sin( idx1 + iTime ) * .15 );\n    \n    float idx2 = pModInterval1( op.y, .4, -2., 2. );\n    op.z += sin( idx2 ) * .1;\n    op.xz = rotate2D( op.xz, PI * .05 * sin( cos( idx2 * idx1 + iTime * 0. ) ) );\n    op.y = rotate2D( op.xy, PI * .05 * sin( idx2 ) ).x;\n    op.xz = rotate2D( op.xz, PI * sin( idx2 + iTime ) );\n    //op.xy = rotate2D( op.xz * 1., PI * sin( idx2 + iTime ) );\n    op.zy = rotate2D( op.zy, PI * sin( idx2 + iTime ) );\n    \n    float idx3 = pModInterval1( op.z, .17, -2., 2. );\n    op.xy = rotate2D( op.xy, PI * .05 * sin( idx3 + p.x * p.y + iTime * 0. ) );\n    \n    float idx4 = pModInterval1( op.x, .5, -2., 0. );\n    //op.y -= idx4 * p.y;\n    //op.xz = rotate2D( op.xz, PI * sin( idx4 )* cos( idx4 ) + iTime);\n    \n    //op.x += .25 * sin( idx1 );\n    \n    \n    float obj =  fBox( op, vec3( 1., .05, 0.05 ) );\n    return obj;\n    \n}\n\nfloat repeatObj3( vec3 p ) {\n    \n    float res;\n    \n    vec3 op = p;\n    op.z += 2.0;\n\n    //op.xy = rotate2D( op.xy, PI  );\n    float idx1 = pModPolar( op.xy, 12. );\n    op.x -= 1.5;\n    op.xy = rotate2D( op.xy, PI * .5 );// + sin( idx1 + iTime ) * .15 );\n    \n    float idx2 = pModInterval1( op.y, .5, -2., 2. );\n    op.z += sin( idx2 ) * .1;\n    op.xz = rotate2D( op.xz, PI * .05 * sin( cos( idx2 * idx1 + iTime * 5. ) ) );\n    op.y = rotate2D( op.xy, PI * .05 * sin( idx2 ) ).x;\n    op.xz = rotate2D( op.xz, PI * sin( idx2 + iTime ) );\n    //op.xy = rotate2D( op.xz * 1., PI * sin( idx2 + iTime ) );\n    op.zy = rotate2D( op.zy, PI * sin( idx2 + iTime ) );\n    \n    float idx3 = pModInterval1( op.z, .4, -2., 2. );\n    op.xy = rotate2D( op.xy, PI * .05 * sin( idx3 + p.x * p.y + iTime * 5. ) );\n    \n    float idx4 = pModInterval1( op.x, .5, -2., 0. );\n    //op.y -= idx4 * p.y;\n    //op.xz = rotate2D( op.xz, PI * sin( idx4 )* cos( idx4 ) + iTime);\n    \n    //op.x += .25 * sin( idx1 );\n    \n    \n    float obj =  fBox( op, vec3( 1., .05, 0.05 ) );\n    return obj;\n    \n}\n\nfloat map( in vec3 p ) {\n    vec3 np = vec3( p.x, p.y, p.z + .25 );\n    \n    float res;\n    float obj1 = repeatObj1( np );\n    float obj2 = repeatObj2( np );\n    float obj3 = repeatObj3( np );\n    res = obj1;\n    //return obj3;\n    //res = repeatObj1( p );\n    //res = opU( res, repeatObj2( p ) );\n   //res = repeatObj2( p );\n    \n    //float f = p.y - .4;\n    //r = opU( r, f );\n    \n    float k = 1.75;\n    float h = clamp( 0.5 + 0.5 * ( obj1 - obj2 ) / k, 0.0, 1.0 );\n    \n    res = mix( obj1, obj1, h ) - k*h*( 1.0 - h );\n    \n    //k = 2.;\n    h = clamp( 0.5 + 0.5 * ( res - obj2 ) / k, 0.0, 1.0 );\n    res = mix( res, obj2, h ) - k*h*( 1.0 - h );\n    \n    h = clamp( 0.5 + 0.5 * ( res - obj3 ) / k, 0.0, 1.0 );\n    res = mix( res, obj3, h ) - k*h*( 1.0 - h );\n    \n    //res = opU( res, obj3 );\n    //res = obj3;\n    \n    \n    return res;\n}\n\n//------------------- RAYMARCHING\n\n#ifdef RENDER_DEPTH\nfloat castRay( in vec3 ro, in vec3 rd, inout float depth ) {\n#else\nfloat castRay( in vec3 ro, in vec3 rd ) {\n#endif\n    float t = 0.;\n    float res;\n    for( int i = 0; i < RAYMARCHING_STEP; i++ ) {\n        vec3 pos = ro + rd * t;\n        res = map( pos );\n        if( res < .025 || t > 100. ) break;\n        t += res * RAYMARCHING_JUMP;\n        #ifdef RENDER_DEPTH\n\t\tdepth += 1./float(RAYMARCHING_STEP);\n\t\t#endif\n    }\n    return t;\n}\n\nvec3 calcNormal(vec3 pos) {\n    float eps = 0.001;\n\tconst vec3 v1 = vec3( 1.0,-1.0,-1.0);\n\tconst vec3 v2 = vec3(-1.0,-1.0, 1.0);\n\tconst vec3 v3 = vec3(-1.0, 1.0,-1.0);\n\tconst vec3 v4 = vec3( 1.0, 1.0, 1.0);\n\treturn normalize( v1 * map( pos + v1*eps ) +\n    \t              v2 * map( pos + v2*eps ) +\n        \t          v3 * map( pos + v3*eps ) +\n            \t      v4 * map( pos + v4*eps ) );\n}\n\nfloat calcAO( in vec3 p, in vec3 n, float maxDist, float falloff ){\n\tfloat ao = 0.0;\n\tconst int nbIte = 6;\n\tfor( int i=0; i<nbIte; i++ )\n\t{\n\t\tfloat l = hash(float(i))*maxDist;\n\t\tvec3 rd = n*l;\n\t\tao += (l - map( p + rd )) / pow(1.+l, falloff);\n\t}\n\treturn clamp( 1.-ao/float(nbIte), 0., 1.);\n}\n\n// calculate local thickness\n// base on AO but : inverse the normale & inverse the color\nfloat thickness( in vec3 p, in vec3 n, float maxDist, float falloff )\n{\n\tfloat ao = 0.0;\n\tconst int nbIte = 6;\n\tfor( int i=0; i<nbIte; i++ )\n\t{\n\t\tfloat l = hash(float(i))*maxDist;\n\t\tvec3 rd = -n*l;\n\t\tao += (l + map( p + rd )) / pow(1.+l, falloff);\n\t}\n\treturn clamp( 1.-ao/float(nbIte), 0., 1.);\n}\n    \nvec3 sundir = normalize( vec3(-1.5,2.,-1.5) );\n\nvec3 addLight( in vec3 posLight, in vec3 colLight, in vec3 nor, in vec3 pos, in vec3 ref, in float radius, in float specRatio ) {\n    float thi = thickness(pos, nor, 6., 1.5);\n    \n    float intens = max( dot( nor, posLight ), 0. );\n    float dist = length( posLight - pos );\n    float att = clamp(1.0 - dist*dist/(radius*radius), 0.0, 1.0);\n    att *= att;\n    float specular = pow( clamp( dot( ref, posLight ), 0., .5 ), 16. );\n    vec3 col = colLight * intens * att;\n    col += specular * .5 * att;\n    return col;\n}\n    \nvec3 render( in vec3 ro, in vec3 rd, in vec2 uv ) {\n\tvec3 col = vec3( 1., .0, 1. );\n    //vec3 colBg = vec3(0.0, 0., 0.) - rd.y*0.2*vec3(1., 1., 0.) + 0.15*0.5;\n\t//colBg += 0.2*vec3(1.0,0.,0.1)*pow( sun, 2.0 );\n    \n    float sun = clamp( dot(sundir,rd), 0.0, 1.0 );\n    vec3 colBg = vec3( 0.152, 0.898, 0.513 ) -  rd.y * .5*vec3( 0.298, 0.474, 0.494 ) + 0.15 * .55;\n\t//colBg += 0.2*vec3( 0.298, 0.474, 0.494 )*pow( sun, 2.0 );\n    //colBg = vec3(cos( uv.y * uv.x ) * .1,cos( uv.y ) * .95,sin( uv.x ) + cos( uv.y ) * .5 ) / 15.;\n    //colBg = vec3( 1. );\n    //colBg = vec3( 1. - length( rd.xy - vec2( .25, .5 ) ) ) * vec3( 0.152, 0.898, 0.513 );\n    \n    //colBg = mix( vec3( 0.298, 0.474, 0.494 ) * .25, vec3( 0.152, 0.898, 0.513 ) * .9, sin( uv.y ) );\n    \n    #ifdef RENDER_DEPTH\n\tfloat depth = 0.;\n    float t = castRay( ro, rd, depth );\n    #else\n    float t = castRay( ro, rd );\n    #endif\n    \n    #ifdef RENDER_DEPTH\n    return vec3( depth / 5., depth, depth );\n    #endif\n    \n    vec3 pos = ro + t * rd;\n    vec3 nor = calcNormal( pos );\n    \n    #ifdef RENDER_NORMAL\n    return nor;\n    #endif\n    \n    float ao = calcAO( pos, nor, 10., 1.2 );\n    #ifdef RENDER_AO\n    return vec3( ao );\n    #endif\n    \n    //vec3 light = vec3( 1.5, 1., 1. );\n    \n    vec3 ref = reflect( rd, nor );\n    \n    col = colBg;\n    if( t < 20. ) {\n        col = mix( col, vec3( .988, 0.152, .482 ), .8 );\n    }\n    // top blue light\n    //col += addLight( vec3( .3, 5.,1. ), vec3( .498, .898, .952 ), nor, pos, ref, 6., 1. );\n    \n    // right green dark\n    col += addLight( vec3( .0, .0, .1 ), vec3( 0.152, 0.898, 0.513 ), nor, pos, ref, 6.25, 0. );\n    // bottom right blue light\n    col += addLight( vec3( 5., -2., 1.85 ), vec3( .988, 0.152, .482 ), nor, pos, ref, 4., 0. );\n    // bottom left red\n    col += addLight( vec3( -4., 0., 1.85 ), vec3( 0.79, .168, .015 ), nor, pos, ref, 6., 0.25 );\n    \n   // col += addLight( vec3( 0., 1.5, 1.5 ), vec3( 1., .0, 0. ), nor, pos, ref, 3.5, 0.5 );\n    \n   // col += .35 * addLight( vec3( 0.21, 2.85, .0 ), vec3( 1., 0.79, .16 ), nor, pos, ref, 4., .0 );\n   \n    //col += 1.1 * vec3( 1., 0.4, 0.2 ) * abs( pow( sun, 3. ) );\n    //col += 2.1 * vec3( 1., 0.79, .16 ) * abs( pow( sun, 24. ) );\n    col += addLight( vec3( .3, 5.,1. ), vec3( 0.152, 0.898, 0.513 ), nor, pos, ref, 6., 1. );\n    col *= ao;\n    \n    vec3 fog = vec3( EPSILON );\n    col = mix( col, colBg, 1. - exp( -.0255 * t * t ) );   \n    \n    col = col;\n    \n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 p = -1. + 2. * uv;\n    p.x *= iResolution.x / iResolution.y;\n    \n    //vec2 m = iMouse.xy/iResolution.xy;\n    \n    // Camera\n\t\n\t//vec3 ta  = vec3( EPSILON, +.4, .5 );\n    float radius = 4.5;\n    vec3 ro = orbit( PI/2.,PI/2.,radius );\n    //vec3 ro = vec3( 0., 0., 5. );//orbit(0.,EPSILON,radius);\n    vec3 ta = vec3( EPSILON, EPSILON, EPSILON );\n    //ta.y = 1.;\n   \n    // Camera to world transformation\n    mat3 ca = setCamera( ro, ta, EPSILON );\n    \n    // Ray direction\n    vec3 rd = ca * normalize( vec3( p.xy, 1. ) );\n    \n    // Raymarching\n    vec3 c = render( ro, rd, uv );\n    c.r = smoothstep(0.2, 1.0, c.r + .12);\n\tc.g = smoothstep(0.0, 1.0, c.g - 0.21);\n\tc.b = smoothstep(-0.3, 1.3, c.b);\n    c = postEffects( c, uv, 0. );\n    fragColor = vec4( c, 1. );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4dt3W2.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "4dV3Dh", "name": "Colorful tris", "author": "zlnimda", "description": "I was inspired by some wallpaper on android devices showing some triangles with a lot of colors. I wanted to see that with animations.\nI first coded it on a shader app on android when i had some time. (non continuous work)", "tags": ["2d", "triangles", "colors"], "likes": 38, "viewed": 1717, "date": "1454274889", "time_retrieved": "2024-06-20T18:29:54.064114", "image_code": "/* ----------------------------------------------------------------------------\n * \"THE BEER-WARE LICENSE\" (Revision 42):\n * zlnimda (Nimda@zl) wrote this file.  As long as you retain this notice you\n * can do whatever you want with this stuff. If we meet some day, and you think\n * this stuff is worth it, you can buy me a beer in return.\n * ----------------------------------------------------------------------------\n */\n\nprecision highp float;\n\nuniform float time;\nuniform vec2 touch;\nuniform vec2 resolution;\n\nfloat rand(vec2 co)\n{\n    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nfloat GetLocation(vec2 s, float d)\n{\n    vec2 f = s*d;\n\n    //s = mix(vec2(0), floor(s*d),step(0.5, f));\n\n    // tris\n    f = mod(f, 8.); // because i failed somewhere\n    \n    f = f + vec2(0,0.5)*floor(f).x;\n    s = fract(f);\n    f = floor(f);\n\n    d = s.y - 0.5;\n    float l = abs(d) + 0.5 * s.x;\n    float ff = f.x+f.y;\n    f = mix(f, f+sign(d)*vec2(0,0.5), step(0.5, l));\n    l = mix(ff, ff+sign(d)*0.5, step(0.5, l));\n\n    return l * rand(vec2(f));\n}\n\nvec3 hsv2rgb(float h, float s, float v)\n{\n    h = fract(h);\n    vec3 c = smoothstep(2./6., 1./6., abs(h - vec3(0.5, 2./6., 4./6.)));\n    c.r = 1.-c.r;\n    /*\n    vec3 c = vec3(\n    smoothstep(1./6., 2./6., abs(h -0.5)),\n        1.-smoothstep(1./6., 2./6., abs(h -2./6.)),\n        1.-smoothstep(1./6., 2./6., abs(h -4./6.))\n        );*/\n    return mix(vec3(s), vec3(1.0), c) * v;\n}\n\nvec3 getRandomColor(float f, float t)\n{\n    return hsv2rgb(f+t, 0.2+cos(sin(f))*0.3, 0.9);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float mx = max( iResolution.x, iResolution.y );\n    float t = iTime*0.3;\n    vec2 s = fragCoord.xy / mx + vec2(t, 0) * 0.2;\n\n    float f[3];\n    f[0] = GetLocation(s, 12.);\n    f[1] = GetLocation(s, 6.);\n    f[2] = GetLocation(s, 3.);\n\n    vec3 color = getRandomColor(f[1] *0.05 + 0.01*f[0] + 0.9*f[2], t);\n\n    fragColor = vec4(color, 1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "beerware", "thumbnail": "https://www.shadertoy.com/media/shaders/4dV3Dh.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "4dV3Rm", "name": "Atari ST Union Demo Intro", "author": "zippycoder", "description": "Old skool Atari ST Union Demo intro as a shadertoy. Original demo video - https://www.youtube.com/watch?v=l2i859S_4no", "tags": ["2d", "retro", "demo", "chiptune", "atari"], "likes": 11, "viewed": 549, "date": "1454023403", "time_retrieved": "2024-06-20T18:29:56.094524", "image_code": "// Atari ST Union Demo old skool intro recreated using ShaderToy fragment shader\n// Created by Simon Morris (ZippyCoder)\n// License: Creative Commons CC0 1.0 Universal (CC-0) \n//  \n// Inspired by other ShaderToy work:\n// Gerard Geer - https://www.shadertoy.com/view/4dtGD2\n// P_Malin - https://www.shadertoy.com/view/4sBSWW\n// Uses Gerard Geer's neat bit extraction approach with no division\n//\n// SoundCloud audioclip of Jochen Hippel's awesmome \"Ikari Union\" chiptune recorded by RockABit \n// https://soundcloud.com/rockabit/jochen-hippel-ikari-union?in=rockabit/sets/union-demo-jochen-hippel\n//\n// Update: Nov'20 - Audioclip is now my SN76489 version of this music ported from the YM original, since the original clip is no longer on SC.\n//\n// Original demo - https://www.youtube.com/watch?v=l2i859S_4no\n//\n// ---------------------------------------------------------------------------------------\n// My first shadertoy project, so probably not as optimized as it could be. \n//\n// The bitmaps were encoded into shader functions from source GIF/PNG images using \n// a python scipt I threw together - https://github.com/simondotm/shadertoys\n// The logo is 4-bits per pixel, the background is 2-bit and the text is 1-bit\n// all packed into vec4's so there's less if checks when decoding.\n// I was originally going to render/animate each text letter individually \n// but in the end I just took a shortcut and rendered the whole text as one image.\n// I also tried unpacking the bitmaps to a separate buffer first, thinking that texture lookup\n// might be faster than computing each pixel from encoded floats, but it actually seemed slower.\n// ----------------------------------------------------------------------------------------\n\n\n\nvoid drawSpriteUnionDemoLogo( inout vec4 color, in float x, in float y )\n{\n\t\n\tvec4 tile = vec4(0.0);\n\t\n\t// unpack the bitmap on a row-by-row basis\n\tif (y == 0.0) tile = ( x < 24.0 ) ? vec4(0xeeeeee) : ( x < 48.0 ) ? vec4(0xaeeeee, 0xeeea03, 0xeeeeee, 0xeeeeee) : vec4(0xeeeeee, 0xeeeeee, 0x00eeee, 0x000000);\n\tif (y == 1.0) tile = ( x < 24.0 ) ? vec4(0xeeeeee) : ( x < 48.0 ) ? vec4(0x3eeeee, 0xeec09c, 0xeeeeee, 0xeeeeee) : vec4(0xeeeeee, 0xeeeeee, 0x00eeee, 0x000000);\n\tif (y == 2.0) tile = ( x < 24.0 ) ? vec4(0xeeeeee) : ( x < 48.0 ) ? vec4(0xc3eeee, 0xec3966, 0xeeeeee, 0xeeeeee) : vec4(0xeeeeee, 0xeeeeee, 0x00eeee, 0x000000);\n\tif (y == 3.0) tile = ( x < 24.0 ) ? vec4(0xeeeeee) : ( x < 48.0 ) ? vec4(0x9a3eee, 0xc3ae66, 0xeeeeee, 0xeeeeee) : vec4(0xeeeeee, 0xeeeeee, 0x00eeee, 0x000000);\n\tif (y == 4.0) tile = ( x < 24.0 ) ? vec4(0xeeeeee) : ( x < 48.0 ) ? vec4(0xe9a0ee, 0x3a6e66, 0xeeeeec, 0xeeeeee) : vec4(0xeeeeee, 0xeeeeee, 0x00eeee, 0x000000);\n\tif (y == 5.0) tile = ( x < 24.0 ) ? vec4(0xeeeeee) : ( x < 48.0 ) ? vec4(0xee6a3e, 0xae6e66, 0xeeeee3, 0xeeeeee) : vec4(0xeeeeee, 0xeeeeee, 0x00eeee, 0x000000);\n\tif (y == 6.0) tile = ( x < 24.0 ) ? vec4(0xeeeeee) : ( x < 48.0 ) ? vec4(0xe6e9a0, 0xee6e66, 0xeeeeaa, 0xeeeeee) : vec4(0xeeeeee, 0xeeeeee, 0x00eeee, 0x000000);\n\tif (y == 7.0) tile = ( x < 24.0 ) ? vec4(0xeeeeee, 0xeeeeee, 0xeeeeee, 0x0eeeee) : ( x < 48.0 ) ? vec4(0xe66e9a, 0x6e6e64, 0xeeea3e, 0xeeeeee) : vec4(0xeeeeee, 0xeeeeee, 0x00eeee, 0x000000);\n\tif (y == 8.0) tile = ( x < 24.0 ) ? vec4(0xeeeeee, 0xeeeeee, 0xeeeeee, 0xa0eeee) : ( x < 48.0 ) ? vec4(0xe66ee9, 0xee6eee, 0xeea066, 0xeeeeee) : vec4(0xeeeeee, 0xeeeeee, 0x00eeee, 0x000000);\n\tif (y == 9.0) tile = ( x < 24.0 ) ? vec4(0xeeeeee, 0xeeeeee, 0xeeeeee, 0x9a3eee) : ( x < 48.0 ) ? vec4(0xe66e4e, 0x4e6e64, 0xea0666, 0xeeeeee) : vec4(0xeeeeee, 0xeeeeee, 0x00eeee, 0x000000);\n\tif (y == 10.0) tile = ( x < 24.0 ) ? vec4(0xeeeeee, 0xeeeeee, 0xeeeeee, 0x99a3ee) : ( x < 48.0 ) ? vec4(0xe46e64, 0xee6e44, 0xa06eee, 0xeeeeee) : vec4(0xeeeeee, 0xeeeeee, 0x00eeee, 0x000000);\n\tif (y == 11.0) tile = ( x < 24.0 ) ? vec4(0x58eeee, 0xeeee82, 0x8258ee, 0x499a3e) : ( x < 48.0 ) ? vec4(0x666646, 0x646666, 0x066666, 0x55eeea) : vec4(0xeeeee5, 0xec88ee, 0x00eeee, 0x000000);\n\tif (y == 12.0) tile = ( x < 24.0 ) ? vec4(0x22eeee, 0xeeee88, 0x8122ee, 0x469ca3) : ( x < 48.0 ) ? vec4(0x664644, 0x666466, 0x946666, 0x22eea3) : vec4(0xeeee81, 0xe125ee, 0x00eeee, 0x000000);\n\tif (y == 13.0) tile = ( x < 24.0 ) ? vec4(0x22eeee, 0xeeee88, 0x8112ee, 0x4669ca) : ( x < 48.0 ) ? vec4(0x666646, 0x666666, 0x466666, 0x15ea39) : vec4(0xeee812, 0xe211ee, 0x00eeee, 0x000000);\n\tif (y == 14.0) tile = ( x < 24.0 ) ? vec4(0x22eeee, 0xeeee88, 0x8212ee, 0x44822c) : ( x < 48.0 ) ? vec4(0x465266, 0x266621, 0x021122, 0x25c352) : vec4(0xee8201, 0xe025ee, 0x00eeee, 0x000000);\n\tif (y == 15.0) tile = ( x < 24.0 ) ? vec4(0x22eeee, 0xeeee88, 0x8221ee, 0x652129) : ( x < 48.0 ) ? vec4(0x642246, 0x256611, 0x221022, 0x020612) : vec4(0xe12212, 0xe012ee, 0x00eeee, 0x000000);\n\tif (y == 16.0) tile = ( x < 24.0 ) ? vec4(0x21eeee, 0xeeee88, 0x8222ee, 0x802214) : ( x < 48.0 ) ? vec4(0x642244, 0x256601, 0x566662, 0x256420) : vec4(0x820221, 0xe215ee, 0x00eeee, 0x000000);\n\tif (y == 17.0) tile = ( x < 24.0 ) ? vec4(0x22d7ee, 0xbbbd88, 0x8022bb, 0x22122d) : ( x < 48.0 ) ? vec4(0xdd22b8, 0x25dd21, 0x5bbbd2, 0x05dd20) : vec4(0x2120d2, 0xe225e8, 0x00eedd, 0x000000);\n\tif (y == 18.0) tile = ( x < 24.0 ) ? vec4(0x22ddde, 0xdddd88, 0x8222b7, 0x22d12b) : ( x < 48.0 ) ? vec4(0xbd2251, 0x25bd21, 0x5bbbb2, 0x22bd12) : vec4(0x121bd2, 0xd12282, 0x00eddd, 0x000000);\n\tif (y == 19.0) tile = ( x < 24.0 ) ? vec4(0x77dddd, 0x7dddbb, 0xb777db, 0x7bb77b) : ( x < 48.0 ) ? vec4(0xbb7777, 0x77bb77, 0xbbbbb7, 0x7bbb77) : vec4(0x7bbbd7, 0xd77b77, 0x00dddd, 0x000000);\n\tif (y == 20.0) tile = ( x < 24.0 ) ? vec4(0xbbbddd, 0xddeedd, 0xddbbbd, 0xdddbbd) : ( x < 48.0 ) ? vec4(0xddbbbb, 0xbdddbb, 0xdddddb, 0xbddbbd) : vec4(0xddddbb, 0xbbbbbb, 0x00dbbb, 0x000000);\n\tif (y == 21.0) tile = ( x < 24.0 ) ? vec4(0x22eeee, 0x828582, 0x821288, 0x646226) : ( x < 48.0 ) ? vec4(0x662226, 0x266621, 0x122211, 0x256662) : vec4(0xec3a62, 0xe02221, 0x00eeee, 0x000000);\n\tif (y == 22.0) tile = ( x < 24.0 ) ? vec4(0x25eeee, 0x222021, 0x822022, 0x646666) : ( x < 48.0 ) ? vec4(0x666666, 0x664666, 0x464466, 0x226666) : vec4(0xe3a642, 0xe2012e, 0x00eeee, 0x000000);\n\tif (y == 23.0) tile = ( x < 24.0 ) ? vec4(0x1eeeee, 0x222122, 0x822212, 0x666666) : ( x < 48.0 ) ? vec4(0x666669, 0x646666, 0x464449, 0x254966) : vec4(0xaa6661, 0xe222ee, 0x00eeee, 0x000000);\n\tif (y == 24.0) tile = ( x < 24.0 ) ? vec4(0xdeeeee, 0x222118, 0x422211, 0x666666) : ( x < 48.0 ) ? vec4(0x666669, 0x966666, 0x666644, 0x664466) : vec4(0x066664, 0xe12eea, 0x00eeee, 0x000000);\n\tif (y == 25.0) tile = ( x < 24.0 ) ? vec4(0xeeeeee, 0x4669a0, 0x646664, 0x666666) : ( x < 48.0 ) ? vec4(0x666666, 0x666666, 0x666666, 0x466666) : vec4(0x6666c6, 0xeeeea0, 0x00eeee, 0x000000);\n\tif (y == 26.0) tile = ( x < 24.0 ) ? vec4(0x0eeeee, 0x44496a, 0x6cc466, 0xcc66cc) : ( x < 48.0 ) ? vec4(0xcc6c66, 0x9c6c6c, 0xcc6c4c, 0x6c6c6c) : vec4(0x6666c6, 0xeeea06, 0x00eeee, 0x000000);\n\tif (y == 27.0) tile = ( x < 24.0 ) ? vec4(0xa0eeee, 0x644666, 0x666c64, 0x6c66cc) : ( x < 48.0 ) ? vec4(0xc4c6c6, 0x6c6c66, 0xc66c6c, 0x6cc446) : vec4(0x646666, 0xeea066, 0x00eeee, 0x000000);\n\tif (y == 28.0) tile = ( x < 24.0 ) ? vec4(0x630eee, 0x444446, 0x6cc466, 0xcc6c4c) : ( x < 48.0 ) ? vec4(0xc6c6c9, 0xc96c66, 0xc66c66, 0x66cc64) : vec4(0x4666c6, 0xea0646, 0x00eeee, 0x000000);\n\tif (y == 29.0) tile = ( x < 24.0 ) ? vec4(0x6c3aee, 0x666444, 0x466646, 0x466644) : ( x < 48.0 ) ? vec4(0x646466, 0x666444, 0x464666, 0x666666) : vec4(0x646466, 0xa09464, 0x00eeee, 0x000000);\n\tif (y == 30.0) tile = ( x < 24.0 ) ? vec4(0x0000ee, 0x000000, 0x000000, 0x000000) : ( x < 48.0 ) ? vec4(0x000000) : vec4(0x000000, 0x300000, 0x00eeec, 0x000000);\n\tif (y == 31.0) tile = ( x < 24.0 ) ? vec4(0xccccee, 0xcccccc, 0xcccccc, 0xcccccc) : ( x < 48.0 ) ? vec4(0xcccccc) : vec4(0xcccccc, 0xcccccc, 0x00eeee, 0x000000);\n\t\n\tfloat n = mod(x, 24.0); // quantize x coordinate to nearest 24 pixels and get float containing 6 pixels\n\tfloat t = ( ( n < 6.0 ) ? tile.x : ( n < 12.0 ) ? tile.y : (n < 18.0 ) ? tile.z : tile.w );\n\tfloat p = mod( x, 6.0 ) * 4.0; // quantize x coordinate to nearest 6 pixels to determine pixel bit index\n    int idx = int( mod( floor( t*exp2(-p) ), 16.0 ));\n    \n\t// look up colour palette for the indexed pixel\n\tif (idx == 0) color = vec4(0.913725, 0.913725, 0.913725, 1.0);\n\tif (idx == 1) color = vec4(0.913725, 0.913725, 0.309804, 1.0);\n\tif (idx == 2) color = vec4(0.913725, 0.670588, 0.309804, 1.0);\n\tif (idx == 3) color = vec4(0.670588, 0.670588, 0.670588, 1.0);\n\tif (idx == 4) color = vec4(0.670588, 0.670588, 0.431373, 1.0);\n\tif (idx == 5) color = vec4(0.913725, 0.552941, 0.670588, 1.0);\n\tif (idx == 6) color = vec4(0.552941, 0.552941, 0.309804, 1.0);\n\tif (idx == 7) color = vec4(0.431373, 0.552941, 0.913725, 1.0);\n\tif (idx == 8) color = vec4(0.792157, 0.431373, 0.309804, 1.0);\n\tif (idx == 9) color = vec4(0.552941, 0.431373, 0.309804, 1.0);\n\tif (idx == 10) color = vec4(0.431373, 0.431373, 0.431373, 1.0);\n\tif (idx == 11) color = vec4(0.309804, 0.431373, 0.913725, 1.0);\n\tif (idx == 12) color = vec4(0.309804, 0.309804, 0.309804, 1.0);\n\tif (idx == 13) color = vec4(0.188235, 0.188235, 0.792157, 1.0);\n\tif (idx == 14) color = vec4(0.070588, 0.070588, 0.070588, 0.0);\n\tif (idx == 15) color = vec4(0.000000, 0.000000, 0.000000, 0.0);\n}\n\n\nvoid drawSpriteUnionBackground( inout vec4 color, float x, float y )\n{\n\t\n\tvec4 tile = vec4(0.0);\n\t\n\t// unpack the bitmap on a row-by-row basis\n\tif (y == 0.0) tile = vec4(0xe46e6e, 0x1ba41a, 0xfbae6e, 0xffffff);\n\tif (y == 1.0) tile = vec4(0xffffff);\n\tif (y == 2.0) tile = vec4(0xffffff, 0xffffff, 0xbbffff, 0xbb6e6e);\n\tif (y == 3.0) tile = vec4(0x9bbfbf, 0xfefffb, 0xfffe6f, 0xffffff);\n\tif (y == 4.0) tile = vec4(0xbfffff, 0xffeeae, 0xffffff, 0xeb9bae);\n\tif (y == 5.0) tile = vec4(0xffffff);\n\tif (y == 6.0) tile = vec4(0xae6e56, 0xbbefbb, 0x6e91b9, 0xbaffae);\n\tif (y == 7.0) tile = vec4(0xffffff);\n\tif (y == 8.0) tile = vec4(0xffffff, 0xffffff, 0xb9baff, 0xffbb95);\n\tif (y == 9.0) tile = vec4(0x1b9bef, 0x9b96e9, 0xffffeb, 0xffffff);\n\tif (y == 10.0) tile = vec4(0xffffff, 0xffffff, 0xbaeeff, 0xeb9b91);\n\tif (y == 11.0) tile = vec4(0xfffeeb, 0xffffff, 0xffffff, 0xbfffff);\n\tif (y == 12.0) tile = vec4(0xffffff);\n\tif (y == 13.0) tile = vec4(0x1b9b9f, 0xe79b99, 0xffffbe, 0xafbeff);\n\tif (y == 14.0) tile = vec4(0xffffff, 0xffffff, 0x9bafff, 0xfffffb);\n\tif (y == 15.0) tile = vec4(0xebabaf, 0xfffffe, 0xfffeeb, 0xbfffff);\n\tif (y == 16.0) tile = vec4(0xffffff, 0xbaffff, 0xffffff, 0xffffff);\n\tif (y == 17.0) tile = vec4(0xeffbeb, 0xfffaea, 0x7efbff, 0xeb6d2e);\n\tif (y == 18.0) tile = vec4(0xffffff, 0xffffff, 0xfffffb, 0xffffff);\n\tif (y == 19.0) tile = vec4(0xffffff, 0xffffff, 0xffffff, 0xbfffff);\n\tif (y == 20.0) tile = vec4(0xb9baef, 0xa41ae4, 0xb9b91b, 0xfeffbf);\n\tif (y == 21.0) tile = vec4(0xffffff);\n\tif (y == 22.0) tile = vec4(0xffffff);\n\tif (y == 23.0) tile = vec4(0xbae6e1, 0xfffeff, 0xbeffff, 0xb9baed);\n\tif (y == 24.0) tile = vec4(0xffffff, 0xafbfff, 0xffefab, 0xffffff);\n\tif (y == 25.0) tile = vec4(0xffefff, 0xffffff, 0xffffff, 0xbfffff);\n\tif (y == 26.0) tile = vec4(0xffffff, 0x92ebef, 0x92e41b, 0xffeb9b);\n\tif (y == 27.0) tile = vec4(0xffffff);\n\tif (y == 28.0) tile = vec4(0xbae46e, 0xeffffb, 0xffffef, 0x6ebfff);\n\tif (y == 29.0) tile = vec4(0xffffff);\n\tif (y == 30.0) tile = vec4(0xfffffe, 0x7afafb, 0xef6e1e, 0xffeffb);\n\tif (y == 31.0) tile = vec4(0xfbffff, 0xffffff, 0xffffff, 0xffffff);\n\tif (y == 32.0) tile = vec4(0xffffff, 0xffffff, 0x6effff, 0xffffae);\n\tif (y == 33.0) tile = vec4(0x9b96e9, 0xefffeb, 0xffefff, 0x1b9bef);\n\tif (y == 34.0) tile = vec4(0xffffff);\n\tif (y == 35.0) tile = vec4(0xfeffef, 0x86e6eb, 0x86e41b, 0xfffbeb);\n\tif (y == 36.0) tile = vec4(0xffffff);\n\tif (y == 37.0) tile = vec4(0xbae6e4, 0xfffbe7, 0xffbfff, 0xb9baef);\n\tif (y == 38.0) tile = vec4(0xffffff, 0xffffff, 0xfffffe, 0xffffff);\n\tif (y == 39.0) tile = vec4(0xffffff);\n\tif (y == 40.0) tile = vec4(0x1b9bae, 0x9416b9, 0xe6e46e, 0xffffba);\n\tif (y == 41.0) tile = vec4(0xffffff, 0xffffff, 0xffffff, 0xffbfff);\n\tif (y == 42.0) tile = vec4(0xbabaef, 0xefffee, 0xe6e4ba, 0xafffba);\n\tif (y == 43.0) tile = vec4(0xffffff);\n\tif (y == 44.0) tile = vec4(0xeeb9b9, 0xffffff, 0xbebfbf, 0x1b92f9);\n\tif (y == 45.0) tile = vec4(0xffffff, 0xb9e6eb, 0xffffff, 0xffffff);\n\tif (y == 46.0) tile = vec4(0xfffffe, 0xffffff, 0xaeffff, 0xebfabf);\n\tif (y == 47.0) tile = vec4(0xffffff, 0xffffff, 0xffffff, 0xffbffb);\n\t\n\tfloat n = mod(x, 48.0); // quantize x coordinate to nearest 48 pixels and get float containing 12 pixels\n\tfloat t = ( ( n < 12.0 ) ? tile.x : ( n < 24.0 ) ? tile.y : (n < 36.0 ) ? tile.z : tile.w );\n\tfloat p = mod( x, 12.0 ) * 2.0; // quantize x coordinate to nearest 12 pixels to determine pixel bit index\n    int idx = int( mod( floor( t*exp2(-p) ), 4.0 ));\n                  \n\t// look up colour palette for the indexed pixel\n\tif (idx == 0) color = vec4(0.431373, 0.552941, 0.913725, 1.0);\n\tif (idx == 1) color = vec4(0.309804, 0.431373, 0.913725, 1.0);\n\tif (idx == 2) color = vec4(0.188235, 0.188235, 0.792157, 1.0);\n\tif (idx == 3) color = vec4(0.070588, 0.070588, 0.070588, 1.0);\n}\n\n\nvoid drawSpriteUnionLettersWhite( inout vec4 color, float x, float y )\n{\n\t\n\tvec4 tile = vec4(0.0);\n\t\n\t// unpack the bitmap on a row-by-row basis\n\tif (y == 0.0) tile = ( x < 96.0 ) ? vec4(0xc0c4c0, 0xccffff, 0xc0f3cc, 0xe0ffcc) : vec4(0xc09cc0, 0x0000f3, 0x000000, 0x000000);\n\tif (y == 1.0) tile = ( x < 96.0 ) ? vec4(0xc4c4f3, 0xccffff, 0xccf3c8, 0xccffc8) : vec4(0xcc88c4, 0x0000f3, 0x000000, 0x000000);\n\tif (y == 2.0) tile = ( x < 96.0 ) ? vec4(0xfcccf3, 0xccffff, 0xccf3c0, 0xccffc0) : vec4(0xcc80fc, 0x0000f3, 0x000000, 0x000000);\n\tif (y == 3.0) tile = ( x < 96.0 ) ? vec4(0xc0c0f3, 0xccffff, 0xc8f3c0, 0xccc040) : vec4(0xc894c0, 0x0000f3, 0x000000, 0x000000);\n\tif (y == 4.0) tile = ( x < 96.0 ) ? vec4(0xfcccf1, 0xc4ffff, 0xc8f1cc, 0xc8c04c) : vec4(0xc89cfc, 0x0000f3, 0x000000, 0x000000);\n\tif (y == 5.0) tile = ( x < 96.0 ) ? vec4(0xc4c8f1, 0xc4ffff, 0xc8f1c8, 0xc8ffc8) : vec4(0xc88cc4, 0x0000ff, 0x000000, 0x000000);\n\tif (y == 6.0) tile = ( x < 96.0 ) ? vec4(0xc0c8f1, 0xc0ffff, 0xc0f1c8, 0xc0ffc8) : vec4(0xc08cc0, 0x0000f3, 0x000000, 0x000000);\n\tif (y == 7.0) tile = ( x < 96.0 ) ? vec4(0xffffff) : vec4(0xffffff, 0x0000ff, 0x000000, 0x000000);\n\tif (y == 8.0) tile = ( x < 96.0 ) ? vec4(0xffffff) : vec4(0xffffff, 0x0000ff, 0x000000, 0x000000);\n\tif (y == 9.0) tile = ( x < 96.0 ) ? vec4(0xffffff) : vec4(0xffffff, 0x0000ff, 0x000000, 0x000000);\n\tif (y == 10.0) tile = ( x < 96.0 ) ? vec4(0xffffff) : vec4(0xffffff, 0x0000ff, 0x000000, 0x000000);\n\tif (y == 11.0) tile = ( x < 96.0 ) ? vec4(0xffffff) : vec4(0xffffff, 0x0000ff, 0x000000, 0x000000);\n\tif (y == 12.0) tile = ( x < 96.0 ) ? vec4(0xffffff) : vec4(0xffffff, 0x0000ff, 0x000000, 0x000000);\n\tif (y == 13.0) tile = ( x < 96.0 ) ? vec4(0xffffff) : vec4(0xffffff, 0x0000ff, 0x000000, 0x000000);\n\tif (y == 14.0) tile = ( x < 96.0 ) ? vec4(0xffffff) : vec4(0xffffff, 0x0000ff, 0x000000, 0x000000);\n\tif (y == 15.0) tile = ( x < 96.0 ) ? vec4(0xffffff) : vec4(0xffffff, 0x0000ff, 0x000000, 0x000000);\n\tif (y == 16.0) tile = ( x < 96.0 ) ? vec4(0xc0ffff, 0xc09cc0, 0xf3c4ff, 0xc0c0cc) : vec4(0xffffff, 0x0000ff, 0x000000, 0x000000);\n\tif (y == 17.0) tile = ( x < 96.0 ) ? vec4(0xc4ffff, 0xc488cc, 0xf3c4ff, 0xc4f3c8) : vec4(0xffffff, 0x0000ff, 0x000000, 0x000000);\n\tif (y == 18.0) tile = ( x < 96.0 ) ? vec4(0xfcffff, 0xfc80cc, 0xf3ccff, 0xfcf3c0) : vec4(0xfffff3, 0x0000ff, 0x000000, 0x000000);\n\tif (y == 19.0) tile = ( x < 96.0 ) ? vec4(0xe1ffff, 0xc094c8, 0xf3c0ff, 0xe1f3c0) : vec4(0xffffff, 0x0000ff, 0x000000, 0x000000);\n\tif (y == 20.0) tile = ( x < 96.0 ) ? vec4(0xcfffff, 0xfc9cc8, 0xf1ccff, 0xcff1cc) : vec4(0xffffff, 0x0000ff, 0x000000, 0x000000);\n\tif (y == 21.0) tile = ( x < 96.0 ) ? vec4(0xccffff, 0xc48cc8, 0xf1c8ff, 0xccf1c8) : vec4(0xfffff3, 0x0000ff, 0x000000, 0x000000);\n\tif (y == 22.0) tile = ( x < 96.0 ) ? vec4(0xc0ffff, 0xc08cc0, 0xf1c8ff, 0xc0f1c8) : vec4(0xffffff, 0x0000ff, 0x000000, 0x000000);\n\tif (y == 23.0) tile = ( x < 96.0 ) ? vec4(0xffffff) : vec4(0xffffff, 0x0000ff, 0x000000, 0x000000);\n\tif (y == 24.0) tile = ( x < 96.0 ) ? vec4(0xfffff3, 0xc0ccff, 0xc0ffc0, 0xccf8cc) : vec4(0xc4c0ff, 0x0000c0, 0x000000, 0x000000);\n\tif (y == 25.0) tile = ( x < 96.0 ) ? vec4(0xfffff1, 0xc4ccff, 0xccffc4, 0xccf8c8) : vec4(0xc4f3ff, 0x0000c4, 0x000000, 0x000000);\n\tif (y == 26.0) tile = ( x < 96.0 ) ? vec4(0xfffff0, 0xfcccff, 0xccfffc, 0xccf8c0) : vec4(0xccf3ff, 0x0000fc, 0x000000, 0x000000);\n\tif (y == 27.0) tile = ( x < 96.0 ) ? vec4(0xfffff3, 0xe1ccff, 0xc8ffc0, 0xc0f9c0) : vec4(0xc0f3ff, 0x0000c0, 0x000000, 0x000000);\n\tif (y == 28.0) tile = ( x < 96.0 ) ? vec4(0xfffff3, 0xcfc4ff, 0xc8fffc, 0xf3f9cc) : vec4(0xccf1ff, 0x0000fc, 0x000000, 0x000000);\n\tif (y == 29.0) tile = ( x < 96.0 ) ? vec4(0xfff3f3, 0xccc4ff, 0xc8ffc4, 0xe3c9c8) : vec4(0xc8f1ff, 0x0000c4, 0x000000, 0x000000);\n\tif (y == 30.0) tile = ( x < 96.0 ) ? vec4(0xfff3c0, 0xc0c0ff, 0xc0ffc0, 0xe3c1c8) : vec4(0xc8f1ff, 0x0000c0, 0x000000, 0x000000);\n\tif (y == 31.0) tile = ( x < 96.0 ) ? vec4(0xffffff) : vec4(0xffffff, 0x0000ff, 0x000000, 0x000000);\n\tif (y == 32.0) tile = ( x < 96.0 ) ? vec4(0xf3cce0, 0xffe0f8, 0xffccf3, 0xc0c0c0) : vec4(0xc0ffcc, 0x0000c0, 0x000000, 0x000000);\n\tif (y == 33.0) tile = ( x < 96.0 ) ? vec4(0xf3cce4, 0xffccf8, 0xffc8f3, 0xcccccc) : vec4(0xf3ffcc, 0x0000cc, 0x000000, 0x000000);\n\tif (y == 34.0) tile = ( x < 96.0 ) ? vec4(0xf3cce4, 0xffccf8, 0xffc0f3, 0xccccfc) : vec4(0xf3ffcc, 0x0000cc, 0x000000, 0x000000);\n\tif (y == 35.0) tile = ( x < 96.0 ) ? vec4(0xf3ccc0, 0xc04cf9, 0xffc0f3, 0xc0c8f8) : vec4(0xf3ffc0, 0x0000c8, 0x000000, 0x000000);\n\tif (y == 36.0) tile = ( x < 96.0 ) ? vec4(0xf1c4cc, 0xc048f9, 0xffccf1, 0xfcc8f8) : vec4(0xf1fff3, 0x0000c8, 0x000000, 0x000000);\n\tif (y == 37.0) tile = ( x < 96.0 ) ? vec4(0xf1c4cc, 0xffc8c9, 0xffc8f1, 0xf8c8c8) : vec4(0xf1ffe3, 0x0000c8, 0x000000, 0x000000);\n\tif (y == 38.0) tile = ( x < 96.0 ) ? vec4(0xf1c0c0, 0xffc0c1, 0xffc8f1, 0xf8c0c0) : vec4(0xf1ffe3, 0x0000c0, 0x000000, 0x000000);\n\tif (y == 39.0) tile = ( x < 96.0 ) ? vec4(0xffffff) : vec4(0xffffff, 0x0000ff, 0x000000, 0x000000);\n\tif (y == 40.0) tile = ( x < 96.0 ) ? vec4(0xc0cce0, 0xc0f3f8, 0xc0c0e1, 0xc0f3ff) : vec4(0xc0ccff, 0x0000c0, 0x000000, 0x000000);\n\tif (y == 41.0) tile = ( x < 96.0 ) ? vec4(0xcccccc, 0xccf3f8, 0xc4f3ed, 0xf3f3ff) : vec4(0xc4ccff, 0x0000c4, 0x000000, 0x000000);\n\tif (y == 42.0) tile = ( x < 96.0 ) ? vec4(0xcccccc, 0xfcf3f8, 0xfcf3ed, 0xf3f3ff) : vec4(0xfcccff, 0x0000fc, 0x000000, 0x000000);\n\tif (y == 43.0) tile = ( x < 96.0 ) ? vec4(0xc0cccc, 0xf8f3f9, 0xc0f3c0, 0xf3f3ff) : vec4(0xe1ccff, 0x0000c0, 0x000000, 0x000000);\n\tif (y == 44.0) tile = ( x < 96.0 ) ? vec4(0xfcc4c8, 0xf8f1f9, 0xfcf1cc, 0xf1f1ff) : vec4(0xcfc4ff, 0x0000fc, 0x000000, 0x000000);\n\tif (y == 45.0) tile = ( x < 96.0 ) ? vec4(0xf8c4c8, 0xc8f1c9, 0xc4f1c4, 0xf1f1ff) : vec4(0xccc4f3, 0x0000c4, 0x000000, 0x000000);\n\tif (y == 46.0) tile = ( x < 96.0 ) ? vec4(0xf8c0c0, 0xc0f1c1, 0xc0f1c4, 0xf1f1ff) : vec4(0xc0c0f3, 0x0000c0, 0x000000, 0x000000);\n\tif (y == 47.0) tile = ( x < 96.0 ) ? vec4(0xffffff) : vec4(0xffffff, 0x0000ff, 0x000000, 0x000000);\n\tif (y == 48.0) tile = ( x < 96.0 ) ? vec4(0x9cfff3, 0xffc0c0, 0xf3c0e0, 0xc0c0c4) : vec4(0xffffff, 0x0000ff, 0x000000, 0x000000);\n\tif (y == 49.0) tile = ( x < 96.0 ) ? vec4(0x88fff1, 0xffccc4, 0xf3cccc, 0xc4c4c4) : vec4(0xffffff, 0x0000ff, 0x000000, 0x000000);\n\tif (y == 50.0) tile = ( x < 96.0 ) ? vec4(0x80fff0, 0xfffcfc, 0xf3cccc, 0xfcfcc4) : vec4(0xffffff, 0x0000ff, 0x000000, 0x000000);\n\tif (y == 51.0) tile = ( x < 96.0 ) ? vec4(0x94fff3, 0xffc4c0, 0xf3c0cc, 0xe1c0cc) : vec4(0xffffff, 0x0000ff, 0x000000, 0x000000);\n\tif (y == 52.0) tile = ( x < 96.0 ) ? vec4(0x9cfff3, 0xffc4fc, 0xf1e4c8, 0xcffccc) : vec4(0xffffff, 0x0000ff, 0x000000, 0x000000);\n\tif (y == 53.0) tile = ( x < 96.0 ) ? vec4(0x8cfff3, 0xffccc4, 0xf1c4c8, 0xccc4e1) : vec4(0xfffff3, 0x0000ff, 0x000000, 0x000000);\n\tif (y == 54.0) tile = ( x < 96.0 ) ? vec4(0x8cffc0, 0xffc0c0, 0xf1c4c0, 0xc0c0f3) : vec4(0xfffff3, 0x0000ff, 0x000000, 0x000000);\n\tif (y == 55.0) tile = ( x < 96.0 ) ? vec4(0xffffff) : vec4(0xffffff, 0x0000ff, 0x000000, 0x000000);\n\tif (y == 56.0) tile = ( x < 96.0 ) ? vec4(0xc0c4c0, 0xc0e0ff, 0xffc09c, 0xc0c0f3) : vec4(0xc0f8c0, 0x0000ff, 0x000000, 0x000000);\n\tif (y == 57.0) tile = ( x < 96.0 ) ? vec4(0xc4c4f3, 0xc4ccff, 0xffcc88, 0xc4f3f3) : vec4(0xc4f8c4, 0x0000ff, 0x000000, 0x000000);\n\tif (y == 58.0) tile = ( x < 96.0 ) ? vec4(0xfcccf3, 0xfcccff, 0xffcc80, 0xfcf3f3) : vec4(0xfcf8fc, 0x0000ff, 0x000000, 0x000000);\n\tif (y == 59.0) tile = ( x < 96.0 ) ? vec4(0xc0c0f3, 0xc0ccff, 0xffc894, 0xe1f3f3) : vec4(0xf0f9c0, 0x0000ff, 0x000000, 0x000000);\n\tif (y == 60.0) tile = ( x < 96.0 ) ? vec4(0xfcccf1, 0xfcc8ff, 0xffc89c, 0xcff1f1) : vec4(0xfcf9fc, 0x0000ff, 0x000000, 0x000000);\n\tif (y == 61.0) tile = ( x < 96.0 ) ? vec4(0xc4c8f1, 0xc4c8ff, 0xffc88c, 0xccf1f1) : vec4(0xfcc9c4, 0x0000ff, 0x000000, 0x000000);\n\tif (y == 62.0) tile = ( x < 96.0 ) ? vec4(0xc0c8f1, 0xc0c0ff, 0xffc08c, 0xc0f1f1) : vec4(0xfcc1c0, 0x0000ff, 0x000000, 0x000000);\n\tif (y == 63.0) tile = ( x < 96.0 ) ? vec4(0xffffff) : vec4(0xffffff, 0x0000ff, 0x000000, 0x000000);\n\tif (y == 64.0) tile = ( x < 96.0 ) ? vec4(0xccccc0, 0xc0ffc0, 0xf3ffcc, 0xffc1ff) : vec4(0xc0c09c, 0x0000ff, 0x000000, 0x000000);\n\tif (y == 65.0) tile = ( x < 96.0 ) ? vec4(0xc8cccc, 0xccffc4, 0xf1ffc8, 0xff9c9f) : vec4(0xccc488, 0x0000ff, 0x000000, 0x000000);\n\tif (y == 66.0) tile = ( x < 96.0 ) ? vec4(0xc0cccc, 0xccfffc, 0xf0ffc0, 0xff9fcf) : vec4(0xfcfc80, 0x0000ff, 0x000000, 0x000000);\n\tif (y == 67.0) tile = ( x < 96.0 ) ? vec4(0xc0ccc0, 0xc8ffe1, 0xf3ffc0, 0xffc1e7) : vec4(0xc4c094, 0x0000ff, 0x000000, 0x000000);\n\tif (y == 68.0) tile = ( x < 96.0 ) ? vec4(0xccc4e4, 0xc8ffcf, 0xf3ffcc, 0xfffcf3) : vec4(0xc4fc9c, 0x0000ff, 0x000000, 0x000000);\n\tif (y == 69.0) tile = ( x < 96.0 ) ? vec4(0xc8c4c4, 0xc8ffcc, 0xf3ffc8, 0xfffcf9) : vec4(0xccc48c, 0x0000ff, 0x000000, 0x000000);\n\tif (y == 70.0) tile = ( x < 96.0 ) ? vec4(0xc8c0c4, 0xc0ffc0, 0xc0ffc8, 0xff80fc) : vec4(0xc0c08c, 0x0000ff, 0x000000, 0x000000);\n\tif (y == 71.0) tile = ( x < 96.0 ) ? vec4(0xffffff) : vec4(0xffffff, 0x0000ff, 0x000000, 0x000000);\n\tif (y == 72.0) tile = ( x < 96.0 ) ? vec4(0xcfc0c0, 0xe1ffc0, 0xffe0cc, 0xf3c0e0) : vec4(0xc0c0c4, 0x0000ff, 0x000000, 0x000000);\n\tif (y == 73.0) tile = ( x < 96.0 ) ? vec4(0xe7f3c4, 0xedffc4, 0xffccc8, 0xf3cccc) : vec4(0xc4c4c4, 0x0000ff, 0x000000, 0x000000);\n\tif (y == 74.0) tile = ( x < 96.0 ) ? vec4(0xf3f3fc, 0xedfffc, 0xffccc0, 0xf3cccc) : vec4(0xfcfcc4, 0x0000ff, 0x000000, 0x000000);\n\tif (y == 75.0) tile = ( x < 96.0 ) ? vec4(0xfff3e1, 0xc0ffe1, 0xffccc0, 0xf3c0cc) : vec4(0xe1c0cc, 0x0000ff, 0x000000, 0x000000);\n\tif (y == 76.0) tile = ( x < 96.0 ) ? vec4(0xfff1cf, 0xccffcf, 0xffc8cc, 0xf1e4c8) : vec4(0xcffccc, 0x0000ff, 0x000000, 0x000000);\n\tif (y == 77.0) tile = ( x < 96.0 ) ? vec4(0xfff1cc, 0xc4ffcc, 0xffc8c8, 0xf1c4c8) : vec4(0xccc4e1, 0x0000f3, 0x000000, 0x000000);\n\tif (y == 78.0) tile = ( x < 96.0 ) ? vec4(0xfff1c0, 0xc4ffc0, 0xffc0c8, 0xf1c4c0) : vec4(0xc0c0f3, 0x0000f3, 0x000000, 0x000000);\n\tif (y == 79.0) tile = ( x < 96.0 ) ? vec4(0xffffff) : vec4(0xffffff, 0x0000ff, 0x000000, 0x000000);\n\tif (y == 80.0) tile = ( x < 96.0 ) ? vec4(0xc0ffc1, 0xc0c7cc, 0xc0ffcc, 0xffc0c4) : vec4(0xc0c0e0, 0x0000c0, 0x000000, 0x000000);\n\tif (y == 81.0) tile = ( x < 96.0 ) ? vec4(0xc4ff9c, 0xccc7c8, 0xf3ffcc, 0xffc4c4) : vec4(0xc4c4e4, 0x0000f3, 0x000000, 0x000000);\n\tif (y == 82.0) tile = ( x < 96.0 ) ? vec4(0xfcff9f, 0xccc7c0, 0xf3ffcc, 0xfffccc) : vec4(0xfcfce4, 0x0000f3, 0x000000, 0x000000);\n\tif (y == 83.0) tile = ( x < 96.0 ) ? vec4(0xc0ffc1, 0xc8e7c0, 0xf3ffc0, 0xffc0c0) : vec4(0xe1c0c0, 0x0000f3, 0x000000, 0x000000);\n\tif (y == 84.0) tile = ( x < 96.0 ) ? vec4(0xfcfffc, 0xc8e7cc, 0xf1fff3, 0xfffccc) : vec4(0xcffccc, 0x0000f1, 0x000000, 0x000000);\n\tif (y == 85.0) tile = ( x < 96.0 ) ? vec4(0xc4f3fc, 0xc8e4c8, 0xf1ffe3, 0xffc4c8) : vec4(0xccc4cc, 0x0000f1, 0x000000, 0x000000);\n\tif (y == 86.0) tile = ( x < 96.0 ) ? vec4(0xc0f380, 0xc0e0c8, 0xf1ffe3, 0xffc0c8) : vec4(0xc0c0c0, 0x0000f1, 0x000000, 0x000000);\n\tif (y == 87.0) tile = ( x < 96.0 ) ? vec4(0xffffff) : vec4(0xffffff, 0x0000ff, 0x000000, 0x000000);\n\tif (y == 88.0) tile = ( x < 96.0 ) ? vec4(0xffc0c0, 0x9cc0e0, 0xc0ffc0, 0x9cc0c0) : vec4(0xc4c0ff, 0x0000c0, 0x000000, 0x000000);\n\tif (y == 89.0) tile = ( x < 96.0 ) ? vec4(0xfff3c4, 0x88c4cc, 0xc4ffcc, 0x88cccc) : vec4(0xc4f3ff, 0x0000c4, 0x000000, 0x000000);\n\tif (y == 90.0) tile = ( x < 96.0 ) ? vec4(0xfff3fc, 0x80fccc, 0xfcffcc, 0x80cccc) : vec4(0xccf3ff, 0x0000fc, 0x000000, 0x000000);\n\tif (y == 91.0) tile = ( x < 96.0 ) ? vec4(0xc073e1, 0x94c0cc, 0xf0ffc8, 0x94c8c0) : vec4(0xc0f3ff, 0x0000c0, 0x000000, 0x000000);\n\tif (y == 92.0) tile = ( x < 96.0 ) ? vec4(0xc071cf, 0x9cfcc8, 0xfcffc8, 0x9cc8e4) : vec4(0xccf1ff, 0x0000fc, 0x000000, 0x000000);\n\tif (y == 93.0) tile = ( x < 96.0 ) ? vec4(0xfff1cc, 0x8cc4c8, 0xfcffc8, 0x8cc8c4) : vec4(0xc8f1ff, 0x0000c4, 0x000000, 0x000000);\n\tif (y == 94.0) tile = ( x < 96.0 ) ? vec4(0xfff1c0, 0x8cc0c0, 0xfcffc0, 0x8cc0c4) : vec4(0xc8f1ff, 0x0000c0, 0x000000, 0x000000);\n\tif (y == 95.0) tile = ( x < 96.0 ) ? vec4(0xffffff) : vec4(0xffffff, 0x0000ff, 0x000000, 0x000000);\n\tif (y == 96.0) tile = ( x < 96.0 ) ? vec4(0xc0c0e0, 0xc0ffc0, 0xc0ffc0, 0xc0cccc) : vec4(0xffffff, 0x0000ff, 0x000000, 0x000000);\n\tif (y == 97.0) tile = ( x < 96.0 ) ? vec4(0xc4c4e4, 0xc4fff3, 0xccfff3, 0xc4cccc) : vec4(0xffffff, 0x0000ff, 0x000000, 0x000000);\n\tif (y == 98.0) tile = ( x < 96.0 ) ? vec4(0xfcfce4, 0xfcfff3, 0xfcfff3, 0xfccccc) : vec4(0xfffff3, 0x0000ff, 0x000000, 0x000000);\n\tif (y == 99.0) tile = ( x < 96.0 ) ? vec4(0xe1c0c0, 0xe1fff3, 0xc4c073, 0xe1c0cc) : vec4(0xffffff, 0x0000ff, 0x000000, 0x000000);\n\tif (y == 100.0) tile = ( x < 96.0 ) ? vec4(0xcffccc, 0xcffff1, 0xc4c071, 0xcff3c4) : vec4(0xffffff, 0x0000ff, 0x000000, 0x000000);\n\tif (y == 101.0) tile = ( x < 96.0 ) ? vec4(0xccc4cc, 0xccfff1, 0xccfff1, 0xcce3c4) : vec4(0xfffff3, 0x0000ff, 0x000000, 0x000000);\n\tif (y == 102.0) tile = ( x < 96.0 ) ? vec4(0xc0c0c0, 0xc0fff1, 0xc0fff1, 0xc0e3c0) : vec4(0xffffff, 0x0000ff, 0x000000, 0x000000);\n\tif (y == 103.0) tile = ( x < 96.0 ) ? vec4(0xffffff) : vec4(0xffffff, 0x0000ff, 0x000000, 0x000000);\n\tif (y == 104.0) tile = ( x < 96.0 ) ? vec4(0xffffff, 0xc0c4c0, 0xccccff, 0xccc0f3) : vec4(0xfffff3, 0x0000ff, 0x000000, 0x000000);\n\tif (y == 105.0) tile = ( x < 96.0 ) ? vec4(0xffffff, 0xc4c4f3, 0xc8ccff, 0xc8ccf3) : vec4(0xfffff3, 0x0000ff, 0x000000, 0x000000);\n\tif (y == 106.0) tile = ( x < 96.0 ) ? vec4(0xffffff, 0xfcccf3, 0xc0ccff, 0xc0ccf3) : vec4(0xfffff3, 0x0000ff, 0x000000, 0x000000);\n\tif (y == 107.0) tile = ( x < 96.0 ) ? vec4(0xffffff, 0xc0c0f3, 0xc0ccff, 0xc0c8f3) : vec4(0xfffff3, 0x0000ff, 0x000000, 0x000000);\n\tif (y == 108.0) tile = ( x < 96.0 ) ? vec4(0xffffff, 0xfcccf1, 0xccc4ff, 0xccc8f1) : vec4(0xfffff3, 0x0000ff, 0x000000, 0x000000);\n\tif (y == 109.0) tile = ( x < 96.0 ) ? vec4(0xffffff, 0xc4c8f1, 0xc8c4ff, 0xc8c8f1) : vec4(0xffffff, 0x0000ff, 0x000000, 0x000000);\n\tif (y == 110.0) tile = ( x < 96.0 ) ? vec4(0xffffff, 0xc0c8f1, 0xc8c0ff, 0xc8c0f1) : vec4(0xfffff3, 0x0000ff, 0x000000, 0x000000);\n\tif (y == 111.0) tile = ( x < 96.0 ) ? vec4(0xffffff) : vec4(0xffffff, 0x0000ff, 0x000000, 0x000000);\n\t\n\tfloat n = mod(x, 96.0); // quantize x coordinate to nearest 96 pixels and get float containing 24 pixels\n\tfloat t = ( ( n < 24.0 ) ? tile.x : ( n < 48.0 ) ? tile.y : (n < 72.0 ) ? tile.z : tile.w );\n\tfloat p = mod( x, 24.0 ) * 1.0; // quantize x coordinate to nearest 24 pixels to determine pixel bit index\n\tint idx = int( mod( floor( t*exp2(-p) ), 2.0 ));\n    \n\t// look up colour palette for the indexed pixel\n\tif (idx == 0) color = vec4(1.000000, 1.000000, 1.000000, 1.0);\n\tif (idx == 1) color = vec4(0.898039, 0.447059, 0.796078, 0.0);\n}\n\n\n\n\nvoid drawLogo(inout vec4 bg, in float x, in float y, in vec2 pixelCoord)\n{\n    const float w = 64.0;\n    const float h = 32.0;\n\n    // bounds check - no idea how the GPU feels about these checks.\n\tif ( (pixelCoord.x >= x) && (pixelCoord.y >= y) \n        && (pixelCoord.x < (x + w)) && (pixelCoord.y < (y + h)))\n    {\n    \tvec2 coord;\n    \tcoord.x = (pixelCoord.x - x);\n    \tcoord.y = (pixelCoord.y - y);\n        drawSpriteUnionDemoLogo(bg,  coord.x, coord.y);  \n    }\n\n}\n\n#define RGBA(r,g,b,a) vec4(float(r)/255.0, float(g)/255.0, float(b)/255.0, float(a)/255.0)\n\nvoid textGradient(inout vec4 c, in float y)\n{   \n\tconst float GRADIENT_SCALE = 112.0/4.0; // 4 zones over the 112 pixel high bitmap\n    const vec4 GRADIENT0 = RGBA(224,0,32,255);\n    const vec4 GRADIENT1 = RGBA(224,0,224,255);\n    const vec4 GRADIENT2 = RGBA(224,224,224,255);\n    const vec4 GRADIENT3 = RGBA(224,224,32,255);\n    const vec4 GRADIENT4 = RGBA(160,224,0,255);    \n    \n    // quantize vertical coord into 4 zones\n    float n = floor(y / GRADIENT_SCALE);\n    \n    // compute interpolation amount\n    float k = mod(y, GRADIENT_SCALE) / 112.0 * 4.0;\n    \n    // lerp the gradients across each zone\n    if (n == 0.0) c *= mix(GRADIENT0, GRADIENT1, k);\n    if (n == 1.0) c *= mix(GRADIENT1, GRADIENT2, k);\n    if (n == 2.0) c *= mix(GRADIENT2, GRADIENT3, k);\n    if (n == 3.0) c *= mix(GRADIENT3, GRADIENT4, k);    \n}\n\nvoid drawText(inout vec4 bg, in float x, in float y, in vec2 pixelCoord)\n{\n    float w = 128.0*2.0;\t// we double up the horizontal pixels when rendering this one\n    float h = 112.0;\n    \n\tif ( (pixelCoord.x >= x) && (pixelCoord.y >= y) \n        && (pixelCoord.x < (x + w)) && (pixelCoord.y < (y + h)))\n    {\n    \tvec2 coord;\n    \tcoord.x = (pixelCoord.x - x);\n    \tcoord.y = (pixelCoord.y - y);\n        drawSpriteUnionLettersWhite(bg,  floor(coord.x/2.0), coord.y);  \n        // apply colour gradient to white text bitmap\n        textGradient(bg, coord.y);\n    }\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{ \n\tfloat sx, sy;\n    vec4 c2;\n    \n    // convert screen space to 320x200 bitmap with top left origin\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 pixelCoord;\n    pixelCoord.x = floor(uv.x * 320.0);\n    pixelCoord.y = floor((1.0 - uv.y) * 200.0);\n    \n\t// render background as tiled bitmap, with vertical scroll animation    \n    vec4 bg = vec4(0.0);\n    sx = mod(floor(fragCoord.x / 3.0), 48.0);\n    sy = mod(floor(iTime * 50.0 + fragCoord.y / 3.0), 48.0);\n\tdrawSpriteUnionBackground(bg, sx, sy);   \n\n    // animate the logo horizontally & render it\n    sx = floor(sin(iTime*3.0) * cos(iTime*2.0) * 280.0*0.3 + 260.0*0.5);\n    sy = 4.0;\n    c2 = vec4(0.0);\n    drawLogo(c2, sx, sy, pixelCoord);\n    bg = mix(bg, c2, c2.w);\n    \n\t// animate the text in an old-skool sine wave way and render it\n    float ws = iTime*2.5;\n    sx = 32.0 + sin(pixelCoord.y/40.0 + ws)*20.0;\n    sy = floor(64.0 + cos(pixelCoord.x/40.0 + ws)*4.0);\n    drawText(c2, sx, sy, pixelCoord);\n    bg = mix(bg, c2, c2.w);\n \n    // final output\n    fragColor = bg;\n}", "image_inputs": [{"id": "lt2GWW", "previewfilepath": "https://soundcloud.com/simon-morris-833102035/union-loader", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0, "src": "https://soundcloud.com/simon-morris-833102035/union-loader", "ctype": "musicstream"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc0-1.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4dV3Rm.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "4dV3zh", "name": "Day 000 - Simple Raytracer", "author": "mwalczyk", "description": "Day 000 - Simple Raytracer", "tags": ["2d"], "likes": 2, "viewed": 190, "date": "1453307261", "time_retrieved": "2024-06-20T18:29:56.100676", "image_code": "vec4 mainSphere = vec4(0.0, 0.0, 0.0, 1.0);\nconst vec3 sphereColor = vec3(0.85, 0.1, 0.2);\nconst vec3 backgroundColor1 = vec3(0.4, 0.15, 0.85);\nconst vec3 backgroundColor2 = vec3(0.1, 0.15, 0.65);\nvec3 lightPos = vec3(2.0, 2.0, -3.0);\n\nfloat iSphere(in vec3 ray,\n              in vec3 dir,\n              in vec4 sphere)\n{\n    // A point is on a sphere if: \t\n    //\t\t\t(point - center) = r^2.\n    // A point is on a ray if: \t\t\n    //\t\t\tpoint = ro + rd * t, for some t > 0.\n    // So, we want to solve for t where in the equation:\n   \t//\t\t\t((ro + rd * t) - center)^2 = r^2\n    \n\tvec3 rc = ray - sphere.xyz;\n    float c = dot(rc, rc) - (sphere.w * sphere.w);\n    float b = dot(dir, rc);\n    float d = b * b - c;\n    float t = -b - sqrt(abs(d));\n    float st = step(0.0, min(t, d));\n    return mix(-1.0, t, st);\n}\n\nvec3 nSphere(in vec3 pos,\n             in vec4 sphere)\n{\n\treturn normalize((pos - sphere.xyz) / sphere.w);    \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{     \n    // First, generate a UV coordinate for this fragment.\n    // Then, remap it to [-1, 1] and scale by the aspect \n    // ratio of the window.\n    vec2 uv = fragCoord.xy / iResolution.xy;\n\tuv = (2.0 * uv - 1.0) * vec2(iResolution.x / iResolution.y, 1.0);\n\t\n    // Move some stuff around.\n    mainSphere.x += cos(iTime);\n    mainSphere.z += sin(iTime);\n    lightPos.x *= (sin(iTime * 2.0) + 1.0) / 2.0;\n    \n    vec3 ro = vec3(0.0, 0.0, -3.0);\t\t// Ray origin\n    vec3 rd = normalize(vec3(uv, 1.0));\t// Ray direction\n    \n    // Calculate the point of intersection.\n\tfloat t = iSphere(ro, rd, mainSphere);\n    vec3 pos = ro + rd * t;\n    \n    // Calculate the normal at the point of intersection.\n    vec3 normal = nSphere(pos, mainSphere);\n    \n    // Calculate the per-fragment diffuse color.\n    vec3 eye = lightPos - pos;\n    float diffIntensity = max(dot(eye, normal), 0.3);\t// Soften the shadow.\n    vec3 diffColor = diffIntensity * sphereColor;\n    \n    float distToCenter = distance(uv, vec2(0.5));\n    vec3 backgroundGrad = mix(backgroundColor1, backgroundColor2, distToCenter);\n    \n    vec3 finalColor = mix(backgroundGrad, diffColor, step(0.0, t));\n    \n    fragColor = vec4(finalColor, 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4dV3zh.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "4dVGzD", "name": "fishing village", "author": "ejang", "description": "fishing village. . Reference image: https://www.youtube.com/watch?v=3ehuu3Zq8L8\nwork in progress. TODO : optimizations, fix swimming textures on boat, add raymarched fog to horizon.", "tags": ["procedural", "3d", "raymarching"], "likes": 10, "viewed": 449, "date": "1453517299", "time_retrieved": "2024-06-20T18:29:58.724981", "image_code": "// Eric Jang (c) 2016\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n\n#define clamp01(a) clamp(a,0.0,1.0)\n#define opS(d1,d2) max(-d1,d2)\n// union 2 objects carrying material info\n#define opU(a,b) ((a.x < b.x) ? a : b)\n\n#define PI 3.14159\n\n// implicitly specifies shading rules\n#define WOOD_MAT 0.\n#define STRAW_MAT 1.\n#define VILLAGE_MAT 2.\n\n#define ID_NONE -1\n#define ID_SKY 0\n#define ID_WATER 1\n#define ID_MOUNTAIN 2\n#define ID_VILLAGE 3\n\n// hash maps sequences to random-ish values\nfloat hash(float u)\n{\n    float f=u*13.1;\n    return fract(sin(f)*134735.3);\n}\n\nfloat Hash2d(vec2 uv)\n{\n    float f = uv.x + uv.y * 37.0;\n    return fract(sin(f)*104003.9);\n}\n\nvec3 hash3( float n ) {\n\treturn fract(sin(vec3(n,n+1.0,n+2.0))*vec3(84.54531253,42.145259123,23.349041223));\n}\n\nvec3 rX(const in vec3 v, const in float cs, const in float sn) {return mat3(1.0,0.0,0.0,0.0,cs,sn,0.0,-sn,cs)*v;}\nvec3 rY(const in vec3 v, const in float cs, const in float sn) {return mat3(cs,0.0,-sn,0.0,1.0,0.0,sn,0.0,cs)*v;}\nvec3 rZ(const in vec3 v, const in float cs, const in float sn) {return mat3(cs,sn,0.0,-sn,cs,0.0,0.0,0.0,1.0)*v;}\n\n// modeling functions\n\nfloat smin( float a, float b, float k )\n{\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\nfloat sdSphere( vec3 p, float s )\n{\n  return length(p)-s;\n}\n\nfloat sdCappedCylinder( vec3 p, vec2 h )// h = radius, height\n{\n  vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat dPlane(in vec3 ro, in vec3 rd)\n{\n    vec3 p0=vec3(0.);\n    vec3 n=vec3(0.,1.,0.);\n    return dot(p0-ro,n)/dot(rd,n);\n}\n\nfloat udRoundBox( vec3 p, vec3 b, float r )\n{\n  return length(max(abs(p)-b,0.0))-r;\n}\n\nfloat noise2d(vec2 uv)\n{\n    vec2 fr = fract(uv.xy);\n    vec2 fl = floor(uv.xy);\n    // 4 slightly different shifted versions\n    // of the same set of blocky tiles.\n    // we blend them together in x,y directions via\n    // 3 mix operations\n    // a=mix h00, h10 across x axis, \n    // b=mix h10, h11 across x axis\n    // c=mix a,b across y axis\n    // to get smooth clouds texture.\n    float h00 = Hash2d(fl);\n    float h10 = Hash2d(fl + vec2(1,0));\n    float h01 = Hash2d(fl + vec2(0,1));\n    float h11 = Hash2d(fl + vec2(1,1));\n    return mix(mix(h00, h10, fr.x), mix(h01, h11, fr.x), fr.y);\n}\n\nfloat clouds(in vec3 rd)\n{\n    vec2 p=rd.xz/rd.y; // rd.xz/rd.y scales down farther in horizon \n \tfloat n = noise2d(p*1.0); \n    n += noise2d(p*2.0)*0.5;\n    n += noise2d(p*4.0)*0.25;\n    n += noise2d(p*8.0)*0.125;\n    n = mix(n * 0.4, n, clamp01(abs(rd.y*3.)));  // fade clouds in distance\n    return n;\n}\n\nfloat sdCylinder( vec3 p, vec3 c )\n{\n  return length(p.xz)-c.z;\n}\nfloat sdCappedCone( in vec3 p, in vec3 c ) // c=vec3(bottom radius, angle , height)\n{\n    vec2 q = vec2( length(p.xz), p.y );\n    vec2 v = vec2( c.z*c.y/c.x, -c.z );\n    vec2 w = v - q;\n    vec2 vv = vec2( dot(v,v), v.x*v.x );\n    vec2 qv = vec2( dot(v,w), v.x*w.x );\n    vec2 d = max(qv,0.0)*qv/vv;\n    return sqrt( dot(w,w) - max(d.x,d.y) )* sign(max(q.y*v.x-q.x*v.y,w.y));\n}\n\nfloat sdTriPrism( vec3 p, vec2 h )\n{\n    vec3 q = abs(p);\n    return max(q.z-h.y,max(q.x*0.866025+p.y*0.5,-p.y)-h.x*0.5);\n}\n\nfloat sdHouse(vec3 p, vec3 i, vec3 o, float h1, float h2) \n{ \n    // implemented as the intersection of an inner\n    // udroundbox and outer udroundbox rotated 45 degrees\n    // i and o are the xyz scales, respectively.\n    // o is shifted down h units prior\n    \n    return max(udRoundBox(p-vec3(0.,-h1,0.),i,.01),\n               udRoundBox(rZ(p-vec3(0.,-h2,0.),0.707106,0.707106),o,.01));\n}\n\n// TODO - village will be done in for loop that creates triangular \n// prisms atop each other in scattered manner\n// windows traced using heightmap function\nvec2 sdvillage(in vec3 p, float seed)\n{\n    \n    vec3 R;\n    float d;\n    vec3 q,q2;\n    vec3 scale=vec3(.5,1.,1.);\n    \n    vec2 dm=vec2(1000.,ID_NONE);\n    \n    for (float i=0.; i<4.; i+=1.)\n    {\n        R=hash3(seed+i)-.5; // dx, dy, ry\n        q=p-vec3(i*3.2-R.x,R.y,-R.x);\n        // rotate\n        q=rY(q,cos(R.z),sin(R.z));\n        \n        d=sdHouse(q, vec3(1.,1.,1.), vec3(2.), -.6, 1.);\n        dm=opU(dm,vec2(d,VILLAGE_MAT));\n        \n        q.y-=1.1;\n        float roof=opS(sdTriPrism((q-vec3(0.,-.1,0.))*scale,vec2(.8,1.4)),\n                       sdTriPrism(q*scale,vec2(.8,1.3)));\n        dm=opU(dm,vec2(roof,STRAW_MAT));\n        \n        // second story\n        if (hash(seed+i)>0.3)\n        {\n            q2=q-vec3(0.,1.,0.);\n            d=sdHouse(q2, vec3(1.,2.,1.), vec3(2.), -.6, 1.);\n            dm=opU(dm,vec2(d,VILLAGE_MAT));\n            q2.y-=1.1;\n            float roof=opS(sdTriPrism((q2-vec3(0.,-.1,0.))*scale,vec2(.8,1.4)),\n                           sdTriPrism(q2*scale,vec2(.8,1.3)));\n            dm=opU(dm,vec2(roof,STRAW_MAT));\n        }    \n    }\n    \n    return dm;\n}\n\n// signed distance function for village\nfloat sdBoardWalk(in vec3 p, in vec2 s)\n{\n    // s = width, half length\n    float d= udRoundBox(p,vec3(s.x,0.03,s.y/2.),0.03);\n    float rx, dx, dz;\n    float l; vec3 q;\n    float k=0.;\n    for (float i=-2.; i<2.; i+=1.)\n    {\n        dz=i*s.y/4.+s.y/8.;\n        for (float j=0.; j<2.; j+=1.)\n        {\n            if (hash(k)>.05)\n            {\n               dx=(2.*j-1.)*s.x+.04;\n                q=p-vec3(dx,0.,dz);\n                rx=(Hash2d(vec2(i,j))-.5)*.4;\n                q=rX(q,cos(rx),sin(rx));\n                d=min(d,sdCappedCylinder(q,vec2(.01,.7)));\n            }\n        }\n        k+=1.;\n    }\n    \n    return d;\n}\n\n\nvec2 sddocks(in vec3 p)\n{   \n    vec2 s=vec2(.5,2.); // .5 wide, 4. long\n    float d=10000.;\n    float t, ry;\n    for (float i=0.; i<3.; i+=1.)\n    {\n        t=hash(i);\n        ry=(t-.5)*.8;\n        d=min(d,sdBoardWalk(rY(p-vec3(0.,0.,i*1.5),cos(ry),sin(ry)),vec2(.5,1.7+.1*t)));\n    }\n\treturn vec2(d,WOOD_MAT);\n}\n\nvec2 sdboat(in vec3 p) // sanpan-style boat.\n{\n    // wood stuff\n    // hull\n    vec3 q=rZ(p,cos(.03),sin(.03));\n    float d=sdTriPrism((q-vec3(0.,-1.2,0.))*vec3(1.,-1.,1.),vec2(3.,.5)); // size, z-thickness\n    \n    vec2 offset=vec2(0.2,14.6);\n    float cylinder= length(q.xy-offset)-14.5;\n    d=opS(cylinder,d);\n    \n    float inner=udRoundBox(q-vec3(0.,0.3,0.),vec3(2.4,.2,.4),.03);\n    d=opS(inner,d);\n    \n    // dude\n   q=p-vec3(1.8,0.,0.2);\n   float dude=sdSphere(q-vec3(0.,1.04,0.),.15); \n   float torso=udRoundBox(q-vec3(0.,0.6,0.),vec3(.07,.2,.12),.05);\n   dude=smin(dude,torso,.1);\n   float legs=sdCappedCylinder(q-vec3(0.,0.,.08), vec2(.06,.5));\nlegs=min(sdCappedCylinder(q-vec3(0.,0.,-.08), vec2(.06,.5)),legs);    \n   dude=smin(legs,dude,.2);\n   \n    // arms and pole\n   float pole=sdCappedCylinder(rZ(q-vec3(1.2,0.,0.16),cos(-1.),sin(-1.)),vec2(.02,2.4));\n   d=min(min(d,dude),pole);\n   \n   vec2 wood=vec2(d,WOOD_MAT);\n    \n    // straw stuff\n    // roof\n   vec3 q1=p-vec3(-0.5,0.,0.);\n   \n   float roof=opS(\n   \tsdCappedCylinder(q1.yxz,vec2(.48,.9)),\n   \tsdCappedCylinder(q1.yxz,vec2(.5,.8 ))\n   );\n   q1.x-=0.6;\t\n   q1=rZ(q1,cos(.05),sin(.05));\n   float roof1=opS(sdCappedCylinder(q1.yxz,vec2(.51,.6)),\n                   sdCappedCylinder(q1.yxz, vec2(.54,.5)));\n   roof1=opS(udRoundBox(q1-vec3(0.,-.85,0.),vec3(1.),0.01),roof1);\n   roof=min(roof,roof1);\n    \n   // hat\n   vec3 q2=rX(q-vec3(0.,1.25,0.), cos(.1), sin(.1));\n   float hat=sdCappedCone(q2,vec3(.2,.4,.18));\n    \n    vec2 straw=vec2(min(hat,roof),STRAW_MAT);\n    return opU(wood,straw);\n}\n\n#define BOAT_SPEED .5\n#define START_POS vec3(3.,0.,1.4)\nvec2 scene(in vec3 p)\n{\n    // TMP\n    //return vec2(10000.,ID_NONE);\n    \n    // houses\n\tvec2 v1= sdvillage(rY(p-vec3(-2.,1.,20.),cos(-2.),sin(-2.)),0.);\n    vec2 v2= sdvillage(rY(p-vec3(16.,.5,25.),cos(2.),sin(2.)),221.);\n    \n    // docks\n    float ry=1.2;\n    vec3 q1=rY(p-vec3(-1.4,0.3,7.),cos(ry),sin(ry));\n  \tvec2 docks=sddocks(q1);\n    \n    // boat\n    ry=-1.7+sin(iTime)*.01;\n    \n    vec3 q2=rY(p-START_POS,cos(ry),sin(ry))-vec3(-mod(iTime*BOAT_SPEED+8.,50.),0.,0.);\n \tvec2 boat= sdboat(q2);\n  \n    vec2 tm=opU(docks,opU(v1,v2)); \n    return opU(tm,boat);\n}\n\nvec3 calcNormal( in vec3 p )\n{\n    vec3 e = vec3( 0.001, 0.0, 0.0 );\n    vec3 n = vec3(\n        scene(p+e.xyy).x - scene(p-e.xyy).x,\n        scene(p+e.yxy).x - scene(p-e.yxy).x,\n        scene(p+e.yyx).x - scene(p-e.yyx).x);\n    return normalize(n);\n}\n\nvec3 background(in vec3 rd)\n{\n    vec3 col;\n    \n    // skycol fades into horizoncol closer to horizon\n    vec3 skyCol = vec3(.454, .298, .261);\n    vec3 horizonCol = vec3(0.866667, 0.47451, 0.270588);\n    col=skyCol;\n    col=mix(horizonCol,skyCol,clamp01(rd.y)*7.);\n    \n    // sunlight\n    vec3 sun_dir=normalize(vec3(0.18,0.1,1.));\n    float sunlight=clamp01(pow(dot(rd,sun_dir),4.));\n    \n    // add sun\n    //float sundot = smoothstep(.996,.999,sunlight);\n    float sundot=1.-smoothstep(0.03,0.06,length(rd-sun_dir));\n    col+=sundot*vec3(1.0,0.913725,0.458824);\n    //col+=sunlight*vec3(1.0,0.913725,0.458824)*.3;\n\n    // clouds\n    vec3 cloudcol=vec3( 0.623529,  0.298039,  0.164706)*1.5;\n\n    //return cloudcol*sunlight;\n    //col=vec3(clouds(rd));\n    col=mix(col,cloudcol*sunlight,clouds(rd));\n    \n    return clamp01(col);  \n}\n\n\n// FBM loop is inlined via macro\n#define F (texture(iChannel0,p*s/1e3)/(s+=s)).x\n\nfloat fbm(in vec2 p, in float s)\n{\n  return F+F+F;\n}\n\nvec3 raymarchFog(in vec3 ro, in vec3 rd, in vec3 bgc)\n{\n  // TODO\n    return mix(bgc,vec3(1.),.1);\n}\n\nfloat watermap( in vec2 p ) { // -.04,.2 controls water direction\n\treturn fbm((p-iTime*vec2(-.04,.2))*10.,.5);\n}\n\nvec3 shade(vec3 p, float m)\n{\n    vec3 n=calcNormal(p);\n   \tvec3 sun_dir=normalize(vec3(-0.28,2.,1.));\n    //vec3 light_dir=normalize(vec3(-0.1,0.1,1.));\n\t//vec3 light_dir=reflect(sun_dir,n); // key light opposite sun\n    \n    vec3 col;\n\tif (m==WOOD_MAT)\n    {\n        col=vec3(0.152941,0.0627451,0.0392157);\n    }\n    else if (m==STRAW_MAT)\n    {\n        // todo - get p as offset in boat coordinates\n        vec4 t=texture(iChannel1,p.xz/2.);\n        col=t.xyz;\n    }\n    else if (m==VILLAGE_MAT)\n    {\n        col=vec3(0.152941,0.0627451,0.0392157)*.1;\n        // add windows\n        vec3 wcol1=vec3(0.972549, 0.294118, 0.137255);\n        vec3 wcol2=vec3( 1.0,0.709804,0.415686);\n        \n        vec4 t=texture(iChannel1,.2+p.xy*vec2(.15,.05));\n        //return vec3(1.-t.x*t.y);\n        float w1=smoothstep(0.7,.8,1.-t.x); // cooler orange glow\n        float w2=smoothstep(0.8,0.9,1.-t.x); // hotter yellow light\n        //return vec3(w2);\n        // skip phong lighting and go straight to color\n        return mix(col,mix(wcol1,wcol2,w2*w1),pow(w1,.2));\n    }\n    \n    col*=1.1*clamp01( dot( n, sun_dir ) ); // phong lighting   \n    return col;\n}\n\n// render subcall (for water refl). returns object id and color.\n// this does shading calculations.\nint trace(in vec3 ro, in vec3 rd, out vec3 col)\n{\n    int obj=ID_SKY;   \n    col=background(rd); // default color = sky\n    \n    // mountains\n    // exponential jump + binary search refinement is a better choice\n    // but this is easier to read\n    vec3 p; float h; float h2;\n    for (float t=0.; t<100.0; t+=0.1)\n    {\n        p=ro+t*rd;\n        \n        // foreground mountains\n        float vwidth=0.7;// valley width\n        float xscale=abs(rd.x-.2)*2.; // valley centered around sun\n\t\tfloat zscale=abs(p.z)/15.; // river gets wider closer to camera        \n        h=fbm(p.xz*3.,.3)*xscale*zscale-.25;///(p.z*.1);\n        \n        // background karst mountains\n        float yscale=p.z/20.-.7; // only show up in background\n        vec4 tex=texture(iChannel2,p.xz/100.);\n        h2=((tex.x-.4)*yscale*(xscale+h*.5)-.2)*15.5;\n        //h2=yscale;\n        if (p.y<h)\n      \t{\n            col=vec3(0.180392, 0.0745098, 0.031372)*2.*(1.-sqrt(h));\n            obj=ID_MOUNTAIN;\n           break;\n        } else if (p.y < h2) {\n            col=mix(vec3(0.180392, 0.0745098, 0.031372)*.5,vec3(0.72549,  0.392157,  0.231373)*.8,t/300.);\n            obj=ID_MOUNTAIN;\n            break;\n        } else if (p.y<0.){\n            obj=ID_NONE;\n        }\n    }\n    \n    // trace village\n    float t=0.1;\n    vec2 dm;\n    vec3 p2;\n    for (int i=0; i<40; i++)\n    {\n        p2=ro+rd*t;\n        dm=scene(p2);\n        if (dm.x<0.01 || t>500.) break;\n        t+=dm.x;\n    }\n   \tif (t<1000. && t<length(p-ro))\n    {\n        col=shade(p2,dm.y);\n    \tobj=ID_VILLAGE;\n    }\n    \n    // is water\n    if (p.y<0. && p2.y<0.){obj=ID_NONE;}\n    \n\treturn obj;\n}\n\n#define BUMP 0.1\n// dx,dz control turbulence of normal displacement for reflection\n#define dx vec2(.1,0.)\n#define dz vec2(0.,.1)\nvec3 render(in vec3 ro, in vec3 rd)\n{\n    vec3 p; float d;\n\t// default color is black\n    vec3 col=vec3(0.);\n    \n  \t// intersect foreground\n    int obj=trace(ro,rd,col);\n    \n    if (obj==ID_NONE) // we must have hit water == ID_NONE\n    {   \n        //return vec3(1.);\n        d=dPlane(ro,rd);\n        float fresnel;// bool refl;\n        p=ro+d*rd;\n        vec3 n=normalize(vec3(\n            -BUMP*(watermap(p.xz+dx)-watermap(p.xz-dx))/(2.*BUMP), // second-order finite difference approx\n            1.,\n            -BUMP*(watermap(p.xz+dz)-watermap(p.xz-dz))/(2.*BUMP)\n        ));\n        fresnel = pow(1.0-abs(dot(n,rd)),5.);\n        rd = reflect( rd, n);\n        ro=p;\n        trace(ro,rd,col);    \n        vec3 watercol=vec3( 0.439216  ,0.270588 , 0.203922);\n        col=mix(col,watercol,1.-fresnel);\n    }\n    \n    // TODO - add fog contribution\n    // col=raymarchFog(ro,rd,col);\n    \n\treturn col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // p.y (-1,1) p.x (-1.5, 1.5)\n    vec2  p = (-iResolution.xy+2.0*fragCoord.xy)/iResolution.y;\n    \n    vec3 ro=vec3(0.,1.5,0.); // eye location\n    vec3 ta=vec3(0.,3.,20.); // look location\n    vec3 up = vec3( 0.0, 1.0, 0.0 ); // up axis of world\n    float d = 2.5; // distance between eye and focal plane\n    \n    // build ray\n    vec3 ww = normalize( ta - ro);\n    vec3 uu = normalize(cross( up, ww ));\n    vec3 vv = normalize(cross(ww,uu));\n    vec3 rd = normalize( p.x*uu + p.y*vv + d*ww );\n    \n    vec3 col=render(ro,rd);\n    \n    // vignette\n    vec2 q = fragCoord.xy/iResolution.xy;\n    col *= 0.5 + 0.5*pow(20.0*q.x*q.y*(1.0-q.x)*(1.0-q.y),0.4);\n\n    fragColor=vec4(col,1.);   \n}\n", "image_inputs": [{"id": "4dX3Rn", "previewfilepath": "/media/ap/bd6464771e47eed832c5eb2cd85cdc0bfc697786b903bfd30f890f9d4fc36657.jpg", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/bd6464771e47eed832c5eb2cd85cdc0bfc697786b903bfd30f890f9d4fc36657.jpg", "ctype": "texture"}, {"id": "XsX3Rn", "previewfilepath": "/media/ap/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg", "ctype": "texture"}, {"id": "4sf3Rr", "previewfilepath": "/media/ap/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc-by-nc-sa-2.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4dVGzD.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "4dy3RR", "name": "Orbit trapped julia", "author": "maeln", "description": "Trying orbit trapping to color a julia fractal.", "tags": ["julia", "orbitrapped"], "likes": 5, "viewed": 693, "date": "1453206081", "time_retrieved": "2024-06-20T18:29:58.724981", "image_code": "#define MAXITER 128\n\nvec2 cmul(vec2 i1, vec2 i2) \n{\n    return vec2(i1.x*i2.x - i1.y*i2.y, i1.y*i2.x + i1.x*i2.y);\n}\n\nvec3 julia(vec2 z, vec2 c)\n{\n    int i = 0;\n    vec2 zi = z;\n    \n    float trap1 = 10e5;\n    float trap2 = 10e5;\n    \n    for(int n=0; n < MAXITER; ++n)\n    {\n        if(dot(zi,zi) > 4.0)\n            break;\n        i++;\n        zi = cmul(zi,zi) + c;\n\t\t\n        // Orbit trap\n        trap1 = min(trap1, sqrt(zi.x*zi.y));\n        trap2 = min(trap2, sqrt(zi.y*zi.y));\n    }\n    \n    return vec3(i,trap1,trap2);\n}\n\nvec4 gen_color(vec3 iter)\n{\n    float t1 = 1.0+log(iter.y)/8.0;\n    float t2 = 1.0+log(iter.z)/16.0;\n    float t3 = t1/t2;\n    \n    //vec3 comp = vec3(t1,t1,t1);\n    vec3 red = vec3(0.9,0.2,0.1);\n    vec3 black = vec3(1.0,1.0,1.0);\n    vec3 blue = vec3(0.1,0.2,0.9);\n    vec3 comp = mix(blue,black,vec3(t2));\n    comp = mix(red,comp,vec3(t1));\n    \n    return vec4(comp, 1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 z = 2.*(2.*fragCoord.xy - iResolution.xy) / iResolution.x;\n    // Display the julia fractal for C = (-0.8, [0.0;0.3]).\n    vec3 iter = julia(z, vec2(cos(iTime/5.0), mix(0.0, 0.3, sin(iTime))));\n\tfragColor = gen_color(iter);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4dy3RR.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "4dyGzD", "name": "Slightly random spheres", "author": "Emil", "description": "Slightly random.., yes", "tags": ["3d", "raymarching", "random"], "likes": 6, "viewed": 176, "date": "1453393124", "time_retrieved": "2024-06-20T18:29:58.724981", "image_code": "vec4 cellColor = vec4(0.0,0.0,0.0,0.0);\nvec3 cellPosition = vec3(0.0,0.0,0.0);\nfloat cellRandom = 0.0, onOffRandom = 0.0;\n\n\nfloat random (vec3 i){\n\treturn fract(sin(dot(i.xyz,vec3(4154895.34636,8616.15646,26968.489)))*968423.156);\n}\n\nvec4 getColorFromFloat (float i){\n    i *= 2000.0;\n    return vec4(normalize(vec3(abs(sin(i+radians(45.0))),abs(sin(i+radians(90.0))),abs(sin(i)))),1.0);\n}\n\nvec3 getPositionFromFloat (float i){\n    i *= 2000.0;\n    return vec3(normalize(vec3(abs(sin(i+radians(45.0))),abs(sin(i+radians(90.0))),abs(sin(i)))))-vec3(0.5,0.5,0.5);\n}\n\nfloat map(vec3 p){\n    //p *= 1.0;\n    cellRandom = random(floor((p*0.5)+0.0*vec3(0.5,0.5,0.5)));\n    onOffRandom = random(vec3(5.0,2.0,200.0)+floor((p*0.5)+0.0*vec3(0.5,0.5,0.5)));\n    cellColor = getColorFromFloat(cellRandom);\n    cellPosition = getPositionFromFloat(cellRandom);\n    p.x = mod(p.x, 2.0);\n    p.y = mod(p.y, 2.0);\n    p.z = mod(p.z, 2.0);\n    p += 1.0*cellPosition.xyz;\n    p += p.xyz*sin(10.0*iTime+onOffRandom*300.0)*\t\t\t0.05;\n    p += p.yzx*cos(10.0*iTime+onOffRandom*300.0+1561.355)*\t0.05;\n    if(onOffRandom>0.5){\n    \treturn length(p-vec3(1.0,1.0,1.0)) - 0.5*cellRandom*abs(sin(iTime+cellRandom*2000.0));\n    } else {\n        return 1.0;\n    }\n}\n\nfloat trace(vec3 o, vec3 r){\n    float t = 0.5;\n    const int maxSteps = 48;\n    for (int i = 0; i < maxSteps; i++){ \n        vec3 p = o + r * t;\n        float d = map(p);\n        t += d*0.35;\n    }\n    return t;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    uv = uv*2.0 -1.0;\n    uv.x *= iResolution.x / iResolution.y;\n    vec3 r = normalize(vec3(uv, 1.0));\n    \n    vec3 o = vec3(0.0,0.0,-3.0);\n    o.z = 2.6*iTime*0.5+(sin(iTime)*1.25);\n    \n    \n    float t = trace(o,r);\n    float fog = 1.0 / (1.0 + t * t * 0.1);\n    vec3 fc = vec3(fog);\n    \n\tfragColor = vec4(fc*vec3(2.0,1.0,2.0)*2.0,1.0)*cellColor;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4dyGzD.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "4scGDs", "name": "glow heart", "author": "CCFSA", "description": "simple shader for glow", "tags": ["2d", "simple"], "likes": 6, "viewed": 616, "date": "1452676505", "time_retrieved": "2024-06-20T18:29:58.724981", "image_code": "// heart function refer to https://www.shadertoy.com/view/MsSXzh\n//\n// formula SRC: http://mathworld.wolfram.com/HeartCurve.html\n\nfloat heartRadius(float theta)\n{\n    return 2. - 2.*sin(theta) + sqrt(abs(cos(theta)))*sin(theta)/(1.4 + sin(theta));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec4 _BgColor = vec4(0,0,0,0);\n    vec2 originalPos = (2.0 * fragCoord - iResolution.xy)/iResolution.yy;\n    vec2 pos = originalPos;\n    pos.y -= 0.5;        \t\n\n    pos.x /= (0.05*sin(iTime*5.0) + 0.8);\n    pos.y /= (0.05*cos(iTime*11.0) + 0.8);\n    //float a = pow(pos.x*pos.x + pos.y*pos.y - 1, 3);      \t\n    //float b = pos.x*pos.x*pos.y*pos.y*pos.y;\n\n    float theta = atan(pos.y, pos.x);\n    float r = heartRadius(theta);\n\n    // èƒŒæ™¯è‰²\n    fragColor = _BgColor;\n    fragColor = mix(fragColor, vec4(0.5*sin(iTime*4.0),0.69*cos(iTime*2.0),0.94,1.0), \n                     smoothstep(0.0, length(pos), r/8.0));\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4scGDs.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "4scGWj", "name": "Electro", "author": "sqrt_1", "description": "Port of Humus Electro demo http://humus.name/index.php?page=3D&ID=35", "tags": ["noise", "lightning", "electricity"], "likes": 90, "viewed": 11902, "date": "1452176909", "time_retrieved": "2024-06-20T18:29:59.646259", "image_code": "// Port of Humus Electro demo http://humus.name/index.php?page=3D&ID=35\n// Not exactly right as the noise is wrong, but is the closest I could make it.\n// Uses Simplex noise by Nikita Miropolskiy https://www.shadertoy.com/view/XsX3zB\n\n/* Simplex code license\n * This work is licensed under a \n * Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n * http://creativecommons.org/licenses/by-nc-sa/3.0/\n *  - You must attribute the work in the source code \n *    (link to https://www.shadertoy.com/view/XsX3zB).\n *  - You may not use this work for commercial purposes.\n *  - You may distribute a derivative work only under the same license.\n */\n\n\n/* discontinuous pseudorandom uniformly distributed in [-0.5, +0.5]^3 */\nvec3 random3(vec3 c) {\n\tfloat j = 4096.0*sin(dot(c,vec3(17.0, 59.4, 15.0)));\n\tvec3 r;\n\tr.z = fract(512.0*j);\n\tj *= .125;\n\tr.x = fract(512.0*j);\n\tj *= .125;\n\tr.y = fract(512.0*j);\n\treturn r-0.5;\n}\n\n/* skew constants for 3d simplex functions */\nconst float F3 =  0.3333333;\nconst float G3 =  0.1666667;\n\n/* 3d simplex noise */\nfloat simplex3d(vec3 p) {\n\t /* 1. find current tetrahedron T and it's four vertices */\n\t /* s, s+i1, s+i2, s+1.0 - absolute skewed (integer) coordinates of T vertices */\n\t /* x, x1, x2, x3 - unskewed coordinates of p relative to each of T vertices*/\n\t \n\t /* calculate s and x */\n\t vec3 s = floor(p + dot(p, vec3(F3)));\n\t vec3 x = p - s + dot(s, vec3(G3));\n\t \n\t /* calculate i1 and i2 */\n\t vec3 e = step(vec3(0.0), x - x.yzx);\n\t vec3 i1 = e*(1.0 - e.zxy);\n\t vec3 i2 = 1.0 - e.zxy*(1.0 - e);\n\t \t\n\t /* x1, x2, x3 */\n\t vec3 x1 = x - i1 + G3;\n\t vec3 x2 = x - i2 + 2.0*G3;\n\t vec3 x3 = x - 1.0 + 3.0*G3;\n\t \n\t /* 2. find four surflets and store them in d */\n\t vec4 w, d;\n\t \n\t /* calculate surflet weights */\n\t w.x = dot(x, x);\n\t w.y = dot(x1, x1);\n\t w.z = dot(x2, x2);\n\t w.w = dot(x3, x3);\n\t \n\t /* w fades from 0.6 at the center of the surflet to 0.0 at the margin */\n\t w = max(0.6 - w, 0.0);\n\t \n\t /* calculate surflet components */\n\t d.x = dot(random3(s), x);\n\t d.y = dot(random3(s + i1), x1);\n\t d.z = dot(random3(s + i2), x2);\n\t d.w = dot(random3(s + 1.0), x3);\n\t \n\t /* multiply d by w^4 */\n\t w *= w;\n\t w *= w;\n\t d *= w;\n\t \n\t /* 3. return the sum of the four surflets */\n\t return dot(d, vec4(52.0));\n}\n\nfloat noise(vec3 m) {\n    return   0.5333333*simplex3d(m)\n\t\t\t+0.2666667*simplex3d(2.0*m)\n\t\t\t+0.1333333*simplex3d(4.0*m)\n\t\t\t+0.0666667*simplex3d(8.0*m);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2 uv = fragCoord.xy / iResolution.xy;    \n  uv = uv * 2. -1.;  \n \n  vec2 p = fragCoord.xy/iResolution.x;\n  vec3 p3 = vec3(p, iTime*0.4);    \n    \n  float intensity = noise(vec3(p3*12.0+12.0));\n                          \n  float t = clamp((uv.x * -uv.x * 0.16) + 0.15, 0., 1.);                         \n  float y = abs(intensity * -t + uv.y);\n    \n  float g = pow(y, 0.2);\n                          \n  vec3 col = vec3(1.70, 1.48, 1.78);\n  col = col * -g + col;                    \n  col = col * col;\n  col = col * col;\n                          \n  fragColor.rgb = col;                          \n  fragColor.w = 1.;  \n}\n\n/* Origial shader and setup source\n\n!!ARBfp1.0\n\nOUTPUT output = result.color;\nTEMP glow, turb, y, t, mid;\n\nPARAM glowFallOff = 0.2;\nPARAM color = { 1.70, 1.48, 1.78, 0 };\n\nTEX\t\tturb, fragment.texcoord[0], texture[0], 3D;\nMAD\t\tturb.x, turb.x, 2, -1;\n\nMAD_SAT\tt.x, fragment.texcoord[1].y, -fragment.texcoord[1].y, 0.15;\n\nMAD\t\ty, turb.x, -t.x, fragment.texcoord[1].x;\nABS\t\ty, y;\n\nPOW\t\tglow.x, y.x, glowFallOff.x;\nMAD\t\tglow, -glow.x, color, color;\nMUL\t\tglow, glow, glow;\nMUL\t\toutput, glow, glow;\n\nEND \n*/\n\n/*\n\tfloat z = currTime * 0.8f;\n\tfloat y = z * 1.82f;\n\n\tglBegin(GL_TRIANGLE_STRIP);\n\t\tglMultiTexCoord3fARB(GL_TEXTURE0_ARB, -1, y - 1, z);\n\t\tglMultiTexCoord2fARB(GL_TEXTURE1_ARB,  1, -0.4f);\n\t\tglVertex2f(-1,  1);\n\t\tglMultiTexCoord3fARB(GL_TEXTURE0_ARB,  1, y - 1, z);\n\t\tglMultiTexCoord2fARB(GL_TEXTURE1_ARB,  1, 0.4f);\n\t\tglVertex2f( 1,  1);\n\t\tglMultiTexCoord3fARB(GL_TEXTURE0_ARB, -1, y,     z);\n\t\tglMultiTexCoord2fARB(GL_TEXTURE1_ARB,  0, -0.4f);\n\t\tglVertex2f(-1,  0);\n\t\tglMultiTexCoord3fARB(GL_TEXTURE0_ARB,  1, y,     z);\n\t\tglMultiTexCoord2fARB(GL_TEXTURE1_ARB,  0, 0.4f);\n\t\tglVertex2f( 1,  0);\n\t\tglMultiTexCoord3fARB(GL_TEXTURE0_ARB, -1, y - 1, z);\n\t\tglMultiTexCoord2fARB(GL_TEXTURE1_ARB, -1, -0.4f);\n\t\tglVertex2f(-1, -1);\n\t\tglMultiTexCoord3fARB(GL_TEXTURE0_ARB,  1, y - 1, z);\n\t\tglMultiTexCoord2fARB(GL_TEXTURE1_ARB, -1, 0.4f);\n\t\tglVertex2f( 1, -1);\n\tglEnd();\n\n*/", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4scGWj.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "4sd3Wj", "name": "Hypnose", "author": "Jespertheend", "description": "Keep looking at the center for 30 seconds or so. Then look at an object in your room.", "tags": ["2d", "circles", "blackandwhite", "hypnose"], "likes": 21, "viewed": 3151, "date": "1452208304", "time_retrieved": "2024-06-20T18:29:59.646259", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 coord = fragCoord.xy;\n    vec2 center = iResolution.xy /2.0;\n    float dist = length(center - coord);\n    float circlesOut = cos(dist/7.0 - iTime*6.0);\n    circlesOut *= 5.0;\n    float circlesIn = cos(dist/7.0 + iTime*6.0);\n    circlesIn *= 5.0;\n    circlesIn = clamp(circlesIn,0.0,1.0);\n    circlesOut = clamp(circlesOut,0.0,1.0);\n    float edge = clamp(dist-100.0,0.0,1.0);\n    circlesOut *= edge;\n    circlesIn *= 1.0-edge;\n    float c = circlesOut + circlesIn;\n\tfragColor = vec4(c,c,c,0.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4sd3Wj.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "4sd3WX", "name": "Spider Ascent", "author": "dr2", "description": "Who knows where they come from, or where they go?", "tags": ["raymarching", "fog", "octopod"], "likes": 4, "viewed": 547, "date": "1452517682", "time_retrieved": "2024-06-20T18:29:59.666356", "image_code": "// \"Spider Ascent\" by dr2 - 2016\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\nconst float pi = 3.14159;\nconst vec4 cHashA4 = vec4 (0., 1., 57., 58.);\nconst vec3 cHashA3 = vec3 (1., 57., 113.);\nconst float cHashM = 43758.54;\n\nvec4 Hashv4f (float p)\n{\n  return fract (sin (p + cHashA4) * cHashM);\n}\n\nfloat Noisefv2 (vec2 p)\n{\n  vec2 i = floor (p);\n  vec2 f = fract (p);\n  f = f * f * (3. - 2. * f);\n  vec4 t = Hashv4f (dot (i, cHashA3.xy));\n  return mix (mix (t.x, t.y, f.x), mix (t.z, t.w, f.x), f.y);\n}\n\nfloat Fbm2 (vec2 p)\n{\n  float f, a;\n  f = 0.;\n  a = 1.;\n  for (int i = 0; i < 5; i ++) {\n    f += a * Noisefv2 (p);\n    a *= 0.5;\n    p *= 2.;\n  }\n  return f;\n}\n\nfloat Fbmn (vec3 p, vec3 n)\n{\n  vec3 s = vec3 (0.);\n  float a = 1.;\n  for (int i = 0; i < 5; i ++) {\n    s += a * vec3 (Noisefv2 (p.yz), Noisefv2 (p.zx), Noisefv2 (p.xy));\n    a *= 0.5;\n    p *= 2.;\n  }\n  return dot (s, abs (n));\n}\n\nvec3 VaryNf (vec3 p, vec3 n, float f)\n{\n  vec3 e = vec3 (0.2, 0., 0.);\n  float s = Fbmn (p, n);\n  vec3 g = vec3 (Fbmn (p + e.xyy, n) - s,\n     Fbmn (p + e.yxy, n) - s, Fbmn (p + e.yyx, n) - s);\n  return normalize (n + f * (g - n * dot (n, g)));\n}\n\nfloat PrBox2Df (vec2 p, vec2 b)\n{\n  vec2 d = abs (p) - b;\n  return min (max (d.x, d.y), 0.) + length (max (d, 0.));\n}\n\nfloat PrSphDf (vec3 p, float s)\n{\n  return length (p) - s;\n}\n\nfloat PrEllipsDf (vec3 p, vec3 r, float dFac)\n{\n  return dFac * (length (p / r) - 1.);\n}\n\nfloat PrCylDf (vec3 p, float r, float h)\n{\n  return max (length (p.xy) - r, abs (p.z) - h);\n}\n\nfloat PrCylAnDf (vec3 p, float r, float w, float h)\n{\n  return max (abs (length (p.xy) - r) - w, abs (p.z) - h);\n}\n\nfloat SmoothBump (float lo, float hi, float w, float x)\n{\n  return (1. - smoothstep (hi - w, hi + w, x)) * smoothstep (lo - w, lo + w, x);\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  return q * cos (a) + q.yx * sin (a) * vec2 (-1., 1.);\n}\n\nfloat BrickPat (vec2 p)\n{\n  vec2 q, iq;\n  q = p * vec2 (1., 4.);\n  iq = floor (q);\n  if (2. * floor (iq.y / 2.) != iq.y) q.x += 0.5;\n  q = smoothstep (0.02, 0.05, abs (fract (q + 0.5) - 0.5));\n  return (0.7 + 0.3 * q.x * q.y);\n}\n\nvec3 footPos[8], kneePos[8], hipPos[8], fBallPos, noiseDisp, qHit, sunDir, wkrPos;\nfloat legLenU, legLenD, bdyHt, trRad, trGap, trWid, trThk, wkrAz, wkrEl, wkrSpd,\n   trCoil, fBallRad, tCur, dstFar;\nint idObj;\nconst int idPath = 1, idCol = 2, idWall = 3, idBdy = 11, idHead = 12, idEye = 13,\n   idAnt = 14, idLegU = 15, idLegD = 16;\n\nfloat FrAbsf (float p)\n{\n  return abs (fract (p) - 0.5);\n}\n\nvec3 FrAbsv3 (vec3 p)\n{\n  return abs (fract (p) - 0.5);\n}\n\nfloat TriNoise3d (vec3 p)\n{\n  const mat3 mr = mat3 (0., 0.8, 0.6, -0.8, 0.36, -0.48, -0.6, -0.48, 0.64);\n  vec3 q;\n  float a, f;\n  a = 1.;\n  f = 0.;\n  p *= 0.005;\n  q = p;\n  for (int j = 0; j < 5; j ++) {\n    p += FrAbsv3 (q + FrAbsv3 (q).yzx) + noiseDisp;\n    p *= 1.2;\n    f += a * (FrAbsf (p.x + FrAbsf (p.y + FrAbsf (p.z))));\n    q *= 2. * mr;\n    q += 0.21;\n    a *= 0.9;\n  }\n  return 0.1 * clamp (2. * f - 1.3, 0., 1.);\n}\n\nfloat ShpCylDf (vec3 p, vec3 v, float md, float r, float rf)\n{\n  float len, s;\n  len = length (v);\n  v = normalize (v);\n  s = clamp (dot (p, v), 0., len);\n  p -= s * v;\n  s = s / len - md;\n  return length (p) - r * (1. - rf * s * s);\n}\n\nvec3 GrndCol (vec3 ro, vec3 rd)\n{\n  vec3 vn, col;\n  vec2 w;\n  float f;\n  vec2 e = vec2 (0.01, 0.);\n  w = 0.1 * ro.xz;\n  f = Fbm2 (w);\n  vn = normalize (vec3 (f - Fbm2 (w + e.xy), 0.07, f - Fbm2 (w + e.yx)));\n  col = mix (vec3 (0.4, 0.8, 0.2), vec3 (0.3, 0.25, 0.),\n    1. + (f - 1.) * (1. - pow (1. + rd.y, 3.)));\n  col *= 0.1 + 0.9 * max (dot (vn, sunDir), 0.);\n  col = mix (col, vec3 (0.1, 0.2, 0.4) + 0.25, pow (1. + rd.y, 32.));\n  return col;\n}\n\nvec3 BgCol (vec3 ro, vec3 rd)\n{\n  vec3 col;\n  float sd, f;\n  if (rd.y > 0.) {\n    ro.xz += 2. * tCur;\n    sd = max (dot (rd, sunDir), 0.);\n    col = vec3 (0.1, 0.2, 0.4) + 0.2 * pow (1. - max (rd.y, 0.), 8.) +\n       0.35 * pow (sd, 6.) + 0.65 * min (pow (sd, 256.), 0.3);\n    f = Fbm2 (0.02 * (ro.xz + rd.xz * (300. - ro.y) / rd.y));\n    col = mix (col, vec3 (1.), clamp (0.1 + 0.8 * f * rd.y, 0., 1.));\n  } else {\n    sd = - ro.y / rd.y;\n    ro += sd * rd;\n    col = GrndCol (ro, rd);\n  }\n  return col;\n}\n\nfloat FBallHit (vec3 ro, vec3 rd, vec3 p, float s)\n{\n  vec3 v;\n  float h, b, d;\n  v = ro - p;\n  b = dot (rd, v);\n  d = b * b + s * s - dot (v, v);\n  h = dstFar;\n  if (d >= 0.) h = - b - sqrt (d);\n  return h;\n}\n\nfloat WkrDf (vec3 p, float dMin)\n{\n  vec3 q;\n  float d, yLim, s, len;\n  yLim = max (- p.y, p.y - trCoil * trGap);\n  p.y = mod (p.y + 0.5 * trGap - (wkrPos.y + bdyHt), trGap) -\n     (0.5 * trGap - (wkrPos.y + bdyHt));\n  p -= wkrPos;\n  p.xz = Rot2D (p.xz, - wkrAz);\n  p.yz = Rot2D (p.yz, wkrEl);\n  p.y -= bdyHt + trThk;\n  d = max (PrCylDf (p.xzy, 4.5, 2.2), yLim);\n  if (d < dMin) {\n    q = p - vec3 (0., -0.15, 0.2);\n    d = PrEllipsDf (q, vec3 (0.7, 0.5, 1.3), 0.6);\n    if (d < dMin) { dMin = d;  idObj = idBdy;  qHit = q; }\n    q = p - vec3 (0., 0.1, 1.1);\n    d = PrEllipsDf (q, vec3 (0.2, 0.4, 0.5), 0.2);\n    if (d < dMin) { dMin = d;  idObj = idHead;  qHit = q; }\n    q = p;\n    q.x = abs (q.x);\n    q -= vec3 (0.15, 0.25, 1.5);\n    d = PrSphDf (q, 0.13);\n    if (d < dMin) { dMin = d;  idObj = idEye; }\n    q -= vec3 (0., 0.15, -0.3);\n    d = ShpCylDf (q, vec3 (0.3, 1.1, 0.4), 0., 0.1, 0.7);\n    if (d < dMin) { dMin = d;  idObj = idAnt; }\n    p.y += bdyHt;\n    for (int j = 0; j < 8; j ++) {\n      q = p - hipPos[j];\n      d = 0.6 * ShpCylDf (q, kneePos[j] - hipPos[j], 0., 0.22, 0.4);\n      if (d < dMin) { dMin = d;  idObj = idLegU;  qHit = q; }\n      q = p - kneePos[j];\n      d = 0.6 * ShpCylDf (q, footPos[j] - kneePos[j], 0.3, 0.15, 1.3);\n      if (d < dMin) { dMin = d;  idObj = idLegD;  qHit = q; }\n    }\n  }\n  return dMin;\n}\n\nfloat ObjDf (vec3 p)\n{\n  float dMin = dstFar;\n  vec3 q;\n  float dr, d;\n  q = p;\n  q.y = mod (q.y + trGap - 0.0001, trGap) - (trGap - 0.0001);\n  q.y -= trGap * atan (q.z, q.x) / (2. * pi);\n  dr = length (q.xz) - trRad;\n  d = PrBox2Df (vec2 (dr, q.y), vec2 (trWid, trThk));\n  q.y += trGap;\n  d = min (d, PrBox2Df (vec2 (dr, q.y), vec2 (trWid, trThk)));\n  d = max (d, p.y - trCoil * trGap);\n  if (d < dMin) { dMin = d;  idObj = idPath;  qHit = q; }\n  q = p;\n  q.xz = abs (q.xz) - (trRad - trWid - 4. * trThk) / 1.414;\n  d = PrCylDf (q.xzy, 3. * trThk, trCoil * trGap);\n  if (d < dMin) { dMin = d;  idObj = idCol;  qHit = q; }\n  q = p;\n  q.y -= 0.1 * trGap;\n  d = min (PrCylAnDf (q.xzy, trRad + 1.1 * trWid, 0.1 * trWid, trGap),\n     PrCylAnDf (q.xzy, trRad - 1.1 * trWid, 0.1 * trWid, trGap));\n  if (d < dMin) { dMin = d;  idObj = idWall;  qHit = q; }\n  dMin = WkrDf (p, dMin);\n  d = p.y;\n  if (d < dMin) { dMin = d;  idObj = -1; }\n  return dMin;\n}\n\nfloat ObjRay (vec3 ro, vec3 rd)\n{\n  float dHit, d;\n  dHit = 0.;\n  for (int j = 0; j < 100; j ++) {\n    d = ObjDf (ro + dHit * rd);\n    dHit += d;\n    if (d < 0.001 || dHit > dstFar) break;\n  }\n  return dHit;\n}\n\nvec3 ObjNf (vec3 p)\n{\n  const vec3 e = vec3 (0.0001, -0.0001, 0.);\n  vec4 v = vec4 (ObjDf (p + e.xxx), ObjDf (p + e.xyy),\n     ObjDf (p + e.yxy), ObjDf (p + e.yyx));\n  return normalize (vec3 (v.x - v.y - v.z - v.w) + 2. * vec3 (v.y, v.z, v.w));\n}\n\nfloat ObjSShadow (vec3 ro, vec3 rd)\n{\n  float sh, d, h;\n  sh = 1.;\n  d = 0.05;\n  for (int j = 0; j < 20; j ++) {\n    h = ObjDf (ro + rd * d);\n    sh = min (sh, smoothstep (0., 1., 20. * h / d));\n    d += 0.25 + 0.1 * d;\n    if (h < 0.001) break;\n  }\n  return 0.5  + 0.5 * sh;\n}\n\nvec3 FBallCol (vec3 col, vec3 ro, vec3 rd, float dHit, float tRot)\n{\n  vec3 p;\n  const vec3 cFog = vec3 (0.8, 0.8, 0.9);\n  float diAx, d, b, f;\n  ro -= fBallPos;\n  ro.xz = Rot2D (ro.xz, tRot);\n  rd.xz = Rot2D (rd.xz, tRot);\n  diAx = 1. / max (0.001, length (ro - dot (rd, ro) * rd));\n  b = 0.05 * fBallRad;\n  d = 0.;\n  for (int i = 0; i < 20; i ++) {\n    d += b;\n    f = smoothstep (1., 1.3, sqrt (d * (2. * fBallRad - d)) * diAx);\n    p = ro + d * rd;\n    f = clamp (TriNoise3d (p) * f * f, 0., 1.);\n    col += f * (cFog - col);\n    if (length (p) > fBallRad) break;\n  }\n  return col;\n}\n\nvec4 WkrCol (vec3 vn)\n{\n  vec4 col;\n  if (idObj == idBdy) {\n    col = vec4 (0.3, 0.3, 1., 0.5);\n  } else if (idObj == idHead) {\n    col = vec4 (0.3, 0.3, 1., 0.5);\n    if (qHit.z > 0.4) col = mix (vec4 (0.2, 0.05, 0.05, 0.1), col,\n       smoothstep (0.02, 0.04, abs (qHit.x)));\n  } else if (idObj == idEye) {\n    col = (vn.z > 0.6) ? vec4 (1., 0., 0., 0.3) : vec4 (1., 1., 0., 1.);\n  } else if (idObj == idLegU || idObj == idLegD) {\n    col = mix (vec4 (0.3, 0.3, 1., 0.5), vec4 (1., 0.2, 0.2, 0.5),\n       SmoothBump (0.4, 1., 0.2, fract (0.7 * length (qHit))));\n  } else if (idObj == idAnt) {\n    col = vec4 (0., 1., 0., 0.5);\n  }\n  return col;\n}\n\nvoid Setup ()\n{\n  vec3 v;\n  float gDisp, a, az, fz, d, ll, t;\n  wkrSpd = 8.;\n  trRad = 20.;\n  trWid = 4.5;\n  trThk = 0.2;\n  trGap = 10.;\n  trCoil = 15.;\n  t = mod ((wkrSpd / (2. * pi * (trRad + 1.))) * tCur, 1.);\n  wkrAz = 2. * pi * t;\n  wkrEl = asin (trGap / (2. * pi * trRad));\n  wkrPos.xz = trRad * vec2 (cos (wkrAz), sin (wkrAz));\n  wkrPos.y = trGap * t;\n  fBallRad = trRad + 4.2 * trWid;\n  fBallPos = vec3 (0., trCoil * trGap, 0.);\n  for (int j = 0; j < 4; j ++) {\n    a = 0.2 * (1. + float (j)) * pi;\n    hipPos[j] = 0.5 * vec3 (- sin (a), 0., 1.5 * cos (a));\n    hipPos[j + 4] = hipPos[j];  hipPos[j + 4].x *= -1.;\n  }\n  gDisp = wkrSpd * tCur;\n  bdyHt = 2.4;\n  legLenU = 2.2;\n  legLenD = 3.;\n  ll = legLenD * legLenD - legLenU * legLenU;\n  for (int j = 0; j < 8; j ++) {\n    fz = fract ((gDisp + 0.93 + ((j < 4) ? -1. : 1.) +\n       mod (7. - float (j), 4.)) / 3.);\n    az = smoothstep (0.7, 1., fz);\n    footPos[j] = 5. * hipPos[j];\n    footPos[j].x *= 1.7;\n    footPos[j].y += 0.7 * sin (pi * clamp (1.4 * az - 0.4, 0., 1.));\n    footPos[j].z += ((j < 3) ? 0.5 : 1.) - 3. * (fz - az);\n    hipPos[j] += vec3 (0., bdyHt - 0.3, 0.2);\n    v = footPos[j] - hipPos[j];\n    d = length (v);\n    a = asin ((hipPos[j].y - footPos[j].y) / d);\n    kneePos[j].y = footPos[j].y + legLenD *\n       sin (acos ((d * d + ll) / (2. * d *  legLenD)) + a);\n    kneePos[j].xz = hipPos[j].xz + legLenU * sin (acos ((d * d - ll) /\n       (2. * d *  legLenU)) + 0.5 * pi - a) * normalize (v.xz);\n  }\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  vec4 objCol;\n  vec3 vn, col, roo;\n  float dstHit, dstBHit, spec, sh, f;\n  int idObjT;\n  col = vec3 (0.);\n  noiseDisp = 0.07 * tCur * vec3 (-1., 0., 1.);\n  dstBHit = FBallHit (ro, rd, fBallPos, fBallRad);\n  roo = ro;\n  idObj = -1;\n  dstHit = ObjRay (ro, rd);\n  if (idObj < 0) dstHit = dstFar;\n  if (dstHit < dstFar) {\n    ro += rd * dstHit;\n    idObjT = idObj;\n    vn = ObjNf (ro);\n    idObj = idObjT;\n    if (idObj >= idBdy) {\n      objCol = WkrCol (vn);\n      col = objCol.rgb;\n      spec = objCol.a;\n    } else if (idObj == idPath) {\n      vn = VaryNf (100. * ro, vn, 0.5);\n      col = vec3 (0.45, 0.4, 0.4);\n      spec = 0.2;\n    } else if (idObj == idCol) {\n      col = vec3 (0.3, 0.3, 0.35);\n      spec = 0.5;\n    } else if (idObj == idWall) {\n      col = vec3 (0.8, 0.5, 0.) * BrickPat (mod (vec2 (50. *\n         atan (qHit.z, - qHit.x) / (2. * pi), 0.2 * qHit.y), 1.));\n      spec = 0.2;\n    } else {\n      col = vec3 (1., 1., 0.5);\n    }\n    sh = ObjSShadow (ro, sunDir);\n    col = col * (0.2 + sh * 0.7 * max (dot (vn, sunDir), 0.)) +\n       0.5 * sh * spec * pow (max (0., dot (sunDir, reflect (rd, vn))), 64.);\n    f = clamp (5. * ro.y / (trCoil * trGap) - 4., 0., 1.);\n    col = mix (col, BgCol (roo, rd), f * f * f);\n  } else {\n    col = BgCol (ro, rd);\n    if (rd.y < 0.) col *= ObjSShadow (ro - rd * ro.y / rd.y, sunDir);\n  }\n  if (dstBHit < min (dstHit, dstFar))\n     col = FBallCol (col, roo + rd * dstBHit, rd, dstBHit, 0.1 * tCur);\n  col = pow (clamp (col, 0., 1.), vec3 (0.7));\n  return col;\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  mat3 vuMat;\n  vec3 ro, rd;\n  vec2 canvas, uv, vf, cf, sf;\n  canvas = iResolution.xy;\n  uv = 2. * fragCoord.xy / canvas - 1.;\n  uv.x *= canvas.x / canvas.y;\n  tCur = iTime;\n  Setup ();\n  vf = vec2 (0.02 * pi, pi - 0.05 * tCur);\n  cf = cos (vf);\n  sf = sin (vf);\n  vuMat = mat3 (1., 0., 0., 0., cf.x, - sf.x, 0., sf.x, cf.x) *\n     mat3 (cf.y, 0., sf.y, 0., 1., 0., - sf.y, 0., cf.y);\n  rd = normalize (vec3 (uv, 6.)) * vuMat;\n  dstFar = 300.;\n  ro = vec3 (0., 0., -200.) * vuMat;\n  ro.y = trCoil * trGap * (0.25 + 0.75 *\n     SmoothBump (0.25, 0.75, 0.2, mod (0.02 * tCur, 1.)));\n  sunDir = normalize (vec3 (0.5, 1., 0.5));\n  fragColor = vec4 (ShowScene (ro, rd), 1.);\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc-by-nc-sa-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4sd3WX.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "4sdGWB", "name": "Totally Not The Game", "author": "Ziziiii", "description": "mneh", "tags": ["game"], "likes": 0, "viewed": 162, "date": "1452012549", "time_retrieved": "2024-06-20T18:30:00.446105", "image_code": "// Using samples from Alexander Lemke\n\n// By Alexander Lemke\n\n/**\n * References:\n *\n * - https://www.shadertoy.com/view/XsBGRt\n*/\n\n#define LETTER_A(position) BitCheck(0x3F, 0x48, 0x48, 0x48, 0x3F, position); position.x -= 7.0 \n#define LETTER_B(position) BitCheck(0x7F, 0x49, 0x49, 0x49, 0x36, position); position.x -= 7.0 \n#define LETTER_C(position) BitCheck(0x3E, 0x41, 0x41, 0x41, 0x41, position); position.x -= 7.0 \n#define LETTER_D(position) BitCheck(0x7F, 0x41, 0x41, 0x41, 0x3E, position); position.x -= 7.0 \n#define LETTER_E(position) BitCheck(0x7F, 0x49, 0x49, 0x49, 0x49, position); position.x -= 7.0 \n#define LETTER_F(position) BitCheck(0x7F, 0x48, 0x48, 0x48, 0x48, position); position.x -= 7.0 \n#define LETTER_G(position) BitCheck(0x3E, 0x41, 0x41, 0x49, 0x49, 0x2E, position); position.x -= 8.0 \n#define LETTER_H(position) BitCheck(0x7F, 0x8, 0x8, 0x8, 0x7F, position); position.x -= 7.0 \n#define LETTER_I(position) BitCheck(0x41, 0x41, 0x7F, 0x41, 0x41, position); position.x -= 7.0 \n#define LETTER_J(position) BitCheck(0x42, 0x41, 0x41, 0x7E, 0x40, 0x40, position); position.x -= 8.0 \n#define LETTER_K(position) BitCheck(0x7F, 0x8, 0x8, 0x14, 0x22, 0x41, position); position.x -= 8.0 \n#define LETTER_L(position) BitCheck(0x7F, 0x1, 0x1, 0x1, 0x1, position); position.x -= 7.0 \n#define LETTER_M(position) BitCheck(0x7F, 0x40, 0x20, 0x1F, 0x20, 0x40, 0x7F, position); position.x -= 9.0 \n#define LETTER_N(position) BitCheck(0x7F, 0x20, 0x18, 0x6, 0x1, 0x7F, position); position.x -= 8.0 \n#define LETTER_O(position) BitCheck(0x3E, 0x41, 0x41, 0x41, 0x41, 0x3E, position); position.x -= 8.0 \n#define LETTER_P(position) BitCheck(0x7F, 0x48, 0x48, 0x48, 0x30, position); position.x -= 7.0 \n#define LETTER_Q(position) BitCheck(0x3E, 0x41, 0x41, 0x45, 0x42, 0x3D, position); position.x -= 8.0 \n#define LETTER_R(position) BitCheck(0x7F, 0x48, 0x4C, 0x4A, 0x31, position); position.x -= 7.0 \n#define LETTER_S(position) BitCheck(0x31, 0x49, 0x49, 0x49, 0x46, position); position.x -= 7.0 \n#define LETTER_T(position) BitCheck(0x40, 0x40, 0x7F, 0x40, 0x40, position); position.x -= 7.0 \n#define LETTER_U(position) BitCheck(0x7E, 0x1, 0x1, 0x1, 0x7E, position); position.x -= 7.0 \n#define LETTER_V(position) BitCheck(0x70, 0xE, 0x1, 0xE, 0x70, position); position.x -= 7.0 \n#define LETTER_W(position) BitCheck(0x7C, 0x2, 0x1, 0x7E, 0x1, 0x2, 0x7C, position); position.x -= 9.0 \n#define LETTER_X(position) BitCheck(0x63, 0x14, 0x8, 0x14, 0x63, position); position.x -= 7.0 \n#define LETTER_Y(position) BitCheck(0x60, 0x10, 0xF, 0x10, 0x60, position); position.x -= 7.0 \n#define LETTER_Z(position) BitCheck(0x41, 0x43, 0x45, 0x49, 0x51, 0x61, position); position.x -= 8.0 \n\n#define SPACE(position) position.x -= 8.0 \n#define NEGATIVE(position) BitCheck(0x8, 0x8, 0x8, position); position.x -= 5.0 \n\n#define NUMBER_1(position) BitCheck(0x21, 0x21, 0x7F, 0x1, 0x1, position); position.x -= 7.0 \n#define NUMBER_2(position) BitCheck(0x23, 0x45, 0x49, 0x49, 0x31, position); position.x -= 7.0 \n#define NUMBER_3(position) BitCheck(0x49, 0x49, 0x49, 0x49, 0x36, position); position.x -= 7.0 \n#define NUMBER_4(position) BitCheck(0x78, 0x8, 0x8, 0x7F, 0x8, position); position.x -= 7.0 \n#define NUMBER_5(position) BitCheck(0x72, 0x49, 0x49, 0x49, 0x46, position); position.x -= 7.0 \n#define NUMBER_6(position) BitCheck(0x3E, 0x49, 0x49, 0x49, 0x26, position); position.x -= 7.0  \n#define NUMBER_7(position) BitCheck(0x41, 0x42, 0x44, 0x48, 0x50, 0x60, position); position.x -= 8.0  \n#define NUMBER_8(position) BitCheck(0x36, 0x49, 0x49, 0x49, 0x36, position); position.x -= 7.0 \n#define NUMBER_9(position) BitCheck(0x32, 0x49, 0x49, 0x49, 0x3E, position); position.x -= 7.0 \n#define NUMBER_0(position) BitCheck(0x3E, 0x41, 0x41, 0x41, 0x3E, position); position.x -= 7.0 \n\n\nfloat BitCheck(in int c1, in int c2, in int c3, in int c4, in int c5, in int c6, in int c7, in vec2 textPos) \n{\n    float columnBits = 0.0;\n    \n    int textColumn = int(textPos.x);\n    \n    if (textColumn == 1) { columnBits = float(c1); }\n    else if (textColumn == 2) { columnBits = float(c2); }\n    else if (textColumn == 3) { columnBits = float(c3); }\n    else if (textColumn == 4) { columnBits = float(c4); }\n    else if (textColumn == 5) { columnBits = float(c5); }\n    else if (textColumn == 6) { columnBits = float(c6); }\n    else if (textColumn == 7) { columnBits = float(c7); }\n       \n    return floor(fract(columnBits / pow(2.0, floor(textPos.y))) * 2.0);\n}\n\nfloat BitCheck(in int c1, in int c2, in int c3, in int c4, in int c5, in int c6, in vec2 textPos) \n{\n    return BitCheck(c1, c2, c3, c4, c5, c6, 0, textPos);\n}\n\nfloat BitCheck(in int c1, in int c2, in int c3, in int c4, in int c5, in vec2 textPos) \n{\n    return BitCheck(c1, c2, c3, c4, c5, 0, textPos);\n}\n\nfloat BitCheck(in int c1, in int c2, in int c3, in int c4, in vec2 textPos) \n{\n    return BitCheck(c1, c2, c3, c4, 0, textPos);\n}\n\nfloat BitCheck(in int c1, in int c2, in int c3, in vec2 textPos) \n{\n    return BitCheck(c1, c2, c3, 0, textPos);\n}\n\n\nfloat WriteString(in vec2 textCursor, in vec2 fragCoord, in float scale)\n{\n    fragCoord = (fragCoord.xy * iResolution.xy) / scale;\n    vec2 textPos = floor(fragCoord.xy - (textCursor.xy  / scale) + 1.0);\n    \n    if (textPos.y < 1.0 || textPos.y > 8.0) \n        return 0.0;\n        \n    float bitVal = 0.0;\n\n    bitVal += LETTER_T(textPos);\n    bitVal += LETTER_H(textPos);\n    bitVal += LETTER_E(textPos);\n    SPACE(textPos);\n    \n    bitVal += LETTER_G(textPos);\n    bitVal += LETTER_A(textPos);\n    bitVal += LETTER_M(textPos);\n    bitVal += LETTER_E(textPos);\n    \n\n    return bitVal;\n}\n\nfloat WriteString2(in vec2 textCursor, in vec2 fragCoord, in float scale)\n{\n    fragCoord = (fragCoord.xy * iResolution.xy) / scale;\n    vec2 textPos = floor(fragCoord.xy - (textCursor.xy  / scale) + 1.0);\n    \n    if (textPos.y < 1.0 || textPos.y > 8.0) \n        return 0.0;\n        \n    float bitVal = 0.0;\n\n    bitVal += LETTER_H(textPos);\n    bitVal += LETTER_A(textPos);\n    bitVal += LETTER_H(textPos);\n    bitVal += LETTER_A(textPos);\n    SPACE(textPos);\n    \n    bitVal += LETTER_S(textPos);\n    bitVal += LETTER_O(textPos);\n    bitVal += LETTER_R(textPos);\n    bitVal += LETTER_R(textPos);\n    bitVal += LETTER_Y(textPos);\n    \n    \n\n    return bitVal;\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    \n    \n    \n    //uv.x /= uv.y;\n    //uv.x+= 0.5;\n    \n    vec2 textPosition = vec2(iResolution.x/3.0 , -20.0 + iTime*20.0);\n    float textBit = WriteString(textPosition, uv, 2.0);\n    textPosition = vec2(iResolution.x/4.0 , -200.0 + iTime*20.0);\n    textBit += WriteString2(textPosition, uv, 2.0);\n    \n    //textBit += WriteInteger(textPosition, uv, 2.0, int(iTime));\n    \n    vec3 fontColor = vec3(1.0,1.0,0.3);\n    fragColor = vec4(fontColor * textBit, 1.0);\n }\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4sdGWB.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "4sdGWS", "name": "Untitled 02", "author": "floz", "description": "Untitled 02 - \nWeek1 - Shader everyday (style)", "tags": ["raymarching", "sphere", "mod"], "likes": 2, "viewed": 180, "date": "1451985083", "time_retrieved": "2024-06-20T18:30:01.458505", "image_code": "#define PI 3.141592654\n\n//------------------------------------------------------------------ VISUAL QUALITY\n#define RAYMARCHING_STEP 30\n#define RAYMARCHING_JUMP 1.\n\n//------------------------------------------------------------------ DEBUG\n//define RENDER_DEPTH\n//define RENDER_NORMAL\n//#define RENDER_AO\n\nfloat hash( float n ){//->0:1\n\treturn fract(sin(n)*3538.5453);\n}\n\n//------------------- CAMERA STUFF\n\nvec3 orbit(float phi, float theta, float radius)\n{\n\treturn vec3(\n\t\tradius * sin( phi ) * cos( theta ),\n\t\tradius * cos( phi ),\n\t\tradius * sin( phi ) * sin( theta )\n\t);\n}\n\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr )\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n\treturn mat3( cu, cv, cw );\n}\n\n//------------------- PRIMITIVES\n\nvec2 rotate2D(vec2 p, float a) {\n return p * mat2(cos(a), -sin(a), sin(a),  cos(a));\n}\n\nfloat sphere( vec3 p, float r ) {\n\treturn length( p ) - r;\n}\n\nfloat displacement( vec3 p, float v ) {\n  float f = iTime * -0.5 + sin( iTime * 2. ) * 1.4;\n  return sin( 20. * sin( cos( f ) ) *p.x)*sin( 10. *sin( cos( f ) ) *p.y)*sin( 30. * sin( cos( f ) ) *p.z);\n}\n\n// Repeat around the origin by a fixed angle.\n// For easier use, num of repetitions is use to specify the angle.\nfloat pModPolar(inout vec2 p, float repetitions) {\n\tfloat angle = 2.*PI/repetitions;\n\tfloat a = atan(p.y+0.0000001, p.x+0.0000001) + angle/2.;\n\tfloat r = length(p);\n\tfloat c = floor(a/angle);\n\ta = mod(a,angle) - angle/2.;\n\tp = vec2(cos(a), sin(a))*r + 0.0000001;\n\t// For an odd number of repetitions, fix cell index of the cell in -x direction\n\t// (cell index would be e.g. -5 and 5 in the two halves of the cell):\n\tif (abs(c) >= (repetitions/2.)) c = abs(c);\n\treturn c;\n}\n\n//------------------- MAP\n\nfloat map( in vec3 p ) {\n    vec3 np = vec3( p.x, p.y, p.z + 2. );\n    vec3 t = vec3( 2., 0., 2. );\n    //vec3 q = mod( np + vec3( 1., 0., -4. ), t ) - t * .5;\n    vec3 q = np;\n    q.xy = rotate2D( q.xy, iTime * -0.5 + sin( iTime * 2. ) * 0.4 );\n    pModPolar( q.xy, 4. + 4. * sin( cos( iTime*2. ) ) ); \n    q -= vec3( 1. + sin( iTime * 2.), 0., 0. );\n    \n    float p1 = sphere( q, .5 );\n    float p2 = displacement( q, 10. );\n    return p1 + p2 * ( 0.025 + 0.0025 * hash( sin( cos( iTime * -0.5 + sin( iTime * 2. ) * 0.4 ) ) ) );// * ( .025 * sin( iTime*2. ) + .025 * sin( sin( iTime * 4. ) ) );\n}\n\n//------------------- RAYMARCHING\n\n#ifdef RENDER_DEPTH\nfloat castRay( in vec3 ro, in vec3 rd, inout float depth ) {\n#else\nfloat castRay( in vec3 ro, in vec3 rd ) {\n#endif\n    float t = 0.;\n    float res;\n    for( int i = 0; i < RAYMARCHING_STEP; i++ ) {\n        vec3 pos = ro + rd * t;\n        res = map( pos );\n        if( res < .01 || t > 100. ) break;\n        t += res * RAYMARCHING_JUMP;\n        #ifdef RENDER_DEPTH\n\t\tdepth += 1./float(RAYMARCHING_STEP);\n\t\t#endif\n    }\n    return t;\n}\n\nvec3 calcNormal(vec3 pos) {\n    float eps = 0.001;\n\tconst vec3 v1 = vec3( 1.0,-1.0,-1.0);\n\tconst vec3 v2 = vec3(-1.0,-1.0, 1.0);\n\tconst vec3 v3 = vec3(-1.0, 1.0,-1.0);\n\tconst vec3 v4 = vec3( 1.0, 1.0, 1.0);\n\treturn normalize( v1 * map( pos + v1*eps ) +\n    \t              v2 * map( pos + v2*eps ) +\n        \t          v3 * map( pos + v3*eps ) +\n            \t      v4 * map( pos + v4*eps ) );\n}\n\nfloat calcAO( in vec3 p, in vec3 n, float maxDist, float falloff ){\n\tfloat ao = 0.0;\n\tconst int nbIte = 6;\n\tfor( int i=0; i<nbIte; i++ )\n\t{\n\t\tfloat l = hash(float(i))*maxDist;\n\t\tvec3 rd = n*l;\n\t\tao += (l - map( p + rd )) / pow(1.+l, falloff);\n\t}\n\treturn clamp( 1.-ao/float(nbIte), 0., 1.);\n}\n    \nvec3 sundir = normalize( vec3(-1.0,0.,-1.0) );\n\nvec3 render( in vec3 ro, in vec3 rd, in vec2 uv ) {\n\tvec3 col = vec3( 1., .0, 1. );\n    \n    float sun = clamp( dot(sundir,rd), 0.0, 1.0 );\n    vec3 colBg = vec3(0.6,0.71,0.75) - rd.y*0.2*vec3(1.0,0.5,1.0) + 0.15*0.5;\n\tcolBg += 0.2*vec3(1.0,.6,0.1)*pow( sun, 8.0 );\n    \n    #ifdef RENDER_DEPTH\n\tfloat depth = 0.;\n    float t = castRay( ro, rd, depth );\n    #else\n    float t = castRay( ro, rd );\n    #endif\n    \n    #ifdef RENDER_DEPTH\n    return vec3( depth / 5., depth, depth );\n    #endif\n    \n    vec3 pos = ro + t * rd;\n    vec3 nor = calcNormal( pos );\n    \n    #ifdef RENDER_NORMAL\n    return nor;\n    #endif\n    \n    float ao = calcAO( pos, nor, 10., 1.2 );\n    #ifdef RENDER_AO\n    return vec3( ao );\n    #endif\n    \n    //vec3 light = vec3( 1.5, 1., 1. );\n    \n    vec3 r = reflect( pos, nor );\n    float m = abs( 2. * sqrt( pow( r.x, 2. ) + pow( r.y, 2. ) + pow( r.z + 1., 2. ) ) );\n    col = colBg + colBg * max( dot( r, sundir ), 0. );\n    //col = col + col * vec3( reflect( pos, nor ) );\n    col += 0.2 * vec3( 1., 0.4, 0.2 ) * abs( pow( sun, 3. ) );\n    col *= ao;\n    \n    vec3 fog = vec3( 0. );\n    col = mix( col, colBg, 1. - exp( -.0125 * t * t ) );   \n    \n    col = col;\n    \n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 p = -1. + 2. * uv;\n    p.x *= iResolution.x / iResolution.y;\n    \n    //vec2 m = iMouse.xy/iResolution.xy;\n    \n    // Camera\n    //vec3 ro = 4.0*normalize(vec3(sin(3.0*m.x), 0.4*m.y, cos(3.0*m.x)));\n    vec3 ro = vec3( 0.0000001, 0.0000001, 2. );\n    vec3 ta = vec3( 0.0000001, 0.0000001, 0.0000001 );\n    \n    // Camera to world transformation\n    mat3 ca = setCamera( ro, ta, 0. );\n    \n    // Ray direction\n    vec3 rd = ca * normalize( vec3( p.xy, 2. ) );\n    \n    // Raymarching\n    vec3 color = render( ro, rd, uv );\n    fragColor = vec4( color, 1. );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4sdGWS.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "4sG3W1", "name": "learning how to sphere", "author": "capitanNeptune", "description": "learning something from that tutorial:\nhttp://www.raywenderlich.com/70208/opengl-es-pixel-shaders-tutorial", "tags": ["shadow", "sphere"], "likes": 4, "viewed": 569, "date": "1454173567", "time_retrieved": "2024-06-20T18:30:02.313207", "image_code": "// http://www.raywenderlich.com/70208/opengl-es-pixel-shaders-tutorial\n// all noise from iq\n\n#define time iTime*0.5\n\nfloat noise3D(vec3 p)\n{\n\treturn fract(sin(dot(p ,vec3(12.9898,78.233,128.852))) * 43758.5453)*2.0-1.0;\n}\n\nfloat simplex3D(vec3 p)\n{\n\t\n\tfloat f3 = 1.0/3.0;\n\tfloat s = (p.x+p.y+p.z)*f3;\n\tint i = int(floor(p.x+s));\n\tint j = int(floor(p.y+s));\n\tint k = int(floor(p.z+s));\n\t\n\tfloat g3 = 1.0/6.0;\n\tfloat t = float((i+j+k))*g3;\n\tfloat x0 = float(i)-t;\n\tfloat y0 = float(j)-t;\n\tfloat z0 = float(k)-t;\n\tx0 = p.x-x0;\n\ty0 = p.y-y0;\n\tz0 = p.z-z0;\n\t\n\tint i1,j1,k1;\n\tint i2,j2,k2;\n\t\n\tif(x0>=y0)\n\t{\n\t\tif\t\t(y0>=z0){ i1=1; j1=0; k1=0; i2=1; j2=1; k2=0; } // X Y Z order\n\t\telse if\t(x0>=z0){ i1=1; j1=0; k1=0; i2=1; j2=0; k2=1; } // X Z Y order\n\t\telse \t\t\t{ i1=0; j1=0; k1=1; i2=1; j2=0; k2=1; } // Z X Z order\n\t}\n\telse \n\t{ \n\t\tif\t\t(y0<z0) { i1=0; j1=0; k1=1; i2=0; j2=1; k2=1; } // Z Y X order\n\t\telse if\t(x0<z0) { i1=0; j1=1; k1=0; i2=0; j2=1; k2=1; } // Y Z X order\n\t\telse \t\t\t{ i1=0; j1=1; k1=0; i2=1; j2=1; k2=0; } // Y X Z order\n\t}\n\t\n\tfloat x1 = x0 - float(i1) + g3; \n\tfloat y1 = y0 - float(j1) + g3;\n\tfloat z1 = z0 - float(k1) + g3;\n\tfloat x2 = x0 - float(i2) + 2.0*g3; \n\tfloat y2 = y0 - float(j2) + 2.0*g3;\n\tfloat z2 = z0 - float(k2) + 2.0*g3;\n\tfloat x3 = x0 - 1.0 + 3.0*g3; \n\tfloat y3 = y0 - 1.0 + 3.0*g3;\n\tfloat z3 = z0 - 1.0 + 3.0*g3;\t\n\t\t\t\t \n\tvec3 ijk0 = vec3(i,j,k);\n\tvec3 ijk1 = vec3(i+i1,j+j1,k+k1);\t\n\tvec3 ijk2 = vec3(i+i2,j+j2,k+k2);\n\tvec3 ijk3 = vec3(i+1,j+1,k+1);\t\n            \n\tvec3 gr0 = normalize(vec3(noise3D(ijk0),noise3D(ijk0*2.01),noise3D(ijk0*2.02)));\n\tvec3 gr1 = normalize(vec3(noise3D(ijk1),noise3D(ijk1*2.01),noise3D(ijk1*2.02)));\n\tvec3 gr2 = normalize(vec3(noise3D(ijk2),noise3D(ijk2*2.01),noise3D(ijk2*2.02)));\n\tvec3 gr3 = normalize(vec3(noise3D(ijk3),noise3D(ijk3*2.01),noise3D(ijk3*2.02)));\n\t\n\tfloat n0 = 0.0;\n\tfloat n1 = 0.0;\n\tfloat n2 = 0.0;\n\tfloat n3 = 0.0;\n\n\tfloat t0 = 0.5 - x0*x0 - y0*y0 - z0*z0;\n\tif(t0>=0.0)\n\t{\n\t\tt0*=t0;\n\t\tn0 = t0 * t0 * dot(gr0, vec3(x0, y0, z0));\n\t}\n\tfloat t1 = 0.5 - x1*x1 - y1*y1 - z1*z1;\n\tif(t1>=0.0)\n\t{\n\t\tt1*=t1;\n\t\tn1 = t1 * t1 * dot(gr1, vec3(x1, y1, z1));\n\t}\n\tfloat t2 = 0.5 - x2*x2 - y2*y2 - z2*z2;\n\tif(t2>=0.0)\n\t{\n\t\tt2 *= t2;\n\t\tn2 = t2 * t2 * dot(gr2, vec3(x2, y2, z2));\n\t}\n\tfloat t3 = 0.5 - x3*x3 - y3*y3 - z3*z3;\n\tif(t3>=0.0)\n\t{\n\t\tt3 *= t3;\n\t\tn3 = t3 * t3 * dot(gr3, vec3(x3, y3, z3));\n\t}\n\treturn 96.0*(n0+n1+n2+n3);\n\t\n}\n\nfloat fbm(vec3 p)\n{\n\tfloat f;\n    f  = 0.50000*(simplex3D( p )); p = p*2.01;\n    f += 0.25000*(simplex3D( p )); p = p*2.02;\n    f += 0.12500*(simplex3D( p )); p = p*2.03;\n    f += 0.06250*(simplex3D( p )); p = p*2.04;\n    f += 0.03125*(simplex3D( p )); p = p*2.05;\n    f += 0.015625*(simplex3D( p ));\n\treturn f;\n}\n\nvec3 planet(float radius, vec2 center, vec2 position, vec3 cLight)\n{\n    float mx = iMouse.x/iResolution.x;\n    float my = iMouse.y/iResolution.y;\n    \n    float z = sqrt(radius*radius - position.x*position.x - position.y*position.y);\n\tvec3 normal = normalize(vec3(position.x, position.y, z)); // for visualize->(normal+1.)/2.\n    float diffuse = max(0.,dot(normal, cLight));\n    \n    // texture\n    float noise = fbm(vec3(normal.x,normal.y, normal.z+mx))*0.5+0.5;\n    vec3 color = (noise<my)?vec3(0.2, 0.2, 0.8):vec3(0.2, 0.5, 0.2);\n    //color *= (z/radius);\n    vec3 result = vec3(diffuse * color);\n    return result;\n}\n\nvec3 atmos(float radius, vec2 center, vec2 position, vec3 cLight)\n{\n    radius *= 1.08;\n    float center_opacity = 150.;\n    float atmos_strenght = 5.5;\n    \n    float z = sqrt(radius*radius - position.x*position.x - position.y*position.y);\n\tvec3 normal = normalize(vec3(position.x, position.y, z));\n    \n    float diffuse = max(.0,(dot(normal*100.0, cLight)));\n    //z /= radius;\n    z /= radius*100.0;\n    \n    vec3 color = vec3(1.0)-(vec3(1.0, 1.0, 1.0)*z*center_opacity);  // white atmos\n    color*=vec3(0.0, 0.7, 0.93)*z*atmos_strenght;\t\t\t\t\t// colorize atmos\n    \n    vec3 result = vec3(diffuse * color);\n    return result;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    \n    float mx = iMouse.x/iResolution.x;\n    float my = iMouse.y/iResolution.y;\n    \n    // SPHERE\n    vec2 center = iResolution.xy/2.0;\n    float radius = iResolution.y/3.0;\n    vec2 position = gl_FragCoord.xy - center;\n    \n    // light\n    vec3 cLight = normalize(vec3(sin(time), .0, cos(time)));\n    \n    // ATMOSPHERE\n    float at_radius = 30.0;\n    \n    vec3 planet_color = planet(radius, center, position, cLight);\n    vec3 atmos_color = atmos(radius, center, position, cLight);\n    \n\tif(length(position) < radius)\n    {\n    \tfragColor = vec4(planet_color, 1.);\n    }\n    else\n    {\n        fragColor = vec4(atmos_color, 1.);\n    }    \n}", "image_inputs": [{"id": "4sf3Rr", "previewfilepath": "/media/ap/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4sG3W1.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "4sK3WR", "name": "Integer Spiral", "author": "mfbaranow", "description": "Attempts to render an ascii spiral, in the strangest way possible", "tags": ["2d", "text", "ascii"], "likes": 11, "viewed": 403, "date": "1454012412", "time_retrieved": "2024-06-20T18:30:02.319360", "image_code": "\n// NOTE: uncomment below to make it spin\n#define ANIMATE\n\n#define pi 3.1415926535897932384626433832795\n#define pi2 6.283185307179586\n\n#define pi4th 0.7853981633974483\n\nvec2 size = vec2(24.0,8.0);\n\nvec2 celUVCoords(vec2 uv) {\n    return ((floor(uv/size)*size) / iResolution.xy);\n}\n\nvec2 linearCoords(vec2 uv) {\n\treturn (uv / iResolution.xy);\n}\n\nvec3 lerp(float t, vec3 a, vec3 b) {\n    return t*a + (1.0-t)*b;\n}\n\nfloat digit(float x) {\n    float n = 0.0;\n\tif (x >= 0.0) n = 6595878.0;\n\tif (x >= 1.0) n = 14815366.0;\n\tif (x >= 2.0) n = 15798566.0;\n\tif (x >= 3.0) n = 16005391.0;\n\tif (x >= 4.0) n = 8666409.0;\n\tif (x >= 5.0) n = 16006190.0;\n\tif (x >= 6.0) n = 16038959.0;\n\tif (x >= 7.0) n = 1118479.0;\n\tif (x >= 8.0) n = 16029999.0;\n\tif (x >= 9.0) n = 16006447.0;\n\treturn n;\n}\n\nfloat character(float n, vec2 p)\n{\n\tp = floor(p*vec2(4.0, -4.0) + 2.5);\n\tif (clamp(p.x, 0.0, 4.0) == p.x && clamp(p.y, 0.0, 4.0) == p.y)\n\t{\n\t\tif (int(mod(n/exp2(p.x + 5.0*p.y), 2.0)) == 1) return 1.0;\n\t}\t\n\treturn 0.0;\n}\n\nint _abs(int a) {\n\treturn a < 0 ? -a : a;\n}\n\nint _max(int a, int b) {\n    return a > b ? a : b;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy;\n    vec2 box = celUVCoords(uv);\n\n    vec3 col = texture(iChannel0, floor(uv/8.0)*8.0/iResolution.xy).rgb;\n    \n    ivec2 pt = ivec2(box * (iResolution.xy / size));\n    pt = ivec2(13,21) - pt;\n    \n#ifdef ANIMATE\n    float angleOffset = mod(pi - pi/4.0 + iTime, 2.0*pi);\n#else\n    float angleOffset =  pi - pi/4.0;\n#endif\n    \n    float thisAngle = atan(float(pt.y), float(pt.x)) + angleOffset;\n    int ring = _max(_abs(pt.x), _abs(pt.y)) * 2 + 1;\n    int prevRing = ring - 2;\n\tint numOfSteps = (ring-1) * 4;\n\tfloat stepAngle = pi2 / float(numOfSteps);\n    int innerNum = prevRing * prevRing;\n    int value = int(floor((thisAngle / stepAngle) + 0.5) + float(innerNum));\n    if (thisAngle <= 0.0) {\n        value += numOfSteps;\n    }\n\t\n    float x = float(_max(0,value));\n    vec2 whichDigit = (linearCoords(uv) - box) * 42.0;\n    float n = 0.0;\n    float offset = 0.0;\n    float d1 = mod(x/100.0,10.0);\n    float d2 = mod(x/10.0,10.0);\n    float d3 = mod(x, 10.0);\n    if (whichDigit.x > 0.0)  { n = x < 100.0 ? 0.0 : digit(d1); offset = +0.4; }\n    if (whichDigit.x > 0.60) { n = x < 10.0  ? 0.0 : digit(d2);  offset =  0.0; }\n    if (whichDigit.x > 1.0)  { n = digit(d3);                         offset = -0.4; }\n\n    \n\tvec2 cuv = mod(uv/4.0, 2.0) - vec2(1.0+offset,1.0);\n    \n    col = (0.3 + vec3( mod(x/36.0, 1.0) ) * 0.7);\n    fragColor = vec4(lerp(character(n, cuv), col, vec3(0.0)), 1) * vec4(0.5 + d1 / 10.0, 0.5 + d2 / 10.0, 0.5 + d3 / 10.0, 1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4sK3WR.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "4sKGWh", "name": "ColorWheel", "author": "Emil", "description": "Needed a dynamic color picker.., anybody has simple solution to antialiasing between color pieces?\nedit: added simple solution to blending colors", "tags": ["2d", "wheel", "colorpicker"], "likes": 0, "viewed": 234, "date": "1454254972", "time_retrieved": "2024-06-20T18:30:02.319360", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float pieCount = 2.0 + ceil(4.0*fract((iTime*0.01)+0.9));\n\tvec2 uv = (2.*fragCoord.xy - iResolution.xy) / iResolution.y;\n    float rad = 0.0;\n    if(uv.y>0.0){ // top\n        // 1 / 6 parts (stretched) (1.0-(1.0/pieCount)) -> 1.0\n    \trad = ((atan(uv.y,uv.x)*0.31830988618379067153776752674503));\n        rad *= (1.0/pieCount);\n        rad += (1.0-(1.0/pieCount));\n        \n    } else { // bottom\n        // 5 / 6 parts (compressed) 0.0 -> (1.0-(1.0/pieCount))\n        rad = (((atan(uv.y,uv.x)*0.31830988618379067153776752674503)))+1.0;\n        rad *= (1.0-(1.0/pieCount));\n    }\n    vec3 finCol = vec3(0.0,0.0,0.0), tempCol = vec3(0.0,0.0,0.0);\n    const float numSamples = 6.0;\n    float moBlur = 0.01;//+clamp(0.1*sin(iTime),0.0,1.0);\n    rad = fract(rad+0.2+1.0*iTime*0.1);\n    for(float f = 0.0; f<=1.0; f+=(1.0/numSamples)){\n        rad = fract(rad+moBlur/numSamples/length(uv));\n        if(rad<=(1.0/pieCount)){\n            tempCol = vec3(252.,163.,17.)/255.; // orange\n        } else if(rad<=(2.0/pieCount)){\n            tempCol = vec3(252.,45.,29.)/255.; // red\n        } else if(rad<=(3.0/pieCount)){\n            tempCol = vec3(0.,174.,65.)/255.; // green\n        } else if(rad<=(4.0/pieCount)){\n            tempCol = vec3(46.,41.,37.)/255.; // black\n        } else if(rad<=(5.0/pieCount)){\n            tempCol = vec3(0.,168.,198.)/255.; // blue\n        } else {\n            tempCol = vec3(240.,3.,127.)/255.; // pink\n        }\n        finCol += vec3(pow(tempCol.x,2.2),pow(tempCol.y,2.2),pow(tempCol.z,2.2));\n    }\n    finCol /= numSamples;\n    \n    finCol = vec3(pow(finCol.x,.454545),pow(finCol.y,.454545),pow(finCol.z,.454545));\n    fragColor = length(uv)<1.0&&length(uv)>0.3?vec4(finCol.xyz,1.0):vec4(1.0);\n    if(abs(uv.x)<uv.y-0.9){ // making triangleTop\n    \tfragColor = vec4(1.0);\n    }\n    //fragColor = vec4(rad);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4sKGWh.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "4st3DS", "name": "website background #2", "author": "104", "description": "just some quick 2d work for a website. Originally very dark, to allow text over top. But for shadertoy.com I made it brighter.", "tags": ["minimal"], "likes": 32, "viewed": 652, "date": "1452003177", "time_retrieved": "2024-06-20T18:30:02.319360", "image_code": "const float pi = 3.14159;\nconst float pi2 = pi * 2.;\n\nconst vec2 cellSizePixels = vec2(192.,192.);// best results = any multiple of 2^iterations\nfloat edgeSizePixels = 2.5;\nconst float iterations = 5.;\n\n\nvec2 q(vec2 x, vec2 p)\n{\n    return floor(x/p)*p;\n}\n\nfloat rand(vec2 co){\n  return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nvec3 rand3(vec2 p)\n{\n    vec3 p2 = vec3(p, rand(p));\n    return\n        fract(sin(vec3(\n            dot(p2,vec3(127.1,311.7,427.89)),\n            dot(p2,vec3(269.5,183.3,77.24)),\n            dot(p2,vec3(42004.33,123.54,714.24))\n            ))*43758.5453);\n}\n\nfloat sdAxisAlignedRect(vec2 uv, vec2 tl, vec2 br)\n{\n  \tvec2 d = max(tl - uv, uv - br);\n    return length(max(vec2(0.0), d)) + min(0.0, max(d.x, d.y));\n}\n\nmat2 rot2D(float r)\n{\n    float c = cos(r), s = sin(r);\n    return mat2(c, s, -s, c);\n}\nfloat pulse(float x, float pulseWidth, float totalPeriod)\n{\n    x = mod(x,totalPeriod);\n    x -= pulseWidth /= 2.;\n    return 1.-smoothstep(0.,pulseWidth, abs(x));\n}\n\n\n\nvoid mainImage( out vec4 o, in vec2 i)\n{\n\tvec2 uv = i / iResolution.xy - .5;\n    vec2 uvn = uv;// screen / unwarped coords\n\n    uv += iMouse.xy *.1 / iResolution.xy;\n    \n\tif(iResolution.x > iResolution.y)\n\t\tuv.x *= iResolution.x / iResolution.y;\n\telse\n\t\tuv.y /= iResolution.x / iResolution.y;\n\n    \n    //uv *= 1.+sin(iTime*0.5)*.1;// zoom\n    uv -= .7;// offset rotation origin\n    float rotation = -(iTime+40.)*0.005;\n    //rotation = -0.2;// fixed-rot\n    uv *= rot2D(rotation);// rot\n    \n    vec2 cellSize = cellSizePixels / iResolution.x;\n\n    vec2 cellOrig;\n    float cellID;\n    float edgeSizePixels = 7.;\n\n    for(float i = 0.;i<iterations;i++)\n    {\n        cellSize *= .5;\n        edgeSizePixels *= .5;\n        cellOrig = q(uv, cellSize);\n        cellID = rand(cellOrig);\n        if(i/iterations > sin(cellID*6.28+iTime*.2)*.5+.3)\n            break;\n    }\n    edgeSizePixels = max(edgeSizePixels, 1.);\n    \n    //float cellID = rand(cellOrig);\n    float distToCenter = distance(uv, cellOrig+cellSize/2.)/(length(cellSize)/2.);\n    vec2 tl = cellOrig;\n    vec2 br = cellOrig + cellSize;\n    float distToEdge = sdAxisAlignedRect(uv, tl, br) / length(cellSize);// 0 = edge, -1 = center\n    \n    float edgeSize = edgeSizePixels/iResolution.x/length(cellSize);\n    float aEdge = smoothstep(-edgeSize, 0., distToEdge);\n    \n    float totalPulsePeriod = 10.;// in seconds\n    float highlightDuration = 1.2;\n    float highlightStrength = 1.7;\n    float highlight = pulse((cellID*totalPulsePeriod*totalPulsePeriod)+iTime,highlightDuration,totalPulsePeriod)*highlightStrength+1.;\n    \n    // cell background\n    vec3 cellColor = rand3(cellOrig);\n    o = vec4(cellColor.rgbb)*.3;\n    o *= highlight;\n    o *= 1.-distToCenter*.4;\n    \n    // edge color\n    vec4 edgeColor = vec4(0,0,0,1);\n    o = mix(o, edgeColor, aEdge);\n\n    // saturation\n    o = clamp(o,0.,1.);\n    //o = mix(o, vec4((o.r+o.g+o.b)/3.), sin(iTime)*.5+.5);\n    o = mix(o, vec4((o.r+o.g+o.b)/3.), .6);\n\n    // tint green / brightness\n    o *= vec4(.5,1,1,0)*2.;\n    \n    // noise\n    o.rgb += (rand3(uvn*iTime)-.5)*.1;\n\n    // vignette\n    uvn *= 1.1;\n    o *= 1.-dot(uvn,uvn);\n    \n    // gamma\n    o = clamp(o,0.,1.);\n    o = pow(o, vec4(1./1.2));\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4st3DS.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "4st3WX", "name": "Breath Potter's Tunnel", "author": "s23b", "description": "tunnel effect tutorial / hello world application", "tags": ["tunnel", "spiral", "hypnosis"], "likes": 51, "viewed": 2254, "date": "1452512645", "time_retrieved": "2024-06-20T18:30:02.319360", "image_code": "#define PI 3.14159265359\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy / .5 - 1.;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    // make a tube\n    float f = 1. / length(uv);\n    \n    // add the angle\n    f += atan(uv.x, uv.y) / acos(0.);\n    \n    // let's roll\n    f -= iTime;\n    \n    // make it black and white\n    // old version without AA: f = floor(fract(f) * 2.);\n    // new version based on Shane's suggestion:\n   \tf = 1. - clamp(sin(f * PI * 2.) * dot(uv, uv) * iResolution.y / 15. + .5, 0., 1.);\n    \n    // add the darkness to the end of the tunnel\n    f *= sin(length(uv) - .1);\n\t\n    fragColor = vec4(f, f, f, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4st3WX.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "4stGD2", "name": "Everyday008-Cathedrale01", "author": "Makio64", "description": "First \"Cathedrale\" study :)", "tags": ["everyday008cathedrale01"], "likes": 9, "viewed": 598, "date": "1452254999", "time_retrieved": "2024-06-20T18:30:03.731593", "image_code": "// Everyday008 - Cathedrale\n// By David Ronai / @Makio64\n\n//------------------------------------------------------------------ VISUAL QUALITY\n#define POSTPROCESS\n#define RAYMARCHING_STEP 40\n#define RAYMARCHING_MIN 10.\n#define RAYMARCHING_MAX 400.\n#define RAYMARCHING_JUMP 1.\n//------------------------------------------------------------------ DEBUG\n//#define RENDER_DEPTH\n//#define RENDER_NORMAL\n//#define RENDER_AO\n\n#define PHI (sqrt(5.)*0.5 + 0.5)\nconst float PI = 3.14159265359;\nfloat snoise(vec3 v);\n\n//-------------------------------------------------------  PPRIMITIVES / OPERATIONS\nvec3 orbit(float phi, float theta, float radius)\n{\n\treturn vec3(\n\t\tradius * sin( phi ) * cos( theta ),\n\t\tradius * cos( phi ),\n\t\tradius * sin( phi ) * sin( theta )\n\t);\n}\nfloat pyramid( vec3 p, float h) {\n\tvec3 q=abs(p);\n\treturn max(-p.y, (q.x*2.1+q.y+q.z*2.1-h)/3.0 );\n}\n\nvoid pR(inout vec2 p, float a) {\n\tp = cos(a)*p + sin(a)*vec2(p.y, -p.x);\n}\nvoid pR45(inout vec2 p) {\n\tp = (p + vec2(p.y, -p.x))*sqrt(0.5);\n}\nfloat fOpUnionRound(float a, float b, float r) {\n\tvec2 u = max(vec2(r - a,r - b), vec2(0));\n\treturn max(r, min (a, b)) - length(u);\n}\nfloat fCylinder(vec3 p, float r, float height) {\n\tfloat d = length(p.xz) - r;\n\td = max(d, abs(p.y) - height);\n\treturn d;\n}\nfloat fTorus(vec3 p, float smallRadius, float largeRadius) {\n\treturn length(vec2(length(p.xz) - largeRadius, p.y)) - smallRadius;\n}\nfloat fSphere(vec3 p, float r) {\n\treturn length(p) - r;\n}\nfloat vmax(vec3 v) {\n\treturn max(max(v.x, v.y), v.z);\n}\nfloat fBox(vec3 p, vec3 b) {\n\tvec3 d = abs(p) - b;\n\treturn length(max(d, vec3(0))) + vmax(min(d, vec3(0)));\n}\nfloat fOpIntersectionChamfer(float a, float b, float r) {\n\treturn max(max(a, b), (a + r + b)*sqrt(0.5));\n}\nfloat fOpIntersectionRound(float a, float b, float r) {\n\tvec2 u = max(vec2(r + a,r + b), vec2(0));\n\treturn min(-r, max (a, b)) + length(u);\n}\nvec2 pModMirror2(inout vec2 p, vec2 size) {\n\tvec2 halfsize = size*0.5;\n\tvec2 c = floor((p + halfsize)/size);\n\tp = mod(p + halfsize, size) - halfsize;\n\tp *= mod(c,vec2(2.))*2. - vec2(1.);\n\treturn c;\n}\nfloat fOpUnionStairs(float a, float b, float r, float n) {\n\tfloat s = r/n;\n\tfloat u = b-r;\n\treturn min(min(a,b), 0.5 * (u + a + abs ((mod (u - a + s, 2. * s)) - s)));\n}\n\n//------------------------------------------------------------------ MAP\nfloat map( in vec3 pos ) {\n    //arch\n    vec3 q = pos;\n    pModMirror2(q.xz,vec2(22.));\n    q.y -= 40.;\n    q.zx -= 21.;\n    pR(q.yz,PI/2.);\n    pR45(q.xy);\n    float d = fTorus(q,1.3,44.);\n    q = pos;\n    pModMirror2(q.xz,vec2(500.));\n    d = max(-fBox(q-vec3(0.,10.5,0.),vec3(500.,30.,500.)),d);\n    \n    //column\n    q = pos;\n    q.zx -= 22.;\n    q.zx += texture(iChannel0,pos.xy/50.).x*.5;\n    vec2 idx = pModMirror2(q.xz,vec2(22.));\n    q.xz -= 9.5;\n    d = fOpUnionStairs(d, fCylinder(q,2.,40.),4.,10.);\n    \n    //ground\n    d = fOpUnionStairs(d, pos.y+40.1+texture(iChannel0,pos.xz/50.).x*.5, 5., 5.);\n    \n    //pyramid on top of arch\n    q = pos;\n    q.y -= 80.;\n    q.zx += 11.;\n    pModMirror2(q.xz,vec2(44.));\n    pR45(q.xz);\n    float d2 = pyramid( q, 12. );\n    pR(q.xy,PI);\n    d2 = min(d2,pyramid( q, 12. ));\n    d = fOpUnionRound(d, d2,1.);\n    return d;\n}\n\n\n\n//------------------------------------------------------------------ RAYMARCHING\n\nfloat castRay( in vec3 ro, in vec3 rd, inout float depth )\n{\n\tfloat t = RAYMARCHING_MIN;\n\tfloat res;\n\tfor( int i=0; i<RAYMARCHING_STEP; i++ )\n\t{\n\t\tvec3 pos = ro+rd*t;\n\t\tres = map( pos );\n\t\tif( res < 0.001 || t > RAYMARCHING_MAX ) break;\n\t\tt += res*RAYMARCHING_JUMP;\n\t\tdepth += 1./float(RAYMARCHING_STEP);\n\t}\n\treturn t;\n}\n\nvec3 calcNormal(vec3 p) {\n\tfloat eps = 0.01;\n\tconst vec3 v1 = vec3( 1.0,-1.0,-1.0);\n\tconst vec3 v2 = vec3(-1.0,-1.0, 1.0);\n\tconst vec3 v3 = vec3(-1.0, 1.0,-1.0);\n\tconst vec3 v4 = vec3( 1.0, 1.0, 1.0);\n\treturn normalize( v1 * map( p + v1*eps ) +\n\t\t\t\t\t  v2 * map( p + v2*eps ) +\n\t\t\t\t\t  v3 * map( p + v3*eps ) +\n\t\t\t\t\t  v4 * map( p + v4*eps ) );\n}\n\nfloat hash( float n ){\n\treturn fract(sin(n)*3538.5453);\n}\n\nfloat calcAO( in vec3 p, in vec3 n, float maxDist, float falloff ){\n\tfloat ao = 0.0;\n\tconst int nbIte = 6;\n\tfor( int i=0; i<nbIte; i++ )\n\t{\n\t\tfloat l = hash(float(i))*maxDist;\n\t\tvec3 rd = n*l;\n\t\tao += (l - map( p + rd )) / pow(1.+l, falloff);\n\t}\n\treturn clamp( 1.-ao/float(nbIte), 0., 1.);\n}\n\nfloat thickness( in vec3 p, in vec3 n, float maxDist, float falloff )\n{\n\tfloat ao = 0.0;\n\tconst int nbIte = 6;\n\tfor( int i=0; i<nbIte; i++ )\n\t{\n\t\tfloat l = hash(float(i))*maxDist;\n\t\tvec3 rd = -n*l;\n\t\tao += (l + map( p + rd )) / pow(1.+l, falloff);\n\t}\n\treturn clamp( 1.-ao/float(nbIte), 0., 1.);\n}\n\n//------------------------------------------------------------------ POSTEFFECTS\nfloat random(vec2 n, float offset ){\n\treturn .5 - fract(sin(dot(n.xy + vec2( offset, 0. ), vec2(12.9898, 78.233)))* 43758.5453);\n}\n\n#ifdef POSTPROCESS\nvec3 postEffects( in vec3 col, in vec2 uv, in float time )\n{\n\t// vigneting\n    float vignette = .8*pow( 16.0*uv.x*uv.y*(1.0-uv.x)*(1.0-uv.y), 0.8 );\n\tcol *= .2+vignette;\n\tcol += (1.-vignette)*vec3( .25 * random( uv, .001 * iTime ) );\n\treturn col;\n}\n#endif\n\nvec3 render( in vec3 ro, in vec3 rd, in vec2 uv )\n{\n\tvec3 col = vec3(.0,.0,1.2);\n\n\tfloat depth = 0.;\n\tfloat t = castRay(ro,rd,depth);\n\t#ifdef RENDER_DEPTH\n\treturn vec3(depth/10.,depth/5.,depth);\n\t#endif\n\tvec3 pos = ro + t * rd;\n\tvec3 nor = calcNormal(pos);\n\t#ifdef RENDER_NORMAL\n\treturn nor;\n\t#endif\n\tfloat ao = calcAO(pos,nor,10.,1.2);\n\t#ifdef RENDER_AO\n\treturn vec3(ao);\n\t#endif\n\n    float thi = thickness(pos, nor, 10., 1.4);\n\tcol = max(vec3(0.), dot(nor,vec3(.5)));\n    if(pos.y>-40.1){\n        col*=texture(iChannel0,pos.xy/10.).ggg*.5;\n    }\n    col += vec3(depth/10.,depth/5.,depth);\n    col *= clamp(1.-smoothstep(250.,400.,t),0.,1.);\n    col *= ao*thi*1.3;\n\treturn col;\n}\n\n//------------------------------------------------------------------ MAIN\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr )\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n\treturn mat3( cu, cv, cw );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 coords )\n{\n\tvec2 uv = coords.xy / iResolution.xy;\n\tvec2 mouse = iMouse.xy / iResolution.xy;\n\tvec2 q = coords.xy/iResolution.xy;\n\tvec2 p = -1.0+2.0*q;\n\tp.x *= iResolution.x/iResolution.y;\n\n\t//Camera\n\tfloat radius = 80.;\n\tvec3 ro = orbit(PI/2.-.2,PI/2.,radius);\n    ro.z-=30.*iTime;\n    ro.x-=11.;\n\tvec3 ta  = vec3(-11.0+sin(iTime)*40.,15., -30.*iTime);\n\tmat3 ca = setCamera( ro, ta, 0. );\n\tvec3 rd = ca * normalize( vec3(p.xy,1.3) );\n\n\t// Raymarching\n\tvec3 color = render( ro, rd, uv );\n\t#ifdef POSTPROCESS\n\tcolor = postEffects( color, uv, iTime );\n\t#endif\n\tfragColor = vec4(color,1.0);\n}\n\n//------------------------------------------------------------------ NOISE\n//AshimaOptim https://www.shadertoy.com/view/Xd3GRf\nvec4 permute(vec4 x){return mod(x*x*34.0+x,289.);}\nfloat snoise(vec3 v){\n  const vec2  C = vec2(0.166666667, 0.33333333333) ;\n  const vec4  D = vec4(0.0, 0.5, 1.0, 2.0);\n  vec3 i  = floor(v + dot(v, C.yyy) );\n  vec3 x0 = v - i + dot(i, C.xxx) ;\n  vec3 g = step(x0.yzx, x0.xyz);\n  vec3 l = 1.0 - g;\n  vec3 i1 = min( g.xyz, l.zxy );\n  vec3 i2 = max( g.xyz, l.zxy );\n  vec3 x1 = x0 - i1 + C.xxx;\n  vec3 x2 = x0 - i2 + C.yyy;\n  vec3 x3 = x0 - D.yyy;\n  i = mod(i,289.);\n  vec4 p = permute( permute( permute(\n\t  i.z + vec4(0.0, i1.z, i2.z, 1.0 ))\n\t+ i.y + vec4(0.0, i1.y, i2.y, 1.0 ))\n\t+ i.x + vec4(0.0, i1.x, i2.x, 1.0 ));\n  vec3 ns = 0.142857142857 * D.wyz - D.xzx;\n  vec4 j = p - 49.0 * floor(p * ns.z * ns.z);\n  vec4 x_ = floor(j * ns.z);\n  vec4 x = x_ *ns.x + ns.yyyy;\n  vec4 y = floor(j - 7.0 * x_ ) *ns.x + ns.yyyy;\n  vec4 h = 1.0 - abs(x) - abs(y);\n  vec4 b0 = vec4( x.xy, y.xy );\n  vec4 b1 = vec4( x.zw, y.zw );\n  vec4 s0 = floor(b0)*2.0 + 1.0;\n  vec4 s1 = floor(b1)*2.0 + 1.0;\n  vec4 sh = -step(h, vec4(0.0));\n  vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy ;\n  vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww ;\n  vec3 p0 = vec3(a0.xy,h.x);\n  vec3 p1 = vec3(a0.zw,h.y);\n  vec3 p2 = vec3(a1.xy,h.z);\n  vec3 p3 = vec3(a1.zw,h.w);\n  vec4 norm = inversesqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));\n  p0 *= norm.x;\n  p1 *= norm.y;\n  p2 *= norm.z;\n  p3 *= norm.w;\n  vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n  m = m * m * m;\n  return .5 + 12.0 * dot( m, vec4( dot(p0,x0), dot(p1,x1),dot(p2,x2), dot(p3,x3) ) );\n}\n", "image_inputs": [{"id": "4dXGRn", "previewfilepath": "/media/ap/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4stGD2.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "4stGWl", "name": "Ringys", "author": "lucastakejame", "description": "gif inspired shader", "tags": ["circles", "spin", "strips"], "likes": 3, "viewed": 212, "date": "1452801224", "time_retrieved": "2024-06-20T18:30:04.319373", "image_code": "#define THICKNESS 5.0\n#define SPACE_BETWEEN .0\n\n#define ALTERNATE_DIRECTION false\n\nfloat pi = 3.1415;\n\n/*\n    More efficient way:\n        check if pixel is in strip domain or spacebetween domain\n        check if pixel is inside current angle window\n\n        working with the angle interval [0, 2pi]\n*/\nbool checkDonut(vec2 polarCoord, float speed, float ringFrac, float thickness, float space){\n    float pixDistance = polarCoord.x;\n    float pixAngle = polarCoord.y;\n\n    // this mod get the pixel relative position to the strip origin\n    // then checks if this position is on a strip or a space\n    if(mod(pixDistance, thickness + space) < thickness)\n    {\n        // num of the strip counting from the center\n        int stripN = int(pixDistance/(thickness + space));\n        float angleBegin;\n\n        \n        if(mod(float(stripN), 2.) == 0. && ALTERNATE_DIRECTION)\n        {\n            angleBegin = mod((speed)*(float(1+stripN)/3.)*iTime, 2.*pi);\n\n            // going in this direction causes negative beginning angles\n            // this deals with it\n            if(angleBegin < 0.)\n            {\n                angleBegin += 2.*pi;\n            }\n        }\n        else\n        {\n            angleBegin = mod((-speed)*(float(1+stripN)/3.)*iTime, 2.*pi);\n        }\n        \n        // defines which angle ( counter-clock wise) the strip starts\n        float angleEnd = mod(angleBegin + 2.0*pi*ringFrac, 2.*pi);\n\n        // when it passes 2*pi and the ending angle is smaller than the beginning\n        if(angleEnd < angleBegin)\n        {\n            if(pixAngle <= angleEnd || pixAngle >= angleBegin)\n            {\n                return true;\n            }\n        }\n        else\n        {\n            if(angleBegin <= pixAngle && pixAngle <= angleEnd)\n            {\n                return true;\n            }\n        }\n\n    }\n    return false;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{        \n    float thickness = THICKNESS;\n    float space = SPACE_BETWEEN;\n    float speed = (iMouse.x != 0.) ? 5.0*iMouse.x/iResolution.x : .5;\n    float ringFrac = (iMouse.y != 0.)? iMouse.y/iResolution.y : .5;\n\n    \n\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    \n    vec2 center = iResolution.xy/2.0;\n       \n    float dist = distance(fragCoord, center);\n\n    float arc;\n\n    // get angle of pixel in plane with\n    // origin in the middle of the screen\n    // angle 0 points to east\n    // grows Counter clock wise\n    if((fragCoord.x - center.x) != 0.0)\n    {\n        // Gets arc from arc tangent and position\n        // transforms arc so its 0 starts on east direction, going CCW\n        arc = atan(-(fragCoord.y - center.y), (fragCoord.x - center.x));\n        arc += 2.*pi;\n        arc = mod(arc, 2.*pi);\n    }\n    else\n    {\n        if((fragCoord.y - center.y) >= 0.0)\n        {\n            arc = pi/2.;\n        }\n        else\n        {\n            arc = 3.*pi/2.;\n        }\n    }\n\n    vec2 polarCoord = vec2(dist, arc);\n    \n    // Background Color\n    fragColor = vec4(0., 0., 0., 1.0);\n        \n    // is pixel inside a ring\n    if(checkDonut(polarCoord, speed, ringFrac, thickness, space))\n    {\n        fragColor = vec4(uv.x*2., uv.y*3., 0.5+0.5*sin(iTime), 1.0);\n    }\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4stGWl.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "4stGWX", "name": "Gaussian AA Test", "author": "tsone", "description": "Testing anti-aliasing with coverage estimated with Gaussian. No multisampling. Click to show the render without anti-aliasing. Based on eiffie's shader: https://www.shadertoy.com/view/ldSGRz", "tags": ["antialias", "gaussian"], "likes": 15, "viewed": 694, "date": "1453452987", "time_retrieved": "2024-06-20T18:30:05.622673", "image_code": "/*\n\nCopyright 2016 Valtteri \"tsone\" HeikkilÃ¤\n\nThis work is licensed under the Creative Commons Attribution 4.0 International License.\nTo view a copy of this license, visit http://creativecommons.org/licenses/by/4.0/\n\n*/\n\n#define SQRT2    1.414213562373095\n#define SQRT3    1.732050807568877\n\n// Number of edges to record (=size of \"edge stack\"). Possible values: 1,2\n#define AA_EDGES 2\n\n// Define for static marching threshold (useful for older GPUs...)\n//#define MARCH_THRESHOLD  .000001\n#ifdef MARCH_THRESHOLD\n#define MARCH_ITERATIONS 96\n#else\n#define MARCH_ITERATIONS 128\n#endif\n\n#define FISHEYE_AMOUNT   (-.3 - .3*sin(.3*iTime))\n#define MAX_DEPTH 220.\n\n\nfloat sqr(float x) { return x*x; }\n\n\nmat3 rot_mat;\n\nfloat pxg; // Pixel cone radius coeff for Gaussian coverage.\nfloat pxn; // -\"- for normal/gradient calculation.\nfloat pxm; // -\"- for dynamic threshold for marching.\n\n\nmat3 rot_y(in float a)\n{\n\tfloat ca = cos(a);\n\tfloat sa = sin(a);\n\treturn mat3(\n\t\tca,0.0,sa,\n\t\t0.0,1.0,0.0,\n\t\t-sa,0.0,ca\n\t);\n}\n\nmat3 rot_x(in float a)\n{\n\tfloat ca = cos(a);\n\tfloat sa = sin(a);\n\treturn mat3(\n\t\t1.0,0.0,0.0,\n\t\t0.0,ca,sa,\n\t\t0.0,-sa,ca\n\t);\n}\n\nfloat BoxRounded(in vec3 p, in vec3 s, float r)\n{\n    p = max(abs(p) - s, 0.);\n\treturn length(p) - r;\n}\n\nfloat Map(in vec3 p)\n{\n    p = mod(p + 6., 12.) - 6.;\n    p = abs(p);\n\tfloat d0 = BoxRounded(p, vec3(2.7), .1);\n\tfloat d1 = BoxRounded(p+vec3(-2.8), vec3(1.7), .1);\n    return max(d0, -d1);\n}\n\nvec3 CameraRayDir(in vec2 fragCoord)\n{\n\tvec2 uv = (2.*fragCoord - iResolution.xy) / length(iResolution.xy);\n\treturn normalize(vec3(SQRT2 * uv, 1. + FISHEYE_AMOUNT * dot(uv, uv)));\n}\n\nvoid Camera(out vec3 P, out vec3 D, in vec2 fragCoord)\n{\n    D = CameraRayDir(fragCoord);\n    \n    // Calc 'px' as delta of D (=ray direction) to neighboring farthest pixel.\n    vec3 D2 = CameraRayDir(fragCoord + sign(D.xy));\n    float px = length(D2 - D);\n    // SQRT3 scale distance to cover a sphere around px cube.\n    pxn = SQRT3 * px;\n    // SQRT2 is from 1/2 scaler in the exponent in Gaussian distribution.\n    // See: https://en.wikipedia.org/wiki/Gaussian_filter\n    pxg = SQRT2 * px;\n    // Ad-hoc, scaler should be small to eliminate surface peeling artefacts.\n    pxm = .0375 * px;\n    \n    // Position and rotate camera.\n    P = rot_mat * vec3(0.0,-.5,-10.);\n\tD = rot_mat * D;\n}\n\nvec3 Normal(in vec3 p, float t)\n{\n    vec2 v = vec2(t * pxn, 0.);\n\tfloat d1 = Map(p-v.xyy), d2 = Map(p+v.xyy);\n\tfloat d3 = Map(p-v.yxy), d4 = Map(p+v.yxy);\n\tfloat d5 = Map(p-v.yyx), d6 = Map(p+v.yyx);\n\treturn normalize(vec3(-d1+d2,-d3+d4,-d5+d6));\n}\n\nstruct MarchResult\n{\n#if AA_EDGES == 1\n    vec2 edge;\n#elif AA_EDGES == 2\n    vec4 edge;\n#endif\n    float t;\n    float d;\n};\n    \nvec3 Shade(in vec3 P, in vec3 D, float t, in vec3 L)\n{\n    P += t * D;\n\tvec3 N = Normal(P, t);\n    float NdotL = max(dot(N, L), 0.);\n    return vec3(NdotL);\n}\n\nvec3 SampleGauss(in vec3 srccolor, in vec3 dstcolor, float t, float d)\n{\n    // Divisor 3 sets the distribution cover 99% of the value inside px distance.\n    // See: https://en.wikipedia.org/wiki/Gaussian_filter\n    return mix(srccolor, dstcolor, exp(-sqr(d) / sqr(t*pxg / 3.)));\n}\n\nvec3 Color(in vec3 P, in vec3 D, in vec3 L, in MarchResult r, bool disable_aa)\n{\n    vec3 color = vec3(sqr(.5*D.y + .5));\n#ifdef MARCH_THRESHOLD\n    if (disable_aa && r.d < MARCH_THRESHOLD) {\n#else\n    if (disable_aa && r.d < pxm*r.t) {\n#endif\n    \tcolor = Shade(P, D, r.t, L);\n    } else {\n        color = SampleGauss(color, Shade(P, D, r.t, L), r.t, r.d);\n#if AA_EDGES == 1\n\t    color = SampleGauss(color, Shade(P, D, r.edge.y, L), r.edge.y, r.edge.x);\n#elif AA_EDGES == 2\n\t    color = SampleGauss(color, Shade(P, D, r.edge.w, L), r.edge.w, r.edge.z);\n\t    color = SampleGauss(color, Shade(P, D, r.edge.y, L), r.edge.y, r.edge.x);\n#endif\n    }\n    return color;\n}\n\nMarchResult March(in vec3 ro, in vec3 rd, float rnd)\n{\n    float t = Map(ro) * (1. - .25*rnd);\n    float t2 = t;\n    float d = t;\n    float od = MAX_DEPTH;\n\n#if AA_EDGES == 1\n    vec2 edge = vec2(MAX_DEPTH);\n#elif AA_EDGES == 2\n    vec4 edge = vec4(MAX_DEPTH);\n#endif\n    \n\tfor (int j = 0; j < MARCH_ITERATIONS; ++j) {\n\t\td = Map(ro + t*rd);\n        \n#if AA_EDGES == 1\n        if (od < d && od < edge.x && od < t2*pxg) {\n            edge = vec2(od, t2);\n        }\n#elif AA_EDGES == 2\n        if (od < d && od < edge.z && od < t2*pxg) {\n            edge = vec4(edge.zw, od, t2);\n        }\n#endif\n        t2 = t;\n        t += d;\n        od = d;\n#ifdef MARCH_THRESHOLD\n\t\tif (d < MARCH_THRESHOLD || t > MAX_DEPTH) {\n#else\n\t\tif (d < pxm*t || t > MAX_DEPTH) {\n#endif\n\t\t\tbreak;\n\t\t}\n\t}\n\n    return MarchResult(edge, t, d);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n\tvec3 P, D;\n\tint i;\n    \n    float rnd = texture(iChannel0, fragCoord / iChannelResolution[0].xy).r;\n\n    float time = .1 * iTime;\n    rot_mat = rot_y(time) * rot_x(.75);\n    \n\tCamera(P, D, fragCoord);\n\tMarchResult r = March(P, D, rnd);\n    vec3 L = rot_mat * normalize(vec3(-.15,.3,-1.));\n    \n    vec3 final = Color(P, D, L, r, iMouse.z > 0.);\n    // Reduce banding by adding noise.\n    final += rnd / 512.0;\n    // Gamma encode.\n    final = pow(final, vec3(1./2.2));\n\tfragColor = vec4(final, 1.);\n}", "image_inputs": [{"id": "4dXGzn", "previewfilepath": "/media/ap/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "channel": 0, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4stGWX.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "4sV3zR", "name": "Ocean Crossing", "author": "dr2", "description": "Choppy seas.", "tags": ["raymarching", "sea", "boat", "wake"], "likes": 43, "viewed": 1836, "date": "1453030046", "time_retrieved": "2024-06-20T18:30:08.022723", "image_code": "// \"Ocean Crossing\" by dr2 - 2016\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\nconst float pi = 3.14159;\nconst vec4 cHashA4 = vec4 (0., 1., 57., 58.);\nconst vec3 cHashA3 = vec3 (1., 57., 113.);\nconst float cHashM = 43758.54;\n\nvec4 Hashv4f (float p)\n{\n  return fract (sin (p + cHashA4) * cHashM);\n}\n\nvec4 Hashv4v3 (vec3 p)\n{\n  const vec3 cHashVA3 = vec3 (37.1, 61.7, 12.4);\n  const vec3 e = vec3 (1., 0., 0.);\n  return fract (sin (vec4 (dot (p + e.yyy, cHashVA3), dot (p + e.xyy, cHashVA3),\n     dot (p + e.yxy, cHashVA3), dot (p + e.xxy, cHashVA3))) * cHashM);\n}\n\nfloat Noisefv2 (vec2 p)\n{\n  vec2 i = floor (p);\n  vec2 f = fract (p);\n  f = f * f * (3. - 2. * f);\n  vec4 t = Hashv4f (dot (i, cHashA3.xy));\n  return mix (mix (t.x, t.y, f.x), mix (t.z, t.w, f.x), f.y);\n}\n\nfloat Noisefv3a (vec3 p)\n{\n  vec3 i, f;\n  i = floor (p);  f = fract (p);\n  f *= f * (3. - 2. * f);\n  vec4 t1 = Hashv4v3 (i);\n  vec4 t2 = Hashv4v3 (i + vec3 (0., 0., 1.));\n  return mix (mix (mix (t1.x, t1.y, f.x), mix (t1.z, t1.w, f.x), f.y),\n              mix (mix (t2.x, t2.y, f.x), mix (t2.z, t2.w, f.x), f.y), f.z);\n}\n\nvec2 Noisev2v4 (vec4 p)\n{\n  vec4 i, f, t1, t2;\n  i = floor (p);  f = fract (p);\n  f = f * f * (3. - 2. * f);\n  t1 = Hashv4f (dot (i.xy, cHashA3.xy));\n  t2 = Hashv4f (dot (i.zw, cHashA3.xy));\n  return vec2 (mix (mix (t1.x, t1.y, f.x), mix (t1.z, t1.w, f.x), f.y),\n               mix (mix (t2.x, t2.y, f.z), mix (t2.z, t2.w, f.z), f.w));\n}\n\nfloat Fbm3 (vec3 p)\n{\n  const mat3 mr = mat3 (0., 0.8, 0.6, -0.8, 0.36, -0.48, -0.6, -0.48, 0.64);\n  float f, a, am, ap;\n  f = 0.;  a = 0.5;\n  am = 0.5;  ap = 4.;\n  p *= 0.5;\n  for (int i = 0; i < 6; i ++) {\n    f += a * Noisefv3a (p);\n    p *= mr * ap;  a *= am;\n  }\n  return f;\n}\n\nfloat Fbmn (vec3 p, vec3 n)\n{\n  vec3 s = vec3 (0.);\n  float a = 1.;\n  for (int i = 0; i < 5; i ++) {\n    s += a * vec3 (Noisefv2 (p.yz), Noisefv2 (p.zx), Noisefv2 (p.xy));\n    a *= 0.5;\n    p *= 2.;\n  }\n  return dot (s, abs (n));\n}\n\nvec3 VaryNf (vec3 p, vec3 n, float f)\n{\n  vec3 e = vec3 (0.2, 0., 0.);\n  float s = Fbmn (p, n);\n  vec3 g = vec3 (Fbmn (p + e.xyy, n) - s,\n     Fbmn (p + e.yxy, n) - s, Fbmn (p + e.yyx, n) - s);\n  return normalize (n + f * (g - n * dot (n, g)));\n}\n\nfloat SmoothMin (float a, float b, float r)\n{\n  float h = clamp (0.5 + 0.5 * (b - a) / r, 0., 1.);\n  return mix (b, a, h) - r * h * (1. - h);\n}\n\nfloat SmoothBump (float lo, float hi, float w, float x)\n{\n  return (1. - smoothstep (hi - w, hi + w, x)) * smoothstep (lo - w, lo + w, x);\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  return q * cos (a) * vec2 (1., 1.) + q.yx * sin (a) * vec2 (-1., 1.);\n}\n\nfloat PrBoxDf (vec3 p, vec3 b)\n{\n  vec3 d = abs (p) - b;\n  return min (max (d.x, max (d.y, d.z)), 0.) + length (max (d, 0.));\n}\n\nfloat PrRoundBoxDf (vec3 p, vec3 b, float r)\n{\n  return length (max (abs (p) - b, 0.)) - r;\n}\n\nfloat PrCylDf (vec3 p, float r, float h)\n{\n  return max (length (p.xy) - r, abs (p.z) - h);\n}\n\nfloat PrCylAnDf (vec3 p, float r, float w, float h)\n{\n  return max (abs (length (p.xy) - r) - w, abs (p.z) - h);\n}\n\nfloat PrRCylDf (vec3 p, float r, float rt, float h)\n{\n  vec2 dc;\n  float dxy, dz;\n  dxy = length (p.xy) - r;\n  dz = abs (p.z) - h;\n  dc = vec2 (dxy, dz) + rt;\n  return min (min (max (dc.x, dz), max (dc.y, dxy)), length (dc) - rt);\n}\n\nint idObj, idObjGrp;\nmat3 bMat, boatMat[2];\nvec3 bPos, boatPos[2], qHit, sunDir, waterDisp;\nfloat tCur, bAng, boatAng[2], dstFar;\n\nvec3 SkyCol (vec3 ro, vec3 rd)\n{\n  vec3 col, bgCol;\n  float cloudFac;\n  bgCol = vec3 (0.2, 0.4, 1.);\n  if (rd.y > 0.) {\n    ro.xz += 0.5 * tCur;\n    vec2 p = 0.01 * (rd.xz * (100. - ro.y) / rd.y + ro.xz);\n    float w = 0.65;\n    float f = 0.;\n    for (int j = 0; j < 4; j ++) {\n      f += w * Noisefv2 (p);\n      w *= 0.5;\n      p *= 2.3;\n    }\n    cloudFac = clamp (3. * (f - 0.1) * rd.y + 0.1, 0., 1.);\n    col = bgCol + 0.2 * pow (1. - max (rd.y, 0.), 5.);\n    col = mix (col, vec3 (0.85), cloudFac);\n  } else col = 0.9 * bgCol + 0.25;\n  return col;\n}\n\nfloat WaveHt (vec3 p)\n{\n  const mat2 qRot = mat2 (1.6, -1.2, 1.2, 1.6);\n  vec4 t4, t4o, ta4, v4;\n  vec2 q2, t2, v2;\n  float wFreq, wAmp, pRough, ht;\n  wFreq = 0.2;  wAmp = 0.35;  pRough = 8.;\n  t4o.xz = tCur * vec2 (1., -1.);\n  q2 = p.xz + waterDisp.xz;\n  ht = 0.;\n  for (int j = 0; j < 4; j ++) {\n    t4 = (t4o.xxzz + vec4 (q2, q2)) * wFreq;\n    t2 = Noisev2v4 (t4);\n    t4 += 2. * vec4 (t2.xx, t2.yy) - 1.;\n    ta4 = abs (sin (t4));\n    v4 = (1. - ta4) * (ta4 + sqrt (1. - ta4 * ta4));\n    v2 = pow (1. - pow (v4.xz * v4.yw, vec2 (0.65)), vec2 (pRough));\n    ht += (v2.x + v2.y) * wAmp;\n    q2 *= qRot;  wFreq *= 2.;  wAmp *= 0.2;\n    pRough = 0.8 * pRough + 0.2;\n  }\n  return ht;\n}\n\nfloat WaveRay (vec3 ro, vec3 rd)\n{\n  vec3 p;\n  float dHit, h, s, sLo, sHi;\n  s = 0.;\n  sLo = 0.;\n  dHit = dstFar;\n  for (int j = 0; j < 70; j ++) {\n    p = ro + s * rd;\n    h = p.y - WaveHt (p);\n    if (h < 0.) break;\n    sLo = s;\n    s += max (0.4, 1.2 * h) + 0.01 * s;\n    if (s > dstFar) break;\n  }\n  if (h < 0.) {\n    sHi = s;\n    for (int j = 0; j < 5; j ++) {\n      s = 0.5 * (sLo + sHi);\n      p = ro + s * rd;\n      h = step (0., p.y - WaveHt (p));\n      sLo += h * (s - sLo);\n      sHi += (1. - h) * (s - sHi);\n    }\n    dHit = sHi;\n  }\n  return dHit;\n}\n\nvec3 WaveNf (vec3 p, float d)\n{\n  vec2 e = vec2 (max (0.1, 1e-4 * d * d), 0.);\n  float h = WaveHt (p);\n  return normalize (vec3 (h - WaveHt (p + e.xyy), e.x, h - WaveHt (p + e.yyx)));\n}\n\nfloat BoatDf (vec3 p, float dMin)\n{\n  vec3 q;\n  float d;\n  p.y -= 0.7;\n  q = p;\n  d = max (max (PrRCylDf (q, 1.2, 2., 3.5),\n     - max (PrRCylDf (q - vec3 (0., 0.1, 0.), 1.15, 2., 3.5),\n     max (q.y - 0.1, - q.y - 0.1))), max (q.y - 0., - q.y - 0.2));\n  q.y -= -0.2;\n  d = max (SmoothMin (d, max (PrRCylDf (q, 1., 2., 3.3), q.y), 0.1), q.z - 2.);\n  if (d < dMin) { dMin = d;  idObj = idObjGrp + 1;  qHit = q; }\n  q = p;\n  q.yz -= vec2 (-0.5, -0.2);\n  d = max (PrRCylDf (q, 1., 1.1, 2.3), max (0.4 - q.y, q.z - 1.2));\n  if (d < dMin) { dMin = d;  idObj = idObjGrp + 2;  qHit = q; }\n  q = p;\n  q.yz -= vec2 (1.3, -0.6);\n  d = PrCylDf (q.xzy, 0.04, 0.8);\n  q.y -= 0.2;\n  d = min (d, PrCylDf (q.yzx, 0.02, 0.2));\n  if (d < dMin) { dMin = d;  idObj = idObjGrp + 3; }\n  q.y -= 0.6;\n  d = PrCylDf (q.xzy, 0.15, 0.02);\n  if (d < dMin) { dMin = d;  idObj = idObjGrp + 4; }\n  q = p;\n  q.x = abs (q.x);\n  q -= vec3 (0.3, -0.9, 2.);\n  d = PrRoundBoxDf (q, vec3 (0.02, 0.2, 0.1), 0.03);\n  if (d < dMin) { dMin = d;  idObj = idObjGrp + 5; }\n  q.y -= -0.4;\n  d = PrCylAnDf (q, 0.1, 0.02, 0.2);\n  if (d < dMin) { dMin = d;  idObj = idObjGrp + 6; }\n  q = p;\n  q.yz -= vec2 (-1., 2.);\n  d = PrCylDf (q, 0.1, 0.2);\n  if (d < dMin) { dMin = d;  idObj = idObjGrp + 6; }\n  q = p;\n  q.yz -= vec2 (0.3, 1.9);\n  d = PrCylDf (q.xzy, 0.015, 0.5);\n  if (d < dMin) { dMin = d;  idObj = idObjGrp + 7; }\n  q.yz -= vec2 (0.38, 0.15);\n  d = PrBoxDf (q, vec3 (0.01, 0.1, 0.15));\n  if (d < dMin) { dMin = d;  idObj = idObjGrp + 8; }\n  return dMin;\n}\n\nfloat ObjDf (vec3 p)\n{\n  vec3 q;\n  const float szFac = 1.5;\n  float dMin, d, dLim;\n  dLim = 0.5;\n  dMin = dstFar;\n  dMin *= szFac;\n  q = p - boatPos[0];\n  idObjGrp = 1 * 256;\n  d = PrCylDf (q.xzy, 2., 2.);\n  dMin = (d < dLim) ? BoatDf (szFac * boatMat[0] * q, dMin) : min (dMin, d);\n  q = p - boatPos[1];\n  idObjGrp = 2 * 256;\n  d = PrCylDf (q.xzy, 2., 2.);\n  dMin = (d < dLim) ? BoatDf (szFac * boatMat[1] * q, dMin) : min (dMin, d);\n  return dMin / szFac;\n}\n\nfloat ObjRay (vec3 ro, vec3 rd)\n{\n  float dHit, d;\n  dHit = 0.;\n  for (int j = 0; j < 150; j ++) {\n    d = ObjDf (ro + dHit * rd);\n    dHit += d;\n    if (d < 0.001 || dHit > dstFar) break;\n  }\n  return dHit;\n}\n\nvec3 ObjNf (vec3 p)\n{\n  const vec3 e = vec3 (0.001, -0.001, 0.);\n  vec4 v = vec4 (ObjDf (p + e.xxx), ObjDf (p + e.xyy),\n     ObjDf (p + e.yxy), ObjDf (p + e.yyx));\n  return normalize (vec3 (v.x - v.y - v.z - v.w) + 2. * vec3 (v.y, v.z, v.w));\n}\n\nfloat ObjSShadow (vec3 ro, vec3 rd)\n{\n  float sh, d, h;\n  sh = 1.;\n  d = 0.02;\n  for (int j = 0; j < 25; j ++) {\n    h = ObjDf (ro + rd * d);\n    sh = min (sh, smoothstep (0., 1., 20. * h / d));\n    d += min (0.05, 3. * h);\n    if (h < 0.001) break;\n  }\n  return 0.3 + 0.7 * sh;\n}\n\nvec4 BoatCol (vec3 n)\n{\n  vec3 col, nn;\n  float spec;\n  int ig, id;\n  ig = idObj / 256;\n  id = idObj - 256 * ig;\n  if (ig == 1) nn = boatMat[0] * n;\n  else nn = boatMat[1] * n;\n  spec = 0.3;\n  if (id == 1) {\n    if (qHit.y < 0.1 && nn.y > 0.99) {\n      col = vec3 (0.8, 0.5, 0.3) *\n         (1. - 0.4 * SmoothBump (0.42, 0.58, 0.05, mod (7. * qHit.x, 1.)));\n      spec = 0.1;\n    } else if (qHit.x * nn.x > 0. && nn.y < 0. && qHit.z < 1.99 &&\n       abs (qHit.y - 0.1) < 0.095) col = (ig == 1) ? vec3 (0.3, 0.9, 0.3) :\n       vec3 (0.9, 0.3, 0.3);\n    else col = (qHit.y > -0.3) ? vec3 (1., 1., 0.2) : vec3 (0.7, 0.7, 0.8);\n  } else if (id == 2) {\n    if (abs (abs (qHit.x) - 0.24) < 0.22 && abs (qHit.y - 0.7) < 0.15 ||\n       abs (abs (qHit.z + 0.2) - 0.5) < 0.4 && abs (qHit.y - 0.7) < 0.15) {\n       col = vec3 (0., 0., 0.1);\n       spec = 1.;\n     } else col = vec3 (1.);\n  } else if (id == 3) col = vec3 (1., 1., 1.);\n  else if (id == 4) col = vec3 (1., 1., 0.4);\n  else if (id == 5) col = vec3 (0.4, 1., 0.4);\n  else if (id == 6) col = vec3 (1., 0.2, 0.);\n  else if (id == 7) col = vec3 (1., 1., 1.);\n  else if (id == 8) col = (ig == 1) ? vec3 (1., 0.4, 0.4) : vec3 (0.4, 1., 0.4);\n  return vec4 (col, spec);\n}\n\nfloat WaveAO (vec3 ro, vec3 rd)\n{\n  float ao, d;\n  ao = 0.;\n  for (int j = 1; j <= 4; j ++) {\n    d = 0.1 * float (j);\n    ao += max (0., d - 3. * ObjDf (ro + rd * d));\n  }\n  return clamp (1. - 0.1 * ao, 0., 1.);\n}\n\nfloat WakeFac (vec3 row)\n{\n  vec2 tw, tw1;\n  float wkFac, ba;\n  tw = row.xz - (boatPos[0].xz - Rot2D (vec2 (0., 3.), boatAng[0]));\n  tw1 = row.xz - (boatPos[1].xz - Rot2D (vec2 (0., 3.), boatAng[1]));\n  if (length (tw1) < length (tw)) {\n    tw = tw1;\n    ba = boatAng[1];\n  } else ba = boatAng[0];\n  tw = Rot2D (tw, - ba);\n  wkFac = 0.;\n  if (length (tw * vec2 (1., 0.5)) < 1.)\n     wkFac = clamp (1. - 1.5 * abs (tw.x), 0., 1.) * clamp (1. + 0.5 * tw.y, 0., 1.);\n  return wkFac;\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  vec4 objCol;\n  vec3 col, watCol, vn, vnw, row, rdw;\n  float dstObj, dstWat, wkFac, sh;\n  int idObjT;\n  bool waterRefl;\n  dstWat = WaveRay (ro, rd);\n  dstObj = ObjRay (ro, rd);\n  waterRefl = (dstWat < min (dstFar, dstObj));\n  if (waterRefl) {\n    ro += rd * dstWat;\n    row = ro;\n    rdw = rd;\n    wkFac = WakeFac (row);\n    vnw = WaveNf (ro, dstWat);\n    if (wkFac > 0.) vnw = VaryNf (10. * row, vnw, 5. * wkFac);\n    rd = reflect (rd, vnw);\n    ro += 0.1 * rd;\n    idObj = -1;\n    dstObj = ObjRay (ro, rd);\n  }\n  if (idObj < 0) dstObj = dstFar;\n  if (dstObj < dstWat) {\n    ro += dstObj * rd;\n    idObjT = idObj;\n    vn = ObjNf (ro);\n    idObj = idObjT;\n    objCol = BoatCol (vn);\n    sh = ObjSShadow (ro, sunDir);\n    col = objCol.rgb * (0.2 + 0.2 * (max (vn.y, 0.) + \n       max (dot (vn, - normalize (vec3 (sunDir.x, 0., sunDir.z))), 0.)) +\n       0.8 * sh * max (dot (vn, sunDir), 0.)) +\n       objCol.a * sh * pow (max (0., dot (sunDir, reflect (rd, vn))), 128.);\n    col = clamp (col, 0., 1.);\n  } else col = SkyCol (ro, rd);\n  if (waterRefl) {\n    watCol = (vec3 (0.2, 0.35, 0.4) * (0.5 + 0.5 * (max (vnw.y, 0.) +\n       0.1 * pow (max (0., dot (sunDir, reflect (rdw, vnw))), 128.)))) *\n       WaveAO (row, vec3 (0., 1., 0.));\n    col = mix (watCol, col, 0.8 * pow (1. - abs (dot (rdw, vnw)), 4.));\n    col = mix (col, vec3 (0.9),\n       pow (clamp (WaveHt (row) + 0.1 * Fbm3 (32. * row), 0., 1.), 8.));\n    if (wkFac > 0.) col = mix (col, vec3 (0.9),\n       wkFac * clamp (0.1 + Fbm3 (9.1 * row), 0., 1.));\n    col = mix (col, SkyCol (row, rdw), clamp (2. * dstWat / dstFar - 1.2, 0., 1.));\n  }\n  return clamp (col, 0., 1.);\n}\n\nvec3 TrackPath (float t)\n{\n  return vec3 (5. * sin (0.2 * t), 0., 1.5 * t);\n}\n\nvoid BoatPM (float t, float ds)\n{\n  vec3 bDir;\n  float h[5], c, s, bAz;\n  bPos = TrackPath (t);\n  vec3 bp = TrackPath (t + 0.1) - bPos;\n  bAz = atan (bp.z, - bp.x);\n  bPos.x += ds;\n  bDir = vec3 (0., 0., 1.);\n  bDir.xz = Rot2D (bDir.xz, bAz);\n  h[0] = WaveHt (bPos);\n  h[1] = WaveHt (bPos + 0.5 * bDir);\n  h[2] = WaveHt (bPos - 0.5 * bDir);\n  bDir.xz = Rot2D (bDir.xz, -0.5 * pi);\n  h[3] = WaveHt (bPos + 1.8 * bDir);\n  h[4] = WaveHt (bPos - 1.8 * bDir);\n  bPos.y = 0.1 + 1.1 * (2. * h[0] + h[1] + h[2] + h[3] + h[4]) / 6.;\n  bMat[2] = normalize (vec3 (4., h[2] - h[1], 0.));\n  bMat[0] = normalize (vec3 (0., 0.3 + h[3] - h[4], 4.));\n  bMat[1] = cross (bMat[0], bMat[2]);\n  c = cos (bAz);\n  s = sin (bAz);\n  bMat *= mat3 (c, 0., s, 0., 1., 0., - s, 0., c);\n  bAng = 0.5 * pi - bAz;\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  mat3 vuMat;\n  vec3 ro, rd, vd, u, bm;\n  vec2 canvas, uv, ori, ca, sa;\n  float f, az, el;\n  canvas = iResolution.xy;\n  uv = 2. * fragCoord.xy / canvas - 1.;\n  uv.x *= canvas.x / canvas.y;\n  tCur = iTime;\n  sunDir = normalize (vec3 (0.5, 0.5, -1.));\n  waterDisp = 0.25 * tCur * vec3 (-1., 0., 1.);\n  BoatPM (tCur, -3.);\n  boatPos[0] = bPos;\n  boatMat[0] = bMat;\n  boatAng[0] = bAng;\n  BoatPM (tCur, 3.);\n  boatPos[1] = bPos;\n  boatMat[1] = bMat;\n  boatAng[1] = bAng;\n  dstFar = 150.;\n  az = 2. * pi * 0.03 * tCur;\n  el = 0.02 * pi * (1. + sin (0.11 * pi * tCur));\n  ori = vec2 (el, az);\n  ca = cos (ori);\n  sa = sin (ori);\n  ro = vec3 (0., 0., -9.) * mat3 (1., 0., 0., 0., ca.x, - sa.x, 0., sa.x, ca.x) *\n     mat3 (ca.y, 0., - sa.y, 0., 1., 0., sa.y, 0., ca.y);\n  bm = 0.5 * (boatPos[0] + boatPos[1]);\n  ro += bm;\n  ro.y = max (ro.y + 2., 0.3 + WaveHt (ro));\n  bm.y += 0.5;\n  vd = normalize (bm - ro);\n  u = - vd.y * vd;\n  f = 1. / sqrt (1. - vd.y * vd.y);\n  vuMat = mat3 (f * vec3 (vd.z, 0., - vd.x), f * vec3 (u.x, 1. + u.y, u.z), vd);\n  rd = vuMat * normalize (vec3 (uv, 2.5));\n  fragColor = vec4 (ShowScene (ro, rd), 1.);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc-by-nc-sa-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4sV3zR.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "4sy3Dz", "name": "WiFi Beamforming visualization", "author": "Andre", "description": "I made a 2D visualization of wifistrength and beamforming using 2 antenna's. The view is 8M wide and the antenna's are 130mm apart. You can change the parameters if you like. Also added an option to add a middle antenna (half out of phase).", "tags": ["2d", "educational", "visualisation", "wifi", "beamforming"], "likes": 6, "viewed": 318, "date": "1453927623", "time_retrieved": "2024-06-20T18:30:08.265217", "image_code": "// Parameters for the calculation, you can change them to see the effect\nconst float waveLength = 125.0; // Wavelength at 2.4 GHz is 125mm\nconst float viewDistance = 4000.0; // Distance in mm, view from center of antenna's\nconst float antennaDistance = 125.0; // Distance between antenna's\n#define middleAntenna 0\n        \nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 antenna1 = (2.0*fragCoord-iResolution.xy) / iResolution.x; // -1.0 .. 1.0\n    antenna1 *= (1.0 / waveLength) * 6.28 * viewDistance; // put viewDistance into view\n    \n    vec2 antenna2 = antenna1;\n#if middleAntenna    \n    vec2 antenna3 = antenna1;\n#endif    \n    \n    // Put distance between antanna's\n    float dist = 0.5 * (1.0 / waveLength) * 6.28 * antennaDistance; \n    antenna1.x += dist;\n    antenna2.x -= dist;\n    \n    // Phase shift is used to steer beamforming\n    float phaseShift = sin(iTime)*3.14;\n    \n    // Calculate color so you can see where they cancel each other (black area)\n    fragColor = vec4(vec3(abs(\n                sin(iTime*-4.+length(antenna1)+phaseShift)\n              + sin(iTime*-4.+length(antenna2))\n#if middleAntenna    \n              + sin(iTime*-4.+length(antenna3)+phaseShift*.5))) * .33\n#else                     \n              )) * .5\n#endif    \n                ,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4sy3Dz.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "4sy3zW", "name": "Everyday021 - Relax", "author": "Makio64", "description": "everyday021 - Relax", "tags": ["everyday"], "likes": 6, "viewed": 564, "date": "1453379447", "time_retrieved": "2024-06-20T18:30:09.538016", "image_code": "// Everyday021 - Relax\n// By David Ronai / @Makio64\n\n//------------------------------------------------------------------ VISUAL QUALITY\n#define POSTPROCESS\n#define RAYMARCHING_STEP 40\n#define RAYMARCHING_JUMP 1.\n//------------------------------------------------------------------ DEBUG\n//#define RENDER_DEPTH\n//#define RENDER_NORMAL\n//#define RENDER_AO\n\nconst float SPEED = 10.;\nconst float PI = 3.14159265359;\n\n//------------------------------------------------------------------  SIGNED PRIMITIVES\n//http://mercury.sexy/hg_sdf/\nfloat fCylinder(vec3 p, float r, float height) {\n\tfloat d = length(p.xz) - r;\n\td = max(d, abs(p.y) - height);\n\treturn d;\n}\nfloat vmax(vec3 v) {\n\treturn max(max(v.x, v.y), v.z);\n}\nfloat fBox(vec3 p, vec3 b) {\n\tvec3 d = abs(p) - b;\n\treturn length(max(d, vec3(0))) + vmax(min(d, vec3(0)));\n}\n\nvec3 pMod3(inout vec3 p, vec3 size) {\n\tvec3 c = floor((p + size*0.5)/size);\n\tp = mod(p + size*0.5, size) - size*0.5;\n\treturn c;\n}\nvoid pR(inout vec2 p, float a) {\n\tp = cos(a)*p + sin(a)*vec2(p.y, -p.x);\n}\nfloat fOpUnionStairs(float a, float b, float r, float n) {\n\tfloat s = r/n;\n\tfloat u = b-r;\n\treturn min(min(a,b), 0.5 * (u + a + abs ((mod (u - a + s, 2. * s)) - s)));\n}\n\nfloat fHexagonCircumcircle(vec3 p, vec2 h) {\n\tvec3 q = abs(p);\n\treturn max(q.y - h.y, max(q.x*sqrt(3.)*0.5 + q.z*0.5, q.z) - h.x);\n}\nfloat pyramid( vec3 p, float h) {\n\tvec3 q=abs(p);\n\treturn max(-p.y, (q.x*1.5+q.y+q.z*1.5-h)/3.0 );\n}\n\nfloat pModPolar(inout vec2 p, float repetitions) {\n\tfloat angle = 2.*PI/repetitions;\n\tfloat a = atan(p.y, p.x) + angle/2.;\n\tfloat r = length(p);\n\tfloat c = floor(a/angle);\n\ta = mod(a,angle) - angle/2.;\n\tp = vec2(cos(a), sin(a))*r;\n\tif (abs(c) >= (repetitions/2.)) c = abs(c);\n\treturn c;\n}\n\nfloat pMod1(inout float p, float size) {\n\tfloat halfsize = size*0.5;\n\tfloat c = floor((p + halfsize)/size);\n\tp = mod(p + halfsize, size) - halfsize;\n\treturn c;\n}\n\n\n\n//------------------------------------------------------------------ MAP\nfloat map( in vec3 pos ) {\n\tvec3 q = pos;\n    //pR(q.xy,iTime+sin(pos.z));\n    pModPolar(q.xy,18.);\n    pMod1(q.z,0.0000001);\n    float idx2 = pMod1(pos.z,10.);\n    idx2 = abs(sin(idx2))*3.;\n    q.y += 10.;\n\tfloat d = pyramid(q,20.);\n    q.y -= 1.8;\n\tfloat d2 = pyramid(q,15.);\n    d = max(-d2,d);\n\tfloat b = fBox(pos, vec3(50.,50.,2.));\n    d = max(-b,d);    \n    return d;\n}\n\n//------------------------------------------------------------------ RAYMARCHING\n#ifdef RENDER_DEPTH\nfloat castRay( in vec3 ro, in vec3 rd, inout float depth )\n#else\nfloat castRay( in vec3 ro, in vec3 rd )\n#endif\n{\n\tfloat t = 0.0;\n\tfloat res;\n\tfor( int i=0; i<RAYMARCHING_STEP; i++ )\n\t{\n\t\tvec3 pos = ro+rd*t;\n\t\tres = map( pos );\n\t\tif( res < 0.01 || t > 150. ) break;\n\t\tt += res*RAYMARCHING_JUMP;\n\t\t#ifdef RENDER_DEPTH\n\t\tdepth += 1./float(RAYMARCHING_STEP);\n\t\t#endif\n\t}\n\treturn t;\n}\n\nvec3 calcNormal(vec3 p) {\n\tfloat eps = 0.0001;\n\tconst vec3 v1 = vec3( 1.0,-1.0,-1.0);\n\tconst vec3 v2 = vec3(-1.0,-1.0, 1.0);\n\tconst vec3 v3 = vec3(-1.0, 1.0,-1.0);\n\tconst vec3 v4 = vec3( 1.0, 1.0, 1.0);\n\treturn normalize( v1 * map( p + v1*eps ) +\n\t\t\t\t\t  v2 * map( p + v2*eps ) +\n\t\t\t\t\t  v3 * map( p + v3*eps ) +\n\t\t\t\t\t  v4 * map( p + v4*eps ) );\n}\n\nfloat hash( float n ){\n\treturn fract(sin(n)*3538.5453);\n}\n\nfloat calcAO( in vec3 p, in vec3 n, float maxDist, float falloff ){\n\tfloat ao = 0.0;\n\tconst int nbIte = 6;\n\tfor( int i=0; i<nbIte; i++ )\n\t{\n\t\tfloat l = hash(float(i))*maxDist;\n\t\tvec3 rd = n*l;\n\t\tao += (l - map( p + rd )) / pow(1.+l, falloff);\n\t}\n\treturn clamp( 1.-ao/float(nbIte), 0., 1.);\n}\n\n// calculate local thickness\n// base on AO but : inverse the normale & inverse the color\nfloat thickness( in vec3 p, in vec3 n, float maxDist, float falloff )\n{\n\tfloat ao = 0.0;\n\tconst int nbIte = 6;\n\tfor( int i=0; i<nbIte; i++ )\n\t{\n\t\tfloat l = hash(float(i))*maxDist;\n\t\tvec3 rd = -n*l;\n\t\tao += (l + map( p + rd )) / pow(1.+l, falloff);\n\t}\n\treturn clamp( 1.-ao/float(nbIte), 0., 1.);\n}\n\n//------------------------------------------------------------------ POSTEFFECTS\n\n#ifdef POSTPROCESS\nvec3 postEffects( in vec3 col, in vec2 uv, in float time )\n{\n\t// vigneting\n\tcol *= 0.4+0.6*pow( 16.0*uv.x*uv.y*(1.0-uv.x)*(1.0-uv.y), 0.5 );\n\treturn col;\n}\n#endif\n\nvec3 addLight(in vec3 lpos, inout vec3 col, in vec3 pos, in vec3 nor, in vec3 rd, in float thi){\n\tvec3 ldir = normalize(lpos-pos);\n\tfloat latt = pow( length(lpos-pos)*.03, .5 );\n    float trans =  pow( clamp( max(0.,dot(-rd, -ldir+nor)), 0., 1.), 1.) + 1.;\n\t//col = vec3(.2,.1,.1) * (max(dot(nor,ldir),0.) ) / latt;\n\tcol += vec3(.3,.3,.1) * (trans/latt)*thi;\n    return col;\n   \n}\n\nvec3 render( in vec3 ro, in vec3 rd, in vec2 uv )\n{\n\tvec3 col = vec3(.0,.0,1.2);\n\n\t#ifdef RENDER_DEPTH\n\tfloat depth = 0.;\n\tfloat t = castRay(ro,rd,depth);\n\t#else\n\tfloat t = castRay(ro,rd);\n\t#endif\n\n\t#ifdef RENDER_DEPTH\n\treturn vec3(depth/10.,depth/5.,depth);\n\t#endif\n\n\tvec3 pos = ro + t * rd;\n\tvec3 nor = calcNormal(pos);\n\n\t#ifdef RENDER_NORMAL\n\treturn nor;\n\t#endif\n\n\tfloat ao = calcAO(pos,nor,10.,1.2);\n\t#ifdef RENDER_AO\n\treturn vec3(ao);\n\t#endif\n\n    float thi = thickness(pos, nor, 4., 2.5);\n\n    vec3 lpos1 = vec3(0.,27.5,-iTime*SPEED);\n\tvec3 ldir1 = normalize(lpos1-pos);\n\tfloat latt1 = pow( length(lpos1-pos)*.03, 1. );\n    float trans1 =  pow( clamp( max(0.,dot(-rd, -ldir1+nor)), 0., 1.), 1.) + 1.;\n\tvec3 diff1 = vec3(.3,.2,.1) * (max(dot(nor,ldir1),0.) ) / latt1;\n\tcol =  diff1;\n\tcol += vec3(.8,.6,.9) * (trans1/latt1)*thi;\n    \n    vec3 lpos = vec3(80.,0.,-iTime*SPEED);\n    vec3 ldir = normalize(lpos-pos);\n\tfloat latt = pow( length(lpos-pos)*.03, .1 );\n    float trans =  pow( clamp( max(0.,dot(-rd, -ldir+nor)), 0., 1.), 1.) + 1.;\n\tcol += vec3(.2,.1,.1) * (max(dot(nor,ldir),0.) ) / latt;\n\tcol += vec3(.1,.1,.1) * (trans/latt)*thi;\n\n    float d = distance(pos.xyz,vec3(0.));\n\tcol = max(vec3(.05),col);\n\tcol *= ao;\n    \n\tcol = mix( col, vec3(1.), 1.0-exp((0.000015+abs(sin(iTime)*0.00015))*t*t));\n\n\treturn col;\n}\n\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr )\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n\treturn mat3( cu, cv, cw );\n}\n\nvec3 orbit(float phi, float theta, float radius)\n{\n\treturn vec3(\n\t\tradius * sin( phi ) * cos( theta ),\n\t\tradius * cos( phi ),\n\t\tradius * sin( phi ) * sin( theta )\n\t);\n}\n\n//------------------------------------------------------------------ MAIN\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 p = -1. + 2. * uv;\n    p.x *= iResolution.x / iResolution.y;\n    \n    //Camera\n\tfloat radius = 10.;\n    float angle = iTime;\n\tvec3 ro = vec3(0.,0.2,-SPEED*iTime+radius);\n\tvec3 ta  = vec3(0.,0., -SPEED*iTime);\n\tmat3 ca = setCamera( ro, ta, 0. );\n\tvec3 rd = ca * normalize( vec3(p.xy,1.5) );\n\n\t// Raymarching\n\tvec3 color = render( ro, rd, uv );\n\t#ifdef POSTPROCESS\n\tcolor = postEffects( color, uv, iTime );\n\t#endif\n\tfragColor = vec4(color,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4sy3zW.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "4syGR1", "name": "Combining two Triangles", "author": "Lerc", "description": "Multiple ways to render six points as a pair of triangles.  The same six points are used for all 8 images with each image using different options.   The top row has an outline triangle,  Left to Right are Additive,  smooth combine. subtract, and Intersect", "tags": ["2d", "triangles"], "likes": 5, "viewed": 232, "date": "1453185507", "time_retrieved": "2024-06-20T18:30:09.538016", "image_code": "float dot2(in vec2 a) {\n    return dot(a,a);\n}\n\nfloat smin( float a, float b, float k )\n{\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\nfloat tri_d(in vec2 p, in vec2 a, in vec2 b, in vec2 c) {\n    vec2 ba = b-a;\n    vec2 cb = c-b;\n    vec2 ac = a-c;\n    \n    vec2 pa = p-a;\n    vec2 pb = p-b;\n    vec2 pc = p-c;\n    \n    float edge_ab = dot (vec2(-ba.y,ba.x),pa);\n    float edge_bc = dot (vec2(-cb.y,cb.x),pb);\n    float edge_ca = dot (vec2(-ac.y,ac.x),pc);\n                             \n    float v= sign(edge_ab) + sign(edge_bc) + sign(edge_ca);\n    \n    return (v <2.0)         \n        ? sqrt(min (min(\n          dot2(ba*clamp(dot(ba,pa)/dot2(ba),0.0,1.0)-pa),\n     \t  dot2(cb*clamp(dot(cb,pb)/dot2(cb),0.0,1.0)-pb) ),\n          dot2(ac*clamp(dot(ac,pc)/dot2(ac),0.0,1.0)-pc) ) )         \n    \t: 0.0;\n\n}\n\n\n\nfloat halfs(in vec2 p, in vec2 a, in vec2 b) {\n    vec2 d = b-a;\n    return dot (vec2(-d.y,d.x),(p-a));\n    \n}\n\nfloat shape_alpha(in vec2 p,\n                  in vec2 a, in vec2 b, in vec2 c,\n                  in vec2 d, in vec2 e, in vec2 f,\n                  in int combineMethod, in float blur) {\n    \n    float tri_1 = tri_d(p, a,b,c);\n    float tri_2 = tri_d(p, d,e,f);\n    \n    float result = 0.0;\n    \n    if ( combineMethod == 0 ) {\n        result = min(tri_1,tri_2);\n    }\n    \n    if ( combineMethod == 1 ) {\n        result = smin(tri_1,tri_2,0.05);\n    }\n\n    if ( combineMethod == 2 ) {\n        result = max(blur-tri_1,tri_2);\n    }\n    \n    if ( combineMethod == 3 ) {\n        result = max(tri_1,tri_2);\n    }\n    \n    return 1.0-smoothstep(0.00,blur,result);    \n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.y;\n    \n    vec2 a = vec2(0.2,0.2);\n    vec2 b = vec2(0.4,0.4);\n    vec2 c = vec2(0.15,0.5);\n\n    vec2 c2 = vec2(0.3,0.2);\n    vec2 b2 = vec2(0.1,0.4);\n    vec2 a2 = vec2(0.4,0.5);\n        \n    float q = 0.0;\n    \n    vec2 xspacing=vec2(0.4,0.0);\n    vec2 yspacing=vec2(0.0,0.4);\n    \n    float blur = 0.2+0.2*sin(iTime);\n    blur=blur*blur;\n    \n    for (int i=0; i<4;i++) {        \n    \tq= max(q,shape_alpha(uv, a,b,c, a2,b2,c2, i, blur));\n    \tq= max(q,shape_alpha(uv, a+yspacing,b+yspacing,c+yspacing, c2+yspacing,b2+yspacing,a2+yspacing, i, blur));\n        a=a+xspacing;\n        b=b+xspacing;\n        c=c+xspacing;\n\n        a2=a2+xspacing;\n        b2=b2+xspacing;\n        c2=c2+xspacing;\n    }    \n    \n    \n\tfragColor = vec4(q,q,q,1.0);\n    \n\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4syGR1.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "ld33W2", "name": "Shapes Morphing", "author": "TambakoJaguar", "description": "Use your mouse to morph between sphere, torus and cube (and a bit over!)\nOn this one, I used Fresnel reflection for fun and made a simple \"world landscape\".\nYou can also hit S to switch between normal and stereo (red-cyan anaglyph)", "tags": ["3d", "raymarching", "mouse", "torus", "cube", "sphere", "landscape", "primitives", "morphing"], "likes": 4, "viewed": 220, "date": "1452208253", "time_retrieved": "2024-06-20T18:30:11.035145", "image_code": "/*\n\"Shapes Morphing\" by Emmanuel Keller aka Tambako - January 2016\nLicense Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\nContact: tamby@tambako.ch\n*/\n\n#define pi 3.141593\n\nstruct Lamp\n{\n  vec3 position;\n  vec3 color;\n  float intensity;\n  float attenuation;\n};\n\nLamp lamps[3];\n    \nstruct RenderData\n{\n  vec3 col;\n  vec3 pos;\n  vec3 norm;\n  int objnr;\n};\n\nvec3 campos = vec3(0., 0.5, 5.);\nvec3 camdir = vec3(0., -0.1, -1.);\nfloat eye_dist = 0.25;\nbool stereo = false;\nfloat fov = 2.8;\n\nconst vec3 ambientColor = vec3(0.1, 0.4, 0.9);\nconst float ambientint = 0.08;\n\nvec3 colors[3];\n\n//#define shadow\n#define ambocc\n#define specular\nconst float specint = 0.2;\nconst float specshin = 30.;\nconst float aoint = 0.6;\nconst float shi = 0.8;\nconst float shf = 0.5;\n\nconst float normdelta = 0.0001;\nconst float maxdist = 55.;\n\n// Antialias. Change from 1 to 2 or more AT YOUR OWN RISK! It may CRASH your browser while compiling!\nconst float aawidth = 0.9;\nconst int aasamples = 2;\n\nconst int KEY_S = 83;\n\n// From https://www.shadertoy.com/view/4dsGRl\nbool ReadKey( int key, bool toggle )\n{\n\tfloat keyVal = texture( iChannel2, vec2( (float(key)+.5)/256.0, toggle?.75:.25 ) ).x;\n\treturn (keyVal>.5)?true:false;\n}\n\nvec2 rotateVec(vec2 vect, float angle)\n{\n    vec2 rv;\n    rv.x = vect.x*cos(angle) + vect.y*sin(angle);\n    rv.y = vect.x*sin(angle) - vect.y*cos(angle);\n    return rv;\n}\n\nfloat map(vec3 pos)\n{\n    float angle = mod(iTime*.8, 2.*pi);\n    vec3 posr = vec3(pos.x*cos(angle) + pos.z*sin(angle), pos.y, pos.x*sin(angle) - pos.z*cos(angle));\n    \n    float d1 = length(posr) - 1.35;\n    float d2 = pow(1.1 - sqrt(pow(posr.x, 2.)+pow(posr.y, 2.)), 2.) + pow(posr.z, 2.) - 0.1;\n    float d3 = max(max(abs(posr.y), abs(posr.z)), abs(posr.x)) - 1.;\n    float mx = iMouse.x/iResolution.x*1.2 - 0.3;\n    float my = iMouse.y/iResolution.y*1.6 -  0.3;\n    return mix(mix(d1, d2, mx), d3, my);\n    return d3;\n}\n\nfloat trace(vec3 cam, vec3 ray, float maxdist) \n{\n    float t = 3.2;\n  \tfor (int i = 0; i < 180; ++i)\n    {\n    \tvec3 pos = ray*t + cam;\n    \tfloat dist = map(pos);\n        if (dist>maxdist || abs(dist)<0.0003)\n            break;\n        t+= dist*0.4;\n  \t}\n  \treturn t;\n}\n\n// From https://www.shadertoy.com/view/MstGDM\nvec3 getNormal(vec3 pos, float e)\n{\n    vec2 q = vec2(0, e);\n    return normalize(vec3(map(pos + q.yxx) - map(pos - q.yxx),\n                          map(pos + q.xyx) - map(pos - q.xyx),\n                          map(pos + q.xxy) - map(pos - q.xxy)));\n}\n\nvec3 obj_color(vec3 norm, vec3 pos)\n{\n    return mix(vec3(1., 0.5, 0.2), vec3(0.5, 0.1, 0.9), dot(cross(norm.xyz, norm.zxy), norm.yzx));\n}\n\nvec3 sky_color(vec3 ray)\n{\n    float elev = atan(ray.y);\n \n    const float cloudsize = 0.25;\n    vec3 sky = ambientColor + vec3(0.4, 0.3, 0.05)*2.8*(0.65-elev);\n    float cloudst = smoothstep(-0.2, 0.5, elev)*texture(iChannel0, cloudsize*ray.xy).r;\n    sky = mix(sky, 0.45 + 0.6*vec3(cloudst), smoothstep(0.12, 0.5, cloudst)) + 0.3*vec3(smoothstep(0.2, 0.8, cloudst));\n    \n    vec3 grass = vec3(0.0, 0.35, 0.25) + vec3(0.22, 0.16, -0.03)*2.8*(0.65-elev);\n    grass = grass*(0.6 + 2.*abs(elev)*texture(iChannel1, 4.*ray.xy).rgb);\n    \n    return mix(grass, sky, smoothstep(-0.001, 0.001, elev)); \n}\n\n// From https://www.shadertoy.com/view/Xds3zN;\nfloat softshadow(vec3 ro, vec3 rd, float mint, float tmax)\n{\n\tfloat res = 1.0;\n    float t = mint;\n    for(int i=0; i<16; i++)\n    {\n    \tfloat h = map(ro + rd*t);\n        res = min( res, 8.0*h/t );\n        t += clamp( h, 0.02, 0.10 );\n        if( h<0.001 || t>tmax ) break;\n    }\n    return clamp( res, 0.0, 1.0 );\n}\n\n// From https://www.shadertoy.com/view/Xds3zN;\nfloat calcAO(vec3 pos, vec3 nor)\n{\n\tfloat occ = 0.0;\n    float sca = 0.8;\n    for( int i=0; i<5; i++ )\n    {\n        float hr = 0.01 + 0.12*float(i)/4.0;\n        vec3 aopos =  nor * hr + pos;\n        \n    \tfloat dd = map(aopos);\n        \n        occ += -(dd-hr)*sca;\n        sca *= 0.95;\n    }\n    return clamp( 1.0 - 2.5*occ, 0.0, 1.0 );    \n}\n\n// Fresnel reflectance factor through Schlick's approximation: https://en.wikipedia.org/wiki/Schlick's_approximation\nfloat fresnel(vec3 ray, vec3 norm, float n2)\n{\n   float n1 = 1.; // air\n   float angle = clamp(acos(-dot(ray, norm)), -pi/2.15, pi/2.15);\n   float r0 = pow((n1-n2)/(n1+n2), 2.);\n   float r = r0 + (1. - r0)*pow(1. - cos(angle), 5.);\n   return clamp(0., 0.9, r);\n}\n\nvec3 lampShading(Lamp lamp, vec3 norm, vec3 pos, vec3 ocol)\n{\n\tvec3 pl = normalize(lamp.position - pos);\n    float dlp = distance(lamp.position, pos);\n    vec3 pli = pl/pow(1. + lamp.attenuation*dlp, 2.);\n      \n    // Diffuse shading\n    float diff = clamp(dot(norm, pli), 0., 1.);\n    vec3 col = ocol*normalize(lamp.color)*lamp.intensity*smoothstep(0., 1.04, pow(diff, 0.78));\n    //vec3 col = ocol*normalize(lamp.color)*lamp.intensity*diff;\n    \n    // Specular shading\n    #ifdef specular\n    if (dot(norm, lamp.position - pos) > 0.0)\n        col+= vec3(1., 0.7, 0.3)*normalize(lamp.color)*lamp.intensity*specint*pow(max(0.0, dot(reflect(pl, norm), normalize(pos - campos))), specshin);\n    #endif\n    \n    // Softshadow\n    #ifdef shadow\n    col*= shi*softshadow(pos, normalize(lamp.position-pos), shf, 50.) + 1. - shi;\n    #endif\n    \n    return col;\n}\n\nvec3 lampsShading(vec3 norm, vec3 pos, vec3 ocol)\n{\n    vec3 col = vec3(0.);\n    for (int l=0; l<3; l++) // lamps.length()\n        col+= lampShading(lamps[l], norm, pos, ocol);\n    \n    return col;\n}\n\n// From https://www.shadertoy.com/view/lsSXzD, modified\nvec3 GetCameraRayDir(vec2 vWindow, vec3 vCameraDir, float fov)\n{\n\tvec3 vForward = normalize(vCameraDir);\n\tvec3 vRight = normalize(cross(vec3(0.0, 1.0, 0.0), vForward));\n\tvec3 vUp = normalize(cross(vForward, vRight));\n    \n\tvec3 vDir = normalize(vWindow.x * vRight + vWindow.y * vUp + vForward * fov);\n\n\treturn vDir;\n}\n\nRenderData trace0(vec3 tpos, vec3 ray)\n{\n    float tx = trace(tpos, ray, maxdist);\n    vec3 col;\n    int objnr;\n    \n    vec3 pos = tpos + tx*ray;\n    vec3 norm;\n    if (tx<10.)\n    {\n        norm = getNormal(pos, normdelta);\n\n        // Coloring\n        col = obj_color(norm, pos);\n        objnr = 1;\n      \n        // Shading\n        col = ambientColor*ambientint + lampsShading(norm, pos, col);\n        \n        // Sky reflection\n        float r = fresnel(ray, norm, 2.3);\n        col = mix(col, sky_color(reflect(ray, norm)), r);\n        \n        // Ambient occlusion\n        #ifdef ambocc\n        col*= 1. - aoint + 1.25*aoint*vec3(calcAO(pos, norm));\n        //col = vec3(calcAO(pos, norm));\n        #endif\n  }\n  else\n  {\n      // Sky\n      col = sky_color(ray);\n      objnr = 3;\n  }\n  return RenderData(col, pos, norm, objnr);\n}\n\nvec4 render(vec2 fragCoord, vec3 campos)\n{\n  lamps[0] = Lamp(vec3(0., 4.5, 10.), vec3(1., 1., 1.), 6., 0.1);\n  lamps[1] = Lamp(vec3(12., -0.5, 6.), vec3(.9, 0.98, 1.), 4., 0.1);\n  lamps[2] = Lamp(vec3(-9., 1.8, -5. + iTime), vec3(1.0, 0.7, 0.7), 3., 0.1);\n    \n  vec2 uv = fragCoord.xy / iResolution.xy; \n  uv = uv*2.0 - 1.0;\n  uv.x*= iResolution.x / iResolution.y;\n\n  vec3 ray = GetCameraRayDir(uv, camdir, fov);\n    \n  RenderData traceinf = trace0(campos, ray);\n  vec3 col = traceinf.col;\n\n  return vec4(col, 1.0);\n}\n\nvec4 render_aa(vec2 fragCoord, vec3 campos)\n{\n    // Antialiasing\n    vec4 vs = vec4(0.);\n    for (int j=0;j<aasamples ;j++)\n    {\n       float oy = float(j)*aawidth/max(float(aasamples-1), 1.);\n       for (int i=0;i<aasamples ;i++)\n       {\n          float ox = float(i)*aawidth/max(float(aasamples-1), 1.);\n          vs+= render(fragCoord + vec2(ox, oy), campos);\n       }\n    }\n    return vs/vec4(aasamples*aasamples);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    if (ReadKey(83, true))\n        stereo = !stereo;\n\n    if (stereo)\n    {\n       vec4 im_l = render_aa(fragCoord, campos + vec3(eye_dist/2., 0., 0.));\n       vec4 im_r = render_aa(fragCoord, campos + vec3(-eye_dist/2., 0., 0.)); \n       fragColor = vec4(im_l.r, 0, 0, 0) + vec4(0, im_r.gb, 0);\n    }\n    else \n       fragColor = render_aa(fragCoord, campos);    \n}", "image_inputs": [{"id": "4dXGzn", "previewfilepath": "/media/ap/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "ctype": "texture"}, {"id": "4dXGRr", "previewfilepath": "/presets/tex00.jpg", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/presets/tex00.jpg", "ctype": "keyboard"}, {"id": "Xsf3Rr", "previewfilepath": "/media/ap/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc-by-nc-sa-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/ld33W2.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "ld3Gzs", "name": "Radiolarian #2 shaded", "author": "tdhooper", "description": "Sources:\n* https://www.shadertoy.com/view/Mdt3RX\n* https://www.shadertoy.com/view/XljGDz\n* https://www.shadertoy.com/view/Xt2XDt", "tags": ["reflection", "sdf", "lighting", "modgeometry"], "likes": 16, "viewed": 717, "date": "1451699625", "time_retrieved": "2024-06-20T18:30:13.544359", "image_code": "\n\n\n\n#define PHI (sqrt(5.)*0.5 + 0.5)\n#define PI 3.14159265\n\nfloat t;\n\n\n\n\nfloat vmax(vec3 v) {\n\treturn max(max(v.x, v.y), v.z);\n}\n\nfloat fPlane(vec3 p, vec3 n, float distanceFromOrigin) {\n    return dot(p, n) + distanceFromOrigin;\n}\n\n// Box: correct distance to corners\nfloat fBox(vec3 p, vec3 b) {\n\tvec3 d = abs(p) - b;\n\treturn length(max(d, vec3(0))) + vmax(min(d, vec3(0)));\n}\n\nfloat fOpIntersectionRound(float a, float b, float r) {\n    float m = max(a, b);\n    if ((-a < r) && (-b < r)) {\n        return max(m, -(r - sqrt((r+a)*(r+a) + (r+b)*(r+b))));\n    } else {\n        return m;\n    }\n}\n\n\n// Cone with correct distances to tip and base circle. Y is up, 0 is in the middle of the base.\nfloat fCone(vec3 p, float radius, float height) {\n    vec2 q = vec2(length(p.xz), p.y);\n    vec2 tip = q - vec2(0, height);\n    vec2 mantleDir = normalize(vec2(height, radius));\n    float mantle = dot(tip, mantleDir);\n    float d = max(mantle, -q.y);\n    float projected = dot(tip, vec2(mantleDir.y, -mantleDir.x));\n    \n    // distance to tip\n    if ((q.y > height) && (projected < 0.)) {\n        d = max(d, length(tip));\n    }\n    \n    // distance to base ring\n    if ((q.x > radius) && (projected > length(vec2(height, radius)))) {\n        d = max(d, length(q - vec2(radius, 0)));\n    }\n    return d;\n}\n\n// Reflect space at a plane\nfloat pReflect(inout vec3 p, vec3 planeNormal, float offset) {\n    float t = dot(p, planeNormal)+offset;\n    if (t < 0.) {\n        p = p - (2.*t)*planeNormal;\n    }\n    return sign(t);\n}\n\n// Rotate around a coordinate axis (i.e. in a plane perpendicular to that axis) by angle <a>.\n// Read like this: R(p.xz, a) rotates \"x towards z\".\n// This is fast if <a> is a compile-time constant and slower (but still practical) if not.\nvoid pR(inout vec2 p, float a) {\n    p = cos(a)*p + sin(a)*vec2(p.y, -p.x);\n}\n\n// The \"Round\" variant uses a quarter-circle to join the two objects smoothly:\nfloat fOpUnionRound(float a, float b, float r) {\n    float m = min(a, b);\n    if ((a < r) && (b < r) ) {\n        return min(m, r - sqrt((r-a)*(r-a) + (r-b)*(r-b)));\n    } else {\n     return m;\n    }\n}\n\n// Repeat around the origin by a fixed angle.\n// For easier use, num of repetitions is use to specify the angle.\nfloat pModPolar(inout vec2 p, float repetitions) {\n    float angle = 2.*PI/repetitions;\n    float a = atan(p.y, p.x) + angle/2.;\n    float r = length(p);\n    float c = floor(a/angle);\n    a = mod(a,angle) - angle/2.;\n    p = vec2(cos(a), sin(a))*r;\n    // For an odd number of repetitions, fix cell index of the cell in -x direction\n    // (cell index would be e.g. -5 and 5 in the two halves of the cell):\n    if (abs(c) >= (repetitions/2.)) c = abs(c);\n    return c;\n}\n\n// Knighty https://www.shadertoy.com/view/XlX3zB\n\nint Type=5;\n\nvec3 nc,pab,pbc,pca;\nvoid initIcosahedron() {//setup folding planes and vertex\n    float cospin=cos(PI/float(Type)), scospin=sqrt(0.75-cospin*cospin);\n\tnc=vec3(-0.5,-cospin,scospin);//3rd folding plane. The two others are xz and yz planes\n\tpab=vec3(0.,0.,1.);\n\tpbc=vec3(scospin,0.,0.5);//No normalization in order to have 'barycentric' coordinates work evenly\n\tpca=vec3(0.,scospin,cospin);\n\tpbc=normalize(pbc);\tpca=normalize(pca);//for slightly better DE. In reality it's not necesary to apply normalization :) \n}\n\n// Barycentric to Cartesian \nvec3 bToC(vec3 A, vec3 B, vec3 C, vec3 barycentric) {\n\treturn barycentric.x * A + barycentric.y * B + barycentric.z * C;\n}\n\nvec3 pModIcosahedron(inout vec3 p, int subdivisions) {\n\tp = abs(p);\n\tpReflect(p, nc, 0.);\n\tp.xy = abs(p.xy);\n\tpReflect(p, nc, 0.);\n\tp.xy = abs(p.xy);\n\tpReflect(p, nc, 0.);\n    \n    if (subdivisions > 0) {\n\n        vec3 A = pbc;\n       \tvec3 C = reflect(A, normalize(cross(pab, pca)));\n        vec3 B = reflect(C, normalize(cross(pbc, pca)));\n       \n        vec3 n;\n\n        // Fold in corner A \n        \n        vec3 p1 = bToC(A, B, C, vec3(.5, .0, .5));\n        vec3 p2 = bToC(A, B, C, vec3(.5, .5, .0));\n        n = normalize(cross(p1, p2));\n        pReflect(p, n, 0.);\n        \n        if (subdivisions > 1) {\n\n            // Get corners of triangle created by fold\n\n            A = reflect(A, n);\n            B = p1;\n            C = p2;\n            \n            // Fold in corner A\n\n            p1 = bToC(A, B, C, vec3(.5, .0, .5));\n            p2 = bToC(A, B, C, vec3(.5, .5, .0));\n            n = normalize(cross(p1, p2));\n            pReflect(p, n, 0.);\n            \n\n            // Fold in corner B\n            \n\t\t\tp2 = bToC(A, B, C, vec3(.0, .5, .5));\n            p1 = bToC(A, B, C, vec3(.5, .5, .0));\n            n = normalize(cross(p1, p2));\n            pReflect(p, n, 0.);\n        }\n    }\n\n    return p;\n}\n\nvec3 lerp(vec3 a, vec3 b, float s) {\n\treturn a + (b - a) * s;\n}\n\nvoid faceDodecahedron(inout vec3 p) {\n\tvec3 rn = normalize(lerp(pbc, vec3(0,0,1), 0.5));\n    p = reflect(p, rn);\n}\n\nvoid faceIcosahedron(inout vec3 p) {\n\tvec3 rn = normalize(lerp(pca, vec3(0,0,1), 0.5));\n    p = reflect(p, rn);\n}\n\nvec3 pModDodecahedron(inout vec3 p) {\n\tpModIcosahedron(p, 0);\n\tfaceDodecahedron(p);\n    return p;\n}\n\n\nfloat spikeModel(vec3 p) {\n    faceDodecahedron(p);\n\tpR(p.zy, PI/2.);\n    return fCone(p, 0.25, 3.);\n}\n\nvec3 faceB(vec3 p) {\n    p = reflect(p, vec3(1,0,0));\n    return p;\n}\n\nvec3 faceC(vec3 p) {\n    p = reflect(p, nc);\n    p = faceB(p);\n    return p;\n}\n\nvec3 icosaFaceB(vec3 p) {\n    p = reflect(p, vec3(0,1,0));\n    return p;\n}\n\n\nfloat spikesModel(vec3 p) {\n    float round = 0.6;\n    \n    pModIcosahedron(p, 0);\n    \n    float spikeA = spikeModel(p);\n    float spikeB = spikeModel(faceB(p));\n    float spikeC = spikeModel(faceC(p));\n\n    return fOpUnionRound(\n        spikeC,\n        fOpUnionRound(\n            spikeA,\n            spikeB,\n            round\n        ),\n        round\n    );\n}\n\nfloat coreModel(vec3 p) {\n    float outer = length(p) - .9;\n    float spikes = spikesModel(p);\n    outer = fOpUnionRound(outer, spikes, 0.4);\n    return outer;\n}\n\nfloat exoSpikeModel(vec3 p) {\n    faceIcosahedron(p);\n    pR(p.zy, PI/2.);\n    p.y -= 1.;\n    return fCone(p, 0.5, 1.);\n}\n\nfloat exoSpikesModel(vec3 p) {\n    pModIcosahedron(p, 0);\n    float spikeA = exoSpikeModel(p);\n    float spikeB = exoSpikeModel(icosaFaceB(p));\n    return fOpUnionRound(spikeA, spikeB, 0.5);\n}\n\nfloat exoHolesModel(vec3 p) {\n    float len = 3.;\n    pModDodecahedron(p);\n    p.z += 1.5;\n    return length(p) - .65;\n}\n\nfloat exoModel(vec3 p) {    \n    float thickness = 0.18;\n    float outer = length(p) - 1.5;\n    float inner = outer + thickness;\n\n    float spikes = exoSpikesModel(p);\n    outer = fOpUnionRound(outer, spikes, 0.3);\n    \n    float shell = max(-inner, outer);\n\n    float holes = exoHolesModel(p);\n    shell = fOpIntersectionRound(-holes, shell, thickness/2.);\n    \n    return shell;\n}\n\nvec3 pRoll(inout vec3 p) {\n    //return p;\n    float s = 5.;\n    float d = 0.01;\n    float a = sin(t * s) * d;\n    float b = cos(t * s) * d;\n    pR(p.xy, a);\n    pR(p.xz, a + b);\n    pR(p.yz, b);\n    return p;\n}\n\nfloat doExo(vec3 p) {\n    //return 1000.;\n\t//return length(p + vec3(0,0,-2)) - 3.;\n\tpRoll(p);\n    //float disp = (sin(length(p) * 5. - t * 8.)) * 0.03;\n    return exoModel(p);\n}\n\nfloat doCore(vec3 p) {\n    // return 1000.;\n\t//return length(p + vec3(0,0,2)) - 3.;\n\tpRoll(p);\n    return coreModel(p);\n}\n\nfloat lerp(float a, float b, float s) {\n\treturn a + (b - a) * s;\n}\n\n\nvec3 envLight(vec3 col, vec3 rayDir, float blur) {\n\tfloat shiny = 0.;\n\tfloat blurry = 0.;\n    \n    //rayDir.x = mod(rayDir.x + t, 1.);\n\n    if (\n        (rayDir.y > abs(rayDir.x) * 3.5)\n        &&\n        (rayDir.y > abs(rayDir.z * 0.))\n    ) {\n        shiny += rayDir.y;\n    }\n    \n\tshiny += max(rayDir.y, 0.);\n    blurry += acos(dot(normalize(vec3(0,-1,0)), normalize(rayDir))) / PI;\n    blurry *= 0.3;\n    blurry += pow(max(rayDir.y, 0.), 2.) * 0.5;\n    return col * lerp(shiny, blurry, blur);\n}\n\n// from https://www.shadertoy.com/view/XljGDz\nvec3 GetEnvColor2(vec3 rayDir, float blur) {\n\t//pR(rayDir.zy, sin(-t * 1.));\n\tpR(rayDir.xz, PI * 0.5);\n    rayDir = normalize(rayDir);\n    vec3 light1 = envLight(vec3(0,1.2,1.4) * .8, rayDir, blur);\n\tpR(rayDir.xy, PI);\n    rayDir = normalize(rayDir);\n    vec3 light2 = envLight(vec3(.15), rayDir, blur);\n\treturn light1 + light2;\n}\n\n\nvec3 doBackground(vec3 rayVec) {\n    //return GetEnvColor2(rayVec, 0.5);\n    return vec3(.13);\n}\n\nvec3 doMaterial(in vec3 p, in vec3 nor, vec3 ref, float blur) {\n    return GetEnvColor2(ref, blur);\n}\n\nvec3 doExoMaterial(vec3 pos, vec3 nor, vec3 ref) {\n    return doMaterial(pos, nor, ref, .0);\n}\n\nvec3 doCoreMaterial(vec3 pos, vec3 nor, vec3 ref) {\n    vec3 mat = doMaterial(pos, nor, ref, 1.);\n    float light = max(3. - length(pos), 0.);\n    \n    float r = 0.2;\n    float stripe = mod(light, r * 2.);\n    if (stripe > r) {\n    \tmat = vec3(length(mat)) * 0.1;\n    }\n\treturn mat;\n}\n\n\n// The MINIMIZED version of https://www.shadertoy.com/view/Xl2XWt\n\n\nconst float MAX_TRACE_DISTANCE = 20.0;           // max trace distance\nconst float INTERSECTION_PRECISION = 0.001;        // precision of the intersection\nconst int NUM_OF_TRACE_STEPS = 100;\n\n\n// checks to see which intersection is closer\n// and makes the y of the vec2 be the proper id\nvec2 opU( vec2 d1, vec2 d2 ){\n    \n\treturn (d1.x<d2.x) ? d1 : d2;\n    \n}\n\n\n//--------------------------------\n// Modelling \n//--------------------------------\nvec2 map( vec3 p ){  \n    \n \tvec2 res = vec2(doExo(p) ,1.); \n    res = opU(res, vec2(doCore(p) ,2.));\n    \n    return res;\n}\n\n\n\nvec2 calcIntersection( in vec3 ro, in vec3 rd ){\n\n    \n    float h =  INTERSECTION_PRECISION*2.0;\n    float t = 0.0;\n\tfloat res = -1.0;\n    float id = -1.;\n    \n    for( int i=0; i< NUM_OF_TRACE_STEPS ; i++ ){\n        \n        if( h < INTERSECTION_PRECISION || t > MAX_TRACE_DISTANCE ) break;\n\t   \tvec2 m = map( ro+rd*t );\n        h = m.x;\n        t += h;\n        id = m.y;\n        \n    }\n\n    if( t < MAX_TRACE_DISTANCE ) res = t;\n    if( t > MAX_TRACE_DISTANCE ) id =-1.0;\n    \n    return vec2( res , id );\n    \n}\n\n\n//----\n// Camera Stuffs\n//----\nmat3 calcLookAtMatrix( in vec3 ro, in vec3 ta, in float roll )\n{\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(sin(roll),cos(roll),0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n    return mat3( uu, vv, ww );\n}\n\nvoid doCamera(out vec3 camPos, out vec3 camTar, in float time, in vec2 mouse) {\n    \n  \tfloat x = .366 + (mouse.x * 0.5);\n    float y = .7 + (mouse.y * 0.33);\n    \n    float an = 10.0 * x + PI / 2.;\n    //an = 10.;\n\n    //float d = 2. + sin(an) * 1.6;\n    float d = 2. + (1. - y) * 10.;\n    camPos = vec3(\n        sin(an),\n        sin(y * PI / 2.),\n        cos(an)\n    ) * d;\n\n    camTar = vec3(0);\n}\n\n\n// Calculates the normal by taking a very small distance,\n// remapping the function, and getting normal for that\nvec3 calcNormal( in vec3 pos ){\n    \n\tvec3 eps = vec3( 0.001, 0.0, 0.0 );\n\tvec3 nor = vec3(\n\t    map(pos+eps.xyy).x - map(pos-eps.xyy).x,\n\t    map(pos+eps.yxy).x - map(pos-eps.yxy).x,\n\t    map(pos+eps.yyx).x - map(pos-eps.yyx).x );\n\treturn normalize(nor);\n}\n\n\n\n\nvec3 render( vec2 res , vec3 ro , vec3 rd ){\n   \n\n  vec3 color = doBackground(rd);\n    \n  if( res.y > -.5 ){\n      \n    vec3 pos = ro + rd * res.x;\n    vec3 norm = calcNormal( pos );\n    vec3 ref = reflect(rd, norm);\n\n      \n    // Exo\n    if( res.y == 1. ){\n\n        color = doExoMaterial(pos, norm, ref);\n    \n    // Core\n    }else if(res.y == 2. ){\n        \n\t\tcolor = doCoreMaterial(pos, norm, ref);\n        \n    }\n        \n        \n  }\n   \n  return color;\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    t = iTime;\n    initIcosahedron();\n    vec2 p = (-iResolution.xy + 2.0*fragCoord.xy)/iResolution.y;\n    vec2 m = iMouse.xy / iResolution.xy;\n\n    vec3 ro = vec3( 0., 0., 2.);\n    vec3 ta = vec3( 0. , 0. , 0. );\n    \n    // camera movement\n    doCamera(ro, ta, iTime, m);\n    \n    // camera matrix\n    mat3 camMat = calcLookAtMatrix( ro, ta, 0.0 );  // 0.0 is the camera roll\n    \n\t// create view ray\n\tvec3 rd = normalize( camMat * vec3(p.xy,2.0) ); // 2.0 is the lens length\n    \n    vec2 res = calcIntersection( ro , rd  );\n\n\t\n    vec3 color = render( res , ro , rd );\n    \n\tfragColor = vec4(color,1.0);\n\n    \n    \n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/ld3Gzs.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "ldcGWl", "name": "2D transition", "author": "nicoptere", "description": "test", "tags": ["2d", "gradient", "transition"], "likes": 0, "viewed": 1528, "date": "1452696719", "time_retrieved": "2024-06-20T18:30:13.544359", "image_code": "\n\nvec2 project( vec2 p, vec2 a, vec2 b ){\n\n    float A = p.x - a.x;\n    float B = p.y - a.y;\n    float C = b.x - a.x;\n    float D = b.y - a.y;\n    float dot = A * C + B * D;\n    float len = C * C + D * D;\n    float t = dot / len;\n    return vec2( a.x + t * C, a.y + t * D );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = ( fragCoord.xy / iResolution.xy );\n    uv.y = 1. - uv.y;\n    \n    \n    vec2 p0 = vec2( abs( cos( iTime * .1 ) ), 0.25 );\n    vec2 p1 = vec2( 0.5,  .75 );\n    p1 = iMouse.xy / iResolution.xy;\n    p1.y = 1. - p1.y;\n    vec2 n = normalize(  vec2( -( p1.y - p0.y ), ( p1.x - p0.x ) ) ) * .15;\n    \n    vec2 c = p0 + (p1 - p0 ) * .5;\n    \n    vec2 a = c + n * sign( p0.x - c.x );\n    vec2 b = c + n * sign( p1.x -  c.x ) ;\n    \n    vec2 pp = project( uv, a, b ) - c;\n    \n    \n    float d = pp.x - uv.x + pp.y - uv.y ;\n    float s = sign( d );\n    pp *= s * pow( d*.95, 2. );\n    \n    float len = length( pp ) / length( c );\n    \n    float t = sin( iTime ) * .5 + .5;\n    //t = iMouse.x / iResolution.x;\n    len = smoothstep( t-.001, t+.001, len );\n    float blue = 0.;\n    if( distance( uv, p0 )<.02 )\n    {\n        pp=vec2(0.,1.);\n        blue = 1.;\n    }\n    if( distance( uv, p1 )<.02 )\n    {\n        pp=vec2(1.,0.);\n        blue = .5;\n    }\n    if( distance( uv, a )<.01 )pp=vec2(0.,1.);\n    if( distance( uv, b )<.01 )pp=vec2(1.,0.);\n    if( distance( uv, c )<.01 )pp=vec2(1.,1.);\n\tfragColor = vec4( vec3(len)+vec3(pp.x, pp.y,blue) , 1.  );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/ldcGWl.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "ldd3Df", "name": "Everyday012 - Undefined", "author": "Makio64", "description": "Everyday012 - Undefined", "tags": ["uv", "voronoid"], "likes": 6, "viewed": 590, "date": "1452609994", "time_retrieved": "2024-06-20T18:30:13.544359", "image_code": "// Everyday012 - Undefined\n// By David Ronai / @Makio64\n\nfloat hash(vec2 p){return fract(21654.65155 * sin(35.51 * p.x + 45.51 * p.y));}\nfloat smoothVoronoi( in vec2 x ){\n    vec2 p = floor( x );\n    vec2  f = fract( x );\n    float res = 0.0;\n    for( int j=-1; j<=1; j++ )\n    for( int i=-1; i<=1; i++ ){\n        vec2 b = vec2( i, j );\n        vec2  r = vec2( b ) - f + hash( p + b );\n        float d = dot( r, r );\n        res += 1.0/pow( d, 16.0 );\n    }\n    return pow( 1.0/res, 1.0/16.0 );\n}\n\nfloat random(vec2 n, float offset ){\n\treturn .5 - fract(sin(dot(n.xy + vec2( offset, 0. ), vec2(12.9898, 78.233)))* 43758.5453);\n}\n\nvec2 circularOut(vec2 t) { return sqrt((2.0 - t) * t);}\n\n//------------------------------------------------------------------ MAIN\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\tuv = abs(uv-.5)+.5;\n\tuv = circularOut(uv)*3.;\n    uv = cos(uv-iTime/10.);\n    float v = smoothVoronoi(uv*6.);\n    vec3 col = vec3(v);\n    col *= vec3(1.,2.,4.);\n\tcol += vec3( .2 * random( uv, .00001 * 1. * iTime ) );\n    float dist = distance(fragCoord.xy / iResolution.xy, vec2(0.5, 0.5));\n\tcol *= smoothstep(0.8, .4 * 0.799, dist * (.8 + .4));\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/ldd3Df.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "lddGDS", "name": "Everyday006 - hangover01", "author": "Makio64", "description": "Everyday006 - hangover01\nYesterday we celebrate the new year with dot by dot inc. team and this morning.. :)\n", "tags": ["reflection", "specular", "capsule", "everyday", "uvplay", "colortrick"], "likes": 3, "viewed": 624, "date": "1452045039", "time_retrieved": "2024-06-20T18:30:14.429451", "image_code": "// Everyday006 - hangover01\n// By David Ronai / @Makio64\n\n//------------------------------------------------------------------ VISUAL QUALITY\n#define POSTPROCESS\n#define RAYMARCHING_STEP 45\n#define RAYMARCHING_JUMP 1.\n//------------------------------------------------------------------ DEBUG\n//#define RENDER_DEPTH\n//#define RENDER_NORMAL\n\nconst float PI = 3.14159265359;\nconst float PI2 = 6.28318530718;\n\nvec3 orbit(float phi, float theta, float radius)\n{\n\treturn vec3(\n\t\tradius * sin( phi ) * cos( theta ),\n\t\tradius * cos( phi ),\n\t\tradius * sin( phi ) * sin( theta )\n\t);\n}\n\n//------------------------------------------------------------------  SIGNED PRIMITIVES\n//http://mercury.sexy/hg_sdf/\n\n#define saturate(x) clamp(x, 0., 1.)\n\nvec3 pMod3(inout vec3 p, vec3 size) {\n\tvec3 c = floor((p + size*0.5)/size);\n\tp = mod(p + size*0.5, size) - size*0.5;\n\treturn c;\n}\n\n// Distance to line segment between <a> and <b>, used for fCapsule() version 2below\nfloat fLineSegment(vec3 p, vec3 a, vec3 b) {\n\tvec3 ab = b - a;\n\tfloat t = saturate(dot(p - a, ab) / dot(ab, ab));\n\treturn length((ab*t + a) - p);\n}\n\n// Capsule version 2: between two end points <a> and <b> with radius r \nfloat fCapsule(vec3 p, vec3 a, vec3 b, float r) {\n\treturn fLineSegment(p, a, b) - r;\n}\nfloat vmax(vec3 v) {return max(max(v.x, v.y), v.z);}\nfloat fBox(vec3 p, vec3 b) {\n\tvec3 d = abs(p) - b;\n\treturn length(max(d, vec3(0))) + vmax(min(d, vec3(0)));\n}\n\nvec3 color;\n\n//------------------------------------------------------------------ MAP\nfloat map( in vec3 pos ) {\n    vec3 q = pos;\n    vec3 o = orbit(sin(iTime)*PI2,cos(iTime)*PI2,8.);\n    pMod3(q, vec3(50.,40.,50.));\n    float d = fCapsule(q,o,-o,5.);\n    float dist = distance(-o,q);\n    float dist2 = distance(o,q);\n    if(dist>dist2){color = vec3(1.,1.1,1.1);}\n    if(dist<=dist2){color = vec3(1.,0.,1.);}\n    return d;\n}\n\n//------------------------------------------------------------------ RAYMARCHING\nfloat castRay( in vec3 ro, in vec3 rd, inout float depth )\n{\n\tfloat t = 15.0;\n\tfloat res;\n\tfor( int i=0; i<RAYMARCHING_STEP; i++ )\n\t{\n\t\tvec3 pos = ro+rd*t;\n\t\tres = map( pos );\n\t\tif( res < 0.01 || t > 150. ) break;\n\t\tt += res*RAYMARCHING_JUMP;\n\t\tdepth += 1./float(RAYMARCHING_STEP);\n\t}\n\treturn t;\n}\n\nvec3 calcNormal(vec3 p) {\n\tfloat eps = 0.001;\n\tconst vec3 v1 = vec3( 1.0,-1.0,-1.0);\n\tconst vec3 v2 = vec3(-1.0,-1.0, 1.0);\n\tconst vec3 v3 = vec3(-1.0, 1.0,-1.0);\n\tconst vec3 v4 = vec3( 1.0, 1.0, 1.0);\n\treturn normalize( v1 * map( p + v1*eps ) +\n\t\t\t\t\t  v2 * map( p + v2*eps ) +\n\t\t\t\t\t  v3 * map( p + v3*eps ) +\n\t\t\t\t\t  v4 * map( p + v4*eps ) );\n}\n\n//------------------------------------------------------------------ POSTEFFECTS\n\n#ifdef POSTPROCESS\nvec3 postEffects( in vec3 col, in vec2 uv, in float time )\n{\n\t// vigneting\n\tcol *= 0.4+0.6*pow( 16.0*uv.x*uv.y*(1.0-uv.x)*(1.0-uv.y), 0.8 );\n\treturn col;\n}\n#endif\n\nvec3 addLight(in vec3 lpos, inout vec3 col, in vec3 pos, in vec3 nor, in vec3 rd, in float thi){\n\tvec3 ldir = normalize(lpos-pos);\n\tfloat latt = pow( length(lpos-pos)*.03, .5 );\n    float trans =  pow( clamp( max(0.,dot(-rd, -ldir+nor)), 0., 1.), 1.) + 1.;\n\tcol = vec3(.2,.1,.1) * (max(dot(nor,ldir),0.) ) / latt;\n\tcol += vec3(.3,.3,.1) * (trans/latt)*thi;\n    return col;\n   \n}\n\nvec3 render( in vec3 ro, in vec3 rd, in vec2 uv )\n{\n\tfloat depth = 0.;\n\tfloat t = castRay(ro,rd,depth);\n\n\t#ifdef RENDER_DEPTH\n\treturn vec3(depth/10.,depth/5.,depth);\n\t#endif\n\n\tvec3 pos = ro + t * rd;\n\tvec3 nor = calcNormal(pos);\n\n\t#ifdef RENDER_NORMAL\n\treturn nor;\n\t#endif\n\n    // lighitng        \n    vec3 lig = vec3(-0.6, 0.7, -0.5);\n    vec3 ref = reflect( rd, nor );\n    float fre = pow( clamp(1.0+dot(nor,rd),0.0,1.0), 2.0 );\n    float specular = pow(clamp( dot( ref, lig ), 0.0, 1.0 ),16.0);\n\n\tvec3 bg = vec3(sin(uv.x),cos(uv.y),1.+abs(sin(iTime))*.5+.5);\t\n    vec3 col = bg;\n    //return col;\n    if(t<150.){\n        col /= 3.;\n    \tcol += max(0.,dot(nor,lig))*color;\n        col += specular*.2; \n        col += fre*.2;\n    }\n    col = max(vec3(.05),col);\n\tcol += depth*vec3(1.,1.,1.)*.2;\n    col = mix( col, bg, 1.0-exp( -0.000001*t*t*t ));\n\treturn col;\n}\n\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr )\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n\treturn mat3( cu, cv, cw );\n}\n\n\n//------------------------------------------------------------------ MAIN\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    uv.y+=sin(iTime*5.+uv.x*25.)*mod(uv.x+iTime/3.,.5)*.15+.1;\n    uv.x+=cos(iTime/2.+uv.y*2.)*.1+.1;\n    uv/=1.3;\n    vec2 p = -1. + 2. * uv;\n    p.x *= iResolution.x / iResolution.y;\n    \n    //Camera\n\tfloat radius = 50.;\n\tvec3 ro = orbit(PI/2.-.4,PI/2.,radius) + vec3(0.,0.,-iTime*50.);\n\tvec3 ta  = vec3(0.);\n\tmat3 ca = setCamera( ro, ta, 0. );\n\tvec3 rd = ca * normalize( vec3(p.xy,1.) );\n\n\t// Raymarching\n\tvec3 color = render( ro, rd, uv );\n\t#ifdef POSTPROCESS\n\tcolor = postEffects( color, fragCoord.xy / iResolution.xy, iTime );\n\t#endif\n\tfragColor = vec4(color,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/lddGDS.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "lddGWl", "name": "Kindergarten Fluid Simulation", "author": "s23b", "description": "the code is a mess, sorry. I'm on a deadline...", "tags": ["2d", "sea", "cartoon"], "likes": 24, "viewed": 1580, "date": "1452808449", "time_retrieved": "2024-06-20T18:30:14.429451", "image_code": "vec4 makeWave(vec2 uv, vec2 o, vec2 s, vec2 v, vec4 c1, vec4 c2, vec4 ch)\n{\n    uv *= s;\n    uv += o;\n    float f = sin(uv.x+iTime * v.x) - uv.y - sin(iTime*v.y);\n    vec4 c = vec4(0.);\n    if (f > 10.)\n    {\n        c = c2;\n    }\n    else if (f > .0)\n    {\n        c = mix(c1, c2, f / 10.);\n    }\n    else if (f > -.2*s.y / 10.)\n    {\n        c = ch;\n    }\n\treturn c;\n}\n\nvec4 blend(vec4 c1, vec4 c2)\n{\n    return vec4(mix(c1.rgb, c2.rgb, c2.a), max(c1.a, c2.a)); \n}\n\nfloat hash(float n)\n{\n    return fract(sin(n) * 123.456);\n}\n\nvec4 sun(vec2 uv, vec4 c1, vec4 c2, vec4 ch)\n{\n    vec4 c = vec4(0.);\n    float f = length(uv) * 2. -  sin(atan(uv.x, uv.y) / cos(.0) * 10. + iTime * 10.)/ 50.;\n    if (f < 1.05 && f >= 1.)\n    {\n        c = ch;\n    }\n    else if (f < 1.)\n    {\n        c = mix(c1, c2, f);\n    }\n\treturn c;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy / .5 - 1.;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    vec4 bg = mix(vec4(.5, .6, .7, 1.), vec4(.2, .6, .9, 1.), clamp(uv.y, 0., 1.));\n    \n    bg = blend (bg, sun(uv, vec4(1., .4, .1, 1.), vec4(1., .7, .2, 1.), vec4(1.)));\n    \n    for (float i = .1; i <= 1.0; i += .1)\n    {\n    \tbg = blend(bg, makeWave(\n            uv,\n            vec2(hash(i) * 10., i * 10.),\n            vec2(10. * (1.25 - i), 10. / i),\n            vec2( i*5. + hash(i), i*3.),\n            vec4(.1, .3, .5, .5), vec4(.4, .8, 1., .6), vec4(1.)));\n    }\n    \n    fragColor = bg;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/lddGWl.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "ldG3Rm", "name": "Dekatest", "author": "deka0106", "description": "first shader", "tags": ["test"], "likes": 4, "viewed": 170, "date": "1453711371", "time_retrieved": "2024-06-20T18:30:14.429451", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    \n    uv = uv - 0.5;\n    uv.y *= iResolution.y / iResolution.x;\n    \n    float pi = 3.1415926;\n    \n    fragColor = vec4(0, 0, 0, 0);\n    for (int i = 0; i < 63; i++){\n        float t = iTime / 5.0 + float(i) * 0.1;\n    \tvec2 p = 0.2 * vec2(cos(t), sin(t)) * (sin(t * 8.0) * 0.5 + 0.5);\n\t\tfragColor += vec4(0.002 / length(uv - p) \n                          * vec3(sin(t) * 0.5 + 0.5,\n                                 sin(t + pi * 2.0 / 3.0),\n                                 sin(t - pi * 2.0 / 3.0)),1.0);\n\t}\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/ldG3Rm.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "ldG3Wh", "name": "map to map collisions", "author": "eiffie", "description": "How to check if 2 distance estimates collide.", "tags": ["collision", "detection"], "likes": 5, "viewed": 562, "date": "1454189277", "time_retrieved": "2024-06-20T18:30:14.774785", "image_code": "//map to map collisions by eiffie\n//It is easy to check collisions between a sphere and a distance estimated object\n//but what about 2 distance estimates. It is pretty easy too if you don't need \n//great accuracy.\nvec2 rotate(vec2 v, float angle) {return cos(angle)*v+sin(angle)*vec2(v.y,-v.x);}\n\nfloat tym;\nvec2 offset;\nfloat DE(vec2 p){\n\tp=rotate(p-offset,tym);\n\treturn min(length(p)-0.2,length(max(abs(p)-vec2(0.5,0.05),0.0)));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n\tvec2 uv=2.0*(fragCoord.xy/iResolution.xy-0.5);\n\tfloat y=0.1+0.25*sin(iTime*1.4);\n\tvec2 p=vec2(-0.35,-0.35);\n\tfloat dp=length(p-uv)-0.01;\n\ttym=iTime;\n\toffset=vec2(0.3,y);\n\tfloat d1=DE(uv);\n\ttym=iTime*1.3;\n\toffset=vec2(-0.35,-0.35);\n\tfloat dp2=length(p-uv)-0.01;\n\td1=min(d1,DE(uv));\n\tvec2 psave=p;\n\t\n\tfor(int i=0;i<4;i++){// i changed it to ping-ponging between the surfaces\n\t\ttym=iTime; // should be more robust\n\t\toffset=vec2(0.3,y);\n\t\tfloat d=DE(p);\n\t\tvec2 e=vec2(d,0.0);\n\t\tvec2 N=normalize(vec2(DE(p-e)-DE(p+e),DE(p-e.yx)-DE(p+e.yx)))*d;\n\t\tif(N==N)p+=N;\n\t\tdp=min(dp,length(p-uv)-0.01);\n\t\t\n\t\tpsave=p;\n\t\t\n\t\ttym=iTime*1.3;//switch the the 2nd distance estimate and do the same\n\t\toffset=vec2(-0.35,-0.35);\n\t\td=DE(p);\n\t\te=vec2(d,0.0);\n\t\tN=normalize(vec2(DE(p-e)-DE(p+e),DE(p-e.yx)-DE(p+e.yx)))*d;\n\t\tif(N==N)p+=N;\n\t\tdp2=min(dp2,length(p-uv)-0.01);\n\t}\n\t\n\t\n\tvec3 col=vec3(smoothstep(0.0,0.01,d1));\n\tcol=mix(vec3(0.0,1.0,0.0),col,smoothstep(0.0,0.01,dp));\n\tcol=mix(vec3(0.0,0.0,1.0),col,smoothstep(0.0,0.01,dp2));\n\tcol=mix(vec3(1.0,0.0,0.0),col,smoothstep(0.0,0.01,length(p-uv)+length(p-psave)-0.03));\n\tfragColor=vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/ldG3Wh.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "ldGGzR", "name": "LocalThickness", "author": "ZigguratVertigo", "description": "This shadertoy describes how one can compute \"Local Thickness\", the surface thickness approximation term described in [1] and [2]. Approximates how \"thick\" or \"thin\" various parts of an object are.", "tags": ["sss", "scattering", "translucency", "subsurface", "thickness"], "likes": 21, "viewed": 1446, "date": "1453081803", "time_retrieved": "2024-06-20T18:30:16.102284", "image_code": "//\n// Local Thickness\n//\n// This shadertoy describes how one can compute \"Local Thickness\", the surface thickness approximation term described\n// in [1] and [2]. \n//\n// The general idea behind the technique is to use a computation similar to ambient occlusion (AO) to approximate how \n// \"thick\" or \"thin\" various parts of an object are. The trick behind this technique is to invert the surface normal \n// and calculate ambient occlusion from inside the surface. That's it ;)\n//\n// This gives a rough approximation of how occluded part of an object is relative to its surroundings, therefore giving \n// a sense of thickness.  While this approximation is really not at all accurate - real thickness being relative to an entry \n// and exit point - the overall result still gives a good sense of thin vs thick. Also, it's possible to remap the value \n// to something that makes more sense to your needs. For example, if you need a big difference between thick and thin\n// objects, you can play with the contrasts. It's also recommended to have a base grey value for thickness, to show better\n// transitions, and not start from pure black. Otherwise, the transition might be too harsh.\n//\n// I've created this shadertoy because a few people have implemented an interpretation of local thickness, and I didn't find\n// it complete. Then again, this wouldn't have been possible without the great many shadertoys I've used as reference, \n// which you can find below. I also have other ideas on how to improve this, and will keep updating it. :)\n//\n// Just like for any AO calculation, results will vary depending on the scene, and distance-based tolerance factors. \n//\n// A few parameters below are tweakable, THICKNESS_MAX_DISTANCE will give you the most control. Also, you can get away\n// with way less samples, especially if your surfaces are not super smooth. \n//\n// References:\n//\t[1] GDC 2011 \"Approximating Translucency for a Fast, Cheap and Convincing Subsurface Scattering Look\"\n//\t\thttp://colinbarrebrisebois.com/2011/03/07/gdc-2011-approximating-translucency-for-a-fast-cheap-and-convincing-subsurface-scattering-look/\n//\n//  [2] [Barre-Brisebois11] Barre-Brisebois, Colin and Bouchard, Marc. \"Real-Time Approximation of Light Transport in \n//      Translucent Homogenous Media\", GPU Pro 2, Wolfgang Engel, Ed. Charles River Media, 2011.\n//\n//  [3] Translucency in Frostbite 2 engine: https://www.youtube.com/watch?v=t7Qw05BUuss\n//\n// Shadertoy References:\n//  [4] Raymarching - Primitives, by IQ\n//\t    https://www.shadertoy.com/view/Xds3zN\n//  \n//  [5] Alien Coccoons, by XT95\n//      https://www.shadertoy.com/view/MsdGz2\n//  \n//  [6] Shadeaday 6 / 4 / 2015 - a bunch of rods, by cabbibo\n//      https://www.shadertoy.com/view/4tS3Dt\n// \n\n// Constants\nconst float PI = 3.14159265359;\nconst float MAX_TRACE_DISTANCE\t   = 25.0;\nconst int   NUM_TRACE_STEPS \t   = 50;\nconst float INTERSECTION_PRECISION = 0.00001;\nconst float THICKNESS_MAX_DISTANCE = 1.0;\nconst int \tNUM_THICKNESS_SAMPLES  = 64;\nconst float NUM_SAMPLES_INV \t   = 1.0 / float(NUM_THICKNESS_SAMPLES);    \n\n// Function Declarations\nvec2 Scene(vec3 p);\nfloat Hash(float n);\nvec3 RandomSphereDir(vec2 rnd);\nvec3 RandomHemisphereDir(vec3 dir, float i);\n\n//---------------------------------------------------------------------------------------------------------\n// Local Thickness \n//---------------------------------------------------------------------------------------------------------\nfloat CalculateThickness(vec3 p, vec3 n, float maxDist)\n{\n    float thickness = 0.0;\n    \n    for (int i=0; i < NUM_THICKNESS_SAMPLES; i++)\n    {\n        // Randomly sample along the hemisphere inside the surface\n        // To sample inside the surface, flip the normal\n        float l = Hash(float(i)) * maxDist;\n        vec3 rd = normalize(-n + RandomHemisphereDir(-n, l)) * l;\n        \n        // Accumulate\n        thickness += l + Scene(p + rd).x;\n    }\n\t\n    return clamp(thickness * NUM_SAMPLES_INV, 0.0, 1.0);\n}\n\n//---------------------------------------------------------------------------------------------------------\n// SDF Functions\n//---------------------------------------------------------------------------------------------------------\nfloat sdPlane(vec3 p)\n{\n\treturn p.y;\n}\n\nfloat sdCapsule(vec3 p, vec3 a, vec3 b, float r)\n{\n    vec3 pa = p - a, ba = b - a;\n    float h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\n    return length(pa - ba * h) - r;\n}\n\nfloat smin(float a, float b, float k)\n{\n    float res = exp(-k * a) + exp(-k * b);\n    return -log(res) / k;\n}\n\nvec2 opU(vec2 d1, vec2 d2)\n{\n\treturn (d1.x < d2.x) ? d1 : d2;\n}\n\nfloat opBlend(vec2 d1, vec2 d2)\n{\n    return smin(d1.x, d2.x, 8.0);\n}\n\n//---------------------------------------------------------------------------------------------------------\n// Helper Functions\n//---------------------------------------------------------------------------------------------------------\nfloat Hash(float n)\n{\n    return fract(sin(n) * 3538.5453);\n}\n\nvec3 RandomSphereDir(vec2 rnd)\n{\n\tfloat s = rnd.x * PI * 2.0;\n\tfloat t = rnd.y * 2.0 - 1.0;\n\treturn vec3(sin(s), cos(s), t) / sqrt(1.0 + t * t);\n}\n\nvec3 RandomHemisphereDir(vec3 dir, float i)\n{\n\tvec3 v = RandomSphereDir(vec2(Hash(i + 1.0), Hash(i + 2.0)));\n\treturn v * sign(dot(v, dir));\n}\n\nmat3 LookAtMatrix(vec3 ro, vec3 ta, float roll)\n{\n    vec3 ww = normalize(ta - ro);\n    vec3 uu = normalize(cross(ww, vec3(sin(roll), cos(roll), 0.0)));\n    vec3 vv = normalize(cross(uu, ww));\n    return mat3(uu, vv, ww);\n}\n\nvoid Camera(out vec3 camPos, out vec3 camTar, float time, float mouseX)\n{\n    float an = 0.3 + 10.0 * mouseX + PI * sin(time * 0.1);\n\tcamPos = vec3(3.5 * sin(an), 1.0, 3.5 * cos(an));\n    camTar = vec3(0.0, 0.0, 0.0);\n}\n\nfloat Random(vec2 co)\n{\n\treturn fract(sin(dot(co.xy, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\n//--------------------------------\n// Scene Functions \n//--------------------------------\nvec2 Scene(vec3 p)\n{  \n    float time = 195.0 + 7.0 + iTime;\n   \tvec2 res = vec2(sdPlane(p - vec3(0.0, -1.0, 0.0)), 0.0);\n    \n    for (int i = 0; i < 15; i++)\n    {\n        vec3 sp = texture(iChannel0 , vec2(float(i) / 15.0, 0.2 + sin(time * .00001) * 0.1)).xyz;\n        vec3 ep = texture(iChannel0 , vec2(float(i) / 15.0, 0.4 + sin(time * .00001) * 0.1)).xyz;\n\n        sp.x = Random(sp.xy);\n        sp.y = Random(sp.zy);\n        sp.z = Random(sp.xz);\n        sp = sp * 2.0 - 1.0;\n       \n        ep.x = Random(ep.xy);\n        ep.y = Random(ep.zy);\n        ep.z = Random(ep.xz);\n\t\t//ep = ep * 2.0 - 1.0; // slightly slanted, for style ;)\n\n    \tres.x = opBlend(res, vec2(sdCapsule(p, sp * 1.5, ep * 1.5, 0.20),  float( i ) + 1.));\n    }\n\n   \treturn res;\n}\n \nvec2 Raymarch(vec3 ro, vec3 rd)\n{\n    float h =  INTERSECTION_PRECISION*2.0;\n    float t = 0.0;\n\tfloat res = -1.0;\n    float id = -1.0;\n    \n    for (int i=0; i< NUM_TRACE_STEPS ; i++)\n    {\n        if (h < INTERSECTION_PRECISION || t > MAX_TRACE_DISTANCE)\n            break;\n\t   \t\n        vec2 m = Scene(ro + rd * t);\n        h = m.x;\n        t += h;\n        id = m.y;\n        \n    }\n\n    if (t < MAX_TRACE_DISTANCE) res = t;\n    if (t > MAX_TRACE_DISTANCE) id =-1.0;\n    \n    return vec2(res, id);\n    \n}\n\nvec3 Normal(vec3 p)\n{\n    vec3 eps = vec3(0.001, 0.0, 0.0);\n\tvec3 n \t = vec3(Scene(p + eps.xyy).x - Scene(p - eps.xyy).x,\n\t    \t\t\tScene(p + eps.yxy).x - Scene(p - eps.yxy).x,\n\t    \t\t\tScene(p + eps.yyx).x - Scene(p - eps.yyx).x);\n\t\n    return normalize(n);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 p = (-iResolution.xy + 2.0 * fragCoord.xy) / iResolution.y;\n    vec2 m = 0.5 + iMouse.xy / iResolution.xy;\n    \n    // camera movement\n    vec3 ro, ta;\n    Camera(ro, ta, iTime, m.x);\n\n    mat3 camMat = LookAtMatrix(ro, ta, 0.0);\n\tvec3 rd = normalize(camMat * vec3(p.xy, 1.3));\n    vec2 res = Raymarch(ro, rd);\n    \n    vec3 col = vec3(0.0);\n        \n    if (res.y > -0.5)\n    {\n    \tvec3 p = ro + rd * res.x;\n        col = vec3(CalculateThickness(p, Normal(p), THICKNESS_MAX_DISTANCE));\n        \n        // For visualization purposes\n        // at the end of the day, you can remap this based on your needs\n        col = pow(col*col*col*7.0+0.0125, vec3(1.0 / 2.2));        \n    }\n    \n    fragColor = vec4(col, 1.0);\n}", "image_inputs": [{"id": "Xsf3zn", "previewfilepath": "/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/ldGGzR.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "ldK3zD", "name": "distance meter", "author": "cupe", "description": "scale-invariant distance meter for SDFs. paint this onto a plane to sweep through your geometry.\nblack isolines are drawn at all powers of 10", "tags": ["distancefield", "sdf", "tool", "debugging"], "likes": 49, "viewed": 1987, "date": "1453580231", "time_retrieved": "2024-06-20T18:30:16.932578", "image_code": "//\n// scale-invariante distance meter\n//\n// be less confused by your distances!\n//\n// (as seen in the screenshots on http://mercury.sexy/hg_sdf/)\n//\n// tries to paint a plane in useful colors. outputs HDR colors, so can easily\n// be integrated into your existing rendering without looking bad. \n//\n//\n\n// constants and stuff\n\n#define PI acos(-1.)\n#define INFINITY pow(2.,8.)\n\nfloat vmax(vec3 v) {\n\treturn max(max(v.x, v.y), v.z);\n}\n\nfloat fBox(vec3 p, vec3 b) {\n\tvec3 d = abs(p) - b;\n\treturn length(max(d, vec3(0.))) + vmax(min(d, vec3(0.)));\n}\n\nvoid pR(inout vec2 p, float a) {\n\tp = cos(a)*p + sin(a)*vec2(p.y, -p.x);\n}\n\n\n// the actual SDF:\nfloat f (vec3 p) {\n    p.z += 1.0;\n    float sphere = length(p) - 1.;   \n    float box = fBox(p - vec3(1.0,0.0,1.0), vec3(1.0,1.0,1.0));\n    \n    return max(-sphere,box);\n}\n\n// tone mapping stolen from zavie's shader\nvec3 Uncharted2ToneMapping(vec3 color) {\n\tfloat A = 0.15;\n\tfloat B = 0.50;\n\tfloat C = 0.10;\n\tfloat D = 0.20;\n\tfloat E = 0.02;\n\tfloat F = 0.30;\n\tfloat W = 11.2;\n\tfloat exposure = 2.;\n\tcolor *= exposure;\n\tcolor = ((color * (A * color + C * B) + D * E) / (color * (A * color + B) + D * F)) - E / F;\n\tfloat white = ((W * (A * W + C * B) + D * E) / (W * (A * W + B) + D * F)) - E / F;\n\tcolor /= white;\n\treturn color;\n}\n\n//\n// interesting part starts here\n//\n// the meter uses the \"fusion\" gradient, which goes from dark magenta (0) to white (1)\n// (often seen in heatmaps in papers etc)\n//\n\nvec3 fusion(float x) {\n\tfloat t = clamp(x,0.0,1.0);\n\treturn clamp(vec3(sqrt(t), t*t*t, max(sin(PI*1.75*t), pow(t, 12.0))), 0.0, 1.0);\n}\n\n// HDR version\nvec3 fusionHDR(float x) {\n\tfloat t = clamp(x,0.0,1.0);\n\treturn fusion(sqrt(t))*(0.5+2.*t);\n}\n\n\n//\n// distance meter function. needs a bit more than just the distance\n// to estimate the zoom level that it paints at.\n//\n// if you have real opengl, you can additionally use derivatives (dFdx, dFdy)\n// to detect discontinuities, i had to strip that for webgl\n//\n// visualizing the magnitude of the gradient is also useful\n//\n\nvec3 distanceMeter(float dist, float rayLength, vec3 rayDir, float camHeight) {\n    float idealGridDistance = 20.0/rayLength*pow(abs(rayDir.y),0.8);\n    float nearestBase = floor(log(idealGridDistance)/log(10.));\n    float relativeDist = abs(dist/camHeight);\n    \n    float largerDistance = pow(10.0,nearestBase+1.);\n    float smallerDistance = pow(10.0,nearestBase);\n\n   \n    vec3 col = fusionHDR(log(1.+relativeDist));\n    col = max(vec3(0.),col);\n    if (sign(dist) < 0.) {\n        col = col.grb*3.;\n    }\n\n    float l0 = (pow(0.5+0.5*cos(dist*PI*2.*smallerDistance),10.0));\n    float l1 = (pow(0.5+0.5*cos(dist*PI*2.*largerDistance),10.0));\n    \n    float x = fract(log(idealGridDistance)/log(10.));\n    l0 = mix(l0,0.,smoothstep(0.5,1.0,x));\n    l1 = mix(0.,l1,smoothstep(0.0,0.5,x));\n\n    col.rgb *= 0.1+0.9*(1.-l0)*(1.-l1);\n    return col;\n}\n\n\n//\n// interesting part ends here\n//\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 screenCoord = (-iResolution.xy + 2.0*fragCoord.xy)/iResolution.y;\n    vec2 m = iMouse.xy/iResolution.xy;\n\n    float camDolly = iMouse.z>0.?m.y:(0.5+0.5*sin(iTime*0.5));\n    float camRotation = iMouse.z>0.?m.x*-5.:(0.2*iTime);\n    vec3 cam_pos = vec3(0.0,1.0,1.4) * pow(10., camDolly*4. - 2.0);\n    vec3 cam_dir = normalize(vec3(0.0,-0.8,-1.0));\n    vec3 cam_up = normalize(vec3(0.0,1.0,-0.8));\n    \n    pR(cam_up.xz,camRotation);\n    pR(cam_dir.xz,camRotation);\n    pR(cam_pos.xz,camRotation);\n    \n    float cam_fov = 45.0;\n    vec3 u = cross(cam_dir, cam_up);\n\tvec3 v = cam_up;\n\tvec3 w = -cam_dir;\n\n\tvec3 o = cam_pos;\n\t\n\tvec3 d = vec3(screenCoord, -1.0/tan(cam_fov*PI/360.0));\n    d = normalize(((mat3(u, v, w)) * d));\n    \n    float t = INFINITY;\n    if (d.y < 0.) {\n\t\tt = (o.y)/-d.y;\n\t}\n   \n    vec3 p = d*t + o;\n    \n    float dist = f(p);\n    \n    vec3 col = distanceMeter(dist, t, d, cam_pos.y);\n    \n    col = Uncharted2ToneMapping(col);\n    \n    fragColor = vec4(pow(col, vec3(1./2.2)), 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/ldK3zD.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "ldKGzR", "name": "ArkTestShader1", "author": "Ark", "description": "test", "tags": ["test"], "likes": 9, "viewed": 319, "date": "1453096346", "time_retrieved": "2024-06-20T18:30:16.932578", "image_code": "const int N = 360;\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\tvec2 uv = (fragCoord.xy*2.0-iResolution.xy)/min(iResolution.x, iResolution.y);\n    vec3 destColor = vec3(0.0);\n    float t = sin(iTime)/5.0;\n    for(int i=0; i<N; i++) {\n        vec2 v = vec2(cos(radians(t+float(i))), sin(radians(t+float(i))))*sin(((1.0-cos(radians(iTime*10.0)))*float(i))/10.0);\n        v *= 0.8;\n        destColor += 0.0015/length(uv-v);\n    }\n    destColor -= sin(vec3(-1.0,0,1.0)*3.141592*2.0/3.0+iTime*2.0)*0.5+1.0;\n    fragColor = vec4(destColor, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/ldKGzR.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "ldt3zl", "name": "3^3 composition", "author": "spolsh", "description": "Raymarching exercise with distance fields. Recreated my drawing from art class: http://imgur.com/EYlx5WB", "tags": ["3d", "raymarching", "sdf", "primitives", "klos"], "likes": 17, "viewed": 857, "date": "1451942620", "time_retrieved": "2024-06-20T18:30:18.326499", "image_code": "// Created by michal klos - spolsh/2016\n\n// based on:\n// Created by inigo quilez - iq/2013\n// https://www.shadertoy.com/view/Xds3zN\n\n\n#define PI 3.14\n#define TIME ( 15.0 + iTime )\n\n\nfloat hash( float n ) {\n\treturn fract(sin(n)*43758.5453);\n}\n\nfloat sdPlane( vec3 p )\n{\n\treturn p.y;\n}\n\nfloat sdSphere( vec3 p, float s )\n{\n    return length(p)-s;\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\nfloat udRoundBox( vec3 p, vec3 b, float r )\n{\n  return length(max(abs(p)-b,0.0))-r;\n}\n\n//----------------------------------------------------------------------\n\nfloat opS( float d1, float d2 )\n{\n    return max(-d2,d1);\n}\n\nvec2 opU( vec2 d1, vec2 d2 )\n{\n\treturn (d1.x<d2.x) ? d1 : d2;\n}\n\nvec3 opRep( vec3 p, vec3 c )\n{\n    return mod(p,c)-0.5*c;\n}\n\nvec3 opTwist( vec3 p )\n{\n    float  c = cos(10.0*p.y+10.0);\n    float  s = sin(10.0*p.y+10.0);\n    mat2   m = mat2(c,-s,s,c);\n    return vec3(m*p.xz,p.y);\n}\n\n//----------------------------------------------------------------------\n\n// rotation matrix\nmat3 rotX(float a)\n{\n\tfloat c=cos(a);\n\tfloat s=sin(a);\n\treturn mat3(1.0,0.0,0.0,0.0,c,-s,0.0,s,c);\n}\n\nmat3 rotY(float a)\n{\n\tfloat c=cos(a);\n\tfloat s=sin(a);\n\treturn mat3(c,0.0,s,0.0,1.0,0.0,-s,0.0,c);\n}\n\nmat3 rotZ(float a)\n{\n\tfloat c=cos(a);\n\tfloat s=sin(a);\n\treturn mat3(c,-s,0.0,s,c,0.0,0.0,0.0,1.0);\n}\n\n\n// rotate the box and \nfloat sdQuaterBox( vec3 p, vec3 b, vec2 sign )\n{\n    b.xy *= sqrt(2.0);\n\tfloat boxBase = udRoundBox( p * rotZ( 0.25 * 3.14 ), b, 0.01 );\n        \n    return max( sign.y * p.y, max( sign.x * p.x, boxBase ) );\n}\n\nfloat sdHalfBox( vec3 p, vec3 b, float cutRot )\n{    \n\tfloat boxBase = udRoundBox( p, b, 0.01 );\n    vec3 cp = p * rotZ( cutRot );\n        \n    return max( cp.x, boxBase );\n}\n\n\nvec2 map( in vec3 pos )\n{\n\tfloat bevel = 0.01;\n    float side = 0.25;\n    \n    vec2 res1 =      vec2( sdPlane(       pos), 1.0 );\n    \n    vec2 res2 = vec2(       udRoundBox(   pos-vec3( 0.0, 0.25, 0.0), vec3(side), bevel ), 3.0 );\n    res2 = opU( res2, vec2( udRoundBox(   pos-vec3( 0.0, 0.75, 0.0), vec3(side), bevel ), 3.0 ) );\n    res2 = opU( res2, vec2( udRoundBox(   pos-vec3( 0.0, 1.25, 0.0), vec3(side), bevel ), 3.0 ) );\n\n\tres2 = opU( res2, vec2( udRoundBox(   pos-vec3( 0.0, 1.25, 0.5), vec3(side), bevel ), 3.0 ) );        \n\n    res2 = opU( res2, vec2( udRoundBox(   pos-vec3( 0.0, 0.25, 1.0), vec3(side), bevel ), 3.0 ) );\n    res2 = opU( res2, vec2( udRoundBox(   pos-vec3( 0.0, 0.75, 1.0), vec3(side), bevel ), 3.0 ) );\n    res2 = opU( res2, vec2( udRoundBox(   pos-vec3( 0.0, 1.25, 1.0), vec3(side), bevel ), 3.0 ) );        \n\n\tres2 = opU( res2, vec2( udRoundBox(   pos-vec3( -0.5, 0.25, 0.0), vec3(side), bevel ), 3.0 ) );\n\tres2 = opU( res2, vec2( sdHalfBox(    pos-vec3( -0.5, 1.25, 0.0), vec3(side), 0.75 * PI ), 3.0 ) );\n   \n    res2 = opU( res2, vec2( sdQuaterBox(  pos-vec3( -0.5 + 0.25, 0.0, 1.0), vec3(0.25), vec2( 1.0, -1.0 ) ), 3.0 ) );        \n\n     \n    res2 = opU( res2, vec2( sdHalfBox(    pos-vec3( -1.0, 0.25, 0.0), vec3(0.25), 0.75 * PI ), 3.0 ) );\n    res2 = opU( res2, vec2( udRoundBox(   pos-vec3( -1.0, 0.75, 0.0), vec3(side), bevel ), 3.0 ) );       \n    \n\tres2 = opU( res2, vec2( sdHalfBox(    pos-vec3( -1.0, 0.25, 0.5), vec3(0.25), 0.25 * PI ), 3.0 ) );\n    res2 = opU( res2, vec2( udRoundBox(   pos-vec3( -1.0, 0.75, 0.5), vec3(side), bevel ), 3.0 ) );\n\n   \tres2 = opU( res2, vec2( sdSphere(     pos-vec3( -1.0, 0.25, 1.0), 0.25 ), 46.9 ) );                    \n    \n    return opU( res1, res2 );\n}\n\nvec2 castRay( in vec3 ro, in vec3 rd )\n{\n    float tmin = 1.0;\n    float tmax = 20.0;\n    \n#if 0\n    float tp1 = (0.0-ro.y)/rd.y; if( tp1>0.0 ) tmax = min( tmax, tp1 );\n    float tp2 = (1.6-ro.y)/rd.y; if( tp2>0.0 ) { if( ro.y>1.6 ) tmin = max( tmin, tp2 );\n                                                 else           tmax = min( tmax, tp2 ); }\n#endif\n    \n\tfloat precis = 0.0005;\n    float t = tmin;\n    float m = -1.0;\n    for( int i=0; i<75; i++ )\n    {\n\t    vec2 res = map( ro+rd*t );\n        if( res.x<precis || t>tmax ) break;\n        t += res.x;\n\t    m = res.y;\n    }\n\n    if( t>tmax ) m=-1.0;\n    return vec2( t, m );\n}\n\n\nfloat softshadow( in vec3 ro, in vec3 rd, in float mint, in float tmax )\n{\n\tfloat res = 1.0;\n    float t = mint;\n    for( int i=0; i<16; i++ )\n    {\n\t\tfloat h = map( ro + rd*t ).x;\n        res = min( res, 8.0*h/t );\n        t += clamp( h, 0.02, 0.10 );\n        if( h<0.001 || t>tmax ) break;\n    }\n    return clamp( res, 0.0, 1.0 );\n\n}\n\nvec3 calcNormal( in vec3 pos )\n{\n\tvec3 eps = vec3( 0.001, 0.0, 0.0 );\n\tvec3 nor = vec3(\n\t    map(pos+eps.xyy).x - map(pos-eps.xyy).x,\n\t    map(pos+eps.yxy).x - map(pos-eps.yxy).x,\n\t    map(pos+eps.yyx).x - map(pos-eps.yyx).x );\n\treturn normalize(nor);\n}\n\nfloat calcAO( in vec3 pos, in vec3 nor )\n{\n\tfloat occ = 0.0;\n    float sca = 1.0;\n    for( int i=0; i<5; i++ )\n    {\n        float hr = 0.01 + 0.12*float(i)/4.0;\n        vec3 aopos =  nor * hr + pos;\n        float dd = map( aopos ).x;\n        occ += -(dd-hr)*sca;\n        sca *= 0.95;\n    }\n    return clamp( 1.0 - 3.0*occ, 0.0, 1.0 );    \n}\n\n\n\n\nvec3 render( in vec3 ro, in vec3 rd )\n{ \n    vec3 col = vec3(0.7, 0.9, 1.0) + rd.y*0.8;\n    vec2 res = castRay(ro,rd);\n    float t = res.x;\n\tfloat m = res.y;\n    if( m>-0.5 )\n    {\n        vec3 pos = ro + t*rd;\n        vec3 nor = calcNormal( pos );\n        vec3 ref = reflect( rd, nor );\n        \n        // material        \n\t\tcol = 0.45 + 0.3*sin( vec3(0.05,0.08,0.10)*(m-1.0) );\n\t\t\n        if( m<1.5 )\n        {\n            float f = mod( floor( 2.0 * ( pos.z + 0.25 ) ) + floor( 2.0 * ( pos.x + 0.25 ) ), 2.0);\n            col = 0.4 + 0.1*f*vec3(1.0);\n        } else {\n            // float f = length( floor( 2.0 * ( pos + vec3( 0.25, 0.5, 0.25 ) ) ) );\n            // col = 0.1 + 0.1 * hash( f + fract( pos ).x ) + 0.1*f*vec3(1.0);\n        }\n\n        // lighitng        \n\t\tvec3  lig = normalize( vec3(-0.6, 0.7, -0.5) );\n\t\tfloat dif = clamp( dot( nor, lig ), 0.0, 1.0 );\n\t\tfloat dom = smoothstep( -0.1, 0.1, ref.y );        \n\t\tfloat amb = clamp( 0.5+0.5*nor.y, 0.0, 1.0 );\n        \n        float occ = calcAO( pos, nor );\n        float bac = clamp( dot( nor, normalize(vec3(-lig.x,0.0,-lig.z))), 0.0, 1.0 )*clamp( 1.0-pos.y,0.0,1.0);        \n        float fre = pow( clamp(1.0+dot(nor,rd),0.0,1.0), 2.0 );\n\t\tfloat spe = pow(clamp( dot( ref, lig ), 0.0, 1.0 ),16.0);\n        \n        dif *= softshadow( pos, lig, 0.02, 2.5 );\n        dom *= softshadow( pos, ref, 0.02, 2.5 );\n\t\n\t\tvec3 lin = vec3(0.0);\n        lin += 1.20*dif*vec3(1.00,0.85,0.55);\n\t\tlin += 1.20*spe*vec3(1.00,0.85,0.55)*dif;\n        lin += 0.20*amb*vec3(0.50,0.70,1.00)*occ;\n        lin += 0.30*dom*vec3(0.50,0.70,1.00)*occ;\n        lin += 0.30*bac*vec3(0.25,0.25,0.25)*occ;\n        lin += 0.40*fre*vec3(1.00,1.00,1.00)*occ;\n\t\tcol = col*lin;\n\n    \tcol = mix( col, vec3(0.8,0.9,1.0), 1.0-exp( -0.002*t*t ) );\t\t\n\n    }\n\n\treturn vec3( clamp(col,0.0,1.0) );\n}\n\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr )\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 q = fragCoord.xy/iResolution.xy;\n    vec2 p = -1.0+2.0*q;\n\tp.x *= iResolution.x/iResolution.y;\n    vec2 mo = iMouse.xy/iResolution.xy;\n\t\t \n\t// float time = 15.0 + iTime;\n\n\t// camera\t\n\tvec3 ro = vec3( 3.5*cos(0.1*TIME + 6.0*mo.x), 0.85 + 2.0*mo.y, 3.5*sin(0.1*TIME + 6.0*mo.x) );\n\tvec3 ta = vec3( 0.0, 0.4, 0.0 );\n\t\n\t// camera-to-world transformation\n    mat3 ca = setCamera( ro, ta, 0.0 );\n    \n    // ray direction\n\tvec3 rd = ca * normalize( vec3(p.xy,2.0) );\n\n    // render\t\n    vec3 col = render( ro, rd );\n\n\tcol = pow( col, vec3(0.4545) );\n\n    fragColor=vec4( col, 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/ldt3zl.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "ldtGWB", "name": "Spiral Ring", "author": "gaz", "description": "3d", "tags": ["raymarching", "spiral", "de"], "likes": 6, "viewed": 238, "date": "1452065560", "time_retrieved": "2024-06-20T18:30:18.326499", "image_code": "#define PI\t3.14159265359\n\nmat2 rotate(float a)\n{\n    float s=sin(a),c=cos(a);\n    return mat2(c,s,-s,c);\n}\n\nfloat deQuad(vec2 p) {\n\tp = abs(p);\n\treturn max(p.x, p.y);\n}\n\nfloat deHex(vec2 p) {\n\tp = abs(p);\n\treturn max((2.0/sqrt(3.0))*p.x, (1.0/sqrt(3.0))*p.x + p.y);\n}\n\nfloat deTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\nfloat deQuadTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return deQuad(q)-t.y;\n}\n\nfloat deHexTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return 0.8 * (deHex(q)-t.y);\n}\n\nfloat deSliceTorus(in vec2 p, in vec2 t, in float a)\n{\n    vec3 pos = vec3(p, 0.0).xzy;\n    pos.yz *= rotate(a);\n    return deTorus(pos, t);\n}\n\nfloat deQuadSliceTorus(in vec2 p, in vec2 t, in float a)\n{\n    vec3 pos = vec3(p, 0.0).xzy;\n    pos.yz *= rotate(a);\n    return deQuadTorus(pos, t);\n}\nfloat deHexSliceTorus(in vec2 p, in vec2 t, in float a)\n{\n    vec3 pos = vec3(p, 0.0).xzy;\n    pos.yz *= rotate(a);\n    return deHexTorus(pos, t);\n}\n\nvec3 opTorusTwist(in vec3 p, in float r, in float t)\n{     \n    float a = atan(p.z, p.x);\n    p.xz *= rotate(a);\n    p.x -= r;\n    p.xy *= rotate(a * t);\n    return p;\n}\n\nfloat de1(in vec3 p)\n{\n    p.yx *= rotate(PI/2.0);   \n    p.zx *= rotate(iTime * -0.02); \n    p  = opTorusTwist(p, 3.0, 10.0);\n    return deQuadSliceTorus(p.xy, vec2(0.8, 0.1), 0.35);  \n}\n\nfloat de2(in vec3 p)\n{\n    p.yz *= rotate(iTime * 0.15); \n    p.z += 20.0;\n    p.xy *= rotate(sin(iTime * 0.15)); \n    p  = opTorusTwist(p, 20.0, 20.0);\n    return deHexSliceTorus(p.xy, vec2(0.8, 0.2), 0.7);    \n}\n\nfloat de3(in vec3 p)\n{\n    p.z -= 3.2;\n \treturn length(p) - 0.35;   \n}\n\nfloat map(in vec3 p)\n{    \n    return min(min(de1(p), de2(p)),de3(p));\n}\n\nvec3 doColor(in vec3 p)\n{\n    float d1 = de1(p);\n    float d2 = de2(p);\n    float d3 = de3(p);\n    if (d1 < d2 && d1 < d3) \n    {\n        p.y -= iTime * 0.07;\n        return mix(texture(iChannel0, p.xy * 10.0).rgb ,\n         vec3(0.9, 0.5, 0.2),0.5);        \n    } else if (d2 < d3){\n    \treturn mix(texture(iChannel0, p.xy).rgb ,\n    \t\tvec3(0.5, 0.6, 0.2),0.5);\n    } else {\n    \tp.x -= iTime * 0.1;\n        p.y -= iTime * -0.05;\n        return mix(texture(iChannel0, p.xy).rgb ,\n    \t\tvec3(0.5, 0.6, 0.5),0.8);\n    }\n}\n\nvec3 calcNormal( in vec3 pos )\n{\n    vec2 e = vec2(1.0, -1.0) * 0.002;\n    return normalize(\n        e.xyy * map(pos + e.xyy) + \n        e.yyx * map(pos + e.yyx) + \n        e.yxy * map(pos + e.yxy) +   \n        e.xxx * map(pos + e.xxx));\n}\n\nfloat softshadow(in vec3 ro, in vec3 rd)\n{\n\tfloat res = 1.0;\n    float t = 0.05;\n    for(int i = 0; i < 32; i++)\n    {\n\t\tfloat h = map(ro + rd * t);\n        res = min(res, 8.0 * h / t);\n        t += clamp(h, 0.02, 0.1);\n        if(h < 0.001 || t > 1.5) break;\n    }\n    return clamp(res, 0.0, 1.0);\n}\n\nfloat intersect(in vec3 ro, in vec3 rd)\n{\n    const float maxd = 50.0;\n    const float precis = 0.001;\n    float h = 1.0;\n    float t = 0.0;\n    for(int i = 0; i < 128; i++)\n    {\n        if(h < precis || t > maxd) break;\n        h = map(ro + rd * t);\n        t += h;\n    }\n    if( t > maxd ) t = -1.0;\n    return t;\n}\n\nvec3 bg(in vec2 p , in vec2 fragCoord)\n{   \n    vec3 col = 0.2* texture(iChannel0, \n    \t3.0 * vec2(inversesqrt(length(p)), atan(p.x, p.y) * 0.2 -iTime*0.005)).rgb;\n    col = clamp(col, 0.0, 0.6);  \t\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = (2.0 * fragCoord - iResolution.xy) / iResolution.y;\n    vec3 col = bg(p, fragCoord);\n    vec3 ro = vec3(0.0, 0.0, 5.0);\n    vec3 rd = normalize(vec3(p, -2.0));\n    float t = intersect(ro, rd);\n    if(t > -0.001)\n    {\n        vec3 pos = ro + t * rd;\n        vec3 nor = calcNormal(pos);\n\t\tvec3 li = normalize(vec3(2.0, 2.0, 3.0));\n    \tcol = doColor(pos);\n        col *= max(dot(li, nor), 0.2);\n        col *= exp(-0.001 * pos.z * pos.z);\n        float sh = clamp(softshadow(pos, li), 0.4, 1.0);\n        col *= sh;\n        if (sh > 0.8) col += pow(max(dot(vec3(0.0, 0.0, 1.0), reflect(-li, nor)), 0.0), 60.0);\n        col = pow(col, vec3(0.8)); \n    }\n    fragColor = vec4(col, 1.0);\n}\n", "image_inputs": [{"id": "4sf3Rr", "previewfilepath": "/media/ap/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/ldtGWB.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "ldV3Dz", "name": "uv sphere??", "author": "FeepingCreature", "description": "not sure if correct", "tags": ["procedural"], "likes": 4, "viewed": 182, "date": "1454108345", "time_retrieved": "2024-06-20T18:30:18.326499", "image_code": "void mainImage (out vec4 fragColor, in vec2 fragCoord) {\n\tvec2 xz = fragCoord / min(iResolution.x, iResolution.y) * 2. - 1.;\n    float PI = 3.1415926538;\n    float x = xz.x, z = xz.y;\n    float y = sqrt(1.-x*x-z*z);\n    if (y != y) {\n        fragColor = vec4(0,0,0,0);\n        return;\n    }\n    \n    float lon1 = atan(y,x);\n    float lat1 = acos(z);\n    \n    float f = iTime * 2. + texture(iChannel0,vec2(lon1-iTime*0.5,lat1)).x*1.6;\n    \n    float x2 = x*sin(f)+y*cos(f);\n    float y2 = x*cos(f)-y*sin(f);\n    x=x2; y=y2;\n    \n    float lon = atan(y,x);\n    float lat = acos(z);\n    fragColor = vec4(lat/PI,lon/PI,0,0);\n}", "image_inputs": [{"id": "4sf3Rr", "previewfilepath": "/media/ap/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/ldV3Dz.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "ldy3RW", "name": "Is this beer heaven?", "author": "Emil", "description": "I don't even like beer!", "tags": ["raymarching", "beer"], "likes": 11, "viewed": 402, "date": "1453404749", "time_retrieved": "2024-06-20T18:30:18.326499", "image_code": "vec4 cellColor = vec4(0.0,0.0,0.0,0.0);\nvec3 cellPosition = vec3(0.0,0.0,0.0);\nfloat cellRandom = 0.0, onOffRandom = 0.0;\n\n\nfloat random (vec3 i){\n\treturn fract(sin(dot(i.xyz,vec3(4154895.34636,8616.15646,26968.489)))*968423.156);\n}\n\nvec4 getColorFromFloat (float i){\n    i *= 2000.0;\n    return vec4(normalize(vec3(abs(sin(i+radians(45.0))),abs(sin(i+radians(90.0))),abs(sin(i)))),1.0);\n}\n\nvec3 getPositionFromFloat (float i){\n    i *= 2000.0;\n    return vec3(normalize(vec3(abs(sin(i+radians(45.0))),abs(sin(i+radians(90.0))),abs(sin(i)))))-vec3(0.5,0.5,0.5);\n}\n\nfloat map(vec3 p, float radius, float time){\n    //p *= 1.0;\n    cellRandom = random(floor((p*0.5)+0.0*vec3(0.5,0.5,0.5)));\n    onOffRandom = random(vec3(5.0,2.0,200.0)+floor((p*0.5)+0.0*vec3(0.5,0.5,0.5)));\n    cellColor = getColorFromFloat(cellRandom);\n    cellPosition = getPositionFromFloat(cellRandom);\n    p.x = mod(p.x, 2.0);\n    p.y = mod(p.y, 2.0);\n    p.z = mod(p.z, 2.0);\n    p += 1.0*cellPosition.xyz;\n    p += p.xyz*sin(10.0*(time+onOffRandom*500.0))*\t\t\t0.2;\n    p += p.yzx*cos(10.0*(time+onOffRandom*500.0)+1561.355)*\t0.2;\n    if(onOffRandom>0.92){\n    \treturn length(p-vec3(1.0,1.0,1.0)) - (0.3*radius*(cellRandom+0.3))+0.01*(sin(time*(20.0*onOffRandom+cellRandom*2000.0)));\n    } else {\n        return 0.95;\n    }\n}\n\nfloat trace(vec3 o, vec3 r, float radius, float time){\n    float t = 0.5;\n    const int maxSteps = 62;\n    for (int i = 0; i < maxSteps; i++){ \n        vec3 p = o + r * t;\n        float d = map(p, radius, time);\n        t += d*0.48;\n    }\n    return t;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    uv = uv*2.0 -1.0;\n    uv.x *= iResolution.x / iResolution.y;\n    vec3 r = normalize(vec3(uv, 1.9+(0.2*sin(iTime))));\n    uv += 0.05*random(vec3(uv.xy,1.0));\n    r = r*0.8+cross(r,vec3(0.0,1.0,0.0));\n    r = r+0.2*cross(r,vec3(-1.4*sin(iTime*0.4+sin(0.7*(uv.x*0.5+0.1*iTime))),-2.0*cos(iTime*0.2),uv.y-2.0*sin(-uv.y)));\n    vec3 o = vec3(0.0,0.0,0.0);\n    o.y = -14.5*iTime+sin(iTime)*2.0;\n    \n    \n    float t = trace(o,r, 0.4, iTime*0.2);\n    float tn = clamp(t*-0.05+1.4,0.0,2.0);\n    o.y += 900.5;\n    t = trace(o+vec3(0.5,6.5,1.9),r, 0.8, iTime*0.8 + 10220.0);\n    tn += 0.2*clamp(t*-0.05+1.4,0.0,2.0);\n    tn *= 0.6;\n    /*\n    o.y += 1.6;\n    t = trace(o,r, 0.2, iTime + 40.0);\n    tn += clamp(t*-0.05+1.4,0.0,2.0);\n    o.y += 1.7;\n    t = trace(o,r, 0.3, iTime + 60.0);\n    tn += clamp(t*-0.05+1.4,0.0,2.0);*/\n    \n    \n    fragColor = vec4(tn)*0.3*vec4(1.0,0.8,0.4,1.0)+vec4(0.5*cos(uv.x*0.6)+0.4*cos((uv.y-2.0)*0.6),0.3*cos(uv.x*0.7)+0.4*cos((uv.y-2.0)*0.6),0.1,0.0) ;\n\t//fragColor = vec4(0.2,0.17,0.1,0.0)*0.8*(uv.y*2.8+1.5)+vec4(0.2,0.08,0.0,0.0)+vec4(fc*vec3(28.0,15.0+-1.0*length(uv+vec2(0.0,1.0)),6.4)*1.2/length(uv+vec2(0.0,1.3))*1.0,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/ldy3RW.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "ls33Wj", "name": "Everyday007 - MeltingTree", "author": "Makio64", "description": "Everyday007 - MeltingTree", "tags": ["noise", "color", "tree", "everyday"], "likes": 4, "viewed": 736, "date": "1452137449", "time_retrieved": "2024-06-20T18:30:19.647898", "image_code": "// Everyday007 - MeltingTree\n// By David Ronai / @Makio64\n\n//------------------------------------------------------------------ VISUAL QUALITY\n#define POSTPROCESS\n#define RAYMARCHING_STEP 35\n#define RAYMARCHING_JUMP 1.\n//------------------------------------------------------------------ DEBUG\n//#define RENDER_DEPTH\n//#define RENDER_NORMAL\n//#define RENDER_AO\n\n#define PHI (sqrt(5.)*0.5 + 0.5)\nconst float PI = 3.14159265359;\nfloat snoise(vec3 v);\n\nvec3 orbit(float phi, float theta, float radius)\n{\n\treturn vec3(\n\t\tradius * sin( phi ) * cos( theta ),\n\t\tradius * cos( phi ),\n\t\tradius * sin( phi ) * sin( theta )\n\t);\n}\n\n//------------------------------------------------------------------  SIGNED PRIMITIVES\nvoid pR(inout vec2 p, float a) {\n\tp = cos(a)*p + sin(a)*vec2(p.y, -p.x);\n}\n\n// Shortcut for 45-degrees rotation\nvoid pR45(inout vec2 p) {\n\tp = (p + vec2(p.y, -p.x))*sqrt(0.5);\n}\nfloat fOpUnionRound(float a, float b, float r) {\n\tvec2 u = max(vec2(r - a,r - b), vec2(0));\n\treturn max(r, min (a, b)) - length(u);\n}\n\n// Cylinder standing upright on the xz plane\nfloat fCylinder(vec3 p, float r, float height) {\n\tfloat d = length(p.xz) - r;\n\td = max(d, abs(p.y) - height);\n\treturn d;\n}\n\nfloat fSphere(vec3 p, float r) {\n\treturn length(p) - r;\n}\n\nfloat vmax(vec3 v) {\n\treturn max(max(v.x, v.y), v.z);\n}\n\nfloat fBox(vec3 p, vec3 b) {\n\tvec3 d = abs(p) - b;\n\treturn length(max(d, vec3(0))) + vmax(min(d, vec3(0)));\n}\n\n//------------------------------------------------------------------ MAP\nfloat map( in vec3 pos ) {\n    float t = texture(iChannel0,pos.xz/20.+vec2(iTime/3.,0.)).x*2.;\n    vec3 q = pos;\n  \tpR(q.xy,.4);\n\tfloat d = fBox(q,vec3(30.,.5+t,30.));\n    d = min(fSphere(pos-vec3(.0,70.,.0)+snoise(pos/10.+vec3(0.,iTime,0.))*10.,20.),d);\n    pos.y += (cos(pos.x/2.-iTime)+sin(pos.z/2.-iTime)-pos.y/20.)*10.;\n\td = fOpUnionRound(d, fCylinder(pos,4.+cos(pos.y/4.-.9),40.),18.4);\n\treturn d;\n}\n\n//------------------------------------------------------------------ RAYMARCHING\n\n#ifdef RENDER_DEPTH\nfloat castRay( in vec3 ro, in vec3 rd, inout float depth )\n#else\nfloat castRay( in vec3 ro, in vec3 rd )\n#endif\n{\n\tfloat t = 45.0;\n\tfloat res;\n\tfor( int i=0; i<RAYMARCHING_STEP; i++ )\n\t{\n\t\tvec3 pos = ro+rd*t;\n\t\tres = map( pos );\n\t\tif( res < 0.01 || t > 200. ) break;\n\t\tt += res*RAYMARCHING_JUMP;\n\t\t#ifdef RENDER_DEPTH\n\t\tdepth += 1./float(RAYMARCHING_STEP);\n\t\t#endif\n\t}\n\treturn t;\n}\n\nvec3 calcNormal(vec3 p) {\n\tfloat eps = 0.01;\n\tconst vec3 v1 = vec3( 1.0,-1.0,-1.0);\n\tconst vec3 v2 = vec3(-1.0,-1.0, 1.0);\n\tconst vec3 v3 = vec3(-1.0, 1.0,-1.0);\n\tconst vec3 v4 = vec3( 1.0, 1.0, 1.0);\n\treturn normalize( v1 * map( p + v1*eps ) +\n\t\t\t\t\t  v2 * map( p + v2*eps ) +\n\t\t\t\t\t  v3 * map( p + v3*eps ) +\n\t\t\t\t\t  v4 * map( p + v4*eps ) );\n}\n\n\nfloat hash( float n ){\n\treturn fract(sin(n)*3538.5453);\n}\n\nfloat calcAO( in vec3 p, in vec3 n, float maxDist, float falloff ){\n\tfloat ao = 0.0;\n\tconst int nbIte = 6;\n\tfor( int i=0; i<nbIte; i++ )\n\t{\n\t\tfloat l = hash(float(i))*maxDist;\n\t\tvec3 rd = n*l;\n\t\tao += (l - map( p + rd )) / pow(1.+l, falloff);\n\t}\n\treturn clamp( 1.-ao/float(nbIte), 0., 1.);\n}\n\n// calculate local thickness\n// base on AO but : inverse the normale(line117) & inverse the color(line 118)\nfloat thickness( in vec3 p, in vec3 n, float maxDist, float falloff )\n{\n\tfloat ao = 0.0;\n\tconst int nbIte = 6;\n\tfor( int i=0; i<nbIte; i++ )\n\t{\n\t\tfloat l = hash(float(i))*maxDist;\n\t\tvec3 rd = -n*l;\n\t\tao += (l + map( p + rd )) / pow(1.+l, falloff);\n\t}\n\treturn clamp( 1.-ao/float(nbIte), 0., 1.);\n}\n\n//------------------------------------------------------------------ POSTEFFECTS\n\n#ifdef POSTPROCESS\nvec3 postEffects( in vec3 col, in vec2 uv, in float time )\n{\n\t// vigneting\n\tcol *= .2+.8*pow( 16.0*uv.x*uv.y*(1.0-uv.x)*(1.0-uv.y), 0.8 );\n\treturn col;\n}\n#endif\n\nvec3 render( in vec3 ro, in vec3 rd, in vec2 uv )\n{\n\tvec3 col = vec3(.0,.0,1.2);\n\n\t#ifdef RENDER_DEPTH\n\tfloat depth = 0.;\n\tfloat t = castRay(ro,rd,depth);\n\t#else\n\tfloat t = castRay(ro,rd);\n\t#endif\n\n\t#ifdef RENDER_DEPTH\n\treturn vec3(depth/10.,depth/5.,depth);\n\t#endif\n\n\tvec3 pos = ro + t * rd;\n\tvec3 nor = calcNormal(pos);\n\n\t#ifdef RENDER_NORMAL\n\treturn nor;\n\t#endif\n\n\tfloat ao = calcAO(pos,nor,10.,1.2);\n\t#ifdef RENDER_AO\n\treturn vec3(ao);\n\t#endif\n\n    float thi = thickness(pos, nor, 6., 1.5);\n\n    vec3 lpos1 = vec3(0.0,0.,0.0);\n\tvec3 ldir1 = normalize(lpos1-pos);\n\tfloat latt1 = pow( length(lpos1-pos)*.1, 1.5 );\n    float trans1 =  pow( clamp( dot(-rd, -ldir1+nor), 0., 1.), 1.) + 1.;\n\tvec3 diff1 = vec3(.1,.2,.1) * (max(dot(nor,ldir1),0.) ) / latt1;\n\tcol =  diff1;\n\tcol += vec3(.3,.2,.05) * (trans1/latt1)*thi;\n    \n    lpos1 = vec3(0.,50.,0.);\n\tldir1 = normalize(lpos1-pos);\n\tlatt1 = pow( length(lpos1-pos)*.05, 1. );\n    trans1 =  pow( clamp( dot(-rd, -ldir1+nor), 0., 1.), 1.) + 1.;\n\tcol += vec3(.7,.2,.1) * (trans1/latt1)*thi;\n\n\tcol = max(vec3(.2,.1,.3)*(pos.y+10.)/80.,col);\n\tcol *= max(ao,.7);\n\treturn col;\n}\n\n\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr )\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n\treturn mat3( cu, cv, cw );\n}\n\n\n\n//------------------------------------------------------------------ MAIN\nvoid mainImage( out vec4 fragColor, in vec2 coords )\n{\n\tvec2 uv = coords.xy / iResolution.xy;\n\tvec2 mouse = iMouse.xy / iResolution.xy;\n\tvec2 q = coords.xy/iResolution.xy;\n\tvec2 p = -1.0+2.0*q;\n\tp.x *= iResolution.x/iResolution.y;\n\n\t//Camera\n\tfloat radius = 80.;\n\tvec3 ro = orbit(PI/2.-.2,PI/2.+iTime,radius);\n    ro.y+=30.;\n\tvec3 ta  = vec3(0.0,30., 0.0);\n\tmat3 ca = setCamera( ro, ta, 0. );\n\tvec3 rd = ca * normalize( vec3(p.xy,1.) );\n\n\t// Raymarching\n\tvec3 color = render( ro, rd, uv );\n\t#ifdef POSTPROCESS\n\tcolor = postEffects( color, uv, iTime );\n\t#endif\n\tfragColor = vec4(color,1.0);\n}\n\n//------------------------------------------------------------------ NOISE\n//AshimaOptim https://www.shadertoy.com/view/Xd3GRf\nvec4 permute(vec4 x){return mod(x*x*34.0+x,289.);}\nfloat snoise(vec3 v){\n  const vec2  C = vec2(0.166666667, 0.33333333333) ;\n  const vec4  D = vec4(0.0, 0.5, 1.0, 2.0);\n  vec3 i  = floor(v + dot(v, C.yyy) );\n  vec3 x0 = v - i + dot(i, C.xxx) ;\n  vec3 g = step(x0.yzx, x0.xyz);\n  vec3 l = 1.0 - g;\n  vec3 i1 = min( g.xyz, l.zxy );\n  vec3 i2 = max( g.xyz, l.zxy );\n  vec3 x1 = x0 - i1 + C.xxx;\n  vec3 x2 = x0 - i2 + C.yyy;\n  vec3 x3 = x0 - D.yyy;\n  i = mod(i,289.);\n  vec4 p = permute( permute( permute(\n\t  i.z + vec4(0.0, i1.z, i2.z, 1.0 ))\n\t+ i.y + vec4(0.0, i1.y, i2.y, 1.0 ))\n\t+ i.x + vec4(0.0, i1.x, i2.x, 1.0 ));\n  vec3 ns = 0.142857142857 * D.wyz - D.xzx;\n  vec4 j = p - 49.0 * floor(p * ns.z * ns.z);\n  vec4 x_ = floor(j * ns.z);\n  vec4 x = x_ *ns.x + ns.yyyy;\n  vec4 y = floor(j - 7.0 * x_ ) *ns.x + ns.yyyy;\n  vec4 h = 1.0 - abs(x) - abs(y);\n  vec4 b0 = vec4( x.xy, y.xy );\n  vec4 b1 = vec4( x.zw, y.zw );\n  vec4 s0 = floor(b0)*2.0 + 1.0;\n  vec4 s1 = floor(b1)*2.0 + 1.0;\n  vec4 sh = -step(h, vec4(0.0));\n  vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy ;\n  vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww ;\n  vec3 p0 = vec3(a0.xy,h.x);\n  vec3 p1 = vec3(a0.zw,h.y);\n  vec3 p2 = vec3(a1.xy,h.z);\n  vec3 p3 = vec3(a1.zw,h.w);\n  vec4 norm = inversesqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));\n  p0 *= norm.x;\n  p1 *= norm.y;\n  p2 *= norm.z;\n  p3 *= norm.w;\n  vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n  m = m * m * m;\n  return .5 + 12.0 * dot( m, vec4( dot(p0,x0), dot(p1,x1),dot(p2,x2), dot(p3,x3) ) );\n}", "image_inputs": [{"id": "4sf3Rr", "previewfilepath": "/media/ap/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/ls33Wj.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "ls33Ws", "name": "Just weird lines", "author": "Emil", "description": "Just random stuff, hoi!", "tags": ["2d", "voronoi", "lines", "cells"], "likes": 12, "viewed": 232, "date": "1452725811", "time_retrieved": "2024-06-20T18:30:19.647898", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float gradient = (0.7-float(fragCoord.y / iResolution.x))*1.4;\n    float cellSize = 38.0;\n    vec2 currentOffset = vec2(0.0,0.0);\n    float pi = 3.141592653;\n    \n    float magrand = 0.0, timeStep = 0.0;\n    \n    float d1 = 0.0,d2 = 0.0,d3 = 0.0,d4 = 0.0,d5 = 0.0,d6 = 0.0,d7 = 0.0,d8 = 0.0,d9 = 0.0;\n    int index = 0;\n    float d = 1.0, e = 0.0, f = 0.0, g = 0.0;\n    \n    vec2 uv = vec2(0.0,0.0), uvStep = vec2(0.0,0.0), newPosition = vec2(0.0,0.0);\n    float y = 0.0, x = 0.0, rm1 = 0.0, rm2 = 0.0;\n    \n    float sintime = clamp(sin(iTime),0.0,1.0);\n    timeStep = ceil(0.1+(iTime/(2.0*pi)));\n    magrand = fract(sin(dot(vec2(timeStep,0.4),vec2(1461.6184,26968.346)))*69184.361);\n    \n    uv = (fragCoord.xy / iResolution.x);\n    \n    for(int xpos = -1;xpos<=1;xpos++){\n        for(int ypos = -1;ypos<=1;ypos++){\n            index++;\n            currentOffset = vec2(xpos,ypos);\n            \n            uvStep = (ceil((uv)*cellSize-vec2(0.5,0.5)+currentOffset)/cellSize);\n            y = fract(sin(dot(uvStep.xy,vec2(8616.1566,26968.489)))*968423.156)-0.5;\n            x = fract(sin(dot(uvStep.xy,vec2(1242.9898,42678.233)))*33758.5453)-0.5;\n\n            \n            //magrand = 1.0;\n            rm1 = sin(iTime*38.5*magrand*x*y)*2.0*(0.3*(clamp(sin(iTime)+0.3,0.0,1.0)))/cellSize;\n            rm2 = cos(iTime*35.5*magrand*x*y)*2.0*(0.3*(clamp(sin(iTime)+0.3,0.0,1.0)))/cellSize;\n    \n    \t\tnewPosition = vec2(uvStep.x + x*rm1, uvStep.y + y*rm2);\n    \t\t//d = 1.0-d;\n\t\t\td = (distance(newPosition.xy,uv.xy)*cellSize);\n            d = x+0.3<-0.2*abs(sin(iTime*0.3))?1.0:d;\n            if(index==1){\n                d1 = d;\n            } else if (index==2){\n                d2 = d;\n            } else if (index==3){\n                d3 = d;\n            } else if (index==4){\n                d4 = d;\n            } else if (index==5){\n                d5 = d;\n            } else if (index==6){\n                d6 = d;\n            } else if (index==7){\n                d7 = d;\n            } else if (index==8){\n                d8 = d;\n            } else if (index==9){\n                d9 = d;\n            }\n            \n        }\n    }\n    // finding smallest\n    d = d1<d2?d1:d2;\n    d = d<d3?d:d3;\n    d = d<d4?d:d4;\n    d = d<d5?d:d5;\n    d = d<d6?d:d6;\n    d = d<d7?d:d7;\n    d = d<d8?d:d8;\n    d = d<d9?d:d9;\n    \n    // finding second smallest\n    if(d==d1){\n        e = d2<d3?d2:d3;\n        e = e<d4?e:d4;\n        e = e<d5?e:d5;\n        e = e<d6?e:d6;\n        e = e<d7?e:d7;\n        e = e<d8?e:d8;\n        e = e<d9?e:d9;\n    } else if(d==d2){\n        e = d1<d3?d1:d3;\n        e = e<d4?e:d4;\n        e = e<d5?e:d5;\n        e = e<d6?e:d6;\n        e = e<d7?e:d7;\n        e = e<d8?e:d8;\n        e = e<d9?e:d9;\n    } else if(d==d3){\n        e = d1<d2?d1:d2;\n        e = e<d4?e:d4;\n        e = e<d5?e:d5;\n        e = e<d6?e:d6;\n        e = e<d7?e:d7;\n        e = e<d8?e:d8;\n        e = e<d9?e:d9;\n\t} else if(d==d4){\n        e = d1<d2?d1:d2;\n        e = e<d3?e:d3;\n        e = e<d5?e:d5;\n        e = e<d6?e:d6;\n        e = e<d7?e:d7;\n        e = e<d8?e:d8;\n        e = e<d9?e:d9;\n    } else if(d==d5){\n        e = d1<d2?d1:d2;\n        e = e<d3?e:d3;\n        e = e<d4?e:d4;\n        e = e<d6?e:d6;\n        e = e<d7?e:d7;\n        e = e<d8?e:d8;\n        e = e<d9?e:d9;\n    } else if(d==d6){\n        e = d1<d2?d1:d2;\n        e = e<d3?e:d3;\n        e = e<d4?e:d4;\n        e = e<d5?e:d5;\n        e = e<d7?e:d7;\n        e = e<d8?e:d8;\n        e = e<d9?e:d9;\n    } else if(d==d7){\n        e = d1<d2?d1:d2;\n        e = e<d3?e:d3;\n        e = e<d4?e:d4;\n        e = e<d5?e:d5;\n        e = e<d6?e:d6;\n        e = e<d8?e:d8;\n        e = e<d9?e:d9;\n    } else if(d==d8){\n        e = d1<d2?d1:d2;\n        e = e<d3?e:d3;\n        e = e<d4?e:d4;\n        e = e<d5?e:d5;\n        e = e<d6?e:d6;\n        e = e<d7?e:d7;\n        e = e<d9?e:d9;\n    } else if(d==d9){\n        e = d1<d2?d1:d2;\n        e = e<d3?e:d3;\n        e = e<d4?e:d4;\n        e = e<d5?e:d5;\n        e = e<d6?e:d6;\n        e = e<d7?e:d7;\n        e = e<d8?e:d8;\n    }\n    fragColor = vec4(smoothstep(-0.2, 0.0, d-e)*gradient*vec4(1.6,0.6,0.3,0.0)+(1.0-gradient)*vec4(0.6,0.2,0.3,0.0));\n\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/ls33Ws.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "ls33zj", "name": "Moon reflection", "author": "narobins", "description": "testing ", "tags": ["reflection", "moon"], "likes": 8, "viewed": 162, "date": "1451666968", "time_retrieved": "2024-06-20T18:30:19.647898", "image_code": "const float xw = 0.1; // x warp\nconst float yw = 0.15; // y warp\nconst float xf = 3.0; // x frequency\nconst float yf = 18.0; // y frequency\nconst float xs = 0.5; // x speed\nconst float ys = -0.4; // y speed\n\n\nconst vec4 m = vec4(0.93, 0.9, 0.8, 1.0); // moon\nconst vec4 w = vec4(0.03, 0.01, 0.3, 1.0); // water\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{   \n    vec2 uv = fragCoord.xy;\n    uv.x = 2.0 * (uv.x - iResolution.x / 2.0);\n    uv /= iResolution.yy;;\n    uv.y = mod(uv.y * 2.0, 1.0) - 0.5;\n    uv *= 2.0;\n    if (fragCoord.y / iResolution.y < 0.5) {\n   \t\tuv += vec2(xw * sin(xf * (uv.x - xs * iTime)), \n               yw * cos(yf * (uv.y - ys * iTime)));\n    }\n    fragColor = mix(m, w, \n                    vec4(smoothstep(0.1, 0.15, dot(uv, uv))));\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/ls33zj.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "ls3GzS", "name": "sand relics", "author": "raziel", "description": "Playing around with noise and sdf to render some sandy dunes. Some lighting tricks picked up from Journey presentation. Plus thanks to iq for all the sdf resources. ", "tags": ["raymarching", "sdf", "valuenoise", "sand"], "likes": 6, "viewed": 371, "date": "1453116576", "time_retrieved": "2024-06-20T18:30:19.654001", "image_code": "// --- thanks to iq for all the ray-marching sdf info and awesomeness\n\nfloat rand(vec2 p)\n{\n    return fract(sin(dot(p.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nfloat value_noise(vec2 p)\n{\n    vec2 i = floor(p);\n    vec2 f = fract(p);\n    \n    vec2 s = smoothstep(0.0, 1.0, f);\n    float nx0 = mix(rand(i + vec2(0.0, 0.0)), rand(i + vec2(1.0, 0.0)), s.x);\n    float nx1 = mix(rand(i + vec2(0.0, 1.0)), rand(i + vec2(1.0, 1.0)), s.x);\n    return mix(nx0, nx1, s.y);\n}\n\nfloat sdf_sbox(in vec3 p, in vec3 l)\n{\n  vec3 d = abs(p) - l;\n  return min(max(d.x, max(d.y, d.z)), length(max(d, 0.0)));\n}\n\nfloat sdf_cbox(in vec3 p, in float l)\n{\n    float fmax = 10000000.0;\n    float b0 = sdf_sbox(p, vec3(fmax, l, l));\n    float b1 = sdf_sbox(p, vec3(l, fmax, l));\n    float b2 = sdf_sbox(p, vec3(l, l, fmax));\n    return min(b0, min(b1, b2));\n}\n\nfloat intersect(vec3 p)\n{\n    const int no = 3;\n    float tot = 0.0;\n    vec2 q = p.xz * 0.35;\n    float a = 0.5;\n    float f = 1.0;\n    for (int i = 0; i < no; ++i)\n    {\n        tot += value_noise(q * f) * a;\n        a *= 0.5;\n        f *= 2.5;\n        q = q * mat2(0.5, -0.866, 0.866, 0.5) * 0.65;\n        q += vec2(2.5, 4.8);\n    }\n    \n    float d1 = p.y - tot * 2.0;\n    \n    vec3 qq = p;\n    qq.xz = mod(qq.xz, 5.0) - 2.5;\n    qq.y -= 2.0;\n    \n    const int mi = 3;\n    float sf = 3.0;\n    float dcc = 0.0;\n    float db = sdf_sbox(qq, vec3(0.5));\n    vec3 pp = qq;\n    for (int i = 0; i < mi; ++i)\n    {\n        pp.xy = pp.xy * mat2(0.5, -0.866, 0.866, 0.5);\n        vec3 ppm = pp;\n       \tppm = mod(ppm, 0.2) - 0.1;\n        dcc = sdf_cbox(ppm * sf, 0.1) / sf;\n        db = max(db, -dcc);\n        sf *= 1.5;      \n    }\n    \n    float d2 = max(db, length(qq) - 0.5);\n    return min(d1, d2);\n}\n\nfloat intersect_shadow(vec3 p)\n{   \n    vec3 qq = p;\n    qq.xz = mod(qq.xz, 5.0) - 2.5;\n    qq.y -= 2.0;\n    \n    const int mi = 3;\n    float sf = 3.0;\n    float dcc = 0.0;\n    float db = sdf_sbox(qq, vec3(0.5));\n    vec3 pp = qq;\n    for (int i = 0; i < mi; ++i)\n    {\n        pp.xy = pp.xy * mat2(0.5, -0.866, 0.866, 0.5);\n        vec3 ppm = pp;\n       \tppm = mod(ppm, 0.2) - 0.1;\n        dcc = sdf_cbox(ppm * sf, 0.1) / sf;\n        db = max(db, -dcc);\n        sf *= 1.5;      \n    }\n    \n    float d2 = max(db, length(qq) - 0.5);\n    return d2;\n}\n\nvec3 compute_normal(vec3 pos)\n{\n    vec3 eps = vec3(0.01, 0.0, 0.0);\n    vec3 pos00 = (pos + eps.xyy);\n    vec3 pos01 = (pos - eps.xyy);\n    vec3 pos10 = (pos + eps.yxy);\n    vec3 pos11 = (pos - eps.yxy);\n    vec3 pos20 = (pos + eps.yyx);\n    vec3 pos21 = (pos - eps.yyx);\n\tvec3 normal = vec3(intersect(pos00) - intersect(pos01), \n                       intersect(pos10) - intersect(pos11), \n                       intersect(pos20) - intersect(pos21));\n\treturn normalize(normal);\n}\n\nfloat compute_shadows(in vec3 ro, in vec3 rd)\n{\n    float res = 1.0;\n    float t = 0.01;\n    for(int i = 0; i < 16; i++)\n    {\n        vec3 p = ro + rd * t;\n        float d = intersect_shadow(p);\n        res = min(res, max(d, 0.0) * 16.0 / t);\n        if (res < 0.001)\n            break;\n        t += d * 0.5;\n    }\n    \n    return res;\n}\n\nvec2 ray_march(in vec3 ro, in vec3 rd)\n{\n    float t = 0.0;\n    float tmax = 120.0;\n    const int smax = 200;\n    float st = 0.0;\n    \n    for (int i = 0; i < smax; ++i)\n    {\n        vec3 p = ro + rd * t;\n        float res = intersect(p);\n        if (res < 0.001 || t > tmax)\n            break;\n        t += res * 0.5;\n        st++;\n    }\n    \n    if (t < tmax)\n        return vec2(t, st / float(smax));\n    else\n        return vec2(-1.0, st / float(smax));\n}\n\n// --- some lighting tricks from \n// --- http://advances.realtimerendering.com/s2012/thatgamecompany/SandRenderingInJourney_thatgamecompany.pptx\nvec3 render(in vec3 ro, in vec3 rd)\n{\n    vec3 col = (1.0 - rd.yyy) * vec3(0.5, 0.7, 0.98);\n    vec3 ld = normalize(vec3(1.0, 0.5, -1.0));\n    \n    vec2 res = ray_march(ro, rd);\n    if (res.x > 0.0)\n    {\n        vec3 pn = ro + res.x * rd;\n        vec3 n1 = compute_normal(pn);\n        vec3 n2 = normalize(textureLod(iChannel0, pn.xz * 3.0, 0.0).rgb);\n        vec3 nn1 = normalize(mix(n1, n2, 0.2));\n        vec3 nn2 = normalize(mix(n1, n2, 0.4));\n        \n        vec3 wv = vec3(sin(pn.xz * 4.0), 1.0);\n        wv = vec3(pn.x * 4.0 + wv.y);\n        wv = vec3(mod(wv.x, 1.1)) * 0.6 + 0.4;\n        \n        nn1 = normalize(mix(nn1, wv, 0.3));\n        \n        float sha = compute_shadows(pn + nn1 * 0.01, ld);\n        \n        nn1.y *= 0.3;\n        vec3 ndotl = clamp(2.0 * dot(nn1, ld) * sha * (1.0 - res.y), 0.0, 1.0) * vec3(0.55, 0.7, 0.6) + vec3(0.45, 0.3, 0.4);\n        col = ndotl * vec3(0.909, 0.686, 0.415) * 1.2;\n        col += (1.0 - ndotl) * vec3(0.36, 0.2, 0.176);\n        \n        nn2 = normalize(mix(nn2, wv, 0.3));\n        \n        nn2.y *= 0.3;\n        float ndotv = clamp(dot(nn2, -rd), 0.0, 1.0);\n        col += pow(1.0 - ndotv, 5.0) * vec3(1.0, 0.8, 0.6) * clamp(dot(nn2, ld), 0.0, 1.0);\n        \n        float fog = exp(-0.0003 * res.x * res.x);\n        col *= fog;\n        col += (1.0 - fog) * vec3(0.5, 0.7, 0.98);\n    }\n    \n    float sun = clamp(dot(rd, ld), 0.0, 1.0) * 0.5 + 0.5; \n    col += vec3(1.0, 0.8, 0.6) * 0.6 * pow(sun, 8.0);\n    \n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 xi[5];\n    xi[0] = vec2(0.0, 0.0);\n    xi[1] = vec2(0.25, 0.0);\n    xi[2] = vec2(-0.25, 0.0);\n    xi[3] = vec2(0.0, 0.25);\n    xi[4] = vec2(0.0, -0.25);\n    \n    vec2 mo = iMouse.xy / iResolution.xy;\n    vec3 cp = vec3(0.0, 2.9 + mo.y, 5.0 - iTime);\n    vec3 cu = normalize(vec3(0.0, 0.8, -0.2));\n    vec3 cr = vec3(1.0, 0.0, 0.0);\n    vec3 cf = normalize(cross(cu, cr));\n    float fl = 2.1;\n    \n    vec3 col = vec3(0.0);\n    const int nx = 1;\n    for (int i = 0; i < nx; ++i)\n    {\n        vec2 c_ss = (fragCoord.xy + xi[i]) / iResolution.xy;\n        vec2 c_cs = 2.0 * c_ss - 1.0;\n        c_cs.x *= iResolution.x / iResolution.y;\n        \n        vec3 rd = normalize(cf * fl + cr * c_cs.x + cu * c_cs.y);\n        col += render(cp, rd);\n    }\n    col /= float(nx);\n    col = pow(col, vec3(0.4545));\n    \n    fragColor = vec4(col, 1.0);\n}", "image_inputs": [{"id": "XdXGzn", "previewfilepath": "/media/ap/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/ls3GzS.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "lsc3Ds", "name": "volumetric fog - above and below", "author": "trapzz", "description": "Shadertoy has been inspiring so I wanted to add something fun.  Here's some simple but cool looking (I think) volumetric fog - you can find references and descriptions at the top of the file.  Thanks for looking!", "tags": ["volumetricfog", "pbr"], "likes": 16, "viewed": 2445, "date": "1452747266", "time_retrieved": "2024-06-20T18:30:23.042241", "image_code": "//No license, if you like anything here feel free to use it - credit would be nice but not necessary\n//Shoutout to IQ, his work is simply incredible \n\n//There are a lot of things this volumetric fog doesn't do; but I think it still gives a pretty nice result\n//and it runs well on my Intel Sandy Bridge integrated graphics, so that's a plus :)\n//What it does:\n//  Marches two 'fog volumes' (separated by a plane) and accumulates lighting according to the density of the fog\n//  It stops the march once the volume is complete or if it intersects an object\n//  It uses a random noise texture to vary the density of the fog which I think gives a nice \"northern lights\" effect.\n//A more complex solution would:\n//  integrate scattering and occlusion from neighbouring fog and other objects\n//  SÃ©bastien Hillaire's paper is an excellent reference:\n//      http://advances.realtimerendering.com/s2015/Frostbite%20PB%20and%20unified%20volumetrics.pptx    \n\n//References:\n//\n//SIGNED DISTANCE FIELD\n//  http://iquilezles.org/www/articles/distfunctions/distfunctions.htm\n//GENERATING NORMALS\n// TEKF https://www.shadertoy.com/view/lslXRj\n//PBR\n//  http://renderwonk.com/publications/s2010-shading-course/gotanda/course_note_practical_implementation_at_triace.pdf\n//  http://simonstechblog.blogspot.com/2011/12/microfacet-brdf.html\n//  http://www.cs.virginia.edu/~jdl/bib/appearance/analytic%20models/schlick94b.pdf\n//  http://graphicrants.blogspot.com/2013/08/specular-brdf-reference.html\n//FOG\n//  http://advances.realtimerendering.com/s2015/Frostbite%20PB%20and%20unified%20volumetrics.pptx\n\n#define CAMERA_STATIC\t0\n#define CAMERA_ROTATE\t1\n#define CAMERA_MANUAL\t2\n#define CAMERA_SCRIPTED\t3\n\n#define RAYMARCH_STEPS\t100\n#define ROTATE_LIGHT\n#define CAMERA\tCAMERA_SCRIPTED\n\n//fog\n#define FOG\n#define FOG_VOLUME                  20\n#define FOG_DENSITY                 1.80 //1 == looking through the fog volume an \n                                         //unoccluded pixel will be fully fogged by the end of the volume\n#define RAYMARCH_FOG_RESOLUTION     .2\n#define RAYMARCH_FOG_STEPS          int(float(FOG_VOLUME) / RAYMARCH_FOG_RESOLUTION)\n#define FOG_VOXEL_DENSITY           float(FOG_DENSITY) / float(RAYMARCH_FOG_STEPS)\n#define RAYMARCH_FOG_LIGHTING_STEPS 15\n#define FOG_LIGHTING_MAX_DISTANCE  20.0\n\nconst float SIGNED_DISTANCE_EPSILON = 0.0001;\nconst float PI = 3.1415926535897932384626433832795;\n\nconst int g_num_materials = 2;\nconst int g_num_spheres = 4;\nconst int g_num_point_lights = 2;\nconst int g_num_light_descs = g_num_point_lights;\n\nstruct Ray\n{\n    vec3 origin;\n    vec3 direction;\n};\n\nstruct Material\n{\n    vec4 color;\n    float emissive;\n    float roughness;\n    float metallic;\n};\n\nstruct Sphere\n{\n    vec3 center;\n    float radius;\n    Material material;\n};  \n\nstruct RayHit\n{\n    Material material;\n    vec3 position;\n    vec3 normal;\n    float n_dot_v;\n    float dist;\n    bool valid;\n};\n\nstruct TraceResult\n{\n    vec4 color;\n    RayHit ray_hit;\n};\n\nstruct SignedDistanceResult\n{\n    float d;\n    Material m;\n};\n\nstruct PointLight\n{\n    vec3 position;\n    vec3 color;\n    \n    float radius;\n    float n_dot_l;\n    float n_dot_h;\n    float v_dot_h;\n};\n\nstruct LightDesc\n{\n    vec3 color;\n    \n    float n_dot_l;\n    float n_dot_h;\n    float v_dot_h;   \n};\n\nMaterial g_materials[g_num_materials];\nSphere g_spheres[g_num_spheres];\n\nPointLight g_point_lights[g_num_point_lights];\nLightDesc g_light_desc[g_num_light_descs];\n\nvec3 g_ambient_light;\n\nvec3 RotateYaw( vec3 position, float yaw )\n{\n    vec3 center = position;\n    center.x = cos(yaw) * position.x + - sin(yaw) * position.z;\n    center.z = sin(yaw) * position.x +   cos(yaw) * position.z;   \n\n    return center;\n}\n\nvec3 RotatePitch( vec3 position, float pitch )\n{\n    vec3 center = position;\n    center.y = cos(pitch) * position.y + - sin(pitch) * position.z;\n    center.z = sin(pitch) * position.y +   cos(pitch) * position.z;   \n\n    return center;\n}\n\nvec3 TransformPosition( vec3 position, vec3 center, float yaw )\n{\n    return RotateYaw( position - center, yaw ) + center;\n}\n\nvec4 saturate(vec4 v)\n{\n    return clamp(v, 0.0, 1.0);\n}\n\nvec3 saturate(vec3 v)\n{\n    return clamp(v, 0.0, 1.0);\n}\n\nfloat saturate(float f)\n{\n    return clamp(f, 0.0, 1.0);\n}\n\nvoid Init()\n{\n    float time_cos_0_point_5 = cos(iTime * 0.5);\n    float time_cos_1_point_0 = cos(iTime * 1.0);\n    float time_sin_0_point_5 = sin(iTime * 0.5);\n    \n    // material for two spheres\n    g_materials[0].color = vec4(1.0, 1.0, 1.0, 1.0);\n    g_materials[0].emissive = 0.0;\n    g_materials[0].metallic = 0.0;   \n    g_materials[0].roughness = 0.5;\n    \n    // materials - emissive (for lights)\n    g_materials[1].color = vec4(1.0, 1.0, 0.30, 1.0);\n    g_materials[1].emissive = 1.0;\n    g_materials[1].roughness = 1.0;\n    g_materials[1].metallic = 1.00;   \n\n    // rotating sphere\n    g_spheres[0].center = vec3(time_sin_0_point_5 * 12.0, -6.0, time_cos_0_point_5 * 12.0);\n    g_spheres[0].radius = 1.0;\n    g_spheres[0].material = g_materials[0];\n    \n    // up / down sphere sphere\n    g_spheres[1].center = vec3(0.0, time_cos_1_point_0 * 10.0, 0.0);\n    g_spheres[1].radius = 2.0;\n    g_spheres[1].material = g_materials[0];\n\n    // lights\n    g_point_lights[0].position = vec3(0.0, 0.0, -15.0);\n    g_point_lights[0].color = vec3(174.0 / 255.0 * 2.0, 174.0 / 255.0 * 2.0, 255.0 / 255.0 * 2.0);\n    g_point_lights[0].radius = .2;\n\n    g_point_lights[1].position = vec3(0.0, 0.0, 15.0);\n    g_point_lights[1].color = vec3(175.0 / 255.0 * 2.0, 151.0 / 255.0 * 2.0, 175.0 / 255.0 * 2.0);\n    g_point_lights[1].radius = .2;\n    \n#ifdef ROTATE_LIGHT\n    g_point_lights[0].position = RotateYaw(g_point_lights[0].position, -time_cos_1_point_0);\n    g_point_lights[0].position = RotatePitch(g_point_lights[0].position, time_cos_0_point_5);\n    g_point_lights[1].position = RotateYaw(g_point_lights[1].position, -time_cos_0_point_5);\n    g_point_lights[1].position = RotatePitch(g_point_lights[1].position, -time_cos_1_point_0);\n#endif\n    \n    g_spheres[2].center = g_point_lights[0].position;\n    g_spheres[2].radius = g_point_lights[0].radius;\n    g_spheres[2].material = g_materials[1];\n    g_spheres[2].material.color.rgb = g_point_lights[0].color;\n    \n    g_spheres[3].center = g_point_lights[1].position;\n    g_spheres[3].radius = g_point_lights[1].radius;\n    g_spheres[3].material = g_materials[1];\n    g_spheres[3].material.color.rgb = g_point_lights[1].color;\n\n    g_ambient_light = vec3(.075, .09, .075);\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n    vec3 d = abs(p) - b;\n    \n    return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\nfloat sdSphere( vec3 p, float s )\n{\n    return length( p ) - s;\n}\n\nSignedDistanceResult sdUnion( SignedDistanceResult r1, SignedDistanceResult r2 )\n{\n    if (r1.d < r2.d)\n        return r1;\n    else    \n        return r2;\n}\n\nSignedDistanceResult SignedDistance( vec3 position )\n{\n    SignedDistanceResult result;\n    \n    float d = sdSphere( position - g_spheres[0].center, g_spheres[0].radius );\n    result = SignedDistanceResult( d, g_spheres[0].material );\n\n    for ( int i = 1; i < g_num_spheres; i++ )\n    {\n        d = sdSphere( position - g_spheres[i].center, g_spheres[i].radius );    \n        result = sdUnion( result, SignedDistanceResult(d, g_spheres[i].material) );\n    }\n            \n    return result;\n}\n\nvec3 CalculateNormal( vec3 ray_direction, vec3 position )\n{   \n    // from TEKF: https://www.shadertoy.com/view/lslXRj\n    // I really liked the results\n    float pitch = 0.2 / iResolution.x;\n    \n    vec2 d = vec2(-1, 1) * pitch;\n\n    vec3 p0 = position + d.xxx; // tetrahedral offsets\n    vec3 p1 = position + d.xyy;\n    vec3 p2 = position + d.yxy;\n    vec3 p3 = position + d.yyx;\n\n    float f0 = SignedDistance(p0).d;\n    float f1 = SignedDistance(p1).d;\n    float f2 = SignedDistance(p2).d;\n    float f3 = SignedDistance(p3).d;\n            \n    vec3 grad = p0 * f0 + p1 * f1 + p2 * f2 + p3 * f3 - position * (f0 + f1 + f2 + f3);\n    \n    // prevent normals pointing away from camera (caused by precision errors)\n    float gdr = dot (grad, ray_direction);\n    grad -= max(0.0, gdr) * ray_direction;\n\n    return normalize(grad);\n}\n\nRay CreateRay(vec3 cam_pos, vec3 cam_euler, vec2 frag_coord)\n{\n    const float fov_degrees = 45.0;\n    \n    vec3 eye;\n    eye.x = 0.0; eye.y = 0.0; eye.z = - 1.0 / tan(fov_degrees / 2.0 * 0.0174532925);\n    \n    vec3 pixel;\n    pixel.xy = (frag_coord.xy - .5) / iResolution.xy * 2.0 - 1.0;\n    pixel.x *= iResolution.x / iResolution.y;\n    pixel.z = 0.0;\n\n    vec3 dir = normalize(pixel - eye);\n\n    Ray ray;\n    \n    ray.direction = dir;\n    ray.direction.x = cos(cam_euler.y) * dir.x + - sin(cam_euler.y) * dir.z;\n    ray.direction.z = sin(cam_euler.y) * dir.x +   cos(cam_euler.y) * dir.z;\n    \n    dir = ray.direction;\n\n    ray.direction.y = cos(cam_euler.x) * dir.y + - sin(cam_euler.x) * dir.z;\n    ray.direction.z = sin(cam_euler.x) * dir.y +   cos(cam_euler.x) * dir.z;\n    \n    vec3 origin = cam_pos;\n\n    ray.origin = origin;\n    ray.origin.x = cos(cam_euler.y) * cam_pos.x + - sin(cam_euler.y) * cam_pos.z;\n    ray.origin.z = sin(cam_euler.y) * cam_pos.x +   cos(cam_euler.y) * cam_pos.z;   \n\n    origin = ray.origin;\n\n    ray.origin.y = cos(cam_euler.x) * origin.y + - sin(cam_euler.x) * origin.z;\n    ray.origin.z = sin(cam_euler.x) * origin.y +   cos(cam_euler.x) * origin.z;\n    \n    ray.origin += ray.direction * - eye.z;\n    \n    return ray;\n}\n\nRayHit CheckHit( vec3 ray_direction, vec3 position )\n{\n    RayHit ray_hit;\n    \n    SignedDistanceResult result = SignedDistance( position );\n    ray_hit.dist = result.d;\n    \n    if ( ray_hit.dist < SIGNED_DISTANCE_EPSILON )\n    {\n        ray_hit.valid = true;\n        ray_hit.material = result.m;\n        ray_hit.position = position;\n        ray_hit.normal = CalculateNormal( ray_direction, position );\n    }\n    else\n    {\n        ray_hit.valid = false;\n    }\n\n    return ray_hit;\n}\n\nRayHit RayMarch( Ray ray )\n{\n    float dist = 0.0;\n    vec3 pos = ray.origin;\n\n    RayHit ray_hit;\n    \n    for (int i = 0; i < RAYMARCH_STEPS; i++)\n    {\n        ray_hit = CheckHit( ray.direction, pos );\n\n        if (true == ray_hit.valid)\n            break;\n        \n        dist += ray_hit.dist;\n        pos = ray.origin + ray.direction * dist;\n    }\n        \n    return ray_hit;\n}\n\nfloat CalculateSpecDistribution_GGX( float n_dot_h, float roughness )\n{\n    float a = roughness * roughness;\n    float a2 = a * a;\n    float d = (n_dot_h * n_dot_h) * (a2 - 1.0) + 1.0;\n\n    d = PI * (d * d);\n    \n    return a2 / d;\n}\n\nfloat CalculateSpecGeometricAttenuation_Schlick_G1( float d, float k )\n{\n    float g = d / (d * (1.0 - k) + k);\n\n    return (g);\n}\n\nfloat CalculateSpecGeometricAttenuation_Schlick_G( float n_dot_l, float n_dot_v, float roughness )\n{\n    float a = (roughness + 1.0) / 2.0;\n    float a2 = a * a;\n    float k = a2 / 2.0;\n    \n    k = a2 * sqrt(2.0 / PI);\n    \n    float g = CalculateSpecGeometricAttenuation_Schlick_G1(n_dot_l, k) * \n              CalculateSpecGeometricAttenuation_Schlick_G1(n_dot_v, k);\n              \n    return max(0.0, g);//saturate(g);\n}\n\nfloat CalculateFresnel_Schlick(float f0, float c)\n{\n    return (f0 + (1.0 - f0) * pow(1.0 - c, 5.0));\n}\n\nvec3 CalculateLighting( RayHit ray_hit, Material material )\n{\n    vec3 color = vec3(0.0, 0.0, 0.0);\n    \n    for (int c = 0; c < g_num_light_descs; c++)\n    {\n        float d = CalculateSpecDistribution_GGX( g_light_desc[c].n_dot_h, material.roughness );\n        float g = CalculateSpecGeometricAttenuation_Schlick_G( g_light_desc[c].n_dot_l, ray_hit.n_dot_v, material.roughness );\n        float fd = CalculateFresnel_Schlick( material.metallic, saturate(g_light_desc[c].n_dot_l) );\n        float fs = CalculateFresnel_Schlick( material.metallic, saturate(g_light_desc[c].v_dot_h) );\n    \n        float n_dot_l_sat = saturate(g_light_desc[c].n_dot_l);\n\n        vec3 diffuse = g_light_desc[c].color * n_dot_l_sat / PI * (1.0 - fd);\n    \n        vec3 brdf = g_light_desc[c].color * (g * d * fs) * n_dot_l_sat / (4.0 * (g_light_desc[c].n_dot_l * ray_hit.n_dot_v));\n        \n        color += diffuse + brdf;\n    }   \n    \n    return color;\n}\n\nTraceResult ProcessRayHit( RayHit ray_hit, Ray ray )\n{\n    TraceResult result;\n    result.ray_hit = ray_hit;\n    \n    if (false == result.ray_hit.valid)\n        return result;\n    \n    result.ray_hit.n_dot_v = dot(result.ray_hit.normal, -ray.direction);\n\n    for (int c = 0; c < g_num_point_lights; c++)\n    {\n        vec3 direction = normalize(result.ray_hit.position - g_point_lights[c].position);\n\n        vec3 h = normalize(direction + ray.direction);\n    \n        g_light_desc[c].n_dot_l = dot(result.ray_hit.normal, -direction);\n        g_light_desc[c].n_dot_h = dot(result.ray_hit.normal, h);\n        g_light_desc[c].v_dot_h = dot(ray.direction, -h);\n        g_light_desc[c].color = g_point_lights[c].color;\n    }\n    \n    vec3 color = CalculateLighting( result.ray_hit, result.ray_hit.material );\n    \n    result.color.rgb =  color + \n                        result.ray_hit.material.color.rgb * result.ray_hit.material.emissive +  \n                        result.ray_hit.material.color.rgb * g_ambient_light;\n\n    result.color.w = result.ray_hit.material.color.w;\n    \n    return result;\n}\n\nvec2 DistanceFromLight(vec3 position, vec3 light_position, float light_radius)\n{\n    vec3 delta = light_position - position;\n    vec3 to_light = normalize(delta);\n    \n    float distance = dot(to_light, delta) - light_radius;\n    \n    if (distance > FOG_LIGHTING_MAX_DISTANCE)\n        return vec2(FOG_LIGHTING_MAX_DISTANCE, 0.0);\n    \n    return vec2(distance, 1.0);\n}    \n\nvec3 PointOnPlane( vec3 direction, vec3 position, vec4 plane )\n{\n    float c = dot(-direction, plane.xyz);\n    float adj = dot(plane.xyz, position) + plane.w;\n    float hyp = adj / c;\n\n    return position + direction * hyp;\n}\n\nvec4 TraceFog( Ray ray, float depth )\n{\n    //A plane at 0,1,0,0 separates two levels of fog\n    //the overlap each other between 1 and -1 for blending\n    //below the plane being very dense\n    //above the plane being just dense enough to scatter some light\n    \n    vec4 fog_color = vec4( 0, 0, 0, 0 );\n    \n    vec3 ray_march_start = ray.origin;\n    float length = 0.0;\n\n    float plane_w = 1.0;\n\n    //if we're starting below the plane or we will end up below the plane\n    if (ray_march_start.y < plane_w || ray.direction.y < 0.0)\n    {\n        //if we are above the plane move our ray march start down the ray to the plane\n        //this way we get as many ray march samples as possible in the plane\n        if (ray_march_start.y > plane_w && ray.direction.y < 0.0)\n            ray_march_start = PointOnPlane(ray.direction, ray_march_start, vec4(0, 1, 0, -plane_w));\n        \n        vec3 position = ray_march_start;\n        \n        //ray march the bottom plane\n        for (int i = 0; i < RAYMARCH_FOG_STEPS; i++)\n        {\n            //if we've gone deep enough that we hit whatever object is at this pixel\n            //we have to stop fogging\n            if (dot(position - ray.origin, ray.direction) >= depth)\n                break;\n            \n            float density;\n            \n            //if we're below the plane, calculate the fog\n            if (position.y <= plane_w)\n            {\n                float scale = .001;\n                float coeff = iTime * .005;\n\n                //use t for a slight fade in to our fog\n                float t = saturate((plane_w - position.y) / 2.0);\n                \n                //random noise sampling so the fog isn't so bland\n                float d1 = texture(iChannel0, position.xz * scale + coeff).g;\n                float d2 = texture(iChannel0, position.xz * scale + cos(iTime) * .002).g;\n                density = max(FOG_VOXEL_DENSITY * max(d1,d2), FOG_VOXEL_DENSITY * .25) * t;\n            }\n            else\n                density = 0.0;\n            \n            if (density > 0.0)\n            {                \n                vec3 light_contribution = vec3(0, 0, 0);\n                vec4 voxel_color;\n                \n                //get the distance to each light and accumulate that in our fog\n                for (int k = 0; k < g_num_point_lights; k++)\n                {\n                    vec2 distance_and_occlusion = DistanceFromLight(position, g_point_lights[k].position, g_point_lights[k].radius);\n                    float distance = distance_and_occlusion.x;\n                    float occlusion = distance_and_occlusion.y;\n                    \n                    float dist = distance / FOG_LIGHTING_MAX_DISTANCE;\n                    dist = saturate(dist);\n\n                    float d = 1.0 - dist;\n                    light_contribution += g_point_lights[k].color * d * d * occlusion;\n                }\n\n                voxel_color.rgb = (light_contribution + g_ambient_light) * density;\n                voxel_color.w = density;\n                \n                // accumulate all the voxels into our end fog result\n                fog_color += voxel_color;\n            }\n            \n            length += float(RAYMARCH_FOG_RESOLUTION);\n            position = ray_march_start + ray.direction * length;\n        }\n    }\n    \n    ray_march_start = ray.origin;\n    length = 0.0;\n\n    //now we trace into the top plane\n    plane_w = -1.0;\n    \n    //if we're starting above the plane or will end up above it\n    if (ray_march_start.y > plane_w || ray.direction.y > 0.0)\n    {\n        //if we are above the plane move our ray march start up the ray to the plane\n        //this way we get as many ray march samples as possible in the plane\n        if (ray_march_start.y < plane_w && ray.direction.y > 0.0)\n            ray_march_start = PointOnPlane(ray.direction, ray_march_start, vec4(0, -1, 0, plane_w));\n        \n        vec3 position = ray_march_start;\n\n        for (int i = 0; i < RAYMARCH_FOG_STEPS; i++)\n        {\n            //if we've gone deep enough that we hit whatever object is at this pixel\n            //we have to stop fogging\n            if (dot(position - ray.origin, ray.direction) >= depth)\n                break;\n            \n            float density;\n            \n            if (position.y > plane_w)\n            {\n                //use t for a slight fade in to our fog\n                float t = saturate((position.y - plane_w) / 2.0);\n                density = FOG_VOXEL_DENSITY * .25 * t;\n            }\n            else\n                density = 0.0;\n            \n            if (density > 0.0)\n            {                \n                vec3 light_contribution = vec3(0, 0, 0);\n                vec4 voxel_color;\n                \n                //get the distance to each light and accumulate that in our fog\n                for (int k = 0; k < g_num_point_lights; k++)\n                {\n                    vec2 distance_and_occlusion = DistanceFromLight(position, g_point_lights[k].position, g_point_lights[k].radius);\n                    float distance = distance_and_occlusion.x;\n                    float occlusion = distance_and_occlusion.y;\n                    \n                    float dist = distance / FOG_LIGHTING_MAX_DISTANCE;\n                    dist = saturate(dist);\n\n                    float d = 1.0 - dist;\n                    light_contribution += g_point_lights[k].color * d * d * occlusion;\n                }\n\n                voxel_color.rgb = (light_contribution + g_ambient_light) * density;\n                voxel_color.w = density;\n                \n                // accumulate all the voxels into our end fog result\n                fog_color += voxel_color;\n            }\n            \n            length += float(RAYMARCH_FOG_RESOLUTION);\n            position = ray_march_start + ray.direction * length;\n        }\n    }\n    \n    fog_color.w = saturate(fog_color.w);\n    return fog_color;\n}\n\nvec4 TraceScene( Ray ray )\n{\n    TraceResult result = ProcessRayHit( RayMarch(ray), ray );\n\n    if (false == result.ray_hit.valid)\n        return vec4(0, 0, 0, 10000.0);\n\n    vec4 color;\n    \n    color.rgb = result.color.rgb;\n    color.w = dot(result.ray_hit.position - ray.origin, ray.direction);\n\n    return color;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    Init();\n    \n    vec3 cam_rot = vec3(.25, 0, 0);\n    vec3 cam_pos = vec3(0, 0, -35.0);\n    \n    #if CAMERA == CAMERA_ROTATE\n        cam_rot = vec3(0, iTime * .025, 0);\n    #elif CAMERA == CAMERA_MANUAL\n        cam_rot = vec3(iMouse.y * .02, iMouse.x * .02, 0);\n    #elif CAMERA == CAMERA_SCRIPTED\n        vec3 rot_up = vec3(0.25, 0.0, 0.0);\n        vec3 rot_down = vec3(-0.25, 0.0, 0.0);\n        vec3 pos_up = vec3(0.0, 5.0, -35.0);\n        vec3 pos_down = vec3(0.0,-10.0, -35.0);\n        \n        float t = abs(cos(iTime * .15));\n        cam_pos = mix(pos_up, pos_down, 1.0 - t);\n        cam_rot = mix(rot_up, rot_down, 1.0 - t);\n    #endif\n    \n    \n    Ray ray = CreateRay(cam_pos, cam_rot, fragCoord);\n\n    vec4 pixel_color_and_depth = TraceScene( ray );\n    \n    #ifdef FOG\n        vec4 fog_color = TraceFog( ray, pixel_color_and_depth.w );\n    #else\n        vec4 fog_color = vec4(0.0, 0.0, 0.0, 0.0);\n    #endif\n    \n    fragColor.rgb = saturate(pixel_color_and_depth.rgb * (1.0 - fog_color.w) + fog_color.rgb);\n    fragColor.a = 1.0;\n    \n    fragColor = sqrt(fragColor);\n}\n\n", "image_inputs": [{"id": "4dXGzn", "previewfilepath": "/media/ap/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/lsc3Ds.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "lscGRl", "name": "Fireworks 2016", "author": "BigWIngs", "description": "A quick and dirty fireworks effect. ", "tags": ["2d", "fireworks"], "likes": 68, "viewed": 3791, "date": "1451605803", "time_retrieved": "2024-06-20T18:30:23.684933", "image_code": "// \"Fireworks\" by Martijn Steinrucken aka BigWings - 2015\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n// Email:countfrolic@gmail.com Twitter:@The_ArtOfCode\n\n#define PI 3.141592653589793238\n#define TWOPI 6.283185307179586\n#define S(x,y,z) smoothstep(x,y,z)\n#define B(x,y,z,w) S(x-z, x+z, w)*S(y+z, y-z, w)\n#define saturate(x) clamp(x,0.,1.)\n\n#define NUM_EXPLOSIONS 8.\n#define NUM_PARTICLES 70.\n\n\n// Noise functions by Dave Hoskins \n#define MOD3 vec3(.1031,.11369,.13787)\nvec3 hash31(float p) {\n   vec3 p3 = fract(vec3(p) * MOD3);\n   p3 += dot(p3, p3.yzx + 19.19);\n   return fract(vec3((p3.x + p3.y)*p3.z, (p3.x+p3.z)*p3.y, (p3.y+p3.z)*p3.x));\n}\nfloat hash12(vec2 p){\n\tvec3 p3  = fract(vec3(p.xyx) * MOD3);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nfloat circ(vec2 uv, vec2 pos, float size) {\n\tuv -= pos;\n    \n    size *= size;\n    return S(size*1.1, size, dot(uv, uv));\n}\n\nfloat light(vec2 uv, vec2 pos, float size) {\n\tuv -= pos;\n    \n    size *= size;\n    return size/dot(uv, uv);\n}\n\nvec3 explosion(vec2 uv, vec2 p, float seed, float t) {\n\t\n    vec3 col = vec3(0.);\n    \n    vec3 en = hash31(seed);\n    vec3 baseCol = en;\n    for(float i=0.; i<NUM_PARTICLES; i++) {\n    \tvec3 n = hash31(i)-.5;\n       \n\t\tvec2 startP = p-vec2(0., t*t*.1);        \n        vec2 endP = startP+normalize(n.xy)*n.z;\n        \n        \n        float pt = 1.-pow(t-1., 2.);\n        vec2 pos = mix(p, endP, pt);    \n        float size = mix(.01, .005, S(0., .1, pt));\n        size *= S(1., .1, pt);\n        \n        float sparkle = (sin((pt+n.z)*100.)*.5+.5);\n        sparkle = pow(sparkle, pow(en.x, 3.)*50.)*mix(0.01, .01, en.y*n.y);\n      \n    \t//size += sparkle*B(.6, 1., .1, t);\n        size += sparkle*B(en.x, en.y, en.z, t);\n        \n        col += baseCol*light(uv, pos, size);\n    }\n    \n    return col;\n}\n\nvec3 Rainbow(vec3 c) {\n\t\n    float t=iTime;\n    \n    float avg = (c.r+c.g+c.b)/3.;\n    c = avg + (c-avg)*sin(vec3(0., .333, .666)+t);\n    \n    c += sin(vec3(.4, .3, .3)*t + vec3(1.1244,3.43215,6.435))*vec3(.4, .1, .5);\n    \n    return c;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\tuv.x -= .5;\n    uv.x *= iResolution.x/iResolution.y;\n    \n    float n = hash12(uv+10.);\n    float t = iTime*.5;\n    \n    vec3 c = vec3(0.);\n    \n    for(float i=0.; i<NUM_EXPLOSIONS; i++) {\n    \tfloat et = t+i*1234.45235;\n        float id = floor(et);\n        et -= id;\n        \n        vec2 p = hash31(id).xy;\n        p.x -= .5;\n        p.x *= 1.6;\n        c += explosion(uv, p, id, et);\n    }\n    c = Rainbow(c);\n    \n    fragColor = vec4(c, 1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc-by-nc-sa-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/lscGRl.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "lscGWX", "name": "Wrinkled circle", "author": "Bart_Verheijen", "description": "started with a circle... and applied multiple distortions...", "tags": ["2d"], "likes": 6, "viewed": 250, "date": "1452430104", "time_retrieved": "2024-06-20T18:30:23.933004", "image_code": "// Created by Bart Verheijen 2016\n// License Creative Commons Attribution-ShareAlike 3.0 Unported License.\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 p = -1.0 + 2.0 * uv;\n    p *= iResolution.xy / min(iResolution.x,iResolution.y);\n\n    p.x += 0.1*sin(iTime/31.0)*sin(iTime) * sin(p.y*11.0);\n    p.y += 0.1*sin(iTime/31.0)*sin(iTime*0.8) * sin(p.x*13.0);\n\n    float d = abs(0.9-length(p))-0.27;\n    float a = atan(p.y,p.x);\n    //fragColor = vec4(a/3.14,0.5-d,0,1);\n\n    d += 0.04*sin(a*15.0);    \n    d += 0.075*sin(iTime);\n    a += 2.0*sin(iTime/5.0);\n    d += 0.04*sin(a*9.0);\n    \n    fragColor = vec4(1.0-abs(d*sin(a)*70.0),1.0-abs(d*cos(a)*70.0),abs(2.0*d)*(1.0-length(p)/1.25),1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "gpl-3.0-plus OR cc-by-sa-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/lscGWX.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "lsd3Rl", "name": "Brush blending problem", "author": "kig", "description": "Trying to draw a good-looking self-intersecting soft brushstroke. The stroke alpha should cap at its max component alpha. The use case is painting flat areas of color with pressure-controlled brush opacity.", "tags": ["2d", "hack"], "likes": 4, "viewed": 308, "date": "1451840481", "time_retrieved": "2024-06-20T18:30:23.933197", "image_code": "void strokeBlend(\n    vec3 srcColor, float srcAlpha,\n    vec3 dstColor, float dstAlpha,\n    out vec3 color, out float alpha\n)\n{\n    alpha = srcAlpha + (1.0-srcAlpha)*dstAlpha;\n    color = srcColor*srcAlpha + dstColor*dstAlpha*(1.0-srcAlpha);\n    alpha = max(max(dstAlpha, srcAlpha), alpha - srcAlpha * dstAlpha);\n    color /= alpha;\n\n    color = clamp(vec3(0.0), vec3(1.0), color);\n}\n\nvec4 layerBlend( vec3 bgColor, float bgAlpha, vec3 strokeColor, float strokeAlpha )\n{\n    return vec4(\n        strokeColor * strokeAlpha + bgColor * (1.0-strokeAlpha),\n        strokeAlpha + (1.0-strokeAlpha)*bgAlpha\n   \t);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    vec3 bgColor = texture(iChannel0, uv).g * vec3(0.4);\n    float bgAlpha = 1.0;\n\n    vec3 color1 = vec3(1.0, 1.0, 0.0);\n    float strokeAlpha1 = 0.5;\n    float brushAlpha1 = smoothstep(0.5, 0.9, 1.0 - abs(2.0*(uv.y+sin(uv.x*3.0+iTime)*0.1 - 0.3)));\n\n    vec3 color2 = vec3(1.0, 1.0, 1.0);\n    float strokeAlpha2 = 0.25;\n    float brushAlpha2 = smoothstep(0.5, 0.9, 1.0 - abs(4.0*(uv.x - 0.3)));\n\n    vec3 color3 = vec3(0.0, 1.0, 1.0);\n    float strokeAlpha3 = 1.0;\n    float brushAlpha3 = smoothstep(0.5, 0.9, 1.0 - abs(4.0*(uv.x+sin(uv.y*3.0+iTime)*0.1 - 0.7)));\n\n\n    vec3 strokeColor;\n    float strokeAlpha;\n    \n\tstrokeBlend(\n        color1, strokeAlpha1*brushAlpha1, // yellow on top of cyan\n        color3, strokeAlpha3*brushAlpha3,\n        strokeColor, strokeAlpha\n    );\n\n    strokeBlend(\n        color2, strokeAlpha2*brushAlpha2, // grey on top of red\n        strokeColor, strokeAlpha,\n        strokeColor, strokeAlpha\n    );\n    \n    // Blend 4 cyan strokes\n    for (int i=0; i<4; i++) {\n        vec3 color4 = vec3(0.0, 1.0, 1.0);\n        float strokeAlpha4 = 0.5;\n        float brushAlpha4 = smoothstep(0.5, 0.9, 1.0 - abs(4.0*(uv.x+sin(uv.y*3.0+iTime)*0.1 - 1.2-(0.07+0.1*sin(iTime))*float(i))));\n        strokeBlend(\n            color4, strokeAlpha4*brushAlpha4,\n            strokeColor, strokeAlpha,\n            strokeColor, strokeAlpha\n        );\n    }\n\n    fragColor = layerBlend(bgColor, bgAlpha, strokeColor, strokeAlpha);\n}", "image_inputs": [{"id": "XsfGRn", "previewfilepath": "/media/ap/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/lsd3Rl.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "lsdGDs", "name": "You spin me right round", "author": "kodde", "description": "My first attempt at a shader here on Shadertoy. I'm still quite new to creating shaders by code.", "tags": ["trippy", "spin", "twirl"], "likes": 6, "viewed": 316, "date": "1452859878", "time_retrieved": "2024-06-20T18:30:24.199859", "image_code": "//This palette solution is from http://iquilezles.org/www/articles/palettes/palettes.htm\nvec3 colorPalette(in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d) {\n\treturn a+b*cos(6.28318530718*(c*t+d));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    \n    //Offseting 0,0 to center of screen.\n    vec2 cUV = uv - 0.5;\n    //Scaling U with screen resolution aspect ratio to get circular shapes and not oval shapes.\n    cUV.x *= iResolution.x/iResolution.y;\n    \n    //Building my own normalized atan2 solution as this does not seem available?\n    float f;\n    if(cUV.y > 0.0)\n    {\n        f = atan(cUV.x/cUV.y) / 6.2831 + 0.25;\n    }\n    else\n    {\n        f = atan(cUV.x/cUV.y) / 6.2831 + 0.75;\n    }\n    \n    //Getting the length from center and animating this to cycles between -8 to +8\n    float l = length(cUV);\n    float lm = sin(iTime)*8.0;\n    \n    //Adding time, modulus to keep it in 0-1 color spectrum, modifiying the swiping line with the length from center and it's animation.\n    float a = mod((l*lm)+f-iTime,1.0);\n    a *= smoothstep(.0,abs(lm)*.004,abs(mod((l*lm)+f-iTime+.5,1.0)-.5));\n    \n    vec3 c = colorPalette(iTime*0.05+l*0.3, vec3(0.5,0.5,0.5), vec3(0.5,0.5,0.5), vec3(1.0,1.0,1.0), vec3(0.0,0.33,0.67)) * a;\n\n    fragColor = vec4(c,1.0);\n}", "image_inputs": [{"id": "4dXGWn", "previewfilepath": "https://soundcloud.com/spade/winter-is-coming-mix", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "https://soundcloud.com/spade/winter-is-coming-mix", "ctype": "musicstream"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/lsdGDs.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "lsdGWB", "name": "grimvoid", "author": "netgrind", "description": "click and drag the mouse, mouse y determines audio reactivity\nforked from https://www.shadertoy.com/view/llfSzH", "tags": ["noise", "raymarch", "blackandwhite", "mic", "grim"], "likes": 6, "viewed": 583, "date": "1452218791", "time_retrieved": "2024-06-20T18:30:24.199859", "image_code": "//forked from https://www.shadertoy.com/view/llfSzH\n\n\nfloat mic(float i, float j){\n return texture(iChannel0,vec2(i,j)).r;   \n}\nvoid push(inout vec2 p, float i){\n    float a = atan(p.y,p.x);\n    float d = length(p.xy);\n    d+=d*i;\n    p.y = sin(a)*d;\n    p.x = cos(a)*d;\n}\n\nvoid mainImage( out vec4 f, vec2 u )\n{\n    float s = 1.;\n    vec3 r = vec3(s*.5, iTime*.1,0.) + s*.5,\n         R = iResolution ;\n    \n    u-= R.xy*.5;\n    float d = length(u/R.y)*2.;\n    float a = sin(iTime*3.1415*.0125);\n    u*= mat2(d,a,-a,d);\n    u+=R.xy*.5;\n    vec2 v = iMouse.xy/iResolution.xy;\n    v = 1.0-v;\n    v.y*=4.;\n    \n    for( float i = .5; i > .0 ; i-=.015 ) {\n        float m = mic(mod(i*2.,v.x),.0)*v.y;\n        f.a = length( mod(r,s) - (s*.5) ) - .2;\n        r += vec3( (u+u-R.xy)/R.y, 2. ) * (.2)*f.a; \n        ;\n        r.xz -= vec2(s*.5);\n        push((r.xz),m*.1);\n        r.xz += vec2(s*.5);\n        \n        f.r=abs(sin(i));\n        if( f.a < .001 ) break ;\n    }\n    f.rgb = vec3(pow(f.r*2.5,1.)); \n}", "image_inputs": [{"id": "XdXGRr", "previewfilepath": "/presets/mic.png", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/presets/mic.png", "ctype": "mic"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/lsdGWB.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "lsG3Dz", "name": "Spiraling Metablobs", "author": "Emil", "description": "Testing smoothstep with distance function", "tags": ["raymarching", "spiral", "metaball"], "likes": 7, "viewed": 184, "date": "1453998049", "time_retrieved": "2024-06-20T18:30:24.205803", "image_code": "float map(vec3 p){\n    float zmodval = 5.0;\n    float xmodval = 11.0;\n    float stepz = p.z;\n    p.z = mod(p.z+zmodval*0.5, zmodval)-zmodval*0.5;\n    p.x = mod(p.x+xmodval*0.5, xmodval)-xmodval*0.5;\n    p.y = mod(p.y+xmodval*0.5, xmodval)-xmodval*0.5;\n    stepz -= p.z;\n    float r = 0.0;// = smoothstep(0.0,1.0,(length(p)));\n    float ma = 0.7+0.2*sin(iTime*0.2);\n    const float maxval = 30.0;\n    float spinval;\n    for(float i = 5.0; i<=maxval; i++){\n        spinval = i*ma+(iTime+stepz)*0.2;\n    \tr += smoothstep(0.0,0.3+i*0.04+0.2*(sin(iTime)),(length(p-(i*0.15)*vec3(sin(spinval),cos(spinval),0.0))));\n    }\n    \n    r -= maxval - 4.5;\n    \n    return r;\n}\n\nfloat trace(vec3 o, vec3 r){\n    float t = 0.0;\n    const int maxSteps = 32;\n    for (int i = 0; i < maxSteps; i++){ \n        vec3 p = o + r * t;\n        float d = map(p);\n        t += d * 0.9;\n        if(d<0.001) break;\n    }\n    return t;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec3 r = normalize(vec3(2.*fragCoord.xy - iResolution.xy, iResolution.y)); \n    \n    vec3 o = vec3(0.0,0.0,-3.0+iTime*0.6);\n    \n    float t = trace(o,r);\n    float fog = 1.0 / (3.0 + t * t * 0.06);\n    vec3 fc = vec3(fog);\n    \n\tfragColor = vec4(fc,1.0)*2.0*vec4(1.2,1.6,1.8,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/lsG3Dz.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "lsK3R1", "name": "Atarty Vidya Musak", "author": "losergenerated", "description": "WIP: Attempt at re-creating Atari Video Music. Click once to start.", "tags": ["2d", "oldschool", "audio"], "likes": 1, "viewed": 569, "date": "1453329365", "time_retrieved": "2024-06-20T18:30:24.205803", "image_code": "// Created by inigo quilez - iq/2013\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n\nconst float color_res = 2.0;\n\nconst vec3 color1 = vec3(0.5, 0.5, 0.5);\nconst vec3 color2 = vec3(0.5, 0.5, 0.5);\nconst vec3 color3 = vec3(1.0, 1.0, 1.0);\nconst vec3 color4 = vec3(0.00, 0.33, 0.67);\n\n\nvec3 palette( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d )\n{\n    return ceil(color_res * (a + b*cos(6.28318*(c*t+d)))) / color_res;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    float scroll = iMouse.y / iResolution.y * 2.0 + .001;\n    float repeats = iMouse.x / iResolution.x * 8.0 + .001;\n    // create pixel coordinates\n\tvec2 uv = (fragCoord.xy / iResolution.xy);\n    uv.y -= scroll * iTime;\n    uv.x -= scroll * iTime;\n    float d = texture( iChannel1, vec2(uv.x,uv.y)).x * .005;\n\n\n    uv.x = uv.x * iResolution.z;\n\n    uv = mod(uv,1.0/repeats);\n    uv -= 0.5/repeats;\n\n    uv = abs(uv);\n\n    d += (uv.x + uv.y) * repeats;\n\n\n\t\n\t// first texture row is frequency data\n\tfloat fft  = texture( iChannel0, vec2(d,0.25) ).x;\n\n    // second texture row is the sound wave\n\tfloat wave = texture( iChannel0, vec2(d,0.75) ).x;\n\n\t// convert frequency to colors\n\tvec3 col = palette(fft, color1, color2, color3, color4);\n\n    col *= .7 - d*d;\n\n\n\n\t// output final color\n\tfragColor = vec4(col,1.0);\n}\n", "image_inputs": [{"id": "4df3Rn", "previewfilepath": "/media/ap/3c33c415862bb7964d256f4749408247da6596f2167dca2c86cc38f83c244aa6.mp3", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/3c33c415862bb7964d256f4749408247da6596f2167dca2c86cc38f83c244aa6.mp3", "ctype": "music"}, {"id": "Xsf3Rr", "previewfilepath": "/media/ap/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg", "channel": 1, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc-by-nc-sa-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/lsK3R1.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "lsKGDz", "name": "Amorphous Rainbow Blob(s)", "author": "brejep", "description": "Ray marched blob. Copied from iq live coding. http://on-demand.gputechconf.com/gtc/2014/video/S4550-shadertoy-fragment-shader.mp4. I added the rainbow palette.", "tags": ["proceduralraymarchblob"], "likes": 14, "viewed": 355, "date": "1454111034", "time_retrieved": "2024-06-20T18:30:24.205803", "image_code": "\nvec3 a = vec3(0.5, 0.5, 0.5);\nvec3 b = vec3(0.5, 0.5, 0.5);\nvec3 c = vec3(1.0, 1.0, 1.0);\nvec3 d = vec3(0.0, 0.33, 0.67);\n\nvec3 palette(in float val, vec3 u, vec3 v, vec3 w, vec3 x) {\n    return u + v * cos( 6.28318531 * (w * (val + x)));\n}\n\nfloat map(in vec3 p) {\n    vec3 q = mod(p+2.0, 4.0) - 2.0;\n\tfloat d0 = length(q) - 1.0;\n    d0 += 0.1 * sin(10.0 * p.x) * sin(10.0 * p.y + 10.0 * iTime) * sin(10.0 * p.z);\n    float d1 = p.y + 1.0;\n    \n    float k = 1.225;\n    float h = clamp(0.5 + 0.5 * (d0 - d1)/k, 0.0, 1.0);\n    return mix(d0, d1, h) - k * h * (1.0 -h);\n}\n\nvec3 calcNormal( in vec3 p ) {\n    vec2 e = vec2(0.0001, 0.0);\n    \n\treturn normalize( vec3( \n        map(p+e.xyy) - map(p-e.xyy),\n        map(p+e.yxy) - map(p-e.yxy),\n        map(p+e.yyx) - map(p-e.yyx)\n    ));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = (2.0*fragCoord.xy-iResolution.xy) / iResolution.y;\n    \n    vec3 rayOrigin = vec3(0.0, 0.0, 2.0);\n    vec3 rayDirection = normalize(vec3(uv, -1.0));\n    \n    vec3 col = vec3(0.22);\n    \n    float h = 1.0;\n    float t = 0.0;\n    float tmax = 20.0;\n    \n    for(int i = 0; i<100; i++) {\n        if(h < 0.0001 || t > tmax) { break; }\n     \th = map(rayOrigin + t * rayDirection);\n        t += h;\n    }\n    \n    vec3 lig = vec3(0.5773);\n    if(t < tmax) {\n        vec3 pos = rayOrigin + t * rayDirection;\n        vec3 norm = calcNormal(pos);\n        col = vec3(0.98); // background colour\n        // lighting\n        col = palette(t, vec3(0.5), vec3(0.5), vec3(1.0), vec3(0.0, 0.33, 0.67)) * clamp(dot(norm, lig), 0.0, 1.0);\n        col += vec3(0.2, 0.3, 0.4) * clamp(norm.y, 0.0, 1.0);\n       \tcol += vec3(1.0, 0.7, 0.2) * clamp(1.0 + dot(rayDirection, norm), 0.0, 1.0);\n        col *= 0.8;\n        //fog\n        col *= exp(-0.1 * t);\n    }\n    \n\tfragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/lsKGDz.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "lsKGzz", "name": "Temporal Gabor noise", "author": "MichelPaulissen", "description": "Gabor noise shader based off the shader of the \"Filtering Solid Gabor Noise\" paper by Lagae et al. Replaced the prng by a webgl-friendly version.\nThis is a 2d slice of solid gabor noise, and the sin wave of the gabor kernel is shifted over time.", "tags": ["temporalgabornoise"], "likes": 11, "viewed": 463, "date": "1453130111", "time_retrieved": "2024-06-20T18:30:25.090678", "image_code": "const float pi = 3.14159265358979323846;\n\nstruct noise_prng\n{\n\tvec3 x_;\n};\n\nfloat noise_prng_rand( in vec3 x )\n{\n    vec3 p = floor(x);\n\t\n\tvec2 uv = (p.xy+vec2(37.0,17.0)*p.z);\n\tvec3 rgb = texture( iChannel0, (uv+0.5)/256.0, -100.0 ).yxz;\n\treturn rgb.x * (255.0 / 256.0) + rgb.y * (1.0 / 255.0) + rgb.z * (1.0 / (256.0*256.0));\n}\n\nfloat noise_prng_uniform_0_1(inout noise_prng this_)\n{\n    float n = noise_prng_rand(this_.x_);\n\tthis_.x_ += floor( (n + 0.1) * vec3(1093.2745987379, 1931.8367497369, 1439.6765789332));\n    this_.x_ = mod(this_.x_, 1024.0);\n    return n;\n}\n\nfloat noise_prng_uniform(inout noise_prng this_, const in float min_, const in float max_)\n{\n\treturn min_ + (noise_prng_uniform_0_1(this_) * (max_ - min_));\n}\n\nfloat noise_gabor_kernel_3d(const in float w, const in vec3 f, const in float phi, const in float a, const in vec3 x)\n{\n    float g = exp(-pi * (a * a) * dot(x, x));\n    float h = cos((2.0 * pi * dot(f, x)) + phi);\n    return w * g * h;\n}\n\nstruct noise\n{\n    float lambda_;\n    float r_;\n    vec3 omega_;\n    float a_;\n};\n    \nvoid noise_constructor(out noise this_, const in float lambda, const in float r, const in vec3 omega, const in float a)\n{\n    this_.lambda_ = lambda;\n    this_.r_ = r;\n    this_.omega_ = omega;\n    this_.a_ = a;\n}\n\nvoid noise_sample(const in noise this_, inout noise_prng prng, out float w, out vec3 omega, out float phi, out float a)\n{\n    w = 1.0;\n    omega = this_.omega_;\n    phi = noise_prng_uniform(prng, 0.0, 2.0 * pi);\n    a = this_.a_;\n}\n\nfloat phi_add = 0.0;\n\n#define IMPULSES 8\n\nfloat freq = 0.03125;\n\nfloat rad = 0.125;\n\nfloat noise_cell(const in noise this_, const in vec3 c, const in vec3 x_c)\n{\n    noise_prng prng;\n    prng.x_ = c;\n    // webgl can't take a non const here, but the scale of the result is now wrong\n  //uint number_of_impulses = noise_prng_poisson(prng, this_.lambda_ * this_.r_ * this_.r_ * this_.r_);\n    const int number_of_impulses = IMPULSES;\n    float sum = 0.0;\n    for (int i = 0; i < number_of_impulses; ++i) {\n        vec3 x_i_c = vec3(noise_prng_uniform_0_1(prng), noise_prng_uniform_0_1(prng), noise_prng_uniform_0_1(prng));\n        vec3 x_k_i = this_.r_ * (x_c - x_i_c);\n        float w_i; vec3 omega_i; float phi_i, a_i;\n        noise_sample(this_, prng, w_i, omega_i, phi_i, a_i);\n        \n        // round (be careful to not call on 0,0)\n        omega_i.xy = normalize(c.xy + 0.0001) * freq;\n        //float d = 2.0 * pi * (-rad*0.5 + rad * noise_prng_uniform_0_1(prng));\n        //omega_i.xy = vec2(sin(d),cos(d)) * freq;\n        \n        if (dot(x_k_i, x_k_i) < (this_.r_ * this_.r_)) {\n            sum += noise_gabor_kernel_3d(w_i, omega_i, phi_i + phi_add, a_i, x_k_i);\n        }\n    }\n    return sum;\n}\n\nfloat noise_grid(const in noise this_, const in vec3 x_g)\n{\n    vec3 int_x_g = floor(x_g);\n    ivec3 c = ivec3(int_x_g);\n    vec3 x_c = x_g - int_x_g;\n    float sum = 0.0;\n    for (int i2 = -1; i2 <= +1; ++i2) {\n        for (int i1 = -1; i1 <= +1; ++i1) {\n            for (int i0 = -1; i0 <= +1; ++i0) {\n                ivec3 c_i = c + ivec3(i0, i1, i2);\n                vec3 iv = vec3(i0, i1, i2);\n                vec3 x_c_i = x_c - iv;\n                sum += noise_cell(this_, vec3(c_i.x,c_i.y,c_i.z), x_c_i);\n            }\n        }\n    }\n    return sum / sqrt(this_.lambda_);\n}\n\nfloat noise_evaluate(const in noise this_, const in vec3 x)\n{\n    vec3 x_g = x / this_.r_;\n    return noise_grid(this_, x_g);\n}\n\nfloat noise_variance(const in noise this_)\n{\n    return (1.0 / (4.0 * sqrt(2.0) * (this_.a_ * this_.a_ * this_.a_)));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //freq = iMouse.y / 1000.0;\n    float noise_frequency = freq;\n    vec3 noise_orientation = vec3(normalize((iMouse.xy - 1.0 / iResolution.xy) - 100.0),0);\n    float noise_bandwidth = 1.0;\n    //noise_bandwidth = iMouse.y / 100.0;\n    float noise_truncate = 0.02;\n    // this is the constant the other impulses calculation needs to be based off to get a correctly scaled result\n    float noise_impulses = float(IMPULSES) * 2.0;\n    vec3 noise_omega = noise_frequency * noise_orientation;\n    float noise_a = (noise_frequency * ((exp2( noise_bandwidth) - 1.0) / (exp2( noise_bandwidth) + 1.0))) * sqrt(pi / log(2.0));\n    float noise_r = sqrt(-log(noise_truncate) / pi) / noise_a;\n    float noise_lambda = noise_impulses / ((4.0 / 3.0) * pi * (noise_r * noise_r * noise_r));\n    \n    //rad = clamp(iMouse.x / 1000.0, 0.0, 0.5);\n    \n    noise ns;\n    noise_constructor(ns, noise_lambda, noise_r, noise_omega, noise_a); \n    \n    phi_add = mod(-iTime, pi*2.0);\n    \n\tvec2 uv = fragCoord.xy -50.5;\n    vec3 nlut = vec3(uv,iTime*0.0);\n    //nlut.x -= iTime * 5.5;\n    \n    float noise = 0.0;\n    //noise += noise_evaluate(ns, nlut);\n    //noise += noise_evaluate(ns, nlut * 2.0) * 0.5;\n    noise += noise_evaluate(ns, nlut * 0.5) * 2.0;\n    //noise += noise_evaluate(ns, nlut * 0.25);\n    noise /= 3.0; // manually scale down\n\n    float scale = 0.5 / (3.0 * sqrt(noise_variance(ns)));\n    float bias = 0.5;\n    float color = bias + (scale * noise);\n    \n    fragColor = vec4(vec3(color),1.0);\n}", "image_inputs": [{"id": "Xsf3zn", "previewfilepath": "/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/lsKGzz.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "lstGDf", "name": "Blue eyes", "author": "licson", "description": "-", "tags": ["2d"], "likes": 15, "viewed": 180, "date": "1452603983", "time_retrieved": "2024-06-20T18:30:25.090678", "image_code": "#define PI 3.141592653589793\n#define TWO_PI 6.283185307179586\n#define N 10\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy - iResolution.xy / 2.0;\n    uv = uv / min(iResolution.x, iResolution.y) * 10.0;\n    \n    float col = 0.0;\n    float a = 0.0;\n    float b = 0.0;\n    for(int i = 0; i < N; i++){\n        a = iTime * 0.04 + 55.0;\n        b = a * float(i);\n        col += cos(TWO_PI * (uv.x * cos(b) + uv.y * tan(b) * cos(b))) * max(sin(b), -0.5);\n    }\n    \n    col /= float(N);\n    fragColor = vec4(2.0 * col, 2.0 * (col * 8.0 * tan(sin(col))), 2.0 * (col * 10.0 * tan(col)), 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/lstGDf.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "lstGRs", "name": "Window Space Implicit Surfaces", "author": "paniq", "description": "Demos how to use bisection using interval arithmetic to interrogate an implicit surface in window/frustum space. Features implicit frustum culling, backfacing gradient culling and detecting fully occluded cells (for filling a hierarchical z-buffer).", "tags": ["implicit", "frustum", "window", "bisection", "arithmetic", "quadtree", "interval"], "likes": 22, "viewed": 1246, "date": "1451870196", "time_retrieved": "2024-06-20T18:30:26.175741", "image_code": "// originally written in Nonelang and auto-translated to GLSL, \n// sorry for the mess ;-)\n\nvec2 u_resolution;\nfloat u_time;\n\nvec2 _2986 (float near, float far) {\n    return vec2(far + near, (-2.000000 * far) * near) / (far - near);\n}\nfloat outline (float d) {\n    return 1.000000 - smoothstep(0.000000, 3.000000 / u_resolution . y, abs(d));\n}\nfloat crossline (vec2 p) {\n    p = abs(p);\n    float minp;\n    minp = min(p . x, p . y);\n    float maxp;\n    maxp = (p . x + p . y) - minp;\n    return max(maxp - 1.000000, minp);\n}\nvec2 ia_div (vec2 a, vec2 b) {\n    vec4 q;\n    q = vec4(a . x / b, a . y / b);\n    return vec2(min(min(min(q . x, q . y), q . z), q . w), max(max(max(q . x, q . y), q . z), q . w));\n}\nvec2 _44 (vec2 a, float b) {\n    return a - vec2(b);\n}\nvec2 _51 (vec2 a, vec2 b) {\n    vec4 q;\n    q = a . xxyy * b . xyxy;\n    return vec2(min(min(min(q . x, q . y), q . z), q . w), max(max(max(q . x, q . y), q . z), q . w));\n}\nvec2 _32 (vec2 a, float b) {\n    return a + b;\n}\nvec2 _29 (vec2 a, vec2 b) {\n    return a + b;\n}\nvec2 _57 (float a, vec2 b) {\n    vec2 q;\n    q = a * b . xy;\n    return vec2(min(q . x, q . y), max(q . x, q . y));\n}\nvoid _69 (mat2 m, vec2 x, vec2 y, inout vec2 ox, inout vec2 oy) {\n    ox = _29(_57(m[0][0], x), _57(m[1][0], y));\n    oy = _29(_57(m[0][1], x), _57(m[1][1], y));\n}\nvec2 _11 (vec2 a, vec2 b) {\n    return vec2(min(a . x, b . x), min(a . y, b . y));\n}\nvec2 _20 (vec2 a, vec2 b) {\n    return vec2(max(a . x, b . x), max(a . y, b . y));\n}\nvec2 ia_unm (vec2 a) {\n    return-a . yx;\n}\nvec2 ia_abs (vec2 a) {\n    if (a . x >= 0.000000)\n        return a;\n    else if (a . y < 0.000000)\n        return ia_unm(a);\n    else\n        return vec2(0.000000, max(-a . x, a . y));\n}\nvec2 ia_sqrt (vec2 a) {\n    return sqrt(a);\n}\nvec2 ia_pow2 (vec2 a) {\n    vec2 q;\n    q = a * a;\n    if (a . x >= 0.000000)\n        return q;\n    else if (a . y < 0.000000)\n        return q . yx;\n    else\n        return vec2(0.000000, max(q . x, q . y));\n}\nvec2 circle_ia (vec2 x, vec2 y, vec2 r) {\n    return _44(ia_sqrt(_29(ia_pow2(x), ia_pow2(y))), r . x);\n}\nvec2 surface (mat2 mtx, vec2 x, vec2 y) {\n    y = _44(y, 0.500000);\n    y = _32(y, mix(0.500000, -3.000000, (cos(u_time) * 0.500000) + 0.500000));\n    x = _32(x, sin(u_time));\n    _69(mtx, x, y, x, y);\n    return _11(_44(_20(ia_abs(x), ia_abs(y)), 0.600000 * 0.400000), _20(circle_ia(x, y, vec2(0.600000)), ia_unm(circle_ia(x, y, vec2(0.600000 * 0.500000)))));\n}\nbool ia_contains (vec2 a, float t) {\n    return(t >= a . x) && (t <= a . y);\n}\nvec2 _63 (vec2 a, float b) {\n    vec2 q;\n    q = b * a . xy;\n    return vec2(min(q . x, q . y), max(q . x, q . y));\n}\nvec2 _38 (vec2 a, vec2 b) {\n    return a - b . yx;\n}\nvec2 gradient_limit (mat2 mtx, vec2 x, vec2 y, vec2 d, float eps) {\n    vec2 dx;\n    dx = _63(_38(surface(mtx, _32(x, eps), y), surface(mtx, _44(x, eps), y)), 1.000000 / (2.000000 * eps));\n    vec2 dy;\n    dy = _63(_38(surface(mtx, x, _32(y, eps)), surface(mtx, x, _44(y, eps))), 1.000000 / (2.000000 * eps));\n    return _29(_63(dx, d . x), _63(dy, d . y));\n}\nvec4 trace_tree_ia (mat2 mtx, vec2 p) {\n    float near;\n    near = 0.500000;\n    vec2 coeffs;\n    coeffs = _2986(near, 100.000000);\n    float b;\n    b = 0.000000;\n    float s;\n    s = 1.000000;\n    p . y = p . y + 1.000000;\n    // scaling factor\n    p = p * 2.0;\n    p . y = p . y + near;\n    vec2 q;\n    q = vec2(p . x / p . y, ((p . y * coeffs . x) + coeffs . y) / p . y);\n    vec2 c;\n    c = vec2(0.000000);\n    float L;\n    L = 0.000000;\n    float cf;\n    cf = mtx[0][0];\n    float sf;\n    sf = mtx[0][1];\n    vec2 iax;\n    iax = vec2(0.000000);\n    vec2 iay;\n    iay = vec2(0.000000);\n    vec2 vpos;\n    vpos = vec2(0.000000);\n    vec4 vcol;\n    vcol = vec4(0.000000);\n    if (max(abs(q . x), abs(q . y)) < 1.000000) {\n        {\n            for (int i = 0; i < 11; ++i) {\n                {\n                    b = b + outline(crossline(q) * s);\n                }\n                {\n                    s = s * 0.500000;\n                }\n                vec2 o;\n                o = (step(vec2(0.000000), q) * 2.000000) - 1.000000;\n                q = (q * 2.000000) - o;\n                c = c + (o * s);\n                iax = vec2(c . x - s, c . x + s);\n                iay = vec2(c . y - s, c . y + s);\n                vec2 w;\n                w = ia_div(vec2(coeffs . y), _44(iay, coeffs . x));\n                iax = _51(iax, w);\n                iay = _51(iay, w);\n                vec2 va;\n                va = vec2(c . x, -1.000000) * (coeffs . y / (-1.000000 - coeffs . x));\n                vec2 vb;\n                vb = vec2(c . x, 1.000000) * (coeffs . y / (1.000000 - coeffs . x));\n                vec2 vq;\n                vq = c * (coeffs . y / (c - coeffs . x));\n                vpos = normalize(va - vb);\n                vec2 d2;\n                d2 = surface(mtx, iax, iay);\n                if (d2 . y <= 0.000000) {\n                    vcol = vcol + vec4(0.000000, 1.000000, 0.000000, 1.000000);\n                }\n                if (ia_contains(d2, 0.000000)) {\n                    vec2 g2;\n                    g2 = gradient_limit(mtx, iax, iay, vpos, 0.050000);\n                    float gc;\n                    gc = (g2 . x + g2 . y) * 0.500000;\n                    if (g2 . y > 0.000000) L = L + 1.0;\n                    else {\n                        break;\n                    }\n                } else {\n                    break;\n                }\n            }\n        }\n    }\n    return vcol + ((L / 11.000000) * vec4(1.000000));\n}\nfloat circle_l2 (vec2 p, vec2 r) {\n    return(length(p / r) - 1.000000) * min(r . x, r . y);\n}\nvec4 frag () {\n    vec2 p;\n    p = ((2.000000 * gl_FragCoord . xy) - u_resolution) / u_resolution . y;\n    float L;\n    L = 0.000000;\n    vec4 M;\n    M = vec4(0.000000);\n    float N;\n    N = 0.000000;\n    float a;\n    a = u_time * 0.300000;\n    float cf;\n    cf = cos(a);\n    float sf;\n    sf = sin(a);\n    mat2 mtx;\n    mtx = mat2(cf, sf, -sf, cf);\n    M = trace_tree_ia(mtx, p);\n    float od;\n    od = circle_l2(p, vec2(0.600000));\n    return 0.000000 + M;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    u_resolution = iResolution.xy;\n    u_time = iTime;\n\tfragColor = frag();\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/lstGRs.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "lstGWl", "name": "MyRayTracerVer1.0.0", "author": "Tacoa", "description": "Hello, world.", "tags": ["ray"], "likes": 0, "viewed": 130, "date": "1452792756", "time_retrieved": "2024-06-20T18:30:26.175741", "image_code": "struct Ray{\n\tvec3 origin;\n\tvec3 direction;\n};\n\nstruct Sphere{\n\tfloat radius;\n\tvec3  position;\n\tvec3  color;\n};\n\nstruct Intersection{\n\tbool hit;\n\tvec3 hitPoint;\n\tvec3 normal;\n\tvec3 color;\n};\n\nIntersection intersectSphere(Ray R, Sphere S){\n\tIntersection i;\n\tvec3  a = R.origin - S.position;\n\tfloat b = dot(a, R.direction);\n\tfloat c = dot(a, a) - (S.radius * S.radius);\n\tfloat d = b * b - c;\n\tif(d > 0.0){\n\t\tfloat t = -b - sqrt(d);\n\t\tif(t > 0.0){\n\t\t\ti.hit = true;\n\t\t\ti.hitPoint = R.origin + R.direction * t;\n\t\t\ti.normal = normalize(i.hitPoint - S.position);\n\t\t\tfloat d = clamp(dot(normalize(vec3(1.0)), i.normal), 0.1, 1.0);\n\t\t\ti.color = S.color * d;\n\t\t\treturn i;\n\t\t}\n\t}\n\ti.hit = false;\n\ti.hitPoint = vec3(0.0);\n\ti.normal = vec3(0.0);\n\ti.color = vec3(0.0);\n\treturn i;\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\t\n    vec2 p = (fragCoord.xy * 2.0 - iResolution.xy) / min(iResolution.x, iResolution.y);\n    \n\tRay ray;\n\tray.origin = vec3(0.0, 0.0, 5.0);\n\tray.direction = normalize(vec3(p.x, p.y, -1.0));\n    \n\tSphere sphere;\n\tsphere.radius = 1.0;\n\tsphere.position = vec3(0,0,cos(iTime * 3.0) * 3.9);\n\tsphere.color = vec3(abs(cos(iTime)),abs(sin(iTime)),1.0);\n\t\n\tIntersection i = intersectSphere(ray, sphere);\n\tfragColor = vec4(i.color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/lstGWl.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "lstGzf", "name": "Mass Effect - Mass Relay", "author": "AxleMike", "description": "Messing around with distance fields and creating a volumetric effect.", "tags": ["raymarching", "distancefield", "volume"], "likes": 10, "viewed": 319, "date": "1454186674", "time_retrieved": "2024-06-20T18:30:29.042660", "image_code": "// Alexander Lemke, 2016\n\n//////////////////////////////////////////////////\n// Settings\n#define     NUMBER_OF_STEPS         32\n\n//////////////////////////////////////////////////\n// Constants\nconst float     MAX_DISTANCE    = 35.0;\nconst float     EPSILON         = 0.001;\nconst float     PI              = 3.14159265359;\n\n//////////////////////////////////////////////////\n// Helpers\nfloat Saturate(in float f)\n{\n    return clamp(f, 0.0, 1.0);\n}\n\nvec3 Saturate(in vec3 v)\n{\n    return clamp(v, 0.0, 1.0);\n}\n\nfloat Hash(in vec2 p)\n{\n    return -1.0 + 2.0 * fract(sin(dot(p, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\nvec2 Hash2D(in vec2 p)\n{\n    return -1.0 + 2.0 * vec2(fract(sin(dot(p, vec2(12.9898, 78.233))) * 43758.5453), fract(sin(dot(p, vec2(37.271, 377.632))) * 43758.5453));\n}\n\nfloat Noise(in vec2 p)\n{\n    vec2 n = floor(p);\n    vec2 f = fract(p);\n    vec2 u = f * f * (3.0 - 2.0 * f);\n\n    return mix(mix(Hash(n), Hash(n + vec2(1.0, 0.0)), u.x),\n               mix(Hash(n + vec2(0.0, 1.0)), Hash(n + vec2(1.0)), u.x), u.y);\n}\n\n//////////////////////////////////////////////////////\n// 3D noise and Voronio from https://www.shadertoy.com/view/4sfGzS and https://www.shadertoy.com/view/ldl3W8\nfloat Noise(in vec3 x)\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n    f = f * f * (3.0 - 2.0 * f);\n    \n    vec2 uv = (p.xy + vec2(37.0, 17.0) * p.z) + f.xy;\n    vec2 rg = texture(iChannel0, (uv+.5) / 256.).yx;\n    return mix(rg.x, rg.y, f.z);\n}\n\nvec3 Voronoi(in vec2 p)\n{\n    vec2 n = floor(p);\n    vec2 f = fract(p);\n\n    vec2 mg, mr;\n\n    float md = 8.0;\n    for(int j = -1; j <= 1; ++j)\n    {\n        for(int i = -1; i <= 1; ++i)\n        {\n            vec2 g = vec2(float(i), float(j));\n            vec2 o = Hash2D(n + g);\n\n            vec2 r = g + o - f;\n            float d = dot(r, r);\n\n            if(d < md)\n            {\n                md = d;\n                mr = r;\n                mg = g;\n            }\n        }\n    }\n    return vec3(md, mr);\n}\n\n//////////////////////////////////////////////////////\n// smin from http://iquilezles.org/www/articles/smin/smin.htm\n// polynomial smooth min (k = 0.1);\nfloat smin(in float a, in float b, in float k)\n{\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\nmat3 Create3x3RotationMatrix(in vec3 axis, in float angle)\n{\n    axis = normalize(axis);\n    float s = sin(angle);\n    float c = cos(angle);\n    float oc = 1.0 - c;\n    \n    return mat3(oc * axis.x * axis.x + c,          oc * axis.x * axis.y - axis.z * s, oc * axis.z * axis.x + axis.y * s,\n                oc * axis.x * axis.y + axis.z * s, oc * axis.y * axis.y + c,          oc * axis.y * axis.z - axis.x * s,\n                oc * axis.z * axis.x - axis.y * s, oc * axis.y * axis.z + axis.x * s, oc * axis.z * axis.z + c);\n}\n\nfloat LengthN(in vec3 v, in float n)\n{\n    float inverseN = 1.0 / n; \n    v = abs(v);\n    return pow(pow(v.x, n) + pow(v.y, n) + pow(v.z, n), inverseN);\n}\n\nfloat LengthN(in vec2 v, in float n)\n{\n    float inverseN = 1.0 / n; \n    v = abs(v);\n    return pow(pow(v.x, n) + pow(v.y, n), inverseN);\n}\n    \n//////////////////////////////////////////////////////\n// Intersection Helpers\nstruct IntersectionData\n{\n    float       mT;\n    float       mMaterialIndex;\n};\n    \nIntersectionData GetClosestIntersection(in IntersectionData a, in IntersectionData b)\n{\n    if(a.mT < b.mT)\n    {\n        return a;\n    }\n    return b;\n}\n\nstruct Ray\n{\n    vec3    mPosition;\n    vec3    mDirection;\n}; \n\n//////////////////////////////////////////////////////\n// Basic Distance Field Tests\n// http://www.iquilezles.org/www/articles/distfunctions/distfunctions.htm\nfloat sdBox(in vec3 p, in vec3 boxSize)\n{\n  vec3 d = abs(p) - boxSize;\n  return min(max(d.x, max(d.y, d.z)), 0.0) + length(max(d, 0.0));\n}\n\nfloat sdCylinder(in vec3 p, in vec3 cylinderDimensions)\n{\n  return length(p.xz - cylinderDimensions.xy) - cylinderDimensions.z;\n}\n\nfloat sdSphere(in vec3 p, in float radius)\n{\n    return length(p) - radius;\n}\n\nfloat sdPipe(in vec3 p, in vec3 cylinderPosition, in vec2 cylinderDimensions)\n{\n    vec2 d = abs(vec2(length(p.yz + cylinderPosition.yz), p.x + cylinderPosition.x)) - cylinderDimensions;\n    return min(max(d.x, d.y), 0.0) + length(max(d, 0.0));\n}\n\nfloat sdVerticalPipe(in vec3 p, in vec3 cylinderPosition, in vec2 cylinderDimensions)\n{\n    vec2 d = abs(vec2(length(p.xz + cylinderPosition.xz), p.y + cylinderPosition.y)) - cylinderDimensions;\n    return min(max(d.x, d.y), 0.0) + length(max(d, 0.0));\n}\n\nfloat sdTorus(in vec3 p, in vec3 torusPosition, in vec2 torusDimensions)\n{\n    vec2 q = vec2(length(p.xy + torusPosition.xy) - torusDimensions.x, p.z + torusPosition.z);\n    return length(q) - torusDimensions.y;\n}\n\nfloat sdTorus82(in vec3 p, in vec3 torusPosition, in vec2 torusDimensions)\n{\n    vec2 q = vec2(LengthN(p.xy + torusPosition.xy, 2.0) - torusDimensions.x, p.z + torusPosition.z);\n    return LengthN(q, 8.0) - torusDimensions.y;\n}\n\nfloat sdTorus42(in vec3 p, in vec3 torusPosition, in vec2 torusDimensions)\n{\n    vec2 q = vec2(LengthN(p.xy + torusPosition.xy, 2.0) - torusDimensions.x, p.z + torusPosition.z);\n    return LengthN(q, 4.0) - torusDimensions.y;\n}\n\nfloat Capsule(in vec3 p, in vec3 pointA, in vec3 pointB, in float radius)\n{\n    vec3 lineBA = pointB - pointA;\n    vec3 linePA = p - pointA;\n    float rate = min(max(dot(lineBA, linePA), 0.0) / dot(lineBA, lineBA), 1.0);\n    return length(p - (pointA + rate * lineBA)) - radius; \n}\n\n//////////////////////////////////////////////////////\n// Scene Elements\nconst vec3 gMassRelayPosition = vec3(1.0, 3.0, 0.0);\n\nIntersectionData CheckMassRelay(in vec3 p)\n{\n    IntersectionData intersectionData = IntersectionData(MAX_DISTANCE, 1.0);\n    \n    float intersectionT = sdTorus(p, gMassRelayPosition, vec2(4.5, 0.85));\n    intersectionData.mT = intersectionT;\n\n    // Back\n    intersectionT = sdBox(p - vec3(7.5, 0.0, 0.0) + gMassRelayPosition, vec3(2.0, 1.8, 0.65));\n    intersectionData.mT = smin(intersectionData.mT, intersectionT, 3.5);\n  \n    // rear modifications\n    intersectionT = sdBox(p - vec3(10.0, -0.5, 0.0) + gMassRelayPosition, vec3(1.0, 0.5, 3.0));\n    intersectionData.mT = max(intersectionData.mT, -intersectionT);\n    intersectionT = sdBox(p - vec3(10.0, 1.05, 0.0) + gMassRelayPosition, vec3(1.85, 0.25, 3.0));\n    intersectionData.mT = max(intersectionData.mT, -intersectionT);\n    \n    // top beam\n    intersectionT = sdPipe(p, vec3(11.0, -1.5, 0.0) + gMassRelayPosition, vec2(0.8, 7.0));\n    intersectionData.mT = smin(intersectionData.mT, intersectionT, 0.8);    \n    intersectionT = sdPipe(p, vec3(8.0, -1.8, 0.0) + gMassRelayPosition, vec2(0.8, 3.5));\n    intersectionData.mT = smin(intersectionData.mT, intersectionT, 0.8);    \n    \n    // bottom beam\n    intersectionT = sdPipe(p, vec3(11.0, 1.5, 0.0) + gMassRelayPosition, vec2(0.8, 7.0));\n    intersectionData.mT = smin(intersectionData.mT, intersectionT, 0.8);\n        \n    // center hole\n    intersectionT = sdBox(p - vec3(-12.0, 0.0, 0.0) + gMassRelayPosition, vec3(10.0, 1.0, 3.0));\n    intersectionData.mT = max(intersectionData.mT, -intersectionT);\n       \n    // rail modifications\n    intersectionT = sdBox(p - vec3(-18.0, -2.25, 0.0) + gMassRelayPosition, vec3(1.0, 1.0, 1.0));\n    intersectionData.mT = max(intersectionData.mT, -intersectionT);\n    intersectionT = sdBox(p - vec3(-18.0, 2.25, 0.0) + gMassRelayPosition, vec3(1.0, 1.0, 1.0));\n    intersectionData.mT = max(intersectionData.mT, -intersectionT);\n    \n    return intersectionData;\n}\n\nIntersectionData CheckMassRelayRing(in vec3 p)\n{\n    IntersectionData intersectionData = IntersectionData(MAX_DISTANCE, 2.0);\n    \n    // Ring 1\n    mat3 rotationMatrix0 = Create3x3RotationMatrix(vec3(0.0, 1.0, 0.0), PI * 0.60 * iTime);\n    vec3 q0 = rotationMatrix0 * (p + gMassRelayPosition);\n    float intersectionT = sdTorus42(q0, vec3(0.0), vec2(3.0, 0.2));\n    intersectionData.mT = intersectionT;\n    \n    mat3 rotationMatrix1 = Create3x3RotationMatrix(vec3(0.0, 1.0, 0.0), PI * 0.60 * iTime);\n    mat3 rotationMatrix2 = Create3x3RotationMatrix(vec3(1.0, 0.0, 0.0), PI * 0.80 * iTime);\n    vec3 q = rotationMatrix2 * (rotationMatrix1 * (p + gMassRelayPosition));\n    intersectionT = sdTorus42(q, vec3(0.0), vec2(2.5, 0.15));\n    intersectionData.mT = min(intersectionData.mT, intersectionT);\n    \n    return intersectionData;\n}\n\nIntersectionData CheckAntennas(in vec3 p)\n{\n    IntersectionData intersectionData = IntersectionData(MAX_DISTANCE, 3.0);\n    \n    // Left Attennas\n    float intersectionT = sdPipe(p, vec3(11.0, -2.4, -0.35) + gMassRelayPosition, vec2(0.07, 2.5));\n    intersectionData.mT = intersectionT;  \n    intersectionT = sdVerticalPipe(p, vec3(1.4, -6.8, 0.0) + gMassRelayPosition, vec2(0.2, 3.1));\n    intersectionData.mT = smin(intersectionData.mT, intersectionT, 0.1);\n    intersectionT = sdVerticalPipe(p, vec3(1.9, -6.8, 0.0) + gMassRelayPosition, vec2(0.08, 3.6));\n    intersectionData.mT = smin(intersectionData.mT, intersectionT, 0.1);    \n    intersectionT = sdVerticalPipe(p, vec3(0.9, -6.8, 0.0) + gMassRelayPosition, vec2(0.1, 3.1));\n    intersectionData.mT = smin(intersectionData.mT, intersectionT, 0.1); \n    intersectionT = sdVerticalPipe(p, vec3(0.6, -6.8, 0.0) + gMassRelayPosition, vec2(0.08, 1.4));\n    intersectionData.mT = smin(intersectionData.mT, intersectionT, 0.1);\n    \n    // Right Attennas\n    intersectionT = sdVerticalPipe(p, vec3(-1.6, -6.5, 0.0) + gMassRelayPosition, vec2(0.08, 1.4));\n    intersectionData.mT = smin(intersectionData.mT, intersectionT, 0.1); \n    intersectionT = sdVerticalPipe(p, vec3(-1.6, -5.8, 0.0) + gMassRelayPosition, vec2(0.16, 0.7));\n    intersectionData.mT = smin(intersectionData.mT, intersectionT, 0.1);    \n    intersectionT = sdVerticalPipe(p, vec3(-2.2, -6.4, 0.0) + gMassRelayPosition, vec2(0.08, 1.5));\n    intersectionData.mT = smin(intersectionData.mT, intersectionT, 0.1);    \n    intersectionT = sdVerticalPipe(p, vec3(-2.2, -5.6, 0.0) + gMassRelayPosition, vec2(0.16, 0.85));\n    intersectionData.mT = smin(intersectionData.mT, intersectionT, 0.1);\n\n    return intersectionData;\n}\n\nIntersectionData CheckBolt(in vec3 p)\n{\n    IntersectionData intersectionData = IntersectionData(MAX_DISTANCE, 4.0);\n      \n    const int NUMBER_OF_BENDS = 5;\n    vec2 maxBoltYValues = vec2(-1.25, 1.25); \n    float maxBoltYRange = abs(maxBoltYValues.x - maxBoltYValues.y); \n    float yIncr = maxBoltYRange / float(NUMBER_OF_BENDS);\n    \n    vec3 q = p + gMassRelayPosition;\n    int index = int(clamp((((q.y - maxBoltYValues.x) / maxBoltYRange) * float(NUMBER_OF_BENDS)), 0.0, float(NUMBER_OF_BENDS)));\n\n    float boltArea = mod(iTime, 15.0);\n    if(boltArea < 13.0)\n    {\n        vec2 currentBoltYValues = vec2((maxBoltYValues.x + float(index) * yIncr), (maxBoltYValues.x + float(index + 1) * yIncr));\n\n        vec3 randomOffsetHigh = (texture(iChannel0, vec2(floor(mod(iTime, 25.0) * 10.0) / 25.0, float(index) / float(NUMBER_OF_BENDS)), -100.0).xyz * 2.0 - 1.0) * vec3(0.25, 0.0, 0.25);\n        if(index >= (NUMBER_OF_BENDS - 1))\n        \trandomOffsetHigh = vec3(0.0);\n      \n        vec3 randomOffsetLow = (texture(iChannel0, vec2(floor(mod(iTime, 25.0) * 10.0) / 25.0, max(0.0, float(index - 1)) / float(NUMBER_OF_BENDS)), -100.0).xyz * 2.0 - 1.0) * vec3(0.25, 0.0, 0.25);\n\n        intersectionData.mT = Capsule(q, vec3(-4.0 - boltArea, currentBoltYValues.x, 0.0) + randomOffsetLow,\n                                      vec3(-4.0 - boltArea, currentBoltYValues.y, 0.0) + randomOffsetHigh, 0.05);\n    }\n    return intersectionData;\n}\n\nIntersectionData CheckSceneForIntersection(in vec3 p)\n{\n    IntersectionData massRelayIntersection = CheckMassRelay(p);\n    IntersectionData antennasIntersection = CheckAntennas(p);    \n    IntersectionData intersectionData = GetClosestIntersection(massRelayIntersection, antennasIntersection);   \n    \n    IntersectionData ringIntersectionData = CheckMassRelayRing(p);\n    intersectionData = GetClosestIntersection(intersectionData, ringIntersectionData); \n    \n    IntersectionData boltIntersectionData = CheckBolt(p);\n    intersectionData = GetClosestIntersection(intersectionData, boltIntersectionData);\n    \n    return intersectionData;\n}\n\nIntersectionData Intersect(in Ray initialRay)\n{    \n    IntersectionData sceneIntersection = IntersectionData(MAX_DISTANCE, -1.0);\n    \n    float t = 0.0;   \n    for(int i = 0; i < NUMBER_OF_STEPS; ++i)\n    {\n        // Break out if our step size is too small or we've gone out of range\n        if(sceneIntersection.mT < EPSILON || t > MAX_DISTANCE) break;\n        \n        Ray currentRay = Ray(initialRay.mPosition + initialRay.mDirection * t, initialRay.mDirection); // Update our ray     \n        sceneIntersection = CheckSceneForIntersection(currentRay.mPosition); // Check the scene for an intersection     \n        t += sceneIntersection.mT; // Step forward\n    }\n    sceneIntersection.mT = t;\n    \n    return sceneIntersection;\n}\n\nvoid RaySphereIntersectionTest(in vec3 rayPosition, in vec3 rayDirection, in vec3 spherePosition, in float sphereRadius,\n                               out vec3 intersectionNear, out vec3 intersectionFar)\n{   \n    float sRadiusSquared = sphereRadius * sphereRadius;\n    vec3 eDistance = rayPosition - spherePosition;\n    \n    float b = dot(eDistance, rayDirection);\n    float c = dot(eDistance, eDistance) - sRadiusSquared;\n    \n    if((c > 0.0 && b > 0.0) == false)\n    {   \n        float discriminant = (b * b) - c;\n        float t0 = max(-b - sqrt(discriminant), 0.0); // clamp t0 to zero incase it started inside the sphere\n        float t1 = max(-b + sqrt(discriminant), 0.0); // clamp t1 to zero incase it started inside the sphere\n           \n        if(discriminant >= EPSILON)\n        {\n            intersectionNear = rayPosition + rayDirection * t0;\n            intersectionFar = rayPosition + rayDirection * t1;\n       }      \n    }\n}\n\n//////////////////////////////////////////////////////\n// Lighting Helpers\nvec3 GetNormal(in vec3 point) \n{\n    IntersectionData d0 = CheckSceneForIntersection(point);\n    IntersectionData dX = CheckSceneForIntersection(point - vec3(EPSILON, 0.0, 0.0));\n    IntersectionData dY = CheckSceneForIntersection(point - vec3(0.0, EPSILON, 0.0));\n    IntersectionData dZ = CheckSceneForIntersection(point - vec3(0.0, 0.0, EPSILON));\n    return normalize(vec3(dX.mT - d0.mT, dY.mT - d0.mT, dZ.mT - d0.mT));\n}\n\nfloat GGXDistribution(in float NdotH, in float m)\n{\n    // Divide by PI is applied later\n    float m2 = m * m;\n    float f = ( NdotH * m2 - NdotH ) * NdotH + 1.0;\n    return m2 / (f * f);\n}\n\nfloat CookTorranceGeometricAttenuation(in float NdotH, in float NdotL, in float VdotH, in float NdotV)\n{\n    return (min(1.0, min((2.0 * NdotH * NdotL) / VdotH, (2.0 * NdotH * NdotV) / VdotH)));\n}\n\nfloat GGXSmithCorrelated(in float NdotL, in float NdotV, in float alphaG)\n{\n    float alphaG2 = alphaG * alphaG;\n    float Lambda_GGXV = NdotL * sqrt((- NdotV * alphaG2 + NdotV) * NdotV + alphaG2);\n    float Lambda_GGXL = NdotV * sqrt((- NdotL * alphaG2 + NdotL) * NdotL + alphaG2);\n    return 0.5 / ( Lambda_GGXV + Lambda_GGXL );\n}\n\nfloat ComputeSchlickFresnel(in float NdotV, in float fresnelReflectionIndex)\n{\n    return fresnelReflectionIndex + (1.0 - fresnelReflectionIndex) * pow((1.0 - NdotV), 5.0);\n}\n\n//////////////////////////////////////////////////////\n// Lighting\nvec3 ApplyPointLight(in vec3 point, in vec3 normal, in vec3 eye, in vec3 albedo, \n                       in float roughness, in float metallic, in float reflectance, in float ambient,\n                       in vec3 lightPosition, in float lightRadius, in vec3 lightColor)\n{       \n    vec3 lightDirection = -(lightPosition - point);\n\n    // Apply lighting\n    float lightDistance = length(lightDirection);\n    lightDirection = normalize(lightDirection);\n    float attenutation = Saturate(1.0 - lightDistance / lightRadius); \n    attenutation *= attenutation;\n    \n    // Determine some values\n    vec3 viewVector = normalize(eye - point);\n    vec3 halfVector = normalize(lightDirection + viewVector);\n\n    float NdotL = Saturate(dot(normal, lightDirection));\n    float NdotH = Saturate(dot(normal, halfVector));\n    float NdotV = Saturate(dot(normal, viewVector));\n    float VdotH = Saturate(dot(viewVector, halfVector));\n    float HdotL = Saturate(dot(halfVector, lightDirection));\n\n    vec3 diffuse = (1.0 - metallic) * albedo;\n\n    // Cook Torence\n    float f0 = 0.16 * (reflectance * reflectance);\n    float fresnel = ComputeSchlickFresnel(NdotV, f0);    \n\n    float Vis = GGXSmithCorrelated(NdotV, NdotL, roughness);\n    float geometricAttenuation = CookTorranceGeometricAttenuation(NdotH, NdotL, VdotH, NdotV);\n    float microfacets = GGXDistribution(NdotH, roughness);\n\n    float specular = (fresnel * microfacets * Vis) / PI;\n\n    return ((NdotL * Saturate(1.5 * ((0.7 * NdotL * diffuse + specular))))) * lightColor * attenutation;         \n}\n\nvec3 CalculateLighting(in vec3 point, in vec3 normal, in vec3 eye, in vec3 albedo, \n                       in float roughness, in float metallic, in float reflectance, in float ambient)\n{       \n    vec3 lighting = ApplyPointLight(point, normal, eye, albedo, roughness, metallic, reflectance,\n                               0.5, -gMassRelayPosition, 60.0, vec3(0.5, 0.5, 1.0));\n    \n    // Apply lighting from moving bolt\n    float boltArea = mod(iTime, 15.0);\n    if(boltArea < 13.0)\n    {\n        lighting += ApplyPointLight(point, normal, eye, albedo, roughness, metallic, reflectance,\n                               0.5, -gMassRelayPosition + vec3(-4.0 - boltArea, 0.0, 0.0), 8.0, vec3(0.5, 0.5, 1.0));\n    }\n    return lighting + (albedo * ambient);\n}\n\n//////////////////////////////////////////////////////\n// Background\nvec3 ApplyFog(in vec3 texCoord)\n{\n    vec3 samplePosition = 8.0 * texCoord.xyz;\n    \n    float fogAmount = Noise(samplePosition);\n    fogAmount += Noise(samplePosition * 3.01) * 0.5;\n    fogAmount += Noise(samplePosition * 3.02) * 0.25;\n    fogAmount += Noise(samplePosition * 3.03) * 0.125;\n    fogAmount += Noise(samplePosition * 3.01) * 0.0625;\n    \n    vec3 fogColor = vec3(texCoord.xyz + vec3(0.5, 0.0, 0.5))  * 0.1;\n    return (fogColor * fogAmount * vec3(0.75));  \n}\n\nvec3 AddStarField(in vec2 p, in float threshold)\n{\n    vec3 starValue = Voronoi(p);\n    if(starValue.x < threshold)\n    {\n        float power = 1.0 - (starValue.x / threshold);\n        return vec3(power * power * 0.5);\n    }\n    return vec3(0.0);\n}\n\n//////////////////////////////////////////////////////\n// Implementation\nvec4 DisplayScene(in vec3 cameraPosition, in vec3 cameraDirection, in float glowThreshold)\n{\n    // Determine our camera info\n    Ray cameraRay = Ray(cameraPosition, cameraDirection);\n    \n    // Gets the intersection point from the camera ray to camera facing plane that the core is on\n    vec3 directionToCore = -normalize(gMassRelayPosition - cameraPosition);\n    vec3 coreIntersectionNear = vec3(MAX_DISTANCE);\n    vec3 coreIntersectionFar = vec3(MAX_DISTANCE);\n    \n    const float coreVolumeRadius = 8.0;\n    const float solidCoreRadius = 1.25;\n    RaySphereIntersectionTest(cameraPosition, cameraDirection, -gMassRelayPosition, coreVolumeRadius, coreIntersectionNear, coreIntersectionFar);\n      \n    vec3 finalColor = vec3(0.0);\n\n    IntersectionData intersection = Intersect(cameraRay);        \n    if(intersection.mT < MAX_DISTANCE)\n    {   \n        vec3 intersectionPoint = (cameraRay.mPosition + cameraRay.mDirection * intersection.mT);\n        vec3 normal = GetNormal(intersectionPoint);\n\n        vec3 diffuse = vec3(1.0);\n        float roughness = 0.9;\n        float metallic = 1.0;\n        float reflectance = 0.2;\n        float ambient = 0.2;\n        \n        if(intersection.mMaterialIndex == 1.0)\n        {\n            // I'm sure theres a better way to do this\n            vec2 texCoords = intersectionPoint.xy;\n            if(abs(dot(normal, vec3(1.0, 0.0, 0.0))) > 0.8)\n                texCoords =  intersectionPoint.zy;  \n            else if(abs(dot(normal, vec3(0.0, 1.0, 0.0))) > 0.8)\n                texCoords =  intersectionPoint.xz;\n\n            vec3 textureColor = texture(iChannel1, texCoords * 0.125).rgb;\n            diffuse = vec3(0.3, 0.3, 0.4);  \n            \n            if(textureColor.r < glowThreshold)\n            {\n                ambient = 1.0;\n                diffuse = vec3(1.0);\n            }  \n        }\n        else if(intersection.mMaterialIndex == 2.0 || intersection.mMaterialIndex == 3.0)  \n            diffuse = vec3(0.5);               \n        else if(intersection.mMaterialIndex == 4.0)\n        {\n            ambient = 10.0;  \n            diffuse = vec3(1.0);\n        }\n\n        finalColor += CalculateLighting(intersectionPoint, normal, cameraPosition, diffuse, roughness, metallic, reflectance, ambient);         \n    }\n    else\n    {   \n        // calculate the uv coords for the skybox\n        vec2 starFieldCoord = vec2(atan(cameraDirection.x, cameraDirection.z) / (2.0 * PI), asin(cameraDirection.y) / PI);       \n        finalColor += AddStarField(starFieldCoord * 80.0, 0.0025);\n        finalColor += AddStarField(starFieldCoord * 65.0, 0.0025);\n        finalColor += AddStarField(starFieldCoord * 50.0, 0.001);       \n        finalColor += ApplyFog(cameraDirection);\n    }\n\n    float lengthToNearVol = min(length(cameraPosition - coreIntersectionNear), intersection.mT);\n    float lengthToFarVol = min(length(cameraPosition - coreIntersectionFar), intersection.mT);\n    float volumeTravelDistance = abs(lengthToNearVol - lengthToFarVol);\n    \n    if(volumeTravelDistance < coreVolumeRadius * 2.0)\n    {\n        vec3 volStartPoint = (cameraRay.mPosition + cameraRay.mDirection * lengthToNearVol);\n        float volumeAmount = 0.0;\n        \n        const int numberOfSteps = 20;\n        float stepSize = max(volumeTravelDistance / float(numberOfSteps), EPSILON);\n\n        for(int i = 0; i < numberOfSteps; ++i)\n        {\n            vec3 currentPoint = volStartPoint + (float(i) * stepSize * cameraDirection);\t   \n            float distanceFromCenterCore = length(currentPoint + gMassRelayPosition);\n\n            float blueTint = Saturate((coreVolumeRadius - distanceFromCenterCore) / coreVolumeRadius) * 2.0;\n            float whiteTint = Saturate((solidCoreRadius - distanceFromCenterCore) / solidCoreRadius) * 200.0;\n\n            if(length(currentPoint) > MAX_DISTANCE)\n            {\n                break;\n            }\n            volumeAmount += blueTint + whiteTint;        \n        }\n        volumeAmount /= float(numberOfSteps);\n        vec3 volumeColor = mix(vec3(0.1, 0.1, 1.0), vec3(1.0), vec3(volumeAmount * 0.5));\n        finalColor = mix(finalColor, volumeColor, vec3(Saturate(volumeAmount)));\n    } \n    return vec4(finalColor, 1.0);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // Adjust UVs for for the resolution so our world goes from [-1,-1] to [1,1]\n    vec2 screenCoord = (fragCoord.xy / iResolution.xy);\n    vec2 aspectRatioAdjustedUVs = vec2((screenCoord.x * 2.0 - 1.0) * (iResolution.x / iResolution.y), (screenCoord.y * 2.0 - 1.0));\n    \n    float xRotationValue = (iMouse.z > 0.0) ? (iMouse.y / iResolution.y - 0.5) * (PI * 0.5) : 0.0;\n    mat3 xRotationMatrix = Create3x3RotationMatrix(vec3(1.0, 0.0, 0.0), xRotationValue);\n    float yRotationValue = (iMouse.z > 0.0) ? (iMouse.x / iResolution.x) * (PI * 2.0) : (iTime * PI) * 0.05; // Multiply by 0.1 to slow down the rotation ;   \n    mat3 yRotationMatrix = Create3x3RotationMatrix(vec3(0.0, -1.0, 0.0), yRotationValue);\n\n    // Determine our camera info\n    const float distanceFromOrigin = 13.0;\n    vec3 cameraPosition = vec3(distanceFromOrigin * sin(yRotationValue) * cos(xRotationValue), distanceFromOrigin * sin(xRotationValue), distanceFromOrigin * cos(yRotationValue) * cos(xRotationValue));\n    vec3 cameraDirection = normalize(yRotationMatrix * xRotationMatrix * normalize(vec3(aspectRatioAdjustedUVs, -1.0)));\n\n    vec4 finalColor = DisplayScene(cameraPosition, cameraDirection, 0.4);\n    finalColor *= pow(16.0 * screenCoord.x * screenCoord.y * (1.0 - screenCoord.x) * (1.0 - screenCoord.y), 0.1); // Vigneting\n\n\tfragColor = finalColor;\n}", "image_inputs": [{"id": "4dXGRn", "previewfilepath": "/media/ap/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg", "ctype": "texture"}, {"id": "Xsf3zn", "previewfilepath": "/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture"}, {"id": "Xsf3Wl", "previewfilepath": "https://soundcloud.com/user3303533/mass-effect-3-earth", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "https://soundcloud.com/user3303533/mass-effect-3-earth", "ctype": "musicstream"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/lstGzf.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "lsVGRR", "name": "_RGB Mandelbrot Set", "author": "rgb", "description": "rubbish", "tags": ["procedural", "2d", "fractal"], "likes": 0, "viewed": 111, "date": "1453086890", "time_retrieved": "2024-06-20T18:30:29.042660", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    const int iter = 1000;\n    \n    float zoom_factor = 1.0/(iTime/10.0);\n        \n    float offset = -0.0 + (1.0/zoom_factor);\n    \n    vec2 c, z;\n    \n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    \n    c.x = (5.0/3.0) * (uv.x - offset) * zoom_factor;\n   \n    c.y = (uv.y - 0.5) * zoom_factor;\n\n    z = c;\n    \n    int outI;\n    \n    for(int i=0; i<iter; i++)\n    {\n        float x = (z.x * z.x - z.y * z.y) + c.x;\n        float y = (z.y * z.x + z.x * z.y) + c.y;\n\n        outI = i;\n        \n        if((x * x + y * y) > 4.0) break;\n        \n        z.x = x;\n        z.y = y;\n    }\n    \n    if (outI == iter)\n    {\n        fragColor = vec4(0,0,0,1);\n    }\n    if (outI != iter)\n    {       \n    \tfragColor = vec4(outI/100,outI/100,outI/100,1);\n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/lsVGRR.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "lsVGzz", "name": "Test clone", "author": "Quantme", "description": "Created by genis sole, modified to test.\nOriginal shader: https://www.shadertoy.com/view/XlfXzM", "tags": ["fractal"], "likes": 1, "viewed": 141, "date": "1453134137", "time_retrieved": "2024-06-20T18:30:30.394398", "image_code": "// Created by genis sole - 2015\n// Original shader: https://www.shadertoy.com/view/XlfXzM\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// Enable more representative frequency analysis.\n//#define CF \n\n// Toggle non-reactive version.\n// #define S\n\nvec4 freqs = vec4(0.6, 1, 1, 1);\n\nvec4 FreqAnalysis() {\n#ifdef S\n    return freqs;\n#endif\n    \n    vec4 sy = vec4(0.0);    \n    \n#ifdef CF\n    // 0.25 / (512 / 4) = 0.001953125\n    for(float i = 0.0; i < 1; i += 0.001953125) {\n   \t\tsy.x += texture(iChannel0, vec2(i, 0.0)).x;\n    }\n    \n    for(float i = 0.25; i < 0.5; i += 0.001953125) {\n   \t\tsy.y += texture(iChannel0, vec2(i, 0.0)).x;\n    }\n    \n    for(float i = 0.5; i < 0.75; i += 0.001953125) {\n   \t\tsy.z += texture(iChannel0, vec2(i, 0.0)).x;\n    }\n    \n    for(float i = 0.75; i <= 1.0; i += 0.001953125) {\n   \t\tsy.w += texture(iChannel0, vec2(i, 0.0)).x;\n    }\n    sy *= vec4(0.0078125); // 1 / (512 / 4) = 0.0078125\n    \n#else\n    \n    sy.x = texture(iChannel0, vec2(0.0, 0.0)).x;\n\tsy.y = texture(iChannel0, vec2(0.33, 0.0)).x;\n    sy.z = texture(iChannel0, vec2(0.66, 0.0)).x;\n    sy.w = texture(iChannel0, vec2(1.0, 0.0)).x;\n    \n#endif\n    \n    return sy;\n}\n\n\nvec3 rgb2hsv(vec3 c) {\n    vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);\n    vec4 p = mix(vec4(c.bg, K.wz), vec4(c.gb, K.xy), step(c.b, c.g));\n    vec4 q = mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));\n\n    float d = q.x - min(q.w, q.y);\n    float e = 1.0e-10;\n    return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);\n}\n\nvec3 hsv2rgb(vec3 c) {\n    vec4 K = vec4(1.0, 2.0 / 1.0, 1.0 / 6.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 16.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nfloat sin3(in vec3 p) {\n\treturn (sin(p.x) + sin(p.y) + sin(p.z));\n}\n\nfloat noise(in vec3 p) {\n    float j = iTime * 0.02;\n    float v = (sin3((p+vec3(j*7.0, j*2.3, j*1.0)) * 10.0) * freqs.w +\n               sin3((p+vec3(j*3.0, j*1.2, j*0.4)) * 8.0) * freqs.z +\n               sin3((p+vec3(j*2.4, j*0.6, j*2.6)) * 6.0) * freqs.y +\n               sin3((p+vec3(j*1.4, j*5.8, j*1.9)) * 4.0) * freqs.x) * 0.16;\n    //return 0.0;\n    \n    v = abs(v);\n    float f = floor(v*10.0);\n    \n    v = clamp((smoothstep(0.0, 0.6, mix(0.1, 0.6, v*10.0-f)) + f)* 0.1, 0.0, 1.0);\n    return v;\n}\n\n// Taken from http://iquilezles.org/www/articles/palettes/palettes.htm\nvec3 ColorPalette(in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d )\n{\n    return a + b*cos( 16.28318*(c*t+d) );\n}\n\n\nbool RaySphereIntersection(in vec3 ro, in vec3 rd, in vec3 c, in float r, out vec3 p0, out vec3 p1) {\n    p0 = vec3(0.0);\n    p1 = vec3(0.0);\n    \n   \tvec3 oc = ro - c;\n    float poc = dot(rd, oc);\n    \n    float sloc = dot(oc, oc);\n    float test = poc*poc - sloc + r*r;\n        \n    if (test < 0.0) return false;\n    \n    float sqt = sqrt(test);\n    float d0 = -poc - sqt;\n    float d1 = -poc + sqt;\n    \n\tp0 = ro + d0*rd;\n    p1 = ro + d1*rd;\n    return true;\n}\n\nvec3 SphereNormal(in vec3 d, in float r, in float e) {\n    float theta = atan(d.y,d.x) ;\n    float phy = acos(d.z);\n    \n    vec3 dy0 = vec3(cos(theta+e)*sin(phy), sin(theta+e)*sin(phy), cos(phy));\n    vec3 dy1 = vec3(cos(theta-e)*sin(phy), sin(theta-e)*sin(phy), cos(phy));\n\n    vec3 dx0 = vec3(cos(theta)*sin(phy+e), sin(theta)*sin(phy+e), cos(phy+e));\n    vec3 dx1 = vec3(cos(theta)*sin(phy-e), sin(theta)*sin(phy-e), cos(phy-e));\n    \n    float ny0 = noise(dy0*r);\n    float ny1 = noise(dy1*r);\n    float nx0 = noise(dx0*r);\n    float nx1 = noise(dx1*r);\n    \n    dy0 *= r + ny0;\n    dy1 *= r + ny1;\n    dx0 *= r + nx0;\n    dx1 *= r + nx1;\n    \n    return normalize(cross(dy0 - dy1, dx1 - dx0));\n}\n\nbool RayMarchPerturbedSphere(in vec3 ro, in vec3 rd, in vec3 c, in float r, in float br, \n                             out vec3 n, out vec3 sd) {\n    n = vec3(0.0);\n    sd = vec3(0.0);\n    \n    vec3 bp0 = vec3(0.0);\n    vec3 bp1 = vec3(0.0);\n    bool bres = RaySphereIntersection(ro, rd, c, br, bp0, bp1);\n    if (!bres) return false;\n    \n    vec3 p0 = vec3(0.0); \n    vec3 p1 = vec3(0.0);\n    bool res = RaySphereIntersection(ro, rd, c, r, p0, p1); \n    \n    float dist = float(res)*length(p0 - bp0) + (1.6-float(res)) * length(bp0 - bp1);\n\t//float dist = length(bp0 - bp1);\n    const float sc = 62.0;\n    const float invsc = 1.0 / sc;\n    float s = dist * invsc;\n    \n    bool ret = false;\n    vec3 pn = vec3(0.0);\n    for (float d = 0.0; d < sc; ++d) {\n    \tpn = (bp0 + d*s*rd) - c;\n\t\t\n        sd = normalize(pn) * r;\n        float h = length(pn) - r - s;\n        \n        float h0 = noise(sd);\n        if (h0 > h) {\n            ret = true;\n            break;\n        } \n    }\n    \n    n = SphereNormal(normalize(pn), r, s);\n    return ret;\n}\n\n\n// Based on this: http://iquilezles.org/www/articles/rmshadows/rmshadows.htm        \nfloat ShadowFactor(in vec3 sd, in vec3 ld, in vec3 c, in float r, in float br) {\n    float w = noise(sd);\n    vec3 ro = c + (normalize(sd) * (w+r));\n    \n    vec3 bp0 = vec3(0.0);\n    vec3 bp1 = vec3(0.0);\n    bool bres = RaySphereIntersection(ro, -ld, c, br, bp0, bp1);\n    \n    vec3 p0 = vec3(0.0);\n    vec3 p1 = vec3(0.0);\n    bool res = RaySphereIntersection(ro, -ld, c, r, p0, p1);\n    \n    float dist = min(length(ro - bp0)+ float(!bres) * 10000.0, \n                     length(ro - p0) + float(!res) * 10000.0);\n    \n    const float sc = 128.0;\n    const float invsc = 1.0 / sc;\n    float s = dist * invsc;\n    \n    float dmin = 1.0;\n    \n    for (float d = 0.0; d < sc; ++d) {\n    \tvec3 pn = (ro + d*s*-ld) - c;\n\t\t\n        sd = normalize(pn) * r;\n        float h = length(pn) - r + s;\n        \n        float h0 = noise(sd);\n        if (h0 > h) {\n            dmin = 0.0;\n            break;\n        }\n        \n        dmin = min(dmin, 4.0*(h-h0)/(d*s));\n    }\n    \n    return clamp(dmin, 0.0, 1.0);\n    \n}\n\n\nvec3 GetColor(vec3 sd) {\n    float n = noise(sd);\n    vec3 c = ColorPalette(n, vec3(0.5, 0.5, 0.5), vec3(0.5, 0.5, 0.5),\n                             vec3(1.0, 1.0, 0.5), vec3(0.4, 0.3, 0.5));\n    \n    c = rgb2hsv(c);\n    c.y += 0.60;\n    c.z += 0.1;\n    c = hsv2rgb(c);\n    \n    return c;\n    \n}\n\nvec3 CameraRay(vec2 fragCoord, float n) {\n    float a = 1.0/max(iResolution.x, iResolution.y);\n    \n    return normalize(vec3((fragCoord - iResolution.xy*0.5)*a, n));\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 rd = CameraRay(fragCoord, 1.0);\n    \n    vec3 sc = vec3(0.0, 0.0, 10.0);\n    float sr = 1.6;\n \n    vec3 n = vec3(0.0);\n    vec3 sd = vec3(0.0);\n    if (RaySphereIntersection(vec3(0.0), rd, sc, sr+1.0, n, sd)) {\n        freqs = FreqAnalysis();\n    }\n    \n    bool hit = RayMarchPerturbedSphere(vec3(0.0), rd, sc, sr, sr+1.0, n, sd);\n    \n    vec3 color = vec3(0.06);\n    if (hit) {\n        \n        float w = max(max(freqs.x,freqs.y) , max(freqs.z, freqs.w));\n        vec2 nM = vec2(sin(iTime*16.4), cos(iTime*1.2));\n        \n        vec3 l = normalize(vec3(-(nM.x*2.0 -1.0), -(nM.y*2.0 - 1.0), -0.9 + w*3.0));\n        \n        float sf = ShadowFactor(sd, l, sc, sr, sr+1.0);\n        \n        color = GetColor(sd);\n        vec3 diff = color * max(dot(-l, n), 0.0 ) * sf * 1.95;\n        vec3 amb = color * 0.05;\n        \n        color = diff;\n    \tcolor += amb;\n    }\n    \n    fragColor = vec4(pow(color, vec3(0.55)), 6.0);\n}", "image_inputs": [{"id": "MdXGWn", "previewfilepath": "https://soundcloud.com/captain-hook/astrix-captain-hook-bungee-jump-protonica-remix_sample", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "https://soundcloud.com/captain-hook/astrix-captain-hook-bungee-jump-protonica-remix_sample", "ctype": "musicstream"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc-by-nc-sa-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/lsVGzz.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "lsy3Rh", "name": "Test Universe", "author": "milewski", "description": "Test", "tags": ["universe"], "likes": 15, "viewed": 784, "date": "1453226925", "time_retrieved": "2024-06-20T18:30:30.557983", "image_code": "// 'Warp Speed' by David Hoskins 2013.\n// I tried to find gaps and variation in the star cloud for a feeling of structure.\nfloat time = (iTime+29.) * 60.0;\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tfloat s = 0.0, v = 0.0;\n\tvec2 uv = (fragCoord.xy / iResolution.xy) * 2.0 - 1.0;\n\tfloat t = time*0.005;\n\tuv.x = (uv.x * iResolution.x / iResolution.y) + sin(t) * 0.5;\n\tfloat si = sin(t + 1.0); // ...Squiffy rotation matrix!\n\tfloat co = cos(t);\n\tuv *= mat2(co, si, -si, co);\n\tvec3 col = vec3(0.0);\n\tvec3 init = vec3(0.25, 0.25 + sin(time * 0.001) * 0.4, floor(time) * 0.0008);\n\tfor (int r = 0; r < 50; r++) \n\t{\n\t\tvec3 p = init + s * vec3(uv, 0.143);\n\t\tp.z = mod(p.z, 2.0);\n\t\tfor (int i=0; i < 10; i++)\tp = abs(p * 2.04) / dot(p, p) - 0.75;\n\t\tv += length(p * p) * smoothstep(0.0, 0.5, 0.9 - s) * .002;\n\t\t// Get a purple and cyan effect by biasing the RGB in different ways...\n\t\tcol +=  vec3(v * 0.8, 1.1 - s * 0.5, .7 + v * 0.5) * v * 0.013;\n\t\ts += .01;\n\t}\n\tfragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/lsy3Rh.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "lsyGD1", "name": "Colored Lights", "author": "Neph", "description": "Learning how to light a scene. Shadows are really expensive right now until I fix them (soz).", "tags": ["procedural", "3d", "distancefield", "raymarch", "primitives", "lights"], "likes": 0, "viewed": 130, "date": "1454232194", "time_retrieved": "2024-06-20T18:30:31.321503", "image_code": "#define nsteps 128\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\nfloat fplane (vec3 p){\n \treturn p.y+10.0;   \n}\n\nfloat map(vec3 p){\n    vec3 c = vec3(10.0);\n    vec3 q = mod(p, c) - 0.5*c;\n    q.y = p.y;\n    \n    float circle = length(q- vec3(0.0, 3.0, 0.0)) - 2.5;\n    float circle2 = length(q- vec3(0.0, -1.0, 0.0)) - 2.3;\n    float box = sdBox(q, vec3(2.0, 5.0, 2.0));\n    float plane = fplane(p);\n    float scene0 = min( max(-(min(circle, circle2)), box), plane);\n    return min(scene0, length(p - vec3(0.0, 10.0, 20.0)) - 6.0);\n}\n\nfloat march (vec3 o, vec3 r){\n \tfloat t = 0.0;\n    for(int i = 0; i < nsteps; i++){\n\t\tvec3 p = o + r * t;\n        float d = map (p);\n        t += d * 0.5;\n    }\n   return t;\n}\n\nvec3 gradient (vec3 p){\n const float df = 0.1;\n const vec3 dx = vec3(df, 0.0, 0.0);\n const vec3 dy = vec3(0.0, df, 0.0);\n const vec3 dz = vec3(0.0, 0.0, df);\n    \n    return normalize(\n        \n        vec3(map( p + dx ) - map ( p - dx),\n             map( p + dy ) - map ( p - dy),\n             map( p + dz ) - map ( p - dz)\n            )\n        \n        );\n    \n}\n\n//Very dirty and expensive shadows -n-\n//Will fix I promise\nfloat shadow (vec3 ro, vec3 rd){\n    float k = 8.0;\n    float res = 1.0;\n    \n    for(float t = 1.0; t<16.0; t += 0.2){\n     \tfloat h = map(ro + rd*t);\n        if (h < 0.001)\n            return 0.0;\n        res = min (res, k*h/t);\n    }\n    \n    return res;\n}\n\nvec3 shade (vec3 p, vec3 n){\n    vec3 lFinal = vec3(0.0);\n    \n    //Light 0\n    {\n        vec3 col = vec3(0.0);\n        vec3 lipos = vec3(cos(iTime)*50.0, 30.0, sin(iTime)*50.0+10.0);\n        vec3 licol = vec3(abs(sin(iTime)), abs(cos(iTime)), abs(sin(iTime*0.2)));\n        float reflectance = 1.5;\n\n        vec3 lidir = normalize(lipos - p);\n        vec3 libir = licol * dot(n, lidir);\n        \n        float sh = clamp(shadow(p, normalize(lipos - p)), 0.0, 1.0);\n        \n        col += reflectance * libir;\n        col *= 1.0 - (length(p - lipos)*0.01);\n        col -= 1.0-sh;\n        col = clamp (col, 0.0, 1.0);\n        lFinal += col;\n    }\n    \n    //Light 1\n        {\n        vec3 col = vec3(0.0);\n        vec3 lipos = vec3(-cos(iTime)*20.0, 30.0, -sin(iTime)*20.0+10.0);\n        vec3 licol = vec3(1.0);\n        float reflectance = clamp(sin(iTime/3.0), 0.0, 1.0)*1.5;\n\n        vec3 lidir = normalize(lipos - p);\n        vec3 libir = licol * dot(n, lidir);\n            \n        float sh = clamp(shadow(p, normalize(lipos - p)), 0.0, 1.0);\n            \n        col += reflectance * libir;\n        col *= 1.0 - (length(p - lipos)*0.01);\n        col -= 1.0-sh;\n        col = clamp (col, 0.0, 1.0);\n        lFinal += col;\n    }\n        //Light 2\n        {\n        vec3 col = vec3(0.0);\n        vec3 lipos = vec3(0.0, 60.0, 0.0);\n        vec3 licol = vec3(1.0);\n        float reflectance = clamp(1.0, 0.0, 1.0)*1.5;\n\n        vec3 lidir = normalize(lipos - p);\n        vec3 libir = licol * dot(n, lidir);\n            \n        float sh = clamp(shadow(p, normalize(lipos - p)), 0.0, 1.0);\n            \n        col += reflectance * libir;\n        col *= 1.0 - (length(p - lipos)*0.01);\n        col -= 1.0-sh;\n        col = clamp (col, 0.0, 1.0);\n        lFinal += col;\n    }\n\n    return clamp(lFinal, vec3(0.0), vec3(1.0));\n    \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    uv = uv * 2. - 1.;\n    uv.x *= iResolution.x / iResolution.y;\n\tvec3 col = vec3(0.0);\n    \n    vec3 o = vec3(0.0, 10.0, 0.0);\n    vec3 ray = vec3(uv, 0.8);\n    vec3 r = normalize(ray);\n\n    float tt = sin(iTime/7.0);\n    ray.xz *= mat2(cos(tt), -sin(tt), sin(tt), cos(tt));\n    \n    \n    float t = march(o, ray);\n    \n    vec3 pos = (o + ray * t);\n   \tvec3 n = gradient(pos);\n    \n    col = shade (pos, n);\n    col -= vec3(t * 0.01);\n    \n    fragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/lsyGD1.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "lsyGR1", "name": "Mouse Julia", "author": "sixstring982", "description": "Julia fractal. Use your mouse to change how it renders! Uses orbit trapping for coloring. Mandelbrot is rendered in the background to aid in finding interesting Julia constants.", "tags": ["fractal", "julia", "mouse", "orbit"], "likes": 5, "viewed": 787, "date": "1453248504", "time_retrieved": "2024-06-20T18:30:31.321503", "image_code": "#define ITERS 32\n\nstruct Window {\n    float x;\n    float y;\n    float w;\n    float h;\n};\n\nvec2 complexFromUv(in Window win, in vec2 uv) {\n    return vec2(uv.x * win.w + win.x,\n                uv.y * win.h + win.y);\n}\n\nvec3 palette(in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d) {\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\nvec3 juliaPalette(in float t) {\n    return palette(t, vec3(0.5, 0.5, 0.5), vec3(0.5, 0.5, 0.5), \n                      vec3(1.0, 1.0, 0.5), vec3(0.80, 0.90, 0.30));\n}\n\nvec3 mbrotPalette(in float t) {\n    return palette(t, vec3(0.5, 0.5, 0.5), vec3(0.5, 0.5, 0.5), \n                      vec3(1.0, 1.0, 0.5), vec3(0.80, 0.90, 0.30));\n}\n\nfloat julia(in vec2 c, in vec2 z, in vec2 target) {\n    float x;\n    float d = 1e20;\n    for (int j = 0; j < ITERS; j++) {\n        if (z.x * z.x + z.y * z.y > 4.0) {\n            return d;\n        }\n        \n        x = z.x * z.x - z.y * z.y + c.x;\n        z.y = 2.0 * z.x * z.y + c.y;\n        z.x = x;\n        \n        d = min(d, length(z - target));\n    }\n    return d;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    Window win = Window(-2.0, -1.0, 3.0, 2.0);\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    \n    vec2 z = complexFromUv(win, uv);\n    vec2 c = complexFromUv(win, iMouse.xy / iResolution.xy);\n    \n    vec2 t = vec2(sin(iTime) + 0.1 * sin(iTime * 2.0), \n                  cos(iTime) + 0.1 * cos(iTime * 2.0));\n    \n    t *= sin(iTime * 0.1) * 0.5;\n\n    vec3 j = juliaPalette(pow(julia(c, z, t), 0.3));\n    vec3 m = mbrotPalette(pow(julia(z, z, t), 0.7));\n    float amt = 0.75 + 0.25 * sin(iTime * 0.1);\n    fragColor = vec4(mix(m, j, amt), 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/lsyGR1.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "Md33Rl", "name": "feliz 2016", "author": "mbanquiero", "description": "ray tracing text ", "tags": ["felicesfiestas"], "likes": 2, "viewed": 180, "date": "1451606029", "time_retrieved": "2024-06-20T18:30:31.321503", "image_code": "const float fov = 3.1415 / 4.0;\nconst float EP = 0.05;\nconst float box_r = 0.9;\nconst mat4 m2 = mat4(\t0.0,0.0,\n                     \t1.0,0.0,\n                     \t2.0,0.0,\n                     \t1.0,1.0,\n                    \t2.0,2.0,\n                     \t0.0,3.0,\n                    \t2.0,3.0,\n                     \t1.0,4.0);\n\nconst mat4 m0 = mat4(\t1.0,0.0,\n                     \t0.0,1.0,\n                     \t2.0,1.0,\n                     \t0.0,2.0,\n                    \t2.0,2.0,\n                     \t0.0,3.0,\n                    \t2.0,3.0,\n                     \t1.0,4.0);\n\nconst mat4 m1 = mat4(\t1.0,0.0,\n                     \t1.0,1.0,\n                     \t1.0,2.0,\n                     \t1.0,3.0,\n                    \t0.0,3.0,\n                     \t1.0,4.0,\n                    \t1.0,0.0,\n                     \t1.0,0.0);\n\nconst mat4 m6 = mat4(\t1.0,0.0,\n                     \t0.0,1.0,\n                     \t2.0,1.0,\n                     \t0.0,2.0,\n                    \t1.0,2.0,\n                     \t0.0,3.0,\n                    \t1.0,4.0,\n                     \t2.0,4.0);\n\nconst mat4 m5 = mat4(\t0.0,0.0,\n                     \t1.0,0.0,\n                     \t2.0,1.0,\n                     \t1.0,2.0,\n                    \t0.0,3.0,\n                     \t0.0,4.0,\n                    \t1.0,4.0,\n                     \t2.0,4.0);\n    \n    \nfloat rand(vec3 x)\n{\n\tfloat n = dot(x , vec3(1.0,113.0,257.0) );\n    return fract(sin(n)*43758.5453) - 0.5;\n}\n\nbool ray_aabb(vec3 org,vec3 dir,vec3 lb, vec3 rt,out float dist)\n{\n    bool rta = false;\n    vec3 dirfrac = 1.0 / dir;\n    vec3 A = (lb-org)*dirfrac;\n    vec3 B = (rt-org)*dirfrac;\n    float tmin = max(max(min(A.x, B.x), min(A.y, B.y)), min(A.z, B.z));\n    float tmax = min(min(max(A.x, B.x), max(A.y, B.y)), max(A.z, B.z));\n    if (tmin<=tmax && tmin>0.0)\n    {\n        rta = true;\n        dist = tmin;\n    }\n\treturn rta;\n}\n\n\nbool ray_edge(vec3 org,vec3 dir,vec3 lb, vec3 rt)\n{\n    bool rta = false;\n    vec3 dirfrac = 1.0 / dir;\n    vec3 A = (lb-org)*dirfrac;\n    vec3 B = (rt-org)*dirfrac;\n    float tmin = max(max(min(A.x, B.x), min(A.y, B.y)), min(A.z, B.z));\n    float tmax = min(min(max(A.x, B.x), max(A.y, B.y)), max(A.z, B.z));\n    if (tmin<=tmax && tmin>0.0)\n    {\n        int cant = 0;\n\t\tvec3 Ip = org + dir*tmin;\n        vec3 Ta = abs(Ip - lb);\n        vec3 Tb = abs(Ip - rt);\n        if( Ta.x < EP)\n            cant++;\n        if( Ta.y < EP)\n            cant++;\n        if( Ta.z < EP)\n            cant++;\n        \n        if( Tb.x < EP)\n            cant++;\n        if( Tb.y < EP)\n            cant++;\n        if( Tb.z < EP)\n            cant++;\n        \n        rta = cant>=2 ? true : false;\n    }\n\treturn rta;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\tfloat x = 2.0*uv.x-1.0;\n    float y = 2.0*uv.y-1.0;\n\tfloat time = iTime*0.4;\n    vec3 vLookFrom = vec3(30.0*sin(time),10.0*cos(time),30.0*cos(time));\n    vec3 vLookAt = vec3(0.0,0.0,0.0);\n    vec3 N = normalize(vLookAt-vLookFrom);\n    vec3 V = normalize(cross( N , vec3(0.0,1.0,0.0)));\n    vec3 U = cross(V , N);\n    float k = 2.0*tan(fov/2.0);\n\tvec3 Dy = U*(k*iResolution.y/iResolution.x*0.8);\n\tvec3 Dx = V*k;\n    \n\t// direccion de cada rayo\n\tvec3 D = normalize(N + Dx*x + Dy*y);\n    vec3 box_dim = vec3(box_r,box_r,box_r);\n    \n    fragColor = vec4(0.0,0.0,0.0,1.0);\n\n    float min_dist = 1000000.0;\n    for(float s=0.0;s<4.0;++s)\n    for(int i=0;i<4;++i)\n    for(int j=0;j<2;++j)\n    {\n        float rnd = rand(vec3(uv,time))*0.1;\n\t\tfloat dist;\n        vec3 box_or;\n        if(s==0.0)\n        \tbox_or = vec3(m2[i][j*2],m2[i][j*2+1],0.0) * box_dim*1.5; \n       \telse\n        if(s==1.0)\n        \tbox_or = vec3(m0[i][j*2],m0[i][j*2+1],0.0) * box_dim*1.5;\n        else\n        if(s==2.0)\n        \tbox_or = vec3(m1[i][j*2],m1[i][j*2+1],0.0) * box_dim*1.5;\n        else\n        {\n         \tif(sin(time*5.0)<0.0)   \n        \tbox_or = vec3(m6[i][j*2],m6[i][j*2+1],0.0) * box_dim*1.5;\n            else\n        \tbox_or = vec3(m5[i][j*2],m5[i][j*2+1],0.0) * box_dim*1.5;\n        }\n            \n \t\tbox_or += vec3(box_r*8.0 * (s-1.0) , -box_r , 0.0);            \n        box_or +=  rnd*box_dim;\n        bool hit_edge = ray_edge(vLookFrom,D , box_or-box_dim, box_or+box_dim);\n        \n        if(hit_edge)\n        {\n            fragColor = vec4(0.75,0.8,1.0,1.0);            \n        }\n        else\n        {\n        \tbox_or +=  rnd*box_dim*1.3;\n            bool hit = ray_aabb(vLookFrom,D , box_or-box_dim, box_or+box_dim, dist);\n\n            if(hit && dist<min_dist)\n            {\n                min_dist = dist;\n                vec3 Ip = vLookFrom + D*dist;\n                float d = length(Ip-box_or) / (2.0 * box_r);\n                d = pow(d,3.0);\n                fragColor = vec4(d,d,0,1.0);            \n            }\n        }\n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/Md33Rl.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "Mdd3D2", "name": "Untitled 06", "author": "floz", "description": "Everyday number 6!", "tags": ["raymarching", "loop", "repeat", "fractalstyle"], "likes": 3, "viewed": 151, "date": "1452362403", "time_retrieved": "2024-06-20T18:30:34.194612", "image_code": "#define PI 3.141592654\n#define EPSILON 0.0000001\n#define AMPLITUDE 0.52\n#define SPEED 0.05\n\n//------------------------------------------------------------------ VISUAL QUALITY\n#define RAYMARCHING_STEP 45\n#define RAYMARCHING_JUMP 1.\n\n//------------------------------------------------------------------ DEBUG\n//#define RENDER_DEPTH\n//#define RENDER_NORMAL\n//#define RENDER_AO\n\n//------------------- FORMULAS/MAGIC\n\nvec4 vec4pow( in vec4 v, in float p ) {\n    // Don't touch alpha (w), we use it to choose the direction of the shift\n    // and we don't want it to go in one direction more often than the other\n    return vec4(pow(v.x,p),pow(v.y,p),pow(v.z,p),v.w); \n}\n\nvec4 permute(vec4 x){return mod(x*x*34.0+x,289.);}\n\nfloat snoise(vec3 v){\n  const vec2  C = vec2(0.166666667, 0.33333333333) ;\n  const vec4  D = vec4(0.0, 0.5, 1.0, 2.0);\n  vec3 i  = floor(v + dot(v, C.yyy) );\n  vec3 x0 = v - i + dot(i, C.xxx) ;\n  vec3 g = step(x0.yzx, x0.xyz);\n  vec3 l = 1.0 - g;\n  vec3 i1 = min( g.xyz, l.zxy );\n  vec3 i2 = max( g.xyz, l.zxy );\n  vec3 x1 = x0 - i1 + C.xxx;\n  vec3 x2 = x0 - i2 + C.yyy;\n  vec3 x3 = x0 - D.yyy;\n  i = mod(i,289.);\n  vec4 p = permute( permute( permute(\n\t  i.z + vec4(0.0, i1.z, i2.z, 1.0 ))\n\t+ i.y + vec4(0.0, i1.y, i2.y, 1.0 ))\n\t+ i.x + vec4(0.0, i1.x, i2.x, 1.0 ));\n  vec3 ns = 0.142857142857 * D.wyz - D.xzx;\n  vec4 j = p - 49.0 * floor(p * ns.z * ns.z);\n  vec4 x_ = floor(j * ns.z);\n  vec4 x = x_ *ns.x + ns.yyyy;\n  vec4 y = floor(j - 7.0 * x_ ) *ns.x + ns.yyyy;\n  vec4 h = 1.0 - abs(x) - abs(y);\n  vec4 b0 = vec4( x.xy, y.xy );\n  vec4 b1 = vec4( x.zw, y.zw );\n  vec4 s0 = floor(b0)*2.0 + 1.0;\n  vec4 s1 = floor(b1)*2.0 + 1.0;\n  vec4 sh = -step(h, vec4(0.0));\n  vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy ;\n  vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww ;\n  vec3 p0 = vec3(a0.xy,h.x);\n  vec3 p1 = vec3(a0.zw,h.y);\n  vec3 p2 = vec3(a1.xy,h.z);\n  vec3 p3 = vec3(a1.zw,h.w);\n  vec4 norm = inversesqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));\n  p0 *= norm.x;\n  p1 *= norm.y;\n  p2 *= norm.z;\n  p3 *= norm.w;\n  vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n  m = m * m * m;\n  return .5 + 12.0 * dot( m, vec4( dot(p0,x0), dot(p1,x1),dot(p2,x2), dot(p3,x3) ) );\n}\n\n// Maximum/minumum elements of a vector\nfloat vmax(vec2 v) {\n\treturn max(v.x, v.y);\n}\n\nfloat vmax(vec3 v) {\n\treturn max(max(v.x, v.y), v.z);\n}\n\nfloat vmax(vec4 v) {\n\treturn max(max(v.x, v.y), max(v.z, v.w));\n}\n\nfloat hash( float n ){//->0:1\n\treturn fract(sin(n)*3538.5453);\n}\n\nfloat smin( float a, float b )\n{\n    float k = .1;\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\nfloat displacement( vec3 p, float v ) {\n  float f = iTime * -0.5 + sin( iTime * 2. ) * 1.4;\n  return sin( 20. * sin( cos( f ) ) *p.x)*sin( 10. *sin( cos( f ) ) *p.y)*sin( 30. * sin( cos( f ) ) *p.z);\n}\n\n// Repeat around the origin by a fixed angle.\n// For easier use, num of repetitions is use to specify the angle.\nfloat pModPolar(inout vec2 p, float repetitions, float dis) {\n\tfloat angle = 2.*PI/repetitions;\n\tfloat a = atan(p.y+0.0000001, p.x+0.0000001) + angle/2.;\n\tfloat r = length(p);\n\tfloat c = floor(a/angle);\n\ta = mod(a,angle) - angle/2.;\n\tp = vec2(cos(a), sin(a))*r + 0.0000001;\n\t// For an odd number of repetitions, fix cell index of the cell in -x direction\n\t// (cell index would be e.g. -5 and 5 in the two halves of the cell):\n\tif (abs(c) >= (repetitions/2.)) c = abs(c);\n\treturn c;\n}\n\n// Repeat space along one axis. Use like this to repeat along the x axis:\n// <float cell = pMod1(p.x,5);> - using the return value is optional.\nfloat pMod1(inout float p, float size) {\n\tfloat halfsize = size*0.5;\n\tfloat c = floor((p + halfsize)/size);\n\tp = mod(p + halfsize, size) - halfsize;\n\treturn c;\n}\n\nvec2 pMod2(inout vec2 p, vec2 size) {\n\tvec2 c = floor((p + size*0.5)/size);\n\tp = mod(p + size*0.5,size) - size*0.5;\n\treturn c;\n}\n\n// Repeat only a few times: from indices <start> to <stop> (similar to above, but more flexible)\nfloat pModInterval1(inout float p, float size, float start, float stop) {\n\tfloat halfsize = size*0.5;\n\tfloat c = floor((p + halfsize)/size);\n\tp = mod(p+halfsize, size) - halfsize;\n\tif (c > stop) { //yes, this might not be the best thing numerically.\n\t\tp += size*(c - stop);\n\t\tc = stop;\n\t}\n\tif (c <start) {\n\t\tp += size*(c - start);\n\t\tc = start;\n\t}\n\treturn c;\n}\n\nfloat opS( float d1, float d2 )\n{\n    return max(-d1,d2);\n}\n\nfloat opU( float d1, float d2 )\n{\n    return min(d1,d2);\n}\n\nvec3 postEffects( in vec3 col, in vec2 uv, in float time )\n{    \n\t// vigneting\n    //col *= .9 + .2 * snoise( vec3( sin( iTime + uv.x ), cos( iTime + uv.y ), 0. ) );\n\tcol *= 0.4+0.6*pow( 16.0*uv.x*uv.y*(1.0-uv.x)*(1.0-uv.y), 0.5 );\n    col += col * .05 * snoise( vec3( -uv.x * 400., uv.y * 400. , iTime * 2. ) );\n    col = col * 1.05;\n    col -= .021;\n    return col;\n}\n\n//------------------- CAMERA STUFF\n\nvec3 orbit(float phi, float theta, float radius)\n{\n\treturn vec3(\n\t\tradius * sin( phi ) * cos( theta ),\n\t\tradius * cos( phi ),\n\t\tradius * sin( phi ) * sin( theta )\n\t);\n}\n\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr )\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n\treturn mat3( cu, cv, cw );\n}\n\n//------------------- PRIMITIVES\n\nvec2 rotate2D(vec2 p, float a) {\n return p * mat2(cos(a), -sin(a), sin(a),  cos(a));\n}\n\nfloat pyramid( vec3 p, float h) {\n\tvec3 q=abs(p);\n\treturn max(-p.y, (q.x*1.5+q.y *.75+q.z*1.5-h)/3.0 );\n}\n\nfloat sphere( vec3 p, float r ) {\n\treturn length( p ) - r;\n}\n\nfloat udRoundBox( vec3 p, vec3 b, float r )\n{\n  return length(max(abs(p)-b,0.0))-r;\n}\n\n// Box: correct distance to corners\nfloat fBox(vec3 p, vec3 b) {\n\tvec3 d = abs(p) - b;\n\treturn length(max(d, vec3(0))) + vmax(min(d, vec3(0)));\n}\n\n\n//------------------- MAP\n\nfloat opTwist( vec3 p )\n{\n    float c = cos(20.0*p.y);\n    float s = sin(20.0*p.y);\n    mat2  m = mat2(c,-s,s,c);\n    vec3  q = vec3(m*p.xz,p.y);\n    return udRoundBox( q, vec3( 2.5, .025, 0.005 ), .05 );\n}\n\nfloat opCheapBend( vec3 p )\n{\n    float c = cos(20.0*p.y);\n    float s = sin(20.0*p.y);\n    mat2  m = mat2(c,-s,s,c);\n    vec3  q = vec3(m*p.xy,p.z);\n    return udRoundBox( q, vec3( 2.5, .025, 0.005 ), .05 );\n}\n\nfloat ratio1 = 0.;\nfloat ratio2 = 0.;\n\nfloat repeatObj1( vec3 p ) {\n    \n    float res;\n    \n    vec3 op = p;\n    /*float idx1 = pModPolar( op.xy, 16., .0 );\n    op.x -= 2.75 +  cos( iTime * -0.5) * .75 + sin( iTime * 2.) * 0.4;\n    //op.x -= 3. + sin( iTime );\n    \n    //op.y = 1.5 * sin( idx1 );\n    op.xy = rotate2D( op.xy, PI * .5 + idx1 );// + sin( idx1 + iTime ) * .15 );\n    //op.xy = rotate2D( op.xy, PI * .5 );// + sin( idx1 + iTime ) * .15 );\n    \n    \n    float idx2 = pModInterval1( op.y, .22, -2., 2. );\n    \n    float idx3 = pModInterval1( op.z, .17, -2., 2. );\n    op.xy = rotate2D( op.xy, PI * .05 * sin( idx3 + p.x * p.y + iTime ) );\n    float idx4 = pModPolar( op.xy, 4., .0 );*/\n\n\n    float idx1 = pModPolar( op.xy, 24., .0 );\n    op.x -= 6.25 +  cos( iTime * -0.5) * .75 + sin( iTime * 2.) * 0.4;\n    //op.x -= 3. + sin( iTime );\n    \n    //op.y = 1.5 * sin( idx1 );\n    op.xy = rotate2D( op.xy, PI * 1.5 + idx1 );// + sin( idx1 + iTime ) * .15 );\n    //op.xy = rotate2D( op.xy, PI * .5 );// + sin( idx1 + iTime ) * .15 );\n    \n    \n    float idx2 = pModInterval1( op.y, .22, -2., 2. );\n    \n    float idx3 = pModInterval1( op.z, 2., -6., 8. );\n    op.xy = rotate2D( op.xy, PI * .05 * sin( idx3 + p.x * p.y + iTime ) );\n    float idx4 = pModPolar( op.xy, 6., .0 );\n     //pModInterval1( op.y, 1., -4., 4. );\n   //     op.x -= sin( 1. * idx4 );\n   \n    //float idx4 = pModInterval1( op.x, .5, -2., 0. );\n    \n    float obj =  fBox( op, vec3( .75, .05, .25 ) );\n    return obj;\n}\n\nfloat repeatObj2( vec3 p ) {\n    \n    float res;\n    \n    vec3 op = p;\n    \n    vec2 pi = vec2( 0., 0. );\n    //float idx = pModInterval1( op.x, cos( PI / 6. ), 0., PI );\n    //float idx2 = pModInterval1( op.y, sin( PI / 6. ), 0., PI );\n    //op.x\n    //op.x += cos( idx * PI / 6. ) * 3.;\n\n\n    float idx1 = pModPolar( op.yz, 16., .0 );\n    op.y -= .25;\n    //op.x -= .75 * idx1;\n    //op.x -= 3. + sin( iTime );\n    \n    //op.y = 1.5 * sin( idx1 );\n    op.xy = rotate2D( op.xy, PI * .5 + idx1 );// + sin( idx1 + iTime ) * .15 );\n    //op.xy = rotate2D( op.xy, PI * .5 );// + sin( idx1 + iTime ) * .15 );\n    \n    \n    float idx2 = pModInterval1( op.y, .22, -2., 2. );\n    op.xy = rotate2D( op.xy, PI * .5 + sin( idx1 + iTime ) * .15 );\n    \n    //op.xy = rotate2D( op.xy, PI * .05 * sin( idx3 + p.x * p.y + iTime ) );\n    float idx4 = pModPolar( op.xy, 4., .0 );\n    \n    float obj =  fBox( op, vec3( .75, .05, 0.05 ) );\n    return obj;\n    \n}\n\nfloat modAngle(inout vec2 p, float a) {\n  float a1 = atan(p.y, p.x);\n  float a2 = mod(a1 + a * 0.5, a) - a * 0.5;\n\n  p = vec2(cos(a2), sin(a2)) * length(p);\n\n  return mod(floor(a1 / a + 0.5), 2.0 * PI / a);\n}\n\nfloat modRot(inout vec2 p, float i) {\n  return modAngle(p, 2.0 * PI / i);\n}\n\nfloat repeatObj3( vec3 p ) {\n    \n    float res;\n    \n    vec3 op = p;\n    \n    vec2 pi = vec2( 0., 0. );\n    //float idx = pModInterval1( op.x, cos( PI / 6. ), 0., PI );\n    //float idx2 = pModInterval1( op.y, sin( PI / 6. ), 0., PI );\n    //op.x\n    //op.x += cos( idx * PI / 6. ) * 3.;\n\n\n    float idx1 = pModPolar( op.xy, 16., .0 );\n    op.x -= 2.75 +  cos( iTime * -0.5) * .75 + sin( iTime * 2.) * 0.4;\n    //op.x -= 3. + sin( iTime );\n    \n    //op.y = 1.5 * sin( idx1 );\n    op.xy = rotate2D( op.xy, PI * .5 + idx1 );// + sin( idx1 + iTime ) * .15 );\n    //op.xy = rotate2D( op.xy, PI * .5 );// + sin( idx1 + iTime ) * .15 );\n    \n    \n    float idx2 = pModInterval1( op.y, .22, -2., 2. );\n    \n    float idx3 = pModInterval1( op.z, .17, -2., 2. );\n    op.xy = rotate2D( op.xy, PI * .05 * sin( idx3 + p.x * p.y + iTime ) );\n    float idx4 = pModPolar( op.xy, 4., .0 );\n     //pModInterval1( op.y, 1., -4., 4. );\n   //     op.x -= sin( 1. * idx4 );\n   \n    //float idx4 = pModInterval1( op.x, .5, -2., 0. );\n    \n    float obj =  fBox( op, vec3( 1., .05, 0.05 ) );\n    return obj;\n    \n}\n\nfloat map( in vec3 p ) {\n    vec3 np = vec3( p.x, p.y, p.z );\n    \n    \n    \n    //np.xy = rotate2D( np.xy, PI * .5 );\n    //float idx1 = pModPolar( np.xy, 10. );\n    //pModPolar( np.xy, 2. );\n    //np.x -= 4.;\n    \n    //np.xy = rotate2D( np.xy, PI * ( .45 ) );\n    \n    //float idx2 = pModInterval1( np.y, .5, -1., 2. );\n    //np.x -= abs( cos( iTime ) ) * 4.;\n    //np.z -= abs( sin( iTime ) ) * 4.;\n    //np.y += sin( iTime ) * 4.;\n    //np.zy = rotate2D( np.zy, iTime * PI * .25 );\n    //np.z -= 1.5;\n    //np.x *= cos( idx * - PI / 2. ) * 2.;\n    //np.y *= sin( idx * - PI ) * 2.;\n    //np.xy = rotate2D( np.xy, sin( iTime * idx + p.x ) );\n    \n    \n    //np = p;\n    //np.x += cos( iTime ) * 4.;\n    //np.y += sin( iTime ) * 4.;\n    \n    /*\n    float obj;\n    vec3 op;\n    \n    const int count = 6;\n    float a = 0.;\n    float aAdd = PI * 2. / float( count );\n    float radius = 4.;\n    float res = 9999.;\n    for( int i = 0; i < count; i++ ) {\n        op = p;\n        op.x = p.x + cos( a ) * radius;\n        op.y = p.y + sin( a ) * radius;\n        op.xy = rotate2D( op.xy, -a + PI * .5 );\n        op.zy = rotate2D( op.zy, a );\n    \tobj = udRoundBox( op, vec3( .5, .05, 0.005 ), .05 );\n\t\ta += aAdd;        \n\n        res = opU( res, obj );\n    }\n*/\n    \n    float res;\n    float obj1 = repeatObj1( p );\n    float obj2 = repeatObj2( p );\n    float obj3 = repeatObj3( p );\n    res = opU( obj2, obj3 );\n    //res = repeatObj1( p );\n    //res = opU( res, repeatObj2( p ) );\n   //res = repeatObj2( p );\n    \n    //float f = p.y - .4;\n    //r = opU( r, f );\n    \n    float k = 1.5;\n    float h = clamp( 0.5 + 0.5 * ( obj2 - obj3 ) / k, 0.0, 1.0 );\n    \n    res = mix( obj2, obj3, h ) - k*h*( 1.0 - h );\n    \n    res = obj3;\n    \n    h = clamp( 0.5 + 0.5 * ( res - obj1 ) / k, 0.0, 1.0 );\n    res = mix( res, obj1, h ) - k*h*( 1.0 - h );\n    \n    res = opU( obj1, obj3 );\n    \n    if( obj1 < obj3 ) {\n        ratio1 = 0.;\n        ratio2 = 1.;\n    } else {\n        ratio1 = 1.;\n        ratio2 = 0.;\n    }\n    \n    return res;\n}\n\n//------------------- RAYMARCHING\n\n#ifdef RENDER_DEPTH\nfloat castRay( in vec3 ro, in vec3 rd, inout float depth ) {\n#else\nfloat castRay( in vec3 ro, in vec3 rd ) {\n#endif\n    float t = 0.;\n    float res;\n    for( int i = 0; i < RAYMARCHING_STEP; i++ ) {\n        vec3 pos = ro + rd * t;\n        res = map( pos );\n        if( res < .025 || t > 100. ) break;\n        t += res * RAYMARCHING_JUMP;\n        #ifdef RENDER_DEPTH\n\t\tdepth += 1./float(RAYMARCHING_STEP);\n\t\t#endif\n    }\n    return t;\n}\n\nvec3 calcNormal(vec3 pos) {\n    float eps = 0.001;\n\tconst vec3 v1 = vec3( 1.0,-1.0,-1.0);\n\tconst vec3 v2 = vec3(-1.0,-1.0, 1.0);\n\tconst vec3 v3 = vec3(-1.0, 1.0,-1.0);\n\tconst vec3 v4 = vec3( 1.0, 1.0, 1.0);\n\treturn normalize( v1 * map( pos + v1*eps ) +\n    \t              v2 * map( pos + v2*eps ) +\n        \t          v3 * map( pos + v3*eps ) +\n            \t      v4 * map( pos + v4*eps ) );\n}\n\nfloat calcAO( in vec3 p, in vec3 n, float maxDist, float falloff ){\n\tfloat ao = 0.0;\n\tconst int nbIte = 6;\n\tfor( int i=0; i<nbIte; i++ )\n\t{\n\t\tfloat l = hash(float(i))*maxDist;\n\t\tvec3 rd = n*l;\n\t\tao += (l - map( p + rd )) / pow(1.+l, falloff);\n\t}\n\treturn clamp( 1.-ao/float(nbIte), 0., 1.);\n}\n\n// calculate local thickness\n// base on AO but : inverse the normale & inverse the color\nfloat thickness( in vec3 p, in vec3 n, float maxDist, float falloff )\n{\n\tfloat ao = 0.0;\n\tconst int nbIte = 6;\n\tfor( int i=0; i<nbIte; i++ )\n\t{\n\t\tfloat l = hash(float(i))*maxDist;\n\t\tvec3 rd = -n*l;\n\t\tao += (l + map( p + rd )) / pow(1.+l, falloff);\n\t}\n\treturn clamp( 1.-ao/float(nbIte), 0., 1.);\n}\n    \nvec3 sundir = normalize( vec3(-1.5,2.,-1.5) );\n\nvec3 addLight( in vec3 posLight, in vec3 colLight, in vec3 nor, in vec3 pos, in vec3 ref, in float radius, in float specRatio ) {\n    float thi = thickness(pos, nor, 6., 1.5);\n    \n    float intens = max( dot( nor, posLight ), 0. );\n    float dist = length( posLight - pos );\n    float att = clamp(1.0 - dist*dist/(radius*radius), 0.0, 1.0);\n    att *= att;\n    float specular = pow( clamp( dot( ref, posLight ), 0., 1.0 ), 16. );\n    vec3 col = colLight * intens * att;\n    col += specular * .5 * att * specRatio * thi;\n    return col;\n}\n    \nvec3 render( in vec3 ro, in vec3 rd, in vec2 uv ) {\n\tvec3 col = vec3( 1., .0, 1. );\n    \n    float sun = clamp( dot(sundir,rd), 0.0, 1.0 );\n    vec3 colBg = vec3(0.0, 0., 0.) - rd.y*0.2*vec3(1., 1., 0.) + 0.15*0.5;\n\tcolBg += 0.2*vec3(1.0,0.,0.1)*pow( sun, 2.0 );\n    //colBg = vec3(cos( uv.y * uv.x ) * .1,cos( uv.y ) * .25,sin( uv.x ) + cos( uv.y ) * .5 ) / 5.;\n    \n    colBg = vec3( 1., 1., 1. );\n    \n    #ifdef RENDER_DEPTH\n\tfloat depth = 0.;\n    float t = castRay( ro, rd, depth );\n    #else\n    float t = castRay( ro, rd );\n    #endif\n    \n    #ifdef RENDER_DEPTH\n    return vec3( depth / 5., depth, depth );\n    #endif\n    \n    vec3 pos = ro + t * rd;\n    vec3 nor = calcNormal( pos );\n    \n    #ifdef RENDER_NORMAL\n    return nor;\n    #endif\n    \n    float ao = calcAO( pos, nor, 10., 1.2 );\n    #ifdef RENDER_AO\n    return vec3( ao );\n    #endif\n    \n    //vec3 light = vec3( 1.5, 1., 1. );\n    \n    vec3 ref = reflect( rd, nor );\n    \n    col = colBg;\n    if( t < 20. ) {\n        col = vec3( 1., 0., 1. );\n        //col = colBg * ratio1 + col * ratio2;\n    }// else if ( t < 10. ) {\n       // col = vec3( 1., 0., 1. );\n    //}\n    // top blue light\n    col += addLight( vec3( .3, 5.,1. ), vec3( .498, .898, .952 ), nor, pos, ref, 6., 1. );\n    // right green dark\n    col += addLight( vec3( 4.2, 1.5, 1. ), vec3( 0.06, .407, .27 ), nor, pos, ref, 6.25, 0. );\n    // bottom right blue light\n    col += addLight( vec3( 5., -2., 1.85 ), vec3( 0.082, .443, .541 ), nor, pos, ref, 6., 0. );\n    // bottom left red\n    col += addLight( vec3( -4., 0., 1.85 ), vec3( 0.79, .168, .015 ), nor, pos, ref, 6., 0.25 );\n    \n   // col += addLight( vec3( 0., 1.5, 1.5 ), vec3( 1., .0, 0. ), nor, pos, ref, 3.5, 0.5 );\n    \n   // col += .35 * addLight( vec3( 0.21, 2.85, .0 ), vec3( 1., 0.79, .16 ), nor, pos, ref, 4., .0 );\n   \n    //col += 1.1 * vec3( 1., 0.4, 0.2 ) * ( 1. - abs( pow( sun, 3. ) ) );\n    col += .41 * vec3( 1., 0.79, .16 ) * abs( pow( sun, 3. ) );\n    col *= ao;\n    \n    vec3 fog = vec3( EPSILON );\n   \tcol = mix( col, colBg, 1. - exp( -.00051505 * t* t * t ) );   \n    \n    col = col;\n    \n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 p = -1. + 2. * uv;\n    p.x *= iResolution.x / iResolution.y;\n    \n    //vec2 m = iMouse.xy/iResolution.xy;\n    \n    // Camera\n\t\n\t//vec3 ta  = vec3( EPSILON, +.4, .5 );\n    float radius = 4.5;\n    vec3 ro = orbit( PI/2.,PI/2.,radius );\n    //vec3 ro = vec3( 0., 0., 5. );//orbit(0.,EPSILON,radius);\n    vec3 ta = vec3( 0., 0., 0. );\n    //ta.y = 1.;\n   \n    // Camera to world transformation\n    mat3 ca = setCamera( ro, ta, EPSILON );\n    \n    // Ray direction\n    vec3 rd = ca * normalize( vec3( p.xy, 1. ) );\n    \n    // Raymarching\n    vec3 c = render( ro, rd, uv );\n    c.r = smoothstep(0.0, 1.0, c.r);\n\tc.g = smoothstep(0.0, 1.0, c.g - 0.1);\n\tc.b = smoothstep(-0.3, 1.3, c.b);\n    c = postEffects( c, uv, 0. );\n    fragColor = vec4( c, 1. );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/Mdd3D2.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "Mdd3zl", "name": "Metaball snake", "author": "TambakoJaguar", "description": "I tried to program this \"Metaball snake\" which follows a double sinus curve, but it is extremely slow. Do you have any idea how to optimize the code? Thanks for any help.", "tags": ["3d", "raymarching", "test", "snake", "hexagon", "sinus", "shapes", "fresnel", "mataballs", "floorreflection"], "likes": 7, "viewed": 308, "date": "1452587596", "time_retrieved": "2024-06-20T18:30:36.322000", "image_code": "/*\n\"Sine metaballs\" by Emmanuel Keller aka Tambako - December 2015\nLicense Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\nContact: tamby@tambako.ch\n*/\n\n#define pi 3.141593\n\nstruct Lamp\n{\n  vec3 position;\n  vec3 color;\n  float intensity;\n  float attenuation;\n};\n\nstruct RenderData\n{\n  vec3 col;\n  vec3 pos;\n  vec3 norm;\n  int objnr;\n};\n    \nconst int nbBalls = 10;\nconst float bSize0 = 1.;\nconst float btShift = 0.26;\nconst float btSFact = 0.94;\nconst float bmovamp = 1.8;\n    \nLamp lamps[3];\n\nvec3 campos = vec3(0., 3., 15.);\nvec3 camdir = vec3(0., -0.29, -1.);\nfloat fov = 2.8;\n\nconst vec3 ambientColor = vec3(0.1, 0.4, 0.9);\nconst float ambientint = 0.17;\n\nvec3 colors[3];\n\n//#define shadow\n#define floorref\n#define ambocc\n#define specular\nconst float specint = 0.27;\nconst float specshin = 11.;\nconst float aoint = 1.5;\nconst float shi = 0.8;\nconst float shf = 0.9;\n\nconst float normdelta = 0.002;\nconst float maxdist = 80.;\n\nconst float flpos = 3.2;\n\nvec4 hex;\nconst float hexts = 1.9;\nconst float hexth = 0.1;\nconst float hexbw = 0.15;\n\n// Antialias. Change from 1 to 2 or more AT YOUR OWN RISK! It may CRASH your browser while compiling!\nconst float aawidth = 0.8;\nconst int aasamples = 1;\n\nvec2 rotateVec(vec2 vect, float angle)\n{\n    vec2 rv;\n    rv.x = vect.x*cos(angle) + vect.y*sin(angle);\n    rv.y = vect.x*sin(angle) - vect.y*cos(angle);\n    return rv;\n}\n\n// From https://www.shadertoy.com/view/Xd2GR3\nvec4 hexagon(vec2 p) \n{\n\tvec2 q = vec2( p.x*2.0*0.5773503, p.y + p.x*0.5773503 );\n\t\n\tvec2 ppi = floor(q);\n\tvec2 pf = fract(q);\n\n\tfloat v = mod(ppi.x + ppi.y, 3.0);\n\n\tfloat ca = step(1.0,v);\n\tfloat cb = step(2.0,v);\n\tvec2  ma = step(pf.xy,pf.yx);\n\t\n    // distance to borders\n\tfloat e = dot( ma, 1.0-pf.yx + ca*(pf.x+pf.y-1.0) + cb*(pf.yx-2.0*pf.xy) );\n\n\t// distance to center\t\n\tp = vec2( q.x + floor(0.5+p.y/1.5), 4.0*p.y/3.0 )*0.5 + 0.5;\n\tfloat f = length( (fract(p) - 0.5)*vec2(1.0,0.85) );\t\t\n\t\n\treturn vec4( ppi + ca - cb*ma, e, f );\n}\n\nvec3 getHexagonColor(vec4 hex, float nbcols, vec3 pos)\n{\n    colors[0] = vec3(.95, .88, .75);\n    colors[1] = vec3(.6, .7, .8);\n    colors[2] = vec3(.75, .95, .3);\n    \n    int colnr = int(mod(hex.x, nbcols));\n    /*vec3 color = vec3(mod(colnr, 3.)==0., mod(colnr, 3.)==1., mod(colnr, 3.)==2.);\n    if (colnr>2.)\n        color = vec3(1.) - color;\n    \n    vec3 color2 = vec3(0.5*color.r + 0.3*color.g + 0.7*color.b,\n                       0.3*color.r + 0.7*color.g + 0.4*color.b,\n                       0.8*color.r + 0.5*color.g + 0.3*color.b);*/\n    \n    vec3 color2 = colnr==0?colors[0]*(0.25 + 0.75*texture(iChannel0, 0.2*pos.xz).rgb):(colnr==1?\n                           colors[1]*(0.25 + 0.75*texture(iChannel1, 0.2*pos.xz).rgb):\n                           colors[2]*(0.25 + 0.75*texture(iChannel2, 0.2*pos.xz).rgb));\n    \n    return color2;\n}\n\nfloat getHexagonHeight(vec4 hex, float borderw)\n{\n    return -1. + 2.*smoothstep(-borderw, borderw, hex.z);\n    //return -2.5 + 2.*smoothstep(-borderw, borderw, hex.z) + 0.5*pow(smoothstep(0., borderw*2.7, hex.w), 2.);\n}\n\nvec3 getObjPosition(float time)\n{    \n   float x = sin(time*1.05);\n   float y = .8*sin(time);\n   float z = sin(time*1.15 + radians(90.));\n    \n   x+= .2*sin(time*2.5 + radians(45.));\n   y+= .4*sin(time*1.5 + radians(20.));\n   z+= .3*sin(time*2.2);\n\n   x+= .03*sin(time*4.5 + radians(10.));\n   y+= .05*sin(time*4.2 + radians(90.));\n   z+= .07*sin(time*5.5);\n\n   return vec3(x, y, z);\n}\n\nfloat floorm(vec3 pos)\n{\n  \thex = hexagon(pos.xz/hexts);\n   \tfloat hexy = hex.x-2.*hex.y;\n   \tfloat h = hexth*(getHexagonHeight(hex, hexbw) - 1.);\n    return hexy<32.?pos.y + flpos - h:500.;\n}\n\n// From https://www.shadertoy.com/view/ld2GRz\nfloat sdMetaBalls(vec3 pos, bool nofloor)\n{\n\tfloat m = 0.0;\n\tfloat p = 0.0;\n\tfloat dmin = 1e20;\n\t\t\n\tfloat h = 1.0; // track Lipschitz constant\n\t\n\tfor( int i=0; i<nbBalls; i++ )\n\t{\n\t\t// bounding sphere for ball\n        float fact = pow(btSFact, float(i));\n        vec3 oPos = bmovamp*getObjPosition(iTime - float(i)*btShift*fact);\n        float db = distance( oPos , pos );\n        float size = bSize0*fact;\n        if( db < size )\n    \t{\n    \t\tfloat x = db/size;\n    \t\tp += 1.0 - x*x*x*(x*(x*6.0-15.0)+10.0);\n\t    \tm += 1.0;\n    \t\th = max( h, 0.5333*size );\n\t    }\n\t    else // bouncing sphere distance\n\t    {\n    \t\tdmin = min( dmin, db - size );\n    \t}\n\t}\n    float d = dmin + 0.1;\n\t\n\tif( m>0.5 )\n\t{\n\t\tfloat th = 0.2;\n\t\td = h*(th-p);\n\t}\n\t\n\treturn min(d, nofloor?100.:floorm(pos));\n}\n\nfloat map(vec3 pos, bool nofloor)\n{\n    return sdMetaBalls(pos, nofloor);\n    \n    float d = 0.;\n    for (int b=0; b<nbBalls; b++)\n    {\n        vec3 oPos = bmovamp*getObjPosition(iTime - float(b)*btShift); //iTime\n        float size = (bSize0 - 1.)*pow(btSFact, float(b));\n        d+= size/dot(pos - oPos, pos - oPos);\n    }   \n    return min(1. - d, nofloor?100.:floorm(pos));\n}\n\nfloat trace(vec3 cam, vec3 ray, float maxdist, bool nofloor) \n{\n    float t = 2.;\n  \tfor (int i = 0; i < 75; ++i)\n    {\n    \tvec3 pos = ray*t + cam;\n    \tfloat dist = map(pos, nofloor);\n        if (dist>maxdist || abs(dist)<0.02)\n            break;\n        t+= dist*(t>20.?1.:0.6);\n  \t}\n  \treturn t;\n}\n\n// From https://www.shadertoy.com/view/ld2GRz\nvec3 norMetaBalls(vec3 pos, float e)\n{\n\tvec3 nor = vec3( 0.0, e, 0.0 );\n\t\t\n\tfor( int i=0; i<nbBalls; i++ )\n\t{\n        float fact = pow(btSFact, float(i));\n        vec3 oPos = bmovamp*getObjPosition(iTime - float(i)*btShift*fact);\n        float db = distance( oPos , pos );\n        float size = bSize0*fact;\n\t\tfloat x = clamp( db/size, 0.0, 1.0 );\n\t\tfloat p = x*x*(30.0*x*x - 60.0*x + 30.0);\n\t\tnor += normalize( pos - oPos ) * p / size;\n\t}\n\t\n\treturn normalize( nor );\n}\n\n// From https://www.shadertoy.com/view/MstGDM\nvec3 getNormal(vec3 pos, float e)\n{\n    if (pos.y>-flpos + 0.1)\n        return norMetaBalls(pos, e);\n    \n    vec2 q = vec2(0, e);\n    return normalize(vec3(floorm(pos + q.yxx) - floorm(pos - q.yxx),\n                          floorm(pos + q.xyx) - floorm(pos - q.xyx),\n                          floorm(pos + q.xxy) - floorm(pos - q.xxy)));\n}\n\nvec3 floor_color(vec3 pos)\n{\n    return getHexagonColor(hex, 3., pos);\n}\n\nvec3 obj_color(vec3 norm, vec3 pos)\n{\n    float cp = dot(cross(norm.xyz, norm.zxy), norm.yzx) - 0.2;\n    return mix(vec3(1., 1., 0.), vec3(1., 0., 1.), cp);\n}\n\nvec3 sky_color(vec3 ray)\n{\n    return ambientColor + vec3(0.4, 0.3, 0.05)*2.8*(0.53-atan(ray.y)); \n}\n\n// From https://www.shadertoy.com/view/Xds3zN;\nfloat softshadow(vec3 ro, vec3 rd, float mint, float tmax)\n{\n\tfloat res = 1.0;\n    float t = mint;\n    for(int i=0; i<16; i++)\n    {\n    \tfloat h = map(ro + rd*t, true);\n        res = min( res, 8.0*h/t );\n        t += clamp( h, 0.02, 0.10 );\n        if( h<0.001 || t>tmax ) break;\n    }\n    return clamp( res, 0.0, 1.0 );\n}\n\nfloat hash( float n ){\n\treturn fract(sin(n)*3538.5453);\n}\n\nfloat calcAO( in vec3 p, in vec3 n, float maxDist, float falloff ){\n\tfloat ao = 0.0;\n\tconst int nbIte = 5;\n\tfor( int i=0; i<nbIte; i++ )\n\t{\n\t\tfloat l = hash(float(i))*maxDist;\n\t\tvec3 rd = n*l;\n\t\tao += (l - map( p + rd, false )) / pow(1.+l, falloff);\n\t}\n\treturn clamp( 1.35*(1.-ao/float(nbIte)), 0., 1.);\n}\n\n// Fresnel reflectance factor through Schlick's approximation: https://en.wikipedia.org/wiki/Schlick's_approximation\nfloat fresnel(vec3 ray, vec3 norm, float n2)\n{\n   float n1 = 1.; // air\n   float angle = acos(-dot(ray, norm));\n   float r0 = dot((n1-n2)/(n1+n2), (n1-n2)/(n1+n2));\n   float r = r0 + (1. - r0)*pow(1. - cos(angle), 5.);\n   return r;\n}\n\nvec3 lampShading(Lamp lamp, vec3 norm, vec3 pos, vec3 ocol)\n{\n\tvec3 pl = normalize(lamp.position - pos);\n    float dlp = distance(lamp.position, pos);\n    vec3 pli = pl/pow(1. + lamp.attenuation*dlp, 2.);\n      \n    // Diffuse shading\n    vec3 col = ocol*normalize(lamp.color)*lamp.intensity*clamp(dot(norm, pli), 0., 1.);\n    \n    // Specular shading\n    #ifdef specular\n    if (dot(norm, lamp.position - pos) > 0.0)\n        col+= vec3(1., 0.7, 0.3)*normalize(lamp.color)*lamp.intensity*specint*pow(max(0.0, dot(reflect(pl, norm), normalize(pos - campos))), specshin);\n    #endif\n    \n    // Softshadow\n    #ifdef shadow\n    col*= shi*softshadow(pos, normalize(lamp.position - pos), shf, 6.) + 1. - shi;\n    #endif\n    \n    return col;\n}\n\nvec3 lampsShading(vec3 norm, vec3 pos, vec3 ocol)\n{\n    vec3 col = vec3(0.);\n    for (int l=0; l<3; l++) // lamps.length()\n        col+= lampShading(lamps[l], norm, pos, ocol);\n    \n    return col;\n}\n\n// From https://www.shadertoy.com/view/lsSXzD, modified\nvec3 GetCameraRayDir(vec2 vWindow, vec3 vCameraDir, float fov)\n{\n\tvec3 vForward = normalize(vCameraDir);\n\tvec3 vRight = normalize(cross(vec3(0.0, 1.0, 0.0), vForward));\n\tvec3 vUp = normalize(cross(vForward, vRight));\n    \n\tvec3 vDir = normalize(vWindow.x * vRight + vWindow.y * vUp + vForward * fov);\n\n\treturn vDir;\n}\n\nRenderData trace0(vec3 tpos, vec3 ray, bool nofloor)\n{\n    float tx = trace(tpos, ray, maxdist, nofloor);\n    vec3 col;\n    int objnr;\n    \n    vec3 pos = tpos + tx*ray;\n    vec3 norm;\n    if (tx<maxdist*0.65)\n    {\n        norm = getNormal(pos, normdelta);\n\n        // Coloring\n        if (pos.y<=-flpos+0.025)\n        {\n           col = floor_color(pos);\n           objnr = 1;\n        }\n        else\n        {\n           col = obj_color(norm, pos);\n           objnr = 2;\n        }\n      \n        // Shading\n        col = ambientColor*ambientint + lampsShading(norm, pos, col);\n        \n        // Ambient occlusion\n        #ifdef ambocc\n        col*= 1. - aoint + aoint*vec3(calcAO(pos, norm, 7., 1.1));\n        //col = vec3(calcAO(pos, norm, 7., 1.1));\n        #endif\n  }\n  else\n  {\n      // Sky\n      col = sky_color(ray);\n      objnr = 3;\n  }\n  return RenderData(col, pos, norm, objnr);\n}\n\nvec4 render(vec2 fragCoord)\n{\n  lamps[0] = Lamp(vec3(-1., 4.5, 10.), vec3(1., 1., 1.), 7.5, 0.1);\n  lamps[1] = Lamp(vec3(9., -0.5, 6.), vec3(1.0, 0.98, 0.9), 3.8, 0.1);\n  lamps[2] = Lamp(vec3(-8., 1.8, -5.), vec3(1.0, 0.7, 0.7), 2., 0.1);\n    \n  vec2 uv = fragCoord.xy / iResolution.xy; \n  uv = uv*2.0 - 1.0;\n  uv.x*= iResolution.x / iResolution.y;\n\n  vec3 ray = GetCameraRayDir(uv, camdir, fov);\n    \n  RenderData traceinf = trace0(campos, ray, false);\n  vec3 col = traceinf.col;\n  #ifdef floorref\n  if (traceinf.objnr==1)\n  {\n     RenderData traceinf_floor = trace0(traceinf.pos, reflect(ray, traceinf.norm), true);\n     float r = 1.2*clamp(fresnel(ray, traceinf.norm, 2.1), 0.0, 0.3);\n     col = mix(col, traceinf_floor.col, r);\n     //col = traceinf_floor.col;\n  }\n  #endif\n\n  return vec4(col, 1.0);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // Antialiasing\n    vec4 vs = vec4(0.);\n    for (int j=0;j<aasamples ;j++)\n    {\n       float oy = float(j)*aawidth/max(float(aasamples-1), 1.);\n       for (int i=0;i<aasamples ;i++)\n       {\n          float ox = float(i)*aawidth/max(float(aasamples-1), 1.);\n          vs+= render(fragCoord + vec2(ox, oy));\n       }\n    }\n    fragColor = vs/vec4(aasamples*aasamples);    \n}", "image_inputs": [{"id": "XsfGRn", "previewfilepath": "/media/ap/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg", "ctype": "texture"}, {"id": "4df3Rr", "previewfilepath": "/media/ap/3871e838723dd6b166e490664eead8ec60aedd6b8d95bc8e2fe3f882f0fd90f0.jpg", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/3871e838723dd6b166e490664eead8ec60aedd6b8d95bc8e2fe3f882f0fd90f0.jpg", "ctype": "texture"}, {"id": "Xsf3Rr", "previewfilepath": "/media/ap/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc-by-nc-sa-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/Mdd3zl.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "MdG3Wh", "name": "Overlaid trig patterns 1", "author": "fallicory", "description": "Overlapping coloured layers creating visually disorientating movement", "tags": ["2d", "interference", "trigonometric"], "likes": 6, "viewed": 612, "date": "1454191766", "time_retrieved": "2024-06-20T18:30:36.600807", "image_code": "\n\n#define PI 3.14159265359\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = vec2(fragCoord.x / iResolution.y, fragCoord.y / iResolution.y);\n    \n    // Get the coordinates relative to the centre\n    vec2 relative = vec2((uv.x * 2.0) - (iResolution.x / iResolution.y), (uv.y * 2.0) - 1.0);\n    \n    // Convert to polar coords\n    float angle = atan(relative.y, relative.x);\n    float dist = length(relative);\n    \n    // Work out individual colour rotations\n    float rRotate = angle + sin(iTime * 0.5) / 10.0;\n    float gRotate = angle + sin(iTime * 0.7) / 10.0;\n    float bRotate = angle + sin(iTime * 1.3) / 10.0;\n    \n    // Magic!\n    float r = (sin(  (dist * PI * 16.0) + iTime * 4.0 + (sin(rRotate * 3.0 * 24.0) * 1.5) + (sin(rRotate * 3.0 * 4.0) * 10.0) + (sin(rRotate * 3.0 * 3.0)*7.0)   ) + 1.0) / 2.0;\n    float g = (sin(  (dist * PI * 16.0) + iTime * 4.0 + (sin(rRotate * 3.0 * 17.0) * 1.5) + (sin(gRotate * 3.0 * 5.0) * 10.0) + (sin(gRotate * 3.0 * 3.0)*6.0)   ) + 1.0) / 2.0;\n    float b = (sin(  (dist * PI * 16.0) + iTime * 4.0 + (sin(rRotate * 3.0 * 33.0) * 1.5) + (sin(bRotate * 3.0 * 3.0) * 10.0) + (sin(bRotate * 3.0 * 3.0)*8.0)   ) + 1.0) / 2.0;\n\n    // Dull green channel as it's a bit overwhelming as the eye is more sensitive to green\n    g = 0.8 * g;\n    \n    // Brighten near centre\n    r = r + (clamp(1.2 - dist, 0.0, 1.0) * 0.4 * 2.0);\n    g = g + (clamp(1.2 - dist, 0.0, 1.0) * 0.3 * 2.0);\n    b = b + (clamp(1.2 - dist, 0.0, 1.0) * 0.5 * 2.0);\n    \n    // Dim very centre\n    float dimming = (clamp(0.35 - dist, 0.0, 0.35) * 7.0);\n    r = r - dimming;\n    g = g - dimming;\n    b = b - dimming;\n     \n    // Vingette effect\n    float vingette = (1.0 - (dist * 0.5));\n    r = r * vingette;\n    g = g * vingette;\n    b = b * vingette;\n    \n    fragColor = vec4(r, g, b, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/MdG3Wh.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "MdGGDz", "name": "Metro Lights", "author": "phil", "description": "My first shader with noise. I guess the next step is to understand what's going on in the noise function :)", "tags": ["noise", "raster", "cricle"], "likes": 8, "viewed": 257, "date": "1453987223", "time_retrieved": "2024-06-20T18:30:37.558658", "image_code": "const vec3 BACKGROUND_COLOR = vec3(0.0);\nconst float CIRCLE_RADIUS = 0.5;\nconst float SAMPLE_FACTOR = 25.0;\nconst float SPEED = .15;\nconst float NOISE_SCALE = 6.0;\n\n\n\n/********************************************************************\n\tNoise function copied from https://github.com/ashima/webgl-noise\n********************************************************************/\n\n//\n// Description : Array and textureless GLSL 2D/3D/4D simplex \n//               noise functions.\n//      Author : Ian McEwan, Ashima Arts.\n//  Maintainer : ijm\n//     Lastmod : 20110822 (ijm)\n//     License : Copyright (C) 2011 Ashima Arts. All rights reserved.\n//               Distributed under the MIT License. See LICENSE file.\n//               https://github.com/ashima/webgl-noise\n// \n\nvec3 mod289(vec3 x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 mod289(vec4 x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 permute(vec4 x) {\n     return mod289(((x*34.0)+1.0)*x);\n}\n\nvec4 taylorInvSqrt(vec4 r)\n{\n  return 1.79284291400159 - 0.85373472095314 * r;\n}\n\nfloat snoise(vec3 v)\n  { \n  const vec2  C = vec2(1.0/6.0, 1.0/3.0) ;\n  const vec4  D = vec4(0.0, 0.5, 1.0, 2.0);\n\n// First corner\n  vec3 i  = floor(v + dot(v, C.yyy) );\n  vec3 x0 =   v - i + dot(i, C.xxx) ;\n\n// Other corners\n  vec3 g = step(x0.yzx, x0.xyz);\n  vec3 l = 1.0 - g;\n  vec3 i1 = min( g.xyz, l.zxy );\n  vec3 i2 = max( g.xyz, l.zxy );\n\n  //   x0 = x0 - 0.0 + 0.0 * C.xxx;\n  //   x1 = x0 - i1  + 1.0 * C.xxx;\n  //   x2 = x0 - i2  + 2.0 * C.xxx;\n  //   x3 = x0 - 1.0 + 3.0 * C.xxx;\n  vec3 x1 = x0 - i1 + C.xxx;\n  vec3 x2 = x0 - i2 + C.yyy; // 2.0*C.x = 1/3 = C.y\n  vec3 x3 = x0 - D.yyy;      // -1.0+3.0*C.x = -0.5 = -D.y\n\n// Permutations\n  i = mod289(i); \n  vec4 p = permute( permute( permute( \n             i.z + vec4(0.0, i1.z, i2.z, 1.0 ))\n           + i.y + vec4(0.0, i1.y, i2.y, 1.0 )) \n           + i.x + vec4(0.0, i1.x, i2.x, 1.0 ));\n\n// Gradients: 7x7 points over a square, mapped onto an octahedron.\n// The ring size 17*17 = 289 is close to a multiple of 49 (49*6 = 294)\n  float n_ = 0.142857142857; // 1.0/7.0\n  vec3  ns = n_ * D.wyz - D.xzx;\n\n  vec4 j = p - 49.0 * floor(p * ns.z * ns.z);  //  mod(p,7*7)\n\n  vec4 x_ = floor(j * ns.z);\n  vec4 y_ = floor(j - 7.0 * x_ );    // mod(j,N)\n\n  vec4 x = x_ *ns.x + ns.yyyy;\n  vec4 y = y_ *ns.x + ns.yyyy;\n  vec4 h = 1.0 - abs(x) - abs(y);\n\n  vec4 b0 = vec4( x.xy, y.xy );\n  vec4 b1 = vec4( x.zw, y.zw );\n\n  //vec4 s0 = vec4(lessThan(b0,0.0))*2.0 - 1.0;\n  //vec4 s1 = vec4(lessThan(b1,0.0))*2.0 - 1.0;\n  vec4 s0 = floor(b0)*2.0 + 1.0;\n  vec4 s1 = floor(b1)*2.0 + 1.0;\n  vec4 sh = -step(h, vec4(0.0));\n\n  vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy ;\n  vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww ;\n\n  vec3 p0 = vec3(a0.xy,h.x);\n  vec3 p1 = vec3(a0.zw,h.y);\n  vec3 p2 = vec3(a1.xy,h.z);\n  vec3 p3 = vec3(a1.zw,h.w);\n\n//Normalise gradients\n  vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));\n  p0 *= norm.x;\n  p1 *= norm.y;\n  p2 *= norm.z;\n  p3 *= norm.w;\n\n// Mix final noise value\n  vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n  m = m * m;\n  return 42.0 * dot( m*m, vec4( dot(p0,x0), dot(p1,x1), \n                                dot(p2,x2), dot(p3,x3) ) );\n  }\n\n/******************************************************************/\n\n\n\n\nvec3 lights (in vec2 i, in vec2 uv, float time) {\n    float n = snoise(vec3(vec2(i/NOISE_SCALE), time/(1./SPEED)));\n    \n    // keep low lights visible\n    n = clamp(n, .1, 1.);\n    \n    // highlight peaks\n    if(n > .7) {\n    \tn = 1.;\n    }                   \n\n    vec3 luminosity = vec3(n);\n\tvec3 color = vec3(\n        cos(sin(n*3.5) + .5),\n        sin(time)/10. + .5,\n        cos(time)/9. + .55);\n    \n    // boost red\n    if(color.r > .9) {\n    \tcolor.g -= .2;\n        color.b -= .2;\n    }\n    return luminosity * color;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n   \n    // correct acpect ratio\n    uv.y /= (iResolution.x/iResolution.y);\n    \n    // resize coordinate system\n \tuv *= SAMPLE_FACTOR;\n\n    // get integer part\n    vec2 i = floor(uv);\n    // get fract part\n    vec2 f = fract(uv);\n    \n    // center tile cooridnate system\n    f = f - .5;\n    \n    // get tile center (global)\n    i = i + .5;\n    \n    // paint circle in tile\n    vec3 color = mix(\n        BACKGROUND_COLOR,\n        lights(i, uv/SAMPLE_FACTOR, iTime),\n        smoothstep(0., 0.05, CIRCLE_RADIUS - length(f))\n    );\n\t\n    fragColor = vec4(color,1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/MdGGDz.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "MdKGRm", "name": "Circles_17627", "author": "ddsol", "description": "Makes circles", "tags": ["circle"], "likes": 0, "viewed": 95, "date": "1453842554", "time_retrieved": "2024-06-20T18:30:37.976694", "image_code": "#define SMOOTH\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float maxRadius = min(iResolution.x, iResolution.y) * 0.5; //Radius of the circle in pixels\n    \n    vec2 center = iResolution.xy * vec2(0.5); //Center of the circle in pixels\n    \n    center += vec2(sin(iTime*1.22),cos(iTime*1.37))*vec2(maxRadius / 4.0);\n\n    vec2 relative = fragCoord.xy - center; //Coordinate relative to center of circle in pixels\n\n    vec2 unit = relative / vec2(maxRadius); //Coordinate relatyive to center of circle in units -1.0 to 1.0 (double unit really).\n    \n    float smoothing = 1.0/min(iResolution.x, iResolution.y)*1.5; //Size of smoothing area relative to (double) unit circle\n    \n    //Web rgba format colors\n    vec4 color1 = vec4(120,60,0,0.8) / vec4(255,255,255,1.0);\n    float radius1 = 0.5+sin(iTime)*0.2; //Radius is relative to maxRadius\n    \n    vec4 color2 = vec4(0,120,30, 1.0) / vec4(255,255,255,1);\n    float radius2 = 0.85+sin(iTime*0.77)*0.15; //Radius is relative to maxRadius\n    \n    \n    float dist = length(unit); //Distance to center where 1 = at edge of maxRadius circle\n    \n    #ifdef SMOOTH\n    \n\n    \t//make input colors  (sRGB) linear\n        float gamma = 2.2;\n        color1.rgb = pow(color1.rgb, vec3(gamma));\n        color2.rgb = pow(color2.rgb, vec3(gamma));\n    \n        //Use smoothstep to go from inside to outside circle to do anti-aliasing\n    \tvec4 col = mix(\n            mix(\n                color1,\n                color2,\n                smoothstep(\n                    radius1 - smoothing,\n                    radius1 + smoothing,\n                    dist\n                )\n            ),\n            vec4(0,0,0,0),\n            smoothstep(\n                radius2 - smoothing,\n                radius2 + smoothing,\n                dist\n            )\n        );\n\n        //Gamma correction (prevents color fringes)\n        //Turn color back to sRGB\n        col.rgb = pow(col.rgb, vec3(1.0 / gamma));\n        fragColor = col;\n    \n    #else\n    \n        if (dist<radius1) {\n            fragColor = vec4(color1,1);\n        } else if (dist<radius2) {\n            fragColor = vec4(color2,1);\n        } else {\n            fragColor = vec4(0);\n        }\n\n    #endif\n    \n    //pre-multiply rgb because shadertoy has no real transparency.\n    fragColor.rgb *=fragColor.a;\n    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/MdKGRm.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "MdSSzW", "name": "GalaxyQuest", "author": "Luther", "description": "Galaxy shader", "tags": ["galaxy"], "likes": 33, "viewed": 1092, "date": "1452601846", "time_retrieved": "2024-06-20T18:30:39.995012", "image_code": "#define PI 3.14159265\n#define TWO_PI 6.2831853\n//#define USE_PROCEDURAL \n//#define ANIMATE\n//#define AUDIOPULSE\n//#define MOUSEZOOM\nfloat zoom = 1.0;\nfloat inv_zoom = 1.0;\n\nvec2 rotate( const in vec2 vPos, const in float fAngle )\n{\n    float s = sin(fAngle);\n    float c = cos(fAngle);\n\n    vec2 vResult = vec2( c * vPos.x + s * vPos.y, -s * vPos.x + c * vPos.y);\n\n    return vResult;\n}\n\nvec2 rotate_around( const in vec2 vPos, const in vec2 vCentre, const in float fAngle )\n{\n    return rotate(vPos - vCentre, fAngle) + vCentre;\n}\n\nvec2 RadialDistort(vec2 uv ,vec2 centre, float radius, float amount, float r)\n{\n    vec2 lpos = uv - centre;\n    float dist = length(lpos);\n    float dx = dist / radius;\n    vec2 ret = rotate(lpos, r + (dx * amount));\n    return ret + centre;\n}\n\nfloat CircularGradient(vec2 pos, vec2 centre, float radius)\n{\n    float dist = length(pos - centre);\n    float dx = dist / radius;\n  \n    return dx;\n}\n\n\nfloat CircularGradientSineSeg(vec2 pos, vec2 centre, float radius, float segments)\n{\n    vec2 vec = (pos - centre);\n    float dist = length(vec);\n    vec2 norm = vec / dist;\n    float segment = max(0.0, sin(atan(-norm.y, norm.x) * segments));\n    float dx = 1.0 - (dist / radius);\n  \n    return dx * segment;\n}\n\n\nfloat SelectSegment(const in vec2 vPos, const in float segcount)\n{\n\t\n\tvec2 vNorm = normalize(vPos);\n\tfloat atn = (atan(vNorm.y, vNorm.x) + PI)/  TWO_PI;\n\tfloat segment = floor(atn * segcount);\n\tfloat half_segment = 0.5 / segcount;\n\tfloat seg_norm = mod((segment / segcount) + 0.25 + half_segment, 1.0);\n\t\n\treturn seg_norm * TWO_PI;//turn it back in to rotation\n}\n\nfloat StarShapeBW(vec2 pos, vec2 centre, float centrerad, float radius, float segments)\n{\n    vec2 vec = (pos - centre);\n    float dist = length(vec);\n    float angle = atan(-vec.y, vec.x);\n    float seg_angle_size = TWO_PI / segments;\n    float half_seg_seg_angle_size = seg_angle_size * 0.5;\n    float seg_arc_length = seg_angle_size * centrerad;\n    //float nrm_mul = 1.0\n    \n    if (dist < centrerad)\n        return 1.0;\n    else if (dist > radius)\n        return 0.0;\n    else\n    {\n        float r =  SelectSegment(vec, segments);\t\t\n\t\tvec2 dpos = rotate(vec, r );        \n        float ld = 1.0 - (dist - centrerad) / (radius - centrerad);\n        float w = mod(angle, seg_angle_size);\n        float d = abs(dpos.x);\n        float width_at = seg_angle_size * ld;\n        return (d < seg_arc_length * 0.5 * ld) ? 1.0 : 0.0;\n    }\n}\n\n\n\nfloat StarShape2(vec2 pos, vec2 centre, float centrerad, float radius, float segments)\n{\n    vec2 vec = (pos - centre);\n    float dist = length(vec);\n    float angle = atan(-vec.y, vec.x);\n    float seg_arc_length = TWO_PI / segments;\n    float half_seg_arc_length = seg_arc_length * 0.5;\n    if (dist < centrerad)\n        return 1.0;\n    else \n    {\n        float ld = 1.0 - (dist - centrerad) / (radius - centrerad);\n        float w = mod(angle, seg_arc_length);\n        float d =  abs(w - half_seg_arc_length) * 1.0/ half_seg_arc_length;\n        return pow(d * 1.0, ld) * ( ld);\n    }\n}\n\nfloat easeInOutQuart(float t) \n{\n\tif ((t/=0.5) < 1.0) return 0.5*t*t*t*t;\n\treturn -0.5 * ((t-=2.0)*t*t*t - 2.0);\n}\nfloat easeOutCubic(float t) \n{\n\treturn ((t=(t/1.0)-1.0)*t*t + 1.0);\n}\nfloat easeInOutCubic(float t) \n{\n\tif ((t/=0.5) < 1.0) return 0.5*t*t*t;\n\treturn 0.5*((t-=2.0)*t*t + 2.0);\n}\n\nfloat fade2(float t)\n{\n\treturn t*t*(3.0-2.0*t);\n}\n \n\nfloat fade(float t) {\n  return t*t*t*(t*(t*6.0-15.0)+10.0);\n}\n\nvec3 fade(vec3 t) \n{\n  return t*t*t*(t*(t*6.0-15.0)+10.0);\n}\n\nfloat fade3(float f)\n{\n    return f*f*(3.0-2.0*f);\n}\n\nvec3 fade3(vec3 f)\n{\n    return f*f*(3.0-2.0*f);\n}\n\n\n#ifdef USE_PROCEDURAL\nfloat hash( float n ) { return fract(sin(n)*43758.5453123); }\n\n\nfloat noise( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n    f = fade(f);//f*f*(3.0-2.0*f);\n\t\n    float n = p.x + p.y*157.0 + 113.0*p.z;\n    return mix(mix(mix( hash(n+  0.0), hash(n+  1.0),f.x),\n                   mix( hash(n+157.0), hash(n+158.0),f.x),f.y),\n               mix(mix( hash(n+113.0), hash(n+114.0),f.x),\n                   mix( hash(n+270.0), hash(n+271.0),f.x),f.y),f.z);\n}\n\n#else\n\n\nfloat noise( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n\tf = fade3(f);\n\t\n\tvec2 uv = (p.xy+vec2(37.0,17.0)*p.z) + f.xy;\n\tvec2 rg = texture( iChannel0, (uv+0.5)/256.0, -100.0 ).yx;\n\treturn mix( rg.x, rg.y, f.z );\n}\n\n\n#endif\n\n\nfloat multiNoise( in vec3 pos )\n{\n    vec3 q = 8.0*pos;\n    const mat3 m = mat3( 0.00,  0.80,  0.60,\n                    -0.80,  0.36, -0.48,\n                    -0.60, -0.48,  0.64 );\n    float amplitude = 0.5;\n    float f  = amplitude*noise( q ); q = m*q*2.01;\n    float scale = 2.02;\n    float amptotal = 0.0;\n    for (int i = 0; i < 10; ++i)\n    {    \n    \tf += amplitude * noise( q ); q = m*q*scale;        \n        amplitude *= 0.65;\n        \n    }\n    f /= 1.7;\n    \t//  f += 0.0312*noise( q ); q = m*q*1.05;\n \n    return f;\n}\n\nvec3 orangegrad(float d)\n{\n    vec3 col1 = mix(vec3(0.0, 0.0, 0.0), vec3(2.0, 0.7, 0.1), d);\n    \n    return mix(col1, vec3(5.0, 2.0, 0.1), d * 0.1);\n    return col1;\n}\n\n\nvec3 bluegrad(float d)\n{\n    return mix(mix(vec3(0.0, 0.0, 0.0), vec3(1.0, 0.7, 0.8), d), vec3(3.0, 7.0, 12.0), d * 0.1);\n}\n\nvec2 hash2( vec2 p )\n{\n\t// texture based white noise\n\treturn texture( iChannel0, (p+0.5)/256.0, -100.0 ).xy;\n}\n\nvec3 blackbody_grad(float x)\n{    \n    float ca = 1.0 - (pow(x, 1.5) * 0.5);\n    float cb = pow(min(1.0, x +0.6), 3.0) * 0.9;\n    float cd = x * 0.4;\n    float g = cb- cd;    \t\n    return vec3(ca * 1.1,g*1.0,(1.0- ca) * 1.3) * 1.2;\n}\n\nvec4 hash4( vec2 p)\n{\n    return vec4(texture( iChannel0, (p+0.5)/256.0, -100.0 ).xy,\n                texture( iChannel0, (p+0.5)/256.0, -260.0 ).xy);\n}\n\nfloat star_falloff(float dist, float radius)\n{\n    float idist = max(0.0, radius - dist);\n    return pow(idist, 70.0) * 3.0 + pow(idist, 10.0) * 0.8;\n}\n\nfloat star_falloff2(float dist, float radius)\n{\n    float idist = max(0.0, radius - dist);\n    return pow(idist, 270.0) * 0.3 + pow(idist, 270.0) * 1.8;\n}\n\n//IQ's voronoi code provided the inspiration for this, thank you.\nvec3 voronoi_stars( in vec2 pos)\n{\n    vec2 n = floor(pos);\n    vec2 f = fract(pos);\n\n   \n\tvec2 min_cell, min_pos;\n\n    float min_dist = 100.0;\n    vec3 col = vec3(0,0,0);\n    int xdir = f.x > 0.5 ? 1 : -1;\n    int ydir = f.y > 0.5 ? 1 : -1;\n    for( int j=0; j<=1; j++ )\n    {\n   \t\tfor( int i=0; i<=1; i++ )    \n\t    {\n    \t    vec2 cell = vec2(float(i * xdir),float(j * ydir)); //integer cell offset\n\t\t\tvec2 o = hash2( n + cell );\t\t  //hashed up random offseterizer\n\t\t\t#ifdef ANIMATE\n        \to = 0.5 + 0.5*sin( iTime * 0.3 + 62.2831*o );\n        \t#endif\t\n        \tvec2 r = cell + o - f;        \n        \tvec4 stardata = hash4(n + cell);\n        \t#define SQRT_DIST\n        \t#ifdef SQRT_DIST\n        \tfloat d = length(r);                \n        \tfloat starfo = star_falloff(d, 1.0) * 2.0;\n        \t#else // faster\n        \tfloat d = dot(r,r);                \n        \tfloat starfo = star_falloff2(d, 1.0) * 2.0;\n        \t#endif\n      \n\t        vec3 star_colour = blackbody_grad(stardata.x * 1.4 )  * stardata.w * starfo;\n\t\t\tcol += star_colour;\n        }\n    }\n    return col;\n}\n\nfloat SphereShape(vec2 pos, vec2 centre, float radius, float curvep, float brightness)\n{\n    vec2 vec = (pos - centre);\n    float dist = length(vec);\n    if (dist > radius) return 0.0;\n    return min(1.0,max(0.0, pow(1.0 - (dist / radius), curvep))) * brightness;   \n}\n\nvec4 Galaxy(vec2 pos, vec2 centre, float centrerad, float radius, float twist_amount, float rotation, float segments)\n{\n    vec2 rpos = RadialDistort(pos, centre, radius, twist_amount, rotation);\n    vec2 rposless = RadialDistort(pos, centre, radius, twist_amount * 0.1, rotation);\n    \n    vec2 vec = rotate((rpos - centre), rotation);\n    \n    vec2 vecless = (rposless - centre);\n    float dist = length(vec);\n    float angle = atan(-vec.y, vec.x);\n    float seg_angle_size = TWO_PI / segments;\n    float half_seg_seg_angle_size = seg_angle_size * 0.5;\n    float seg_arc_length = seg_angle_size * centrerad;\n    float seg_arc_end_length = seg_arc_length * 0.2;\n   \n    float ns = multiNoise(vec3(pos.x * 1.0, pos.y * 1.0, iTime*0.005));\n    float nst = multiNoise(vec3(rposless.x * 3.0, rposless.y * 3.0, iTime*0.0016));\n    ns = mix(ns, nst, 0.5);\n        \n    if (dist > radius)\n        return vec4(0.0, 0.0, 0.0, 0.0);\n    else\n    {\n      \n        \n        float r =  SelectSegment(vec, segments);\t\t\n\t\tvec2 dpos = rotate(vec, r );        \n        float yd = 1.0 - (dist - centrerad) / (radius - centrerad);\n        \n        float fadeout = pow(yd, 5.3) *0.4;\n        float w = mod(angle, seg_angle_size);\n      \n        float centre_fo =  1.0;//max(0.0, 1.0 - pow(yd, 30.1));\n         vec2 dposless = rotate(vecless, r );        \n     \n        float thread = 1.0 - max(0.0, abs(dpos.x  + ((ns - 0.5)* 0.4 * centre_fo)));\n        float d =  abs(dpos.x ) ;\n             \n        float width_at = seg_arc_end_length+(seg_arc_length - seg_arc_end_length * yd);\n        \n        float xd = clamp((width_at-d) / seg_arc_length, 0.0, 1.0);\n        \n        float fadexd = (pow(fade2(xd), 1.2) * 1.2) * ns;\n        return vec4( fadexd, xd,thread,fadeout);//fadeout);\n        \n    }\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float timemod = iTime * 2.5;\n    vec2 mousep = iMouse.xy / iResolution.xy;\n    \n    float minzoom = 0.02;\n    float maxzoom = 1.0;\n    float zoom_delta = (sin(timemod * 0.05) + 1.0) / 2.0;\n    zoom_delta = pow(zoom_delta, 2.0);\n    \n    #ifdef MOUSEZOOM\n    zoom_delta = sin(mousep.x + (timemod * 0.05));\n    #endif\n    zoom = mix(minzoom, maxzoom, zoom_delta);\n    inv_zoom = 1.0 / zoom;\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 orignal_uv = uv;\n    \n    float ar = iResolution.x / iResolution.y;\n    \n    uv.x = (uv.x * ar);\n    uv -= 0.5;\n    uv *= zoom;\n    uv += 0.5;\n    uv.x -= 0.5;\n    \n    vec2 centre  = vec2(0.4, 0.5);\n    float centre_radius = 0.2;\n    float radius = 1.2;\n    \n    float r = mousep.y * PI + zoom_delta * 5.0 ;\n \n    vec2 ruv = rotate_around(uv, centre, r );\n    \n    float twist_amount = 6.0;//sin(iTime * 1.0)*5.0;\n  \n    vec4 galaxy_params = Galaxy(ruv,centre, centre_radius, radius, twist_amount, 0.0, 2.0);\n    \n   \tfloat galactic_centre = SphereShape(uv, centre, 0.4, 3.0, 1.);\n    vec3 col = bluegrad(galaxy_params.x * galaxy_params.w * 0.7);\n    \n    #ifdef AUDIOPULSE\n    float pulse_nebula = 0.4 + texture(iChannel1, vec2(ruv.x * 0.001, 0.3)).b;\n    #else\n    float pulse_nebula = 0.7;\n    #endif\n    col += bluegrad(pow(galaxy_params.x, 6.0) * pulse_nebula * clamp(0.8-galaxy_params.w, 0.0, 1.0) * clamp(pow(galaxy_params.w * 2000.0, 2.0), 0.0, 1.0))   ;\n    \n    float thread = clamp(galaxy_params.z - galactic_centre * 1.0, 0.0, 1.0);\n    float ribbon_fadeout = (0.02 + pow(galaxy_params.w * 2.0, 2.0)) * 0.3;\n    col += orangegrad(pow(thread,10.0) ) * ribbon_fadeout * 2.0 ;\n    col -= bluegrad(pow(thread,60.0)) *  ribbon_fadeout * 3.0;\n    col += orangegrad(galactic_centre * 0.80) ;\n    \n    float cellsize = 30.0;\n    vec2 ruv2 = rotate_around(uv,centre, r);\n    float starscale = 0.15;\n    float starpowcurve = 5.0;\n    float seed = 1.0;\n    vec3 starcolbase =  vec3(0.5,0.2,0.4) * 2.0;    \n    vec3 starcol = starcolbase;\n    \n\n    starscale = 20.0;\n    #ifdef AUDIOPULSE\n    float starbrightness = 0.2 + texture(iChannel1, vec2(ruv.x * 0.001, ruv.y * 0.5)).g * 1.9;// * 15.3 + (galaxy_params.x * 2.0) ;\n    #else\n    float starbrightness = 0.7 * (1.0 / pow(zoom, 0.4));\n    #endif\n    for (int i = 0; i < 10; ++i)\n    {        \n        \n        float starsize = 0.4;\n        float fadeout = pow(galaxy_params.y, 4.0) * 0.9 *  (galaxy_params.w  * 0.9 + 0.1) + 0.1;\n        col += voronoi_stars(ruv * starscale) * fadeout * starbrightness;//star_b * starcol ;\n        starbrightness *= 0.9;\n        starscale *= 2.0;\n      \n       \n    }\n    vec4 sound_col = 0.4 + texture(iChannel1,  orignal_uv);\n    fragColor = vec4(col, 1.0);\n}", "image_inputs": [{"id": "Xsf3zn", "previewfilepath": "/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/MdSSzW.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "Mdt3Wl", "name": "Orbits", "author": "Tacoa", "description": "Orbs", "tags": ["gl"], "likes": 5, "viewed": 395, "date": "1452801615", "time_retrieved": "2024-06-20T18:30:39.995012", "image_code": "const float PI = 3.141592653589793238462643383;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\t//Normalize\n    vec2 p = (fragCoord.xy * 2.0 - iResolution.xy) / min(iResolution.x, iResolution.y);\n    \n    vec3 destColor = vec3(0.0);\n    \n    float num = 40.0;\n    for(float i = 0.0; i < num; i++){\n        vec2 q = p + vec2(cos(iTime + i * PI / (num/2.0)), sin(iTime + i * PI / (num/2.0))) * 0.7 * cos(iTime);\n        destColor.yz += 0.005 / length(q);\n    }\n    \n    fragColor = vec4(destColor, 1.0);\n    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/Mdt3Wl.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "MdtGWj", "name": "Wave city", "author": "qleonetti", "description": "Practicing", "tags": ["3d", "raymarching", "waves"], "likes": 1, "viewed": 183, "date": "1452265621", "time_retrieved": "2024-06-20T18:30:39.995012", "image_code": "float sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return min(max(d.x,max(d.y,d.z)),0.0) +\n         length(max(d,0.0));\n}\n\nfloat opU( float d1, float d2 )\n{\n    return min(d1,d2);\n}\nvec3 opRep( vec3 p, vec3 c )\n{\n    return mod(p,c)-0.5*c;\n}\n\nvec2 distance_to_obj(in vec3 p) {\n    vec3 q = opRep(p,vec3(3.,p.y,3.));\n    //vec3 q = p;\n    return vec2(sdBox(q,vec3(1.,\n                             //abs(cos(iTime)) * \n                             (cos(sin(iTime/2.)*floor(p.z/3.))/2. + 0.5) * \n                             (sin(sin(iTime/2.)*floor(p.x/3.))/2. + 0.5) * 3.+.2,1.)\n    ));\n}\n\n// primitive color\nvec3 prim_c(in vec3 p) {\n    return vec3(sin(floor(sqrt((p.x)*(p.x)+(p.z)*(p.z)))*8.)+p.y/4.,\n                sin(floor(sqrt((p.x)*(p.x)+(p.z)*(p.z)))*8.)+p.y/4.,\n                p.y/2.\n                );\n    //return vec3(sin(p.x*p.y*p.z/10.),cos(p.x*p.y*p.z/5.),.5);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 cam_pos = vec3(cos(iTime/3.)*10.0,10.0,10.0);\n\t//vec3 cam_pos = vec3(10.);\n\tvec2 tx = fragCoord.xy / iResolution.xy;\n    vec2 vPos = -1.0 + 2.0 * tx;\n\n    //camera up vector\n    vec3 vuv = vec3(0,1,0);\n\n    //camera lookat\n    vec3 vrp=vec3(0,0,0);\n\n    vec3 prp = cam_pos;\n    vec3 vpn = normalize(vrp-prp);\n    vec3 u = normalize(cross(vuv,vpn));\n    vec3 v = cross(vpn,u);\n    vec3 vcv = (prp+vpn);\n    vec3 scrCoord = vcv+vPos.x*u*0.8+vPos.y*v*0.8;\n    vec3 scp=normalize(scrCoord-prp);\n\n    //Raymarching\n    const vec3 e=vec3(0.02,0,0);\n    const float maxd=100.0;\n    vec2 d=vec2(0.02,0.0);\n    vec3 c,p,N;\n\n    float f=1.0;\n    for(int i=0;i<256;i++) {\n        if ((abs(d.x)<.001) || (f > maxd)) break;\n\n        f+=d.x;\n        p=prp+scp*f;\n        d = distance_to_obj(p);\n    }\n    if (f<maxd) {\n        c=prim_c(p);\n        vec3 n = vec3(\n            d.x-distance_to_obj(p-e.xyy).x,\n            d.x-distance_to_obj(p-e.yxy).x,\n            d.x-distance_to_obj(p-e.yyx).x\n            );\n        N = normalize(n);\n        float b=dot(N,normalize(prp-p));\n        fragColor = vec4((b*c+pow(b,16.0))*(1.0-f*0.01), 1.0 );\n    } else {\n    fragColor=vec4(0,0,0,1);\n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/MdtGWj.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "MdyGzR", "name": "Lights in Smoke", "author": "ehj1", "description": "Glowing balls of light illuminating smoke.", "tags": ["clouds", "glow", "smoke", "lights"], "likes": 75, "viewed": 9245, "date": "1452926867", "time_retrieved": "2024-06-20T18:30:39.995012", "image_code": "vec3 mod289(vec3 x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 mod289(vec4 x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 permute(vec4 x) {\n     return mod289(((x*34.0)+1.0)*x);\n}\n\nvec4 taylorInvSqrt(vec4 r)\n{\n  return 1.79284291400159 - 0.85373472095314 * r;\n}\n\nfloat snoise(vec3 v)\n  { \n  const vec2  C = vec2(1.0/6.0, 1.0/3.0) ;\n  const vec4  D = vec4(0.0, 0.5, 1.0, 2.0);\n\n// First corner\n  vec3 i  = floor(v + dot(v, C.yyy) );\n  vec3 x0 =   v - i + dot(i, C.xxx) ;\n\n// Other corners\n  vec3 g = step(x0.yzx, x0.xyz);\n  vec3 l = 1.0 - g;\n  vec3 i1 = min( g.xyz, l.zxy );\n  vec3 i2 = max( g.xyz, l.zxy );\n\n  //   x0 = x0 - 0.0 + 0.0 * C.xxx;\n  //   x1 = x0 - i1  + 1.0 * C.xxx;\n  //   x2 = x0 - i2  + 2.0 * C.xxx;\n  //   x3 = x0 - 1.0 + 3.0 * C.xxx;\n  vec3 x1 = x0 - i1 + C.xxx;\n  vec3 x2 = x0 - i2 + C.yyy; // 2.0*C.x = 1/3 = C.y\n  vec3 x3 = x0 - D.yyy;      // -1.0+3.0*C.x = -0.5 = -D.y\n\n// Permutations\n  i = mod289(i); \n  vec4 p = permute( permute( permute( \n             i.z + vec4(0.0, i1.z, i2.z, 1.0 ))\n           + i.y + vec4(0.0, i1.y, i2.y, 1.0 )) \n           + i.x + vec4(0.0, i1.x, i2.x, 1.0 ));\n\n// Gradients: 7x7 points over a square, mapped onto an octahedron.\n// The ring size 17*17 = 289 is close to a multiple of 49 (49*6 = 294)\n  float n_ = 0.142857142857; // 1.0/7.0\n  vec3  ns = n_ * D.wyz - D.xzx;\n\n  vec4 j = p - 49.0 * floor(p * ns.z * ns.z);  //  mod(p,7*7)\n\n  vec4 x_ = floor(j * ns.z);\n  vec4 y_ = floor(j - 7.0 * x_ );    // mod(j,N)\n\n  vec4 x = x_ *ns.x + ns.yyyy;\n  vec4 y = y_ *ns.x + ns.yyyy;\n  vec4 h = 1.0 - abs(x) - abs(y);\n\n  vec4 b0 = vec4( x.xy, y.xy );\n  vec4 b1 = vec4( x.zw, y.zw );\n\n  //vec4 s0 = vec4(lessThan(b0,0.0))*2.0 - 1.0;\n  //vec4 s1 = vec4(lessThan(b1,0.0))*2.0 - 1.0;\n  vec4 s0 = floor(b0)*2.0 + 1.0;\n  vec4 s1 = floor(b1)*2.0 + 1.0;\n  vec4 sh = -step(h, vec4(0.0));\n\n  vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy ;\n  vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww ;\n\n  vec3 p0 = vec3(a0.xy,h.x);\n  vec3 p1 = vec3(a0.zw,h.y);\n  vec3 p2 = vec3(a1.xy,h.z);\n  vec3 p3 = vec3(a1.zw,h.w);\n\n//Normalise gradients\n  vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));\n  p0 *= norm.x;\n  p1 *= norm.y;\n  p2 *= norm.z;\n  p3 *= norm.w;\n\n// Mix final noise value\n  vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n  m = m * m;\n  return 42.0 * dot( m*m, vec4( dot(p0,x0), dot(p1,x1), \n                                dot(p2,x2), dot(p3,x3) ) );\n  }\n\nfloat normnoise(float noise) {\n\treturn 0.5*(noise+1.0);\n}\n\nfloat clouds(vec2 uv) {\n    uv += vec2(iTime*0.05, + iTime*0.01);\n    \n    vec2 off1 = vec2(50.0,33.0);\n    vec2 off2 = vec2(0.0, 0.0);\n    vec2 off3 = vec2(-300.0, 50.0);\n    vec2 off4 = vec2(-100.0, 200.0);\n    vec2 off5 = vec2(400.0, -200.0);\n    vec2 off6 = vec2(100.0, -1000.0);\n\tfloat scale1 = 3.0;\n    float scale2 = 6.0;\n    float scale3 = 12.0;\n    float scale4 = 24.0;\n    float scale5 = 48.0;\n    float scale6 = 96.0;\n    return normnoise(snoise(vec3((uv+off1)*scale1,iTime*0.5))*0.8 + \n                     snoise(vec3((uv+off2)*scale2,iTime*0.4))*0.4 +\n                     snoise(vec3((uv+off3)*scale3,iTime*0.1))*0.2 +\n                     snoise(vec3((uv+off4)*scale4,iTime*0.7))*0.1 +\n                     snoise(vec3((uv+off5)*scale5,iTime*0.2))*0.05 +\n                     snoise(vec3((uv+off6)*scale6,iTime*0.3))*0.025);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  \n\tvec2 uv =  fragCoord.xy/iResolution.x;\n    \n    vec2 center = vec2(0.5,0.5*(iResolution.y/iResolution.x));\n    \n    vec2 light1 = vec2(sin(iTime*1.2+50.0)*1.0 + cos(iTime*0.4+10.0)*0.6,sin(iTime*1.2+100.0)*0.8 + cos(iTime*0.2+20.0)*-0.2)*0.2+center;\n    vec3 lightColor1 = vec3(1.0, 0.3, 0.3);\n    \n    vec2 light2 = vec2(sin(iTime+3.0)*-2.0,cos(iTime+7.0)*1.0)*0.2+center;\n    vec3 lightColor2 = vec3(0.3, 1.0, 0.3);\n    \n    vec2 light3 = vec2(sin(iTime+3.0)*2.0,cos(iTime+14.0)*-1.0)*0.2+center;\n    vec3 lightColor3 = vec3(0.3, 0.3, 1.0);\n\n    \n    float cloudIntensity1 = 0.7*(1.0-(2.5*distance(uv, light1)));\n    float lighIntensity1 = 1.0/(100.0*distance(uv,light1));\n\n    float cloudIntensity2 = 0.7*(1.0-(2.5*distance(uv, light2)));\n    float lighIntensity2 = 1.0/(100.0*distance(uv,light2));\n    \n    float cloudIntensity3 = 0.7*(1.0-(2.5*distance(uv, light3)));\n    float lighIntensity3 = 1.0/(100.0*distance(uv,light3));\n    \n    \n\tfragColor = vec4(vec3(cloudIntensity1*clouds(uv))*lightColor1 + lighIntensity1*lightColor1 +\n                     vec3(cloudIntensity2*clouds(uv))*lightColor2 + lighIntensity2*lightColor2 +\n                     vec3(cloudIntensity3*clouds(uv))*lightColor3 + lighIntensity3*lightColor3 \n                     ,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/MdyGzR.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "MdyGzw", "name": "Companion Cubed", "author": "unconed", "description": "Random experiment with lighting and folds.", "tags": ["hybridfractal"], "likes": 13, "viewed": 650, "date": "1453691413", "time_retrieved": "2024-06-20T18:30:40.958720", "image_code": "vec4 fold1(vec4 z) {\n    vec3 p = z.xyz;\n    p = p - 2.0 * clamp(p, -1.0, 1.0);\n    return vec4(p, z.w);\n}\n\nvec4 fold2(vec4 z) {\n    vec3 p = z.xyz;\n    p = p - 2.0 * clamp(p, -1.0, 1.0);\n    return vec4(p * 2.0, 2.0 * z.w);\n}\n\nvec4 invertRadius(vec4 z, float radius2, float limit) {\n  float r2 = dot(z.xyz, z.xyz);\n  float f = clamp(radius2 / r2, 1., limit);\n  return z * f;\n}\n\nvec4 affine(vec4 z, float factor, vec3 offset) {\n  z.xyz *= factor;\n  z.xyz += offset;\n  z.w *= abs(factor);\n  return z;\n}\n\nvec4 mandel(vec4 z, vec3 offset) {\n  float x = z.x;\n  float y = z.y;\n\n  z.w = 2. * length(z.xy) * z.w + 1.;\n\n  z.x = x*x - y*y + offset.x;\n  z.y = 2.*x*y + offset.y;\n\n  return z;\n}\n\nvec4 invert(vec4 z, float factor) {\n  float r2 = dot(z.xyz, z.xyz);\n  float f = factor / r2;\n  return z * f;\n}\n\nvec4 rotateXY(vec4 z, float angle) {\n  float c = cos(angle);\n  float s = sin(angle);\n  mat2 m = mat2(c, s, -s, c);\n  return vec4(m * z.xy, z.zw);\n}\n\nvec4 rotateXZ(vec4 z, float angle) {\n  float c = cos(angle);\n  float s = sin(angle);\n  mat2 m = mat2(c, s, -s, c);\n  vec2 r = m * z.xz;\n  return vec4(r.x, z.y, r.y, z.w);\n}\n\nvec4 shiftXY(vec4 z, float angle, float radius) {\n  float c = cos(angle);\n  float s = sin(angle);\n  return vec4(vec2(c, s) * radius + z.xy, z.zw);\n}\n\nfloat surface = 0.0;\nfloat sdf(vec3 p) {\n    //vec3 pmod = mod(p + 2.0, 4.0) - 2.0;\n    vec4 z = vec4(p, 1.0);\n    \n    float t = iTime * .5;\n\n    vec3 vo1 = vec3(sin(t * .1), cos(t * .0961), sin(t * .017)) * .1;\n    vec3 vo2 = vec3(cos(t * .07), sin(t * .0533), sin(t * .138)) * .1;\n    vec3 vo3 = vec3(sin(t * .031), sin(t * .0449), cos(t * .201)) * .1;\n    \n    z = invertRadius(z, 10.0*10.0, 1.3);\n    z.xyz += vo1;\n    z = fold1(z);\n    z.xyz += vo2;\n    z = invertRadius(z, 10.0*10.0, 1.3);\n    z = rotateXZ(z, t * .102);\n    z = rotateXY(z, t * .123);\n    z = fold1(z);\n    z.xyz += vo1;\n    z = invertRadius(z, 10.0*10.0, 1.3);\n    z = fold1(z);\n    z = rotateXY(z, t * .123);\n    z = fold2(z);\n    z.xyz += vo3;\n    z = rotateXY(z, t);\n    z = rotateXZ(z, t * .202);\n    z = invertRadius(z, 1.0*1.0, 3.0);\n    z = rotateXY(z, t * .123);\n    z = fold1(z);\n    z = invertRadius(z, 1.0*1.0, 3.0);\n\n\n\n    vec3 po = vec3(0.0, 0.0, 0.0);\n\n    float d1 = (length(z.xyz - po) - .9) / z.w;\n    \n    vec3 box = abs(z.xyz);\n    float d2 = (max(box.x - 1.0, max(box.y - 1.0, box.z - .5))) / z.w;\n\t\n    float d3 = min(d1, d2);\n    if (d2 == d3) {\n      surface = 1.0;\n    }\n    else {\n      surface = 0.0;\n    }\n    return d3;\n}\n\nvec3 normal(vec3 p) {\n\tvec2 e = vec2(.0001, 0.0);\n    return normalize(vec3(\n        sdf(p + e.xyy) - sdf(p - e.xyy),\n        sdf(p + e.yxy) - sdf(p - e.yxy),\n        sdf(p + e.yyx) - sdf(p - e.yyx)\n    ));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 xy = (uv * 2.0 - 1.0) * vec2(iResolution.x / iResolution.y, 1.0);\n\n    vec3 color = vec3(.8, .9, 1.0) * (1.5 - uv.y);\n\n    vec3 light = vec3(.577);\n    float angle = 1.0-iMouse.x * .005;   \n    float c = cos(angle);\n    float s = sin(angle);\n    mat3 camera = mat3(\n        c,  0.0, -s,\n         0.0,  1.0, 0.0,\n        s,  0.0, c//,\n\t);\n    float fov = .5;\n\n    vec3 rd = camera * normalize(vec3(xy * fov,-1.0));\n    vec3 ro = vec3(s,0.0,c)*14.0;\n    \n    float tmax = 100.0;\n    float dmin = .001;\n    float t = 0.0;\n    float d = sdf(ro);\n    if (d < 0.0) rd = -rd;\n    for (int i = 0; i < 96; ++i) {\n        vec3 p = ro + rd * t;\n        d = sdf(p);\n        t += d;\n        if (t > tmax || abs(d) < dmin) break;\n    }\n\n    vec3 p = ro + rd * t;\n    vec3 n = normal(p);\n    if (t < tmax && d < dmin) {\n      vec3 albedo = mix(vec3(1.0, 0.02, 0.02), vec3(1.0), surface);\n  \t  float diffuse = clamp(dot(n, light), 0.0, 1.0);\n      \n      float ao = 0.0;\n      float am = 0.0;\n      float step = .05;\n      vec3 pa = p;\n      for (int i = 0; i < 8; ++i) {\n          pa += n * step;\n          am += step;\n          ao += max(0.0, sdf(pa) / am);\n          step += .05;\n      }\n      \n      t = .1;\n      float shadow = 1.0;\n      if (diffuse > 0.0) {\n        for (int i = 0; i < 32; ++i) {\n          vec3 pb = p + light * t;\n          d = sdf(pb);\n          t += d;\n          if (d < 0.0) break;\n        }\n        \n        shadow = clamp(d, 0.0, 1.0);\n        diffuse *= shadow;\n      }\n        \n      ao = ao / 8.0;\n      float ambient = 0.04;\n\n      vec3 sun = vec3(1.0, .9, .8);\n      vec3 sky = vec3(.3, .5, 1.0);\n      color = 2.0 * vec3(mix(sun * diffuse, sky, ambient) * ao * ao * albedo * 5.0);\n      color = color/(1.0+color);\n    }\n    \n\tfragColor = vec4(sqrt(color),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/MdyGzw.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "MdyGzz", "name": "Cellular creature", "author": "TambakoJaguar", "description": "I played with Voronoi pattern and used it to create a disgusting fantasy creature. It's just a bit slow because of the complexity, but still cool! :)\nUse your mouse to rotate the creature.\nHelp is welcome for optimization.", "tags": ["raymarching", "ugly", "voronoi", "subsurfacescattering", "alien", "cells", "pulsating", "creature", "being", "slimy", "disgusting"], "likes": 13, "viewed": 347, "date": "1453324138", "time_retrieved": "2024-06-20T18:30:42.831797", "image_code": "/*\n\"Cellular creature\" by Emmanuel Keller aka Tambako - January 2016\nLicense Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\nContact: tamby@tambako.ch\n*/\n\n#define pi 3.141593\n\nstruct Lamp\n{\n  vec3 position;\n  vec3 color;\n  float intensity;\n  float attenuation;\n};\n\nstruct RenderData\n{\n  vec3 col;\n  vec3 pos;\n  vec3 norm;\n  float objnr;\n};\n    \nLamp lamps[3];\n\nvec3 campos = vec3(0., -0.5, 9.);\nvec3 camdir = vec3(0., 0., -1.);\nfloat fov = 3.3;\n\nconst vec3 ambientColor = vec3(0.2);\nconst float ambientint = 0.16;\nconst vec3 speccolor = vec3(1., 0.75, 0.73);\n\nvec3 colors[3];\n\n//#define shadow\n#define ambocc\n#define specular\n#define ss_scatering\nconst float specint1 = 0.08;\nconst float specshin1 = 2.5;\nconst float specint2 = 0.6;\nconst float specshin2 = 100.;\nconst float aoint = 0.17;\nconst float shi = 0.8;\nconst float shf = 0.9;\nconst float ssstrmr = 1.35;\nconst float sssInt1 = 0.39;\nconst float sssInt2 = 0.55;\nconst vec3 sssColor1 = vec3(1.0, 0.55, 0.5);\nconst vec3 sssColor2 = vec3(0.25, 0.8, 0.35);\n\nconst float normdelta = 0.001;\nconst float maxdist = 15.;\n\nvec3 voronoiv;\nvec3 posr;\n\nfloat angle;\nfloat angle2;\n\n// Antialias. Change from 1 to 2 or more AT YOUR OWN RISK! It may CRASH your browser while compiling!\nconst float aawidth = 0.8;\nconst int aasamples = 1;\n\n// From https://www.shadertoy.com/view/ldl3Dl\nvec3 hash(vec3 x)\n{\n\tx = vec3(dot(x,vec3(127.1,311.7, 74.7)),\n\t\t\t dot(x,vec3(269.5,183.3,246.1)),\n\t\t\t dot(x,vec3(113.5,271.9,124.6)));\n\n\treturn fract(sin(x)*43356.5453123);\n}\n\n// From https://www.shadertoy.com/view/ldl3Dl and https://www.shadertoy.com/view/ldl3W8\nvec3 voronoi(vec3 x)\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n\n\tfloat id = 0.0;\n    vec3 mg;\n    vec3 mr;\n    float res = 10.0;\n    for(int k=0; k<=1; k++)\n    for(int j=0; j<=1; j++)\n    for(int i=0; i<=1; i++)\n    {\n        vec3 b = vec3(float(i), float(j), float(k));\n        vec3 r = b - f + 0.45*hash(p + b);\n        float d = dot(r, r);\n\n        if(d < res)\n        {\n\t\t\tid = dot(p + b, vec3(1.0,57.0,113.0));\n            res = d;\t\n            mg = b;\n            mr = r;\n        }\n    }\n    \n    float md2 = 8.0;\n    for(int k=-1; k<=1; k++)\n    for(int j=-1; j<=1; j++)\n    for(int i=-1; i<=2; i++)\n    {\n        vec3 b = mg + vec3(float(i),float(j),float(k));;\n        vec3 r = b - f + 0.45*hash(p + b);\n\n        if(dot(mr-r,mr-r)>0.00001)\n            md2 = 1./(1./md2 + 0.53/dot((mr + r*1.07), normalize(r*1.07 - mr)));\n    }\n\n    return vec3(res, md2, abs(id));\n}\nvec2 rotateVec(vec2 vect, float angle)\n{\n    vec2 rv;\n    rv.x = vect.x*cos(angle) + vect.y*sin(angle);\n    rv.y = vect.x*sin(angle) - vect.y*cos(angle);\n    return rv;\n}\n\nvec3 rotateVec2(vec3 posr)\n{\n    posr = vec3(posr.x, posr.y*cos(angle2) + posr.z*sin(angle2), posr.y*sin(angle2) - posr.z*cos(angle2));\n    posr = vec3(posr.x*cos(angle) + posr.z*sin(angle), posr.y, posr.x*sin(angle) - posr.z*cos(angle)); \n    \n    return posr;\n}\n\nvec3 creaturePulse(vec3 posr)\n{\n    posr*= vec3(1. - 0.08*sin(posr.x*2.3 + iTime*0.754) + 0.03*sin(posr.x*4.3 + iTime*0.12), 1. - 0.08*sin(posr.y*2.5 + iTime*0.982) + 0.03*sin(posr.x*4.1 + iTime*0.725), 1. - 0.08*sin(posr.y*2.8 + iTime*1.0843) + 0.03*sin(posr.x*4.9 + iTime*0.15));    \n    return posr;\n}\n\nvec3 creaturePulse2(vec3 posr)\n{\n    posr*= vec3(1.3 - 0.1*sin(posr.x*2.4 + iTime*0.765) + 0.04*sin(posr.x*4.34 + iTime*0.176), 0.95 - 0.12*sin(posr.y*2.66 + iTime*0.927) + 0.06*sin(posr.x*4.15 + iTime*0.648) + 0.02*sin(posr.z*8.02 + iTime*0.648), 1.3 - 0.1*sin(posr.y*2.72 + iTime*1.125) + 0.04*sin(posr.x*5.4+ iTime*0.18));    \n    posr.y-= 0.45;\n    return posr;\n}\n\nfloat map_s(vec3 pos)\n{    \n    vec3 posr = rotateVec2(pos);\n    posr = creaturePulse(posr);\n    return length(posr) -1.85;   \n}\n\nfloat map_s2(vec3 pos)\n{    \n    vec3 posr = rotateVec2(pos);\n    posr = creaturePulse2(posr);\n    return length(posr) -1.85;   \n}\n\nfloat map(vec3 pos)\n{   \n    posr = rotateVec2(pos);\n    \n    vec3 posr0=posr;\n    voronoiv = voronoi(4.*normalize(posr0));\n    posr = creaturePulse(posr);\n    \n    float cd = sign(mod(voronoiv.z, 2.)-0.5);\n    return length(pos) -1.8 - 0.15*(smoothstep(0.033, 0.067, voronoiv.y) + 5.*cd*smoothstep(0.065, 0.15, voronoiv.y))\n           - 0.008*texture(iChannel0, posr0.xy*4.3).r;\n}\n\nvec2 trace(vec3 cam, vec3 ray, float maxdist) \n{\n    float t = 3.5;\n    vec3 pos;\n    float dist;\n    \n  \tfor (int i = 0; i < 100; ++i)\n    {\n    \tpos = ray*t + cam;\n    \tdist = min(map_s(pos), map_s2(pos));\n        if (dist>maxdist || abs(dist)<0.001)\n            break;\n        t+= dist*0.98;\n  \t}\n    \n  \tfor (int i = 0; i < 18; ++i)\n    {\n    \tpos = ray*t + cam;\n    \tdist = min(map(pos), map_s2(pos));\n        if (dist>maxdist || abs(dist)<0.001)\n            break;\n        t+= dist*0.12;\n  \t}\n\n    float o = smoothstep(0.1, 0.0, (map_s2(pos)-dist));\n        \n  \treturn vec2(t, o);\n}\n\n// From https://www.shadertoy.com/view/MstGDM\nvec3 getNormal(vec3 pos, float e)\n{\n    vec2 q = vec2(0, e);\n    vec3 norm = normalize(vec3(map(pos + q.yxx) - map(pos - q.yxx),\n                          map(pos + q.xyx) - map(pos - q.xyx),\n                          map(pos + q.xxy) - map(pos - q.xxy)));\n    return norm;\n}\n\nvec3 getNormal2(vec3 pos, float e)\n{\n    vec2 q = vec2(0, e);\n    vec3 norm = normalize(vec3(map_s2(pos + q.yxx) - map_s2(pos - q.yxx),\n                          map_s2(pos + q.xyx) - map_s2(pos - q.xyx),\n                          map_s2(pos + q.xxy) - map_s2(pos - q.xxy)));\n    return norm;\n}\n\nvec3 obj_color(vec3 norm, vec3 pos)\n{\n    vec3 fleshcol = vec3(.9, .2, .1);\n    vec3 col2 = mod(voronoiv.z, 10.)<9.?fleshcol:vec3(.1, .4, .3);\n    vec3 col_out = mix(vec3(1., .63, .42), col2, 4.*smoothstep(0.058, 0.11 + 0.008*sin(iTime*0.75 + voronoiv.z*5.), voronoiv.y));\n    return mix(col_out, fleshcol*0.5, 4.*smoothstep(0.073, 0., voronoiv.y));\n}\n\nvec3 obj_color2(vec3 norm, vec3 pos)\n{\n    return vec3(.25 + 0.3*dot(norm.xy, pos.yz) - 0.2*pos.y - 0.3*sin(iTime*0.927),\n                .5 - 0.2*pos.y + 0.2*sin(iTime*0.927),\n                .3 - 0.2*dot(norm.zx, pos.yx))*(0.7 + 0.3*texture(iChannel1, posr.xz*0.18 + vec2(0.01*iTime, 0.003*iTime)).rgb);\n}\n\n// From https://www.shadertoy.com/view/Xds3zN;\nfloat softshadow(vec3 ro, vec3 rd, float mint, float tmax)\n{\n\tfloat res = 1.0;\n    float t = mint;\n    for(int i=0; i<16; i++)\n    {\n    \tfloat h = map(ro + rd*t);\n        res = min( res, 8.0*h/t );\n        t += clamp( h, 0.02, 0.10 );\n        if( h<0.001 || t>tmax ) break;\n    }\n    return clamp( res, 0.0, 1.0 );\n}\n\nfloat calcAO( in vec3 pos, in vec3 nor )\n{\n\tfloat occ = 0.0;\n    float sca = 1.0;\n    for( int i=0; i<5; i++ )\n    {\n        float hr = 0.01 + 0.12*float(i)/4.0;\n        vec3 aopos =  nor * hr + pos;\n        float dd = map(aopos);\n        occ += -(dd-hr)*sca;\n        sca *= 0.95;\n    }\n    return clamp( 1.0 - 3.0*occ, 0.0, 1.0 );    \n}\n\nvec3 lampShading(Lamp lamp, vec3 norm, vec3 pos, vec3 ocol, float objnr)\n{\n\tvec3 pl = normalize(lamp.position - pos);\n    float dlp = distance(lamp.position, pos);\n    vec3 pli = pl/pow(1. + lamp.attenuation*dlp, 2.);\n    vec3 nlcol = normalize(lamp.color);\n    float specint = mix(specint1, specint2, pow(objnr, 6.));\n    float specshin = mix(specshin1, specshin2, pow(objnr, 5.));\n    float sssInt = mix(sssInt1, sssInt2, objnr);\n    vec3 sssColor = mix(sssColor1, sssColor2, objnr);\n      \n    // Diffuse shading\n    vec3 col = ocol*nlcol*lamp.intensity*clamp(dot(norm, pli), 0., 1.);\n    \n    // Specular shading\n    #ifdef specular\n    if (dot(norm, lamp.position - pos) > 0.0)\n        col+= speccolor*nlcol*lamp.intensity*specint*pow(max(0.0, dot(reflect(pl, norm), normalize(pos - campos))), specshin);\n    #endif\n    \n    // Softshadow\n    #ifdef shadow\n    col*= shi*softshadow(pos, normalize(lamp.position - pos), shf, 6.) + 1. - shi;\n    #endif\n    \n\t// Sub surface scattering from https://www.shadertoy.com/view/MdXSzX\n    #ifdef ss_scatering\n\tfloat transmission = mix(map(pos + pl*ssstrmr), map_s2(pos + pl*ssstrmr), objnr)/ssstrmr;\n\tvec3 sssLight = sssColor*nlcol*smoothstep(0.0,1.0,transmission);\n    col = col*(1. - sssInt) + sssInt*sssLight;\n    #endif\n    \n    return col;\n}\n\nvec3 lampsShading(vec3 norm, vec3 pos, vec3 ocol, float objnr)\n{\n    vec3 col = vec3(0.);\n    for (int l=0; l<2; l++) // lamps.length()\n        col+= lampShading(lamps[l], norm, pos, ocol, objnr);\n    \n    return col;\n}\n\n// From https://www.shadertoy.com/view/lsSXzD, modified\nvec3 GetCameraRayDir(vec2 vWindow, vec3 vCameraDir, float fov)\n{\n\tvec3 vForward = normalize(vCameraDir);\n\tvec3 vRight = normalize(cross(vec3(0.0, 1.0, 0.0), vForward));\n\tvec3 vUp = normalize(cross(vForward, vRight));\n    \n\tvec3 vDir = normalize(vWindow.x * vRight + vWindow.y * vUp + vForward * fov);\n\n\treturn vDir;\n}\n\nRenderData trace0(vec3 tpos, vec3 ray)\n{\n    vec2 t = trace(tpos, ray, maxdist);\n    float tx = t.x;\n    vec3 col;\n    float objnr = t.y;\n    \n    vec3 pos = tpos + tx*ray;\n    vec3 norm;\n    if (tx<maxdist*0.65)\n    {\n        norm = mix(getNormal(pos, normdelta), getNormal2(pos, normdelta), objnr);\n\n        // Coloring\n        col = mix(obj_color(norm, pos), obj_color2(norm, pos), objnr);\n      \n        // Shading\n        col = ambientColor*ambientint + lampsShading(norm, pos, col, objnr);\n        \n        // Ambient occlusion\n        #ifdef ambocc\n        col*= 1. + aoint*vec3(calcAO(pos, norm)) - aoint;\n        //col = vec3(calcAO(pos, norm));\n        #endif\n  }\n  return RenderData(col, pos, norm, objnr);\n}\n\nvec4 render(vec2 fragCoord)\n{\n  lamps[0] = Lamp(vec3(-1., 4.5, 10.), vec3(1., 1., 1.), 8.2, 0.1);\n  lamps[1] = Lamp(vec3(9., -3.5, 6.), vec3(0.93, 0.98, 1.0), 4.8, 0.1);\n  lamps[2] = Lamp(vec3(-5., 1.8, -5.), vec3(1.0, 0.75, 0.75), 10., 0.1);\n    \n  vec2 uv = fragCoord.xy / iResolution.xy; \n  uv = uv*2.0 - 1.0;\n  uv.x*= iResolution.x / iResolution.y;\n\n  vec3 ray = GetCameraRayDir(uv, camdir, fov);\n    \n  RenderData traceinf = trace0(campos, ray);\n  vec3 col = traceinf.col;\n\n  return vec4(col, 1.0);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    angle = 2.*pi*(iMouse.x/iResolution.x - 0.5);\n    angle2 = -2.*pi*(iMouse.y/iResolution.y - 0.5);\n    \n    // Antialiasing\n    vec4 vs = vec4(0.);\n    for (int j=0;j<aasamples ;j++)\n    {\n       float oy = float(j)*aawidth/max(float(aasamples-1), 1.);\n       for (int i=0;i<aasamples ;i++)\n       {\n          float ox = float(i)*aawidth/max(float(aasamples-1), 1.);\n          vs+= render(fragCoord + vec2(ox, oy));\n       }\n    }\n    fragColor = vs/vec4(aasamples*aasamples);    \n}", "image_inputs": [{"id": "XdfGRn", "previewfilepath": "/media/ap/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg", "ctype": "texture"}, {"id": "XdX3Rn", "previewfilepath": "/media/ap/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc-by-nc-sa-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/MdyGzz.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "Ms33Dj", "name": "Garage", "author": "dr2", "description": "Fun in the parking deck", "tags": ["raymarching", "lighting", "cars"], "likes": 32, "viewed": 3175, "date": "1452158255", "time_retrieved": "2024-06-20T18:30:42.868058", "image_code": "// \"Garage\" by dr2 - 2016\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\nconst float pi = 3.14159;\nconst vec4 cHashA4 = vec4 (0., 1., 57., 58.);\nconst vec3 cHashA3 = vec3 (1., 57., 113.);\nconst float cHashM = 43758.54;\n\nvec4 Hashv4f (float p)\n{\n  return fract (sin (p + cHashA4) * cHashM);\n}\n\nfloat Noisefv2 (vec2 p)\n{\n  vec2 i = floor (p);\n  vec2 f = fract (p);\n  f = f * f * (3. - 2. * f);\n  vec4 t = Hashv4f (dot (i, cHashA3.xy));\n  return mix (mix (t.x, t.y, f.x), mix (t.z, t.w, f.x), f.y);\n}\n\nfloat Fbmn (vec3 p, vec3 n)\n{\n  vec3 s = vec3 (0.);\n  float a = 1.;\n  for (int i = 0; i < 5; i ++) {\n    s += a * vec3 (Noisefv2 (p.yz), Noisefv2 (p.zx), Noisefv2 (p.xy));\n    a *= 0.5;\n    p *= 2.;\n  }\n  return dot (s, abs (n));\n}\n\nvec3 VaryNf (vec3 p, vec3 n, float f)\n{\n  vec3 e = vec3 (0.2, 0., 0.);\n  float s = Fbmn (p, n);\n  vec3 g = vec3 (Fbmn (p + e.xyy, n) - s,\n     Fbmn (p + e.yxy, n) - s, Fbmn (p + e.yyx, n) - s);\n  return normalize (n + f * (g - n * dot (n, g)));\n}\n\nfloat PrBoxDf (vec3 p, vec3 b)\n{\n  vec3 d = abs (p) - b;\n  return min (max (d.x, max (d.y, d.z)), 0.) + length (max (d, 0.));\n}\n\nfloat PrRoundBoxDf (vec3 p, vec3 b, float r)\n{\n  return length (max (abs (p) - b, 0.)) - r;\n}\n\nfloat PrBox2Df (vec2 p, vec2 b)\n{\n  vec2 d = abs (p) - b;\n  return min (max (d.x, d.y), 0.) + length (max (d, 0.));\n}\n\nfloat PrCylDf (vec3 p, float r, float h)\n{\n  return max (length (p.xy) - r, abs (p.z) - h);\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  return q * cos (a) * vec2 (1., 1.) + q.yx * sin (a) * vec2 (-1., 1.);\n}\n\nfloat SmoothMin (float a, float b, float r)\n{\n  float h = clamp (0.5 + 0.5 * (b - a) / r, 0., 1.);\n  return mix (b, a, h) - r * h * (1. - h);\n}\n\nfloat SmoothBump (float lo, float hi, float w, float x)\n{\n  return (1. - smoothstep (hi - w, hi + w, x)) * smoothstep (lo - w, lo + w, x);\n}\n\n#define NCAR 6\n\nmat3 carMat[NCAR + 1], oMat;\nvec3 carPos[NCAR + 1], oPos, qHit;\nfloat ti[6], tPer, ts, tCur, qFy, fLen, spDist, spRad, trWid, dstFar;\nint carCv[NCAR], oCv, idObj, idObjGrp;\nbool tracking, refMir, smSurf;\n\nvoid TrackSetup ()\n{\n  float r, dtc;\n  fLen = 3.5;\n  trWid = 0.12;\n  spRad = 0.7;\n  spDist = 0.82 * fLen;\n  r = spRad / spDist;\n  ts = length (vec2 (2. * pi * r, 1. / spDist));\n  dtc = (0.5 * pi - 2.) * r;\n  ti[0] = 0.;\n  ti[1] = ti[0] + ts + 2. + dtc;\n  ti[2] = ti[1] + ts + 2. + dtc;\n  ti[3] = ti[2] + ts + 4. + 2. * dtc;\n  ti[4] = ti[3] + ts + 4. + 3. * dtc;\n  ti[5] = ti[4] + ts + 4. + 3. * dtc;\n  tPer =  ti[5] + ts + 4. + 2. * dtc;\n}\n\nvec3 TrackPath (float t)\n{\n  vec3 p;\n  vec2 sn;\n  float tm, tsi, tc, a, r, mr, dtc, av, c1, c2;\n  const float c025 = 0.25, c05 = 0.5, c075 = 0.75;\n  bool axFlip;\n  int pType;\n  r = spRad / spDist;\n  mr = 1. - r;\n  tsi = 1. / ts;\n  tc = c05 * pi * r;\n  av = c025 / tc;\n  dtc = (c05 * pi - 2.) * r;\n  t = mod (t, tPer);\n  p = vec3 (0.);\n  axFlip = false;\n  pType = 0;\n  sn = vec2 (1.);\n  if (t < ti[3]) {\n    if (t < ti[1] + ts) {\n      if (t < ti[0] + ts) {\n        pType = 4;  tm = t - ti[0];\n        p.xzy = vec3 (0., - mr, tm * tsi);  a = tm * tsi + c075;\n      } else if (t < ti[1]) {\n        pType = 2;  tm = t - (ti[0] + ts);\n        p.y = 1.;  a = c075;\n      } else {\n        pType = 4;  tm = t - ti[1];\n        p.xzy = vec3 (mr, 0., 1. + tm * tsi);  a = tm * tsi;\n      }\n    } else {\n      if (t < ti[2]) {\n        pType = 2;  tm = t - (ti[1] + ts);\n        p.y = 2.;  a = 0.;\n        axFlip = true;\n        sn.x = -1.;\n      } else if (t < ti[2] + ts) {\n        pType = 4;  tm = t - ti[2];\n        p.xzy = vec3 (0., mr, 2. + tm * tsi);  a = tm * tsi + c025;\n      } else {\n        pType = 1;  tm = t - (ti[2] + ts);\n        p.y = 3.;  a = c025;\n      }\n    }\n  } else {\n    if (t < ti[4] + ts) {\n      if (t < ti[3] + ts) {\n        pType = 4;  tm = t - ti[3];\n        p.xzy = vec3 (0., - mr, 3. - tm * tsi);  a = tm * tsi + c075;\n      } else if (t < ti[4]) {\n        pType = 3;  tm = t - (ti[3] + ts);\n        p.y = 2.;  a = c075;\n      } else {\n        pType = 4;  tm = t - ti[4];\n        p.xzy = vec3 (- mr, 0., 2. - tm * tsi);  a = tm * tsi + c05;\n      }\n    } else {\n      if (t < ti[5]) {\n        pType = 3;  tm = t - (ti[4] + ts);\n        p.y = 1.;  a = c05;\n        axFlip = true;\n        sn.y = -1.;\n      } else if (t < ti[5] + ts) {\n        pType = 4;  tm = t - ti[5];\n        p.xzy = vec3 (0., mr, 1. - tm * tsi);  a = tm * tsi + c025;\n      } else {\n        pType = 1;  tm = t - (ti[5] + ts);\n        p.y = 0.;  a = c025;\n      }\n    }\n  }\n  if (pType == 1) {\n    if (tm < mr) p.xz = vec2 (- tm, 1.);\n    else if (tm < mr + tc) {\n      p.xz = vec2 (-1., 1.);  a += (tm - mr) * av;\n      pType = 5;\n    } else if (tm < 3. * mr + tc) p.xz = vec2 (-1., - tm + 2. * mr + tc);\n    else if (tm < 3. * mr + 2. * tc) {\n      p.xz = vec2 (-1., -1.);  a += (tm - (3. * mr + tc)) * av + c025;\n      pType = 5;\n    } else p.xz = vec2 (tm - (4. * mr + 2. * tc), -1.);\n  } else if (pType == 2) {\n    if (tm < mr) p.xz = vec2 (tm, -1.);\n    else if (tm < mr + tc) {\n      p.xz = vec2 (1., -1.);  a += (tm - mr) * av;\n      pType = 5;\n    } else p.xz = vec2 (1., tm - (2. * mr + tc));\n    p.xz = axFlip ? p.zx : p.xz;\n  } else if (pType == 3) {\n    c1 = 2. - 3. * r + tc;\n    c2 = 3.5 - 5. * r + 2. * tc;\n    if (tm < c05 - r) p.xz = vec2 (tm, -1.);\n    else if (tm < c05 - r + tc) {\n      p.xz = vec2 (c05, -1.);  a += (tm - (c05 - r)) * av;\n      pType = 5;\n    } else if (tm < c1) p.xz = vec2 (c025 + r, tm - (1.5 - 2. * r + tc));\n    else if (tm < c1 + tc) {\n      p.xz = vec2 (c05, c05);  a += (tm - c1) * av + c025;\n      pType = 5;\n    } else if (tm < c2) p.xz = vec2 (- (tm - (c1 + tc)) + c025, c05);\n    else if (tm < c2 + tc) {\n      p.xz = vec2 (-1., c05);  a += (tm - c2) * av + c05;\n      pType = 5;\n    } else p.xz = vec2 (-1., c025 - (tm - (c2 + tc)));\n    p.xz = axFlip ? p.zx : p.xz;\n  }\n  p.xz *= sn;\n  oCv = 0;\n  if (pType == 5) p.xz -= r * sign (p.xz);\n  if (pType == 4 || pType == 5) {\n    a *= 2. * pi;\n    p.xz += r * vec2 (cos (a), sin (a));\n    oCv = 1;\n  }\n  p.xz *= spDist;\n  p.y += 0.1;\n  return p;\n}\n\nfloat CarDf (vec3 p, float dMin)\n{\n  vec3 q;\n  float d;\n  q = p;\n  d = SmoothMin (PrRoundBoxDf (q + vec3 (0., -0.08, 0.),\n     vec3 (0.06, 0.01, 0.15), 0.02), PrRoundBoxDf (q + vec3 (0., -0.13, 0.02),\n     vec3 (0.035, 0.005, 0.07), 0.02), 0.06);\n  if (d < dMin) { dMin = d;  idObj = idObjGrp + 1;  qHit = q; }\n  q.xz = abs (q.xz) - vec2 (0.07, 0.1);\n  q.y -= 0.055;\n  d = PrCylDf (q.yzx, 0.03, 0.012);\n  if (d < dMin) { dMin = d;  idObj = idObjGrp + 2;  qHit = q; }\n  return dMin;\n}\n\nfloat ObjDf (vec3 p)\n{\n  vec3 q;\n  float dMin, d, dr, fy, sn34, sn4, flThk, htWl, wThk;\n  bool is24;\n  flThk = 0.03;\n  htWl = 0.02;\n  wThk = 0.03;\n  dMin = dstFar;\n  fy = floor (p.y) + 1.;\n  is24 = (fy == 2. || fy == 4.);\n  sn34 = ((fy == 3. || fy == 4.) ? -1. : 1.);\n  sn4 = ((fy == 4.) ? -1. : 1.);\n  if (fy >= 1. && fy <= 3.) {\n    q = p;\n    q.xz = is24 ? q.zx : q.xz;\n    q.z = abs (q.z) - spDist + spRad;\n    q.xz = vec2 (- q.z, q.x * sn34);\n    q.y -= atan (q.z, - q.x) / (2. * pi) + fy;\n    dr = length (q.xz) - spRad;\n    d = max (max (PrBox2Df (vec2 (dr, q.y), vec2 (trWid + wThk, htWl)),\n       - PrBox2Df (vec2 (dr, q.y - htWl), vec2 (trWid, htWl))), q.z);\n    q.y += 1.;\n    d = min (d, max (max (PrBox2Df (vec2 (dr, q.y), vec2 (trWid + wThk, htWl)),\n       - PrBox2Df (vec2 (dr, q.y - htWl), vec2 (trWid, htWl))), - q.z));\n    if (d < dMin) { dMin = d;  idObj = 1;  qHit = q; }\n  }\n  if (fy >= 0. && fy <= 3.) {\n    q = p;\n    q.y -= fy - flThk;\n    d = PrBoxDf (q, vec3 (fLen, flThk, fLen));\n    if (fy >= 1.) {\n      q.xz = is24 ? q.xz : q.zx;\n      q.x = abs (q.x) - spDist + 0.5 * spRad;\n      q.z += 0.65 * spRad * sn34;\n      d = max (d, - PrBox2Df (q.xz, spRad * vec2 (0.9, 0.65)));\n    }  \n    if (d < dMin) { dMin = d;  idObj = 2;  qFy = fy;  qHit = p; }\n  }\n  if (fy >= 2. && fy <= 4.) {\n    q = p;\n    q.y -= fy - 1. + 2. * flThk;\n    q.xz = is24 ? q.zx : q.xz;\n    q.x = abs (q.x) - spDist + 0.5 * spRad;\n    q.z += 0.65 * spRad * sn4;\n    d = PrBoxDf (q, spRad * vec3 (0.9, 0., 0.65) + flThk * vec3 (2.));\n    d = max (d, - min (PrBox2Df (q.xz, spRad * vec2 (0.9, 0.65)),\n       PrBox2Df (q.xz - spRad * vec2 (0.5, 0.6 * sn4),\n       spRad * vec2 (0.3, 0.2))));\n    if (d < dMin) { dMin = d;  idObj = 3; }\n  }\n  if (fy >= 1. && fy <= 4.) {\n    q = p;\n    q.y -= fy - 1. + 2. * flThk;\n    d = max (PrBoxDf (q, vec3 (fLen, 2. * flThk, fLen)),\n       - PrBox2Df (q.xz, vec2 (fLen - flThk)));\n    if (d < dMin) { dMin = d;  idObj = 4; }\n  }\n  q = p;\n  q.y -= 1.5;\n  q.xz = Rot2D (q.xz, 0.25 * pi);\n  q.xz = abs (q.xz) - (spDist - spRad) / sqrt (2.);\n  d = PrCylDf (q.xzy, 3. * flThk, 1.49);\n  if (d < dMin) { dMin = d;  idObj = 5; }\n  q = p;\n  q.y -= 1.5;\n  q.xz = abs (q.xz) - 0.95 * fLen;\n  d = PrCylDf (q.xzy, 3. * flThk, 1.49);\n  if (d < dMin) { dMin = d;  idObj = 6; }\n  q = p;\n  q.y -= 1.9;\n  d = max (PrBoxDf (q, vec3 (0.2 * fLen, 1.9, 0.2 * fLen)),\n     - PrBox2Df (q.xz, vec2 (0.2 * fLen - wThk)));\n  if (fy >= 1. && fy <= 4.) {\n    q = p;\n    q.y -= fy - 0.7;\n    d = max (d, - min (PrBox2Df (q.xy, vec2 (0.05 * fLen, 0.3)),\n       PrBox2Df (q.zy, vec2 (0.05 * fLen, 0.3))));\n  }\n  if (d < dMin) { dMin = d;  idObj = 7;  qHit = q; }\n  idObjGrp = 0;\n  for (int nc = 0; nc < NCAR; nc ++) {\n    q = p - carPos[nc];\n    d = PrBoxDf (q, vec3 (0.2));\n    idObjGrp += 256;\n    if (d < dMin) dMin = CarDf (carMat[nc] * q, dMin);\n  }\n  return dMin;\n}\n\nvec3 ObjNf (vec3 p)\n{\n  vec3 e = vec3 (0.0001, -0.0001, 0.);\n  vec4 v = vec4 (ObjDf (p + e.xxx), ObjDf (p + e.xyy),\n     ObjDf (p + e.yxy), ObjDf (p + e.yyx));\n  return normalize (vec3 (v.x - v.y - v.z - v.w) + 2. * vec3 (v.y, v.z, v.w));\n}\n\nfloat ObjRay (vec3 ro, vec3 rd)\n{\n  vec3 p;\n  float d, dHit, srd, dda;\n  dHit = 0.;\n  srd = - sign (rd.y);\n  dda = - srd / (rd.y + 0.00001);\n  for (int j = 0; j < 200; j ++) {\n    p = ro + dHit * rd;\n    d = ObjDf (p);\n    dHit += min (d, 0.01 + max (0., fract (dda * fract (srd * p.y))));\n    if (d < 0.001 || dHit > dstFar) break;\n  }\n  return dHit;\n}\n\nvec4 FloorCol (vec3 vn)\n{\n  vec3 col;\n  vec2 u, uu;\n  float spec, wFac, f, ff;\n  bool nrTrail;\n  col = vec3 (0.4);\n  spec = 0.1;\n  smSurf = false;\n  u = qHit.xz;\n  if (idObj == 1) {\n    f = abs (length (u) - spRad) / trWid;\n    if (vn.y > 0. && f < 0.95) {\n      col = mix (vec3 (0.1), vec3 (1., 1., 0.),\n         SmoothBump (-0.05, 0.1, 0.05, abs (f) - 0.85));\n      spec = 0.3;\n      smSurf = true;\n    } else if (vn.y < -0.8) {\n      col = mix (col, vec3 (0.3, 0.3, 1.),\n         smoothstep (0., 0.02, abs (f) - 0.93));\n    } else {\n      col = vec3 (0.7, 0.6, 0.4);\n    }\n  } else if (idObj == 2) {\n    wFac = 1.;\n    if (vn.y > 0.999) {\n      uu = mod (u + 0.25, 0.5);\n      f = 1. - (1. - SmoothBump (0.24, 0.26, 0.01, uu.x)) *\n         ( 1. - SmoothBump (0.24, 0.26, 0.01, uu.y));\n      col = mix (col, vec3 (0.5, 0.5, 0.8), f);\n      if (qFy == 0. || qFy == 3.) nrTrail = (u.x < 0.);\n      else {\n        if (qFy == 1.) u.y *= -1.;\n        if (u.x > 0. || u.y > 0.) {\n          if (u.x > 0. && u.y > 0. && length (u.xy) > 0.6 * fLen) nrTrail = true;\n          else {\n            u.xy += 0.25 * spDist;\n            wFac = 0.75;\n            nrTrail = true;\n          }\n        }\n      }\n      if (nrTrail) {\n        f = (pow (length (pow (abs (u), vec2 (5.))), 0.2) -\n           0.82 * wFac * fLen) / trWid;\n        if (abs (f) < 0.98) {\n          uu = mod (u + 0.4, 0.8) - 0.4;\n          ff = (1. - SmoothBump (- 0.1, 0.1, 0.02, uu.x)) *\n             (1. - SmoothBump (- 0.1, 0.1, 0.02, uu.y));\n          col = mix (vec3 (0.1), vec3 (1., 1., 0.),\n             ff * SmoothBump (-0.05, 0.1, 0.05, abs (f) - 0.85));\n          spec = 0.3;\n          smSurf = true;\n        }\n      }\n    } else if (qFy > 0. && vn.y < -0.999) {\n      uu = mod (u + 0.1, 0.35) - 0.1;\n      f = 1. - (1. - SmoothBump (-0.006, 0.006, 0.002, uu.x)) *\n         (1. - SmoothBump (-0.006, 0.006, 0.002, uu.y));\n      col = mix (col, vec3 (0.5), f);\n      uu = mod (u, 0.35) - 0.175;\n      if (length (uu) < 0.03) {\n        col = vec3 (1., 0.7, 0.2);\n        spec = -1.;\n      }\n    } else if (abs (vn.y) < 0.01) col = vec3 (0.45, 0.45, 0.4);\n  }\n  return vec4 (col, spec);\n}\n\nvec4 CarCol ()\n{\n  vec3 col;\n  vec2 u;\n  float f, spec, br;\n  int ig, id;\n  bool brkLt;\n  ig = idObj / 256;\n  id = idObj - 256 * ig;\n  if (id == 1) {\n    col = vec3 (0.3, 1., 0.5);\n    f = abs (qHit.z + 0.02);\n    f = max (max (step (0.075, f) * step (0.045, abs (qHit.x)),\n       step (f, 0.007)), step (0.017, abs (qHit.y - 0.13)));\n    if (f == 0.) {\n      col = vec3 (0.2, 0.1, 0.);\n      spec = 0.5;\n    }\n    if (abs (qHit.z) > 0.15) {\n      if (qHit.z > 0.) {\n        if (length (vec2 (qHit.x, 3. * (qHit.y - 0.08))) < 0.03) col *= 0.3;\n        u = qHit.xy;\n        u.x = abs (u.x);\n        u -= vec2 (0.045, 0.08);\n        if (length (u) < 0.009) {\n          col = vec3 (1., 1., 0.3);\n          spec = -1.;\n        }\n      } else {\n        brkLt = false;\n        u = qHit.xy;\n        u.y -= 0.095;\n        if (abs (u.x) < 0.03 && abs (u.y) < 0.0025) brkLt = true;\n        u = qHit.xy;\n        u.x = abs (u.x);\n        u -= vec2 (0.055, 0.08);\n        if (length (u) < 0.007) brkLt = true;\n        if (brkLt) {\n          br = 0.;\n          for (int nc = 0; nc < NCAR; nc ++) {\n            if (nc == ig - 1 && carCv[nc] == 1) br = 1.;\n          }\n          col = vec3 (1., 0., 0.) * (0.5 + 0.5 * br);\n          spec = -1.;\n        }\n        u.x += 0.02;\n        if (length (u) < 0.007) {\n          col = vec3 (1., 0., 0.);\n          spec = -1.;\n        }\n      }\n    }\n  } else if (id == 2) {\n    f = length (qHit.yz);\n    if (f < 0.018) {\n      col = (f > 0.005) ? vec3 (0.9) : vec3 (0.3);\n      spec = 0.7;\n    } else {\n      col = vec3 (0.03);\n      spec = 0.1;\n    } \n  }\n  return vec4 (col, spec);\n}\n\nfloat BrickPat (vec2 p)\n{\n  vec2 q, iq;\n  q = 8. * p * vec2 (1., 4.);\n  iq = floor (q);\n  if (2. * floor (iq.y / 2.) != iq.y) q.x += 0.5;\n  q = smoothstep (0.02, 0.05, abs (fract (q + 0.5) - 0.5));\n  return (0.7 + 0.3 * q.x * q.y);\n}\n\nvec4 ObjCol (vec3 ro, vec3 vn)\n{\n  vec4 objCol;\n  vec3 q;\n  float f;\n  objCol.a = 0.1;\n  if (idObj == 1 || idObj == 2) {\n    objCol = FloorCol (vn);\n  } else if (idObj == 3) {\n    f = (max (abs (vn.x), abs (vn.z)) > abs (vn.y)) ?\n       BrickPat ((abs (vn.x) >  abs (vn.z) ? ro.zy : ro.xy)) : 1.;\n    objCol.rgb = f * vec3 (0.5, 0.4, 0.3);\n  } else if (idObj == 4) {\n    f = (dot (vn.xz, ro.xz) < 0.) ?\n       BrickPat ((abs (vn.x) >  abs (vn.z) ? ro.zy : ro.xy)) : 1.;\n    objCol.rgb = f * vec3 (0.7, 0.6, 0.4);\n  } else if (idObj == 5) {\n    f = smoothstep (0.1, 0.15, abs (mod (10. * ro.y, 1.)));\n    objCol.rgb = mix (vec3 (0., 0., 1.), vec3 (0.7, 0.6, 0.4), f);\n  } else if (idObj == 6) {\n    f = smoothstep (0.1, 0.15, abs (mod (10. * ro.y, 1.)));\n    objCol.rgb = (0.7 + 0.3 * f) * vec3 (0.7, 0.6, 0.4);\n  } else if (idObj == 7) {\n    q = abs (vn.x) > abs (vn.z) ? qHit.zyx : qHit;\n    if (dot (vn.xz, ro.xz) > 0. && length (q.xy - vec2 (0., 0.35)) < 0.02) {\n      objCol.rgb = vec3 (1., 0.2, 0.2);\n      objCol.a = -1.;\n    } else objCol.rgb = BrickPat (q.xy) * vec3 (0.7, 0.6, 0.4);\n  } else if (idObj > 256) {\n    objCol = CarCol ();\n  }\n  return objCol;\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  vec4 objCol;\n  vec3 ltPos, ltAx, ltDir, col, vn, rds;\n  float dstHit, diff, ltDiff, ltSpec, d, atten, f;\n  int idObjT;\n  dstHit = ObjRay (ro, rd);\n  if (dstHit < dstFar) {\n    ro += rd * dstHit;\n    idObjT = idObj;\n    vn = ObjNf (ro);\n    idObj = idObjT;\n    objCol = ObjCol (ro, vn);\n    if ((idObj == 1 || idObj == 2) && ! smSurf || idObj >= 3 && idObj <= 7)\n       vn = VaryNf (100. * ro, vn, 0.2);\n    if (objCol.a >= 0.) {\n      ltDiff = 0.;\n      ltSpec = 0.;\n      for (int nc = 0; nc < NCAR + 1; nc ++) {\n        if (tracking || nc < NCAR) {\n          ltPos = carPos [nc];\n          ltAx = vec3 (0., 0., 1.) * carMat[nc];\n          ltPos += 0.2 * ltAx;\n          ltPos.y += 0.05;\n          ltDir = ltPos - ro;\n\t  ltDir.y += 0.05;\n          atten = 1. - smoothstep (0.85, 0.95, abs (ltAx.y));\n\t  if (nc < NCAR) atten *= 1. - smoothstep (0.05, 0.1, ltDir.y);\n          d = max (length (ltDir), 0.3);\n          ltDir = normalize (ltDir);\n          f = max (dot (ltAx, - ltDir), 0.);\n          atten *= f * f / pow (d, 2.);\n          diff = max (dot (ltDir, vn), 0.);\n          ltDiff += atten * diff;\n          ltSpec += step (0., diff) *\n             atten * pow (max (dot (reflect (ltDir, vn), rd), 0.), 32.);\n         }\n      }\n      ltDiff = min (0.4 * ltDiff, 1.) +\n         0.2 * max (dot (vec3 (0., 0., 1.), vn), 0.);\n      col = objCol.rgb * (0.1 + ltDiff + objCol.a * min (0.3 * ltSpec, 1.));\n      if (! tracking) col *= 1.5;\n    } else col = objCol.rgb;\n  } else {\n    col = vec3 (0., 0., 0.07);\n    f = step (0., (rd.y + 0.3) / 1.3);\n    rds = (rd + vec3 (1., 0.7, 0.3));\n    for (int j = 0; j < 14; j ++) rds = 11. * abs (rds) / dot (rds, rds) - 3.;\n    col += min (1., 1.5e-6 * pow (min (16., length (rds)), 5.)) *\n       f * f * vec3 (0.65, 0.65, 0.6);\n  }\n  return clamp (col, 0., 1.);\n}\n\nvoid ObjPM (float t)\n{\n  vec3 vuF, vuB, dv;\n  vec2 ort, cr, sr;\n  oPos = TrackPath (t);\n  vuF = TrackPath (t + 0.05);\n  vuB = TrackPath (t - 0.05);\n  dv = vuF - vuB;\n  ort = vec2 (- asin (dv.y / length (dv)), atan (dv.z, dv.x) - 0.5 * pi);\n  cr = cos (ort);\n  sr = sin (ort);\n  oMat = mat3 (1., 0., 0., 0., cr.x, - sr.x, 0., sr.x, cr.x) *\n     mat3 (cr.y, 0., - sr.y, 0., 1., 0., sr.y, 0., cr.y);\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  vec4 mPtr;\n  mat3 vuMat, vuMatT;\n  vec3 col, ro, rd, vd, u, p1, p2;\n  vec2 canvas, uv, ut, uvs, vf, cf, sf, mMid, mSize;\n  float el, az, f, s, cd, vel, cdGap, fnc;\n  canvas = iResolution.xy;\n  uv = 2. * fragCoord.xy / canvas - 1.;\n  uvs = uv;\n  uv.x *= canvas.x / canvas.y;\n  tCur = iTime;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / canvas - 0.5;\n  tracking = ! (mPtr.z > 0.);\n  dstFar = tracking ? 10. : 30.;\n  mMid = vec2 (-1., 0.6);\n  mSize = vec2 (0.6, 0.3);\n  ut = abs (uv - mMid) - mSize;\n  refMir = tracking && (max (ut.x, ut.y) < 0.);\n  vel = 0.3;\n  TrackSetup ();\n  s = vel * tCur;\n  cdGap = 0.4 + 0.6 * SmoothBump (0.3, 0.8, 0.2, fract (2.5 * s / tPer));\n  for (int nc = 0; nc < NCAR; nc ++) {\n    fnc = float (nc);\n    ObjPM (s + cdGap * (floor (0.5 * fnc) + 1.) * (2. * mod (fnc, 2.) - 1.));\n    carPos[nc] = oPos;\n    carPos[nc].y -= 0.125;\n    carMat[nc] = oMat;\n    carCv[nc] = oCv;\n  }\n  if (tracking) {\n    s += 0.1 * (SmoothBump (0.2, 0.7, 0.1, fract (7. * s / tPer)) - 0.5);\n    ObjPM (s);\n    carPos[NCAR] = oPos;\n    carPos[NCAR].y -= 0.125;\n    carMat[NCAR] = oMat;\n    p1 = TrackPath (s + 0.1);\n    p2 = TrackPath (s - 0.1);\n    ro = 0.5 * (p1 + p2);\n    vd = normalize (p1 - p2);\n    if (refMir) vd *= -1.;\n    u = - vd.y * vd;\n    f = 1. / sqrt (1. - vd.y * vd.y);\n    vuMatT = mat3 (f * vec3 (- vd.z, 0., vd.x), f * vec3 (u.x, 1. + u.y, u.z), vd);\n  }\n  az = 0.;\n  el = refMir ? -0.1 : 0.1;\n  if (mPtr.z > 0.) {\n    el = el - 4. * mPtr.y;\n    az = az + 10. * mPtr.x;\n  }\n  el = clamp (el, -0.45 * pi, 0.45 * pi);\n  vf = vec2 (el, az);\n  cf = cos (vf);\n  sf = sin (vf);\n  vuMat = mat3 (1., 0., 0., 0., cf.x, - sf.x, 0., sf.x, cf.x) *\n     mat3 (cf.y, 0., sf.y, 0., 1., 0., - sf.y, 0., cf.y);\n  if (tracking) {\n    ro.y += 0.05;\n    if (refMir) uv = (uv - mMid) / mSize.x;\n    rd = vuMatT * (vuMat * normalize (vec3 (uv, (refMir ? 1.5 : 1.8))));\n  } else {\n    ro = vec3 (0., 2., -12.) * vuMat;\n    rd = normalize (vec3 (uv, 3.)) * vuMat;\n  }\n  col = ShowScene (ro, rd);\n  col = mix (vec3 (0.3), col, pow (max (0., 0.85 -\n     length (pow (abs (uvs), vec2 (10.)))), 0.2));\n  ut = abs (ut);\n  if (refMir && min (ut.x, ut.y) * canvas.y < 2.) col = vec3 (0.3, 0.5, 0.2);\n  fragColor = vec4 (col, 1.);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc-by-nc-sa-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/Ms33Dj.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "Msc3WB", "name": "Raymarched Yin Yang", "author": "KnightPista", "description": "Simple raymarched yin yang", "tags": ["3d", "raymarching", "yang", "yin", "yinyang"], "likes": 5, "viewed": 623, "date": "1452154694", "time_retrieved": "2024-06-20T18:30:43.565162", "image_code": "const float PI = 3.14159265359;\nconst float DEG_TO_RAD = PI / 180.0;\n\nfloat sdCylinderZ( vec3 p, vec2 h )\n{\n  vec2 d = abs(vec2(length(p.xy),p.z)) - h;\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat sdTorusZ( vec3 p, vec2 t )\n{\n  return length( vec2(length(p.xy)-t.x,p.z) )-t.y;\n}\n\nvec4 uni(vec4 a, vec4 b)\n{\n  return a.x < b.x ? a : b;\n}\n\nvec4 yin_yang(vec3 p)\n{\n    const float discRadius = 1.0;\n\tconst float discOutline = 0.02;\n\tconst float discHeight = 0.1;\n    \n    vec4 d = vec4(sdCylinderZ(p, vec2(discRadius + discOutline, discHeight)), vec3(0.4));\n    \n    d = uni(d, vec4(sdTorusZ(p, vec2(discRadius + discOutline, discHeight)), vec3(1.0)));\n    \n    d = uni(d, vec4(sdCylinderZ(p, vec2(discRadius, discHeight)), vec3(step(p.x, 0.0))));\n    \n    d = uni(d, vec4(sdCylinderZ(p + vec3(0.0, discRadius*0.5, 0.0), vec2(discRadius*0.5, discHeight)), vec3(1.0)));\n    d = uni(d, vec4(sdCylinderZ(p + vec3(0.0, -discRadius*0.5, 0.0), vec2(discRadius*0.5, discHeight)), vec3(0.0)));\n    \n    d = uni(d, vec4(sdCylinderZ(p + vec3(0.0, discRadius*0.5, 0.0), vec2(discRadius*0.125, discHeight)), vec3(0.0)));\n    d = uni(d, vec4(sdCylinderZ(p + vec3(0.0, -discRadius*0.5, 0.0), vec2(discRadius*0.125, discHeight)), vec3(1.0)));\n    \n    return d;\n}\n\nvec3 calcNormal( in vec3 pos )\n{\n\tvec3 eps = vec3( 0.001, 0.0, 0.0 );\n\tvec3 nor = vec3(\n\t    yin_yang(pos+eps.xyy).x - yin_yang(pos-eps.xyy).x,\n\t    yin_yang(pos+eps.yxy).x - yin_yang(pos-eps.yxy).x,\n\t    yin_yang(pos+eps.yyx).x - yin_yang(pos-eps.yyx).x );\n\treturn normalize(nor);\n}\n\nvec3 rayDir( float fov, vec2 size, vec2 pos )\n{\n\tvec2 xy = pos - size * 0.5;\n\n\tfloat cot_half_fov = tan( ( 90.0 - fov * 0.5 ) * DEG_TO_RAD );\t\n\tfloat z = size.y * 0.5 * cot_half_fov;\n\t\n\treturn normalize( vec3( xy, z ) );\n}\n\nvec4 trace(vec3 origin, vec3 ray, vec2 bounds)\n{\n    float t = 0.0;\n    vec3 color = vec3(0.0);\n    \n    for (int i = 0; i < 64; ++i)\n    {\n        vec3 p = origin + ray * t;\n        vec4 ret = yin_yang(p);\n        \n        float distance = ret.x;\n        color = ret.yzw;\n        \n        t += distance;\n        \n        if(t < bounds.x || t > bounds.y)\n            break;\n    }\n    \n    return vec4(t, color);\t\t\t\t\t\t\t\n}\n\nmat3 setCamera( in vec3 eye, in vec3 target, float rotation )\n{\n\tvec3 cw = normalize(target-eye);\n\tvec3 cp = vec3(sin(rotation), cos(rotation),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\nvec3 shade(vec3 eye, vec3 dir, float t, vec3 col)\n{\n    vec3 lightDir = normalize(vec3(0.0, -0.5, 1.0));\n    \n    vec3 pos = eye + dir*t;\n    vec3 nrm = calcNormal(pos);\n    vec3 ref = reflect( dir, nrm );\n    \n    float diff = clamp(dot(nrm, lightDir), 0.0, 1.0);\n    float spec = pow(clamp( dot( ref, lightDir ), 0.0, 1.0 ), 32.0);\n    float fre = pow( clamp(1.0+dot(nrm,dir),0.0,1.0), 2.0 );\n    \n    vec3 ret = vec3(0.3);\n   \tret += 1.4 * vec3(0.9) * diff;\n    ret += 1.2 * vec3(0.8) * spec;\n    ret += 0.4 * vec3(1.0) * fre;\n    ret = ret * col;\n\n    vec3 back = mix(vec3(0.4), 1.5 * vec3(0.7, 0.8, 0.9), clamp((dir.y*1.5+1.0)/2.0, 0.0, 1.0));\n    \n    ret = mix( ret, back, 1.0-exp( -0.002*t*t ) );\n        \n    return clamp(ret, 0.0, 1.0);\n}\n\nvec3 render(vec3 eye, vec3 dir)\n{\n\tvec4 rayMarch = trace(eye, dir, vec2(0.01, 100.0));\n    \n    return shade(eye, dir, rayMarch.x, rayMarch.yzw);    \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    const float mouseSpeed = 5.0;\n    vec2 mouseRel = iMouse.xy/iResolution.xy;\n    \n    float time = 2.5 + iTime * 0.5;\n    float camDist = 3.0 - (1.0 * mouseRel.y);\n    \n\tvec3 camPos = vec3( sin(-time + mouseSpeed*mouseRel.x) * camDist, -sin(-time+5.0) * 1.4, cos(-time + mouseSpeed*mouseRel.x) * camDist );\n    mat3 cam = setCamera( camPos, vec3(0.0), 0.0 );\n    \n    vec3 rd = cam * rayDir( 45.0, iResolution.xy, fragCoord.xy );\n \n    vec3 col = render(camPos, rd);\n    \n    col = pow( col, vec3(1.0/2.2) );\n    \n    fragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/Msc3WB.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "Msc3WX", "name": "Mandelbrot meets Julia", "author": "s23b", "description": "Just my little hello world", "tags": ["2d", "fractal", "julia", "mandelbrot"], "likes": 2, "viewed": 531, "date": "1452432066", "time_retrieved": "2024-06-20T18:30:43.565162", "image_code": "#define RATIO .2\n#define ZOOM .25\n#define MAX_ITER 256\n#define PI 3.14159265359\n\nvec3 hsv2rgb (in vec3 hsv) {\n    return hsv.z * (1.0 + 0.5 * hsv.y * (cos (2.0 * PI * (hsv.x + vec3 (0.0, 0.6667, 0.3333))) - 1.0));\n}\n\nvec4 pal(in float f)\n{   \n    return vec4(hsv2rgb(vec3(f / 128.0, 1.0, 1.0)), 1.0);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n\tvec2 z = (fragCoord.xy / iResolution.xy - .5) / ZOOM;\n    z.x *= iResolution.x / iResolution.y;\n    float t = iTime;\n    z *= mat2(cos(t), -sin(t), sin(t), cos(t));\n\t\n    vec2 c = mix(vec2(sin(t), cos(t)), z, RATIO);\n    \n    float f = 0.0;\n    for (int i = 0; i < MAX_ITER; ++i)\n    {\n        z = vec2(z.x * z.x - z.y * z.y, 2.0 * z.x * z.y) + c;\n        if (length(z) > 256.0) break;\n        f += 1.0;\n    }\n    \n    if (f < float(MAX_ITER))\n    {\n        float m = log2(log2(length(z)));\n        f += 1.0 - m;\n        vec4 c1 = pal(floor(f));\n        vec4 c2 = pal(floor(f + 1.0));\n        fragColor = mix(c1, c2, fract(f));\n\t}\n    else\n    {\n        fragColor = vec4(0.0, 0.0, 0.0, 1.0);\n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/Msc3WX.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "MscGzs", "name": "2016/01/02", "author": "hughsk", "description": "âœ¨", "tags": ["sdf", "warp", "spin", "environmentmap"], "likes": 17, "viewed": 776, "date": "1451702798", "time_retrieved": "2024-06-20T18:30:44.437863", "image_code": "vec2 doModel(vec3 p);\n\nvec2 calcRayIntersection(vec3 rayOrigin, vec3 rayDir, float maxd, float precis) {\n  float latest = precis * 2.0;\n  float dist   = +0.0;\n  float type   = -1.0;\n  vec2  res    = vec2(-1.0, -1.0);\n\n  for (int i = 0; i < 70; i++) {\n    if (latest < precis || dist > maxd) break;\n\n    vec2 result = doModel(rayOrigin + rayDir * dist);\n\n    latest = result.x;\n    type   = result.y;\n    dist  += latest;\n  }\n\n  if (dist < maxd) {\n    res = vec2(dist, type);\n  }\n\n  return res;\n}\n\nvec2 calcRayIntersection(vec3 rayOrigin, vec3 rayDir) {\n  return calcRayIntersection(rayOrigin, rayDir, 20.0, 0.001);\n}\n\nvec3 calcNormal(vec3 pos, float eps) {\n  const vec3 v1 = vec3( 1.0,-1.0,-1.0);\n  const vec3 v2 = vec3(-1.0,-1.0, 1.0);\n  const vec3 v3 = vec3(-1.0, 1.0,-1.0);\n  const vec3 v4 = vec3( 1.0, 1.0, 1.0);\n\n  return normalize( v1 * doModel( pos + v1*eps ).x +\n                    v2 * doModel( pos + v2*eps ).x +\n                    v3 * doModel( pos + v3*eps ).x +\n                    v4 * doModel( pos + v4*eps ).x );\n}\n\nvec3 calcNormal(vec3 pos) {\n  return calcNormal(pos, 0.002);\n}\n\nvec2 squareFrame(vec2 screenSize, vec2 coord) {\n  vec2 position = 2.0 * (coord.xy / screenSize.xy) - 1.0;\n  position.x *= screenSize.x / screenSize.y;\n  return position;\n}\n\nmat3 calcLookAtMatrix(vec3 origin, vec3 target, float roll) {\n  vec3 rr = vec3(sin(roll), cos(roll), 0.0);\n  vec3 ww = normalize(target - origin);\n  vec3 uu = normalize(cross(ww, rr));\n  vec3 vv = normalize(cross(uu, ww));\n\n  return mat3(uu, vv, ww);\n}\n\nvec3 getRay(mat3 camMat, vec2 screenPos, float lensLength) {\n  return normalize(camMat * vec3(screenPos, lensLength));\n}\n\nvec3 getRay(vec3 origin, vec3 target, vec2 screenPos, float lensLength) {\n  mat3 camMat = calcLookAtMatrix(origin, target, 0.0);\n  return getRay(camMat, screenPos, lensLength);\n}\n\nvoid orbitCamera(\n  in float camAngle,\n  in float camHeight,\n  in float camDistance,\n  in vec2 screenResolution,\n  out vec3 rayOrigin,\n  out vec3 rayDirection,\n  in vec2 coord\n) {\n  vec2 screenPos = squareFrame(screenResolution, coord);\n  vec3 rayTarget = vec3(0.0);\n\n  rayOrigin = vec3(\n    camDistance * sin(camAngle),\n    camHeight,\n    camDistance * cos(camAngle)\n  );\n\n  rayDirection = getRay(rayOrigin, rayTarget, screenPos, 2.0);\n}\n\nfloat sdBox(vec3 position, vec3 dimensions) {\n  vec3 d = abs(position) - dimensions;\n\n  return min(max(d.x, max(d.y,d.z)), 0.0) + length(max(d, 0.0));\n}\n\nfloat gaussianSpecular(\n  vec3 lightDirection,\n  vec3 viewDirection,\n  vec3 surfaceNormal,\n  float shininess) {\n  vec3 H = normalize(lightDirection + viewDirection);\n  float theta = acos(dot(H, surfaceNormal));\n  float w = theta / shininess;\n  return exp(-w*w);\n}\n\nconst float PI = 3.14159265359;\n\nvec2 rotate2D(vec2 p, float a) {\n return p * mat2(cos(a), -sin(a), sin(a),  cos(a));\n}\n\nvec3 palette(float t, vec3 a, vec3 b, vec3 c, vec3 d) {\n  return a + b * cos(6.28318 * (c * t + d));\n}\n\nvec3 gradient(float t) {\n  return palette(t,\n    vec3(0.5),\n    vec3(0.5),\n    vec3(0.5, 0.25, 0.39),\n    vec3(0.35, 0.25, 0.15)\n  );\n}\n\nfloat modAngle(inout vec2 p, float a) {\n  float a1 = atan(p.y, p.x);\n  float a2 = mod(a1 + a * 0.5, a) - a * 0.5;\n\n  p = vec2(cos(a2), sin(a2)) * length(p);\n\n  return mod(floor(a1 / a + 0.5), 2.0 * PI / a);\n}\n\nfloat modRot(inout vec2 p, float i) {\n  return modAngle(p, 2.0 * PI / i);\n}\n \nvec2 doModel(vec3 p) {\n  float off2 = iTime * -0.5 + sin(iTime * 2.) * 0.4;\n  float off1 = 1.7 + sin(-iTime * 3.) * .25;\n  float bsize = 0.1 - pow(abs(p.y / off1), 20.05) * 0.15;\n  float d = length(p) - 1.;\n  \n  d += sin((p.x * p.y * p.z) * 10. - iTime * 5.) * 0.025;\n  d = min(d, length(abs(p) - vec3(0, off1, 0)) - 0.3);\n  \n  modRot(p.xz, 8.0);\n  p.yx = rotate2D(p.yx, off2);\n  modRot(p.yx, 6.0);\n  \n  p.xz = rotate2D(p.xz, iTime * 2. + sin(iTime * 2.) * 2.);\n  float d2 = sdBox(p - vec3(0, off1, 0), vec3(bsize)) - 0.02;\n    \n  d = min(d, d2);\n  \n  return vec2(d, 0.0);\n}\n\nvec3 bg(vec3 ro, vec3 rd) {\n  return gradient(rd.y);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  vec3 ro, rd;\n\n  vec2  uv       = squareFrame(iResolution.xy, fragCoord.xy);\n  float rotation = iTime * 0.85;\n  float height   = 0.1;\n  float dist     = 4.5;\n  \n  orbitCamera(rotation, height, dist, iResolution.xy, ro, rd, fragCoord.xy);\n\n  vec3 color = mix(bg(ro, rd) * 1.5, vec3(1), 0.125);\n  vec2 t = calcRayIntersection(ro, rd, 8., 0.005);\n  if (t.x > -0.5) {\n    vec3 pos = ro + rd * t.x;\n    vec3 nor = calcNormal(pos);\n    color = bg(pos, reflect(rd, nor));\n    color += gaussianSpecular(vec3(0, 1, 0), -rd, nor, 0.415) * 1.0;\n  }\n  \n  color = mix(color, vec3(1), 0.5);\n  color -= dot(uv, uv * 0.155) * vec3(0.5, 1, 0.7) * 0.9;\n  color.r = smoothstep(0.1, 0.9, color.r);\n  color.g = smoothstep(0.0, 1.1, color.g);\n  color.b = smoothstep(0.05, 1.0, color.b);\n\n  fragColor.rgb = color;\n  fragColor.a   = 1.0;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/MscGzs.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "Msd3DX", "name": "Eater", "author": "gaz", "description": "3d", "tags": ["raymarching", "fold", "bend"], "likes": 12, "viewed": 231, "date": "1452589566", "time_retrieved": "2024-06-20T18:30:44.437863", "image_code": "#define PI\t3.14159265359\n\nmat2 rotate(in float a)\n{\n    float s=sin(a),c=cos(a);\n    return mat2(c,s,-s,c);\n}\n\nvec3 hsv(float h, float s, float v)\n{\n  return mix(vec3(1),clamp((abs(fract(h+vec3(3,2,1)/3.)*6.-3.)-1.),0.,1.),s)* v;\n}\n\nvec2 opFold(in vec2 p, in float a, in int t)\n{\n    p.x = abs(p.x);\n    vec2 v = vec2(cos(a), sin(a));\n    for(int i = 0; i < 10; i++)\n    {\n        if (i == t) break;\n        p -= 2.0*min(0.0,dot(p,v))*v;\n        v = normalize(vec2(v.x-1.0,v.y));\n    }\n    return p;    \n}\n\nvec2 opBend(in vec2 p, in float d) // used quadratic function\n{\n    p.y -= d*p.x*p.x;\n    p.y *= cos(atan(2.0*d*p.x));\n \treturn p;   \n}\n\nfloat smin(in float a, in float b, in float k )\n{\n    float h = clamp( 0.5 + 0.5*(b-a)/k, 0.0, 1.0 );\n\treturn mix( b, a, h ) - k*h*(1.0-h);\n}\n\nfloat lengthN(in vec2 p, in float n)\n{\n\tp = pow(abs(p), vec2(n));\n\treturn pow(p.x+p.y, 1.0/n);\n}\n\nvec2 deSegment(in vec2 p, in vec2 a, in vec2 b)\n{\n\tvec2 pa=p-a,ba=b-a;\n\tfloat h=clamp(dot(pa,ba)/dot(ba,ba),0.,1.);\n\treturn vec2(length(pa-ba*h), h);\n}\n\nfloat de1(in vec3 p)\n{\n    p.y *=0.7;\n \tvec2 q = vec2(length(p.xz)-2.1,p.y);\n    float a = atan(p.z,p.x)+0.11;\n \tfloat de = lengthN(q, 3.0+2.0*sin(a*16.0))-0.3;\n    p.xz = opFold(p.xz, PI / 2.0, 4);\n\tde += texture(iChannel1, p.xy*0.2).x *  0.03;\n\treturn de;\n}\n\nfloat de2(in vec3 p)\n{\n    p.xz = opFold(p.xz, PI/2.0, 4);\n    p.z -= 2.0;\n    p.y = abs(p.y);\n    p.yz *= rotate(0.8*sin(iTime *0.6));\n    p.y -= 0.6;\n    p.yz = opBend(p.yz, -0.35);\n    vec2 d = deSegment(p.yz, vec2(1.0, 0.0), vec2(-0.1,0.0));\n \treturn lengthN(vec2(0.8*d.x, p.x), 3.0) - 0.25*d.y;   \n}\n\nvec3 transform(in vec3 p)\n{\n\tp.zx *= rotate(iTime * 0.1);\n    p.yz *= rotate(iTime * 0.2);\n    return p;\n}\n\nfloat map(in vec3 p)\n{    \n    p = transform(p);\n    return smin(de1(p),de2(p),0.08);\n}\n\nvec3 doColor(in vec3 p)\n{\n\tp = transform(p);\n    float d1 = de1(p);\n    float d2 = de2(p);\n    if (d1 < d2){\n    \treturn mix(0.6*texture(iChannel1, p.xy).xxx,\n    \t\thsv(0.35, 0.6, 0.4), 0.5);\n    } else {   \t\n        return vec3(0.7,0.8,0.9);\n    }\n}\n\nvec3 calcNormal(in vec3 pos)\n{\n    vec2 e = vec2(1.0, -1.0) * 0.002;\n    return normalize(\n        e.xyy * map(pos + e.xyy) + \n        e.yyx * map(pos + e.yyx) + \n        e.yxy * map(pos + e.yxy) +   \n        e.xxx * map(pos + e.xxx));\n}\n\nfloat softshadow(in vec3 ro, in vec3 rd)\n{\n\tfloat res = 1.0;\n    float t = 0.05;\n    for(int i = 0; i < 32; i++)\n    {\n\t\tfloat h = map(ro + rd * t);\n        res = min(res, 8.0 * h / t);\n        t += clamp(h, 0.02, 0.1);\n        if(h < 0.001 || t > 1.5) break;\n    }\n    return clamp(res, 0.0, 1.0);\n}\n\nfloat calcAO(in vec3 pos, in vec3 nor)\n{\n\tfloat occ = 0.0;\n    float sca = 1.0;\n    for( int i=0; i<5; i++ )\n    {\n        float hr = 0.01 + 0.12*float(i)/4.0;\n        vec3 aopos =  nor * hr + pos;\n        float dd = map( aopos );\n        occ += -(dd-hr)*sca;\n        sca *= 0.95;\n    }\n    return clamp( 1.0 - 3.0*occ, 0.0, 1.0 );    \n}\n\nfloat intersect(in vec3 ro, in vec3 rd)\n{\n    const float maxd = 10.0;\n    const float precis = 0.001;\n    float h = 1.0;\n    float t = 0.0;\n    for(int i = 0; i < 64; i++)\n    {\n        if(h < precis || t > maxd) break;\n        h = map(ro + rd * t);\n        t += h;\n    }\n    if( t > maxd ) t = -1.0;\n    return t;\n}\n\nvec3 bg(in vec2 p , in vec2 fragCoord)\n{   \n    vec3 col = texture(iChannel0, \n    \t3.0 * vec2(inversesqrt(length(p)), atan(p.x, p.y) * 0.2 -iTime*0.005)).xyz;\n    col = mix(col, vec3(0.25,0.2,0.3)*length(p*0.6), 0.7);  \t\n    return col;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 p = (2.0 * fragCoord - iResolution.xy) / iResolution.y;\n    vec3 col = bg(p, fragCoord);\n    vec3 ro = vec3(0.0, 0.0, 5.0);\n    vec3 rd = normalize(vec3(p, -2.0));\n    float t = intersect(ro, rd);\n    if(t > -0.001)\n    {\n        vec3 pos = ro + t * rd;\n        vec3 nor = calcNormal(pos);\n\t\tcol = doColor(pos);\n        \n        // https://www.shadertoy.com/view/Xds3zN\n        vec3 ref = reflect( rd, nor );\n        float occ = calcAO( pos, nor );\n\t\tvec3  lig = normalize( vec3(2.0, 2.0, 3.0) );\n\t\tfloat amb = clamp( 0.3+0.5*nor.y, 0.0, 1.0 );\n        float dif = clamp( dot( nor, lig ), 0.0, 1.0 );\n        float bac = clamp( dot( nor, normalize(vec3(-lig.x,0.0,-lig.z))), 0.0, 1.0 )*clamp( 1.0-pos.y,0.0,1.0);\n        float dom = smoothstep( -0.1, 0.1, ref.y );\n        float fre = pow( clamp(1.0+dot(nor,rd),0.0,1.0), 2.0 );\n\t\tfloat spe = pow(clamp( dot( ref, lig ), 0.0, 1.0 ),30.0);\n        dif *= softshadow( pos, lig);\n        dom *= softshadow( pos, ref );\n\t\tvec3 lin = vec3(0.0);\n        lin += 1.2*dif*vec3(1.0,0.8,0.5);\n\t\tlin += 1.2*spe*vec3(1.0,0.8,0.5)*dif;\n        lin += 0.2*amb*vec3(0.5,0.7,1.0)*occ;\n        lin += 0.3*dom*vec3(0.5,0.7,1.0)*occ;\n        lin += 0.3*bac*vec3(0.2,0.2,0.2)*occ;\n        lin += 0.4*fre*vec3(1.0,1.0,1.0)*occ;\n\t\tcol = col*lin;\n    \tcol = mix( col, vec3(0.0), 1.0-exp( -0.01*t*t ) );\n\t\tcol = pow(col, vec3(0.9));\n    }\n    fragColor = vec4(col, 1.0);\n}\n", "image_inputs": [{"id": "4sfGRn", "previewfilepath": "/media/ap/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg", "ctype": "texture"}, {"id": "XsX3Rn", "previewfilepath": "/media/ap/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/Msd3DX.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "MsG3D1", "name": "Rolling shutter propellor", "author": "JamesGriffin", "description": "A propellor is defined using the implicit equation r < cos^2K(n/2*theta) + H (set the delayCoeff to 0.0 to see it).\nThis is rotated (rotationRate) and a time-shift is applied with the delay set by delayCoeff * y-coord (the rolling shutter effect).", "tags": ["implicitequation", "rollingshutter"], "likes": 4, "viewed": 618, "date": "1454236240", "time_retrieved": "2024-06-20T18:30:44.922920", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Constants\n    float delayCoeff = 0.8;\n    float rotationRate = 2.0;\n    float hubSize = 0.1;\n    float bladeThinness = 5.0; // Higher is thinner\n    int numBlades = 5; // Can only be 2, 3, 4, 5, 6 (otherwise defaults to 6)\n    // Transform coordinate system\n    vec2 xy = 4.0*(fragCoord.xy-0.5*iResolution.xy) / max(iResolution.x,iResolution.y);\n\t\n    // Work out the angle\n    float theta = rotationRate * (iTime - delayCoeff * xy.y);\n    // Rotation matrix\n    mat2 M = mat2(cos(theta), sin(theta), -sin(theta), cos(theta));\n    xy = M * xy;\n    float r = length(xy);\n    float a = 0.0;\n    float x = xy.x / r;\n    float y = xy.y / r;\n    if (r > hubSize + 1.0) { // Don't bother with calculations if out of bounds\n        a = -1.0;\n    } else {\n        float p = 0.0;\n        float q = 0.0;\n\n        if(numBlades == 2) {\n            // 2 bladed version\n            // p = cos(2t) and q = sin(2t)\n            p = (x*x - y*y);\n            // q = (2.0*x*y); (not used)\n        } else if(numBlades == 3) {\n            // 3 bladed version\n            // p = cos(3t) and q = sin(3t)\n            p = (x*x*x - 3.0*x*y*y);\n            // q = (3.0*x*x*y - y*y*y); (not used)\n        } else if (numBlades == 4) {    \n            // 4 bladed version\n            // p = cos(4t) and q = sin(4t)\n            p = (x*x*x*x - 6.0*x*x*y*y + y*y*y*y);\n            // q = (4.0*x*x*x*y - 4.0*x*y*y*y); (not used)\n        } else if (numBlades == 5) {    \n            // 5 bladed version\n            // This is p = cos(5t) and q = sin(5t)\n            p = (x*x*x*x*x - 10.0*x*x*x*y*y + 5.0*x*y*y*y*y);\n            // q = (5.0*x*x*x*x*y - 10.0*x*x*y*y*y + y*y*y*y*y); (not used)\n        } else {\n            // 6 bladed version\n            // This is p = cos(6t) and q = sin(6t)\n            p = (x*x*x*x*x*x - 15.0*x*x*x*x*y*y + 15.0*x*x*y*y*y*y - y*y*y*y*y*y);\n            // q = (6.0*x*x*x*x*x*y - 20.0*x*x*x*y*y*y + 6*x*y*y*y*y*y); (not used)\n        }\n\n        // RHS of the implicit equation\n        a = pow(0.5*(1.0 - p), bladeThinness) + hubSize;\n\n        // Rather than plot LHS < RHS, use this to smooth edges (AA for free)\n        a = min(a/r - 1.0, 0.1) / 0.1;\n    }\n    \n    \n    if(a < 0.0) {\n        // White background\n        fragColor = vec4(1.0,1.0,1.0,1.0);\n    } else {\n        // Compute a colour for the propellor\n    \tvec3 colour = vec3(0.5, 0.5, 0.5) + x*vec3(0.5,-0.5,0.0)/sqrt(2.0) + y*vec3(0.5,0.5,-1.0)/sqrt(6.0);\n    \tcolour = colour / max(max(colour.r, colour.g), colour.b);\n\t\tfragColor = vec4(a*colour + (1.0 - a), 1.0);\n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/MsG3D1.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "MsK3DR", "name": "Fractal city_242", "author": "rebb", "description": "Based on fragmentarium port of http://www.creativeapplications.net/javascript-2/the-imaginary-kingdom-of-aurullia/", "tags": ["fractal", "city", "fragmentarium"], "likes": 10, "viewed": 402, "date": "1454081145", "time_retrieved": "2024-06-20T18:30:45.807570", "image_code": "const float PI=3.14159265358979323846;\nvec3 fo =vec3 (0.0961,1.28528,0.74286);\nvec3 gh = vec3 (0.4273,0.62314,0.5638);\nvec3 gw = vec3 (0.0,0.0,0.0);\nvec4 X = vec4( 0.5,0.6,0.6,-0.22968);\nvec3 BaseColor = vec3(.623529,0.623529,0.623529);\nvec4 Y = vec4(1,0.6,0,0.44876);\nvec4 Z = vec4(0.8,0.78,1,0.15902);\nvec4 R = vec4(0.4,0.7,1,0.08464);\nvec3 orbitColor;\n\nint Iterations=12;\nfloat Scale = 3.22996;\nfloat MinRad2 = 0.112585;\nvec4 orbitTrap = vec4(40000.0);\nfloat r = .1;\nfloat sr = 30.0;\nmat3 rot;\nfloat Power =6.0;\nvec2 moro = vec2 (1.31,1.6);\nfloat marched = 0.0;\n\nfloat min_distance = 1.0;\nfloat max_distance = 63.2;\nmat3 rotationXY( vec2 angle ) {\n\tvec2 c = cos( angle );\n\tvec2 s = sin( angle );\n\t\n\treturn mat3(\n\t\tc.y      ,  0.0, -s.y,\n\t\ts.y * s.x,  c.x,  c.y * s.x,\n\t\ts.y * c.x, -s.x,  c.y * c.x\n\t);\n}\n\nvec2 rotate(vec2 k,float t)\n\t{\n\treturn vec2(cos(t)*k.x-sin(t)*k.y,sin(t)*k.x+cos(t)*k.y);\n\t}\n\n//DarkBeam's \"fold\"... reinterpreted... it's more than a fold, much more! Just awesome!\nfloat DBFold(vec3 p, float fo, float g, float w){\n\tif(p.z>p.y) p.yz=p.zy;\n\tfloat vx=p.x-2.*fo;\n\tfloat vy=p.y-4.*fo;\n \tfloat v=max(abs(vx+fo)-fo,vy);\n\tfloat v1=max(vx-g,p.y-w);\n\tv=min(v,v1);\n\tv1=max(v1,-abs(p.x));\n\treturn min(v,p.x);\n}\n//the coordinates are pushed/pulled in parallel\nvec3 DBFoldParallel(vec3 p, vec3 fo, vec3 g, vec3 w){\n\tvec3 p1=p;\n\tp.x=DBFold(p1,fo.x,g.x,w.x);\n\tp.y=DBFold(p1.yzx,fo.y,g.y,w.y);\n\tp.z=DBFold(p1.zxy,fo.z,g.z,w.z);\n\treturn p;\n}\n//serial version\nvec3 DBFoldSerial(vec3 p, vec3 fo, vec3 g,vec3 w){\n\tp.x=DBFold(p,fo.x,g.x,w.x);\n\tp.y=DBFold(p.yzx,fo.y,g.y,w.y);\n\tp.z=DBFold(p.zxy,fo.z,g.z,w.z);\n\treturn p;\n}\nfloat DE(vec3 p)\n{\n\tvec4 JC=vec4(p,1.);\n\tfloat r2=dot(p,p);\n\tfloat dd = 1.;\n\tfor(int i = 0; i<12 ; i++){\n\t\t\n\t\tp = p - clamp(p.xyz, -1.0, 1.0) * 2.0;  // mandelbox's box fold\n\n\t\t//Apply pull transformation\n\t\tvec3 signs=sign(p);//Save \tthe original signs\n\t\tp=abs(p);\n\t\tp=DBFoldParallel(p,fo,gh,gw);\n\t\t\n\t\tp*=signs;//resore signs: this way the mandelbrot set won't extend in negative directions\n\t\t\n\t\t//Sphere fold\n\t\tr2=dot(p,p);\n\t\tfloat  t = clamp(1./r2, 1., 1./MinRad2);\n\t\tp*=t; dd*=t;\n\t\t\n\t\t//Scale and shift\n\t\tp=p*Scale+JC.xyz; dd=dd*Scale+JC.w;\n\t\tp=vec3(1.0,1.0,.92)*p;\n\t\n\t\t//For coloring and bailout\n\t\tr2=dot(p,p);\n\t\torbitTrap = min(orbitTrap, abs(vec4(p.x,p.y,p.z,r2)));\t\n\t}\n\tdd=abs(dd);\n#if 1\n\treturn (sqrt(r2)-sr)/dd;//bounding volume is a sphere\n#else\n\tp=abs(p); return (max(p.x,max(p.y,p.z))-sr)/dd;//bounding volume is a cube\n#endif\n}\n\nfloat opRep( vec3 p, vec3 c )\n{\n    vec3 q = mod(p,c)-0.5*c;\n    return DE( q );\n}\nvec3 cpath( float t )\n{\n\tvec3 pos = vec3( 0.0, 0.0, 95.0 + t );\n\t\n\tfloat a = smoothstep(5.0,20.0,t);\n\tpos.xz += a*150.0 * cos( vec2(1.0,6.0) + 1.0*0.01*t );\n\tpos.xz -= a*150.0 * cos( vec2(5.0,6.0) );\n\tpos.xz += a* 50.0 * cos( vec2(0.0,3.5) + 6.0*0.01*t );\n\tpos.xz -= a* 50.0 * cos( vec2(0.0,3.5) );\n\n\treturn pos;\n}\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr )\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\nfloat rm(vec3 origin, vec3 ray) {\n   \n\tfloat distance_marched = min_distance;\n\n\tfor (int i=0; i<250; i++) {\n\t\t\n\t\tfloat step_distance = DE(origin + ray*distance_marched);\n\t\tif (abs(step_distance) < 0.001 ) {\n\t\t\treturn distance_marched/(max_distance-min_distance);\n\t\t}\n\t\tdistance_marched += step_distance;\n\t\tmarched = distance_marched;\n\t\tif (distance_marched > max_distance) {\n\t\t\treturn -1.0;\n\t\t}\n\t}\n\treturn -1.0;\n}\n\nvec3 render(vec2 q) {\n    orbitTrap.w = sqrt(orbitTrap.w);\n\t\n    \n    vec2 mouse = (iMouse.xy / iResolution.xy) * 8.0 ;\n\tvec3 eye = vec3(vec2(-5.0,5.5),-8.0);\n\tvec3 screen = vec3(q,6.222+sin(iTime)*.8);\n\t\n\tvec3 ray = normalize (screen-eye);\n    mat3 rot = rotationXY(moro);\n\tfloat s = rm(rot*eye,rot*ray);\n    \n\torbitColor = X.xyz*X.w*orbitTrap.x +\n\t\tY.xyz*Y.w*orbitTrap.y +\n\t\tZ.xyz*Z.w*orbitTrap.z +\n\t\tR.xyz*R.w*orbitTrap.w;\n\t\n\tvec3 color = mix(BaseColor,.79*orbitColor, 0.3743);\n\t//color += vec3(s-.43*.8+0.4*q.y *sin(q.x))*marched/5.26;\n    return color;\n\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 q = (6.0*fragCoord.xy-iResolution.xy)/iResolution.x;\n\t\n\tvec3 col = render(q);\n\t\t\n  //vec3 col2 = texture( iChannel0,q ).xyz;\n  fragColor = vec4(col,1.0); \t\n\t//fragColor = vec4(col.xyz+col2, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/MsK3DR.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "MsKGDR", "name": "Ret_", "author": "calx", "description": "Procedural Reticle - revised here: https://www.shadertoy.com/view/MsfcD7", "tags": ["radial", "distance", "reticle"], "likes": 22, "viewed": 883, "date": "1454278299", "time_retrieved": "2024-06-20T18:30:46.219865", "image_code": "#define PI 3.14159265359\n\nfloat n_angleBetween(vec2 v1,vec2 v2)\n{\n    float angle = atan(v1.y-v2.y,v1.x-v2.x);\n    if (angle < 0.0) angle = angle+(PI*2.0); \n    \n    return (angle / (PI*2.0));\n}\n\nvoid section(inout vec4 pixel, vec4 col1, vec4 bgCol, vec2 uv, vec2 position, float numSections, float gap, float rotationOffset, float speed, float start, float finish, float inner, float outer, float taper, float inwards, float outwards, float braceWidthStart, float braceWidthEnd, float startBrace, float endBrace) \n{\n \tspeed *= 0.02;       \n    float rotation = rotationOffset + ((speed) * iTime); \n    vec2 q = vec2(cos(rotation)*uv.x + sin(rotation)*uv.y, -sin(rotation)*uv.x + cos(rotation)*uv.y);\n    float angle = n_angleBetween(q, position); \n\n    float adjOuter = outer + (smoothstep(start, start+taper, angle) *(1.0 -smoothstep(finish, finish+taper, angle)))*outwards;\n    float adjInner = inner + (smoothstep(start, start+taper, angle) * 1.0 -smoothstep(finish, finish+taper, angle)) *inwards;\n    \n    if(angle > start  && angle < start+braceWidthStart) adjInner /= startBrace;\n    if(angle < finish && angle > finish-braceWidthEnd)  adjInner /= endBrace;\n\n    float split = floor(angle * numSections) / numSections;\n    \n    if(angle > split && angle < split+gap) adjOuter = outer-(outer-inner); \n    \n    float smoothv = 0.0025;\n    \n    float distToPos = length(uv-position);  \n    float outerEdge = smoothstep(adjOuter-smoothv, adjOuter+smoothv, distToPos);\n    float innerEdge = smoothstep(adjInner-smoothv, adjInner+smoothv, distToPos);\n    float baseRing = 1.0-(innerEdge) * 1.0+(outerEdge);\n    \n    pixel = mix(bgCol, mix(col1, bgCol, baseRing), col1.a);\n}\n\nfloat grid(vec2 r) \n{\n    float g = 0.0;\n    const float unit = 0.05;\n    \n    for(float i=-2.0; i<2.0; i+=unit)\n    {\n        g += 1.-smoothstep(0.001, 0.0011, abs(r.x-i));\n        g += 1.-smoothstep(0.001, 0.0011, abs(r.y-i));\n    }\n  \n    return g;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv =  2.0 * vec2(fragCoord.xy - 0.5* iResolution.xy) / iResolution.y;\n    vec2 pos =   vec2(0.0);\n    vec4 col1 =  vec4(1.0); \n    vec2 q = 0.6 * uv;\n    float val = 0.3+0.1*q.y;\n    vec4 bgCol = vec4(val, val, val, 0.5);      \n    bgCol *= 1.0-0.8*length(q);\n    vec4 pixel = bgCol * (grid(q)*0.25);\n    \n    section(pixel, vec4(1.0, 1.0, 1.0, 1.00), pixel, uv, pos, 03.0000, 00.1000, PI *0.5,  50.0000, 00.2000, 00.8000, 00.0300, 00.0350, 00.0000, 00.0000, 00.0000, 00.0000, 00.0000, 00.0000, 00.0000);\n    section(pixel, vec4(1.0, 1.0, 1.0, 0.60), pixel, uv, pos, 08.0000, 00.0100, PI *0.5, -50.0000, 00.2000, 00.8000, 00.0500, 00.0570, 00.0000, 00.0000, 00.0000, 00.0000, 00.0000, 00.0000, 00.0000);\n    section(pixel, vec4(1.0, 1.0, 1.0, 0.60), pixel, uv, pos, 02.0000, 00.0050, PI *0.5,  30.0000, 00.2000, 00.8000, 00.1050, 00.1070, 00.0000, 00.0000, 00.0000, 00.0000, 00.0000, 00.0000, 00.0000);\n    section(pixel, vec4(1.0, 1.0, 1.0, 0.70), pixel, uv, pos, 00.0000, 00.0050, PI *0.5,  30.0000, 00.2000, 00.8000, 00.3100, 00.3120, 00.0000, 00.0000, 00.0000, 00.0000, 00.0000, 00.0000, 00.0000);\n    section(pixel, vec4(1.0, 1.0, 1.0, 0.80), pixel, uv, pos, 32.0000, 00.0275, PI *0.5,  20.0000, 00.2000, 00.8000, 00.3100, 00.3300, 00.0000, 00.0000, 00.0000, 00.0000, 00.0000, 00.0000, 00.0000);\n    section(pixel, vec4(1.0, 1.0, 1.0, 0.90), pixel, uv, pos, 01.0000, 00.0270, PI *0.5,  20.0000, 00.2000, 00.8000, 00.3280, 00.3350, 00.0000, 00.0000, 00.0000, 00.0000, 00.0000, 00.0000, 00.0000);\n    section(pixel, vec4(1.0, 1.0, 1.0, 0.70), pixel, uv, pos, 00.0000, 00.0000, PI *0.5,  30.0000, 00.2000, 00.8000, 00.3580, 00.3750, 00.0100, 00.0100, 00.0000, 00.0000, 00.0000, 00.0000, 00.0000);\n    section(pixel, vec4(1.0, 1.0, 1.0, 0.60), pixel, uv, pos, 01.0000, 00.0020, PI *0.5, -90.0000, 00.2000, 00.8000, 00.3950, 00.4300, 00.0050, 00.0250, 00.0000, 00.0000, 00.0000, 00.0000, 00.0000);\n    section(pixel, vec4(1.0, 1.0, 1.0, 0.90), pixel, uv, pos, 03.0000, 00.0015, PI *0.0, -40.0000, 00.1000, 00.9000, 00.5000, 00.5200, 00.0350, 00.0000, 00.0220, 00.0000, 00.0000, 00.0000, 00.0000);  \n    section(pixel, vec4(1.0, 1.0, 1.0, 0.55), pixel, uv, pos, 21.0000, 00.0450, PI *0.0, -15.0000, 00.0000, 00.0000, 00.5620, 00.5720, 00.0000, 00.0000, 00.0200, 00.0000, 00.0000, 00.0000, 00.0000); \n    section(pixel, vec4(1.0, 1.0, 1.0, 0.60), pixel, uv, pos, 00.0000, 00.0050, PI *1.0,  40.0000, 00.1000, 00.9000, 00.6900, 00.7100, 00.0000, 00.0200, 00.0000, 00.0010, 00.0010, 01.2000, 01.2000); \n    section(pixel, vec4(1.0, 1.0, 1.0, 0.80), pixel, uv, pos, 00.0000, 00.0000, PI *0.0,  40.0000, 00.1000, 00.9000, 00.6900, 00.7100, 00.0000, 00.0200, 00.0000, 00.0010, 00.0010, 01.2000, 01.2000);  \n    section(pixel, vec4(1.0, 1.0, 1.0, 0.70), pixel, uv, pos, 00.0000, 00.0050, PI *0.5,  30.0000, 00.0000, 00.0000, 00.7100, 00.7220, 00.0000, 00.0000, 00.0000, 00.0000, 00.0000, 00.0000, 00.0000);\n    section(pixel, vec4(1.0, 1.0, 1.0, 0.80), pixel, uv, pos, 02.0000, 00.0010, PI *0.5,  40.0000, 00.0000, 00.0000, 00.7050, 00.7000, 00.0050, 00.0100, 00.0050, 00.0000, 00.0000, 00.0000, 00.0000); \n    section(pixel, vec4(1.0, 1.0, 1.0, 0.90), pixel, uv, pos, 01.0000, 00.0010, PI *0.5,  11.0000, 00.1000, 00.9000, 00.7500, 00.8350, 00.0100, 00.0700, 00.0000, 00.0000, 00.0000, 00.0000, 00.0000); \n    \n    fragColor = vec4(pixel);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/MsKGDR.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "Mst3DX", "name": "gloopy ladder", "author": "hypothete", "description": "Distorting the infinite spheres", "tags": ["raycasting", "brdf", "cooktorrance"], "likes": 0, "viewed": 124, "date": "1452585482", "time_retrieved": "2024-06-20T18:30:47.110824", "image_code": "#define minStep 0.1\n#define maxStep 10.0\n#define delta 0.01\n#define damping 0.9\n#define numSteps 100\n#define randseed  173.0\n\nstruct camera {\n    vec3 position;\n    vec3 direction;\n};\n    \nstruct pointLight {\n\tvec3 position;\n    float intensity;\n    vec3 color;\n};\n\nconst vec3 worldUp = vec3(0.0,1.0,0.0);\n\n\nmat3 getViewMatrix (vec3 t, vec3 d, vec3 k) // position, direction, worldUp\n{\n\tvec3 z = normalize(d);\n    vec3 x = normalize(cross(d,k));\n    vec3 y = -normalize(cross(z,x));\n    return mat3(x,y,z);\n}\n\nfloat sdSphere( vec3 p, float s ) //sphere distf\n{\n  return length(p)-s;\n}\n\nfloat sykari(in float seed)\n{\n  float x = sin(seed++) * 10000.0;\n  return clamp(fract(x), 0.0, 1.0);\n}\n\nvec3 opTwist( vec3 p )\n{\n    float c = cos(10.*p.x+iTime);\n    float s = sin(10.*p.z+iTime);\n    mat2  m = mat2(c,-s,s,c);\n    vec3  q = vec3(m*p.yx,p.z);\n    return q;\n}\n\n\nfloat opRep( vec3 p, vec3 c )\n{\n    vec3 q = mod(p,c)-0.5*c;\n    return sdSphere(opTwist(q), 0.1);\n}\n\n\nfloat distf (vec3 pos) //scene distance function\n{\n    float dist = opRep(pos,normalize(vec3(2.)));\n\treturn dist;\n}\n\nvec3 normal (vec3 p) //borrowed from https://www.shadertoy.com/view/ltfXDM\n{\n    vec2 h = vec2(delta, -delta);\n\treturn normalize (\n\t\th.xxx * distf(p + h.xxx) +\n\t\th.xyy * distf(p + h.xyy) +\n\t\th.yxy * distf(p + h.yxy) +\n\t\th.yyx * distf(p + h.yyx)\n\t);\n}\n\nfloat castRay ( vec3 pos, vec3 dir, out vec3 norm)\n{\n    float dist = minStep;\n    for(int step = 0; step < numSteps; step++)\n    {\n        norm = pos + dir*dist;\n        float normL = distf(norm);\n        if(normL > delta || dist > maxStep){\n            dist += normL*damping;\n        }\n    }\n    return dist;\n}\n\nfloat lum (vec3 rgb){\n\treturn 0.2126*rgb.r + 0.7152*rgb.g + 0.0722*rgb.b;\n}\n\nvec4 render(in vec2 xy)\n{\n    camera myCam = camera( \n    \tvec3(100.*sin(iTime*0.01),\n             50.*cos(iTime*0.01),\n             100.*cos(iTime*0.01)\n            ),\n    \tvec3(sin(iTime*0.2),\n             cos(iTime*0.8+0.4),\n             cos(iTime*0.2)\n            )\n\t);\n\n    vec3 spherePos = vec3(0);\n    \n    //BDRF stuff adapted from http://ruh.li/GraphicsCookTorrance.html\n    float roughness = 0.1;\n    float f0 =1.; //dilectric fresnel\n    float k = 0.7; //diffuse reflection strength\n    float specular = 0.6;\n    vec3 diffuseColor = vec3(0.99);\n    \n    //camera\n    mat3 viewMatrix = getViewMatrix(myCam.position, myCam.direction, worldUp);\n\tvec3 rayDir = viewMatrix * normalize(vec3(xy, 1.0));\n    vec3 ro = vec3(0.0,0.0,0.0);\n    vec4 colToRtn = vec4(0,0,1.,1.);\n    float histDistanceFunction = castRay(myCam.position, rayDir, ro);\n    vec3 nml = normal(ro);\n    \n    //more BDRF\n    vec3 lightDir = vec3(0,1.,-0.6);\n    float NdotL = max(dot(nml, lightDir),0.);\n    \n    vec4 rLight = vec4(1.);\n    float rLightIntensity = lum(rLight.xyz);\n    \n    if(NdotL > 0.){\n        vec3 eyeDir = -normalize(rayDir);\n        vec3 halfVector = normalize(lightDir+eyeDir);\n    \tfloat NdotH = max(dot(nml,halfVector),0.);\n        float NdotV = max(dot(nml,eyeDir),0.);\n        float VdotH = max(dot(eyeDir, halfVector),0.);\n        float mSquared = roughness * roughness;\n        \n        //geometric attenuation\n        float NH2 = 2. * NdotH;\n        float g1 = (NH2 * NdotV) / VdotH;\n        float g2 = (NH2 * NdotL) / VdotH;\n        float geoAtt = min(1., min(g1, g2));\n        \n        //roughness\n        float r1 = 1. / (4. * mSquared * pow(NdotH, 4.));\n        float r2 = (NdotH * NdotH - 1.) / (mSquared * NdotH * NdotH);\n        float finalRough =  r1 * exp(r2);\n        \n        //fresnel\n        float fresnel = pow(1. - VdotH, 5.);\n        fresnel *= 1. - f0;\n        fresnel += f0;\n        \n        specular = (fresnel * geoAtt * finalRough) / (NdotV * NdotL * 3.14); \n        diffuseColor = vec3(NdotL, NdotV,VdotH);\n        diffuseColor = clamp(vec3(0),vec3(1.),diffuseColor);\n    }\n    \n    vec3 finalBDRF = diffuseColor * rLight.xyz * rLightIntensity * NdotL * (k + specular * (1. - k));\n    \n    //choose which sampler we use based on our distf result\n    if(histDistanceFunction < maxStep){\n        \n\t\tcolToRtn.xyz = finalBDRF;\n    }\n    else{\n        colToRtn = vec4(vec3(0.1618),1.);\n    }\n    return colToRtn;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = (2.0 * fragCoord.xy - iResolution.xy) / iResolution.y;\n    fragColor = render(uv);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/Mst3DX.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "Mst3Wl", "name": "Music visualiser", "author": "Ruzzyr", "description": "Just felt like doing a shader and so I did.", "tags": ["raymarching", "random", "musicvisualizer"], "likes": 3, "viewed": 319, "date": "1452803900", "time_retrieved": "2024-06-20T18:30:47.116921", "image_code": "mat3 rotateYmat(float ang)\n{\n    return mat3(cos(ang), 0.0, sin(ang),\n                0.0, 1.0, 0.0,\n                -sin(ang), 0.0, cos(ang));\n}\nmat3 rotateXmat(float ang)\n{\n    return mat3(1.0, -0.0, 0.0,\n                0.0, cos(ang), -sin(ang),\n                0.0, sin(ang), cos(ang));\n}\n\nfloat sdSphere( vec3 p, float s )\n{    \n    vec3 o = vec3(sin(p.x*2. + iTime*2.),cos(p.z*10. + iTime*2.),1.0)*0.1;\n\tfloat d = length(p + o)- s;\n\to = vec3(sin(p.x*3. + iTime*2.),cos(p.z*2. + iTime*2.),1.0)*0.2;\n    for(int i = 0; i < 3; i++)\n    {\n        float prism2 = length(p + o*float(i))- s;\n        d = max(d, -prism2);\n    }\n  \treturn d;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy/iResolution.xy;\n    uv = uv*2.0-1.0;\n    uv.x *= iResolution.x/iResolution.y;\n    \n    vec3 dir = normalize(vec3(uv, 1.0))*rotateYmat(iTime)*rotateXmat(iTime);\n    \n    float t = 0.0;\n\tvec3 p;\n    vec3 fc; \n        vec3 o = vec3(0.,0.,-4.)*rotateYmat(iTime)*rotateXmat(iTime);\n        vec4 s = texture (iChannel0,vec2(fragCoord.x/iResolution.x-0.01, 0.75));\n\t\tvec3 cl = vec3(.5 + sin(uv.x+iTime +s.x*5.)*.4,.5 +cos(uv.y+iTime + s.x*5.)*.5,.5);\n        for (int k = 0; k <15; k++)\n        {\n            p = o + t*dir;\n            float d = sdSphere(p, 2.0);\n           \n            {\n                vec3 position = p;\n                float radius = 0.1+float(k)*0.5+clamp(s.x, 0.0, 1.0)*1.;        \n                float lineThickness = 0.02 + float(k)*0.01;\n\n                vec3 o = vec3(sin(position.x*10. + iTime*0.9),sin(position.y*10. + iTime ),cos(position.z*10. + iTime*1.9))*0.5;\n                float condition = step(length(position + o) , radius)\n                                      - step(length(position + o), radius - lineThickness);\n                fc += cl*condition;\n            }\n            \n            t += d;\n        }\n    fragColor = min(vec4(fc+cl*vec3(1.0/(1.0+t*t*0.1)), 1.0), vec4(1.0));  \n}", "image_inputs": [{"id": "4sXGzn", "previewfilepath": "/media/ap/a6a1cf7a09adfed8c362492c88c30d74fb3d2f4f7ba180ba34b98556660fada1.mp3", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/a6a1cf7a09adfed8c362492c88c30d74fb3d2f4f7ba180ba34b98556660fada1.mp3", "ctype": "music"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/Mst3Wl.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "MsVGWz", "name": "Pickover Mandelbrot", "author": "Justaway", "description": "A Mandelbrot set rendered using Pickover stalks.  Use mouse to move view.\nMore info here:\nhttps://en.wikipedia.org/wiki/Pickover_stalk", "tags": ["mandelbrotfractalpickover"], "likes": 0, "viewed": 158, "date": "1454097800", "time_retrieved": "2024-06-20T18:30:47.116921", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 c = fragCoord.xy / iResolution.xy - vec2(0.5);\n    \n    if(iMouse.x == 0.0 && iMouse.y == 0.0)\n    {\n        c += vec2(sin(iTime/10.0), cos(iTime/10.0)) * 1.5;\n    }\n    else\n    {\n        c += (iMouse.xy / iResolution.xy - vec2(0.5)) * 7.0;\n    }\n    \n    c *= 0.5;\n    \n    vec2 z = vec2(0.0);\n    vec2 zn;\n    vec2 zmin = vec2(1000000.0);\n    \n    for(int i = 0; i < 64; i++)\n    {\n        zn.x = z.x * z.x - z.y * z.y + c.x;\n        zn.y = 2.0 * z.x * z.y + c.y;\n        z = zn;\n        zmin = min(zmin, abs(zn));\n    }\n    \n    float near = min(zmin.x, zmin.y) * 2.0;\n    \n\tfragColor = vec4(\n        sin(near - 1.0),\n        sin(near + 0.2),\n        sin(near + 0.8),\n        1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/MsVGWz.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "MsyGDh", "name": "fishing village v2", "author": "ejang", "description": " I used this image as a reference: http://pre03.deviantart.net/35e5/th/pre/f/2016/003/6/e/fishing_village_by_artofchirag-d9mknu3\nThis is the same as my previous shader https://www.shadertoy.com/view/4dVGzD, but with some extra features and optimizations.", "tags": ["procedural", "raymarching", "terrain", "settlement"], "likes": 50, "viewed": 3062, "date": "1454219020", "time_retrieved": "2024-06-20T18:30:50.032219", "image_code": "// Eric Jang (c) 2016\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n\n#define clamp01(a) clamp(a,0.0,1.0)\n#define opS(d1,d2) max(-d1,d2)\n// union 2 objects carrying material info\n#define opU(a,b) ((a.x < b.x) ? a : b) \n\n#define PI 3.14159\n#define BOAT_SPEED .4\n//#define disable_village 1\n\n// rendering docks is slow. Think of better way to do this.\n//#define DOCKS 1\n\n#define WOOD_MAT 0.\n#define STRAW_MAT 1.\n#define VILLAGE_MAT 2.\n#define DOCKS_MAT 3.\n#define DUDE_MAT 4.\n#define FISH_MAT 5.\n\n#define ID_NONE -1\n#define ID_SKY 0\n#define ID_WATER 1\n#define ID_MOUNTAIN 2\n#define ID_VILLAGE 3\n\nvec3 sun_dir=normalize(vec3(0.18,0.1,1.));\n\nfloat boat_dx;\n#define START_POS vec3(7.,0.,7.6)\n\n// hash maps sequences to random-ish values\nfloat hash(float u)\n{\n    float f=u*13.1;\n    return fract(sin(f)*134735.3);\n}\n\nfloat Hash2d(vec2 uv) { return fract(sin(uv.x + uv.y * 37.0)*104003.9); }\nvec3 hash3( float n ) { return fract(sin(vec3(n,n+1.0,n+2.0))*vec3(84.54531253,42.145259123,23.349041223));}\n\nvec3 rX(const in vec3 v, const in float cs, const in float sn) {return mat3(1.0,0.0,0.0,0.0,cs,sn,0.0,-sn,cs)*v;}\nvec3 rY(const in vec3 v, const in float cs, const in float sn) {return mat3(cs,0.0,-sn,0.0,1.0,0.0,sn,0.0,cs)*v;}\nvec3 rZ(const in vec3 v, const in float cs, const in float sn) {return mat3(cs,sn,0.0,-sn,cs,0.0,0.0,0.0,1.0)*v;}\n\n// modeling functions\nfloat smin( float a, float b, float k )\n{\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\nfloat sdSphere( vec3 p, float s )\n{\n  return length(p)-s;\n}\n\nfloat sdCappedCylinder( vec3 p, vec2 h )// h = radius, height\n{\n  vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat dPlane(in vec3 ro, in vec3 rd)\n{\n    vec3 p0=vec3(0.);\n    vec3 n=vec3(0.,1.,0.);\n    return dot(p0-ro,n)/dot(rd,n);\n}\n\nfloat udRoundBox( vec3 p, vec3 b, float r )\n{\n  return length(max(abs(p)-b,0.0))-r;\n}\n\nfloat noise2d(vec2 uv)\n{\n    vec2 fr = fract(uv.xy);\n    vec2 fl = floor(uv.xy);\n    // 4 slightly different shifted versions\n    // of the same set of blocky tiles.\n    // we blend them together in x,y directions via\n    // 3 mix operations\n    // a=mix h00, h10 across x axis, \n    // b=mix h10, h11 across x axis\n    // c=mix a,b across y axis\n    // to get smooth clouds texture.\n    float h00 = Hash2d(fl);\n    float h10 = Hash2d(fl + vec2(1,0));\n    float h01 = Hash2d(fl + vec2(0,1));\n    float h11 = Hash2d(fl + vec2(1,1));\n    return mix(mix(h00, h10, fr.x), mix(h01, h11, fr.x), fr.y);\n}\n\nfloat clouds(in vec3 rd)\n{\n    vec2 p=rd.xz/rd.y; // rd.xz/rd.y scales down farther in horizon \n \tfloat n = noise2d(p*1.0); \n    n += noise2d(p*2.0)*0.5;\n    n += noise2d(p*4.0)*0.25;\n    n += noise2d(p*8.0)*0.125;\n    \n\t// n = mix(n * 0.4, n, clamp01(abs(rd.y*3.)));  // fade clouds in distance    \n    n = mix(n,0.4*n, clamp01(abs(rd.y*3.2)));  // clouds thicker farther away (personal pref)\n    return n;\n}\n\nfloat sdCappedCone( in vec3 p, in vec3 c ) // c=vec3(bottom radius, angle , height)\n{\n    vec2 q = vec2( length(p.xz), p.y );\n    vec2 v = vec2( c.z*c.y/c.x, -c.z );\n    vec2 w = v - q;\n    vec2 vv = vec2( dot(v,v), v.x*v.x );\n    vec2 qv = vec2( dot(v,w), v.x*w.x );\n    vec2 d = max(qv,0.0)*qv/vv;\n    return sqrt( dot(w,w) - max(d.x,d.y) )* sign(max(q.y*v.x-q.x*v.y,w.y));\n}\n\nfloat sdEllipsoid( in vec3 p, in vec3 r )\n{\n    return (length( p/r ) - 1.0) * min(min(r.x,r.y),r.z);\n}\n\nfloat sdTriPrism( vec3 p, vec2 h )\n{\n    vec3 q = abs(p);\n    return max(q.z-h.y,max(q.x*0.866025+p.y*0.5,-p.y)-h.x*0.5);\n}\n\nfloat sdHouse(vec3 p, vec3 i, vec3 o, float h1, float h2) \n{ \n    // implemented as the intersection of an inner\n    // udroundbox and outer udroundbox rotated 45 degrees\n    // i and o are the xyz scales, respectively.\n    // o is shifted down h units prior\n    return max(udRoundBox(p-vec3(0.,-h1,0.),i,.01),\n               udRoundBox(rZ(p-vec3(0.,-h2,0.),0.707106,0.707106),o,.01));\n}\n\nvec2 sdvillage(in vec3 p, float seed)\n{\n    vec3 R,q,q2; float d;\n    vec3 scale=vec3(.5,1.,1.);\n    \n    vec2 dm=vec2(1000.,ID_NONE);\n    for (float i=0.; i<4.; i+=1.) {\n        R=hash3(seed+i)-.5; // dx, dy, ry\n        q=p-vec3(i*3.2-R.x,R.y,-R.x);\n        // rotate\n        q=rY(q,cos(R.z),sin(R.z));\n        \n        d=sdHouse(q, vec3(1.,1.,1.), vec3(2.), -.6, 1.);\n        dm=opU(dm,vec2(d,VILLAGE_MAT));\n        \n        q.y-=1.1;\n        float roof=opS(sdTriPrism((q-vec3(0.,-.1,0.))*scale,vec2(.8,1.4)),\n                       sdTriPrism(q*scale,vec2(.8,1.3)));\n        dm=opU(dm,vec2(roof,DOCKS_MAT));\n        \n        // second story\n        if (hash(seed+i)>0.3) {\n            q2=q-vec3(0.,1.,0.);\n            d=sdHouse(q2, vec3(1.,2.,1.), vec3(2.), -.6, 1.);\n            dm=opU(dm,vec2(d,VILLAGE_MAT));\n            q2.y-=1.1;\n            float roof=opS(sdTriPrism((q2-vec3(0.,-.1,0.))*scale,vec2(.8,1.4)),\n                           sdTriPrism(q2*scale,vec2(.8,1.3)));\n            dm=opU(dm,vec2(roof,DOCKS_MAT));\n        }    \n    }\n    \n    return dm;\n}\n\n// signed distance function for village\nfloat sdBoardWalk(in vec3 p, in vec2 s)\n{\n    // s = width, half length\n    float d= udRoundBox(p,vec3(s.x,0.03,s.y/2.),0.03);\n    float rx, dx, dz;\n    float l; vec3 q;\n    float k=0.;\n    for (float i=-2.; i<2.; i+=1.)\n    {\n        dz=i*s.y/4.+s.y/8.;\n        for (float j=0.; j<2.; j+=1.)\n        {\n            if (hash(k)>.05)\n            {\n               dx=(2.*j-1.)*s.x+.04;\n                q=p-vec3(dx,0.,dz);\n                rx=(Hash2d(vec2(i,j))-.5)*.4;\n                q=rX(q,cos(rx),sin(rx));\n                d=min(d,sdCappedCylinder(q,vec2(.01,.7)));\n            }\n        }\n        k+=1.;\n    }\n    return d;\n}\n\n\nvec2 sddocks(in vec3 p)\n{   \n    vec2 s=vec2(.5,2.); // .5 wide, 4. long\n    float d=10000.;\n    float t, ry;\n    float i=2.;\n\n    \n#if 0\n        t=hash(i);\n        ry=(t-.5)*.8;\n        d=min(d,sdBoardWalk(rY(p-vec3(0.,0.,i*1.5),cos(ry),sin(ry)),vec2(.5,1.7+.1*t)));\n#endif\n\treturn vec2(d,DOCKS_MAT);\n}\n\nvec2 sdboat(in vec3 p) // sanpan-style boat.\n{\n    // wood stuff\n    // hull\n    vec3 q=rZ(p,cos(.03),sin(.03));\n    float d=sdTriPrism((q-vec3(0.,-1.2,0.))*vec3(1.,-1.,1.),vec2(3.,.5)); // size, z-thickness\n    \n    vec2 offset=vec2(0.2,14.6);\n    float cylinder= length(q.xy-offset)-14.5;\n    d=opS(cylinder,d);\n    \n    float inner=udRoundBox(q-vec3(0.,0.3,0.),vec3(2.4,.2,.4),.03);\n    d=opS(inner,d);\n    \n    // dude\n   q=p-vec3(1.8,0.,0.2);\n   float d2=sdSphere(q-vec3(0.,1.04,0.),.15); \n   \n   float torso=sdEllipsoid( q-vec3(0.11,0.62,0.),vec3(.07,.2,.14) );\n   torso=smin(torso,sdEllipsoid(q-vec3(0.05,0.45,0.),vec3(.09,.1,.15)),.12);\n   d2=smin(d2,torso,.1);\n   float legs=sdEllipsoid(q-vec3(0.11,0.14,.08), vec3(.03,.1,.03));\n    legs=min(sdEllipsoid(q-vec3(0.11,0.14,-.08), vec3(.03,.1,.03)),legs);    \n   d2=smin(legs,d2,.1);\n\n    // pole\n#if 1\n   float pole=sdCappedCylinder(rZ(q-vec3(1.2,0.,0.16),cos(-1.),sin(-1.)),vec2(.02,2.4));\n\td=min(d,pole);\n#endif\n    \n    // straw stuff\n    // roof\n   vec3 q1=p-vec3(-0.5,0.,0.);\n   \n   float roof=opS(\n   \tsdCappedCylinder(q1.yxz,vec2(.48,.9)),\n   \tsdCappedCylinder(q1.yxz,vec2(.5,.8 ))\n   );\n   q1.x-=0.6;\t\n   q1=rZ(q1,cos(.05),sin(.05));\n   //float roof1=opS(sdCappedCylinder(q1.yxz,vec2(.51,.6)),\n   //                sdCappedCylinder(q1.yxz, vec2(.54,.5)));\n   float roof1=sdCappedCylinder(q1.yxz, vec2(.54,.5));\n   roof1=opS(udRoundBox(q1-vec3(0.,-.85,0.),vec3(1.),0.01),roof1);\n   roof=min(roof,roof1);\n    \n   // hat\n   vec3 q2=rX(q-vec3(0.,1.25,0.), cos(.1), sin(.1));\n   float hat=sdCappedCone(q2,vec3(.2,.4,.18));\n    \n\n   vec2 dude=vec2(d2,DUDE_MAT);\n   vec2 wood=vec2(d,WOOD_MAT);\n   vec2 straw=vec2(min(hat,roof),STRAW_MAT);\n   vec2 tm=opU(dude,opU(wood,straw));\n    \n#if 1\n   // fish (q3 is fish coordinates)\n   float fs=1000.; float f; vec3 q3;\n   for (float i=0.; i<3.; i+=1.) {\n   \tq3=p-vec3(-1.6,0.15,-.2+i*.25);\n    f=sdEllipsoid(q3,vec3(.3,.05,.15));\n   \tfs=min(f,fs);\n   }\n   \n    vec2 fish=vec2(fs,FISH_MAT);    \n    tm=opU(fish,tm);\n#endif\n    \n    return tm;\n   \t\n    \n}\n\nvec2 scene(in vec3 p)\n{    \n#ifdef disable_village\n    return vec2(10000.,ID_NONE);\n#endif\n    // houses\n\tvec2 v1= sdvillage(rY(p-vec3(-2.,1.,20.),cos(-2.),sin(-2.)),0.);\n    vec2 v2= sdvillage(rY(p-vec3(16.,.5,25.),cos(2.),sin(2.)),221.);\n    vec2 tm=opU(v1,v2);\n    \n#ifdef DOCKS\n    // docks\n    float ry=1.2;\n    vec3 q1=rY(p-vec3(-1.4,0.3,7.),cos(ry),sin(ry));\n  \tvec2 docks=sddocks(q1);\n    tm=opU(docks,tm); \n#endif\n    \n    // boat\n    vec3 q2=rY(p-START_POS,cos(.3),sin(.3))-vec3(boat_dx,0.,0.); // boat coordinates\n\tvec2 boat= sdboat(q2);\n    \n    return opU(tm,boat);\n}\n\nvec3 calcNormal( in vec3 p )\n{\n    vec3 e = vec3( 0.001, 0.0, 0.0 );\n    vec3 n = vec3(\n        scene(p+e.xyy).x - scene(p-e.xyy).x,\n        scene(p+e.yxy).x - scene(p-e.yxy).x,\n        scene(p+e.yyx).x - scene(p-e.yyx).x);\n    return normalize(n);\n}\n\nvec3 background(in vec3 rd)\n{\n        vec3 col;\n    \n    // skycol fades into horizoncol closer to horizon\n    vec3 skyCol = vec3( 0.49, 0.352, 0.294);\n    vec3 horizonCol = vec3(0.866667, 0.47451, 0.270588);\n    col=skyCol;\n    col=mix(horizonCol,skyCol,clamp01(rd.y)*7.);\n    \n    // sunlight\n    float sunlight=clamp01(pow(dot(rd,sun_dir),4.));\n    \n    // add sun\n    //float sundot = smoothstep(.996,.999,sunlight);\n    float sundot=1.-smoothstep(0.03,0.06,length(rd-sun_dir));\n    col+=sundot*vec3(1.0,0.913725,0.458824);\n    \n    // clouds\n    vec3 cloudcol=vec3( 0.623529,  0.298039,  0.164706)*1.5;\n\n    //return cloudcol*sunlight;\n    //col=vec3(clouds(rd));\n    //col=mix(col,cloudcol*sunlight,clouds(rd));\n    col=mix(col,cloudcol,clouds(rd));\n    return clamp01(col);  \n    \n #if 0\n    \n    vec3 col=vec3( 0.49, 0.352, 0.294); // sky color\n    // add sun\n    float sundot=1.-smoothstep(0.03,0.06,length(rd-sun_dir));\n    col+=sundot*vec3(1.0,0.913725,0.458824);\n   \n    // clouds\n    \n    vec3 cloudcol=vec3(0.772549, 0.388235, 0.211765);\n    col=mix(col,cloudcol*sunlight,clouds(rd));\n    \n    return col;\n#endif\n}\n\n// FBM loop is inlined via macro\n#define F (texture(iChannel0,p*s/1e3)/(s+=s)).x\nfloat fbm(in vec2 p, in float s) { return F+F+F; }\n\nvec3 cheapFog(in vec3 ro, in vec3 rd, in vec3 bgc, in vec3 p)\n{\n  float xscale=sqrt(clamp01(.8-abs(rd.x-.2))); // denser in valley\n  float yscale=clamp01(1.-p.y*.02); // denser closer to ground\n  float zscale=clamp01(sqrt(p.z*.01));// gets denser as we go farther out\n  float n=clamp01(fbm(p.xy+iTime*4.,.1));\n  float fog=xscale*yscale*zscale*n;\n  //return vec3(fog);\n  // lighting\n  float sunlight=clamp01(pow(dot(rd,sun_dir),4.));\n  vec3 fogc=mix(vec3(1.),vec3(0.843137,0.461373,0.247059),sunlight);\n  // TODO - fog has to get lighting from sun.\n  return mix(bgc,fogc,fog);\n  //return mix(bgc,,fog);\n}\n\nfloat watermap( in vec2 p ) { // -.04,.2 controls water flow in XZ plane\n\treturn fbm((p-iTime*vec2(-.04,.2))*10.,.5);\n}\n\nvec3 shade(vec3 p, float m)\n{\n    vec3 n=calcNormal(p);\n   \tvec3 sun_dir=normalize(vec3(-0.28,3.,1.));\n    vec3 col;\n    vec3 q2=rY(p-START_POS,cos(.3),sin(.3))-vec3(boat_dx,0.,0.); // boat coordinates\n\tif (m==WOOD_MAT) {\n        col=vec3(0.152941,0.0627451,0.0392157);\n    }\n    else if (m==DOCKS_MAT) {\n        vec3 wood1=vec3(0.36, 0.275, 0.1625);\n        vec3 wood2=vec3(0.152941,0.0627451,0.0392157);\n        col=mix(wood1,wood2,Hash2d(floor(p.xz*vec2(4.,1.))));   \n    }\n    else if (m==STRAW_MAT) {\n        \n        vec4 t=texture(iChannel1,q2.xz/2.);\n        col=t.xyz;\n    } else if (m==DUDE_MAT) {\n        vec3 fleshcol=vec3(0.909804,  0.713725,  0.541176);\n        vec3 pantscol=vec3(0.266667,  0.376471,  0.509804);\n        col=mix(pantscol,fleshcol,smoothstep(.4,.45,q2.y));\n    } else if (m==VILLAGE_MAT) {\n        col=vec3(0.152941,0.0627451,0.0392157)*.1;\n        // add windows\n        vec3 wcol1=vec3(0.972549, 0.294118, 0.137255);\n        vec3 wcol2=vec3( 1.0,0.709804,0.415686);\n        \n        vec4 t=texture(iChannel1,.2+p.xy*vec2(.15,.05));\n        //return vec3(1.-t.x*t.y);\n        float w1=smoothstep(0.7,.8,1.-t.x); // cooler orange glow\n        float w2=smoothstep(0.8,0.9,1.-t.x); // hotter yellow light\n        //return vec3(w2);\n        // skip phong lighting and go straight to color\n        return mix(col,mix(wcol1,wcol2,w2*w1),pow(w1,.2));\n    } else if (m==FISH_MAT) {\n        float shine=pow(smoothstep(.8,.99,dot(n,vec3(0.,.98,.2))),6.);\n        col=mix(vec3( 0.459, 0.482, 0.514),vec3( 0.870588, 0.819608, 0.760784),shine);\n        //col=vec3(pow(smooths(dot(n,vec3(0.,1.,0.))),4.));\n    }\n    \n    col*=1.1*clamp01( dot( n, sun_dir ) ); // phong lighting   \n    return col;\n}\n\n// render subcall (for water refl). returns object id and color.\n// this does shading calculations.\nint trace(in vec3 ro, in vec3 rd, out vec3 col, out vec3 p)\n{\n    int obj=ID_SKY;   \n    col=background(rd); // default color = sky\n    \n    // mountains\n    // exponential jump + binary search refinement\n    float h; float h2;\n\tfloat t=0.;\n    float jump;\n    for (int i=0; i<100; i++) {\n        jump=0.05*t+0.1;\n        t+=jump;\n        p=ro+t*rd;\n        \n        // foreground mountains\n        float vwidth=0.7;// valley width\n        float xscale=abs(rd.x-.2)*2.; // valley centered around sun\n\t\tfloat zscale=abs(p.z)/15.; // river gets wider closer to camera        \n        h=fbm(p.xz*3.,.3)*xscale*zscale-.25;\n        \n        // background mountains\n        float zscale2=p.z/20.-.7; // only show up in background\n        vec4 tex=texture(iChannel2,p.xz/140.);\n        h2=((tex.x-.4)*zscale2*max(xscale+.15,0.)-.2)*30.;\n        \n        // binary search refinement\n        if (p.y <h || p.y<h2) {\n            for (int j=0; j<5; j++) {\n                float dir=(p.y<h || p.y<h2) ? -1. : 1.;\n                jump*=.5;\n                t+=dir*jump;\n                p=ro+t*rd;\n            }\n        }\n        \n        if (p.y<h) {\n            col=vec3(0.180392, 0.0745098, 0.031372)*2.*(1.-sqrt(h));\n            obj=ID_MOUNTAIN;\n           break;\n        } else if (p.y < h2) {\n            col=mix(vec3(0.180392, 0.0745098, 0.031372)*.5,vec3(0.72549,  0.392157,  0.231373)*.8,t/300.);\n            obj=ID_MOUNTAIN;\n            break;\n        } else if (p.y<0.){\n            obj=ID_NONE;\n        }\n    }\n    \n    // trace village\n    t=0.1;\n    vec2 dm;\n    vec3 p2;\n    for (int i=0; i<40; i++)\n    {\n        p2=ro+rd*t;\n        dm=scene(p2);\n        if (dm.x<0.01 || t>500.) break;\n        t+=dm.x;\n    }\n   \tif (t<1000. && t<length(p-ro))\n    {\n        p=p2;\n        col=shade(p2,dm.y);\n    \tobj=ID_VILLAGE;\n    }\n    // is water\n    if (p.y<0. && p2.y<0.){\n        obj=ID_NONE;\n    }\n    \n\treturn obj;\n}\n\n#define BUMP 0.1\n// dx,dz control turbulence of normal displacement for reflection\n#define dx vec2(.1,0.)\n#define dz vec2(0.,.1)\nvec3 render(in vec3 ro, in vec3 rd)\n{\n    vec3 p; float d;\n    vec3 col=vec3(0.);\n    \n  \t// intersect foreground\n    int obj=trace(ro,rd,col,p);\n    vec3 p2;\n\n    if (obj==ID_NONE) { // we must have hit water == ID_NONE   \n        d=dPlane(ro,rd);\n        float fresnel;// bool refl;\n        p=ro+d*rd;\n        vec3 n=normalize(vec3(\n            -BUMP*(watermap(p.xz+dx)-watermap(p.xz-dx))/(2.*BUMP), // central difference approximation of normal\n            1.,\n            -BUMP*(watermap(p.xz+dz)-watermap(p.xz-dz))/(2.*BUMP)\n        ));\n        fresnel = pow(1.0-abs(dot(n,rd)),5.);\n        rd = reflect( rd, n);\n        ro=p;\n        trace(ro,rd,col,p2);    \n        vec3 watercol=vec3( 0.439216  ,0.270588 , 0.203922);\n        col=mix(col,watercol,1.-fresnel);\n    }\n    \n    col=cheapFog(ro,rd,clamp01(col),p);\n\treturn col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    boat_dx=-mod(iTime*BOAT_SPEED+5.8,25.);\n\n    // alternate animation - boat sailing down the river\n    //ry=-1.7+sin(iTime)*.01;\n    //vec3 q2=rY(p-vec3(3.,0.,1.4),cos(ry),sin(ry))-vec3(-mod(iTime*BOAT_SPEED+8.,50.),0.,0.);\n    vec2  p = (-iResolution.xy+2.0*fragCoord.xy)/iResolution.y; // x=(-1.5,1.5), y=(1,1)\n    \n    vec3 ro=vec3(0.,1.5,0.); // eye location\n    vec3 ta=vec3(0.,3.,20.); // look location\n    vec3 up = vec3( 0.0, 1.0, 0.0 ); // up axis of world\n    float d = 2.5; // distance between eye and film plane\n    \n    // build ray\n    vec3 ww = normalize( ta - ro); // film plane normal\n    vec3 uu = normalize(cross( up, ww )); // horizontal axis of film plane\n    vec3 vv = normalize(cross(ww,uu)); // vertical axis of film plane\n    vec3 rd = normalize( p.x*uu + p.y*vv + d*ww );\n    \n    vec3 col=render(ro,rd);\n    \n    // vignette\n    vec2 q = fragCoord.xy/iResolution.xy;\n    col *= 0.5 + 0.5*pow(20.0*q.x*q.y*(1.0-q.x)*(1.0-q.y),0.4);\n\n    fragColor=vec4(col,1.); \n}\n", "image_inputs": [{"id": "4dX3Rn", "previewfilepath": "/media/ap/bd6464771e47eed832c5eb2cd85cdc0bfc697786b903bfd30f890f9d4fc36657.jpg", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/bd6464771e47eed832c5eb2cd85cdc0bfc697786b903bfd30f890f9d4fc36657.jpg", "ctype": "texture"}, {"id": "XsX3Rn", "previewfilepath": "/media/ap/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg", "ctype": "texture"}, {"id": "4sf3Rr", "previewfilepath": "/media/ap/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc-by-nc-sa-2.0", "thumbnail": "https://www.shadertoy.com/media/shaders/MsyGDh.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "MsyGzw", "name": "Trellis Fractal", "author": "unconed", "description": "Two long boxes folded with mandelbox-like inversions.", "tags": ["raymarching", "hybridfractal"], "likes": 22, "viewed": 1076, "date": "1453695132", "time_retrieved": "2024-06-20T18:30:50.977742", "image_code": "vec4 fold1(vec4 z) {\n    vec3 p = z.xyz;\n    p = p - 2.0 * clamp(p, -1.0, 1.0);\n    return vec4(p, z.w);\n}\n\nvec4 fold2(vec4 z) {\n    vec3 p = z.xyz;\n    p = p - 2.0 * clamp(p, -1.0, 1.0);\n    return vec4(p * 2.0, 2.0 * z.w);\n}\n\nvec4 invertRadius(vec4 z, float radius2, float limit) {\n  float r2 = dot(z.xyz, z.xyz);\n  float f = clamp(radius2 / r2, 1., limit);\n  return z * f;\n}\n\nvec4 affine(vec4 z, float factor, vec3 offset) {\n  z.xyz *= factor;\n  z.xyz += offset;\n  z.w *= abs(factor);\n  return z;\n}\n\nvec4 mandel(vec4 z, vec3 offset) {\n  float x = z.x;\n  float y = z.y;\n\n  z.w = 2. * length(z.xy) * z.w + 1.;\n\n  z.x = x*x - y*y + offset.x;\n  z.y = 2.*x*y + offset.y;\n\n  return z;\n}\n\nvec4 invert(vec4 z, float factor) {\n  float r2 = dot(z.xyz, z.xyz);\n  float f = factor / r2;\n  return z * f;\n}\n\nvec4 rotateXY(vec4 z, float angle) {\n  float c = cos(angle);\n  float s = sin(angle);\n  mat2 m = mat2(c, s, -s, c);\n  return vec4(m * z.xy, z.zw);\n}\n\nvec4 rotateXZ(vec4 z, float angle) {\n  float c = cos(angle);\n  float s = sin(angle);\n  mat2 m = mat2(c, s, -s, c);\n  vec2 r = m * z.xz;\n  return vec4(r.x, z.y, r.y, z.w);\n}\n\nvec4 shiftXY(vec4 z, float angle, float radius) {\n  float c = cos(angle);\n  float s = sin(angle);\n  return vec4(vec2(c, s) * radius + z.xy, z.zw);\n}\n\nfloat surface = 0.0;\nfloat sdf(vec3 p) {\n    //vec3 pmod = mod(p + 2.0, 4.0) - 2.0;\n    vec4 z = vec4(p, 1.0);\n    \n    float t = iTime * .2;\n\n    vec3 vo1 = vec3(sin(t * .1), cos(t * .0961), sin(t * .017)) * 1.1;\n    vec3 vo2 = vec3(cos(t * .07), sin(t * .0533), sin(t * .138)) * 1.1;\n    vec3 vo3 = vec3(sin(t * .031), sin(t * .0449), cos(t * .201)) * 1.1;\n    \n    z = invertRadius(z, 10.0, 1.5);\n    z = invertRadius(z, 10.0*10.0, 2.0);\n    z = rotateXY(z, t);\n    z = fold1(z);\n    z = rotateXZ(z, t * 1.112);\n    z.xyz += vo3;\n    z = fold2(z);\n    z.xyz += vo1;\n    z = affine(z, -1.5, p);\n    z = invertRadius(z, 4.0*4.0, 2.0);\n    z = affine(z, -1.5, p);\n    z = rotateXY(z, t * .881);\n    z = fold1(z);\n    z = rotateXZ(z, t * .783);\n    z = fold1(z);\n    z = affine(z, -1.5, p);\n    z = invertRadius(z, 10.0*10.0, 3.0);\n    z = fold1(z);\n    z = fold1(z);\n    z = affine(z, -1.5, p);\n    z = invertRadius(z, 10.0*10.0, 2.0);\n\n\n    vec3 po = vec3(0.0, 0.0, 0.0);\n\n    vec3 box = abs(z.xyz);\n    float d1 = (max(box.x - 2.0, max(box.y - 2.0, box.z - 10.0))) / z.w;\n    float d2 = (max(box.x - 20.0, max(box.y - .5, box.z - .5))) / z.w;\n\t\n    float d3 = min(d1, d2);\n    if (d2 == d3) {\n      surface = 1.0;\n    }\n    else {\n      surface = 0.0;\n    }\n    return d3;\n}\n\nvec3 normal(vec3 p) {\n\tvec2 e = vec2(.0001, 0.0);\n    float f = sdf(p);\n    return normalize(vec3(\n        sdf(p + e.xyy) - f,\n        sdf(p + e.yxy) - f,\n        sdf(p + e.yyx) - f\n    ));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 xy = (uv * 2.0 - 1.0) * vec2(iResolution.x / iResolution.y, 1.0);\n\n    vec3 color = vec3(.03, .02, .02) * (1.5 - uv.y);\n\n    vec3 light = vec3(.577);\n    float angle = 1.0-iMouse.x * .005;   \n    float c = cos(angle);\n    float s = sin(angle);\n    mat3 camera = mat3(\n        c,  0.0, -s,\n         0.0,  1.0, 0.0,\n        s,  0.0, c//,\n\t);\n    float fov = .5;\n\n    vec3 rd = camera * normalize(vec3(xy * fov,-1.0));\n    vec3 ro = vec3(s,0.0,c)*6.0;\n    \n    float tmax = 100.0;\n    float dmin = .001;\n    float t = 0.0;\n    float d = sdf(ro);\n    if (d < 0.0) rd = -rd;\n    for (int i = 0; i < 96; ++i) {\n        vec3 p = ro + rd * t;\n        d = sdf(p);\n        t += d;\n        if (t > tmax || d < dmin) break;\n    }\n\n    vec3 p = ro + rd * t;\n    vec3 n = normal(p);\n    if (t < tmax && d < dmin) {\n      vec3 albedo = mix(vec3(.02, .1, 1.0), vec3(1.0), surface);\n  \t  float diffuse = clamp(dot(n, light), 0.0, 1.0);\n      \n      float ao = 0.0;\n      float am = 0.0;\n      float step = .05;\n      vec3 pa = p;\n      for (int i = 0; i < 8; ++i) {\n          pa += n * step;\n          am += step;\n          ao += max(0.0, sdf(pa) / am);\n          step += .05;\n      }\n      \n      t = .1;\n      float shadow = 1.0;\n      if (diffuse > 0.0) {\n        for (int i = 0; i < 24; ++i) {\n          vec3 pb = p + light * t;\n          d = sdf(pb);\n          t += d;\n          if (d < 0.0) break;\n        }\n        \n        shadow = clamp(d, 0.0, 1.0);\n        diffuse *= shadow;\n      }\n        \n      ao = ao / 8.0;\n      float ambient = 0.08;\n\n      vec3 sun = vec3(1.0, 1.0, .85);\n      vec3 sky = vec3(1.0, .5, .5);\n      color = 6.0 * vec3(mix(sun * diffuse, sky, ambient) * ao * ao * albedo * 5.0);\n      color = color/(1.0+color);\n    }\n    \n\tfragColor = vec4(sqrt(color),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/MsyGzw.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "MtfGzX", "name": "Reactive Audio March", "author": "StanRee", "description": "More fun marching into textures\n\nFeat. beats by SWEEDIN\nhttps://soundcloud.com/sethweedin/break-of-day", "tags": ["raymarching", "music", "visualizer", "mountains", "hueshift", "soundcloud"], "likes": 1, "viewed": 606, "date": "1453181544", "time_retrieved": "2024-06-20T18:30:50.977742", "image_code": "// [2TC 15] Mystery Mountains.\n// Fractal mountains in 280 chars.\n// Original by Dave Hoskins. : https://www.shadertoy.com/view/llsGW7#\nvec3 HUEtoRGBZ(vec3 H)\n  {\n    float R = (abs(H * 6. - 3.) - 1.).r;\n    float G = (2. - abs(H * 6. - 2.)).g;\n    float B = (2. - abs(H * 6. - 4.)).r;\n    return clamp(vec3(R,G,B), 0., 1.);\n  }\n\nvec3 HUEtoRGB(vec3 c)\n{\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\n#define F t+=texture(iChannel0,.3+p.xw*s/6e3,-99.)/s;s+=s;\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float T = iTime; \n    //vec4 p=fragCoord/(vec4(iResolution.xyz, iResolution.x))-.5);\n    vec4 p; \n  \tp.x = fragCoord.x/iResolution.x - .5; \n    p.y = fragCoord.y/iResolution.y - .5; \n    p.z = 0.0;\n        p.w = 1.0;\n    \n    vec4 d=p*1.0;\n    vec4 t;\n    p.w += iTime*20.;\n    d.y-=.1;//camera adjustment down\n    d.x-=.1;\n    \n    vec4 color; \n    \n    for(float i=1.0;i>=0.;i-=.02)\n    {\n        float s=1.5;\n        t = d - d; \n        \n        float uvXscaler = 5.; \n        t += (1.0 - texture(iChannel0,vec2(uvXscaler*p.x*s/60000. + .5, 0.0)).r/s) - .7 ;    \n        t += texture(iChannel0,vec2(uvXscaler*p.x*s/6000. + .5, 0.0)).r/s  ;\n        \n        \n         \n       // s+=s;\n        \n      //  t+=texture(iChannel1,p.xw*s/6e3,-99.)/s;\n        \n        t+=texture(iChannel1,p.xw*s/6e3);\n        //s+=s;\n\n\n\t\tcolor = vec4(0,0,0,0)*.1+d.x+t*i;\n        \n        float height = 4.0;//sin(T)*.01 + .7; \n        float yscaler = .0095;// (sin(T*10.)+3.)*.5*.01;\n        \n        if(t.x>p.y*yscaler*(abs(.00500*p.x))*abs(sin(iTime)*.3 + 1.) + height)break;\n        p += d * 100.0 ;//iTime - 1800.;\n    } \n    \n    color = vec4(dot(color.xyz,vec3(0.5,0.0,0.5)) * HUEtoRGB(vec3(p.x*p.y*0., 1.0 - color.r, 1.0 - color.y)), 1.0);\n    \n    if(t.x > 2.0)\n        t *= 0.0; \n    \n   // vec4( HUEtoRGB(vec3(0.0, 0.0, 1.0)), 1.0);\n    fragColor = abs(t.r - t.w*0.2 + 0.*t.w)*vec4( HUEtoRGB(vec3(iTime*0.0001+ p.y*.001, 1.0 - color.x, 1.0 - color.y)), 1.0);\n    \n    \n}\n", "image_inputs": [{"id": "XsX3Rn", "previewfilepath": "/media/ap/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg", "ctype": "texture"}, {"id": "Xss3W8", "previewfilepath": "https://soundcloud.com/sethweedin/break-of-day", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "https://soundcloud.com/sethweedin/break-of-day", "ctype": "musicstream"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/MtfGzX.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "Xdc3Wl", "name": "Simple Ripple on Texture", "author": "azakhary", "description": "This is the simplest ripple from mouse coordinates performed on a texture", "tags": ["ripple"], "likes": 7, "viewed": 718, "date": "1452620849", "time_retrieved": "2024-06-20T18:30:51.177889", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    vec2 position = ( fragCoord.xy / iResolution.xy );\n\t\n\tposition.x = position.x * 1.7;\n\t\n\tvec2 mouse = iMouse.xy / iResolution.xy;\n\t\n\tmouse.x = mouse.x * 1.7;\n\t\n\tfloat radius = 1.25*iTime;\n\t\n\tfloat posDist = distance(position, mouse);\n\t\n\tfloat dist2 = 5.0*abs(radius - posDist);\n\t\n\tfloat distort = 1.0-(sin(dist2)+1.0)/2.0;\n    \n    vec2 samplePos = fragCoord/iResolution.y;\n    \n    samplePos= samplePos * distort;\n    \n    vec4 color = texture(iChannel0, samplePos);\n    \n    vec4 tint = vec4(0.5, 0.8, 0.9, 1);\n    \n    tint = tint * (1.0 - distort);\n    \n    color = color + tint/2.0;\n       \n\tfragColor = color;\n}", "image_inputs": [{"id": "4sXGzn", "previewfilepath": "/media/ap/a6a1cf7a09adfed8c362492c88c30d74fb3d2f4f7ba180ba34b98556660fada1.mp3", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/a6a1cf7a09adfed8c362492c88c30d74fb3d2f4f7ba180ba34b98556660fada1.mp3", "ctype": "music"}, {"id": "4sf3Rr", "previewfilepath": "/media/ap/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/Xdc3Wl.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "Xdc3Ws", "name": "Rectangle Parallel Projection", "author": "paniq", "description": "Analytic projection of arbitrary oriented and sized rectangle to arbitrarily oriented line; I assume the 3D case is similar", "tags": ["projection", "rectangle", "planar"], "likes": 2, "viewed": 647, "date": "1452652155", "time_retrieved": "2024-06-20T18:30:51.432480", "image_code": "\n#define time iTime\n#define resolution iResolution\n\nvec2 anglevector (float r) {\n\treturn vec2(cos(r), sin(r));\n}\n\nfloat cube (vec2 p, vec2 r) {\n\treturn max(abs(p.x) - r.x, abs(p.y) - r.y);\n}\n\nvec3 dist2color (float d) {\n    return abs((mod(abs(d),0.1)/0.1)-0.5)/0.5 * mix(vec3(1.0,0.0,0.0),vec3(0.0,1.0,0.0),step(0.0,d));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 position = fragCoord.xy / resolution.xy * 2.0 - 1.0;\n\tposition.x *= resolution.x / resolution.y;\n\n\tposition *= 4.0;\n\t\n\tvec2 offs = anglevector(time) * 1.0;\n\tvec2 hsize = vec2(0.5,1.0);\n    vec2 vsize = vec2(2.0,0.25);\n\t\n    vec2 cp = position - offs;\n\tfloat d = cube(cp, hsize);\n    d = min(d, cube(cp, vsize));\n\t\n\tvec2 pl = anglevector(time * 0.1);\n\tfloat pd = dot(pl, position);\n    \n        vec2 bcp = pl.yx;\n\t\tvec2 bb = bcp * hsize;\n\t\tfloat dmin = (abs(bb.x) + abs(bb.y));\n        vec2 bb2 = bcp * vsize;\n        dmin = max(dmin, (abs(bb2.x) + abs(bb2.y)));\n\t\tvec2 pp = vec2(pl.y, -pl.x);\n\t\tfloat planed = dot(pp, position - offs);\n\t\tfloat d2 = abs(planed) - dmin;\n    \n    vec3 c0 = dist2color(d);\n    vec3 c1 = dist2color(d2);\n    \n\t\n\tfragColor = vec4(max(c0, c1), 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/Xdc3Ws.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "Xdc3WX", "name": "Loading circle...", "author": "Tetane", "description": "Please wait while the shader is loading...", "tags": ["circle", "loading", "dots"], "likes": 10, "viewed": 426, "date": "1452355475", "time_retrieved": "2024-06-20T18:30:51.432480", "image_code": "#define PI 3.14159265\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tfloat time = iTime;\n\tfloat mx = max(iResolution.x, iResolution.y);\n\tvec2 scrs = iResolution.xy/mx;\n\tvec2 uv = vec2(fragCoord.x, iResolution.y-fragCoord.y)/mx;\n\tvec2 m = vec2(iMouse.x/mx,scrs.y-iMouse.y/mx);\n    \n    \n    vec3 col = vec3(0.0);\n    float x,y = 0.0;\n\tfloat radius = 0.02;\n\tconst float dotsnb = 10.0;\n\n\tfor(float i = 0.0 ; i < dotsnb ; i++){\n\t\tx = 0.1*cos(2.0*PI*i/dotsnb+time*(i+3.0)/3.0);\n\t\ty = 0.1*sin(2.0*PI*i/dotsnb+time*(i+3.0)/3.0);\n\n\t\tcol += vec3(smoothstep(radius, radius-0.01, distance(uv, scrs/2.0 + vec2(x,y)) ) * (sin(i/dotsnb+time+2.0*PI/3.0)+1.0)/2.0,\n\t\t\t\t\tsmoothstep(radius, radius-0.01, distance(uv, scrs/2.0 + vec2(x,y)) ) * (sin(i/dotsnb+time+4.0*PI/3.0)+1.0)/2.0,\n\t\t\t\t\tsmoothstep(radius, radius-0.01, distance(uv, scrs/2.0 + vec2(x,y)) ) * (sin(i/dotsnb+time+6.0*PI/3.0)+1.0)/2.0);      \n\t}\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/Xdc3WX.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "XdcGWX", "name": "Everyday009 - Thinking", "author": "Makio64", "description": "Experiments tunnel effect with cheapBox. Its simple but I like the rendering :)\nAlso for unknow reason the normal map is much better at iGlobalTime+42. ( yeah 42 Oo ) ..", "tags": ["simple", "fast", "geometry", "everyday", "cheapbox"], "likes": 29, "viewed": 2522, "date": "1452338243", "time_retrieved": "2024-06-20T18:30:52.414259", "image_code": "// Everyday009 - Thinking\n// By David Ronai / @Makio64\n\n//------------------------------------------------------------------ VISUAL QUALITY\n#define POSTPROCESS\n#define RAYMARCHING_STEP 30\n#define RAYMARCHING_JUMP 1.\n//------------------------------------------------------------------ DEBUG\n//#define RENDER_DEPTH\n//#define RENDER_NORMAL\n//#define RENDER_AO\n\nconst float PI = 3.14159265359;\nfloat time = 50.;\n\n//------------------------------------------------------------------  OPERATIONS / PRIMITIVES\n//http://mercury.sexy/hg_sdf/\nvoid pR(inout vec2 p, float a) {p = cos(a)*p + sin(a)*vec2(p.y, -p.x);}\nfloat vmax(vec2 v) { return max(v.x, v.y); }\nfloat vmax(vec3 v) { return max(max(v.x, v.y), v.z); }\nfloat fBox2Cheap(vec2 p, vec2 b) {return vmax(abs(p)-b);}\nfloat fBoxCheap(vec3 p, vec3 b) { return vmax(abs(p) - b);}\nfloat pMod1(inout float p, float size) {\n\tfloat halfsize = size*0.5;\n\tfloat c = floor((p + halfsize)/size);\n\tp = mod(p + halfsize, size) - halfsize;\n\treturn c;\n}\n\n\n//------------------------------------------------------------------ MAP\nfloat map( in vec3 pos ) {\n    pos.y -= 23.;\n    pR(pos.xy,pos.z/20.-time);\n    vec3 bp = pos;\n    pMod1(bp.z,40.);\n    float b = fBoxCheap(bp,vec3(10.,10.,2.));\n    \t  b = max(b,-fBox2Cheap(pos.xy,vec2(8.+sin(pos.z/10.)))); \n\tfloat d = min(b,-fBox2Cheap(pos.xy, vec2(10.)));\n    return d;\n}\n\n//------------------------------------------------------------------ RAYMARCHING\n#ifdef RENDER_DEPTH\nfloat castRay( in vec3 ro, in vec3 rd, inout float depth )\n#else\nfloat castRay( in vec3 ro, in vec3 rd )\n#endif\n{\n\tfloat t = 0.0;\n\tfloat res;\n\tfor( int i=0; i<RAYMARCHING_STEP; i++ )\n\t{\n\t\tvec3 pos = ro+rd*t;\n\t\tres = map( pos );\n\t\tif( res < 0.01 || t > 150. ) break;\n\t\tt += res*RAYMARCHING_JUMP;\n\t\t#ifdef RENDER_DEPTH\n\t\tdepth += 1./float(RAYMARCHING_STEP);\n\t\t#endif\n\t}\n\treturn t;\n}\n\nvec3 calcNormal(vec3 p) {\n\tfloat eps = 0.0001;\n\tconst vec3 v1 = vec3( 1.0,-1.0,-1.0);\n\tconst vec3 v2 = vec3(-1.0,-1.0, 1.0);\n\tconst vec3 v3 = vec3(-1.0, 1.0,-1.0);\n\tconst vec3 v4 = vec3( 1.0, 1.0, 1.0);\n\treturn normalize( v1 * map( p + v1*eps ) +\n\t\t\t\t\t  v2 * map( p + v2*eps ) +\n\t\t\t\t\t  v3 * map( p + v3*eps ) +\n\t\t\t\t\t  v4 * map( p + v4*eps ) );\n}\n\nfloat hash( float n ){\n\treturn fract(sin(n)*3538.5453);\n}\n\nfloat calcAO( in vec3 p, in vec3 n, float maxDist, float falloff ){\n\tfloat ao = 0.0;\n\tconst int nbIte = 6;\n\tfor( int i=0; i<nbIte; i++ )\n\t{\n\t\tfloat l = hash(float(i))*maxDist;\n\t\tvec3 rd = n*l;\n\t\tao += (l - map( p + rd )) / pow(1.+l, falloff);\n\t}\n\treturn clamp( 1.-ao/float(nbIte), 0., 1.);\n}\n\n// calculate local thickness\n// base on AO but : inverse the normale & inverse the color\nfloat thickness( in vec3 p, in vec3 n, float maxDist, float falloff )\n{\n\tfloat ao = 0.0;\n\tconst int nbIte = 6;\n\tfor( int i=0; i<nbIte; i++ )\n\t{\n\t\tfloat l = hash(float(i))*maxDist;\n\t\tvec3 rd = -n*l;\n\t\tao += (l + map( p + rd )) / pow(1.+l, falloff);\n\t}\n\treturn clamp( 1.-ao/float(nbIte), 0., 1.);\n}\n\n//------------------------------------------------------------------ POSTEFFECTS\n\n#ifdef POSTPROCESS\nvec3 postEffects( in vec3 col, in vec2 uv, in float time )\n{\n\t// vigneting\n\tcol *= 0.5+0.5*pow( 16.0*uv.x*uv.y*(1.0-uv.x)*(1.0-uv.y), 0.5 );\n\treturn col;\n}\n#endif\n\nvec3 render( in vec3 ro, in vec3 rd, in vec2 uv )\n{\n\tvec3 col = vec3(.0,.0,1.2);\n\n\t#ifdef RENDER_DEPTH\n\tfloat depth = 0.;\n\tfloat t = castRay(ro,rd,depth);\n\t#else\n\tfloat t = castRay(ro,rd);\n\t#endif\n\n\t#ifdef RENDER_DEPTH\n\treturn vec3(depth/10.,depth/5.,depth);\n\t#endif\n\n\tvec3 pos = ro + t * rd;\n\tvec3 nor = calcNormal(pos);\n\n\t#ifdef RENDER_NORMAL\n\treturn nor;\n\t#endif\n\n\tfloat ao = calcAO(pos,nor,10.,1.2);\n\t#ifdef RENDER_AO\n\treturn vec3(ao);\n\t#endif\n\n    float thi = thickness(pos, nor, 4., 2.5);\n\n    vec3 lpos1 = vec3(0.,27.5,-time*50.);\n\tvec3 ldir1 = normalize(lpos1-pos);\n\tfloat latt1 = pow( length(lpos1-pos)*.1, 1. );\n    float trans1 =  pow( clamp( max(0.,dot(-rd, -ldir1+nor)), 0., 1.), 1.) + 1.;\n\tvec3 diff1 = vec3(.1,.1,.1) * (max(dot(nor,ldir1),0.) ) / latt1;\n\tcol =  diff1;\n\tcol += vec3(.2,.2,.3) * (trans1/latt1)*thi;\n    \n    vec3 lpos = vec3(80.,0.,-time*50.);\n    vec3 ldir = normalize(lpos-pos);\n\tfloat latt = pow( length(lpos-pos)*.03, .1 );\n    float trans =  pow( clamp( max(0.,dot(-rd, -ldir+nor)), 0., 1.), 1.) + 1.;\n\tcol += vec3(.1,.1,.1) * (trans/latt)*thi;\n\n    float d = distance(pos.xyz,vec3(0.));\n\tcol = max(vec3(.05),col);\n\tcol *= ao;\n\n\treturn col;\n}\n\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr )\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n\treturn mat3( cu, cv, cw );\n}\n\nvec3 orbit(float phi, float theta, float radius)\n{\n\treturn vec3(\n\t\tradius * sin( phi ) * cos( theta ),\n\t\tradius * cos( phi ),\n\t\tradius * sin( phi ) * sin( theta )\n\t);\n}\n\n//------------------------------------------------------------------ MAIN\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 p = -1. + 2. * uv;\n    p.x *= iResolution.x / iResolution.y;\n    \n    time = 42. + iTime;\n    //Camera\n\tfloat radius = 50.;\n\tvec3 ro = orbit(PI/2.-.5,PI/2.,radius);\n    ro.z -= time*50.;\n\tvec3 ta  = vec3(ro.x, ro.y, ro.z-time*50.);\n\tmat3 ca = setCamera( ro, ta, 0. );\n\tvec3 rd = ca * normalize( vec3(p.xy,1.5) );\n\n\t// Raymarching\n\tvec3 color = render( ro, rd, uv );\n\t#ifdef POSTPROCESS\n\tcolor = postEffects( color, uv, time );\n\t#endif\n\tfragColor = vec4(color,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/XdcGWX.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "XdGGDh", "name": "Spiral Mapping", "author": "vox", "description": "MandelSpiral", "tags": ["mandelspiral"], "likes": 9, "viewed": 555, "date": "1454125996", "time_retrieved": "2024-06-20T18:30:52.414259", "image_code": "\n#define PI 3.14159265359\n#define E 2.7182818284\n\nfloat saw(float x)\n{\n    return acos(cos(x))/3.14;\n}\nvec2 saw(vec2 x)\n{\n    return acos(cos(x))/3.14;\n}\n\nvec2 spiral(vec2 uv)\n{\n    float turns = 5.0;\n    float r = pow(log(length(uv)+1.), 1.175);\n    float theta = atan(uv.y, uv.x)*turns-r*PI;\n    return vec2(saw(r*PI+iTime), saw(theta+iTime*1.1));\n}\n\nfloat draw(vec2 p)\n{\n    \n    // animation\t\n\tfloat tz = 0.5 - 0.5*cos(0.225*iTime);\n    float zoo = pow( 0.5, 13.0*tz );\n\tvec2 c = vec2(-0.05,.6805) + p*zoo;\n\n    // iterate\n    vec2 z  = vec2(0.0);\n    float m2 = 0.0;\n    vec2 dz = vec2(0.0);\n    for( int i=0; i<256; i++ )\n    {\n        if( m2>1024.0 ) continue;\n\n\t\t// Z' -> 2Â·ZÂ·Z' + 1\n        dz = 2.0*vec2(z.x*dz.x-z.y*dz.y, z.x*dz.y + z.y*dz.x) + vec2(1.0,0.0);\n\t\t\t\n        // Z -> ZÂ² + c\t\t\t\n        z = vec2( z.x*z.x - z.y*z.y, 2.0*z.x*z.y ) + c;\n\t\t\t\n        m2 = dot(z,z);\n    }\n\n    // distance\t\n\t// d(c) = |Z|Â·log|Z|/|Z'|\n\tfloat d = 0.5*sqrt(dot(z,z)/dot(dz,dz))*log(dot(z,z));\n\n\t\n    // do some soft coloring based on distance\n\td = clamp( 8.0*d/zoo, 0.0, 1.0 );\n\td = pow( d, 0.25 );\n    return d;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    \n    float scale = 2.0*PI;\n    uv *= scale;\n    uv -= scale/2.0;\n\tuv.x *= iResolution.x/iResolution.y;\n    uv += vec2(cos(iTime*.234), sin(iTime*.345))*1.0;\n    uv = spiral(uv*scale);\n    uv = spiral(uv*scale);\n   fragColor = vec4(draw(saw(uv*1.0*PI)*2.0-1.0));\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/XdGGDh.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "XdGGRz", "name": "Army of Oranges", "author": "Emil", "description": "First experiment with raymarching. Animated the length of iteration step and got funky blurryness :)", "tags": ["3d", "raymarching", "abstract"], "likes": 9, "viewed": 267, "date": "1452872320", "time_retrieved": "2024-06-20T18:30:52.414259", "image_code": "float map(vec3 p){\n    p.x = mod(p.x, 2.0);\n    p.y = (p.y, 2.0);\n    p.z = mod(p.z, 2.0);\n    return length(p-vec3(1.0,1.0,1.0)) - 0.5;\n}\n\nfloat trace(vec3 o, vec3 r){\n    float t = 0.5;\n    const int maxSteps = 32;\n    for (int i = 0; i < maxSteps; i++){ \n        vec3 p = o + r * t;\n        float d = map(p);\n        t += d * 1.0*(sin(iTime));\n    }\n    return t;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    uv = uv*2.0 -1.0;\n    uv.x *= iResolution.x / iResolution.y;\n    vec3 r = normalize(vec3(uv, 1.0));\n    \n    vec3 o = vec3(0.0,0.0,-3.0);\n    o.z = 2.6*iTime;\n    \n    \n    float t = trace(o,r);\n    float fog = 1.0 / (1.0 + t * t * 0.1);\n    vec3 fc = vec3(fog);\n    \n\tfragColor = vec4(fc*vec3(2.0,1.0,0.05),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/XdGGRz.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "XdGGzw", "name": "First Raymarches", "author": "cacheflowe", "description": "My first real attempt at drawing with raymarching functions. Thanks to everybody who helps beginners like me understand this stuff :)", "tags": ["raymarching", "hexagons"], "likes": 90, "viewed": 9797, "date": "1453602837", "time_retrieved": "2024-06-20T18:30:52.826408", "image_code": "#define ITERATIONS 128\n\nfloat sdHexPrism( vec3 p, vec2 h ) {\n    vec3 q = abs(p);\n    return max(q.z-h.y,max((q.x*0.866025+q.y*0.5),q.y)-h.x);\n}\n\nfloat opRep( vec3 p, vec3 spacing ) {\n    vec3 q = mod(p, spacing) - 0.5 * spacing;\n    return sdHexPrism( q, vec2( 0.2 + 0.1 * cos(iTime/2.), 1.0 + 0.9 * sin(3.14 + iTime/2.) ) );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // 1 : retrieve the fragment's coordinates\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    uv -= vec2(0.5, 0.5);\n\tuv.x *= iResolution.x / iResolution.y;\t\t// Correct for aspect ratio\n\t\n    // 2 : camera position and ray direction\n\t// vec3 pos = vec3( sin(iTime), 0, sin(iTime) * 5. );\n\tvec3 pos = vec3( sin(iTime), 0, iTime / 20. );\n\tvec3 dir = normalize( vec3( uv, 1. ) );\n \n\t// 3 : ray march loop\n    // ip will store where the ray hits the surface\n\tvec3 ip;\n \n\t// variable step size\n\tfloat t = 0.0;\n\tfloat findThresh = 0.001;\n\tint found = 0;\n    int last_i = 0;\n    \n\tfor(int i = 0; i < ITERATIONS; i++) {\n\t\tlast_i = i;\n        \n        //update position along path\n        ip = pos + dir * t;\n \n        //gets the shortest distance to the scene\n        //break the loop if the distance was too small\n        //this means that we are close enough to the surface\n \t\tfloat temp;\n\n\t\t// make a repeating SDF shape\n\t\ttemp = opRep( ip, vec3(2.5 + 2.0 * sin(iTime/2.) ) );\n\t\tif( temp < findThresh ) {\n\t\t\tfloat r = 0.7 + 0.3 * sin(ip.z/8. + ip.x/2.);\n\t\t\tfloat g = 0.6 + 0.3 * cos(ip.z/8. + ip.y/2.);\n\t\t\tfloat b = 0.5 + 0.4 * sin(ip.z/8. + ip.x);\n\t\t\tip = vec3(r, g, b);\n\t\t\tfound = 1;\n\t\t\tbreak;\n\t\t}\n\t\t\n\t\t//increment the step along the ray path\n\t\tt += temp;\n\t}\n\t\n\t// make background black if no shape was hit\n\tif(found == 0) {\n\t\tip = vec3(0,0,0);\n\t}\n \n\t// 4 : apply color to this fragment\n    // subtract from color as distance increases\n\tfragColor = vec4(ip - float(last_i) / float(ITERATIONS), 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/XdGGzw.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "XdKGRD", "name": "2D Radial Repeat : Hex GridClick", "author": "aiekick", "description": "Based on the hex pattern from a shader of nimitz ( i not find the shader anymore :))\nckick on cells for full screen", "tags": ["2d", "radial", "hex", "repeat"], "likes": 24, "viewed": 807, "date": "1453494776", "time_retrieved": "2024-06-20T18:30:53.353624", "image_code": "// Created by Stephane Cuillerdier - @Aiekick/2016\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n// Tuned via XShade (http://www.funparadigm.com/xshade/)\n// here the XShade file i used for tuning the shader : http://www.funparadigm.com/2016/01/23/2d-radial-repeat-hex/\n// there is some dedicated widget already configured, ready to tune. enjoy :)\n\nconst vec2 gridSize = vec2(3.,3.);//grid size (columns, rows)  \nconst vec3 startColor = vec3(1,0.26,0);\nconst vec3 endColor = vec3(0.33,0.2,0.49);\n\nvec3 pattern(vec2 uv, vec4 v, vec3 k)\n{\n\tfloat a = atan(uv.x, uv.y)/3.14159*floor(k.y);\n\tfloat r = length(uv)*4.;\n\tuv = vec2(a,r);\n\tuv.x *= floor(uv.y)-k.x;\n\tuv.x += iTime ;\n\tvec3 color = mix(startColor, endColor, vec3(floor(uv.y)/6.));\n\tuv = abs(fract(uv)-0.5);\n\tfloat x = uv.x*v.x;\n\tfloat y = uv.y*v.y;\n\tfloat z = uv.y*v.z;\n\treturn color / (abs(max(x + y,z) - v.w)*k.z);\n}\n\nfloat EncID(vec2 s, vec2 h, vec2 sz) // encode id from coord // s:screenSize / h:pixelCoord / sz=gridSize\n{\n    float cx = floor(h.x/(s.x/sz.x));\n    float cy = floor(h.y/(s.y/sz.y));\n    return cy*sz.x+cx;\n}\n\nvec2 DecID(float id, vec2 sz) // decode id to coord // id:cellId / sz=gridSize\n{\n    float cx = mod(float(id), sz.x);\n    float cy = (float(id)-cx)/sz.x;\n    return vec2(cx,cy);\n}\n\nvec3 getcell(vec2 s, vec2 h, vec2 sz) // return id / uv\n{\n    float cx = floor(h.x/(s.x/sz.x));\n    float cy = floor(h.y/(s.y/sz.y));\n    \n    float id = cy*sz.x+cx;\n    \n    vec2 size = s/sz;\n    float ratio = size.x/size.y;\n    vec2 uv = (2.*(h)-size)/size.y - vec2(cx*ratio,cy)*2.;\n    uv*=1.5;\n    \n    return vec3(id, uv);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 cell = getcell(iResolution.xy,gl_FragCoord.xy,gridSize);\n    if(iMouse.z>0.) \n\t{\n\t\tcell.x = EncID(iResolution.xy,iMouse.xy,gridSize);\n\t\tcell.yz = gl_FragCoord.xy;\n\t}\n\t\n\tvec2 uv = 1.6 * (2.*gl_FragCoord.xy - iResolution.xy)/iResolution.y;\n\t\n\tvec4 p;\n    \n\tvec3 k = vec3(-.3, 5, 4); // alternance, density, glow\n\n\tif (cell.x == 0.) {p = vec4(1.2,0.92,1.88,0.8);}\n\tif (cell.x == 1.) {p = vec4(2.2,0,1.88,0.8);}\n\tif (cell.x == 2.) {p = vec4(2.2,0,4,0.8);}\n\tif (cell.x == 3.) {p = vec4(1,0,4,0.8);}\n\tif (cell.x == 4.) {p = vec4(1.2,0,2.12,0.64);}\n\tif (cell.x == 5.) {p = vec4(4,4,1,0.8);}\n\tif (cell.x == 6.) {p = vec4(1,2.96,4,0.8);}\n\tif (cell.x == 7.) {p = vec4(1.5,0.96,1.8,0.4);}\n\tif (cell.x == 8.) {p = vec4(1.2,2.24,0,0.68);}\n\t\n\tvec3 hex = clamp(pattern(uv, p, k),0.,1.);\n\t\n\tfragColor = vec4(hex, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc-by-nc-sa-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/XdKGRD.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "Xdt3WS", "name": "Bumps", "author": "davidar", "description": "Based on https://www.shadertoy.com/view/llsGW7", "tags": ["3d"], "likes": 3, "viewed": 120, "date": "1451986487", "time_retrieved": "2024-06-20T18:30:53.359532", "image_code": "#define STEPS 1000\n\nfloat f(float x, float y) {\n    return 100.0 * sin(0.1*x) * sin(0.1*y) * sin(iTime) - 125.0;\n}\n\nvoid mainImage(out vec4 c, in vec2 w) {\n    vec4 p = vec4(w/iResolution.xy,1,1) - 0.5;\n    vec4 d = p * 0.5;\n    p.z += 20.*iTime;\n    d.y -= 0.2;\n\n    for(int i = 0; i < STEPS; i++) {\n        c = vec4(vec3(i)/float(STEPS), 1);\n        if(f(p.x,p.z) > p.y) break;\n        p += d;\n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/Xdt3WS.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "XdtGD2", "name": "Wave Road", "author": "Densen90", "description": "Some moving repeating cubes and spheres going on waves.", "tags": ["raymarching", "cube", "shadow", "sphere", "repetition", "fog", "ao"], "likes": 5, "viewed": 208, "date": "1452252521", "time_retrieved": "2024-06-20T18:30:54.396289", "image_code": "const float moveSpeed = 2.5;\nconst int maxSteps = 256;\nconst float pi = 3.14159;\nconst float ambient = 0.1;\nconst float brightness = 3.0;\nconst float epsilon = 0.0001;\nconst float maxDepth = 60.0;\nconst float aoSamples = 5.0;\nconst vec3 diffuse = vec3(1, 1, 1);\nconst vec3 lightCol = vec3(1,1,1);\nvec3 lightDir = normalize(vec3(0.5, 0.5, 1.0));\nvec3 lightDir2 = normalize(vec3(-0.5, 0.5, 1.0));\n\nvec3 color = vec3(1.0);\n\nstruct Camera\n{\n\tvec3 pos;\n\tvec3 dir;\n} cam;\n\n// give the distance to a plane from a point p and normal n, shifted by y\nfloat distPlane( vec3 p, vec3 n, float y )\n{\n\t// n must be normalized\n\treturn dot(p,n) - y;\n}\n\n// give the distance from point p to a sphere surface at origin\nfloat distSphere(vec3 p, float rad)\n{\n\treturn length(p) - rad;\n}\n\nfloat distBox(vec3 point, vec3 center, vec3 b )\n{\n  return length(max(abs(point - center) - b, vec3(0.0)));\n}\n\nvec3 pointRepetition(vec3 point, vec3 c)\n{\n\tpoint.x = mod(point.x, c.x) - 0.5*c.x;\n\tpoint.z = mod(point.z, c.z) - 0.5*c.z;\n\treturn point;\n}\n\n// Rotation / Translation of a point p with rotation r\nvec3 rotate( vec3 p, vec3 r )\n{\n\tr.x *= pi/180.0;\n\tr.y *= pi/180.0;\n\tr.z *= pi/180.0;\n\n\tmat3 xRot = mat3 (\t1,\t0,\t\t\t\t0,\n\t\t\t\t\t\t0,\tcos(r.x),\t-sin(r.x),\n\t\t\t\t\t\t0,\tsin(r.x),\tcos(r.x) );\n\tmat3 yRot = mat3 ( \tcos(r.y),\t\t0,\tsin(r.y),\n\t\t\t\t\t\t0,\t\t\t\t\t1,\t0,\n\t\t\t\t\t\t-sin(r.y),\t\t0,\tcos(r.y) );\n\tmat3 zRot = mat3 (\tcos(r.z),\t-sin(r.z),\t0,\n\t\t\t\t\t\tsin(r.z),\tcos(r.z),\t0,\n\t\t\t\t\t\t0,\t\t\t\t0,\t\t\t\t1 );\n\treturn xRot * yRot * zRot * p;\n}\n\nfloat distanceField(vec3 p)\n{\n\tvec3 point = p;\n\tfloat expansion = 4.5;\n\tvec3 repPoint = pointRepetition(p, vec3(expansion, 0.0, expansion));\n\tvec3 repPoint2 = pointRepetition(p-vec3(0,0,expansion/2.0), vec3(expansion, 0.0, expansion));\n\tvec3 repPointSphere = pointRepetition(p-vec3(cos(iTime*moveSpeed*0.5)*expansion/4.0,0,0), vec3(expansion, 0, expansion));\n\tvec3 repPointSphere2 = pointRepetition(p-vec3(sin(iTime*moveSpeed*0.5)*expansion/4.0,0,expansion/2.0), vec3(expansion, 0, expansion));\n\n\tvec3 boxDimension1 = vec3(expansion/4.0, (0.5*(cos(iTime*moveSpeed+repPoint.x)+1.0)), (0.5*(cos(iTime*moveSpeed+repPoint.y)+1.0)));\n\tvec3 boxDimension2 = vec3(expansion/4.0, (0.5*(sin(iTime*moveSpeed+repPoint.x)+1.0)), (0.5*(sin(iTime*moveSpeed+repPoint.y)+1.0)));\n\tvec3 spherePos = vec3(repPointSphere.x, repPoint.y-(0.5*(cos(iTime*moveSpeed+repPoint.x)+1.0))+0.3, repPointSphere.z);\n\tvec3 spherePos2 = vec3(repPointSphere2.x, repPoint2.y-(0.5*(sin(iTime*moveSpeed+repPoint2.x)+1.0))+0.3, repPointSphere2.z);\n\n\tfloat plane = distPlane(point, normalize(vec3(0, 1, 0)), -0.5);\n\tfloat boxes = distBox(repPoint, vec3(0, -0.5, 0), boxDimension1);\n\tfloat boxes2 = distBox(repPoint2, vec3(0, -0.5, 0), boxDimension2);\n\tfloat spheres = distSphere(spherePos, 0.2);\n\tfloat spheres2 = distSphere(spherePos2, 0.2);\n\n\tfloat ret = min(plane, min(boxes, min(boxes2,min(spheres, spheres2))));\n\n\tif(ret==plane) color = vec3(1.0);\n\telse if(ret==boxes) color = vec3(0.8, 0.5, 0.6);\n\telse if(ret==boxes2) color = vec3(0.5, 0.4, 0.8);\n\telse if(ret==spheres) color = vec3(0.5, 0.7, 0.4);\n\telse if(ret==spheres2) color = vec3(0.8, 0.8, 0.3);\n\n\treturn ret;\n}\n\n// marching along the ray at step sizes, \n// and checking whether or not the surface is within a given threshold\nvec4 raymarch(vec3 rayOrigin, vec3 rayDir, out int steps)\n{\n\tfloat totalDist = 0.0;\n\tfor(int j=0; j<maxSteps; j++)\n\t{\n\t\tsteps = j;\n\t\tvec3 p = rayOrigin + totalDist*rayDir;\n\t\tfloat dist = distanceField(p);\n\t\tif(abs(dist)<epsilon)\t//if it is near the surface, return an intersection\n\t\t{\n\t\t\treturn vec4(p, 1.0);\n\t\t}\n\t\ttotalDist += dist;\n\t\tif(totalDist>=maxDepth) break;\n\t}\n\treturn vec4(0);\n}\n\n// Approximates the (normalized) gradient of the distance function at the given point.\n// If p is near a surface, the function will approximate the surface normal.\nvec3 getNormal(vec3 p)\n{\n\tfloat h = 0.0001;\n\treturn normalize(vec3(\n\t\tdistanceField(p + vec3(h, 0, 0)) - distanceField(p - vec3(h, 0, 0)),\n\t\tdistanceField(p + vec3(0, h, 0)) - distanceField(p - vec3(0, h, 0)),\n\t\tdistanceField(p + vec3(0, 0, h)) - distanceField(p - vec3(0, 0, h))));\n}\n\nfloat shadow(vec3 ro, vec3 rd)\n{\n\tfloat softshadowFac = 32.0;\n\tfloat res = 1.0;\n    float tt=0.01;\n    for( float i=0.0; i<1.0; i+=0.0)\n    {\n        float h = distanceField(ro + rd*tt);\n        if( h<epsilon )\n            return ambient;\n        res = min( res, softshadowFac*h/tt );\n        tt += h;\n        if(tt>=32.0) break;\n    }\n    return res;\n}\n\n//calculate ambient occlusion\nfloat ambientOcclusion(vec3 p, vec3 n)\n{\n\tfloat res = 0.0;\n\tfloat fac = 1.0;\n\tfor(float i=0.0; i<aoSamples; i++)\n\t{\n\t\tfloat distOut = i*0.3;\t//go on normal ray AOSAMPLES times with factor 0.3\n\t\tres += fac * (distOut - distanceField(p + n*distOut));\t//look for every step, how far the nearest object is\n\t\tfac *= 0.5;\t//for every step taken on the normal ray, the fac decreases, so the shadow gets brighter\n\t}\n\treturn 1.0 - clamp(res, 0.0, 1.0);\n}\n\n//calculate the color, the shadow, the lighting for a position\nvec3 shading(vec3 pos, vec3 rd, vec3 n)\n{\n\tvec3 lDir = pos.x > 0.0 ? lightDir : lightDir2;\t//little trick to simulate two lights -> choose which light source depending on position\n\tvec3 light = max(ambient*brightness, dot(n, lDir)) * lightCol;\t//lambert light with light Color\n\tlight *= shadow(pos, lDir);\t//add shadow\n\n\tlight += ambientOcclusion(pos, n) * ambient*brightness;\n\treturn light;\n}\n\nvoid mainRender(out vec4 col)\n{\n\tfloat fov = 60.0;\n\tfloat tanFov = tan(fov / 2.0 * 3.14159 / 180.0) / iResolution.x;\n\tvec2 p = tanFov * (gl_FragCoord.xy * 2.0 - iResolution.xy);\n\n\tcam.pos = vec3(0,0,iTime*moveSpeed*2.0);\n\tcam.dir = rotate(normalize(vec3( p.x, p.y, 1 )), vec3(0, 0, 0));\n\n\tvec4 res;\n\tint steps;\n\tres = raymarch(cam.pos, cam.dir, steps);\n\tvec3 currentCol = color; //save the color, the global color changes in shading (shadow & AO)\n\n\tif(res.a==1.0)\n\t{\n\t\tcurrentCol *= clamp(shading(res.xyz, cam.dir, getNormal(res.xyz)), 0.0, 1.0);\n\t}\n\telse\n\t{\n\t\tcurrentCol = vec3(1);\n\t}\n\n\t//fog\n\tvec3 fogColor = vec3(1);\n\tfloat fogDist = 200.0;\n\tcurrentCol = mix(currentCol, fogColor, (float(steps)/fogDist));\n\n\tcol = vec4(currentCol, 1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tmainRender(fragColor);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/XdtGD2.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "XdV3Dh", "name": "CS224_BALL_zli27", "author": "zli27", "description": "You toggle motion blur and anti-aliasing off by comment #define motionblur and #define antialiasing out. ", "tags": ["raytracing", "motionblur", "antialiasing", "softshadow"], "likes": 3, "viewed": 117, "date": "1454268702", "time_retrieved": "2024-06-20T18:30:54.396289", "image_code": "// ground plane is at Y=0\n// sphere is resting on top of ground plane.\n\n#define motionblur\n\n//Super sampling -> 9 Sample points\n#define antialiasing \n\nvec3 fogCol   = vec3(.5);\nconst float SPHERE_RADIUS = .6;\nconst float EPSILON = 0.05;\n\n//****** SPHERES ****** //\n\nvec3 CENTER = vec3(-10.,2.,8.);\nvec4 SPHERE1 = vec4(-10., 1. + .5 * sin(iTime * 10.), 10.,.5);\nvec4 SPHERE2 = vec4(SPHERE1.x-2.5*SPHERE_RADIUS * cos(iTime / 3.),SPHERE_RADIUS,SPHERE1.z- 2.5*SPHERE_RADIUS*sin(iTime / 3.),.7);\nvec4 SPHERE3 = vec4(SPHERE1.x+4.5*SPHERE_RADIUS * cos(iTime * 3.0),SPHERE_RADIUS,SPHERE1.z+ 4.5*SPHERE_RADIUS*sin(iTime * 3.0),.5);\nvec4 SPHERE4 = vec4(SPHERE1.x+6.5*SPHERE_RADIUS * sin(iTime * 2.),SPHERE_RADIUS,SPHERE1.z+ 6.5*SPHERE_RADIUS*cos(iTime * 2.),.4);\nvec4 SPHERE5 = vec4(SPHERE1.x-7.5*SPHERE_RADIUS* sin(iTime),.25 + .2 * sin(iTime),SPHERE1.z- 7.5*SPHERE_RADIUS*cos(iTime),.25 + .1 * sin(iTime));\n\n\nvec3 POINT_LIGHT = vec3(-20. * smoothstep(-.5,.5,sin(iTime / 3.)),22., -7.); \nconst vec3 SPHERE_AMBIENT1 = vec3(.0);\nconst vec3 SPHERE_AMBIENT2 = vec3(.5);\nconst vec3 SPHERE_DIFFUSE = vec3(.5, 0.5, 0.5); // diffuse color of the sphere\nconst vec3 SPHERE_SPECULAR = vec3(.5);\nconst vec3 WORLD_COLOR = vec3(0.8, 0.9, 1.0);\nconst vec3 GROUND_COLOR_2 = vec3(0.05);\nconst vec3 GROUND_COLOR_1 = vec3(0.9,0.9,0.9);\nconst vec3 LIGHT_COLOR = vec3(1.);\n\n//Returns the sphere(#3) position at given time\nvec3 getPosition(float time, int which)\n{\n    if (which == 1){\n        return vec3(-10., 1. + .5 * sin(time * 10.), 10.);\n    } else if (which == 2){\n        return vec3(SPHERE1.x-2.5*SPHERE_RADIUS * cos(time / 3.),SPHERE_RADIUS,SPHERE1.z- 2.5*SPHERE_RADIUS*sin(time / 3.));\n    } else if (which == 3){\n        return vec3(SPHERE1.x+4.5*SPHERE_RADIUS * cos(time * 3.0),SPHERE_RADIUS,SPHERE1.z+ 4.5*SPHERE_RADIUS*sin(time * 3.0));\n    } else if (which == 4){\n        return vec3(SPHERE1.x+6.5*SPHERE_RADIUS * sin(time * 2.),SPHERE_RADIUS,SPHERE1.z+ 6.5*SPHERE_RADIUS*cos(time * 2.));\n    } else {\n        return vec3(SPHERE1.x-7.5*SPHERE_RADIUS* sin(time),.25 + .2 * sin(time),SPHERE1.z- 7.5*SPHERE_RADIUS*cos(time));\n    }   \n}\nfloat getBlendFactor(in vec3 pos, in vec4 sphere)\n{\n    float dist = distance(pos, sphere.xyz) - sphere.w;\n    return clamp(dist, 0., 1.);\n}\n\n//Ray : x = ro + t * rd\n//Sphere : |x - o| = r\n//Equation : t2 + 2 * t * (ro*rd - o*rd) + (ro-o)2 - r2 = 0\n//--> [A]t2 + [B]2 * t * <rd, ro-o> + [C](ro-o)2 - r2 = 0\nfloat iSphere( in vec3 ro, in vec3 rd, in vec4 sphere)\n{\n \n    vec3 ro2o = ro - sphere.xyz;\n    float b = dot(rd, ro2o);\n    float c = dot(ro2o, ro2o) - pow(sphere.w, 2.);\n    float delta = pow(b, 2.) - c;\n    \n    //IF DELTA < 0 : no intersection\n    if(delta < 0.){\n        return -1.;\n    }\n    \n    return -b - sqrt(delta);    \n}\n\n//Idea from iq\n//http://iquilezles.org/www/articles/sphereshadow/sphereshadow.htm\n//Equation for testing intersection is identical with the above function\nfloat sphSoftShadow( in vec3 ro, in vec3 rd, in vec4 sphere, in float k )\n{\n    vec3 ro2o = ro - sphere.xyz;\n    float b = dot(rd, ro2o );\n    float c = dot(ro2o, ro2o) - pow(sphere.w, 2.);\n    float delta = b*b - c;\n    \n    //T is identical with the intersection result\n    //no further shadow calculation requires if there is no intersection\n    float t = -b - sqrt(max(0.0,delta));\n    if(t < 0.0){\n        return 1.;\n    }\n    \n    //d is the closest distance from sphere center to the ray\n    //Draw a line from sphere center which perpendicular to the ray direction\n    //the length between the intersection point and the sphere center is d\n    //\n   \n    float l2 = dot(ro2o,ro2o);\n    float projection2 = pow(dot(rd,ro2o), 2.);\n    float d = sqrt(max(0., l2 - projection2)) - sphere.w;\n    return smoothstep(0.0, 1.0, k*d / t);\n}\n\nvec3 sphereNormal(in vec3 pos, in vec4 sphere)\n{\n    return normalize(pos - sphere.xyz);\n}\n\nvec3 illuminateSphere(in vec3 pos, in vec4 sphere)\n{\n    vec3 normal = sphereNormal(pos,sphere);\n    \n    //Phong lighting \n    vec3 l = normalize(POINT_LIGHT - pos);\n    vec3 r = normalize(reflect(l,normal));\n    vec3 e = normalize(vec3(10., 2.1, 20.) - pos);\n    float spec = max(0., dot(e, r));\n    vec3 ambient = vec3(0.);\n    float angle = atan(pos.x / pos.z * .8) * 160.;\n    if(tan(angle) > .0){\n        ambient = SPHERE_AMBIENT1;\n    }else{\n        ambient = SPHERE_AMBIENT2;\n    }\n    vec3 specular = SPHERE_SPECULAR * pow(spec,10.);\n    vec3 phong = ambient + SPHERE_DIFFUSE * max(0., dot(normal,l)) + specular;\n    float alpha = getBlendFactor(pos, sphere);\n    return mix(phong, vec3(.5), alpha);\n}\n\nvec3 refl( in vec3 pos, in vec3 rd)\n{\n    vec3 gnormal = vec3(0., 1., 0.);\n    vec3 r = normalize(reflect(rd, gnormal));\n    vec3 p = vec3(0.);\n    vec3 col = vec3(0.);\n    float mint = 1e10;\n    float h = iSphere(pos,r,SPHERE1);\n    if(h > 0. && h < mint){\n        mint = h;\n        p = pos + h * r;\n        col = illuminateSphere(p,SPHERE1);\n    }\n    h = iSphere(pos,r,SPHERE2);\n    if(h > 0. && h < mint){\n        mint = h;\n        p = pos + h * r;\n        col = illuminateSphere(p,SPHERE2);\n    }\n    h = iSphere(pos,r,SPHERE3);\n    if(h > 0. && h < mint){\n        mint = h;\n        p = pos + h * r;\n        col = illuminateSphere(p,SPHERE3);\n    }\n    h = iSphere(pos,r,SPHERE4);\n    if(h > 0. && h < mint){\n        mint = h;\n        p = pos + h * r;\n        col = illuminateSphere(p,SPHERE4);\n    }\n    h = iSphere(pos,r,SPHERE5);\n    if(h > 0. && h < mint){\n        mint = h;\n        p = pos + h * r;\n        col = illuminateSphere(p,SPHERE5);\n    }\n    \n    return col; \n}\n\nvec3 illuminateGround(in vec3 pos, in vec3 rd)\n{\n    vec3 col = vec3(0.);\n    \n    float diff = pow((pos.x-SPHERE1.x),2.) + pow((pos.z-SPHERE1.z),2.);\n    if(sin(diff/pow(SPHERE_RADIUS,2.)) <= 0.){\n        col = GROUND_COLOR_2;\n    }else{\n        col = GROUND_COLOR_1;\n    } \n    \n    //Apply soft shadow on the ground\n    float sshadow = sphSoftShadow(pos, normalize(POINT_LIGHT-pos), SPHERE1, 5.);\n    col *= sshadow;\n    float sshadow2 = sphSoftShadow(pos, normalize(POINT_LIGHT-pos), SPHERE2, 10.);\n    col *= sshadow2;\n    float sshadow3 = sphSoftShadow(pos, normalize(POINT_LIGHT-pos), SPHERE3, 12.);\n    col *= sshadow3;\n    float sshadow4 = sphSoftShadow(pos, normalize(POINT_LIGHT-pos), SPHERE4, 16.);\n    col *= sshadow4;\n    float sshadow5 = sphSoftShadow(pos, normalize(POINT_LIGHT-pos), SPHERE5, 32.);\n    col *= sshadow5;\n    \n    //Get the reflection color\n    vec3 reflcol = refl(pos, rd);\n    \n    col = mix(col, reflcol, .22);\n      \n    return col;\n}\n\n//Brute force motion blur\nvec3 motionBlur(in vec3 ro, in vec3 rd, int which, float radius)\n{\n    vec3 col = vec3(0.0);\n    const int samples = 40;\n    \n    //Sample at 60 different points\n    for( int i=0; i<samples; i++ )\n\t{   \n        //Sample time interval \n        float deltaT = float(i) / float(samples);\n        vec3 ap = getPosition(iTime + deltaT / 15., which);\n        \n        //Ambient color if doesn't intersect with the current position\n        vec3 tcol = vec3(.5);\n        \n        vec4 newSpherePos = vec4(ap, radius);\n        \n        float t = iSphere( ro, rd, newSpherePos);\n        \n        //If there is an intersection at the sample position\n        if( t > 0.0 )\n        {\n            vec3 pos = ro + t * rd;\n            vec3 nor = sphereNormal(pos, newSpherePos);\n            tcol = illuminateSphere(pos, newSpherePos);\n        }\n        col += tcol;\n\t}\n    \n    //Divide by sample num\n\tcol /= float(samples);\n    \n    return col;\n}\n\nvec3 render(in vec3 ro, in vec3 rd)\n{\n    vec3 pos = vec3(0.);\n    vec3 col = vec3(0.);\n    float mint = 1e10;\n    float h = iSphere(ro,rd,SPHERE1);\n    if(h > 0. && h < mint){\n        mint = h;\n        pos = ro + h * rd;\n        \n        #ifdef motionblur\n        col = motionBlur(ro, rd, 1,SPHERE1.w);\n        #else\n        col = illuminateSphere(pos,SPHERE1);\n        #endif\n    }\n    h = iSphere(ro,rd,SPHERE2);\n    if(h > 0. && h < mint){\n        mint = h;\n        pos = ro + h * rd;\n        col = illuminateSphere(pos,SPHERE2);\n    }\n    h = iSphere(ro,rd,SPHERE3);\n    if(h > 0. && h < mint){\n        mint = h;\n        pos = ro + h * rd;\n        #ifdef motionblur\n        col = motionBlur(ro, rd, 3,SPHERE3.w);\n        #else\n        col = illuminateSphere(pos,SPHERE3);\n        #endif\n    }\n    h = iSphere(ro,rd,SPHERE4);\n    if(h > 0. && h < mint){\n        mint = h;\n        pos = ro + h * rd;\n        #ifdef motionblur\n        col = motionBlur(ro, rd,4, SPHERE4.w);\n        #else\n        col = illuminateSphere(pos,SPHERE4);\n        #endif\n    }\n    h = iSphere(ro,rd,SPHERE5);\n    if(h > 0. && h < mint){\n        mint = h;\n        pos = ro + h * rd;\n        #ifdef motionblur\n        col = motionBlur(ro, rd, 5,SPHERE5.w);\n        #else\n        col = illuminateSphere(pos,SPHERE5);\n        #endif\n    }\n    h =  -ro.y / rd.y;\n    if(h > 0. && h < mint){\n        mint = h;\n        pos = ro + h * rd;\n        col = illuminateGround(pos, rd);\n    }\n    \n    float d = distance(pos, POINT_LIGHT);\n    \n    //Light attenuation\n    float atten = min(1., 20. / (1. + .8 * d + 1.8 * pow(d, .4)));\n    \n    col *= atten;\n    \n    //Distance fog\n    float fog = 1. - exp(distance(ro, pos) * .07);\n    \n    col = mix(col, fogCol, fog);\n        \n    return col;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy/iResolution.xy;\n    vec2 p = -1.0+2.0*uv; // pixel space of the focal plane\n    p.x *= iResolution.x/iResolution.y;\n    \n    // camera   \n    vec3 eye = vec3(-10. + 5. * sin(iTime),7. + 2. * sin(iTime / 2.), -5. + 2.5 * cos(iTime)); // world space camera location\n    vec3 look = CENTER; // where camera is pointing at\n    vec3 up = vec3( 0.0, 1.0, 0.0 ); // up axis of world\n    float d = 5.5; // distance between eye and focal plane\n    \n    vec3 w = normalize( look - eye);\n    vec3 u = normalize( cross(w,up) );\n    vec3 v = normalize( cross(u,w) );\n    vec3 rd = normalize( p.x*u + p.y*v + d*w );\n    \n    //Color gained from the central ray\n    vec3 col = render(eye,rd);\n    \n    #ifdef antialiasing\n    \n       float samplex = 1. / iResolution.x;\n       float sampley = 1. / iResolution.y;\n       for(int i=-1;i<=1;i++){\n           for(int j=-1;j<=1;j++){\n               if( i == 0 && j == 0) continue;\n               vec2 sp = p + vec2(samplex * float(i), sampley*float(j));\n               vec3 srd = normalize(sp.x*u+sp.y*v+d*w);\n               col += render(eye,srd);\n           }\n       }\n    \n       col /= 9.;\n    #endif\n    \n    fragColor=vec4(col, 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/XdV3Dh.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "XdV3Dz", "name": "Practicing 01", "author": "bmiles", "description": "Basic shader practice. Starting off copying whatever my friend 104 has done ;)", "tags": ["practice"], "likes": 1, "viewed": 92, "date": "1454045902", "time_retrieved": "2024-06-20T18:30:54.396289", "image_code": "// original: https://www.shadertoy.com/view/ltBGzt\n\nvec4 rgb(int r, int g, int b)\n{\n    return vec4(float(r)/255., float(g)/255., float(b)/255., 1);\n}\n\nvec4 circle(vec2 uv, vec2 origin, float radius, vec4 color)\n{\n    float d = length(uv - origin) - radius;// distance from uv to the edge of the circle.\n    \n//    float a = 1.0 - step(0., d);\n//    float delta = 0.006;\n    float delta = fwidth(d);\n    float a = 1.0 - smoothstep(-delta, delta, d);\n\n    return vec4(color.rgb, color.a * a);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.yy;\n    vec2 center = vec2(iResolution.x/iResolution.y*0.5, 0.5);\n    \n\tfragColor = rgb(251,199,38);\n \n    vec4 c2 = circle(uv, center + 0.3*vec2(cos(iTime), sin(iTime)), 0.1, rgb(3,72,51));\n\tfragColor = mix(fragColor, c2, c2.a);\n    \n    vec4 c1 = circle(uv, center, 0.3, rgb(204,1,46));\n\tfragColor = mix(fragColor, c1, c1.a);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/XdV3Dz.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "XdV3RD", "name": "WaveInterference", "author": "Varcho", "description": "simple illustration of wave interefence between two sources.", "tags": ["wave", "signal"], "likes": 3, "viewed": 112, "date": "1453508164", "time_retrieved": "2024-06-20T18:30:54.396289", "image_code": "#define LAMBDA 3.e-2\n#define PI 3.14159\n\nvec3 color(float v) {\n    float t = v/4.+.5;\n\treturn vec3(sin(PI/2. * t+.5),\n               1. - cos(PI/2. * t),\n               1. - cos(PI/2. * t - .3));\n}\n\nfloat destructiveDamp(float v) {\n\treturn smoothstep(.15, .0, abs(v));\n}\n\nfloat waveDampening(in vec2 p, in vec2 o) {\n\treturn exp(- LAMBDA * pow(distance(p, o), 2.));\n}\n\nfloat wave(in vec2 p, in vec2 o, float alpha) {\n\treturn waveDampening(p, o) * sin(10. * distance(p, o) - alpha);\n}    \n\nfloat interference(in vec2 pos,  float alpha) {\n\treturn wave(pos, vec2(5. * cos(iTime), 0.), alpha) \n        + wave(pos, vec2(-5. * cos(iTime), 0.), alpha);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float ar = iResolution.x/ iResolution.y;\n\tvec2 uv = 10.0 * vec2(ar * (fragCoord.x - iResolution.x / 2.)/iResolution.x,\n        \t\t\t(fragCoord.y - iResolution.y / 2.)/iResolution.y);\n    \n    float F = interference(uv, 20. * iTime);\n    vec3 col = color(F);\n    if (destructiveDamp(F) > 0.) {\n    \tcol = col * .6 + .4 * vec3(1., 0., 1.);\n    }   \n    fragColor = vec4(col, 1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/XdV3RD.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "XdV3Wh", "name": "RainShaderTest", "author": "yasuo", "description": "It's just rain experiment.", "tags": ["2d"], "likes": 5, "viewed": 622, "date": "1454259096", "time_retrieved": "2024-06-20T18:30:54.396289", "image_code": "const float PI = 3.14159265359;\nconst float DEG_TO_RAD = PI / 180.0;\n\n// from iq\nfloat sdSegment( in vec2 p, in vec2 a, in vec2 b )\n{\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\n\nvec2 rot(vec2 p, float a) {\n    return vec2(\n        cos(a) * p.x - sin(a) * p.y,\n        sin(a) * p.x + cos(a) * p.y);\n}\n\nfloat rand(vec2 co){\n    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    \n    vec3 cl = vec3(0.0);\n\tfloat time = iTime;\n\tint numrain = 10;\n    float speed = 0.1;\n    if(mod(time,10.0) >= 2.0 && mod(time,10.0) < 5.0) {\n        numrain = 20;\n        speed = 0.2;\n    } else if(mod(time,10.0) >= 5.0 && mod(time,10.0) < 8.0) {\n        numrain = 30;\n        speed = 0.25;\n    } else if(mod(time,10.0) >= 8.0 && mod(time,10.0) <= 10.0) {\n        numrain = 40;\n        speed = 0.4;\n    }\n\n    float l;\n    for(int i = 0; i<40; i++) {\n        if(i<numrain){\n            float dir = 1.0;\n            if (mod(float(i),2.0) == 1.0){\n                dir = -1.0;\n            }\n\n            float temp = rand(vec2(1.02,1.0+float(i)));\n            float temp2 = rand(vec2(1.02+float(i),1.01+float(i)*dir));\n\n            vec2 p0 = rot(vec2(-0.1+temp,0.1+temp2-tan(time*float(i)*speed)),DEG_TO_RAD*-15.0);\n            vec2 p1 = rot(vec2(-0.1+temp,0.4+temp2-tan(time*float(i)*speed)),DEG_TO_RAD*-15.0);\n\n            l = sdSegment(uv, p0, p1);\n            cl = mix( cl, vec3(1.0), 1.0-smoothstep( 0.001, 0.003, l ) );\n        }\n    }\n\n\n    fragColor = vec4( vec3( cl ), 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/XdV3Wh.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "XdVGDz", "name": "Gradient Dial", "author": "TheGrego", "description": "Growing gradient circle. Perfect for progress bars and countdown timers.", "tags": ["circle", "gradient", "progress", "dial"], "likes": 11, "viewed": 719, "date": "1454038730", "time_retrieved": "2024-06-20T18:30:54.814424", "image_code": "// static values\nconst float PI=3.14159265358979323846;\nconst float TAU = 6.28318530717958647692;\nconst float STEP_LENGTH = 0.01;\nconst float ANGLE_OFFSET = PI*0.5;\t\t\t\t// angle of dial\nconst vec4 color1 = vec4(1.0, 0.0, 0.0, 1.0);\nconst vec4 color2 = vec4(1.0, 1.0, 0.0, 1.0);\nconst float duration = 3.0;\t\t\t\t\t\t// duration of dial\n\n\n// Get the color value based on where in the circle the uv is\nvec4 getGradientValue(in vec2 uv)\n{\n    vec2 dist =\tvec2(1.0, 0.0) - vec2(-1.0, 0.0);\n\tfloat val = dot( uv - vec2(-1,0), dist ) / dot( dist, dist );\n\tclamp( val, 0.0, 1.0 );\n    \n\tvec4 color = mix( color1, color2, val );\n\t// clamp depending on higher alpha value\n\tif( color1.a >= color2.a )\n\t\tcolor.a = clamp( color.a, color2.a, color1.a );\n\telse\n\t\tcolor.a = clamp( color.a, color1.a, color2.a );\n\treturn color;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float progress = mod(iTime, duration) / duration;\n    float innerRadius = 0.5;\n    float outerRadius = 0.65;\n    float startAngle = 0.0;\n    float endAngle = progress* TAU;\n    vec2 uv = (2.0*fragCoord.xy - iResolution.xy)/iResolution.y;\n    float d = length( uv );\n    vec4 ioColor = getGradientValue(uv);    \n\n    // Perform adaptive anti-aliasing.\n    float w = fwidth( d ) * 1.0;\n    float c = smoothstep( outerRadius + w, outerRadius - w, d );\n    c -= smoothstep( innerRadius + w, innerRadius - w, d );\n    \n    // set color for the area within inner and outer radius\n    fragColor = vec4(ioColor.rgb * vec3(c), 1.0);\n\t\n    // limit to active progress\n    float angle = (atan(uv.y,uv.x)) + ANGLE_OFFSET;\n\tif( angle < 0.0 ) angle += PI * 2.0;\n    if( angle > endAngle){\n        float a = smoothstep( 0.75, -w*2.0,  abs(endAngle - angle) );        \n        //float a = smoothstep( 0.0, -w*2.0,  abs(endAngle - angle) );        \n        fragColor *= a;\n    }\n    if(angle - w*2.0 < startAngle ){\n        float a = smoothstep(  -w*2.0, w*2.0, (abs(startAngle - angle)) );\n        fragColor *= a;    \n    }\n    \n    /*\n    // round butt stuff\n\tfloat lineWidth = (outerRadius - innerRadius) * 0.5;\n    float midRadius = innerRadius + lineWidth;\n    \n   \t// distance from pt at end angle\n    vec2 endAnglePos = vec2( cos(endAngle-ANGLE_OFFSET), sin(endAngle-ANGLE_OFFSET)) * vec2(midRadius);\n    float dist = length( uv - endAnglePos );\n    float buttAlpha = smoothstep( lineWidth + w, lineWidth - w, dist );\n    fragColor = mix(fragColor, ioColor, buttAlpha );\n\n    // distance from pt at start angle\n    vec2 startAnglePos = vec2( cos(startAngle-ANGLE_OFFSET), sin(startAngle-ANGLE_OFFSET)) * vec2(midRadius);\n    dist = length( uv - startAnglePos );\n    buttAlpha = smoothstep( lineWidth + w, lineWidth - w, dist );\n    fragColor = mix(fragColor, ioColor, buttAlpha );\n\t*/\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/XdVGDz.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "XdVGzw", "name": "Day 004 - Soft Shadows", "author": "mwalczyk", "description": "Soft Shadows - Day 004", "tags": ["2d"], "likes": 3, "viewed": 323, "date": "1453742228", "time_retrieved": "2024-06-20T18:30:55.826605", "image_code": "// Much love / credit to @cabbibo for his SDF tutorial --> https://www.shadertoy.com/view/Xl2XWt\n\n#define PI 3.14159\n\nconst float MAX_TRACE_DIST = 20.0;\t// Max trace distance\nconst float MIN_HIT_DIST = 0.001;\t// Precision of the intersection\nconst int MAX_NUM_STEPS = 100;\t\t// Max number of steps we take along a ray\n\n// Polynomial smooth min (k = 0.1) and opBlend from IQ\n// http://www.iquilezles.org/www/articles/smin/smin.htm\nfloat smin(float a, float b, float k)\n{\n    float h = clamp(0.5 + 0.5 * (b - a) / k, 0.0, 1.0);\n    return mix(b, a, h) - k * h * (1.0 - h);\n}\n\nfloat opBlend(float a, float b)\n{\n    // Added this for the animation\n    float k = (sin(iTime * 4.0) + 1.0) / 2.0;\n    k = max(0.2, k);\n\n\treturn smin(a, b, k);\n}\n\nvec2 opU( vec2 a, vec2 b )\n{\n\treturn (a.x < b.x) ? a : b;\n}\n\nfloat sdPlane(in vec3 p)\n{\n\treturn p.y;\n}\n\nfloat sdSphere(in vec3 p, float s)\n{\n  \t// Domain deformation based on sinusoidal funcs\n    // See IQ's website, per-usual...guy is a genius!\n  \tfloat freq = 4.0 * pow(sin(iTime), 2.0);\n    float d1 = length(p) - s;\n  \tfloat d2 = 0.3*sin(freq * p.x) * sin(freq * p.y + 0.8) * sin(freq * p.z + 0.3); \n  \n   \treturn d1 + d2;\n}\n\nvec2 map(in vec3 pos)\n{\n    // This is where we actually define all of the properties of \n    // the objects in our scene and perform any unions, intersections, \n    // deformations, etc.\n    \n    float sphere1 = sdSphere(pos - \tvec3(0.5, 0.0, 0.0), \t1.5);\n    float sphere2 = sdSphere(pos - \tvec3(-0.5, 0.0, 0.0), \t1.5);\n\n    vec2 res = vec2( \t  sdPlane(pos - vec3(0.0, -2.0, 0.0)),       1.0 ); \n    res = opU( res, vec2( opBlend(sphere1, sphere2), \t\t\t\t 2.0 ));\n    \n    return res;\n}\n\nfloat softshadow( in vec3 ro, in vec3 rd, in float mint, in float tmax )\n{\t\n    // min and max are 0.02 and 2.5\n\tfloat res = 1.0;\n    float t = mint;\n    for(int i = 0; i < 16; ++i)\n    {\n\t\tfloat h = map(ro + rd * t).x;\n        res = min(res, 8.0 * h / t);\t// 8.0 seems to control the softness\n        t += clamp(h, 0.02, 0.10);\n        if(h < 0.001 || t > tmax) break;\n    }\n    return clamp( res, 0.0, 1.0 );\n\n}\n\n// Calculate the normal of the surface at position pos\nvec3 calcNormal(in vec3 pos)\n{\n    vec3 eps = vec3(0.001, 0.0, 0.0);\n\tvec3 nor = vec3(\n\t    map(pos+eps.xyy).x - map(pos-eps.xyy).x,\n\t    map(pos+eps.yxy).x - map(pos-eps.yxy).x,\n\t    map(pos+eps.yyx).x - map(pos-eps.yyx).x);\n\treturn normalize(nor);\n}\n\n// Calculate intersections\nvec2 calcIntersection(in vec3 ro, in vec3 rd)\n{\n    // This is where we do the actual \"marching\"\n    \n    float h =  MIN_HIT_DIST * 2.0;\t// Distance to the closest surface, which we overwrite each iteration\n    float t = 0.0;\t\t\t\t\t// Total distance traveled along the ray\t\t\t\t\t\t\n\tfloat finalDist = -1.0;\t\t\t// We haven't hit anything yet, so make this negative\n    float id = -1.0;\t\t\t\t// We haven't hit anything yet, so make this negative\n    \n    for(int i = 0; i < MAX_NUM_STEPS; ++i)\n    {\n        // Are we close enough to the surface? OR\n        // Have we traveled far enough to safely say we won't hit anything?\n    \tif(h < MIN_HIT_DIST || t > MAX_TRACE_DIST) break;\n        \n        vec2 distToClosest = map(ro + rd * t);\n        h = distToClosest.x;\t// The distance\n        id = distToClosest.y;\t// The object id\n        t += h;\t\t\t\t\t// Clever optimization: see literature on \"Distance Aided Raymarching\"\n    }\n    \n    if(t < MAX_TRACE_DIST) finalDist = t;\n    if(t > MAX_TRACE_DIST) id = -1.0;\n    return vec2(finalDist, id);\n}\n\n// Calculate the color at the ray position\nvec3 render(in vec3 ro, in vec3 rd, in vec2 uv)\n{\n    // Make a corny ass background gradient\n    float ssDistToCenter = length(uv);\n    vec3 bgColor1 = vec3(0.6, 0.2, 0.9);\n    vec3 bgColor2 = vec3(0.0, 0.2, 0.8); \n    vec3 surfaceColor = vec3(0.7, 0.9, 1.0) + rd.y * 0.8;\n    \n    vec2 results = calcIntersection(ro, rd);\n    float t = results.x;\t\t\t\t\t\t// Where along our ray did we hit?\n    float id = results.y;\t\t\t\t\t\t// What did we hit?\n    \n    if(t > -0.5)\n    {\n    \t// Here, we could use the 'id' to change lighting / material \n   \t\t// params on a per-object basis\n   \t\tvec3 lightPos = vec3(1.0, 4.0, 3.0);\n   \t \tvec3 pos = ro + rd * t;\n        \n        vec3 n = calcNormal(pos);\n        vec3 diffColor = vec3(0.8, 0.0, 0.1);\n        \n        if( id < 1.5 )\n        {    \n            // The only object that has an 'id' less than 1.5 is the floor\n            float f = mod( floor(5.0 * pos.z) + floor(5.0 * pos.x), 2.0);\n            diffColor = 0.4 + 0.1 * f * vec3(1.0);\n        }\n    \t\n    \tvec3 l = normalize(lightPos - pos);       \n    \tfloat diffStrength = max(dot(n, l), 0.0);\n        float ambientStrength = clamp(0.5 + 0.5 * n.y, 0.0, 1.0);\n        vec3 ambientColor = vec3(0.50,0.70,1.00);\n        \n    \tdiffColor *= softshadow( pos, lightPos, 0.02, 2.5 );\n        ambientColor *= ambientStrength * 0.2;\n        \n    \tsurfaceColor = diffStrength * diffColor + ambientColor;\n        \n    }\n    \n    return surfaceColor;\n}\n    \nmat3 setCamMatrix(in vec3 ro, in vec3 ta, float roll)\n{\n\tvec3 ww = normalize(ta - ro);\t// Look-at direction, normalized\n    vec3 uu = normalize(cross(ww, vec3(sin(roll), cos(roll), 0.0)));\n    vec3 vv = normalize(cross(uu, ww));\n    return mat3(uu, vv, ww);    \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Need to review this calculation...\n   \tvec2 p = (-iResolution.xy + 2.0 * fragCoord.xy) / iResolution.y;\n\n    float radius = 7.0;\n    float camX = radius * cos(iTime * 0.5);\n    float camZ = radius * sin(iTime * 0.5);\n   \n    vec3 ro = vec3(camX, 0.0, camZ);\t\t\t\t\t\t\t\t\t// Ray origin\n\tvec3 ta = vec3(0.0);\t\t\t\t\t\t\t\t\t\t\t// Look-at position\n    mat3 cameraMatrix = setCamMatrix(ro, ta, 0.0);\t\t\t\t\t// Position, look-at, roll\n    \n    float lensLength = 2.0;\n    vec3 rd = normalize(cameraMatrix * vec3(p.xy, lensLength));\t\t// Ray direction\n    \n    vec3 color = render(ro, rd, p);\n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/XdVGzw.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "Xdy3Rw", "name": "Sphere Intersection", "author": "Ramocles", "description": "Simple show on the result of two spheres intersecting. The intersection is drawn as a red torus. Use the mouse in order to rotate the camera.", "tags": ["3draymarching", "ik", "sphereintersection"], "likes": 1, "viewed": 89, "date": "1453599660", "time_retrieved": "2024-06-20T18:30:57.032784", "image_code": "// Created by Ramon Viladomat\n\n// Quick visualizer for 2 sphere intersection. \n\n// Sphere positons and radius here ( the movement is performed in line 50 )\n\nvec3 position1 = vec3(0.0,0.0,0.0);\nfloat radius1 = 0.8;\n\nvec3 position2 = vec3(1.0,1.0,1.0);\nfloat radius2 = 0.5;\n\nvec3 resultPosition = vec3(0.0);\nvec3 resultNormal   = vec3(0.0,1.0,0.0);\nvec3 resultLeft     = vec3(1.0,0.0,0.0);\nvec3 resultFwd      = vec3(0.0,0.0,1.0);\nfloat resultRadius  = 1.0;\nfloat resultWidth   = 0.01;\n\nvoid updateIntersection()\n{\n    vec3 AtoB = position2 - position1; \n    float dist = length(AtoB);\n    if (dist > 0.0)\n    {\n    \tfloat planeDist = ((radius1*radius1)-(radius2*radius2)+(dist*dist))/(2.0*dist);\n    \tfloat resultRadiusSqr = (radius1*radius1)-(planeDist*planeDist);\n    \n    \tif (resultRadiusSqr >= 0.0)\n    \t{\n        \tresultRadius = sqrt(resultRadiusSqr);\n            resultWidth  = 0.02;\n            \n            resultNormal   = normalize(AtoB);\n            resultPosition = position1 + resultNormal*planeDist;\n    \t}\n        else\n        {\n            resultWidth = 0.0;\n        }\n    }\n    else\n    {\n        resultWidth = 0.0;\n    }\n}\n\nvoid updateWorld()\n{\n    position2 = vec3(sin(iTime),sin(iTime*0.76),sin(iTime*0.24));\n    \n    updateIntersection();\n    resultLeft = normalize(cross(vec3(0.0,1.0,0.0),resultNormal)); \n    resultFwd  = normalize(cross(resultLeft,resultNormal)); \n}\n\n// PRIMITIVES\n\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\nfloat sdSphere( vec3 p, float radius)\n{\n  \treturn length(p)-radius;\n}\n\n//--------------------------------------------------------------------------\nvec2 mapBg( in vec3 p)\n{\n\t//background room shape\n\tvec3 q = p; \n\tq.xz = abs(q.xz); \n\treturn vec2(min(min(p.y + 1.5,10.0 - p.y),min(10.0-q.z,10.0-q.x)),3.0);\n}\n\n//--------------------------------------------------------------------------\nvec2 map( in vec3 p )\n{\t\n\tvec2 sphere1 = vec2(sdSphere( p-position1, radius1 ), 1.0);\n    vec2 sphere2 = vec2(sdSphere( p-position2, radius2 ), 2.0);\n    vec2 bg      = mapBg(p);\n\t\n    vec3 q = p - resultPosition;\n    vec3 q2 = vec3(dot(q,resultLeft),dot(q,resultNormal),dot(q,resultFwd));\n    vec2 intersection = vec2(sdTorus(q2,vec2(resultRadius,resultWidth)),4.0);\n    \n    vec2 res = sphere1;\n    if (res.x > sphere2.x)      res = sphere2; \n    if (res.x > bg.x)           res = bg;\n    if (res.x > intersection.x) res = intersection;\n    \n    return res;\n}\n\nvec2 intersect( in vec3 ro, in vec3 rd )\n{\n\tfloat maxd = 25.0;\n\tfloat precis = 0.001;\n    float h=precis*2.0;\n    float t = 0.0;\n    float m = -1.0;\n    for( int i=0; i<150; i++ )\n    {\n        if( abs(h)<precis||t>maxd ) continue;//break;\n        t += h;\n\t    vec2 res = map( ro+rd*t );\n        h = res.x;\n\t    m = res.y;\n    }\n\n    if( t>maxd ) m=-1.0;\n    return vec2( t, m );\n}\n\n// MATERIALS\n\nvec4 calcBgColor( in vec3 pos, in vec3 nor)\n{\n    vec3 groundtiles = 2.0*(0.5 - abs(0.5-mod(pos,vec3(0.89)))); \n\tfloat groundtileBorder = smoothstep(0.0,0.1,min(groundtiles.x,min(groundtiles.y,groundtiles.z)));//min(groundtiles.x,min(groundtiles.y,groundtiles.z)));\n\treturn groundtileBorder*vec4(0.2,0.2,0.2,0.2); \n}\n\nvec4 calcColor( in vec3 pos, in vec3 nor, float matID )\n{\n\tvec4 mate = vec4(0.0);\n\n    if (matID > 0.5) mate = vec4(0.0,0.2,0.2,0.05);\n    if (matID > 1.5) mate = vec4(0.0,0.2,0.0,0.05);\n    if (matID > 2.5) mate = calcBgColor(pos,nor);\n    if (matID > 3.5) mate = vec4(0.2,0.0,0.0,0.05);;\n\t\n\treturn mate;\n}\n\nvec3 calcNormal( in vec3 pos) \n{\n    vec3 e = vec3(0.0,0.0002,0.0);\n\tfloat d = map(pos).x;\n    return normalize(vec3( map(pos+e.yxx).x-d, map(pos+e.xyx).x-d, map(pos+e.xxy).x-d) );\t\n}\n\nfloat softShadow( in vec3 ro, in vec3 rd, float mint, float k )\n{\n    float res = 1.0;\n    float t = mint;\n    for( int i=0; i<45; i++ )\n    {\n        float h = map(ro + rd*t).x;\n        res = min( res, k*h/t );\n        t += clamp( h, 0.04, 0.1 );\n    }\n    return clamp(res,0.0,1.0);\n}\n\n//IQ ray-marched ambient occlusion algorithm \nfloat ambientOcclusion( in vec3 pos, in vec3 nor )\n{\n\tfloat totao = 0.0;\n    float sca = 1.0;\n    for( int aoi=0; aoi<8; aoi++ )\n    {\n        float hr = 0.01 + 1.2*pow(float(aoi)/8.0,1.5);\n        vec3 aopos =  nor * hr + pos;\n        float dd = map( aopos ).x;\n        totao += -(dd-hr)*sca;\n        sca *= 0.85;\n    }\n    return clamp( 1.0 - 0.6*totao, 0.0, 1.0 );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = -1.0 + 2.0 * fragCoord.xy / iResolution.xy;\n    p.x *= iResolution.x/iResolution.y;\n\n    // update world\n    updateWorld();\n    \n    // camera\n\tvec2 mousePos = iMouse.xy/iResolution.xy;\n\t\n\tfloat camAngle = -3.1415*2.0*mousePos.x;\n\tfloat camDist = 2.0+((1.0-mousePos.y)*2.0); \n\t\n    vec3 camPosition = camDist*normalize(vec3(sin(camAngle), 0.5, cos(camAngle)));\n    vec3 camTarget\t = vec3( 0.0, 0.0, 0.0 );\n    vec3 camFront \t = normalize( camTarget - camPosition );\n    vec3 camRight \t = normalize( cross(camFront,vec3(0.0,1.0,0.0) ) );\n    vec3 camUp \t\t = normalize( cross(camRight,camFront));\n    vec3 rayDir \t = normalize( p.x*camRight + p.y*camUp + 2.0*camFront );\n\n\t// render\n    vec3 color = vec3(0.0);\n\tfloat attenuation = 1.0;\n\tfor( int k=0; k<2; k++ )\n\t{\n        // raymarch\n        vec2 tmat = intersect(camPosition,rayDir);\n        if( tmat.y>-0.5 )\n        {\n            // geometry\n            vec3 position \t= camPosition + tmat.x*rayDir;\n            vec3 normal \t= calcNormal(position);\n            vec3 reflDir \t= reflect(rayDir,normal);\n\n            // material\n            vec4 mate = calcColor( position, normal, tmat.y );\n            normal = normalize( normal );\n\n            //ambient occlusion\n\t\t\tfloat occlusion = ambientOcclusion( position, normal );\n            \n            // lights\n            vec3 lightDir \t= normalize(vec3(-0.5,2.0,-1.0));\n\n            float ambient  = 0.6 + 0.4*normal.y;\n            float diffuse  = max(dot(normal,lightDir),0.0);\n            float specular = pow(clamp(dot(lightDir,reflDir),0.0,1.0),3.0);\n            float shadow   = softShadow( position, lightDir, 0.01, 10.0 );\n        \n            \n            color += attenuation*mate.xyz*occlusion;\n            color += attenuation*10.0*mate.w*mate.w*(0.5+0.5*mate.xyz)*specular*shadow*vec3(1.0,0.95,0.9);\n\n            attenuation *= 2.0*mate.w;\n            camPosition = position + 0.001*normal;\n            rayDir = reflDir;\n        }\n\t}\n\t\n\t// desat\n\tcolor = mix( color, vec3(dot(color,vec3(0.33))), 0.3 );\n\t\n    // gamma\n\tcolor = pow( color, vec3(0.45) );\n\n\t// tint\n\tcolor *= vec3(1.0,1.04,1.0);\n\n    fragColor = vec4( color,1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/Xdy3Rw.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "Xdy3Wh", "name": "Mondrian pong", "author": "FabriceNeyret2", "description": " reproducing http://33.media.tumblr.com/tumblr_mafojfoHoJ1rvbw2yo1_400.gif \n:-)", "tags": ["pong", "gif", "mondrian", "reproduction"], "likes": 11, "viewed": 947, "date": "1454123256", "time_retrieved": "2024-06-20T18:30:57.226734", "image_code": "// reproducing http://33.media.tumblr.com/tumblr_mafojfoHoJ1rvbw2yo1_400.gif\n\nvoid mainImage( out vec4 O,  vec2 U )\n{\n    vec2 R = iResolution.xy, L;\n\tU = 100.* (U+U-R)/R.y;\n    \n    float B = 1.,                   // border size\n          t = iTime;\n    vec2 P  = mod(t/vec2(1,2),2.); P = 2.*min(P,2.-P)-1.; // ball trajectory\n    vec2 P2 = 50.*P,               // ball\n         L2 = vec2(15,12),\n         L0 = vec2(15,45),         // left pad\n         P0 = vec2(-80,P2.y*.7), \n         L1 = vec2(15,45),         // right pad\n         P1 = vec2( 80,-P2.y*.7);\n     \n    \n    O-=O;\n#define box(P,S,C) L = abs(U-P)/S; if (max(L.x,L.y)<1.)  { O = C; return; }\n    box( P0, L0, vec4(1,0,0,1) );\n    box( P1, L1, vec4(0,0,1,1) );\n    box( P2, L2, vec4(1,1,0,1) );\n    \n#define lines(P,S)  L = abs(U-P-(S))/B; if (min(L.x,L.y)<1.)   return; \n    lines( P0, L0+B); lines(P0,-L0-B); \n    lines( P1, L1+B); lines(P1,-L1-B); \n    lines( P2, L2+B); lines(P2,-L2-B); \n    O++;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/Xdy3Wh.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "XdyGRw", "name": "Thing spawner", "author": "Tsarpf", "description": "VR enabled ray marching thing.", "tags": ["raymarching"], "likes": 2, "viewed": 141, "date": "1453586844", "time_retrieved": "2024-06-20T18:30:58.717944", "image_code": "float sdSphere( vec3 p, float s )\n{\n  return length(p)-s;\n}\n\nfloat lengthRound(vec3 p)\n{\n\tfloat n = 1.7;\n\treturn pow(pow(p.x,n) + pow(p.y,n) + pow(p.z,n), 1.0/n);\n}\n\nfloat smin( float a, float b, float k )\n{\n    float res = exp( -k*a ) + exp( -k*b );\n    return -log( res )/k;\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  \n  //float lengthRounded = lengthRound(max(d,0.0));\n  //return min(max(d.x,max(d.y,d.z)),0.0) + lengthRounded;\n  return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\nvec3 repeatPos(vec3 p, vec3 c)\n{\n\treturn mod(p,c)-.5 * c;\n}\n\nfloat getDistance(vec3 position)\n{\t\n    vec3 pos = vec3\n        (\n            (position.x + 5.0 * sin(iTime)) - 2.0,\n            position.y + 5.0 * cos(iTime),\n            position.z - 1.5\n        );\n    \n    vec3 pos2 = vec3\n        (\n            (position.x + 5.0 * sin(iTime)) - 2.0,\n            position.y + 5.0 * cos(iTime),\n            position.z - 1.5\n        );\n    vec3 pos3 = vec3\n        (\n            position.x + 45.,\n            position.y - 52. - iTime * 5.,\n            position.z + 55.0\n        );\n    //vec3 pos3 = vec3(position.x + 1.8 * sin(iTime - 3.3) + 0.2, position.y + 1.8 * cos(iTime - 3.3), position.z - 0.5);\n  \n    vec3 floorPos = vec3\n        (\n            position.x,\n            position.y + 5.0,\n            position.z\n        );\n    \n    vec3 wallPos = vec3\n        (\n            position.x,\n            position.y + 5.0,\n            position.z - 25.\n        );\n    \n    pos3 = repeatPos(pos3, vec3(15.,15.,15.));\n    \n    //float dis1 = sdSphere(pos, 2.0);\n    \n    //float dis2 = sdSphere(pos2, 1.33);\n    //float dis2 = sdBox(pos2, vec3(1.5, 1.5, 1.5));\n    float floorDis = sdBox(floorPos, vec3(300, 1, 300));\n    float wallDis = sdBox(wallPos, vec3(300, 100, 1));\n    \n    \n    \n    float sphereDis = sdSphere(pos3, 1.);\n    //float sphereDis = sdBox(pos3, vec3(1., 1., 1.));\n  \n    \n    // distance = smin(dis1, dis2, 1.0);\n    float distance = smin(floorDis, sphereDis, 1.0);\n    \n    distance = smin(distance, floorDis, 0.5);\n    distance = min(distance, wallDis);\n   \n  \n    \n    //return dis1;\n    return distance;\n    //return dis3;\n    \n    \n    //return sdSphere(pos, 2.0);\n    //Repeat shape\n\t//vec3 repPos = repeatPos(position, vec3(5.0,20.0,4.5));\n    \n    //Draw cubes\n\t//return sdBox(repPos, vec3(1.,1.,1.));\n\t\n    //Draw spheres\n\t//return sdSphere(repPos, 1.0);\n}\n\nvec4 getColor(vec3 position)\n{\n\tfloat e = 0.001;\n\tfloat f0 = getDistance(position);\n\t\n    //Approximate the normal by stepping a minimal amount in each of the axes' direction\n\tfloat fx = getDistance(vec3(position.x + e, position.y, position.z));\n\tfloat fy = getDistance(vec3(position.x, position.y + e, position.z));\n\tfloat fz = getDistance(vec3(position.x, position.y, position.z + e));\n\t\n\t\n\t\n\tvec3 normal = normalize(vec3(fx - f0, fy - f0, fz - f0));\n\tvec3 lightPosition = vec3\n\t\t(\n\t\t\t0.0, //+ 12.0*sin(iTime*1.0),\n\t\t\t20.0, //+ 12.0*sin(iTime*2.0),\n            -5.0\n            //iTime * 20.0\n            \n            //-1.0 - sin(iTime) * 2.0\n\t\t\t//280.0 + 300.0*sin(iTime*1.0) //Make the light move on the z axis\n\t\t\t//iTime * 5.0 + 100.0\n\t\t);\n\tvec3 lightDir = normalize(lightPosition - position);\n    /*\n\tvec4 lightColor = vec4\n        (\n            (sin(iTime * 0.1) + 0.5)/ 25.0 + 0.1,\n            (sin(iTime / 1.1) + 1.5)/ 25.0 + 0.1,\n            (cos(iTime * 0.1) + 0.5)/ 25.0 + 0.1,\n            //0.5 * tan(iTime),\n            //0.5 - 0.5 * sin(iTime),\n            //0.5 - 0.5 * cos(iTime),\n            0.2);\n    */\n    vec4 lightColor = vec4\n        (\n            0.15,\n            0.2,\n            0.3,\n            //0.5 * tan(iTime),\n            //0.5 - 0.5 * sin(iTime),\n            //0.5 - 0.5 * cos(iTime),\n            0.2);\n\tvec4 lightIntensity = lightColor * dot(normal, lightDir);\n\tfloat reflectance = 0.5;\n\t\n\tfloat lightDistance = length(position-lightPosition);\n    \n    //Hacky but pretty good looking light intensity diminishing over distance\n\t//float distanceIntensity = (1.0 / (pow(lightDistance / 100.0, 1.1))); \n    float distanceIntensity = (5.0 / (pow(lightDistance / 25.0, 1.0001))); \n\t\n\treturn reflectance * lightIntensity * (distanceIntensity);\n\t\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //Moving eye position, bugs on some weaker hardware and just shows grey as mentioned in the omments\n    //vec3 eye = vec3(0, 3, iTime * 20.0 - 50.0);\n    \n    //Still eye\n\tvec3 eye = vec3(0, 0, -15);\n\t//eye.z = -1.0*sin(iTime);\n    vec3 up = vec3(0, 1, 0);\n    vec3 right = vec3(1, 0, 0);\n    \n    //Epsilon for when we are close enough to a surface to decide the surface is right here\n    float epsilon = 0.1;\n    float maxDistance = 10000.0;\n\n\t//Normalized device coordinates\n\tvec2 ndcXY = -1.0 + 2.0 * fragCoord.xy / iResolution.xy;\n\t\n\t// aspect ratio\n\tfloat aspectRatio = iResolution.x / iResolution.y;\n\t\n\t// scaled XY which fits the aspect ratio\n\tvec2 uv = ndcXY * vec2( aspectRatio, 1.0 );\n\t//uv.y += (0.07 * sin(uv.x + iTime*4.0));\n\n\t\n    \n    //Variables needed for ray marching this pixel\n    float focalLength = 1.0;\n    vec3 forward = normalize(cross(right, up));\n    \n    vec3 planePos = right * uv.x + up * uv.y;\n\t\n    vec3 pImagePlane = eye + forward * focalLength + planePos;\n    vec3 rayDirection = normalize(pImagePlane - eye);\n\n\t// Sky color\n    vec4 color = vec4\n\t\t(\n\t\t\t0.30,\n\t\t\t0.30,\n\t\t\t0.30,\n\t\t\t1\n\t\t); \n\n    float t = 0.0;\n    const float maxSteps = 512.0;\n    for(float i = 0.0; i < maxSteps; ++i)\n    {\n        vec3 p = pImagePlane + rayDirection * t;\n\t\tfloat d = getDistance(p);\n\t\tif(d > maxDistance) {break;}\n        if(d < epsilon)\n        {\n\t\t\n            //Fixed color, no shading\n\t\t\t//color = vec4(i*0.1+0.1,0.5,0,1);\n            \n            //Shade this surface\n\t\t\tcolor = getColor(p);\n            break;\n        }\n\t\t//March forward by the distance to the closest surface to current point in space\n        t += d;\n    }\n\n    fragColor = color;\n}\n\nvoid mainVR( out vec4 fragColor, in vec2 fragCoord, in vec3 fragRayOri, in vec3 fragRayDir)\n{    \n    //Still eye\n\tvec3 eye = vec3(0, 0, -15);\n\t//eye.z = -1.0*sin(iTime);\n    vec3 up = vec3(0, 1, 0);\n    vec3 right = vec3(1, 0, 0);\n    //Epsilon for when we are close enough to a surface to decide the surface is right here\n    float epsilon = 0.1;\n    float maxDistance = 100000.0;\n\n\t//Normalized device coordinates\n\tvec2 ndcXY = -1.0 + 2.0 * fragCoord.xy / iResolution.xy;\n\t\n\t// aspect ratio\n\tfloat aspectRatio = iResolution.x / iResolution.y;\n\t\n\t// scaled XY which fits the aspect ratio\n\tvec2 uv = ndcXY * vec2( aspectRatio, 1.0 );\n\t//uv.y += (0.07 * sin(uv.x + iTime*4.0));\n\n\t\n    \n    //Variables needed for ray marching this pixel\n    float focalLength = 1.0;\n    vec3 forward = normalize(cross(right, up));\n    \n    vec3 planePos = right * uv.x + up * uv.y;\n\t\n    vec3 pImagePlane = eye + forward * focalLength + planePos;\n    //vec3 rayDirection = normalize(pImagePlane - eye);\n    vec3 rayDirection = -fragRayDir;\n\n\t// Sky color\n    vec4 color = vec4\n\t\t(\n\t\t\t0.30,\n\t\t\t0.30,\n\t\t\t0.30,\n\t\t\t1\n\t\t); \n\n    float t = 0.0;\n    const float maxSteps = 512.0;\n    for(float i = 0.0; i < maxSteps; ++i)\n    {\n        vec3 p = pImagePlane + rayDirection * t;\n\t\tfloat d = getDistance(p);\n\t\tif(d > maxDistance) {break;}\n        if(d < epsilon)\n        {\n\t\t\n            //Fixed color, no shading\n\t\t\t//color = vec4(i*0.1+0.1,0.5,0,1);\n            \n            //Shade this surface\n\t\t\tcolor = getColor(p);\n            break;\n        }\n\t\t//March forward by the distance to the closest surface to current point in space\n        t += d;\n    }\n\n    fragColor = color;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/XdyGRw.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "Xs33Df", "name": "Desert Canyon", "author": "Shane", "description": "Traversing a desert canyon.", "tags": ["raymarching", "tunnel", "terrain", "sky"], "likes": 258, "viewed": 11513, "date": "1452775785", "time_retrieved": "2024-06-20T18:31:01.639370", "image_code": "/*\n\tDesert Canyon\n\t-------------\n\n\tJust a simple canyon fly through. Since the laws of physics aren't adhered to (damn stray floating \n\trocks), you can safely assume the setting is a dry, rocky desert on a different planet... in an \n\talternate reality. :)\n\n\tI thought I'd do a daytime scene for a change. I like the way they look, but I find they require\n\tmore effort to light up correctly. In this particular example, I had to find the balance between\n\tindoor and outdoor lighting, but keep it simple enough to allow reasonable frame rates for swift \n\tcamera movement. For that reason, I was really thankful to have some of Dave Hoskins's and IQ's \n\texamples to refer to.\n\n\tThe inspiration for this particular scene came from Dr2's flyby examples. This is obviously less\n\tcomplicated, since his involve flybys with actual planes. Really cool, if you've never seen them.\n\n\tAnyway, I'll put up a more interesting one at a later date.\n\t\n\n\tOutdoor terrain shaders:\n\n\tElevated - iq\n\thttps://www.shadertoy.com/view/MdX3Rr\n\tBased on his (RGBA's) famous demo, Elevated.\n\thttp://www.pouet.net/prod.php?which=52938\n\n\t// How a canyon's really done. :)\n\tCanyon - iq\n\thttps://www.shadertoy.com/view/MdBGzG\n\n\t// Too many good ones to choose from, but here's one.\n\t// Mountains - Dave_Hoskins\n\thttps://www.shadertoy.com/view/4slGD4\n\n\t// Awesome.\n    River Flight - Dr2\n    https://www.shadertoy.com/view/4sSXDG\n\n*/\n\n// The far plane. I'd like this to be larger, but the extra iterations required to render the \n// additional scenery starts to slow things down on my slower machine.\n#define FAR 65.\n\n// Frequencies and amplitudes of the \"path\" function, used to shape the tunnel and guide the camera.\nconst float freqA = .15/3.75;\nconst float freqB = .25/2.75;\nconst float ampA = 20.;\nconst float ampB = 4.;\n\n// 2x2 matrix rotation. Angle vector, courtesy of Fabrice.\nmat2 rot2( float th ){ vec2 a = sin(vec2(1.5707963, 0) + th); return mat2(a, -a.y, a.x); }\n\n// 1x1 and 3x1 hash functions.\nfloat hash(float n){ return fract(cos(n)*45758.5453); }\nfloat hash(vec3 p){ return fract(sin(dot(p, vec3(7, 157, 113)))*45758.5453); }\n\n// Grey scale.\nfloat getGrey(vec3 p){ return dot(p, vec3(0.299, 0.587, 0.114)); }\n\n/*\n// IQ's smooth minium function. \nfloat sminP(float a, float b , float s){\n    \n    float h = clamp(.5 + .5*(b - a)/s, 0., 1.);\n    return mix(b, a, h) - h*(1.0-h)*s;\n}\n*/\n\n// Smooth maximum, based on the function above.\nfloat smaxP(float a, float b, float s){\n    \n    float h = clamp(.5 + .5*(a - b)/s, 0., 1.);\n    return mix(b, a, h) + h*(1. - h)*s;\n}\n\n// The path is a 2D sinusoid that varies over time, depending upon the frequencies, and amplitudes.\nvec2 path(in float z){ return vec2(ampA*sin(z * freqA), ampB*cos(z * freqB) + 3.*(sin(z*0.025)  - 1.)); }\n\n// The canyon, complete with hills, gorges and tunnels. I would have liked to provide a far\n// more interesting scene, but had to keep things simple in order to accommodate slower machines.\nfloat map(in vec3 p){\n    \n    // Indexing into the pebbled texture to provide some rocky surface detatiling. I like this\n    // texture but I'd much rather produce my own. From what I hear, Shadertoy will be providing\n    // fixed offscreen buffer sizes (like 512 by 512, for instance) at a later date. When that\n    // happens, I'll really be able to do some damage. :)\n    float tx = textureLod(iChannel0, p.xz/16. + p.xy/80., 0.).x;\n  \n    // A couple of sinusoidal layers to produce the rocky hills.\n    vec3 q = p*.25;\n    float h = dot(sin(q)*cos(q.yzx), vec3(.222)) + dot(sin(q*1.5)*cos(q.yzx*1.5), vec3(.111));\n    \n    \n    // The terrain, so to speak. Just a flat XZ plane, at zero height, with some hills added.\n    float d = p.y + h*6.;\n  \n    // Reusing \"h\" to provide an undulating base layer on the tunnel walls.\n    q = sin(p*.5 + h);\n    h = q.x*q.y*q.z;\n  \n\t// Producing a single winding tunnel. If you're not familiar with the process, this is it.\n    // We're also adding some detailing to the walls via \"h\" and the rocky \"tx\" value.\n    p.xy -= path(p.z);\n    float tnl = 1.5 - length(p.xy*vec2(.33, .66)) + h + (1. - tx)*.25;\n\n\t// Smoothly combine the terrain with the tunnel - using a smooth maximum - then add some\n    // detailing. I've also added a portion of the tunnel term onto the end, just because\n    // I liked the way it looked more. \n    return smaxP(d, tnl, 2.) - tx*.5 + tnl*.8; \n\n}\n\n\n// Log-Bisection Tracing\n// https://www.shadertoy.com/view/4sSXzD\n//\n// Log-Bisection Tracing by nimitz (twitter: @stormoid)\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n// Contact: nmz@Stormoid.com\n//\n// Notes: This is a trimmed down version of Nitmitz's original. If you're interested in the function \n// itself, refer to the original function in the link above. There, you'll find a good explanation as to \n// how it works too.\n//\n// For what it's worth, I've tried most of the standard raymarching methods around, and for difficult \n// surfaces to hone in on, like the one in this particular example, \"Log Bisection\" is my favorite.\n\nfloat logBisectTrace(in vec3 ro, in vec3 rd){\n\n\n    float t = 0., told = 0., mid, dn;\n    float d = map(rd*t + ro);\n    float sgn = sign(d);\n\n    for (int i=0; i<96; i++){\n\n        // If the threshold is crossed with no detection, use the bisection method.\n        // Also, break for the usual reasons. Note that there's only one \"break\"\n        // statement in the loop. I heard GPUs like that... but who knows?\n        if (sign(d) != sgn || d < 0.001 || t > FAR) break;\n \n        told = t;\n        \n        // Branchless version of the following:   \n        // if(d>1.) t += d; else t += log(abs(d) + 1.1);     \n        t += step(d, 1.)*(log(abs(d) + 1.1) - d) + d;\n        //t += log(abs(d) + 1.1);\n        //t += d;//step(-1., -d)*(d - d*.5) + d*.5;\n        \n        d = map(rd*t + ro);\n    }\n    \n    // If a threshold was crossed without a solution, use the bisection method.\n    if (sign(d) != sgn){\n    \n        // Based on suggestions from CeeJayDK, with some minor changes.\n\n        dn = sign(map(rd*told + ro));\n        \n        vec2 iv = vec2(told, t); // Near, Far\n\n        // 6 iterations seems to be more than enough, for most cases...\n        // but there's an early exit, so I've added a couple more.\n        for (int ii=0; ii<8; ii++){ \n            //Evaluate midpoint\n            mid = dot(iv, vec2(.5));\n            float d = map(rd*mid + ro);\n            if (abs(d) < 0.001)break;\n            // Suggestion from movAX13h - Shadertoy is one of those rare\n            // sites with helpful commenters. :)\n            // Set mid to near or far, depending on which side we're on.\n            iv = mix(vec2(iv.x, mid), vec2(mid, iv.y), step(0.0, d*dn));\n        }\n\n        t = mid; \n        \n    }\n    \n\n    return min(t, FAR);\n}\n\n\n// Tetrahedral normal, courtesy of IQ.\nvec3 normal(in vec3 p)\n{  \n    vec2 e = vec2(-1, 1)*.001;   \n\treturn normalize(e.yxx*map(p + e.yxx) + e.xxy*map(p + e.xxy) + \n\t\t\t\t\t e.xyx*map(p + e.xyx) + e.yyy*map(p + e.yyy) );   \n}\n\n\n// Tri-Planar blending function. Based on an old Nvidia writeup:\n// GPU Gems 3 - Ryan Geiss: http://http.developer.nvidia.com/GPUGems3/gpugems3_ch01.html\nvec3 tex3D( sampler2D tex, in vec3 p, in vec3 n ){\n   \n    n = max(n*n, .001);\n    n /= (n.x + n.y + n.z );  \n    \n\treturn (texture(tex, p.yz)*n.x + texture(tex, p.zx)*n.y + texture(tex, p.xy)*n.z).xyz;\n}\n\n\n// Texture bump mapping. Four tri-planar lookups, or 12 texture lookups in total.\nvec3 doBumpMap( sampler2D tex, in vec3 p, in vec3 nor, float bumpfactor){\n   \n    const float eps = .001;\n    vec3 grad = vec3( getGrey(tex3D(tex, vec3(p.x - eps, p.y, p.z), nor)),\n                      getGrey(tex3D(tex, vec3(p.x, p.y - eps, p.z), nor)),\n                      getGrey(tex3D(tex, vec3(p.x, p.y, p.z - eps), nor)));\n    \n    grad = (grad - getGrey(tex3D(tex, p, nor)))/eps; \n            \n    grad -= nor*dot(nor, grad);          \n                      \n    return normalize(nor + grad*bumpfactor);\n\t\n}\n\n// The iterations should be higher for proper accuracy, but in this case, I wanted less accuracy, just to leave\n// behind some subtle trails of light in the caves. They're fake, but they look a little like light streaming \n// through some cracks... kind of.\nfloat softShadow(in vec3 ro, in vec3 rd, in float start, in float end, in float k){\n\n    float shade = 1.;\n    // Increase this and the shadows will be more accurate, but the wispy light trails in the caves will disappear.\n    // Plus more iterations slow things down, so it works out, in this case.\n    const int maxIterationsShad = 10; \n\n    // The \"start\" value, or minimum, should be set to something more than the stop-threshold, so as to avoid a collision with \n    // the surface the ray is setting out from. It doesn't matter how many times I write shadow code, I always seem to forget this.\n    // If adding shadows seems to make everything look dark, that tends to be the problem.\n    float dist = start;\n    float stepDist = end/float(maxIterationsShad);\n\n    // Max shadow iterations - More iterations make nicer shadows, but slow things down. Obviously, the lowest \n    // number to give a decent shadow is the best one to choose. \n    for (int i=0; i<maxIterationsShad; i++){\n        // End, or maximum, should be set to the distance from the light to surface point. If you go beyond that\n        // you may hit a surface not between the surface and the light.\n        float h = map(ro + rd*dist);\n        //shade = min(shade, k*h/dist);\n        shade = min(shade, smoothstep(0., 1., k*h/dist));\n        \n        // What h combination you add to the distance depends on speed, accuracy, etc. To be honest, I find it impossible to find \n        // the perfect balance. Faster GPUs give you more options, because more shadow iterations always produce better results.\n        // Anyway, here's some posibilities. Which one you use, depends on the situation:\n        // +=max(h, 0.001), +=clamp( h, 0.01, 0.25 ), +=min( h, 0.1 ), +=stepDist, +=min(h, stepDist*2.), etc.\n        \n        // In this particular instance the light source is a long way away. However, we're only taking a few small steps\n        // toward the light and checking whether anything \"locally\" gets in the way. If a part of the scene a long distance away\n        // is between our hit point and the light source, it won't be accounted for. Technically that's not correct, but the local\n        // shadows give that illusion... kind of.\n        dist += clamp(h, .2, stepDist*2.);\n        \n        // There's some accuracy loss involved, but early exits from accumulative distance function can help.\n        if (abs(h)<.001 || dist > end) break; \n    }\n\n    // I usually add a bit to the final shade value, which lightens the shadow a bit. It's a preference thing. Really dark shadows \n    // look too brutal to me.\n    return min(max(shade, 0.) + .1, 1.); \n}\n\n\n\n\n\n// Ambient occlusion, for that self shadowed look. Based on the original by XT95. I love this \n// function and have been looking for an excuse to use it. For a better version, and usage, \n// refer to XT95's examples below:\n//\n// Hemispherical SDF AO - https://www.shadertoy.com/view/4sdGWN\n// Alien Cocoons - https://www.shadertoy.com/view/MsdGz2\nfloat calculateAO( in vec3 p, in vec3 n, float maxDist )\n{\n\tfloat ao = 0., l;\n\tconst float nbIte = 6.;\n\t//const float falloff = .9;\n    for(float i=1.; i< nbIte+.5; i++){\n    \n        l = (i + hash(i))*.5/nbIte*maxDist;\n        \n        ao += (l - map( p + n*l))/(1. + l);// / pow(1.+l, falloff);\n    }\n\t\n    return clamp(1. - ao/nbIte, 0., 1.);\n}\n\n// More concise, self contained version of IQ's original 3D noise function.\nfloat noise3D(in vec3 p){\n    \n    // Just some random figures, analogous to stride. You can change this, if you want.\n\tconst vec3 s = vec3(7, 157, 113);\n\t\n\tvec3 ip = floor(p); // Unique unit cell ID.\n    \n    // Setting up the stride vector for randomization and interpolation, kind of. \n    // All kinds of shortcuts are taken here. Refer to IQ's original formula.\n    vec4 h = vec4(0., s.yz, s.y + s.z) + dot(ip, s);\n    \n\tp -= ip; // Cell's fractional component.\n\t\n    // A bit of cubic smoothing, to give the noise that rounded look.\n    p = p*p*(3. - 2.*p);\n    \n    // Standard 3D noise stuff. Retrieving 8 random scalar values for each cube corner,\n    // then interpolating along X. There are countless ways to randomize, but this is\n    // the way most are familar with: fract(sin(x)*largeNumber).\n    h = mix(fract(sin(h)*43758.5453), fract(sin(h + s.x)*43758.5453), p.x);\n\t\n    // Interpolating along Y.\n    h.xy = mix(h.xz, h.yw, p.y);\n    \n    // Interpolating along Z, and returning the 3D noise value.\n    return mix(h.x, h.y, p.z); // Range: [0, 1].\n\t\n}\n\n// Simple fBm to produce some clouds.\nfloat fbm(in vec3 p){\n    \n    // Four layers of 3D noise.\n    return .5333*noise3D(p) + .2667*noise3D(p*2.02) + .1333*noise3D(p*4.03) + .0667*noise3D(p*8.03);\n\n}\n\n\n// Pretty standard way to make a sky. \nvec3 getSky(in vec3 ro, in vec3 rd, vec3 sunDir){\n\n\t\n\tfloat sun = max(dot(rd, sunDir), 0.); // Sun strength.\n\tfloat horiz = pow(1.0-max(rd.y, 0.), 3.)*.35; // Horizon strength.\n\t\n\t// The blueish sky color. Tinging the sky redish around the sun. \t\t\n\tvec3 col = mix(vec3(.25, .35, .5), vec3(.4, .375, .35), sun*.75);//.zyx;\n    // Mixing in the sun color near the horizon.\n\tcol = mix(col, vec3(1, .9, .7), horiz);\n    \n    // Sun. I can thank IQ for this tidbit. Producing the sun with three\n    // layers, rather than just the one. Much better.\n\tcol += .25*vec3(1, .7, .4)*pow(sun, 5.);\n\tcol += .25*vec3(1, .8, .6)*pow(sun, 64.);\n\tcol += .2*vec3(1, .9, .7)*max(pow(sun, 512.), .3);\n    \n    // Add a touch of speckle, to match up with the slightly speckly ground.\n    col = clamp(col + hash(rd)*.05 - .025, 0., 1.);\n\t\n\t// Clouds. Render some 3D clouds far off in the distance. I've made them sparse and wispy,\n    // since we're in the desert, and all that.\n\tvec3 sc = ro + rd*FAR*100.; sc.y *= 3.;\n    \n    // Mix the sky with the clouds, whilst fading out a little toward the horizon (The rd.y bit).\n\treturn mix( col, vec3(1, .95, 1), .5*smoothstep(.5, 1., fbm(.001*sc)) * clamp(rd.y*4., 0., 1.) );\n\t\n\n}\n\n// Cool curve function, by Shadertoy user, Nimitz.\n//\n// It gives you a scalar curvature value for an object's signed distance function, which \n// is pretty handy for all kinds of things. Here's it's used to darken the crevices.\n//\n// From an intuitive sense, the function returns a weighted difference between a surface \n// value and some surrounding values - arranged in a simplex tetrahedral fashion for minimal\n// calculations, I'm assuming. Almost common sense... almost. :)\n//\n// Original usage (I think?) - Cheap curvature: https://www.shadertoy.com/view/Xts3WM\n// Other usage: Xyptonjtroz: https://www.shadertoy.com/view/4ts3z2\nfloat curve(in vec3 p){\n\n    const float eps = .05, amp = 4., ampInit = .5;\n\n    vec2 e = vec2(-1, 1)*eps; // 0.05->3.5 - 0.04->5.5 - 0.03->10.->0.1->1.\n    \n    float t1 = map(p + e.yxx), t2 = map(p + e.xxy);\n    float t3 = map(p + e.xyx), t4 = map(p + e.yyy);\n    \n    return clamp((t1 + t2 + t3 + t4 - 4.*map(p))*amp + ampInit, 0., 1.);\n}\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n\n\t\n\t// Screen coordinates.\n\tvec2 u = (fragCoord - iResolution.xy*.5)/iResolution.y;\n\t\n\t// Camera Setup.\n\tvec3 lookAt = vec3(0, 0, iTime*8.);  // \"Look At\" position.\n\tvec3 ro = lookAt + vec3(0, 0, -.25); // Camera position, doubling as the ray origin.\n \n\t// Using the Z-value to perturb the XY-plane.\n\t// Sending the camera and \"look at\" vectors down the tunnel. The \"path\" function is \n\t// synchronized with the distance function.\n\tlookAt.xy += path(lookAt.z);\n\tro.xy += path(ro.z);\n\n    // Using the above to produce the unit ray-direction vector.\n    float FOV = 3.14159/3.; // FOV - Field of view.\n    vec3 forward = normalize(lookAt - ro);\n    vec3 right = normalize(vec3(forward.z, 0, -forward.x )); \n    vec3 up = cross(forward, right);\n\n    // rd - Ray direction.\n    vec3 rd = normalize(forward + FOV*u.x*right + FOV*u.y*up);\n    \n    // Swiveling the camera about the XY-plane (from left to right) when turning corners.\n    // Naturally, it's synchronized with the path in some kind of way.\n\trd.xy = rot2( path(lookAt.z).x/64. )*rd.xy;\n    \n    \n\t\n    // Usually, you'd just make this a unit directional light, and be done with it, but I\n    // like some of the angular subtleties of point lights, so this is a point light a\n    // long distance away. Fake, and probably not advisable, but no one will notice.\n    vec3 lp = vec3(FAR*.5, FAR, FAR) + vec3(0, 0, ro.z);\n \n\n\t// Raymarching, using Nimitz's \"Log Bisection\" method. Very handy on stubborn surfaces. :)\n\tfloat t = logBisectTrace(ro, rd);\n    \n    // Standard sky routine. Worth learning. For outdoor scenes, you render the sky, then the\n    // terrain, then mix together with a fog falloff. Pretty straight forward.\n    vec3 sky = getSky(ro, rd, normalize(lp - ro));\n    \n    // The terrain color. Can't remember why I set it to sky. I'm sure I had my reasons.\n    vec3 col = sky;\n    \n    // If we've hit the ground, color it up.\n    if (t < FAR){\n    \n        vec3 sp = ro+t*rd; // Surface point.\n        vec3 sn = normal(sp); // Surface normal.\n\n        \n        // Light direction vector. From the sun to the surface point. We're not performing\n        // light distance attenuation, since it'll probably have minimal effect.\n        vec3 ld = lp-sp;\n        ld /= max(length(ld), 0.001); // Normalize the light direct vector.\n\n        \n        // Texture scale factor.        \n        const float tSize1 = 1./6.;\n        \n        // Bump mapping with the sandstone texture to provide a bit of gritty detailing.\n        // This might seem counter intuitive, but I've turned off mip mapping and set the\n        // texture to linear, in order to give some grainyness. I'm dividing the bump\n        // factor by the distance to smooth it out a little. Mip mapped textures without\n        // anisotropy look too smooth at certain viewing angles.\n        sn = doBumpMap(iChannel1, sp*tSize1, sn, .007/(1. + t/FAR));//max(1.-length(fwidth(sn)), .001)*hash(sp)/(1.+t/FAR)\n        \n        float shd = softShadow(sp, ld, .05, FAR, 8.); // Shadows.\n        float curv = curve(sp)*.9 +.1; // Surface curvature.\n        float ao = calculateAO(sp, sn, 4.); // Ambient occlusion.\n        \n        float dif = max( dot( ld, sn ), 0.); // Diffuse term.\n        float spe = pow(max( dot( reflect(-ld, sn), -rd ), 0. ), 5.); // Specular term.\n        float fre = clamp(1.0 + dot(rd, sn), 0., 1.); // Fresnel reflection term.\n\n       \n\n        // Schlick approximation. I use it to tone down the specular term. It's pretty subtle,\n        // so could almost be aproximated by a constant, but I prefer it. Here, it's being\n        // used to give a hard clay consistency... It \"kind of\" works.\n\t\tfloat Schlick = pow( 1. - max(dot(rd, normalize(rd + ld)), 0.), 5.);\n\t\tfloat fre2 = mix(.2, 1., Schlick);  //F0 = .2 - Hard clay... or close enough.\n       \n        // Overal global ambience. Without it, the cave sections would be pretty dark. It's made up,\n        // but I figured a little reflectance would be in amongst it... Sounds good, anyway. :)\n        float amb = fre*fre2 + .06*ao;\n        \n        // Coloring the soil - based on depth. Based on a line from Dave Hoskins's \"Skin Peeler.\"\n        col = clamp(mix(vec3(.8, .5, .3), vec3(.5, .25, .125),(sp.y+1.)*.15), vec3(.5, .25, .125), vec3(1));\n        \n        // Give the soil a bit of a sandstone texture. This line's made up.\n        col =  smoothstep(-.5, 1., tex3D(iChannel1, sp*tSize1, sn))*(col + .25);\n        // One thing I really miss when using Shadertoy is anisotropic filtering, which makes mapped \n        // textures appear far more crisp. It requires just a few lines in the backend code, and doesn't \n        // appear to effect frame rate, but I'm assuming the developers have their reasons. Anyway, this\n        // line attempts to put a little definition back in, but it's definitely not the same thing. :)     \n        col = clamp(col + noise3D(sp*48.)*.3 - .15, 0., 1.);\n        \n        // Edit: This shader needs gamma correction, so I've hacked this and a postprocessing line\n        // in to counter the dark shading... I'll do it properly later.\n        col = pow(col, vec3(1.5));\n        \n        // Tweaking the curvature value a bit, then using it to color in the crevices with a \n        // brownish color... in a lame attempt to make the surface look dirt-like.\n        curv = smoothstep(0., .7, curv);\n        col *= vec3(curv, curv*.95, curv*.85);\n \n        \n        // A bit of sky reflection. Not really accurate, but I've been using fake physics since the 90s. :)\n        col += getSky(sp, reflect(rd, sn), ld)*fre*fre2*.5;\n        \n        \n        // Combining all the terms from above. Some diffuse, some specular - both of which are\n        // shadowed and occluded - plus some global ambience. Not entirely correct, but it's\n        // good enough for the purposes of this demonstation.        \n        col = (col*(dif + .1) + fre2*spe)*shd*ao + amb*col;\n       \n        \n    }\n    \n    \n    // Combine the terrain with the sky using some distance fog. This one is designed to fade off very\n    // quickly a few units out from the horizon. Account for the clouds, change \"FAR - 15.\" to zero, and \n    // the fog will be way more prominent. You could also use \"1./(1 + t*scale),\" etc.\n    col = mix(col, sky, sqrt(smoothstep(FAR - 15., FAR, t)));\n    \n\n    // Edit: This shader needs gamma correction, so I've hacked this and a line above in\n    // to counter the dark shading... I'll do it properly later.\n    col = pow(max(col, 0.), vec3(.75));\n\n    \n    // Standard way to do a square vignette. Note that the maxium value value occurs at \"pow(0.5, 4.) = 1./16,\" \n    // so you multiply by 16 to give it a zero to one range. This one has been toned down with a power\n    // term to give it more subtlety.\n    u = fragCoord/iResolution.xy;\n    col *= pow(16.*u.x*u.y*(1. - u.x)*(1. - u.y) , .0625);\n\n    // Done.\n\tfragColor = vec4(clamp(col, 0., 1.), 1);\n}", "image_inputs": [{"id": "XsXGRn", "previewfilepath": "/media/ap/cd4c518bc6ef165c39d4405b347b51ba40f8d7a065ab0e8d2e4f422cbc1e8a43.jpg", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/cd4c518bc6ef165c39d4405b347b51ba40f8d7a065ab0e8d2e4f422cbc1e8a43.jpg", "ctype": "texture"}, {"id": "4sf3Rr", "previewfilepath": "/media/ap/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/Xs33Df.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "Xs3GWj", "name": "GrafEq", "author": "davidar", "description": "I loved playing with GrafEq as a kid, so here it is re-implemented in GLSL.\n\nTry changing [code]#define AA 4.[/code] to [code]#define AA 1.[/code] if you have trouble running the shader.", "tags": ["2d", "graph", "implicit", "equation", "inequality"], "likes": 16, "viewed": 400, "date": "1452130756", "time_retrieved": "2024-06-20T18:31:01.639370", "image_code": "// 2016 David A Roberts <https://davidar.io>\n#define AA 4.\n\n#define PI 3.141592653589793\n\n// CRT effects (curvature, vignette, scanlines and CRT grille)\n// from <https://www.shadertoy.com/view/XtlSD7>\nvec2 CRTCurveUV( vec2 uv ) {\n    uv = uv * 2.0 - 1.0;\n    vec2 offset = abs( uv.yx ) / vec2( 6.0, 4.0 );\n    uv = uv + uv * offset * offset;\n    uv = uv * 0.5 + 0.5;\n    return uv;\n}\nvoid DrawVignette( inout vec3 color, vec2 uv ) {    \n    float vignette = uv.x * uv.y * ( 1.0 - uv.x ) * ( 1.0 - uv.y );\n    vignette = clamp( pow( 16.0 * vignette, 0.3 ), 0.0, 1.0 );\n    color *= vignette;\n}\nvoid DrawScanline( inout vec3 color, vec2 uv ) {\n    float scanline      = clamp( 0.95 + 0.05 * cos( 3.14 * ( uv.y + 0.008 * iTime ) * 240.0 * 1.0 ), 0.0, 1.0 );\n    float grille        = 0.85 + 0.15 * clamp( 1.5 * cos( 3.14 * uv.x * 640.0 * 1.0 ), 0.0, 1.0 );    \n    color *= scanline * grille * 1.2;\n}\n\nfloat atanp(in vec2 p) { return atan(p.y,p.x); }\nfloat cube_root(float x) { return sign(x) * pow(abs(x), 1./3.); }\nfloat sq(float x) { return x*x; }\n\nvec3 margarita(in vec2 p) {\n    float z = length(p) - 3.5 * atanp(p) + sin(p.x) + cos(p.y);\n    if(mod(z,7.*PI) < PI/2.) return vec3(1,0,0);\n    if(mod(z,1.*PI) < PI/2.) return vec3(0);\n    return vec3(1);\n}\n\nvec3 digital_bacteria(in vec2 p) {\n    p /= 4.;\n    float x = sq(sin(p.x)+p.y) + sq(cos(p.y)+p.x);\n    float y = cos(10.*p.x) + cos(10.*p.y) - sin(p.x*p.y);\n    float z = sq(sin(floor(p.x))+floor(p.y)) + sq(cos(floor(p.y))+floor(p.x));\n    if(17. < x && x < 21. && 17. < z && z < 21. && y < 0.)\n        return vec3(1.,1.,85./256.);\n    if(17. < z && z < 21.) return vec3(85./256.,0.,0.);\n    if(17. < x && x < 21.) return vec3(170./256.,170./256.,0.);\n    return vec3(85./256.,85./256.,0.);\n}\n\nvec3 threesome(in vec2 p) {\n    p /= 3.;\n    float z = 1.;\n    z *= sin(length(p + vec2(5,0))) * cos(8.*atanp(p + vec2(5,0)));\n    z *= sin(length(p - vec2(5,5))) * cos(8.*atanp(p - vec2(5,5)));\n    z *= sin(length(p + vec2(0,5))) * cos(8.*atanp(p + vec2(0,5)));\n    if(-0.1 < z && z < 0. || 0.2 < z) return vec3(0);\n    return vec3(1);\n}\n\nvec3 plaid_meltdown(in vec2 p) {\n    p /= 15.;\n    p += 7.;\n    float a = 2.*sin(p.x*sin(p.y) + p.y*sin(p.x));\n    float b = cube_root(sin(2.5*sqrt(2.) * (p.x - p.y)));\n    float c = cube_root(sin(2.5*sqrt(2.) * (p.x + p.y)));\n    float d = sin(80.*p.x) + sin(80.*p.y);\n    if(0.25 * (a + b + c) > 0.5 * d) return vec3(0);\n    return vec3(1);\n}\n\nvec3 sunlight_revealed(in vec2 p) {\n    p /= 6.;\n    p.x += 2.;\n    float a = length(vec2(3.-p.x,p.y)) + abs(p.y) + abs(1.-p.x);\n    float f = atan(p.y,p.x-1.);\n    float c = atan(p.y,p.x-3.);\n    float R = sq(p.x-1.) + sq(p.y);\n    vec3 col = vec3(0);\n    bool mix = false;\n    if(5. < a && a < 7. && mod(f,PI/7.) < PI/14.) {\n        col += vec3(0.,82./256.,173./256.);\n        if(mix) col /= 2.;\n        mix = true;\n    }\n    if(5. < a && a < 7. && mod(c,PI/9.) < PI/18.) {\n        col += vec3(1,0,0);\n        if(mix) col /= 2.;\n        mix = true;\n    }\n    if(5. < a && a < 7. && mod(f,PI/8.) < PI/16.) {\n        col += vec3(1,1,0);\n        if(mix) col /= 2.;\n        mix = true;\n    }\n    if((45.-3.*p.x)*PI/180. < f && f < (47.-p.x)*PI/180. && p.y > 0.1*p.x\n       && mod(log(R)/log(f),2.) < 1.) {\n        col += vec3(1);\n        if(mix) col /= 2.;\n    }\n    return col;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    float t = mod(iTime,10.);\n    vec3 color = vec3(0);\n    for(float i = 0.; i < AA*AA - 0.5; i += 1.) {\n        vec2 uv = (fragCoord.xy + vec2(floor(i/AA), mod(i,AA))/AA) / iResolution.xy;\n        vec2 crtUV = CRTCurveUV( uv );\n        if ( crtUV.x < 0.0 || crtUV.x > 1.0 || crtUV.y < 0.0 || crtUV.y > 1.0 ) continue;\n        vec2 p = 50.0 * crtUV - 25.0;\n        p *= 0.75 + 0.05*mod(iTime,10.);\n        p += mod(iTime,10.) - 5.;\n        p.x *= iResolution.x / iResolution.y;\n        if(t < 2. || 8. < t) {\n            float fade = smoothstep(0.,2.,t) - smoothstep(8.,10.,t);\n            float scale = iResolution.y/50.*float(AA)*fade + 1.;\n            p = floor(p.xy*scale)/scale;\n        }\n\n        vec3 c;\n        if     (mod(0.1*iTime,5.) < 1.) c = margarita(p);\n        else if(mod(0.1*iTime,5.) < 2.) c = plaid_meltdown(p);\n        else if(mod(0.1*iTime,5.) < 3.) c = sunlight_revealed(p);\n        else if(mod(0.1*iTime,5.) < 4.) c = threesome(p);\n        else if(mod(0.1*iTime,5.) < 5.) c = digital_bacteria(p);\n\n        DrawVignette( c, crtUV );\n        DrawScanline( c, uv );\n        color += c / float(AA*AA);\n    }\n\n    fragColor.xyz = color;\n    fragColor.w = 1.0;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/Xs3GWj.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "Xsc3Df", "name": "Phoney Reflections", "author": "dr2", "description": "How many Androids (use the mouse)?", "tags": ["raymarching", "reflection", "android"], "likes": 8, "viewed": 509, "date": "1452416938", "time_retrieved": "2024-06-20T18:31:01.665472", "image_code": "// \"Phoney Reflections\" by dr2 - 2016\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\nconst float pi = 3.14159;\nconst vec4 cHashA4 = vec4 (0., 1., 57., 58.);\nconst vec3 cHashA3 = vec3 (1., 57., 113.);\nconst float cHashM = 43758.54;\n\nvec4 Hashv4f (float p)\n{\n  return fract (sin (p + cHashA4) * cHashM);\n}\n\nfloat Noisefv2 (vec2 p)\n{\n  vec2 i = floor (p);\n  vec2 f = fract (p);\n  f = f * f * (3. - 2. * f);\n  vec4 t = Hashv4f (dot (i, cHashA3.xy));\n  return mix (mix (t.x, t.y, f.x), mix (t.z, t.w, f.x), f.y);\n}\n\nfloat Fbm2 (vec2 p)\n{\n  float f, a;\n  f = 0.;\n  a = 1.;\n  for (int i = 0; i < 5; i ++) {\n    f += a * Noisefv2 (p);\n    a *= 0.5;\n    p *= 2.;\n  }\n  return f;\n}\n\nfloat Fbmn (vec3 p, vec3 n)\n{\n  vec3 s = vec3 (0.);\n  float a = 1.;\n  for (int i = 0; i < 5; i ++) {\n    s += a * vec3 (Noisefv2 (p.yz), Noisefv2 (p.zx), Noisefv2 (p.xy));\n    a *= 0.5;\n    p *= 2.;\n  }\n  return dot (s, abs (n));\n}\n\nvec3 VaryNf (vec3 p, vec3 n, float f)\n{\n  vec3 e = vec3 (0.2, 0., 0.);\n  float s = Fbmn (p, n);\n  vec3 g = vec3 (Fbmn (p + e.xyy, n) - s,\n     Fbmn (p + e.yxy, n) - s, Fbmn (p + e.yyx, n) - s);\n  return normalize (n + f * (g - n * dot (n, g)));\n}\n\nfloat PrBoxDf (vec3 p, vec3 b)\n{\n  vec3 d = abs (p) - b;\n  return min (max (d.x, max (d.y, d.z)), 0.) + length (max (d, 0.));\n}\n\nfloat PrBox2Df (vec2 p, vec2 b)\n{\n  vec2 d = abs (p) - b;\n  return min (max (d.x, d.y), 0.) + length (max (d, 0.));\n}\n\nfloat PrRoundBoxDf (vec3 p, vec3 b, float r)\n{\n  return length (max (abs (p) - b, 0.)) - r;\n}\n\nfloat PrSphDf (vec3 p, float s)\n{\n  return length (p) - s;\n}\n\nfloat PrCylDf (vec3 p, float r, float h)\n{\n  return max (length (p.xy) - r, abs (p.z) - h);\n}\n\nfloat PrShCylDf (vec3 p, float rIn, float rEx, float h)\n{\n  float s;\n  s = length (p.xy);\n  return max (max (s - rEx, rIn - s), abs (p.z) - h);\n}\n\nfloat PrERCylDf (vec3 p, float r, float rt, float h)\n{\n  vec2 dc;\n  float dxy, dz;\n  dxy = length (p.xy) - r;\n  dz = abs (p.z - 0.5 * h) - h;\n  dc = vec2 (dxy, dz) + rt;\n  return min (min (max (dc.x, dz), max (dc.y, dxy)), length (dc) - rt);\n}\n\nmat3 RMatFromEuAng (vec3 eu)\n{\n  vec4 q, p1, p2, p3;\n  float a1, a2, a3, c1, s1, p4w;\n  a1 = 0.5 * eu.y;\n  a2 = 0.5 * (eu.x - eu.z);\n  a3 = 0.5 * (eu.x + eu.z);\n  s1 = sin (a1);\n  c1 = cos (a1);\n  q = vec4 (s1 * cos (a2), s1 * sin (a2), c1 * sin (a3), c1 * cos (a3));\n  p1 = 2. * q.x * q;\n  p2.yzw = 2. * q.y * q.yzw;\n  p3.zw  = 2. * q.z * q.zw;\n  p4w    = 2. * q.w * q.w - 1.;\n  return mat3 (p1.x + p4w,  p1.y - p3.w, p1.z + p2.w,\n               p1.y + p3.w, p2.y + p4w,  p2.z - p1.w,\n               p1.z - p2.w, p2.z + p1.w, p3.z + p4w);\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  return q * cos (a) * vec2 (1., 1.) + q.yx * sin (a) * vec2 (-1., 1.);\n}\n\nfloat SmoothBump (float lo, float hi, float w, float x)\n{\n  return (1. - smoothstep (hi - w, hi + w, x)) * smoothstep (lo - w, lo + w, x);\n}\n\nmat3 objMat;\nvec3 sunDirMv, qHit, ltDir, phSize, bxSize;\nvec2 scrnSize;\nfloat dstFar, dstFarMv, tCur, rAngH, rAngL, rAngA, gDisp;\nint idObj, idObjMv;\nbool walk, hOr, vOr;\nconst int idFrame = 1, idFloor = 2, idCeil = 3, idWall = 4, idMir = 5,\n   idPhScrn = 10, idPhFace = 11, idRing = 12, idLens = 13, idBut = 14,\n   idSock = 15;\n\nvec3 BgColMv (vec3 ro, vec3 rd)\n{\n  vec3 col;\n  float sd, f;\n  if (rd.y > 0.) {\n    ro.xz += 2. * tCur;\n    sd = max (dot (rd, sunDirMv), 0.);\n    col = vec3 (0.1, 0.2, 0.4) + 0.2 * pow (1. - max (rd.y, 0.), 8.) +\n       0.35 * pow (sd, 6.) + 0.65 * min (pow (sd, 256.), 0.3);\n    f = Fbm2 (0.05 * (ro.xz + rd.xz * (50. - ro.y) / rd.y));\n    col = mix (col, vec3 (1.), clamp (0.1 + 0.8 * f * rd.y, 0., 1.));\n  } else {\n    sd = - ro.y / rd.y;\n    col = mix (vec3 (0.6, 0.5, 0.3),\n       0.9 * (vec3 (0.1, 0.2, 0.4) + 0.2) + 0.1, pow (1. + rd.y, 5.));\n  }\n  return col;\n}\n\nfloat ObjDfMv (vec3 p)\n{\n  vec3 q, pp;\n  vec2 ip;\n  float dMin, d, bf, hGap, bFac, ah;\n  hGap = 2.5;\n  bf = PrBox2Df (p.xz, vec2 (7. * hGap));\n  pp = p;\n  ip = floor ((pp.xz + hGap) / (2. * hGap));\n  pp.xz = pp.xz - 2. * hGap * ip;\n  bFac = (ip.x == 0. && ip.y == 0.) ? 1.6 : 1.;\n  ah = rAngH * (walk ? sign (1.1 - bFac) : - step (1.1, bFac));\n  dMin = dstFarMv;\n  q = pp;\n  q.y -= 1.2;\n  d = max (PrSphDf (q, 0.85), - q.y);\n  q = pp;\n  q.y -= 0.2;\n  d = min (d, PrERCylDf (q.xzy, 0.9, 0.28, 0.7));\n  q = pp;\n  q.xz = Rot2D (q.xz, ah);\n  q.x = abs (q.x) - 0.4;\n  q.y -= 1.9;\n  q.xy = Rot2D (q.xy, 0.2 * pi);\n  d = min (d, PrERCylDf (q.xzy, 0.06, 0.04, 0.4 * (2. * bFac - 1.)));\n  q = pp;\n  q.x = abs (q.x) - 1.05;\n  q.y -= 1.1;\n  q.yz = Rot2D (q.yz, rAngA * (walk ? sign (pp.x) : 1.));\n  q.y -= -0.9;\n  d = min (d, PrERCylDf (q.xzy, 0.2, 0.15, 0.6));\n  q = pp;\n  q.x = abs (q.x) - 0.4;\n  q.yz = Rot2D (q.yz, - rAngL * sign (pp.x));\n  q.y -= -0.8;\n  d = min (d, PrERCylDf (q.xzy, 0.25, 0.15, 0.55));\n  d = max (d, bf);\n  if (d < dMin) { dMin = d;  idObjMv = 1; }\n  q = pp;\n  q.xz = Rot2D (q.xz, ah);\n  q.x = abs (q.x) - 0.4;\n  q -= vec3 (0., 1.6 + 0.3 * (bFac - 1.), 0.7 - 0.3 * (bFac - 1.));\n  d = PrSphDf (q, 0.15 * bFac);\n  d = max (d, bf);\n  if (d < dMin) { dMin = d;  idObjMv = 2; }\n  d = p.y + 1.;\n  if (d < dMin) { dMin = d;  idObjMv = 0;  qHit = p; }\n  return dMin;\n}\n\nfloat ObjRayMv (vec3 ro, vec3 rd)\n{\n  float dHit, d;\n  dHit = 0.;\n  for (int j = 0; j < 150; j ++) {\n    d = ObjDfMv (ro + dHit * rd);\n    dHit += d;\n    if (d < 0.001 || dHit > dstFarMv) break;\n  }\n  return dHit;\n}\n\nvec3 ObjNfMv (vec3 p)\n{\n  const vec3 e = vec3 (0.001, -0.001, 0.);\n  vec4 v = vec4 (ObjDfMv (p + e.xxx), ObjDfMv (p + e.xyy),\n     ObjDfMv (p + e.yxy), ObjDfMv (p + e.yyx));\n  return normalize (vec3 (v.x - v.y - v.z - v.w) + 2. * v.yzw);\n}\n\nfloat ChqPat (vec3 p, float dHit)\n{\n  vec2 q, iq;\n  float f, s;\n  p.z += gDisp;\n  q = p.xz + vec2 (0.5, 0.25);\n  iq = floor (q);\n  s = 0.5 + 0.5 * Noisefv2 (q * 107.);\n  if (2. * floor (iq.x / 2.) != iq.x) q.y += 0.5;\n  q = smoothstep (0., 0.02, abs (fract (q + 0.5) - 0.5));\n  f = dHit / dstFarMv;\n  return s * (1. - 0.9 * exp (-2. * f * f) * (1. - q.x * q.y));\n}\n\nvec3 ObjColMv (vec3 rd, vec3 vn, float dHit)\n{\n  vec3 col;\n  if (idObjMv == 1) col = vec3 (0.65, 0.8, 0.2);\n  else if (idObjMv == 2) col = vec3 (0.8, 0.8, 0.);\n  else col = mix (vec3 (0.4, 0.3, 0.2), vec3 (0.6, 0.5, 0.4),\n     (0.5 + 0.5 * ChqPat (qHit / 5., dHit)));\n  return col * (0.3 + 0.7 * max (dot (vn, sunDirMv), 0.)) +\n     0.3 * pow (max (0., dot (sunDirMv, reflect (rd, vn))), 64.);\n}\n\nfloat ObjSShadowMv (vec3 ro, vec3 rd)\n{\n  float sh, d, h;\n  sh = 1.;\n  d = 0.05;\n  for (int j = 0; j < 15; j ++) {\n    h = ObjDfMv (ro + rd * d);\n    sh = min (sh, 10. * h / d);\n    d += 0.2;\n    if (h < 0.001) break;\n  }\n  return clamp (sh, 0., 1.);\n}\n\nvec3 TrackPathMv (float t)\n{\n  vec3 p;\n  vec2 tr;\n  float ti[5], rPath, a, r, tC, tL, tWf, tWb;\n  bool rotStep;\n  rPath = 28.;\n  tC = pi * rPath / 8.;\n  tL = 2. * rPath / 5.;\n  tWf = 4.;\n  tWb = 2.;\n  rotStep = false;\n  ti[0] = 0.;\n  ti[1] = ti[0] + tWf;\n  ti[2] = ti[1] + tL;\n  ti[3] = ti[2] + tWb;\n  ti[4] = ti[3] + tC;\n  p.y = 1.;\n  t = mod (t, ti[4]);\n  tr = vec2 (0.);\n  if (t < ti[1]) {\n    tr.y = rPath;\n  } else if (t < ti[2]) {\n    tr.y = rPath - 2. * rPath * (t - ti[1]) / (ti[2] - ti[1]);\n  } else if (t < ti[3]) {\n    tr.y = - rPath;\n  } else {\n    rotStep = true;\n    a = 1.5 + (t - ti[3]) / (ti[4] - ti[3]);\n    r = rPath;\n  }\n  if (rotStep) {\n    a *= pi;\n    p.xz = r * vec2 (cos (a), sin (a));\n  } else {\n    p.xz = tr;\n  }\n  p.xz -= 2.5;\n  return p;\n}\n\nvec3 ShowSceneMv (vec3 ro, vec3 rd)\n{\n  vec3 vn, col, c;\n  float dstHit, refl;\n  int idObjT;\n  dstHit = ObjRayMv (ro, rd);\n  if (dstHit < dstFarMv) {\n    ro += rd * dstHit;\n    idObjT = idObjMv;\n    vn = ObjNfMv (ro);\n    col = ObjColMv (rd, vn, dstHit);\n    idObjMv = idObjT;\n    if (idObjMv > 0) {\n      rd = reflect (rd, vn);\n      ro += 0.01 * rd;\n      refl = 0.2 + 0.3 * pow (1. - dot (vn, rd), 4.);\n      dstHit = ObjRayMv (ro, rd);\n      if (dstHit < dstFarMv) {\n        ro += rd * dstHit;\n        c = ObjColMv (rd, ObjNfMv (ro), dstHit);\n      } else {\n        c = BgColMv (ro, rd);\n      }\n      col = mix (col, c, refl);\n    }\n    col *= (0.8 + 0.2 * ObjSShadowMv (ro, sunDirMv));\n  } else {\n    col = BgColMv (ro, rd);\n  }\n  return col;\n}\n\nvec3 ScrnCol (vec2 w)\n{\n  mat3 vuMat;\n  vec3 ro, rd, vd, u, col;\n  float f;\n  bool isMv;\n  isMv = true;\n  if (hOr) {\n    w = w.yx;\n    w.x *= -1.;\n    w /= scrnSize.y;\n  } else {\n    w /= scrnSize.x;\n    if (abs (w.y) > scrnSize.x / scrnSize.y) isMv = false;\n  }\n  if (! vOr) w *= -1.;\n  if (isMv) {\n    ro = TrackPathMv (tCur);\n    vd = normalize (vec3 (0., 2., 0.) - ro);\n    u = - vd.y * vd;\n    f = 1. / sqrt (1. - vd.y * vd.y);\n    vuMat = mat3 (f * vec3 (vd.z, 0., - vd.x), f * vec3 (u.x, 1. + u.y, u.z), vd);\n    rd = vuMat * normalize (vec3 (w, 1.));\n    col = ShowSceneMv (ro, rd);\n  } else col = vec3 (0.);\n  return col;\n}\n\nvoid SetState (vec3 sv)\n{\n  float tCyc, wkSpd;\n  wkSpd = 0.7;\n  tCyc = mod (wkSpd * tCur, 7.);\n  if (tCyc < 4.) {\n    walk = true;\n    tCyc = mod (tCyc, 1.);\n    gDisp = mod (wkSpd * tCur, 1.);\n    rAngH = -0.7 * sin (2. * pi * tCyc);\n    rAngA = 1.1 * sin (2. * pi * tCyc);\n    rAngL = 0.6 * sin (2. * pi * tCyc);\n  } else {\n    walk = false;\n    tCyc = mod (tCyc, 1.);\n    gDisp = 0.;\n    rAngH = 0.4 * sin (2. * pi * tCyc);\n    rAngA = 2. * pi * (0.5 - abs (tCyc - 0.5)); \n    rAngL = 0.;\n  }\n  sunDirMv = normalize (vec3 (1., 2., 1.));\n  dstFarMv = 150.;\n  if (abs (sv.y) > 4. * max (abs (sv.x), abs (sv.z))) {\n    hOr = false;\n    vOr = true;\n  } else {\n    hOr = (abs (sv.z) < abs (sv.x));\n    vOr = (hOr ? (sv.x >= 0.) : (sv.z >= 0.));\n  }\n  phSize = vec3 (0.85, 0.015, 1.55);\n  scrnSize = phSize.xz - vec2 (0.05, 0.2);\n  bxSize = vec3 (3.6, 3.8, 3.6);\n}\n\nfloat PhoneDf (vec3 p, float dMin)\n{\n  vec3 q;\n  float d;\n  p = objMat * p;\n  q = p;\n  d = min (PrCylDf (q - vec3 (0.5, 0., 1.) * phSize, phSize.y, 0.05 * phSize.z),\n     PrCylDf (q - vec3 (0., 0., -1.) * phSize, 1.2 * phSize.y, 0.05 * phSize.z));\n  d = max (PrRoundBoxDf (q, phSize, 0.03), - d); \n  if (d < dMin) { dMin = d;  qHit = q;  idObj = idPhFace; }\n  q = p;\n  q.yz -= vec2 (- 2.3, 0.8) * phSize.yz;\n  d = PrShCylDf (q.xzy, 0.1 * phSize.x, 0.12 * phSize.x, 2.3 * phSize.y);\n  if (d < dMin) { dMin = d;  qHit = q;  idObj = idRing; }\n  d = PrCylDf (q.xzy, 0.1 * phSize.x, 1.5 * phSize.y);\n  if (d < dMin) { dMin = d;  qHit = q;  idObj = idLens; }\n  q = p;\n  q.yz -= vec2 (- 1.8, 0.75) * phSize.yz;\n  q.x = abs (q.x) - 0.3 * phSize.x;\n  d = PrShCylDf (q.xzy, 0.04 * phSize.x, 0.05 * phSize.x, 1.8 * phSize.y);\n  if (d < dMin) { dMin = d;  qHit = q;  idObj = idRing; }\n  q = p;\n  q.yz -= vec2 (- 2., 0.45) * phSize.yz;\n  q.z = abs (q.z) - 0.09 * phSize.z;\n  d = PrRoundBoxDf (q, vec3 (0.16, 0.05, 0.06) * phSize, 0.03);\n  if (d < dMin) { dMin = d;  qHit = q;  idObj = idBut; }\n  q = p;\n  d = min (PrCylDf (q - vec3 (0.5, 0., 0.97) * phSize, phSize.y, 0.05 * phSize.z),\n     PrCylDf (q - vec3 (0., 0., -0.97) * phSize, 1.2 * phSize.y, 0.05 * phSize.z));\n  if (d < dMin) { dMin = d;  qHit = q;  idObj = idSock; }\n  return dMin;\n}\n\nfloat ObjDf (vec3 p)\n{\n  vec3 q;\n  float dMin, d, bl, bt;\n  bt = 0.06;\n  dMin = dstFar;\n  p.y -= 3.6;\n  q = p;\n  q = abs (q) - bxSize - bt;\n  d = min (PrBox2Df (q.xz, vec2 (bt)), \n     min (PrBox2Df (q.yz, vec2 (bt)), PrBox2Df (q.yx, vec2 (bt))));\n  if (d < dMin) { dMin = d;  idObj = idFrame;  qHit = q; }\n  q = p;\n  q.y += bxSize.y - 0.25 * bt;\n  d = PrBoxDf (q, vec3 (bxSize.x + bt, 0.25 * bt, bxSize.z + bt));\n  if (d < dMin) { dMin = d;  idObj = idFloor;  qHit = q; }\n  q = p;\n  q.y -=  bxSize.y - 0.05 * bt;\n  d = PrBoxDf (q, vec3 (bxSize.x, 0.05 * bt, bxSize.z));\n  if (d < dMin) { dMin = d;  idObj = idCeil;  qHit = q; }\n  q = p;\n  d = - PrBox2Df (q.xz, bxSize.xz + 1.5 * bt);\n  if (d < dMin) { dMin = d;  idObj = idMir;  qHit = q; }\n  dMin = PhoneDf (p, dMin);\n  return dMin;\n}\n\nfloat ObjRay (vec3 ro, vec3 rd)\n{\n  float dHit, d;\n  dHit = 0.;\n  for (int j = 0; j < 100; j ++) {\n    d = ObjDf (ro + dHit * rd);\n    dHit += d;\n    if (d < 0.001 || dHit > dstFar) break;\n  }\n  return dHit;\n}\n\nvec3 ObjNf (vec3 p)\n{\n  const vec3 e = vec3 (0.0001, -0.0001, 0.);\n  vec4 v = vec4 (ObjDf (p + e.xxx), ObjDf (p + e.xyy),\n     ObjDf (p + e.yxy), ObjDf (p + e.yyx));\n  return normalize (vec3 (v.x - v.y - v.z - v.w) + 2. * vec3 (v.y, v.z, v.w));\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  vec3 vn, vnn, vltDir, col, qd;\n  vec2 uu;\n  float dstHit, reflFac, spec, nRefl;\n  int idObjT;\n  bool isFBut;\n  const int maxRefl = 7;\n  dstFar = 15.;\n  idObj = -1;\n  dstHit = ObjRay (ro, rd);\n  nRefl = 0.;\n  for (int nf = 0; nf < maxRefl; nf ++) {\n    if (idObj == idMir) {\n      ro += rd * dstHit;\n      qd = abs (qHit) / bxSize;\n      uu = vec2 (min (qd.x, qd.z), qd.y);\n      uu *= uu;\n      uu *= uu;\n      if (dot (uu, uu) > 0.8) {\n        idObj = idWall;\n\tbreak;\n      }\n      rd = reflect (rd, ObjNf (ro));\n      ro += 0.002 * rd;\n      ++ nRefl;\n      idObj = -1;\n      dstHit = ObjRay (ro, rd);\n    } else break;\n  }\n  if (idObj < 0 || idObj == idMir) dstHit = dstFar;\n  if (dstHit < dstFar) {\n    ro += rd * dstHit;\n    idObjT = idObj;\n    vn = ObjNf (ro);\n    idObj = idObjT;\n    if (idObj == idFloor) vn = VaryNf (10. * vec3 (5., 1., 1.) * qHit, vn, 0.4);\n    spec = 0.3;\n    if (idObj == idPhFace) {\n      vnn = objMat * vn;\n      if (vnn.y > 0.999) {\n        if (abs (qHit.x) < scrnSize.x && abs (qHit.z) < scrnSize.y) {\n          col = ScrnCol (qHit.xz);\n          idObj = idPhScrn;\n        } else {\n\t  uu = vec2 (abs (qHit.x) - 0.1 * phSize.x,\n\t      abs (qHit.z + 0.93 * phSize.z) - 0.03 * phSize.z);\n\t  isFBut = (max (uu.x, uu.y) < 0.);\n\t  uu = abs (uu);\n\t  isFBut = isFBut && (min (uu.x, uu.y) < 0.015 * phSize.x);\n\t  col = isFBut ? vec3 (0.4, 0.4, 0.3) : vec3 (0.05);\n\t }\n      } else if (vnn.y < -0.999) {\n        if (abs (abs (qHit.x) - 0.02 * phSize.x) < 0.007 * phSize.x) {\n          col = vec3 (0.7, 0., 0.) * SmoothBump (0.15, 0.85, 0.1,\n             mod (30. * qHit.z / phSize.z, 1.));\n        } else {\n          vnn = VaryNf (31. * qHit, vec3 (0., -1., 0.), 0.5);\n          vn = vnn * objMat;\n          col = vec3 (0.2, 0.05, 0.);\n        }\n      } else col = vec3 (0.3, 0.1, 0.);\n    } else if (idObj == idRing) col = vec3 (0.6, 0.65, 0.6);\n    else if (idObj == idLens) col = vec3 (0.1);\n    else if (idObj == idBut) col = vec3 (0.65, 0.6, 0.6);\n    else if (idObj == idSock) col = vec3 (0.1);\n    else if (idObj == idFrame || idObj == idWall) {\n      col = vec3 (0.3, 0.2, 0.1);\n      spec = 0.2;\n    } else if (idObj == idFloor) {\n      col = vec3 (0., 0.45, 0.3);\n      spec = 0.1;\n    } else if (idObj == idCeil) {\n      col = vec3 (1., 1., 0.8) * (1. - 0.5 * min (1.,\n         length (pow (abs (qHit.xz) / 3.6, vec2 (8.)))));\n    }\n    if (idObj != idPhScrn && idObj != idCeil) {\n      vltDir = vec3 (0., 1., 0.);\n      col = col * (0.2 + 0.6 * max (dot (vn, ltDir), 0.) +\n         0.8 * max (dot (vn, vltDir), 0.)) +\n         spec * (0.6 * pow (max (0., dot (ltDir, reflect (rd, vn))), 64.) +\n\t 0.8 * pow (max (0., dot (vltDir, reflect (rd, vn))), 64.));\n    }\n  } else col = vec3 (0., 0.3, 0.4);\n  col = clamp (col * pow (0.85, nRefl), 0., 1.);\n  if (idObj != idPhScrn) col = pow (col, vec3 (0.65));\n  return col;\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  mat3 vuMat;\n  vec4 mPtr;\n  vec3 ro, rd, eu;\n  vec2 canvas, uv, ori, ca, sa;\n  float az, el;\n  canvas = iResolution.xy;\n  uv = 2. * fragCoord.xy / canvas - 1.;\n  uv.x *= canvas.x / canvas.y;\n  tCur = iTime;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / canvas - 0.5;\n  az = -0.1 * tCur;\n  el = 0.;\n  if (mPtr.z > 0.) {\n    az += 1.5 * pi * mPtr.x;\n    el += pi * mPtr.y;\n  }\n  el = clamp (el, -0.4 * pi, 0.4 * pi);\n  ori = vec2 (el, az);\n  ca = cos (ori);\n  sa = sin (ori);\n  vuMat = mat3 (1., 0., 0., 0., ca.x, - sa.x, 0., sa.x, ca.x) *\n     mat3 (ca.y, 0., - sa.y, 0., 1., 0., sa.y, 0., ca.y);\n  eu = -2. * pi * mod (vec3 (0.27, 0.21, 0.43) * 0.3 * tCur, 1.);\n  objMat = RMatFromEuAng (eu);\n  SetState (objMat[1]);\n  rd = normalize (vec3 (uv, 1.6)) * vuMat;\n  ro = vec3 (0., 0., - bxSize.x) * vuMat;\n  ro.y += 0.9 * bxSize.y;\n  ltDir = normalize (vec3 (0.5, 1., -2.)) * vuMat;\n  fragColor = vec4 (ShowScene (ro, rd), 1.);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc-by-nc-sa-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/Xsc3Df.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "Xsc3W2", "name": "Colorful perspective effect", "author": "Tetane", "description": "My first attempt to make a Sierpinski carpet was a big failure but it made this !!\n(mouse translate the camera)", "tags": ["3d", "colors", "array", "perspective", "squares"], "likes": 6, "viewed": 176, "date": "1452115791", "time_retrieved": "2024-06-20T18:31:01.666468", "image_code": "#define PI 3.14159265\nconst float it = 100.0;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tfloat time = iTime;\n\tfloat mx = max(iResolution.x, iResolution.y);\n\tvec2 scrs = iResolution.xy/mx;\n\tvec2 uv = vec2(fragCoord.x, iResolution.y-fragCoord.y)/mx;\n\tvec2 m = vec2(iMouse.x/mx,scrs.y-iMouse.y/mx);\n    \n    uv-=scrs/2.0; // Place the origin at the center of the screen\n    \n    const float it = 100.0;\n    \n\tfloat v = it+1.0;\n\t\n\tfragColor = vec4(vec3(0.0),1.0); // background color\n   \n\t\n\tfor (float i = 0.0; i < it; i++)\n\t{\n        \n\t\tv--;\n\t\tif(floor(mod(uv.x*2.0*v+m.x*50.0,6.0))==1.0 && floor(mod(uv.y*2.0*v+m.y*50.0,6.0))==1.0){\n\t\t\t\n\t\t\tfragColor = vec4(i/it*(sin(i/5.0-time*5.0+2.0*PI/3.0)+1.0)/2.0,\n\t\t\t\t\t    \t i/it*(sin(i/5.0-time*5.0+4.0*PI/3.0)+1.0)/2.0,\n\t\t\t\t\t   \t\t i/it*(sin(i/5.0-time*5.0+6.0*PI/3.0)+1.0)/2.0,\n\t\t\t\t\t    \t 1.0);\n\t\t}\n\t}\n    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/Xsc3W2.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "Xsd3Rs", "name": "Everyday003 - IceCube", "author": "Makio64", "description": "Everyday003 - IceCube\n\nTest SSS Technic & HG_SDF ", "tags": ["noise", "sss", "ice", "hgsdf"], "likes": 75, "viewed": 7144, "date": "1451797870", "time_retrieved": "2024-06-20T18:31:02.972754", "image_code": "// Everyday003 - IceCube\n// By David Ronai / @Makio64\n\n// Thanks to XT95 to implement SSS in this shadertoy:\n// https://www.shadertoy.com/view/MsdGz2\n// Base on this papper :\n// http://colinbarrebrisebois.com/2011/03/07/gdc-2011-approximating-translucency-for-a-fast\n\n//------------------------------------------------------------------ VISUAL QUALITY\n#define POSTPROCESS\n#define RAYMARCHING_STEP 35\n#define RAYMARCHING_JUMP 1.\n//------------------------------------------------------------------ DEBUG\n//#define RENDER_DEPTH\n//#define RENDER_NORMAL\n//#define RENDER_AO\n\nconst float PI = 3.14159265359;\nfloat snoise(vec3 v);\n\n//------------------------------------------------------------------  SIGNED PRIMITIVES\nfloat vmax(vec3 v) {return max(max(v.x, v.y), v.z);}\nfloat fBox(vec3 p, vec3 b) {\n\tvec3 d = abs(p) - b;\n\treturn length(max(d, vec3(0))) + vmax(min(d, vec3(0)));\n}\nfloat pModPolar(inout vec2 p, float repetitions) {\n\tfloat angle = 2./repetitions*PI;\n\tfloat a = atan(p.y, p.x) + angle/2.;\n\tfloat r = length(p);\n\tfloat c = floor(a/angle);\n\ta = mod(a,angle) - angle/2.;\n\tp = vec2(cos(a), sin(a))*r;\n\tif (abs(c) >= (repetitions/2.)) c = abs(c);\n\treturn c;\n}\nfloat fOpUnionRound(float a, float b, float r) {\n\tvec2 u = max(vec2(r - a,r - b), vec2(0));\n\treturn max(r, min (a, b)) - length(u);\n}\n\n//------------------------------------------------------------------ MAP\nfloat map( in vec3 pos ) {\n\tfloat d = pos.y;\n    pos -= snoise(pos*0.15);\n    vec3 q = pos-vec3(0.,5.,0.);\n    pModPolar(q.xz, 6.);\n    q -= vec3(30,0,0);\n\td = fOpUnionRound(d, fBox(q,vec3(5.)),4.4);\n    q = pos;\n    pModPolar(q.xz,8.);\n\td = fOpUnionRound(d, fBox(q,vec3(6.,20.,6.)),6.);\n\treturn d;\n}\n\n//------------------------------------------------------------------ RAYMARCHING\n\n#ifdef RENDER_DEPTH\nfloat castRay( in vec3 ro, in vec3 rd, inout float depth )\n#else\nfloat castRay( in vec3 ro, in vec3 rd )\n#endif\n{\n\tfloat t = 0.0;\n\tfloat res;\n\tfor( int i=0; i<RAYMARCHING_STEP; i++ )\n\t{\n\t\tvec3 pos = ro+rd*t;\n\t\tres = map( pos );\n\t\tif( res < 0.01 || t > 100. ) break;\n\t\tt += res*RAYMARCHING_JUMP;\n\t\t#ifdef RENDER_DEPTH\n\t\tdepth += 1./float(RAYMARCHING_STEP);\n\t\t#endif\n\t}\n\treturn t;\n}\n\nvec3 calcNormal(vec3 p) {\n\tfloat eps = 0.01;\n\tconst vec3 v1 = vec3( 1.0,-1.0,-1.0);\n\tconst vec3 v2 = vec3(-1.0,-1.0, 1.0);\n\tconst vec3 v3 = vec3(-1.0, 1.0,-1.0);\n\tconst vec3 v4 = vec3( 1.0, 1.0, 1.0);\n\treturn normalize( v1 * map( p + v1*eps ) +\n\t\t\t\t\t  v2 * map( p + v2*eps ) +\n\t\t\t\t\t  v3 * map( p + v3*eps ) +\n\t\t\t\t\t  v4 * map( p + v4*eps ) );\n}\n\n\nfloat hash( float n ){\n\treturn fract(sin(n)*3538.5453);\n}\n\nfloat calcAO( in vec3 p, in vec3 n, float maxDist, float falloff ){\n\tfloat ao = 0.0;\n\tconst int nbIte = 6;\n\tfor( int i=0; i<nbIte; i++ )\n\t{\n\t\tfloat l = hash(float(i))*maxDist;\n\t\tvec3 rd = n*l;\n\t\tao += (l - map( p + rd )) / pow(1.+l, falloff);\n\t}\n\treturn clamp( 1.-ao/float(nbIte), 0., 1.);\n}\n\n// calculate local thickness\n// base on AO but : inverse the normale(line117) & inverse the color(line 118)\nfloat thickness( in vec3 p, in vec3 n, float maxDist, float falloff )\n{\n\tfloat ao = 0.0;\n\tconst int nbIte = 6;\n\tfor( int i=0; i<nbIte; i++ )\n\t{\n\t\tfloat l = hash(float(i))*maxDist;\n\t\tvec3 rd = -n*l;\n\t\tao += (l + map( p + rd )) / pow(1.+l, falloff);\n\t}\n\treturn clamp( 1.-ao/float(nbIte), 0., 1.);\n}\n\n//------------------------------------------------------------------ POSTEFFECTS\n\n#ifdef POSTPROCESS\nvec3 postEffects( in vec3 col, in vec2 uv, in float time )\n{\n\t// gamma correction\n\t// col = pow( clamp(col,0.0,1.0), vec3(0.45) );\n\t// vigneting\n\tcol *= 0.7+0.3*pow( 16.0*uv.x*uv.y*(1.0-uv.x)*(1.0-uv.y), 0.15 );\n\treturn col;\n}\n#endif\n\nvec3 render( in vec3 ro, in vec3 rd, in vec2 uv )\n{\n\tvec3 col = vec3(.0,.0,1.2);\n\n\t#ifdef RENDER_DEPTH\n\tfloat depth = 0.;\n\tfloat t = castRay(ro,rd,depth);\n\t#else\n\tfloat t = castRay(ro,rd);\n\t#endif\n\n\t#ifdef RENDER_DEPTH\n\treturn vec3(depth/10.,depth/5.,depth);\n\t#endif\n\n\tvec3 pos = ro + t * rd;\n\tvec3 nor = calcNormal(pos);\n\n\t#ifdef RENDER_NORMAL\n\treturn nor;\n\t#endif\n\n\tfloat ao = calcAO(pos,nor,10.,1.2);\n\t#ifdef RENDER_AO\n\treturn vec3(ao);\n\t#endif\n\n    float thi = thickness(pos, nor, 6., 1.5);\n\n    vec3 lpos1 = vec3(0.0,15.+sin(iTime)*5.,0.0);\n\tvec3 ldir1 = normalize(lpos1-pos);\n\tfloat latt1 = pow( length(lpos1-pos)*.1, 1.5 );\n    float trans1 =  pow( clamp( dot(-rd, -ldir1+nor), 0., 1.), 1.) + 1.;\n\tvec3 diff1 = vec3(.0,.5,1.) * (max(dot(nor,ldir1),0.) ) / latt1;\n\tcol =  diff1;\n\tcol += vec3(.3,.2,.05) * (trans1/latt1)*thi;\n\n    for(int i = 0; i<6; i++){\n        float angle = float(i)/6.*PI*2.;\n        float radius = 30.;\n        vec3 lpos1 = vec3(cos(angle)*radius,5.,sin(angle)*radius);\n\t\tvec3 ldir1 = normalize(lpos1-pos);\n\t\tfloat latt1 = pow( length(lpos1-pos)*(.3+abs(sin(iTime)*2.)), 1. );\n    \tfloat trans1 =  pow( clamp( dot(-rd, -ldir1+nor), 0., 1.), 1.) + 1.;\n\t\tcol += vec3(.2,.2,.4) * (trans1/latt1)*thi;\n\t}\n    \n\tcol = max(vec3(.05),col);\n\tcol *= ao;\n\treturn col;\n}\n\n\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr )\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n\treturn mat3( cu, cv, cw );\n}\n\nvec3 orbit(float phi, float theta, float radius)\n{\n\treturn vec3(\n\t\tradius * sin( phi ) * cos( theta ),\n\t\tradius * cos( phi ),\n\t\tradius * sin( phi ) * sin( theta )\n\t);\n}\n\n//------------------------------------------------------------------ MAIN\nvoid mainImage( out vec4 fragColor, in vec2 coords )\n{\n\tfloat time = iTime;\n\tvec2 uv = coords.xy / iResolution.xy;\n\tvec2 mouse = iMouse.xy / iResolution.xy;\n\tvec2 q = coords.xy/iResolution.xy;\n\tvec2 p = -1.0+2.0*q;\n\tp.x *= iResolution.x/iResolution.y;\n\n\t//Camera\n\tfloat radius = 50.;\n\tvec3 ro = orbit(PI/2.-.5,PI/2.+time,radius);\n\tvec3 ta  = vec3(0.0, 0., 0.0);\n\tmat3 ca = setCamera( ro, ta, 0. );\n\tvec3 rd = ca * normalize( vec3(p.xy,1.6) );\n\n\t// Raymarching\n\tvec3 color = render( ro, rd, uv );\n\t#ifdef POSTPROCESS\n\tcolor = postEffects( color, uv, time );\n\t#endif\n\tfragColor = vec4(color,1.0);\n}\n\n//------------------------------------------------------------------ NOISE\n//AshimaOptim https://www.shadertoy.com/view/Xd3GRf\nvec4 permute(vec4 x){return mod(x*x*34.0+x,289.);}\nfloat snoise(vec3 v){\n  const vec2  C = vec2(0.166666667, 0.33333333333) ;\n  const vec4  D = vec4(0.0, 0.5, 1.0, 2.0);\n  vec3 i  = floor(v + dot(v, C.yyy) );\n  vec3 x0 = v - i + dot(i, C.xxx) ;\n  vec3 g = step(x0.yzx, x0.xyz);\n  vec3 l = 1.0 - g;\n  vec3 i1 = min( g.xyz, l.zxy );\n  vec3 i2 = max( g.xyz, l.zxy );\n  vec3 x1 = x0 - i1 + C.xxx;\n  vec3 x2 = x0 - i2 + C.yyy;\n  vec3 x3 = x0 - D.yyy;\n  i = mod(i,289.);\n  vec4 p = permute( permute( permute(\n\t  i.z + vec4(0.0, i1.z, i2.z, 1.0 ))\n\t+ i.y + vec4(0.0, i1.y, i2.y, 1.0 ))\n\t+ i.x + vec4(0.0, i1.x, i2.x, 1.0 ));\n  vec3 ns = 0.142857142857 * D.wyz - D.xzx;\n  vec4 j = p - 49.0 * floor(p * ns.z * ns.z);\n  vec4 x_ = floor(j * ns.z);\n  vec4 x = x_ *ns.x + ns.yyyy;\n  vec4 y = floor(j - 7.0 * x_ ) *ns.x + ns.yyyy;\n  vec4 h = 1.0 - abs(x) - abs(y);\n  vec4 b0 = vec4( x.xy, y.xy );\n  vec4 b1 = vec4( x.zw, y.zw );\n  vec4 s0 = floor(b0)*2.0 + 1.0;\n  vec4 s1 = floor(b1)*2.0 + 1.0;\n  vec4 sh = -step(h, vec4(0.0));\n  vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy ;\n  vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww ;\n  vec3 p0 = vec3(a0.xy,h.x);\n  vec3 p1 = vec3(a0.zw,h.y);\n  vec3 p2 = vec3(a1.xy,h.z);\n  vec3 p3 = vec3(a1.zw,h.w);\n  vec4 norm = inversesqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));\n  p0 *= norm.x;\n  p1 *= norm.y;\n  p2 *= norm.z;\n  p3 *= norm.w;\n  vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n  m = m * m * m;\n  return .5 + 12.0 * dot( m, vec4( dot(p0,x0), dot(p1,x1),dot(p2,x2), dot(p3,x3) ) );\n}", "image_inputs": [{"id": "XdSXR3", "previewfilepath": "https://soundcloud.com/acidarabofficial/sayarat-303", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0, "src": "https://soundcloud.com/acidarabofficial/sayarat-303", "ctype": "musicstream"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/Xsd3Rs.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "XsdGDS", "name": "King Kai's planet", "author": "hanmaokun", "description": "eiffie's [url=https://www.shadertoy.com/view/XtsGRH]car[/url] running on Xor's mountains, though believe it or not, I want to make a [url=http://dragonball.wikia.com/wiki/King_Kai%27s_planet]King Kai's planet[/url] originally.. :D ", "tags": ["raymarch", "car"], "likes": 5, "viewed": 304, "date": "1451998482", "time_retrieved": "2024-06-20T18:31:04.724542", "image_code": "#define CHANGE_SPEED 0.1\t\t\t\t/* terrain changing speed */\n#define VIEW_SCOPE   0.13\t\t\t\t/* view scope. */\n#define TRACK_WIDTH  12.\n#define TRACK_HEIGHT 9.\n\n/*=======================global variables========================*/\nvec2 uv;\nvec3 cameraOrigin, rayDir;\nfloat dh_car = 0.0;\nfloat cur_car_dir_ang_xz = 0.0;\nvec3 terrain_normal = vec3(0.0);\nvec3 carPos = vec3(0.0, 0.0, 0.0);\n\n/*=======================proto function declarations=============*/\nfloat terrain_map(vec3 p);\nfloat map(vec3 p);\n\n/*=======================shading utils===========================*/\nfloat sfract(float n){ return smoothstep(0.0,1.0,fract(n)); }\nfloat rand(vec3 n){ return fract(sin(dot(n,vec3(5.3357,-5.8464,5.7645)))*256.75+0.325); }\nfloat noise(vec3 n)\n{\n    float h1 = mix(rand(vec3(floor(n.x),floor(n.y),floor(n.z))),rand(vec3(ceil(n.x),floor(n.y),floor(n.z))),sfract(n.x));\n    float h2 = mix(rand(vec3(floor(n.x),ceil(n.y),floor(n.z))),rand(vec3(ceil(n.x),ceil(n.y),floor(n.z))),sfract(n.x));\n    float s1 = mix(h1,h2,sfract(n.y));\n\n    h1 = mix(rand(vec3(floor(n.x),floor(n.y),ceil(n.z))),rand(vec3(ceil(n.x),floor(n.y),ceil(n.z))),sfract(n.x));\n    h2 = mix(rand(vec3(floor(n.x),ceil(n.y),ceil(n.z))),rand(vec3(ceil(n.x),ceil(n.y),ceil(n.z))),sfract(n.x));\n    float s2 = mix(h1,h2,sfract(n.y));\n    return mix(s1,s2,sfract(n.z));\n}\n\nvec3 doMaterial( in vec3 pos, in vec3 nor )\n{\n    float tm = (noise(vec3(pos.xz/2.0,0.0)) + noise(vec3(pos.xz*4.0,0.0)))*0.25;\n    float th = (tm+noise(vec3(pos.xz,0.0))*0.25 + noise(vec3(pos.xz/2.0,0.0))*0.75);\n\n    float tn = noise(pos*64.0)*0.05 + noise(pos*32.0)*0.05 + noise(pos*16.0)*0.05 + 0.05;\n    return mix(vec3(0.035, tn, 0.025), vec3(tn), clamp(pow(th, 8.0)*0.2, 0.0, 1.0));\n}\n\nfloat calcSoftshadow( in vec3 ro, in vec3 rd )\n{\n    float res = 1.0;\n    float t = 0.5;                 \t\t// selfintersection avoidance distance\n\tfloat h = 1.0;\n    for( int i=0; i<4; i++ )         \t// 40 is the max numnber of raymarching steps\n    {\n        h = map(ro + rd*t);\n        res = min( res, 64.0*h/t );   \t// 64 is the hardness of the shadows\n\t\tt += clamp( h, 0.02, 2.0 );   \t// limit the max and min stepping distances\n    }\n    return clamp(res, 0.8, 1.0);\n}\n\nvec3 doLighting( in vec3 pos, in vec3 nor, in vec3 rd, in float dis, in vec3 mal )\n{\n    vec3 lin = vec3(0.0);\n\n    vec3  lig = normalize(vec3(1.0, 2.7, 0.09));\n    float dif = max(dot(nor, lig), 0.0);\n    float sha = 0.0; if( dif > 0.01 ) sha=calcSoftshadow( pos+0.01*nor, lig );\n\n    lin += dif * vec3(4.00, 4.00, 4.00) * sha;\n    lin += vec3(0.5);\n\n    vec3 col = mal * lin;\n\n\tcol = mix(vec3(0.9), col, 1.0 - clamp(dis * dis / 600.0, 0.0, 1.0));\n\n    return col;\n}\n\n/*=======================raymarching models======================*/\nfloat smin(float a,float b,float k){float h=clamp(0.5+0.5*(b-a)/k,0.0,1.0);return b+h*(a-b-k+k*h);}\nvec3 cp1;\nmat2 cm1;\nvec3 rc=vec3(0.7,0.26,1.5);\n\nmat2 trmx,mrmx;//the wheel spinners\nfloat minL,cc3,cc4;//car config\nvec4 trpc,cc;//color and stuff\nbool bColoring=false;\n\nmat3 rotationMatrix(vec3 axis, float angle)\n{\n    axis = normalize(axis);\n    float s = sin(angle);\n    float c = cos(angle);\n    float oc = 1.0 - c;\n\n    return mat3(oc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s,\n                oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s,\n                oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c);\n}\n\nfloat car_map(in vec3 p0){\n\tp0 -= carPos;\n\n\t/* rotation according to terrain surface normal. */\n    vec3 up_y = vec3(0., 1., 0.);\n\tvec3 axis = normalize(cross(up_y, terrain_normal));\n\tfloat rot_ang = acos(dot(terrain_normal, up_y) / (length(terrain_normal) * length(up_y)));\n\tp0 = rotationMatrix(axis, rot_ang) * p0;\n\n\t/* rotation in 'x-z' plane, to align car with the track direction. */\n\tp0 = rotationMatrix(vec3(0.0, 1.0, 0.0), -cur_car_dir_ang_xz + 3.14/2.) * p0;\n\n\t/* car model, from eiffie's https://www.shadertoy.com/view/XtsGRH */\n\tvec3 p=p0;\n\tp.y += 1.24;\n\tfloat d=length(max(vec3(abs(p.x)-0.35,length(p.yz)-1.92,-p.y+1.4),0.0))-0.05;\n\td=max(d,p.z-1.0);\n\tp=p0+vec3(0.0,-0.22,0.39);\n\tp.xz=abs(p.xz);\n\tfloat w1=0.24,w2=cc.z,dL=length(p+vec3(-0.3,0.0,-1.18-p0.z*0.17))-0.05;\n\tp.xz-=vec2(cc.w,1.0);\n\tif(p0.z<0.0){\n\t\tw1=cc.x;w2=cc.y;\n\t\tp.xy=mrmx*p.xy;\n\t}else p.xz=mrmx*p.xz;\n\tp.x=abs(p.x);\n\tfloat r=length(p.yz);\n\td=smin(d,length(vec2(max(max(p.x-w2,0.0),-p.y-0.08),r-w1))-0.02,0.25);\n\tfloat d1=length(vec2(max(p.x-w2-0.01,0.0),r-w1+0.05))-0.04;\n\tif(p0.z<0.0)p.yz=p.yz*trmx;\n\telse p.yz=trmx*p.yz;\n\tfloat d2=min(min(abs(p.z+p.y),abs(p.z-p.y)),min(abs(p.z),abs(p.y)));//8 blades\n\td2=max(r-w1+cc3,max(d2-0.003,p.x-w2+0.04));\n\td2=min(d2,dL);\n\tminL=min(minL,d2);//catch the minimum distance to the glowing things\n\tif(bColoring){\n\t\tif(d2<d && d2<d1){trpc+=vec4(1.0,0.6,0.5,256.0);}//spokes/turbines\n\t\telse if(d1<d){trpc+=vec4(vec3(clamp(1.0-(r-w1+0.09)*100.0,0.0,1.0)),256.0);}\n\t\telse {//the car's body\n\t\t\tif(p0.z<-1.04 || (abs(p0.y-0.58)>0.05-p0.z*0.09 || p0.z>0.25) && length(max(abs(p0.xz+vec2(0.0,-0.27))-vec2(0.18,0.39),0.0))>0.1)trpc+=vec4(1.0,0.9,0.4,16.0);\n\t\t\telse trpc += vec4(0.1, 0.2, 0.3, 2.0);//the windshield\n\t\t}\n\t}\n\treturn min(d,min(d1,d2));\n}\n\nvec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec4 mod289(vec4 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec4 permute(vec4 x) { return mod289(((x*34.0)+1.0)*x); }\nvec4 taylorInvSqrt(vec4 r) { return 1.79284291400159 - 0.85373472095314 * r; }\nfloat snoise(vec3 v)\n{\n  v.z = 0.;\t//comment out this line to see a shifting terrain.\n  const vec2  C = vec2(1.0/6.0, 1.0/3.0) ;\n  const vec4  D = vec4(0.0, 0.5, 1.0, 2.0);\n\n  vec3 i  = floor(v + dot(v, C.yyy) );\n  vec3 x0 =   v - i + dot(i, C.xxx) ;\n\n  vec3 g = step(x0.yzx, x0.xyz);\n  vec3 l = 1.0 - g;\n  vec3 i1 = min( g.xyz, l.zxy );\n  vec3 i2 = max( g.xyz, l.zxy );\n\n  vec3 x1 = x0 - i1 + C.xxx;\n  vec3 x2 = x0 - i2 + C.yyy;\n  vec3 x3 = x0 - D.yyy;\n\n  i = mod289(i);\n  vec4 p = permute( permute( permute(\n             i.z + vec4(0.0, i1.z, i2.z, 1.0 ))\n           + i.y + vec4(0.0, i1.y, i2.y, 1.0 ))\n           + i.x + vec4(0.0, i1.x, i2.x, 1.0 ));\n\n  float n_ = 0.142857142857;\n  vec3  ns = n_ * D.wyz - D.xzx;\n\n  vec4 j = p - 49.0 * floor(p * ns.z * ns.z);\n\n  vec4 x_ = floor(j * ns.z);\n  vec4 y_ = floor(j - 7.0 * x_ );\n\n  vec4 x = x_ *ns.x + ns.yyyy;\n  vec4 y = y_ *ns.x + ns.yyyy;\n  vec4 h = 1.0 - abs(x) - abs(y);\n\n  vec4 b0 = vec4( x.xy, y.xy );\n  vec4 b1 = vec4( x.zw, y.zw );\n\n  vec4 s0 = floor(b0)*2.0 + 1.0;\n  vec4 s1 = floor(b1)*2.0 + 1.0;\n  vec4 sh = -step(h, vec4(0.0));\n\n  vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy ;\n  vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww ;\n\n  vec3 p0 = vec3(a0.xy,h.x);\n  vec3 p1 = vec3(a0.zw,h.y);\n  vec3 p2 = vec3(a1.xy,h.z);\n  vec3 p3 = vec3(a1.zw,h.w);\n\n  vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));\n  p0 *= norm.x;\n  p1 *= norm.y;\n  p2 *= norm.z;\n  p3 *= norm.w;\n\n  vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n  m = m * m;\n  return 42.0 * dot( m*m, vec4( dot(p0,x0), dot(p1,x1),\n                                dot(p2,x2), dot(p3,x3) ) );\n}\n\nfloat terrain_map( vec3 p ) {\n    vec3 drpz = vec3(p.xz * VIEW_SCOPE, iTime * CHANGE_SPEED);\n\treturn p.y - snoise(drpz);\n}\n\nfloat map( vec3 p)\n{\n\tfloat d_terrain = terrain_map(p);\n\tfloat d_car     = car_map(p);\n\tdh_car = d_car - d_terrain;\n\treturn min(d_car, d_terrain);\n}\n\nfloat march(in vec3 ro, in vec3 rd)\n{\n\tconst float maxd = 30.0;\n\tconst float precis = 0.001;\n    float h = precis * 2.0;\n    float t = 0.0;\n\tfloat res = -1.0;\n    for(int i = 0; i < 32; i++)\n    {\n        if(h < precis*t || t > maxd) break;\n\t    h = map(ro + rd * t);\n        t += h;\n    }\n    if(t < maxd) res = t;\n    return res;\n}\n\n/*==========================main entry===========================*/\nvoid setConfig(){\n\tfloat t=mod(iTime,10.0);\n\tt=t-5.0;\n\tif(t>4.0)t=5.0-t;\n\tt=clamp(t,0.0,1.0);\n\tcc3=mix(0.06,-0.03,t);\n\tcc4=mix(0.0,-0.5,t);\n\tcc=mix(vec4(0.24,0.07,0.1,0.55),vec4(0.33,0.04,0.22,0.72),t);\n\n\tfloat tim=iTime*5.0,a=cc4*3.0;\n\ttrmx=mat2(cos(tim),sin(tim),-sin(tim),cos(tim));\n\tmrmx=mat2(cos(a),sin(a),-sin(a),cos(a));\n\n\t// car position and rotation params calculation\n\tfloat ang = mod(iTime/2., 6.28) - 3.14;\n\tfloat car_pos_x = (TRACK_WIDTH * TRACK_HEIGHT)/sqrt((pow(TRACK_HEIGHT, 2.) + pow(TRACK_WIDTH, 2.)*tan(ang)*tan(ang)));\n\tif((ang > 3.14/2.) || (ang < -3.14/2.)) {\n\t\tcar_pos_x *= -1.0;\n\t}\n\tfloat car_pos_z = car_pos_x * tan(ang);\n    vec3 pos = vec3(vec2(car_pos_x, car_pos_z) * VIEW_SCOPE, iTime * CHANGE_SPEED);\n\tfloat car_pos_y = snoise(pos);\n\tcarPos = vec3(car_pos_x, car_pos_y, car_pos_z);\n\tcur_car_dir_ang_xz = atan(-pow(TRACK_HEIGHT, 2.) * car_pos_x, pow(TRACK_WIDTH, 2.) * car_pos_z);\n\tvec2 eps = vec2(0.0, 0.001);\n\tterrain_normal = normalize(\n\t\t\tvec3(\n\t\t\t\tterrain_map(vec3(carPos + eps.yxx)) - terrain_map(vec3(carPos - eps.yxx)),\n\t\t\t\tterrain_map(vec3(carPos + eps.xyx)) - terrain_map(vec3(carPos - eps.xyx)),\n\t\t\t\tterrain_map(vec3(carPos + eps.xxy)) - terrain_map(vec3(carPos - eps.xxy))\n\t\t\t)\n\t);\n}\n\nvoid initWorldCoords(in vec2 fragCoord) {\n    uv = fragCoord.xy / iResolution.xy;\n\tuv = 2. * uv - 1.;\n\tuv.x *= iResolution.x/iResolution.y;\n    cameraOrigin = vec3(0.0, 4, -12);\n\tvec3 cameraTarget = vec3(0, 0.0, 0);\n\tvec3 upDirection = vec3(0.0, -1.0, 0.0);\n\tvec3 cameraDir = normalize(cameraTarget - cameraOrigin);\n\tvec3 cameraRight = normalize(cross(upDirection, cameraOrigin));\n\tvec3 cameraUp = cross(cameraDir, cameraRight);\n    rayDir = normalize(cameraRight * uv.x + cameraUp * uv.y + cameraDir);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tinitWorldCoords(fragCoord);\n\n\tsetConfig();\n\tfloat tim=iTime*5.0,a=cc4*3.0;\n\ttrmx=mat2(cos(tim),sin(tim),-sin(tim),cos(tim));//the turbine spinner\n\tmrmx=mat2(cos(a),sin(a),-sin(a),cos(a));\n\ttim=iTime*0.5;\n\n    float t = march(cameraOrigin, rayDir);\n\n\t/* ==================shading==================*/\n    vec3 col = vec3(0.9);\n\n    if(t > -0.001)\n    {\n        vec3 pos = cameraOrigin + t * rayDir;\n        float noise = mix(0.6, 1.0, pos.y);\n        col = vec3(noise);\n\n\t\tif(dh_car < 0.) {\n\t\t\t/* shade car. */\n\t    \tvec3 L=normalize(vec3(0.5,0.5,-0.5));\n\t\t\tvec3 p = pos;\n\t\t\tvec2 v=vec2(2.0/iResolution.y,0.0);\n\t\t\ttrpc=vec4(0.0); bColoring=true;\n\t\t\tvec3 N=normalize(vec3(-car_map(p-v.xyy)+car_map(p+v.xyy),-car_map(p-v.yxy)+car_map(p+v.yxy),-car_map(p-v.yyx)+car_map(p+v.yyx)));\n\t\t\tcol=trpc.rgb*0.1666*max(0.2,0.25+0.75*dot(N,L));\n\t\t\tcol*=mix(vec3(0.5,0.5,1.0),vec3(1.0,1.0,0.5),abs(dot(rayDir,N)));\n\t\t\tcol+=vec3(1.0,0.5,0.0)*pow(max(0.0,dot(reflect(rayDir,N),L)),trpc.a);\n\t\t}else {\n\t\t\t/* shade terrain. */\n\t\t\tvec2 eps = vec2(0.0, 0.01);\n\t\t\tvec3 normal = normalize(\n\t\t\t\t\tvec3(\n\t\t\t\t\t\tmap(vec3(pos + eps.yxx)) - map(vec3(pos - eps.yxx)),\n\t\t\t\t\t\tmap(vec3(pos + eps.xyx)) - map(vec3(pos - eps.xyx)),\n\t\t\t\t\t\tmap(vec3(pos + eps.xxy)) - map(vec3(pos - eps.xxy))\n\t\t\t\t\t)\n\t\t\t);\n\t\t\tvec3 mal = doMaterial( pos, normal );\n\t\t\tcol = doLighting( pos, normal, rayDir, t, mal );\n\n\t\t\t/* draw race track */\n\t\t\tfloat pwa = pow(TRACK_WIDTH, 2.), pwb = pow(TRACK_HEIGHT, 2.);\n\t\t\tfloat pwx = pos.x * pos.x, pwy = pos.z * pos.z;\n\t\t\tfloat x1 = sqrt(pwa*pwb*pwx / (pwb*pwx + pwa*pwy));\n\t\t\tfloat x2 = -x1;\n\t\t\tfloat x0 = pos.x * x1 > 0. ? x1:x2;\n\t\t\tfloat z0 = pos.z * x0 / pos.x;\n\t\t\tvec2 uv_c = vec2(x0, z0);\n\t\t\tif(distance(uv_c, vec2(pos.x, pos.z)) < 2.2) {\n\t\t\t\tfloat y0 = snoise(vec3(uv_c * VIEW_SCOPE, iTime * CHANGE_SPEED));\n\t\t\t\tfloat dist = distance(pos, vec3(x0, y0, z0));\n\t\t\t\tfloat d_abs = abs(dist);\n\t\t\t\tcol = mix(vec3(0.3 - d_abs/4.), col, pow(smoothstep(0.0, 1.5, d_abs), 5.));\n\t\t\t\tfloat a = atan(z0, x0);\n\t\t\t\ta = mod(a*39.1, 3.0);\n\t\t\t\tif(a > 1.8) {\n\t\t\t\t\tcol = mix(vec3(1.0), col, smoothstep(0., 0.02, d_abs));\n\t\t\t\t}\n\t\t\t\tif(d_abs > 1.1) {\n\t\t\t\t\tcol = mix(vec3(1.0), col, smoothstep(1.1, 1.13, d_abs));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n    }\n\n    fragColor = vec4(col, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/XsdGDS.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "XsG3zm", "name": "binoculars", "author": "nicoptere", "description": "a 2D transition", "tags": ["2d", "effect", "transition"], "likes": 2, "viewed": 1235, "date": "1453658309", "time_retrieved": "2024-06-20T18:31:04.966897", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    vec3 rgb = vec3( uv, 0.5+0.5*sin( iTime ) );\n\tvec3 color = vec3(0.);\n    \n    float radius = 0.5 + cos( iTime ) * .5;\n    float gradientLength = abs( sin( iTime * 3. ) * .1 );\n    \n    //the 'binoculars'\n    //get a normalized screen position in the range [-1,1]\n    vec2 p =  2. * ( fragCoord.xy / iResolution.xy ) - 1.;\n    //with the same aspect ratio as the screen\n    p.x *= iResolution.x / iResolution.y;\n\n    //left eye / right eye\n    vec2 le = vec2( -.4, 0. );\n    vec2 re = vec2(  .4, 0. );\n\n    //we'll compute a distance to the eyes' locations and a radius\n    //beyond which we'll use a flat color d is the union of the 2 eyes\n    float d = max(  ( 1.-( distance( p, le ) * radius )  ) ,  ( 1.-( distance( p, re ) * radius )  ) );\n\n    //if d < .5 -> transparent\n    //if d > .5 -> opaque color\n    // .55 - .5 = 0.05 : that's the opaque to transparent gradient's length\n    rgb = mix( color, rgb, smoothstep( 0.5, 0.5 + gradientLength, d ) );\n    fragColor = vec4( rgb, 1. );\n    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/XsG3zm.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "XsGGRw", "name": "Spinning Rings Mini", "author": "squid", "description": "More spinning rings!", "tags": ["3d", "raymarch", "short"], "likes": 10, "viewed": 612, "date": "1453846891", "time_retrieved": "2024-06-20T18:31:05.178905", "image_code": "//Code initially from FabriceNeyret2 (https://www.shadertoy.com/view/ltBSRy), \n// who took it from Trisomie21: https://www.shadertoy.com/view/4tfGRB#\n\n//You would think that these shorter shaders would be faster...\n\n#define T (iTime*.06)\n#define r(t) mat2( C = cos(t*T), S = sin(t*T), -S, C )\n#define Q  P.xz*=F;P.yz*=F; x = min(x, length( vec2( length(P.xz) - (R-=.1), P.y ) ) - .03);\n\nvoid mainImage( out vec4 f, vec2 w ) {\n    float C,S,R,x=1.; f=vec4(0.);\n    vec4 p = vec4(w,0,1)/iResolution.yyxy-.5, d=p, P;\n    d.x -= .3; p.z -= 1.5;          \n    mat2 F = r(6.);\n    for (float i = 1.; i>0.; i-=.03) \n    {\n        P=p;R=1.;\n        float z = 0.;\n        \n        Q Q Q Q Q Q\n                    \n        if(x<.02) {\n            f.x=i+.3;\n            f.y=i*i; \n            return;\n        } \n        \n        p -= d*x*1.3;\n     }\n }\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/XsGGRw.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "XsK3WR", "name": "Circular to hexa morphing", "author": "Emil", "description": "I'm not sure yet but I think I could use this on a particle system...", "tags": ["2d", "simple", "bokeh"], "likes": 8, "viewed": 401, "date": "1454011676", "time_retrieved": "2024-06-20T18:31:05.178905", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float blurry = sin(iTime)*0.25+0.25;\n\tvec2 uv = (2.*fragCoord.xy - iResolution.xy) / iResolution.y;\n    float rad = ((atan(uv.x,uv.y)*0.31830988618379067153776752674503)*0.5)+0.5;\n    float d = length(uv);\n    float pattern  = abs(sin((rad)*6.0*3.141592653))*d;\n    float re = d + (0.26*pattern)*(0.5-blurry);\n    float r = ((cos(-blurry*20.0+d*60.0*(re-0.25))*0.25)+0.5);\n    float g = ((cos(-0.25-blurry*20.0+d*70.0*(re-0.25))*0.25)+0.5);\n    float b = ((cos(-0.5-blurry*20.0+d*80.0*(re-0.25))*0.25)+0.5);\n\tfragColor = 0.6*vec4(smoothstep(0.5+blurry,0.48-blurry,re));\n    \n    vec4 diffract = vec4(r,g,b,1.0)*(clamp((0.3-abs(0.5-d))*3.0,0.0,1.0))*0.1;\n\tfragColor = 2.0*(diffract*1.0*blurry+(0.4-blurry*0.1)*vec4(smoothstep(0.5+blurry,0.48-blurry,re)));\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/XsK3WR.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "XsKGzm", "name": "Alien Tunnel Timewarp", "author": "cacheflowe", "description": "Experimenting with more complex shapes, but still not very complex at all, and I have no idea what I'm doing.", "tags": ["lattice"], "likes": 9, "viewed": 991, "date": "1453864935", "time_retrieved": "2024-06-20T18:31:05.706421", "image_code": "#define ITERATIONS 512\n\nfloat smin( float a, float b, float k )\n{\n    float res = exp( -k*a ) + exp( -k*b );\n    return -log( res )/k;\n}\n\nfloat smin( float a, float b )\n{\n    return smin(a, b, 12. + 4. * sin(iTime/2.));\n}\n\n\nfloat sdCylinder( vec3 p, vec3 c )\n{\n  return length(p.xz-c.xy)-c.z;\n}\n\nfloat udRoundBox( vec3 p, vec3 b, float r ) {\n  return length(max(abs(p)-b,0.0))-r;\n}\n\n\nfloat opBlend( vec3 p ) {\n    vec3 boxSize = vec3(0.02 + 0.1 * sin(p.z/10.), 0.03 + 0.2 * sin(p.z/20.), 0.25);\n    float d1 = udRoundBox( p, boxSize, 0.1);\n    vec3 cylinderSize = vec3(0.01 + 0.005 * sin(p.z/10.), 0.01 + 0.02 * sin(p.z/20.), 0.01);\n    float d2 = sdCylinder(p, cylinderSize);\n    //return smin( d1, d2 );\n    return smin( d1, d2, 12. + 4. * sin(iTime/2.) );\n}\n\nfloat opRep( vec3 p, vec3 spacing ) {\n    vec3 q = mod(p, spacing) - 0.5 * spacing;\n    return opBlend(q);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // 1 : retrieve the fragment's coordinates\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    uv -= vec2(0.5, 0.5);\n\n\t// 2 : camera position and ray direction\n\tvec3 pos = vec3( 0, iTime/2., iTime );\n\tvec3 dir = vec3( uv.x, uv.y, 1.0 + 0.9 * sin(iTime/1.) );\n \n\t// 3 : ray march loop\n    // ip will store where the ray hits the surface\n\tvec3 ip;\n \n\t// variable step size\n\tfloat t = 0.0;\n\tfloat findThresh = 0.0001;\n\tint found = 0;\n    int last_i = 0;\n    \n\tfor(int i = 0; i < ITERATIONS; i++) {\n\t\tlast_i = i;\n        \n        //update position along path\n        ip = pos + dir * t;\n \n        //gets the shortest distance to the scene\n        //break the loop if the distance was too small\n        //this means that we are close enough to the surface\n \t\tfloat temp;\n\n\t\t// make a repeating SDF shape\n        vec3 spacings = vec3(0.7 + 0.4 * sin(iTime/4.), 0.5, 0.5);\n\t\ttemp = opRep( ip, spacings );\n\t\tif( temp < findThresh ) {\n\t\t\tfloat r = 0.5 + 0.2 * sin(ip.z/2. + iTime/2. + ip.y/4.);\n\t\t\tfloat g = 0.3 + 0.2 * sin(ip.z/4. + iTime/2. - ip.y/2.);\n\t\t\tfloat b = 0.6 + 0.3 * sin(ip.z/3. + iTime/2. + ip.y/1.);\n\t\t\tip = vec3(r, g, b);\n\t\t\tfound = 1;\n\t\t\tbreak;\n\t\t}\n\t\t\n\t\t//increment the step along the ray path\n\t\tt += temp;\n\t}\n\t\n\t// make background black if no shape was hit\n\tif(found == 0) {\n\t\tip = vec3(0,0,0);\n\t}\n \n\t// 4 : apply color to this fragment\n    // subtract from color as distance increases\n\tfragColor = vec4(ip - (float(last_i)/0.5) / float(ITERATIONS), 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/XsKGzm.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "Xst3Wj", "name": "hello world 4", "author": "njazz", "description": "trying to understand that", "tags": ["raymarching"], "likes": 0, "viewed": 140, "date": "1452248928", "time_retrieved": "2024-06-20T18:31:05.706421", "image_code": "//based on this:\n//http://iquilezles.org/www/articles/distfunctions/distfunctions.htm\n//http://iquilezles.org/www/articles/menger/menger.htm\n\nvec3 w2s(vec3 p)\n{\n\tp.xy *= (-1.-1.*p.z);\n    return p;\n}\n\nfloat sdSphere( vec3 p, float s )\n{\n    return length(p)-s;\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return min(max(d.x,max(d.y,d.z)),0.0) +\n         length(max(d,0.0));\n    \n   \n}\n\nfloat maxcomp(vec2 v1)\n{\n\treturn max(v1.x,v1.y);\n}\nfloat sdCross( in vec3 p )\n{\n    float inf = 40.;\n    float size = 2.;\n    \n  float da = sdBox(p.xyz,vec3(inf,size,size));\n  float db = sdBox(p.yzx,vec3(size,inf,size));\n  float dc = sdBox(p.zxy,vec3(size,size,inf));\n    \n  //float da = maxcomp(abs(p.xy));\n  //float db = maxcomp(abs(p.yz));\n  //float dc = maxcomp(abs(p.zx));\n    \n  return min(da,min(db,dc));\n    \n  //  return db;\n}\n\n\n//float opScale( vec3 p, float s )\n//{\n//    return primitive(p/s)*s;\n//}\n\nfloat udRoundBox( vec3 p, vec3 b, float r )\n{\n  return length(max(abs(p)-b,0.0))-r;\n}\n\nfloat opS( float d1, float d2 )\n{\n    return max(-d1,d2);\n}\n\nfloat opU( float d1, float d2 )\n{\n    return min(d1,d2);\n}\n\nfloat opRep( vec3 p, vec3 c )\n{\n    //too lazy to clean up\n    \n    vec3 q = p;//mod(p,c)-0.5*c;\n    \n    //vec3 q3 = mod(p,vec3(4.,4.,10.)) - 0.5*vec3(4.,4.,10.);\n    \n    \n    \n    float w = cos(iTime/8.)*3.1415*1.;\n    vec3 q2 ;\n    \n    q2.x = q.x*cos(w)+q.z*sin(w);\n   q2.z = q.x*-sin(w)+q.z*cos(w);\n    q2.y = q.y;\n    \n    q = q2;\n    \n    //float z = 0.67*sin(iTime*2.9);\n\t\n    //float res = sdSphere( q, 1.9+z );\n    //res = opS (  udRoundBox(q,vec3(1.7,1.7,1.), 0.5), res);\n    \n    float res;\n    \n    float d,e;//= udRoundBox(q+vec3(0.,0.,0.),vec3(15.), 0.5);\n  \n    \n    //new code\n    d = sdSphere(q,6.5);\n    \n    //d = sdBox(q,vec3(3.));\n    \n    //d=0.;\n    \n    float s = 1.;\n   \n    float step = 8.5+2.*sin(iTime/16.);\n    float scale2 = 3.+1.*cos(iTime/3.);//;\n    \n    \n   for( int m=0; m<5; m++ )\n   {\n       \n      vec3 a = mod( q*s, step )-0.5*step;\n      s *= scale2 ;\n      \n      vec3 r = a;//0.5*step - 1.*abs(a);\n       \n       r = 1.-scale2*(a);\n       \n\n      float c = sdCross(r)/s;///s;\n      d = max(d,-c);\n       e = min(e,c);\n   }\n    \n   //res = opU(udRoundBox(p,vec3(30.7,30.7,30.), 0.5), d);\n    //res = sdCross(q);\n    \n    float f = sdSphere(q,8.);\n    e = max(e,-f);\n    \n    res = min(d,e);\n    \n    return res;\n}\n\n\n\n\n\n\nfloat gMix(vec3 p)\n{\n    float z;// = (10.+0.001*sin(iTime*2.9))*iTime;\n    z = -7.-0.75*(1.+cos(iTime/4.));;\n\treturn opRep(p+vec3(0.,0.,z),vec3(1.,1.,1.));\t\n}\n    \n\n\n\n\nvec2 rM (vec3 ro, vec3 rd)\n{\n\tfloat dist;\n    \n    //ro.xy -= 0.5;\n    //rd.xy -= 0.5;\n    \n    //ro.xy *= (1.-1.5*ro.z);\n    //rd.xy *= (1.-1.5*rd.z);\n    \n    //ro = w2s(ro);\n    //rd = w2s(rd);\n    \n    vec3 rp = ro+rd;\n    \n    float eps = 0.003;\n    \n    float l=1.;\n    \n    for (int i=0;i<150;i++)\n    {\n    \tdist = gMix(ro+rd*l);\n        \n        rp += rd*dist;\n        \n        if (dist<eps)\n        {\n            //l = clamp(l,1.,20.);\n        \treturn vec2(l,1);\n            \n        }\n        l+= dist;\n        \n    }\n    //l = clamp(l,0.,25.);\n\treturn vec2(l,(l>20.)?-1.:1.);\n}\n\n\n\nvec3 gNorm(vec3 p)\n{\n    highp vec3 ret;\n    \n    //p = w2s(p);\n    \n    float eps = 0.0001;\n    \n    ret.r = gMix(p+vec3(eps,0,0.))-gMix(p-vec3(eps,0,0.));\n    ret.g = gMix(p+vec3(0.,eps,0.))-gMix(p-vec3(0,eps,0.));\n    ret.b = gMix(p+vec3(0.,0,-eps))-gMix(p-vec3(0,0,-eps));\n    \n    //ret = normalize(vec3(0,0.00025,0)+(ret));\n\treturn normalize(ret);\n}\n                        \nfloat gLamb(vec3 norm, vec3 lvec)\n{\n    return  clamp((dot((norm),lvec)),0.,1.);\n}  \n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = 2. * fragCoord.xy / iResolution.xy - 1.;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    vec3 rd = vec3(0.,0.,0.5)+1.*vec3(uv.xy,0);\n    //rd = normalize(rd);\n    vec3 ro = vec3(uv,0.);\n    \n    \n    vec2 rm_d = rM(ro,rd);\n    \n    bool v = (rm_d.y>0.);\n    \n    vec3 lv1 = w2s(vec3(-.2,-2.2,1.5));\n    lv1 = normalize(lv1);\n    \n    vec3 lv2 = w2s(vec3(-1.2,1.2,1.2));\n    lv2 = normalize(lv2);\n    \n    vec3 pos1 = vec3(uv.xy,rm_d.x);//vec3(vec2(-1.-1.*rm_d.x)*uv.xy,-rm_d.x);\n   \tpos1 = ro+rd*rm_d.x;\n    \n    vec3 n = (v)?gNorm(pos1):normalize(vec3(0.,0.,-0.));\n    //n = vec3(float(v));\n    //n = clamp(n,-1.,1.);\n    \n    vec3 suv = w2s(vec3(uv.xy,1.0));\n    vec3 hv = suv+lv1;\n    hv /= length(hv);\n    \n    vec3 suv2 = w2s(vec3(uv.xy,1.0));\n    vec3 hv2 = suv2+lv2;\n    hv2 /= length(hv2);\n    \n    float fog = pos1.z/8.;\n    fog = clamp(fog,0.,1.);\n    \n    vec3 fogC = vec3(0.75,0.75,0.75);\n    \n    float spec = 1.*clamp(pow(dot((n),(hv)),500.),0.,1.);\n    float spec2 = 1.*clamp(pow(dot((n),(hv2)),300.),0.,1.);\n    \n    \n    //shadows attempt 1\n    float ld = rM(pos1, lv1).x;\n    float ld2 = rM(lv1, pos1).x;\n    float sh = 1. - 0.5*float(ld!=ld2);\n    vec3 diffC = vec3(1.,0.,0.5)*gLamb(n, lv1);\n    diffC*=sh;\n    \n     ld = rM(pos1, lv2).x;\n     ld2 = rM(lv2, pos1).x;\n    \n     sh = 1. - 0.5*float(ld!=ld2);\n    \n    //reflection attempt 1\n    vec3 ref = reflect(pos1,n);\n    float r1 = rM(lv1, ref).x;\n    \n    diffC += clamp((1.-r1/1.5),0.,1.)*vec3(.5,.75,1.);\n    \n    //diffC = clamp(diffC,0.,1.);\n    diffC += vec3(0.25,.5,0.)*sh*gLamb(n, lv2);\n\n    //diffC = clamp(diffC,0.,1.);\n    \n    vec3 specC = spec*vec3(1.9,1.8,1.5);\n    specC += spec2*vec3(2.7,2.8,2.9);\n    \n    //\n    \n\n    \n    \n    //float ao = calcAO(pos1,n);\n    \n    fragColor = vec4(mix(diffC+specC,fogC,fog),1);\n    \n    //fragColor = vec4(rm_d.x*0.1,-rm_d.y,0,1);\n    //fragColor = vec4(n,1);              \n\t//fragColor = vec4(uv,0.5+0.5*sin(iTime),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/Xst3Wj.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "XstGRl", "name": "Everyday 002 - Pyramid", "author": "Makio64", "description": "Hi guys, this year I'm starting a \"everyday\" so here is a simple raymarching code template.\n\ncomments line 33 to get only one pyramid\n\nIf I'm doing anything wrong, thanks to let me know & Happy new year again!\n", "tags": ["raymarching", "basic", "pyramid", "everyday"], "likes": 7, "viewed": 739, "date": "1451717919", "time_retrieved": "2024-06-20T18:31:06.609349", "image_code": "// Pyramid - raymarching\n// By David Ronai / @Makio64\n\n//------------------------------------------------------------------ VISUAL QUALITY\n#define POSTPROCESS\n#define RAYMARCHING_STEP 40\n#define RAYMARCHING_JUMP 1.\n//------------------------------------------------------------------ DEBUG\n//#define RENDER_DEPTH\n//#define RENDER_NORMAL\n//#define RENDER_AO\n\nconst float PI = 3.14159265359;\n\n//------------------------------------------------------------------  SIGNED PRIMITIVES\n\nfloat sdBox( vec3 p, vec3 b ){ return length(max(abs(p)-b,0.0)); }\nfloat sdBox(vec3 p, vec3 b, float r) { return length(max(abs(p)-b,0.0))-r; }\nfloat sdGround( in vec3 p ){ return p.y; }\n\n//------------------------------------------------------------------ MAP\n\nfloat map( in vec3 pos ) {\n\tfloat d = 1000000.;\n\tvec3 q;\n\tfloat t = mod(iTime*2.,1.);\n\tfor(int i=-1; i < 10; i++){\n\t\tfloat ii = float(i);\n        float y = -.1+(-ii-t)*.2;\n        y += .2*t*smoothstep(8.,9.,ii);\n\t\tq = pos+vec3(0.,y,0.);\n        vec3 c = vec3(2.,0.,2.);\n        q = mod(q,c)-0.5*c;\n        float size = 1.-ii*.1-t*.1;\n\t\td = min(sdBox(q, vec3(size,.1,size)),d);\n\t}\n\td = min(d,sdGround(pos));\n\treturn d;\n}\n\n//------------------------------------------------------------------ RAYMARCHING\n\n#ifdef RENDER_DEPTH\nfloat castRay( in vec3 ro, in vec3 rd, inout float depth )\n#else\nfloat castRay( in vec3 ro, in vec3 rd )\n#endif\n{\n\tfloat tmax = 15.;\n\tfloat precis = .01;\n\tfloat t = 0.0;\n\tfloat res;\n\tfor( int i=0; i<RAYMARCHING_STEP; i++ )\n\t{\n\t\tvec3 pos = ro+rd*t;\n\t\tres = map( pos );\n\t\tif( res<precis || t>tmax ) break;\n\t\tt += res*RAYMARCHING_JUMP;\n\t\t#ifdef RENDER_DEPTH\n\t\tdepth += 1./float(RAYMARCHING_STEP);\n\t\t#endif\n\t}\n\treturn t;\n}\n\nvec3 calcNormal(vec3 pos) {\n    float eps = 0.001;\n\tconst vec3 v1 = vec3( 1.0,-1.0,-1.0);\n\tconst vec3 v2 = vec3(-1.0,-1.0, 1.0);\n\tconst vec3 v3 = vec3(-1.0, 1.0,-1.0);\n\tconst vec3 v4 = vec3( 1.0, 1.0, 1.0);\n\treturn normalize( v1 * map( pos + v1*eps ) +\n    \t              v2 * map( pos + v2*eps ) +\n        \t          v3 * map( pos + v3*eps ) +\n            \t      v4 * map( pos + v4*eps ) );\n}\n\nfloat hash( float n ){//->0:1\n\treturn fract(sin(n)*3538.5453);\n}\n\nfloat calcAO( in vec3 p, in vec3 n, float maxDist, float falloff ){\n\tfloat ao = 0.0;\n\tconst int nbIte = 6;\n\tfor( int i=0; i<nbIte; i++ )\n\t{\n\t\tfloat l = hash(float(i))*maxDist;\n\t\tvec3 rd = n*l;\n\t\tao += (l - map( p + rd )) / pow(1.+l, falloff);\n\t}\n\treturn clamp( 1.-ao/float(nbIte), 0., 1.);\n}\n\n\n//------------------------------------------------------------------ POSTEFFECTS\n\n#ifdef POSTPROCESS\nvec3 postEffects( in vec3 col, in vec2 uv, in float time )\n{\n\t// gamma correction\n\tcol = pow( clamp(col,0.0,1.0), vec3(0.45) );\n\t// vigneting\n\tcol *= 0.5+0.5*pow( 16.0*uv.x*uv.y*(1.0-uv.x)*(1.0-uv.y), 0.15 );\n\treturn col;\n}\n#endif\n\nvec3 render( in vec3 ro, in vec3 rd, in vec2 uv )\n{\n\tvec3 col = vec3(.0,.0,1.2);\n\n\t#ifdef RENDER_DEPTH\n\tfloat depth = 0.;\n\tfloat t = castRay(ro,rd,depth);\n\t#else\n\tfloat t = castRay(ro,rd);\n\t#endif\n\n\t#ifdef RENDER_DEPTH\n\treturn vec3(depth/10.,depth/5.,depth);\n\t#endif\n\n\tvec3 pos = ro + t * rd;\n\tvec3 nor = calcNormal(pos);\n\n\t#ifdef RENDER_NORMAL\n\treturn nor;\n\t#endif\n\n\tfloat ao = calcAO(pos,nor,1.,0.1);\n\t#ifdef RENDER_AO\n\treturn vec3(ao);\n\t#endif\n\n\tvec3 light = vec3(.2,.5,.5);\n    col = vec3(1.,.2,.2)*min(max(dot(nor,light),.0) + .05, 1.);\n\tcol *= ao;\n    vec3 fog = vec3(.0,0.,0.);\n\tcol = mix( col, fog, 1.0-exp( -0.05*t*t ));\n\n\treturn col;\n}\n\n\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr )\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n\treturn mat3( cu, cv, cw );\n}\n\nvec3 orbit(float phi, float theta, float radius)\n{\n\treturn vec3(\n\t\tradius * sin( phi ) * cos( theta ),\n\t\tradius * cos( phi ),\n\t\tradius * sin( phi ) * sin( theta )\n\t);\n}\n\n//------------------------------------------------------------------ MAIN\nvoid mainImage( out vec4 fragColor, in vec2 coords )\n{\n\tfloat time = iTime;\n\tvec2 uv = coords.xy / iResolution.xy;\n\tvec2 mouse = iMouse.xy / iResolution.xy;\n\tvec2 q = coords.xy/iResolution.xy;\n\tvec2 p = -1.0+2.0*q;\n\tp.x *= iResolution.x/iResolution.y;\n\n\t//Camera\n\tfloat radius = 5.;\n\tvec3 ro = orbit(PI/2.-.7,time,4.5);\n\tvec3 ta  = vec3(0.0, 0.5, 0.0);\n\tmat3 ca = setCamera( ro, ta, 0. );\n\tvec3 rd = ca * normalize( vec3(p.xy,2.) );\n\n\t// Raymarching\n\tvec3 color = render( ro, rd, uv );\n\t#ifdef POSTPROCESS\n\tcolor = postEffects( color, uv, time );\n\t#endif\n\tfragColor = vec4(color,1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/XstGRl.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "XsVGzm", "name": "Elephant Ear Plants", "author": "hsiangyun", "description": "try to model elephant ear plants...", "tags": ["raymarching", "distancefield", "leaf", "plant"], "likes": 32, "viewed": 1682, "date": "1453953874", "time_retrieved": "2024-06-20T18:31:08.730864", "image_code": "// Created by Hsiang Yun 2016 \n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// This shader is inspired by the leaf in https://www.shadertoy.com/view/ld3Gz2  (iq's Snail)\n\n\n/***************************\n\t\tUtility\n****************************/\n\nfloat rand(float id){\n    return fract(sin(id * 37.0) * 43758.5453);\n}\n\nfloat smin( float a, float b, float k )\n{\n  \tfloat h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\nfloat smax ( float a, float b, float k )\n{\n    return -smin(-a,-b, k);\n}\n\nfloat sub ( float a , float b )\n{\n    return smax(-b, a, 0.10);\n}\nvec2 rot ( vec2 p, float a ) \n{\n    a = radians(a);\n    float s = sin(a);\n    float c = cos(a);\n    return mat2(vec2(c, s), vec2( -s, c )) * p; \n}\n\n// http://research.microsoft.com/en-us/um/people/hoppe/ravg.pdf\nfloat det( vec2 a, vec2 b ) { return a.x*b.y-b.x*a.y; }\nvec3 getClosest( vec2 b0, vec2 b1, vec2 b2 ) \n{\n    float a =     det(b0,b2);\n    float b = 2.0*det(b1,b0);\n    float d = 2.0*det(b2,b1);\n    float f = b*d - a*a;\n    vec2  d21 = b2-b1;\n    vec2  d10 = b1-b0;\n    vec2  d20 = b2-b0;\n    vec2  gf = 2.0*(b*d21+d*d10+a*d20); gf = vec2(gf.y,-gf.x);\n    vec2  pp = -f*gf/dot(gf,gf);\n    vec2  d0p = b0-pp;\n    float ap = det(d0p,d20);\n    float bp = 2.0*det(d10,d0p);\n    float t = clamp( (ap+bp)/(2.0*a+b+d), 0.0 ,1.0 );\n    return vec3( mix(mix(b0,b1,t), mix(b1,b2,t),t), t );\n}\n\nvec4 sdBezier( vec3 a, vec3 b, vec3 c, vec3 p )\n{\n\tvec3 w = normalize( cross( c-b, a-b ) );\n\tvec3 u = normalize( c-b );\n\tvec3 v = normalize( cross( w, u ) );\n\n\tvec2 a2 = vec2( dot(a-b,u), dot(a-b,v) );\n\tvec2 b2 = vec2( 0.0 );\n\tvec2 c2 = vec2( dot(c-b,u), dot(c-b,v) );\n\tvec3 p3 = vec3( dot(p-b,u), dot(p-b,v), dot(p-b,w) );\n\n\tvec3 cp = getClosest( a2-p3.xy, b2-p3.xy, c2-p3.xy );\n\n\treturn vec4( sqrt(dot(cp.xy,cp.xy)+p3.z*p3.z), cp.z, length(cp.xy), p3.z );\n}\n\nfloat sdEllipse( vec2 p, vec2 r ) \n{\n    return ( length(p/r) - 1.0 ) * min(r.x,r.y);\n}\n\n/***************************\n\t\tGlobal\n****************************/\n#define INF 1.0e38\nstruct Hit\n{\n    float d;\n    float mID;\n    vec3 diff;\n    float thickness;\n};\n\nfloat leafID;\nvec3 darkgreen = vec3 ( 0.2,0.8,0.05) *0.02;\nvec3 yellow = vec3 ( 0.8,0.8,0.2)*0.04;\nvec3 leafClr()\n{\n    if ( leafID < 0.5 )\n        return darkgreen;\n    else if (leafID < 1.5 )\n        return darkgreen.yxz;\n    else if (leafID < 2.5 )\n        return darkgreen.zxy;\n    return yellow;\n}\nvec3 edgeClr()\n{\n    return yellow;\n}\n\n/***************************\n\tAlocasia Modeling\n****************************/\nvec2 sdVeins ( in vec3 p, in float rot_a, vec2 w, vec3 range, vec2 yoff, vec2 cnt_) \n{\n    float cntR = cnt_.x;\n    float cntL = cnt_.y;\n    float cnt = (p.x> 0.0) ? cntR : cntL;\n    float yoffsetR = yoff.x;\n    float yoffsetL = yoff.y;\n    float w2 = 0.01;\n    vec3 q = p ;\n    // stem \n    float dStem = abs(p.x) - w.x;\n    // offset & mirror\n    p.y += ( p.x > 0.0 ) ? yoffsetR : yoffsetL;\n    p.x = abs(p.x);    \n    q.x = abs(q.x);\n    // rotate\n    p.xy = rot ( p.xy, rot_a);\n    q.xy = rot ( q.xy, rot_a);\n    // repeat\n    p.y = sin (cnt* p.y) / cnt;\n    \n    float dVeins = abs(p.y) - 0.0005;\n    float dVeinRange = abs ( q.y + range.x  ) - range.y ;\n    // intersetion with range\n    dVeins = max ( dVeins, dVeinRange  ) ;\n    dVeins = smin ( dVeins, dStem, 0.01);\n    return vec2(dVeins, w.y);\n}\n\n\nHit sdLeaf ( in vec3 p, float rbias ) \n{\n    vec3 q = p;\n    float a = atan ( p.y, p.x ) ;\n    \n    // sharpen the heart shape\n    p.x = 1.1 * p.x * exp( -0.4*((p.y)));\n    float r = 1.0 - sin ( a ) ;  r += rbias;\n    \n    // veins \n  \tvec2 dVeins = sdVeins( p,28.0,  vec2(0.02,0.01), vec3(0.75,0.55,0.0), vec2(0.4,0.43), vec2(15.0,15.0));\n    vec3 p1 = p;\n    p1.x = abs(p1.x);\n    p1.y +=0.4;\n    p1.xy = rot(p1.xy,-110.0);\n    vec2 dVeins2 = sdVeins (p1, 42.0, vec2(0.005,0.01),vec3(0.8,0.7,0.1), vec2(0.0,0.03), vec2(20.0,15.0) );\n\n    vec3 p0 = p; \n    p.z += (1.0-smoothstep ( 0.0, 0.1, dVeins.x)) * 0.01; \n    p.z += (1.0-smoothstep ( 0.0, 0.05, dVeins2.x)) * 0.0025; \n   \n    // domain operation  \n    float dheart = length ( p ) -r ;\n    float mID = (p.z > 0.0) ? 1.5 : 0.5;\n    float dslab = abs(p.z) - 0.02;\n    float dhole = sdEllipse ( q.xy + vec2(0,-0.3), vec2(0.05,0.4));\n    float d = dheart ;\n    d = smax( d, dslab, 0.4);\n    d = sub ( d, dhole);   \n      \n    // vein material\n    float mVein1 = (1.0-smoothstep ( 0.0, dVeins.y, dVeins.x));\n    float mVein2 = (1.0-smoothstep ( 0.0, dVeins2.y, dVeins2.x));\n    float mVein = max ( mVein1, mVein2);\n   \t// leaf material \n    vec3 mat = mix( leafClr(), edgeClr() , smoothstep(-0.5 ,0.0, dheart )) ;\n    // final material  \n    mat += yellow * mVein * (1.0-smoothstep(-1.0,-0.25, dheart));\n    \n    // material stuff\n    Hit hit;\n    hit.d = d;\n    hit.mID = mID;\n    hit.diff = (mID > 1.0 ) ? mat :  mix( mix(edgeClr()*5.0,leafClr()*5.0,0.7), leafClr()*5.0 , smoothstep(-0.9 ,0.0, dheart ));;\n    hit.thickness = mVein * (1.0-clamp(smoothstep(-1.0,-0.35, dheart),0.0,1.0));\n \treturn hit;\n}\n\nHit sdDistortLeaf ( vec3 p ) \n{\n    // scale \n    p *= 0.45;\n    // bias\n    p.y -= 0.4;\n    p.z -= length(p.xy) *0.3 ;\n    p.z += 0.1;\n    // z vibration around the edge\n    vec3 q = p;\n    if ( q.x < 0.0 ) q.y-= 0.2;\n    q.x = abs(p.x);\n    float w = smoothstep(0.3,1.0, -q.y ) ; \n    q.xy = rot (q.xy, 30.0);\n    p.z += w * 0.1* sin(30.0*q.y*(1.0+q.y))* abs(p.x*p.x*p.x*q.x);\n  \n    // r vibration \n    vec3 v = q - vec3(0.0,-0.6,0.0);\n    float a2 = atan ( v.y, v.x);\n    float rbias = 0.04 * cos ( 22.0*a2);\n    // alocasia shape \n    return sdLeaf( p, rbias)   ;    \n}\n\nHit sdStem ( in vec3 p, vec3 a, vec3 b, vec3 c )\n{\n    float d = sdBezier( a, b, c, p ).x;\n    d = abs(d) - mix(0.08, 0.1, clamp(-p.y,0.0,1.0));\n\tHit hit;\n    hit.d = d ;\n    hit.mID = 2.5;\n    vec3 yellow = vec3 ( 0.8,0.8,0.2)*0.08;\n    hit.diff = yellow ;\n    hit.thickness = 1.0;\n    return hit;\n}\n\nHit sdAlocasia( in vec3 p, vec3 a, vec3 b, vec3 c, float leaf_rot )\n{\n    // translate the leaf to the top of the stem\n    vec3 offset =  a ;\n    vec3 q = p ;\n   \tq = q - offset; \n    q.yz = rot (q.yz, leaf_rot) ;\n    \n    Hit hitA = sdDistortLeaf ( q  ) ; \n    Hit hitB = sdStem ( p, a, b,c ) ;\n    Hit hit = hitA;\n    if ( hitB.d < 0.0001 ) hit = hitB;\n    hit.d = min ( hitA.d, hitB.d ) ;\n    return hit;\n}\n\nHit sdGround ( in vec3 p)\n{\n    Hit hit;\n    hit.d = p.y - 0.3;\n    hit.mID = 1.5;\n    hit.diff = texture ( iChannel0 ,p.xz*0.05).xyz*0.2;\n    hit.thickness = 1.0;\n    return hit;\n}\n\nHit sdScene ( in vec3 p )\n{\n    Hit h_grnd = sdGround ( p ) ;\n    \n    leafID = 0.0;    \n    if ( p.z > 0.0 )\n    {\n        p *= 0.9;\n        leafID = 0.0;\n        if (p.x > 0.0 )\n        {\n            leafID = 1.0;\n        }\n    }\n    else\n    {\n        leafID = 2.0;\n        if (p.x > 0.0 )\n        {\n            p *= 0.85;\n            leafID = 3.0;\n        }\n    }\n    float heightBais = rand( leafID + 5.0 ) * 4.0;\n    float sideBias = rand( leafID + 1.0 )* 1.5 +2.5; \n    vec3 a = vec3(0.0, 4.0+heightBais,sideBias);\n    vec3 b = vec3(0.0, 2.0+heightBais,sideBias * 0.1); \n    vec3 c = vec3(0.0, 0.0,0.0);    \n    p.x = abs(p.x);  \n\tp.z = abs(p.z);\n    p.xz = rot(p.xz, 40.0);\n    Hit h = sdAlocasia ( p, a, b, c, mix ( 30.0,40.0, rand(leafID))) ;\n    \n    \n    h.d = min ( h.d, h_grnd.d ) ;\n    if ( abs(h_grnd.d) < 0.001 )  return h_grnd;\n    return h;\n}\n\n/***************************\n\t\trender\n****************************/\n\nHit getMaterial( in vec3 p ) \n{\n    return sdScene ( p ); \n}\n\nfloat map( in vec3 p )\n{\n    return sdScene ( p ).d ;     \n}\n\nfloat raymarch( in vec3 ro, in vec3 rd )\n{\n\tconst float maxd = 50.0;          \n\tconst float precis = 0.0001;      \n    float h = precis*2.0;\n    float t = 0.00;\n\tfloat res = INF;\n    for( int i=0; i<90; i++ )         \n    {\n        //if( h<precis||t>maxd ) break;\n\t    h = map( ro+rd*t );\n        t += h;\n    }\n    if( t<maxd ) res = t;\n    return res;\n}\n\n\nvec3 calcNormal( in vec3 pos )\n{\n    const float eps = 0.001;            \n    const vec3 v1 = vec3( 1.0,-1.0,-1.0);\n    const vec3 v2 = vec3(-1.0,-1.0, 1.0);\n    const vec3 v3 = vec3(-1.0, 1.0,-1.0);\n    const vec3 v4 = vec3( 1.0, 1.0, 1.0);\n\treturn normalize( v1*map( pos + v1*eps ) + \n\t\t\t\t\t  v2*map( pos + v2*eps ) + \n\t\t\t\t\t  v3*map( pos + v3*eps ) + \n\t\t\t\t\t  v4*map( pos + v4*eps ) );\n}\n\nfloat softshadow( in vec3 ro, in vec3 rd )\n{\n    float res = 1.0;\n    float t = 0.0001;                 \n\tfloat h = 1.0;\n    for( int i=0; i<20; i++ )         \n    {\n        h = map(ro + rd*t);\n        res = min( res, 32.0*h/t );   \n\t\tt += clamp( h, 0.02, 2.0 );\n    }\n    return clamp(res,0.0,1.0);\n}\n\nvec3 getLightPos()\n{\n    float t = iTime;\n    return vec3(5.0*sin(t)*1.0,15.0+ 0.1*sin(t),cos(t)*5.0);\n}\n\nvec3 doLighting( in vec3 pos, in vec3 nml, in vec3 rd, in float dis, in Hit hit )\n{\n    vec3 lin = vec3(0.0);\n    // ambient \n    lin += vec3(0.5);  \n    // lighting factors\n    vec3 ldir = normalize( getLightPos());    \n    vec3 hal = normalize( ldir -rd );\n    float fre = clamp(1.0+dot(nml,rd), 0.0, 1.0 );\n    float ndl = dot( nml, ldir ) ;\n    float dif = max(ndl,0.0);\n    float spe1 = clamp( dot(nml,hal), 0.0, 3.0 );\n    // shadow \n    float sha = 0.0; \n    if( dif>0.01 ) sha= softshadow( pos+0.01*nml, ldir );\n    // simple lighiting\n    lin += pow( spe1, 1.0  + 5.0) * vec3(0.0);\n    lin += pow( fre,3.0) * dif * vec3(15.0) ;   \n    lin += dif * vec3(7.00)*sha;\n    \n    vec3 col = vec3(0.0);\n    col = hit.diff*lin;\n    \n    // leaf backface lighting \n    // http://http.developer.nvidia.com/GPUGems3/gpugems3_ch16.html\n    if (hit.mID < 1.0)\n    {       \n\t    float edl = clamp(dot (rd, ldir), 0.0, 1.0);\n\t    edl *= edl;     \n    \tlin +=  mix ( edl, -ndl, 0.1) *10.0* (1.0-hit.thickness);\n       \tcol = hit.diff * lin;\n    }\n    // fog\n\tcol *= exp(-0.01*dis*dis);\n\n    return col;\n}\n\n\nmat3 calcLookAtMatrix( in vec3 ro, in vec3 ta, in float roll )\n{\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(sin(roll),cos(roll),0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n    return mat3( uu, vv, ww );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = (-iResolution.xy + 2.0*fragCoord.xy)/iResolution.y;\n    vec2 m = iMouse.xy/iResolution.xy;\n    // camera \n    vec3 ro, ta;\n    float an = 0.3*iTime + 5.0*m.x;\n    float r = 10.0;\n\tro = vec3(r*sin(an), 3.0 +3.0* m.y,r*cos(an));\n    ta = vec3(0.0,6.0,0.0);    \n    mat3 camMat = calcLookAtMatrix( ro, ta, 0.0 );  \n\tvec3 rd = normalize( camMat * vec3(p.xy,1.0) ); \n    \n\tvec3 col = vec3 (0.0);\n\t// raymarch\n    float d  = raymarch( ro, rd );\n    if( d != INF )\n    {\n        float t = d;\n        vec3 pos = ro + t*rd;\n        vec3 nor = calcNormal(pos);\n        col = doLighting( pos, nor, rd, t,  getMaterial ( pos ) );        \n\t}\n    // sprite\n    vec3 ldir = normalize(getLightPos());\n    float lsprite =  clamp(pow (dot ( normalize(getLightPos()- ro), rd )*0.5+0.5, 128.0),0.0, 10.0);\n    lsprite = smoothstep(0.98,1.0, lsprite);\n\tcol += lsprite* lsprite;\n\n    // gamma\n\tcol = pow( clamp(col,0.0,1.0), vec3(0.4545) );\t   \n    fragColor = vec4( col, 1.0 );\n}\n", "image_inputs": [{"id": "Xsf3Rr", "previewfilepath": "/media/ap/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc-by-nc-sa-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/XsVGzm.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "XsyGRW", "name": "2D SDF Toy", "author": "hughsk", "description": "I've been using this to experiment with different DF operations, but keep losing my link to it! Putting it here for safe keeping :) Note that you can use the mouse to test raymarching.", "tags": ["2d", "sdf", "debug", "toy"], "likes": 94, "viewed": 5087, "date": "1453359259", "time_retrieved": "2024-06-20T18:31:09.573203", "image_code": "#define TRACE_STEPS 20\n#define TRACE_RAY\n\n// 0 = Distance Field Display\n// 1 = Raymarched Edges\n// 2 = Resulting Solid\n// 3 = Distance Field Polarity\n#define DISPLAY 0\n\n// 0 = Sine Wave\n// 1 = Circle\n// 2 = Offset Circle\n// 3 = Circle Join\n// 4 = Smooth Circle Join\n#define SCENE 3\n\n#if SCENE == 0\n  #define SAMPLER(p) shape_sine(p)\n#endif\n#if SCENE == 1\n  #define SAMPLER(p) shape_circle(p)\n#endif\n#if SCENE == 2\n  #define SAMPLER(p) shape_circle(p + vec2(0.7, 0))\n#endif\n#if SCENE == 3\n  #define SAMPLER(p) min(shape_circle(p - vec2(cos(iTime))), shape_circle(p + vec2(sin(iTime), 0)))\n#endif\n#if SCENE == 4\n  #define SAMPLER(p) shape_circles_smin(p, iTime * 0.5)\n#endif\n\nfloat smin(float a, float b, float k) {\n  float h = clamp(0.5 + 0.5 * (b - a) / k, 0.0, 1.0);\n  return mix(b, a, h) - k * h * (1.0 - h);\n}\n\nvec2 squareFrame(vec2 screenSize, vec2 coord) {\n  vec2 position = 2.0 * (coord.xy / screenSize.xy) - 1.0;\n  position.x *= screenSize.x / screenSize.y;\n  return position;\n}\n\nconst float PI = 3.14159265359;\n\nvec3 palette(float t, vec3 a, vec3 b, vec3 c, vec3 d) {\n  return a + b * cos(6.28318 * (c * t + d));\n}\n\n// r^2 = x^2 + y^2\n// r = sqrt(x^2 + y^2)\n// r = length([x y])\n// 0 = length([x y]) - r\nfloat shape_circle(vec2 p) {\n  return length(p) - 0.5;\n}\n\n// y = sin(5x + t) / 5\n// 0 = sin(5x + t) / 5 - y\nfloat shape_sine(vec2 p) {\n  return p.y - sin(p.x * 5.0 + iTime) * 0.2;\n}\n\nfloat shape_box2d(vec2 p, vec2 b) {\n  vec2 d = abs(p) - b;\n  return min(max(d.x, d.y), 0.0) + length(max(d, 0.0));\n}\n\nfloat shape_line(vec2 p, vec2 a, vec2 b) {\n  vec2 dir = b - a;\n  return abs(dot(normalize(vec2(dir.y, -dir.x)), a - p));\n}\n\nfloat shape_segment(vec2 p, vec2 a, vec2 b) {\n  float d = shape_line(p, a, b);\n  float d0 = dot(p - b, b - a);\n  float d1 = dot(p - a, b - a);\n  return d1 < 0.0 ? length(a - p) : d0 > 0.0 ? length(b - p) : d;\n}\n\nfloat shape_circles_smin(vec2 p, float t) {\n  return smin(shape_circle(p - vec2(cos(t))), shape_circle(p + vec2(sin(t), 0)), 0.8);\n}\n\nvec3 draw_line(float d, float thickness) {\n  const float aa = 3.0;\n  return vec3(smoothstep(0.0, aa / iResolution.y, max(0.0, abs(d) - thickness)));\n}\n\nvec3 draw_line(float d) {\n  return draw_line(d, 0.0025);\n}\n\nfloat draw_solid(float d) {\n  return smoothstep(0.0, 3.0 / iResolution.y, max(0.0, d));\n}\n\nvec3 draw_polarity(float d, vec2 p) {\n  p += iTime * -0.1 * sign(d) * vec2(0, 1);\n  p = mod(p + 0.06125, 0.125) - 0.06125;\n  float s = sign(d) * 0.5 + 0.5;\n  float base = draw_solid(d);\n  float neg = shape_box2d(p, vec2(0.045, 0.0085) * 0.5);\n  float pos = shape_box2d(p, vec2(0.0085, 0.045) * 0.5);\n  pos = min(pos, neg);\n  float pol = mix(neg, pos, s);\n\n  float amp = abs(base - draw_solid(pol)) - 0.9 * s;\n\n  return vec3(1.0 - amp);\n}\n\nvec3 draw_distance(float d, vec2 p) {\n  float t = clamp(d * 0.85, 0.0, 1.0);\n  vec3 grad = mix(vec3(1, 0.8, 0.5), vec3(0.3, 0.8, 1), t);\n\n  float d0 = abs(1.0 - draw_line(mod(d + 0.1, 0.2) - 0.1).x);\n  float d1 = abs(1.0 - draw_line(mod(d + 0.025, 0.05) - 0.025).x);\n  float d2 = abs(1.0 - draw_line(d).x);\n  vec3 rim = vec3(max(d2 * 0.85, max(d0 * 0.25, d1 * 0.06125)));\n\n  grad -= rim;\n  grad -= mix(vec3(0.05, 0.35, 0.35), vec3(0.0), draw_solid(d));\n\n  return grad;\n}\n\nvec3 draw_trace(float d, vec2 p, vec2 ro, vec2 rd) {\n  vec3 col = vec3(0);\n  vec3 line = vec3(1, 1, 1);\n  vec2 _ro = ro;\n\n  for (int i = 0; i < TRACE_STEPS; i++) {\n    float t = SAMPLER(ro);\n    col += 0.8 * line * (1.0 - draw_line(length(p.xy - ro) - abs(t), 0.));\n    col += 0.2 * line * (1.0 - draw_solid(length(p.xy - ro) - abs(t) + 0.02));\n    col += line * (1.0 - draw_solid(length(p.xy - ro) - 0.015));\n    ro += rd * t;\n    if (t < 0.01) break;\n  }\n\n  #ifdef TRACE_RAY\n    col += 1.0 - line * draw_line(shape_segment(p, _ro, ro), 0.);\n  #endif\n\n  return col;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  float t = iTime * 0.5;\n  vec2 uv = squareFrame(iResolution.xy, fragCoord);\n  float d;\n  vec3 col;\n  vec2 ro = vec2(iMouse.xy / iResolution.xy) * 2.0 - 1.0;\n  ro.x *= squareFrame(iResolution.xy, iResolution.xy).x;\n\n  vec2 rd = normalize(-ro);\n\n  d = SAMPLER(uv);\n\n  #if DISPLAY == 0\n    col = vec3(draw_distance(d, uv.xy));\n    col -= (iMouse.z > 0.0 ? 1.0 : 0.0) * vec3(draw_trace(d, uv.xy, ro, rd));\n  #endif\n  #if DISPLAY == 1\n    col += 1.0 - vec3(draw_line(d));\n    col += (iMouse.z > 0.0 ? 1.0 : 0.0) * vec3(1, 0.25, 0) * vec3(draw_trace(d, uv.xy, ro, rd));\n    col = 1. - col;\n  #endif\n  #if DISPLAY == 2\n    col = vec3(draw_solid(d));\n  #endif\n  #if DISPLAY == 3\n    col = vec3(draw_polarity(d, uv.xy));\n  #endif\n\n  fragColor.rgb = col;\n  fragColor.a   = 1.0;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/XsyGRW.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "XsyGzR", "name": "My first shadertoy, yay", "author": "sakri", "description": "Just trying to get the hang of this, I created some \"seed\" animation, then fidgeted with the values for a few hours until I got something nifty enough together.   At some moments this looks interesting, at others crap. Such is life.", "tags": ["2d"], "likes": 3, "viewed": 444, "date": "1452867036", "time_retrieved": "2024-06-20T18:31:09.573203", "image_code": "mat2 scale(vec2 _scale){\n    return mat2(_scale.x,0.0,\n                0.0,_scale.y);//copy paste from thebookofshaders\n}\n\nmat2 rotate2d(float _angle){\n    return mat2(cos(_angle),-sin(_angle),\n                sin(_angle),cos(_angle));//copy paste from thebookofshaders\n}\n\nvec3 getFragColorForTime(float time, float d, vec2 uv){\n    float moveDiv = 250.0;\n    float moveTime = time + 55787.0;\n    float moveValue = mod(moveTime , moveDiv) / moveDiv;\n    float rotation = sin(moveValue * 5.0 );\n    float scaleNum = moveValue / (moveValue * d);\n    float scaleOffset = cos(moveValue) * 10.0;\n    uv *= rotate2d( rotation );//apply rotation matrix\n    uv -= vec2(scaleOffset);//apply scale matrix\n    uv *= scale( vec2(scaleNum) );\n    uv += vec2(scaleOffset);\n    \n    vec2 xy = vec2( cos(uv.x), sin(uv.y) );\n    float div = 100.0;\n    float colorValue = mod(moveTime * xy.x * xy.y , div) / div;\n\treturn vec3(smoothstep(0.5, 0.7, colorValue));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    float d = max(iResolution.x, iResolution.y);\n\tvec2 uv = mod(fragCoord.xy , d);\n    vec3 color = getFragColorForTime(iTime, d, uv);//\"oldest value\", then \"smoooth\"\n    for(float i=0.01; i<0.3; i+=0.01){\n    \tcolor = mix(getFragColorForTime(iTime + i, d, uv), color, 0.82);\n    }\n    fragColor = vec4(smoothstep(0.5, 0.7, color), 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/XsyGzR.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
