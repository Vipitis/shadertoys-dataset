{"id": "3d2SRG", "name": "Terrain Example", "author": "peterekepeter", "description": "Just messing around with some terrain stuff an layering them textures.", "tags": ["terrainsnowgrass"], "likes": 2, "viewed": 105, "published": "Public API", "date": "1554207945", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n// tweakable values ///////////////////////////////////////////////////////////\n\nfloat water_level = 2.0;\nfloat snow_amount = 4.0;\nfloat grass_amount = 5.0;\nfloat sand_amount = 1.0;\nfloat rock_amount = 1.0;\n\nfloat sun_brightness = 12.0;\nfloat sky_brightness = 1.0;\nvec3 sun_direction = normalize(vec3(0.9,0.5,.2));\n\nvec3 color_sun = vec3(0.9,0.8,0.6);\nvec3 color_sky = vec3(0.2,0.4,0.9);\nvec3 color_snow = vec3(0.96, 0.98, 0.99);\nvec3 color_grass = vec3(0.3,0.5,0.2);\nvec3 color_dirt = vec3(0.24,0.16,0.12);\nvec3 color_rock = vec3(0.52,0.54,0.5);\nvec3 color_sand = vec3(0.9,0.8,0.4);\n        \n//#define SHOW_HEIGHT_LEVELS\n//#define SHOW_NORMALS        \n//#define SHOW_SHADOWS\n      \n\n// implementation begins //////////////////////////////////////////////////////\n\n// procedural 2d noise texture, for given (x,y) return value between 0 and 1\nfloat noise_2d(vec2 p);\n\nfloat distance_from_water(vec3 pos){\n    return pos.y+14.0-water_level;\n}\n\n// returns albedo for given (x,y,z) position and (nx, ny, nz) surface normal\nvec3 terrain_material(vec3 pos, vec3 normal){\n    \n    // altitude taken from y component\n    float altitude = pos.y+5.0;\n    \n    vec4 map1 = texture(iChannel0, pos.xz*0.1);\n    vec4 map2 = texture(iChannel1, pos.xz*0.05);\n    vec4 map3 = texture(iChannel2, pos.xz*0.025);\n    \n    vec3 color = vec3(0); // black\n    \n    // add dirt layer\n    color=mix(color_dirt,\n              color_dirt*0.125, // darker shade of dirt\n              map1.x); // use first texture to add variation\n    \n    // add rock layer\n    color=mix(color, \n              color_rock*map3.xyz*1.5-.1, // use third texture to add variation to rock\n              clamp( // clamp makes sure layer mask is valid (values between 0 and 1)\n                  8.0*(length(normal.xz)*rock_amount // slopes should be rocky\n                       + altitude*0.5-3.0+map1.z*0.5)*0.1, // add more rock at higher altitudes\n                    0.0, 1.0));\n    \n    float sand = clamp(normal.y*4.0*sand_amount // don't put sand on slope\n                       - distance_from_water(pos)*16.0 // the further we're from water, the less sand\n                       , 0.0, 1.0);\n    \n    // add sand layer\n    color=mix(color, color_sand, sand);\n    \n    // add grass layer\n    color=mix(color, \n              color_grass*map2.xyz*1.4, \n              clamp(map2.y*8.0 // add variation based on texture\n                    + normal.y*2.5 // add more grass on flat areas (not slope)\n                    + normal.x // more grass on east side of mountains\n                    - altitude*0.1 // less grass on higher altitudes\n                    - 10.0 + grass_amount // constant value to adjust grass amount\n                    - color.y*2.0 // less grass where previous layers have bright color\n                    - sand, // less grass where we have sand\n                    0.0,1.0));\n    \n    // add snow layer\n    color=mix(color, \n              color_snow, \n              clamp(map1.y*2.0 // add variation using texture 1\n                    + normal.y*4.0 // more snow on flat (not slope) terrain\n                    + altitude // more slow on higher altitude\n                    - 6.5 + snow_amount // manual adjustment using constant value\n                    , 0.0, 1.0));\n    \n    // make sure components of final color is not above 1.0f for correct shading\n    return clamp(color, 0.0, 1.0);\n}\n\nfloat heightmap(vec2 coord2d)\n{\n    float altitude =.0;\n    \n    // create a mask for mountain biome\n    float mountains = noise_2d(coord2d*0.05); \n    \n    altitude += noise_2d(coord2d*0.06125)*16.0*mountains; // rough shape of mountain \n    altitude += noise_2d(coord2d*0.25)*4.0*mountains;\n    altitude += noise_2d(coord2d*0.5+altitude*0.5)*2.0*mountains;\n    altitude += noise_2d(coord2d*2.0)*0.5*mountains;\n    altitude += noise_2d(coord2d*8.0)*0.125*mountains; // smaller details of mountain\n    \n    return altitude;\n}\n\nvec3 background_fn(vec3 dir){\n    \n    vec3 background = sky_brightness*color_sky*pow(2.0-abs(dir.y), 4.0);\n    return background + pow(max(.0,dot(dir, sun_direction)), 200.0)*sun_brightness;\n}\n\n// rendering and shading ////////////////////////////////////////////////\n\nfloat df(vec3 pos){ // distance from geometry\n    float terrain = pos.y+4.0;\n    terrain += 10.0-heightmap(pos.xz);\n    return min(terrain, distance_from_water(pos));\n}\n\nvec2 rot(vec2 v, float a){ // rotate\n    float c = cos(a), s = sin(a);\n    return vec2(\n        v.x*c - v.y*s,\n        v.x*s + v.y*c);\n}\n\nvec3 nf(vec3 pos, float smoothing){ // normal function\n    vec2 e = vec2(0, smoothing);\n    float c = df(pos+smoothing);\n    return normalize(vec3(\n        c-df(pos-e.yxx),\n        c-df(pos-e.xyx),\n        c-df(pos-e.xxy)\n    ));\n}\n\nfloat hash(float x); vec3 hash(vec3 v); float hash(vec2 v);\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 cuv = (fragCoord.xy-iResolution.xy*.5)/iResolution.yy;\n    vec2 mouse = (iMouse.xy-iResolution.xy*.5)/iResolution.yy;\n\n    vec3 opos = vec3(0,0,-4. +iTime*2.0);\n    vec3 pos = opos;\n    vec3 dir = normalize(vec3(cuv,1));\n    \n    //pos.xz = rot(pos.xz, mouse.x);\n    dir.xz = rot(dir.xz, mouse.x);\n    dir.yz = rot(dir.yz, mouse.y);\n    \n    \n    pos += hash(cuv)*dir;\n    \n    vec3 ldir = sun_direction;\n    \n    int i, mi=200;\n    float dist, spd=1.0;\n    for(i=0; i<mi; i=i+1){\n        dist = df(pos);\n        pos += dist*dir*spd;\n        if (dist<-0.0){\n            spd*=.5;\n        }\n        else if ((dist>0.005&&dist<0.005)||dist>100.0) { break; }\n    }\n    float totald = length(opos-pos);\n    \n    vec3 background = background_fn(dir);\n    vec3 color = background;\n    \n    if (dist < 0.1){\n        color=vec3(.0);\n        vec3 normal = nf(pos,0.2);\n        vec3 albedo;\n        \n        float refl=0.5;\n        if (distance_from_water(pos)<=dist){\n            refl=0.5;\n            albedo=vec3(0.15,0.19,0.13);\n            normal=vec3(0,1,0);\n        }else {\n        \talbedo = terrain_material(pos, normal);\n            refl=.0;\n        }\n        \n        #ifdef SHOW_HEIGHT_LEVELS\n        albedo = 1.0/(1.0+vec3(pow(abs(sin(pos.y*4.0)),0.5)));\n        refl=.0;\n        #endif\n        \n        #ifdef SHOW_NORMALS\n        albedo = (normal*.5+.5);\n        refl=.0;\n        #endif\n        \n        #ifdef SHOW_SHADOWS\n        albedo = vec3(1.0);\n        refl=.0;\n        #endif\n        \n        vec3 npos = pos;\n        float ao = .0;\n        int ao_i, max_ao_i=4;\n        for (ao_i=0; ao_i<max_ao_i; ao_i++){\n            float d=pow(1.1, float(ao_i-4));\n       \t\tvec3 ndir = (hash(npos)-0.5+vec3(0,0.5,0))*d;\n            npos = pos + ndir;\n            ao += (df(npos)+(d*.5))/d;\n        }\n        ao *= 1./float(max_ao_i);\n        ao=df(pos+normal)*.5+.5;\n        ao=df(pos+normal*0.5)+.5;\n        ao=df(pos+normal*4.0)*.25+.5;\n        color+=albedo*ao*color_sky*sky_brightness;\n        \n        float shadow=1.0;\n        int sh_i, sh_max=40;\n        vec3 spos = pos+ldir;\n        float strav =.1;\n        for(sh_i=0; sh_i<sh_max; sh_i++){\n            float dist = df(spos+ldir*strav);\n            shadow=min(dist/strav,shadow);\n            strav+=dist;\n            if(shadow<.001||dist>100.0){ break; }\n        }\n        shadow=max(.0,shadow);\n        float diffuse = max(0.,dot(normal, ldir));\n        color+=albedo*diffuse*color_sun*sun_brightness*shadow;\n        \n        if (refl>.0){\n            vec3 refldir=reflect(dir, normal);\n            color += background_fn(refldir)*refl;\n        }\n    }\n    color=max(vec3(.0), color);\n\tcolor = mix(background, color, 1.0/(1.0+totald*0.0025));\n    \n    color = color*1.2 / (1.+color);\n    // Output to screen\n    fragColor = vec4(color,1.0);\n}\n\n// implementation details /////////////////\n\n\nfloat hash(float x){ return fract(pow(sin(x*41.7179)*41.1536, 2.0)*13.145); }\nvec3 hash(vec3 v){ return vec3(hash(v.x+v.y), hash(v.y+v.z), hash(v.z+v.x)); }\nfloat hash(vec2 v){ return hash(v.x-v.y*59.7177); }\n\n// procedural 2d noise texture, for given (x,y) return value between 0 and 1\nfloat noise_2d(vec2 p){\n    vec2 f = fract(p);\n    vec2 id = p - f;\n    float a = hash(id.xy+vec2(0,0));\n    float b = hash(id.xy+vec2(1,0));\n    float c = hash(id.xy+vec2(0,1));\n    float d = hash(id.xy+vec2(1,1));\n    return mix(\n        mix(a,b, f.x),\n        mix(c,d, f.x),\n        f.y\n\t);\n}\n", "image_inputs": [{"id": "XsX3Rn", "previewfilepath": "/media/ap/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg", "ctype": "texture"}, {"id": "4df3Rr", "previewfilepath": "/media/ap/3871e838723dd6b166e490664eead8ec60aedd6b8d95bc8e2fe3f882f0fd90f0.jpg", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/3871e838723dd6b166e490664eead8ec60aedd6b8d95bc8e2fe3f882f0fd90f0.jpg", "ctype": "texture"}, {"id": "Xsf3Rr", "previewfilepath": "/media/ap/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3d2SRG.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[868, 868, 904, 904, 941], [943, 1020, 1065, 1109, 3374], [3376, 3376, 3407, 3407, 3901], [3903, 3903, 3932, 3932, 4096], [4173, 4173, 4192, 4218, 4341], [4343, 4343, 4369, 4379, 4479], [4481, 4481, 4516, 4535, 4712], [4775, 4775, 4832, 4882, 7733], [7781, 7781, 7801, 7801, 7858], [7859, 7859, 7877, 7877, 7937], [7938, 7938, 7957, 7957, 7989], [7991, 8068, 8091, 8091, 8363]], "test": "error"}
{"id": "3d2SW3", "name": "RayMarch_Demo", "author": "zlanto2024", "description": "RayMarch_demo, public", "tags": ["raymarch"], "likes": 1, "viewed": 49, "published": "Public", "date": "1555105999", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define MAX_STEPS 100\n#define MAX_DIST 100.\n#define SURF_DIST .01\n#define CAMERA_X 0.\n#define CAMERA_Y 3\n#define CAMERA_Z 0.\n#define LIGHT_Z 5.\n#define OBJ_Z 7.\n#define LIGHT_MOVE_SPEED 3.\n#define OBJ_MOVE_SPEED 3.\n\nfloat dBox(vec3 curMarchPoint, vec3 s)\n{\n    return length(max(abs(curMarchPoint) - s, 0.));\n}\n\nfloat sdTorus(vec3 curMarchPoint, vec2 r)\n{\n   float x = length(curMarchPoint.xz) - r.x;\n   return length(vec2(x, curMarchPoint.y)) - r.y;\n}\n\nfloat sdCapsule(vec3 curMarchPoint, vec3 sphereA, vec3 sphereB, float r)\n{\n    vec3 vAtoB = sphereB - sphereA;\n    vec3 vAtoP = curMarchPoint - sphereA;\n    \n    float dotAPonAB = dot(vAtoB, vAtoP) / dot(vAtoB, vAtoB);\n    dotAPonAB = clamp(dotAPonAB, 0., 1.);\n    \n    vec3 closestPointOnCapsule = sphereA + vAtoB * dotAPonAB;\n    \n    return length(curMarchPoint - closestPointOnCapsule) - r;\n}\n\nfloat sdSphereDist(vec3 curMarchPoint, vec3 pos, float r)\n{\n    return length(curMarchPoint - pos) - r;\n}\n\nfloat GetDist(vec3 curMarchPoint)\n{\n    vec2 iTimeInterp1 = vec2(sin(iTime * OBJ_MOVE_SPEED), cos(iTime * OBJ_MOVE_SPEED));\n    \n    //Sphere\n    vec4 sphereDef = vec4( 0, 2.5, OBJ_Z, 0.5f);\n    sphereDef.y += iTimeInterp1.y;\n    sphereDef.x += iTimeInterp1.x * .5;\n    float sphereDist = sdSphereDist(curMarchPoint, sphereDef.xyz, sphereDef.w);\n    \n    //Capsule\n    vec3 sphere1 = vec3( -2., 1., OBJ_Z);\n    vec3 sphere2 = vec3( -2., 1., OBJ_Z);\n    sphere1.xz += iTimeInterp1;\n    sphere2.xz -= iTimeInterp1;\n    float capsuleRad =  0.2;\n    float capsuleDist = sdCapsule(curMarchPoint, sphere1, sphere2, capsuleRad);\n    \n    //Torus\n    vec3 torusPos = vec3(0.f, 1., OBJ_Z);\n    torusPos.xz += iTimeInterp1;\n    vec2 torusSize = vec2(1., .2);\n    float torusDist = sdTorus(curMarchPoint - torusPos, torusSize);\n    \n    vec3 boxPos = vec3(0., 1., OBJ_Z);\n    boxPos.xz += iTimeInterp1;\n    vec3 boxSize = vec3(.5);\n    float boxDist = dBox(curMarchPoint - boxPos, boxSize);\n    \n    //Plane\n    float planeDist = curMarchPoint.y;\n    \n    float retDist = min(planeDist, sphereDist);\n    retDist = min(retDist, capsuleDist);\n    retDist = min(retDist, torusDist);\n    retDist = min(retDist, boxDist);\n    \n    return retDist;\n}\n\nfloat RayMarch(vec3 rayOrigin, vec3 rayDir)\n{\n    float distFromOrigin = 0.f;\n    \n    for (int i = 0; i < MAX_STEPS; i++)\n    {\n        vec3 currMarchPoint = rayOrigin + rayDir * distFromOrigin;\n        \n        //gets the min radius from currMarchPoint to the scene\n        float distToScene = GetDist(currMarchPoint); \n        distFromOrigin += distToScene;\n        \n   \t\tif (distFromOrigin > MAX_DIST || distToScene < SURF_DIST) break;\n    }\n    \n    return distFromOrigin;\n}\n\nvec3 GetNormal(vec3 p)\n{\n    float distP = GetDist(p);\n    vec2 e = vec2(0.01, 0); //epsilon vec\n    \n    vec3 normal = distP - vec3 (GetDist(p-e.xyy), GetDist(p-e.yxy), GetDist(p-e.yyx));\n    \n    return normalize(normal);\n}\n\nfloat GetLight(vec3 p)\n{\n    //Simple diffuse light model\n    vec3 lightPos = vec3 (0, 10, LIGHT_Z);\n    lightPos.xz += vec2(sin(iTime * LIGHT_MOVE_SPEED), cos(iTime * LIGHT_MOVE_SPEED));\n    \n    vec3 dirToLight = normalize(lightPos - p);\n    vec3 normalPointP = GetNormal(p);\n    \n    float diffuseLight = clamp(dot(normalPointP, dirToLight), 0., 1.);\n    \n    //shadow\n    float shadowDist = RayMarch(p + normalPointP * SURF_DIST * 2.f, dirToLight);\n    if (shadowDist < length(lightPos - p) && true)\n    {\n        diffuseLight *= 0.1f;\n    }\n    \n    return diffuseLight;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n\t\n    //Ray fire from center and direction of each pixel\n    vec3 rayOrigin = vec3(CAMERA_X, CAMERA_Y, CAMERA_Z);\n    vec3 rayDir = normalize(vec3(uv.x, uv.y-0.4, 1));\n    \n    float intersectionDist = RayMarch(rayOrigin, rayDir);\n    \n    vec3 shadePoint = rayOrigin + rayDir * intersectionDist;\n    float diffuseColor = GetLight(shadePoint);\n    \n    vec3 col = vec3(diffuseColor);\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3d2SW3.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[216, 216, 256, 256, 310], [312, 312, 355, 355, 452], [454, 454, 528, 528, 850], [852, 852, 911, 911, 957], [959, 959, 994, 994, 2191], [2193, 2193, 2238, 2238, 2672], [2674, 2674, 2698, 2698, 2899], [2901, 2901, 2925, 2958, 3478], [3480, 3480, 3537, 3587, 4095]], "test": "ok"}
{"id": "3d2SWc", "name": "Living noise", "author": "AlexK", "description": "An attempt to make scalable and dynamic base for time and scale dependent procedural stuff. It can be iterated huge number of times without noticeable loss in performance, however it do not work after 24 iteration correctly because of float precision.", "tags": ["noise", "life"], "likes": 5, "viewed": 133, "published": "Public", "date": "1555138783", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float[] seed = float[](.25, .5,\n                     .75, 1.) ;\n\n\nfloat rnd(float seed){\n\treturn fract((1. - cos((seed + 21.2313662551) * 37.6447205633))/2.);\n}\n\nvec2 color(vec2 uv, float col, int i, float r){\n    int x = int(uv.x * 2.)%2;\n    int y = int(uv.y * 2.)%2;\n\n    float c;\n    \n    float r1 = rnd(float(i));\n    float r2 = rnd(seed[y * 2 + x]);\n    \n    float r3 = rnd((r1 + r2) * r);\n    \n    \n    c = (col + r3 + col * (r3 - 0.5) * 0.6) * 1.2 ;\n    \n\treturn vec2(c, r3);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.y;\n    \n    uv -= vec2(1.1, 0.6);\n    \n    // Starting at 200000x zoom and move it to 1x over period of 30s\n    float zoom = 1. / min(1., mix(0.000005, 1., pow((1. + iTime) / 30., 5.)));\n    uv = uv / zoom;\n    \n    uv += vec2(1.1, 0.6);\n    uv.y = 1. - uv.y;\n    uv.x += -0.4;\n        \n    float inn = iTime * 0.3;\n    float val = 0.5; \n    vec2 n_uv = uv;\n    float r = 1.;\n    \n    // Reduce number of iterations as zoom value became smaller (not necessary, just a demonstration of persistence)\n    int iters = int(max(9.,mix(24., 9., pow((1. + iTime) / 30., 5.) )));\n    \n    for (int i=0;i<iters;i++){\n        vec2 res = color(n_uv, inn, i+1, r);\n        inn = res[0];\n        r = res[1];\n        n_uv = n_uv * 2.;\n        \n        val += cos(inn) / pow(float(i + 1), 0.4) /8.;\n    }\n    \n    \n\n    // Output to screen\n    \n    vec3 col = vec3(val, val, val);\n    //if (col.r <0.2) col = vec3(0.4, 0., 0.);\n    if (uv.x<0. || uv.x>1.) col = vec3(0., 0., 0.);\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3d2SWc.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[66, 66, 88, 88, 160], [162, 162, 209, 209, 485], [488, 488, 545, 545, 1583]], "test": "error"}
{"id": "3d2SWK", "name": "Second Image of a Black Hole", "author": "BigWIngs", "description": "Its a black hole, from my imagination, not reality.\nUse mouse to move.", "tags": ["blackhole"], "likes": 34, "viewed": 2350, "published": "Public", "date": "1555002230", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// \"Second Image of a Black Hole\" by Martijn Steinrucken aka BigWings - 2019\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n// Email:countfrolic@gmail.com Twitter:@The_ArtOfCode\n//\n// In honor of the amazing achievement of the photographing of a real black hole,\n// behold my 100% fake one. I know next to nothing about black holes other than\n// that it distorts spacetime so much that it visibly affects light.\n//\n// Just marching the light rays and bending them towards the hole bulges the accretion disc\n// over the top when you look at it from the side, similar to the way it looked in\n// interstellar. I didn't specifically code this, it just came out that way\n// so I figure my 'physics' is not completely wrong ;)\n//\n// The jets coming out the top and bottom I just added because lots of black hole \n// illustrations have them and they look cool :)\n//\n// Code is a bit of a mess. It annoys me that step size has to be super small in order\n// for it to look halfway decent. \n\n#define SURFDIST .001\n#define MAXSTEPS 200\n#define MAXDIST 20.\n#define TAU 6.2832\n\n#define USEDISC\n#define USESTREAM\n\nmat2 Rot(float a) {\n\tfloat s = sin(a), c = cos(a);\n    \n    return mat2(c, -s, s, c);\n}\n\nfloat N21(vec2 p) {\n    p = fract(p*vec2(123.34,345.35));\n    p += dot(p, p+34.53);\n    return fract(p.x*p.y);\n}\n\nfloat Noise(vec2 p) {\n\tvec2 gv = fract(p);\n    vec2 id = floor(p);\n    \n    gv = smoothstep(0.,1.,gv);\n    \n    float b = mix(N21(id+vec2(0,0)), N21(id+vec2(1, 0)), gv.x);\n    float t = mix(N21(id+vec2(0,1)), N21(id+vec2(1, 1)), gv.x);\n    \n    return mix(b, t, gv.y);\n}\n\nfloat Noise3(vec2 p) {\n    return \n        (Noise(p) + \n        .50*Noise(p*2.12*Rot(1.)) +\n        .25*Noise(p*4.54*Rot(2.)))/1.75;\n}\n\nvec3 GetRd(vec2 uv, vec3 ro, vec3 lookat, vec3 up, float zoom, inout vec3 bBend) {\n    vec3 f = normalize(lookat-ro),\n        r = normalize(cross(up, f)),\n        u = cross(f, r),\n        c = ro + zoom * f,\n        i = c + uv.x*r + uv.y*u,\n        rd = normalize(i-ro);\n \t\n    vec3 offs = normalize(uv.x*r + uv.y*u);\n    bBend = rd-.1*offs/(1.+dot(uv,uv));\n    return rd;   \n}\n\nvec3 GetBg(vec3 rd) {\n\tfloat x = atan(rd.x, rd.z);\n    float y = dot(rd, vec3(0,1,0));\n    \n    float size = 10.;\n    vec2 uv = vec2(x, y)*size;\n    float m = abs(y);\n    \n    float side = Noise3(uv);\n    float stars = pow(Noise(uv*20.)*Noise(uv*23.), 10.);\n    \n    vec2 puv = rd.xz*size;\n    float poles = Noise3(rd.xz*size);\n    float stars2 = pow(Noise(puv*21.)*Noise(puv*13.), 10.);\n    \n    stars = mix(stars, stars2, m*m);\n    float n = mix(side, poles, m*m);\n    n = pow(n, 5.);\n    \n    vec3 nebulae = n * vec3(1., .7, .5);\n    \n    return nebulae + stars*4.;\n}\n\nfloat GetDist(vec3 p) {\n    float d = length(p)-.15;\n    \n    //d = min(d, max(length(p.xz)-2., abs(p.y)));\n    return d;\n}\n\nfloat GetDisc(vec3 p, vec3 pp) {\n\t\n    float t = iTime;\n    \n    // calculate plane intersection point\n    vec3 rd = p-pp;\t\t\t// local ray direction\n    vec3 c = pp + rd*pp.y;\t// intersection point\n    rd = normalize(rd)*.5;\n    p = c-rd;\n    rd *= 2.;\n    \n    // myeah this seemed like a good idea at some point... doesn't add as much as it should\n    float m = 0.;\n    const float numSamples = 3.;\n    for(float i=0.; i<1.; i+=1./numSamples) {\n    \tc = p + i*rd;\n        \n        float d = length(c.xz);\n    \tfloat l = smoothstep(3.5, .6, d);\n    \tl *= smoothstep(.1, .6, d);\n    \t\n        float x = atan(c.x, c.z);\n    \tl *= sin(x*floor(5.)+d*20.-t)*.3+.7;\n        m += l;\n    }\n    \n    return 1.5*m/numSamples;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\tvec2 m = iMouse.xy/iResolution.xy;\n    \n    vec3 col = vec3(0);\n\t\n    vec3 ro = vec3(0, 0, -4.+sin(iTime*.2));\n    ro.yz *= Rot(m.y*TAU+iTime*.05);\n    ro.xz *= Rot(-m.x*TAU+iTime*.1);\n    \n    vec3 lookat = vec3(0);\n    float zoom = .8;\n    vec3 up = normalize(vec3(.5, 1,0));\n    vec3 bBend;\n    vec3 rd = GetRd(uv, ro, lookat, up, zoom, bBend);\n    vec3 eye = rd;\n    \n    float dS, dO;\n    float disc = 0.;\n    vec3 p=ro;\n    p += N21(uv)*rd*.05;\n    vec3 pp;\n    \n    float stream = 0.;\n    \n    for(int i=0; i<MAXSTEPS; i++) {\n        rd -= .01*p/dot(p,p);\t\t// bend ray towards black hole\n        \n        pp = p;\n        p += dS*rd;\n        \n        if(p.y*pp.y<0.)\n            disc += GetDisc(p, pp);\n        \n        float y = abs(p.y)*.2;\n        stream += smoothstep(.1+y, 0., length(p.xz))*\n            smoothstep(0., .2, y)*\n            smoothstep(1., .5, y)*.05;\n        \n        dS = GetDist(p);\n        dS = min(.05, dS);\n        dO += dS;\n        if(dS<SURFDIST || dO>MAXDIST) break;\n    }\n    \n    col = GetBg(bBend);\n    \n    if(dS<SURFDIST) {\n        col = vec3(0);      // its black!\n    }\n    \n    #ifdef USEDISC\n    col += disc*vec3(1,.8,.5)*1.5;\n    #endif\n    #ifdef USESTREAM\n    col += min(.5, stream)*vec3(.7, .7, 1.);\n    #endif\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3d2SWK.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[1140, 1140, 1159, 1159, 1227], [1229, 1229, 1248, 1248, 1341], [1343, 1343, 1364, 1364, 1613], [1615, 1615, 1637, 1637, 1749], [1751, 1751, 1833, 1833, 2127], [2129, 2129, 2150, 2150, 2699], [2701, 2701, 2724, 2724, 2824], [2826, 2826, 2858, 2858, 3543], [3545, 3545, 3602, 3602, 4958]], "test": "ok"}
{"id": "3d2SWt", "name": "A What", "author": "ruojake", "description": "Hello Shadertoy! Messing around with voronoi. The colours turned out very nice I think.", "tags": ["voronoi", "noise"], "likes": 3, "viewed": 166, "published": "Public", "date": "1555512443", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// (c) Kristian Sivonen 2019\n\n//#define MOUSE_CTRL\n\nfloat rand(in vec3 p)\n{\n    return fract(sin(dot(p, vec3(306.3289, 456.1157, 398.7079)))* 64.77871);\n}\n    \nvec3 randP(in vec3 p)\n{\n    return fract(sin(vec3(dot(p, vec3(181.1291, 277.7524, 862.331)),\n                          dot(p, vec3(271.321, 857.3111, 190.614)),\n                          dot(p, vec3(178.9412, 832.961, -269.523))))* 493.721);\n}\n\nfloat vor(in vec3 p, in float t)\n{\n    // try to nudge position to between\n    // the eight nearest neighbours\n    // for somewhat naive 2x2x2 sampling\n\tvec3 p_i = floor(p + .501);\n    vec3 p_f = p - p_i;\n    float mDist = .8 + .6 * t;\n    float base = mDist;\n    vec3 r = vec3(0.0);\n    for(int x = -1; x < 1; x++)\n    {\n        for(int y = -1; y < 1 ; y++)\n        {\n            for(int z = -1; z < 1; z++)\n            {\n                vec3 n = vec3(x, y, z);\n                // reduce discontinuities from 2x2x2 sampling\n                vec3 c = randP(p_i + n) * .6 + .2;\n                vec3 d = n + c - p_f;\n                float dist = dot(d,d);\n\t\t\t\t\n                // 2019-04-18: got rid of an if statement\n                // no idea if it's really an optimization though\n                mDist = min(mDist, dist);\n                r = max(n + 8192./(dist + .001), r);               \n            }\n        }\n    }\n    return 1. - rand(p_i + r - 8192./(mDist + .001)) * step(mDist-base,-.0001);\n}\n\nfloat vor4(in vec3 p, in float t)\n{\n\tfloat r = vor(p, t) * 2.0 - 1.0;\n    r += vor(p * 2.0, t) - .5;\n    r += vor(p * 4.0, t) * .5 - .25;\n    r += vor(p * 8.0, t) * .25 - .125;\n    return r * .266666 + .266666;\n}\n\n// a bit truncated version of iq's palette function\n// https://www.shadertoy.com/view/ll2GD3\nvec3 color(in float t, in vec3 d)\n{\n    return cos(6.28318 * (t + d)) * .5 + .5;\n}\n\nvec4 quat(in vec3 x, in float a)\n{\n    vec4 q;\n    q.xyz = x * sin(a);\n    q.w = cos(a);\n    return q;\n}\n\nvec3 rot(vec3 p, vec4 q)\n{\n    return cross(q.xyz,cross(q.xyz, p) + q.w * p) * 2. + p;\n}\n\nvoid mainImage( out vec4 col, in vec2 fc )\n{\n    float t = iTime * .2;\n    vec3 c = vec3(0.1, cos(t * .7) * .1 + .1, sin(t * 1.1) * .1 + .15);\n\n    vec3 uv = vec3(fc / iResolution.x, .5);\n\n#ifdef MOUSE_CTRL\n    vec3 mouse = vec3(iMouse.xy/iResolution.x, .5);\n#else\n    vec3 mouse = vec3(vec2(iResolution.xy * .5 / iResolution.x), .5);\n#endif\n    \n    uv.z = 1. - sqrt(dot(uv-mouse,uv-mouse));\n    uv = rot(uv * (3. + sin(t)), quat(normalize(vec3(uv.y,-uv.x,uv.z) - mouse), t * .1));\n\tuv *= 8.;\n    \n    float r = 0.;\n    float st = sin(iTime * .3);    \n    float a = 4.18879;\n    float j = iTime + fc.x * .01;\n    vec2 scale = vec2(.015);\n    for(int i = 0; i < 3; i++)\n    {\n        vec3 ouv = vec3(uv.xy + vec2(cos(j), sin(j)) * scale, uv.z);\n    \tr += vor4(ouv, st);\n        uv += vec3(.0, .0, .004);\n        j += a;\n    }\n    r *= .3333;\n    col = vec4(color(fract(r + t * .1), c), 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3d2SWt.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[52, 52, 75, 75, 154], [160, 160, 183, 183, 403], [405, 405, 439, 556, 1407], [1409, 1409, 1444, 1444, 1621], [1623, 1716, 1751, 1751, 1798], [1800, 1800, 1834, 1834, 1904], [1906, 1906, 1932, 1932, 1994], [1996, 1996, 2040, 2040, 2889]], "test": "ok"}
{"id": "3d2XR3", "name": "Water flow with FBM", "author": "toridango", "description": "Experiments with Fractional Brownian Motion to simulate water flow\nTried adding reflections but not satisfied with the result", "tags": ["fbm"], "likes": 0, "viewed": 43, "published": "Public", "date": "1554516528", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// pseudo random\nfloat random (vec2 st)\n{\n    return fract(\n        sin(dot(st.xy,vec2(12.9898,78.233))) \n        * 43758.5453123);\n}\n\nfloat noise(vec2 p)\n{\n    // integer part\n    vec2 i = floor(p);\n    // fractional part\n    vec2 f = fract(p);\n    \n    float ul = random(i); // + vec2(0.0, 0.0)\n    float ur = random(i + vec2(1.0, 0.0));\n    float ll = random(i + vec2(0.0, 1.0));\n    float lr = random(i + vec2(1.0, 1.0));\n    \n    // mix(x, y, a): lerp between x and y using a: x*(1−a) + y*a\n    float u = mix(ul, ur, f.x);\n    float l = mix(ll, lr, f.x);\n    \n    float n = mix(u, l, f.y);\n            \n    return n;\n}\n\n\nfloat brownian(vec2 p)\n{\n    int numOctaves = 3;\n    float frequency = 1.0;\n    float amplitude = 1.0;\n\n    float lacunarity = 2.0;\n    float gain = 0.5;\n\n    float result = 0.0;\n    for(int i; i < numOctaves; i++)\n    {\n        result += noise(frequency * p) * amplitude;\n        frequency *= lacunarity;\n        amplitude *= gain;\n    }\n    return result;\n}\n\nfloat getHeight(vec2 p)\n{\n    \n    float b1 = brownian(p)+iTime/1.3;\n    float b2 = brownian(1.2*p);\n\t\n    float fbm1 = brownian(vec2(iTime+p.x, iTime+p.y));\n    float fbm1slow = brownian(vec2(iTime*0.3+p.x, iTime*0.3+p.y));\n\tfloat fbm2 = brownian(vec2(b1, b2));\n\n    \n    return fbm1+fbm1slow+fbm2;\n}\n\nvec3 getNormal(vec2 fragCoord, float zoom)\n{\n    vec3 normal;\n    vec2 thisp = (fragCoord/iResolution.xy) * zoom;\n    vec2 p2    = ((fragCoord + vec2(1.0,0.0))/iResolution.xy) * zoom;\n    vec2 p3    = ((fragCoord + vec2(0.0,1.0))/iResolution.xy) * zoom;\n    \n    /*vec3 thisv \t= vec3(fragCoord.x, \t\tgetHeight(thisp), \tfragCoord.y\t\t\t);\n    vec3 v2 \t= vec3(fragCoord.x + 1.0, \tgetHeight(p2), \t\tfragCoord.y\t\t\t);\n    vec3 v3 \t= vec3(fragCoord.x, \t\tgetHeight(p3), \t\tfragCoord.y + 1.0\t);*/\n    vec3 thisv \t= vec3(thisp.x, getHeight(thisp), thisp.y\t\t\t);\n    vec3 v2 \t= vec3(p2.x, getHeight(p2), p2.y);\n    vec3 v3 \t= vec3(p3.x, getHeight(p3), p3.y);\n    \n    vec3 Vec1 = thisv - v3;\n    vec3 Vec2 = v3 - v2;\n    \n    normal = normalize(cross(Vec1, Vec2));\n    \n    return normal;\n}\n\n\n\nvec3 lightDirection = vec3(0.4, -0.5, 0.4);\nvec3 viewDirection = vec3(0.35, -1.0, 0.5);\nfloat specularPower = 32.0;\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    float zoom = 25.0;\n\tvec2 p = zoom * uv;\n    // Time varying pixel color\n    //vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n    \n    vec3 dark = vec3(0.1, 0.15, 0.3);\n    vec3 light = vec3(0.1, 0.25, 0.75);\n    \n    float b1 = brownian(p)+iTime/1.3;\n    float b2 = brownian(1.2*p);\n\t\n    float fbm1 = brownian(vec2(iTime+p.x, iTime+p.y));\n    float fbm1slow = brownian(vec2(iTime*0.3+p.x, iTime*0.3+p.y));\n\tfloat fbm2 = brownian(vec2(b1, b2));\n    \n    \n    \n    vec3 colour1 = mix(dark, light, fbm1);\n    vec3 colour1slow = mix(dark, light, fbm1slow);\n    vec3 colour2 = mix(dark, light, fbm2);\n    \n    vec3 colour = clamp(colour1 + colour2, 0.0, 1.0);\n    vec3 colour3 = mix(dark, light, getHeight(p));\n\n    vec3 lightDir = normalize(-lightDirection);\n    vec3 normal = getNormal(fragCoord, zoom);\n    float lightIntensity = clamp(dot(normal, lightDirection), 0.0, 1.0);\n    vec3 reflection = normalize(2.0 * lightIntensity * normal - lightDir);\n    float specular = pow(clamp(dot(reflection, viewDirection), 0.0, 1.0), specularPower);\n    \n    \n    \n    // Output to screen\n    //fragColor = vec4(clamp(colour3, 0.0, 1.0),1.0);\n    fragColor = vec4(clamp(colour3 - vec3(0.1,0.1,0.1)*specular, 0.0, 1.0),1.0);\n    //fragColor = vec4(clamp(colour3 + vec3(0.1,0.1,0.1)*specular, 0.0, 1.0),1.0);\n    //fragColor = vec4(clamp(colour3 + mix(dark, light, specular), 0.0, 1.0),1.0);\n    //fragColor = vec4(clamp(vec3(1.0,1.0,1.0)*specular, 0.0, 1.0),1.0);\n    //fragColor = vec4(clamp(normal, 0.0, 1.0),1.0);\n    //fragColor = vec4(clamp(getNormal(fragCoord, zoom), 0.0, 1.0),1.0); // Normals visualised look cool\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3d2XR3.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 17, 41, 41, 133], [135, 135, 156, 176, 625], [628, 628, 652, 652, 987], [989, 989, 1014, 1014, 1290], [1292, 1292, 1336, 1336, 2066], [2188, 2188, 2245, 2295, 3962]], "test": "timeout"}
{"id": "3dBSRd", "name": "Classical hypnosis", "author": "avin", "description": "Classical hypnosis", "tags": ["simple", "spiral", "hypno", "hypnosis"], "likes": 10, "viewed": 468, "published": "Public API", "date": "1554653245", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;               \n    vec2 st = vec2(atan(uv.x, uv.y), length(uv));    \n    uv = vec2(st.x / 6.2831 + iTime * 2.0 - st.y * 20.0, st.y);    \n    float smf = 1.5*fwidth(uv.x);        \n    float m = fract(uv.x);    \n    float mask = smoothstep(0., smf, abs(m-.5)-.25);    \n    vec3 col = vec3(0.88, 0, 0.52) * mask;    \n    fragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3dBSRd.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 468]], "test": "ok"}
{"id": "3dBSW3", "name": "Deterioration", "author": "Blokatt", "description": "A simple noise exercise.", "tags": ["fractal", "terrain", "fbm", "oil", "layers", "rust"], "likes": 21, "viewed": 816, "published": "Public API", "date": "1555015046", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Deterioration by @blokatt\n// 11/04/19\n// Mesmerising...\n\nmat2 rot(float a){\n\treturn mat2 (\n        cos(a), -sin(a),\n        sin(a), cos(a)\n    );\n}\n\nfloat rand(vec2 uv){\n\treturn fract(sin(dot(vec2(12.9898,78.233), uv)) * 43758.5453123);\n}\n\nfloat valueNoise(vec2 uv){\n    vec2 i = fract(uv);\n    vec2 f = floor(uv);\n\tfloat a = rand(f);\n    float b = rand(f + vec2(1.0, 0.0));\n    float c = rand(f + vec2(0.0, 1.0));\n    float d = rand(f + vec2(1.0, 1.0));    \n    return mix(mix(a, b, i.x), mix(c, d, i.x), i.y);\n}\n\nfloat fbm(vec2 uv) {\n    float v = 0.0;\n    float freq = 9.5;\n    float amp = .75;\n    float z = (20. * sin(iTime * .2)) + 30.;\n   \n    for (int i = 0; i < 10; ++i) {\n        v += valueNoise(uv + (z * uv * .05) + (iTime * .1)) * amp;\n    \tuv *= 3.25;        \n        amp *= .5;\n    }\n    \n    return v;    \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy - .5;\n\tvec2 oldUV = uv;\n    uv.x *= iResolution.x / iResolution.y;\n    vec3 col = (0.5 * cos(iTime + uv.xyx + vec3(0., 2., 4.))) + 0.5;\n    uv *= rot(iTime * .02);\n    mat2 angle = rot(fbm(uv));\n    fragColor = vec4(vec3(\n                    \tfbm((vec2(5.456, -2.8112) * angle) + uv),\n                    \tfbm((vec2(5.476, -2.8122) * angle) + uv),\n                    \tfbm((vec2(5.486, -2.8132) * angle) + uv)\n                 \t) - (smoothstep(.1, 1., length(oldUV))), 1.);\n}", "image_inputs": [{"id": "XlsGDM", "previewfilepath": "https://soundcloud.com/blokatt/noendinsight", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0, "src": "https://soundcloud.com/blokatt/noendinsight", "ctype": "musicstream"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3dBSW3.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[60, 60, 78, 78, 150], [152, 152, 172, 172, 241], [243, 243, 269, 269, 516], [518, 518, 538, 538, 826], [828, 828, 885, 885, 1400]], "test": "ok"}
{"id": "3dBSz3", "name": "World War Zed", "author": "Passion", "description": "just messin around", "tags": ["2d", "tiling"], "likes": 14, "viewed": 258, "published": "Public", "date": "1554426738", "time_retrieved": "2021-10-01T00:00:00", "image_code": "mat2 r2(float a){\n    float s = sin(a);\n    float c = cos(a);\n    return mat2(s,c,-c,s);\n}\n\nfloat rnd(float r){\n    return fract(sin(r * 768.67)*7684.98);\n}\n\nfloat sdCapsule( vec2 p, vec2 a, vec2 b, float r ){\n    vec2 pa = p - a, ba = b - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return smoothstep(.02, .01, length( pa - ba*h ) - r);\n}\n\nvec4 effect(vec2 uv){\n    float n = texture(iChannel0, uv).x;\n    vec2 id = floor(uv);\n    float updown = rnd(id.y);\n    updown = updown > .5 ? 1.0 : -1.0;\n    uv.x += rnd(id.y)*iTime*3.*updown;\n    id = floor(uv);\n    vec2 ft = fract(uv)-.5;\n    \n    float grid = step(.49, ft.x) + step(.49, ft.y);\n    \n    ft *= r2(.5*sin(3.*iTime+rnd(id.x*id.y)*2.)+1.5);\n    \n    float eye = length((vec2(abs(ft.x), ft.y))-.2);//- .025;\n    eye = smoothstep(.03,.02,eye);\n    \n    float rand = rnd(id.x+id.y);\n    rand = rand < .5 ? -1.0 : 1.0;\n    \n    float line = sdCapsule(ft, vec2(-0.17, -.3),vec2(.17, -.3), .001);    \n    float line2 = sdCapsule(ft, vec2(-0.11, -.18),vec2(.11, -.18), .001);\n    float line3 = sdCapsule(ft, vec2(-0.11*rand, -.18),vec2(0., .15), .001);\n    \n    vec4 color = vec4((line+line2+line3+eye)); //+;  //;color;\n    color.r += grid;\n    return color;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    uv = uv * 2.0 - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n    uv *= 1.0 + dot(uv,uv)*.125;\n    uv.x+=sin(iTime/2.)*4.;\n    uv.y+=cos(iTime/2.)*4.;\n\n    uv *= 2.;\n    \n    vec4 color = vec4(0.0);\n    color = effect(r2(.25*sin(iTime/2.)+1.6)*uv+sin(iTime));\n    \n    fragColor = vec4(color); // vec4(id*.2, 0.0, 1.0)*eye;\n}", "image_inputs": [{"id": "ltX3W7", "previewfilepath": "https://soundcloud.com/stephen-ferrari/world-war-z-music-remix", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0, "src": "https://soundcloud.com/stephen-ferrari/world-war-z-music-remix", "ctype": "musicstream"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3dBSz3.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 17, 17, 90], [92, 92, 111, 111, 156], [158, 158, 209, 209, 358], [360, 360, 381, 381, 1232], [1234, 1234, 1291, 1291, 1663]], "test": "error"}
{"id": "3dBSzt", "name": "Neon enso", "author": "jblanper", "description": "Inspired by \"Enso\" series (2016) by José María Yturralde.", "tags": ["2d", "sketch", "enso"], "likes": 3, "viewed": 110, "published": "Public", "date": "1554642958", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float Circle (vec2 uv, float r, float lw, float blur) \n{\n\treturn smoothstep(r + blur, r - .005, length(uv)) -\n\t\tsmoothstep(r - lw, r - lw - .005 - blur, length(uv));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy - .5;\n\tuv.x *= iResolution.x / iResolution.y;\n\tvec3 col = vec3(0.);\n\tvec3 blue = vec3(.2, .2, .6);\n\tvec3 pink = vec3(.6, .2, .6);\n\t\n\tcol += .6 - mix(blue, pink, .3) * length(uv);\n\tcol += Circle(uv, .3, .01, .02) * blue * vec3(sin(iTime * .5) + 1.);\n\tcol += Circle(uv, .3, .01, .002);\n\tcol += Circle(uv, .38, .02, .03) * pink * vec3(sin(iTime * .5) + 1.);\n\tcol += Circle(uv, .38, .02, .002);\n\tcol *= vec3(sin(iTime * .5) * .3 + .8) * (1. - length(uv));\n\n\tfragColor = vec4(col, 1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3dBSzt.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 56, 56, 167], [169, 169, 226, 226, 750]], "test": "ok"}
{"id": "3dBXRd", "name": "Simple surface warp / bend", "author": "codebro", "description": "I wanted to create an effect similar to my design software's \"sear\" effect. Planning on using it to create glitch effect in images.", "tags": ["lines", "warp", "bend"], "likes": 4, "viewed": 165, "published": "Public", "date": "1554657541", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const vec4 BLACK = vec4(0.0, 0.0, 0.0, 1.0);\nconst vec4 WHITE = vec4(1.0,1.0,1.0,1.0);\nconst vec4 EMPTY_C = vec4(0.0);\nconst float LINE_FREQUENCY = 20.0;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  \tvec2 coord = (2.0 * fragCoord - iResolution.xy) / iResolution.y;\n\tcoord.x -= cos(coord.y) * sin(iTime); \n  \tvec4 c = EMPTY_C;\n  \n  \tfloat total = floor(coord.x * LINE_FREQUENCY);\n  \tbool isEven = mod(total, 2.0) == 0.0;\n  \t//c = isEven ? WHITE : BLACK; // originally I had these two lines\n  \t//fragColor = c; // (see comments section)\n\n  \tfragColor =  vec4(2.*sin(3.14*coord.x * LINE_FREQUENCY));\n}\n\n// Tiny version written by FabriceNeyret2 in the comments - very impressive :-D\n//void mainImage( out vec4 fragColor, in vec2 fragCoord )\n//{\n//    vec2 R = iResolution.xy, U = (fragCoord+fragCoord - R) / R.y;\n//    float v = sin(62.8 * ( U.x - cos(U.y) * sin(iTime) ) );\n//\tfragColor += sqrt( v/fwidth(v) );\n//}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3dBXRd.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[155, 155, 212, 212, 614]], "test": "ok"}
{"id": "3djSD3", "name": "Sphere Thing of Square Things", "author": "Mr_E", "description": "This is a sphere thing", "tags": ["sphere", "thing"], "likes": 4, "viewed": 408, "published": "Public API", "date": "1556547411", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec2 det(vec3 p3D){\n \treturn vec2((p3D.x * 90.)/p3D.z + iResolution.x/2., (p3D.y * 90.)/p3D.z + iResolution.y/2.);\n}\n\nfloat ist(vec2 fin){\n \tfloat w = 5.;\n \tfloat r0 = 100.;\n \tfloat x = 0.;\n \tfloat y = -r0-20.;\n \tfloat z = 90.;\n\t\n \tfloat rate = 1.;\n \n \tfloat n = 10.;\n \n    float returned = 1.;\n    \n    vec2 cent = det(vec3(x,y+r0*1.2,z));\n    if (distance(fin,cent) > r0*1.5) {\n        return 1.;\n    }\n    \n \tfor (float j = 0.; j <= r0/10.; j++){\n        y += 20.;\n        float r = sqrt(r0*r0 - y*y);\n        \n        for (float i = 0.; i <= n; i++){\n            vec2 dete1 = det(vec3(sin(iTime*rate + 6.28*i/n)*r+x-w,y-w,cos(iTime*rate + 6.28*i/n)*(r/2.)+z));\n            vec2 dete2 = det(vec3(sin(iTime*rate + 6.28*i/n)*r+x+w,y+w,cos(iTime*rate + 6.28*i/n)*(r/2.)+z));\n            \n            if(fin.x > dete1.x && fin.x < dete2.x &&\n               fin.y > dete1.y && fin.y < dete2.y){\n                returned = min(returned,cos(iTime*rate + 6.28*i/n)*0.5+0.4);\n            }\n        }\n    }\n    \n    return returned;\n}\n\nvoid mainImage (out vec4 fout,in vec2 fin){\n    fout = vec4(ist(fin));/*\n    if (ist(fin)){\n        fout = vec4(0);\n    }else{\n        fout = vec4(1);\n    }*/\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3djSD3.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 19, 19, 116], [118, 118, 138, 138, 1027], [1029, 1029, 1072, 1072, 1189]], "test": "ok"}
{"id": "3djSRc", "name": "Fast random placement on a grid", "author": "evan", "description": "Fast random placement on a grid", "tags": ["grid", "random"], "likes": 2, "viewed": 137, "published": "Public", "date": "1554537022", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// From: https://www.shadertoy.com/view/4djSRW\nfloat hash12(vec2 p) {\n  vec3 p3 = fract(vec3(p.xyx) * .1031);\n  p3 += dot(p3, p3.yzx + 33.33);\n  return fract((p3.x + p3.y) * p3.z);\n}\n\nvec2 posInCell(vec2 cell) {\n  if (hash12(cell * 109.0) < 0.8) {\n    // Cell is empty, so return something really far off screen\n    return vec2(-100.0);\n  }\n  return cell + vec2(hash12(cell), hash12(cell * 33.0));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  float s = 10.0 * pow(2.0, cos(iTime));\n  vec2 grid = fract(fragCoord.xy / s) * s;\n  vec2 cell = floor(fragCoord.xy / s);\n  float gridLines = clamp(2.0 - min(grid.x, grid.y), 0.0, 0.1);\n  float color = gridLines;\n\n  for (float x = -1.0; x <= 1.0; x += 1.0) {\n    for (float y = -1.0; y <= 1.0; y += 1.0) {\n      vec2 neighbor = cell + vec2(x, y);\n      vec2 pos = posInCell(neighbor);\n      float len = length(fragCoord.xy / s - pos);\n      float neighborColor = clamp(s * 0.25 - len * s, 0.0, 1.0);\n      color = max(color, neighborColor);\n    }\n  }\n\n  fragColor = vec4(vec3(color), 1);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3djSRc.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 47, 69, 69, 182], [184, 184, 211, 211, 399], [401, 401, 456, 456, 1047]], "test": "ok"}
{"id": "3djSRt", "name": "Psy flower", "author": "avin", "description": "Flower interprtitation of polar coordinates. Impressed by @BigWings video https://www.youtube.com/watch?v=r1UOB8NVE8I", "tags": ["flower", "psy"], "likes": 3, "viewed": 358, "published": "Public API", "date": "1554715172", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Big thanks to @BigWings for his youtube videos! \n// Impressed by https://www.youtube.com/watch?v=r1UOB8NVE8I\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord.xy - iResolution.xy * 0.5) / iResolution.y;\n\n    vec2 st = vec2(atan(uv.x, uv.y), length(uv));\n\n    float c1 = 0.0;\n    float c2 = 0.0;\n    float c3 = 0.0;\n    float z = 1.0;\n    for(float i = 0.0; i <= 3.14; i += 0.314) {\n        z *= -1.0;\n        uv = vec2(st.x / 6.2831 + i + (sign(z) * iTime * sqrt(i * 5.0) * 0.01), st.y + cos(iTime+i) * 0.02);\n\n        float x = uv.x * 14.0;\n        float m = min(fract(x), fract(1.0 - x));\n        c1 += smoothstep(0.0, 0.01, m * 0.5 + 0.2 - uv.y*i*.75) * 0.20;\n        c2 += sign(z) * smoothstep(0.0, 0.01, m * 0.5  - uv.y*i) * 0.75;\n        c3 += sign(z * -1.0) * smoothstep(0.0, 0.01, m * 0.5 + 0.2 - uv.y) * 0.75;\n    }\n\n    vec3 col = vec3(fract(c3*.5), fract(c1 +c3), floor(c2 + c1)) ;\n\n    fragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3djSRt.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[113, 113, 170, 170, 964]], "test": "ok"}
{"id": "3djSWK", "name": "4x4D Perlin Noise", "author": "scratch13764", "description": "A 4 channel 4 dimensional Perlin noise algorithm with the analytical normal of the fourth channel.", "tags": ["noise", "perlin", "gradient", "volumetric", "4d"], "likes": 9, "viewed": 190, "published": "Public", "date": "1555028948", "time_retrieved": "2021-10-01T00:00:00", "image_code": "struct vec16 // 4x vec4\n{\n    vec4 x, y, z, w;\n};\n\nstruct vec8 // 2x vec4\n{\n    vec4 x, y; \n    // Used to hold the values of noise and the derivative of the alpha channel\n};\n\nvec16 hash (vec4 p) // uh\n{\n    p = round(p); // Just a hardware issue on my computer, you probably don't need this\n    vec4 a = -1. + 2.*fract(\n        vec4(4825.39872, 5978.23875, 2938.69837, 7981.19439)*\n        sin(p.x*29.847 + p.y*74.947 + \n            p.z*34.684 + p.w*91.234));\n    vec4 b = -1. + 2.*fract(\n        vec4(8274.84872, 8763.17864, 5763.89345, 7185.87917)*\n        sin(p.x*22.398 + p.y*93.478 + \n            p.z*93.239 + p.w*25.252));\n    vec4 c = -1. + 2.*fract(\n        vec4(9287.29472, 6782.62067, 9872.75203, 4987.28734)*\n        sin(p.x*74.973 + p.y*63.289 + \n            p.z*34.428 + p.w*50.982));\n    vec4 d = -1. + 2.*fract(\n        vec4(3287.97291, 9247.82436, 2874.38254, 6298.92293)*\n        sin(p.x*43.834 + p.y*78.934 + \n            p.z*48.934 + p.w*48.729));\n    return vec16(a, b, c, d);\n}\n\nvec4 dott (vec16 f, vec4 v) //\"No matching overload function found\"\n{\n    return vec4(\n    dot(f.x, v),\n    dot(f.y, v),\n    dot(f.z, v),\n    dot(f.w, v));\n}\n\nvec8 perlin4x4 (vec4 p)\n{\n    // Address and interpolation values\n    vec4 f = fract(p),\n    m = f*f*f*(f*f*6. - f*15. + 10.);\n    p -= f;\n\n    // Interpolating the gradients for noise\n    vec4 noise = mix(mix(mix(\n        mix(dott(hash(p + vec4(0,0,0,0)), f - vec4(0,0,0,0)), \n            dott(hash(p + vec4(1,0,0,0)), f - vec4(1,0,0,0)), m.x), \n        mix(dott(hash(p + vec4(0,1,0,0)), f - vec4(0,1,0,0)), \n            dott(hash(p + vec4(1,1,0,0)), f - vec4(1,1,0,0)), m.x), m.y), mix(\n        mix(dott(hash(p + vec4(0,0,1,0)), f - vec4(0,0,1,0)), \n            dott(hash(p + vec4(1,0,1,0)), f - vec4(1,0,1,0)), m.x), \n        mix(dott(hash(p + vec4(0,1,1,0)), f - vec4(0,1,1,0)), \n            dott(hash(p + vec4(1,1,1,0)), f - vec4(1,1,1,0)), m.x), m.y), m.z), mix(mix(\n        mix(dott(hash(p + vec4(0,0,0,1)), f - vec4(0,0,0,1)), \n            dott(hash(p + vec4(1,0,0,1)), f - vec4(1,0,0,1)), m.x), \n        mix(dott(hash(p + vec4(0,1,0,1)), f - vec4(0,1,0,1)), \n            dott(hash(p + vec4(1,1,0,1)), f - vec4(1,1,0,1)), m.x), m.y), mix(\n        mix(dott(hash(p + vec4(0,0,1,1)), f - vec4(0,0,1,1)), \n            dott(hash(p + vec4(1,0,1,1)), f - vec4(1,0,1,1)), m.x), \n        mix(dott(hash(p + vec4(0,1,1,1)), f - vec4(0,1,1,1)), \n            dott(hash(p + vec4(1,1,1,1)), f - vec4(1,1,1,1)), m.x), m.y), m.z), m.w);\n    // Interpolating the values of the gradients for the first derivative normal\n    // (of the alpha channel)\n    // It's faster to recalculate the hashes by the way\n    vec4 derivative = mix(mix(mix(\n        mix(hash(p + vec4(0,0,0,0)).w, \n            hash(p + vec4(1,0,0,0)).w, m.x), \n        mix(hash(p + vec4(0,1,0,0)).w, \n            hash(p + vec4(1,1,0,0)).w, m.x), m.y), mix(\n        mix(hash(p + vec4(0,0,1,0)).w, \n            hash(p + vec4(1,0,1,0)).w, m.x), \n        mix(hash(p + vec4(0,1,1,0)).w, \n            hash(p + vec4(1,1,1,0)).w, m.x), m.y), m.z), mix(mix(\n        mix(hash(p + vec4(0,0,0,1)).w, \n            hash(p + vec4(1,0,0,1)).w, m.x), \n        mix(hash(p + vec4(0,1,0,1)).w, \n            hash(p + vec4(1,1,0,1)).w, m.x), m.y), mix(\n        mix(hash(p + vec4(0,0,1,1)).w, \n            hash(p + vec4(1,0,1,1)).w, m.x), \n        mix(hash(p + vec4(0,1,1,1)).w, \n            hash(p + vec4(1,1,1,1)).w, m.x), m.y), m.z), m.w);\n    return vec8(noise, derivative);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - .5*iResolution.xy)/iResolution.y;\n    \n    float a = iTime/2.;\n    \n    vec3 ro = -vec3(sin(a), 0, cos(a))*7.5;\n    vec3 rs = normalize(vec3(uv, 1));\n    rs.xz *= mat2(cos(-a),-sin(-a),sin(-a),cos(-a));\n    \n    vec3 p;\n    \n    fragColor = vec4(0.);\n    if (uv.x < cos(iTime/2.))\n    {\n        for (float d = 9.; d >= 5.; d -= .25)\n        {\n            vec3 p = ro + rs*d;\n            vec8 n = perlin4x4(vec4(p*1.25, iTime/2.));\n            n.x = n.x*.5 + .5;\n            fragColor = mix(fragColor, n.x*.75+.25,\n                        pow(n.x.a, 6.)*smoothstep(3., 2.7, length(p)));\n        }\n        fragColor *= 2.;\n    }else{\n\t    float d = 5.;\n        vec8 noise;\n        float m;\n        vec3 norm;\n        for (d; d <= 8.;)\n        {\n            noise = perlin4x4(vec4((ro+rs*d)*1.25, iTime/2.));\n            m = max(length(ro+rs*d)-2.8, -noise.x.w*.5+.05);\n            if (m <= .01)\n            {\n                p = ro+rs*d; \n                fragColor = noise.x*.5+.5;\n                norm = normalize((length(p) < 2.8)? noise.y.xyz : p);\n                fragColor += .7*max(pow(dot(reflect(rs, norm), vec3(.577)), 9.), 0.);\n                fragColor *= dot(norm, vec3(.577))*.25+.75;\n                break;\n            }\n            d += m;\n        }\n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3djSWK.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[176, 176, 203, 203, 999], [1001, 1001, 1070, 1070, 1158], [1160, 1160, 1185, 1225, 3472], [3474, 3474, 3531, 3531, 4829]], "test": "timeout"}
{"id": "3djXWG", "name": "cppn2glsl", "author": "karlosgliberal", "description": "Probando cppn ", "tags": ["cppn"], "likes": 6, "viewed": 130, "published": "Public", "date": "1554840837", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define N_HIDDEN 16\n\nvec4 bufA[N_HIDDEN/4];\nvec4 bufB[N_HIDDEN/2];\n\n\nvec4 cppn_fn(vec2 coordinate, float in0, float in1, float in2, float in3) {\n    vec4 tmp;\n    bufB[0] = vec4(coordinate.x, coordinate.y, 0., 0.);\nbufA[0] = vec4(-0.46531567,0.27698937,0.25664687,-0.13642992) + mat4(vec4(0.7989471554756165,0.4222799241542816,-0.010213207453489304,-0.3434750735759735),vec4(-0.4049549400806427,0.10863465070724487,-0.19030581414699554,-0.16983091831207275),vec4(0.0,0.0,0.0,0.0),vec4(0.0,0.0,0.0,0.0)) * bufB[0];\nbufA[1] = vec4(0.08896216,-0.008342344,0.17350595,0.0918947) + mat4(vec4(-0.29238060116767883,1.060044765472412,-0.1815766990184784,0.7910200357437134),vec4(0.9869383573532104,0.14851130545139313,-0.47477632761001587,-0.0713120549917221),vec4(0.0,0.0,0.0,0.0),vec4(0.0,0.0,0.0,0.0)) * bufB[0];\nbufA[2] = vec4(0.09820335,0.23828956,0.22844179,0.06523356) + mat4(vec4(-0.20187807083129883,-0.44249674677848816,0.3673096299171448,1.2974296808242798),vec4(0.7476376295089722,1.1170638799667358,0.3840537667274475,0.6498743891716003),vec4(0.0,0.0,0.0,0.0),vec4(0.0,0.0,0.0,0.0)) * bufB[0];\nbufA[3] = vec4(-0.26875862,0.2253887,0.285484,-0.03691154) + mat4(vec4(-0.5225133895874023,0.9973945021629333,-0.6933567523956299,-0.0836125835776329),vec4(-0.07762482762336731,-0.05472502484917641,-0.23656333982944489,0.9241566061973572),vec4(0.0,0.0,0.0,0.0),vec4(0.0,0.0,0.0,0.0)) * bufB[0];\ntmp = atan(bufA[0]);\nbufB[0] = tmp/0.67;\nbufB[4] = (tmp*tmp) / 0.6;\ntmp = atan(bufA[1]);\nbufB[1] = tmp/0.67;\nbufB[5] = (tmp*tmp) / 0.6;\ntmp = atan(bufA[2]);\nbufB[2] = tmp/0.67;\nbufB[6] = (tmp*tmp) / 0.6;\ntmp = atan(bufA[3]);\nbufB[3] = tmp/0.67;\nbufB[7] = (tmp*tmp) / 0.6;\nbufA[0] = vec4(0.49503228,0.09211826,-0.03265594,-0.12637815) + mat4(vec4(0.13359901,-0.30276835,-0.2626819,-0.11160955),vec4(-0.07799274,0.28385687,-0.100538656,0.20158201),vec4(0.008143242,0.10036408,-0.052189905,0.13966367),vec4(-0.010869595,-0.0887737,-0.19077243,-0.13466083)) * bufB[0] + mat4(vec4(-0.04155759,0.29997194,0.4258987,0.12162944),vec4(-0.11523578,-0.26343265,0.35289353,-0.082066044),vec4(0.011385583,0.067048825,-0.35558158,0.08923514),vec4(-0.034817684,0.3375762,-0.18795304,0.1803095)) * bufB[1] + mat4(vec4(0.4581005,0.059712317,0.3481995,0.22089063),vec4(0.13528252,-0.10531307,-0.15891889,0.09074471),vec4(0.28373867,0.124615096,0.2610411,0.127872),vec4(0.040919594,-0.26804286,0.14503607,0.26025417)) * bufB[2] + mat4(vec4(0.08890303,0.006350284,-0.12461653,-0.10195164),vec4(0.3314931,-0.10290398,-0.16580851,0.12279658),vec4(0.22378917,0.22199513,0.14126647,0.3180122),vec4(-0.19322748,-0.18368202,0.36948016,0.27709916)) * bufB[3] + mat4(vec4(-0.028209982,-0.15570943,0.04071624,0.1284736),vec4(0.051089283,0.0022035164,0.14185867,-0.2673741),vec4(0.0688265,0.096779175,0.12582174,0.24023955),vec4(0.1522257,-0.019367117,-0.07845876,-0.25476965)) * bufB[4] + mat4(vec4(-0.11451679,-0.02907758,0.05035189,0.24022041),vec4(-0.17335792,0.4074784,-0.5918986,-0.5452782),vec4(0.2731505,0.13125156,-0.19170925,-0.16276014),vec4(-0.15618424,0.5339465,-0.31250516,-0.2920238)) * bufB[5] + mat4(vec4(-0.044649724,-0.07947169,0.07736699,0.32270387),vec4(-0.027725756,-0.13507862,-0.028178578,0.168349),vec4(0.17426185,0.087518446,0.06552481,-0.19540806),vec4(0.01702251,0.1980849,-0.19972754,0.040812936)) * bufB[6] + mat4(vec4(0.07796967,0.27818945,-0.092967026,-0.049602363),vec4(-0.117151566,0.54561615,-0.26160148,-0.567078),vec4(-0.15890643,0.43769363,-0.34698763,-0.5407515),vec4(-0.18213809,-0.17299691,0.0923674,0.3832961)) * bufB[7];\nbufA[1] = vec4(-0.4650077,0.41214877,0.44565535,-0.3837856) + mat4(vec4(-0.018641278,-0.3883677,0.10445613,0.003654326),vec4(0.09449435,-0.05089507,-0.15763748,0.20446001),vec4(0.08666902,-0.034659576,0.16693127,-0.17416485),vec4(-0.19497226,-0.27377635,0.22262172,-0.15018013)) * bufB[0] + mat4(vec4(0.042611867,0.11098616,0.39521784,0.45393652),vec4(0.10411098,0.081083156,-0.15282927,-0.04953883),vec4(0.17558059,0.18042031,-0.02124743,-0.23990747),vec4(-0.11542144,-0.16199419,-0.118448146,0.0824573)) * bufB[1] + mat4(vec4(0.11378064,0.35069793,0.2156747,0.16576415),vec4(-0.050625972,0.56358886,0.1693859,0.06017933),vec4(0.13656116,-0.029610809,-0.1241302,0.1286515),vec4(-0.17626058,0.2183735,0.04064249,-0.040826954)) * bufB[2] + mat4(vec4(-0.40101475,-0.455565,0.29090172,0.0045103314),vec4(-0.2004233,0.2841089,-0.43565488,-0.14593224),vec4(-0.12362736,0.20129949,-0.29414755,0.17656702),vec4(0.01675359,0.111217216,0.37890494,0.64865893)) * bufB[3] + mat4(vec4(-0.26909572,0.2002804,-0.011987114,0.012278857),vec4(-0.31427175,0.13623187,0.11980425,0.2338151),vec4(0.039009135,-0.009090867,-0.08058105,-0.07805047),vec4(0.014728965,-0.050155926,0.11913634,0.3387843)) * bufB[4] + mat4(vec4(-0.30142906,-0.006225585,0.042757906,-0.27645323),vec4(0.11045743,-0.20467353,0.3232617,0.32747987),vec4(-0.022063782,0.20626336,0.28111005,-0.22030412),vec4(-0.11885476,-0.46400288,0.28006893,0.4357071)) * bufB[5] + mat4(vec4(-0.091388576,0.05034802,0.3748192,0.082449),vec4(-0.34536096,-0.13372996,-0.17387117,-0.049684),vec4(-0.058573794,0.053775158,-0.023536308,0.13580485),vec4(0.06993015,-0.21152715,0.40131292,0.04351068)) * bufB[6] + mat4(vec4(-0.22989827,-0.29988274,0.2124955,-0.2541185),vec4(-0.047833476,-0.22864823,0.36513487,0.3219362),vec4(0.088168286,-0.015718807,0.62389296,0.23033239),vec4(-0.3166135,0.15839958,-0.014822761,-0.32925686)) * bufB[7];\nbufA[2] = vec4(-0.06607472,0.27451414,0.27952114,-0.35619223) + mat4(vec4(0.003884744,0.15999478,0.10828728,-0.35802647),vec4(-0.13133873,-0.038610373,-0.0018088103,0.30018932),vec4(-0.36391535,0.22295806,-0.5847471,0.3670008),vec4(0.23184785,-0.037351117,0.07498443,0.14172654)) * bufB[0] + mat4(vec4(0.057644147,-0.24209511,0.27877617,-0.33955774),vec4(-0.1518788,-0.04952726,0.18867469,0.23099795),vec4(0.1501271,-0.14157398,0.008457036,0.11796618),vec4(-0.17113969,0.12383903,-0.18575998,0.41588625)) * bufB[1] + mat4(vec4(-0.16702843,-0.143291,0.030662933,-0.21953891),vec4(-0.0011065454,-0.28517428,0.093323484,0.22412056),vec4(0.07667039,-0.10217787,-0.16886102,-0.30373788),vec4(-0.1496648,0.13022186,-0.551398,-0.06862121)) * bufB[2] + mat4(vec4(0.034822423,-0.16209286,-0.1156872,-0.107005306),vec4(0.039417543,0.0036854749,-0.110542536,0.3621033),vec4(-0.0015613532,-0.00075567164,-0.20156354,0.52869636),vec4(-0.060021363,0.013873869,0.038130775,0.052893776)) * bufB[3] + mat4(vec4(-0.3029081,-0.10414318,-0.2882297,-0.52448297),vec4(0.1872939,-0.03453853,0.24968386,-0.23312838),vec4(0.13037723,0.38678095,-0.50348574,0.41821986),vec4(-0.025774468,-0.053129353,-0.1901151,-0.31775767)) * bufB[4] + mat4(vec4(-0.45806393,0.022640223,-0.36054575,-0.029880853),vec4(0.6393721,0.035307653,0.5163976,-0.15782256),vec4(-0.21673189,0.11395648,-0.030746968,-0.24040294),vec4(0.12466431,-0.06516399,0.48096538,-0.43734366)) * bufB[5] + mat4(vec4(-0.26438862,0.13545933,-0.4418768,-0.2885495),vec4(-0.043724783,0.084897906,-0.3137108,0.044260878),vec4(0.2252301,-0.22139375,0.18354878,-0.27530473),vec4(0.11562573,0.03381446,-0.11377379,-0.043971103)) * bufB[6] + mat4(vec4(0.012888684,-0.10842138,0.09095412,-0.026929015),vec4(-0.009704896,-0.09689625,0.8049133,-0.4636161),vec4(0.0031350995,-0.21627027,0.26087764,0.0005766416),vec4(0.040237077,0.058316533,-0.16377239,0.16294172)) * bufB[7];\nbufA[3] = vec4(0.49668384,0.29708225,0.1454361,-0.71646345) + mat4(vec4(0.07730069,-0.21195413,0.34078938,0.061390948),vec4(0.40145802,0.03693796,0.21197738,0.068364844),vec4(0.3074955,0.23112714,0.29860574,-0.287868),vec4(0.0077479417,-0.27117854,-0.22094469,-0.2137733)) * bufB[0] + mat4(vec4(0.21859418,0.19399448,-0.21615297,-0.01703906),vec4(0.030193668,0.057647437,0.05811473,-0.07901107),vec4(0.10873194,0.37506443,-0.030459037,-0.5050159),vec4(0.074922316,-0.24323297,0.1546272,-0.5652297)) * bufB[1] + mat4(vec4(0.057212062,-0.14372765,-0.27146015,0.007866435),vec4(-0.051104996,0.1200591,-0.4390093,-0.06623883),vec4(-0.047320962,0.20713621,0.011291184,0.09747682),vec4(-0.13208704,-0.0975766,-0.052091353,0.18521751)) * bufB[2] + mat4(vec4(-0.07094247,-0.49675983,-0.11605726,0.20416059),vec4(0.019138806,0.3953694,0.00340255,0.0072578583),vec4(-0.07886781,0.3709391,0.20684116,-0.29751474),vec4(0.15304498,0.09975302,0.04816855,-0.10533625)) * bufB[3] + mat4(vec4(-0.5455673,-0.1648445,0.16746406,0.19780566),vec4(-0.08628868,0.15165587,-0.067341864,-0.040893886),vec4(-0.05919106,0.0071866633,-0.059191734,-0.025255186),vec4(-0.3658833,-0.39295283,-0.3849954,-0.096797936)) * bufB[4] + mat4(vec4(-0.28370255,-0.026878266,0.11873646,0.35829327),vec4(-0.022455575,-0.08905718,-0.21645288,-0.21571869),vec4(-0.39892063,-0.44584417,-0.108528465,0.3475833),vec4(-0.18602704,-0.12738137,-0.25623357,0.116262436)) * bufB[5] + mat4(vec4(-0.068034686,-0.7667095,0.06949485,0.049620066),vec4(-0.26023105,-0.18375401,0.14945063,0.12857224),vec4(-0.049209066,0.04989473,-0.2936479,-0.05137029),vec4(-0.23035449,-0.040370822,-0.21665546,-0.136399)) * bufB[6] + mat4(vec4(-0.21634078,-0.09770218,-0.16769497,0.15938395),vec4(-0.34084952,-0.02937271,-0.08218219,-0.26380393),vec4(-0.3364068,-0.2307863,-0.47061723,0.13524668),vec4(-0.36201468,-0.31932867,-0.04451971,0.49942377)) * bufB[7];\ntmp = atan(bufA[0]);\nbufB[0] = tmp/0.67;\nbufB[4] = (tmp*tmp) / 0.6;\ntmp = atan(bufA[1]);\nbufB[1] = tmp/0.67;\nbufB[5] = (tmp*tmp) / 0.6;\ntmp = atan(bufA[2]);\nbufB[2] = tmp/0.67;\nbufB[6] = (tmp*tmp) / 0.6;\ntmp = atan(bufA[3]);\nbufB[3] = tmp/0.67;\nbufB[7] = (tmp*tmp) / 0.6;\nbufA[0] = vec4(-0.49272716,0.19814727,0.2579291,-0.20937358) + mat4(vec4(0.082209565,-0.49163958,-0.02924105,0.015441424),vec4(0.004623659,-0.15760878,-0.20247659,-0.057464465),vec4(0.61993974,-0.11257923,0.3767441,0.04508028),vec4(0.44108152,-0.2848718,0.20430818,-0.08950389)) * bufB[0] + mat4(vec4(0.06217819,-0.106648825,-0.23685259,0.17733668),vec4(0.18934329,-0.26553074,-0.069523185,-0.16761385),vec4(0.05611644,-0.29308853,-0.17650412,0.6042097),vec4(-0.09873635,-0.15582824,0.014189916,0.21393187)) * bufB[1] + mat4(vec4(-0.019528372,-0.1293669,0.0076547163,0.13030279),vec4(-0.17346245,0.26686278,0.3883129,-0.23633437),vec4(-0.34588125,-0.4851837,-0.6241996,0.1678636),vec4(-0.22573446,-0.046266016,0.10105704,-0.054754548)) * bufB[2] + mat4(vec4(0.085014,-0.11795142,-0.051944308,-0.29604098),vec4(-0.04651805,-0.16780399,-0.17262293,-0.19030268),vec4(-0.31614104,0.20908232,-0.09782055,-0.55616134),vec4(0.01983099,0.18834972,0.21377465,0.34758723)) * bufB[3] + mat4(vec4(0.320026,0.29232213,0.05878084,-0.09552203),vec4(-0.10426552,-0.23647031,-0.07879187,-0.025850272),vec4(0.049399994,0.31051394,0.5722681,0.19596827),vec4(0.3818231,0.34325674,0.38098544,0.68817675)) * bufB[4] + mat4(vec4(0.19148365,-0.18241817,0.2950751,-0.1119766),vec4(0.5490207,-0.49457648,0.2039804,-0.30888754),vec4(0.13405234,-0.0064205555,0.10722924,0.61945593),vec4(-0.10083494,0.18547243,0.22668935,-0.34066364)) * bufB[5] + mat4(vec4(0.05745489,0.33004695,-0.14391871,0.12733686),vec4(-0.06680932,-0.011345774,0.31301966,0.08570059),vec4(-0.033061206,0.580648,0.50642395,-0.04853674),vec4(0.03403142,0.3532254,-0.001182335,0.020731362)) * bufB[6] + mat4(vec4(-0.043823067,0.5347286,0.3021745,0.16588488),vec4(-0.21096827,0.0360647,-0.15225337,-0.29434508),vec4(-0.25538233,-0.05496189,0.18322203,-0.44614646),vec4(-0.37045452,-0.0536167,-0.10190382,0.22432093)) * bufB[7];\nbufA[1] = vec4(0.3925343,0.44028273,-0.53479356,-0.38176933) + mat4(vec4(0.18942845,0.13560402,-0.020269515,-0.06984382),vec4(0.062230628,-0.2388355,0.04913622,0.06566606),vec4(-0.11962017,-0.4965788,0.43953797,0.13944942),vec4(-0.38682023,0.0022638196,0.28598025,0.089282796)) * bufB[0] + mat4(vec4(-0.21561505,-0.20312221,0.22457615,0.10962152),vec4(-0.24728794,0.104084805,0.24122399,0.042467378),vec4(0.21404855,0.37017357,0.04953474,-0.17563605),vec4(0.04512872,-0.16398236,-0.08677068,-0.042577446)) * bufB[1] + mat4(vec4(-0.02315363,-0.1640844,-0.22185823,0.02408516),vec4(0.1593581,0.0026239054,0.06676351,-0.012486454),vec4(0.07240818,0.0055775475,-0.34807745,0.044717703),vec4(0.121841244,-0.35863295,-0.009675936,0.08723844)) * bufB[2] + mat4(vec4(-0.14954981,-0.011497932,-0.06690906,0.32261896),vec4(-0.3178466,-0.14366217,0.13048474,-0.009046429),vec4(0.027867414,0.09799013,0.09873077,-0.022093391),vec4(-0.43767858,0.0894376,0.3047325,0.08192865)) * bufB[3] + mat4(vec4(-0.11955349,0.04251531,0.037197158,0.106200635),vec4(0.05421407,0.30607232,-0.37291357,-0.5017636),vec4(0.26948053,0.35694447,0.030221442,-0.23889801),vec4(-0.16622873,-0.030798722,0.38968801,-0.2144946)) * bufB[4] + mat4(vec4(-0.14623523,0.110298604,-0.14602563,0.16295105),vec4(-0.13161491,-0.1702305,-0.19046038,0.11140647),vec4(0.103458315,0.29427144,-0.18589151,-0.40335682),vec4(0.11346335,0.13275623,0.19949225,-0.57766366)) * bufB[5] + mat4(vec4(-0.11252199,0.16231625,-0.07415384,-0.174347),vec4(0.30917138,0.08065128,-0.1941919,0.5208881),vec4(0.24113275,-0.04647988,0.21745741,-0.0738131),vec4(-0.18985839,0.14219953,-0.04169515,0.07657433)) * bufB[6] + mat4(vec4(-0.15296088,-0.049411844,0.07623872,-0.09859268),vec4(0.12146361,-0.15962587,-0.03759259,0.37934333),vec4(0.44053087,0.26549017,-0.21571586,-0.19914441),vec4(-0.10416555,-0.14738399,-0.24296546,0.039855808)) * bufB[7];\nbufA[2] = vec4(-0.5039044,0.050333455,-0.48714775,-0.40797698) + mat4(vec4(-0.08432522,-0.23220856,0.12214793,-0.08826435),vec4(-0.37166205,-0.17586337,0.12102419,-0.3878744),vec4(-0.20595512,0.33325616,-0.021094296,-0.17678937),vec4(0.19809523,-0.018850205,0.033687692,-0.11804781)) * bufB[0] + mat4(vec4(0.13280629,-0.39224946,0.11081454,0.22009018),vec4(0.047373004,0.08662173,-0.3546337,-0.55753744),vec4(-0.31447375,0.07479613,-0.26863945,0.09237899),vec4(-0.19441646,-0.09141983,0.028303757,0.17435333)) * bufB[1] + mat4(vec4(-0.073487036,-0.06255257,-0.5175322,-0.0042826626),vec4(-0.15802923,0.09919525,-0.14868167,0.12595178),vec4(-0.5119539,-0.17322108,-0.2871213,-0.2138322),vec4(0.28075048,-0.08407418,-0.22362596,0.09456981)) * bufB[2] + mat4(vec4(0.04126975,-0.22876215,-0.20762838,-0.4399492),vec4(0.118720174,-0.20365752,-0.3180024,-0.4858404),vec4(0.2422827,-0.13267477,0.16781043,-0.20964995),vec4(-0.02088079,0.16145746,0.04390977,0.69191027)) * bufB[3] + mat4(vec4(0.19709164,-0.30095193,0.013104767,-0.13089637),vec4(-0.056095775,-0.32629454,-0.08028833,0.114248276),vec4(-0.053390455,-0.042808324,0.25406212,0.3243189),vec4(0.15737464,0.12323097,0.051445544,0.2773899)) * bufB[4] + mat4(vec4(-0.4500657,0.042385023,0.08793909,0.09918514),vec4(0.20272417,0.029558504,0.31175485,-0.24579574),vec4(-0.16063549,0.11812995,-0.01698143,0.067490846),vec4(-0.3240299,-0.14816988,0.32573932,0.46855333)) * bufB[5] + mat4(vec4(-0.35656077,-0.23328659,-0.004026594,0.07268032),vec4(-0.0011165112,-0.043378722,0.043464705,0.08600959),vec4(-0.20787589,-0.15374938,0.10747231,0.19669342),vec4(-0.33605358,0.105214074,0.20298816,0.2265728)) * bufB[6] + mat4(vec4(-0.30215347,0.5333784,-0.21047792,0.51396734),vec4(-0.3358874,0.26160514,-0.4530291,-0.1545915),vec4(-0.33071592,0.19083774,-0.105523266,0.14742367),vec4(-0.16633953,-0.036600616,0.15853705,-0.28379533)) * bufB[7];\nbufA[3] = vec4(0.31543967,-0.1440293,0.15916215,-0.7267685) + mat4(vec4(0.021747038,0.124898486,0.013782395,-0.15250467),vec4(0.26546824,0.04411789,-0.12535208,-0.0058618835),vec4(-0.20754237,-0.054307383,-0.15058361,0.32698318),vec4(0.053492166,0.054915644,-0.08688869,0.435683)) * bufB[0] + mat4(vec4(-0.21304622,0.2767829,-0.12812719,0.16990604),vec4(0.19349608,0.30016524,0.08216311,-0.30781546),vec4(-0.08381636,-0.02782673,-0.16662371,-0.4185515),vec4(0.031656258,-0.35000536,-0.047208533,0.0043815775)) * bufB[1] + mat4(vec4(-0.11814413,0.26119593,0.10019543,0.002341261),vec4(0.15840213,0.2850925,0.09109719,0.067813985),vec4(0.22678605,-0.06873435,-0.17665783,-0.2627405),vec4(0.14229183,-0.09947602,0.036661964,0.14304633)) * bufB[2] + mat4(vec4(0.22696322,0.2853575,-0.30616483,0.08601173),vec4(0.45969394,0.4729983,-0.17981808,-0.4656394),vec4(-0.007009553,0.23430979,0.34966594,0.3585001),vec4(0.030305969,-0.16624993,0.047301255,0.1385112)) * bufB[3] + mat4(vec4(0.12560748,0.099837966,-0.032287452,-0.12844843),vec4(-0.09579794,0.06948058,-0.26753482,-0.43002743),vec4(-0.15548606,-0.3223447,0.26888976,0.16650292),vec4(-0.28507447,-0.16434096,0.34747076,0.15638362)) * bufB[4] + mat4(vec4(-0.20757173,-0.14394605,-0.07260176,-0.3442261),vec4(0.064700186,0.2399962,-0.02585275,0.04949599),vec4(0.08274591,-0.103452936,0.12782598,-0.21992753),vec4(-0.3890103,-0.14220466,0.21553616,0.20985107)) * bufB[5] + mat4(vec4(-0.10039888,-0.07896874,-0.06921348,-0.0026895234),vec4(-0.1741446,0.119164206,0.14185844,0.034687117),vec4(0.13731842,-0.016509626,0.4214293,0.13989268),vec4(-0.5854998,-0.17805731,0.17953673,0.021692386)) * bufB[6] + mat4(vec4(-0.06718292,-0.5997938,-0.112841986,-0.15200129),vec4(0.1839641,0.17676523,-0.01215037,-0.38513708),vec4(-0.04829954,-0.10665939,0.19156685,-0.056461595),vec4(0.18713014,-0.039726812,0.09367697,-0.5707948)) * bufB[7];\ntmp = atan(bufA[0]);\nbufB[0] = tmp/0.67;\nbufB[4] = (tmp*tmp) / 0.6;\ntmp = atan(bufA[1]);\nbufB[1] = tmp/0.67;\nbufB[5] = (tmp*tmp) / 0.6;\ntmp = atan(bufA[2]);\nbufB[2] = tmp/0.67;\nbufB[6] = (tmp*tmp) / 0.6;\ntmp = atan(bufA[3]);\nbufB[3] = tmp/0.67;\nbufB[7] = (tmp*tmp) / 0.6;\nbufA[0] = vec4(0.022647766,0.43301105,0.07124476,0.5891566) + mat4(vec4(0.106955186,-0.0740886,-0.20420967,0.040680785),vec4(0.046530787,0.12551762,-0.07284599,0.09466414),vec4(0.18333356,0.032884885,-0.37055898,-0.28800493),vec4(-0.547322,-0.47958782,0.078058556,-0.18832539)) * bufB[0] + mat4(vec4(-0.09742489,0.1575377,0.15004791,-0.040688097),vec4(-0.105863094,0.09518007,-0.09288933,-0.07238565),vec4(0.28282043,-0.052472286,-0.1978017,-0.4239592),vec4(0.24427925,0.07358462,-0.13529709,-0.3284933)) * bufB[1] + mat4(vec4(0.108375676,-0.10990075,-0.18253928,-0.24243115),vec4(-0.11698211,-0.077411994,-0.40505046,-0.016192341),vec4(0.17970063,0.31595245,-0.35413235,0.00028854999),vec4(-0.012003062,-0.22159053,-0.19849108,0.02014435)) * bufB[2] + mat4(vec4(0.010296353,0.18225284,0.4421541,-0.14544393),vec4(0.097567074,0.28632268,0.15402727,0.24417506),vec4(0.045594994,0.1489328,0.0073778084,0.017833127),vec4(0.24656244,-0.15892328,-0.009717884,-0.34599078)) * bufB[3] + mat4(vec4(-0.12732573,0.119980104,-0.3030131,-0.10585168),vec4(-0.30561012,0.33550858,0.013363981,0.48232517),vec4(0.28088984,0.23309846,-0.12901483,0.06979934),vec4(-0.17757349,-0.4802094,-0.36526904,-0.35510412)) * bufB[4] + mat4(vec4(0.22264785,0.045487896,0.008360866,0.025178418),vec4(-0.10884647,-0.23532742,-0.27400658,0.10963388),vec4(-0.012221781,-0.2721134,-0.054653626,0.10804211),vec4(-0.16717753,0.05392876,0.057645015,-0.41062504)) * bufB[5] + mat4(vec4(-0.09124403,-0.021912849,-0.08751847,0.24784935),vec4(-0.033442482,0.003510592,-0.07568446,-0.017208552),vec4(0.009929976,0.16627121,0.07013511,0.32229796),vec4(-0.3724873,0.20471616,-0.037483755,0.4316486)) * bufB[6] + mat4(vec4(-0.047696657,-0.17289537,-0.24381846,0.107347086),vec4(-0.092202626,-0.22485135,-0.12395929,0.11961665),vec4(0.012003842,-0.10985969,0.11882847,0.12249971),vec4(-0.5976311,0.16837838,0.11095368,-0.07900641)) * bufB[7] + in0;\nbufA[1] = vec4(-0.5257323,-0.26539907,-0.26971444,0.5078853) + mat4(vec4(-0.16832353,0.013859047,-0.25874978,-0.25802577),vec4(0.435699,-0.15954362,-0.120464794,-0.07999876),vec4(0.43237758,-0.39243293,0.34048668,-0.3275938),vec4(0.26033318,-0.37747225,-0.14260946,0.16177152)) * bufB[0] + mat4(vec4(0.0998113,-0.14456552,0.2061974,0.35658887),vec4(0.10569003,0.0883345,-0.15283795,0.15309615),vec4(0.15474114,-0.23183481,-0.16196162,-0.11031415),vec4(-0.090777434,0.41124207,0.05914896,-0.51361287)) * bufB[1] + mat4(vec4(0.26870707,0.09191026,0.0005593961,0.022337977),vec4(0.16897897,-0.15446757,0.005105121,-0.13381821),vec4(0.332429,-0.17513143,0.119942255,-0.024115874),vec4(0.6641851,-0.39335778,-0.037411954,-0.12767921)) * bufB[2] + mat4(vec4(-0.22924158,0.15604584,0.17287993,-0.04460197),vec4(-0.3392564,0.57413864,0.12391606,-0.054690383),vec4(-0.0056030955,-0.007474138,0.06707771,0.3729894),vec4(0.15733801,0.119576,-0.2710422,-0.10160216)) * bufB[3] + mat4(vec4(-0.16679303,0.018776286,0.28698185,-0.12287697),vec4(0.072007716,-0.020465977,0.2079129,0.3205551),vec4(0.21419731,-0.14185898,0.21498612,-0.07207494),vec4(0.3157557,-0.10664688,0.07303007,-0.012154612)) * bufB[4] + mat4(vec4(0.0078070257,-0.4550695,0.29341817,0.24011166),vec4(0.060222734,-0.19481182,0.045099836,0.18828973),vec4(0.1504956,-0.12730663,0.3132916,0.06671864),vec4(0.16692773,0.14722657,0.18366472,0.07661985)) * bufB[5] + mat4(vec4(0.2143421,0.05436324,0.19081949,0.4328481),vec4(-0.085790254,0.09496702,0.5881508,-0.13163505),vec4(0.054744862,0.097720146,0.023595609,-0.20783803),vec4(-0.33468774,0.37894574,-0.10003422,0.08633971)) * bufB[6] + mat4(vec4(0.04192798,0.10252972,-0.09721341,-0.18864028),vec4(0.2918268,0.25749636,-0.023497133,0.025728622),vec4(-0.07540477,0.055198904,-0.04197887,-0.12530828),vec4(-0.334065,0.48017508,0.1054961,0.28723994)) * bufB[7] + in1;\nbufA[2] = vec4(0.25379002,-0.6589909,0.14332034,0.5008996) + mat4(vec4(0.1991462,0.62149924,-0.26503003,-0.40989748),vec4(0.11264868,0.061865,-0.084048405,-0.12728603),vec4(0.39238358,0.27230626,-0.33937284,-0.038176417),vec4(0.58294636,0.55852723,-0.36074743,0.32122743)) * bufB[0] + mat4(vec4(-0.09372624,-0.039053287,-0.091044866,-0.14389968),vec4(-0.36742252,-0.11718431,-0.034097355,0.5812902),vec4(0.19379953,0.18720312,-0.21319316,-0.08347496),vec4(0.02065562,0.148574,-0.12825446,-0.3528181)) * bufB[1] + mat4(vec4(0.12974535,0.26468942,0.09906491,0.035901602),vec4(0.3889494,0.07097937,-0.41628587,-0.22967577),vec4(0.07559818,0.16688578,-0.06785664,0.027098052),vec4(0.025819914,0.011092817,0.2646039,-0.09543419)) * bufB[2] + mat4(vec4(0.006991183,-0.268067,0.023162382,0.3168556),vec4(-0.13524325,-0.27817553,-0.15227832,0.046202816),vec4(0.044166297,-0.12776664,0.04589928,0.18450727),vec4(0.0013442567,0.26670223,-0.0048760436,0.04300502)) * bufB[3] + mat4(vec4(0.41983524,0.3297438,0.016717536,-0.34626135),vec4(-0.3412419,-0.095130466,0.019943073,0.17329393),vec4(0.38807735,-0.09670513,-0.069039635,-0.2673401),vec4(0.20077913,0.27508563,-0.09339606,0.0024540473)) * bufB[4] + mat4(vec4(0.028969059,-0.1701402,0.10139835,0.07361756),vec4(0.01950419,0.022795448,0.023708092,0.5333765),vec4(0.045178276,-0.23146296,0.44340712,0.18677896),vec4(0.102305874,0.17768332,0.13896014,0.06950603)) * bufB[5] + mat4(vec4(0.18497042,0.06559684,-0.15307765,0.15011719),vec4(0.053465888,0.24728274,0.36008075,-0.04698268),vec4(-0.15267356,-0.019314332,0.2654743,-0.08480704),vec4(-0.3087434,-0.43766356,-0.0050647045,-0.013071175)) * bufB[6] + mat4(vec4(-0.50230163,-0.2174886,0.06571843,-0.2521099),vec4(-0.01322861,0.24634185,0.04101044,-0.041248202),vec4(-0.07311194,0.33078143,0.17878477,0.00864393),vec4(-0.11497196,-0.34319052,-0.0469964,-0.024945416)) * bufB[7] + in2;\nbufA[3] = vec4(-0.15394863,-0.34595156,-0.24173003,0.26409012) + mat4(vec4(-0.19734666,-0.015005163,0.1270123,0.31274116),vec4(0.25864604,0.093337275,0.09440035,-0.034125254),vec4(0.60425305,0.35622922,-0.05808888,-0.022773767),vec4(0.4037894,0.55071455,0.06725969,-0.27142137)) * bufB[0] + mat4(vec4(0.09678973,-0.21746582,0.10585695,-0.12849292),vec4(0.15274616,-0.31876683,-0.22677135,-0.54864246),vec4(0.15587857,-0.08435282,0.19774053,0.038555387),vec4(-0.24011274,0.019129908,0.3717834,0.4443587)) * bufB[1] + mat4(vec4(0.118504904,-0.041668493,0.08517173,0.110313416),vec4(0.063948505,0.19858977,0.24954942,-0.24757864),vec4(0.11085827,-0.17090607,-0.024462955,-0.218319),vec4(-0.009561564,0.085509405,-0.058956284,0.15274842)) * bufB[2] + mat4(vec4(-0.16873488,-0.23164311,-0.15518294,-0.21545164),vec4(-0.352455,-0.43607596,0.085112944,0.22815907),vec4(0.23883472,0.04622393,-0.086341985,0.00013223727),vec4(0.14547384,-0.26671627,0.01855706,0.16050151)) * bufB[3] + mat4(vec4(0.51766956,-0.11709828,-0.26859584,-0.09214056),vec4(-0.1572954,-0.37153733,-0.19619793,-0.0020349978),vec4(0.27556968,0.121876456,-0.2786819,-0.30187023),vec4(0.024704702,0.26881987,0.4985097,0.40939218)) * bufB[4] + mat4(vec4(0.17582406,-0.35902053,-0.36597842,0.11582861),vec4(0.51863945,-0.20064676,-0.20298453,0.038785934),vec4(-0.039600242,0.09379975,-0.0061539668,-0.53211254),vec4(0.37434813,0.032043148,-0.108125664,-0.21113108)) * bufB[5] + mat4(vec4(-0.1377355,0.44398388,0.15506089,-0.37404722),vec4(0.038906552,0.077746645,-0.079487406,-0.10765066),vec4(-0.060717218,-0.055968218,0.041270398,0.2854097),vec4(-0.15562789,0.13347812,0.04801229,-0.23927404)) * bufB[6] + mat4(vec4(-0.18845409,0.079814926,-0.1228193,0.073832035),vec4(0.163158,0.029287172,0.2420007,0.39954957),vec4(0.4593627,-0.011815849,-0.25125456,-0.21844152),vec4(0.051588953,0.017213138,0.023312302,-0.07047295)) * bufB[7] + in3;\ntmp = atan(bufA[0]);\nbufB[0] = tmp/0.67;\nbufB[4] = (tmp*tmp) / 0.6;\ntmp = atan(bufA[1]);\nbufB[1] = tmp/0.67;\nbufB[5] = (tmp*tmp) / 0.6;\ntmp = atan(bufA[2]);\nbufB[2] = tmp/0.67;\nbufB[6] = (tmp*tmp) / 0.6;\ntmp = atan(bufA[3]);\nbufB[3] = tmp/0.67;\nbufB[7] = (tmp*tmp) / 0.6;\nbufA[0] = vec4(-0.03688306,0.42016533,-0.5452001,0.48388946) + mat4(vec4(0.36189884,-0.090169355,0.4123708,0.09097962),vec4(0.17519772,-0.16914949,-0.20366186,0.14932328),vec4(0.05148192,-0.04725986,0.028291654,-0.19439493),vec4(-0.23446696,-0.2600951,-0.37294033,-0.20098357)) * bufB[0] + mat4(vec4(0.05873717,-0.27991897,0.5148751,0.05473601),vec4(-0.17402843,0.35096556,-0.42037225,0.019409852),vec4(0.44095787,0.20515881,0.05010785,0.38161233),vec4(0.039955854,0.27711254,-0.028437559,-0.20275703)) * bufB[1] + mat4(vec4(0.33138242,0.13003042,-0.093473546,0.70897096),vec4(-0.17350219,0.14517714,0.7765317,0.26729634),vec4(0.088312946,-0.039568245,-0.15582448,0.09652546),vec4(0.29817742,0.17307152,0.17535967,0.088178545)) * bufB[2] + mat4(vec4(0.4161686,0.09774712,0.02539128,0.534023),vec4(0.114596665,0.003585313,0.5362325,-0.1553871),vec4(0.1811798,-0.22592357,0.12852813,-0.17930289),vec4(-0.18927795,0.011101204,0.1557022,-0.08783108)) * bufB[3] + mat4(vec4(0.19796683,0.00819865,0.20358129,0.06340134),vec4(-0.019250384,0.062279277,-0.3103531,-0.09685348),vec4(0.3160165,0.21219027,-0.1891308,-0.053074215),vec4(-0.18969305,-0.41503716,0.4045249,-0.39634022)) * bufB[4] + mat4(vec4(-0.30133855,-0.21889935,-0.47699696,-0.15871313),vec4(-0.2815081,0.06244025,-0.277462,0.003819351),vec4(0.05532253,0.031570353,-0.08513346,0.06310473),vec4(0.37420207,-0.05260369,0.16007091,0.008168375)) * bufB[5] + mat4(vec4(0.28281456,0.26503623,0.51011384,-0.17465669),vec4(-0.07698227,-0.28457928,0.16938692,0.24317518),vec4(0.117667235,0.11343406,-0.0689556,-0.27613172),vec4(0.31834844,0.0039239693,-0.08224374,0.0027006157)) * bufB[6] + mat4(vec4(0.49562663,0.08336628,0.19890708,0.41200373),vec4(0.082216844,0.026836945,0.021252137,0.09094677),vec4(0.16096123,0.011054538,0.094718166,-0.25246954),vec4(0.24629176,0.22142535,-0.06600799,-0.026919505)) * bufB[7];\nbufA[1] = vec4(-0.17549658,-0.35856378,0.1286605,0.04821878) + mat4(vec4(0.3085058,0.16288985,-0.13444468,-0.14659615),vec4(0.121063404,0.06383052,0.092065535,-0.17167816),vec4(0.11857918,-0.3611311,0.21602264,-0.09804889),vec4(0.21126738,0.06419054,-0.21435207,0.1200905)) * bufB[0] + mat4(vec4(-0.32804957,-0.019345652,0.3453669,-0.05329189),vec4(0.23121476,0.065208554,-0.07753789,0.12681243),vec4(0.17287679,0.01052281,-0.2184712,0.19220015),vec4(0.24108218,0.06481567,-0.04623652,-0.1480494)) * bufB[1] + mat4(vec4(-0.5194581,-0.12886834,0.02615709,-0.03134937),vec4(-0.23574585,0.2665192,-0.16614136,-0.35379905),vec4(0.4404753,0.17759791,0.039208304,0.22146653),vec4(-0.1755605,-0.3005327,0.20932437,0.301648)) * bufB[2] + mat4(vec4(-0.39269334,-0.3609913,0.118552655,-0.46705887),vec4(-0.28751057,0.08405717,-0.11559247,-0.15927887),vec4(0.28697258,0.70692325,0.056351624,0.13226388),vec4(0.50156116,0.13712862,-0.25484842,0.014772648)) * bufB[3] + mat4(vec4(-0.049118515,0.014550577,0.1966241,-0.12521115),vec4(0.1887915,0.13127832,0.16070452,0.12822632),vec4(0.16441883,0.2366171,0.18208785,0.28134277),vec4(0.13661604,0.075314224,0.17560144,0.19486044)) * bufB[4] + mat4(vec4(0.30788293,0.22076274,-0.0039070062,0.47451323),vec4(0.27027407,0.35189974,-0.08864479,0.35607103),vec4(0.1851119,0.035002172,0.004813391,-0.17002018),vec4(-0.13330461,-0.37393627,0.32528046,-0.059640378)) * bufB[5] + mat4(vec4(0.2844771,0.36619014,0.25693312,-0.25389782),vec4(0.35570267,0.18420464,0.3767336,0.22759579),vec4(-0.07782898,-0.2238543,0.12700136,-0.095538184),vec4(-0.16989894,-0.11711669,0.37060392,-0.30539122)) * bufB[6] + mat4(vec4(-0.2024269,-0.4259463,0.39678815,-0.4339369),vec4(-0.23701012,0.014572485,-0.043475535,-0.0988959),vec4(0.063216984,0.41033483,0.106110185,0.04502835),vec4(-0.018638197,-0.13026538,-0.124531426,-0.07806948)) * bufB[7];\nbufA[2] = vec4(-0.08430813,-0.10573175,-0.27811795,0.40212077) + mat4(vec4(-0.18144338,-0.099458836,-0.035687603,-0.20220387),vec4(0.121104084,-0.19244927,0.19984795,-0.02993359),vec4(-0.28260255,-0.07712416,-0.27824137,0.38613296),vec4(0.14315352,-0.0923429,-0.26381788,0.38677025)) * bufB[0] + mat4(vec4(-0.5161716,0.3830787,0.14840564,0.057208598),vec4(0.37424254,-0.038904823,-0.32135287,-0.100799195),vec4(0.021163171,-0.328431,-0.1064486,0.11125035),vec4(-0.018518262,-0.35864124,0.13887493,-0.16511323)) * bufB[1] + mat4(vec4(0.23937115,0.026890464,0.23232333,-0.05890608),vec4(-0.7686126,-0.012838253,0.3927272,-0.82192004),vec4(0.17613176,-0.21960266,-0.17185715,0.33868274),vec4(0.25862867,0.057881612,-0.0071809595,0.11285218)) * bufB[2] + mat4(vec4(0.29029566,0.06680649,0.24212188,-0.25144303),vec4(-0.2138477,0.40151224,0.3376713,-0.26291522),vec4(0.08060266,0.090732746,0.5528505,-0.08639107),vec4(-0.09474238,0.098900974,0.25571257,-0.035554472)) * bufB[3] + mat4(vec4(0.02007963,0.24509402,0.2826844,-0.24860531),vec4(0.22623907,-0.24527504,-0.28661308,0.26476958),vec4(0.24732363,0.29543906,-0.12324633,-0.1228896),vec4(-0.3240157,-0.08972366,-0.09336419,-0.021786215)) * bufB[4] + mat4(vec4(0.26422694,0.258053,-0.3126275,0.07781233),vec4(0.103057064,-0.39850676,-0.29243922,0.13987103),vec4(0.16245191,0.13711485,-0.19101834,-0.16024189),vec4(0.20759211,-0.05050647,-0.2841815,0.41310167)) * bufB[5] + mat4(vec4(-0.30138054,-0.021677425,0.41213208,-0.1383404),vec4(0.102833696,0.04573487,0.05233986,-0.21665232),vec4(0.009752363,-0.12598106,-0.045265943,-0.055250432),vec4(0.25902167,-0.09480516,-0.0063718758,0.07128201)) * bufB[6] + mat4(vec4(-0.21048641,0.06300885,0.08181816,-0.18017319),vec4(-0.11808548,0.0969719,-0.3313337,0.05663513),vec4(0.03970951,-0.09126141,0.004001066,-0.053297),vec4(0.15394652,-0.12165845,0.17327964,0.2286019)) * bufB[7];\nbufA[3] = vec4(-0.07500333,-0.16530988,-0.102540724,-0.029848939) + mat4(vec4(0.12179108,-0.35374624,-0.24960604,-0.19958349),vec4(0.1232034,0.21403036,-0.1462275,-0.080766894),vec4(0.028847767,0.52280843,-0.2243868,0.052302305),vec4(-0.22882195,0.1736377,0.2961714,0.088667735)) * bufB[0] + mat4(vec4(0.1641756,-0.42180556,-0.011295599,-0.20342381),vec4(-0.17782162,0.18621607,0.11779182,0.14141443),vec4(0.089181244,0.09985279,-0.1874299,-0.14209886),vec4(-0.12748878,-0.011604293,0.4901569,0.49939266)) * bufB[1] + mat4(vec4(0.13407351,-0.06305748,-0.42793858,-0.19208536),vec4(0.37956595,-0.85079986,0.021925261,-0.60653305),vec4(-0.32221237,-0.12929288,-0.05542431,-0.0031403042),vec4(-0.054395974,0.14749981,0.18659838,0.07034697)) * bufB[2] + mat4(vec4(-0.01807953,0.0052484167,-0.09812726,-0.32293612),vec4(0.03580088,-0.031090729,-0.42226937,-0.050728064),vec4(-0.10936859,-0.070810415,0.028598627,-0.060178667),vec4(-0.037819523,-0.089852735,-0.1988045,-0.27743727)) * bufB[3] + mat4(vec4(0.2786608,-0.122529924,-0.065746926,-0.27554658),vec4(-0.21170232,0.10259754,-0.0028340959,0.23170605),vec4(-0.4406148,0.11450314,0.24867044,0.27379733),vec4(-0.012339633,-0.065237045,0.43660423,-0.008106675)) * bufB[4] + mat4(vec4(-0.3448206,-0.21194421,0.21994983,-0.04659777),vec4(-0.15567969,0.16205427,0.23018895,-0.2769374),vec4(-0.29727212,0.17091358,0.07922716,-0.00405734),vec4(0.064865164,0.22125411,0.07260115,0.21362504)) * bufB[5] + mat4(vec4(0.041790392,-0.049928073,0.22166522,0.07980358),vec4(-0.0643302,-0.52297914,0.41656274,-0.060863264),vec4(-0.0021153418,-0.1397051,-0.100346394,-0.024653379),vec4(-0.30494836,0.12572192,0.2170954,-0.3615045)) * bufB[6] + mat4(vec4(0.3539333,-0.06830864,-0.18483657,0.13758604),vec4(0.3983713,0.087334625,0.24860708,0.28351343),vec4(-0.13272797,0.016703827,0.23835954,0.2512352),vec4(0.28770065,0.2634236,-0.39997223,0.39159423)) * bufB[7];\ntmp = atan(bufA[0]);\nbufB[0] = tmp/0.67;\nbufB[4] = (tmp*tmp) / 0.6;\ntmp = atan(bufA[1]);\nbufB[1] = tmp/0.67;\nbufB[5] = (tmp*tmp) / 0.6;\ntmp = atan(bufA[2]);\nbufB[2] = tmp/0.67;\nbufB[6] = (tmp*tmp) / 0.6;\ntmp = atan(bufA[3]);\nbufB[3] = tmp/0.67;\nbufB[7] = (tmp*tmp) / 0.6;\nbufA[0] = vec4(-0.22219574,0.08110032,0.09682924,-0.47059026) + mat4(vec4(0.025014542,0.19047156,-0.27074513,-0.46801),vec4(0.28420693,-0.06406507,0.14379591,0.19430162),vec4(0.39717427,-0.16998921,-0.20911163,0.16966516),vec4(0.107852,0.16005272,0.019828113,-0.09949211)) * bufB[0] + mat4(vec4(0.1365055,0.24059126,0.72532743,0.47102615),vec4(0.23813584,0.04702315,0.25904837,0.2716832),vec4(-0.1990068,-0.084954366,0.08633764,-0.20247294),vec4(-0.10862427,-0.30565652,0.47084633,0.05657641)) * bufB[1] + mat4(vec4(-0.2440486,0.28524068,-0.090494156,0.0898354),vec4(-0.10942319,0.021073822,-0.09201485,0.2481022),vec4(0.5391363,0.1349165,-0.37231463,-0.13358587),vec4(-0.14690626,-0.10190102,-0.08682451,0.038911253)) * bufB[2] + mat4(vec4(0.36779734,-0.22414759,-0.13845429,-0.040579926),vec4(-0.2620833,-0.30142403,-0.10871203,-0.02232198),vec4(-0.36026317,0.16331011,-0.037251666,0.1282144),vec4(-0.25426015,-0.20596641,0.037278175,-0.1687914)) * bufB[3] + mat4(vec4(-0.015799118,0.20475036,-0.46442997,-0.023480242),vec4(0.039746046,0.04721911,0.15397424,-0.10147803),vec4(-0.2876512,0.21118903,0.15141013,-0.10661648),vec4(0.06293281,0.16718908,-0.26525816,-0.16706581)) * bufB[4] + mat4(vec4(-0.008653847,-0.032874864,0.04975499,-0.25232193),vec4(0.24727719,-0.2650655,-0.08325356,0.0036056198),vec4(0.11969053,-0.098518714,-0.050532207,-0.48203033),vec4(0.19082023,-0.021765796,-0.064068645,-0.15100643)) * bufB[5] + mat4(vec4(0.0726709,-0.00827631,-0.039349638,-0.24493274),vec4(0.1800754,-0.19125888,-0.03515076,-0.087898806),vec4(-0.17708144,0.27,0.107263826,0.14570644),vec4(-0.38589555,0.0924594,-0.13848637,0.13649058)) * bufB[6] + mat4(vec4(-0.10039292,0.14684801,-0.08328363,-0.16452016),vec4(0.3145122,0.20991494,-0.22002731,0.18138552),vec4(0.096424825,0.15422364,0.082278036,-0.22416167),vec4(0.07967347,-0.41389772,0.078978166,-0.16120672)) * bufB[7];\nbufA[1] = vec4(0.13375968,0.32013682,0.4005659,-0.40757138) + mat4(vec4(-0.26049364,-0.67822796,0.21339895,0.154719),vec4(0.031941075,-0.20524935,-0.20223525,0.10535022),vec4(0.2533872,-0.03808661,-0.10202027,0.07629213),vec4(0.21184707,-0.6222062,0.17290689,-0.13426653)) * bufB[0] + mat4(vec4(-0.13322408,0.2563011,0.028809393,-0.25453168),vec4(-0.07018787,0.44133255,-0.35090464,0.35794744),vec4(-0.040169388,-0.15709162,0.17622091,0.028932845),vec4(-0.29056823,0.40588516,-0.10704759,0.22505957)) * bufB[1] + mat4(vec4(-0.24321271,0.19980301,0.1299414,0.18926091),vec4(0.07742712,-0.05634682,-0.06401247,0.40277576),vec4(-0.28853083,-0.3167612,-0.54175204,0.06271105),vec4(0.21362397,-0.03503314,0.3767654,-0.23073089)) * bufB[2] + mat4(vec4(0.01690299,0.15975726,0.12666291,0.06627687),vec4(0.27962095,-0.14930159,0.13727142,0.3636744),vec4(0.07369851,0.121956296,-0.24561153,0.1857746),vec4(-0.046821225,0.059050135,0.2713815,-0.0566624)) * bufB[3] + mat4(vec4(0.15578641,-0.47133747,0.0024603175,0.036124896),vec4(0.10101007,-0.1574949,0.047280133,0.3451455),vec4(0.32484025,-0.060031593,0.15661696,-0.47301033),vec4(0.10252459,0.07733834,-0.09178872,-0.010678217)) * bufB[4] + mat4(vec4(-0.3381176,-0.30946833,0.39685404,-0.058036726),vec4(0.24137677,-0.59525454,-0.00044969333,0.06066114),vec4(0.14487419,-0.38591665,0.09108606,0.3484254),vec4(-0.117917284,0.3905375,-0.012273918,0.06862979)) * bufB[5] + mat4(vec4(0.22451824,-0.14144072,0.103418656,0.02569529),vec4(-0.024340814,0.34206626,0.314698,-0.077602275),vec4(-0.01061616,0.05396977,-0.10710312,-0.0574767),vec4(-0.061085913,0.108697765,-0.465898,-0.012621079)) * bufB[6] + mat4(vec4(-0.47353134,0.1108094,-0.07101587,0.18272683),vec4(-0.08133835,0.112408355,-0.28591746,-0.36838695),vec4(-0.26402432,0.1241693,0.044732053,0.084959954),vec4(-0.10293626,-0.23183656,-0.038115747,0.49972153)) * bufB[7];\nbufA[2] = vec4(0.18938465,0.24211608,-0.38077447,-0.33536813) + mat4(vec4(-0.2152116,-0.06199436,0.25732154,0.20235747),vec4(-0.10423722,-0.1842747,-0.115402676,-0.10588782),vec4(-0.23244694,-0.38554874,-0.46076632,0.12611656),vec4(0.20748782,-0.18655553,-0.5033582,0.147461)) * bufB[0] + mat4(vec4(-0.17312762,0.28984112,-0.030481724,0.21782377),vec4(0.27659997,0.018358463,-0.09031494,-0.047327604),vec4(-0.2055974,0.21628593,0.20421463,-0.30772978),vec4(0.14962736,-0.31766525,-0.07893743,0.4181977)) * bufB[1] + mat4(vec4(-0.028106704,0.07981264,0.2794962,0.2579597),vec4(-0.074463926,-0.0765295,0.06376264,0.20124646),vec4(-0.3037729,-0.22759192,-0.57055587,0.26523992),vec4(0.1816951,0.4741332,0.60706156,-0.47957227)) * bufB[2] + mat4(vec4(-0.35762095,-0.24012965,-0.0479959,-0.12477872),vec4(-0.21634246,0.26683825,0.3341505,-0.31803095),vec4(0.34713992,-0.2899746,0.26073232,0.09111081),vec4(-0.14989966,-0.0614809,0.20204283,-0.24624078)) * bufB[3] + mat4(vec4(-0.03185339,-0.12408931,-0.30718774,-0.1460018),vec4(-0.16677636,0.1232161,-0.118382566,-0.15617293),vec4(0.17001916,-0.11891127,0.13748491,-0.016299041),vec4(-0.15146455,0.12897782,-0.0500117,0.024664035)) * bufB[4] + mat4(vec4(-0.14509611,-0.10216189,-0.3160496,-0.23036118),vec4(0.03165996,0.17654774,-0.059808716,-0.41069278),vec4(-0.31549853,0.22694232,0.11447315,0.13147707),vec4(-0.42967913,0.052255858,-0.21623518,-0.18686607)) * bufB[5] + mat4(vec4(0.09555619,0.3741823,0.14064114,0.30390295),vec4(0.3424719,0.23366416,-0.23914951,-0.18038213),vec4(0.25459662,-0.18298505,0.12982734,0.03953956),vec4(0.21591136,0.09903775,0.4041307,0.13753308)) * bufB[6] + mat4(vec4(0.00944076,0.30644065,0.01876761,-0.060998514),vec4(0.05528328,-0.16337824,-0.15931715,-0.031294685),vec4(0.21867871,-0.014018947,0.23435077,0.033381402),vec4(0.01624158,-0.070110485,0.16857049,0.0056478363)) * bufB[7];\nbufA[3] = vec4(-0.20584285,-0.29306877,0.36628035,-0.51385516) + mat4(vec4(0.0017289937,-0.18522269,-0.18044686,0.29407495),vec4(-0.20368135,-0.25918937,-0.18306872,0.10978846),vec4(0.20032723,0.60830986,-0.13122143,0.5401648),vec4(0.07401492,-0.07307555,-0.35781735,0.20401515)) * bufB[0] + mat4(vec4(0.22530764,0.038475,0.4784387,-0.010519726),vec4(-0.07014159,-0.09559196,0.106163144,-0.08700386),vec4(0.014618144,0.19849898,0.23312722,-0.0721639),vec4(0.17165188,0.13783875,0.586003,-0.41759235)) * bufB[1] + mat4(vec4(-0.058633756,-0.3165871,0.06431635,-0.16432256),vec4(0.0580415,0.15470459,-0.18596995,-0.032197855),vec4(0.104878455,0.24683501,-0.18506399,0.45832747),vec4(-0.11384856,-0.38531676,0.07651328,-0.3741349)) * bufB[2] + mat4(vec4(-0.114737995,0.38753864,-0.036925178,0.19600989),vec4(-0.008834021,-0.27924705,0.055341866,-0.49906328),vec4(-0.049521122,0.12135687,-0.08823417,-0.12148109),vec4(0.0088199,-0.14707713,0.4601008,0.11081624)) * bufB[3] + mat4(vec4(-0.06657294,-0.288072,0.03958763,0.047558833),vec4(-0.41742876,-0.3285568,-0.0695956,-0.07995464),vec4(0.074090235,-0.71300554,0.21480183,-0.640926),vec4(0.017163265,-0.12376971,-0.33070427,-0.07335545)) * bufB[4] + mat4(vec4(0.090279184,-0.031405304,-0.6538407,0.26190197),vec4(-0.3907897,0.088212036,-0.4695799,-0.3287825),vec4(-0.16163233,0.061877545,0.0329182,0.06302859),vec4(-0.22582956,0.30356118,-0.17586353,0.06980791)) * bufB[5] + mat4(vec4(-0.16077197,-0.15511593,0.030308122,-0.31168386),vec4(-0.22412094,-0.45537362,0.053832732,-0.039758593),vec4(0.0835889,0.40473843,0.072426915,0.020111015),vec4(-0.1777025,0.13729344,0.29885015,-0.48036012)) * bufB[6] + mat4(vec4(0.09821225,-0.021009568,-0.09630521,0.3016441),vec4(-0.032381877,0.6414402,0.23208177,0.019418715),vec4(-0.14709641,-0.15259369,0.06332261,-0.07766673),vec4(0.2608811,-0.21601403,0.0736598,-0.35135597)) * bufB[7];\ntmp = atan(bufA[0]);\nbufB[0] = tmp/0.67;\nbufB[4] = (tmp*tmp) / 0.6;\ntmp = atan(bufA[1]);\nbufB[1] = tmp/0.67;\nbufB[5] = (tmp*tmp) / 0.6;\ntmp = atan(bufA[2]);\nbufB[2] = tmp/0.67;\nbufB[6] = (tmp*tmp) / 0.6;\ntmp = atan(bufA[3]);\nbufB[3] = tmp/0.67;\nbufB[7] = (tmp*tmp) / 0.6;\nbufA[0] = vec4(0.34333488,0.035600543,-0.042171583,-0.35963634) + mat4(vec4(-0.12593691,0.15506954,-0.18167703,-0.433184),vec4(-0.108375266,0.04465108,0.07013312,-0.26725537),vec4(-0.07242611,-0.14858516,0.044627808,0.21272172),vec4(0.220853,-0.1527233,-0.0026260593,0.057989538)) * bufB[0] + mat4(vec4(-0.13658322,0.043669056,0.2100827,-0.2636539),vec4(0.007890221,-0.032123588,-0.25402853,0.061787415),vec4(0.06325712,0.045401756,-0.6068945,0.049563758),vec4(0.22267321,-0.14169776,0.55129313,0.021414544)) * bufB[1] + mat4(vec4(-0.21021205,-0.23116302,-0.032672707,-0.2083897),vec4(-0.45742875,-0.0034125024,0.025646217,0.3263178),vec4(0.047446292,-0.21300979,-0.029175919,0.36571106),vec4(-0.119451016,-0.2663619,0.22503206,0.0821285)) * bufB[2] + mat4(vec4(-0.24893904,-0.22572859,-0.07512447,0.17695348),vec4(0.31244683,0.2861829,0.24681465,0.05638313),vec4(0.42010075,-0.011542799,-0.047800817,0.049208477),vec4(0.07055512,0.49233848,0.23471127,0.15268806)) * bufB[3] + mat4(vec4(0.13449451,0.0574381,-0.048376042,-0.05380767),vec4(-0.109199554,-0.21970564,0.053206794,-0.14819726),vec4(0.11330347,0.07338825,0.17607498,0.192752),vec4(0.22624493,0.34778088,0.021272022,-0.10817388)) * bufB[4] + mat4(vec4(0.29060572,-0.045227695,-0.3898011,-0.19624497),vec4(0.4531046,0.21942681,-0.22540288,0.26401478),vec4(-0.058983557,-0.16228881,-0.021921098,0.38906524),vec4(0.018229034,-0.4371961,-0.289779,-0.14015082)) * bufB[5] + mat4(vec4(0.07694778,0.04864601,0.3651875,0.048000902),vec4(-0.33348492,0.021981698,-0.1757138,-0.1013316),vec4(0.023638703,0.04977828,-0.41276225,-0.131988),vec4(0.07651373,0.26975986,-0.14899747,0.11746648)) * bufB[6] + mat4(vec4(-0.21300118,-0.45992643,-0.27227235,0.056859944),vec4(0.06460947,0.14523917,-0.2805882,-0.17638898),vec4(0.4859822,0.12932432,-0.050606646,-0.47878733),vec4(-0.07597723,-0.09223436,-0.41568923,-0.0060949167)) * bufB[7];\nbufA[1] = vec4(0.26228753,-0.12847538,-0.4274551,0.02479796) + mat4(vec4(-0.360326,-0.3122325,-0.17361768,-0.08703664),vec4(-0.15982164,-0.19101071,-0.031503685,0.009683869),vec4(0.271894,0.22612648,0.060835622,0.16913831),vec4(-0.1855572,0.07959861,0.113730185,-0.3560711)) * bufB[0] + mat4(vec4(0.28749073,0.4741153,0.22262046,-0.091447435),vec4(0.28957763,0.33020335,-0.24510863,-0.139298),vec4(0.04749112,0.257276,0.019706601,0.13436382),vec4(-0.0099476045,-0.32473528,-0.10647098,0.04047094)) * bufB[1] + mat4(vec4(0.16379026,0.07087411,-0.039644033,0.47581238),vec4(-0.30327526,0.045483857,-0.03501181,-0.09860452),vec4(0.60430676,0.14866754,-0.48415637,0.48436064),vec4(-0.22618292,-0.07664497,0.4193346,0.03069871)) * bufB[2] + mat4(vec4(-0.18173678,-0.103476234,0.07169973,0.040994868),vec4(-0.24509186,0.09085151,-0.038884215,-0.15454848),vec4(0.10981384,0.20301282,-0.1392773,-0.09885063),vec4(-0.2094424,-0.6089992,-0.17281918,-0.3600431)) * bufB[3] + mat4(vec4(0.18196125,-0.09263863,-0.21230364,-0.02860693),vec4(-0.08926939,-0.42866424,0.04354611,0.085952595),vec4(0.01930102,-0.23341182,-0.03221846,-0.19618292),vec4(-0.16272174,-0.09882148,-0.12601091,-0.038228005)) * bufB[4] + mat4(vec4(0.19029151,-0.18366164,-0.07540493,-0.014983139),vec4(-0.3518369,0.24007595,0.21999267,-0.20545657),vec4(0.010413495,-0.11492875,0.053740952,-0.109125644),vec4(0.13885221,-0.084387325,0.18217464,-0.1405026)) * bufB[5] + mat4(vec4(-0.4459901,0.088974826,0.063104875,-0.14665583),vec4(0.089128464,0.22729091,0.09621192,0.08983262),vec4(-0.10591193,-0.057056207,-0.1734096,0.37326074),vec4(-0.027878849,0.1039724,-0.09575733,0.11268118)) * bufB[6] + mat4(vec4(-0.1359572,0.010763775,-0.15218668,-0.15168425),vec4(-0.39996457,0.02668798,0.8140242,-0.04842146),vec4(0.23000322,-0.08333489,-0.15604587,-0.22659133),vec4(0.21257669,0.26450205,-0.49298978,0.5254972)) * bufB[7];\nbufA[2] = vec4(-0.16389287,0.31942126,0.26621723,0.42259273) + mat4(vec4(-0.28201783,-0.2649544,-0.26322195,0.16663921),vec4(-0.08118009,-0.0924782,0.004873634,-0.020043246),vec4(0.44694114,0.111815065,-0.17520827,0.046716526),vec4(0.3827434,0.085821286,-0.26367173,0.23214865)) * bufB[0] + mat4(vec4(-0.59651506,-0.03725916,0.29193634,0.08454543),vec4(0.4795978,0.08779498,-0.029029835,0.15419006),vec4(-0.15727451,-0.11532001,0.4041356,0.021805545),vec4(-0.22106189,-0.17228043,-0.16240524,-0.10165849)) * bufB[1] + mat4(vec4(0.62512547,0.060138915,-0.06674953,-0.49438602),vec4(-0.06517164,-0.12881349,0.052021928,-0.30008286),vec4(0.36449537,0.29889315,-0.42660886,-0.4182381),vec4(0.0604673,0.10081625,-0.12898432,-0.044434115)) * bufB[2] + mat4(vec4(0.09107574,-0.23426312,-0.07059516,-0.25824285),vec4(-0.24441163,-0.2668384,0.105933994,-0.2280419),vec4(0.40507108,0.06548799,-0.14680979,-0.15111062),vec4(-0.26420394,-0.215652,-0.17342259,0.13673393)) * bufB[3] + mat4(vec4(0.17295823,-0.025298782,-0.059051685,-0.24679555),vec4(0.17297149,-0.061412457,0.024250118,0.022576867),vec4(-0.47719547,-0.075919256,0.38420337,0.1819025),vec4(0.09919233,0.16551407,0.063227564,0.00031099562)) * bufB[4] + mat4(vec4(0.013575012,0.1826033,-0.21446012,0.0042731776),vec4(-0.11369747,0.087787665,0.5499004,0.5217147),vec4(0.16772838,0.2382292,0.1236803,-0.3626956),vec4(-0.041796952,-0.017383112,0.13061117,-0.18987228)) * bufB[5] + mat4(vec4(-0.0629312,-0.15770526,0.24768624,-0.098338075),vec4(-0.2626161,-0.024999218,0.14207646,-0.37299886),vec4(-0.19981605,-0.37813485,-0.31104466,-0.20192085),vec4(-0.09104364,-0.08117885,0.05573573,-0.013218031)) * bufB[6] + mat4(vec4(-0.24820846,0.22546652,-0.116703704,0.10145592),vec4(0.16132586,0.013419429,-0.112450466,-0.15496929),vec4(0.52297693,0.10639997,-0.15855594,-0.18635198),vec4(0.09938662,0.02116475,-0.12503603,0.002460145)) * bufB[7];\nbufA[3] = vec4(0.28123796,0.10024686,-0.34776092,0.14783666) + mat4(vec4(0.27517447,0.13628027,0.31392077,-0.3637771),vec4(-0.19124658,-0.15057467,0.27416402,-0.046460636),vec4(0.12890084,0.3353049,-0.15859962,-0.02321101),vec4(0.07954242,0.029793091,0.19578746,-0.076272435)) * bufB[0] + mat4(vec4(-0.025296433,-0.13284583,-0.24684666,0.47876814),vec4(0.023314008,0.006557029,-0.36241508,0.02976217),vec4(-0.20295413,-0.35208806,-0.03727873,0.31886467),vec4(0.27752963,0.22995971,0.09998724,-0.34200233)) * bufB[1] + mat4(vec4(-0.23667084,0.017789543,-0.2208325,0.06285123),vec4(-0.24814023,0.032575723,-0.03490747,-0.16248359),vec4(0.25087762,-0.14405866,0.009231794,-0.058475535),vec4(0.09566179,0.23872103,-0.06416611,-0.07685704)) * bufB[2] + mat4(vec4(-0.075285114,0.23551604,-0.16790882,-0.1105422),vec4(0.328286,-0.16346148,0.24649775,-0.013881703),vec4(0.35453776,0.22006035,-0.23888743,0.14769614),vec4(0.06475257,0.09587994,0.18441778,0.2258205)) * bufB[3] + mat4(vec4(0.013910242,-0.31261185,-0.33629844,0.08089266),vec4(0.37543145,0.068890736,0.1927521,-0.095681064),vec4(-0.01829606,-0.023064332,-0.05568188,-0.09340006),vec4(-0.058822982,-0.01956579,-0.2008008,0.1496029)) * bufB[4] + mat4(vec4(-0.07452334,-0.07089517,0.08063533,0.2546002),vec4(-0.44031286,-0.04100834,0.0015972777,0.12053251),vec4(-0.12829882,-0.21512854,0.00757297,-0.17972918),vec4(-0.24239586,0.005917758,-0.25922808,-0.21780911)) * bufB[5] + mat4(vec4(0.22475186,-0.095102504,-0.10272486,-0.332798),vec4(-0.19030243,-0.3157414,-0.17985404,-0.049581133),vec4(0.30454233,0.350003,-0.23833789,0.17419694),vec4(-0.27468,-0.004364911,-0.13676639,-0.0030040257)) * bufB[6] + mat4(vec4(0.044257734,-0.23405664,-0.09166489,-0.32880676),vec4(-0.037170537,0.06898781,0.059299555,0.12095319),vec4(0.07853374,0.017779313,0.086481735,-0.14704147),vec4(0.1354169,-0.08309499,-0.66447145,-0.25471583)) * bufB[7];\ntmp = atan(bufA[0]);\nbufB[0] = tmp/0.67;\nbufB[4] = (tmp*tmp) / 0.6;\ntmp = atan(bufA[1]);\nbufB[1] = tmp/0.67;\nbufB[5] = (tmp*tmp) / 0.6;\ntmp = atan(bufA[2]);\nbufB[2] = tmp/0.67;\nbufB[6] = (tmp*tmp) / 0.6;\ntmp = atan(bufA[3]);\nbufB[3] = tmp/0.67;\nbufB[7] = (tmp*tmp) / 0.6;\nbufA[0] = vec4(0.28306586,0.22959527,-0.35880914,0.28557986) + mat4(vec4(-0.122443534,-0.18748973,0.22658685,0.021713885),vec4(-0.4839875,0.28169245,-0.1929851,0.001223651),vec4(-0.23885092,0.17878667,-0.0006636499,0.14322224),vec4(0.13142756,-0.13278802,0.20995338,-0.005646321)) * bufB[0] + mat4(vec4(0.41330677,0.04324968,-0.062823534,0.07681742),vec4(0.12245189,-0.38006556,-0.08796626,0.02145387),vec4(-0.24357772,-0.23941489,-0.025618166,-0.05911793),vec4(0.5994696,0.27993283,-0.09224191,-0.24398924)) * bufB[1] + mat4(vec4(-0.03597697,-0.2740224,-0.1890259,-0.0042083864),vec4(0.14879672,-0.10487711,0.115727186,0.19820938),vec4(-0.12955062,-0.109577864,0.15482746,0.24137136),vec4(-0.2412184,-0.010298263,-0.09504638,0.157607)) * bufB[2] + mat4(vec4(0.20370664,0.23804271,-0.33940756,-0.21937157),vec4(0.26859877,-0.11569574,-0.00700202,-0.21827221),vec4(-0.24647877,-0.068718456,0.13908361,-0.43474704),vec4(-0.075698644,-0.20636968,-0.1073239,-0.047271695)) * bufB[3] + mat4(vec4(-0.050282642,-0.17476134,0.040687494,0.27556127),vec4(-0.029850986,0.17802614,0.031842347,-0.07622615),vec4(0.361325,-0.0016660377,-0.14421676,0.110655144),vec4(0.05411649,0.14295119,-0.080342196,0.21528956)) * bufB[4] + mat4(vec4(0.09456426,0.45969847,-0.30989343,-0.20137231),vec4(-0.25777644,0.05852079,0.23810333,0.03108816),vec4(-0.28595325,0.20340632,-0.74377584,-0.19663726),vec4(0.30776238,0.23383282,0.0045249052,-0.02987988)) * bufB[5] + mat4(vec4(-0.32094425,-0.11844189,-0.3090558,-0.08904546),vec4(-0.13388398,-0.078869835,-0.05316092,-0.0018185659),vec4(-0.1724143,0.10846213,0.037209306,-0.11844299),vec4(0.58866656,-0.09850815,-0.022261575,-0.07631882)) * bufB[6] + mat4(vec4(-0.031828165,0.032561254,0.19947882,0.4086451),vec4(0.085922346,0.1652706,0.035279736,0.3244753),vec4(0.1599315,0.15121101,-0.15106964,0.16408539),vec4(0.06607092,-0.052970637,0.07167244,0.029029164)) * bufB[7];\nbufA[1] = vec4(-0.31445825,-0.09756754,0.209975,-0.07368597) + mat4(vec4(-0.2014243,-0.13868856,-0.14683005,-0.06759785),vec4(-0.29922438,-0.2542105,0.13501254,-0.0794227),vec4(-0.04465849,0.01712778,0.118634224,-0.07152154),vec4(-0.09934992,0.34632212,-0.17467605,-0.007831005)) * bufB[0] + mat4(vec4(-0.5319495,-0.16044272,-0.024218269,-0.092086814),vec4(-0.31408748,-0.21861838,0.046159737,-0.22742122),vec4(-0.15695119,0.24141525,-0.2934781,0.13424733),vec4(-0.012031459,-0.27290887,0.043534826,-0.05094985)) * bufB[1] + mat4(vec4(0.013332249,0.0703544,0.23939605,0.13130452),vec4(-0.09340643,-0.017978538,0.118776016,-0.32647488),vec4(-0.2432252,-0.43928534,-0.25011337,-0.141573),vec4(0.020991853,-0.032126997,-0.24475971,-0.03778666)) * bufB[2] + mat4(vec4(0.24795726,0.12111525,0.122562274,-0.088035785),vec4(-0.025710113,0.31739172,0.0899836,0.11378557),vec4(0.19286028,0.04076392,-0.16373505,0.010400829),vec4(0.21304084,-0.068910465,-0.5407649,-0.060497653)) * bufB[3] + mat4(vec4(-0.054337334,-0.03941977,0.21229835,-0.25669655),vec4(0.027099278,0.3408604,0.15126672,0.06412545),vec4(-0.12552193,-0.36428773,0.12342316,-0.048524685),vec4(0.1796333,-0.37466136,-0.13387543,0.29202488)) * bufB[4] + mat4(vec4(0.1062534,-0.07862097,0.478528,0.051165946),vec4(0.0061646565,0.29415974,-0.16246404,0.020500027),vec4(0.4106688,-0.009341144,0.741439,0.36751866),vec4(-0.004923848,-0.021326115,0.09980737,-0.10982764)) * bufB[5] + mat4(vec4(0.03282983,-0.025614785,-0.1286004,-0.02123954),vec4(0.08766858,-0.28212523,0.15588927,0.030626208),vec4(-0.2265447,0.015025221,-0.08524102,0.06616824),vec4(-0.20842028,-0.2899818,0.38406393,0.4153597)) * bufB[6] + mat4(vec4(-0.09458116,-0.057566658,-0.356764,-0.3018729),vec4(-0.057857327,0.0035962942,-0.05719555,-0.23094526),vec4(-0.15563615,-0.22901817,-0.21149836,-0.26320004),vec4(0.06827371,-0.16793066,-0.12437695,0.105795376)) * bufB[7];\nbufA[2] = vec4(-0.071114406,0.2503286,0.43078402,-0.08576749) + mat4(vec4(-0.31597224,-0.09841674,-0.2915426,0.20549722),vec4(-0.25940847,-0.085748136,-0.09544628,0.13800935),vec4(-0.25932875,0.011776234,-0.22954631,-0.12194345),vec4(0.121099375,-0.31163082,0.01993538,0.027133588)) * bufB[0] + mat4(vec4(-0.17600395,-0.34197423,-0.23248391,-0.21773015),vec4(0.088632904,-0.24504301,0.005923797,-0.08812967),vec4(-0.15566576,0.045224402,0.08485772,0.0087754745),vec4(-0.26862884,0.12199482,-0.18252331,-0.33774808)) * bufB[1] + mat4(vec4(-0.018459504,-0.009105103,-0.002340665,-0.040851656),vec4(-0.05121601,-0.42412388,-0.22283317,-0.048008043),vec4(0.221971,-0.3452601,-0.21852368,-0.15306081),vec4(0.0041765785,0.07287141,0.013953432,0.21219563)) * bufB[2] + mat4(vec4(-0.1984249,0.145311,0.043170583,0.08150648),vec4(-0.328789,0.14310859,-0.055430587,0.059725814),vec4(-0.27342123,0.06741795,-0.056962326,0.16220294),vec4(-0.09819358,-0.09258384,-0.29595214,-0.019938955)) * bufB[3] + mat4(vec4(-0.2657911,-0.12157537,-0.05312604,0.107305534),vec4(-0.27792484,0.028171513,0.56474876,0.20149557),vec4(0.13823329,-0.20212567,-0.19895858,-0.05286217),vec4(0.16157797,0.14603196,0.0060971086,0.031161554)) * bufB[4] + mat4(vec4(-0.3695671,0.2544718,0.37153,-0.08520019),vec4(-0.26401392,0.29658186,-0.05786663,-0.07816143),vec4(-0.50124544,0.5179464,-0.17068808,0.0685623),vec4(-0.16180512,0.1482748,-0.12493594,-0.2347814)) * bufB[5] + mat4(vec4(-0.38923353,-0.25987488,0.1978015,-0.0110512385),vec4(-0.057488386,-0.12761118,0.37775758,0.12993577),vec4(0.07335056,-0.42263693,0.018190222,0.050933152),vec4(-0.11894879,0.010587463,0.15033665,0.0933359)) * bufB[6] + mat4(vec4(0.134665,-0.16635993,-0.2087813,-0.06486279),vec4(0.08872823,0.0015649828,-0.20601337,0.07539144),vec4(0.2052036,-0.04801042,-0.20444848,-0.11914386),vec4(-0.0016885587,-0.049111735,0.01802272,0.16688669)) * bufB[7];\nbufA[3] = vec4(-0.33425993,-0.45283687,0.40238792,0.25144064) + mat4(vec4(0.019121699,-0.12922488,-0.011014485,0.05370313),vec4(-0.041486498,0.020860232,-0.5829015,-0.09289857),vec4(-0.32722956,0.24022588,0.14300369,0.029260095),vec4(0.18453689,0.27655435,0.21166731,0.10568852)) * bufB[0] + mat4(vec4(-0.028977185,-0.34694436,0.41015005,0.04799084),vec4(-0.18277349,-0.11612749,0.14314787,-0.1715849),vec4(0.17684038,-0.09631111,-0.43433785,0.025469337),vec4(-0.1251474,0.079273395,0.67806304,0.22217034)) * bufB[1] + mat4(vec4(-0.26273268,-0.008685854,-0.061454084,0.30449536),vec4(0.49723798,-0.10384323,0.0046691527,-0.20941918),vec4(-0.49875137,-0.08128819,-0.16893563,-0.24793583),vec4(0.3007976,0.109469585,-0.7322441,0.17008173)) * bufB[2] + mat4(vec4(0.19299918,-0.05095627,0.09832589,0.033056356),vec4(-0.26082507,0.0012221836,0.027577948,-0.044457324),vec4(-0.23134518,0.20421386,0.13983946,0.043540683),vec4(0.06537537,0.033017527,-0.17568666,-0.14129497)) * bufB[3] + mat4(vec4(-0.09039579,-0.41533896,-0.15264992,0.08330472),vec4(0.30828124,0.36075476,-0.168571,0.1865518),vec4(0.070272885,-0.14197144,0.37862408,-0.026896467),vec4(-0.33957854,0.2938678,0.1384609,0.0151527375)) * bufB[4] + mat4(vec4(0.3266304,-0.22149535,-0.22759658,0.35793263),vec4(-0.22021209,-0.15702848,-0.32507655,-0.115998454),vec4(0.30064368,0.17705026,-0.10451349,0.51936483),vec4(-0.18229437,0.0997031,0.16658074,0.24133219)) * bufB[5] + mat4(vec4(0.55728436,-0.046178482,-0.5024576,0.08290428),vec4(0.024458222,0.31568387,-0.12145827,-0.20149007),vec4(0.21949564,-0.1837058,-0.22579451,-0.25598273),vec4(-0.12728904,0.01454727,0.24441548,0.008118272)) * bufB[6] + mat4(vec4(-0.11533347,0.22123401,0.031383693,0.027204644),vec4(0.06476852,-0.12691215,0.11994294,-0.09522415),vec4(0.2538013,-0.122360855,0.17980044,0.07059128),vec4(0.096756205,-0.32399255,0.11087955,-0.020612272)) * bufB[7];\ntmp = atan(bufA[0]);\nbufB[0] = tmp/0.67;\nbufB[4] = (tmp*tmp) / 0.6;\ntmp = atan(bufA[1]);\nbufB[1] = tmp/0.67;\nbufB[5] = (tmp*tmp) / 0.6;\ntmp = atan(bufA[2]);\nbufB[2] = tmp/0.67;\nbufB[6] = (tmp*tmp) / 0.6;\ntmp = atan(bufA[3]);\nbufB[3] = tmp/0.67;\nbufB[7] = (tmp*tmp) / 0.6;\nbufA[0] = vec4(-0.013486195,-0.32507575,0.26546207,-0.21417491) + mat4(vec4(0.30391097,-0.16245049,-0.38710603,-0.031867266),vec4(0.345871,-0.017950365,0.07969028,0.03529012),vec4(-0.11658732,0.0044468897,-0.1359971,-0.05437829),vec4(0.120166816,0.1491582,0.105504006,-0.29570195)) * bufB[0] + mat4(vec4(0.12726183,0.034176424,-0.16499294,0.0332956),vec4(0.13705136,0.2432657,0.10440954,0.320986),vec4(0.34021276,-0.2902605,-0.19232081,-0.14611611),vec4(0.038985103,0.012972802,0.051959373,-0.27028677)) * bufB[1] + mat4(vec4(-0.048947763,0.03528757,0.15812035,0.30928355),vec4(0.0167107,0.41606826,0.1594442,0.049698435),vec4(0.2997353,0.11312791,0.059662372,0.12462212),vec4(0.12726067,0.120534435,-0.18076654,-0.2560818)) * bufB[2] + mat4(vec4(-0.3048137,-0.33302975,-0.10669051,-0.29801723),vec4(-0.14466475,0.23534276,-0.20474008,-0.012211293),vec4(-0.08943569,0.11207865,-0.13046609,-0.015171917),vec4(0.02491674,0.119438656,-0.025476554,-0.34656775)) * bufB[3] + mat4(vec4(0.557114,0.14814813,0.052478336,0.22114746),vec4(-0.12029584,-0.10877709,0.060608484,-0.002499575),vec4(-0.110960856,-0.19629732,-0.21574992,-0.083257616),vec4(-0.013861414,-0.23580484,0.30639672,-0.12940831)) * bufB[4] + mat4(vec4(0.040707175,-0.18383966,-0.5781413,-0.23421863),vec4(0.17465128,-0.20626429,0.29121867,-0.17118503),vec4(-0.014133459,-0.23622276,0.21815553,-0.12636057),vec4(0.2611312,-0.15407814,-0.10783886,-0.1954425)) * bufB[5] + mat4(vec4(0.16824333,-0.2265349,-0.110802725,0.21358244),vec4(-0.30031472,0.24484201,0.34079885,-0.33869165),vec4(0.124768056,-0.046674322,0.395249,-0.001707339),vec4(0.041002348,-0.24065234,-0.34385943,-0.17048718)) * bufB[6] + mat4(vec4(-0.1302159,0.06898922,0.088335454,-0.20833288),vec4(-0.10003407,-0.38838434,-0.030397259,-0.05084753),vec4(0.92431265,-0.12767029,0.14574757,0.22144814),vec4(0.65445894,-0.24320509,-0.068497114,0.16114141)) * bufB[7];\nbufA[1] = vec4(0.29405534,0.038920194,-0.3874736,-0.39291) + mat4(vec4(-0.5524785,0.04073378,-0.1679955,-0.43898597),vec4(0.12994434,0.098366566,0.1336472,0.13953598),vec4(-0.49894997,0.022113957,0.1686563,-0.33564696),vec4(-0.18828246,-0.014834394,0.11827513,0.20761833)) * bufB[0] + mat4(vec4(0.17067721,0.122440554,0.14991026,0.1572995),vec4(0.07405673,-0.09423334,-0.002126264,-0.17220484),vec4(-0.41145983,0.03646687,-0.281624,-0.08266847),vec4(-0.19574033,0.014240584,-0.24891442,0.07029452)) * bufB[1] + mat4(vec4(-0.5659115,-0.06763987,0.22738488,-0.1054056),vec4(0.25362828,0.063294835,-0.17876646,0.26815292),vec4(0.020238105,0.22220445,0.2388265,0.03016332),vec4(0.28909004,0.17244467,0.27188575,0.070485845)) * bufB[2] + mat4(vec4(-0.003893824,0.04081436,-0.30556262,-0.094272085),vec4(0.20907167,0.12184172,0.11200094,-0.09975798),vec4(-0.042686224,0.110874645,-0.03329671,-0.17902192),vec4(0.070230395,0.01190076,-0.16879675,-0.047217466)) * bufB[3] + mat4(vec4(-0.04806064,-0.2647692,-0.62597704,0.044642042),vec4(-0.12695758,-0.31834796,-0.13672785,0.030984389),vec4(0.22920181,-0.30393168,0.13412784,-0.035641596),vec4(-0.25508162,0.0475138,0.0938668,-0.050633125)) * bufB[4] + mat4(vec4(-0.086060025,-0.31758365,0.21472713,-0.003026109),vec4(0.2091498,0.02886029,-0.15361671,-0.16980454),vec4(0.5356793,-0.20783727,0.112045065,0.11339182),vec4(-0.020509645,-0.120650515,-0.07990211,0.14986423)) * bufB[5] + mat4(vec4(0.5450036,-0.20801236,-0.28861752,0.17512353),vec4(-0.2046298,-0.46666792,0.2661991,0.2621726),vec4(0.060054887,0.10781852,0.027127689,0.22756472),vec4(0.15737334,0.097750425,0.10669416,0.04900946)) * bufB[6] + mat4(vec4(0.11164945,0.12717235,-0.21649677,0.0896417),vec4(-0.05842931,-0.5026216,-0.0988292,-0.21710564),vec4(0.18459076,0.08159534,-0.9152354,0.17663012),vec4(0.22745976,-0.18880494,-0.18156032,0.009560608)) * bufB[7];\nbufA[2] = vec4(-0.050627206,0.16876112,-0.21685876,0.3603687) + mat4(vec4(-0.041720185,0.10076258,-0.25367323,-0.3685321),vec4(-0.2291118,0.29283968,0.21183307,-0.3358434),vec4(0.21825828,-0.016139477,0.06020782,0.32297757),vec4(0.08414646,-0.31835988,0.25212854,0.48687708)) * bufB[0] + mat4(vec4(-0.13811179,0.17201266,-0.16145715,0.22335824),vec4(0.0076048784,0.17308213,-0.06578999,-0.059957437),vec4(0.30433246,-0.038772758,0.28112075,0.118137285),vec4(0.16221783,-0.0031919868,-0.09534214,-0.028712187)) * bufB[1] + mat4(vec4(0.27078694,-0.30822575,0.1677137,0.07770002),vec4(-0.15651493,0.48517364,-0.14978945,-0.62211096),vec4(0.016813554,0.20323566,0.060523327,-0.014010395),vec4(0.068583794,0.035253525,0.06084563,-0.25744498)) * bufB[2] + mat4(vec4(-0.25784332,-0.25291565,-0.048908796,-0.25596255),vec4(0.07569045,0.15132645,-0.4801467,-0.24360864),vec4(0.148932,0.025384672,-0.34271467,0.120222725),vec4(-0.24895874,0.03609057,0.4082751,-0.086207174)) * bufB[3] + mat4(vec4(-0.13392226,0.27760032,0.1966919,-0.118986376),vec4(-0.539645,-0.13097988,-0.36252677,0.43475103),vec4(-0.29462457,-0.03204743,0.006940564,0.24282426),vec4(0.14747612,-0.18037271,0.23608951,0.010953434)) * bufB[4] + mat4(vec4(-0.1265832,-0.16616212,0.46875817,0.09461774),vec4(0.12540512,-0.2035554,0.10373938,0.25817546),vec4(-0.31478214,0.4498039,-0.072069556,-0.02060219),vec4(-0.08964259,-0.13171303,0.3300447,0.05757157)) * bufB[5] + mat4(vec4(0.30278718,0.269784,-0.06301896,0.0011087566),vec4(0.20425126,-0.1063899,-0.25251678,0.44613814),vec4(-0.1250703,-0.10595793,-0.11127257,0.19829084),vec4(0.022047898,0.087422594,0.0014708037,0.11116071)) * bufB[6] + mat4(vec4(-0.023009397,0.16491245,-0.024029769,-0.022766663),vec4(0.05022126,-0.4991805,-0.29032794,0.10327223),vec4(0.06325593,0.20169394,0.3095096,-0.19119366),vec4(0.05139694,0.27195072,-0.07947269,-0.047458235)) * bufB[7];\nbufA[3] = vec4(0.20758443,0.26319963,0.3543845,-0.374557) + mat4(vec4(0.15290426,-0.108065456,0.086052656,-0.29569885),vec4(-0.29844382,-0.090763785,0.03271038,0.15857527),vec4(-0.19789183,-0.17427905,-0.05415978,-0.6143154),vec4(-0.07998605,-0.11030122,0.1993432,-0.011473758)) * bufB[0] + mat4(vec4(-0.019241368,-0.0638006,-0.004150646,-0.08962536),vec4(0.07369666,0.09769458,0.20008843,-0.1186479),vec4(-0.1253553,0.36316094,0.09661297,0.362528),vec4(0.031659465,0.12193538,0.012850011,-0.022779047)) * bufB[1] + mat4(vec4(0.11400168,0.041037336,0.056707628,-0.57191086),vec4(0.112429455,0.32979712,0.40636367,0.26125547),vec4(-0.2803938,0.3115405,-0.041095294,0.38275892),vec4(-0.38825288,-0.3885768,0.1889136,0.09461373)) * bufB[2] + mat4(vec4(0.32628107,-0.08258292,-0.22972766,0.24874641),vec4(0.11373954,0.104024574,-0.12430211,-0.08046167),vec4(0.10529321,0.23025897,-0.3127974,-0.2890251),vec4(-0.15987554,0.2410936,0.11143705,-0.060333416)) * bufB[3] + mat4(vec4(-0.23791851,0.12584,-0.059304,-0.034084436),vec4(-0.096151665,0.12712309,0.082360975,-0.18047707),vec4(-0.13228622,0.012949351,0.13042454,0.13980383),vec4(-0.18100758,-0.23848882,0.116797805,-0.15142791)) * bufB[4] + mat4(vec4(-0.33457172,-0.14530312,-0.031647235,-0.12112105),vec4(-0.12505963,0.10227386,-0.04236913,-0.20075352),vec4(0.047859136,-0.17261522,-0.2816275,0.58938175),vec4(-0.2438954,-0.27424058,-0.0044381414,-0.07466254)) * bufB[5] + mat4(vec4(-0.15833318,-0.26974332,0.36408556,0.321858),vec4(-0.014987728,-0.5501599,-0.47945765,-0.43194133),vec4(0.34176216,0.09377449,-0.332093,0.2240729),vec4(-0.10647855,-0.14109924,0.07284056,0.19018492)) * bufB[6] + mat4(vec4(0.051917356,-0.013809024,-0.2655711,0.18474114),vec4(-0.5495967,0.030382462,0.051932625,0.22243336),vec4(0.16497405,0.21691331,0.27428547,-0.25280005),vec4(-0.19926098,0.46225512,-0.19810043,0.2724643)) * bufB[7];\ntmp = atan(bufA[0]);\nbufB[0] = tmp/0.67;\nbufB[4] = (tmp*tmp) / 0.6;\ntmp = atan(bufA[1]);\nbufB[1] = tmp/0.67;\nbufB[5] = (tmp*tmp) / 0.6;\ntmp = atan(bufA[2]);\nbufB[2] = tmp/0.67;\nbufB[6] = (tmp*tmp) / 0.6;\ntmp = atan(bufA[3]);\nbufB[3] = tmp/0.67;\nbufB[7] = (tmp*tmp) / 0.6;\nbufA[0] = vec4(0.20186237,0.30873334,-0.44290742,-0.34150642) + mat4(vec4(0.31376144,0.04149227,-0.06634847,-0.41464287),vec4(-0.035924427,0.15965857,-0.040366046,0.04978562),vec4(-0.23458217,-0.02794117,0.32544535,0.018570509),vec4(-0.15285903,-0.13199754,0.4558136,-0.16328643)) * bufB[0] + mat4(vec4(0.024025619,-0.16130787,-0.10792845,-0.16094974),vec4(-0.1157222,-0.40774217,0.4619154,0.2430956),vec4(-0.34533957,0.06962146,-0.013098499,0.4599957),vec4(0.1467084,-0.41980696,0.21556567,0.20317475)) * bufB[1] + mat4(vec4(0.05754407,0.0015152509,-0.28542727,-0.009965516),vec4(0.26566747,-0.039349563,0.11256973,-0.0066197086),vec4(0.11236838,0.17141454,0.16120325,0.1877825),vec4(0.19944732,-0.251126,-0.3002186,0.16307825)) * bufB[2] + mat4(vec4(-0.031812884,0.10202658,0.032633662,-0.030291954),vec4(0.4096748,0.061482903,-0.21733549,-0.5602974),vec4(0.11683939,-0.10166027,0.4876576,-0.18112494),vec4(-0.2489568,0.38222358,0.2427088,0.1052537)) * bufB[3] + mat4(vec4(0.29174936,0.18686335,0.042604502,-0.7285926),vec4(0.064865835,-0.1474089,-0.053203896,-0.16046193),vec4(-0.039735857,-0.36844638,-0.31146577,0.14634645),vec4(-0.06221919,0.14515188,-0.021558564,0.27460206)) * bufB[4] + mat4(vec4(0.24839339,0.25841567,0.19771354,-0.15780178),vec4(-0.09443234,0.43129393,0.03635831,0.18863474),vec4(0.32547227,0.13641492,0.2120136,-0.33865824),vec4(0.39020953,0.051883563,-0.039266754,-0.29248103)) * bufB[5] + mat4(vec4(0.37461433,0.06792194,-0.468567,-0.018974464),vec4(-0.05007454,0.06008666,-0.41621503,0.38567796),vec4(0.187945,0.31431556,0.14955814,-0.17743406),vec4(-0.36735117,0.09114306,-0.27344847,0.13111232)) * bufB[6] + mat4(vec4(0.22575738,0.12548113,0.3066843,0.044142265),vec4(-0.046819393,0.099369675,0.19620055,-0.0964125),vec4(-0.4379616,0.16952777,0.23313743,0.024674237),vec4(0.14287539,-0.179661,0.18070695,-0.19630566)) * bufB[7];\nbufA[1] = vec4(0.13508758,0.067420155,-0.121603325,-0.27952784) + mat4(vec4(-0.16466324,0.20789559,0.65781987,-0.29019198),vec4(-0.07381621,-0.44946197,0.06304091,-0.31774202),vec4(0.04888987,-0.026313895,0.072785705,0.07486055),vec4(-0.094948374,0.14270832,0.15426517,-0.21494712)) * bufB[0] + mat4(vec4(0.32529506,-0.26297185,-0.098347776,0.062598936),vec4(0.14747056,0.2745003,-0.10748036,-0.10957703),vec4(0.19804892,-0.10031606,-0.5367271,0.4057839),vec4(-0.35012645,0.20854062,0.18675047,0.076918945)) * bufB[1] + mat4(vec4(-0.27265352,0.3148351,0.22468053,-0.11965138),vec4(-0.26986486,0.2772559,0.053494506,-0.26028487),vec4(0.10357733,0.056983866,-0.0075256643,0.017996129),vec4(0.25277212,-0.06457391,-0.11352731,0.20413353)) * bufB[2] + mat4(vec4(-0.34171772,-0.108328454,0.29558086,-0.15873134),vec4(-0.15885267,-0.13174681,0.2204218,-0.07166476),vec4(-0.0064424947,0.18462227,0.3098267,-0.0799449),vec4(0.2982084,-0.05898919,-0.010633527,0.18891825)) * bufB[3] + mat4(vec4(-0.07298756,0.24428263,-0.022720432,-0.46305817),vec4(-0.056289546,-0.4379849,0.09489536,-0.1298681),vec4(0.10633402,-0.4442073,-0.041160833,-0.25018418),vec4(-0.16936113,-0.029240198,0.11725521,0.3447079)) * bufB[4] + mat4(vec4(-0.181786,0.132112,0.46230432,-0.13545874),vec4(-0.20223057,-0.07985522,-0.074556164,0.082484744),vec4(-0.05220919,0.17571546,0.15980095,-0.2848564),vec4(-0.108002484,0.030806659,0.4824295,-0.047267985)) * bufB[5] + mat4(vec4(0.1600785,0.20947173,-0.15058589,-0.27349272),vec4(0.64914316,-0.11751273,0.070003994,0.1740842),vec4(0.0006858101,0.25652412,0.33586115,-0.32405317),vec4(0.06176912,-0.12470486,-0.45341548,-0.025902927)) * bufB[6] + mat4(vec4(0.15416764,0.1766851,0.2790537,-0.108954675),vec4(-0.19273755,-0.12131599,-0.18948981,-0.42113078),vec4(-0.0038300664,-0.10602361,-0.004264374,0.13946411),vec4(-0.53066206,0.47488877,0.6929089,-0.44355088)) * bufB[7];\nbufA[2] = vec4(-0.07745518,0.25176972,-0.2597267,0.111908175) + mat4(vec4(0.15988955,0.13707432,0.037561577,-0.4695828),vec4(0.14494756,-0.14487058,-0.20414785,0.1293177),vec4(-0.2380702,0.09958434,-0.25639114,-0.002866216),vec4(-0.12769991,-0.2166049,-0.0433871,0.014432979)) * bufB[0] + mat4(vec4(-0.0071910294,-0.11405468,0.21778831,0.21912931),vec4(0.15789936,-0.08416968,-0.19476345,0.09761735),vec4(-0.5292071,-0.24084641,0.11462163,0.20980681),vec4(-0.18849061,-0.08282951,0.28121424,-0.17579332)) * bufB[1] + mat4(vec4(-0.17625299,0.08310498,-0.14734456,0.33213207),vec4(0.055409342,-0.1337617,-0.42755535,0.25779855),vec4(-0.066521384,0.272227,-0.038226917,-0.10719541),vec4(0.04643083,0.17629607,-0.124881655,0.03941381)) * bufB[2] + mat4(vec4(0.13014247,-0.42353213,-0.11082221,-0.2255113),vec4(0.033012547,-0.0016861376,-0.23331356,-0.037908927),vec4(-0.19895186,0.315233,-0.43659216,0.09236447),vec4(0.06507314,0.063590825,0.19029772,-0.19901024)) * bufB[3] + mat4(vec4(0.44410875,0.37590933,0.28143916,0.103901684),vec4(0.26531237,-0.15173021,0.32529762,0.33188316),vec4(0.26231936,0.1256206,-0.16997701,-0.1038122),vec4(0.060124636,0.061114658,0.23468791,-0.02272441)) * bufB[4] + mat4(vec4(0.047000997,-0.050315853,0.016651342,-0.4183083),vec4(-0.16952822,0.14643475,0.17439541,-0.024541965),vec4(0.634084,0.28828463,-0.23329663,0.15564704),vec4(-0.0171687,0.045623653,-0.13477723,-0.061787024)) * bufB[5] + mat4(vec4(0.13401124,-0.052925315,-0.087464556,0.095936194),vec4(-0.07374087,-0.19409259,0.34158143,0.09089423),vec4(0.06728317,0.065654695,-0.34535548,-0.1823414),vec4(0.06276605,-0.033041805,0.29920727,0.091177605)) * bufB[6] + mat4(vec4(-0.2727208,0.027072998,0.031346347,0.022360967),vec4(0.35356668,0.20901464,-0.21349494,0.10467262),vec4(-0.19059195,-0.11251398,0.00851433,0.005591197),vec4(-0.084418386,-0.22036852,-0.4548702,-0.19220512)) * bufB[7];\nbufA[3] = vec4(0.069509305,0.31582183,0.33533958,0.304985) + mat4(vec4(-0.02480296,0.15718211,-0.061188288,-0.07114256),vec4(-0.21511686,0.10219339,-0.16238533,0.17902279),vec4(-0.012382321,-0.34754428,0.075849175,-0.2011396),vec4(-0.075715266,0.24595216,-0.11680812,0.13823062)) * bufB[0] + mat4(vec4(0.22110648,0.093351156,0.2616521,-0.12971888),vec4(0.045668047,-0.21838461,-0.24023193,-0.0066676415),vec4(0.0350389,0.05457951,0.29501408,-0.11585128),vec4(0.18122466,0.0823527,-0.43865228,0.21222572)) * bufB[1] + mat4(vec4(-0.28852764,-0.11113448,-0.22400144,0.1555303),vec4(-0.120302685,-0.09830451,0.006569049,0.2827441),vec4(0.03446509,0.4135323,0.15242055,-0.04074156),vec4(0.23495774,-0.24745706,0.0946473,-0.074963056)) * bufB[2] + mat4(vec4(0.15929519,-0.3817086,0.17790721,0.011152829),vec4(0.5084718,-0.036623754,0.18804877,0.064675696),vec4(-0.18237728,-0.22069564,0.027204528,-0.08214404),vec4(-0.035066437,0.047515217,-0.027566526,-0.22231162)) * bufB[3] + mat4(vec4(0.28541937,-0.2543674,0.11420045,0.246093),vec4(0.13481568,0.083907366,0.2168991,-0.33952457),vec4(-0.08562641,-0.25756115,-0.0058270367,0.0158011),vec4(0.26175374,0.26523116,0.14959674,-0.03144314)) * bufB[4] + mat4(vec4(0.00033605826,0.11486544,0.1322877,0.2621999),vec4(0.27027193,-0.04612902,0.17881127,-0.25578612),vec4(-0.2744572,-0.23680414,0.28677416,0.40327176),vec4(0.016721943,0.147972,-0.018523514,0.10771087)) * bufB[5] + mat4(vec4(7.86882e-05,-0.212311,0.030163426,-0.076934025),vec4(0.29571244,-0.14786837,0.13568269,-0.47592553),vec4(-0.27341366,0.38238195,0.0039461385,-0.42560455),vec4(-0.07767283,0.47623473,0.25753027,0.009698251)) * bufB[6] + mat4(vec4(0.24542785,-0.17173384,-0.2640243,-0.1136215),vec4(-0.16590022,0.020752208,0.29172263,0.4198563),vec4(0.09487733,-0.19190733,0.04115026,-0.1390663),vec4(0.17814036,0.1759538,-0.32797533,0.48078012)) * bufB[7];\ntmp = atan(bufA[0]);\nbufB[0] = tmp/0.67;\nbufB[4] = (tmp*tmp) / 0.6;\ntmp = atan(bufA[1]);\nbufB[1] = tmp/0.67;\nbufB[5] = (tmp*tmp) / 0.6;\ntmp = atan(bufA[2]);\nbufB[2] = tmp/0.67;\nbufB[6] = (tmp*tmp) / 0.6;\ntmp = atan(bufA[3]);\nbufB[3] = tmp/0.67;\nbufB[7] = (tmp*tmp) / 0.6;\nbufA[0] = vec4(0.020496107637882233,0.01779508963227272,-0.0544867217540741,0.0) + mat4(vec4(-0.018649877980351448,-0.07664527744054794,-0.1139489933848381,0.0),vec4(0.012778076343238354,0.02614169754087925,0.049445345997810364,0.0),vec4(-0.19020122289657593,-0.15553788840770721,-0.0609007366001606,0.0),vec4(-0.04195922240614891,0.14305360615253448,0.2535417377948761,0.0)) * bufB[0] + mat4(vec4(0.3146887421607971,0.2342713177204132,0.1570543795824051,0.0),vec4(-0.17464692890644073,-0.09207716584205627,-0.04324442148208618,0.0),vec4(-0.02154507488012314,-0.00878843478858471,-0.22196997702121735,0.0),vec4(0.012726368382573128,0.22967487573623657,0.1308547556400299,0.0)) * bufB[1] + mat4(vec4(-0.005894636735320091,-0.16297097504138947,-0.1726302057504654,0.0),vec4(0.0007388025405816734,-0.07306940108537674,-0.07719917595386505,0.0),vec4(0.19719532132148743,0.12092392891645432,0.027950113639235497,0.0),vec4(0.012447708286345005,0.07253675907850266,0.13110420107841492,0.0)) * bufB[2] + mat4(vec4(0.043200116604566574,0.07268501073122025,-0.056749552488327026,0.0),vec4(-0.016595734283328056,0.004572335164994001,0.043812040239572525,0.0),vec4(0.03244176506996155,0.007915206253528595,0.020024597644805908,0.0),vec4(-0.22307202219963074,-0.14736247062683105,-0.11852521449327469,0.0)) * bufB[3] + mat4(vec4(0.025387460365891457,0.029115239158272743,-0.09914715588092804,0.0),vec4(0.017439909279346466,0.005680975969880819,-0.03400564566254616,0.0),vec4(0.04357798397541046,0.08460211008787155,0.0421084426343441,0.0),vec4(-0.14951260387897491,-0.026618964970111847,0.21306204795837402,0.0)) * bufB[4] + mat4(vec4(0.15191926062107086,0.08239474892616272,0.15955404937267303,0.0),vec4(0.11888688057661057,0.07534586638212204,0.06615284830331802,0.0),vec4(-0.005204495508223772,-0.11590441316366196,-0.1620001643896103,0.0),vec4(-0.26605406403541565,-0.06252120435237885,0.16158828139305115,0.0)) * bufB[5] + mat4(vec4(-0.055318642407655716,0.04303671419620514,0.055017873644828796,0.0),vec4(-0.0005682659102603793,0.0314733050763607,-0.05514111369848251,0.0),vec4(0.123996801674366,0.12053263932466507,0.08811386674642563,0.0),vec4(-0.030289972200989723,-0.06495193392038345,-0.034646324813365936,0.0)) * bufB[6] + mat4(vec4(0.03126890957355499,0.013291697949171066,-0.048152774572372437,0.0),vec4(-0.0103741604834795,-0.016886141151189804,-0.08969379961490631,0.0),vec4(0.01324724406003952,-0.03676807880401611,-0.07155090570449829,0.0),vec4(0.15610021352767944,0.12649942934513092,0.12370672076940536,0.0)) * bufB[7];\nreturn vec4((1. / (1. + exp(-bufA[0]))).xyz, 1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 mouseNorm = (iMouse.xy / iResolution.xy) - vec2(0.5, 0.5);\n\n\n    uv.x *= iResolution.x / iResolution.y;\n    uv.x -= ((iResolution.x / iResolution.y) - 1.) /2.;\n\n\n    // Shifted to the form expected by the CPPN\n    uv = vec2(1., -1.) * 2. * (uv - vec2(0.5, 0.5));\n    // Output to screen\n    fragColor = cppn_fn(uv, sin(iTime), sin(2.*iTime), sin(3.*iTime), sin(4.*iTime));\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3djXWG.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[69, 69, 144, 144, 74341], [74343, 74343, 74400, 74450, 74874]], "test": "timeout"}
{"id": "3dSSWc", "name": "volcano", "author": "leon21062000", "description": "aaa", "tags": ["aa"], "likes": 1, "viewed": 118, "published": "Public", "date": "1555033626", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// \"ShaderToy Tutorial - Ray Marching Primitives\" \n// by Martijn Steinrucken aka BigWings/CountFrolic - 2018\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n//\n// This shader is part of a tutorial on YouTube\n// https://youtu.be/Ff0jJyyiVyw\n\n#define MAX_STEPS 15\n#define MAX_DIST 15.\n#define SURF_DIST .001\n\n\nfloat time;\n\n//-----------------------------------------------------------------------------\nfloat hash( float n )\n{\n    return fract(sin(n)*43758.5453);\n}\n\n//-----------------------------------------------------------------------------\nfloat noise( in vec2 x )\n{\n    vec2 p = floor(x);\n    vec2 f = fract(x);\n\n    f = f*f*(3.0-2.0*f);\n\n    float n = p.x + p.y*57.0;\n\n    float res = mix(mix( hash(n+  0.0), hash(n+  1.0),f.x),\n                    mix( hash(n+ 57.0), hash(n+ 58.0),f.x),f.y);\n\n    return res;\n}\n\n//-----------------------------------------------------------------------------\nfloat SmokeParticle(vec2 loc, vec2 pos, float size, float rnd)\n{\n\tloc = loc-pos;\n\tfloat d = dot(loc, loc)/size;\n\t// Outside the circle? No influence...\n\tif (d > 1.0) return 0.0;\n\n\t// Rotate the particles...\n\tfloat r= time*rnd*1.85;\n\tfloat si = sin(r);\n\tfloat co = cos(r);\n\t// Grab the rotated noise decreasing resolution due to Y position.\n\t// Also used 'rnd' as an additional noise changer.\n\td = noise(hash(rnd*828.0)*83.1+mat2(co, si, -si, co)*loc.xy*2./(pos.y*.16)) * pow((1.-d), 3.)*.7;\n\treturn d;\n}\n\n//-----------------------------------------------------------------------------\nfloat RockParticle(vec2 loc, vec2 pos, float size, float rnd)\n{\n\tloc = loc-pos;\n\tfloat d = dot(loc, loc)/size;\n\t// Outside the circle? No influence...\n\tif (d > 1.0) return 0.0;\n\tfloat r= time*1.5 * (rnd);\n\tfloat si = sin(r);\n\tfloat co = cos(r);\n\td = noise((rnd*38.0)*83.1+mat2(co, si, -si, co)*loc*143.0) * pow(1.0-d, 15.25);\n\treturn pow(d, 2.)*5.;\n\t\n}\n\n\n//Cone\nfloat sdCone(in vec3 p, in vec3 c) {\n    vec2 q = vec2( length(p.xz), p.y );\n    float d1 = -q.y-c.z;\n    float d2 = max( dot(q,c.xy), q.y);\n    \n    return length(max(vec2(d1,d2),0.5)) + min(max(d1,d2), 0.);\n}\n\n\n\nfloat GetDist(vec3 p) {\t \t\n    float planeDist = p.y;\n\n    float sc = sdCone(p-vec3(-0.75,2.0, 5), vec3(3.0));\n    \n    float d = min(sc, planeDist);\n    \n    return d;\n}\n\nfloat RayMarch(vec3 ro, vec3 rd) {\n\tfloat dO=0.;\n    for(int i=0; i<MAX_STEPS; i++) {\n    \tvec3 p = ro + rd*dO;\n        float dS = GetDist(p);\n        dO += dS;\n        if(dO>MAX_DIST || dS<SURF_DIST) break;\n    }\n    \n    return dO;\n}\n\nvec3 GetNormal(vec3 p) {\n\tfloat d = GetDist(p);\n    vec2 e = vec2(0.3, 0.);\n    vec3 n = d - vec3(GetDist(p-e.xyy), GetDist(p-e.yxy), GetDist(p-e.yyx));\n    \n    return normalize(n);\n}\n\nfloat GetLight(vec3 p) {\n    vec3 lightPos = vec3(0, 5, 6);\n    \n    vec3 l = normalize(lightPos-p);\n    vec3 n = GetNormal(p);\n    \n    float dif = clamp(dot(n, l), 0., 1.);\n    float d = RayMarch(p+n*SURF_DIST*2., l);\n    if(d<length(lightPos-p)) dif *= .1;\n    \n    return dif;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    time = (iTime+1.);\n   vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\t //vec2 uv = ((fragCoord.xy/iResolution.xy)) * 2.0- 1.0;\n    vec3 col = vec3(0);\n\n    \n    vec3 ro = vec3(0, 2, 0);\n    vec3 rd = normalize(vec3(uv.x-.15, uv.y-.2, 1));\n\n    float d = RayMarch(ro, rd);\n    \n    vec3 p = ro + rd * d;\n    \n    float dif = GetLight(p);\n    vec3 texcolor = texture(iChannel0, p.xy + p.xz).rgb;\n    col = vec3(dif) + texcolor;\n\n    \n    \n    for (float i = 0.0; i < 40.0; i+=1.0)\n\t{\n\t\tfloat t = time*1.3+i*(2.+hash(i*-1239.)*2.0);\n\t\tfloat sm = mod(t, 9.3)*.8;\n\t\tfloat rnd = floor(t / 9.3);\n\t\tvec2 pos = vec2(0.0, sm) *.5;\n\t\tpos.x += (hash(i*33.0+rnd)-.5)*.2 * sm*2.13;\n\t\t// Mechanics... a butchered d = vt + (1/2)at^2    ;)\n\t\tpos.y += (.1 - (.075+hash(i*30.0+rnd*36.7)*.15)*(sm*sm)*.8);\n\t\tfloat d = RockParticle(pos, uv, .01*hash(i*1332.23)+.001, (hash(-i*42.13*rnd)-.5)*15.0);\n\t\tif (d <= 0.0) continue;\n\t\tfloat c = max(.3+abs(hash(i*11340.0))*.8+(1.0-sm*.5), 0.0);\n\t\tcol = mix(col, vec3(c,c*.2, 0.0), min(d, 1.));\n\t}\n\n\t// Loop through smoke particles...\n\tfor (float i = 0.0; i < 120.0; i+=1.0)\n\t{\n\t\t// Lots of magic numbers? Yerp....\n\t\tfloat t=  time+i*(2.+hash(i*-1239.)*2.0);\n\t\tfloat sm = mod(t, 8.6) *.5;\n\t\tfloat rnd = floor(t / 8.6);\n\n\t\tvec2 pos = vec2(0.0, sm) *.5;\n\t\tpos.x += (hash(i)-.5)*.2 * uv.y*5.13;\n\t\tfloat d = SmokeParticle(pos, uv, .03*hash(i*1332.23+rnd)+.001+sm*0.03, hash(i*rnd*2242.13)-0.5);\n\t\tif (d <= 0.0) continue;\n\t\td = d* max((3.0-(hash(i*1127.0)*1.5) - sm*.63), 0.0);\n\t\tfloat c = abs(hash(i*4.4));\n\t\t// Black/rusty smoke...\n\t\tcol= mix(col, vec3(c*.3+.05, c*.3, c*.25), min(d, 1.0));\n\t\t// Lava gush...\n\t\tcol = mix(col, vec3(.52, .25, 0.0), max((d-1.05)*8.0, 0.0));\n\t}\n\tuv = ((fragCoord.xy/iResolution.xy));\n    //col *= pow( 45.0*uv.x*uv.y*(1.0-uv.x)*(1.0-uv.y), .08 );\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": "4dX3Rn", "previewfilepath": "/media/ap/bd6464771e47eed832c5eb2cd85cdc0bfc697786b903bfd30f890f9d4fc36657.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/bd6464771e47eed832c5eb2cd85cdc0bfc697786b903bfd30f890f9d4fc36657.jpg", "ctype": "texture"}, {"id": "4sf3Rn", "previewfilepath": "/media/ap/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3dSSWc.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[360, 440, 463, 463, 502], [504, 584, 610, 610, 858], [860, 940, 1004, 1004, 1443], [1445, 1525, 1588, 1588, 1877], [1880, 1887, 1923, 1923, 2097], [2101, 2101, 2124, 2124, 2271], [2273, 2273, 2307, 2307, 2508], [2510, 2510, 2534, 2534, 2694], [2696, 2696, 2720, 2720, 2978], [2980, 2980, 3037, 3037, 4880]], "test": "error"}
{"id": "3dSXRy", "name": "Thick glass", "author": "OliverSchaff", "description": "Branch of https://www.shadertoy.com/view/3dBSRG\nTrying to add fake refraction, in order to make the glass look thicker. ", "tags": ["glass"], "likes": 5, "viewed": 246, "published": "Public", "date": "1554149353", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Based on a shader by Shane\n// https://www.shadertoy.com/view/ll2SRy\n// almost all the code comes from his shader. It's a very good resource!\n\n#define PI 3.14159265359\n#define grad_step 0.01\n#define time iTime+2.31\n\n// Spectrum colour palette\n// IQ https://www.shadertoy.com/view/ll2GD3\nvec3 pal( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d ) {\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\nvec3 spectrum(float n) {\n    //return pal( n, vec3(0.5,0.5,0.5),vec3(0.5,0.5,0.5),vec3(1.0,1.0,1.0),vec3(0.0,0.33,0.67) );\n    //return pal( n, vec3(0.5,0.5,0.5),vec3(0.5,0.0,0.5),vec3(1.0,1.0,1.0),vec3(0.2,0.33,0.67) );\n    return pal( n, vec3(0.4,0.9,0.7),vec3(0.9,0.2,0.4),vec3(1.0,1.0,1.0),vec3(0.3,0.4,0.8) );\n\n}\n\n// iq's distance functions\nfloat sdSphere( vec3 p, float s )\n{\n  return length(p)-s;\n}\n\nfloat opOnion( in float sdf, in float thickness )\n{\n    return abs(sdf)-thickness;\n}\n\nfloat sdUnion_s( float a, float b, float k ) {\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\nvec3 carToPol(vec3 p) {\n    float r = length(p);\n    float the = acos(p.z/r);\n    float phi = atan(p.y,p.x);\n    return vec3(r,the,phi);\n}\n\n// 2D rotation : pitch, yaw\nmat3 rotationXY( vec2 angle ) {\n\tvec2 c = cos( angle );\n\tvec2 s = sin( angle );\n\t\n\treturn mat3(\n\t\tc.y      ,  0.0, -s.y,\n\t\ts.y * s.x,  c.x,  c.y * s.x,\n\t\ts.y * c.x, -s.x,  c.y * c.x\n\t);\n}\n\n\nfloat map( vec3 pos ){\n    \n    \n    \n    vec3 p2 = vec3(1.0*cos(-0.3*time),1.4*sin(time)*cos(-0.4*time),1.7*sin(time)*sin(-0.3*time));\n    float d2 = sdSphere( pos-p2, 0.4);\n    vec3 p3 = vec3(1.4*sin(0.3*time),0.2,-1.6*sin(0.3*time+0.3));\n    float d3 = sdSphere( pos-p3, 0.25);\n    vec3 p4 = vec3(0);\n    float d4 = sdSphere( pos-p4, 0.25);\n    float d00 = sdUnion_s(d2,d3,0.2);\n    float d0 = sdUnion_s(d00,d4,0.2);\n\n    vec3 pol = carToPol(pos);\n    \n    float d1 = sdSphere( pos, 1.0 );\n    float wave = 0.08*sin(15.*(pol.y+PI));\n    d1 = opOnion(d1+wave, 0.001);\n    \n    return sdUnion_s(d1,d0,0.3);\n    \n}\n\n// get gradient in the world\nvec3 gradient( vec3 pos ) {\n\tconst vec3 dx = vec3( grad_step, 0.0, 0.0 );\n\tconst vec3 dy = vec3( 0.0, grad_step, 0.0 );\n\tconst vec3 dz = vec3( 0.0, 0.0, grad_step );\n\treturn normalize (\n\t\tvec3(\n\t\t\tmap( pos + dx ) - map( pos - dx ),\n\t\t\tmap( pos + dy ) - map( pos - dy ),\n\t\t\tmap( pos + dz ) - map( pos - dz )\t\t\t\n\t\t)\n\t);\n}\n\nvec3 selfColor(vec3 pos) {\n    vec3 pol = carToPol(pos);\n    return spectrum(1.0*pol.z/PI/2.0+0.5*pol.y/PI);\n}\n\nmat3 calcLookAtMatrix( in vec3 ro, in vec3 ta, in float roll )\n{\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(sin(roll),cos(roll),0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n    return mat3( uu, vv, ww );\n}\n\n/*\nfloat rCoeff(in vec3 p, in vec3 rd){\n    vec3 g = gradient(p);\n    g = rotationXY(vec2(2.0,1.0))*g;\n    float refl = 1.0-dot(g,rd);\n    return refl;\n}\n*/\n\nvoid mainImage( out vec4 fragColor, vec2 fragCoord ) {\n    \n    vec2 p = (-iResolution.xy + 2.0*fragCoord.xy)/iResolution.y;\n//    vec3 ro = vec3( -5.0*cos(0.2*iTime+0.0), 0.0, 5.0*sin(0.2*iTime+0.0));\n    vec3 ro = vec3( 0.0, 5.0*cos(0.3*time), 5.0*sin(0.3*time));\n    vec3 ta = vec3( 0. , 0. , 0. );\n    \n    float aa = 1.0/min(iResolution.y,iResolution.x);\n    \n    // camera matrix\n    mat3 camMat = calcLookAtMatrix( ro, ta, 1.5);  // 0.0 is the camera roll\n    \n\t// create view ray\n\tvec3 rd = normalize( camMat * vec3(p.xy, 3.0) ); // 3.0 is the lens length\n    \n    // rotate camera with mouse\n\tmat3 rot = rotationXY( ( iMouse.xy - iResolution.xy * 0.5 ).yx * vec2( 0.01, -0.01 ) );\n\trd = rot * rd;\n\tro = rot * ro;\n    vec3 col = vec3(1), sp;\n    \n\t// Ray distance, bail out layer number, surface distance and normalized accumulated distance.\n\tfloat t=0., layers=0., d, aD;\n    \n    // Surface distance threshold. Smaller numbers give a sharper object. Antialiased with aa\n    float thD = .4*sqrt(aa); \n    \n    // Only a few iterations seemed to be enough. Obviously, more looks better, but is slower.\n\tfor(int i=0; i<100; i++)\t{\n        \n        // Break conditions. Anything that can help you bail early usually increases frame rate.\n        if(layers>10. || col.x<0. || t>8.) break;\n        \n        // Current ray postion\n        sp = ro + rd*t;\n\t\t\n        d = map(sp); // Distance to nearest point in the cube field.\n        \n        // If we get within a certain distance of the surface, accumulate some surface values.\n        // Values further away have less influence on the total.\n        //\n        // aD - Accumulated distance. I interpolated aD on a whim (see below), because it seemed \n        // to look nicer.\n        //\n        // 1/.(1. + t*t*.25) - Basic distance attenuation. Feel free to substitute your own.\n        \n         // Normalized distance from the surface threshold value to our current isosurface value.\n        aD = (thD-abs(d))/thD;\n        \n        // If we're within the surface threshold, accumulate some color.\n        // Two \"if\" statements in a shader loop makes me nervous. I don't suspect there'll be any\n        // problems, but if there are, let us know.\n        if(aD>0.) { \n            // Smoothly interpolate the accumulated surface distance value, then apply some\n            // basic falloff (fog, if you prefer) using the camera to surface distance, \"t.\"\n            // selfColor is the color of the object at the point sp\n            vec3 sc = selfColor(sp);\n            \n            vec3 g = gradient(sp);\n            \n            // reflection value based omn the gradient\n\t\t    vec3 rg = rotationXY(vec2(1.5,2.5))*g;\n\t\t    float refl = 1.0-dot(rg,rd);\n\t\t\trefl = pow(exp(-3.0*refl),3.0);\n            \n            //float refl = 0.1*pow(exp(-4.0*rCoeff(sp,rd)),2.0);\n            col -= sc*(aD*aD*(3. - 2.*aD)/(1. + t*t*1.75)*5.0);\n            col += 0.15*refl;\n            layers++;\n            \n            // fake refraction\n            // bend the ray by adding some of the gradient\n            // this makes the glass look thicker\n            rd += 0.5*aD*aD*aD*g*aa;\n        }\n\n\t\t\n        // Kind of weird the way this works. I think not allowing the ray to hone in properly is\n        // the very thing that gives an even spread of values. The figures are based on a bit of \n        // knowledge versus trial and error. If you have a faster computer, feel free to tweak\n        // them a bit.\n        t += max(abs(d)*.5, thD*0.8); \n\t}\n    \n    // I'm virtually positive \"col\" doesn't drop below zero, but just to be safe...\n    col = max(col, 0.);\n    \n\tfragColor = vec4(clamp(col, 0., 1.), 1);\n }\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3dSXRy.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[218, 289, 357, 357, 400], [402, 402, 426, 622, 719], [721, 748, 783, 783, 807], [809, 809, 860, 860, 893], [895, 895, 941, 941, 1034], [1036, 1036, 1059, 1059, 1174], [1176, 1204, 1235, 1235, 1391], [1394, 1394, 1416, 1416, 2008], [2010, 2039, 2066, 2066, 2358], [2360, 2360, 2386, 2386, 2470], [2472, 2472, 2536, 2536, 2714], [2874, 2874, 2928, 2928, 6538]], "test": "ok"}
{"id": "3dSXWt", "name": "Starfield sim v2.0", "author": "alexxxor", "description": "Everyone's favourite windows 3.1 screensaver with a bit of polish", "tags": ["stars"], "likes": 7, "viewed": 357, "published": "Public", "date": "1555224063", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// divisions of grid\nconst float repeats = 30.;\n\n// number of layers\nconst float layers = 21.;\n\n// star colours\nconst vec3 blue = vec3(51.,64.,195.)/255.;\nconst vec3 cyan = vec3(117.,250.,254.)/255.;\nconst vec3 white = vec3(255.,255.,255.)/255.;\nconst vec3 yellow = vec3(251.,245.,44.)/255.;\nconst vec3 red = vec3(247,2.,20.)/255.;\n\n// spectrum function\nvec3 spectrum(vec2 pos){\n    pos.x *= 4.;\n    vec3 outCol = vec3(0);\n    if( pos.x > 0.){\n        outCol = mix(blue, cyan, fract(pos.x));\n    }\n    if( pos.x > 1.){\n        outCol = mix(cyan, white, fract(pos.x));\n    }\n    if( pos.x > 2.){\n        outCol = mix(white, yellow, fract(pos.x));\n    }\n    if( pos.x > 3.){\n        outCol = mix(yellow, red, fract(pos.x));\n    }\n    \n    return 1.-(pos.y * (1.-outCol));\n}\n\nfloat N21(vec2 p){\n    p = fract(p*vec2(233.34, 851.73));\n    p+= dot(p, p+23.45);\n    return fract(p.x*p.y);\n}\n\nvec2 N22 (vec2 p){\n\tfloat n = N21(p);\n    return vec2 (n, N21(p+n));\n}\n\nmat2 scale(vec2 _scale){\n    return mat2(_scale.x,0.0,\n                0.0,_scale.y);\n}\n\n// 2D Noise based on Morgan McGuire @morgan3d\n// https://www.shadertoy.com/view/4dS3Wd\nfloat noise (in vec2 st) {\n    vec2 i = floor(st);\n    vec2 f = fract(st);\n\n    // Four corners in 2D of a tile\n    float a = N21(i);\n    float b = N21(i + vec2(1.0, 0.0));\n    float c = N21(i + vec2(0.0, 1.0));\n    float d = N21(i + vec2(1.0, 1.0));\n\n    // Smooth Interpolation\n\n    // Cubic Hermine Curve.  Same as SmoothStep()\n    vec2 u = f*f*(3.0-2.0*f);\n\n    // Mix 4 coorners percentages\n    return mix(a, b, u.x) +\n            (c - a)* u.y * (1.0 - u.x) +\n            (d - b) * u.x * u.y;\n}\n\nfloat perlin2(vec2 uv, int octaves, float pscale){\n    float col = 1.;\n    float initScale = 4.;  \n    for ( int l; l < octaves; l++){\n        float val = noise(uv*initScale);\n        if (col <= 0.01){\n            col = 0.;\n            break;\n        }\n        val -= 0.01;\n        val *= 0.5;\n        col *= val;\n        initScale *= pscale;\n    }\n \treturn col;\n}\n\nvec3 stars(vec2 uv, float offset){\n    \n    float timeScale = -(iTime + offset) / layers;\n    \n    float trans = fract(timeScale);\n    \n    float newRnd = floor(timeScale);\n    \n    vec3 col = vec3(0.);\n   \n    \n    // translate uv then scale for center\n    uv -= vec2(0.5);\n    uv = scale( vec2(trans) ) * uv;\n    uv += vec2(0.5);\n    \n    // create square aspect ratio\n    uv.x *= iResolution.x / iResolution.y;\n    \n    // add nebula colours\n    float colR = N21(vec2(offset+newRnd));\n    float colB = N21(vec2(offset+newRnd*123.));\n    \n    // generate perlin noise nebula on every third layer\n    if (mod(offset,3.) == 0.){\n    \tfloat perl = perlin2(uv+offset+newRnd,3,2.);\n    \tcol += vec3(perl*colR,perl*0.1,perl*colB);\n    }\n    \n    // create boxes\n    uv *= repeats;\n    \n    // get position\n    vec2 ipos = floor(uv);\n    \n    // return uv as 0 to 1\n    uv = fract(uv);\n    \n    // calculate random xy and size\n    vec2 rndXY = N22(newRnd + ipos*(offset+1.))*0.9+0.05;\n    float rndSize = N21(ipos)*100.+200.;\n    \n    \n    vec2 j = (rndXY - uv)*rndSize;\n    float sparkle = 1./dot(j,j);\n    \n    col += spectrum(fract(rndXY*newRnd*ipos)) * vec3(sparkle);\n    \n    \n\t// visualize layers\n    /*if ((uv.x > 9. || uv.y > 0.99) && ipos.y == 8.){\n        col += vec3(1.,0.,0.)*smoothstep(1.,0.5,trans);\n    }\n    if (mod(offset,3.) == 0.){\n    \tif (uv.x > 0.99 || uv.y > 0.99){\n        \tcol += vec3(1.,0.,0.)*smoothstep(0.2,0.1,trans);\n    \t}\n    }*/\n    \n   \tcol *= smoothstep(1.,0.8,trans);\t\n    col *= smoothstep(0.,0.1,trans);\n    return col;\n       \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    vec3 col = vec3(0.);\n\t\n    for (float i = 0.; i < layers; i++ ){\n    \tcol += stars(uv, i);\n    }\n\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3dSXWt.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[333, 354, 378, 378, 771], [773, 773, 791, 791, 884], [886, 886, 904, 904, 956], [958, 958, 982, 982, 1045], [1047, 1134, 1160, 1160, 1633], [1635, 1635, 1685, 1685, 1999], [2001, 2001, 2035, 2035, 3563], [3565, 3565, 3622, 3672, 3877]], "test": "ok"}
{"id": "3ll3Wr", "name": "Menger Journey (With Music)", "author": "Yusef28", "description": "menger Sponge, \n\nOther Music That Goes well with this:\nProtagonist - Imperia Of Ash\nPoint to Point - Animals as Leaders (The original Version of this song!)", "tags": ["fractal", "menger", "sponge"], "likes": 9, "viewed": 709, "published": "Public", "date": "1556081074", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n\nvec2 rot(vec2 uv,float a){\n\treturn vec2(uv.x*cos(a)-uv.y*sin(a),uv.y*cos(a)+uv.x*sin(a));\n}\n\nmat2 rot(float a)\n{\n    \n float si = sin(a);\n    float cs = cos(a);\n    \n    mat2 mat= mat2(cs, -si, si, cs);\n    return mat;\n}\n\nvec2 random2(vec2 st){\n    st = vec2( dot(st,vec2(127.1,311.7)),\n              dot(st,vec2(269.5,183.3)) );\n    return -1.0 + 2.0*fract(sin(st)*43758.5453123);\n}\n\n// Value Noise by Inigo Quilez - iq/2013\n// https://www.shadertoy.com/view/lsf3WH\nfloat oldnoise(vec2 st) {\n    vec2 i = floor(st);\n    vec2 f = fract(st);\n\n    vec2 u = f*f*(3.0-2.0*f);\n\n    return mix( mix( dot( random2(i + vec2(0.0,0.0) ), f - vec2(0.0,0.0) ), \n                     dot( random2(i + vec2(1.0,0.0) ), f - vec2(1.0,0.0) ), u.x),\n                mix( dot( random2(i + vec2(0.0,1.0) ), f - vec2(0.0,1.0) ), \n                     dot( random2(i + vec2(1.0,1.0) ), f - vec2(1.0,1.0) ), u.x), u.y);\n}\n\nfloat noise( in vec2 x )\n{\n    vec2 p = floor(x);\n    vec2 f = fract(x);\n\tvec2 uv = p.xy + f.xy*f.xy*(3.0-2.0*f.xy);\n\treturn texture( iChannel0, (uv+118.4)/200., -100.0 ).y-0.4;\n}\n\n\nmat2 mat = mat2(.944, -.640, 1.124, 1.076);\n\nfloat oldfbm(vec2 st)\n{\n    float f = noise(st)*0.5; st*=2.02*mat;\n    f += noise(st)*0.25; st*=2.04*mat;\n    f += noise(st)*0.125; st*=2.03*mat;\n    f += noise(st)*0.06125; st*=2.03*mat;\n    \n    return f;\n}\n\n\nfloat fbm(vec2 p)\n{\n    \n float f;\n    \n    f = noise(p)*1.; p*=2.01;\n    f += noise(p)*.5; p*=2.04;\n    f += noise(p)*.25; p*=2.03;\n   // f += noise(p)*.125; p*=2.02;\n    //f += noise(p)*.06125; p*=2.012;\n    \n    return f;\n    \n}\n\nvec3 pattern(vec2 p)\n{\n vec2 lp = p;\n    vec2 id = p*1.;//5 because 10 mod 2\n     id = floor(random2(floor(id)+1.));\n    \n   \n    p = mod(p*4.5002, 1.5)-1.;//<-----the 5002 is me manually finding the grid fit\n  //  p.xy*=rot( 3.14159/2.*(floor(id.x)+floor(id.y) ) );\n    float rect = fbm(vec2(p.x+floor(lp.x*5.), p.y+floor(lp.y*5.))/3.)*0.5+0.5;\n    \n    \n    \n    //TEXTURE OPTIONS!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n     //upddate: changed the 5's to 4.5s because mod is now of p*9 and that affects this fbm version.\n    \n    //what I had before (2019)\n //   rect = fbm(vec2(p.x+floor(lp.x*4.5), p.y+floor(lp.y*4.5))/3. + fbm(p*8.))*0.5+0.5; \n    \n   \n    //rect = fbm(vec2(p.x+floor(lp.x*4.5), p.y+floor(lp.y*4.5))*1. + fbm(lp*12.))*0.5+0.5;\n    rect = oldfbm(vec2(p.x+floor(lp.x*100.5), p.y+floor(lp.y*100.5))/3.)*0.5+0.5;\n    //////////////////////////////////////////////////////////////\n    \n    \n    \n    ///make lines for tiles whcih double as indents in the bump mapping\n    \n    ///some machines don't like nagative powers!!!\n   /// rect*=1.0-pow(p.x, 20.);\n   // rect*=1.0-pow(p.y, 20.);\n    \n    rect*=1.0-pow(abs(p.x), 20.);\nrect*=1.0-pow(abs(p.y), 20.);\n    \n\n     p.y+=sin(p.x*1.+cos(p.y*2.+sin(p.y*2.)/1. )/30.)/1.;\n     p = fract(p*2.);\n    //rect = pow(rect, 1./1.02)*3.;\n    float c = rect;\n    //rect *= fbm(lp*6.)*0.5+0.5;\n    vec3 color = vec3(rect);\n        \n    \n    \n    ///COLORING OPTIONS, !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n    color = mix( vec3( c*c, c*c*c, c-0.8), vec3(0.1, 0.4, 0.9)/6., rect)*4.+id.x;\n\n //color = mix( vec3( c*c, c*c*c*c, c+1.2), vec3(0.5, 0.4, 0.9)/1., rect)*0.6+id.x;\n //color =  vec3(c, c*c*c*c, c*c*c*c*c*c*c*c*c*c);\n   //color = 0.5+0.5*cos(vec3(0.850,0.323,0.134)*3.+c+vec3(5.304,2.164,4.124)/6.)*4.;\n\n    color = 0.5+0.6*cos(vec3(0.212,0.337,0.850)*9.9 +c);\n   /// color = 0.5+0.5*cos(vec3(0.212,0.337,0.850)*4.2+ pow(c, 1./3.))*6.;\n   //color = (0.5+0.5*cos(vec3(0.212,0.337,0.850)*1.2 +(1.+pow(c, 1./1.)) )-0.4);\n    \n    \n color /= mix( vec3( c*c, c*c*c, c-0.8), vec3(0.1, 0.4, 0.9)/9., rect)*4.+id.x;\n   \n    \n    \n    \n    return clamp(color, 0.0, 1.0);//need to clamp or else darks go to negative and light wont show up on it. which would be a shame...\n}\nvec3 pattern2(vec2 p)//for bumps\n{\n    \n    vec3 color;\n    \n    vec2 lp = p;\n    vec2 id = p*5.;//5 because 10 mod 2\n     id = floor(random2(floor(id)+04.));\n    \n   \n    p = mod(p*9., 2.)-1.;\n    p.xy*=rot( 3.14159/2.*(floor(id.x)+floor(id.y) ) );\n    float rect = 1.;;\n    \n   //rect*=1.0-pow(p.x, 40.);\n   //rect*=1.0-pow(p.y, 40.);\n\n            \n    rect*=1.0-pow(abs(p.x), 20.);\nrect*=1.0-pow(abs(p.y), 20.);\n        \n        color = clamp(vec3(rect), 0.85, 1.);\n    \n return color;   \n}\nfloat getGrey(vec3 p)\n{\n    return p.x*0.299 + p.y*0.587 + p.z*0.114;\n       }\n\n\nvec3 triPlanar(sampler2D tex, vec3 p, vec3 n)\n{\n    //this thing gets the normal, abs because we only need positive values, \n    //negative ones are going into the surface so not needed?\n    //we get max I guess because I guess if the normal is 0 or too small it's not helpful lol\n    //we get the sum and use it to get the percentage each component contributes to the whole.\n vec3 norm = max(abs(n), 0.0001);\t//I'll keep it simple with just this\n float sum = norm.x+norm.y+norm.z;\n norm = norm/sum;//so now the normal is a weighting factor, each component is  weight out of 100 percent\n   // p/=10.;\n    //I kinda get this. it's doing the scaling here, but it's still hard to visualize \n    //that adding texures of the yz, xz, and xy planes would result it a crisp image.\n    //for example, if the texture was a chess board pattern...hmmm maybe.\n    return vec3(pattern(p.yz*8.)*norm.x + \n                pattern(p.xz*8.)*norm.y +\n                pattern(p.xy*8.)*norm.z ) ;\n    \n}\n\nvec3 triPlanar2(sampler2D tex, vec3 p, vec3 n)\n{\n    //this thing gets the normal, abs because we only need positive values, \n    //negative ones are going into the surface so not needed?\n    //we get max I guess because I guess if the normal is 0 or too small it's not helpful lol\n    //we get the sum and use it to get the percentage each component contributes to the whole.\n vec3 norm = max(abs(n), 0.0001);\t//I'll keep it simple with just this\n float sum = norm.x+norm.y+norm.z;\n norm = norm/sum;//so now the normal is a weighting factor, each component is  weight out of 100 percent\n   // p/=10.;\n    //I kinda get this. it's doing the scaling here, but it's still hard to visualize \n    //that adding texures of the yz, xz, and xy planes would result it a crisp image.\n    //for example, if the texture was a chess board pattern...hmmm maybe.\n    return vec3(pattern2(p.yz*8.)*norm.x + \n                pattern2(p.xz*8.)*norm.y +\n                pattern2(p.xy*8.)*norm.z ) ;\n    \n}\n\nvec3 bumpMap(sampler2D tex, in vec3 p, in vec3 n, float bumpfactor)\n{\n    //ok so I don't understand this technique yet.\n    //I mean I can visualize getting the greyscale values from the texture \n    //at three points around the ref, based on the point and the normal.\n    \n    //usually if you want a gradient you\n    //want to get the difference between the ref and points around it\n    \n    //we do this when we take the normal although in that cause we are \n    //getting distances. Here we imply distance by getting greyscale values.\n    //the resulting gradient then cna be considered a normal because each of\n    //it's components is a basis vector that is the slope between the \n    //the components of the ref and the point representing the change from that point\n    //to a bit away.\n    \n    \n    \n    const vec3 eps = vec3(0.001, 0., 0.);//I use swizzling here, x is eps\n    float ref = getGrey(triPlanar(tex, p, n));//reference value \n    \n    vec3 grad = vec3(getGrey(triPlanar(tex, p - eps, n)) - ref,\n                     //eps.yxz means 0.,0.001, 0. \"swizzling\n                     getGrey(triPlanar(tex, p - eps.yxz, n)) - ref,\n                     getGrey(triPlanar(tex, p - eps.yzx, n)) - ref)/eps.xxx;\n    \n    //so grad is the normal...then he does:\n    grad -= n*dot(grad, n);//takes the dot of the surface normal \n    //and the texture normal (the gradient), so percentage of how similar they are\n    //multplies by the surface normal again so scaling it by that percentage\n    //and subtracting that from the gradient.\n    //so the result is only the portion of the gradient that is not part of n??\n    \n    // and returning the surface normal + that gradient portion plus a bump factor\n    //why???\n    return normalize(n + grad*bumpfactor);\n}\n\n\nfloat sphere(vec3 p, float r)\n{\n    \n return length(p) - r;   \n}\n\nfloat rect(vec3 p, vec3 b)\n{\n    p = abs(p)-b;\n return max(p.x, max(p.y, p.z));\n}\n\nfloat infRect(vec3 p, vec3 b)\n{\n    p = abs(p)-b;\n    float f = max(p.x, p.y);\n return f;   \n}\nfloat plane(vec3 p, vec4 n)\n{\n   // p.y = 1.0-p.y;\n return p.y + n.w;//dot(p, n.xyz) + n.w;   \n}\n\n\nfloat infCyl(vec3 p, float r)\n{\n    \n return length(p.xy)-r;   \n}\n\nfloat cylCross(vec3 p, float r)\n{\n p = abs(p);\n    vec3 f = vec3(max(p.x, p.y), max(p.y, p.z), max(p.z,p.x));\n    return min(length(p.xy), min(length(p.yz), length(p.xz)))-r;\n}\n\nfloat rCross(vec3 p)\n{\n    p = abs(p);\n    vec3 f = vec3(max(p.x, p.y), max(p.y, p.z), max(p.z,p.x));\n    float k = min(f.x, min(f.y, f.z) ) - 1./3.;\n    \n return k;   \n}\n\nfloat repCross(vec3 p)\n{\n    vec3 q = mod(p+1., 2.)-1.;\n    float f = rCross(q);\n    \n/*\n    q = abs(q)-0.05;\nq = abs(q)-0.7;\n\n    \n    f = min(f, rCross(q) );\n*/\n\n    \n    //cool linething use 1 or 2 loops only\n  \nq = abs(q)-0.5;\n\n   q = abs(q)-0.2;q = abs(q)-0.95;q = abs(q)-0.5;q = abs(q)-0.5;\n    q=abs(q)-0.005;\n    f = min(f, cylCross(q,0.101));\n    \n    \n    //2 or three loops\n    \n    /*\nq = abs(q)-0.6;\n    q = abs(q)-0.1;\n    q = abs(q)-0.43;\n    q = abs(q)-0.34;\n    f = min(f, cylCross(q, 0.1) );\n*/\n\n    \n    /*\n   \nq = abs(q)-0.34;\n    //q = abs(q)-0.04;\n    q = abs(q)-0.08;\n    f = min(f, cylCross(q, 0.1) );\n*/\n   /*\n    \n q = abs(q)-0.934;\n    q = abs(q)-0.094;\n    q = abs(q)-0.08;\n    f = min(f, cylCross(q, 0.1) );\n*/\n    \n    \n    // f = cylCross(q, 0.25);\n return f;   \n}\n\nfloat repCylCross(vec3 p)\n{\n    vec3 q = mod(p+1., 2.)-1.;\n    float f =  cylCross(q, 0.05) ;\n return f;   \n}\n\nfloat rcScale(vec3 p, float s)\n{\n    \n return repCross(p*s)/s;\n}\n\n\n\nfloat map(vec3 p)\n   {\n       //p = fract(p);\n     \n      \n    float re = 0.0;\n       float scale = 1.;\n       \n       for(int i=0; i<3 ;i++)\n       {\n        \n        scale*=1.891; //getting a weird shape here\n        re = max(re, -rcScale(p, scale)  );\n        p = abs(p)-0.24;\n       }\n       /* re = max(re, -rcScale(p, scale*2.2)  );\n       //there are a ton of possibilities, which I'm glad shane kind of hinted at\n       \tscale*=17.;//17, 8, 3, even 4\n        re = max(re, -rcScale(p.xyy, scale*3.)  );\n       \n       \n       \tscale*=1.;\n        re = max(re, -rcScale(p.xxy, scale/8.1)  );\n         \n       \tscale*=3.;\n        re = max(re, -rcScale(p, scale/20.)  );*/\n       \n       \n       /*\n         p.xz*=rot(1.9);\n\t\tp.xz = mod(p.xz, .24) - 0.12;\n     p.y/=1.5;\n      \n       re = max(re,  rect(p, vec3(0.1) ));*/\n    return re;//rect(p, vec3(2.5));\n    /*\n    vec3 ss = p;\n    for(int i = 0;i<8;i++)\n    {    \n        p = abs(p)-0.037;\n        p.xz=rot(p.xz,1.6+iTime/3.);\n        //p*=(1.02-float(i)/800.);\n        p = abs(p)-0.3*1.4;;\n        p.xy=rot(p.xy,1.6+iTime/3.);\n        p = abs(p)-0.02*1.4;;\n        p*=1.3;\n        \n        \n    }\n    //p = fract(p/4.)-.5;\n    float  s = rect(p, vec3(0.2));\n    s =  max(s, -sphere(ss, .5));\n    //s = sphere(p, 0.5);\n   //s = min(sphere(p+vec3(0., 1.,.2), 0.2), s);\n    return s;*/\n\n\n\n\n    /*\n \t vec2 pos = vec2(p.xz/5.);//vec2(st.x*5.0, 1./st.y*4.0);\n\tfloat c1 = fbm(pos);\n    \n    float ter = smoothstep(.5,1.95, sin(p.z*24.))*smoothstep(0.5,1.9, sin(p.x*24.));//(1.0-pow(c1, 1.)-0.768);\n    //p.y+=ter;\n   // ter += smoothstep(0.5,1.9,sin(p.x/1.)/1.)+smoothstep(1.,2.,abs(sin(p.x*3.)*1.));\n    //ter +=(smoothstep(.5,1.95, sin(p.z*2.))+smoothstep(0.5,1.9, sin(p.x*2.)));;\n    // ter +=smoothstep(.5,1.95, sin(p.z*4.))+smoothstep(0.5,1.9, sin(p.x*4.));   \n       // ter +=smoothstep(.5, 1.95, 0.5+0.5*sin(p.z/2.)+smoothstep(.5, 1.95, sin(p.z/2.))*1.);//+smoothstep(0.5,1.9, sin(p.x*1.));;\n  float x = p.x/4.;\n    ter += smoothstep(0.0,0.5,fract(x/4.))+smoothstep(0.0,0.5,fract(x/2.));\n    float pl = plane(p, vec4(0., 1., 0., pow(ter, 2.)*8.));\n    \n \tp = mod(p, 1.)-0.5;   \n    return pl;//min(pl, sphere(p, 0.02));//sphere(p, 0.2);*/\n}\n\nfloat trace(vec3 ro, vec3 rd)\n{\n    float eps = 0.001;\n    float dist;\n    float t = 0.0;\n    for(int i = 0;i<96;i++)\n    {\n        dist = map(ro+rd*t);\n    if(dist<eps || t > 120.)\n        break;\n    \n    t +=dist*0.95;\n    }\n    \n    return t;\n\t    \n}\n\n\n//based on shanes reflection tutorial\nfloat rtrace(vec3 ro, vec3 rd)\n{\n    float eps = 0.0001;\n    float dist;\n   \tfloat t = 0.0;\n    \n    for(int i=0; i<48; i++)\n    {\n     dist = map(ro + rd*t);\n        if(dist<eps || t > 120.)\n            break;\n        \n      t += dist;\n        \n    }\n    \n    \n return t;   \n}\nvec2 path(vec3 p)\n{\n    \n float a = sin(p.z*1.)/3. ;\n     float b = cos(p.z)/3.;\n    return vec2(a, b);\n}\n\n\n\nvec3 normal(vec3 sp)\n{///had to adjust the normal cause I was getting these weird lines on edges.\n    vec3 eps = vec3(.0014, 0.0, 0.0);\n    \n    vec3 normal = normalize (vec3( map(sp+eps) - map(sp-eps)\n                       ,map(sp+eps.yxz) - map(sp-eps.yxz)\n                       ,map(sp+eps.yzx) - map(sp-eps.yzx) ));\n    \n    \n return normal;   \n}\n\n//guess who this is from...shane\n// \"I keep a collection of occlusion routines... OK, that sounded really nerdy. :)\n// Anyway, I like this one. I'm assuming it's based on IQ's original.\"\nfloat calculateAO(in vec3 pos, in vec3 nor)\n{\n\tfloat sca = 2.0, occ = 0.0;\n    for( int i=0; i<5; i++ ){\n    \n        float hr = 0.01 + float(i)*0.5/4.0;        \n        float dd = map(nor * hr + pos);\n        occ += (hr - dd)*sca;\n        sca *= 0.7;\n    }\n    return clamp( 1.0 - occ, 0.0, 1.0 );    \n}\n\n//based on shanes lighting function but i added reflections using a cubemap\nvec3 lighting(vec3 sp, vec3 sn, vec3 lp, vec3 rd)\n{\nvec3 color;\n    \n    //some other experiemnts\n    //where the id's are based on cells you don't need to pass the id variable around\n    //you can just recreate it where needed.\n    /*float id = rnd(floor(sp.xz));\n    float id1to3 = floor(id*3.0);\n    float one = step(1., id1to3);\n    float two = step(2., id1to3);\n    float three = step(3., id1to3);///hmmm*/\n    \n    //vec3 tex = texture(iChannel0, sp.xz).xyz*one;\n    sn = bumpMap(iChannel0, sp, sn, 0.0015);\n    vec3 lv = lp - sp;\n    float ldist = max(length(lv), 0.01);\n    vec3 ldir = lv/ldist;\n    \n    float atte = 1.0/(1.0 + 0.002*ldist*ldist );\n    \n    float diff = dot(ldir, sn);\n    float spec = pow(max(dot(reflect(-ldir, sn), -rd), 0.0), 10.);\n    float fres = pow(max(dot(rd, sn) + 1., 0.0), 1.);\n\tfloat ao = calculateAO(sp, sn);\n    \n    vec3 refl = reflect(rd, sn);\n    vec3 refr = refract(rd, sn, 0.7);\n    \n   vec3 color2 = vec3(0.2, 0.5, 0.9);\n    vec3 color3 = vec3(0.0);\n    //getting reflected and refracted color froma cubemap, only refl is used\n   // vec4 reflColor = texture(iChannel1, refl);\n   // vec4 refrColor = texture(iChannel2, refr);\n     \n    //blue vs orage specular, orange all the way.\n    vec3 coolSpec = vec3(.3, 0.5, 0.9);\n    vec3 hotSpec = vec3(0.9,0.5, 0.2);\n   color2 = triPlanar(iChannel0, sp, sn);\n    //+reflColor.xyz*0.2\n    //apply color options and add refl/refr options\n    color = (diff*color2*8. +  spec*coolSpec*9.  )*atte;\n\t\n    \n    //apply ambient occlusion and return.\n return color*ao;   \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    uv=uv*2.0-1.0;\n    uv.x*=iResolution.x/iResolution.y;\n    \n    vec3 lk = vec3(0.,0, 0.+iTime/4.);\n    \n    //lk.xy+=vec2(2.34,.34);//path(lk/4.);//lk.xz*=rot(lk.z);//;\n    vec3 ro = lk + vec3(0., 0., -1.0);\n    vec3 lp = ro + vec3(0, 0., 0.);//lp is ro so no area is too dark\n   \tfloat FOV = .57;\n    \n    vec3 fwd = normalize(lk - ro);\n    vec3 up = vec3(0., -1., 0.0);\n    vec3 rr = normalize(cross(up, fwd));\n    vec3 uu = normalize(cross(rr, fwd));\n    \n    vec3 rd = normalize(vec3(rr*FOV*uv.x + uu*FOV*uv.y + fwd));\n    \n   rd.yz*=rot(iTime/5.);\n    //rd.xz*=rot(iTime/10.);\n    rd.xz*=rot((iTime)/10.);\n    float t = trace(ro, rd);\n    \n     vec3 sp = ro + rd*t;\n    vec3 sn = normal(sp);\n   \t\n    float far = smoothstep(0.0, 1.0, t/7.);\n    \n    //get cube color from cubemap again this time to apply to the sky,\n    //really just so that the reflections on the ground make sense\n    \n  //  vec4 cubeColor = texture(iChannel1, rd);\n    vec3 color = lighting(sp, sn, lp, rd);//mix(stripes(ro+rd*t),vec3(t), far);\n     //reflection trace based on shanes reflection tutorial\n    vec3 refRay = reflect(rd, sn);\n    float rt = rtrace(sp+refRay*0.01, refRay);\n    vec3 rsp = sp + refRay*rt;\n    vec3 rsn = normal(rsp);\n     //\n  // color += lighting(rsp, rsn, lp, refRay)*0.1;\n         //color += clamp(lighting(rsp, rsn, lp, refRay)*0.9, 0.0, 1.);\n   \n    color = mix(color*1.5, vec3(2., 2.5, 3.) ,far);//\n    ///color = mix(color, vec3(0.9, 0.5, 0.2), t);\n  // color = vec3(t*t*t, t*t, t*t*t*t*t*t*t);\n  // color = vec3(t/100.);\n    \n    \n    \n    \n    \n    \n    \n\tfragColor = vec4(color,1.0);\n    \n    \n    \n    \n}", "image_inputs": [{"id": "4dXGRn", "previewfilepath": "/media/ap/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg", "ctype": "texture"}, {"id": "4lXGzS", "previewfilepath": "https://soundcloud.com/vitalification/point-to-point-aal", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0, "src": "https://soundcloud.com/vitalification/point-to-point-aal", "ctype": "musicstream"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3ll3Wr.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[2, 2, 28, 28, 93], [95, 95, 114, 114, 222], [224, 224, 246, 246, 385], [387, 469, 494, 494, 900], [902, 902, 928, 928, 1081], [1129, 1129, 1152, 1152, 1337], [1340, 1340, 1359, 1359, 1571], [1573, 1573, 1595, 1595, 3810], [3811, 3811, 3845, 3845, 4304], [4305, 4305, 4328, 4328, 4383], [4386, 4386, 4433, 4761, 5369], [5371, 5371, 5419, 5747, 6358], [6360, 6360, 6429, 7154, 8130], [8133, 8133, 8164, 8164, 8197], [8199, 8199, 8227, 8227, 8280], [8282, 8282, 8313, 8313, 8376], [8377, 8377, 8406, 8427, 8473], [8476, 8476, 8507, 8507, 8541], [8543, 8543, 8576, 8576, 8719], [8721, 8721, 8743, 8743, 8891], [8893, 8893, 8917, 8917, 9688], [9690, 9690, 9717, 9717, 9799], [9801, 9801, 9833, 9833, 9865], [9869, 9869, 9891, 9914, 12069], [12071, 12071, 12102, 12102, 12324], [12327, 12365, 12397, 12397, 12642], [12643, 12643, 12662, 12662, 12748], [12752, 12752, 12774, 12849, 13104], [13106, 13293, 13338, 13338, 13597], [13599, 13675, 13726, 13726, 15229], [15231, 15231, 15288, 15288, 16954]], "test": "error"}
{"id": "3llGD7", "name": "Fibonacci spiral 3", "author": "FabriceNeyret2", "description": "Dynamic version with no precomputations.\n[url]https://en.wikipedia.org/wiki/Fibonacci_spiral[/url] Box sides = Fibonacci sequence.\nCompare to golden log spiral: [url]https://www.shadertoy.com/view/wtlGD4[/url]", "tags": ["spiral", "fibonacci", "log", "golden"], "likes": 18, "viewed": 840, "published": "Public API", "date": "1556545648", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// zoomable + values display variant of https://shadertoy.com/view/3lf3DM\n\nfloat pInt(vec2,float);                    // display integer\n// #define S(v) min( 1., abs(v)/p  )       // lazy AA\n\nvoid mainImage( out vec4 O, vec2 u )\n{\n    vec2 R = iResolution.xy, U, P,V,B, C = vec2(1,0);\n    float l,r,  _F=0.,F=1.,                // Fibonacci sequence\n          p = exp2(iTime)/R.y;             // pixel size (i.e. 1/scaling)\n    \n    U = p* ( u+u - R );\n \n    O = vec4(1);\n    \n    for (float i=0.; i<3.+ iTime/log(2.); i++) {\n        V = cos( 1.5708 * vec2(i+1.,i) );  // next box direction\n        r = F/2.;                          // box radius & center\n        B = C - r* vec2(V.y+V.x,V.y-V.x);  // vec2(1)*mat2(V.y,V.x,-V.x,V.y);\n        P = abs( B - U );\n        l = max(P.x,P.y) - r;              // SDF to box border\n        if ( l < p/4.) {                   // in box: draw arc and box\n            O = mix(vec4(1,0,0,1), .98+.02*cos( i + vec4(0,23,21,0) ), min(1.,abs(length(C-U)-2.*r)/p/5.) ); // https://www.shadertoy.com/view/ll2cDc\n            O = min(O, abs(l)/p/3. );\n            O.rg -= pInt((U-B)*6./F,F)     // display size = Fibonacci\n                    *( i<36.? 1.: .2 );    // faint when approx\n         // O.rg -= pInt((U-B)*8./p/R.y,F);\n        }\n        C += _F * V;                       // next arc center\n        l=F; F += _F; _F=l;                // Fibonacci sequence\n    }\n}\n\n// --- utils : display integer\n#define C(U,c) U.x<.0||U.x>1.||U.y<0.||U.y>1. ?0.: textureGrad(iChannel3, U/16. + fract( vec2(c, 15-(c)/16) / 16.), dFdx(U/16.),dFdy(U/16.) ).x\nfloat pInt(vec2 p, float n) {\n    float v = 0.; \n    p+=.5; p.x -= .25*floor(log(n)/log(10.));// centering\n    for (int i = int(n); i>0; i/=10, p.x += .5 )\n        v += C(p, 48+ i%10 );\n    return v;\n}", "image_inputs": [{"id": "4dXGzr", "previewfilepath": "/media/ap/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png", "channel": 3, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3llGD7.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[192, 192, 230, 230, 1407], [1584, 1584, 1613, 1613, 1785]], "test": "error"}
{"id": "3llGRH", "name": "Raymarching Beginner", "author": "batman", "description": "My discovery of a basic raymarching setup.", "tags": ["basic"], "likes": 3, "viewed": 103, "published": "Public", "date": "1555637865", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define ITERATIONS 64\n#define MAX_DISTANCE 200.\n#define MIN_DISTANCE .001\n\nfloat sdSphere(vec3 pos, vec3 center, float r) {\n \treturn length(pos-center) - r;\n}\n\nfloat sdFloor(vec3 pos) {\n \treturn pos.y;\n}\n\nfloat sdScene(vec3 pos) {\n \treturn min(sdFloor(pos),sdSphere(pos, vec3(0.,0.5,-3.), .5));\n}\n\nvec3 grad(vec3 pos) {\n \tvec2 e = vec2(0.,0.1);\n    return normalize(vec3(\n        sdScene(pos + e.yxx) - sdScene(pos - e.yxx), \n        sdScene(pos + e.xyx) - sdScene(pos - e.xyx), \n        sdScene(pos + e.xxy) - sdScene(pos - e.xxy)\n    ));\n}\n\nfloat castray(vec3 ro, vec3 rd) {\n    float d = 1.;\n  \tfloat inc;\n    for(int i=0; i< ITERATIONS;i++) {\n        vec3 p = ro + d * rd;\n     \tinc = sdScene(p);\n        d += inc;\n        if(d > MAX_DISTANCE || inc <= MIN_DISTANCE) break;\n    }\n    return d;\n}\n\nfloat getDiffuse(vec3 p, float dist) {\n   vec3 lightPos = vec3(0.+3.*sin(iTime), 4.,-3.+3.*cos(iTime));\n   vec3 lightV = normalize(lightPos - p);\n   vec3 n = grad(p);\n   float d = dot(lightV,n); \n   // shadows\n    float rayToLight = castray(p, lightV);\n    if(rayToLight < length(lightPos-p)) d *=0.1;\n    return d;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord /iResolution.xy;\n    uv -= 0.5;\n    uv.x *= iResolution.x/iResolution.y;\n    vec3 camPos = vec3(0.,.5,0.);\n\tvec3 ro = camPos + vec3(0.,0.,1.);\n    vec3 rd = normalize(camPos + vec3(uv,0.) - ro);\n    float dist = castray(ro, rd);\n    vec3 p = ro + rd * dist;\n    float diff = getDiffuse(p, dist);\n    vec3 shade = diff*vec3(1.0,0.,0.);\n    if(diff>0.) shade += pow(diff,5.)*vec3(0.,1.,0.);\n    vec3 col = shade;\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3llGRH.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[75, 75, 123, 123, 158], [160, 160, 185, 185, 203], [205, 205, 230, 230, 296], [298, 298, 319, 319, 541], [543, 543, 576, 576, 799], [801, 801, 839, 839, 1118], [1121, 1121, 1178, 1228, 1725]], "test": "ok"}
{"id": "3llGRn", "name": "SpinCoaster", "author": "kiyamada96", "description": "can rot mouseInput", "tags": ["ray"], "likes": 4, "viewed": 144, "published": "Public", "date": "1555489148", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec3 hash(vec3 p)\n{ \n    float n = sin(dot(p, vec3(7, 157, 113)));    \n    return fract(vec3(2097152, 262144, 32768)*n); \n}\n\nfloat map(vec3 p)\n{\n    vec3 o = hash(floor(p)) * 0.1; \n    \n    p = fract(p + o) - .5; \n    float r = dot(p, p) - 0.21; \n    p = abs(p); \n    \n    float d = max(p.x, p.y);\n    return d;    \n    \n}\n\nvoid mainImage( out vec4 fragColor, vec2 fragCoord )\n{\n\tvec2 uv = (fragCoord - iResolution.xy*.5 ) / iResolution.y;\n    vec3 rd = normalize(vec3(uv, (1.- dot(uv, uv) * .5) * .5));\n    \n    vec2 mouse = (2.0 * (iMouse.xy / iResolution.xy) - 1.0) * 5.0 + 0.1;\n    vec3 ro = vec3(mouse, iTime * 0.5);\n    \n    vec3 col = vec3(0);\n    vec3 sp = vec3(0);\n\t\n\tfloat cs = cos( iTime * 0.375 ); \n    float si = sin( iTime * 0.375 );\n    \n    rd.xz = mat2(cs, si,-si, cs) * rd.xz;\n    rd.xy = mat2(cs, si,-si, cs) * rd.xy;\n    \t\n    float t= 0.0;\n    float layers= 0.0;\n    float d;\n    float aD;\n    float thD = .055;\n    \n\tfor(int i=0; i < 256; i++)\t\n    {\n        \n        if(layers > 15. || col.x>1. || t > 10.)\n        {\n        \tbreak;\n        }\n        \n        sp = ro + rd * t;\t\t\n        d = map(sp);\n        aD = (thD - abs(d) * 15./16.) / thD;\n        \n        if(aD > 0.)\n        {  \n            col += aD * aD * (3. - 2. * aD) / (1. + t * t * .25) * 0.8;\n           \n        }\n        \n        t += max(abs(d) * .5, thD * 1.);\n        \n    }\n    \n\n\t  fragColor = vec4(clamp(col, 0., 1.0), 1);\n\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3llGRn.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 19, 19, 123], [125, 125, 144, 144, 322], [324, 324, 378, 378, 1422]], "test": "ok"}
{"id": "3llGzH", "name": "Psychedelic Curiosity", "author": "Vovosunt", "description": "Click for a stare.\nAs per usual mashing up functions till they look like something, no optimization.", "tags": ["2d", "eyes"], "likes": 32, "viewed": 905, "published": "Public API", "date": "1555681628", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define thick   0.04\n#define smooth  (16.0 / iResolution.x)\n#define PI      3.1415926535\n#define S(x) smoothstep(-smooth, smooth, x)\n#define SR(x, y) smoothstep(-smooth * y, smooth * y, x)\n#define scalex 5.\n#define scaley 5.\n#define scx (scalex * PI * 2.)\n\n//Palettes by Inigo Quilez http://www.iquilezles.org/www/articles/palettes/palettes.htm\nvec3 pal( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d )\n{\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\nvec3 pal1(in float t){\n    return pal(t, vec3(0.5,0.5,0.5),vec3(0.5,0.5,0.5),vec3(1.0,1.0,1.0),vec3(0.0,0.33,0.67)) ;\n}\n\nfloat rand(vec3 v){\n    return fract(cos(dot(v,vec3(13.46543,67.1132,123.546123)))*43758.5453);\n}\n\nfloat rand(vec2 v){\n    return fract(sin(dot(v,vec2(5.11543,71.3177)))*43758.5453);\n}\n\nfloat rand(float v){\n    return fract(sin(v * 71.3132)*43758.5453);\n}\n\nvec2 rand2(vec2 v){\n    return vec2(\n        fract(sin(dot(v,vec2(5.11543,71.3132)))*43758.5453),\n        fract(sin(dot(v,vec2(7.3113,21.5723)))*31222.1234)\n        );\n}\nvec2 rotate(vec2 st, float angle){\n    float c = cos(angle);\n    float s = sin(angle);\n    return mat2(c, -s, s, c) * st;\n}\nfloat smrand(float v){\n    float vv = floor(v);\n    return mix(rand(vv),rand(vv+1.0),fract(v));\n}\n\nvec3 eye(vec2 fst, vec2 cst, vec2 mouse){\n    float mouseDown = clamp(iMouse.z, 0.0, 1.0);\n    float noise = rand(cst);\n    \n    float nt = iTime*2.0 * (noise + 0.8 ) +noise * 100.0;\n    float fnt = floor(nt);\n    vec2 noise2 = rand2(cst + vec2(fnt));\n    vec2 noise22 = rand2(cst + vec2(fnt + 1.));\n    float pinoise = noise2.x * PI * 2.0;\n    float pinoise2 = noise22.x * PI * 2.0;\n    float move = 1.0 - (cos(fract(nt)*PI)+1.0) /2.0;\n    move = pow(move,4.0);\n    \n    float eyeOpen = (sin(iTime*2.0 + noise * 100.0) + 1.0) / 2.0;\n    eyeOpen = mix(eyeOpen,0.0, mouseDown);\n    eyeOpen = 1.0 - pow(eyeOpen, 3.0);\n    \n    float col = (sin(fst.x) + 1.)/2.0;\n    //col = pow(col,0.9);\n    float col2 = col* eyeOpen + fst.y*2.1 - 0.1;\n    col = col* eyeOpen - fst.y*2.1 - 0.1;\n    float cs1 = min(col - 0.1, col2- 0.1);\n    float cs2 = S(cs1);\n    col = S(min(col, col2));\n    \n    float grad = min(eyeOpen * 1.2, 1.);\n    //float grad = min(1.0 - pow(1.0 -abs(fst.y),10.) + 0.3,1.0);\n    \n    vec2 loc = vec2(fract(fst.x/PI/2.0 + PI*2.0) - 0.53,fst.y*iResolution.y/iResolution.x);\n    \n    vec2 pin2 = mix(vec2(cos(pinoise),sin(pinoise))*((noise2.y +1.0) / 2.0),\n                    vec2(cos(pinoise2),sin(pinoise2))*((noise22.y +1.0) / 2.0),move);\n    pin2 *= 0.25;\n    pin2 =  mix(pin2, mouse, max(mouseDown - 0.05,0.));\n    \n    float lloc = length(loc);\n    float irisn = mix(1.0,mix(noise2.x, noise22.x, move),0.25);\n    float iris = length(loc - pin2 * (0.5 -lloc) );\n    float irisWhite = length(loc - pin2 * (0.2 -lloc) );\n    float irisDark = SR(length(loc - pin2 * (0.4 -lloc) ) - 0.05 * irisn,0.5);\n    float irisShadow = SR(-irisWhite + 0.07,15.);\n    irisWhite = SR(-irisWhite + 0.03,1.4);\n    \n    vec3 irisColor = irisDark *pal1( irisShadow + nt/10.0);\n    irisColor = max(irisColor, irisWhite*0.9);\n    vec3 baseCol = vec3(SR(-lloc+ .25,15.));\n    baseCol = baseCol + 0.25*pal1( baseCol.x + nt/10.0);\n    \n    vec3 finCol = mix(baseCol, irisColor, S(-iris + 0.15));\n    finCol = mix(pal1(noise + nt/10.0) * grad,finCol, cs2);\n    finCol = min(finCol, col);\n    \n    return finCol;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    vec2 st = (fragCoord.xy)/ iResolution.xy;\n    vec2 mouse = (iMouse.xy)/ iResolution.xy;\n    \n    float fsty = fract(st.y * scaley) - 0.5;\n    float fsty2 = fract(st.y * scaley  + 0.5) - 0.5;\n    float csty = floor(st.y * scaley);\n    float csty2 = floor(st.y * scaley + 0.5);\n    float cstx = floor(st.x * scalex);\n    float cstx2 = floor(st.x * scalex + 0.5);\n    vec2 cst = vec2(cstx,csty);\n    vec2 cst2 = vec2(cstx2,csty2 + 1234.);\n    vec2 fst = vec2(st.x * scx - 0.5 * PI, fsty);\n    vec2 fst2 = vec2(st.x * scx + 0.5 * PI, fsty2);\n\n    \n    vec2 m1 = mouse - vec2((cstx + 0.5)/scalex, (csty + 0.5)/scaley);\n    vec2 m2 = mouse - vec2((cstx2 + 0.5)/scalex, (csty2 + 0.5)/scaley);\n    \n    vec3 col = eye(fst, cst, m1);\n    vec3 col2 = eye(fst2, cst2, m2);\n    col = max(col,col2);\n    col += 0.1 * (rand(fragCoord.xy/3.0 + iTime)-0.5);\n    //col -= 0.1 * (rand(fragCoord.xy/3.0 + iTime + 100.0));\n  \n    fragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3llGzH.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[257, 345, 413, 413, 456], [458, 458, 480, 480, 577], [579, 579, 598, 598, 676], [678, 678, 697, 697, 763], [765, 765, 785, 785, 834], [836, 836, 855, 855, 1005], [1006, 1006, 1040, 1040, 1129], [1130, 1130, 1152, 1152, 1227], [1229, 1229, 1270, 1270, 3328], [3330, 3330, 3386, 3386, 4330]], "test": "ok"}
{"id": "3ls3Wr", "name": "Fork: Noise over time, redefined", "author": "endymion", "description": "All credit goes to https://www.shadertoy.com/view/3sXXD4\nThis is just me cleaning up the code while trying to figure out what was going on", "tags": ["noise", "time", "perlin"], "likes": 4, "viewed": 186, "published": "Public", "date": "1556081382", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// All credit goes to https://www.shadertoy.com/view/3sXXD4\n// This is just me cleaning up the code while trying to figure out what was going on\n\n#ifdef GL_ES\nprecision mediump float;\n#endif\n\n#define PI 3.14159265359\n\nconst int RAMP_STEPS = 5;\n\n/** \n * Noise\n * @src https://gist.github.com/patriciogonzalezvivo/670c22f3966e662d2f83#perlin-noise\n */\n\n// Noise: Random\nfloat rand(vec2 c){\n\treturn fract(sin(dot(c.xy, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\n// Noise: Basic noise\nfloat noise(vec2 p, float freq){\n\tfloat unit = iResolution.x / freq;\n\tvec2 ij = floor(p / unit);\n\tvec2 xy = .5 * (1. - cos(PI * mod(p, unit) / unit));\n\tfloat a = rand((ij + vec2(0., 0.)));\n\tfloat b = rand((ij + vec2(1., 0.)));\n\tfloat c = rand((ij + vec2(0., 1.)));\n\tfloat d = rand((ij + vec2(1., 1.)));\n\tfloat x1 = mix(a,b,xy.x);\n\tfloat x2 = mix(c,d,xy.x);\n\treturn mix(x1,x2,xy.y);\n}\n\n// Noise: Perlin noise\nfloat perlinNoise(vec2 p, int res, float scale, float lacunarity) {\n\tfloat persistance = .5;\n\tfloat n = 0.;\n\tfloat normK = 0.;\n\tfloat f = scale;\n\tfloat amp = 1.;\n\tint count = 0;\n\tfor(int i = 0; i < 50; i++) {\n\t\tn += amp * noise(p + iTime,f);\n\t\tf *= lacunarity;\n\t\tnormK += amp;\n\t\tamp *= persistance;\n\t\tif (count == res) break;\n\t\tcount++;\n\t}\n\tfloat nf = n / normK;\n\treturn nf * nf * nf * nf * 3.;\n}\n\n/**\n * Animation\n * @src https://www.shadertoy.com/view/3sXXD4\n */\nfloat noiseTextureScalar(vec2 position, float distortion, float scale, int detail) {\n\tfloat distortionTheta = perlinNoise(position, detail, scale, 2.) * 2. * PI;\n\tvec2 distortionOffset = distortion * vec2(cos(distortionTheta), sin(distortionTheta));\n\treturn abs(perlinNoise(position + distortionOffset, detail, scale, 2.));\n}\n\nvec4 noiseTexture(vec2 position, float distortion, float scale, int detail) {\n\treturn vec4(\n\t\tnoiseTextureScalar(position + 10000., distortion, scale, detail),\n\t\tnoiseTextureScalar(position + 20000., distortion, scale, detail),\n\t\tnoiseTextureScalar(position, distortion, scale, detail),\n\t\t1.\n\t);\n}\n\nvec3 colorRamp(float position, vec4 steps[RAMP_STEPS]) {\n\tvec3 color = mix(steps[0].rgb, steps[1].rgb, smoothstep(steps[0].a, steps[1].a, position));\n\tcolor = mix(color, steps[2].rgb, smoothstep(steps[1].a, steps[2].a, position));\n\tcolor = mix(color, steps[3].rgb, smoothstep(steps[2].a, steps[3].a, position));\n\tcolor = mix(color, steps[4].rgb, smoothstep(steps[3].a, steps[4].a, position));\n\treturn color;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n\tvec4 rampColors[RAMP_STEPS];\n\t\n    // Fourth parameter is not really alpha,\n    // but where the color will map to on the ramp\n\trampColors[0] = vec4(0.000, 0.240, 0.500, 0.100);\n\trampColors[1] = vec4(0.003, 0.300, 0.297, 0.);\n\trampColors[2] = vec4(0.336, 0.800, 0.792, 0.200);\n\trampColors[3] = vec4(0.459, 1.000, 0.825, 0.700);\n\trampColors[4] = vec4(0.325, 0.700, 0.646, 1.000);\n\t\n\tvec4 n1 = noiseTexture(fragCoord.xy, 10., 1. + .0005 * iTime, 16);\n\tvec4 n2 = noiseTexture(n1.xy * iResolution.xy, 5., 8., 16);\n\n\tfragColor = vec4(colorRamp(n2.x, rampColors), 1.);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3ls3Wr.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[351, 368, 387, 387, 456], [458, 480, 512, 512, 863], [865, 888, 955, 955, 1284], [1286, 1353, 1437, 1437, 1678], [1680, 1680, 1757, 1757, 1977], [1979, 1979, 2035, 2035, 2388], [2390, 2390, 2445, 2445, 3011]], "test": "ok"}
{"id": "3lsGD4", "name": "Domain coloring of Lambert W", "author": "tpfto", "description": "Domain coloring of the complex [url=https://en.wikipedia.org/wiki/Lambert_W_function]Lambert W function[/url], the inverse function of x * exp(x).", "tags": ["2d", "math", "complex", "domaincoloring", "specialfunctions"], "likes": 1, "viewed": 288, "published": "Public API", "date": "1556360871", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// The MIT License\n// Copyright © 2019 J. M.\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// Basic domain coloring plot (https://en.wikipedia.org/wiki/Domain_coloring)\n// of the Lambert W function w = W(z) (https://en.wikipedia.org/wiki/Lambert_W_function)\n\n#define PI 3.14159265359\n#define EE 2.71828182846\n#define SCALE 5.0 // plot scale\n#define SPACING 0.0625 // grid line spacing\n\n// from Fabrice Neyret, \n#define cmul(A,B) ( mat2( A, -(A).y, (A).x ) * (B) )\n#define cinv(Z) ( vec2( (Z).x, -(Z).y ) / dot(Z, Z) ) \n#define cdiv(A,B) cmul( A, cinv(B) )\n\n// Schlick bias function, from http://dept-info.labri.u-bordeaux.fr/~schlick/DOC/gem2.ps.gz\nfloat bias( float a, float x )\n{\n    return x/((1.0/a - 2.0) * (1.0 - x) + 1.0);\n}\n\n// biased sawtooth\nfloat my_saw( float x, float p )\n{\n    float xs = mod(x, 1.0);\n    float xh = clamp(xs, 0.0, p);\n    return 0.5 + 0.5 * bias(0.95, xh) * (1.0 - smoothstep(p, 1.0, xs));\n}\n\n// modified version of Inigo Quilez's method at https://www.shadertoy.com/view/MsS3Wc\n// using \"rational smoothstep\" from https://tpfto.wordpress.com/2019/03/28/on-a-rational-variant-of-smoothstep/\nvec3 smooth_hue( float h )\n{\n    vec3 rgb = clamp( abs(mod(6.0 * h + vec3(0.0, 4.0, 2.0), 6.0) - 3.0) - 1.0, 0.0, 1.0);\n    return rgb * rgb * rgb/(1.0 - 3.0 * rgb * (1.0 - rgb));\n}\n\n// modified DLMF coloring, adapted from https://www.shadertoy.com/view/WtXGWN\nvec3 smooth_dlmf( float h )\n{\n    vec3 rgb = clamp( vec3(1., -1., -1.) * abs((vec3(8., 4., 8.) * mod(h, 1.0) - vec3(4.5, 1.5, 5.5))) + vec3(-1.5, 1.5, 2.5), 0.0, 1.0 );\n\treturn rgb * rgb * rgb/(1.0 - 3.0 * rgb * (1.0 - rgb));\n}\n\n// complex square root, from Numerical Recipes\n\nvec2 sqrtz( in vec2 z )\n{\n\tfloat ar = abs(z.x);\n    float ai = abs(z.y);\n\n    float w = (dot(z, z) == 0.0) ? 0.0 : ( (ar >= ai) ? (sqrt(ar) * sqrt(0.5 * (1.0 + sqrt(1.0 + (ai * ai)/(ar * ar))))) : (sqrt(ai) * sqrt(0.5 * (ar/ai + sqrt(1.0 + (ar * ar)/(ai * ai))))));\n    \n    return ((w == 0.0) ? vec2(0.0) : ((z.x >= 0.0 ? vec2(w, 0.5 * z.y/w) : vec2(0.5*ai/w, ((z.y >= 0.0) ? w : -w)))));\n}\n\n// complex logarithm\n\nvec2 logz( in vec2 z )\n{\n\treturn vec2(log(length(z)), atan(z.y, z.x));\n}\n\n// Lambert W function, Winitzki's approximation (https://doi.org/10.1007/3-540-44839-X_82)\n\nvec2 LambertW( in vec2 z )\n{\n    vec2 v = sqrtz(2.0 * EE * z + 2.0);\n    vec2 w = 2.0 * logz(vec2(1.0, 0.0) + 0.8842 * v);\n\n    return cdiv(w - logz(vec2(1.0, 0.0) + 0.9294 * logz(vec2(1.0, 0.0) + 0.5106 * v)) - vec2(1.213, 0.0), vec2(1.0, 0.0) + cinv(w + vec2(4.69483568, 0.0)));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 aspect = iResolution.xy / iResolution.y;\n    vec2 z = ( fragCoord.xy / iResolution.y ) - 0.5 * aspect;\n    z *= SCALE;\n    \n    vec2 w = LambertW(z);\n    float ph = atan(w.y, w.x);\n    float lm = log(0.0001 + length(w));\n    \n    vec3 c = vec3(1.0);\n    c = smooth_dlmf(0.5 * (ph / PI));\n    // uncomment for HSV version \n    // c = smooth_hue(0.5 * (ph / PI));\n\n    c *= mix(1.0, my_saw((0.5 * (lm/PI))/SPACING, 0.95) * my_saw((0.5 * (ph / PI))/SPACING, 0.95), 0.5 + 0.5 * cos(iTime));\n    fragColor = vec4(c, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3lsGD4.jpg", "access": "shaders20k", "license": "mit", "functions": [[1537, 1629, 1661, 1661, 1711], [1713, 1732, 1766, 1766, 1902], [1904, 2102, 2130, 2130, 2283], [2285, 2363, 2392, 2392, 2590], [2640, 2640, 2665, 2665, 3031], [3055, 3055, 3079, 3079, 3127], [3221, 3221, 3249, 3249, 3503], [3505, 3505, 3562, 3562, 4090]], "test": "ok"}
{"id": "3lsGWH", "name": "Glow Particles", "author": "soi", "description": "Simple particles shader.", "tags": ["2d", "particles", "glow"], "likes": 2, "viewed": 252, "published": "Public", "date": "1556388135", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float hash(float x)\n{\n    return fract(sin(x) * 43758.5453) * 2.0 - 1.0;\n}\n\nvec2 startPos(float x, vec2 pos)\n{\n\treturn vec2(pos.x + (cos(hash(x)) * 0.05), pos.y + (sin(hash(x * 1.4)) * 0.05));\n}\n\nvec2 endPos(float x, vec2 pos)\n{\n\treturn vec2(pos.x + (cos(hash(x)) * 0.4), pos.y + (sin(hash(x * 1.7)) * 0.4));\n}\n\nfloat sphere(vec2 center, float rayon, vec2 coord)\n{\n    return length(coord.xy - center) - rayon;\n}\n\nvec3 glow(vec3 color, float ld)\n{\n    return color * exp(-(ld/25.0)*25.5);\n}\n\nvec2 getBasisFragCoord(vec2 coord)\n{   \n    vec2 frag = coord;\n    frag.x /= iResolution.x / iResolution.y;\n    frag = frag / 2.0 + 1.0;\n    return frag.xy * iResolution.xy;\n}\n\nvec4 particles(vec2 uv, float time, float mx, float my, float speed)\n{\n    float px = mod(uv.x, 0.86) - 0.43;\n    float py = mod(uv.y, 0.86) - 0.43;\n    vec3 ret = vec3(0.0);\n    vec2 center = vec2(uv.x + px * mx, uv.y + py * my);\n    vec4 ret_color = vec4(vec3(0.0), 1.0);\n    \n    float i_time = iTime + time;\n    \n    const float seq_duration = 2.0;\n\tfloat current_seq = floor(i_time / seq_duration);\n\tfloat current_seq_time = mod(i_time, seq_duration);\n    \n    vec2 start_pos = startPos(current_seq + ((uv.x - px) + (uv.y - py)), center);\n\tvec2 end_pos   = endPos(current_seq + ((uv.x - px) + (uv.y - py)), center);\n\tvec2 current_pos;\n    \n\tfloat potential_dist = speed * current_seq_time;\n\tfloat end_dist = length(end_pos - start_pos);\n\t\n\tcurrent_pos = mix(start_pos, end_pos, potential_dist / end_dist) * step(potential_dist, end_dist);\n\tcurrent_pos += end_pos * step(end_dist, potential_dist);\n    \n    float dist_length     = sqrt((end_pos.x - start_pos.x)*(end_pos.x - start_pos.x) + (end_pos.y - start_pos.y)*(end_pos.y - start_pos.y));\n    float dist_bright_off = dist_length * 0.2;\n    float dist_current    = sqrt((end_pos.x - current_pos.x)*(end_pos.x - current_pos.x) + (end_pos.y - current_pos.y)*(end_pos.y - current_pos.y));\n    \n    float ld = sphere(getBasisFragCoord(current_pos), 0.01, getBasisFragCoord(uv));\n        \n    float alpha = smoothstep(0.0, dist_bright_off, dist_length - dist_current) * smoothstep(0.0, dist_bright_off, dist_current);\n    alpha *= 1.0 - step(0.1, length(uv - current_pos));\n    ret_color = vec4(glow(vec3(1.0, 1.0, 0.0), ld), 1.0) * alpha;\n        \n    return ret_color;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\tuv = uv * 2.0 - 1.0;\n\tuv.x *= iResolution.x / iResolution.y;\n    \n    fragColor = particles(uv + vec2(25.0), 0.0, 1.0, 1.0, 0.35);\n    fragColor += particles(uv - vec2(20.0), 0.25, -1.0, -1.0, 0.1);\n    fragColor += particles(uv + vec2(20.0), 0.5, -1.0, 1.0, 0.25);\n    fragColor += particles(uv - vec2(40.0), 0.75, 1.0, -1.0, 0.15);\n    \n    fragColor += particles(uv + vec2(10.0), 1.75, -1.0, 1.0, 0.3);\n    fragColor += particles(uv - vec2(40.0), 1.0, -1.0, -1.0, 0.2);\n    fragColor += particles(uv + vec2(30.0), 1.25, -1.0, 1.0, 0.15);\n    fragColor += particles(uv - vec2(30.0), 1.5, 1.0, -1.0, 0.25);\n    \n    fragColor += particles(uv - vec2(10.0), 0.35, 1.0, -1.0, 0.3);\n    fragColor += particles(uv - vec2(15.0), 0.65, 1.0, 1.0, 0.25);\n    fragColor += particles(uv + vec2(15.0), 1.35, 1.0, 1.0, 0.2);\n    fragColor += particles(uv - vec2(25.0), 1.65, 1.0, -1.0, 0.15);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3lsGWH.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 21, 21, 74], [76, 76, 110, 110, 194], [196, 196, 228, 228, 310], [312, 312, 364, 364, 412], [414, 414, 447, 447, 490], [492, 492, 528, 528, 667], [669, 669, 739, 739, 2294], [2296, 2296, 2353, 2353, 3279]], "test": "timeout"}
{"id": "3lX3DM", "name": "Water galaxy", "author": "jblanper", "description": "Black & white spirals and sparks.", "tags": ["2d", "spiral", "blackwhite", "spark"], "likes": 11, "viewed": 255, "published": "Public", "date": "1556448349", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2 uv = (fragCoord.xy - .5 * iResolution.xy) / iResolution.y;\n\n  vec3 color = vec3(0);\n\n  float t = (sin(iTime * .6) * .4 + .6);\n  float a = atan(uv.y, uv.x);\n  float l = length(uv);\n\n  vec2 rt = vec2(cos(iTime * .3), sin(iTime * .3)) * 5.;\n  vec2 p1 = vec2(cos(l * 120. + iTime), sin(l * 20. + iTime * .5));\n  vec2 p2 = vec2(cos(a + l * 30. + iTime), sin(a - l * 20. + iTime * .4)) * 5.;\n\n  vec2 st = uv * 18.;\n  color += 1. / length(st + p1) * t; // spark\n\n  color += 1. / dot(st + p2, st + p2) * t; // spark\n  \n  color *= mix(\n      color, vec3(abs(1. - uv.x)), \n      smoothstep(.01, .1, 1. / dot(st + p2 * rt, st + p2 - rt) / t)); // spark\n\n  st += rt + pow(p1, vec2(7.));\n  color += 1. / dot(st, st) * t; // spark\n\n  fragColor = vec4(color, 1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3lX3DM.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 815]], "test": "ok"}
{"id": "3lX3Wr", "name": "Color Lerp Gradient", "author": "Diatom", "description": "Linear interpolation multi color gradient bands.", "tags": ["gradientlinear"], "likes": 1, "viewed": 249, "published": "Public", "date": "1556048485", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define numColors  8\nvec3 colorArray[numColors];\nfloat _Speed = -0.0;\nfloat _Scale = 1.;\n\n//---------------------------------- random\nfloat random(vec2 st)\n\t\t\t{\n\t\t\t\treturn abs(fract(sin(dot(st.xy,\n\t\t\t\t\tvec2(12.9898, 78.233)))*\n\t\t\t\t\t43758.5453123));\n            }\n\n//---------------------------------- flat_band\nvec3 flat_band(float t, vec3 colA, float posA, float posB){\n\tvec3 retColor = vec3(0.);     \n    float maskStep = step(posA, t)*  (1.- step(posB, t));  \n    retColor +=   colA * maskStep;\n    return retColor;\n}\n\n//---------------------------------- color_lerp\nvec3 color_lerp(float t, vec3 colA,float posA, float posB){\n    //t = mod(t*_Scale +iTime*_Speed, 1.0); // transform UVs\n    t = t* (1.0-1.0/float(numColors)) + (1.0/float(numColors)*0.5); // frame for seamless looping\n\tvec3 retColor = vec3(0.);   // return color\n    float m = posA + ((posB - posA)/2.); // midpoint between A and B\n    float d = (posB - posA); // distance between A and B\n    float maskSmooth =  smoothstep(m-d, m, t) *( 1. - smoothstep(m, m+d, t));      \n    retColor = colA * maskSmooth; \n    return retColor;\n}\n\n//---------------------------------- main\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\t    \n    float rSeed = 39.11025;\n    float rStrength = 0.;\n    float waveStrength = 1.;\n    float waveAmp = 1.0;\n    float waveFreq = 4.5;\n    float waveOff = 0.0;\n    float waveSpeed = 0.33;\n    vec3 colorPhase = vec3(0.2, 0.35, 0.8);\n    float PI = 3.1415926;\n    for (int i=0; i<numColors; i++)\n    {\n    \t// Random Color\n       /* colorArray[i] += vec3( random(vec2(float(i+1)*33.3 *rSeed, float(i+1)*66.6*rSeed) ), \n                              random(vec2(float(i+1)*11.1*rSeed, float(i+1)*55.6*rSeed)), \n                              random(vec2(float(i+1)*22.8*rSeed, float(i+1)*77.6*rSeed)) )* rStrength;*/\n    \t// Wave Color\n        \n   \t float w = float(i) / float(numColors) ;\n     colorArray[i] += vec3( (sin(w*PI*waveFreq+colorPhase.x*PI + waveSpeed*iTime)+1.0)*0.5 * waveAmp + waveOff,\n                              (sin(w*PI*waveFreq+colorPhase.y*PI + waveSpeed*iTime)+1.0)*0.5 * waveAmp + waveOff,\n                              (sin(w*PI*waveFreq+colorPhase.z*PI + waveSpeed*iTime)+1.0)*0.5 * waveAmp + waveOff )  * waveStrength;   \n\t}\n    \n    vec3 col = vec3(0.); \n    float ptInterval = 1./float(numColors);\n    int loop = 1;\n    int a,b;\n    float offset = 0.21;\n   // float ptStart, ptEnd;\n    for (int i=0; i < numColors; i++){\n        a = i % (numColors-1 + ((1-loop)*1000));      \n        col +=  color_lerp(uv.x,  colorArray[a],   ptInterval * float(i) ,  ptInterval * float(i)+ptInterval  ); \n        //col += flat_band(uv.x,  colorArray[a],   ptInterval * float(i),  ptInterval * float(i)+ptInterval ); \n    }\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3lX3Wr.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[90, 134, 160, 160, 262], [264, 311, 370, 370, 520], [522, 570, 629, 690, 1101], [1103, 1145, 1202, 1252, 2888]], "test": "ok"}
{"id": "3lXGD4", "name": "Patarty Remix", "author": "Lanza", "description": "Fork of \"Patarty\" by MrsBeanbag. https://shadertoy.com/view/wtXGWr\nAdded some movement.\n\nIt's not a party, it's a patarty yeah !\n\nmy first shader lmaooo", "tags": ["amiga", "remix", "boom"], "likes": 2, "viewed": 280, "published": "Public API", "date": "1556286323", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Fork of \"Patarty\" by MrsBeanbag. https://shadertoy.com/view/wtXGWr\n// 2019-04-26 12:45:38\n\nfloat random (in vec2 st) {\n    return fract(sin(dot(st.xy,\n                         vec2(12.9898,78.233)))*\n        43758.5453123);\n}\n\n// Based on Morgan McGuire @morgan3d\n// https://www.shadertoy.com/view/4dS3Wd\nfloat noise (in vec2 st) {\n    vec2 i = floor(st);\n    vec2 f = fract(st);\n\n    // Four corners in 2D of a tile\n    float a = random(i);\n    float b = random(i + vec2(1.0, 0.0));\n    float c = random(i + vec2(0.0, 1.0));\n    float d = random(i + vec2(1.0, 1.0));\n\n    vec2 u = f * f * (3.0 - 2.0 * f);\n\n    return mix(mix(a, b, u.x), mix(c, d, u.x), u.y);\n}\n\nfloat plasma (in vec2 st) {\n    float value = 4.0 * noise(st);\n    return step(fract(value), 0.5);\n}\n\n// ray marching\nconst int max_iterations = 128;\nconst float grad_step = 0.0001;\nconst float clip_far = 10.0;\n\n// math\nconst float PI = 3.14159265359;\nconst float DEG_TO_RAD = PI / 180.0;\nfloat bounce = 0.0;\n\nvec3 diffuse_colour = vec3(0.0);\nvec3 specular_colour = vec3(0.0);\nvec3 final_diff_colour = vec3(0.0);\nvec3 final_spec_colour = vec3(0.0);\n\n// iq's distance function\nfloat sdSphere( vec3 pos, float r ) {\n\treturn length( pos ) - r;\n}\n\nfloat sdUnion( float d0, float d1 ) {\n    return min( d0, d1 );\n}\n\nfloat sdUnion_mat( float d0, float d1, vec3 cd, vec3 cs ) {\n    if (d0 <= d1) {\n        return d0;\n    } else {\n        diffuse_colour = cd;\n        specular_colour = cs;\n        return d1;\n    }\n}\n\nfloat sdUnion_s( float a, float b, float k ) {\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\nfloat potato( vec3 p ) {\n    float d0 = sdSphere( p + vec3(0.05,-0.5*sin(fract(iTime) * 13.2), 0.0), 0.45 );\n    float d1 = sdSphere( p + vec3(0.0, 0.0, 0.1), 0.6 );\n    float d2 = sdSphere( p + vec3(0.15 * cos(fract(iTime) * 6.6), 0.5, 0.0), 0.5 );\n    \n    float d = sdUnion_s( d0, d1, 0.4 );\n    return sdUnion_s( d, d2, 0.4 );\n}\n\nfloat eyes( vec3 p ) {\n    float e0 = sdSphere( p + vec3(0.15, -0.2, -0.42), 0.15 );\n    float e1 = sdSphere( p + vec3(-0.15, -0.22, -0.42), 0.15 );\n    return sdUnion(e0, e1);\n}\n\n// get distance in the world\nfloat dist_field( vec3 p ) {\n    vec3 pb = p;\n    pb.y += -0.2 + bounce;\n\tdiffuse_colour = vec3( 0.9, 0.7, 0.55 );\n\tspecular_colour = vec3( 0.0 );\n\n    float d = sdUnion_mat(potato(pb), eyes(pb), vec3(0.0), vec3(1.0));\n    \n    return d;\n}\n\n// get gradient in the world\nvec3 gradient( vec3 p ) {\n    const vec2 k = vec2(1,-1);\n    return vec3( k.xyy*dist_field( p + k.xyy * grad_step ) + \n                 k.yyx*dist_field( p + k.yyx * grad_step ) + \n                 k.yxy*dist_field( p + k.yxy * grad_step ) + \n                 k.xxx*dist_field( p + k.xxx * grad_step ) );\n}\n\n// phong shading\nvec3 shading( vec3 v, vec3 n, vec3 dir, vec3 eye) {\n\tvec3 light_pos   = vec3( 20.0, 20.0, 30.0 );\n\tvec3 light_color = vec3( 1.0 );\n\n\tfloat shininess = 40.0;\n\t\n\tvec3 vl = normalize( light_pos - v );\n\tvec3 ref = reflect( dir, n );\n\t\n\tfloat diffuse  = max( 0.0, dot( vl, n ) );\n\tfloat specular = max( 0.0, dot( vl, ref ) );\n\t\t\n\tspecular = pow( specular, shininess );\n\t\t\n\treturn light_color * final_diff_colour * diffuse\n        + final_spec_colour * specular;\n}\n\n// ray marching\nbool ray_marching( vec3 o, vec3 dir, inout float depth, inout vec3 n ) {\n\tfloat t = 0.0;\n    for ( int i = 0; t < depth; i++ ) {\n        vec3 v = o + dir * t;\n        float d = dist_field( v );\n        if ( d < grad_step || i >= max_iterations) {\n    \t\tfinal_diff_colour = diffuse_colour;\n\t\t\tfinal_spec_colour = specular_colour;\n\t\t    n = normalize( gradient( v ) );\n    \t\tdepth = t;\n\t\t    return true;\n        }\n        t += d;\n    }\n    return false;\n}\n\n// get ray direction\nvec3 ray_dir( float fov, vec2 size, vec2 pos ) {\n\tvec2 xy = pos - size * 0.5;\n\n\tfloat cot_half_fov = tan( ( 90.0 - fov * 0.5 ) * DEG_TO_RAD );\t\n\tfloat z = size.y * 0.5 * cot_half_fov;\n\t\n\treturn normalize( vec3( xy, -z ) );\n}\n\n// camera rotation : pitch, yaw\nmat3 rotationXY( vec2 angle ) {\n\tvec2 c = cos( angle );\n\tvec2 s = sin( angle );\n\t\n\treturn mat3(\n\t\tc.y      ,  0.0, -s.y,\n\t\ts.y * s.x,  c.x,  c.y * s.x,\n\t\ts.y * c.x, -s.x,  c.y * c.x\n\t);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\t// default ray dir\n\tvec3 dir = ray_dir( 45.0, iResolution.xy, fragCoord.xy );\n\t\n\t// default ray origin\n\tvec3 eye = vec3( 0.0, 0.0, 3.5 );\n\n\t// rotate camera\n\tmat3 rot = rotationXY( vec2(0.0, sin(iTime) ) );\n\t//mat3 rot = rotationXY( ( iMouse.xy - iResolution.xy * 0.5 ).yx * vec2( 0.01, -0.01 ) );\n\tdir = rot * dir;\n\teye = rot * eye;\n\n    bounce = fract(iTime*2.2)-0.5;\n    bounce *= bounce;\n\tfloat boom = pow(cos(bounce), 25.);\n\n\t// ray marching\n    float depth = clip_far;\n    vec3 n = vec3( 0.0 );\n\tif (ray_marching( eye, dir, depth, n)) {\n\t\t// shading\n\t\tvec3 pos = eye + dir * depth;\n    \n    \tvec3 color = shading( pos, n, dir, eye );\n\t\tfragColor = vec4( color, 1.0 );\n        return;\n    }\n    \n    vec2 st0 = vec2(.9, .5) - fragCoord.xy/iResolution.y;\n    vec2 st = vec2(length(st0), atan(st0.x, st0.y));\n\n\tvec3 color = vec3((1.- boom));\n    color.x += plasma(vec2(log(st.x), st.y + iTime*0.2)*3.0);\n    color.y += plasma(vec2(log(st.x) * boom, st.y + iTime*0.1)*4.0);\n    color.z += plasma(vec2(log(st.x), st.y - iTime*0.4)*5.0);\n\n\tfragColor = vec4(color*0.5,1.0);\n    return;\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3lXGD4.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[94, 94, 121, 121, 228], [230, 308, 334, 334, 665], [667, 667, 694, 694, 767], [1117, 1143, 1180, 1180, 1209], [1211, 1211, 1248, 1248, 1276], [1278, 1278, 1337, 1337, 1475], [1477, 1477, 1523, 1523, 1616], [1618, 1618, 1642, 1642, 1950], [1952, 1952, 1974, 1974, 2130], [2132, 2161, 2189, 2189, 2400], [2402, 2431, 2456, 2456, 2737], [2739, 2756, 2807, 2807, 3214], [3216, 3232, 3304, 3304, 3686], [3688, 3709, 3757, 3757, 3933], [3935, 3967, 3998, 3998, 4154], [4156, 4156, 4213, 4233, 5301]], "test": "ok"}
{"id": "3lXGRB", "name": "FakeLightMove", "author": "cedar_x", "description": "postfilter fake light", "tags": ["2d"], "likes": 11, "viewed": 528, "published": "Public API", "date": "1556629508", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define TAU 6.28318530718\n#define MAX_ITER 5\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float time = iTime * 0.2 + 23.0;\n    vec2 uv = fragCoord.xy / iResolution.xy;\n\n    vec2 p = mod(uv * TAU, TAU) - 250.0;\n    vec2 i = vec2(p);\n    float c = 1.0;\n    float inten = 0.005;\n\n    for (int n = 0; n < MAX_ITER; n++) {\n        float t = time * (1.0 - (3.5 / float(n + 1)));\n        i = p + vec2(cos(t - i.x) + sin(t + i.y), sin(t - i.y) + cos(t + i.x));\n        c += 1.0 / length(vec2(p.x / (sin(i.x + t) / inten), p.y / (cos(i.y + t) / inten)));\n    }\n\n    c /= float(MAX_ITER);\n    c = 1.17-pow(c, 1.4);\n    vec3 colour = vec3(pow(abs(c), 8.0));\n    //colour = clamp(colour + vec3(0.0, 0.0, 0.0), 0.0, 1.0);\n\n    fragColor = vec4(colour, 1.0) + texture(iChannel0,uv);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3lXGRB.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[46, 46, 103, 103, 788]], "test": "error"}
{"id": "3lXGz7", "name": "Aura", "author": "gaz", "description": "3d", "tags": ["3d"], "likes": 2, "viewed": 135, "published": "Public", "date": "1555852401", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec3 rotate(vec3 p,vec3 axis,float theta)\n{\n    vec3 v = cross(p, axis), u = cross(v, axis);\n    return u * cos(theta) + v * sin(theta) + axis * dot(p, axis);   \n}\n\nfloat map(vec3 p)\n{\n    p = rotate(p,normalize(vec3(1)), iTime);\n    p = abs(p);\n    return min(length(p)-1.8,(p.x+p.y+p.z-2.5)*0.5773);\n\n}\n\nvec3 calcNormal(vec3 pos){\n  vec2 e = vec2(1, -1) * 0.002;\n  return normalize(\n    e.xyy*map(pos+e.xyy)+e.yyx*map(pos+e.yyx)+ \n    e.yxy*map(pos+e.yxy)+e.xxx*map(pos+e.xxx)\n  );\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 p = (gl_FragCoord.xy * 2.0 - iResolution.xy) / iResolution.y;\n    vec3 ro = vec3(0,0,7);\n    vec3 rd = normalize(vec3(p, -2));\n\n\tvec3 col = vec3(0.05, 0.05, 0.15);\n\tconst float maxd = 80.0, precis = 0.001;\n\tfloat t,d;\n\tt = 0.0;\n\tfloat weight =  0.5+sin(iTime)*0.25;\n \tfor(int i = 0; i < 32; i++)\n  \t{\n\t\tvec3 p=ro + rd * t; \n        t += d =map(p) * weight;\n    \tif (d < precis || t > maxd) break;\n    }\n  \tcol = mix(vec3(0.9,0.4,0.1),col, smoothstep(0.0, 1.0, d*0.08+0.05));  \n\tt = 0.0;\n\tfor(int i = 0; i < 128; i++)\n  \t{\n\t\tvec3 p=ro + rd * t; \n    \tt += d =map(p);\n    \tif (d < precis || t > maxd) break;\n    }\n    if(d < precis)\n  \t{\n\t  \tvec3 p = ro + rd * t;\n\t \tvec3 nor = calcNormal(p);\n    \tvec3 li = normalize(vec3(1));\n        col = vec3(0.3,0.7,0.5);\n        float dif = clamp(dot(nor, li), 0.3, 1.0);\n        float amb = max(0.5 + 0.5 * nor.y, 0.0);\n        col *= dif * amb;\n    }\n  \tcol = pow(col, vec3(1.2));        \n\tt=iTime * 5.0;\n\tcol +=vec3(1,0.5,0)*sin(p.y*500.0-t)*sin(p.x*300.0-t)*0.2;\n\tcol *= clamp(2.0-length(p),0.0,1.0);\n    fragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3lXGz7.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 43, 43, 163], [165, 165, 184, 184, 304], [306, 306, 332, 332, 485], [487, 487, 542, 542, 1628]], "test": "ok"}
{"id": "3lXGzH", "name": "Flowing noise", "author": "avin", "description": "Noise experiment", "tags": ["noise"], "likes": 6, "viewed": 401, "published": "Public API", "date": "1555587079", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Noise pixel size\n#define SIZE 1.0\n// Lower - more flowing\n#define FLUENCY 0.85\n\nfloat rand(vec2 co) { \n    return fract(sin(dot(co.xy , vec2(12.9898, 78.233))) * 43758.5453);\n} \n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{        \n    vec2 id = ceil(fragCoord/SIZE);    \n    vec2 rid = vec2(rand(id), rand(id+iResolution.y));            \n        \n    fragColor = vec4(0.1/fract(rid.x + rid.y - iTime * FLUENCY));\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3lXGzH.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[83, 83, 104, 104, 179], [182, 182, 239, 239, 431]], "test": "ok"}
{"id": "3lXGzM", "name": "The Walk", "author": "OliverSchaff", "description": "The materials contain a density in their a-coordinate. This defines the transparency.\nUse mouse to rotate.", "tags": ["3d", "raymarching", "transparency", "volumetric", "glass", "transforms"], "likes": 31, "viewed": 630, "published": "Public", "date": "1556462876", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Renderingcode from a shader by Shane\n// https://www.shadertoy.com/view/ll2SRy\n\n#define PI 3.14159265359\n#define grad_step 0.01\n\n#define wormTimeXF pow(clamp(sin(2.0*PI*time-0.3*2.0*PI),0.0,1.0),0.8)\n#define wormTimeXB pow(clamp(sin(2.0*PI*time-0.3*2.0*PI-1.0*PI),0.0,1.0),0.8)\n\n#define time 0.5*iTime\n\n#define ZERO (min(iFrame,0))\n\nvec2 opUC( vec2 d1, vec4 mate1, vec2 d2, vec4 mate2, out vec4 mate){\n    if (d1.x<d2.x) {\n        mate = mate1;\n        return d1;\n    }\n    mate = mate2;\n    return d2;\n}\n\n\nvec2 opUC_s( vec2 a, vec4 matea,vec2 b, vec4 mateb, float k , out vec4 mate){\n    float h = clamp( 0.5+0.5*(b.x-a.x)/k, 0.0, 1.0 );\n    float d = mix( b.x, a.x, h ) - k*h*(1.0-h);\n    \n    mate = mix( mateb, matea, h ) - k*h*(1.0-h);\n    \n    if (a.x<b.x) {\n        return vec2(d,a.y);\n    }\n    return vec2(d,b.y);\n}\n\n\n// iq's distance functions\n\nfloat sdSphere( vec3 p, float s )\n{\n  return length(p)-s;\n}\n\nvec3 carToCyl(vec3 p) {\n    mat2 rot = mat2(-1.0,0.0,0.,-1.0);\n    p.xy = rot*p.xy;\n    float r = length(p.xy);\n    float the = atan(p.y,p.x);\n    return vec3(r,the,p.z);\n}\n\n// 2D rotation : pitch, yaw\nmat3 rotationXY( vec2 angle ) {\n\tvec2 c = cos( angle );\n\tvec2 s = sin( angle );\n\t\n\treturn mat3(\n\t\tc.y      ,  0.0, -s.y,\n\t\ts.y * s.x,  c.x,  c.y * s.x,\n\t\ts.y * c.x, -s.x,  c.y * c.x\n\t);\n}\n\nfloat pModPolar(inout vec2 p, float repetitions) { \n\tfloat angle = 2.*PI/repetitions; \n\tfloat a = atan(p.y, p.x) + angle/2.; \n\tfloat r = length(p); \n\tfloat c = floor(a/angle); \n\ta = mod(a,angle) - angle/2.; \n\tp = vec2(cos(a), sin(a))*r; \n    // For an odd number of repetitions, fix cell index of the cell in -x direction // (cell index would be e.g. -5 and 5 in the two halves of the cell): \n\tif (abs(c) >= (repetitions/2.)) c = abs(c);\n    return c;\n}\n\n\nfloat sdVerticalCapsule( vec3 p, float h, float r )\n{\n    p.z -= clamp( p.z, 0.0, h );\n    return length( p ) - r;\n}\n\nfloat blob(vec2 p,float r){\n    float f = smoothstep(0.2*r,r,length(p));\n    return f;\n}\n\nfloat line( vec3 p, vec3 a, vec3 b, float radius, inout vec4 mate)\n{\n\tvec3 ba = b - a;\n\tvec3 pa = p - a;\n\tfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n\treturn length( pa - ba*h ) - radius;\n}\n\nfloat sdCylinder( vec3 p, vec3 c )\n{\n  return length(p.xy-c.xy)-c.z;\n}\n\n// https://www.shadertoy.com/view/4djSRW\n// thanks to Dave_Hoskins\nvec2 hash22(vec2 p)\n{\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+19.19);\n    return fract((p3.xx+p3.yz)*p3.zy);\n\n}\n\n\nvec2 map(in vec3 p, out vec4 mate){\n    \n    float tubeTime = floor(time)+smoothstep(0.3,0.7,fract(time));\n    p.x += 0.2*sin(2.0*p.z+4.0*time);\n    p.z += tubeTime;\n    \n\n    // tube\n    vec3 pt = p;\n    pt.z -= tubeTime;\n\tconst float xOffset = 0.4;\n    \n    // tube material\n    vec3 ptm = pt;\n    vec3 pcyl = carToCyl(ptm-vec3(xOffset,0,0));\n    vec4 mate0 = vec4(1,1,1,0.2);\n    vec4 mate1 = vec4(texture(iChannel0,1.0*vec2(pcyl.y/PI,pcyl.z)).rrr,0.6);\n    const float radius = 0.3;\n    float modRadius = 0.06*mate1.r+radius+0.1*pow(abs(sin(-3.*time+0.25*pt.z)),25.0);\n    mate0 = mix(mate0,mate1,0.7);\n\n    vec2 d0 = vec2(sdCylinder(pt, vec3(xOffset,0.0,modRadius)),1.0);\n    \n    // leaves\n    vec3 pl = pt;\n\tpl.xy -= vec2(xOffset,0.0);\n    pl.z = fract(0.5*pl.z)/0.5;\n    float leafIndex = pModPolar(pl.xy,3.);\n    pl = rotationXY(vec2(0.0,-2.7))*pl;\n    vec2 d1 = vec2(sdVerticalCapsule(pl-vec3(-1.2,0.0,0.4),-1.8,0.03-0.03*pl.z),3.0);\n    \n    // leaf material\n    mate1 = vec4(0.6,0.8,1,0.2);\n    d0 = opUC_s(d0, mate0,d1,mate1,0.3,mate0);\n    \n    // worm body\n    mate1 = vec4(1,1,1,0.2);\n    vec3 pb = p;\n\n    float wormTimeZ = floor(time)+smoothstep(0.3,0.7,fract(time))-floor(time-0.5)-smoothstep(0.3,0.7,fract(time-0.5));\n    vec3 back = vec3(-0.4*wormTimeXB+0.7*wormTimeXF,0.,1.5+wormTimeZ);\n    float l = length(back);\n    pb.x += 0.7*wormTimeXF+radius-0.19+0.4*(0.5+0.5*sin(1.6*PI*p.z/l-0.8));\n    pb = rotationXY(vec2(0.0,-atan(back.x/back.z)))*pb;\n    pb.z *= 1.0/length(back);\n    \n    // worm's freckles\n    pcyl = carToCyl(pb-vec3(0.,0.,0.));\n    vec2 ps = vec2(10.0*0.5*pcyl.y/PI,20.0*pcyl.z);\n   \tvec2 fps = fract(ps);\n    vec2 ips = floor(ps);\n    vec2 ran = hash22(ips);\n//    vec2 ran = texelFetch( iChannel0, (ivec2(ips)+10), 0 ).rg;\n    float r = 0.2+0.3*ran.x;\n    float blob = blob(fps-0.2-0.4*ran.xy, r);\n    float freckles = (1.0-blob)*smoothstep(0.0,0.1,pb.z)*smoothstep(1.0,0.9,pb.z);\n    mate1 = mix(mate1, vec4(1,0.2,0,0.8), freckles);\n\n    d1 = vec2(sdVerticalCapsule(pb, 1.0, 0.15-0.07*wormTimeZ+0.01*freckles),1.0);\n\n    pb.z *= length(back);\n    // head\n    vec4 mate2 = vec4(1,0.2,0,0.4);\n    vec4 mate3;\n    vec2 d2 = vec2(sdSphere(pb-vec3(0,0,-0.2),0.15),2.0);\n    d1 = opUC_s(d1, mate1 ,d2, mate2 ,0.1, mate3);\n    \n    // back end\n    d2 = vec2(sdSphere(pb-vec3(0,0,length(back)+0.15),0.15),3.0);\n    d1 = opUC_s(d1, mate3 ,d2, mate2 ,0.1, mate3);\n    \n    vec2 dFinal = opUC_s(d0, mate0, d1, mate3, 0.05, mate);\n    return dFinal;\n}\n\n// http://iquilezles.org/www/articles/normalsSDF/normalsSDF.htm\nvec3 calcNormal( in vec3 pos, in float ep )\n{\n    vec4 kk;\n#if 1\n    vec2 e = vec2(1.0,-1.0)*0.5773;\n    return normalize( e.xyy*map( pos + e.xyy*ep, kk).x + \n\t\t\t\t\t  e.yyx*map( pos + e.yyx*ep, kk).x + \n\t\t\t\t\t  e.yxy*map( pos + e.yxy*ep, kk).x + \n\t\t\t\t\t  e.xxx*map( pos + e.xxx*ep, kk).x );\n#else\n    // prevent the compiler from inlining map() 4 times\n    vec3 n = vec3(0.0);\n    for( int i=ZERO; i<4; i++ )\n    {\n        vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);\n        n += e*map(pos+e*ep, kk).x;\n    }\n    return normalize(n);\n#endif    \n    \n}\n\nmat3 calcLookAtMatrix( in vec3 ro, in vec3 ta, in float roll )\n{\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(sin(roll),cos(roll),0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n    return mat3( uu, vv, ww );\n}\n\nvec3 phongColor(in vec3 p, in vec3 rd){\n    \n    vec3 Ks = vec3(1.0); // specular reflected intensity\n    float shininess = 80.0;\n    \n    vec3 n = calcNormal(p, 0.01);\n    vec3 ref = reflect( rd, n );\n    vec3 final = vec3(0);\n    \n\n    // light 0\n\t{\n\t\tvec3 light_pos   = p+vec3( -1.0, 1.0, 0.0 );\n\t\tvec3 light_color = vec3( 1.0, 1.0, 1.0 );\n\t\n\t\tvec3 vl = normalize( light_pos - p );\n\t\tvec3 specular = vec3( max( 0.0, dot( vl, ref ) ) );\n        specular = pow( specular, vec3( shininess ) );\n\t\tfinal += light_color * specular; \n\t}\n    return final;\n}\n\n// The MINIMIZED version of https://www.shadertoy.com/view/Xl2XWt\nconst float MAX_TRACE_DISTANCE = 11.0;           // max trace distance\nconst float INTERSECTION_PRECISION = 0.009;        // precision of the intersection\nconst int NUM_OF_TRACE_STEPS = 50;\nconst float EPS_NORMAL = 0.01;\nconst float SCALE_DIST = 0.9;\n\n\nvec2 calcIntersection( in vec3 ro, in vec3 rd ){\n    float h =  INTERSECTION_PRECISION*2.0;\n    float t = 0.0;\n\tfloat res = -1.0;\n    float id = -1.;\n    vec4 kk;\n    \n    for( int i=0; i< NUM_OF_TRACE_STEPS ; i++ ){\n        if( h < INTERSECTION_PRECISION || t > MAX_TRACE_DISTANCE ) break;\n\t   \tvec2 m = map( ro+rd*t , kk);\n        h = m.x;\n        t += h*SCALE_DIST;\n        id = m.y;\n    }\n    if( t < MAX_TRACE_DISTANCE ) res = t;\n    if( t > MAX_TRACE_DISTANCE ) id =-1.0;\n    return vec2( res , id );\n}\n\nvec3 render( vec2 res , vec3 ro , vec3 rd ){\n  vec3 c = vec3(0);\n  if( res.y > -.5 ){\n      vec3 pos = ro + rd * res.x;\n      c = phongColor(pos, rd);\n  }\n  return c;\n}\n\n\n\nvoid mainImage( out vec4 fragColor, vec2 fragCoord ) {\n    \n    vec2 p = (-iResolution.xy + 2.0*fragCoord.xy)/iResolution.y;\n\tvec3 ro = vec3(-2,-3,-3.0-time);\n    vec3 ta = vec3( 0.3*sin(time), 0.3*cos(2.0*time) , -time);\n    \n    float aa = 1.0/min(iResolution.y,iResolution.x);\n    \n    // camera matrix\n    mat3 camMat = calcLookAtMatrix( ro, ta, -1.1);  // 0.0 is the camera roll\n    \n\t// create view ray\n\tvec3 rd = normalize( camMat * vec3(p.xy, 4.5+1.5*sin(time)) );\n    \n    // rotate camera with mouse\n\tmat3 rot = rotationXY(iMouse.xy * vec2( 0.01, -0.01 ) );\n    vec3 shift = ro-vec3(-2,-3,-3.0);\n    ro -= shift;\n\trd = rot * rd;\n\tro = rot * ro;\n    ro += shift;\n    \n    vec3 col = vec3(0.05,0.05,0.15);\n    vec3 sp;\n    vec4 mate;\n    \n    // volume rymarching\n\t// Ray distance, bail out layer number, surface distance and normalized accumulated distance.\n\tfloat t=0., layers=0., d, aD;\n    \n    // Surface distance threshold. Smaller numbers give a sharper object. Antialiased with aa\n    float thD = 0.25*sqrt(aa); \n    \n    // Only a few iterations seemed to be enough. Obviously, more looks better, but is slower.\n    for(int i=0; i<90; i++)\t{\n        if(layers>100. || col.g>1.0 || t>11.) break;\n        sp = ro + rd*t;\n        d = map(sp, mate).x; // Distance to nearest point in the cube field.\n        // Normalized distance from the surface threshold value to our current isosurface value.\n        aD = (thD-abs(d))/thD;\n        // If we're within the surface threshold, accumulate some color.\n        if(aD>0.) { \n            vec3 tc = mate.rgb*pow(mate.a,2.0);\n            col += 5.0*tc*(aD*aD*(3. - 2.*aD)/(1. + t*t*.2));\n            layers += 30.0*pow(mate.a+0.2,2.0);\n        }\n        t += max(abs(d)*0.7, thD*0.7); \n\t}\n\n    // standard raymarching code to color the surface\n    vec2 res = calcIntersection( ro , rd  );\n    vec3 surfaceColor = render(res, ro, rd);\n    col += surfaceColor;\n    \n    \n    col = clamp(col, 0.0,1.0);\n    // post processing\n    col = pow(col,vec3(0.7,0.85,1.0));\n    // iq's vignetting\n \tvec2 q = fragCoord/iResolution.xy;\n    col *= pow( 16.0*q.x*q.y*(1.0-q.x)*(1.0-q.y), 0.3 );\n\n\tfragColor = vec4(clamp(col, 0., 1.), 1);\n }\n", "image_inputs": [{"id": "4sf3Rr", "previewfilepath": "/media/ap/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png", "channel": 0, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3lXGzM.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[335, 335, 403, 403, 506], [509, 509, 586, 586, 826], [857, 857, 892, 892, 916], [918, 918, 941, 941, 1090], [1092, 1120, 1151, 1151, 1307], [1309, 1309, 1359, 1359, 1762], [1765, 1765, 1818, 1818, 1881], [1883, 1883, 1910, 1910, 1971], [1973, 1973, 2041, 2041, 2170], [2172, 2172, 2208, 2208, 2242], [2244, 2311, 2332, 2332, 2466], [2469, 2469, 2504, 2504, 4950], [4952, 5016, 5061, 5061, 5585], [5587, 5587, 5651, 5651, 5829], [5831, 5831, 5870, 5870, 6383], [6704, 6704, 6752, 6752, 7212], [7214, 7214, 7258, 7258, 7382], [7386, 7386, 7440, 7440, 9567]], "test": "error"}
{"id": "3s2SDd", "name": "Basics - Geometry", "author": "trevorleake", "description": "Studying methods of geometry.", "tags": ["geometry", "basics"], "likes": 1, "viewed": 57, "published": "Public", "date": "1555372687", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float line(vec2 uv, float height, float width) \n{\n    return smoothstep(height-width/2., height, uv.y) // Add what's above the line's bottom\n         - smoothstep(height, height+width/2., uv.y); // Subtract what's above the line's top\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/min(iResolution.x, iResolution.y);\n\n    vec3 col = vec3(line(uv, .5+sin(iTime)*.5, .02), 0, 0);\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3s2SDd.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 49, 49, 236], [239, 239, 296, 346, 528]], "test": "ok"}
{"id": "3s2SR3", "name": "Grid Slider", "author": "MacSlow", "description": "During dinner I had this idea after seeing Passion's \"World War Zed\" (https://www.shadertoy.com/view/3dBSz3)... it worked out for the most part (minus the bugs :). The cell-index is a bit underused for introducing more variations per cell-scene.", "tags": ["2d", "3d", "raymarching", "phong", "grid", "sdf", "fbm", "shadow", "blinn"], "likes": 9, "viewed": 390, "published": "Public API", "date": "1554510922", "time_retrieved": "2021-10-01T00:00:00", "image_code": "////////////////////////////////////////////////////////////////////////////////\n//\n// Grid Slider - Passion's \"World War Zed\" gave me the idea for trying this\n// collage-like thing. Passion's shader is https://www.shadertoy.com/view/3dBSz3\n//\n// Copyright 2019 Mirco Müller\n//\n// Author(s):\n//   Mirco \"MacSlow\" Müller <macslow@gmail.com>\n//\n// This program is free software: you can redistribute it and/or modify it\n// under the terms of the GNU General Public License version 3, as published\n// by the Free Software Foundation.\n//\n// This program is distributed in the hope that it will be useful, but\n// WITHOUT ANY WARRANTY; without even the implied warranties of\n// MERCHANTABILITY, SATISFACTORY QUALITY, or FITNESS FOR A PARTICULAR\n// PURPOSE.  See the GNU General Public License for more details.\n//\n// You should have received a copy of the GNU General Public License along\n// with this program.  If not, see <http://www.gnu.org/licenses/>.\n//\n////////////////////////////////////////////////////////////////////////////////\n\nmat2 r2d (float degree)\n{\n\tfloat r = radians (degree);\n    float c = cos (r);\n    float s = sin (r);\n    return mat2 (c,  s, -s,  c);\n}\n\n// hash(), noise3d() & fbm() are from iq or shane iirc\nfloat hash (float f)\n{\n\treturn fract (sin (f) * 45785.5453);\n}\n\nfloat noise3d (vec3 p)\n{\n    vec3 u = floor (p);\n    vec3 v = fract (p);\n    \n    v = v * v * (3. - 2. * v);\n\n    float n = u.x + u.y * 57. + u.z * 113.;\n    float a = hash (n);\n    float b = hash (n + 1.);\n    float c = hash (n + 57.);\n    float d = hash (n + 58.);\n\n    float e = hash (n + 113.);\n    float f = hash (n + 114.);\n    float g = hash (n + 170.);\n    float h = hash (n + 171.);\n\n    float result = mix (mix (mix (a, b, v.x),\n                             mix (c, d, v.x),\n                             v.y),\n                        mix (mix (e, f, v.x),\n                             mix (g, h, v.x),\n                             v.y),\n                        v.z);\n\n    return result;\n}\n\nfloat fbm (vec3 p)\n{\n\tmat2 m1 = r2d (1.1 * iTime);\n\tmat2 m2 = r2d (-1.2 * iTime);\n\tmat2 m3 = r2d (iTime);\n\n    float result = .0;\n    result = 0.5 * noise3d (p);\n    p.xz *= m1 * 2.02;\n    result += 0.25 * noise3d (p);\n    p.xz *= m2 * 2.03;\n    result += 0.125 * noise3d (p);\n    p.xz *= m3 * 2.04;\n    result += 0.0625 * noise3d (p);\n    result /= 0.9375;\n\n    return result;\n}\n\nfloat sdThing (in vec3 p, in int type, inout vec3 objectUVW) {\n    float d = .0;\n    if (type == 0) { // wavy ball\n    \tfloat r = .5 + .1*(.5 + .5*cos (5.*iTime + 25.*p.y));\n\t    d = length (p) - r;\n    } else if (type == 1) { // turning cube\n        p.xz *= r2d (25.*iTime);\n        p.yz *= r2d (67.*iTime);\n        d = length (max (vec3 (.0), abs (p) - vec3 (.3))) - .05;\n    } else if (type == 2){ // spiky ball\n        float x = .5 + .5*cos (5.*(iTime + 2.) + 17.*p.x);\n        float y = .5 + .5*cos (5.*(iTime + 4.) + 17.*p.y);\n        float z = .5 + .5*cos (5.*(iTime + 6.) + 17.*p.z);\n    \tfloat r = .5 + .1*(x + y + z);\n        d = length (p) - r;\n    }\n\n\tobjectUVW = p;\n\n    return d;\n}\n\nfloat map (in vec3 p, in int type, inout vec3 objectUVW, inout int id) {\n    float g = p.y + 2.;\n    float w = p.z + 2.;\n    vec3 s = p;\n    vec3 t;\n    float b = sdThing (p, type, t);\n    float d = min (g, min (w, b));\n    if (d == g || d == w) {\n        objectUVW = s;\n        id = 0;\n    } else if (d == b) {\n        objectUVW = t;\n    \tid = 1;\n    }\n    return d;\n}\n\nfloat march (in vec3 ro, in vec3 rd, in int type, inout vec3 objectUVW, inout int id)\n{\n    float t = .0;\n    float d = .0;\n    vec3 p = vec3 (.0);\n    for (int i = 0; i < 64; ++i) {\n        p = ro + d*rd;\n        t = map (p, type, objectUVW, id);\n        if (abs (t) < .0001*(1. + .125*t)) break;\n        d += t*.75;\n    }\n\treturn d;\n}\n\nvec3 normal (in vec3 p, in int type) {\n    vec3 ignored1;\n    int ignored2;\n    float d = map (p, type, ignored1, ignored2);\n    vec2 e = vec2 (.001, .0);\n    return normalize (vec3 (map(p + e.xyy, type, ignored1, ignored2),\n                            map(p + e.yxy, type, ignored1, ignored2),\n                            map(p + e.yyx, type, ignored1, ignored2)) - d);\n}\n\nfloat shadow (in vec3 p, in vec3 n, in vec3 ldir, in float ldist, in int type) {\n    vec3 ignored1;\n    int ignored2;\n    float d2w = march (p + .01*n, ldir, type, ignored1, ignored2);\n    return ldist < d2w ? 1. : .5;\n}\n\nvec3 shade (in vec3 ro,\n            in vec3 rd,\n            in float d,\n            in vec3 n,\n            in vec3 lc,\n            in vec3 lp,\n            in float lshiny,\n            in int type,\n            in vec3 objectUVW,\n            in int id) {\n    vec3 amb = vec3 (.05);\n    vec3 p = ro + d*rd;\n    vec3 ldir = normalize (lp - p);\n    float ldist = distance (lp, p);\n    float diff = max (.0, dot (n, ldir));\n    float att = 4./(ldist*ldist);\n    float li = 2.;\n    vec3 mat = vec3 (.0);\n    if (id == 1 && type == 0) { // wavy ball\n        float m = smoothstep (.1, .2, .5 + .5*(cos (40.*objectUVW.x) * cos(40.*objectUVW.z)));\n        mat = mix (vec3 (1.), vec3 (.0), m);\n    }\n    else if (id == 1 && type == 1) { // turning cube\n        float m = smoothstep (.1, .2, .5 + .5*cos (20.*objectUVW.x));\n        float n = smoothstep (.1, .2, .5 + .5*cos (20.*objectUVW.y));\n        float o = smoothstep (.1, .2, .5 + .5*cos (20.*objectUVW.z));\n        mat = mix (vec3 (.125, .0, .25), vec3 (1., 1., 0), m*n*o);\n    }\n    else if (id == 1 && type == 2) { // spiky ball\n        float m = smoothstep (.2, .4, .5 + .5*cos (500.*objectUVW.x*objectUVW.y*objectUVW.z));\n        mat = mix (vec3 (.125, .25, .5), vec3 (.5, .25, .125), m);\n    }\n    else\n        mat = vec3 (.25);\n\n    float s = shadow (p, n, ldir, ldist, type);\n    vec3 h = normalize(-rd + ldir);\n    float sp = pow (max (.0, dot (n, h)), lshiny);\n\n\treturn amb + att*s*(diff*lc*li*mat + sp*vec3 (1.));\n}\n\nvec3 cam (in vec2 uv, in vec3 ro, in vec3 aim, in float zoom) {\n\tvec3 f = normalize (aim - ro);\n    vec3 wu = vec3 (.0, 1., .0);\n    vec3 r = normalize (cross (wu, f));\n    vec3 u = normalize (cross (f, r));\n    vec3 c = ro + f*zoom;\n    return normalize (c + r*uv.x + u*uv.y - ro);\n}\n\nvec3 miniRaymarcher (in vec2 uv,\n                     in vec3 lc,\n                     in vec3 lp,\n                     in float lshiny,\n                     in int type,\n                     in float offset,\n                     in float aspect)\n{\n    uv = uv*2. - 1.;\n    uv.x *= aspect;\n\n    vec3 ro = vec3 (2.*cos(iTime + offset), .75, 1.);\n    vec3 aim = vec3 (.0);\n    float zoom = 2.;\n    vec3 rd = cam (uv, ro, aim, zoom);\n    vec3 objectUVW = vec3 (.0);\n    int id = 0;\n    float d = march (ro, rd, type, objectUVW, id);\n    vec3 p = ro + d*rd;\n    vec3 n = normal (p, type);\n    vec3 col = shade (ro, rd, d, n, lc, lp, lshiny, type, objectUVW, id);\n    col += shade (ro, rd, d, n, lc, lp + vec3 (-1., .0, .0), lshiny, type, objectUVW, id);\n    col += shade (ro, rd, d, n, lc, lp + vec3 (1., .0, 1.), lshiny, type, objectUVW, id);\n\n    col *= 1. - .25*length (uv);\n\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy*2. - 1.;\n    uv.x *= iResolution.x/iResolution.y;\n    uv *= r2d (20.*cos (iTime));\n    uv *= 1. + .25*length (vec2 (uv.x + .3*cos(2.*iTime + 8.*uv.y), uv.y));\n\n    vec3 col = vec3 (.0);\n    vec2 scale = 1.125*vec2 (1., 1.75);\n    vec2 grid = fract (uv*scale);\n    vec2 cell = floor (uv*scale);\n    float aspect = scale.y/scale.x;\n\n    uv.x += .5*(iTime+15.)*abs ((fbm (vec3 (cell.y + .75))));\n    grid = fract (uv*scale);\n    cell = floor (uv*scale);\n\n    float d = length (grid*2. - 1.) - .02;\n    float m = smoothstep (.01, .02, d);\n    col = vec3 (1. - m);\n    float r = fbm (vec3(cell+1., cell.x));\n    float g = fbm (vec3(cell+2., cell.y));\n    float b = fbm (vec3(cell.x, cell+3.));\n    float x = fbm (vec3(cell+2., cell.x));\n    float y = fbm (vec3(cell+4., cell.y));\n    float z = fbm (vec3(cell.x, cell+2.));\n    float shiny = 60.*fbm (vec3(cell, cell.x));\n    float offset = cos (iTime + cell.x + cell.y);\n    col = miniRaymarcher (grid,\n                          vec3 (r, g, b),\n                          vec3 (x, y, z),\n                          shiny,\n                          int(mod (floor(cell.x + cell.y),3.)),\n                          offset,\n                          aspect);\n\n    col = col/(1. + col);\n    col = pow (col, vec3 (1./2.2));\n    col *= mix (1., .5, .5 + .5*cos (600.*uv.y));\n\n    fragColor = vec4 (col, 1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3s2SR3.jpg", "access": "shaders20k", "license": "gpl-3.0", "functions": [[1037, 1037, 1062, 1062, 1172], [1174, 1229, 1251, 1251, 1291], [1293, 1293, 1317, 1317, 1991], [1993, 1993, 2013, 2013, 2372], [2374, 2374, 2436, 2436, 3069], [3071, 3071, 3143, 3143, 3440], [3442, 3442, 3529, 3529, 3778], [3780, 3780, 3818, 3818, 4152], [4154, 4154, 4234, 4234, 4374], [4376, 4376, 4628, 4628, 5845], [5847, 5847, 5910, 5910, 6131], [6133, 6133, 6381, 6381, 7025], [7027, 7027, 7084, 7084, 8469]], "test": "timeout"}
{"id": "3s2SRV", "name": "Capsule - bounding box", "author": "iq", "description": "Bounding box of a capsule", "tags": ["3d", "capsule", "bounding", "bbox"], "likes": 6, "viewed": 547, "published": "Public API", "date": "1554377948", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// The MIT License\n// Copyright © 2019 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// Bounding box of a capsule\n\n\n// Other capsule functions:\n//\n// Capsule intersection: https://www.shadertoy.com/view/Xt3SzX\n// Capsule bounding box: https://www.shadertoy.com/view/3s2SRV\n// Capsule distance:     https://www.shadertoy.com/view/Xds3zN\n// Capsule occlusion:    https://www.shadertoy.com/view/llGyzG\n\n\n// Other bounding box functions:\n//\n// Disk             - 3D BBox : https://www.shadertoy.com/view/ll3Xzf\n// Cylinder         - 3D BBox : https://www.shadertoy.com/view/MtcXRf\n// Ellipse          - 3D BBox : https://www.shadertoy.com/view/Xtjczw\n// Cone             - 3D BBox : https://www.shadertoy.com/view/WdjSRK\n// Capsule          - 3D Bbox : https://www.shadertoy.com/view/3s2SRV\n// Cubic     Bezier - 2D BBox : https://www.shadertoy.com/view/XdVBWd \n// Quadratic Bezier - 3D BBox : https://www.shadertoy.com/view/ldj3Wh\n// Quadratic Bezier - 2D BBox : https://www.shadertoy.com/view/lsyfWc\n\n\n\n#define AA 3\n\nstruct bound3\n{\n    vec3 mMin;\n    vec3 mMax;\n};\n    \n//---------------------------------------------------------------------------------------\n// bounding box for a capsule\n//---------------------------------------------------------------------------------------\nbound3 CapsuleAABB( in vec3 pa, in vec3 pb, in float ra )\n{\n    vec3 a = pb - pa;\n    \n    return bound3( min( pa - ra, pb - ra ),\n                   max( pa + ra, pb + ra ) );\n}\n\n// http://www.iquilezles.org/www/articles/intersectors/intersectors.htm\nfloat iCapsule( in vec3 ro, in vec3 rd, in vec3 pa, in vec3 pb, in float r )\n{\n    vec3  ba = pb - pa;\n    vec3  oa = ro - pa;\n\n    float baba = dot(ba,ba);\n    float bard = dot(ba,rd);\n    float baoa = dot(ba,oa);\n    float rdoa = dot(rd,oa);\n    float oaoa = dot(oa,oa);\n\n    float a = baba      - bard*bard;\n    float b = baba*rdoa - baoa*bard;\n    float c = baba*oaoa - baoa*baoa - r*r*baba;\n    float h = b*b - a*c;\n    if( h>=0.0 )\n    {\n        float t = (-b-sqrt(h))/a;\n\n        float y = baoa + t*bard;\n        \n        // body\n        if( y>0.0 && y<baba ) return t;\n\n        // caps\n        vec3 oc = (y<=0.0) ? oa : ro - pb;\n        b = dot(rd,oc);\n        c = dot(oc,oc) - r*r;\n        h = b*b - c;\n        if( h>0.0 )\n        {\n            return -b - sqrt(h);\n        }\n    }\n    return -1.0;\n}\n\n// compute normal\nvec3 capNormal( in vec3 pos, in vec3 a, in vec3 b, in float r )\n{\n    vec3  ba = b - a;\n    vec3  pa = pos - a;\n    float h = clamp(dot(pa,ba)/dot(ba,ba),0.0,1.0);\n    return (pa - h*ba)/r;\n}\n\n\n// ray-box intersection\nvec2 iBox( in vec3 ro, in vec3 rd, in vec3 cen, in vec3 rad ) \n{\n    vec3 m = 1.0/rd;\n    vec3 n = m*(ro-cen);\n    vec3 k = abs(m)*rad;\n\t\n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n\n\tfloat tN = max( max( t1.x, t1.y ), t1.z );\n\tfloat tF = min( min( t2.x, t2.y ), t2.z );\n\t\n\tif( tN > tF || tF < 0.0) return vec2(-1.0);\n\n\treturn vec2( tN, tF );\n}\n\n\nfloat hash1( in vec2 p )\n{\n    return fract(sin(dot(p, vec2(12.9898, 78.233)))*43758.5453);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 tot = vec3(0.0);\n    \n#if AA>1\n    for( int m=0; m<AA; m++ )\n    for( int n=0; n<AA; n++ )\n    {\n        // pixel coordinates\n        vec2 o = vec2(float(m),float(n)) / float(AA) - 0.5;\n        vec2 p = (-iResolution.xy + 2.0*(fragCoord+o))/iResolution.y;\n#else    \n        vec2 p = (-iResolution.xy + 2.0*fragCoord)/iResolution.y;\n#endif\n\n        // camera position\n        vec3 ro = vec3( -0.5, 0.4, 1.5 );\n        vec3 ta = vec3( 0.0, 0.0, 0.0 );\n        // camera matrix\n        vec3 ww = normalize( ta - ro );\n        vec3 uu = normalize( cross(ww,vec3(0.0,1.0,0.0) ) );\n        vec3 vv = normalize( cross(uu,ww));\n        // create view ray\n        vec3 rd = normalize( p.x*uu + p.y*vv + 1.5*ww );\n\n        // cylidner animation\n        vec3  c_a =  0.2 + 0.3*sin(iTime*vec3(1.11,1.27,1.47)+vec3(2.0,5.0,6.0));\n        vec3  c_b = -0.2 + 0.3*sin(iTime*vec3(1.23,1.41,1.07)+vec3(0.0,1.0,3.0));\n        float c_ra =  0.3 + 0.2*sin(iTime*1.3+0.5);\n\n        // render\n        vec3 col = vec3(0.4)*(1.0-0.3*length(p));\n\n        // raytrace\n        float t = iCapsule( ro, rd, c_a, c_b, c_ra );\n        float tmin = 1e10;\n        if( t>0.0 )\n        {\n            tmin = t;\n            // shading/lighting\t\n            vec3 pos = ro + t*rd;\n            vec3 nor = capNormal( pos, c_a, c_b, c_ra );\n\n            float dif = clamp( dot(nor,vec3(0.5,0.7,0.2)), 0.0, 1.0 );\n            float amb = 0.5 + 0.5*dot(nor,vec3(0.0,1.0,0.0));\n            col = sqrt( vec3(0.2,0.3,0.4)*amb + vec3(0.8,0.7,0.5)*dif );\n            col *= vec3(1.0,0.75,0.3);\n        }\n\n\n        // compute bounding box of cylinder\n        bound3 bbox = CapsuleAABB( c_a, c_b, c_ra );\n\n        // raytrace bounding box\n        vec3 bcen = 0.5*(bbox.mMin+bbox.mMax);\n        vec3 brad = 0.5*(bbox.mMax-bbox.mMin);\n        vec2 tbox = iBox( ro, rd, bcen, brad );\n        if( tbox.x>0.0 )\n        {\n            // back face\n            if( tbox.y < tmin )\n            {\n                vec3 pos = ro + rd*tbox.y;\n                vec3 e = smoothstep( brad-0.03, brad-0.02, abs(pos-bcen) );\n                float al = 1.0 - (1.0-e.x*e.y)*(1.0-e.y*e.z)*(1.0-e.z*e.x);\n                col = mix( col, vec3(0.0), 0.25 + 0.75*al );\n            }\n            // front face\n            if( tbox.x < tmin )\n            {\n                vec3 pos = ro + rd*tbox.x;\n                vec3 e = smoothstep( brad-0.03, brad-0.02, abs(pos-bcen) );\n                float al = 1.0 - (1.0-e.x*e.y)*(1.0-e.y*e.z)*(1.0-e.z*e.x);\n                col = mix( col, vec3(0.0), 0.15 + 0.85*al );\n            }\n        }\n\n        // no gamma required here, it's done in line 118\n\n        tot += col;\n#if AA>1\n    }\n    tot /= float(AA*AA);\n#endif\n\n    // dithering\n    tot += ((hash1(fragCoord.xy)+hash1(fragCoord.yx+13.1))/2.0 - 0.5)/256.0;\n\n\n\tfragColor = vec4( tot, 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3s2SRV.jpg", "access": "shaders20k", "license": "mit", "functions": [[2062, 2272, 2331, 2331, 2450], [2452, 2524, 2602, 2602, 3333], [3335, 3353, 3418, 3418, 3544], [3547, 3571, 3635, 3635, 3915], [3918, 3918, 3944, 3944, 4011]], "test": "ok"}
{"id": "3s2SWc", "name": "witch'sFog", "author": "ukeyshima", "description": "witch'sFog", "tags": ["raymarching"], "likes": 2, "viewed": 179, "published": "Public API", "date": "1555142875", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI 3.141592\n\nfloat random1(vec3 p){\n    return fract(sin(dot(p.xyz,vec3(12.9898,46.2346,78.233)))*43758.5453123)*2.0-1.0;\n}\n\nfloat random2(vec3 p){\n    return fract(sin(dot(p.xyz,vec3(73.6134,21.6712,51.5781)))*51941.3781931)*2.0-1.0;\n}\n\nfloat random3(vec3 p){\n    return fract(sin(dot(p.xyz,vec3(39.1831,85.3813,16.2981)))*39183.4971731)*2.0-1.0;\n}\n\nfloat perlinNoise(vec3 p){\n    vec3 i1=floor(p);    \n    vec3 i2=i1+vec3(1.0,0.0,0.0);\n    vec3 i3=i1+vec3(0.0,1.0,0.0);\n    vec3 i4=i1+vec3(1.0,1.0,0.0);\n    vec3 i5=i1+vec3(0.0,0.0,1.0);\n    vec3 i6=i1+vec3(1.0,0.0,1.0);\n    vec3 i7=i1+vec3(0.0,1.0,1.0);\n    vec3 i8=i1+vec3(1.0,1.0,1.0);\n    vec3 f1=vec3(random1(i1),random2(i1),random3(i1));\n    vec3 f2=vec3(random1(i2),random2(i2),random3(i2));\n    vec3 f3=vec3(random1(i3),random2(i3),random3(i3));\n    vec3 f4=vec3(random1(i4),random2(i4),random3(i4));\n    vec3 f5=vec3(random1(i5),random2(i5),random3(i5));\n    vec3 f6=vec3(random1(i6),random2(i6),random3(i6));\n    vec3 f7=vec3(random1(i7),random2(i7),random3(i7));\n    vec3 f8=vec3(random1(i8),random2(i8),random3(i8));\n    vec3 k1=p-i1;\n    vec3 k2=p-i2;\n    vec3 k3=p-i3;\n    vec3 k4=p-i4;\n    vec3 k5=p-i5;\n    vec3 k6=p-i6;\n    vec3 k7=p-i7;\n    vec3 k8=p-i8;\n    vec3 j=fract(p);\n    j=j*j*(3.0-2.0*j);\n\treturn mix(mix(mix(dot(f1,k1),dot(f2,k2),j.x),mix(dot(f3,k3),dot(f4,k4),j.x),j.y),mix(mix(dot(f5,k5),dot(f6,k6),j.x),mix(dot(f7,k7),dot(f8,k8),j.x),j.y),j.z)*0.95+0.05;\n}\n\nfloat octavePerlinNoise(vec3 p){\n    float value=0.0;\n    float maxValue=0.0;\n    for(float i=0.0;i<5.0;i++){\n        value+=pow(0.5,i)*perlinNoise(vec3(p.x*pow(2.0,i),p.y*pow(2.0,i),p.z*pow(2.0,i)));\n        maxValue+=pow(0.5,i);\n    }\n    return value/maxValue;\n}\n\nvec3 rayMarching(vec2 p) {\n    vec3 cPos = vec3(0.0, 0.0, iTime/5.0);\n    vec3 cDir = vec3(0.0, 0.0, 1.0);\n    vec3 cUp = vec3(sin(iTime/30.0), cos(iTime/30.0), 0.0);\n    float depth = 1.0;    \n    vec3 cSide = cross(cDir, cUp);\n    vec3 ray = normalize(cSide * p.x + cUp * p.y + cDir * depth);\n    vec3 rPos = cPos;    \n    vec3 color = vec3(50.0,0.0,0.0);\n    for (float i = 0.0; i < 5.0; i++) {\n        color+=vec3(1.0/octavePerlinNoise(rPos));\n        color=mix(color,mod(color,0.5),0.5);        \n        rPos+=ray*2.0;\n    }\n  return color;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  vec2 p =\n      (fragCoord.xy * 2.0 - iResolution.xy) / min(iResolution.x, iResolution.y);\n    vec3 color = rayMarching(p);\n    fragColor =vec4(color,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3s2SWc.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[21, 21, 43, 43, 131], [133, 133, 155, 155, 244], [246, 246, 268, 268, 357], [359, 359, 385, 385, 1449], [1451, 1451, 1483, 1483, 1716], [1718, 1718, 1744, 1744, 2265], [2267, 2267, 2322, 2322, 2481]], "test": "ok"}
{"id": "3s2Szy", "name": "4tap kerning for euler & euclid", "author": "ollj", "description": "kerning,2tap,4tap,interval,optimization,mod,fract,integral,hash,polynom,analysis,euler,euclid,calculus,polynomial,set\n", "tags": ["mod", "optimization", "fract", "integral", "set", "hash", "polynomial", "analysis", "euler", "interval", "euclid", "calculus", "polynom", "kerning", "2tap", "4tap"], "likes": 1, "viewed": 358, "published": "Public API", "date": "1554236628", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec4 iMouseZwFix(vec4 m,bool NewCoke\n ){if(m.z>0.){ //while mouse down\n    if(m.w>0.)return m;//mouse was clicked in THIS     iFrame \n    else m.w=-m.w      //mosue was clicked in previous iFrame\n    //remember, MouseDrag advances the iFrame Count, even while paused !!\n ;}else{if(!NewCoke||m.w>0.)return m.xyxy; //OPTIONAL onMouseUp (fold or whatever)\n    m.zw=-m.zw;}\n  return m;}\n\n/* start.Head_UI:\n\nyou may want to pause time\nyou may want to remove the line; //#define noNoise\nyou may want to do; #define ViewSvivel  //to rotate swap .x and .y of the view.\n\nMouse sets.xyzw coefficients, as a simple way to degine a continuous curve\nMouse.x sets cubic    ==cubic         change over x\nMouse.y sets null     ==baseline      height.y at x=0;\nMouse.z sets linear   ==linear        change\nMouse.w sets quadratic==quadratic a*a change\n*/\n\n//named [euler and euclid] for a fictional argument about infinitessimals\n//this is not intended as graph plotter, though it can be used as a bad one\n//this explores 2tap and 4tap of boxes along time.x, of different height.y\n//this is intended to draw glyphs, that are composed of up to 3 combined note-symbols\n//it is only slighly trickier in its .y scaling than its parent, that does circles\n//and it extends his parent to optional 4tap-ping\n\n/* start.Head:hash_for_Euler+Euclid\nkerning,2tap,4tap,interval,optimization,mod,fract,integral,hash,polynom,analysis,euler,euclid,calculus,polynomial,set\n\nparent     : https://www.shadertoy.com/view/MlscWn\ngrandfather: https://www.shadertoy.com/view/4llcWn\ngrandmother: https://www.shadertoy.com/view/Xtscz7\n replaced a hash with a Polynomial_3rd_deg,then mixed the hash back in.\n*/\n\n/* end__.Head_UI\n   start.Manual\n/*\n\nFor hashed bands of [bounding volumes] to be filled with dots, moons, noteGlyphs\nthis variant one makes boxes, for sake of simplicity\n\nBy using multi-tapping along one domain, this turns any y=f(x)curve(including HASH,noise)into a dotted/boxed line.\n of any(homogeneous)period.x,interval.x \n WITHOUT A LOOP,by using fract()\np4()returns y=f(x)where f(x)is a (general) cubic polynomial.\n\nThis generalization blurs some lines between analysis,hashes and RNG.LCG.PCG\n ==Random/Linear/Permuted Number/Congruential/Congruential Generator\nThis makes me wonder what loops can be converted into single passes with fract()\n And what the constrains to types of loops are that can be turned to fract().\n And when it is worth it,and when not.\n\nthis still only works for a regular interval.x\n, needs a piececise bijection (+inverse) to tretch some parts of this regular interval into an irregular interval\n- this would then do non-monospace-glyph kerning\n\nThe gradient is good within the mod()interval,\nJust make sure that the visible parts(dots)are within boundingVolume==interval==[i]\nthis safe zone is shown as [c.xy] boxes.\nc.w goes outside of this bound, chich is mostly fine, as long as it implies c0-continuity of its higher context.\nLeonard Euler: The best inverval is [i]==0;\n...\n*/\n\n/* end__.Manual\n   start.Manual.Parameters\n*/\n//2tap (or 4tap) along 1 domain.x for overlapping notes\n//4tap is often uneccessary, but a reasonable upper bound for opengl vec4 types.\n#define do4taps\n//with [do4taps], this is not too different from a [fibonacci sphere]\n\n#define noNoise\n\n//sub-pixel blur\n#define bokeh 14./min(iResolution.x,iResolution.y)\n\n//swivel view,make .y horizontal,more horizontal ScreenSpace for higher exponents.\n//#define ViewSvivel\n\n//with intervals, we always have the near-asymptotic case of invervals being too close to a length of 0.\n//this then divides by 0, or by a very small number.\n//we have various ways to envelope this tobe more worksafe:\n\n//  set period,interval==[i]~0,not just VERY small,but actually divide by 0.\n//   Just to screw with(or implement basiccalculus)analysis on a fundamental level!\n//   TestDivideByZeroCase==0 will calculate;.0*vec2(fract(a/.0),floor(a/.0));\n//  Effects of settings depend on implementation:\n//     Leonard Euler : ==0 This is fine,I define this as being fine, as long as your function is c0 continuous!\n//fract(Congruental Generator): ==0 ; No it is not fine! Null-State equals death!\n//    Low IEEE precision: ==1 ; Where is my hash! Screw you,all of you!\n//  Heuristic large epsilon: ==2 ;Whatever,this is as close as we can get!\n//    Euclidean Unit circle: ==-1 ;Null-State-death only affects me tangentially\n#define TestDivideByZeroCase -1\n\n//control speed of time,to make time static or negative.\n#define TimeS (iTime-1.)\n//-1. offsetmakes a better thumbnail for the first frame\n//-1. also offsets from [the initial VOID-state]:\n// Because Shadertoy has the PATHETIC error that iTime and iGlobalTime are not initialized.\n// iTime and iGlobalTime are initially ==NullPointer!=0. \n// This confuses many webgl implementations,eg: when using i=cos(acos(-1.)+iTime);\n// cos(acos(-1.)+0.)==-1. is fine.\n//(NullPointer +0.)!=0. confuses many implementations. ->black screen on iTime==0.\n\n\n/* end__.Manual.Parameters\n   start.Lib.Frame.8 (reduced,as this is a simple (mostly 1d) demo)\n//this is based on a 2017-ish library.\n*/\n//  HasMix linear interpolates between a hasn and a PolynomialWithExponent3\n#define MixHashPoly3 u5(cos(TimeS*0.61))\n//#define MixHashPoly3 .0\n\n\n//View.Frame\n#define fra(u)(u-.5*iResolution.xy)*ViewZoom/iResolution.y\n\n//2d zoom\n#define ViewZoom 6.\n//divide by/aa for hairline drawing and sharp smoothstep()\n#define Aa (min(iResolution.x,iResolution.y)/ViewZoom)\n#define fra(u)(u-.5*iResolution.xy)*ViewZoom/iResolution.y//usually first function of mainImage(),not typecast.\n\n\n//library of often used functions: //ounting,index starts at 0!\n#define v0 float\n#define v1 vec2\n#define v2 vec3\n#define v3 vec4\n//triangle wave //euclidean grid\n#define tri(a)abs(u2(fract(a)))\n#define grid(a)mav(tri(a))\n#define u5(a) ((a)*.5+.5)\nv0 sat2(v0 a,v1 m){a=.5*(sign(a)+m.x)*a+m.y;a=(sign(2.-a)+1.)*(a-2.)+2.;return a*.5;}\n#define dd(a)dot(a,a)\n//perpendicular ==90deg rotation\nv1 perp(v1 a){return v1(-a.y,a.x);}\n//---trigonometry,rotations and(distance to)Quadratic functions.\n//(distance to quadratic is a cubic with less than 2 intersections==roots)\n#define cs(a)vec2(cos(a),sin(a))\n//mirror p at half rotated axis==cheap SINGLE 2d rotation.\n#define rs(r)mat2(sin(r+vec4(1,0,0,-1)*asin(1.)))\n//golden ratios are the best factors for hashes because;phi.xy-1.=1/phi.xy\n\n#define hs vec4(1031,.1030,.0973,.1099)\nv0 h11(v0 p){\n #ifdef noNoise \n  return 0.;//no hash, its just noisy\n #endif\n v2 f=fract(v2(p)*hs.y);f+=dot(f,f.yzx+19.19);\n return fract((f.x+f.y)*f.z);}\n \nv0 p3(v0 a,v3 m//eval polynomial a=.x return .y;  [m]=coefficients\n){//return m.x+a*m.y+a*a*m.z+a*a*a*m.w;//lazy,worst\n //return dot(vec4(1),m*vec4(1.,a*vec3(1,a*vec2(1.,a))));//overly explicit vector processor\n return dot(vec4(1),m*vec4(1.,a,a*a,a*a*a));//explicit vector processor\n return m.x+a*(m.y+a*(m.z+a* m.w));//explixit MAD()(better precision)\n ;}//#define p3(u,f)(f.x+u*f.y+(u*u)*f.z+(u*u*u)*f.w)\n\n//a mix(interpolate between)a polynom.y and a hash.y\nfloat ph(float a,vec4 m){return mix(h11(a),p3(a,m),MixHashPoly3);}\n\n//assert a=abs(a)\n#define boxN(a,b) max(a,abs(b))\n\nvoid mainImage(out vec4 O,in vec2 U\n){vec4 mouse=iMouseZwFix(iMouse,true)\n ;vec2 u =fra(U);vec4 m=vec4(fra(mouse.xy),fra(mouse.zw))\n #ifdef ViewSvivel\n  ;u=u.yx;m=m.yxwz;//swivel view,use horizontal space to show higher exponentials.\n #endif\n ;float t=TimeS\n ;float i=u5(cos(acos(-1.)+t))\n //i=interval of dots,goes all the way to 0,maybe not on linux.\n //testing limited precision(of IEEE float)\n #if   TestDivideByZeroCase==0\n  ;i=.000000;\n #elif TestDivideByZeroCase==1 \n  ;i=.000001;\n #elif TestDivideByZeroCase==2\n  ;i=.000020;\n #endif\n ;vec2 x=i*vec2(fract(u.x/i),floor(u.x/i));//dividing by 0,or very small values,here.\n //and then multiplying by the same(asmall number).\n \n //m=vec4(-1);//static debug overwrite\n ;m.xyzw=m.ywzx;//swivel coefficients to something that makes more sense \n      // for mouse.xy inputs.\n ;vec4 a=vec4(ph(x.y,m),ph(x.y+i,m),ph(x.y-i,m),ph(x.y+i*2.,m))//position.y of \n ;a=u.y-a\n #ifdef do4taps\n  ;a=abs(a)+i //make slimmer than wide (brick shape)\n #else\n  ;a=abs(a)+i*(1.-1./4) //make slimmer than wide (brick shape)\n #endif\n #if 1\n  //below is the 2tap\n  ;float f=min(boxN(a.x,x.x) //halfDot on the left  side of a period.\n               ,boxN(a.y,x.x-i));//halfDot on the right side of a period.\n  //above is 2tap, below is +2taps:\n  #ifdef do4taps\n   ;f=min(f,boxN(a.z,x.x+i))\n   ;f=min(f,boxN(a.w,x.x-i*2.))\n   ;i*=2.//optionally we can nor double note didth\n  #endif\n #else\n  //same as above, but crunched (always does 4tap)\n  ;vec4 n=x.x-vec4(0,1,-1,2)*i\n  ;n=boxN(a,n)\n  ;float f=min(min(n.x,n.y),min(n.z,n.w))//min of 4 distances\n  ;i*=2.\n #endif\n ;vec4 c=vec4(0)\n ;c.x=smoothstep(bokeh,-bokeh,abs(f-i+bokeh*2.)-bokeh)//red shows a box-outline of [safe space]\n ;c.y=smoothstep(bokeh,-bokeh,   (f-i+bokeh*2.)-bokeh)//green is red, but filled in\n //red and green scale by *i, which can scale the size (close to) 0.\n ;c.w=smoothstep(bokeh,-bokeh,   (f  +bokeh*2.)-bokeh-.5*i-.2)//yellow has some minimum tickness\n  ;c.z=fract(f)//blue is base field (f), without scaling\n  //;c=mix(c,c.xxxx,u5(sin(iTime*acos(-1.))));//oscillate between showing;c.x;or;c\n ;c.rg=mix(c.rg,c.aa,.5)//mix a as yellow;\n ;O=vec4(c.xyz,1);}\n/* End__.Main\n   Start.Bisymmetry.4\n*/\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3s2Szy.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 40, 40, 382], [5809, 5809, 5828, 5828, 5894], [5917, 5950, 5964, 5964, 5985], [6384, 6384, 6397, 6397, 6538], [6541, 6541, 6610, 6751, 6897], [6949, 7002, 7027, 7027, 7068]], "test": "ok"}
{"id": "3s2XDd", "name": "Basics - Coordinate Translation", "author": "trevorleake", "description": "Study to see how translating shapes and coordinates works.", "tags": ["basics", "coordinates", "translate"], "likes": 1, "viewed": 162, "published": "Public", "date": "1555381502", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float box(vec2 uv, vec2 topLeft, vec2 bottomRight)\n{\n    return uv.x > topLeft.x && uv.x < bottomRight.x && uv.y < topLeft.y && uv.y > bottomRight.y ? 1. : 0.;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\t// Center our coordinate system    \n    vec2 uv = (fragCoord - .5*iResolution.xy) / min(iResolution.x, iResolution.y);\n    \n    // Move space by adding uniformally to all coordinates\n    \n    // Show space coordinates as colors on the background\n    vec3 col = vec3(uv.x,uv.y,0.0);\n    \n    float radius = .2;\n    uv += radius*vec2(sin(iTime), cos(iTime));\n    \n    col += box(uv, vec2(-.1,.1), vec2(.1,-.1));\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3s2XDd.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 52, 52, 161], [164, 164, 221, 258, 694]], "test": "ok"}
{"id": "3s2XRK", "name": "portalvideo game", "author": "lindademan", "description": "portal video game", "tags": ["portal", "videogame"], "likes": 1, "viewed": 170, "published": "Public", "date": "1554372221", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    vec4 col = texture(iChannel0,uv);\n    vec4 color1 = vec4(0.251,0.921,0.930,1.000);\n    vec4 color2 = vec4(0.214,0.708,0.900,1.000);\n\tvec4 colorp = mix(color2,color1,uv.y *sin(iTime));\n\t\n\tvec4 BG_color = texture(iChannel1,uv);\n\t\n\t//position portal vec2(0.5) is middel of the screen\n\tvec2 posPortal = vec2(0.5) * iResolution.xy;\n\tvec2 position = (fragCoord.xy-posPortal.xy)/ iResolution.y;\n\t//altering y position to make the circle oval form\n\tposition.y *= 0.5;\n\t//making the inner circle and outer circle\n\tfloat win = smoothstep(0.0, 0.03, 0.27-distance(position , vec2(0.0))); \n\tfloat wex = smoothstep(0.0, 0.05, 0.25-distance(position , vec2(0.0))); \n\t//combining the background color with the blue color \n\tvec4 portalcolor = mix(BG_color, colorp, win);\n\t//projecting the import image in the inside of the portal\n\tfragColor= mix(portalcolor,col, wex);\n}", "image_inputs": [{"id": "4sXGRn", "previewfilepath": "/media/ap/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg", "ctype": "texture"}, {"id": "4sf3zn", "previewfilepath": "/presets/webcam.png", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/presets/webcam.png", "ctype": "webcam"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3s2XRK.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 107, 1007]], "test": "error"}
{"id": "3s2XWV", "name": "Polycolor circles", "author": "avin", "description": "simple multi-color example", "tags": ["circles", "polycolor", "multicolor"], "likes": 4, "viewed": 306, "published": "Public API", "date": "1554986430", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define SIZE 10.\n\nfloat rand(vec2 co) { \n    return fract(sin(dot(co.xy , vec2(12.9898, 78.233))) * 43758.5453);\n} \n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{     \n    vec2 uv = (fragCoord.xy - iResolution.xy * 0.5) / iResolution.y;\n    \n    uv = uv * SIZE;\n    uv.x += floor(mod(uv.y, 2.0)) * iTime * 2.0 - iTime;\n    vec2 id = floor(uv);\n    vec2 gv = fract(uv) - 0.5;\n    \n    float sF = 1.5 * (SIZE / iResolution.y);         \n    float size = 0.4;\n    float colMask = smoothstep(size, size - sF, length(gv));\n        \n    vec3 circleColor = vec3(\n        rand(id),\n        rand(id + 1.0),\n        rand(id + 2.0)\n    );\n    \n    vec3 col = mix(vec3(1.0), circleColor, colMask);\n    \n    fragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3s2XWV.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[18, 18, 39, 39, 114], [117, 117, 174, 174, 735]], "test": "ok"}
{"id": "3s2XWW", "name": "The meaning of life", "author": "iapafoto", "description": "What the frog? Just playing with deformabed textures", "tags": ["texture", "frog"], "likes": 30, "viewed": 359, "published": "Public", "date": "1554469780", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Created by Sebastien DURAND - 2019\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n//----------------------------------------------------------------\n// Thanks to\n// Iq: Deformed tubes, distance field, shadows, etc. \n// Shane: Texture 3D, render\n//----------------------------------------------------------------\n\n// The far plane. I'd like this to be larger, but the extra iterations required to render the \n// additional scenery starts to slow things down on my slower machine.\n#define FAR 80.\n#define PI 3.14159265\n\nconst float slab = 0.05;\nconst float ani0 = 2.,  // Start Grow\n      ani1 = 6.,  \n      ani2 = 10.,  // start graine\n      ani3 = 20.,  // start move cam up\n      ani4 = 30.,  // start move to frogs\n\t  ani5 = 46.,  // start turn arround frogs\n      ani5b = 64., // To center of frogs\n      ani5b2 = 83., // Eye bottom\n      ani5c = 86., // Move hand \n      ani5d = 101., // Enter the ground\n\t  ani6 = 122., // Under the ground\n \t  ani7 = 129.;\n\nconst mat2 rot = mat2(cos(-.3),sin(-.3),-sin(-.3),cos(-.3));\n\nfloat dhaloLight, dhaloFrog;\nfloat sanim01, sanim12, sanim23, sanim34, sanim45, sanim56, sanim5cd, sanim56r, sanim67;\nfloat gPulse, gPulseGround;\n\n// --------------------------------------------------------------\n\nvec2 rotate( vec2 v, float a ) { return vec2( v.x*cos(a)+v.y*sin(a), -v.x*sin(a)+v.y*cos(a) ); }\nvec2 sincos( float x ) { return vec2( sin(x), cos(x) ); }\nvec3 opU( vec3 d1, vec3 d2 ){ return (d1.x<d2.x) ? d1 : d2;}\n\n\n// --------------------------------------------------------------\n// hash functions\n// --------------------------------------------------------------\nfloat hash( vec2 p ) { return fract(sin(1.0+dot(p,vec2(127.1,311.7)))*43758.545); }\nfloat hash( float n ){ return fract(cos(n)*45758.5453); }\nfloat hash( vec3 p ) { return fract(sin(dot(p, vec3(7, 157, 113)))*45758.5453); }\nvec3 hash3( vec2 p ) {\n    vec3 q = vec3( dot(p,vec2(127.1,311.7)), \n\t\t\t\t   dot(p,vec2(269.5,183.3)), \n\t\t\t\t   dot(p,vec2(419.2,371.9)) );\n\treturn fract(sin(q)*43758.5453);\n}\n// --------------------------------------------------------------\n\n\n\n// Grey scale.\nfloat getGrey(vec3 p){ return dot(p, vec3(0.299, 0.587, 0.114)); }\n\n\n// IQ's smooth minium function. \nfloat sminP(float a, float b , float s){\n    float h = clamp(.5 + .5*(b-a)/s, 0. , 1.);\n    return mix(b, a, h) - h*(1.-h)*s;\n}\n\n// Smooth maximum, based on the function above.\nfloat smaxP(float a, float b, float s){\n    float h = clamp( .5 + .5*(a-b)/s, 0., 1.);\n    return mix(b, a, h) + h*(1.-h)*s;\n}\n\n\n// Tri-Planar blending function. Based on an old Nvidia writeup:\n// GPU Gems 3 - Ryan Geiss: http://http.developer.nvidia.com/GPUGems3/gpugems3_ch01.html\nvec3 tex3D( sampler2D tex, in vec3 p, in vec3 n ){\n    n = max(n*n, 0.001);\n    n /= (n.x + n.y + n.z );  \n\treturn (texture(tex, p.yz)*n.x + texture(tex, p.zx)*n.y + texture(tex, p.xy)*n.z).xyz;\n}\n\n\n//--------------------------------------------------\n// From Mercury\n// Repeat around the origin by a fixed angle.\n// For easier use, num of repetitions is use to specify the angle.\nfloat pModPolar(inout vec2 p, float rep) {\n\tfloat angle = 2.*PI/rep,\n         a = atan(p.y, p.x) + angle*.5,\n         r = length(p),\n         c = floor(a/angle);\n\ta = mod(a, angle) - angle*.5;\n\tp = vec2(cos(a), sin(a))*r;\n\t// For an odd number of repetitions, fix cell index of the cell in -x direction\n\t// (cell index would be e.g. -5 and 5 in the two halves of the cell):\n\tif (abs(c) >= rep*.5) c = abs(c);\n\treturn c;\n}\n//-----------------------------------------------------\n\n\nfloat sdSegment( vec3 p, vec3 a, vec3 b, float r) {\n    vec3 pa = p - a, ba = b - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1. );\t\n    return length(pa - ba*h) - r;\n}\n\nfloat sdEllipsoid( in vec3 p, in vec3 r) {\n    float k0 = length(p/r), k1 = length(p/(r*r));\n    return k0*(k0-1.0)/k1;\n}\n\n// capsule with bump in the middle -> use for arms and legs\nfloat sdBumpCapsule( vec3 p, vec3 a, vec3 b, float r, float k) {\n    vec3 pa = p - a, ba = b - a;\n    float h = clamp(dot(pa,ba)/dot(ba,ba), 0., 1. ),\n    \t dd = k*cos(3.141592*h+1.57);  // Little adaptation\n    return length(pa - ba*h) - r+dd; \n}\n\n// ------------------------------------------------------------------\n\nfloat sdFrog(vec3 p) {\n\n    float id = pModPolar(p.xz, 12.);\n    p.x -= 12.;\n    p.y += .1;\n    \n    float scale = .4 + .2*hash(id);\n    p /= scale;\n    p.xz += 2.*fract(11.*scale);\n    \n    float dFrog = length(p-vec3(.31,1.6,0));\n    if (dFrog> 3.3+1./scale) return dFrog;\n    \n    float kRot = sanim5cd*.2*cos(id + 5.*iTime); \n    p.xz = rotate(p.xz, .5*kRot);\n    vec3 pr = p;\n    pr.xy *= rot;\n    \n    float sgn = sign(p.z);\n    p.z = abs(p.z);\n    pr.z = abs(pr.z);\n    \n    float dEye = length(pr-vec3(-2.,2.,.7)) - .7;\n  \n    float dLeg = sminP(sdBumpCapsule(p,vec3(2.1,.7,.3),vec3(.0,2.5, 2.7),.2,.3),\n                     sminP(sdBumpCapsule(p,vec3(0.,2.4,2.8),vec3(1.8,.6,1.3),.2,.2),\n                           sdSegment(p,vec3(1.8,.6,1.3),vec3(1.2,.3,1.6),.2),.05) ,.05);\n    float dFeet =  min(sdSegment(p,vec3(1.1,.25,1.55),vec3(.2,.3,1.5),.08),\n                       min(sdSegment(p,vec3(1.2,.25,1.6),vec3(-.0,.3,2.),.08),\n    \t\t\t\t\t   sdSegment(p,vec3(1.1,.25,1.75),vec3(.3,.3,2.3),.08)));\n    float dFinger = min(min(length(p-vec3(.3,.3,1.5)),\n                        length(p-vec3(.1,.3,2.))),\n                        length(p-vec3(.4,.3,2.3))) - .12;\n  \n    vec3 pFinger = p;\n    pFinger.z += 4.*sgn*kRot;\n    \n    float dLeg2 = sminP(sdBumpCapsule(p,vec3(-1.,1.6,1.6),vec3(-.2,1.2, 2.2-sgn*kRot),.2,.1),\n                     sdBumpCapsule(p,vec3(-.2,1.2,2.3-sgn*kRot),vec3(-1.,.3,2.-4.*sgn*kRot),.2,.1),.1);\n    \n    float dFeet2 =  min(sdSegment(pFinger,vec3(-1.,.2,2.),vec3(-1.8,.3,1.5),.1),\n                       min(sdSegment(pFinger,vec3(-1.,.2,2.),vec3(-2.,.3,2.),.1),\n    \t\t\t\t       min(sdSegment(pFinger,vec3(-1.,.2,2.),vec3(-1.3,.3,1.1),.1),\n                               sdSegment(pFinger,vec3(-1.,.2,2.),vec3(-.85,.3,1.2),.1)\n                              )));\n    float dFinger2 = min(min(length(pFinger-vec3(-1.8,.3,1.5)),\n                             length(pFinger-vec3(-2.,.3,2.))),\n                         min(length(pFinger-vec3(-1.3,.3,1.1)),\n                             length(pFinger-vec3(-.85,.3,1.2))) ) - .12;\n    \n    dFeet2 = sminP(dFinger2, dFeet2,.1); \n    dFeet = sminP(dFinger, dFeet,.1); \n    dLeg = sminP(dLeg, dFeet,.2);\n    dLeg2 = sminP(dLeg2, dFeet2,.2);\n    \n    float dd = max(max(.5-p.y, dot(pr-vec3(3.,1.3,0), normalize(vec3(1,2,1)))),\n                   max(dot(pr-vec3(-3.4,1.8,-.1), normalize(vec3(-1.9,1.,2))),\n                       min(.8-pr.y, dot(pr-vec3(-.5,.3,2.), normalize(vec3(-1.5,-2.2,1))))));\n\t\n    float dBody = sdEllipsoid(pr-vec3(-.5,1.2,0), vec3(2.7,1.3,2));\n    dBody = smaxP(dd, dBody, .1);\n    dBody = sminP(dBody, dEye, .2);\n    \n    float d = dBody;\n    \n    d = smaxP(dd, d, .1);\n    d = sminP(d, dEye, .2);\n    d = smaxP(d, -min(dLeg,dLeg2), .3);\n    d = sminP(d, dLeg, .2);\n    d = sminP(d, dLeg2, .15);\n    d = smaxP(d, -(length(p - vec3(-1.5,2.4,.8)) - .5), .4);\n    d = smaxP(d, -(length(pr - vec3(-3.05,1.55,.18))), .1);\n    \n    float kFrog = .55*smoothstep(.9,1.,cos(iTime+102.*id));\n    d = sminP(d, sdEllipsoid(pr-vec3(-2.,.65-.2*kFrog,0.), mix(vec3(.5,.15,.9), vec3(1.,1.,1.8), kFrog)), .2);\n    dEye = length(p-vec3(-1.5,2.4,.8)) - .5;\n    \n    return scale*min(d,dEye);\n}\n\n\nfloat mapTube( vec3 p ) {\n    vec2 id = floor( (p.xz+5.0)/10. );\n    \n    float k = hash(id.x+101.*id.y);\n    if (k>.3 || k<.1) return 999.;\n    \n    float tt = mod(iTime,1.5)/1.5;\n    float ss = pow(tt,.2)*0.5 + 0.5;\n    float pulseY = sanim01*(.25+ss*0.5*sin(tt*6.2831*3.+p.y)*exp(-tt*4.0));\n    ss = pulseY*.25;\n\n    p.xz = mod(p.xz+5.0, 10.) - 5.;\n    p.xz += .5*sin( 2.0 + p.y*vec2(.53,.32) - vec2(1.57,.0) );\n\n    return min( min(length(p.xz+.15*sincos(p.y)), \n                    length(p.xz+.15*sincos(p.y+4.))) - .15*(.8+.2*sin(2.*p.y)) - ss, \n                min(length(p.xz+.15*sincos(p.y+2.)) - .15*(.8+.2*sin(2.*p.y + 2.*(p.y-iTime)))-ss-.01, \n                    length(p.xz+.15*sincos(p.y+5.)) - .08*(.8+.2*sin(2.*p.y + ss + 8.*(p.y-iTime)))-.02-.3*ss));\n}\n\n\nfloat map( vec3 pos, bool light) {\n    vec3 p0 = pos;\n\n    float h = mix(1.,.1, smoothstep(20., 14., length(pos.xz))) + gPulseGround;\n    h *= texture(iChannel2, -p0.xz*.02).x;\n    pos.y -= h;\n    \n    float kEat = sanim56*(1.+.1*gPulse); \n    vec3 pFrog = p0-vec3(0, - 1.5*kEat,0);\n    \n    float dFrog = iTime < ani4 ? 999. : sdFrog(pFrog);\n\n    float dTube = mapTube(pos);\n\n    vec2 id = floor( (pos.xz-1.)/2.);\n    \n    pos.xz = mod(pos.xz+1., 2.) - 1.;\n    pos.xz += .2*sin(dot(120.*id,vec2(1213.15,1317.34)));\n    pos.xz += vec2(1,-1)*.2*sin(3.5*iTime +3.*cos(pos.y))*sin(.5*pos.y);\n\n    vec3 posButton = pos;\n    \n    float len = max(sanim01,.1)*(.5+.4*smoothstep(.4,.5,cos(.3*iTime+id.x))+0.3*sin(dot(110.*id,vec2(1213.15,1317.34))));\n    float thi = sanim01*(.8+.4*cos(.4*iTime)) * slab * (0.5+0.3*sin(-3.151592*posButton.y/len));\n   \n    float d = 999.;\n     \n        if (hash(id.x+11.*id.y) > .6) {\n            d = sdSegment( posButton, vec3(0.,-len*.25,0.), vec3(0,len,0), 4.*thi);\n            float dlight = length(pos-vec3(0,fract(1.+cos(id.x+3.1*id.y)+iTime*.1)*15.,0))-.05*sanim23;\n            if (light) dhaloLight = min(dhaloLight, pos.y > len ? dlight-.02*sanim23 : 9999.);\n            if (sanim23 > 0.) {\n                d = sminP(d, dlight, .3);\n            }\n        }\n        if (light && sanim56 > 0.) {\n            dhaloFrog = min(dhaloFrog, dFrog -.02*sanim56); \n        }\n    \n        \n       // d = max(d, -(dlight-.02-.01));\n   // }\n\n    // Bump arround frog ---------------------------------\n\n    float idFrog = pModPolar(pFrog.xz, 12.);\n    pFrog.x -= 12.;\n    float scale = .4 + .2*hash(idFrog);\n    pFrog /= scale;\n    pFrog.xz += 2.*fract(11.*scale);\n \n    float dBumpFrog = scale*(length(pFrog-vec3(-1.,1.7-2.1*kEat*kEat,0))-4.*kEat);\n    // ---------------------------------------------------\n\n    d = sminP(d, pos.y, .3);\n    d = sminP(d, dBumpFrog, .6);\n    d = smaxP(d,-dFrog, .3);\n\n    \n//    return min(dFrog, min(dTube, smaxP(-min(dTube-.3,length(p0.xz)-4.2), d, 1.)));\n    return min(dFrog, min(dTube, smaxP(-dTube+.3, d, 1.)));\n}\n\n\nfloat textureFrog(vec3 p, out vec4 out_posIdFrog) {\n    float id = pModPolar(p.xz, 12.);\n    p.x -= 12.;\n    p.y += .1;\n    \n    float scale = .4 + .2*hash(id);\n    p /= scale;\n    p.xz += 2.*fract(11.*scale);\n    \n    float dFrog = length(p-vec3(.31,1.6,0));\n    if (dFrog> 3.3+1./scale) return dFrog;\n        \n   \n    float kRot = sanim5cd*.2*cos(id + 5.*iTime); \n    p.xz = rotate(p.xz, .5*kRot);\n    vec3 p0 = p;\n    vec3 pr = p;\n    pr.xy *= rot;\n    \n    float sgn = sign(p.z);\n    p.z = abs(p.z);\n    pr.z = abs(pr.z);\n    \n    float dEye = length(pr-vec3(-2.,2.,.7)) - .7;\n  \n    float dLeg = sminP(sdBumpCapsule(p,vec3(2.1,.7,.3),vec3(.0,2.5, 2.7),.2,.3),\n                     sminP(sdBumpCapsule(p,vec3(0.,2.4,2.8),vec3(1.8,.6,1.3),.2,.2),\n                          sdSegment(p,vec3(1.8,.6,1.3),vec3(1.2,.3,1.6),.2),.05) ,.05);\n    float dFeet =  min(sdSegment(p,vec3(1.1,.25,1.55),vec3(.2,.3,1.5),.08),\n                       min(sdSegment(p,vec3(1.2,.25,1.6),vec3(-.0,.3,2.),.08),\n    \t\t\t\tsdSegment(p,vec3(1.1,.25,1.75),vec3(.3,.3,2.3),.08)));\n    float dFinger = min(min(length(p-vec3(.3,.3,1.5)),\n                        length(p-vec3(.1,.3,2.))),\n                        length(p-vec3(.4,.3,2.3))) - .12;\n  \n    vec3 pFinger = p;\n    pFinger.z += 4.*sgn*kRot;\n    float dLeg2 = sminP(sdBumpCapsule(p,vec3(-1.,1.6,1.6),vec3(-.2,1.2, 2.2-sgn*kRot),.2,.1),\n                     sdBumpCapsule(p,vec3(-.2,1.2,2.3-sgn*kRot),vec3(-1.,.3,2.-4.*sgn*kRot),.2,.1),.1);\n    \n    float dFeet2 =  min(sdSegment(pFinger,vec3(-1.,.2,2.),vec3(-1.8,.3,1.5),.1),\n                       min(sdSegment(pFinger,vec3(-1.,.2,2.),vec3(-2.,.3,2.),.1),\n    \t\t\t\t       min(sdSegment(pFinger,vec3(-1.,.2,2.),vec3(-1.3,.3,1.1),.1),\n                               sdSegment(pFinger,vec3(-1.,.2,2.),vec3(-.85,.3,1.2),.1)\n                              )));\n    float dFinger2 = min(min(length(pFinger-vec3(-1.8,.3,1.5)),\n                             length(pFinger-vec3(-2.,.3,2.))),\n                         min(length(pFinger-vec3(-1.3,.3,1.1)),\n                             length(pFinger-vec3(-.85,.3,1.2))) ) - .12;\n    \n    dFeet2 = sminP(dFinger2, dFeet2,.1); \n    dFeet = sminP(dFinger, dFeet,.1); \n    dLeg = sminP(dLeg, dFeet,.2);\n    dLeg2 = sminP(dLeg2, dFeet2,.2);\n    \n    float dd = max(max(.5-p.y, dot(pr-vec3(3.,1.3,0), normalize(vec3(1,2,1)))),\n                   max(dot(pr-vec3(-3.4,1.8,-.1), normalize(vec3(-1.9,1.,2))),\n                       min(.8-pr.y, dot(pr-vec3(-.5,.3,2.), normalize(vec3(-1.5,-2.2,1))))));\n\t\n    float dBody = sdEllipsoid(pr-vec3(-.5,1.2,0), vec3(2.7,1.3,2));\n    dBody = smaxP(dd, dBody, .1);\n    dBody = sminP(dBody, dEye, .2);\n    \n    float d = dBody;\n    \n    d = smaxP(dd, d, .1);\n    d = sminP(d, dEye, .2);\n    d = smaxP(d, -min(dLeg,dLeg2), .3);\n    d = sminP(d, dLeg, .2);\n    d = sminP(d, dLeg2, .15);\n    d = smaxP(d, -(length(p - vec3(-1.5,2.4,.8)) - .5), .4);\n    d = smaxP(d, -(length(pr - vec3(-3.05,1.55,.18))), .1);\n    \n    float kFrog = .55*smoothstep(.9,1.,cos(iTime+102.*id));\n    d = sminP(d, sdEllipsoid(pr-vec3(-2.,.65-.2*kFrog,0.), mix(vec3(.5,.15,.9), vec3(1.,1.,1.8), kFrog)), .2);\n    vec3 pEye = p-vec3(-1.5,2.4,.8);\n    dEye = length(pEye) - .5;\n    \n    out_posIdFrog = d<dEye ? vec4(p0, 20.+abs(id)) : vec4(pEye, 31.+abs(id));\n    \n    return scale*min(d,dEye);\n}\n\n\nfloat texturePtTube(vec3 p, out vec4 out_idPosTube) {\n\n    vec2 id = floor( (p.xz+5.0)/10. );\n\n    float k = hash(id.x+101.*id.y);\n    if (k>.3 || k<.1) return 999.;\n    \n    float tt = mod(iTime,1.5)/1.5;\n    float ss = pow(tt,.2)*0.5 + 0.5;\n    float pulseY = sanim01*(.25+ss*0.5*sin(tt*6.2831*3.0+p.y)*exp(-tt*4.0));\n    ss = pulseY*.25;\n\n    p.xz = mod( p.xz+5.0, 10.0 ) - 5.0;\n    p.xz += 0.5*sin( 2.0 + (p.y)*vec2(0.53,0.32) - vec2(1.57,0.0) );\n\n    vec3 p1 = p; p1.xz += 0.15*sincos(p.y);\n    vec3 p2 = p; p2.xz += 0.15*sincos(p.y+2.0);\n    vec3 p3 = p; p3.xz += 0.15*sincos(p.y+4.0);\n    vec3 p4 = p; p4.xz += 0.15*sincos(p.y+5.0);   \n    \n    float h1 = length(p1.xz),\n         h2 = length(p2.xz),\n     \t h3 = length(p3.xz),\n     \t h4 = length(p4.xz);\n\n    vec3 res = opU( opU(vec3(h1-0.15*(0.8+0.2*sin(2.*p.y))-ss, 10., p.y), \n                    \tvec3(h2-0.15*(0.8+0.2*sin(2.*p.y+2.0*(p2.y-iTime)))-ss-.01, 11., p.y)), \n                    opU(vec3(h3-0.15*(0.8+0.2*sin(2.*p.y))-ss, 12., p.y),\n        \t\t\t\tvec3(h4-0.08*(0.8+0.2*sin(2.*p.y+ss+8.0*(p.y-iTime)))-.02-.3*ss, 13., p.y) ));\n\n    out_idPosTube = vec4(res.y == 10. ? p1 : res.y == 11. ? p2 : res.y == 12. ? p3 : p4, res.y);\n    return res.x;\n}\n\n\nvec4 texturePt(vec3 pos) {\n    vec3 p0 = pos;\n\n    float h = mix(1.,.1, smoothstep(20., 14., length(pos.xz))) + gPulseGround;\n    h *= texture(iChannel2, -p0.xz*.02).x;\n    pos.y -= h;\n    \n   \n    float kEat = sanim56*(1.+.1*gPulse); \n    vec3 pFrog = p0-vec3(0,-1.5*kEat,0);\n    vec4 idPosFrog;\n    float dFrog = textureFrog(pFrog, idPosFrog);\n\n    vec4 idPosTube;\n    float dTube = texturePtTube(pos, idPosTube);\n\n//    pos.z *= .8 + .212*cos(pos.x*.053);\n//    pos.x *= .8 + .212*cos(pos.z*.051);\n    //pos.xz *= cos(pos.x*.5);\n         \n    vec2 id = floor( (pos.xz-1.)/2.);    \n   // pos.xz = mod(pos.xz+1., 2.) - 1.;\n    pos.xz -= .2*sin(dot(120.*id,vec2(1213.15,1317.34)));\n    pos.xz += vec2(1,-1)*.2*sin(3.5*iTime +3.*cos(pos.y))*sin(.5*pos.y);\n\n     // Bump arround frog ---------------------------------\n/*\n    float idFrog = pModPolar(pFrog.xz, 12.);\n    pFrog.x -= 12.;\n    float scale = .4 + .2*hash(idFrog);\n    pFrog /= scale;\n    pFrog.xz += 2.*fract(11.*scale);\n \n    float dBumpFrog = scale*(length(pFrog-vec3(-1.,1.5-1.5*kEat,0))-4.*kEat);\n    // ---------------------------------------------------\n\n    d = sminP(d, pos.y, .3);\n    d = sminP(d, dBumpFrog, .6);\n    d = smaxP(d,-dFrog, .3);\n*/\n    \n    return dTube < .01 ? idPosTube : dFrog < .01 ? idPosFrog : vec4(pos,1.);\n}\n\n\n#define EDGE_WIDTH .001\n\nvec3 trace(in vec3 ro, in vec3 rd, in float maxd) {\n\t// edge detection\n    dhaloLight = 9999.; // reset closest trap\n    dhaloFrog = 9999.;\n    float lastt,lastDistEval = 1e10;\n\tfloat edge = 0.0;\n    float iter = 0.;\n\n    float t = hash(rd);\n    float d = 999.;//map(rd*t + ro);\n    for (int i=0; i<240; i++){\n\t\td = .7*map(rd*t + ro, true);\n        if ( abs(d) < 0.002 || t > maxd) break;\n        t += min(.9,d);\n    }\n    return vec3(t);\n}\n\n\n// Tetrahedral normal, courtesy of IQ.\n// -- Calculate normals -------------------------------------\n\nvec3 calcNormal(in vec3 pos, in vec3 ray, in float t) {\n\n\tfloat pitch = .2 * t / iResolution.x;\n\tpitch = max( pitch, .002 );\n\t\n\tvec2 d = vec2(-1,1) * pitch;\n\n\tvec3 p0 = pos+d.xxx, p1 = pos+d.xyy, p2 = pos+d.yxy, p3 = pos+d.yyx;\n\tfloat f0 = map(p0,false), f1 = map(p1,false), f2 = map(p2,false), f3 = map(p3,false);\n\t\n\tvec3 grad = p0*f0+p1*f1+p2*f2+p3*f3 - pos*(f0+f1+f2+f3);\n\t// prevent normals pointing away from camera (caused by precision errors)\n\treturn normalize(grad - max(.0, dot (grad,ray))*ray);\n}\n\n\n\n\n// The iterations should be higher for proper accuracy, but in this case, I wanted less accuracy, just to leave\n// behind some subtle trails of light in the caves. They're fake, but they look a little like light streaming \n// through some cracks... kind of.\nfloat softShadow(in vec3 ro, in vec3 rd, in float start, in float end, in float k){\n\n    float shade = 1.0;\n    const int maxIterationsShad = 32; \n    float dist = start;\n    float stepDist = end/float(maxIterationsShad);\n\n    // Max shadow iterations - More iterations make nicer shadows, but slow things down. Obviously, the lowest \n    // number to give a decent shadow is the best one to choose. \n    for (int i=0; i<maxIterationsShad; i++){\n        float h = map(ro + rd*dist,false);\n        shade = min(shade, smoothstep(0.0, 1.0, k*h/dist));\n        dist += clamp(h, 0.1, stepDist*2.);\n        if (abs(h)<0.001 || dist > end) break; \n    }\n    return min(max(shade, 0.) + 0.1, 1.0); \n}\n\n\n\n// Ambient occlusion, for that self shadowed look. Based on the original by XT95. I love this \n// function and have been looking for an excuse to use it. For a better version, and usage, \n// refer to XT95's examples below:\n//\n// Hemispherical SDF AO - https://www.shadertoy.com/view/4sdGWN\n// Alien Cocoons - https://www.shadertoy.com/view/MsdGz2\nfloat calculateAO(in vec3 pos, in vec3 nor) {\n    float dd, hr=.01, totao=.0, sca=1.;\n    for(int aoi=0; aoi<4; aoi++ ) {\n        dd = map(nor * hr + pos,false);\n        totao += -(dd-hr)*sca;\n        sca *= .8;\n        hr += .06;\n    }\n    return clamp(1.-4.*totao, 0., 1.);\n}\n\n\n\n// Texture bump mapping. Four tri-planar lookups, or 12 texture lookups in total.\nvec3 doBumpMap( sampler2D tex, in vec3 p, in vec3 nor, float bumpfactor){\n   \n    const float eps = 0.001;\n    vec3 grad = vec3( getGrey(tex3D(tex, vec3(p.x-eps, p.y, p.z), nor)),\n                      getGrey(tex3D(tex, vec3(p.x, p.y-eps, p.z), nor)),\n                      getGrey(tex3D(tex, vec3(p.x, p.y, p.z-eps), nor)));\n    \n    grad = (grad - getGrey(tex3D(tex,  p , nor)))/eps;             \n    grad -= nor*dot(nor, grad);          \n    return normalize( nor + grad*bumpfactor );\n\t\n}\n\nvec3 pal( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d ) {\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\nvec3 palette(float id, float k) {\n    return 2.*pal( k, vec3(0.5,0.8,0.8),vec3(0.6,0.3,0.5),vec3(1.0,.2,1.0), vec3((id-10.)*.01) );\n}\n\n\n// HSV to RGB conversion \n// [iq: https://www.shadertoy.com/view/MsS3Wc]\nvec3 hsv2rgb_smooth(float x, float y, float z) {\n    vec3 rgb = clamp( abs(mod(x*6.+vec3(0.,4.,2.),6.)-3.)-1., 0., 1.);\n\trgb = rgb*rgb*(3.-2.*rgb); // cubic smoothing\t\n\treturn z * mix( vec3(1), rgb, y);\n}\n\n\n// -------------------------------------------------------------------\n// pupils effect came from lexicobol shader:\n// https://www.shadertoy.com/view/XsjXz1\n// -------------------------------------------------------------------\n\n\n\nfloat iqnoise( in vec2 x, float u, float v )\n{\n    vec2 p = floor(x);\n    vec2 f = fract(x);\n\tfloat k = 1.0+63.0*pow(1.0-v,4.0);\n\tfloat va = 0.0;\n\tfloat wt = 0.0;\n    for( int j=-2; j<=2; j++ )\n    for( int i=-2; i<=2; i++ ) {\n        vec2 g = vec2(i,j);\n\t\tvec3 o = hash3( p + g )*vec3(u,u,1.0);\n\t\tvec2 r = g - f + o.xy;\n\t\tfloat d = dot(r,r);\n\t\tfloat ww = pow( 1.0-smoothstep(0.0,1.414,sqrt(d)), k );\n\t\tva += o.z*ww;\n\t\twt += ww;\n    }\n\t\n    return va/wt;\n}\n\nfloat noise ( vec2 x)\n{\n\treturn iqnoise(x, 0.0, 1.0);\n}\n\nmat2 m = mat2( 0.8, 0.6, -0.6, 0.8);\n\nfloat fbm( vec2 p)\n{\n\tfloat f = 0.0;\n    f += 0.5000 * noise(p); p *= m* 2.02;\n    f += 0.2500 * noise(p); p *= m* 2.03;\n    f += 0.1250 * noise(p); p *= m* 2.01;\n    f += 0.0625 * noise(p); p *= m* 2.04;\n    f /= 0.9375;\n    return f;\n}\n\nvec3 iris(vec2 p, float open)\n{\n\n    float r = sqrt( dot (p,p));\n    float r_pupil = .15 + .15*smoothstep(.5,2.,open);\n    \n    float dPupil = length(vec2(abs(p.x)+.2, p.y)) - .35;// + .15*smoothstep(.5,2.,open);\n\n    float a = atan(p.y, p.x); // + 0.01*iTime;\n    vec3 col = vec3(1.0);\n    \n    float ss = 0.5;// + 0.5 * sin(iTime * 2.0);\n    float anim = 1.0 + 0.05*ss* clamp(1.0-r, 0.0, 1.0);\n    r *= anim;\n        \n    if( r< .8) {\n\t\tcol = vec3(0.12, 0.60, 0.57);\n        float f = fbm(5.0 * p);\n        col = mix(col, 2.*vec3(1.,.8,0.12), f); \n        \n        f = 1.0 - smoothstep( 0., .1, dPupil);\n        col = mix(col, vec3(0.12,1., 0.30), f); \n        \n        a += 0.05 * fbm(20.0*p);\n        \n        f = smoothstep(0.3, 1.0, fbm(vec2(5.0 * r, 20.0 * a))); // white highlight\n        col = mix(col, vec3(1.0), f);\n        \n        f = smoothstep(0.3, 1.0, fbm(vec2(5.0 * r, 5.0 * a))); // yellow highlight\n        col = mix(col, vec3(1.5,.8,0.12), f);\n        \n        f = smoothstep(0.5, 1.0, fbm(vec2(5.0 * r, 15.0 * a))); // dark highlight\n        col *= 1.0 - f;\n        \n        f = smoothstep(0.55, 0.8, r); //dark at edge\n        col *= 1.0 - 0.6*f;\n        \n        f = smoothstep( 0., .05, dPupil); //pupil\n        col *= f; \n        \n        f = smoothstep(0.75, 0.8, r);\n        col = .5*mix(col, vec3(1.0), f);\n    }\n    \n\treturn 3.*col;\n}\n\n\n\n#ifdef STEREOGRAPHIC\nvec3 getStereoDir(vec2 fragCoord)\n{\n\tvec2 p = fragCoord.xy / iResolution.xy;\n    float t = 3.+iTime*.08, ct = cos(t), st = sin(t);\n\tfloat m = .5;\n    p = (p * 2. * m - m)*.7;\n    p.x *= iResolution.x/iResolution.y;\n    p *= mat2(ct,st,-st,ct);\n\n\treturn normalize(vec3(2.*p.x,dot(p,p)-1.,2.*p.y));\n}  \n#endif\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\t\n\tfloat tt = mod(iTime,1.5)/1.5;\n    float ss = pow(tt,.2)*0.5 + 0.5;\n\n    sanim01 = smoothstep(ani0,ani1,iTime);\n    sanim12 = smoothstep(ani1,ani2,iTime);\n    sanim23 = smoothstep(ani2,ani3,iTime);\n    sanim34 = smoothstep(ani3,ani4,iTime);\n    sanim45 = smoothstep(ani4,ani5,iTime);\n    sanim56r = smoothstep(ani5b,ani5c,iTime); \n    float sanim5c = smoothstep(ani5,ani5c,iTime); \n    sanim5cd = smoothstep(ani5c,ani5d,iTime); \n    sanim56 = smoothstep(ani5d,ani6,iTime); \n    sanim67 = smoothstep(ani6,ani7,iTime);\n    \n    // Heart pulse\n    gPulse = (.25+ss*0.5*sin(tt*6.2831*3.0)*exp(-tt*4.0));\n    \n    // Ground Pulse\n    gPulseGround = .2+.8*mix(gPulse, 0., sanim45 + sanim67);\n    \n\t// Screen coordinates.\n\tvec2 u = (fragCoord - iResolution.xy*0.5)/iResolution.y;\n\t    \n    vec2 uv = gl_FragCoord.xy / iResolution.xy;\n\n    // Camera Setup.\n    float a = .1*iTime + 2.*3.141592*iMouse.x/iResolution.x;\n    \n\tvec3 ro = vec3(-92.0,  4.5, -78.);\n    ro = mix(ro, vec3(-106.0,  8.0, -84.), sanim34); \n    ro = mix(ro, vec3(cos(-a), .3, sin(-a))*26., sanim45);\n    ro = mix(ro, vec3(1,3,0), sanim5c);\n    ro = mix(ro, vec3(1,3,0) + vec3(1.,.2,.8)*(iTime - ani6), sanim67);\n    \n\tvec3 lookAt = ro + vec3(.25, -.22, .5); // Camera position, doubling as the ray origin.\n\tlookAt = mix(lookAt, vec3(0, 0, 0), sanim34); // Camera position, doubling as the ray origin.\n\tlookAt = mix(lookAt, vec3(cos(a), .25, sin(a))*7., sanim5c); // Camera position, doubling as the ray origin.\n \n    // Using the above to produce the unit ray-direction vector.\n    float FOV = 3.14159/6.; // FOV - Field of view.\n    vec3 forward = normalize(lookAt-ro);\n    vec3 right = normalize(vec3(forward.z, 0., -forward.x )); \n    vec3 up = cross(forward, right);\n\n    // rd - Ray direction.\n    vec3 rd = normalize(forward + FOV*u.x*right + FOV*u.y*up);\n\n\n    // Swiveling the camera about the XY-plane (from left to right) when turning corners.\n    // Naturally, it's synchronized with the path in some kind of way.\n\t//rd.xz = rot2( /*iMouse.x/iResolution.x +*/ path(lookAt.z).x/64. )*rd.xz;\n\n    // Usually, you'd just make this a unit directional light, and be done with it, but I\n    // like some of the angular subtleties of point lights, so this is a point light a\n    // long distance away. Fake, and probably not advisable, but no one will notice.\n\n\tvec3 res = trace(ro, rd, FAR);\n    float t = res.x;\n    \n    // Standard sky routine. Worth learning. For outdoor scenes, you render the sky, then the\n    // terrain, then mix together with a fog falloff. Pretty straight forward.\n    vec3 sky = .3*vec3(1.,1.3,1.3);//getSky(ro, rd, normalize(lp - ro));\n    vec3 col = sky;\n\t\n //   vec3 lp = mix(ro+vec3(5.05,-1.5,-5.05), ro+vec3(.05,12.5,-5.05), sanim56r);\n //   lp = mix(lp, ro+vec3(5.05,-1.5,-5.05), sanim67);\n    \n     vec3 lp = (forward*.5+up-right)*FAR/*vec3(FAR*.5, FAR, FAR)*/ + vec3(0, 0, ro.z);\n\n    if (t < FAR){\n    \t\n        vec3 sp = ro+t*rd; // Surface point.\n        vec4 spt = texturePt(sp); // Surface points on objects coords (to enable textures to follow object moves)\n        vec3 sn = calcNormal( sp, rd, t ); // Surface normal.\n\n\t\t// Light direction\n        vec3 ld = normalize(lp-sp);\n\n        // Texture scale factor.        \n        const float tSize1 = 1./3.;\n        float k;\n        vec3 colTxt;\n        \n        if (spt.w > 30.) {\n            // Frog eyes\n            vec3 pe = spt.xyz;\n            float a = .2*cos(.1*iTime),\n                  ca = cos(a), sa = sin(a);\n            pe.xz *= mat2(ca, sa, -sa, ca);\n            float b = mix(3.1-1.5*fract(iTime*.2+.17*spt.w), 4.2, step(ani5b2, iTime)),//sanim56r),\n                  cb = cos(b), sb = sin(b);\n            pe.xy *= mat2(cb, sb, -sb, cb);\n            colTxt = iris((pe.zy), 20.5);\n\n        } else if (spt.w > 19.) {\n            // Frog Body\n            vec3 hh = hash3(vec2(spt.w,spt.w));\n            colTxt = hsv2rgb_smooth(spt.w*.2, .6, .7);\n            colTxt = mix(colTxt, vec3(0.), .7*smoothstep(.6,.7, hh*.5+tex3D(iChannel2, spt.xyz*tSize1, sn).x));\n            colTxt = mix(colTxt, vec3(0,1,1), .1*smoothstep(.0,1., -sn.y));\n            colTxt = .7*sqrt(colTxt);\n\t        sn = doBumpMap(iChannel2, 2.*spt.xyz*tSize1, sn, .2/(1. + t/FAR));\n            \n        } else if (spt.w > 5.) {\n\n\t        float k = tex3D(iChannel0, spt.xyz*tSize1 + .1*spt.w, sn).x;\n            colTxt = mix(vec3(1.2,.5,.4), palette(1., spt.w), .7+.3*cos(spt.w+4.*spt.y-5.*iTime));     \n            colTxt = mix(colTxt, vec3(1,0,0), .2+.5*smoothstep(.2,.8,k));\n\n    \t    sn = doBumpMap(iChannel0, spt.xyz*tSize1, sn, .007/(1. + t/FAR));\n\n        }  else {\n            k = tex3D(iChannel0, spt.xyz*tSize1, sn).x;\n           // colTxt = mix(vec3(1,.5,.3), 4.*(.6+.5*sin(.1*iTime+.01*length(spt.xz)))*vec3(0,1,1), .5+.5*smoothstep(.4,.7,k+.05*cos(2.*iTime)));\n            colTxt = mix(.3*vec3(1,.5,.3), 1.3*vec3(0,1,1), .4+.6*smoothstep(.4,.7,k+.05*cos(2.*iTime)));\n            colTxt = mix(colTxt, 1.7*vec3(1.8,1.8,.5), sanim01*smoothstep(.4,0.,abs(.8-spt.y)));\n       \t\tsn = doBumpMap(iChannel0, spt.xyz*tSize1, sn, .007/(1. + t/FAR));//max(1.-length(fwidth(sn)), .001)*hash(sp)/(1.+t/FAR)\n        }\n       \n    \t// prevent normals pointing away from camera (caused by precision errors)\n\t\tsn = normalize(sn - max(.0, dot(sn,rd))*rd);       \n                \n        float d2 = 1.;//RayMarchOut(sp+rd*(.05*4. + noise.x*0.05), ld);\n        \n        float shd = softShadow(sp, ld, 0.005, 4., 8.); // Shadows.\n        float ao = calculateAO(sp, sn); // Ambient occlusion.\n        float dif = max( dot( ld, sn ), 0.0); // Diffuse term.\n        float spe = pow(max( dot( reflect(-ld, sn), -rd ), 0.0 ), 29.); // Specular term.\n        float fre = clamp(1.0 + dot(rd, sn), 0.0, 1.0); // Fresnel reflection term.\n       \n        // Schlick approximation. I use it to tone down the specular term. It's pretty subtle,\n        // so could almost be aproximated by a constant, but I prefer it. Here, it's being\n        // used to give a hard clay consistency... It \"kind of\" works.\n\t\tfloat Schlick = pow( 1. - max(dot(rd, normalize(rd + ld)), 0.), 5.0);\n\t\tfloat fre2 = mix(.2, 1., Schlick);  //F0 = .2 - Hard clay... or close enough.\n       \n        // Overal global ambience. Without it, the cave sections would be pretty dark. It's made up,\n        // but I figured a little reflectance would be in amongst it... Sounds good, anyway. :)\n        float amb = fre*fre2 + .06*ao;\n        \n        // Coloring the soil - based on depth. Based on a line from Dave Hoskins's \"Skin Peeler.\"\n        col = colTxt;\n        col = (col*(dif*d2 + .1) + fre2*spe*2.)*shd*ao + amb*col;\n    } \n    \n    col = .5*mix(col, sky, smoothstep(5., FAR, t));\n   \n    // Light\n    if (dhaloLight < t) {\n        float BloomFalloff = 50000.; \n \t\tcol += mix(1.5*vec3(1.,1.,.4), sky, .5+.5*smoothstep(5., FAR, dhaloLight))/(1.+dhaloLight*dhaloLight*dhaloLight*BloomFalloff);\n    }\n    if (dhaloFrog < t) {\n        float BloomFalloff = 50000.; \n \t\tcol += mix(sanim56*vec3(1.,1.,.4), vec3(0), .5+.5*smoothstep(5., FAR, dhaloFrog))/(1.+dhaloFrog*dhaloFrog*dhaloFrog*BloomFalloff);\n    }\n   \n    \n    // gamma correction\n    col = pow(max(col, 0.), vec3(.7));\n\n    u = fragCoord/iResolution.xy;\n    col *= pow( 16.0*u.x*u.y*(1.0-u.x)*(1.0-u.y) , .32);\n\n    \n\tfragColor = vec4(clamp(col, 0., 1.), 1.0 );\n}", "image_inputs": [{"id": "4dX3Rn", "previewfilepath": "/media/ap/bd6464771e47eed832c5eb2cd85cdc0bfc697786b903bfd30f890f9d4fc36657.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/bd6464771e47eed832c5eb2cd85cdc0bfc697786b903bfd30f890f9d4fc36657.jpg", "ctype": "texture"}, {"id": "4sf3Rr", "previewfilepath": "/media/ap/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3s2XWW.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[1282, 1282, 1314, 1314, 1378], [1379, 1379, 1403, 1403, 1436], [1437, 1437, 1466, 1466, 1497], [1500, 1650, 1672, 1672, 1733], [1734, 1734, 1756, 1756, 1791], [1792, 1792, 1814, 1814, 1873], [1874, 1874, 1896, 1896, 2047], [2117, 2132, 2154, 2154, 2198], [2201, 2234, 2274, 2274, 2361], [2363, 2411, 2450, 2450, 2537], [2540, 2694, 2744, 2744, 2890], [2893, 3075, 3117, 3117, 3496], [3555, 3555, 3606, 3606, 3731], [3733, 3733, 3775, 3775, 3854], [3856, 3916, 3980, 3980, 4163], [4236, 4236, 4258, 4258, 7412], [7415, 7415, 7440, 7440, 8186], [8189, 8189, 8223, 8223, 10262], [10265, 10265, 10316, 10316, 13589], [13592, 13592, 13645, 13645, 14805], [14808, 14808, 14834, 14834, 16106], [16134, 16134, 16185, 16204, 16574], [16679, 16679, 16734, 16734, 17185], [17190, 17448, 17531, 17531, 18140], [18144, 18491, 18536, 18536, 18768], [18772, 18854, 18927, 18927, 19346], [19348, 19348, 19416, 19416, 19459], [19461, 19461, 19494, 19494, 19594], [19597, 19670, 19718, 19718, 19874], [20108, 20108, 20154, 20154, 20564], [20566, 20566, 20589, 20589, 20621], [20661, 20661, 20681, 20681, 20898], [20900, 20900, 20931, 20931, 22264], [22600, 22600, 22656, 22656, 29972]], "test": "error"}
{"id": "3s2Xz3", "name": "visualizer__", "author": "s_das", "description": "  \n", "tags": ["raytracing", "vfx", "shader", "visualizer", "pattern", "trigonometry"], "likes": 4, "viewed": 249, "published": "Public API", "date": "1554535806", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    vec2 uv = fragCoord.xy/iResolution.xy;\n    uv -= .5;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    //uv = uv*2. - 1.;\n    \n    float da = iTime/5. +12.;\n     \n    vec3 col = vec3(1.);  \n\n    float d = distance( atan(uv.x, uv.y) , sin(uv.x)*5.);\n    d = length(uv) + 0.;\n    d = tan(d) * 5.;\n    float a = atan(sin(da),uv.y) * atan(da) * 5.;\n    \n    d = sin(a * cos( d + da) * sin(da)) * cos(a * sin(d + da) * cos(iTime));\n    d /= sin(dot( atan( uv.y, d), da) * cos(d));\n    \n    col *= smoothstep( 0.5, tan(iTime) , length( atan(uv) ) ) ;\n    col /= vec3(dot(d * atan( d, uv.x), da ));\n    \n    col -= vec3(.1, .2, .1);\n    col /= vec3(0.5, 0.5, .2);\n   \n    fragColor = vec4(col,1.0);\n \n}  ", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3s2Xz3.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 760]], "test": "error"}
{"id": "3sBSWt", "name": "Dotted Polyp", "author": "OliverSchaff", "description": "Branch of https://www.shadertoy.com/view/tdSXWt. I liked the dots on the arms... so I made it public, too.\nUse mouse to rotate.", "tags": ["raymarching", "transparency", "volumetric", "glass"], "likes": 15, "viewed": 158, "published": "Public", "date": "1556463848", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Renderingcode from a shader by Shane\n// https://www.shadertoy.com/view/ll2SRy\n\n#define PI 3.14159265359\n#define grad_step 0.01\n#define time 2.0*iTime\n\n#define ZERO (min(iFrame,0))\n\n\n// Spectrum colour palette\n// IQ https://www.shadertoy.com/view/ll2GD3\nvec3 pal( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d ) {\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\nvec3 spectrum(float n) {\n    return pal( n, vec3(0.5,0.5,0.5),vec3(0.0,0.5,0.5),vec3(.0,1.0,.0),vec3(0.62,0.33,0.37) );\n}\n\n\nvec2 opUC_s( vec2 a, vec4 matea,vec2 b, vec4 mateb, float k , out vec4 mate){\n    float h = clamp( 0.5+0.5*(b.x-a.x)/k, 0.0, 1.0 );\n    float d = mix( b.x, a.x, h ) - k*h*(1.0-h);\n    \n    mate = mix( mateb, matea, h ) - k*h*(1.0-h);\n    \n    if (a.x<b.x) {\n        return vec2(d,a.y);\n    }\n    return vec2(d,b.y);\n}\n\n\n// iq's distance functions\nfloat sdSphere( vec3 p, float s )\n{\n  return length(p)-s;\n}\n\nfloat opOnion( in float sdf, in float thickness )\n{\n    return abs(sdf)-thickness;\n}\n\nvec3 carToPol(vec3 p) {\n    float r = length(p);\n    float the = acos(p.z/r);\n    float phi = atan(p.y,p.x);\n    return vec3(r,the,phi);\n}\n\nvec3 carToCyl(vec3 p) {\n    float r = length(p.xy);\n    float the = atan(p.y/p.x);\n    return vec3(r,the,p.z);\n}\n\n\n// 2D rotation : pitch, yaw\nmat3 rotationXY( vec2 angle ) {\n\tvec2 c = cos( angle );\n\tvec2 s = sin( angle );\n\t\n\treturn mat3(\n\t\tc.y      ,  0.0, -s.y,\n\t\ts.y * s.x,  c.x,  c.y * s.x,\n\t\ts.y * c.x, -s.x,  c.y * c.x\n\t);\n}\n\nfloat pModPolar(inout vec2 p, float repetitions) { \n\tfloat angle = 2.*PI/repetitions; \n\tfloat a = atan(p.y, p.x) + angle/2.; \n\tfloat r = length(p); \n\tfloat c = floor(a/angle); \n\ta = mod(a,angle) - angle/2.; \n\tp = vec2(cos(a), sin(a))*r; \n    // For an odd number of repetitions, fix cell index of the cell in -x direction // (cell index would be e.g. -5 and 5 in the two halves of the cell): \n\tif (abs(c) >= (repetitions/2.)) c = abs(c);\n    return c;\n}\n\n\nfloat sdVerticalCapsule( vec3 p, float h, float r )\n{\n    p.z -= clamp( p.z, 0.0, h );\n    return length( p ) - r;\n}\n\nfloat blob(vec2 p,float r){\n    float f = smoothstep(0.2*r,r,length(p));\n    return f;\n}\n\n// https://www.shadertoy.com/view/4djSRW\n// Thanks to Dave_Hoskins\nvec2 hash22(vec2 p)\n{\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+19.19);\n    return fract((p3.xx+p3.yz)*p3.zy);\n\n}\n\nvec2 distortedCapsule(vec3 p, inout vec4 mate, float index){\n    float dtime = 1.8*p.z-time-1.; // mix time with space to create wave\n    float dt = sin((dtime)-0.8*sin(dtime)); // distorted time, asymmetric sine wave\n    p = rotationXY(vec2(0.0,0.15*p.z*dt))*p;\n    \n    // stem of tentacle\n    vec4 mate0 = mate;\n    \n    vec3 pcyl = carToCyl(p-vec3(0.9,0,0.));\n    vec2 ps = vec2(10.0*0.5*pcyl.y/PI,10.0*pcyl.z);\n   \tvec2 fps = fract(ps);\n    vec2 ips = floor(ps);\n    vec2 ran = hash22(ips);\n    //vec4 ran = texelFetch( iChannel0, (ivec2(ips)+70+int(index)), 0 );\n    float r = 0.1+0.3*ran.x;\n    float b = blob(fps-0.2-0.4*ran.xy, r);\n    mate0 = mix(mate0, vec4(1,1,0,0.8), (1.0-b)*smoothstep(0.0,0.5,pcyl.z)  );\n   \tvec2 d0 = vec2(sdVerticalCapsule(p-vec3(0.9,0,0.), 2.0,0.05*(4.0-1.5*p.z)), index);\n    \n    // bulb at end of tentacle\n    vec4 mate1 = vec4(mate.rgb, 0.6);\n    vec2 d1 = vec2(sdSphere(p-vec3(0.9,0,2.),0.2),11.0);\n    d0 = opUC_s(d0,mate0,d1,mate1,0.1,mate);\n\treturn d0;\n}\n\nvec2 map(in vec3 p, out vec4 mate, in bool doColor){\n    \n    vec3 pol = carToPol(p-vec3(0,0,-0.8));\n    mate = vec4(spectrum(0.45*pol.x),0.4);\n\n\n    \n    float dt = sin((time+2.5)-0.8*sin(time+2.5)); // distorted time, asymmetric sine wave\n    p.z += -0.2*dt;\n    \n    // center sphere\n    vec4 mate0 = mate;\n    vec2 d0 = vec2(opOnion(sdSphere(p-vec3(0,0,-0.7),0.5),0.001), 1.0);\n\n    // in center sphere\n    vec4 mate2 = vec4(1,1,1,0.8);\n    vec2 d2 = vec2(sdSphere(p-vec3(0,0,-0.7),0.25), 1.0);\n    \n    d0 = opUC_s(d0, mate0, d2, mate2, 0.3, mate0);\n    \n    // tentacles\n    float tentacleIndex = pModPolar(p.xy, 9.0);\n    p = rotationXY(vec2(0.0,-0.8))*p;\n    vec4 mate1 = mate;\n    vec2 d1 = distortedCapsule(p, mate1, tentacleIndex+6.0);// index from 2-10\n    \n    d0 = opUC_s(d0, mate0, d1, mate1, 0.5, mate);\n    \n    float a = 0.;\n    if (d0.y < 10.5) {\n        a = d0.y*0.1;\n    } else {\n        a = 1.0;\n    }\n\n    return d0;\n}\n\n// http://iquilezles.org/www/articles/normalsSDF/normalsSDF.htm\nvec3 calcNormal( in vec3 pos, in float ep )\n{\n    vec4 kk;\n#if 1\n    vec2 e = vec2(1.0,-1.0)*0.5773;\n    return normalize( e.xyy*map( pos + e.xyy*ep, kk, false ).x + \n\t\t\t\t\t  e.yyx*map( pos + e.yyx*ep, kk, false ).x + \n\t\t\t\t\t  e.yxy*map( pos + e.yxy*ep, kk, false ).x + \n\t\t\t\t\t  e.xxx*map( pos + e.xxx*ep, kk, false ).x );\n#else\n    // prevent the compiler from inlining map() 4 times\n    vec3 n = vec3(0.0);\n    for( int i=ZERO; i<4; i++ )\n    {\n        vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);\n        n += e*map(pos+e*ep, kk, false).x;\n    }\n    return normalize(n);\n#endif    \n    \n}\n\n\nvec3 fresnel( vec3 F0, vec3 h, vec3 l ) {\n\treturn F0 + ( 1.0 - F0 ) * pow( clamp( 1.0 - dot( h, l ), 0.0, 1.0 ), 5.0 );\n}\n\nmat3 calcLookAtMatrix( in vec3 ro, in vec3 ta, in float roll )\n{\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(sin(roll),cos(roll),0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n    return mat3( uu, vv, ww );\n}\n\nvec3 phongColor(in vec3 p, in vec3 rd){\n    \n    vec3 Ks = vec3(1.0); // specular reflected intensity\n    vec3 Kd = vec3(0.0); // diffuse reflected intensity\n    float shininess = 79.0;\n    \n   \tvec3 n = calcNormal( p, 0.01 );\n    vec3 ref = reflect( rd, n );\n    vec3 final = vec3(0);\n    \n   \t// light 0\n\t{\n\t\tvec3 light_pos   = vec3( 20.0, 20.0, 20.0 );\n\t\tvec3 light_color = vec3( 1.0, 1.0, 1.0 );\n\t\n\t\tvec3 vl = normalize( light_pos - p );\n\t\n\t\tvec3 diffuse  = Kd * vec3( max( 0.0, dot( vl, n ) ) );\n\t\tvec3 specular = vec3( max( 0.0, dot( vl, ref ) ) );\n\t\t\n        vec3 F = fresnel( Ks, normalize( vl - rd ), vl );\n\t\tspecular = pow( specular, vec3( shininess ) );\n\t\t\n\t\tfinal += light_color * mix( diffuse, specular, F ); \n\t}\n\t\n\t// light 1\n\t{\n\t\tvec3 light_pos   = vec3( -20.0, -20.0, -30.0 );\n\t\tvec3 light_color = vec3( 1.0, 1.0, 1.0 );\n\t\n\t\tvec3 vl = normalize( light_pos - p );\n\t\n\t\tvec3 diffuse  = Kd * vec3( max( 0.0, dot( vl, n ) ) );\n\t\tvec3 specular = vec3( max( 0.0, dot( vl, ref ) ) );\n        \n        vec3 F = fresnel( Ks, normalize( vl - rd ), vl );\n\t\tspecular = pow( specular, vec3( shininess ) );\n\t\t\n\t\tfinal += light_color * mix( diffuse, specular, F );\n\t}\n\n    //final += texture( iChannel0, ref ).rgb * fresnel( Ks, n, -dir );\n    \n    return final;\n}\n\n// The MINIMIZED version of https://www.shadertoy.com/view/Xl2XWt\nconst float MAX_TRACE_DISTANCE = 8.0;           // max trace distance\nconst float INTERSECTION_PRECISION = 0.009;        // precision of the intersection\nconst int NUM_OF_TRACE_STEPS = 200;\nconst float EPS_NORMAL = 0.01;\nconst float SCALE_DIST = 0.3;\n\n\nvec2 calcIntersection( in vec3 ro, in vec3 rd ){\n    float h =  INTERSECTION_PRECISION*2.0;\n    float t = 0.0;\n\tfloat res = -1.0;\n    float id = -1.;\n    vec4 kk;\n    \n    for( int i=0; i< NUM_OF_TRACE_STEPS ; i++ ){\n        if( h < INTERSECTION_PRECISION || t > MAX_TRACE_DISTANCE ) break;\n\t   \tvec2 m = map( ro+rd*t , kk, false);\n        h = m.x;\n        t += h*SCALE_DIST;\n        id = m.y;\n    }\n    if( t < MAX_TRACE_DISTANCE ) res = t;\n    if( t > MAX_TRACE_DISTANCE ) id =-1.0;\n    return vec2( res , id );\n}\n\nvec3 render( vec2 res , vec3 ro , vec3 rd ){\n  vec3 c = vec3(0);\n  if( res.y > -.5 ){\n      vec3 pos = ro + rd * res.x;\n      c = phongColor(pos, rd);\n  }\n  return c;\n}\n\n\n\nvoid mainImage( out vec4 fragColor, vec2 fragCoord ) {\n    \n    vec2 p = (-iResolution.xy + 2.0*fragCoord.xy)/iResolution.y;\n    vec3 ro = vec3( 5.0*cos(0.2*iTime-10.0), 1.0, 5.0*sin(0.2*iTime-10.0));\n    vec3 ta = vec3( 0. , 0. , 0. );\n    \n    float aa = 1.0/min(iResolution.y,iResolution.x);\n    \n    // camera matrix\n    mat3 camMat = calcLookAtMatrix( ro, ta, 0.0);  // 0.0 is the camera roll\n    \n\t// create view ray\n\tvec3 rd = normalize( camMat * vec3(p.xy, 1.9+0.8*sin(0.15*iTime+12.0)) ); // 3.0 is the lens length\n    \n    // rotate camera with mouse\n\tmat3 rot = rotationXY(iMouse.xy * vec2( 0.01, -0.01 ) );\n\trd = rot * rd;\n\tro = rot * ro;\n    \n    vec3 col = vec3(0);\n    vec3 sp;\n    vec4 mate;\n    \n    // volume rymarching\n\t// Ray distance, bail out layer number, surface distance and normalized accumulated distance.\n\tfloat t=0., layers=0., d, aD;\n    \n    // Surface distance threshold. Smaller numbers give a sharper object. Antialiased with aa\n    float thD = 0.2*sqrt(aa); \n    \n    // Only a few iterations seemed to be enough. Obviously, more looks better, but is slower.\n    for(int i=0; i<150; i++)\t{\n        if(layers>200. || col.g>1.0 || t>8.) break;\n        sp = ro + rd*t;\n        d = map(sp, mate, true).x; // Distance to nearest point in the cube field.\n        // Normalized distance from the surface threshold value to our current isosurface value.\n        aD = (thD-abs(d))/thD;\n        // If we're within the surface threshold, accumulate some color.\n        if(aD>0.) { \n            vec3 tc = mate.rgb*pow(mate.a,2.0);\n            col += 25.0*tc*(aD*aD*(3. - 2.*aD)/(1. + t*t*1.85));\n            layers += 20.0*pow(mate.a+0.2,2.0);\n        }\n        t += max(abs(d)*0.5, thD*0.5); \n\t}\n \n    // standard raymarching code to color the surface\n    vec2 res = calcIntersection( ro , rd  );\n    vec3 surfaceColor = render(res, ro, rd);\n    col += surfaceColor;\n\n    col = pow(col,vec3(0.9,1.,2.));\n\tfragColor = vec4(clamp(col, 0., 1.), 1);\n }\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3sBSWt.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[185, 256, 324, 324, 367], [369, 369, 393, 393, 490], [493, 493, 570, 570, 810], [813, 840, 875, 875, 899], [901, 901, 952, 952, 985], [987, 987, 1010, 1010, 1125], [1127, 1127, 1150, 1150, 1239], [1242, 1270, 1301, 1301, 1457], [1459, 1459, 1509, 1509, 1912], [1915, 1915, 1968, 1968, 2031], [2033, 2033, 2060, 2060, 2121], [2123, 2190, 2211, 2211, 2345], [2347, 2347, 2407, 2407, 3344], [3346, 3346, 3398, 3398, 4287], [4289, 4353, 4398, 4398, 4961], [4964, 4964, 5005, 5005, 5085], [5087, 5087, 5151, 5151, 5329], [5331, 5331, 5370, 5370, 6595], [6916, 6916, 6964, 6964, 7431], [7433, 7433, 7477, 7477, 7601], [7605, 7605, 7659, 7659, 9577]], "test": "timeout"}
{"id": "3sBXDy", "name": "Line space", "author": "edo_m18", "description": "Line space", "tags": ["line", "space"], "likes": 2, "viewed": 127, "published": "Public", "date": "1554886430", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define R iResolution\n#define S(a, b, t) smoothstep(a, b, t)\n\nmat2 rot(float a)\n{\n    float s = sin(a);\n    float c = cos(a);\n    return mat2(s, c, -c, s);\n}\n\nmat3 camera(vec3 ro, vec3 ta)\n{\n    const vec3 up = normalize(vec3(0, 1, 0));\n    vec3 cw = normalize(ta - ro);\n    vec3 cu = normalize(cross(cw, up));\n    vec3 cv = normalize(cross(cu, cw));\n    return mat3(cu, cv, cw);\n}\n\nfloat map(vec3 p)\n{\n    // Ping Pong on 0.5\n    vec3 q = abs(p);\n    q = abs(q - round(q));\n    \n    mat2 rm = rot(sin(iTime * 0.1));\n    q.xy *= rm;\n    q.xz *= rm;\n    \n    float l1 = length(q.xy);\n    float l2 = length(q.yz);\n    float l3 = length(q.xz);\n    \n    float d = min(min(l1, l2), l3);\n    \n    return d;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord * 2.0 - R.xy) / R.y;\n\n    vec2 mouse = (2.0 * (iMouse.xy / R.xy) - 1.0) * 5.0 + 0.1;\n    vec3 ro = vec3(mouse, iTime * 0.5);\n    vec3 ta = vec3(0.0, sin(iTime), iTime * 0.5 + 1.5);\n    \n    vec3 ray = camera(ro, ta) * normalize(vec3(uv, 1.5));\n    \n    float d = 0.0;\n    \n    float dist = 0.0;\n    for (int i = 0; i < 50; i++)\n    {\n        dist = map(ro + ray * d);\n                \n        if (dist < 0.01)\n        {\n            break;\n        }\n                \n        d += dist;\n    }\n    \n    vec3 col = vec3(0.0);\n    \n    if (dist < 0.01)\n    {\n        float r = 1.0 - d;\n        float g = exp(-d * 0.30) * 2.0;\n        float b = exp(-d * 0.50) * 2.0;\n        col = vec3(r, g, b);\n    }\n    \n    //col.rgb += mix(vec3(0.323, 0.334, 0.776), vec3(0.25, 0.3, 0.8), uv.y);\n    \n    fragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3sBXDy.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[62, 62, 81, 81, 157], [159, 159, 190, 190, 381], [383, 383, 402, 426, 702], [704, 704, 761, 761, 1603]], "test": "ok"}
{"id": "3sBXWV", "name": "SphereCast", "author": "mrsargas", "description": "Simple test", "tags": ["sphere"], "likes": 1, "viewed": 85, "published": "Public", "date": "1554914921", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\nvec2 sphIntersect( in vec3 ro, in vec3 rd, in vec4 sph )\n{\n\tvec3 oc = ro - sph.xyz;\n\tfloat b = dot( oc, rd );\n\tfloat c = dot( oc, oc ) - sph.w*sph.w;\n\tfloat h = b*b - c;\n\tif( h < 0.0 ) return vec2(-1.0);\n\treturn vec2(-b - sqrt( h ), -b + sqrt( h ));\n}\nfloat bump(in float x) \n{\n  return abs(x)>1.0? 0.0: 1.0 - x*x;\n} \nvec3 colormap(in float x) {\n    float r = 0.0, g = 0.0, b = 0.0;\n\n    float c = 3.0;\n    r = bump(c*(x - 0.75));\n    g = bump(c*(x - 0.5));\n    b = bump(c*(x - 0.25));\n    return vec3(r, g, b);\n}\n\nfloat planeIntersect( in vec3 ro, in vec3 rd )\n{\n  if(rd.y == 0.0)\n  return 1e15;\n  float distance = (-1.0 - ro.y)/rd.y;\n  if(distance<0.0)\n    distance = 1e20;\n  return distance;\n}\n\nvec3 getPlaneColor(in vec3 ro, in vec3 rd, in float dist)\n{\n  vec3 v =  ro + rd*dist;\n  float x = v.x*1.0;\n  float y = v.z*1.0;\n  float factor = (sin(x)*sin(x) + cos(y)*cos(y));\n  return vec3(colormap(factor/2.0));\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord)\n{\n  float currentDepth = 1e20;\n  float factor = 1.0;\n  vec2 uv = ((fragCoord.xy / iResolution.xy) - 0.5) * 3.0 *vec2(iResolution.x/iResolution.y, 1.0);\n  float x = uv.x;\n  float y = uv.y;\n  const int sizeOffsets = 10;\n  float []rgbOffsets = float[](\n    0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,\n    0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,\n    0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,\n    0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,\n    0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,\n    0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,\n    0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,\n    0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,\n    0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,\n    0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 );\n\n   for(int i = 0; i < sizeOffsets; i++ )\n    {\n      rgbOffsets[i] = 1.0 + 0.01 * float(i);\n    }\n\n  vec3 camPos = vec3(0.0, 0.0, -10);\n  vec3 pos = vec3(uv, 0.0);\n  vec4 sph = vec4( cos( iTime + vec3(2.0, 1.0, 3.0) + 0.0 )*vec3(1.0, 1.0, 1.0), 1.0 );\n\n  vec3 camDir = normalize(pos - camPos);\n  float plDist = max(planeIntersect(camPos, camDir), 0.0);\n \n  vec3 planeColor = getPlaneColor(camPos, camDir, plDist);\n  vec2 sphDist = max(sphIntersect(camPos, camDir, sph ), 0.0);\n  vec3 spherePos = camPos + sphDist.x*camDir;\n  vec3 sphereNormal = normalize( spherePos - sph.xyz ); \n  vec3 backgroundColor = vec3( 0.7, 0.7, 0.7);\n  vec4 color = vec4( backgroundColor, 1.0);\n  float ligth = dot( sphereNormal, normalize( sph.xzy ));\n  vec3 sphColor = vec3( 0.0 );\n\n  if(plDist < currentDepth)\n  {\n    color.xyz = planeColor.xyz;\n    currentDepth = plDist;\n  }\n  if( sphDist.x > 0.0)\n  {\n    sphColor = backgroundColor;\n    float colorLength = 0.0;\n    for(int i = 0; i < sizeOffsets; i++ )\n    {\n      float traceDepth = 1e20;\n      vec3 newDir = refract(camDir, sphereNormal, rgbOffsets[i]);\n     \n      vec2 refrCol = abs(sphIntersect(spherePos, newDir, sph ));\n   \n      vec3 refrSpherePos = spherePos + refrCol.y*(newDir);\n\n      vec3 refrSphereNormal = normalize(refrSpherePos - sph.xyz);\n\n      vec3 dir = refract(newDir, refrSphereNormal, rgbOffsets[i]); \n     \n      float refrPlDist = max(planeIntersect(refrSpherePos, dir), 0.0);\n\n      vec3 planeColor = getPlaneColor(refrSpherePos, dir, refrPlDist);\n      vec3 rgbColor = vec3( colormap(float(i) /float(sizeOffsets) ) );\n\n      sphColor.xyz += planeColor*rgbColor;\n      colorLength += length(1.0);\n      if( refrPlDist < traceDepth)\n      {\n        traceDepth = refrPlDist;\n      }\n    \n    }\n    if(sphDist.x < currentDepth)\n    {\n      color.xyz = sphColor.xyz/colorLength ;\n      currentDepth = sphDist.x;\n    }\n    \n  }\n\n  fragColor = vec4( color.xyz, 1.0);\n\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3sBXWV.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 1, 59, 59, 252], [253, 253, 278, 278, 317], [319, 319, 346, 346, 514], [516, 516, 564, 564, 697], [699, 699, 758, 758, 915]], "test": "error"}
{"id": "3sjSD3", "name": "QuickGrid", "author": "Wunkolo", "description": "Quick test for fwidth-based grid drawing", "tags": ["grid", "algorithm"], "likes": 0, "viewed": 45, "published": "Public", "date": "1555111391", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    uv += iTime / 10.0;\n    uv.x *= iResolution.x / iResolution.y;\n    uv *= 15.0;\n    \n    vec2 grid = abs(fract(uv - 0.5) - 0.5) / fwidth(uv);\n    float line = min(grid.x,grid.y);\n    float edge = 1.0 - min(line,1.0);\n    fragColor = vec4(vec3(edge),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3sjSD3.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 357]], "test": "ok"}
{"id": "3sjSDK", "name": "Retro cube on raster-display", "author": "MacSlow", "description": "Me pretending to have been (or be) part of the demoscene :) Maybe I will be after attending Revision 2019 next week.", "tags": ["2d", "retro", "sdf", "cube", "lines", "box"], "likes": 15, "viewed": 1085, "published": "Public API", "date": "1554959387", "time_retrieved": "2021-10-01T00:00:00", "image_code": "////////////////////////////////////////////////////////////////////////////////\n//\n// Retro cube - mimic a vectors-cube on an old CRT-display\n//\n// Copyright 2019 Mirco Müller\n//\n// Author(s):\n//   Mirco \"MacSlow\" Müller <macslow@gmail.com>\n//\n// This program is free software: you can redistribute it and/or modify it\n// under the terms of the GNU General Public License version 3, as published\n// by the Free Software Foundation.\n//\n// This program is distributed in the hope that it will be useful, but\n// WITHOUT ANY WARRANTY; without even the implied warranties of\n// MERCHANTABILITY, SATISFACTORY QUALITY, or FITNESS FOR A PARTICULAR\n// PURPOSE.  See the GNU General Public License for more details.\n//\n// You should have received a copy of the GNU General Public License along\n// with this program.  If not, see <http://www.gnu.org/licenses/>.\n//\n////////////////////////////////////////////////////////////////////////////////\n\nconst vec3 red = vec3 (1.0, 0.0, 0.0);\nconst vec3 green = vec3 (0.0, 1.0, 0.0);\nconst vec3 blue = vec3 (0.0, 0.0, 1.0);\nconst vec3 white = vec3 (1.0);\nconst vec3 orange = vec3 (1.0, 0.4, 0.125);\nconst vec3 black = vec3 (0.2, 0.3, 0.2);\nconst vec3 cyan = vec3 (0.0, 1.0, 1.0);\nconst vec3 magenta = vec3 (1.0, 0.0, 1.0);\nconst vec3 yellow = vec3 (1.0, 1.0, 0.0);\nconst float SIZE = .003;\n\nfloat distLine (vec2 p, vec2 a, vec2 b) {\n    vec2 pa = p - a;\n    vec2 ba = b - a;\n    float t = clamp ( dot (pa, ba) / dot (ba, ba), .0, 1.);\n    return length (pa - ba*t);\n}\n\nfloat lineMask (vec2 uv, vec2 a, vec2 b) {\n    float d = distLine (uv, a, b);\n    float thickness = SIZE;\n    return smoothstep (thickness, .125*thickness, d);\n}\n\nvec3 glowLine (vec2 uv, vec2 a, vec2 b, vec3 rgbGlow) {\n    float m = lineMask (uv, a, b);\n    float dist = distLine (uv, a, b);\n    float brightness = SIZE/pow (.085 + 2.*dist, 2.);\n    vec3 color = m*vec3 (.7);\n    color += rgbGlow*brightness;\n\treturn color;\n}\n\nstruct boxType {vec4 p[8];};\n\nmat4 trans (vec3 t)\n{\n    mat4 mat = mat4 (vec4 (1., .0, .0, .0),\n                     vec4 (.0, 1., .0, .0),\n                     vec4 (.0, .0, 1., .0),\n                     vec4 (t.x, t.y, t.z, 1.));\n    return mat;\n}\n\nmat4 rotX (float angle)\n{\n    float rad = radians (angle);\n    float c = cos (rad);\n    float s = sin (rad);\n\n    mat4 mat = mat4 (vec4 (1., .0, .0, .0),\n                     vec4 (.0,   c,   s, .0),\n                     vec4 (.0,  -s,   c, .0),\n                     vec4 (.0, .0, .0, 1.));\n\n    return mat;\n}\n\nmat4 rotY (float angle)\n{\n    float rad = radians (angle);\n    float c = cos (rad);\n    float s = sin (rad);\n\n    mat4 mat = mat4 (vec4 (  c, .0,  -s, .0),\n                     vec4 (.0, 1., .0, .0),\n                     vec4 (  s, .0,   c, .0),\n                     vec4 (.0, .0, .0, 1.));\n\n    return mat;\n}\n\nmat4 rotZ (float angle)\n{\n    float rad = radians (angle);\n    float c = cos (rad);\n    float s = sin (rad);\n\n    mat4 mat = mat4 (vec4 (  c,   s, .0, .0),\n                     vec4 ( -s,   c, .0, .0),\n                     vec4 (.0, .0, 1.0, .0),\n                     vec4 (.0, .0, .0, 1.));\n\n    return mat;\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (fragCoord/iResolution.xy)* 2. - 1.;\n    uv.x *= iResolution.x/iResolution.y;\n    uv *= 1. + .4*length(uv);\n    uv.x += .0035*cos(40.*uv.y + 2.*iTime);\n\n    boxType box;\n    box.p[0] = vec4 ( 0.1,  0.1,  0.1, 1.0);\n    box.p[1] = vec4 ( 0.1, -0.1,  0.1, 1.0);\n    box.p[2] = vec4 (-0.1, -0.1,  0.1, 1.0);\n    box.p[3] = vec4 (-0.1,  0.1,  0.1, 1.0);\n    box.p[4] = vec4 ( 0.1,  0.1, -0.1, 1.0);\n    box.p[5] = vec4 ( 0.1, -0.1, -0.1, 1.0);\n    box.p[6] = vec4 (-0.1, -0.1, -0.1, 1.0);\n    box.p[7] = vec4 (-0.1,  0.1, -0.1, 1.0);\n\n    float t = 8. + 14.*iTime;\n    mat4 rot3d = rotX (-4.*t)*rotY (3.*t)*rotZ (2.*t);\n    mat4 model = trans (vec3 (.0, .0, -.275))*rot3d;\n    box.p[0] = model * box.p[0];\n    box.p[1] = model * box.p[1];\n    box.p[2] = model * box.p[2];\n    box.p[3] = model * box.p[3];\n    box.p[4] = model * box.p[4];\n    box.p[5] = model * box.p[5];\n    box.p[6] = model * box.p[6];\n    box.p[7] = model * box.p[7];\n\n    vec3 boxCol = glowLine (uv, box.p[0].xy / box.p[0].z, box.p[1].xy / box.p[1].z, red);\n    boxCol += glowLine (uv, box.p[1].xy / box.p[1].z, box.p[2].xy / box.p[2].z, green);\n    boxCol += glowLine (uv, box.p[2].xy / box.p[2].z, box.p[3].xy / box.p[3].z, orange);\n    boxCol += glowLine (uv, box.p[3].xy / box.p[3].z, box.p[0].xy / box.p[0].z, cyan);\n    boxCol += glowLine (uv, box.p[4].xy / box.p[4].z, box.p[5].xy / box.p[5].z, blue);\n    boxCol += glowLine (uv, box.p[5].xy / box.p[5].z, box.p[6].xy / box.p[6].z, red);\n    boxCol += glowLine (uv, box.p[6].xy / box.p[6].z, box.p[7].xy / box.p[7].z, yellow);\n    boxCol += glowLine (uv, box.p[7].xy / box.p[7].z, box.p[4].xy / box.p[4].z, green);\n    boxCol += glowLine (uv, box.p[0].xy / box.p[0].z, box.p[4].xy / box.p[4].z, blue);\n    boxCol += glowLine (uv, box.p[1].xy / box.p[1].z, box.p[5].xy / box.p[5].z, cyan);\n    boxCol += glowLine (uv, box.p[2].xy / box.p[2].z, box.p[6].xy / box.p[6].z, green);\n    boxCol += glowLine (uv, box.p[3].xy / box.p[3].z, box.p[7].xy / box.p[7].z, magenta);\n\n    boxCol = boxCol / (1. + boxCol);\n    boxCol = sqrt (boxCol);\n    boxCol *= mix (1., .5, .5 + .5*cos (500.*uv.y));\n\n    fragColor = vec4(boxCol, 1.);\n}", "image_inputs": [{"id": "4tlGDM", "previewfilepath": "https://soundcloud.com/demoscenemusic/fff-keygen-intro", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0, "src": "https://soundcloud.com/demoscenemusic/fff-keygen-intro", "ctype": "musicstream"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3sjSDK.jpg", "access": "shaders20k", "license": "gpl-3.0", "functions": [[1326, 1326, 1367, 1367, 1502], [1504, 1504, 1546, 1546, 1665], [1667, 1667, 1722, 1722, 1929], [1961, 1961, 1982, 1982, 2180], [2182, 2182, 2207, 2207, 2491], [2493, 2493, 2518, 2518, 2802], [2804, 2804, 2829, 2829, 3114], [3116, 3116, 3172, 3172, 5332]], "test": "ok"}
{"id": "3sjXDc", "name": "Noobies Sinescape", "author": "rgbees", "description": "Trying to get the hang of plotting functions, drawing and a bit of lighting", "tags": ["landscape", "noob", "sine", "mountains"], "likes": 1, "viewed": 69, "published": "Public", "date": "1555160640", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const float pi = 3.1415926;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n\n    float scale = min(iResolution.x, iResolution.y);    \n    vec2 uv = fragCoord / scale * 2.5 + vec2(0.0,-1.25);\n    float x = uv.x;\n    float y = uv.y;\n    float t = iTime;\n    float xpi = x * pi;\n    float ypi = y * pi;\n\n    \n    float ast = 0.5 + 0.3 * abs(sin(t * 0.5));\n\n    float f = pow(sin(xpi * ast*0.75) * ast * 0.8, 3.0);\n    \n    float lineWidth = 0.5 * ast;\n    \n    float r = sin(y)*2.0;\n    \n    float sun = sin(t) * (sin(x / 2.5) + sin(y / 2.5));\n    \n    float mountains = y - f < lineWidth ? r : 0.0;\n  \n    float plains = -sin(ypi / 3.0);\n    float sky = sin(ypi / 3.0);\n\n    float stars = \n        y > 0.75 ? \n        (mod((x+y*sin(t/100.0*sin(t/10.0))+sin((t+y)/100.0))*100.0 , 50.0) < 2.0 ? 1.0 : 0.0) * \n        (mod((y+x*sin(t/100.0*sin(t/10.0))+sin((t+x)/100.0))*100.0 , 50.0) < 2.0 ? 1.0 : 0.0)  \n        //        (mod((y+sin((t+x)/100.0))*100.0 , 30.0) < 2.0 ? 1.0 : 0.0)  \n\n        : 0.0;\n    \n    vec3 color = \n        vec3(stars, stars, stars) +\n        vec3(sun, sun, 0) +\n        vec3(0, abs(plains), 0) +\n        vec3(0, 0, mountains > 0.1 ? 0.0 : sky) +\n    \tvec3(mountains, 0, 0);\n    \n    fragColor = vec4(color.xyz, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3sjXDc.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[29, 29, 86, 136, 1300]], "test": "ok"}
{"id": "3sjXDG", "name": "Sound Track", "author": "Passion", "description": "I decided to texture the previous shader 'On Track' after reading MacSlows comment.  Also added a much better sky from a previous shader I did 'Going Coastal' with better fogging of the background terrain and track.", "tags": ["raymarch", "texture", "bumpmap", "soundcloud"], "likes": 4, "viewed": 212, "published": "Public", "date": "1554850233", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define NUM_STEPS 100\n#define FUDGE_AMOUNT 0.75\n#define EPS 0.001\n#define FAR 75.0\n\n#define PI 3.1415926535898\nvec3 sunCenter = vec3(1.0,1.0,0.2)*6.;\nvec3 sunPeriph = vec3(1.0,0.3568,0.078)*5.;\n\nvec3 sunEarthBottom = vec3(0.5)*4.;\nvec3 sunEarthTop = vec3(0,0.49,0.69)*3.;\n\n//void doScatter(inout vec3 dSC, inout vec3 sEC, in vec3 sp, in vec3 l, in vec3 r, in vec3 o);\n// sebastien.hillaire.free.fr/demos/godray/godray.htm\nvoid doScatter(inout vec3 dSC, inout vec3 sEC, in vec3 sp, in vec3 l, in vec3 r, in vec3 o){\n    vec3 ctpn = normalize(sp-o);\n\n    //direct sun color\n    float directSun = dot(ctpn, normalize(l+r));\n    directSun = pow( clamp(directSun,0.0,1.0), 125.0);\n\n    // atmosphere\n    float sunEarthScatering = 1.0-dot(ctpn, vec3(0.0,1.0,0.0));\n    sunEarthScatering = pow( clamp(sunEarthScatering,0.0,1.0), 5.0);\n    vec4 skyBlend = pow(1.*vec4(.1, .75, .8, 1), vec4(4.*(1.*r.y-.15)));\n    sunEarthTop = 4.* pow(vec4(.1, .7, .8, 1).rgb, vec4(4.*max(r.y,-0.141)+1.5).rgb);\n\n    // learp or mix based on directional lights 'y' coord/dir\n    sunEarthTop = mix(.65*skyBlend.rgb, sunEarthTop, l.y);\n    sunEarthBottom = mix(vec3(.5)*sunEarthBottom, sunEarthBottom, l.y);\n    \n    //lerp color and add contribution of sun and atmosphere\n    dSC = mix(sunPeriph,sunCenter,directSun)*directSun;\n    sEC = mix(sunEarthTop,sunEarthBottom,sunEarthScatering);\n}\n\nvec3 tri(in vec3 x){return abs(x-floor(x)-.5);} // Triangle function.\n\nfloat surfFunc(in vec3 p){\n\treturn dot(tri(p*0.5 + tri(p*0.25).yzx), vec3(0.777));\n}\n\nvec2 path(in float z){ float s = sin(z/34.)*cos(z/12.)*cos(sin(z/20.)); return vec2(s*20.+sin(s)*5.1, -2.25*s*15.); }\n\nmat3 lookAtMatrix(vec3 origin, vec3 target, float roll) {\n    vec3 rr = vec3(sin(roll), cos(roll), 0.0);\n    vec3 ww = normalize(target - origin);\n    vec3 uu = normalize(cross(ww, rr));\n    vec3 vv = normalize(cross(uu, ww));\n\n    return mat3(uu, vv, ww);\n}\n\nmat2 r2(float a){\n    float s = sin(a);\n    float c = cos(a);\n    return mat2(s, -c, c, s);\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return length(max(d,0.0))\n         + min(max(d.x,max(d.y,d.z)),0.0); // remove this line for an only partially signed sdf \n}\n\nfloat sdRoundBox( vec3 p, vec3 b, float r )\n{\n  vec3 d = abs(p) - b;\n  return length(max(d,0.0)) - r\n         + min(max(d.x,max(d.y,d.z)),0.0); // remove this line for an only partially signed sdf \n}\n\nfloat trackPlanks(vec3 tp){\n    tp.xy = (tp.xy - path(tp.z))*vec2(0.5, 0.47071);\n    tp.z = mod(tp.z, 1.) -0.5;\n    float bmp2 = texture(iChannel1, tp.xz/4.).r*.015;\n    return sdBox(vec3(tp.x,tp.y+1.4,tp.z), vec3(1., .05152, .2))+bmp2;\n}\nfloat trackRails(vec3 tp){\n    tp.xy = (tp.xy - path(tp.z))*vec2(0.5, 0.47071);\n    tp.z = mod(tp.z, 1.) -0.5;\n    tp.x = abs(tp.x)-1.;\n    return sdRoundBox(vec3(tp.x, tp.y+1.3, tp.z), vec3(.015, .015, .5), .12);\n}\nfloat map(vec3 p){\n    float ground = p.y + (sin(sin(p.z*0.1253) - p.x*0.311)*1.31 + cos(p.z*0.53 + sin(p.x*0.127))*0.12)*1.7 + 0.2;\n    ground += tri(p).y;\n    float bmp = texture(iChannel0, p.xz/10.).r*.05;\n    float tx = textureLod(iChannel3, p.xz/66. + p.xy/50., 0.0).x;\n\n    ground+=bmp;\n\n    vec2 tun = (p.xy - path(p.z))*vec2(0.5, 0.47071);\n    float n = 1.- length(tun) + (0.5);\n    n += surfFunc(p/2.);\n    n+=tx;\n      \n    float planks = trackPlanks(p);\n    float rails = trackRails(p);\n        \n    return min(min(max(ground, n), planks), rails);\n}\n\nfloat trace(vec3 o, vec3 r){\n    float t = 0.0;\n    for(int i = 0; i < NUM_STEPS; i++){\n        float d = map(o+r*t);\n        t += d * FUDGE_AMOUNT;\n        if(abs(d) < EPS || t > FAR) break;\n    }\n    return t;\n}\n// Surface normal.\nvec3 getNormal(in vec3 p) {\n\t\n\tconst float eps = 0.001;\n\treturn normalize(vec3(\n\t\tmap(vec3(p.x + eps, p.y, p.z)) - map(vec3(p.x - eps, p.y, p.z)),\n\t\tmap(vec3(p.x, p.y + eps, p.z)) - map(vec3(p.x, p.y - eps, p.z)),\n\t\tmap(vec3(p.x, p.y, p.z + eps)) - map(vec3(p.x, p.y, p.z - eps))\n\t));\n\n}\n// Tri-Planar blending function. Based on an old Nvidia tutorial.\nvec3 tex3D( sampler2D tex, in vec3 p, in vec3 n ){\n  \n    n = max((abs(n) - 0.2)*7., 0.001); // max(abs(n), 0.001), etc.\n    n /= (n.x + n.y + n.z );  \n    \n\treturn (texture(tex, p.yz)*n.x + texture(tex, p.zx)*n.y + texture(tex, p.xy)*n.z).xyz;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    uv -= .5; uv.x *= iResolution.x / iResolution.y;\n    vec3 r = normalize(vec3(uv, 1.0 - dot(uv, uv) * .33));\n    vec3 o = vec3(0.0, 0.0, iTime*15.0);\n    \n    vec3 lookAt = o + vec3(0.0, -0.05,.245);\n    o.xy += path(o.z);\n    lookAt.xy +=path(lookAt.z);    \n    \n    mat3 camMat = lookAtMatrix(o, lookAt, -o.x/15.);  //clamp(o.x/3.,-.3,.3));\n    r = normalize(camMat * r);\n    \n    float hit = trace(o, r);\n    vec3 surfPos = o + r * hit;\n    vec3 n = getNormal(surfPos);\n    vec4 bg = vec4(0.0);\n    vec3 l = normalize(vec3(0.1, 0.38+sin(iTime*.75)*.5, 0.4));\n    l.xz *= r2(iTime*2.);\n    float diff = max(dot(n,l), 0.25);\n    \n    float fog = smoothstep(01.175, 02.75, hit*0.03);\n    fragColor=vec4(0.0);\n    \n    float d = map(surfPos);\n    float d2 = trackRails(surfPos);\n    float d3 = trackPlanks(surfPos);\n    vec3 rf = reflect(r,n);\n    //vec3 cmp = texture(iChannel2, rf).rgb;\n    \n    vec3 directSunContrib = vec3(0.0);\n    vec3 sunEarthContrib = vec3(0.0);\n    doScatter(directSunContrib, sunEarthContrib, surfPos, l, r, o);\n    \n    bg = 0.25 * vec4( sunEarthContrib, 1.0);\n    \n    if(abs(d) < EPS+.4){\n        vec3 tx= tex3D(iChannel0, surfPos/20., n);\n        fragColor = mix(vec4(tx, 1.0)*vec4(1.0*diff), bg, fog);        //+ hit* -.04;\n        if(abs(d2)<EPS+.01)\n            fragColor = mix(vec4(vec3(.7, 0.4, 0.4), 1.0)*diff,bg,fog);  //\n        else if(abs(d3) < EPS+0.1){\n            vec4 tx = texture(iChannel1, surfPos.xz);\n            fragColor = mix(tx*diff,bg,fog);//*+vec4(0.2, 0.5, 0.3, 1.0)*diff*vec4(cmp,1.0);\n        }\n    }\n    else\n        fragColor = vec4(0.25 * vec4( directSunContrib + sunEarthContrib, 1.0));\n}", "image_inputs": [{"id": "XsfGRn", "previewfilepath": "/media/ap/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg", "ctype": "texture"}, {"id": "4df3Rr", "previewfilepath": "/media/ap/3871e838723dd6b166e490664eead8ec60aedd6b8d95bc8e2fe3f882f0fd90f0.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/3871e838723dd6b166e490664eead8ec60aedd6b8d95bc8e2fe3f882f0fd90f0.jpg", "ctype": "texture"}, {"id": "XdXGzr", "previewfilepath": "/media/ap/8979352a182bde7c3c651ba2b2f4e0615de819585cc37b7175bcefbca15a6683.jpg", "channel": 3, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/8979352a182bde7c3c651ba2b2f4e0615de819585cc37b7175bcefbca15a6683.jpg", "ctype": "texture"}, {"id": "4tl3WM", "previewfilepath": "https://soundcloud.com/federationrecords/deadmau5-snowcone-original-mix", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0, "src": "https://soundcloud.com/federationrecords/deadmau5-snowcone-original-mix", "ctype": "musicstream"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3sjXDG.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[273, 422, 514, 514, 1364], [1366, 1366, 1386, 1386, 1413], [1437, 1437, 1463, 1463, 1521], [1523, 1523, 1545, 1545, 1640], [1642, 1642, 1699, 1699, 1900], [1902, 1902, 1919, 1919, 1995], [1997, 1997, 2028, 2028, 2178], [2180, 2180, 2225, 2225, 2379], [2381, 2381, 2408, 2408, 2619], [2620, 2620, 2646, 2646, 2835], [2836, 2836, 2854, 2854, 3396], [3398, 3398, 3426, 3426, 3611], [3612, 3631, 3658, 3658, 3918], [3919, 3985, 4035, 4035, 4231], [4232, 4232, 4289, 4339, 6032]], "test": "error"}
{"id": "3slGWM", "name": "Circle parametrizations", "author": "iq", "description": "Some different circle parametrizations, and the math behind them to make them as constant speed as possible, without trigonometry. Maybe.", "tags": ["2d", "circle"], "likes": 10, "viewed": 525, "published": "Public API", "date": "1555546158", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// The MIT License\n// Copyright © 2019 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n/*\n\n Trying to parametrize a circle without using trigonometry. Two\n possible ways to do so are:\n\n * p(t) = sqrt( 1-t, t )\n * p(t) = ( 1-t², 2t ) / (1+t²)\n\n When plotted you'll see points equidistant in parameter space\n are not equidistant in the plane or across arcelength. The \n reason is the tangent to the curve, p'(t), has no constant\n length. Let's try to fix it.\n\n\n\n 1. Fixing p(t) = sqrt( 1-t, t );\n\n We compute the length (squared) of the tangent. We wish that\n was a constant, but it's not:\n\n |p'(t)|² = 1/[ 4·t·(1-t) ]\n\n We can try to fix it by introducing a reparametrization s(t),\n still to be determined, such that we now do\n\n p(s(t)) = sqrt( 1-s(t), s(t) )\n\n and\n\n |p'(t)|² = s'(t)² / [ 4·s(t)·(1-s(t)) ]\n\n Since we want the derivative to be constant, we need to\n choose s(t) such that its squared derivative is proportional\n to itself minus its square. That sounds a lot like the kind\n of thing trigonometric functioins do. And indeed, with some\n exploration you can quickly find that\n\n s(t) = 1/2 - 1/2·cos(PI·t)\n\n produces exactly a consant derivative! So, \n\n s(t) = 1/2 - 1/2·cos(PI·t)\n p(s(t)) = sqrt( 1-s(t), s(t) )\n\n will produce an perfect circle. However, the point was to\n avoid using trigonometrics. So here's an alternative: do\n s(t) = t²(3-2t), a cubic smoothstep, which is close to the\n cosine curve.\n\n This approximation only changes the position of the sampling\n points along the circle. The circle itself is still a perfect\n curcle, for |p(t)| is still 1 exactly.\n\n \n\n 2. Fixing p(t) = ( 1-t², 2t ) / (1+t²);\n\n We proceed similary. In this case,\n  \n |p'(t)| = 2/(1+t²)\n\n So we introduce a reparametrization\n\n p(s(t)) = p = ( 1-s²(t), 2s(t) ) / (1+s²(t));\n\n and by the chain rule |p'(s(t))| = |s'(t)|·|p'(s(t))|. Then\n\n s'(t) = (1+s²(t))·k/2\n\n Since we want s(0)=0 and s(1)=1, that means k=s'(1)\n \n s'(t) = (1+s²(t))·s'(1)/2\n\n which can be fulfilled by s(t) = tan(t*PI/4), so\n\n s(t) = tan(t*PI/4)\n p(t) = ( 1-t², 2t ) / (1+t²)\n\n is a perfect cicle. But we can approximate s(t) by  \n\n s(t) = t*(0.7612+t*t*0.2388) \t\t\t\t\t\t\t MSE=1.32e-5  ERR=5.4e-3\n s(t) = t*(0.787756+t*t*(0.145251+t*t*0.066993)) \t\t MSE=1.06e-7  ERR=4.9e-4\n s(t) = t*(0.7856+t*t*(0.1604+t*t*(0.0382+t*t*0.01578))) MSE=2.35e-9  ERR=8.1e-5\n \n in which case we still have a perfect circle with\n nearly-perfectly equidistant points. \n*/\n\n\n// 0 : p(t) = ( cos(t), sin(t) )\n// 1 : p(t) = sqrt( 1-t, t )\n// 2 : p(t) = ( 1-t², 2t ) / (1+t²)\n#define PARMATRIZATION 1\n\n// Make 16 to see more dramatic effets\n#define NUMPOINTS 50\n\n\n//----------------------------------------\nconst float pi = 3.1415926535;\n\nvec2 circle( in float t )\n{\n#if PARMATRIZATION==0\n    vec2 p = vec2( -sin(2.0*pi*t), cos(2.0*pi*t) );\n#endif\n    \n#if PARMATRIZATION==1\n    float s = fract(t*4.0);\n    \n  //s = 0.5-0.5*cos( s*pi ); // exact\n    s = s*s*(3.0-2.0*s);       // approximation\n    \n    vec2 p = sqrt( vec2(1.0-s,s) );\n         if( t<0.25 ) p = vec2(-p.y, p.x);\n    else if( t<0.50 ) p = vec2(-p.x,-p.y);\n    else if( t<0.75 ) p = vec2( p.y,-p.x);\n#endif\n        \n#if PARMATRIZATION==2\n    float s = fract(t*4.0);\n        \n    #if 0\n  \ts = tan(s*3.14159/4.0);     // exact\n    #else \n  \tfloat s2 = s*s; \t\t\t// approximation\n  //s = s*(0.7612+s2*0.2388);  \t\t\t\t\t\t\t// MSE=1.32e-5  ERR=5.4e-3\n    s = s*(0.787756+s2*(0.145251+s2*0.066993)); \t\t// MSE=1.06e-7  ERR=4.9e-4\n  //s = s*(0.7856+s2*(0.1604+s2*(0.0382+s2*0.01578))); \t// MSE=2.35e-9  ERR=8.1e-5\n    #endif\n\n           \n    vec2 p = vec2( 1.0-s*s, 2.0*s ) / (1.0+s*s);\n         if( t<0.25 ) p = vec2(-p.y, p.x);\n    else if( t<0.50 ) p = vec2(-p.x,-p.y);\n    else if( t<0.75 ) p = vec2( p.y,-p.x);\n#endif        \n        \n    return p;\n}\n        \n//----------------------------------------\n\nfloat sdSegment( in vec2 p, in vec2 a, in vec2 b )\n{\n\tvec2 pa = p - a, ba = b - a;\n\tfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n\treturn length( pa - ba*h );\n}\n\nfloat animate( float t )\n{\n    return fract(t+iTime*0.05);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    const float sc = 1.2;\n\n    float px = sc*2.0/iResolution.y;\n\tvec2  p  = sc*(2.0*fragCoord-iResolution.xy)/iResolution.y;\n\n    // compute distance to shape, brute force way\n    vec2 o = circle(animate(0.0));\n    vec2 d = vec2(length( p - o ));\n    for( int i=0; i<NUMPOINTS; i++ )\n    {\n        float t = animate(float(i+1)/float(NUMPOINTS));\n        vec2  c = circle(t);\n        float w = sdSegment( p, o, c );\n        d = min( d, vec2(w, length(p-c)-0.02) );\n        o = c;\n\t}\n    \n\t// colorize\n    vec3 col = vec3(0.25)*(1.0-0.1*length(p));\n    col = mix( col, vec3(1.0,1.0,1.0), 1.0 - smoothstep(0.0, 2.0*px, d.x ) );\n    col = mix( col, vec3(1.0,0.7,0.0), 1.0 - smoothstep(0.0, 2.0*px, d.y ) );\n    \n    // dither\n    col += (1.0/128.0)*cos(31.1*dot(fragCoord,vec2(57.,13.)));\n\n    fragColor = vec4( col, 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3slGWM.jpg", "access": "shaders20k", "license": "mit", "functions": [[3697, 3697, 3724, 3724, 4763], [4817, 4817, 4869, 4869, 4983], [4985, 4985, 5011, 5011, 5045], [5047, 5047, 5104, 5104, 5926]], "test": "ok"}
{"id": "3slXDX", "name": "random shiz", "author": "johannco98", "description": "asasd", "tags": ["asd"], "likes": 0, "viewed": 49, "published": "Public", "date": "1554889741", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float rect(vec2 uv, vec2 pos, float width, float height)\n{\n    float square = (step(pos.x - width, uv.x) - step(pos.x + width, uv.x)) *\n                   (step(pos.y - height, uv.y) - step(pos.y + height, uv.y));\n    \n    \n    return square;\n}\n\nfloat Circle(vec2 uv, vec2 pos, float rad, float blur) \n{\n\tfloat d = length(uv-pos);\n\tfloat t = smoothstep(rad, rad-blur, d);\n    \n    \n\treturn t;\n}\n\nfloat rand(vec2 uv)\n{\n    //return fract(sin(dot(uv, vec2(12.9898,78.233)))*10000.*iTime);\n\t//return fract(sin(dot(uv, iMouse.xy))*10000.);\n\t//return (fract(sin(dot(uv, vec2(12., 70.)))*100000.));\n    return (fract(sin(dot(uv, vec2(12., 70.)))*43758.5453123));\n}\n\n// Value noise\nfloat noise(in vec2 st) {\n    vec2 i = floor(st);\n    vec2 f = fract(st);\n\n    // Four corners in 2D of a tile\n    float a = rand(i);\n    float b = rand(i + vec2(1.0, 0.0));\n    float c = rand(i + vec2(0.0, 1.0));\n    float d = rand(i + vec2(1.0, 1.0));\n\n    // Smooth Interpolation\n\n    // Cubic Hermine Curve.  Same as SmoothStep()\n    vec2 u = f*f*(3.0-2.0*f);\n    // u = smoothstep(0.,1.,f);\n\n    // Mix 4 coorners porcentages\n    return mix(a, b, u.x) + \n            (c - a)* u.y * (1.0 - u.x) + \n            (d - b) * u.x * u.y;\n}\n\n// Gradient noise\nvec2 hash( vec2 x )  // replace this by something better\n{\n    const vec2 k = vec2( 0.3183099, 0.3678794 );\n    x = x*k + k.yx;\n    return -1.0 + 2.0*fract( 16.0 * k*fract( x.x*x.y*(x.x+x.y)) );\n}\n\nfloat gnoise( in vec2 p )\n{\n    vec2 i = floor( p );\n    vec2 f = fract( p );\n\t\n\tvec2 u = f*f*(3.0-2.0*f);\n\n    return mix( mix( dot( hash( i + vec2(0.0,0.0) ), f - vec2(0.0,0.0) ), \n                     dot( hash( i + vec2(1.0,0.0) ), f - vec2(1.0,0.0) ), u.x),\n                mix( dot( hash( i + vec2(0.0,1.0) ), f - vec2(0.0,1.0) ), \n                     dot( hash( i + vec2(1.0,1.0) ), f - vec2(1.0,1.0) ), u.x), u.y);\n}\n\n// Simplex noise\nvec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec2 mod289(vec2 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec3 permute(vec3 x) { return mod289(((x*34.0)+1.0)*x); }\n\nfloat snoise(vec2 v) {\n    const vec4 C = vec4(0.211324865405187,  // (3.0-sqrt(3.0))/6.0\n                        0.366025403784439,  // 0.5*(sqrt(3.0)-1.0)\n                        -0.577350269189626,  // -1.0 + 2.0 * C.x\n                        0.024390243902439); // 1.0 / 41.0\n    vec2 i  = floor(v + dot(v, C.yy) );\n    vec2 x0 = v -   i + dot(i, C.xx);\n    vec2 i1;\n    i1 = (x0.x > x0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);\n    vec4 x12 = x0.xyxy + C.xxzz;\n    x12.xy -= i1;\n    i = mod289(i); // Avoid truncation effects in permutation\n    vec3 p = permute( permute( i.y + vec3(0.0, i1.y, 1.0 ))\n        + i.x + vec3(0.0, i1.x, 1.0 ));\n\n    vec3 m = max(0.5 - vec3(dot(x0,x0), dot(x12.xy,x12.xy), dot(x12.zw,x12.zw)), 0.0);\n    m = m*m ;\n    m = m*m ;\n    vec3 x = 2.0 * fract(p * C.www) - 1.0;\n    vec3 h = abs(x) - 0.5;\n    vec3 ox = floor(x + 0.5);\n    vec3 a0 = x - ox;\n    m *= 1.79284291400159 - 0.85373472095314 * ( a0*a0 + h*h );\n    vec3 g;\n    g.x  = a0.x  * x0.x  + h.x  * x0.y;\n    g.yz = a0.yz * x12.xz + h.yz * x12.yw;\n    return 130.0 * dot(m, g);\n}\n\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n     //Colors in vec3\n    vec3 red = vec3(0.8 ,0.0 ,0.0);\n    vec3 white = vec3(1.0, 1.0, 1.0);\n    vec3 yellow = vec3(0.9, 0.9, 0.3);\n    vec3 blue = vec3(0.5, 0.8, 0.9);\n    vec3 black = vec3(0.0, 0.0, 0.0);\n    vec3 green = vec3(0.0, 1.0, 0.0);\n\n    \n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    uv *= 5.0;\n    float value = gnoise(uv + (sin(iTime) * 0.005));\n    \n    float bar = step(0.1 + value, uv.x) - step(0.2, uv.x);\n    \n    float a = snoise(uv + iTime);\n    \n    //right\n    a = abs(gnoise(uv + snoise(sin(uv + iTime) + iTime) + iTime)*50.0);\n    \n    a = gnoise(uv + iTime)*snoise(uv + iTime) * 100.;\n    //a = (step(0.2*a, uv.y - 0.8 ) - step(3.9*a, uv.y - 0.8));\n    \n    //left\n    float val = noise(uv + iTime );\n    \n    //combine\n    //val = mix(val, a, step(0.5, uv.x));\n    \n    //waves\n    //val = step(0.48*val, uv.y) - step(0.5*val, uv.y);\n    val = val * sin(rand(uv/100000.)*iTime) * a;\n    val = mix(val , a, step(uv.x, 2.5 + sin(iTime) * 2.5));\n    \n    // Output to screen\n    fragColor = vec4(val);\n    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3slXDX.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 58, 58, 244], [246, 246, 303, 303, 394], [396, 396, 417, 592, 658], [660, 675, 700, 700, 1211], [1213, 1231, 1289, 1289, 1427], [1429, 1429, 1456, 1456, 1854], [1856, 1873, 1894, 1894, 1941], [1942, 1942, 1963, 1963, 2010], [2011, 2011, 2033, 2033, 2068], [2070, 2070, 2092, 2092, 3140], [3145, 3145, 3202, 3224, 4287]], "test": "ok"}
{"id": "3sSSDK", "name": "Shaderwave · 20190410", "author": "JacobJoaquin", "description": "An experiment in compositing two layers.", "tags": ["waves", "checkerboard"], "likes": 1, "viewed": 91, "published": "Public", "date": "1554907562", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#ifdef GL_ES\nprecision mediump float;\n#endif\n\n#define TAU 6.283185307179586\n#define PI 3.141592653589793\n\nfloat maskIt(in float mask, in float v0, in float v1)\n{\n\treturn mask * v0 + (1.0 - mask) * v1;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Phase\n    float phase = iTime * 0.5;\n    \n    // Colors\n\tvec3 c0 = vec3(1.0, 0.5, 0.0);\n\tvec3 c1 = vec3(0.8, 0.1, 0.3);\n\n    // Waves\n\tvec2 st = fragCoord.xy / iResolution.xy;\n\tfloat m = sin(phase * TAU) * 0.5 + 1.0;\n\tm = m * 1.0 + 8.0;\n\tfloat x = fract(cos((2.0 * (st.x) + phase) * TAU) * 3.0 + m * st.y);\n\tfloat y = fract(sin((1.0 * st.y + 0.0 * phase) * TAU) * 1.0);\n\tx = step(0.5, x);\n\n    // Checkerboard\n\tfloat nTiles = 2.5;\n\tfloat x1 = step(0.5, fract(st.x * nTiles));\n\tfloat y1 = step(0.5, fract(st.y * nTiles));\n\tfloat n = mod(x1 + y1, 2.0);\n\n    // Create composite\n\tfloat v = maskIt(n, mod(x + y, 2.0), n);\n\tvec3 composite = vec3(mix(c1, c0, v));\n\n    // Output\n\tvec3 color = vec3(composite);\n\tfragColor = vec4(color, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3sSSDK.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[106, 106, 161, 161, 202], [204, 204, 261, 274, 1005]], "test": "ok"}
{"id": "3sSSDV", "name": "123abc", "author": "alighazi", "description": "nice", "tags": ["raymarchin"], "likes": 2, "viewed": 219, "published": "Public API", "date": "1554915445", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define MAX_DIST 100.\n#define SURF_DIST 0.01\n#define MAX_STEPS 100\n\n\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return length(max(d,0.0))\n         + min(max(d.x,max(d.y,d.z)),0.0); // remove this line for an only partially signed sdf \n}\n\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\nfloat dist(vec3 p){\n    float an = sin(iTime*2.);\n    float an2 = sin(iTime*3.);\n    vec4 sph = vec4(0, 2.+ an, 6, 1);\n    float sphDist = length(p - sph.xyz) - sph.w;\n    float planeDist = p.y;\n    float boxDist = sdTorus(p-vec3(0,1.,6.), vec2(.5+0.5*an2, 0.5));\n    \n    return min(min(sphDist, planeDist), boxDist);\n}\n\nfloat rayMarch(vec3 ro, vec3 rd){\n\tfloat dO = 0.;\n    \n    for(int i=0; i<MAX_STEPS; i++){\n    \tvec3 p = ro + rd*dO;\n        float d = dist(p);\n        dO += d;\n        if(d <= SURF_DIST || dO > MAX_DIST) break;                   \n    }\n    return dO;\n}\n\nvec3 calcNormal( in vec3 p ) // for function f(p)\n{\n    const float eps = 0.0001; // or some other value\n    const vec2 h = vec2(eps,0);\n    return normalize( vec3(dist(p+h.xyy) - dist(p-h.xyy),\n                           dist(p+h.yxy) - dist(p-h.yxy),\n                           dist(p+h.yyx) - dist(p-h.yyx) ) );\n}\n\nfloat getLight( in vec3 p){\n    vec3 lightPos = vec3(1.+5.*cos(iTime), 7, 5.+5.*sin(iTime));    \n    vec3 lightDir = normalize(lightPos - p);\n    vec3 normal = calcNormal(p);\n    float dif = dot(normal, lightDir);\n    \n    float d = rayMarch(p+ normal*SURF_DIST*2., lightDir);\n    if(d<length(lightPos-p)) dif *= .1;\n    \n    return dif*0.9+0.05;\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv= (fragCoord - 0.5*iResolution.xy) / iResolution.y;\n    vec3 col = vec3(0.);\n    \n    vec3 ro = vec3(0., 2., 0.);\n    vec3 rd = normalize(vec3(uv.x, uv.y, 1.));\n    \n    vec3 d = vec3(rayMarch(ro, rd)); \n    vec3 p = ro + rd* d;\n    \n    float light = getLight(p);    \n    col = vec3(light);\n    fragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3sSSDV.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[70, 70, 101, 101, 251], [253, 253, 286, 286, 351], [353, 353, 372, 372, 673], [675, 675, 708, 708, 928], [930, 930, 981, 981, 1246], [1248, 1248, 1275, 1275, 1596], [1600, 1600, 1657, 1657, 1991]], "test": "ok"}
{"id": "3sSSW3", "name": "Sparking techno", "author": "jblanper", "description": "Music visualization.", "tags": ["visualization", "music", "light"], "likes": 2, "viewed": 226, "published": "Public", "date": "1555070865", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    uv -= .5;\n    uv.x *= iResolution.x / iResolution.y;\n\n    float d = length(uv);\n    \n    float fft1 = texture(iChannel0, vec2(.1, 0.)).x * .8;\n    float fft2 = texture(iChannel0, vec2(.4, 0.)).x;\n    \n    vec3 col = vec3(smoothstep(.01, .9, d)) + vec3(.1, .3, .8);\n    col += d * 1.2;\n    \n    col += smoothstep(.5 + cos(iTime + fract(fft2)) * .02 + .04,\n                      .25,\n                      d - (fft1 * abs(uv.x))) * 1.2 - vec3(.1, d, fft1) - \n        smoothstep(.3  * sin(iTime * .5) * .002 + .003, \n                   .25,\n                   d - (fft1 * abs(uv.x * 1.5))) * .8 - vec3(fft2, d, .1);\n        \n    col.rb += fft1 * .2 /  d;\n    col.gr += fft2 * cos(iTime * .2) * uv;\n    col -= abs(uv.y) * 1.5;\n    col -= abs(uv.x) * 1.5;\n\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": "4sXGRr", "previewfilepath": "/media/ap/48e2d9ef22ca6673330b8c38a260c87694d2bbc94c19fec9dfa4a1222c364a99.mp3", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/48e2d9ef22ca6673330b8c38a260c87694d2bbc94c19fec9dfa4a1222c364a99.mp3", "ctype": "music"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3sSSW3.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 886]], "test": "error"}
{"id": "3sSSzt", "name": "Arc dance", "author": "avin", "description": "Simple arc dance function", "tags": ["simple", "arc"], "likes": 2, "viewed": 398, "published": "Public API", "date": "1554641421", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;  \n    \n    float factor = 50.0;\n    \n    // Rotate\n    float a = iTime * 2.0;\n    float as = sin(a);\n    float ac = cos(a);\n    uv *= uv * mat2(ac, - as, as, ac);\n    \n    float v = fract(sin(uv.x * uv.y * factor) * 10.0);       \n    \n    float mask = smoothstep( .3, 0., abs(v-.5) );\n    \n    vec3 col = vec3(uv.y * 1000.0, 0.7, uv.x * 1000.0) * mask;\n    \n    fragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3sSSzt.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 515]], "test": "ok"}
{"id": "3sSXDc", "name": "simple spiral galaxy", "author": "Bitmesh", "description": "for game", "tags": ["space", "milkyway"], "likes": 3, "viewed": 465, "published": "Public API", "date": "1555328158", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define ARM_COUNT 5.\n#define WHIRL 14.0\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy - 0.5;\n    uv.x *= iResolution.x/iResolution.y;\n    uv = vec2((atan(uv.y,uv.x)) - iTime*.1, sqrt(uv.x*uv.x + uv.y*uv.y));\n    float g = pow(1.-uv.y, 10.)*10.;\n    vec3 col = vec3(sin((uv.x + pow(uv.y, 0.2)*WHIRL) * ARM_COUNT)) + g - uv.y*2.2;\n    fragColor = vec4(col/5.,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3sSXDc.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[41, 41, 98, 98, 416]], "test": "ok"}
{"id": "3sSXDt", "name": "Rainbow cicle", "author": "avin", "description": "short demo", "tags": ["hue"], "likes": 11, "viewed": 504, "published": "Public API", "date": "1555240384", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// #define hue(h) clamp( abs( fract(h + vec4(3,2,1,0)/3.) * 6. - 3.) -1. , 0., 1.)\n#define hue(v)  ( .6 + .6 * cos( 6.3*(v)  + vec4(0,23,21,0)  ) )\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv =  floor(fragCoord/iResolution.x * 12.)/12.;    \n    fragColor = hue(uv.x + uv.y/3. + iTime*0.5);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3sSXDt.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[149, 149, 206, 206, 318]], "test": "ok"}
{"id": "3sSXWt", "name": "Katamari Damacy", "author": "yasuo", "description": "Hope someone like this shit!", "tags": ["raymerching"], "likes": 5, "viewed": 354, "published": "Public API", "date": "1555226331", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// All the distance functions from:http://iquilezles.org/www/articles/distfunctions/distfunctions.htm\n#define matRotateX(rad) mat3(1,0,0,0,cos(rad),-sin(rad),0,sin(rad),cos(rad))\n#define matRotateY(rad) mat3(cos(rad),0,-sin(rad),0,1,0,sin(rad),0,cos(rad))\n#define matRotateZ(rad) mat3(cos(rad),-sin(rad),0,sin(rad),cos(rad),0,0,0,1)\n\nfloat dot2( in vec2 v ) { return dot(v,v); }\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\nfloat sdRoundedCylinder( vec3 p, float ra, float rb, float h )\n{\n    vec2 d = vec2( length(p.xz)-2.0*ra+rb, abs(p.y) - h );\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0)) - rb;\n}\n\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r )\n{\n    vec3 pa = p - a, ba = b - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h ) - r;\n}\n\nfloat sdCappedCone( in vec3 p, in float h, in float r1, in float r2 )\n{\n    vec2 q = vec2( length(p.xz), p.y );\n    \n    vec2 k1 = vec2(r2,h);\n    vec2 k2 = vec2(r2-r1,2.0*h);\n    vec2 ca = vec2(q.x-min(q.x,(q.y < 0.0)?r1:r2), abs(q.y)-h);\n    vec2 cb = q - k1 + k2*clamp( dot(k1-q,k2)/dot2(k2), 0.0, 1.0 );\n    float s = (cb.x < 0.0 && ca.y < 0.0) ? -1.0 : 1.0;\n    return s*sqrt( min(dot2(ca),dot2(cb)) );\n}\n\nfloat opSmoothUnion( float d1, float d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); \n}\n\nfloat dBox2d(vec2 p, vec2 b) {\n\treturn max(abs(p.x) - b.x, abs(p.y) - b.y);\n}\n\nfloat sdTriangle( in vec2 p0, in vec2 p1, in vec2 p2, in vec2 p )\n{\n\tvec2 e0 = p1 - p0;\n\tvec2 e1 = p2 - p1;\n\tvec2 e2 = p0 - p2;\n\n\tvec2 v0 = p - p0;\n\tvec2 v1 = p - p1;\n\tvec2 v2 = p - p2;\n\n\tvec2 pq0 = v0 - e0*clamp( dot(v0,e0)/dot(e0,e0), 0.0, 1.0 );\n\tvec2 pq1 = v1 - e1*clamp( dot(v1,e1)/dot(e1,e1), 0.0, 1.0 );\n\tvec2 pq2 = v2 - e2*clamp( dot(v2,e2)/dot(e2,e2), 0.0, 1.0 );\n    \n    float s = sign( e0.x*e2.y - e0.y*e2.x );\n    vec2 d = min( min( vec2( dot( pq0, pq0 ), s*(v0.x*e0.y-v0.y*e0.x) ),\n                       vec2( dot( pq1, pq1 ), s*(v1.x*e1.y-v1.y*e1.x) )),\n                       vec2( dot( pq2, pq2 ), s*(v2.x*e2.y-v2.y*e2.x) ));\n\n\treturn -sqrt(d.x)*sign(d.y);\n}\n\nvec4 combine(vec4 val1, vec4 val2 ){\n    if ( val1.w < val2.w ) {\n        return val1;\n    }\n    return val2;\n}\n\nvec3 faceTex(vec2 uv) {\n    float eyeL = length(uv+vec2(0.07,-0.35))-0.005;\n    float eyeL2 = length(uv+vec2(0.08,-0.36))-0.005;\n    float eyeR = length(uv+vec2(-0.07,-0.35))-0.005;\n    float eyeR2 = length(uv+vec2(-0.08,-0.36))-0.005;\n    vec3 col = vec3(0.0,0.7,0.0);\n    float f = dBox2d(uv+vec2(0.0,-0.3),vec2(0.15,0.15));\n    float mouth = dBox2d(uv+vec2(0.0,-0.2),vec2(0.03,0.03+sin(iTime*10.0)*0.01));\n    \n    float nose = sdTriangle(vec2(0.0,0.02),vec2(0.02,-0.02),vec2(-0.02,-0.02),uv+vec2(0.0,-0.3));\n    \n    col = mix( col, vec3(0.9,0.8,0.1), 1.0-smoothstep(0.01,0.02,f) );\n    col = mix( col, vec3(0.6,0.0,0.0), 1.0-smoothstep(0.01,0.02,eyeL) );\n    col = mix( col, vec3(0.6,0.0,0.0), 1.0-smoothstep(0.01,0.02,eyeR) );\n    col = mix( col, vec3(0.6,0.0,0.0), 1.0-smoothstep(0.01,0.02,eyeL2) );\n    col = mix( col, vec3(0.6,0.0,0.0), 1.0-smoothstep(0.01,0.02,eyeR2) );\n    col = mix( col, vec3(0.7,0.0,0.0), 1.0-smoothstep(0.01,0.02,mouth) );\n    col = mix( col, vec3(0.8,0.6,0.0), 1.0-smoothstep(0.01,0.02,nose) );\n    \n    col = (uv.x<-0.35)? vec3(0.95):col;\n    col = (uv.x>0.35)? vec3(0.95):col;\n    \n    col = (uv.x< -0.25 && uv.x>-0.3)? vec3(0.0,0.9,0.0):col;\n    col = (uv.x> 0.25 && uv.x<0.3)? vec3(0.0,0.9,0.0):col;\n    \n    return col;\n}\n\nvec3 ranbowTex(vec2 uv) {\n    vec3 col = vec3(1.0);\n    uv.y = cos(uv.x)*0.5+sin(uv.y)*0.5;\n    col = (uv.y<-0.35)? vec3(1.0,0.0,0.0):col;\n    col = (uv.y>=-0.35 && uv.y< -0.15)? vec3(1.0,0.6,0.0):col;\n    col = (uv.y>=-0.15 && uv.y< 0.05)? vec3(1.0,1.0,0.0):col;\n    col = (uv.y>=0.05 && uv.y< 0.25)? vec3(0.0,1.0,0.0):col;\n    col = (uv.y>=0.25 && uv.y< 0.55)? vec3(0.3,0.3,0.8):col;\n    col = (uv.y>=0.55 && uv.y< 0.85)? vec3(0.7,0.7,1.0):col;\n    col = (uv.y>=0.85)? vec3(0.8,0.0,1.0):col;\n\n    return col;   \n}\n\nvec3 floorTex(vec2 uv) {\n    vec3 col = vec3(0.6,0.9,0.6);\n    col = (uv.x>=-1.2 && uv.x< 1.2)? vec3(0.8):col;\n    return col;\n}\n\nvec3 bodyTex(vec2 uv) {\n    vec3 col = vec3(0.0,0.7,0.0);\n    col = (uv.y<-0.38)? vec3(0.0,0.3,0.0):col;\n    return col;\n}\n\nvec4 Chara(vec3 p) {\n    vec4 head0 = vec4(1.0,0.0,0.0,length(p+vec3(0.0,-0.72,0.0))-0.05);\n    vec4 head1 = vec4(1.0,1.0,0.0,sdCappedCone((p+vec3(0.0,-0.5,0.0)),0.2,0.1,0.005));\n    vec4 head2 = vec4(faceTex(p.xy),sdRoundedCylinder((p+vec3(0.0,-0.3,0.0))*matRotateZ(radians(90.0)),0.11,0.32,0.22));\n    vec4 body = vec4(bodyTex(p.xy),sdCappedCone((p+vec3(0.0,0.17,0.0)),0.25,0.3,0.22));\n    vec4 armL = vec4(0.0,0.7,0.0,sdCapsule((p+vec3(0.33,0.2,0.0)),vec3(-0.2,-0.2,sin(iTime*10.0)*0.1),vec3(0.1,0.25,0.0),0.02));\n    vec4 armR = vec4(0.0,0.7,0.0,sdCapsule((p+vec3(-0.33,0.2,0.0)),vec3(0.2,-0.2,sin(iTime*10.0)*-0.1),vec3(-0.1,0.25,0.0),0.02));\n    vec4 legL0 = vec4(0.5,0.1,0.3,sdCapsule((p+vec3(0.15,0.7,0.0)),vec3(0.0,0.0,sin(iTime*10.0)*-0.05),vec3(0.0,0.25,0.0),0.04));\n    vec4 legL1 = vec4(0.5,0.1,0.3,sdCapsule((p+vec3(0.15,0.95,0.0)),vec3(0.0,0.0,sin(iTime*10.0)*-0.15),vec3(0.0,0.25,sin(iTime*10.0)*-0.05),0.04));\n    vec4 legL = combine(legL0,legL1);\n    vec4 legR0 = vec4(0.5,0.1,0.3,sdCapsule((p+vec3(-0.15,0.7,0.0)),vec3(0.0,0.0,sin(iTime*10.0)*0.05),vec3(0.0,0.25,0.0),0.04));\n    vec4 legR1 = vec4(0.5,0.1,0.3,sdCapsule((p+vec3(-0.15,0.95,0.0)),vec3(0.0,0.0,sin(iTime*10.0)*0.15),vec3(0.0,0.25,sin(iTime*10.0)*0.05),0.04));\n    vec4 legR = combine(legR0,legR1);\n    return combine(combine(combine(combine(combine(combine(head0,combine(head1,head2)),body),armL),armR),legL),legR);\n}\n\nvec4 map(vec3 p){    \n    vec3 pref = p;\n    vec2 uv = p.xy;\n    vec4 f = vec4(floorTex(uv),p.y+1.0);\n    vec4 c = Chara(p);\n    p.z += iTime*3.0;\n    p.z = mod(p.z,6.0)-3.0;\n    p.x = abs(p.x);\n    vec4 sphere = vec4(ranbowTex(uv),length((p+vec3(-5.0,-0.1,2.0)))-1.3);\n    \n    return combine(combine(f,c),sphere);\n}\n\nvec3 normalMap(vec3 p){\n\tfloat d = 0.0001;\n\treturn normalize(vec3(\n\t\tmap(p + vec3(  d, 0.0, 0.0)).w - map(p + vec3( -d, 0.0, 0.0)).w,\n\t\tmap(p + vec3(0.0,   d, 0.0)).w - map(p + vec3(0.0,  -d, 0.0)).w,\n\t\tmap(p + vec3(0.0, 0.0,   d)).w - map(p + vec3(0.0, 0.0,  -d)).w\n\t));\n}\n\nfloat shadowMap(vec3 ro, vec3 rd){\n\tfloat h = 0.0;\n\tfloat c = 0.001;\n\tfloat r = 1.0;\n\tfloat shadow = 0.5;\n\tfor(float t = 0.0; t < 30.0; t++){\n\t\th = map(ro + rd * c).w;\n\t\tif(h < 0.001){\n\t\t\treturn shadow;\n\t\t}\n\t\tr = min(r, h * 16.0 / c);\n\t\tc += h;\n\t}\n\treturn 1.0 - shadow + r * shadow;\n}\n\n// from simon green and others\nfloat ambientOcclusion(vec3 p, vec3 n)\n{\n    const int steps = 4;\n    const float delta = 0.15;\n\n    float a = 0.0;\n    float weight = 4.;\n    for(int i=1; i<=steps; i++) {\n        float d = (float(i) / float(steps)) * delta; \n        a += weight*(d - map(p + n*d).w);\n        weight *= 0.5;\n    }\n    return clamp(1.0 - a, 0.0, 1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n\tvec2 p = (fragCoord.xy * 2.0 - iResolution.xy) / min(iResolution.x, iResolution.y);\n\t\n\tvec3 camPos = vec3(0.0, 0.0, 1.3);\n\tvec3 Fwd = vec3(0.0, 0.0, -1.0);\n\tvec3 Up  = vec3(0.0,  1., 0.0);\n\t\n\tvec3 left = cross(Fwd, Up);\n\tfloat depth = 0.7;\n\tvec3 ray = normalize(left * p.x + Up * p.y + Fwd * depth);\n\n\tmat3 camRot = matRotateY(radians(sin(iTime*2.0)*10.0));\n\n\tfloat t, dist;\n\tt = 0.0;\n\tvec3 distPos = camPos;\n\tvec4 distCl = vec4(0.0);\n\tfor(int i = 0; i < 64; i++){\n\t\tdistCl = map(distPos);\n\t\tdist = distCl.w;\n\t\tt += dist;\n\t\tdistPos = (camPos + t * ray)*camRot;\n        if(dist < 0.01 || dist > 30.0) break;\n\t}\n\n\tvec3 color;\n\tfloat shadow = 1.0;\n\tif(dist < 0.1){\n\t\t// lighting\n\t\tvec3 lightDir = vec3(0.0, 1.0, 0.0);\n\t\tvec3 light = normalize(lightDir + vec3(0.5, 0.0, 0.9));\n\t\tvec3 normal = normalMap(distPos);\n\n\t\t// difuse color\n\t\tfloat diffuse = clamp(dot(light, normal), 0.1, 1.0);\n\t\tfloat lambert = max(.0, dot( normal, light));\n\t\t\n        // ambient occlusion\n        float ao = ambientOcclusion(distPos,normal);\n        \n\t\t// shadow\n\t\tshadow = shadowMap(distPos + normal * 0.001, light);\n\n\t\t// result\n\t\tcolor += vec3(lambert);\n\t\tcolor = ao*diffuse*(distCl.xyz+(.1-length(p.xy)/3.))*vec3(1.0, 1.0, 1.0);\n        \n\t}else{\n\t\tcolor =.84*max(mix(vec3(0.0,0.81,0.85)+(.1-length(p.xy)/3.),vec3(1),.1),0.);\n\t}\n\n\t// rendering result\n\tfloat brightness = 1.5;\n\tvec3 dst = (color * max(0.5, shadow))*brightness;\n\tfragColor = vec4(dst, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3sSXWt.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[334, 334, 359, 359, 378], [380, 380, 411, 411, 498], [500, 500, 564, 564, 685], [687, 687, 739, 739, 866], [868, 868, 939, 939, 1277], [1279, 1279, 1331, 1331, 1431], [1433, 1433, 1463, 1463, 1510], [1512, 1512, 1579, 1579, 2188], [2190, 2190, 2226, 2226, 2301], [2303, 2303, 2326, 2326, 3562], [3564, 3564, 3589, 3589, 4079], [4081, 4081, 4105, 4105, 4209], [4211, 4211, 4234, 4234, 4333], [4335, 4335, 4355, 4355, 5735], [5737, 5737, 5754, 5754, 6054], [6056, 6056, 6079, 6079, 6329], [6331, 6331, 6365, 6365, 6615], [6986, 6986, 7042, 7042, 8478]], "test": "timeout"}
{"id": "3sSXzy", "name": "Breaking up stripes", "author": "MacSlow", "description": "Trying to use the cell-index for some variation in motion. Also wanted to do something at least slightly artistic. Set REFLECTIONS to false, if your GPU gets stressed.", "tags": ["3d", "raymarching", "phong", "metaballs", "shadows", "blinn", "soundcloud"], "likes": 20, "viewed": 697, "published": "Public API", "date": "1554150134", "time_retrieved": "2021-10-01T00:00:00", "image_code": "////////////////////////////////////////////////////////////////////////////////\n//\n// Breaking up stripes - Making use of the cell-index of domain repetition to\n// vary object motion\n//\n// Copyright 2019 Mirco Müller\n//\n// Author(s):\n//   Mirco \"MacSlow\" Müller <macslow@gmail.com>\n//\n// This program is free software: you can redistribute it and/or modify it\n// under the terms of the GNU General Public License version 3, as published\n// by the Free Software Foundation.\n//\n// This program is distributed in the hope that it will be useful, but\n// WITHOUT ANY WARRANTY; without even the implied warranties of\n// MERCHANTABILITY, SATISFACTORY QUALITY, or FITNESS FOR A PARTICULAR\n// PURPOSE.  See the GNU General Public License for more details.\n//\n// You should have received a copy of the GNU General Public License along\n// with this program.  If not, see <http://www.gnu.org/licenses/>.\n//\n////////////////////////////////////////////////////////////////////////////////\n\nconst bool REFLECTIONS = true;\n\nmat2 r2d (float deg) {\n\tfloat rad = radians (deg);\n\tfloat c = cos (rad);\n\tfloat s = sin (rad);\n\treturn mat2 (c, s, -s, c);\n}\n\nfloat smin (float d1, float d2, float k)\n{\n\tfloat h = clamp (.5 + .5*(d2 - d1)/k, .0, 1.);\n\treturn mix (d2, d1, h) - k*h*(1. - h);\n}\n\nfloat sdSphere (vec3 p, float r) {\n\treturn length (p) - r;\n}\n\nfloat ballMerge (float d, vec3 p, float r, float k) {\n\tfloat ball = sdSphere (p, r);\n\treturn smin (d, ball, k);\n}\n\nfloat opRepeat (inout float p, float size) {\n\tfloat c = floor ((p + .5*size)/size);\n\tp = mod (p + .5*size, size) - .5*size;\n\treturn c;\n}\n\nfloat map (vec3 p) {\n\tfloat ground = p.y + 1.5;\n\tfloat wall = p.z + 1.5;\n\tfloat size = 4.;\n\tfloat cell = opRepeat (p.x, 4.);\n\tp.xz *= r2d (45.*iTime + 80.*cell);\n\tp.xy *= r2d (57.*iTime + 50.*cell);\n\tfloat t = iTime;\n\tfloat r1 = .5 + .1*(.5+.5*cos (2.*t));\n\tfloat r2 = .3 + .1*(.5+.5*cos (3.*t));\n\tfloat r3 = .4 + .1*(.5+.5*cos (4.*t));\n\tfloat r4 = .2 + .1*(.5+.5*cos (2.*t));\n\tfloat r5 = .6 + .1*(.5+.5*cos (3.*t));\n\tfloat r6 = .3 + .1*(.5+.5*cos (4.*t));\n\tfloat k1 = .35 + .1*(.5+.5*cos (2.*t));\n\tfloat k2 = .5 + .1*(.5+.5*cos (3.*t));\n\tfloat k3 = .4 + .1*(.5+.5*cos (4.*t));\n\tfloat k4 = .6 + .1*(.5+.5*cos (2.*t));\n\tfloat k5 = .3 + .1*(.5+.5*cos (3.*t));\n\tvec3 c1 = vec3 (cos(2.*t), .1, sin(2.*t));\n\tvec3 c2 = vec3 (cos(3.*t), .2, sin(3.*t));\n\tvec3 c3 = vec3 (cos(4.*t), sin(2.*t), .3);\n\tvec3 c4 = vec3 (cos(2.*t), sin(4.*t), .5);\n\tvec3 c5 = vec3 (.2, cos (3.*t), sin(3.*t));\n\tvec3 c6 = vec3 (.5, cos (4.*t), sin(2.*t));\n\tfloat ball1 = sdSphere (p + c1, r1);\n\tball1 = ballMerge (ball1, p + c2, r2, k1);\n\tball1 = ballMerge (ball1, p + c3, r3, k2);\n\tball1 = ballMerge (ball1, p + c4, r4, k3);\n\tball1 = ballMerge (ball1, p + c5, r5, k4);\n\tball1 = ballMerge (ball1, p + c6, r6, k5);\n\tfloat d = smin (ball1, smin (ground, wall, .7), .9);\n\treturn d;\n}\n\nfloat march (vec3 ro, vec3 rd, inout int iter) {\n\tfloat t = .0;\n\tfloat d = .0;\n\tfor (int i = 0; i < 48; ++i) {\n\t\tvec3 p = ro + d*rd;\n\t\tt = map (p);\n\t\tif (abs (t) < .001*(1. + .125*t)) break;\n\t\td += t*.95;\n\t\titer = i;\n\t}\n\treturn d;\n}\n\nvec3 norm (vec3 p) {\n\tfloat d = map (p);\n\tvec2 e = vec2 (.001, .0);\n\treturn normalize (vec3 (map (p+e.xyy),\n                            map (p+e.yxy),\n                            map (p+e.yyx)) - d);\n}\n\nfloat sha (vec3 p, vec3 lp, vec3 n, float ldist, vec3 ldir)\n{\n\tint foo;\n\tfloat d2w = march (p+.01*n, ldir, foo);\n\treturn ldist < d2w ? 1. : .1;\n}\n\nvec3 shade (vec3 ro, vec3 rd, float d, vec3 n, vec3 lp, vec3 lc, float li) {\n\tvec3 p = ro + d*rd;\n\tvec3 amb = vec3 (.05);\n\tvec3 ldir = normalize (lp - p);\n\tfloat ldist = distance (p, lp);\n\tfloat att = 7. / (ldist*ldist);\n\tfloat diff = max (.0, dot (n, ldir));\n\tvec3 mat = vec3 (.1, .2, 0);\n\tfloat m = smoothstep (.2, .3, .5+.5*cos(4.*(10.+p.z*p.y*p.y)));\n\tmat = mix (vec3 (1.), vec3 (.0), m);\n\tfloat s = sha (p, lp, n, ldist, ldir);\n\tvec3 h = normalize (-rd + ldir);\n\tfloat sp = pow (max (.0, dot (n, h)), 80.);\n\treturn s*att*(amb + diff*lc*li*mat + sp*vec3 (1.));\n}\n\nvec3 cam (vec2 uv, vec3 ro, vec3 aim, float zoom) {\n\tvec3 f = normalize (aim - ro);\n\tvec3 wu = vec3 (.0, 1., .0);\n\tvec3 r = normalize (cross (wu, f));\n\tvec3 u = normalize (cross (f, r));\n\tvec3 c = ro + f*zoom;\n\treturn normalize (c + r*uv.x + u*uv.y - ro);\n}\n\nconst\tvec3 lps[3] = vec3[3](vec3 (.0, .0, 2.),\n                          vec3 (.0, 3., .0),\n                          vec3 (-3., 1., .5));\nconst\tvec3 lcs[3] = vec3[3](vec3 (.9, .8, .7),\n                          vec3 (.8, .7, .9),\n                          vec3 (.8, .9, .7));\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uvRaw = fragCoord/iResolution.xy;\n\tvec2 uv = uvRaw*2. - 1.;\n\tuv.x *= iResolution.x/iResolution.y;\n\tuv *= 1. + .75*length (uv);\n\n    vec3 ro = vec3 (2., 2., 1.);\n\tvec3 aim = vec3 (.0);\n\tro.x -= 7.*iTime;\n\taim.x -= 7.*iTime;\n\tvec3 rd = cam (uv, ro, aim, 1.75);\n\tint iter = 0;\n\tfloat d = march (ro, rd, iter);\n\tfloat fog = 1. / (1. + d*d*.1);\n\tfloat glow = float (iter) / 48.;\n\tvec3 p = ro + d*rd;\n\tvec3 n = norm (p);\n\tvec3 col = shade (ro, rd, d, n, p+lps[0], lcs[0], 2. );\n\tcol += shade (ro, rd, d, n, p+lps[1], lcs[1], 3.);\n\tcol += shade (ro, rd, d, n, p+lps[2], lcs[2], 4.);\n\tcol += pow (glow, 1.125)*vec3 (1., .3, .1);\n\n    if (REFLECTIONS) {\n        ro = p+.01*n;\n\t\trd = normalize (reflect (rd, n));\n\t\td = march (ro,rd,  iter);\n\t\tvec3 rcol = shade (ro, rd, d, n, p+lps[0], lcs[0], 2.);\n\t\trcol += shade (ro, rd, d, n, p+lps[1], lcs[1], 3.);\n\t\trcol += shade (ro, rd, d, n, p+lps[2], lcs[2], 4.);\n\t\tcol += .15*rcol;\n    }\n\n\tcol *= fog;\n\tcol = col / (1.25 + col*.5);\t\n\tcol *= 1. - .65*length (uvRaw*2. - 1.);\n\tcol *= mix (1., .75, cos (300.*(uvRaw.y+1.)*(uvRaw.x+uvRaw.y)));\n\tcol = pow (col, vec3 (1./2.2));\n\n\tfragColor = vec4(col, 1.);\n}", "image_inputs": [{"id": "MtfGDM", "previewfilepath": "https://soundcloud.com/user4686404/08-danny-byrd-sweet-harmony", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0, "src": "https://soundcloud.com/user4686404/08-danny-byrd-sweet-harmony", "ctype": "musicstream"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3sSXzy.jpg", "access": "shaders20k", "license": "gpl-3.0", "functions": [[1012, 1012, 1034, 1034, 1136], [1138, 1138, 1180, 1180, 1270], [1272, 1272, 1306, 1306, 1332], [1334, 1334, 1387, 1387, 1447], [1449, 1449, 1493, 1493, 1585], [1587, 1587, 1607, 1607, 2835], [2837, 2837, 2885, 2885, 3069], [3071, 3071, 3091, 3091, 3272], [3274, 3274, 3335, 3335, 3419], [3421, 3421, 3497, 3497, 3987], [3989, 3989, 4040, 4040, 4246], [4527, 4527, 4584, 4584, 5728]], "test": "error"}
{"id": "3tf3R8", "name": "Fake Rubik's Cube", "author": "zackpudil", "description": "I'm sure this has been done much better before.  Not actually solving a cube, just rotating it a bunch.", "tags": ["raymarching", "rubix"], "likes": 15, "viewed": 577, "published": "Public API", "date": "1555558748", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI 3.14159\nmat2 rot(float a) {\n    float s = sin(a), c = cos(a);\n    \n    return mat2(c, s, -s, c);\n}\n\nfloat box(vec3 p, vec3 b) {\n    vec3 q = abs(p) - b;\n    return max(max(q.x, q.y), q.z);\n}\n\nfloat box(vec2 p, vec2 b) {\n    vec2 q = abs(p) - b;\n    return max(q.x, q.y);\n}\n\nvec2 opU(vec2 a, vec2 b) {\n    return a.x < b.x ? a : b;\n}\n\nfloat ac[16]; // store rotations.\n\nvec2 de(vec3 p) {\n    vec3 op = p;\n    float at = mod(iTime*3.0, PI*9.0);\n    \n    float j = 0.0;\n    for(int i = 0; i < 16; i++) {\n        float s = i < 8 ? 1.0 : -1.0;\n        ac[i] = s*PI*smoothstep(j*PI, (j+0.5)*PI, at);\n        j += 0.5;\n    }\n    \n    // I hate this, but I can't find a better way to do it.\n    // do the rotations in reverse so the steps() don't interfer with eachother.\n    p.xz *= rot(ac[15]*step(0.6, p.y)); // last rotation to happen chronologically\n    p.xy *= rot(ac[14]*step(0.6, p.z));\n    p.yz *= rot(ac[13]*step(0.6, p.x));\n    p.xz *= rot(ac[12]*step(0.6, -p.y));\n    p.xy *= rot(ac[11]*step(0.6, -p.z));\n    p.yz *= rot(ac[10]*step(0.6, -p.x));\n    p.xz *= rot(ac[9]*step(0.6, p.y));\n    p.xy *= rot(ac[8]*step(0.6, p.z));\n    \n    p.xy *= rot(ac[7]*step(0.6, p.z));\n    p.xz *= rot(ac[6]*step(0.6, p.y));\n    p.yz *= rot(ac[5]*step(0.6, -p.x));\n    p.xy *= rot(ac[4]*step(0.6, -p.z));\n    p.xz *= rot(ac[3]*step(0.6, -p.y));\n    p.yz *= rot(ac[2]*step(0.6, p.x));\n    p.xy *= rot(ac[1]*step(0.6, p.z));\n    p.xz *= rot(ac[0]*step(0.6, p.y)); // first rotation to happen chronologically\n    \n    // hacky way to get the different colors.\n    float m = 0.0;\n    if(p.x > 1.73) m = 1.0;\n    else if(p.y > 1.73) m = 2.0;\n    else if(p.z > 1.73) m = 3.0;\n    else if(p.x < -1.73) m = 4.0;\n    else if(p.z < -1.73) m = 5.0;\n    else if(p.y < -1.73) m = 6.0;\n    \n    // these two lines turn one cube into 27.\n    p = abs(p) - vec3(0.6);\n    p = abs(p) - vec3(0.6);\n\n    float b = box(p, vec3(0.55)); // the actual rubik cube.\n        \n    // this distance is for the black border around the cube.\n\tfloat c = box(p, vec3(0.56));\n\tc = max(c, -box(p.xz, vec2(0.47)));\n    c = max(c, -box(p.xy, vec2(0.47)));\n    c = max(c, -box(p.yz, vec2(0.47)));\n        \n    vec2 t = vec2(b, m);\n    vec2 s = vec2(length(op) - 1.7, 7.0);\n    vec2 u = vec2(c, 7.0);\n    \n    return opU(t, opU(s, u));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = (fragCoord - 0.5*iResolution.xy)/iResolution.y;\n    \n    vec3 col = vec3(0);\n    vec3 bcol = col = vec3(0.3, 0.4, 1.0);\n    \n    float a = 6.7;\n    float at = iTime*0.6;\n    \n    vec3 ro = vec3(a*cos(at), 3, -a*sin(at));\n    vec3 ww = normalize(vec3(0, 0, 0)-ro);\n    vec3 uu = cross(vec3(0, 1, 0), ww);\n    vec3 vv = cross(ww, uu);\n    vec3 rd = normalize(mat3(uu, vv, ww)*vec3(uv, 1.0));\n    \n    float t = 0.0, m = -1.0, mx = 50.0;\n    for(int i = 0; i < 300; i++) {\n        vec2 d = de(ro + rd*t);\n        if(abs(d.x) < 0.0001 || t >= mx) break;\n        t += d.x*0.5;\n        m = d.y;\n    }\n    \n    vec3 ld = normalize(vec3(0.6, 0.5, -0.5));\n    \n    if(t < mx) {\n        vec3 p = ro + rd*t;\n        vec2 h = vec2(0.001, 0.0);\n        vec3 n = normalize(vec3(\n        \tde(p + h.xyy).x - de(p - h.xyy).x,\n            de(p + h.yxy).x - de(p - h.yxy).x,\n            de(p + h.yyx).x - de(p - h.yyx).x\n        ));\n                \n        vec3 ld = normalize(p);\n        \n        float glo = 16.0;\n        vec3 alb = vec3(0.9);\n        \n        if(m == 1.0) alb = vec3(1.0, 0.3, 0.3);\n        else if(m == 2.0) alb = vec3(0.3, 1.0, 0.3);\n        else if(m == 3.0) alb = vec3(0.3, 0.3, 1.0);\n        else if(m == 4.0) alb = vec3(3.0);\n        else if(m == 5.0) alb = vec3(1.0, 1.0, 0.3);\n        else if(m == 6.0) alb = vec3(1.0, 0.3, 1.0);\n        else if(m == 7.0) alb = vec3(0);\n        \n        float occ = exp2(-pow(max(0.0, 1.0 - de(p + n*0.05).x/0.05), 2.0));\n        float dif = max(0.0, dot(ld, n));\n        float spe = pow(max(0.0, dot(reflect(-ld, n), -rd)), glo);\n        float fre = pow(1.0 + dot(rd, n), 4.0);\n        \n        col = 0.5*mix(occ*(alb*(0.25 + dif) + spe), bcol, fre);\n    }\n    \n    fragColor = vec4(pow(col, vec3(0.4545)), 1);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3tf3R8.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[19, 19, 38, 38, 109], [111, 111, 138, 138, 201], [203, 203, 230, 230, 283], [285, 285, 311, 311, 343], [380, 380, 397, 397, 2295], [2297, 2297, 2354, 2354, 4126]], "test": "timeout"}
{"id": "3tf3zM", "name": "purple-magenta-yellow", "author": "uynet", "description": "trap.jp/post/697/", "tags": ["gradation"], "likes": 1, "viewed": 86, "published": "Public", "date": "1555839517", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI 3.14159265\n\nfloat atan2(vec2 p){\n    return p.x == 0.0 ? sign(p.y)*PI/2. : atan(p.y, p.x);\n}\nvec2 polar(vec2 p){\n  float r = length(p);\n  float t = atan2(p);\n  t+=PI;\n  return vec2(r,t);\n}\nvec3 grad(vec2 uv){\n  vec3 f = vec3(uv.x*2.0,1.0-uv.y*4.0,1.0-uv.x*0.9)*0.9;\n  return f;\n}\n\nvec2 rot2(vec2 p,float a){\n  vec2 q = p;\n  q.x = p.x*cos(a)-p.y*sin(a);\n  q.y = p.x*sin(a)+p.y*cos(a);\n  return q;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-iResolution.xy*0.5)/iResolution.y;\n    vec3 col = grad((uv+0.5));\n    vec2 puv = polar(uv);\n    \n     col.y = 0.03 * pow(\n        (cos(puv.y-PI)+1.0),4.0\n     );\n   \n    float r = 0.3 + 0.1 * sin(iTime);\n    if(length(uv)>r + 0.05)col = vec3(1);\n    if(length(uv)<r - 0.05)col = vec3(1);\n    \n    col = mix(col,vec3(1),0.2);\n\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3tf3zM.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[23, 23, 43, 43, 103], [104, 104, 123, 123, 199], [200, 200, 219, 219, 290], [292, 292, 318, 318, 408], [410, 410, 467, 467, 851]], "test": "ok"}
{"id": "3tf3zS", "name": "Crazy Springs", "author": "eiffie", "description": "Still re-uploading. Adjusted the craziness a bit.", "tags": ["crazy"], "likes": 29, "viewed": 569, "published": "Public API", "date": "1556624627", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Crazy Springs by eiffie (re-uploaded)\n\n#define time iTime\n#define size iResolution\n\nfloat f1,f2,f3;\nvec3 crazy(vec3 g){return sin(g.yzx*f1+g.zxy*f2+g*f3)*0.25;}\nvec3 mcol=vec3(0.0);\nfloat DE(vec3 p){//trying to get by with just the bounding 4 points\n vec3 g=floor(p+0.5);\n vec3 g1=g+crazy(g);\n vec4 dlt=vec4(sign(p-g1),0.0);\n vec3 g2=g+dlt.xww;\n vec3 g3=g+dlt.wyw;\n vec3 g4=g+dlt.wwz;\n g1-=p;\n g2+=crazy(g2)-p;\n g3+=crazy(g3)-p;\n g4+=crazy(g4)-p;\n vec3 gD=g2-g1,gDs=gD;\n float t1=clamp(dot(-g1,gD)/dot(gD,gD),0.0,1.0);\n vec3 p1=mix(g1,g2,t1);\n float m1=dot(p1,p1);\n gD=g3-g1;\n float t2=clamp(dot(-g1,gD)/dot(gD,gD),0.0,1.0);\n vec3 p2=mix(g1,g3,t2);\n float m2=dot(p2,p2);\n if(m2<m1){m1=m2;t1=t2;p1=p2;gDs=gD;}\n gD=g4-g1;\n t2=clamp(dot(-g1,gD)/dot(gD,gD),0.0,1.0);\n vec3 p3=mix(g1,g4,t2);\n m2=dot(p3,p3);\n if(m2<m1){m1=m2;t1=t2;p1=p3;gDs=gD;}\n float d1=sqrt(min(dot(g1,g1),min(dot(g2,g2),min(dot(g3,g3),dot(g4,g4)))))-0.15;\n float len=length(gDs);\n float d2=sqrt(m1)-0.07+len*sqrt(d1)*0.03;//0.02\n float d=0.25;\n if(d2<d && d2<d1){\n  if(d2<0.015){\n   gDs/=len;\n   gD=normalize(cross(gDs,vec3(1.0,0.0,0.0)));\n   float b=dot(p1,gD),c=dot(p1,cross(gDs,gD));\n   vec2 v=vec2(d2,(fract( (t1*16.0+atan(b,c)*0.795775))-0.5)*0.05*len);\n   d2=length(v)-0.01;\n  }\n  d=d2;\n }\n if(mcol.x>0.0){\n   if(d1<0.005)mcol+=vec3(0.6,0.2,0.0)+sin(g*2.0)*0.2;\n   else mcol+=vec3(0.5,0.4,0.2)+sin(p*100.0)*0.1;\n }\n return min(d,d1);\n}\nmat3 lookat(vec3 fw,vec3 up){\n fw=normalize(fw);vec3 rt=normalize(cross(fw,up));return mat3(rt,cross(rt,fw),fw);\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n f1=fract(time*0.01)*6.2832;f2=6.2832*(1.0-fract(time*0.013));f3=6.2832*(fract(time*0.017));\n vec3 ro = vec3(0.5,0.5,time);\n mat3 rotCam=lookat(vec3(sin(time*0.9)*0.5,sin(time*1.4)*0.3,1.0),vec3(sin(time*0.3),cos(time*0.3)*vec2(cos(time*0.5),sin(time*0.5))));\n vec3 rd = rotCam*normalize(vec3((size.xy-2.0*fragCoord.xy)/size.y,1.75));\n float t=0.0,d=1.0,dm=1.0,tm=0.0;\n for(int i=0;i<32;i++){\n  t+=d=DE(ro+rd*t);\n  if(d<dm){dm=d;tm=t;}\n }\n vec3 L=normalize(vec3(0.3,0.7,-0.4));\n vec3 col=vec3(0.5,0.6,0.7)*pow(0.75+0.25*dot(rd,L),2.0)+rd*0.1;\n float pxl=1.0/size.y;\n if(d<pxl*10.0){\n  mcol.x=0.1;\n  vec3 p=ro+rd*tm;\n  vec2 v=vec2(pxl,0.0);\n  vec3 N=normalize(vec3(DE(p+v.xyy)-DE(p-v.xyy),DE(p+v.yxy)-DE(p-v.yxy),DE(p+v.yyx)-DE(p-v.yyx)));\n  vec3 scol=mcol*0.16*(1.0+dot(N,L))/(1.0+0.01*t*t);\n  scol+=vec3(0.5,0.2,0.75)*pow(max(0.0,dot(reflect(rd,N),L)),8.0);\n  mcol=vec3(0.0);\n  scol*=clamp((DE(p+N*0.03125)+DE(p+N*0.0125))*20.0,0.25,1.0);//cheat from mu6k\n  scol=mix(col,scol,exp(-t*0.4));\n  col=mix(scol,col,smoothstep(0.0,0.01,dm));\n }\n fragColor = vec4(clamp(col*1.5,0.0,1.0),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3tf3zS.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[103, 103, 122, 122, 163], [185, 185, 202, 252, 1410], [1411, 1411, 1440, 1440, 1525], [1526, 1526, 1583, 1583, 2671]], "test": "timeout"}
{"id": "3tfGW7", "name": "Rotating Squares Tiling", "author": "fizzer", "description": "Fitting rotated squares together in a grid. The result is a bit similar to Cairo tilings: [url]https://www.shadertoy.com/view/MlSfRd[/url].", "tags": ["tiling"], "likes": 12, "viewed": 177, "published": "Public", "date": "1556458772", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float pi = acos(-1.);\n    float zoom = 5.;\n    vec2 p = fragCoord / iResolution.y * zoom;\n\n    float th = mod(iTime * pi / 5., pi * 2.);\n    float gridsize = (.5 + abs(sin(th * 2.)) * (sqrt(2.) / 2. - .5)) * 2.;\n\n    bool flip = false;\n\n    if(fract(th / pi + .25) > .5)\n    {\n        p -= .5;\n        flip = true;\n    }\n\n    p *= gridsize;\n\n    vec2 cp = floor(p / gridsize);\n\n    p = mod(p, gridsize) - gridsize / 2.;\n\n    p *= mod(cp, 2.) * 2. - 1.;\n\n    p *= mat2(cos(th), sin(th), -sin(th), cos(th));\n\n    float w = zoom / iResolution.y * 1.5;\n    \n    float a = smoothstep(-w, +w, max(abs(p.x), abs(p.y)) - .5);\n\n    if(flip)\n        a = 1. - a;\n\n    if(flip && a < .5 && (abs(p.x) - abs(p.y)) * sign(fract(th / pi) - .5) > 0.)\n        a = .4;\n\n    if(!flip && a < .5 && (mod(cp.x + cp.y, 2.) - .5) > 0.)\n        a = .4;\n\n    fragColor.rgb = pow(vec3(a), vec3(1. / 2.2));\n    fragColor.a = 1.;\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3tfGW7.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 963]], "test": "ok"}
{"id": "3tl3Wr", "name": "Torus attack", "author": "Domenicobrz", "description": "sketch", "tags": ["raymarch"], "likes": 4, "viewed": 102, "published": "Public", "date": "1556070733", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float reptorus(vec3 p, vec2 t) {\n    \n      float tr = 25.0;\n      float htr = tr * 0.5;\n      float px = mod(p.x + htr, tr) - htr;\n      float py = mod(p.y + htr, tr) - htr;\n      float pz = mod(p.z + htr, tr) - htr;\n    \n      p = vec3(px, py, pz);       \n      \n      \n  \t  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  \t  return length(q)-t.y;\n}\n\nmat4 rotationMatrix(vec3 axis, float angle)\n{\n    axis = normalize(axis);\n    float s = sin(angle);\n    float c = cos(angle);\n    float oc = 1.0 - c;\n    \n    return mat4(oc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s,  0.0,\n                oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s,  0.0,\n                oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c,           0.0,\n                0.0,                                0.0,                                0.0,                                1.0);\n}\n\nfloat trace(vec3 p) {\n    float d = 99999.0;\n    \n    \n    float s1 = reptorus(vec3(p) * mat3(rotationMatrix(vec3(1.0, sin(iTime), 0.0), iTime + p.z * 0.001)), vec2(3.0, 1.0));\n    if(s1 < d) d = s1;\n    \n\n    return d;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = ( 2.*fragCoord - iResolution.xy ) / iResolution.y;\n\n\n    vec3 ro = vec3(0.0 + sin(iTime) * 10.0, 0.0, -15.0);\n    vec3 rd = normalize(vec3(uv, 2.0)); \n    \n   \n    vec3 lightDir = vec3(1.0, -1.0, 1.0);\n    \n    \n    vec3 p = ro;\n    float d = 0.0;\n    for(int i = 0; i < 100; i++) {\n        p += rd * d;\n        d = trace(p);\n       \n        if(d < 0.001) {\n            \n            float epsilon = 0.001;\n            \n            float px = trace(p + vec3(+epsilon, 0.0, 0.0));\n            float nx = trace(p + vec3(-epsilon, 0.0, 0.0));\n            \n            float py = trace(p + vec3(0.0, +epsilon, 0.0));\n            float ny = trace(p + vec3(0.0, -epsilon, 0.0));\n            \n            float pz = trace(p + vec3(0.0, 0.0, +epsilon));\n            float nz = trace(p + vec3(0.0, 0.0, -epsilon));\n            \n            vec3 n = normalize(vec3(px - nx, py - ny, pz - nz));\n            \n                               \n            float diffuse = max(  dot(n, -lightDir)  , 0.0);\n            vec3 surfaceColor = vec3(1.0);                   \n                       \n            \n            fragColor = vec4(surfaceColor * diffuse, 1.0);\n            return;\n        }\n    }\n    \n    // Output to screen\n    fragColor = vec4(0.0, 0.0, 0.0, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3tl3Wr.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 32, 32, 342], [344, 344, 389, 389, 1017], [1019, 1019, 1040, 1040, 1240], [1243, 1243, 1300, 1350, 2620]], "test": "ok"}
{"id": "3tl3zH", "name": "Voxels with Ray tracing", "author": "kindpotato", "description": "Voxels with ray tracing. This took me a really long time to figure out how to do.", "tags": ["minecraftraytracing"], "likes": 3, "viewed": 412, "published": "Public", "date": "1555691172", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define UVINBOUND uv.x < halfWidth && uv.x > -halfWidth && uv.y < halfWidth && uv.y > -halfWidth\n\nfloat planeIntersection(vec3 N,vec3 V,vec3 pos){\n\tfloat distToPlane = -dot(pos,N);\n\tfloat rayDotPlane = -dot(V,N);\n    if (rayDotPlane > 0. && distToPlane > 0.)\n        return distToPlane/rayDotPlane;\n    else return 0.;\n}\n\nfloat ground(vec2 coord){\n\treturn cos(0.2*coord.x)+cos(0.2*coord.y)+cos(coord.x/10.);\n}\n\nvec3 planeColor(vec3 V,vec3 N,vec3 lightVec,vec2 uv){\n    float lightDist = length(lightVec);\n    float threshold = 1./lightDist/lightDist/lightDist;\n    //float brightness = 1000. * threshold * dot(N,lightVec);\n    float brightness = dot(N,lightVec/lightDist);\n    vec3 reflected = reflect(V,N);\n    \n    vec2 pixel = vec2(1./1024.);\n    //float shine = 600. * threshold * pow(max(0.,dot(reflected,lightVec/lightDist)),50.);\n    float shine = 0.3*pow(max(0.,dot(reflected,lightVec/lightDist)),50.);\n    return (brightness+shine+0.2)*texture(iChannel0,501.*pixel+8.*pixel*(0.5*uv+0.5)).xyz;\n}\nbool filled(vec3 gridPos){\n\t/*const int width = 16;\n    ivec3 pos = ivec3(int(gridPos.x),int(gridPos.y),int(gridPos.z)) + ivec3(8);\n    ivec2 Z = ivec2(width*(pos.z%width),width*(pos.z/width));\n    \n    return length(texelFetch(iChannel1,Z+pos.xy,0).xyz) > 0.9;*/\n    return gridPos.y < ground(vec2(gridPos.x,gridPos.z));\n}\n\nvec4 boxIntersection(vec3 viewingNormal, vec3 boxPos){\n    vec3 X = vec3(1,0,0);\n    vec3 Y = vec3(0,1,0);\n   \tvec3 Z = vec3(0,0,1);\n    \n    float halfWidth = 0.5;\n    for (int i = 0; i < 2; ++i){\n        \n        \n        vec2 uv;\n        vec3 pos;\n        \n        vec3 planePos = boxPos - halfWidth*X;\n        float t = planeIntersection(X,viewingNormal,planePos);\n        if (t != 0.){\n            pos = t*viewingNormal;\n\n            uv = (pos - planePos).yz;\n            if (UVINBOUND){\n                return vec4(uv,t,0.);\n            }\n        }\n\n        planePos = boxPos - halfWidth*Y;\n        t = planeIntersection(Y,viewingNormal,planePos);\n        if (t != 0.){\n            pos = t*viewingNormal;\n\n            uv = (pos - planePos).xz;\n            if (UVINBOUND){\n                return vec4(uv,t,0.1);\n            }\n        }\n        planePos = boxPos - halfWidth*Z;\n        t = planeIntersection(Z,viewingNormal,planePos);;\n        if (t != 0.){\n            pos = -t*viewingNormal;\n\n            uv = (pos + planePos).xy;\n            if (UVINBOUND){\n                return vec4(uv,t,0.2);\n            }\n        }\n\n        X *= -1.;\n        Y *= -1.;\n        Z *= -1.;\n    }\n    return vec4(0);\n}  \nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy/iResolution.x;\n    float aspect = iResolution.x/iResolution.y;\n    \n    \n    float time = 0.1*iTime;\n    //Based on uv\n    vec3 viewingNormal = normalize( vec3( uv-vec2(0.5,0.5/aspect),1));\n    vec3 cameraZ = normalize(vec3(-sin(time),0.1*sin(iTime),cos(time)));\n    vec3 cameraX = normalize(cross(vec3(0,1,0),cameraZ));\n    vec3 cameraY = cross(cameraZ,cameraX);\n    viewingNormal = viewingNormal.x*cameraX + viewingNormal.y*cameraY + viewingNormal.z*cameraZ;\n    \n    \n    const vec3 planeX = vec3(1,0,0);\n    const vec3 planeY = vec3(0,1,0);\n    const vec3 planeZ = vec3(0,0,1);\n    \n  \t\n    vec3 cameraPos = vec3(100.*cos(time),0,100.*sin(time));\n   \tcameraPos.y =  2.+ground(vec2(cameraPos.x,cameraPos.z));\n    vec3 currentPos = cameraPos;\n    vec3 lightPos = vec3(1000,1000,-40);\n    \n    vec3 gridPos = vec3(floor(currentPos.x),floor(currentPos.y),floor(currentPos.z));\n    bool found = false;\n    vec3 colour = vec3(0.6,0.7,1); //Sky color\n    \n    for(int i = 0; i < 100; ++i){\n        \n    \tvec4 uvt = boxIntersection(viewingNormal,gridPos+vec3(0.5)-currentPos);\n        \n        currentPos += viewingNormal*(uvt.z+0.001); \n        \n        gridPos = vec3(floor(currentPos.x),floor(currentPos.y),floor(currentPos.z));\n        \n        if (filled(gridPos)){\n        \tcurrentPos -= viewingNormal*0.001;\n            vec3 lightVec = lightPos - currentPos;\n        \tif (!found){\n            \tif (uvt.w == 0.) \n            \t\tcolour = planeColor(viewingNormal, -sign(viewingNormal.x)*planeX, lightVec,uvt.xy);\n            \telse if (uvt.w == 0.1)\n            \t\tcolour = planeColor(viewingNormal, -sign(viewingNormal.y)*planeY, lightVec,uvt.xy);\n            \telse if (uvt.w == 0.2) \n            \t\tcolour = planeColor(viewingNormal, -sign(viewingNormal.z)*planeZ, lightVec,uvt.xy);\n            \telse fragColor = vec4(vec3(0.2,0.3,0.5),1);\n                viewingNormal = normalize(lightVec);\n                found = true;\n        \t}\n            else{\n            \tcolour *= 0.45;\n                break;\n            }\n            \n            \n        }\n    }\n    fragColor = vec4(colour, 1);\n     \n\t\t\n}", "image_inputs": [{"id": "XdX3Rn", "previewfilepath": "/media/ap/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg", "channel": 0, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg", "ctype": "texture"}, {"id": "4sf3Rn", "previewfilepath": "/media/ap/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3tl3zH.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[98, 98, 146, 146, 320], [322, 322, 347, 347, 409], [411, 411, 464, 464, 1003], [1004, 1004, 1030, 1267, 1327], [1329, 1329, 1383, 1383, 2539], [2542, 2542, 2599, 2599, 4729]], "test": "error"}
{"id": "3tlGRr", "name": "Rotation headpain", "author": "avin", "description": "Classical rotation demo which may cause a headpain ;)", "tags": ["grid", "rotation", "headpain"], "likes": 10, "viewed": 466, "published": "Public API", "date": "1555510422", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define SIZE 15.0 \n#define HPI 1.5707963 \n#define COL1 vec3(32, 43, 51) / 255.0 \n#define COL2 vec3(235, 241, 245) / 255.0 \n \nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n { \n    vec2 uv = (fragCoord.xy - iResolution.xy * 0.5) / iResolution.x;\n    float hsm = 1.5 / iResolution.y * SIZE * 0.5; // Half-Smooth factor\n        \n    uv *= SIZE; // Make grid\n    vec2 id = floor(uv);\n    uv = fract(uv) - 0.5;\n    \n    float angle = iTime; // Prepare rotation matrix    \n    \n    float phase = mod(floor(angle / HPI), 2.0); // Determine what phase is right now\n    \n    float mask = 0.0;\n    for(float y =- 1.0; y <= 1.0; y++ ) { // Loop to draw neighbour cells\n        for(float x =- 1.0; x <= 1.0; x++ ) {\n            vec2 ruv = uv + vec2(x, y);\n            vec2 rid = id + vec2(x, y);\n                        \n            // Golfed Rotation https://www.shadertoy.com/view/XlsyWX\n            ruv *= mat2(cos( angle + vec4(0,33,11,0)));\n            \n            vec2 maskXY = smoothstep(0.5 + hsm, 0.5 - hsm, abs(ruv));            \n            float maskI = maskXY.x*maskXY.y;  \n            \n            vec2 idm = mod(rid, 2.0);\n            float draw = abs(idm.x*idm.y + (1.-idm.x)*(1.-idm.y) - phase); // Flip depending on phase            \n            \n            mask += maskI * draw;\n        }\n    }\n    \n    vec3 col = vec3(1.0);\n    col = mix(COL1, COL2, abs(mask - phase)); // Color flip depending on phase\n    \n    fragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3tlGRr.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[125, 125, 181, 181, 1459]], "test": "error"}
{"id": "3tlGW4", "name": "AKIRA inspired bike", "author": "yasuo", "description": "Very simple one. I might add the UI and others later.", "tags": ["raymerching", "akira"], "likes": 14, "viewed": 349, "published": "Public API", "date": "1556351167", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// All the distance functions from:http://iquilezles.org/www/articles/distfunctions/distfunctions.htm\n// Edge detection code from:https://www.shadertoy.com/view/MsSGD1\n#define rot(a) mat2(cos(a),-sin(a),sin(a),cos(a))\n#define matRotateX(rad) mat3(1,0,0,0,cos(rad),-sin(rad),0,sin(rad),cos(rad))\n#define matRotateY(rad) mat3(cos(rad),0,-sin(rad),0,1,0,sin(rad),0,cos(rad))\n#define matRotateZ(rad) mat3(cos(rad),-sin(rad),0,sin(rad),cos(rad),0,0,0,1)\n#define hash(h) fract(sin(h) * 43758.5453123)\n#define EDGE_WIDTH 0.05\n\nmat3 m = mat3( 0.00,  0.80,  0.60,\n              -0.80,  0.36, -0.48,\n              -0.60, -0.48,  0.64 );\n\nfloat noise( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n\n    f = f*f*(3.0-2.0*f);\n\n    float n = p.x + p.y*57.0 + 113.0*p.z;\n\n    float res = mix(mix(mix( hash(n+  0.0), hash(n+  1.0),f.x),\n                        mix( hash(n+ 57.0), hash(n+ 58.0),f.x),f.y),\n                    mix(mix( hash(n+113.0), hash(n+114.0),f.x),\n                        mix( hash(n+170.0), hash(n+171.0),f.x),f.y),f.z);\n    return res;\n}\n\nfloat fbm( vec3 p )\n{\n    float f;\n    f  = 0.5000*noise( p ); p = m*p*2.02;\n    f += 0.2500*noise( p ); p = m*p*2.03;\n    f += 0.1250*noise( p );\n    return f;\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0))-0.08;\n}\n\nfloat dBox2d(vec2 p, vec2 b) {\n    return max(abs(p.x) - b.x, abs(p.y) - b.y);\n}\n\nfloat sdHexPrism( vec3 p, vec2 h )\n{\n    const vec3 k = vec3(-0.8660254, 0.5, 0.57735);\n    p = abs(p);\n    p.xy -= 2.0*min(dot(k.xy, p.xy), 0.0)*k.xy;\n    vec2 d = vec2(\n       length(p.xy-vec2(clamp(p.x,-k.z*h.x,k.z*h.x), h.x))*sign(p.y-h.x),\n       p.z-h.y );\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat sdRoundedCylinder( vec3 p, float ra, float rb, float h )\n{\n    vec2 d = vec2( length(p.xz)-2.0*ra+rb, abs(p.y) - h );\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0)) - rb;\n}\n\nvec4 combine(vec4 val1, vec4 val2 ){\n    if ( val1.w < val2.w ) {\n        return val1;\n    }\n    return val2;\n}\n\nfloat sdTorus(vec3 p, vec2 t) {\n    vec2 q = vec2(length(p.xz)-t.x,p.y);\n    return length(q)-t.y;\n}\n\nvec3 tireTex(vec2 uv) {\n    vec3 col = vec3(1.0,0.0,0.0);\n    float d0 = length(uv+vec2(0.5,0.5))-0.36;\n    float d1 = length(uv+vec2(0.5,0.5))-0.33;\n    float d2 = length(uv+vec2(-0.5,0.5))-0.36;\n    float d3 = length(uv+vec2(-0.5,0.5))-0.33;\n    \n    float size = 0.01;\n    \n    col = mix( col, vec3(1.0), 1.0-smoothstep(0.01,0.02,d0) );\n    col = mix( col, vec3(1.0,0.0,0.0), 1.0-smoothstep(0.01,0.02,d1) );\n    col = mix( col, vec3(1.0), 1.0-smoothstep(0.01,0.02,d2) );\n    col = mix( col, vec3(1.0,0.0,0.0), 1.0-smoothstep(0.01,0.02,d3) );\n    \n    return col;\n}\n\nvec3 bodyTex(vec2 uv) {\n    vec3 col = vec3(1.0,0.0,0.0);\n    float d0 = dBox2d(uv+vec2(-0.4,0.2),vec2(0.1,0.03));\n    float d1 = dBox2d(uv+vec2(0.4,0.2),vec2(0.1,0.03));\n    col = mix( col, vec3(1.0), 1.0-smoothstep(0.04,0.05,d0) );\n    col = mix( col, vec3(1.0), 1.0-smoothstep(0.04,0.05,d1) );\n    \n    return col;\n}\n\nvec3 animateTex(vec2 uv, float dir) {\n    vec3 col = vec3(1.0,0.0,0.0);\n    uv.y+=(dir == 0.0)?iTime*-0.1:iTime*0.1;\n    uv.y = mod(uv.y,0.1)-0.05;\n    float d0 = dBox2d(uv+vec2(0.0,0.0),vec2(0.1,0.02));\n    col = mix( col, vec3(1.0,1.0,0.0), 1.0-smoothstep(0.01,0.02,d0) );\n    return col;\n}\n\nvec3 seatTex(vec2 uv) {\n    vec3 col = vec3(1.0,0.0,0.0);\n    float d0 = dBox2d(uv+vec2(0.0,0.0),vec2(0.25,0.4));\n    col = mix( col, vec3(0.2), 1.0-smoothstep(0.01,0.02,d0) );\n    return col;\n}\n\nvec3 floorTex(vec2 uv) {\n    vec3 col = vec3(0.9,0.6,0.6);\n    float w = 2.0;\n    col = (uv.x>=-w && uv.x< w)? vec3(0.8):col;\n    uv.y+=iTime*30.0;\n    uv.y = mod(uv.y,8.0)-4.0;\n    float d0 = dBox2d(uv+vec2(1.5,0.0),vec2(0.05,2.5));\n    float d1 = dBox2d(uv+vec2(-1.5,0.0),vec2(0.05,2.5));\n    col = mix( col, vec3(1.0), 1.0-smoothstep(0.01,0.03,d0) );\n    col = mix( col, vec3(1.0), 1.0-smoothstep(0.01,0.03,d1) );\n    \n    return col;\n}\n\nvec4 sdBike(vec3 p) {\n    vec3 pref = p;\n    vec2 uv = p.xy;\n    \n    vec4 tireF = vec4(vec3(0.0,0.0,0.0),sdTorus((p+vec3(0.0,0.55,1.2))*matRotateZ(radians(90.0)),vec2(0.3,0.12)));\n    vec4 tireF2 = vec4(tireTex(uv),length(p+vec3(0.0,0.55,1.2))-0.3);\n    \n    vec4 tireB = vec4(vec3(0.0,0.0,0.0),sdTorus((p+vec3(0.0,0.55,-1.2))*matRotateZ(radians(90.0)),vec2(0.3,0.12)));\n    vec4 tireB2 = vec4(tireTex(uv),length(p+vec3(0.0,0.55,-1.2))-0.3);\n\n    p.x = abs(p.x);\n    vec4 rearFrame = vec4(bodyTex(uv),sdBox((p+vec3(-0.3,0.3,0.9))*matRotateX(radians(40.0)), vec3(0.002,0.17,0.45)));\n    p = pref;\n    \n    vec4 body0 = vec4(seatTex(uv),sdBox((p+vec3(0.0,0.2,0.4))*matRotateX(radians(-60.0)), vec3(0.2,0.17,0.45)));\n    vec4 body1 = vec4(vec3(1.0,0.0,0.0),sdBox(p+vec3(0.0,0.6,-0.12), vec3(0.2,0.1,0.4)));\n    vec4 body2 = vec4(vec3(1.0,0.0,0.0),sdBox((p+vec3(0.0,0.35,-0.55))*matRotateX(radians(-20.0)), vec3(0.2,0.3,0.1)));\n    \n    p.x = abs(p.x);\n    vec4 frontFrame = vec4(bodyTex(uv),sdBox((p+vec3(-0.25,0.2,-0.8))*matRotateX(radians(-25.0)), vec3(0.002,0.15,0.45)));\n    p = pref;\n    \n    vec4 frontGlass = vec4(animateTex(uv,0.0),sdBox(( p+vec3(0.0,-0.03,-0.80))*matRotateX(radians(-25.0)),vec3(0.25,0.05,0.55)));\n    p = pref;\n    \n    p.x = abs(p.x);\n    vec4 engine = vec4(vec3(1.0,0.0,0.0),sdRoundedCylinder((p+vec3(-0.25,0.65,0.3))*matRotateZ(radians(90.0)), 0.11,0.05,0.05));\n    vec4 engine2 = vec4(vec3(1.0,0.0,0.0),sdRoundedCylinder((p+vec3(-0.25,0.75,-0.05))*matRotateZ(radians(90.0)), 0.08,0.05,0.05));\n    p = pref;\n    \n    vec4 rearMudguard = vec4(animateTex(uv,1.0),sdBox((p+vec3(0.0,-0.17,0.77))*matRotateX(radians(20.0)), vec3(0.2,0.02,0.3)));\n    \n    p.x = abs(p.x);\n    vec4 handle = vec4(vec3(0.2),sdBox((p+vec3(-0.25,-0.1,-0.3))*matRotateX(radians(20.0))*matRotateY(radians(45.0)), vec3(0.2,0.0001,0.0001)));\n    \n    return combine(combine(combine(combine(combine(combine(combine(tireF,tireF2), combine(tireB,tireB2)),combine(rearFrame,body0)),combine(body1,body2)),combine(frontFrame,frontGlass)),combine(engine,engine2)),combine(rearMudguard,handle));\n}\n\nvec4 map(vec3 p){    \n    vec3 pref = p;\n    vec2 uv = p.xy;\n    vec4 f = vec4(floorTex( p.xz),p.y+1.0);\n    p.z += iTime*30.0;\n    p.z = mod(p.z,20.0)-10.0;\n\n    float d0 = sdHexPrism((p+ vec3(0.0,-1.5,0.0)),vec2(4.5,1.0));\n    float d1 = sdHexPrism((p+ vec3(0.0,-1.5,0.0)),vec2(4.7,0.7));\n    d0 = max(-d0,d1);\n    vec4 cell = vec4(vec3(1.0,0.0,0.0),max(sdBox(pref,vec3(9.0,9.0,70.0)),d0));\n    return combine(combine(f,sdBike(pref*matRotateZ(radians(sin(iTime*1.2)*15.0)))),cell);\n}\n\nvec3 normalMap(vec3 p){\n    float d = 0.0001;\n    return normalize(vec3(\n        map(p + vec3(  d, 0.0, 0.0)).w - map(p + vec3( -d, 0.0, 0.0)).w,\n        map(p + vec3(0.0,   d, 0.0)).w - map(p + vec3(0.0,  -d, 0.0)).w,\n        map(p + vec3(0.0, 0.0,   d)).w - map(p + vec3(0.0, 0.0,  -d)).w\n    ));\n}\n\nfloat shadowMap(vec3 ro, vec3 rd){\n    float h = 0.0;\n    float c = 0.001;\n    float r = 1.0;\n    float shadow = 0.5;\n    for(float t = 0.0; t < 30.0; t++){\n        h = map(ro + rd * c).w;\n        if(h < 0.001){\n            return shadow;\n        }\n        r = min(r, h * 16.0 / c);\n        c += h;\n    }\n    return 1.0 - shadow + r * shadow;\n}\n\n// from simon green and others\nfloat ambientOcclusion(vec3 p, vec3 n)\n{\n    const int steps = 4;\n    const float delta = 0.15;\n\n    float a = 0.0;\n    float weight = 4.;\n    for(int i=1; i<=steps; i++) {\n        float d = (float(i) / float(steps)) * delta; \n        a += weight*(d - map(p + n*d).w);\n        weight *= 0.5;\n    }\n    return clamp(1.0 - a, 0.0, 1.0);\n}\n\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr )\n{\n    vec3 cw = normalize(ta-ro);\n    vec3 cp = vec3(sin(cr), cos(cr),0.0);\n    vec3 cu = normalize( cross(cw,cp) );\n    vec3 cv =          ( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    vec2 p = (fragCoord.xy * 2.0 - iResolution.xy) / min(iResolution.x, iResolution.y);\n    vec2 uv = p;\n    \n    p.x+=(mod(iTime,4.0)<0.5)?sin(floor(p.y*60.0)*iTime*30.)*0.05:0.0;\n    \n    float time = iTime*2.0;\n    \n    float handShakeY = fbm(vec3(iTime,iTime*1.1,iTime*1.2))*0.5;\n    float handShakeX = fbm(vec3(iTime*1.1,iTime*1.2,iTime))*0.3;\n    \n    vec3 ro = vec3( handShakeX+0.5+3.5*cos(0.1*time + 6.0), handShakeY + 1.0, -0.5+5.5*sin(0.1*time + 6.0) );\n    vec3 ta = vec3( 0.5, -0.4, -0.5 );\n    mat3 ca = setCamera( ro, ta, 0.0 );\n    vec3 rd = ca * normalize( vec3(p.xy,2.0) );\n    \n    float t, dist;\n    float lastDistEval = 1e10;\n\tfloat edge = 0.0;\n    t = 0.0;\n    vec3 distPos = ro+rd;\n    vec4 distCl = vec4(0.0);\n    for(int i = 0; i < 64; i++){\n        distCl = map(distPos);\n        dist = distCl.w;\n        t += dist;\n        distPos = ro+rd*t;\n        \n\t\tif (lastDistEval < EDGE_WIDTH && dist > lastDistEval + 0.001) {\n\t\t\tedge = 1.0;\n\t\t}\n        if (dist < lastDistEval) lastDistEval = dist;\n        if(dist < 0.01 || dist > 30.0) break;\n    }\n\n    vec3 color;\n    float shadow = 1.0;\n    if(dist < 1.0){\n        // lighting\n        vec3 lightDir = vec3(0.0, 1.0, 0.0);\n        vec3 light = normalize(lightDir + vec3(0.5, 0.0, 0.9));\n        vec3 normal = normalMap(distPos);\n\n        // difuse color\n        float diffuse = clamp(dot(light, normal), 0.5, 1.0);\n        float lambert = max(.0, dot( normal, light));\n        \n        // ambient occlusion\n        float ao = ambientOcclusion(distPos,normal);\n        \n        // shadow\n        shadow = shadowMap(distPos + normal * 0.001, light);\n\n        // result\n        color += vec3(lambert);\n        color = ao*diffuse*(distCl.xyz+(.1-length(p.xy)/3.))*vec3(1.0, 1.0, 1.0);\n        \n    }else{\n        color =.84*max(mix(vec3(0.9,0.81,0.85)+(.1-length(p.xy)/3.),vec3(1),.1),0.);\n    }\n\n    // rendering result\n    float brightness = 1.5;\n    vec3 dst = (color * max(0.8, shadow))*brightness;\n    \n    // add edge detection result\n    dst = mix(dst,vec3(0.1,0.1,0.1),edge);\n    \n    // UI\n    vec3 uicol = vec3(0.0);\n    vec3 barColor = vec3(0.7,0.2,0.2);\n    \n    float numBar = 20.0;\n    float deg = 360.0/numBar;\n    vec2 pos = vec2(0.0,0.0);\n    for(float i = 0.0; i<numBar; i+=1.0) {\n\t\tfloat rotVal = radians(i*deg+iTime*10.0);\n    \tmat2 m = rot(rotVal);\n        float animateVal = sin(hash(i)*(i*deg)*iTime*0.1)*0.1;\n        float bdist = 0.8;\n        float x = pos.x+cos(rotVal)*(bdist+animateVal);\n        float y = pos.y+sin(rotVal)*(bdist+animateVal);\n        float bar = dBox2d((uv+vec2(y, x))*m, vec2(0.01,0.12+animateVal));\n    \tuicol = mix( uicol, barColor, 1.0-smoothstep(0.01,0.02,bar) );\n    }\n    \n    vec2 ruv = uv*rot(radians(iTime*60.0));\n    float circleD = (ruv.y<-0.3)?length(ruv)-0.6:10.0;\n    float circleD2 = (ruv.y>=0.3)?length(ruv)-0.6:10.0;\n    \n    uicol = mix( uicol, barColor, 1.0-smoothstep(0.01,0.015,abs(min(circleD,circleD2))) );\n    fragColor = vec4(dst+uicol, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3tlGW4.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[628, 628, 654, 654, 1059], [1061, 1061, 1082, 1082, 1223], [1225, 1225, 1256, 1256, 1348], [1350, 1350, 1380, 1380, 1430], [1432, 1432, 1468, 1468, 1751], [1753, 1753, 1817, 1817, 1938], [1940, 1940, 1976, 1976, 2051], [2053, 2053, 2084, 2084, 2153], [2155, 2155, 2178, 2178, 2722], [2724, 2724, 2747, 2747, 3043], [3045, 3045, 3082, 3082, 3337], [3339, 3339, 3362, 3362, 3533], [3535, 3535, 3559, 3559, 3974], [3976, 3976, 3997, 3997, 6062], [6064, 6064, 6081, 6081, 6549], [6551, 6551, 6574, 6574, 6851], [6853, 6853, 6887, 6887, 7197], [7568, 7568, 7620, 7620, 7809], [7811, 7811, 7867, 7867, 10851]], "test": "timeout"}
{"id": "3ts3WN", "name": "Domain coloring of inverse gd", "author": "tpfto", "description": "Domain coloring of the complex-valued inverse [url=https://en.wikipedia.org/wiki/Gudermannian_function]Gudermannian function[/url].", "tags": ["2d", "math", "complex", "domaincoloring"], "likes": 4, "viewed": 202, "published": "Public", "date": "1556381397", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// The MIT License\n// Copyright © 2019 J. M.\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// Basic domain coloring plot (https://en.wikipedia.org/wiki/Domain_coloring)\n// of the inverse Gudermannian function w = gd^(-1)(z) (https://en.wikipedia.org/wiki/Gudermannian_function)\n\n#define PI 3.14159265359\n#define TWOPI 6.28318530718\n#define SCALE 7.5 // plot scale\n#define XY_SPACING 1.0 // Cartesian grid line spacing\n#define R_SPACING 1.5 // polar grid line spacing\n\n// modified version of Inigo Quilez's method at https://www.shadertoy.com/view/MsS3Wc\n// using \"rational smoothstep\" from https://tpfto.wordpress.com/2019/03/28/on-a-rational-variant-of-smoothstep/\nvec3 smooth_hue( float h )\n{\n    vec3 rgb = clamp( abs(mod(6.0 * h + vec3(0.0, 4.0, 2.0), 6.0) - 3.0) - 1.0, 0.0, 1.0);\n    return rgb * rgb * rgb/(1.0 - 3.0 * rgb * (1.0 - rgb));\n}\n\n// modified DLMF coloring, adapted from https://www.shadertoy.com/view/WtXGWN\nvec3 smooth_dlmf( float h )\n{\n    vec3 rgb = clamp( vec3(1., -1., -1.) * abs((vec3(8., 4., 8.) * mod(h, 1.0) - vec3(4.5, 1.5, 5.5))) + vec3(-1.5, 1.5, 2.5), 0.0, 1.0 );\n\treturn rgb * rgb * rgb/(1.0 - 3.0 * rgb * (1.0 - rgb));\n}\n\n// Inverse Gudermannian function\n\nvec2 invgd( in vec2 z )\n{\n\tfloat sx = sin(z.x);\n    float cy = cosh(z.y);\n    return vec2(0.5 * log((cy + sx)/(cy - sx)), atan(sinh(z.y), cos(z.x)));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 aspect = iResolution.xy / iResolution.y;\n    vec2 z = ( fragCoord.xy / iResolution.y ) - 0.5 * aspect;\n    z *= SCALE;\n    z.x += iTime;\n    \n    vec2 w = invgd(z);\n    float ph = atan(w.y, w.x);\n    float lm = log(0.0001 + length(w));\n    \n    vec3 cd = smooth_dlmf(0.5 * (ph / PI));\n    vec3 ch = smooth_hue(0.5 * (ph / PI));\n    // transition between normal hue and DLMF coloring\n    vec3 c = mix(cd, ch, 0.5 + 0.5 * cos(2.0 * iTime));\n\n    float sat = abs(sin(TWOPI * lm/R_SPACING));\n    float bri = pow(abs(sin(TWOPI * w.x/XY_SPACING) * sin(TWOPI * w.y/XY_SPACING)), 0.25);\n    bri = max(1.0 - sat, bri);\n    sat = sqrt(sat);\n\n    fragColor = vec4(bri * mix( vec3(1.0), c, sat), 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3ts3WN.jpg", "access": "shaders20k", "license": "mit", "functions": [[1448, 1646, 1674, 1674, 1827], [1829, 1907, 1936, 1936, 2134], [2170, 2170, 2195, 2195, 2321], [2323, 2323, 2380, 2380, 3081]], "test": "ok"}
{"id": "3tX3R4", "name": "Hologram Boxes", "author": "kaneta", "description": "Like SF", "tags": ["3d", "raymarching", "hologram"], "likes": 154, "viewed": 6408, "published": "Public API", "date": "1555695551", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI 3.141592\n#define TAU (PI*2.0)\n\nfloat rand(vec2 n) { \n\treturn fract(sin(dot(n, vec2(12.9898, 4.1414))) * 43758.5453);\n}\n\nfloat noise(vec2 p){\n\tvec2 ip = floor(p);\n\tvec2 u = fract(p);\n\tu = u*u*(3.0-2.0*u);\n\t\n\tfloat res = mix(\n\t\tmix(rand(ip),rand(ip+vec2(1.0,0.0)),u.x),\n\t\tmix(rand(ip+vec2(0.0,1.0)),rand(ip+vec2(1.0,1.0)),u.x),u.y);\n\treturn res*res;\n}\n\nfloat fbm(vec2 p) {\n    float r = 0.0;\n    float amp = 1.0;\n    float freq = 1.0;\n    for(int i = 0; i < 3; i++) {\n        r += amp * noise(freq*p);\n        amp *= 0.5;\n        freq *= 1.0/0.5;\n    }\n    return r;\n}\n\nmat2 rot( float th ){ vec2 a = sin(vec2(1.5707963, 0) + th); return mat2(a, -a.y, a.x); }\n\nfloat remap(float val, float im, float ix, float om, float ox)\n{\n    return clamp(om + (val - im) * (ox - om) / (ix - im), om, ox);\n}\n\nfloat cio(float t) {\n\treturn t < 0.5\n\t? 0.5 * (1.0 - sqrt(1.0 - 4.0 * t * t))\n\t: 0.5 * (sqrt((3.0 - 2.0 * t) * (2.0 * t - 1.0)) + 1.0);\n}\n\nfloat animHeight(vec2 p)\n{\n    float s = 0., hs = 1.;\n    float t = mod(iTime, 7.);\n    float tt = remap(t, 1., 2., 0., 1.);\n    s = mix(0., .3, cio(tt));\n\n    tt = remap(t, 3., 4., 0., 1.);\n    p *= rot(cio(tt) * 3.);\n\n    tt = remap(t, 4., 5., 0., 1.);\n    s = mix(s, 1.0, cio(tt));\n\n    tt = remap(t, 5., 6., 0., 1.);\n    p *= rot(-cio(tt) * 3.);\n\n    tt = remap(t, 6.5, 7., 0., 1.);\n    p *= rot(cio(tt) * 1.);\n    hs = mix(1., 0., cio(tt));\n\n    float pls = (sin(t * TAU - PI*.5) * .5 + .5) * step(mod(t, 2.), 1.) * .2;\n    return (fbm(p * s + t * .5) + pls) * hs;\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return length(max(d,0.0));\n}\n\nvec2 rep( in vec2 p, in vec2 c)\n{\n    return mod(p,c)-0.5*c;\n}\n\nfloat map(vec3 p)\n{\n    float bd = length(p.xz) - 5.0;\n    if (bd > 0.1) {\n    \treturn bd;\n    }\n    vec2 id = floor(p.xz / 0.2);\n    float height = animHeight(id * 0.2) * 0.5;\n    p.xz = rep(p.xz, vec2(0.2));\n    p.y -= height;\n    float box = sdBox(p, vec3(0.03, height, 0.03));\n    return max(box, bd) * .5;\n}\n\nvec2 trace(vec3 p, vec3 ray, float mx)\n{\n    float t = 0.0;\n    vec3 pos;\n    float dist;\n    for (int i = 0; i < 128; i++) {\n        pos = p + ray * t;\n        dist = map(pos);\n        if (dist < 0.002 || t > mx) {\n        \tbreak;\n        }\n        t += dist;\n    }\n    return vec2(t, dist);\n}\n\nvec3 getColor(vec3 p, vec3 ray)\n{\n    vec2 t = trace(p, ray, 100.0);\n    vec3 pos = p + ray * t.x;\n    if (t.x > 100.0) {\n        return vec3(0.0);\n    }\n    return max(vec3(0.2, 0.5, 0.8) * 7.0 * pow(pos.y, 4.0) * smoothstep(0.0, -1.0, length(pos.xz) - 5.0), vec3(0.0));\n}\n\nmat3 camera(vec3 ro, vec3 ta, float cr )\n{\n\tvec3 cw = normalize(ta - ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\nfloat luminance(vec3 col)\n{\n    return dot(vec3(0.3, 0.6, 0.1), col);\n}\n\nvec3 acesFilm(const vec3 x) {\n    const float a = 2.51;\n    const float b = 0.03;\n    const float c = 2.43;\n    const float d = 0.59;\n    const float e = 0.14;\n    return clamp((x * (a * x + b)) / (x * (c * x + d ) + e), 0.0, 1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = (fragCoord.xy * 2.0 - iResolution.xy) / min(iResolution.x, iResolution.y);\n    \n    float t = iTime * 0.1;\n    vec3 ro = vec3(cos(t) * 10.0, 5.5, sin(t) * 10.0);\n    vec3 ta = vec3(0.0, 1.0, 0.0);\n    mat3 c = camera(ro, ta, 0.0);\n    vec3 ray = c * normalize(vec3(p, 2.5));\n    vec3 col = getColor(ro, ray);\n    \n    vec3 lp = vec3(0.0, 6.0, 0.0), rd = ray;\n\n    float s = 7.5, vol = 0.0;\n    for(int i = 0; i < 60; i++) {\n        vec3 pos = ro + rd*s;\n        \n        vec3 v = -normalize(lp - pos);\n        \n    \tfloat tt = -(lp.y-2.) / v.y;\n        \n        vec3 ppos = lp + v * tt;\n\t    vol += pow(animHeight(ppos.xz), 3.0) * 0.05 * smoothstep(0.0, 1.5, pos.y) * smoothstep(-1.0, -4.0, length(ppos.xz) - 5.0);\n\n        s += 0.1;\n    }\n\n    col += 1.6*vec3(0.3*vol, 0.5*vol, vol);\n\n    col = acesFilm(col * 0.5);\n    col = pow(col, vec3(1.0/2.2));\n\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3tX3R4.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[42, 42, 62, 62, 129], [131, 131, 151, 151, 360], [362, 362, 381, 381, 577], [579, 579, 600, 600, 668], [670, 670, 734, 734, 803], [805, 805, 825, 825, 942], [944, 944, 970, 970, 1515], [1517, 1517, 1548, 1548, 1602], [1604, 1604, 1637, 1637, 1666], [1668, 1668, 1687, 1687, 1980], [1982, 1982, 2022, 2022, 2276], [2278, 2278, 2311, 2311, 2551], [2553, 2553, 2595, 2595, 2773], [2775, 2775, 2802, 2802, 2846], [2848, 2848, 2877, 2877, 3081], [3083, 3083, 3140, 3140, 4039]], "test": "ok"}
{"id": "3tX3R8", "name": "Selmi Triangle", "author": "dracusa", "description": "My my, will you look at that sexy list of tags.", "tags": ["fractal", "retro", "illusion", "escher", "recursive", "sierpinski", "penrose", "impossible", "reutersvard"], "likes": 70, "viewed": 2783, "published": "Public API", "date": "1555557240", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/*\nFractal Penrose triangle aka Selmi triangle. I came across it when John Baez\nshared it a couple of months ago, and I wanted to explore the concept with a\nshader. Representations of it were first posted online by Nidhal Selmi and \nAkiyoshi Kitaoka in 2009-2010.\n\nRegarding implementation, I didn't find any super elegant or efficient way of\ngenerating it, and ended up manually placing overlapping isometric faces.\nEverything is 2D. I'm basically treating the Sierpinski triangle as a tiling,\nwith the Penrose triangle being the prototile. Somewhat experimentally,\neverything is generated in HSV color space and converted to RGB at the end,\nwhich makes for easy color management.\n\nLinks:\nhttp://math.ucr.edu/home/baez/diary/march_2019.html\nhttps://www.deviantart.com/nydhalo/art/Selmi-Triangle-136342456\nhttp://www.psy.ritsumei.ac.jp/~akitaoka/fukano2e.html\n*/\n\n\n// Sets of coordinates used for the current and adjacent tiles\nstruct TileSpace {\n\tvec2 p; // current point in tile coordinates\n\tvec2 to; // tile origin in global coordinates\n};\n\n// Existence of neighboring tiles (left/right/bottom)\nstruct Neighbors {\n\tbool L;\n\tbool BL;\n\tbool BR;\n};\n\n// Number of iterations being displayed\nint level;\n// Smoothed number of iterations and related values\nfloat smoothLevel, tilesize, lineLightness;\n// Colors in HSV space\nconst vec3 lightHSV = vec3(0., 0., 0.95);\nconst vec3 mediumHSV = vec3(0., 0., 0.4);\nconst vec3 darkHSV = vec3(0., 0., 0.14);\nconst vec3 lineHSV = vec3(0., 0., 0.);\nvec3 bgHSV;\n\n// These functions angle space for the placement of isometric cube faces\nvec2 isoM(vec2 p) { return vec2(p.y, 0.5*p.y - p.x); }\nvec2 isoL(vec2 p) { return vec2(p.x+p.y*0.5, p.y); }\nvec2 isoR(vec2 p) { return vec2(p.x+p.y*0.5, 0.5*p.y - p.x); }\n\n// These functions repeat space to draw cheap rows of faces\nfloat range(float x, float xmin, float xmax) {\n\treturn max(min(fract(x), x-xmin), x-xmax);\n}\nvec2 xRange(vec2 p, float xmin, float xmax) {\n\tp.x = range(p.x, xmin, xmax);\n\treturn p;\n}\nvec2 yRange(vec2 p, float ymin, float ymax) {\n\tp.y = range(p.y, ymin, ymax);\n\treturn p;\n}\n\n// Draw a unit square onto ret\nvoid square(inout vec3 ret, vec2 p, vec3 col, float aaSize) {\n\tp = abs(p-0.5);\n\tfloat sqgrad = max(p.x, p.y)*2.;\n\tvec3 lc = mix(lineHSV, col, lineLightness);\n\tret = mix (ret, lc, 1.-smoothstep(1., 1.+aaSize, sqgrad));\n\tret = mix(col, ret, smoothstep(1.-aaSize, 1., sqgrad));\n}\n\n/*\nConstruct a Penrose triangle in 2D by manually placing a bunch of angled\nsquares. Nothing really magic.\n*/\nvoid drawPenrose(inout vec3 ret, vec2 p, float aaSize) {\n\t// L to T\n\tsquare(ret, xRange(isoR(p)+vec2(0., 1.), 1., 2.), lightHSV, aaSize);\n\t// R to L\n\tsquare(ret, yRange(isoM(p), -3., 0.), mediumHSV, aaSize);\n\tsquare(ret, xRange(isoL(p)+vec2(0., 1.), -1., 2.), darkHSV, aaSize);\n\t// R to T\n\tsquare(ret, yRange(isoL(p)-vec2(3., 0.), -1., 2.), darkHSV, aaSize);\n\tsquare(ret, yRange(isoR(p)-vec2(4., 0.), -5., -1.), lightHSV, aaSize);\n\t// L to T cover\n\tsquare(ret, isoR(p)+vec2(-3., 1.), lightHSV, aaSize);\n\tsquare(ret, xRange(isoM(p), 1., 4.), mediumHSV, aaSize);\n}\n\n/*\nConstruct a Penrose triangle and connect it to its neighbors by adding some more\nangled squares.\n*/\nvoid drawSelmi(inout vec3 ret, TileSpace t, Neighbors n, float aaSize) {\n\tvec2 p = t.p*4.-vec2(2., 0.);\n\tp *= vec2(0.5, 0.578);\n\tp += vec2(3., 1.3);\n\tif (n.BL) {\n\t\tsquare(ret, yRange(isoR(p)+vec2(0., 0.), -3., -2.), lightHSV, aaSize);\n\t}\n\tif (n.BR) {\n\t\tsquare(ret, isoM(p)+vec2(2., 4.), mediumHSV, aaSize);\n\t}\n\tdrawPenrose(ret, p, aaSize);\n\tif (n.L) {\n\t\tsquare(ret, isoL(p)+vec2(1., 0.), darkHSV, aaSize);\n\t\tsquare(ret, isoL(p)+vec2(2., 1.), darkHSV, aaSize);\n\t\tsquare(ret, isoR(p), lightHSV, aaSize);\n\t}\n\tif (n.BL) {\n\t\tsquare(ret, isoR(p)+vec2(1., 1.), lightHSV, aaSize);\n\t\tsquare(ret, isoM(p)+vec2(1., 0.), mediumHSV, aaSize);\n\t}\n\tif (n.BR) {\n\t\tsquare(ret, isoR(p)+vec2(-3., 5.), lightHSV, aaSize);\n\t\tsquare(ret, isoR(p)-vec2(4., -6.), lightHSV, aaSize);\n\t\tsquare(ret, isoM(p)+vec2(1., 4.), mediumHSV, aaSize);\n\t}\n}\n\n/*\nConvert coordinates to \"Sierpinski tile\" coordinates. I originally rolled my own\nSierpinski function, but then I saw iq's smugly superior version so I\nrage-deleted all my code and based my new version on his:\nhttps://www.shadertoy.com/view/Md2GzR\nwhich itself was probably inspired by Syntopia's Sierpinski code:\nhttp://blog.hvidtfeldts.net/index.php/2011/08/distance-estimated-3d-fractals-iii-folding-space/\n*/\nconst vec2 va = vec2(0.0, 1.73-0.85);\nconst vec2 vb = vec2(1.0, 0.00-0.85);\nconst vec2 vc = vec2(-1.0, 0.00-0.85);\nfloat length2(vec2 p) { return dot(p,p); }\nTileSpace sierpSpace(vec2 pin) {\n\tfloat a = 0.0;\n\tvec2 p = pin;\n\tvec2 c;\n\tfloat dist, d, t;\n\tfor (int i = 0; i<7; i++) {\n\t\tif (i>=level) continue;\n\t\td = length2(p-va);                 c = va; dist=d; t=0.0;\n        d = length2(p-vb); if (d < dist) { c = vb; dist=d; t=1.0; }\n        d = length2(p-vc); if (d < dist) { c = vc; dist=d; t=2.0; }\n\t\tp = c + 2.0*(p - c);\n\t\ta = t + a*3.0;\n\t}\n\tvec2 to = (pin - p*tilesize);\n\treturn TileSpace(p, to);\n}\n\n/*\nI'm resorting to an utterly barbaric way of determining if the tile has\nneighbors to connect to: re-running down the entire fractal for each neighboring\nside to check. There's got to be a way of getting all of this in a single pass,\nbut I couldn't figure it out. Oh well, at least I reduced it to 3 taps instead\nof having to check all 6 possible neighbors, by offsetting the tile contents so\nthat it's only affected by the bottom-left connections.\n*/\n#define EPSILON 0.001\nbool approx(vec2 a, vec2 b) { return all(lessThan(abs(a-b), vec2(EPSILON))); }\nNeighbors getNeighbors(vec2 p, TileSpace t) {\n\tNeighbors n;\n\tfloat eps = tilesize*0.002;\n    // check if the tile origin is equal to the tile origin of neighboring points\n\tn.L = !approx(t.to, sierpSpace(t.to-tilesize*vec2(1.1, 0.)).to);\n\tn.BL = !approx(t.to, sierpSpace(t.to-tilesize*vec2(0.92, 0.92)).to);\n\tn.BR = !approx(t.to, sierpSpace(t.to-tilesize*vec2(-0.92, 0.92)).to);\n\treturn n;\n}\n\n/*\nEquilateral triangle distance by iq, used for the big blurry shadow.\n(Todo: project it onto the plane because right now it looks wrong.)\nAlso used for the transition effect between levels of iteration.\n*/\nfloat sdEquilateralTriangle(vec2 p)\n{\n    const float k = sqrt(3.0);\n    p.x = abs(p.x) - 1.0;\n    p.y = p.y + 1.0/k;\n    if( p.x + k*p.y > 0.0 ) p = vec2( p.x - k*p.y, -k*p.x - p.y )/2.0;\n    p.x -= clamp( p.x, -2.0, 0.0 );\n    return -length(p)*sign(p.y);\n}\n\n// Smooth HSV: https://www.shadertoy.com/view/MsS3Wc\nvec3 hsv2rgb_smooth(vec3 c)\n{\n\treturn c.z * (1.-c.y*smoothstep(2.,1., abs(mod(c.x*6.+vec3(0,4,2), 6.) -3.)));\n}\n\n// Convert to ground-plane coordinates\nvec2 groundP(vec2 p)\n{\n\tp.y += 0.184;\n\tp.x = 2.*(p.x/8.)/(.5-p.y);\n\tp.y = p.y / (p.y-.5);\n\tp.y += smoothLevel*0.46;\n\tp *= 7.;\n\treturn p;\n}\n\n/*\nReturn a drawable grid on the ground-plane.\nTodo: get the AA size with the derivative of groundP instead of this shitty\nnumerical approximation.\n*/\nfloat ground(vec2 pin)\n{\n\tpin.x = abs(pin.x);\n\tvec2 p = groundP(pin);\n\tvec2 p2 = groundP(pin-vec2(1./iResolution));\n\tfloat aax = min(0.5, abs(p.x-p2.x)*1.5);\n\tfloat aay = min(0.5, abs(p.y-p2.y)*1.5);\n\tfloat ret = smoothstep(0.5-aax, 0.5, abs(fract(p.x)-0.5));\n\tret = max(ret, smoothstep(0.5-aay, 0.5, abs(fract(p.y)-0.5)));\n\treturn ret*(0.5-aay)*2.;\n}\n\n//  Dave_Hoskins hash, used for film grain effect\nfloat hash13(vec3 p3)\n{\n\tp3 = fract(p3 * .1031);\n\tp3 += dot(p3, p3.yzx + 19.19);\n\treturn fract((p3.x + p3.y) * p3.z);\n}\n\nvoid mainImage(out vec4 fragColor, vec2 fragCoord)\n{\n    vec2 uv = fragCoord/iResolution.xy;\n\tvec2 p = uv-0.5;\n\tp.x *= iResolution.x/iResolution.y;\n\t\n\t// Slowly increase and decrease the fractal's iteration count\n\tsmoothLevel = 0.7+(4.5-0.7)*(0.5-0.5*cos(iTime*0.2));\n\tfloat trans = sdEquilateralTriangle(-0.2*(p-vec2(0., 0.33)))+0.66;\n\tlevel = int(smoothLevel-trans);\n\ttilesize = 1./pow(2.,float(level));\n\tlineLightness = smoothLevel*0.18;\n\tfloat zoom = pow(2.,smoothLevel)*1.09*tilesize;\n\tfloat aaSize = 22.*zoom*(1.0/length(iResolution))/tilesize;\n\n\t// Prepare some colors and background grid on plane\n\tbgHSV = vec3(float(level)*0.16+0.5, 0.6, 1.);\n\tvec3 bg2 = vec3(bgHSV.x+0.25, 0., 1.);\n\tbgHSV = mix(bgHSV, bg2, sqrt(uv.y));\n\tbgHSV.z *= 1.-ground(p)*0.75;\n\tvec3 ret = bgHSV;\n\n\t// Prepare coordinates for the object\n\tp = (p-vec2(0., 0.33-0.1/smoothLevel))*zoom+vec2(0.5, 0.94);\n\tTileSpace t = sierpSpace(p*2.-1.);\n\tNeighbors n = getNeighbors(p, t);\n\n\t// Shadow\n\tvec2 sp = (p-vec2(0.35, 0.2));\n\tsp.y *= 2.;\n\tsp.x += sp.y*0.3;\n\tfloat s = sdEquilateralTriangle(sp * 2.);\n\tfloat samp = 1.5/(max(sp.y+2.,0.)+1.);\n\tsamp *= 2.2-1.2*smoothstep(-1., 4., float(level));\n\tret.z *= 1. - samp/(max(s, 0.)+1.);\n\t\n\t// Draw the object\n\tdrawSelmi(ret, t, n, aaSize);\n\n\t// Draw white transition triangle\n\tvec3 c2 = vec3(bgHSV.x, 0., 0.9);\n\tret = mix(c2, ret, clamp(abs(fract(smoothLevel-trans+0.49)-0.5)*400.-4., 0., 1.));\n\n\t// Film grain effect\n\tfloat hash = hash13(vec3(fragCoord, iTime*1500.+50.));\n\tret.z *= 1.-hash*0.13*(1.-ret.y);\n\tret.x += hash*0.13*ret.y;\n\n\t// Convert to RGB\n    fragColor = vec4(hsv2rgb_smooth(ret), 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3tX3R8.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1497, 1570, 1589, 1589, 1624], [1625, 1625, 1644, 1644, 1677], [1678, 1678, 1697, 1697, 1740], [1742, 1802, 1848, 1848, 1894], [1895, 1895, 1940, 1940, 1984], [1985, 1985, 2030, 2030, 2074], [2076, 2107, 2168, 2168, 2383], [2385, 2495, 2551, 2562, 3057], [3059, 3162, 3234, 3234, 3979], [4511, 4511, 4534, 4534, 4553], [4554, 4554, 4586, 4586, 4998], [5476, 5476, 5505, 5505, 5554], [5555, 5555, 5600, 5600, 5945], [5947, 6155, 6192, 6192, 6414], [6416, 6469, 6498, 6498, 6580], [6582, 6621, 6643, 6643, 6759], [6761, 6912, 6936, 6936, 7263], [7265, 7315, 7338, 7338, 7434], [7436, 7436, 7488, 7488, 9055]], "test": "ok"}
{"id": "3tX3zM", "name": "d_Squares", "author": "daumkuchen", "description": "study.", "tags": ["2d"], "likes": 2, "viewed": 76, "published": "Public", "date": "1555837833", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\n    vec2 p = (fragCoord.xy * 2. - iResolution.xy) / min(iResolution.x, iResolution.y);\n    \n    float reso = 4.;\n\n    vec2 cell = floor(p * reso);\n    vec2 center = (cell + .5) / reso;\n\n    float t = iTime + cell.x + cell.y;\n    t *= 2.;\n\n    float l = distance(p, center);\n    float r = (.4 + sin(t) * .4) / reso;\n\n    vec3 rgb = vec3((l - r) * reso);\n\n    fragColor = vec4(rgb, 1.);\n    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3tX3zM.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 450]], "test": "ok"}
{"id": "3tX3zn", "name": "2d soft lights", "author": "Jodie", "description": "2d soft shadows", "tags": ["2d", "shadow", "lighting", "penumbra", "soft"], "likes": 16, "viewed": 739, "published": "Public", "date": "1555418660", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n// curve matched using turingbot\nvec3 linearToSrgb(const vec3 x){\n    return 1.14374*(-0.126893*x+sqrt(x));\n}\n\n\nconst float pi = radians(180.);\nconst float hpi = radians(90.);\n\nfloat mulSign(float x,float y){\n    return uintBitsToFloat(floatBitsToUint(x)^(floatBitsToUint(y)&0x80000000u));\n}\n\n//curve fitted with turingbot rms 0.000030\nfloat fast_acos(float x){\n    float a = abs(x);\n    a=a*(a*(a*(0.151627-0.0354045*a)-0.387686)+1.27146);\n    return mulSign(sqrt(1.-a)-1.,x)*hpi+hpi;\n}\n#define acos(x) fast_acos(x)\n#define asin(x) ( pi * .5 - acos(x) )\n#define saturate(x) clamp(x,0.,1.)\n\nstruct circle {\n    float distance;\n\tvec2 direction;\n\tfloat angularRadius;\n};\n\nfloat getLighting(const circle light, const circle occluder){\n    \n    bool behindOccluder = occluder.distance < light.distance;\n    \n    float offset = acos(saturate(dot(light.direction,occluder.direction)));\n\t\n    if(behindOccluder)\n\t\treturn light.angularRadius - max(occluder.angularRadius - offset,0.);\n    return light.angularRadius;\n}\n\nfloat dither(const vec2 fragCoord){\n\treturn (texture(iChannel0,fragCoord/8.)-.5).x/255.;\n}\n        \ncircle createCircle(vec2 position,const float radius,const vec2 fragCoord){\n\tcircle c;\n\n    position -= fragCoord;\n\tfloat distanceSquared = dot(position,position);\n\tfloat inverseDistance = inversesqrt(distanceSquared);\n    \n    c.distance = inverseDistance * distanceSquared;\n\tc.direction = position * inverseDistance;\n    c.angularRadius = asin(radius*inverseDistance);\n    \n    bool inside = c.distance < radius;\n    \n    if(inside) c.angularRadius = pi;\n\n    return c;\n    \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    \n    circle l0 = createCircle(\n        vec2((200.+cos(iTime)*100.),40.),\n        25.,\n        fragCoord\n    );\n    \n    circle l1 = createCircle(\n        vec2(30,100.+cos(iTime)*100.),\n        10.,\n        fragCoord\n    );\n    \n    circle l2 = createCircle(\n        iMouse.xy,\n        30.,\n        fragCoord\n    );\n    \n    circle o0 = createCircle(\n        vec2(150,160),\n        15.,\n        fragCoord\n    );\n    \n    circle o1 = createCircle(\n        vec2(350,130),\n    \t40.,\n        fragCoord\n    );\n    \n    fragColor.rgb = vec3(2,0,0) * min(getLighting(l0,o0),getLighting(l0,o1))+ \n    \t\t\t\tvec3(0,2,0) * min(getLighting(l1,o0),getLighting(l1,o1))+\n    \t\t\t\tvec3(0,0,2) * min(getLighting(l2,o0),getLighting(l2,o1));\n    \n    fragColor.rgb /= pi;\n\n    fragColor.rgb = linearToSrgb(fragColor.rgb) + dither(fragCoord);\n    \n    //fragColor.rgb=vec3(acos((fragCoord.x/iResolution.x)*2.-1.))/pi;\n}", "image_inputs": [{"id": "Xdf3zn", "previewfilepath": "/media/ap/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3tX3zn.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 34, 66, 66, 110], [178, 178, 209, 209, 292], [294, 337, 362, 362, 488], [671, 671, 732, 732, 1011], [1013, 1013, 1048, 1048, 1103], [1113, 1113, 1188, 1188, 1591], [1593, 1593, 1649, 1649, 2550]], "test": "error"}
{"id": "3tXGDn", "name": "zigzigzig", "author": "lennyjpg", "description": "sdfgsdgsdfg", "tags": ["dfsdfgdsfg"], "likes": 3, "viewed": 257, "published": "Public API", "date": "1555972449", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord/iResolution.x)*2.0;\n    \n    uv.x = abs(mod(uv.x,0.2)-0.1);\n    uv.x+=iTime*0.1;    \n    float s = 0.05;\n    uv.y += step(mod(uv.x,s*2.0),s)*0.5;\n    float k = mod(uv.x,s);\n    float h = abs(mod(uv.y,s*2.0)-s);\n    float g = smoothstep( k*0.95,k, h );\n    fragColor = vec4(g);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3tXGDn.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 361]], "test": "ok"}
{"id": "3tXGR8", "name": "Sun on the water", "author": "jojobavg", "description": "raymarching first test scene\nNoise based on Morgan McGuire @morgan3d https://www.shadertoy.com/view/4dS3Wd", "tags": ["3d", "raymarching"], "likes": 5, "viewed": 147, "published": "Public", "date": "1555545281", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define time iTime\n\n\nfloat random (float x) {\n    return fract(sin(x)*1e4);\n}\n\nfloat noise2(vec3 p) {\n  vec3 ip=floor(p);\n  p=fract(p);\n  p=smoothstep(0.0,1.0,p);\n  vec3 st=vec3(7,37,289);\n  vec4 pos=dot(ip,st) + vec4(0,st.y,st.z,st.y+st.z);\n  vec4 val=mix(fract(sin(pos)*7894.552), fract(sin(pos+st.x)*7894.552), p.x);\n  vec2 val2=mix(val.xz,val.yw, p.y);\n  return mix(val2.x,val2.y, p.z);\n}\n\n// Based on Morgan McGuire @morgan3d\n// https://www.shadertoy.com/view/4dS3Wd\nfloat noise( vec3 p) {\n    const vec3 step = vec3(110.0, 241.0, 171.0);\n\n    vec3 i = floor(p);\n    vec3 f = fract(p);\n\n    // For performance, compute the base input to a\n    // 1D random from the integer part of the\n    // argument and the incremental change to the\n    // 1D based on the 3D -> 1D wrapping\n    float n = dot(i, step);\n\n    vec3 u = f * f * (3.0 - 2.0 * f);\n    return mix( mix(mix(random(n + dot(step, vec3(0.0,0.0,0.0))),\n                        random(n + dot(step, vec3(1.0,0.0,0.0))),\n                        u.x),\n                    mix(random(n + dot(step, vec3(0.0,1.0,0.0))),\n                        random(n + dot(step, vec3(1.0,1.0,0.0))),\n                        u.x),\n                u.y),\n                mix(mix(random(n + dot(step, vec3(0.0,0.0,1.0))),\n                        random(n + dot(step, vec3(1.0,0.0,1.0))),\n                        u.x),\n                    mix(random(n + dot(step, vec3(0.0,1.0,1.0))),\n                        random(n + dot(step, vec3(1.0,1.0,1.0))),\n                        u.x),\n                u.y),\n            u.z);\n}\n\nmat2 rot(float a) {\n  float ca=cos(a);\n  float sa=sin(a);\n  return mat2(ca,sa,-sa,ca);\n}\n\nfloat sphere( vec3 p, in vec3 centerPos, float radius) {\n\treturn length(p-centerPos) - radius;\n}\n\nfloat fire( vec3 p, vec3 centerPos, float scale,float radius ) {\n  float l=min(length(p-centerPos)/radius,1.0)*0.7+0.3;\n  float nl = (1.0-l);\n  float x=(noise((p+sin(time)*2.0*l)*0.2)*2.0-1.0)*15.0*nl;\n  float y=(noise((p+sin(time+5.0)*2.0*l)*0.2)*2.0-1.0)*15.0*nl;\n  float z=(noise((p+sin(time+3.5)*2.0*l)*0.2)*2.0-1.0)*15.0*nl;\n  p+=vec3(x,y,z);\n  return max((noise(p*scale)+noise(p*2.0*scale)*0.5+\n              noise(p*3.0*scale)*0.33+\n              noise(p*4.0*scale)*0.25)*0.4807-(l*l*l*l),0.0);\n}\n  \nfloat flow(vec3 p,float scale){\n  float l=length(p-vec3(0,-20,0));\n  return mix(sin(l-time*10.0)+cos(l-time*10.0),\n             0.0,\n             min(1.0-(100.0-l)*0.01,1.0));\n}\nfloat map(vec3 p){\n  return sphere(p,vec3(0.0,0.0,0.0),20.0);\n  }\n  \nfloat map2(vec3 p){\n  return sphere(p,vec3(0.0,0.0,0.0),10.0);\n  }\n \nfloat mapHyper(vec3 p){\n  return fire(p,vec3(0.0,0.0,0.0),0.3,20.0);\n  }  \n\n  \nfloat dot2(  vec3 v ) { return dot(v,v); }\n\nfloat udQuad( vec3 p, vec3 a, vec3 b, vec3 c, vec3 d )\n{\n    \n    vec3 ba = b - a; vec3 pa = p - a;\n    vec3 cb = c - b; vec3 pb = p - b;\n    vec3 dc = d - c; vec3 pc = p - c;\n    vec3 ad = a - d; vec3 pd = p - d;\n    vec3 nor = cross( ba, ad );\n\n    return sqrt(\n    (sign(dot(cross(ba,nor),pa)) +\n     sign(dot(cross(cb,nor),pb)) +\n     sign(dot(cross(dc,nor),pc)) +\n     sign(dot(cross(ad,nor),pd))<3.0)\n     ?\n     min( min( min(\n     dot2(ba*clamp(dot(ba,pa)/dot2(ba),0.0,1.0)-pa),\n     dot2(cb*clamp(dot(cb,pb)/dot2(cb),0.0,1.0)-pb) ),\n     dot2(dc*clamp(dot(dc,pc)/dot2(dc),0.0,1.0)-pc) ),\n     dot2(ad*clamp(dot(ad,pd)/dot2(ad),0.0,1.0)-pd) )\n     :\n     dot(nor,pa)*dot(nor,pa)/dot2(nor) );\n}\n\nfloat map3(vec3 p){\nreturn udQuad(p,\n              vec3(10000, 20.0, 10000.0),\n              vec3(-10000.0, 20.1, 10000.0), \n              vec3(-10000.0, 20.0, -10000.0),\n              vec3(10000.0, 20.0, -10000.0));\n  }\n  \nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n  vec2 uv = vec2(fragCoord.x / iResolution.x, fragCoord.y / iResolution.y);\n  uv -= 0.5;\n  uv /= vec2(iResolution.y / iResolution.x, 1);\n  vec3 s=vec3(0,0,-100);\n  float t2=(time*0.5+10.0);\n  s.y = -abs(cos(t2*0.1)*100.0);\n  s.xz *= rot(t2*0.1);\n \n  vec3 t=vec3(0,0,0);\n  vec3 cz=normalize(t-s);\n  vec3 cx=normalize(cross(cz,vec3(0,1,0)));\n  vec3 cy=normalize(cross(cz,cx));\n  vec3 r=normalize(uv.x*cx+uv.y*cy+cz*0.7);\n  \n// real fireball/////////////////////////\n  vec3 p=s;\n  float dd=0.0;\n  for(int i=0; i<60; ++i) {\n    float d=map(p);\n    if(d<0.0001) break;\n    if(dd>500.0) {dd=500.0; break;}\n    p+=d*r*0.8;\n    dd+=d;\n  }\n  \n  vec2 c= vec2(0,0);\n  for(int i=0; i<400; ++i) {\n    float d=map(p);\n    float d2=map2(p);\n    c+=vec2(mapHyper(p)*0.018,0);\n    c.y=1.0;\n    if(dd>=500.0) {dd=500.0;c.y=0.0; break;}\n    if( d2<0.001 ){c.x+=0.5;c.y=2.0;break;}\n    if( d>0.001 ){ break;}\n    p+=r*(0.1);\n    dd+=0.1;\n  }\n  \n  //////////////////////////////////////////////////////////////////////////////////////////////\n  \n  //water\n  p=s;\n  dd=0.0;\n  int hit = 1;\n  for(int i=0; i<60; ++i) {\n    float d=map3(p);\n    if(d<0.0001) break;\n    if(dd>500.0) {dd=500.0;hit =0; break;}\n    p+=d*r*0.8;\n    dd+=d;\n  }\n  // reflection on the water\n  vec2 off=vec2(0.01,0);\n  p.y=p.y+flow( p,0.1)*2.0;\n  vec3 n=normalize(map3(p)-vec3(map3(p-off.xyy), map3(p-off.yxy), map3(p-off.yyx)));\n  if(hit==1){r=reflect(p-s,n);s=p-r;r=normalize(r);}\n    \n  p=s;\n  dd=0.0;\n  for(int i=0; i<60; ++i) {\n    float d=map(p);\n    if(d<0.0001) break;\n    if(dd>500.0) {dd=500.0; break;}\n    p+=d*r*0.8;\n    dd+=d;\n  }\n  \n  //sky\n  float dotr=(dot(r,normalize(vec3(0,-1,1))));\n    \n  vec3 sky = mix(vec3(0.2,0.1,0.1),\n                 vec3(0.1,0.1,0.2),\n                 min(dotr+0.2,1.0));\n    \n  vec3 star=vec3(dot(r,normalize(vec3(1.0,0.0,0.0))),\n                 dot(r,normalize(vec3(0.0,1.0,0.0))),\n                 dot(r,normalize(vec3(0.0,0.0,1.0))));\n    \n  float starPoint=noise(star*200.0)*30.0;\n    \n  vec3 b = mix(vec3(1.0,1.0,0.5),\n               sky,\n               min(starPoint+0.2,1.0));\n  \n  // fire ball reflection\n  vec2 c2= vec2(0,0);\n  if(hit==1){\n    for(int i=0; i<400; ++i) {  \n      float d2=map2(p);\n      c2+=vec2(mapHyper(p)*0.018,0);\n      c2.y=1.0;\n      if(dd>=500.0) {dd=500.0;c2.y=0.0; break;}\n      if( d2<0.001 ){c2.x+=0.5;c2.y=2.0;break;}\n      p+=r*(0.1);\n      dd+=0.1;\n      }\n  }\n  \n  //compositing\n  vec3 col=vec3(0.0);\n  if(c.y==1.0)col = mix(vec3(1.0,0.0,0.0),vec3(1.0,1.0,0.0),c.x);\n  if(c.y==2.0)col = mix(vec3(1.0,0.0,0.0),vec3(1.0,1.0,0.0),c.x);\n \n  vec3 col2=vec3(0.0);\n  if(c2.y==1.0) col2 = mix(vec3(1.0,0.0,0.0),vec3(1.0,1.0,0.0),c2.x);\n  if(c2.y==2.0) col2 = mix(vec3(1.0,0.0,0.0),vec3(1.0,1.0,0.0),c2.x);\n  if(c2.y==0.0) col2 = b;\n  else{\n    if(c2.y!=2.0)col2 = mix(b,col2,c2.x);\n  }\n  if(c.y==0.0)col = col2;\n  else {\n    if(c.y!=2.0)col = mix(col2,col,c.x);\n  }\n  \n  fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3tXGR8.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[21, 21, 45, 45, 77], [79, 79, 101, 101, 392], [394, 472, 494, 494, 1559], [1561, 1561, 1580, 1580, 1649], [1651, 1651, 1707, 1707, 1747], [1749, 1749, 1813, 1813, 2252], [2256, 2256, 2287, 2287, 2433], [2434, 2434, 2452, 2452, 2499], [2503, 2503, 2522, 2522, 2569], [2572, 2572, 2595, 2595, 2644], [2651, 2651, 2674, 2674, 2693], [2695, 2695, 2751, 2751, 3396], [3398, 3398, 3417, 3417, 3618], [3622, 3622, 3677, 3677, 6606]], "test": "timeout"}
{"id": "3tXGW4", "name": "Stretching", "author": "jblanper", "description": "Simple sketch of moving ripples.", "tags": ["2d", "ripples", "abstract"], "likes": 9, "viewed": 196, "published": "Public", "date": "1556273277", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord.xy - .5 * iResolution.xy) / iResolution.y;\n\n  \tfloat l = length(uv);\n  \tuv += cos(iTime * .12) * .6; //  * .1\n\n    vec3 color = vec3(0.);\n  \tcolor += cos(dot(uv, vec2(l, l)) * 40. + iTime * .8) * .5;\n  \tcolor *= sin(length(vec2(uv.y, uv.x)) * 20. + iTime * .5) * .3;\n\n  \tcolor += 1. - l * 1.5;\n  \tcolor += vec3(l, uv.y, uv.x) * .5;\n\n  \tfragColor = vec4(color, 1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3tXGW4.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 449]], "test": "ok"}
{"id": "3tXGzN", "name": "Polar Julia Set", "author": "Tezza48", "description": "I wanted to know what happened... This happens.", "tags": ["fractal", "julia", "mandelbrot", "polar"], "likes": 1, "viewed": 64, "published": "Public", "date": "1555707466", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define JULIA\n#define SMOOTHFRACT\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy * 2.0 - 1.0;\n    uv.y /= iResolution.x / iResolution.y;\n\t\n    \n    vec2 puv;\n    puv.x = atan(uv.y / uv.x);\n    puv.y = length(uv);\n    \n    uv = puv;\n    \n    \n    vec2 fuv = uv;\n    \n    #ifndef JULIA\n    fuv.x -= 0.25;\n    #endif\n    \n    fuv *= 1.5;\n    \n    #ifdef JULIA\n    vec2 z = fuv;\n    vec2 c = vec2(sin(iTime * 0.5) * 0.8, cos((iTime * 0.1 + sin(iTime * 0.21)) * 0.5));\n    #else\n    vec2 z = vec2(0);\n    vec2 c = fuv;\n    #endif\n    float i;\n    float zdz;\n    for (i = 0.0; i < 20.0; i++)\n    {\n\t\tz= vec2(z.x * z.x - z.y * z.y, 2.0 * z.x * z.y) + c;\n        zdz = dot(z, z);\n        if (zdz > 4.0)\n            break;\n    }\n    \n    #ifdef SMOOTHFRACT\n    float log2=0.69314718056;\n    float L = log(zdz)/2.0;\n    float nu = log(L/log2)/log2;\n    i+=1.0-nu;\n    #endif\n    \n    float dist = float(i) / 20.0;\n    \n    fragColor = vec4(dist);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3tXGzN.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[35, 35, 92, 92, 989]], "test": "ok"}
{"id": "4lXcD7", "name": "Color Stretch", "author": "KilledByAPixel", "description": "Horizontal colored lines that stretch out into infinity. Notice, they are not stretching from the center, but from everywhere. Strangely terrifying!", "tags": ["fractal", "zoom", "recursion"], "likes": 9, "viewed": 178, "published": "Public", "date": "1554223729", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//////////////////////////////////////////////////////////////////////////////////\n// Color Stretch - Copyright 2019 Frank Force\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n//////////////////////////////////////////////////////////////////////////////////\n\nconst float zoomSpeed\t\t\t= .5;\t// how fast to zoom (negative to zoom out)\nconst float zoomScale\t\t\t= 0.1;\t// how much to multiply overall zoom (closer to zero zooms in)\nconst int recursionCount\t\t= 6;\t// how deep to recurse\nconst int glyphSize\t\t\t\t= 3;\t// width & height of glyph in pixels\nconst float curvature\t\t\t= 0.0;\t// time warp to add curvature\n\n//////////////////////////////////////////////////////////////////////////////////\n// Precached values and math\n\nconst float glyphSizeF = float(glyphSize);\nconst float glyphSizeLog = log(glyphSizeF);\nconst float e = 2.718281828459;\nconst float pi = 3.14159265359;\n\nfloat RandFloat(int i) { return (fract(sin(float(i)) * 43758.5453)); }\nint RandInt(int i) { return int(100000.0*RandFloat(i)); }\n\nvec3 HsvToRgb(vec3 c) \n{\n    float s = c.y * c.z;\n    float s_n = c.z - s * .5;\n    return vec3(s_n) + vec3(s) * cos(2.0 * pi * (c.x + vec3(1.0, 0.6666, .3333)));\n}\n\n//////////////////////////////////////////////////////////////////////////////////\n// Color and image manipulation\n\nfloat GetRecursionFade(int r, float timePercent)\n{\n    if (r > recursionCount)\n        return timePercent;\n    \n    // fade in and out recusion\n    float rt = max(float(r) - timePercent, 0.0);\n    float rc = float(recursionCount);\n    return rt / rc;\n}\n\nvec3 InitPixelColor() { return vec3(0, .5, .5); }\nvec3 CombinePixelColor(vec3 color, float timePercent, int i, int r, vec2 pos, ivec2 glyphPos, ivec2 glyphPosLast)\n{\n    i = (i+r) + (glyphPosLast.y + glyphPos.y);\n    //i+=glyphPosLast.x + glyphPos.x;\n\n    vec3 myColor = vec3\n    (\n    \tmix(-0.2, 0.2, RandFloat(i)),\n    \tmix(-0.2, 0.2, RandFloat(i + 10)),\n        mix(-0.2, 0.2, RandFloat(i + 20))\n    );\n\n    // combine with my color\n    float f = GetRecursionFade(r, timePercent);\n    color += myColor*f;\n    return color;\n}\n\nvec3 FinishPixel(vec3 color, vec2 uv)\n{\n    // color wander\n    color.x += 0.03*iTime;\n    \n    // convert to rgb\n    color = HsvToRgb(color);\n    return color;\n}\n\nvec2 InitUV(vec2 uv)\n{\n   //v.y += 1.0;\n\t// wave\n\t//uv.x += 0.04*sin(10.0*uv.y + 0.17*iTime);\n\t//uv.y += 0.04*sin(10.0*uv.x + 0.13*iTime);\n\t//uv.x += 0.2*sin(2.0*uv.y + 0.31*iTime);\n\t//uv.y += 0.2*sin(2.0*uv.x + 0.27*iTime);\n    \n    // spin\n    //float theta = 0.0;//pi/2.0;//0.05*iTime;\n\t//float c = cos(theta);\n\t//float s = sin(theta);\n\t//uv = vec2((uv.x*c - uv.y*s), (uv.x*s + uv.y*c));\n    \n    return uv;\n}\n\n//////////////////////////////////////////////////////////////////////////////////\n// Fractal functions\n\nivec2 GetFocusPos(int i) { return ivec2(glyphSize/2); }\n      \n// get color of pos, where pos is 0-1 point in the glyph\nvec3 GetPixelFractal(vec2 pos, int iterations, float timePercent)\n{\n\tivec2 glyphPosLast = GetFocusPos(-2);\n\tivec2 glyphPos =     GetFocusPos(-1);\n\tvec3 color = InitPixelColor();\n    \n\tfor (int r = 0; r <= recursionCount + 1; ++r)\n\t{\n        color = CombinePixelColor(color, timePercent, iterations, r, pos, glyphPos, glyphPosLast);\n        if (r > recursionCount)\n\t\t\treturn color;\n           \n        // update pos\n        pos *= glyphSizeF;\n\n        // get glyph and pos within that glyph\n        glyphPosLast = glyphPos;\n        glyphPos = ivec2(pos);\n        \n        // next glyph\n\t\tpos -= vec2(floor(pos));\n\t}\n}\n \n//////////////////////////////////////////////////////////////////////////////////\n\t\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\t// use square aspect ratio\n\tvec2 uv = fragCoord;\n\tuv = fragCoord / iResolution.y;\n\tuv -= vec2(0.5*iResolution.x / iResolution.y, 0.5);\n    uv = InitUV(uv);\n    \n    // time warp\n    float time = iTime + curvature*pow(length(uv), 0.2);\n    \n    // time warp to add add some 3d curve\n    //float c1 = 0.5*sin(0.3*iTime);\n    //float c2 = 0.5*sin(0.23*iTime);\n    //time += curvature*(c1*length(uv) + c2*uv.x*uv.y)*zoomSpeed;\n    \n\t// get time \n\tfloat timePercent = time*zoomSpeed;\n\tint iterations = int(floor(timePercent));\n\ttimePercent -= float(iterations);\n\t\n\t// update zoom, apply pow to make rate constant\n\tfloat zoom = pow(e, -glyphSizeLog*timePercent);\n\tzoom *= zoomScale;\n    \n\t// get offset\n\tvec2 offset = vec2(0);\n    const float gsfi = 1.0 / glyphSizeF;\n\tfor (int i = 0; i < 13; ++i)\n\t\toffset += (vec2(GetFocusPos(i)) * gsfi) * pow(gsfi,float(i));\n    \n\t// apply zoom & offset\n    vec2 uvFractal = uv * zoom + offset;\n\t\n\t// check pixel recursion depth\n\tvec3 pixelFractalColor = GetPixelFractal(uvFractal, iterations, timePercent);\n    //pixelFractalColor.y = pow(pixelFractalColor.y, 2.);\n    //pixelFractalColor.z = pow(pixelFractalColor.z, 2.);\n    pixelFractalColor = FinishPixel(pixelFractalColor, uv);\n    \n\t// apply final color\n\tfragColor = vec4(pixelFractalColor, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4lXcD7.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[913, 913, 937, 937, 983], [984, 984, 1004, 1004, 1041], [1043, 1043, 1067, 1067, 1207], [1325, 1325, 1375, 1375, 1577], [1579, 1579, 1602, 1602, 1628], [1629, 1629, 1744, 1744, 2106], [2108, 2108, 2147, 2167, 2270], [2272, 2272, 2294, 2662, 2684], [2791, 2791, 2817, 2817, 2846], [2854, 2911, 2978, 2978, 3527], [3615, 3615, 3672, 3700, 4960]], "test": "error"}
{"id": "4t2cR1", "name": "♫ Sailing Beyond - Hyper Tunnel", "author": "patu", "description": "This is the aggressive version of tunnel from my PC intro \"Sailing Beyond\".\nMusic used here is \"Xara\" by Effect (https://soundcloud.com/neurofunksocietyofpoland/effect-xara-clip)\n", "tags": ["tunnel", "demoscene"], "likes": 152, "viewed": 9224, "published": "Public API", "date": "1554750790", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/* \n\n    Hyper Tunnel from \"Sailing Beyond\" (demoscene producion)\n\t\n    https://www.youtube.com/watch?v=oITx9xMrAcM&\n\thttps://www.pouet.net/prod.php?which=77899\n\n\n*/\n\n\n/*\n\thttp://bit.ly/shadertoy-plugin\n*/\n\n\n\n\n\n#pragma optimize(off)\n\n\n\n\n\n#define getNormal getNormalHex\n\n#define FAR 1e3\n#define INFINITY 1e32\n\n#define T iTime\n#define mt (iChannelTime[0] > 0. ? iChannelTime[0] : iTime)\n#define FOV 70.0\n#define FOG .06\n\n#define PI 3.14159265\n#define TAU (2*PI)\n#define PHI (1.618033988749895)\n\nfloat vol = 0.;\n\nfloat hash12(vec2 p) {\n\tfloat h = dot(p,vec2(127.1,311.7));\t\n    return fract(sin(h)*43758.5453123);\n}\n\n// 3d noise\nfloat noise_3(in vec3 p) {\n    vec3 i = floor(p);\n    vec3 f = fract(p);\t\n\tvec3 u = 1.-(--f)*f*f*f*-f;\n    \n    vec2 ii = i.xy + i.z * vec2(5.0);\n    float a = hash12( ii + vec2(0.0,0.0) );\n\tfloat b = hash12( ii + vec2(1.0,0.0) );    \n    float c = hash12( ii + vec2(0.0,1.0) );\n\tfloat d = hash12( ii + vec2(1.0,1.0) ); \n    float v1 = mix(mix(a,b,u.x), mix(c,d,u.x), u.y);\n    \n    ii += vec2(5.0);\n    a = hash12( ii + vec2(0.0,0.0) );\n\tb = hash12( ii + vec2(1.0,0.0) );    \n    c = hash12( ii + vec2(0.0,1.0) );\n\td = hash12( ii + vec2(1.0,1.0) );\n    float v2 = mix(mix(a,b,u.x), mix(c,d,u.x), u.y);\n        \n    return max(mix(v1,v2,u.z),0.);\n}\n\nfloat fbm(vec3 x)\n{\n    float r = 0.0;\n    float w = 1.0, s = 1.0;\n    for (int i=0; i<4; i++)\n    {\n        w *= 0.25;\n        s *= 3.;\n        r += w * noise_3(s * x);\n    }\n    return r;\n}\n \nfloat yC(float x) {\n \treturn cos(x * -.134) * 1. * sin(x * .13) * 15.+ fbm(vec3(x * .1, 0., 0.) * 55.4);\n}\n\nvoid pR(inout vec2 p, float a) {\n\tp = cos(a)*p + sin(a)*vec2(p.y, -p.x);\n}\n\nstruct geometry {\n    float dist;\n    vec3 hit;\n    int iterations;\n};\n\n\n// Cylinder with infinite height\nfloat fCylinderInf(vec3 p, float r) {\n\treturn length(p.xz) - r;\n}\n\ngeometry map(vec3 p) {\n    p.x -= yC(p.y * .1) * 3.;\n    p.z += yC(p.y * .01) * 4.;\n    \n    float n = pow(abs(fbm(p * .06 )) * 12., 1.3);\n    float s = fbm(p * 0.01 + vec3(0., T * 0.14, 0.)) * 128.;\n    \n    geometry obj;\n\n    obj.dist = max(0., -fCylinderInf(p, s + 18. -n));\n    \n    p.x -= sin(p.y * .02) * 34. + cos(p.z * 0.01) * 62.;\n    \n    obj.dist = max(obj.dist, -fCylinderInf(p, s + 28. + n * 2.));\n    \n    return obj;\n}\n\n\nfloat t_min = 10.0;\nfloat t_max = FAR;\nconst int MAX_ITERATIONS = 100;\n\ngeometry trace(vec3 o, vec3 d) {\n    float omega = 1.3;\n    float t = t_min;\n    float candidate_error = INFINITY;\n    float candidate_t = t_min;\n    float previousRadius = 0.;\n    float stepLength = 0.;\n    float pixelRadius = 1./ 1000.;\n    \n    geometry mp = map(o);\n\n    float functionSign = mp.dist < 0. ? -1. : +1.;\n    float minDist = FAR;\n    \n    for (int i = 0; i < MAX_ITERATIONS; ++i) {\n\n        mp = map(d * t + o);\n\t\tmp.iterations = i;\n    \n        float signedRadius = functionSign * mp.dist;\n        float radius = abs(signedRadius);\n        bool sorFail = omega > 1. &&\n        \t(radius + previousRadius) < stepLength;\n        \n        if (sorFail) {\n            stepLength -= omega * stepLength;\n            omega = 1.;\n        } else {\n        \tstepLength = signedRadius * omega;\n        }\n        previousRadius = radius;\n        float error = radius / t;\n        \n        if (!sorFail && error < candidate_error) {\n            candidate_t = t;\n            candidate_error = error;\n        }\n        \n        if (!sorFail && error < pixelRadius || t > t_max) break;\n        \n        t += stepLength * .5; // ;(\n   \t}\n    \n    mp.dist = candidate_t;\n    \n    if (\n        (t > t_max || candidate_error > pixelRadius)\n    \t) mp.dist = INFINITY;\n    \n    \n    return mp;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    \n    vec2 ouv = fragCoord.xy / iResolution.xy;\n    vec2 uv = ouv - .5;\n\n    uv *= tan(radians (FOV) / 2.0) * 4.;\n    \n    vec3 \n        vuv = normalize(vec3(cos(T), sin(T * .11), sin(T * .41))), // up\n    \tro = vec3(0., 30. + iTime * 100., -.1);\n\n    ro.x += yC(ro.y * .1) * 3.;\n    ro.z -= yC(ro.y * .01) * 4.;\n    \n    vec3 vrp =  vec3(0., 50. + iTime * 100., 2.);\n    \n    vrp.x += yC(vrp.y * .1) * 3.;\n    vrp.z -= yC(vrp.y * .01) * 4.;\n    \n    vec3\n\t\tvpn = normalize(vrp - ro),\n    \tu = normalize(cross(vuv, vpn)),\n    \tv = cross(vpn, u),\n    \tvcv = (ro + vpn),\n    \tscrCoord = (vcv + uv.x * u * iResolution.x/iResolution.y + uv.y * v),\n    \trd = normalize(scrCoord - ro),\n        oro = ro;\n\t\n    vec3 sceneColor = vec3(0.);\n\n    geometry tr = trace(ro, rd);\n    \n    tr.hit = ro + rd * tr.dist;\n    \n    vec3 col = vec3(1., 0.5, .4) * fbm(tr.hit.xzy * .01) * 20.;\n    col.b *= fbm(tr.hit * .01) * 10.;  \n    \n    sceneColor += min(.8, float(tr.iterations) / 90.) * col + col * .03;\n    sceneColor *= 1. + .9 * (abs(fbm(tr.hit * .002 + 3.) * 10.) * (fbm(vec3(0.,0.,iTime * .05) * 2.)) * 1.);\n    sceneColor = pow(sceneColor, vec3(1.)) * (iChannelTime[0] > 0. ? texelFetch(iChannel0, ivec2(128, 0), 0).r * min(1., mt * .1) : 0.6);\n    \n    vec3 steamColor1 = vec3(.0, .4, .5);\n\tvec3 rro = oro;\n    \n    ro = tr.hit;\n\n    float distC = tr.dist, f = 0., st = .9;\n    \n    for (float i = 0.; i < 24.; i++) {       \n        rro = ro - rd * distC;\n        f += fbm(rro * vec3(.1, .1, .1) * .3) * .1;\n        distC -= 3.;\n        if (distC < 3.) break;\n    }\n \n    steamColor1 *= iChannelTime[0] > 0. ? texelFetch(iChannel0, ivec2(32, 0), 0).r : 1.;\n    sceneColor += steamColor1 * pow(abs(f * 1.5), 3.) * 4.;\n    \n    fragColor = vec4(clamp(sceneColor * (1. - length(uv) / 2.), 0.0, 1.0), 1.0);\n    fragColor = pow(abs(fragColor / tr.dist * 130.), vec4(.8));\n    \n}\n", "image_inputs": [{"id": "llf3D7", "previewfilepath": "https://soundcloud.com/neurofunksocietyofpoland/effect-xara-clip", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0, "src": "https://soundcloud.com/neurofunksocietyofpoland/effect-xara-clip", "ctype": "musicstream"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4t2cR1.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[510, 510, 532, 532, 612], [614, 626, 652, 652, 1274], [1276, 1276, 1295, 1295, 1467], [1470, 1470, 1489, 1489, 1576], [1578, 1578, 1610, 1610, 1652], [1727, 1760, 1797, 1797, 1825], [1827, 1827, 1849, 1849, 2260], [2335, 2335, 2367, 2367, 3624], [3626, 3626, 3681, 3681, 5551]], "test": "error"}
{"id": "llc3Ws", "name": "Fractal Screen", "author": "Yusef28", "description": "Last one for today. Another thing I didn't get around to uploaded.", "tags": ["fractal"], "likes": 4, "viewed": 138, "published": "Public", "date": "1555373271", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n   vec2 st = uv;\n    st=st*2.-1.;\n     st.x *= iResolution.x/iResolution.y;\n\t;\n    //st += vec2(.0);\n    vec3 re ;\n    //st*=1.;\n    \n    \n    vec3 color;//vec3(1.);\n    int s;\n    \n    st/=1.328;\n    st/=10.;\n    for(int i= 0;i<19;i++)\n    {\n        //st/=2.;\n        st*=abs(sin(0.848 + sin(iTime)/30. ));\n\t\tst=fract(st)-0.5;\n        \n    \tcolor += 0.2*(sin(vec3(0.400,0.114,0.064) +  (  1./pow(1.0-smoothstep(0.4, 0.82 , length(st)), 10.)*1. - (1.0-smoothstep(0.36, 0.38 , length(st))) + float(i)*800.*sin(iTime/1000.)  )  )    );\n    \tst*=2.;\n       // s = i/int(re);\n       // color=sqrt(color);\n    }\n    \n\tfragColor = vec4(color,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/llc3Ws.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 743]], "test": "ok"}
{"id": "MlyBR1", "name": "Eyeball circle -Beginner-", "author": "LeBurgold", "description": "Hey there! Total GLSL beginner here. Trying to get into it and any feedback is welcome!", "tags": ["eye", "minimal", "eyeball"], "likes": 3, "viewed": 374, "published": "Public API", "date": "1554408580", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float Circle(vec2 uv, float radius, vec2 offset, float blur)\n{  \n   float distance = length(uv-offset);\n   return smoothstep(radius, radius - blur, distance);\n}\n\nvec2 getUV(vec2 fragCoord)\n{\n   vec2 uv = fragCoord.xy / iResolution.xy;\n   uv -= .5;\n   uv.x *= iResolution.x / iResolution.y;\n   return uv;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   vec3 red = vec3(1.,0.,0.);\n   vec3 white = vec3(1.);\n   vec3 black = vec3(0);\n   vec3 grey = vec3(.65);\n   vec3 darkred = vec3(.9,0.,0.);\n   vec3 pink = vec3(1.,.25,.5);\n   vec3 turqoise = vec3(.3,1.,1.);\n   vec3 yellow = vec3(1.,1.,0);\n  \n   vec2 uv = getUV(fragCoord);\n    \n   float eyeball = Circle(uv, .5, cos (iTime) * vec2(.05), 0.2);\n   float iris = Circle(uv, .3, cos(iTime) * vec2(.12), 0.05);\n   float pupil = Circle(uv, .1, cos(iTime) * vec2(.15), 0.01);\n   \n   float shadeE = Circle(uv, .5, vec2(0), 0.01);\n    \n   float shadeI = Circle(uv, .3, cos(iTime) * vec2(.1), 0.01);\n    \n   float reflex = Circle(uv, .2, cos(iTime) * vec2(.12) + vec2(-.1,.1), 0.3);\n   float reflex2 = Circle(uv, .06, cos(iTime) * vec2(.12) + vec2(.1,-.1), 0.08);\n    \n   float base1 = Circle(uv, .7, vec2(0), 0.01);\n   float base2 = Circle(uv, .9, vec2(0), 0.01);\n   float base3 = Circle(uv, 1.1, vec2(0), 0.01);\n    \n   float baseshadow = Circle(uv, .55, vec2(0.), 0.1);\n   \n   pupil = pupil - reflex - reflex2;\n   iris = iris - pupil - reflex - reflex2;\n   shadeI = shadeI - iris - reflex - reflex2;\n   eyeball = eyeball - shadeI - iris - pupil - reflex - reflex2; \n   shadeE = shadeE - eyeball - shadeI - iris - pupil - reflex - reflex2;\n    \n   float eye = eyeball + shadeE + iris + shadeI + pupil + reflex + reflex2;  \n   \n   baseshadow = baseshadow - eye;\n   base1 = base1 - baseshadow - eye;\n   base2 = base2 - base1 - baseshadow - eye;\n   base3 = base3 - base2 - base1 - baseshadow - eye;\n       \n   vec3 shadeEC = shadeE * grey;\n   vec3 shadeIC = shadeI * darkred;\n   vec3 eyeballC = eyeball * white;\n   vec3 irisC = iris * red;\n   vec3 pupilC = pupil * black;\n   vec3 reflexC = reflex * white;\n    \n   vec3 base1C = base1 * pink;\n   vec3 base2C = base2 * turqoise;\n   vec3 base3C = base3 * yellow;\n    \n   vec3 baseshadowC = baseshadow * black;\n     \n   vec3 color = baseshadowC + base1C + base2C + base3C + eyeballC + irisC + pupilC + reflexC + shadeEC + shadeIC;\n    \n   fragColor = vec4(color, 1.);  \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MlyBR1.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 62, 62, 160], [162, 162, 190, 190, 305], [307, 307, 364, 364, 2371]], "test": "ok"}
{"id": "td2SDc", "name": "Glass jelly cubes", "author": "MacSlow", "description": "Experiment in doing raytrace-like things (esp. refractions) with raymarching.\nHere are some screencasts of variations from the original desktop-GL application:\n - https://www.youtube.com/watch?v=EbDHlJ3iMpI\n - https://www.youtube.com/watch?v=GEQWYh2sG", "tags": ["3d", "raymarch", "sdf", "refraction", "shadow", "raytrace", "materials", "glass"], "likes": 11, "viewed": 787, "published": "Public API", "date": "1555204455", "time_retrieved": "2021-10-01T00:00:00", "image_code": "////////////////////////////////////////////////////////////////////////////////\n//\n// Glass jelly cubes - Experiment in doing more raytrace-y things with\n// raymarching. Share and enjoy!\n//\n// Copyright 2019 Mirco Müller\n//\n// Author(s):\n//   Mirco \"MacSlow\" Müller <macslow@gmail.com>\n//\n// This program is free software: you can redistribute it and/or modify it\n// under the terms of the GNU General Public License version 3, as published\n// by the Free Software Foundation.\n//\n// This program is distributed in the hope that it will be useful, but\n// WITHOUT ANY WARRANTY; without even the implied warranties of\n// MERCHANTABILITY, SATISFACTORY QUALITY, or FITNESS FOR A PARTICULAR\n// PURPOSE.  See the GNU General Public License for more details.\n//\n// You should have received a copy of the GNU General Public License along\n// with this program.  If not, see <http://www.gnu.org/licenses/>.\n//\n////////////////////////////////////////////////////////////////////////////////\n\nbool isInside = false;\n\nmat2 r2d (float deg) {\n\tfloat rad = radians (deg);\n\tfloat c = cos (rad);\n\tfloat s = sin (rad);\n\treturn mat2 (c,s,-s,c);\n}\n\nfloat smin (float d1, float d2, float k) {\n\tfloat h = clamp (.5 + .5*(d2 - d1)/k, .0, 1.);\n\treturn mix (d2, d1, h) - h*k*(1. - h);\n}\n\nfloat sdBox (in vec3 p, in vec3 size, in float r)\n{\n\tvec3 d = abs(p) - size;\n\treturn min (max (d.x, max (d.y,d.z)), .0) + length (max (d, .0)) - r;\n}\n\nfloat map (vec3 p, inout int id, inout vec3 pout) {\n\tfloat ground = p.y + 1.;\n\tfloat wall = p.z + 1.;\n\tvec3 pbox = p + vec3 (.0, -.4, -.2);\n\tpbox.xz *= r2d (14.*iTime);\n\tpbox.yz *= r2d (26.*iTime);\n\tfloat r = .75 + .1*(.5+.5*cos(4.*iTime + 9.*pbox.y));\n\tfloat box = sdBox (pbox, vec3 (.6), .05);\n\tp -= vec3 (2.5*cos (1.25*iTime), .75, .2);\n\tp.xz *= r2d (-60.*iTime);\n\tp.yz *= r2d (-90.*iTime);\n\tfloat ball = sdBox (p , vec3 (.4), .05);\n\tbox = (isInside? -1. : 1.)*smin (box, ball, .5);\n\tfloat d = min (ground, min (wall, box));\n\tif (d == ground) {id = 1; pout = p;}\n\tif (d == wall) {id = 2; pout = p;}\n\tif (d == box) {id = 3; pout = p;}\n    return d;\n}\n\nfloat march (vec3 ro, vec3 rd, inout int id, inout vec3 pout)\n{\n\tfloat t = .0;\n\tfloat d = .0;\n\tfor (int i = 0; i< 48; ++i) {\n\t\tvec3 p = ro+d*rd;\n\t\tt = map (p, id, pout);\n\t\tif (abs (t) < .00001*(1. + .125*t)) break;\n\t\td += t*.75;\n\t}\n\treturn d;\n}\n\nvec3 norm (vec3 p){\n\tint foo;\n\tvec3 bar;\n\tfloat d = map (p, foo, bar);\n\tvec2 e = vec2 (.001, .0);\n\treturn normalize (vec3 (map (p+e.xyy, foo, bar),\n                            map (p+e.yxy, foo, bar),\n                            map (p+e.yyx, foo, bar))-d);\n}\n\nfloat sha (vec3 p, vec3 lp, vec3 n, vec3 ldir) {\n\tfloat d2l = distance (lp, p);\n\tint foo;\n\tvec3 bar;\n\tfloat d2w = march (p+.01*n, ldir, foo, bar);\n\treturn d2l < d2w ? 1. : .1;\n}\n\nfloat ao (vec3 p, vec3 n, float stepsize, int iter, float i){\n\tfloat ao = .0;\n\tfloat dist = .0;\n\tint foo;\n\tvec3 bar;\n\tfor (int a = 1; a <= iter; ++a) {\n\t\tdist = float (a)*stepsize;\n\t\tao += max (.0, (dist - map (p+n*dist, foo, bar))/dist);\n\t}\n\treturn 1. - ao*i;\n}\n\nvec3 shade (vec3 ro,\n\t\t\tvec3 rd,\n\t\t\tfloat d,\n\t\t\tvec3 n,\n\t\t\tvec3 lp,\n\t\t\tvec3 lc,\n\t\t\tfloat li,\n\t\t\tint id,\n\t\t\tvec3 pout) {\n    vec3 p = ro + d*rd;\n\tfloat ld = distance (p, lp); \n\tvec3 ldir = normalize (lp - p);\n\tfloat att = 5. / (ld*ld);\n\tvec3 mat = vec3 (.2);\n\tif (id == 1) {\n\t\tmat = mix (vec3 (.0, .0, .0),\n\t\t\t\t   vec3 (.5, .5, .5),\n                   smoothstep(.4, .6, cos (5.*p.x) * sin(5.*p.z+5.*iTime)));\n\t}\n\tif (id == 2) {\n\t\tmat = mix (vec3 (.0, .0, .0),\n\t\t\t\t   vec3 (.5, .5, .5),\n\t\t\t\t   smoothstep (.0, .9, sin (25.*p.y + 12.*iTime)));\n\t}\n\tif (id == 3) {\n\t\tmat = vec3 (.9, .5, .2);\n\t}\n\tfloat s = sha (p, lp, n, ldir);\n\tfloat diff = max (.0, dot (n, ldir));\n\tvec3 h = normalize (-rd + ldir);\n\tfloat shiny = 100.;\n\tfloat lf = .0;\n\tfloat hf = .0;\n    float fac = 1.;\n    if (id == 1) {\n\t\tlf = texture (iChannel0, .5*p.xz+vec2 (.0, .5*iTime)).r;\n\t\thf = texture (iChannel0, 2.*p.xz+vec2 (.0, 2.*iTime)).r;\n\t\tfac = lf + hf;\n\t}\n    if (id == 2) {\n\t\tlf = texture (iChannel0, .5*p.xy+vec2(.0, .5*iTime)).r;\n\t\thf = texture (iChannel0, 2.*p.xy+vec2(.0, 2.*iTime)).r;\n\t\tfac = lf + hf;\n\t}\n\tshiny *= fac;\n\tfloat sp = pow (max (.0, dot (n, h)), shiny);\n\tvec3 am = vec3 (.05);\n\tfloat ao = ao (p, n, .1, 8, .1);\n\tao *= (isInside ? 1.25 : 1.);\n\t\n\treturn ao*att*s*(am + diff*lc*li*mat + sp*vec3 (1.));\n}\n\nvec3 cam (vec2 uv, vec3 ro, vec3 aim, float zoom) {\n\tvec3 f =normalize (aim - ro);\n\tvec3 wu = vec3 (.0, 1., .0);\n\tvec3 r = normalize (cross (wu, f));\n\tvec3 u = normalize (cross (f, r));\n\tvec3 c = ro + f*zoom;\n\treturn normalize (c + r*uv.x+u*uv.y - ro);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n\tvec2 uvRaw = fragCoord.xy/iResolution.xy;\n\tvec2 uv = uvRaw*2. - 1.;\n\tuv.x *= iResolution.x/iResolution.y;\n\tuv *= 1. + .25*length (uv);\n\n\tvec3 ro = vec3 (cos (iTime), 1. + .125*(.5+.5*cos(5.*iTime)), 2.5);\n\tvec3 rd = cam (uv, ro, vec3 (.0), 1.7);\n\tint id = 0;\n\tvec3 pout = vec3 (.0);\n\tisInside = false;\n\tfloat d = march (ro, rd, id, pout);\n\tvec3 p = ro + d*rd;\n\tvec3 n = norm (p);\n\tvec3 col = vec3 (.0);\n\n\tvec3  lp1 = vec3 (2., 1., 2.);\n\tvec3  lc1 = vec3 (.9, .8, .7);\n\tfloat li1 = 3.;\n\tvec3  lp2 = vec3 (.7, 3., .0);\n\tvec3  lc2 = vec3 (.2, .2, .9);\n\tfloat li2 = 6.;\n\tvec3  lp3 = vec3 (-2., 2., .5);\n\tvec3  lc3 = vec3 (.9, .3, .2);\n\tfloat li3 = 3.;\n\n\tfloat fac = 1.;\n\tif (id == 3) {\n\t\tfac = .025;\n\t}\n\n\tcol = fac*shade (ro, rd, d, n, lp1, lc1, li1, id, pout);\n\tcol += fac*shade (ro, rd, d, n, lp2, lc2, li2, id, pout);\n\tcol += fac*shade (ro, rd, d, n, lp3, lc3, li3, id, pout);\n\tif (id == 3) {\n\t\tn = normalize (n + texture (iChannel0, .125*p.xy).r);\n\t\tro = p - .05*n;\n\t\tfloat ior = .7;\n\t\trd = normalize (refract (rd, n, ior));\n\t\tisInside = true;\n\t\td = march (ro, rd, id, pout);\n\t\tp = ro + d*rd;\n\t\tn = norm (p);\n\t\tcol += shade (ro, rd, d, n, lp1, lc1, li1, id, pout);\n\t\tcol += shade (ro, rd, d, n, lp2, lc2, li2, id, pout);\n\t\tcol += shade (ro, rd, d, n, lp3, lc3, li3, id, pout);\n\n\t\tro = p - .01*n;\n\t\trd = normalize (refract (rd, n, ior));\n\t\tisInside = false;\n\t\td = march (ro, rd, id, pout);\n\t\tp = ro + d*rd;\n\t\tn = norm (p);\n\t\tcol += shade (ro, rd, d, n, lp1, lc1, li1, id, pout);\n\t\tcol += shade (ro, rd, d, n, lp2, lc2, li2, id, pout);\n\t\tcol += shade (ro, rd, d, n, lp3, lc3, li3, id, pout);\n\t}\n\n\tcol = col / (1. + col);\n\tcol *= 1. - .5*length(uvRaw*2.-1.);\n\tcol = pow (col, vec3 (1./2.2));\n\n    fragColor = vec4(col, 1.);\n}\n", "image_inputs": [{"id": "4sfGRn", "previewfilepath": "/media/ap/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/td2SDc.jpg", "access": "shaders20k", "license": "gpl-3.0", "functions": [[1008, 1008, 1030, 1030, 1129], [1131, 1131, 1173, 1173, 1263], [1265, 1265, 1316, 1316, 1414], [1416, 1416, 1467, 1467, 2068], [2070, 2070, 2133, 2133, 2314], [2316, 2316, 2335, 2335, 2575], [2577, 2577, 2625, 2625, 2754], [2756, 2756, 2817, 2817, 3018], [3020, 3020, 3139, 3139, 4310], [4312, 4312, 4363, 4363, 4566], [4568, 4568, 4625, 4625, 6350]], "test": "error"}
{"id": "td2SWy", "name": "Finals-7", "author": "jojo169", "description": "7", "tags": ["7"], "likes": 1, "viewed": 36, "published": "Public", "date": "1554891142", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float circle(vec2 uv,float distanceAa, float distanceAb,float ditanceBa,float distanceBb,float size)\n{\n    \n    float val = distance(uv, vec2(distanceAa, distanceAb)) * distance(uv, vec2(ditanceBa, distanceBb));\n    \n\tval = step(val, size);\n    \n    return val;\n}\n\nfloat rand(vec2 uv)\n{\n    return fract(sin(dot(uv, vec2(12.9898,78.233)))*1000.*iTime);\n\t//return fract(sin(dot(uv, iMouse.xy))*10000.);\n\t//return (fract(sin(dot(uv, vec2(12., 70.)))*100000.));\n    //return (fract(sin(dot(uv, vec2(12., 70.)))*43758.5453123));\n}\n\nvec2 hash( vec2 x )  // replace this by something better\n{\n    const vec2 k = vec2( 0.3183099, 0.3678794 );\n    x = x*k + k.yx;\n    return -1.0 + 2.0*fract( 16.0 * k*fract( x.x*x.y*(x.x+x.y)) );\n}\n\nfloat gnoise( in vec2 p )\n{\n    vec2 i = floor( p );\n    vec2 f = fract( p );\n\t\n\tvec2 u = f*f*(3.0-2.0*f);\n\n    return mix( mix( dot( hash( i + vec2(0.0,0.0) ), f - vec2(0.0,0.0) ), \n                     dot( hash( i + vec2(1.0,0.0) ), f - vec2(1.0,0.0) ), u.x),\n                mix( dot( hash( i + vec2(0.0,1.0) ), f - vec2(0.0,1.0) ), \n                     dot( hash( i + vec2(1.0,1.0) ), f - vec2(1.0,1.0) ), u.x), u.y);\n}\n\n// Simplex noise\nvec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec2 mod289(vec2 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec3 permute(vec3 x) { return mod289(((x*34.0)+1.0)*x); }\n\nfloat snoise(vec2 v) {\n    const vec4 C = vec4(0.211324865405187,  // (3.0-sqrt(3.0))/6.0\n                        0.366025403784439,  // 0.5*(sqrt(3.0)-1.0)\n                        -0.577350269189626,  // -1.0 + 2.0 * C.x\n                        0.024390243902439); // 1.0 / 41.0\n    vec2 i  = floor(v + dot(v, C.yy) );\n    vec2 x0 = v -   i + dot(i, C.xx);\n    vec2 i1;\n    i1 = (x0.x > x0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);\n    vec4 x12 = x0.xyxy + C.xxzz;\n    x12.xy -= i1;\n    i = mod289(i); // Avoid truncation effects in permutation\n    vec3 p = permute( permute( i.y + vec3(0.0, i1.y, 1.0 ))\n        + i.x + vec3(0.0, i1.x, 1.0 ));\n\n    vec3 m = max(0.5 - vec3(dot(x0,x0), dot(x12.xy,x12.xy), dot(x12.zw,x12.zw)), 0.0);\n    m = m*m ;\n    m = m*m ;\n    vec3 x = 2.0 * fract(p * C.www) - 1.0;\n    vec3 h = abs(x) - 0.5;\n    vec3 ox = floor(x + 0.5);\n    vec3 a0 = x - ox;\n    m *= 1.79284291400159 - 0.85373472095314 * ( a0*a0 + h*h );\n    vec3 g;\n    g.x  = a0.x  * x0.x  + h.x  * x0.y;\n    g.yz = a0.yz * x12.xz + h.yz * x12.yw;\n    return 130.0 * dot(m, g);\n}\n\nfloat noise(in vec2 st) {\n    vec2 i = floor(st);\n    vec2 f = fract(st);\n\n    // Four corners in 2D of a tile\n    float a = rand(i);\n    float b = rand(i + vec2(1.0, 0.0));\n    float c = rand(i + vec2(0.0, 1.0));\n    float d = rand(i + vec2(1.0, 1.0));\n\n    // Smooth Interpolation\n\n    // Cubic Hermine Curve.  Same as SmoothStep()\n    vec2 u = f*f*(3.0-2.0*f);\n    // u = smoothstep(0.,1.,f);\n\n    // Mix 4 coorners porcentages\n    return mix(a, b, u.x) + \n            (c - a)* u.y * (1.0 - u.x) + \n            (d - b) * u.x * u.y;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    \n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    vec3 orange = vec3((sin(iTime)+1.)/2.,(sin(iTime)+1.)/4.,0.);\n    vec3 red= vec3(.5,.0,.0);\n    vec3 blue= vec3(.0,.0,1.0);\n    vec3 green = vec3(.0,1.,0);\n    float ratio = iResolution.x/iResolution.y;\n    uv.x *= ratio;\n    \n\n \tvec2 shapePos = vec2(.5*ratio,.5);\n    float dist = distance(shapePos,uv)*2.;\n    vec3 yellow= vec3(.9,.9,.3);\n    uv -=shapePos;\n    vec3 black = vec3(0.,0.,0.);\n    float angle= atan(uv.y,uv.x);\n    float radius = cos(2.*angle+iTime);\n    radius = circle(uv,snoise(uv)*2.,gnoise(uv)*2.,.3,rand(uv)*.1,.4);\n    float cir = circle(uv,2.2,2.2,sin(iTime)+.3,.2,.4);\n    float value = 1.-step(radius,dist);\n    float value2 = 1.-step(cir,dist);\n   \n    vec3 val = mix(black,red, value);\n   \n\n    // Output to screen\n    fragColor = vec4(val,uv);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/td2SWy.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 102, 102, 263], [265, 265, 286, 286, 526], [528, 528, 586, 586, 724], [726, 726, 753, 753, 1151], [1153, 1170, 1191, 1191, 1238], [1239, 1239, 1260, 1260, 1307], [1308, 1308, 1330, 1330, 1365], [1367, 1367, 1389, 1389, 2437], [2439, 2439, 2464, 2464, 2975], [2978, 2978, 3035, 3095, 3914]], "test": "ok"}
{"id": "td2XRc", "name": "Evil Structure", "author": "zackpudil", "description": "spoopy spikes", "tags": ["raymarching", "ifs", "bump"], "likes": 13, "viewed": 401, "published": "Public API", "date": "1554617385", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// SPOOPINESS\n\nvec3 ro; // I'm saving the camera as a global variable, so I can use it in the de method.\n\n// simple 2d rotation matrix.\nmat2 rot(float a) {\n\tfloat s = sin(a);\n\tfloat c = cos(a);\n\t\n\treturn mat2(c, s, -s, c);\n}\n\n// changing the metric for measuring distance.\nfloat len(vec3 p, float l) {\n\tp = pow(abs(p), vec3(l));\t\n\treturn pow(p.x+p.y+p.z, 1.0/l);\n}\n\n// 2d varient of the change of metric formula.\nfloat len(vec2 p, float l) {\n\tp = pow(abs(p), vec2(l)); // if l is 2, this would be the good old sqrt(dot(p, p)) euclidean metric.\n\treturn pow(p.x+p.y, 1.0/l);\n}\n\n// The fuction we are iterating in our Iterating Function System.\nvec2 shape(vec3 p) {\n    // triangular prism as the purplish stuff.\n\tfloat a = len(p.xy, 1.0) - 1.0;\n\tfloat b = len(p.yz, 1.0) - 1.0;\n\t\n\tvec2 t = vec2(min(a, b), 1.0);\n\tvec2 s = vec2(len(p, 1.0) - 7.75, 2.0); // a octahedron as the black stuff.\n\t\n\treturn t.x < s.x ? t : s;\n}\n\nvec2 de(vec3 p) {\n\tvec4 q = vec4(p, 1);\n\t\n\tq.xyz -= 1.0; // this puts the center of the fractal back at the origin.\n    \n    // My favorite fract, a element of the kaliset, AbsBox fractal.\n\tfor(int i = 0; i < 5; i++) {\n\t\tq.xyz = abs(q.xyz + 1.0) - 1.0; // mirror\n\t\tq /= clamp(dot(q.xyz, q.xyz), 0.1, 1.0); // the abs(p)/dot(p, p) is basically the kaliset.\n\t\tq.xz *= rot(0.1 + float(i)*0.15); // do some rotations.\n\t\t\n\t\tq *= 2.0; // scales.\n\t}\n\t\t\n\tvec2 s = shape(q.xyz)/vec2(q.w, 1); // get the shape.\n    s.x = max(-length(p - ro) + 0.01, s.x); // use the camera position to carve out a small sphere around the camera, so collisions don't look so bad.\n    \n    return s;\n}\n\n// using a kaliset 2d fractal to modify the coords for a texture.\nvec3 tex(sampler2D s, vec2 p) {\n    for(int i = 0; i < 10; i++) {\n        p = abs(p)/dot(p, p) - vec2(0.2);\n    }\n    \n    return texture(iChannel0, p).rgb;\n}\n\n// Triplanar texture blending.  Thanks to one of the great wizards of ShaderToy: Shane.\nvec3 mat(vec3 p, vec3 n, sampler2D s) {\n    vec3 m = abs(n);\n    m /= dot(m, vec3(1));\n    \n    vec3 x = tex(s, p.yz);\n    vec3 y = tex(s, p.xz);\n    vec3 z = tex(s, p.xy);\n    \n    return (m.x*x*x + m.y*y*y + m.z*z*z);\n}\n\n// luminosity rbg.\nvec3 sgrey = vec3(0.299, 0.587, 0.114);\n\n// using a 3d texture add bump mapping to the surface.\nvec3 bump(vec3 p, vec3 n, sampler2D s) {\n    vec2 h = vec2(0.009, 0.0);\n    vec3 g = mat3(\n        mat(p - h.xyy, n, s),\n        mat(p - h.yxy, n, s),\n        mat(p - h.yyx, n, s))*sgrey;\n    \n    g = g - dot(mat(p, n, s), sgrey);\n    g -= n*dot(g, n);\n    \n    return normalize(n + 0.9*g);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\tvec2 uv = (fragCoord - 0.5*iResolution.xy)/iResolution.y;\n\t\n\tvec3 col, bg;\n\tcol = bg = vec3(0.04)*(1.0 - length(uv)); // small bit of vinetting.\n\t\n\tfloat at = iTime*0.1;\n    float a = 1.4;\n\t\n    // camera setup. ro = position, rd = ray we shoot at geometry.\n\tro = vec3(a*cos(at), 0.04, -a*sin(at));\n\tvec3 ww = normalize(vec3(0, 0, 0)-ro);\n\tvec3 uu = normalize(cross(vec3(0, 1, 0), ww));\n\tvec3 vv = normalize(cross(ww, uu));\n\tvec3 rd = normalize(mat3(uu, vv, ww)*vec3(uv, 0.5 + 0.5*smoothstep(-1.0, 1.0, cos(iTime*0.5)))); // FOV goes from 0.5 to 1 in interval.\n\t\n    // sphere tracing, main method of ray-marching.  Faster than constant step ray-marching.\n\tfloat t = 0.0, m = -1.0, mx = 50.0; // t = distance, m = material id, mx = max distance.\n\tfor(int i = 0; i < 200; i++) {\n\t\tvec2 d = de(ro + rd*t);\n\t\tif(d.x < 0.001 || t >= mx) break;\n\t\tt += d.x*0.5;\n\t\tm = d.y;\n\t}\n\t\n    // very dumb light direction.\n\tvec3 ld = normalize(vec3(0, 0.5, 0));\n\tvec2 h = vec2(0.001, 0.0); // used for calculating the gradient of the de function (normal).\n\t\n\tif(t < mx) {\n\t\tvec3 p = ro + rd*t; // get coord of position we hit.\n\t\tvec3 n = normalize(vec3( // calculate the gradient at that position and use that for normal.\n\t\t\tde(p + h.xyy).x - de(p - h.xyy).x,\n\t\t\tde(p + h.yxy).x - de(p - h.yxy).x,\n\t\t\tde(p + h.yyx).x - de(p - h.yyx).x));\n\t\t\n\t\tvec3 al = vec3(1); // albeido = color\n        float gloss = 10.0; // gloss map, used in specular value.\n        \n        if(m == 1.0) {\n            al = vec3(0.3, 0.0, 0.2)*mat(p*0.1, n, iChannel0); // the spikes have a purpilish color to them.\n            gloss = 64.0; // have a very sharp specular light.\n        } else if(m == 2.0) {\n            al = vec3(0.0); // the main body is black (only specular and fresnel terms add to the color).\n            gloss = 16.0; // shiny object\n        }\n            \n        n = bump(p, n, iChannel0); // bump the normal to get some cheap detail of the surface.\n\t\t\n        // ambient occlusion, using a wave packet to approximate distance from geometry from normal.\n\t\tfloat occ = exp2(-pow(max(0.0, 1.0 - de(p + n*(t/50.0)).x/(t/50.0)), 2.0));\n\t\tfloat dif = max(0.0, dot(ld, n)); // diffuse lighting.\n\t\t\n        // specular light.\n\t\tfloat spe = pow(max(0.0, dot(reflect(-ld, n), -rd)), gloss);\n\t\tfloat fre = pow(dot(rd, n) + 1.0, 2.0); // fresnel term (light reflecting of edge).\n\t\t\n\t\tcol = mix(occ*(al*(dif + 0.25) + vec3(0.4, 0.6, 0.8)*spe), al + 0.01, fre); // put it all together.\n\t}\n    \n    col *= 5.0;\n\t\n\tcol = mix(col, bg, 1.0 - exp(-0.2*t)); // add a bit of fog.\n\tfragColor = vec4(pow(col, vec3(0.45)), 1);\n}", "image_inputs": [{"id": "XdfGRn", "previewfilepath": "/media/ap/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/td2XRc.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[106, 136, 155, 155, 224], [226, 273, 301, 301, 364], [366, 413, 441, 441, 574], [576, 642, 662, 709, 917], [919, 919, 936, 936, 1591], [1593, 1659, 1690, 1690, 1817], [1819, 1907, 1946, 1946, 2128], [2190, 2245, 2285, 2285, 2537], [2539, 2539, 2596, 2596, 5183]], "test": "error"}
{"id": "td2XWK", "name": "first video of a black hole", "author": "semmais", "description": "//fork fromhttps://www.shadertoy.com/view/WdBXWV", "tags": ["blackhole", "nasa", "reproduction", "m87", "eventhorizon", "parody"], "likes": 8, "viewed": 277, "published": "Public", "date": "1554997346", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//fork https://www.shadertoy.com/view/WdBXWV\n#define f(a) exp( -10.* pow( length( U -.52*cos(a+vec2(0,33)) ) , 2. ) )\n#define time iTime\n\nvoid mainImage( out vec4 O, vec2 u )\n{\n    vec2  R = iResolution.xy,\n          U = ( u+u - R ) / R.y;\n    \n    O =   ( .5-.5*cos(-time+min(6.*length(U),6.3)) ) \n        * (    .7* vec4(1,.25,0,0)\n            + ( f(.65- time*.1 )+f(1.6 + time*.5)+f(2.8 + time) ) * vec4(.8,.8,.5,0) );\n  O *= O;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/td2XWK.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[138, 138, 176, 176, 433]], "test": "ok"}
{"id": "td2XWy", "name": "Finals6 - Dancing Birds", "author": "EmperorLem", "description": "dancing", "tags": ["dancing"], "likes": 1, "viewed": 49, "published": "Public", "date": "1554894044", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec3 red = vec3(0.8 ,0.0 ,0.0);\nvec3 white = vec3(1.0, 1.0, 1.0);\nvec3 yellow = vec3(0.9, 0.9, 0.3);\nvec3 blue = vec3(0.0, 0.2, 1.0);\nvec3 black = vec3(0.0, 0.0, 0.0);\nvec3 green = vec3(0.0, 1.0, 0.0);\n\nfloat rand(vec2 uv)\n{\n    //return fract(sin(dot(uv, vec2(12.9898,78.233)))*10000.*iTime);\n\t//return fract(sin(dot(uv, iMouse.xy))*10000.);\n\t//return (fract(sin(dot(uv, vec2(12., 70.)))*100000.));\n    return (fract(sin(dot(uv, vec2(12., 70.)))*43758.5453123));\n}\n\n// Value noise\nfloat noise(in vec2 st) {\n    vec2 i = floor(st);\n    vec2 f = fract(st);\n\n    // Four corners in 2D of a tile\n    float a = rand(i);\n    float b = rand(i + vec2(1.0, 0.0));\n    float c = rand(i + vec2(0.0, 1.0));\n    float d = rand(i + vec2(1.0, 1.0));\n\n    // Smooth Interpolation\n\n    // Cubic Hermine Curve.  Same as SmoothStep()\n    vec2 u = f*f*(3.0-2.0*f);\n    // u = smoothstep(0.,1.,f);\n\n    // Mix 4 coorners porcentages\n    return mix(a, b, u.x) + \n            (c - a)* u.y * (1.0 - u.x) + \n            (d - b) * u.x * u.y;\n}\n\n// Gradient noise\nvec2 hash( vec2 x )  // replace this by something better\n{\n    const vec2 k = vec2( 0.3183099, 0.3678794 );\n    x = x*k + k.yx;\n    return -1.0 + 2.0*fract( 16.0 * k*fract( x.x*x.y*(x.x+x.y)) );\n}\n\nfloat gnoise( in vec2 p )\n{\n    vec2 i = floor( p );\n    vec2 f = fract( p );\n\t\n\tvec2 u = f*f*(3.0-2.0*f);\n\n    return mix( mix( dot( hash( i + vec2(0.0,0.0) ), f - vec2(0.0,0.0) ), \n                     dot( hash( i + vec2(1.0,0.0) ), f - vec2(1.0,0.0) ), u.x),\n                mix( dot( hash( i + vec2(0.0,1.0) ), f - vec2(0.0,1.0) ), \n                     dot( hash( i + vec2(1.0,1.0) ), f - vec2(1.0,1.0) ), u.x), u.y);\n}\n\n// Simplex noise\nvec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec2 mod289(vec2 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec3 permute(vec3 x) { return mod289(((x*34.0)+1.0)*x); }\n\nfloat snoise(vec2 v) {\n    const vec4 C = vec4(0.211324865405187,  // (3.0-sqrt(3.0))/6.0\n                        0.366025403784439,  // 0.5*(sqrt(3.0)-1.0)\n                        -0.577350269189626,  // -1.0 + 2.0 * C.x\n                        0.024390243902439); // 1.0 / 41.0\n    vec2 i  = floor(v + dot(v, C.yy) );\n    vec2 x0 = v -   i + dot(i, C.xx);\n    vec2 i1;\n    i1 = (x0.x > x0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);\n    vec4 x12 = x0.xyxy + C.xxzz;\n    x12.xy -= i1;\n    i = mod289(i); // Avoid truncation effects in permutation\n    vec3 p = permute( permute( i.y + vec3(0.0, i1.y, 1.0 ))\n        + i.x + vec3(0.0, i1.x, 1.0 ));\n\n    vec3 m = max(0.5 - vec3(dot(x0,x0), dot(x12.xy,x12.xy), dot(x12.zw,x12.zw)), 0.0);\n    m = m*m ;\n    m = m*m ;\n    vec3 x = 2.0 * fract(p * C.www) - 1.0;\n    vec3 h = abs(x) - 0.5;\n    vec3 ox = floor(x + 0.5);\n    vec3 a0 = x - ox;\n    m *= 1.79284291400159 - 0.85373472095314 * ( a0*a0 + h*h );\n    vec3 g;\n    g.x  = a0.x  * x0.x  + h.x  * x0.y;\n    g.yz = a0.yz * x12.xz + h.yz * x12.yw;\n    return 130.0 * dot(m, g);\n}\n\n\nfloat bird(vec2 uv, vec2 pos, float r)\n{   \n    float dist = distance(pos, uv) * r;\n    float value = step(r, dist);\n    \n    uv -= pos;\n\n    float angle = (atan(uv.y, uv.x) - 4.7);\n    \n    float radius = abs(cos(angle * 1.0) * sin(angle * 3.0)) * sin(angle * 3.0) * 0.7 + 0.5;\n    \n    value = step(radius , dist);\n    \n    return value;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    float ratio = iResolution.x / iResolution.y;\n    uv.x *= iResolution.x/iResolution.y;\n    uv *= 3.0;\n    \n    float offset = mod(uv.x,2.)>1. ? -1. : 1.;\n    //float offset = step(1.,mod(uv.y,2.0));\n    //float offset2 = step(mod(uv.y,2.0), 1.);\n    \n\t//uv.x += offset * iTime * 2.0;\n\t\n    uv.x -= offset *iTime;\n    uv.y *= ratio;\n    \n    vec2 pos = vec2(0.5*ratio, 0.5);\n    \n    \n    uv = fract(uv);\n    uv -= pos ;\n   \t//uv *= rotate2d(tan(iTime * 3.0)  );\n    uv += pos;\n    //uv *= scale2d(vec2(1.0, 1.0)); \n\n    // Time varying pixel color\n    vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n    \n    float mBird = bird(uv, vec2(0.5, 0.5), 3.0);\n    vec3 spiCol = mix( tan(col + iTime * 10.0) + 1.0, black, mBird);\n\n    // Output to screen\n    fragColor = vec4(spiCol,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/td2XWy.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[203, 203, 224, 399, 465], [467, 482, 507, 507, 1018], [1020, 1038, 1096, 1096, 1234], [1236, 1236, 1263, 1263, 1661], [1663, 1680, 1701, 1701, 1748], [1749, 1749, 1770, 1770, 1817], [1818, 1818, 1840, 1840, 1875], [1877, 1877, 1899, 1899, 2947], [2950, 2950, 2990, 2990, 3291], [3293, 3293, 3350, 3400, 4231]], "test": "ok"}
{"id": "td2XzV", "name": "Drunken Flight", "author": "zackpudil", "description": "Drunken flight through an ifs fractal.", "tags": ["raymarching", "ifs"], "likes": 15, "viewed": 200, "published": "Public", "date": "1554406807", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI 3.141596\n#define PHI (sqrt(5)*0.5 + 0.5)\n\n// simple 2d rotation matrix based on angle.\nmat2 rot(float a) {\n  float s = sin(a);\n  float c = cos(a);\n  \n  return mat2(c, s, -s, c);\n}\n\n// From http://mercury.sexy/hg_sdf/, modulate around a circle.\nvec2 modPolar(vec2 p, float reps) {\n  float angle = 2.0*PI/reps;\n  \n  float a = mod(atan(p.y, p.x) + angle/2.0, angle) - angle/2.0;\n  float r = length(p);\n  \n  return r*vec2(cos(a), sin(a));\n}\n\nvec2 opU(vec2 a, vec2 b) {\n  return a.x < b.x ? a : b;\n}\n\n// simple box sdf.\nfloat box(vec3 p, vec3 r) {\n  vec3 q = abs(p) - r;\n  return max(max(q.x, q.y), q.z);\n}\n\n// box wrapped in a \nvec2 shape(vec3 p) {\n  vec3 op = p;\n  p.xz = abs(p.xz) - vec2(1); // this mirrors space along a diagnal in the xz plane.  \n  \n  float a = box(p + vec3(1, 0, 0), vec3(1, 0.05, 0.1)); // stripe running from left to right.\n  float b = box(p + vec3(0, 0, 1), vec3(0.1, 0.05, 1)); // running from back to front.\n  float c = box(p, vec3(0.1, 1, 0.1)); // running from top to bottom.\n  float d = box(op, vec3(1)); // big cube in the middle.\n  \n  vec2 s = vec2(min(a, min(b, c)), 1.0); // the gold stripes.\n  vec2 t = vec2(d, 2.0); // the purplish box.\n  \n  return opU(s, t);\n}\n\nvec2 de(vec3 p) {\n  \n  vec3 op = p;\n  \n  p.zy *= rot(iTime); // rotating space, adds to the drunk feel.\n  p.zy = abs(p.yz) - vec2(1.6, 1.3); // mirror space to get the fract to fill up more of the scene.\n  p.x = mod(p.x + 1.0, 2.0) - 1.0; // repeat space along x axis.\n  \n  float s = 1.2;\n  vec4 q = vec4(p*s, 1);\n  \n  // typical IFS coordinate deformation setup.\n  for(int i = 0; i < 8; i++) {\n    q.xyz = abs(q.xyz) - vec3(0.5, 0.1, 0.7); // Mirror.\n    q.xz *= rot(1.1); // rotate\n    q.xy *= rot(0.7); // again.\n    \n    q *= 1.4; // scale.\n  }\n    \n  vec2 f = shape(q.xyz)/vec2(q.w*s, 1);\n  \n  return f;\n}\n\n\n// not sure where this was from, but it's a nice way of mapping a 2d texture unto a 3d object.\n// Tri-Planar blending function.\nvec3 mat(in vec3 p, in vec3 n, sampler2D s){\n  \n    // Tweaked to suit your needs.\n    n = max(abs(n) - .2, .001); // n = max(n*n - .1, 0.001), etc.\n    //n /= (n.x + n.y + n.z); // Rough normalization... I think? \n    n /= length(n); // Normalizing.\n    \n    vec3 x = texture(s, p.yz).xyz;\n    vec3 y = texture(s, p.zx).xyz;\n    vec3 z = texture(s, p.xy).xyz;\n    \n    return x*x*n.x + y*y*n.y + z*z*n.z;\n    \n}\n  \n\n// luminosity grey scale.\nvec3 grey = vec3(0.212, 0.715, 0.072);\n\n// bump mapping, perturbing normals to add some detail to geometry.\nvec3 bump(vec3 p, vec3 n, sampler2D s) {\n    vec2 h = vec2(0.005, 0.0);\n    vec3 b = normalize(mat3(\n        mat(p + h.xyy, n, s) - mat(p - h.xyy, n, s),\n        mat(p + h.yxy, n, s) - mat(p - h.yxy, n, s),\n        mat(p + h.yyx, n, s) - mat(p - h.yyx, n, s))*grey);\n    \n    b -= n*dot(n, b); // have no idea what this term does, but it helps smooth out the bumps around corners.\n    \n    return normalize(n + 0.1*b);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n  vec2 uv = fragCoord/iResolution.xy - 0.5; // converting gl_FragCoord.xy from [0, 1] to [-1, 1]\n  uv.x *= iResolution.x/iResolution.y; // stretch based on resolution.\n  \n  vec3 col, bg;\n  col = bg = vec3(1.0)*(1.0 - (length(uv) - 0.2)); // vinetting (darker cornders).\n  \n  \n  float a = -3.0;\n  float at = 0.3*iTime;\n  \n  vec3 ro = vec3(at, 0, 0); // camera position.\n  vec3 ww = normalize(vec3(at + 1.0, 0.5*sin(at), cos(at))-ro); // camera looking at vector.\n  vec3 uu = normalize(cross(vec3(sin(iTime), cos(iTime), 0), ww)); // the roll vector for the \"right vector\" is causing most of the drunken fly feel.\n  vec3 vv = normalize(cross(ww, uu)); // up vector.\n  vec3 rd = normalize(mat3(uu, vv, ww)*vec3(uv, 1.0)); // combine the 3 vectors representing the camera to get the ray direction.\n  \n  // sphere tracing, get intersection distance from pixel to geometry.\n  float t = 0.0, m = -1.0, mx = 50.0;\n  for(int i = 0; i < 200; i++) {\n    vec2 d = de(ro + rd*t);\n    if(d.x < 0.001 || t >= mx) break;\n    t += d.x*0.5; // small bit of fudging to get better results.\n    m = d.y;\n  }\n  \n  vec3 ld = normalize(vec3(-0.5, 0, 0)); // light direction.\n  vec2 e = vec2(1, -1)*0.001;\n  \n  if(t < mx) {\n    vec3 p = ro + rd*t;\n    vec3 n = normalize(\n      e.xxx*de(p + e.xxx).x +\n      e.xyy*de(p + e.xyy).x +\n      e.yxy*de(p + e.yxy).x +\n      e.yyx*de(p + e.yyx).x); // tetrahedral derivative to get normal.\n        \n    vec3 al = vec3(1); // al = albeido, which is color of object.\n\tfloat spo = 16.0; // spo = specular/gloss map.\n     \n    float aot = t/50.0;\n    float ao = exp2(-2.0*pow(max(0.0, 1.0 - de(p + n*aot).x/aot), 2.0)); // nice fake for occulsion by using a wave-paket 2^(-x^2) to approximate a falloff at distances.\n    float dif = max(0.0, dot(ld, n)); // diffuse lighting.\n      \n    p.zy *= rot(iTime); // rotate the space so the textures don't swim (more accuratly so the geometry spins while the texture mapping stands still).\n      \n    if(m < 1.5) {\n      // albeido and gloss map for gold stripes.\n      al = vec3(4)*mat(p, n, iChannel1);\n      spo = 4.0;\n    } else if(m > 1.5) {\n      // albeido, gloss and bump map for purplish box.\n      al = vec3(0.6, 0.3, 1)*mat(p*2.0, n, iChannel0);\n      //n = bump(p*2.0, n, iChannel1);\n      spo = 3.0;\n    }\n    \n    float sst = 3.4;\n    float sss = smoothstep(0.0, 1.0, de(p + ld*sst).x/sst); // subsurface scattering, basically this terms adds some light that bleeds through geometry based on sst.\n    \n    float sp = pow(max(0.0, dot(reflect(-ld, n), -rd)), spo); // specular light.\n\tfloat fr = pow(1.0 + dot(rd, n), 2.0); // fresnel term. I don't understand this, but it works.\n\n    \n    col = mix(vec3(al*ao*(dif + sss + sp)), al, fr); // mix it all together, usually sp is outside the al*ao term, but Idk what I'm doing.\n  }\n  \n  col = mix(col, bg, 1.0 - exp(-0.3*t)); // some fog, make the scene look bigger, and hide popin from.\n  fragColor = vec4(pow(col, vec3(0.45)), 1); // the pow(col, vec3(0.45)) is gamma correction, used to make sure different monitors see roughly the same colors.\n}", "image_inputs": [{"id": "XdfGRn", "previewfilepath": "/media/ap/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg", "ctype": "texture"}, {"id": "XsfGRn", "previewfilepath": "/media/ap/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/td2XzV.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[53, 98, 117, 117, 190], [192, 255, 290, 290, 447], [449, 449, 475, 475, 505], [507, 526, 553, 553, 612], [614, 635, 655, 655, 1204], [1206, 1206, 1223, 1223, 1816], [1819, 1947, 1991, 2029, 2359], [2430, 2498, 2538, 2538, 2918], [2920, 2920, 2977, 2977, 6044]], "test": "error"}
{"id": "tdBSWc", "name": "oh no", "author": "Pyramid", "description": "oops", "tags": ["epilepsy"], "likes": 3, "viewed": 88, "published": "Public", "date": "1555080700", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define hue(h) abs(fract(h + vec3(3,2,1)/3.) * 6. - 3.) -1.\n\nvec3 hsv2rgb(vec3 c)\n{\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    float t = 228.+iTime*1.;\n    \n    float frq=t/4.;\n    float amp=cos(t/4.5);\n    float h=cos(uv.y)*t+sin(uv.x*amp*frq)+uv.y*t/26.*frq;\n    \n    //vec3 c=vec3(h,1,1);\n    //vec3 rgbcc=hsv2rgb(c);\n    vec3 rgbcc=hue(h);\n    \n    fragColor = vec4(rgbcc,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tdBSWc.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[61, 61, 83, 83, 252], [254, 254, 311, 311, 617]], "test": "ok"}
{"id": "tdBSWG", "name": "OpShader · 20190409", "author": "JacobJoaquin", "description": "An experiment of patterns and masking.", "tags": ["opart"], "likes": 1, "viewed": 86, "published": "Public", "date": "1554820156", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#ifdef GL_ES\nprecision mediump float;\n#endif\n\n#define TAU 6.283185307179586\n#define PI 3.141592653589793\n\nfloat biToUni(float v)\n{\n    return (v + 1.0) * 0.5;\n}\n\n// Power curve\n// http://www.iquilezles.org/www/articles/functions/functions.htm\nfloat pcurve(in float x, in float a, in float b)\n{\n\tfloat k = pow(a + b, a + b) / (pow(a , a) * pow(b , b));\n\treturn k * pow(x, a) * pow(1.0 - x, b);\n}\n\nfloat maskIt(in float mask, in float v0, in float v1)\n{\n\treturn mask * v0 + (1.0 - mask) * v1;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float nTiles = 3.0;\n\tfloat t = iTime * 0.125;\n\tvec2 st = gl_FragCoord.xy / iResolution.xy;\n\n\t// Create tile mask\n\tvec2 mst = fract(st * nTiles);\n\tfloat curve = biToUni(sin(iTime * TAU)) * 2.0 + 0.25;\n\tfloat vx = pcurve(mst.x, curve, curve);\n\tfloat vy = pcurve(mst.y, curve, curve);\n\tfloat mask = min(vx, vy);\n\tmask = step(0.5, mask);\n\n\t// Diagonal Stripes\n\tfloat rowst = biToUni(sin((st.x - st.y + t) * TAU * 4.0));\n\trowst = step(0.5, rowst);\n\tfloat colst = biToUni(cos((st.y + st.x + t) * TAU * 8.0));\n\tcolst = step(0.5, colst);\n\tfloat value = maskIt(mask, rowst, colst);\n\n    // Output\n\tvec3 color = vec3(value);\n\tfragColor = vec4(color, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tdBSWG.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[106, 106, 130, 130, 160], [162, 243, 293, 293, 394], [396, 396, 451, 451, 492], [494, 494, 551, 551, 1203]], "test": "ok"}
{"id": "tdBXDc", "name": "Raytracing - Textured Spheres", "author": "clepirelli", "description": "Thanks to UglySwedishFish#3207 on discord for their help with specular lighting\n\nTextured spheres ", "tags": ["raytracing", "light", "sphere"], "likes": 2, "viewed": 270, "published": "Public API", "date": "1555094703", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define E 2.71828\n\n//ray data, used to get the pixel color by sending (or casting) a ray per pixel into the scene\nstruct ray\n{\n\tvec3 origin;\n    vec3 direction;\n};\n    \n//material represents the way light bounces off the surface of a primitive\nstruct material\n{\n\tfloat kSpecular;\n    float kDiffuse;\n    float glossiness;\n};\n    \n//one-color sphere\nstruct sphere\n{\n\tvec3 origin;\n    vec3 color;\n    float radius;\n    material mat;\n};\n    \n//point light\nstruct light\n{\n    vec3 origin;\n  \tfloat intensity;\n};\n    \nstruct directionalLight\n{\n    vec3 direction;\n    float intensity;\n};\n\nstruct intersection\n{\n    //distance from the origin of the ray to the intersection\n    float dist;\n    //color of the primitive at the intersection\n    vec3 color;\n    //normal of the primitive at the intersection\n    vec3 normal;\n    //material of the primitive at the intersection\n    material mat;\n};\n    \nconst float renderDistance = 9999.0;\n\n//return value if a ray misses a primitive\nconst intersection miss = intersection(renderDistance, vec3(.0), vec3(.0), material(.0, .0, .0));\n\n\n\nconst int sphereCount = 6;\n\nconst int lightCount = 3;\n\nconst float ambientLight = .1;\n\nconst vec3 WHITE = vec3(1.0);\nconst vec3 GREEN = vec3(.0, 1.0, .0);\nconst vec3 RED = vec3(1.0, .0,.0);\nconst vec3 TEAL = vec3(.0, 1.0, 1.0);\nconst vec3 YELLOW = vec3(1.0, 1.0, .0);\n\n\n//gets the intersection between a ray and a sphere\n//from : https://www.scratchapixel.com/lessons/3d-basic-rendering/minimal-ray-tracer-rendering-simple-shapes/minimal-ray-tracer-rendering-spheres\nintersection sphereIntersect(in ray pRay, in sphere pSphere)\n{\n    float radius2 = pSphere.radius*pSphere.radius;\n    vec3 L = pSphere.origin - pRay.origin; \n    float tca = dot(L, pRay.direction); \n    float d2 = dot(L,L) - tca * tca; \n    if (d2 > radius2) return miss; \n    float thc = sqrt(radius2 - d2); \n    float t0 = tca - thc;\n    float t1 = tca + thc;\n    float t = min(t0, t1);\n    \n    vec3 hit = pRay.origin + pRay.direction * t;\n    vec3 coords = hit - pSphere.origin;\n\tvec2 uv = vec2(atan(coords.z, coords.x), acos(coords.y/pSphere.radius));\n    \n    vec3 color = texture(iChannel0, uv).rgb;\n    \n    //return the distance from the ray's origin to the point\n    return intersection(t, color*pSphere.color, normalize(pSphere.origin - hit), pSphere.mat);\n}\n\nfloat lightAura(in ray pRay, in light pLight, sphere[sphereCount] spheres)\n{\n\t//distance from the ray's origin to the light's origin\n    float distanceToLightOrigin = distance(pLight.origin, pRay.origin);\n    \n    //projection of the ray on the light, aka the point on the ray which is the closest to the light's origin\n    vec3 rayProjection = pRay.origin + pRay.direction * distanceToLightOrigin;\n    \n    return pLight.intensity /(distance(pLight.origin, rayProjection)*100.0);\n}\n\n//mixes two intersection\n//Think of this as a more optimized way of saying :\n//if(mixRatio = 0) return a, else return b\nintersection mixIntersections(intersection a, intersection b, float mixRatio)\n{\n\treturn intersection\n            (\n            mix(a.dist, \tb.dist, \tmixRatio),\n            mix(a.color, \tb.color, \tmixRatio),\n            mix(a.normal, \tb.normal, \tmixRatio),\n            material\n                (\n                mix(a.mat.kSpecular, \tb.mat.kSpecular, \tmixRatio),\n                mix(a.mat.kDiffuse, \tb.mat.kDiffuse, \tmixRatio),\n                mix(a.mat.glossiness, \tb.mat.glossiness, \tmixRatio)\n\t\t\t\t)\n            );\n}\n\nfloat getDiffuse(intersection pIntersection, vec3 lightDirection)\n{\n    //clamp the dot product of the normal of the point and of the origin of the light\n\treturn clamp(dot(pIntersection.normal, lightDirection), .0, 1.0) * pIntersection.mat.kDiffuse;\n}\n\n\nfloat getSpecular(vec3 point, intersection pIntersection, ray pRay, vec3 lightDirection)\n{\n    //reflection of the light on the surface\n    vec3 reflection = reflect(lightDirection, pIntersection.normal);\n    \n    //specular term\n    //Thanks to UglySwedishFish#3207 on discord for their help with this :\n    //dot products range from -1 to 1, so the dot product of the reflection and the ray's direction\n    //has to be clamped so that a negative value doesn't get squared into a positive value\n    return pow(clamp(dot(normalize(reflection), pRay.direction), .0, 1.0), pIntersection.mat.glossiness) * pIntersection.mat.kSpecular;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float time = iTime;\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv    = fragCoord.xy / iResolution.xy - vec2(0.5);\n         uv.x *= iResolution.x / iResolution.y;\n    \n    directionalLight SUN = directionalLight(normalize(vec3(-.5, -1.5, 1.5)), 2.0);\n    \n    ray currentRay = ray(vec3(uv.xy, .0), normalize(vec3(uv, 1.))); \n    \n    material mat = material(.7, .2, 32.);\n    vec3 col = vec3(1.);\n    \n    vec2 path = vec2(.0);\n    path.x += sin(time);\n    path.x += sin(time*2.);\n    path.x += 2.0*cos(time*.1);\n    path.x *= sin(time);\n    \n    path.y += sin(time*.1);\n    path.y += cos(time);\n    \n    \n    //sphere definitions\n    sphere spheres[sphereCount] = sphere[sphereCount]\n\t(\n\t\tsphere(vec3(cos(time), .2, 4.0), \tWHITE,\t1., mat),\n\t    sphere(vec3(-path.x + 1.0, -path.y, 5.0), \t\tWHITE,\t1.0,mat),\n        sphere(vec3(sin(time)*2.0, 2.0, 4.0), \t\tTEAL,\t1.5,mat),\n        sphere(vec3(2.0, -1.0, 10.0), \t\t\t\tTEAL,\t.8, mat),\n        sphere(vec3(path.x, path.y, 10.0), \tGREEN,\t1., mat),\n        sphere(vec3(.0, .0, 8.0), \t\t\t\t\tRED,\t1.0,mat)\n\t);\n    \n    //light definitions\n    light lights[lightCount] = light[lightCount]\n    (\n        light(vec3(1.0, .2, 10.0 + abs(sin(iTime)*10.0)), 5.),\n        light(vec3(.0, -2.0, 10.0), 7.),\n        light(vec3(1.0, 1.0, .0), 20.)\n    );    \n    \n    intersection finalIntersection = miss;\n    \n    //for every sphere, see whether the ray intersects it\n    for(int i = 0; i < sphereCount; i++)\n    {\n        //sphere intersection returns the distance at which the sphere is intersected\n        intersection currentIntersection = sphereIntersect(currentRay, spheres[i]);\n        \n        //if the current distance is smaller than the final distance\n        //set the final intersection to be the current intersection\n        float distanceSmaller = float(currentIntersection.dist < finalIntersection.dist);\n        finalIntersection = mixIntersections(finalIntersection, currentIntersection, distanceSmaller);\n    }\n    \n    //whether the ray missed or not\n    bool rayMissed = finalIntersection.dist == miss.dist;\n    \n    //the point where the ray hit a primitive\n    vec3 hit = currentRay.origin + currentRay.direction * finalIntersection.dist;\n    \n    vec3 finalCol = vec3(.0);\n    vec3 aura = vec3(.0);\n    \n    //sun light\n    finalCol += min(finalIntersection.color * \n        (\n            getDiffuse(finalIntersection, SUN.direction) + \n            getSpecular(hit, finalIntersection, currentRay, SUN.direction)\n            + ambientLight\n        ) * \n        SUN.intensity ,1.0)*\n        clamp(dot(finalIntersection.normal, SUN.direction), ambientLight, 1.0);\n    \n    for(int i = 0; i < lightCount; i++)\n    {        \n        //the light's intensity is its intensity variable divided by its attenuation over distance\n        float lightIntensity = lights[i].intensity / pow(distance(hit, lights[i].origin), 2.0);                \n        vec3 lightDirection = normalize(hit - lights[i].origin);\n        \n        //final color\n    \tfinalCol +=\n        \t//color of the primitive\n        \tfinalIntersection.color *\n            //lighting terms\n        \t(\n            getDiffuse(finalIntersection, lightDirection)\n            + getSpecular(hit, finalIntersection, currentRay, lightDirection)\n            + ambientLight\n            ) *\n            //intensity of the light\n            lightIntensity *\n            clamp(dot(finalIntersection.normal, lightDirection), ambientLight, 1.0);\n        aura += lightAura(currentRay, lights[i], spheres)* float(finalIntersection.dist > distance(lights[i].origin, currentRay.origin));\n    }\n\n\t//background color\n\tvec3 bgCol = vec3(ambientLight) + pow(E, 1.0 - 1.0/ pow(min(dot(currentRay.direction, SUN.direction), .0), 2.0)) * YELLOW;\n    bgCol = clamp(bgCol, .0, 1.0);\n    //select between the background color (if the ray missed) and the final color (if the ray hit)\n    finalCol = mix(finalCol, bgCol, float(rayMissed));\n    finalCol += aura;\n    \n    // Output to buffer\n    fragColor = vec4(finalCol, 1.0);\n}", "image_inputs": [{"id": "XsfGRn", "previewfilepath": "/media/ap/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tdBXDc.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1346, 1543, 1605, 1605, 2312], [2798, 2918, 2997, 2997, 3435], [3437, 3437, 3504, 3590, 3688], [3691, 3691, 3781, 3826, 4324], [4327, 4327, 4384, 4384, 8406]], "test": "error"}
{"id": "tdBXDt", "name": "water_texture", "author": "lqt0223", "description": "water_texture", "tags": ["texture"], "likes": 2, "viewed": 151, "published": "Public", "date": "1555299625", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#ifdef GL_ES\nprecision mediump float;\n#endif\n\nuniform vec2 u_resolution;\nuniform vec2 u_mouse;\n\nfloat sdcircle(vec2 st,vec2 origin,float r){\n  return length(st-origin)-r;\n}\n\nvec2 floor2d(vec2 st){\n  return vec2(floor(st.x),floor(st.y));\n}\n\nvec2 fract2d(vec2 st){\n  return vec2(fract(st.x),fract(st.y));\n}\n\nvec2 random2d(vec2 st){\n  float r1=fract(sin(dot(st.xy,vec2(127.9898,311.233)))*43758.5453123);\n  float r2=fract(sin(dot(st.xy,vec2(269.5,183.3)))*43758.5453123);\n  return 2.*vec2(r1,r2)-1.;\n}\n\nfloat noise(vec2 st){\n  vec2 i=floor2d(st);\n  vec2 f=fract2d(st);\n  \n  vec2 a=random2d(i);\n  vec2 b=random2d(i+vec2(1,0));\n  vec2 c=random2d(i+vec2(0,1));\n  vec2 d=random2d(i+vec2(1,1));\n  \n  vec2 u=smoothstep(0.,1.,f);\n  \n  float e=mix(dot(a,f),dot(b,f-vec2(1,0)),u.x);\n  float g=mix(dot(c,f-vec2(0,1)),dot(d,f-vec2(1,1)),u.x);\n  float h=mix(e,g,u.y);\n  return h;\n}\n\nfloat fbm(vec2 st){\n  const int OCTAVES=10;\n  // Initial values\n  float value=0.;\n  float amplitude=.5;\n  //\n  // Loop of octaves\n  for(int i=0;i<OCTAVES;i++){\n    value+=amplitude*abs(noise(st));\n    st*=2.;\n    amplitude*=.5;\n  }\n  return value;\n}\n\nvec2 distort(vec2 uv){\n  return uv+fbm(uv+vec2(.24,.025)+iTime*.125);\n}\n\nvec2 distort2(vec2 uv){\n  return uv+fbm(uv+vec2(.12,.52)+iTime*.324);\n}\n\nvec4 wave(vec2 uv){\n  uv=uv*2.;\n  vec2 p=distort(uv);\n  p=distort(p);\n  float c=fbm(p);\n  c=c*4.-.2;\n  vec4 color=vec4(vec3(c),1.);\n  color=color*vec4(1.,.5,.3,1.);\n  color=1.-color;\n  color.w=1.;\n  return color;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n  vec2 uv=fragCoord/iResolution.xy-.5;\n  uv=uv*1.;\n  vec4 wave1=wave(uv);\n  vec4 wave2=wave(vec2(uv.x,-uv.y)+1.5);\n  vec4 wave3=wave(vec2(-uv.x,-uv.y)+3.);\n  vec4 wave4=wave(vec2(-uv.x,-uv.y)+4.5);\n  fragColor=.25*wave1+.25*wave2+.25*wave3+.25*wave4;\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tdBXDt.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[96, 96, 140, 140, 172], [174, 174, 196, 196, 238], [240, 240, 262, 262, 304], [306, 306, 329, 329, 498], [500, 500, 521, 521, 866], [868, 868, 887, 887, 1117], [1119, 1119, 1141, 1141, 1190], [1192, 1192, 1215, 1215, 1263], [1265, 1265, 1284, 1284, 1479], [1481, 1481, 1535, 1535, 1788]], "test": "error"}
{"id": "tdBXWK", "name": "fbm mountain", "author": "ankd", "description": "What is the cause of this distortion... -> This problem is solved, Thanks!", "tags": ["raymarching", "fbm"], "likes": 2, "viewed": 260, "published": "Public", "date": "1554924823", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const float PI = 3.14150265359;\n\n// hash() and noise() is from Inigo Quilez \"Noise - value - 3D\"\n// https://www.shadertoy.com/view/4sfGzS\nfloat hash(vec3 p)  // replace this by something better\n{\n    p  = fract( p*0.3183099+.1 );\n\tp *= 17.0;\n    return fract( p.x*p.y*p.z*(p.x+p.y+p.z) );\n}\nfloat noise( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n\t\n    return mix(mix(mix( hash(p+vec3(0,0,0)), \n                        hash(p+vec3(1,0,0)),f.x),\n                   mix( hash(p+vec3(0,1,0)), \n                        hash(p+vec3(1,1,0)),f.x),f.y),\n               mix(mix( hash(p+vec3(0,0,1)), \n                        hash(p+vec3(1,0,1)),f.x),\n                   mix( hash(p+vec3(0,1,1)), \n                        hash(p+vec3(1,1,1)),f.x),f.y),f.z);\n}\n\nfloat fbm(in vec3 p){\n    float res = 0.;\n    vec3 q = p;\n    float amp = 1.0;//\n    for(int i=0;i<5;i++){\n\t\tfloat fi = float(i);\n        res += amp*noise(q);\n        amp *= 0.5;//\n        q*=2.0;\n    }\n    return res;\n}\n\nfloat sdPlane(in vec3 p, in float h){\n    return p.y - h;\n}\nvec2 map(in vec3 p){\n    float h = fbm(vec3(p.x, 0., p.z));\n    return vec2(sdPlane(p, h), 0.);\n}\n\nvec2 castRay(in vec3 ro, in vec3 rd){\n    float minD = 0.0;\n    float maxD = 10.0;\n    float thr = 0.00001;// 0.001 -> 0.00001\n    \n    float d=minD, m=0.0;\n    for(int i=0;i<64;i++){\n        vec3 pos = ro+rd*d;\n        vec2 tmp = map(pos);\n        if(tmp.x<thr || maxD<tmp.x) break;\n        d += tmp.x*0.5;// d+=tmp.x; -> d+=tmp.x*0.5;\n        m = tmp.y;\n    }\n    if(maxD<d) m=-1.0;\n    return vec2(d, m);\n}\n\nvec3 calcNormal(in vec3 p){\n    vec2 eps = vec2(1.0, -1.0)*0.001;\n    return normalize(vec3(\n    \teps.xyy*map(p+eps.xyy).x +\n    \teps.yxy*map(p+eps.yxy).x +\n    \teps.yyx*map(p+eps.yyx).x +\n    \teps.xxx*map(p+eps.xxx).x \n    ));\n}\n\nvec3 render(in vec3 ro, in vec3 rd){\n    vec2 res = castRay(ro, rd);\n    float d = res.x, m=res.y;\n    \n    vec3 pos = ro + rd*d;\n    vec3 nor = calcNormal(pos);\n    \n    vec3 lightDir = vec3(1.0);\n    \n    vec3 col = clamp(vec3(dot(lightDir, nor)), 0.0, 1.0);\n\tcol *= vec3(0.3, 0.15, 0.02)*noise(pos);\n    \n    //col = mix(col, vec3(1.0), clamp(d/10.0, 0., 1.0));\n    col = mix(col, vec3(1.0), 1.0-exp(-0.03*d*d));// use gaussian\n\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 p = (fragCoord*2.0-iResolution.xy)/min(iResolution.x, iResolution.y);\n    \n    vec3 eye = vec3(0., 2.0+0.1*sin(iTime), -iTime);\n    vec3 dir = normalize(vec3(p, -1.0));\n    float an = -PI*0.1;\n    dir.yz *= mat2(cos(an), -sin(an), sin(an), cos(an));\n    \n    vec3 col = render(eye, dir);\n    \n\tfragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tdBXWK.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[33, 138, 195, 195, 290], [291, 291, 317, 317, 791], [793, 793, 814, 814, 1013], [1015, 1015, 1052, 1052, 1074], [1075, 1075, 1095, 1095, 1172], [1174, 1174, 1211, 1211, 1583], [1585, 1585, 1612, 1612, 1814], [1816, 1816, 1852, 1852, 2265], [2267, 2267, 2324, 2324, 2653]], "test": "ok"}
{"id": "tdjSDw", "name": "Comme un poisson dans l'Ourcq", "author": "eliemichel", "description": "Tribute to the grapher Da Cruz, inspired by \"4 oiseaux dans 1 masque\".\n\n2d distance fields\n\nClick to interact", "tags": ["2d", "graph", "streetart"], "likes": 82, "viewed": 1127, "published": "Public API", "date": "1554411295", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// \"Comme un poisson dans l'Ourcq\"\n// Tribute to the grapher Da Cruz\n// Copyright (c) March 2019 - Alt144 (Elie Michel)\n// License: CC 3.0 BY - Please notify me when using it\n\n#define PI 3.14159265\n\nvec2 rand2(vec2 seed) {\n    return vec2(fract(sin(dot(seed.xy ,vec2(12.9898,78.233))) * 43758.5453),\n\t\tfract(cos(dot(seed.xy ,vec2(4.898,7.23))) * 23421.631));\n}\n\nvec2 noise2(vec2 uv) {\n    vec2 e = vec2(1., 0.);\n    vec2 i = floor(uv);\n    vec2 t = fract(uv);\n    t = t*t*(3.-2.*t);\n    vec2 r00 = rand2((i + e.yy)*.0254);\n    vec2 r10 = rand2((i + e.xy)*.0254);\n    vec2 r01 = rand2((i + e.yx)*.0254);\n    vec2 r11 = rand2((i + e.xx)*.0254);\n    return mix(\n    \tmix(r00, r10, t.x),\n        mix(r01, r11, t.x),\n        t.y\n    );\n}\nfloat noise(vec2 uv) { return noise2(uv).x; }\n\nvec2 moda(vec2 uv, float repeat, out float iter) {\n    float a = atan(uv.y, uv.x);\n    float s = PI/repeat;\n    iter = mod(a/2./s, repeat);\n    a = mod(a, 2.*s) - s;\n    return length(uv) * vec2(cos(a), sin(a));\n}\n\nvec2 elbow(vec2 uv) {\n    vec2 tuv = vec2(-uv.y+.295, uv.x);;\n    float a = atan(uv.x, uv.y);\n    vec2 ruv = vec2(2.*PI*a*.03, length(uv));\n    return mix(tuv, mix(uv, ruv, step(0., uv.x)), step(0., uv.y));\n}\n\nfloat smin( float a, float b, float k )\n{\n    float h = max( k-abs(a-b), 0.0 )/k;\n    return min( a, b ) - h*h*k*(1.0/4.0);\n}\n\nfloat circleRing(vec2 uv, float steps, float minr, float maxr, float angleJitter, float angularSpeed, float rotation) {\n    float iter;\n    float a = atan(uv.y, uv.x);\n    a += rotation + iTime * angularSpeed;\n    uv = length(uv) * vec2(cos(a), sin(a));\n    uv = moda(uv, steps, iter);\n    vec2 r = rand2(vec2(floor(iter)*.0354, 0.21));\n    float d = length(uv - vec2(.3+mix(maxr, minr, r.x),mix(-1.,1.,r.y)*.08*angleJitter)) - mix(minr, maxr, r.x);\n    return -d;\n}\n\nfloat shape1(vec2 uv, float steps, float angleJitter, float angularSpeed) {\n    float d = length(uv) - .4;\n    d = min(d, -circleRing(uv, steps, .05, .08, angleJitter, angularSpeed, .0));\n    return -d;\n}\n\nstruct StripesOpt {\n    float distorsion;\n    float spacing;\n    float bump;\n};\nfloat stripes(vec2 uv, StripesOpt opt) {\n    vec2 ouv = uv;\n    float s = 10.;\n    float iter = round(uv.x*s+.25);\n    uv.x = mod(uv.x, 1./10.) - 1./10./2.;\n    vec2 r = rand2(vec2(iter*.0234, iter*0.8913));\n    float ax = mix(-1.,1.,r.x)*.05*opt.distorsion;\n    float d = sin(2.*PI*(uv.x+uv.y*ax)*10.);\n    d += mix(-.5+opt.spacing, .5+opt.spacing, r.x);\n    d *= .03;\n    \n    float sides = .47-abs(uv.y);\n    \n    // bumps\n    float nobump = (1. - step(.5, opt.bump)) * 99999.;\n    uv = ouv;\n    s = 2.;\n    uv.x = mod(uv.x, s) - s/2.;\n    sides = min(sides, length(uv-vec2(0.,.9)) - 0.6 + nobump);\n    sides = min(sides, length(uv-vec2(0.5,-.85)) - 0.55 + nobump);\n    \n    d = smin(d, sides, mix(0.10, 0.05, r.y));\n    return d;\n}\n\nfloat fill(float d) {\n    return smoothstep(0., .003, d);\n}\n\nfloat fit01(float a, float b, float x) {\n    return (clamp(x, a, b) - a) / (b - a);\n}\n\nstruct StripesCircleOpt {\n    float minRadius;\n    float maxRadius;\n    float kappa;\n    float omega;\n    float phi;\n};\nfloat stripesCircle(vec2 uv, StripesCircleOpt opt, StripesOpt sopt) {\n    uv = vec2(atan(uv.y, uv.x)/PI*opt.kappa+iTime*opt.omega+opt.phi, fit01(opt.minRadius, opt.maxRadius, length(uv))*2.-1.);\n    return stripes(uv, sopt);\n}\n\nfloat stripesCircle1(vec2 uv, float distorsion) {\n    return stripesCircle(uv, StripesCircleOpt(.25, .385, 3., -.05, 0.), StripesOpt(distorsion, 0., 1.));\n}\n\nfloat stripesCircle2(vec2 uv, float distorsion) {\n    return stripesCircle(uv, StripesCircleOpt(.354, .395, 3.5, -.01, 112.2), StripesOpt(distorsion, .5, 1.));\n}\n\nfloat stripesCircle3(vec2 uv, float distorsion) {\n    return stripesCircle(uv, StripesCircleOpt(.45, .9, 7.5, -.03, 57.3), StripesOpt(distorsion, 0., 1.));\n}\n\nfloat stripesCircle4(vec2 uv, float distorsion) {\n    return stripesCircle(uv, StripesCircleOpt(.4, .95, 6.5, -.03, 32.7), StripesOpt(distorsion, 0., 1.));\n}\n\nfloat circle(vec2 uv, float r) {\n    return -(length(uv) - r);\n}\n\nfloat contours(float shape, float thickness) {\n    return thickness - abs(shape);\n}\n\nfloat capsule(vec2 uv, float r, float h) {\n    uv = abs(uv);\n    return max(circle(uv-vec2(.0, h), r), min(r - uv.x, h - uv.y));\n}\n\nmat2 rot(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat2(c, s, -s, c);\n}\n\nvoid solveCircle(in float width, in float aperture, out float radius, out float offset) {\n    offset = (width*width/aperture-aperture)/2.;\n    radius = offset + aperture;\n}\n\nvec3 drawMainEye(vec3 col, vec2 uv, vec2 mouse, out float dist) {\n    float outerCircle = shape1(uv*.99, 8., 1., .1);\n    float blueCircle = -(length(uv) - 0.392);\n    float blueCircle2 = -(length(uv) - mix(0.355, 0.36, noise(uv*15.)));\n    float ring1 = stripesCircle1(uv, .5);\n    float ring2 = stripesCircle2(uv, .5);\n    float upperEyelidRing = stripesCircle3(uv-vec2(0.,-.5), .5);\n    float lowerEyelidRing = stripesCircle4(uv+vec2(0.,-.5), .5);\n    vec2 innerCircleNoise = (noise2(uv*2.+iTime)-.5)*.05;\n    float innerCircle = shape1((uv+innerCircleNoise)*1.4, 9., .25, -.07);\n    \n    float open = fit01(.0, .005, sin(iTime*2.)*.5+.5);\n    \n    float upperEyeAperture = mix(.15, .23, max(0., mouse.y)*2.);\n    float lowerEyeAperture = mix(.1, .23, clamp(max(0., -mouse.y+.3)*3., 0., 1.));\n    \n    float c = .28; // eye radius\n    float b = mix(.001, upperEyeAperture, open);\n    float a, r;\n    solveCircle(c, b, r, a);\n    float upperEye = -(length(uv+innerCircleNoise - vec2(0.,.01-a)) - r);\n    float upperEyelid = -(length(uv+innerCircleNoise) - mix(0.27, 0.28, noise(uv*15.+3.4)));\n    upperEyelid = min(upperEyelid, -upperEye);\n    \n    b = mix(.001, lowerEyeAperture, open);\n    solveCircle(c, b, r, a);\n    float lowerEye = -(length(uv+innerCircleNoise + vec2(0.,-.01-a)) - r);\n    float lowerEyelid = -(length(uv+innerCircleNoise) - mix(0.27, 0.275, noise(uv*15.+3.464)));\n    lowerEyelid = min(lowerEyelid, -lowerEye);\n    \n    b = lowerEyeAperture;\n    solveCircle(c, b, r, a);\n    vec2 eyeCenter = -vec2(0.,-.025-a);\n    float eye = 1.;\n    eye = min(eye, upperEye-.01);\n    eye = min(eye, lowerEye-.01);\n    \n    ring1 = smin(ring1, -innerCircle-mix(.0, .03, noise(uv*12.+iTime*.5)), 0.02);\n    \n    upperEyelidRing = smin(upperEyelidRing, upperEyelid-.01, 0.01);\n    lowerEyelidRing = min(lowerEyelidRing, lowerEyelid);\n    \n    vec2 eyeOffset = mouse*vec2(.2,.5)+vec2(.0,-.1);\n    eyeOffset.y = min(eyeOffset.y, 0.03);\n    float eyeRing = stripesCircle(uv-eyeCenter-eyeOffset, StripesCircleOpt(.05, .36, 2.5, -.05, 0.), StripesOpt(.5, 0., 0.));\n    float pupille = -(length(uv-eyeCenter-eyeOffset) - .09);\n    \n    eyeRing = min(eyeRing, -.03-upperEyelid) * .2;\n    \n    float eyeRingFade = clamp((-upperEyelid*7.)*(-lowerEyelid*7.) + .2, 0., .9);\n    float eyeWhite = length(uv+innerCircleNoise-eyeCenter)-mix(.325, .31, noise(uv*8.+45.1+iTime*.5))*3.4*pow(r,1.1);\n    \n    vec3 eyeLayer = vec3(.0, .3, .6);\n    eyeLayer = mix(eyeLayer, vec3(1., .292, .173), fill(eyeRing)*eyeRingFade);\n    eyeLayer = mix(eyeLayer, vec3(1.), fill(pupille));\n    eyeLayer = mix(eyeLayer, vec3(1.), fill(eyeWhite));\n    \n    col = mix(col, vec3(.14, .21, .3), fill(outerCircle));\n    col = mix(col, vec3(.1, .3, .5), fill(blueCircle));\n    col = mix(col, vec3(.7, .8, .85), fill(blueCircle2));\n    col = mix(col, vec3(0.65, 0.3, 0.6), fill(ring1*.3));\n    col = mix(col, vec3(0.9, 0.8, 0.2), fill(ring2*.25));\n    col = mix(col, vec3(.14, .21, .3), fill(innerCircle));\n    col = mix(col, eyeLayer, fill(eye));\n    col = mix(col, vec3(1., .292, .173), fill(upperEyelid));\n    col = mix(col, vec3(.75, .102, .073), fill(upperEyelidRing));\n    col = mix(col, vec3(.292, .85, .653), fill(lowerEyelid));\n    col = mix(col, vec3(.75), fill(lowerEyelidRing));\n    \n    dist = outerCircle;\n        \n    return col;\n}\n\nvec3 smallEye(vec2 uv, vec2 mouse, vec2 seed, vec3 eyeColor, out float dist) {\n    vec2 innerCircleNoise = (noise2(seed+uv*3.+iTime*.2+uv.y*3.)-.5)*.03;\n    \n    vec2 r = rand2(seed);\n    float freq = mix(.5,1.,r.x);\n    float phi = r.y * 2. * PI;\n    float open = fit01(.0, .002, sin(iTime*freq+phi)*.5+.5);\n    \n    float upperRadius, upperOffset, lowerRadius, lowerOffset, innerRadius, innerOffset;\n    solveCircle(.175, mix(.001, .12, open), upperRadius, upperOffset);\n    solveCircle(.175, mix(.001, .085, open), lowerRadius, lowerOffset);\n    solveCircle(.175, .085, innerRadius, innerOffset);\n    vec2 eyeCenter = -vec2(0.,-.025-innerOffset);\n    \n    vec2 eyeOffset = mouse*vec2(.1,.5)+vec2(.0,-.1);\n    eyeOffset.y = min(eyeOffset.y, 0.03);\n    eyeOffset = vec2(0.); // DEACTIVATE\n    \n    float pupille = circle(uv-eyeCenter-eyeOffset, .08);\n    \n    float upperEye = circle(uv+innerCircleNoise - vec2(0.,.01-upperOffset), upperRadius);\n    float lowerEye = circle(uv+innerCircleNoise + vec2(0.,-.01-lowerOffset), lowerRadius);\n    \n    float eyeRing = stripesCircle(uv-eyeCenter-eyeOffset, StripesCircleOpt(.05, .25, 2., -.05, 0.), StripesOpt(.5, 0., 0.));\n    float eyeRingFade = clamp((-upperEye*7.)*(-lowerEye*7.) + .2, 0., .9);\n    \n    float eyeWhite = -circle(uv+innerCircleNoise-eyeCenter, mix(.95, .99, noise(seed+uv*8.+45.1+iTime*.5))*innerRadius);\n    \n    float eye = 1.;\n    eye = min(eye, upperEye-.01);\n    eye = min(eye, lowerEye-.01);\n    \n    vec3 col = vec3(.0, .3, .6);\n    col = mix(col, eyeColor, fill(eyeRing)*eyeRingFade);\n    col = mix(col, vec3(1.), fill(pupille));\n    col = mix(col, vec3(1.), fill(eyeWhite));\n    \n    dist = eye;\n    return col;\n}\n\n// Animation around the small eyes\n// Pb: How to do a kind of temporal modulo on this to clone along path at low cost?\nvec2 anim1(float anim) {\n    float len = PI*.14+.11*2.+PI*.14+.11*2.;\n    vec2 cc = vec2(.14,.11);\n    float theta;\n    float a1 = fit01(.0, .22/len, fract(anim));\n    float a2 = fit01(.22/len, (.22+PI*.14)/len, fract(anim));\n    float a3 = fit01((.22+PI*.14)/len, (.44+PI*.14)/len, fract(anim));\n    float a4 = fit01((.44+PI*.14)/len, 1., fract(anim));\n    theta = PI*a2;\n    vec2 cc2 = vec2(.0,.11) + .14 * vec2(cos(theta), sin(theta));\n    theta = PI+PI*a4;\n    vec2 cc4 = vec2(.0,-.11) + .14 * vec2(cos(theta), sin(theta));\n    vec2 cc1 = vec2(.14,-.11) + a1 * vec2(0.,.22);\n    vec2 cc3 = vec2(-.14,.11) + a3 * vec2(0.,-.22);\n    cc = mix(cc1, cc2, step(0.01, a2));\n    cc = mix(cc, cc3, step(0.01, a3));\n    cc = mix(cc, cc4, step(0.01, a4));\n    return cc;\n}\n\nvec3 drawSubEyes(vec3 col, vec2 uv, vec2 mouse, out float dist) {\n    uv -= vec2(-.7,-.065);\n    mouse -= vec2(-.7,-.065);\n    uv.x *= 1.+uv.y*uv.y*1.5;\n    float mask = capsule(uv, .17, .11);\n    \n    float topEyeDist, bottomEyeDist;\n    vec3 topEyeLayer =    smallEye(uv-vec2(.0,.085), mouse-vec2(.0,.085), vec2(.12,.7896), vec3(.7, .2, .5), topEyeDist);\n    vec3 bottomEyeLayer = smallEye(uv-vec2(.0,-.11), mouse-vec2(.0,-.11), vec2(8.1,54.16), vec3(1., .15, .14), bottomEyeDist);\n    float eyesMask = max(topEyeDist, bottomEyeDist);\n    \n    // Inter eyes\n    float h1Stripes = stripes(uv*vec2(3.5,1.)+vec2(iTime*.08,.0), StripesOpt(0.,0.,0.));\n    float h1InnerMask = min(mask, -eyesMask)-.01;\n    h1InnerMask = min(h1InnerMask, -max(abs(uv.x)-.2, abs(uv.y)-.1));\n    float h1StripesMask = h1InnerMask-.005;\n    h1Stripes = smin(h1Stripes, h1StripesMask, .01);\n    \n    // Top of eyes\n    float h2Stripes = stripes(uv*vec2(3.5,1.)+vec2(iTime*.08,.0), StripesOpt(0.,0.,0.));\n    float h2InnerMask = min(mask, -eyesMask)-.01;\n    h2InnerMask = min(h2InnerMask, uv.y-.1);\n    float h2StripesMask = h2InnerMask-.005;\n    h2Stripes = smin(h2Stripes, h2StripesMask, .01);\n    \n    // Bottom of eyes\n    float h3Stripes = stripesCircle(uv-vec2(.0,.3), StripesCircleOpt(.3, .7, 4.5, -.03, 32.7), StripesOpt(0.,0.,0.));\n    float h3InnerMask = min(mask, -eyesMask)-.01;\n    h3InnerMask = min(h3InnerMask, -uv.y-.1);\n    float h3StripesMask = h3InnerMask-.005;\n    h3Stripes = smin(h3Stripes, h3StripesMask, .01);\n    \n    for (float i = 0. ; i < 1. ; i += .15) {\n        vec2 r = rand2(vec2(i,.167));\n        vec2 cc = anim1(iTime*.05+i+.01*(r.x-.5));\n        mask = max(mask, circle(uv-cc, mix(.045, .05, r.y)));\n    }\n    \n    col = mix(col, vec3(.14, .21, .3), fill(mask));\n    col = mix(col, vec3(1., .32, .17), fill(h1InnerMask));\n    col = mix(col, vec3(.75, .8, .84), fill(h1Stripes));\n    col = mix(col, vec3(.83, .88, .7), fill(h2InnerMask));\n    col = mix(col, vec3(.75, .8, .84), fill(h2Stripes));\n    col = mix(col, vec3(.83, .88, .7), fill(h3InnerMask));\n    col = mix(col, vec3(0.6, 0.3, 0.6), fill(h3Stripes*.5));\n    \n    col = mix(col, topEyeLayer, fill(topEyeDist));\n    col = mix(col, bottomEyeLayer, fill(bottomEyeDist));\n    \n    dist = mask;\n    return col;\n}\n\nvec3 horn1(vec3 col, vec2 uv, float mainEye, float dh4, out float dist) {\n    vec2 uv2 = (uv-vec2(-.32,.1))*vec2(1.,1.1);\n    float mask = circle(uv2, .7);\n    mask = min(mask, -circle(uv-vec2(-.7,.3), .7));\n    mask = min(mask, circle(uv-vec2(-.45,-.2), .7));\n    \n    float cr1 = circleRing(uv2*.47, 10., .055, .065, .0, .08, .0);\n    float cr2 = circleRing(uv2*.445, 5., .045, .05, .0, .08, .27);\n    float cr3 = circleRing((uv-vec2(-.7,.3))*.66, 10., .14, .05, .0, -.08, .0);\n    \n    float innerMask = mask-mix(.008,.015,noise(uv*8.));\n    innerMask = min(innerMask, -cr2);\n    innerMask = min(innerMask, -dh4);\n    \n    float s = stripes(uv*vec2(3.,1.5)+vec2(iTime*.12,.7), StripesOpt(0.5, .3, 0.5));\n    float stripesMask = innerMask-mix(.005,.015,noise(uv*15.));\n    stripesMask = min(stripesMask, -cr1);\n    stripesMask = min(stripesMask, -cr3);\n    s = smin(s, stripesMask, .02);\n    s = min(s, -mainEye-.008);\n    s*=.7;\n    \n    col = mix(col, vec3(.14, .21, .3), fill(mask));\n    col = mix(col, vec3(.95,.9,.6), fill(innerMask));\n    col = mix(col, vec3(1.,.292,.173), fill(s));\n    dist = mask;\n    return col;\n}\n\nvec3 horn2(vec3 col, vec2 uv, float mainEye, float dh4, out float dist) {\n    uv -= vec2(-.33, .23);\n    uv = rot(3.0) * uv;\n    vec2 muv = uv;\n    muv += noise2(uv*10.)*.01;\n    \n    float mask = circle(muv, .3);\n    float innerMask = mask-.013;\n    innerMask = min(innerMask, -circle(muv, .1));\n    innerMask = min(innerMask, -dh4);\n    \n    float cr1 = circleRing(uv*1.2, 10., .05, .065, .0, -.12, .0);\n    \n    float stripesMask = innerMask-.01;\n    stripesMask = min(stripesMask, -cr1);\n    stripesMask = min(stripesMask, -mainEye-.008);\n    \n    float c = stripesCircle(uv, StripesCircleOpt(.0, .5, 2.0, -.12, 32.7), StripesOpt(.5, 0.3, 1.));\n    c = smin(c, stripesMask, .02);\n    \n    float redRing = contours(circle(muv, .1), .01);\n    \n    col = mix(col, vec3(.14, .21, .3), fill(mask));\n    col = mix(col, vec3(.95,.9,.6), fill(innerMask));\n    col = mix(col, vec3(1.,.292,.173), fill(c));\n    col = mix(col, vec3(.7,.232,.273), fill(redRing));\n    dist = mask;\n    return col;\n}\n\nvec3 horn3(vec3 col, vec2 uv, float mainEye, float subEyes) {\n    uv -= vec2(0., .31);\n    uv.xy = uv.yx;\n    vec2 muv = uv;\n    muv += noise2(uv*10.-iTime*.5)*.01;\n    \n    vec2 buv = uv;\n    float bending = max(0., -(uv.y+.5)*1.4);\n    bending += max(0., (uv.y+.4)*.7);\n    bending = bending * bending;\n    buv.x += bending;\n    float s = stripes(buv*vec2(3.,1.5)+vec2(iTime*.12,.7), StripesOpt(0.5, .3, 0.));\n    \n    float mask = circle(muv-vec2(-.3,-.5), .5);\n    float bending2 = max(0., -(uv.y+.5)*1.8);\n    bending2 += max(0., (uv.y+.5)*.7);\n    bending2 = bending2 * bending2;\n    mask = min(mask, -(uv.x+bending2));\n    mask = min(mask, uv.x+.66+uv.y*.2);\n    mask = min(mask, uv.y+.7);\n    \n    float innerMask = mask-mix(.017, .012, fit01(-.2, -.1, uv.x));\n    innerMask = smin(innerMask, -subEyes, mix(0.1, 0.01, uv.x+1.3));\n    \n    float stripesMask = innerMask-.01;\n    float eyes = max(mainEye, subEyes);\n    stripesMask = min(stripesMask, -eyes-mix(.0, .05, pow(noise(uv*10.-iTime*.1), 4.)));\n    \n    s = smin(s, stripesMask, .02);\n    \n    col = mix(col, vec3(.14, .21, .3), fill(mask));\n    col = mix(col, vec3(.292, .8, .653), fill(innerMask));\n    col = mix(col, vec3(.4,.7,1.), fill(s));\n    \n    return col;\n}\n\nvec3 horn4(vec3 col, vec2 uv, float subEyes, out float dist) {\n    vec2 cuv = rot(-.1)*(uv-vec2(-.55,-.03))+vec2(uv.y*uv.y,.0)*.7;\n    vec2 nuv = cuv + noise2(uv*7.+.2*iTime)*.015;\n    \n    float cr1 = circleRing(nuv*.85, 8., .08, .09, .0, -.12, .0);\n    float cr2 = circleRing(rot(-.42)*nuv*.85, 4., .08, .09, .0, -.12, .0);\n    \n    float mask = circle(nuv, .42);\n    float innerMask = mask-.015;\n    innerMask = min(innerMask, -circle(nuv, .1));\n    innerMask = min(innerMask, -subEyes);\n    float stripesMask = innerMask-.01;\n    \n    stripesMask = min(stripesMask, -cr1);\n    innerMask = min(innerMask, -cr2+.02);\n    \n    float c = stripesCircle(cuv, StripesCircleOpt(.0, .7, 2.9, .1, 32.7), StripesOpt(.5, 0.5, 1.));\n    c = smin(c, stripesMask, .02);\n    \n    col = mix(col, vec3(.14, .21, .3), fill(mask));\n    col = mix(col, vec3(.85, .202, .173), fill(innerMask));\n    col = mix(col, vec3(1., .32, .17), fill(c));\n    dist = mask;\n    return col;\n}\n\nvec3 horn5(vec3 col, vec2 uv, float dh4, out float dist) {\n    uv -= vec2(-.65, .32);\n    uv *= 1.5;\n    uv = rot(3.0) * uv;\n    vec2 muv = uv;\n    muv += noise2(uv*10.)*.01;\n    \n    float mask = circle(muv, .3);\n    float innerMask = mask-.017;\n    innerMask = min(innerMask, -circle(muv, .1));\n    innerMask = min(innerMask, -dh4);\n    \n    float cr1 = circleRing(uv*1.25, 10., .05, .065, .0, -.12, .0);\n    \n    float stripesMask = innerMask-.01;\n    stripesMask = min(stripesMask, -cr1);\n    \n    float c = stripesCircle(uv, StripesCircleOpt(.0, .5, 1.3, -.1, 32.7), StripesOpt(.5, 0.2, 1.));\n    c = smin(c, stripesMask, .02);\n    \n    col = mix(col, vec3(.14, .21, .3), fill(mask));\n    col = mix(col, vec3(.55,.3,.55), fill(innerMask));\n    col = mix(col, vec3(.75,.15,.25), fill(c));\n    dist = mask;\n    return col;\n}\n\nvec3 horn6(vec3 col, vec2 uv, float mainEye, out float dist) {\n    uv -= vec2(.62, -.25);\n    uv *= 1.5;\n    uv = rot(3.0) * uv;\n    vec2 muv = uv;\n    muv += noise2(uv*6.)*.02;\n    \n    float mask = circle(muv, 1.5);\n    mask = min(mask, -circle(muv, 1.1));\n    \n    float cr1 = circleRing(uv*.21, 16., .03, .035, .5, -.12, .0);\n    float cr2 = circleRing(rot(.5)*uv*.335, 6., .04, .045, .8, .12, .0);\n    float cr3 = circleRing(uv*.335, 6., .04, .045, .8, .09, .0);\n    \n    float innerMask = mask-.017;\n    innerMask = min(innerMask, -cr3);\n    \n    float stripesMask = innerMask-mix(.005, .02, noise(uv*10.));\n    stripesMask = min(stripesMask, -cr1);\n    stripesMask = min(stripesMask, -cr2-.01);\n    stripesMask = min(stripesMask, -mainEye-.002);\n    \n    float s = stripes(rot(-.5)*uv*vec2(1.3,1.)-vec2(-iTime*.03,-1.2), StripesOpt(.5, 0.5, 1.));\n    s = smin(s, stripesMask, .02);\n    \n    col = mix(col, vec3(.14, .21, .3), fill(mask));\n    col = mix(col, vec3(1., .32, .17), fill(innerMask));\n    col = mix(col, vec3(.85,.8,.25), fill(s));\n    dist = mask;\n    return col;\n}\n\nvec3 horn7(vec3 col, vec2 uv, float mainEye, out float dist) {\n    uv -= vec2(.75, .25);\n    uv = uv.yx;\n    vec2 muv = uv;\n    muv += noise2(uv*6.)*.01;\n    \n    muv = abs(muv);\n    float mask = -max(muv.x-.5, muv.y-.12);\n    \n    vec2 cruv = uv;\n    cruv -= vec2(iTime*.05, -.085);\n    float iter = floor(cruv.x / .3);\n    cruv.x = mod(cruv.x, .3)-.3/2.;\n    vec2 r = rand2(vec2(iter, .127));\n    vec2 offset = vec2(mix(-.1,.1,r.y), .0);\n    float cr1 = circle(cruv-offset, mix(.05, .06, r.x));\n    \n    float innerMask = mask-.017;\n    mask = max(mask, cr1);\n    mask = min(mask, -(muv.x-.5));\n    \n    float stripesMask = innerMask-mix(.005, .015, noise(uv*10.));\n    stripesMask = min(stripesMask, -mainEye-.002);\n    \n    float s = stripes(uv*vec2(3.,4.)-vec2(-iTime*.03,-.0), StripesOpt(.5, 0.5, 0.));\n    s = smin(s, stripesMask, .02);\n    \n    col = mix(col, vec3(.14, .21, .3), fill(mask));\n    col = mix(col, vec3(.99, .96, .73), fill(innerMask));\n    col = mix(col, vec3(.95,.82,.22), fill(s));\n    dist = mask;\n    return col;\n}\n\nvec3 horn8(vec3 col, vec2 uv, float mainEye, out float dist) {\n    uv -= vec2(.75, -.5);\n    vec2 muv = uv;\n    muv += noise2(uv*6.)*.01;\n    \n    muv.x += -.5*muv.y;\n    muv = abs(muv);\n    float mask = -max(muv.x-.26, muv.y-.11);\n    \n    float innerMask = mask-.017;\n    \n    float stripesMask = innerMask-mix(.002, .025, noise(uv*15.));\n    stripesMask = min(stripesMask, -mainEye-.002);\n    \n    float s = stripes(uv*vec2(4.,7.)-vec2(-iTime*.03,.16), StripesOpt(.5, 0.2, 0.))*.25;\n    s = smin(s, stripesMask, .02);\n    \n    col = mix(col, vec3(.14, .21, .3), fill(mask));\n    col = mix(col, vec3(.0, .3, .6), fill(innerMask));\n    col = mix(col, vec3(.65,.4,.65), fill(s));\n    dist = mask;\n    return col;\n}\n\nvec3 horn9(vec3 col, vec2 uv, float mainEye, out float dist) {\n    uv = uv * 1.5 - vec2(1., -.7);\n    uv = vec2(uv.y, -uv.x);\n    vec2 cruv = uv;\n    uv = elbow(uv);\n    uv.y += -.23;\n    \n    vec2 muv = uv;\n    muv += noise2(uv*6.)*.01;\n    muv = abs(muv);\n    float mask = -max(muv.x-.7, muv.y-.16);\n    \n    cruv -= vec2(.13,.13);\n    cruv = elbow(cruv);\n    cruv += vec2(-.1*iTime, -.26);\n    float iter = floor(cruv.x/ .3);\n    cruv.x = mod(cruv.x, .3)-.3/2.;\n    float cr1 = circle(cruv, mix(.07, .09, rand2(vec2(iter, .127)).x));\n    \n    float cr2 = circle(cruv+vec2(.1,.12), mix(.07, .09, rand2(vec2(iter, .127)).x));\n    \n    float innerMask = mask-mix(.023, .015, noise(uv*8.));\n    innerMask = min(innerMask, -cr1);\n    mask = max(mask, cr2);\n    \n    float stripesMask = innerMask-mix(.01, .02, noise(uv*10.));\n    \n    \n    float s = stripes(uv*vec2(2.,3.)-vec2(iTime*.05,-.0), StripesOpt(.65, 0.5, 0.))*.25;\n    float s2 = stripes(uv*vec2(1.,3.)-vec2(iTime*.025+.1*uv.y,-.0), StripesOpt(0., -1.3, 0.));\n    s = min(s, -s2);\n    s = smin(s, stripesMask, .01);\n    \n    col = mix(col, vec3(.14, .21, .3), fill(mask));\n    col = mix(col, vec3(.75, .8, .84), fill(innerMask));\n    col = mix(col, vec3(1., .32, .17), fill(s));\n    \n    dist = mask;\n    return col;\n}\n\nvec3 horn10(vec3 col, vec2 uv, float mainEye, out float dist) {\n    uv -= vec2(.85, .25);\n    uv = uv.yx;\n    vec2 muv = uv;\n    muv += noise2(uv*6.)*.01;\n    \n    muv = abs(muv);\n    float mask = -max(muv.x-.5, muv.y-.12);\n    \n    float innerMask = mask-.017;\n    \n    float stripesMask = innerMask-mix(.005, .015, noise(uv*10.));\n    stripesMask = min(stripesMask, -mainEye-.002);\n    \n    float s = stripes(uv*vec2(4.,4.)-vec2(iTime*.02,-.0), StripesOpt(1.5, 0.5, 0.));\n    s = smin(s, stripesMask, .02);\n    \n    col = mix(col, vec3(.14, .21, .3), fill(mask));\n    col = mix(col, vec3(.292, .8, .653), fill(innerMask));\n    col = mix(col, vec3(.4,.7,1.), fill(s));\n    dist = mask;\n    return col;\n}\n\n\nvec3 horn11(vec3 col, vec2 uv, float mainEye, out float dist) {\n    uv -= vec2(.0, -.3);\n    uv = rot(0.3) * uv;\n    vec2 muv = uv;\n    muv += noise2(uv*10.)*.01;\n    \n    float mask = circle(muv, .38);\n    float innerMask = mask-.017;\n    innerMask = min(innerMask, -circle(muv, .1));\n    \n    float cr1 = circleRing(uv*.95, 10., .05, .065, .0, -.12, .0);\n    float cr2 = circleRing(uv*1.023, 8., .05, .065, .5, .12, .0);\n    \n    mask = max(mask, cr2);\n    \n    float stripesMask = innerMask-.01;\n    stripesMask = min(stripesMask, -cr1);\n    stripesMask = min(stripesMask, -mainEye-.005);\n    \n    float c = stripesCircle(uv, StripesCircleOpt(.0, .55, 2.1, -.1, 32.7), StripesOpt(.5, .5, 1.));\n    \n    float s = stripes((rot(-1.1)*uv)*vec2(2.,3.)+vec2(-iTime*.1,.6), StripesOpt(.5, .5, 1.));\n    float limit = uv.x+uv.y*2. - .1;\n    c = mix(s, c, step(0., limit));\n    stripesMask = smin(stripesMask, -contours(limit, .015), .02);\n    \n    c = smin(c, stripesMask, .02);\n    \n    col = mix(col, vec3(.14, .21, .3), fill(mask));\n    col = mix(col, vec3(.75, .8, .84), fill(innerMask));\n    col = mix(col, vec3(1., .32, .17), fill(c));\n    dist = mask;\n    return col;\n}\n\n\nvec3 horn12(vec3 col, vec2 uv, float mainEye, out float dist) {\n    uv -= vec2(-.1, -.25);\n    uv = uv.yx;\n    vec2 muv = uv;\n    muv += noise2(uv*6.)*.01;\n    \n    muv = abs(muv);\n    float mask = -max(muv.x-.5, muv.y-.12);\n    \n    vec2 cruv = uv;\n    cruv -= vec2(iTime*.05, .08);\n    float iter = floor(cruv.x / .3);\n    cruv.x = mod(cruv.x, .3)-.3/2.;\n    float cr1 = circle(cruv, mix(.05, .06, rand2(vec2(iter, .127)).x));\n    \n    float innerMask = mask-.017;\n    mask = max(mask, cr1);\n    mask = min(mask, -(muv.x-.5));\n    \n    float stripesMask = innerMask-mix(.005, .015, noise(uv*10.));\n    stripesMask = min(stripesMask, -mainEye-.002);\n    \n    float s = stripes(uv*vec2(4.,4.)-vec2(iTime*.02,-.0), StripesOpt(.7, 0.5, 1.));\n    s = smin(s, stripesMask, .02);\n    \n    col = mix(col, vec3(.14, .21, .3), fill(mask));\n    col = mix(col, vec3(1., .37, .3), fill(innerMask));\n    col = mix(col, vec3(.5,.9,.3), fill(s*.5));\n    \n    dist = mask;\n    return col;\n}\n\nvec3 horn13(vec3 col, vec2 uv, float bg, out float dist) {\n    uv -= vec2(.0,.3);\n    float innerMask = -bg+.004;\n    innerMask = min(innerMask, uv.x);\n    float stripesMask = innerMask-mix(.005, .02, noise(uv*10.+iTime));\n    float s = stripes(uv*vec2(3.,1.)+vec2(-iTime*.05,0.), StripesOpt(.9,.5,.0));\n    s = smin(s, stripesMask, .02);\n    \n    col = mix(col, vec3(1., .37, .3), fill(innerMask));\n    col = mix(col, vec3(.65,.4,.65), fill(s));\n    \n    dist = innerMask;\n    return col;\n}\n\nvec3 horn14(vec3 col, vec2 uv, float mainEye, float dh15, out float dist) {\n    uv -= vec2(.445,.0);\n    float mask = circle(uv+vec2(.0,-.7*uv.x*uv.x)-noise2(uv*10.+iTime*.1)*.01, .2);\n    float innerMask = mask-.013;\n    float stripesMask = innerMask-mix(.005, .02, noise(uv*10.+iTime));\n    float s = stripes(uv*vec2(3.3,1.)+vec2(iTime*.03,0.), StripesOpt(.9,.3,.0));\n    stripesMask = min(stripesMask, -mainEye-.005);\n    stripesMask = min(stripesMask, -dh15-.005);\n    s = smin(s, stripesMask, .02);\n    \n    col = mix(col, vec3(.14, .21, .3), fill(mask));\n    col = mix(col, vec3(.1, .3, .5), fill(innerMask));\n    col = mix(col, vec3(0.9, 0.8, 0.2), fill(s));\n    \n    dist = mask;\n    return col;\n}\n\nvec3 horn15(vec3 col, vec2 uv, float mainEye, out float dist) {\n    uv -= vec2(.445,-.1);\n    float mask = circle(uv+vec2(.0,-.7*uv.x*uv.x)+noise2(uv*9.-iTime*.15)*.02, .2);\n    float innerMask = mask;//-.013;\n    float stripesMask = innerMask-mix(.005, .02, noise(uv*10.+iTime));\n    \n    float bending = max(0., uv.y-.0);\n    bending = bending * bending * smoothstep(.05, .15, uv.x);\n    uv.x += -1.*bending;\n    \n    float s = stripes(uv*vec2(3.8,1.)+vec2(-iTime*.03,0.), StripesOpt(.9,.3,.0))*.5;\n    stripesMask = min(stripesMask, -mainEye-.005);\n    s = smin(s, stripesMask, .01);\n    \n    col = mix(col, vec3(1., .9, .65), fill(innerMask));\n    col = mix(col, vec3(1., .37, .3), fill(s));\n    \n    dist = innerMask;\n    return col;\n}\n\nvec3 horn16(vec3 col, vec2 uv, float mainEye, out float dist) {\n    uv -= vec2(.525,-.15);\n    vec2 cuv = uv+vec2(.0,-.7*uv.x*uv.x)+noise2(uv*9.-iTime*.15)*.01;\n    float mask = circle(cuv, .12);\n    \n    mask = max(mask, -max(abs(cuv.x+.12)-.12, abs(cuv.y)-.12));\n    mask = max(mask, -max(abs(cuv.x)-.12, abs(cuv.y+.12)-.12));\n    \n    float innerMask = mask-.013;\n    mask = -smin(-mask, -mainEye, .05);\n    \n    float stripesMask = innerMask-mix(.005, .02, noise(uv*10.+iTime));\n    innerMask = smin(innerMask, -mainEye, .01);\n    \n    float s = stripes(uv*vec2(3.8,1.)+vec2(-iTime*.03,0.), StripesOpt(.9,.3,.0))*.5;\n    stripesMask = min(stripesMask, -mainEye-.005);\n    s = smin(s, stripesMask, .01);\n    \n    col = mix(col, vec3(.14, .21, .3), fill(mask));\n    col = mix(col, vec3(.292, .8, .653), fill(innerMask));\n    col = mix(col, vec3(.4,.7,1.), fill(s));\n    \n    dist = mask;\n    return col;\n}\n\nvec3 horn17(vec3 col, vec2 uv, float mainEye, float dh11, float dh9, out float dist) {\n    uv -= vec2(.525,-.25);\n    vec2 cuv = uv+vec2(.0,-.7*uv.x*uv.x)+noise2(uv*9.-iTime*.15)*.005;\n    float mask = circle(cuv, .12);\n    \n    mask = max(mask, -max(abs(cuv.x+.12)-.12, abs(cuv.y)-.12));\n    mask = max(mask, -max(abs(cuv.x)-.12, abs(cuv.y+.12)-.12));\n    mask = max(mask, -max(abs(cuv.x)-.25, abs(cuv.y+.2)-.2));\n    \n    float innerMask = mask-.013;\n    mask = -smin(-mask, -mainEye, .05);\n    \n    float stripesMask = innerMask-mix(.005, .015, noise(uv*10.+iTime));\n    innerMask = smin(innerMask, -mainEye, .01);\n    \n    float s = stripes((rot(-.3)*uv)*vec2(3.4,1.)+vec2(-iTime*.03,0.), StripesOpt(.9,.5,.0))*.25;\n    stripesMask = min(stripesMask, -mainEye-.005);\n    float sides = max(dh11, dh9);\n    stripesMask = min(stripesMask, -sides-mix(.0, .01, noise2(uv*10.).x));\n    s = smin(s, stripesMask, .005);\n    \n    col = mix(col, vec3(.14, .21, .3), fill(mask));\n    col = mix(col, vec3(.8, .2, .15), fill(innerMask));\n    col = mix(col, vec3(.95,.8,.1), fill(s));\n    \n    dist = mask;\n    return col;\n}\n\nvec3 horn18(vec3 col, vec2 uv, out float dist) {\n    uv -= vec2(.965,-.12);\n    vec2 cuv = uv+vec2(.0,-.7*uv.x*uv.x)+noise2(uv*9.-iTime*.15)*.01;\n    float mask = circle(cuv, .12);\n    \n    mask = max(mask, -max(abs(cuv.x-.12)-.12, abs(cuv.y)-.12));\n    mask = max(mask, -max(abs(cuv.x)-.12, abs(cuv.y+.12)-.12));\n    \n    float innerMask = mask-.013;\n    \n    float stripesMask = innerMask-mix(.005, .02, noise(uv*10.+iTime));\n    \n    float s = stripes(uv*vec2(3.8,1.)+vec2(-iTime*.03,0.), StripesOpt(.9,.3,.0))*.5;\n    s = smin(s, stripesMask, .01);\n    \n    col = mix(col, vec3(.14, .21, .3), fill(mask));\n    col = mix(col, vec3(.75, .8, .84), fill(innerMask));\n    col = mix(col, vec3(.4,.7,1.), fill(s));\n    \n    dist = mask;\n    return col;\n}\n\nvec3 dots(vec3 col, vec2 uv, out float dist) {\n    vec2 n = noise2(uv*5.+iTime*.4)*.01;\n    dist = circle(uv+noise2(uv*10.+.5)*.05+n-vec2(-.82,.33), .045);\n    dist = max(dist, circle(uv-vec2(-.9,.2), .1));\n    dist = max(dist, circle(uv+noise2(uv*10.+1.7)*.02+n-vec2(-.5,.49), .045));\n    dist = max(dist, circle(uv+noise2(uv*10.+2.7)*.02+n-vec2(-.1,.46), .042));\n    col = mix(col, vec3(.14, .21, .3), fill(dist));\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord/iResolution.xy-.5)*iResolution.xy/iResolution.y;\n    vec2 mouse = (iMouse.xy/iResolution.xy-.5)*iResolution.xy/iResolution.y;\n    \n    if (iMouse.xy == vec2(0.)) {\n        mouse = vec2(0.,0.17);\n    }\n    \n    float mainEye, subEyes;\n    vec3 mainEyeLayer = drawMainEye(vec3(0.), uv, mouse, mainEye);\n    vec3 subEyesLayer = drawSubEyes(vec3(0.), uv, mouse, subEyes);\n    \n    float backgroundRing = stripesCircle(uv, StripesCircleOpt(.4, .95, 6.5, -.1, 32.7), StripesOpt(.5, 0., 1.));\n    \n    float d, dist = -999.;\n    float dh15, dh11, dh9, dh4;\n    \n    vec3 horn15Layer = horn15(vec3(0.), uv, mainEye, dh15);\n    vec3 horn11Layer = horn11(vec3(0.), uv, mainEye, dh11);\n    vec3 horn9Layer = horn9(vec3(0.), uv, mainEye, dh9);\n    vec3 horn4Layer = horn4(vec3(0.), uv, subEyes, dh4);\n    \n    vec3 col = vec3(1.);\n    col = dots(col, uv, d); dist = max(dist, d);\n    col = horn14(col, uv, mainEye, dh15, d); dist = max(dist, d);\n    col = mix(col, horn15Layer, fill(dh15)); dist = max(dist, dh15);\n    col = horn16(col, uv, mainEye, d); dist = max(dist, d);\n    col = horn17(col, uv, mainEye, dh11, dh9, d); dist = max(dist, d);\n    col = horn6(col, uv, mainEye, d); dist = max(dist, d);\n    col = mix(col, horn11Layer, fill(dh11)); dist = max(dist, dh11);\n    col = horn12(col, uv, mainEye, d); dist = max(dist, d);\n    col = horn1(col, uv, mainEye, dh4, d); dist = max(dist, d);\n    col = horn5(col, uv, dh4, d); dist = max(dist, d);\n    col = horn2(col, uv, mainEye, dh4, d); dist = max(dist, d);\n    col = mix(col, horn4Layer, fill(dh4)); dist = max(dist, dh4);\n    col = horn3(col, uv, mainEye, subEyes);\n    col = horn10(col, uv, mainEye, d); dist = max(dist, d);\n    col = horn18(col, uv, d); dist = max(dist, d);\n    col = mix(col, horn9Layer, fill(dh9)); dist = max(dist, dh9);\n    col = horn8(col, uv, mainEye, d); dist = max(dist, d);\n    col = horn13(col, uv, dist, d); dist = max(dist, d);\n    col = horn7(col, uv, mainEye, d); dist = max(dist, d);\n    col = mix(col, mainEyeLayer, fill(mainEye)); dist = max(dist, mainEye);\n    col = mix(col, subEyesLayer, fill(subEyes)); dist = max(dist, subEyes);\n    \n    col = mix(col, vec3(.14, .21, .3), fill(-dist-mix(.005, .02, noise(uv*10.))));\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tdjSDw.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[199, 199, 222, 222, 360], [362, 362, 384, 384, 732], [733, 733, 755, 755, 778], [780, 780, 830, 830, 993], [995, 995, 1016, 1016, 1203], [1205, 1205, 1246, 1246, 1330], [1332, 1332, 1451, 1451, 1798], [1800, 1800, 1875, 1875, 2004], [2086, 2086, 2126, 2126, 2821], [2823, 2823, 2844, 2844, 2882], [2884, 2884, 2924, 2924, 2969], [3091, 3091, 3160, 3160, 3317], [3319, 3319, 3368, 3368, 3475], [3477, 3477, 3526, 3526, 3638], [3640, 3640, 3689, 3689, 3797], [3799, 3799, 3848, 3848, 3956], [3958, 3958, 3990, 3990, 4022], [4024, 4024, 4070, 4070, 4107], [4109, 4109, 4151, 4151, 4239], [4241, 4241, 4264, 4264, 4348], [4350, 4350, 4439, 4439, 4522], [4524, 4524, 4589, 4589, 7838], [7840, 7840, 7918, 7918, 9526], [9528, 9647, 9671, 9671, 10412], [10414, 10414, 10479, 10479, 12691], [12693, 12693, 12766, 12766, 13819], [13821, 13821, 13894, 13894, 14811], [14813, 14813, 14874, 14874, 16047], [16049, 16049, 16111, 16111, 17008], [17010, 17010, 17068, 17068, 17837], [17839, 17839, 17901, 17901, 18923], [18925, 18925, 18987, 18987, 19966], [19968, 19968, 20030, 20030, 20682], [20684, 20684, 20746, 20746, 21960], [21962, 21962, 22025, 22025, 22666], [22669, 22669, 22732, 22732, 23841], [23844, 23844, 23907, 23907, 24819], [24821, 24821, 24879, 24879, 25312], [25314, 25314, 25389, 25389, 26019], [26021, 26021, 26084, 26084, 26761], [26763, 26763, 26826, 26826, 27670], [27672, 27672, 27758, 27758, 28786], [28788, 28788, 28836, 28836, 29539], [29541, 29541, 29587, 29587, 29975], [29977, 29977, 30034, 30034, 32328]], "test": "timeout"}
{"id": "tdjSR1", "name": "Finals2 - Blue Flame", "author": "EmperorLem", "description": "blue flame using noise", "tags": ["flame"], "likes": 4, "viewed": 104, "published": "Public", "date": "1554865223", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec3 brown = vec3(0.3,0.2,0.2);\nvec3 black = vec3(0.0,0.0,0.0);\nvec3 red = vec3(0.7,0.0,0.0);\nvec3 blue = vec3(0.,.4,1.0);\nvec3 yellow = vec3(1.0,1.0,0.0);\nvec3 green = vec3(0.1,0.9,0.0);\nvec3 white = vec3(1.0,1.0,1.0);\n\nfloat rand(vec2 uv)\n{\n    //return fract(sin(dot(uv, vec2(12.9898,78.233)))*10000.*iTime);\n\t//return fract(sin(dot(uv, iMouse.xy))*10000.);\n\t//return (fract(sin(dot(uv, vec2(12., 70.)))*100000.));\n    return (fract(sin(dot(uv, vec2(12., 70.)))*43758.5453123));\n}\n\n// Value noise\nfloat noise(in vec2 st) {\n    vec2 i = floor(st);\n    vec2 f = fract(st);\n\n    // Four corners in 2D of a tile\n    float a = rand(i);\n    float b = rand(i + vec2(1.0, 0.0));\n    float c = rand(i + vec2(0.0, 1.0));\n    float d = rand(i + vec2(1.0, 1.0));\n\n    // Smooth Interpolation\n\n    // Cubic Hermine Curve.  Same as SmoothStep()\n    vec2 u = f*f*(3.0-2.0*f);\n    // u = smoothstep(0.,1.,f);\n\n    // Mix 4 coorners porcentages\n    return mix(a, b, u.x) + \n            (c - a)* u.y * (1.0 - u.x) + \n            (d - b) * u.x * u.y;\n}\n\n// Gradient noise\nvec2 hash( vec2 x )  // replace this by something better\n{\n    const vec2 k = vec2( 0.3183099, 0.3678794 );\n    x = x*k + k.yx;\n    return -1.0 + 2.0*fract( 16.0 * k*fract( x.x*x.y*(x.x+x.y)) );\n}\n\nfloat gnoise( in vec2 p )\n{\n    vec2 i = floor( p );\n    vec2 f = fract( p );\n\t\n\tvec2 u = f*f*(3.0-2.0*f);\n\n    return mix( mix( dot( hash( i + vec2(0.0,0.0) ), f - vec2(0.0,0.0) ), \n                     dot( hash( i + vec2(1.0,0.0) ), f - vec2(1.0,0.0) ), u.x),\n                mix( dot( hash( i + vec2(0.0,1.0) ), f - vec2(0.0,1.0) ), \n                     dot( hash( i + vec2(1.0,1.0) ), f - vec2(1.0,1.0) ), u.x), u.y);\n}\n\n// Simplex noise\nvec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec2 mod289(vec2 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec3 permute(vec3 x) { return mod289(((x*34.0)+1.0)*x); }\n\nfloat snoise(vec2 v) {\n    const vec4 C = vec4(0.211324865405187,  // (3.0-sqrt(3.0))/6.0\n                        0.366025403784439,  // 0.5*(sqrt(3.0)-1.0)\n                        -0.577350269189626,  // -1.0 + 2.0 * C.x\n                        0.024390243902439); // 1.0 / 41.0\n    vec2 i  = floor(v + dot(v, C.yy) );\n    vec2 x0 = v -   i + dot(i, C.xx);\n    vec2 i1;\n    i1 = (x0.x > x0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);\n    vec4 x12 = x0.xyxy + C.xxzz;\n    x12.xy -= i1;\n    i = mod289(i); // Avoid truncation effects in permutation\n    vec3 p = permute( permute( i.y + vec3(0.0, i1.y, 1.0 ))\n        + i.x + vec3(0.0, i1.x, 1.0 ));\n\n    vec3 m = max(0.5 - vec3(dot(x0,x0), dot(x12.xy,x12.xy), dot(x12.zw,x12.zw)), 0.0);\n    m = m*m ;\n    m = m*m ;\n    vec3 x = 2.0 * fract(p * C.www) - 1.0;\n    vec3 h = abs(x) - 0.5;\n    vec3 ox = floor(x + 0.5);\n    vec3 a0 = x - ox;\n    m *= 1.79284291400159 - 0.85373472095314 * ( a0*a0 + h*h );\n    vec3 g;\n    g.x  = a0.x  * x0.x  + h.x  * x0.y;\n    g.yz = a0.yz * x12.xz + h.yz * x12.yw;\n    return 130.0 * dot(m, g);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    float zoom = 8.0;\n    float scale = 0.02;\n    \n    float flame = noise(uv*10.+vec2(.0, -iTime*10.))*.1;\n    \n    float newFlame = noise(uv*10.+vec2(0.0,iTime*10.))*.1;\n    \n    float wave = gnoise(uv + iTime * 1.0) * 0.5;\n    \n    //scene = step(0.6 - offset, uv.x) - step(0.6 + offset, uv.x);\n    //value = offset;\n    //value = mix(scene, value, step(0.5, uv.x));\n    \n    wave = step(-1.0 - wave, uv.y) - step(0.8 - wave, uv.y);\n    flame = smoothstep(0.5 - flame, 0.0, uv.y) + smoothstep(0.9 - flame, 0.0, uv.y);\n   \n    newFlame = smoothstep(0.2 - newFlame, 0.2, uv.y) + smoothstep(0.4 - newFlame, 0.0,uv.y);\n    \n    \n    \n    //float value = mix(offset, scene, uv.y);\n    \n\n    // Output to screen\n    fragColor = vec4(vec3((flame * blue) * (newFlame * white)),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tdjSR1.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[221, 221, 242, 417, 483], [485, 500, 525, 525, 1036], [1038, 1056, 1114, 1114, 1252], [1254, 1254, 1281, 1281, 1679], [1681, 1698, 1719, 1719, 1766], [1767, 1767, 1788, 1788, 1835], [1836, 1836, 1858, 1858, 1893], [1895, 1895, 1917, 1917, 2965], [2968, 2968, 3025, 3075, 3900]], "test": "ok"}
{"id": "tdjSWm", "name": "Divison multiplex2", "author": "tristanwhitehill", "description": "simple explorations", "tags": ["simple"], "likes": 3, "viewed": 123, "published": "Public", "date": "1554094987", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n \n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 r = vec2( fragCoord.xy - 0.5*iResolution.xy );\n\t\n\tr = 3.0 * r.xy / iResolution.xy;\n  \n    vec3 col1 = vec3 (0.2,0.2,.2);\n    vec3 col2 = vec3 (0.0,0.8,.9);\n     vec3 col3 = vec3 (.7,.7,.7);\n    vec3 pixi;\n    \n    float width = (sin(.2 * iTime)*50.);\n    float width2 = sin(.003 * iTime)*3.;\n    float mody = mod(width/width2,floor(cos(r.x+iTime)*10.));\n    if(r.y > mody-width*(sin(.3*iTime)*.3)){\n        \n        pixi = col1;\n        \n    \t}\n    else {\n        \n        pixi = col2;\n    \n        }\n      if(r.y < mody*(cos(.03*iTime)/10.)){\n        \n        pixi = col3;\n        \n    \t}\n\n    fragColor = vec4((pixi-sin(r.x)/-mody),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tdjSWm.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 750]], "test": "ok"}
{"id": "tdjXDd", "name": "Color arcs", "author": "avin", "description": "Basic arcs demo", "tags": ["arcs", "multicolor"], "likes": 36, "viewed": 1002, "published": "Public API", "date": "1555413592", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI 3.1415926\n#define TAU 6.2831852\n#define BLACK_COL vec3(24,32,38)/255.\n\n#define rand1(p) fract(sin(p* 78.233)* 43758.5453) \n#define hue(h) clamp( abs( fract(h + vec4(3,2,1,0)/3.) * 6. - 3.) -1. , 0., 1.)\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{    \n    vec2 uv = (fragCoord.xy-iResolution.xy*0.5)/iResolution.y;\n\n    float SIZE = 4. + cos(iTime*0.2)*0.5;\n    float r = length(uv) * SIZE;\n    r*=10.0;\n    float id = ceil(r);\n    float s = mod(id, 2.)*2. - 1.; // Direction\n    float a = fract(atan(uv.y, uv.x)/TAU + s*(iTime*(rand1(id+400.)*0.5+0.5)*0.2 + id*0.2));\n    float inRange = step(3.,id); // Don's draw center arcs    \n    float sm = (1./iResolution.y * 20.* SIZE);    \n    \n    inRange *= smoothstep(.0, sm, fract(r)) * smoothstep(1.0, 1.0 - sm, fract(r));\n    float arcLength =  (rand1(id)*0.25 + 0.25);\n    \n    sm = (sqrt(SIZE)*(1./iResolution.y * 5. / id));\n    inRange *= smoothstep(arcLength, arcLength + sm, a) * smoothstep(1.0, 1. - sm, a);\n        \n    vec3 col = hue(rand1(id)).rgb;\n    \n    col = mix(BLACK_COL, col, inRange);\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tdjXDd.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[215, 215, 272, 272, 1114]], "test": "ok"}
{"id": "tdjXWm", "name": "Panomera Apollonian ", "author": "smkgames", "description": "Panomera Apollonian ", "tags": ["3d", "raymarching", "fractal", "distancefield", "kleinian", "apollonian", "vr", "panomera"], "likes": 2, "viewed": 164, "published": "Public", "date": "1554101244", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n\n#define AA 1\n\nvec4 orb; \nvec4 brg;\n\nfloat map( vec3 p, float s )\n{\n\tfloat scale = 1.0;\n\n\torb = vec4(1000.0); \n\tbrg = vec4(1000.0); \n\tfor( int i=0; i<8;i++ )\n\t{\n\t\tp = -1.0 + 2.0*fract(0.5*p+0.5);\n\n\t\tfloat r2 = dot(p,p);\n\t\t\n        orb = min( orb, vec4(abs(p),r2) );\n        brg = max( orb, vec4(abs(p),r2) )/4.;\n\t\t\n\t\tfloat k = s/r2;\n\t\tp     *= k;\n\t\tscale *= k;\n\t}\n\t\n\treturn 0.25*abs(p.y)/scale;\n}\n\nvec3 hsv2rgb( in vec3 c ) {\n  vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n  rgb = rgb*rgb*(3.0-2.0*rgb); // cubic smoothing\t\n  return c.z * mix( vec3(1.0), rgb, c.y);\n}\n\nvec3 getCol(vec3 n){\n  return hsv2rgb(vec3(mod(n.z*.5,1.0),0.9,0.9));\n}\n\nvec2 fragCoordinate;\nvec3 panomeraRay(){\n    \n    vec2 pix=( fragCoordinate.xy*2.0 - iResolution.xy) / iResolution.x;\n\t\n    vec3 camP=vec3(\n        0.05 * sin(iTime*0.2 ),\n        0.05 * sin(iTime*0.15 ),\n        0.1*iTime\n    );\n\n\tvec3 camC= camP + vec3(\n        0.3 * sin(iTime*0.05),\n        0.3 * sin(iTime*0.06),\n        1.);\n\n    vec3 camA=vec3(0.3*sin(iTime*0.03),0.8,0.);\n\tvec3 camS=cross(normalize(camC-camP),camA);\n\tvec3 camU=cross(camS,normalize(camC-camP));\n    \n    vec3 camF = normalize(camC-camP );\n\n    // panoramic projection by aiming rays using angles\n    vec3 ray=normalize(\n        camS*sin(pix.x*3.5) + camF*cos(pix.x*3.5) +\n        camU*pix.y*3.14\n    );\n         \n    vec3 rayP=camP;\n    return ray;\n}\n\nfloat trace( in vec3 ro, in vec3 rd, float s )\n{\n\tfloat maxd = 30.0;\n    float t = 0.01;\n    for( int i=0; i<200; i++ )\n    {\n\t    float precis = 0.001 * t;\n        \n\t    float h = map( ro+rd*t, s );\n        if( h<precis||t>maxd ) break;\n        t += h;\n    }\n\n    if( t>maxd ) t=-1.0;\n    return t;\n}\n\nvec3 calcNormal( in vec3 pos, in float t, in float s )\n{\n    float precis = 0.001 * t;\n\n    vec2 e = vec2(1.0,-1.0)*precis;\n    return normalize( e.xyy*map( pos + e.xyy, s ) + \n\t\t\t\t\t  e.yyx*map( pos + e.yyx, s ) + \n\t\t\t\t\t  e.yxy*map( pos + e.yxy, s ) + \n                      e.xxx*map( pos + e.xxx, s ) );\n}\n\nvec3 render( in vec3 ro, in vec3 rd, in float anim )\n{\n\n    // trace\t\n    vec3 col = vec3(0.0);\n    float t = trace( ro, panomeraRay(), anim );\n    if( t>0.0 )\n    {\n        vec4 tra = orb;\n        vec4 art = brg;\n        vec3 pos = ro + t*rd;\n        \n\n        \n        vec3 nor = calcNormal( pos, t, anim );\n\n        // lighting\n        vec3  light1 = vec3(  0.577, 0.577, -0.577 );\n        vec3  light2 = vec3( -0.707, 0.000,  0.707 );\n        float key = clamp( dot( light1, nor ), 0.0, 1.0 );\n        float bac = clamp( 0.2 + 0.8*dot( light2, nor ), 0.0, 1.0 );\n        float amb = (0.7+0.3*nor.y);\n        float ao = pow( clamp(tra.w*2.0,0.0,1.0), 1.2 );\n\n        vec3 brdf  = 1.0*vec3(0.40,0.40,0.40)*amb*ao;\n        brdf += 1.0*vec3(1.00,1.00,1.00)*key*ao;\n        brdf += 1.0*vec3(0.40,0.40,0.40)*bac*ao;\n\n       vec3 colorful =getCol(vec3(t));\n        // material\t\t\n        vec3 rgb = vec3(1.0);\n       // rgb = mix( rgb, colorful, clamp(6.0*tra.y,0.0,1.0) );\n      //  rgb = mix( rgb, colorful, pow(clamp(1.0-2.0*tra.z,0.0,1.0),8.0) );\n       \trgb = mix(rgb,colorful,art.y*5.);\n        // color\n        col = rgb*brdf*exp(-0.2*t);\n    }\n\n    return sqrt(col);\n}\n\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragCoordinate = fragCoord;\n    float time = iTime*0.25 + 0.01*iMouse.x;\n    float anim = 1.1 + 0.5*smoothstep( -0.3, 0.3, cos(0.1*iTime) );\n    \n    vec3 tot = vec3(0.0);\n    #if AA>1\n    for( int jj=0; jj<AA; jj++ )\n    for( int ii=0; ii<AA; ii++ )\n    #else\n    int ii = 1, jj = 1;\n    #endif\n    {\n        vec2 q = fragCoord.xy+vec2(float(ii),float(jj))/float(AA);\n        vec2 p = (2.0*q-iResolution.xy)/iResolution.y;\n\n        // camera\n        vec3 ro = vec3( 1., 1., 2.8*cos(0.5+0.35*time) );\n        vec3 ta = vec3( 1., 1., 1.9*cos(2.0+0.38*time) );\n        float roll = 0.2*cos(0.1*time);\n        vec3 cw = normalize(ta-ro);\n        vec3 cp = vec3(sin(roll), cos(roll),0.0);\n        vec3 cu = normalize(cross(cw,cp));\n        vec3 cv = normalize(cross(cu,cw));\n        vec3 rd = normalize( p.x*cu + p.y*cv + 2.0*cw );\n\n        tot += render( ro, panomeraRay(), anim );\n    }\n    \n    tot = tot/float(AA*AA);\n    \n\tfragColor = vec4( tot, 1.0 );\t\n\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tdjXWm.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[38, 38, 68, 68, 397], [399, 399, 426, 426, 602], [604, 604, 624, 624, 675], [698, 698, 717, 717, 1402], [1404, 1404, 1452, 1452, 1705], [1707, 1707, 1763, 1763, 2014], [2016, 2016, 2070, 2085, 3188]], "test": "ok"}
{"id": "tdSXRc", "name": "Icosahedron/Dodecahedron", "author": "CelestialAmber", "description": "Modification of a glitch transformation shader between a dodecahedron and icosahedron https://www.shadertoy.com/view/XtyXzW", "tags": ["icosahedron", "dodecahedron"], "likes": 5, "viewed": 669, "published": "Public API", "date": "1554479515", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define MODEL_ROTATION vec2(.5, .5)\n#define LIGHT_ROTATION vec2(.3, .8)\n#define CAMERA_ROTATION vec2(.5, .67)\n\n// Mouse control\n// 0: Defaults\n// 1: Model\n// 2: Lighting\n// 3: Camera\n#define MOUSE_CONTROL 1\n\n// Debugging\n//#define NORMALS\n\n\n//sets what model to use. 0 is dodecahedron, 1 is icosahedron\n#define usedModel 1\n\nfloat time;\n\nfloat _round(float n) {\n    return floor(n + .5);\n}\n\nvec2 _round(vec2 n) {\n    return floor(n + .5);\n}\n\n// --------------------------------------------------------\n// HG_SDF\n// https://www.shadertoy.com/view/Xs3GRB\n// --------------------------------------------------------\n\n#define PI 3.14159265359\n#define PHI (1.618033988749895)\n#define TAU 6.283185307179586\n\nfloat vmax(vec3 v) {\n    return max(max(v.x, v.y), v.z);\n}\n\n// Rotate around a coordinate axis (i.e. in a plane perpendicular to that axis) by angle <a>.\n// Read like this: R(p.xz, a) rotates \"x towards z\".\n// This is fast if <a> is a compile-time constant and slower (but still practical) if not.\nvoid pR(inout vec2 p, float a) {\n    p = cos(a)*p + sin(a)*vec2(p.y, -p.x);\n}\n\n// Plane with normal n (n is normalized) at some distance from the origin\nfloat fPlane(vec3 p, vec3 n, float distanceFromOrigin) {\n    return dot(p, n) + distanceFromOrigin;\n}\n\n// Box: correct distance to corners\nfloat fBox(vec3 p, vec3 b) {\n    vec3 d = abs(p) - b;\n    return length(max(d, vec3(0))) + vmax(min(d, vec3(0)));\n}\n\n\n#define GDFVector3 normalize(vec3(1, 1, 1 ))\n#define GDFVector4 normalize(vec3(-1, 1, 1))\n#define GDFVector5 normalize(vec3(1, -1, 1))\n#define GDFVector6 normalize(vec3(1, 1, -1))\n\n#define GDFVector7 normalize(vec3(0, 1, PHI+1.))\n#define GDFVector8 normalize(vec3(0, -1, PHI+1.))\n#define GDFVector9 normalize(vec3(PHI+1., 0, 1))\n#define GDFVector10 normalize(vec3(-PHI-1., 0, 1))\n#define GDFVector11 normalize(vec3(1, PHI+1., 0))\n#define GDFVector12 normalize(vec3(-1, PHI+1., 0))\n\n#define GDFVector13 normalize(vec3(0, PHI, 1))\n#define GDFVector14 normalize(vec3(0, -PHI, 1))\n#define GDFVector15 normalize(vec3(1, 0, PHI))\n#define GDFVector16 normalize(vec3(-1, 0, PHI))\n#define GDFVector17 normalize(vec3(PHI, 1, 0))\n#define GDFVector18 normalize(vec3(-PHI, 1, 0))\n\n#define fGDFBegin float d = 0.;\n#define fGDF(v) d = max(d, abs(dot(p, v)));\n#define fGDFEnd return d - r;\n\nfloat fDodecahedron(vec3 p, float r) {\n    fGDFBegin\n    fGDF(GDFVector13) fGDF(GDFVector14) fGDF(GDFVector15) fGDF(GDFVector16)\n    fGDF(GDFVector17) fGDF(GDFVector18)\n    fGDFEnd\n}\n\nfloat fIcosahedron(vec3 p, float r) {\n    fGDFBegin\n    fGDF(GDFVector3) fGDF(GDFVector4) fGDF(GDFVector5) fGDF(GDFVector6)\n    fGDF(GDFVector7) fGDF(GDFVector8) fGDF(GDFVector9) fGDF(GDFVector10)\n    fGDF(GDFVector11) fGDF(GDFVector12)\n    fGDFEnd\n}\n\n\n// --------------------------------------------------------\n// Rotation\n// --------------------------------------------------------\n\nmat3 sphericalMatrix(float theta, float phi) {\n    float cx = cos(theta);\n    float cy = cos(phi);\n    float sx = sin(theta);\n    float sy = sin(phi);\n    return mat3(\n        cy, -sy * -sx, -sy * cx,\n        0, cx, sx,\n        sy, cy * -sx, cy * cx\n    );\n}\n\nmat3 mouseRotation(bool enable, vec2 xy) {\n    if (enable) {\n        vec2 mouse = iMouse.xy / iResolution.xy;\n\n        if (mouse.x != 0. && mouse.y != 0.) {\n            xy.x = mouse.x;\n            xy.y = mouse.y;\n        }\n    }\n    float rx, ry;\n    \n    rx = (xy.y + .5) * PI;\n    ry = (-xy.x) * 2. * PI;\n    \n    return sphericalMatrix(rx, ry);\n}\n\nmat3 modelRotation() {\n    mat3 m = mouseRotation(MOUSE_CONTROL==1, MODEL_ROTATION);\n    return m;\n}\n\nmat3 lightRotation() {\n    mat3 m = mouseRotation(MOUSE_CONTROL==2, LIGHT_ROTATION);\n    return m;\n}\n\nmat3 cameraRotation() {\n    mat3 m = mouseRotation(MOUSE_CONTROL==3, CAMERA_ROTATION);\n    return m;\n}\n\n\n// --------------------------------------------------------\n// Modelling \n// --------------------------------------------------------\n\nstruct Material {\n    vec3 albedo;\n};\n\nstruct Model {\n    float dist;\n    Material material;\n};\n\nMaterial defaultMaterial = Material(\n    vec3(.5)\n);  \n\nModel newModel() {\n    return Model(\n        10000.,\n        defaultMaterial\n    );\n}\n\nconst float modelSize = 1.2;\n\n\nfloat Flip() {\n\treturn round(mod(time, 1.));\n}\n\nModel mainModel(vec3 p) {\n    \n    Model model = newModel();\n   \n    float flip = Flip();\n    \n    pR(p.xz, PI * flip);\n    float modelToUse;\n    if(usedModel == 0) modelToUse =  fDodecahedron(p, modelSize * .5);\n      else   modelToUse = fIcosahedron(p, modelSize * .5);\n        \n    \n    pR(p.xz, PI/2.);\n   \n    float d = modelToUse;\n\n    model.dist = d;\n    model.material.albedo = mix(vec3(.03), vec3(.8), 1.);\n\n    return model;\n}\n\n\nModel map( vec3 p , bool glitchMask){\n    mat3 m = modelRotation();\n    p *= m;\n    pR(p.xz, -time*PI);\n    Model model = mainModel(p);\n    return model;\n}\n\n\n// --------------------------------------------------------\n// LIGHTING\n// https://www.shadertoy.com/view/Xds3zN\n// --------------------------------------------------------\n\nfloat softshadow( in vec3 ro, in vec3 rd, in float mint, in float tmax )\n{\n    float res = 1.0;\n    float t = mint;\n    for( int i=0; i<16; i++ )\n    {\n        float h = map( ro + rd*t, false ).dist;\n        res = min( res, 8.0*h/t );\n        t += clamp( h, 0.02, 0.10 );\n        if( h<0.00001 || t>tmax ) break;\n    }\n    return clamp( res, 0.0, 1.0 );\n}\n\nfloat calcAO( in vec3 pos, in vec3 nor )\n{\n    float occ = 0.0;\n    float sca = 1.0;\n    for( int i=0; i<5; i++ )\n    {\n        float hr = 0.01 + 0.12*float(i)/4.0;\n        vec3 aopos =  nor * hr + pos;\n        float dd = map( aopos, false ).dist;\n        occ += -(dd-hr)*sca;\n        sca *= 0.95;\n    }\n    return clamp( 1.0 - 3.0*occ, 0.0, 1.0 );    \n}\n\nvec3 doLighting(Material material, vec3 pos, vec3 nor, vec3 ref, vec3 rd) {\n    vec3 lightPos = vec3(0,0,-1);\n    vec3 backLightPos = normalize(vec3(0,-.3,1));\n    vec3 ambientPos = vec3(0,1,0);\n\n    mat3 m = lightRotation();\n    lightPos *= m;\n    backLightPos *= m;\n        \n    float occ = calcAO( pos, nor );\n    vec3  lig = lightPos;\n    float amb = clamp((dot(nor, ambientPos) + 1.) / 2., 0., 1.);\n    float dif = clamp((dot(nor, lig) + 1.) / 3., 0.0, 1.0 );\n    float bac = pow(clamp(dot(nor, backLightPos), 0., 1.), 1.5);\n    float fre = pow( clamp(1.0+dot(nor,rd),0.0,1.0), 2.0 );\n    \n    dif *= softshadow( pos, lig, 0.01, 2.5 ) * .5 + .5;\n\n    vec3 lin = vec3(0.0);\n    lin += 1.20*dif*vec3(.95,0.80,0.60);\n    lin += 0.80*amb*vec3(0.50,0.70,.80)*occ;\n    lin += 0.30*bac*vec3(0.25,0.25,0.25)*occ;\n    lin += 0.20*fre*vec3(1.00,1.00,1.00)*occ;\n    vec3 col = material.albedo*lin;\n    \n\tfloat spe = clamp(dot(ref, lightPos), 0., 1.);\n    spe = pow(spe, 2.) * .1;\n    col += spe;\n\n    return col;\n}   \n\n\n// --------------------------------------------------------\n// Ray Marching\n// Adapted from: https://www.shadertoy.com/view/Xl2XWt\n// --------------------------------------------------------\n\nconst float MAX_TRACE_DISTANCE = 30.; // max trace distance\nconst float INTERSECTION_PRECISION = .001; // precision of the intersection\nconst int NUM_OF_TRACE_STEPS = 100;\nconst float FUDGE_FACTOR = .9; // Default is 1, reduce to fix overshoots\n\nstruct CastRay {\n    vec3 origin;\n    vec3 direction;\n    bool glitchMask;\n};\n\nstruct Ray {\n    vec3 origin;\n    vec3 direction;\n    float len;\n};\n\nstruct Hit {\n    Ray ray;\n    Model model;\n    vec3 pos;\n    bool isBackground;\n    vec3 normal;\n    vec3 color;\n};\n\nvec3 calcNormal( in vec3 pos ){\n    vec3 eps = vec3( 0.001, 0.0, 0.0 );\n    vec3 nor = vec3(\n        map(pos+eps.xyy, false).dist - map(pos-eps.xyy, false).dist,\n        map(pos+eps.yxy, false).dist - map(pos-eps.yxy, false).dist,\n        map(pos+eps.yyx, false).dist - map(pos-eps.yyx, false).dist );\n    return normalize(nor);\n}\n    \nHit raymarch(CastRay castRay){\n\n    float currentDist = INTERSECTION_PRECISION * 2.0;\n    Model model;\n    \n    Ray ray = Ray(castRay.origin, castRay.direction, 0.);\n\n    for( int i=0; i< NUM_OF_TRACE_STEPS ; i++ ){\n        if (currentDist < INTERSECTION_PRECISION || ray.len > MAX_TRACE_DISTANCE) {\n            break;\n        }\n        model = map(ray.origin + ray.direction * ray.len, castRay.glitchMask);\n        currentDist = model.dist;\n        ray.len += currentDist * FUDGE_FACTOR;\n    }\n    \n    bool isBackground = false;\n    vec3 pos = vec3(0);\n    vec3 normal = vec3(0);\n    vec3 color = vec3(0);\n    \n    if (ray.len > MAX_TRACE_DISTANCE) {\n        isBackground = true;\n    } else {\n        pos = ray.origin + ray.direction * ray.len;\n        normal = calcNormal(pos);\n    }\n\n    return Hit(ray, model, pos, isBackground, normal, color);\n}\n\n\n// --------------------------------------------------------\n// Rendering\n// Refraction from https://www.shadertoy.com/view/lsXGzH\n// --------------------------------------------------------\n\nvoid shadeSurface(inout Hit hit){\n\n    vec3 color = vec3(.25);\n    \n    if (hit.isBackground) {\n        hit.color = color;\n        return;\n    }\n\n    #ifdef NORMALS\n        color = hit.normal * 0.5 + 0.5;\n    #else\n    \tvec3 ref = reflect(hit.ray.direction, hit.normal);\n        color = doLighting(\n            hit.model.material,\n            hit.pos,\n            hit.normal,\n            ref,\n            hit.ray.direction\n        );\n    #endif\n\n    hit.color = color;\n}\n\n\nvec3 render(Hit hit){\n    \n    shadeSurface(hit);\n    \n    if (hit.isBackground) {\n        return hit.color;\n    }\n    \n    return hit.color;\n}\n\n\n// --------------------------------------------------------\n// Camera\n// https://www.shadertoy.com/view/Xl2XWt\n// --------------------------------------------------------\n\nmat3 calcLookAtMatrix( in vec3 ro, in vec3 ta, in float roll )\n{\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(sin(roll),cos(roll),0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n    return mat3( uu, vv, ww );\n}\n\nvoid doCamera(out vec3 camPos, out vec3 camTar, out float camRoll, in float time, in vec2 mouse) {\n    float dist = 3.;\n    camRoll = 0.;\n    camTar = vec3(0,0,0);\n    camPos = vec3(0,0,-dist);\n    camPos *= cameraRotation();\n    camPos += camTar;\n}\n\nHit raymarchPixel(vec2 p, bool glitchPass) {\n    vec2 m = iMouse.xy / iResolution.xy;\n\n    vec3 camPos = vec3( 0., 0., 2.);\n    vec3 camTar = vec3( 0. , 0. , 0. );\n    float camRoll = 0.;\n    \n    // camera movement\n    doCamera(camPos, camTar, camRoll, iTime, m);\n    \n    // camera matrix\n    mat3 camMat = calcLookAtMatrix( camPos, camTar, camRoll );  // 0.0 is the camera roll\n    \n    // create view ray\n    float focalLength = 3.;\n    vec3 rd = normalize( camMat * vec3(p.xy, focalLength) );\n    \n    Hit hit = raymarch(CastRay(camPos, rd, glitchPass));\n    \n    return hit;\n}\n\n\n// --------------------------------------------------------\n// Gamma\n// https://www.shadertoy.com/view/Xds3zN\n// --------------------------------------------------------\n\nconst float GAMMA = 2.2;\n\nvec3 gamma(vec3 color, float g) {\n    return pow(color, vec3(g));\n}\n\nvec3 linearToScreen(vec3 linearRGB) {\n    return gamma(linearRGB, 1.0 / GAMMA);\n}\n\n\n// --------------------------------------------------------\n// Glitch core\n// --------------------------------------------------------\n\n\n\n\n\n    \nfloat fBox2d(vec2 p, vec2 b) {\n  vec2 d = abs(p) - b;\n  return min(max(d.x, d.y), 0.0) + length(max(d, 0.0));\n}\n\n\n\n\n\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    time = iTime;\n    time /= 3.;\n    time = mod(time, 1.);\n    \n    vec2 p = (-iResolution.xy + 2.0*fragCoord.xy)/iResolution.y;\n    \n    vec3 color;\n    \n\n\n        Hit hit = raymarchPixel(p, false);\n        color = render(hit);\n\n       \n    \n        #ifndef NORMALS\n           color = linearToScreen(color);\n        #endif\n\n    \n\n    fragColor = vec4(color,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tdSXRc.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[337, 337, 360, 360, 388], [390, 390, 411, 411, 439], [701, 701, 721, 721, 759], [761, 999, 1031, 1031, 1076], [1078, 1152, 1208, 1208, 1253], [1255, 1291, 1319, 1319, 1406]], "test": "ok"}
{"id": "tdSXW3", "name": "2D_Planet", "author": "Simplyfire", "description": "A simplified 2D planet", "tags": ["2d", "noise", "fbm", "planet"], "likes": 10, "viewed": 394, "published": "Public API", "date": "1555065130", "time_retrieved": "2021-10-01T00:00:00", "image_code": "precision highp float;\n\nuniform vec2 resolution;\nuniform float time;\n\n#define pi 3.14159265359\n#define S(a, b, t) smoothstep(a, b, t)\n\n// functions from the Book of Shaders\nvec3 random3(vec3 c) {\n    float j = 4096.0*sin(dot(c,vec3(17.0, 59.4, 15.0)));\n    vec3 r;\n    r.z = fract(512.0*j);\n    j *= .125;\n    r.x = fract(512.0*j);\n    j *= .125;\n    r.y = fract(512.0*j);\n    return r-0.5;\n}\n\nconst float F3 =  0.3333333;\nconst float G3 =  0.1666667;\nfloat snoise(float x0,float y0, float z0) {\n    vec3 p = vec3(x0,y0,z0);\n    vec3 s = floor(p + dot(p, vec3(F3)));\n    vec3 x = p - s + dot(s, vec3(G3));\n    vec3 e = step(vec3(0.0), x - x.yzx);\n    vec3 i1 = e*(1.0 - e.zxy);\n    vec3 i2 = 1.0 - e.zxy*(1.0 - e);\n    vec3 x1 = x - i1 + G3;\n    vec3 x2 = x - i2 + 2.0*G3;\n    vec3 x3 = x - 1.0 + 3.0*G3;\n    vec4 w, d;\n    w.x = dot(x, x);\n    w.y = dot(x1, x1);\n    w.z = dot(x2, x2);\n    w.w = dot(x3, x3);\n    w = max(0.6 - w, 0.0);\n    d.x = dot(random3(s), x);\n    d.y = dot(random3(s + i1), x1);\n    d.z = dot(random3(s + i2), x2);\n    d.w = dot(random3(s + 1.0), x3);\n    w *= w;\n    w *= w;\n    d *= w;\n    return dot(d, vec4(52.0));\n}\n\nfloat cubicPulse( float c, float w, float x ){\n\t x = abs(x - c);\n\t if( x>w ) return 0.0;\n\t x /= w;\n\t return 1.0 - x*x*(3.0-2.0*x);\n}\n\nvec3 rgb( in vec3 c ){\n vec3 rgb = clamp(abs(mod(c.x*6.0+vec3(0.0,4.0,2.0), 6.0)-3.0)-1.0, 0.0, 1.0 );\n rgb = rgb*rgb*(3.0-2.0*rgb);  return c.z * mix(vec3(1.0), rgb, c.y);\n}\n\nmat2 rotate2d(float angle){\n\treturn mat2(cos(angle),-sin(angle), sin(angle),cos(angle));\n}\n\n#define OCTAVES 12\nfloat fbm (float x, float y, float z) {\n\tvec3 st = vec3(x,y,z);\n    float value = 0.0;\n    float amplitude = .5;\n    float frequency = 0.;\n    for (int i = 0; i < OCTAVES; i++) {\n\t\tfloat n = abs(snoise(st.x, st.y, st.z));\n        value += amplitude * n;\n        st *= 2.;\n        amplitude *= .5;\n    }\n    return value;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  float time = iTime+5.;\n  vec2 uv = (fragCoord.xy-.5*iResolution.xy)/iResolution.y;\n  float d = length(uv);\n  vec2 landId = floor(uv*40.)+1.0;\n  vec2 atmoId = floor(uv*70.)+1.0;\n  float planet = smoothstep(.35,.3, d);\n  float landScl = .04;\n  float atmoScl = .01;\n  float land = max(.5,clamp(3.*fbm(landScl*landId.x-time*.1, landScl*landId.y, 0.), 0.,1.));\n  float atmosphere = clamp(1.5*fbm(atmoScl*atmoId.x-time*.2, atmoScl*atmoId.y, 0.), 0.,1.);\n  float poles = smoothstep(.0, .1,abs(.5-landId.y)*.004);\n  vec3 hsb = vec3(mix(.2, 1.0, 1.-land), 1.-poles*planet-atmosphere-(smoothstep(.3,.35,d)-smoothstep(.35,0.5,d)), planet+poles*planet);\n  fragColor = vec4(rgb(hsb),1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tdSXW3.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[135, 173, 195, 195, 392], [452, 452, 495, 495, 1144], [1146, 1146, 1192, 1192, 1278], [1280, 1280, 1302, 1302, 1454], [1456, 1456, 1483, 1483, 1546], [1567, 1567, 1606, 1606, 1889], [1891, 1891, 1948, 1948, 2627]], "test": "error"}
{"id": "tdSXWt", "name": "Space Polyp", "author": "OliverSchaff", "description": "My first try on wavy motion. Use mouse to rotate.", "tags": ["raymarching", "transparency", "volumetric"], "likes": 32, "viewed": 408, "published": "Public", "date": "1555276563", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Renderingcode from a shader by Shane\n// https://www.shadertoy.com/view/ll2SRy\n\n#define PI 3.14159265359\n#define grad_step 0.01\n#define time 2.0*iTime\n\n\n// Spectrum colour palette\n// IQ https://www.shadertoy.com/view/ll2GD3\nvec3 pal( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d ) {\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\nvec3 spectrum(float n) {\n    return pal( n, vec3(0.5,0.5,0.5),vec3(0.0,0.5,0.5),vec3(.0,1.0,.0),vec3(0.62,0.33,0.37) );\n}\n\n// iq's distance functions\nfloat sdSphere( vec3 p, float s )\n{\n  return length(p)-s;\n}\n\nfloat opOnion( in float sdf, in float thickness )\n{\n    return abs(sdf)-thickness;\n}\n\nfloat sdUnion_s( float a, float b, float k ) {\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\nvec3 carToPol(vec3 p) {\n    float r = length(p);\n    float the = acos(p.z/r);\n    float phi = atan(p.y,p.x);\n    return vec3(r,the,phi);\n}\n\n// 2D rotation : pitch, yaw\nmat3 rotationXY( vec2 angle ) {\n\tvec2 c = cos( angle );\n\tvec2 s = sin( angle );\n\t\n\treturn mat3(\n\t\tc.y      ,  0.0, -s.y,\n\t\ts.y * s.x,  c.x,  c.y * s.x,\n\t\ts.y * c.x, -s.x,  c.y * c.x\n\t);\n}\n\nfloat pModPolar(inout vec2 p, float repetitions) { \n\tfloat angle = 2.*PI/repetitions; \n\tfloat a = atan(p.y, p.x) + angle/2.; \n\tfloat r = length(p); \n\tfloat c = floor(a/angle); \n\ta = mod(a,angle) - angle/2.; \n\tp = vec2(cos(a), sin(a))*r; \n    // For an odd number of repetitions, fix cell index of the cell in -x direction // (cell index would be e.g. -5 and 5 in the two halves of the cell): \n\tif (abs(c) >= (repetitions/2.)) c = abs(c); \n    return c;\n}\n\n\nfloat sdVerticalCapsule( vec3 p, float h, float r )\n{\n    p.z -= clamp( p.z, 0.0, h );\n    return length( p ) - r;\n}\n\nfloat distortedCapsule(vec3 p){\n    float dtime = 1.8*p.z-time-1.; // mix time with space to create wave\n    float dt = sin((dtime)-0.8*sin(dtime)); // distorted time, asymmetric sine wave\n    p.x += 0.2*(p.z)*dt;\n   \tfloat d = sdVerticalCapsule(p-vec3(0.9,0,0.), 2.0,0.05*(4.0-1.5*p.z));\n    float d2 = sdSphere(p-vec3(0.9,0,2.0),0.2);\n    d = sdUnion_s(d,d2,0.1);\n\treturn d;\n}\n\n\n\nfloat map( vec3 p ){\n    float dt = sin((time+2.5)-0.8*sin(time+2.5)); // distorted time, asymmetric sine wave\n    p.z += -0.2*dt;\n    float d0 = sdSphere(p-vec3(0,0,-0.7),0.5);\n    \n    float tentacleIndex = pModPolar(p.xy, 9.0);\n    p = rotationXY(vec2(0.0,-0.8))*p;\n    float d2 = distortedCapsule(p);\n    d0 = sdUnion_s(d0,d2,0.4);\n    return d0;\n}\n\n// get gradient in the world\nvec3 gradient( vec3 pos ) {\n\tconst vec3 dx = vec3( grad_step, 0.0, 0.0 );\n\tconst vec3 dy = vec3( 0.0, grad_step, 0.0 );\n\tconst vec3 dz = vec3( 0.0, 0.0, grad_step );\n\treturn normalize (\n\t\tvec3(\n\t\t\tmap( pos + dx ) - map( pos - dx ),\n\t\t\tmap( pos + dy ) - map( pos - dy ),\n\t\t\tmap( pos + dz ) - map( pos - dz )\t\t\t\n\t\t)\n\t);\n}\n\n\nvec3 fresnel( vec3 F0, vec3 h, vec3 l ) {\n\treturn F0 + ( 1.0 - F0 ) * pow( clamp( 1.0 - dot( h, l ), 0.0, 1.0 ), 5.0 );\n}\n\n\n\nvec3 selfColor(vec3 pos) {\n    vec3 pol = carToPol(pos-vec3(0,0,-0.8));\n    return spectrum(0.45*pol.x);\n}\n\nmat3 calcLookAtMatrix( in vec3 ro, in vec3 ta, in float roll )\n{\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(sin(roll),cos(roll),0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n    return mat3( uu, vv, ww );\n}\n\nvec3 reflectedColor(in vec3 p, in vec3 rd){\n    \n    vec3 Ks = vec3(0.7); // specular reflected intensity\n    float shininess = 40.0;\n    \n   \tvec3 n = gradient( p );\n    vec3 ref = reflect( rd, n );\n    vec3 rc = vec3(0);\n    \n    vec3 light_pos   = vec3( 15.0, 20.0, 5.0 );\n\tvec3 light_color = vec3( 1.0, 1.0, 1.0 );\n\tvec3 vl = normalize( light_pos - p );\n\tvec3 specular = vec3( max( 0.0, dot( vl, ref ) ) );\n    vec3 F = fresnel( Ks, normalize( vl - rd ), vl );\n\tspecular = pow( specular, vec3( shininess ) );\n\trc += light_color * specular; \n    return rc;\n}\n\nvoid mainImage( out vec4 fragColor, vec2 fragCoord ) {\n    \n    vec2 p = (-iResolution.xy + 2.0*fragCoord.xy)/iResolution.y;\n    vec3 ro = vec3( 5.0*cos(0.2*iTime-10.0), 1.0, 5.0*sin(0.2*iTime-10.0));\n    vec3 ta = vec3( 0. , 0. , 0. );\n    \n    float aa = 1.0/min(iResolution.y,iResolution.x);\n    \n    // camera matrix\n    mat3 camMat = calcLookAtMatrix( ro, ta, 0.0);  // 0.0 is the camera roll\n    \n\t// create view ray\n\tvec3 rd = normalize( camMat * vec3(p.xy, 1.9+0.8*sin(0.15*iTime+12.0)) ); // 3.0 is the lens length\n    \n    // rotate camera with mouse\n\tmat3 rot = rotationXY(iMouse.xy * vec2( 0.01, -0.01 ) );\n\trd = rot * rd;\n\tro = rot * ro;\n    vec3 col = vec3(0), sp;\n    \n\t// Ray distance, bail out layer number, surface distance and normalized accumulated distance.\n\tfloat t=0., layers=0., d, aD;\n    \n    // Surface distance threshold. Smaller numbers give a sharper object. Antialiased with aa\n    float thD = 0.5*sqrt(aa); \n    \n    // Only a few iterations seemed to be enough. Obviously, more looks better, but is slower.\n\tfor(int i=0; i<50; i++)\t{\n        \n        // Break conditions. Anything that can help you bail early usually increases frame rate.\n        if(layers>12. || col.g>1.0 || t>8.) break;\n        \n        // Current ray postion\n        sp = ro + rd*t;\n\t\t\n        d = map(sp); // Distance to nearest point in the cube field.\n        \n        // If we get within a certain distance of the surface, accumulate some surface values.\n        // Values further away have less influence on the total.\n        //\n        // aD - Accumulated distance. I interpolated aD on a whim (see below), because it seemed \n        // to look nicer.\n        //\n        // 1/.(1. + t*t*.85) - Basic distance attenuation. Feel free to substitute your own.\n        \n         // Normalized distance from the surface threshold value to our current isosurface value.\n        aD = (thD-abs(d))/thD;\n        \n        // If we're within the surface threshold, accumulate some color.\n        // Two \"if\" statements in a shader loop makes me nervous. I don't suspect there'll be any\n        // problems, but if there are, let us know.\n        if(aD>0.) { \n            // Smoothly interpolate the accumulated surface distance value, then apply some\n            // basic falloff (fog, if you prefer) using the camera to surface distance, \"t.\"\n            // selfColor is the color of the object at the point sp\n            vec3 sc = selfColor(sp);\n            col += 8.*sc*(aD*aD*(3. - 2.*aD)/(1. + t*t*0.85));\n            col += 1.0*reflectedColor(sp, rd);\n            layers++;\n        }\n\n\t\t\n        // Kind of weird the way this works. I think not allowing the ray to hone in properly is\n        // the very thing that gives an even spread of values. The figures are based on a bit of \n        // knowledge versus trial and error. If you have a faster computer, feel free to tweak\n        // them a bit.\n        //t += abs(d)*0.5;\n        t += max(abs(d)*0.8, thD*1.1); \n\t}\n    \n    // I'm virtually positive \"col\" doesn't drop below zero, but just to be safe...\n    col = max(col, 0.);\n    \n\tfragColor = vec4(clamp(col, 0., 1.), 1);\n }\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tdSXWt.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[155, 226, 294, 294, 337], [339, 339, 363, 363, 460], [462, 489, 524, 524, 548], [550, 550, 601, 601, 634], [636, 636, 682, 682, 775], [777, 777, 800, 800, 915], [917, 945, 976, 976, 1132], [1134, 1134, 1184, 1184, 1588], [1591, 1591, 1644, 1644, 1707], [1709, 1709, 1740, 1740, 2087], [2091, 2091, 2111, 2111, 2443], [2445, 2474, 2501, 2501, 2793], [2796, 2796, 2837, 2837, 2917], [2921, 2921, 2947, 2947, 3027], [3029, 3029, 3093, 3093, 3271], [3273, 3273, 3316, 3316, 3834], [3836, 3836, 3890, 3890, 6976]], "test": "ok"}
{"id": "tlf3z7", "name": "Size illusion", "author": "AlexK", "description": "Find smallar distortion. Notice that size of it does not changes over time.\nFind bigger distortion. While looking at the center of it try to observe what size smaller distortion would have.", "tags": ["illusion", "gravity"], "likes": 2, "viewed": 128, "published": "Public", "date": "1555889602", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define tau 6.28318530718\n\nfloat coss(float x){\n\treturn (1. + cos(x * tau))/2.;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv =  ( fragCoord -.5*iResolution.xy ) / iResolution.y;\n    \n    \n    uv *= 20.;\n    \n    float t = iTime;\n    vec2 pos = vec2(cos(t) * 5., sin(t) * 5.);\n    float d = length(uv - pos) * 0.5;\n    \n    uv = pos + (uv-pos) * (1. + 1. / (0.1 + d));\n    \n    \n    pos = vec2(cos(t + tau / 2.) * 5., sin(t + tau / 2.) * 5.);\n    d = length(uv - pos) * 0.1;\n    \n    uv = pos + (uv-pos) * (1. + 1. / (0.1 + d));\n    \n    \n    // Output to screen\n    float val = pow(coss(uv.x) * coss(uv.y), 0.2);\n    vec3 col = vec3(val, val, val);\n\n    \n    fragColor = vec4(col,1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tlf3z7.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[27, 27, 47, 47, 81], [83, 83, 140, 140, 712]], "test": "ok"}
{"id": "tlf3zH", "name": "Neon Cube", "author": "TekF", "description": "Variation of https://www.shadertoy.com/view/wtfGR8", "tags": ["wireframe", "rotation", "plotter"], "likes": 15, "viewed": 555, "published": "Public API", "date": "1555612449", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Created by Hazel Quantock 2019\n// This work is licensed under a Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International License. http://creativecommons.org/licenses/by-nc-sa/4.0/\n\nconst int numCubes = 16;\nconst float twistStep = .12;\nconst float scaleStep = 1.03;\nconst float zoom = 3.;\nconst float lineThickness = 6.;\n\n\n// input in range [-1,1] to span iResolution.y pixels\nfloat RenderLine( vec2 a, vec2 b, vec2 fragCoord )\n{\n    a = (iResolution.y*a + iResolution.xy)*.5;\n    b = (iResolution.y*b + iResolution.xy)*.5;\n    \n    float halfThickness = lineThickness*iResolution.y/750.; \n\n    float halfAASoftening = halfThickness; //.7; // in pixels (don't change this much)\n    \n    float t = dot(fragCoord-a,b-a);\n    t /= dot(b-a,b-a);\n    t = clamp( t, 0., 1. );\n    return smoothstep( halfThickness-halfAASoftening, halfThickness+halfAASoftening, length(fragCoord - mix(a,b,t)) );\n}\n\n    \nfloat RenderLine3D( vec3 a, vec3 b, vec2 fragCoord )\n{\n    vec3 camPos = vec3(0,0,-8);\n    \n    a -= camPos;\n    b -= camPos;\n    \n    // todo: transform by camera matrix\n\n    a.z /= zoom;\n    b.z /= zoom;\n    \n    // perspective projection\n    return RenderLine( a.xy/a.z, b.xy/b.z, fragCoord );\n}\n\n\n// combine 2 anti-aliased values\nfloat BlendAA( float a, float b )\n{\n    // a and b values represent what proportion of the pixel is covered by each line,\n    // but they don't contain enough information to accurately combine them!\n    // if both lines are covering the same part of the pixel the result should be min(a,b)\n    // if they cover non-overlapping parts of the pixel the result is a-(1-b)\n\t// a*b assumes the proportion of overlap is the same in the solid and clear regions\n    // this is the safest assumption given the lack of any other info\n\n    // but, tune it until it looks good\n    return mix( min(a,b), a*b, .5 );\n}\n\n\nvoid mainImage( out vec4 fragColour, in vec2 fragCoord )\n{\n    fragColour.rgb = vec3(.8);\n  \n    float t = iTime;\n\n    // bendy!\n    //t += 3.*dot(fragCoord.xy/iResolution.xy,vec2(.8,.5));\n    \n    vec3 a = vec3(twistStep*cos(t*5./vec3(11,13,17)+1.5));\n    mat3 stepTransform =\n        scaleStep *\n        mat3( cos(a.z), sin(a.z), 0,\n             -sin(a.z), cos(a.z), 0,\n              0, 0, 1 ) *\n        mat3( cos(a.y), 0, sin(a.y),\n             0, 1, 0,\n             -sin(a.y), 0, cos(a.y) ) *\n        mat3( 1, 0, 0,\n              0, cos(a.x), sin(a.x),\n              0,-sin(a.x), cos(a.x) );\n\n    vec3 b = vec3(.7+t/6.,.7-t/6.,.6);\n    mat3 transform = //mat3(1,0,0,0,1,0,0,0,1); // identity\n        mat3( cos(b.z), sin(b.z), 0,\n             -sin(b.z), cos(b.z), 0,\n              0, 0, 1 ) *\n        mat3( cos(b.y), 0, sin(b.y),\n             0, 1, 0,\n             -sin(b.y), 0, cos(b.y) ) *\n        mat3( 1, 0, 0,\n              0, cos(b.x), sin(b.x),\n              0,-sin(b.x), cos(b.x) );\n\n    #define DrawLine(a,b) line = BlendAA( line, RenderLine3D(a,b,fragCoord) );\n    \n    fragColour.rgb = vec3(.0);\n    \n    for ( int cube=0; cube < numCubes; cube++ )\n    {\n        vec3 vertices[8];\n        for ( int i=0; i < 8; i++ )\n        {\n            vertices[i] = transform*(vec3(i>>2,(i>>1)&1,i&1)*2.-1.);\n        }\n        \n\t    float line = 1.;\n        \n        DrawLine( vertices[0], vertices[1] );\n        DrawLine( vertices[2], vertices[3] );\n        DrawLine( vertices[4], vertices[5] );\n        DrawLine( vertices[6], vertices[7] );\n        DrawLine( vertices[0], vertices[2] );\n        DrawLine( vertices[1], vertices[3] );\n        DrawLine( vertices[4], vertices[6] );\n        DrawLine( vertices[5], vertices[7] );\n        DrawLine( vertices[0], vertices[4] );\n        DrawLine( vertices[1], vertices[5] );\n        DrawLine( vertices[2], vertices[6] );\n        DrawLine( vertices[3], vertices[7] );\n        \n        float f = float(cube)/float(numCubes-1);\n        vec3 col = f*smoothstep(-.5,.7,cos(6.283*(f+vec3(0,1,2)/3.)));\n\t    fragColour.rgb += col*(1.f-line);//mix( col, fragColour.rgb, line );\n    \n        transform *= stepTransform;\n    }\n    \n    fragColour.rgb = pow(fragColour.rgb,vec3(1./2.2));\n    fragColour.a = 1.;\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tlf3zH.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-4.0", "functions": [[340, 394, 446, 446, 907], [914, 914, 968, 968, 1212], [1215, 1248, 1283, 1811, 1850], [1853, 1853, 1911, 1911, 4099]], "test": "ok"}
{"id": "tlf3zn", "name": "Simple Worley", "author": "Xor", "description": "Just about as simple (computationally) as I can make it. Any suggestions?", "tags": ["2d", "noise", "xor"], "likes": 6, "viewed": 118, "published": "Public", "date": "1555461911", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//2D hash function:\nvec2 hash2(vec2 p)\n{\n \treturn fract(cos(p*mat2(56.,37.,81.,-26.))*28.9);   \n}\n//Simple Worley noise function:\nfloat worley(vec2 p)\n{\n    vec3 s = vec3(-1,0,1);\n \tvec2 f = floor(p);\n    \n    vec2 v = hash2(f+s.xx)-p+f+s.xx;\n    float d = dot(v,v);\n    v = hash2(f+s.yx)-p+f+s.yx;\n    d = min(d,dot(v,v));\n    v = hash2(f+s.zx)-p+f+s.zx;\n    d = min(d,dot(v,v));\n    \n    v = hash2(f+s.xy)-p+f+s.xy;\n    d = min(d,dot(v,v));\n    v = hash2(f+s.yy)-p+f+s.yy;\n    d = min(d,dot(v,v));\n    v = hash2(f+s.zy)-p+f+s.zy;\n    d = min(d,dot(v,v));\n\n    v = hash2(f+s.xz)-p+f+s.xz;\n    d = min(d,dot(v,v));\n    v = hash2(f+s.yz)-p+f+s.yz;\n    d = min(d,dot(v,v));\n    v = hash2(f+s.zz)-p+f+s.zz;\n    d = min(d,dot(v,v));\n    return sqrt(d);\n}\n\nvoid mainImage( out vec4 color, in vec2 coord)\n{\n    float noise = worley(coord/64.+iTime);\n    color = vec4(noise,noise,noise,1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tlf3zn.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 20, 40, 40, 97], [98, 130, 152, 152, 750], [752, 752, 800, 800, 885]], "test": "ok"}
{"id": "tlfGD4", "name": "eye of patrik", "author": "Pyramid", "description": "learning then playing", "tags": ["patrik"], "likes": 2, "viewed": 108, "published": "Public", "date": "1556320296", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float dist(vec2 origin, vec2 target)\n{\n    return abs(sqrt(pow(target.x+origin.x,2.)+pow(target.y+origin.y,2.)));\n}\n\nfloat point(vec2 uv, vec2 position, float size)\n{\n    //vec2 target = vec2(0.,0.);\n    //float size =.004;\n    //float dist = dist(uv,point);\n    //float dist = length(uv)-length(point);\n    //float point=1.-distance(uv,target);\n    //point = smoothstep(.49,.51,point);\n    //float point=smoothstep(size+size/2.,size,distance(uv,target));\n    \n    return smoothstep(size+size/2.,size,distance(uv,position));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    uv-=.5;\n    //uv.y-=.5;\n\n    float aspectRatio = iResolution.x/iResolution.y;\n    uv.x *= aspectRatio;\n    \n    float zoom = 12.;\n    uv*=zoom;\n    float c,x,y,t;\n    \n    //t=floor(iTime)*fract(iTime/4.);\n    //t=float(int(floor(iTime))%2)*fract(iTime/4.);\n    t=sin(iTime/8.)*2.;\n    \n    x=y=t;\n    for(int i=0;i<1000;i++)\n    {\n        x+=sin(y*2.)-y+t;\n        y+=y/88.*t+x/7.;\n        if(abs(x)>zoom||abs(y)>zoom) break;\n    \tc+=point(uv, vec2(x,y), clamp(.1,.7,abs(sin(iTime)/20.)));\n    }\n    \n    vec3 color = vec3(c,abs(sin(c)),abs(sin(iTime)*c/776.));\n    fragColor = vec4(color,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tlfGD4.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 38, 38, 115], [117, 117, 166, 455, 526], [528, 528, 585, 585, 1227]], "test": "ok"}
{"id": "tll3RM", "name": "My Very First Shader", "author": "georgecruesby", "description": "This is my first shader.", "tags": ["test"], "likes": 1, "viewed": 228, "published": "Public API", "date": "1555942047", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Time varying pixel color\n    vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n    \n    // input channel. XX = 2D/Cube\n    \n    \n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tll3RM.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 107, 344]], "test": "ok"}
{"id": "tll3Wr", "name": "synthwave sunset", "author": "jijis_duty", "description": "first shader test", "tags": ["synthwave"], "likes": 3, "viewed": 419, "published": "Public API", "date": "1556117513", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  // vec2 uv = fragCoord/iResolution.xy;\n  // uv -=.5;\n    \n    vec2 uv = (fragCoord -iResolution.xy*.5) /iResolution.xy;\n    \n\n    uv.x*= iResolution.x/iResolution.y;\n\n    float d = length(uv);\n    float r = abs(mod(uv.y*iTime,0.5*2.0)-0.5);\n   \n    \n /* \n    float c = smoothstep(r, r-0.2, d);\n    float b = smoothstep(r, r-0.1, d);\n    float a = smoothstep(r, r-0.05, d);\n\n \n    fragColor = vec4(a,b,c,1);\n*/\n    \n    \n    fragColor = vec4(smoothstep(vec4(r),r - vec4(.05,.1,.2,0), vec4(d)));\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tll3Wr.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 112, 555]], "test": "ok"}
{"id": "tllGRM", "name": "concentric tori", "author": "edapx", "description": "Raymarching and torus", "tags": ["raymarching", "torus"], "likes": 1, "viewed": 86, "published": "Public", "date": "1555937014", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n#define PI 3.14159265359\nconst int MAX_MARCHING_STEPS = 164;\nconst float EPSILON = 0.0015;\nconst float NEAR_CLIP = 0.0;\nconst float FAR_CLIP = 80.00;\n\nvec3 lightDirection = vec3(0.702, 0.1686, 0.6745);\n\n// https://iquilezles.org/www/articles/distfunctions/distfunctions.htm\nfloat opSubtraction( float d1, float d2 ) { return max(-d1,d2); }\n\nfloat sdBox( vec3 p, vec3 b ){\n    vec3 d = abs(p) - b;\n    return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\nfloat onion( in float d, in float h ){\n    return abs(d)-h;\n}\n\nfloat sdTorus( vec3 p, vec2 t ){\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\nfloat bendTorus( vec3 p, vec2 dim ){\n    float wave = sin(iTime * 2.0) * 0.2;\n    float c = cos(wave*p.x);\n    float s = sin(wave*p.x);\n    mat2  m = mat2(c,-s,s,c);\n    vec3  q = vec3( p.xy*m, p.z);\n    return sdTorus(q, dim);\n}\n\nfloat bendBox( vec3 p, vec3 dim ){\n    float wave = sin(iTime * 2.0) * 0.2;\n    float c = cos(wave*p.x);\n    float s = sin(wave*p.x);\n    mat2  m = mat2(c,-s,s,c);\n    vec3  q = vec3( p.x, m*p.yz);\n    return sdBox(q, dim);\n}\n\nfloat map(vec3 pos){\n    float thick = 0.08;\n    float d = onion(bendTorus( pos.xzy, vec2(1.0,0.2) ), thick);\n    \n    d = max( d, pos.y+cos(iTime+1.2));\n    float d1 = onion(bendTorus( pos.xzy, vec2(1.1,0.5) ), thick-0.01);\n    d1 = max( d1, pos.x+sin(iTime-0.3));\n\n    float d2 = onion(bendTorus( pos.xzy, vec2(1.2,0.8) ), thick-0.02);\n    d2 = max( d2, pos.y+cos(iTime-0.9));\n    \n    float d3 = onion(bendTorus( pos.xzy, vec2(1.3,1.1) ), thick-0.03);\n    d3 = max( d3, pos.x+sin(iTime+0.5));\n\n    vec3 posBox = pos;\n    float boxZ = 0.1;\n    float box = bendBox(posBox, vec3(12.5, 3.1, boxZ));\n    \n    // cut it all in half so that the interior parts are visible\n    float tori = min(d3,min(d2,min(d1, d)));\n    return opSubtraction(box,tori);\n}    \n\nvec2 squareFrame(vec2 res, vec2 coord){\n    vec2 uv = 2.0 * coord.xy / res.xy - 1.0;\n    uv.x *= res.x / res.y;\n    return uv;\n}\n\nfloat raymarching(vec3 eye, vec3 marchingDirection){\n    float depth = NEAR_CLIP;\n    for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n        float dist = map(eye + depth * marchingDirection);\n        if (dist < EPSILON){\n            return depth;\n        }\n\n        depth += dist;\n\n        if (depth >= FAR_CLIP) {\n            return FAR_CLIP;\n        }\n    }\n    return FAR_CLIP;\n}\n\nfloat softshadow( in vec3 ro, in vec3 rd, in float mint, in float tmax ) {\n    float res = 1.0;\n    float t = mint;\n    for( int i=0; i<16; i++ ) {\n        float h = map( ro + rd*t );\n        res = min( res, 8.0*h/t );\n        t += clamp( h, 0.02, 0.10 );\n        if( h<0.001 || t>tmax ) break;\n    }\n    return clamp( res, 0.0, 1.0 );\n}\n\nfloat ao( in vec3 pos, in vec3 nor ){\n    float occ = 0.0;\n    float sca = 1.0;\n    for( int i=0; i<5; i++ )\n    {\n        float hr = 0.01 + 0.06*float(i)/4.0;\n        vec3 aopos =  nor * hr + pos;\n        float dd = map( aopos );\n        occ += -(dd-hr)*sca;\n        sca *= 0.95;\n    }\n    return clamp( 1.0 - 3.0*occ, 0.0, 1.0 );    \n}\n\nvec3 computeNormal(vec3 pos){\n    vec2 eps = vec2(0.01, 0.);\n    return normalize(vec3(\n        map(pos + eps.xyy) - map(pos - eps.xyy),\n        map(pos + eps.yxy) - map(pos - eps.yxy),\n        map(pos + eps.yyx) - map(pos - eps.yyx)\n    ));\n}\n\nfloat diffuse(vec3 normal){\n    float ambient = 0.3;\n    return clamp( dot(normal, lightDirection) * ambient + ambient, 0.0, 1.0 );\n}\n\nfloat specular(vec3 normal, vec3 dir){\n    vec3 h = normalize(normal - dir);\n    float specularityCoef = 40.;\n    return clamp( pow(max(dot(h, normal), 0.), specularityCoef), 0.0, 1.0);\n}\n\nfloat fresnel(vec3 normal, vec3 dir){\n    return pow( clamp(1.0+dot(normal,dir),0.0,1.0), 2.0 );\n}\n\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr ){\n    vec3 cw = normalize(ta-ro);\n    vec3 cp = vec3(sin(cr), cos(cr),0.0);\n    vec3 cu = normalize( cross(cw,cp) );\n    vec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = squareFrame(iResolution.xy,fragCoord.xy);\n\n    float camSpeed = 1.0;\n    vec3 eye = vec3( \n               0.5+2.5*sin(camSpeed*iTime),\n                2.5,\n                2.3 - 3.0*cos(camSpeed*iTime)\n    );\n\n    vec3 ta = vec3(0.0, 0.0, 0.0);\n    mat3 camera = setCamera( eye, ta, 0.0 );\n    float fov = 1.5;\n    vec3 dir = camera * normalize(vec3(uv, fov));\n    \n    float shortestDistanceToScene = raymarching(eye, dir);\n\n    vec3 color;\n    vec3 bgColor = vec3(0.086, 0.290, 0.800);\n\n    if (shortestDistanceToScene < FAR_CLIP - EPSILON) {\n        vec3 collision = (eye += (shortestDistanceToScene*0.995) * dir );\n        float shadow  = softshadow(collision, lightDirection, 0.02, 2.5 );\n        vec3 normal = computeNormal(collision);\n        float diffLight = diffuse(normal);\n        float specLight = specular(normal, dir);\n        float fresnelLight = fresnel(normal, dir);\n        float ambientOcc = ao(collision, normal);\n        vec3 texCol = vec3(1.00, 0.352, 0.207);\n        color = (diffLight + specLight + fresnelLight) * texCol;\n        \n        shadow = mix(shadow, 1.0, 0.7);\n        color = color * ambientOcc * shadow;\n\n    } else {\n        color = bgColor;\n    }\n    \n\n    fragColor = vec4(clamp(color,0.0,1.0) , 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tllGRM.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[204, 275, 318, 318, 340], [342, 342, 372, 372, 463], [465, 465, 503, 503, 526], [528, 528, 560, 560, 625], [627, 627, 663, 663, 856], [858, 858, 892, 892, 1083], [1085, 1085, 1105, 1105, 1835], [1841, 1841, 1880, 1880, 1969], [1971, 1971, 2023, 2023, 2353], [2355, 2355, 2429, 2429, 2692], [2694, 2694, 2731, 2731, 3031], [3033, 3033, 3062, 3062, 3276], [3278, 3278, 3305, 3305, 3411], [3413, 3413, 3451, 3451, 3600], [3602, 3602, 3639, 3639, 3700], [3702, 3702, 3753, 3753, 3942], [3944, 3944, 4001, 4001, 5260]], "test": "timeout"}
{"id": "tls3zN", "name": "Simple Explosion in 2D", "author": "10000volts", "description": "Imitate the explosion effect in Soul Knight.\nThis's my first submission...", "tags": ["2d", "explosion", "pixel"], "likes": 0, "viewed": 268, "published": "Public", "date": "1555820884", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI 3.1415927\n\n// draw a moving bullet.\nconst float TIME_PHASE1 = 2.0;\n// draw explosion.\nconst float TIME_PHASE2 = 2.5;\n\nconst float BULLET_RADIUS = 4.0;\nconst float BULLET_RADIUS2 = 9.0;\nconst float EXPLOSION_RADIUS = 15.0;\nconst vec3 BULLET_COLOR = vec3(1.0, 0.6, 0.0);\nconst vec4 EXPLOSION_COLOR = vec4(1.0, 0.6, 0.0, 1.0);\nconst vec4 EXPLOSION_SQUARE_COLOR = vec4(1.0, 1.0, 0.6, 1.0);\nconst int SQUARE_COUNT = 3;\nconst float SQUARE_MAX_HALF_WIDTH = 11.0;\n\n// the speed of bullet.\nfloat MOVING_SPEED;\nfloat START_X;\nfloat START_Y;\nfloat explosionX;\nfloat explosionY;\n\nvec2 uv;\n\nvoid drawBackground(out vec4 fragColor){\n    fragColor = vec4(vec3(texture(iChannel0, uv/iResolution.xy)), 1.0);\n}\n\n// xy: position of squares' center.\n// z: the half of width and height of the squares.\nvec4 square[SQUARE_COUNT];\nvoid drawExplosion(float t, out vec4 fragColor){\n    // draw circle.\n    float r = t * EXPLOSION_RADIUS / (TIME_PHASE2 - TIME_PHASE1); \n    vec2 o = vec2(explosionX, explosionY);\n    float d = distance(uv, o);\n    if(d <= EXPLOSION_RADIUS && d > r){\n    \tfragColor = EXPLOSION_COLOR;\n    }\n    \n    // draw squares.\n    int i;\n    for(i = 0; i < SQUARE_COUNT; ++i){\n    \tif(abs(uv.x - square[i].x) <= square[i].z && \n           abs(uv.y - square[i].y) <= square[i].z){\n    \t\tfragColor = EXPLOSION_SQUARE_COLOR;\n        }\n    }\n}\n\nvoid drawBullet(float t, out vec4 fragColor){\n    // the center of the two circles.\n    vec2 o = vec2(START_X + MOVING_SPEED * t, START_Y);\n    float d = distance(uv, o);\n    \n    // draw smaller circle.\n    if(d <= BULLET_RADIUS){\n\t\tfragColor = vec4(1.0, 1.0, 1.0, 1.0);\n    }\n\t// draw bigger circle.\n    else if(d <= BULLET_RADIUS2){\n    \tfloat R, G, B;\n        float W = smoothstep(BULLET_RADIUS, BULLET_RADIUS2, d);\n        R = 1.0 - (1.0 - BULLET_COLOR.x) * W;\n        G = 1.0 - (1.0 - BULLET_COLOR.y) * W;\n        B = 1.0 - (1.0 - BULLET_COLOR.z) * W;\n\t\tfragColor = vec4(R, G, B, 1.0);\n    }\n}\n\nvoid init(vec2 fragCoord){\n    uv = fragCoord;\n    \n    START_Y = iResolution.y / 2.0;\n    START_X = iResolution.x / 4.0;\n    MOVING_SPEED = iResolution.x * 0.5 / TIME_PHASE1;\n    \n    explosionX = START_X + MOVING_SPEED * TIME_PHASE1;\n    explosionY = START_Y;\n}\n\n#define rand(x, y) fract(cos(x * (12.9898) + y * (4.1414)) * 43758.5453)\n#define rand2(x, y) fract(cos(x * (11.2333) + y * (6.6262)) * 43758.5453)\n\nvoid randExplusionEffect(float t, vec2 xy){\n    float ti = ceil(iTime / TIME_PHASE2);\n\tvec2 seed = vec2(ti, 100.0 / (ti + 1.0));\n    int i;\n    float r;\n    float degree;\n    for(i = 0; i < SQUARE_COUNT; ++i){\n        r = rand(seed.x, seed.y) * EXPLOSION_RADIUS;\n        degree = rand2(seed.x, seed.y) * PI * 2.0;\n        \n        square[i].x = explosionX + r * cos(degree);\n        square[i].y = explosionY + r * sin(degree);\n        square[i].z = \n            rand(square[i].x, square[i].y) * SQUARE_MAX_HALF_WIDTH * (\n            1.0 - t / (TIME_PHASE2 - TIME_PHASE1));\n        \n        seed.x = iResolution.x * rand(seed.x + ti, seed.y);\n        seed.y = iResolution.y * rand2(seed.y + ti, seed.x);\n    }\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    init(fragCoord);\n\t\n    // draw background\n    drawBackground(fragColor);\n    \n    float t = iTime;\n    while(t > TIME_PHASE2) {\n        t -= TIME_PHASE2;\n    }\n    \n    if(t < TIME_PHASE1){\n\t\tdrawBullet(t, fragColor);\n    }else{\n    \trandExplusionEffect(t - TIME_PHASE1, fragCoord);\n\t\tdrawExplosion(t - TIME_PHASE1, fragColor);\n    }\n}", "image_inputs": [{"id": "4sXGRn", "previewfilepath": "/media/ap/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tls3zN.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[589, 589, 629, 629, 703], [819, 819, 867, 887, 1347], [1349, 1349, 1394, 1432, 1948], [1950, 1950, 1976, 1976, 2213], [2363, 2363, 2406, 2406, 3073], [3075, 3075, 3132, 3132, 3472]], "test": "error"}
{"id": "tlX3W4", "name": "short shader study", "author": "Machia", "description": "test", "tags": ["raymarching"], "likes": 3, "viewed": 80, "published": "Public", "date": "1556312687", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/*\n\tcompressed shader study\n\n\treference from\n\thttp://glslsandbox.com/e#54303.0\n*/\n\n//マッピング（立体配置）\nfloat map(vec3 p) {\n\tfloat t = length(mod(p, 2.0) - 1.0) - 0.35;\n\treturn t;\n}\n\n//法線を取得する（ことで立体的な絵になる）\nvec3 getN(vec3 p) {\n\tfloat t = map(p);\n\tvec2 d = vec2(0.001, 0.0);\n    \n\treturn normalize(vec3(\n\t\tt - map(p + d.xyy),\n\t\tt - map(p + d.yxy),\n\t\tt - map(p + d.yyx)));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n\tvec2 uv = ( 2.0 * fragCoord.xy - iResolution.xy ) / min(iResolution.x , iResolution.y);\n    \n    //レイを飛ばす方向\n\tvec3 dir = normalize(vec3(uv, 1.0));\n    float x_po,y_po;\n    //調査ポジションの定義\n    \n    if( uv.x*uv.x + uv.y*uv.y >0.45){\n        x_po = -1.;\n        y_po = -0.;\n    }else{\n        x_po = 1.0;\n        y_po = 0.0;\n    }\n    if( (uv.x*uv.x + uv.y*uv.y)>1.0){\n        x_po =0.0;\n        y_po = 1.0;\n    }\n    \n    if(uv.x*uv.x + uv.y*uv.y>2.0){\n        x_po = 2.0;\n        y_po = -2.0;\n    }\n    \n    \n    vec3 pos = vec3(y_po*cos(iTime) ,x_po*sin(iTime) , iTime);\n\n    //変数定義\n\tfloat t= 0.0;\n    \n    int mx =75;//int(floor(20.*(sin(iTime)+1.) ) );\n    \n    //レイを飛ばして調査する\n\tfor(int i = 0 ; i < 25+mx; i++ ) {\n        //マップしてる図形に対しレイを飛ばし、\n        //その分距離を進める\n\t\tt += map(dir * t + pos);\n\t}\n    \n    //計算を終了した時点のレイの位置を定義する\n    vec3 ip = dir * t + pos;\n    \n    //法線定義\n\tvec3 L = normalize(vec3(1,2,3));\n\tvec3 N = getN(ip);\n    \n    // Output to screen\n    \n    //dot(L,N):法線とライトの座標との内積を求める\n    //dir*0.1:色を抑えてる（このままだとRGBがキツい）\n    fragColor = vec4(dot(L, N)*0.75 + x_po*3.*dir * 0.2, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tlX3W4.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[83, 119, 138, 138, 196], [198, 261, 280, 280, 426], [428, 428, 485, 535, 1862]], "test": "ok"}
{"id": "tlX3Wn", "name": "Grid Parallax", "author": "Wuszt", "description": "Simple grid", "tags": ["parallaxgrid"], "likes": 4, "viewed": 175, "published": "Public", "date": "1556041786", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const float CELLSIZE = 0.75f;\nconst float SPEED = 400.55f;\nconst float DIST = 0.1f;\n\nconst float OFFSET = 0.3f;\n\n#define FILL_WALLS\n\n#ifndef FILL_WALLS\nconst int ITERATIONS = 25;\n#endif\n\nvec4 Grid(vec2 uv)\n{    \n    float invertedAspect = iResolution.y / iResolution.x;\n    \n    uv.y *= invertedAspect;\n    uv.x += sin(iTime * SPEED * 1.0f / iResolution.x) * DIST;\n    uv.y += cos(iTime * SPEED * 1.0f / iResolution.x) * DIST;\n\n    float cellSize = 0.1f * CELLSIZE;\n    float thickness = 0.001f;\n\n    vec2 closest = round(uv / cellSize) * cellSize;\n    vec2 distances = abs(closest - uv);\n    distances.y *= 0.5f;\n    \n    float x = step(0.0f,thickness - distances.x);\n    float y = step(0.0f,thickness - distances.y);\n\n    return max(x,y) * vec4(1.0f,1.0f,0.5f,1.0f);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{    \n    vec2 uv = fragCoord/iResolution.xy;\n\n    vec2 centeredUV = uv;\n    centeredUV *= 2.0f;\n    centeredUV -= 1.0f;\n    fragColor = Grid(uv) * 10.0f;\n    \n    #ifdef FILL_WALLS\n    vec3 texelSize = 1.0f / iResolution;\n    int ITERATIONS = int(OFFSET / texelSize.x);\n    #endif\n    \n    for(int i=0;i<=ITERATIONS;++i)\n    {\n        float ratio = float(i) / float(ITERATIONS);      \n        fragColor += Grid(uv + OFFSET * (0.5f * ratio + 0.5f* smoothstep(0.0f, 0.2f,ratio)) * (-centeredUV)* (1.0f - ratio));\n    }\n    \n    fragColor /= float(ITERATIONS);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tlX3Wn.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[187, 187, 207, 207, 770], [772, 772, 829, 829, 1388]], "test": "ok"}
{"id": "tlXGD4", "name": "dvdfdfsdsfsdfdfsdfsadsf", "author": "lennyjpg", "description": "asdfasdfasf", "tags": ["asddadssdfsdaf"], "likes": 1, "viewed": 238, "published": "Public API", "date": "1556367846", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float grid(vec2 p, vec2 res){\n    p = mod(p,res.y);\n    float d = length(p-res.y*.5);\n    return smoothstep(d,d+1.5/iResolution.y, res.x);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.y;\n    vec2 res = vec2(.1,.2);\n    vec2 u = uv;\n    u.x +=  mod( u.y, res.x);\n    u.x -= u.y+iTime * .1;\n    if(uv.y > .5){\n   // u.x += sin(iTime)*0.1;\n        u +=  mod( u, res.x);\n    }\n    fragColor = vec4(grid(u,res));\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tlXGD4.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 29, 29, 140], [142, 142, 199, 199, 461]], "test": "ok"}
{"id": "tlXGW8", "name": "random uv grid", "author": "sako", "description": "random uv grid", "tags": ["glsl"], "likes": 5, "viewed": 307, "published": "Public", "date": "1556167942", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float rand(vec2 co){\n    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    uv *= 2.0; // scale\n    float sp = iTime/2.0;\n    uv -= sp;\n\n    vec2 grid = fract(uv);\n    float divN = 3.0;\n    vec2 id = floor(uv);\n    uv = mod(uv, divN);\n       \n    float randIdx = rand(id);\n    float randIdy = rand(id+vec2(100.0));\n    vec2 uv2 = grid;\n    float divX = 2.0; float divY = 2.0;\n    uv2.x *= (1.0+floor(randIdx*divX));\n    uv2.y *= (1.0+floor(randIdy*divY));\n\n    grid = fract(uv2);\n    id += floor(uv2)/vec2(divX, divY);\n   \n    vec3 col = vec3(rand(id), grid);\n    \n    //example\n    if(rand(id) < 0.2){\n        col = vec3(0.0);\n    }\n\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tlXGW8.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 20, 20, 92], [94, 94, 151, 151, 792]], "test": "ok"}
{"id": "tlXGzS", "name": "RayWa", "author": "ankd", "description": "The name of era of japan changed to \"Reiwa\" and I made this by \"Ray\"marching.", "tags": ["raymarching"], "likes": 4, "viewed": 83, "published": "Public", "date": "1556659823", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const float PI = 3.14159265359;\n\nmat2 rotate(in float r){\n    float c=cos(r), s=sin(r);\n    return mat2(c, -s, s, c);\n}\nfloat hash(in vec2 n){\n    return fract(sin(dot(n, vec2(12.9898, 78.233)))*46123.9878);\n}\nvec3 hash3(in vec2 n){\n    return vec3(\n            hash(n+vec2(1.0)),\n            hash(n+vec2(10000.0)),\n            hash(n+vec2(100.0))\n        );\n}\nfloat usin(in float x){\n  return 0.5+0.5*sin(x);\n}\nfloat easeInOut(in float x, in float e){\n    float x2 = x*2.0;\n    return x<0.5 ? 0.5*pow(x2, e) : 1.0-0.5*pow(2.0-x2, e);\n}\n\n\nfloat sdSphere(in vec3 p, in float r){\n    return length(p) - r;\n}\nfloat sdPlane(in vec3 p, in float h){\n    return p.y - h;\n}\nfloat sdBox(in vec3 p, in vec3 b){\n    vec3 d = abs(p) - b;\n    return length(max(d, 0.)) + min(max(d.x, max(d.y, d.z)), 0.);\n}\n\nfloat rei(in vec3 p){\n    vec3 q = p;\n    float res,d;\n\n    // top obj\n    q.x = abs(q.x);\n    q.y -= 0.6;\n    q.xy *= rotate(PI*0.25);\n    d = sdBox(q, vec3(1.0, 0.1, 0.1));\n    res = d;\n\n    // point\n    q = p;\n    q -= vec3(0., 0.1, 0.);\n    q.xy *= rotate(PI*0.25);\n    d = sdBox(q, vec3(0.1));\n    res = min(res,d);\n\n    // bottom obj\n    q = p;\n    d = sdBox(q-vec3(0., -0.2, 0.), vec3(0.4, 0.1, 0.1));\n    d = min(d, sdBox(q-vec3(0.3, -0.5, 0.), vec3(0.1, 0.2, 0.1)));\n    d = min(d, sdBox(q-vec3(0.2, -0.6, 0.), vec3(0.15, 0.1, 0.1)));\n    d = min(d, sdBox(q-vec3(-0.15, -0.55, 0.), vec3(0.1, 0.28, 0.1)));\n    res = min(res,d);\n\n    return res;\n}\nfloat wa(in vec3 p){\n    vec3 tmp_p = p;\n    vec3 q;\n    float res,d;\n\n    // left obj (nogi_hen)\n    p = tmp_p-vec3(-0.4, 0., 0.);\n    q = p;\n    d = sdBox(q-vec3(-0.02, 0.45, 0.), vec3(0.25, 0.08, 0.1));\n    d = min(d, sdBox(q-vec3(0., 0.05, 0.), vec3(0.4, 0.1, 0.1)));\n    d = min(d, sdBox(q-vec3(0., -0.2, 0.), vec3(0.08, 0.6, 0.1)));\n    q.x = abs(q.x);\n    q.xy *= rotate(PI*0.25);\n    d = min(d, sdBox(q, vec3(0.5, 0.08, 0.1)));\n    res = d;\n\n    // right obj (tsukuri)\n    p = tmp_p-vec3(0.4, 0., 0.);\n    q = p - vec3(0., -0.2, 0.);\n    d = max(-sdBox(q, vec3(0.2, 0.25, 0.2)), sdBox(q, vec3(0.3, 0.35, 0.1)));\n    res = min(res, d);\n\n    return res;\n}\n\nfloat reiwa(in vec3 p){\n    vec3 q = p;\n    float t = iTime*0.8;\n    float it = floor(t);\n    float ft = fract(t);\n\n    float d_rei = rei(q);\n    float d_wa = wa(q);\n    float d_reiwa = min(rei(q-vec3(-0.9, 0., 0.)), wa(q-vec3(0.8, 0., 0.)));\n\n    float pattern = floor(mod(t, 3.0));\n    float pct = easeInOut(ft, 8.0);\n    return  pattern<1.0 ? mix(d_rei, d_wa, pct) :\n            pattern<2.0 ? mix(d_wa, d_reiwa, pct) :\n                          mix(d_reiwa, d_rei, pct);\n}\n\nvec3 opRep(in vec3 p, in vec3 c){\n    return mod(p-0.5*c, c) - 0.5*c;\n}\n\nvec2 map(in vec3 p){\n    vec3 q = p;\n\n    for(int i=0;i<2;i++){\n        q = abs(q) - vec3(4.0);\n        q.xy *= rotate(iTime*0.2);\n        q.yz *= rotate(iTime*0.3);\n        q.zx *= rotate(iTime*0.1);\n    }\n    q = opRep(q, vec3(5.0+floor(q)));\n    q = mix(p, q, easeInOut(usin(iTime*0.5), 4.0));\n    vec2 res = vec2(reiwa(q), 1.0);\n    return res;\n}\n\nvec2 castRay(in vec3 ro, in vec3 rd){\n    float minD=0.5, maxD=20.0;\n    float d = minD, m = -1.0;\n    for(int i=0;i<32;i++){\n        vec2 tmp = map(ro + rd*d);\n        if(tmp.x<0.001 || maxD<tmp.x) break;\n        d += tmp.x;\n        m = tmp.y;\n    }\n    if(maxD<d) m = -1.0;\n    return vec2(d, m);\n}\n\nvec3 calcNormal(in vec3 p){\n    vec2 e = vec2(1.0, -1.0)*0.0001;\n    return normalize(vec3(\n            e.xyy*map(p+e.xyy).x +\n            e.yxy*map(p+e.yxy).x +\n            e.yyx*map(p+e.yyx).x +\n            e.xxx*map(p+e.xxx).x\n        ));\n}\n\nvec3 render(in vec3 ro, in vec3 rd){\n  vec3 color = vec3(0.0);\n\n  vec2 res = castRay(ro, rd);\n  float d = res.x;\n  float m = res.y;\n\n  vec3 pos = ro + rd*d;\n  vec3 nor = calcNormal(pos);\n\n  vec3 lp = vec3(1.0);\n  vec3 ld = normalize(lp - pos);\n\n  color =\n      m==1.0 ? mix(vec3(1.), vec3(0.1, 0.4, 0.9), exp(-0.2*length(pos-lp)))*clamp(dot(ld, nor), 0., 1.):\n               vec3(1.0);\n\n  return color;\n}\n\nmat3 lookAt(in vec3 eye, in vec3 tar, in float r){\n    vec3 cw = normalize(tar - eye);\n    vec3 cp = vec3(sin(r), cos(r), 0.);\n    vec3 cu = normalize(cross(cw, cp));\n    vec3 cv = normalize(cross(cu, cw));\n    return mat3(cu, cv, cw);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    vec2 p = (fragCoord.xy * 2.0 - iResolution.xy) / min(iResolution.x, iResolution.y);\n\n    float t = iTime*1.4 + 1.0*sin(iTime*0.8);\n    float it = floor(t);\n    float ft = fract(t);\n    ft = sqrt(ft);\n\n    vec3 ro1 = hash3(vec2(it))*2.0-1.0;\n    vec3 ro2 = hash3(vec2(it+1.0))*2.0-1.0;\n    vec3 roa = mix(ro1, ro2, ft)*mix(3.0, 1.0, easeInOut(clamp(iTime*0.1, 0., 1.), 4.0));\n    vec3 rob = vec3(0., 0., 1.0+sin(iTime*0.2));\n\n    vec3 tar = vec3(0.);\n    vec3 rda = lookAt(roa, tar, 0.)*normalize(vec3(p, 1.0));\n    vec3 rdb = lookAt(rob, tar, 0.)*normalize(vec3(p, 1.0));\n\n    vec3 colora = render(roa, rda);\n    vec3 colorb = render(rob, rdb);\n\n    vec3 color = mix(colora, colorb, easeInOut(usin(iTime*0.45), 6.0));\n\n    fragColor = vec4(color, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tlXGzS.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[33, 33, 57, 57, 119], [120, 120, 142, 142, 209], [210, 210, 232, 232, 360], [361, 361, 384, 384, 411], [412, 412, 452, 452, 536], [539, 539, 577, 577, 605], [606, 606, 643, 643, 665], [666, 666, 700, 700, 793], [795, 795, 816, 816, 1450], [1451, 1451, 1471, 1471, 2112], [2114, 2114, 2137, 2137, 2589], [2591, 2591, 2624, 2624, 2662], [2664, 2664, 2684, 2684, 3014], [3016, 3016, 3053, 3053, 3316], [3318, 3318, 3345, 3345, 3561], [3563, 3563, 3599, 3599, 3967], [3969, 3969, 4019, 4019, 4206], [4208, 4208, 4264, 4264, 5023]], "test": "timeout"}
{"id": "ts2SDt", "name": "Basics - Patterns", "author": "trevorleake", "description": "Study in basic shaders and combining techniques of coordinate manipulation.", "tags": ["patterns", "dots", "translation", "basics"], "likes": 4, "viewed": 1012, "published": "Public", "date": "1555391273", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const float PI = 3.1415926535897932384626433832795;\n\n\nfloat circles(vec2 uv, float r){\n    // Position of point assuming center is (.5,.5)\n    vec2 pos = vec2(0.5)-fract(uv);\n    \n    // Find squared distance from origin\n    float lineLength = distance(pos, vec2(0.));\n    return 1.-step(r, lineLength);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.yy;\n\n    // Scale the coords up by 5\n    uv *= 5.;\n    \n    // Note the column and row of each coord\n\tvec2 colRow = floor(uv);\n\n    // Grab fractional remainders for each to create [0, 1] blocks\n    uv = fract(uv);\n\n    // This flips if seconds are even or odd\n    bool flipper = mod(floor(iTime), 2.) == 0.;\n    \n    // Scaled and offset so seconds are in increments of Pi\n    float t = PI/2.+(fract(iTime)*PI);\n    \n    float v = (sin(t)+1.)/2.;\n    if(flipper){\n        // For any pixel in an even column\n        if(mod(colRow.x, 2.) == 0.)\n            uv += vec2(0, v);\n        else\n            uv -= vec2(0, v);\n    }\n    else{\n        // For any pixel in an even row\n        if(mod(colRow.y, 2.) == 0.)\n            uv += vec2(v,0.);\n        else\n            uv -= vec2(v,0.);\n    }\n\n    \n    \n    // Lets look at colors now    \n    vec3 col = vec3(0.);\n\n    // Paint the coordinate system with colors\n//  col = vec3(uv.x, uv.y,0);\n    \n    // Paint in the circles, without destroying the background\n    float val = circles(uv, .1);\n    if(val != 0.)\n\t    col = vec3(val);\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ts2SDt.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[54, 54, 86, 138, 305], [308, 308, 365, 415, 1591]], "test": "ok"}
{"id": "ts2SWd", "name": "Forbidden sign", "author": "jblanper", "description": "Pulsating forbidden sign.", "tags": ["2d"], "likes": 2, "viewed": 87, "published": "Public", "date": "1555408020", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float fill (float d, float r, float blur) {\n  return smoothstep(r, r - .005 - blur, d);\n}\n\nfloat stroke (float d, float r, float lw, float blur) {\n  float hlw = lw / 2.;\n  return smoothstep(r + hlw + .005, r + (hlw * blur), d) *\n    smoothstep(r - hlw - .005, r - (hlw * blur), d);\n}\n\nfloat dfSquare (vec2 p, vec2 ratio) {\n  return max(abs(p.x) / ratio.x, abs(p.y) / ratio.y);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = (fragCoord.xy - .5 * iResolution.xy) / iResolution.y;\n\n  \tvec3 color = vec3(0.);\n\n    float t = sin(iTime * 1.5) * .05 + .05;\n\tfloat r = length(uv); // for circle\n\n  \t// background\n    color += cos(fract(uv.x/uv.y*5.+iTime*.4) * 5.) * 2.5;\n  \tcolor *= mix(color, vec3(.2, .3, .8) * 1.5, r + .3 - t * 1.5);\n    \n    // forbidden sign\n  \tcolor = mix(color, vec3(0.), fill(r, .313 + t, 0.));\n  \tcolor = mix(color, vec3(.8, .3, .2), fill(r, .32 + t, .02));\n  \tcolor = mix(color, vec3(1.), stroke(r, .3 + t, .02, 0.));\n  \tcolor = mix(color, vec3(1.), fill(dfSquare(uv, vec2(1. + t * 4., .3 + t * 1.)), .2, .005));\n  \tcolor += vec3(uv.y) * fill(r, .32 + t, .02);\n    \n    fragColor = vec4(color, 1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ts2SWd.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 43, 43, 89], [91, 91, 146, 146, 283], [285, 285, 322, 322, 378], [380, 380, 437, 437, 1148]], "test": "ok"}
{"id": "ts2SWt", "name": "Basics - Coordinate Scale", "author": "trevorleake", "description": "Study in scaling shaders by their coordinates. ", "tags": ["basics", "coordinates", "scale"], "likes": 1, "viewed": 1308, "published": "Public", "date": "1555383389", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float box(vec2 uv, vec2 topLeft, vec2 bottomRight)\n{\n    return uv.x > topLeft.x && uv.x < bottomRight.x && uv.y < topLeft.y && uv.y > bottomRight.y ? 1. : 0.;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\t\n    // Center our coordinate system    \n    vec2 uv = (fragCoord - .5*iResolution.xy) / min(iResolution.x, iResolution.y);\n    \n    // Scale that $#!+ !\n    uv *= 1.+.5*(sin(iTime));\n    \n    // Show space coordinates as colors on the background\n    vec3 col = vec3(uv.x,uv.y,0.0);\n    \n\t// Tack on a shape\n    col += box(uv, vec2(-.1,.1), vec2(.1,-.1));\n\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ts2SWt.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 52, 52, 161], [164, 164, 221, 262, 636]], "test": "ok"}
{"id": "ts2XDt", "name": "Orange And Teal", "author": "zackpudil", "description": "Nothing special here.  Added some mouse controls.", "tags": ["raymarching", "mouse", "ifs"], "likes": 11, "viewed": 442, "published": "Public API", "date": "1555397812", "time_retrieved": "2021-10-01T00:00:00", "image_code": "mat2 rot(float a) {\n    float s = sin(a);\n    float c = cos(a);\n    \n    return mat2(c, s, -s, c);\n}\n\nfloat box(vec3 p, vec3 b) {\n    vec3 q = abs(p) - b;\n    return max(max(q.x, q.y), q.z);\n}\n\nvec2 shape(vec3 p) {\n    float a = box(p, vec3(1));\n    \n\tp = abs(p) - vec3(1);\n    float b = box(p + vec3(1, 0, 0), vec3(1.200,0.200,0.200));\n    float c = box(p + vec3(0, 0, 1), vec3(0.2, 0.2, 1));\n    float d = box(p + vec3(0, 1, 0), vec3(0.2, 1, 0.2));\n    \n    vec2 s = vec2(a, 1.0);\n    vec2 t = vec2(min(b, min(c, d)), 2.0);\n    \n    return s.x < t.x ? s : t;\n}\n\nvoid opIFS(inout vec4 q) {\n    for(int i = 0; i < 9; i++) {\n        q.xyz = abs(q.xyz) - vec3(0.900,1.393,0.594);\n        q.xz *= rot(0.628 + float(i)*0.932);\n        q.xy *= rot(0.644);\n        \n        q *= 1.2;\n    }\n}\n\nvec2 de(vec3 p) {\n    vec4 q = vec4(p, 1);\n    \n    opIFS(q);\n    \n    return shape(q.xyz)/vec2(q.w, 1);\n}\n\nvec3 form(vec2 p, sampler2D s) {\n    for(int i = 0; i < 3; i++) {\n        p = abs(p)/clamp(dot(p, p), 0.5, 1.0) - vec2(0.1, 0.3);\n        p *= rot(0.33);\n    }\n    \n    return texture(s, p).rgb;\n}\n\nvec3 mat(vec3 p, vec3 n, sampler2D s) {\n    vec3 m = pow(abs(n), vec3(10.0));\n    m /= dot(vec3(1), m);\n    \n    vec3 x = form(p.yz, s);\n    vec3 y = form(p.xz, s);\n    vec3 z = form(p.xy, s);\n    \n    return (m.x*x*x + m.y*y*y + m.z*z*z);\n}\n\nvec3 bump(vec3 p, vec3 n, sampler2D s, float bf) {\n    vec2 h = vec2(0.01, 0);\n    vec3 g = mat3(\n        mat(p - h.xyy, n, s),\n        mat(p - h.yxy, n, s),\n        mat(p - h.yyx, n, s)\n    )*vec3(0.299, 0.548, 0.114);\n    \n    g -= dot(mat(p, n, s), vec3(0.299, 0.548, 0.114));\n    g -= n*dot(g, n);\n    \n    return normalize(n + bf*g);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = (gl_FragCoord.xy - 0.5*iResolution.xy)/iResolution.y;\n    vec2 mo = 5.0*iMouse.xy/iResolution.xy;\n    \n    vec3 col = vec3(0);\n    \n    float a = 6.8;\n    float at = iTime*0.1;\n    \n    vec3 ro = vec3(a*sin(at + mo.x), 2.0*sin(at*2.0 + mo.y), -a*cos(at + mo.x));\n    vec3 ww = normalize(vec3(0)-ro);\n    vec3 uu = cross(vec3(0, 1, 0), ww);\n    vec3 vv = cross(ww, uu);\n    vec3 rd = normalize(mat3(uu, vv, ww)*vec3(uv, 1));\n    \n    float t = 0.0, m = -1.0, mx = 10.0;\n    for(int i = 0; i < 200; i++) {\n        vec2 d = de(ro + rd*t);\n        if(d.x < 0.001 || t >= mx) break;\n        t += d.x*0.5;\n        m = d.y;\n    }\n    \n    if(t < mx) {\n        vec3 p = ro + rd*t;\n        vec2 h = vec2(0.001, 0.0);\n        vec3 n = normalize(vec3(\n            de(p + h.xyy).x - de(p - h.xyy).x,\n            de(p + h.yxy).x - de(p - h.yxy).x,\n            de(p + h.yyx).x - de(p - h.yyx).x\n        ));\n        \n        vec3 ld = normalize(p);\n        \n        vec3 alb = vec3(1);\n        vec4 q = vec4(p, 1);\n        \n        opIFS(q);\n        if(m == 1.0) {\n\t\t\talb = vec3(0.075,0.401,1.000);\n            n = bump(p, n, iChannel0, 0.2);\n        } else if(m == 2.0) {\n            alb = vec3(1.000,0.550,0.015);\n            n = bump(p, n, iChannel0, 0.15);\n        }\n        \n        float oat = t/50.0;\n        float occ = exp2(-pow(max(0.0, 1.0 - de(p + n*oat).x/oat), 2.0));\n        float dif = max(0.0, dot(ld, n));\n        \n        float sp = pow(max(0.0, dot(reflect(-ld, n), -rd)), 32.0);\n        \n        col = 0.75*occ*(alb*(0.25 + dif) + 2.0*vec3(0.6, 0.7, 1.0)*sp);\n    }\n    \n    fragColor = vec4(pow(col, vec3(0.4545)), 1);\n}", "image_inputs": [{"id": "Xsf3zn", "previewfilepath": "/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ts2XDt.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 19, 19, 100], [102, 102, 129, 129, 192], [194, 194, 214, 214, 562], [564, 564, 590, 590, 785], [787, 787, 804, 804, 893], [895, 895, 927, 927, 1091], [1093, 1093, 1132, 1132, 1334], [1336, 1336, 1386, 1386, 1676], [1678, 1678, 1735, 1735, 3377]], "test": "error"}
{"id": "ts2XRc", "name": "unnatural girl", "author": "taso69", "description": "Inspired by MV of Perfume「不自然なガール」\nhttps://youtu.be/kfqToOh7MVA?t=30", "tags": ["3d", "raymarching", "tetrahedron"], "likes": 3, "viewed": 86, "published": "Public", "date": "1554959356", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI 3.14195265359\n\nmat2 rotate(float a)\n{\n\tfloat s = sin(a);\n\tfloat c = cos(a);\n\treturn mat2(c, -s,s, c);\n}\n\n//https://www.shadertoy.com/view/Ws23zt\nfloat sdTetra(vec3 pos,float i){\n    pos.xy *= rotate(iTime+i);\n    pos.xz *= rotate(iTime*2.0);\n    return (max(abs(pos.x+pos.y)-pos.z,abs(pos.x-pos.y)+pos.z)-0.2)/sqrt(3.);\n}\n\nfloat sdPlane( vec3 pos){\n    vec3 n = normalize(vec3(0.0,1.0,0.0)); \n\treturn dot(pos,n.xyz);\n}\n\nfloat sdBox(vec3 pos, vec3 b){\n    vec3 d = abs(pos) - b;\n    return length(max(d,0.0)) + min(max(d.x,max(d.y,d.z)),0.0);\n}\n\nfloat sdPanel(vec3 pos){\n    float d = sdBox(pos,vec3(0.9,0.9,0.01));\n    d = max(d, -sdBox(pos-vec3(0.9,0.0,0.0),vec3(0.1,0.2,0.02)));\n    d = max(d, -sdBox(pos-vec3(-0.9,0.0,0.0),vec3(0.1,0.2,0.02)));\n    d = max(d, -sdBox(pos-vec3(0.0,0.9,0.0),vec3(0.2,0.1,0.02)));\n    d = max(d, -sdBox(pos-vec3(0.0,-0.9,0.0),vec3(0.2,0.1,0.02)));\n    return d;\n}\n\nvec3 rotPanel(vec3 p,vec3 id, float rep){\n    p.xy = mod(p.xy,rep)-rep*0.5; \n    \n    float c = 4.0;//rotation cycle\n    float d = 0.2;\n    float mt = mod(iTime,c);\n    float t = clamp(mt - (c-d), 0.0, 1.0)/d;\n    float rad =  mix(floor(iTime/c),floor(iTime/c+1.0),t)*PI/2.0;\n    p.xy *= rotate(rad);\n    //p.xy *= rotate(rad*(1.0-2.0*mod(id.y,2.0)));//switch the rotation direction by each row\n    return p;\n}\n\n\nvec2 map(vec3 pos){\n    float rep = 2.0;\n    float d = 100000.0;\n    float m = -1.0;\n    vec3 id = floor(pos/rep);\n    \n    float plane = sdBox(pos-vec3(0.0,-0.01,4.0),vec3(5.0,0.1,5.0));\n    d = min(d,plane);\n    m = (d < plane) ? m : 1.0;\n    \n    vec3 p = pos;\n    p.x += (1.0-2.0*mod(floor(p.y/rep),2.0))*iTime;\n    p = rotPanel(p,id,rep);\n    \n    if(id.x > -7.0 && id.x < 6.0 && id.y > -1.0 && id.y < 4.0){\n        float panel = sdPanel(p-vec3(0.0,0.0,2.0)); \n   \t\td = min(d,panel);\n        m = (d < panel) ? m : 2.0;\n    }\n\t\n    vec3 t1= vec3(-0.5,1.0,4.0),t2=vec3(0.0,1.0,4.0),t3=vec3(0.5,1.0,4.0);\n    t1.x += 2.0*sin(iTime*1.1); t1.y += 0.6*cos(iTime*1.3); t1.z += -1.0*sin(iTime*2.9);\n    t2.x += 2.0*cos(iTime*2.1); t2.y += -0.6*cos(iTime*0.8); t2.z += 1.0*sin(iTime*1.5);\n    t3.x += -2.0*sin(iTime*0.6); t3.y += 0.6*sin(iTime*2.5); t3.z += 1.0*cos(iTime*1.2);\n    float tetra = min(sdTetra(pos-t1,1.0),\n                     min(sdTetra(pos-t2,2.0),sdTetra(pos-t3,3.0)));\n    d = min(d,tetra);\n    m = (d < tetra) ? m : 3.0;\n\t\n    return vec2(d,m);\n}\n\n//https://www.shadertoy.com/view/Xds3zN\nfloat calcSoftshadow( in vec3 ro, in vec3 rd, in float mint, in float tmax )\n{\n    // bounding volume\n    float tp = (10.0-ro.y)/rd.y; if( tp>0.0 ) tmax = min( tmax, tp );\n\n    float res = 1.0;\n    float t = mint;\n    for( int i=0; i<16; i++ )\n    {\n\t\tfloat h = map( ro + rd*t ).x;\n        res = min( res, 8.0*h/t );\n        t += clamp( h, 0.02, 0.10 );\n        if( res<0.005 || t>tmax ) break;\n    }\n    return clamp( res, 0.0, 1.0 );\n}\n\nvec3 calcNorm(vec3 pos)\n{\n    float d = 0.0001;\n    return normalize(vec3(\n        map(pos + vec3(  d, 0.0, 0.0)).x - map(pos + vec3( -d, 0.0, 0.0)).x,\n        map(pos + vec3(0.0,   d, 0.0)).x - map(pos + vec3(0.0,  -d, 0.0)).x,\n        map(pos + vec3(0.0, 0.0,   d)).x - map(pos + vec3(0.0, 0.0,  -d)).x\n    ));\n}\n\nvec3 texPanel(vec2 uv,vec2 id){\n    //range of uv : [-1,1]\n    float y =  mod(id.x,2.0) == 0.0 ? uv.y : -uv.y ;\n    vec3 c1,c2,c3,c4;\n    \n    float u = mod(id.x,2.0);\n    float v = mod(id.y,2.0);\n    \n    c1 = (u == 0.0) ? vec3(0.58, 0.9, 0.45) : vec3(0.07, 0.1, 0.55);\n    c2 = (u == 0.0) ? vec3(0.07, 0.1, 0.55) : vec3(0.58, 0.9, 0.45);\n    c3 = (u == 0.0) ? vec3(0.82, 0.12, 0.22) : vec3(0.36, 0.0, 0.48);\n    c4 = (u == 0.0) ? vec3(0.36, 0.0, 0.48) : vec3(0.82, 0.12, 0.22);\n    \n    float d1 = smoothstep(uv.x-0.05,uv.x,uv.y);\n    float d2 = smoothstep(uv.x-0.05,uv.x,-uv.y);\n    \n    vec3 p1 = mix(c1,c2,d1);\n    vec3 p2 =  mix(c3,c4,d2); \n    return u == v ? p1 : p2;\n}\n\nvec3 texPlane(vec2 uv){\n    vec3 col = vec3(0.0);\n    vec2 id = floor(uv/0.4);\n    float u = mod(id.x,4.0);\n    \n    if(u == 0.0) col = vec3(0.9);\n    if(u == 2.0) col = vec3(1.3);\n    \n    return col;\n}\n\nvec3 light = normalize(vec3(0.0,2.0,3.0));\n\nvec3 render(vec3 ro, vec3 rd){\n    vec3 col = vec3(0.0);\n    \n    float t = 0.0;\n    vec2 m;\n    vec3 pos;\n    for(int i = 0; i < 128; i++){\n        pos = ro + t*rd;\n      \tm = map(pos);\n        t += m.x*0.8;\n    }\n    pos = ro + t*rd;\n    \n    if(abs(m.x) < 0.0001){\n    \tvec3 norm = calcNorm(pos);\n        vec3 v = normalize(ro-pos);\n        vec3 l = normalize(light-pos);\n        vec3 r = normalize(reflect(-l,norm));\n    \n        float diff = clamp(dot(light, norm), 0.1, 1.0);\n        float spec = pow(max(dot(r,v), 0.0), 64.0);\n        float shadow = calcSoftshadow( pos, light, 0.02, 2.5 );\n        diff *=  shadow;\n      \n        vec3 tex;\n        if(m.y == 1.0){\n            tex = texPlane(pos.xz);\n        }\n        \n        if(m.y == 2.0){\n        \tfloat rep = 2.0;\n        \tvec3 p = pos;\n        \tp.x += (1.0-2.0*mod(floor(p.y/rep),2.0))*iTime;\n        \tvec3 id = floor(p/rep);\n        \n        \tp = rotPanel(p,id,rep);\n        \ttex = texPanel(p.xy,id.xy);\n        }\n        \n        if(m.y == 3.0){\n          tex = vec3(1.0,0.1,0.1);\n        }\n               \n    \tcol = clamp(vec3(diff)* tex,0.0,1.0) + vec3(0.1);\n        col += spec*vec3(.5);\n        \n    }else{\n        col = vec3(0.2);\n    }\n\treturn col ;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = (fragCoord.xy*2.0 - iResolution.xy)/min(iResolution.x,iResolution.y);\n    \n    vec3 up = vec3(0.,1.,0.);\n    vec3 lookAt = vec3(0.0,0.5,0.0);\n    vec3 ro = vec3(0.0,0.5,6.0);\n    ro.xz *= rotate(0.2*sin(iTime*0.5));\n    \n    vec3 cDir = normalize(lookAt-ro);\n    vec3 cSide = normalize(cross(cDir,up));\n    vec3 cUp = normalize(cross(cSide,cDir));\n     \n    vec3 rd= normalize(cSide * p.x + cUp * p.y + cDir );\n \n\tvec3 col = render(ro,rd);\n    vec2 q = fragCoord.xy / iResolution.xy;   \n    col *= 0.4 + 0.6 * pow(16.0 * q.x * q.y * (1.0 - q.x) * (1.0 - q.y), 0.1);\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ts2XRc.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[26, 26, 48, 48, 114], [116, 156, 188, 188, 332], [334, 334, 359, 359, 429], [431, 431, 461, 461, 554], [556, 556, 580, 580, 907], [909, 909, 950, 950, 1319], [1322, 1322, 1341, 1341, 2385], [2387, 2427, 2505, 2528, 2864], [2866, 2866, 2891, 2891, 3180], [3182, 3182, 3213, 3240, 3859], [3861, 3861, 3884, 3884, 4064], [4110, 4110, 4140, 4140, 5334], [5336, 5336, 5393, 5393, 6005]], "test": "timeout"}
{"id": "ts2XWy", "name": "Finals7 - Hypnosis", "author": "EmperorLem", "description": "nosis", "tags": ["hip"], "likes": 1, "viewed": 84, "published": "Public", "date": "1554895268", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec3 red = vec3(1.0, 0.0, 0.0);\nvec3 orange = vec3(1.0, 0.4, 0.0);\nvec3 green = vec3(0.0, 1.0, 0.0);\nvec3 blue = vec3(0.0, 0.0, 1.0);\nvec3 black = vec3(0.0, 0.0, 0.0);\n\nfloat rand(vec2 uv)\n{\n    //return fract(sin(dot(uv, vec2(12.9898,78.233)))*10000.*iTime);\n\t//return fract(sin(dot(uv, iMouse.xy))*10000.);\n\t//return (fract(sin(dot(uv, vec2(12., 70.)))*100000.));\n    return (fract(sin(dot(uv, vec2(12., 70.)))*43758.5453123));\n}\n\n// Value noise\nfloat noise(in vec2 st) {\n    vec2 i = floor(st);\n    vec2 f = fract(st);\n\n    // Four corners in 2D of a tile\n    float a = rand(i);\n    float b = rand(i + vec2(1.0, 0.0));\n    float c = rand(i + vec2(0.0, 1.0));\n    float d = rand(i + vec2(1.0, 1.0));\n\n    // Smooth Interpolation\n\n    // Cubic Hermine Curve.  Same as SmoothStep()\n    vec2 u = f*f*(3.0-2.0*f);\n    // u = smoothstep(0.,1.,f);\n\n    // Mix 4 coorners porcentages\n    return mix(a, b, u.x) + \n            (c - a)* u.y * (1.0 - u.x) + \n            (d - b) * u.x * u.y;\n}\n\n// Gradient noise\nvec2 hash( vec2 x )  // replace this by something better\n{\n    const vec2 k = vec2( 0.3183099, 0.3678794 );\n    x = x*k + k.yx;\n    return -1.0 + 2.0*fract( 16.0 * k*fract( x.x*x.y*(x.x+x.y)) );\n}\n\nfloat gnoise( in vec2 p )\n{\n    vec2 i = floor( p );\n    vec2 f = fract( p );\n\t\n\tvec2 u = f*f*(3.0-2.0*f);\n\n    return mix( mix( dot( hash( i + vec2(0.0,0.0) ), f - vec2(0.0,0.0) ), \n                     dot( hash( i + vec2(1.0,0.0) ), f - vec2(1.0,0.0) ), u.x),\n                mix( dot( hash( i + vec2(0.0,1.0) ), f - vec2(0.0,1.0) ), \n                     dot( hash( i + vec2(1.0,1.0) ), f - vec2(1.0,1.0) ), u.x), u.y);\n}\n\n// Simplex noise\nvec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec2 mod289(vec2 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec3 permute(vec3 x) { return mod289(((x*34.0)+1.0)*x); }\n\nfloat snoise(vec2 v) {\n    const vec4 C = vec4(0.211324865405187,  // (3.0-sqrt(3.0))/6.0\n                        0.366025403784439,  // 0.5*(sqrt(3.0)-1.0)\n                        -0.577350269189626,  // -1.0 + 2.0 * C.x\n                        0.024390243902439); // 1.0 / 41.0\n    vec2 i  = floor(v + dot(v, C.yy) );\n    vec2 x0 = v -   i + dot(i, C.xx);\n    vec2 i1;\n    i1 = (x0.x > x0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);\n    vec4 x12 = x0.xyxy + C.xxzz;\n    x12.xy -= i1;\n    i = mod289(i); // Avoid truncation effects in permutation\n    vec3 p = permute( permute( i.y + vec3(0.0, i1.y, 1.0 ))\n        + i.x + vec3(0.0, i1.x, 1.0 ));\n\n    vec3 m = max(0.5 - vec3(dot(x0,x0), dot(x12.xy,x12.xy), dot(x12.zw,x12.zw)), 0.0);\n    m = m*m ;\n    m = m*m ;\n    vec3 x = 2.0 * fract(p * C.www) - 1.0;\n    vec3 h = abs(x) - 0.5;\n    vec3 ox = floor(x + 0.5);\n    vec3 a0 = x - ox;\n    m *= 1.79284291400159 - 0.85373472095314 * ( a0*a0 + h*h );\n    vec3 g;\n    g.x  = a0.x  * x0.x  + h.x  * x0.y;\n    g.yz = a0.yz * x12.xz + h.yz * x12.yw;\n    return 130.0 * dot(m, g);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    float ratio = iResolution.x / iResolution.y;\n    uv *= 10.0;\n    float offset = mod(uv.y,2.)>1. ? -1. : 1.;\n    //float offset = step(1.,mod(uv.y,2.0));\n    //float offset2 = step(mod(uv.y,2.0), 1.);\n    \n\tuv.y += offset * sin(iTime) * 2.0;\n\t\n    //uv.x -= offset2 *iTime;\n    uv.x *= ratio;\n    \n    vec2 pos = vec2(0.5*ratio, 0.5);\n    \n    \n    uv = fract(uv);\n    uv -= pos ;\n   \t//uv *= rotate2d(tan(iTime * 3.0)  );\n    uv += pos;\n    //uv *= scale2d(vec2(1.0, 1.0)); \n    \n    orange *= sin(orange * 2.0) *2.0 / 0.5;\n    blue *= sin(blue * 2.0) / 1.0;\n    \n    //Dusk\n    vec3 timeDown = mix(red, red, uv.y);\n    vec3 dusk = mix(orange,timeDown, uv.y);\n    \n    \n    //Dawn\n    vec3 dawn = mix(blue, black, uv.y);\n    \n    vec3 rotation = mix(dusk, dawn,sin(iTime) + uv.y);\n    \n    float mNoise = gnoise(uv * cos(iTime)) / snoise(uv * atan(iTime) *2.0) / gnoise(uv * atan(iTime));\n    \n    // Output to screen\n    fragColor = vec4(rotation * mNoise,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ts2XWy.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[169, 169, 190, 365, 431], [433, 448, 473, 473, 984], [986, 1004, 1062, 1062, 1200], [1202, 1202, 1229, 1229, 1627], [1629, 1646, 1667, 1667, 1714], [1715, 1715, 1736, 1736, 1783], [1784, 1784, 1806, 1806, 1841], [1843, 1843, 1865, 1865, 2913], [2915, 2915, 2972, 3022, 4031]], "test": "ok"}
{"id": "tsBGR3", "name": "Splitting Spheres", "author": "BackwardsCap", "description": "Playing around with polar coordinates", "tags": ["spheres", "polar"], "likes": 5, "viewed": 647, "published": "Public API", "date": "1555508600", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float Circle(vec2 uv, vec2 p, float r, float blur){\n    \n    float d = length(uv-p);\n    \n    return smoothstep(r,r-blur,d);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float t = iTime;\n\n    vec2 uvo = (fragCoord-0.5*iResolution.xy)/iResolution.y;\n    uvo.x+=.3;\n    \n    vec2 gvo = fract(uvo*5.)-.5;\n    \n    vec2 st = vec2(atan(uvo.x,uvo.y), length(uvo));\n    \n    vec2 uv = vec2(st.x/6.2831-.5,st.y*20.);\n    \n    \n    float cr =sin(t*1.)*.1 + .15;\n    \n    float b = mod(t,1.);\n    float c = 0.;\n\tfloat mask = 0.;\n    vec2 gv = fract(uv*6.)-.5;\n    \n    vec3 col = vec3(0);\n    for( float x = -1.;x<=1.;x++){\n        for(float y=-1.;y<=1.;y++){\n\t\t\tfloat c2 =Circle(vec2(gv.x-x,gv.y-y), \n                             vec2((b-.5)+(uv.y-y)/50.,\n                                  sin(t*.1+uvo.y*10.)),\n                             .75,\n                             .9);\n            \n            \n            float c3 =Circle(vec2(gvo.x-x,gvo.y-y), \n                             vec2((b-.5),\n                                  uv.x+(fract(uv.x*5.)-(fract(uv.x)))\n                                  +.2)+sin(t*.5)*uvo.x/5.,\n                             .2*sin(uvo.y*4.-4.7)+uvo.x/4.+.2,\n                             .4*uvo.x+.25);\n                     \n            \n\t   \t \tc+= c2;\n            mask+=c3/2.;\n            \n            col= vec3(sin(t)/(-uv.y/10.),0.25,cos(t)+uv.y/15.);\n        }\n    }\n    \n    fragColor = vec4(mask*c*col,1.0);\n    fragColor*=10.;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tsBGR3.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 51, 51, 126], [128, 128, 185, 185, 1480]], "test": "ok"}
{"id": "tsBSzc", "name": "Jelly-Tube Forest", "author": "fizzer", "description": "Voxel-stepped and raytraced cylinders, with screenspace distortion to make them bendy. No distance field required here.", "tags": ["sketch", "colourful", "jelly", "tubes"], "likes": 74, "viewed": 862, "published": "Public", "date": "1554494489", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define AA 2 // Square root of the number of anti-aliasing samples to make.\n\nvec2 intersectSphere(vec3 ro, vec3 rd, vec3 org, float rad)\n{\n    float a = dot(rd, rd);\n    float b = 2. * dot(rd, ro - org);\n    float c = dot(ro - org, ro - org) - rad * rad;\n    float desc = b * b - 4. * a * c;\n    if (desc < 0.)\n        return vec2(1, 0);\n\n    return vec2((-b - sqrt(desc)) / (2. * a), (-b + sqrt(desc)) / (2. * a));\n}\n\nvec2 intersectCylinder(vec2 ro, vec2 rd, vec2 org, float rad)\n{\n    return intersectSphere(vec3(ro, 0), vec3(rd, 0), vec3(org, 0), rad);\n}\n\nvec3 nn = vec3(0);\nfloat u = 0.;\n\nvec3 tr2(vec3 o, vec3 r, vec2 t)\n{\n    o += r * (1e-4 + .5 - o.y) / r.y;\n    for(int i = 0; i < 38; ++i)\n    {\n        vec3 c = vec3(floor(o.x), 0, floor(o.z));\n\n        vec3 ofs = vec3(cos(c.z) * .1, 0, cos(c.x) * .1);      \n\n        float rad = .3+cos(c.x) * .1;\n        ofs.x = cos(t.y * 8. + c.z * 2.5) * rad / 4.;\n\n        float h = -(cos(c.x + 3. + c.z * 65.) * .5 + .5) * 11.8;\n\n        u = h;\n\n        float ht = (h - o.y) / r.y;\n        float ft = (-2.2 - o.y) / r.y;\n\n        vec2 cyl = intersectCylinder(o.xz, r.xz, (c + ofs).xz + .5, rad);\n        vec2 sph = intersectSphere(o, r, (c + ofs) + .5 + vec3(0, -.5 + h, 0), rad);\n\n        cyl.x = max(cyl.x, ht);\n\n        if(sph.x < cyl.x && sph.y > 0. && sph.x < sph.y)\n        {\n            nn = normalize(o + r * sph.x - ((c + ofs) + .5 + vec3(0, -.5 + h, 0)));\n            return o + r * sph.x;\n        }\n\n        if((cyl.x < sph.y || sph.x >= sph.y) && cyl.y > 0. && cyl.x < cyl.y)\n        {\n            nn.xz = o.xz + r.xz * cyl.x - ((c + ofs).xz + .5);\n            nn.y = 0.;\n            nn = normalize(nn);\n            return o + r * cyl.x;\n        }\n\n        c.xz = ((c.xz + max(sign(r.xz), 0.)) - o.xz) / r.xz;\n        float t = (dot(c.xz, step(c.xz, c.zx)) + 1e-4);\n        //      if(ft<t){nn=vec3(0,1,0);return o+r*ft;}\n        o += t * r;\n    }\n    return o;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.xy * 2. - 1.;\n    uv.y *= iResolution.y / iResolution.x;\n\n    vec3 acc = vec3(0);\n    float wsum = 0.;\n\n    float time = iTime;\n\n    for(int y = 0; y < AA; ++y)\n        for(int x = 0; x < AA; ++x)\n        {\n            vec2 t = uv.xy + vec2(x, y) / float(AA) * vec2(2.2) / iResolution.x;\n\n            vec3 o = vec3(1.4 + time / 3., 2.5, 0), r = normalize(vec3(t.xy + vec2(0, -1), -3.5));\n\n            {\n                float ang = -3.14159 / 5.;\n                r.xz *= mat2(cos(ang), sin(ang), -sin(ang), cos(ang));\n            }\n\n            vec3 rp;\n            fragColor.rgb = vec3(0);\n\n            rp = tr2(o, r, t);\n            u += o.y * 75.;\n            u += rp.y / 4.;\n\n            {\n                vec3 rd = r;\n                vec3 n = normalize(nn);\n                vec3 r = reflect(rd, n);\n                float fresnel = pow(clamp(1. - dot(n, -rd), 0., 1.), 2.);\n\n                float spec = step(max(abs(3. + r.x * o.y / r.y) - 4., abs(+r.z * o.y / r.y)), 1.4) * step(0., r.y);\n                spec += step(max(abs(-6.6 + r.x * o.y / r.y) - 2., abs(+r.z * o.y / r.y)), 1.4) * step(0., r.y) / 3.;\n\n                spec += step(abs(r.x-1.),.4)/7.;\n\n                fragColor.rgb += (vec3(cos(u), cos(u * 2.), cos(u * 3.)) * .5 + .5) * mix(.9, 1., fresnel);\n\n                vec3 rp2 = rp * 10.;\n                fragColor.rgb = mix(fragColor.rgb, vec3(1), .1 - .1 * smoothstep(.0, .05, length(rp2 - (floor(rp2) + cos(time + floor(rp2.zxy) * 9.) * .4 + .5)) - .1));\n\n                vec3 rp3 = rp * 3.;\n                fragColor.rgb *= mix(.7, 1., smoothstep(.0, .01, length(rp3 - (floor(rp3) + cos(floor(rp3.zxy) * 9.) * .25 + .5)) - .2));\n\n                fragColor.rgb *= rp.y / 10. + 1.5;\n\n                fragColor.rgb += 1.5 * spec * fresnel + fresnel / 15.;\n            }\n\n            acc += clamp(fragColor.rgb, 0., 1.);\n            wsum += 1.;\n        }\n    fragColor.rgb = pow(acc / wsum, vec3(1. / 2.2));\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tsBSzc.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[77, 77, 138, 138, 417], [419, 419, 482, 482, 557], [593, 593, 627, 627, 1924], [1926, 1926, 1983, 1983, 3951]], "test": "ok"}
{"id": "tsBXDG", "name": "D&D 002 - Basic SDF", "author": "Ryp", "description": "First attempt at SDFs", "tags": ["sdf"], "likes": 1, "viewed": 77, "published": "Public", "date": "1554826894", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float saturate(float v)\n{\n    return clamp(v, 0.0, 1.0);\n}\n\nmat4 viewMatrix(vec3 eye, vec3 center, vec3 up) {\n\tvec3 f = normalize(center - eye);\n\tvec3 s = normalize(cross(f, up));\n\tvec3 u = cross(s, f);\n\treturn mat4(\n\t\tvec4(s, 0.0),\n\t\tvec4(u, 0.0),\n\t\tvec4(-f, 0.0),\n\t\tvec4(0.0, 0.0, 0.0, 1)\n\t);\n}\n\nfloat intersectSDF(float distA, float distB) {\n    return max(distA, distB);\n}\n\nfloat unionSDF(float distA, float distB) {\n    return min(distA, distB);\n}\n\nfloat opSmoothUnion( float d1, float d2, float k )\n{\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h);\n}\n\nfloat differenceSDF(float distA, float distB) {\n    return max(distA, -distB);\n}\n\nfloat sphereSDF(vec3 p)\n{\n    return length(p) - 1.0;\n}\n\nconst int MAX_MARCHING_STEPS = 200;\nconst float EPSILON = 0.001f;\n\nfloat sceneSDF(vec3 p)\n{\n    vec3 hole1 = vec3(-0.5 - 0.7 * sin(iTime * 0.47));\n    vec3 hole2 = vec3(0.51 + 0.5 * sin(iTime));\n    \n    float hole1Size = 0.5;\n    float hole2Size = 0.9;\n    \n    return opSmoothUnion(\n        sphereSDF(p + sin(iTime * -0.99)),\n        sphereSDF(p + sin(iTime))\n        , 0.5\n    );\n    \n    return intersectSDF(\n        \t\tintersectSDF(\n                    sphereSDF(p),\n                  \t-sphereSDF((p + hole1) / hole1Size) * hole1Size\n                ),\n        \t\t-sphereSDF((p + hole2) / hole2Size) * hole2Size\n    \t\t);\n}\n\nfloat shortestDistanceToSurface(vec3 eye, vec3 marchingDirection, float start, float end) {\n    float depth = start;\n    for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n        float dist = sceneSDF(eye + depth * marchingDirection);\n        if (dist < EPSILON) {\n\t\t\treturn depth;\n        }\n        depth += dist;\n        if (depth >= end) {\n            return end;\n        }\n    }\n    return end;\n}\n\nvec3 estimateNormal(vec3 p)\n{\n    return normalize(vec3(\n        sceneSDF(vec3(p.x + EPSILON, p.y, p.z)) - sceneSDF(vec3(p.x - EPSILON, p.y, p.z)),\n        sceneSDF(vec3(p.x, p.y + EPSILON, p.z)) - sceneSDF(vec3(p.x, p.y - EPSILON, p.z)),\n        sceneSDF(vec3(p.x, p.y, p.z  + EPSILON)) - sceneSDF(vec3(p.x, p.y, p.z - EPSILON))\n    ));\n}\n\nconst float pi = 3.14159265358;\n\nfloat deg2rad(float angleDeg)\n{\n \treturn (angleDeg * pi) / 180.f;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 positionUV = fragCoord / iResolution.xy;\n    vec2 positionNDC = 2.0 * positionUV - 1.0;\n    \n    // Camera setup\n    float cameraHFovAngle = deg2rad(55.f);\n    float cameraNear = 0.1f;\n    float cameraFar = 10.0f;\n    vec3 eyePositionWS = vec3(0.0f, 0.0f, -5.0f);\n    //vec3 eyeOrientationWS = vec3(1.0f, 0.0f, 0.0f);\n\n    // Viewport calculations\n    float aspectRatioInv = iResolution.y / iResolution.x;\n    \n    float horizontalFov = cameraNear * tan(cameraHFovAngle * 0.5f);\n \tfloat verticalFov = horizontalFov * aspectRatioInv;\n    vec2 cameraViewportExtent = vec2(horizontalFov, verticalFov);\n    \n    vec3 viewRayDirectionWS = vec3(positionNDC * cameraViewportExtent, cameraNear);\n    viewRayDirectionWS = normalize(viewRayDirectionWS);\n    \n    float rayDepth = shortestDistanceToSurface(eyePositionWS, viewRayDirectionWS, cameraNear, cameraFar);\n\n    vec3 p = eyePositionWS + rayDepth * viewRayDirectionWS;\n    \n    vec3 lightPosWS = vec3(1.0, 1.0, -2.0);\n    vec3 normalWS = estimateNormal(p);\n    vec3 L = normalize(lightPosWS - p);\n    vec3 V = normalize(eyePositionWS - p);\n    vec3 R = normalize(reflect(-L, normalWS));\n    \n    float dotLN = saturate(dot(L, normalWS));\n    float dotRV = saturate(dot(R, V));\n        \n    // Output some color\n    vec3 color = vec3(0.0);\n\t\n    if (rayDepth > cameraFar - EPSILON)\n    {\n        // Didn't hit anything\n        color = vec3(0.0);\n    }\n    else\n    \tcolor = vec3(1.0) * dotLN;\n    \n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tsBXDG.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 25, 25, 58], [60, 60, 109, 109, 296], [298, 298, 344, 344, 376], [378, 378, 420, 420, 452], [454, 454, 506, 506, 605], [607, 607, 654, 654, 687], [689, 689, 714, 714, 744], [813, 813, 837, 837, 1371], [1373, 1373, 1464, 1464, 1770], [1772, 1772, 1801, 1801, 2111], [2146, 2146, 2177, 2177, 2213], [2215, 2215, 2270, 2270, 3759]], "test": "ok"}
{"id": "tsBXRc", "name": "procedural antho", "author": "louis_C", "description": "drawing with curve", "tags": ["drawingcurve"], "likes": 17, "viewed": 246, "published": "Public", "date": "1554487431", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float rand ( vec2 uv) {return  fract(sin(dot(floor(uv),vec2(75.365,12.365)))*4285.365);}\nfloat noise ( vec2 uv) {\nfloat a = rand(uv);\nfloat b = rand (uv+vec2(1,0));\n float c  = rand (uv+vec2(0,1));\n float d  = rand ( uv+vec2(1,1));\nvec2 u =smoothstep(0.,1.,fract(uv));\nreturn mix (a,b,u.x)+(c-a)*u.y*(1.-u.x)+(d-b)*u.x*u.y;\n}\nfloat sdBezier(vec2 pos, vec2 A, vec2 B, vec2 C)\n{    \n    vec2 a = B - A;\n    vec2 b = A - 2.0*B + C;\n    vec2 c = a * 2.0;\n    vec2 d = A - pos;\n    float kk = 1.0 / dot(b,b);\n    float kx = kk * dot(a,b);\n    float ky = kk * (2.0*dot(a,a)+dot(d,b)) / 3.0;\n    float kz = kk * dot(d,a);      \n    float res = 0.0;\n    float p = ky - kx*kx;\n    float p3 = p*p*p;\n    float q = kx*(2.0*kx*kx - 3.0*ky) + kz;\n    float h = q*q + 4.0*p3;\n    if(h >= 0.0)  { \n        h = sqrt(h);\n        vec2 x = (vec2(h, -h) - q) / 2.0;\n        vec2 uv = sign(x)*pow(abs(x), vec2(1.0/3.0));\n        float t = uv.x + uv.y - kx;\n        t = clamp( t, 0.0, 1.0 );\n        vec2 qos = d + (c + b*t)*t;\n        res = length(qos);}\n    else{\n        float z = sqrt(-p);\n        float v = acos( q/(p*z*2.0) ) / 3.0;\n        float m = cos(v);\n        float n = sin(v)*1.732050808;\n        vec3 t = vec3(m + m, -n - m, n - m) * z - kx;\n        t = clamp( t, 0.0, 1.0 );\n        vec2 qos = d + (c + b*t.x)*t.x;\n        float dis = dot(qos,qos);        \n        res = dis;\n        qos = d + (c + b*t.y)*t.y;\n        dis = dot(qos,qos);\n        res = min(res,dis);\n        qos = d + (c + b*t.z)*t.z;\n        dis = dot(qos,qos);\n        res = min(res,dis);\n        res = sqrt( res );}\n        return res;}\nfloat rd (float t ) {return fract(sin(dot(floor(t),45.236))*4978.236);}\nfloat no (float t ) {return mix(rd(t),rd(t+1.),smoothstep(0.,1.,fract(t)));}\nvec2 rd2 (float t ) {return vec2(fract(sin(dot(floor(t*10.),45.236))*4978.236),\n                                 fract(sin(dot(floor(t*10.),97.236))*4978.236));}\nvec2 no2 (float t ) {return mix(rd2(t),rd2(t+1.),smoothstep(vec2(0.),vec2(1.),vec2(fract(t))));}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n\tvec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.y+vec2(0.,-0.1);\n        //+vec2(noise(uv*20.+iTime*10.)-0.5,noise(uv*20.+73.26+iTime*10.)-0.5)\n        //*no(iTime*100.)*0.05;\n    float d1 = 0.;\n    float d2 = 0.;\n    float d3 = 0.;\n    float d4 = 0.;\n    float d5 = 0.;\n    float d6 = 0.;\n    float d7 = 0.;\n    float d8 = 0.;\n    float d9 = 0.;\n    float d10 = 0.;\n    float d11 = 0.;\n    float d12 = 0.;\n    float d13 = 0.;\n    float d14 = 0.;\n    float d15 = 0.;\n    float d16 = 0.;\n    float d17 = 0.;\n    float d18 = 0.;    \n    float d19 = 0.;\n    for (int i = 0; i < 4 ; i++){\n    vec2 p1 =vec2(0.2,-0.7)+no2(iTime+float(i)*76.23)*0.1; \n    vec2 p2 =vec2(0.15,-0.75)+no2(iTime+float(i)*15.23)*0.1;\n    vec2 p3 =vec2(0.,-0.9)+no2(iTime+float(i)*64.23)*0.1;\n    vec2 p4 =vec2(0.65,0.1)+no2(iTime+float(i)*19.23)*0.1;\n    vec2 p5 =vec2(0.2,0.55)+no2(iTime+float(i)*60.23)*0.1;\n    vec2 p6 =vec2(0.,0.1)+no2(iTime+float(i)*40.36)*0.1;\n    vec2 p7 =vec2(0.1,0.2)+no2(iTime+float(i)*81.23)*0.1;\n    vec2 q1 =vec2(-0.2,-0.7)+no2(iTime+float(i)*75.23)*0.1; \n    vec2 q2 =vec2(-0.15,-0.75)+no2(iTime+float(i)*77.26)*0.1;\n    vec2 q4 =vec2(-0.65,0.1)+no2(iTime+float(i)*81.25)*0.1;\n    vec2 q5 =vec2(-0.2,0.55)+no2(iTime+float(i)*78.23)*0.1;\n    vec2 p8 = vec2(-0.25,-0.4)+no2(iTime+float(i)*74.23)*0.1;\n    vec2 q8 = vec2(0.25,-0.4)+no2(iTime+float(i)*74.23)*0.1;\n    vec2 p9 = vec2(0.,-0.47)+no2(iTime+float(i)*66.23)*0.1;\n    vec2 q9 = vec2(0.05,-0.37)+no2(iTime+float(i)*66.23)*0.1;\n    vec2 p10 = vec2(0.1,-0.45)+no2(iTime+float(i)*44.23)*0.1;\n    vec2 q10 = vec2(0.05,-0.37)+no2(iTime+float(i)*44.23)*0.1;\n    vec2 p11 = vec2(-0.1,-0.2)+no2(iTime+float(i)*19.23)*0.1;\n    vec2 q11 = vec2(0.1,-0.2)+no2(iTime+float(i)*32.36)*0.1;\n    vec2 r1 = vec2(0.75,-0.8)+no2(iTime+float(i)*76.23)*0.1;\n    vec2 r2 = vec2(0.15,-0.7)+no2(iTime+float(i)*15.23)*0.1;\n    vec2 r3 = vec2(0.12,-0.9)+no2(iTime+float(i)*64.23)*0.1;\n    vec2 r4 = vec2(0.6,0.55)+no2(iTime+float(i)*19.23)*0.1;\n    vec2 t1 = vec2(-0.75,-0.8)+no2(iTime+float(i)*75.23)*0.1;\n    vec2 t2 = vec2(-0.15,-0.7)+no2(iTime+float(i)*77.26)*0.1;\n    vec2 t3 = vec2(-0.12,-0.9)+no2(iTime+float(i)*64.23)*0.1;\n    vec2 t4 = vec2(-0.6,0.55)+no2(iTime+float(i)*81.25)*0.1;\n    vec2 r5 = vec2(-0.3,0.3)+no2(iTime+float(i)*60.23)*0.1;\n    vec2 r6 = vec2(-0.45,0.15)+no2(iTime+float(i)*40.36)*0.1;\n    vec2 r7 = vec2(0.05,0.1)+no2(iTime+float(i)*81.23)*0.1;\n    vec2 r8 = vec2(0.15,0.05)+no2(iTime+float(i)*74.23)*0.1;\n    vec2 r9 = vec2(0.0,-0.55)+no2(iTime+float(i)*66.23)*0.1;\n    vec2 r10 = vec2(0.0,-0.37)+no2(iTime+float(i)*44.23)*0.1;\n    vec2 r11 = vec2(0.1,-0.37)+no2(iTime+float(i)*19.23)*0.1;\n    vec2 r12 = vec2(0.,-0.3)+no2(iTime+float(i)*19.23)*0.1;\n    vec2 pc1 = vec2(0.3,-0.05)+no2(iTime+float(i)*61.22)*0.1;\n    vec2 pc2 = vec2(-0.3,-0.05)+no2(iTime+float(i)*41.05)*0.1;\n     d1 += smoothstep(0.015,0.,sdBezier(p,p1,r1,p4));\n     d2 += smoothstep(0.015,0.,sdBezier(p,p1,r2,p2));\n     d3 += smoothstep(0.015,0.,sdBezier(p,p2,r3,p3));\n     d4 += smoothstep(0.015,0.,sdBezier(p,q2,t3,p3));\n     d5 += smoothstep(0.015,0.,sdBezier(p,q1,t2,q2));\n     d6 += smoothstep(0.015,0.,sdBezier(p,q1,t1,q4));\n     d7 += smoothstep(0.015,0.,sdBezier(p,p4,r4,p5));\n     d8 += smoothstep(0.015,0.,sdBezier(p,q4,t4,q5));\n     d9 += smoothstep(0.015,0.,sdBezier(p,p5,r5,p6));\n     d10 += smoothstep(0.015,0.,sdBezier(p,q5,r6,p6));\n\t\n    \n    for (int i = 0 ; i < 5 ; i++){\n    float va = rd (iTime*10.+float(i)*458.236);\n    vec2 p5b = mix(p5,p5*vec2(-1.,1.),va);\n    vec2 re =  mix(r5,r6,va);\n    vec2 re2 =  mix(r7,r8,va);\n    d11 = max(d11,smoothstep(0.015,0.,sdBezier(p,p5b,re,p6))); \n    d12 = max(d12,smoothstep(0.015,0.,sdBezier(p,p6,re2,p7))); \n    }\n     d13 += smoothstep(0.015,0.,sdBezier(p,p8,r9,q8));\n     d14 += smoothstep(0.015,0.,sdBezier(p,p9,r10,q9));\n     d15 += smoothstep(0.015,0.,sdBezier(p,p10,r11,q10));\n     d16 += smoothstep(0.015,0.,sdBezier(p,p11,r12,q11));\n     d17 += smoothstep(0.015,0.,sdBezier(p,p11,r12,q11));\n     d18 += smoothstep(0.045,0.03,distance(p,pc1))*smoothstep(0.01,0.03,distance(p,pc1));    \n     d19 += smoothstep(0.045,0.03,distance(p,pc2))*smoothstep(0.01,0.03,distance(p,pc2));\n    }\n    float df = max(max(max(max(max(max(max(max(max(d1,d2),d3),d4),d5),d6),d7),d8),d9),d10);\n    float df2 = max(max(max(max(max(max(max(max(df,d11),d12),d13),d14),d15),d16),d18),d19);\n\tfragColor = vec4(1.-df2);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tsBXRc.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 23, 23, 88], [89, 89, 113, 113, 325], [326, 326, 376, 376, 1600], [1601, 1601, 1622, 1622, 1672], [1673, 1673, 1694, 1694, 1749], [1750, 1750, 1771, 1771, 1911], [1912, 1912, 1933, 1933, 2008], [2009, 2009, 2066, 2066, 6504]], "test": "error"}
{"id": "tsjSzy", "name": "Smallest 2D SDF", "author": "egon", "description": "Shows the simplest way of implementing signed distance functions.", "tags": ["2d", "sdf"], "likes": 1, "viewed": 332, "published": "Public", "date": "1554278823", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const float PI = 3.14159265359;\n\n// sdf_circle returns:\n//    negative value when inside the circle\n//    positive value when outside the circle\nfloat sdf_circle(vec2 sampleAt, vec2 center, float radius) {\n    return length(center - sampleAt) - radius;\n}\n\nvec4 color_blue_green(float value) {\n    // quick hack way to color things, such that \n    // negative values are blue and positive values are green\n    const float offset = 0.5;\n    float offsetValue = value + offset;\n    \n    vec4 colorMask = vec4(0.8, 1.0, 0.8, 1.0);\n    if(offsetValue < offset){\n        colorMask = vec4(0.8, 0.8, 1.0, 1.0);\n    }\n    // to disable coloring set:\n    // colorMask = vec4(1.0); \n    \n    return vec4(offsetValue, offsetValue, offsetValue, 1.0) * colorMask;\n}\n\n// color negative (inside) black and outside white\nvec4 color_black_white(float value) {\n    if(value > 0.0){\n        return vec4(0.0, 0.0, 0.0, 1.0);\n    } else {\n        return vec4(1.0, 1.0, 1.0, 1.0);\n    }\n}\n\n// color using absolute value of the signed distance function\nvec4 color_grayscale(float value) {\n    return vec4(abs(value), abs(value), abs(value), 1);\n}\n\n\nfloat smin(float a, float b, float k) {\n    // see http://www.iquilezles.org/www/articles/smin/smin.htm\n    float h = clamp(0.5 + 0.5 * (b - a) / k, 0.0, 1.0);\n    return mix(b, a, h) - k * h * (1.0 - h);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float t = iTime * 1.0;\n\t// this part ensures we don't distort the image\n    vec2 sampleAt = 2.0 * (fragCoord.xy / iResolution.xy) - 1.0;\n  \tsampleAt.x *= iResolution.x / iResolution.y;\n\n    // calculating the shapes\n    float right = sdf_circle(sampleAt, vec2(sin(t)*0.8, 0), 0.4);\n    float left  = sdf_circle(sampleAt, vec2(0, sin(t*2.41)*0.3), 0.5);\n    \n    // try using max, smin\n    float value = min(left, right);\n    \n    // min acts like addition of shapes:\n    //   min(negative, positive) ~= min(inside, outside) = inside\n    // max acts like intersection of shapes\n    //   max(negative, positive) ~= max(inside, outside) = outside\n\n    // try different coloring functions:\n    // color_blue_green:\n    //   blue  = negative value\n    //   green = positive value\n    // color_black_white\n    //   all negative values will be white, positive black\n    // color_grayscale\n    //   absolute value of the distance field\n    fragColor = color_blue_green(value);\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tsjSzy.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[33, 145, 205, 205, 254], [256, 256, 292, 404, 751], [753, 804, 841, 841, 965], [967, 1029, 1064, 1064, 1122], [1125, 1125, 1164, 1228, 1331], [1333, 1333, 1390, 1390, 2365]], "test": "ok"}
{"id": "tsjXDc", "name": "Sector timer a0 + a1", "author": "andreyu", "description": "A useful timer renderer, where: \na0 is a start angle in radians;\na1 is a sector size in radians.", "tags": ["ui", "widget"], "likes": 1, "viewed": 91, "published": "Public", "date": "1555214841", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Sector timer by Andrey A. Ugolnik\n// 2019\n\nconst float M_PI = 3.1415926535897932384626433832795;\n\nconst vec4 color = vec4(0.0, 0.0, 0.3, 1.0);\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float a0 = M_PI * 0.0;\n    float a1 = mod(iTime * 0.5, M_PI * 2.0);\n\n\tvec2 res = iResolution.xy;\n    vec2 p = (2.0 * fragCoord - res) / res.y;\n    \n    float r = cos(a1 * 0.5 + a0 + atan(-p.x, p.y));\n    float d = cos(a1 * 0.5);\n\n    float f = smoothstep(r, r, d);\n\n    // mix with texture\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec4 tc = texture(iChannel0, uv);\n    fragColor = mix(tc, color, f);\n}", "image_inputs": [{"id": "Xdf3zn", "previewfilepath": "/media/ap/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png", "channel": 0, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tsjXDc.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[147, 147, 204, 204, 618]], "test": "error"}
{"id": "tsjXDV", "name": "Wet Concrete", "author": "kaneta", "description": "reference: http://advances.realtimerendering.com/other/2016/naughty_dog/NaughtyDog_TechArt_Final.pdf", "tags": ["3d", "voronoi", "wet"], "likes": 35, "viewed": 1322, "published": "Public API", "date": "1555007179", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define M_PI 3.1415926\n\n// Voronoi - distances by iq\n// https://www.shadertoy.com/view/ldl3W8\nvec2 hash2( vec2 p )\n{\n\treturn fract(sin(vec2(dot(p,vec2(127.1,311.7)),dot(p,vec2(269.5,183.3))))*43758.5453);\n}\n\nvec3 voronoi( in vec2 x )\n{\n    vec2 n = floor(x);\n    vec2 f = fract(x);\n\n    //----------------------------------\n    // first pass: regular voronoi\n    //----------------------------------\n\tvec2 mg, mr;\n\n    float md = 8.0;\n    for( int j=-1; j<=1; j++ )\n    for( int i=-1; i<=1; i++ )\n    {\n        vec2 g = vec2(float(i),float(j));\n\t\tvec2 o = hash2( n + g );\n        vec2 r = g + o - f;\n        float d = dot(r,r);\n\n        if( d<md )\n        {\n            md = d;\n            mr = r;\n            mg = g;\n        }\n    }\n\n    //----------------------------------\n    // second pass: distance to borders\n    //----------------------------------\n    md = 8.0;\n    for( int j=-2; j<=2; j++ )\n    for( int i=-2; i<=2; i++ )\n    {\n        vec2 g = mg + vec2(float(i),float(j));\n\t\tvec2 o = hash2( n + g );\n        vec2 r = g + o - f;\n\n        if( dot(mr-r,mr-r)>0.00001 )\n        md = min( md, dot( 0.5*(mr+r), normalize(r-mr) ) );\n    }\n\n    return vec3( md, mr );\n}\n\n// Vorocracks marble by FabriceNeyret2\n// https://www.shadertoy.com/view/Xs3fR4\n#define rot(a) mat2(cos(a),-sin(a),sin(a),cos(a))\n#define hash21(p) fract(sin(dot(p,vec2(127.1,311.7)))*43758.5453123)\nfloat noise2(vec2 p) {\n    vec2 i = floor(p);\n    vec2 f = fract(p); f = f*f*(3.-2.*f); // smoothstep\n\n    float v= mix( mix(hash21(i+vec2(0,0)),hash21(i+vec2(1,0)),f.x),\n                  mix(hash21(i+vec2(0,1)),hash21(i+vec2(1,1)),f.x), f.y);\n\treturn 2.*v-1.;\n}\n\n\n#define noise22(p) vec2(noise2(p),noise2(p+17.7))\nvec2 fbm22(vec2 p) {\n    vec2 v = vec2(0);\n    float a = .5;\n    mat2 R = rot(.37);\n\n    for (int i = 0; i < 6; i++, p*=2.,a/=2.) \n        p *= R,\n        v += a * noise22(p);\n\n    return v;\n}\nfloat fbm2(vec2 p) {\n    float v = 0.,  a = .5;\n    mat2 R = rot(.37);\n\n    for (int i = 0; i < 9; i++, p*=2.,a/=2.) \n        p *= R,\n        v += a * noise2(p);\n\n    return v;\n}\n\nfloat luminance(vec3 col)\n{\n    return dot(vec3(0.298912, 0.586611, 0.114478), col);\n}\n\nvec3 contrast(vec3 col, float scale)\n{\n    return (col - 0.5) * scale + 0.5;\n}\n\n#define saturate(x) clamp(x, 0.0, 1.0)\n\nfloat remap(float val, float inMin, float inMax, float outMin, float outMax)\n{\n    return clamp(outMin + (val - inMin) * (outMax - outMin) / (inMax - inMin), outMin, outMax);\n}\n\n\nfloat roadTex( vec2 p )\n{\n    p *= 0.1;\n    float n = noise2(p*1000.0);\n    float f = remap(fbm2(p * 12.0), -0.2, 0.4, 0.0, 1.0);\n\n    float d = 999999.9;\n    \n    float height = 1.0;\n    float alpha = 2.0;\n    \n    for(float i=0.; i<5. ; i++) {\n        vec3 c = voronoi( 8.0*p + fbm22(p*8.0) );\n        height -= smoothstep(0.05, 0.0, c.x) * alpha * remap(fbm2(p * 12.0), 0.0, 0.4, 0.0, 1.0);\n        alpha *= 0.55;\n        d = min(d, c.x);\n        p *= 1.5 * rot(.37);\n    }\n    \n    vec3 col = vec3(height + n*0.1 - f);\n    \n    col = contrast(col, 0.05);\n\treturn col.x;\n}\n\n// iq's sky https://www.shadertoy.com/view/MdX3Rr\nvec3 sunDir = normalize(vec3(.3, .25, .5));\nvec3 skyColor(vec3 rd)\n{\n    float sundot = clamp(dot(rd,sunDir),0.0,1.0);\n    // sky\t\t\n    //vec3 col = vec3(0.2,0.5,0.85)*1.1 - rd.y*rd.y*0.5;\n    vec3 col = mix(vec3(0.2,0.5,0.85)*1.1, vec3(0.0,0.15,0.7), rd.y);\n    col = mix( col, 0.85*vec3(0.8,0.8,0.7), pow( 1.0-max(rd.y,0.0), 4.0 ) );\n    // sun\n    col += 0.3*vec3(1.0,0.7,0.4)*pow( sundot,5.0 );\n    col += 0.5*vec3(1.0,0.8,0.6)*pow( sundot,64.0 );\n    col += 6.0*vec3(1.0,0.8,0.6)*pow( sundot,1024.0 );\n    // horizon\n    //col = mix( col, 0.68*vec3(0.4,0.65,1.0), pow( 1.0-max(rd.y,0.0), 16.0 ) );\n    return col * 10.0;\n}\n\nfloat trace( vec3 p, vec3 ray )\n{\n    float dist = 99999.9;\n    float t = -p.y / ray.y;\n    if ( t > 0.0 )\n    {\n        dist = t;\n    }\n \n    return dist;\n}\n\nmat3 camera(vec3 ro, vec3 ta, float cr )\n{\n\tvec3 cw = normalize(ta - ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\nvec3 reinhard(vec3 col, float exposure, float white) {\n    col *= exposure;\n    white *= exposure;\n    float lum = luminance(col);\n    return (col * (lum / (white * white) + 1.0) / (lum + 1.0));\n}\n\nvec3 acesFilm(const vec3 x) {\n    const float a = 2.51;\n    const float b = 0.03;\n    const float c = 2.43;\n    const float d = 0.59;\n    const float e = 0.14;\n    return clamp((x * (a * x + b)) / (x * (c * x + d ) + e), 0.0, 1.0);\n}\n\nvec3 normal( in vec3 pos )\n{\n    vec3 e = vec3(0.001,0.0,0.0);\n\treturn normalize( vec3(roadTex(pos.xz-e.xy) - roadTex(pos.xz+e.xy),\n                           20.0*e.x,\n                           roadTex(pos.xz-e.yx) - roadTex(pos.xz+e.yx) ) );\n}\n\nfloat ndfGGX(float NdotH, float roughness)\n{\n\tfloat alpha   = roughness * roughness;\n\tfloat alphaSq = alpha * alpha;\n\n\tfloat denom = (NdotH * NdotH) * (alphaSq - 1.0) + 1.0;\n\treturn alphaSq / (M_PI * denom * denom);\n}\n\nfloat gaSchlickG1(float theta, float k)\n{\n\treturn theta / (theta * (1.0 - k) + k);\n}\n\nfloat gaSchlickGGX(float NdotL, float NdotV, float roughness)\n{\n\tfloat r = roughness + 1.0;\n\tfloat k = (r * r) / 8.0;\n\treturn gaSchlickG1(NdotL, k) * gaSchlickG1(NdotV, k);\n}\n\nvec3 fresnelSchlick_roughness(vec3 F0, float cosTheta, float roughness) {\n    return F0 + (max(vec3(1.0 - roughness), F0) - F0) * pow(1.0 - cosTheta, 5.0);\n}\n\nvec3 PBR(vec3 pos, vec3 albedo, float metalness, float roughness, vec3 N, vec3 V, vec3 L, vec3 Lradiance)\n{\n\tvec3 H = normalize(L + V);\n\tfloat NdotV = max(0.0, dot(N, V));\n\tfloat NdotL = max(0.0, dot(N, L));\n\tfloat NdotH = max(0.0, dot(N, H));\n\t\t\n\tvec3 F0 = mix(vec3(0.04), albedo, metalness);\n\n\tvec3 F  = fresnelSchlick_roughness(F0, max(0.0, dot(H, L)), roughness);\n\tfloat D = ndfGGX(NdotH, roughness);\n\tfloat G = gaSchlickGGX(NdotL, NdotV, roughness);\n\n\tvec3 kd = mix(vec3(1.0) - F, vec3(0.0), metalness);\n    \n    //NdotL *= shadow;\n\tvec3 diffuseBRDF = kd * albedo / M_PI;\n\tvec3 specularBRDF = (F * D * G) / max(0.0001, 4.0 * NdotL * NdotV);\n\n\treturn (diffuseBRDF + specularBRDF) * Lradiance * NdotL;\n}\n\nvec3 EnvBRDFApprox( vec3 SpecularColor, float Roughness, float NoV )\n{\n\tconst vec4 c0 = vec4( -1, -0.0275, -0.572, 0.022 );\n\tconst vec4 c1 = vec4( 1, 0.0425, 1.04, -0.04 );\n\tvec4 r = Roughness * c0 + c1;\n\tfloat a004 = min( r.x * r.x, exp2( -9.28 * NoV ) ) * r.x + r.y;\n\tvec2 AB = vec2( -1.04, 1.04 ) * a004 + r.zw;\n\treturn SpecularColor * AB.x + AB.y;\n}\n\nvec3 calcAmbient(vec3 pos, vec3 albedo, float metalness, float roughness, vec3 N, vec3 V)\n{\n\tvec3 F0 = mix(vec3(0.04), albedo, metalness);\n\t//vec3 F  = fresnelSchlick(F0, max(0.0, dot(N, V)));\n    vec3 F  = fresnelSchlick_roughness(F0, max(0.0, dot(N, V)), roughness);\n    vec3 kd = mix(vec3(1.0) - F, vec3(0.0), metalness);\n\n    vec3 ambientColor = mix(vec3(0.2,0.5,0.85)*0.8, vec3(0.1,0.25,0.8) * 0.5, 0.5+0.5*N.y);\n    \n    vec3 diffuseAmbient = kd * albedo * ambientColor * min(1.0, 0.75+0.5*N.y) * 3.0;\n    vec3 R = reflect(-V, N);\n    \n    vec3 col = mix(skyColor(R) * pow( 1.0-max(-R.y,0.0), 4.0 ), mix(vec3(0.2,0.5,0.85)*0.8, vec3(0.1,0.25,0.8) * 0.5, 0.5+0.5*R.y)*3.0 * (0.5+0.5*R.y), pow(roughness, 0.5));\n\n    vec3 ref = EnvBRDFApprox(F0, roughness, max(dot(N, V), 0.0));\n    //vec3 specularAmbient = col * F;\n    vec3 specularAmbient = col * ref;\n\n    return vec3(diffuseAmbient + specularAmbient);\n}\n\n// http://advances.realtimerendering.com/other/2016/naughty_dog/NaughtyDog_TechArt_Final.pdf\nvoid wet(inout vec3 albedo, inout float roughness, inout vec3 norm, float w)\n{\n    albedo = mix(albedo, albedo * albedo, remap(w, 0.0, 0.35, 0.0, 1.0) * roughness);\n    roughness = mix(roughness, 0.05, remap(w, 0.25, 0.5, 0.0, 1.0));\n    norm = mix(norm, vec3(0.0, 1.0, 0.0), vec3(remap(w, 0.45, 0.95, 0.0, 1.0)));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = (fragCoord.xy * 2.0 - iResolution.xy) / min(iResolution.x, iResolution.y);\n    \n    float mousex = 10.0*iMouse.x/iResolution.x + 0.75;\n    float mousey = remap(iMouse.y/iResolution.y, 0.0, 1.0, 1.5, 10.0);\n    vec3 ro = vec3(-5.0 * cos(mousex), mousey, -5.0 * sin(mousex) + iTime);\n    vec3 ta = vec3(0.0, 0.0, iTime);\n    mat3 c = camera(ro, ta, 0.0);\n    vec3 ray = c * normalize(vec3(p, 3.5));\n    float depth = trace(ro, ray);\n    \n    vec3 pos = ro + ray * depth;\n\n    float sundot = clamp(dot(ray,sunDir),0.0,1.0);\n    float height = roadTex(pos.xz);\n    vec3 albedo = vec3(pow(height, 2.2));\n    vec3 n = normal(pos);\n    float roughness = 1.0 - albedo.x;\n    \n    float tt = remap(sin(iTime * 0.5) * 0.5 + 0.5, 0.0, 1.0, 0.33, 0.5);\n    wet(albedo, roughness, n, smoothstep(tt + 0.03, tt, height));\n    \n    vec3 col = PBR(pos, albedo, 0.0, roughness, n, -ray, sunDir, vec3(50.0));\n    col += calcAmbient(pos, albedo, 0.0, roughness, n, -ray);\n    \n    //col = col * saturate(dot(n, sunDir));\n    \n    col += 1.5*vec3(1.0,0.7,0.3)*pow( sundot, 4.0 );\n    //col = reinhard(col, 0.15, 50.0);\n    col = acesFilm(col* 0.08);\n    col = pow(col, vec3(1.0/2.2));\n\tfragColor = vec4(col,1.0);\n    //fragColor = vec4(vec3(roadTex(p * 5.0)),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tsjXDV.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[24, 94, 116, 116, 206], [208, 208, 235, 235, 1174], [1375, 1375, 1397, 1397, 1638], [1691, 1691, 1711, 1711, 1883], [1884, 1884, 1904, 1904, 2062], [2064, 2064, 2091, 2091, 2150], [2152, 2152, 2190, 2190, 2230], [2272, 2272, 2350, 2350, 2448], [2451, 2451, 2476, 2476, 3026], [3122, 3122, 3146, 3146, 3705], [3707, 3707, 3740, 3740, 3864], [3866, 3866, 3908, 3908, 4086], [4088, 4088, 4142, 4142, 4284], [4286, 4286, 4315, 4315, 4519], [4521, 4521, 4549, 4549, 4767], [4769, 4769, 4813, 4813, 4986], [4988, 4988, 5029, 5029, 5072], [5074, 5074, 5137, 5137, 5248], [5250, 5250, 5323, 5323, 5407], [5409, 5409, 5516, 5516, 6115], [6117, 6117, 6187, 6187, 6470], [6472, 6472, 6563, 6563, 7384], [7386, 7479, 7557, 7557, 7795], [7797, 7797, 7854, 7854, 9113]], "test": "ok"}
{"id": "tsjXRG", "name": "Yet another lattice structure", "author": "MacSlow", "description": "Had to do one of these myself. Camera-path needs some work. Added SSAA but lost the reflections. Still debugging that.", "tags": ["3d", "raymarching", "aa", "pbr", "lattice"], "likes": 2, "viewed": 369, "published": "Public API", "date": "1554247615", "time_retrieved": "2021-10-01T00:00:00", "image_code": "////////////////////////////////////////////////////////////////////////////////\n//\n// \"Yet another lattice structure\" - One of those things you have to write at\n// least once\n//\n// Copyright 2019 Mirco Müller\n//\n// Author(s):\n//   Mirco \"MacSlow\" Müller <macslow@gmail.com>\n//\n// This program is free software: you can redistribute it and/or modify it\n// under the terms of the GNU General Public License version 3, as published\n// by the Free Software Foundation.\n//\n// This program is distributed in the hope that it will be useful, but\n// WITHOUT ANY WARRANTY; without even the implied warranties of\n// MERCHANTABILITY, SATISFACTORY QUALITY, or FITNESS FOR A PARTICULAR\n// PURPOSE.  See the GNU General Public License for more details.\n//\n// You should have received a copy of the GNU General Public License along\n// with this program.  If not, see <http://www.gnu.org/licenses/>.\n//\n////////////////////////////////////////////////////////////////////////////////\n\nconst int MAX_ITER    = 48;\nconst float STEP_SIZE = 1.1;\nconst float EPSILON   = .001;\nconst float PI = 3.14159265359;\nconst int AA_SIZE = 3; // 1: no anti-aliasing, 2 and up: better anti-aliasing\n\nmat2 r2d (in float a) {\n    float rad = radians (a);\n    float c = cos(rad);\n    float s = sin (rad);\n    return mat2 (c, s, -s, c);\n}\n\nstruct Result {\n\tfloat d;\n\tint id;\n};\n\n// ---- PBR toolbox ------------------------------\nfloat DistributionGGX (in vec3 N, in vec3 H, in float roughness)\n{\n    float a2     = roughness * roughness;\n    float NdotH  = max (dot (N, H), .0);\n    float NdotH2 = NdotH * NdotH;\n\n    float nom    = a2;\n    float denom  = (NdotH2 * (a2 - 1.) + 1.);\n    denom        = PI * denom * denom;\n\n    return nom / denom;\n}\n\nfloat GeometrySchlickGGX (in float NdotV, in float roughness)\n{\n    float nom   = NdotV;\n    float denom = NdotV * (1. - roughness) + roughness;\n\n    return nom / denom;\n}\n\nfloat GeometrySmith (in vec3 N, in vec3 V, in vec3 L, in float roughness)\n{\n    float NdotV = max (dot (N, V), .0);\n    float NdotL = max (dot (N, L), .0);\n    float ggx1 = GeometrySchlickGGX (NdotV, roughness);\n    float ggx2 = GeometrySchlickGGX (NdotL, roughness);\n\n    return ggx1 * ggx2;\n}\n\nvec3 fresnelSchlick (in float cosTheta, in vec3 F0, float roughness)\n{\n\treturn F0 + (max (F0, vec3(1. - roughness)) - F0) * pow (1. - cosTheta, 5.);\n}\n\nfloat smin (in float d1, in float d2, in float r)\n{\n    float h = clamp (.5 + .5 * (d2 - d1) / r, .0, 1.);\n    return mix (d2, d1, h) - r * h * (1. - h);\n}\n\nvec2 mapToScreen (in vec2 p)\n{\n    vec2 res = p;\n    res = res * 2. - 1.;\n    res.x *= iResolution.x / iResolution.y;\n    \n    return res;\n}\n\n\n// ---- Raymarching toolbox ------------------------------\n\n// slightly adapted column-step operator from Mercury's http://mercury.sexy/hg_sdf\nfloat fOpUnionColumns(float a, float b, float r, float n) {\n    if ((a < r) && (b < r)) {\n        vec2 p = vec2(a, b); \n        float columnradius = r*sqrt(2.)/((n-1.)*2.+sqrt(2.));\n        p *= r2d (45.);\n        p.x -= sqrt(2.)/2.*r;\n        p.x += columnradius*sqrt(2.);\n        if (mod(n,2.) == 1.) {\n            p.y += columnradius;\n        }\n        p.y = mod (p.y + columnradius, columnradius*2.)-columnradius;\n        float result = length(p) - columnradius;\n        result = min(result, p.x);\n        result = min(result, a); \n        return min(result, b); \n    } else {\n        return min(a, b); \n    }   \n}\n\nfloat udRoundedBox (in vec3 p, in vec3 size, in float r)\n{\n    return length(max (vec3 (.0), abs (p) - size)) - r;\n}\n\nvec3 cylinderCenter;\n\nResult scene (in vec3 p)\n{\n\tp.xz *= r2d (34.*iTime);\n\tp.xy *= r2d (23.*iTime);\n\tp.x -= cos (iTime);\n\tp.z -= sin (iTime);\n\n    // bye-bye Lipschitz continuity... but it looks cool :)\n    p.xy *= r2d (3.*p.z);\n    p.yz *= r2d (3.*p.x);\n\n\tcylinderCenter = p;\n\tvec3 size = vec3 (3.5);\n\tcylinderCenter = mod (cylinderCenter + .5*size, size) - .5*size;\n\tfloat cylinder = length (cylinderCenter.xz) - .1;\n\tcylinder = min (cylinder, length (cylinderCenter.yz) - .3);\n\tcylinder = min (cylinder, udRoundedBox (cylinderCenter, vec3 (.1, .2, 2.), .075));\n    float d = cylinder;\n\n    vec3 ballCenter = p;\n    ballCenter = mod (ballCenter + .5*size, size) - .5*size;\n\n    float ball = length (ballCenter) - .6;\n\n    Result res = Result (.0, 0);\n\tres.d = fOpUnionColumns (cylinder, ball, .1, 2.);\n    res.id = 2;\n    return res;\n}\n\nResult raymarch (in vec3 ro, in vec3 rd)\n{\n    Result res = Result (.0, 0);\n\n    for (int i = 0; i < MAX_ITER; i++)\n    {\n        vec3 p = ro + res.d * rd;\n        Result tmp = scene (p);\n        if (abs (tmp.d) < EPSILON*(1. + .125*tmp.d)) return res;\n        res.d += tmp.d * STEP_SIZE;\n        res.id = tmp.id;\n    }\n\n    return res;\n}\n\nvec3 normal (in vec3 p)\n{\n    vec2 e = vec2(.0001, .0);\n    float d = scene (p).d;\n    vec3 n = vec3 (scene (p + e.xyy).d,\n                   scene (p + e.yxy).d,\n                   scene (p + e.yyx).d) - d;\n    return normalize(n);\n}\n\nfloat shadow (in vec3 p, in vec3 n, in vec3 ldir, in float ldist)\n{\n\tfloat d2w = raymarch (p + .01*n, ldir).d;\n\treturn ldist < d2w ? 1. : .1;\n}\n\nfloat ao (vec3 p, vec3 n, float stepsize, int iter, float i) {\n\tfloat ao = .0;\n\tfloat dist = .0;\n\tfor (int a = 1; a <= iter; ++a) {\n\t\tdist = float (a)*stepsize;\n\t\tao += max (.0, (dist - scene (p+n*dist).d)/dist);\n\t}\n\treturn 1. - ao*i;\n}\nvec3 shadePBR (in vec3 ro, in vec3 rd, in float d, in int id)\n{\n    vec3 p = ro + d * rd;\n    vec3 nor = normal (p);\n\n    // \"material\" hard-coded for the moment\n    vec3 s = cylinderCenter;\n    float m = smoothstep (.1, .9, .5 + .5*cos(26.9*(s.x + s.y + s.z)));\n    float metallic  = mix (.4, .6, m);\n    float roughness = mix (.6, .4, m);\n    vec3 albedo = mix (vec3 (.4, .2, .1), vec3 (.8, .7, .6), m);\n    float ao = ao (p, nor, .05, 8, .2);\n\n    // lights hard-coded as well atm\n    vec3 lightColors[2];\n    lightColors[0] = vec3 (.5, .5, .9) * 60.;\n    lightColors[1] = vec3 (.9, .9, .7) * 60.;\n\n    vec3 lightPositions[2];\n    lightPositions[0] = vec3 (.5, 2.75, .5);\n    lightPositions[1] = vec3 (-.3, .25, -.5);\n\n\tvec3 N = normalize (nor);\n    vec3 V = normalize (ro - p);\n\n    vec3 F0 = vec3 (0.04); \n    F0 = mix (F0, albedo, metallic);\n    vec3 kD = vec3(.0);\n\t\t           \n    // reflectance equation\n    vec3 Lo = vec3 (.0);\n    for(int i = 0; i < 2; ++i) \n    {\n        // calculate per-light radiance\n        vec3 L = normalize(lightPositions[i] - p);\n        vec3 H = normalize(V + L);\n        float ldist = distance (lightPositions[i], p);\n        float attenuation = 5./(ldist * ldist);\n        vec3 radiance = lightColors[i] * attenuation;\n\t        \n        // cook-torrance brdf\n        float aDirect = .125 * pow (roughness + 1., 2.);\n        float aIBL = .5 * roughness * roughness;\n        float NDF = DistributionGGX(N, H, roughness);        \n        float G   = GeometrySmith(N, V, L, roughness);      \n        vec3 F    = fresnelSchlick(max(dot(H, V), 0.0), F0, roughness);\n\t        \n        vec3 kS = F;\n        kD = vec3(1.) - kS;\n        kD *= 1. - metallic;\t  \n\t        \n        vec3 nominator    = NDF * G * F;\n        float denominator = 4. * max(dot(N, V), 0.0) * max(dot(N, L), 0.0);\n        vec3 specular     = nominator / max(denominator, .001);  \n\n        // add to outgoing radiance Lo\n        float NdotL = max(dot(N, L), 0.0);                \n        Lo += (kD * albedo / PI + specular) * radiance * NdotL; \n\t    Lo *= shadow (p, N, L, ldist);\n    }\n\n    vec3 ambient = kD*albedo*ao;\n\n    return ambient + Lo;\n}\n\nvec3 camera (in vec2 uv, in vec3 ro, in vec3 aim, in float zoom)\n{\n    vec3 camForward = normalize (vec3 (aim - ro));\n    vec3 worldUp = vec3 (.0, 1., .0);\n    vec3 camRight = normalize (cross (camForward, worldUp));\n    vec3 camUp = normalize (cross (camRight, camForward));\n    vec3 camCenter = normalize (ro + camForward * zoom);\n\n    return normalize ((camCenter + uv.x*camRight + uv.y*camUp) - ro);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // normalizing and aspect-correction\n\tvec2 uvRaw = fragCoord.xy/iResolution.xy;\n\n    // set up \"camera\", view origin (ro)\n    vec3 ro = vec3 (.0, 1., 2.);\n    vec3 aim = vec3 (.0, .0, .0);\n    float zoom = 2.;\n\n    float fog = .0;\n    Result res;\n    vec3 color = vec3 (.0);\n\n    for (int x = 0; x < AA_SIZE; ++x) {\n\t    for (int y = 0; y < AA_SIZE; ++y) {\n\n            // anti-alias offset\n            vec2 pixelOffset = vec2 (float(x), float(y)) / float (AA_SIZE) - .5;\n\n            // normalize, aspect-correct and 'bulge' UVs\n\t\t\tvec2 uv = (fragCoord.xy + pixelOffset)/iResolution.xy;\n\t\t    uv = uv * 2. - 1.;\n    \t\tuv.x *= iResolution.x/iResolution.y;\n\t\t\tuv *= 1. + .5*length (uv);\n\n            // create ray for view direction\n\t\t    vec3 rd = camera (uv, ro, aim, zoom);\n\n            // do the ray-march...\n            res = raymarch (ro, rd);\n            fog = 1. / (1. + res.d * res.d * .05);\n            vec3 ctmp = shadePBR (ro, rd, res.d, res.id);\n            ctmp *= fog;\n\n            // do the reflections\n            /*if (res.id == 2) {\n                vec3 p = ro + res.d*rd;\n                vec3 n = normal (p);\n                ro = p +.01*n;\n                rd = normalize (reflect (rd, n));\n\t            Result resRefl = raymarch (ro, rd);\n                ctmp += .05*shadePBR (ro, rd, resRefl.d, resRefl.id);\n            }*/\n\t\t\tcolor += ctmp;\n    \t}\n    }\n    color /= float (AA_SIZE*AA_SIZE);\n\n    // distance-mist, tonemapping, tint, vignette, raster-line, gamma-correction\n\tcolor = mix (color, vec3 (.9, .85, .7), pow (1. - 1. / res.d, 30.));\n\tcolor = color / (1. + color);\n    color *= vec3 (.9, .8, .7);\n    color *= .2 + .8*pow(16.*uvRaw.x*uvRaw.y*(1. - uvRaw.x)*(1. - uvRaw.y), .3);\n\tcolor *= mix (1., .5, cos (1100.*uvRaw.y));\n    color = pow (color, vec3 (1./2.2));\n\n\tfragColor = vec4(color, 1.);\n}\n\n", "image_inputs": [{"id": "ltX3DM", "previewfilepath": "https://soundcloud.com/dannybyrdmusic/quantum-leap-feat-terri-pace", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0, "src": "https://soundcloud.com/dannybyrdmusic/quantum-leap-feat-terri-pace", "ctype": "musicstream"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tsjXRG.jpg", "access": "shaders20k", "license": "gpl-3.0", "functions": [[1170, 1170, 1193, 1193, 1304], [1345, 1396, 1462, 1462, 1715], [1717, 1717, 1780, 1780, 1888], [1890, 1890, 1965, 1965, 2184], [2186, 2186, 2256, 2256, 2336], [2338, 2338, 2389, 2389, 2493], [2495, 2495, 2525, 2525, 2635], [2698, 2781, 2840, 2840, 3399], [3401, 3401, 3459, 3459, 3517], [3541, 3541, 3567, 3567, 4357], [4359, 4359, 4401, 4401, 4697], [4699, 4699, 4724, 4724, 4933], [4935, 4935, 5002, 5002, 5078], [5080, 5080, 5142, 5142, 5316], [5317, 5317, 5380, 5380, 7469], [7471, 7471, 7537, 7537, 7876], [7878, 7878, 7935, 7976, 9766]], "test": "timeout"}
{"id": "tsSSzK", "name": "Destroyer of Lipschitz/GPUs ;)", "author": "MacSlow", "description": "Nicer version of https://www.shadertoy.com/view/XscfW2 from 2018. Visually cleaner, but heavy for the GPU... sorry! Use the mouse to orbit around the thing in the middle.\n\nFor lower end GPUs try:\nMAX_ITER = 48;\nSTEP_SIZE = 1.1;\nAA_SIZE = 1;", "tags": ["3d", "reflection", "phong", "interactive", "experiment", "shadows", "ao", "aa", "blinn"], "likes": 6, "viewed": 422, "published": "Public API", "date": "1554329607", "time_retrieved": "2021-10-01T00:00:00", "image_code": "////////////////////////////////////////////////////////////////////////////////\n//\n// \"Destroyer of Lipschitz\" - This is a cleaner looking version of an old shader\n// of mine (https://www.shadertoy.com/view/XscfW2) from 2018. Share and enjoy!\n//\n// Copyright 2019 Mirco Müller\n//\n// Author(s):\n//   Mirco \"MacSlow\" Müller <macslow@gmail.com>\n//\n// This program is free software: you can redistribute it and/or modify it\n// under the terms of the GNU General Public License version 3, as published\n// by the Free Software Foundation.\n//\n// This program is distributed in the hope that it will be useful, but\n// WITHOUT ANY WARRANTY; without even the implied warranties of\n// MERCHANTABILITY, SATISFACTORY QUALITY, or FITNESS FOR A PARTICULAR\n// PURPOSE.  See the GNU General Public License for more details.\n//\n// You should have received a copy of the GNU General Public License along\n// with this program.  If not, see <http://www.gnu.org/licenses/>.\n//\n////////////////////////////////////////////////////////////////////////////////\n\nconst int MAX_ITER = 80; // 48 or 64 will work too (faster) but not look clean\nconst float EPSILON = .0001;\nconst float STEP_SIZE = .5; // .75 or 1.1 will work also (faster) but not look clean\nconst int AA_SIZE = 2; // 1: no anti-aliasing (faster), 2 or up: better anti-aliasing (slower)\n\nfloat opBend (inout vec3 p, float deg)\n{\n    float rad = radians (deg);\n    float cy = cos (rad * p.y);\n    float sy = sin (rad * p.y);\n    mat2  my = mat2 (cy, -sy, sy, cy);\n    float cx = cos (rad * p.x);\n    float sx = sin (rad * p.x);\n    mat2  mx = mat2 (cx, -sx, sx, cx);\n    p = mix (vec3 (mx* p.zx, p.y), vec3 (my * p.xy, p.z), .15*cos (p.x));\n\n    return .0;\n}\n\nfloat displace (vec3 p)\n{\n    float result = 1.;\n    float factor = 6. + 4.*cos (2.*iTime);\n\tresult = .375 * sin (factor * p.x) * cos (factor * p.y) * sin (factor * p.z);\n\n    return result;\n}\n\nfloat opCombine (in float d1, in float d2, in float r) {\n    float h = clamp (.5 + .5 * (d2 - d1) / r, .0, 1.);\n    return mix (d2, d1, h) - r * h * (1. - h);\n}\n\nfloat sdSphere (in vec3 p, in float radius)\n{\n\treturn length (p) - radius;\n}\n\nfloat sdPlane (in vec3 p, in float height)\n{\n\treturn length (p.y - height);\n}\n\nfloat udBox (in vec3 p, in vec3 size, in float radius)\n{\n\treturn length (max (abs (p) - size, .0)) - radius;\n}\n\nmat2 r2d (in float degree)\n{\n    float rad = radians (degree);\n    float c = cos (rad);\n\tfloat s = sin (rad);\n\n    return mat2 (c, s, -s, c);\n}\n\nfloat scene (in vec3 p)\n{\n\t// well, kind of self explanatory\n    float ground = sdPlane (p, -2.);\n\n\t// the weird distorted thing in the middle of the scene\n    vec3 p2 = p;\n    opBend (p2, 45. * cos (.25*iTime));\n    p2.zx *= r2d (50.*iTime);\n    p2.xy *= r2d (-75.*iTime);\n    float dt = sdSphere (p2, .5);\n    float dp = displace (p2);\n    float ball2 = dt + dp;\n\n\t// the structure rotating around the scene\n    p.xz *= r2d (20.*iTime);\n    p.zy *= r2d (-30.*iTime);\n    float x = p.x*.125;\n    float y = p.y*.125;\n    float z = p.z*.125;\n    float fourthOrderChmutovBanchoffSurface = 3. + 8.*(x*x*x*x + y*y*y*y + z*z*z*z) - 8.*(x*x + y*y + z*z);\n    fourthOrderChmutovBanchoffSurface *= .75;\n    ground = opCombine (ground, ball2, 2.5);\n    fourthOrderChmutovBanchoffSurface = opCombine (fourthOrderChmutovBanchoffSurface, ground, .5);\n\n    return fourthOrderChmutovBanchoffSurface;\n}\n\nvec3 normal (in vec3 p, in float epsilon)\n{\n    vec2 e = vec2 (epsilon, .0);\n    float d = scene (p);\n    return normalize (vec3 (scene (p + e.xyy),\n                            scene (p + e.yxy),\n                            scene (p + e.yyx)) - d);\n}\n\nfloat raymarch (in vec3 ro, in vec3 rd)\n{\n    float d = .0;\n    float t = .0;\n    for (int iter = 0; iter < MAX_ITER; ++iter) {\n        t = scene (ro + d * rd);\n        if (abs(t) < EPSILON*(1. + .125*t)) break;\n        d += t*STEP_SIZE;\n    }\n\n    return d;\n}\n\nfloat shadow (in vec3 p, in vec3 lpos)\n{\n    float distanceToLight = distance (lpos, p);\n    vec3 n = normal (p, distanceToLight*EPSILON);\n    vec3 ldir = normalize (lpos - p);\n    float distanceToObject = raymarch (p + .01 * n, ldir);\n    bool isShadowed = distanceToObject < distanceToLight;\n\n\treturn isShadowed ? .3 : 1.;\n}\n\nfloat ao (in vec3 p, in vec3 n, float stepsize, int iterations, float intensity) {\n    float ao = .0; \n    float dist = .0; \n    for (int a = 1; a <= iterations; ++a) {\n        dist = float (a)*stepsize;\n        ao += max (.0, (dist - scene (p + n*dist))/dist);\n    }   \n    return 1. - ao*intensity;\n}\n\n// rusty old blinn/phong shading model\nvec3 shade (in vec3 p, in vec3 rd, in vec3 n)\n{\n\t// attributes of first light\n    vec3 lightPosition1 = vec3 (1.);\n    lightPosition1.xz *= r2d (60.*iTime);\n    vec3 l1 = normalize (lightPosition1 - p);\n    float d1 = distance (p, lightPosition1);\n    float lightIntensity1 = 5.;\n\tfloat att1 = 2./(d1*d1);\n    vec3 lightColor1 = vec3 (.9, .8, .7);\n\n\t// attributes of second light\n \tvec3 lightPosition2 = vec3 (1., 1.*cos (2.*iTime), 1.);\n    lightPosition2.xz *= r2d (20.*iTime);\n    vec3 l2 = normalize (lightPosition2 - p);\n    float d2 = distance (p, lightPosition2);\n    float lightIntensity2 = 3.;\n\tfloat att2 = 2./(d2*d2);\n    vec3 lightColor2 = vec3 (.7, .8, .9);\n\n\t// diffuse term parts\n    vec3 diffuseColor1 = max (dot (n, l1), .0) * lightColor1 * lightIntensity1;\n    vec3 diffuseColor2 = max (dot (n, l2), .0) * lightColor2 * lightIntensity2;\n\n\t// specular coefficient\n\tfloat shiny = 60.;\n\tvec3 h1 = normalize (-rd + l1);\n\tvec3 h2 = normalize (-rd + l2);\n\tfloat sp1 = pow (max(.0, dot (h1, l1)), shiny);\n\tfloat sp2 = pow (max(.0, dot (h2, l2)), shiny);\n\n\t// there is only one 'material'\n    vec3 matertialColor = vec3 (.4, .7, .6);\n\n    float ao = ao (p, n, .15, 4, .15);\n    \n    return ao*att1*shadow (p, lightPosition1) * (matertialColor*diffuseColor1 + sp1*vec3 (1.))+\n           ao*att2*shadow (p, lightPosition2) * (matertialColor*diffuseColor2 + sp2*vec3 (1.));\n}\n\nvec3 camera (in vec2 uv, in vec3 ro, in vec3 aim, in float zoom)\n{\n\tvec3 f = normalize (aim - ro);\n\tvec3 wu = vec3 (.0, 1., .0);\n\tvec3 r = normalize (cross (wu, f));\n\tvec3 u = normalize (cross (f, r));\n\tvec3 c = ro + f*zoom;\n\treturn normalize (c + r*uv.x + u*uv.y - ro);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\t// orbit camera preparation\n    float dist2cam = 3.;\n    float azimuthAngle = ((iMouse.x/iResolution.x) * 2. - 1.) * 179.;\n    float elevationAngle = ((iMouse.y/iResolution.y) * 2. - 1.) * -40.;\n    float x = dist2cam*cos (radians (azimuthAngle));\n    float y = dist2cam*sin (radians (elevationAngle));\n    float z = dist2cam*sin (radians (azimuthAngle));\n\n\t// stuff\n    vec2 uv = fragCoord.xy/iResolution.xy;\n    vec3 ro = vec3 (x, y, z);\n\tfloat fog = .0;\n\tfloat d = .0;\n\tvec3 col = vec3 (.0);\n\tvec3 aim = vec3 (.0);\n\tfloat zoom = 1.7;\n\n\t// walk over AA-grid\n\tfor (int x = 0; x < AA_SIZE; ++x) {\n\t\tfor (int y = 0; y < AA_SIZE; ++y) {\n\n\t\t\t// anti-alias offset\n\t\t\tvec2 pixelOffset = vec2 (float (x), float (y))/float  (AA_SIZE);\n\n\t\t\t// normalize and aspect-correct UVs\n\t\t\tvec2 uv = (fragCoord.xy + pixelOffset)/iResolution.xy;\n    \t\tuv = uv*2. - 1.;\n            uv.x *= iResolution.x/iResolution.y;\n\n    \t\t// create viewray\n    \t\tvec3 rd = camera (uv, ro, aim, zoom);\n\n\t\t\t// primary/view ray\n\t\t\td = raymarch (ro, rd);\n\t\t\tfog = 1. / (1. + d*d*.02);\n\t\t\tvec3 p = ro + d*rd;\n\t\t\tvec3 n = normal (p, d*EPSILON);\n\t\t\tvec3 ctmp = shade (p, rd, n);\n\t\t\tctmp *= fog;\n\n\t\t\t// secondary/reflection ray\n\t\t\tvec3 refr = normalize (reflect (rd, n));\n\t\t\tfloat refd = raymarch (p + .0005*n, refr);\n\t\t\tvec3 refp = p + refd * refr;\n\t\t\tvec3 refn = normal (refp, EPSILON);\n\t\t\tcol += ctmp + .05*shade (refp, refr, refn);\n\t\t}\n\t}\n\tcol /= float (AA_SIZE*AA_SIZE);\n\n    // distance-mist, vignette, tone-map, gamma-correct\n\tcol = mix (col, vec3 (.2, .35, .7), pow (1. - 1./d, 90.));\n\tcol *= 1. - .5*length (fragCoord.xy/iResolution.xy*2. - 1.);\n    col = col / (1. + col);\n    col = pow (col, vec3 (1./2.2));\n\n    fragColor = vec4 (col, 1.);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tsSSzK.jpg", "access": "shaders20k", "license": "gpl-3.0", "functions": [[1329, 1329, 1369, 1369, 1698], [1700, 1700, 1725, 1725, 1892], [1894, 1894, 1950, 1950, 2054], [2056, 2056, 2101, 2101, 2132], [2134, 2134, 2178, 2178, 2211], [2213, 2213, 2269, 2269, 2323], [2325, 2325, 2353, 2353, 2468], [2470, 2470, 2495, 2530, 3357], [3359, 3359, 3402, 3402, 3609], [3611, 3611, 3652, 3652, 3871], [3873, 3873, 3913, 3913, 4199], [4201, 4201, 4283, 4283, 4503], [4505, 4544, 4591, 4621, 5926], [5928, 5928, 5994, 5994, 6200], [6202, 6202, 6259, 6288, 7972]], "test": "timeout"}
{"id": "tsSXDc", "name": "coherent Rayleigh", "author": "FabriceNeyret2", "description": "simplif. Rayleigh scattering of coherent plane wave on on random particles (green)\nTop: random phases\nMiddle: particle spread << wavelength,  thus coherent (all ~ in phase). -> interference rebuilt the plane wave.\nBottom: particle spread >>\nRed: ref wave.", "tags": ["refraction", "rayleigh", "interferences", "huygens"], "likes": 8, "viewed": 471, "published": "Public API", "date": "1555098334", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define N 800.      // number of random partics\n#define k 400.      // plane sine wave (kx) propag from left to right\n#define W1 .001     // dielectric material width middle\n#define W2 .5       // dielectric material width bottom\n#define Lcoher 0*15 // coherence length. 0: coherent source (laser)\n\n#define rnd2(p) fract(sin((p)*mat2(127.1,311.7,269.5,183.3))*43758.5453123)\n#define rnd(p)  fract(sin((p)* 78.233) * 43758.5453)\n#define srnd(p) ( 2.*rnd(p) - 1. )\n#define K(x)    smoothstep(1.,0.,abs(x))  // photon kernel (incoherent source)\n\nvoid mainImage( out vec4 O, vec2 U )\n{\n    vec2 R = iResolution.xy;\n    U /= R.y;\n    \n    float v = 0., phi, a=1.,l,\n          W = U.y < .35 ? W2 : W1;\n    \n    for (float i=0.; i<N; i++) {\n        vec2 P = .5+vec2(W,1)*(2.*rnd2(vec2(i))-1.);// random partic\n     // P.y = fract(.5*P.y-U.y+.5)+U.y-.5;          // sliding window for continuity\n        l = length(U-P);\n     // a = max(0.,(U-P).x/l);                      // (scattering function)\n        phi = k*( a*l + P.x );                      // phase left -> P -> U\n        if(U.y>.66) phi += 6.28*rnd2(P).x;          // top: incoherent phases\n#if Lcoher > 0                                      //  incoherent source\n      float x = phi/float(Lcoher),\n         iphi = floor(x) , f = fract(x);\n      phi += 3.14*( K(f) * srnd(iphi) + K(1.-f) * srnd(iphi+1.) ); // random phase per photon\n#endif        \n        v += sin(phi - 10.*iTime) /l; // (l*l)      // diffracted wave\n    }\n    O = vec4(.5+.5*v*.3/sqrt(N));\n    \n    if (abs(U.x-.5) < W/2.+2./R.x) O.g = .7;        // dielectric width\n    if (U.y<.05) O = vec4(.5+.5*sin(k*U.x - 10.*iTime),0,0,1); // ref without material\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tsSXDc.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[543, 543, 581, 581, 1679]], "test": "ok"}
{"id": "tsSXDt", "name": "Fusion Apparatus", "author": "zackpudil", "description": "Name doesn't really fit, but it sounds cool :P.", "tags": ["raymarching", "ifs", "glow"], "likes": 10, "viewed": 421, "published": "Public API", "date": "1555296716", "time_retrieved": "2021-10-01T00:00:00", "image_code": "mat2 rot(float a) {\n  float c = cos(a);\n  float s = sin(a);\n  \n  return mat2(c, s, -s, c);\n}\n\nfloat len(vec3 p, float l) {\n  vec3 q = pow(abs(p), vec3(l));\n  return pow(q.x + q.y + q.z, 1.0/l);\n}\n\nfloat len(vec2 p, float l) {\n  vec2 q = pow(abs(p), vec2(l));\n  return pow(q.x + q.y, 1.0/l);\n}\n\nfloat box(vec3 p, vec3 b) {\n  vec3 q = abs(p) - b;\n  return max(max(q.x, q.y), q.z);\n}\n\nfloat torus(vec3 p, vec2 h, float l) {\n  vec2 q = vec2(len(p, l) - h.x, p.y);\n  return len(q, l) - h.y;\n}\n\nvec2 shape(vec3 p) {\n  float a = torus(p, vec2(1, 0.2), 16.0);\n  \n  p.y = abs(p.y) - 0.2;\n  \n  float b = torus(p, vec2(1.1, 0.14), 16.0);\n\n  vec2 s = vec2(a, 1.0);  \n  vec2 t = vec2(b, 2.0);\n\n  return s.x < t.x ? s : t;\n}\n\nvec2 path(float z) {\n  return vec2(0.5*sin(0.3*z + 1.0), cos(0.6*z));\n}\n\nfloat glow = 0.0;\nvec2 de(vec3 p) {\n  float sc = 1.0;\n  \n  p.xy += path(p.z);\n  \n  vec3 op = p;\n  p.z = mod(p.z + 1.5, 3.0) - 1.5;\n  vec4 q = vec4(p*sc, 1);\n  \n  q.xyz -= 1.0;\n  \n  for(int i = 0; i < 5; i++) {\n    q.xyz = abs(q.xyz + 1.0) - 1.0;\n    q.xz *= rot(0.55);\n    q.xy *= rot(0.1);\n    \n    q *= 1.1;\n  }\n  \n  vec2 s = shape(q.xyz)/vec2(q.w*sc, 1);\n  \n  float at = mod(iTime, 100.0);\n  vec3 gop = op - vec3(0, 0, at);\n  \n  vec2 t = vec2(length(gop) - 0.1, 2.0);\n  \n  glow += 0.1/(0.01 + t.x*t.x);\n  \n  return s.x < t.x ? s : t;\n}\n\nfloat form(vec2 p) {\n  p = mod(p + 2.0, 4.0) - 2.0;\n  \n  for(int i = 0; i < 10; i++) {\n    p = abs(p)/clamp(dot(p, p), 0.5, 0.8) - vec2(0.0, 0.6);\n  }\n  \n  return smoothstep(0.5, 0.8, abs(p.y));\n}\n\nfloat mat(vec3 p, vec3 n) {\n  vec3 m = pow(abs(n), vec3(10.0));\n  \n  float x = form(p.yz);\n  float y = form(p.xz);\n  float z = form(p.xy);\n  \n  return (m.x*x + m.y*y + m.z*z)/(m.x + m.y + m.z);\n}\n\nvec3 bump(vec3 p, vec3 n, float bf) {\n  vec2 h = vec2(0.01, 0.0);\n  vec3 g = vec3(\n    mat(p - h.xyy, n),\n    mat(p - h.yxy, n),\n    mat(p - h.yyx, n));\n  \n  g -= mat(p, n);\n  g -= n*dot(g, n);\n  \n  return normalize(n + bf*g);\n}\n\nvec3 mat(vec3 p, vec3 n, sampler2D s) {\n  vec3 m = pow(abs(n), vec3(10.0));\n  \n  vec3 x = texture(s, p.yz).rgb;\n  vec3 y = texture(s, p.xz).rgb;\n  vec3 z = texture(s, p.xy).rgb;\n  \n  return (m.x*x + m.y*y + m.z*z)/(m.x + m.y + m.z);\n}\n\nvec3 bump(vec3 p, vec3 n, sampler2D s, float bf) {\n  vec2 h = vec2(0.009, 0.0);\n  \n  vec3 g = mat3(\n    mat(p - h.xyy, n, s),\n    mat(p - h.yxy, n, s),\n    mat(p - h.yyx, n, s))*vec3(0.299, 0.589, 0.114);\n  \n  g -= dot(mat(p, n, s), vec3(0.299, 0.589, 0.114));\n  g -= n*dot(g, n);\n  \n  return normalize(n + bf*g);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n  vec2 uv = (fragCoord - 0.5*iResolution.xy)/iResolution.y;\n  \n  vec3 col = vec3(0);\n  \n  float at = mod(iTime, 100.0);\n  \n  vec3 ro = vec3(0, 0, -3.0 + at);\n  ro.xy -= path(ro.z);\n  \n  vec3 la = vec3(0, 0, at);\n  la.xy -= path(la.z);\n  \n  vec3 ww = normalize(la-ro);\n  vec3 uu = cross(vec3(0, 1, 0), ww);\n  vec3 vv = cross(ww, uu);\n  vec3 rd = normalize(mat3(uu, vv, ww)*vec3(uv, 1));\n  \n  float t = 0.0, m = -1.0, mx = 50.0;\n  for(int i = 0; i < 200; i++) {\n    vec2 d = de(ro + rd*t);\n    if(d.x < 0.001 || t >= mx) break;\n    t += d.x*0.75;\n    m = d.y;\n  }\n  \n  vec2 h = vec2(0.001, 0.0);\n  vec3 salb = vec3(1.00, 0.89, 0.25);\n  vec3 lp = ro + vec3(0, 0, 3);\n  \n  if(t < mx) {\n    vec3 p = ro + rd*t;\n    vec3 n = normalize(vec3(\n      de(p + h.xyy).x - de(p - h.xyy).x,\n      de(p + h.yxy).x - de(p - h.yxy).x,\n      de(p + h.yyx).x - de(p - h.yyx).x));\n   \n    vec3 alb = salb;\n    \n    vec3 ld = normalize(lp-p);\n    \n    if(m == 1.0) {\n      alb = vec3(0.1, 0.2, 0.3);\n      n = bump(p*0.25, n, 2.0);\n    } else if(m == 2.0) {\n      alb = vec3(0.3, 0.2, 0.1);\n      n = bump(p, n, iChannel0, 1.0);\n    }\n    \n    float ot = t/50.0;\n    float occ = exp2(-pow(max(0.0, 1.0 - de(p + n*ot).x/ot), 2.0));\n    float dif = max(0.0, dot(ld, n));\n    \n    float spe = pow(max(0.0, dot(reflect(-ld, n), -rd)), 16.0);\n    float fre = pow(dot(rd, n) + 1.0, 2.0);\n    \n    col = 2.0*mix(occ*(alb*(0.1 + dif) + salb*spe), alb, fre);\n  }\n  \n  col += 0.05*salb*glow;\n   \n  //col = mix(col, vec3(0.2, 0.3, 0.4), 1.0 - exp(-0.1*t));\n  //col = vec3(1)*form(uv);\n  fragColor = vec4(pow(col, vec3(0.4545)), 1);\n}", "image_inputs": [{"id": "XsfGRn", "previewfilepath": "/media/ap/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tsSXDt.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 19, 19, 92], [94, 94, 122, 122, 195], [197, 197, 225, 225, 292], [294, 294, 321, 321, 380], [382, 382, 420, 420, 487], [489, 489, 509, 509, 710], [712, 712, 732, 732, 783], [803, 803, 820, 820, 1323], [1325, 1325, 1345, 1345, 1521], [1523, 1523, 1550, 1550, 1718], [1720, 1720, 1757, 1757, 1948], [1950, 1950, 1989, 1989, 2184], [2186, 2186, 2236, 2236, 2501], [2503, 2503, 2560, 2560, 4161]], "test": "error"}
{"id": "tsSXDV", "name": "*Actual* Perlin Noise", "author": "scratch13764", "description": "So it turned out that I didn't know what Perlin noise was, so I needed to get that sorted out.", "tags": ["procedural", "noise", "perlin"], "likes": 3, "viewed": 123, "published": "Public", "date": "1554940292", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec2 hash2 (vec2 p)\n{\n    return fract(vec2(5978.23857, 2915.98275)*sin(vec2(\n        p.x*832.2388 + p.y*234.9852,\n        p.x*921.7381 + p.y*498.2348\n        )))*2.-1.;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = fragCoord/iResolution.y*20. + iTime,\n    f = fract(p),\n    m = f*f*(3.-f-f);\n    p -= f;\n    \n    float n = mix(\n        mix(dot(hash2(p + vec2(0,0)), f - vec2(0,0)), \n            dot(hash2(p + vec2(1,0)), f - vec2(1,0)), m.x),\n        mix(dot(hash2(p + vec2(0,1)), f - vec2(0,1)), \n            dot(hash2(p + vec2(1,1)), f - vec2(1,1)), m.x),\n        m.y);\n    \n    fragColor = vec4(.5*n+.5);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tsSXDV.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 21, 21, 171], [173, 173, 230, 230, 638]], "test": "ok"}
{"id": "tsSXzK", "name": "Cone - distance", "author": "iq", "description": "Euclidean distance to a capped cone. Uses only two square roots instead of three like the naive implementation.", "tags": ["3d", "distancefield", "sdf"], "likes": 7, "viewed": 1193, "published": "Public API", "date": "1554360231", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// The MIT License\n// Copyright © 2019 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// Euclidean distance to a capped cone. Uses only two square roots instead of\n// three like the naive implementation.\n//\n//\n// Other cone functions:\n//\n// Cone bbox:         https://www.shadertoy.com/view/WdjSRK\n// Cone distance:     https://www.shadertoy.com/view/tsSXzK\n// Cone intersection: https://www.shadertoy.com/view/llcfRf\n//\n//\n// List of other 3D SDFs: https://www.shadertoy.com/playlist/43cXRl\n//\n// and http://iquilezles.org/www/articles/distfunctions/distfunctions.htm\n\n\n// http://iquilezles.org/www/articles/distfunctions/distfunctions.htm\nfloat sdCone(vec3 p, vec3 a, vec3 b, float ra, float rb)\n{\n    float rba  = rb-ra;\n    float baba = dot(b-a,b-a);\n    float papa = dot(p-a,p-a);\n    float paba = dot(p-a,b-a)/baba;\n\n    float x = sqrt( papa - paba*paba*baba );\n\n    float cax = max(0.0,x-((paba<0.5)?ra:rb));\n    float cay = abs(paba-0.5)-0.5;\n\n    float k = rba*rba + baba;\n    float f = clamp( (rba*(x-ra)+paba*baba)/k, 0.0, 1.0 );\n\n    float cbx = x-ra - f*rba;\n    float cby = paba - f;\n    \n    float s = (cbx < 0.0 && cay < 0.0) ? -1.0 : 1.0;\n    \n    return s*sqrt( min(cax*cax + cay*cay*baba,\n                       cbx*cbx + cby*cby*baba) );\n}\n\n\nfloat map( in vec3 pos )\n{\n    return sdCone(pos, vec3(-0.15,-0.2,-0.1), vec3(0.2,0.2,0.1), 0.4, 0.1 );\n}\n\n// http://iquilezles.org/www/articles/normalsSDF/normalsSDF.htm\nvec3 calcNormal( in vec3 pos )\n{\n    vec2 e = vec2(1.0,-1.0)*0.5773;\n    const float eps = 0.0005;\n    return normalize( e.xyy*map( pos + e.xyy*eps ) + \n\t\t\t\t\t  e.yyx*map( pos + e.yyx*eps ) + \n\t\t\t\t\t  e.yxy*map( pos + e.yxy*eps ) + \n\t\t\t\t\t  e.xxx*map( pos + e.xxx*eps ) );\n}\n    \n#define AA 3\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n     // camera movement\t\n\tfloat an = 0.5*(iTime-10.0);\n\tvec3 ro = vec3( 1.0*cos(an), 0.4, 1.0*sin(an) );\n    vec3 ta = vec3( 0.0, 0.0, 0.0 );\n    // camera matrix\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(0.0,1.0,0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n\n    \n    \n    vec3 tot = vec3(0.0);\n    \n    #if AA>1\n    for( int m=0; m<AA; m++ )\n    for( int n=0; n<AA; n++ )\n    {\n        // pixel coordinates\n        vec2 o = vec2(float(m),float(n)) / float(AA) - 0.5;\n        vec2 p = (-iResolution.xy + 2.0*(fragCoord+o))/iResolution.y;\n        #else    \n        vec2 p = (-iResolution.xy + 2.0*fragCoord)/iResolution.y;\n        #endif\n\n\t    // create view ray\n        vec3 rd = normalize( p.x*uu + p.y*vv + 1.5*ww );\n\n        // raymarch\n        const float tmax = 5.0;\n        float t = 0.0;\n        for( int i=0; i<256; i++ )\n        {\n            vec3 pos = ro + t*rd;\n            float h = map(pos);\n            if( h<0.0001 || t>tmax ) break;\n            t += h;\n        }\n        \n    \n        // shading/lighting\t\n        vec3 col = vec3(0.0);\n        if( t<tmax )\n        {\n            vec3 pos = ro + t*rd;\n            vec3 nor = calcNormal(pos);\n            float dif = clamp( dot(nor,vec3(0.57703)), 0.0, 1.0 );\n            float amb = 0.5 + 0.5*dot(nor,vec3(0.0,1.0,0.0));\n            col = vec3(0.2,0.3,0.4)*amb + vec3(0.8,0.7,0.5)*dif;\n        }\n\n        // gamma        \n        col = sqrt( col );\n\t    tot += col;\n    #if AA>1\n    }\n    tot /= float(AA*AA);\n    #endif\n\n\tfragColor = vec4( tot, 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tsSXzK.jpg", "access": "shaders20k", "license": "mit", "functions": [[1563, 1633, 1691, 1691, 2251], [2254, 2254, 2280, 2280, 2359], [2361, 2425, 2457, 2457, 2696]], "test": "ok"}
{"id": "tsXXzf", "name": "ps17.", "author": "jojo169", "description": "17", "tags": ["17"], "likes": 1, "viewed": 42, "published": "Public", "date": "1554887188", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float rect(vec2 uv, vec2 pos, float width, float height)\n{\n    float square = (step(pos.x - width, uv.x) - step(pos.x + width, uv.x)) *\n                   (step(pos.y - height, uv.y) - step(pos.y + height, uv.y));\n    \n    \n    return square;\n}\n\nmat2 rotate2d(float angle)\n{\n    return mat2 (cos(angle), -sin(angle), sin(angle), cos(angle));\n}\n\nmat2 scale2d(vec2 value)\n{\n    return mat2 (value.x, 0, 0,  value.y);\n    \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n     //Colors in vec3\n    vec3 red = vec3(0.8 ,0.0 ,0.0);\n    vec3 white = vec3(1.0, 1.0, 1.0);\n    vec3 yellow = vec3(0.9, 0.9, 0.3);\n    vec3 blue = vec3(0.0, 0.2, 1.0);\n    vec3 black = vec3(0.0, 0.0, 0.0);\n    vec3 green = vec3(0.0, 1.0, 0.0);\n    \n    vec2 uv = fragCoord/iResolution.xy;\n    float ratio = iResolution.x / iResolution.y;\n    uv *= 4.0;\n    float offset = mod(uv.y,2.)>1. ? -1. : 1.;\n    //float offset = step(1.,mod(uv.y,2.0));\n    //float offset2 = step(mod(uv.y,2.0), 1.);\n    \n\tuv.x += offset * iTime;\n\t\n    //uv.x -= offset2 *iTime;\n    uv.x *= ratio;\n    \n    vec2 pos = vec2(0.5*ratio, 0.5);\n    \n    \n    uv = fract(uv);\n    uv -= pos ;\n   \tuv *= rotate2d(tan(iTime * 3.0)  );\n    uv += pos;\n    //uv *= scale2d(vec2(1.0, 1.0)); \n    \n    \n    vec3 color = vec3(rect(uv, pos, 0.1, 0.1))*red;\n\n    fragColor = vec4(color,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tsXXzf.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 58, 58, 244], [246, 246, 274, 274, 343], [345, 345, 371, 371, 421], [423, 423, 480, 502, 1336]], "test": "ok"}
{"id": "ttf3D4", "name": "Warm/Mild Color Adjustment", "author": "TEttinger", "description": "This is a simple example of a shader that edits colors in the YCwCm color space (see block comment at top)", "tags": ["color", "ycc", "ycwcm"], "likes": 2, "viewed": 180, "published": "Public", "date": "1556324041", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// CC0 license; any and all rights to this work are waived by the author.\n/* These are some simple color-tweaking effects using a variant on YCbCr and YCoCg that I hacked\n * together, called YCwCm.\n * Y is luma (perceptual lightness) and it isn't calculated especially well; it ranges from 0.0 \n * to 1.0, with 0.0 including but not limited to black, and 1.0 including (not just) white.\n * Cw is Chroma Warm, and determines whether a color is close to blue/green or red/yellow; it\n * ranges from -1.0 to 1.0, with -1.0 blue to green, 0.0 purple to grayscale to chartreuse, and 1.0\n * red to yellow. Cm is Chroma Mild, and determines whether a color is close to blue/red or\n * green/yellow; it ranges from -1.0 to 1.0, with -1.0 blue to red, 0.0 cyan to gray to orange, and\n * 1.0 green to yellow. \n * You can change mul and add to edit the effect. A few versions are provided.\n */\n\n//// yellowing dingy effect\n//const vec3 mul = vec3(0.9, 0.7, 0.75);\n//const vec3 add = vec3(0.05, 0.14, 0.16);\n\n//// hot/on-fire effect?\n//const vec3 mul = vec3(1.1, 0.8, 1.0);\n//const vec3 add = vec3(-0.1, 0.65, 0.2);\n\n// ice effect?\nconst vec3 mul = vec3(1.0, 0.7, 0.7);\nconst vec3 add = vec3(0.4, -0.5, -0.15);\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 mulWave = mix(mul, vec3(1.0), sin(iTime) * 0.5 + 0.5);\n    vec3 addWave = mix(add, vec3(0.0), sin(iTime) * 0.5 + 0.5);\n\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    vec4 tgt = texture( iChannel0, uv );\n    // xyz is used when a color is using luma, warm, mild instead of red, green, blue channels\n    tgt.xyz = addWave + mulWave * vec3(dot(tgt.rgb, vec3(0.375, 0.5, 0.125)), tgt.r - tgt.b, tgt.g - tgt.b);\n    fragColor.rgb = clamp(vec3(\n           dot(tgt.xyz, vec3(1.0, 0.625, -0.5)),\n           dot(tgt.xyz, vec3(1.0, -0.375, 0.5)),\n           dot(tgt.xyz, vec3(1.0, -0.375, -0.5))),\n       0.0, 1.0);\n    fragColor.a = 1.0;\n}\n", "image_inputs": [{"id": "4dfGRn", "previewfilepath": "/media/ap/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "channel": 0, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttf3D4.jpg", "access": "shaders20k", "license": "cc0-1.0", "functions": [[1198, 1198, 1255, 1255, 1944]], "test": "error"}
{"id": "ttfGDn", "name": "Colorful Sine Snake ", "author": "repeatingmotion", "description": "https://www.shadertoy.com/view/4dsGzH\n\nTook this elegant design and proceeded to turn it into a colorful monstrosity. ", "tags": ["simple", "basic", "wave", "retro", "colorful", "color", "sine", "trippy", "easy", "glowing", "signal"], "likes": 5, "viewed": 445, "published": "Public", "date": "1556030098", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec3 COLOR1 = vec3(0.1, 0.1, 0.0);\nvec3 COLOR2 = vec3(0.0, 0.1, 0.1);\nfloat BLOCK_WIDTH = 0.01;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\t\n\t// To create the BG pattern\n\tvec3 final_color = vec3(0.0);\n\tvec3 bg_color = vec3(0.0);\n\tvec3 wave_color = vec3(0.0);\n\t\n\tfloat c1 = mod(uv.x, 20. * BLOCK_WIDTH );\n\tc1 = step(BLOCK_WIDTH, c1);\n\t\n\tfloat c2 = mod(uv.y, 20. * BLOCK_WIDTH );\n\tc2 = step(BLOCK_WIDTH, c2);\n\t\n\tbg_color = mix(uv.x * COLOR1, uv.y * COLOR2, c1 * c2);\n\t\n\t\n\t// To create the waves\n\tfloat wave_width = 0.01;\n\tuv  = -1.3 + 2.4* uv;\n\tuv.y += 0.1;\n\tfor(float i = 0.0; i < 13.0; i++) {\n\t\t\n\t\tuv.y += (0.3 * sin(uv.x + i/1.5 + iTime ));\n\t\twave_width = abs(1.0 / (150.0 * uv.y));\n\t\twave_color += vec3(wave_width * 1.7 * sin(iTime-1.5), wave_width, wave_width * 1.5 * sin(iTime+1.));\n\t}\n\t\n\tfinal_color = bg_color + wave_color;\n\t\n\t\n\tfragColor = vec4(final_color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttfGDn.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[97, 97, 154, 154, 930]], "test": "ok"}
{"id": "ttfGzH", "name": "🎶 Rainbow soundviz 🎶", "author": "avin", "description": "Ok, now it's time to play with music visualization :)\n\nTrack: https://soundcloud.com/lil_peep/spotlight-1", "tags": ["circles", "musicvisualizer"], "likes": 16, "viewed": 747, "published": "Public API", "date": "1555620438", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI 3.1415926 \n#define PI2 6.2831852 \n \n#define hue(h)clamp(abs(fract(h + vec4(3, 2, 1, 0) / 3.0) * 6.0 - 3.0) - 1.0 , 0.0, 1.0)\n \nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n { \n    vec2 uv = (fragCoord - iResolution.xy * 0.5) / iResolution.y;\n    \n    float CIRCLES = 20.0;\n    float cS = 0.375;\n    \n    float sm = 1.0 / iResolution.y * 2.0; // smooth\n    float ps = 1.0 / iResolution.y * sqrt(iResolution.y) * 0.225; // circle thin\n    \n    float d = length(uv);\n    \n    float a = atan(uv.y, uv.x);\n    a = a < 0.0 ? PI + (PI - abs(a)) : a;\n    \n    float lPos = a /PI2;\n    \n    float m = 0.0;\n    float partSize = 1.0 / CIRCLES;\n    vec3 col;\n    for(float i = CIRCLES; i > 1.0; i -= 1.0) {\n        \n        float ilPos = fract(lPos + i*0.1 + iTime * 0.1);\n        float cPos = partSize * i + ilPos * partSize;\n        float invPos = partSize * (i + 1.0) - ilPos * partSize;\n        float nzF = (1.0 - ilPos);\n        float mP0 = texture(iChannel0, vec2(partSize * i, 0.0)).x;\n        float mP = texture(iChannel0, vec2(cPos, 0.0)).x;\n        float mPInv = texture(iChannel0, vec2(invPos, 0.0)).x;\n        \n        mP = (mP + mPInv) / 2.0;\n        \n        float rDiff = i*(1.0 / CIRCLES * 0.35);\n        float r = mP * (1.0 / CIRCLES * 3.0) - rDiff;\n        \n        float subm = smoothstep(cS - ps + r, cS - ps + sm + r, d) * smoothstep(cS + r, cS - sm + r, d);\n        \n        if (subm > 0.0) {\n            col = hue(i / CIRCLES * 0.5 + iTime * 0.05 + mP0 * 0.84).rgb;\n        }\n        \n        m += subm;\n    }\n    \n    m = clamp(m, 0.0, 1.0);\n        \n    float r = (sin(iTime * 0.5) * 0.5 + 0.5);\n    float b = (cos(iTime * 0.5) * 0.5 + 0.5);\n    vec3 backCol = vec3(r, 0.0, b) * length(uv * 0.75) * 0.5;\n       \n    col = mix(backCol, col, m);\n        \n    fragColor = vec4(col, 1.0);\n} \n", "image_inputs": [{"id": "4tl3D7", "previewfilepath": "https://soundcloud.com/lil_peep/spotlight-1", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0, "src": "https://soundcloud.com/lil_peep/spotlight-1", "ctype": "musicstream"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttfGzH.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[138, 138, 194, 194, 1819]], "test": "error"}
{"id": "ttl3z4", "name": "Waves of sound", "author": "madonius", "description": "Ripples", "tags": ["ripples", "physics"], "likes": 8, "viewed": 771, "published": "Public API", "date": "1555793246", "time_retrieved": "2021-10-01T00:00:00", "image_code": "# define WARP 1.\n# define FREQ_RANGE 20.\n# define PI 3.141592653589793\n# define SCALE iResolution.x/\n# define SOUNDSOURCE iChannel1\n// http://lolengine.net/blog/2013/07/27/rgb-to-hsv-in-glsl\nvec3 hsv2rgb(vec3 c)\n{\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nfloat getfrequency(float x) {\n\treturn texture(SOUNDSOURCE, vec2(floor(x * FREQ_RANGE + 1.0) / FREQ_RANGE, .25)).x + 0.06;\n}\n\nfloat getfrequency_smooth(float x) {\n\tfloat index = floor(x * FREQ_RANGE) / FREQ_RANGE;\n    float next = floor(x * FREQ_RANGE + 1.0) / FREQ_RANGE;\n\treturn mix(getfrequency(index), getfrequency(next), smoothstep(0.0, 1.0, fract(x * FREQ_RANGE)));\n}\n\nfloat getfrequency_blend(float x) {\n    return mix(getfrequency(x), getfrequency_smooth(x), 0.5);\n}\n\nfloat getMaxFreq(){\n\treturn texture(SOUNDSOURCE, vec2(1.)).x;\n}\n\nvec3 gradients( in vec2 fragCoord ) {\n\tvec2 uv = fragCoord/iResolution.xy;\n    \n    return hsv2rgb(vec3 (\n        0.5+0.5*sin(0.4*iTime*WARP)*(\n            sqrt(\n                (\n                    pow(0.5-0.6*cos(0.3*WARP*iTime)*(fragCoord.x-(iResolution.x-iResolution.y)/2.)/iResolution.y,2.)\n                )\n                +\n                (\n                    pow(0.7-0.4*sin(0.15*WARP*iTime)*uv.y,2.)\n                )\n            )\n        ),\n        0.8+0.2*cos(0.2*WARP*iTime)*(\n            sqrt(\n                (\n                    pow(0.7-0.2*sin(0.5*WARP*iTime)*(fragCoord.x-(iResolution.x-iResolution.y)/2.)/iResolution.y,2.)\n                )\n                +\n                (\n                    pow(-0.1*cos(0.3*WARP*iTime)*uv.y,2.)\n                )\n        \t)\n        ),\n        0.9+0.1*sin(WARP*iTime)*(\n            sqrt(\n                (\n                    pow(0.6-\n                        sin(2.*WARP*iTime)*\n                        (\n                            fragCoord.x-(\n                                iResolution.x-iResolution.y\n                            )/2.\n                        )/iResolution.y,2.\n                       )\n                )\n                +\n                (\n                    pow(0.2-cos(WARP*iTime)*uv.y,2.)\n                )\n        \t)\n        )\n    ));\n}\n\nvec3 ripples( in vec2 fragCoord, in vec2 cent ){\n\tvec2 uv = fragCoord/iResolution.xy;\n    float scale = iResolution.x/1920.;\n    float max_rad = sqrt(\n        pow(iResolution.x,2.0)\n        +pow(iResolution.y,2.0)\n    );\n    \n    float r = sqrt(\n    \tpow(fragCoord.x-cent.x,2.0)\n        +pow(fragCoord.y-cent.y,2.0)\n    );\n    \n    return vec3 (\n    \t1.-0.9*sin((26.*(r/scale-150.*WARP*iTime)/(0.2*max_rad/scale)+0.1))\n    );\n}\n\nfloat fade( in float f_in, in float f_out){\n\tfloat warp_time = iTime*WARP;\n    float fade_duration = f_out-f_in;\n    return max(0.,min(1./(f_out-f_in)*(f_out-warp_time),1.));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float weight = .90;\n    float pi = 3.141592653589793;\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 cent = 0.5*iResolution.xy;\n    float scale = iResolution.x/1920.;\n    vec2 offset = vec2 (-.1*iResolution.y, -.1*iResolution.y);\n    vec2 cent2 = vec2 (-0.2*iResolution.x, -0.2*iResolution.y);\n    vec2 cent3 = vec2 (1.2*iResolution.x,1.2*iResolution.y);\n    vec2 cent4 = vec2 (-0.2*iResolution.x,1.2*iResolution.y);\n    vec2 cent5 = vec2 (1.2*iResolution.x,-0.2*iResolution.y);\n    vec2 cent6 = vec2 (iResolution.x/2., iResolution.y*1.05);\n    vec2 cent7 = vec2 (iResolution.x/2., -iResolution.y*0.15);\n    \n    vec3 col = fade(60.,80.)*gradients(fragCoord)*weight\n        \t   +fade(80.,60.)*(\n                   \t\t\t   hsv2rgb(vec3 (\n                                   sin(0.01*iTime)-0.4*getfrequency_smooth(\n                                       0.3*sin(\n                                           max(0.01,\n                                               min(1.,\n                                                sqrt(\n                                                    pow((cent.x-fragCoord.x)/(500.*scale),2.)\n                                                    +pow((cent.y-fragCoord.y)/(500.*scale),2.)\n                                                )\n                                               )\n                                           )   \n                                       )\n                                   ),\n                                   1.,\n                                   0.3\n                               )))\n        \t   -(\n                   +fade(25.,40.)*(\n                   \t+cos(-iTime*WARP*0.02)*ripples(fragCoord,cent3)\n                   \t+cos(-iTime*WARP*0.02)*ripples(fragCoord,cent3+offset)\n                   \t+cos(-iTime*WARP*0.02)*ripples(fragCoord,cent2)\n                    +cos(-iTime*WARP*0.02)*ripples(fragCoord,cent2+offset)\n                    +cos(-iTime*WARP*0.02)*ripples(fragCoord,cent4)\n                    +cos(-iTime*WARP*0.02)*ripples(fragCoord,cent4+offset)\n                    +cos(-iTime*WARP*0.02)*ripples(fragCoord,cent5)\n                    +cos(-iTime*WARP*0.02)*ripples(fragCoord,cent5+offset)\n                   )\n                   +fade(37.,20.)*fade(50.,60.)*(\n                   \t+2.*cos(-iTime*WARP*0.1)*ripples(fragCoord,cent6)\n                   \t+2.*cos(-iTime*WARP*0.1)*ripples(fragCoord,cent6-offset)\n                   \t+2.*cos(-iTime*WARP*0.1)*ripples(fragCoord,cent7)\n                   \t+2.*cos(-iTime*WARP*0.1)*ripples(fragCoord,cent7+offset)\n                   )\n                   /*+fade(70.,30.)*(\n                    +cos(-iTime*WARP/10.)*ripples(fragCoord,cent)\n                    +cos(-iTime*WARP/10.)*ripples(fragCoord,cent+offset)\n                   )*/\n                   +fade(80.,40.)*1.*(\n                    +(0.3+0.7*getfrequency_smooth(0.1*mod(iTime,10.))\n                     *ripples(fragCoord,cent\n                      +(0.7+0.3*getfrequency_smooth(0.1*mod(iTime,10.)))\n                      +vec2(-offset.x/4.*sin(iTime*WARP),\n                            -offset.x/4.*cos(iTime*WARP))\n                      +(0.7+0.3*getfrequency_smooth(0.1*mod(iTime,10.)))\n                       *vec2(-offset.x*4.*sin(0.4*iTime*WARP),\n                            -offset.x*4.*cos(0.4*iTime*WARP))\n                      )\n                     )\n                    +(0.3+0.7*getfrequency_smooth(0.1*mod(iTime,10.))\n                     *ripples(fragCoord,cent\n                      +(0.7+0.3*getfrequency_smooth(0.1*mod(iTime,10.)))\n                       *vec2(offset.x/4.*sin(iTime*WARP),\n                             offset.x/4.*cos(iTime*WARP))\n                      +(0.7+0.3*getfrequency_smooth(0.1*mod(iTime,10.)))\n                       *vec2(-offset.x*4.*sin(0.4*iTime*WARP),\n                             -offset.x*4.*cos(0.4*iTime*WARP))\n                      )\n                     )\n                   )\n               )*(1.-weight);\n\n    fragColor = vec4(0.2+0.8*sqrt(col),1);\n}", "image_inputs": [{"id": "XdXGRr", "previewfilepath": "/presets/mic.png", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/presets/mic.png", "ctype": "mic"}, {"id": "Mls3D7", "previewfilepath": "https://soundcloud.com/bonifansius/bedtime-baby-lullaby-classical-music-mozart-bach-beethoven-pachelbel-sleep-music-1-hour", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0, "src": "https://soundcloud.com/bonifansius/bedtime-baby-lullaby-classical-music-mozart-bach-beethoven-pachelbel-sleep-music-1-hour", "ctype": "musicstream"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttl3z4.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[132, 191, 213, 213, 382], [384, 384, 413, 413, 507], [509, 509, 545, 545, 756], [758, 758, 793, 793, 857], [859, 859, 878, 878, 922], [924, 924, 961, 961, 2250], [2252, 2252, 2300, 2300, 2679], [2681, 2681, 2724, 2724, 2857], [2859, 2859, 2916, 2916, 6915]], "test": "error"}
{"id": "ttl3z7", "name": "Trippy rubber cube", "author": "MacSlow", "description": "After Revision 2019 - which was a blast - I have lots of trippy ideas in my head. This is one of them... also kind of Amiga-compo inspried. I might add/change face-patterns over time. I added motion-blur support. Mess with the value of MOTION_BLUR_SAMPLES", "tags": ["3d", "retro", "sdf", "motionblur"], "likes": 5, "viewed": 465, "published": "Public API", "date": "1555962295", "time_retrieved": "2021-10-01T00:00:00", "image_code": "////////////////////////////////////////////////////////////////////////////////\n//\n// Trippy rubber cube - Giving room to ideas after Revision 2019.\n//\n// Copyright 2019 Mirco Müller\n//\n// Author(s):\n//   Mirco \"MacSlow\" Müller <macslow@gmail.com>\n//\n// This program is free software: you can redistribute it and/or modify it\n// under the terms of the GNU General Public License version 3, as published\n// by the Free Software Foundation.\n//\n// This program is distributed in the hope that it will be useful, but\n// WITHOUT ANY WARRANTY; without even the implied warranties of\n// MERCHANTABILITY, SATISFACTORY QUALITY, or FITNESS FOR A PARTICULAR\n// PURPOSE.  See the GNU General Public License for more details.\n//\n// You should have received a copy of the GNU General Public License along\n// with this program.  If not, see <http://www.gnu.org/licenses/>.\n//\n////////////////////////////////////////////////////////////////////////////////\n\nprecision highp float;\n\n// number of samples used for motion blur, set to 1.\n// for no motion-blur, if the frame-rate is too low\n// higher values give smoother motion-blur results\nconst float MOTION_BLUR_SAMPLES = 12.;\n\nconst int MAX_ITER    = 32;\nconst float STEP_SIZE = 1.;\nconst float EPSILON   = .001;\n\nmat2 r2d (float d) {\n\tfloat a = radians(d);\n\tfloat c = cos(a);\n\tfloat s = sin (a);\n\treturn mat2 (vec2 (c, s), vec2 (-s, c));\n}\n\nfloat map (vec3 p, inout int id, inout vec3 pout, float t)\n{\n\t// rotate the cube\n\tp.xz *= r2d (135.*t);\n\tp.zy *= r2d (90.*t);\n\tp.xy *= r2d (-73.*t);\n\n\t// twist the cube\n\tp.xy *= r2d (35.*cos(p.z + 2.*t));\n\tp.yz *= r2d (60.*sin(p.x + 3.*t));\n\tp.zx *= r2d (40.*sin(p.y + 3.*t));\n\n    // build cube from infinite planes, so it's\n    // easier to get the UVs per plane later\n\tfloat size = .75;\n\tfloat p1 = p.y - size;\n\tfloat p2 = -p.y - size;\n\tfloat p3 = p.z - size;\n\tfloat p4 = -p.z - size;\n\tfloat p5 = p.x - size;\n\tfloat p6 = -p.x - size;\n\n\tfloat d = max (p1, p2);\n\td = max (d, p3);\n\td = max (d, p4);\n\td = max (d, p5);\n\td = max (d, p6);\n\n    // material/UV id\n\tif (d == p1) id = 1;\n\tif (d == p2) id = 2;\n\tif (d == p3) id = 3;\n\tif (d == p4) id = 4;\n\tif (d == p5) id = 5;\n\tif (d == p6) id = 6;\n\n    // scale UVs\n\tpout = 10.*p;\n\n\treturn d;\n}\n\nfloat march (vec3 ro, vec3 rd, inout int id, inout vec3 pout, float tm)\n{\n\tfloat t = .0;\n\tfloat d = .0;\n\n    for (int i = 0; i < MAX_ITER; i++)\n    {\n        t = map (ro+d*rd, id, pout, tm);\n        if (abs (t) < EPSILON*(1. + .125*t)) break;\n        d += t*STEP_SIZE;\n    }\n\n    return d;\n}\n\nvec3 background (vec2 uv, float t)\n{\n\tfloat d = fract (5.*length (uv) - 3.*t);\n\tfloat m = smoothstep (.0, 1., d);\n    return mix (vec3 (.0125), vec3 (.3, .0125, .0), 1. - m);\n}\n\nvec3 shade (int id, vec3 pout, float t)\n{\n    vec3 color = vec3 (.0);\n\tfloat dark = .1;\n\tfloat light = .9;\n\n\tif (id == 1) {\n\t\tpout.xz *= r2d (90.*t);\n\t\tfloat lf = 4.*texture (iChannel0, .25*pout.xz).r;\n\t\tfloat hf = .25*texture (iChannel0, 4.*pout.xz).r;\n\t\tfloat d = cos (2.*pout.z - 6.*t + sin(2.*(pout.x+lf+hf)));\n\t\tfloat m = smoothstep (.3, .7, d);\n\t\tcolor = mix (vec3 (dark), vec3 (light), m);\n\t}\n\tif (id == 2) {\n        t *= 2.;\n\t\tpout.xz *= r2d (-135.*t);\n\t\tpout.xz *= 20.;\n        float d = cos(pout.x*.12 + t)+\n                  cos(pout.x*.13 - t)+\n                  cos(pout.z*.1 + t)+\n            \t  cos(pout.z*.105 - t);\n\t    float m = smoothstep (.0, 1., d);\n\n\t\tcolor = mix (vec3 (dark), vec3 (light), m);\n\t}\n\tif (id == 3) {\n\t\tfloat lf = 2.*texture (iChannel0, .125*pout.xy).r;\n\t\tfloat hf = .125*texture (iChannel0, 8.*pout.xy).r;\n\t\tfloat d = cos (5.*(pout.x+lf+hf)-5.*(pout.y-lf+hf)+15.*t);\n\t\tfloat m = smoothstep (.5, .55, d);\n\t\tcolor = mix (vec3 (dark), vec3 (light), m);\n\t}\n\tif (id == 4) {\n\t\tpout.xy *= 1. + 1.*(.5 + .5*cos(4.*t));\n\t\tpout.xy *= r2d (45.*t);\n\t\tfloat lf = texture (iChannel0, .25*pout.xy-.6*t).r;\n\t\tfloat hf = .25*texture (iChannel0, 2.*pout.xy+.4*t).r;\n\t\tfloat d = cos (pout.x+lf+hf + sin(lf+hf*pout.y));\n\t\tfloat m = smoothstep (.0, 1., d);\n\t\tcolor = mix (vec3 (dark), vec3 (light), m);\n\t}\n\tif (id == 5) {\n\t\tfloat d = fract (length (.5*pout.zy)+2.*t);\n\t\tfloat m = smoothstep (.45, .55, d);\n\t\tcolor = mix (vec3 (dark), vec3 (light), d);\n\t}\n\tif (id == 6) {\n\t\tvec2 off1 = 5.*vec2 (cos (1.6*t), sin (2.4*t));\n\t\tvec2 off2 = 6.*vec2 (cos (2.1*t), sin (1.5*t));\n\t\tfloat d1 = fract (length (pout.yz + off1) - .3);\n\t\tfloat d2 = fract (length (pout.yz + off2) - .3);\n\t\tfloat m1 = smoothstep (.5, .52, d1);\n\t\tfloat m2 = smoothstep (.5, .52, d2);\n\t\tfloat m = m1*(1. - m2) + m2*(1. - m1);\n\t\tcolor = mix (vec3 (dark), vec3 (light), m);\n\t}\n\n    return color;\n}\n\nvec3 camera (in vec2 uv, in vec3 ro, in vec3 aim, in float zoom)\n{\n    vec3 f = normalize (vec3 (aim - ro));\n    vec3 wu = vec3 (.0, 1., .0);\n    vec3 r = normalize (cross (wu, f));\n    vec3 u = normalize (cross (f, r));\n    vec3 c = ro + f*zoom;\n\n    return normalize (c + uv.x*r + uv.y*u - ro);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n\tvec2 uvRaw = fragCoord.xy/iResolution.xy;\n\tvec2 uv = uvRaw*2. - 1.;\n    uv.x *= iResolution.x/iResolution.y;\n\n    vec3 ro = vec3 (1., 1.5, 2.);\n    vec3 aim = vec3 (.0, .5*cos(4.*iTime), .0);\n    float zoom = 1.5+.2*cos(3.*iTime);\n    vec3 rd = camera (uv, ro, aim, zoom);\n\n\tint id = 0;\n\tvec3 pout;\n\n    float d;\n    float fog;\n    vec3 bg;\n    vec3 fg;\n\tvec3 c = vec3 (.0);\n\n    const float numSamples = MOTION_BLUR_SAMPLES;\n    for (float samples = .0; samples < numSamples; ++samples) {\n        float t = iTime - samples/numSamples/60.;\n\t\td = march (ro, rd, id, pout, t);\n    \tfog = abs (1./(2. - exp(d*d*.35)));\n    \tbg = background (uv, t);\n        fg = shade (id, pout, t);\n        c += (d < 3.25) ? fg*fog : bg;\n    }\n    c /= numSamples;\n\n    c = c / (1. + c);\n\tc *= 1. - .75*length (uvRaw*2.-1.);\n\tc *= mix (1., .5, cos(700.*uv.y));\n\tc *= mix (1., .5, cos(700.*uv.x));\n    c = pow (c, vec3 (1./2.2));\n\n\tfragColor = vec4(c, 1.);\n}\n", "image_inputs": [{"id": "4sf3Rr", "previewfilepath": "/media/ap/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png", "ctype": "texture"}, {"id": "XlX3RS", "previewfilepath": "https://soundcloud.com/kinesau/jesus-on-es-on-speed", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0, "src": "https://soundcloud.com/kinesau/jesus-on-es-on-speed", "ctype": "musicstream"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttl3z7.jpg", "access": "shaders20k", "license": "gpl-3.0", "functions": [[1253, 1253, 1273, 1273, 1379], [1381, 1381, 1441, 1461, 2217], [2219, 2219, 2292, 2292, 2510], [2512, 2512, 2548, 2548, 2688], [2690, 2690, 2731, 2731, 4567], [4569, 4569, 4635, 4635, 4867], [4869, 4869, 4926, 4926, 5867]], "test": "error"}
{"id": "ttlGD8", "name": "Ray Marching Fractal Spheres", "author": "kindpotato", "description": "This is a shit shader I made. I say it is shit because it looks really glitchy. oh well.", "tags": ["fractalraymarchingspheres"], "likes": 3, "viewed": 162, "published": "Public", "date": "1556232404", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define offsetDist(offset) dist = distance(pos,ballPos+offset)-ballRadius;if (dist < t){t = dist;newPos = ballPos+offset;}\nvec4 distToFractal(vec3 pos){\n    vec3 ballPos = vec3(0);\n    float ballRadius = 1.3;\n    float time = 3.14159265*sin(iTime*1.1)/20.;\n    vec2 rotator = vec2(cos(time),sin(time));\n    vec3 X = vec3(1.5,0,0);\n    vec3 Y = vec3(0,1,0);\n    vec3 Z = vec3(0,0,1);\n    float t = 1000.;\n    vec3 newPos;\n    float dist;\n    \n    for (int i = 0; i < 6; ++i){\n        \n        \n       \n        //float midt = length(pos-ballPos)-ballRadius;\n        offsetDist(vec3(0));\n        ballRadius /= 2.;\n\t\t\n        offsetDist(X)\n       \toffsetDist(Y)\n        offsetDist(Z)\n        offsetDist(-X)\n        offsetDist(-Y)\n        offsetDist(-Z)\n      \t/*if (midt < t){\n            return vec4(normalize(pos-ballPos),midt);\n            \n        }*/\n        \n        X = vec3(rotator.x*X.x - rotator.y*X.y,rotator.x*X.y+rotator.y*X.x,0);\n        X /= 2.;\n        Y /= 2.;\n        \n        Z /= 2.;\n        ballPos = newPos;\n    }\n    return vec4(normalize(pos-newPos),t);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy/iResolution.x;\n    float aspect = iResolution.x/iResolution.y;\n    vec3 viewingNormal = normalize( vec3( uv-vec2(0.5,0.5/aspect),1));\n    float time = iTime * 0.1;\n    vec3 cameraPos = 10.*vec3(cos(time),cos(iTime)/5.,sin(time));\n    vec3 currentPos = cameraPos;\n    vec3 Z = -normalize(currentPos);\n    vec3 X = normalize(cross(vec3(0,1,0),Z));\n    vec3 Y = cross(Z,X);\n    viewingNormal = viewingNormal.x * X + viewingNormal.y * Y + viewingNormal.z *Z;\n    fragColor = vec4(0,0,0,1);\n    for (int i = 0; i < 50; ++i){\n        vec4 NT = distToFractal(currentPos);\n        if (NT.w < 0.001){\n            const vec3 lightPos = vec3(2,-10,4);\n            vec3 position = viewingNormal*NT.w;\n            vec3 surfaceToLight = normalize(lightPos - position);\n            vec3 reflected = reflect(viewingNormal,NT.xyz);\n            float sky = asin(dot(NT.xyz,vec3(0,1,0)))/3.141459+0.5;\n            float shine = smoothstep(0.8,1.,dot(reflected,surfaceToLight));\n            float diffuse = dot(NT.xyz,surfaceToLight);\n            fragColor = vec4(vec3(0.1+0.3*shine+0.5*sky+0.3*diffuse),1);\n        }\n        currentPos += viewingNormal*NT.w;\n        \n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttlGD8.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[123, 123, 152, 152, 1075], [1077, 1077, 1134, 1134, 2318]], "test": "ok"}
{"id": "ttlGR4", "name": "Flying Centipede", "author": "Klems", "description": "Also VR compatible! Click to rotate the camera.", "tags": ["procedural", "3d", "raymarch", "pbr", "insect"], "likes": 105, "viewed": 4298, "published": "Public API", "date": "1555783245", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n#define PI 3.14159265359\n#define rot(a) mat2(cos(a + PI*0.5*vec4(0,1,3,0)))\n#define Z min(iFrame, 0)\n\n// how many segments there are\n#define SEGMENTS 21\n// only display the nth segment\n//#define SEGMENT 0\n\n#define COLOR_SHELL vec4(0.015, 0.01, 0.005, 0.3)\n#define COLOR_SHELL2 vec4(0.15, 0.01, 0.001, 0.6)\n#define COLOR_ORGAN vec4(0.3, 0.1, 0.01, 0.7)\n#define COLOR_SUB vec3(0.5, 0.8, 0.9)\n\n#define VR_SCALE 0.5\n\nvec4 dummy = vec4(0);\n\n// iq's distance to a box\nfloat sdBox( vec3 p, vec3 b ) {\n    vec3 d = abs(p) - b;\n    return length(max(d,0.0)) + min(max(d.x,max(d.y,d.z)),0.0);\n}\n\n// iq's distance to capped cylinder\nfloat sdCappedCylinder( vec3 p, vec2 h ) {\n    vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\n// iq's smooth minimum\nfloat smin( float d1, float d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h);\n}\n\n// iq's box filtered grid\nfloat grid( in vec2 p ) {\n    vec2 dpdx = dFdx(p);\n    vec2 dpdy = dFdy(p);\n    const float N = 15.0;\n    p += 1.0/N*0.5;\n    vec2 w = max(abs(dpdx), abs(dpdy));\n    vec2 a = p + 0.5*w;                        \n    vec2 b = p - 0.5*w;           \n    vec2 i = (floor(a)+min(fract(a)*N,1.0)-\n              floor(b)-min(fract(b)*N,1.0))/(N*w);\n    return (1.0-i.x)*(1.0-i.y);\n}\n\n// dave hoskins hash\nvec3 hash33( vec3 p3 ) {\n\tp3 = fract(p3 * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+19.19);\n    return fract((p3.xxy + p3.yxx)*p3.zyx);\n}\n\n// path parametric equation\nvec3 path( float x ) {\n    x += iTime*0.7;\n    return vec3(cos(x), sin(x*2.3312)*0.3 + sin(x*1.456)*0.4, sin(x))*1.0;\n}\n\n// path derivative\nvec3 pathd( float x ) {\n    x += iTime*0.7;\n    return vec3(-sin(x), cos(x*2.3312)*0.3*2.3312+cos(x*1.456)*0.4*1.456, cos(x))*1.0;\n}\n\n// path scale\nfloat paths( float x ) {\n    return 1.0 - cos(x*2.0)*0.3;\n}\n\n// one leg\nfloat leg( vec3 p, const bool complex, out vec4 albedo, float parm, float phase, int end ) {\n    \n    float scaleP = paths(parm);\n    \n    // walk animation\n    float xro = iTime*-3.0+phase*2.0*PI + parm*12.0;\n    float sro = sin(xro);\n    float cro = cos(xro);\n    \n    float ends = 1.0;\n    if (end == 0) ends = 0.2;\n    if (end == SEGMENTS-1) ends = 0.4;\n    \n    p = p.yxz;\n    \n    p.yz *= rot(sro*0.3*ends);\n    p.yx *= rot(-0.2);\n    p.y += 0.02;\n    \n    float de = length(p)-0.03;\n    float s = 0.0;\n    float scale = 1.0;\n    float col = 0.0;\n    \n    float temp = (cro*-0.5+0.5)*0.5*ends;\n    \n    for (int i = Z ; i < 3 ; i++) {\n    \t\n        // offset the leg segment\n        p.y -= 0.04;\n        p.yx *= rot( temp + 0.1*scale );\n        p.y -= 0.04;\n        \n        // bend toward a point\n        s += smoothstep(-0.04, 0.04, p.y)*scale;\n        // find out the segment dimension\n        vec2 dim = vec2(0.039 - 0.02*(scale *= 1.1) - 0.003*s, 0.04);\n        // get distance\n        float d = sdCappedCylinder( p, dim ) - 0.002;\n        de = smin(de, d, 0.01);\n        \n        // colorize a bit\n        if ( complex ) {\n            float f = smoothstep(0.01, -0.01, d);\n            float c = sin(p.y*60.0)*-0.5+0.5;\n        \tcol += f*c;\n        }\n    }\n    \n    if ( complex ) {\n        float f = max(0.2, 0.75-col*0.7);\n        vec4 colOrg = mix(COLOR_ORGAN, COLOR_SHELL2, clamp((1.0-scaleP)*3.0+0.5, 0.0, 1.0));\n        albedo = mix(colOrg, COLOR_SHELL, f);\n    }\n    \n    return de;\n    \n}\n\n// one body part with two legs, return organic/shell as vec2\nvec2 body( vec3 p, const bool complex, out vec4 albedo, float parm, int index ) {\n    \n    float scaleP = paths(parm);\n    p /= scaleP;\n    \n    // add a base body\n    vec3 dim = vec3(0.04, 0.01, 0.05);\n    dim += cos(p.zxx*vec3(48,38,30))*vec3(0.01, 0.005, 0.02);\n   \tfloat org = sdBox(p, dim) - 0.04;\n    \n    // shell above it\n    vec3 inShell = p - vec3(0, 0.055, -0.01);\n    inShell.yz *= rot(-0.15);\n    inShell.yz -= cos(inShell.xx*vec2(20, 15))*0.02;\n    inShell.x = abs(inShell.x) - cos(inShell.z*20.0+1.0)*0.01;\n    float de = sdBox(inShell, vec3(0.08, 0, 0.09)) - 0.01;\n    \n    // legs\n    vec3 inLe = p;\n    float phase = step(p.x, 0.0)*0.5;\n    inLe.x = abs(inLe.x);\n    if (index == 0) {\n        // recycle legs into antennas\n        phase *= 0.4;\n        inLe.xz *= rot(-1.2);\n        inLe -= vec3(0.12, 0.02, 0.02);\n        inLe.xy *= rot(-0.3);\n        // add mandibles while we're here\n        vec3 inMandi = p;\n       \tinMandi.x = abs(inMandi.x) - 0.04;\n        inMandi.yz += vec2(0.03, -0.1);\n        inMandi.xy *= rot(0.3);\n        inMandi.yz *= rot(-0.3);\n        float mandi = sdBox(inMandi, vec3(0.01, 0.03, 0.04)) - 0.025;\n        de = min(de, mandi);\n    } else if (index == SEGMENTS-1) {\n        phase *= 0.2;\n        inLe.xz *= rot(1.2);\n        inLe -= vec3(0.1, 0.02, -0.01);\n        inLe.xy *= rot(-0.3);\n    } else {\n        inLe.xy += vec2(-0.07, 0.02);\n    }\n    \n    // add more stuff between the body and leg\n    vec4 leAlbedo = vec4(0);\n    float le = leg(inLe, complex, leAlbedo, parm, phase, index);\n    float bum = length(inLe)-0.03;\n    le = smin(le, bum, 0.03);\n    \n    // add bump mapping and coloring\n    if ( complex ) {\n        float tex1 = textureLod(iChannel0, inShell.xz*1.0 + float(index)*0.1424, 0.0).r;\n        float tex2 = textureLod(iChannel0, inShell.xz*1.4 + float(index)*0.1424, 0.0).r;\n        float she = smoothstep(0.0, 0.025, de+tex1*0.005);\n        de += tex1*0.03;\n        org -= tex2*0.03;\n        vec4 colOrg = mix(COLOR_ORGAN, COLOR_SHELL2, clamp((1.0-(scaleP*scaleP))*3.0-0.5, 0.0, 1.0));\n        float leAl = smoothstep(0.01, 0.0, le);\n        colOrg = mix(colOrg, leAlbedo, leAl);\n        vec4 baseColor = mix(COLOR_SHELL, colOrg, she);\n        albedo = baseColor;\n    }\n    \n    // then add the legs to the shell\n    de = smin(de, le, 0.005);\n    \n    // return organic + shell to composite later\n    return vec2(org, de) * scaleP;\n}\n\n// distance estimator\nfloat de( vec3 p, const bool complex, out vec4 albedo ) {\n    \n    #ifdef SEGMENT\n    vec2 seg = body(p, complex, albedo, 0.0, SEGMENT);\n    return smin(seg.x, seg.y, 0.01);\n    #endif\n    \n    // find the two closest points\n    vec3[2] closestParmDistIndex = vec3[2](vec3(0, 9e9, 0), vec3(0, 9e9, 0));\n    float currentParm = 0.0;\n    for (int i = Z ; i < SEGMENTS ; i++) {\n        vec3 current = path(currentParm);\n        vec3 currentD = p - current;\n        float currentDist = dot(currentD, currentD);\n        if (currentDist < closestParmDistIndex[0].y) {\n            closestParmDistIndex[1] = closestParmDistIndex[0];\n            closestParmDistIndex[0] = vec3(currentParm,currentDist,float(i));\n        } else if (currentDist < closestParmDistIndex[1].y) {\n            closestParmDistIndex[1] = vec3(currentParm,currentDist,float(i));\n        }\n        currentParm -= 0.17 / length(pathd(currentParm)) * paths(currentParm);\n    }\n    \n    float dOrg = 8.0;\n    float dShe = 8.0;\n    \n    albedo = COLOR_SHELL;\n    \n    for (int i = Z; i < 2 ; i++) {\n        float centerParm = closestParmDistIndex[i].x;\n        int centerIndex = int(closestParmDistIndex[i].z);\n        vec3 center = path(centerParm);\n        \n        // create basis\n        vec3 upZ = path(centerParm + 0.3) - center;\n        vec3 forward = normalize(path(centerParm + 0.1) - center);\n        vec3 right = normalize(cross(forward, upZ));\n        vec3 up = cross(forward, right);\n        // offset and transform\n        vec3 tp = p - center;\n        tp = tp * mat3(right, up, forward);\n\t\t\n        // get distance to the object\n        vec4 albObj = vec4(0);\n        vec2 de = body(tp, complex, albObj, centerParm, centerIndex);\n        float minDe = min(de.x, de.y);\n        \n        // composite organic/shell differently so shell/legs don't merge together\n        dOrg = smin(dOrg, de.x, 0.07);\n        dShe = min(dShe, de.y);\n        \n        if (complex) {\n            albedo = mix(albedo, albObj, smoothstep(0.01, -0.01, minDe));\n        }\n    }\n    \n    float d = smin(dShe, dOrg, 0.02);\n    \n    return d;\n}\n\n// normal function, call de() in a for loop for faster compile times.\nvec3 getNormal( vec3 p, float here ) {\n    vec3 n = vec3(0);\n    for (int i = Z ; i < 3 ; i++) {\n        vec3 s = p;\n        s[i] += 0.01;\n        n[i] = de(s, true, dummy);\n    }\n    return normalize(n.xyz-here);\n}\n\n// PBR WORKFLOW BELOW\n\nfloat DistributionGGX(vec3 N, vec3 H, float roughness) {\n    float a = roughness*roughness;\n    float a2 = a*a;\n    float NdotH = max(dot(N, H), 0.0);\n    float NdotH2 = NdotH*NdotH;\n    float num = a2;\n    float denom = (NdotH2 * (a2 - 1.0) + 1.0);\n    denom = PI * denom * denom;\n    return num / denom;\n}\n\nfloat GeometrySchlickGGX(float NdotV, float roughness) {\n    float r = (roughness + 1.0);\n    float k = (r*r) / 8.0;\n    float num = NdotV;\n    float denom = NdotV * (1.0 - k) + k;\n    return num / denom;\n}\n\nfloat GeometrySmith(vec3 N, vec3 V, vec3 L, float roughness) {\n    float NdotV = max(dot(N, V), 0.0);\n    float NdotL = max(dot(N, L), 0.0);\n    float ggx2 = GeometrySchlickGGX(NdotV, roughness);\n    float ggx1 = GeometrySchlickGGX(NdotL, roughness);\n    return ggx1 * ggx2;\n}\n\nvec3 fresnelSchlick(float cosTheta, vec3 F0) {\n    return F0 + (1.0 - F0) * pow(1.0 - cosTheta, 5.0);\n}\n\nvec3 computeLighting(in vec3 normal, in vec3 viewDir,\n                     in vec3 albedo, in float metallic, in float roughness,\n                     in vec3 lightDir, in vec3 radiance) {\n    \n    vec3 result = vec3(0);\n    \n    // find half way vector\n    vec3 halfwayDir = normalize(viewDir + lightDir);\n    \n    // figure out surface reflection\n    vec3 F0 = vec3(0.04);\n    F0 = mix(F0, albedo, metallic);\n    \n    // find the PBR terms\n    float NDF = DistributionGGX(normal, halfwayDir, roughness);\n    float G = GeometrySmith(normal, viewDir, lightDir, roughness);\n    vec3 F = fresnelSchlick(max(dot(halfwayDir, viewDir), 0.0), F0);\n    \n    vec3 kS = F;\n    vec3 kD = 1.0 - kS;\n    kD *= 1.0 - metallic;\n    \n    // Cook Torrance BRDF\n    vec3 numerator = NDF * G * F;\n    float denominator = 4.0 * max(dot(normal, viewDir), 0.0) * max(dot(normal, lightDir), 0.0);\n    vec3 specular = numerator / max(denominator, 0.001);  \n    \n    // add light contribution\n    float NdotL = max(dot(normal, lightDir), 0.0);\n    result += (kD * albedo / PI + specular) * radiance * NdotL;\n    \n    return result;\n}\n\n// PBR WORKFLOW ABOVE\n\n// fake subsurface scattering\nvec3 computeSSS(in vec3 normal, in vec3 viewDir, \n                in vec3 albedo, in float trans, in float index,\n                in vec3 lightDir, in vec3 radiance) {\n    float add = 1.0 - index;\n    add *= add;\n    add *= add;\n    add *= add;\n    add *= add;\n    float fr = dot(viewDir, normal)*0.5+0.5;\n    float lu = dot(viewDir, lightDir)*-0.5+0.5;\n    add *= fr*fr;\n    add *= lu;\n    return radiance*add*1.0*trans*albedo;\n}\n\n// soft shadow function\nfloat traceShadow( in vec3 from, in vec3 dir, in vec3 normal, const float sinTheta ) {\n    if (dot(dir, normal) < 0.0) return 0.0;\n    float minAlpha = 1.0;\n    float totdist = 0.0;\n    #define SHADOW_STEPS 20\n    for (int i = Z ; i < SHADOW_STEPS ; i++) {\n        vec3 p = from+dir*totdist;\n        if (dot(p, p) > 6.0) return minAlpha;\n        float dist = de(p, false, dummy);\n        float rad = dist / (totdist*sinTheta);\n        float alpha = rad * 0.5 + 0.5;\n        if (alpha <= 0.0) {\n            return 0.0;\n        } else if (alpha < minAlpha) {\n            minAlpha = alpha;\n        }\n        totdist += max(0.01, dist*0.8);\n    }\n    return minAlpha;\n}\n\n// get lighting here\nvec3 getLighting( in vec3 p, in vec3 dir, float index ) {\n    // get surface albedo and roughness\n    vec4 albedo = vec4(0);\n    float d = de(p, true, albedo);\n    // get surface normal\n    vec3 n = getNormal(p, d);\n    \n    vec3 result = vec3(0);\n    const vec3 sunDir = normalize(vec3(1, 4, 2));\n    const vec3 subDir = normalize(vec3(2, -7, 3));\n    \n    // add two lights, main one with shadows\n    float shadow = traceShadow(p+n*0.01, sunDir, n, 0.05);\n    result += computeLighting(n, dir, albedo.rgb, (1.0-albedo.a)*0.3, albedo.a, sunDir,\n                              vec3(0.9, 0.85, 0.5)*10.0)*shadow;\n    result += computeLighting(n, dir, albedo.rgb, (1.0-albedo.a)*0.3, albedo.a, subDir,\n                              COLOR_SUB*0.5);\n    // and add subsurface scattering\n    result += computeSSS(n, dir, albedo.rgb, albedo.a, index, sunDir,\n                         vec3(0.9, 0.85, 0.5)*10.0);\n    result += computeSSS(n, dir, albedo.rgb, albedo.a, index, subDir,\n                         COLOR_SUB*0.5);\n    \n    return result;\n}\n\n// get background\nvec3 getBackground( in vec3 dir ) {\n    // raytrace two plane\n    dir.y = abs(dir.y);\n    float d = 1.0 / dir.y;\n    vec2 p = (dir*d).xz;\n    // add a simple grid\n    vec3 base = mix(COLOR_SUB*0.007, vec3(0.001), grid(p));\n    // and a black fog over it\n    base = mix(base, vec3(0.0002), 1.0-exp(-d*0.4));\n    return base;\n}\n\n// return ray color for this position and direction\nvec4 getColor( in vec2 fragCoord, in vec3 from, in vec3 dir ) {\n    \n    // get random stuff\n    vec3 rnd = hash33(vec3(fragCoord, iFrame*2+0));\n    \n    // find the angular extent of this pixel\n    vec3 ddir = normalize(dir+fwidth(dir)*0.5);\n    float sinPix = length(cross(dir, ddir));\n    // add some noise to the base distance as dithering\n    float totdist = 0.2*rnd.x;\n    \n    // keep track of the closest position\n    vec3 fullPos = vec3(0);\n    float fullAlpha = 0.0;\n    int fullIndex = 0;\n    \n    #define STEPS 100\n    for (int i = Z ; i < STEPS ; i++) {\n        vec3 p = from + dir*totdist;\n        // found sky, break early\n        if (dot(p, p) > 6.0) break;\n        // find out the average alpha here\n        float dist = de(p, false, dummy);\n        float rad = dist / (totdist*sinPix);\n        float alpha = rad * -0.5 + 0.5;\n        \n        // we have a covering sample, consider it\n        if (alpha > 0.0 && alpha > fullAlpha) {\n            fullPos = p;\n            fullAlpha = alpha;\n            fullIndex = i;\n            // sample is fully opaque, break early\n            if (alpha >= 1.0) break;\n        }\n            \n        // move to next sample point\n        totdist += max(0.0004, dist*0.8);\n    }\n    \n    // if we found the surface add lighting\n    if (fullAlpha > 0.0) {\n        float index = float(fullIndex)/float(STEPS-1);\n        fullAlpha = clamp(fullAlpha, 0.0, 1.0);\n        return vec4(getLighting(fullPos, -dir, index), fullAlpha);\n    }\n    \n    return vec4(0);\n}\n\n// vr entry point\nvoid mainVR( out vec4 fragColor, in vec2 fragCoord, in vec3 fragRayOri, in vec3 fragRayDir ) {\n    \n    // get color and mix with background\n    vec4 col = getColor(fragCoord, fragRayOri/VR_SCALE, fragRayDir);\n    fragColor.rgb = mix(getBackground(fragRayDir), col.rgb, col.a);\n    // tonemapping\n    fragColor.rgb = fragColor.rgb / (fragColor.rgb + vec3(1));\n    // gamma correction\n    fragColor.rgb = pow(fragColor.rgb, vec3(1.0/2.2));\n    // add noise\n    vec3 rnd = hash33(vec3(fragCoord, iFrame*2+1));\n    fragColor.rgb += (rnd-0.5)*0.08;\n    \n    fragColor.a = 1.0;\n}\n\n// main entry point, simulate vr input\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    \n    vec2 uv = fragCoord - iResolution.xy * 0.5;\n    uv /= iResolution.y;\n    \n    vec3 from = vec3(0, 0, -2.0);\n    #ifdef SEGMENT\n    from = vec3(0, 0, -0.5);\n    #endif\n    vec3 dir = normalize(vec3(uv, 1.0));\n    \n    vec2 r = vec2(iTime*0.1, 0.3);\n    \n    if (iMouse.z > 0.25) {\n        r = iMouse.xy - iResolution.xy*0.5;\n        r *= -0.01;\n    }\n    \n    dir.yz *= rot(r.y+0.1);\n    from.yz *= rot(r.y);\n    dir.xz *= rot(r.x);\n    from.xz *= rot(r.x);\n    \n    mainVR(fragColor, fragCoord, from*VR_SCALE, dir);\n    \n    // add some vignetting in non vr\n    vec2 uvv = fragCoord / iResolution.xy * 2.0 - 1.0;\n    float vigD = dot(uvv, uvv);\n    fragColor.rgb = mix(fragColor.rgb, vec3(0), vigD*0.3);\n    \n}\n", "image_inputs": [{"id": "4sf3Rr", "previewfilepath": "/media/ap/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png", "channel": 0, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttlGR4.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[437, 463, 494, 494, 585], [587, 623, 665, 665, 768], [770, 793, 836, 836, 935], [937, 963, 988, 988, 1336], [1338, 1359, 1383, 1383, 1507], [1509, 1537, 1559, 1559, 1656], [1658, 1677, 1700, 1700, 1809], [1811, 1825, 1849, 1849, 1884], [1886, 1897, 1989, 1989, 3404], [3406, 3467, 3548, 3548, 5872], [7988, 8058, 8096, 8096, 8273], [8298, 8298, 8354, 8354, 8605], [8607, 8607, 8663, 8663, 8813], [8815, 8815, 8877, 8877, 9091], [9093, 9093, 9139, 9139, 9196], [9198, 9198, 9386, 9386, 10307], [10332, 10362, 10529, 10529, 10792], [10794, 10818, 10904, 10904, 11483], [11485, 11506, 11563, 11603, 12547], [12549, 12567, 12602, 12628, 12892], [12894, 12946, 13009, 13038, 14454], [14456, 14474, 14568, 14614, 15048], [15050, 15089, 15146, 15146, 15866]], "test": "error"}
{"id": "ttlGRn", "name": "superegg 3d", "author": "suitzero", "description": " Piet Hein.. super egg.. 3d\nI'm trying to figure out why the egg turned into a fog like looking. ", "tags": ["hello"], "likes": 6, "viewed": 182, "published": "Public", "date": "1555547332", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// mostly copied from this shadertoy code https://www.shadertoy.com/view/Mdl3Rr\n\n\n#define BRUTE_FORCE_AA 1\n\n#if BRUTE_FORCE_AA\n#define AA_SAMPLES 4\n#define INSCATTER_STEPS 30\n#define NOISE_AMPLITUDE 0.1\n#else\n#define INSCATTER_STEPS 50\n#define NOISE_AMPLITUDE 0.05\n#endif\n\n#define INF 1.0e38\n#define HIT(x) hit = min(hit, x)\n\n// Shadow rays can make things faster if there are big occluders\n// but kinda ugly with no #include statement\n//#define HIT(x) if (x < INF) return 0.0\n\nmat3 m = mat3( 0.00,  0.80,  0.60,\n\t\t\t  -0.80,  0.36, -0.48,\n\t\t\t  -0.60, -0.48,  0.64 );\n\nfloat hash (float n)\n{\n\treturn fract(sin(n)*43758.5453);\n}\n\nfloat noise (in vec3 x)\n{\n\tvec3 p = floor(x);\n\tvec3 f = fract(x);\n\n\tf = f*f*(3.0-2.0*f);\n\n\tfloat n = p.x + p.y*57.0 + 113.0*p.z;\n\n\tfloat res = mix(mix(mix( hash(n+  0.0), hash(n+  1.0),f.x),\n\t\t\t\t\t\tmix( hash(n+ 57.0), hash(n+ 58.0),f.x),f.y),\n\t\t\t\t\tmix(mix( hash(n+113.0), hash(n+114.0),f.x),\n\t\t\t\t\t\tmix( hash(n+170.0), hash(n+171.0),f.x),f.y),f.z);\n\treturn res;\n}\n\nfloat fbm (vec3 p)\n{\n\tfloat f;\n\tf  = 0.5000*noise( p ); p = m*p*2.02;\n\tf += 0.2500*noise( p ); p = m*p*2.03;\n\tf += 0.1250*noise( p ); //p = m*p*2.01;\n\t//f += 0.0625*noise( p );\n\treturn f;\n}\n\nfloat box(vec3 org, vec3 dir, vec3 size, out float far)\n{\n\t// compute intersection of ray with all six bbox planes\n\tvec3 invR = 1.0 / dir;\n\tvec3 tbot = invR * (-0.5*size - org);\n\tvec3 ttop = invR * (0.5*size - org);\n\t\n\t// re-order intersections to find smallest and largest on each axis\n\tvec3 tmin = min (ttop, tbot);\n\tvec3 tmax = max (ttop, tbot);\n\t\n\t// find the largest tmin and the smallest tmax\n\tvec2 t0 = max (tmin.xx, tmin.yz);\n\tfloat near;\n\tnear = max (t0.x, t0.y);\n\tt0 = min (tmax.xx, tmax.yz);\n\tfar = min (t0.x, t0.y);\n\n\t// check for hit\n\treturn near < far && far > 0.0 ? near : INF;\n}\n\nfloat box(vec3 org, vec3 dir, vec3 size)\n{\n\tfloat far;\n\treturn box(org, dir, size, far);\n}\n\nfloat impulse (float k, float x)\n{\n\tfloat h = k * x;\n\treturn h * exp (1.0 - h);\n}\n\nfloat impulse2 (float k0, float k1, float x)\n{\n\tfloat k = k0;\n\tif (x > 1.0/k0)\n\t{\n\t\tx += 1.0/k1 - 1.0/k0;\n\t\tk = k1;\n\t}\n\tfloat h = k * x;\n\treturn h * exp (1.0 - h);\n}\n\nfloat cubicPulse (float w, float x)\n{\n\tx = abs (x);\n\tif (x > w)\n\t\treturn 0.0;\n\tx /= w;\n\treturn 1.0 - x * x * (3.0 - 2.0 * x);\n}\n\nmat2 rot(float angle)\n{\n\tfloat c = cos(angle);\n\tfloat s = sin(angle);\n\treturn mat2(c,-s,s,c);\n}\n\n// rd doesn't have to be normalized\nfloat sphere(vec3 ro, vec3 rd, float r)\n{\n\tfloat b = dot(ro, rd);\n\tfloat c = dot(ro, ro) - r * r;\n\tfloat a = dot(rd, rd);\n\t// Exit if râ€™s origin outside s (c > 0) and r pointing away from s (b > 0)\n\tif (c > 0.0 && b > 0.0)\n\t\treturn INF;\n\tfloat discr = b*b - a*c;\n\t// A negative discriminant corresponds to ray missing sphere\n\tif (discr < 0.0)\n\t\treturn INF;\n\t// Ray now found to intersect sphere, compute smallest t value of intersection\n\tfloat t = - b - sqrt(discr);\n\tt /= a;\n\t// If t is negative, ray started inside sphere so clamp t to zero\n\tt = max(0.0, t);\n\treturn t;\n}\n\nfloat sdsuperegg( in vec3 p, in float r )\n{\n    float k = 2.5;\n    \n     return pow(abs(p.z)/5.,k) + pow(abs(p.x)/5.,k) + pow(abs(p.y)/6.,k)-pow(r,k);\n}\n\nfloat superegg(vec3 ro, vec3 rd, float r)\n{\n    float far;\n\t\n    float t = 0.0;\n\tfloat hit = -1.0;\n\tfor(int i=0; i < 24; i++)\n\t{\n\t\tfloat h = sdsuperegg(ro + rd*t,0.05);\n\t\tif (h < 1e-5)\n\t\t\thit = t;\n\t\tt += h;\n\t}\n    return hit > -1.0 ? hit : INF;\n}\n\nfloat sdCone( vec3 p, vec2 c )\n{\n\t// c must be normalized\n\tfloat q = length(p.xy);\n\treturn dot(c,vec2(q,p.z));\n}\n\nfloat sdPlane (vec3 p, vec4 n)\n{\n\t// n must be normalized\n\treturn dot(p,n.xyz) + n.w;\n}\n\nfloat sdSphere (vec3 p, float s)\n{\n\treturn length(p)-s;\n}\n\nfloat roof(vec3 ro, vec3 rd)\n{\n\tfloat hit = -ro.y/rd.y;\n\t// An offset, so that shadow rays starting from the roof don't\n\t// think they're unoccluded\n\tif (hit < -0.1)\n\t\treturn INF;\n\t\n\t// We've hit the plane. If we've hit the window, but\n\t// not the beams, return no hit.\n\tvec2 pos = ro.xz + hit*rd.xz;\n\tvec2 window = abs(pos) - 0.71;\n\t// single beams\n\t//vec2 beams = 0.02 - abs(pos);\n\t// double beams\n\tvec2 beams = 0.015 - abs(mod(pos, 0.54) - 0.27);\n\tif (max(max(window.x, window.y), max(beams.x, beams.y)) < 0.0)\n\t\treturn INF;\n\n\treturn hit;\n}\n\n#define ROOFPOS vec3(0.4,-0.5,0.01)\n\nfloat intersect (vec3 ro, vec3 rd)\n{\n\tfloat hit = INF;\n\t\n\t// stuff\n\tHIT(superegg (ro + vec3(-0.1,0.5+sin(iTime)*0.03,0.35), rd, 0.25));\n    \n\tmat2 m = rot(3.5);\n\tvec3 rorot = ro + vec3(0.4,-0.6,0.3);\n\tvec3 rdrot = rd;\n\trorot.xz = m*rorot.xz;\n\trdrot.xz = m*rdrot.xz;\n\t//HIT(box (rorot, rdrot, vec3(0.35,0.2,0.35)));\n\t\n\t// roof\n\trorot = ro + ROOFPOS;\n\trdrot = rd;\n    m = rot(1.5);\n\t// reuse the previous rotation matrix\n\trorot.xy = m*rorot.xy;\n\trdrot.xy = m*rdrot.xy;\n    m = rot(0.2);\n    rorot.yz = m*rorot.yz;\n\trdrot.yz = m*rdrot.yz;\n\tHIT(roof(rorot, rdrot));\n\t\n\t// floor\n\tfloat floorHit = -(ro.y + 0.95)/rd.y;\n\tif (floorHit < 0.0)\n\t\tfloorHit = INF;\n\tHIT(floorHit);\n\n\treturn hit;\n}\n\nfloat particles (vec3 p)\n{\n\tvec3 pos = p;\n\tpos.y -= iTime*0.02;\n\tfloat n = fbm(20.0*pos);\n\tn = pow(n, 5.0);\n\tfloat brightness = noise(10.3*p);\n\tfloat threshold = 0.26;\n\treturn smoothstep(threshold, threshold + 0.15, n)*brightness*90.0;\n}\n\nfloat transmittance (vec3 p)\n{\n\treturn exp (0.4*p.y);\n}\n\nvec3 inscatter (vec3 ro, vec3 rd, vec3 roLight, vec3 rdLight, vec3 lightDir, float hit, vec2 screenPos)\n{\n\tfloat far;\n\tfloat near = box(roLight + vec3(0.0, 1.0, 0.0), rdLight, vec3(1.5, 3.0, 1.5), far);\n\tif(near == INF || hit < near)\n\t\treturn vec3(0);\n\t\n\tfloat distAlongView = min(hit, far) - near;\n\tfloat oneOverSteps = 1.0/float(INSCATTER_STEPS);\n\tvec3 step = rd*distAlongView*oneOverSteps;\n    vec3 pos = ro + rd*near;\n\tfloat light = 0.0;\n    \n    // add noise to the start position to hide banding\n    // TODO: blue noise\n\tpos += rd*noise(vec3(2.0*screenPos, 0.0))*NOISE_AMPLITUDE;\n\n\tfor(int i = 0; i < INSCATTER_STEPS; i++)\n\t{\n\t\tfloat l = intersect(pos, lightDir) == INF ? 1.0 : 0.0;\n\t\tl *= transmittance(pos);\n\t\tlight += l;\n\t\tlight += particles(pos)*l;\n\t\tpos += step;\n\t}\n\n\tlight *= oneOverSteps * distAlongView;\n\treturn light*vec3(0.6);\n}\n\nvec3 rot (vec3 v, vec3 axis, vec2 sincosangle)\n{\n\treturn v*sincosangle.y + cross(axis, v)*sincosangle.x + axis*(dot(axis, v))*(1.0 - sincosangle.y);\n}\n\nvec3 surface(vec2 fragCoord, vec3 ro, vec3 u, vec3 v, vec3 w, vec3 lightRotAxis, vec2 lightAngleSinCos, vec3 lightDir)\n{\n    vec2 q = fragCoord.xy/iResolution.xy;\n\tvec2 p = -1.0 + 2.0*q;\n\tp.x *= iResolution.x/iResolution.y;\n\n\tvec3 rd = normalize( p.x*u + p.y*v + 1.5*w );\n\n\t// raycast the scene\n\tfloat hit = intersect(ro,rd);\n\tvec3 hitPos = ro + hit * rd;\n\t\n\t// white window\n\tif (hit == INF)\n\t\treturn vec3(1.0);\n\t\n\t// direct light (screw shading!)\n\tvec3 c = vec3(0.0);\n    float shadowBias = 1.0e-4;\n\tif (intersect(hitPos + lightDir*shadowBias, lightDir) == INF)\n\t\tc = vec3(0.9);\n    \n    lightAngleSinCos.x *= -1.0; // rev angle\n\tvec3 roLight = rot(ro + ROOFPOS, lightRotAxis, lightAngleSinCos);\n\tvec3 rdLight = rot(rd, lightRotAxis, lightAngleSinCos);\n\tc += inscatter(ro, rd, roLight, rdLight, lightDir, hit, fragCoord);\n    \n    // color correction - Sherlock color palette ;)\n\tc.r = smoothstep(0.0, 1.0, c.r + 0.02);\n\tc.g = smoothstep(0.0, 1.0, c.g - 0.1);\n\tc.b = smoothstep(0.0, 1.0, c.g - 0.1);\n    \n    return c;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // camera\n\tvec3 ro = normalize(vec3(1.0,-0.1,0.1));\n\tfloat cameraAngle = iMouse.x/iResolution.x - 0.5;\n\tif(iMouse.z < 0.5)\n\t\tcameraAngle = 0.5*sin(0.1*iTime);\n\tfloat cca = cos(cameraAngle);\n\tfloat sca = sin(cameraAngle);\n\tmat2  m = mat2(cca,-sca,sca,cca);\n\tro = vec3(m*ro.xz,ro.y).xzy;\n\tvec3 w = -ro;\n\tro *= 2.5;\n\tvec3 u = normalize(cross( vec3(0.0,1.0,0.0), w ));\n\tvec3 v = normalize(cross(w,u));\n    \n    // light\n    vec3 lightRotAxis = vec3(0.707,0,0.707); //1,0,1 normalized\n\tvec2 lightAngleSinCos = vec2(sin(0.58), cos(0.58));\n\tvec3 lightDir = rot(vec3(0,1,0), lightRotAxis, lightAngleSinCos);\n    \n#if BRUTE_FORCE_AA\n    float invAA = 1.0 / float(AA_SAMPLES);\n    vec3 c = vec3(0);\n    vec2 offset = vec2(-0.5, -0.5);\n    for (int i=0; i < AA_SAMPLES; i++)\n    {\n        for (int j=0; j < AA_SAMPLES; j++)\n        {\n            c += surface(fragCoord + offset, ro, u, v, w, lightRotAxis, lightAngleSinCos, lightDir);\n            offset.y += invAA;\n        }\n        offset.x += invAA;\n        offset.y = -0.5;\n    }\n    c *= invAA * invAA;\n#else\n    vec3 c = surface(fragCoord, ro, u, v, w, lightRotAxis, lightAngleSinCos, lightDir);\n#endif\n    \n\tfragColor = vec4(c, 0.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttlGRn.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[568, 568, 590, 590, 626], [628, 628, 653, 653, 989], [991, 991, 1011, 1011, 1180], [1182, 1182, 1239, 1296, 1776], [1778, 1778, 1820, 1820, 1868], [1870, 1870, 1904, 1904, 1951], [1953, 1953, 1999, 1999, 2118], [2120, 2120, 2157, 2157, 2247], [2249, 2249, 2272, 2272, 2344], [2346, 2382, 2423, 2423, 2962], [2964, 2964, 3007, 3007, 3116], [3118, 3118, 3161, 3161, 3364], [3366, 3366, 3398, 3423, 3478], [3480, 3480, 3512, 3537, 3567], [3569, 3569, 3603, 3603, 3626], [3628, 3628, 3658, 3658, 4171], [4210, 4210, 4246, 4246, 4893], [4895, 4895, 4921, 4921, 5132], [5134, 5134, 5164, 5164, 5189], [5191, 5191, 5296, 5296, 6035], [6037, 6037, 6085, 6085, 6187], [6189, 6189, 6309, 6309, 7210], [7212, 7212, 7269, 7283, 8455]], "test": "ok"}
{"id": "ttlGW7", "name": "Handgun", "author": "codebro", "description": "Learning how raymarching works in GLSL lead me to create this handgun model.", "tags": ["raymarch", "handgun"], "likes": 5, "viewed": 73, "published": "Public", "date": "1556568140", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const float SIZE = 1.0;\nconst float MINIMUM_HIT_DISTANCE = 0.001;\nconst float MAXIMUM_TRACE_DISTANCE = 1000.0;\nconst int NUMBER_OF_STEPS = 100;\nconst float PI = 3.14159265359;\n\nmat3 rotateY(float rad) {\n    float c = cos(rad);\n    float s = sin(rad);\n    return mat3(\n        c, 0.0, -s,\n        0.0, 1.0, 0.0,\n        s, 0.0, c\n    );\n}\n\nmat3 rotateX(float rad) {\n    float c = cos(rad);\n    float s = sin(rad);\n    return mat3(\n        1.0, 0.0, 0.0,\n        0.0, c, s,\n        0.0, -s, c\n    );\n}\n\nmat3 rotateZ(float rad) {\n    float c = cos(rad);\n    float s = sin(rad);\n    return mat3(\n        c, s, 0.0,\n        -s, c, 0.0,\n        0.0, 0.0, 1.0\n    );\n}\n\nmat2 rotationMatrix2d(float time) { // matrix representation of a complex number can be used to rotate 2d vectors\n  return mat2(cos(time), sin(time), -sin(time), cos(time));\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return length(max(d,0.0))\n         + min(max(d.x,max(d.y,d.z)),0.0); // remove this line for an only partially signed sdf\n}\n\nfloat sdRoundBox( vec3 p, vec3 b, float r ) {\n  vec3 d = abs(p) - b;\n  return length(max(d,0.0)) - r\n         + min(max(d.x,max(d.y,d.z)),0.0); // remove this line for an only partially signed sdf\n}\n\nfloat sdTriPrism( vec3 p, vec2 h, float narrow ) {\n    vec3 q = abs(p);\n    return max(q.z-h.y,max(q.x*0.866025+p.y*narrow,-p.y)-h.x*0.5);\n}\n\nfloat sdPlane( vec3 p, vec4 n )\n{\n  // n must be normalized\n  return dot(p,n.xyz) + n.w;\n}\n\nfloat sdCappedCylinder( vec3 p, vec2 h ) {\n  vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat smoothMin(float dstA, float dstB, float k) {\n    float h = max(k - abs(dstA - dstB), 0.0) / k;\n    return min(dstA, dstB) - h * h * h * k * 1.0 / 6.0;\n}\n\nfloat opOnion( in float sdf, in float thickness ) {\n    return abs(sdf)-thickness;\n}\n\nfloat mapTheWorld(in vec3 p) {\n    float displacement = sin(5.0 * p.x) * cos(5.0 * p.y) * sin(5.0 * p.z) * 0.25;\n\n    float barrel = sdRoundBox(p + vec3(0.0, -0.5, 0.0), vec3(0.1, 0.1, 1.0), 0.06);\n\n    vec3 barrelTipPos = rotateX(PI * 0.5) * p + vec3(0.0, -1.15, -0.55);\n    float barrelTipInner = sdCappedCylinder(barrelTipPos, vec2(0.0675, 2.0));\n    float tri = sdTriPrism(rotateZ(PI * 0.25) * rotateY(PI * 0.5) * p + vec3(-0.28, -1.1, 0.0), vec2(0.28, 0.28), 0.5);\n\n    float x = sdRoundBox(p + vec3(0.0,-0.2,-0.24), vec3(0.01,0.1,0.1), 0.01);\n\n    barrel = max(barrel, -tri);\n    barrel = max(barrel, -barrelTipInner);\n    barrel = min(barrel, x);\n\n    vec3 handlePos = rotateX(PI * 0.04) * p + vec3(0.0, 0.0, -0.6);\n    float handle = sdRoundBox(handlePos, vec3(0.1, 0.5, 0.25), 0.05);\n\n    float trigger = sdRoundBox(p + vec3(0.0, -0.3, -0.1), vec3(0.05, 0.2, 0.2), 0.025);\n    float triggerHole = sdRoundBox(p + vec3(0.0, -0.3, -0.1), vec3(0.1, 0.14, 0.14), 0.025);\n\n    trigger = max(trigger, -triggerHole);\n\n    float sight = sdTriPrism(p + vec3(0.0, -0.65, 0.65), vec2(0.01, 0.4), 0.1);\n\n    return min(sight, smoothMin(barrel, min(handle, trigger), 0.2));\n}\n\nvec3 calculateNormal(in vec3 currentPosition) {\n    const vec3 small_step = vec3(0.001, 0.0, 0.0);\n\n    float gradient_x = mapTheWorld(currentPosition + small_step.xyy) - mapTheWorld(currentPosition - small_step.xyy);\n    float gradient_y = mapTheWorld(currentPosition + small_step.yxy) - mapTheWorld(currentPosition - small_step.yxy);\n    float gradient_z = mapTheWorld(currentPosition + small_step.yyx) - mapTheWorld(currentPosition - small_step.yyx);\n\n    vec3 normal = vec3(gradient_x, gradient_y, gradient_z);\n\n    return normalize(normal);\n}\n\nvec3 remap(vec3 col) { // map range -1 to 1, to, range 0 to 1\n  return col * 0.5 + 0.5;\n}\n\nmat2 rotation() {\n    return rotationMatrix2d(iTime * 0.5);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n  vec3 coord = vec3((fragCoord - 0.5 * iResolution.xy) / iResolution.y, 0.0); // adjusting for the viewport size\n\n  vec3 ro = vec3(0, 1, -2), // where the camera is sitting\n        look_at = vec3(0); // where the camera is pointing\n\n  ro.xz *= rotation();\n\n  float zoom = 0.8; // camera zoom\n  vec3 f = normalize(look_at - ro), // forward vector\n    r = normalize(cross(vec3(0, 1, 0), f)); // right vector\n  vec3 u = cross(f, r), // up vector\n    c = ro + f * zoom, // center point of the virtual screen (virtual screen is a screen that the objects are painted onto and sits between the camera and the objects)\n    i = c + coord.x * r + coord.y * u, // ray intersection point with our virtual screen\n    rd = normalize(i - ro); // ray direction\n  float dS, dO = 0.0; // distance to surface and distance to origin;\n  vec3 currentPosition; // point along the ray (from which we emit our spheres);\n  vec3 col = vec3(0); // empty canvas\n\n  for(int i = 0; i < 100; i++) { // ray marcher\n    currentPosition = ro + rd * dO; // the point coord is the ray origin plus the distance from the origin times ray direction\n    dS = mapTheWorld(currentPosition);\n    if (dS < MINIMUM_HIT_DISTANCE) {\n      vec3 normal = calculateNormal(currentPosition);\n      // For now, hard-code the light's position in our scene\n      vec3 lightPosition = vec3(2.0, -5.0, 3.0);\n      lightPosition.xz *= rotation();\n      // Calculate the unit direction vector that points from\n      // the point of intersection to the light source\n      vec3 direction_to_light = normalize(currentPosition - lightPosition);\n  \n      float diffuse_intensity = max(0.0, dot(normal, direction_to_light));\n  \n      col = vec3(0.5, 0.5, 0.5) * diffuse_intensity;\n      break;\n    }; // register a hit - one of our spheres can register a hit on our object because distance of surface is tiny\n    if (dO > MAXIMUM_TRACE_DISTANCE) break; // maximum distance that our camera will pick up\n    dO += dS; // This is stepping to the next point coord to emit another sphere\n  }\n    \t\t\n  fragColor = vec4(col, 1.0); // our final color\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttlGW7.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[177, 177, 202, 202, 337], [339, 339, 364, 364, 499], [501, 501, 526, 526, 661], [663, 663, 698, 776, 838], [840, 840, 871, 871, 1020], [1022, 1022, 1067, 1067, 1220], [1222, 1222, 1272, 1272, 1362], [1364, 1364, 1397, 1423, 1454], [1456, 1456, 1498, 1498, 1597], [1599, 1599, 1649, 1649, 1757], [1759, 1759, 1810, 1810, 1843], [1845, 1845, 1875, 1875, 3015], [3017, 3017, 3064, 3064, 3564], [3566, 3566, 3588, 3627, 3655], [3657, 3657, 3674, 3674, 3718], [3720, 3720, 3777, 3777, 5856]], "test": "ok"}
{"id": "tts3DM", "name": "SoC Chain Reaction parallelized", "author": "ollj", "description": "i like SoC\ni like pMod\ni like kerning\n\ni like dont like global vars\n\ni parallelized and sqrt()deferred DE(Link()) of\nhttps://www.shadertoy.com/view/wtX3W7\ninto this shader", "tags": ["soc", "pmod", "kerning"], "likes": 11, "viewed": 464, "published": "Public API", "date": "1556563487", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//self  : https://www.shadertoy.com/view/tts3DM\n//parent: https://www.shadertoy.com/view/wtX3W7\n// Chain Reaction by eiffie\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n#define tim time*2.0\n\n#define pixelSize 2.0/size.y\n\n#define REFLECTIONS\n#define SHADOWS\n//#define TEXTURECUBE\n//#define CIRCLE_LINKS\n#define TWISTS 4.5\n\n// V2 added shadows and made it compile on my older machine by unrolling the code\n#define time iTime\n#define size iResolution\n#define TAO 6.2831853\n\nconst float aperture=0.1,shadowCone=0.5,reflectionCone=0.5,pdt=10.0/TAO,tdp=TAO/10.0;\nconst vec3 mcol=vec3(.6,1.6,2.0);\n\nvec2 Rot2D(vec2 v,float a){return cos(a)*v+sin(a)*vec2(v.y,-v.x);}\n//below is the dual of the above\nvec4 Rot2D(vec4 v,vec2 a){return vec4(Rot2D(v.xy,a.y),Rot2D(v.zw,a.x));}\n\n#define dd(a) dot(a,a)\n//below is the dual of the above\n#define ddd(a) vec2(dd(a.xy),dd(a.zw))\n\n//so i tried to parallelized the Link() function of\n//https://www.shadertoy.com/view/wtX3W7\n//i suceeded, but the result does not look elegant in source code.\n#ifdef CIRCLE_LINKS\n #define ass .0225\n#else\n #define ass .02\n#endif\nvec2 Link(vec3 p, vec2 a\n){vec4 q=vec4(0)\n ;vec4 f=Rot2D(p.xyxy,a)\n ;f.yw+=1.+sin(a.yx+tim)*.2\n ;q.xy=f.zw\n ;p.x=f.x //this started as origami foldAndCut , and ended up as used toilet paper.\n ;a=a*TWISTS+tim\n ;vec4 g=Rot2D(vec4(vec2(f.w,p.z),vec2(f.y,p.z)),a.yx)\n#ifdef CIRCLE_LINKS  \n ;q.yz=g.xy\n ;p.yz=g.zw\n ;return vec2(dd(vec2(length(vec2(p.x,p.y))-ass,p.z))\n             ,dd(vec2(length(q.xy)-ass,q.z)));}\n#else\n ;f=vec4(p.x,g.z,q.x,g.x)//look at this crumbled piece of paper. its an oregami unicorn!\n ;return ddd(vec4(\n     sqrt(ddd(max(abs(f)-vec2(.125,.025).xyxy,0.)))-.1 \n     ,g.wy).xzyw);}\n#endif \n\nfloat DE(in vec3 p\n){vec2 i=vec2(.5,0)\n ;i=Link(p,(floor(atan(p.x,-p.y)*pdt+i)+i.yx)*tdp)\n ;return sqrt(min(i.y,i.x))-ass;}\n\n/*\nvec2 Link2(vec3 p, vec2 a\n){vec3 q=vec3(0)\n ;vec4 f=p.xyxy\n ;f=Rot2D(f,a)\n ;f.yw+=1.+sin(a.yx+tim)*.2\n ;q.xy=f.zw\n ;p.x=f.x\n ;a=a*TWISTS+tim\n ;vec4 g=Rot2D(vec4(vec2(f.w,p.z),vec2(f.y,p.z)),a.yx)\n ;q.yz=g.xy\n ;p.yz=g.zw\n#ifdef CIRCLE_LINKS  \n ;return vec2(dd(vec2(length(vec2(p.x,p.y))-ass,p.z))\n             ,dd(vec2(length(q.xy)-ass,q.z)));}\n#else\n ;p.xy=sqrt(ddd(max(abs(vec4(p.x,p.y,q.x,q.y))-vec2(.125,.025).xyxy,0.)))-.1\n ;return ddd(vec4(p.x,p.z,p.y,q.z));}\n#endif \n*/\n\n\nfloat CircleOfConfusion(float t,float focalDistance){//calculates the radius of the circle of confusion at length t\n return max(abs(focalDistance-t)*aperture,pixelSize*(1.0+t));\n}\nmat3 lookat(vec3 fw,vec3 up){\n fw=normalize(fw);vec3 rt=normalize(cross(fw,up));return mat3(rt,cross(rt,fw),fw);\n}\nfloat linstep(float a, float b, float t){return clamp((t-a)/(b-a),0.,1.);}// i got this from knighty and/or darkbeam\n//random seed and generator\nfloat randSeed;\nfloat randStep(){//a simple pseudo random number generator based on iq's hash\n return  (0.8+0.2*fract(sin(++randSeed)*4375.5453123));\n}\n#ifdef SHADOWS\nfloat FuzzyShadow(vec3 ro, vec3 rd, float lightDist, float coneGrad, float rCoC){\n float t=0.0,d,s=1.0,r;\n ro+=rd*rCoC*2.0;\n for(int i=0;i<4;i++){\n  r=rCoC+t*coneGrad;d=DE(ro+rd*t)+r*0.5;s*=linstep(-r,r,d);t+=abs(d)*randStep();\n }\n return clamp(s,0.0,1.0);\n}\n#endif\nvec3 Background(vec3 rd,vec3 Llll){\n#ifdef TEXTURECUBE\n return textureCube(iChannel0,rd).rgb;\n#else\n float s=max(0.0,dot(rd,Llll));\n return vec3(.4,.5,.75)*(s+pow(s,10.0))+rd*0.05;\n#endif\n}\n#ifdef REFLECTIONS\nvec3 FuzzyReflection(vec3 ro, vec3 rd, float coneGrad, float rCoC,vec3 Llll){\n float t=0.0,d,r;\n ro+=rd*rCoC*2.0;\n vec4 col=vec4(0.0);\n for(int i=0;i<3;i++){//had to unroll this before to get it to compile correctly?!?!\n  r=rCoC+t*coneGrad;d=DE(ro);\n  if(d<r){\n   vec2 v=vec2(r*0.1,0.0);//use normal deltas based on CoC radius\n   vec3 N=normalize(vec3(DE(ro+v.xyy)-d,DE(ro+v.yxy)-d,DE(ro+v.yyx)-d));\n   if(N!=N)N=-rd;\n   vec3 scol=mcol*(0.1+Background(reflect(rd,N),Llll))*(0.75+0.5*dot(N,Llll));\n   float alpha=(1.0-col.w)* linstep(-r,r,-d);\n   col+=vec4(scol*alpha,alpha);\n  }\n  d=max(d,r*0.5)*randStep();ro+=d*rd;t+=d;\n }\n return col.rgb+Background(rd,Llll)*(1.0-clamp(col.w,0.0,1.0));\n}\n#endif\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n randSeed=fract(cos((fragCoord.x+fragCoord.y*117.0+time*10.0)*473.7192451));\n vec3 ro=vec3(0,0,-2.75);\n vec3 rd=lookat(vec3(cos(tim)*0.2,-sin(tim)*.2,0.)-ro,vec3(0,1,0))*normalize(vec3((2.0*fragCoord.xy-size.xy)/size.y,2.0));\n float focalDistance=length(ro);\n vec3 Llll=normalize(vec3(0.5,0.6,0.4));\n vec4 col=vec4(0);//color accumulator\n float t=2.5;//distance traveled\n ro+=rd*t;//move close to object\n for(int i=0;i<15;i++){//march loop\n  if(col.w>0.9 || t>4.0)continue;//bail if we hit a surface or go out of bounds\n  float rCoC=CircleOfConfusion(t,focalDistance);//calc the radius of CoC\n  float d=DE(ro);\n  if(d<rCoC){//if we are inside add its contribution\n   vec2 v=vec2(rCoC*.1,.0);//use normal deltas based on CoC radius\n   vec3 N=normalize(vec3(-d+DE(ro+v.xyy),-d+DE(ro+v.yxy),-d+DE(ro+v.yyx)));\n   if(N!=N)N=-rd;\n   vec3 refl=reflect(rd,N);\n   vec3 scol=mcol*(0.1+Background(refl,Llll));\n#ifdef SHADOWS\n   scol*=FuzzyShadow(ro,Llll,3.0,shadowCone,rCoC);\n#else\n   scol*=(0.75+0.5*dot(N,Llll));\n#endif\n#ifdef REFLECTIONS\n   scol+=0.5*FuzzyReflection(ro,refl,reflectionCone,rCoC,Llll);\n#endif\n   float alpha=(1.0-col.w)*linstep(-rCoC,rCoC,-d);//calculate the mix like cloud density\n   col+=vec4(scol*alpha,alpha);//blend in the new color \n  }\n  d=max(d,pixelSize)*randStep();//add in noise to reduce banding and create fuzz\n  ro+=d*rd;//march\n  t+=d;\n }//mix in background color\n col.rgb=mix(Background(rd,Llll),col.rgb,clamp(col.w,0.0,1.0));\n\n fragColor=vec4(clamp(col.rgb,0.,1.),1);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tts3DM.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[635, 635, 662, 662, 701], [702, 735, 761, 761, 807]], "test": "timeout"}
{"id": "tts3z7", "name": "Neon Panther", "author": "el_visio", "description": "The disco effect", "tags": ["plasma"], "likes": 2, "viewed": 130, "published": "Public", "date": "1555964473", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    vec3 col = 0.5 + 0.25*(cos(uv.yxy*15.0+iTime+uv.xyx*vec3(-3,-7,11)*7.0) + cos(uv.yxy*(-3.0)+iTime*vec3(-11,5,9)*0.3));\n    float a = col.x*col.y*col.z;\n    vec3 b = (1.0-uv.y) * vec3(1.0,0.5,0.7) + uv.y * vec3(0.4,0.8,1.0);\n    \n    fragColor = vec4(b * (1.0-(col * a * 5.0)),1.0);\n\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tts3z7.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 107, 437]], "test": "ok"}
{"id": "tts3zM", "name": "adfasdfasdf", "author": "lennyjpg", "description": "asdfasdfasdf", "tags": ["asdfasdfa"], "likes": 1, "viewed": 263, "published": "Public API", "date": "1555960520", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord/iResolution.x)*2.0;\n    uv.x-=(iResolution.y/iResolution.x);\n   uv=abs(uv-.5) - iTime * .02; \n    if(iMouse.z>0.)uv.y += uv.x ;     \n    float s = 0.05 + (sin(iTime*.05)+1.)*0.1;\n    float k = mod(uv.x,s);\n    fragColor = vec4(smoothstep( k*.98,k, abs(mod(uv.y,s)) ));\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tts3zM.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 353]], "test": "ok"}
{"id": "tts3zr", "name": "Desert phenom.", "author": "gyabo", "description": "I saw desert on dreaming. My brain got the hazy...", "tags": ["raymarching"], "likes": 3, "viewed": 92, "published": "Public", "date": "1555543714", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n#define resolution iResolution\n#define time iTime\n\n\nconst float FR = 0.2;\nconst float FRS = FR * 123.0;\n\nfloat map(vec3 p) {\n\tfloat t = 10.0 + dot(p, vec3(0, 1, 0)) + sin(p.x * FR + sin(p.z * 0.02) * 50.1) + sin(p.z * FR);\n\tfloat tu = 5000.0 + dot(p, vec3(0, -1, 0));\n\tt = min(t, tu);\n\tt = min(t, length(p + vec3(4200, -4000.0, -5000.0)) - 1500.0);\n\tt = min(t, length(p + vec3(-7000, -3500.0, -7000.0)) - 150.0);\n\treturn t;\n}\n\nvec3 getnor(vec3 p) {\n\tvec2 d = vec2(0.001, 0.0);\n\tfloat t = map(p);\n\treturn normalize(vec3(\n\t\tt - map(p + d.xyy),\n\t\tt - map(p + d.yxy),\n\t\tt - map(p + d.yyx)));\n}\n\nfloat rand(float n){return fract(sin(n) * 43758.5453123);}\n\nvec2 rot(vec2 p, float a) {\n    return vec2(\n        cos(a) * p.x - sin(a) * p.y,\n        sin(a) * p.x + cos(a) * p.y);\n}\n\nvec4 getcolor(vec2 uv, vec2 a) {\n\tvec3 dir = normalize(vec3(uv + a, 1.0));\n    dir.yz = rot(dir.yz, 0.25 * (cos(0.15 * time)));\n    \n\tvec3 pos = vec3(5, 10, sin(time) + 50.0 + rand(uv.x + dir.z * FRS) * rand(uv.y + dir.z * FRS));\n\tfloat t = 0.0;\n\tfor(int i = 0; i < 100; i++) {\n\t    float k = map(dir * t + pos);\n\t    if(k < 0.1) break;\n\t\tt += k;\n\t}\n\tvec3 ip = dir * t + pos;\n\tvec3 N = getnor(ip);\n\tvec3 col = vec3(0.0);\n\tconst vec3 cnear = vec3(2.0, 1.2, 0.5);\n\tconst vec3 cfar = cnear.zyx;\n\tcol += mix(cfar, cnear, min(1.0, t));\n\tcol *= max(0.025, dot(normalize(vec3(2,-0.5,0.2)), N)) * vec3(1.5, 0.7, 0.8);\n\tcol += (cfar * 0.1) * sqrt(t) * 0.04;\n\tcol = pow(col, vec3(1.0 / 2.2));\n\treturn vec4(col, 1.0);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec4 col = vec4(0.0);\n    vec2 uv = ( 2.0 * fragCoord.xy - resolution.xy ) / min(resolution.x, resolution.y);\n    vec2 a = vec2(0.0125 * length(uv * 0.5), 0.0);\n    col += getcolor(uv, vec2(a.xy));\n    col += getcolor(uv, vec2(a.yx));\n    col += getcolor(uv, vec2(-a.xy));\n    col += getcolor(uv, vec2(-a.yx));\n    col /= vec4(4.0);\n    fragColor = col;\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tts3zr.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[106, 106, 125, 125, 426], [428, 428, 449, 449, 590], [592, 592, 612, 612, 650], [652, 652, 679, 679, 773], [775, 775, 807, 807, 1483], [1486, 1486, 1543, 1543, 1903]], "test": "timeout"}
{"id": "ttsGRN", "name": "Mandelbrot constructing Art?", "author": "himmel", "description": "Could you call that art?\nAnd isn't the construction interesting", "tags": ["mandelbrotset"], "likes": 1, "viewed": 51, "published": "Public", "date": "1555801583", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    float oe = 1.0;\n    float ue = -20.0;\n    float sp = 0.5;\n  \tfloat b = abs(mod(iTime*sp, (oe-ue)*2.0)-(oe-ue))+ue;\n    float a = pow(2.0,-b);\n    \n    float x = (uv.x - 0.5);\n    float y = (uv.y - 0.5) * (iResolution.y/iResolution.x);\n    x = x + -1.5; //* a;\n    y += 0.0;// * a;\n    \n    \n    vec2 po = vec2(x,y);\n    \n    float co = 0.0;\n    vec2 n = vec2(0.0,0.0);\n    while(n.y < iTime && co < iTime){\n    \tn = vec2(n.x*n.x - n.y*n.y, 2.*n.x*n.y) + po; //* 1.0/a;\n        co = co + 1.0;\n    }\n    \n    \n    if (n.y < iTime ){\n    \tvec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n        fragColor = vec4(col,1.0);\n    }else{\n    // Time varying pixel color\n    \n        \n        fragColor = vec4(co/100.0,co/100.0,co/100.0,1.0);\n\n\n        }\n    \n    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttsGRN.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 107, 914]], "test": "ok"}
{"id": "ttsGz8", "name": "Polar Coordinates Experiments", "author": "toridango", "description": "Experiments with polar coordinates", "tags": ["polar"], "likes": 0, "viewed": 36, "published": "Public", "date": "1556295614", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n#define EPS 0.01\n\n// Imperial Japan with rotation\n/*\nvec2 uv = (fragCoord - 0.1 * iResolution.xy) / iResolution.y;\nvec2 pol = vec2(atan(uv.y, uv.x), length(uv));\nvec3 col = vec3(iTime*sin(pol.y), cos(pol.y), tan(2.0*iTime+pol.x*iTime*-0.01));\nfragColor = vec4(col,1.0);\n*/\n\n// Sakura\n/*\nvec2 uv = (fragCoord.xy - 0.5 * iResolution.xy) / iResolution.y;\nvec2 pol = vec2(atan(uv.y, uv.x), length(uv));\npol = vec2(pol.x/6.2831 + 0.5, pol.y);\nfloat m = min(fract(pol.x*5.0), fract(1.0 - pol.x*5.0));\nfloat f = smoothstep(0.0, 0.1, m*0.3 + 0.2 - pol.y);\nfragColor = vec4(0.8*f, 0.5*f, 0.7*f, 1.0);\n*/\n\n// Hurricane-ish\n/*\nvec2 uv = (fragCoord.xy - 0.5 * iResolution.xy) / iResolution.y;\nvec2 pol = vec2(atan(uv.y, uv.x), length(uv));\npol = vec2(pol.x/5.24 - 0.1*iTime + pol.y, pol.y);\nfloat m = min(fract(pol.x*5.0), fract(1.0 - pol.x*5.0));\nfloat f = smoothstep(0.0, 0.1, m*0.3 + 0.2 - pol.y);\nfragColor = vec4(f);\n*/\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from -0.5 to 0.5)\n    vec2 uv = (fragCoord.xy - 0.5 * iResolution.xy) / iResolution.y;\n    // Polar coordinates \n    vec2 pol = vec2(atan(uv.y, uv.x), length(uv));\n\t//vec3 col = vec3(iTime+sin(pol.y), cos(pol.y), sin(2.0*iTime+pol.x*iTime*-0.015)/1.2);\n\tvec3 col = vec3(iTime+sin(pol.y), cos(pol.y), sin(2.0*iTime+pol.x*iTime*-0.015)/1.6);\n    \n    pol = vec2(pol.x/5.24 - 0.1*iTime + pol.y, pol.y);\n    \n    float m = min(fract(pol.x*5.0), fract(1.0 - pol.x*5.0));\n    \n    //vec3 col = 0.5 + 0.5*cos(iTime + pol.xyx + vec3(0,2,4));\n    //vec3 col = vec3(sin(pol.y), cos(pol.y), tan(-1.0*iTime+pol.x));\n    \n    float f = smoothstep(0.0, 0.1, m*0.3 + 0.2 - pol.y);\n    // Output to screen\n    fragColor = vec4(f*col, f);\n    //fragColor = vec4(col, 1.0);\n    //fragColor = distance(vec3(0.0), fragColor.xyz) < EPS ? vec4(1.0) : fragColor;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttsGz8.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[917, 917, 974, 1029, 1853]], "test": "ok"}
{"id": "ttX3D7", "name": "SoC with DEL", "author": "eiffie", "description": "Still re-uploading", "tags": ["soc", "del"], "likes": 18, "viewed": 637, "published": "Public API", "date": "1556507665", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// SoC with DEL by eiffie (adding Distance Estimated Light to the Sphere of Confusion renderer)\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n#define time iTime\n#define size iResolution\n\nfloat pixelSize,focalDistance,aperture,fudgeFactor=0.78,shadowCone=0.5;\n\nbool bColoring=false;\nvec3 mcol;\nmat2 rmx;\nconst vec4 p0=vec4(0.0,0.0,4.0,1.0);\nconst vec3 rc=vec3(2.633,0.033,2.133);\nvec2 DE(in vec3 z0){//amazing box by tglad\n vec4 z = vec4(z0,1.0);float r2=10.0;\n for (int n = 0; n < 3; n++) {\n  z.xzy=clamp(z.xyz, -1.0, 1.0) *2.0-z.xyz;\n  z*=2.0/clamp(dot(z.xyz,z.xyz),0.1,1.0);\n  z+=p0;\n  if(n==1)r2=length(z.xyz)/z.w;//distance to light\n  z.xy=z.xy*rmx;\n }\n if(bColoring)mcol+=vec3(0.7,0.6,0.4)+z.xyz*0.2;\n z.xyz=max(abs(z.xyz)-rc,vec3(0.0));\n return vec2((length(z.xyz)-0.1)/z.w,r2);//returns distance to surface and light\n}\n\nfloat CircleOfConfusion(float t){//calculates the radius of the circle of confusion at length t\n return max(abs(focalDistance-t)*aperture,pixelSize*(1.0+t));\n}\nmat3 lookat(vec3 fw,vec3 up){\n fw=normalize(fw);vec3 rt=normalize(cross(fw,normalize(up)));return mat3(rt,cross(rt,fw),fw);\n}\nfloat linstep(float a, float b, float t){return clamp((t-a)/(b-a),0.,1.);}// i got this from knighty and/or darkbeam\n//random seed and generator\nvec2 randv2;\nfloat rand2(){// implementation derived from one found at: lumina.sourceforge.net/Tutorials/Noise.html\n randv2+=vec2(1.0,1.0);\n return fract(sin(dot(randv2 ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nfloat FuzzyShadow(vec3 ro, vec3 rd, float lightDist, float coneGrad, float rCoC){\n float t=0.01,d=1.0,s=1.0;\n for(int i=0;i<4;i++){\n  if(t>lightDist)continue;\n  float r=rCoC+t*coneGrad;//radius of cone\n  d=DE(ro+rd*t).x+r*0.66;\n  s*=linstep(-r,r,d);\n  t+=abs(d)*(0.8+0.2*rand2());\n }\n return clamp(s,0.0,1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n randv2=fract(cos((fragCoord.xy+fragCoord.yx*vec2(100.0,100.0))+vec2(time)*10.0)*1000.0);\n pixelSize=1.0/size.y;\n float tim=time*0.25;//camera, lighting and object setup\n float ct=cos(tim),st=sin(tim);\n rmx=mat2(ct,-st,st,ct);\n float z=cos(tim*0.3)*5.0;\n vec3 ro=vec3(vec2(ct,st)*(abs(z)+0.1)*(1.0+sin(tim*0.1)),z);\n focalDistance=min(length(ro)+0.001,1.0);\n aperture=0.007*focalDistance;\n vec3 rd=lookat(-ro,vec3(0.0,1.0,0.0)-sin(ro)*0.1)*normalize(vec3((2.0*fragCoord.xy-size.xy)/size.y,2.0));\n vec3 lightColor=vec3(1.0,0.5,0.25);\n vec4 col=vec4(0.0);//color accumulator, .w=alpha\n float t=0.0,mld=100.0;//distance traveled, minimum light distance\n for(int i=1;i<72;i++){//march loop\n  if(col.w>0.9 || t>15.0)break;//bail if we hit a surface or go out of bounds\n  float rCoC=CircleOfConfusion(t);//calc the radius of CoC\n  vec2 D=DE(ro);\n  float d=D.x+0.33*rCoC;\n  float lightDist=D.y;//the distance estimate to light\n  mld=min(mld,lightDist);//the minimum light distance along the march\n  if(d<rCoC){//if we are inside the sphere of confusion add its contribution\n   vec3 p=ro-rd*abs(d-rCoC);//back up to border of SoC\n   mcol=vec3(0.0);//clear the color trap\n   bColoring=true;//collecting color samples with normal deltas\n   vec2 v=vec2(rCoC*0.5,0.0);//use normal deltas based on CoC radius\n   vec3 N=normalize(vec3(-DE(p-v.xyy).x+DE(p+v.xyy).x,-DE(p-v.yxy).x+DE(p+v.yxy).x,-DE(p-v.yyx).x+DE(p+v.yyx).x));\n   bColoring=false;\n   if(N!=N)N=-rd;//if no gradient assume facing us\n   v=vec2(lightDist,0.0);//now find the closest light's general direction\n   vec3 L=-normalize(vec3(-DE(p-v.xyy).y+DE(p+v.xyy).y,-DE(p-v.yxy).y+DE(p+v.yxy).y,-DE(p-v.yyx).y+DE(p+v.yyx).y));\n   float lightStrength=1.0/(1.0+lightDist*lightDist*20.0);\n   vec3 scol=mcol*0.2*(0.2+0.4*(1.0+dot(N,L)))*lightStrength;//average material color * diffuse lighting * attenuation\n   scol+=pow(max(0.0,dot(reflect(rd,N),L)),8.0)*lightColor;//specular lighting\n   scol*=FuzzyShadow(p,L,lightDist*0.5,shadowCone,rCoC);//now stop the shadow march at light distance\n   col.rgb+=lightColor/(0.5+mld*mld*5000.0)*(1.0-col.w);//add a bloom around the light\n   mld=100.0;//clear the minimum light distance for the march\n   float alpha=fudgeFactor*(1.0-col.w)*linstep(-rCoC,rCoC,-d);//calculate the mix like cloud density\n   col=vec4(col.rgb+scol*alpha,clamp(col.w+alpha,0.0,1.0));//blend in the new color \n  }//move the minimum of the object and light distance\n  d=abs(fudgeFactor*min(d,lightDist+0.33*rCoC)*(0.8+0.2*rand2()));//add in noise to reduce banding and create fuzz\n  ro+=d*rd;//march\n  t+=d;\n }//mix in background color\n vec3 scol=lightColor/(0.5+mld*mld*5000.0);//add one last light bloom\n col.rgb+=scol*(1.0-col.w);\n\n fragColor = vec4(clamp(col.rgb,0.0,1.0),1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttX3D7.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[421, 421, 441, 463, 867], [869, 869, 902, 964, 1028], [1029, 1029, 1058, 1058, 1154], [1155, 1155, 1196, 1196, 1229], [1313, 1313, 1327, 1415, 1509], [1511, 1511, 1592, 1592, 1822], [1824, 1824, 1881, 1881, 4620]], "test": "ok"}
{"id": "ttX3W7", "name": "Shiny Toy", "author": "eiffie", "description": "Putting back up some old shaders. Increase the Rays variable for a smoother ride.", "tags": ["pathtracing"], "likes": 23, "viewed": 582, "published": "Public API", "date": "1556492880", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Shiny Toy Car by eiffie\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n// V2 Sedan Version: simplified car, added quadcop, bushs and the speed, lighting fix. \n\n// Just putting back some old shaders.\n// I removed this while being poisoned with heavy metals by the illuminati!\n// True story. Who knew the world is actually run by psychopathic pedophiles?\n// If it happens to you: cilantro and get out of 5 eyes controlled countries.\nconst int Rays=3, RaySteps=48, maxBounces=6;//up the Rays value for less fuzz\nconst float fov = 4.5,blurAmount = 0.005,maxDepth=11.0,HitDistance=0.001;\nconst vec3 sunColor=vec3(1.0,0.9,0.8),sunDir=vec3(0.35,0.5,-0.35),skyColor=vec3(0.13,0.14,0.15);\nconst vec2 ve=vec2(0.0001,0.0);\nint obj=0;\nfloat tim;\nmat2 rmx;\n#define tex iChannel0\n#define time iTime*0.5\n#define size iResolution\n\nstruct material {vec3 color;float difExp,spec,specExp;};\n\nfloat smin(float a,float b,float k){return -log(exp(-k*a)+exp(-k*b))/k;}//from iq\n#define TAO 6.283\nvoid Rotate(inout vec2 v, float angle) {v*=mat2(cos(angle),sin(angle),-sin(angle),cos(angle));}\nvoid Kaleido(inout vec2 v,float power){Rotate(v,floor(0.5+atan(v.x,-v.y)*power/TAO)*TAO/power);}\n\nfloat DE(in vec3 p0){//carcar\n p0.z+=tim;\n vec3 p=p0+vec3(0.0,1.24,0.0);\n float r=length(p.yz);\n float d= length(max(vec3(abs(p.x)-0.35,r-1.92,-p.y+1.4),0.0))-0.05;\n d=max(d,p.z-1.0);\n p=p0+vec3(0.0,-0.22,0.39);\n p.xz=abs(p.xz)-vec2(0.5300,0.9600);p.x=abs(p.x);\n r=length(p.yz);\n d=smin(d,length(max(vec3(p.x-0.08,r-0.25,-p.y-0.08),0.0))-0.04,8.0);\n d=max(d,-max(p.x-0.165,r-0.24));\n float d2=length(vec2(max(p.x-0.13,0.0),r-0.2))-0.02;\n float d3=length(vec2(max(p.x-0.11,0.0),r-0.18))-0.02;\n if(p0.z<0.0)p.yz=p.yz*rmx;\n else p.yz=rmx*p.yz;\n Kaleido(p.yz,9.0);\n d3=min(d3,length(max(abs(p.xyz)-vec3(0.07,0.0,0.17),0.0))-0.01);\n d=min(min(p0.y,d),min(d2,d3));\n if(obj<0){\n  if(d==d2)obj=1;\n  else if(d==d3)obj=2;\n  else if(d==p0.y)obj=3;\n  else obj=0;\n }\n return d;\n}\n\nmaterial getMaterial( in vec3 p0, inout vec3 nor )\n{//return material properties\n vec3 dif=vec3(0.0);\n if(obj==0){//body\n  if(abs(p0.y-0.6)>0.1 || abs(p0.x)>0.43 || p0.z+tim<-0.9900)dif=vec3(0.9,0.9,0.4);\n  return material(dif,pow(2.0,10.0),1.0,pow(2.0,14.0));\n }else if(obj==1){//tire\n  return material(dif,4.0,0.75,32.0);\n }else if(obj==2){//rim\n  return material(vec3(0.8),pow(2.0,16.0),1.0,2048.0);\n }else {//ground\n  p0.x+=(sin(p0.z*0.1)+sin(p0.z*0.13))*0.5;\n  if(abs(abs(p0.x-1.0)-2.5)<0.05 || (abs(p0.x-1.0)<0.05 && fract(p0.z*0.25)<0.25))dif=vec3(1.0);\n  else if(abs(p0.x-1.0)<3.25-texture(tex,p0.xz*0.5).r*0.2)dif=vec3(0.25);\n  else dif=vec3(0.6,0.5,0.3);\n  vec3 col=min(10.0,abs(p0.x))*0.01*texture(tex,p0.xz*0.05).rgb;\n  nor=normalize(nor+col);\n  dif+=col;\n  return material(dif,3.0,0.5,1024.0);\n }\n}\n\nfloat DEQCop(vec2 z){\n vec2 p=abs(z)-vec2(2.0);\n p*=rmx;\n float d=max(abs(p.x)-1.5,abs(p.y)-0.1);\n p=abs(z*mat2(0.707,-0.707,0.707,0.707));\n d=min(d,length(p)-1.0);\n d=min(d,max(p.x-3.0,p.y-0.1));\n d=min(d,max(p.x-0.1,p.y-3.0));\n return step(0.0,d)*0.75+0.25;\n}\n\nvec3 getBackground( in vec3 ro, vec3 rd, vec3 qcop  ){\n vec2 pt=vec2(rd.x+rd.z*0.6,rd.y*2.0)/iResolution.xy*64.0;\n if(rd.y<texture(tex,pt).r*0.02)return vec3(0.05,0.1,0.025)+max(0.0,rd.y)*vec3(8.0,4.0,0.0);\n vec3 clouds=texture(tex,pt*0.1).rgb*0.05+texture(tex,pt*0.3).rgb*0.025;\n float t=1.0;\n if(ro!=qcop){\n  t=(qcop.y-ro.y)/rd.y;\n  if(t>0.0){\n   pt=ro.xz+rd.xz*t-qcop.xz;\n   t=DEQCop(pt);\n  }else t=1.0;\n }\n\n return t*(clouds+skyColor+rd*0.05+sunColor*(pow(max(0.0,dot(rd,sunDir)),2.0)*0.5+pow(max(0.0,dot(rd,sunDir)),80.0)));\n}\n\nfloat BBox(vec3 p, vec3 rd, vec3 bs)\n{\n vec3 t0=(-bs-p)/rd,t1=(bs-p)/rd;\n vec3 n=min(t0,t1),f=max(t0,t1);\n float tmin=max(n.x,max(n.y,n.z)),tmax=min(f.x,min(f.y,f.z));\n if(tmin<=tmax) return tmin;\n return maxDepth;\n}\n\n//random seed and generator\nvec2 randv2;\nvec2 rand2(){// implementation derived from one found at: lumina.sourceforge.net/Tutorials/Noise.html\n randv2+=vec2(1.0,1.0);\n return vec2(fract(sin(dot(randv2.xy ,vec2(12.9898,78.233))) * 4375.5453),\n  fract(cos(dot(randv2.xy ,vec2(4.898,7.23))) * 2342.631));\n}\n \nvec3 powDir(vec3 nor, vec3  dir, float power) //modified from syntopia's code\n{//creates a biased random sample without penetrating the surface (approx Schlick's)\n float ddn=max(0.01,abs(dot(dir,nor)));\n vec2 r=rand2()*vec2(TAO,1.0);\n vec3 nr=(ddn<0.99)?nor:((abs(nor.x)<0.5)?vec3(1.0,0.0,0.0):vec3(0.0,1.0,0.0));\n vec3 sdir=normalize(cross(dir,nr));\n r.y=pow(r.y,1.0/power);\n vec3 ro= normalize(sqrt(1.0-r.y*r.y)*(cos(r.x)*sdir + sin(r.x)*cross(dir,sdir)*ddn) + r.y*dir);\n return (dot(ro,nor)<0.0)?reflect(ro,nor):ro;\n}\n\nvec3 scene(vec3 ro, vec3 rd) \n{// find color of scene\n vec3 fcol=vec3(1.333),qcop=ro;\n float d,t=min(ro.y/-rd.y,BBox(ro-vec3(0.0,0.22,-tim-0.33),rd,vec3(0.8,0.51,1.75)));//bounding\n int iHitCount=0;\n for(int i=0; i<RaySteps; i++ ){// march loop\n  if(t>=maxDepth)continue;\n  t+=d=DE(ro+t*rd);//march\n  if(abs(d)<HitDistance*t){//hit\n   obj=-1;//turn on material mapping\n   t+=d=DE(ro+t*rd);//move closer while coloring\n   ro+=rd*t;// advance ray position to hit point\n   vec3 nor = normalize(vec3(-DE(ro-ve.xyy)+DE(ro+ve.xyy),\n    -DE(ro-ve.yxy)+DE(ro+ve.yxy),\n    -DE(ro-ve.yyx)+DE(ro+ve.yyx)));// get the surface normal\n   material m=getMaterial( ro, nor );//and material\n   vec3 refl=reflect(rd,nor);//setting up for a new ray direction and defaulting to a reflection\n   rd=powDir(nor,refl,m.difExp);//redirect the ray\n   m.color+=mix(vec3(-0.2,0.0,0.2),vec3(0.2,0.0,-0.2),0.25+0.75*dot(rd,nor));\n   //the next line calcs the amount of energy left in the ray based on how it bounced (diffuse vs specular) \n   fcol*=mix(m.color,vec3(1.0),min(pow(max(0.0,dot(rd,refl)),m.specExp)*m.spec,1.0));\n   t=max(d*5.0,HitDistance);//hopefully pushs thru the surface\n   if(iHitCount++>maxBounces || dot(fcol,fcol)<0.01)t=maxDepth;\n  }\n }\n if(rd.y<0.0){//one more ground hit for good luck\n  obj=3;\n  t=ro.y/-rd.y;//calc the intersection\n  ro+=rd*t;// advance ray position to hit point\n  vec3 nor = vec3(0.0,1.0,0.0);\n  material m=getMaterial( ro, nor );\n  vec3 refl=reflect(rd,nor);//setting up for a new ray direction and defaulting to a reflection\n  rd=powDir(nor,refl,m.difExp);//redirect the ray\n  m.color+=mix(vec3(-0.2,0.0,0.2),vec3(0.2,0.0,-0.2),0.25+0.75*dot(rd,nor));\n  fcol*=mix(m.color,vec3(1.0),min(pow(max(0.0,dot(rd,refl)),m.specExp)*m.spec,1.0)); \n }\n return fcol*getBackground(ro,rd,qcop);//light the scene\n} \n\nmat3 lookat(vec3 fw,vec3 up){\n fw=normalize(fw);vec3 rt=normalize(cross(fw,normalize(up)));return mat3(rt,cross(rt,fw),fw);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n randv2=fract(cos((fragCoord.xy+fragCoord.yx*vec2(100.0,100.0))+vec2(time)*10.0)*1000.0);\n vec3 clr=vec3(0.0);\n for(int iRay=0;iRay<Rays;iRay++){\n  float tim3=time+0.02*float(iRay)/float(Rays);\n  tim=tim3*tim3;//14.4;\n  float tim2=tim3*0.15;\n  float ct=cos(tim*1.25),st=sin(tim*1.25);\n  vec3 ro=vec3(cos(tim2)*vec2(sin(tim2*6.4),cos(tim2*6.4)),sin(tim2))*(6.0+3.0*sin(tim2*3.0));\n  ro.y=ro.y*0.2+2.5;\n  float focusDistance=max(length(ro)-0.1,0.01);\n  mat3 rotCam=lookat(-ro+texture(tex,vec2(tim2,tim2*1.3)).rgb*0.125+vec3(cos(tim2*0.75),sin(tim2*0.4),sin(tim2*0.6))*0.5,vec3(0.0,1.0+cos(tim2*25.0)*0.125,0.125*sin(tim2*25.0)));\n  ro.z-=tim;\n  rmx=mat2(ct,st,-st,ct);\n  vec2 pxl=(-size.xy+2.0*(fragCoord.xy+rand2()))/size.y;\n  vec3 er = normalize( vec3( pxl.xy, fov ) );\n  vec3 go = blurAmount*focusDistance*vec3( -1.0 + 2.0*rand2(), 0.0 );\n  vec3 gd = normalize( er*focusDistance - go );gd.z=0.0;\n  clr+=scene(ro+rotCam*go,normalize(rotCam*(er+gd)));\n }\n clr/=vec3(Rays);\n fragColor = vec4(sqrt(clr)*1.4-0.25,1.0);\n}", "image_inputs": [{"id": "Xsf3zn", "previewfilepath": "/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttX3W7.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[916, 916, 952, 952, 988], [1016, 1016, 1056, 1056, 1111], [1112, 1112, 1151, 1151, 1208], [1210, 1210, 1231, 1239, 1976], [1978, 1978, 2030, 2058, 2789], [2791, 2791, 2812, 2812, 3052], [3054, 3054, 3108, 3108, 3585], [3587, 3587, 3625, 3625, 3803], [3846, 3846, 3859, 3947, 4108], [4111, 4111, 4190, 4273, 4631], [4633, 4633, 4664, 4686, 6446], [6449, 6449, 6478, 6478, 6574], [6576, 6576, 6633, 6633, 7650]], "test": "error"}
{"id": "ttXGD4", "name": "[TWITCH] Pit of the beast", "author": "Flopine", "description": "I did this shader during a stream on Twitch here: https://www.twitch/flopine\nThe purpose was to recreate the effect I did  in 25 minutes during the quaterfinals of the revision shader showdown, but by improving it and building more stuff upon it.", "tags": ["3d", "raymarching", "hexagons", "twitch"], "likes": 21, "viewed": 319, "published": "Public", "date": "1556317041", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Code by Flopine\n// Thanks to wsmind, leon, XT95, lsdlive, lamogui, Coyhot, Alkama and YX for teaching me\n// Thanks LJ for giving me the love of shadercoding :3\n\n// Cookie Collective rulz\n\n#define time iTime\n\nvec2 hr = vec2(1., sqrt(3.));\nfloat detail = 5.;\nfloat PI = 3.141593;\n\nfloat rand (vec2 st)\n{return fract(sin(dot(vec2(2.45,3.45), st))*11.44);}\n\nfloat stmin (float a, float b, float k, float n)\n{\n    float st = k/n;\n    float u = b-k;\n    return min(min(a,b), 0.5*(u+a+abs(mod(u-a+st,2.*st)-st)));\n}\n\nmat2 rot(float a)\n{return mat2(cos(a),sin(a),-sin(a),cos(a));}\n\nvoid moda(inout vec2 p, float rep)\n{\n    float per = 2.*PI/rep;\n    float a = atan(p.y,p.x);\n    float l = length(p);\n    a = mod(a-per*0.5, per)-per*0.5;\n    p = vec2(cos(a),sin(a))*l;\n}\n\nvec4 hg (vec2 uv)\n{\n    uv *= detail;\n\n    vec2 ga = mod(uv, hr)-hr*0.5;\n    vec2 gb = mod(uv - hr*0.5, hr)-hr*0.5;\n    vec2 guv = dot(ga,ga) < dot(gb,gb) ? ga : gb;\n\n    vec2 gid = uv-guv;\n\n    vec2 uu = abs(guv);\n    guv.y = .5 - max(uu.x, dot(uu, normalize(hr)));\n\n    return vec4(guv,gid);\n}\n\nvec2 hid;\nfloat dm (vec2 uv)\n{\n    vec4 hxs = hg(uv);\n    hid = hxs.zw;\n    return smoothstep(0.05,0.06-sin(time)*0.1+0.1,hxs.y) * sin(length(hid)-time);\n}\n\nfloat box (vec3 p, vec3 c)\n{\n    vec3 q = abs(p)-c;\n    return min(0.,max(q.x,max(q.y,q.z))) + length(max(q,0.));\n}\n\nfloat cyl (vec3 p, float r, float h)\n{ return max(length(p.xy)-r, abs(p.z)-h); }   \n\nfloat od (vec3 p, float d)\n{return dot(p, normalize(sign(p)))-d;}\n\nfloat room (vec3 p)\n{\n    p.y -=3.5;\n    float b = -box(p, vec3(10.,4.,10.));\n\n    float c = 1e10;\n    float aoffset = 0.;\n    float offset = 0.;\n    for (int i=0; i<3; i++)\n    {\n        p.xz *= rot(PI/(4.+aoffset));\n        moda(p.xz, 5.);\n        p.x -= 2.+offset;\n        c = min(c, cyl(p.xzy, 0.25, 10.));\n\n        aoffset += 2.;\n        offset ++;\n    }\n\n\n    return stmin(b, c, 0.3, 4.);\n}\n\nfloat pit (vec3 p)\n{\n    float c = cyl(p.xzy, 2.,5.);\n    return max(abs(c)-0.14, p.y-.7);\n}\n\nfloat g1 = 0.;\nfloat water (vec3 p)\n{\n    vec3 pp = p;\n    p.y += .3;\n    p.y += dm(p.xz)*0.07;\n    float d = max(abs(p.y)-.8,cyl(pp.xzy, 2.,5.));  \n    g1 += 0.01/(0.01+d*d);\n    return d;\n} \n\nfloat g2 = 0.;\nfloat monster (vec3 p)\n{\n    vec3 pp = p;\n    p.y -= .8+sin(time)*0.1;\n    float o = od(p, 0.3);\n\n    p = pp;\n    p.xz*=rot(sin(p.y-time));\n    moda(p.xz, 6.);\n    p.x -= 1.;\n    float c = cyl(p.xzy, 0.3-p.y*0.1, 5.);\n\n    float d =  min(c,o);\n    g2 += 0.01/(0.01+d*d);\n    return d;\n}\n\nfloat SDF (vec3 p)\n{\n    float m = monster(p);\n    float r = room(p);\n    float w = water(p);\n    float well = pit(p);\n    float d = min(m,min(stmin(r, well, .5, 5.),w));\n\n    return d;\n}\n\nvec3 getnormal(vec3 p)\n{\n    vec2 eps = vec2(0.01,0.);\n    //return normalize(SDF(p)-vec3(SDF(p-eps.xyy), SDF(p-eps.yxy),SDF(p-eps.yyx)));\n    return normalize(vec3(SDF(p+eps.xyy)-SDF(p-eps.xyy),\n                          SDF(p+eps.yxy)-SDF(p-eps.yxy),\n                          SDF(p+eps.yyx)-SDF(p-eps.yyx)\n                         )\n                    );\n}\n\n\nfloat dir_lighting (vec3 n, vec3 l)\n{return dot(n, normalize(l)) * 0.5 + 0.5;}\n\n\nvec3 getcam (vec3 ro, vec3 tar, vec2 uv)\n{\n    vec3 f = normalize(tar-ro);\n    vec3 l = normalize(cross(vec3(0.,1.,0.),f));\n    vec3 u = cross(f,l);\n    return normalize(f + l*uv.x + u*uv.y);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = vec2(fragCoord.x / iResolution.x, fragCoord.y / iResolution.y);\n    uv -= 0.5;\n    uv /= vec2(iResolution.y / iResolution.x, 1);\n    \n    vec3 col = vec3(0.);\n    vec3 ro = vec3(4.*cos(time*0.5),2.5,-4.*sin(-time*0.5)); vec3 p = ro;\n    vec3 rd = normalize(vec3(uv,1.));\n    rd = getcam(ro, vec3(0.,0.5,0.), uv);\n    float shad = 0.;\n    bool hit = false;\n\n    for (float i=0.; i<100.; i++)\n    {\n        float d = SDF(p);\n        if (d<0.001)\n        {\n            hit = true;\n            shad = i/100.;\n            break;\n        }     \n        p += d*rd*0.8;\n    }\n    float t = length(ro-p);\n    if (hit)\n    {\n        vec3 l = vec3(8., 1., 3.);\n        vec3 n = getnormal(p);\n        col = mix(vec3(0.3,0.,0.2), vec3(0.5,0.7,0.8), dir_lighting(n, l));\n\n        col += vec3(rand(hid),0.3,1.)*g1*0.3;\n        col -= g2*0.2;\n    }\n\n    else col = vec3(0.);\n\n    col = mix(col, vec3(0.1,0.15,0.2), 1.-exp(-0.04*t*t));\n    fragColor = vec4(col, 1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttXGD4.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[282, 282, 304, 304, 355], [357, 357, 407, 407, 511], [513, 513, 532, 532, 575], [577, 577, 613, 613, 764], [766, 766, 785, 785, 1061], [1073, 1073, 1093, 1093, 1218], [1220, 1220, 1248, 1248, 1335], [1337, 1337, 1375, 1375, 1417], [1422, 1422, 1450, 1450, 1487], [1489, 1489, 1510, 1510, 1885], [1887, 1887, 1907, 1907, 1979], [1996, 1996, 2018, 2018, 2172], [2190, 2190, 2214, 2214, 2476], [2478, 2478, 2498, 2498, 2665], [2667, 2667, 2691, 2691, 3027], [3030, 3030, 3067, 3067, 3108], [3111, 3111, 3153, 3153, 3304], [3306, 3306, 3363, 3363, 4329]], "test": "timeout"}
{"id": "ttXGDN", "name": "Domain coloring of complex sine", "author": "tpfto", "description": "Domain coloring plot of the complex sine function.", "tags": ["2d", "math", "complex", "trigonometry", "domaincoloring"], "likes": 4, "viewed": 184, "published": "Public", "date": "1556357267", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// The MIT License\n// Copyright © 2019 J. M.\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// Basic domain coloring plot (https://en.wikipedia.org/wiki/Domain_coloring)\n// of the complex sine function w = sin(z)\n\n#define PI 3.14159265359\n#define SCALE 5.0 // plot scale\n#define SPACING 0.0625 // grid line spacing\n\n// Schlick bias function, from http://dept-info.labri.u-bordeaux.fr/~schlick/DOC/gem2.ps.gz\nfloat bias( float a, float x )\n{\n    return x/((1.0/a - 2.0) * (1.0 - x) + 1.0);\n}\n\n// biased sawtooth\nfloat my_saw( float x, float p )\n{\n    float xs = mod(x, 1.0);\n    float xh = clamp(xs, 0.0, p);\n    return 0.5 + 0.5 * bias(0.95, xh) * (1.0 - smoothstep(p, 1.0, xs));\n}\n\n// modified version of Inigo Quilez's method at https://www.shadertoy.com/view/MsS3Wc\n// using \"rational smoothstep\" from https://tpfto.wordpress.com/2019/03/28/on-a-rational-variant-of-smoothstep/\nvec3 smooth_hue( float h )\n{\n    vec3 rgb = clamp( abs(mod(6.0 * h + vec3(0.0, 4.0, 2.0), 6.0) - 3.0) - 1.0, 0.0, 1.0);\n    return rgb * rgb * rgb/(1.0 - 3.0 * rgb * (1.0 - rgb));\n}\n\n// modified DLMF coloring, adapted from https://www.shadertoy.com/view/WtXGWN\nvec3 smooth_dlmf( float h )\n{\n    vec3 rgb = clamp( vec3(1., -1., -1.) * abs((vec3(8., 4., 8.) * mod(h, 1.0) - vec3(4.5, 1.5, 5.5))) + vec3(-1.5, 1.5, 2.5), 0.0, 1.0 );\n\treturn rgb * rgb * rgb/(1.0 - 3.0 * rgb * (1.0 - rgb));\n}\n\n// complex sine\n\nvec2 sinz( in vec2 z )\n{\n\treturn vec2(sin(z.x) * cosh(z.y), cos(z.x) * sinh(z.y));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 aspect = iResolution.xy / iResolution.y;\n    vec2 z = ( fragCoord.xy / iResolution.y ) - 0.5 * aspect;\n    z *= SCALE;\n    z.x += iTime;\n    \n    vec2 w = sinz(z);\n    float ph = atan(w.y, w.x);\n    float lm = log(0.0001 + length(w));\n    \n    vec3 cd = smooth_dlmf(0.5 * (ph / PI));\n    vec3 ch = smooth_hue(0.5 * (ph / PI));\n    // transition between normal hue and DLMF coloring\n    vec3 c = mix(cd, ch, 0.5 + 0.5 * cos(2.0 * iTime));\n\n    // log-polar grid lines\n    float sat = my_saw((0.5 * (lm/PI))/SPACING, 0.98) * my_saw((0.5 * (ph / PI))/SPACING, 0.98);\n\n    fragColor = vec4(mix( vec3(1.0), c, sat), 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttXGDN.jpg", "access": "shaders20k", "license": "mit", "functions": [[1295, 1387, 1419, 1419, 1469], [1471, 1490, 1524, 1524, 1660], [1662, 1860, 1888, 1888, 2041], [2043, 2121, 2150, 2150, 2348], [2367, 2367, 2391, 2391, 2451], [2453, 2453, 2510, 2510, 3138]], "test": "ok"}
{"id": "ttXGDr", "name": "color dumpling", "author": "sako", "description": "I want to solve edge noise...", "tags": ["raymarching"], "likes": 2, "viewed": 53, "published": "Public", "date": "1556039108", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n\nconst float epsilon = 0.00001;\nconst float PI = 3.14159265;\nconst int rayLoopCount = 128;\nvec3 lightDir = normalize(vec3(1.0, 1.0, -1.0));\n\nstruct camera{\n    vec3 position;\n    float fov;\n} cam;\n\n\n// util func\n//-------------------------------------------------------------------------------------\nfloat deg2rad(float angle){\n    return angle * PI / 180.0;\n}\n\n// dist func\n//-------------------------------------------------------------------------------------\n\n// box distance fuction\nfloat distBox(vec3 p, vec3 size){\n    vec3 q = abs(p);\n    return length(max(q - size, 0.0));\n}\n\n// shere distance fuction\nfloat distSphere(vec3 pos, float size, vec3 sPos)\n{\n    return length(pos - sPos) - size; \n}\n\nfloat sdVerticalCapsule( vec3 p, float h, float r )\n{\n    p.y -= clamp( p.y, 0.0, h );\n    return length( p ) - r;\n}\n\n\nfloat opSmoothUnion( float d1, float d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h);\n}\n\nvec3 onRep(vec3 p, float interval){\n    return mod(p, interval) - interval * 0.5;\n}\n\nvec3 foldX(vec3 p) {\n    p.x = abs(p.x);\n    return p;\n}\n\nvec3 foldY(vec3 p) {\n    p.y = abs(p.y);\n    return p;\n}\n\nvec3 rotate(vec3 p, float angle, vec3 axis){\n    vec3 a = normalize(axis);\n    float s = sin(angle);\n    float c = cos(angle);\n    float r = 1.0 - c;\n    mat3 m = mat3(\n        a.x * a.x * r + c,\n        a.y * a.x * r + a.z * s,\n        a.z * a.x * r - a.y * s,\n        a.x * a.y * r - a.z * s,\n        a.y * a.y * r + c,\n        a.z * a.y * r + a.x * s,\n        a.x * a.z * r + a.y * s,\n        a.y * a.z * r - a.x * s,\n        a.z * a.z * r + c\n    );\n    return m * p;\n}\n\n// scene\n//-------------------------------------------------------------------------------------\n\nfloat sceneDist(vec3 pos){\n    vec3 fPos = pos;\n    fPos = rotate(fPos, iTime*3.0, vec3(0, 1, 1));\n    fPos = foldX(fPos);\n    fPos = foldY(fPos);\n    float random = sin(iTime+floor(pos.y*2.0));\n    float sphere = distSphere(fPos, 0.3, vec3(0.5, 0.5, random));\n    vec3 pollFPos = fPos -vec3(0.5, 0.5, 2.0);\n    pollFPos = rotate(pollFPos, PI/2.0, vec3(1.0, 0.0, 0.0));\n    float poll = sdVerticalCapsule(pollFPos, 4.0, 0.05);\n\n\n    float dist = min(poll, sphere);\n    return dist;\n}\n\nvec3 getNormal(vec3 pos)\n{\n    return normalize(vec3(\n        sceneDist(pos + vec3(epsilon, 0., 0.)) - sceneDist(pos - vec3(epsilon, 0., 0.)),\n        sceneDist(pos + vec3(0., epsilon, 0.)) - sceneDist(pos - vec3(0., epsilon, 0.)),\n        sceneDist(pos + vec3(0., 0., epsilon)) - sceneDist(pos - vec3(0., 0., epsilon))\n    ));\n}\n\nfloat genShadow(vec3 ro, vec3 rd){\n    float h = 0.0;\n    float c = 0.001;\n    float r = 1.0;\n    float shadowCoef = 0.5;\n    for(float t=0.0; t<100.0; t++){\n        h = sceneDist(ro+rd*c);\n        if(h<epsilon){\n            return shadowCoef;\n        }\n        r = min(r, h * 16.0 / c);\n        c += h;\n    }\n    return 1.0 - shadowCoef + r * shadowCoef;\n}\n\nvec3 trace(vec2 uv){\n    vec3 col = vec3(0.0);   \n    vec3 bgCol = vec3(1.2, 1.1, 1.2);\n    bgCol += length(uv-vec2(0.5/min(iResolution.x, iResolution.y)))/8.0; \n    vec2 cp = vec2(3.0 * cos(iTime), 3.0 * sin(iTime));\n    cam.position = vec3(cp.x, cp.y, -3.0*(cos(iTime)+1.0)-5.0);\n    cam.fov = 30.0;\n    \n    //trace\n    float fov = deg2rad(cam.fov / 2.0);\n    \n    vec3 lookAt = vec3(0.0, 0.0, 0.0);\n    vec3 forward = normalize(lookAt-cam.position);\n    vec3 right = normalize(vec3(forward.z, 0., -forward.x ));\n    vec3 up = normalize(cross(forward,right));\n    \n\n    vec3 ray = normalize(forward + fov*uv.x*right + fov*uv.y*up);\n    vec3 cur = cam.position;\n    \n    //dist\n    float dist;\n    for (int i=0; i < rayLoopCount; i++)\n    {\n        dist = sceneDist(cur);\n        if (dist < epsilon)\n        {\n        break;\n        }\n        cur += ray * dist;\n    }\n    \n    vec3 outcol = vec3(1.0);\n    if(dist <= epsilon){\n        vec3 normal = getNormal(cur);\n    \n        float diff = dot(normal, lightDir);\n        // float shadow = genShadow(cur + normal * epsilon, lightDir);\n        // return bgCol;\n        vec3 ambient = vec3(0.2);\n        vec3 diffcol = vec3(1.0);\n        diffcol = vec3(floor(normal.x*10.0), fract(uv.x*3.0), floor(normal.y*10.0));\n        diffcol += vec3(0.5);\n        // diffcol = vec3();\n        col = vec3(diff)*diffcol + ambient;\n        // col = col * max(0.5, shadow);\n        \n        \n        outcol = col;\n    }else{\n        outcol = bgCol;\n    }\n    outcol *= 1.-length(uv-vec2(0.5/min(iResolution.x, iResolution.y)))/4.0; \n    \n    return outcol;\n    \n    \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //setup\n    vec2 uv = (fragCoord * 2.0 - iResolution.xy) / min(iResolution.x, iResolution.y);\n    fragColor = vec4(trace(uv), 1.0);\n}\n\n\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttXGDr.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[200, 301, 328, 328, 361], [465, 489, 522, 522, 584], [586, 612, 663, 663, 704], [706, 706, 759, 759, 822], [825, 825, 877, 877, 976], [978, 978, 1013, 1013, 1061], [1063, 1063, 1083, 1083, 1119], [1121, 1121, 1141, 1141, 1177], [1179, 1179, 1223, 1223, 1652], [1752, 1752, 1778, 1778, 2235], [2237, 2237, 2263, 2263, 2566], [2568, 2568, 2602, 2602, 2925], [2927, 2927, 2947, 2947, 4530], [4532, 4532, 4589, 4601, 4727]], "test": "ok"}
{"id": "ttXGWH", "name": "Abstract Terrain Objects", "author": "Shane", "description": "Rendering some abstract objects onto terrain. Inspired by Mike Winkelmann's imagery.", "tags": ["terrain", "geometry", "scifi", "reflect", "shine"], "likes": 192, "viewed": 7861, "published": "Public API", "date": "1556289065", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/*\n\n    Abstract Terrain Objects\n    ------------------------\n\n\tRendering some abstract geometry onto some terrain in a basic sci-fi tone.\n\n\tThis was inspired by one of Mike Winkelmann's images, which I've included \n\ta link to below. The original image is nicer -- partly due to the fact that\n\tI'm restricted by realtime constraints, and possibly, because I have the\n\tartistic vision of a programmer. :D\n\t\n\tMike Winkelmann is the guy behind the amazing sci-fi flavored Beeple imagery \n\tthat appears in various corners of the internet. For anyone not familiar \n\twith his work, it's well worth the look. Shau has been putting up a few \n\tBeeple inspired shaders lately, which reminded me that I'd been meaning to\n\tdo the same.\n\n\tMost of this is pretty standard stuff: Render some sky, terrain, and some \n\tobjects, with an extra reflective pass on the objects to make them shiny.\n\tI went to the trouble to blend materials when the shiny objects were near \n\tthe terrain. That involved a little bit of fiddly mixing, which complicated \n\tthe code a little, but nothing that anyone here couldn't handle. :)\n\n\n\tOriginal Image:\n\n\t// Putting abstract geometry on terrain is a weird but common concept \n\t// amongst the graphics community, and this is a beautiful example.\n\tTRIOMETRIC - Beeple\n\thttps://twitter.com/beeple/status/848029629973749760\n\n\n\tExamples:\n\n\t// One of Shau's Beeple inspired shaders.\n\tData Surge - shau\n\thttps://www.shadertoy.com/view/3dSXzm\n\n\t// Cool and qwirky. I love the rendering style.\n\t[SH16B] valley flight  - Bananaft\n\thttps://www.shadertoy.com/view/XldGR7\n\n\t// I like the rendering style of this also.\n\tRayCraft - jolle\n\thttps://www.shadertoy.com/view/tslGRX\n\n\t// Another one of Shau's. Fun to watch.\n\tXANNN - shau\n\thttps://www.shadertoy.com/view/llSfzR\n\n*/\n\n// Maximum ray distance. Analogous to the far plane.\n#define FAR 100. \n\n// More correct third pass: The reflection off the reflected surface is less\n// noticeable, so we're saving some computing power and faking it, which means\n// this is not on by default. However, if your computer can afford it, this is \n// a better option.\n//#define THIRD_PASS\n\n\n// Scene object ID. Either the Terrain object (0) or the chrome object (0).\nvec4 objID, oSvObjID;\nfloat svObjID; // Global ID to keep a copy of the above from pass to pass.\n\n\n// vec2 to vec2 hash.\nvec2 hash22(vec2 p) { \n\n    // Faster, but doesn't disperse things quite as nicely. However, when framerate\n    // is an issue, and it often is, this is a good one to use. Basically, it's a tweaked \n    // amalgamation I put together, based on a couple of other random algorithms I've \n    // seen around... so use it with caution, because I make a tonne of mistakes. :)\n    float n = sin(dot(p, vec2(1, 113)));\n    return fract(vec2(262144, 32768)*n)*2. - 1.; \n    \n    // Animated.\n    //p = fract(vec2(262144, 32768)*n); \n    // Note the \".45,\" insted of \".5\" that you'd expect to see. When edging, it can open \n    // up the cells ever so slightly for a more even spread. In fact, lower numbers work \n    // even better, but then the random movement would become too restricted. Zero would \n    // give you square cells.\n    //return sin( p*6.2831853 + iTime ); \n    \n}\n\n\n// Fabrice's consice, 2D rotation formula.\n//mat2 r2(float th){ vec2 a = sin(vec2(1.5707963, 0) + th); return mat2(a, -a.y, a.x); }\n// Standard 2D rotation formula.\nmat2 r2(in float a){ float c = cos(a), s = sin(a); return mat2(c, s, -s, c); }\n\n// The path is a 2D sinusoid that varies over time, depending upon the frequencies, and amplitudes.\nvec2 path(in float t){ \n\n    //return vec2(0);\n    //float s = sin(t/24.)*cos(t/12.);\n    //return vec2(s*4., 0.);\n    \n    float a = sin(t*.11);\n    float b = cos(t*.14);\n    return vec2((a*2./2. - b*1.5/2.), b*1.7/4. + a*1.5/4.);\n    \n    //return vec2(sin(t*.15)*2.4, cos(t*.25)*1.7*.5); \n}\n\n// Smooth fract function.\nfloat sFract(float x, float sf){\n    \n    x = fract(x);\n    return min(x, (1. - x)*x*sf);\n    \n}\n\n\n// Compact, self-contained version of IQ's 3D value noise function.\nfloat n3D(vec3 p){\n    \n\tconst vec3 s = vec3(113., 57., 27.);\n\tvec3 ip = floor(p); p -= ip; \n    vec4 h = vec4(0., s.yz, s.y + s.z) + dot(ip, s);\n    //p = p*p*(3. - 2.*p);\n    p *= p*p*(p*(p*6. - 15.) + 10.);\n    h = mix(fract(sin(h)*43758.5453), fract(sin(h + s.x)*43758.5453), p.x);\n    h.xy = mix(h.xz, h.yw, p.y);\n    return mix(h.x, h.y, p.z); // Range: [0, 1].\n}\n\n\n// Smooth maximum, based on IQ's smooth minimum.\nfloat smax(float a, float b, float s){\n    \n    float h = clamp(.5 + .5*(a - b)/s, 0., 1.);\n    return mix(b, a, h) + h*(1. - h)*s;\n}\n\n\n\n\n// Cheap and nasty 2D smooth noise function with inbuilt hash function -- based on IQ's \n// original. Very trimmed down. In fact, I probably went a little overboard. I think it \n// might also degrade with large time values.\nfloat n2D(vec2 p) {\n\n\tvec2 i = floor(p); p -= i; //p *= p*(3. - p*2.);  \n    \n    p *= p*p*(p*p*6. - p*15. + 10.); \n    \n    return dot(mat2(fract(sin(mod(vec4(0, 1, 113, 114) + dot(i, vec2(1, 113)), 6.2831853))*43758.5453))*\n                vec2(1. - p.y, p.y), vec2(1. - p.x, p.x) );\n\n}\n\n// FBM -- 4 accumulated noise layers of modulated amplitudes and frequencies.\nfloat fbm(vec2 p){ return n2D(p)*.533 + n2D(p*2.)*.267 + n2D(p*4.)*.133 + n2D(p*8.)*.067; }\nfloat fbmCam(vec2 p){ return n2D(p)*.533 + n2D(p*2.)*.267; }\n\n// The triangle function that Shadertoy user Nimitz has used in various triangle noise demonstrations.\n// See Xyptonjtroz - Very cool. Anyway, it's not really being used to its full potential here.\nvec2 tri(in vec2 x){return abs(x - floor(x) - .5);} // Triangle function.\nvec2 triS(in vec2 x){return cos(x*6.2831853)*.25 + .25;} // Smooth version.\n\n// Height function layers. \nfloat h1(vec2 p){ return dot(tri(p + tri(p.yx*.5 + .25)), vec2(1)); }\nfloat h1Low(vec2 p){ return dot(triS(p + triS(p.yx*.5 + .25)), vec2(1)); }\n\n// Terrain height function. Just a few layers.\nfloat h(vec2 p) {\n    \n    float ret = 0., m = 1., a = 1., s = 0.;\n    \n    //for(int i=0; i<1; i++) {\n    \n        ret += a*h1Low(p/m);\n        //ret += a * n2D(p/m);\n        p = r2(1.57/3.73)*p;\n        //p = mat2(1, .75, -.75, 1)*p;\n        m *= -.375;\n        s += a;\n        a *= .3;\n    //}\n    \n    for(int i=1; i<5; i++) {\n        ret += a*h1(p/m);\n        //ret += a * n2D(p/m);\n        p = r2(1.57/3.73)*p;\n        //p = mat2(1, .75, -.75, 1)*p;\n        m *= -.375;\n        s += a;\n        a *= .3;\n    }\n    \n    ret /= s;\n    \n    return ret*.25 + ret*ret*ret*.75;\n\n}\n\n// The camera height function, which is a smoother version of the terrain function.\nfloat hLow(vec2 p) {\n    \n    float ret = 0., m = 1., a = 1., s = 0.;\n    for(int i=0; i<2; i++){\n        \n        ret += a*h1Low(p/m);\n        //ret += a * n2D(p/m);\n        p = r2(1.57/3.73)*p;\n        //p = mat2(1, .75, -.75, 1)*p;\n        m *= -.375;\n        s += a;\n        a *= .3;\n    }\n    \n    ret /= s;\n    \n    return ret*.25 + ret*ret*ret*.75;\n\n}\n\n// Surface function.\nfloat surfaceFunc(vec3 q){\n    \n    // Height.\n    float sf = h(q.xz/20.);\n    \n    // Experimental way to dig out a trench.\n    sf -= smax(1.4 - q.x*q.x*.5, 0., 1.)*.12;\n    \n    return (.5 - sf)*5.;\n}\n\n// Surface function for the camera.\nfloat surfaceFuncCam(vec3 q){\n    \n    // Height.\n    float sf = hLow(q.xz/20.);\n    \n    // Experimental way to dig out a trench.\n    sf -= smax(1.4 - q.x*q.x*.5, 0., 1.)*.12;\n    \n    return (.5 - sf)*3.;\n}\n\n// Toroidal distance function... Technically, a lot of these are just\n// bounds, so not exactly correct, which means shadows, glow, and other\n// things can be effected. However, they're cheaper, and you can't really\n// tell here.\nfloat distT(vec2 p){\n    \n    // Try some of the others, if you get bored enough. :)\n    \n    //return max(abs(p.x)*.866025 + p.y*.5, -p.y); // Triangle.\n    //return length(p); // Circle.\n    \n    p = abs(p);\n    return (p.x + p.y)*.7071; // Diamond.\n    //return max(p.x, p.y); // Square.\n    //return max(p.x*.866025 + p.y*.5, p.y); // Hexagon.\n    //return max((p.x + p.y)*.7071 - .4, max(p.x, p.y)); // Octagon.\n    \n}\n\n// Poloidal distance function. As mentioned above these are technically\n// bounds, but they work well enough.\nfloat distP(vec2 p){\n    \n    //return length(p); // Circle.\n    \n    p = abs(p);\n    return max((p.x + p.y)*.7071 - .06, max(p.x, p.y)); // Beveled square.\n    //return max(p.x*.866025 + p.y*.5, p.y); // Hexagon.\n    //return max(p.x, p.y); // Square.\n    \n}\n\n// Global scale, to space out the chrome objects.\nconst vec3 sc = vec3(16, 4, 4);\n\nfloat objects(vec3 p){\n    \n    \n    p.xz += sc.xz/2.;\n    \n    vec3 ip = floor(p/sc)*sc;\n    \n \n    // Repeating objects across the terrain in Z direction.\n    p.xz = vec2(p.x, p.z - ip.z) - sc.xz*.5; // Equivalent to: mod(p.xz, sc) - sc*.5;\n    // Repeating objects across the terrain in the X and Z directions.\n    //p.xz = (p.xz - ip.xz) - sc.xz*.5; // vec2(p.x, mod(p.z, sc.y)) - sc*.5;\n    \n    \n    // Obtaining the surface height at the center of the grid. This height is used\n    // to shift the object to the approximate top of the terrain.\n    float sf = surfaceFunc(ip);\n    \n    // Add the grid height to the object's Y position.\n    p.y += sf - 1.8;\n    \n    // Use the object's Z position to rotate it about the XY plane. This effect looks\n    // better on a flat terrain.\n    p.xy = r2(sc.z/16. - ip.z/16.)*p.xy;\n    // Random XZ rotation, just to show it can be done.\n    //p.xz = r2((hash(ip.z) - .5)/2.)*p.xz;\n    \n    \n    const float sz = 1.8;\n    const float th = .5;\n     \n    // Toroidal angle. \n    //float a = atan(p.y, p.x);\n    \n    // Toroidal distance -- The large radius part.\n    p.xy = vec2(distT(p.xy) - sz, p.z);\n    // Windows logo warp. :)\n    //p.xy = vec2(distT(p.xy) - sz + sin(a*4.)*.125, p.z);\n    \n    // Mobius-like twisting: Twisting the toroidal axis one full revolution\n    // about the poloidal plane... Yeah, it confuses me too. :) Be sure to\n    // uncomment the \"atan\" bit above.\n    //p.xz = r2(a)*p.xz;\n    \n    \n    // Poloidal distance. The smaller radius part. \n    float obj = distP(p.xz) - th/2.;\n    \n     \n    // Return the cell object.\n    return obj;\n    \n}\n\n\n// The distance function. Just some geometric objects and some terrain.\nfloat map(vec3 p){\n    \n    // Wrap everything around the path.\n    p.xy -= path(p.z);\n    \n    // The surface function. Essentially, the bumps we add to the terrain.\n    float sf = surfaceFunc(p);\n    \n    // The terrain, which we're lowering a bit.\n    float terr = p.y + .0 + sf;\n\n    // The chrome objects. \n    float obj = objects(p);\n    \n    // Store the terrain and object IDs, for sorting later.\n    objID = vec4(terr, obj, 0, 0);\n    \n    // Return the minimum distance.\n    return min(terr, obj);\n    \n}\n\n\n// Standard raymarching routine.\nfloat trace(vec3 ro, vec3 rd){\n   \n    float t = 0., d;\n    \n    for (int i=0; i<80; i++){\n\n        d = map(ro + rd*t);\n        \n        if(abs(d)<.001*(t*.1 + 1.) || t>FAR) break;\n        \n        t += d*.866; // Using slightly more accuracy in the first pass.\n    }\n    \n    return min(t, FAR);\n}\n\n// Second pass, which is the first, and only, reflected bounce. \n// Virtually the same as above, but with fewer iterations and less \n// accuracy.\n//\n// The reason for a second, virtually identical equation is that \n// raymarching is usually a pretty expensive exercise, so since the \n// reflected ray doesn't require as much detail, you can relax things \n// a bit - in the hope of speeding things up a little.\nfloat traceRef(vec3 ro, vec3 rd){\n    \n    float t = 0., d;\n    \n    for (int i=0; i<56; i++){\n\n        d = map(ro + rd*t);//*rDir;\n        \n        if(abs(d)<.001*(t*.1 + 1.) || t>FAR) break;\n        \n        t += d*.9;\n    }\n    \n    return min(t, FAR);\n}\n\n\n\n// Bump function. \nfloat bumpSurf3D( in vec3 p, float t){\n    \n    \n    float c, c0 = 0., c1 = 0.;\n    \n    //float bordTx0Tx1 = oSvObjID.x - oSvObjID.y;\n    //const float bordW = .0;\n    \n    \n    // Terrain.\n    if(svObjID == 0.){// || abs(bordTx0Tx1)<bordW) {\n        \n        c0 = fbm(p.xz*8.);\n        \n        c0 = (1. - c0)/3.;\n    }\n    /*\n    // Metallic objects. The original image has a metallic bump, \n    // but I wanted to keep it smooth.\n    if(svObjID == 1.){// || abs(bordTx0Tx1)<bordW) {\n    \n        \n        c1 = (n3D(p*6.)*.66 + n3D(p*12.)*.34);\n        c1 = smoothstep(0., .1, n3D(p*3.) - .65)*c1/12.;\n        \n        //c1 = (1. - smoothstep(.05, .3, c1))/4.;\n        \n    }\n    */\n    // Used to fade the bump when objects are near one another, but\n    // I feel it's a little bit of overkill, for this particular example.\n    //c = mix(c0, c1, step(oSvObjID.y, oSvObjID.x));\n    //c = mix(c0, c1, smoothstep(-bordW/2., bordW/2., bordTx0Tx1));\n    \n    c = c0;\n    \n    // Fading the bump out over distance.\n    return c/(1. + t*t*3.);\n    \n}\n\n\n// Standard function-based bump mapping routine: This is the cheaper four tap version. There's\n// a six tap version (samples taken from either side of each axis), but this works well enough.\nvec3 doBumpMap(in vec3 p, in vec3 nor, float bumpfactor, float t){\n    \n    // Larger sample distances give a less defined bump, but can sometimes lessen the aliasing.\n    const vec2 e = vec2(.001, 0); \n    \n    // Gradient vector: vec3(df/dx, df/dy, df/dz);\n    float ref = bumpSurf3D(p, t);\n    vec3 grad = (vec3(bumpSurf3D(p - e.xyy, t),\n                      bumpSurf3D(p - e.yxy, t),\n                      bumpSurf3D(p - e.yyx, t)) - ref)/e.x; \n    \n    /*\n    // Six tap version, for comparisson. No discernible visual difference, in a lot of cases.\n    vec3 grad = vec3(bumpSurf3D(p - e.xyy, t) - bumpSurf3D(p + e.xyy, t),\n                     bumpSurf3D(p - e.yxy, t) - bumpSurf3D(p + e.yxy, t),\n                     bumpSurf3D(p - e.yyx, t) - bumpSurf3D(p + e.yyx, t))/e.x*.5;\n    */\n       \n    // Adjusting the tangent vector so that it's perpendicular to the normal. It's some kind \n    // of orthogonal space fix using the Gram-Schmidt process, or something to that effect.\n    grad -= nor*dot(nor, grad);          \n         \n    // Applying the gradient vector to the normal. Larger bump factors make things more bumpy.\n    return normalize(nor + grad*bumpfactor);\n\t\n}\n\n\n\n// Cheap shadows are the bain of my raymarching existence, since trying to alleviate artifacts is an excercise in\n// futility. In fact, I'd almost say, shadowing - in a setting like this - with limited  iterations is impossible... \n// However, I'd be very grateful if someone could prove me wrong. :)\nfloat softShadow(vec3 ro, vec3 lp, float k, float t){\n\n    // More would be nicer. More is always nicer, but not really affordable... Not on my slow test machine, anyway.\n    const int maxIterationsShad = 32; \n    \n    vec3 rd = lp - ro; // Unnormalized direction ray.\n\n    float shade = 1.;\n    float dist = .0015; // Coincides with the hit condition in the \"trace\" function.  \n    float end = max(length(rd), 0.0001);\n    //float stepDist = end/float(maxIterationsShad);\n    rd /= end;\n\n    // Max shadow iterations - More iterations make nicer shadows, but slow things down. Obviously, the lowest \n    // number to give a decent shadow is the best one to choose. \n    for (int i=0; i<maxIterationsShad; i++){\n\n        float h = map(ro + rd*dist);\n        shade = min(shade, k*h/dist);\n        //shade = min(shade, smoothstep(0.0, 1.0, k*h/dist)); // Subtle difference. Thanks to IQ for this tidbit.\n        // So many options here, and none are perfect: dist += min(h, .2), dist += clamp(h, .01, stepDist), etc.\n        dist += clamp(h, .05, .5); \n        \n        // Early exits from accumulative distance function calls tend to be a good thing.\n        if (h<0. || dist > end) break; \n    }\n\n    // I've added a constant to the final shade value, which lightens the shadow a bit. It's a preference thing. \n    // Really dark shadows look too brutal to me. Sometimes, I'll add AO also just for kicks. :)\n    return min(max(shade, 0.) + .2, 1.); \n}\n\n\n// Standard normal function. It's not as fast as the tetrahedral calculation, but more symmetrical.\nvec3 getNormal(in vec3 p) {\n\tconst vec2 e = vec2(.001, 0);\n\treturn normalize(vec3(map(p + e.xyy) - map(p - e.xyy), map(p + e.yxy) - map(p - e.yxy),\tmap(p + e.yyx) - map(p - e.yyx)));\n}\n\n\n\nvec3 getSky(vec3 ro, vec3 rd, vec3 lp){\n\n    // Gradient blues, and red, or something.\n    vec3 sky = max(mix(vec3(1, .7, .6), vec3(.7, .9, 1.5), rd.y + .0), 0.)/4.; \n    \n    // Last minute contrast.\n    sky = pow(sky, vec3(1.25))*1.25;\n    \n    // Horizon strip.\n    sky = mix(sky, vec3(1, .1, .05), (1. - smoothstep(-.1, .25, rd.y))*.3);\n    \n    \n\t// Blending in the sun.\n    float sun = max(dot(normalize(lp - ro), rd), 0.);\n    //sky = mix(sky, vec3(.6, 1, .5), pow(sun, 6.)*.5);\n    sky = mix(sky, vec3(1, .7, .6)*.9, pow(sun, 6.));\n    sky = mix(sky, vec3(1, .9, .8)*1.2, pow(sun, 32.));\n\n\n    // Subtle, fake sky curvature.\n    rd.z *= 1. + length(rd.xy)*.25;\n    rd = normalize(rd);\n\n    // A simple way to place some clouds on a distant plane above the terrain -- Based on something IQ uses.\n    const float SC = 1e5;\n    float tt = (SC - ro.y - .15)/(rd.y + .15); // Trace out to a distant XZ plane.\n    vec2 uv = (ro + tt*rd).xz; // UV coordinates.\n\n    // Mix the sky with the clouds, whilst fading out a little toward the horizon (The rd.y bit).\n    if(tt>0.) {\n\n        float cl = fbm(1.5*uv/SC);\n\n        // White clouds.\n        sky =  mix(sky, vec3(1)*vec3(1, .9, .85), smoothstep(.3, .95, cl)*\n                   smoothstep(.475, .575, rd.y*.5 + .5)*.5); \n        // Fake dark shadow. Subtle, but kind of worth doing. :)\n        sky =  mix(sky, vec3(0), smoothstep(.0, .95, cl)*fbm(7.*uv/SC)*\n                   smoothstep(.475, .575, rd.y*.5 + .5)*.3);\n\n    }\n\n    // Speckles. Not science based, but it looks intering.\n    vec3 p = (ro + rd*FAR)/1. + vec3(0, 0, iTime);\n    float st = n3D(p)*.66 + n3D(p*2.)*.34;\n    st = smoothstep(.1, .9, st - .0);\n    sky = mix(sky, vec3(.7, .9, 1), (1. - sqrt(st))*.05);\n    \n    // The sky color.\n    return sky;\n\n}\n\n\n// Coloring\\texturing the scene objects, according to the object IDs.\nvec3 getObjectColor(vec3 p, vec3 n){\n    \n    // Object texture color.\n\n    // Contorting the texture coordinates to math the contorted scene.\n    //vec3 txP = p - vec3(path(p.z), 0.);\n    p = p - vec3(path(p.z), 0.);\n\n    // Texture value, and individual texture values.\n    vec3 tx, tx0, tx1;\n    \n    float bordTx0Tx1 = oSvObjID.x - oSvObjID.y;\n    const float bordW = .075;\n    \n     \n    // If we hit the terrain, or hit the region near the terrain, color\n    // it up.\n    if(svObjID==0. || abs(bordTx0Tx1)<bordW){\n        \n        // Noisy color mixing. Tweaked until it looked right.\n        vec2 q = p.xz;\n\n        float c = n2D(q)*.6 + n2D(q*3.)*.3 + n2D(q*9.)*.1;\n        c = c*c*.7 + sFract(c*4., 12.)*.3;\n        c = c*.9 + .2;\n        tx0 = mix(vec3(1, .3, .2), vec3(1, .35, .25), n2D(q*6.));\n        tx0 *= c;\n\n        float c2 = n2D(q*20.)*.66 + n2D(q*40.)*.34;\n        c2 = smoothstep(.1, .6, c2*c2);\n\n\n        tx0 = mix(tx0*vec3(1.2, .8, .65).zyx, tx0, abs(n));\n        tx0 = mix(tx0, vec3(0), c2*.4);\n\n        //tx0 *= mix(vec3(1.2, .8, .6), vec3(1.2, .8, .6).yxz, -n.y*.5 + .5);\n\n        \n        /*\n        // Extra shadowing. A bit much, in this case.\n \t\t\n\t\t// Matches the terrain height function.\n        float sf = h(p.xz/20.);\n    \n        // Experimental way to dig out a trench.\n    \tsf -= smax(1.4 - q.x*q.x*.5, 0., 1.)*.12;\n        \n        tx0 *= smoothstep(-.1, .5, sf) + .5;\n        */\n        \n    }\n     \n    // If the ray hits the metallic object, or close to it, color it dark.\n    // The shininess is provided with the relective color. I used to get \n    // this wrong all the time. :)\n    if(svObjID==1. || abs(bordTx0Tx1)<bordW) tx1 = vec3(.08, .1, .12);\n    \n    \n    // Return the color, which is either the terrain color, the shiny object color,\n    // or if we're in the vicinity of both, make it a mixture of the two.\n    tx = mix(tx0, tx1, smoothstep(-bordW, bordW, bordTx0Tx1));\n   \n    \n    return tx; // Return the object color.\n    \n}\n\n// Using the hit point, unit direction ray, etc, to color the scene. Diffuse, specular, falloff, etc. \n// It's all pretty standard stuff.\nvec3 doColor(in vec3 ro, in vec3 sp, in vec3 rd, in vec3 sn, in vec3 lp, float edge, float crv, float ao, float t){\n    \n    // Initiate the scene (for this pass) to zero.\n    vec3 sceneCol = vec3(0);\n    \n    if(t<FAR){ // If we've hit a scene object, light it up.\n    \n        vec3 ld = lp - sp; // Light direction vector.\n        float lDist = max(length(ld), 0.001); // Light to surface distance.\n        ld /= lDist; // Normalizing the light vector.\n\n        // Attenuating the light, based on distance.\n        float atten = 1.5/(1. + lDist*0.001 + lDist*lDist*0.0001);\n\n        // Standard diffuse term.\n        float diff = max(dot(ld, sn), 0.);\n        //diff = pow(diff, 2.)*.66 + pow(diff, 4.)*.34;\n        // Standard specualr term.\n        float spec = pow(max(dot(reflect(-ld, sn), -rd), 0.), 32.);\n        float fres = clamp(1. + dot(rd, sn), 0., 1.);\n        //float Schlick = pow( 1. - max(dot(rd, normalize(rd + ld)), 0.), 5.0);\n        //float fre2 = mix(.5, 1., Schlick);  //F0 = .5.\n        \n        // Ramp up the diffuse value on the shiny geometric object. It's a cheap\n        // trick to make things look shiny.\n        if(svObjID==1.) diff *= diff*2.;\n\n        // Coloring the object, accoring to object ID,.        \n        vec3 objCol = getObjectColor(sp, sn);\n\n        \n        // Combining the above terms to produce the final scene color.\n        sceneCol = objCol*(diff + .35 + fres*fres*0. + vec3(.5, .7, 1)*spec);\n        \n        \n        // Attenuation only. To save cycles, the shadows and ambient occlusion\n        // from the first pass only are used.\n        sceneCol *= atten;\n    \n    }\n    \n    \n    // Get the sky color.  \n    vec3 sky = getSky(ro, rd, lp);\n    \n    // Smoothly blend it in, according to the FAR plane distance. Basically, we want it\n    // to fade in strongly as we hit the horizon.\n    sceneCol = mix(sceneCol, sky, smoothstep(0., .95, t/FAR)); // exp(-.002*t*t), etc.\n \n    \n  \n    // Return the color. Done once for each pass.\n    return sceneCol;\n    \n}\n\n// I keep a collection of occlusion routines... OK, that sounded really nerdy. :)\n// Anyway, I like this one. I'm assuming it's based on IQ's original.\nfloat calculateAO(in vec3 pos, in vec3 nor)\n{\n\tfloat sca = 2., occ = 0.;\n    for(int i=0; i<5; i++){\n    \n        float hr = .01 + float(i)*.5/4.;        \n        float dd = map(nor * hr + pos);\n        occ += (hr - dd)*sca;\n        sca *= .7;\n    }\n    return clamp(1. - occ, 0., 1.);    \n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n\n    // Screen coordinates.\n\tvec2 uv = (fragCoord - iResolution.xy*.5)/iResolution.y;\n    \n\t\n\t// Camera Setup.\n\tvec3 ro = vec3(0, 1.25, iTime*2.); // Camera position, doubling as the ray origin.\n\tvec3 lk = ro + vec3(0, 0, .5);  // \"Look At\" position.\n    \n    \n    // Light position. Set in up in the sky above the horizon -- out near the far plane.\n    vec3 lp = ro + vec3(-20, 30, 60);\n    \n   \n\t// Using the Z-value to perturb the XY-plane.\n\t// Sending the camera, \"look at,\" and light vector down the path, which is \n\t// synchronized with the distance function.\n    ro.xy += path(ro.z);\n\tlk.xy += path(lk.z);\n\tlp.xy += path(lp.z);\n    \n    // Using a smoother version of the terrain function to move the camera up and down.\n    // Alternatively, you could thread it through some Bezier points... if you're not\n    // lazy, like me. :D\n    ro.y -= surfaceFuncCam(ro.xyz);\n    lk.y -= surfaceFuncCam(lk.xyz);\n    \n\n    // Using the above to produce the unit ray-direction vector.\n    float FOV = 3.14159/2.; // FOV - Field of view.\n    vec3 forward = normalize(lk-ro);\n    vec3 right = normalize(vec3(forward.z, 0., -forward.x )); \n    vec3 up = cross(forward, right);\n\n    // rd - Ray direction.\n    //vec3 rd = normalize(forward + FOV*uv.x*right + FOV*uv.y*up);\n    \n    // Warped unit direction vector, for a warped lens effect.\n    vec3 rd = (forward + FOV*uv.x*right + FOV*uv.y*up);\n    rd = normalize(vec3(rd.xy, rd.z - length(rd.xy)*.15));\n    \n    \n    // Edge and curvature variables. Not used here.\n    float edge = 0., crv = 1.;\n\n    \n    // FIRST PASS.\n    //\n    float t = trace(ro, rd); // Trace.\n\n    // Save the object IDs after the first pass.\n    svObjID = objID.x<objID.y? 0. : 1.;\n    oSvObjID = objID;\n    \n    // Advancing the ray origin, \"ro,\" to the new hit point.\n    vec3 sp = ro + rd*t;\n    \n    // Retrieving the normal at the hit point, plus the edge and curvature values.\n    //vec3 sn = getNormal(sp, edge, crv);\n    vec3 sn = getNormal(sp);\n    \n    // Function based bump mapping. the final value is a fade off with\n    // respect to distance.\n    sn = doBumpMap(sp, sn, .2, t/FAR);\n    \n\n    \n    // Fresnel. Handy for all kinds of aesthetic purposes. Not used here.\n    //float fr = clamp(1. + dot(rd, sn), 0., 1.);\n    \n    // Shading. Shadows, ambient occlusion, etc. We're only performing this on the \n    // first pass. Not accurate, but faster, and in most cases, not that noticeable.\n    // In fact, the shadows almost didn't make the cut, but it didn't quite feel \n    // right without them.\n    float sh = softShadow(sp + sn*.002, lp, 12., t); // Set to \"1.,\" if you can do without them.\n    float ao = calculateAO(sp, sn);\n    sh = (sh + ao*.3)*ao;\n    \n\n    // Retrieving the color at the initial hit point.\n    vec3 sceneColor = doColor(ro, sp, rd, sn, lp, edge, crv, ao, t);\n\n    \n   \n    // SECOND PASS\n    \n    // Reflected and refracted rays.\n    vec3 refl = reflect(rd, sn); // Standard reflection.\n    //vec3 refr = refract(rd, sn, 1./1.33); // Water refraction. Note the inverted index.\n    \n    // We're branching off from the same spot in two directions, so we'll use this so as\n    // not to interfere with the original surface point vector, \"sp.\" It was a style\n    // choice on my part, but there are other ways.\n    vec3 refSp; \n    \n    // REFLECTED PASS\n    //\n    // Standard reflected ray, which is just a reflection of the unit\n    // direction ray off of the intersected surface. You use the normal\n    // at the surface point to do that.\n    \n    \n    // Making thing complicated for myself, and anyone trying to read this, just so I\n    // can blend the terrain into the object... In my defence, the unblended dirt doesn't\n    // quite look right sitting against the object. :)\n    float bordTx0Tx1 = oSvObjID.x - oSvObjID.y;\n    const float bordW = .075; // Blend border width... Kind of.\n    \n    // If the ray hits the chrome geometric object, or the ground nearby, perform a\n    // reflective pass.\n    if((svObjID==1. || abs(bordTx0Tx1)<bordW)  && t<FAR){\n\n        // The ray is edged off the surface, as required, but note that it has to be enough\n        // to avoid conflict with the break condition in the \"reflected\" trace algorithm.\n        t = traceRef(sp + refl*.002, refl);\n\n        // Save the object IDs after the second pass.\n        svObjID = objID.x<objID.y? 0. : 1.;\n    \toSvObjID = objID;\n\n\n        // Advancing the ray from the new origin, \"sp,\" to the new reflected hit point.\n        refSp = sp + refl*t;\n\n        // Retrieving the normal at the reflected hit point.\n        sn = getNormal(refSp);\n        \n        // Color at the reflected hit point.\n        vec3 reflColor = doColor(sp, refSp, refl, sn, lp, edge, crv, 1., t);\n        sceneColor = mix(sceneColor, sceneColor + reflColor*1.33, smoothstep(-bordW/2., bordW/2., bordTx0Tx1));\n        //sceneColor = sceneColor + reflColor*1.33;\n        //sceneColor = sceneColor*.35 + mix(reflColor, sceneColor, fr*fr*.66 + .34)*2.5;\n        \n        \n        #ifndef THIRD_PASS\n        // Very cheap third pass: It'd be nice to put a proper third pass in, but we're \n        // pushing our luck as it is, so we'll make do with a makeshift sky reflection.\n      \n        //if((svObjID==1. || abs(bordTx0Tx1)<bordW)  && t<FAR){\n        if(svObjID == 1. && t<FAR){\n            \n            refl = reflect(refl, sn);\n            vec3 sky = getSky(ro, refl, lp);\n            sceneColor = mix(sceneColor, sceneColor*.7 + sceneColor*sky*5.*vec3(1.15, 1, .85), smoothstep(-bordW/2., bordW/2., bordTx0Tx1));\n      \n            //sceneColor = sceneColor + tpCol*sky*4.;\n            //sceneColor = sceneColor*.7 + tpCol;\n            //sceneColor = sceneColor*.35 + mix(reflColor, sceneColor, fr*fr*.66 + .34)*2.5;\n            \n        }\n        #endif\n    \n    }\n    \n    /*\n\t// Really bad cheap reflection pass. Only here for debug purposes. \n    //if(svObjID==1. && t<FAR){\n    if((svObjID==1. || abs(bordTx0Tx1)<bordW)  && t<FAR){\n        \n         vec3 sky = getSky(sp, refl, lp);\n         sceneColor = mix(sceneColor, sceneColor + sceneColor*sky*20., smoothstep(-bordW/2., bordW/2., bordTx0Tx1));\n      \n    }\n    */\n    \n    #ifdef THIRD_PASS\n    // More correct third pass: Since it's just a reflection off a reflection of one\n    // object, we're not using it by default, but it's there if you want it.\n    if(svObjID == 1. && t<FAR){\n        \n        refl = reflect(refl, sn);\n        \n        t = traceRef(refSp + refl*.002, refl);\n\n        // Save the object IDs after the third pass.\n        svObjID = objID.x<objID.y? 0. : 1.;\n    \toSvObjID = objID;\n        \n\n        // Advancing the ray from the new origin, \"sp,\" to the new reflected hit point.\n        refSp = refSp + refl*t;\n\n        // Retrieving the normal at the reflected hit point.\n        sn = getNormal(refSp);//*rDir;\n        //edge = 0.;\n\n        \n        // Color at the reflected hit point.\n        vec3 reflColor = doColor(sp, refSp, refl, sn, lp, edge, crv, 1., t);\n        sceneColor = mix(sceneColor, sceneColor + reflColor*1.33, smoothstep(-bordW/2., bordW/2., bordTx0Tx1));\n     \n        //sceneColor = sceneColor + reflColor*1.25; \n    }\n    #endif\n     \n    // APPLYING SHADOWS\n    //\n    // Multiply the shadow from the first pass by the final scene color. Ideally, you'd check to\n    // see if the reflected point was in shadow, and incorporate that too, but we're cheating to\n    // save cycles and skipping it. It's not really noticeable anyway.\n    sceneColor *= sh;\n    \n    \n    \n   \n    // POSTPROCESSING\n    // Interesting red to blueish mix.\n    //sceneColor = mix(sceneColor, pow(min(vec3(1.5, 1, 1)*sceneColor, 1.), vec3(1, 2.5, 12.)), uv.y);\n    //sceneColor = pow(max(sceneColor, 0.), vec3(1.25))*1.33; // Adding a bit of contrast.\n    //sceneColor *= mix(vec3(1.2, 1, .9).yxz, vec3(1.2, 1, .9).zyx, -rd.y*.5 + .5);\n    \n    /*\n    vec2 u2 = uv*r2(3.14159/6.);\n    float overlay = 1. + .35*sin(u2.x*3.14159*iResolution.y/1.5);\n    overlay *= 1. + .35*sin(u2.y*3.14159*iResolution.y/1.5); \n    sceneColor *= overlay*1.1;\n    */\n    \n    // Subtle vignette.\n    uv = fragCoord/iResolution.xy;\n    sceneColor *= pow(16.*uv.x*uv.y*(1. - uv.x)*(1. - uv.y) , .0625)*.5 + .5;\n    // Colored varation.\n    //sceneColor = mix(pow(min(vec3(1.5, 1, 1)*sceneColor, 1.), vec3(1, 2.5, 12.)).zyx, sceneColor, \n                    // pow( 16.0*uv.x*uv.y*(1.0-uv.x)*(1.0-uv.y) , .125)*.5 + .5);\n    \n    \n\n    // Clamping the scene color, then presenting to the screen.\n\tfragColor = vec4(sqrt(max(sceneColor, 0.)), 1);\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttXGWH.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[2303, 2325, 2346, 2695, 3198], [3201, 3366, 3386, 3386, 3444], [3446, 3546, 3568, 3660, 3839], [3841, 3867, 3899, 3899, 3963], [3966, 4034, 4052, 4052, 4403], [4406, 4455, 4493, 4493, 4588], [4593, 4817, 4836, 4836, 5105], [5107, 5185, 5203, 5203, 5276], [5277, 5277, 5298, 5298, 5337], [5339, 5537, 5557, 5557, 5588], [5589, 5611, 5632, 5632, 5667], [5688, 5716, 5733, 5733, 5785], [5786, 5786, 5806, 5806, 5860], [5862, 5909, 5926, 5926, 6488], [6490, 6574, 6594, 6594, 6932], [6934, 6955, 6981, 7001, 7157], [7159, 7195, 7224, 7244, 7403], [7405, 7635, 7655, 7823, 8058], [8060, 8170, 8190, 8230, 8429], [8514, 8514, 8536, 8536, 10133], [10136, 10208, 10226, 10271, 10722], [10725, 10758, 10788, 10788, 11056], [11058, 11468, 11501, 11501, 11725], [11729, 11748, 11786, 11786, 12795], [12798, 12989, 13055, 13156, 14171], [14175, 14476, 14529, 14646, 15927], [15930, 16030, 16057, 16057, 16214], [16218, 16218, 16257, 16304, 17994], [17997, 18067, 18103, 18251, 20050], [20052, 20190, 20305, 20361, 22210], [22212, 22364, 22409, 22409, 22655], [22658, 22658, 22714, 22742, 31250]], "test": "error"}
{"id": "wd2SD3", "name": "Borromean Rings", "author": "dr2", "description": "Couldn't find any here...", "tags": ["torus", "illusion"], "likes": 5, "viewed": 317, "published": "Public API", "date": "1555176621", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// \"Borromean Rings\" by dr2 - 2019\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\n#define AA  1   // optional antialiasing\n\nfloat PrTorusDf (vec3 p, float ri, float rc);\nfloat SmoothBump (float lo, float hi, float w, float x);\nvec2 Rot2D (vec2 q, float a);\nvec3 VaryNf (vec3 p, vec3 n, float f);\n\nvec3 ltDir, qHit;\nfloat dstFar;\nint idObj;\nconst float pi = 3.14159;\n\n#define DMINQ(id) if (d < dMin) { dMin = d;  idObj = id;  qHit = q; }\n\nfloat ObjDf (vec3 p)\n{\n  vec3 q, ds;\n  float dMin, d;\n  dMin = dstFar;\n  ds = vec3 (0.92, 1.07, 1.);\n  q = p * ds;\n  d = PrTorusDf (q, 1., 15.);\n  DMINQ (1);\n  q = p.zxy * ds;\n  d = PrTorusDf (q, 1., 15.);\n  DMINQ (2);\n  q = p.yzx * ds;\n  d = PrTorusDf (q, 1., 15.);\n  DMINQ (3);\n  return 0.8 * dMin;\n}\n\nfloat ObjRay (vec3 ro, vec3 rd)\n{\n  float dHit, d;\n  dHit = 0.;\n  for (int j = 0; j < 80; j ++) {\n    d = ObjDf (ro + dHit * rd);\n    if (d < 0.0005 || dHit > dstFar) break;\n    dHit += d;\n  }\n  return dHit;\n}\n\nvec3 ObjNf (vec3 p)\n{\n  vec4 v;\n  vec2 e = vec2 (0.0002, -0.0002);\n  v = vec4 (- ObjDf (p + e.xxx), ObjDf (p + e.xyy), ObjDf (p + e.yxy), ObjDf (p + e.yyx));\n  return normalize (2. * v.yzw - dot (v, vec4 (1.)));\n}\n\nfloat ObjSShadow (vec3 ro, vec3 rd)\n{\n  float sh, d, h;\n  sh = 1.;\n  d = 0.1;\n  for (int j = 0; j < 30; j ++) {\n    h = ObjDf (ro + d * rd);\n    sh = min (sh, smoothstep (0., 0.05 * d, h));\n    d += clamp (h, 0.2, 1.);\n    if (sh < 0.05) break;\n  }\n  return 0.3 + 0.7 * sh;\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  vec4 col4;\n  vec3 col, vn;\n  float dstObj, sh, nDotL;\n  dstObj = ObjRay (ro, rd);\n  if (dstObj < dstFar) {\n    ro += dstObj * rd;\n    vn = ObjNf (ro);\n    vn = VaryNf (4. * ro, vn, 8.);\n    if (idObj == 1) col4 = vec4 (1., 0.2, 0.2, 0.2);\n    else if (idObj == 2) col4 = vec4 (0.2, 1., 0.2, 0.2);\n    else if (idObj == 3) col4 = vec4 (0.2, 0.2, 1., 0.2);\n    col4.rgb *= 0.3 + 0.7 * SmoothBump (0.07, 0.93, 0.02,\n       mod (64. * atan (qHit.y, - qHit.x) / (2. * pi), 1.));\n    sh = ObjSShadow (ro, ltDir);\n    nDotL = max (dot (vn, ltDir), 0.);\n    nDotL *= nDotL;\n    col = col4.rgb * (0.2 + 0.8 * sh * nDotL * nDotL) +\n       col4.a * step (0.95, sh) * sh * pow (max (dot (normalize (ltDir - rd), vn), 0.), 32.);\n  } else col = vec3 (0.1);\n  return clamp (col, 0., 1.);\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  mat3 vuMat;\n  vec4 mPtr;\n  vec3 ro, rd, col;\n  vec2 canvas, uv, ori, ca, sa;\n  float tCur, el, az, zmFac, sr;\n  canvas = iResolution.xy;\n  uv = 2. * fragCoord.xy / canvas - 1.;\n  uv.x *= canvas.x / canvas.y;\n  tCur = iTime;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / canvas - 0.5;\n  az = 0.;\n  el = 0.;\n  if (mPtr.z > 0.) {\n    az += 2. * pi * mPtr.x;\n    el += pi * mPtr.y;\n  } else {\n    az += 0.47 * tCur;\n    el += 0.43 * tCur;\n  }\n  ori = vec2 (el, az);\n  ca = cos (ori);\n  sa = sin (ori);\n  vuMat = mat3 (ca.y, 0., - sa.y, 0., 1., 0., sa.y, 0., ca.y) *\n          mat3 (1., 0., 0., 0., ca.x, - sa.x, 0., sa.x, ca.x);\n  ro = vuMat * vec3 (0., 0., -60.);\n  zmFac = 3.;\n  dstFar = 100.;\n  ltDir = vuMat * normalize (vec3 (1., 1., -1.));\n#if ! AA\n  const float naa = 1.;\n#else\n  const float naa = 3.;\n#endif  \n  col = vec3 (0.);\n  sr = 2. * mod (dot (mod (floor (0.5 * (uv + 1.) * canvas), 2.), vec2 (1.)), 2.) - 1.;\n  for (float a = 0.; a < naa; a ++) {\n    rd = vuMat * normalize (vec3 (uv + step (1.5, naa) * Rot2D (vec2 (0.5 / canvas.y, 0.),\n       sr * (0.667 * a + 0.5) * pi), zmFac));\n    col += (1. / naa) * ShowScene (ro, rd);\n  }\n  fragColor = vec4 (pow (col, vec3 (0.8)), 1.);\n}\n\nfloat PrTorusDf (vec3 p, float ri, float rc)\n{\n  return length (vec2 (length (p.xy) - rc, p.z)) - ri;\n}\n\nfloat SmoothBump (float lo, float hi, float w, float x)\n{\n  return (1. - smoothstep (hi - w, hi + w, x)) * smoothstep (lo - w, lo + w, x);\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  vec2 cs;\n  cs = sin (a + vec2 (0.5 * pi, 0.));\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nconst float cHashM = 43758.54;\n\nvec2 Hashv2v2 (vec2 p)\n{\n  vec2 cHashVA2 = vec2 (37., 39.);\n  return fract (sin (vec2 (dot (p, cHashVA2), dot (p + vec2 (1., 0.), cHashVA2))) * cHashM);\n}\n\nfloat Noisefv2 (vec2 p)\n{\n  vec2 t, ip, fp;\n  ip = floor (p);  \n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = mix (Hashv2v2 (ip), Hashv2v2 (ip + vec2 (0., 1.)), fp.y);\n  return mix (t.x, t.y, fp.x);\n}\n\nfloat Fbmn (vec3 p, vec3 n)\n{\n  vec3 s;\n  float a;\n  s = vec3 (0.);\n  a = 1.;\n  for (int j = 0; j < 5; j ++) {\n    s += a * vec3 (Noisefv2 (p.yz), Noisefv2 (p.zx), Noisefv2 (p.xy));\n    a *= 0.5;\n    p *= 2.;\n  }\n  return dot (s, abs (n));\n}\n\nvec3 VaryNf (vec3 p, vec3 n, float f)\n{\n  vec3 g;\n  vec2 e = vec2 (0.1, 0.);\n  g = vec3 (Fbmn (p + e.xyy, n), Fbmn (p + e.yxy, n), Fbmn (p + e.yyx, n)) - Fbmn (p, n);\n  return normalize (n + f * (g - n * dot (n, g)));\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wd2SD3.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[479, 479, 501, 501, 781], [783, 783, 816, 816, 992], [994, 994, 1015, 1015, 1207], [1209, 1209, 1246, 1246, 1484], [1486, 1486, 1521, 1521, 2298], [2300, 2300, 2356, 2356, 3545], [3547, 3547, 3593, 3593, 3650], [3652, 3652, 3709, 3709, 3792], [3794, 3794, 3824, 3824, 3937], [3971, 3971, 3995, 3995, 4125], [4127, 4127, 4152, 4152, 4338], [4340, 4340, 4369, 4369, 4581], [4583, 4583, 4622, 4622, 4802]], "test": "error"}
{"id": "wd2SR3", "name": "Simple Raymarching Example Scene", "author": "samlo", "description": "When I started learning ray marching I basically just wanted pre-built \"scene\" that I could dive into and start tinkering with, so here is a simple example that does exactly that! No step-by-step tutorial, just simple explanations of what everything does.", "tags": ["raymarching", "sdf", "tutorial"], "likes": 9, "viewed": 823, "published": "Public API", "date": "1554572003", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Title: Simple Raymarching Example Scene\n// Author: Sam Loeschen https://twitter.com/samloeschen\n\n// Description:\n// When I started learning raymarching I basically just wanted pre-built \"scene\" that I could dive into and start tinkering with,\n// so here is a simple example that does exactly that! No step-by-step tutorial, just simple explanations of what everything does.\n// If you want to start messing around, the first thing I would do is modify the scene() function with more shapes. You can find \n// more primitive at http://iquilezles.org/www/articles/distfunctions/distfunctions.htm. \n\n// Things to try:\n// 1. Check out ourBox() and ourSphere() to see how I animated the primitives and gave them material IDs.\n// 2. See if you can add a shape and material of your own.\n// 3. Play with the camera and directional light, and see if you can animate them.\n\n#define RAYMARCH_STEPS 50\n#define EPSILON 0.005\n#define BACKGROUND vec4(0, 0.3, 0.3, 1) // windows 95?\n#define MIN_DIST 0.01\n#define MAX_DIST 100.0\n\n#define BLUE_MATERIAL_ID 0.5\n#define RED_MATERIAL_ID 1.0\n\n// iq's axis to direction rotation. Aligns an axis (z) to point along a direction (d)\nmat3 rotationAlign(vec3 d, vec3 z) {\n    vec3  v = cross( z, d );\n    float c = dot( z, d );\n    float k = 1.0/(1.0+c);\n\n    return mat3(v.x*v.x*k + c,     v.y*v.x*k - v.z,    v.z*v.x*k + v.y,\n                v.x*v.y*k + v.z,   v.y*v.y*k + c,      v.z*v.y*k - v.x,\n                v.x*v.z*k - v.y,   v.y*v.z*k + v.x,    v.z*v.z*k + c    );\n}\n\n\n// composes a view matrix for a direction and global up vector\n// based on gluLookAt man page\nmat4 viewMatrix (vec3 dir, vec3 up) { \n    vec3 f = normalize(dir);\n    vec3 s = normalize(cross(f, up));\n    vec3 u = cross(s, f);\n    return mat4(\n        vec4(s, 0.0),\n        vec4(u, 0.0),\n        vec4(-f, 0.0),\n        vec4(0.0, 0.0, 0.0, 1)\n    );\n}\n\n// simple box sdf. for a library of other primitives, see http://iquilezles.org/www/articles/distfunctions/distfunctions.htm\nfloat box (vec3 pos, vec3 size) {\n  vec3 d = abs(pos) - size;\n  return length(max(d, 0.0)) + min(max(d.x, max(d.y, d.z)), 0.0);\n}\n\n// simple sphere sdf. for a library of other primitives, see http://iquilezles.org/www/articles/distfunctions/distfunctions.htm\nfloat sphere(vec3 pos, float radius) {\n  return length(pos) - radius;\n}\n\n// returns the distance to our rotating box and the its associated material ID packed into a vec2\nvec2 ourBox (vec3 pos) {\n\n    // get a rotation matrix for our box's rotation\n    vec3 dir = normalize(vec3(cos(iTime * 0.5), 0.0, sin(iTime * 0.5)));\n    vec3 axis = normalize(vec3(0.0, 1.0, 0.0)); // up\n    mat3 rotation = rotationAlign(dir, axis);\n\n    // rotate our world point with the box's rotation matrix\n    pos *= rotation;\n    return vec2(box(pos, vec3(1.0)), BLUE_MATERIAL_ID);\n}\n\n// returns the distance to our moving sphere and the its associated material ID packed into a vec2\nvec2 ourSphere (vec3 pos) {\n\n    // just translate the sphere up and down\n    vec3 offset = vec3(sin(iTime * 0.5), sin(iTime) * 3.0, cos(iTime) * 3.0);\n    pos += offset;\n    \n    return vec2(sphere(pos, 1.0), RED_MATERIAL_ID);\n}\n\n// this is the combined scene sdf function! if you want to add shapes, put them in here.\n// it returns a vec2 containing a depth value for the x coordinate, and a material ID for the y coordinate.\nvec2 scene (vec3 pos) {\n    // test our shapes\n    vec2 boxTest        = ourBox(pos);\n    vec2 sphereTest     = ourSphere(pos);\n    vec2 result         = boxTest;\n\n    // we want to return the nearest surface, so we sort by distance\n    result = mix(result, sphereTest, step(sphereTest.x, result.x));\n\n    // if you want to add more shapes, modify the result like so:\n    // result = mix(result, yourNewShapeTest, step(yourNewShapeTest.x, result.x));\n    return result;\n}\n\n// creates a view space ray going out from the camera\nvec3 calcRay (float fieldOfView, vec2 size, vec2 fragCoord) {\n    vec2 xy = fragCoord - size * 0.5;\n    float z = size.y / tan(radians(fieldOfView) * 0.5);\n    return normalize(vec3(xy, -z));\n}\n\n// gets an estimated normal of the scene sdf at a given point\n// we use the x coord because that is the depth value that is returned from the scene\nvec3 calcNormal (vec3 pos) {\n    const vec2 eps = vec2(EPSILON, 0);\n    return normalize(vec3(scene(pos + eps.xyy).x - scene(pos - eps.xyy).x,\n                          scene(pos + eps.yxy).x - scene(pos - eps.yxy).x,\n                          scene(pos + eps.yyx).x - scene(pos - eps.yyx).x));\n}\n\n// returns a color based on the material id from the scene sample\n// right now it uses gross branching, but this could be eliminated with clever usage of step()\nvec3 calcMaterial (float id) {\n    if (id == RED_MATERIAL_ID)      return vec3(1, 0, 0);\n    if (id == BLUE_MATERIAL_ID)     return vec3(0, 0, 1);\n    return vec3(1);\n}\n\n// raymarches our scene with a provided camera position, camera direction, and simple directional light\nvec4 marchScene (vec2 fragCoord, vec3 camPos, vec3 camDir, vec3 lightDir) {\n    \n    // calculate the world direction of the ray at this pixel\n    vec3 viewDir = calcRay(45.0, iResolution.xy, fragCoord.xy);\n    mat4 viewMat = viewMatrix(\n        camDir,\n        vec3(0.0, 1.0, 0.0)\n    );\n    vec3 worldDir = (viewMat * vec4(viewDir, 1)).xyz;\n\n    // do our raymarching!\n    float depth = MIN_DIST;\n    for (int i = 0; i < RAYMARCH_STEPS; i++) {\n        vec3 rayPos = camPos + depth * worldDir;\n\n        // sample the scene at this point in the ray.\n        // the sample's x coord is our distance value, and the y coord is the material id\n        vec2 sceneSample = scene(rayPos);\n        float shortestDist = sceneSample.x;\n        float materialId = sceneSample.y;\n\n        if (shortestDist < EPSILON) {\n\n            // we hit something, so get estimate our normal to do lighting and return a material color\n            vec3 normal = calcNormal(rayPos);\n            float light = max(dot(lightDir, normal) * 0.5 + 0.5, 0.15); // half lambert with a floor\n            vec3 surfaceColor = calcMaterial(materialId);\n            vec4 outputColor = vec4(surfaceColor * light, 1.0);\n            return outputColor;\n        }\n\n        // increase the depth of our ray by the shortest distance to an object in the scene.\n        // since we know how far away everything is, we don't need to increment our ray in tiny steps!\n        depth += shortestDist;\n\n        // we reached our max distance and didn't hit anything, so just return the background\n        if (depth > MAX_DIST - EPSILON) {\n            return BACKGROUND;\n        }\n    }\n    return BACKGROUND;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // let's place the camera 20 units away from the origin on the negative z axis,\n    // and orient it to look at the center of the scene\n    vec3 camPos = vec3(0, 0, 20); \n    vec3 camDir = normalize(-camPos);\n\n    // we'll have our light coming from above and behind us\n    vec3 lightDir = normalize(vec3(0, 1, 1));\n\n    fragColor = marchScene(fragCoord, camPos, camDir, lightDir);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wd2SR3.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1072, 1158, 1194, 1194, 1499], [1502, 1596, 1633, 1633, 1851], [1853, 1978, 2011, 2011, 2107], [2109, 2237, 2275, 2275, 2308], [2310, 2408, 2432, 2485, 2799], [2801, 2900, 2927, 2973, 3129], [3131, 3328, 3351, 3374, 3799], [3801, 3855, 3916, 3916, 4048], [4050, 4198, 4226, 4226, 4494], [4496, 4657, 4687, 4687, 4825], [4827, 4931, 5006, 5073, 6589], [6591, 6591, 6646, 6786, 7034]], "test": "ok"}
{"id": "Wd2SRd", "name": "Finals1 - Candle v2.0", "author": "EmperorLem", "description": "Candle using noise", "tags": ["noise"], "likes": 2, "viewed": 99, "published": "Public", "date": "1554732206", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec3 black = vec3(0.0,0.0,0.0);\nvec3 red = vec3(0.7,0.4,0.0);\nvec3 blue = vec3(0.0,.8,0.8);\nvec3 gold = vec3(0.9,0.9,0.0);\nvec3 white = vec3(1.0,1.0,1.0);\n\nfloat rand(vec2 uv)\n{\n    //return fract(sin(dot(uv, vec2(12.9898,78.233)))*10000.*iTime);\n\t//return fract(sin(dot(uv, iMouse.xy))*10000.);\n\t//return (fract(sin(dot(uv, vec2(12., 70.)))*100000.));\n    return (fract(sin(dot(uv, vec2(12., 70.)))*43758.5453123));\n}\n\n// Value noise\nfloat noise(in vec2 st) {\n    vec2 i = floor(st);\n    vec2 f = fract(st);\n\n    // Four corners in 2D of a tile\n    float a = rand(i);\n    float b = rand(i + vec2(1.0, 0.0));\n    float c = rand(i + vec2(0.0, 1.0));\n    float d = rand(i + vec2(1.0, 1.0));\n\n    // Smooth Interpolation\n\n    // Cubic Hermine Curve.  Same as SmoothStep()\n    vec2 u = f*f*(3.0-2.0*f);\n    // u = smoothstep(0.,1.,f);\n\n    // Mix 4 coorners porcentages\n    return mix(a, b, u.x) + \n            (c - a)* u.y * (1.0 - u.x) + \n            (d - b) * u.x * u.y;\n}\n\nvec3 circle(vec2 uv, vec2 pos)\n{       \n    uv.x *= iResolution.x/iResolution.y;\n    \n    float d = length(uv - pos) *0.5;    \n    \n    float offset = noise(uv*4.+vec2(.0, -iTime*4.))*.1;\n    \n    float r = 0.09;\n    float rate = clamp(sin(20.0 * r * iTime)*r , 0.25, 0.30);\n    float circle = smoothstep(rate, r, d+offset);\n    vec3 mixed = mix(black, red, circle);\n    \n    return mixed;\n}\n\nvec3 circle2(vec2 uv, vec2 pos)\n{       \n    uv.x *= iResolution.x/iResolution.y;\n    \n    float d = length(uv - pos);    \n    \n    float offset = noise(uv*4.+vec2(.0, -iTime*4.))*.1;\n    \n    float r = 0.01;\n    float rate = clamp(sin(20.0 * r * iTime)*r , 0.25, 0.30);\n    float circle2 = smoothstep(rate, r, d+offset);\n    vec3 mixed = mix(black, gold, circle2);\n    \n    return mixed;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    float height = step(0.0,uv.y) - step(0.35,uv.y);\n    float width = step(0.4,uv.x) -step(0.6,uv.x);\n                                          \n    // Time varying pixel color\n    //vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n    \n    vec3 image = mix(black, blue, height * width);\n    \n    height = step(0.35,uv.y) - step(0.45,uv.y);\n    width = step(0.5,uv.x) -step(0.51,uv.x);\n        \n    image = mix(image, white, height * width);\n    \n    vec3 mCircle = circle(uv, vec2(0.89,0.52));\n    \n    image = mix(mCircle, image, image);\n    \n    vec3 mCircle2 = circle2(uv, vec2(0.89,0.52));\n    \n    image = mix(mCircle2, image, image);\n\n    // Output to screen\n    fragColor = vec4(image,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Wd2SRd.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[156, 156, 177, 352, 418], [420, 435, 460, 460, 971], [973, 973, 1005, 1005, 1364], [1366, 1366, 1399, 1399, 1756], [1758, 1758, 1815, 1865, 2611]], "test": "ok"}
{"id": "Wd2Sz1", "name": "Ufo", "author": "SolidTux", "description": "ufo", "tags": ["ufo"], "likes": 0, "viewed": 50, "published": "Public", "date": "1554751049", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const float EPS = 0.0001;\nconst float PI = acos(-1.);\n\nvoid sphere(in vec3 pos, out float d, in float r)\n{\n    d = length(pos) - r;\n}\n\nmat2 rot(in float phi)\n{\n    return mat2(cos(phi), -sin(phi), sin(phi), cos(phi));\n}\n\nvoid random2f(in ivec2 pos, out vec2 o) {\n    o = vec2(\n            fract(sin(dot(vec2(pos) ,vec2(12.9898,78.233))) * 43758.5453),\n            fract(sin(dot(vec2(pos) ,vec2(58.1213,32.422))) * 31671.8792)\n        );\n}\n\nvoid voronoi(in vec3 pos, out float res) {\n    vec2 x = 4.*pos.xy;\n    ivec2 p = ivec2(floor(x));\n    vec2 f = fract(x);\n\n    ivec2 mb;\n    vec2 mr;\n    res = 8.0;\n    for (int j=-1; j<=1; j++) {\n        for (int i=-1; i<=1; i++) {\n            ivec2 b = ivec2(i, j);\n            vec2 r;\n            random2f(p + b, r);\n            r += vec2(b) - f;\n            float d = dot(r, r);\n            if (d < res) {\n                res = d;\n                mb = b;\n                mr = r;\n            }\n        }\n    }\n    res = 8.0;\n    for (int j=-1; j<=1; j++) {\n        for (int i=-1; i<=1; i++) {\n            ivec2 b = mb + ivec2(i, j);\n            vec2 r;\n            random2f(p + b, r);\n            r += vec2(b) - f;\n            float d = dot(0.5*(mr+r), normalize(r-mr));\n            res = min(res, d);\n        }\n    }\n}\n\n\nvoid beam(in vec3 pos, out float d)\n{\n    if (pos.z > 0.)\n    {\n        d = 10000.;\n    } else\n    {\n        d = length(pos.xy) - (0.2 - 0.1 * pos.z);\n    }\n}\n\nvoid huergb(in float hue, out vec3 color)\n{\n    float h = mod(hue, 1.);\n    float f = mod(6. * h, 1.);\n    if (6. * h < 1.)\n    {\n        color = vec3(1., f, 0.);\n    } else if (6. * h < 2.)\n    {\n        color = vec3(1. - f, 1., 0.);\n    } else if (6. * h < 3.)\n    {\n        color = vec3(0., 1., f);\n    } else if (6. * h < 4.)\n    {\n        color = vec3(0., 1. - f, 1.);\n    } else if (6. * h < 5.)\n    {\n        color = vec3(f, 0., 1.);\n    } else\n    {\n        color = vec3(1., 0., 1. - f);\n    }\n}\n\nvoid ufocolor(in vec3 pos, out vec3 color, in bool b, in vec3 bcolor, out float d)\n{\n    float r = smoothstep(0., 1., length(pos.xy));\n    float phi = atan(pos.x, pos.y);\n    if (pos.z < 0.)\n    {   \n           d = 0.02 * sin(3. * PI * r) * (0.2 / r + 1.);\n        vec3 c = vec3(0.2);\n        if (b)\n        {\n            huergb(phi / (2.*PI) + 0.5 * r - 0.5 * iTime, c);\n            c = mix(\n                bcolor,\n                c,\n                smoothstep(0.5, 0.7, r)\n            );\n        }\n        color = mix(\n            c,\n            vec3(0.),\n            smoothstep(0.25 * PI - 0.05, 0.25 * PI + 0.05, r)\n        );\n    } else\n    {\n        float f = mod(3.5 * phi / PI + 0.5, 1.) - 0.5;\n        f = smoothstep(0.1, 0.2, abs(f));\n        vec3 c = mix(\n            vec3(0., 0., 0.5),\n            vec3(0.4),\n            f\n        );\n        color = mix(\n            c,\n            vec3(0.1),\n            smoothstep(0.925, 0.95, r)\n        );\n        d = 0.025 * f * smoothstep(1., 0.9, r);\n        d += 0.1 * smoothstep(0.5, 0., r);\n    }\n    float v;\n    voronoi(pos, v);\n    v = smoothstep(0.1, 0., v);\n    d -= 0.02*v;\n    color *= 1. - 0.2*v;\n}\n\nvoid ufo(in vec3 r, in bool b, in vec3 bcolor, out vec3 color, out vec4 m, out float d)\n{\n    float d3, d4, d5, dis;\n    float rad = length(r);\n    float angle = atan(r.y, r.x);\n    vec3 c;\n    ufocolor(r, color, b, bcolor, dis);\n    m = vec4(20., 0.3, 0.5, 0.2);\n    if (r.z < 0.)\n    {\n    \tsphere(r - vec3(0., 0., 1.75), d, 2. + dis);\n    } else\n    {\n    \tsphere(r + vec3(0., 0., 1.75), d, 2. + dis);\n    }\n    if (b)\n    {\n        beam(r, d4);\n        if (d > d4)\n        {\n            d = d4;\n            color = bcolor * 0.5;\n            m = vec4(1., 1., 0., 0.);\n        }\n    }\n    float phi = mod(angle + PI/7., 2.*PI/7.);\n    vec3 r2 = vec3(vec2(rad*sin(phi), rad*cos(phi)), r.z);\n    sphere(r2 - vec3(0.7*sin(PI/14.), 0.7*cos(PI/14.), 0.1), d4, 0.1);\n    if (d > d4)\n    {\n        d = d4;\n        color = clamp(sin(10.* iTime + angle) - 0.2, 0.05, 1.)*vec3(1., 1., 0.2);\n        m = vec4(1., 0.9, 0.1, 0.);\n    }\n}\n\nvoid scene(in vec3 pos, out vec3 color, out vec4 m, out float d)\n{\n    float d1;\n    vec3 color1;\n    vec4 m1;\n    \n    d = 10000.;\n    \n    vec3 r = vec3(0.);\n    r.x = 3.*cos(iTime);\n    r.y = 2.*sin(iTime);\n    r = pos - r;\n    float rand1 = fract(sin(floor(iTime)) * 47828.12);\n    float rand2 = fract(sin(floor(iTime) + 1.) * 47828.12);\n    float rand3 = fract(sin(floor(5.*iTime) + 1.) * 12311.41);\n    float phi = 0.2*smoothstep(rand1, rand2, fract(iTime)) + sin(2.*iTime);\n    vec3 bcolor;\n    huergb(0.1 * (2. + sin(0.2 * iTime)) * r.z + 0.8 * iTime, bcolor);\n    bcolor *= 0.95;\n    r.xy = rot(iTime - PI/.4)*r.xy;\n    r.yz = rot(0.3*sin(phi))*r.yz;\n    \n    ufo(r, rand3 > 0.2, bcolor, color1, m1, d1);\n\n    if (d > d1)\n    {\n        d = d1;\n        color = color1;\n        m = m1;\n    }\n}\n\nvoid norm(in vec3 p, out vec3 n) {\n    float x1, x2, y1, y2, z1, z2;\n    vec3 c;\n    vec4 m;\n    scene(vec3(p.x + EPS, p.y, p.z), c, m, x1);\n    scene(vec3(p.x - EPS, p.y, p.z), c, m, x2);\n    scene(vec3(p.x, p.y + EPS, p.z), c, m, y1);\n    scene(vec3(p.x, p.y - EPS, p.z), c, m, y2);\n    scene(vec3(p.x, p.y, p.z + EPS), c, m, z1);\n    scene(vec3(p.x, p.y, p.z - EPS), c, m, z2);\n    n = normalize(vec3(x1 - x2, y1 - y2, z1 - z2));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    float scale = 1.5;\n    \n    vec2 uv = fragCoord/iResolution.xy;\n    vec3 color = texture(iChannel0, uv).rgb;\n    uv = 2.*uv - 1.0;\n    uv.x *= iResolution.x/iResolution.y;\n    uv *= scale;\n    \n    vec3 o = vec3(10., 0., 0.7 + 4.*sin(1.1*iTime));\n    vec3 t = vec3(0., 0., -0.7);\n    vec3 dir = normalize(t - o);\n    \n    vec3 up = vec3(0.0, 0.0, 1.0);\n    vec3 right = normalize(cross(dir, up));\n    t += scale*uv.x * right + scale*uv.y * up;\n    dir = normalize(t - o);\n    \n    float depth = 0.0;\n    float dis;\n    vec3 n, c;\n    vec4 m;\n    for (int i=0; i<100; i++) {\n        vec3 pos = o + depth * dir;\n        scene(pos, c, m, dis);\n        if (dis < EPS) {\n            norm(pos, n);\n            vec3 l;\n            color = vec3(0.);\n            for (int j=0; j<2; j++)\n            {\n                if (j == 0)\n                {\n                    l = normalize(pos - vec3(-3., 0., 1.));\n                } else\n                {\n                    l = normalize(pos - vec3(0., 3.*sin(1.2*iTime), 5.*cos(1.2*iTime)));\n                }\n                float diff = clamp(dot(l, n), 0.0, 1.0);\n                vec3 r = normalize(2.0*n*dot(n, -l) + l);\n                float spec = clamp(dot(r, -dir), 0.0, 1.0);\n                spec = pow(spec, m.x);\n                color += clamp((m.y + diff * m.z)* c.rgb + m.w * spec * vec3(1.), 0.0, 1.0);    \n            }\n            break;\n        }\n        depth += dis;\n        if (depth >= 50.)\n        {\n            break;\n        }\n    }\n    \n    fragColor = vec4(color, 1.);\n}", "image_inputs": [{"id": "4dfGRn", "previewfilepath": "/media/ap/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Wd2Sz1.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[55, 55, 106, 106, 133], [135, 135, 159, 159, 219], [221, 221, 262, 262, 438], [440, 440, 482, 482, 1261], [1264, 1264, 1301, 1301, 1422], [1424, 1424, 1467, 1467, 1927], [1929, 1929, 2013, 2013, 3091], [3093, 3093, 3182, 3182, 4019], [4021, 4021, 4087, 4087, 4821], [4823, 4823, 4857, 4857, 5257], [5259, 5259, 5314, 5314, 6851]], "test": "error"}
{"id": "wd2Sz3", "name": "On Track", "author": "Passion", "description": "Enjoy", "tags": ["raymarch", "sky", "life", "track"], "likes": 14, "viewed": 309, "published": "Public", "date": "1554583948", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define NUM_STEPS 128\n#define FUDGE_AMOUNT 0.75\n#define EPS 0.001\n#define FAR 50.0\n\n#define PI 3.1415926535898\n\n\nvec3 tri(in vec3 x){return abs(x-floor(x)-.5);} // Triangle function.\n\nfloat surfFunc(in vec3 p){\n\treturn dot(tri(p*0.5 + tri(p*0.25).yzx), vec3(0.777));\n}\n\nvec2 path(in float z){ float s = sin(z/34.)*cos(z/12.)*cos(sin(z/20.)); return vec2(s*12.+sin(s)*6.1, s*15.); }\n\nmat3 lookAtMatrix(vec3 origin, vec3 target, float roll) {\n    vec3 rr = vec3(sin(roll), cos(roll), 0.0);\n    vec3 ww = normalize(target - origin);\n    vec3 uu = normalize(cross(ww, rr));\n    vec3 vv = normalize(cross(uu, ww));\n\n    return mat3(uu, vv, ww);\n}\n\nmat2 r2(float a){\n    float s = sin(a);\n    float c = cos(a);\n    return mat2(s, -c, c, s);\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return length(max(d,0.0))\n         + min(max(d.x,max(d.y,d.z)),0.0); // remove this line for an only partially signed sdf \n}\n\nfloat sdRoundBox( vec3 p, vec3 b, float r )\n{\n  vec3 d = abs(p) - b;\n  return length(max(d,0.0)) - r\n         + min(max(d.x,max(d.y,d.z)),0.0); // remove this line for an only partially signed sdf \n}\n\nfloat trackPlanks(vec3 tp){\n    tp.xy = (tp.xy - path(tp.z))*vec2(0.5, 0.47071);\n    tp.z = mod(tp.z, 1.) -0.5;\n    float bmp2 = texture(iChannel1, tp.xz/4.).r*.015;\n    return sdBox(vec3(tp.x,tp.y+1.4,tp.z), vec3(1., .05152, .2))+bmp2;\n}\nfloat trackRails(vec3 tp){\n    tp.xy = (tp.xy - path(tp.z))*vec2(0.5, 0.47071);\n    tp.z = mod(tp.z, 1.) -0.5;\n    tp.x = abs(tp.x)-1.;\n    return sdRoundBox(vec3(tp.x, tp.y+1.3, tp.z), vec3(.015, .015, .5), .12);\n}\nfloat map(vec3 p){\n    //float ground = p.y+2.5+surfFunc(p)-tri(p).y;\n    float ground = p.y + (sin(sin(p.z*0.1253) - p.x*0.311)*1.31 + cos(p.z*0.53 + sin(p.x*0.127))*0.12)*1.7 + 0.2;\n    ground += tri(p).y;\n    //float bmp = texture(iChannel0, p.xz/10.).r*.1;\n    //float tx = textureLod(iChannel0, p.xz/16. + p.xy/80., 0.0).x;\n\n    //ground+=bmp;\n    // Round tunnel.\n    // For a round tunnel, use the Euclidean distance: length(tun.y)\n    vec2 tun = (p.xy - path(p.z))*vec2(0.5, 0.47071);\n    float n = 1.- length(tun) + (0.5);\n    n += surfFunc(p/2.);\n    //n+=bmp;\n    vec3 tp = p;\n    \n    tp.xy = tun;\n    \n    \n    float planks = trackPlanks(p);\n    float rails = trackRails(p);\n        \n    return min(min(max(ground, n), planks), rails);\n}\n\nfloat trace(vec3 o, vec3 r){\n    float t = 0.0;\n    for(int i = 0; i < NUM_STEPS; i++){\n        float d = map(o+r*t);\n        t += d * FUDGE_AMOUNT;\n        if(abs(d) < EPS || t > FAR) break;\n    }\n    return t;\n}\n// Surface normal.\nvec3 getNormal(in vec3 p) {\n\t\n\tconst float eps = 0.001;\n\treturn normalize(vec3(\n\t\tmap(vec3(p.x + eps, p.y, p.z)) - map(vec3(p.x - eps, p.y, p.z)),\n\t\tmap(vec3(p.x, p.y + eps, p.z)) - map(vec3(p.x, p.y - eps, p.z)),\n\t\tmap(vec3(p.x, p.y, p.z + eps)) - map(vec3(p.x, p.y, p.z - eps))\n\t));\n\n}\n// Tri-Planar blending function. Based on an old Nvidia tutorial.\nvec3 tex3D( sampler2D tex, in vec3 p, in vec3 n ){\n  \n    n = max((abs(n) - 0.2)*7., 0.001); // max(abs(n), 0.001), etc.\n    n /= (n.x + n.y + n.z );  \n    \n\treturn (texture(tex, p.yz)*n.x + texture(tex, p.zx)*n.y + texture(tex, p.xy)*n.z).xyz;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    uv -= .5; uv.x *= iResolution.x / iResolution.y;\n    vec3 r = normalize(vec3(uv, 1.0 - dot(uv, uv) * .33));\n    vec3 o = vec3(0.0, 0.0, iTime*22.0);\n    \n    vec3 lookAt = o + vec3(0.0, -0.05,.245);\n    o.xy += path(o.z);\n    lookAt.xy +=path(lookAt.z);    \n    \n    mat3 camMat = lookAtMatrix(o, lookAt, -o.x/15.);  //clamp(o.x/3.,-.3,.3));\n    r = normalize(camMat * r);\n    \n\n    \n    float hit = trace(o, r);\n    vec3 surfPos = o + r * hit;\n    vec3 n = getNormal(surfPos);\n    vec4 bg = vec4(0.0);\n    vec3 l = normalize(vec3(-0.1, 0.38, -0.2));\n    //l.xz *= r2(iTime*3.);\n    float diff = max(dot(n,l), 0.5);\n\tbg = pow(vec4(.1, .7, .8, 1), vec4(4.*max(r.y,-0.141)+1.5)); //+(dot(r,l)*.315+.215);\n    float fog = smoothstep(0.75, 01.75, hit*0.03);\n    fragColor=vec4(0.0);\n    \n    float d = map(surfPos);\n    float d2 = trackRails(surfPos);\n    float d3 = trackPlanks(surfPos);\n    \n    if(abs(d) < EPS+.4){\n        vec3 tx = tex3D(iChannel2, surfPos/8., n);\n        fragColor = mix(vec4(1.0*diff), bg, fog);        //+ hit* -.04;\n        if(abs(d2)<EPS+.01){\n            fragColor = vec4(1.0, 0.0, 0.0, 1.0)*diff;\n        }\n        else if(abs(d3) < EPS+0.1){\n            vec4 tx = texture(iChannel1, surfPos.xz);\n            fragColor = vec4(0.0, 1.0, 0.0, 1.0)*diff;\n        }\n    }\n    else\n        fragColor = vec4(bg);\n}", "image_inputs": [{"id": "XsfGRn", "previewfilepath": "/media/ap/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg", "ctype": "texture"}, {"id": "MtX3D7", "previewfilepath": "https://soundcloud.com/allmau5/deadmau5-all-i-have", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0, "src": "https://soundcloud.com/allmau5/deadmau5-all-i-have", "ctype": "musicstream"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wd2Sz3.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[113, 113, 133, 133, 160], [184, 184, 210, 210, 268], [270, 270, 292, 292, 381], [383, 383, 440, 440, 641], [643, 643, 660, 660, 736], [738, 738, 769, 769, 919], [921, 921, 966, 966, 1120], [1122, 1122, 1149, 1149, 1360], [1361, 1361, 1387, 1387, 1576], [1577, 1577, 1595, 1646, 2327], [2329, 2329, 2357, 2357, 2542], [2543, 2562, 2589, 2589, 2849], [2850, 2916, 2966, 2966, 3162], [3163, 3163, 3220, 3270, 4648]], "test": "error"}
{"id": "wd2Szc", "name": "Plasma Coil", "author": "dr2", "description": "Energy...", "tags": ["plasma", "transparent", "glow", "coil"], "likes": 13, "viewed": 370, "published": "Public API", "date": "1554623735", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// \"Plasma Coil\" by dr2 - 2019\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\nfloat PrTorusDf (vec3 p, float ri, float rc);\nfloat PrTorus4Df (vec3 p, float ri, float rc);\nfloat PrTorusAnDf (vec3 p, float ri, float rc, float w);\nfloat SmoothBump (float lo, float hi, float w, float x);\nvec2 Rot2D (vec2 q, float a);\n\nvec3 ltDir;\nfloat tCur, dstFar, rTor, htFlr, nSeg, tzFac, crExt, aRot;\nint idObj;\nconst float pi = 3.14159;\n\n#define DMIN(id) if (d < dMin) { dMin = d;  idObj = id; }\n\nfloat ObjDf (vec3 p)\n{\n  vec3 q;\n  float dMin, d, cvOrd, a;\n  dMin = dstFar;\n  p.y -= htFlr;\n  d = PrTorusDf (p.xzy, 1.5, rTor);\n  DMIN (1);\n  q = p;\n  q.xy = Rot2D (q.xy, 0.5 * pi);\n  q.yz = vec2 (atan (q.y, q.z) * rTor, length (q.yz) - rTor);\n  cvOrd = 7.;\n  a = atan (q.z, q.x) / (2. * pi);\n  q.xz = Rot2D (vec2 (length (q.xz) - 2., mod (q.y + 2. * a + 1., 2.) - 1.),\n     2. * pi * (cvOrd - 1.) * a);\n  d = 0.4 * (length (Rot2D (q.xz, - (floor ((0.5 * pi - atan (q.x, q.z)) + pi / cvOrd))) -\n     vec2 (0.6, 0.)) - 0.2);\n  DMIN (2);\n  q = p;\n  q.xz = Rot2D (q.xz, 2. * pi * ((floor (4. * atan (q.z, - q.x) / (2. * pi)) + 0.5) / 4.));\n  q.x = abs (q.x) - rTor;\n  d = PrTorus4Df (q, 1., 5. + crExt);\n  DMIN (3);\n  return dMin;\n}\n\nfloat ObjRay (vec3 ro, vec3 rd)\n{\n  vec3 p;\n  float dHit, d;\n  dHit = 0.;\n  for (int j = 0; j < 200; j ++) {\n    p = ro + dHit * rd;\n    d = ObjDf (p);\n    if (d < 0.0005 || dHit > dstFar || p.y < 0.) break;\n    dHit += d;\n  }\n  if (p.y < 0.) dHit = dstFar;\n  return dHit;\n}\n\nvec3 ObjNf (vec3 p)\n{\n  vec4 v;\n  vec2 e = vec2 (0.0001, -0.0001);\n  v = vec4 (- ObjDf (p + e.xxx), ObjDf (p + e.xyy), ObjDf (p + e.yxy), ObjDf (p + e.yyx));\n  return normalize (2. * v.yzw - dot (v, vec4 (1.)));\n}\n\nfloat TrObjDf (vec3 p)\n{\n  p.y -= htFlr;\n  p.xz = Rot2D (p.xz, 2. * pi * aRot / nSeg);\n  p.xz = Rot2D (p.xz, 2. * pi * ((floor (nSeg * atan (p.z, - p.x) / (2. * pi)) + 0.5) / nSeg));\n  p.x = abs (p.x) - rTor;\n  p.z *= tzFac;\n  return PrTorusDf (p, 2., 2.);\n}\n\nfloat TrObjRay (vec3 ro, vec3 rd)\n{\n  vec3 p;\n  float dHit, d;\n  dHit = 0.;\n  for (int j = 0; j < 100; j ++) {\n    p = ro + dHit * rd;\n    d = TrObjDf (p);\n    if (d < 0.0005 || dHit > dstFar || p.y < 0.) break;\n    dHit += d;\n  }\n  if (p.y < 0.) dHit = dstFar;\n  return dHit;\n}\n\nvec3 TrObjNf (vec3 p)\n{\n  vec4 v;\n  vec2 e = vec2 (0.0001, -0.0001);\n  v = vec4 (- TrObjDf (p + e.xxx), TrObjDf (p + e.xyy), TrObjDf (p + e.yxy), TrObjDf (p + e.yyx));\n  return normalize (2. * v.yzw - dot (v, vec4 (1.)));\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  vec3 col, glCol, bgCol, vn, roo, p;\n  float dstObj, dstTrObj, nDotL, r, s, tCyc, t, tm;\n  rTor = 80. / (2. * pi);\n  nSeg = 12.;\n  tCyc = 50.;\n  t = 2. * pi * tCur / tCyc;\n  tm = mod (tCur / tCyc, 1.);\n  aRot = 0.01 * tCyc * t + 30. * (sin (t) - t);\n  tzFac = 0.8 + 0.2 * cos (t);\n  crExt = 0.05 * sin (512. * tCur) * SmoothBump (0.2, 0.8, 0.1, tm);\n  htFlr = 5.8;\n  roo = ro;\n  dstTrObj = TrObjRay (ro, rd);\n  dstObj = ObjRay (ro, rd);\n  bgCol = mix (vec3 (0.1, 0.1, 0.2), vec3 (0.5, 0.3, 0.2), (0.5 +\n     0.5 * SmoothBump (0.3, 0.7, 0.15, mod (64. * rd.y - 16. * atan (rd.z, - rd.x) / (2. * pi) +\n     0.5 * aRot, 1.))) * SmoothBump (0.25, 0.75, 0.15, tm));\n  glCol = mix (vec3 (0.9, 0.9, 0.3) * (0.97 + 0.03 * sin (64. * tCur)), vec3 (1., 1., 0.9),\n     SmoothBump (0.3, 0.7, 0.1, tm));\n  if (dstObj < dstFar) {\n    ro += dstObj * rd;\n    vn = ObjNf (ro);\n    nDotL = max (dot (vn, ltDir), 0.);\n    s = mod (nSeg * atan (ro.z, - ro.x) / (2. * pi) - aRot, 1.);\n    if (idObj == 1) {\n      col = mix (vec3 (0.7, 0.7, 0.), vec3 (1.), 0.5 + 0.5 * sin (t)) *\n         (0.4 + 0.6 * SmoothBump (0.35, 0.65, 0.05, s * tzFac));\n    } else if (idObj == 2) {\n      col = mix (vec3 (0.7, 0.6, 0.6), mix (vec3 (1., 0., 0.), vec3 (1.), 0.5 + 0.5 * cos (t)),\n         SmoothBump (0.25, 0.75, 0.1, s));\n    } else if (idObj == 3) {\n      col = vec3 (0.7, 0.7, 0.8);\n    }\n    col = col * (0.2 + 0.8 * nDotL * nDotL) +\n       0.1 * pow (max (dot (normalize (ltDir - rd), vn), 0.), 32.);\n    if (idObj > 1) col.r += ((idObj == 2) ? 0.5 : 0.2) * max (- dot (rd, vn), 0.) *\n       SmoothBump (0.3, 0.7, 0.1, tm);\n  } else if (rd.y < 0.) {\n    dstObj = - ro.y / rd.y;\n    ro += dstObj * rd;\n    r = length (ro.xz);\n    if (r < 2. * rTor) {\n      col = vec3 (0.2, 0.22, 0.2) * (0.8 + 0.2 * SmoothBump (0.03, 0.97, 0.01, mod (0.5 * r, 1.)));\n      p = ro;\n      p.xz = Rot2D (p.xz, 2. * pi * ((floor (4. * atan (p.z, - p.x) / (2. * pi)) + 0.5) / 4.));\n      p.x = abs (p.x) - rTor;\n      s =  smoothstep (1., 1.3, length (p.xz * vec2 (0.4, 1.) + crExt));\n      col *= 0.8 + 0.2 * s;\n      p = ro;\n      p.xz = Rot2D (p.xz, 2. * pi * aRot / nSeg);\n      p.xz = Rot2D (p.xz, 2. * pi * ((floor (nSeg * atan (p.z, - p.x) / (2. * pi)) + 0.5) / nSeg));\n      col += glCol * 0.2 * s * SmoothBump (-0.2, 0.2, 0.1,\n         length (vec2 (r / rTor - 1., 0.8 * p.z * tzFac / (2. * pi * rTor / nSeg))));\n    } else col = bgCol;\n  } else {\n    col = bgCol;\n  }\n  dstObj = min (dstObj, dstFar);\n  if (dstTrObj < dstObj) col += glCol * smoothstep (0.05, 0.5, dstObj - dstTrObj) *\n     (0.05 + 0.4 * clamp (- dot (TrObjNf (roo + dstTrObj * rd), rd), 0., 1.));\n  return clamp (col, 0., 1.);\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  mat3 vuMat;\n  vec4 mPtr;\n  vec3 ro, rd;\n  vec2 canvas, uv, ori, ca, sa;\n  float el, az, zmFac;\n  canvas = iResolution.xy;\n  uv = 2. * fragCoord.xy / canvas - 1.;\n  uv.x *= canvas.x / canvas.y;\n  tCur = iTime;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / canvas - 0.5;\n  az = 0.01;\n  el = -0.1 * pi;\n  if (mPtr.z > 0.) {\n    az += 2. * pi * mPtr.x;\n    el += 1.5 * pi * mPtr.y;\n  }\n  el = clamp (el, -0.5 * pi, 0.01 * pi);\n  ori = vec2 (el, az);\n  ca = cos (ori);\n  sa = sin (ori);\n  vuMat = mat3 (ca.y, 0., - sa.y, 0., 1., 0., sa.y, 0., ca.y) *\n          mat3 (1., 0., 0., 0., ca.x, - sa.x, 0., sa.x, ca.x);\n  ro = vuMat * vec3 (0., 5., -80.);\n  ro.y = max (ro.y, 0.01);\n  zmFac = 8. - 3. * abs (el);\n  rd = vuMat * normalize (vec3 (uv, zmFac));\n  dstFar = 100.;\n  ltDir = vuMat * normalize (vec3 (1., 1., -1.));\n  fragColor = vec4 (ShowScene (ro, rd), 1.);\n}\n\nfloat PrTorusDf (vec3 p, float ri, float rc)\n{\n  return length (vec2 (length (p.xy) - rc, p.z)) - ri;\n}\n\nfloat PrTorus4Df (vec3 p, float ri, float rc)\n{\n  vec2 q;\n  q = vec2 (length (p.xy) - rc, p.z);\n  q *= q;\n  return sqrt (sqrt (dot (q * q, vec2 (1.)))) - ri;\n}\n\nfloat PrTorusAnDf (vec3 p, float ri, float rc, float w)\n{\n  return abs (length (vec2 (length (p.xy) - rc, p.z)) - ri) - w;\n}\n\nfloat SmoothBump (float lo, float hi, float w, float x)\n{\n  return (1. - smoothstep (hi - w, hi + w, x)) * smoothstep (lo - w, lo + w, x);\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  vec2 cs;\n  cs = sin (a + vec2 (0.5 * pi, 0.));\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wd2Szc.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[525, 525, 547, 547, 1255], [1257, 1257, 1290, 1290, 1531], [1533, 1533, 1554, 1554, 1746], [1748, 1748, 1772, 1772, 2006], [2008, 2008, 2043, 2043, 2286], [2288, 2288, 2311, 2311, 2511], [2513, 2513, 2548, 2548, 5206], [5208, 5208, 5264, 5264, 6120], [6122, 6122, 6168, 6168, 6225], [6227, 6227, 6274, 6274, 6386], [6388, 6388, 6445, 6445, 6512], [6514, 6514, 6571, 6571, 6654], [6656, 6656, 6686, 6686, 6799]], "test": "timeout"}
{"id": "wd2XDG", "name": "Finals4 - Noise ", "author": "EmperorLem", "description": "noise", "tags": ["noise"], "likes": 0, "viewed": 52, "published": "Public", "date": "1554889427", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec3 brown = vec3(0.3,0.2,0.2);\nvec3 black = vec3(0.0,0.0,0.0);\nvec3 red = vec3(0.7,0.0,0.0);\nvec3 blue = vec3(0.,.4,1.0);\nvec3 yellow = vec3(1.0,1.0,0.0);\nvec3 green = vec3(0.1,0.9,0.0);\nvec3 white = vec3(1.0,1.0,1.0);\n\nfloat rand(vec2 uv)\n{\n    //return fract(sin(dot(uv, vec2(12.9898,78.233)))*10000.*iTime);\n\t//return fract(sin(dot(uv, iMouse.xy))*10000.);\n\t//return (fract(sin(dot(uv, vec2(12., 70.)))*100000.));\n    return (fract(sin(dot(uv, vec2(12., 70.)))*43758.5453123));\n}\n\n// Value noise\nfloat noise(in vec2 st) {\n    vec2 i = floor(st);\n    vec2 f = fract(st);\n\n    // Four corners in 2D of a tile\n    float a = rand(i);\n    float b = rand(i + vec2(1.0, 0.0));\n    float c = rand(i + vec2(0.0, 1.0));\n    float d = rand(i + vec2(1.0, 1.0));\n\n    // Smooth Interpolation\n\n    // Cubic Hermine Curve.  Same as SmoothStep()\n    vec2 u = f*f*(3.0-2.0*f);\n    // u = smoothstep(0.,1.,f);\n\n    // Mix 4 coorners porcentages\n    return mix(a, b, u.x) + \n            (c - a)* u.y * (1.0 - u.x) + \n            (d - b) * u.x * u.y;\n}\n\n// Gradient noise\nvec2 hash( vec2 x )  // replace this by something better\n{\n    const vec2 k = vec2( 0.3183099, 0.3678794 );\n    x = x*k + k.yx;\n    return -1.0 + 2.0*fract( 16.0 * k*fract( x.x*x.y*(x.x+x.y)) );\n}\n\nfloat gnoise( in vec2 p )\n{\n    vec2 i = floor( p );\n    vec2 f = fract( p );\n\t\n\tvec2 u = f*f*(3.0-2.0*f);\n\n    return mix( mix( dot( hash( i + vec2(0.0,0.0) ), f - vec2(0.0,0.0) ), \n                     dot( hash( i + vec2(1.0,0.0) ), f - vec2(1.0,0.0) ), u.x),\n                mix( dot( hash( i + vec2(0.0,1.0) ), f - vec2(0.0,1.0) ), \n                     dot( hash( i + vec2(1.0,1.0) ), f - vec2(1.0,1.0) ), u.x), u.y);\n}\n\n// Simplex noise\nvec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec2 mod289(vec2 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec3 permute(vec3 x) { return mod289(((x*34.0)+1.0)*x); }\n\nfloat snoise(vec2 v) {\n    const vec4 C = vec4(0.211324865405187,  // (3.0-sqrt(3.0))/6.0\n                        0.366025403784439,  // 0.5*(sqrt(3.0)-1.0)\n                        -0.577350269189626,  // -1.0 + 2.0 * C.x\n                        0.024390243902439); // 1.0 / 41.0\n    vec2 i  = floor(v + dot(v, C.yy) );\n    vec2 x0 = v -   i + dot(i, C.xx);\n    vec2 i1;\n    i1 = (x0.x > x0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);\n    vec4 x12 = x0.xyxy + C.xxzz;\n    x12.xy -= i1;\n    i = mod289(i); // Avoid truncation effects in permutation\n    vec3 p = permute( permute( i.y + vec3(0.0, i1.y, 1.0 ))\n        + i.x + vec3(0.0, i1.x, 1.0 ));\n\n    vec3 m = max(0.5 - vec3(dot(x0,x0), dot(x12.xy,x12.xy), dot(x12.zw,x12.zw)), 0.0);\n    m = m*m ;\n    m = m*m ;\n    vec3 x = 2.0 * fract(p * C.www) - 1.0;\n    vec3 h = abs(x) - 0.5;\n    vec3 ox = floor(x + 0.5);\n    vec3 a0 = x - ox;\n    m *= 1.79284291400159 - 0.85373472095314 * ( a0*a0 + h*h );\n    vec3 g;\n    g.x  = a0.x  * x0.x  + h.x  * x0.y;\n    g.yz = a0.yz * x12.xz + h.yz * x12.yw;\n    return 130.0 * dot(m, g);\n}\n\nfloat createCircle(vec2 uv)\n{\n    uv -= 0.5;\n    uv.x *= iResolution.x/iResolution.y;\n    \n    float d = length(uv) * 0.6;\n    float r = 0.2;\n    float ratio = 0.3;\n    float rate = clamp(sin(20.0 * ratio * iTime)*ratio , 0.25, 0.3);\n    float circle = smoothstep( rate,r=0.2,d);\n    \n    \n    \n    float angle = (atan(uv.y, uv.x));\n        \n    float value = smoothstep( rate,ratio = 0.2 ,d);\n    \n    float radius = 0.0;\n    radius = smoothstep(-1.0, 20.0, cos(circle * 4.0 * circle *10.0)) * 10.0 + 0.15;\n    \n    value = 1.0 - step(radius, d) + clamp(sin(radius * sin(iTime * 2.0) / sin(iTime * 2.0)) , 0.25, 0.30);\n    radius /= noise(uv*20. * sin(iTime *2.0) / 0.2);\n\n    return radius / circle;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Time varying pixel color\n    vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n    \n    float mCircle = createCircle(uv);\n    vec3 mixed = mix(black , col, mCircle);\n    \n    // Output to screen\n    fragColor = vec4(mixed,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wd2XDG.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[221, 221, 242, 417, 483], [485, 500, 525, 525, 1036], [1038, 1056, 1114, 1114, 1252], [1254, 1254, 1281, 1281, 1679], [1681, 1698, 1719, 1719, 1766], [1767, 1767, 1788, 1788, 1835], [1836, 1836, 1858, 1858, 1893], [1895, 1895, 1917, 1917, 2965], [2967, 2967, 2996, 2996, 3670], [3673, 3673, 3730, 3780, 4060]], "test": "ok"}
{"id": "Wd2XRc", "name": "emissive point light", "author": "takumifukasawa", "description": "emissive point light by raymarching", "tags": ["raymarching", "pointlight", "rgb", "glow", "emissive"], "likes": 9, "viewed": 346, "published": "Public", "date": "1554543583", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define EPS 0.0001\n#define PI 3.14159265359\n#define FLT_MAX 3.402823466e+38\n#define FLT_MIN 1.175494351e-38\n#define DBL_MAX 1.7976931348623158e+308\n#define DBL_MIN 2.2250738585072014e-308\n\nprecision mediump float;\n\nconst int maxIterations = 64;\nconst float stepScale = 1.;\nconst float stopThreshold = .005;\n\nfloat fov = .6;\nfloat nearClip = 0.;\nfloat farClip = 80.;\n\nstruct Light {\n  vec3 position;\n  float intensity;\n  vec3 color;\n};\n    \nstruct Surface {\n  float dist;\n  vec3 position;\n  vec3 baseColor;\n  vec3 normal;\n  vec3 emissiveColor;\n};\n    \nstruct Hit {\n  Surface surface;\n  Surface near;\n};\n    \nfloat saturate(float s) {\n  return clamp(s, 0., 1.);\n}\n\nfloat distanceToLine(vec3 origin, vec3 dir, vec3 point) {\n\tvec3 pointToOrigin = point - origin;\n    float pointToOriginLength = length(pointToOrigin);\n    vec3 pointToOriginNorm = normalize(pointToOrigin);\n    float theta = dot(dir, pointToOriginNorm);\n    return pointToOriginLength * sqrt(1. - theta * theta);\n}\n\nfloat invert(float m) {\n  return 1.0 / m;\n}\n\nmat2 invert(mat2 m) {\n  return mat2(m[1][1],-m[0][1],\n             -m[1][0], m[0][0]) / (m[0][0]*m[1][1] - m[0][1]*m[1][0]);\n}\n\nmat3 invert(mat3 m) {\n  float a00 = m[0][0], a01 = m[0][1], a02 = m[0][2];\n  float a10 = m[1][0], a11 = m[1][1], a12 = m[1][2];\n  float a20 = m[2][0], a21 = m[2][1], a22 = m[2][2];\n\n  float b01 = a22 * a11 - a12 * a21;\n  float b11 = -a22 * a10 + a12 * a20;\n  float b21 = a21 * a10 - a11 * a20;\n\n  float det = a00 * b01 + a01 * b11 + a02 * b21;\n\n  return mat3(b01, (-a22 * a01 + a02 * a21), (a12 * a01 - a02 * a11),\n              b11, (a22 * a00 - a02 * a20), (-a12 * a00 + a02 * a10),\n              b21, (-a21 * a00 + a01 * a20), (a11 * a00 - a01 * a10)) / det;\n}\n\nmat4 invert(mat4 m) {\n  float\n      a00 = m[0][0], a01 = m[0][1], a02 = m[0][2], a03 = m[0][3],\n      a10 = m[1][0], a11 = m[1][1], a12 = m[1][2], a13 = m[1][3],\n      a20 = m[2][0], a21 = m[2][1], a22 = m[2][2], a23 = m[2][3],\n      a30 = m[3][0], a31 = m[3][1], a32 = m[3][2], a33 = m[3][3],\n\n      b00 = a00 * a11 - a01 * a10,\n      b01 = a00 * a12 - a02 * a10,\n      b02 = a00 * a13 - a03 * a10,\n      b03 = a01 * a12 - a02 * a11,\n      b04 = a01 * a13 - a03 * a11,\n      b05 = a02 * a13 - a03 * a12,\n      b06 = a20 * a31 - a21 * a30,\n      b07 = a20 * a32 - a22 * a30,\n      b08 = a20 * a33 - a23 * a30,\n      b09 = a21 * a32 - a22 * a31,\n      b10 = a21 * a33 - a23 * a31,\n      b11 = a22 * a33 - a23 * a32,\n\n      det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;\n\n  return mat4(\n      a11 * b11 - a12 * b10 + a13 * b09,\n      a02 * b10 - a01 * b11 - a03 * b09,\n      a31 * b05 - a32 * b04 + a33 * b03,\n      a22 * b04 - a21 * b05 - a23 * b03,\n      a12 * b08 - a10 * b11 - a13 * b07,\n      a00 * b11 - a02 * b08 + a03 * b07,\n      a32 * b02 - a30 * b05 - a33 * b01,\n      a20 * b05 - a22 * b02 + a23 * b01,\n      a10 * b10 - a11 * b08 + a13 * b06,\n      a01 * b08 - a00 * b10 - a03 * b06,\n      a30 * b04 - a31 * b02 + a33 * b00,\n      a21 * b02 - a20 * b04 - a23 * b00,\n      a11 * b07 - a10 * b09 - a12 * b06,\n      a00 * b09 - a01 * b07 + a02 * b06,\n      a31 * b01 - a30 * b03 - a32 * b00,\n      a20 * b03 - a21 * b01 + a22 * b00) / det;\n}\n\nmat4 scale(vec3 s) {\n  return invert(mat4(\n    s.x, 0., 0., 0.,\n    0., s.y, 0., 0.,\n    0., 0., s.z, 0.,\n    0., 0., 0., 1.\n  ));\n}\n\nmat4 rotateX(float angle) {\n  return invert(mat4(\n    1., 0., 0., 0.,\n    0., cos(angle), -sin(angle), 0.,\n    0., sin(angle), cos(angle), 0.,\n    0., 0., 0., 1.\n  ));\n}\n\nmat4 rotateY(float angle) {\n  return invert(mat4(\n    cos(angle), 0., sin(angle), 0.,\n    0., 1., 0., 0.,\n    -sin(angle), 0., cos(angle), 0.,\n    0., 0., 0., 1.\n  ));\n}\n\nmat4 rotateZ(float angle) {\n  return invert(mat4(\n    cos(angle), -sin(angle), 0., 0.,\n    sin(angle), cos(angle), 0., 0.,\n    0., 0., 1., 0.,\n    0., 0., 0., 1.\n  ));\n}\n\nmat4 translate(vec3 p) {\n  return invert(mat4(\n    1., 0., 0., p.x,\n    0., 1., 0., p.y,\n    0., 0., 1., p.z,\n    0., 0., 0., 1.\n  ));\n}\n\nfloat sphere(vec3 p, float size) {\n  return length(p) - size;\n}\n\nfloat box(vec3 p, vec3 size) {\n  vec3 d = abs(p) - size;\n  return length(max(d, 0.)) + min(max(d.x, max(d.y, d.z)), 0.);\n}\n\nfloat tube2(vec2 p, float size) {\n  return length(p) - size;\n}\n\nfloat box2(vec2 p, float size) {\n  return length(max(abs(p) - size, 0.));\n}\n\nfloat cylindar(vec3 p, vec3 c) {\n  return length(p.xz - c.xy) - c.z;\n}\n\nfloat displacement(vec3 p, vec3 power) {\n  return sin(power.x * p.x) * sin(power.y * p.y) * sin(power.z * p.z);\n}\n\nvec3 repeat(vec3 p, float c) {\n  return mod(p, c) - c * .5;\n}\n\nfloat smin(float a, float b, float k) {\n  float res = exp(-k * a) + exp(-k * b);\n  return -log(res) / k;\n}\n\nfloat scene(vec3 p) {\n  vec3 _p = p;\n\n  _p = (vec4(_p, 1.)\n      // * translate(vec3(cos(iTime) * 2., sin(iTime), 0.))\n      // * rotateX(iTime)\n      // * rotateY(iTime)\n      // * rotateZ(iTime)\n      // * scale(vec3(1. + sin(iTime) * .1))\n   ).xyz;\n    \n  return min(\n    sphere((vec4(p, 1.) * translate(vec3(-.7, 0., 0.))).xyz, .5),\n    box((vec4(p, 1.) * translate(vec3(.7, 0., 0))).xyz, vec3(.45))\n  );\n}\n\nfloat calcAO(vec3 p, vec3 n) {\n  float k = 1.;\n  float occ = 0.;\n  for(int i = 0; i < 5; i++) {\n    float len = .15 * (float(i) + 1.);\n    float distance = scene(n * len + p);\n    occ += (len - distance) * k;\n    k *= .5;\n  }\n  return clamp(1. - occ, 0., 1.);\n}\n\nvec3 getNormal(vec3 p) {\n  const float e = EPS;\n  return normalize(vec3(\n    scene(p + vec3(e,   0.0, 0.0)) - scene(p + vec3(-e,  0.0, 0.0)),\n    scene(p + vec3(0.0,   e, 0.0)) - scene(p + vec3(0.0,  -e, 0.0)),\n    scene(p + vec3(0.0, 0.0,   e)) - scene(p + vec3(0.0, 0.0,  -e))\n  ));\n}\n\nSurface near(Surface needle, Surface target) {\n  if(needle.dist < 0. || needle.dist < target.dist) {\n    return needle;\n  }\n  return target;\n}\n\nHit rayMarching(vec3 origin, vec3 dir, float start, float end) {\n  Surface cs;  // current surface\n  cs.dist = -1.;\n    \n  Surface ns; // near surface\n  ns.dist = FLT_MAX;\n    \n  Hit hit;\n\n  float sceneDist = 0.;\n  float rayDepth = start;\n\n  for(int i = 0; i < maxIterations; i++) {\n    sceneDist = scene(origin + dir * rayDepth);\n      \n    // cache near distance\n    if(sceneDist < ns.dist) {\n      ns.dist = sceneDist;\n    }\n\n    if((sceneDist < stopThreshold) || (rayDepth >= end)) {\n     break;\n    }\n    rayDepth += sceneDist * stepScale;\n    cs.dist = rayDepth;\n  }\n    \n  if (sceneDist >= stopThreshold) {\n    rayDepth = end;\n  }\n    \n  cs.dist = rayDepth;\n  hit.surface = cs;\n  hit.near = ns;\n\n  return hit;\n}\n\nfloat getSpecular(vec3 position, vec3 normal, Light light, float diffuse, vec3 cameraPos) {\n  vec3 lightDir = light.position - position;\n  vec3 ref = reflect(-normalize(lightDir), normal);\n  float specular = 0.;\n  if(diffuse > 0.) {\n    specular = max(0., dot(ref, normalize(cameraPos - normal)));\n    float specularPower = 32.;\n    specular = pow(specular, specularPower) * light.intensity;\n  }\n  return specular;\n}\n\nvec3 lighting(Surface surface, vec3 cameraPos) {\n  vec3 position = surface.position;\n\n  vec3 color = vec3(0.);\n  vec3 sceneColor = vec3(0.);\n  vec3 normal = getNormal(position);\n\n  vec3 objColor = vec3(.4, .4, .4);\n  vec3 specularColor = vec3(.6, .6, .6);\n\n  Light directionalLight;\n  directionalLight.position = vec3(5., 5., 5.);\n  directionalLight.intensity = .8;\n  directionalLight.color = vec3(.4, .4, .4);\n\n  Light pointLight;\n  pointLight.position = vec3(5., 5., 5.);\n  pointLight.intensity = .8;\n  pointLight.color = vec3(.5, .5, .5);\n\n  Light ambientLight;\n  ambientLight.color = vec3(.1, .1, .1);\n  ambientLight.intensity = .3;\n    \n  // directional light\n  float dDiffuse = max(0., dot(normal, normalize(directionalLight.position)));\n  dDiffuse *= directionalLight.intensity;\n  vec3 dDiffuseColor = dDiffuse * directionalLight.color * objColor;\n  float dSpecular = getSpecular(position, normal, directionalLight, dDiffuse, cameraPos);\n  vec3 dSpecularColor = dSpecular * specularColor;\n\n  // point light\n  vec3 pLightDir = pointLight.position - position;\n  float pDiffuse = max(0., dot(normal, normalize(pLightDir)));\n  vec3 pDiffuseColor = pDiffuse * pointLight.color * objColor;\n  float d = distance(pointLight.position, position);\n  vec3 k = vec3(.05, .9, .06);\n  float attenuation = 1. / (k.x + (k.y * d) + (k.z * d * d));\n  pDiffuse *= pointLight.intensity;\n  pDiffuse *= attenuation;\n  float pSpecular = getSpecular(position, normal, pointLight, pDiffuse, cameraPos);\n  pSpecular *= attenuation;\n  vec3 pSpecularColor = pSpecular * specularColor;\n    \n  // ambient\n  vec3 ambientColor = ambientLight.color * ambientLight.intensity * objColor;\n  float ao = calcAO(position, normal);\n\n  vec3 diffuse = dDiffuseColor + pDiffuseColor;\n  vec3 specular = dSpecularColor + pSpecularColor;\n  vec3 ambient = ambientColor * ao;\n\n  // color += objColor * diffuse + specular + ambient * ao;\n  color += objColor * diffuse + ambient * ao;\n    \n  return color;\n}\n\nvec3 emissiveLight(Light light, Surface surface, vec3 rayOrigin, vec3 rayDirection) {\n  vec3 eyeDirection = rayOrigin + rayDirection;\n  \n  float lightEmissive = pow(distanceToLine(eyeDirection, rayDirection, light.position) + .95, -2.);\n\n  float c = dot(surface.normal, normalize(light.position - surface.position));\n  c = clamp(c, 0., 1.);\n  float em = 0.;\n\n  em = c + (1. - c) * step(farClip, surface.dist);\n\n  return lightEmissive * light.color * light.intensity * em;  \n}\n\nvec3 emissiveLighting(Surface surface, vec3 rayOrigin, vec3 rayDirection) {\n  vec3 eyeDirection = rayOrigin + rayDirection;\n  vec3 normal = surface.normal;\n\n  Light pointLightRed;\n  pointLightRed.color = vec3(1., .1, .1);\n  pointLightRed.intensity = 1.;\n  pointLightRed.position = vec3(cos(iTime * 1.4) * 2., sin(iTime * 1.4) * 2., 0.);\n  \n  Light pointLightGreen;\n  pointLightGreen.color = vec3(.1, 1., .1);\n  pointLightGreen.intensity = 1.;\n  pointLightGreen.position = vec3(cos(iTime * 1.6) * 2., 0., sin(iTime * 1.6) * 2.);\n\n  Light pointLightBlue;\n  pointLightBlue.color = vec3(.1, .1, 1.);\n  pointLightBlue.intensity = 1.;\n  pointLightBlue.position = vec3(0., sin(iTime * 1.8) * 2., cos(iTime * 1.8) * 2.);    \n    \n    \n  vec3 color = vec3(0.);\n  color += emissiveLight(pointLightRed, surface, rayOrigin, rayDirection);\n  color += emissiveLight(pointLightGreen, surface, rayOrigin, rayDirection);\n  color += emissiveLight(pointLightBlue, surface, rayOrigin, rayDirection);\n\n  return color;    \n}\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  vec2 aspect = vec2(iResolution.x / iResolution.y, 1.);\n  vec2 screenCoord = (2. * fragCoord.xy / iResolution.xy - 1.) * aspect;\n  vec2 mouse = iMouse.xy / iResolution.xy - .5;\n  \n  // camera settings\n  vec3 lookAt = vec3(0., 0., 0.);\n  vec3 cameraPos = vec3(mouse.x * 8., mouse.y * 8., 5.);\n\n  // camera vectors\n  vec3 forward = normalize(lookAt - cameraPos);\n  vec3 right = normalize(cross(forward, vec3(0., 1., 0.)));\n  vec3 up = normalize(cross(right, forward));        \n\n  // raymarch\n  vec3 rayOrigin = cameraPos;\n  vec3 rayDirection = normalize(forward + fov * screenCoord.x * right + fov * screenCoord.y * up);\n  Hit hit = rayMarching(rayOrigin, rayDirection, nearClip, farClip);\n  Surface surface = hit.surface;\n  Surface near = hit.near;\n\n  surface.position = rayOrigin + rayDirection * surface.dist;\n    \n  // color\n  vec3 sceneColor = vec3(0.);\n    \n  // no hit or too far\n  if(surface.dist >= farClip) {\n    vec3 bgColor = vec3(0.);\n    sceneColor = bgColor;\n  } else {\n    sceneColor += lighting(surface, cameraPos);\n  }\n\n  surface.normal = getNormal(surface.position);\n  sceneColor += emissiveLighting(surface, rayOrigin, rayDirection);\n\n  fragColor = vec4(sceneColor, 1.);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Wd2XRc.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[607, 607, 632, 632, 661], [663, 663, 720, 720, 976], [978, 978, 1001, 1001, 1021], [1023, 1023, 1044, 1044, 1149], [1151, 1151, 1172, 1172, 1714], [1716, 1716, 1737, 1737, 3195], [3197, 3197, 3217, 3217, 3329], [3331, 3331, 3358, 3358, 3500], [3502, 3502, 3529, 3529, 3671], [3673, 3673, 3700, 3700, 3842], [3844, 3844, 3868, 3868, 3980], [3982, 3982, 4016, 4016, 4045], [4047, 4047, 4077, 4077, 4169], [4171, 4171, 4204, 4204, 4233], [4235, 4235, 4267, 4267, 4310], [4312, 4312, 4344, 4344, 4382], [4384, 4384, 4424, 4424, 4497], [4499, 4499, 4529, 4529, 4560], [4562, 4562, 4601, 4601, 4668], [4670, 4670, 4691, 4691, 5080], [5345, 5345, 5369, 5369, 5631], [5633, 5633, 5679, 5679, 5775], [5777, 5777, 5841, 5841, 6495], [6497, 6497, 6588, 6588, 6913], [6915, 6915, 6963, 6963, 8878], [8880, 8880, 8965, 8965, 9355], [9357, 9357, 9432, 9432, 10359], [10362, 10362, 10417, 10417, 11609]], "test": "timeout"}
{"id": "Wd2XRy", "name": "light ray marching thing", "author": "samw", "description": "Just messing about with some ray marching", "tags": ["raymarching", "lighting", "light"], "likes": 4, "viewed": 419, "published": "Public", "date": "1554284389", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define MAX_STEPS 100\n#define MAX_DIST 100.\n#define SURF_DIST .01\n#define PI 3.14159\n\n\nfloat distCuboid(vec3 pos, vec3 cubePos, vec3 size) \n{\n    \n    vec3 d = abs(pos - cubePos) - size;\n    \n    float insideDist = min(max(d.x, max(d.y, d.z)), 0.);\n    float outsideDist = length(max(d, 0.));\n    \n    return insideDist + outsideDist;\n}\n\nfloat distSphere(vec3 pos, vec4 sphere)\n{\n\treturn length(pos-sphere.xyz)-sphere.w;\n}\n\nfloat dist(vec3 pos)\n{\n    vec4 sphere = vec4(0, 1, 0, 1);\n    vec3 center = vec3(0., 3., 0.);\n    float planeDist = pos.y;\n    \n    float sideLength = .8 + sin(iTime)/6.;\n    float sideLength2 = .8 + cos(iTime)/6.;\n    \n    float sphereDist1 = distSphere(pos, vec4(center.x, center.y, center.z, 1.9*sideLength));\n    float sphereDist2 = distSphere(pos, vec4(center.x, center.y, center.z, 1.7*sideLength));\n    \n    vec3 cuboid1 = vec3(1, 2.*(.8 + sin(iTime)/6.), 0.6);\n    vec3 cuboid2 = vec3(1, 2.*(.8 + sin(iTime + 2.*PI/3.)/6.), 0.6);\n    vec3 cuboid3 = vec3(1, 2.*(.8 + sin(iTime + 4.*PI/3.)/6.), 0.6);\n    float cuboidDist1 = distCuboid(pos, center, cuboid1.yxx);\n    float cuboidDist2 = distCuboid(pos, center, cuboid2.xyx);\n    float cuboidDist3 = distCuboid(pos, center, cuboid3.xxy);\n    \n    float cuboidDist4 = distCuboid(pos, center, 1.1*cuboid1.yzz);\n    float cuboidDist5 = distCuboid(pos, center, 1.1*cuboid2.zyz);\n    float cuboidDist6 = distCuboid(pos, center, 1.1*cuboid3.zzy);\n    \n    return min(planeDist, max(-min(cuboidDist4, min(cuboidDist5, cuboidDist6)), min(cuboidDist1, min(cuboidDist2, cuboidDist3))));\n}\n\nvec3 normal(vec3 pos)\n{\n\tvec2 e = vec2(.01, 0);\n    float d = dist(pos);\n    vec3 n = vec3(\n    \td-dist(pos-e.xyy),\n        d-dist(pos-e.yxy),\n        d-dist(pos-e.yyx)\n    );\n        \n    return normalize(n);\n}\n\nvec3 march(vec3 ro, vec3 rd)\n{\n\tfloat dO=0.;\n    \n    for (int i=0; i<MAX_STEPS; i++)  {\n    \tvec3  p = ro + rd*dO;\n        float dS = dist(p);\n        dO += dS;\n        \n        if (dO>MAX_DIST || dS<SURF_DIST) break;\n    }\n    \n    return ro + rd*dO;\n}\n\nfloat light(vec3 pos)\n{\n    //vec3 lightSource = vec3(2.*cos(iTime), 10., 2.*sin(iTime));\n    vec3 lightSource = vec3(6., 10., 4.);\n    \n    vec3 lightDir = normalize(lightSource-pos);\n        \n        \n    vec3 d = march(pos+normal(pos)*SURF_DIST*2., lightDir);\n    \n    if (length(d)>length(pos-lightSource)) {\n    \treturn dot(normalize(lightSource.xyz-pos),  normal(pos));\n    } else {\n    \treturn dot(normalize(lightSource.xyz-pos),  normal(pos))*0.3;   \n    }\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    \n    //vec3 ro = vec3((iMouse.x-.5*iResolution.x)/200., 1, 0);\n    //vec3 rd = normalize(vec3(uv.x, uv.y, 1));\n    \n    //float angle = 0.1;\n    float angle = -(iMouse.x-.5*iResolution.x)/100.;\n    float angle2 = -(iMouse.y-.5*iResolution.y)/100.;\n    mat3 yaw = mat3(\n    \tcos(angle), 0., sin(angle),\n        0., 1., 0.,\n        -sin(angle), 0., cos(angle)\n    );\n    \n    mat3 pitch = mat3(\n        1., 0., 0.,\n    \t0., cos(angle2), sin(angle2),\n        0.,-sin(angle2), cos(angle2)\n    );\n    \n    mat3 rotation = yaw * pitch;\n    \n    vec3 ro = rotation * vec3(0., 0., -10.) + vec3(0., 3., 0.);\n    \n    vec3 rd = normalize(rotation*(vec3(uv.x, uv.y, 1)));\n\n    vec3 surfacePos = march(ro, rd);\n\n    float dif = light(surfacePos);\n    \n    vec3 col = dif * vec3(.75, .75, .75) + vec3(.25, .25, .25);\n    \n\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Wd2XRy.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[87, 87, 141, 141, 336], [338, 338, 379, 379, 422], [424, 424, 446, 446, 1558], [1560, 1560, 1583, 1583, 1771], [1773, 1773, 1803, 1803, 2027], [2029, 2029, 2052, 2118, 2495], [2497, 2497, 2554, 2554, 3460]], "test": "ok"}
{"id": "wd2XW3", "name": "A loading screen?", "author": "coburn", "description": "Got carried away with making a loading screen and this is what came out of it.", "tags": ["loading"], "likes": 1, "viewed": 177, "published": "Public", "date": "1555169156", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\nconst float cells = 10.0;\n\nconst float steps = cells+1.0;\nconst float cellW = 1.0/cells;\n\nvec4 loaderImage(vec2 uv)\n{\n    float hwr = iResolution.y/iResolution.x;\n    \n\t//Time varying\n    float tStep = floor(mod(iTime/5.0,1.0)*steps); //0.0-10.0 by 1.0s steps\n    float tCell = tStep - 1.0; //The current time varying cell\n    if(tCell < 0.0) //Cell -1 is all cells blank\n        return vec4(0.0);\n    \n    //Pos varying\n    float pCell = floor(uv.x*cells); //Current pixel cell\n    float pCellLoaded = float(pCell <= tCell);\n\tfloat pCellLoadedP1 = float(pCell+1.0 <= tCell);\n    float pCellLoadedM1 = float(pCell-1.0 <= tCell);\n    \n    //Cell coordinates\n    //0.0-1.0 across the cell, square coords in y w/ 0 at center\n    vec2 cl = vec2(mod(uv.x*cells, 1.0), (uv.y-0.5)*cells*hwr);\n\n    //Make halo'd circles in every cell\n    const vec4 inSwatch = vec4(1.0);\n    \n    float dist = length(vec2(0.5,0.5*sin(iTime + pCell*2.0)) - cl);\n    float dist2 = min(length(vec2(1.5,0.5*sin(iTime + pCell*2.0 +2.0)) - cl) + 10000.0*(1.0-pCellLoadedP1),\n                      length(vec2(-0.5,0.5*sin(iTime + pCell*2.0-2.0)) - cl));\n    \n    float distR = 1.0-smoothstep(0.10,0.20,dist) + 1.0-smoothstep(0.20,0.70,dist);\n    float distR2 = 1.0-smoothstep(0.10,0.20,dist2) + 1.0-smoothstep(0.20,0.70,dist2);\n    vec4 outCol = inSwatch * (distR * pCellLoaded + distR2 * pCellLoadedM1) / 2.0;\n    \n    return outCol;\n}\n\nvec4 bloomImage(vec2 uv)\n{\n   const float blurSize = 1.0/512.0;\n   const float intensity = 0.35;\n    \n   vec4 fragColor;\n   vec4 sum = vec4(0);\n   vec2 texcoord = uv;\n   int j;\n   int i;\n\n   //thank you! http://www.gamerendering.com/2008/10/11/gaussian-blur-filter-shader/ for the \n   //blur tutorial\n   // blur in y (vertical)\n   // take nine samples, with the distance blurSize between them\n   sum += loaderImage(vec2(texcoord.x - 4.0*blurSize, texcoord.y)) * 0.05;\n   sum += loaderImage(vec2(texcoord.x - 3.0*blurSize, texcoord.y)) * 0.09;\n   sum += loaderImage(vec2(texcoord.x - 2.0*blurSize, texcoord.y)) * 0.12;\n   sum += loaderImage(vec2(texcoord.x - blurSize, texcoord.y)) * 0.15;\n   sum += loaderImage(vec2(texcoord.x, texcoord.y)) * 0.16;\n   sum += loaderImage(vec2(texcoord.x + blurSize, texcoord.y)) * 0.15;\n   sum += loaderImage(vec2(texcoord.x + 2.0*blurSize, texcoord.y)) * 0.12;\n   sum += loaderImage(vec2(texcoord.x + 3.0*blurSize, texcoord.y)) * 0.09;\n   sum += loaderImage(vec2(texcoord.x + 4.0*blurSize, texcoord.y)) * 0.05;\n\t\n\t// blur in y (vertical)\n   // take nine samples, with the distance blurSize between them\n   sum += loaderImage(vec2(texcoord.x, texcoord.y - 4.0*blurSize)) * 0.05;\n   sum += loaderImage(vec2(texcoord.x, texcoord.y - 3.0*blurSize)) * 0.09;\n   sum += loaderImage(vec2(texcoord.x, texcoord.y - 2.0*blurSize)) * 0.12;\n   sum += loaderImage(vec2(texcoord.x, texcoord.y - blurSize)) * 0.15;\n   sum += loaderImage(vec2(texcoord.x, texcoord.y)) * 0.16;\n   sum += loaderImage(vec2(texcoord.x, texcoord.y + blurSize)) * 0.15;\n   sum += loaderImage(vec2(texcoord.x, texcoord.y + 2.0*blurSize)) * 0.12;\n   sum += loaderImage(vec2(texcoord.x, texcoord.y + 3.0*blurSize)) * 0.09;\n   sum += loaderImage(vec2(texcoord.x, texcoord.y + 4.0*blurSize)) * 0.05;\n\n    \n   sum /= 5.0;\n   //increase blur with intensity!\n   //fragColor = sum*intensity + texture2D(iChannel0, texcoord); \n   if(sin(iTime) > 0.0)\n       fragColor = sum * sin(iTime)+ loaderImage(texcoord);\n   else\n\t   fragColor = sum * -sin(iTime)+ loaderImage(texcoord);\n    \n    return fragColor;\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec4 outCol = bloomImage(uv);\n    \n\tfragColor = outCol;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wd2XW3.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[91, 91, 118, 118, 1407], [1409, 1409, 1435, 1435, 3498], [3502, 3502, 3559, 3559, 3666]], "test": "ok"}
{"id": "wd2XWd", "name": "Menger sponge maze", "author": "edo_m18", "description": "Menger sponge maze.\n\nThis post purpose a menger sponge maze analyzing.\nRefer to this post: https://www.shadertoy.com/view/ldyGWm", "tags": ["menger"], "likes": 5, "viewed": 100, "published": "Public", "date": "1555408046", "time_retrieved": "2021-10-01T00:00:00", "image_code": "///\n/// This post purpose a menger sponge maze analyzing.\n///\n/// Refer to this post: https://www.shadertoy.com/view/ldyGWm\n///\n\n#define FAR 40.\n\nfloat map(vec3 q)\n{   \n    // Layer one.\n \tfloat s = 3.0;\n    \n    vec3 p = abs(fract(q / s) * s - s * 0.5);\n    \n    // Cross distance function.\n    float a1 = max(p.x, p.y);\n    float a2 = max(p.y, p.z);\n    float a3 = max(p.x, p.z);\n    \n \tfloat d = min(a1, min(a2, a3)) - 1.0 + 0.05;\n    \n    float s2 = 1.0;\n    \n    // Layer two.\n    p = abs(fract(q / s2) * s2 - s2 * 0.5);\n    \n    float b1 = max(p.x, p.y);\n    float b2 = max(p.y, p.z);\n    float b3 = max(p.x, p.z);\n    float d2 = min(b1, min(b2, b3)) - 1.0 / 3.0 + 0.05;\n \td = max(d, d2);\n    \n    // Layer three. 3D space is divided by two, instead of three, to give some variance.\n    float s3 = 2.0;\n    p = abs(fract(q * s3) / s3 - (1.0 / s3 * 0.5));\n    \n    float c1 = max(p.x, p.y);\n    float c2 = max(p.y, p.z);\n    float c3 = max(p.x, p.z);\n    float d3 = min(c1, min(c2, c3)) - 0.5 / 3.0 - 0.015;\n \td = max(d, d3);\n\n    // Layer four. The little holes, for fine detailing.\n    float s4 = 3.0 / 0.5;\n    p =  abs(fract(q * s4) / s4 - (1.0 / s4 * 0.5));\n    \n    float e1 = max(p.x, p.y);\n    float e2 = max(p.y, p.z);\n    float e3 = max(p.x, p.z);\n    float d4 = min(e1, min(e2, e3)) - 1.0 / 18.0 - 0.015;    \n    d = max(d, d4);\n\n    return d;\n}\n\n// Very basic raymarching equation. Menger Sponge objects raymarch reasonably well. Not all surfaces do.\nfloat trace(vec3 ro, vec3 rd)\n{    \n    float t = 0., d;\n    \n    for(int i = 0; i < 64; i++)\n    {        \n        d = map(ro + rd * t);\n        \n        if (d <.0025 * t || t>FAR) break;\n        \n        t += d;\n    } \n    \n    return t;\n}\n\nvec3 normal(in vec3 p)\n{\n    // Note the slightly increased sampling distance, to alleviate artifacts due to hit point inaccuracies.\n    vec2 e = vec2(0.005, -0.005); \n    return normalize(e.xyy * map(p + e.xyy) + e.yyx * map(p + e.yyx) + e.yxy * map(p + e.yxy) + e.xxx * map(p + e.xxx));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Unit direction ray vector: Note the absence of a divide term. I came across this via a comment \n    // Shadertoy user \"Coyote\" made. I'm pretty happy with this.\n    vec3 rd = (vec3(2.*fragCoord - iResolution.xy, iResolution.y)); // Normalizing below.\n    \n    // Barrel distortion. Looks interesting, but I like it because it fits more of the scene in.\n    // If you comment this out, make sure you normalize the line above.\n    rd = normalize(vec3(rd.xy, sqrt(max(rd.z*rd.z - dot(rd.xy, rd.xy)*.2, 0.))));\n    \n    // Rotating the ray with Fabrice's cost cuttting matrix. I'm still pretty happy with this also. :)\n    vec2 m = sin(vec2(0, 1.57079632) + iTime / 4.0);\n    rd.xy = mat2(m.y, -m.x, m)*rd.xy;\n    rd.xz = mat2(m.y, -m.x, m)*rd.xz;\n    \n    // Ray origin, set off in the Z direction.\n    vec3 ro = vec3(0.0, 0.0, iTime);\n    \n    // Initiate the scene color to black.\n    vec3 col = vec3(0);\n    \n    float t = trace(ro, rd); // Raymarch.\n    \n    // Scene hit, so do some lighting.\n    if(t < FAR)\n    {\n        vec3 sp = ro + rd * t; // Surface position.\n        vec3 sn = normal(sp); // Surface normal.\n        col = sn;\n    }\n\n    fragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wd2XWd.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[146, 146, 165, 186, 1361], [1363, 1468, 1499, 1499, 1709], [1711, 1711, 1735, 1843, 2001], [2003, 2003, 2060, 2228, 3244]], "test": "ok"}
{"id": "Wd2XWy", "name": "Fractal rings", "author": "edo_m18", "description": "Fractal rings.\n\nI respect below post. I rebuilded the post.\n -> https://www.shadertoy.com/view/3dBXWG", "tags": ["fractal", "ring"], "likes": 5, "viewed": 147, "published": "Public", "date": "1554864617", "time_retrieved": "2021-10-01T00:00:00", "image_code": "///\n/// I respect below post. I rebuilded the post.\n///  -> https://www.shadertoy.com/view/3dBXWG\n///\n\nmat2 rot(float a)\n{\n    float s = sin(a);\n    float c = cos(a);\n    return mat2(c, -s, s, c);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord * 2.0 - iResolution.xy) / iResolution.y;\n    uv *= 0.4 + sin(iTime * 0.5) * 0.1;\n    \n    vec3 col = 0.5 + 0.5 * cos(iTime + uv.xyx + vec3(0, 2, 4));\n\n    vec2 p = uv + uv * sin(iTime) * 0.04;\n    p *= rot(iTime * 0.1);\n    \n    for (float i = 0.0; i < 6.0; i++)\n    {\n        // -1 ~ 1 to 0 ~ 1 + offset\n        p = abs(2.0 * fract(p - 0.5) - 1.0);\n        \n        float t = iTime * 0.5;\n        mat2 mat = rot(p.y * sin(t));\n        p *= mat;\n        \n        col += exp(-abs(p.x) * 15.0);\n    }\n    \n    fragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Wd2XWy.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[103, 103, 122, 122, 198], [200, 200, 257, 257, 820]], "test": "ok"}
{"id": "wdBSRm", "name": "Diamond Octagon Truchet Pattern", "author": "Shane", "description": "Octagonal diamond Truchet pattern. Just a reworking of Fizzer's \"4.8^2 Truchet\" example.", "tags": ["diamond", "truchet", "pattern", "arc", "octagon"], "likes": 34, "viewed": 923, "published": "Public API", "date": "1554293840", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/*\n\n\n\tDiamond Octagon Truchet Pattern\n\t-------------------------------\n\n\tFizzer's already made one of these, so I had the benefit of taking a peek at his \n\tcode before starting this. It kind of felt like looking up the answers at the back\n\tof the book, but it definitely made it a much quicker process. :) I took a similar\n\tapproach to the grid setup, but used a slightly different heuristic approach to \n    determine the tile combinations. I was pretty happy with Fizzer's \"solveCircle\" \n    method, so used that directly. If you'd like to reproduce one of these patterns, \n    I'd definitely refer to his original work, which I've linked to below. \n\n    In theory, all Truchet patterns are simple enough to produce: Partition the grid\n\tvia some kind of regular, semi-regular, or aperiodic tiling method, render \n\tsymmetrical patterns onto each tile, then randomly orientate the tile in accordance\n\twith the symmetry you've chosen.\n\n\tIn this particular case, the canvas is tessellated in a semi-regular fashion with\n\tdiamonds and octagons. A couple of arcs are renderd onto the diamond, and four arcs \n    (two different lengths) are rendered onto the octagonal tile (refer to the shader \n    imagery). To achieve the random pattern, the diamonds and octagons are randomly \n    rotated.\n\n\tOn a side note, it's a trivial matter to render the arcs in an overlapped fashion to \n\tproduce a pretty interesting looking weave. However, I thought I'd leave that for \n    another time. I might also produce a quasi 3D version at some stage.\n\n\n\n    Based on the following:\n\n\t// Like all of Fizzer's examples, it's aesthetically pleasing, and well written.\n\t4.8^2 Truchet - Fizzer\n\thttps://www.shadertoy.com/view/MlyBRG\n\n\n\t// Same principles, but more involved. Very cool looking pattern. The weaved\n\t// version would look pretty crazy.\n\t4.6.12 Truchet - Fizzer\n\thttps://www.shadertoy.com/view/llyBRG\n\n\n*/\n\n\n\n// Arc shape - Circle: 0, Octagon: 1, Hexadecagon: 2.\n//\n// The circular shape is probably the only one that looks pleasing, but I \n// wanted to show that octagonal and hexadecagonal (16 sides) arcs are possilbe.\n// Technically, the octagon option is a mixture of the two latter options.\n#define SHAPE 0\n\n\n// Root 2, or more precisely, an approximation to the principle square root of 2. :)\n#define sqrt2 1.414213562373\n\n\n//  vec2 to float hash.\nfloat hash12(vec2 p){\n\n\treturn fract(sin(dot(p ,vec2(12.9898, 78.233)))*43758.5453);\n}\n\n \n//  vec2 to vec2 hash.\nvec2 hash22(vec2 p){\n\n    return fract(sin(vec2(dot(p,vec2(127.1, 311.7)), dot(p, vec2(269.5, 183.3))))*43758.5453);\n}\n\n\n// Standard 2D rotation formula.\nmat2 rot2(in float a){ float c = cos(a), s = sin(a); return mat2(c, -s, s, c); }\n\n/*\n\tThis is Fizzer's circle solving function. It's very useful, and not just for this\n\tparticular example. I put in some rough comments, for anyone who wants to know how\n\tit comes about. Although, I'd doulbe check the reasoning. \n\n\tI spent quite some time trying to tackle the geometry from a different perspective, \n\tthen realized that since the points A and B would be in constant form, a lot of this \n\twould be optimized by the compiler... Would that be right? Either way, even if it \n\twasn't, it'd be possible to precalculate a lot of this anyway.\n\n\n            A\n             \\\n              \\\n  O------------C (0, 0)\n              /\n             B\n*/\n\n/*\n// Returns the origin and radius of a circle intersecting A and B, with tangents\n// at A and B pointing towards C (vec2(0)). This is for drawing the circular arcs.\nvoid solveCircle(vec2 a, vec2 b, out vec2 o, out float r){\n\n    // Angle between two vectors (AC and BC) defined using an inner product.\n    // cos(th) = a.b/|a||b|\n    float th = acos(dot(normalize(a), normalize(b)))/2.; // Angle OCA\n    float adj = length(a); // Length AC.\n    r = tan(th)*adj; // r is not length OC, it's OA... 15 minutes of my life I won't get back. :)\n    o = normalize(a + b)*sqrt(r*r + adj*adj); // Direction and length of OC.\n \n}\n*/\n\n// adx's considerably more concise version of the method above.\n// On a side note, if you haven't seen it before, his \"Quake / Introduction\" \n// shader is well worth the look: https://www.shadertoy.com/view/lsKfWd\nvoid solveCircle(vec2 a, vec2 b, out vec2 o, out float r){\n    \n    vec2 m = a + b;\n    o = dot(a, a)/dot(m, a)*m;\n    r = length(o - a);\n    \n}\n\n// The following function takes in the color, fractional coordinates, tangential arc \n// end-points, arc width, and a scaling factor -- which is necessary to plot the correct \n// amount of arc lines.\n//\n// A lot of this is just window dressing, so I wouldn't take it too seriously. Without the\n// decoration, this'd be a pretty short function.\nvec3 doArc(vec3 col, float w, float arc, vec2  p, float aNum, float r){\n    \n    \n    // Indexing into the texture prior to coordinate manipulation.\n    vec3 tx = texture(iChannel0, p).xyz; tx *= tx;\n     \n    // Rotating the lines to a different position. Not absolutely necessary, but\n    // I thought they looked neater here.\n    p = rot2(3.14159/aNum)*p;\n    \n \n    // Using the arc distance field for a bit of sinusoidal shading. Not that important,\n    // and not the only way to do it, but it enhances the borders a bit.\n    float shade = min(abs(arc)/.1*1.25, 1.);\n    shade = clamp(-sin(shade*2.*6.283) + .25, 0., 1.);\n\n    \n    // Cell pixel angle.\n    float ang = atan(p.y, p.x); \n    // Quantizing and repeating the angle, whilst snapping to the center.\n    float ia = (floor(ang/6.2831*aNum) + .5)/aNum;\n    \n    // Polar coordinates -- Radial and angular.\n    p = rot2(ia*6.2831)*p;\n    p.x -= r; // Moving the center of the cell out to the arc radius.\n    \n\n    // Thin rectangles (spaced out around the arc), to emulated dividing lines. \n    p = abs(p);\n    float d = max(p.x - .05, p.y + .005);\n    // Cheaper, but not as nice. It's there for comparison.\n    //float d = clamp(cos(ang*aNum)*1. + .25, 0., 1.);\n    \n    // Combining the dividing lines with the arc to create the partitioned squares.\n    d = max(arc + .045, -d);\n    \n    // Dots: Interesting, but not as well suited to the example.\n    //float d = length(p) - .05;\n    \n    \n    // Arc coloring, slightly blended into  the background.\n    vec3 arcCol = mix(tx*1.5, vec3(1, .9, .8), .75);\n    \n    // Texture colored border lines.\n    col = mix(col, vec3(0), (1. - smoothstep(-w*8., w*8., arc - .04))*.5);\n    col = mix(col, vec3(0), 1. - smoothstep(-w, w, arc - .015));\n    col = mix(col, arcCol*shade*vec3(1.2, .8, .6)*vec3(1.5, .9, .6), 1. - smoothstep(-w, w, arc + .015));\n    \n     \n    // Applying the white partitioned squares.\n    col = mix(col, vec3(0), (1. - smoothstep(-w*2., w*2., d - .01))*.5);\n    col = mix(col, vec3(0), 1. - smoothstep(-w, w, d));\n    col = mix(col, arcCol, 1. - smoothstep(-w, w, d + .02));\n    \n    // Return the decorated arc color.\n    return col;\n}\n\n\n\n\n// Distance metric.\nfloat dist(vec2 p, float sc){\n    \n    #if SHAPE == 0\n    return length(p); // Circle.\n    #elif SHAPE == 1\n    p = abs(p);\n    float oct = max((p.y + p.x)/sqrt2, max(p.x, p.y)); // Octagon.\n    p *= rot2(3.14159/8.);\n    float dec = max(oct, max((p.y + p.x)/sqrt2, max(p.x, p.y)));\n    return sc<32.?  oct : dec;\n    #else    \n    p = abs(p);\n    float d = max((p.y + p.x)/sqrt2, max(p.x, p.y));\n    p *= rot2(3.14159/8.);\n    return max(d, max((p.y + p.x)/sqrt2, max(p.x, p.y))); // Hexadecagon.\n    #endif\n    \n}\n\n// The following function takes in the color, fractional coordinates, tangential arc \n// end-points, arc width, and a scaling factor -- which is necessary to plot the correct \n// amount of arc lines.\nvec3 renderArc(vec3 col, vec2 p, vec2 a, vec2 b, float aw, float sc){\n      \n    // Falloff factor.\n    float w = 3./iResolution.y;\n\n    // Applying Fizzer's \"solveCircle\" function, which returns the\n    // origin and radius of the circle that cuts through the end-points\n    // \"a\" and \"b\".\n    vec2 o; float r;\n    solveCircle(a, b, o, r);   \n\n    // Circular distance.\n    float arc = dist(p - o, sc);\n    // Just the outer rim of the circle. \"aw\" is the width.\n    arc = abs(arc - r) - aw; \n    \n    // Render the arc. You could make this function as simple or as\n    // esoteric as you want, depending on the level of detail required.\n    col = doArc(col, w, arc, p - o, sc, r);\n\n    // Return the decorated arc color.\n    return col;\n}\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n\n    // Normalized pixel coordinates.\n    vec2 uv = fragCoord/min(iResolution.y, 650.);\n    \n    // Scaling and translation.\n    vec2 p = uv*4. + vec2(1, .25)*iTime;   \n    p = rot2(3.14159/8.)*p;\n    vec2 oP = p; // Keeping a copy for later.\n    \n    // Falloff factor, based on resolution. \n    float w = 1./iResolution.y;\n    // Fizzer's falloff factor. It works, but I get a bit paranoid when it comes to\n    // the behaviour of differnt GPUs. :)\n    //float w = max(length(dFdx(p)), length(dFdy(p)))/2.;\n    \n    \n    \n    // Rendering variables.\n    \n    // Just a quick debug hack. Set the first slot to zero to omit the diamond\n    // background, and\\or the second slot to omit the octagonal background.\n    const vec2 doBg = vec2(1, 1);\n    \n    // Load in a texture, perform some round sRGB to linear conversion, then\n    // set a version of it to the background.\n    vec3 tx = texture(iChannel0, oP/4. + .3).xyz; tx *= tx;\n    vec3 bg = tx*vec3(2, 1.45, 1);\n    \n    // Initiate the color to the background.\n    vec3 col = bg;\n \n    \n    const float aw = .1; // Arc width.\n    const float scL = 80.; // Large arc scale.\n    const float scS = 16.; // Small arc scale.\n    \n    \n    // Performing a diamond octagon partitioning: It's slightly more involved than\n    // a single tile partitioning, but not that difficult.\n    //    \n    vec2 ip = floor(p); // Diamond ID.\n    p -= ip + .5; // Fractional coordinates. Equivalent to: fract(p) - .5.\n    \n    // 2D diamond field... The dimensions are calculated using basic trigonometry. \n    // Although, I was still too lazy to do it myself.\n    float dia = abs(p.x) + abs(p.y) - (1. - sqrt2/2.);\n    \n    \n    // If we're inside a diamond, then render the diamond tile. Anything outside of this\n    // will obviously be inside an octagon tile.\n    if(dia<.0){\n        \n        \n        if(doBg.x>.5){\n            \n            //vec3 dCol = mix(bg*1.5, vec3(1, .9, .8), .65);\n            vec3 dCol = bg*2.;\n            float snD = clamp(-cos(dia*6.2831*16. + 3.14159/2.)*1. + .75, 0., 1.);\n            dCol *= vec3(1, .8, .6)*snD;\n            //dCol = bg*vec3(1, 2, 3)*snD;\n            //dCol = bg*vec3(1.5, 2.125, 2.75)*snD;\n             \n            col = mix(col, vec3(0), 1. - smoothstep(-w, w, dia - .015));\n            col = mix(col, dCol, 1. - smoothstep(-w, w, dia + .015));\n        }\n        \n        \n        // Obtain a random ID for the diamond cell, and if it's over a certain threshold,\n        // rotate it by 90 degrees; It's a standard square Truchet move.\n        if(hash12(ip + .59)>.5) p = p.yx;\n        \n        \n        // Render the two arcs (refer to the shader imagery). By the way, we're using Fizzer's \n        // \"solveCircle\" method for completeness, but you could calculate it pretty easily by hand, \n        // if necessary.\n        const float k = .5 - sqrt2/4.;\n        \n        // The following function takes in the color, fractional coordinates, tangential arc end-points, \n        // arc width, and a scaling factor -- which is necessary to plot the correct amount of arc lines.\n        col = renderArc(col, p, vec2(k, k), vec2(k, -k), aw, scS);\n        col = renderArc(col, p, vec2(-k, k), vec2(-k, -k), aw, scS);\n        \n    }\n    else {\n        \n        // If we're inside an octagon cell (outside a diamond), then obtain the \n        // ID (similar to the diaomond ID, but offset by half a cell) and \n        // fractional coordinates.\n        p = oP - .5;\n        vec2 ip = floor(p);\n        p -= ip + .5; // Equivalent to: fract(p) - .5;\n        \n        \n        // 2D octagonal bound: There's a few ways to achieve the same, but this will\n        // do. We're giving it a diameter of one, to fill up the cell. By the way, we're\n        // only using this for background decoration. Otherwise, we wouldn't need it.\n        float oct = max((abs(p.x) + abs(p.y))/sqrt2, max(abs(p.x), abs(p.y))) - .5;\n \n        \n        // Some random numbers. It's a bit hacky, but it'll do. In fact, I should \n        // probably lash out and use one of Dave Hoskins's hash formulae.\n        vec3 rnd3 = vec3(hash22(ip + vec2(37.73, 132.57)), hash12(ip)); \n       \n        \n        \n        // If applicable, render the octagonal background pattern. I wouldn't pay too much \n        // attention to any of this. A lot of it was made up as I went along. :)\n        if(doBg.y>.5){\n            \n            \n            // Weird hack: The drop shadows make the the octagon backgrounds covered with double\n            // arcs look a little dark, so I've lit them up a little. \n            if(rnd3.x>.5 && rnd3.y>.5) col *= 1.25;\n            \n            // Random octagonal cell coloring, if you like that kind of thing.\n            //if(hash(rnd3.z*37.2 + .53)>.5) col *= vec3(1, .5, 1.5); \n            //if(hash(rnd3.z*71.3 + .71)>.5) col = mix(col.zyx, dot(col, vec3(.299, .587, .114))*vec3(1), .5);\n            // Subtle checkerboard coloring.\n            //if(mod(ip.x + ip.y, 2.)>.5) col = mix(col, col.xzy, .35);\n            //if(mod(ip.x + ip.y, 2.)<.5) col = mix(col.zyx, dot(col, vec3(.299, .587, .114))*vec3(1), .5);\n             \n            \n            // A cheap way to render some repeat lines... There are better ways, but this works.\n            float snD = clamp(cos(oct*6.2831*20. + 3.14159/2.)*2. + 1.5, 0., 1.);\n            //col *= (clamp(cos(length(p)*6.2831*20. + 3.14159/2.)*2. + 1.5, 0., 1.)*.8 + .2);\n            \n            // The octagonal border.\n            float octTor = abs(oct + .1666/2. - .015) - .1666/2. + .015;\n            col = mix(col, vec3(0), (1. - smoothstep(-w*5., w*5., octTor - .03))*.5);\n            col = mix(col, vec3(0), 1. - smoothstep(-w, w, octTor - .015));\n            col = mix(col, bg/1.25*(snD*.75 + .25), 1. - smoothstep(-w, w, octTor + .015));\n\n           \n            // The circular or octagonal pattern inside the octagon.\n            \n            #if SHAPE == 0\n                // A circular decoration.\n                float shp = length(p) - .14;\n            #else\n                // A star variation, if that's you're thing.\n                //oct = min((abs(p.x) + abs(p.y))/sqrt2, max(abs(p.x), abs(p.y))) - .5;\n                // An octagonal center decoration.\n                float shp = oct + .1666 + .2;//max(abs(p.x), abs(p.y)) - .15;// - (1. - sqrt2/2.);\n            #endif\n            \n            snD = clamp(-sin(shp*6.2831*20. + 3.14159/2.)*1. + .5, 0., 1.); // Concentric rings.\n            \n            // Render the central bullseye pattern.\n            col = mix(col, vec3(0), 1. - smoothstep(-w, w, shp - .065));\n            col = mix(col, mix(bg*1.5, vec3(1, .9, .8), .65), (1. - smoothstep(-w*2., w*2., shp - .03)));\n            col = mix(col, vec3(0), 1. - smoothstep(-w*2., w*2., shp - .015));\n            col = mix(col, bg/1.*(snD*.95 + .05)*vec3(1.5, 2.125, 2.75), 1. - smoothstep(-w, w, shp + .015));\n          \n          \n        }\n        \n        \n        // Rendering the octagonal arc patterns over the background.\n        \n        // Use the unique octagonal ID to produce a random integer that can be used to\n        // randomly rotate the octagonal coordinates about its rotationally symmetric axes.\n        float iRnd = floor(rnd3.z*8.);\n        p = rot2(3.14159/4.*iRnd)*p;\n        \n        // A point that cuts the midway point of the top side... prior to rotation.\n        vec2 a = vec2(0, .5);\n        \n        // Rotational matrices -- to help rotate mid-points.\n        mat2 r1 = rot2(3.14159/4.), r2 = rot2(3.14159/2.), r3 = rot2(3.14159/4.*3.);\n        \n        \n        \n        \n        // I came up with this logic pretty quickly, but I think it's sound... Having said that, \n        // you'd be much better off referring to Fizzer's workings, as it's more elegant.\n        //\n        // On one side of the octagon, render either a long arc surrounding a small arc, or\n        // two adjacent small arcs. On the other side of the octagon, use another random number\n        // to do the same.\n            \n        \n        // One half of the octagon.\n        if(rnd3.x>.5){\n\n            // The following function takes in the color, fractional coordinates, tangential arc \n            // end-points, arc width, and a scaling factor -- which is necessary to plot the correct \n            // amount of arc lines.\n            col = renderArc(col, p, a, r3*a, aw, scL);\n            col = renderArc(col, p, r1*a, r2*a, aw, scS);\n        }\n        else {\n           \n            col = renderArc(col, p, a, r1*a, aw, scS);\n            col = renderArc(col, p, r2*a, r3*a, aw, scS);\n        }\n           \n        a = -a; // Simple way to render the other half.\n   \n        // Other half of the octagon.\n        if(rnd3.y>.5){\n       \n            col = renderArc(col, p, a, r3*a, aw, scL);\n            col = renderArc(col, p, r1*a, r2*a, aw, scS);\n        }\n        else {\n            \n            col = renderArc(col, p, a, r1*a, aw, scS);\n            col = renderArc(col, p, r2*a, r3*a, aw, scS);\n        }\n\n        \n    }\n    \n     \n    // Mixing in a bit of pink down the bottom of the canvas, to give a sunset feel? :)\n    col = mix(col.xzy, col, pow(uv.y, .25));\n    \n    // Subtle vignette.\n    uv = fragCoord/iResolution.xy;\n    col *= pow(16.*uv.x*uv.y*(1. - uv.x)*(1. - uv.y) , .0625);\n    // Colored variation.\n    //col = mix(col.zyx, col, pow(16.*uv.x*uv.y*(1. - uv.x)*(1. - uv.y) , .125));\n\n    \n    \n    // Rough gamma correction and output to screen\n    fragColor = vec4(sqrt(max(col, 0.)), 1);\n    \n}", "image_inputs": [{"id": "XsfGRn", "previewfilepath": "/media/ap/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wdBSRm.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[2322, 2346, 2367, 2367, 2432], [2436, 2459, 2479, 2479, 2577], [2580, 2613, 2635, 2635, 2693], [3979, 4193, 4251, 4251, 4337], [4339, 4683, 4754, 4831, 6851], [6856, 6876, 6905, 6905, 7391], [7393, 7593, 7662, 7692, 8334], [8337, 8337, 8391, 8429, 17892]], "test": "error"}
{"id": "wdBSRV", "name": "5.2", "author": "beefburrito", "description": "32rdc", "tags": ["222d3d2"], "likes": 1, "viewed": 254, "published": "Public API", "date": "1554390026", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI 3.14159265359\n\nvec3 colorA = vec3(0.149,0.141,0.912);\nvec3 colorB = vec3(.40,0.533,0.224);\n\nfloat plot (vec2 st, float pct){\n  return  smoothstep( pct-0.01, pct, st.y) -\n          smoothstep( pct, pct+0.01, st.y);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 col = vec3(0.0);\n    float pct = abs(sin(iTime));\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    float r = smoothstep(0.0,1.0, uv.x);\n    float g = sin(uv.x*PI);\n    float b = pow(uv.x,0.5);\n\n    // Time varying pixel color\n    col = mix(colorA, colorB, pct);\n    col = mix(col,vec3(.0,1.0,0.0),plot(uv,r));\n    col = mix(col,vec3(0.0,1.0,1.0),plot(uv,g));\n    col = mix(col,vec3(1.0,0.0,1.0),plot(uv,b));\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wdBSRV.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[103, 103, 135, 135, 226], [228, 228, 285, 285, 809]], "test": "ok"}
{"id": "WdBSWd", "name": "Dance of pluses", "author": "avin", "description": "dance of pluses", "tags": ["rotate"], "likes": 8, "viewed": 402, "published": "Public API", "date": "1555250583", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define SIZE 25.0 \n#define COL_BLACK vec3(23, 32, 38) / 255.0 \n#define COL_WHITE vec3(245, 248, 250) / 255.0 \n \nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n {     \n    vec2 uv = (fragCoord - iResolution.xy * 0.5) / iResolution.y;\n     \n    vec2 ouv = floor(uv * SIZE) / SIZE;    \n    uv *= SIZE;    \n    uv = fract(uv) - 0.5;\n    \n    float a = length(ouv * 5.0) - iTime * 2.5;\n    float ca = cos(a);\n    float sa = sin(a);\n    mat2 rot = mat2(ca, - sa, sa, ca);\n    \n    uv *= rot;\n    \n    float sm = 1.0 / (iResolution.x / SIZE) * 2.0;\n    float s = 0.05;\n    float mask = smoothstep(s + sm, s, abs(uv.x));\n    mask += smoothstep(s + sm, s, abs(uv.y));\n    \n    s = 0.25 + (ca * 0.5 + 0.5) * 0.2;\n    mask *= smoothstep(s, s - sm, abs(uv.x));\n    mask *= smoothstep(s, s - sm, abs(uv.y));\n    \n    vec3 col = mix(COL_BLACK, COL_WHITE, mask);\n    \n    fragColor = vec4(col, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WdBSWd.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[112, 112, 168, 168, 893]], "test": "ok"}
{"id": "WdBXzG", "name": "Ride the Breeze", "author": "dr2", "description": "Spreading the seed (mouseable)", "tags": ["fibonacci", "wind", "seed"], "likes": 2, "viewed": 329, "published": "Public API", "date": "1554133134", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// \"Ride the Breeze\" by dr2 - 2019\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\n#define AA  1  // optional antialiasing\n\nfloat PrSphDf (vec3 p, float r);\nfloat PrCylDf (vec3 p, float r, float h);\nvec4 SphFib (vec3 v, float n);\nvec3 RotToDir (vec3 v1, vec3 v2, vec3 p);\nvec2 Rot2D (vec2 q, float a);\nfloat Minv3 (vec3 p);\nfloat Hashfv2 (vec2 p);\nfloat Hashfv3 (vec3 p);\nvec3 Hashv3f (float p);\nfloat Fbm1 (float p);\nfloat Fbm2 (vec2 p);\n\nvec3 bGrid, sunDir, pOff, aRot;\nfloat dstFar, tCur, vSpd;\nint idObj;\nbool cOcc;\nconst float pi = 3.14159;\n\n#define DMIN(id) if (d < dMin) { dMin = d;  idObj = id; }\n\nfloat ObjDf (vec3 p, vec3 cId)\n{\n  vec4 f4;\n  float dMin, d, rad, len;\n  dMin = dstFar;\n  rad = 0.06;\n  len = 0.4;\n  if (cOcc) {\n    p -= pOff;\n    d = PrSphDf (p, 2. * len + rad + 0.06);\n    if (d < 0.05) {\n      p.yz = Rot2D (p.yz, aRot.x);\n      p.xz = Rot2D (p.xz, aRot.y);\n      p.xy = Rot2D (p.xy, aRot.z);\n      f4 = SphFib (normalize (p), 200.);\n      d = PrSphDf (p, rad);\n      DMIN (1);\n      p = RotToDir (f4.yzw, vec3 (0., 0., 1.), p - f4.yzw);\n      len -= 0.03 * Hashfv3 (73. * f4.yzw);\n      p.z -= -1. + rad + len;\n      d = PrCylDf (p, 0.1 * rad * (1. - 0.5 * abs (p.z) / len), len);\n      DMIN (2);\n      dMin *= 0.5;\n    } else dMin = d;\n  }\n  return dMin;\n}\n\nvoid SetConf (vec3 cId)\n{\n  vec3 vRan;\n  vRan = Hashv3f (dot (cId, vec3 (31.1, 41.1, 51.1)) + 99.);\n  cOcc = (vRan.x * step (2., length (cId.xz)) > 0.6);\n  if (cOcc) {\n    pOff = bGrid * (cId + 0.5) + (0.2 + 0.1 * bGrid.x * vRan.x) *\n       vec3 (sin (0.6 * vRan.z * tCur + vRan.x) * vec2 (0.5 * pi, 0.), 0.).xzy;\n    aRot = (vRan - 0.5) * 0.5 * tCur;\n  }\n}\n\nfloat ObjRay (vec3 ro, vec3 rd)\n{\n  vec3 p, rdi, cId, cIdP, s, sb, sf;\n  float dHit, d, eps;\n  eps = 0.0005;\n  if (rd.x == 0.) rd.x = 0.001;\n  if (rd.y == 0.) rd.y = 0.001;\n  if (rd.z == 0.) rd.z = 0.001;\n  rdi = 1. / rd;\n  sf = bGrid * rdi;\n  sb = sf * step (0., rd);\n  cIdP = vec3 (-99.);\n  dHit = eps;\n  for (int j = 0; j < 160; j ++) {\n    p = ro + dHit * rd;\n    cId.xz = floor (p.xz / bGrid.xz);\n    p.y -= vSpd * tCur * (1. + Hashfv2 (cId.xz));\n    cId.y = floor (p.y / bGrid.y);\n    if (cId != cIdP) {\n      cIdP = cId;\n      SetConf (cId);\n    }\n    d = ObjDf (p, cId);\n    s = sb + sf * cId - p * rdi;\n    d = min (d, abs (Minv3 (s)) + eps);\n    dHit += d;\n    if (d < eps || dHit > dstFar) break;\n  }\n  if (d >= eps) dHit = dstFar;\n  return dHit;\n}\n\nfloat ObjDfN (vec3 p)\n{\n  vec3 cId;\n  cId.xz = floor (p.xz / bGrid.xz);\n  p.y -= vSpd * tCur * (1. + Hashfv2 (cId.xz));\n  cId.y = floor (p.y / bGrid.y);\n  return ObjDf (p, cId);\n}\n\nvec3 ObjNf (vec3 p)\n{\n  vec4 v;\n  vec2 e = vec2 (0.00002, -0.00002);\n  v = vec4 (- ObjDfN (p + e.xxx), ObjDfN (p + e.xyy), ObjDfN (p + e.yxy), ObjDfN (p + e.yyx));\n  return normalize (2. * v.yzw - dot (v, vec4 (1.)));\n}\n\nvec3 BgCol (vec3 ro, vec3 rd)\n{\n  vec3 col, clCol;\n  vec2 q;\n  float f, fd, ff;\n  if (rd.y > -0.02 && rd.y < 0.03 * Fbm1 (16. * atan (rd.z, - rd.x))) {\n    col = mix (vec3 (0.4, 0.5, 0.7), vec3 (0.3, 0.45, 0.55), smoothstep (-0.02, 0.01, rd.y));\n  } else if (rd.y > 0.) {\n    q = 0.005 * (ro.xz + tCur * vec2 (0.5, 2.) + ((200. - ro.y) / rd.y) * rd.xz);\n    ff = Fbm2 (q);\n    f = smoothstep (0.1, 0.8, ff);\n    fd = smoothstep (0.1, 0.8, Fbm2 (q + 0.01 * sunDir.xz)) - f;\n    clCol = (0.8 + 0.5 * ff) * (vec3 (0.7) - 0.7 * vec3 (0.3, 0.3, 0.2) * sign (fd) *\n       smoothstep (0., 0.05, abs (fd)));\n    fd = smoothstep (0.01, 0.1, rd.y);\n    col = mix (mix (vec3 (0.8, 0.8, 0.75), vec3 (0.4, 0.5, 0.8), 0.3 + 0.7 * fd), clCol,\n       0.1 + 0.9 * f * fd);\n  } else {\n    col = vec3 (0.1, 0.5, 0.1);\n  }\n  return col;\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  vec3 col, bgCol, vn;\n  float dstObj;\n  bGrid = vec3 (4.);\n  vSpd = 0.1;\n  bgCol = BgCol (ro, rd);\n  dstObj = ObjRay (ro, rd);\n  if (dstObj < dstFar) {\n    ro += dstObj * rd;\n    vn = ObjNf (ro);\n    if (idObj == 1) col = vec3 (0.5, 0.7, 0.3);\n    else col = vec3 (1., 1., 0.9);\n    col *= 0.5 + 0.7 * max (dot (vn, sunDir), 0.);\n    col = mix (col, bgCol, 0.1 + 0.9 * smoothstep (0.5 * dstFar, dstFar, dstObj));\n  } else col = bgCol;\n  return clamp (col, 0., 1.);\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  mat3 vuMat;\n  vec4 mPtr;\n  vec3 ro, rd, col;\n  vec2 canvas, uv, ori, ca, sa;\n  float el, az, sr, zmFac;\n  canvas = iResolution.xy;\n  uv = 2. * fragCoord.xy / canvas - 1.;\n  uv.x *= canvas.x / canvas.y;\n  tCur = iTime;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / canvas - 0.5;\n  az = 0.;\n  el = 0.08 * pi;\n  zmFac = 4.;\n  if (mPtr.z > 0.) {\n    az += 2. * pi * mPtr.x;\n    el += 0.5 * pi * mPtr.y;\n  }\n  el = clamp (el, 0.075 * pi, 0.45 * pi);\n  ori = vec2 (el, az);\n  ca = cos (ori);\n  sa = sin (ori);\n  vuMat = mat3 (ca.y, 0., - sa.y, 0., 1., 0., sa.y, 0., ca.y) *\n          mat3 (1., 0., 0., 0., ca.x, - sa.x, 0., sa.x, ca.x);\n  ro = vec3 (0.5);\n  dstFar = 32.;\n  sunDir = normalize (vec3 (1., 2., -1.));\n#if ! AA\n  const float naa = 1.;\n#else\n  const float naa = 3.;\n#endif  \n  col = vec3 (0.);\n  sr = 2. * mod (dot (mod (floor (0.5 * (uv + 1.) * canvas), 2.), vec2 (1.)), 2.) - 1.;\n  for (float a = 0.; a < naa; a ++) {\n    rd = vuMat * normalize (vec3 (uv + step (1.5, naa) * Rot2D (vec2 (0.5 / canvas.y, 0.),\n       sr * (0.667 * a + 0.5) * pi), zmFac));\n    col += (1. / naa) * ShowScene (ro, rd);\n  }\n  fragColor = vec4 (col, 1.);\n}\n\nfloat PrSphDf (vec3 p, float r)\n{\n  return length (p) - r;\n}\n\nfloat PrCylDf (vec3 p, float r, float h)\n{\n  return max (length (p.xy) - r, abs (p.z) - h);\n}\n\nvec4 SphFib (vec3 v, float n)\n{   // Keinert et al's inverse spherical Fibonacci mapping\n  vec4 b;\n  vec3 vf, vfMin;\n  vec2 ff, c;\n  float fk, ddMin, dd, a, z, ni;\n  const float phi = 1.618034;\n  ni = 1. / n;\n  fk = pow (phi, max (2., floor (log (n * pi * sqrt (5.) * dot (v.xy, v.xy)) /\n     log (phi + 1.)))) / sqrt (5.);\n  ff = vec2 (floor (fk + 0.5), floor (fk * phi + 0.5));\n  b = vec4 (ff * ni, pi * (fract ((ff + 1.) * phi) - (phi - 1.)));\n  c = floor ((0.5 * mat2 (b.y, - b.x, b.w, - b.z) / (b.y * b.z - b.x * b.w)) *\n     vec2 (atan (v.y, v.x), v.z - (1. - ni)));\n  ddMin = 4.1;\n  for (int j = 0; j < 4; j ++) {\n    a = dot (ff, vec2 (j - 2 * (j / 2), j / 2) + c);\n    z = 1. - (2. * a + 1.) * ni;\n    vf = vec3 (sin (2. * pi * fract (phi * a) + vec2 (0.5 * pi, 0.)) * sqrt (1. - z * z), z);\n    dd = dot (vf - v, vf - v);\n    if (dd < ddMin) {\n      ddMin = dd;\n      vfMin = vf;\n    }\n  }\n  return vec4 (sqrt (ddMin), vfMin);\n}\n\nvec3 RotToDir (vec3 v1, vec3 v2, vec3 p)\n{\n  vec3 n;\n  float c;\n  n = normalize (cross (v1, v2));\n  c = dot (v1, v2);\n  return c * p + sqrt (1. - c * c) * cross (n, p) + (1. - c) * dot (n, p) * n;\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  vec2 cs;\n  cs = sin (a + vec2 (0.5 * pi, 0.));\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nfloat Minv3 (vec3 p)\n{\n  return min (p.x, min (p.y, p.z));\n}\n\nconst float cHashM = 43758.54;\n\nfloat Hashfv2 (vec2 p)\n{\n  return fract (sin (dot (p, vec2 (37., 39.))) * cHashM);\n}\n\nfloat Hashfv3 (vec3 p)\n{\n  return fract (sin (dot (p, vec3 (37., 39., 41.))) * cHashM);\n}\n\nvec2 Hashv2f (float p)\n{\n  return fract (sin (p + vec2 (0., 1.)) * cHashM);\n}\n\nvec2 Hashv2v2 (vec2 p)\n{\n  vec2 cHashVA2 = vec2 (37., 39.);\n  return fract (sin (vec2 (dot (p, cHashVA2), dot (p + vec2 (1., 0.), cHashVA2))) * cHashM);\n}\n\nvec3 Hashv3f (float p)\n{\n  return fract (sin (p + vec3 (37., 39., 41.)) * cHashM);\n}\n\nfloat Noiseff (float p)\n{\n  vec2 t;\n  float ip, fp;\n  ip = floor (p);\n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = Hashv2f (ip);\n  return mix (t.x, t.y, fp);\n}\n\nfloat Noisefv2 (vec2 p)\n{\n  vec2 t, ip, fp;\n  ip = floor (p);  \n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = mix (Hashv2v2 (ip), Hashv2v2 (ip + vec2 (0., 1.)), fp.y);\n  return mix (t.x, t.y, fp.x);\n}\n\nfloat Fbm1 (float p)\n{\n  float f, a;\n  f = 0.;\n  a = 1.;\n  for (int j = 0; j < 5; j ++) {\n    f += a * Noiseff (p);\n    a *= 0.5;\n    p *= 2.;\n  }\n  return f * (1. / 1.9375);\n}\n\nfloat Fbm2 (vec2 p)\n{\n  float f, a;\n  f = 0.;\n  a = 1.;\n  for (int j = 0; j < 5; j ++) {\n    f += a * Noisefv2 (p);\n    a *= 0.5;\n    p *= 2.;\n  }\n  return f * (1. / 1.9375);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WdBXzG.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[646, 646, 678, 678, 1324], [1326, 1326, 1351, 1351, 1683], [1685, 1685, 1718, 1718, 2444], [2446, 2446, 2469, 2469, 2625], [2627, 2627, 2648, 2648, 2846], [2848, 2848, 2879, 2879, 3666], [3668, 3668, 3703, 3703, 4171], [4173, 4173, 4229, 4229, 5367], [5369, 5369, 5402, 5402, 5429], [5431, 5431, 5473, 5473, 5524], [5526, 5526, 5557, 5614, 6464], [6466, 6466, 6508, 6508, 6664], [6666, 6666, 6696, 6696, 6809], [6811, 6811, 6833, 6833, 6871], [6905, 6905, 6929, 6929, 6989], [6991, 6991, 7015, 7015, 7080], [7082, 7082, 7106, 7106, 7159], [7161, 7161, 7185, 7185, 7315], [7317, 7317, 7341, 7341, 7401], [7403, 7403, 7428, 7428, 7574], [7576, 7576, 7601, 7601, 7787], [7789, 7789, 7811, 7811, 7965], [7967, 7967, 7988, 7988, 8143]], "test": "error"}
{"id": "wdjSDG", "name": "Sci-fi Building Shapes", "author": "TekF", "description": "I decided to turn [url=https://www.shadertoy.com/view/Md3yzH]my 2D sci-fi buildings[/url] into 3D.", "tags": ["procedural", "raymarching", "architecture"], "likes": 15, "viewed": 460, "published": "Public API", "date": "1554898021", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Sci-fi Building Shapes\n// by Hazel Quantock 2019\n// This work is licensed under a Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International License. http://creativecommons.org/licenses/by-nc-sa/4.0/\n\n// reduce this to improve frame rate in windowed mode (0 disables anti-aliasing)\n#define AA_QUALITY 3\n\n// allow a little bleed between pixels - I think this looks more photographic, but blurrier\n#define AA_ROUND false\n#define AA_ROUND_RADIUS 0.7071\n\n\nconst float phi = 1.6180339887498948;\nconst float tau = 6.2831853071795865;\n\n// from here: https://www.shadertoy.com/view/4dVBzz\n#define M1 1597334677U     //1719413*929\n#define M2 3812015801U     //140473*2467*11\n#define M3 3299493293U     //467549*7057\n\n#define F0 (1.0/float(0xffffffffU))\n\n#define hash(n) n*(n^(n>>15))\n\n#define coord1(p) ((p)*M1)\n#define coord2(p) ((p).x*M1^(p).y*M2)\n#define coord3(p) ((p).x*M1^(p).y*M2^(p).z*M3)\n\nfloat hash1(uint n){return float(hash(n))*F0;}\nvec2 hash2(uint n){return vec2(hash(n)*uvec2(0x1U,0x3fffU))*F0;}\nvec3 hash3(uint n){return vec3(hash(n)*uvec3(0x1U,0x1ffU,0x3ffffU))*F0;}\nvec4 hash4(uint n){return vec4(hash(n)*uvec4(0x1U,0x7fU,0x3fffU,0x1fffffU))*F0;}\n\n\nuint seed = 1u;\n\nfloat Polygon( vec2 uv, float h )\n{\n    vec4 rand1 = hash4(coord3(uvec3(h*2.,0,seed)));\n    vec4 rand2 = hash4(coord3(uvec3(h*2.,1,seed)));\n    \n    float mid = (rand1.x-.5)*exp2(-h*2.);\n    float f = abs(uv.y-rand1.y+.5)-rand1.z-2.; //2.*mix(1.,rand(),.5+.5*h); // so 1.+rand->2.*rand\n    f = max(f,abs(uv.x-mid)-rand1.w-.5+h*.4); //1.5*mix(1.,rand(),.7+.3*h);\n    f = max(f,abs(dot(uv,vec2(1,1)/sqrt(2.))-rand2.x+.5)-rand2.y-1.);\n    f = max(f,abs(dot(uv,vec2(1,-1)/sqrt(2.))-rand2.z+.5)-rand2.w-1.);\n    \n    // support-stalk\n    //f = min(f,max(uv.y,abs(uv.x-mid)-.1));\n    \n    return f;\n}\n\n\nfloat BevelMax( float a, float b, float bevelSize )\n{\n    return max(max(a,b), dot(vec2(a,b),normalize(vec2(.5,1))) + bevelSize );\n}\n\nfloat SDF( vec3 p )\n{\n\t// octahedral, but with random distances so some planes won't be seen\n    float a = Polygon( p.zy-vec2(0,0), 0. );\n    float b = Polygon( p.zy-vec2(0,2), .5 );\n    float c = Polygon( p.zy-vec2(0,4), 1. );\n\n/*    vec3 f = vec3(a,min(a,b),min(min(a,b),c));\n    f = max( f, vec3(abs(p.x)-.2) );\n    return min( f.z, p.y+.5 ); // ground*/\n    \n    float w = abs(p.x);\n\n    vec3 rand = hash3(coord1(seed^0x1999u));\n    \n    float ground = p.y+.5;\n    \n    return min(min(min(BevelMax(a,w-rand.x,.1),BevelMax(b,w-rand.y,.03)),BevelMax(c,w-rand.z,.1)),ground);\n}\n\n\n\n// higher precision trace function canibalised from one of my other shaders - not sure if this is the best version but it's good enough\nconst float epsilon = .0004;\nfloat Trace( vec3 rayStart, vec3 rayDirection )\n{\n    float t = 0.;\n    \n    float h = 0.;\n    float lasth = 0.;\n    float bestt = 0.;\n    float bestDist = 1e30;\n    float sdf = 0.;\n    for ( int i=0; i < 200; i++ )\n    {\n        lasth = h;\n        sdf = SDF( rayDirection*t+rayStart );\n        h = sdf + epsilon*.5;\n\t\tt += h;\n        if ( sdf < bestDist ) { bestt = t; bestDist = sdf; } // not sure if all these conditionals will compile well, could flip to use step and mix\n        if ( h < epsilon ) break;\n    }\n\n    if ( sdf == bestDist )\n    {\n        // improve precision\n\t\tfloat lastt = t-epsilon;\n\t\tfloat lastsdf = SDF( rayDirection*lastt+rayStart );\n\t\tfloat sdf = SDF( rayDirection*t+rayStart );\n       \tt = mix( lastt, t, (0.-lastsdf)/(sdf-lastsdf) );\n    }\n    else if ( t < bestt*2. )\n    {\n        // use the closest sample we had, to avoid sampling back-sides and things\n        t = bestt;\n\t\t// this can add a fringe, but maybe better than the alternative\n    }\n    \n    return t;\n}\n\n\nvec3 GetNormal( vec3 p )\n{\n    vec2 d = vec2(-1,1)*epsilon;\n    return normalize(\n        \tSDF(p+d.xxx)*d.xxx +\n        \tSDF(p+d.yyx)*d.yyx +\n        \tSDF(p+d.yxy)*d.yxy +\n        \tSDF(p+d.xyy)*d.xyy\n        );\n}\n\n\nvoid mainImage2( out vec4 fragColour, in vec2 fragCoord )\n{\n    seed = uint(iTime/2.);\n    \n    vec3 camPos = vec3(-5,1,-3);\n    float a = iTime*.1;\n    if ( iMouse.z > 0. )\n    {\n        camPos.y = 12.*iMouse.y/iResolution.y+.000001;\n        a += .5*tau*(iMouse.x/iResolution.x-.5);\n    }\n    camPos.xz = camPos.xz*cos(a)+vec2(1,-1)*sin(a)*camPos.zx;\n    vec3 camK = normalize(vec3(0,3,0) - camPos);\n    vec3 camI = normalize(cross(vec3(0,1,0),camK));\n    vec3 camJ = cross(camK,camI);\n#if 1\n    // architectural projection (non-orthographic)\n    camJ = vec3(0,1./sqrt(camJ.y),0);  // (0,1,0) works too, but causes more vertical stretching at steep angles\n#endif\n    \n    vec3 ray = vec3( (fragCoord-iResolution.xy*.5)/iResolution.y, .8 );\n    ray = ray.x*camI + ray.y*camJ + ray.z * camK;\n    ray = normalize( ray );\n    \n    float t = Trace( camPos, ray );\n    vec3 pos = camPos+t*ray;\n    \n    if ( t < 1e3 && SDF(pos) < 10. )\n    {\n//    \tfragColour.rgb = fract(pos);\n        \n        vec3 normal = GetNormal(pos);\n\n        vec3 toLight = normalize(vec3(-1,2,3));\n\n        if ( Trace( pos+toLight*.001-normal*SDF(pos), toLight ) > 1e2 )\n        {\n        \tfragColour.rgb = vec3(.9,.8,.7)*max( dot(normal,toLight), 0. );\n        }\n        \n        float aoStep = 1.;\n        float ao = smoothstep(-1.,1.,SDF(pos+normal*aoStep)/aoStep);\n        aoStep = .4;\n        ao = mix( ao, smoothstep(-1.,1.,SDF(pos+normal*aoStep)/aoStep), .5 );\n        aoStep = .15;\n        ao = mix( ao, smoothstep(-1.,1.,SDF(pos+normal*aoStep)/aoStep), .4 );\n        \n        fragColour.rgb += ao*mix( vec3(.3), vec3(.2,.3,.4), (.5+.5*normal.y) );\n    }\n    else\n    {\n        fragColour.rgb = vec3(.5,.7,1);\n    }\n    \n    fragColour.rgb = pow(fragColour.rgb,vec3(1./2.2));\n    fragColour.a = 1.;\n}\n\n\nvoid mainImage( out vec4 fragColour, in vec2 fragCoord )\n{\n#if ( AA_QUALITY == 0 )\n    mainImage2( fragColour, fragCoord );\n#else\n    int numSamples = max( 1, int((1920.*1080.*float(AA_QUALITY)*.2) / (iResolution.x*iResolution.y)) );\n\n    vec4 colSum = vec4(0);\n    for ( int i=0; i < numSamples; i++ )\n    {\n        uvec2 quasi2 = uvec2(0xC13FA9A9u,0x91E10DA5u);\n        uint seed = uint(i);\n        //seed += uint(iFrame*numSamples); // randomize per frame - causes shimmering\n        //seed += uint(fragCoord.x)*quasi2.x+uint(fragCoord.y)*quasi2.y; // randomize per pixel - this looks bad at low sample counts (and at high counts it's less important)\n        vec2 jitter = vec2( quasi2 * seed ) / exp2(32.);\n\n        if ( AA_ROUND )\n        {\n            // circle of confusion slightly bigger than a pixel - should look more photographic\n            jitter.x *= 6.283185;\n            jitter = AA_ROUND_RADIUS*(1.-jitter.y*jitter.y)*vec2(cos(jitter.x),sin(jitter.x));\n        }\n        else\n        {\n            jitter -= .5;\n        }\n        \n        vec4 col;\n        mainImage2( col, fragCoord + jitter );\n        colSum += col;\n    }\n   \n    fragColour = colSum/float(numSamples);\n#endif\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wdjSDG.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-4.0", "functions": [[905, 905, 925, 925, 951], [952, 952, 971, 971, 1016], [1017, 1017, 1036, 1036, 1089], [1090, 1090, 1109, 1109, 1170], [1190, 1190, 1225, 1225, 1784], [1787, 1787, 1840, 1840, 1919], [1921, 1921, 1942, 2013, 2499], [2668, 2668, 2717, 2717, 3665], [3668, 3668, 3694, 3694, 3880], [3883, 3883, 3942, 3942, 5662], [5665, 5665, 5723, 5723, 6863]], "test": "ok"}
{"id": "WdjSRd", "name": "WavyGravy", "author": "automaticjack", "description": "Just trying to get up the glsl curve. Welcome any suggestions on how to enrich this as a soothing, gentle evolution of color waves.", "tags": ["mindful"], "likes": 1, "viewed": 268, "published": "Public API", "date": "1554731877", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n        \n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 p = fragCoord/iResolution.yx.xy.yx;\n\n    \n    // Time varying pixel color\n    vec3 col = 2.5 + 3.4*cos(iTime*.05+p.xyx+vec3(3,0,6));\n    \n col *= p.x / p.y + sin(iTime*.05+vec3(0,4,0));\n\n    // Output to screen\n    fragColor = vec4(col,.5);\n}\n\n ", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WdjSRd.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 121, 373]], "test": "ok"}
{"id": "WdjSRy", "name": "Terrain attempt, second try", "author": "MacSlow", "description": "A bit better than my first attempt, which I never published. I wish I could use a perlin-noise texture to create the landscape, but one has to live with what is provided. Still need to figure out waves, sun and... clouds... volumetric clouds... *sigh*", "tags": ["3d", "raymarching", "terrain", "soundcloud"], "likes": 3, "viewed": 541, "published": "Public API", "date": "1554225413", "time_retrieved": "2021-10-01T00:00:00", "image_code": "////////////////////////////////////////////////////////////////////////////////\n//\n// \"Flight of the navigator\" ;) - A second attempt at creating a flight over a\n// procedurally generated landscape\n//\n// Copyright 2019 Mirco Müller\n//\n// Author(s):\n//   Mirco \"MacSlow\" Müller <macslow@gmail.com>\n//\n// This program is free software: you can redistribute it and/or modify it\n// under the terms of the GNU General Public License version 3, as published\n// by the Free Software Foundation.\n//\n// This program is distributed in the hope that it will be useful, but\n// WITHOUT ANY WARRANTY; without even the implied warranties of\n// MERCHANTABILITY, SATISFACTORY QUALITY, or FITNESS FOR A PARTICULAR\n// PURPOSE.  See the GNU General Public License for more details.\n//\n// You should have received a copy of the GNU General Public License along\n// with this program.  If not, see <http://www.gnu.org/licenses/>.\n//\n////////////////////////////////////////////////////////////////////////////////\n\nconst int MAX_ITER = 48;\nconst float EPSILON = .001;\nconst float STEP_BIAS = .65;\n\nmat2 r2d (float deg) {\n\tfloat rad = radians (deg);\n\tfloat c = cos (rad);\n\tfloat s = sin (rad);\n\treturn mat2 (c, s, -s, c);\n}\n\n// hash() & noise3d() are from an example by iq or shane... I can't remember \nfloat hash (float f)\n{\n\treturn fract (sin (f) * 45785.5453);\n}\n\nfloat noise3d (vec3 p)\n{\n    vec3 u = floor (p);\n    vec3 v = fract (p);\n    \n    v = v * v * (3. - 2. * v);\n\n    float n = u.x + u.y * 57. + u.z * 113.;\n    float a = hash (n);\n    float b = hash (n + 1.);\n    float c = hash (n + 57.);\n    float d = hash (n + 58.);\n\n    float e = hash (n + 113.);\n    float f = hash (n + 114.);\n    float g = hash (n + 170.);\n    float h = hash (n + 171.);\n\n    float result = mix (mix (mix (a, b, v.x),\n                             mix (c, d, v.x),\n                             v.y),\n                        mix (mix (e, f, v.x),\n                             mix (g, h, v.x),\n                             v.y),\n                        v.z);\n\n    return result;\n}\n\n// cheap-ass material-system with call-by-ref id & pout\nfloat map (vec3 p, inout int id, inout vec3 pout) {\n\tvec3 tp = p;\n\ttp.z -= 6.*iTime;\n\tfloat lf = 2.*noise3d (.25*tp.xzy);\n    tp.xz *= r2d (34.);\n\tfloat mf = 1.25*noise3d (.5*tp.xzy);\n    tp.xz *= r2d (57.);\n    float hf = .5*noise3d (2.*tp.xzy);\n\tfloat g = tp.y + 1.5 + lf + mf + hf;\n\tfloat w = tp.y + 3.5;\n    pout = tp;\n\tvec3 bp = p;\n\tbp.x += 2.*cos (iTime)*sin(2.*iTime);\n    bp.y += .75*cos (.75*iTime);\n    float r = .5 + .2*(cos(5.*iTime - 7.*bp.z));\n\tfloat b = length (bp) - r;\n\tfloat d = min (b, min (g, w));\n\tif (d == g) id = 1;\n\tif (d == w) id = 2;\n\tif (d == b) id = 3;\n\treturn d;\n}\n\nfloat march (vec3 ro, vec3 rd, float tmax, inout int id, inout int iters, inout vec3 pout) {\n\tfloat t = .0;\n\tfloat d = .0;\n\tfor (int i = 0; i < MAX_ITER; ++i) {\n\t\titers = i;\n\t\tvec3 p = ro + d*rd;\n\t\tt = map (p, id, pout);\n\t\tif (abs (t) < EPSILON*(1. + .125*t) || d > tmax) break;\n\t\td += t*STEP_BIAS;\n\t}\n\treturn d > tmax ? tmax : d;\n}\n\nvec3 norm (vec3 p) {\n\tint foo;\n    vec3 bar;\n\tfloat d = map (p, foo, bar);\n\tvec2 e = vec2 (.001, .0);\n\treturn normalize (vec3 (map (p + e.xyy, foo, bar),\n                            map (p + e.yxy, foo, bar),\n                            map (p + e.yyx, foo, bar)) - d);\n}\n\nfloat shadow (vec3 p, vec3 n, vec3 ldir, float ldist) {\n\tfloat tmax = 20.;\n\tint foo;\n\tint bar;\n    vec3 bla;\n\tfloat d2w = march (p + .01*n, ldir, tmax, foo, bar, bla);\n\treturn ldist < d2w ? 1. : .1;\n}\n\nfloat ao (vec3 p, vec3 n, float stepsize, int iters, float intensity) {\n\tfloat dist = .0;\n\tint foo;\n    vec3 bla;\n\tfloat ao = .0;\n\tfor (int i = 1; i <= iters; ++i) {\n\t\tdist = float (i)*stepsize;\n\t\tao += max (.0, (dist - map(p + dist*n, foo, bla))/dist);\n\t}\n\treturn 1. - ao*intensity;\n}\n\n// id 1: terrain\n// id 2: water\n// id 3: sphere/'spaceship'\nvec3 shade (vec3 ro, vec3 rd, float d, vec3 p, vec3 n, int id, vec3 pout) {\n\tvec3 amb = vec3 (.05);\n\tvec3 lp = vec3 (-1., 2., 2.);\n\tvec3 ldir = normalize (lp - p);\n\tfloat li = 3.;\n\tvec3 lc = vec3 (.9, .8, .7);\n\tvec3 mat = vec3 (.2);\n\tif (id == 1) mat = texture (iChannel0, pout.xz).rgb+vec3 (.05, .15, .1);\n\tif (id == 2) mat = vec3 (.0, .0, .9);\n\tif (id == 3) mat = vec3 (.2, .1, .0);\n\tfloat ldist = distance (lp, p);\n\tfloat s = shadow (p, n, ldir, ldist);\n\tfloat att = 44. / (ldist*ldist);\n\tfloat diff = max (.0, dot (n, ldir));\n\tvec3 h = normalize (-rd + ldir);\n\tfloat shiny = 100.;\n\tif (id == 1) shiny = 10.;\n\tif (id == 2) shiny = 100.;\n\tif (id == 3) shiny = 50.;\n\tfloat sp = pow (max (.0, dot (n, h)), shiny);\n\tfloat ao = 1.;//ao (p, n, .02, 8, .2); // ao has no visual impact currently\n\treturn ao*att*s*(amb + diff*lc*li*mat + sp*vec3 (1.));\n}\n\nvec3 background (vec2 uv) {\n\tfloat m = smoothstep (.0, 1.125, clamp (uv.y, .0, 1.));\n\treturn 5.*mix (vec3 (.9, .85, .5), vec3 (.2, .1, .9), m);\n}\n\nvec3 cam (vec2 uv, vec3 ro, vec3 aim, float zoom) {\n\tvec3 f = normalize (aim - ro);\n\tvec3 wu = vec3 (.0, 1., .0);\n\tvec3 r = normalize (cross(wu, f));\n\tvec3 u = normalize (cross(f, r));\n\tvec3 c = ro + f*zoom;\n\treturn normalize (c + r*uv.x + u*uv.y - ro);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n\tvec2 uvRaw = uv;\n\tuv = uv*2. - 1.;\n\tuv.x *= iResolution.x/iResolution.y;\n\tuv *= 1. + .35*length(uv);\n\n    float heightOffset = +.4*cos(iTime);\n\tvec3 ro = vec3 (1., 2. + heightOffset, 7.);\n\tvec3 aim = vec3 (.0, 1.5 + heightOffset, .0);\n\tfloat zoom = 2.;\n\tvec3 rd = cam (uv, ro, aim, zoom);\n\trd.xy *= r2d (15.*cos (iTime));\n\n\tfloat tmax = 90.;\n\tint id = 0;\n\tint iters = 0;\n    vec3 pout = vec3 (.0);\n\tfloat d = march (ro, rd, tmax, id, iters, pout);\n\tfloat d2 = d;\n\tvec3 col = vec3 (.0);\n\tfloat fog = 1. / (1. + d*d*.025);\n\n\tif (d == tmax) {\n\t\tuv *= r2d (-15.*cos (iTime));\n\t\tcol = 10.*background (uv);\n\t} else {\n\t\tvec3 p = ro + d*rd;\n\t\tvec3 n = norm (p);\n\t\tcol = shade (ro, rd, d, p, n, id, pout);\n\t\tif (id == 2 || id == 3) {\n\t\t\tro = p + .01*n;\n\t\t\trd = normalize (reflect (rd, n));\n\t\t\td = march (ro, rd, tmax, id, iters, pout);\n\t\t\tp = ro + d*rd;\n\t\t\tn = norm (p);\n\t\t\tcol += shade (ro, rd, d, p, n, id, pout);\n\t\t}\n\t}\n\n\tcol *= fog; // fog\n    col = mix (col, 1.5*vec3 (.95, .9, .8), pow (1. - 1. / d2, 130.)); // horizon-mist\n\tcol = col / (1. + col); // tone-mapping\n\tcol *= 1. - .5*length (uvRaw*2. - 1.); // vignette\n    col = pow (col, vec3 (1./2.2)); // gamma-correction\n\n\tfragColor = vec4(col, 1.);\n}", "image_inputs": [{"id": "XsX3Rn", "previewfilepath": "/media/ap/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg", "ctype": "texture"}, {"id": "MlXGDM", "previewfilepath": "https://soundcloud.com/brenticus/ambient-house", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0, "src": "https://soundcloud.com/brenticus/ambient-house", "ctype": "musicstream"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WdjSRy.jpg", "access": "shaders20k", "license": "gpl-3.0", "functions": [[1078, 1078, 1100, 1100, 1202], [1204, 1282, 1304, 1304, 1344], [1346, 1346, 1370, 1370, 2044], [2046, 2102, 2153, 2153, 2695], [2697, 2697, 2789, 2789, 3029], [3031, 3031, 3051, 3051, 3302], [3304, 3304, 3359, 3359, 3504], [3506, 3506, 3577, 3577, 3791], [3793, 3853, 3928, 3928, 4701], [4703, 4703, 4730, 4730, 4848], [4850, 4850, 4901, 4901, 5105], [5107, 5107, 5164, 5164, 6407]], "test": "error"}
{"id": "WdjSWK", "name": "Katie Bouman", "author": "marquizzo", "description": "I decided to make a quick and dirty recreation of the first true photograph of a black hole in honor of the tremendous work by Katie Bouman and team.", "tags": ["space", "galaxy", "hole", "black", "m87"], "likes": 7, "viewed": 316, "published": "Public", "date": "1554949578", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/* discontinuous pseudorandom uniformly distributed in [-0.5, +0.5]^3 */\nvec3 random3(vec3 c) {\n\tfloat j = 4096.0*sin(dot(c,vec3(17.0, 59.4, 15.0)));\n\tvec3 r;\n\tr.z = fract(512.0*j);\n\tj *= .125;\n\tr.x = fract(512.0*j);\n\tj *= .125;\n\tr.y = fract(512.0*j);\n\treturn r-0.5;\n}\n\n/* skew constants for 3d simplex functions */\nconst float F3 =  0.3333333;\nconst float G3 =  0.1666667;\n\n/* 3d simplex noise */\nfloat simplex3d(vec3 p) {\n\t /* 1. find current tetrahedron T and it's four vertices */\n\t /* s, s+i1, s+i2, s+1.0 - absolute skewed (integer) coordinates of T vertices */\n\t /* x, x1, x2, x3 - unskewed coordinates of p relative to each of T vertices*/\n\t \n\t /* calculate s and x */\n\t vec3 s = floor(p + dot(p, vec3(F3)));\n\t vec3 x = p - s + dot(s, vec3(G3));\n\t \n\t /* calculate i1 and i2 */\n\t vec3 e = step(vec3(0.0), x - x.yzx);\n\t vec3 i1 = e*(1.0 - e.zxy);\n\t vec3 i2 = 1.0 - e.zxy*(1.0 - e);\n\t \t\n\t /* x1, x2, x3 */\n\t vec3 x1 = x - i1 + G3;\n\t vec3 x2 = x - i2 + 2.0*G3;\n\t vec3 x3 = x - 1.0 + 3.0*G3;\n\t \n\t /* 2. find four surflets and store them in d */\n\t vec4 w, d;\n\t \n\t /* calculate surflet weights */\n\t w.x = dot(x, x);\n\t w.y = dot(x1, x1);\n\t w.z = dot(x2, x2);\n\t w.w = dot(x3, x3);\n\t \n\t /* w fades from 0.6 at the center of the surflet to 0.0 at the margin */\n\t w = max(0.6 - w, 0.0);\n\t \n\t /* calculate surflet components */\n\t d.x = dot(random3(s), x);\n\t d.y = dot(random3(s + i1), x1);\n\t d.z = dot(random3(s + i2), x2);\n\t d.w = dot(random3(s + 1.0), x3);\n\t \n\t /* multiply d by w^4 */\n\t w *= w;\n\t w *= w;\n\t d *= w;\n\t \n\t /* 3. return the sum of the four surflets */\n\t return dot(d, vec4(52.0));\n}\n\n///////////////////////////////////////////////\n\nvec3 mod289(vec3 x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 mod289(vec4 x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 permute(vec4 x) {\n     return mod289(((x*34.0)+1.0)*x);\n}\n\nvec4 taylorInvSqrt(vec4 r) {\n  return 1.79284291400159 - 0.85373472095314 * r;\n}\n\nfloat snoise(vec3 v) {\n  const vec2  C = vec2(1.0/6.0, 1.0/3.0) ;\n  const vec4  D = vec4(0.0, 0.5, 1.0, 2.0);\n\n// First corner\n  vec3 i  = floor(v + dot(v, C.yyy) );\n  vec3 x0 =   v - i + dot(i, C.xxx) ;\n\n// Other corners\n  vec3 g = step(x0.yzx, x0.xyz);\n  vec3 l = 1.0 - g;\n  vec3 i1 = min( g.xyz, l.zxy );\n  vec3 i2 = max( g.xyz, l.zxy );\n\n  //   x0 = x0 - 0.0 + 0.0 * C.xxx;\n  //   x1 = x0 - i1  + 1.0 * C.xxx;\n  //   x2 = x0 - i2  + 2.0 * C.xxx;\n  //   x3 = x0 - 1.0 + 3.0 * C.xxx;\n  vec3 x1 = x0 - i1 + C.xxx;\n  vec3 x2 = x0 - i2 + C.yyy; // 2.0*C.x = 1/3 = C.y\n  vec3 x3 = x0 - D.yyy;      // -1.0+3.0*C.x = -0.5 = -D.y\n\n// Permutations\n  i = mod289(i);\n  vec4 p = permute( permute( permute(\n             i.z + vec4(0.0, i1.z, i2.z, 1.0 ))\n           + i.y + vec4(0.0, i1.y, i2.y, 1.0 ))\n           + i.x + vec4(0.0, i1.x, i2.x, 1.0 ));\n\n// Gradients: 7x7 points over a square, mapped onto an octahedron.\n// The ring size 17*17 = 289 is close to a multiple of 49 (49*6 = 294)\n  float n_ = 0.142857142857; // 1.0/7.0\n  vec3  ns = n_ * D.wyz - D.xzx;\n\n  vec4 j = p - 49.0 * floor(p * ns.z * ns.z);  //  mod(p,7*7)\n\n  vec4 x_ = floor(j * ns.z);\n  vec4 y_ = floor(j - 7.0 * x_ );    // mod(j,N)\n\n  vec4 x = x_ *ns.x + ns.yyyy;\n  vec4 y = y_ *ns.x + ns.yyyy;\n  vec4 h = 1.0 - abs(x) - abs(y);\n\n  vec4 b0 = vec4( x.xy, y.xy );\n  vec4 b1 = vec4( x.zw, y.zw );\n\n  //vec4 s0 = vec4(lessThan(b0,0.0))*2.0 - 1.0;\n  //vec4 s1 = vec4(lessThan(b1,0.0))*2.0 - 1.0;\n  vec4 s0 = floor(b0)*2.0 + 1.0;\n  vec4 s1 = floor(b1)*2.0 + 1.0;\n  vec4 sh = -step(h, vec4(0.0));\n\n  vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy ;\n  vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww ;\n\n  vec3 p0 = vec3(a0.xy,h.x);\n  vec3 p1 = vec3(a0.zw,h.y);\n  vec3 p2 = vec3(a1.xy,h.z);\n  vec3 p3 = vec3(a1.zw,h.w);\n\n//Normalise gradients\n  vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));\n  p0 *= norm.x;\n  p1 *= norm.y;\n  p2 *= norm.z;\n  p3 *= norm.w;\n\n// Mix final noise value\n  vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n  m = m * m;\n  return 42.0 * dot( m*m, vec4( dot(p0,x0), dot(p1,x1),\n                                dot(p2,x2), dot(p3,x3) ) );\n}\n\n\nvec3 snoiseVec3( vec3 x ){\n\n  float s0 = snoise(vec3( x ));\n  float s1 = snoise(vec3( x.y - 19.1 , x.z + 33.4 , x.x + 47.2 ));\n  float s2 = snoise(vec3( x.z + 74.2 , x.x - 124.5 , x.y + 99.4 ));\n  return vec3( s0, s1 , s2 );\n\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 vpRatio = vec2(iResolution.x / iResolution.y, 1.0);\n    \n    // Distortion\n    vec3 distortion = snoiseVec3(vec3(uv.xy * 2.0, iTime * 0.5));\n    \n    // Create accretion disk\n    vec2 singularity = vec2(0.5) * vpRatio;\n    float dist = distance(uv * vpRatio, singularity + distortion.xy * 0.03);\n    float eventHorizon = smoothstep(0.0, 0.3, dist);\n    float outerAccretion = smoothstep(0.6, 0.3, dist);\n    \n    // Luminosity\n    float doppler = smoothstep(0.2, 0.8, uv.y) * 0.3;\n    float lum = eventHorizon * outerAccretion;\n    lum -= doppler;\n    lum *= distortion.z * 0.2 + 0.8;\n    \n    vec3 color = vec3(\n        smoothstep(0.0, 1.0, lum),\n        smoothstep(0.5, 1.0, lum),\n    \tsmoothstep(0.8, 1.0, lum)\n    );\n\n    // Output to screen\n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WdjSWK.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 73, 95, 95, 268], [375, 398, 423, 676, 1593], [1644, 1644, 1665, 1665, 1714], [1716, 1716, 1737, 1737, 1786], [1788, 1788, 1810, 1810, 1850], [1852, 1852, 1880, 1880, 1932], [1934, 1934, 1956, 1956, 4095], [4098, 4098, 4124, 4124, 4325], [4327, 4327, 4384, 4384, 5215]], "test": "ok"}
{"id": "wdjSWt", "name": "Basics - Coordinate Rotation", "author": "trevorleake", "description": "Studying the basics. Now playing with rotation.", "tags": ["rotation", "basics"], "likes": 2, "viewed": 120, "published": "Public", "date": "1555382771", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n\nmat2 rotate2d(float angle)\n{\n    return mat2(cos(angle), -sin(angle),\n                sin(angle), cos(angle));\n}\n\nfloat box(vec2 uv, vec2 topLeft, vec2 bottomRight)\n{\n    return uv.x > topLeft.x && uv.x < bottomRight.x && uv.y < topLeft.y && uv.y > bottomRight.y ? 1. : 0.;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{    \t\n    // Center our coordinate system    \n    vec2 uv = (fragCoord - .5*iResolution.xy) / min(iResolution.x, iResolution.y);\n\n    // Apply rotation to coordinates\n\tuv = rotate2d(sin(iTime) * 3.1415) * uv;\n\n    // Display coordinate system as colors in the background\n    vec3 col = vec3(uv.x,uv.y,0);    \n\n    // Tack on a shape for kicks\n    col += box(uv, vec2(-.1,.1), vec2(.1,-.1));\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wdjSWt.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[2, 2, 30, 30, 114], [116, 116, 168, 168, 277], [280, 280, 337, 382, 789]], "test": "ok"}
{"id": "wdjSWy", "name": "Finals_Shader03_Co", "author": "johannco98", "description": "asd", "tags": ["asd"], "likes": 1, "viewed": 38, "published": "Public", "date": "1554889858", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float Spikes(float angle, float armSpeed, float armNum, float armWidth, float size)\n{\n    float spikes =  -(abs(cos(angle * 0.5 + (iTime * armSpeed)) \n                        * sin(angle * armNum )))\n        \t\t\t\t\t\t\t\t\t\t\t* armWidth +      size;\n    \n    return spikes;\n    \n}\n\nfloat rect(vec2 uv, vec2 pos, float width, float height)\n{\n    float square = (step(pos.x - width, uv.x) - step(pos.x + width, uv.x)) *\n                   (step(pos.y - height, uv.y) - step(pos.y + height, uv.y));\n    \n    \n    return square;\n}\n\nfloat Circle(vec2 uv, vec2 pos, float rad, float blur) \n{\n\tfloat d = length(uv-pos);\n\tfloat t = smoothstep(rad, rad-blur, d);\n    \n    \n\treturn t;\n}\n\nfloat rand(vec2 uv)\n{\n    //return fract(sin(dot(uv, vec2(12.9898,78.233)))*10000.*iTime);\n\t//return fract(sin(dot(uv, iMouse.xy))*10000.);\n\t//return (fract(sin(dot(uv, vec2(12., 70.)))*100000.));\n    return (fract(sin(dot(uv, vec2(12., 70.)))*43758.5453123));\n}\n\n// Value noise\nfloat noise(in vec2 st) {\n    vec2 i = floor(st);\n    vec2 f = fract(st);\n\n    // Four corners in 2D of a tile\n    float a = rand(i);\n    float b = rand(i + vec2(1.0, 0.0));\n    float c = rand(i + vec2(0.0, 1.0));\n    float d = rand(i + vec2(1.0, 1.0));\n\n    // Smooth Interpolation\n\n    // Cubic Hermine Curve.  Same as SmoothStep()\n    vec2 u = f*f*(3.0-2.0*f);\n    // u = smoothstep(0.,1.,f);\n\n    // Mix 4 coorners porcentages\n    return mix(a, b, u.x) + \n            (c - a)* u.y * (1.0 - u.x) + \n            (d - b) * u.x * u.y;\n}\n\n// Gradient noise\nvec2 hash( vec2 x )  // replace this by something better\n{\n    const vec2 k = vec2( 0.3183099, 0.3678794 );\n    x = x*k + k.yx;\n    return -1.0 + 2.0*fract( 16.0 * k*fract( x.x*x.y*(x.x+x.y)) );\n}\n\nfloat gnoise( in vec2 p )\n{\n    vec2 i = floor( p );\n    vec2 f = fract( p );\n\t\n\tvec2 u = f*f*(3.0-2.0*f);\n\n    return mix( mix( dot( hash( i + vec2(0.0,0.0) ), f - vec2(0.0,0.0) ), \n                     dot( hash( i + vec2(1.0,0.0) ), f - vec2(1.0,0.0) ), u.x),\n                mix( dot( hash( i + vec2(0.0,1.0) ), f - vec2(0.0,1.0) ), \n                     dot( hash( i + vec2(1.0,1.0) ), f - vec2(1.0,1.0) ), u.x), u.y);\n}\n\n// Simplex noise\nvec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec2 mod289(vec2 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec3 permute(vec3 x) { return mod289(((x*34.0)+1.0)*x); }\n\nfloat snoise(vec2 v) {\n    const vec4 C = vec4(0.211324865405187,  // (3.0-sqrt(3.0))/6.0\n                        0.366025403784439,  // 0.5*(sqrt(3.0)-1.0)\n                        -0.577350269189626,  // -1.0 + 2.0 * C.x\n                        0.024390243902439); // 1.0 / 41.0\n    vec2 i  = floor(v + dot(v, C.yy) );\n    vec2 x0 = v -   i + dot(i, C.xx);\n    vec2 i1;\n    i1 = (x0.x > x0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);\n    vec4 x12 = x0.xyxy + C.xxzz;\n    x12.xy -= i1;\n    i = mod289(i); // Avoid truncation effects in permutation\n    vec3 p = permute( permute( i.y + vec3(0.0, i1.y, 1.0 ))\n        + i.x + vec3(0.0, i1.x, 1.0 ));\n\n    vec3 m = max(0.5 - vec3(dot(x0,x0), dot(x12.xy,x12.xy), dot(x12.zw,x12.zw)), 0.0);\n    m = m*m ;\n    m = m*m ;\n    vec3 x = 2.0 * fract(p * C.www) - 1.0;\n    vec3 h = abs(x) - 0.5;\n    vec3 ox = floor(x + 0.5);\n    vec3 a0 = x - ox;\n    m *= 1.79284291400159 - 0.85373472095314 * ( a0*a0 + h*h );\n    vec3 g;\n    g.x  = a0.x  * x0.x  + h.x  * x0.y;\n    g.yz = a0.yz * x12.xz + h.yz * x12.yw;\n    return 130.0 * dot(m, g);\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //Colors in vec3\n    vec3 red = vec3(0.8 ,0.0 ,0.0);\n    vec3 white = vec3(1.0, 1.0, 1.0);\n    vec3 yellow = vec3(0.9, 0.9, 0.3);\n    vec3 blue = vec3(0.0, 0.2, 1.0);\n    vec3 black = vec3(0.0, 0.0, 0.0);\n    vec3 green = vec3(0.0, 1.0, 0.0);\n    \n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    float ratio = iResolution.x/iResolution.y;\n    uv.x *= ratio;\n    \n    //music shiz\n    float val = noise(uv + (iTime) * (iTime * 0.001) - (uv.x*1000.0)/10000.);\n    \n    val = val + gnoise(uv * snoise(uv * rand(uv)) * noise(uv * rand(uv)) + iTime + rand(uv*iTime));\n    val = val * noise(uv + (iTime) * (iTime * 0.005) - abs(uv.x*clamp(sin(iTime), 0.0, 1.0)) * 100.0);\n    val = val + snoise(uv + vec2(0.0, -iTime*1.5));\n    \n    \n    //waves\n    val = step(-0.1*val, uv.y) - step(1.5*val, uv.y);\n    \n    \n    vec3 lampLight = abs(vec3(\n        \t\t\t\t  clamp(abs(sin(iTime)),0.3 , 0.8 ),\n                          clamp(abs(cos(iTime)),0.4 , 0.9 ), \n                          clamp(abs(sin(iTime)),0.4 , 1.0 ))\n                        \t );\n    \n    \n    vec3 Val = mix(black, lampLight, val);\n    \n    // Output to screen\n    fragColor = vec4(Val, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wdjSWy.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 85, 85, 273], [275, 275, 333, 333, 519], [521, 521, 578, 578, 669], [671, 671, 692, 867, 933], [935, 950, 975, 975, 1486], [1488, 1506, 1564, 1564, 1702], [1704, 1704, 1731, 1731, 2129], [2131, 2148, 2169, 2169, 2216], [2217, 2217, 2238, 2238, 2285], [2286, 2286, 2308, 2308, 2343], [2345, 2345, 2367, 2367, 3415], [3416, 3416, 3473, 3494, 4675]], "test": "ok"}
{"id": "WdjSzd", "name": "Finals3 - Dancing Stars", "author": "EmperorLem", "description": "many stars", "tags": ["stars"], "likes": 1, "viewed": 51, "published": "Public", "date": "1554887599", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec3 red = vec3(0.8 ,0.0 ,0.0);\nvec3 white = vec3(1.0, 1.0, 1.0);\nvec3 yellow = vec3(0.9, 0.9, 0.3);\nvec3 blue = vec3(0.0, 0.2, 1.0);\nvec3 black = vec3(0.0, 0.0, 0.0);\nvec3 green = vec3(0.0, 1.0, 0.0);\n\nfloat createCircle(vec2 uv)\n{\n    uv -= 0.5;\n    uv.x *= iResolution.x/iResolution.y;\n    \n    float dist = length(uv);\n    float ratio = 0.3;\n    float rate = clamp(sin(20.0 * ratio * iTime)*ratio , 0.25, 0.3);\n        \n    float angle = (atan(uv.y, uv.x) + iTime * 3.0);\n        \n    float value = smoothstep( rate,ratio = 0.2 ,dist);\n    \n    float radius = 0.0;\n    radius = smoothstep(-1.0, 20.0, cos(angle * 5.0)) * 10.0 + 0.15;\n    \n    value = 1.0 - step(radius, dist) + clamp(sin(20.0 * radius * iTime) , 0.25, 0.30);\n    \n    \n    return value * radius * 5.0;\n}\n\n\nmat2 rotate2d(float angle)\n{\n    return mat2 (cos(angle), -sin(angle), sin(angle), cos(angle));\n}\n\nmat2 scale2d(vec2 value)\n{\n    return mat2 (value.x, 0, 0,  value.y);\n    \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{    \n    vec2 uv = fragCoord/iResolution.xy;\n    float ratio = iResolution.x / iResolution.y;\n    uv *= 10.0;\n    float offset = mod(uv.y,2.)>1. ? -1. : 1.;\n    //float offset = step(1.,mod(uv.y,2.0));\n    //float offset2 = step(mod(uv.y,2.0), 1.);\n    \n\tuv.x += offset * sin(iTime) * 2.0;\n\t\n    //uv.x -= offset2 *iTime;\n    uv.x *= ratio;\n    \n    vec2 pos = vec2(0.5*ratio, 0.5);\n    \n    \n    uv = fract(uv);\n    uv -= pos ;\n   \t//uv *= rotate2d(tan(iTime * 3.0)  );\n    uv += pos;\n    //uv *= scale2d(vec2(1.0, 1.0)); \n   \t\n    uv *= scale2d(vec2(1.0, 1.0)); \n    vec3 image = vec3(createCircle(uv));\n    vec3 mixed = mix(white, red, vec3(createCircle(uv)));\n\n    fragColor = vec4(mixed,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WdjSzd.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[203, 203, 232, 232, 774], [777, 777, 805, 805, 874], [876, 876, 902, 902, 952], [954, 954, 1011, 1011, 1710]], "test": "ok"}
{"id": "wdjXDG", "name": "finals 6", "author": "jojo169", "description": "6f", "tags": ["f6v1"], "likes": 0, "viewed": 37, "published": "Public", "date": "1554888950", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float rand(vec2 uv)\n{\n    return fract(sin(dot(uv, vec2(12.9898,78.233)))*1000.*iTime);\n\t//return fract(sin(dot(uv, iMouse.xy))*10000.);\n\t//return (fract(sin(dot(uv, vec2(12., 70.)))*100000.));\n    //return (fract(sin(dot(uv, vec2(12., 70.)))*43758.5453123));\n}\n\nvec2 hash( vec2 x )  // replace this by something better\n{\n    const vec2 k = vec2( 0.3183099, 0.3678794 );\n    x = x*k + k.yx;\n    return -1.0 + 2.0*fract( 16.0 * k*fract( x.x*x.y*(x.x+x.y)) );\n}\n\nfloat gnoise( in vec2 p )\n{\n    vec2 i = floor( p );\n    vec2 f = fract( p );\n\t\n\tvec2 u = f*f*(3.0-2.0*f);\n\n    return mix( mix( dot( hash( i + vec2(0.0,0.0) ), f - vec2(0.0,0.0) ), \n                     dot( hash( i + vec2(1.0,0.0) ), f - vec2(1.0,0.0) ), u.x),\n                mix( dot( hash( i + vec2(0.0,1.0) ), f - vec2(0.0,1.0) ), \n                     dot( hash( i + vec2(1.0,1.0) ), f - vec2(1.0,1.0) ), u.x), u.y);\n}\n\n// Simplex noise\nvec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec2 mod289(vec2 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec3 permute(vec3 x) { return mod289(((x*34.0)+1.0)*x); }\n\nfloat snoise(vec2 v) {\n    const vec4 C = vec4(0.211324865405187,  // (3.0-sqrt(3.0))/6.0\n                        0.366025403784439,  // 0.5*(sqrt(3.0)-1.0)\n                        -0.577350269189626,  // -1.0 + 2.0 * C.x\n                        0.024390243902439); // 1.0 / 41.0\n    vec2 i  = floor(v + dot(v, C.yy) );\n    vec2 x0 = v -   i + dot(i, C.xx);\n    vec2 i1;\n    i1 = (x0.x > x0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);\n    vec4 x12 = x0.xyxy + C.xxzz;\n    x12.xy -= i1;\n    i = mod289(i); // Avoid truncation effects in permutation\n    vec3 p = permute( permute( i.y + vec3(0.0, i1.y, 1.0 ))\n        + i.x + vec3(0.0, i1.x, 1.0 ));\n\n    vec3 m = max(0.5 - vec3(dot(x0,x0), dot(x12.xy,x12.xy), dot(x12.zw,x12.zw)), 0.0);\n    m = m*m ;\n    m = m*m ;\n    vec3 x = 2.0 * fract(p * C.www) - 1.0;\n    vec3 h = abs(x) - 0.5;\n    vec3 ox = floor(x + 0.5);\n    vec3 a0 = x - ox;\n    m *= 1.79284291400159 - 0.85373472095314 * ( a0*a0 + h*h );\n    vec3 g;\n    g.x  = a0.x  * x0.x  + h.x  * x0.y;\n    g.yz = a0.yz * x12.xz + h.yz * x12.yw;\n    return 130.0 * dot(m, g);\n}\n\nfloat noise(in vec2 st) {\n    vec2 i = floor(st);\n    vec2 f = fract(st);\n\n    // Four corners in 2D of a tile\n    float a = rand(i);\n    float b = rand(i + vec2(1.0, 0.0));\n    float c = rand(i + vec2(0.0, 1.0));\n    float d = rand(i + vec2(1.0, 1.0));\n\n    // Smooth Interpolation\n\n    // Cubic Hermine Curve.  Same as SmoothStep()\n    vec2 u = f*f*(3.0-2.0*f);\n    // u = smoothstep(0.,1.,f);\n\n    // Mix 4 coorners porcentages\n    return mix(a, b, u.x) + \n            (c - a)* u.y * (1.0 - u.x) + \n            (d - b) * u.x * u.y;\n}\n\n\nfloat rect(vec2 uv, vec2 pos, float width, float height)\n{\n    float square = (step(pos.x - width, uv.x) - step(pos.x + width, uv.x)) *\n                   (step(pos.y - height, uv.y) - step(pos.y + height, uv.y));\n    \n    \n    return square;\n}\n\nmat2 rotate2d(float angle)\n{\n    return mat2 (cos(angle), -sin(angle), sin(angle), cos(angle));\n}\n\nmat2 scale2d(vec2 value)\n{\n    return mat2 (value.x, 0, 0,  value.y);\n    \n}\n\nfloat virus(vec2 uv,float posX,float posY,float midSize,float outerSize)\n{\n    float ratio = iResolution.x/iResolution.y;\n    uv.x *= ratio;\n    \n    vec2 shapePos= vec2(posX*ratio,posY);\n    float dist = distance(shapePos,uv)*2.;\n    \n    uv -=shapePos;\n    float angle= atan(uv.y,uv.x);\n    float radius = cos(2.*angle);\n    radius = abs(tan(angle+iTime)*sin(angle*3.+iTime))*outerSize+midSize;\n    \n    float value = 1.-step(radius,dist);\n\n    \n    return value;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n     //Colors in vec3\n    vec3 red = vec3(0.8 ,0.0 ,0.0);\n    vec3 white = vec3(1.0, 1.0, 1.0);\n    vec3 yellow = vec3(0.9, 0.9, 0.3);\n    vec3 blue = vec3(0.0, 0.2, 1.0);\n    vec3 black = vec3(0.0, 0.0, 0.0);\n    vec3 green = vec3(0.0, 1.0, 0.0);\n    \n    vec2 uv = fragCoord/iResolution.xy;\n    float ratio = iResolution.y / iResolution.y;\n    uv *= 1.;\n    float offset = mod(uv.x,2.)>1. ? -1. : 1.;\n    //float offset = step(1.,mod(uv.y,2.0));\n    //float offset2 = step(mod(uv.y,2.0), 1.);\n    \n\tuv.x += offset * iTime;\n\t\n    //uv.x -= offset2 *iTime;\n    uv.x *= ratio;\n    \n    vec2 pos = vec2(0.9*ratio, 0.5);\n  \n    \n    uv = fract(uv);\n    uv -= pos ;\n\n    uv += pos;\n    //uv *= scale2d(vec2(1.0, 1.0)); \n    \n    \n    vec3 color = vec3(rect(uv, pos*snoise(uv), 0.2+gnoise(uv), 0.1))*red*snoise(uv);\n\n    fragColor = vec4(color,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wdjXDG.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 21, 21, 261], [263, 263, 321, 321, 459], [461, 461, 488, 488, 886], [888, 905, 926, 926, 973], [974, 974, 995, 995, 1042], [1043, 1043, 1065, 1065, 1100], [1102, 1102, 1124, 1124, 2172], [2174, 2174, 2199, 2199, 2710], [2713, 2713, 2771, 2771, 2957], [2959, 2959, 2987, 2987, 3056], [3058, 3058, 3084, 3084, 3134], [3136, 3136, 3210, 3210, 3603], [3605, 3605, 3662, 3684, 4509]], "test": "ok"}
{"id": "WdjXDt", "name": "Visiting the alien hive ;)", "author": "MacSlow", "description": "First go at a tunnel with SDFs. fbm() makes it costly, but the surface looks nicer with the bumps. Turned out pretty spooky, thus the title of the shader :) Still have to learn about better variations of the paths and wall distortions... too repetitive.", "tags": ["3d", "tunnel", "sdf", "spooky"], "likes": 1, "viewed": 345, "published": "Public API", "date": "1555353739", "time_retrieved": "2021-10-01T00:00:00", "image_code": "////////////////////////////////////////////////////////////////////////////////\n//\n// Visiting the alien hive - Excersice in building and flying through a tunnel.\n//\n// Copyright 2019 Mirco Müller\n//\n// Author(s):\n//   Mirco \"MacSlow\" Müller <macslow@gmail.com>\n//\n// This program is free software: you can redistribute it and/or modify it\n// under the terms of the GNU General Public License version 3, as published\n// by the Free Software Foundation.\n//\n// This program is distributed in the hope that it will be useful, but\n// WITHOUT ANY WARRANTY; without even the implied warranties of\n// MERCHANTABILITY, SATISFACTORY QUALITY, or FITNESS FOR A PARTICULAR\n// PURPOSE.  See the GNU General Public License for more details.\n//\n// You should have received a copy of the GNU General Public License along\n// with this program.  If not, see <http://www.gnu.org/licenses/>.\n//\n////////////////////////////////////////////////////////////////////////////////\n\nmat2 r2d (float deg) {\n    float r = radians (deg);\n    float c = cos (r);\n    float s = sin (r);\n    return mat2 (c, s, -s, c);\n}\n\nfloat smin (float d1, float d2, float k) {\n    float h = clamp (.5 + .5*(d2 - d1)/k, .0, 1.);\n    return mix (d2, d1, h) - h*k*(1. - h);\n}\n\n// pathVariation1() & pathVariation2() are two random functions meant to distort the\n// radius of an endless cylinder in order to create the rough shape of a tunnel/cave\nfloat pathVariation1 (vec3 p) {\n    float v = sin (p.x + p.y + p.z);\n    return sin (v) + cos (v*v);\n}\n\nfloat pathVariation2 (vec3 p) {\n    float v = sin (p.x * p.y - p.z);\n    return sin (v*v) + cos (v+v);\n}\n\n// hash(), noise(), fbm() are from an example by iq and/or Shane\nfloat hash( float n ) {\n    return fract(sin(n)*43758.5453);\n}\n\nfloat noise( in vec3 x ) {\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n\n    f = f*f*(3. - 2.*f);\n\n    float n = p.x + p.y*57. + 113.*p.z;\n\n    float res = mix(mix(mix( hash(n+  0.), hash(n+  1.),f.x),\n                        mix( hash(n+ 57.), hash(n+ 58.),f.x),f.y),\n                    mix(mix( hash(n+113.), hash(n+114.),f.x),\n                        mix( hash(n+170.), hash(n+171.),f.x),f.y),f.z);\n    return res;\n}\n\nfloat fbm( vec3 p ) {\n    float f;\n    mat2 m = r2d (1.1);\n\n    f  = .5*noise( p ); p.xz *= m*2.02;\n    f += .25*noise( p ); p.xy *= m*2.23;\n    f += .125*noise( p ); p.yz *= m*2.71;\n    f += .0625*noise( p );\n\n    return f;\n}\n\nfloat map (vec3 p) {\n    p.xy *= r2d (-6.*cos(iTime));\n    p.z += 4.*iTime;\n\n    float cyl1 = length (p.xy + .3*pathVariation1 (2.*p) + vec2 (-.5, .0)) - (.9 + .05*fbm(7.*p));\n    float cyl2 = length (p.xy + .2*pathVariation2 (3.*p) +vec2 (.5, .0)) - (1.1 + .075*fbm(8.*p));\n\n    float cyl = smin (cyl1, cyl2, .75);\n\n    float d = cyl;\n    return d;\n}\n\nfloat march (vec3 ro, vec3 rd) {\n    float t = .0;\n    float d = .0;\n    for (int i = 0; i < 48; ++i) {\n        t = map (ro+d*rd);\n        if (abs (t) < .0001*(1. + .126*t)) break;\n        d += t*.75;\n    }\n    return  d;\n}\n\nvec3 norm (vec3 p) {\n    float d = map (p);\n    vec2 e = vec2 (.001, .0);\n    return normalize (vec3 (map (p + e.xyy), map (p + e.yxy), map (p + e.yyx))  - d);\n}\n\n// hard shadows\nfloat sha (vec3 p, vec3 n, vec3 ldir, float ldist) {\n    float d2w = march (p  + .01*n, ldir);\n    return ldist < d2w ? 1. : .3;\n}\n\nvec3 shade (vec3 ro, vec3 rd, float d, vec3 p, vec3 n, vec3 lp, vec3 lc) {\n    vec3 mat = vec3 (.3);\n    vec3 am = vec3 (.05);\n    vec3 ldir = normalize (lp - p);\n    vec3 h = normalize (-rd + ldir);\n    float sp = pow (max (.0, dot (n, h)), 80.);\n    float ldist = distance (lp, p);\n    float s = sha (p, n, ldir, ldist);\n    float att = 3. / (ldist*ldist);\n    float li = 2.;\n    float diff = max (.0, dot (n, ldir));\n    return att*s*(am + diff*mat*li*lc + sp*vec3 (1.));\n}\n\nvec3 cam (vec2 uv, vec3 ro, vec3 aim, float z) {\n    vec3 f = normalize (aim - ro);\n    vec3 wu = vec3 (.0, 1., .0);\n    wu.xy *= r2d (65.*iTime);\n    vec3 r = normalize (cross (wu, f));\n    vec3 u = normalize (cross (f, r));\n    vec3 c = ro + f*z;\n    return normalize (c + r*uv.x + u*uv.y - ro);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 uvRaw = uv;\n    uv = uv*2. - 1.;\n    uv.x *= iResolution.x/iResolution.y;\n    uv *= 1. + .5*length (uv);\n\n    vec3 ro = vec3 (-.3*cos (3.*iTime), .1*sin(3.*iTime), 2.);\n    vec3 aim = vec3 (.0);\n    float z = 1.5;\n    vec3 rd = cam (uv, ro, aim, z);\n    float d = march (ro, rd);\n    float fog = 1. / (1. + d*d*.1);\n    vec3 p = ro+d*rd;\n    vec3 n = -norm (p);\n    vec3 lp1 = vec3 (.0, .0, 2.);\n    vec3 lp2 = vec3 (.0, .0, 5.);\n    vec3 lp3 = vec3 (.0, .0, 7.);\n    vec3 lc1 = vec3 (.9, .8, .7);\n    vec3 lc2 = vec3 (.2, .3, .9);\n    vec3 lc3 = vec3 (.9, .3, .2);\n    vec3 col = shade (ro, rd, d, p, n, lp1, lc1);\n    col += shade (ro, rd, d, p, n, lp2, lc2);\n    col += shade (ro, rd, d, p, n, lp3, lc3);\n\n    ro = p +.01*n;\n    rd = normalize (reflect (rd, n));\n    d = march (ro, rd);\n    p = ro+d*rd;\n    n = -norm (p);\n\n    vec3 rcol = shade (ro, rd, d, p, n, lp1, lc1);\n    rcol += shade (ro, rd, d, p, n, lp2, lc2);\n    rcol += shade (ro, rd, d, p, n, lp3, lc3);\n    col += .5*rcol;\n\n    col *= fog;\n    col *= 1. - .25*length (uv);\n    col = col / (.76 + col*1.25);\n    col *= mix (1., .5, cos (500.*uvRaw.y));\n    col = sqrt (col);\n\n    fragColor = vec4 (col, 1.);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WdjXDt.jpg", "access": "shaders20k", "license": "gpl-3.0", "functions": [[960, 960, 982, 982, 1090], [1092, 1092, 1134, 1134, 1230], [1232, 1402, 1433, 1433, 1504], [1506, 1506, 1537, 1537, 1610], [1612, 1677, 1700, 1700, 1739], [1741, 1741, 1767, 1767, 2162], [2164, 2164, 2185, 2185, 2390], [2392, 2392, 2412, 2412, 2743], [2745, 2745, 2777, 2777, 2968], [2970, 2970, 2990, 2990, 3131], [3133, 3149, 3201, 3201, 3279], [3281, 3281, 3355, 3355, 3757], [3759, 3759, 3807, 3807, 4058], [4060, 4060, 4117, 4117, 5344]], "test": "timeout"}
{"id": "wdjXDw", "name": "Recursive Clover", "author": "dracusa", "description": "A strange noisy flower.", "tags": ["raymarching", "sdf", "flower", "zoomer", "loopless", "logspherical"], "likes": 17, "viewed": 480, "published": "Public API", "date": "1554082151", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/*\n\nAnother flower, possibly inspired by John Edmark's sculptures.\n\nThe code is probably inefficient and lacks documentation, but if you want to\ncheck out code and understand the log-spherical mapping that's used here, look\nat \"Recursive Lotus\" instead: https://www.shadertoy.com/view/3d2Szm\n\nChange the AA to 1 if laggy, or 3 if your graphics card can handle it!\n\n*/\n\n#define AA 2\n#define ITER 60\n#define M_PI 3.1415926535897932384626433832795\n\nfloat fov;\nfloat cam_ty;\nfloat cam_incl;\nfloat ctrl;\nfloat cam_azi;\nvec3 cam_pos;\nfloat timein = 0.;\nvec2 AAradius;\nfloat azrep = M_PI/6.;\nfloat rrep = 2.;\nfloat cam_dist = 2.25;\n\n// Axis rotation taken from tdhooper. R(p.xz, a) rotates \"x towards z\".\nvoid pR(inout vec2 p, float a) {\n\tp = cos(a)*p + sin(a)*vec2(p.y, -p.x);\n}\n\n// Modified from http://www.iquilezles.org/www/articles/distfunctions/distfunctions.htm\nfloat sdCylinder( vec3 p, vec2 h )\n{\n  vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\nfloat sdBox( vec3 p, vec3 b )\n{\n    vec3 d = abs(p) - b;\n    return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\nfloat opUsmin( float a, float b, float k )\n{\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\n// From https://www.osar.fr/notes/logspherical/\nvec3 logspherical(in vec3 p)\n{\n\treturn vec3(\n\t\tlog(length(p)),\n\t\tacos(p.z / length(p)),\n\t\tatan(p.y, p.x)\n\t);\n}\n\nfloat kk(float x) {\n\treturn x>1.?x:exp(x-1.)+0.;\n}\n\nfloat sphFlower(in vec3 p, in float eradius)\n{\n\tp.y -= p.x*M_PI/5.; // azimuth transform\n\tp.y = fract(p.y/azrep+0.5*azrep)*azrep-0.5*azrep; // azimuth rep\n\tfloat unsquish = (1.+1./(M_PI-p.z));\n\tp.y /= sqrt(unsquish);\n\t\n\tp.x = fract((p.x)*rrep+0.25)/rrep-0.25; // radius rep\n\tp.z -= 1.6+0.25*eradius; // inclination transform\n\t\n\t// stem\n\tfloat ret = sdCylinder(p.xzy-vec3(-0.03,1.,0.), vec2(0.02, 1.));\n\t\n\t// rotate for petal and cap stem\n\tfloat sub = -p.z;\n\tpR(p.yz, 0.6);\n\tpR(p.xz, 0.4);\n\tret = max(ret, -p.x+0.07+sub*0.3);\n\t\n\t// petal\n\tret = opUsmin(ret, sdBox(p, vec3(-0.3, 0.04, 0.04))-0.32, 0.1);\n\treturn ret;\n\t\n}\n\nfloat sdf(in vec3 p)\n{\n    float fix = length(p+vec3(0.,0.35,0.))-0.3;\n    if (fix<0.05) fix = 10.;\n\tp *= 1. - 0.02*kk(length(p));\n\t\n\tp.xzy = logspherical(p.xzy);\n\tfloat eradius = exp(p.x-0.25);\n\tp.x -= timein;\n\t\n\tfloat sd = sphFlower(p, eradius);\n\tp.x += 0.25;\n\tsd = min(sd, sphFlower(p, eradius));\n\t\n\tsd *= eradius;\n\treturn min(sd, fix);\n}\n\nfloat iqhash(float n)\n{\n\treturn fract(sin(n)*43758.5453);\n}\n\nvec3 castRay(in vec3 ro, in vec3 rd)\n{\n\tfloat rmul = iqhash(rd.x*0.1+rd.y*10.+rd.z*100.+fract(timein))*0.05;\n\tro += rd * rmul*2.;\n\tfloat tmin = 0.2;\n\tfloat tmax = 30.0;\n\t\n\tfloat t = tmin;\n\tfloat m = -1.0;\n\tfloat i2;\n\t\n\tfor(int i=0; i<ITER; i++)\n\t{\n\t\ti2 = float(i);\n\t    float precis = 0.0004*t;\n\t\tvec3 pos = ro+rd*t;\n\t    vec2 res = vec2(sdf(pos), 53.);\n\t\tif(res.x<precis || t>tmax) break;\n\t\tt += res.x*(0.8+rmul);\n\t    m = res.y;\n\t}\n\n\tif( t>tmax ) {\n\t\ti2 = float(ITER);\n\t\tm=-1.0;\n\t}\n\tvec3 pt = ro+rd*t;\n\treturn vec3(t, m, i2);\n}\n\n// Adapted from http://iquilezles.org/www/articles/normalsSDF/normalsSDF.htm\nvec3 calcNormal(in vec3 pos)\n{\n\tvec2 e = vec2(1.0,-1.0)*0.5773;\n\tconst float eps = 0.0005;\n\treturn normalize(\n\t\te.xyy*sdf(pos + e.xyy*eps) + \n\t\te.yyx*sdf(pos + e.yyx*eps) + \n\t\te.yxy*sdf(pos + e.yxy*eps) + \n\t\te.xxx*sdf(pos + e.xxx*eps)\n\t);\n}\n\nvoid getray(in vec2 pos, out vec3 ro, out vec3 rd)\n{\n\t//pos = pos*-1.333+0.677;\n\tvec3 ta = vec3(0., cam_ty, 0.);\n\tro = cam_pos;\n\tvec3 ww = normalize(ta - ro);\n\tvec3 uu = normalize(cross(ww,vec3(0.0,1.0,0.0)));\n\tvec3 vv = normalize(cross(uu,ww));\n\trd = normalize(pos.x*uu + pos.y*vv + fov*ww);\n}\n\nvec3 render(in vec3 ro, in vec3 rd, in vec2 scrpos)\n{\n\tvec3 bg = vec3(0.7, 0.9, 1.0) +rd.y*0.8;\n\tvec3 col = bg;\n\tvec3 res = castRay(ro,rd);\n\tfloat t = res.x;\n\tfloat m = res.y;\n\tvec3 pos = ro + t*rd;\n\n\tvec3 ipt = vec3(0.);\n\t\n\tif( m>-0.5 )\n\t{\n\t\tvec3 nor = calcNormal( pos );\n\t\t\n\t\t// material        \n\t\tcol = 0.45 + 0.35*sin( vec3(0.05,0.08,0.10)*(m-1.0) );\n\n\t\t// lighting        \n\t\tvec3  lig = normalize( vec3(-0.4, 0.7, -0.6) );\n\t\tfloat amb = clamp( 0.5+0.5*nor.y, 0.0, 1.0 );\n\t\tfloat dif = clamp( dot( nor, lig ), 0.0, 1.0 );\n\t\tfloat bac = clamp( dot( nor, normalize(vec3(-lig.x,0.0,-lig.z))), 0.0, 1.0 )*clamp( 1.0-pos.y,0.0,1.0);\n\t\tfloat fre = pow( clamp(1.0+dot(nor,rd),0.0,1.0), 2.0 );\n\n\t\tvec3 lin = vec3(0.0);\n\t\tlin += 1.30*dif*vec3(1.00,0.80,0.55);\n\t\tlin += 0.40*amb*vec3(0.40,0.60,1.00);\n\t\tlin += 0.50*bac*vec3(0.25,0.25,0.25);\n\t\tlin += 0.25*fre*vec3(1.00,1.00,1.00);\n\t\tcol = col*lin;\n\t}\n\n\tfloat fogf = pos.y<0. ? -(pos.y * pos.y * 3.): 0.;\n\tcol = mix( col, bg, 1.0-exp( -0.006*t*t + fogf) );\n\t\n\tvec3 inice = vec3(res.z/float(ITER));\n\tinice *= inice;\n\tinice = mix( inice, vec3(1.), 1.0-exp( -0.0002*t*t*t ) );\n\tcol = col*(inice)*1.2 + bg*(inice)*0.4;\n\n\t//return inice;\n\treturn vec3( clamp(col,0.0,1.0) );\n}\n\n// From http://iquilezles.org/www/articles/functions/functions.htm\nfloat gain(float x, float k) \n{\n\tfloat a = 0.5*pow(2.0*((x<0.5)?x:1.0-x), k);\n\treturn (x<0.5)?a:1.0-a;\n}\n\nvec3 gain(vec3 v, float k)\n{\n\treturn vec3(\n\t\tgain(v.x, k),\n\t\tgain(v.y, k),\n\t\tgain(v.z, k)\n\t);\n}\n\nvec3 pillow(in vec3 col, in vec2 uv)\n{\n\tuv -= 0.5;\n\tfloat mpow = 5.;\n\tfloat d = pow(pow(abs(uv.x),mpow)+pow(abs(uv.y),mpow),1./mpow);\n\td = smoothstep(0., 1., d*2.-0.64);\n\treturn mix(col, vec3(0.), d);\n}\n\n// Based on http://iquilezles.org/www/articles/raymarchingdf/raymarchingdf.htm\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n\ttimein = iTime*0.08*1.8+4.;\n\tctrl = iTime*0.1+0.1;\n\n\tfloat t2 = ctrl * M_PI + 0.3;\n\tvec3 shot1 = vec3(0.75, -0.7, cos(t2)*0.3+1.1);\n\tvec3 shot2 = vec3(0.75, -0.7, cos(t2)*0.25+2.4);\n\tvec3 shot3 = vec3(cos(t2)*0.392+0.952, -3.0, 0.1);\n\tvec3 shot = shot3;\n\tif (mod(ctrl, 3.) <= 2.) shot = shot2;\n\tif (mod(ctrl, 3.) <= 1.) shot = shot1;\n\tfov = shot.x;\n\tcam_ty = shot.y;\n\tcam_incl = shot.z;\n\n\n\tcam_azi = M_PI * timein / (1.5 * 5.) + 0.12;\n\tcam_pos = vec3(\n\t\tcam_dist*sin(cam_incl)*cos(cam_azi), \n\t\tcam_dist*cos(cam_incl),\n\t\tcam_dist*sin(cam_incl)*sin(cam_azi) );\n\n\tAAradius  = vec2(1.) / iResolution.xy;\n\tvec3 tot = vec3(0.);\n\n\t// centered ratio-corrected UV\n\tvec2 cUV = uv-vec2(0.5);\n\tcUV.x *= iResolution.x/iResolution.y;\n\t\n\t#if AA > 1\n\tfor( int m=0; m<AA; m++ )\n\tfor( int n=0; n<AA; n++ )\n\t{    \t\n\t\t// pixel coordinates\n\t\tvec2 ofs = AAradius*(vec2(float(m),float(n)) / float(AA) - 0.5);\n\t\tvec2 pos = cUV+ofs;\n\t#else    \n\t\tvec2 pos = cUV;\n\t#endif\n\t\tvec3 ro, rd;\n\t\tgetray(pos, ro, rd);\n\t\t\n\t\tvec3 col = render(ro, rd, pos);\n\t\ttot += col;\n\t#if AA>1\n\t}\n\ttot /= float(AA*AA);\n\t#endif\n\ttot = pow(tot, vec3(0.4545));\n\ttot = gain(tot, 1.5);\n\ttot = pillow(tot, uv);\n\ttot *= 1.-pow(cos(ctrl*M_PI*2.)*0.5+0.5, 200.);\n\n    // Output to screen\n    fragColor = vec4(tot, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wdjXDw.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[626, 698, 730, 730, 772], [774, 862, 898, 898, 997], [998, 998, 1029, 1029, 1120], [1121, 1121, 1165, 1165, 1258], [1260, 1308, 1338, 1338, 1418], [1420, 1420, 1439, 1439, 1470], [1472, 1472, 1518, 1518, 2090], [2092, 2092, 2114, 2114, 2433], [2435, 2435, 2458, 2458, 2494], [2496, 2496, 2534, 2534, 3025], [3027, 3104, 3134, 3134, 3344], [3346, 3346, 3398, 3425, 3640], [3642, 3642, 3695, 3695, 4855], [4857, 4924, 4955, 4955, 5028], [5030, 5030, 5058, 5058, 5125], [5127, 5127, 5165, 5165, 5329]], "test": "ok"}
{"id": "WdsSDn", "name": "Playing With Pentagons", "author": "gannon", "description": "pentagons", "tags": ["pentagon"], "likes": 1, "viewed": 350, "published": "Public API", "date": "1554487129", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float sdHexPrism( vec3 p, vec2 h )\n{\n    const vec3 k = vec3(-0.8660254, 0.5, 0.57735);\n    p = abs(p);\n    p.xy -= 2.0*min(dot(k.xy, p.xy), 0.0)*k.xy;\n    vec2 d = vec2(\n       length(p.xy-vec2(clamp(p.x,-k.z*h.x,k.z*h.x), h.x))*sign(p.y-h.x),\n       p.z-h.y );\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nvec2 tile(vec2 _st, float _zoom){\n    _st *= _zoom;\n    return fract(_st);\n}\n\nfloat sdPentagon( in vec2 p, in float r )\n{\n    const vec3 k = vec3(0.809016994,0.587785252,0.726542528); // pi/5: cos, sin, tan\n\n    // reflections\n    p.y = -p.y;\n    p.x = abs(p.x);\n    p -= 2.0*min(dot(vec2(-k.x,k.y),p),0.0)*vec2(-k.x,k.y);\n    p -= 2.0*min(dot(vec2( k.x,k.y),p),0.0)*vec2( k.x,k.y);\n    \n\t// side of polygon\n    return length(p-vec2(clamp(p.x,-r*k.z,r*k.z),r))*sign(p.y-r);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    vec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n    // p = tile(p,1.);\n    // Time varying pixel color\n    vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n\t\n    float pent = sdPentagon(p,0.85)/sdPentagon(p,0.82) + sdPentagon(p,0.75)/sdPentagon(p,0.72);\n    float pent2= sdPentagon(p,0.1+ sin(iTime/2.));\n\n    \n    // Output to screen\n    fragColor = vec4(cos(iTime)-clamp(pent,0.,0.1),0.5-clamp(pent-pent2,0.,0.1),1.-clamp(pent2,0.,0.1),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WdsSDn.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 36, 36, 319], [321, 321, 354, 354, 397], [399, 399, 442, 442, 796], [798, 798, 855, 905, 1406]], "test": "ok"}
{"id": "WdSSRD", "name": "大龙猫 - Hanami", "author": "totetmatt", "description": "Playing with circles, almost back to school playing with compass :)\nCouldn't find a way to add more \"depht\" but I like it.", "tags": ["circle", "hanami", "pinky"], "likes": 11, "viewed": 642, "published": "Public", "date": "1554712181", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv  = ( fragCoord -.5* iResolution.xy ) / iResolution.y;\n    float z =0.2;\n     \n   \n    if(sqrt(uv.x*uv.x +uv.y*uv.y) > 0.1){\n    uv.y += sign(sin(uv.x*100.))/30.* sin(uv.x*uv.x +uv.y*uv.y) ;//*sin(iTime*2.);\n    uv.x += sign(cos(uv.y*100.))/30. * sin(uv.x*uv.x +uv.y*uv.y);//*cos(iTime*2.);\n    /* Some Nice Effect */\n    }\n    // uv.y += sign(sin(uv.x*20.))/200.*clamp(sin(iTime*2.+3.),0.,1.);\n    //uv.x += sign(sin(uv.y*20.))/200.*clamp(-sin(iTime*2.),-1.,0.);\n    //uv.x += sign(sin(uv.x*20.))/200.*clamp(-cos(iTime*2.),-1.,0.);\n     //uv.y += sign(sin(uv.y*20.))/200.*clamp(sin(iTime*2.+3.),0.,1.);\n    \n    //uv.x = log(uv.x)*z ;\n   \n   // uv.y = log(uv.y)*z ; \n    \n   \n    \n    float p= 0.2  ;\n    float q= 0.229 - (1.+cos(iTime*2. - exp(length(uv)*2.) ))/45.;\n    float k= 6.;\n    \n    float colc = mod(length(uv )  -  iTime/k ,p) ;\n    \n\tfloat col1 = mod(length(uv + vec2(0.1,0.))  -  iTime/k ,p) ;\n    float col2 = mod(length(uv + vec2(-0.1,0.)) -  iTime/k ,p);\n    \n    float col3 = mod(length(uv + vec2(0,-0.1))  -  iTime/k ,p);\n    float col4 = mod(length(uv + vec2(0,0.1))   -  iTime/k ,p);\n    \n    \n    \n    float colo = mix(col1,col2,0.5);\n    float coli = mix(col3,col4,0.5);\n    float col  = mix(colo,coli,0.5);\n    \n    float aa = (colo + coli) /2.;\n    \n    \n    col = clamp(.8,.9, smoothstep(q,q-0.15,col));\n   \n    float b  =  1.-col;\n    \n    float ring =  smoothstep(1.,0.8,log( (q*10.59) ))+q;\n\n    ring = smoothstep(0.2,0.1,1.-ring);\n  \n    fragColor = 1.5*vec4( vec3(0.9,0.2,0.6) * vec3( b+aa ,0.1,aa+col*b*ring )   ,1.0);\n    //fragColor  = vec4(col1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WdSSRD.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 107, 1703]], "test": "ok"}
{"id": "wdSXzK", "name": "Hypnoferromagnetism", "author": "dracusa", "description": "All parts are connected, nothing appears, nothing disappears (except where it glitches).\n\nUpdate: now with a bright center!", "tags": ["logspherical"], "likes": 37, "viewed": 725, "published": "Public API", "date": "1554334259", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/*\nA raymarching shader. I thought it would be interesting to tile iq's ellipsoid\napproximation, since it can be smoothly turned into an infinite cylinder,\nallowing the tiles to connect and disconnect with each other along different\naxes over time. I then applied the log-spherical map, so this reveals how the 3\naxes are transformed by this map:\n\n- Lines along the rho coordinate converge towards the origin\n- Lines along the theta coordinate become like circles of longitude\n- Lines along the phi coordinate become like circles of latitude\n\nThe ellipsoids also appear nicely twised because rotation is applied in a\ngradient (but this can't be pushed very far because it also twists the distance\nfield).\n\nThis is part of a series of explorations on the log-spherical mapping:\nhttps://www.osar.fr/notes/logspherical/\n*/\n\n// definitely try changing this value:\n#define DENSITY 12.0\n\n#define AA 2\n#define M_PI 3.1415926535897932384626433832795\n\nfloat worldtime;\nfloat centerhue;\n\n// ssN: smooth staircase of iteration N, step height = 2 pi\nfloat ss1(float x) { return x - sin(x); }\nfloat ss2(float x) { return ss1(ss1(x)); }\n\n// alternating smooth staircases\nfloat as(float x) { return smoothstep(0.1,0.4,fract(x))+floor(x); }\nfloat asa(float x) { return as(x*(0.25/M_PI)); }\nfloat asb(float x) { return as(x*(0.25/M_PI)+M_PI*0.5); }\n// shelves, returns 1 when the staircases are in the middle of steps\nfloat shelves(float x) { return 1.-pow(abs(sin(x*0.5)), 4.)*0.4; }\n\n// map (0-1) to (0-big) with inverse curve\nfloat zeroInf(float x) {\n\treturn -0.99/(x-1.)-0.98;\n}\n\n// Axis rotation taken from tdhooper. R(p.xz, a) rotates \"x towards z\".\nvoid pR(inout vec2 p, float a) {\n\tp = cos(a)*p + sin(a)*vec2(p.y, -p.x);\n}\n\n// iq's ellipsod https://www.shadertoy.com/view/tdS3DG\nfloat sdEllipsoid(in vec3 p, in vec3 r)\n{\n\tfloat k0 = length(p/r);\n\tfloat k1 = length(p/(r*r));\n\treturn k0*(k0-1.0)/k1;\n}\n\nfloat sdf(in vec3 p)\n{\n\tconst float lpscale = DENSITY/M_PI;\n\t\n\t// Apply the forward log-spherical map\n\tfloat r = length(p);\n\tp = vec3(log(r), acos(p.z / length(p)), atan(p.y, p.x));\n\n\t// Get a scaling factor to compensate for pinching at the poles\n\t// (there's probably a better way of doing this)\n\tfloat xshrink = 1.0/(abs(p.y-M_PI)) + 1.0/(abs(p.y)) - 1.0/M_PI;\n\n\t// Scale to fit in the ]-pi,pi] interval\n\tp *= lpscale;\n\n\t// prepare values for rotation and stretching of tile contents\n\tfloat rotclock = worldtime*5.-p.x;\n\tfloat stretch = shelves(worldtime*5.-p.x*0.5)*0.5+0.5;\n\tfloat thik = 0.005/(r+0.03);\n\n\t// Apply rho-translation, which yields zooming\n\tp.x -= worldtime;\n\t\n\t// Turn tiled coordinates into single-tile coordinates\n\tp = fract(p*0.5) * 2.0 - 1.0;\n\tp.x *= xshrink;\n\n\t// rotate and stretch the primitive\n\tpR(p.xz, asa(rotclock)*M_PI*0.5);\n\tpR(p.yz, asb(rotclock)*M_PI*0.5);\n\tfloat ret = sdEllipsoid(p, vec3(thik, thik, thik*zeroInf(stretch)));\n\n\t// Compensate for all the scaling that's been applied so far\n\t// (and shorten the steps a bit)\n\tfloat mul = 0.9*r/lpscale/xshrink;\n\treturn ret * mul;\n}\n\n// Minkowski pillow\nvec3 pillow(in vec3 col, in vec2 uv)\n{\n\tuv -= 0.5;\n\tfloat mpow = 5.;\n\tfloat d = pow(pow(abs(uv.x),mpow)+pow(abs(uv.y),mpow),1./mpow);\n\td = smoothstep(0., 1., d*2.-0.64);\n\treturn mix(col, vec3(0.), d);\n}\n\n// From http://www.iquilezles.org/www/articles/functions/functions.htm\nfloat gain(float x, float k) \n{\n\tfloat a = 0.5*pow(2.0*((x<0.5)?x:1.0-x), k);\n\treturn (x<0.5)?a:1.0-a;\n}\n\nvec3 gain(vec3 v, float k)\n{\n\treturn vec3(\n\t\tgain(v.x, k),\n\t\tgain(v.y, k),\n\t\tgain(v.z, k)\n\t);\n}\n\n// Smooth HSV by iq and Fabrice Neyret: https://www.shadertoy.com/view/MsS3Wc\nvec3 hsv2rgb_smooth(in vec3 c)\n{\n\treturn c.z * (1.-c.y*smoothstep(2.,1., abs(mod(c.x*6.+vec3(0,4,2), 6.) -3.)));\n}\n\n// Shading is flat. The color is an interpolation in HSV space between a\n// time-varying hue at the center and a backgroundish color at the outer limits\nvec3 shade(in vec3 pos)\n{\n\tfloat cf = clamp(length(pos*1.6), 0., 1.);\n\tvec3 hsv1 = vec3(centerhue, 0., 1.);\n\tvec3 hsv2 = vec3(0.6, 1., 0.2);\n    vec3 ret = mix(hsv1, hsv2, cf);\n    // and a bit of extra brightness at the center\n    ret.y = ret.y*0.2/(ret.y*ret.y+0.025);\n\treturn hsv2rgb_smooth(ret);\n}\n\n// Based on http://iquilezles.org/www/articles/raymarchingdf/raymarchingdf.htm\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n\t// alternate between moving the camera+color and moving the world\n\tworldtime = ss1(iTime+6.)*0.5;\n\tfloat camtime = ss2(iTime+M_PI+6.);\n\tcenterhue = abs(fract(camtime*0.03)-0.5)*2.2+0.1;\n\n\t // camera movement\t\n\tfloat an = 0.3*camtime;\n\tfloat cy = 0.6+sin(an*2.+1.6)*0.5;\n\tvec3 ro = vec3((1.3-cy*0.5)*sin(an), cy, (1.3-cy*0.5)*cos(an));\n\tvec3 ta = vec3( 0.0, 0.0, 0.0 );\n\t// camera matrix\n\tvec3 ww = normalize(ta - ro);\n\tvec3 uu = normalize(cross(ww,vec3(0.0,1.0,0.0)));\n\tvec3 vv = normalize(cross(uu,ww));\n\n\tvec3 bg = vec3(0.15, 0.15, 0.18);\n\tvec3 tot = bg;\n\t\n\t#if AA>1\n\tfor(int m=0; m<AA; m++)\n\tfor(int n=0; n<AA; n++)\n\t{\n\t\t// pixel coordinates\n\t\tvec2 o = vec2(float(m),float(n)) / float(AA) - 0.5;\n\t\tvec2 p = (-iResolution.xy + 2.0*(fragCoord+o))/iResolution.y;\n\t\t#else    \n\t\tvec2 p = (-iResolution.xy + 2.0*fragCoord)/iResolution.y;\n\t\t#endif\n\n\t\t// create view ray\n\t\tvec3 rd = normalize(p.x*uu + p.y*vv + 3.5*ww); // fov\n\n\t\t// raymarch\n\t\tconst float tmax = 2.7;\n\t\tfloat t = 0.5;\n\t\tvec3 pos;\n\t\tint i2;\n\t\tfor( int i=0; i<80; i++ )\n\t\t{\n\t\t\tpos = ro + t*rd;\n\t\t\tfloat h = sdf(pos);\n\t\t\tif( h<0.0001 || t>tmax ) break;\n\t\t\tt += h;\n\t\t\ti2 = i;\n\t\t}\n\t\n\t\t// shading/lighting\t\n\t\tvec3 col = vec3(0.0);\n\t\tif( t<tmax )\n\t\t\tcol = shade(pos);\n\t\t// fog\n\t\tcol = mix(col, bg, smoothstep(0.8, 2.5, t));\n\t\t// glow\n\t\tfloat g = float(i2) * (0.1/80.);\n\t\tcol += vec3(g);\n\n\t\ttot += col;\n\t#if AA>1\n\t}\n\ttot /= float(AA*AA);\n\t#endif\n\n\ttot = gain(clamp(tot, 0., 1.), 1.5);\n\ttot = pillow(tot, uv);\n\tfragColor = vec4(tot, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wdSXzK.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[978, 1038, 1058, 1058, 1079], [1080, 1080, 1100, 1100, 1122], [1124, 1157, 1176, 1176, 1224], [1225, 1225, 1245, 1245, 1273], [1274, 1274, 1294, 1294, 1331], [1332, 1401, 1425, 1425, 1467], [1469, 1512, 1536, 1536, 1565], [1567, 1639, 1671, 1671, 1713], [1715, 1770, 1811, 1811, 1891], [1893, 1893, 1915, 1915, 3007], [3009, 3029, 3067, 3067, 3231], [3233, 3304, 3335, 3335, 3408], [3410, 3410, 3438, 3438, 3505], [3507, 3585, 3617, 3617, 3699], [3701, 3854, 3879, 3879, 4155]], "test": "ok"}
{"id": "wdSXzt", "name": "Beam bending", "author": "MacSlow", "description": "Basic practice of putting a random idea to screen.", "tags": ["3d", "raymarching", "phong", "sdf", "shadows", "spheretracing", "reflections", "blinn"], "likes": 10, "viewed": 446, "published": "Public API", "date": "1555353968", "time_retrieved": "2021-10-01T00:00:00", "image_code": "////////////////////////////////////////////////////////////////////////////////\n//\n// Beam bending - Just shader-writing practice of a random idea.\n//\n// Copyright 2019 Mirco Müller\n//\n// Author(s):\n//   Mirco \"MacSlow\" Müller <macslow@gmail.com>\n//\n// This program is free software: you can redistribute it and/or modify it\n// under the terms of the GNU General Public License version 3, as published\n// by the Free Software Foundation.\n//\n// This program is distributed in the hope that it will be useful, but\n// WITHOUT ANY WARRANTY; without even the implied warranties of\n// MERCHANTABILITY, SATISFACTORY QUALITY, or FITNESS FOR A PARTICULAR\n// PURPOSE.  See the GNU General Public License for more details.\n//\n// You should have received a copy of the GNU General Public License along\n// with this program.  If not, see <http://www.gnu.org/licenses/>.\n//\n////////////////////////////////////////////////////////////////////////////////\n\nmat2 r2d (float deg) {\n\tfloat rad = radians (deg);\n\tfloat c = cos (rad);\n\tfloat s = sin (rad);\n\treturn mat2 (c,s,-s,c);\n}\n\nfloat texNoise (vec2 p) {\n\treturn texture (iChannel0, p).r;\n}\n\nfloat smin (float d1, float d2, float k) {\n\tfloat h = clamp (.5 + .5*(d2 - d1)/k, .0, 1.);\n\treturn mix (d2, d1, h) - h*k*(1. - h);\n}\n\nfloat map (vec3 p, inout int id, inout vec3 pout) {\n\tfloat size = 3.;\n\tfloat offset = cos (.2*iTime);\n\tfloat offset2 = cos (iTime);\n\tfloat ground = p.y + size + offset2 + .75*texNoise (offset+.05*p.xz+.1*iTime);\n\tground = min (ground, -p.y + size + offset2 + .75*texNoise (offset-.1*iTime+.075*p.xz + 1.));\n\tfloat wall = p.z + 3.*size;\n\twall = min (wall, -p.z + 3.*size);\n\twall = min (wall, p.x + 2.*size);\n\twall = min (wall, -p.x + 2.*size);\n\tvec3 pbar = p;\n\tpbar.xz *= r2d (25.*cos (pbar.y + sin(3.*iTime)));\n\tpbar.xy *= r2d (9.*cos (pbar.y + sin(4.*iTime)));\n\tpbar.yz *= r2d (9.*sin (pbar.y + sin(2.*iTime)));\n\n\tpbar.x += .2*cos (pbar.y + 2.*iTime);\n\tpbar.z += -(.3*(cos(2.*iTime)))*sin (2.*pbar.y + 2.*iTime);\n\tfloat thickness = .5-.2*offset2*cos (2.*pbar.y+3.*iTime);\n\tvec3 s = vec3 (thickness, 3.5, thickness);\n\tfloat bar = length (max (vec3 (.0), abs (pbar) - s)) - .1;\n\tfloat d = min (wall, smin (ground, bar, 1.5));\n\tid = 1;\n    pout = pbar;\n\tif (d == wall) {id = 2; pout = p;}\n    return d;\n}\n\nfloat march (vec3 ro, vec3 rd, inout int id, inout vec3 pout)\n{\n\tfloat t = .0;\n\tfloat d = .0;\n\tfor (int i = 0; i< 64; ++i) {\n\t\tvec3 p = ro+d*rd;\n\t\tt = map (p, id, pout);\n\t\tif (abs (t) < .000000001*(1. + .125*t)) break;\n\t\td += t*.5;\n\t}\n\treturn d;\n}\n\nvec3 norm (vec3 p){\n\tint foo;\n\tvec3 bar;\n\tfloat d = map (p, foo, bar);\n\tvec2 e = vec2 (.01, .0);\n\treturn normalize (vec3 (map (p+e.xyy, foo, bar),\n                            map (p+e.yxy, foo, bar),\n                            map (p+e.yyx, foo, bar))-d);\n}\n\nfloat sha (vec3 p, vec3 lp, vec3 n, vec3 ldir) {\n\tfloat d2l = distance (lp, p);\n\tint foo;\n\tvec3 bar;\n\tfloat d2w = march (p+.01*n, ldir, foo, bar);\n\treturn d2l < d2w ? 1. : .1;\n}\n\nvec3 shade (vec3 ro, vec3 rd, float d, vec3 n, vec3 lp, vec3 lc, float li, int id, vec3 pout) {\n    vec3 p = ro + d*rd;\n\tfloat ld = distance (p, lp); \n\tvec3 ldir = normalize (lp - p);\n\tfloat att = 12. / (ld*ld);\n\tvec3 mat = vec3 (1., .0, .0);\n\tif (id == 1) mat = vec3 (.0);\n\tif (id == 2) mat = mix (vec3 (.0), vec3 (1.), smoothstep (.0, .5, sin (3.*p.y+5.*iTime)));\n\tfloat s = sha (p, lp, n, ldir);\n\tfloat diff = max (.0, dot (n, ldir));\n\tvec3 h = normalize (-rd + ldir);\n\tfloat shiny = 40.;\n\tfloat sp = pow (max (.0, dot (n, h)), shiny);\n\tvec3 am = vec3 (.05);\n\treturn att*s*(am + diff*lc*li*mat + sp*vec3 (1.));\n}\n\nvec3 cam (vec2 uv, vec3 ro, vec3 aim, float z) {\n\tvec3 f = normalize (aim - ro);\n\tvec3 wu = vec3 (.0, 1., .0);\n\tvec3 r = normalize (cross (wu, f));\n\tvec3 u = normalize (cross (f, r));\n\tvec3 c = ro + f*z;\n\treturn normalize(c + r*uv.x + u*uv.y - ro);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uvRaw = fragCoord/iResolution.xy;\n\tvec2 uv = uvRaw*2. - 1.;\n\tuv.x *= iResolution.x/iResolution.y;\n\tuv *= 1. + .25*length (uv);\n\n\tfloat dist = 3.;\n\tvec3 ro = vec3 (dist*cos (iTime), .0, dist*sin(iTime));\n\tvec3 rd = cam (uv, ro, vec3 (.0), 1.25);\n\tint id = 0;\n\tvec3 pout = vec3 (.0);\n\tfloat d = march (ro, rd, id, pout);\n\tvec3 p = ro + d*rd;\n\tvec3 n = norm (p);\n\tvec3 c = shade (ro, rd, d, n, vec3 (.0, .0, 2.), vec3 (.9, .85, .3), 2.,id, pout);\n\tc += shade (ro, rd, d, n, vec3 (2., 2., -2.), vec3 (.5, .5, .9), 2.,id, pout);\n\n\tif (id == 1) {\n\t\tro = p + .01*n;\n\t\trd = normalize (reflect (rd, n));\n\t\td = march (ro, rd, id, pout);\n\t\tp = ro + d*rd;\n\t\tn = norm(p);\n\t\tvec3 rc = shade (ro, rd, d, n, vec3 (.0, .0, 2.), vec3 (.9, .85, .3), 2.,id, pout);\n\t\trc += shade (ro, rd, d, n, vec3 (2., 2., -2.), vec3 (.3, .3, .9), 2.,id, pout);\n\t\tc += .3*rc;\n\t}\n\tc=c/(1.25+c*.5);\n\tc*=1.-.65*length(uvRaw*2.-1.);\n\tc*=mix(1.,.75,cos(500.*uvRaw.y));\n\tc=pow(c,vec3(1./2.2));\n\n    fragColor = vec4(c,1.);\n}\n", "image_inputs": [{"id": "4sf3Rr", "previewfilepath": "/media/ap/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wdSXzt.jpg", "access": "shaders20k", "license": "gpl-3.0", "functions": [[945, 945, 967, 967, 1066], [1068, 1068, 1093, 1093, 1129], [1131, 1131, 1173, 1173, 1263], [1265, 1265, 1316, 1316, 2267], [2269, 2269, 2332, 2332, 2516], [2518, 2518, 2537, 2537, 2776], [2778, 2778, 2826, 2826, 2955], [2957, 2957, 3052, 3052, 3572], [3574, 3574, 3622, 3622, 3824], [3826, 3826, 3883, 3883, 4876]], "test": "error"}
{"id": "wlf3Dn", "name": "Opposite Mirror: FBM Pattern", "author": "takumifukasawa", "description": "Opposite Mirror: FBM Pattern", "tags": ["fbm", "mirror", "oppositemirror"], "likes": 6, "viewed": 129, "published": "Public", "date": "1556082375", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n//-----------------------------------------------------------\n// fbm ref.\n// https://thebookofshaders.com/13/?lan=jp\n// http://www.iquilezles.org/www/articles/warp/warp.htm\n//-----------------------------------------------------------\n\n#define EPS 0.0001\n#define PI 3.14159265359\n#define FLT_MAX 3.402823466e+38\n#define FLT_MIN 1.175494351e-38\n#define DBL_MAX 1.7976931348623158e+308\n#define DBL_MIN 2.2250738585072014e-308\n\nprecision highp float;\n\nconst int num = 16;\nvec2 textureScale = vec2(1.);\nvec2 textureOffset = vec2(0.);\nvec2 parallaxScale = vec2(0.); // if use parallax with mouse, set value rather than 0.\nfloat speed = 1.2;\nfloat scaleStep = .66;\n\nfloat bs = 0.; // border size\n\nvec3 oppositeMirror(vec2 coord, vec2 mouse) {\n\tvec3 st = vec3(0.); // dist uv\n\n    vec3 np = vec3(0.);\n\tvec3 nn = vec3(0.);\n\tvec3 nf = normalize(vec3(mouse, 0.));\n\tvec3 center = vec3(0.);\n\tvec3 v = nn - (-nf);\n    // v = normalize(v);\n    // vec3 v = vec3(0.);\n\n\tfloat ts = iTime * speed;\n\tfloat t = mod(ts, 1.f); // 0 - 1\n\n\t// highp int n = int(num);\n    int n = num;\n\n\tfor(int i=0; i<n; i++) {\n\t\tfloat si = mix(float(i) - 2., float(i) - 3., t); // margin for parallax\n        \n\t\tvec3 po = v;\n\t\tpo.z *= -1.;\n        \n\t\tvec2 m = po.xy * parallaxScale * (1.f - si / float(n));\n  \t\t//vec2 m = vec2(-0.); // debug: off parallax\n  \t\tvec2 rd = 1. / textureScale;\n\n\t\tvec2 uv = coord - textureOffset;\n\n\t\tuv *= 1. / pow(scaleStep, si);\n\t\t// centering offset \n\t\tfloat sc = pow(1. / scaleStep, si) - 1.;\n\t\tuv += rd * -.5 * sc + rd * m * - .5;\n  \t\tif(\n    \t\t0. <= uv.x\n    \t\t&& rd.x >= uv.x\n    \t\t&& 0. <= uv.y\n   \t\t \t&& rd.y >= uv.y\n  \t\t) {\n    \t\tst.xy = uv;\n            st.z = si;\n            // flip\n    \t\tfloat ft = mod(floor(ts), 2.);\n    \t\tint fi = int(step(.5, ft));\n            if(mod(float(i), 2.) == float(fi)) {\n                st.x = rd.x - st.x;\n            }\n        } else {\n            break;\n        }\n\t}\n\n\treturn st; \n}\n\nfloat random(in vec2 st)\n{\n    return fract(sin(dot(st.xy, vec2(12.9898, 78.233))) * 43758.5453123);\n}\n\nfloat noise (in vec2 st) {\n    vec2 i = floor(st);\n    vec2 f = fract(st);\n\n    float a = random(i);\n    float b = random(i + vec2(1.0, 0.0));\n    float c = random(i + vec2(0.0, 1.0));\n    float d = random(i + vec2(1.0, 1.0));\n\n    vec2 u = f * f * (3.0 - 2.0 * f);\n\n    return mix(a, b, u.x) +\n            (c - a)* u.y * (1.0 - u.x) +\n            (d - b) * u.x * u.y;\n}\n\n#define OCTAVES 4\nfloat fbm(in vec2 st) {\n  float value = 0.;\n  float amp = .44;\n      \n  for(int i = 0; i < OCTAVES; i++) {\n    value += amp * noise(st);\n    st *= 2.3;\n    amp *= .44;\n  }\n  return value;\n}\n\nfloat pattern(in vec2 p) {\n  float f = 0.;\n  vec2 q = vec2(\n    fbm(p + iTime * .15 + vec2(0.)),\n    fbm(p + iTime * .05 + vec2(2.4, 4.8))\n  );\n  vec2 r = vec2(\n    fbm(q + iTime * .1 + 4. * q + vec2(3., 9.)),\n    fbm(q + iTime * .2 + 8. * q + vec2(2.4, 8.4))\n  );\n  f = fbm(p + r * 2. + iTime * .1);\n  return clamp(f, 0., 1.);\n}\n\nvec3 gradient(float v, float i) {\n\t//v += i * .1;\n    //vec3 r = vec3(random(vec2(i, i)), random(vec2(i, i)), random(vec2(i, i)));\n    float steps = 4.;\n\tfloat s = 1. / steps;\n    vec3 col = vec3(0.);\n\n    // base colors\n    vec3 c1 = vec3(255. / 255.,  255. / 255.,  255. / 255.);\n\tvec3 c2 = vec3(53. / 255.,  185. / 255.,  208. / 255.);\n    vec3 c3 = vec3(0. / 255.,  128. / 255.,  209. / 255.);\n\tvec3 c4 = vec3(233. / 255., 233. / 255., 215. / 255.);\n    vec3 c5 = vec3(230. / 255.,  244. / 255.,  241. / 255.);\n\n\tif(v >= 0. && v < s) {\n  \t\tcol = mix(c1, c2, v * steps);\n\t} else if (v >= s && v < s * 2.) {\n  \t\tcol = mix(c2, c3, (v - s) * steps);\n\t} else if (v >= s * 2. && v < s * 3.) {\n    \tcol = mix(c3, c4, (v - s * 2.) * steps);\n    } else {\n        col = mix(c4, c5, (v - s * 3.) * steps);\n\t}\n    col += sin((iTime * .95) * vec3(\n        sin(iTime * .03 + .2) * .5 + .5,\n        sin(iTime * .03 + .8) * .5 + .5,\n        sin(iTime * .03 + 1.4) * .5 + .5\n    )) * .2;\n    \n    float n = float(num);\n  \treturn col;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    float aspect = iResolution.x / iResolution.y;\n    \n    vec2 mouse = (iMouse.xy / iResolution.xy) * 2. - 1.;\n    \n\tvec3 om = oppositeMirror(uv, mouse);\n\t\n    uv.xy = om.xy;\n    \n\tvec3 color = gradient(pattern(uv), om.z);\n    \n    float border = 0.;\n    border += 1. - step(bs, uv.x) * (1. - step(1. - bs, uv.x));\n    border += 1. - step(bs * aspect, uv.y) * (1. - step(1. - bs * aspect, uv.y));\n    border =  clamp(border, 0., 1.);\n    \n    color = mix(color, vec3(1.), border);\n\n    //color = vec3(border);\n    \n\tfragColor = vec4(color, 1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wlf3Dn.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[692, 692, 737, 737, 1918], [1920, 1920, 1946, 1946, 2022], [2024, 2024, 2050, 2050, 2394], [2414, 2414, 2437, 2437, 2603], [2605, 2605, 2631, 2631, 2934], [2936, 2936, 2969, 3066, 3958], [3960, 3960, 4015, 4015, 4608]], "test": "ok"}
{"id": "wlf3RH", "name": "Local Random Phase Noise (2014)", "author": "H4w0", "description": "Simple implementation of the noise model introduced by Gilet et al. \nLocal Random-Phase Noise for Procedural Texturing (SIGGRAPH ASIA 2014) \nMouse.x : Frequency - Mouse.y : Orientation", "tags": ["procedural", "noise", "texture", "prng", "lrpn"], "likes": 7, "viewed": 602, "published": "Public API", "date": "1555606426", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//@author : Arthur Cavalier\n\n// Simple implementation of the noise model introduced by Gilet et al. \n// Local Random-Phase Noise for Procedural Texturing (SIGGRAPH ASIA 2014)\n// http://www.unilim.fr/pages_perso/guillaume.gilet/publications/pdf/ProcTextures.pdf\n\n// User Controls\n#define MOUSE_CONTROL\n#define TIMER_OFFSET\n//#define BERNOUILLI\nconst int   NOF_COSINES = 5;\nconst float GRID_RES    = 5.0;\n\n// Constants\nconst float m_pi_2        = 1.57079632;         \nconst float m_pi          = 3.14159265;          \nconst float m_2_pi        = 6.28318530;  \n\n\n// Pseudo Random Number Generation\n// From Texton Noise Source Code provided by Galerne et al. \n// https://www.idpoisson.fr/galerne/texton_noise/index.html\n// Sourced ::\n/* \n * From http://www.reedbeta.com/blog/2013/01/12/quick-and-easy-gpu-random-numbers-in-d3d11/\n * Same strategy as in Gabor noise by example\n * Apply hashtable to create cellseed\n * Use a linear congruential generator as fast PRNG\n */\n\nuint  wang_hash(uint seed)                                          {seed=(seed^61u)^(seed>>16u);seed*=9u;seed=seed^(seed>>4u);seed*=668265261u;seed=seed^(seed>>15u);return(seed);}\nuint  cell_seed(const in ivec2 c, const in uint offset)             {const uint period=1024u;uint s=((uint(c.y)%period)*period+(uint(c.x)%period))*period+offset; if(s==0u){s = 1u;}return(s);}\nuint  myrand(inout uint p)                                          {p^=(p<<13u);p^=(p>>17u);p^=(p<<5u);return p;}\nfloat myrand_uniform_0_1(inout uint p)                              {return float(myrand(p))/float(4294967295u);}\nfloat myrand_uniform_m_M(inout uint p, in float mi, in float ma)    {return mi + (myrand_uniform_0_1(p) * (ma - mi));}\n\n\n// Kaiser Bessel Function\nfloat bessel_3(float x)\n{\n    float y=0.5*x;\n    float y2=(y*y);\n    return(y2*y*(1.0/6.0+y2*(1.0/24.0+y2*(1.0/240.0+y2*(1.0/4320.0+y2/120960.0)))));\n}\n\nfloat kaiser_bessel_window(float x)\n{\n    float i=clamp(x/1.5,-1.0,1.0);\n    float t=sqrt(1.0-pow(i,2.0));\n    return float(bessel_3(3.0*m_pi*t)/bessel_3(m_pi*3.0));\n}\n\n// Procedural Noise Function\nvec3 local_random_phase_noise(\n        in vec2  texcoords,\n        in float resolution,\n        in int   cosines,\n        in vec2  range_frequency,\n        in vec2  range_orientation\n    )\n{\n    vec2  scaled_coords  = texcoords * resolution;\n    vec2  cell_coords  = fract(scaled_coords);\n    vec2  cell_index   = floor(scaled_coords);\n    \n    vec2  scaled_frequency = range_frequency * resolution;\n\n    ivec2 cell_ID;\n    uint  prng, seed;\n    \n    float lrpn = 0.;\n    for (int m=-1; m<=+1; m++)\n    for (int n=-1; n<=+1; n++)\n    {\n        cell_ID.x = int(cell_index.x) + m;\n        cell_ID.y = int(cell_index.y) + n;\n\n        seed = cell_seed(cell_ID,0u);\n        prng = wang_hash(seed);\n\n        vec2 xy = cell_coords - vec2(m,n) - vec2(0.5);\n        float w = 1. / float(cosines);\n        float d = dot(xy,xy);\n        \n        float sc = 0.; // Sum of cosines\n        for(int k=0; k<cosines; k++)\n        {\n            float fr = myrand_uniform_m_M(prng,scaled_frequency.x,scaled_frequency.y); // pick a frequency \n            float or = myrand_uniform_m_M(prng,range_orientation.x,range_orientation.y); // pick an orientation\n            float ph = m_pi*(myrand_uniform_0_1(prng)*2.-1.); // pick a phase (shift)\n            float Am = myrand_uniform_0_1(prng)*2.-1.; // pick a amplitude between [-1;1]\n\n            #ifdef BERNOUILLI\n                // In Gabor Noise Revisited (JFIG 2018)\n                // Tavernier et al. (https://hal.archives-ouvertes.fr/hal-01926451/document)\n                // Studied Gabor Noise and its follow ups \n                // They compared the uniform weighting scheme for Gabor Kernels with simple Bernouilli distribution\n                // \"Splats with a low weight count for little in the sum, which seems like a waste of computation\"\n\n                // Because the formulation is quite close\n                // Testing with a LRPN seems interesting\n                Am = myrand_uniform_0_1(prng) > 0.5 ? -1.0 : 1.0; // choose between -1 or 1\n            #endif\n\n            vec2 ff = fr * vec2(cos(or),sin(or)); // oriented frequency\n            sc += Am * cos( m_2_pi * dot(xy,ff) + ph);\n        }\n\n        lrpn += kaiser_bessel_window(d) * w * sc;\n    }\n    return vec3(0.5+0.5*lrpn); \n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 texcoords = (2.*fragCoord.xy-iResolution.xy) / iResolution.y;\n    vec2 mouse = clamp(iMouse.xy / iResolution.xy, 0., 1.);\n\n    vec2 F,O; // frequency and orientation range ( vec2(min,max) )\n    float R = GRID_RES;  // grid resolution\n    int   K = NOF_COSINES;   // number of cosines\n\n#ifdef MOUSE_CONTROL\n    F = vec2(0.3, max(0.1,mouse.x) ); \n    O = vec2(0.,mouse.y*m_pi);      \n#else \n    F = vec2(0.4,0.5);\n    O = vec2(0.,m_pi / 6.);\n#endif\n\n#ifdef TIMER_OFFSET\n    texcoords += vec2(0.1*iTime);\n#endif\n\n    vec3 lrpn = local_random_phase_noise(texcoords,R,K,F,O);\n    fragColor = vec4(lrpn,1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wlf3RH.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[967, 967, 1036, 1036, 1147], [1340, 1340, 1409, 1409, 1454], [1455, 1455, 1524, 1524, 1568], [1569, 1569, 1638, 1638, 1687], [1690, 1716, 1741, 1741, 1867], [1869, 1869, 1906, 1906, 2036], [2038, 2067, 2257, 2257, 4303], [4306, 4306, 4363, 4363, 4976]], "test": "error"}
{"id": "Wlf3RN", "name": "Event Horizon", "author": "oemfoe", "description": "A simulation of falling into a black hole where a completely alternative universe resides. Thanks to iq for his noise functions.\n\nFeatured in RBBS-Minus-03: Singularity\nhttp://www.pouet.net/prod.php?which=81031", "tags": ["eventhorizonsingularityrbbs"], "likes": 1, "viewed": 292, "published": "Public API", "date": "1555706763", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec2 hash(vec2 x)\n{\n    const vec2 k = vec2( 0.3183099, 0.3678794 );\n    x = x*k + k.yx;\n    return -1.0 + 2.0*fract( 16.0 * k*fract( x.x*x.y*(x.x+x.y)) );\n}\n\nfloat noise( in vec2 p )\n{\n    vec2 i = floor( p );\n    vec2 f = fract( p );\n\t\n\tvec2 u = f*f*(3.0-2.0*f);\n\n    return mix( mix( dot( hash( i + vec2(0.0,0.0) ), f - vec2(0.0,0.0) ), \n                     dot( hash( i + vec2(1.0,0.0) ), f - vec2(1.0,0.0) ), u.x),\n                mix( dot( hash( i + vec2(0.0,1.0) ), f - vec2(0.0,1.0) ), \n                     dot( hash( i + vec2(1.0,1.0) ), f - vec2(1.0,1.0) ), u.x), u.y);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    float aspect = iResolution.x / iResolution.y;\n\tuv.y = -uv.y;\n    uv.y /= aspect;\n    \n    //vec2 sing = iMouse.xy / iResolution.xy;\n    vec2 sing = vec2(0.5, 0.5 / aspect);\n    sing.y = -sing.y;\n    \n    uv -= sing;\n    uv *= pow(0.1, (iTime - 10.0) * 0.05);\n    uv += sing;\n    \n\tvec2 warp = 1. * normalize(sing - uv) * pow(distance(sing, uv) * 1000.0, -1.0);\n\tuv = uv + warp;\n    \n    uv = fract(uv - iTime / 8.0);\n    \n    float n = smoothstep(0.4, 0.5, noise(uv * 100.) + noise(uv * 25.) / 2.0);\n\t\n\tfloat light = clamp(distance(sing, uv), 0.0, 1.0);\n\t\n\t//vec4 color = texture(iChannel1, fract(uv - iTime / 8.0));\n    vec4 color = vec4(n);\n\tfragColor = color;// * light;\n}\n", "image_inputs": [{"id": "XdfGRn", "previewfilepath": "/media/ap/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Wlf3RN.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 19, 19, 157], [159, 159, 185, 185, 583], [586, 586, 643, 643, 1365]], "test": "ok"}
{"id": "wlf3W8", "name": "blobs in a box", "author": "madpew", "description": "ray marching with single bounce reflections and very basic materials", "tags": ["simple", "sdf", "bouncereflections"], "likes": 1, "viewed": 329, "published": "Public API", "date": "1556189163", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float box(vec3 p, vec3 c)\n{\n  \tvec3 q = abs(p)-c;\n  \treturn min(0., max(q.x, max(q.y, q.z))) + length(max(q,0.));\n}\n\nfloat sphere(vec3 p, float r)\n{\n  \treturn length(p)-r;\n}\n\nfloat sdf_smin(float a, float b)\n{\n\tfloat res = exp(-12.*a) + exp(-12.*b);\n \treturn -log(max(0.001,res)) / 12.;\n}\n\nvec2 add_object(float f, float id, vec2 current)\n{\n    if (f < current.x) return vec2(f,id);\n    return current;\n}\n\nvec2 map(vec3 p)\n{\n    vec2 result = vec2(999.,-1.);\n    \n    float backwall = box(p, vec3(.9, .9, .05));\n    float leftwall = box(p+vec3(.9,0.,0.), vec3(.05,.9,.9));\n    float rightwall = box(p-vec3(.9,0.,0.), vec3(.05,.9,.9));\n    float floorwall = box(p+vec3(0.,.9,0.), vec3(.95,.05,.9));\n    \n    float room = min(floorwall, min(rightwall, min(backwall, leftwall)));\n    result = add_object(room, 0., result);\n    \n    vec3 rotbase = p+vec3(0.,0.,.5);\n    vec3 rotp = rotbase;\n    rotp.x = rotbase.x * cos(iTime*2.2) - rotbase.z * sin(iTime*2.2);\n  \trotp.z = rotbase.z * cos(iTime*2.2) + rotbase.x * sin(iTime*2.2);\n\n    float bar = box(rotp + vec3(0.,.8,0.), vec3(.38,.05,.05));\n    result = add_object(bar, 2., result);\n    \n    float s1 = sphere(p+vec3(.4*sin(iTime*2.3),.4*cos(iTime*1.4), 0.2), .3);\n    float s2 = sphere(p+vec3(.5*sin(iTime*1.7),.5*cos(iTime*1.2), .3+.3*sin(iTime*.7)), .2);\n    float s3 = sphere(p+vec3(.3*cos(iTime*1.3),.3*sin(iTime*1.7), .4+.35*cos(iTime*.6)), .4);\n    \n    float object =sdf_smin(s3, sdf_smin(s1, s2));\n    \n    result = add_object(object, 1., result);\n\n    float light_ball = sphere(p+vec3(.2*cos(iTime*2.1),.3*sin(iTime*2.1), .5+.2*cos(iTime*1.6)), .15);\n    result = add_object(light_ball, 3., result);\n    \n    float overball = sphere(p+vec3(.5*sin(iTime*2.1),.4*sin(iTime*1.5), .6+.4*cos(iTime*2.1)), .1);\n    result = add_object(overball, 4., result);\n    \n    return result;\n}\n\nvec4 getMaterial(int id)\n{\n    switch(id)\n    {\n        //shiny, light, texture, darken (should be reworked to emissive light)\n        // box\n        case 0: return vec4(0.4,1.,.25,0.);\n        \n        // blobs\n    \tcase 1: return vec4(1.,1.,0.,0.);\n        \n        // bar\n    \tcase 2: return vec4(0.,1.,1.,0);\n        \n        // light ball\n        case 3: return vec4(0.,0.,0.,0.);\n        \n        // dark ball\n        case 4: return vec4(0.,0.,0.,1.);\n    }\n}\n\nvec3 n(vec3 p)\n{\n  vec2 eps = vec2(0.00001, 0.); // eps defines hot smooth the normals are\n  return normalize(vec3(map(p+eps.xyy).x - map(p-eps.xyy).x, map(p+eps.yxy).x - map(p-eps.yxy).x, map(p+eps.yyx).x - map(p-eps.yyx).x));\n}\n\nfloat light(vec3 p)\n{\n  \tvec3 l = vec3(7.*cos(iTime*.5),8.*sin(iTime*.4),-4.);\n  \treturn dot(n(p), normalize(l))*.5+.5;\n}\n\nvec3 background(vec2 uv)\n{\n    vec2 bguv = uv+.01*sin(209.*uv);\n    return vec3(.2,.2,.3) * (mod(bguv.y+bguv.x*.3*cos(iTime+bguv.y*6.),(-bguv.x)*.7)*.9+.95);\n}\n\nvec4 march(vec2 uv)\n{\n  vec3 ro = vec3(0,0,-2.9); // ray origin\n  vec3 rd = normalize(vec3(uv, 1.)); // ray direction / cam direction\n  ro.x += .73*sin(iTime*.62); // simple camera movement and alignment\n  ro.y -= .03;\n    \n  vec3 p = ro; // current point\n  \n  \n    \n  bool hit = false;\n  vec3 color = vec3(1.);\n  vec3 bounce_pos = vec3(0);\n  vec4 bounce_material = vec4(0);\n    \n  for(float i=0.;i<100.; i++) // trace steps\n  { \n    // catch wandering rays\n    if ((abs(p.z) > 3.) || (abs(p.y) > 3.) || (abs(p.x) > 3.))\n    {\n    \tbreak;\n    }      \n      \n  \tvec2 tracehit = map(p); // get SDF (x = distance, y = object id)\n    \n    if (abs(tracehit.x)<0.001)\n    {\n        vec4 material = getMaterial(int(tracehit.y));\n        \n        if (hit == false)\n        {\n            hit = true;\n            bounce_pos = p;\n                \n            color = mix(vec3(1.), vec3(light(p)), material.y);\n            color *= mix(vec3(1.), texture(iChannel0, cos(p.xy)+p.yz+sin(p.zx)).xyz, material.z);\n            color *= (1.-material.w);\n            if (material.x > 0.)\n            {\n            \trd = reflect(rd,n(p));\n            \tp += rd * 0.0011;\n                bounce_material = material;\n            \tcontinue;\n            }\n            break;\n        } else {\n            // bounce hit\n            vec3 bounce_color = mix(vec3(1.), vec3(light(p)), material.y);\n            bounce_color *= mix(vec3(1.), texture(iChannel0, cos(p.xy)+p.yz+sin(p.zx)).xyz, material.z);\n            bounce_color *= (1.-material.w);\n            float bounce_distance = 1. - clamp(length(bounce_pos-p),0.,.75);\n            color = mix(color, bounce_color, bounce_material.x * bounce_distance); \n            break;\n        }\n    }\n  \tp += tracehit.x * rd;\n  }\n  \n  if (!hit)\n  {\n      color = background(uv);\n  }\n  \n  return vec4(color,1);\n}\n\nfloat random (in vec2 st) {\n    return fract(sin(dot(st.xy,vec2(12.98 *iTime,78.233)))*43758.5453123);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // normalized coordinates\n    vec2 uv = fragCoord/iResolution.xy;\n    uv -= .5;\n    uv /= vec2(iResolution.y / iResolution.x, 1);\n    \n    //pixelate\n    //uv -= mod(uv,0.0025);\n    \n\tfragColor = march(uv);\n\t\n  \t// gamma and grading\n  \tfragColor = pow(fragColor, .8*vec4(.9,1.0,.9,1));\n   \n  \t// white vignette\n  \tfragColor = mix(fragColor,vec4(random(uv)),length(uv)*.1);\n    fragColor = clamp(fragColor, 0.,1.);\n}", "image_inputs": [{"id": "Xsf3Rr", "previewfilepath": "/media/ap/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wlf3W8.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 27, 27, 115], [117, 117, 148, 148, 173], [175, 175, 209, 209, 288], [290, 290, 340, 340, 404], [406, 406, 424, 424, 1836], [1838, 1838, 1864, 1864, 2303], [2305, 2305, 2321, 2321, 2534], [2536, 2536, 2557, 2557, 2657], [2659, 2659, 2685, 2685, 2818], [2820, 2820, 2841, 2841, 4643], [4645, 4645, 4672, 4672, 4749], [4751, 4751, 4808, 4838, 5228]], "test": "error"}
{"id": "wlf3WM", "name": "Extinction Rebellion", "author": "hamoid", "description": "Shader XR\n\nClick to wave. Nothing too fancy, but maybe others can use the shape to do cool stuff :)", "tags": ["logo", "xr"], "likes": 3, "viewed": 322, "published": "Public API", "date": "1556481028", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const vec3 green = vec3(0.137, 0.658, 0.247);\n\n// See shorter contributed versions in the comments :)\n\n// v0.2\nfloat xr(vec2 pos, float aa) {\n    float w = 0.077;\n    float h = 0.639;\n    float tilt = 1.152;\n    // xy symmetry\n    pos = abs(pos);\n    return 1.0 - min(\n        // circle\n        smoothstep(w-aa, w, abs(length(pos)-1.0+w)) - \n        // black sand clock\n        smoothstep(pos.y-aa, pos.y, h) * \n        smoothstep(pos.x-aa, pos.x, pos.y / tilt + .11) *\n        // green holes in sand clock\n        (1.0 - \n        smoothstep(pos.y-aa, pos.y, h-w*2.) * \n        smoothstep(pos.x+w*3.-aa, pos.x+w*3., pos.y / tilt + .12)\n         )\n    , 1.);    \n}\n\nvoid mainImage( out vec4 O, in vec2 p ) {\n    vec2 uv = 1.1 * ( 2. * p - iResolution.xy ) / iResolution.y;\n    \n    // wavy\n    if(iMouse.z > 0.0) {\n    \tuv += 0.03 * sin(uv.y * 3. + iTime * 1.) * \n                     sin(uv.x * 2. - iTime * 2.);\n    }\n    \n    // noisy\n    vec3 n = vec3(fract(sin(uv.y+iTime)*1984.0) > 0.9 ? 0.2 : 0.0);\n    \n    O = vec4(mix(green, n, xr(uv, 3./iResolution.y)), 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wlf3WM.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[103, 111, 141, 141, 663], [665, 665, 706, 706, 1071]], "test": "ok"}
{"id": "Wlf3Wn", "name": "Bubble rings slow", "author": "RaduBT", "description": "Created by tdhooper", "tags": ["torus", "glow", "4d", "stereographic"], "likes": 5, "viewed": 429, "published": "Public API", "date": "1555971870", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n// --------------------------------------------------------\n// HG_SDF\n// https://www.shadertoy.com/view/Xs3GRB\n// https://www.shadertoy.com/view/WdB3Dw\n// Created by tdhooper \n// --------------------------------------------------------\n\n#define PI 3.14159265359\n\nvoid pR(inout vec2 p, float a) {\n    p = cos(a)*p + sin(a)*vec2(p.y, -p.x);\n}\n\nfloat smax(float a, float b, float r) {\n    vec2 u = max(vec2(r + a,r + b), vec2(0));\n    return min(-r, max (a, b)) + length(u);\n}\n\n\n// --------------------------------------------------------\n// Spectrum colour palette\n// IQ https://www.shadertoy.com/view/ll2GD3\n// --------------------------------------------------------\n\nvec3 pal( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d ) {\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\nvec3 spectrum(float n) {\n    return pal( n, vec3(0.5,0.5,0.5),vec3(0.5,0.5,0.5),vec3(1.0,1.0,1.0),vec3(0.0,0.33,0.67) );\n}\n\n\n// --------------------------------------------------------\n// Main SDF\n// https://www.shadertoy.com/view/wsfGDS\n// --------------------------------------------------------\n\nvec4 inverseStereographic(vec3 p, out float k) {\n    k = 2.0/(1.0+dot(p,p));\n    return vec4(k*p,k-1.0);\n}\n\nfloat fTorus(vec4 p4) {\n    float d1 = length(p4.xy) / length(p4.zw) - 1.;\n    float d2 = length(p4.zw) / length(p4.xy) - 1.;\n    float d = d1 < 0. ? -d1 : d2;\n    d /= PI;\n    return d;\n}\n\nfloat fixDistance(float d, float k) {\n    float sn = sign(d);\n    d = abs(d);\n    d = d / k * 1.82;\n    d += 1.;\n    d = pow(d, .5);\n    d -= 1.;\n    d *= 5./3.;\n    d *= sn;\n    return d;\n}\n\nfloat time;\n\nfloat map(vec3 p) {\n    float k;\n    vec4 p4 = inverseStereographic(p,k);\n\n    pR(p4.zy, time * -PI / 2.);\n    pR(p4.xw, time * -PI / 2.);\n\n    // A thick walled clifford torus intersected with a sphere\n\n    float d = fTorus(p4);\n    d = abs(d);\n    d -= .2;\n    d = fixDistance(d, k);\n    d = smax(d, length(p) - 1.85, .2);\n\n    return d;\n}\n\n\n// --------------------------------------------------------\n// Rendering\n// --------------------------------------------------------\n\nmat3 calcLookAtMatrix(vec3 ro, vec3 ta, vec3 up) {\n    vec3 ww = normalize(ta - ro);\n    vec3 uu = normalize(cross(ww,up));\n    vec3 vv = normalize(cross(uu,ww));\n    return mat3(uu, vv, ww);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n\n    time = mod(iTime / 12., 1.);\n\n    vec3 camPos = vec3(1.8, 5.5, -5.5) * 1.75;\n    vec3 camTar = vec3(.0,0,.0);\n    vec3 camUp = vec3(-1,0,-1.5);\n    mat3 camMat = calcLookAtMatrix(camPos, camTar, camUp);\n    float focalLength = 5.;\n    vec2 p = (-iResolution.xy + 2. * gl_FragCoord.xy) / iResolution.y;\n\n    vec3 rayDirection = normalize(camMat * vec3(p, focalLength));\n    vec3 rayPosition = camPos;\n    float rayLength = 0.;\n\n    float distance = 0.4;\n    vec3 color = vec3(0);\n\n    vec3 c;\n\n    // Keep iteration count too low to pass through entire model,\n    // giving the effect of fogged glass\n    const float ITER = 1244.;\n    const float FUDGE_FACTORR = .8;\n    const float INTERSECTION_PRECISION = .001;\n    const float MAX_DIST = 20.;\n\n    for (float i = 0.; i < ITER; i++) {\n\n        // Step a little slower so we can accumilate glow\n        rayLength += max(INTERSECTION_PRECISION, abs(distance) * FUDGE_FACTORR);\n        rayPosition = camPos + rayDirection * rayLength;\n        distance = map(rayPosition);\n\n        // Add a lot of light when we're really close to the surface\n        c = vec3(max(0., .01 - abs(distance)) * .5);\n        c *= vec3(2.4,2.1,1.7); // blue green tint\n\n        // Accumilate some purple glow for every step\n        c += vec3(.6,.25,.7) * FUDGE_FACTORR / 160.;\n        c *= smoothstep(20., 7., length(rayPosition));\n\n        // Fade out further away from the camera\n        float rl = smoothstep(MAX_DIST, .1, rayLength);\n        c *= rl;\n\n        // Vary colour as we move through space\n        c *= spectrum(rl * 7. - .6);\n\n        color += c;\n\n        if (rayLength > MAX_DIST) {\n            break;\n        }\n    }\n\n    // Tonemapping and gamma\n    color = pow(color, vec3(1. / 1.8)) * 2.5;\n    color = pow(color, vec3(2.)) * 3.;\n    color = pow(color, vec3(1. / 2.2));\n\n    fragColor = vec4(color, 1);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Wlf3Wn.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[264, 264, 296, 296, 341], [343, 343, 382, 382, 474], [669, 669, 737, 737, 780], [782, 782, 806, 806, 904], [1081, 1081, 1129, 1129, 1187], [1189, 1189, 1212, 1212, 1377], [1379, 1379, 1416, 1416, 1569], [1584, 1584, 1603, 1603, 1925], [2062, 2062, 2112, 2112, 2255], [2257, 2257, 2312, 2312, 4166]], "test": "ok"}
{"id": "wlf3z8", "name": "simple metaball test", "author": "mxr233", "description": "a simple metaball test.", "tags": ["metaball"], "likes": 1, "viewed": 72, "published": "Public", "date": "1555601917", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float circle(vec2 uv,float r)\n{\n    return r/length(uv);\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (2.*fragCoord-iResolution.xy)/iResolution.y;\n\tvec2 mouseUV=(2.*iMouse.xy-iResolution.xy)/iResolution.y;\n    // Time varying pixel color\n    vec2 s[3];\n    s[0]=mouseUV;\n\ts[1]=vec2(-1,0)*sin(iTime*0.5);\n    s[2]=vec2(1,0)*sin(iTime*0.5);\n    float t=smoothstep(0.2,0.7,circle(uv-s[1],0.1));\n    t+=smoothstep(0.2,0.7,circle(uv-s[0],0.1));\n    t+=smoothstep(0.2,0.7,circle(uv-s[2],0.1));\n    // Output to screen\n    fragColor = vec4(t*sin(iTime*2.),t,t*cos(iTime),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wlf3z8.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 31, 31, 58], [59, 59, 116, 166, 650]], "test": "ok"}
{"id": "Wlf3zn", "name": "spectrum reflections", "author": "johh", "description": "some gradient experiments", "tags": ["spectrum", "gradient"], "likes": 8, "viewed": 175, "published": "Public", "date": "1555422273", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec3 bluenoise( vec2 st ) {\n    return texture( iChannel0, st / iChannelResolution[0].xy ).rgb * 2. - 1.;\n}\n\n\nfloat gradient( in float x ) {\n\t\n    float t = iTime * 3.;\n    \n    float a = sin( t - x ) + cos( t * 3.39 - x * 2. ) + ( sin( t * 1.721 - x - 3842.18 )* .4);\n\ta *= .5;\n    \n    return a;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\n    vec2 uv = ( fragCoord -.5 * iResolution.xy ) / iResolution.y;\n    uv.x = mix( 1. - uv.x, uv.x, smoothstep( .3, .45, length( uv ) ) );\n    \n   \n    float shift = ( sin( iTime ) * .5 + .5 ) * .2 + .1;\n    float noise = bluenoise( .75 * fragCoord + 1337. * fract( iTime ) ).r * .2;\n\n\tvec3 c = vec3(\n    \tgradient( uv.x + noise - shift ),\n    \tgradient( uv.x + noise ),\n        gradient( uv.x + noise + shift )\n    );\n    \n    fragColor = vec4( c, 1.0 );\n}", "image_inputs": [{"id": "XsBSR3", "previewfilepath": "/media/ap/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Wlf3zn.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 27, 27, 107], [110, 110, 140, 140, 299], [301, 301, 358, 358, 816]], "test": "error"}
{"id": "WlfGRN", "name": "Study - Paintbrush Stroke", "author": "trevorleake", "description": "A first study in making paintbrush like strokes procedurally. Definitely room for progress. :) My first attempt at making an actually pretty thing. \n\nInspired entirely by user 104's Brush Experiments found here: https://www.shadertoy.com/view/ltj3Wc", "tags": ["noise", "brush"], "likes": 4, "viewed": 1069, "published": "Public", "date": "1555920671", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const float pi = 3.1415;\n\n\n//////////////////////\n// Helper Functions //\n//////////////////////\n\n// Returns 1 if the components of v are within [0, 1], 0 otherwise. \nfloat zeroToOne(vec2 v) { return v.x>=0. && v.x<=1. && v.y>=0. && v.y<=1. ? 1. : 0.; }\nfloat inRange(vec2 v, vec2 bl, vec2 tr) { return v.x>=bl.x && v.x<=tr.x && v.y>=bl.y && v.y<=tr.y ? 1. : 0.; }\n\n// Returns a rotation matrix which will rotate a vector clockwise by angle randians. \nmat2 rotate2d(float angle)\n{\n    return mat2(cos(angle), -sin(angle),\n                sin(angle), cos(angle));\n}\n\nfloat ellipse(vec2 uv, vec2 center, float semimajor, float semiminor)\n{\n    float theta = acos((uv.x-center.x)/semimajor);\n\tif(uv.y < center.y)\n        theta = 2.*pi - theta;\n\n    float x = center.x + semimajor*cos(theta);\n    float y = center.y + semiminor*sin(theta);\n\n    float val = pow(uv.x-center.x, 2.)/pow(semimajor, 2.) + pow(uv.y-center.y, 2.) / pow(semiminor, 2.);\n    return step(0., 1.-val);\n}\n\nfloat circle(vec2 uv, vec2 center, float radius) { return distance(uv, center) <= radius ? 1. : 0.;} \n\n\n/////////////////////\n// Noise Functions //\n/////////////////////\n\n// Simplex noise implemented by Inigo Quilez \n// https://www.shadertoy.com/view/Msf3WH\n\nvec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec2 mod289(vec2 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec3 permute(vec3 x) { return mod289(((x*34.0)+1.0)*x); }\n\nfloat simplexNoise(vec2 v) {\n    const vec4 C = vec4(0.211324865405187,  // (3.0-sqrt(3.0))/6.0\n                        0.366025403784439,  // 0.5*(sqrt(3.0)-1.0)\n                        -0.577350269189626,  // -1.0 + 2.0 * C.x\n                        0.024390243902439); // 1.0 / 41.0\n    vec2 i  = floor(v + dot(v, C.yy) );\n    vec2 x0 = v -   i + dot(i, C.xx);\n    vec2 i1;\n    i1 = (x0.x > x0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);\n    vec4 x12 = x0.xyxy + C.xxzz;\n    x12.xy -= i1;\n    i = mod289(i); // Avoid truncation effects in permutation\n    vec3 p = permute( permute( i.y + vec3(0.0, i1.y, 1.0 ))\n        + i.x + vec3(0.0, i1.x, 1.0 ));\n\n    vec3 m = max(0.5 - vec3(dot(x0,x0), dot(x12.xy,x12.xy), dot(x12.zw,x12.zw)), 0.0);\n    m = m*m ;\n    m = m*m ;\n    vec3 x = 2.0 * fract(p * C.www) - 1.0;\n    vec3 h = abs(x) - 0.5;\n    vec3 ox = floor(x + 0.5);\n    vec3 a0 = x - ox;\n    m *= 1.79284291400159 - 0.85373472095314 * ( a0*a0 + h*h );\n    vec3 g;\n    g.x  = a0.x  * x0.x  + h.x  * x0.y;\n    g.yz = a0.yz * x12.xz + h.yz * x12.yw;\n    return 130.0 * dot(m, g);\n}\n\nfloat positiveSimplexNoise(vec2 uv) {return abs(simplexNoise(uv));}\n\n\n\n// from \"Magic Fractal\" by dgreensp\n// https://www.shadertoy.com/view/4ljGDd\nfloat magicBox(vec3 p) {\n    const int MAGIC_BOX_ITERS = 13;\n    const float MAGIC_BOX_MAGIC = 0.55;\n    // The fractal lives in a 1x1x1 box with mirrors on all sides.\n    // Take p anywhere in space and calculate the corresponding position\n    // inside the box, 0<(x,y,z)<1\n    p = 1.0 - abs(1.0 - mod(p, 2.0));\n    \n    float lastLength = length(p);\n    float tot = 0.0;\n    // This is the fractal.  More iterations gives a more detailed\n    // fractal at the expense of more computation.\n    for (int i=0; i < MAGIC_BOX_ITERS; i++) {\n      // The number subtracted here is a \"magic\" paremeter that\n      // produces rather different fractals for different values.\n      p = abs(p)/(lastLength*lastLength) - MAGIC_BOX_MAGIC;\n      float newLength = length(p);\n      tot += abs(newLength-lastLength);\n      lastLength = newLength;\n    }\n\n    return tot;\n}\n\n\nfloat magicBox(vec2 uv){\n    // A random 3x3 unitary matrix, used to avoid artifacts from slicing the\n    // volume along the same axes as the fractal's bounding box.\n    const mat3 M = mat3(0.28862355854826727, 0.6997227302779844, 0.6535170557707412,\n                        0.06997493955670424, 0.6653237235314099, -0.7432683571499161,\n                        -0.9548821651308448, 0.26025457467376617, 0.14306504491456504);\n    vec3 p = 0.5*M*vec3(uv, 0.0);\n    return magicBox(p);\n}\n\n\n\n\n\n///////////////////////\n// Drawing Functions //\n///////////////////////\n\n\n// Returns the position of UV relative to the drawn line. Interval [0,1] is in the line.\nvec2 lineGeometry(vec2 uv, vec2 p1, vec2 p2, float lineWidth) \n{\n    // We'll grab the angle & length of the line\n    float lineAngle = atan(p1.x-p2.x, p1.y-p2.y);\n    float lineLength = distance(p1, p2);\n\n    // And find the rotation matrix which flattens it to the y-axis \n    mat2 rotMat = rotate2d(pi-lineAngle);\n\n    // Next, we'll describe a new line which lives on the y-axis & has the same length\n    vec2 pa = vec2(0);\t\t\t\t// Point A\n    vec2 pb = vec2(0, lineLength);\t// Point B\n\n    // Transform our uv the same as we have transformed the line\n\tuv -= p1;\n    uv = rotMat * uv;\n    \n    // Check if the point is in the line (rectangle)\n  \tfloat inWidthRange = abs(uv.x) < lineWidth/2. ? 1. : 0.;\n    float inHeightRange = (1.-step(max(pa.y, pb.y), uv.y)) * (step(min(pa.y, pb.y), uv.y));\n\n    vec2 bl = vec2(-lineWidth/2., 0);\n    vec2 tr = vec2(lineWidth/2., lineLength);\n\tvec2 uvLinePosition = vec2(uv/(tr-bl));\n        \n    return uvLinePosition;\n}\n\n\nfloat brushLine(vec2 uv, vec2 p1, vec2 p2, float lineWidth)\n{\n    // Find our position in the line as a vec2 in (0,0) to (1, 1) or beyond if out of line\n    vec2 uvLine = lineGeometry(uv, p1, p2, lineWidth);\n\n    // inStroke is in (0, 1] if the pixel is in, 0 if not\n    float inStroke = zeroToOne(uvLine);\n\t\n    // Source a coordinate we can use in all noise functions as a sampling point\n    vec2 source = uvLine + vec2(0, iTime);\n\n    // We'll add texture that looks like bristles by squishing and stretching our simplex noise in nice ways.\n\tfloat tex = 0.;\n    \n    \n    /* \tLittle Thin Bristles */\n    float strokeFade =  smoothstep(0., .5, uvLine.y) - smoothstep(.9, 1., uvLine.y);\n    float lilBristlesTexture = clamp(\n      \tsimplexNoise(source * vec2(10., .1))\t// Simplex noise being squished vertically and stretch horizontally\n     \t+ simplexNoise(source * vec2(15., 1.))  // Simplex noise being squished a bit more, and moving faster horizontally\n    , 0., 1.);\n    tex += inStroke * strokeFade * lilBristlesTexture;\n\n    \n    /* Spackle */\n    /*\n    float spackleFade = smoothstep(.2, .4, uvLine.y) - smoothstep(.95, 1., uvLine.y);    \n\tspackleFade *= (smoothstep(-.2, 0., uvLine.x) - smoothstep(1., 1.2, uvLine.x));\n    float spackleTexture = clamp(\n        smoothstep(43., 45., magicBox(source))\n\t,0.,1.);\n  \ttex +=  spackleFade * spackleTexture;   \n\t*/    \n    \n    \n    /* Thick Bristles */\n    float thickBristlesTexture = clamp(\n      \t1.3*smoothstep(.3, 1., uvLine.y) // This creates a full stroke between 30% and 100% through the line\n        - 0.3 * positiveSimplexNoise(source * vec2(10., .2)) // Partially scrape away a few streaks. \n    , 0., 1.);    \n    float thickBristleFade = smoothstep(0., 1., uvLine.y) - smoothstep(.97, 1., uvLine.y);\n    tex += inStroke * thickBristleFade * thickBristlesTexture;\n\n    \n    tex = clamp(tex, 0., 1.);\n    return tex;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/min(iResolution.x, iResolution.y);\n    \n    // Centering\n    uv -= vec2(.5);\n\n    // Add wibbliness to the line for +1 to beauty.\n    uv.y += sin(simplexNoise(uv+vec2(iTime,0)))*.02;\n    \n    // Points for the line to go between\n    vec2 p1 = vec2(-.6, .0);\n    vec2 p2 = vec2(.6, .0);\n\n    // The return value is 0 if the pixel is not in the brush texture and up to 1 if it is.\n    float tex = brushLine(uv, p1, p2, .1);    \n    \n    // Have a little fun with the brush color\n    float t = iTime/6.;\n    vec3 brushColor = normalize(vec3(.3+sin(2.*t)*.3, .1+sin(t)*.1, .1+cos(t)*.1));\n    \n    // Output to screen\n    fragColor = vec4(tex * brushColor, 1.);\n}\n\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WlfGRN.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[97, 166, 191, 191, 252], [253, 253, 294, 294, 363], [365, 451, 479, 479, 563], [565, 565, 636, 636, 971], [973, 973, 1023, 1023, 1073], [1232, 1232, 1253, 1253, 1300], [1301, 1301, 1322, 1322, 1369], [1370, 1370, 1392, 1392, 1427], [1429, 1429, 1457, 1457, 2505], [2507, 2507, 2544, 2544, 2574], [2578, 2655, 2679, 2679, 3512], [3515, 3515, 3539, 3681, 4000], [4080, 4169, 4233, 4282, 5129], [5132, 5132, 5193, 5284, 7017], [7020, 7020, 7077, 7127, 7811]], "test": "ok"}
{"id": "wlfGWn", "name": "Bouge ton boule sur le scanner", "author": "totetmatt", "description": " Tweaking the Art of Code tutorial to understand more the simple 3D ray on sphere. Got this \"shake your booty on your office printer scanner\" shader .\n\nSlightly Shameful.", "tags": ["shakeshakeshake"], "likes": 1, "viewed": 302, "published": "Public API", "date": "1556472258", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\nfloat remap01(float a,float b,float t)\n{\n    return (t-a)/(b-a);\n}\n\nfloat sphe(vec3 ro,vec3 rd,vec4 s) \n{\n    float t = dot(s.xyz-ro,rd);\n    vec3 p = ro + rd*t;\n    float y = length(s.xyz-p);  \n    if(y<s.w) {\n        float x = sqrt(s.w*s.w - y*y);\n        float t1 = t-x ;\n        float t2= t+x  ;\n        float c = remap01(s.z,s.z-s.w,t1);\n        return c;\n    }\n    return 0.;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  \n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\n   vec3 ro = vec3(0.,0.,0.);\n   vec3 rd= normalize(vec3(uv.x,uv.y,1.));\n  \n    \n    float s1 = sphe(ro,rd,vec4(.5 + sin(iTime*5.),0.,7.+ cos(iTime*5.),1.));\n    float s2 = sphe(ro,rd,vec4(-.5+ sin(iTime*5.),0.,7.+ cos(iTime*5.),1.))  ;\n    float s3=0.;\n    float s4=0.;\n    //PEGI18   :s3 = sphe(ro,rd,vec4(sin(iTime*5.),-.6,6.8+ cos(iTime*5.),.3))  ;\n    //FSK18 : s4 = sphe(ro,rd,vec4(sin(iTime*5.),0.,6.8+ cos(iTime*5.),.2))  ;\n\n    float d = max(max(s1,s2),max(s3,s4));\n    \n    vec3 col = vec3(d);\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wlfGWn.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 1, 41, 41, 67], [69, 69, 106, 106, 384], [385, 385, 442, 442, 1041]], "test": "ok"}
{"id": "Wll3DM", "name": "Fourier series demo", "author": "tpfto", "description": "Demonstration of approximating a periodic function with a finite Fourier series. The green curve is the function being approximated by its Fourier series, which is plotted as an orange curve.", "tags": ["2d", "math", "plot", "fourier"], "likes": 4, "viewed": 252, "published": "Public", "date": "1556537114", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Demonstrate the approximation of a function with a finite Fourier series\n\n// plotter forked from https://www.shadertoy.com/view/4tB3WV\n\n// some constants\n#define PI 3.14159265359\n\n#define BLACK vec3(0.0)\n#define WHITE vec3(1.0)\n\n// dark and light colors from Solarized (https://ethanschoonover.com/solarized/)\n#define DARK vec3(0., 0.169, 0.212)\n#define LIGHT vec3(0.992, 0.965, 0.89)\n#define GRAY vec3(0.396, 0.482, 0.514)\n\n// Solarized \"accent colors\"\n#define ORANGE vec3(0.796, 0.294, 0.086)\n#define GREEN vec3(0.522, 0.6, 0.)\n\n// comment out to switch to light mode\n#define DARK_MODE\n\n// XY range of the display.\n#define DISP_SCALE 9.0 \n\n// Line thickness (in pixels).\n#define LINE_SIZE 2.0\n\n// Tick thickness (in pixels).\n#define TICK_SIZE 1.0\n\n// Tick length.\n#define TICK_LENGTH 0.025 * DISP_SCALE\n\n// Grid line & axis thickness (in pixels).\n#define GRID_LINE_SIZE 1.0\n#define GRID_AXIS_SIZE 2.0\n\n// Number of grid lines per unit.\n#define GRID_LINES 1.0\n\nconst vec2 GRADH = vec2(0.01, 0);\n\n// central difference\n#define GRAD(f, p) (0.5 * vec2(f(p - GRADH.xy) - f(p + GRADH.xy), f(p - GRADH.yx) - f(p + GRADH.yx)) / GRADH.xx)\n\n// PLOT(Function, Color, Destination, Screen Position)\n#define PLOT(f, c, d, p) d = mix(c, d, smoothstep(0.0, (LINE_SIZE / iResolution.y * DISP_SCALE), abs(f(p) / length(GRAD(f, p)))))\n\n// maximum supported series terms; increase for difficult examples, but beware of the Gibbs phenomenon\n#define MAX_FOURIER_ORDER 12\n\n// number of terms of Fourier series; 8 terms gives a good approximation for this example\n#define TERMS 4\n\n// squaring\n#define sqr(a) ((a) * (a))\n\n// Example function from Neuwirth; https://doi.org/10.2307/2690622\n\nfloat Wave(vec2 p)\n{\n\tfloat q = 0.5;\n\t\n    float y = sin(p.x)/(1.0 + sqr(q) - 2.0 * q * cos(p.x));\n\t\n\treturn p.y - y;\n}\n\n// Fourier coefficients of example function\n\nfloat ck(int k)\n{\n    float q = 0.5;\n    int ord = 1 + int(mod(0.05 * iTime + 0.5, 8.0));\n\n    return ((1 <= k && k <= ord) ? (pow(q, float(k) - 1.0)) : (0.0));\n}\n\n// Goertzel-Reinsch algorithm for summing trigonometric (Fourier) series;\n// pp. 90-91 of Bulirsch and Stoer, Introduction to Numerical Analysis 3rd ed.\n\nfloat fsum(bool cc, float x)\n{\n    float cx = cos(x);\n    float h = 0.0, u = 0.0;\n    \n    float sg = (cx > 0.0) ? 1.0 : -1.0;\n    float lm = 4.0 * ((sg > 0.0) ? (-sqr(sin(0.5 * x))) : (sqr(cos(0.5 * x))));\n    \n    for (int k = MAX_FOURIER_ORDER; k >= 0; k--)\n    {\n        u = h + sg * u;\n        h = ck(k) + sg * h + lm * u;\n    }\n    \n    return ((cc) ? (h - 0.5 * lm * u) : (u * sin(x)));\n}\n\nfloat Fourier(vec2 p)\n{\t\n\treturn p.y - fsum(false, p.x);\n}\n\n#define MAKETICK(c) (clamp(1.0 + 0.5 * TICK_LENGTH - abs(c), 0.0, 1.0))\n\nfloat grid(vec2 p, bool showAxes, bool showTicks, bool showGrid)\n{\n\tvec2 uv = mod(p, 1.0 / GRID_LINES);\n\tfloat halfScale = 0.5 / GRID_LINES;\n    \n    float grid = 1.0, tick = 1.0, axis = 1.0;\n\t\n    if (showTicks) {\n\tfloat tickRad = (TICK_SIZE / iResolution.y) * DISP_SCALE;\n\ttick = halfScale - max( MAKETICK(p.y) * abs(uv.x - halfScale), MAKETICK(p.x) * abs(uv.y - halfScale));\n\ttick = smoothstep(0.0, tickRad, tick);\n    }\n    \n    if (showGrid) {\n\tfloat gridRad = (GRID_LINE_SIZE / iResolution.y) * DISP_SCALE;\n\tgrid = halfScale - max(abs(uv.x - halfScale), abs(uv.y - halfScale));\n\tgrid = smoothstep(0.0, gridRad, grid);\n    }\n\t\n    if (showAxes) {\n\tfloat axisRad = (GRID_AXIS_SIZE / iResolution.y) * DISP_SCALE;\n\taxis = min(abs(p.x), abs(p.y));\n\taxis = smoothstep(axisRad - 0.05, axisRad, axis);\n    }\n\t\n\treturn min(tick, min(grid, axis));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 aspect = iResolution.xy / iResolution.y;\n\tvec2 uv = ( fragCoord.xy / iResolution.y ) - 0.5 * aspect;\n\tuv *= DISP_SCALE;\n\t\n    vec3 col = WHITE;\n\n    // set up axes and ticks\n    #ifdef DARK_MODE\n    col = mix(GRAY, DARK, grid(uv, true, true, false));\n    #else\n    col = mix(GRAY, LIGHT, grid(uv, true, true, false));\n    #endif\n    \n    // offset the curves every few seconds\n    float offset = 0.25 * DISP_SCALE * clamp(2.0 * cos(0.1 * PI * iTime), 0.0, 1.0);\n    \n    PLOT(Wave, GREEN, col, uv + vec2(iTime, -offset));\n    \n    PLOT(Fourier, ORANGE, col, uv + vec2(iTime, offset));\n\t\n\tfragColor = vec4( col, 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Wll3DM.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1670, 1670, 1690, 1690, 1789], [1836, 1836, 1853, 1853, 1998], [2154, 2154, 2184, 2184, 2549], [2551, 2551, 2574, 2574, 2609], [2684, 2684, 2750, 2750, 3529], [3531, 3531, 3588, 3588, 4214]], "test": "timeout"}
{"id": "Wll3z8", "name": "Alternative Approach", "author": "vox", "description": "In response to: https://www.shadertoy.com/view/wtfGR8", "tags": ["alternative", "approach"], "likes": 4, "viewed": 326, "published": "Public API", "date": "1555628875", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//Do not redistribute.\n\n//-----------------CONSTANTS MACROS-----------------\n\n#define PI 3.14159265359\n#define E 2.7182818284\n#define GR 1.61803398875\n\n//-----------------UTILITY MACROS-----------------\n\n#define time ((sin(float(__LINE__))*GR/2.0/PI+GR/PI)*iTime+100.0)\n#define saw(x) (acos(cos(x))/PI)\n#define flux(x) (vec3(cos(x),cos(4.0*PI/3.0+x),cos(2.0*PI/3.0+x))*.5+.5)\n#define rotatePoint(p,n,theta) (p*cos(theta)+cross(n,p)*sin(theta)+n*dot(p,n) *(1.0-cos(theta)))\n#define carpet_floor(x) (floor(x)+pow((fract(x)), 10.))\n\nvoid ray_ray(in vec3 eye, in vec3 ray1, in vec3 p1, in vec3 ray2, out float t1, out float t2){\n    \n\n    float a = dot(ray1,ray1);\n    float b = dot(ray1,ray2);\n    float c = dot(ray2,ray2);\n    float d = dot(ray1,eye-p1);\n    float e = dot(eye-p1,ray2);\n\n    t1 = (b*e-c*d)/(a*c-b*b);\n    t2 = (a*e-b*d)/(a*c-b*b);\n}\n\n\n#define iTime (iTime/GR)\n\n#define PI 3.14159265359\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy*2.0-1.0;\n    uv.x *= iResolution.x/iResolution.y;\n    \n\t//vec3 eye = vec3(0.0, 0.0, 3.0);\n\tvec3 eye = vec3(cos(iTime), sin(iTime*.5), sin(iTime))*2.0;\n    vec3 look = vec3(0.0, 0.0, 0.0);\n    vec3 up = vec3(0.0, 1.0, 0.0);\n    vec3 foward = normalize(look-eye);\n    vec3 right = normalize(cross(foward, up));\n    up = normalize(cross(right, foward));\n    vec3 ray = normalize(foward+uv.x*right+uv.y*up);\n    \n    fragColor = vec4(0.0);\n    \n \tconst float outerCount = 4.0;\n \tconst float innerCount = 4.0;\n        \n    float map = 0.0;\n    float sum = 0.0;\n    \n    float min_scale = 1./GR;\n    float max_scale = 1.;\n    float scale_steps = 4.;\n   \tfor(float s = 0.; s < scale_steps; s+=1.)\n    {\n        float scale_iteration = (s/scale_steps);\n        float scalar = min_scale+scale_iteration*(max_scale-sin(time*scale_iteration)*min_scale);\n    for(float i = 0.0; i < outerCount; i+=1.0)\n    {\n        \n        float theta1 = i/outerCount*PI;\n        \n        for(float j = 0.0; j < innerCount; j+=1.0)\n        {\n            \n            float theta2 = j/innerCount*PI*2.;\n\n            \n            float omega1 = theta1+PI/2.*(carpet_floor(scale_iteration*time));\n            float omega2 = theta2+PI*carpet_floor(scale_iteration*time)\n                \t\t\t\t\t\t+carpet_floor(time)*PI;//*sign(cos(i*PI));\n            \n       \t \tvec3 p1 = vec3(cos(omega1)*sin(omega2),\n                           sin(omega1)*sin(omega2),\n                           cos(omega2))*scalar;\n                           \n            omega2 += PI/outerCount*2.;\n       \t \tvec3 p2 = vec3(cos(omega1)*sin(omega2),\n                           sin(omega1)*sin(omega2),\n                           cos(omega2))*scalar;\n            \n            omega2 -= PI/outerCount*2.;\n            omega1 += PI/outerCount*2.;\n       \t \tvec3 p3 = vec3(cos(omega1)*sin(omega2),\n                           sin(omega1)*sin(omega2),\n                           cos(omega2))*scalar;\n            \n            float t1;\n            float t2;\n            vec3 ray2 = normalize(p2-p1);\n            \n            ray_ray(eye, ray, p1, ray2, t1, t2);\n            \n            float dist = length((eye+ray*t1)-(p1+ray2*t2));\n            \n            float lineWidth = 5.0/min(iResolution.x, iResolution.y);\n            \n            float lineLength = length(p2-p1);\n            \n            \n                float sides = (1.0-smoothstep(0.0, lineWidth, dist));\n                float ends = (1.0-smoothstep(1.-lineWidth, 1., (t2)/lineLength))*(1.0-smoothstep(1.-lineWidth, 1., 1.-(t2)/lineLength));\n                float line = sides*ends;\n                \n                map += line*(1.0+i/innerCount+j/outerCount)/2.0;\n                sum += 1.0*line;\n            \n            ray2 = normalize(p3-p1);\n            \n            ray_ray(eye, ray, p1, ray2, t1, t2);\n            \n            dist = length((eye+ray*t1)-(p1+ray2*t2));\n            \n            lineLength = length(p3-p1);\n            \n            \n                sides = (1.0-smoothstep(0.0, lineWidth, dist));\n                ends = (1.0-smoothstep(1.-lineWidth, 1., (t2)/lineLength))*(1.0-smoothstep(1.-lineWidth, 1., 1.-(t2)/lineLength));\n                line = sides*ends;\n                \n                map += line*(1.0+i/innerCount+j/outerCount)/2.0;\n                sum += 1.0*line;\n        }\n    }\n    }\n\tfragColor = vec4(flux(PI*map/sum+time), 1.0)+clamp(sum-1., 0.0, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Wll3z8.jpg", "access": "shaders20k", "license": "proprietary-license", "functions": [[530, 530, 624, 624, 847], [902, 902, 959, 959, 4390]], "test": "error"}
{"id": "wllGD4", "name": "Elliptic Nome Domain Coloring", "author": "tpfto", "description": "Domain coloring of the elliptic nome q(m), a function that can be expressed in terms of the complete elliptic integral of the first kind K(m).", "tags": ["2d", "math", "domaincoloring", "specialfunctions"], "likes": 3, "viewed": 171, "published": "Public", "date": "1556469930", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// The MIT License\n// Copyright © 2019 J. M.\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// Basic domain coloring plot (https://en.wikipedia.org/wiki/Domain_coloring)\n// of the elliptic nome w = q(z) (https://en.wikipedia.org/wiki/Nome_(mathematics))\n\n#define PI 3.14159265359\n#define SCALE 6.0 // plot scale\n#define SPACING 0.0625 // grid line spacing\n\n// from Fabrice Neyret, \n#define cmul(A,B) ( mat2( A, -(A).y, (A).x ) * (B) )\n#define cinv(Z) ( vec2( (Z).x, -(Z).y ) / dot(Z, Z) ) \n#define cdiv(A,B) cmul( A, cinv(B) )\n\n// Schlick bias function, from http://dept-info.labri.u-bordeaux.fr/~schlick/DOC/gem2.ps.gz\nfloat bias( float a, float x )\n{\n    return x/((1.0/a - 2.0) * (1.0 - x) + 1.0);\n}\n\n// biased sawtooth\nfloat my_saw( float x, float p )\n{\n    float xs = mod(x, 1.0);\n    float xh = clamp(xs, 0.0, p);\n    return 0.5 + 0.5 * bias(0.95, xh) * (1.0 - smoothstep(p, 1.0, xs));\n}\n\n// modified version of Inigo Quilez's method at https://www.shadertoy.com/view/MsS3Wc\n// using \"rational smoothstep\" from https://tpfto.wordpress.com/2019/03/28/on-a-rational-variant-of-smoothstep/\nvec3 smooth_hue( float h )\n{\n    vec3 rgb = clamp( abs(mod(6.0 * h + vec3(0.0, 4.0, 2.0), 6.0) - 3.0) - 1.0, 0.0, 1.0);\n    return rgb * rgb * rgb/(1.0 - 3.0 * rgb * (1.0 - rgb));\n}\n\n// modified DLMF coloring, adapted from https://www.shadertoy.com/view/WtXGWN\nvec3 smooth_dlmf( float h )\n{\n    vec3 rgb = clamp( vec3(1., -1., -1.) * abs((vec3(8., 4., 8.) * mod(h, 1.0) - vec3(4.5, 1.5, 5.5))) + vec3(-1.5, 1.5, 2.5), 0.0, 1.0 );\n\treturn rgb * rgb * rgb/(1.0 - 3.0 * rgb * (1.0 - rgb));\n}\n\n// complex square root, from Numerical Recipes\n\nvec2 sqrtz( in vec2 z )\n{\n\tfloat ar = abs(z.x), ai = abs(z.y);\n\n    float w = (dot(z, z) == 0.0) ? 0.0 : ( (ar >= ai) ? (sqrt(ar) * sqrt(0.5 * (1.0 + sqrt(1.0 + (ai * ai)/(ar * ar))))) : (sqrt(ai) * sqrt(0.5 * (ar/ai + sqrt(1.0 + (ar * ar)/(ai * ai))))));\n    \n    return ((w == 0.0) ? vec2(0.0) : ((z.x >= 0.0 ? vec2(w, 0.5 * z.y/w) : vec2(0.5*ai/w, ((z.y >= 0.0) ? w : -w)))));\n}\n\n// complex exponential\n\nvec2 expz( in vec2 z )\n{\n\treturn exp(z.x) * vec2(cos(z.y), sin(z.y));\n}\n\n// complete elliptic integral K(m) via arithmetic-geometric mean (AGM) iteration \n\nvec2 ellK( in vec2 z )\n{\n    vec2 agA = vec2(1.0, 0.0), agB = sqrtz(agA - z);\n    vec2 tmp = vec2(0.0), h = tmp;\n\t\n    for( int i = 0; i <= 9; i++ )\n    {\n        tmp = sqrtz(cmul(agA, agB));\n        h = 0.5 * (agB - agA);\n        agA += h;\n        agB = tmp;\n        if (length(h) < 1.0e-6) break;\n    }\n\t\n    return (PI * cinv(agA + agB));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 aspect = iResolution.xy / iResolution.y;\n    vec2 z = ( fragCoord.xy / iResolution.y ) - 0.5 * aspect;\n    z *= SCALE;\n    \n    vec2 w = expz(-PI * cdiv(ellK(vec2(1.0, 0.0) - z), ellK(z))); // elliptic nome q(m)\n    // vec2 w = ellK(z); // uncomment if you just want K(m)\n    float ph = atan(w.y, w.x);\n    float lm = log(0.0001 + length(w));\n    \n    vec3 c = vec3(1.0);\n    c = smooth_dlmf(0.5 * (ph / PI));\n    // uncomment for HSV version \n    // c = smooth_hue(0.5 * (ph / PI));\n\n    c *= mix(1.0, my_saw((0.5 * (lm/PI))/SPACING, 0.95) * my_saw((0.5 * (ph / PI))/SPACING, 0.95), 0.5 + 0.5 * cos(iTime));\n    fragColor = vec4(c, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wllGD4.jpg", "access": "shaders20k", "license": "mit", "functions": [[1507, 1599, 1631, 1631, 1681], [1683, 1702, 1736, 1736, 1872], [1874, 2072, 2100, 2100, 2253], [2255, 2333, 2362, 2362, 2560], [2610, 2610, 2635, 2635, 2991], [3017, 3017, 3041, 3041, 3088], [3173, 3173, 3197, 3197, 3516], [3518, 3518, 3575, 3575, 4225]], "test": "ok"}
{"id": "WllGD7", "name": "Recursive__", "author": "s_das", "description": "  ", "tags": ["raytracing", "recursive", "red", "shaders", "pattern"], "likes": 1, "viewed": 260, "published": "Public API", "date": "1556544138", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n \n\nvoid mainImage(out vec4 FragColor, in vec2 FragCoord){\n    vec2 uv = FragCoord.xy/iResolution.xy;\n    uv = 2.*uv - 1.;\n    uv.x *= iResolution.x / iResolution.y;\n    \n\n    float da = iTime/(10.);\n    vec2 pts = vec2(sin(da*2.), cos(da*2.));\n\n    float d = length(cos(  abs((abs(uv)+atan(da))*pts))*sin(atan(abs(uv))));\n\n    d = atan(d) - cos(da+d*d)*sin(da - d*d);\n    d -= atan(cos(da)*abs(  fract(d*d)-da) + 0.5);\n\n    float fill = step(tan(fract(abs(d)-0.5)*da),0.2);\n \n \n    vec3 col = vec3(fill);\n\n    col += vec3(0., 0., 1.);\n    col *= vec3(1., 0., 0.2);\n    FragColor = vec4(col, 1.);\n\tda += uv.x;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WllGD7.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[4, 4, 58, 58, 611]], "test": "ok"}
{"id": "WllGR4", "name": "Julia Sets for increasing powers", "author": "Tezza48", "description": "Having a little fun with complex numbers :D", "tags": ["fractal", "julia", "mandelbrot", "power"], "likes": 2, "viewed": 93, "published": "Public", "date": "1555756016", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define ITERATIONS 20.0\n#define POWER 3\n\n#define JULIA\n\n#define SMOOTHFRACT\n\nvec2 cSquare(vec2 c)\n{\n    return vec2(c.x * c.x - c.y * c.y, 2.0 * c.x * c.y);\n}\n\nvec2 cMul(vec2 a, vec2 b)\n{\n \treturn vec2(a.x * b.x - a.y * b.y, a.y * b.x + a.x * b.y);   \n}\n\nvec2 cPow(vec2 c, int p)\n{\n\tvec2 res = c;\n \tfor (int i = 1; i < p; i++)\n    {\n    \tres = cMul(res, c);\n    }\n    return res;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord/iResolution.xy * 2.0) - 1.0;\n    uv.y /= iResolution.x / iResolution.y;\n\n    #ifdef JULIA\n    vec2 z = uv * 2.0;\n    vec2 c = vec2(sin(iTime * 0.5) * 0.8, cos((iTime * 0.1 + sin(iTime * 0.21)) * 0.5));\n    #else\n    vec2 z = vec2(0.0);\n    vec2 c = (uv * 2.5);\n    #endif\n    \n    float i;\n    for (i = 0.0; i < ITERATIONS; i++)\n    {\n        z = cPow(z, POWER) + c;\n        if(dot(z, z) > 4.0)\n            break;\n    }\n    \n    #ifdef SMOOTHFRACT\n    float log2=0.69314718056;\n    float L = log(dot(z, z))/2.0;\n    float nu = log(L/log2)/log2;\n    i+=1.0-nu;\n    #endif\n    \n    float dist = float(i) / 10.0;\n    \n    fragColor = vec4(sin(dist * 2.0));\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WllGR4.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[77, 77, 99, 99, 158], [160, 160, 187, 187, 253], [255, 255, 281, 281, 381], [383, 383, 440, 490, 1171]], "test": "ok"}
{"id": "WllGRn", "name": "Rising bubbles", "author": "avin", "description": "simple circles demo", "tags": ["circles", "simple", "learn"], "likes": 21, "viewed": 689, "published": "Public API", "date": "1555498534", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define SIZE 20.\n#define BLACK_COL vec3(32,43,51)/255.\n#define WHITE_COL vec3(235,241,245)/255.\n\n// Get random value\nfloat rand(vec2 co) { \n    return fract(sin(dot(co.xy , vec2(12.9898, 78.233))) * 43758.5453);\n} \n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{       \n    vec2 uv = fragCoord.xy/iResolution.y;\n    float smf = 1./(iResolution.y) * SIZE * 2.; // smooth factor\n    \n    vec2 ruv = uv*SIZE;    \n    vec2 id = ceil(ruv);       \n        \n    ruv.y -= iTime*2. * (rand(vec2(id.x))*0.5+.5); // move up\n    ruv.y += ceil(mod(id.x, 2.))*0.3 * iTime; // every 2nd column always move faster \n    vec2 guv = fract(ruv) - 0.5; // ceneterize guv   \n    \n    ruv = ceil(ruv);    \n    float g = length(guv);\n    \n    float v = rand(ruv)*0.5; // random bubble size     \n    v *= step(0.1, v); // remove too small bubbles\n    float m = smoothstep(v,v-smf, g);\n    v*=.8; // bubble inner empty space\n    m -= smoothstep(v,v-smf, g);\n    \n    vec3 col = mix(BLACK_COL, WHITE_COL, m); // final color\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WllGRn.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[97, 117, 138, 138, 213], [216, 216, 273, 273, 1045]], "test": "ok"}
{"id": "wllGzr", "name": "Recursive Noise Experiment", "author": "ompuco", "description": "trying something with simplex noise in a loop feeding itself data for more seemingly random, organic values.", "tags": ["noise"], "likes": 7, "viewed": 717, "published": "Public API", "date": "1555541583", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float hash( float n )\n\t\t\t{\n\t\t\t    return fract(sin(n)*43758.5453);\n\t\t\t}\n\n\t\t\tfloat noise( vec3 x )\n\t\t\t{\n\t\t\t    // The noise function returns a value in the range -1.0f -> 1.0f\n\n\t\t\t    vec3 p = floor(x);\n\t\t\t    vec3 f = fract(x);\n\n\t\t\t    f       = f*f*(3.0-2.0*f);\n\t\t\t    float n = p.x + p.y*57.0 + 113.0*p.z;\n\n\t\t\t    return mix(mix(mix( hash(n+0.0), hash(n+1.0),f.x),\n\t\t\t                   mix( hash(n+57.0), hash(n+58.0),f.x),f.y),\n\t\t\t               mix(mix( hash(n+113.0), hash(n+114.0),f.x),\n\t\t\t                   mix( hash(n+170.0), hash(n+171.0),f.x),f.y),f.z)-.5;\n\t\t\t}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    \n    vec3 t = (float(iFrame)*vec3(1.0,2.0,3.0)/1.0)/1000.0;//+iMouse.xyz/1000.0;\n\n    \n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    uv=uv/4.0+.5;\n    uv-=iMouse.xy/iResolution.xy/4.0;\n\n    vec3 col = vec3(0.0);\n    \n    \n    \n    for(int i = 0; i < 16; i++){\n        float i2 = float(i)*1.0;\n\t\t\t\t\tcol.r+=noise(uv.xyy*(12.0+i2)+col.rgb+t*sign(sin(i2/3.0)));\n\t\t\t\t\tcol.g+=noise(uv.xyx*(12.0+i2)+col.rgb+t*sign(sin(i2/3.0)));\n\t\t\t\t\tcol.b+=noise(uv.yyx*(12.0+i2)+col.rgb+t*sign(sin(i2/3.0)));\n\t\t\t\t}\n\t\t\t\t\n\n\t\t\t\tfor(int i = 0; i < 16; i++){\n                    float i2 = float(i)*1.0;\n\t\t\t\t\tcol.r+=noise(uv.xyy*(32.0)+col.rgb+t*sign(sin(i2/3.0)));\n\t\t\t\t\tcol.g+=noise(uv.xyx*(32.0)+col.rgb+t*sign(sin(i2/3.0)));\n\t\t\t\t\tcol.b+=noise(uv.yyx*(32.0)+col.rgb+t*sign(sin(i2/3.0)));\n\t\t\t\t}\n\t\t\t\tcol.rgb/=32.0;\n\t\t\t\tcol.rgb=mix(col.rgb,normalize(col.rgb)*2.0,1.0);\n\t\t\t\tcol.rgb+=.3;\n    \n    \n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wllGzr.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 26, 26, 71], [76, 76, 102, 174, 573]], "test": "ok"}
{"id": "wls3Wr", "name": "Hypnotical", "author": "janetdaetton", "description": "My second attempt. :)", "tags": ["circle", "hypno"], "likes": 1, "viewed": 260, "published": "Public API", "date": "1556119034", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n\n\nfloat wave(vec2 xy, float wavelength, float speed){\n    float x = xy.x;\n    float y = xy.y;\n    \n    return sin(sqrt(x*x + y*y)/wavelength - iTime*speed);\n}\nvec4 view(float x, float y, float z){\n    return vec4((vec3(x,y,z)+1.)/2., 1.);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 xy = (4.*fragCoord.xy - iResolution.xy)/50.;\n    vec2 x = vec2(0,0);\n    vec2 y = vec2(1,1);\n    \n    float a = wave(xy - x, 0.2, 1.);\n    float b = wave(xy + x, 0.5, 1.);\n    \n\tfragColor = view(0.,0.,a+b);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wls3Wr.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[3, 3, 54, 54, 159], [160, 160, 197, 197, 241], [243, 243, 300, 300, 515]], "test": "ok"}
{"id": "Wls3z8", "name": "Rectangular", "author": "johnyboy94", "description": "After fooling around with the grid shader taught by Bigwings used for water drops, came upon a nice pattern by chance.", "tags": ["grid", "pattern"], "likes": 6, "viewed": 118, "published": "Public", "date": "1555633451", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float N2(vec2 p)\n{\t// Dave Hoskins - https://www.shadertoy.com/view/4djSRW\n\tvec3 p3  = fract(vec3(p.xyx) * vec3(443.897, 441.423, 437.195));\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n//applied n2 to kinda sorta get a random vec2\nvec2 randVec2(vec2 p)\n{\n\treturn vec2(N2(p), N2(p.yx)) - .5;\n}\n\n\nvec2 getCellStar(vec2 cellID)\n{\n    vec2 temp = randVec2(cellID);\n \treturn vec2(sin(iTime * temp.x), cos(iTime * temp.y)) * .4;\t//moving\n    return vec2(temp.x, temp.y) * .8;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //vec2 uv = fragCoord.xy / iResolution.xy;\n    //uv *= 2.f;\n    //uv -= 1.f;\n    //uv.x *= iResolution.x/iResolution.y;\n    \n    //thanks Fabrice\n    vec2 uv = (2.* fragCoord -  iResolution.xy ) /iResolution.y;\n    uv *= 5.;\n\n    vec2 gridCell = floor(uv);\n    vec2 gridOffset = fract(uv) - .5;\n\n    vec2 cellPoint = getCellStar(gridCell);\n\t\n    vec2 rekt = gridOffset - cellPoint;\t\n    float dToPoint = max(rekt.x, rekt.y);\n    \n\t//dToPoint = sin(iTime) > 0. ? dToPoint :smoothstep(.1, .05, dToPoint);\n    //dToPoint = smoothstep(sin(iTime) * .3, .05, dToPoint);\n\tdToPoint = mix(dToPoint, smoothstep(.1, .05, dToPoint), sin(iTime));\n    \n    fragColor = vec4(dToPoint);\n}\n\n  \t", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Wls3z8.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 18, 74, 217], [219, 265, 288, 288, 326], [329, 329, 360, 360, 505], [508, 508, 565, 715, 1242]], "test": "ok"}
{"id": "Wls3zn", "name": "Kira", "author": "Pasha", "description": "q", "tags": ["kira"], "likes": 1, "viewed": 156, "published": "Public", "date": "1555519646", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   \n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\tvec3 background_color = 0.5 + 0.5*cos(iTime+3.0+uv.xyx+vec3(0,2,4));\n    // Time varying pixel color\n    vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n\t\n    \n    if(uv.y<0.8 && uv.y>0.2)\n    {\n    \tif(uv.x<=0.1 && uv.x>=0.09){\n    \t\tfragColor = vec4(col,1.0);\n    \t}\n  \t\telse\n    \t{\n        \tfragColor = vec4(background_color,1.0);\n    \t}\n        \n        \n        if(uv.x*2.0+0.32 > uv.y && uv.x*2.0+0.32 < uv.y+0.03 && uv.y>0.5)\n            fragColor = vec4(col,1.0);\n        \n        \n        if(-1.0*uv.x*2.0+0.71 > uv.y && -1.0*uv.x*2.0+0.71 < uv.y+0.03 && uv.y<0.5)\n            fragColor = vec4(col,1.0);\n        \n        \n        if(uv.x<=0.3 && uv.x>=0.29)\n            fragColor = vec4(col,1.0);\n        \n        if(3.0*uv.x - 0.67 > uv.y && 3.0*uv.x - 0.67 < uv.y+0.03)\n        \tfragColor = vec4(col,1.0);\n        \n        if(uv.x<=0.5 && uv.x>=0.49)\n        \tfragColor = vec4(col,1.0);\n        \n        if(uv.x<=0.6 && uv.x>=0.59)\n        \tfragColor = vec4(col,1.0);\n        \n        if(pow(uv.x-0.6,2.0)+pow(uv.y-0.659,2.0)<0.02 && pow(uv.x-0.6,2.0)+pow(uv.y-0.659,2.0)>0.017 && uv.x>0.6)\n            fragColor = vec4(col,1.0);\n        \n        if(5.0*uv.x - 3.45 > uv.y && 5.0*uv.x - 3.45 < uv.y+0.05)\n        \tfragColor = vec4(col,1.0);\n        \n        if(-1.0*5.0*uv.x +5.1 > uv.y && -1.0*5.0*uv.x +5.1 < uv.y+0.05)\n        \tfragColor = vec4(col,1.0);\n        \n        if(uv.y<0.51 && uv.y>0.49 && uv.x>0.791 && uv.x<0.919)\n        \tfragColor = vec4(col,1.0);\n       \n    }\n    else\n    {\n        fragColor = vec4(background_color,1.0);\n    }\n    \n    \n    \n    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Wls3zn.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 111, 1738]], "test": "ok"}
{"id": "wlsGDn", "name": "Waterworld City", "author": "dr2", "description": "Climate change is coming...", "tags": ["water", "tower", "boat"], "likes": 15, "viewed": 462, "published": "Public API", "date": "1556108076", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// \"Waterworld City\" by dr2 - 2019\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\n#define AA    0  // optional antialiasing\n\nfloat PrRoundBoxDf (vec3 p, vec3 b, float r);\nfloat PrCylDf (vec3 p, float r, float h);\nfloat PrRoundCylDf (vec3 p, float r, float rt, float h);\nfloat PrCapsDf (vec3 p, float r, float h);\nvec2 PixToHex (vec2 p);\nvec2 HexToPix (vec2 h);\nfloat SmoothMin (float a, float b, float r);\nfloat SmoothBump (float lo, float hi, float w, float x);\nvec2 Rot2D (vec2 q, float a);\nfloat Minv3 (vec3 p);\nfloat Hashfv2 (vec2 p);\nvec2 Hashv2v2 (vec2 p);\nfloat Fbm1 (float p);\nfloat Fbm2 (vec2 p);\nvec3 VaryNf (vec3 p, vec3 n, float f);\n\n#define N_BOAT 2\n\nmat3 boatMat[N_BOAT], bMat;\nvec3 boatPos[N_BOAT], bPos, sunDir, qHit;\nvec2 gId, obOff;\nfloat boatAng[N_BOAT], bAng, dstFar, tCur, obSzFac, hgSize, nWin;\nint idObj, idObjGrp;\nconst float pi = 3.14159, sqrt3 = 1.7320508;\n\nvec3 TrackPath (float t)\n{\n  return vec3 (7. * cos (0.06 * t) + 0.1 * t, 0., t);\n}\n\nvec3 TrackVel (float t)\n{\n  return vec3 (-0.06 * 7. * sin (0.06 * t) + 0.1, 0., 1.);\n}\n\n#define DMINQ(id) if (d < dMin) { dMin = d;  idObj = id;  qHit = q; }\n\nfloat ObjCDf (vec3 p)\n{\n  vec3 q;\n  float dMin, d;\n  dMin = dstFar;\n  if (obSzFac > 0.) {\n    dMin /= obSzFac;\n    p.xz -= HexToPix (gId * hgSize) + obOff;\n    p /= obSzFac;\n    p.y -= 2.2;\n    q = p;\n    d = PrCylDf (q.xzy, 0.25 * (0.7 + 0.1 * q.y * q.y), 2.2);\n    DMINQ (1);\n    p.y -= 2.4 - 0.01;\n    q = p;\n    d = PrRoundCylDf (q.xzy, 0.8, 0.1, 0.4);\n    DMINQ (2);\n    dMin *= obSzFac;\n  }\n  return dMin;\n}\n\nfloat GrndHt (vec2 p)\n{\n  float h, s;\n  h = Fbm2 (0.5 * p) - 0.5;\n  s = 1. - abs (p.x - TrackPath (p.y).x) / 4.;\n  if (s > 0.) h = max (h - s * s, -0.5);\n  return h;\n}\n\nvoid SetTwrConf ()\n{\n  vec2 g, w;\n  g = HexToPix (gId * hgSize);\n  if (GrndHt (g) < 0.1 || Hashfv2 (37. * gId + 99.) < 0.1) obSzFac = 0.;\n  else {\n    obSzFac = hgSize * 0.5 * sqrt3 * (1. - 0.7 * Hashfv2 (17. * gId + 99.));\n    w = Hashv2v2 (73. * gId + 77.);\n    obOff = hgSize * max (0., 0.4 * sqrt3 - obSzFac) * w.x * sin (2. * pi * w.y + vec2 (0.5 * pi, 0.));\n    nWin = 4. + floor (8. * w.y);\n  }\n}\n\nfloat ObjCRay (vec3 ro, vec3 rd)\n{\n  vec3 vri, vf, hv, p;\n  vec2 edN[3], pM, gIdP;\n  float dHit, d, s, eps;\n  eps = 0.0005;\n  edN[0] = vec2 (1., 0.);\n  edN[1] = 0.5 * vec2 (1., sqrt3);\n  edN[2] = 0.5 * vec2 (1., - sqrt3);\n  for (int k = 0; k < 3; k ++) edN[k] *= sign (dot (edN[k], rd.xz));\n  vri = hgSize / vec3 (dot (rd.xz, edN[0]), dot (rd.xz, edN[1]), dot (rd.xz, edN[2]));\n  vf = 0.5 * sqrt3 - vec3 (dot (ro.xz, edN[0]), dot (ro.xz, edN[1]),\n     dot (ro.xz, edN[2])) / hgSize;\n  pM = HexToPix (PixToHex (ro.xz / hgSize));\n  gIdP = vec2 (-99.);\n  dHit = 0.;\n  for (int j = 0; j < 200; j ++) {\n    hv = (vf + vec3 (dot (pM, edN[0]), dot (pM, edN[1]), dot (pM, edN[2]))) * vri;\n    s = Minv3 (hv);\n    p = ro + dHit * rd;\n    gId = PixToHex (p.xz / hgSize);\n    if (gId.x != gIdP.x || gId.y != gIdP.y) {\n      gIdP = gId;\n      SetTwrConf ();\n    }\n    d = ObjCDf (p);\n    if (dHit + d < s) {\n      dHit += d;\n    } else {\n      dHit = s + eps;\n      pM += sqrt3 * ((s == hv.x) ? edN[0] : ((s == hv.y) ? edN[1] : edN[2]));\n    }\n    if (d < eps || dHit > dstFar || p.y < -0.1 || rd.y > 0. && p.y > 10.) break;\n  }\n  if (d >= eps) dHit = dstFar;\n  return dHit;\n}\n\nvec3 ObjCNf (vec3 p)\n{\n  vec4 v;\n  vec2 e = vec2 (0.0001, -0.0001);\n  v = vec4 (- ObjCDf (p + e.xxx), ObjCDf (p + e.xyy), ObjCDf (p + e.yxy), ObjCDf (p + e.yyx));\n  return normalize (2. * v.yzw - dot (v, vec4 (1.)));\n}\n\nfloat ObjCSShadow (vec3 ro, vec3 rd)\n{\n  vec3 p;\n  vec2 gIdP;\n  float sh, d, h;\n  sh = 1.;\n  d = 0.05;\n  gIdP = vec2 (-99.);\n  for (int j = 0; j < 30; j ++) {\n    p = ro + d * rd;\n    gId = PixToHex (p.xz / hgSize);\n    if (gId.x != gIdP.x || gId.y != gIdP.y) {\n      gIdP = gId;\n      SetTwrConf ();\n    }\n    h = ObjCDf (p);\n    sh = min (sh, smoothstep (0., 0.05 * d, h));\n    d += clamp (h, 0.05, 0.3);\n    if (sh < 0.05) break;\n  }\n  return 0.5 + 0.5 * sh;\n}\n\nfloat GrndRay (vec3 ro, vec3 rd)\n{\n  vec3 p;\n  float dHit, d;\n  dHit = -0.1 - ro.y / rd.y;\n  for (int j = 0; j < 100; j ++) {\n    p = ro + dHit * rd;\n    d = p.y + 0.01 * step (GrndHt (p.xz), -0.01);\n    if (d < 0.0005 || dHit > dstFar) break;\n    dHit += d;\n  }\n  return dHit;\n}\n\nfloat BoatDf (vec3 p, float dMin)\n{\n  vec3 q;\n  float d;\n  p.y -= 0.7;\n  q = p;\n  d = max (max (PrRoundCylDf (q, 1.2, 2., 3.5),\n     - max (PrRoundCylDf (q - vec3 (0., 0.1, 0.), 1.15, 2., 3.5),\n     abs (q.y) - 0.1)), abs (q.y + 0.1) - 0.1);\n  q.y -= -0.2;\n  d = max (SmoothMin (d, max (PrRoundCylDf (q, 1., 2., 3.3), q.y), 0.1), q.z - 2.);\n  DMINQ (idObjGrp + 1);\n  q = p;\n  q.yz -= vec2 (-0.5, -0.2);\n  d = max (PrRoundCylDf (q, 1., 1.1, 2.3), max (0.4 - q.y, q.z - 1.2));\n  DMINQ (idObjGrp + 2);\n  q = p;\n  q.yz -= vec2 (0.8, 0.5);\n  d = PrCylDf (q.xzy, 0.04, 0.3);\n  DMINQ (idObjGrp + 3);\n  return dMin;\n}\n\nfloat ObjDf (vec3 p)\n{\n  vec3 q;\n  float dMin, d, dLim;\n  const float bSzFac = 0.3;\n  dLim = 0.5 / bSzFac;\n  dMin = dstFar;\n  dMin /= bSzFac;\n  for (int k = 0; k < N_BOAT; k ++) {\n    q = p - boatPos[k];\n    idObjGrp = (k + 1) * 256;\n    d = PrCylDf (q.xzy, 2., 2.);\n    dMin = (d < dLim) ? BoatDf (boatMat[k] * q / bSzFac, dMin) : min (dMin, d);\n  }\n  return bSzFac * dMin;\n}\n\nfloat ObjRay (vec3 ro, vec3 rd)\n{\n  float dHit, d;\n  dHit = 0.;\n  for (int j = 0; j < 100; j ++) {\n    d = ObjDf (ro + dHit * rd);\n    dHit += d;\n    if (d < 0.001 || dHit > dstFar) break;\n  }\n  return dHit;\n}\n\nvec3 ObjNf (vec3 p)\n{\n  vec4 v;\n  vec2 e = vec2 (0.0001, -0.0001);\n  v = vec4 (- ObjDf (p + e.xxx), ObjDf (p + e.xyy), ObjDf (p + e.yxy), ObjDf (p + e.yyx));\n  return normalize (2. * v.yzw - dot (v, vec4 (1.)));\n}\n\nfloat ObjSShadow (vec3 ro, vec3 rd)\n{\n  float sh, d, h;\n  sh = 1.;\n  d = 0.05;\n  for (int j = 0; j < 30; j ++) {\n    h = ObjDf (ro + d * rd);\n    sh = min (sh, smoothstep (0., 0.05 * d, h));\n    d += clamp (h, 0.01, 0.3);\n    if (sh < 0.05) break;\n  }\n  return 0.5 + 0.5 * sh;\n}\n\nvec3 SkyCol (vec3 ro, vec3 rd)\n{\n  vec3 col, clCol;\n  vec2 q;\n  float f, fd, ff;\n  q = 0.005 * (ro.xz + tCur * vec2 (0.5, 2.) + ((200. - ro.y) / rd.y) * rd.xz);\n  ff = Fbm2 (q);\n  f = smoothstep (0.1, 0.8, ff);\n  fd = smoothstep (0.1, 0.8, Fbm2 (q + 0.01 * sunDir.xz)) - f;\n  clCol = (0.8 + 0.5 * ff) * (vec3 (0.7) - 0.7 * vec3 (0.3, 0.3, 0.2) * sign (fd) *\n     smoothstep (0., 0.05, abs (fd)));\n  fd = smoothstep (0.01, 0.1, rd.y);\n  col = mix (mix (vec3 (0.8, 0.8, 0.75), vec3 (0.4, 0.5, 0.8), 0.3 + 0.7 * fd), clCol,\n     0.1 + 0.9 * f * fd);\n  return col;\n}\n\nfloat WakeFac (vec3 row)\n{\n  vec2 tw[N_BOAT], twa;\n  float twLen[N_BOAT], wkFac, ba;\n  for (int k = 0; k < N_BOAT; k ++) {\n    tw[k] = row.xz - (boatPos[k].xz - Rot2D (vec2 (0., 2.5), boatAng[k]));\n    twLen[k] = length (tw[k]);\n  }\n  if (twLen[0] < twLen[1]) {\n    twa = tw[0];\n    ba = boatAng[0];\n  } else {\n    twa = tw[1];\n    ba = boatAng[1];\n  }\n  twa = Rot2D (twa, - ba);\n  wkFac = 0.;\n  if (length (twa * vec2 (1., 0.5)) < 1.) wkFac =\n     clamp (1. - 2. * abs (twa.x), 0., 1.) * clamp (0.5 + twa.y, 0., 1.);\n  return wkFac;\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  vec4 col4;\n  vec3 col, vn, row, rdd;\n  float dstObj, dstObjC, dstObjM, dstGrnd, wkFac, sh, a, nDotS;\n  int idObjC, ig, id;\n  bool wtRefl, glRefl;\n  dstObjC = ObjCRay (ro, rd);\n  idObjC = idObj;\n  dstObjM = ObjRay (ro, rd);\n  dstGrnd = (rd.y < 0.) ? GrndRay (ro, rd) : dstFar;\n  wtRefl = false;\n  glRefl = false;\n  wkFac = 0.;\n  dstObj = min (dstObjM, dstObjC);\n  if (dstGrnd < min (dstObj, dstFar)) {\n    row = ro + dstGrnd * rd;\n    if (row.y < 0.) {\n      ro = row;\n      wkFac = WakeFac (row);\n      row.xz += 0.2 * tCur;\n      if (wkFac > 0.) vn = VaryNf (16. * row, vec3 (0., 1., 0.), 2. * wkFac);\n      else vn = VaryNf (2. * row, vec3 (0., 1., 0.), 0.05 *\n         (1. - smoothstep (0.1, 0.4, dstGrnd / dstFar)));\n      row = ro;\n      rd = reflect (rd, vn);\n      ro += 0.01 * rd;\n      dstObjC = ObjCRay (ro, rd);\n      idObjC = idObj;\n      dstObjM = ObjRay (ro, rd);\n      dstGrnd = dstFar;\n      dstObj = min (dstObjM, dstObjC);\n      wtRefl = true;\n    }\n  }\n  if (min (dstObj, dstGrnd) < dstFar) {\n    if (dstObj < dstGrnd) {\n      if (dstObjM < dstObjC) {\n        ro += dstObjM * rd;\n        vn = ObjNf (ro);\n        ig = idObj / 256;\n        id = idObj - 256 * ig;\n        if (id == 1) {\n          if (abs (qHit.y - 0.105) < 0.005) col4 = vec4 (0.8, 0.6, 0.4, 0.1) *\n             (1. - 0.4 * SmoothBump (0.42, 0.58, 0.05, mod (7. * qHit.x, 1.)));\n          else col4 = (qHit.y > -0.3) ? ((ig == 1) ? vec4 (0.9, 0.9, 0.3, 0.3) :\n             vec4 (0.9, 0.3, 0.3, 0.3)) : vec4 (0.7, 0.7, 0.8, 0.1);\n        } else if (id == 2) {\n          col4 = (abs (abs (qHit.x) - 0.4) < 0.36 && qHit.y > 0.45 && \n             length (vec2 (abs (qHit.x) - 0.1, qHit.y - 0.2)) < 0.7 ||\n             abs (abs (qHit.z + 0.2) - 0.6) < 0.5 && abs (qHit.y - 0.65) < 0.2) ?\n             vec4 (0., 0., 0.1, -1.) : vec4 (0.9, 0.9, 1., 0.5);\n        } else if (id == 3) col4 = vec4 (1., 1., 1., 0.2);\n        if (col4.a == -1.) {\n          col4.a = 0.1;\n          glRefl = true;\n        }\n        sh = ObjSShadow (ro, sunDir);\n     } else {\n        ro += dstObjC * rd;\n        gId = PixToHex (ro.xz / hgSize);\n        vn = ObjCNf (ro);\n        if (idObjC == 1) {\n          col4 = vec4 (0.8, 0.8, 0.2, 0.2);\n        } else if (idObjC == 2) {\n          col4 = vec4 (0.7, 0.4, 0.1, 0.1);\n          a = mod (nWin * atan (qHit.z, - qHit.x) / pi, 1.);\n          if (step (abs (qHit.y), 0.3) * step (a, 0.75) > 0.) {\n             if (step (abs (qHit.y), 0.27) * step (a, 0.72) > 0.) {\n              col4.rgb = vec3 (0.3, 0.5, 0.3);\n              glRefl = true;\n            } else col4.rgb *= 1.4;\n          }\n        }\n        sh = ObjCSShadow (ro, sunDir);\n      }\n    } else {\n      ro += dstGrnd * rd;\n      vn = vec3 (0., 1., 0.);\n      if (dstGrnd < 0.5 * dstFar)\n         vn = VaryNf (4. * ro, vn, 1.5 * (1. - smoothstep (0.2, 0.5, dstGrnd / dstFar)));\n      col4 = vec4 (vec3 (0., 0.4, 0.) * min (1. - 0.2 * Fbm2 (32. * ro.xz), 1.), 0.1);\n      sh = ObjCSShadow (ro, sunDir);\n    }\n    nDotS = max (dot (vn, sunDir), 0.);\n    if (dstObj < dstGrnd) nDotS *= nDotS;\n    col = col4.rgb * (0.2 + 0.1 * max (dot (normalize (vec3 (vn.x, 0., vn.z)), - sunDir), 0.) +\n       0.8 * sh * nDotS) + col4.a * smoothstep (0.8, 1., sh) *\n       pow (max (dot (normalize (sunDir - rd), vn), 0.), 32.);\n    col = mix (col, SkyCol (ro, rd), (wtRefl ? 0.2 + 0.8 * smoothstep (0.4, 0.6, dstObj / dstFar) :\n       smoothstep (0.8, 0.9, min (dstGrnd, dstObj) / dstFar)));\n    if (glRefl) {\n      rdd = reflect (rd, vn);\n      rdd.y = abs (rdd.y);\n      col = mix (col, 0.8 * SkyCol (ro, rdd), 0.5);\n    }\n  } else col = SkyCol (ro, rd);\n  if (wkFac > 0.) col = mix (col, vec3 (0.8, 0.83, 0.8), wkFac * clamp (0.1 +\n     Fbm2 (16. * row.xz), 0., 1.));\n  col.rgb *= vec3 (1.1, 0.9, 0.9);\n  return clamp (col, 0., 1.);\n}\n\nvoid BoatPM (float t)\n{\n  vec3 v;\n  float c, s, bAz;\n  bPos = TrackPath (t);\n  bPos.y = 0.;\n  bMat[2] = vec3 (Rot2D (vec2 (1., 0.), 0.4 * (Fbm1 (0.2 * t) - 0.5)), 0.);\n  bMat[0] = normalize (vec3 (0., 0.1, 1.));\n  bMat[1] = cross (bMat[0], bMat[2]);\n  v = TrackVel (t);\n  bAz = atan (v.z, - v.x);\n  bAng = 0.5 * pi - bAz;\n  c = cos (bAz);\n  s = sin (bAz);\n  bMat *= mat3 (c, 0., s, 0., 1., 0., - s, 0., c);\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  mat3 vuMat;\n  vec4 mPtr, dateCur;\n  vec3 ro, rd, vd, col;\n  vec2 canvas, uv, uvs, ori, ca, sa, mMid, ut, mSize;\n  float el, az, asp, winHt, vuId, zmFac, sr, spd;\n  canvas = iResolution.xy;\n  uv = 2. * fragCoord.xy / canvas - 1.;\n  uvs = uv;\n  uv.x *= canvas.x / canvas.y;\n  tCur = iTime;\n  dateCur = iDate;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / canvas - 0.5;\n  asp = canvas.x / canvas.y;\n  winHt = 0.85;\n  mSize = (1./6.) * vec2 (asp, 1.) * winHt;\n  mMid = vec2 (asp * (1. - mSize.y) - 0.1 * mSize.y, - winHt + 1.1 * mSize.y);\n  ut = abs (uv - mMid) - mSize;\n  vuId = 0.;\n  if (max (ut.x, ut.y) < 0.) {\n    uv = (uv - mMid) / mSize.y;\n    vuId = 1.;\n  }\n  tCur = mod (tCur, 2400.) + 30. * floor (dateCur.w / 7200.);\n  hgSize = 1.;\n  spd = 2.;\n  ro = TrackPath (spd * tCur);\n  ro.x += 1. * sin (0.05 * 2. * pi * tCur);\n  ro.y = 1. + 2. * Fbm1 (0.1 * tCur);\n  vd = TrackVel (spd * tCur);\n  el = -0.03 * pi;\n  az = atan (vd.x, vd.z);\n  if (mPtr.z > 0.) {   \n    el += 0.4 * pi * mPtr.y;\n    az += 2.2 * pi * mPtr.x;\n  }\n  for (int k = 0; k < N_BOAT; k ++) {\n    BoatPM (spd * tCur + ((vuId == 0. && abs (az) > 0.5 * pi ||\n       vuId == 1. && abs (az) < 0.5 * pi) ? -1. : 1.) * (7. * float (k) + 4.5));\n    boatPos[k] = bPos;\n    boatMat[k] = bMat;\n    boatAng[k] = bAng;\n    boatPos[k].y = -0.02 + 0.07 * Fbm1 (tCur + 5. * float (k));\n  }\n  if (vuId == 1.) az += pi;\n  ori = vec2 (clamp (el, -0.5 * pi, 0.45 * pi), az);\n  ca = cos (ori);\n  sa = sin (ori);\n  vuMat = mat3 (ca.y, 0., - sa.y, 0., 1., 0., sa.y, 0., ca.y) *\n          mat3 (1., 0., 0., 0., ca.x, - sa.x, 0., sa.x, ca.x);\n  dstFar = 100.;\n  sunDir = normalize (vec3 (0., 1.2, -1.));\n  sunDir.xz = Rot2D (sunDir.xz, 0.3 * pi * cos (0.1 * tCur));\n  zmFac = 1.5;\n#if ! AA\n  const float naa = 1.;\n#else\n  const float naa = 3.;\n#endif  \n  col = vec3 (0.);\n  if (abs (uvs.y) < winHt) {\n    sr = 2. * mod (dot (mod (floor (0.5 * (uv + 1.) * canvas), 2.), vec2 (1.)), 2.) - 1.;\n    for (float a = 0.; a < naa; a ++) {\n      rd = vuMat * normalize (vec3 (uv + step (1.5, naa) * Rot2D (vec2 (0.5 / canvas.y, 0.),\n         sr * (0.667 * a + 0.5) * pi), zmFac));\n      col += (1. / naa) * ShowScene (ro, rd);\n    }\n  }\n  if (max (ut.x, ut.y) < 0. && min (abs (ut.x), abs (ut.y)) * canvas.y < 2.) col = vec3 (0.4, 0.4, 0.);\n  if (vuId == 0.) col *= 1. - smoothstep (0.99 * winHt, winHt, abs (uvs.y));\n  fragColor = vec4 (col, 1.);\n}\n\nfloat PrRoundBoxDf (vec3 p, vec3 b, float r)\n{\n  return length (max (abs (p) - b, 0.)) - r;\n}\n\nfloat PrCylDf (vec3 p, float r, float h)\n{\n  return max (length (p.xy) - r, abs (p.z) - h);\n}\n\nfloat PrRoundCylDf (vec3 p, float r, float rt, float h)\n{\n  float dxy, dz;\n  dxy = length (p.xy) - r;\n  dz = abs (p.z) - h;\n  return min (min (max (dxy + rt, dz), max (dxy, dz + rt)), length (vec2 (dxy, dz) + rt) - rt);\n}\n\nfloat PrCapsDf (vec3 p, float r, float h)\n{\n  return length (p - vec3 (0., 0., clamp (p.z, - h, h))) - r;\n}\n\nvec2 PixToHex (vec2 p)\n{\n  vec3 c, r, dr;\n  c.xz = vec2 ((1./sqrt3) * p.x - (1./3.) * p.y, (2./3.) * p.y);\n  c.y = - c.x - c.z;\n  r = floor (c + 0.5);\n  dr = abs (r - c);\n  r -= step (dr.yzx, dr) * step (dr.zxy, dr) * dot (r, vec3 (1.));\n  return r.xz;\n}\n\nvec2 HexToPix (vec2 h)\n{\n  return vec2 (sqrt3 * (h.x + 0.5 * h.y), (3./2.) * h.y);\n}\n\nfloat Minv3 (vec3 p)\n{\n  return min (p.x, min (p.y, p.z));\n}\n\nfloat SmoothMin (float a, float b, float r)\n{\n  float h;\n  h = clamp (0.5 + 0.5 * (b - a) / r, 0., 1.);\n  return mix (b, a, h) - r * h * (1. - h);\n}\n\nfloat SmoothBump (float lo, float hi, float w, float x)\n{\n  return (1. - smoothstep (hi - w, hi + w, x)) * smoothstep (lo - w, lo + w, x);\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  vec2 cs;\n  cs = sin (a + vec2 (0.5 * pi, 0.));\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nconst float cHashM = 43758.54;\n\nfloat Hashfv2 (vec2 p)\n{\n  return fract (sin (dot (p, vec2 (37., 39.))) * cHashM);\n}\n\nvec2 Hashv2f (float p)\n{\n  return fract (sin (p + vec2 (0., 1.)) * cHashM);\n}\n\nvec2 Hashv2v2 (vec2 p)\n{\n  vec2 cHashVA2 = vec2 (37., 39.);\n  return fract (sin (vec2 (dot (p, cHashVA2), dot (p + vec2 (1., 0.), cHashVA2))) * cHashM);\n}\n\nfloat Noiseff (float p)\n{\n  vec2 t;\n  float ip, fp;\n  ip = floor (p);\n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = Hashv2f (ip);\n  return mix (t.x, t.y, fp);\n}\n\nfloat Noisefv2 (vec2 p)\n{\n  vec2 t, ip, fp;\n  ip = floor (p);  \n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = mix (Hashv2v2 (ip), Hashv2v2 (ip + vec2 (0., 1.)), fp.y);\n  return mix (t.x, t.y, fp.x);\n}\n\nfloat Fbm1 (float p)\n{\n  float f, a;\n  f = 0.;\n  a = 1.;\n  for (int j = 0; j < 5; j ++) {\n    f += a * Noiseff (p);\n    a *= 0.5;\n    p *= 2.;\n  }\n  return f * (1. / 1.9375);\n}\n\nfloat Fbm2 (vec2 p)\n{\n  float f, a;\n  f = 0.;\n  a = 1.;\n  for (int j = 0; j < 5; j ++) {\n    f += a * Noisefv2 (p);\n    a *= 0.5;\n    p *= 2.;\n  }\n  return f * (1. / 1.9375);\n}\n\nfloat Fbmn (vec3 p, vec3 n)\n{\n  vec3 s;\n  float a;\n  s = vec3 (0.);\n  a = 1.;\n  for (int j = 0; j < 5; j ++) {\n    s += a * vec3 (Noisefv2 (p.yz), Noisefv2 (p.zx), Noisefv2 (p.xy));\n    a *= 0.5;\n    p *= 2.;\n  }\n  return dot (s, abs (n));\n}\n\nvec3 VaryNf (vec3 p, vec3 n, float f)\n{\n  vec3 g;\n  vec2 e = vec2 (0.1, 0.);\n  g = vec3 (Fbmn (p + e.xyy, n), Fbmn (p + e.yxy, n), Fbmn (p + e.yyx, n)) - Fbmn (p, n);\n  return normalize (n + f * (g - n * dot (n, g)));\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wlsGDn.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[925, 925, 951, 951, 1007], [1009, 1009, 1034, 1034, 1095], [1168, 1168, 1191, 1191, 1581], [1583, 1583, 1606, 1606, 1750], [1752, 1752, 1772, 1772, 2155], [2157, 2157, 2191, 2191, 3321], [3323, 3323, 3345, 3345, 3541], [3543, 3543, 3581, 3581, 4006], [4008, 4008, 4042, 4042, 4287], [4289, 4289, 4324, 4324, 4898], [4900, 4900, 4922, 4922, 5276], [5278, 5278, 5311, 5311, 5487], [5489, 5489, 5510, 5510, 5702], [5704, 5704, 5741, 5741, 5982], [5984, 5984, 6016, 6016, 6546], [6548, 6548, 6574, 6574, 7083], [7085, 7085, 7120, 7120, 10908], [10910, 10910, 10933, 10933, 11318], [11320, 11320, 11376, 11376, 13758], [13760, 13760, 13806, 13806, 13853], [13855, 13855, 13897, 13897, 13948], [13950, 13950, 14007, 14007, 14171], [14173, 14173, 14216, 14216, 14280], [14282, 14282, 14306, 14306, 14536], [14538, 14538, 14562, 14562, 14622], [14624, 14624, 14646, 14646, 14684], [14686, 14686, 14731, 14731, 14834], [14836, 14836, 14893, 14893, 14976], [14978, 14978, 15008, 15008, 15121], [15155, 15155, 15179, 15179, 15239], [15241, 15241, 15265, 15265, 15318], [15320, 15320, 15344, 15344, 15474], [15476, 15476, 15501, 15501, 15647], [15649, 15649, 15674, 15674, 15860], [15862, 15862, 15884, 15884, 16038], [16040, 16040, 16061, 16061, 16216], [16218, 16218, 16247, 16247, 16459], [16461, 16461, 16500, 16500, 16680]], "test": "error"}
{"id": "WlsGz4", "name": "Flowing noise 2", "author": "avin", "description": "little more flowing :)\ncontinue of https://www.shadertoy.com/view/3lXGzH\n", "tags": ["noise"], "likes": 8, "viewed": 374, "published": "Public API", "date": "1555764543", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Noise pixel size\n#define SIZE 5.0\n// Lower - more flowing\n#define FLUENCY 0.85\n\nfloat rand(vec2 co) { \n    return fract(sin(dot(co.xy , vec2(12.9898, 78.233))) * 43758.5453);\n} \n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{            \n    vec2 id = ceil(fragCoord/SIZE);    \n    vec2 rid = vec2(rand(id), rand(id+iResolution.y));            \n        \n    float ridFactor = rid.x + rid.y;\n    float f = ridFactor + iTime * FLUENCY *  (ridFactor);\n    float fid = floor(f);\n    f = abs(fract(f) - mod(fid, 2.));\n    fragColor = vec4(0.1/f);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WlsGz4.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[83, 83, 104, 104, 179], [182, 182, 239, 239, 557]], "test": "ok"}
{"id": "wlX3D8", "name": "581 Final Proj Part2", "author": "zheng516", "description": "581 final part2", "tags": ["581finalpart2"], "likes": 19, "viewed": 176, "published": "Public", "date": "1556334882", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Joseph Klinger - University of Pennsylvania\n// https://github.com/klingerj\n// https://www.linkedin.com/in/josephklinger/\n// Inspired by: https://www.shadertoy.com/view/MsSGD1\n// Idea also inspired from this course taught by Rachel Hwang at UPenn: https://cis700-procedural-graphics.github.io/\n\n// Raymarching params\n#define T_MAX 50.0\n\n// Colors\n#define GRAPHITE_COLOR vec3(0.3)\n#define RED_LINE_COLOR vec3(1.0, 0.41, 0.73)\n#define BLUE_LINE_COLOR vec3(0.58, 0.83, 0.95)\n#define PAPER_COLOR vec3(0.8, 0.8, 0.73)\n\n#define SHADOWS\n#define LIGHT_VEC normalize(vec3(0.0, 0.8, -1.0))\n\n// 3D Noise by IQ\nfloat Noise3D( in vec3 pos )\n{\n    vec3 p = floor(pos);\n    vec3 f = fract(pos);\n    f = f * f * (3.0 - 2.0 * f);\n    vec2 uv = (p.xy + vec2(37.0, 17.0) * p.z) + f.xy;\n    vec2 rg = textureLod( iChannel0, (uv + 0.5) / 256.0, 0.0).yx;\n    return -1.0 + 2.0 * mix( rg.x, rg.y, f.z );\n}\n\nfloat ComputeFBM( in vec3 pos )\n{\n    float amplitude = 0.25;\n    float sum = 0.0;\n    sum += Noise3D(pos) * amplitude;\n    return clamp(sum, 0.0, 1.0);\n}\n\n// Credit to IQ: http://iquilezles.org/www/articles/distfunctions/distfunctions.htm\n\n\nfloat SDF_Box( in vec3 pos, in vec3 b )\n{\n     return length(max(abs(pos) - b, 0.0));\n}\n\n\n// tea pot and cup==================================\n\n\nfloat sdCappedCylinder( vec3 p, vec2 h )\n{\n  vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat sdRoundedCylinder( vec3 p, float ra, float rb, float h )\n{\n    vec2 d = vec2( length(p.xz)-2.0*ra+rb, abs(p.y) - h );\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0)) - rb;\n}\n\nfloat opSmoothSubtraction( float d1, float d2, float k )\n{\n\tfloat h = clamp( 0.5 - 0.5*(d2+d1)/k, 0.0, 1.0 );\n\treturn mix( d2, -d1, h ) + k*h*(1.0-h);\n}\n\nfloat cupSDF(vec3 p) {\t\n    float dst = 0.0;\n\tfloat d1 = sdRoundedCylinder(-p, 0.12, 0.1, 0.1);\n   \tfloat d2 = sdCappedCylinder(vec3(0.,0.2,0.)-p, vec2(.1,.35));\n    dst = opSmoothSubtraction(d2, d1, 0.2);    \n    return dst;   \n}\n\n//Bezier curve utility func=====================\nfloat U(in vec2 a, in vec2 b){\n  return (a.x*b.y-b.x*a.y);\n}\n\n\nvec2 B(vec2 m, vec2 n, vec2 o, vec3 p) {\n\tvec2 q = p.xy;\n\tm-= q; n-= q; o-= q;\n\tfloat x = U(m, o), y = 2. * U(n, m), z = 2. * U(o, n);\n\tvec2 i = o - m, j = o - n, k = n - m, \n\t\t s = 2. * (x * i + y * j + z * k), \n\t\t r = m + (y * z - x * x) * vec2(s.y, -s.x) / dot(s, s);\n\tfloat t = clamp((U(r, i) + 2. * U(k, r)) / (x + x + y + z), 0.,1.); // parametric position on curve\n\tr = m + t * (k + k + t * (j - k)); // distance on 2D xy space\n\treturn vec2(sqrt(dot(r, r) + p.z * p.z), t); // distance on 3D space\n}\n\nfloat smin(float a, float b, float k){\n    float h = clamp(.5+.5*(b-a)/k, 0., 1.);\n    return mix(b,a,h)-k*h*(1.-h);\n}\n//Tea pot distance func=============================================\nvec2 A[15];\nvec2 T1[5];\nvec2 T2[5];\n\nvoid potAssgn(){\n\t //pot=====\n    // Teapot body profil (8 quadratic curves) \n    A[0]=vec2(0,0);A[1]=vec2(.64,0);A[2]=vec2(.64,.03);A[3]=vec2(.8,.12);A[4]=vec2(.8,.3);A[5]=vec2(.8,.48);A[6]=vec2(.64,.9);A[7]=vec2(.6,.93);\n    A[8]=vec2(.56,.9);A[9]=vec2(.56,.96);A[10]=vec2(.12,1.02);A[11]=vec2(0,1.05);A[12]=vec2(.16,1.14);A[13]=vec2(.2,1.2);A[14]=vec2(0,1.2);\n\t// Teapot spout (2 quadratic curves)\n\tT1[0]=vec2(1.16, .96);T1[1]=vec2(1.04, .9);T1[2]=vec2(1,.72);T1[3]=vec2(.92, .48);T1[4]=vec2(.72, .42);\n\t// Teapot handle (2 quadratic curves)\n\tT2[0]=vec2(-.6, .78);T2[1]=vec2(-1.16, .84);T2[2]=vec2(-1.16,.63);T2[3]=vec2(-1.2, .42);;T2[4]=vec2(-.72, .24);\n    //=========\n}\n\nfloat potSDF(vec3 p) {\n\n// Distance to Teapot --------------------------------------------------- \n\t// precalcul first part of teapot spout\n\tvec2 h = B(T1[2],T1[3],T1[4], p);\n\tfloat a = 99., \n    // distance to teapot handle (-.06 => make the thickness) \n\t\tb = min(min(B(T2[0],T2[1],T2[2], p).x, B(T2[2],T2[3],T2[4], p).x) - .06, \n    // max p.y-.9 => cut the end of the spout \n                max(p.y - .9,\n    // distance to second part of teapot spout (abs(dist,r1)-dr) => enable to make the spout hole \n                    min(abs(B(T1[0],T1[1],T1[2], p).x - .07) - .01, \n    // distance to first part of teapot spout (tickness incrase with pos on curve) \n                        h.x * (1. - .75 * h.y) - .08)));\n    // distance to teapot body => use rotation symetry to simplify calculation to a distance to 2D bezier curve\n    vec3 qq= vec3(sqrt(dot(p,p)-p.y*p.y), p.y, 0);\n    // the substraction of .015 enable to generate a small thickness arround bezier to help convergance\n    // the .8 factor help convergance  \n\tfor(int i=0;i<13;i+=2) \n\t\ta = min(a, (B(A[i], A[i + 1], A[i + 2], qq).x - .015) * .7); \n    // smooth minimum to improve quality at junction of handle and spout to the body\n\tfloat dTeapot = smin(a,b,.0);\n\n    return dTeapot;\n}\n\n\n// Cheap, pseudorandom number generator taken from: https://www.shadertoy.com/view/MscSzf\n/*\nfloat rand(float x)\n{\n    return fract(sin(x) * 43758.5453);\n}*/\n\n\nfloat rand( float p )\n{\n    p = dot(p,1271311.7);// dot(p,vec2(269.5,183.3)) ;\n\treturn fract(sin(p)*43758.5453);\n}\n\n\nfloat SceneMap( in vec3 pos )\n{\n   \n\tfloat sdf = potSDF(pos- vec3 (0.0, 0.0, 0.0));\n    sdf = min(sdf, cupSDF(pos- vec3(0.8, 0.2, -1.0)));\n   \tsdf = min(sdf, SDF_Box(pos - vec3(0.0, 0.0, 0.0), vec3(4.0, 0.02, 4.0) * 0.5));\n \n    return sdf;\n}\n\nvec3 ComputeNormal( in vec3 pos )\n{\n    vec2 epsilon = vec2(0.0, 0.001);\n    return normalize( vec3( SceneMap(pos + epsilon.yxx) - SceneMap(pos - epsilon.yxx),\n                            SceneMap(pos + epsilon.xyx) - SceneMap(pos - epsilon.xyx),\n                            SceneMap(pos + epsilon.xxy) - SceneMap(pos - epsilon.xxy)));\n}\n\nvec3 RaymarchScene( in vec3 origin, in vec3 dir )\n{\n    float distance, lastDistance = 10000000.0;\n    const float EDGE_THRESHOLD = 0.015;\n    float dt = 0.01;\n    float t = 0.01;\n    float hitSomething, isOnEdge = 0.0;\n    \n    for(int i = 0; i < 200; i++)\n    {\n        distance = SceneMap(origin + t * dir);\n        \n        // If we get very close to an object and we also moved away since the last iteration\n        if (distance < EDGE_THRESHOLD && distance > lastDistance + 0.00001)\n        {//edge detection\n            hitSomething = 1.0;\n            isOnEdge = 1.0;\n            break;\n        }\n        \n        if(distance < 0.001)\n        {\n            hitSomething = 1.0;\n            break;\n        }\n        else if (t > T_MAX)\n        {\n            break;\n        }\n        \n        t += distance;\n        lastDistance = distance;\n    }\n    return vec3(t, hitSomething, isOnEdge);\n}\n\nvec3 GetBackgroundColor( in vec2 coord )\n{\n    // Blue notebook paper lines\n    vec3 col = PAPER_COLOR;\n    \n    \n    //bool isOnRedLine = false;\n    /*\n    if (coord.x <= 86.5 && coord.x >= 85.0) // red notebook paper line\n    {\n        col *= RED_LINE_COLOR;\n        isOnRedLine = true;\n    }*/\n   /* \n    if (mod(coord.y, 20.0) <= 1.0 && mod(coord.y, 20.0) >= -1.0)\n    {\n        col *= BLUE_LINE_COLOR;\n        if (isOnRedLine) // mix the red and blue ink if the lines intersect\n        {\n            col *= RED_LINE_COLOR;\n        }\n        \n    }*/\n    \n    \n    // Accounting for the mottling in paper\n    float mottling = ComputeFBM(vec3(coord, 1.0) * 1.0);\n    //float mottling = 0.0;\n    return mix(col, vec3(0.0, 0.0, 0.0), pow(mottling, 0.8));\n}\n\nvec3 GetHatchingColor( in vec2 coord, in float lightIntensity, in vec3 camRight, in vec3 camUp, in bool isGradientEnabled, in float doOffsetHatching )\n{    \n    vec3 hatchingColor = GetBackgroundColor(coord);\n    \n    // Make the hatching look more consistent at full resolution\n    coord = coord / iResolution.xy * 1024.0;\n    \n    // Just catch a flag saying we want to jitter the hatching-\n    // For example, make the outline or shadow hatching look\n    // noncontinuous with any nearby dark hatching\n    coord += vec2(75.0, 15.0) * doOffsetHatching;\n    \n    float lineWidth, lineFreq, hatching;\n    \n    float thresh1 = 0.5;\n    float thresh0 = thresh1 + 0.075;\n    float thresh2 = thresh1 - 0.1;\n    float thresh3 = 0.2;\n    float thresh4 = thresh3 - 0.1;\n    \n    // This code could probably be a lot less verbose but oh well\n    \n    // Threshold 1\n    lineWidth = 0.015 * (0.5 * sin((coord.x - 0.25 * coord.y) * 0.04167 + 0.15 * (coord.x + coord.y)) + 0.5) + 1.0;\n    lineFreq = 10.0;\n    hatching = mod(coord.x + coord.y * 0.15 * (sin(abs(coord.y + coord.x) * 0.00390625 * 0.75)), lineFreq) + 2.0 * (rand(coord.x - 0.75 * coord.y) - 2.0);\n    if (lightIntensity <= thresh1)\n    {\n        if ((hatching <= lineWidth) && (hatching >= -lineWidth))\n    \t{\n    \t    hatchingColor *= GRAPHITE_COLOR;\n   \t    }\n    }\n    else\n    {\n        if(isGradientEnabled && lightIntensity < thresh0)\n        {\n        \tif ((hatching <= lineWidth) && (hatching >= -lineWidth))\n    \t\t{\n        \t   float weight = (thresh0 - lightIntensity) / (thresh0 - thresh1);\n       \t       weight = pow(weight, 1.0);\n    \t\t   hatchingColor = mix(hatchingColor * GRAPHITE_COLOR, hatchingColor, 1.0 - weight);\n   \t        }\n        }\n    }\n    \n    \n    // Threshold 2\n    lineWidth = 1.0 * (0.5 * sin((coord.x + 0.75 * coord.y) * 0.0625 + 0.15 * (coord.x - 0.5 * coord.y)) + 0.5) + 1.0;\n    lineFreq = 14.0;\n    hatching = mod(coord.x + coord.y, lineFreq) + 2.0 * (rand(coord.x - 0.75 * coord.y) - 2.0);\n    if (lightIntensity <= thresh2)\n    {\n        if ((hatching <= lineWidth) && (hatching >= -lineWidth))\n    \t{\n    \t   hatchingColor *= GRAPHITE_COLOR;\n   \t    }\n    }\n    else\n    {\n        if(isGradientEnabled && lightIntensity < thresh1)\n        {\n        \tif ((hatching <= lineWidth) && (hatching >= -lineWidth))\n    \t\t{\n        \t   float weight = (thresh1 - lightIntensity) / (thresh1 - thresh2);\n       \t       weight = pow(weight, 1.0);\n    \t\t   hatchingColor = mix(hatchingColor * GRAPHITE_COLOR, hatchingColor, 1.0 - weight);\n   \t        }\n        }\n    }\n    \n    // Threshold 3\n    lineWidth = 1.0 * (0.5 * sin((coord.x + 1.0 * coord.y) * 0.03125 + 0.15 * (coord.x - 1.5 * coord.y)) + 0.5) + 1.5;\n    lineFreq = 8.0;\n    hatching = mod(coord.x - 0.75 * coord.y, lineFreq) + 2.0 * (rand(coord.x + 0.75 * coord.y) - 2.0);\n    if (lightIntensity <= thresh3)\n    {\n        if ((hatching <= lineWidth) && (hatching >= -lineWidth))\n    \t{\n    \t    hatchingColor *= GRAPHITE_COLOR;\n   \t    }\n    }\n    else\n    {\n        if(isGradientEnabled && lightIntensity < thresh2)\n        {\n        \tif ((hatching <= lineWidth) && (hatching >= -lineWidth))\n    \t\t{\n        \t   float weight = (thresh2 - lightIntensity) / (thresh2 - thresh3);\n       \t       weight = pow(weight, 1.0);\n    \t\t   hatchingColor = mix(hatchingColor * GRAPHITE_COLOR, hatchingColor, 1.0 - weight);\n   \t        }\n        }        \n    }\n    \n    \n    // Threshold 4\n    lineWidth = 1.25;\n    lineFreq = 7.0;\n    hatching = mod(coord.x + 0.15 * coord.y, lineFreq) + 2.0 * (rand(coord.x - 0.75 * coord.y) - 2.0);\n    if (lightIntensity <= thresh4)\n    {\n        if ((hatching <= lineWidth) && (hatching >= -lineWidth))\n    \t{\n    \t    hatchingColor *= GRAPHITE_COLOR;\n   \t    }\n    }\n    else\n    {\n        if(isGradientEnabled && lightIntensity < thresh3)\n        {\n        \tif ((hatching <= lineWidth) && (hatching >= -lineWidth))\n    \t\t{\n        \t   float weight = (thresh3 - lightIntensity) / (thresh3 - thresh4);\n       \t       weight = pow(weight, 2.0);\n    \t\t   hatchingColor = mix(hatchingColor * GRAPHITE_COLOR, hatchingColor, 1.0 - weight);\n   \t        }\n        }  \n    }\n    return hatchingColor;\n    \n}\n\n// Credit to IQ: http://www.iquilezles.org/www/articles/rmshadows/rmshadows.htm\nfloat SoftShadow( in vec3 ro, in vec3 rd, float k )\n{\n    float res = 1.0;\n    float t = 0.05;\n    while(t <= 10.0)\n    {\n        float h = SceneMap(ro + rd * t);\n        if (h < 0.001)\n        {\n            return 0.0;\n        }\n        res = min(res, k * h / t);\n        t += h;\n    }\n    return res;\n}\n\n// \"Plasma\": Compute ray jitter using \"plasma\": http://lodev.org/cgtutor/plasma.html\nfloat Plasma( in vec2 sp, in float timeStutter )\n{    \n    float plasma = 0.5 * sin(sp.x * 8.0 + timeStutter) + 0.5;\n    plasma *=  sin((sp.x + sp.y) * 8.0 + timeStutter) + 0.5;\n    plasma *= 0.5 * sin(length(sp) * 15.0 + timeStutter) + 0.5;\n    return plasma;\n}\n\nvec3 CastRay( in vec2 sp, in vec3 origin, out vec3 camRight, out vec3 camUp ) // need the camRight vector in the hatching color function\n{\n    // Compute local camera vectors\n    vec3 refPoint = vec3(0.0, 0.4, 0.0);\n    vec3 camLook = normalize(refPoint - origin);\n    camRight = normalize(cross(camLook, vec3(0.0, 1.0, 0.0)));\n    camUp = normalize(cross(camRight, camLook));\n    \n    vec3 rayPoint = refPoint + sp.x * camRight + sp.y * camUp;\n    return normalize(rayPoint - origin);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{    \n    potAssgn();\n    \n    vec2 screenPoint = (2.0 * fragCoord.xy - iResolution.xy) / iResolution.y;\n    \n    // Compute ray direction\n    float radius = 4.0;\n    float speed = 0.015625;\n    \n    // camera \n    vec3 rayOrigin = vec3(cos(iMouse.x * speed) * radius, -5.0 * ((iMouse.y / iResolution.y) - 0.8), sin(iMouse.x * speed) * radius);\n    vec3 camRight, camUp;\n    vec3 rayDirection = CastRay(screenPoint, rayOrigin, camRight, camUp);\n    \n    // Compute ray jitter using fake noise stuff using sin() - see the Plasma() function\n    float timeStutter = floor(iTime * 12.0) * 16.0;\n    timeStutter = mod(timeStutter, 2048.0); // the plasma function broke when iTime reached high values, mod every 2^24\n    \n    const bool isGradientEnabled = true;\n    \n    // Compute a direction to offset the .xy component of each ray via a gradient\n    vec2 fragSize = 1.0 / iResolution.xy;\n    vec2 offsetDir = normalize(vec2(cos(cos(iTime * 2.0)), sin(cos(iTime * 2.0)))) * 0.75;\n    rayDirection.xy += max(Plasma(screenPoint, timeStutter), 0.05) * offsetDir * 0.00390625; // that's 1 / 256\n    \n    vec3 result = RaymarchScene(rayOrigin, rayDirection);\n    \n    if (result.y > 0.0)\n    {\n        vec3 isectPoint = rayOrigin + result.x * rayDirection;\n        vec3 normal = ComputeNormal(isectPoint);\n        float lightIntensity = clamp(dot(normal, LIGHT_VEC), 0.0, 1.0);\n        \n        vec3 col;\n        \n        // Compute shadows\n        float shadowing = 1.0;\n        #ifdef SHADOWS\n            shadowing= SoftShadow(isectPoint, LIGHT_VEC, 7.0);\n        #endif\n        \n        // Shade depending on whether or not we are on an outline\n       \n        col = mix(GetHatchingColor(fragCoord.xy, min(shadowing, lightIntensity), camRight, camUp, isGradientEnabled, 0.0),\n                  GetHatchingColor(fragCoord.xy, 0.0, camRight, camUp, isGradientEnabled, 0.0),\n                  result.z);\n        \n        \n       // col = GetHatchingColor(fragCoord.xy, min(shadowing, lightIntensity), camRight, camUp, isGradientEnabled, 0.0);\n        //col = GetHatchingColor(fragCoord.xy, 0.0, camRight, camUp, isGradientEnabled, 0.0);\n                        \n        fragColor = vec4(col, 1.0);\n    }\n    else // we miss geometry completely\n    {\n        fragColor = vec4(GetBackgroundColor(fragCoord.xy), 1.0);\n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wlX3D8.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[583, 601, 631, 631, 884], [886, 886, 919, 919, 1040], [1128, 1128, 1169, 1169, 1215], [1273, 1273, 1315, 1315, 1414], [1416, 1416, 1480, 1480, 1601], [1603, 1603, 1661, 1661, 1755], [1757, 1757, 1779, 1779, 1987], [1989, 2038, 2068, 2068, 2098], [2101, 2101, 2141, 2141, 2607], [2609, 2609, 2647, 2647, 2727], [2834, 2834, 2850, 2911, 3509], [3511, 3511, 3533, 3650, 4762], [4925, 4925, 4948, 4948, 5039], [5042, 5042, 5073, 5073, 5284], [5286, 5286, 5321, 5321, 5623], [5625, 5625, 5676, 5676, 6521], [6523, 6523, 6565, 6598, 7280], [7282, 7282, 7434, 7434, 11450], [11452, 11532, 11585, 11585, 11836], [11838, 11923, 11973, 11973, 12185], [12187, 12187, 12325, 12361, 12674], [12676, 12676, 12733, 12733, 15046]], "test": "error"}
{"id": "WlX3RM", "name": "Cartoon shade", "author": "Kua256", "description": "cartoon shade", "tags": ["raymarching"], "likes": 8, "viewed": 131, "published": "Public", "date": "1555830125", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const float sphereSize = 1.0;\nconst vec3 lightDir = vec3(-0.577, 0.577, 0.577);\n\nvec3 hsv2rgb(vec3 c)\n{\n  c = vec3(c.x, clamp(c.yz, 0.0, 1.0));\n  vec4 k = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n  vec3 p = abs(fract(c.xxx + k.xyz) * 6.0 - k.www);\n  return c.z * mix(k.xxx, clamp(p - k.xxx, 0.0, 1.0), c.y);\n}\n\nvec3 rotate(vec3 p, float angle, vec3 axis)\n{\n    vec3 a = normalize(axis);\n    float s = sin(angle);\n    float c = cos(angle);\n    float r = 1.0 - c;\n    mat3 m = mat3(\n              a.x * a.x * r + c,  a.y * a.x * r + a.z * s,  a.z * a.x * r - a.y * s,\n        a.x * a.y * r - a.z * s,        a.y * a.y * r + c,  a.z * a.y * r + a.x * s,\n        a.x * a.z * r + a.y * s,  a.y * a.z * r - a.x * s,  a.z * a.z * r + c\n    );\n    return m * p;\n}\n\nfloat sphere(vec3 p, float r)\n{\n    return length(p) - r;\n}\n\nfloat box(vec3 p, vec3 b)\n{\n    vec3 d = abs(p) - b;\n    return length(max(d,0.0)) + min(max(d.x,max(d.y,d.z)),0.0);\n}\n\nfloat torus(vec3 p, vec2 t)\n{\n    vec2 q = vec2(length(p.xz)-t.x,p.y);\n\treturn length(q)-t.y;\n}\n\nfloat sub(float d1, float d2)\n{\n    return max(-d1, d2);\n}\n\nfloat distanceFunc(vec3 p)\n{\n    float d1 = box(rotate(p, iTime * 0.3, vec3(1.0, 0.5, 1.0)), vec3(0.5));\n    float d2 = sphere(p, 0.65);\n    float d3 = torus(rotate(p, iTime, vec3(1.0, 0.5, 0.0)), vec2(0.7, 0.2));\n    float d4 = sub(d2, d1);\n    \n    int pair = int(floor(mod(iTime * 0.5, 4.0)));\n    float a = smoothstep(0.2, 0.7, mod(iTime * 0.5, 1.0));\n    \n    if(pair == 0) return mix(d1, d2, a);\n    if(pair == 1) return mix(d2, d3, a);\n    if(pair == 2) return mix(d3, d4, a);\n    else\t\t  return mix(d4, d1, a);\n}\n\nvec3 getNormal(vec3 pos)\n{\n    float d = 0.0001;\n    return normalize(vec3(\n        distanceFunc(pos + vec3(  d, 0.0, 0.0)) - distanceFunc(pos + vec3( -d, 0.0, 0.0)),\n        distanceFunc(pos + vec3(0.0,   d, 0.0)) - distanceFunc(pos + vec3(0.0,  -d, 0.0)),\n        distanceFunc(pos + vec3(0.0, 0.0,   d)) - distanceFunc(pos + vec3(0.0, 0.0,  -d))));\n}\n\nfloat circle(vec2 pos)\n{\n    return length(pos);\n}\n\nfloat square(vec2 pos)\n{\n  vec2 a = pow(abs(pos), vec2(1.0));\n  return pow(a.x + a.y, 1.0);\n}\n\nfloat heart(vec2 pos)\n{\n\tpos = (pos - vec2(0.5, 0.48)) * vec2(2.1, -2.8);\n\n\treturn pow(pos.x, 2.0) + pow(pos.y - sqrt(abs(pos.x)), 2.0);\n}\n\nfloat create2DShape(vec2 pos)\n{\n    pos = vec2(0.5) - pos;\n    float s1 = circle(pos);\n    float s2 = square(pos);\n    float s3 = heart(pos + vec2(0.5));\n    \n    int pair = int(floor(mod(iTime, 3.0)));\n    float a = smoothstep(0.2, 0.7, mod(iTime, 1.0));\n    \n    if(pair == 0) return mix(s1, s2, a);\n    if(pair == 1) return mix(s2, s3, a);\n    else\t\t  return mix(s3, s1, a);\n}\n\nfloat createScreenTone(vec2 pos, float NdotL)\n{\n    float iNdotL = 1.0 - NdotL;\n    iNdotL *= 0.5;\n                \n    pos = pos * 50.0 * iNdotL;\n    pos.x += step(1.0, mod(pos.y, 2.0)) * 0.5;\n    pos = fract(pos);\n\n    float r = 0.7 * iNdotL;\n    return smoothstep(r, r + 0.15, create2DShape(pos));\n}\n\nvec4 render(vec2 pos)\n{\n    vec3 cPos = vec3(0.0,  0.0,  1.25);\n    vec3 cDir = vec3(0.0,  0.0, -1.0);\n    vec3 cUp  = vec3(0.0,  1.0,  0.0);\n    vec3 cSide = cross(cDir, cUp);\n    float targetDepth = 1.0;\n    \n    vec3 ray = normalize(cSide * pos.x + cUp * pos.y + cDir * targetDepth);\n    \n    float d = 0.0;\n    float rLen = 0.0;\n    vec3  rPos = cPos;\n    for(int i = 0; i < 32; ++i)\n    {\n        d = distanceFunc(rPos);\n        rLen += d;\n        rPos = cPos + ray * rLen;\n    }\n    \n    if(abs(d) < 0.001)\n    {\n        vec3 normal = getNormal(rPos);\n        float nDotL = dot(lightDir + vec3(acos(cos(iTime * 0.7)), 0.0, 0.0), normal);\n\t\tnDotL = nDotL > 0.65 ? 1.0 \n\t\t\t: nDotL > 0.3 ? 0.5\n\t\t\t: 0.1;\n        \n\t\tfloat tone = createScreenTone(pos, nDotL);\n        vec3 hsv = vec3(abs(sin(iTime * 0.5)), 1.0, 0.7);\n\t\tvec3 color = mix(hsv2rgb(hsv), vec3(1.0), tone);\n        \n        return vec4(color, 1.0);\n    }\n    else\n    {\n        pos = pos + vec2(0.5);\n        pos = fract(pos * 2.0);\n        return vec4(vec4(0.3) - step(0.1, 0.4 * create2DShape(pos)));\n    }\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = (fragCoord.xy * 2.0 - iResolution.xy) \n        / min(iResolution.x, iResolution.y);\n\n    vec4 color = vec4(0);\n    const int iter = 3;\n    for(int i = 1; i <= iter; ++i)\n    {\n        float fi = float(i);\n        vec2 offset = (vec2(step(fi, 2.0), mod(fi, 2.0)) - 0.5) * 0.005;\n        color += render(uv + offset);\n    }\n\n    color /= float(iter);\n    fragColor = color;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WlX3RM.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[81, 81, 103, 103, 306], [308, 308, 353, 353, 752], [754, 754, 785, 785, 813], [815, 815, 842, 842, 933], [935, 935, 964, 964, 1030], [1032, 1032, 1063, 1063, 1090], [1092, 1092, 1120, 1120, 1612], [1614, 1614, 1640, 1640, 1966], [1968, 1968, 1992, 1992, 2018], [2020, 2020, 2044, 2044, 2113], [2115, 2115, 2138, 2138, 2253], [2255, 2255, 2286, 2286, 2634], [2636, 2636, 2683, 2683, 2938], [2940, 2940, 2963, 2963, 4013], [4015, 4015, 4071, 4071, 4459]], "test": "ok"}
{"id": "wlX3Wn", "name": "Zelda illumination", "author": "munrocket", "description": "Trying to implement cartoon-like shader.", "tags": ["cartoon", "shading", "zelda"], "likes": 16, "viewed": 511, "published": "Public", "date": "1556032716", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord ) {    \n    // Grid parameters\n    vec2 gridsize = vec2(5., 3.);\n    float zoom = 0.75;\n    \n    // Cell coordinates\n    vec2 uv = fragCoord / iResolution.xy;\n    vec2 cellcoord = fract(uv * gridsize);\n    vec2 cellgrid = floor(uv * gridsize) / gridsize;\n    vec2 ratio = vec2(iResolution.x / gridsize.x / iResolution.y * gridsize.y , 1.0);\n    vec2 xy = (2. * cellcoord - 1.) / zoom * ratio;\n        \n    // AA mask, planet normals, noize\n    float aa_mask = smoothstep(1. + 0.02 * gridsize.y, 1., dot(xy, xy));\n    vec3 N = vec3(xy, sqrt(1. - clamp(dot(xy, xy), 0., 1.)));\n    vec3 noize = texture(iChannel0, uv).xyz;\n    \n    // Material/scene properties\n    vec3 albedo = vec3(.25 + .5*cellgrid.x, .45, 0.25 + .5*cellgrid.y);\n    vec3 white = vec3(.99, .95, .8);\n    float Kd = 0.33;\n    float Kh = 0.5;\n    float Kb = -0.1;\n    vec3 V = vec3(0.,0.,1.);\n    vec3 L = normalize(vec3(sin(iTime/2.),cos(iTime/2.), sin(iTime/8.)));\n    \n    // Diffuse light\n    float ldotn = dot(L, N);\n    vec3 diffuse = mix(vec3(0), 1.0 - albedo, Kd * smoothstep(0.0, 0.02, ldotn));\n    \n    // Halo light\n    float vdotn = smoothstep(0.73, .85, 1. - dot(V, N));\n    vec3 halo = vdotn * mix(vec3(Kb), Kh * white, smoothstep(0.0, 0.08, ldotn));\n    \n    // Result color\n    vec3 planet = albedo + diffuse + halo;\n    vec3 space = vec3(step(1.46, length(noize - vec3(1.)))) * (1. - noize);\n    fragColor = vec4(mix(space, planet, aa_mask), 1.);\n}", "image_inputs": [{"id": "Xsf3zn", "previewfilepath": "/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wlX3Wn.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 84, 1484]], "test": "error"}
{"id": "wlX3zr", "name": "Basics - Patterns 2", "author": "trevorleake", "description": "A simple study in use of noise.", "tags": ["noise", "patterns", "basics"], "likes": 2, "viewed": 768, "published": "Public", "date": "1555484233", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float random (in float x) {\n    return fract(sin(x)*1e4);\n}\n\n\n// Just a function to return a pleasant translation/velocity for each column\nfloat velocity(float column) {\n    float v = (random(column) - .5)/2.;\n    v *= 14.2857;\n    return iTime * v;\n}\n\n\nfloat box(vec2 uv, vec2 topLeft, vec2 bottomRight)\n{\n    return uv.x > topLeft.x && uv.x < bottomRight.x && uv.y < topLeft.y && uv.y > bottomRight.y ? 1. : 0.;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Center our coordinate system    \n    vec2 uv = (fragCoord - .5*iResolution.xy) / min(iResolution.x, iResolution.y);\n    \n    // Scale the coords up by 10\n    uv *= 10.;\n        \n    // Assign translation by column\n    uv += vec2(0, velocity(floor(uv.x)));\n    \n\n    vec3 col = vec3(0);\n\n    // Determine each row exists (as columns are offset, this will look like each cell is determined individually\n    float rowExists = step(.7, random(floor(uv.y)));\n\n    // Paint in boxes if row exists\n    col += rowExists * box(fract(uv), vec2(0,.7), vec2(.3,0));\n\t\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}\n        \n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wlX3zr.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 27, 27, 59], [62, 139, 169, 169, 251], [254, 254, 306, 306, 415], [418, 418, 475, 515, 1095]], "test": "ok"}
{"id": "wlXGR7", "name": "nicso_abstract01", "author": "nicso", "description": "_", "tags": ["abstract"], "likes": 3, "viewed": 91, "published": "Public", "date": "1555875115", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float sphere(vec3 p)\n{\n    p = mod(p,3.)-3.*.5;\n    return length(p)-.3;\n}\nvoid mainImage(out vec4 fragColor,in vec2 fragCoord)\n{\n    vec2 uv=fragCoord/iResolution.xy;\n    uv-=.5;    \n    uv.x*=iResolution.x/iResolution.y;\n\n    vec3 col = vec3(.2);\n\n    vec3 ro = vec3(0.,0.,-3.);\n    vec3 rd = normalize(vec3(uv,1.));\n    vec3 p = ro;\n    p.x += sin(iTime );\n    p.y += cos(iTime );\n\n    bool hit = false;\n    float shading = 0.;\n    for(float i=0.; i<100.; i++){\n        float d = sphere(p+i);\n        if(d<.05){\n            hit = true;\n            shading = i/100.;\n            break;\n        }\n        p += d * rd;\n    }\n    if(hit) col = vec3(1.-shading);\n    else col = vec3(0.);\n    \n    fragColor=vec4(col.r);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wlXGR7.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 22, 22, 74], [75, 75, 129, 129, 719]], "test": "ok"}
{"id": "WlXGR8", "name": "Cubic circle parametrizations", "author": "iq", "description": "Some different circle parametrizations. Getting constant speed (derivatives) needs reparametrizing to ensure constant derivative. I've done that for circles but not for square circles yet, so I quickly eyeballed some smoothstep based reparametrizations.", "tags": ["2d", "circle", "parametrization"], "likes": 16, "viewed": 976, "published": "Public API", "date": "1555546192", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// The MIT License\n// Copyright © 2019 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n\n// How to parametrize a square circle (a circle to a root really) \n// such that it's more or less uniform. The maths can be done but\n// for now I quickly eyeballed some smoothstep based reparametrizations.\n//\n// I provide three different  versions:\n\n\n// 0 : quartic root, non trigonometric\n// 1 : cubic   root, non trigonometric\n// 2 : cubic   root,     trigonometric\n#define METHOD 2\n\n// Make 0 to see uncorrected result\n#define REPARAMETRIZE 1\n\n// Make 16 to see more dramatic effets\n#define NUMPOINTS 50\n\n// See also this shader: https://www.shadertoy.com/view/3slGWM\n\n\n\n\n#if METHOD==0\nvec2 circle( in float t )\n{\n    float s = fract(t*4.0);\n    \n    #if REPARAMETRIZE==1\n    s = s*s*(3.0-2.0*s);  // pick something better\n    s = s*s*(3.0-2.0*s);\n    s = s*s*(3.0-2.0*s);\n    #endif\n    \n    vec2 p = pow( vec2(1.0-s,s), vec2(1.0/8.0) );\n  //vec2 p = sqrt(sqrt(sqrt(vec2(1.0-s,s))));\n    \n    return (t<0.25) ? vec2(-p.y, p.x) :\n           (t<0.50) ? vec2(-p.x,-p.y) :\n           (t<0.75) ? vec2( p.y,-p.x) : p;\n}\n#endif\n\n#if METHOD==1\nvec2 circle( in float t )\n{\n    float s = fract(t*4.0);\n\t\n    #if REPARAMETRIZE==1\n    s = s*s*s*(6.0*s*s-15.0*s+10.0); // pick something better\n    s = s*s*(3.0-2.0*s);\n    #endif\n\n    vec2 p = pow( vec2(1.0-s,s), vec2(1.0/6.0) );\n    \n    return (t<0.25) ? vec2(-p.y, p.x) :\n           (t<0.50) ? vec2(-p.x,-p.y) :\n           (t<0.75) ? vec2( p.y,-p.x) : p;\n}\n#endif\n\n#if METHOD==2\nvec2 circle( in float t )\n{\n    #if REPARAMETRIZE==1\n    float i = floor(4.0*t);\n    float s = fract(4.0*t);\n\n    // pick some other smoothstep-like polynomial\n    s = s*s*s*(5.0+s*(6.0+s*(-15.0+s*(-21.0+s*(+54.0+s*(-36.0+s*8.0))))));\n    \n    t = (i+s)/4.0;\n    #endif\n  \n    const float pi = 3.1415926535;\n    vec2 p = vec2( cos(2.0*pi*t), sin(2.0*pi*t));\n    return sign(p)*pow(abs(p),vec2(1.0/3.0)); // cubic root\n}\n#endif\n        \n//------------------------------------------------------\n//------------------------------------------------------\n\nfloat sdSegment( in vec2 p, in vec2 a, in vec2 b )\n{\n\tvec2 pa = p - a, ba = b - a;\n\tfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n\treturn length( pa - ba*h );\n}\n\nfloat animate( float t )\n{\n    return fract(t+iTime*0.05);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    const float sc = 1.2;\n\n    float px = sc*2.0/iResolution.y;\n\tvec2  p  = sc*(2.0*fragCoord-iResolution.xy)/iResolution.y;\n\n    // compute distance to shape, brute force way\n    vec2 o = circle(animate(0.0));\n    vec2 d = vec2(length( p - o ));\n    for( int i=0; i<NUMPOINTS; i++ )\n    {\n        float t = animate(float(i+1)/float(NUMPOINTS));\n        vec2  c = circle(t);\n        float w = sdSegment( p, o, c );\n        d = min( d, vec2(w, length(p-c)-0.02) );\n        o = c;\n\t}\n    \n\t// colorize\n    vec3 col = vec3(0.25)*(1.0-0.1*length(p));\n    col = mix( col, vec3(1.0,1.0,1.0), 1.0 - smoothstep(0.0, 2.0*px, d.x ) );\n    col = mix( col, vec3(1.0,0.7,0.0), 1.0 - smoothstep(0.0, 2.0*px, d.y ) );\n\n    // dither\n    col += (1.0/128.0)*cos(31.1*dot(fragCoord,vec2(57.,13.)));\n    \n\tfragColor = vec4( col, 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WlXGR8.jpg", "access": "shaders20k", "license": "mit", "functions": [[3054, 3054, 3106, 3106, 3220], [3222, 3222, 3248, 3248, 3282], [3284, 3284, 3341, 3341, 4160]], "test": "ok"}
{"id": "WlXGzS", "name": "Egg over square tiles", "author": "jblanper", "description": "Wobbling egg over moving square tiles. Experimenting with randomness.", "tags": ["2d", "egg", "tiles", "randomness"], "likes": 1, "viewed": 76, "published": "Public", "date": "1556618296", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float random (vec2 uv) {\n  return fract(sin(dot(uv.xy, vec2(11.987, 77.49)))*8523.6886);\n}\n\nfloat stroke (float d, float r, float lw, float blur) {\n  float hlw = lw / 2.;\n  return smoothstep(r + hlw, r + hlw - .005 - blur, d) *\n    smoothstep(r - hlw, r - hlw + .005 + blur, d);\n}\n\nfloat fill (float d, float r, float blur) {\n  return smoothstep(r, r - .005 - blur, d);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n  vec2 uv = (fragCoord.xy - .5 * iResolution.xy) / iResolution.y;\n\n  // background\n  vec2 p = uv;\n  float t = iTime * .08;\n  p.x += (mod(floor(p.y * 10.), 2.) == 0.) ? -t : t;\n\n  vec2 st = fract(p * 10.) - .5;\n    \n  if ((mod(floor(p.y * 10.), 2.) == 0.) && (mod(floor(p.x * 10.), 2.) == 0.)) {\n    float a = iTime;\n    st = mat2(sin(a)+2., 0., 0., sin(a)+2.) * mat2(cos(a), -sin(a), sin(a), cos(a)) * st;\n  }\n\n  vec3 color = vec3(0.);\n\n  color += smoothstep(.45, .05 + cos(t*5.)*.18+.18, length(st));\n  color -= 1. - smoothstep(.4, .45, max(abs(st.x) + (cos(t * 5.) * .05 + .35), abs(st.y)));\n  color += 1. - smoothstep(.4, .45, max(abs(st.x), abs(st.y)));\n\n  color *= (mod(floor(p.y * 10.), 2.) == 0.) ? vec3(1., .2, .5) : vec3(.5, .2, 1.);\n\n  color *= 1. - length(vec2(uv)*.8) ;\n\n  // foreground\n  float r = cos(atan(\n    uv.y * cos(iTime) * .5 + .3,\n    uv.x * sin(iTime) * .5 + .2) * 10.) * .04 + clamp(random(uv), .198, .2);\n\n  p = vec2(uv.x + cos(t) * .2 + .2, uv.y);\n\n  color = mix(color, vec3(1.) - vec3(0., 0., vec2(length(p * p * p) * 15., 0.)), stroke(length(p), r, .15, 0.));\n  color = mix(color, vec3(.9, .9, 0.) - vec3(0., length(p) * 4., 0.), fill(length(p), r - .068, 0.));\n\n  fragColor = vec4(color, 1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WlXGzS.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 24, 24, 90], [92, 92, 147, 147, 280], [282, 282, 325, 325, 371], [373, 373, 430, 430, 1655]], "test": "ok"}
{"id": "Ws2SDK", "name": "melt sKIFS smooth paperCity", "author": "ollj", "description": "iMouse.x sets smoothness k of the kaleidoscope mirrors\n\nkaleidoscopic smin() is simpler and can be faster/prettier than expected, but it lacks context (molten trees are not ideal)\n\nsee image tab", "tags": ["kaleidoscope", "snow", "smin", "melting", "continuity", "almostidentity", "kerning", "snooth", "skifs", "sabs"], "likes": 22, "viewed": 773, "published": "Public API", "date": "1554961290", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//self  : https://www.shadertoy.com/view/Ws2SDK\n//parent: https://www.shadertoy.com/view/3dSXD1\n\n/*\niMouse.x sets smoothness k of the kaleidoscope mirrors\n\nissue:\n- kifs tend to show their mirror axes too easily\n- , and these are a lot of c1-discontinuities, sharp corners.\n- the symmetry of these mirror axes can be hidden in polar distortion\n- , but it still begs to be smoothened.\n\nNuSan, 2019-03-27\n@ollj Also I found another way to remove discontinuity\n, instead of x=abs(x), use x=smin(x,-x,-5); \nBut I'm not sure it would be great for buildings with sharps edges.\n\nthis sure lacks a lot of context, it smooths everything the same way\n- large and small walls\n- roofs and trees\n- distant and nearby things.\nand that may not be the ideal approach, it needs more scaling context.\n- it can be made faster\n\nThis shader replaces a lot of abs() with ab() or ab2()\n, where ab(a) is smoothAbs(), used for the kifs mirrroring\n, and ab() is optionally used for other abs()-contexts within ab2();\n*/\n\n#define ab2(a) abs(a)\n//#define ab2(a) ab(a)  //ab() all the ab2(), is significantly slower\n//all abs() is replaced by ab2()\n//,except the kifs-abs() is ab()\n//,and; spheretrackingEscapeTime(),Gamma(),skyTexture() \n//...have unchanged abs()\n\n//make k depend on iMouse.x\n#define sk (9.*(1.-iMouse.x/iResolution.x))\n//#define sk .5\n//#define sk 5.\n\n//(c< 0)?a:b  == less(a,b,c) == mix(a,b,step(0.,c))\n#define less(a,b,c)      mix(a,b,step(0.,c))\n\n#define sabs(x,k) less((.5/k)*x*x+k*.5,abs(x),abs(x)-k)\n\n/*  \n//expanded sabs()\nfloat sabs(float x,float k//BigWIngs, 2019-03-30: [You could also try smooth abs;]\n){float b=abs(x)   \n ;return less((.5/k)*x*x+k*.5,abs(x) ,abs(x) -k)\n //;return b<k?(.5/k)*x*x+k*.5:b\n ;}\nvec2 sabs(vec2 x,vec2 k//BigWIngs, 2019-03-30: [You could also try smooth abs;]\n){vec2 b=abs(x)\n ;return less((.5/k)*x*x+k*.5,b,b-k)\n //;return b<k?(.5/k)*x*x+k*.5:b\n ;}\nvec3 sabs(vec3 x,vec3 k//BigWIngs, 2019-03-30: [You could also try smooth abs;]\n){vec3 b=abs(x)\n  ;return less((.5/k)*x*x+k*.5,b,b-k)\n //;return b<k?(.5/k)*x*x+k*.5:b\n ;}\n*/\n\nfloat ab(float a){//toggling wrapper\n ;if(sk<.175)return abs(a)\n ;return sabs(a,sk)\n ;}\nvec2 ab(vec2 a){//toggling wrapper\n  ;if(sk<.175)return abs(a)\n ;return sabs(a,vec2(sk))\n ;}\nvec3 ab(vec3 a){//toggling wrapper\n  ;if(sk<.175)return abs(a)\n ;return sabs(a,vec3(sk))\n ;}\n\n\n/*\nparent comment:\nShader coded live on twitch (https://www.twitch.tv/nusan_fx)\nYou can lower the MARCH_STEPS and SHADOW_STEPS if too slow\nThe shader was made using Bonzomatic.\nYou can find the original shader here: http://lezanu.fr/LiveCode/PaperCity.glsl\nInspired by https://www.shadertoy.com/view/tsjGRG\n*/\n\n#define MARCH_STEPS 60\n#define SHADOW_STEPS 10\n\n#define time iTime\n#define PI acos(-1.)\n\n//distance field functions are explained on;\n//http://mercury.sexy/hg_sdf\n//https://www.iquilezles.org/www/index.htm\n\n//this implements iterative root solving via sphere-tracking\n//to calculate the distance from camera to surface along a ray.\n\nmat2 rot(float a){float c=cos(a),s=sin(a);return mat2(c,s,-s,c);}\n\nfloat box(vec3 p, vec3 s\n){vec3 ap=ab2(p)-s\n ;//return length(max(vec3(0),ap)) + min(0, max(ap.x,max(ap.y,ap.z)))\n ;return max(ap.x,max(ap.y,ap.z));}\n\nfloat tri(vec3 p, vec3 s\n){p.y=-p.y\n ;p.xz=ab2(p.xz)\n ;return max(max(-p.y-s.y, dot(p.xy,vec2(0.7))-s.x), p.z-s.z);}\n\nfloat cone(vec3 p, float a, float b\n){return max(length(p.xz)-p.y*a, p.y-b);}\n\nvec3 rep(vec3 p, vec3 s){return (fract(p/s+0.5)-0.5)*s;}\nvec2 rep(vec2 p, vec2 s){return (fract(p/s+0.5)-0.5)*s;}\nfloat rep(float p, float s){return (fract(p/s+0.5)-0.5)*s;}\n\n//above is more general library, below is more specific CSG composites:\n\nfloat house(vec3 p, float s\n){float t=tri(p+vec3(0,3,0)*s, vec3(1,1,3.5)*s)\n ;t = min(t, box(p, vec3(2,2,3)*s))\n ;return t;}\n\nfloat minitower(vec3 p\n){p.y+=5.\n ;vec3 p2 = p\n ;if(ab2(p2.x)<ab2(p2.z)) p2.xz=p2.zx\n ;float t = min(house(p+vec3(0,3,0),0.5), house(p2, 1.0))\n ;t = min(t, house(p-vec3(0,5,0),1.5))\n ;return t;}\n\nfloat tower(vec3 p\n){p.y+=15.0\n ;vec3 p2 = p\n ;if(ab2(p2.x)<ab2(p2.z)) p2.xz=p2.zx\n ;float t = min(house(p+vec3(0,3,0),0.5), house(p2, 1.0))\n ;t = min(t, house(p-vec3(0,5,0),1.5))\n ;p2.x -= sign(p2.x)*5.0\n ;p2.x = ab2(p2.x)\n ;p2.z = ab2(p2.z)\n ;t = min(t, house(p2.zyx-vec3(2,8,2),0.3))\n ;t = min(t, house(p2-vec3(0,12,0),1.5))\n ;return t;}\n\nfloat wall(vec3 p\n){p.x -= cos(p.z*0.1)*2.0\n ;p.x -= sin(p.z*0.03)*3.0\n ;vec3 rp=p\n ;rp.z = rep(rp.z, 5.0)\n ;float w = box(rp+vec3(0,1,0), vec3(2,1,50))\n ;rp.x = ab2(rp.x)-2.0\n ;float m = box(rp-vec3(0,2,0), vec3(0.25,5,1.6))\n ;return min(w, m);}\n\nfloat field(vec3 p\n){vec3 p2 = p\n ;if(ab2(p2.x)<ab2(p2.z)) p2.xz=p2.zx\n ;float tmp = box(p2, vec3(5,5,5));\n  float f = max(ab2(tmp-4.0), -p.y-2.0);\n  f=min(f, box(p, vec3(7,0.5,7)));\n  \n  vec3 p3 = p;\n  p3.xz=rep(p3.xz, vec2(2.5));\n  \n  float a = box(p3, vec3(0.2,2,0.2));\n  a = min(a, cone(p3+vec3(0,4,0), 0.3,3.0));\n  f=min(f, max(a,tmp-3.8));\n  \n  return f;\n}\n\nfloat village(vec3 p\n){\n  vec3 p2=p;\n  p2.xz = ab2(p2.xz);\n  float w = wall(p);\n  p2.xz -= 23.0;\n  float t=tower(p2);\n  vec3 p3 = p;\n  p3.z = p3.z-4.5*sign(p.x);\n  p3.x = ab2(p3.x)-25.0;\n  float f=field(p3);\n  \n  float res = t;\n  res = min(res, w);\n  res = min(res, f);\n  \n /*\n  p2.xz*=rot(0.3);\n  res = min(res, house(p2+vec3(13,0,0), 1));\n  p2.xz*=rot(0.6);\n  res = min(res, house(p2+vec3(18,1,-2.5), 1.5));\n  */\n  p.z = p.z+10.0*sign(p.x);\n  p.x = -ab2(p.x);\n  res = min(res, minitower(p+vec3(29,1,0)));\n  \n  return res;\n}\n\nfloat map(vec3 p\n){float t1=sin(length(p.xz)*0.009)//distort\n ;float s=12.0\n ;for(int i=0; i<6; ++i//kifs iterations\n ){p.xz=ab(p.xz)-s//kifs mirror axis is always ab() smoothened\n  ;p.xz *= rot(0.55+t1+float(i)*0.34)//kifs rotation\n  ;s/=.85//kifs scale\n  ;}\n ;p.x+=3.\n ;return min(village(p),-p.y);}\n\nfloat getao(vec3 p, vec3 n, float dist) {\n  return clamp(map(p+n*dist)/dist, 0.0, 1.0);\n}\n\nfloat noise(vec2 p\n){\n  vec2 ip=floor(p);\n  p=smoothstep(0.0,1.0,fract(p));\n  vec2 st=vec2(67,137);\n  vec2 v=dot(ip,st)+vec2(0,st.y);\n  vec2 val=mix(fract(sin(v)*9875.565), fract(sin(v+st.x)*9875.565), p.x);\n  return mix(val.x,val.y,p.y);\n}\n\nfloat fractal(vec2 p\n){float d=0.5\n ;float v=0.0\n ;for(int i=0; i<5; ++i\n ){v+=noise(p/d)*d\n  ;d *= 0.5\n  ;}\n ;return v;}\n\nvec3 sky(vec3 r, vec3 l\n){float v=pow(max(dot(r,l),0.0),3.0)\n //sky texture UV abs() is not smoothened\n ;vec2 sphereuv = vec2(abs(atan(r.z,r.x))+time*0.03,atan(r.y,length(r.xz)))\n ;float skyn = fractal(sphereuv*vec2(5,10))\n ;float skyn2 = fractal(sphereuv*vec2(5,10)*0.3-vec2(time*0.06,0))\n ;skyn2=smoothstep(0.3,0.7,skyn2)\n ;vec3 blue = mix(vec3(0.5,0.5,0.8), vec3(0.0), skyn2*skyn)\n ;return mix(blue*0.2, vec3(1,0.7,0.4)*(skyn2*0.8+0.2), v);}\n\nvec3 sky2(vec3 r, vec3 l\n){float v=pow(max(dot(r,l),0.0),3.0)\n ;vec3 blue = vec3(0.5,0.5,0.8)\n ;return mix(blue*0.2, vec3(1,0.7,0.4), v);}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord\n){vec2 uv = vec2(fragCoord.x / iResolution.x, fragCoord.y / iResolution.y);\n  uv -= 0.5;\n  uv /= vec2(iResolution.y / iResolution.x, 1);\n  float t2=time+10.0;\n  vec3 s=vec3(0,0,-100);\n  s.yz *= rot(sin(t2*0.3)*0.2+0.5);\n  s.xz *= rot(t2*0.2);\n  vec3 t=vec3(0,30,60);\n  t.yz *= rot(sin(t2)*0.3-0.2);\n  t.xz *= rot(t2*0.32)\n  ;vec3 cz=normalize(t-s)\n  ;vec3 cx=normalize(cross(cz,vec3(0,1,0)))\n  ;vec3 cy=normalize(cross(cz,cx))\n  ;//vec3 r=normalize(vec3(-uv, 0.7))\n  ;vec3 r=normalize(uv.x*cx+uv.y*cy+cz*0.7)\n  ;vec3 p=s\n  ;float dd=0.\n  ;for(int i=0; i<MARCH_STEPS; ++i//spheretracking loop\n  ){float d=map(p)\n   ;if(abs(d)<0.001) break//rootSolveEscapeTime is not smoothened\n   ;if(dd>500.0) {dd=500.0; break;}\n   ;p+=d*r*0.8\n   ;dd+=d;}\n  //shade point at distance dd:\n  ;float fog=1.-clamp(dd/500.0,0.,1.)\n  ;vec3 col=vec3(0)\n  ;vec2 off=vec2(0.01,0)\n  ;vec3 n=normalize(map(p)-vec3(map(p-off.xyy), map(p-off.yxy), map(p-off.yyx)))\n  ;float ao=(getao(p, n, 12.0) * 0.5 + 0.5) * (getao(p, n, 2.0) * 0.3 + 0.7) * (getao(p, n, 0.5) * 0.8 + 0.2)\n  ;vec3 l=normalize(vec3(-1,-2,-2.5))\n  ;float f = pow(1.0-abs(dot(n,r)), 3.0);//gamma is not smoothened\n  \n  ;float shad=1.\n  ;vec3 sp=p+n*.5-r*.2//light source (here its parallel global illumination)\n  ;for(int i=0; i<SHADOW_STEPS; ++i//shadow loop\n  ){float d=map(sp)\n   ;if(d<0.2){shad = 0.0;break;}\n   ;sp+=d*l*3.0;}\n  \n  col += max(0.0,dot(n,l)) * fog * vec3(1,0.7,0.4) * 1.5 * mix(0.0, ao*0.5+0.5, shad);\n  col += (-n.y*0.5+0.5) * ao * fog * vec3(0.5,0.5,0.8) * 0.5;\n  col += sky2(reflect(r,n), l)*f*10.0*fog * (0.5+0.5*shad);\n  col += sky(r, l) * pow(dd*0.01,1.4);\n  //col = vec3(shad);//incomment tor high contrast shadow\n  col = 1.0-exp(-col*2.5);\n  col = pow(col, vec3(2.3));\n  col = pow(col, vec3(0.4545));\n  col.g+=.07; //tint green to differentiate from parent.\n  fragColor = vec4(col, 1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Ws2SDK.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[2054, 2054, 2072, 2090, 2141], [2142, 2142, 2158, 2176, 2234], [2235, 2235, 2251, 2269, 2327], [2974, 2974, 2992, 2992, 3039], [3041, 3041, 3068, 3068, 3190], [3192, 3192, 3219, 3219, 3308], [3310, 3310, 3348, 3348, 3387], [3389, 3389, 3414, 3414, 3445], [3446, 3446, 3471, 3471, 3502], [3503, 3503, 3531, 3531, 3562], [3637, 3637, 3667, 3667, 3761], [3763, 3763, 3788, 3788, 3957], [3959, 3959, 3980, 3980, 4299], [4301, 4301, 4321, 4321, 4547], [4549, 4549, 4570, 4570, 4911], [4913, 4913, 4936, 4936, 5438], [5440, 5440, 5459, 5459, 5741], [5743, 5743, 5784, 5784, 5832], [5834, 5834, 5855, 5855, 6074], [6076, 6076, 6099, 6099, 6197], [6199, 6199, 6225, 6225, 6643], [6645, 6645, 6672, 6672, 6783], [6786, 6786, 6842, 6842, 8691]], "test": "timeout"}
{"id": "ws2SDt", "name": "bonfire vortex", "author": "jsharifi", "description": "inspired by the phoenix mascot for Bonfire Studios", "tags": ["radial", "distance"], "likes": 0, "viewed": 75, "published": "Public", "date": "1555391348", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec2 Rotate(vec2 v, float a) {\n    return(vec2(v.x * cos(a) - v.y * sin(a), v.x * sin(a) + v.y * cos(a)));\n}\n\nvec2 Hatch(vec2 uv) {\n    float c = cos(6.28 * cos(6.28 * uv.x + 233.25 + cos(iTime)));\n    float s = sin(6.28 * sin(6.28 * uv.y + 345.43 + sin(iTime)));\n    return(vec2(c, s));\n}\n\nvec2 Multihatch(vec2 init) {\n    vec2 uv1 = Rotate(init, 0.5 + iTime * 0.1);   \n    vec2 uv2 = Rotate(init, 1.0 + iTime * 0.1);\n    vec2 uv3 = Rotate(init, 1.5 + iTime * 0.1);\n    vec2 uv4 = Rotate(init, 2.0 + iTime * 0.1);\n    return(Hatch(uv1) + Hatch(uv2) + Hatch(uv3) + Hatch(uv4));\n}\n\nconst float nfreq = 3.14 * 1.0;\nfloat cNoise(float v1, float v2, float v3, float v4) {\n    return(cos(\n        cos(v1 * -cos(iTime * 0.5 + 1.0) * nfreq) * sin(v2 * sin(iTime * 0.2 + 3.0) * nfreq) + \n        cos(v3 * -sin(iTime * 0.3 + 2.0) * nfreq) * cos(v4 * cos(iTime * 0.3 + 4.0) * nfreq)\n    ) * 0.5 + 0.5);\n}\n\nvec3 colorQuery(float a) {\n    const int count = 12;\n    const vec3 color_lut[count] = vec3[count] (\n        // dark blues\n        vec3(0.3, 0.1, 0.6),\n        vec3(0.2, 0.1, 0.7),\n        vec3(0.1, 0.1, 0.3),\n        \n        // light blues\n        vec3(0.7, 0.5, 0.9),\n        vec3(0.2, 0.9, 0.9),\n        vec3(0.1, 0.0, 0.2),\n        \n        // dark red\n        vec3(0.4, 0.2, 0.2),\n        vec3(0.5, 0.1, 0.6),\n        vec3(0.9, 0.3, 0.2),\n        \n        // light red\n        vec3(0.7, 0.5, 0.3),\n        vec3(0.8, 0.3, 0.2),\n        vec3(0.0, 0.1, 0.0)\n        );\n    float rescale = float(count) * a;\n    int ind1 = int(rescale) % count;\n    int ind2 = int(rescale + 1.0) % count;\n\n    return(mix(color_lut[ind1], color_lut[ind2], fract(rescale)));\n}\n\nconst float hashing_freq = 0.04;\nconst float spiral_freq = 0.9;\nconst float arm_count = 1.0;\nconst float p_spiral = 0.1;\nconst float p_time = 0.1;\nconst float spiral_out_speed = -20.0;\nconst float spiral_out_length = 0.5;\nconst float spiral_shades = 3.0;\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord/iResolution.xy - 0.5) * 3.14;\n    // remap uniform surface into a bubbly surface\n    uv = mix(uv, Multihatch(uv), hashing_freq);\n\n    // angle of uv coordinates\n    float theta = atan(uv.y, uv.x) + 3.0;\n    // distance from 0\n    float d = cos(uv.x) * cos(uv.y) / spiral_freq;\n    // composition of theta and d produces spiral\n    float spiral = cos(d * spiral_out_speed + theta * arm_count);\n    // dark highlights\n\tfloat vignette = cNoise(uv.x, spiral, d, uv.y);\n \n    // color is darkened by vig, queries a lookup table based on uv coordinates and time\n    vec3 col = vignette * colorQuery(sin(d * spiral_out_length) * spiral_shades + \n                        p_spiral * spiral + \n                        p_time * iTime);\n\n    // Output to screen\n    fragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ws2SDt.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 30, 30, 108], [110, 110, 131, 131, 289], [291, 291, 319, 319, 579], [613, 613, 667, 667, 894], [896, 896, 922, 922, 1655], [1912, 1912, 1969, 2019, 2828]], "test": "error"}
{"id": "ws2XDG", "name": "Finals_Shader02_Co", "author": "johannco98", "description": "asd", "tags": ["asd"], "likes": 1, "viewed": 37, "published": "Public", "date": "1554889809", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float rect(vec2 uv, vec2 pos, float width, float height)\n{\n    float square = (step(pos.x - width, uv.x) - step(pos.x + width, uv.x)) *\n                   (step(pos.y - height, uv.y) - step(pos.y + height, uv.y));\n    \n    \n    return square;\n}\n\nfloat Circle(vec2 uv, vec2 pos, float rad, float blur) \n{\n\tfloat d = length(uv-pos);\n\tfloat t = smoothstep(rad, rad-blur, d);\n    \n    \n\treturn t;\n}\n\nfloat rand(vec2 uv)\n{\n    //return fract(sin(dot(uv, vec2(12.9898,78.233)))*10000.*iTime);\n\t//return fract(sin(dot(uv, iMouse.xy))*10000.);\n\t//return (fract(sin(dot(uv, vec2(12., 70.)))*100000.));\n    return (fract(sin(dot(uv, vec2(12., 70.)))*43758.5453123));\n}\n\n// Value noise\nfloat noise(in vec2 st) {\n    vec2 i = floor(st);\n    vec2 f = fract(st);\n\n    // Four corners in 2D of a tile\n    float a = rand(i);\n    float b = rand(i + vec2(1.0, 0.0));\n    float c = rand(i + vec2(0.0, 1.0));\n    float d = rand(i + vec2(1.0, 1.0));\n\n    // Smooth Interpolation\n\n    // Cubic Hermine Curve.  Same as SmoothStep()\n    vec2 u = f*f*(3.0-2.0*f);\n    // u = smoothstep(0.,1.,f);\n\n    // Mix 4 coorners porcentages\n    return mix(a, b, u.x) + \n            (c - a)* u.y * (1.0 - u.x) + \n            (d - b) * u.x * u.y;\n}\n\n// Gradient noise\nvec2 hash( vec2 x )  // replace this by something better\n{\n    const vec2 k = vec2( 0.3183099, 0.3678794 );\n    x = x*k + k.yx;\n    return -1.0 + 2.0*fract( 16.0 * k*fract( x.x*x.y*(x.x+x.y)) );\n}\n\nfloat gnoise( in vec2 p )\n{\n    vec2 i = floor( p );\n    vec2 f = fract( p );\n\t\n\tvec2 u = f*f*(3.0-2.0*f);\n\n    return mix( mix( dot( hash( i + vec2(0.0,0.0) ), f - vec2(0.0,0.0) ), \n                     dot( hash( i + vec2(1.0,0.0) ), f - vec2(1.0,0.0) ), u.x),\n                mix( dot( hash( i + vec2(0.0,1.0) ), f - vec2(0.0,1.0) ), \n                     dot( hash( i + vec2(1.0,1.0) ), f - vec2(1.0,1.0) ), u.x), u.y);\n}\n\n// Simplex noise\nvec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec2 mod289(vec2 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec3 permute(vec3 x) { return mod289(((x*34.0)+1.0)*x); }\n\nfloat snoise(vec2 v) {\n    const vec4 C = vec4(0.211324865405187,  // (3.0-sqrt(3.0))/6.0\n                        0.366025403784439,  // 0.5*(sqrt(3.0)-1.0)\n                        -0.577350269189626,  // -1.0 + 2.0 * C.x\n                        0.024390243902439); // 1.0 / 41.0\n    vec2 i  = floor(v + dot(v, C.yy) );\n    vec2 x0 = v -   i + dot(i, C.xx);\n    vec2 i1;\n    i1 = (x0.x > x0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);\n    vec4 x12 = x0.xyxy + C.xxzz;\n    x12.xy -= i1;\n    i = mod289(i); // Avoid truncation effects in permutation\n    vec3 p = permute( permute( i.y + vec3(0.0, i1.y, 1.0 ))\n        + i.x + vec3(0.0, i1.x, 1.0 ));\n\n    vec3 m = max(0.5 - vec3(dot(x0,x0), dot(x12.xy,x12.xy), dot(x12.zw,x12.zw)), 0.0);\n    m = m*m ;\n    m = m*m ;\n    vec3 x = 2.0 * fract(p * C.www) - 1.0;\n    vec3 h = abs(x) - 0.5;\n    vec3 ox = floor(x + 0.5);\n    vec3 a0 = x - ox;\n    m *= 1.79284291400159 - 0.85373472095314 * ( a0*a0 + h*h );\n    vec3 g;\n    g.x  = a0.x  * x0.x  + h.x  * x0.y;\n    g.yz = a0.yz * x12.xz + h.yz * x12.yw;\n    return 130.0 * dot(m, g);\n}\n\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n     //Colors in vec3\n    vec3 red = vec3(0.8 ,0.0 ,0.0);\n    vec3 white = vec3(1.0, 1.0, 1.0);\n    vec3 yellow = vec3(0.9, 0.9, 0.3);\n    vec3 blue = vec3(0.5, 0.8, 0.9);\n    vec3 black = vec3(0.0, 0.0, 0.0);\n    vec3 green = vec3(0.0, 1.0, 0.0);\n\n    \n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    uv *= 5.0;\n    float value = gnoise(uv + (sin(iTime) * 0.005));\n    \n    float bar = step(0.1 + value, uv.x) - step(0.2, uv.x);\n    \n    float a = snoise(uv + iTime);\n    \n    //right\n    a = abs(gnoise(uv + snoise(sin(uv + iTime) + iTime) + iTime)*50.0);\n    \n    a = gnoise(uv + iTime)*snoise(uv + iTime) * 100.;\n    //a = (step(0.2*a, uv.y - 0.8 ) - step(3.9*a, uv.y - 0.8));\n    \n    //left\n    float val = noise(uv + iTime );\n    \n    //combine\n    val = mix(val, a, step(0.3, uv.x));\n    \n    //waves\n    val = step(0.48*val, uv.y) - step(0.5*val, uv.y);\n    val = val * sin(rand(uv/100000.)*iTime) * a;\n    val = mix(val , a, step(uv.y, 2.5 + sin(iTime) * 2.5));\n    \n    \n    \n    \n    \n    \n    \n    \n    // Output to screen\n    fragColor = vec4(val);\n    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ws2XDG.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 58, 58, 244], [246, 246, 303, 303, 394], [396, 396, 417, 592, 658], [660, 675, 700, 700, 1211], [1213, 1231, 1289, 1289, 1427], [1429, 1429, 1456, 1456, 1854], [1856, 1873, 1894, 1894, 1941], [1942, 1942, 1963, 1963, 2010], [2011, 2011, 2033, 2033, 2068], [2070, 2070, 2092, 2092, 3140], [3145, 3145, 3202, 3224, 4318]], "test": "ok"}
{"id": "ws2XDy", "name": "Finals_Shader07_Co", "author": "johannco98", "description": "asd", "tags": ["asd"], "likes": 1, "viewed": 42, "published": "Public", "date": "1554900198", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float rect(vec2 uv, vec2 pos, float width, float height)\n{\n    float square = (step(pos.x - width, uv.x) - step(pos.x + width, uv.x)) *\n                   (step(pos.y - height, uv.y) - step(pos.y + height, uv.y));\n    \n    \n    return square;\n}\n\nfloat Circle(vec2 uv, vec2 pos, float rad, float blur) \n{\n\tfloat d = length(uv-pos);\n\tfloat t = smoothstep(rad, rad-blur, d);\n    \n    \n\treturn t;\n}\n\nfloat rand(vec2 uv)\n{\n    //return fract(sin(dot(uv, vec2(12.9898,78.233)))*10000.*iTime);\n\t//return fract(sin(dot(uv, iMouse.xy))*10000.);\n\t//return (fract(sin(dot(uv, vec2(12., 70.)))*100000.));\n    return (fract(sin(dot(uv, vec2(12., 70.)))*43758.5453123));\n}\n\n// Value noise\nfloat noise(in vec2 st) {\n    vec2 i = floor(st);\n    vec2 f = fract(st);\n\n    // Four corners in 2D of a tile\n    float a = rand(i);\n    float b = rand(i + vec2(1.0, 0.0));\n    float c = rand(i + vec2(0.0, 1.0));\n    float d = rand(i + vec2(1.0, 1.0));\n\n    // Smooth Interpolation\n\n    // Cubic Hermine Curve.  Same as SmoothStep()\n    vec2 u = f*f*(3.0-2.0*f);\n    // u = smoothstep(0.,1.,f);\n\n    // Mix 4 coorners porcentages\n    return mix(a, b, u.x) + \n            (c - a)* u.y * (1.0 - u.x) + \n            (d - b) * u.x * u.y;\n}\n\n// Gradient noise\nvec2 hash( vec2 x )  // replace this by something better\n{\n    const vec2 k = vec2( 0.3183099, 0.3678794 );\n    x = x*k + k.yx;\n    return -1.0 + 2.0*fract( 16.0 * k*fract( x.x*x.y*(x.x+x.y)) );\n}\n\nfloat gnoise( in vec2 p )\n{\n    vec2 i = floor( p );\n    vec2 f = fract( p );\n\t\n\tvec2 u = f*f*(3.0-2.0*f);\n\n    return mix( mix( dot( hash( i + vec2(0.0,0.0) ), f - vec2(0.0,0.0) ), \n                     dot( hash( i + vec2(1.0,0.0) ), f - vec2(1.0,0.0) ), u.x),\n                mix( dot( hash( i + vec2(0.0,1.0) ), f - vec2(0.0,1.0) ), \n                     dot( hash( i + vec2(1.0,1.0) ), f - vec2(1.0,1.0) ), u.x), u.y);\n}\n\n// Simplex noise\nvec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec2 mod289(vec2 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec3 permute(vec3 x) { return mod289(((x*34.0)+1.0)*x); }\n\nfloat snoise(vec2 v) {\n    const vec4 C = vec4(0.211324865405187,  // (3.0-sqrt(3.0))/6.0\n                        0.366025403784439,  // 0.5*(sqrt(3.0)-1.0)\n                        -0.577350269189626,  // -1.0 + 2.0 * C.x\n                        0.024390243902439); // 1.0 / 41.0\n    vec2 i  = floor(v + dot(v, C.yy) );\n    vec2 x0 = v -   i + dot(i, C.xx);\n    vec2 i1;\n    i1 = (x0.x > x0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);\n    vec4 x12 = x0.xyxy + C.xxzz;\n    x12.xy -= i1;\n    i = mod289(i); // Avoid truncation effects in permutation\n    vec3 p = permute( permute( i.y + vec3(0.0, i1.y, 1.0 ))\n        + i.x + vec3(0.0, i1.x, 1.0 ));\n\n    vec3 m = max(0.5 - vec3(dot(x0,x0), dot(x12.xy,x12.xy), dot(x12.zw,x12.zw)), 0.0);\n    m = m*m ;\n    m = m*m ;\n    vec3 x = 2.0 * fract(p * C.www) - 1.0;\n    vec3 h = abs(x) - 0.5;\n    vec3 ox = floor(x + 0.5);\n    vec3 a0 = x - ox;\n    m *= 1.79284291400159 - 0.85373472095314 * ( a0*a0 + h*h );\n    vec3 g;\n    g.x  = a0.x  * x0.x  + h.x  * x0.y;\n    g.yz = a0.yz * x12.xz + h.yz * x12.yw;\n    return 130.0 * dot(m, g);\n}\n\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n     //Colors in vec3\n    vec3 red = vec3(0.8 ,0.0 ,0.0);\n    vec3 white = vec3(1.0, 1.0, 1.0);\n    vec3 yellow = vec3(0.9, 0.9, 0.3);\n    vec3 blue = vec3(0.5, 0.8, 0.9);\n    vec3 black = vec3(0.0, 0.0, 0.0);\n    vec3 green = vec3(0.0, 1.0, 0.0);\n\n    \n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    uv *= 4.0;\n    float value = gnoise(uv + (sin(iTime) * 0.005));\n    \n    //music shiz\n    float val = noise(uv + (iTime) * (iTime * 0.001) - (uv.x*10.));\n    \n    //val = val + gnoise(uv * snoise(uv * rand(uv)) * noise(uv * rand(uv)) + iTime + rand(uv*iTime));\n    //val = val * noise(uv + (iTime) * (iTime * 0.005) - abs(uv.x*clamp(sin(iTime), 0.0, 1.0)) * 100.0);\n    val = val + snoise(uv + (iTime * 1.0) + vec2(0.0, -iTime*2.0));\n    \n    \n    //waves\n    val = step(-0.1*val, uv.y) - step(2.5*val, uv.y);\n    \n    \n    vec3 lampLight = abs(vec3(\n        \t\t\t\t  clamp(abs(sin(iTime)),0.3 , 0.8 ),\n                          clamp(abs(cos(iTime)),0.4 , 0.9 ), \n                          clamp(abs(sin(iTime)),0.4 , 1.0 ))\n                        \t );\n    \n    \n    vec3 Val = mix(lampLight, black, val);\n    Val = mix(lampLight, black, Val);\n    \n    float ratio = iResolution.x/iResolution.y;\n    uv.x *= ratio * 0.25;\n    uv.y += 0.5;\n    \n    vec2 shapePos = vec2((0.5 * ratio) /*plus minus something to adjust Pos*/, 0.5);\n    float dist = distance(shapePos , uv) * 2.50;\n \n    \n    uv -= shapePos;\n    \n    float angle = atan(uv.y, uv.x);\n    \n    float radius = sin(4.0 * angle);\n    radius = smoothstep(-0.75 , 1.0,  cos(angle * 8.0 + iTime * 15.0)  ) * 0.2 + 0.4;\n   \n    float radius2 =  1.0 /  abs(cos(angle * 10000.0 + iTime) * sin(angle * 7.0 + iTime)) * 0.5 + 0.1;\n\t\n    value =  step(radius + radius2 * clamp(sin(iTime * 0.0)+1.2,0.1, 3.0), dist);\n    \n   \n    // Output to screen\n    fragColor = vec4(value * Val, 1.0);\n    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ws2XDy.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 58, 58, 244], [246, 246, 303, 303, 394], [396, 396, 417, 592, 658], [660, 675, 700, 700, 1211], [1213, 1231, 1289, 1289, 1427], [1429, 1429, 1456, 1456, 1854], [1856, 1873, 1894, 1894, 1941], [1942, 1942, 1963, 1963, 2010], [2011, 2011, 2033, 2033, 2068], [2070, 2070, 2092, 2092, 3140], [3145, 3145, 3202, 3224, 5093]], "test": "ok"}
{"id": "Ws2XRK", "name": "butterfly fractal", "author": "smkgames", "description": "feather fractal", "tags": ["fractal"], "likes": 11, "viewed": 346, "published": "Public API", "date": "1554367911", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//Created By Seyed Morteza Kamali\n\n#define accurate 10.\n\nvec3 hsv2rgb( in vec3 c ) {\n  vec3 rgb = clamp( abs(mod(c.x*1.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n  return c.z * mix( vec3(1.0), rgb, c.y);\n}\n\nvec3 getCol(vec3 n){\n  return hsv2rgb(vec3(mod(n.z*100.,1.0),1.,0.8));\n}\n\nmat2 rotate2d(float _angle){\n    return mat2(cos(_angle),-sin(_angle),\n                sin(_angle),cos(_angle));\n}\n\nvec3 pixelColor(vec2 p)\n{\n    \n    \n    p = vec2(p.x, -p.y) / length((p*p)) ;\n\n    \n    \n  vec2 z = vec2(p);  \n  for (float i = 1.; i <= accurate; i++)\n    {  \n\n    z = vec2(z.x*z.x - z.y*z.y, 2.0*z.x*z.y) + p; \n    z.x *= mix(1.,atan(i,i)/2.9,abs(cos(iTime)));\n   \n   // z += vec2(z.x*z.x - z.y*z.y, 2.0*z.x*z.y);     \n\n    if (504.0 + 300.0 < dot(z, p))\n        {\n      return getCol(vec3(0.,0.,z.x));\n    }\n  }\n\n    \n    \n    return vec3(1.);\n    \n}\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    \n    \n    \n  vec2 c = 1.8*(-2.0*fragCoord.xy/iResolution.xy + 0.9)*vec2(iResolution.x/iResolution.y, 1.0) + vec2(0.25, 0.2);\n    \n\tc = rotate2d(4.705)*c;\n    \n    float a = 2.0;\n    float e = 1.0/min(iResolution.x, iResolution.y);    \n    vec3 col = vec3(0.0);\n    \n    for (float j = -a; j < a; j++)\n        for (float i = -a; i < a; i++)\n            col += pixelColor(c + 2.1*vec2(i, j) * (e/a)) / (4.0*a*a);\n\n  fragColor = vec4(col, 1.0);\n    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Ws2XRK.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[57, 57, 84, 84, 209], [211, 211, 231, 231, 283], [285, 285, 313, 313, 399], [401, 401, 426, 426, 853], [856, 856, 911, 911, 1364]], "test": "ok"}
{"id": "WsBSDd", "name": "blob factory2", "author": "tristanwhitehill", "description": "sinnnneee", "tags": ["blob"], "likes": 3, "viewed": 93, "published": "Public", "date": "1555266328", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n \n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 r = vec2( fragCoord.xy +sin(.05 * iTime)*2.0 *iResolution.xy );\n\t\n\tr = 2.0 * r.xy / iResolution.xy;\n   float colorwave=sin(.5 * iTime)*4.0;\n    vec3 col1 = vec3 (0.7,0.9,.2*colorwave);\n    vec3 col2 = vec3 (0.3,0.8,.5*colorwave);\n     vec3 col3 = vec3 (0.1,0.9,.4*colorwave);\n    vec3 pixi;\n    \n    float width = (sin(.05 * iTime)*2.0);\n    float width2 = sin(cos(.06 * iTime)*6.0);\n    float mody = dot(width*width2,sin(cos(r.x+iTime)*10.));\n    float mody2 = dot(width*width2,sin(cos(r.x+iTime*.03)*20.));\n    if(sin(sin(iTime+r.x*.5))/r.y> mody){\n        \n        pixi = col1;\n        \n    \t}\n    else {\n        \n        pixi = col2;\n    \n        }\n      if(sin(sin(iTime+r.y*.4))/r.x < mody2){\n        \n        pixi = col3;\n        \n    \t}\n\n    fragColor = vec4(pixi,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WsBSDd.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 888]], "test": "error"}
{"id": "wsBSWG", "name": "Raytracing Infinite Plane 3D", "author": "bloxard", "description": "Raytracing an infinite plane in 3D and mapping a grid onto it.", "tags": ["3d", "raytracing", "intersection", "plane", "analytical"], "likes": 4, "viewed": 301, "published": "Public", "date": "1554821601", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//Created by Per Bloksgaard/2019\n//Raytracing an infinite plane in 3D and mapping a grid onto it.\n\nmat3 setupRotationMatrix(vec3 ww)\n{\n  vec3 uu = normalize(cross(ww,vec3(0.,1.,0.)));\n  vec3 vv = normalize(cross(uu,ww));\n  return mat3(uu,vv,ww);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n  vec3 vCamPos = vec3(cos(iTime*0.5)*1.6,0.,sin(iTime*0.5)*1.6);\n  vec3 vCamTarget = vec3(0.,-1.3,0.);\n  vec3 vCamForward = normalize(vCamTarget-vCamPos);\n  vec3 vCamRight = normalize(cross(vCamForward,vec3(0.,1.,0.)));\n  vec3 vCamUp = normalize(cross(vCamRight,vCamForward));\n  vec3 vPlanePos = vec3(0.,-1.,0.);\n  vec3 vPlaneRight = vec3(1.,0.,0.);\n  vec3 vPlaneUp = vec3(0.,0.,1.);\n  vec3 vForwardRot = normalize(vec3(cos(iTime*0.5),sin(iTime*0.3)*0.9,cos(iTime*0.7)*0.2));\n  mat3 m = setupRotationMatrix(vForwardRot);\n  vPlaneRight *= m;\n  vPlaneUp *= m;\n  vec3 vPlaneNormal = normalize(cross(vPlaneRight,vPlaneUp));\n  float fPlaneDeltaNormalDistance = dot(vPlanePos - vCamPos,vPlaneNormal);\n  vec3 color = vec3(0.);\n  for(int m=0; m<2; m++)\n  {\n    for(int n=0; n<2; n++)\n    {\n      vec2 s = (-iResolution.xy+2.*(gl_FragCoord.xy+(vec2(float(m),float(n))*0.5-0.5)))/iResolution.y;\n      vec3 vRayDir = normalize(s.x*vCamRight+s.y*vCamUp+vCamForward*1.3);\n      float t = fPlaneDeltaNormalDistance / dot(vPlaneNormal,vRayDir);\n      vec3 hitPos = vCamPos + vRayDir*t;\n      vec3 delta = hitPos - vPlanePos;\n      vec2 bary = vec2(dot(delta, vPlaneRight),dot(delta, vPlaneUp));\n      vec2 grid = (70.7+t*0.1)-pow(vec2(2.5-t*0.03),abs(vec2(0.5)-fract(bary*4.))*10.2);\n      color += vec3(clamp(min(grid.x,grid.y),0.,1.))*clamp(1.-t*0.15,0.,1.)*step(0.,t);\n    }\n  }\n  fragColor = vec4(color*0.25,1.);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wsBSWG.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[99, 99, 134, 134, 247], [249, 249, 304, 304, 1708]], "test": "ok"}
{"id": "wsBXDt", "name": "Random Tiled Pattern", "author": "Shane", "description": "Creating a distance field value for a random tiled pattern, then applying image software layering techniques to produce a raised-looking hand drawn image.", "tags": ["random", "truchet", "pattern", "tile", "photoshop", "layer"], "likes": 33, "viewed": 1302, "published": "Public API", "date": "1555417901", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/*\n\n\tRandom Tiled Pattern\n\t--------------------\n\n\tCreating a distance field value for a random tiled pattern, then applying standard image \n\tsoftware layering techniques to produce a raised-looking hand drawn image.\n\n\tI used to love playing around with Photoshop, but haven't used it since Adobe moved to the \n    subscription model, which the 90s internet user in me isn't comfortable with. Regardless, \n\tI still like to apply Photoshop layering principles in Shadertoy.\n\n\tMost of the techniques used in this example employ common sense: Create a 2D vector field, \n    then render various layers over the top of one another. For instance, a black field shape \n\tfollowed by a slightly thinner colored one will give the appearance of a colored vector \n\timage with a dark stroke line, and so forth. Render a faded shape with an offset position \n\tonto the background prior to rendering the other layers, and you have yourself a shadow, \n\tetc.\n\t\n\tThe pattern itself is nothing special, but I like the way it looks. The most common square\n\tTruchet tile consists of a couple of arc lines. This one is constructed via a few more arc \n\tlines in each tile, whilst still maintaining rotational symmetry. You can see a similar \n\texample in the paper \"Truchet Tiles Revisited,\" which I've provided a link to below. \n\tHowever, uncommenting the \"SHOW_GRID\" define should give you a fair idea.\n\n \tI went for a kind of grungey hand drawn style... Probably not to everyone's taste, but with \n\ta bit of imagination, all kinds of styles are possible. Just for fun, and to keep Dr2 happy, \n\tI produced my own texture, which is just a mixture of noise and color. I coded this in the \n\t800 by 450 window on a 17 inch laptop, but have tried to keep it looking similar in other \n\tscreen settings.\n\n\n\n\tPattern based on an image in the following paper:\n\n\tTruchet Tiles Revisited - Robert J. Krawczyk\n\thttp://mypages.iit.edu/~krawczyk/rjkisama11.pdf\n\n\n\n\n*/\n\n// Show the square grid markings, which enables the viewer to see the individual tiles.\n//#define SHOW_GRID\n\n\n// Shorthand.\n#define sstep(sf, d) (1. - smoothstep(0., sf, d))\n\n\n// Standard 2D rotation formula.\nmat2 rot2(in float a){ float c = cos(a), s = sin(a); return mat2(c, -s, s, c); }\n\n\n// IQ's standard vec2 to float hash formula.\nfloat hash21(vec2 p){\n \n    float n = dot(p, vec2(127.183, 157.927));\n    return fract(sin(n)*43758.5453);\n}\n\n\n// Cheap and nasty 2D smooth noise function with inbuilt hash function -- based on IQ's \n// original. Very trimmed down. In fact, I probably went a little overboard. I think it \n// might also degrade with large time values.\nfloat n2D(vec2 p) {\n\n\tvec2 i = floor(p); p -= i; p *= p*(3. - p*2.);  \n    \n\treturn dot(mat2(fract(sin(vec4(0, 1, 113, 114) + dot(i, vec2(1, 113)))*43758.5453))*\n                vec2(1. - p.y, p.y), vec2(1. - p.x, p.x) );\n\n}\n\n// FBM -- 4 accumulated noise layers of modulated amplitudes and frequencies.\nfloat fbm(vec2 p){ return n2D(p)*.533 + n2D(p*2.)*.267 + n2D(p*4.)*.133 + n2D(p*8.)*.067; }\n\n\n// Distance field for the grid tile.\nfloat TilePattern(vec2 p){\n    \n     \n    vec2 ip = floor(p); // Cell ID.\n    p -= ip + .5; // Cell's local position. Range [vec2(-.5), vec2(.5)].\n    \n     \n    // Using the cell ID to generate a unique random number.\n    float rnd = hash21(ip);\n    float rnd2 = hash21(ip + 27.93);\n    //float rnd3 = hash21(ip + 57.75);\n     \n    // Random tile rotation.\n    float iRnd = floor(rnd*4.);\n    p = rot2(iRnd*3.14159/2.)*p;\n    // Random tile flipping.\n    //p.y *= (rnd>.5)? -1. : 1.;\n    \n    \n    // Rendering the arcs onto the tile.\n    //\n    float d = 1e5, d1 = 1e5, d2 = 1e5, d3 = 1e5, l;\n    \n   \n    // Three top left arcs.\n    l = length(p - vec2(-.5, .5));\n    d1 = abs(l - .25);\n    d2 = abs(l - .5);\n    d3 = abs(l - .75);\n    if(rnd2>.33) d3 = abs(length(p - vec2(.125, .5)) - .125);\n    \n    d = min(min(d1, d2), d3);\n    \n    // Two small arcs on the bottom right.\n    d1 = 1e5;//abs(length(p - vec2(.5, .5)) - .25);\n    //if(rnd3>.35) d1 = 1e5;//\n    d2 = abs(length(p - vec2(.5, .125)) - .125);\n    d3 = abs(length(p - vec2(.5, -.5)) - .25);\n    d = min(d, min(d1, min(d2, d3))); \n    \n    \n    // Three bottom left arcs.\n    l = length(p + .5);\n    d = max(d, -(l - .75)); // Outer mask.\n    \n    // Equivalent to the block below:\n    //\n    //d1 = abs(l - .75);\n    //d2 = abs(l - .5);\n    //d3 = abs(l - .25);\n    //d = min(d, min(min(d1, d2), d3));\n\t//\n    d1 = abs(l - .5);\n    d1 = min(d1, abs(d1 - .25));\n    d = min(d, d1);\n    \n    \n    // Arc width. \n    d -= .0625;\n    \n \n    // Return the distance field value for the grid tile.\n    return d; \n    \n}\n\n\n// Smooth fract function.\nfloat sFract(float x, float sf){\n    \n    x = fract(x);\n    return min(x, (1. - x)*x*sf);\n    \n}\n\n\n// The grungey texture -- Kind of modelled off of the metallic Shadertoy texture,\n// but not really. Most of it was made up on the spot, so probably isn't worth \n// commenting. However, for the most part, is just a mixture of colors using \n// noise variables.\nvec3 GrungeTex(vec2 p){\n    \n \t// Some fBm noise.\n    //float c = n2D(p*4.)*.66 + n2D(p*8.)*.34;\n    float c = n2D(p*3.)*.57 + n2D(p*7.)*.28 + n2D(p*15.)*.15;\n   \n    // Noisey bluish red color mix.\n    vec3 col = mix(vec3(.25, .1, .02), vec3(.35, .5, .65), c);\n    // Running slightly stretched fine noise over the top.\n    col *= n2D(p*vec2(150., 350.))*.5 + .5; \n    \n    // Using a smooth fract formula to provide some splotchiness... Is that a word? :)\n    col = mix(col, col*vec3(.75, .95, 1.2), sFract(c*4., 12.));\n    col = mix(col, col*vec3(1.2, 1, .8)*.8, sFract(c*5. + .35, 12.)*.5);\n    \n    // More noise and fract tweaking.\n    c = n2D(p*8. + .5)*.7 + n2D(p*18. + .5)*.3;\n    c = c*.7 + sFract(c*5., 16.)*.3;\n    col = mix(col*.6, col*1.4, c);\n    \n    // Clamping to a zero to one range.\n    return clamp(col, 0., 1.);\n    \n}\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n    \n\n    // Aspect correct screen coordinates. Setting a minumum resolution on the\n    // fullscreen setting in an attempt to keep things relatively crisp.\n    float res = min(iResolution.y, 750.);\n\tvec2 uv = (fragCoord - iResolution.xy*.5)/res;\n    \n    // Scaling and translation.\n    vec2 p = uv*4. + vec2(1, 0)*iTime;\n    // Optional rotation, if you'd prefer.\n    //vec2 p = rot2(3.14159/6.)*uv*4. + vec2(1, 0)*iTime;\n    // Flockaroo's rotozoom suggestion, if that's more your speed. :)\n    //vec2 p = rot2(sin(iTime/4.)*3.14159)*uv*(4.5 + 1.5*sin(iTime/4.)) + vec2(0, 1)*iTime;\n    \n    \n    // Taking a few distance field readings.    \n    vec2 eps = vec2(4, 6)/iResolution.y;\n    float d = TilePattern(p); // Initial field value.\n    float d2 = TilePattern(p + eps); // Slight sample distance, for highlighting,.\n    float dS = TilePattern(p + eps*3.); // Larger distance, for shadows.\n    \n    // Calculating the sample difference.    \n    float b = smoothstep(0., 15./450., d - .015);\n    float b2 = smoothstep(0., 15./450., d2 - .015);\n    \n    // Bump value for the warm highlight (above), and the cool one (below).\n    float bump = max(b2 - b, 0.)/length(eps);\n    float bump2 = max(b - b2, 0.)/length(eps);\n    \n \n    \n    // Smoothing factor, based on resolution.\n    float sf = 5./iResolution.y;\n     \n    // The grungey texture.\n    vec3 tx = GrungeTex(p/4. + .5);\n    tx = smoothstep(0., .5, tx);\n    \n     \n    // Background texture.\n    vec3 bg = tx*vec3(.85, .68, .51);\n   \n    // Initiate the image color to the background.\n    vec3 col = bg;\n    \n    \n\n    // Displaying the grid, in order to see the individual grid tiles.\n    #ifdef SHOW_GRID\n    vec2 q = abs(fract(p) - .5);\n\tfloat gw = .0275;\n    float grid = (max(q.x, q.y) - .5 + gw);\n    col = mix(col, vec3(0), (smoothstep(0., sf*4., grid - gw + gw*2.))*.75);\n    col = mix(col, bg*2., (smoothstep(0., sf, grid - gw + gw/2.)));\n    #endif\n    \n     \n    // Sometimes, more detail can help, but in this case, it's a bit much, I think. :)\n    //float dP = TilePattern(p*5.);\n    //col = mix(col, min(bg*2.5, 1.), sstep(sf*15., dP + .01)); // Pattern.\n    //col = mix(col, bg/4., sstep(sf*5., dP + .03)); // Pattern.\n     \n    \n    // TILE RENDERING.\n    \n    // Drop shadow -- blurred and slighly faded onto the background.\n    col = mix(col, vec3(0), sstep(sf*4., dS - .02)*.75); // Shadow.\n    \n    // Blurred line -- subtle, and not entirely necessary, but it's there.\n    col = mix(col, vec3(0), sstep(sf*8., d)*.35);\n    \n    // Dark edge line -- stroke.\n    col = mix(col, vec3(0), sstep(sf, d));\n     \n    \n    // Pattern color -- just a brightly colored version of the background.   \n    vec3 pCol = vec3(2.5, .75, .25)*tx;\n    // Uncomment this, if blue's more your thing.\n    //pCol = pCol.zyx*1.2;\n    \n  \n    // Apply the pattern color. Decrease the pattern width by the edge line width.\n    col = mix(col, pCol, sstep(sf, d + .025));\n     \n    \n    // Use some noise to mix the colors from orange to pink. Uncomment to see what it does.\n    col = mix(col, col.xzy, smoothstep(.3, 1., fbm(p*.85))*.7);\n    \n    // Applying the warm sunlight bump value to the image, on the opposite side to the shadow.\n    col = col + (vec3(1, .2, .1)*(bump*.01 + bump*bump*.003));\n    // Applying the cool bump value to the image, on the shadow side.\n    col = col + col*(vec3(1, .2, .1).zyx*(bump2*.01 + bump2*bump2*.003));   \n \n    \n    // Uncomment this to see the grungey texture on its own. Yeah, it's pretty basic,\n    // so it won't be winning any awards, but it's suitable enough for this example. :)\n    //col = tx;\n\n    \n    // Rough gamma correction.\n    fragColor = vec4(sqrt(max(col, 0.)), 1);\n\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wsBXDt.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[2107, 2140, 2162, 2162, 2220], [2223, 2268, 2289, 2289, 2376], [2379, 2603, 2622, 2622, 2827], [2829, 2907, 2925, 2925, 2998], [3001, 3038, 3064, 3064, 4618], [4621, 4647, 4679, 4679, 4743], [4746, 5006, 5029, 5102, 5846], [5849, 5849, 5903, 6060, 9590]], "test": "error"}
{"id": "WsBXRG", "name": "Particle like", "author": "flyingrub", "description": "Heavily inspired by https://www.shadertoy.com/view/lscczl\n", "tags": ["grid", "circle"], "likes": 1, "viewed": 152, "published": "Public", "date": "1554124206", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define resolution iResolution\n#define frame iFrame\n#define pixel_width 1./iResolution.y\n\nconst float speed = .5;\nconst float grid = 20.;\nconst float size = 1.5;\n\nfloat random (vec2 st) {\n    return fract(sin(dot(st.xy,vec2(12.9898,78.233)))*43758.5453123);\n}\n\nvec2 GetPos(vec2 id, vec2 offs, float t) {\n    float n = random(id+offs);\n    float n1 = fract(n*10.);\n    float n2 = fract(n*100.);\n    float a = t+n;\n    return offs + vec2(sin(a*n1), cos(a*n2))*.8;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord.xy-iResolution.xy*.5)/iResolution.y;\n    uv = uv * grid;\n\n    float col;\n    for (int i =-1; i<=1; i++) {\n        for (int j =-1; j<=1; j++) {\n            vec2 offset = vec2(i,j);\n            vec2 id = floor(uv);\n            vec2 gv = fract(uv);\n            vec2 pos = GetPos(id, offset, iTime*speed+10.);\n            float p_size = random(id+offset)/20.*size;\n            col += smoothstep(pixel_width*grid,0.0,length(pos-gv)-p_size);\n    \t}\n    }\n    \n    //col += step(0.98,fract(uv.x));\n    //col += step(0.98,fract(uv.y));\n\n    \n\t\n    // Output to screen\n    fragColor = vec4(vec3(col),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WsBXRG.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[163, 163, 187, 187, 259], [261, 261, 303, 303, 463], [465, 465, 522, 522, 1146]], "test": "ok"}
{"id": "WsBXWd", "name": "Black Hole Accretion", "author": "dr2", "description": "An alternative view (no physics)...", "tags": ["light", "fibonacci", "relativity"], "likes": 7, "viewed": 407, "published": "Public API", "date": "1555261710", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// \"Black Hole Accretion\" by dr2 - 2019\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\nvec4 SphFib (vec3 v, float n);\nfloat SmoothBump (float lo, float hi, float w, float x);\nfloat Maxv3 (vec3 p);\nvec2 Rot2D (vec2 q, float a);\nvec3 HsvToRgb (vec3 c);\nfloat Hashfv3 (vec3 p);\nfloat Fbm2 (vec2 p);\n\nfloat tCur, dstFar;\nconst float pi = 3.14159, phi = 1.618034;\n\nvec2 BallHit (vec3 ro, vec3 rd, vec3 p, float s)\n{\n  vec3 v;\n  float dbIn, dbOut, b, d;\n  v = ro - p;\n  b = dot (rd, v);\n  d = b * b + s * s - dot (v, v);\n  dbIn = dstFar;\n  dbOut = dstFar;\n  if (d > 0.) {\n    d = sqrt (d);\n    dbIn = - b - d;\n    dbOut = - b + d;\n  }\n  return vec2 (dbIn, dbOut);\n}\n\nvec3 StarPat (vec3 rd, float scl)\n{\n  vec3 tm, qn, u;\n  vec2 q;\n  float f;\n  tm = -1. / max (abs (rd), 0.0001);\n  qn = - sign (rd) * step (tm.zxy, tm) * step (tm.yzx, tm);\n  u = Maxv3 (tm) * rd;\n  q = atan (vec2 (dot (u.zxy, qn), dot (u.yzx, qn)), vec2 (1.)) / pi;\n  f = 0.57 * (Fbm2 (11. * dot (0.5 * (qn + 1.), vec3 (1., 2., 4.)) + 531.13 * scl * q) +\n      Fbm2 (13. * dot (0.5 * (qn + 1.), vec3 (1., 2., 4.)) + 571.13 * scl * q.yx));\n  return 12. * vec3 (1., 1., 0.5) * pow (f, 16.);\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  vec4 f4;\n  vec3 col, bPos, ror;\n  vec2 dSph;\n  float nCyc, tCyc, iFib, phs, rMax, rMin, rFac, r, s, rp, c, aSpin, bSpin, pFlash;\n  const float kMax = 20.;\n  rMax = 16.;\n  rMin = 0.5;\n  iFib = 16384.;\n  tCyc = 20.;\n  nCyc = floor (tCur / tCyc) + 1.;\n  phs = fract (tCur / tCyc);\n  pFlash = abs (phs - 1./1.5);\n  phs = min (1.5 * phs, 1.);\n  bPos = vec3 (0.);\n  rp = length (cross (bPos - ro, rd));\n  aSpin = -2. * pi * pow (phs, 4.);\n  bSpin = 0.02 * tCur;\n  c = 0.;\n  for (float k = 0.; k < kMax; k ++) {\n    r = (rMax - (rMax - rMin) * phs) * (1. - 0.002 * k);\n    rFac = 0.004 * (1. - 0.003 * (k - 0.5 * kMax) * (k - 0.5 * kMax));\n    dSph = BallHit (ro, rd, bPos, r);\n    if (dSph.x < dstFar) {\n      ro += dSph.x * rd;\n      ror = normalize (ro);\n      ror.xy = Rot2D (ror.xy, bSpin);\n      ror.xz = Rot2D (ror.xz, aSpin);\n      f4 = SphFib (ror, iFib);\n      s = Hashfv3 (73.11 * f4.yzw + 87.11 * nCyc);\n      if (s > 0.5 && f4.x < rFac * s) c = 1. - 0.01 * (kMax - k);\n      else if (rp < rMin) c = 2.;\n      else {\n        ro += (dSph.y - dSph.x) * rd;\n        ror = normalize (ro);\n        ror.xy = Rot2D (ror.xy, bSpin);\n        ror.xz = Rot2D (ror.xz, aSpin);\n        f4 = SphFib (ror, iFib);\n        s = Hashfv3 (73.11 * f4.yzw + 87.11 * nCyc);\n        if (s > 0.5 && f4.x < rFac * s) c = 0.8;\n      }\n      if (c > 0.) break;\n    }\n  }\n  if (c == 2.) {\n    col = vec3 (0.08, 0., 0.) * (1. - 0.5 * smoothstep (0.8, 1., rp / rMin)) +\n       vec3 (1., 1., 0.5) * (1. - smoothstep (0.001, 0.01, pFlash));\n  } else if (c > 0.) {\n    s = pow ((r - rMin) / (rMax - rMin), 0.7);\n    col = c * HsvToRgb (vec3 (0.15 * s, 1., smoothstep (0., 0.001, s)));\n  } else {\n    col = StarPat (normalize (vec3 (Rot2D (rd.xy, bSpin) * (1. -\n       0.95 * smoothstep (0.7, 1., phs) * (1. - smoothstep (1., 16., rp / rMin))), rd.z)), 4.);\n  }\n  col += vec3 (1., 1., 0.5) * (1. - smoothstep (0.001, 0.005, pFlash));\n  return clamp (col, 0., 1.);\n}\n\n#define AA  1   // optional antialiasing\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  mat3 vuMat;\n  vec4 mPtr;\n  vec3 ro, rd, col;\n  vec2 canvas, uv, ori, ca, sa;\n  float el, az, sr;\n  canvas = iResolution.xy;\n  uv = 2. * fragCoord.xy / canvas - 1.;\n  uv.x *= canvas.x / canvas.y;\n  tCur = iTime;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / canvas - 0.5;\n  az = 0.;\n  el = 0.;\n  if (mPtr.z > 0.) {\n    az -= 0.02 * pi * mPtr.x;\n    el -= 0.02 * pi * mPtr.y;\n  }\n  ori = vec2 (el, az);\n  ca = cos (ori);\n  sa = sin (ori);\n  vuMat = mat3 (ca.y, 0., - sa.y, 0., 1., 0., sa.y, 0., ca.y) *\n          mat3 (1., 0., 0., 0., ca.x, - sa.x, 0., sa.x, ca.x);\n  ro = vuMat * vec3 (0., 0., -40.);\n  dstFar = 100.;\n  #if ! AA\n  const float naa = 1.;\n#else\n  const float naa = 3.;\n#endif  \n  col = vec3 (0.);\n  sr = 2. * mod (dot (mod (floor (0.5 * (uv + 1.) * canvas), 2.), vec2 (1.)), 2.) - 1.;\n  for (float a = 0.; a < naa; a ++) {\n    rd = vuMat * normalize (vec3 (uv + step (1.5, naa) * Rot2D (vec2 (0.5 / canvas.y, 0.),\n       sr * (0.667 * a + 0.5) * pi), 6.));\n    col += (1. / naa) * ShowScene (ro, rd);\n  }\n  fragColor = vec4 (col, 1.);\n}\n\nvec4 SphFib (vec3 v, float n)\n{   // Keinert et al's inverse spherical Fibonacci mapping\n  vec4 b;\n  vec3 vf, vfMin;\n  vec2 ff, c;\n  float fk, ddMin, dd, a, z, ni;\n  ni = 1. / n;\n  fk = pow (phi, max (2., floor (log (n * pi * sqrt (5.) * dot (v.xy, v.xy)) /\n     log (phi + 1.)))) / sqrt (5.);\n  ff = vec2 (floor (fk + 0.5), floor (fk * phi + 0.5));\n  b = vec4 (ff * ni, pi * (fract ((ff + 1.) * phi) - (phi - 1.)));\n  c = floor ((0.5 * mat2 (b.y, - b.x, b.w, - b.z) / (b.y * b.z - b.x * b.w)) *\n     vec2 (atan (v.y, v.x), v.z - (1. - ni)));\n  ddMin = 4.1;\n  for (int j = 0; j < 4; j ++) {\n    a = dot (ff, vec2 (j - 2 * (j / 2), j / 2) + c);\n    z = 1. - (2. * a + 1.) * ni;\n    vf = vec3 (sin (2. * pi * fract (phi * a) + vec2 (0.5 * pi, 0.)) * sqrt (1. - z * z), z);\n    dd = dot (vf - v, vf - v);\n    if (dd < ddMin) {\n      ddMin = dd;\n      vfMin = vf;\n    }\n  }\n  return vec4 (sqrt (ddMin), vfMin);\n}\n\nfloat SmoothBump (float lo, float hi, float w, float x)\n{\n  return (1. - smoothstep (hi - w, hi + w, x)) * smoothstep (lo - w, lo + w, x);\n}\n\nfloat Maxv3 (vec3 p)\n{\n  return max (p.x, max (p.y, p.z));\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  vec2 cs;\n  cs = sin (a + vec2 (0.5 * pi, 0.));\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nvec3 HsvToRgb (vec3 c)\n{\n  return c.z * mix (vec3 (1.), clamp (abs (fract (c.xxx + vec3 (1., 2./3., 1./3.)) * 6. - 3.) - 1., 0., 1.), c.y);\n}\n\nconst float cHashM = 43758.54;\n\nfloat Hashfv3 (vec3 p)\n{\n  return fract (sin (dot (p, vec3 (37., 39., 41.))) * cHashM);\n}\n\nvec2 Hashv2v2 (vec2 p)\n{\n  vec2 cHashVA2 = vec2 (37., 39.);\n  return fract (sin (vec2 (dot (p, cHashVA2), dot (p + vec2 (1., 0.), cHashVA2))) * cHashM);\n}\n\nfloat Noisefv2 (vec2 p)\n{\n  vec2 t, ip, fp;\n  ip = floor (p);  \n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = mix (Hashv2v2 (ip), Hashv2v2 (ip + vec2 (0., 1.)), fp.y);\n  return mix (t.x, t.y, fp.x);\n}\n\nfloat Fbm2 (vec2 p)\n{\n  float f, a;\n  f = 0.;\n  a = 1.;\n  for (int j = 0; j < 5; j ++) {\n    f += a * Noisefv2 (p);\n    a *= 0.5;\n    p *= 2.;\n  }\n  return f * (1. / 1.9375);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WsBXWd.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[401, 401, 451, 451, 700], [702, 702, 737, 737, 1191], [1193, 1193, 1228, 1228, 3166], [3210, 3210, 3266, 3266, 4311], [4313, 4313, 4344, 4401, 5221], [5223, 5223, 5280, 5280, 5363], [5365, 5365, 5387, 5387, 5425], [5427, 5427, 5457, 5457, 5570], [5572, 5572, 5596, 5596, 5713], [5747, 5747, 5771, 5771, 5836], [5838, 5838, 5862, 5862, 5992], [5994, 5994, 6019, 6019, 6205], [6207, 6207, 6228, 6228, 6383]], "test": "error"}
{"id": "WsBXWt", "name": "Hollow glass cube", "author": "MacSlow", "description": "Further experimenting with my glass-shader. Fresnel still not working as intended (removed for now), but the overall look is ok for my taste. Somehow, I like this one better than the jelly glass cubes. There is an options to control the camera.", "tags": ["3d", "raymarching", "phong", "sdf", "shadow", "glass", "material", "blinn"], "likes": 19, "viewed": 622, "published": "Public API", "date": "1555233741", "time_retrieved": "2021-10-01T00:00:00", "image_code": "////////////////////////////////////////////////////////////////////////////////\n//\n// Hollow glass cube - More experimenting with the glass shader. Fresnel still\n// not working correctly. Share and enjoy!\n//\n// Copyright 2019 Mirco Müller\n//\n// Author(s):\n//   Mirco \"MacSlow\" Müller <macslow@gmail.com>\n//\n// This program is free software: you can redistribute it and/or modify it\n// under the terms of the GNU General Public License version 3, as published\n// by the Free Software Foundation.\n//\n// This program is distributed in the hope that it will be useful, but\n// WITHOUT ANY WARRANTY; without even the implied warranties of\n// MERCHANTABILITY, SATISFACTORY QUALITY, or FITNESS FOR A PARTICULAR\n// PURPOSE.  See the GNU General Public License for more details.\n//\n// You should have received a copy of the GNU General Public License along\n// with this program.  If not, see <http://www.gnu.org/licenses/>.\n//\n////////////////////////////////////////////////////////////////////////////////\n\n// set to 1 for manual camera-control\n#define MANUAL_CAMERA 0\n\nbool isInside = false;\n\nmat2 r2d (float deg) {\n\tfloat rad = radians (deg);\n\tfloat c = cos (rad);\n\tfloat s = sin (rad);\n\treturn mat2 (c,s,-s,c);\n}\n\nfloat smin (float d1, float d2, float k) {\n\tfloat h = clamp (.5 + .5*(d2 - d1)/k, .0, 1.);\n\treturn mix (d2, d1, h) - h*k*(1. - h);\n}\n\nfloat sdBox (in vec3 p, in vec3 size, in float r)\n{\n\tvec3 d = abs(p) - size;\n\treturn min (max (d.x, max (d.y,d.z)), .0) + length (max (d, .0)) - r;\n}\n\nfloat map (vec3 p, inout int id, inout vec3 pout) {\n    vec3 pground = p;\n\tfloat ground = pground.y + 1.;\n    vec3 pwall = p;\n\tfloat wall = pwall.z + 1.;\n\tvec3 pbox = p + vec3 (.0, -.4, -.2);\n\tpbox.xz *= r2d (14.*iTime);\n\tpbox.yz *= r2d (26.*iTime);\n\tfloat r = .75 + .1*(.5+.5*cos(4.*iTime + 9.*pbox.y));\n\tfloat box = sdBox (pbox, vec3 (.6), .05);\n\tfloat box2 = sdBox (pbox, vec3 (.55), .06);\n\tbox = max (box, -box2);\n\tp -= vec3 (2.5*cos (1.25*iTime), .75, .2);\n\tp.xz *= r2d (-60.*iTime);\n\tp.yz *= r2d (-90.*iTime);\n\tfloat ball = sdBox (p , vec3 (.4), .05);\n\tbox = (isInside? -1. : 1.)*box; //smin (box, ball, .5);\n\tfloat d = min (ground, min (wall, box));\n\tif (d == ground) {id = 1; pout = pground;}\n\tif (d == wall) {id = 2; pout = pwall;}\n\tif (d == box) {id = 3; pout = p;}\n    return d;\n}\n\nfloat march (vec3 ro, vec3 rd, inout int id, inout vec3 pout)\n{\n\tfloat t = .0;\n\tfloat d = .0;\n\tfor (int i = 0; i< 48; ++i) {\n\t\tvec3 p = ro+d*rd;\n\t\tt = map (p, id, pout);\n\t\tif (abs (t) < .00001*(1. + .125*t)) break;\n\t\td += t*.75;\n\t}\n\treturn d;\n}\n\nvec3 norm (vec3 p){\n\tint foo;\n\tvec3 bar;\n\tfloat d = map (p, foo, bar);\n\tvec2 e = vec2 (.001, .0);\n\treturn normalize (vec3 (map (p+e.xyy, foo, bar),\n                            map (p+e.yxy, foo, bar),\n                            map (p+e.yyx, foo, bar))-d);\n}\n\nfloat sha (vec3 p, vec3 lp, vec3 n, vec3 ldir) {\n\tfloat d2l = distance (lp, p);\n\tint foo;\n\tvec3 bar;\n\tfloat d2w = march (p+.01*n, ldir, foo, bar);\n\treturn d2l < d2w ? 1. : .1;\n}\n\nfloat ao (vec3 p, vec3 n, float stepsize, float i){\n\tfloat ao = .0;\n\tfloat dist = .0;\n\tint foo;\n\tvec3 bar;\n\tfor (int a = 1; a <= 8; ++a) {\n\t\tdist = float (a)*stepsize;\n\t\tao += max (.0, (dist - map (p+n*dist, foo, bar))/dist);\n\t}\n\treturn 1. - ao*i;\n}\n\nvec2 normalMap(in vec2 uv)\n{\n    vec2 s = 1./iChannelResolution[1].xy;\n    float p = texture(iChannel1, uv).r;\n    float h = texture(iChannel1, uv + s*vec2(1., .0)).r;\n    float v = texture(iChannel1, uv + s*vec2(.0, 1.)).r;\n   \treturn p - vec2(h, v);\n}\n\nvec3 shade (vec3 ro,\n\t\t\tvec3 rd,\n\t\t\tfloat d,\n\t\t\tvec3 n,\n\t\t\tvec3 lp,\n\t\t\tvec3 lc,\n\t\t\tfloat li,\n\t\t\tint id,\n\t\t\tvec3 pout) {\n    vec3 p = ro + d*rd;\n\tfloat ld = distance (p, lp); \n\tvec3 ldir = normalize (lp - p);\n\tfloat att = 5. / (ld*ld);\n\tvec3 mat = vec3 (.2);\n\tif (id == 1) {\n\t    vec2 noffset = -4.*normalMap(.25*pout.xz*r2d (-20.));\n        n = normalize (n + vec3 (noffset.x, .0, noffset.y));\n\t\tmat = texture (iChannel1, .25*pout.xz*r2d(-20.)).rgb;\n\t}\n\tif (id == 2) {\n\t    vec2 noffset = -4.*normalMap(.25*pout.xy*r2d (20.));\n        n = normalize (n + vec3 (noffset.x, noffset.y, .0));\n\t\tmat = texture (iChannel1, .25*pout.xy*r2d(20.)).rgb;\n\t}\n\tif (id == 3) {\n\t\tmat = vec3 (.9, .5, .2);\n\t}\n\tfloat s = sha (p, lp, n, ldir);\n\tfloat diff = max (.0, dot (n, ldir));\n\tvec3 h = normalize (-rd + ldir);\n\tfloat shiny = 100.;\n\tfloat lf = .0;\n\tfloat hf = .0;\n    float fac = 1.;\n\tshiny *= fac;\n\tfloat sp = pow (max (.0, dot (n, h)), shiny);\n\tvec3 am = vec3 (.05);\n\tfloat ao = ao (p, n, .1, .1);\n\tao *= (isInside ? 1.25 : 1.);\n\t\n\treturn ao*att*s*(am + diff*lc*li*mat + sp*vec3 (1.));\n}\n\nvec3 cam (vec2 uv, vec3 ro, vec3 aim, float zoom) {\n\tvec3 f =normalize (aim - ro);\n\tvec3 wu = vec3 (.0, 1., .0);\n\tvec3 r = normalize (cross (wu, f));\n\tvec3 u = normalize (cross (f, r));\n\tvec3 c = ro + f*zoom;\n\treturn normalize (c + r*uv.x+u*uv.y - ro);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uvRaw = fragCoord.xy/iResolution.xy;\n\tvec2 uv = uvRaw*2. - 1.;\n\tuv.x *= iResolution.x/iResolution.y;\n\tuv *= 1. + .25*length (uv);\n\n    #if MANUAL_CAMERA == 1\n    float x = -2.*(iMouse.x/iResolution.x * 2. - 1.);\n    float y = 2.*(iMouse.y/iResolution.y * 2. - 1.);\n\tvec3 ro = vec3 (x, 1. + y, 2.5);\n    #else\n\tvec3 ro = vec3 (cos (iTime), 1. + .125*(.5+.5*cos(5.*iTime)), 2.5);\n    #endif\n\n    vec3 rd = cam (uv, ro, vec3 (.0), 1.7);\n\tint id = 0;\n\tvec3 pout = vec3 (.0);\n\tisInside = false;\n\tfloat d = march (ro, rd, id, pout);\n\tvec3 p = ro + d*rd;\n\tvec3 n = norm (p);\n\tvec3 col = vec3 (.0);\n\n\tvec3  lp1 = vec3 (2., 1., 2.);\n\tvec3  lc1 = vec3 (.9, .8, .7);\n\tfloat li1 = 3.;\n\tvec3  lp2 = vec3 (.7, 3., .0);\n\tvec3  lc2 = vec3 (.2, .2, .9);\n\tfloat li2 = 6.;\n\tvec3  lp3 = vec3 (-2., 2., .5);\n\tvec3  lc3 = vec3 (.9, .3, .2);\n\tfloat li3 = 3.;\n\n\tfloat fac = 1.;\n\tif (id == 3) {\n\t\tfac = .025;\n\t}\n\n\tcol = fac*shade (ro, rd, d, n, lp1, lc1, li1, id, pout);\n\tcol += fac*shade (ro, rd, d, n, lp2, lc2, li2, id, pout);\n\tcol += fac*shade (ro, rd, d, n, lp3, lc3, li3, id, pout);\n\tif (id == 3) {\n\t\tn = normalize (n + texture (iChannel0, .75*p.xy).r);\n\t\tro = p - .05*n;\n\t\tfloat ior = .85;\n\t\trd = normalize (refract (rd, n, ior));\n\t\tisInside = true;\n\t\td = march (ro, rd, id, pout);\n\t\tp = ro + d*rd;\n\t\tn = norm (p);\n\t\tcol += shade (ro, rd, d, n, lp1, lc1, li1, id, pout);\n\t\tcol += shade (ro, rd, d, n, lp2, lc2, li2, id, pout);\n\t\tcol += shade (ro, rd, d, n, lp3, lc3, li3, id, pout);\n\n\t\tro = p - .01*n;\n\t\trd = normalize (refract (rd, n, ior));\n\t\tisInside = false;\n\t\td = march (ro, rd, id, pout);\n\t\tp = ro + d*rd;\n\t\tn = norm (p);\n\t\tcol += shade (ro, rd, d, n, lp1, lc1, li1, id, pout);\n\t\tcol += shade (ro, rd, d, n, lp2, lc2, li2, id, pout);\n\t\tcol += shade (ro, rd, d, n, lp3, lc3, li3, id, pout);\n\n\t\tif (id == 3) {\n\t\t\tn = normalize (n + texture (iChannel0, .75*p.xy).r);\n\t\t\tro = p - .05*n;\n\t\t\trd = normalize (refract (rd, n, ior));\n\t\t\tisInside = true;\n\t\t\td = march (ro, rd, id, pout);\n\t\t\tp = ro + d*rd;\n\t\t\tn = norm (p);\n\t\t\tcol += shade (ro, rd, d, n, lp1, lc1, li1, id, pout);\n\t\t\tcol += shade (ro, rd, d, n, lp2, lc2, li2, id, pout);\n\t\t\tcol += shade (ro, rd, d, n, lp3, lc3, li3, id, pout);\n\n\t\t\tro = p - .01*n;\n\t\t\trd = normalize (refract (rd, n, ior));\n\t\t\tisInside = false;\n\t\t\td = march (ro, rd, id, pout);\n\t\t\tp = ro + d*rd;\n\t\t\tn = norm (p);\n\t\t\tcol += shade (ro, rd, d, n, lp1, lc1, li1, id, pout);\n\t\t\tcol += shade (ro, rd, d, n, lp2, lc2, li2, id, pout);\n\t\t\tcol += shade (ro, rd, d, n, lp3, lc3, li3, id, pout);\n\t\t}\n\t}\n\n\tcol = col / (1. + col);\n\tcol *= 1. - .5*length(uvRaw*2.-1.);\n\tcol = pow (col, vec3 (1./2.2));\n\n    fragColor = vec4(col, 1.);\n}", "image_inputs": [{"id": "XsfGRn", "previewfilepath": "/media/ap/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg", "ctype": "texture"}, {"id": "4sfGRn", "previewfilepath": "/media/ap/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WsBXWt.jpg", "access": "shaders20k", "license": "gpl-3.0", "functions": [[1089, 1089, 1111, 1111, 1210], [1212, 1212, 1254, 1254, 1344], [1346, 1346, 1397, 1397, 1495], [1497, 1497, 1548, 1548, 2288], [2290, 2290, 2353, 2353, 2534], [2536, 2536, 2555, 2555, 2795], [2797, 2797, 2845, 2845, 2974], [2976, 2976, 3027, 3027, 3225], [3227, 3227, 3255, 3255, 3480], [3482, 3482, 3601, 3601, 4558], [4560, 4560, 4611, 4611, 4814], [4816, 4816, 4873, 4873, 7510]], "test": "error"}
{"id": "wsBXzG", "name": "New Pixel Colorization method", "author": "iopzxz", "description": "this shader permutates through many possible combination of colors", "tags": ["pixel"], "likes": 1, "viewed": 122, "published": "Public", "date": "1554202467", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float mixSinWaves(float x, float cycleA, float cycleB, float mixCycle) {\n\treturn sin(x / cycleA)*((1.0 + sin(x / mixCycle)) * 0.5) + sin(x / cycleB) * (1.0 - (1.0 + sin(x / mixCycle)) * 0.5);\n}\nfloat lerpThree(float H, float numA, float numB, float numC) {\n\tfloat c = 1.0;\n    float x = 1.0-abs(mod(H/60.0f,2.0f) -1.0);\n    float m = 0.0;\n\tfloat r = 0.0, g = 0.0, b = 0.0;\n\tr = float(((H < 60.0) || (H >= 300.0 && H < 360.0))) \n        +x * float(((H >= 60.0 && H < 120.0) || (H >= 240.0 && H < 300.0)));\n\tg = float((H >= 60.0 && H < 180.0)) + x * float(((H < 60.0) || (H >= 180.0 && H < 240.0)));\n\tb = float((H >= 180.0 && H < 300.0)) + x * float(((H >= 120.0 && H < 180.0) || (H >= 300.0 && H < 360.0)));\n\n\tfloat rgb = r+g+b+0.0001f;\n\tr /= rgb;\n\tg /= rgb;\n\tb /= rgb;\n\treturn (numA * r + numB * g + numC * b);\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float time = iTime;\n    \n    float liftScaleFactor = 0.5;\n    float gainScaleFactor = 0.25;\n    float gammaScaleFactor = .5;\n    \n    vec3 sinWaves = vec3(\n        mixSinWaves(iTime, 2.1, 3.1,  7.0),\n        mixSinWaves(iTime, 3.1, 5.0,  7.4),\n        mixSinWaves(iTime, 2.0, 17.0, 6.7));\n    vec3 lift = vec3(\n        lerpThree(mod(iTime*0.1,360.0),sinWaves.x,sinWaves.y,sinWaves.z),\n        lerpThree(mod((iTime*0.1+120.0),360.0),sinWaves.x,sinWaves.y,sinWaves.z),\n        lerpThree(mod((iTime*0.1+240.0),360.0),sinWaves.x,sinWaves.y,sinWaves.z));\n    \n    vec3 gain = vec3(1.0,1.0,1.0);\n    vec3 gamma = vec3(1,1,1);\n    \n    \n    lift *= liftScaleFactor;\n    gain = 1.0 + gain  * gainScaleFactor;\n    gamma = 1.0 + gamma *gammaScaleFactor;\n    \n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    vec3 texcolour = texture(iChannel0,uv).xyz;//Get the pixel at xy from iChannel0\n    \n    \n    // Output to screen\n    vec3 lgg = pow(clamp((gain*(texcolour+lift*(1.0-texcolour))),0.0,1.0),(1.0/gamma));\n    fragColor = vec4(lgg,1.0);\n}", "image_inputs": [{"id": "4dfGRn", "previewfilepath": "/media/ap/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wsBXzG.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 72, 72, 193], [194, 194, 256, 256, 812], [813, 813, 870, 870, 1952]], "test": "error"}
{"id": "wsjGWd", "name": "Implicit CAD model", "author": "J_O", "description": "Simple demo of a CAD model described by implicit geometry. This is not real world model, but it contains some elements that may be used in a part designed for additive manufacturing.  Rendering is based on IQs https://www.shadertoy.com/view/Xds3zN", "tags": ["csg", "implicitgeometry"], "likes": 9, "viewed": 335, "published": "Public", "date": "1556133438", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// The MIT License\n// Copyright © 2019 Jan Orend\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// Based on https://www.shadertoy.com/view/Xds3zN by IQ\n\n#define AA 1   // make this 2 or 3 for antialiasing\n\n\n//------------------------------------------------------------------\n\nfloat sdPlane( vec3 p )\n{\n\treturn p.y;\n}\n\nfloat sdSphere( vec3 p, float s )\n{\n    return length(p)-s;\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n    vec3 d = abs(p) - b;\n    return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\nfloat sdEllipsoid( in vec3 p, in vec3 r ) // approximated\n{\n    float k0 = length(p/r);\n    float k1 = length(p/(r*r));\n    return k0*(k0-1.0)/k1;\n    \n}\n\nfloat sdRoundBox( in vec3 p, in vec3 b, in float r ) \n{\n    vec3 q = abs(p) - b;\n    return min(max(q.x,max(q.y,q.z)),0.0) + length(max(q,0.0)) - r;\n}\n\nfloat sdTorus( vec3 p, vec2 t )\n{\n    return length( vec2(length(p.xz)-t.x,p.y) )-t.y;\n}\n\nfloat sdHexPrism( vec3 p, vec2 h )\n{\n    vec3 q = abs(p);\n\n    const vec3 k = vec3(-0.8660254, 0.5, 0.57735);\n    p = abs(p);\n    p.xy -= 2.0*min(dot(k.xy, p.xy), 0.0)*k.xy;\n    vec2 d = vec2(\n       length(p.xy - vec2(clamp(p.x, -k.z*h.x, k.z*h.x), h.x))*sign(p.y - h.x),\n       p.z-h.y );\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r )\n{\n\tvec3 pa = p-a, ba = b-a;\n\tfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n\treturn length( pa - ba*h ) - r;\n}\n\nfloat sdRoundCone( in vec3 p, in float r1, float r2, float h )\n{\n    vec2 q = vec2( length(p.xz), p.y );\n    \n    float b = (r1-r2)/h;\n    float a = sqrt(1.0-b*b);\n    float k = dot(q,vec2(-b,a));\n    \n    if( k < 0.0 ) return length(q) - r1;\n    if( k > a*h ) return length(q-vec2(0.0,h)) - r2;\n        \n    return dot(q, vec2(a,b) ) - r1;\n}\n\nfloat dot2(in vec3 v ) {return dot(v,v);}\nfloat sdRoundCone(vec3 p, vec3 a, vec3 b, float r1, float r2)\n{\n    // sampling independent computations (only depend on shape)\n    vec3  ba = b - a;\n    float l2 = dot(ba,ba);\n    float rr = r1 - r2;\n    float a2 = l2 - rr*rr;\n    float il2 = 1.0/l2;\n    \n    // sampling dependant computations\n    vec3 pa = p - a;\n    float y = dot(pa,ba);\n    float z = y - l2;\n    float x2 = dot2( pa*l2 - ba*y );\n    float y2 = y*y*l2;\n    float z2 = z*z*l2;\n\n    // single square root!\n    float k = sign(rr)*rr*rr*x2;\n    if( sign(z)*a2*z2 > k ) return  sqrt(x2 + z2)        *il2 - r2;\n    if( sign(y)*a2*y2 < k ) return  sqrt(x2 + y2)        *il2 - r1;\n                            return (sqrt(x2*a2*il2)+y*rr)*il2 - r1;\n}\n\nfloat sdEquilateralTriangle(  in vec2 p )\n{\n    const float k = 1.73205;//sqrt(3.0);\n    p.x = abs(p.x) - 1.0;\n    p.y = p.y + 1.0/k;\n    if( p.x + k*p.y > 0.0 ) p = vec2( p.x - k*p.y, -k*p.x - p.y )/2.0;\n    p.x += 2.0 - 2.0*clamp( (p.x+2.0)/2.0, 0.0, 1.0 );\n    return -length(p)*sign(p.y);\n}\n\nfloat sdTriPrism( vec3 p, vec2 h )\n{\n    vec3 q = abs(p);\n    float d1 = q.z-h.y;\n    h.x *= 0.866025;\n    float d2 = sdEquilateralTriangle(p.xy/h.x)*h.x;\n    return length(max(vec2(d1,d2),0.0)) + min(max(d1,d2), 0.);\n}\n\n// vertical\nfloat sdCylinder( vec3 p, vec2 h )\n{\n    vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\n// arbitrary orientation\nfloat sdCylinder(vec3 p, vec3 a, vec3 b, float r)\n{\n    vec3 pa = p - a;\n    vec3 ba = b - a;\n    float baba = dot(ba,ba);\n    float paba = dot(pa,ba);\n\n    float x = length(pa*baba-ba*paba) - r*baba;\n    float y = abs(paba-baba*0.5)-baba*0.5;\n    float x2 = x*x;\n    float y2 = y*y*baba;\n    float d = (max(x,y)<0.0)?-min(x2,y2):(((x>0.0)?x2:0.0)+((y>0.0)?y2:0.0));\n    return sign(d)*sqrt(abs(d))/baba;\n}\n\nfloat sdCone( in vec3 p, in vec3 c )\n{\n    vec2 q = vec2( length(p.xz), p.y );\n    float d1 = -q.y-c.z;\n    float d2 = max( dot(q,c.xy), q.y);\n    return length(max(vec2(d1,d2),0.0)) + min(max(d1,d2), 0.);\n}\n\nfloat dot2( in vec2 v ) { return dot(v,v); }\nfloat sdCappedCone( in vec3 p, in float h, in float r1, in float r2 )\n{\n    vec2 q = vec2( length(p.xz), p.y );\n    \n    vec2 k1 = vec2(r2,h);\n    vec2 k2 = vec2(r2-r1,2.0*h);\n    vec2 ca = vec2(q.x-min(q.x,(q.y < 0.0)?r1:r2), abs(q.y)-h);\n    vec2 cb = q - k1 + k2*clamp( dot(k1-q,k2)/dot2(k2), 0.0, 1.0 );\n    float s = (cb.x < 0.0 && ca.y < 0.0) ? -1.0 : 1.0;\n    return s*sqrt( min(dot2(ca),dot2(cb)) );\n}\n\n\nfloat sdOctahedron(vec3 p, float s)\n{\n    p = abs(p);\n    \n    float m = p.x + p.y + p.z - s;\n    \n\tvec3 q;\n         if( 3.0*p.x < m ) q = p.xyz;\n    else if( 3.0*p.y < m ) q = p.yzx;\n    else if( 3.0*p.z < m ) q = p.zxy;\n    else return m*0.57735027;\n    \n    float k = clamp(0.5*(q.z-q.y+s),0.0,s); \n    return length(vec3(q.x,q.y-s+k,q.z-k)); \n}\n\n\nfloat length2( vec2 p )\n{\n\treturn sqrt( p.x*p.x + p.y*p.y );\n}\n\nfloat length6( vec2 p )\n{\n\tp = p*p*p; p = p*p;\n\treturn pow( p.x + p.y, 1.0/6.0 );\n}\n\nfloat length8( vec2 p )\n{\n\tp = p*p; p = p*p; p = p*p;\n\treturn pow( p.x + p.y, 1.0/8.0 );\n}\n\nfloat sdTorus82( vec3 p, vec2 t )\n{\n    vec2 q = vec2(length2(p.xz)-t.x,p.y);\n    return length8(q)-t.y;\n}\n\nfloat sdTorus88( vec3 p, vec2 t )\n{\n    vec2 q = vec2(length8(p.xz)-t.x,p.y);\n    return length8(q)-t.y;\n}\n\nfloat sdCylinder6( vec3 p, vec2 h )\n{\n    return max( length6(p.xz)-h.x, abs(p.y)-h.y );\n}\n\n\n//------------------------------------------------------------------\n\n\n//Substraction\nfloat opS( float d1, float d2 )\n{\n    return max(-d2,d1);\n}\n\n//Union\nvec2 opU( vec2 d1, vec2 d2 )\n{\n\treturn (d1.x<d2.x) ? d1 : d2;\n}\n\n\nfloat opU( float d1, float d2 )\n{\n\treturn min(d1,d2);\n}\n\n\n//Intersection\nfloat opI( float d1, float d2 ) \n{ \n    return max(d1,d2); \n}\n\nvec3 opRep( vec3 p, vec3 c )\n{\n    return mod(p,c);\n}\n\n\nfloat opSmoothUnion( float d1, float d2, float k )\n{\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); \n}\n\nfloat opSmoothSubtraction( float d1, float d2, float k ) \n{\n    float h = clamp( 0.5 - 0.5*(d2+d1)/k, 0.0, 1.0 );\n    return mix( d2, -d1, h ) + k*h*(1.0-h); \n}\n\nfloat opSmoothIntersection( float d1, float d2, float k ) \n{\n    float h = clamp( 0.5 - 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) + k*h*(1.0-h); \n}\n\n//deformation\nvec4 opElongate( in vec3 p, in vec3 h )\n{  \n    vec3 q = abs(p)-h;\n    return vec4( max(q,0.0), min(max(q.x,max(q.y,q.z)),0.0) );\n}\n\n\n//transformations\nvec3 rotateY( in vec3 p, float t )\n{\n    float co = cos(t);\n    float si = sin(t);\n    p.xz = mat2(co,-si,si,co)*p.xz;\n    return p;\n}\n\nvec3 rotateX( in vec3 p, float t )\n{\n    float co = cos(t);\n    float si = sin(t);\n    p.yz = mat2(co,-si,si,co)*p.yz;\n    return p;\n}\nvec3 rotateZ( in vec3 p, float t )\n{\n    float co = cos(t);\n    float si = sin(t);\n    p.xy = mat2(co,-si,si,co)*p.xy;\n    return p;\n}\n\nvec3 translate(in vec3 p, in vec3 translation)\n{\n    return p - translation;\n}\n\nvec3 mirrorX(in vec3 pos)\n{\n    return pos * vec3(-1.0, 1.0, 1.0);\n}\n\n//------------------------------------------------------------------\n\n#define ZERO (min(iFrame,0))\n\n//Combined Geometries\n\nfloat cell(in vec3 pos, float size, float radius)\n{\n \tfloat res = 1e10;\n    float k = (0.2 + 0.2 * sin(iTime*0.12)) * size;\n    res = opSmoothUnion(res, sdCapsule(pos, vec3(size*0.5, size*0.5, 0.0), vec3(size*0.5, size*0.5, size), radius), k);\n    res = opSmoothUnion(res, sdCapsule(pos, vec3(0.0, size*0.5, size*0.5), vec3(size, size*0.5, size*0.5), radius), k);\n    res = opSmoothUnion(res, sdCapsule(pos, vec3(size*0.5, 0.0, size*0.5), vec3(size*0.5, size, size*0.5), radius), k);\n    return res;\n}\n\n\nfloat lattices(in vec3 pos, float size, float radius)\n{ \n   return cell(opRep(pos, vec3(size)), size, radius);      \n}\n\n\nfloat flange( in vec3 pos, in vec3 size)\n{\n   float res = sdBox(translate(pos, size * vec3(0.5,0.0,0.0)), size*vec3(0.5, 1.0, 1.0));\n   res = opU(res, sdCylinder(translate(pos, size * vec3(1.0,0.0,0.0)) , vec2(size.x * 0.6, size.y)));\n   res = opS(res, sdCylinder(translate(pos, size * vec3(1.0,0.0,0.0)) , vec2(size.x * 0.5 * 0.6, size.y*1.1)));\n   return res;\n}\n\n\nfloat base( in vec3 pos, in vec3 size)\n{\n  \n   //base plate\n   float radius = 0.15;   \n    \n   float sdf = sdRoundBox(pos, size, radius);\n   float flangePos = 0.70 + 0.3 * sin(iTime*0.2);\n   float k = 0.3 + 0.1 * sin(iTime*0.5);\n   \n    \n   sdf = opSmoothUnion( sdf, flange(translate(pos, size * vec3(1.0, 0.0, flangePos)), vec3(1.0, size.y * 0.5, 0.5)),k);\n   sdf = opSmoothUnion( sdf, flange(translate(mirrorX(pos), size * vec3(1.0, 0.0, flangePos)), vec3(1.0, size.y * 0.5, 0.5)),k); \n   sdf = opSmoothUnion( sdf, flange(translate(pos, size * vec3(1.0, 0.0, -flangePos)), vec3(1.0, size.y * 0.5, 0.5)),k);\n   sdf = opSmoothUnion( sdf, flange(translate(mirrorX(pos), size * vec3(1.0, 0.0, -flangePos)), vec3(1.0, size.y * 0.5, 0.5)),k); \n\n   return sdf;\n}\n\nfloat model( in vec3 pos)\n{\n    vec3 size = vec3(1.0, 0.2, 2.0);\n    \n    float k = 0.5+ 0.3 * sin(iTime*0.5);\n    float h = 1.0 + 0.5 * (1.0+ sin(iTime*0.2));\n    float wRatio = 0.3;\n    float holeRatio = 0.8;\n    \n    float sdf = base(pos, size);\n    sdf = opSmoothUnion(sdf, sdBox(translate(pos, vec3(0.0, h * 0.5,0.0)), vec3(size.x * wRatio, h *0.5, size.z)),k);\n    \n    float inFill = sdBox(translate(pos, vec3(0.0, h * 0.5,0.0)), holeRatio * vec3(size.x*2.0, h *0.5, size.z));\n    float interSectionInill = opI(sdf, inFill);\n    sdf = opS(sdf, inFill);\n            \t\n    float cellSize = 0.05 + 0.25* (1.0+ sin(iTime*0.1));\n    float latticeRadius = 0.01 + 0.005 * cos(iTime*0.2);\n    sdf = opSmoothUnion(\n        \tsdf, \n        \topI(lattices(pos, cellSize, latticeRadius), interSectionInill),k*0.1); \n    \n    \n    sdf = opSmoothUnion( sdf, flange(rotateZ(translate(pos, vec3(0.0, h, 0)), 3.142*0.5), vec3(1.0, size.y * 0.5, 0.5)),k); \n    return sdf;\n}\n\n//Scene\n\nvec2 map( in vec3 pos )\n{\n    float color = 2.7;     \n    return vec2(model(pos), color);\n}\n\n// http://iquilezles.org/www/articles/boxfunctions/boxfunctions.htm\nvec2 iBox( in vec3 ro, in vec3 rd, in vec3 rad ) \n{\n    vec3 m = 1.0/rd;\n    vec3 n = m*ro;\n    vec3 k = abs(m)*rad;\n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n\treturn vec2( max( max( t1.x, t1.y ), t1.z ),\n\t             min( min( t2.x, t2.y ), t2.z ) );\n}\n\nconst float maxHei = 10.0;\n\nvec2 castRay( in vec3 ro, in vec3 rd )\n{\n    vec2 res = vec2(-1.0,-1.0);\n\n    float tmin = 1.0;\n    float tmax = 20.0;\n\n    // raytrace floor plane\n    float tp1 = (0.0-ro.y)/rd.y;\n    if( tp1>0.0 )\n    {\n        tmax = min( tmax, tp1 );\n        res = vec2( tp1, 0.0 );\n    }\n    \n    // raymarch primitives   \n    vec2 tb = iBox( ro-vec3(0.0,0.0,0.0), rd, vec3(1000.0,1000.0,1000.0) );\n    if( tb.x<tb.y && tb.y>0.0 && tb.x<tmax)\n    {\n        tmin = max(tb.x,tmin);\n        tmax = min(tb.y,tmax);\n\n        float t = tmin;\n        for( int i=0; i<70 && t<tmax; i++ )\n        {\n            vec2 h = map( ro+rd*t );\n            if( abs(h.x)<(0.00001*t) )\n            { \n                res = vec2(t,h.y); \n                 break;\n            }\n            t += h.x;\n        }\n    }\n    \n    return res;\n}\n\n\n// http://iquilezles.org/www/articles/rmshadows/rmshadows.htm\nfloat calcSoftshadow( in vec3 ro, in vec3 rd, in float mint, in float tmax )\n{\n    // bounding volume\n    float tp = (maxHei-ro.y)/rd.y; if( tp>0.0 ) tmax = min( tmax, tp );\n\n    float res = 1.0;\n    float t = mint;\n    for( int i=ZERO; i<16; i++ )\n    {\n\t\tfloat h = map( ro + rd*t ).x;\n        res = min( res, 8.0*h/t );\n        t += clamp( h, 0.02, 0.10 );\n        if( res<0.005 || t>tmax ) break;\n    }\n    return clamp( res, 0.0, 1.0 );\n}\n\n// http://iquilezles.org/www/articles/normalsSDF/normalsSDF.htm\nvec3 calcNormal( in vec3 pos )\n{\n#if 1\n    vec2 e = vec2(1.0,-1.0)*0.5773*0.0005;\n    return normalize( e.xyy*map( pos + e.xyy ).x + \n\t\t\t\t\t  e.yyx*map( pos + e.yyx ).x + \n\t\t\t\t\t  e.yxy*map( pos + e.yxy ).x + \n\t\t\t\t\t  e.xxx*map( pos + e.xxx ).x );\n#else\n    // inspired by tdhooper and klems - a way to prevent the compiler from inlining map() 4 times\n    vec3 n = vec3(0.0);\n    for( int i=ZERO; i<4; i++ )\n    {\n        vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);\n        n += e*map(pos+0.0005*e).x;\n    }\n    return normalize(n);\n#endif    \n}\n\nfloat calcAO( in vec3 pos, in vec3 nor )\n{\n\tfloat occ = 0.0;\n    float sca = 1.0;\n    for( int i=ZERO; i<5; i++ )\n    {\n        float hr = 0.01 + 0.12*float(i)/4.0;\n        vec3 aopos =  nor * hr + pos;\n        float dd = map( aopos ).x;\n        occ += -(dd-hr)*sca;\n        sca *= 0.95;\n    }\n    return clamp( 1.0 - 3.0*occ, 0.0, 1.0 ) * (0.5+0.5*nor.y);\n}\n\n// http://iquilezles.org/www/articles/checkerfiltering/checkerfiltering.htm\nfloat checkersGradBox( in vec2 p )\n{\n    // filter kernel\n    vec2 w = fwidth(p) + 0.001;\n    // analytical integral (box filter)\n    vec2 i = 2.0*(abs(fract((p-0.5*w)*0.5)-0.5)-abs(fract((p+0.5*w)*0.5)-0.5))/w;\n    // xor pattern\n    return 0.5 - 0.5*i.x*i.y;                  \n}\n\nvec3 render( in vec3 ro, in vec3 rd )\n{ \n    vec3 col = vec3(0.0, 0.0, 0.0) +rd.y*0.8;\n    vec2 res = castRay(ro,rd);\n    float t = res.x;\n\tfloat m = res.y;\n    if( m>-0.5 )\n    {\n        vec3 pos = ro + t*rd;\n        vec3 nor = (m<1.5) ? vec3(0.0,1.0,0.0) : calcNormal( pos );\n        vec3 ref = reflect( rd, nor );\n        \n        // material        \n\t\tcol = 0.35 + 0.45*sin( vec3(0.05,0.08,0.10)*(m-1.0) );\n        if( m<1.5 )\n        {\n            \n            float f = checkersGradBox( 1.0*pos.xz );\n            col = f*vec3(0.005);\n        }\n\n        // lighting\n        float occ = calcAO( pos, nor );\n\t\tvec3  lig = normalize( vec3(-0.4, 0.7, -0.6) );\n        vec3  hal = normalize( lig-rd );\n\t\tfloat amb = clamp( 0.5+0.5*nor.y, 0.0, 1.0 );\n        float dif = clamp( dot( nor, lig ), 0.0, 1.0 );\n        float bac = clamp( dot( nor, normalize(vec3(-lig.x,0.0,-lig.z))), 0.0, 1.0 )*clamp( 1.0-pos.y,0.0,1.0);\n        float dom = smoothstep( -0.2, 0.2, ref.y );\n        float fre = pow( clamp(1.0+dot(nor,rd),0.0,1.0), 2.0 );\n        \n        dif *= calcSoftshadow( pos, lig, 0.02, 2.5 );\n        dom *= calcSoftshadow( pos, ref, 0.02, 2.5 );\n\n\t\tfloat spe = pow( clamp( dot( nor, hal ), 0.0, 1.0 ),16.0)*\n                    dif *\n                    (0.04 + 0.96*pow( clamp(1.0+dot(hal,rd),0.0,1.0), 5.0 ));\n\n\t\tvec3 lin = vec3(0.0);\n        lin += 1.30*dif*vec3(1.00,0.80,0.55);\n        lin += 0.30*amb*vec3(0.40,0.60,1.00)*occ;\n        lin += 0.40*dom*vec3(0.40,0.60,1.00)*occ;\n        lin += 0.50*bac*vec3(0.25,0.25,0.25)*occ;\n        lin += 0.25*fre*vec3(1.00,1.00,1.00)*occ;\n\t\tcol = col*lin;\n\t\tcol += 9.00*spe*vec3(1.00,0.90,0.70);\n\n    \tcol = mix( col, vec3(0.0,0.0,0.0), 1.0-exp( -0.0002*t*t*t ) );\n    }\n\n\treturn vec3( clamp(col,0.0,1.0) );\n}\n\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr )\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv =          ( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\n\nvec4 renderScene(in vec2 fragCoord, float splitratio)\n{\n    vec3 Resolution = iResolution * splitratio;\n    \n    vec2 mo = iMouse.xy/iResolution.xy;\n\tfloat time = 15.0 + iTime * 0.05;\n\t\n    if (iTimeDelta > 0.5)\n    {\n        int skipStep = 5;\n        int offset = iFrame % skipStep;\n        if (( (int(fragCoord.x) % skipStep) == offset) || ((int(fragCoord.y) % skipStep) == offset))\n        {\n             discard;\n        }\n    }\n        \n    // camera\t\n    vec3 ro = vec3( 4.6*cos(0.1*time + 6.0*mo.x), 1.0 + 2.0*mo.y, 0.5 + 4.6*sin(0.1*time + 6.0*mo.x) );\n    vec3 ta = vec3( -0.5, -0.4, 0.5 );\n    // camera-to-world transformation\n    mat3 ca = setCamera( ro, ta, 0.0 );\n\n    vec3 tot = vec3(0.0);\n#if AA>1\n    for( int m=ZERO; m<AA; m++ )\n    for( int n=ZERO; n<AA; n++ )\n    {\n        // pixel coordinates\n        vec2 o = vec2(float(m),float(n)) / float(AA) - 0.5;\n        vec2 p = (-Resolution.xy + 2.0*(fragCoord+o))/Resolution.y;\n#else    \n        vec2 p = (-Resolution.xy + 2.0*fragCoord)/Resolution.y;\n#endif\n\n        // ray direction\n        vec3 rd = ca * normalize( vec3(p.xy,2.0) );\n\n        // render\t\n        vec3 col = render( ro, rd );\n\n\t\t// gamma\n        col = pow( col, vec3(0.4545) );\n\n        tot += col;\n#if AA>1\n    }\n    tot /= float(AA*AA);\n#endif\n\n    \n    return vec4( tot, 1.0 );\n}\n\nvec4 renderSDF(in vec2 fragCoord, float splitratio)\n{\n    float zoom = 5.0;\n    float zHeight = 0.5;\n\n    vec2 coordInFrame = fragCoord - splitratio * vec2(iResolution.x * splitratio, 0.0);\n    \n    vec2 uv = coordInFrame / (iResolution.xy) - vec2(0.5, 0.5);\n    vec3 pos = vec3(uv.x * zoom, zHeight, uv.y * zoom);\n    float d = map(pos).x;\n    \n   \n    vec3 col = vec3(1.0) - sign(d)*vec3(0.1,0.4,0.7);\n\tcol *= 1.0 - exp(-4.0*abs(d));\n\tcol *= 0.8 + 0.2*cos(500.0*d);\n\tcol = mix( col, vec3(1.0), 1.0-smoothstep(0.0,0.005,abs(d)) );\n  \n    \n    return vec4(col,1.0); \n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    float splitratio = 1.0;\n    if (texelFetch(iChannel0, ivec2(83, 0), 0).x > 0.)\n    {\n        splitratio = 0.5;\n    }\n    \n    \n    if (fragCoord.x < iResolution.x * splitratio)\n    {\n    \tfragColor = renderScene(fragCoord, splitratio);\n    }\n    else\n    {\n        fragColor = renderSDF(fragCoord, splitratio);\n    }\n}", "image_inputs": [{"id": "4dXGRr", "previewfilepath": "/presets/tex00.jpg", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/presets/tex00.jpg", "ctype": "keyboard"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wsjGWd.jpg", "access": "shaders20k", "license": "mit", "functions": [[1256, 1256, 1281, 1281, 1296], [1298, 1298, 1333, 1333, 1359], [1361, 1361, 1392, 1392, 1483], [1485, 1485, 1544, 1544, 1638], [1640, 1640, 1695, 1695, 1790], [1792, 1792, 1825, 1825, 1880], [1882, 1882, 1918, 1918, 2229], [2231, 2231, 2283, 2283, 2397], [2399, 2399, 2463, 2463, 2741], [2743, 2743, 2767, 2767, 2784], [2785, 2785, 2848, 2912, 3499], [3501, 3501, 3544, 3544, 3795], [3797, 3797, 3833, 3833, 4016], [4018, 4030, 4066, 4066, 4169], [4171, 4196, 4247, 4247, 4602], [4604, 4604, 4642, 4642, 4811], [4813, 4813, 4838, 4838, 4857], [4858, 4858, 4929, 4929, 5267], [5270, 5270, 5307, 5307, 5618], [5621, 5621, 5646, 5646, 5683], [5685, 5685, 5710, 5710, 5768], [5770, 5770, 5795, 5795, 5860], [5862, 5862, 5897, 5897, 5968], [5970, 5970, 6005, 6005, 6076], [6078, 6078, 6115, 6115, 6168], [6242, 6257, 6290, 6290, 6316], [6318, 6326, 6356, 6356, 6389], [6392, 6392, 6425, 6425, 6447], [6450, 6465, 6499, 6499, 6526], [6528, 6528, 6558, 6558, 6581], [6584, 6584, 6636, 6636, 6736], [6738, 6738, 6797, 6797, 6898], [6900, 6900, 6960, 6960, 7060], [7062, 7076, 7117, 7117, 7207], [7210, 7228, 7264, 7264, 7362], [7364, 7364, 7400, 7400, 7498], [7499, 7499, 7535, 7535, 7633], [7635, 7635, 7683, 7683, 7713], [7715, 7715, 7742, 7742, 7783], [7908, 7908, 7959, 7959, 8409], [8412, 8412, 8467, 8467, 8530], [8533, 8533, 8575, 8575, 8896], [8899, 8899, 8939, 8958, 9656], [9658, 9658, 9685, 9685, 10619], [10630, 10630, 10655, 10655, 10721], [10723, 10791, 10842, 10842, 11047], [11077, 11077, 11117, 11117, 11880], [11883, 11945, 12023, 12046, 12387], [12389, 12453, 12485, 12485, 13016], [13018, 13018, 13060, 13060, 13376], [13378, 13454, 13490, 13511, 13734], [13736, 13736, 13775, 13775, 15494], [15496, 15496, 15548, 15548, 15725]], "test": "error"}
{"id": "wsjSDK", "name": "Part 2 - Challenges", "author": "sanddroo", "description": "gg", "tags": ["part2"], "likes": 2, "viewed": 260, "published": "Public API", "date": "1554998827", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/**\n * Part 2 Challenges\n * - Change the diffuse color of the sphere to be blue\n * - Change the specular color of the sphere to be green\n * - Make one of the lights pulse by having its intensity vary over time\n * - Add a third light to the scene\n */\n\nconst int MAX_MARCHING_STEPS = 255;\nconst float MIN_DIST = 0.0;\nconst float MAX_DIST = 100.0;\nconst float EPSILON = 0.0001;\n\n/**\n * Signed distance function for a sphere centered at the origin with radius 1.0;\n */\nfloat sphereSDF(vec3 samplePoint) {\n    return length(samplePoint) - 1.0;\n}\n\n/**\n * Signed distance function describing the scene.\n * \n * Absolute value of the return value indicates the distance to the surface.\n * Sign indicates whether the point is inside or outside the surface,\n * negative indicating inside.\n */\nfloat sceneSDF(vec3 samplePoint) {\n    return sphereSDF(samplePoint);\n}\n\n/**\n * Return the shortest distance from the eyepoint to the scene surface along\n * the marching direction. If no part of the surface is found between start and end,\n * return end.\n * \n * eye: the eye point, acting as the origin of the ray\n * marchingDirection: the normalized direction to march in\n * start: the starting distance away from the eye\n * end: the max distance away from the ey to march before giving up\n */\nfloat shortestDistanceToSurface(vec3 eye, vec3 marchingDirection, float start, float end) {\n    float depth = start;\n    for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n        float dist = sceneSDF(eye + depth * marchingDirection);\n        if (dist < EPSILON) {\n\t\t\treturn depth;\n        }\n        depth += dist;\n        if (depth >= end) {\n            return end;\n        }\n    }\n    return end;\n}\n            \n\n/**\n * Return the normalized direction to march in from the eye point for a single pixel.\n * \n * fieldOfView: vertical field of view in degrees\n * size: resolution of the output image\n * fragCoord: the x,y coordinate of the pixel in the output image\n */\nvec3 rayDirection(float fieldOfView, vec2 size, vec2 fragCoord) {\n    vec2 xy = fragCoord - size / 2.0;\n    float z = size.y / tan(radians(fieldOfView) / 2.0);\n    return normalize(vec3(xy, -z));\n}\n\n/**\n * Using the gradient of the SDF, estimate the normal on the surface at point p.\n */\nvec3 estimateNormal(vec3 p) {\n    return normalize(vec3(\n        sceneSDF(vec3(p.x + EPSILON, p.y, p.z)) - sceneSDF(vec3(p.x - EPSILON, p.y, p.z)),\n        sceneSDF(vec3(p.x, p.y + EPSILON, p.z)) - sceneSDF(vec3(p.x, p.y - EPSILON, p.z)),\n        sceneSDF(vec3(p.x, p.y, p.z  + EPSILON)) - sceneSDF(vec3(p.x, p.y, p.z - EPSILON))\n    ));\n}\n\n/**\n * Lighting contribution of a single point light source via Phong illumination.\n * \n * The vec3 returned is the RGB color of the light's contribution.\n *\n * k_a: Ambient color\n * k_d: Diffuse color\n * k_s: Specular color\n * alpha: Shininess coefficient\n * p: position of point being lit\n * eye: the position of the camera\n * lightPos: the position of the light\n * lightIntensity: color/intensity of the light\n *\n * See https://en.wikipedia.org/wiki/Phong_reflection_model#Description\n */\nvec3 phongContribForLight(vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye,\n                          vec3 lightPos, vec3 lightIntensity) {\n    vec3 N = estimateNormal(p);\n    vec3 L = normalize(lightPos - p);\n    vec3 V = normalize(eye - p);\n    vec3 R = normalize(reflect(-L, N));\n    \n    float dotLN = dot(L, N);\n    float dotRV = dot(R, V);\n    \n    if (dotLN < 0.0) {\n        // Light not visible from this point on the surface\n        return vec3(0.0, 0.0, 0.0);\n    } \n    \n    if (dotRV < 0.0) {\n        // Light reflection in opposite direction as viewer, apply only diffuse\n        // component\n        return lightIntensity * (k_d * dotLN);\n    }\n    return lightIntensity * (k_d * dotLN + k_s * pow(dotRV, alpha));\n}\n\n/**\n * Lighting via Phong illumination.\n * \n * The vec3 returned is the RGB color of that point after lighting is applied.\n * k_a: Ambient color\n * k_d: Diffuse color\n * k_s: Specular color\n * alpha: Shininess coefficient\n * p: position of point being lit\n * eye: the position of the camera\n *\n * See https://en.wikipedia.org/wiki/Phong_reflection_model#Description\n */\nvec3 phongIllumination(vec3 k_a, vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye) {\n    const vec3 ambientLight = 0.5 * vec3(1.0, 1.0, 1.0);\n    vec3 color = ambientLight * k_a;\n    \n    //light 1\n    vec3 light1Pos = vec3(4.0 * sin(iTime),\n                          2.0,\n                          4.0 * cos(iTime));\n    vec3 light1Intensity = vec3(0.4, 0.4, 0.4);\n    \n    color += phongContribForLight(k_d, k_s, alpha, p, eye,\n                                  light1Pos,\n                                  light1Intensity);\n    \n    //light 2\n    vec3 light2Pos = vec3(1.0 * sin(0.37 * iTime),\n                          1.0 * cos(0.37 * iTime),\n                          1.0);//DR: change the light pulse from SIN(0.37 to 2.37)\n    vec3 light2Intensity = vec3(0.4, 0.4, 0.4);\n    \n    color += phongContribForLight(k_d, k_s, alpha, p, eye,\n                                  light2Pos,\n                                  light2Intensity);\n    \n    //light 3\n    //DR: adding the third lights\n    vec3 light3Pos = vec3(-4.0 * sin(iTime),\n                          -2.0,\n                          -4.0 * cos(iTime));\n    vec3 light3Intensity = vec3(0.2, 0.4, 0.4);\n    \n    color += phongContribForLight(k_d, k_s, alpha, p, eye,\n                                  light3Pos,\n                                  light3Intensity);\n    \n    \n    return color;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec3 dir = rayDirection(45.0, iResolution.xy, fragCoord);\n    vec3 eye = vec3(0.0, 0.0, 5.0);\n    float dist = shortestDistanceToSurface(eye, dir, MIN_DIST, MAX_DIST);\n    \n    if (dist > MAX_DIST - EPSILON) {\n        // Didn't hit anything\n        fragColor = vec4(0.0, 0.0, 0.0, 0.0);\n\t\treturn;\n    }\n    \n    // The closest point on the surface to the eyepoint along the view ray\n    vec3 p = eye + dist * dir;\n    \n    vec3 K_a = vec3(0.2, 0.1, 0.5);\n    vec3 K_d = vec3(0.0, 1.0, 1.0);//DR:  change the diffuse color to blue\n    vec3 K_s = vec3(0.0, 1.0, 0.0);//DR: change the specular color to green\n    float shininess = 10.0;\n    \n    vec3 color = phongIllumination(K_a, K_d, K_s, shininess, p, eye);\n    \n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wsjSDK.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[376, 465, 500, 500, 540], [542, 782, 816, 816, 853], [855, 1276, 1367, 1367, 1673], [1688, 1942, 2007, 2007, 2139], [2141, 2230, 2259, 2259, 2569], [2571, 3063, 3203, 3203, 3793], [3795, 4165, 4250, 4250, 5520], [5523, 5523, 5580, 5580, 6331]], "test": "ok"}
{"id": "wsjSWy", "name": "Finals_Shader04_Co", "author": "johannco98", "description": "and", "tags": ["asd"], "likes": 1, "viewed": 42, "published": "Public", "date": "1554890988", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float rect(vec2 uv, vec2 pos, float width, float height)\n{\n    float square = (step(pos.x - width, uv.x) - step(pos.x + width, uv.x)) *\n                   (step(pos.y - height, uv.y) - step(pos.y + height, uv.y));\n    \n    \n    return square;\n}\n\nmat2 rotate2d(float angle)\n{\n    return mat2 (cos(angle), -sin(angle), sin(angle), cos(angle));\n}\n\nmat2 scale2d(vec2 value)\n{\n    return mat2 (value.x, 0, 0,  value.y);\n    \n}\n\nfloat Circle(vec2 uv, vec2 pos, float rad, float blur) \n{\n\tfloat d = length(uv-pos);\n\tfloat t = smoothstep(rad, rad-blur, d);\n    \n    \n\treturn t;\n}\n\nfloat rand(vec2 uv)\n{\n    //return fract(sin(dot(uv, vec2(12.9898,78.233)))*10000.*iTime);\n\t//return fract(sin(dot(uv, iMouse.xy))*10000.);\n\t//return (fract(sin(dot(uv, vec2(12., 70.)))*100000.));\n    return (fract(sin(dot(uv, vec2(12., 70.)))*43758.5453123));\n}\n\n// Value noise\nfloat noise(in vec2 st) {\n    vec2 i = floor(st);\n    vec2 f = fract(st);\n\n    // Four corners in 2D of a tile\n    float a = rand(i);\n    float b = rand(i + vec2(1.0, 0.0));\n    float c = rand(i + vec2(0.0, 1.0));\n    float d = rand(i + vec2(1.0, 1.0));\n\n    // Smooth Interpolation\n\n    // Cubic Hermine Curve.  Same as SmoothStep()\n    vec2 u = f*f*(3.0-2.0*f);\n    // u = smoothstep(0.,1.,f);\n\n    // Mix 4 coorners porcentages\n    return mix(a, b, u.x) + \n            (c - a)* u.y * (1.0 - u.x) + \n            (d - b) * u.x * u.y;\n}\n\n// Gradient noise\nvec2 hash( vec2 x )  // replace this by something better\n{\n    const vec2 k = vec2( 0.3183099, 0.3678794 );\n    x = x*k + k.yx;\n    return -1.0 + 2.0*fract( 16.0 * k*fract( x.x*x.y*(x.x+x.y)) );\n}\n\nfloat gnoise( in vec2 p )\n{\n    vec2 i = floor( p );\n    vec2 f = fract( p );\n\t\n\tvec2 u = f*f*(3.0-2.0*f);\n\n    return mix( mix( dot( hash( i + vec2(0.0,0.0) ), f - vec2(0.0,0.0) ), \n                     dot( hash( i + vec2(1.0,0.0) ), f - vec2(1.0,0.0) ), u.x),\n                mix( dot( hash( i + vec2(0.0,1.0) ), f - vec2(0.0,1.0) ), \n                     dot( hash( i + vec2(1.0,1.0) ), f - vec2(1.0,1.0) ), u.x), u.y);\n}\n\n// Simplex noise\nvec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec2 mod289(vec2 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec3 permute(vec3 x) { return mod289(((x*34.0)+1.0)*x); }\n\nfloat snoise(vec2 v) {\n    const vec4 C = vec4(0.211324865405187,  // (3.0-sqrt(3.0))/6.0\n                        0.366025403784439,  // 0.5*(sqrt(3.0)-1.0)\n                        -0.577350269189626,  // -1.0 + 2.0 * C.x\n                        0.024390243902439); // 1.0 / 41.0\n    vec2 i  = floor(v + dot(v, C.yy) );\n    vec2 x0 = v -   i + dot(i, C.xx);\n    vec2 i1;\n    i1 = (x0.x > x0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);\n    vec4 x12 = x0.xyxy + C.xxzz;\n    x12.xy -= i1;\n    i = mod289(i); // Avoid truncation effects in permutation\n    vec3 p = permute( permute( i.y + vec3(0.0, i1.y, 1.0 ))\n        + i.x + vec3(0.0, i1.x, 1.0 ));\n\n    vec3 m = max(0.5 - vec3(dot(x0,x0), dot(x12.xy,x12.xy), dot(x12.zw,x12.zw)), 0.0);\n    m = m*m ;\n    m = m*m ;\n    vec3 x = 2.0 * fract(p * C.www) - 1.0;\n    vec3 h = abs(x) - 0.5;\n    vec3 ox = floor(x + 0.5);\n    vec3 a0 = x - ox;\n    m *= 1.79284291400159 - 0.85373472095314 * ( a0*a0 + h*h );\n    vec3 g;\n    g.x  = a0.x  * x0.x  + h.x  * x0.y;\n    g.yz = a0.yz * x12.xz + h.yz * x12.yw;\n    return 130.0 * dot(m, g);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n     //Colors in vec3\n    vec3 red = vec3(0.8 ,0.0 ,0.0);\n    vec3 white = vec3(1.0, 1.0, 1.0);\n    vec3 yellow = vec3(0.9, 0.9, 0.3);\n    vec3 blue = vec3(0.0, 0.2, 1.0);\n    vec3 black = vec3(0.0, 0.0, 0.0);\n    vec3 green = vec3(0.0, 1.0, 0.0);\n    \n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 iuv = uv;\n\tfloat ratio = iResolution.x / iResolution.y;\n    uv *= 3.0;\n    \n    \n    float offset = -step(mod(uv.y,2.0), 1.0);\n    offset -= -step(1.0, mod(1.0, mod(uv.y, 2.0)));\n    \n    //change uv.y to uv.x to change from collumns to rows\n    uv.x += offset * iTime;\n    uv.x /= ratio;\n    \n    uv *= 2.0;\n    \n    vec2 pos = vec2(0.3*ratio, 0.5);  \n    \n    uv = fract(uv);\n    \n\n    uv -= pos ;\n    uv *= rotate2d(-abs(sin(iTime * 0.05)));\n    uv += pos;\n   \n    \n    uv *= 4.0;\n    float value = gnoise(uv + (sin(iTime) * 0.005));\n    \n    //music shiz\n    float val = noise(uv + (iTime) * (iTime * 0.001) - (uv.x*1000.0));\n    \n    val = val + snoise(uv + (iTime * 0.0) + vec2(0.0, -iTime*5.0));\n    \n    \n    //waves\n    val = step(-0.1*val, uv.y) - step(1.5*val, uv.y);\n    \n    \n    vec3 lampLight = abs(vec3(\n        \t\t\t\t  clamp(abs(sin(iTime)),0.3 , 0.8 ),\n                          clamp(abs(cos(iTime)),0.4 , 0.9 ), \n                          clamp(abs(sin(iTime)),0.4 , 1.0 ))\n                        \t );\n    \n    \n    vec3 Val = mix(black, lampLight, val);\n    \n    fragColor = vec4(Val ,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wsjSWy.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 58, 58, 244], [246, 246, 274, 274, 343], [345, 345, 371, 371, 421], [423, 423, 480, 480, 571], [573, 573, 594, 769, 835], [837, 852, 877, 877, 1388], [1390, 1408, 1466, 1466, 1604], [1606, 1606, 1633, 1633, 2031], [2033, 2050, 2071, 2071, 2118], [2119, 2119, 2140, 2140, 2187], [2188, 2188, 2210, 2210, 2245], [2247, 2247, 2269, 2269, 3317], [3320, 3320, 3377, 3399, 4792]], "test": "ok"}
{"id": "WsjSzd", "name": "cam feeds the heightfield", "author": "gagarinloops", "description": "raycasting a heightfield defined by luminance of video stream", "tags": ["video", "heightfield"], "likes": 6, "viewed": 468, "published": "Public", "date": "1554737325", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Fork of \"video heightfield\" by simesgreen. https://shadertoy.com/view/Xss3zr\n// 2019-04-08 15:23:35\n\n// @simesgreen\n\nconst int _Steps = 312;\nconst vec3 lightDir = vec3(0.577, 0.177, 0.577);\n\n// transforms\nvec3 rotateX(vec3 p, float a)\n{\n    float sa = sin(a);\n    float ca = cos(a);\n    vec3 r;\n    r.x = p.x;\n    r.y = ca*p.y - sa*p.z;\n    r.z = sa*p.y + ca*p.z;\n    return r;\n}\n\nvec3 rotateY(vec3 p, float a)\n{\n    float sa = sin(a);\n    float ca = cos(a);\n    vec3 r;\n    r.x = ca*p.x + sa*p.z;\n    r.y = p.y;\n    r.z = -sa*p.x + ca*p.z;\n    return r;\n}\n\nbool\nintersectBox(vec3 ro, vec3 rd, vec3 boxmin, vec3 boxmax, out float tnear, out float tfar)\n{\n\t// compute intersection of ray with all six bbox planes\n\tvec3 invR = 1.0 / rd;\n\tvec3 tbot = invR * (boxmin - ro);\n\tvec3 ttop = invR * (boxmax - ro);\n\t// re-order intersections to find smallest and largest on each axis\n\tvec3 tmin = min (ttop, tbot);\n\tvec3 tmax = max (ttop, tbot);\n\t// find the largest tmin and the smallest tmax\n\tvec2 t0 = max (tmin.xx, tmin.yz);\n\ttnear = min (t0.x, t0.y);\n\tt0 = min (tmax.xx, tmax.yz);\n\ttfar = min (t0.x, t0.y);\n\t// check for hit\n\tbool hit;\n\tif ((tnear > tfar)) \n\t\thit = false;\n\telse\n\t\thit = true;\n\treturn hit;\n}\n\nfloat luminance(sampler2D tex, vec2 uv)\n{\n\tvec3 c = textureLod(tex, uv, 0.0).xyz;\n\treturn dot(c, vec3(0.33, 0.333, 0.33));\n}\n\nvec2 gradient(sampler2D tex, vec2 uv, vec2 texelSize)\n{\n\tfloat h = luminance(tex, uv);\n\tfloat hx = luminance(tex, uv + texelSize*vec2(1.0, 0.0));\t\n\tfloat hy = luminance(tex, uv + texelSize*vec2(0.0, 1.0));\n\treturn vec2(hx + h, hy * h);\n}\n\nvec2 worldToTex(vec3 p)\n{\n\tvec2 uv = p.xz*0.5+0.5;\n\tuv.y = 1.0 - uv.y;\n\treturn uv;\n}\n\nfloat heightField(vec3 p)\n{\n\t//return sin(p.x*4.0)*sin(p.z*4.0);\n\t//return luminance(iChannel0, p.xz*0.5+0.5)*2.0-1.0;\n\treturn luminance(iChannel0, worldToTex(p))*0.5;\n}\n\nbool traceHeightField(vec3 ro, vec3 rayStep, out vec3 hitPos)\n{\n\tvec3 p = ro;\n\tbool hit = false;\n\tfloat pH = 0.0;\n\tvec3 pP = p;\n\tfor(int i=0; i<_Steps; i++) {\n\t\tfloat h = heightField(p);\n\t\tif ((p.y < h) && !hit) {\n\t\t\thit = true;\n\t\t\t//hitPos = p;\n\t\t\t// interpolate based on height\n            hitPos = mix(pP, p, (pH - pP.y) / ((p.y - pP.y) - (h - pH)));\n\t\t}\n\t\tpH = h;\n\t\tpP = p;\n\t\tp += rayStep;\n\t}\n\treturn hit;\n}\n\nvec3 background(vec3 rd)\n{\n     return mix(vec3(1.0, 1.0, 1.0), vec3(0.0, 0.5, 1.0), abs(rd.y));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 pixel = (fragCoord.xy / iResolution.xy)*2.0-1.0;\n\n    // compute ray origin and direction\n    float asp = iResolution.x / iResolution.y;\n    vec3 rd = normalize(vec3(asp*pixel.x, pixel.y, -2.0));\n    vec3 ro = vec3(0.0, 0.0, 2.0);\n\t\t\n\tvec2 mouse = iMouse.xy / iResolution.xy;\n\n\t// rotate view\n    float ax = -0.7;\n\tif (iMouse.x > 0.0) {\n    \tax = -(1.0 - mouse.y)*2.0 - 1.0;\n\t}\n    rd = rotateX(rd, ax);\n    ro = rotateX(ro, ax);\n\t\t\n\tfloat ay = sin(iTime*0.2);\n    rd = rotateY(rd, ay);\n    ro = rotateY(ro, ay);\n\t\n\t// intersect with bounding box\n    bool hit;\t\n\tconst vec3 boxMin = vec3(-1.0, -0.01, -1.0);\n\tconst vec3 boxMax = vec3(1.0, 0.5, 1.0);\n\tfloat tnear, tfar;\n\thit = intersectBox(ro, rd, boxMin, boxMax, tnear, tfar);\n\n\ttnear -= 0.0001;\n\tvec3 pnear = ro + rd*tnear;\n    vec3 pfar = ro + rd*tfar;\n\t\n    float stepSize = length(pfar - pnear) / float(_Steps);\n\t\n    vec3 rgb = background(rd);\n    if(hit)\n    {\n    \t// intersect with heightfield\n\t\tro = pnear;\n\t\tvec3 hitPos;\n\t\thit = traceHeightField(ro, rd*stepSize, hitPos);\n\t\tif (hit) {\n\t\t\trgb = hitPos*0.5+1.5;\n\t\t\tvec2 uv = worldToTex(hitPos);\n\t\t\trgb = texture(iChannel0, uv).xyz;\n\t\t\t//vec2 g = gradient(iChannel0, uv, vec2(1.0) / iResolution.xy);\n\t\t\t//vec3 n = normalize(vec3(g.x, 0.01, g.y));\n\t\t\t//rgb = n*0.5+0.5;\n#if 0\n\t\t\t// shadows\n\t\t\thitPos += vec3(0.0, 0.01, 0.0);\n\t\t\tbool shadow = traceHeightField(hitPos, lightDir*0.01, hitPos);\n\t\t\tif (shadow) {\n\t\t\t\trgb *= 0.75;\n\t\t\t}\n#endif\t\t\t\n\t\t}\n     }\n\n    fragColor=vec4(rgb, 1.0);\n\t//fragColor = vec4(vec3(tfar - tnear)*0.2, 1.0);\n}\n", "image_inputs": [{"id": "4sf3zn", "previewfilepath": "/presets/webcam.png", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/presets/webcam.png", "ctype": "webcam"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WsjSzd.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[194, 208, 239, 239, 382], [384, 384, 415, 415, 559], [561, 561, 657, 714, 1205], [1207, 1207, 1248, 1248, 1331], [1333, 1333, 1388, 1388, 1570], [1572, 1572, 1597, 1597, 1656], [1658, 1658, 1685, 1776, 1827], [1829, 1829, 1892, 1892, 2240], [2242, 2242, 2268, 2268, 2340], [2342, 2342, 2399, 2399, 3949]], "test": "error"}
{"id": "WsjXDK", "name": "Gyroidal Torus", "author": "dr2", "description": "Gyroid surface transformed into toroidal torus", "tags": ["raymarch", "surface", "gyroid"], "likes": 16, "viewed": 383, "published": "Public API", "date": "1554971961", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// \"Gyroidal Torus\" by dr2 - 2019\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\n#define AA  1   // optional antialiasing\n\nfloat PrTorusDf (vec3 p, float ri, float rc);\nfloat Minv3 (vec3 p);\nfloat SmoothMax (float a, float b, float r);\nvec2 Rot2D (vec2 q, float a);\n\nvec3 ltDir;\nfloat dstFar;\nint idObj;\nconst float pi = 3.14159;\n\n#define DMIN(id) if (d < dMin) { dMin = d;  idObj = id; }\n\nfloat ObjDf (vec3 p)\n{\n  vec3 q;\n  float dMin, d, rt, rg, tt, ws;\n  dMin = dstFar;\n  rt = 20.;\n  rg = 6.;\n  tt = 0.5 * pi;\n  ws = 0.2;\n  q = p;\n  d = PrTorusDf (q.xzy, 1., rt);\n  DMIN (1);\n  q.xz = vec2 (rt * atan (q.z, - q.x), length (q.xz) - rt);\n  q.yz = vec2 (rg * atan (q.z, - q.y), length (q.yz) - rg);\n  d = 0.6 * SmoothMax (abs (dot (sin (q), cos (q).yzx)) - ws, abs (q.z) - tt, 0.2);\n  DMIN (2);\n  return dMin;\n}\n\nfloat ObjRay (vec3 ro, vec3 rd)\n{\n  float dHit, d;\n  dHit = 0.;\n  for (int j = 0; j < 120; j ++) {\n    d = ObjDf (ro + dHit * rd);\n    if (d < 0.0005 || dHit > dstFar) break;\n    dHit += d;\n  }\n  return dHit;\n}\n\nvec3 ObjNf (vec3 p)\n{\n  vec4 v;\n  vec2 e = vec2 (0.0002, -0.0002);\n  v = vec4 (- ObjDf (p + e.xxx), ObjDf (p + e.xyy), ObjDf (p + e.yxy), ObjDf (p + e.yyx));\n  return normalize (2. * v.yzw - dot (v, vec4 (1.)));\n}\n\nfloat ObjSShadow (vec3 ro, vec3 rd)\n{\n  float sh, d, h;\n  sh = 1.;\n  d = 0.1;\n  for (int j = 0; j < 30; j ++) {\n    h = ObjDf (ro + d * rd);\n    sh = min (sh, smoothstep (0., 0.05 * d, h));\n    d += clamp (h, 0.1, 0.5);\n    if (sh < 0.05) break;\n  }\n  return 0.5 + 0.5 * sh;\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  vec4 col4;\n  vec3 col, vn, w;\n  float dstObj, sh, nDotL;\n  dstObj = ObjRay (ro, rd);\n  if (dstObj < dstFar) {\n    ro += dstObj * rd;\n    vn = ObjNf (ro);\n    if (idObj == 1) col4 = vec4 (1., 0.5, 1., 0.5);\n    else if (idObj == 2) {\n      w = mod (8. * ro / pi, 1.);\n      w = min (w, 1. - w);\n      col4 = vec4 (1., 0.7, 0.1, 0.3) * (0.8 + 0.2 * smoothstep (0.05, 0.07, Minv3 (w)));\n    }\n    sh = ObjSShadow (ro, ltDir);\n    nDotL = max (dot (vn, ltDir), 0.);\n    col = col4.rgb * (0.2 + 0.8 * sh * nDotL * nDotL) +\n       col4.a * step (0.95, sh) * sh * pow (max (dot (normalize (ltDir - rd), vn), 0.), 64.);\n  } else col = vec3 (0.6, 0.6, 1.) * (0.2 + 0.2 * (rd.y + 1.) * (rd.y + 1.));\n  return clamp (col, 0., 1.);\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  mat3 vuMat;\n  vec4 mPtr;\n  vec3 ro, rd, col;\n  vec2 canvas, uv, ori, ca, sa;\n  float tCur, el, az, sr;\n  canvas = iResolution.xy;\n  uv = 2. * fragCoord.xy / canvas - 1.;\n  uv.x *= canvas.x / canvas.y;\n  tCur = iTime;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / canvas - 0.5;\n  az = 0.;\n  el = -0.1 * pi;\n  if (mPtr.z > 0.) {\n    az += 2. * pi * mPtr.x;\n    el += pi * mPtr.y;\n  } else {\n    az += 0.3 * pi * sin (0.1 * pi * tCur);\n    el += 0.1 * pi * sin (0.03 * pi * tCur);\n  }\n  ori = vec2 (el, az);\n  ca = cos (ori);\n  sa = sin (ori);\n  vuMat = mat3 (ca.y, 0., - sa.y, 0., 1., 0., sa.y, 0., ca.y) *\n          mat3 (1., 0., 0., 0., ca.x, - sa.x, 0., sa.x, ca.x);\n  ro = vuMat * vec3 (0., 0., -60.);\n  dstFar = 150.;\n  ltDir = vuMat * normalize (vec3 (1., 1., -1.));\n#if ! AA\n  const float naa = 1.;\n#else\n  const float naa = 3.;\n#endif  \n  col = vec3 (0.);\n  sr = 2. * mod (dot (mod (floor (0.5 * (uv + 1.) * canvas), 2.), vec2 (1.)), 2.) - 1.;\n  for (float a = 0.; a < naa; a ++) {\n    rd = vuMat * normalize (vec3 (uv + step (1.5, naa) * Rot2D (vec2 (0.5 / canvas.y, 0.),\n       sr * (0.667 * a + 0.5) * pi), 2.));\n    col += (1. / naa) * ShowScene (ro, rd);\n  }\n  fragColor = vec4 (col, 1.);\n}\n\nfloat PrTorusDf (vec3 p, float ri, float rc)\n{\n  return length (vec2 (length (p.xy) - rc, p.z)) - ri;\n}\n\nfloat Minv3 (vec3 p)\n{\n  return min (p.x, min (p.y, p.z));\n}\n\nfloat Maxv3 (vec3 p)\n{\n  return max (p.x, max (p.y, p.z));\n}\n\nfloat SmoothMin (float a, float b, float r)\n{\n  float h;\n  h = clamp (0.5 + 0.5 * (b - a) / r, 0., 1.);\n  return mix (b, a, h) - r * h * (1. - h);\n}\n\nfloat SmoothMax (float a, float b, float r)\n{\n  return - SmoothMin (- a, - b, r);\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  vec2 cs;\n  cs = sin (a + vec2 (0.5 * pi, 0.));\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WsjXDK.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[431, 431, 453, 453, 852], [854, 854, 887, 887, 1064], [1066, 1066, 1087, 1087, 1279], [1281, 1281, 1318, 1318, 1557], [1559, 1559, 1594, 1594, 2318], [2320, 2320, 2376, 2376, 3573], [3575, 3575, 3621, 3621, 3678], [3680, 3680, 3702, 3702, 3740], [3742, 3742, 3764, 3764, 3802], [3804, 3804, 3849, 3849, 3952], [3954, 3954, 3999, 3999, 4037], [4039, 4039, 4069, 4069, 4182]], "test": "error"}
{"id": "WsjXRG", "name": "Cs230", "author": "doyounglee", "description": "change color with position of cursor & automatically", "tags": ["colormouse"], "likes": 1, "viewed": 52, "published": "Public", "date": "1554212513", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/*------------------------------------------------------------------------\nFile Name:Extra Credit-Fragment Shader\nCourse name: Cs230Kr\nAssignment name/Number:Shader Programming Assignment/3\nAuthor:Doyeong Yi\nTerm:Spring 2019\n------------------------------------------------------------------------*/\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )//A function to accept both out(vec4 fragColor) and in-type(vec2 fragCoord).\n{\n    float mouseX = iMouse.x; \n    //declaration of float type variable that get the x coordinates of the mouse\n    float mouseY = iMouse.y;\n    //declaration of float type variable that get the y coordinates of the mouse\n    \n    fragColor = vec4(sin(mouseX), cos(mouseY) ,abs(sin(iTime)),0);\n    //Colors change depending on the coordinates of the mouse and automatically.\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WsjXRG.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 300, 433, 433, 809]], "test": "ok"}
{"id": "WsjXRK", "name": "Tank Patrol", "author": "dr2", "description": "Tanks, tracks, fire and smoke", "tags": ["fire", "smoke", "track"], "likes": 14, "viewed": 408, "published": "Public API", "date": "1554366212", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// \"Tank Patrol\" by dr2 - 2019\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\n#define AA  1   // optional antialiasing\n\nfloat PrSphDf (vec3 p, float r);\nfloat PrCylDf (vec3 p, float r, float h);\nfloat PrCylAnDf (vec3 p, float r, float w, float h);\nfloat PrFlatCylDf (vec3 p, float rhi, float rlo, float h);\nfloat PrFlatCylAnDf (vec3 p, float rhi, float rlo, float w, float h);\nfloat PrTorusDf (vec3 p, float ri, float rc);\nfloat SmoothBump (float lo, float hi, float w, float x);\nvec2 Rot2D (vec2 q, float a);\nfloat Fbm1 (float p);\nfloat Fbm2 (vec2 p);\nfloat Fbm3 (vec3 p);\nvec3 VaryNf (vec3 p, vec3 n, float f);\n\nvec3 sunDir, qHit;\nfloat tCur, dstFar, canEl, canAz, canLen, smkRadEx, smkRadIn, smkPhs, flmLen, whlSpc, whlRad,\n   bltThk, bltWid, veGap;\nint idObj;\nconst float pi = 3.14159;\nconst int idBelt = 1, idWhl = 2, idAxl = 3, idBase = 4, idTur = 5, idCan = 6;\n\n#define DMINQ(id) if (d < dMin) { dMin = d;  idObj = id;  qHit = q; }\n\nfloat ObjDf (vec3 p)\n{\n  vec3 q;\n  float dMin, d, qx, qz, r, xLim;\n  dMin = dstFar;\n  xLim = abs (p.x) - 1.5 * veGap;\n  p.x = mod (p.x + 0.5 * veGap, veGap) - 0.5 * veGap;\n  q = p;\n  q.y -= whlRad + 2. * bltThk;\n  qx = q.x;\n  q.x = abs (q.x) - 0.8 * whlSpc;\n  d = PrFlatCylAnDf (q.zyx, whlSpc, whlRad + bltThk, bltThk, bltWid);\n  DMINQ (idBelt);\n  qz = q.z;\n  q.z = mod (q.z + 0.5 * whlSpc, whlSpc) - 0.5 * whlSpc;\n  d = max (min (PrCylAnDf (q.yzx, 0.9 * whlRad, 0.1 * whlRad, 1.2 * bltWid),\n     PrCylDf (q.yzx, 0.8 * whlRad, 0.5 * bltWid)), abs (qz) - whlSpc - whlRad);\n  DMINQ (idWhl);\n  q.x = qx;\n  d = max (PrCylDf (q.yzx, 0.2 * whlRad, 0.9 * whlSpc), abs (qz) - whlSpc - whlRad);\n  DMINQ (idAxl);\n  q = p;\n  q.y -= 1.4 * whlRad + 2. * bltThk;\n  d = 0.8 * PrFlatCylDf (q.zyx, whlSpc + whlRad, 0.9 * whlRad * (1. - 0.5 * q.x * q.x),\n     0.8 * whlSpc - 1.5 * bltWid);\n  DMINQ (idBase);\n  r = 1.1 * (0.8 * whlSpc - 1.5 * bltWid);\n  q.xz = Rot2D (q.xz, canAz);\n  q.y -= 0.9 * whlRad - 0.5 * r;\n  d = max (PrSphDf (q, r), - (q.y - 0.5 * r));\n  DMINQ (idTur);\n  q.y -= 0.58 * r;\n  q.yz = Rot2D (q.yz, canEl);\n  q.z -= canLen;\n  d = PrCylAnDf (q, 0.12 * whlRad, 0.04 * whlRad, canLen);\n  DMINQ (idCan);\n  dMin = max (0.9 * dMin, xLim);\n  return dMin;\n}\n\nfloat ObjRay (vec3 ro, vec3 rd)\n{\n  vec3 p;\n  float dHit, d;\n  dHit = 0.;\n  for (int j = 0; j < 120; j ++) {\n    p = ro + dHit * rd;\n    d = ObjDf (p);\n    if (d < 0.0005 || dHit > dstFar || p.y < 0.) break;\n    dHit += d;\n  }\n  if (p.y < 0.) dHit = dstFar;\n  return dHit;\n}\n\nvec3 ObjNf (vec3 p)\n{\n  vec4 v;\n  vec2 e = vec2 (0.0002, -0.0002);\n  v = vec4 (- ObjDf (p + e.xxx), ObjDf (p + e.xyy), ObjDf (p + e.yxy), ObjDf (p + e.yyx));\n  return normalize (2. * v.yzw - dot (v, vec4 (1.)));\n}\n\nfloat SmokeDens (vec3 p)\n{\n  mat2 rMat;\n  vec3 q, u;\n  float f;\n  f = PrTorusDf (p.xzy, smkRadIn, smkRadEx);\n  if (f < 0.) {\n    q = p.xzy / smkRadEx;\n    u = normalize (vec3 (q.xy, 0.));\n    q -= u;\n    rMat = mat2 (vec2 (u.x, - u.y), u.yx);\n    q.xy = rMat * q.xy;\n    q.xz = Rot2D (q.xz, 2.5 * tCur);\n    q.xy = q.xy * rMat;\n    q += u;\n    q.xy = Rot2D (q.xy, 0.2 * tCur);\n    f = smoothstep (0., smkRadIn, - f) * Fbm3 (16. * q);\n  } else f = 0.;\n  return f;\n}\n\nvec4 SmokeCol (vec3 ro, vec3 rd, float dstObj)\n{\n  vec4 col4;\n  vec3 smkPos, p;\n  float densFac, d, h, xLim;\n  smkPos = vec3 (0., 0., 2. * canLen + smkPhs);\n  smkPos.yz = Rot2D (smkPos.yz, - canEl);\n  smkPos.xz = Rot2D (smkPos.xz, - canAz);\n  smkPos.y += 1.4 * whlRad + 2. * bltThk + 0.58 * 1.1 * (0.8 * whlSpc - 1.5 * bltWid);\n  smkRadIn = 0.005 + 0.045 * smoothstep (0.02, 0.15, smkPhs);\n  smkRadEx = (2.5 + 3. * smoothstep (0.1, 0.4, smkPhs)) * smkRadIn;\n  smkRadIn *= 1. - 0.3 * smoothstep (0.7, 1., smkPhs);\n  d = 0.;\n  for (int j = 0; j < 30; j ++) {\n    p = ro + d * rd - smkPos;\n    xLim = abs (p.x) - 1.5 * veGap;\n    p.x = mod (p.x + 0.5 * veGap, veGap) - 0.5 * veGap;\n    p.xz = Rot2D (p.xz, canAz);\n    p.yz = Rot2D (p.yz, 0.5 * pi + canEl);\n    h = max (PrTorusDf (p.xzy, smkRadIn, smkRadEx), xLim);\n    d += h;\n    if (h < 0.001 || d > dstFar) break;\n  }\n  col4 = vec4 (0.);\n  if (d < min (dstObj, dstFar)) {\n    densFac = 1.5 * max (1.1 - pow (smkPhs, 1.5), 0.);\n    for (int j = 0; j < 16; j ++) {\n      p = ro + d * rd - smkPos;\n      p.x = mod (p.x + 0.5 * veGap, veGap) - 0.5 * veGap;\n      p.xz = Rot2D (p.xz, canAz);\n      p.yz = Rot2D (p.yz, 0.5 * pi + canEl);\n      col4 += densFac * SmokeDens (p) * (1. - col4.w) * vec4 (vec3 (0.9) - col4.rgb, 0.1);\n      d += 2.2 * smkRadIn / 16.;\n      if (col4.w > 0.99 || d > dstFar) break;\n    }\n  }\n  return col4;\n}\n\nvec4 FlameCol (vec3 ro, vec3 rd, float dstObj)\n{\n  vec3 flmPos, p;\n  float d, h, xLim;\n  flmPos = vec3 (0., 0., 2. * canLen + flmLen);\n  flmPos.yz = Rot2D (flmPos.yz, - canEl);\n  flmPos.xz = Rot2D (flmPos.xz, - canAz);\n  flmPos.y += 1.4 * whlRad + 2. * bltThk + 0.58 * 1.1 * (0.8 * whlSpc - 1.5 * bltWid);\n  d = 0.;\n  for (int j = 0; j < 50; j ++) {\n    p = ro + d * rd - flmPos;\n    xLim = abs (p.x) - 1.5 * veGap;\n    p.x = mod (p.x + 0.5 * veGap, veGap) - 0.5 * veGap;\n    p.xz = Rot2D (p.xz, canAz);\n    p.yz = Rot2D (p.yz, 0.5 * pi + canEl);\n    p.y -= flmLen;\n    h = max (0.9 * PrCylDf (p.xzy, 0.12 * whlRad * clamp (0.7 + 0.3 * p.y / flmLen, 0., 1.),\n       flmLen), xLim);\n    d += h;\n    if (h < 0.001 || d > dstFar) break;\n  }\n  return (d < min (dstObj, dstFar)) ? vec4 (1., 0.4, 0.1,\n     1. - 0.9 * smoothstep (0.2, 0.25, smkPhs)) : vec4 (0.);\n}\n\nfloat ObjSShadow (vec3 ro, vec3 rd)\n{\n  float sh, d, h;\n  sh = 1.;\n  d = 0.01;\n  for (int j = 0; j < 30; j ++) {\n    h = ObjDf (ro + d * rd);\n    sh = min (sh, smoothstep (0., 0.05 * d, h));\n    d += h;\n    if (sh < 0.05) break;\n  }\n  return 0.3 + 0.7 * sh;\n}\n\nvec3 SkyBgCol (vec3 ro, vec3 rd)\n{\n  vec3 col, clCol, skCol;\n  vec2 q;\n  float f, fd, ff, sd;\n  if (rd.y > -0.02 && rd.y < 0.03 * Fbm1 (16. * atan (rd.z, - rd.x))) {\n    col = vec3 (0.3, 0.41, 0.55);\n  } else {\n    q = 0.02 * (ro.xz + 0.5 * tCur + ((100. - ro.y) / rd.y) * rd.xz);\n    ff = Fbm2 (q);\n    f = smoothstep (0.2, 0.8, ff);\n    fd = smoothstep (0.2, 0.8, Fbm2 (q + 0.01 * sunDir.xz)) - f;\n    clCol = (0.7 + 0.5 * ff) * (vec3 (0.7) - 0.7 * vec3 (0.3, 0.3, 0.2) * sign (fd) *\n       smoothstep (0., 0.05, abs (fd)));\n    sd = max (dot (rd, sunDir), 0.);\n    skCol = vec3 (0.4, 0.5, 0.8) + step (0.1, sd) * vec3 (1., 1., 0.9) *\n       min (0.3 * pow (sd, 64.) + 0.5 * pow (sd, 2048.), 1.);\n    col = mix (skCol, clCol, 0.1 + 0.9 * f * smoothstep (0.01, 0.1, rd.y));\n  }\n  return col;\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  vec4 col4, smkCol4, flmCol4;\n  vec3 q, col, vn, gPos, roo;\n  float dstObj, dstGrnd, tCyc, spd, dMove, s, t, f, nSegR, bGap, r, nDotS, sh;\n  nSegR = 16.;\n  whlRad = 0.29;\n  bltWid = 0.1;\n  bltThk = 0.03;\n  bGap = 2. * pi * whlRad / nSegR;\n  whlSpc = floor (0.8 / bGap) * bGap;\n  canLen = 0.8 * whlSpc;\n  veGap = 3.5 * whlSpc;\n  tCyc = 8.;\n  spd = 3.;\n  t = mod (tCur / tCyc, 1.);\n  dMove = spd * (floor (tCur / tCyc) + smoothstep (0.5, 1., t));\n  canEl = pi * (0.05 + 0.15 * SmoothBump (0.1, 0.4, 0.1, t));\n  s = floor (mod (tCur / tCyc, 4.));\n  canAz = (mod (s, 2.) == 1.) ? pi * 0.2 * SmoothBump (0.1, 0.4, 0.1, t) * sign (s - 2.) : 0.;\n  smkPhs = clamp (t, 0.15, 0.5) / 0.15 - 1.;\n  dstObj = ObjRay (ro, rd);\n  if (smkPhs > 0.) smkCol4 = SmokeCol (ro, rd, dstObj);\n  flmLen = 0.7 * whlRad * SmoothBump (0.03, 0.32, 0.02, smkPhs);\n  if (flmLen > 0.) flmCol4 = FlameCol (ro, rd, dstObj);\n  if (dstObj < dstFar) {\n    ro += dstObj * rd;\n    vn = ObjNf (ro);\n    if (idObj == idBase || idObj == idTur) {\n      col4 = mix (vec4 (0.1, 0.4, 0.1, 0.1), vec4 (0.4, 0.4, 0.1, 0.05),\n         smoothstep (0.45, 0.5, Fbm2 (8. * qHit.xz + 11. * floor (ro.x / veGap + 0.5))));\n      r = abs (qHit.x) / (0.8 * whlSpc - 1.5 * bltWid);\n      if (idObj == idBase) {\n        col4 *= 1. - 0.5 * SmoothBump (0.8, 0.85, 0.01, r);\n        if (r < 0.75) {\n          if (qHit.z < -1.65 * whlSpc)\n             col4 *= 1. - 0.7 * SmoothBump (0.3, 0.7, 0.02, mod (8. * r, 1.));\n          else if (qHit.z > 1.6 * whlSpc)\n             col4 *= 1. - 0.7 * SmoothBump (0.3, 0.7, 0.02, mod (16. * qHit.y, 1.));\n        }\n      } else if (idObj == idTur) {\n        col4 *= 1. - 0.5 * SmoothBump (0.8, 0.85, 0.01, r);\n        col4 *= 1. - 0.7 * SmoothBump (0.17, 0.2, 0.01, r);\n        if (qHit.z > 0. && abs (qHit.y - 0.43) < 0.07) col4 *= 1. - 0.5 * step (r, 0.08);\n      }\n    } else if (idObj == idCan) {\n      col4 = vec4 (0.3, 0.5, 0.3, 0.1) * (1. - 0.5 * SmoothBump (0.03, 0.06, 0.01,\n         abs (qHit.z - 0.3))) * (1. - 0.8 * step (length (qHit.xy), 0.1 * whlRad));\n    } else if (idObj == idWhl) {\n      col4 = (abs (qHit.x) < bltWid) ? vec4 (0.2, 0.3, 0.2, 0.) : vec4 (0.1, 0.4, 0.1, 0.1);\n      q = qHit;\n      q.yz = Rot2D (q.yz, - dMove / whlRad);\n      r = length (q.yz) / whlRad;\n      col4.rgb *= 1. - 0.9 * max (step (0.5, r) * SmoothBump (0.45, 0.55, 0.03,\n         mod (nSegR * atan (q.z, - q.y) / (2. * pi), 1.)),\n         SmoothBump (0.48, 0.52, 0.01, abs (r)));\n    } else if (idObj == idAxl) {\n      col4 = vec4 (0.2, 0.3, 0.2, 0.05);\n    } else if (idObj == idBelt) {\n      col4 = vec4 (0.4, 0.3, 0.1, 0.);\n      if (abs (qHit.z) < whlSpc) {\n        col4.rgb *= 1. - 0.7 * SmoothBump (0.42, 0.58, 0.05,\n           mod ((qHit.z - sign (qHit.y) * dMove) / bGap, 1.));\n      } else {\n        q = qHit;\n        q.z -= sign (q.z) * whlSpc;\n        q.yz = Rot2D (q.yz, - dMove / whlRad);\n        col4.rgb *= 1. - 0.7 * SmoothBump (0.42, 0.58, 0.05,\n           mod (nSegR * atan (q.z, - q.y) / (2. * pi), 1.));\n      }\n    }\n    sh = ObjSShadow (ro, sunDir);\n    nDotS = max (dot (vn, sunDir), 0.);\n    if (idObj != idBelt) nDotS *= nDotS;\n    col = col4.rgb * (0.3 + 0.7 * sh * nDotS) + smoothstep (0.8, 0.9, sh) * sh *\n       col4.a * pow (max (dot (normalize (sunDir - rd), vn), 0.), 32.);\n  } else if (rd.y < 0.) {\n    roo = ro;\n    dstGrnd = - ro.y / rd.y;\n    ro += dstGrnd * rd;\n    vn = vec3 (0., 1., 0.);\n    sh = (dstGrnd < dstFar) ? ObjSShadow (ro, sunDir) : 1.;\n    gPos = ro + vec3 (0., 0., dMove);\n    r = (ro.z < whlSpc && abs (ro.x) < 1.5 * veGap) ? 1. - smoothstep (1., 1.8,\n       abs (abs (mod (ro.x + 0.5 * veGap, veGap) - 0.5 * veGap) - 0.8 * whlSpc) / bltWid) : 0.;\n    s = 1. - smoothstep (0.3, 0.8, dstGrnd / dstFar);\n    f = 1. - Fbm2 (0.5 * gPos.xz);\n    vn = VaryNf (4. * gPos, vn, (4. * f * f + 2. * r) * s);\n    col = mix (vec3 (0.4, 0.5, 0.3), vec3 (0.4, 0.3, 0.2),\n       smoothstep (0.2, 0.8, Fbm2 (2. * gPos.xz)));\n    col = mix (vec3 (0.33, 0.45, 0.15), col, s);\n    if (r > 0.) col *= 1. - (0.1 + 0.05 * sin ((2. * pi / bGap) * gPos.z)) * r * s;\n    col *= sh * max (dot (vn, sunDir), 0.);\n    col = mix (0.8 * col, vec3 (0.3, 0.41, 0.55), pow (1. + rd.y, 16.));\n  } else {\n    col = SkyBgCol (ro, rd);\n  }\n  if (flmLen > 0.) col = mix (col, flmCol4.rgb, flmCol4.a);\n  if (smkPhs > 0.) col = mix (col, smkCol4.rgb, smkCol4.a);\n  return clamp (col, 0., 1.);\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  mat3 vuMat;\n  vec4 mPtr;\n  vec3 ro, rd, col;\n  vec2 canvas, uv, ori, ca, sa;\n  float el, az, sr;\n  canvas = iResolution.xy;\n  uv = 2. * fragCoord.xy / canvas - 1.;\n  uv.x *= canvas.x / canvas.y;\n  tCur = iTime;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / canvas - 0.5;\n  az = 0.;\n  el = -0.15 * pi;\n  if (mPtr.z > 0.) {\n    az += 3. * pi * mPtr.x;\n    el += pi * mPtr.y;\n  } else {\n    az += 0.03 * pi * tCur;\n    el += 0.12 * pi * sin (0.023 * pi * tCur);\n  }\n  el = clamp (el, -0.4 * pi, -0.03 * pi);\n  ori = vec2 (el, az);\n  ca = cos (ori);\n  sa = sin (ori);\n  vuMat = mat3 (ca.y, 0., - sa.y, 0., 1., 0., sa.y, 0., ca.y) *\n          mat3 (1., 0., 0., 0., ca.x, - sa.x, 0., sa.x, ca.x);\n  ro = vuMat * vec3 (0., 0., -18.);\n  dstFar = 80.;\n  sunDir = normalize (vec3 (0., 1., -0.7));\n  sunDir.xz = Rot2D (sunDir.xz, 0.005 * pi * tCur);\n#if ! AA\n  const float naa = 1.;\n#else\n  const float naa = 3.;\n#endif  \n  col = vec3 (0.);\n  sr = 2. * mod (dot (mod (floor (0.5 * (uv + 1.) * canvas), 2.), vec2 (1.)), 2.) - 1.;\n  for (float a = 0.; a < naa; a ++) {\n    rd = vuMat * normalize (vec3 (uv + step (1.5, naa) * Rot2D (vec2 (0.5 / canvas.y, 0.),\n       sr * (0.667 * a + 0.5) * pi), 6.));\n    col += (1. / naa) * ShowScene (ro, rd);\n  }\n  fragColor = vec4 (pow (col, vec3 (0.9)), 1.);\n}\n\nfloat PrSphDf (vec3 p, float r)\n{\n  return length (p) - r;\n}\n\nfloat PrCylDf (vec3 p, float r, float h)\n{\n  return max (length (p.xy) - r, abs (p.z) - h);\n}\n\nfloat PrCylAnDf (vec3 p, float r, float w, float h)\n{\n  return max (abs (length (p.xy) - r) - w, abs (p.z) - h);\n}\n\nfloat PrFlatCylDf (vec3 p, float rhi, float rlo, float h)\n{\n  float d;\n  d = length (p.xy - vec2 (clamp (p.x, - rhi, rhi), 0.)) - rlo;\n  if (h > 0.) d = max (d, abs (p.z) - h);\n  return d;\n}\n\nfloat PrFlatCylAnDf (vec3 p, float rhi, float rlo, float w, float h)\n{\n  return max (abs (length (p.xy - vec2 (clamp (p.x, - rhi, rhi), 0.)) - rlo) - w, abs (p.z) - h);\n}\n\nfloat PrTorusDf (vec3 p, float ri, float rc)\n{\n  return length (vec2 (length (p.xy) - rc, p.z)) - ri;\n}\n\nfloat SmoothMin (float a, float b, float r)\n{\n  float h;\n  h = clamp (0.5 + 0.5 * (b - a) / r, 0., 1.);\n  return mix (b, a, h) - r * h * (1. - h);\n}\n\nfloat SmoothBump (float lo, float hi, float w, float x)\n{\n  return (1. - smoothstep (hi - w, hi + w, x)) * smoothstep (lo - w, lo + w, x);\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  vec2 cs;\n  cs = sin (a + vec2 (0.5 * pi, 0.));\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nconst float cHashM = 43758.54;\n\nvec2 Hashv2f (float p)\n{\n  return fract (sin (p + vec2 (0., 1.)) * cHashM);\n}\n\nvec2 Hashv2v2 (vec2 p)\n{\n  vec2 cHashVA2 = vec2 (37., 39.);\n  return fract (sin (vec2 (dot (p, cHashVA2), dot (p + vec2 (1., 0.), cHashVA2))) * cHashM);\n}\n\nvec4 Hashv4v3 (vec3 p)\n{\n  vec3 cHashVA3 = vec3 (37., 39., 41.);\n  vec2 e = vec2 (1., 0.);\n  return fract (sin (vec4 (dot (p + e.yyy, cHashVA3), dot (p + e.xyy, cHashVA3),\n     dot (p + e.yxy, cHashVA3), dot (p + e.xxy, cHashVA3))) * cHashM);\n}\n\nfloat Noiseff (float p)\n{\n  vec2 t;\n  float ip, fp;\n  ip = floor (p);\n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = Hashv2f (ip);\n  return mix (t.x, t.y, fp);\n}\n\nfloat Noisefv2 (vec2 p)\n{\n  vec2 t, ip, fp;\n  ip = floor (p);  \n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = mix (Hashv2v2 (ip), Hashv2v2 (ip + vec2 (0., 1.)), fp.y);\n  return mix (t.x, t.y, fp.x);\n}\n\nfloat Noisefv3 (vec3 p)\n{\n  vec4 t;\n  vec3 ip, fp;\n  ip = floor (p);\n  fp = fract (p);\n  fp *= fp * (3. - 2. * fp);\n  t = mix (Hashv4v3 (ip), Hashv4v3 (ip + vec3 (0., 0., 1.)), fp.z);\n  return mix (mix (t.x, t.y, fp.x), mix (t.z, t.w, fp.x), fp.y);\n}\n\nfloat Fbm1 (float p)\n{\n  float f, a;\n  f = 0.;\n  a = 1.;\n  for (int j = 0; j < 5; j ++) {\n    f += a * Noiseff (p);\n    a *= 0.5;\n    p *= 2.;\n  }\n  return f * (1. / 1.9375);\n}\n\nfloat Fbm2 (vec2 p)\n{\n  float f, a;\n  f = 0.;\n  a = 1.;\n  for (int j = 0; j < 5; j ++) {\n    f += a * Noisefv2 (p);\n    a *= 0.5;\n    p *= 2.;\n  }\n  return f * (1. / 1.9375);\n}\n\nfloat Fbm3 (vec3 p)\n{\n  float f, a;\n  f = 0.;\n  a = 1.;\n  for (int j = 0; j < 5; j ++) {\n    f += a * Noisefv3 (p);\n    a *= 0.5;\n    p *= 2.;\n  }\n  return f * (1. / 1.9375);\n}\n\nfloat Fbmn (vec3 p, vec3 n)\n{\n  vec3 s;\n  float a;\n  s = vec3 (0.);\n  a = 1.;\n  for (int j = 0; j < 5; j ++) {\n    s += a * vec3 (Noisefv2 (p.yz), Noisefv2 (p.zx), Noisefv2 (p.xy));\n    a *= 0.5;\n    p *= 2.;\n  }\n  return dot (s, abs (n));\n}\n\nvec3 VaryNf (vec3 p, vec3 n, float f)\n{\n  vec3 g;\n  vec2 e = vec2 (0.1, 0.);\n  g = vec3 (Fbmn (p + e.xyy, n), Fbmn (p + e.yxy, n), Fbmn (p + e.yyx, n)) - Fbmn (p, n);\n  return normalize (n + f * (g - n * dot (n, g)));\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WsjXRK.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[981, 981, 1003, 1003, 2232], [2234, 2234, 2267, 2267, 2508], [2510, 2510, 2531, 2531, 2723], [2725, 2725, 2751, 2751, 3189], [3191, 3191, 3239, 3239, 4570], [4572, 4572, 4620, 4620, 5430], [5432, 5432, 5469, 5469, 5691], [5693, 5693, 5727, 5727, 6487], [6489, 6489, 6524, 6524, 10905], [10907, 10907, 10963, 10963, 12246], [12248, 12248, 12281, 12281, 12308], [12310, 12310, 12352, 12352, 12403], [12405, 12405, 12458, 12458, 12519], [12521, 12521, 12580, 12580, 12711], [12713, 12713, 12783, 12783, 12883], [12885, 12885, 12931, 12931, 12988], [12990, 12990, 13035, 13035, 13138], [13140, 13140, 13197, 13197, 13280], [13282, 13282, 13312, 13312, 13425], [13459, 13459, 13483, 13483, 13536], [13538, 13538, 13562, 13562, 13692], [13694, 13694, 13718, 13718, 13938], [13940, 13940, 13965, 13965, 14111], [14113, 14113, 14138, 14138, 14324], [14326, 14326, 14351, 14351, 14576], [14578, 14578, 14600, 14600, 14754], [14756, 14756, 14777, 14777, 14932], [14934, 14934, 14955, 14955, 15110], [15112, 15112, 15141, 15141, 15353], [15355, 15355, 15394, 15394, 15574]], "test": "error"}
{"id": "wsjXzc", "name": "Domain Warped FBM", "author": "hahahahaman", "description": "Modification of fractal brownian motion from: https://thebookofshaders.com/13/ and http://www.iquilezles.org/www/articles/warp/warp.htm", "tags": ["fractal", "noise", "brownian"], "likes": 3, "viewed": 152, "published": "Public", "date": "1554626350", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI 3.14159265359\n\nfloat random (in vec2 _st) {\n    return fract(sin(dot(_st.xy,\n                         vec2(12.9898,78.233)))*\n        43758.5453123);\n}\n\nfloat noise (in vec2 _st) {\n    vec2 i = floor(_st);\n    vec2 f = fract(_st);\n\n    // Four corners in 2D of a tile\n    float a = random(i);\n    float b = random(i + vec2(1.0, 0.0));\n    float c = random(i + vec2(0.0, 1.0));\n    float d = random(i + vec2(1.0, 1.0));\n\n    vec2 u = f * f * (3.0 - 2.0 * f);\n\n    return mix(a, b, u.x) +\n            (c - a)* u.y * (1.0 - u.x) +\n            (d - b) * u.x * u.y;\n}\n\n#define NUM_OCTAVES 10\n#define NUM_FBM 3\nfloat fbm ( in vec2 _st) {\n    float v = 0.0;\n    float a = 0.5;\n    vec2 shift = vec2(100.0);\n    // Rotate to reduce axial bias\n    mat2 rot = mat2(cos(0.5), sin(0.5),\n                    -sin(0.5), cos(0.50));\n    for (int i = 0; i < NUM_OCTAVES; ++i) {\n        v += a * noise(_st)*1.236;\n        _st = rot * _st * 1.608 + shift;\n        a *= 0.588;\n    }\n    return v;\n}\n\nfloat nested_fbm(in vec2 _st, float s){\n    vec2 p = vec2(0.);\n    for(int i = 0; i < NUM_FBM-1; i++){\n        float float_i = float(i);\n        vec2 q = vec2(0.);\n        vec2 shift = vec2(float_i*s*0.080, float_i*s*0.492);\n        q.x = sin(fbm(_st + 3.904*p + shift));\n        q.y = fbm(_st + 4.344*p + shift);\n\n        p = q;\n    }\n\n    return fbm(_st + 3.504*p);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    vec2 st = fragCoord.xy/iResolution.xy*2.;\n    vec2 uv = fragCoord.xy/iResolution.xy;\n    // st += st * abs(sin(iTime*0.1)*3.0);\n    vec3 color = vec3(0.0);\n\n    vec2 q = vec2(0.);\n    q.x = fbm( st + .01*iTime);\n    q.y = fbm( st + vec2(1.0));\n\n    vec2 r = vec2(0.);\n    r.x = fbm( st + 5.272*q + vec2(0.2,22.0)+ -0.001*iTime );\n    r.y = fbm( st + 4.992*q + vec2(8.3,2.8)+ 0.0001*iTime);\n\n    vec2 s = vec2(0.);\n    s.x = fbm(st + 6.808*r + vec2(0.150,-0.460) + 0.001*iTime);\n    s.y = fbm(st + 7.968*r + vec2(-0.160,0.230) + 0.003*iTime);\n\n    float f = fbm(st+2.0*s);\n    float f1 = nested_fbm(st, 2.400);\n    float f2 = nested_fbm(st, 3.800);\n    float f3 = nested_fbm(st, 2.584);\n\n    color = mix(color,\n                vec3(f3, f, f2),\n                clamp(f*f*f,0.0,1.0));\n\n    float cr = clamp(f3*f*(1.0-uv.x)*cos(uv.x), 0.0, 1.0);\n    float cg = 0.5;\n    float cb = clamp(f2*f*cos(uv.x),0.0, 1.0);\n\n    fragColor = vec4(vec3(cr,cg,cb)*0.6*color, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wsjXzc.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[26, 26, 54, 54, 162], [164, 164, 191, 191, 573], [616, 616, 642, 642, 990], [992, 992, 1031, 1031, 1361], [1363, 1363, 1419, 1419, 2388]], "test": "ok"}
{"id": "WsSSDc", "name": "Analog TV simulation", "author": "avin", "description": "Shit TV-set simulation :)", "tags": ["filter", "tv", "analog"], "likes": 5, "viewed": 653, "published": "Public API", "date": "1555055696", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float rand(vec2 co) { \n    return fract(sin(dot(co.xy , vec2(12.9898, 78.233))) * 43758.5453);\n} \n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{          \n    vec2 uv = (fragCoord.xy - iResolution.xy*0.5)/iResolution.y;      \n        \n    // Make better TV size\n    uv *= .32;\n    uv.x *= .56;\n    \n    // Fish eye\n    float fovTheta = 7.55;    \n    float z = sqrt(0.2 - uv.x * uv.x - uv.y * uv.y);\n    float a = 1. / (z * tan(fovTheta * 0.5));\t\n    uv = uv * a;\n    \n    // Take video pixel\n    vec3 col = texture(iChannel0, (uv + 0.5) ).rgb;\n        \n    // Glitch color\n    vec2 ruv = uv;\n    ruv.x += 0.02;\n    col.r += texture(iChannel0, (ruv + 0.5) ).r * 0.4;\n    \n    // Color noise    \n    col += rand(fract(floor((ruv + iTime)*iResolution.y)*0.7))*0.2;    \n    \n    // Make small lines               \n    col *= clamp(fract(uv.y * 100.+iTime*8.), 0.8, 1.);       \n    \n    // Make big lines\n    float bf = fract(uv.y * 3.+iTime*26.);\n    float ff = min(bf, 1. - bf) + 0.35;\n    col *= clamp(ff, 0.5, 0.75) + 0.75;       \n    \n    // Make low Hz\n    col *= (sin(iTime*120.)*0.5 + 0.5)*0.1+0.9;\n    \n    // Make borders\n    col *= smoothstep(-0.51, -0.50,  uv.x) * smoothstep(0.51, 0.50, uv.x);\n    col *= smoothstep(-0.51, -0.50,  uv.y) * smoothstep(0.51, 0.50, uv.y);       \n    \n    fragColor = vec4(col, 1.);\n}", "image_inputs": [{"id": "Xdf3Rn", "previewfilepath": "/media/ap/e81e818ac76a8983d746784b423178ee9f6cdcdf7f8e8d719341a6fe2d2ab303.webm", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/e81e818ac76a8983d746784b423178ee9f6cdcdf7f8e8d719341a6fe2d2ab303.webm", "ctype": "video"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WsSSDc.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 21, 21, 96], [99, 99, 156, 156, 1333]], "test": "error"}
{"id": "WsSSDt", "name": "Scalable and dynamic terrain", "author": "AlexK", "description": "Based on https://www.shadertoy.com/view/3sBXWt\nmax zoom: 200000x\n", "tags": ["noise", "terrain", "life", "dynamic", "scalable"], "likes": 7, "viewed": 588, "published": "Public", "date": "1555236560", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const float TIMESCALE = .03;\nconst float DETALIZATION = 2.6;\nconst float BALANCE = 0.9;\n\n\n//colors\nconst vec3 white = vec3(1.,1.,1.);\nconst vec3 dark_brown = vec3(86./255., 69./255., 61./255.);\nconst vec3 brown = vec3(101./255., 79./255., 68./255.);\nconst vec3 light_green = vec3(96./255., 163./255., 24./255.);\nconst vec3 dark_green = vec3(71./255., 117./255., 18./255.);\nconst vec3 beige = vec3(215./255., 213./255., 136./255.);\nconst vec3 blue = vec3(63./255., 114./255., 206./255.);\nconst vec3 dark_blue = vec3(59./255., 100./255., 202./255.);\n\n//division lines\nconst float snow_line = 0.8;\nconst float mount_line_1 = 0.67;\nconst float mount_line_2 = 0.6;\nconst float ground_line_1 = 0.58;\nconst float ground_line_2 = 0.45;  \nconst float sand_line = 0.42;\nconst float water_line_1 = 0.4;\nconst float water_line_2 = 0.32;\n\n\nfloat[] seed = float[](.25, .5, .75, 1.) ;\n\n\nfloat rnd(float seed){\n\treturn fract((1. - cos((seed + 21.2313662551) * 37.6447205633))/2.);\n}\n\nvec2 color(vec2 uv, float col, int i, float r){\n    int x = int(uv.x * 2.)%2;\n    int y = int(uv.y * 2.)%2;\n\n    float c;\n    \n    float r1 = rnd(float(i));\n    float r2 = rnd(seed[y * 2 + x]);\n    \n    float r3 = rnd((r1 + r2) * r);\n    \n    \n    c = (col + r3 + col * (r3 - 0.5) * 0.6) * 1.2 ;\n    \n\treturn vec2(c, r3);\n}\n\nfloat l_norm(vec2 v, float p){\n\treturn pow(pow(abs(v.x), p) + pow(abs(v.y), p), 1./p);\n}\n\n\nfloat gen_map(float init, vec2 n_uv, int iters, float seed, float time, float bol){\n    float val = init;\n    float r = seed;\n    float inn = time;\n    \n    n_uv = n_uv * 0.5;\n    \n\tfor (int i=0;i<iters;i++){\n        n_uv = mod(n_uv, 1.);\n        \n        vec2 res = color(n_uv, inn, i+1, r);\n     \tfloat bal = bol / pow(float(i+1), 1.);\n        \n        inn = res[0];\n        r = res[1];\n        \n        float val_tot = (bal + cos(inn)) / pow(float(i + 1), 0.4) /2.;\n        val_tot = val_tot * max(0., 1. - pow(l_norm(vec2(.25,.25) - mod(n_uv, 0.5), 3.)*4., 0.85));\n        val += val_tot / pow(float(i+1), 1. / DETALIZATION);\n        \n        n_uv = n_uv * 2.;\n    }\n    \n    return val;\n}\n\nfloat gen_sky(vec2 uv, int iters){\n    float val = 0.;\n    \n    float time = 30. + (0.0 + iTime) * TIMESCALE * 10.;\n\tfloat val_1 = gen_map(0.5, uv+0.2 * vec2(rnd(5.1), rnd(5.2)) - 0.1, iters, 1., time, 0.);\n    float val_2 = gen_map(0.5, uv+0.2 * vec2(rnd(6.1), rnd(6.2)) - 0.1, iters, 1., time * 1.01, 0.);\n    float val_3 = gen_map(0.5, uv+0.2 * vec2(rnd(7.1), rnd(7.2)) - 0.1, iters, 1., time * 1.02, 0.);\n\n    \n    val = val + val_1 * (1.-val);\n    val = val + val_2 * (1.-val);\n\tval = val + val_3 * (1.-val);\n    val = pow(val, 15.);\n    \n\treturn val;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.y;\n    \n    uv -= vec2(1.1, 0.6);\n    \n    // Starting at 200000x zoom and move it to 1x over period of 30s\n    float zoom = 1. / min(1., mix(0.000005, 1., pow((1. + iTime) / 30., 5.)));\n    uv = uv / zoom;\n    \n    uv += vec2(1.1, 0.6);\n    uv.y = 1. - uv.y;\n    uv.x += -0.4;\n       \n     \n    vec2 n_uv = uv;\n    // Reduce number of iterations as zoom value became smaller (not necessary, just a demonstration of persistence)\n    int iters = min(24, int(log2(zoom)) +9);\n    \n    //compute hight of the terrain\n    float time = 40. + (0.0 + iTime) * TIMESCALE;\n    float val_1 = gen_map(0.2, uv, iters, 1.,  time, BALANCE);\n    vec2 du = 0.2 * vec2(rnd(8.1), rnd(1.2)) + 0.1;\n    float val_2 = gen_map(0.2, uv - du, iters, 2.2, time, BALANCE);\n    float val = (val_1 + val_2) / 2.;\n    \n    //snow\n    vec3 col = white;\n    if (val <= snow_line && val > mount_line_1) {\n        float a = (val - mount_line_1) / (snow_line - mount_line_1);\n        col = mix(dark_brown, white,  pow(abs(a),0.2));\n    }\n    \n    //mountains\n    if (val < mount_line_1) {\n        float a = (val - mount_line_2) / (mount_line_1 - mount_line_2);\n        col = mix(brown, dark_brown,  pow(abs(a),0.5));\n    }\n    if (val < mount_line_2) col = brown;\n    \n    //ground\n    if (val < ground_line_1) {\n        float a = (val - ground_line_2) / (ground_line_1 - ground_line_2);\n        col = mix(light_green, dark_green,  a);\n    }\n    if (val < ground_line_2) col = light_green;\n    if (val < sand_line) col = beige;\n    \n    //water\n    if (val < water_line_1) col = blue;\n    if (val < water_line_2) col = dark_blue;\n    \n    \n    if (zoom<100.) {\n        float sky = gen_sky(uv, iters);\n        float a = (val - 0.4) / (1. - 0.4);\n        if (val > 0.4) \n            sky = clamp(0., 1., mix(sky, 0., pow(abs(a),0.2)));\n\t\telse \n            sky = clamp(0., 1.,sky);\n            \n        vec3 sky_col = white;\t\n        col = col * (1. - sky) + sky_col * sky;\n    }\n    \n    //out of reach\n    if (uv.x<0. || uv.x>1.) col = vec3(0., 0., 0.);\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WsSSDt.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[872, 872, 894, 894, 966], [968, 968, 1015, 1015, 1291], [1293, 1293, 1323, 1323, 1381], [1384, 1384, 1467, 1467, 2077], [2079, 2079, 2113, 2113, 2637], [2639, 2639, 2696, 2696, 4788]], "test": "error"}
{"id": "wsSSRy", "name": "Equirectangular Apollonian ", "author": "smkgames", "description": "Equirectangular Apollonian ", "tags": ["3d", "raymarching", "fractal", "distancefield", "kleinian", "apollonian", "vr", "equirectangular", "equirectangle"], "likes": 7, "viewed": 541, "published": "Public API", "date": "1554190572", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n#define AA 1\n\nvec4 orb; \n\nvec3 hsv2rgb( in vec3 c ) {\n  vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n  rgb = rgb*rgb*(3.0-2.0*rgb); // cubic smoothing\t\n  return c.z * mix( vec3(1.0), rgb, c.y);\n}\n\nvec3 getCol(vec3 n){\n  return hsv2rgb(vec3(mod(n.z*.5,1.0),0.8,0.8));\n}\n\nfloat map( vec3 p, float s )\n{\n\tfloat scale = 1.0;\n\n\torb = vec4(1000.0); \n\t\n\tfor( int i=0; i<8;i++ )\n\t{\n\t\tp = -1.0 + 2.0*fract(0.5*p+0.5);\n\n\t\tfloat r2 = dot(p,p);\n\t\t\n        orb = min( orb, vec4(abs(p),r2) );\n\t\t\n\t\tfloat k = s/r2;\n\t\tp     *= k;\n\t\tscale *= k;\n\t}\n\t\n\treturn 0.25*abs(p.y)/scale;\n}\n\nvec2 fragCoordinate;\nvec3 equirectangularRay(){\n    vec2 texCoord = fragCoordinate.xy / iResolution.xy; \n    vec2 thetaphi = ((texCoord * 2.0) - vec2(1.0)) * vec2(3.1415926535897932384626433832795, 1.5707963267948966192313216916398); \n    vec3 rayDirection = vec3(cos(thetaphi.y) * cos(thetaphi.x), sin(thetaphi.y), cos(thetaphi.y) * sin(thetaphi.x));\n         \n    return rayDirection;\n}\n\nfloat trace( in vec3 ro, in vec3 rd, float s )\n{\n\tfloat maxd = 30.0;\n    float t = 0.01;\n    for( int i=0; i<200; i++ )\n    {\n\t    float precis = 0.001 * t;\n        \n\t    float h = map( ro+rd*t, s );\n        if( h<precis||t>maxd ) break;\n        t += h;\n    }\n\n    if( t>maxd ) t=-1.0;\n    return t;\n}\n\nvec3 calcNormal( in vec3 pos, in float t, in float s )\n{\n    float precis = 0.001 * t;\n\n    vec2 e = vec2(1.0,-1.0)*precis;\n    return normalize( e.xyy*map( pos + e.xyy, s ) + \n\t\t\t\t\t  e.yyx*map( pos + e.yyx, s ) + \n\t\t\t\t\t  e.yxy*map( pos + e.yxy, s ) + \n                      e.xxx*map( pos + e.xxx, s ) );\n}\n\nvec3 render( in vec3 ro, in vec3 rd, in float anim )\n{\n\n    // trace\t\n    vec3 col = vec3(0.0);\n    float t = trace( ro, equirectangularRay(), anim );\n    if( t>0.0 )\n    {\n        vec4 tra = orb;\n        vec3 pos = ro + t*rd;\n        \n\n        \n        vec3 nor = calcNormal( pos, t, anim );\n       vec3 colorful =getCol(vec3(t));\n        // lighting\n        vec3  light1 = vec3(  0.577, 0.577, -0.577 );\n        vec3  light2 = vec3( -0.707, 0.000,  0.707 );\n        float key = clamp( dot( light1, nor ), 0.0, 1.0 );\n        float bac = clamp( 0.2 + 0.8*dot( light2, nor ), 0.0, 1.0 );\n        float amb = (0.7+0.3*nor.y);\n        float ao = pow( clamp(tra.w*2.0,0.0,1.0), 1.2 );\n\n        vec3 brdf  = 1.0*vec3(0.40,0.40,0.40)*amb*ao;\n        brdf += 1.0*vec3(1.00,1.00,1.00)*key*ao;\n        brdf += 1.0*vec3(0.40,0.40,0.40)*bac*ao;\n \n\n        // material\t\t\n        vec3 rgb = vec3(1.0);\n        rgb = mix( rgb, colorful, clamp(6.0*tra.y,0.0,1.0) );\n        rgb = mix( rgb, colorful, pow(clamp(1.0-2.0*tra.z,0.0,1.0),8.0) );\n        \n\n        // color\n        col = rgb*brdf*exp(-0.2*t);\n    }\n\n    return sqrt(col);\n}\n\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragCoordinate = fragCoord;\n    float time = iTime*0.25 + 0.01*iMouse.x;\n    float anim = 1.1 + 0.5*smoothstep( -0.3, 0.3, cos(0.1*iTime) );\n    \n    vec3 tot = vec3(0.0);\n    #if AA>1\n    for( int jj=0; jj<AA; jj++ )\n    for( int ii=0; ii<AA; ii++ )\n    #else\n    int ii = 1, jj = 1;\n    #endif\n    {\n        vec2 q = fragCoord.xy+vec2(float(ii),float(jj))/float(AA);\n        vec2 p = (2.0*q-iResolution.xy)/iResolution.y;\n\n        // camera\n        vec3 ro = vec3( 1., 1., 2.8*cos(0.5+0.35*time) );\n        vec3 ta = vec3( 1., 1., 1.9*cos(2.0+0.38*time) );\n        float roll = 0.2*cos(0.1*time);\n        vec3 cw = normalize(ta-ro);\n        vec3 cp = vec3(sin(roll), cos(roll),0.0);\n        vec3 cu = normalize(cross(cw,cp));\n        vec3 cv = normalize(cross(cu,cw));\n        vec3 rd = normalize( p.x*cu + p.y*cv + 2.0*cw );\n\n        tot += render( ro, equirectangularRay(), anim );\n    }\n    \n    tot = tot/float(AA*AA);\n    \n\tfragColor = vec4( tot, 1.0 );\t\n\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wsSSRy.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[27, 27, 54, 54, 230], [232, 232, 252, 252, 303], [305, 305, 335, 335, 598], [621, 621, 647, 647, 988], [990, 990, 1038, 1038, 1291], [1293, 1293, 1349, 1349, 1600], [1602, 1602, 1656, 1671, 2722]], "test": "ok"}
{"id": "wsSSWc", "name": "rounded cube intersection", "author": "abje", "description": "Finds the nearest intersection between a ray and a rounded cube.", "tags": ["raytracing", "roundedcube"], "likes": 4, "viewed": 453, "published": "Public API", "date": "1555085229", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define rot(spin) mat2(cos(spin),sin(spin),-sin(spin),cos(spin))\n\n#define FAR 1000.0\n\n#define antialiasing 16\n\nfloat seed = 0.0;\nvec2 fragUV = vec2(0.0);\nfloat rand() \n{\n\tfloat r = fract(sin(dot(fragUV, vec2(12.9898, 78.233)) + seed) * 43758.5453);\n\tseed++;\n    return r;    \n}\n\n//mask is 1.0/(ellipsoid size)\nvec2 ellipsoid(vec3 ro, vec3 rd, vec3 mask) {\n    mask = max(mask, 0.01);\n    \n    ro *= mask;\n    rd *= mask;\n    \n    float e = 1.0/dot(rd,rd);\n    float b = -dot(rd,ro)*e;\n    vec3 p = ro+rd*b;\n    float a = dot(p,p);\n    if (a > 1.0) return vec2(1000,999);\n    float c = sqrt((1.0-a)*e);\n    \n    return b+vec2(-c,c);\n}\n\n//box intersection from iq\n//https://www.shadertoy.com/view/ld23DV\nvec2 iBox( in vec3 ro, in vec3 rd, in vec3 rad) \n{\n\t// ray-box intersection in box space\n    vec3 m = 1.0/rd;\n    vec3 n = m*ro;\n    vec3 k = abs(m)*rad;\n\t\n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n    \n\tfloat tN = max(max( t1.x, t1.y ), t1.z);\n\tfloat tF = min(min( t2.x, t2.y ), t2.z);\n\n\treturn vec2(max(tN,0.0), tF);\n}\n\nfloat solve(vec2 l) {\n    if (l.x > l.y) l.x = FAR;\n    return l.x;\n}\n\nvec4 roundedcube(vec3 ro, vec3 rd, vec3 size, vec3 radius) {\n    \n    vec2 l = iBox(ro,rd,size+radius);\n    \n    if (l.x > l.y) return vec4(FAR,0,0,0);\n    \n    // inverted radius for the ellipsoid intersection\n    radius = 1.0/radius;\n    \n    vec3 p = ro+rd*l.x;\n\n    vec3 s = sign(p);\n    vec3 m = step(size,p*s);\n    m = m.yzx*m.zxy;\n    \n    float d = 0.0;\n    \n    vec3 cyl = ro-s*size;\n    \n    if (m.x > 0.5) {\n        l.x = max(l.x,solve(ellipsoid(cyl,rd,vec3(0,1,1)*radius)));\n    }\n    if (m.y > 0.5) {\n        l.x = max(l.x,solve(ellipsoid(cyl,rd,vec3(1,0,1)*radius)));\n    }\n    if (m.z > 0.5) {\n        l.x = max(l.x,solve(ellipsoid(cyl,rd,vec3(1,1,0)*radius)));\n    }\n\n    p = ro+rd*l.x;\n\n    s = sign(p);\n    if (all(lessThan(size,p*s)))\n        l.x = max(l.x,solve(ellipsoid(ro-s*size,rd,radius)));\n    \n    p = ro+rd*l.x;\n    \n    vec3 n = max(abs(p)-size,0.0)*radius*sign(p);\n    \n    return vec4(l.x,n);\n}\n\nvec3 background(vec3 n) {\n    float a = max(0.0,dot(n,normalize(vec3(0.4,-0.5,0.7))));\n    float b = max(0.0,dot(n,normalize(vec3(-0.8,0.2,0.4))));\n\n    vec3 col = vec3(a*vec3(0.8,1,0.4)+b*vec3(0.8,0.2,0.65));\n    col = max(col,vec3(0.1,0.4,0.2));\n    \n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragUV = fragCoord / iResolution.xy;\n    seed = iTime;\n    \n    vec3 acc = vec3(0);\n    for (int aa = 0; aa < antialiasing+min(iFrame,0); aa++) {\n#if antialiasing==1\n        vec2 uv = (fragCoord*2.0-iResolution.xy)/iResolution.y;\n#else\n        vec2 uv = ((fragCoord+vec2(rand(),rand()))*2.0-iResolution.xy)/iResolution.y;\n#endif\n\n        vec3 ro = vec3(0,0,-4);\n        vec3 rd = vec3(uv,1);\n\n        if (length(iMouse.xy) > 40.0) {\n            rd.yz *= rot(iMouse.y/iResolution.y*3.14-3.14*0.5);\n            rd.xz *= rot(iMouse.x/iResolution.x*3.14*2.0-3.14);\n            ro.yz *= rot(iMouse.y/iResolution.y*3.14-3.14*0.5);\n            ro.xz *= rot(iMouse.x/iResolution.x*3.14*2.0-3.14);\n        }\n\n        vec4 d = roundedcube(ro,rd,vec3(0.6+sin(iTime)*0.4,0.8+cos(iTime)*0.5,0.5),vec3(0.3,0.3,0.3));\n\n        vec3 col;\n\n        if (d.x < FAR) {\n            vec3 p = ro+rd*d.x;\n\n            vec3 n = d.yzw;\n\n            col = vec3(max(dot(n,normalize(vec3(1,1,-1))),0.1));\n\n            vec3 r = reflect(rd,n);\n\n            col += background(r)*0.12;\n        } else {\n\n            col = background(rd);\n        }\n        acc += col;\n    }\n    acc /= float(antialiasing);\n    fragColor = vec4(sqrt(acc),1);\n}\n\n/* old intersector\n\nvec2 roundedcube(vec3 ro, vec3 rd) {\n    vec3 ird = 1.0/rd;\n    \n    vec3 lens = -ro*ird;\n    \n    vec3 near = lens-abs(ird)*bound;\n    vec3 far = lens+abs(ird)*bound;\n    \n    vec2 res = vec2(max(max(max(near.x,near.y),near.z),0.0),\n                        min(min( far.x, far.y), far.z));\n    \n    vec2 d3 = vec2(10000.0,0.0);\n    \n    float d = res.x;\n    \n    if (d < res.y) {\n        vec3 p = ro+rd*d;\n        \n        vec3 q = abs(p);\n        vec3 f = step(size,q)*sign(p);\n        vec3 lens = -p*ird;\n        \n        vec3 a = max(lens+ird*size,-1.0);\n        a += step(0.0,-a)*10000.0;\n        vec3 b = max(lens-ird*size,-1.0);\n        b += step(0.0,-b)*10000.0;\n        \n        for (int i = 0; i < 7; i++) {\n            float d2 = d;\n            vec3 c = min(a,b);\n\n            vec3 m;\n            if (c.x < min(c.y,c.z)) {\n                m = vec3(1,0,0);\n            } else if (c.y < c.z) {\n                m = vec3(0,1,0);\n            } else {\n                m = vec3(0,0,1);\n            }\n\n            float l = dot(c,m);\n            \n            a -= l;\n            b -= l;\n            \n            if (dot(a,m) < dot(b,m)) {\n                a += m*10000.0;\n            } else {\n                b += m*10000.0;\n            }\n            \n            d = d + l;\n\n            vec2 s = max(ellipsoid((ro+rd*d2)-f*size,rd,abs(f)/radius),0.0);\n            \n            if (s.x < s.y) {\n                if (d2+s.x < d) {\n                \td3.x = min(d3.x, d2+s.x);\n                }\n                if (d2+s.y < d) {\n                    d3.y = max(d3.y, d2+s.y);\n                }\n            } else if (d > res.y) {\n                break;\n            }\n\n            \n            f += sign(rd)*m;\n        }\n        \n    }\n    \n    return d3;\n}*/", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wsSSWc.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[154, 154, 169, 169, 277], [279, 310, 355, 355, 633], [635, 702, 752, 790, 1024], [1026, 1026, 1047, 1047, 1095], [1097, 1097, 1157, 1157, 2022], [2024, 2024, 2049, 2049, 2294], [2296, 2296, 2353, 2353, 3566]], "test": "ok"}
{"id": "WsSSWK", "name": "Finals_Shader08_Co", "author": "johannco98", "description": "asd", "tags": ["asd"], "likes": 1, "viewed": 75, "published": "Public", "date": "1554902377", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float rand(vec2 uv)\n{\n    //return fract(sin(dot(uv, vec2(12.9898,78.233)))*10000.*iTime);\n\t//return fract(sin(dot(uv, iMouse.xy))*10000.);\n\t//return (fract(sin(dot(uv, vec2(12., 70.)))*100000.));\n    return (fract(sin(dot(uv, vec2(12., 70.)))*43758.5453123));\n}\n\n// Value noise\nfloat noise(in vec2 st) {\n    vec2 i = floor(st);\n    vec2 f = fract(st);\n\n    // Four corners in 2D of a tile\n    float a = rand(i);\n    float b = rand(i + vec2(1.0, 0.0));\n    float c = rand(i + vec2(0.0, 1.0));\n    float d = rand(i + vec2(1.0, 1.0));\n\n    // Smooth Interpolation\n\n    // Cubic Hermine Curve.  Same as SmoothStep()\n    vec2 u = f*f*(3.0-2.0*f);\n    // u = smoothstep(0.,1.,f);\n\n    // Mix 4 coorners porcentages\n    return mix(a, b, u.x) + \n            (c - a)* u.y * (1.0 - u.x) + \n            (d - b) * u.x * u.y;\n}\n\n// Gradient noise\nvec2 hash( vec2 x )  // replace this by something better\n{\n    const vec2 k = vec2( 0.3183099, 0.3678794 );\n    x = x*k + k.yx;\n    return -1.0 + 2.0*fract( 16.0 * k*fract( x.x*x.y*(x.x+x.y)) );\n}\n\nfloat gnoise( in vec2 p )\n{\n    vec2 i = floor( p );\n    vec2 f = fract( p );\n\t\n\tvec2 u = f*f*(3.0-2.0*f);\n\n    return mix( mix( dot( hash( i + vec2(0.0,0.0) ), f - vec2(0.0,0.0) ), \n                     dot( hash( i + vec2(1.0,0.0) ), f - vec2(1.0,0.0) ), u.x),\n                mix( dot( hash( i + vec2(0.0,1.0) ), f - vec2(0.0,1.0) ), \n                     dot( hash( i + vec2(1.0,1.0) ), f - vec2(1.0,1.0) ), u.x), u.y);\n}\n\n// Simplex noise\nvec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec2 mod289(vec2 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec3 permute(vec3 x) { return mod289(((x*34.0)+1.0)*x); }\n\nfloat snoise(vec2 v) {\n    const vec4 C = vec4(0.211324865405187,  // (3.0-sqrt(3.0))/6.0\n                        0.366025403784439,  // 0.5*(sqrt(3.0)-1.0)\n                        -0.577350269189626,  // -1.0 + 2.0 * C.x\n                        0.024390243902439); // 1.0 / 41.0\n    vec2 i  = floor(v + dot(v, C.yy) );\n    vec2 x0 = v -   i + dot(i, C.xx);\n    vec2 i1;\n    i1 = (x0.x > x0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);\n    vec4 x12 = x0.xyxy + C.xxzz;\n    x12.xy -= i1;\n    i = mod289(i); // Avoid truncation effects in permutation\n    vec3 p = permute( permute( i.y + vec3(0.0, i1.y, 1.0 ))\n        + i.x + vec3(0.0, i1.x, 1.0 ));\n\n    vec3 m = max(0.5 - vec3(dot(x0,x0), dot(x12.xy,x12.xy), dot(x12.zw,x12.zw)), 0.0);\n    m = m*m ;\n    m = m*m ;\n    vec3 x = 2.0 * fract(p * C.www) - 1.0;\n    vec3 h = abs(x) - 0.5;\n    vec3 ox = floor(x + 0.5);\n    vec3 a0 = x - ox;\n    m *= 1.79284291400159 - 0.85373472095314 * ( a0*a0 + h*h );\n    vec3 g;\n    g.x  = a0.x  * x0.x  + h.x  * x0.y;\n    g.yz = a0.yz * x12.xz + h.yz * x12.yw;\n    return 130.0 * dot(m, g);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //Colors in vec3\n    vec3 red = vec3(0.8 ,0.0 ,0.0);\n    vec3 white = vec3(1.0, 1.0, 1.0);\n    vec3 yellow = vec3(0.9, 0.9, 0.3);\n    vec3 blue = vec3(0.5, 0.8, 0.9);\n    vec3 black = vec3(0.0, 0.0, 0.0);\n    vec3 green = vec3(0.0, 1.0, 0.0);\n    vec2 ouv = fragCoord/iResolution.xy;\n    \n\tvec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;               \n    vec2 st = vec2(atan(uv.x, uv.x), length(uv));   \n    float speed = 2.0;\n    float rings = 20.0;\n    uv = vec2(st.x / 10000.0 + iTime * speed - st.y * (rings * abs(clamp(sin(iTime), 0.1, 1.0))), st.y);  \n    \n    //ring thickness\n    float a = fwidth(uv.x);         \n    \n    vec2 h = hash(uv);\n    float b = fract(uv.x);  \n    \n    \n    float mask = smoothstep(0.0, a, abs(b-0.9) );    \n    vec3 lampLight = abs(vec3(\n        \t\t\t\t  clamp(abs(sin(iTime)),0.0 , 0.8 ),\n                          clamp(abs(cos(iTime)),0.0 , 0.8 ), \n                          clamp(abs(sin(iTime)),0.4 , 1.0 ))\n                        \t );\n    \n    vec3 col = mix(vec3(1.0), lampLight, mask);   \n    //=================================================\n    float value = gnoise(uv + (sin(iTime) * 0.005));\n    float angle = atan(uv.y, uv.x);\n    \n    float radius = sin(4.0 * angle);\n    radius = smoothstep(-0.75 , 1.0,  cos(angle * 8.0 + iTime * 15.0)  ) * 0.2 + 0.4;\n   \n    float radius2 =  1.0 /  abs(cos(angle * 10000.0 + iTime) * sin(angle * 7.0 + iTime)) * 0.5 + 0.1;\n\n    //=================================================\n    fragColor = vec4(col * radius2 * lampLight, 1.0);        \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WsSSWK.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 21, 196, 262], [264, 279, 304, 304, 815], [817, 835, 893, 893, 1031], [1033, 1033, 1060, 1060, 1458], [1460, 1477, 1498, 1498, 1545], [1546, 1546, 1567, 1567, 1614], [1615, 1615, 1637, 1637, 1672], [1674, 1674, 1696, 1696, 2744], [2747, 2747, 2804, 2825, 4354]], "test": "ok"}
{"id": "wsSSzy", "name": "My name is Yamada", "author": "kiyamada96", "description": "My name is yamada.From Japane.\nThis is Kanji.", "tags": ["yamada"], "likes": 1, "viewed": 111, "published": "Public", "date": "1554200081", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec3 hsv(vec3 c)\n{\n\tvec3 rgb = clamp(abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0,0.0,1.0);\n    rgb = rgb*rgb*(3.0-2.0*rgb);\n    return c.z * mix( vec3(1.0), rgb, c.y);\n}\n\nfloat box(vec2 p,vec2 b)\n{\n\treturn max(abs(p.x)-b.x,abs(p.y)-b.y);\n}\n\nfloat yama(vec2 p,vec2 s)\n{\n\tfloat d=box(p+s,vec2(0.25,1.5)); \n    d = min(d, box(p - vec2(0.0, -1.25)+s, vec2(1.5, 0.25)));\n    d = min(d, box(p - vec2(1.5, -0.75)+s, vec2(0.25, 0.75)));\n    d = min(d, box(p - vec2(-1.5, -0.75)+s, vec2(0.25, 0.75)));\n    return d;\n}\n\nfloat da(vec2 p,vec2 s)\n{\n\tfloat d=box(p+s,vec2(0.25,1.)); \n    d = min(d, box(p - vec2(0.0, -1.25)+s, vec2(1.5, 0.25)));\n    d = min(d, box(p - vec2(1.5, -0.25)+s, vec2(0.25, 1.25)));\n    d = min(d, box(p - vec2(-1.5, -0.25)+s, vec2(0.25, 1.25)));\n    d = min(d, box(p - vec2(0.0, 1.25)+s, vec2(1.75, 0.25)));\n    d = min(d, box(p - vec2(0.0, 0.)+s, vec2(1.75, 0.25)));\n    return d;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 p=(fragCoord.xy*2.0-iResolution.xy)/min(iResolution.x,iResolution.y);\n       \n   \tp*=3.0;\n    \n    float y=yama(p,vec2(2.,0));\n    float d=da(p,vec2(-2.0,0));\n       \n    float e= box(p, vec2(1.3, 0.25));\n    \n    float col=min(y,d);\n    float z=sign(col);\n   \tvec3 yamada=vec3(z);\n    \n    float pi=3.14;\n    vec3 color=vec3(0.,0.,0.);\n    float angle = atan(p.y,p.x);\n    float radius = length(p)*2.0;\n    \n    float h=(angle/pi*5.0)+iTime;\n    color = hsv(vec3(h,radius,1.));\n    \n    fragColor=vec4(color+yamada,1.);\n\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wsSSzy.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 18, 18, 173], [175, 175, 201, 201, 243], [245, 245, 272, 272, 512], [514, 514, 539, 539, 900], [902, 902, 959, 959, 1489]], "test": "ok"}
{"id": "WsSXDc", "name": "Twisted Gyroid Ring", "author": "dr2", "description": "Endless possibilities...", "tags": ["surface", "gyroid"], "likes": 18, "viewed": 412, "published": "Public API", "date": "1555057500", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// \"Twisted Gyroid Ring\" by dr2 - 2019\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\n#define AA  1   // optional antialiasing\n\nfloat Minv3 (vec3 p);\nfloat SmoothMax (float a, float b, float r);\nvec2 Rot2D (vec2 q, float a);\n\nvec3 ltDir, qHit;\nfloat dstFar;\nint idObj;\nconst float pi = 3.14159;\n\n#define DMINQ(id) if (d < dMin) { dMin = d;  idObj = id;  qHit = q; }\n\nfloat ObjDf (vec3 p)\n{\n  vec3 q;\n  vec2 tt;\n  float dMin, d, a, rt, ws;\n  dMin = dstFar;\n  rt = 20.;\n  tt = vec2 (pi, 1.5 * pi);\n  ws = 0.2;\n  q = p;\n  a = atan (q.z, - q.x);\n  q.xz = vec2 (rt * a, length (q.xz) - rt);\n  d = length (q.yz) - 2. * ws;\n  DMINQ (1);\n  q.yz = Rot2D (q.yz, a);\n  d = length (abs (q.yz) - tt) - ws;\n  DMINQ (2);\n  d = SmoothMax (max (abs (dot (sin (q), cos (q).yzx)) - ws, 3. * ws - length (q.yz)),\n     max (abs (q.y) - tt.x, abs (q.z) - tt.y), 0.2);\n  DMINQ (3);\n  return 0.6 * dMin;\n}\n\nfloat ObjRay (vec3 ro, vec3 rd)\n{\n  float dHit, d;\n  dHit = 0.;\n  for (int j = 0; j < 120; j ++) {\n    d = ObjDf (ro + dHit * rd);\n    if (d < 0.0005 || dHit > dstFar) break;\n    dHit += d;\n  }\n  return dHit;\n}\n\nvec3 ObjNf (vec3 p)\n{\n  vec4 v;\n  vec2 e = vec2 (0.0002, -0.0002);\n  v = vec4 (- ObjDf (p + e.xxx), ObjDf (p + e.xyy), ObjDf (p + e.yxy), ObjDf (p + e.yyx));\n  return normalize (2. * v.yzw - dot (v, vec4 (1.)));\n}\n\nfloat ObjSShadow (vec3 ro, vec3 rd)\n{\n  float sh, d, h;\n  sh = 1.;\n  d = 0.1;\n  for (int j = 0; j < 30; j ++) {\n    h = ObjDf (ro + d * rd);\n    sh = min (sh, smoothstep (0., 0.05 * d, h));\n    d += clamp (h, 0.1, 0.5);\n    if (sh < 0.05) break;\n  }\n  return 0.5 + 0.5 * sh;\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  vec4 col4;\n  vec3 col, vn, w;\n  float dstObj, sh, nDotL;\n  dstObj = ObjRay (ro, rd);\n  if (dstObj < dstFar) {\n    ro += dstObj * rd;\n    vn = ObjNf (ro);\n    if (idObj == 1) col4 = vec4 (1., 0., 0., 0.5);\n    else if (idObj == 2) col4 = vec4 (1., 0.9, 0.9, 0.5);\n    else if (idObj == 3) {\n      w = mod (4. * qHit / pi, 1.);\n      w = min (w, 1. - w);\n      col4 = mix (vec4 (0.2, 0.2, 0.8, 0.3), vec4 (0.9, 0.9, 0.2, 0.3), \n         smoothstep (0.05, 0.07, Minv3 (w)));\n    }\n    sh = ObjSShadow (ro, ltDir);\n    nDotL = max (dot (vn, ltDir), 0.);\n    col = col4.rgb * (0.2 + 0.8 * sh * nDotL * nDotL) +\n       col4.a * step (0.95, sh) * sh * pow (max (dot (normalize (ltDir - rd), vn), 0.), 64.);\n  } else col = vec3 (1., 0.8, 0.8) * (0.15 + 0.05 * rd.y);\n  return clamp (col, 0., 1.);\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  mat3 vuMat;\n  vec4 mPtr;\n  vec3 ro, rd, col;\n  vec2 canvas, uv, ori, ca, sa;\n  float tCur, el, az, zmFac, sr;\n  canvas = iResolution.xy;\n  uv = 2. * fragCoord.xy / canvas - 1.;\n  uv.x *= canvas.x / canvas.y;\n  tCur = iTime;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / canvas - 0.5;\n  az = 0.;\n  el = 0.;\n  if (mPtr.z > 0.) {\n    az += 2. * pi * mPtr.x;\n    el += pi * mPtr.y;\n  } else {\n    az += pi * sin (0.03 * pi * tCur);\n    el -= 0.15 * pi * cos (0.03 * pi * tCur);\n  }\n  ori = vec2 (el, az);\n  ca = cos (ori);\n  sa = sin (ori);\n  vuMat = mat3 (ca.y, 0., - sa.y, 0., 1., 0., sa.y, 0., ca.y) *\n          mat3 (1., 0., 0., 0., ca.x, - sa.x, 0., sa.x, ca.x);\n  ro = vuMat * vec3 (0., 0., -60.);\n  zmFac = 3. - 0.8 * abs (el);\n  dstFar = 120.;\n  ltDir = vuMat * normalize (vec3 (1., 1., -1.));\n#if ! AA\n  const float naa = 1.;\n#else\n  const float naa = 3.;\n#endif  \n  col = vec3 (0.);\n  sr = 2. * mod (dot (mod (floor (0.5 * (uv + 1.) * canvas), 2.), vec2 (1.)), 2.) - 1.;\n  for (float a = 0.; a < naa; a ++) {\n    rd = vuMat * normalize (vec3 (uv + step (1.5, naa) * Rot2D (vec2 (0.5 / canvas.y, 0.),\n       sr * (0.667 * a + 0.5) * pi), zmFac));\n    col += (1. / naa) * ShowScene (ro, rd);\n  }\n  fragColor = vec4 (col, 1.);\n}\n\nfloat Minv3 (vec3 p)\n{\n  return min (p.x, min (p.y, p.z));\n}\n\nfloat SmoothMin (float a, float b, float r)\n{\n  float h;\n  h = clamp (0.5 + 0.5 * (b - a) / r, 0., 1.);\n  return mix (b, a, h) - r * h * (1. - h);\n}\n\nfloat SmoothMax (float a, float b, float r)\n{\n  return - SmoothMin (- a, - b, r);\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  vec2 cs;\n  cs = sin (a + vec2 (0.5 * pi, 0.));\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WsSXDc.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[408, 408, 430, 430, 922], [924, 924, 957, 957, 1134], [1136, 1136, 1157, 1157, 1349], [1351, 1351, 1388, 1388, 1627], [1629, 1629, 1664, 1664, 2457], [2459, 2459, 2515, 2515, 3742], [3744, 3744, 3766, 3766, 3804], [3806, 3806, 3851, 3851, 3954], [3956, 3956, 4001, 4001, 4039], [4041, 4041, 4071, 4071, 4184]], "test": "error"}
{"id": "wsSXDd", "name": "Batterie Alienware M14x R1", "author": "batterypross", "description": "http://www.batterieprofessionnel.com/dell-alienware-m14x-r1.html", "tags": ["batteriealienwarem14xr1"], "likes": 3, "viewed": 61, "published": "Public", "date": "1555320495", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Time varying pixel color\n    vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wsSXDd.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 107, 294]], "test": "ok"}
{"id": "WsSXzt", "name": "Neon circles", "author": "avin", "description": "Simple neon effect circles", "tags": ["simple", "neon"], "likes": 13, "viewed": 742, "published": "Public API", "date": "1554647518", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;  \n\n    vec2 gv = uv * 50.0 ;\n    gv = fract(gv) - 0.5;\n\n    float t = iTime * 5.0;\n\n    float s = (sin(t - length(uv * 2.0) * 5.0) * 0.4 + 0.5) * 0.6;\n    float m = smoothstep(s, s - 0.05, length(gv)) + s*2.0;\n\n    vec3 col = vec3(s, 0.0, 0.5) * m;\n\n    fragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WsSXzt.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 407]], "test": "ok"}
{"id": "wtf3DN", "name": "Möbius domain coloring", "author": "tpfto", "description": "Domain coloring plot of a Möbius transformation.", "tags": ["2d", "math", "complex", "domaincoloring"], "likes": 4, "viewed": 191, "published": "Public", "date": "1556354480", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// The MIT License\n// Copyright © 2019 J. M.\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// Basic domain coloring plot (https://en.wikipedia.org/wiki/Domain_coloring)\n// of a Möbius transformation\n\n#define PI 3.14159265359\n#define SCALE 5.0 // plot scale\n#define SPACING 0.125 // grid line spacing\n\n// from Fabrice Neyret, \n#define cis(a) vec2( cos(a), sin(a) )\n#define cmul(A,B) ( mat2( A, -(A).y, (A).x ) * (B) )\n#define cdiv(A,B) ( cmul( A, vec2( (B).x, -(B).y ) ) / dot(B,B) )\n\n// Schlick bias function, from http://dept-info.labri.u-bordeaux.fr/~schlick/DOC/gem2.ps.gz\nfloat bias( float a, float x )\n{\n    return x/((1.0/a - 2.0) * (1.0 - x) + 1.0);\n}\n\n// biased sawtooth\nfloat my_saw( float x, float p )\n{\n    float xs = mod(x, 1.0);\n    float xh = clamp(xs, 0.0, p);\n    return 0.5 + 0.5 * bias(0.95, xh) * (1.0 - smoothstep(p, 1.0, xs));\n}\n\n// modified version of Inigo Quilez's method at https://www.shadertoy.com/view/MsS3Wc\n// using \"rational smoothstep\" from https://tpfto.wordpress.com/2019/03/28/on-a-rational-variant-of-smoothstep/\nvec3 smooth_hue( float h )\n{\n    vec3 rgb = clamp( abs(mod(6.0 * h + vec3(0.0, 4.0, 2.0), 6.0) - 3.0) - 1.0, 0.0, 1.0);\n    return rgb * rgb * rgb/(1.0 - 3.0 * rgb * (1.0 - rgb));\n}\n\n// modified DLMF coloring, adapted from https://www.shadertoy.com/view/WtXGWN\nvec3 smooth_dlmf( float h )\n{\n    vec3 rgb = clamp( vec3(1., -1., -1.) * abs((vec3(8., 4., 8.) * mod(h, 1.0) - vec3(4.5, 1.5, 5.5))) + vec3(-1.5, 1.5, 2.5), 0.0, 1.0 );\n\treturn rgb * rgb * rgb/(1.0 - 3.0 * rgb * (1.0 - rgb));\n}\n\n// Möbius transformation parametrized by its fixed points g1, g2 and pole zi, https://en.wikipedia.org/wiki/M%C3%B6bius_transformation#Poles_of_the_transformation\n\nvec2 moebius( in vec2 g1, in vec2 g2, in vec2 zi, in vec2 z )\n{\n\treturn cdiv(cmul(g1 + g2 - zi, z) - cmul(g1, g2), z - zi);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 aspect = iResolution.xy / iResolution.y;\n    vec2 z = ( fragCoord.xy / iResolution.y ) - 0.5 * aspect;\n    z *= SCALE;\n    \n    vec2 w = moebius(0.75 * cis(-3.0 * iTime - PI/5.0), 1.25 * cis(2.0 * iTime + PI/3.0), vec2(-1.5, 0.0), z);\n    float ph = atan(w.y, w.x);\n    float lm = log(0.0001 + length(w));\n    \n    vec3 c = vec3(1.0);\n    c = smooth_dlmf(0.5 * (ph / PI));\n    // uncomment for HSV version \n    // c = smooth_hue(0.5 * (ph / PI));\n\n    c *= my_saw((0.5 * (lm/PI))/SPACING, 0.95) * my_saw((0.5 * (ph / PI))/SPACING, 0.95);\n    fragColor = vec4(c, 1.0);\n    \n    // uncomment if you want to see white lines instead; then comment out previous two lines\n    // float sat = my_saw((0.5 * (lm/PI))/SPACING, 0.95) * my_saw((0.5 * (ph / PI))/SPACING, 0.95);\n    // fragColor = vec4(mix( vec3(1.0), c, sat), 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtf3DN.jpg", "access": "shaders20k", "license": "mit", "functions": [[1465, 1557, 1589, 1589, 1639], [1641, 1660, 1694, 1694, 1830], [1832, 2030, 2058, 2058, 2211], [2213, 2291, 2320, 2320, 2518], [2685, 2685, 2748, 2748, 2810], [2812, 2812, 2869, 2869, 3701]], "test": "ok"}
{"id": "wtf3WN", "name": "dogslow", "author": "jj99", "description": "slow", "tags": ["slow"], "likes": 2, "viewed": 283, "published": "Public API", "date": "1556336185", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//\n// shader mod (slow and dirty)\n//\n\nfloat SMOKE_HEIGHT = 0.4;\nfloat SMOKE_CHOPPY = 40.0;\nfloat SMOKE_FREQ = 0.06;\nfloat SEA_TIME = 21.;\nmat2 octave_m = mat2(1.6,1.2,-1.2,1.6);\n\nfloat hash( vec2 p )\n{\n\tfloat h = dot(p,vec2(127.1,311.7));\t\n    return fract(sin(h)*43758.5453123);\n}\n\nfloat noise( in vec2 p )\n{\n    vec2 i = floor( p );\n    vec2 f = fract( p );\t\n\tvec2 u = f*f*(3.0-2.0*f);\n    return -1.0+2.0*mix( mix( hash( i + vec2(0.0,0.0) ), \n                     hash( i + vec2(1.0,0.0) ), u.x),\n                mix( hash( i + vec2(0.0,1.0) ), \n                     hash( i + vec2(1.0,1.0) ), u.x), u.y);\n}\n\nfloat sea_octave(vec2 uv, float choppy)\n{\n    uv += noise(uv);        \n    vec2 wv = 1.0-abs(sin(uv));\n    vec2 swv = abs(cos(uv));    \n    wv = mix(wv,swv,wv);\n    return pow(1.0-pow(wv.x * wv.y,0.65),choppy);\n}\n\nfloat map_detailed(vec3 p)\n{\n    float freq = SMOKE_FREQ;\n    float amp = SMOKE_HEIGHT;\n    float choppy = SMOKE_CHOPPY;\n    vec2 uv = p.xz; uv.x *= 0.75;\n    \n    float d, h = 0.0;    \n    for(int i = 0; i < 3; i++)\n    {        \n    \td = sea_octave((uv+SEA_TIME)*freq,choppy);\n    \td += sea_octave((uv-SEA_TIME)*freq,choppy);\n        h += d * amp;        \n    \tuv *= octave_m; freq *= 1.9; amp *= 0.22;\n        choppy = mix(choppy,1.0,0.2);\n    }\n    return p.y - h;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{    \n    \n    float time = iTime+0.5;\n    vec2 resolution = iResolution.xy;\n\tvec2 gg = fragCoord.xy;\n\tgg.y += sin(time);\n\t\n\t\n\tgg-= resolution*0.5;\n\t\n\tgg*=1.5+sin(time*0.42)*0.1;\n\t\n\t\n\tgg.x += time*100.0;\n\t\n\t\n\tSEA_TIME += 21.0+sin(time*0.1)*12.0;\t\n\tSMOKE_HEIGHT = (0.5+(sin(time*0.77)*0.5))+0.1;\n\t\n\t\n\tfloat noiseVal = (1.0 - gg.y / resolution.y);\n\tfloat x =gg.x / 12.-time + sin(gg.x*0.01+time*0.8);\n\tfloat y = pow(noiseVal + noise(vec2(1.0,0.0)+gg.xy/resolution) * noiseVal + sin(gg.y*.0001), 0.9);\n\tfloat z = gg.y / 10.-time + cos(gg.x*0.01+time*0.1);\n\tfragColor = vec4( vec3( map_detailed(vec3(x, y, z))), 1.0 );\n\n\tfloat rradd = sin(50.0+gg.y*0.003+time*0.4+gg.x*0.001)*2.0;\n\trradd = -abs(rradd-0.4);\n\t\n\tif (fragColor.r<0.0)\n\t\tfragColor.r *= (rradd-0.1);\n\tfragColor.g *= 1.5;\n\tfragColor.b *= 0.7;\n\t\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtf3WN.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[179, 179, 201, 201, 281], [283, 283, 309, 309, 610], [612, 612, 653, 653, 824], [826, 826, 854, 854, 1296], [1298, 1298, 1355, 1355, 2156]], "test": "ok"}
{"id": "Wtf3Wr", "name": "Clock_Pong", "author": "sharkalash", "description": "It's a clock", "tags": ["clock"], "likes": 1, "viewed": 49, "published": "Public", "date": "1556105965", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\nstruct Circle {\n \tvec4 color;\n    vec2 coord;\n    float r;\n};\n\nstruct Line {\n\tvec4 color;\n    vec2 coord;\n    float size;\n    float angle;\n};\n\nvec4 draw_circle(vec4 fragColor, vec2 uv, Circle c)\n{\n    float res = (pow(uv.x - c.coord.x,2.0)+ pow(uv.y - c.coord.y,2.0));\n    if( abs(res-c.r*c.r) <= (abs(cos(iTime))*0.008 + 0.005)) {\n   \t\tfragColor = c.color; \n    }\n    \n    return fragColor;\n}\n\nvec4 draw_line(vec4 fragColor, vec2 uv, Line line) \n{\n    vec2 target;\n    \n    target.x = cos(line.angle)*line.size + line.coord.x;\n    target.y = sin(line.angle)*line.size + line.coord.y;\n    \n    \n    float coeff = (target.y - line.coord.y)  / (target.x - line.coord.x);\n \tfloat b = line.coord.y - line.coord.x * coeff;    \n    \n    if(abs(uv.x * coeff + b - uv.y) <= 0.012 * min(uv.x,line.coord.x)/max(uv.x,line.coord.x)) {\n     \t\n        if(target.x >= line.coord.x && uv.x >= line.coord.x && uv.x <= target.x)  {   \n        \tfragColor = line.color;\n        }\n        else if(target.x <= line.coord.x && uv.x <= line.coord.x && uv.x >= target.x) {\n            fragColor = line.color;\n        }\n    }\n    \n\treturn fragColor;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    vec3 black = vec3(.0,.0,.0);\n    vec4 white = vec4(1.0,1.0,1.0,1.0);\n    float speed = (540.0/260.0);\n\n    // Output to screen\n    fragColor = vec4(black,1.0);\n    fragColor = draw_circle(fragColor,uv,Circle(white,vec2(0.5,0.5),0.4)); \n    \n    fragColor = draw_line(fragColor,uv,Line(white,vec2(0.5,0.5),0.25,-iTime/speed));\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Wtf3Wr.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[144, 144, 197, 197, 394], [396, 396, 449, 449, 1126], [1128, 1128, 1185, 1235, 1607]], "test": "ok"}
{"id": "wtf3z8", "name": "Spirochaete", "author": "dyla", "description": "I had some fun with logarithmic spirals.", "tags": ["2d", "white", "black", "spirals"], "likes": 6, "viewed": 196, "published": "Public API", "date": "1555601288", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI 3.1415\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float time = cos(iTime*0.1)*12.5-12.5;\n    vec2 uv = (fragCoord-iResolution.xy*0.5)/iResolution.xx;\n    float alpha = atan(uv.y, uv.x);\n    float r = length(uv);\n    alpha += sin(time*0.25)*r*5.0;\n    float ra = time*0.075*log(r*200.0);\n    \n    fragColor = mix(\n        vec4(1.0,1.0,1.0,1.0),\n        vec4(1.0-smoothstep(0.2, 1.0, abs(sin(ra*12.0)-sin(alpha*12.0)))),\n        r*50.0\n    );\n   \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtf3z8.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[18, 18, 75, 75, 476]], "test": "ok"}
{"id": "Wtf3zM", "name": "simplified heightMapTracing", "author": "takahiroando", "description": "https://www.shadertoy.com/view/llsXD2 based on this.  Huge thanks for the creator!", "tags": ["test", "ocean"], "likes": 6, "viewed": 289, "published": "Public", "date": "1555840014", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// A documented version of \"Seascape\" for learning purposes.  Original shader page here:\n// https://www.shadertoy.com/view/Ms2SD1\n\n// \"Seascape\" by Alexander Alekseev aka TDM - 2014\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\nconst int NUM_STEPS = 8;\nconst float PI\t \t= 3.1415;\nconst float EPSILON\t= 1e-3;\n\n// sea\nconst int ITER_GEOMETRY = 3;\nconst int ITER_FRAGMENT = 5;\nconst float SEA_HEIGHT = 0.6;\nconst float SEA_CHOPPY = 4.0;\nconst float SEA_SPEED = 0.8;\nconst float SEA_FREQ = 0.16;\nconst vec3 SEA_BASE = vec3(0.1,0.19,0.22);\nconst vec3 SEA_WATER_COLOR = vec3(0.8,0.9,0.6);\nfloat SEA_TIME;\n\nmat2 octave_m = mat2(1.6,1.2,-1.2,1.6);\n\n// math\n// bteitler: Turn a vector of Euler angles into a rotation matrix\nmat3 fromEuler(vec3 ang) {\n\tvec2 a1 = vec2(sin(ang.x),cos(ang.x));\n    vec2 a2 = vec2(sin(ang.y),cos(ang.y));\n    vec2 a3 = vec2(sin(ang.z),cos(ang.z));\n    mat3 m;\n    m[0] = vec3(a1.y*a3.y+a1.x*a2.x*a3.x,a1.y*a2.x*a3.x+a3.y*a1.x,-a2.y*a3.x);\n\tm[1] = vec3(-a2.y*a1.x,a1.y*a2.y,a2.x);\n\tm[2] = vec3(a3.y*a1.x*a2.x+a1.y*a3.x,a1.x*a3.x-a1.y*a3.y*a2.x,a2.y*a3.y);\n\treturn m;\n}\n\n// bteitler: A 2D hash function for use in noise generation that returns range [0 .. 1].  You could\n// use any hash function of choice, just needs to deterministic and return\n// between 0 and 1, and also behave randomly.  Googling \"GLSL hash function\" returns almost exactly \n// this function: http://stackoverflow.com/questions/4200224/random-noise-functions-for-glsl\n// Performance is a real consideration of hash functions since ray-marching is already so heavy.\nfloat hash( vec2 p ) {\n    float h = dot(p,vec2(127.1,311.7));\t\n    return fract(sin(h)*43758.5453123);\n}\n\n// bteitler: A 2D psuedo-random wave / terrain function.  This is actually a poor name in my opinion,\n// since its the \"hash\" function that is really the noise, and this function is smoothly interpolating\n// between noisy points to create a continuous surface.\nfloat noise( in vec2 p ) {\n    vec2 i = floor( p );\n    vec2 f = fract( p );\t\n\n    // bteitler: This is equivalent to the \"smoothstep\" interpolation function.\n    // This is a smooth wave function with input between 0 and 1\n    // (since it is taking the fractional part of <p>) and gives an output\n    // between 0 and 1 that behaves and looks like a wave.  This is far from obvious, but we can graph it to see\n    // Wolfram link: http://www.wolframalpha.com/input/?i=plot+x*x*%283.0-2.0*x%29+from+x%3D0+to+1\n    // This is used to interpolate between random points.  Any smooth wave function that ramps up from 0 and\n    // and hit 1.0 over the domain 0 to 1 would work.  For instance, sin(f * PI / 2.0) gives similar visuals.\n    // This function is nice however because it does not require an expensive sine calculation.\n    vec2 u = f*f*(3.0-2.0*f);\n\n    // bteitler: This very confusing looking mish-mash is simply pulling deterministic random values (between 0 and 1)\n    // for 4 corners of the grid square that <p> is inside, and doing 2D interpolation using the <u> function\n    // (remember it looks like a nice wave!) \n    // The grid square has points defined at integer boundaries.  For example, if <p> is (4.3, 2.1), we will \n    // evaluate at points (4, 2), (5, 2), (4, 3), (5, 3), and then interpolate x using u(.3) and y using u(.1).\n    return -1.0+2.0*mix( \n                mix( hash( i + vec2(0.0,0.0) ), \n                     hash( i + vec2(1.0,0.0) ), \n                        u.x),\n                mix( hash( i + vec2(0.0,1.0) ), \n                     hash( i + vec2(1.0,1.0) ), \n                        u.x), \n                u.y);\n}\n\n// bteitler: diffuse lighting calculation - could be tweaked to taste\n// lighting\nfloat diffuse(vec3 n,vec3 l,float p) {\n    return pow(dot(n,l) * 0.4 + 0.6,p);\n}\n\n// bteitler: specular lighting calculation - could be tweaked taste\nfloat specular(vec3 n,vec3 l,vec3 e,float s) {    \n    float nrm = (s + 8.0) / (3.1415 * 8.0);\n    return pow(max(dot(reflect(e,n),l),0.0),s) * nrm;\n}\n\n// bteitler: Generate a smooth sky gradient color based on ray direction's Y value\n// sky\nvec3 getSkyColor(vec3 e) {\n    e.y = max(e.y,0.0);\n    vec3 ret;\n    ret.x = pow(1.0-e.y,2.0);\n    ret.y = 1.0-e.y;\n    ret.z = 0.6+(1.0-e.y)*0.4;\n    return ret;\n}\n\n// sea\n// bteitler: TLDR is that this passes a low frequency random terrain through a 2D symmetric wave function that looks like this:\n// http://www.wolframalpha.com/input/?i=%7B1-%7B%7B%7BAbs%5BCos%5B0.16x%5D%5D+%2B+Abs%5BCos%5B0.16x%5D%5D+%28%281.+-+Abs%5BSin%5B0.16x%5D%5D%29+-+Abs%5BCos%5B0.16x%5D%5D%29%7D+*+%7BAbs%5BCos%5B0.16y%5D%5D+%2B+Abs%5BCos%5B0.16y%5D%5D+%28%281.+-+Abs%5BSin%5B0.16y%5D%5D%29+-+Abs%5BCos%5B0.16y%5D%5D%29%7D%7D%5E0.65%7D%7D%5E4+from+-20+to+20\n// The <choppy> parameter affects the wave shape.\nfloat sea_octave(vec2 uv, float choppy) {\n    // bteitler: Add the smoothed 2D terrain / wave function to the input coordinates\n    // which are going to be our X and Z world coordinates.  It may be unclear why we are doing this.\n    // This value is about to be passed through a wave function.  So we have a smoothed psuedo random height\n    // field being added to our (X, Z) coordinates, and then fed through yet another wav function below.\n    uv += noise(uv);\n    // Note that you could simply return noise(uv) here and it would take on the characteristics of our \n    // noise interpolation function u and would be a reasonable heightmap for terrain.  \n    // However, that isn't the shape we want in the end for an ocean with waves, so it will be fed through\n    // a more wave like function.  Note that although both x and y channels of <uv> have the same value added, there is a \n    // symmetry break because <uv>.x and <uv>.y will typically be different values.\n\n    // bteitler: This is a wave function with pointy peaks and curved troughs:\n    // http://www.wolframalpha.com/input/?i=1-abs%28cos%28x%29%29%3B\n    vec2 wv = 1.0-abs(sin(uv)); \n\n    // bteitler: This is a wave function with curved peaks and pointy troughs:\n    // http://www.wolframalpha.com/input/?i=abs%28cos%28x%29%29%3B\n    vec2 swv = abs(cos(uv));  \n  \n    // bteitler: Blending both wave functions gets us a new, cooler wave function (output between 0 and 1):\n    // http://www.wolframalpha.com/input/?i=abs%28cos%28x%29%29+%2B+abs%28cos%28x%29%29+*+%28%281.0-abs%28sin%28x%29%29%29+-+abs%28cos%28x%29%29%29\n    wv = mix(wv,swv,wv);\n\n    // bteitler: Finally, compose both of the wave functions for X and Y channels into a final \n    // 1D height value, shaping it a bit along the way.  First, there is the composition (multiplication) of\n    // the wave functions: wv.x * wv.y.  Wolfram will give us a cute 2D height graph for this!:\n    // http://www.wolframalpha.com/input/?i=%7BAbs%5BCos%5Bx%5D%5D+%2B+Abs%5BCos%5Bx%5D%5D+%28%281.+-+Abs%5BSin%5Bx%5D%5D%29+-+Abs%5BCos%5Bx%5D%5D%29%7D+*+%7BAbs%5BCos%5By%5D%5D+%2B+Abs%5BCos%5By%5D%5D+%28%281.+-+Abs%5BSin%5By%5D%5D%29+-+Abs%5BCos%5By%5D%5D%29%7D\n    // Next, we reshape the 2D wave function by exponentiation: (wv.x * wv.y)^0.65.  This slightly rounds the base of the wave:\n    // http://www.wolframalpha.com/input/?i=%7B%7BAbs%5BCos%5Bx%5D%5D+%2B+Abs%5BCos%5Bx%5D%5D+%28%281.+-+Abs%5BSin%5Bx%5D%5D%29+-+Abs%5BCos%5Bx%5D%5D%29%7D+*+%7BAbs%5BCos%5By%5D%5D+%2B+Abs%5BCos%5By%5D%5D+%28%281.+-+Abs%5BSin%5By%5D%5D%29+-+Abs%5BCos%5By%5D%5D%29%7D%7D%5E0.65\n    // one last final transform (with choppy = 4) results in this which resembles a recognizable ocean wave shape in 2D:\n    // http://www.wolframalpha.com/input/?i=%7B1-%7B%7B%7BAbs%5BCos%5Bx%5D%5D+%2B+Abs%5BCos%5Bx%5D%5D+%28%281.+-+Abs%5BSin%5Bx%5D%5D%29+-+Abs%5BCos%5Bx%5D%5D%29%7D+*+%7BAbs%5BCos%5By%5D%5D+%2B+Abs%5BCos%5By%5D%5D+%28%281.+-+Abs%5BSin%5By%5D%5D%29+-+Abs%5BCos%5By%5D%5D%29%7D%7D%5E0.65%7D%7D%5E4\n    // Note that this function is called with a specific frequency multiplier which will stretch out the wave.  Here is the graph\n    // with the base frequency used by map and map_detailed (0.16):\n    // http://www.wolframalpha.com/input/?i=%7B1-%7B%7B%7BAbs%5BCos%5B0.16x%5D%5D+%2B+Abs%5BCos%5B0.16x%5D%5D+%28%281.+-+Abs%5BSin%5B0.16x%5D%5D%29+-+Abs%5BCos%5B0.16x%5D%5D%29%7D+*+%7BAbs%5BCos%5B0.16y%5D%5D+%2B+Abs%5BCos%5B0.16y%5D%5D+%28%281.+-+Abs%5BSin%5B0.16y%5D%5D%29+-+Abs%5BCos%5B0.16y%5D%5D%29%7D%7D%5E0.65%7D%7D%5E4+from+-20+to+20\n    return pow(1.0-pow(wv.x * wv.y,0.65),choppy);\n}\n\n// bteitler: Compute the distance along Y axis of a point to the surface of the ocean\n// using a low(er) resolution ocean height composition function (less iterations).\nfloat map(vec3 p) {\n    float freq = SEA_FREQ;\n    float amp = SEA_HEIGHT;\n    float choppy = SEA_CHOPPY;\n    vec2 uv = p.xz; uv.x *= 0.75;\n    \n    // bteitler: Compose our wave noise generation (\"sea_octave\") with different frequencies\n    // and offsets to achieve a final height map that looks like an ocean.  Likely lots\n    // of black magic / trial and error here to get it to look right.  Each sea_octave has this shape:\n    // http://www.wolframalpha.com/input/?i=%7B1-%7B%7B%7BAbs%5BCos%5B0.16x%5D%5D+%2B+Abs%5BCos%5B0.16x%5D%5D+%28%281.+-+Abs%5BSin%5B0.16x%5D%5D%29+-+Abs%5BCos%5B0.16x%5D%5D%29%7D+*+%7BAbs%5BCos%5B0.16y%5D%5D+%2B+Abs%5BCos%5B0.16y%5D%5D+%28%281.+-+Abs%5BSin%5B0.16y%5D%5D%29+-+Abs%5BCos%5B0.16y%5D%5D%29%7D%7D%5E0.65%7D%7D%5E4+from+-20+to+20\n    // which should give you an idea of what is going.  You don't need to graph this function because it\n    // appears to your left :)\n    float d, h = 0.0;    \n    for(int i = 0; i < ITER_GEOMETRY; i++) {\n        // bteitler: start out with our 2D symmetric wave at the current frequency\n    \td = sea_octave((uv+SEA_TIME)*freq,choppy);\n        // bteitler: stack wave ontop of itself at an offset that varies over time for more height and wave pattern variance\n    \td += sea_octave((uv-SEA_TIME)*freq,choppy);\n\n        h += d * amp; // bteitler: Bump our height by the current wave function\n        \n        // bteitler: \"Twist\" our domain input into a different space based on a permutation matrix\n        // The scales of the matrix values affect the frequency of the wave at this iteration, but more importantly\n        // it is responsible for the realistic assymetry since the domain is shiftly differently.\n        // This is likely the most important parameter for wave topology.\n    \tuv *= octave_m;\n        \n        freq *= 1.9; // bteitler: Exponentially increase frequency every iteration (on top of our permutation)\n        amp *= 0.22; // bteitler: Lower the amplitude every frequency, since we are adding finer and finer detail\n        // bteitler: finally, adjust the choppy parameter which will effect our base 2D sea_octave shape a bit.  This makes\n        // the \"waves within waves\" have different looking shapes, not just frequency and offset\n        choppy = mix(choppy,1.0,0.2);\n    }\n    return p.y - h;\n}\n\n// bteitler: Compute the distance along Y axis of a point to the surface of the ocean\n// using a high(er) resolution ocean height composition function (more iterations).\nfloat map_detailed(vec3 p) {\n    float freq = SEA_FREQ;\n    float amp = SEA_HEIGHT;\n    float choppy = SEA_CHOPPY;\n    vec2 uv = p.xz; uv.x *= 0.75;\n    \n    // bteitler: Compose our wave noise generation (\"sea_octave\") with different frequencies\n    // and offsets to achieve a final height map that looks like an ocean.  Likely lots\n    // of black magic / trial and error here to get it to look right.  Each sea_octave has this shape:\n    // http://www.wolframalpha.com/input/?i=%7B1-%7B%7B%7BAbs%5BCos%5B0.16x%5D%5D+%2B+Abs%5BCos%5B0.16x%5D%5D+%28%281.+-+Abs%5BSin%5B0.16x%5D%5D%29+-+Abs%5BCos%5B0.16x%5D%5D%29%7D+*+%7BAbs%5BCos%5B0.16y%5D%5D+%2B+Abs%5BCos%5B0.16y%5D%5D+%28%281.+-+Abs%5BSin%5B0.16y%5D%5D%29+-+Abs%5BCos%5B0.16y%5D%5D%29%7D%7D%5E0.65%7D%7D%5E4+from+-20+to+20\n    // which should give you an idea of what is going.  You don't need to graph this function because it\n    // appears to your left :)\n    float d, h = 0.0;    \n    for(int i = 0; i < ITER_FRAGMENT; i++) {\n        // bteitler: start out with our 2D symmetric wave at the current frequency\n    \td = sea_octave((uv+SEA_TIME)*freq,choppy);\n        // bteitler: stack wave ontop of itself at an offset that varies over time for more height and wave pattern variance\n    \td += sea_octave((uv-SEA_TIME)*freq,choppy);\n        \n        h += d * amp; // bteitler: Bump our height by the current wave function\n        \n        // bteitler: \"Twist\" our domain input into a different space based on a permutation matrix\n        // The scales of the matrix values affect the frequency of the wave at this iteration, but more importantly\n        // it is responsible for the realistic assymetry since the domain is shiftly differently.\n        // This is likely the most important parameter for wave topology.\n    \tuv *= octave_m;\n        \n        freq *= 1.9; // bteitler: Exponentially increase frequency every iteration (on top of our permutation)\n        amp *= 0.22; // bteitler: Lower the amplitude every frequency, since we are adding finer and finer detail\n        // bteitler: finally, adjust the choppy parameter which will effect our base 2D sea_octave shape a bit.  This makes\n        // the \"waves within waves\" have different looking shapes, not just frequency and offset\n        choppy = mix(choppy,1.0,0.2);\n    }\n    return p.y - h;\n}\n\n// bteitler:\n// p: point on ocean surface to get color for\n// n: normal on ocean surface at <p>\n// l: light (sun) direction\n// eye: ray direction from camera position for this pixel\n// dist: distance from camera to point <p> on ocean surface\nvec3 getSeaColor(vec3 p, vec3 n, vec3 l, vec3 eye, vec3 dist) {  \n    // bteitler: Fresnel is an exponential that gets bigger when the angle between ocean\n    // surface normal and eye ray is smaller\n    float fresnel = 1.0 - max(dot(n,-eye),0.0);\n    fresnel = pow(fresnel,3.0) * 0.65;\n        \n    // bteitler: Bounce eye ray off ocean towards sky, and get the color of the sky\n    vec3 reflected = getSkyColor(reflect(eye,n));    \n    \n    // bteitler: refraction effect based on angle between light surface normal\n    vec3 refracted = SEA_BASE + diffuse(n,l,80.0) * SEA_WATER_COLOR * 0.12; \n    \n    // bteitler: blend the refracted color with the reflected color based on our fresnel term\n    vec3 color = mix(refracted,reflected,fresnel);\n    \n    // bteitler: Apply a distance based attenuation factor which is stronger\n    // at peaks\n    float atten = max(1.0 - dot(dist,dist) * 0.001, 0.0);\n    color += SEA_WATER_COLOR * (p.y - SEA_HEIGHT) * 0.18 * atten;\n    \n    // bteitler: Apply specular highlight\n    color += vec3(specular(n,l,eye,60.0));\n    \n    return color;\n}\n\n// bteitler: Estimate the normal at a point <p> on the ocean surface using a slight more detailed\n// ocean mapping function (using more noise octaves).\n// Takes an argument <eps> (stands for epsilon) which is the resolution to use\n// for the gradient.  See here for more info on gradients: https://en.wikipedia.org/wiki/Gradient\n// tracing\nvec3 getNormal(vec3 p, float eps) {\n    // bteitler: Approximate gradient.  An exact gradient would need the \"map\" / \"map_detailed\" functions\n    // to return x, y, and z, but it only computes height relative to surface along Y axis.  I'm assuming\n    // for simplicity and / or optimization reasons we approximate the gradient by the change in ocean\n    // height for all axis.\n    vec3 n;\n    n.y = map_detailed(p); // bteitler: Detailed height relative to surface, temporarily here to save a variable?\n    n.x = map_detailed(vec3(p.x+eps,p.y,p.z)) - n.y; // bteitler approximate X gradient as change in height along X axis delta\n    n.z = map_detailed(vec3(p.x,p.y,p.z+eps)) - n.y; // bteitler approximate Z gradient as change in height along Z axis delta\n    // bteitler: Taking advantage of the fact that we know we won't have really steep waves, we expect\n    // the Y normal component to be fairly large always.  Sacrifices yet more accurately to avoid some calculation.\n    n.y = eps; \n    return normalize(n);\n\n    // bteitler: A more naive and easy to understand version could look like this and\n    // produces almost the same visuals and is a little more expensive.\n    // vec3 n;\n    // float h = map_detailed(p);\n    // n.y = map_detailed(vec3(p.x,p.y+eps,p.z)) - h;\n    // n.x = map_detailed(vec3(p.x+eps,p.y,p.z)) - h;\n    // n.z = map_detailed(vec3(p.x,p.y,p.z+eps)) - h;\n    // return normalize(n);\n}\n\n// bteitler: Find out where a ray intersects the current ocean\nfloat heightMapTracing(vec3 ori, vec3 dir, out vec3 p) {  \n    float tm = 0.0;\n    float tx = 1000.0; // bteitler: a really far distance, this could likely be tweaked a bit as desired\n\n    // bteitler: At a really far away distance along the ray, what is it's height relative\n    // to the ocean in ONLY the Y direction?\n    float hx = map(ori + dir * tx);\n    \n    // bteitler: A positive height relative to the ocean surface (in Y direction) at a really far distance means\n    // this pixel is pure sky.  Quit early and return the far distance constant.\n    if(hx > 0.0) return tx;   \n\n    // bteitler: hm starts out as the height of the camera position relative to ocean.\n    float hm = map(ori + dir * tm); \n   \n    // bteitler: This is the main ray marching logic.  This is probably the single most confusing part of the shader\n    // since height mapping is not an exact distance field (tells you distance to surface if you drop a line down to ocean\n    // surface in the Y direction, but there could have been a peak at a very close point along the x and z \n    // directions that is closer).  Therefore, it would be possible/easy to overshoot the surface using the raw height field\n    // as the march distance.  The author uses a trick to compensate for this.\n    float tmid = tm;\n    for(int i = 0; i < NUM_STEPS; i++) { // bteitler: Constant number of ray marches per ray that hits the water\n        // bteitler: Move forward along ray in such a way that has the following properties:\n        // 1. If our current height relative to ocean is higher, move forward more\n        // 2. If the height relative to ocean floor very far along the ray is much lower\n        //    below the ocean surface, move forward less\n        // Idea behind 1. is that if we are far above the ocean floor we can risk jumping\n        // forward more without shooting under ocean, because the ocean is mostly level.\n        // The idea behind 2. is that if extruding the ray goes farther under the ocean, then \n        // you are looking more orthgonal to ocean surface (as opposed to looking towards horizon), and therefore\n        // movement along the ray gets closer to ocean faster, so we need to move forward less to reduce risk\n        // of overshooting.\n        //tmid = mix(tm,tx, hm/(hm-hx));\n        p = ori + dir * tmid; \n                  \n    \tfloat hmid = map(p); // bteitler: Re-evaluate height relative to ocean surface in Y axis\n        tmid += hmid;\n\n        /*if(hmid < 0.0) { // bteitler: We went through the ocean surface if we are negative relative to surface now\n            // bteitler: So instead of actually marching forward to cross the surface, we instead\n            // assign our really far distance and height to be where we just evaluated that crossed the surface.\n            // Next iteration will attempt to go forward more and is less likely to cross the boundary.\n            // A naive implementation might have returned <tmid> immediately here, which\n            // results in a much poorer / somewhat indeterministic quality rendering.\n            tx = tmid;\n            hx = hmid;\n        } else {\n            // Haven't hit surface yet, easy case, just march forward\n            tm = tmid;\n            hm = hmid;\n        }*/\n    }\n\n    // bteitler: Return the distance, which should be really close to the height map without going under the ocean\n    return tmid;\n}\n\n// main\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n     float EPSILON_NRM\t= 0.1 / iResolution.x;\n    float SEA_TIME = iTime * SEA_SPEED;\n\n\n    // bteitler: 2D Pixel location passed in as raw pixel, let's divide by resolution\n    // to convert to coordinates between 0 and 1\n    vec2 uv = fragCoord.xy / iResolution.xy;\n\n    uv = uv * 2.0 - 1.0; //  bteitler: Shift pixel coordinates from 0 to 1 to between -1 and 1\n    uv.x *= iResolution.x / iResolution.y; // bteitler: Aspect ratio correction - if you don't do this your rays will be distorted\n    float time = iTime * 0.3 + iMouse.x*0.01; // bteitler: Animation is based on time, but allows you to scrub the animation based on mouse movement\n        \n    // ray\n\n    // bteitler: Calculated a vector that smoothly changes over time in a sinusoidal (wave) pattern.  \n    // This will be used to drive where the user is looking in world space.\n    vec3 ang = vec3(sin(time*3.0)*0.1,sin(time)*0.2+0.3,time);\n    \n    // bteitler: Calculate the \"origin\" of the camera in world space based on time.  Camera is located\n    // at height 3.5, at x 0 (zero), and flies over the ocean in the z axis over time.\n    vec3 ori = vec3(0.0,4.5,time*5.0);\n   \n    // bteitler: This is the ray direction we are shooting from the camera location (\"ori\") that we need to light\n    // for this pixel.  The -2.0 indicates we are using a focal length of 2.0 - this is just an artistic choice and\n    // results in about a 90 degree field of view.\n    vec3 dir = normalize(vec3(uv.xy,-2.0)); \n\n    // bteitler: Distort the ray a bit for a fish eye effect (if you remove this line, it will remove\n    // the fish eye effect and look like a realistic perspective).\n    // dir.z += length(uv) * 0.15;\n\n    // bteitler: Renormalize the ray direction, and then rotate it based on the previously calculated\n    // animation angle \"ang\".  \"fromEuler\" just calculates a rotation matrix from a vector of angles.\n    // if you remove the \" * fromEuler(ang)\" part, you will disable the camera rotation animation.\n    dir = normalize(dir) * fromEuler(ang);\n    \n    // tracing\n\n    // bteitler: ray-march to the ocean surface (which can be thought of as a randomly generated height map)\n    // and store in p\n    vec3 p;\n    heightMapTracing(ori,dir,p);\n\n    vec3 dist = p - ori; // bteitler: distance vector to ocean surface for this pixel's ray\n\n    // bteitler: Calculate the normal on the ocean surface where we intersected (p), using\n    // different \"resolution\" (in a sense) based on how far away the ray traveled.  Normals close to\n    // the camera should be calculated with high resolution, and normals far from the camera should be calculated with low resolution\n    // The reason to do this is that specular effects (or non linear normal based lighting effects) become fairly random at\n    // far distances and low resolutions and can cause unpleasant shimmering during motion.\n    vec3 n = getNormal(p, \n             dot(dist,dist)   // bteitler: Think of this as inverse resolution, so far distances get bigger at an expnential rate\n                * EPSILON_NRM // bteitler: Just a resolution constant.. could easily be tweaked to artistic content\n           );\n\n    // bteitler: direction of the infinitely far away directional light.  Changing this will change\n    // the sunlight direction.\n    vec3 light = normalize(vec3(0.0,1.0,0.8)); \n             \n    // color\n\n    // bteitler: Mix (linear interpolate) a color calculated for the sky (based solely on ray direction) and a sea color \n    // which contains a realistic lighting model.  This is basically doing a fog calculation: weighing more the sky color\n    // in the distance in an exponential manner.\n    vec3 color = mix(\n        getSkyColor(dir),\n        getSeaColor(p,n,light,dir,dist),\n    \tpow(smoothstep(0.0,-0.05,dir.y), 0.3) // bteitler: Can be thought of as \"fog\" that gets thicker in the distance\n    );\n        \n    // post\n    \n    // bteitler: Apply an overall image brightness factor as the final color for this pixel.  Can be\n    // tweaked artistically.\n    fragColor = vec4(pow(color,vec3(0.75)), 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Wtf3zM.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[683, 757, 783, 783, 1129], [1131, 1597, 1619, 1619, 1702], [1704, 1965, 1991, 1991, 3625], [3627, 3709, 3747, 3747, 3789], [3791, 3859, 3905, 3905, 4009], [4011, 4101, 4127, 4127, 4265], [4267, 4790, 4831, 5233, 8385], [8387, 8556, 8575, 8575, 10857], [10859, 11029, 11057, 11057, 13347], [13349, 13591, 13654, 13790, 14672], [14674, 15014, 15049, 15392, 16432], [16434, 16497, 16553, 16553, 19894], [19896, 19904, 19961, 19961, 24026]], "test": "timeout"}
{"id": "wtfGR8", "name": "Cube Plot Doodle", "author": "TekF", "description": "Inspired by this: https://twitter.com/sasj_nl/status/1118844071756357633", "tags": ["wireframe", "rotation", "plotter"], "likes": 33, "viewed": 792, "published": "Public API", "date": "1555610148", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Created by Hazel Quantock 2019\n// This work is licensed under a Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International License. http://creativecommons.org/licenses/by-nc-sa/4.0/\n\n\nconst int numCubes = 32;\nconst float twistStep = .06;\nconst float scaleStep = 0.96;\nconst float zoom = 3.7;\nconst float lineThickness = 1.2; // in pixels\n\n/*\n// alternative settings for full-screen\nconst int numCubes = 64;\nconst float twistStep = .03;\nconst float scaleStep = 0.98;\nconst float zoom = 2.8;\nconst float lineThickness = .8; // in pixels\n*/\n\n\n// input in range [-1,1] to span iResolution.y pixels\nfloat RenderLine( vec2 a, vec2 b, vec2 fragCoord )\n{\n    a = (iResolution.y*a + iResolution.xy)*.5;\n    b = (iResolution.y*b + iResolution.xy)*.5;\n    \n    const float halfThickness = lineThickness*.5; \n\n    const float halfAASoftening = .7; // in pixels (don't change this much)\n    \n    float t = dot(fragCoord-a,b-a);\n    t /= dot(b-a,b-a);\n    t = clamp( t, 0., 1. );\n    return smoothstep( halfThickness-halfAASoftening, halfThickness+halfAASoftening, length(fragCoord - mix(a,b,t)) );\n}\n\n    \nfloat RenderLine3D( vec3 a, vec3 b, vec2 fragCoord )\n{\n    vec3 camPos = vec3(0,0,-5);\n    \n    a -= camPos;\n    b -= camPos;\n    \n    // todo: transform by camera matrix\n\n    a.z /= zoom;\n    b.z /= zoom;\n    \n    // perspective projection\n    return RenderLine( a.xy/a.z, b.xy/b.z, fragCoord );\n}\n\n\n// combine 2 anti-aliased values\nfloat BlendAA( float a, float b )\n{\n    // a and b values represent what proportion of the pixel is covered by each line,\n    // but they don't contain enough information to accurately combine them!\n    // if both lines are covering the same part of the pixel the result should be min(a,b)\n    // if they cover non-overlapping parts of the pixel the result is a-(1-b)\n\t// a*b assumes the proportion of overlap is the same in the solid and clear regions\n    // this is the safest assumption given the lack of any other info\n\n    // but, tune it until it looks good\n    return mix( min(a,b), a*b, .5 );\n}\n\n\nvoid mainImage( out vec4 fragColour, in vec2 fragCoord )\n{\n    fragColour.rgb = vec3(.8);\n    \n    vec3 a = vec3(twistStep*cos(iTime*3./vec3(11,13,17)+1.5));\n    mat3 stepTransform =\n        scaleStep *\n        mat3( cos(a.z), sin(a.z), 0,\n             -sin(a.z), cos(a.z), 0,\n              0, 0, 1 ) *\n        mat3( cos(a.y), 0, sin(a.y),\n             0, 1, 0,\n             -sin(a.y), 0, cos(a.y) ) *\n        mat3( 1, 0, 0,\n              0, cos(a.x), sin(a.x),\n              0,-sin(a.x), cos(a.x) );\n\n    vec3 b = vec3(.7+iTime/6.,.7+iTime/6.,.6);\n    mat3 transform = //mat3(1,0,0,0,1,0,0,0,1); // identity\n        mat3( cos(b.z), sin(b.z), 0,\n             -sin(b.z), cos(b.z), 0,\n              0, 0, 1 ) *\n        mat3( cos(b.y), 0, sin(b.y),\n             0, 1, 0,\n             -sin(b.y), 0, cos(b.y) ) *\n        mat3( 1, 0, 0,\n              0, cos(b.x), sin(b.x),\n              0,-sin(b.x), cos(b.x) );\n\n    float line = 1.;\n    #define DrawLine(a,b) line = BlendAA( line, RenderLine3D(a,b,fragCoord) );\n    \n    for ( int cube=0; cube < numCubes; cube++ )\n    {\n        vec3 vertices[8];\n        for ( int i=0; i < 8; i++ )\n        {\n            vertices[i] = transform*(vec3(i>>2,(i>>1)&1,i&1)*2.-1.);\n        }\n        \n        DrawLine( vertices[0], vertices[1] );\n        DrawLine( vertices[2], vertices[3] );\n        DrawLine( vertices[4], vertices[5] );\n        DrawLine( vertices[6], vertices[7] );\n        DrawLine( vertices[0], vertices[2] );\n        DrawLine( vertices[1], vertices[3] );\n        DrawLine( vertices[4], vertices[6] );\n        DrawLine( vertices[5], vertices[7] );\n        DrawLine( vertices[0], vertices[4] );\n        DrawLine( vertices[1], vertices[5] );\n        DrawLine( vertices[2], vertices[6] );\n        DrawLine( vertices[3], vertices[7] );\n        \n        transform *= stepTransform;\n    }\n    \n    fragColour.rgb = mix( vec3(.02), vec3(.8), line );\n    \n    fragColour.rgb = pow(fragColour.rgb,vec3(1./2.2));\n    fragColour.a = 1.;\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtfGR8.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-4.0", "functions": [[556, 610, 662, 662, 1102], [1109, 1109, 1163, 1163, 1407], [1410, 1443, 1478, 2006, 2045], [2048, 2048, 2106, 2106, 4022]], "test": "ok"}
{"id": "WtfGW7", "name": "Voronoi blocks", "author": "MrsBeanbag", "description": "started off tinkering with Voronoi graphs, and ended up with this.\n\nit's a bit slow though.\n\n2019 April 29, 7:45pm: implemented a smooth intersection function and improved the speed a little\n", "tags": ["voronoi"], "likes": 14, "viewed": 504, "published": "Public API", "date": "1556457934", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// ray marching\nconst int max_iterations = 128;\nconst float grad_step = 0.0001;\nconst float min_dist = 0.005;\nconst float clip_far = 1000.0;\n\n// math\nconst float PI = 3.14159265359;\nconst float DEG_TO_RAD = PI / 180.0;\n\nvec3 diffuse_colour = vec3(0.0);\nvec3 final_diff_colour = vec3(0.0);\n\n\nconst vec3 sky_colour = vec3(0.2, 0.6, 1.0);\nconst vec3 clouds_colour = vec3(1.0);\nconst vec3 sun_colour = 32.0 * vec3(1.0, 1.0, 0.0);\nconst vec3 sun_pos = normalize(vec3( 20.0, 30.0, 30.0 ));\n\n//get a scalar random value from a 3d value\nfloat rand3dTo1d(vec3 value, vec3 dotDir) {\n    //make value smaller to avoid artefacts\n    vec3 smallValue = sin(value);\n    //get scalar value from 3d vector\n    float random = dot(smallValue, dotDir);\n    //make value more random by making it bigger and then taking the factional part\n    random = fract(sin(random) * 143758.5453);\n    return random;\n}\n\nvec3 rand3dTo3d(vec3 value){\n    return vec3(\n        rand3dTo1d(value, vec3(12.989, 78.233, 37.719)),\n        rand3dTo1d(value, vec3(39.346, 11.135, 83.155)),\n        rand3dTo1d(value, vec3(73.156, 52.235, 09.151))\n    );\n}\n\n/*vec2 random2( vec2 p ) {\n    return fract(sin(vec2(dot(p,vec2(127.1,311.7)),dot(p,vec2(269.5,183.3))))*43758.5453);\n}*/\n\n// this isn't very random but it's a good deal quicker than the above\nvec2 random2( vec2 p ) {\n    return fract(p * vec2(9.61, 3.28) - p.yx * vec2(5.85, 7.11));\n}\n\n// http://www.iquilezles.org/www/articles/smin/smin.htm\n// polynomial smooth min (k = 0.1);\nfloat smin( float a, float b, float k )\n{\n    float h = max( k-abs(a-b), 0.0 )/k;\n    return min( a, b ) - h*h*h*k*(1.0/6.0);\n}\n\nfloat smax( float a, float b, float k ) {\n    return -smin(-a, -b, k);\n}\n\nvec2 cell_position(vec2 cell) {\n    vec2 point = random2(cell);\n    point = 0.5 - 0.4*sin(iTime + 6.2831*point);\n    return cell + point;\n}\n\nfloat dist_field(vec3 p) {\n    float md = 1000.0;\n    vec2 mcell = vec2(0.0);\n    vec2 mpos = vec2(0.0);\n    vec2 fuv = floor(p.xz);\n    for (int i = -1; i <= 1; ++i) {\n\t    for (int j = -1; j <= 1; ++j) {\n            vec2 ij = vec2(float(i), float(j));\n            vec2 cell = ij + fuv;\n            vec2 pos = cell_position(cell);\n    \t\tvec2 mid = p.xz - pos;\n            float d = dot(mid, mid);\n            if (d < md) {\n                md = d;\n                mcell = cell;\n                mpos = pos;\n            }\n        }\n    }\n    \n    float plane = p.y;\n\n    for (int i = -1; i <= 1; ++i) {\n\t    for (int j = -1; j <= 1; ++j) {\n            vec2 ij = vec2(float(i), float(j));\n   \t        vec2 cell = ij + fuv;\n            if (cell != mcell) {\n\t            vec2 pos = cell_position(cell);\n\t\t\t    vec2 n = normalize(mpos - pos);\n\t\t\t    vec2 pt = (mpos + pos) * 0.5;\n                { // smooth pebbles :)\n\t\t\t\t    plane = smax(plane, -dot(n, p.xz - pt)+0.1, 0.2);\n                }\n                /*{ // angular blocks\n\t\t\t\t    plane = max(plane, -dot(n, p.xz - pt)+0.1);\n\t\t\t\t    vec3 n = vec3(n, -1.0).xzy / sqrt(2.0);\n\t\t\t\t    vec3 pt = vec3((mpos + pos) * 0.5, -0.15).xzy;\n\t\t\t\t    plane = max(plane, -dot(n, p - pt));\n                }*/\n            }\n        }\n    }\n\n    float floor = p.y + 0.2;\n    if (floor < plane) {\n        diffuse_colour = vec3(smoothstep(0.08, 0.09, plane)*0.4 + 0.3);\n        plane = min(plane, floor);\n    } else {\n\t    diffuse_colour = rand3dTo3d(vec3(mcell, 0.0));\n    }\n    return plane;\n}\n\nvec3 skybox(vec3 dir) {\n    float horizon = smoothstep(0.0, 0.25, dir.y);\n    float cloud = mix(0.8, 0.0, horizon);\n    return mix(sky_colour, clouds_colour, cloud);\n}\n\n// get gradient in the world\nvec3 gradient( vec3 p ) {\n    const vec2 k = vec2(1,-1);\n    const vec2 kg = vec2(grad_step,-grad_step);\n    return vec3( k.xyy*dist_field( p + kg.xyy) +\n                 k.yyx*dist_field( p + kg.yyx) +\n                 k.yxy*dist_field( p + kg.yxy) +\n                 k.xxx*dist_field( p + kg.xxx) );\n}\n\n// parallel light source\nvec3 shading( vec3 v, vec3 n, vec3 dir, vec3 eye ) {\n\tfloat diffuse  = max( 0.0, dot( sun_pos, n ) );\n\tfloat shininess = 80.0;\n\t\n\tvec3 ref = reflect( dir, n );\n\tfloat specular = max( 0.0, dot( sun_pos, ref ) );\n\t\t\n\tspecular = pow( specular, shininess );\n\t\t\n\treturn final_diff_colour * diffuse + vec3(specular);\n}\n\n// ray marching\n// Enhanced Sphere Tracing:\n// http://erleuchtet.org/~cupe/permanent/enhanced_sphere_tracing.pdf\nvec3 ray_marching(vec3 o, vec3 dir) {\n    vec3 colour = vec3(0.0);\n    vec3 acc_refl = vec3(1.0);\n\n    // give the ray a bit of a head start by jumping\n    // straight to the upper bounding plane!\n    float t = 0.0;\n    if (dir.y < 0.0) {\n        t = -o.y/dir.y;\n    } else {\n        return skybox(dir);\n    }\n\tt = max(t, min_dist*2.0);\n\n    vec3 v;\n    for (int i = 0; i < max_iterations; i++) {\n       \tfloat d = dist_field(v = o + dir * t);\n\n        if (d <= min_dist) {\n            break;\n        }\n\t\tif ((t+=d) >= clip_far) {\n            return skybox(dir);\n\t    }\n    }\n\tfinal_diff_colour = diffuse_colour;\n\n    vec3 n = normalize( gradient(v) );\n\n    colour += shading( v, n, dir, o );\n\n    return colour;\n}\n\n// get ray direction\nvec3 ray_dir( float fov, vec2 size, vec2 pos ) {\n\tvec2 xy = pos - size * 0.5;\n\n\tfloat cot_half_fov = tan( ( 90.0 - fov * 0.5 ) * DEG_TO_RAD );\n\tfloat z = size.y * 0.5 * cot_half_fov;\n\n\treturn normalize( vec3( xy, -z ) );\n}\n\n// camera rotation : pitch, yaw\nmat3 rotationXY( vec2 angle ) {\n\tvec2 c = cos( angle );\n\tvec2 s = sin( angle );\n\n\treturn mat3(\n\t\tc.y      ,  0.0, -s.y,\n\t\ts.y * s.x,  c.x,  c.y * s.x,\n\t\ts.y * c.x, -s.x,  c.y * c.x\n\t);\n}\n\nconst vec2 spin = vec2(0.005, 0.0041);\nconst float radius = 120.0;\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\t// rotate camera\n\tmat3 rot = rotationXY( vec2( -0.8, iTime * 0.2 ) );\n\t//mat3 rot = rotationXY( ( iMouse.xy - iResolution.xy * 0.5 ).yx * vec2( 0.01, -0.01 ) );\n\n\t// default ray origin\n\tvec3 eye = vec3( 0.0, 0.0, 0.0 );\n\teye = rot * eye;\n    \n    // move in a sinusoidal path so we don't end up in floating point hell!\n    vec2 camera = radius * cos(iTime * spin);\n    \n    eye += vec3(camera, 2.0).xzy;\n\n    // default ray dir\n\tvec3 dir = rot * ray_dir( 60.0, iResolution.xy, fragCoord.xy);\n\tvec3 color = ray_marching(eye, dir);\n\n\tfragColor = vec4(color, 1.0);\n    return;\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WtfGW7.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[485, 529, 572, 616, 884], [886, 886, 914, 914, 1110], [1235, 1305, 1329, 1329, 1397], [1399, 1491, 1532, 1532, 1618], [1620, 1620, 1661, 1661, 1692], [1694, 1694, 1725, 1725, 1833], [1835, 1835, 1861, 1861, 3364], [3366, 3366, 3389, 3389, 3533], [3535, 3564, 3589, 3589, 3867], [3869, 3894, 3946, 3946, 4206], [4208, 4321, 4358, 4358, 5035], [5037, 5058, 5106, 5106, 5280], [5282, 5314, 5345, 5345, 5500], [5569, 5569, 5626, 5644, 6203]], "test": "error"}
{"id": "Wtl3D4", "name": "spiral-glass effect 3", "author": "FabriceNeyret2", "description": ".", "tags": ["2d", "video", "short"], "likes": 4, "viewed": 299, "published": "Public API", "date": "1556362309", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// variant of https://shadertoy.com/view/3tl3D4\n\n#define hash(p)  fract(sin(dot(p, vec2(12.9898, 78.233))) * 43758.5453)\n#define hash2(p) fract(sin( p *mat2( 127.1,311.7, 269.5,183.3 ) )*43758.5453123)\n\nvoid mainImage( out vec4 O, vec2 u )\n{\n    vec2 R = iResolution.xy,\n         U = ( u+u - R ) / R.y, \n         V = 2.*fract(4.*U) - 1.,\n         T = floor(4.*U);\n    \n    float s = cos(iTime+6.3*hash(T)), // 14.*T.x-78.4*T.y),\n          l = length(V),                             \n          a = atan(V.y,V.x); a = mod(a,6.283);\n    \n    a += 10. * exp(-4.*l)\n        * s;  s=1.;                  // both optional\n   \n    V = l * max(0.,cos(l*1.57))\n          * vec2(cos(a),sin(a));\n     \n    U  = V * s;                      // chose variant\n // U += V * s;\n    \n // O = vec4(.5+.5*U,.5,1);\n    O = vec4(sin(3.14*U.y));\n}", "image_inputs": [{"id": "4dfGRn", "previewfilepath": "/media/ap/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Wtl3D4.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[203, 203, 241, 241, 823]], "test": "ok"}
{"id": "Wtl3D7", "name": "star trails", "author": "mxr233", "description": "orbits.", "tags": ["test", "star", "polar", "trail"], "likes": 10, "viewed": 340, "published": "Public", "date": "1556626755", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI 3.1415926\nfloat rand(float t)\n{\n    return fract(sin(dot(vec2(t,t) ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tfloat time=iTime;\n\tvec2 uv=(fragCoord.xy*2.0-iResolution.xy)/iResolution.y;\n \tvec2 uv1=uv-vec2(0.8,.4);\n    float r = length(uv1)*111.;\n    \n    float t = ceil(r);\n    float a = fract(atan(uv1.y, uv1.x)/PI+time*rand(t)*.1 +t*0.1);\n\n    float ang = rand(t);\n    float c = smoothstep(ang,ang-1.5,a*5.) ;\n    \n    vec3 col = vec3(.3,0.3,.5)*3.;\n    float rr = length(uv-vec2(0.6,1.4))-0.8;\n\tvec3 coll=vec3(0.,rr*0.1,rr*0.24);\n    \n    coll=mix(coll,col*rand(t),c*step(0.1,r/111.));\n    \n    fragColor=vec4(coll,1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Wtl3D7.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[21, 21, 42, 42, 118], [120, 120, 177, 177, 694]], "test": "ok"}
{"id": "Wtl3DH", "name": "raycasting illustrated", "author": "stduhpf", "description": "I needed something to explain visually how raytracing works, so i raytraced it.\n\nCode commented in french for some reasons.", "tags": ["raycasting", "meta"], "likes": 12, "viewed": 222, "published": "Public", "date": "1556277629", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec4 iSphere(vec3 sp, float sr,vec3 ro, vec3 rd) //intersection entre une sphere et un rayon\n{\nvec3 p = sp-ro;\nfloat d = dot(-rd,p);\nfloat i = d*d- dot(p,p)+sr*sr;\nd = i>0.?-sqrt(i)-d:-1000.;\n    if(d<0.)\n        i=-abs(i);\nreturn vec4(normalize(rd*d-p),i>0.?d:1e6); //renvoie le vecteur normal au point d'intersection et la distance\n}\t\t\t\t\t\t\t\t\t//1e6 est un nombre tres grand\n\nfloat iPlane(vec3 ro, vec3 rd, vec3 po, vec3 pn){//intersection entre un plan et un rayon\n    float d =dot(rd,pn);\n    if(abs(d)<1e-4)\n        return -1.;\n  \treturn dot(po-ro,pn)/d;//renvoie juste la distance\n}\n\nfloat iRec(vec3 ro, vec3 rd, vec3 po, vec3 pn,vec2 dim, vec3 vert){//intersection entre un rectangle et un rayon\n    vec3 horiz = cross(pn,vert);\n\tfloat d =iPlane( ro,  rd,  po,  pn); //on calcule l'intersection avec le plan contenant le rectangle\n    if(d>0.){\n    \tvec3 p = ro+d*rd-po;\n    \tif(abs(dot(p,horiz))>dim.x || abs(dot(p,vert))>dim.y) //on verifie si on est effectivement a l'interieur du rectangle\n    \t\treturn 1e6;\n     }else\n     \treturn 1e6;\n    return d;\n}\n\nvec2 rli(vec3 o1, vec3 d1, vec3 o2, vec3 d2){ //intersection entre deux rayons(demi-droites)\n\tvec3 n = normalize(cross(d1,d2));\n    float md = dot(o1-o2,n);\n    o1 = o1-md*n;\t\t\t\t\t//o1 projeté dans le plan passant par o2\n    vec3 dt = normalize(cross(d1,n)); //\"transposée\" de d1 dans le plan induit par d1,d2 \n    float d = (dot(dt,o1))/dot(dt,d2);\n    return vec2(abs(md)*d,abs(md)<d && dot(cross(d2,n),o1)>0.?d:1e6); //renvoie la distance minimale entre les deux rayons ainsi que la distance parcourue par le deuxieme rayon avant ce point\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = 2.*fragCoord-iResolution.xy;\n    \n    float vFov = 1.5;\t\t\t//pas réellement le Fov, mais des les variables \"vFov\" et \"Fov\" permettent d'influer sur l'angle\n   \tfloat Fov = 1.5;\t\t\t//de la caméra virtuelle et de la caméra principale respectivement\n    \n    vec3 ro = vec3(0,0,0);\t\t\t\t\t\t\t//origine des rayons = position de la \"camera\"\n    vec3 rd = normalize(vec3(uv,iResolution.y*Fov));//direction du rayon\n\n\n\t\n    vec3 ld = normalize(vec3(1,1,-1));//direction de la lumiere\n    vec3 c = vec3(1);  //couleur temporaire (avcant gestion de la lumuiere\n    \n    \n    vec3 spp = vec3(-3,1.1,8);//position de la sphere\n    float spr = .8;//rayon de la sphere\n    \n    vec4 isph = iSphere(spp,spr,ro,rd);//sphere\n    vec3 n = isph.rgb;\n    float d = isph.a;//distance a l'objet le plus proche le long du rayon en cours\n \n    \n    float ipl = iPlane(ro,rd,vec3(0,-.5,0),normalize(vec3(0,1,0))); //sol\n    if(ipl<d && ipl>0.){\n        n = normalize(vec3(0,1,0));\n    \td=ipl;\n    }\n    \n    \n    vec3 so = vec3(1.3,.6+.2*cos(iTime*.9),4.);\t//position du centre de l'\"ecran\"\n    so.xz+=.8*vec2(cos(iTime*.4),sin(iTime*.4));//animation\n    vec3 sn = normalize(so-vec3(.35,.44,6.6));\t//orientation de l'\"ecran\"\n    vec3 ro2 = so+sn*vFov;\t\t\t\t\t\t//position de la \"camera\" viruelle\n    vec3 vert = normalize(vec3(0,1,0));\t\t\t//orientation de la verticale de l'écran \n    vert =normalize(vert-dot(sn,vert)*sn);\t\t//correction de la verticale pour qu'elle soit orthogonale a la direction de l'ecran\n    vec2 format=vec2(1.6,.9);\t\t\t\t\t//dimension de l'ecran\n    \n    float ir = iRec(ro,rd,so,sn,format,vert); \t//\"ecran\"\n    if(ir<d && ir>0.){\n        n = sn;\n    \td=ir;\n        vec3 ro = d*rd;\n        vec3 rd2 = normalize(ro-ro2);\n        vec4 isph = iSphere(spp,spr,ro,rd2); //encore la sphere\n    \tvec3 n = isph.rgb;\n    \tfloat d = isph.a;\n \n    \n    \tfloat ipl = iPlane(ro,rd2,vec3(0,-.5,0),normalize(vec3(0,1,0)));//encore le sol\n    \tif(ipl<d && ipl>0.){\n        \tn = normalize(vec3(0,1,0));\n    \t\td=ipl;\n    \t}\n        float l =(iSphere(spp,spr,ro+d*rd2,ld).a>=1e6?max(0.,dot(ld,n)):0.);//lumiere directe\n    \tc = mix(vec3(.4+l),vec3(.5,.7,1.),float(d>1e5));//affichage de la scene sur l'\"ecran\" secondaire\n    }\n    \n\n    \n    vec4 io =iSphere(so+sn*vFov,.03,ro,rd); //camera (bille noire)\n    if(io.a<d){\n        n = io.rgb;\n    \td=io.a;\n        c = vec3(.1);\n    }\n   \n    \n    vec3 p =ro+(d-1e-5)*rd;\n    float sh = min(iSphere(spp,spr,p,ld).a,min( iRec(p,ld,so,sn,format,vert),iSphere(so+sn*vFov,.03,p,ld).a));\n    float l =(sh>=1e6?max(0.,dot(ld,n)):0.);//limiere directe\n    \n    vec3 col =  mix(c*vec3(.4+l),vec3(.5,.7,1.),float(d>1e5));//application de l'eclairage \n\n    \n   \tfloat epsilon = 2./(iResolution.y*Fov);//antialiasing\n\n    vec2 itsc=(rli(ro2,normalize(ro2-spp-vec3(3,1,0)),ro,rd)); // le rayon qui n'intersecte pas la scène\n    if(itsc.y<d && itsc.y>0.){\n        col=mix(col,vec3(1,0,0),smoothstep(.05+epsilon*itsc.y*itsc.y,.05,itsc.x));\n        d=mix(d,itsc.y,step(itsc.x,.06));\n    }\n\n    itsc=(rli(ro2,normalize(ro2-spp+.3),ro,rd));//le rayon qui intersecte la sphère\n    if(itsc.y<d && itsc.y>0.){\n        col=mix(col,vec3(0,1,0),smoothstep(.05+epsilon*itsc.y*itsc.y,.05,itsc.x));\n        d=mix(d,itsc.y,step(itsc.x,.06));\n    }\n\n    vec3 horiz = cross(sn,vert);\t//et les quatre coins\n    itsc=(rli(ro2,normalize(ro2-so+format.x*horiz+format.y*vert),ro,rd));\n    if(itsc.y<d && itsc.y>0.){\n        col=mix(col,vec3(.4,.45,1),smoothstep(.05+epsilon*itsc.y*itsc.y,.05,itsc.x));\n        d=mix(d,itsc.y,step(itsc.x,.06));\n    }\n    itsc=(rli(ro2,normalize(ro2-so-format.x*horiz+format.y*vert),ro,rd));\n    if(itsc.y<d && itsc.y>0.){\n        col=mix(col,vec3(.4,.45,1),smoothstep(.05+epsilon*itsc.y*itsc.y,.05,itsc.x));\n        d=mix(d,itsc.y,step(itsc.x,.06));\n    }\n    itsc=(rli(ro2,normalize(ro2-so+format.x*horiz-format.y*vert),ro,rd));\n    if(itsc.y<d && itsc.y>0.){\n        col=mix(col,vec3(.4,.45,1),smoothstep(.05+epsilon*itsc.y*itsc.y,.05,itsc.x));\n        d=mix(d,itsc.y,step(itsc.x,.06));\n    }\n    itsc=(rli(ro2,normalize(ro2-so-format.x*horiz-format.y*vert),ro,rd));\n    if(itsc.y<d && itsc.y>0.){\n        col=mix(col,vec3(.4,.45,1),smoothstep(.05+epsilon*itsc.y*itsc.y,.05,itsc.x));\n        d=mix(d,itsc.y,step(itsc.x,.06));\n    }\n    \n    \n    col = pow(col*.6,vec3(1./2.24));//correction gamma\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Wtl3DH.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 94, 94, 335], [376, 376, 425, 465, 586], [588, 588, 655, 700, 1061], [1063, 1063, 1108, 1155, 1607], [1609, 1609, 1666, 1666, 6036]], "test": "ok"}
{"id": "Wtl3R4", "name": "electron1", "author": "RaduBT", "description": "Created by gopher in 2013-02-25\n\nhttps://www.shadertoy.com/view/MslGRn\nquick glsl port of an effect used in a 4k from 2007.\nuse mouse to rotate (x) and zoom (y)", "tags": ["glsl", "electron"], "likes": 4, "viewed": 406, "published": "Public API", "date": "1555761179", "time_retrieved": "2021-10-01T00:00:00", "image_code": "////////////////////////////////////////////////////////////////////////////////////////\n// INFO:\n// - use the mouse to navigate (x is rotation, y is zoom)\n// - play with the defines below to change the visuals\n////////////////////////////////////////////////////////////////////////////////////////\n\n// the more slices the slower\n#define SLICES \t\t\t50.0\n// start amplitude for the noise\n#define START_AMPLITUDE\t0.01\n// start frequency for the noise\n#define START_FREQUENCY\t1.25\n// start density value\n#define START_DENSITY\t0.01\n// animation speed\n#define ANIMATION_SPEED 0.075\n\n////////////////////////////////////////////////////////////////////////////////////////\n// iq's 3d noise functions from the elevated shader (incl. modifications where needed)\n////////////////////////////////////////////////////////////////////////////////////////\n\n// rotation matrix for fbm octaves\nmat3 m = mat3( 0.00,  0.80,  0.60,\n              -0.80,  0.36, -0.48,\n              -0.60, -0.48,  0.64 );\n\nfloat hash( float n )\n{\n    return fract(sin(n)*43758.5453123);\n}\n\n// 3d noise function\nfloat noise( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n    float n = p.x + p.y*57.0 + 113.0*p.z;\n    float res = mix(mix(mix( hash(n+  0.0), hash(n+  1.0),f.x),\n                        mix( hash(n+ 57.0), hash(n+ 58.0),f.x),f.y),\n                    mix(mix( hash(n+113.0), hash(n+114.0),f.x),\n                        mix( hash(n+170.0), hash(n+171.0),f.x),f.y),f.z);\n    return res;\n}\n\n// fbm noise for 2-4 octaves including rotation per octave\nfloat fbm( vec3 p )\n{\n    float f = 0.0;\n    f += 0.5000*noise( p );\n\tp = m*p*2.02;\n    f += 0.2500*noise( p ); \n// set to 1 for 2 octaves\t\n#if 0\t\n\treturn f/0.75;\n#else\t\n\tp = m*p*2.03;\n    f += 0.1250*noise( p );\n// set to 1 for 3 octaves, 0 for 4 octaves\t\n#if 1\t\n\treturn f/0.875;\n#else\t\n\tp = m*p*2.01;\n    f += 0.0625*noise( p );\n    return f/0.9375;\n#endif\t\n#endif\t\n}\n\n////////////////////////////////////////////////////////////////////////////////////////\n\n// color gradient\nvec3 gradient(float s)\n{\n\treturn vec3(22.0, max(1.0-s*2.0, 0.0), max(s>0.5?1.0-(s-0.15)*5.0:21.0, 1.0));\n}\n\n// intersection for a sphere with a ray\n#define RADIUS 0.5\nbool intersectSphere(vec3 origin, vec3 direction, out float tmin, out float tmax)\n{\n    bool hit = false;\n\tfloat a = dot(direction, direction);\n    float b = 2.0*dot(origin, direction);\n    float c = dot(origin, origin) - 0.5*0.5;\n    float disc = b*b - 4.0*a*c;           // discriminant\n    tmin = tmax = 0.0;\n\n    if (disc > 0.0) {\n        // Real root of disc, so intersection\n        float sdisc = sqrt(disc);\n        float t0 = (-b - sdisc)/(2.0*a);          // closest intersection distance\n        float t1 = (-b + sdisc)/(2.0*a);          // furthest intersection distance\n\n\t\ttmax = t1;\n        if (t0 >= 0.0) \n            tmin = t0;\n        hit = true;\n    }\n\n    return hit;\n}\n\n// rotate around axis\nvec2 rt(vec2 x,float y)\n{\n\treturn vec2(cos(y)*x.x-sin(y)*x.y,sin(y)*x.x+cos(y)*x.y);\n}\n\n// shader main function\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\t// normalized and aspect ratio corrected pixel coordinate\n    vec2 p = (fragCoord.xy / iResolution.xy)*2.0-1.0;\n    p.x *= iResolution.x/ iResolution.y*2.0;\n    p.y *= iResolution.x/ iResolution.y*2.0;\n\n\t// camera and user input\n\tvec3 oo = vec3(0, 0, 0.4-iMouse.y/iResolution.y);\n\tvec3 od = normalize(vec3(p.x, p.y, -2.0));\n\tvec3 o,d;\t\n\to.xz = rt(oo.xz, 6.3*iMouse.x/iResolution.x);\n\to.y = oo.y;\n\td.xz = rt(od.xz, 6.3*iMouse.x/iResolution.x);\n\td.y = od.y;\n\n\t// render\n\tvec4 col = vec4(0, 0, 0, 0);\n\tfloat tmin, tmax;\n\tif (intersectSphere(o, d, tmin, tmax))\n\t{\t\n\t\t// step thoug the sphere with max SLICES steps\n\t\tfor (float i = 0.0; i < SLICES; i+=1.0)\n\t\t{\n\t\t\t// stay within the sphere bounds\n\t\t\tfloat t = tmin+i/SLICES;\n\t\t\tif (t > tmax) \n\t\t\t\tbreak;\n\t\t\tvec3 curpos = o + d*t;\n\t\t\t\n\t\t\t// get sphere falloff in s\n\t\t\tfloat s = (0.5-length(curpos))*2.0;\n\t\t\ts*=s;\n\n\t\t\t// get turbulence in d\n\t\t\tfloat a = START_AMPLITUDE;\n\t\t\tfloat b = START_FREQUENCY;\n\t\t\tfloat d = START_DENSITY;\n\t\t\tfor (int j = 0; j < 3; j++)\t\t\t\t\t\t\t\t\t\n\t\t\t{\n\t\t\t\td += 0.5/abs((fbm(5.0*curpos*b+ANIMATION_SPEED*iTime/b)*2.0-1.0)/a);\n\t\t\t\tb *= 2.0;\n\t\t\t\ta /= 2.0;\n\t\t\t}\n\t\t\t\n\t\t\t// get gradient color depending on s\n\t\t\tcol.rgb += gradient(s)*max(d*s,0.0);\n\t\t}\t\t\n\t}\n\n\tfragColor = col;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Wtl3R4.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[987, 987, 1010, 1010, 1052], [1054, 1075, 1101, 1101, 1503], [1505, 1564, 1585, 1585, 1933], [2025, 2043, 2067, 2067, 2149], [2210, 2210, 2293, 2293, 2897], [2899, 2921, 2946, 2946, 3007], [3009, 3033, 3090, 3149, 4328]], "test": "ok"}
{"id": "wtl3R8", "name": "Uranium snot", "author": "avin", "description": "liquid + little backlight", "tags": ["glow", "glow", "liquid", "neon"], "likes": 5, "viewed": 510, "published": "Public API", "date": "1555663187", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define COUNT 5.\n#define COL1 vec3(31, 29, 28)/255.\n#define COL2 vec3(6, 243, 5)/255.\n\n#define rand1(p) fract(sin(p* 78.233)* 43758.5453) \n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{    \n    vec2 uv = (fragCoord - iResolution.xy*.5)/iResolution.y;        \n    \n    float sum = 0.;  \n    float sumG = 0.; //for GLOW\n    \n    for(float i=0.; i<COUNT; i++){\n        float dir = mod(i, 2.)*2.-1.;        \n        float a = iTime + i + rand1(i) * 3.1415;\n        float l = length(vec2(uv.x+sin(a)*.25*dir, uv.y+cos(a*.5)*.25)*dir);\n    \t\n        sum+=.03/l;\n        sumG+=.0275/l;\n    }        \n    sumG-=0.5;\n              \n    float fd = smoothstep(.7425, .75,  sum);\n    \n    vec3 col = mix(COL1, COL2, clamp(fd + sumG*3.0, 0., 1.));\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtl3R8.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[140, 140, 197, 197, 784]], "test": "ok"}
{"id": "wtl3zM", "name": "190501_noodle", "author": "omeometo", "description": "test", "tags": ["raymarch"], "likes": 16, "viewed": 345, "published": "Public", "date": "1556641645", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec3 rand3(vec3 p){\n    vec3 q=vec3(\n        p.x*41.839+p.y*91.793+p.z*23.418,\n        p.x*54.941+p.y*73.694+p.z*48.932,\n        p.x*14.023+p.y*10.089+p.z*83.573\n    );\n\treturn fract(sin(q+0.25)*2434.2434)*2.0-1.0;\n}\n\nvec3 smth3(vec3 f){\n\treturn f*f*f*(10.+f*(-15.+f*6.));\n}\nvec3 dsmth3(vec3 f){\n\treturn 30.*(f*f*(1.+f*(-2.+f)));\n}\n/*\nfloat noise(vec3 p){\n\tvec3 i=floor(p);\n    vec3 f=fract(p);\n    vec3 u=smth3(f);\n    vec3 du=dsmth3(f);\n    \n    vec3 g000=rand3(i+vec3(0.0, 0.0, 0.0));\n    vec3 g001=rand3(i+vec3(0.0, 0.0, 1.0));\n    vec3 g010=rand3(i+vec3(0.0, 1.0, 0.0));\n    vec3 g011=rand3(i+vec3(0.0, 1.0, 1.0));\n    vec3 g100=rand3(i+vec3(1.0, 0.0, 0.0));\n    vec3 g101=rand3(i+vec3(1.0, 0.0, 1.0));\n    vec3 g110=rand3(i+vec3(1.0, 1.0, 0.0));\n    vec3 g111=rand3(i+vec3(1.0, 1.0, 1.0));\n    float a000=dot(g000, f-vec3(0.0, 0.0, 0.0));\n    float a001=dot(g001, f-vec3(0.0, 0.0, 1.0));\n    float a010=dot(g010, f-vec3(0.0, 1.0, 0.0));\n    float a011=dot(g011, f-vec3(0.0, 1.0, 1.0));\n    float a100=dot(g100, f-vec3(1.0, 0.0, 0.0));\n    float a101=dot(g101, f-vec3(1.0, 0.0, 1.0));\n    float a110=dot(g110, f-vec3(1.0, 1.0, 0.0));\n    float a111=dot(g111, f-vec3(1.0, 1.0, 1.0));\n   \n    return mix(\n        mix(mix(a000, a001, u.z), mix(a010, a011, u.z), u.y), \n        mix(mix(a100, a101, u.z), mix(a110, a111, u.z), u.y), u.x); \n}\n*/\n\nvoid noisewithgrad3(out float val, out vec3 grad, in vec3 p){\n\tvec3 i=floor(p);\n    vec3 f=fract(p);\n    vec3 u=smth3(f);\n    vec3 du=dsmth3(f);\n    \n    vec3 g000=rand3(i+vec3(0.0, 0.0, 0.0));\n    vec3 g001=rand3(i+vec3(0.0, 0.0, 1.0));\n    vec3 g010=rand3(i+vec3(0.0, 1.0, 0.0));\n    vec3 g011=rand3(i+vec3(0.0, 1.0, 1.0));\n    vec3 g100=rand3(i+vec3(1.0, 0.0, 0.0));\n    vec3 g101=rand3(i+vec3(1.0, 0.0, 1.0));\n    vec3 g110=rand3(i+vec3(1.0, 1.0, 0.0));\n    vec3 g111=rand3(i+vec3(1.0, 1.0, 1.0));\n    float a000=dot(g000, f-vec3(0.0, 0.0, 0.0));\n    float a001=dot(g001, f-vec3(0.0, 0.0, 1.0));\n    float a010=dot(g010, f-vec3(0.0, 1.0, 0.0));\n    float a011=dot(g011, f-vec3(0.0, 1.0, 1.0));\n    float a100=dot(g100, f-vec3(1.0, 0.0, 0.0));\n    float a101=dot(g101, f-vec3(1.0, 0.0, 1.0));\n    float a110=dot(g110, f-vec3(1.0, 1.0, 0.0));\n    float a111=dot(g111, f-vec3(1.0, 1.0, 1.0));\n   \n    val = mix(\n        mix(mix(a000, a001, u.z), mix(a010, a011, u.z), u.y), \n        mix(mix(a100, a101, u.z), mix(a110, a111, u.z), u.y), u.x); \n    grad = mix(\n        mix(mix(g000, g001, u.z), mix(g010, g011, u.z), u.y), \n        mix(mix(g100, g101, u.z), mix(g110, g111, u.z), u.y), u.x); \n    grad += du * vec3(\n    \tmix(mix(a100-a000, a101-a001, u.z), mix(a110-a010, a111-a011, u.z), u.y),\n    \tmix(mix(a010-a000, a011-a001, u.z), mix(a110-a100, a111-a101, u.z), u.x),\n    \tmix(mix(a001-a000, a011-a010, u.y), mix(a101-a100, a111-a110, u.y), u.x)\n    );\n}\n\n\nfloat dist(out vec3 grad, in vec3 p){\n\t//float val1=sqrt(dot(p,p))-1.0;\n    //vec3 g1=normalize(p);\n    float val1, val2;\n    vec3 g1, g2;\n    float r=2.0;\n    noisewithgrad3(val1, g1, p*r+iTime*vec3(0.0, 1.0, 0.0));\n    noisewithgrad3(val2, g2, p*r-iTime*vec3(0.0, 1.0, 0.0)-0.5);\n    g1*=r;\n    g2*=r;\n    \n\tfloat a=dot(g1,g1), b=dot(g1,g2);\n    float c=dot(g2,g1), d=dot(g2,g2);\n    float det=a*d-b*c;\n    float x=(d*val1-b*val2)/det;\n    float y=(-c*val1+a*val2)/det;\n    vec3 g=g1*x+g2*y;\n    grad=normalize(g);\n    return min(0.1, sqrt(dot(g,g))-0.01)*0.5;\n\t//return sqrt(val1*val1+val2*val2)*0.5-0.007;\n}\n\n\nvoid getColor(out vec4 fragColor, in vec3 pos, in vec3 ray){\n\tfloat col = 0.0;\n    float col_cur = 1.0;\n    for(int i=0;i<64;i++){\n        vec3 grad;\n    \tfloat d = dist(grad, pos);\n        if(d<1e-3){\n        \tfloat eps=1e-2;\n            /*\n            vec3 normal=vec3(\n            \tdist(pos + vec3(eps, 0.0, 0.0)) - dist(pos - vec3(eps, 0.0, 0.0)),\n            \tdist(pos + vec3(0.0, eps, 0.0)) - dist(pos - vec3(0.0, eps, 0.0)),\n            \tdist(pos + vec3(0.0, 0.0, eps)) - dist(pos - vec3(0.0, 0.0, eps))\n            );\n            normal = normalize(normal);\n            */\n            vec3 normal=grad;\n\t\t\tvec3 op_ray_dir = -normalize(ray);\n\t\t\tcol=col_cur * max(dot(normal, op_ray_dir), 0.5);\n            //col=col_cur;\n            break;\n        }\n        pos += d * ray;\n        col_cur -=1./64.;\n    }\n    fragColor = vec4(vec3(col), 1.0);    \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord){\n\tvec2 uv = ( fragCoord*2.-iResolution.xy ) / iResolution.y;\n\n\n    vec3 pos = vec3(0.0, 0.0, 2.0); //vec3(cos(iTime)*3.0, 0.0, sin(iTime)*3.0);\n    vec3 eye = vec3(0.0, 0.0, -1.0); //-normalize(pos);\n    vec3 up = vec3(0.0, 1.0, 0.0);\n    vec3 right = cross(eye, up);\n    float angle = 0.5;\n    vec3 ray = eye + (right * uv.x + up * uv.y) * angle;\n    ray = normalize(ray);\n    \n\tgetColor(fragColor, pos, ray);\n}\n\nvoid mainVR( out vec4 fragColor, in vec2 fragCoord, in vec3 fragRayOri, in vec3 fragRayDir )\n{\n\tgetColor(fragColor, fragRayOri, fragRayDir);\n}\n\n/*\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Time varying pixel color\n    vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}\n*/", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtl3zM.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 19, 19, 216], [218, 218, 237, 237, 274], [275, 275, 295, 295, 331], [1346, 1346, 1407, 1407, 2806], [2809, 2809, 2846, 2908, 3420], [3423, 3423, 3483, 3483, 4279], [4281, 4281, 4336, 4336, 4748], [4750, 4750, 4844, 4844, 4892]], "test": "ok"}
{"id": "Wtl3zN", "name": "Raymarching Shapes", "author": "batman", "description": "This is my first cube and first positioning in raymarching. Second time I coded it, making progress as I got this result in 40min.", "tags": ["basic"], "likes": 4, "viewed": 370, "published": "Public", "date": "1555803071", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define ITERATIONS 1000\n#define MIN_D 0.0001\n#define MAX_D 30.\n\n// collection of distances to each object.\nfloat distS[10];\n\n// adapted from http://www.neilmendoza.com/glsl-rotation-about-an-arbitrary-axis/\nvec3 rotation(vec3 point, vec3 axis, float angle){\n    axis = normalize(axis);\n    float s = sin(angle);\n    float c = cos(angle);\n    float oc = 1.0 - c;\n    \n    mat4 rot= mat4(oc * axis.x * axis.x + c, oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s,  0.0,\n                oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,oc * axis.y * axis.z - axis.x * s,  0.0,\n                oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c,           0.0,\n                0.0,0.0,0.0,1.0);\n    return (rot*vec4(point,1.)).xyz;\n}\n\n/*\n Collection of signed distance functions.\n\n*/\n// signed distance to a sphere\nfloat sdSphere( vec3 p, float r) {\n \treturn length(p) -r;   \n}\n\n// signed distance to the plan y=0\nfloat sdPlan(vec3 p) {\n    return abs(p.y);\n}\n\n// signed distance to a cube of dimension b\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return length(max(d,0.0));\n}\n\n// compute distance to each object and returns the minimum (aka the distance to each object)\nfloat sdScene(vec3 pos) {\n    vec3 cubePos = rotation(pos - vec3(0.,1.,-3.5), vec3(0.,.5,0.5), iTime);\n    distS[0] = sdSphere(pos-vec3(.5,.5,-5.), 1.);\n    distS[1] = sdPlan(pos);\n    distS[2] = sdBox(cubePos, vec3(.5,.6,.5));\n    distS[3] = sdBox(pos - vec3(2.,0.,-3.), vec3(.5,.6,.5));\n    int oid = 0;\n    float d = distS[0];\n    for(int i=1;i<=3;i++) {\n        if(distS[i] < d) {\n          oid = i;\n          d = distS[i];\n        }\n    }\n\treturn d;\n}\n\n// raymarch algorithm\nfloat rayMarch(vec3 ro, vec3 rd) {\n\tvec3 pos = ro;\n    float inc = 0.;\n    float d = 0.;\n    for(int i=0;i<ITERATIONS;i++) {\n    \tpos = ro + d*rd;\n        inc = sdScene(pos);\n        d += inc;\n        if(inc < MIN_D || d > MAX_D) break;\n    }\n    return d;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    uv -=0.5;\n    uv.x *= iResolution.x/iResolution.y;\n    // basic cam\n    vec3 camPos = vec3(0.,1.,0.);\n    vec3 ro = camPos + vec3(0.,0.,1.);\n    vec3 rd = normalize(camPos+ vec3(uv, 0.) - ro);\n    \n    float d = rayMarch(ro, rd);\n    // here I only display the distance, not trying to shade with normal and light vectors.\n    vec3 col = vec3(smoothstep(MAX_D,0.,pow(d-1.,2.)));\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Wtl3zN.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[125, 207, 257, 257, 808], [810, 890, 924, 924, 952], [954, 989, 1011, 1011, 1034], [1036, 1080, 1111, 1111, 1165], [1167, 1260, 1285, 1285, 1716], [1718, 1740, 1774, 1774, 1998], [2000, 2000, 2057, 2057, 2512]], "test": "ok"}
{"id": "WtlGWr", "name": "dice field", "author": "tauli", "description": "My first raymarching shader. Thanks so much to flopine and evvvvil for their great shader coding seminar at revision 2019. https://www.youtube.com/watch?v=uFFR31t1WMM", "tags": ["raymarching", "dice"], "likes": 5, "viewed": 369, "published": "Public API", "date": "1556062941", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//ACME Labs rainbow colors\nvec3[ 5] rbow = vec3[5]\n  ( vec3(1., .0  , 0.)\n  , vec3(1., .553, 0.)\n  , vec3(1., .859, 0.)\n  , vec3(0., .839,  .098)\n  , vec3(0., .624, 1.)\n  );\n\n// positions of all the dimples in the dice\nvec3[21] dips = vec3[21]\n  // one\n  ( vec3( 0.,    0.,    0.31)\n  // two\n  , vec3( 0.31,  0.15,  0.15)\n  , vec3( 0.31, -0.15, -0.15)\n  // three\n  , vec3( 0.15,  0.31,  0.15)\n  , vec3( 0.,    0.31,  0.  )\n  , vec3(-0.15,  0.31, -0.15)\n  // four\n  , vec3( 0.15, -0.31,  0.15)\n  , vec3(-0.15, -0.31,  0.15)\n  , vec3( 0.15, -0.31, -0.15)\n  , vec3(-0.15, -0.31, -0.15)\n  // five\n  , vec3(-0.31,  0.,    0.  )\n  , vec3(-0.31, -0.15, -0.15)\n  , vec3(-0.31, -0.15,  0.15)\n  , vec3(-0.31,  0.15, -0.15)\n  , vec3(-0.31,  0.15,  0.15)\n  // six\n  , vec3( 0.15, -0.15, -0.31)\n  , vec3( 0.15,  0.,   -0.31)\n  , vec3( 0.15,  0.15, -0.31)\n  , vec3(-0.15, -0.15, -0.31)\n  , vec3(-0.15,  0.,   -0.31)\n  , vec3(-0.15,  0.15, -0.31)\n  );\n\nvec3 rotate (vec3 p, vec3 r) {\n  mat3x3 rotX = mat3x3(\n    1, 0,         0,\n    0, cos(r.x), -sin(r.x),\n    0, sin(r.x), cos(r.x)\n  );\n  mat3x3 rotY = mat3x3(\n    cos(r.y),  0, sin(r.y),\n    0,         1, 0,\n    -sin(r.y), 0, cos(r.y)\n  );\n  mat3x3 rotZ = mat3x3(\n    1, 0,         0,\n    0, cos(r.z), -sin(r.z),\n    0, sin(r.z), cos(r.z)\n  );\n  return rotX * rotY * rotZ * p;\n}\n\nfloat sphere (vec3 p, float radius) {\n  return length(p) - radius ;\n}\n\nfloat box (vec3 p, vec3 c) {\n  vec3 q = abs(p) - c;\n  return min(0., max(q.x, max(q.y,q.z))) - 0.02 + length(max(q,0.));\n}\n\nfloat map (vec3 p) {\n  vec3 b = floor(mod(p, 15.) / 3.);\n  p = mod(p, 3.) - 1.5;\n\n  // rotate each dice a bit differently\n  p = rotate(p, vec3(iTime * 0.3 + b.x, iTime * 0.7 + b.y, iTime * 0.111 + b.z));\n  float s = sphere(p, 0.45);\n  float c = box(p,vec3(0.29));\n  float dice = max(s,c);\n  \n  //short circuting for better performance\n  if (dice > 0.001) return dice;\n \n  float d = sphere(p + dips[0], 0.06);\n  for (int i = 1; i <= 21; i++) {\n    d = min(d, sphere(p + dips[i], 0.06));\n  }\n  return max(dice, -d);\n}\n\nvec3 get_normal (vec3 p) {\n  vec2 eps = vec2(0.0001, 0.);\n  return normalize( vec3(\n    map(p+eps.xyy) - map(p-eps.xyy),\n    map(p+eps.yxy) - map(p-eps.yxy),\n    map(p+eps.yyx) - map(p-eps.yyx)\n  ) );\n}\n\nfloat diffuse (vec3 n, vec3 l) {\n   return dot(n, normalize(l))*.5+.5;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2 uv = vec2(gl_FragCoord.x / iResolution.x, gl_FragCoord.y / iResolution.y);\n  uv -= 0.5;\n  uv /= vec2(iResolution.y / iResolution.x, 1);\n  \n  //mat2x2 rot = mat2x2(cos(time),-sin(time),sin(time),cos(time));\n  //uv = rot * uv;\n  \n  //vec3 ro = vec3(.0, .0, -3.0);\n  vec3 ro = vec3(mod(iTime * 2.5,15.), sin(iTime * 0.5)*1.5, -3.0);\n  vec3 p = ro;\n  vec3 rd = normalize (vec3(uv,1.));\n  float shad = 0.;\n  bool hit = false;\n  \n  for (float i = 0.; i < 100.; i++) {\n    float d = map(p);\n    if (d < 0.001) {\n      shad = 1. - i / 100.;\n      hit = true;\n      break;\n    }\n    p += d * rd;\n    if (p.z > 21.) break;\n  }\n  \n  float t = length(ro-p);\n  \n  vec3 color;\n  if (hit) {\n    vec3 n = get_normal(p);\n    vec3 l = vec3(.5, 2., -2.);\n    int boxNum = int(mod(floor(p.x / 3. + p.y / 3. + p.z / 3.),5.));\n \n    vec3 b = floor(mod(p, 15.) / 3.);\n    p = mod(p, 3.) - 1.5;\n    p = rotate(p, vec3(iTime * 0.3 + b.x, iTime * 0.7 + b.y, iTime * 0.111 + b.z));\n    float d = sphere(p + dips[0], 0.06);\n    for (int i = 1; i <= 21; i++) {\n      d = min(d, sphere(p + dips[i], 0.06));\n    }\n    if (d < 0.001) { color = vec3(0.3,0.3,0.3); }\n    else           { color = rbow[boxNum]; }\n\n    color = mix(color, color * 0.5, vec3(diffuse(n,l)));\n  }\n  else {color = vec3(.0);}\n  color = mix(color, vec3(.15,.15,.3), 1. - exp(-.005*t*t));\n  \n  fragColor = vec4(color, 1);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WtlGWr.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[938, 938, 968, 968, 1316], [1318, 1318, 1355, 1355, 1387], [1389, 1389, 1417, 1417, 1511], [1513, 1513, 1533, 1533, 2028], [2030, 2030, 2056, 2056, 2232], [2234, 2234, 2266, 2266, 2306], [2308, 2308, 2365, 2365, 3735]], "test": "ok"}
{"id": "wtlGzN", "name": "Mandelbrot Test [lvachon]", "author": "lvachon", "description": "I wanted to see how much faster this was on the GPU.  ", "tags": ["fractal", "mandelbrot"], "likes": 1, "viewed": 53, "published": "Public", "date": "1555812357", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 z = vec2(0,0);\n    vec2 nz = vec2(0,0);\n    float timeStuffC = (1.0/(iTime*iTime*iTime));\n    vec2 c = (0.0000001+2.0 * timeStuffC) * (uv-vec2(0.5,0.50))+vec2(-0.761574*(1.0-timeStuffC),-0.0847596 *(1.0-timeStuffC)).xy;\n\tfloat iter=0.0;\n    for(iter=0.0; iter<1.0 && z.x < 2.0 && z.x > -2.0 && z.y < 2.0 && z.y > -2.0 ; iter+=0.0025){\n       nz.x = (z.x*z.x) - (z.y*z.y);// + c.x;\n       nz.y = (z.x*z.y) + (z.y*z.x);// + c.y;\n       z.x = nz.x+c.x;\n       z.y = nz.y+c.y;\n        //z=z+c;\n    }\n    // Time varying pixel color\n    //vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n\n    // Output to screen\n    fragColor = vec4(1.0-cos(6.28*iter),sin(6.28*iter),1.0-iter,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtlGzN.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 107, 839]], "test": "ok"}
{"id": "Wts3DN", "name": "Digamma function domain coloring", "author": "tpfto", "description": "Domain coloring plot of the digamma function, the logarithmic derivative of the gamma function (cf. https://www.shadertoy.com/view/WtlGDN)", "tags": ["2d", "math", "complex", "domaincoloring", "specialfunctions"], "likes": 5, "viewed": 115, "published": "Public", "date": "1556647561", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// The MIT License\n// Copyright © 2019 J. M.\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// Basic domain coloring plot (https://en.wikipedia.org/wiki/Domain_coloring)\n// of the digamma/psi function w = ψ(z) (https://en.wikipedia.org/wiki/Digamma_function)\n\n#define PI 3.14159265359\n#define SCALE 5.0 // plot scale\n#define SPACING 0.0625 // grid line spacing\n\n// Constants for gamma function approximation\n\n#define LG 4.15\n#define P0 2.506628464366\n#define P1 41.41740453024\n#define P2 -27.0638924937\n#define P3 2.239317963303\n\n// from Fabrice Neyret, \n#define cmul(A,B) ( mat2( A, -(A).y, (A).x ) * (B) )\n#define cinv(Z) ( vec2( (Z).x, -(Z).y ) / dot(Z, Z) ) \n#define cdiv(A,B) cmul( A, cinv(B) )\n#define csqr(Z) cmul(Z, Z)\n\n// Schlick bias function, from http://dept-info.labri.u-bordeaux.fr/~schlick/DOC/gem2.ps.gz\nfloat bias( float a, float x )\n{\n    return x/((1.0/a - 2.0) * (1.0 - x) + 1.0);\n}\n\n// biased sawtooth\nfloat my_saw( float x, float p )\n{\n    float xs = mod(x, 1.0);\n    float xh = clamp(xs, 0.0, p);\n    return 0.5 + 0.5 * bias(0.95, xh) * (1.0 - smoothstep(p, 1.0, xs));\n}\n\n// modified version of Inigo Quilez's method at https://www.shadertoy.com/view/MsS3Wc\n// using \"rational smoothstep\" from https://tpfto.wordpress.com/2019/03/28/on-a-rational-variant-of-smoothstep/\nvec3 smooth_hue( float h )\n{\n    vec3 rgb = clamp( abs(mod(6.0 * h + vec3(0.0, 4.0, 2.0), 6.0) - 3.0) - 1.0, 0.0, 1.0);\n    return rgb * rgb * rgb/(1.0 - 3.0 * rgb * (1.0 - rgb));\n}\n\n// modified DLMF coloring, adapted from https://www.shadertoy.com/view/WtXGWN\nvec3 smooth_dlmf( float h )\n{\n    vec3 rgb = clamp( vec3(1., -1., -1.) * abs((vec3(8., 4., 8.) * mod(h, 1.0) - vec3(4.5, 1.5, 5.5))) + vec3(-1.5, 1.5, 2.5), 0.0, 1.0 );\n\treturn rgb * rgb * rgb/(1.0 - 3.0 * rgb * (1.0 - rgb));\n}\n\n// complex cotangent\n\nvec2 cotz( in vec2 z )\n{\n\treturn vec2(-sin(2.0 * z.x), sinh(2.0 * z.y))/(cos(2.0 * z.x) - cosh(2.0 * z.y));\n}\n\n// complex logarithm\n\nvec2 logz( in vec2 z )\n{\n\treturn vec2(log(length(z)), atan(z.y, z.x));\n}\n\n// digamma function, Lanczos approximation (https://doi.org/10.1137/0701008) with Toth's coefficients (https://www.rskey.org/gamma.htm)\n\nvec2 Psi( in vec2 z )\n{\n    vec2 zz = (z.x > 1.0) ? (z) : (vec2(1.0, 0.0) - z);\n    vec2 sum1 = P1 * csqr(cinv(zz + vec2(1.0, 0.0))) + P2 * csqr(cinv(zz + vec2(2.0, 0.0))) + P3 * csqr(cinv(zz + vec2(3.0,0.0)));\n    vec2 sum2 = vec2(P0, 0.0) + P1 * cinv(zz + vec2(1.0, 0.0)) + P2 * cinv(zz + vec2(2.0, 0.0)) + P3 * cinv(zz + vec2(3.0,0.0));\n    vec2 zh = zz + vec2(LG, 0.0);\n    vec2 w = logz(zh) - cdiv(zh + (LG - 0.5) * zz, cmul(zz, zh)) - cdiv(sum1, sum2);\n\n    return ((z.x > 1.0) ? w : w - PI * cotz(PI * z));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 aspect = iResolution.xy / iResolution.y;\n    vec2 z = ( fragCoord.xy / iResolution.y ) - 0.5 * aspect;\n    z *= SCALE;\n    \n    vec2 w = Psi(z);\n    float ph = atan(w.y, w.x);\n    float lm = log(0.0001 + length(w));\n    \n    vec3 c = vec3(1.0);\n    c = smooth_dlmf(0.5 * (ph / PI));\n    // uncomment for HSV version \n    // c = smooth_hue(0.5 * (ph / PI));\n\n    c *= mix(1.0, my_saw((0.5 * (lm/PI))/SPACING, 0.95) * my_saw((0.5 * (ph / PI))/SPACING, 0.95), 0.5 + 0.5 * cos(iTime));\n    fragColor = vec4(c, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Wts3DN.jpg", "access": "shaders20k", "license": "mit", "functions": [[1708, 1800, 1832, 1832, 1882], [1884, 1903, 1937, 1937, 2073], [2075, 2273, 2301, 2301, 2454], [2456, 2534, 2563, 2563, 2761], [2785, 2785, 2809, 2809, 2894], [2918, 2918, 2942, 2942, 2990], [3129, 3129, 3152, 3152, 3644], [3646, 3646, 3703, 3703, 4226]], "test": "ok"}
{"id": "Wts3W7", "name": "past racer by jetlag", "author": "w23", "description": "A fast partyprod born out of shader showdown scene.\nTook 4th place at PC 4k intro compo at Revision 2019\n\nmusic, direction by keen\n\npouet: https://www.pouet.net/prod.php?which=81016\n\nShader is mostly as is, except for a few weird Windows/ANGLE fixes.", "tags": ["pathtracing", "4kintro", "revision2019"], "likes": 19, "viewed": 570, "published": "Public API", "date": "1556625716", "time_retrieved": "2021-10-01T00:00:00", "image_code": "precision highp float;\nfloat t;\n\nfloat sym(vec2 p, float fs) {\n    vec2 s = vec2(mod(fs,16.), 16.-floor(fs/16.));\n    vec2 tsz = vec2(iChannelResolution[0]), rsz = 1. / tsz;\n    p = (p + vec2(16.,0.) + s*64.)*rsz;\n    return smoothstep(.5, .49, texture(iChannel0, p).a);\n}\n\nbool text_balls = false;\nfloat text(vec2 p) {\n\tif (text_balls) {\n\t\tvec2 cid = floor(p), cc=(p-cid)*2.-1.;\n\t\treturn step(length(cc), .7);\n    } else {\n        p *= .1;\n        p += vec2(.1, .1);\n        p *= vec2(iChannelResolution[0]);\n        vec2 gsz = vec2(16.,64.);\n        vec2 ci = floor(p/gsz), cp = mod(p, gsz);\n#define SYM(a) if (ci.x == 0.) { return sym(cp*vec2(2.,1.), a); } ci.x -= 1.;\n        if (ci.y == 1.) {\n        \tSYM(122.); SYM(117.); SYM(132.); SYM(124.); SYM(113.); SYM(119.);\n        } else if (ci.y == 0.) {\n            SYM(128.); SYM(113.); SYM(131.); SYM(132.); ci.x -= 1.;\n            SYM(130.); SYM(113.); SYM(115.); SYM(117.); SYM(130.);\n        }\n        return 0.;\n    }\n}\n\nconst float PI=3.1415923;\nconst vec3 E=vec3(0.,.01,1.);\n\nfloat hash1(float f){return fract(sin(f)*46347.423874);}\nfloat hash2(vec2 v){return hash1(dot(v,vec2(79.53248,31.4328)));}\n\nfloat noise2(vec2 v) {\n\tvec2 V=floor(v);v-=V;\n\tv*=v*(3.-2.*v);\n\treturn mix(\n\t\tmix(hash2(V+E.xx), hash2(V+E.zx), v.x),\n\t\tmix(hash2(V+E.xz), hash2(V+E.zz), v.x), v.y);\n}\n\nmat3 RX(float a){float c=cos(a),s=sin(a);return mat3(1.,0.,0.,0.,-s,c,0.,c,s);}\nmat3 RY(float a){float c=cos(a),s=sin(a);return mat3(c,0.,s,0.,1.,0.,-s,0.,c);}\nmat3 RZ(float a){float c=cos(a),s=sin(a);return mat3(c,s,0.,-s,c,0.,0.,0.,1.);}\n\nvec3 O, D, P, N;\nvec2 UV;\nint M;\nfloat l;\n\nvoid aapl(float offset, vec3 axis, int mi) {\n\tfloat x = dot(O,axis), rx = dot(D,axis), s = sign(rx);\n\tfloat lp = (s * offset - x) / rx;\n\tif (lp < l) {\n\t\tl = lp;\n\t\tP = O + D * l;\n\t\tN = - s * axis;\n\t\tM = mi;\n\t\tUV = axis.x*P.yz + axis.y*P.xz + axis.z*P.xy;\n\t}\n}\n\nfloat ss(float f){return max(0.,min(1.,f));}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    t = mod(iTime, 120.) * 12.0;\n    vec2 R = iResolution.xy;\n\tvec2 uv=(fragCoord.xy/R)*2.-1.;uv.x*=R.x/R.y;\n    \n    //fragColor=vec4(hash2(uv));return;\n\n\tvec3 c=vec3(0.);\n\tfloat seed = t;\n\n\tfloat tpat = t/32.;\n\n\t////////////// TWEAK THESE\n\tfloat ls = .2, // lens size\n\t\t\t\tlf = 4. + 3.,// * sin(t*.1), // focus distance\n\t\t\t\tlS = 1.; // fov-ish\n\tvec3 sz = vec3(1.5,2.,6.);\n\tfloat or = 4.;\n\tmat3 mv = mat3(1,0,0,0,1,0,0,0,1);\n\t//mv = RY(2.*sin(t*.01))*RY(3.*sin(t*.039));\n\t//mv = RY(2.+sin(t*.05));\n\tfloat text_offset = -2. + 6. * hash1(floor(t/8.));\n\tfloat pscl = 4.;\n\tbool text_plane = false;\n\tbool pix1 = false, pix2 = false;\n\tbool pixmv = false;\n\tbool proj2 = false;\n\tbool proj1 = false;\n\tvec3 bgcolor = .5 * vec3(.3,.5,.8);\n\tfloat zmove = 0.;\n\tvec2 pixmvs = vec2(0.);\n\tfloat pixmvl = 1.;\n\tbool rpix = true;\n\tvec3 rpixc = vec3(0.);\n\tvec3 pixmvc = vec3(1.);\n\tvec3 pix2c = vec3(1.);\n\tvec3 pc = vec3(0.,0.,-6.);\n\n\tsz=vec3(8.);\n\tbgcolor = vec3(0.);\n\tls = 1.;\n\tlf = 4.;\n\trpix = true;\n\trpixc = vec3(tpat/6.);\n\tmv = RY(tpat)*RX(tpat*.3);\n\n\tif (tpat > 6.) {\n\t\tpixmv = true;\n\t\tpixmvs=vec2(1., 0.);\n\t}\n\n\tif (tpat > 9.) {\n\t\tfloat tt=ss(tpat-9.);\n\t\tsz = mix(sz, vec3(1.5,2.,6.), tt);\n\t\tor = mix(or,1.,tt);\n\t\tls = mix(ls,.1,tt);\n\t}\n\n\tif (tpat > 13.6) {\n\t\tfloat tt = smoothstep(13.6, 14., tpat);\n\t\tlS = mix(10., 1., tt);\n\t\tls = mix(4., .1, tt);\n\t\tlf = mix(.1, 7., tt);\n\t\tmv = RZ(1.-tt);\n\t\tzmove = 4.;\n\t}\n\n\tif (tpat > 14.) {\n\t\tmv = RZ(.1*sin(tpat-14.));\n\t}\n\n\tif (tpat > 17.) {\n\t\ttext_plane = true;\n\t\ttext_offset = -6. + 2.*floor(tpat-17.);\n\t}\n\n\tif (tpat > 19.) {\n\t\trpix = false;\n\t}\n\n\tif (tpat > 20.) {\n\t\tpixmv = false;\n\t}\n\n\tif (tpat > 21.8) {\n\t\tfloat tt=smoothstep(21.8, 22., tpat);\n\t\tsz = mix(sz, vec3(4.,1.,-1.), tt);\n\t\tpixmv = true;\n\t}\n\n\tif (tpat > 22.) {\n\t\tmv = RZ(tpat-22.);\n\t\ttext_plane = false;\n\t\tbgcolor = .01 * vec3(.3,.5,.8);\n\t\tzmove = 47.;\n\t}\n\n\tif (tpat > 23.) {\n\t\tfloat tt = ss(tpat-23.);\n\t\tpixmvl = mix(pixmvl, 5., tt);\n\t\tpixmvs = mix(pixmvs, vec2(1., 10.), tt);\n\t\tpixmvc = .5 * vec3(.2, .5, .9);\n\t\tlf = 10.;\n\t\tls = .1;\n\t}\n\n\tif (tpat > 24.) {\n\t\ttext_plane = true;\n\t\ttext_balls = true;\n\t\ttext_offset = -8. + 2.*mod(floor(tpat-23.), 4.);\n\t}\n\n\tif (tpat > 26.) {\n\t\trpix = true;\n\t\trpixc = vec3(1.);\n\t\ttext_plane = false;\n\t\tfloat tt = ss(tpat-26.);\n\t\tsz = mix(sz, vec3(2.,2.,-1.), tt);\n\t\tor = mix(or, 2., tt);\n\t\tmv *= RY(tt*(tpat-26.));\n\t}\n\n\tif (tpat > 28.) {\n\t\tproj1 = true;\n\t\tlf = 4.;\n\t\tpc = vec3(vec2(cos(tpat*.3), sin(tpat*.7)) * 1.5, 10.*sin(tpat*.9));\n\t}\n\n\tif (tpat > 30.) {\n\t\tls = .12, // lens size\n\t\t\t\tlf = 4. + 3.,// * sin(t*.1), // focus distance\n\t\t\t\tlS = 7.; // fov-ish\n\t\tpixmv = false;\n\t}\n\n\tif (tpat > 34.) {\n\t\tproj1 = false;\n\t\tproj2 = true;\n\t\tlS = .1;\n\t\tbgcolor = .5 * vec3(.3,.5,.8);\n\t}\n\n\tif (tpat > 38.) {\n\t\t//bgcolor = vec3(1.,.0,.0);\n\t\tmv = RX(-3.);\n\t}\n\n\t// PATHTRACER STARTS\n\tlS *= lf;\n#define NS 32.\n\tfor (float s=0.;s<NS;++s) {\n\t\tfloat a = hash1(seed+=uv.x)*2.*PI, r = s/NS;\n\t\tO = vec3(vec2(cos(a),sin(a))*r*ls, or);\n\t\tvec3 at = vec3(uv*lS, O.z-lf);\n\t\tD = normalize(at - O) * mv; O *= mv;\n\t\tvec3 kc = vec3(1.);\n\t\tfor (int i = 0; i < 4; ++i) {\n\t\t\tl = 1e6;\n\t\t\taapl(sz.x, vec3(1.,0.,0.), 1);\n\t\t\taapl(sz.y, vec3(0.,1.,0.), 2);\n\t\t\tif (sz.z>0.) aapl(sz.z, vec3(0.,0.,1.), 3);\n\n\t\t\tif (text_plane) {\n\t\t\t\tfloat dist = text_offset - O.z;\n\t\t\t\tfloat lt = dist / D.z;\n\t\t\t\tvec3 tp = O+D*lt;\n\t\t\t\tif (lt > 0. && lt < l) {\n\t\t\t\t\tif (text(tp.xy) > 0.) {\n\t\t\t\t\t\tl = lt;\n\t\t\t\t\t\tP = tp;\n\t\t\t\t\t\tN = vec3(0., 0., sign(dist));\n\t\t\t\t\t\tM = 4;\n\t\t\t\t\t\tUV = P.xy;\n\t\t\t\t\t} /* alpha glass fx */ //else { kc *= vec3(.5, .5, .7); }\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tvec3 me = vec3(0.), ma = vec3(.7);\n\t\t\tfloat mr = .5;\n\n\t\t\tif (M == 4) {\n\t\t\t\tma = vec3(.9);\n\t\t\t\tme = 4. * vec3(step(1.3,mod(t*.5+dot(3.*normalize(vec2(1.,1.)), UV), 2.)));\n\t\t\t\tmr = .9;\n\t\t\t} else {\n                // Windows/ANGLE fix\n\t\t\t\t//UV.y -= tpat*zmove;\n\t\t\t\t//UV *= pscl;\n                vec2 fix_uv_wtf = (UV - vec2(0., tpat*zmove)) * pscl;\n\t\t\t\t\n                vec2 cid = floor(fix_uv_wtf);\n\t\t\t\tvec2 cpc = fract(fix_uv_wtf)*2. - 1.;\n\n                if (rpix) {\n\t\t\t\t\tme += rpixc * step(.9,hash2(cid));\n\t\t\t\t}\n\n\t\t\t\tif (pix1) {\n\t\t\t\t\tfloat e2step = 2.;\n\t\t\t\t\tfloat e2a = t * .2;\n\t\t\t\t\tvec2 e2dir=vec2(cos(e2a),sin(e2a));\n\t\t\t\t\tfloat d = dot(UV, e2dir);\n\t\t\t\t\tme += vec3(2,0,0.5) * step(abs(d),e2step);\n\t\t\t\t}\n\n\t\t\t\tif (pix2) {\n\t\t\t\t\tme += max(me, pix2c*mod(floor(-.2*t+(dot(cid/12.,vec2(3.)))), 2.));\n\t\t\t\t}\n\n\t\t\t\tif (pixmv) {\n\t\t\t\t\tfloat pos = floor(t * pixmvs.x + pixmvs.y * hash1(cid.x));\n\t\t\t\t\tfloat len = 16.;\n\t\t\t\t\tfloat p = mod(cid.y + pos, len);\n\t\t\t\t\tme += pixmvc * step(len-pixmvl,p);\n\t\t\t\t}\n\n\t\t\t\t{\n\t\t\t\t\tvec3 ruv = normalize(floor(P*pscl) - pc);\n\t\t\t\t\truv *= RY(t*.1);\n\n\t\t\t\t\tvec3 dir = normalize(vec3(1.));\n\n\t\t\t\t\tme += bgcolor;\n\n\t\t\t\t\tif (proj1) {\n\t\t\t\t\t\t me += 2.*vec3(.9,.7,.2) * step(1.5, mod(t *.1+ 6.*dot(ruv, dir), 2.));\n\t\t\t\t\t}\n\n\t\t\t\t\tif (proj2) {\n\t\t\t\t\t\tme += 7. * vec3(.9,.7,.2) * pow(max(0.,dot(dir,ruv)), 100.);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tme *= vec3(\n\t\t\t\t\tstep(length(cpc),.8),\n\t\t\t\t\tstep(length(cpc+vec2(.1,0.)),.8),\n\t\t\t\t\tstep(length(cpc+vec2(.0,.1)),.8)\n\t\t\t\t);\n\t\t\t\tmr = .001 + hash2(cid)*.3;\n\t\t\t\tma *= step(abs(cpc.x),.9)*step(abs(cpc.y),.9);\n\t\t\t}\n\n\t\t\t//kc *= 1. - l/40.;\n\t\t\tc += kc * me;\n\t\t\tkc *= ma;\n\n\t\t\tif (all(lessThan(kc,vec3(.001)))) break;\n\n\t\t\tO = P;\n\t\t\tD = normalize(mix(\n\t\t\t\treflect(D, N),\n\t\t\t\tvec3(hash1(seed+=P.z),hash1(seed+=D.x),hash1(seed+=P.y))*2.-1., mr));\n\t\t\tD *= sign(dot(D, N));\n\t\t}\n\t}\n\n\tc /= NS;\n\n\tfragColor=vec4(sqrt(c), 0);\n}\n", "image_inputs": [{"id": "4dXGzr", "previewfilepath": "/media/ap/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png", "ctype": "texture"}, {"id": "MtXGzB", "previewfilepath": "https://soundcloud.com/keensky/past-racer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0, "src": "https://soundcloud.com/keensky/past-racer", "ctype": "musicstream"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Wts3W7.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[33, 33, 62, 62, 272], [299, 299, 319, 319, 977], [1036, 1036, 1057, 1057, 1092], [1093, 1093, 1113, 1113, 1158], [1160, 1160, 1182, 1182, 1327], [1329, 1329, 1346, 1346, 1408], [1409, 1409, 1426, 1426, 1488], [1489, 1489, 1506, 1506, 1568], [1613, 1613, 1657, 1657, 1871], [1873, 1873, 1891, 1891, 1917], [1919, 1919, 1974, 1974, 7339]], "test": "error"}
{"id": "Wts3W8", "name": "psychedelic box", "author": "ankd", "description": "rotated box and gray2hue coloring", "tags": ["raymarching", "psychedelic"], "likes": 3, "viewed": 162, "published": "Public", "date": "1556207709", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const float PI = 3.1415926;\n#define AA 2\n\nvec3 hsv(float h, float s, float v){\n    vec4 t = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(vec3(h) + t.xyz) * 6.0 - vec3(t.w));\n    return v * mix(vec3(t.x), clamp(p - vec3(t.x), 0.0, 1.0), s);\n}\nmat2 rotate(in float r){\n    return mat2(cos(r), -sin(r), sin(r), cos(r));\n}\nfloat usin(in float x){\n    return 0.5+0.5*sin(x);\n}\nfloat gray(in vec3 color){\n    return dot(color, vec3(0.299, 0.587, 0.114));\n}\n\nfloat sdSphere(in vec3 p, in float r){\n    return length(p) - r;\n}\nfloat sdBox(in vec3 p, in vec3 b){\n    vec3 d = abs(p) - b;\n    return min(max(d.x, max(d.y, d.z)), 0.) + length(max(d, 0.));\n}\n\nvec3 opRep(in vec3 p, in vec3 c){\n    return mod(p, c) - 0.5*c;\n}\n\nfloat sdObj(in vec3 p){\n    vec3 q = p;\n    q.xy *= rotate(q.z*PI*0.05+iTime*0.1);\n    q = opRep(q, vec3(5.0));\n    // q.z\n    q.xy *= rotate(q.z*PI+iTime);\n    return sdBox(q, vec3(2.5, 0.1, 2.5));\n}\n\nvec2 map(in vec3 p){\n    vec2 res = vec2(0.0);\n    vec3 q = p;\n\n    res = vec2(sdObj(q), 1.);\n    return res;\n}\n\nvec3 calcNormal(in vec3 p){\n    vec2 e = vec2(1.0, -1.0) * 0.00001;\n    return normalize(vec3(\n            e.xyy*map(p+e.xyy).x +\n            e.yxy*map(p+e.yxy).x +\n            e.yyx*map(p+e.yyx).x +\n            e.xxx*map(p+e.xxx).x\n        ));\n}\n\nmat3 lookAt(in vec3 eye, in vec3 tar, in float r){\n    vec3 cw = normalize(tar - eye);\n    vec3 cp = vec3(sin(r), cos(r), 0.);\n    vec3 cu = normalize(cross(cp, cw));\n    vec3 cv = normalize(cross(cw, cu));\n    return mat3(cu,cv,cw);\n}\n\nvec2 castRay(in vec3 ro, in vec3 rd){\n    float minD=0.0, maxD = 30.0;\n    float d=minD, m=0.0;\n\n    for(int i=0;i<32;i++){\n        vec3 pos = ro + rd*d;\n        vec2 tmp = map(pos);\n        if(tmp.x<0.0000001 || maxD<tmp.x) break;\n        d += tmp.x*0.6;\n        m = tmp.y;\n    }\n    if(maxD<d) m = -1.0;\n\n    return vec2(d, m);\n}\n\nvec3 render(in vec3 ro, in vec3 rd){\n    vec2 res = castRay(ro, rd);\n    float d = res.x;\n    float m = res.y;\n\n    vec3 pos = ro + rd * d;\n    vec3 nor = calcNormal(pos);\n\n    vec3 lightDir = normalize(vec3(cos(iTime), 1., sin(iTime)));\n\n    vec3 color = vec3(0.);\n    if(m==1.){\n        color += clamp(dot(lightDir, nor), 0., 1.);\n        float g = gray(color);\n        color = hsv(0.5+0.1*sin(iTime*0.5)+g*(0.4+usin(iTime*0.001)), 1.0, 1.0);\n        color += usin(d+iTime*20.0);\n        color *= exp(-0.03*d);\n    }else {\n        color = vec3(0.0);\n    }\n\n\n    return color;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    vec3 eye = vec3(0., 0., iTime);\n    vec3 tar = eye-vec3(0.1*sin(iTime*1.2+sin(iTime*0.5)), 0.1*sin(iTime*.9+sin(iTime*1.3)), 1.0);\n\n    vec3 color = vec3(0.);\n    for(int i=0;i<AA;i++){\n        for(int j=0;j<AA;j++){\n            vec2 p = (fragCoord.xy * 2.0 - iResolution.xy) / min(iResolution.x, iResolution.y);\n            p += vec2(float(i), float(j))/iResolution.xy;\n            vec3 dir = normalize(lookAt(eye, tar, iTime*0.4+0.2*sin(iTime*0.8)) * vec3(p, 1.0));\n            dir = normalize(vec3(dir.xy, sqrt(max(dir.z*dir.z - dot(dir.xy, dir.xy)*0.2, 0.))));\n\n            color += render(eye, dir);\n        }\n    }\n    color /= float(AA*AA);\n    fragColor = vec4(color,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Wts3W8.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[42, 42, 78, 78, 257], [258, 258, 282, 282, 334], [335, 335, 358, 358, 387], [388, 388, 414, 414, 466], [468, 468, 506, 506, 534], [535, 535, 569, 569, 662], [664, 664, 697, 697, 729], [731, 731, 754, 754, 931], [933, 933, 953, 953, 1044], [1046, 1046, 1073, 1073, 1292], [1294, 1294, 1344, 1344, 1529], [1531, 1531, 1568, 1568, 1862], [1864, 1864, 1900, 1900, 2443], [2445, 2445, 2502, 2502, 3190]], "test": "ok"}
{"id": "wts3Wr", "name": "Testing colors", "author": "janetdaetton", "description": "My first attempt.", "tags": ["dark"], "likes": 2, "viewed": 260, "published": "Public API", "date": "1556118829", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Time varying pixel color\n    vec3 col = 0.1 + 0.1*cos(iTime+uv.xyx+vec3(0,0,2));\n\n    // Output to screen\n    fragColor = vec4(col,2.1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wts3Wr.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 107, 294]], "test": "ok"}
{"id": "Wts3z4", "name": "Laser in the sewer", "author": "hedyla2055", "description": "just another experiment with some distance functions", "tags": ["sdf"], "likes": 1, "viewed": 107, "published": "Public", "date": "1555767739", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI acos(-1.)\n\nmat2 rotate(float angle)\n{\n    float s = sin(angle);\n    float c = cos(angle);\n    return mat2(c, -s, s, c);\n}\n\nvec4 laser(vec2 uv, vec4 color)\n{\n    uv -= 0.5;\n    float w = pow( .1 / length(uv), 3.);\n    return color * w * .7;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n\n\tvec3 dir = normalize(vec3(uv, 1));\n    dir.xy *= rotate(sin(iTime * .3));\n    \n    vec2 luv = vec2(.3 / length(dir.xy), atan(dir.x , dir.y) / PI * .5);\n\n    // Let's give it a green color, we are in the sewer after all\n    fragColor = laser(fract(luv), vec4(.1, 1., .1, 1.));\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Wts3z4.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[22, 22, 48, 48, 132], [134, 134, 167, 167, 252], [254, 254, 311, 311, 657]], "test": "ok"}
{"id": "Wts3z8", "name": "Someone help!", "author": "scratch13764", "description": "description", "tags": ["tag"], "likes": 2, "viewed": 164, "published": "Public", "date": "1555633431", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/*\nI know at least some people also get this glitch, but I also heard that refreshing \nfixes it. I would love to be able to edit the shaders I've been working on for \nawhile, obviously if I make new ones I can save the link and skip the menu but\nfor my old shaders I didn't think to do that. I also don't have a twitter if\nanyone wonders why I'm saying this here instead of trying to go report it to \nsomeone there. Also I wanted to make a shader that said text...\n*/\n\n\n#define L_A 65\n#define L_B 66\n#define L_C 67\n#define L_D 68\n#define L_E 69\n#define L_F 70\n#define L_G 71\n#define L_H 72\n#define L_I 73\n#define L_J 74\n#define L_K 75\n#define L_L 76\n#define L_M 77\n#define L_N 78\n#define L_O 79\n#define L_P 80\n#define L_Q 81\n#define L_R 82\n#define L_S 83\n#define L_T 84\n#define L_U 85\n#define L_V 86\n#define L_W 87\n#define L_X 88\n#define L_Y 89\n#define L_Z 90\n\n#define L_SP 32\n#define L_PD 46\n\nfloat Letter(sampler2D Font,vec2 P,int L)\n{\n   return texture(Font,(P+vec2(L-(L/16)*16,15-L/16))/16.).x; \t   \n}\n\nint message[274] = int[](\nL_S,\nL_O,\nL_SP,\nL_I,\nL_SP,\nL_H,\nL_A,\nL_V,\nL_E,\nL_SP,\nL_A,\nL_SP,\nL_G,\nL_L,\nL_I,\nL_T,\nL_C,\nL_H,\nL_SP,\nL_R,\nL_I,\nL_G,\nL_H,\nL_T,\nL_SP,\nL_N,\nL_O,\nL_W,\nL_SP,\nL_W,\nL_I,\nL_T,\nL_H,\nL_SP,\nL_S,\nL_H,\nL_A,\nL_D,\nL_E,\nL_R,\nL_T,\nL_O,\nL_Y,\nL_SP,\nL_W,\nL_H,\nL_E,\nL_R,\nL_E,\nL_SP,\nL_I,\nL_SP,\nL_C,\nL_A,\nL_N,\nL_SP,\nL_O,\nL_N,\nL_L,\nL_Y,\nL_SP,\nL_V,\nL_I,\nL_E,\nL_W,\nL_SP,\nL_M,\nL_Y,\nL_SP,\nL_P,\nL_U,\nL_B,\nL_L,\nL_I,\nL_C,\nL_S,\nL_H,\nL_A,\nL_D,\nL_E,\nL_R,\nL_S,\nL_PD,\nL_SP,\nL_W,\nL_H,\nL_E,\nL_N,\nL_SP,\nL_I,\nL_SP,\nL_T,\nL_R,\nL_Y,\nL_SP,\nL_T,\nL_O,\nL_SP,\nL_SP,\nL_SP,//Lmao it's getting real\nL_V,\nL_I,\nL_E,\nL_W,\nL_SP,\nL_M,\nL_Y,\nL_SP,\nL_P,\nL_R,\nL_I,\nL_V,\nL_A,\nL_T,\nL_E,\nL_SP,\nL_P,\nL_R,\nL_O,\nL_F,\nL_I,\nL_L,\nL_E,\nL_SP,\nL_SP,\nL_E,\nL_V,\nL_E,\nL_R,\nL_Y,\nL_T,\nL_H,\nL_I,\nL_N,\nL_G,\nL_SP,\nL_W,\nL_O,\nL_R,\nL_K,\nL_S,\nL_SP,\nL_E,\nL_X,\nL_C,\nL_E,\nL_P,\nL_T,\nL_SP,\nL_SP,\nL_N,\nL_O,\nL_SP,\nL_S,\nL_H,\nL_A,\nL_D,\nL_E,\nL_R,\nL_S,\nL_SP,\nL_S,\nL_H,\nL_O,\nL_W,\nL_SP,\nL_U,\nL_P,\nL_PD,\nL_SP,\nL_D,\nL_O,\nL_E,\nL_S,\nL_SP,\nL_A,\nL_N,\nL_Y,\nL_O,\nL_N,\nL_E,\nL_SP,\nL_E,\nL_L,\nL_S,\nL_E,\nL_SP,\nL_G,\nL_E,\nL_T,\nL_SP,\nL_T,\nL_H,\nL_I,\nL_S,\nL_PD,\nL_SP,\nL_I,\nL_S,\nL_SP,\nL_T,\nL_H,\nL_E,\nL_R,\nL_E,\nL_SP,\nL_A,\nL_SP,\nL_W,\nL_A,\nL_Y,\nL_SP,\nL_T,\nL_O,\nL_SP,\nL_F,\nL_I,\nL_X,\nL_SP,\nL_I,\nL_T,\nL_PD,\nL_SP,\nL_I,\nL_F,\nL_I,\nL_T,\nL_SP,\nL_H,\nL_E,\nL_L,\nL_P,\nL_S,\nL_SP,\nL_I,\nL_SP,\nL_A,\nL_M,\nL_SP,\nL_U,\nL_S,\nL_I,\nL_N,\nL_G,\nL_SP,\nL_O,\nL_P,\nL_E,\nL_R,\nL_A,\nL_B,\nL_R,\nL_O,\nL_W,\nL_S,\nL_E,\nL_R,\nL_SP,\nL_O,\nL_N,\nL_SP,\nL_W,\nL_I,\nL_N,\nL_D,\nL_O,\nL_W,\nL_S,\nL_SP,\nL_T,\nL_E,\nL_N,\nL_PD,\nL_SP);\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = 1.-(iResolution.xy-fragCoord)/iResolution.x;\n    \n    vec3 col = .25*cos(iTime+uv.xyx+vec3(0,2,4));\n    \n    int L = message[int(floor(uv.x*25.) + (24.-floor(uv.y*25.))*25.)];\n    \n    float f = Letter (iChannel0, fract(uv*25.), L)*step(uv.x, 1.);\n    \n    fragColor = vec4(col*(1.-f) + f,1);\n}", "image_inputs": [{"id": "4dXGzr", "previewfilepath": "/media/ap/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Wts3z8.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[894, 894, 937, 937, 1005], [2490, 2490, 2547, 2547, 2856]], "test": "error"}
{"id": "Wts3zH", "name": "Proper dithering", "author": "orlp", "description": "Proper dithering with triangular noise.", "tags": ["dither"], "likes": 5, "viewed": 193, "published": "Public", "date": "1555661236", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Original idea by Mikkel Gjoel (https://computergraphics.stackexchange.com/a/5952/10515),\n// simplified to one readable function.\n\n// Dithers and quantizes color value c in [0, 1] to the given color depth.\n// It's expected that rng contains a uniform random variable on [0, 1].\nuint dither_quantize(float c, uint depth, float rng) {\n    float cmax = float(depth) - 1.0;\n    float ci = c * cmax;\n\n    float d;\n    if (ci < 0.5 || ci >= cmax - 0.5) {\n        // Uniform distribution on [-0.5, 0.5] for edges.\n        d = rng - 0.5;\n    } else {\n        // Symmetric triangular distribution on [-1, 1].\n        d = (rng < 0.5) ? sqrt(2.0 * rng) - 1.0 : 1.0 - sqrt(2.0 - 2.0*rng);\n    }\n\n    return uint(clamp(ci + d + 0.5, 0.0, cmax));\n}\n\n\n\n#define LINE_THICKNESS 0.002\n#define DEPTH 4.\n#define REPS 500.\n\nconst uint k = 1103515245U;  // GLIB C\nvec3 hash( uvec3 x )\n{\n    x = ((x>>8U)^x.yzx)*k;\n    x = ((x>>8U)^x.yzx)*k;\n    x = ((x>>8U)^x.yzx)*k;\n    \n    return vec3(x)*(1.0/float(0xffffffffU));\n}\n\nfloat line(float d) {\n    return smoothstep(0., d, LINE_THICKNESS);\n}\n\n\nfloat i2f(uint i) {\n    return float(i) / (DEPTH - 1.0);\n}\n\nvec3 graphic(vec2 uv) {\n    vec2 g = vec2(uv.x * 1.5 - 0.25, (uv.y - 0.05) / 0.4);\n    \n    if (-LINE_THICKNESS < g.x && g.x < 0. ||\n        1.0 < g.x && g.x < 1.0 + LINE_THICKNESS) {\n        return vec3(0.5, 0.5, 0.5);\n    }\n    \n    uvec3 seed = uvec3(int(uv.x * 10000.), int(uv.y*10000.), iFrame);\n    float signal = clamp(g.x, 0.0, 1.0);\n    float dithered = i2f(dither_quantize(signal, uint(DEPTH), hash(seed).x));\n    float avg = 0.;\n    float variance = 0.;\n    for (float i = 0.; i < REPS; i += 1.) {\n        uvec3 r = seed + uint(i);\n        float d = i2f(dither_quantize(signal, uint(DEPTH), hash(r).x));\n        avg += d / REPS;\n        variance += (d - signal) * (d - signal) / REPS;\n    }\n    \n    if (uv.y > 5./6.) {\n        return vec3(signal);\n    }\n    \n    if (uv.y > 4./6.) {\n        return vec3(avg);\n    }\n    \n    if (uv.y > 3./6.) {\n        return vec3(dithered);\n    }\n    \n    vec3 c = vec3(0.);\n    \n    // Signal.\n    c += vec3(0.5) * line(abs(g.y - signal));\n    \n    // Average dithered signal.\n    c += vec3(1.0, 1.0, 0.0) * line(abs(g.y - avg));\n    \n    // Error of average.\n    float error = (avg - signal) * 5.;\n    c += vec3(1.0, 0.0, 0.0) * line(abs(g.y - 0.5 - error));\n    \n    // Variance.\n    c += vec3(0.0, 0.0, 1.0) * line(abs(g.y - variance * 15.));\n    \n    return c;\n}\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = fragCoord/iResolution.xy;\n    vec3 col = vec3(0.);\n    fragColor = vec4(graphic(uv), 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Wts3zH.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[133, 280, 334, 334, 736], [834, 844, 866, 866, 999], [1001, 1001, 1022, 1022, 1070], [1073, 1073, 1092, 1092, 1131], [1133, 1133, 1156, 1156, 2446], [2449, 2449, 2504, 2504, 2611]], "test": "ok"}
{"id": "WtsGWH", "name": "HelloWorld1", "author": "ShaderJJ", "description": "My first Shader", "tags": ["learn"], "likes": 0, "viewed": 37, "published": "Public", "date": "1556211255", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Time varying pixel color\n    vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WtsGWH.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 107, 294]], "test": "ok"}
{"id": "WtsGWr", "name": "newop", "author": "chicollgamer", "description": "rainbow", "tags": ["color"], "likes": 1, "viewed": 49, "published": "Public", "date": "1556065989", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Time varying pixel color\n    vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WtsGWr.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 107, 294]], "test": "ok"}
{"id": "WtsGzr", "name": "D&D 003 - Kioube", "author": "Ryp", "description": "I was lazy", "tags": ["quickdirty"], "likes": 7, "viewed": 91, "published": "Public", "date": "1555525746", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float saturate(float v)\n{\n    return clamp(v, 0.0, 1.0);\n}\n\nmat4 viewMatrix(vec3 eye, vec3 center, vec3 up) {\n\tvec3 f = normalize(center - eye);\n\tvec3 s = normalize(cross(f, up));\n\tvec3 u = cross(s, f);\n\treturn mat4(\n\t\tvec4(s, 0.0),\n\t\tvec4(u, 0.0),\n\t\tvec4(-f, 0.0),\n\t\tvec4(0.0, 0.0, 0.0, 1)\n\t);\n}\n\nfloat intersectSDF(float distA, float distB) {\n    return max(distA, distB);\n}\n\nfloat unionSDF(float distA, float distB) {\n    return min(distA, distB);\n}\n\nfloat opSmoothUnion( float d1, float d2, float k )\n{\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h);\n}\n\nfloat differenceSDF(float distA, float distB) {\n    return max(distA, -distB);\n}\n\nfloat sdBox(vec3 p, vec3 b)\n{\n  \tvec3 d = abs(p) - b;\n  \treturn length(max(d,0.0)) + min(max(d.x,max(d.y,d.z)),0.0); // remove this line for an only partially signed sdf \n}\n\nfloat sphereSDF(vec3 p)\n{\n    return length(p) - 1.0;\n}\n\nconst int MAX_MARCHING_STEPS = 200;\nconst float EPSILON = 0.001f;\n\nfloat sceneSDF(vec3 p)\n{\n    float time = mod(iTime, 3.1415 * 1.0);\n    \n    vec3 boxSize = vec3(1.0, 1.0, 1.0);\n    \n    mat3 rot1 = mat3(\n        cos(time), sin(time), 0.0,\n        sin(time), -cos(time), 0.0,\n        0.0, 0.0, 1.0);\n\n    mat3 rot2 = mat3(\n        -cos(time), 0.0, sin(time),\n        0.0, 1.0, 0.0,\n        sin(time), 0.0, cos(time));\n    \n    mat3 rot3 = mat3(\n        1.0, 0.0, 0.0,\n        0.0, cos(time), sin(time),\n        0.0, sin(time), -cos(time));\n    \n    return unionSDF(\n        sdBox(rot1 * (p + vec3(-1,-1,0)) - vec3(1.0, 1.0, 0.0), boxSize),\n        unionSDF(\n            sdBox(rot2 * (p + vec3(-1, 0, -1)) - vec3(1.0, 0.0, 1.0), boxSize),\n\t\t\tsdBox(rot3 * (p + vec3(0, -1, -1)) - vec3(0.0, 1.0, 1.0), boxSize)\n        )\n    );\n}\n\nfloat shortestDistanceToSurface(vec3 eye, vec3 marchingDirection, float start, float end) {\n    float depth = start;\n    for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n        float dist = sceneSDF(eye + depth * marchingDirection);\n        if (dist < EPSILON) {\n\t\t\treturn depth;\n        }\n        depth += dist;\n        if (depth >= end) {\n            return end;\n        }\n    }\n    return end;\n}\n\nvec3 estimateNormal(vec3 p)\n{\n    return normalize(vec3(\n        sceneSDF(vec3(p.x + EPSILON, p.y, p.z)) - sceneSDF(vec3(p.x - EPSILON, p.y, p.z)),\n        sceneSDF(vec3(p.x, p.y + EPSILON, p.z)) - sceneSDF(vec3(p.x, p.y - EPSILON, p.z)),\n        sceneSDF(vec3(p.x, p.y, p.z  + EPSILON)) - sceneSDF(vec3(p.x, p.y, p.z - EPSILON))\n    ));\n}\n\nconst float pi = 3.14159265358;\n\nfloat deg2rad(float angleDeg)\n{\n \treturn (angleDeg * pi) / 180.f;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 positionUV = fragCoord / iResolution.xy;\n    vec2 positionNDC = 2.0 * positionUV - 1.0;\n    positionNDC.y = -positionNDC.y;\n    \n    // Camera setup\n    float cameraHFovAngle = deg2rad(55.f);\n    float cameraNear = 0.1f;\n    float cameraFar = 20.0f;\n    vec3 eyePositionWS = vec3(7.0f, 7.0f, 7.0f);\n\n    // Viewport calculations\n    float aspectRatioInv = iResolution.y / iResolution.x;\n    \n    float horizontalFov = cameraNear * tan(cameraHFovAngle * 0.5f);\n \tfloat verticalFov = horizontalFov * aspectRatioInv;\n    vec2 cameraViewportExtent = vec2(horizontalFov, verticalFov);\n    \n    vec3 viewRayDirectionWS = vec3(positionNDC * cameraViewportExtent, cameraNear);\n    \n    viewRayDirectionWS = (viewMatrix(eyePositionWS, vec3(0.0, 0.0, 0.0), vec3(0.0, 0.0, 1.0)) * vec4(viewRayDirectionWS, 0.0)).xyz;        \n    viewRayDirectionWS = normalize(-viewRayDirectionWS);\n    \n    float rayDepth = shortestDistanceToSurface(eyePositionWS, viewRayDirectionWS, cameraNear, cameraFar);\n\n    vec3 p = eyePositionWS + rayDepth * viewRayDirectionWS;\n    \n    vec3 lightPosWS = vec3(2.0, 4.0, 6.0);\n    vec3 normalWS = estimateNormal(p);\n    vec3 L = normalize(lightPosWS - p);\n    vec3 V = normalize(eyePositionWS - p);\n    vec3 R = normalize(reflect(-L, normalWS));\n    \n    float dotLN = saturate(dot(L, normalWS));\n    float dotRV = saturate(dot(R, V));\n        \n    // Output some color\n    vec3 color = vec3(0.0);\n\t\n    if (rayDepth > cameraFar - EPSILON)\n    {\n        // Didn't hit anything\n        color = vec3(0.0);\n    }\n    else\n    \tcolor = vec3(1.0, 0.0, 0.7) * dotLN + vec3(.1, .1, .1);\n    \n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WtsGzr.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 25, 25, 58], [60, 60, 109, 109, 296], [298, 298, 344, 344, 376], [378, 378, 420, 420, 452], [454, 454, 506, 506, 605], [607, 607, 654, 654, 687], [689, 689, 718, 718, 861], [863, 863, 888, 888, 918], [987, 987, 1011, 1011, 1748], [1750, 1750, 1841, 1841, 2147], [2149, 2149, 2178, 2178, 2488], [2523, 2523, 2554, 2554, 2590], [2592, 2592, 2647, 2647, 4291]], "test": "ok"}
{"id": "WtX3D7", "name": "tv - bug", "author": "pegasus", "description": "Cycling color patterns in shapes of vertical crossfading lines", "tags": ["tv"], "likes": 1, "viewed": 266, "published": "Public API", "date": "1556472368", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float x = cos(iTime/2.)*sin(fragCoord.x/30.)+iTime*0.001225;\n    float y = sin(iTime/20.)*cos(fragCoord.y/.0013)+iTime*.0625; \n     \n    fragCoord = vec2(x,y);\n    float z = fragCoord.x/fragCoord.y+iTime*.125;\n\tfragColor = vec4(smoothstep(tan(z+x),0.6,0.8), \n                     smoothstep(sin(z+x-y),.8,.6), \n                     smoothstep(cos(z+y),.3,.5) ,.5);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WtX3D7.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 428]], "test": "ok"}
{"id": "WtX3R4", "name": "2D mastersun marquee", "author": "zproxy", "description": "https://www.shadertoy.com/view/wd2SDt", "tags": ["2d", "loading"], "likes": 3, "viewed": 95, "published": "Public", "date": "1555696944", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float N21(vec2 p) {\n\tp = fract(p * vec2(233.34, 851.73));\n    p += dot(p, p + 23.45);\n    return fract(p.x * p.y);\n}\n\nfloat inRect(vec2 pos, vec2 topLeft, vec2 rightBottom) {\n\treturn step(topLeft.x, pos.x) * step(rightBottom.y, pos.y) * step(-rightBottom.x, -pos.x) * step(-topLeft.y, -pos.y);\n}\n\nfloat inBetween(float x, float a, float b) {\n    return step(a, x) * step(-b, -x);\n}\n\nfloat boxLayer(float depth, vec2 uv, float size, float pos, float iTime) {\n\n    const float fullDepth = 4.0;\n    \n    float boxHalfSize = size * 0.5;\n\n    vec2 boxCenter = vec2(fullDepth * pos, (1.0 - boxHalfSize) * sin((iTime + 1.0) * 10.0 * (0.3 + 0.7 * N21(vec2(depth, size))) ));\n    \n    return inRect(uv, boxCenter + vec2(-boxHalfSize, boxHalfSize), boxCenter + vec2(boxHalfSize, -boxHalfSize))\n    * inRect(uv, vec2(0.0, 1.0), vec2(3.99, -1.0));\n}\n\nvoid mainImage0( out vec4 fragColor, in vec2 fragCoord,\n               vec3 baseColor,\n                 vec3 activeColor,\n                float iTime\n               )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 inv_resolution = 1.0 / iResolution.xy;\n    vec2 uv = fragCoord * inv_resolution.xy;\n\n\tfloat sWidth = iResolution.x * inv_resolution.y;\n    const float barWidthRatio = 0.8;\n    float inv_barWidth = 1.0 / (barWidthRatio * sWidth);\n    float barHeight = 0.06;\n    float twice_inv_barHeight = 2.0 / barHeight;\n    uv.x = uv.x * sWidth;\n\n    mat3 T_bar2s = mat3(\n        vec3(inv_barWidth, 0.0, 0.0),\n        vec3(0.0, inv_barWidth, 0.0),\n        vec3((1.0 - sWidth * inv_barWidth) * 0.5, -0.5 * inv_barWidth, 1.0)\n    );\n\n    vec2 uv_bar = (T_bar2s * vec3(uv.xy, 1.0)).xy;\n    float isInBaseRect = inRect(uv_bar, vec2(0.0, 0.5 * barHeight), vec2(1.0, -0.5 * barHeight));\n    float isInActiveRect = inRect(uv_bar, vec2(0.0, 0.5 * barHeight), vec2(fract(iTime * 0.1), -0.5 * barHeight)); \n//    vec3 baseColor = vec3(0.12941, 0.13725, 0.17647);\n    \n    //vec3 baseColor = mix(vec3(0.2, 0.35294, 0.91373), vec3(0.43529, 0.43529, 0.96078), uv_bar.x);\n  \n    //vec3 activeColor = mix(vec3(0.2, 0.35294, 0.91373), vec3(0.43529, 0.43529, 0.96078), uv_bar.x);\n  \n   // vec3 baseColor = vec3(0.43529, 0.43529, 0.96078);\n    //vec3 activeColor = vec3(0.12941, 0.13725, 0.17647);\n  \n    \n    \n    vec3 color = vec3(0.0, 0.0, 0.0);\n    color = mix(color, baseColor, isInBaseRect);\n    color = mix(color, activeColor, isInActiveRect);\n\n    mat3 T_top2bar = mat3(\n        vec3(twice_inv_barHeight, 0.0, 0.0),\n        vec3(0.0, twice_inv_barHeight, 0.0),\n        vec3(-twice_inv_barHeight * fract(iTime * 0.1), 0.0, 1.0)\n    );\n\n    vec2 topCord = (T_top2bar * vec3(uv_bar, 1.0)).xy;\n    \n    float sizes[8];\n\n    sizes[0] =  0.64443028954883467;\n    sizes[1] =  0.5305055282034009;\n    sizes[2] =  0.563223756594665;\n    sizes[3] =  0.7904855321774765;\n    sizes[4] =  0.58575556655444496;\n    sizes[5] =  0.3690261013697286;\n    sizes[6] =  0.40226518516562614;\n    sizes[7] =  0.935630139708542;\n\n    float inBoxes = 0.0;\n\n    // for (float j = 0.0; j < 1.0; j+=0.125) {\n    // \t// float depth = fract(i + iTime * 0.6);\n    // \tfloat depth = j;\n    //     float pos = fract(j + iTime * 0.6);\n    //     inBoxes += boxLayer(depth, topCord, sizes[int(j * 8.0)], pos);\n    // }\n\n//    float ftime = iTime * 0.6;\n    float ftime = iTime * 0.6;\n    \n    //iTime *= 0.01;\n    \n    inBoxes += boxLayer(0.0, topCord, sizes[0], fract(0.0 + ftime), iTime);\n    inBoxes += boxLayer(0.125, topCord, sizes[1], fract(0.125 + ftime), iTime);\n    inBoxes += boxLayer(0.25, topCord, sizes[2], fract(0.25 + ftime), iTime);\n    inBoxes += boxLayer(0.375, topCord, sizes[3], fract(0.375 + ftime), iTime);\n    inBoxes += boxLayer(0.5, topCord, sizes[4], fract(0.5 + ftime), iTime);\n    inBoxes += boxLayer(0.625, topCord, sizes[5], fract(0.625 + ftime), iTime);\n    inBoxes += boxLayer(0.75, topCord, sizes[6], fract(0.75 + ftime), iTime);\n    inBoxes += boxLayer(0.875, topCord, sizes[7], fract(0.875 + ftime), iTime);\n\n    color = mix(color, activeColor, clamp(inBoxes, 0.0, 1.0) * inBetween(uv_bar.x, 0.0, 1.0) );\n\n    // Output to screen\n    fragColor = vec4(color, 1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 baseColor = vec3(0.43529, 0.43529, 0.96078);\n    vec3 activeColor = vec3(0.12941, 0.13725, 0.17647);\n\n    \n    float swapTime = mod(iTime * 0.5 , 20.0);\n\n    float iiiTime = mod(iTime * 0.5, 10.0);\n    //float iiiTime = iTime % 10.0;\n    \n    vec4 fragColor0;\n    mainImage0(fragColor0, fragCoord, baseColor, activeColor, iiiTime + 00.);\n    \n    vec4 fragColor1;\n    mainImage0(fragColor1, fragCoord, activeColor, baseColor, iiiTime + 00.);\n\n//    if (fragCoord.y < iResolution.y/2.0)\n        \n    if (swapTime >= 10.0)\n    {\n//    \tfragColor = min(fragColor0, fragColor1);\n        \n        fragColor = fragColor0 ;\n    }\n    else\n        fragColor = fragColor1;\n    \n//    fragColor.b = max(fragColor0.b, fragColor1.b);\n\n//        fragColor.b = min(fragColor0.b, fragColor1.b);\n\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WtX3R4.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 19, 19, 116], [118, 118, 174, 174, 295], [297, 297, 341, 341, 381], [383, 383, 457, 457, 837], [839, 839, 1007, 1057, 4108], [4110, 4110, 4167, 4167, 4959]], "test": "ok"}
{"id": "wtX3Rn", "name": "Black star", "author": "dyla", "description": "some simple 2d mess :)", "tags": ["2d", "blackstar"], "likes": 3, "viewed": 89, "published": "Public", "date": "1555507585", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-0.5*iResolution.xy)/iResolution.yy;\n    \n    float r = length(uv);\n    float a = atan(uv.x, uv.y);\n    \n    \n    float hlIntensity = sin(1.0*(a+iTime*0.79))*0.4+0.4;\n    hlIntensity *= exp(hlIntensity);\n    hlIntensity *= hlIntensity*0.49;\n    hlIntensity *= sin(iTime*1.3)*0.5+0.5;\n    vec4 hlColor = vec4(0.7, 0.8, 1.0, 1.0);\n    \n    float sna = sin(iTime*0.2);\n    float csa = cos(iTime*0.2);\n    mat2 rot = mat2(csa, -sna, sna, csa);\n    vec4 spaceColor = vec4(1.5, 1.0, 0.05, 1.0) * texture(iChannel0, uv*exp(-r)*((1.0-r)*(1.0-hlIntensity)*0.125)*rot+iTime*0.005);\n    \n\tfloat ringRad = 0.33;\n    float ringWid = (sin(a+iTime)*0.008+0.017) * (sin(iTime*4.0)*0.07+1.0) + hlIntensity*0.05;\n    float ringIntensity = 1.0-smoothstep(0.0,ringWid,abs(ringRad-r));\n    vec4 ringColor = mix(vec4(0.0), vec4(1.0,0.7,0.2,1.0), ringIntensity);\n\t\n    \n    \n    vec4 ringFinal = ringIntensity * mix(ringColor, hlColor, hlIntensity);\n\t\n    fragColor = r<ringRad ? ringFinal : mix(spaceColor, ringFinal, ringIntensity);\n}", "image_inputs": [{"id": "XdfGRn", "previewfilepath": "/media/ap/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtX3Rn.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 1095]], "test": "error"}
{"id": "WtX3RS", "name": "Contour and density plotting", "author": "tpfto", "description": "Show the contours and the density plot of a function z == f(x, y). Now with hill shading included.", "tags": ["2d", "math", "plot", "contours", "hillshading"], "likes": 3, "viewed": 260, "published": "Public", "date": "1556609251", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// The MIT License\n// Copyright © 2019 J. M.\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// contour/density plotter, with hill shading\n\n// some constants\n#define PI 3.14159265359\n\n#define BLACK vec3(0.0)\n#define WHITE vec3(1.0)\n\n// dark and light colors from Solarized (https://ethanschoonover.com/solarized/)\n#define DARK vec3(0., 0.169, 0.212)\n#define LIGHT vec3(0.992, 0.965, 0.89)\n#define GRAY vec3(0.396, 0.482, 0.514)\n\n// XY range of the display.\n#define DISP_SCALE 6.5 \n\n// comment out to disable contours\n#define SHOW_CONTOURS\n\n#ifdef SHOW_CONTOURS\n// Contour thickness (in pixels).\n#define CONTOUR_SIZE 1.0\n\n// number of contours\n#define CONTOURS 12\n\n// contour color\n#define CONTOUR_COLOR GRAY\n#endif\n\n// comment out to disable hill shading\n#define SHADE\n\n// Clip areas outside DISP_SCALE\n#define CLIP_EDGES\n\n// rescaling functions\n\nfloat logistic(float x)\n{\n\t  float ex = exp(-abs(x));\n      return ((x >= 0.0) ? 1.0 : ex)/(1.0 + ex);\n}\n\nfloat rescale(float x, vec2 range)\n{\n\t  float a = range.x, b = range.y;\n      return (x - a)/(b - a);\n}\n\nfloat rescale(float x, vec2 r1, vec2 r2)\n{\n\t  float a = r1.x, b = r1.y;\n      float c = r2.x, d = r2.y;\n      return c + (d - c) * ((x - a)/(b - a));\n}\n\n// using rational version of smoothstep from https://tpfto.wordpress.com/2019/03/28/on-a-rational-variant-of-smoothstep/\nfloat myStep(float e0, float e1, float x)\n{\n    float t = clamp((x - e0)/(e1 - e0), 0.0, 1.0);\n\treturn t * t * t/(1.0 - 3.0 * t * (1.0 - t));\n}\n\n// custom colormap\n\nvec3 land(float t)\n{\n    const float eps = 0.05;\n    const vec3 bl = vec3(0.0);\n    \n    const vec3 c1 = vec3(0.277, 0.355, 0.484);\n    const vec3 c2 = vec3(0.337, 0.468, 0.376);\n    const vec3 c3 = vec3(0.495, 0.563, 0.427);\n    const vec3 c4 = vec3(0.735, 0.728, 0.66);\n    const vec3 c5 = vec3(1., 0.997, 0.914);\n\n    vec3 cc = + mix(c1, c2, 4.0 * t)\n              + mix(bl, c1 - 2.0 * c2 + c3, 4.0 * t - 1.0) * myStep(0.25 - eps, 0.25 + eps, t)\n              + mix(bl, c2 - 2.0 * c3 + c4, 4.0 * t - 2.0) * myStep(0.5 - eps, 0.5 + eps, t)\n              + mix(bl, c3 - 2.0 * c4 + c5, 4.0 * t - 3.0) * myStep(0.75 - eps, 0.75 + eps, t);\n    \n    return pow(cc, vec3(1.6));\n\n}\n\nconst vec2 GRADH = vec2(0.01, 0);\n\n// gradient using central differences\n#define GRAD(f, p) (0.5 * vec2(f(p - GRADH.xy) - f(p + GRADH.xy), f(p - GRADH.yx) - f(p + GRADH.yx)) / GRADH.xx)\n\n// PLOT_CONTOUR(Function, Height, Destination, Screen Position); adapted from https://www.shadertoy.com/view/4tB3WV\n#define PLOT_CONTOUR(f, z, d, p) d = mix(CONTOUR_COLOR, d, smoothstep(0.0, (CONTOUR_SIZE / iResolution.y * DISP_SCALE), abs((z - f(p))/ length(GRAD(f, p)))))\n\n// utility functions\n#define cis(a) vec2( cos(a), sin(a) )\n#define sqr(a) ((a) * (a))\n\n// function to plot\nfloat f(vec2 p)\n{\n      float x = p.x, y = p.y;\n\n      // \"peaks\" function from MATLAB (https://www.mathworks.com/help/matlab/ref/peaks.html)\n      float z = 3.0 * sqr(1.0 - x) * exp(-x * x - sqr(y + 1.0)) - 10.0 * ((0.2 - x * x) * x - y * sqr(y * y)) * exp(-x * x - y * y) - exp(-sqr(x + 1.0) - y * y)/3.0;\n        \n      return z;\n}\n\n// range of height values; the need to manually determine them is the weakness of this approach\n#define ZRANGE vec2(-6, 7)\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n        vec2 aspect = iResolution.xy / iResolution.y;\n        vec2 uv = ( fragCoord.xy / iResolution.y ) - 0.5 * aspect;\n        uv *= DISP_SCALE;\n        \n        // evaluate function\n        float z = f(uv), g = 1.0;\n        vec3 col = land(rescale(z, ZRANGE));\n\n        // plot the contour lines\n        #ifdef SHOW_CONTOURS\n        float fac = (ZRANGE.y - ZRANGE.x)/float(CONTOURS - 1);\n        for (int j = 0; j < CONTOURS; j++) PLOT_CONTOUR(f, ZRANGE.x + fac * float(j), col, uv);\n        #endif\n\n        #ifdef SHADE\n        // gradient using forward differences\n        float h = 0.5 * DISP_SCALE/iResolution.y;\n        vec2 grad = z - vec2(f(uv + vec2(h, 0.0)), f(uv + vec2(0.0, h)));\n        // uncomment to use GPU derivatives instead\n        // vec2 grad = - vec2(dFdx(z), dFdy(z));\n\n        // lighting angles for hill shading\n        float th = PI * (0.25 * iTime + 0.25);\n        float ph = 0.125 * PI * (1.0 + cos(0.5 * PI * iTime));\n        \n        // shading factor\n        g = 1.0 - 0.25 * (1.0 + cos(ph) * dot(cis(th), grad)/(pow(h, 1.2) + length(grad)));\n        #endif\n\n        col *= g;\n\n        #ifdef CLIP_EDGES\n        col = mix(DARK, col, 1.0 - step(0.5 * DISP_SCALE, abs(uv.x)));\n        #endif\n\n        fragColor = vec4( vec3(col), 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WtX3RS.jpg", "access": "shaders20k", "license": "mit", "functions": [[1825, 1825, 1850, 1850, 1929], [1931, 1931, 1967, 1967, 2034], [2036, 2036, 2078, 2078, 2187], [2189, 2310, 2353, 2353, 2453], [2475, 2475, 2495, 2495, 3151], [3702, 3722, 3739, 3739, 4056], [4182, 4182, 4239, 4239, 5510]], "test": "ok"}
{"id": "wtX3W7", "name": "Chain Reaction", "author": "eiffie", "description": "Re-uploaded: Sphere of Confusion tracing. Sampling the cone of confusion with spheres. This was based on an idea from IQ and some code help from knighty.", "tags": ["soc"], "likes": 10, "viewed": 499, "published": "Public API", "date": "1556493575", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Chain Reaction by eiffie\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n#define REFLECTIONS\n#define SHADOWS\n//#define TEXTURECUBE\n//#define CIRCLE_LINKS\n#define TWISTS 4.5\n\n// V2 added shadows and made it compile on my older machine by unrolling the code\n#define time iTime\n#define size iResolution\n#define TAO 6.2831853\nfloat focalDistance,tim,pixelSize;\nconst float aperture=0.1,shadowCone=0.5,reflectionCone=0.5,pdt=10.0/TAO,tdp=TAO/10.0;\nvec3 L;\nconst vec3 mcol=vec3(2.0,1.6,1.0);\n\nvec2 Rot2D(vec2 v, float angle) {return cos(angle)*v+sin(angle)*vec2(v.y,-v.x);}\n\nfloat Link(vec3 p, float a){\n p.xy=Rot2D(p.xy,a);\n p.y+=1.0+sin(a+tim)*0.2;\n p.yz=Rot2D(p.yz,a*TWISTS+tim);\n#ifdef CIRCLE_LINKS\n return length(vec2(length(p.xy)-0.225,p.z))-0.0225;\n#else\n return length(vec2(length(max(abs(p.xy)-vec2(0.125,0.025),0.0))-0.1,p.z))-0.02;\n#endif \n}\n\nfloat DE(in vec3 p){\n float a=atan(p.x,-p.y)*pdt;\n return min(Link(p,floor(0.5+a)*tdp),Link(p,(floor(a)+0.5)*tdp));\n}\n\nfloat CircleOfConfusion(float t){//calculates the radius of the circle of confusion at length t\n return max(abs(focalDistance-t)*aperture,pixelSize*(1.0+t));\n}\nmat3 lookat(vec3 fw,vec3 up){\n fw=normalize(fw);vec3 rt=normalize(cross(fw,up));return mat3(rt,cross(rt,fw),fw);\n}\nfloat linstep(float a, float b, float t){return clamp((t-a)/(b-a),0.,1.);}// i got this from knighty and/or darkbeam\n//random seed and generator\nfloat randSeed;\nfloat randStep(){//a simple pseudo random number generator based on iq's hash\n return  (0.8+0.2*fract(sin(++randSeed)*4375.5453123));\n}\n#ifdef SHADOWS\nfloat FuzzyShadow(vec3 ro, vec3 rd, float lightDist, float coneGrad, float rCoC){\n float t=0.0,d,s=1.0,r;\n ro+=rd*rCoC*2.0;\n for(int i=0;i<4;i++){\n  r=rCoC+t*coneGrad;d=DE(ro+rd*t)+r*0.5;s*=linstep(-r,r,d);t+=abs(d)*randStep();\n }\n return clamp(s,0.0,1.0);\n}\n#endif\nvec3 Background(vec3 rd){\n#ifdef TEXTURECUBE\n return textureCube(iChannel0,rd).rgb;\n#else\n float s=max(0.0,dot(rd,L));\n return vec3(1.0,0.5,0.25)*(s+pow(s,10.0))+rd*0.05;\n#endif\n}\n#ifdef REFLECTIONS\nvec3 FuzzyReflection(vec3 ro, vec3 rd, float coneGrad, float rCoC){\n float t=0.0,d,r;\n ro+=rd*rCoC*2.0;\n vec4 col=vec4(0.0);\n for(int i=0;i<3;i++){//had to unroll this before to get it to compile correctly?!?!\n  r=rCoC+t*coneGrad;d=DE(ro);\n  if(d<r){\n   vec2 v=vec2(r*0.1,0.0);//use normal deltas based on CoC radius\n   vec3 N=normalize(vec3(DE(ro+v.xyy)-d,DE(ro+v.yxy)-d,DE(ro+v.yyx)-d));\n   if(N!=N)N=-rd;\n   vec3 scol=mcol*(0.1+Background(reflect(rd,N)))*(0.75+0.5*dot(N,L));\n   float alpha=(1.0-col.w)* linstep(-r,r,-d);\n   col+=vec4(scol*alpha,alpha);\n  }\n  d=max(d,r*0.5)*randStep();ro+=d*rd;t+=d;\n }\n return col.rgb+Background(rd)*(1.0-clamp(col.w,0.0,1.0));\n}\n#endif\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n tim=time*2.0;\n randSeed=fract(cos((fragCoord.x+fragCoord.y*117.0+time*10.0)*473.7192451));\n pixelSize=2.0/size.y;\n vec3 ro=vec3(0.0,0.0,-2.75);\n vec3 rd=lookat(vec3(cos(tim)*0.2,-sin(tim)*0.2,0.0)-ro,vec3(0.0,1.0,0.0))*normalize(vec3((2.0*fragCoord.xy-size.xy)/size.y,2.0));\n focalDistance=length(ro);\n L=normalize(vec3(0.5,0.6,0.4));\n vec4 col=vec4(0.0);//color accumulator\n float t=2.5;//distance traveled\n ro+=rd*t;//move close to object\n for(int i=0;i<12;i++){//march loop\n  if(col.w>0.9 || t>4.0)continue;//bail if we hit a surface or go out of bounds\n  float rCoC=CircleOfConfusion(t);//calc the radius of CoC\n  float d=DE(ro);\n  if(d<rCoC){//if we are inside add its contribution\n   vec2 v=vec2(rCoC*0.1,0.0);//use normal deltas based on CoC radius\n   vec3 N=normalize(vec3(-d+DE(ro+v.xyy),-d+DE(ro+v.yxy),-d+DE(ro+v.yyx)));\n   if(N!=N)N=-rd;\n   vec3 refl=reflect(rd,N);\n   vec3 scol=mcol*(0.1+Background(refl));\n#ifdef SHADOWS\n   scol*=FuzzyShadow(ro,L,3.0,shadowCone,rCoC);\n#else\n   scol*=(0.75+0.5*dot(N,L));\n#endif\n#ifdef REFLECTIONS\n   scol+=0.5*FuzzyReflection(ro,refl,reflectionCone,rCoC);\n#endif\n   float alpha=(1.0-col.w)*linstep(-rCoC,rCoC,-d);//calculate the mix like cloud density\n   col+=vec4(scol*alpha,alpha);//blend in the new color \n  }\n  d=max(d,pixelSize)*randStep();//add in noise to reduce banding and create fuzz\n  ro+=d*rd;//march\n  t+=d;\n }//mix in background color\n col.rgb=mix(Background(rd),col.rgb,clamp(col.w,0.0,1.0));\n\n fragColor = vec4(clamp(col.rgb,0.0,1.0),1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtX3W7.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[530, 530, 563, 563, 610], [612, 612, 640, 640, 889], [891, 891, 911, 911, 1008], [1010, 1010, 1043, 1105, 1169], [1170, 1170, 1199, 1199, 1284], [1285, 1285, 1326, 1326, 1359], [1446, 1446, 1463, 1523, 1581], [1863, 1863, 1888, 1888, 2042], [2737, 2737, 2794, 2794, 4301]], "test": "timeout"}
{"id": "wtX3z4", "name": "Bubble Shuffle", "author": "MadEqua", "description": "Playing around with simple operations.", "tags": ["random", "tiling"], "likes": 6, "viewed": 442, "published": "Public API", "date": "1555723517", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float random(vec2 st) {\n    return fract(sin(dot(st, vec2(12.9898,78.233))) * 43758.5453123);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (fragCoord.xy - 0.5 * iResolution.xy) / iResolution.y; \n\tvec2 scaleUv = uv * 25.0;\n    \n    float s = 2.0 * sin(iTime * 1.5);   \n    float slideX = s * (floor(s * 0.5) + 1.0) * mix(-1.0, 1.0, mod(floor(scaleUv.y), 2.0));\n    float slideY = s * -floor(s * 0.5) * mix(-1.0, 1.0, mod(floor(scaleUv.x), 2.0));\n    scaleUv += vec2(slideX, slideY);\n    \n    vec2 flUv = floor(scaleUv);\n    vec2 frUv = fract(scaleUv);\n        \n    float t = 5.0 * iTime + random(flUv) * 100.0;\n    \n    float center = 0.55 * length(uv) + 0.45;\n    float sizeAnim = (1.0 - (sin(t) * 0.15 + 0.65)) * center;\n    float mask = smoothstep(sizeAnim, sizeAnim - 0.05, distance(frUv, vec2(0.5)));\n    \n    float r = random(flUv);\n    float g = random(flUv + 1.0);\n    float b = random(flUv - 1.0);\n    vec3 col = mask * vec3(r, g, b);\n    fragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtX3z4.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 23, 23, 95], [97, 97, 152, 152, 1004]], "test": "ok"}
{"id": "wtXGDH", "name": "Bromo", "author": "leon21062000", "description": "ga perlu", "tags": ["gungung"], "likes": 2, "viewed": 74, "published": "Public", "date": "1556197843", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float PrSphDf (vec3 p, float s);//untuk bentuk sphere\nfloat PrCylDf (vec3 p, float r, float h);//untuk bentuk cylinder\nfloat PrTorusDf (vec3 p, float ri, float rc);//untuk bentuk torus\nfloat Hashff (float p);\nfloat Noiseff (float p);//tekstur pada badan gunung\nfloat Noisefv2 (vec2 p);//tekstur tanah pada alas tanah dan badan gunung\nfloat Fbm2 (vec2 p);//efek berbatuan pada badan gunung\nvec3 VaryNf (vec3 p, vec3 n, float f);\nfloat SmoothMin (float a, float b, float r);\nfloat SmoothBump (float lo, float hi, float w, float x);\n\n#define NROCK 16\nvec4 rkPos[NROCK];\nvec3 sunDir, flmCylPos, smkPos;\nfloat dstFar, tCur, lavHt, qRad, flmCylRad, flmCylLen, smkRadEx,\n   smkRadIn, smkPhs, szFac, densFac;\nint idObj;\nconst int idMnt = 1, idRock = 2, idLav = 3;\nconst float pi = 3.14159;\nfloat time;\n\n//-----------------------------------------------------------------------------\nfloat hash( float n )\n{\n    return fract(sin(n)*43758.5453);\n}\n\n//texture asap\nfloat noise4( in vec2 x )\n{\n    vec2 p = floor(x);\n    vec2 f = fract(x);\n\n    f = f*f*(3.0-2.0*f);\n\n    float n = p.x + p.y*57.0;\n\n    float res = mix(mix( hash(n+  0.0), hash(n+  1.0),f.x),\n                    mix( hash(n+ 57.0), hash(n+ 58.0),f.x),f.y);\n\n    return res;\n}\n//fungsi untuk membuat asap \nfloat SmokeParticle(vec2 loc, vec2 pos, float size, float rnd)\n{\n\tloc = loc-pos;\n\tfloat d = dot(loc, loc)/size;\n\t\n\tif (d > 1.0) return 0.0;\n\n\t// Memutarkan particle nya\n\tfloat r= time*rnd*1.85;//untuk menggerakkan asap\n\tfloat si = sin(r);\n\tfloat co = cos(r);\n\t// Menggunakan 'rnd' untuk menggant noise.\n\td = noise4(hash(rnd*828.0)*83.1+mat2(co, si, -si, co)*loc.xy*2./(pos.y*.16)) * pow((1.-d), 3.)*.7;\n\treturn d;\n}\n\n//fungsi untuk membuat batu\nfloat RockParticle(vec2 loc, vec2 pos, float size, float rnd)\n{\n\tloc = loc-pos;\n\tfloat d = dot(loc, loc)/size;\n\tif (d > 1.0) return 0.0;\n\tfloat r= time*1.5 * (rnd);//untuk menggerakkan batu\n\tfloat si = sin(r);\n\tfloat co = cos(r);\n\td = noise4((rnd*38.0)*83.1+mat2(co, si, -si, co)*loc*143.0) * pow(1.0-d, 15.25);//rendering utama untuk batu\n\treturn pow(d, 2.)*5.;\n\t\n}\n\n\n//Gunung\nfloat MountDf (vec3 p, float dMin)\n{\n  vec3 q;\n  float d, a, r, hd, s;\n  q = p;\n  a = atan (q.z, q.x) / (2. * pi) + 0.5;\n  r = length (q.xz);\n  s = 2. * Fbm2 (vec2 (33. * a, 7. * r)) - 0.5;\n  d = PrCylDf (q.xzy, 2.0, 3.0);\n  q.y -= 0.75;\n  d = max (d, - (PrSphDf (q, 0.35) - 0.03 * s));\n  hd = 0.015 * (1. + sin (64. * pi * a) + 2. * sin (25. * pi * a)) *\n     SmoothBump (0.5, 1.8, 0.3, r) + 0.15 * s * SmoothBump (0.1, 2., 0.2, r);\n  q.y -= 1.2 + hd;\n  d = max (max (d, - PrTorusDf (q.xzy, 2.8, 2.7)), 0.4 - length (q.xz));//Mengatur ukukuran dan bentuk pada gunung\n  q = p;\n  q.y -= -0.75;\n  d = max (SmoothMin (d, PrCylDf (q.xzy, 2.5, 0.05 *\n     (1. - smoothstep (2.2, 2.5, length (q.xz)))), 0.2), - q.y);\n  if (d < dMin) { dMin = d;  idObj = idMnt; }\n  q = p;\n  q.y -= lavHt;\n  d = PrCylDf (q.xzy, 0., 0.02);\n  if (d < dMin) { dMin = d;  idObj = idLav; }\n  return 0.8 * dMin;\n}\n\nfloat ObjDf (vec3 p)\n{\n  float dMin, d;\n  dMin = dstFar;\n  dMin = MountDf (p, dMin);\n  for (int j = 0; j < NROCK; j ++) {\n    d = PrSphDf (p - rkPos[j].xyz, rkPos[j].w);\n    if (d < dMin) { dMin = d;  idObj = idRock;  qRad = rkPos[j].w; }\n  }\n  return dMin;\n}\n//pencahayaan pada gunung\nfloat ObjRay (vec3 ro, vec3 rd)\n{\n  float dHit, d;\n  dHit = 0.;\n  for (int j = 0; j < 100; j ++) {\n    d = ObjDf (ro + dHit * rd);\n    dHit += d;\n    if (d < 0.001 || dHit > dstFar) break;\n  }\n  return dHit;\n}\n\nvec3 ObjNf (vec3 p)\n{\n  vec4 v;\n  vec3 e = vec3 (0.001, -0.001, 0.);\n  v = vec4 (ObjDf (p + e.xxx), ObjDf (p + e.xyy),\n     ObjDf (p + e.yxy), ObjDf (p + e.yyx));\n  return normalize (vec3 (v.x - v.y - v.z - v.w) + 2. * v.yzw);\n}\n\n\n\n\n//background colour\nvec3 BgCol (vec3 ro, vec3 rd)\n{\n  vec3 col, vn;\n  float f;\n  if (rd.y >= 0.) {\n    col = mix (col, vec3 (0.8), clamp (3. * (f - 0.5) * rd.y + 0.1, 0., 1.));\n  } else {\n    ro -= ((ro.y + 0.75) / rd.y) * rd;\n    col = vec3 (0.17, 0.14, 0.05) * (0.7 + 0.3 * Fbm2 (10. * ro.xz));\n    f = 0.3 - smoothstep (0.1, 1., length (ro.xz) / dstFar);\n    vn = VaryNf (10. * ro, vec3 (0., 1., 0.), 3. * f);\n    col = col * (0.1 + 0.1 * max (vn.y, 0.) + 0.8 * max (dot (vn, sunDir), 0.));\n  }\n  return col;\n}\n\n\n//triger untuk ouput gunung dan tanah \nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  vec4 col4;\n  vec3 col, vn, roo;\n  float dstHit, dstFlm, dstFlmR, intFlm, bgFlm, s, dstSmk;\n \n  roo = ro;\n\n  \n  dstHit = ObjRay (ro, rd);\n  bgFlm = (5.0 + 1.0 * Noiseff (10. * tCur));//ambiance pada gunung\n \n  if (dstHit >= dstFar) col = BgCol (ro, rd);\n  else {\n    ro += dstHit * rd;\n    vn = ObjNf (ro);\n    if (idObj == idMnt) {\n      s = clamp (ro.y / 1.2 + 0.6, 0., 1.);\n      vn = VaryNf (10. * ro, vn, 5. - 2. * s);\n      col = (0.5 + 0.7 * bgFlm * s) * vec3 (0.2 + 0.1 * (1. - s),\n         0.05 + 0.2 * (1. - s), 0.05);\n      col = col * (0.1 + 0.1 * max (vn.y, 0.) +\n         0.8 * max (dot (vn, sunDir), 0.));\n    \n    \n    }\n  }\n  if (intFlm > 0.) col = mix (col, bgFlm * mix (vec3 (1., 0., 0.1),\n     vec3 (1., 1., 0.5), 0.5 * intFlm), 1.2 * intFlm);\n  ro = roo - smkPos;\n  \n  \n  col = mix (col, col4.rgb, min (col4.a, 1.));\n  return pow (clamp (col, 0., 1.), vec3 (0.7));\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  time = (iTime+1.);\n  vec4 mPtr;\n  vec3 rd, ro;\n  vec2 canvas, uv;\n  float az, el;\n  canvas = iResolution.xy;\n  uv = 2. * fragCoord.xy / canvas - 1.;\n  \n  mPtr.xy = mPtr.xy / canvas - 0.5;\n  dstFar = 30.;\n  szFac = 1.;\n\tvec3 col = vec3(0);  \n  vec2 uv1 = uv + vec2(0.,-0.21);\n    //looping partikel lava\n   for (float i = 0.0; i < 40.0; i+=1.0)\n\t{\n\t\tfloat t = time*1.3+i*(2.+hash(i*-1239.)*10.0);\n\t\tfloat sm = mod(t, 9.3)*.8;\n\t\tfloat rnd = floor(t / 9.3);\n\t\tvec2 pos = vec2(0.0, sm) *.5;\n\t\tpos.x += (hash(i*33.0+rnd)-.5)*.2 * sm*2.13;\n\t\t// Mechanics... a butchered d = vt + (1/2)at^2    ;)\n\t\tpos.y += (.1 - (.075+hash(i*30.0+rnd*36.7)*.15)*(sm*sm)*.8);\n\t\tfloat d = RockParticle(pos, uv1, .01*hash(i*1332.23)+.001, (hash(-i*42.13*rnd)-.5)*15.0);\n\t\tif (d <= 0.0) continue;\n\t\tfloat c = max(.3+abs(hash(i*11340.0))*.8+(1.0-sm*.5), 0.0);\n\t\tcol = mix(col, vec3(c,c*.2, 0.0), min(d, 1.));\n\t}\n\n\t// Looping partikel asap\n\tfor (float i = 0.0; i < 120.0; i+=1.0)\n\t{\n\t\t\n\t\tfloat t=  time+i*(10.+hash(i*-1239.)*2.0);\n\t\tfloat sm = mod(t, 8.6) *.5;\n\t\tfloat rnd = floor(t / 8.6);\n\n\t\tvec2 pos = vec2(0.0, sm) *.5;\n\t\tpos.x += (hash(i)-.5)*.2 * uv1.y*5.13;\n\t\tfloat d = SmokeParticle(pos, uv1, .03*hash(i*1332.23+rnd)+.001+sm*0.03, hash(i*rnd*2242.13)-0.5);\n\t\tif (d <= 0.0) continue;\n\t\td = d* max((3.0-(hash(i*1127.0)*1.5) - sm*.63), 0.0);\n\t\tfloat c = abs(hash(i*4.4));\n\t\t// warna pada asap\n\t\tcol= mix(col, vec3(c*.35, c*.3, c*.25), min(d, 1.0));\n\t\t// Semburan lava\n\t\tcol = mix(col, vec3(.52, .25, 0.0), max((d-1.05)*1.0, 0.0));\n\t}\n  ro = vec3 (0., 1. * smkPhs * (1. - smoothstep (0.9, 1., smkPhs)), -8.);\n  rd = normalize (vec3 (uv, 4.8));\n    \n \n  uv = ((fragCoord.xy/iResolution.xy));\n  vec3 test= ShowScene (ro, rd);\n  el = clamp (el, -0.01 * pi, 0.25 * pi);\n  sunDir = normalize (vec3 (5., 2., 1.));\n  vec3 col1 = col + ShowScene(ro,rd);\n  \n  fragColor = vec4 (col1 , 1.);\n}\n//membuat bentuk sphere\nfloat PrSphDf (vec3 p, float s)\n{\n  return length (p) - s;\n}\n\nfloat PrCylDf (vec3 p, float r, float h)//membuat bentuk silinder\n{\n  return max (length (p.xy) - r, abs (p.z) - h);\n}\n//Fungsi torus\nfloat PrTorusDf (vec3 p, float ri, float rc)//membuat bentuk torus\n{\n  return length (vec2 (length (p.xy) - rc, p.z)) - ri;\n}\n\nconst float cHashM = 43758.54;\n\nfloat Hashff (float p)\n{\n  return fract (sin (p) * cHashM);\n}\n\nvec2 Hashv2f (float p)\n{\n  return fract (sin (p + vec2 (0., 2.)) * cHashM);\n}\n\nvec2 Hashv2v2 (vec2 p)\n{\n  vec2 cHashVA2 = vec2 (37., 39.);\n  vec2 e = vec2 (1., 0.);\n  return fract (sin (vec2 (dot (p + e.yy, cHashVA2), dot (p + e.xy, cHashVA2))) * cHashM);\n}\n\nvec4 Hashv4v3 (vec3 p)\n{\n  vec3 cHashVA3 = vec3 (37., 39., 41.);\n  vec2 e = vec2 (1., 0.);\n  return fract (sin (vec4 (dot (p + e.yyy, cHashVA3), dot (p + e.xyy, cHashVA3),\n     dot (p + e.yxy, cHashVA3), dot (p + e.xxy, cHashVA3))) * cHashM);\n}\n\nfloat Noiseff (float p)//tekstur untuk gunung\n{\n  vec2 t;\n  float ip, fp;\n  ip = floor (p); \n  fp = fract (p);\n  fp = fp * fp * (5. - 2. * fp);\n  t = Hashv2f (ip);\n  return mix (t.x, t.y, fp);\n}\n\nfloat Noisefv2 (vec2 p)//tekstur tanah pada badan gunung dan kaki gunung\n{\n  vec2 t, ip, fp;\n  ip = floor (p);  \n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = mix (Hashv2v2 (ip), Hashv2v2 (ip + vec2 (0., 1.)), fp.y);\n  return mix (t.x, t.y, fp.x);\n}\n\n\nfloat Fbm2 (vec2 p)//efek berbatuan pada badan gunung\n{\n  float f, a;\n  f = 0.;\n  a = 1.;\n  for (int i = 0; i < 5; i ++) {\n    f += a * Noisefv2 (p);\n    a *= 0.5;\n    p *= 2.;\n  }\n  return f * (1. / 1.9375);\n}\n\n\n\nfloat Fbmn (vec3 p, vec3 n)//efek grainny pada gunung\n{\n  vec3 s;\n  float a;\n  s = vec3 (0.);  \n  a = 1.;\n  for (int i = 0; i < 5; i ++) {\n    s += a * vec3 (Noisefv2 (p.yz), Noisefv2 (p.zx), Noisefv2 (p.xy));\n    a *= 0.5;  \n    p *= 2.;\n  }\n  return dot (s, abs (n));\n}\n\nvec3 VaryNf (vec3 p, vec3 n, float f)\n{\n  vec3 e = vec3 (0.1, 0., 0.);\n  vec3 g;\n  float s;\n  s = Fbmn (p, n);\n  g = vec3 (Fbmn (p + e.xyy, n) - s, Fbmn (p + e.yxy, n) - s, Fbmn (p + e.yyx, n) - s);\n  return normalize (n + f * (g - n * dot (n, g)));\n}\n\n\n\nfloat SmoothMin (float a, float b, float r)//fungsi ini agar bentuk gunung tetap kerucut\n{\n  float h;\n  h = clamp (0.5 + 0.5 * (b - a) / r, 0., 1.);\n  return mix (b, a, h) - r * h * (1. - h);\n}\n\nfloat SmoothBump (float lo, float hi, float w, float x)//mengatur kedalaman pada tekstur batu di gunung\n{\n  return (1. - smoothstep (hi - w, hi + w, x)) * smoothstep (lo - w, lo + w, x);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtXGDH.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[795, 875, 898, 898, 937], [939, 954, 981, 981, 1229], [1230, 1259, 1323, 1323, 1674], [1676, 1704, 1767, 1767, 2070], [2073, 2082, 2118, 2118, 2965], [2967, 2967, 2989, 2989, 3226], [3227, 3253, 3286, 3286, 3462], [3464, 3464, 3485, 3485, 3692], [3697, 3717, 3748, 3748, 4210], [4213, 4252, 4287, 4287, 5176], [5178, 5178, 5234, 5234, 7094], [7095, 7119, 7152, 7152, 7179], [7181, 7181, 7248, 7248, 7299], [7300, 7315, 7383, 7383, 7440], [7474, 7474, 7498, 7498, 7535], [7537, 7537, 7561, 7561, 7614], [7616, 7616, 7640, 7640, 7794], [7796, 7796, 7820, 7820, 8040], [8042, 8042, 8089, 8089, 8236], [8238, 8238, 8312, 8312, 8498], [8501, 8501, 8556, 8556, 8711], [8715, 8715, 8770, 8770, 8986], [8988, 8988, 9027, 9027, 9239], [9243, 9243, 9333, 9333, 9436], [9438, 9438, 9543, 9543, 9626]], "test": "error"}
{"id": "wtXGDM", "name": "Ride to Heaven", "author": "MadEqua", "description": "Trying to raymarch a somewhat complex scene. And some cel-shading. :)\n\nUse the mouse to control the camera.", "tags": ["raymarching", "celshading", "toonshading"], "likes": 9, "viewed": 427, "published": "Public API", "date": "1556480452", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define MAT_RAILS 0\n#define MAT_BARS 1\n#define MAT_CART 2\n#define MAT_TERRAIN 3\n#define MAT_CART_BOLTS 4\n#define MAT_RAIL_BOLTS 5\n#define MAT_EDGE 6\n#define MAT_TREE 7\n\n#define PRIMARY_STEPS 256\n#define SHADOW_STEPS 32\n\n#define EPSILON 0.001\n#define MAX_DIST 1750.\n\n#define CEL_SHADES 6.\n#define EDGE_THICKNESS 0.01\n#define EDGE_MAX_DIST 1000.\n\nfloat time;\n\nstruct Light {\n    vec3 dir;\n    vec3 diffColor;\n    vec3 specColor;\n};\n\nstruct Material {\n    vec3 diffColor;\n    vec3 specColor;\n    float shininess;\n};\n\nstruct ScenePoint {\n    int materialId; //Material of closest object\n    float d; //Distance to closest object\n    float t; //Distance on ray that generated this point\n};\n\nLight lights[3];\nMaterial materials[8];\n\n\nfloat rand(float v) {\n    return fract(sin(v) * 5364.54367);\n}\n\nfloat rand(vec2 p) {\n    return fract(sin(dot(p.xy, vec2(12.9898, 78.233))) * 47851.5453123);\n}\n\nfloat noise(vec2 p){\n    vec2 i = floor(p);\n    vec2 f = fract(p);\n    \n    float a = rand(i);\n    float b = rand(i + vec2(1., 0.));  \n    float c = rand(i + vec2(0., 1.)); \n    float d = rand(i + vec2(1., 1.)); \n    \n    float ab = mix(a, b, smoothstep(0., 1., f.x));\n    float cd = mix(c, d, smoothstep(0., 1., f.x));\n    return mix(ab, cd, smoothstep(0., 1., f.y));\n}\n\nfloat fbm(vec3 p) {\n    float v = 0.;\n    float amplitude = .5;\n    float freq = 0.;\n    \n    for(int i = 0; i < 2; ++i) {\n        v += amplitude * noise(p.xz);\n        p *= 2.;\n        amplitude *= .5;\n    }\n    return v;\n}\n\nvec3 cam2world(vec3 v, vec3 pos, vec3 lookAt) {\n    vec3 z = normalize(lookAt - pos);\n    vec3 y = vec3(0, 1, 0);\n    vec3 x = normalize(cross(z, y));\n    y = normalize(cross(x, z));\n    mat3 m = mat3(x, y, z);\n    return normalize(m * v);\n}\n\nfloat sphere(vec3 p, float r) {\n     return length(p) - r;\n}\n\nfloat box(vec3 p, vec3 b)  {\n    vec3 d = abs(p) - b;\n    return length(max(d, 0.)) + min(max(d.x, max(d.y, d.z)), 0.);\n}\n\nfloat roundBox(vec3 p, vec3 b, float r) {\n    vec3 d = abs(p) - b;\n    return length(max(d, 0.)) - r + min(max(d.x, max(d.y, d.z)), 0.);\n}\n\nfloat plane(vec3 p, vec3 n, float d)  {\n    return dot(p, n) - d;\n}\n\nfloat roundCone( vec3 p, float r1, float r2, float h) {\n    vec2 q = vec2(length(p.xz), p.y);\n    float b = (r1 - r2) / h;\n    float a = sqrt(1.0 - b * b);\n    float k = dot(q, vec2(-b, a));\n    if(k < 0.) return length(q) - r1;\n    if(k > a * h) return length(q - vec2(0., h)) - r2;\n    return dot(q, vec2(a, b) ) - r1;\n}\n\nvec3 repeat(vec3 p, vec3 period) {\n    return mod(p, period) - .5 * period;\n}\n\nfloat smoothUnion(float v1, float v2, float k) {\n    float h = clamp(.5 + .5 * (v2 - v1) / k, 0., 1.);\n    return mix(v2, v1, h) - k * h * (1. - h); \n}\n\nfloat hills(float z) {\n    z -= time;\n    return sin(z / 128.) * cos(z / 64.) * 6.;\n}\n\nvec3 sky(vec3 originalColor, float dist, vec3 rd) {\n    const vec3 SKY_COLOR = vec3(.2, .4, 1.);\n    \n    vec3 sunDir = -lights[0].dir;\n    float skyAmmount = smoothstep(5., 25., dist) * (1. - exp(-dist * 0.012));\n    float sunAmmount = max(dot(rd, sunDir), 0.);\n\n    vec3 diff = sunDir - rd;\n    float rays = smoothstep(-1., 1., sin(atan(diff.y, diff.x) * 8. + time * .3)) * .35;\n    rays *= step(MAX_DIST * .5, dist);\n    rays = min(rays, length(diff * .3));\n\n    vec3 skyCol = mix(SKY_COLOR, lights[0].diffColor, pow(sunAmmount, 50.) + rays);\n    return mix(originalColor, skyCol, skyAmmount);\n}\n\nScenePoint scene(vec3 p) {\n    ScenePoint result;\n\n    p.y -= hills(p.z);\n\n    //Rails\n    vec3 xMirrorP = p;\n    xMirrorP.x = abs(xMirrorP.x);\n\n    float rails = box(xMirrorP - vec3(1.5, 0., 0.), vec3(.12, .2, 999.));\n    rails = max(rails, -box(xMirrorP - vec3(1.4, 0., 0.), vec3(.06, .15, 999.)));\n    result.materialId = MAT_RAILS;\n    result.d = rails;\n    \n    //Bars\n    vec3 scrollP = p;\n    scrollP.z = scrollP.z - time;\n    \n    vec3 repeatedP = scrollP;\n    repeatedP.z = repeat(repeatedP, vec3(1, 1, 2)).z;\n    \n    vec3 xMirrorRepP = repeatedP;\n    xMirrorRepP.x = abs(xMirrorRepP.x);\n    \n    repeatedP.x += rand(floor(scrollP.z + .5)) * .5 - .25;\n    float bars = box(repeatedP - vec3(0, -.4, 0), vec3(2.4, .18, .2));\n    if(bars < result.d) {\n        result.materialId = MAT_BARS;\n        result.d = bars;\n    }\n\n    //Bar bolts\n    float bolts = sphere(xMirrorRepP - vec3(1.44, -.15, 0.1), .05);\n    if(bolts < result.d) {\n        result.materialId = MAT_RAIL_BOLTS;\n        result.d = bolts;\n    }\n    \n    //Cart\n    const float cartZ = 19.4;\n    float cart = roundBox(p - vec3(0., .8, cartZ), vec3(1.2, 1., 1.), .15);\n    cart = max(cart, -roundBox(p - vec3(0., 1., cartZ), vec3(.9, 1., .7), .1));\n    cart = max(cart, -roundBox(p - vec3(0., 1., cartZ), vec3(1., .65, .65), .16));\n    cart = min(cart, box(p - vec3(0., 1., cartZ - 0.84), vec3(.75, .5, .05)));\n    if(cart < result.d) {\n        result.materialId = MAT_CART;\n        result.d = cart;\n    }\n\n    //Cart bolts\n    vec3 cartBoltsP = p;\n    cartBoltsP.x *= step(-1.1, cartBoltsP.x) * step(cartBoltsP.x, 1.1);\n    cartBoltsP.x = repeat(cartBoltsP, vec3(.25, 1., 1.)).x;\n    float cartBolts = sphere(cartBoltsP - vec3(0., 1.83, cartZ - .76), .02);\n\n    vec3 cartBoltsP2 = p;\n    cartBoltsP2.x = abs(cartBoltsP2.x);\n    cartBoltsP2.y = abs(cartBoltsP2.y - 1.05);\n    cartBolts = min(cartBolts, sphere(cartBoltsP2 - vec3(0.63, .35, cartZ - .76), .02));\n    if(cartBolts < result.d) {\n        result.materialId = MAT_CART_BOLTS;\n        result.d = cartBolts;\n    }\n\n    //Terrain\n    vec3 terrP = scrollP;\n    float ridge = smoothstep(2., 10., terrP.x) + smoothstep(-2., -10., terrP.x);\n    terrP.y -= ridge * (sin(terrP.z * .02) * 2. + 8.);\n\n    terrP.x -= sin(terrP.z * .65) * 2.;\n    terrP.y -= fbm(terrP) * (ridge + .3);\n\n    float terr = plane(terrP, vec3(0., 1., 0.), -.45);\n    if(terr < result.d) {\n        result.materialId = MAT_TERRAIN;\n        result.d = smoothUnion(result.d, terr, .05);\n\n        float n = noise(vec2(p.x, terrP.z) * 1.2);\n        vec3 c = mix(vec3(.1, .9, .15), vec3(0., .85, .2), smoothstep(.3, .5, n));\n        materials[MAT_TERRAIN].diffColor = mix(vec3(.6, .35, .33), c, pow(ridge, .4));\n    }\n\n    //Trees\n    vec3 treeP = vec3(p.x, terrP.y, scrollP.z);\n    treeP.x = abs(treeP.x);\n    treeP -= vec3(11.5, 2.9, 0.);\n\n    const float cells = 27.;\n    treeP.z = repeat(treeP, vec3(1., 1., cells)).z;\n    vec2 id = floor(vec2(step(p.x, .0), scrollP.z / cells));\n\n    float r = rand(id);\n    float r2 = rand(id + vec2(12.23, 42.25));\n    float r3 = rand(id - vec2(76.432, 980.543));\n\n    float tree = roundCone(treeP, (r + .3) * 2.5, (r2 + .45) * 1.4, (r3 + .4) * 3.2);\n    if(tree < result.d) {\n        result.materialId = MAT_TREE;\n        result.d = tree;\n        materials[MAT_TREE].diffColor = mix(vec3(.8, .3, .15), vec3(.15, .95, .15), r2);\n    }\n    tree = min(tree, box(treeP - vec3(0., -2., 0.), vec3(.2, 2., .2)));\n    if(tree < result.d) {\n        result.materialId = MAT_BARS;\n        result.d = tree;\n    }\n    \n    return result;\n}\n\nbool rm(int steps, vec3 ro, vec3 rd, out ScenePoint sp) {\n    float t = 0.;\n    float minD = 99999.;\n    \n    for(int i = 0; i < steps && t < MAX_DIST; ++i) {\n        vec3 p = ro + rd * t;\n        sp = scene(p);\n        sp.t = t;\n        if(sp.d < EPSILON)\n            return true;\n        \n        //Edge detection\n        minD = min(sp.d, minD);\n        if(sp.d > minD && minD < EDGE_THICKNESS * (1. - (t / EDGE_MAX_DIST))) {\n            sp.materialId = MAT_EDGE;\n            return true;\n        }\n        \n        t += sp.d;\n    }\n    return false;\n}\n\nvec3 normal(vec3 p, ScenePoint sp) {\n    vec2 e = vec2(EPSILON, 0.);\n    //float d = scene(p).d;\n    float x = scene(p - e.xyy).d;\n    float y = scene(p - e.yxy).d;\n    float z = scene(p - e.yyx).d;\n    return normalize(vec3(sp.d) - vec3(x, y, z));\n}\n\nvec3 shade(vec3 cameraPos, vec3 rd, ScenePoint sp) {\n    if(sp.materialId == MAT_EDGE) {\n        vec3 c = materials[MAT_EDGE].diffColor;\n        return mix(c, c * .01, smoothstep(.0, 1., sp.d / EDGE_THICKNESS));\n    }\n    \n    vec3 albedo = materials[sp.materialId].diffColor;\n    vec3 specular = materials[sp.materialId].specColor;\n    float shininess = materials[sp.materialId].shininess;\n    \n    vec3 p = cameraPos + rd * sp.t;\n    vec3 N = normal(p, sp);\n    vec3 V = normalize(cameraPos - p);\n    \n    vec3 sum = vec3(0);\n    for(int i = 0; i < 3; ++i) {\n    \n        vec3 L = -lights[i].dir;\n        vec3 H = normalize(V + L);\n    \n        float difFactor = max(0., dot(L, N));\n        difFactor = ceil(difFactor * CEL_SHADES) / CEL_SHADES;\n    \n        float specFactor = pow(max(0., dot(H, N)), shininess);\n        specFactor = ceil(specFactor * CEL_SHADES) / CEL_SHADES;\n        \n        sum += lights[i].diffColor * albedo * difFactor +\n            lights[i].specColor * specular * specFactor;\n    }\n    \n    ScenePoint shadowSp;\n    bool hit = rm(SHADOW_STEPS, p + N * (EDGE_THICKNESS + EPSILON), -lights[0].dir, shadowSp);\n    if(hit) {\n        sum *= vec3(.8);\n    }\n    return sum;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n     time = iTime * 8.;\n\n    //Sun Key\n    lights[0].dir = normalize(vec3(0., -.05, 1.));\n    lights[0].diffColor = vec3(.95, .95, .9);\n    lights[0].specColor = vec3(1.);\n    //Sun Fill\n    lights[1].dir = normalize(vec3(1., -1., -.6));\n    lights[1].diffColor = vec3(.7, .6, .6);\n    lights[1].specColor = vec3(0.);\n    //Sun Fill\n    lights[2].dir = normalize(vec3(-1., -1., -.6));\n    lights[2].diffColor = vec3(.7, .6, .6);\n    lights[2].specColor = vec3(0.);\n\n    materials[MAT_RAILS].diffColor = vec3(.1, .1, .05);\n    materials[MAT_RAILS].specColor = vec3(.7);\n    materials[MAT_RAILS].shininess = 10.;\n\n    materials[MAT_BARS].diffColor = vec3(.1, .077, .05);\n    materials[MAT_BARS].specColor = vec3(0.);\n    materials[MAT_BARS].shininess = 1.;\n\n    materials[MAT_CART].diffColor = vec3(.9, .55, .25);\n    materials[MAT_CART].specColor = vec3(.7);\n    materials[MAT_CART].shininess = 20.;\n\n    //materials[MAT_TERRAIN].diffColor = vec3(0.); Dynamically generated\n    materials[MAT_TERRAIN].specColor = vec3(0.);\n    materials[MAT_TERRAIN].shininess = 1.;\n\n    materials[MAT_CART_BOLTS].diffColor = vec3(.5, .35, .21);\n    materials[MAT_CART_BOLTS].specColor = vec3(.2);\n    materials[MAT_CART_BOLTS].shininess = 20.;\n\n    materials[MAT_RAIL_BOLTS].diffColor = vec3(.05, .05, .05);\n    materials[MAT_RAIL_BOLTS].specColor = vec3(.7);\n    materials[MAT_RAIL_BOLTS].shininess = 10.;\n\n    materials[MAT_EDGE].diffColor = vec3(0.1);\n    materials[MAT_EDGE].specColor = vec3(.0);\n    materials[MAT_EDGE].shininess = 1.;\n\n    //materials[MAT_TREE].diffColor = vec3(.0); Dynamically generated\n    materials[MAT_TREE].specColor = vec3(.0);\n    materials[MAT_TREE].shininess = 1.;\n\n    vec2 uv = (gl_FragCoord.xy - .5 * iResolution.xy) / iResolution.y;\n\n    vec3 cameraPos = vec3(0., 2.5 + hills(19.1), 20.);   \n    vec3 lookAt = vec3(sin(time * .05) * 1.3, 0.5, 0.);\n    if(iMouse.z > .0)\n    \tlookAt.xy = vec2(15., 25.) * ((iMouse.xy / iResolution.xy) - vec2(.5));\n    \n    vec3 rd = cam2world(vec3(uv, 1.5), cameraPos, lookAt); \n\n    ScenePoint sp;\n    vec3 col = vec3(.4);\n\n    bool hit = rm(PRIMARY_STEPS, cameraPos, rd, sp);\n    if(hit) {\n        col = shade(cameraPos, rd, sp);\n    }\n\n    col = sky(col, sp.t, rd);\n\n    col = pow(col, vec3(1. / 2.2));\n    fragColor = vec4(col, 1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtXGDM.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[728, 728, 749, 749, 790], [792, 792, 812, 812, 887], [889, 889, 909, 909, 1259], [1261, 1261, 1280, 1280, 1485], [1487, 1487, 1534, 1534, 1728], [1730, 1730, 1761, 1761, 1790], [1792, 1792, 1820, 1820, 1913], [1915, 1915, 1956, 1956, 2053], [2055, 2055, 2094, 2094, 2122], [2124, 2124, 2179, 2179, 2446], [2448, 2448, 2482, 2482, 2525], [2527, 2527, 2575, 2575, 2678], [2680, 2680, 2702, 2702, 2765], [2767, 2767, 2818, 2818, 3365], [3367, 3367, 3393, 3393, 6921], [6923, 6923, 6980, 6980, 7477], [7479, 7479, 7515, 7515, 7729], [7731, 7731, 7783, 7783, 8929], [8931, 8931, 8986, 8986, 11278]], "test": "timeout"}
{"id": "wtXGDN", "name": "Yurei - additive colours", "author": "Chosen", "description": "Noticed there were artifacts at the shape edges and due the order of application.\nTwo modes to try. Change background colour.\nPrevious https://www.shadertoy.com/view/wtfGWN\nOriginal https://www.shadertoy.com/view/wlf3RM", "tags": ["test", "colours"], "likes": 3, "viewed": 184, "published": "Public", "date": "1556342537", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// These aren't used much, are you planning to do something interesting?\nvec2 spread = vec2(.3);\nvec2 offset = vec2(0.);\nfloat shapeSize = .3;\nconst float s = 1.;\n\nconst int MAX_SHAPES = 3;\nvec3 shapeColors[MAX_SHAPES] = vec3[MAX_SHAPES] (  \n  vec3(s, 0., 0.),\n  vec3(0., s, 0.),\n  vec3(0., 0., s)\n);\n\nvec2 motionFunction (float i) {\n  float t = iTime;\n\n  return vec2(\n    (cos(t * .31 + i * 3.) + cos(t * .11 + i * 14.) + cos(t * .78 + i * 30.) + cos(t * .55 + i * 10.)) / 4.,\n    (cos(t * .13 + i * 33.) + cos(t * .66 + i * 38.) + cos(t * .42 + i * 83.) + cos(t * .9 + i * 29.)) / 4.\n  );\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord) {\n    vec2 pixel = (fragCoord - .5 * iResolution.xy) / iResolution.x;\n    // Change include_background to 0 or 1 to try 2 different modes\n    // I didn't use #define as I'm not sure if you are familiar with those\n    int include_background = 0;\n    \n    // With include_background == 1 and a pure white background, you don't see the shapes,\n    // but try other colours\n    vec3 background = vec3(.2, .5, .7);\n    vec4 totalColor;\n    \n    if(include_background == 0)\n\t    // Create a colour to add to mix with background later. Initialise to 0.\n    \ttotalColor = vec4(0.);\n    else\n\t    // Initialise with background colour\n    \ttotalColor = vec4(background, 0.);\n    \n    for (int i = 0; i != MAX_SHAPES; ++i) {\n        vec2 shapeCenter = motionFunction(float(i)) * spread + offset;\n        float ratio = smoothstep(0., 1., distance(shapeCenter, pixel) / shapeSize);\n//      float ratio = clamp(distance(shapeCenter, pixel) / shapeSize, 0., 1.);\n\n        // Additive colour\n        totalColor += vec4(mix(shapeColors[i], vec3(0.), ratio), 1. - ratio);\n    }\n\n    totalColor = clamp(totalColor, 0., 1.);\n    if(include_background == 0){\n        // Mix the combined colour with the background\n        // Similar to Photoshop - Linear Dodge (Add) ?\n        totalColor.rgb = mix(background, totalColor.rgb, totalColor.a);    \n    } \n    \n    fragColor = vec4(\n        // Approximately convert to sRGB colourspace with sqrt()\n        sqrt(totalColor.rgb),\n        1.\n    );\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtXGDN.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[302, 302, 333, 333, 592], [594, 594, 650, 650, 2121]], "test": "ok"}
{"id": "wtXGDr", "name": "Assim2", "author": "deaths_angel", "description": "v2 https://www.shadertoy.com/view/tsj3Rh", "tags": ["loading", "hypnotising"], "likes": 1, "viewed": 101, "published": "Public", "date": "1556039168", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord.xy-iResolution.xy*.5)/iResolution.y;\n    float Time = sin(iTime); \n\tuv *=\n        mat2(.71+ ((.145 + (0.1*sin(iTime))) * 0.1*iTime ) ,\n             -.707 -((.155 + (0.31*cos(iTime+0.2)))* 0.1*iTime), \n             .701+ (((tan(iTime) *0.125) + (0.1*sin(iTime)))* 0.1*iTime), \n             .707+ ((1.105+ (0.1*sin(iTime)))* 0.1*iTime)); \n    uv *= 15.;\n\n    vec2 gv = fract(uv)-.5; \n    vec2 id = floor(uv);\n\n\n    vec4 mc = vec4(0,0,0,0);\n    float t;\n    for(float y=-1.; y<=-1.; y++) {\n        for(float x=-1.; x<=2.; x++) {\n            vec2 offs = vec2(x*1.5f, y );\n\n            t = -(iTime +5.0f)+length(id-offs)* 0.35; \n            float r = mix(.375, .81, sin(t)*0.85);\n              float r2 = mix(.88, .35, sin(t + 0.15)*.75); \n            float r3 = mix(.88, 1.05, sin(t + 0.25) *.95);\n            float c = smoothstep(r * 1.7, r * 0.9, length(gv+offs));\n            mc.x = mc.x*(1.0-c) + c*(1.-mc.x) * 1.3 * ( r2 );\n            mc.y = mc.y*(1.-c) + c*(1.-mc.y)* 1.7 * r;\n            mc.z = mc.z*(1.-c) + c*(1.-mc.z) * 1.3* r3;\n            mc.a = mc.a*(1.-c) + c*(1.-mc.a); \n        } \n    } \n    \t\n    \t\tmc *= 2.875; \n   mc *= 0.3*mc; \n    \n    fragColor = mc; \n\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtXGDr.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 1256]], "test": "ok"}
{"id": "wtXGzS", "name": "Folding space", "author": "MacSlow", "description": "For the most part this is an exercise in trying out folding of space... with a bit of basic toon- and blinn/phong-shading.", "tags": ["3d", "phong", "ray", "sdf", "sphere", "shading", "marching", "folding", "ao", "tracing", "blinn", "toon"], "likes": 9, "viewed": 502, "published": "Public API", "date": "1556659394", "time_retrieved": "2021-10-01T00:00:00", "image_code": "////////////////////////////////////////////////////////////////////////////////\n//\n// Space folding exercise - Learning experience with regards to folding space\n// and playing a bit with different shading methods.\n//\n// Copyright 2019 Mirco Müller\n//\n// Author(s):\n//   Mirco \"MacSlow\" Müller <macslow@gmail.com>\n//\n// This program is free software: you can redistribute it and/or modify it\n// under the terms of the GNU General Public License version 3, as published\n// by the Free Software Foundation.\n//\n// This program is distributed in the hope that it will be useful, but\n// WITHOUT ANY WARRANTY; without even the implied warranties of\n// MERCHANTABILITY, SATISFACTORY QUALITY, or FITNESS FOR A PARTICULAR\n// PURPOSE.  See the GNU General Public License for more details.\n//\n// You should have received a copy of the GNU General Public License along\n// with this program.  If not, see <http://www.gnu.org/licenses/>.\n//\n////////////////////////////////////////////////////////////////////////////////\n\nmat2 r2d (float deg)\n{\n    float r = radians (deg);\n    float c = cos (r);\n    float s = sin (r);\n    return mat2 (c, s, -s, c);\n}\n\nvec3 smin (vec3 d1, vec3 d2, float k)\n{\n    vec3 h = clamp (.5 + .5*(d2 - d1)/k, .0, 1.);\n    return mix (d2, d1, h) - h*k*(1. - h);\n}\n\nfloat vary (float v, float s)\n{\n    return v*(.5 + .5*cos(s*iTime));\n}\n\n// ollj suggested map() variation, which lets you control smooth-minimum distance and\n// cube edge-radius with the mouse\nfloat map (vec3 p, out int id)\n{\n    float t = iTime*.5;\n    float s = 3.;\n    for(float i = .0; i < 5.; i += 1.) {\n        p.xz *= r2d (degrees(t + i));\n        p.xy *= r2d (degrees(-t*.4 - i));\n        p = smin (p, -p, -.25-3.*iMouse.x/iResolution.x);\n        p -= s; s *= .625;\n    }\n    vec3 size = vec3 (.4);\n    float d = length (max (vec3 (.0), abs (p) - size))-iMouse.y/iResolution.y;\n    id = 3;\n    return d;\n}\n\n// my original version of map()\nfloat map2(vec3 p, out int id)\n{\n\tfloat t = iTime*.5;\n\tfloat s = 3.;\n\tfor(float i = .0; i < 5.; i += 1.) {\n\t\tp.xz *= r2d (degrees(t + i));\n\t\tp.xy *= r2d (degrees(-t*.4 - i));\n\t\tp = smin (p, -p, -1.25);\n\t\tp -= s;\n\t\ts *= .625;\n\t}\n\tvec3 size = vec3 (.4);\n    float d = length (max (vec3 (.0), abs (p) - size)) - .1;\n    id = 3;\n    return d;\n}\n\nfloat march (vec3 ro, vec3 rd, out int id, out int iter)\n{\n\tfloat t = .0;\n\tfloat d = .0;\n\tfor (int i = 0;i < 48; ++i) {\n\t\titer = i;\n\t\tt = map(ro + d*rd, id);\n\t\tif (abs(t) < .01*(1. + .125*t)) break;\n\t\td += t*.95;\n\t}\n\treturn d;\n}\n\nvec3 normal (vec3 p)\n{\n    int ignored;\n    vec2 e = vec2 (.001, .0);\n    float d = map (p, ignored);\n    return normalize (vec3 (map (p + e.xyy, ignored),\n                            map (p + e.yxy, ignored),\n                            map (p + e.yyx, ignored)) - d);\n}\n\nfloat shadow (vec3 p, vec3 ldir, vec3 n, float ldist)\n{\n    int ignored;\n    int ignored2;\n    float d2w = march (p + .01*n, ldir, ignored, ignored2);\n    return ldist < d2w ? 1. : .25;\n}\n\nfloat ao (vec3 p, vec3 n, float d)\n{\n\tint ignored;\n\treturn clamp (map (p + d*n, ignored)/d, .0, 1.);\n}\n\nvec3 shade (vec3 rd, vec3 p, vec3 n, vec3 lp, vec3 lc, float li, int id)\n{\n    vec3 am = vec3(.1);\n    float ldist = distance (lp, p);\n    float att = 800./(ldist*ldist);\n    vec3 ldir = normalize(lp - p);\n    vec3 h = normalize(-rd + ldir);\n    float s = shadow(p, ldir, n, ldist);\n    vec3 mat = vec3(.3);\n    float shiny = 80.;\n    if (id == 3){ mat = vec3 (1.,.5,.25); shiny = 70.;}\n    float sp = pow (max (.0, dot (n, h)), shiny);\n    float diff = max (.0, dot (n, ldir));\n    float ao = ao (p, n, 1.5);\n\n    return att*s*(am + ao*diff*li*lc*mat + sp*vec3 (1.));\n}\n\nvec3 gradient (float value) {\n\tvec3 color = vec3 (.2);\n\tif (value > .0 && value < .2) {\n\t\tcolor = vec3 (.3, .4, .5);\n\t} else if (value >= .2 && value < .4) {\n\t\tcolor = vec3 (.35, .5, .7);\n\t} else if (value >= .4 && value < .7) {\n\t\tcolor = vec3 (.4, .6, .8);\n\t} else if (value >= .7 && value < .9) {\n\t\tcolor = vec3 (.5, .7, .85);\n\t} else if (value >= .9) {\n\t\tcolor = vec3 (.85, .9, .95);\n\t}\n\treturn color;\n}\n\nvec3 shadeToon (vec3 p, vec3 n, vec3 lp, vec3 rd)\n{\n\tvec3 ldir=normalize(lp-p);\n\tfloat diff=max(.0,dot(n,ldir));\n\tvec3 color = gradient (diff);\n\tvec3 outline = vec3 (.0);\n\n    return color;\n}\n\nvec3 camera (vec2 uv, vec3 ro, vec3 aim, float z)\n{\n    vec3 f = normalize (aim - ro);\n    vec3 wu = vec3 (.0, 1., .0);\n    vec3 r = normalize (cross (wu, f));\n    vec3 u = normalize (cross (f, r));\n    vec3 c = ro + f*z;\n\n    return normalize (c + r*uv.x + u*uv.y - ro);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy/iResolution.xy*2.-1.;\n    float aspect = iResolution.x/iResolution.y;\n    uv.x *= aspect;\n\n    vec3 ro = vec3 (4., 0.5, 33.);\n    vec3 aim = vec3 (.0);\n    float zoom = 2.25;\n    vec3 rd = camera (uv, ro, aim, zoom);\n\n    int id=0;\n\tint iter=0;\n    float d=march(ro,rd,id,iter);\n\tfloat fog=1./(1.+d*d*.05);\n    vec3 p=ro+d*rd;\n    vec3 n=normal(p);\n\n    // light one\n    vec3 lp1=vec3(10.,20.,30.);\n    lp1.xz*=r2d(vary(45.,2.));\n    vec3 lc1=vec3(.9,.8,.7);\n    float li1=24.;\n\n    // light two\n\tvec3 lp2=vec3(-10.,5.,30.);\n    lp2.yz*=r2d(vary(45.,2.));\n    vec3 lc2=vec3(.7,.8,.9);\n    float li2=20.;\n\n    // light three\n\tvec3 lp3=vec3(-8.,-20.,30.);\n    lp3.xy*=r2d(vary (45.,2.));\n    vec3 lc3=vec3(.2,.3,.9);\n    float li3=22.;\n\n    vec3 c;\n\tif (uv.x < uv.y*aspect - .01) {\n    \tc = shade (rd, p, n, lp1, lc1, li1, id);\n    \tc += shade (rd, p, n, lp2, lc2, li2, id);\n    \tc += shade (rd, p, n, lp3, lc3, li3, id);\n\t\tc *= fog;\n    \tc = c/(1. + c);\n\t\tc *= 1. - .25*pow (length (uv), 2.);\n    \tc = pow (c, vec3 (1./2.2));\n\t} else if (uv.x >= uv.y*aspect - .01 && uv.x < uv.y*aspect + .01) {\n\t\tc = vec3 (1.);\n\t} else {\n\t\tfloat glow = float (iter)/48.;\n\t\tc = shadeToon (p, n, lp2, rd);\n    }\n\n    fragColor = vec4 (c, 1.);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtXGzS.jpg", "access": "shaders20k", "license": "gpl-3.0", "functions": [[1011, 1011, 1033, 1033, 1141], [1143, 1143, 1182, 1182, 1277], [1279, 1279, 1310, 1310, 1349], [1351, 1472, 1504, 1504, 1892], [1894, 1926, 1958, 1958, 2266], [2268, 2268, 2326, 2326, 2496], [2498, 2498, 2520, 2520, 2769], [2771, 2771, 2826, 2826, 2958], [2960, 2960, 2996, 2996, 3062], [3064, 3064, 3138, 3138, 3634], [3636, 3636, 3665, 3665, 4042], [4044, 4044, 4095, 4095, 4235], [4237, 4237, 4288, 4288, 4510], [4512, 4512, 4569, 4569, 5822]], "test": "ok"}
{"id": "XdlGRH", "name": "Fractal Fish.", "author": "Logos", "description": "My first shader on Shadertoy. Fractal Fish - collage out of two mandelbrot pieces.", "tags": ["2d", "fractal", "mandelbrot", "complex", "inversion", "collage", "binarydecomposition"], "likes": 14, "viewed": 263, "published": "Public", "date": "1554270330", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Created by Robert Śmietana (Logos) - 03.04.2019\n// Bielsko-Biała, Poland, UE, Earth, Sol, Milky Way, Local Group, Laniakea :)\n\n\nvec3 pixelColor(vec2 p)\n{\n    \n    //--- calculate water (background) color ---//\n    \n    vec3 wc = vec3(0.0, 0.2 + 0.4*(0.5 - 0.5*p.y), 0.3 + 0.4*(0.5 - 0.5*p.y));\n    wc += vec3(0.08*sin(p.y - p.x));\n    \n    \n    //--- get main body of the fish ---//\n    \n    if (p.x < 3.968)\n    {\n        p = vec2(p.x, -p.y) / dot(p, p);\n    }\n\n    \n\t//--- carve tail of the fish ---//\n    \n    else\n    {\n\t\tp.x -= 3.687;\n        if (0.359 - 0.2*cos(5.0*p.y) < dot(p, p)) return wc;\n    }\n\n    \n    //--- iterate mandelbrot and return pixel color ---//\n    \n\tvec2 z = vec2(p);  \n\tfor (int i = 1; i <= 100; i++)\n    {  \n\t\tz = vec2(z.x*z.x - z.y*z.y, 2.0*z.x*z.y) + p; \n\n\t\tif (504.0 + 300.0*sin(4.1*iTime) < dot(z, z))\n        {\n\t\t\treturn z.y < 0.0? vec3(0.0) : vec3(1.0);\n\t\t}\n\t}\n\n    \n    //--- that was water :) ---//\n    \n    return wc;\n    \n}\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    \n    //--- calculate point coordinates ---//\n    \n\tvec2 c = 2.1*(-2.0*fragCoord.xy/iResolution.xy + 0.9)*vec2(iResolution.x/iResolution.y, 1.0) - vec2(-2.0, 0.0);\n    \n    \n    //--- animate fish movement ---//\n\n    c.x += 0.3*sin(0.4*iTime);\n    c.y += 0.15 - 0.3*sin(0.43*iTime) + 0.2*cos(c.x);\n    \n    \n    //--- add tail swing ---//\n    \n    if (0.0 < c.x) c.x += 0.1*c.x*cos(2.0*iTime + sin(0.8*c.x));\n    \n\n    //--- calculate final pixel color ---//\n    \n    float a = 3.0;\n    float e = 1.0/min(iResolution.x, iResolution.y);    \n    vec3 col = vec3(0.0);\n    \n    for (float j = -a; j < a; j++)\n        for (float i = -a; i < a; i++)\n            col += pixelColor(c + 2.1*vec2(i, j) * (e/a)) / (4.0*a*a);\n\n\tfragColor = vec4(col, 1.0);\n    \n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XdlGRH.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[133, 133, 158, 214, 967], [970, 970, 1025, 1074, 1781]], "test": "ok"}
{"id": "XlcGWs", "name": "Abstract Eclipse", "author": "Yusef28", "description": "Some kind of abstract eclipse shader I never uploaded", "tags": ["sun", "sky", "eclipse"], "likes": 7, "viewed": 139, "published": "Public", "date": "1555372962", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec2 random2(vec2 st){\n    st = vec2( dot(st,vec2(127.1,311.7)),\n              dot(st,vec2(269.5,183.3)) );\n    return -1.0 + 2.0*fract(sin(st)*43758.5453123);\n}\n\n// Value Noise by Inigo Quilez - iq/2013\n// https://www.shadertoy.com/view/lsf3WH\nfloat noise(vec2 st) {\n    vec2 i = floor(st);\n    vec2 f = fract(st);\n\n    vec2 u = f*f*(3.0-2.0*f);\n\n    return mix( mix( dot( random2(i + vec2(0.0,0.0) ), f - vec2(0.0,0.0) ), \n                     dot( random2(i + vec2(1.0,0.0) ), f - vec2(1.0,0.0) ), u.x),\n                mix( dot( random2(i + vec2(0.0,1.0) ), f - vec2(0.0,1.0) ), \n                     dot( random2(i + vec2(1.0,1.0) ), f - vec2(1.0,1.0) ), u.x), u.y);\n}\n\nfloat fbm(vec2 st)\n    {\n    float f = noise(st)*1.;st*=2.02;\n     f += noise(st)*0.5;st*=2.04;\n     f += noise(st)*0.25;st*=2.03;\n     f += noise(st)*0.125;st*=2.04;\n     f += noise(st)*0.0625;///st*=2.01;\n    \nreturn f;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 st = uv;\n    st.x*=iResolution.x/iResolution.y;\n     vec3 color = vec3(0.0);\n\n    vec2 pos = vec2(st*10.0);\n\n    color = vec3( noise(pos)*.5+.5 );\n\tvec3 color1 = vec3(0.022,0.144,0.145);\n    vec3 color2 = vec3(0.064,0.008,0.100);\n    \n    float sun = 1./pow(length(st-0.5), 1./2.)/4.;\n    color = color1*step(0.5, st.x)*(1.0-st.x);\n    color += color2*step(0.5, 1.0-st.x)*(st.x);\n    \n    color = mix(color1, color2, st.x-0.120);\n    color = mix(color, vec3(0.765,0.723,0.661), sun-0.3);\n    \n    \n    sun = 1.0-length(vec2(st.x/3., st.y-0.598));\n    color1 = vec3(0.525,0.787,0.945);\n    color2 = vec3(0.870,0.685,0.660);\n    vec3 color3 = vec3(0.990,0.985,0.781);\n    color = mix(color1, color2, pow(sun, 3.));//sin(st.y*6.168+-1.316)*0.5+0.5);\n    //sun = 1.0-length(vec2(st.x/2., st.y-0.708));\n    //color = mix(color, color3, pow(sun, 2.)/1.3);\n        color+=pow(st.y, 2.)/8.;\n    vec3 color4 = vec3(0.258,0.602,0.820);\n    color2 = vec3(0.940,0.231,0.403);\n    color2 = mix(color2, color3, st.y+0.10);\n    color = mix(color4, color1, st.y)+pow(st.y, 2.)/8.;\n    color =mix(color,  color2, pow(sun, 2.200)*1.);\n    //color = color*2.0-0.328;\n    st.x+=7.696;\n    //st.y*=1.816;\n    \n    st.x/=2.;\n    color *= mix(color, vec3(3.), fbm(st*4.+fbm(st*2.)/2.)*(noise(st*2.)));\n    \n    st = fragCoord.xy / iResolution.xy;\n    st=st*2.0-1.0;\n    st.x*=iResolution.x/iResolution.y;\n    \n    st/=1.2;\n    \n    \n    color += clamp(vec3(\n     1./pow(length(st+vec2(0.010,-0.0)), 2.+sin(atan(st.y,st.x)*50.+3.14159+iTime )/40.  )  *0.06   ), 0.0, 3.7);\n    \n    color -= clamp(vec3(\n     1./pow(length(st+vec2(0.010,-0.0)), 2.)*0.05   ), .0, 4.0)/(1.+sin(iTime*1.)/10.)+vec3(0.035,0.436,0.440)+sin(iTime*3.)/40.;\n    \n    \n    \n\tfragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XlcGWs.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 22, 22, 161], [163, 245, 267, 267, 673], [675, 675, 699, 699, 898], [901, 901, 958, 958, 2766]], "test": "timeout"}
{"id": "XtByWW", "name": "XRaymarching", "author": "Aeless", "description": "Raymarching test.. HOORAY", "tags": ["raymarching"], "likes": 3, "viewed": 114, "published": "Public", "date": "1555429561", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define NEAR_CLIPPING_PLANE 0.1\n#define FAR_CLIPPING_PLANE 100.0\n#define NUMBER_OF_MARCH_STEPS 64\n#define EPSILON 0.001\n#define DISTANCE_BIAS 0.7\n\nfloat fmod(float a, float b) { if(a<0.0) { return b - mod(abs(a), b); } return mod(a, b); }\n\nfloat Scene_Sphere(in vec3 rayPosition, in vec3 position, in float radius)\n{\n\treturn length(rayPosition - position) - radius;\n}\n\nvec2 Scene(in vec3 rayPosition)\n{\n    float displacement = sin(5.0 * (rayPosition.x + iTime / 3.0)) * sin(5.0 * rayPosition.y + iTime / 3.0) * sin(5.0 * rayPosition.z) * 0.25;\n    \n    vec3 tmpRayPosition = rayPosition;\n    // tmpRayPosition.x = fract(rayPosition.x + 0.5) - 0.5;\n    // tmpRayPosition.z = fmod(rayPosition.z + 1.0, 2.0) - 1.0;\n    \n    // tmpRayPosition.y += sin(rayPosition.x + iTime) * 0.35;\n    // tmpRayPosition.y += cos(rayPosition.z + iTime);\n    \n    float distance = Scene_Sphere(rayPosition, vec3(cos(iTime * 1.2), sin(iTime * 0.97), 1.0), 0.8);\n\tfloat materialID = 1.0;\n    \n    // float distance2 = Scene_Sphere(rayPosition, vec3(0, 0.5 * abs(sin(iTime*3.8)) + 1.0, 5.0), 0.5);\n\t// float materialID2 = 2.0;\n    \n    /*\n    vec3 spherePosition = rayPosition;\n    spherePosition.x = fract(spherePosition.x + 0.5) - 0.5;\n    spherePosition.z = fmod(spherePosition.z + 1.0, 2.0) - 1.0;\n    spherePosition.y += sin(rayPosition.x + iTime) * 0.35;\n    spherePosition.y += cos(rayPosition.z + iTime);\n    \n    float distance2 = Scene_Sphere(spherePosition, vec3(0.0, 0.5, 1.0), 0.15);\n\tfloat materialID2 = 2.0;\n\t\n        \n    if(distance2 < distance)\n    {\n\t\tdistance = distance2;\n        materialID = materialID2;\n    } \n\t*/\n    \n    return vec2(distance + displacement, materialID);\n}\n\nvec2 Raymarch(in vec3 position, in vec3 direction)\n{\n    float totalDistance = NEAR_CLIPPING_PLANE;\n    for(int i = 0 ; i < NUMBER_OF_MARCH_STEPS ; ++i)\n    {\n        vec2 result = Scene(position + direction * totalDistance);\n        if(result.x < EPSILON)\n        {\n            return vec2(totalDistance, result.y);\n        }\n        totalDistance += result.x * DISTANCE_BIAS;\n        if(totalDistance > FAR_CLIPPING_PLANE)\n        {\n            break;\n        }\n    }\n    return vec2(FAR_CLIPPING_PLANE, 0.0);\n}\n\nvec3 GetNormal(vec3 rayHitPosition, float smoothness)\n{\t\n\tvec3 n;\n\tvec2 dn = vec2(smoothness, 0.0);\n\tn.x\t= Scene(rayHitPosition + dn.xyy).x - Scene(rayHitPosition - dn.xyy).x;\n\tn.y\t= Scene(rayHitPosition + dn.yxy).x - Scene(rayHitPosition - dn.yxy).x;\n\tn.z\t= Scene(rayHitPosition + dn.yyx).x - Scene(rayHitPosition - dn.yyx).x;\n\treturn normalize(n);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\tuv = uv * 2.0 - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    vec3 cameraPosition = vec3(0, 1.0, -2.5);\n    vec3 direction = normalize(vec3(uv, 2.5));// - cameraPosition);\n    \n    vec3 lightDirection = normalize(vec3(0.0, 1.0, -0.5));\n    vec3 lightDiffuseColor = vec3(1.4, 1.2, 0.7);\n    vec3 lightAmbientColor = vec3(0.2, 0.45, 0.6);\n    \n    vec2 result = Raymarch(cameraPosition, direction);\n    \n    float fog = pow(1.0 / (1.0 + result.x), 0.45);\n    \n    vec3 materialColor = vec3(0.1, 0.1, 0.1);\n    \n    if(result.y == 1.0)\n    {\n        materialColor = vec3(1.0, 0.50, 0.25);\n    }\n    if(result.y == 2.0)\n    {\n       \tmaterialColor = vec3(0.7, 0.7, 0.7);\n    }\n          \n    vec3 intersection = cameraPosition + direction * result.x;\n    vec3 normal = GetNormal(intersection, 0.01);\n    float diffuse = dot(lightDirection, normal);\n    //diffuse = diffuse * 0.5 + 0.5;\n    diffuse = max(0.0, diffuse);\n    vec3 R = 2.0 * dot(lightDirection, normal) * normal - lightDirection;\n    float specular = pow(max(dot(-direction, R), 0.0), 32.0);\n    vec3 diffuseLit = materialColor * (diffuse * lightDiffuseColor + lightAmbientColor) + specular;\n    fragColor = vec4(diffuseLit, 1.0) * fog;\n\n}", "image_inputs": [{"id": "XdX3Rn", "previewfilepath": "/media/ap/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XtByWW.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[147, 147, 177, 177, 238], [240, 240, 316, 316, 367], [369, 369, 402, 402, 1675], [1677, 1677, 1729, 1729, 2190], [2192, 2192, 2247, 2247, 2543], [2545, 2545, 2600, 2600, 3853]], "test": "ok"}
