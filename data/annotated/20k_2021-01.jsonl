{"id": "3dVBDd", "name": "Shadow Pool EAS", "author": "public_int_i", "description": "Shadow Pool EAS", "tags": ["shadowpooleas"], "likes": 8, "viewed": 167, "published": "Public API", "date": "1609535955", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/*Ethan Alexander Shulman 2020 - xaloez.com\n4k 60fps video https://www.youtube.com/watch?v=b5S1k7Ma1C8\n4k wallpaper xaloez.com/art/2020/ShadowPool.jpg*/\n\n#define time iTime\n\nmat2 r2(float a) {\n\tfloat s = sin(a), c = cos(a);\n\treturn mat2(c,-s,s,c);\n}\n\nvec4 hash(vec4 a) {\n\treturn fract(abs(sin(a.ywxz*766.345)+cos(normalize(a)*4972.92855))*2048.97435+abs(a.wxyz)*.2735);\n}\n\nfloat caustics(vec2 p, vec2 uv) {\n\tfloat s = 0.;\n\tfor (float l = 1.; l < 5.; l++) {\n\t\tvec4 lh = hash(l*vec4(.01,.1,1.,10.));\n\t\tvec2 ruv = mod(abs((p.xy-(lh.xy*2.-1.))*r2(time*.1+l*.01+log(1.+length(uv.xy)*(1.+l*l)))),.4)-.2,\n\t\t\tauv = abs(ruv)-.2;\n\t\ts += pow(max(-auv.x,-auv.y)*5.,8.);\n\t}\n\treturn s;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord*2.-iResolution.xy)/iResolution.y;\n\n\tvec3 rd = normalize(vec3(uv.xy,.1));\n\tfloat s = 0.;\n\tfor (float t = .1; t < 3.; t += .2) {\n\t\ts += caustics((rd*t).xy,uv)/t;\n\t}\n\tfragColor = vec4(1.-pow(s*.03,1.));\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3dVBDd.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 174, 192, 192, 249], [251, 251, 270, 270, 371], [373, 373, 406, 406, 673], [676, 676, 733, 733, 960]]}
{"id": "3dVfDd", "name": "Brew EAS", "author": "public_int_i", "description": "Brew EAS", "tags": ["breweas"], "likes": 0, "viewed": 134, "published": "Public API", "date": "1609536007", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/*Ethan Alexander Shulman 2020 - xaloez.com\n4k 60fps video https://www.youtube.com/watch?v=7M4K1v5c43s\n4k wallpaper xaloez.com/art/2020/Brew.jpg*/\n\n#define time iTime\n\n#define PI 3.14159265358\n#define EPS 1e-3\n\nmat2 r2(float a) {\n\tfloat sn = sin(a), cs = cos(a);\n\treturn mat2(cs,-sn,sn,cs);\n}\n\nfloat geo(vec3 p) {\n\treturn min(-(length(p.xz)-5.),\n\t\t\t   length(mod(abs(p+vec3(100.+sin(time+p.y*2.)*.1,time*-.1,100.+cos(p.y*2.)*.1)),.4)-.2)-.05);\n}\n\nvec3 bg(vec3 rd) {\n\treturn vec3(0)+pow(max(0.,1.-length(rd-normalize(vec3(.2,.2,.4)))*.5),2.);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord*2.-iResolution.xy)/iResolution.y;\n\n\n\tvec3 rp = vec3(0,0,-4),\n\t\trd = normalize(vec3(uv.xy,.5)),\n\t\tc = vec3(1);\n\t\n\tfor (int i = 0; i < 100; i++) {\n\t\tfloat dst = geo(rp);\n\t\tif (dst <= 0.) {\n\t\t\tif (length(rp.xz) >= 5.) break;\n\t\t\tvec3 gp = mod(abs(rp-rd*EPS+vec3(100.+sin(time+rp.y*2.)*.1,time*-.1,100.+cos(rp.y*2.)*.1)),.4)-.2;\n\t\t\trd = refract(rd,normalize(gp),.97);\n\t\t\tc *= 1.05;\n\t\t\tdst = .2;\n\t\t}\n\t\tfloat dt = dst+EPS;\n\t\trp += rd*dt;\n\t\tc /= 1.+dt*vec3(.3,.36,1.)*.5;\n\t}\n\t\n\tfragColor = vec4(c*bg(rd)*3.,1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3dVfDd.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 211, 229, 229, 292], [294, 294, 313, 313, 445], [447, 447, 465, 465, 543], [546, 546, 603, 603, 1133]]}
{"id": "3l3Bzn", "name": "Rotation 360 sdf", "author": "iuryBorgesRodrigues", "description": "Based: https://www.shadertoy.com/view/3ddcW8", "tags": ["sdf", "rotation", "360"], "likes": 2, "viewed": 161, "published": "Public", "date": "1612036053", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\nconst float PI= 3.14159265359;\n#define TYPE 4\nvec3 saturate(vec3 a) { return clamp(a, 0.0, 1.0); }\nvec2 saturate(vec2 a) { return clamp(a, 0.0, 1.0); }\nfloat saturate(float a) { return clamp(a, 0.0, 1.0); }\n\n\nmat3 rotate_x(float a){float sa = sin(a); float ca = cos(a); return mat3(vec3(1.,.0,.0),    vec3(.0,ca,sa),   vec3(.0,-sa,ca));}\nmat3 rotate_y(float a){float sa = sin(a); float ca = cos(a); return mat3(vec3(ca,.0,sa),    vec3(.0,1.,.0),   vec3(-sa,.0,ca));}\nmat3 rotate_z(float a){float sa = sin(a); float ca = cos(a); return mat3(vec3(ca,sa,.0),    vec3(-sa,ca,.0),  vec3(.0,.0,1.));}\n\n\nconst float TAU = 2.0 * PI;\n\nfloat glow = 0.0;\n\n\n\nfloat sdPlane(in vec3 p) {\n    return p.y;\n}\n\nfloat sdSphere(in vec3 p, float s) {\n    return length(p) - s;\n}\n\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\nvec2 opUnion(vec2 d1, vec2 d2) {\n    return d1.x < d2.x ? d1 : d2;\n}\nfloat sdApple(vec3 p, float r) {\n\tp.y *= 0.95;\n\n\tp.xz *= 1.2;\n\n\tfloat k = 0.84 + 0.16 * smoothstep(-r, r, p.y);\n\tp.xz /= k;\n\treturn sdTorus(p, vec2((0.9 / 1.25) * r, r))*0.3;\n}\n\n\n\nfloat localTime = 0.0;\n\n\n\n\n\n\n\nfloat smin( float a, float b, float k )\n{\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\nvec2 matMin(vec2 a, vec2 b)\n{\n\tif (a.x < b.x) return a;\n\telse return b;\n}\n\n\nfloat sdBox(vec3 p, vec3 radius)\n{\n  vec3 dist = abs(p) - radius;\n  return min(max(dist.x, max(dist.y, dist.z)), 0.0) + length(max(dist, 0.0));\n}\n\n\n\n\n\n\nmat2 mm2(in float a){float c = cos(a), s = sin(a);return mat2(c,-s,s,c);}\n\nvec3 fold(in vec3 p)\n{\n    const vec3 nc = vec3(-0.5,-0.809017,0.309017);\n    for(int i=0;i<5;i++)\n    {\n\t\tp.xy = abs(p.xy);\n\t\tfloat t = 2.*min(0.,dot(p,nc));\n\t\tp -= t*nc;\n\t}\n    return p;\n}\n\nfloat smax(float a, float b)\n{\n    const float k = 2.;\n    float h = 1.-clamp(.5 + .5*(b-a)/k, 0., 1.);\n    return mix(b, a, h) - k*h*(1.0-h);\n}\n\nfloat tri(in float x){return abs(fract(x)-0.5)*2.;}\n\n\nvec2 toroidal (vec2 p, float r) { return vec2(length(p.xy)-r, atan(p.y,p.x)); }\nmat2 rot (float a) { float c=cos(a),s=sin(a); return mat2(c,-s,s,c); }\nfloat amod (inout vec2 p, float count) { float an = TAU/count; float a = atan(p.y,p.x)+an/2.; float c = floor(a/an); c = mix(c,abs(c),step(count*.5,abs(c))); a = mod(a,an)-an/2.; p.xy = vec2(cos(a),sin(a))*length(p); return c; }\nfloat sdCylinder (vec2 p, float r) { return length(p)-r; }\n\nfloat sdIso(vec3 p, float r) { return max(0.,dot(p,normalize(sign(p))))-r; }\nfloat sdStar (vec3 pos) {\n    float dist;\n    \n    float radius = 3.;\n    float size = .2;\n    vec3 p = pos;\n    p.y -= radius;\n    p.xy *= rot(-iTime*.5);\n    float index = amod(p.xy, 16.);\n    p.x -= radius-1.5;\n    p.xy *= rot(iTime+index);\n    amod(p.xy, 5.);\n    dist = sdIso(p, size);\n   \n    return dist;\n}\n\nfloat sdShere (vec3 pos) {\n    float dist;\n    \n    float radius = 3.;\n    float size = .2;\n    vec3 p = pos;\n    p.y -= radius;\n    p.xy *= rot(-iTime*.5);\n    float index = amod(p.xy, 16.);\n    p.x -= radius-1.5;\n    p.xy *= rot(iTime+index);\n    \n    dist = length(p)-0.2;\n   \n    return dist;\n}\n\nfloat box (vec3 pos) {\n    float dist;\n    \n    float radius = 4.;\n    float size = .2;\n    vec3 p = pos;\n    p.y -= radius;\n    p.xy *= rot(-iTime*.5);\n    float index = amod(p.xy, 16.);\n    p.x -= radius-1.5;\n    p.xy *= rot(iTime+index);\n    \n    dist =sdBox(p,vec3(0.2));\n   \n    return dist;\n}\n\nvec2 scene(in vec3 position) {\n\n\n    vec3 p=position;\n    p-=vec3(0.0,-0.5,0.0);\n    p/=vec3(0.5);\n    float star=sdStar(p)*0.3;\n    p-=vec3(0.0,0.0,1.0);\n    float sphere=sdShere(p)*0.3;\n    p-=vec3(0.0,3.0,-4.3);\n    p*=rotate_x(1.5);\n    float torus=box (p)*0.3;\n  \n    star=min(star,sphere);\n    star=min(star,torus);\n  \n    \n   \n   \n    vec2 scene = opUnion(\n          vec2(sdPlane(position), 1.0),\n          vec2(star, 12.0)\n    );\n    return scene;\n}\n\nvec4 boxmap( sampler2D sam, in vec3 p, in vec3 n, in float k )\n{\n    vec3 m = pow( abs(n), vec3(k) );\n\tvec4 x = texture( sam, p.yz );\n\tvec4 y = texture( sam, p.zx );\n\tvec4 z = texture( sam, p.xy );\n\treturn (x*m.x + y*m.y + z*m.z)/(m.x+m.y+m.z);\n}\n//------------------------------------------------------------------------------\n// Ray casting\n//------------------------------------------------------------------------------\n\nfloat shadow(in vec3 origin, in vec3 direction) {\n    float hit = 1.0;\n    float t = 0.02;\n    \n    for (int i = 0; i < 1000; i++) {\n        float h = scene(origin + direction * t).x;\n        if (h < 0.001) return 0.0;\n        t += h;\n        hit = min(hit, 10.0 * h / t);\n        if (t >= 2.5) break;\n    }\n\n    return clamp(hit, 0.0, 1.0);\n}\n\nvec2 traceRay(in vec3 origin, in vec3 direction) {\n    float material = -1.0;\n\n    float t = 0.02;\n    \n    for (int i = 0; i < 1000; i++) {\n        vec2 hit = scene(origin + direction * t);\n        if (hit.x < 0.002 || t > 20.0) break;\n        t += hit.x;\n        material = hit.y;\n    }\n\n    if (t > 20.0) {\n        material = -1.0;\n    }\n\n    return vec2(t, material);\n}\n\nvec3 normal(in vec3 position) {\n    vec3 epsilon = vec3(0.001, 0.0, 0.0);\n    vec3 n = vec3(\n          scene(position + epsilon.xyy).x - scene(position - epsilon.xyy).x,\n          scene(position + epsilon.yxy).x - scene(position - epsilon.yxy).x,\n          scene(position + epsilon.yyx).x - scene(position - epsilon.yyx).x);\n    return normalize(n);\n}\n\n//------------------------------------------------------------------------------\n// BRDF\n//------------------------------------------------------------------------------\n\nfloat pow5(float x) {\n    float x2 = x * x;\n    return x2 * x2 * x;\n}\n\nfloat D_GGX(float linearRoughness, float NoH, const vec3 h) {\n    // Walter et al. 2007, \"Microfacet Models for Refraction through Rough Surfaces\"\n    float oneMinusNoHSquared = 1.0 - NoH * NoH;\n    float a = NoH * linearRoughness;\n    float k = linearRoughness / (oneMinusNoHSquared + a * a);\n    float d = k * k * (1.0 / PI);\n    return d;\n}\n\nfloat V_SmithGGXCorrelated(float linearRoughness, float NoV, float NoL) {\n    // Heitz 2014, \"Understanding the Masking-Shadowing Function in Microfacet-Based BRDFs\"\n    float a2 = linearRoughness * linearRoughness;\n    float GGXV = NoL * sqrt((NoV - a2 * NoV) * NoV + a2);\n    float GGXL = NoV * sqrt((NoL - a2 * NoL) * NoL + a2);\n    return 0.5 / (GGXV + GGXL);\n}\n\nvec3 F_Schlick(const vec3 f0, float VoH) {\n    // Schlick 1994, \"An Inexpensive BRDF Model for Physically-Based Rendering\"\n    return f0 + (vec3(1.0) - f0) * pow5(1.0 - VoH);\n}\n\nfloat F_Schlick(float f0, float f90, float VoH) {\n    return f0 + (f90 - f0) * pow5(1.0 - VoH);\n}\n\nfloat Fd_Burley(float linearRoughness, float NoV, float NoL, float LoH) {\n    // Burley 2012, \"Physically-Based Shading at Disney\"\n    float f90 = 0.5 + 2.0 * linearRoughness * LoH * LoH;\n    float lightScatter = F_Schlick(1.0, f90, NoL);\n    float viewScatter  = F_Schlick(1.0, f90, NoV);\n    return lightScatter * viewScatter * (1.0 / PI);\n}\n\nfloat Fd_Lambert() {\n    return 1.0 / PI;\n}\n\n//------------------------------------------------------------------------------\n// Indirect lighting\n//------------------------------------------------------------------------------\n\nvec3 Irradiance_SphericalHarmonics(const vec3 n) {\n    // Irradiance from \"Ditch River\" IBL (http://www.hdrlabs.com/sibl/archive.html)\n    return max(\n          vec3( 0.754554516862612,  0.748542953903366,  0.790921515418539)\n        + vec3(-0.083856548007422,  0.092533500963210,  0.322764661032516) * (n.y)\n        + vec3( 0.308152705331738,  0.366796330467391,  0.466698181299906) * (n.z)\n        + vec3(-0.188884931542396, -0.277402551592231, -0.377844212327557) * (n.x)\n        , 0.0);\n}\n\nvec2 PrefilteredDFG_Karis(float roughness, float NoV) {\n    // Karis 2014, \"Physically Based Material on Mobile\"\n    const vec4 c0 = vec4(-1.0, -0.0275, -0.572,  0.022);\n    const vec4 c1 = vec4( 1.0,  0.0425,  1.040, -0.040);\n\n    vec4 r = roughness * c0 + c1;\n    float a004 = min(r.x * r.x, exp2(-9.28 * NoV)) * r.x + r.y;\n\n    return vec2(-1.04, 1.04) * a004 + r.zw;\n}\n\n//------------------------------------------------------------------------------\n// Tone mapping and transfer functions\n//------------------------------------------------------------------------------\n\nvec3 Tonemap_ACES(const vec3 x) {\n    // Narkowicz 2015, \"ACES Filmic Tone Mapping Curve\"\n    const float a = 2.51;\n    const float b = 0.03;\n    const float c = 2.43;\n    const float d = 0.59;\n    const float e = 0.14;\n    return (x * (a * x + b)) / (x * (c * x + d) + e);\n}\n\nvec3 OECF_sRGBFast(const vec3 linear) {\n    return pow(linear, vec3(1.0 / 2.2));\n}\n\n//------------------------------------------------------------------------------\n// Rendering\n//------------------------------------------------------------------------------\n\nvec3 hash3(vec2 p)\n{\n    vec3 q = vec3(\n\t\tdot(p,vec2(127.1,311.7)), \n\t\tdot(p,vec2(269.5,183.3)), \n\t\tdot(p,vec2(419.2,371.9))\n\t);\n\treturn fract(sin(q) * 43758.5453);\n}\n\nfloat noise(vec2 x)\n{\n\tvec2 p = floor(x);\n\tvec2 f = fract(x);\n\treturn mix(\n\t\tmix(\n\t\t\thash3(p + vec2(0.0, 0.0)).x,\n\t\t\thash3(p + vec2(1.0, 0.0)).x,\n\t\t\tsmoothstep(0.0, 1.0, f.x)\n\t\t),\n\t\tmix(\n\t\t\thash3(p + vec2(0.0, 1.0)).x,\n\t\t\thash3(p + vec2(1.0, 1.0)).x,\n\t\t\tsmoothstep(0.0, 1.0, f.x)\n\t\t),\n\t\tsmoothstep(0.0, 1.0, f.y)\n\t);\n}\n\n\nvec2 getUV(vec3 pos)\n{\n    vec3 nor = normal(pos);\n    float lon = atan(nor.x,nor.z)/3.14;\n    float lat = acos(nor.y)/3.14;\n    vec2 r = vec2(lat, lon);\n    \n    return r;\n}\nvec3 render(in vec3 origin, in vec3 direction, out float distance,vec2 uv) {\n    // Sky gradient\n    vec3 color = vec3(0.65, 0.85, 1.0) + direction.y * 0.72;\n\n    // (distance, material)\n    vec2 hit = traceRay(origin, direction);\n    distance = hit.x;\n    float material = hit.y;\n\n    // We've hit something in the scene\n    if (material > 0.0) {\n        vec3 position = origin + distance * direction;\n\n        vec3 v = normalize(-direction);\n        vec3 n = normal(position);\n        vec3 l = normalize(vec3(0.6, 0.7, -0.7));\n        vec3 h = normalize(v + l);\n        vec3 r = normalize(reflect(direction, n));\n\n        float NoV = abs(dot(n, v)) + 1e-5;\n        float NoL = saturate(dot(n, l));\n        float NoH = saturate(dot(n, h));\n        float LoH = saturate(dot(l, h));\n\n        vec3 baseColor = vec3(0.0);\n        float roughness = 0.0;\n        float metallic = 0.0;\n\n        float intensity = 2.0;\n        float indirectIntensity = 0.64;\n\n        if (material < 4.0)  {\n            // Checkerboard floor\n            float f = mod(floor(6.0 * position.z) + floor(6.0 * position.x), 2.0);\n            baseColor = 0.4 + f * vec3(0.6);\n            roughness = 0.1;\n        } else if (material < 16.0) {\n            // Metallic objects\n            baseColor = vec3(255.0,255.0,0.0)/255.0218,165,32;\n            roughness = 0.5;\n            metallic=0.5;\n        }\n\n        float linearRoughness = roughness * roughness;\n        vec3 diffuseColor = (1.0 - metallic) * baseColor.rgb;\n        vec3 f0 = 0.04 * (1.0 - metallic) + baseColor.rgb * metallic;\n\n        float attenuation = shadow(position, l);\n\n        // specular BRDF\n        float D = D_GGX(linearRoughness, NoH, h);\n        float V = V_SmithGGXCorrelated(linearRoughness, NoV, NoL);\n        vec3  F = F_Schlick(f0, LoH);\n        vec3 Fr = (D * V) * F;\n\n        // diffuse BRDF\n        vec3 Fd = diffuseColor * Fd_Burley(linearRoughness, NoV, NoL, LoH);\n\n        color = Fd + Fr;\n        color *= (intensity * attenuation * NoL) * vec3(0.98, 0.92, 0.89);\n\n        // diffuse indirect\n        vec3 indirectDiffuse = Irradiance_SphericalHarmonics(n) * Fd_Lambert();\n\n        vec2 indirectHit = traceRay(position, r);\n        vec3 indirectSpecular = vec3(0.65, 0.85, 1.0) + r.y * 0.72;\n        if (indirectHit.y > 0.0) {\n            if (indirectHit.y < 4.0)  {\n                vec3 indirectPosition = position + indirectHit.x * r;\n                // Checkerboard floor\n                float f = mod(floor(6.0 * indirectPosition.z) + floor(6.0 * indirectPosition.x), 2.0);\n                indirectSpecular = 0.4 + f * vec3(0.6);\n            } else if (indirectHit.y < 16.0) {\n                // Metallic objects\n                indirectSpecular = vec3(0.3, 0.0, 0.0);\n            }\n        }\n\n        // indirect contribution\n        vec2 dfg = PrefilteredDFG_Karis(roughness, NoV);\n        vec3 specularColor = f0 * dfg.x + dfg.y;\n        vec3 ibl = diffuseColor * indirectDiffuse + indirectSpecular * specularColor;\n\n        color += ibl * indirectIntensity;\n    }\n\n    return color;\n}\n\n//------------------------------------------------------------------------------\n// Setup and execution\n//------------------------------------------------------------------------------\n\nmat3 setCamera(in vec3 origin, in vec3 target, float rotation) {\n    vec3 forward = normalize(target - origin);\n    vec3 orientation = vec3(sin(rotation), cos(rotation), 0.0);\n    vec3 left = normalize(cross(forward, orientation));\n    vec3 up = normalize(cross(left, forward));\n    return mat3(left, up, forward);\n}\n// Camera\nvec2 glFragCoord;\nvec3 Ray( float zoom )\n{\n\treturn vec3( glFragCoord.xy-iResolution.xy*.5, iResolution.x*zoom );\n}\n\nvec3 Rotate( inout vec3 v, vec2 a )\n{\n\tvec4 cs = vec4( cos(a.x), sin(a.x), cos(a.y), sin(a.y) );\n\t\n\tv.yz = v.yz*cs.x+v.zy*cs.y*vec2(-1,1);\n\tv.xz = v.xz*cs.z+v.zx*cs.w*vec2(1,-1);\n\t\n\tvec3 p;\n\tp.xz = vec2( -cs.w, -cs.z )*cs.x;\n\tp.y = cs.y;\n\t\n\treturn p;\n}\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    // Normalized coordinates\n    vec2 p = -1.0 + 2.0 * fragCoord.xy / iResolution.xy;\n    vec2 uv= fragCoord.xy / iResolution.xy;\n    // Aspect ratio\n    p.x *= iResolution.x / iResolution.y;\n    \n    vec3 ray = Ray(1.8);\n\t\n\t\n\t\n\tray = normalize(ray);\n    vec3 localRay = ray;\n\n\tvec2 mouse = vec2(-.1,iTime*.01);\n\t\n\tmouse = vec2(.5)-iMouse.yx/iResolution.yx;\n\t\t\n\tfloat T = iTime*.0;\n\tvec3 pos = 3.0*Rotate( ray, vec2(.2,1.5-T)+vec2(-1.0,-7.0)*mouse );\n\t//pos += vec3(0,.3,0) + T*vec3(0,0,-1);\n    pos.y += .06-pos.z*.02; // tail is higher\n    pos.z += pos.z*.2; // centre on the end of the car we're looking at\n    pos.x += .3;//sign(pos.x)*.2*smoothstep(.0,.5,abs(pos.x)); // off-centre framingvec3 ray = Ray(1.8);\n\n\t\n\t\n\t\n\n    // Camera position and \"look at\"\n    vec3 origin = vec3(0.0, 2.0, 0.0);\n    vec3 target = vec3(0.0);\n\n    origin+=pos;\n\n    mat3 toWorld = setCamera(origin, target, 0.0);\n    vec3 direction = toWorld * normalize(vec3(p.xy, 2.0));\n\n    // Render scene\n    float distance;\n    vec3 color = render(origin, direction, distance,getUV(origin + direction*traceRay(origin, direction).x));\n\n    // Tone mapping\n    color = Tonemap_ACES(color);\n\n    // Exponential distance fog\n    color = mix(color, 0.8 * vec3(0.7, 0.8, 1.0), 1.0 - exp2(-0.011 * distance * distance));\n\n    // Gamma compression\n    color = OECF_sRGBFast(color);\n\n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3l3Bzn.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[47, 47, 70, 70, 99], [100, 100, 123, 123, 152], [153, 153, 178, 178, 207], [210, 210, 233, 233, 338], [339, 339, 362, 362, 467], [468, 468, 491, 491, 595], [648, 648, 674, 674, 692], [694, 694, 730, 730, 758], [760, 760, 793, 793, 858], [860, 860, 892, 892, 928], [929, 929, 961, 961, 1105], [1139, 1139, 1180, 1180, 1273], [1275, 1275, 1304, 1304, 1348], [1351, 1351, 1385, 1385, 1496], [1503, 1503, 1524, 1524, 1576], [1578, 1578, 1600, 1600, 1768], [1770, 1770, 1800, 1800, 1914], [1916, 1916, 1938, 1938, 1967], [1970, 1970, 2003, 2003, 2049], [2050, 2050, 2070, 2070, 2120], [2121, 2121, 2161, 2161, 2349], [2350, 2350, 2386, 2386, 2408], [2410, 2410, 2440, 2440, 2486], [2487, 2487, 2512, 2512, 2800], [2802, 2802, 2828, 2828, 3100], [3102, 3102, 3124, 3124, 3400], [3402, 3402, 3432, 3432, 3859], [3861, 3861, 3925, 3925, 4107], [4108, 4286, 4335, 4335, 4629], [4631, 4631, 4681, 4681, 5004], [5006, 5006, 5037, 5037, 5357], [5359, 5530, 5551, 5551, 5599], [5601, 5601, 5662, 5747, 5944], [5946, 5946, 6019, 6111, 6311], [6313, 6313, 6355, 6435, 6489], [6491, 6491, 6540, 6540, 6588], [6590, 6590, 6663, 6720, 6933], [6935, 6935, 6955, 6955, 6978], [6980, 7164, 7214, 7298, 7656], [7658, 7658, 7713, 7770, 8030], [8032, 8234, 8267, 8323, 8509], [8511, 8511, 8550, 8550, 8593], [8595, 8771, 8791, 8791, 8937], [8939, 8939, 8960, 8960, 9257], [9260, 9260, 9282, 9282, 9434], [9435, 9435, 9511, 9531, 12488], [12490, 12676, 12740, 12740, 12992], [12993, 13021, 13045, 13045, 13117], [13119, 13119, 13156, 13156, 13371], [13374, 13374, 13429, 13459, 14815]]}
{"id": "3l3cRs", "name": "raymarching infinite spheres", "author": "rahul897", "description": "first try at infinite spheres", "tags": ["raymarching"], "likes": 1, "viewed": 169, "published": "Public API", "date": "1609688678", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define MaximumRaySteps 100\n#define MinimumDistance .01\n\n\nfloat DE(vec3 p)\n{\n  p = mod(p,1.0)-vec3(0.5);\n  return length(p)-0.25;\n}\n\nfloat trace(vec3 from, vec3 direction) {\n\tfloat totalDistance = 0.0;\n\tint steps;\n\tfor (steps=0; steps < MaximumRaySteps; steps++) {\n\t\tvec3 p = from + totalDistance * direction;\n\t\tfloat distance = DE(p);\n\t\ttotalDistance += distance;\n\t\tif (distance < MinimumDistance) break;\n\t}\n\treturn 1.0-float(steps)/float(MaximumRaySteps);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\n    vec3 col = vec3(0);\n    \n    vec3 ro = vec3(-6.*sin(iTime/10.), -6.*sin(iTime/10.), 0);\n    vec3 rd = normalize(vec3(uv.x, uv.y, 1));\n\n    float d = trace(ro, rd);\n    col = vec3(d);\n    \n    col = pow(col, vec3(.4545));\t// gamma correction\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3l3cRs.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[58, 58, 76, 76, 131], [133, 133, 173, 173, 459], [461, 461, 518, 518, 861]]}
{"id": "3l3XW4", "name": "Attempt at basic shapes", "author": "MinimilisticBits", "description": "Trying to create basic 3d shapes", "tags": ["3d", "basic", "shapes"], "likes": 5, "viewed": 62, "published": "Public", "date": "1611336058", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//Move camera with mouse\n\nconst float ni = 3.14159;\nvec2 rot(vec2 a, float c){\nfloat l = length(a);\na = normalize(a);\nfloat ang = atan(a.y, a.x)+(c*ni/180.0);    \nreturn vec2(l*cos(ang), l*sin(ang));    \n}\n\n\nfloat capsule(vec3 a, vec3 b, vec3 p, float s){\nfloat h = dot(b-a, p-a)/pow(length(b-a),2.0);\nh = clamp(h,0.0,1.0);\nvec3 q = a + (b-a)*h;\nreturn length(q-p)-s;    \n}\n\nvec3 r(vec3 a, float c){\nreturn ((fract(a/c))*c)-0.5*c;\n}\nfloat r(float a, float c){\nreturn ((fract(a/c))*c)-0.5*c;\n}\n\nfloat box(vec3 p, vec3 c){\nvec3 a = abs(p)-c;\nreturn max(max(a.x,a.y), a.z);\n}\n\nfloat sphere(vec3 p, float s){\nreturn length(p)-s;\n}\n\n\nfloat pyramid(vec3 p){// fix function with position+scale\n//p=r(p, 4.);\n    vec3 pos = p;\n    pos.yz = rot(pos.yz, 45.0);\n    pos.xy = rot(pos.xy, 45.0);\n    pos = vec3(-pos.y, pos.x, pos.z);\n    return max(box(pos, vec3(1.3)), -box(p-vec3(0.0, 0.0, -0.9), vec3(3.0, 3.0, 1.5)));\n}\n\nfloat prism(vec3 p){ //fix function with position + scale\nvec3 ppos = vec3(0.0, 4.0, 2.0);\n    vec3 pos = p-ppos;\n    pos.xy = rot(pos.xy, 90.0);\n    pos.yz = rot(pos.yz, 45.0);\n    return max(box(pos, vec3(1.0)), -box(ppos-p-vec3(0.0,0.0,1.0), vec3(2.0, 2.0, 1.0)) );\n}\n\n\nfloat cone(vec3 pos, float h, float s, vec3 p){ //hallow\n    vec3 a = vec3(pos.xy + normalize(p.xy-pos.xy)*s, pos.z);\n    vec3 b = vec3(pos.xy, pos.z+h);\n    float h1 = dot(b-a, p-a)/pow(length(b-a),2.0);\n    h1 = clamp(h1, 0.0, 1.0);\n    vec3 q = a + (b-a)*h1;\n    return length(q-p)-0.1;\n}\n\nfloat cylinder(vec3 pos, vec3 p, float h, float s){\nvec3 q = vec3(pos.xy, clamp(p.z, pos.z, pos.z+h));\nreturn max(length(q-p)-s, box(pos-p+vec3(0.0, 0.0, h*0.5), vec3(s,s,h*0.5)));    \n}\n\nfloat torus(vec3 pos, vec3 p, float r1, float r2){\n    vec3 pp = vec3(pos.xy + normalize(p.xy-pos.xy)*r1, pos.z);\n    return length(pp-p)-r2;\n}\n\nfloat dis(vec3 p){\n    return min(min(min(min(min(min(min(min(torus(vec3(0.0, 3.0, 4.0*sin(iTime)), p, 2.0, 0.5),\n              cone(vec3(0.0, 3.0, 2.0*sin(iTime)), 3.0, 2.0, p)\n              ),\n              box(vec3(0.0, 3.0, -4.*sin(iTime))-p, vec3(2.0))\n              ),\n              capsule(vec3(-3.0, 3.0, 2.0*sin(iTime)), vec3(3.0, 3.0, 2.0*cos(iTime)),p, 0.6)\n              ),\n              length(vec3(6.0*sin(iTime), 3.0, 2.0)-p)-1.8\n              ),\n              pyramid(p-vec3(4.0, 2.0, 3.0*sin(iTime)))\n              ),\n              prism(p-vec3(-4.0, -1.0, 3.0*cos(iTime)))\n              ),cylinder(vec3(2.0*cos(iTime), 3.0, 4.0*sin(iTime)), p, 3.0, 1.0)),\n              box(vec3(0.0,3.0,-6.0)-p, vec3(40.0,40.0,2.0))\n              );\n           \n}\n\nbool trac(inout vec3 p, vec3 d, inout float dd){\n    for(int i = 0; i < 60; i++){\n        dd = dis(p);\n        if(dd < 0.01)return true;\n        p+=d*dd;\n    }\n    return false;\n}\n\nvec3 norm(vec3 p, float dd){\nreturn normalize(\nvec3(\ndd-dis(vec3(p.x-0.1, p.yz)),\ndd-dis(vec3(p.x, p.y-0.1, p.z)),\ndd-dis(vec3(p.xy,p.z-0.1))\n));\n}\n\nfloat shadow(vec3 p, vec3 lig){\nvec3 d = normalize(lig-p);\n    float dd,lg;\n    for(int i = 0; i < 60; i++){\n        lg = length(lig-p)-1.3;\n        dd = min(dis(p), lg);\n        if(dd < 0.01)break;\n        p+=d*dd;\n    }\n    \n    if(dd < 0.01 && dd == lg)return 1.0;\n    return 0.2;\n}\n\nfloat rough(float a, float c){\nreturn exp(-pow(12.0*(1.0-a)*(c-1.0)-a,2.0))/(ni*a);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    uv -= 0.5;\n    uv.x *= iResolution.x / iResolution.y;\n    uv *= 2.0;\n    \n    vec3 d = normalize(vec3(uv.x, 1.0, uv.y));\n    vec2 mouse = iMouse.xy / iResolution.xy;\n    mouse = mouse * 2.0 - 1.0;\n    d.yz = rot(d.yz, mouse.y*90.);\n    d.xy = rot(d.xy, -mouse.x*90.);\n    vec3 p = vec3(0.0, -5.0, 2.0);\n    \n    vec3 col = vec3(0.3, 0.5, 0.6)*max(pow(dot(d, vec3(0.0,0.0,1.0)),0.5),0.2)*2.0;\n    float dd;\n    vec3 prevp;\n    vec3 lig = vec3(8.0, 4.0, 9.0);\n    if(trac(p,d,dd)){\n       vec3 n = norm(p,dd);\n       vec3 light = normalize(lig - p);\n       col = vec3(1.0)*max(dot(n,light),0.0)*shadow(p-d*0.1,lig)+\n           (vec3(0.3, 0.5, 0.6)*max(pow(dot(reflect(d,n), vec3(0.0,0.0,1.0)),0.5),0.2))*0.9 + rough(0.4, dot(reflect(d,n),light)); \n        \n        p-=d*0.2;\n        d = reflect(d,n);\n        if(trac(p,d,dd)){\n        n = norm(p,dd);\n        light = normalize(lig - p);\n        col += vec3(1.0)*max(dot(n,light),0.0)*shadow(p-d*0.1,lig)+\n           (vec3(0.3, 0.5, 0.6)*max(pow(dot(reflect(d,n), vec3(0.0,0.0,1.0)),0.5),0.2))*0.9+ rough(0.4, dot(reflect(d,n),light)); \n        }else{\n        col+= vec3(0.3, 0.5, 0.6)*max(pow(dot(d, vec3(0.0,0.0,1.0)),0.5),0.2)*2.0;\n        }\n        col/=2.0;\n        \n    }\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3l3XW4.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 52, 78, 78, 205], [208, 208, 255, 255, 373], [375, 375, 399, 399, 432], [433, 433, 459, 459, 492], [494, 494, 520, 520, 572], [574, 574, 604, 604, 626], [629, 629, 651, 700, 910], [912, 912, 932, 969, 1182], [1185, 1185, 1232, 1241, 1476], [1478, 1478, 1529, 1529, 1664], [1666, 1666, 1716, 1716, 1809], [1811, 1811, 1829, 1829, 2576], [2578, 2578, 2626, 2626, 2757], [2759, 2759, 2787, 2787, 2906], [2908, 2908, 2939, 2939, 3193], [3195, 3195, 3225, 3225, 3280], [3282, 3282, 3339, 3339, 4646]]}
{"id": "3l3yDS", "name": "Genuary2021 4: Small Symmetry", "author": "qw", "description": "Entry for Day 4 of #Genuary2021 - see https://genuary2021.github.io/\nPrompt of the day: Small areas of symmetry.", "tags": ["2d", "symmetry", "genuary2021", "genuary"], "likes": 1, "viewed": 39, "published": "Public", "date": "1609778112", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define cellCount 10.\n#define cellSize 1./cellCount\n#define T (iTime * 10.)\n\nfloat drawCircle(vec2 uv, vec2 id, vec2 dir){\n\n    float circleR = 0.2 /cellCount;\n    float l = length( (id* cellSize+(cellSize*0.5) - (dir*cellSize*0.25) ) - uv);\n    return smoothstep(  l - 1.5/iResolution.y ,l  ,circleR);\n}\n\n\nvec3 Rand2To3(vec2 id)\n{\n    float r = dot(id.xx, id.yx*41.2330);\n    return vec3( fract(r), fract(r*10.), fract(r*100.));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = ( fragCoord -.5*iResolution.xy ) /iResolution.y;;\n\n    uv += vec2(.5,0);\n    \n    vec2 id = floor((uv * cellCount));\n    if(id.x < 0. || id.x > cellCount-1.){ id= vec2(0);}\n    //fragColor.rgb = vec3( id/cellCount,0);\n    fragColor.rgb = vec3(0);\n    \n    \n    float patternCount = 16.;\n    vec2[] movePatterns = vec2[] (  vec2(0,1), vec2(1,1),\n                                    vec2(0,1), vec2(-1,0),\n                                    vec2(-1,-1), vec2(-1,0),\n                                    vec2(-1,1), vec2(0,0),\n                                    vec2(0,1), vec2(-1,1),\n                                    vec2(-1,0), vec2(0,0),\n                                    vec2(1,0), vec2(0,-1),\n                                    vec2(-1,0), vec2(-1,1)\n                                    );\n    \n    vec2 moveDir = mix(movePatterns[int(mod( T-1.+patternCount ,patternCount))],  movePatterns[int(mod( T,patternCount))], fract(T));\n    //Variation\n    moveDir *= 1. - (2.*mod(id+1.,2.));\n    \n    \n    fragColor.rgb += mix(vec3(0.058, 0.101, 0.349),Rand2To3(id+vec2(1.)) , drawCircle( uv, id, moveDir) );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3l3yDS.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[77, 77, 122, 122, 304], [307, 307, 331, 331, 431], [433, 433, 490, 540, 1667]]}
{"id": "3l3yRj", "name": "peck of hexes (vlllll)", "author": "valalalalala", "description": "messing with hex tiles and truchet tiling. lotta issue to resolve still. the uv coordinates for the curves in particular are kooky.", "tags": ["truchet", "tiling", "hex"], "likes": 2, "viewed": 64, "published": "Public", "date": "1609708524", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/////////////////////////////////////////////////////////////////////////////\n//\n// \"peck of hexes\" \n//\n// by Val \"valalalalala\" GvM - 2020\n// Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n//\n// Trying to combine ideas from BigWings's videos on hex and truchet tiling\n// - https://www.youtube.com/watch?v=VmrIDyYiJBA\n// - https://www.youtube.com/watch?v=2R7h76GoIJM\n//\n// There are tiles with rounded and straight edges which are mixed. The edges\n// are pretty janky, and the flow has issues, uv's are wack\n//\n// taking a break from it for a bit...\n//\n/////////////////////////////////////////////////////////////////////////////\n\n#define TRIG(d, a)      ( d * vec2( cos( a ), sin( a ) ) )\n#define PI2             6.283185307179586\n\n#define RAND2(v)        fract( 333433.444469 * sin( dot( v + 13123.2421433, vec2( 449.457, 359.367 ) ) ) )\n#define EQUALS(a,b)     step( a, b ) * step( b, a )\n\n/////////////////////////////////////////////////////////////////////////////\n// demo controls\n\n#define FLIP\n#define SHOW_UV_\n#define COLOR_TILES\n#define SCALE 3.3\n#define PAN\n#define LINE_THRESHOLD .33\n\nconst vec2 HEX_MOD = vec2( 1., sqrt( 3.) );\n\n/////////////////////////////////////////////////////////////////////////////\n// helper functions\n\nmat2 rotate2d( in float angle ) {\n    angle *= PI2;\n    return mat2(\n        cos( angle ), -sin( angle ),\n        sin( angle ),  cos( angle )\n    );\n}\n\nvec2 which( in vec2 current, in vec2 test ) {\n    return test.y < current.y ? test : current;\n}\n\nfloat can_atan( vec2 v ) {\n    return atan( v.x, v.y );\n}\n\n/////////////////////////////////////////////////////////////////////////////\n// distance function \n\nfloat sdHex( vec2 uv ) {    \n    uv = abs( uv );\n    float angled = dot( uv, normalize( HEX_MOD ) );\n    float sides = uv.x;\n    \n    float d = max( angled, sides );\n    return d;\n}\n\n/////////////////////////////////////////////////////////////////////////////\n// the tile connections (values are fiddled and twiddled)\n\nvec2 connectLines( vec2 uv ) {\n    vec2 d = vec2( 1., 1e33 );\n\n    d = which( d, vec2( 1., abs( uv.y - .00 ) / 1.0 ) );\n    d = which( d, vec2( 2., abs( uv.x - .25 ) / 0.8 ) );\n    d = which( d, vec2( 3., abs( uv.x + .25 ) / 0.8 ) );\n    \n    float a = .0;\n    a += EQUALS( 1., d.x ) * ( uv.x + .5 );\n    a += EQUALS( 2., d.x ) * ( uv.y + .2 ) / .8;\n    a += EQUALS( 3., d.x ) * ( uv.y + .2 ) / .8;\n    d.x = a;\n    \n    return d;\n}\n\nvec2 connectCircles( vec2 uv ) {\n    vec2 d = vec2( 1., 1e33 );\n\n    float lil = .29;\n    float big = .578;\n    float side = .5;\n\n    vec2 center1 = vec2( +side, lil );\n    vec2 center2 = vec2( -side, lil );\n    vec2 center3 = vec2( +.0, -big );\n    float r = .28;\n    d = which( d, vec2( 1., length( uv - center1 ) -r) );\n    d = which( d, vec2( 2., length( uv - center2 ) -r) );\n    d = which( d, vec2( 3., length( uv - center3 ) -r) );\n   \n    float a = .0;\n    a += EQUALS( 1., d.x ) * can_atan( center1 - uv ) / ( PI2 * .5);\n    a += EQUALS( 2., d.x ) * abs( can_atan( uv  - center2 ) -1. ) / 2.6;  \n    a += EQUALS( 3., d.x ) * ( 1. - ( can_atan( uv - center3 ) + .8 ) );\n    d.x = a;\n   \n    return d;\n}\n\n\n/////////////////////////////////////////////////////////////////////////////\n// make a hex tile with a random rotation and edge types\n\nvec4 hexTile( vec2 uv ) {\n    vec2 hexMod = vec2( 1., sqrt( 3.) );\n    vec2 halb = .5 * HEX_MOD;\n    \n    vec2 a = mod( uv ,       HEX_MOD ) -halb;\n    vec2 b = mod( uv + halb, HEX_MOD ) -halb;\n    \n    vec2 nu = dot( a,a ) < dot( b,b ) ? a : b;\n    vec2 id = ( uv - nu );\n\n    float angle = atan( nu.x, nu.y );\n    float d = .5 - sdHex( nu );\n\n#ifdef FLIP    \n    float n = floor( mod( 6. * RAND2( id * 7.89 + 43.34 ), 6. ) );\n    nu *= rotate2d( 1. / 6. * n );\n#endif\n\n    vec2 da = RAND2( id ) < LINE_THRESHOLD ? connectLines( nu ) : connectCircles( nu );\n    angle = da.x;\n    d = da.y;\n\n    return vec4( angle, d, id.x, id.y );\n}\n\n/////////////////////////////////////////////////////////////////////////////\n//\n\nvec3 old1( in vec2 fragCoord ) {\n    vec2 uv = ( fragCoord - .5 * iResolution.xy ) / iResolution.y;\n    vec3 color = vec3( .0 );\n    \n    color += sin( ( sdHex( uv ) * 9. - iTime * 3. ) * 4. );\n    //color.rg += .2 * hexTile( uv * 7. ).xy;\n    //color.gb += .2 * hexTile( uv * 7. ).zw *.2;\n    return color;\n}\n\nvec3 old2( in vec2 fragCoord ) {\n    vec2 uv = ( fragCoord - .5 * iResolution.xy ) / iResolution.y;\n    vec3 color = vec3( .0 );\n    float scale = 9.;\n    \n    vec4 hexo = hexTile( scale * uv + cos( iTime * .0239 ) * 99. );\n    color.r += smoothstep( .03, .09, hexo.y * cos( hexo.z * hexo.w + iTime ) );\n    color.g += smoothstep( .03, .09, hexo.y * sin( hexo.z * hexo.w + iTime ) );\n    color.b += .5 + .5 * cos( hexo.x + iTime );\n\n    return color;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = ( fragCoord - .5 * iResolution.xy ) / iResolution.y;\n    vec2 mx = ( iMouse.xy / iResolution.xy ) * 2. -1.;\n\n    vec3 color = vec3( .0 );\n\n    float width = .22 * pow( .6 - abs( uv.y  ), .8 );\n    \n\n    uv += mx * 2.; // mouse pan\n#ifdef PAN\nuv += cos( iTime * .005 ) * 99.;\n#endif\n\n    vec4 hexo = hexTile( SCALE * uv );\n    float mask = smoothstep( .01, -.01, abs( hexo.y ) - width );\n/*  \n    never did get this quite right...\n    float eo = floor( mod( ( hexo.z + 99.) * 2.,  2. ) );\n    eo = floor( mod( (hexo.w+hexo.z+101.), 2. ) );\n    eo = eo * 2. - 1.;\n    \n    float every_other_column = floor( mod( abs(hexo.w + hexo.z), 2. ) );\n    float every_other_row    = floor( mod( hexo.z *2., 2. ) );\n    eo = mod( every_other_column - every_other_row, 2. );\n\n    //eo = every_other_column;\n    //eo = every_other_row;\n    eo = eo * 2. - 1.;\n*/\n    float eo = floor( mod( hexo.w + hexo.z, 2. ) ) * 2. - 1.; // idk...\n    \n\n#ifdef SHOW_UV\n    color.rg += mask * hexo.xy;\n#else\n    vec2 textureCoordinates = hexo.xy;\n    textureCoordinates.x += cos( eo * hexo.y * .1 + iTime * .4 );\n    \n    //color += mask * texture( iChannel0, textureCoordinates ).rgb;\n    \n    color += mask * hexTile( textureCoordinates * 4.4 ).xyy;\n#endif\n\n#ifdef COLOR_TILES\n    color.gb += (1.-mask) * fract( ( hexo.wz + 3.) * .2 ) * .3;\n#endif\n\n    fragColor = vec4( color, 1. );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3l3yRj.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[1171, 1270, 1303, 1303, 1420], [1422, 1422, 1467, 1467, 1517], [1519, 1519, 1545, 1545, 1576], [1578, 1679, 1703, 1703, 1860], [1862, 1999, 2029, 2029, 2431], [2433, 2433, 2465, 2465, 3143], [3146, 3282, 3307, 3307, 3916], [3918, 4000, 4032, 4032, 4309], [4311, 4311, 4343, 4343, 4763], [4766, 4766, 4823, 4823, 6195]]}
{"id": "3l3yzl", "name": "RayMarch study", "author": "FunMaster", "description": "First steps into raymarch", "tags": ["raymarch", "sphere", "study"], "likes": 2, "viewed": 51, "published": "Public", "date": "1609676273", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define MAX_STEPS 100\n#define MIN_DIST 0.01\n#define MAX_DIST 1000.\n#define EPSILON 0.00000001\n\n\nvec2 rotatePlane(in vec2 plane, in float angle){\n\treturn cos(angle) * plane + sin(angle) * vec2(plane.y, -plane.x);\n}\n\nvec3 rotate(in vec3 pos, in vec3 rot){\n    pos.yz = rotatePlane(pos.yz, rot.x);\n    \n    pos.xz = rotatePlane(pos.xz, rot.y);\n    \n    pos.xy = rotatePlane(pos.xy, rot.z);\n    \n    return pos;\n}\n\nfloat DistanceToPlane(in vec3 pos, in float planeOffset){\n    return pos.y + planeOffset;\n}\n\nfloat DistanceToBox(in vec3 pos, in vec3 scale){\n    vec3 q = abs(pos) - scale;\n  \n\n    return length(max(q, 0.)) + min(max(q.x, max(q.y, q.z)), 0.);\n}\n\nfloat DistanceToSphere(in vec3 pos, in vec3 spherePos, in float r){\n    return length(pos - spherePos) - r;\n}\n\nfloat smin(float a, float b, float k ) {\n    float h = clamp( 0.5+0.5*(b-a)/k, 0., 1. );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\nfloat DistanceTo(in vec3 pos){\n    return DistanceToBox(rotate(pos + vec3(7., -5., -20.), vec3(-0.1, sin(iTime), 0.)), vec3(3., 2., 3.));\n    //return smin(o, DistanceToSphere(pos, vec3(-5. + sin(iTime * 2.) * 5., 1., 20.), 3.), 1.);\n}\n\nfloat GetDist(vec3 pos){\n    float d = length(pos)-1.5;\n    return d*.7;\n}\n\nvec3 GetNormal(vec3 p) {\n\tfloat d = GetDist(p);\n    vec2 e = vec2(.01, 0);\n    \n    vec3 n = d - vec3(\n        DistanceTo(p-e.xyy),\n        DistanceTo(p-e.yxy),\n        DistanceTo(p-e.yyx));\n    \n    return normalize(n);\n}\n\nfloat GetDirectLight(in vec3 normal, in vec3 lightDir){\n    return clamp(dot(lightDir, normal), 0., 1.);\n}\n\n\nfloat GetPointLightSpecular(in vec3 normal, in vec3 pos, in vec3 lightPos){\n    vec3 attenGrad = vec3(0.006, 0.003, 0.001);\n\n    vec3 lightDir = lightPos - pos;\n    float dist = length(lightDir);\n    lightDir /= dist;\n    vec3 halfVec = normalize(lightDir - vec3(0., 0., 0.));\n    \n    float distAtten = clamp(1. / (attenGrad.x + attenGrad.y * dist + attenGrad.z * dist * dist), 0., 1.);\n    \n    return pow(clamp(dot(normal, halfVec), 0., 1.), 32.) * distAtten;\n}\n\nfloat GetPointLight(in vec3 normal, in vec3 pos, in vec3 lightPos){\n    vec3 attenGrad = vec3(0.006, 0.003, 0.001);\n\n    vec3 lightDir = lightPos - pos;\n    float dist = length(lightDir);\n    lightDir /= dist;\n    \n    float distAtten = clamp(1. / (attenGrad.x + attenGrad.y * dist + attenGrad.z * dist * dist), 0., 1.);\n    return clamp(dot(normal, lightDir), 0., 1.) * distAtten;\n}\n\n\n\n\nvoid RayMarch(in vec3 rayPos, in vec3 rayDir, out bool back, out float dist){\n    \n    dist = 0.;\n    back = false;\n    \n    for (int i = 0; i < MAX_STEPS; i++){\n        if (dist > MAX_DIST){\n            back = true;\n            break;\n        }\n        else if (DistanceTo(rayPos + rayDir * dist) < MIN_DIST)\n            break;\n        dist += DistanceTo(rayPos + rayDir * dist);\n    }\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - .5 * iResolution.xy) / iResolution.y;\n    \n    vec3 rayPos = vec3((iMouse.x) / -50., 2., 0.);\n    vec3 rayDir = normalize(vec3(uv.x, uv.y, 1.));\n    float p;\n    bool back;\n    RayMarch(rayPos, rayDir, back, p);\n    vec3 pos = rayPos + rayDir * p;\n    \n   // pos = rotate(pos + vec3(7., -5., -20.), vec3(-0.1, sin(iTime), 0.));\n    \n    //pos *= 1. - float(back);\n    \n    vec3 normals = GetNormal(pos);\n    \n    vec3 an = abs(normals);\n    an = pow(an, vec3(3.));\n    \n    an /= an.x + an.y + an.z;\n    \n   // vec3 outColor = abs(normals);\n    //vec3 outColor = texture(iChannel0, pos.xy / 4. + 0.5).rgb * an.y;\n    //+ texture(iChannel0, pos.xz / 4. + 0.5).rgb * an.y \n    //+ texture(iChannel0, pos.xy / 4. + 0.5).rgb * an.z;\n    \n    //p = 0.1;\n   // p = GetDirectLight(normals, vec3(0.7, 0.4, 0.));\n    vec3 outColor = vec3(p + GetPointLightSpecular(normals, pos, vec3(-13., 11., 2.)) + 0.3 * GetPointLight(normals, pos, vec3(-13., 11., 2.)));\n    //outColor = pow(outColor, vec3(0.454));\n    \n    \n    fragColor = vec4(normals, 1.0);\n}", "image_inputs": [{"id": "4dfGRn", "previewfilepath": "/media/ap/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3l3yzl.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[96, 96, 144, 144, 213], [215, 215, 253, 253, 409], [411, 411, 468, 468, 502], [504, 504, 552, 552, 655], [657, 657, 724, 724, 766], [768, 768, 808, 808, 899], [901, 901, 931, 931, 1136], [1138, 1138, 1162, 1162, 1212], [1214, 1214, 1238, 1238, 1436], [1438, 1438, 1493, 1493, 1544], [1547, 1547, 1622, 1622, 2011], [2013, 2013, 2080, 2080, 2396], [2401, 2401, 2478, 2478, 2789], [2791, 2791, 2848, 2848, 3917]]}
{"id": "3lcczX", "name": "R-Disc", "author": "luckyballa", "description": "Random 2021 code", "tags": ["metal", "disk", "reflective"], "likes": 1, "viewed": 74, "published": "Public", "date": "1609573538", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float disk(vec2 uv,vec2 rotation) {\n    return  cos(length(uv * 2.) * 20. + iTime * 3.) * atan(uv.y * 7., 2.);   \n}\n\n\n//from https://www.shadertoy.com/view/ltVyWh\nvec3 phong(vec3 p, float t){\n    vec3 L1 = 3.*vec3(sin(2.5*t),cos(t),sin(t));\n    float dt = t+2.;\n    vec3 L2 = 3.*vec3(sin(2.5*dt),cos(dt),sin(dt));\n    vec3 i1s = vec3(1.);\n    vec3 i1d = vec3(1.);\n    vec3 ia = .4*vec3(1.);\n    \n    vec3 Tks = vec3(.7);\n    vec3 Tkd = .5*vec3(.9);\n    vec3 Tka = 3.*vec3(.45);\n    float alp = 100.;\n    \n    \n    vec3 L1v = normalize(L1-p);\n    vec3 L2v = normalize(L2-p);\n    vec3 N = p;\n    vec3 R1 = normalize(reflect(L1v,N));\n    vec3 R2 = normalize(reflect(L2v,N));\n    vec3 J,Q;\n    float temp = dot(L1v,N);\n    float stemp = dot(R1,L1v);\n    if(temp>0.){J = Tkd*i1d*temp;}\n    if(stemp>0.){Q = Tks*i1d*pow(stemp,alp);}\n    float temp2 = dot(L2v,N);\n    float stemp2 = dot(R2,L2v);\n    if(temp2>0.){J += Tkd*i1d*temp2;}\n    if(stemp2>0.){Q += Tks*i1d*pow(stemp2,alp);}\n    \n    float k = 10.;\n    vec3 ir = Tka*ia*(.15*\n         vec3(\n         sin(k*temp)+sin(k*temp2),\n         sin(k*temp+.75)+sin(10.*temp2+.75),\n         cos(k*temp)+cos(k*temp2))\n         +1.3);\n    \n    vec3 I = ir + J + Q;\n    return I;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 rotation = vec2(sin(iTime), cos(iTime));\n    vec2 uv = fragCoord/iResolution.xy;\n    uv += sin(iTime) / 5.; uv -=  .5;\n    uv *=  abs(sin(iTime / 8.) + 0.5) * 1.2;\n    float r = disk(uv, rotation)  +  min(dot(uv + rotation * 1.5, uv + rotation), 2.);                 \n    uv.x -= mod(r, 0.85) * 2.;              \n    vec3 col = vec3(0.3,0.3252,0.859) +  mod(length(uv * 2.), 0.05) * 5.;                 \n    fragColor = vec4( phong(vec3(r), 0.1), 1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3lcczX.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 35, 35, 115], [118, 163, 191, 191, 1218], [1220, 1220, 1277, 1277, 1740]]}
{"id": "3lcyRs", "name": "Clouds from Above", "author": "tomolt", "description": "Attempting to mimic clouds seen on satellite images of earth.\nMy plan is to combine this with a simple sphere tracer and some procedural terrain color\nto produce some kind of earth-like planet.", "tags": ["clouds"], "likes": 3, "viewed": 112, "published": "Public", "date": "1609693317", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Written by Thomas Oltmann, placed into the public domain.\n\n#define TAU 6.283185307179586476925286766559 // tau is two times pi\n#define RR2 0.707106781186547524400844362105 // reciprocal of square root of 2\n\nfloat rand(vec2 co) {\n    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nfloat evolve(float v) {\n    v = v*100.0+iTime*1.5;\n    v = sin(v/9.9)*sin(v/7.0);\n    v = v*0.5+0.5;\n    return v;\n}\n\nvec2 swirlgen(vec2 co) {\n    float r1 = rand(co);\n    float r2 = rand(co+vec2(12.0,21.0));\n    r1 = evolve(r1);\n    r2 = evolve(r2);\n    float angle = r1*TAU;\n    float len = r2;\n    return vec2(sin(angle),cos(angle))*len;\n}\n\nvec2 swirloct(vec2 co) {\n    vec2 i = floor(co);\n    vec2 f = co-i;\n    vec2 t = smoothstep(0.0,1.0,f);\n    vec2 ll = swirlgen(i+vec2(0.0,0.0));\n    vec2 lh = swirlgen(i+vec2(0.0,1.0));\n    vec2 hl = swirlgen(i+vec2(1.0,0.0));\n    vec2 hh = swirlgen(i+vec2(1.0,1.0));\n    return mix(\n        mix(ll, hl, t.x),\n        mix(lh, hh, t.x),\n        t.y);\n}\n\nvec2 swirl(vec2 co) {\n    vec2 val = vec2(0.0);\n    float freq = 1.0;\n    float ampl = 1.0;\n    for (int i = 0; i < 8; ++i) {\n        val += ampl*swirloct(co*freq);\n        freq *= 2.0;\n        ampl *= 0.5;\n    }\n    return val;\n}\n\nfloat noisegen(vec2 co) {\n    float val = rand(co);\n    //val = evolve(val);\n    return val;\n}\n\nvec3 noiseoct(vec2 co) {\n    vec2 i = floor(co);\n    vec2 f = co-i;\n    vec2 t = -2.0*f*f*f+3.0*f*f;\n    float ll = noisegen(i+vec2(0.0,0.0));\n    float lh = noisegen(i+vec2(0.0,1.0));\n    float hl = noisegen(i+vec2(1.0,0.0));\n    float hh = noisegen(i+vec2(1.0,1.0));\n    vec3 val;\n    val.z = mix(\n        mix(ll, hl, t.x),\n        mix(lh, hh, t.x),\n        t.y);\n    val.x = (mix(hl, hh, t.y) - mix(ll, lh, t.y)) * (-6.0*f.x*f.x+6.0*f.x);\n    val.y = (mix(lh, hh, t.x) - mix(ll, hl, t.x)) * (-6.0*f.y*f.y+6.0*f.y);\n    return val;\n}\n\nvec3 noise(vec2 co) {\n    vec3 val = vec3(0.0);\n    float freq = 1.0;\n    float ampl = 1.0;\n    for (int i = 0; i < 8; ++i) {\n        val += ampl*noiseoct(co*freq);\n        freq *= 1.995;\n        ampl *= 0.5;\n    }\n    return val;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    uv *= 7.0;\n    \n    uv += 0.3*swirl(uv);\n    \n    vec3 n = noise(uv+vec2(0.11,0.04)*iTime);\n    \n    vec3 norm = normalize(vec3(-n.xy, 0.3));\n    \n    vec3 light = normalize(vec3(1.0, 1.0, 2.0));\n    float diff = max(dot(norm,light),0.0);\n    \n    vec3 col;\n    col = mix(vec3(0.0,0.7,0.8), vec3(0.9,0.9,0.8), diff);\n    col = mix(vec3(0.05,0.15,0.2), col, max(n.z*1.5-1.6,0.0));\n    //col = vec3(n.x*0.5+0.5, n.y*0.5+0.5,n.z);\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3lcyRs.jpg", "access": "shaders20k", "license": "public-domain", "functions": [[0, 210, 231, 231, 303], [305, 305, 328, 328, 421], [423, 423, 447, 447, 647], [649, 649, 673, 673, 1000], [1002, 1002, 1023, 1023, 1232], [1234, 1234, 1259, 1259, 1328], [1330, 1330, 1354, 1354, 1865], [1867, 1867, 1888, 1888, 2099], [2101, 2101, 2156, 2206, 2745]]}
{"id": "3lcyWX", "name": "Airplane - Modelling Exercise", "author": "oneshade", "description": "Probably my best SDF model yet! I am planning on using it in a game or something else related.", "tags": ["sdf", "exercise", "modelling", "airplane"], "likes": 5, "viewed": 78, "published": "Public", "date": "1609971406", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/*\nProbably my best SDF model yet!\nIf you have suggestions on how to improve the propeller SDF I would really like to\nknow. In case you are wondering it is a squashed Bernoulli lemniscate.\n\nThe MIT License\nCopyright © 2020 Elijah Bevers\nPermission is hereby granted, free of charge, to any person obtaining a copy of this software and\nassociated documentation files (the \"Software\"), to deal in the Software without restriction, including\nwithout limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the\nfollowing conditions: The above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY\nKIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A\nPARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR\nANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n*/\n\n// Distance functions and SDF operators are from Inigo Quilez's distance functions article (https://www.iquilezles.org/www/articles/distfunctions/distfunctions.htm):\nfloat opExtrusion(in vec3 p, in float d, in float h) {\n    // d is the distance to the 2D shape using the x and y components of p\n    vec2 w = vec2(d, abs(p.z) - h);\n    return min(max(w.x, w.y), 0.0) + length(max(w, 0.0));\n}\n\nvec3 opTwist(in vec3 p, in float t) {\n    float c = cos(t * p.y);\n    float s = sin(t * p.y);\n    mat2 m = mat2(c, -s, s, c);\n    return vec3(m * p.xz, p.y);\n}\n\nfloat sdBox2D(in vec2 p, in vec2 b) {\n    vec2 q = abs(p) - b;\n    return length(max(q, 0.0)) + min(max(q.x, q.y), 0.0);\n}\n\nfloat sdTrapezoid(in vec2 p, in float r1, in float r2, in float he) {\n    vec2 k1 = vec2(r2, he);\n    vec2 k2 = vec2(r2 - r1, 2.0 * he);\n\n\tp.x = abs(p.x);\n    vec2 ca = vec2(max(0.0, p.x - ((p.y < 0.0) ? r1 : r2)), abs(p.y) - he);\n    vec2 cb = p - k1 + k2 * clamp(dot(k1 - p, k2) / dot(k2, k2), 0.0, 1.0);\n    \n    float s = (cb.x < 0.0 && ca.y < 0.0) ? -1.0 : 1.0;\n    \n    return s * sqrt(min(dot(ca, ca), dot(cb, cb)));\n}\n\nfloat sdBox(in vec3 p, in vec3 b) {\n    vec3 q = abs(p) - b;\n    return length(max(q, 0.0)) + min(max(q.x, max(q.y, q.z)), 0.0);\n}\n\nfloat sdCylinder(in vec3 p, in float h, in float r) {\n    vec2 d = abs(vec2(length(p.xz), p.y)) - vec2(r, h);\n    return min(max(d.x, d.y), 0.0) + length(max(d, 0.0));\n}\n\nfloat BernoulliDE(in vec2 p, in vec2 scale) {\n    vec2 ps = p / scale;\n\n    float l = ps.x - 1.0;\n    float r = ps.x + 1.0;\n    float ys = ps.y * ps.y;\n\n    float bernoulli = sqrt(l * l + ys) * sqrt(r * r + ys) - 1.0;\n\n    vec2 pSqrS = p / (scale * scale);\n    float sInvX = 1.0 / scale.x;\n    float ls = pSqrS.x - sInvX;\n    float rs = pSqrS.x + sInvX;\n\n    float psSqrY = ps.y * ps.y;\n    float ld = sqrt(l * l + psSqrY);\n    float rd = sqrt(r * r + psSqrY);\n\n    float pdx = (ls * rd) / ld + (rs * ld) / rd;\n    float pdy = (rd / ld + ld / rd) * pSqrS.y;\n    float bernoulliGrad = sqrt(pdx * pdx + pdy * pdy);\n\n    return bernoulli / bernoulliGrad;\n}\n\nfloat mapScene(in vec3 p) {\n    float airplane = sdBox(p, vec3(0.4, 0.4, 2.8)) - 0.146;\n    airplane += smoothstep(-4.0, 10.0, p.z);\n\n    vec3 wp = p;\n    wp.yz *= mat2(0.99801615628, 0.06295833376, -0.06295833376, 0.99801615628);\n\n    float wing = sdTrapezoid(p.xz + vec2(0.0, 1.4), 2.85, 2.7, 0.3) - 0.25;\n    airplane = min(airplane, opExtrusion(wp.xzy - vec3(0.0, 0.0, 0.212), wing, 0.052) - 0.1);\n\n    vec3 tp = p - vec3(0.0, 0.0, 2.5);\n    float tail = sdTrapezoid(tp.xz, 0.85, 1.0, 0.475) - 0.1;\n    airplane = min(airplane, opExtrusion(tp.xzy, tail, 0.05) - 0.1);\n\n    tp.yz -= vec2(1.0, 0.25 * tp.y - 0.025);\n    tail = sdBox2D(tp.zy, vec2(0.3, 0.75)) - 0.1;\n    tail = 0.82 * tail + tp.y * 0.164;\n    airplane = min(airplane, opExtrusion(tp.zyx, tail, 0.05) - 0.1);\n\n    vec3 pp = p + vec3(0.0, 0.0, 3.0);\n\n    float r = iTime * 5.0;\n    float c = cos(r), s = sin(r);\n    pp.xy *= mat2(c, s, -s, c);\n\n    airplane = min(airplane, sdCylinder(pp.xzy, 0.05, 0.2));\n\n    float prop;\n    if (abs(pp.x) > 1.5 || abs(pp.y) > 1.05 || abs(pp.z) > 0.25) {\n        prop = sdBox(pp, vec3(1.4, 0.95, 0.2));\n    }\n\n    else {\n        pp = opTwist(pp, 0.4).xzy;\n        prop = opExtrusion(pp, BernoulliDE(pp.xy, vec2(1.0, 0.5)), 0.02) - 0.02;\n        prop *= 0.9;\n    }\n\n    airplane = min(airplane, prop);\n\n    vec3 sp = vec3(abs(wp.x) - 0.51, p.yz + vec2(1.0, 2.5));\n    sp.xy *= mat2(0.98877107793, 0.14943813247, -0.14943813247, 0.98877107793);\n\n    float struts = sdTrapezoid(sp.zy, 0.1, 0.2, 0.55) - 0.05;\n    airplane = min(airplane, opExtrusion(sp.yzx, struts, 0.03) - 0.025);\n\n    wp = sp + vec3(0.0, 0.5, 0.0);\n    float wheels = sdCylinder(wp.yxz, 0.1, 0.24) - 0.05;\n    airplane = min(airplane, wheels);\n\n    return airplane;\n}\n\nvec3 getNormal(in vec3 p) {\n    return normalize(vec3(mapScene(p + vec3(0.001, 0.0, 0.0)) - mapScene(p - vec3(0.001, 0.0, 0.0)),\n                          mapScene(p + vec3(0.0, 0.001, 0.0)) - mapScene(p - vec3(0.0, 0.001, 0.0)),\n                          mapScene(p + vec3(0.0, 0.0, 0.001)) - mapScene(p - vec3(0.0, 0.0, 0.001))));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (fragCoord.xy - 0.5 * iResolution.xy) / iResolution.y;\n    fragColor = vec4(0.0, 0.0, 0.0, 1.0);\n\n    vec3 ro = vec3(0.0, 0.0, 10.0);\n    vec3 rd = normalize(vec3(uv, -1.0));\n\n    float c1 = cos(iTime), s1 = sin(iTime);\n    float c2 = cos(0.25), s2 = sin(0.25);\n\n    float t = 0.0;\n    for (float iters=0.0; iters < 150.0; iters++) {\n        vec3 p = ro + rd * t;\n\n        p.y += 0.5;\n        p.xz *= mat2(c1, -s1, s1, c1);\n        p.yz *= mat2(c2, s2, -s2, c2);\n\n        float d = mapScene(p / 1.5) * 1.5;\n        if (d < 0.001) {\n            vec3 n = getNormal(p / 1.5) * 1.2;\n            vec3 l = vec3(-0.58, 0.58, 0.58);\n\n            n.yz *= mat2(c2, -s2, s2, c2);\n            n.xz *= mat2(c1, s1, -s1, c1);\n\n            fragColor.rg += max(0.2, dot(n, l));\n            break;\n        }\n\n        if (t > 50.0) {\n            break;\n        }\n\n        t += d;\n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3lcyWX.jpg", "access": "shaders20k", "license": "mit", "functions": [[1263, 1429, 1483, 1558, 1654], [1656, 1656, 1693, 1693, 1815], [1817, 1817, 1854, 1854, 1939], [1941, 1941, 2010, 2010, 2366], [2368, 2368, 2403, 2403, 2498], [2500, 2500, 2553, 2553, 2669], [2671, 2671, 2716, 2716, 3324], [3326, 3326, 3353, 3353, 5060], [5062, 5062, 5089, 5089, 5396], [5398, 5398, 5453, 5453, 6337]]}
{"id": "3ldcWs", "name": "Mini Hill Climb Racing", "author": "tonifing", "description": "Trying to learn raymarching, so wrote a mini hill climb racing version.\n\nLearned a lot from examples around shadertoy, so thanks to everyone!\n\nShader originally written to fit into a \"playable\" 4k executable and then transferred here", "tags": ["raymarching", "mini", "hcr", "hillclimbracing"], "likes": 5, "viewed": 247, "published": "Public API", "date": "1610224884", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/*\nA learning experience into shaders and raymarching.\n\nOriginally written to fit into a \"playable\" 4k executable.\n\nLots of things learned and copy pasted from: https://www.iquilezles.org/\nAlso used Leviathan 2.0 for the 4k, there's a lot learned from it and some code present: https://github.com/armak/Leviathan-2.0\n*/\n\nvec4 m;\nvec2 v;\n\nvec3 jeep;\nvec3 frontWheelOffset = vec3(0.9, -0.4, -0.7);\nvec3 rearWheelOffset = vec3(-0.9, -0.4, -0.7);\n\n//These are used as constants\nvec3 cFrontWheelOffset = vec3(0.9, -0.25, -0.7);\nvec3 cRearWheelOffset = vec3(-0.9, -0.25, -0.7);\n\nvec3 lightPos;\n\nfloat PI = 3.1416;\n\nfloat hash(float c){return fract(sin(dot(c, 12.9898)) * 43758.5453);}\n\n//Rotation\nmat3 rx(float a){return mat3(1.0,0.0,0.0,0.0,cos(a),-sin(a),0.0,sin(a),cos(a));}\nmat3 ry(float a){return mat3(cos(a),0.0,sin(a),0.0,1.0,0.0,-sin(a),0.0,cos(a));}\nmat3 rz(float a){return mat3(cos(a),-sin(a),0.0,sin(a),cos(a),0.0,0.0,0.0,1.0);}\n\n//Smoothmin, can be used to \"blend\" 2 distancefields together smoothly\nfloat opSmoothMin( float a, float b, float k )\n{\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\n\nvec2 opUnion(vec2 d1, vec2 d2)\n{\n\t//min(d1,d2);\n\treturn (d1.x<d2.x) ? d1 : d2;\n}\n\nvec2 opSubtract(vec2 d1, vec2 d2)\n{\n\t//max(-d1,d2);\n\treturn ((-d1.x)>d2.x) ? -d1 : d2;\n}\n\nvec2 opIntersect(vec2 d1, vec2 d2)\n{\n\t//max(d1,d2);\n\treturn (d1.x>d2.x) ? d1 : d2;\n}\n\n\n//Slightly simplified original equation for HCR1: Countryside\nfloat heightAt(float x)\n{\n\tx*=1.5;\n    x+=10.0;\n\treturn (cos(x/10.0)*2.0 +\n\t\t    +(cos(x+(sin(x*0.25)))*0.2*min(x*0.0015, 1.0f))\n\t        +(cos(x*0.17+(sin(x*0.25)))*2.0*min(x*0.00075, 1.0f))\n\t        +(cos(x*0.0952+(sin(x*0.15)))*2.0*min(x*0.00275, 1.0f))\n\t\t    +(-1.0 + sin(x/30.0+cos(x/32.14))*4.0*min(x*0.00075, 1.0f)))\n\t\t\t*(0.5+x/2000.0);\n}\n\nfloat sdRoundBox(vec3 p, vec3 b, float r )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0) - r;\n}\n\nfloat sdPlane( vec3 p, vec3 n, float h )\n{\n  // n must be normalized\n  return dot(p,n) + h;\n}\n\nfloat sdBox(vec3 p, vec3 b)\n{\n\treturn max(max(abs(p.x)-b.x,abs(p.y)-b.y),abs(p.z)-b.z);\n}\n\nfloat sdSphere(vec3 p, float r)\n{\n\treturn length(p) - r;\n}\n\nfloat sdCappedCylinder( vec3 p, float h, float r )\n{\n  vec2 d = abs(vec2(length(p.xy),p.z)) - vec2(h,r);\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat sdCappedCylinderXZ( vec3 p, float h, float r )\n{\n  //p.x += 1.0-sin(PI*0.5-(r + p.y)*m.y*0.1);\n  vec2 d = abs(vec2(length(p.xz),p.y)) - vec2(h,r);\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat sdCircle2D(vec2 p, vec2 c, float r)\n{\n\tfloat m = 0.1+max(dot(normalize(p-c), normalize(vec2(1, -1))), 0.0)*1.9;\n\treturn clamp(1.0-pow(1.0-(length(p-c)-r)*2.5, 0.075*m), 0.0, 1.0);\n}\n\nvec3 getMaterialColor(vec3 p, float material)\n{\n\tint c=int(material);\n\tif (c==0) return mix(vec3(36.0, 212.0, 255.0)/255.0, vec3(161.0, 236.0, 255.0)/255.0, v.y); //Skycolor \n\tif (c==1) return mix(vec3(98.0, 169.0, 0.0) / 255.0, vec3(173.0, 234.0, 81.0) / 255.0, pow(1.0-clamp(abs(p.z-4.0)/1.9, 0.0, 1.0), 0.1));\t//Surface color\n\tif (c==2) return vec3(98.0 , 169.0, 0.0  ) / 255.0; //Guess I forgot to use this\n\tif (c==3) //Terrain (underground part)\n\t{\n\t\t//Texture some circles for this material\n\t\tvec2 q = mod(p.xy*0.5+0.5*5.0,5.0)-0.5*5.0;\n\t\t\n\t\tfloat d = sdCircle2D(q, vec2(0.1, 0.5), 0.3);\n\t\td = max(d, sdCircle2D(q, vec2(1.5, -0.5), 0.25));\n\t\td = max(d, sdCircle2D(q, vec2(-0.5, -1.5), 0.17));\n\t\td = max(d, sdCircle2D(q, vec2(2.0, 1.5), 0.08));\n\t\td = max(d, sdCircle2D(q, vec2(-2.0, 0), 0.05));\n\t\t\n\t\t//Repeat a few circle on edge of texture to simulate tiling\n\t\td = max(d, sdCircle2D(q, vec2(0.5, -2.7), 0.08));\n\t\td = max(d, sdCircle2D(q, vec2(0.5, 2.3), 0.08));\n\t\t\n\t\td = max(d, sdCircle2D(q, vec2(2.8, -2.0), 0.08));\n\t\td = max(d, sdCircle2D(q, vec2(-2.2, -2.0), 0.08));\n\t\treturn vec3(63.0 , 50.0 , 34.0 ) / 255.0*(2.0-d);\n\t}\n\tif (c==4) return vec3(168.0, 0.0  , 0.0  ) / 255.0; //Jeep chassis\n\tif (c==5) return vec3(50.0 , 50.0 , 50.0 ) / 255.0; //Jeep tires\n\tif (c==6) return vec3(150.0, 150.0, 150.0) / 255.0; //Jeep rims\n\tif (c==7) return vec3(192.0, 74.0 , 81.0 ) / 255.0; //Bill: Clothes red\n\tif (c==8) return vec3(207.0, 191.0, 168.0) / 255.0*1.1; //Bill: Head\n\tif (c==9) return vec3(225.0, 211.0, 196.0) / 255.0*1.2; //Bill: Eyes\n\n\treturn vec3(0,1,0);\n}\n\nfloat getMaterialReflectivity(float material)\n{\n\tif (material==1.0) return 0.1; //Terrain, just a little to see the jeep from the ground\n\tif (material==4.0) return 0.2; //Jeep chassis\n\tif (material==6.0) return 0.4; //Jeep rims\n\treturn 0.0;\n}\n\nfloat getMaterialSpecular(float material)\n{\n\tif (material == 1.0) return 0.0; //No specular on terrain surface\n\tif (material >= 7.0) return 0.05; //Only minimal specular on bill\n\t\n\treturn 1.0;\n}\n\nfloat materialAmbient(float material)\n{\n\tif (material==3.0) return 0.65; //Terrain\n\tif (material==4.0) return 0.4; //Jeep chassis\n\tif (material==5.0) return 0.3; //Jeep tires\n\treturn 0.2;\n}\n\n//This defines our whole scene content, it returns distance to a point in the world\nvec2 map(vec3 p, bool shadowPass)\n{\n\tvec2 d = vec2(100.0, 0.0);\n\t\n\t//Terrain\n\tif (!shadowPass)\n\t{\n\t\t//Terrain\n\t\td = opIntersect(vec2(p.y - heightAt(p.x), 1.0),\n\t\t\t\t\t    vec2(-sdPlane(p, vec3(0.0, 0.0, 1.0), -2.0), 3.0));\n\t\t\n\t\t//Sky plane\n\t\td = opIntersect(d, vec2(-sdPlane(p, vec3(0.0, 0.0, -1.0), 6.0), 3.0));\n\t}\n\n\tvec2 dfJeep = opUnion(vec2(100.0, 0.0),\n\t\t\t\t\tvec2(\n\t\t\t\t\t\topSmoothMin(\n\t\t\t\t\t\t\topSmoothMin(\n\t\t\t\t\t\t\t\topSmoothMin(\n\t\t\t\t\t\t\t\t\tsdRoundBox((p-jeep)*rz(m.z), vec3(1.6, 0.3, 0.8),0.1), //Chassis\n\t\t\t\t\t\t\t\t\tsdRoundBox((p-(jeep + vec3(0.45, 0.6, 0.0)*rz(-m.z)))*rz(m.z-0.3), vec3(0.05, 0.25, 0.7),0.03), //Windscreen\n\t\t\t\t\t\t\t\t\t0.1),\n\t\t\t\t\t\t\t\tsdRoundBox((p-jeep-vec3(-1.65,0.37,0)*rz(-m.z))*rz(m.z+0.7), vec3(0.1, 0.02, 0.65),0.065), //Spoiler\n\t\t\t\t\t\t\t\t0.12),\n\t\t\t\t\t\t\tsdRoundBox((p-jeep-vec3(1.05,0.4,0)*rz(-m.z))*rz(m.z-0.15), vec3(0.2, 0.1, 0.25),0.035), 0.05),\t//Scoop\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t4.0)\n\t\t\t\t\t); \n\t//dfJeep = opSmoothMin(dfJeep, vec2(sdRoundBox((p-jeep-vec3(1.2,0.45,0)*rz(-m.z))*rz(m.z-0.2), vec3(0.2, 0.1, 0.25),0.035), 4.0); //Scoop\n\t\t\t\t\t\t\n\t//Jeep: Interior\n\tdfJeep = opIntersect(dfJeep, vec2(-sdBox((p-jeep-vec3(-0.2,0.1,0)*rz(-m.z))*rz(m.z), vec3(0.6, 0.5, 0.7)), 5.0));\n\t\n\t//Bumper\n\tdfJeep = opUnion(dfJeep, vec2(sdRoundBox((p-jeep-vec3(0.0,-0.3,0)*rz(-m.z))*rz(m.z), vec3(1.7, 0.05, 0.85),0.1), 5.0));\n\t\n\t//Car wheels\n\t{\n\t\tvec3 q = p;\n\t\t//Wheels\n\t\tq.z = abs(q.z-jeep.z)+2.4;\n\t\tdfJeep = opIntersect(dfJeep, vec2(-sdCappedCylinder((q-(jeep + cFrontWheelOffset*rz(-m.z)))*rz(m.z-0.3), 0.55, 0.2), 5.0));\n\t\tdfJeep = opIntersect(dfJeep, vec2(-sdCappedCylinder((q-(jeep + cRearWheelOffset*rz(-m.z)))*rz(m.z-0.3), 0.55, 0.2), 5.0));\n\t\t\n\t\t//Wheel covers\n\t\tq.z = abs(p.z-jeep.z)+2.5;\n\t\tdfJeep = opUnion(dfJeep, vec2(sdCappedCylinder((q-(jeep + frontWheelOffset*rz(-m.z)))*rz(m.z-0.3), 0.5,0.2), 5.0));\n\t\tdfJeep = opUnion(dfJeep, vec2(sdCappedCylinder((q-(jeep +  rearWheelOffset*rz(-m.z)))*rz(m.z-0.3), 0.5,0.2), 5.0));\n\t\t\n\t\t//Rims\n\t\tdfJeep = opUnion(dfJeep, vec2(sdCappedCylinder((q-(jeep + frontWheelOffset*rz(-m.z)))*rz(m.z-0.3), 0.3,0.21), 6.0));\n\t\tdfJeep = opUnion(dfJeep, vec2(sdCappedCylinder((q-(jeep +  rearWheelOffset*rz(-m.z)))*rz(m.z-0.3), 0.3,0.21), 6.0));\n\t}\n\t\n\t//Seat\n\tdfJeep = opUnion(dfJeep, vec2(sdRoundBox((p-jeep-vec3(-0.6,0.15,0)*rz(-m.z))*rz(m.z-0.2), vec3(0.05, 0.4, 0.5),0.1), 5.0));\n\t\n\t//Now put together with scene\n\td = opUnion(d, dfJeep);\n\t\n\t//Antenna\n\td = opUnion(d, vec2(sdCappedCylinderXZ((p-(jeep + vec3(-1.2, 1.2, 0.4)*rz(-m.z)))*rz(m.z), 0.075,0.8), 5.0));\n\t\n\t//Bill himself\n\t//Torso\n\tfloat fd = opSmoothMin(\n\t\t\t\t\tsdRoundBox((p-jeep-vec3(-0.15,0.3,0)*rz(-m.z))*rz(m.z-0.2), vec3(0.1, 0.45, 0.35),0.1),\n\t\t\t\t\tsdSphere((p-jeep-vec3(-0.15,0.3,0)*rz(-m.z))*rz(m.z), 0.55),\n\t\t\t\t\t0.2);\n\tfd = opSmoothMin(fd, sdSphere((p-jeep-vec3(0.05,0.67,-0.2)*rz(-m.z))*rz(m.z), 0.15), 0.1);\n\tfd = opSmoothMin(fd, sdSphere((p-jeep-vec3(0.05,0.67,0.2)*rz(-m.z))*rz(m.z), 0.15), 0.1);\n\td = opUnion(d, vec2(fd, 7.0));\n\t\t\n\t//Head\n\td = opUnion(d, vec2(sdSphere((p-jeep-vec3(-0.35,1.2,0)*rz(-m.z))*rz(m.z), 0.35), 8.0));\n\t\t\n\t//Nose\n\td = opUnion(d, vec2(sdSphere((p-jeep-vec3(-0.05,1.2,0)*rz(-m.z))*rz(m.z), 0.125), 8.0));\n\t\t\n\t//Eyes\n\td = opUnion(d, vec2(sdSphere((p-jeep-vec3(-0.125,1.3,0.12)*rz(-m.z))*rz(m.z), 0.12), 9.0));\n\td = opUnion(d, vec2(sdSphere((p-jeep-vec3(-0.125,1.3,-0.12)*rz(-m.z))*rz(m.z), 0.12), 9.0));\n\t\t\n\td = opUnion(d, vec2(sdSphere((p-jeep-vec3(-0.0,1.32,0.12)*rz(-m.z))*rz(m.z), 0.04), 5.0));\n\td = opUnion(d, vec2(sdSphere((p-jeep-vec3(-0.0,1.32,-0.12)*rz(-m.z))*rz(m.z), 0.04), 5.0));\n\t\t\n\t//Hat\n\tvec2 dHat = opIntersect(vec2(sdSphere((p-jeep-vec3(-0.38,1.25,0)*rz(-m.z))*rz(m.z), 0.35), 7.0),\n\t\t\t\t\t        vec2(sdPlane((p-jeep-vec3(-0.38,1.25,0)*rz(-m.z))*rz(m.z), normalize(vec3(0.6,-1.0,0.0)), 0.1), 7.0));\n\t\t\n\tfloat hatCurve = min(pow(abs(4.0-p.z), 2.0), 1.0);\n\tdHat.x = opSmoothMin(dHat.x, sdRoundBox((p-jeep-vec3(-0.8+hatCurve,1.2-hatCurve*0.6,0)*rz(-m.z))*rz(m.z-0.5), vec3(0.2, 0.02, 0.24),0.02),0.07);\n\td = opUnion(d,dHat);\n\treturn d;\n}\n\nvec3 rhs(vec3 dir, float i)\n{\n\tvec2 rnd = vec2(hash(i+1.), hash(i+2.));\n\tfloat s = rnd.x*PI*2.;\n\tfloat t = rnd.y*2.-1.;\n\tvec3 v = vec3(sin(s), cos(s), t) / sqrt(1.0 + t * t);\n\treturn v * sign(dot(v, dir));\n}\n\nfloat ao( vec3 p, vec3 n, float maxDist, float falloff)\n{\n\tfloat ao = 0.0;\n\tfor( int i=0; i<10; i++ )\n\t{\n\t\tfloat l = hash(float(i))*maxDist;\n\t\tvec3 rd = normalize(n+rhs(n, l )*0.95)*l;\n\t\tao += (l - map( p + rd, false).x) / pow(1.+l, falloff);\n\t}\n\treturn clamp(1.-ao*0.1,0.0,999.0);\n}\n\nvec3 normal(vec3 p)\n{\n    // Copy from iq shader.\n    // inspired by tdhooper and klems - a way to prevent the compiler from inlining map() 4 times\n    vec3 n = vec3(0.0);\n    for( int i=0; i<4; i++ )\n    {\n        vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);\n        n += e*map(p+0.0005*e, false).x;\n    }\n    return normalize(n);\n}\n\n//Raymarch soft shadows\nfloat softshadow( vec3 ro, vec3 rd, float mint, float maxt, float k )\n{\n    float res = maxt;\n    float ph = 1e20;\n    for( float t=mint; t<maxt; )\n    {\n        float h = map(ro + rd*t, true).x;\n        if( h<0.001 )\n            return 0.0;\n\n        float y = h*h/(2.0*ph);\n        float d = sqrt(h*h-y*y);\n        res = min( res, k*d/max(0.0,t-y) );\n        ph = h;\n        t += h*0.5+0.01;\n    }\n    return res;\n}\n\n//This goes forward until close enough to a surface\nvec3 raymarch( vec3 ro, vec3 rd, out float material, const int iterationCount, const float step)\n{\n\tvec3 p = ro;\n\tvec2 d;\n\tfloat t = .0;\n\tfor(int i=0; i<iterationCount; i++)\n\t{\n\t\td = map(p, false);\n\t\tif( d.x < 0.01)\n\t\t{\n\t\t\tmaterial = d.y;\n\t\t\tbreak;\n\t\t}\n\t\t\n\t\tif (t > 100.0)\n\t\t{\n\t\t\tmaterial = 0.0;\n\t\t\treturn p;\n\t\t}\n\t\t\n\t\tt += d.x*step;\n\t\tp += rd*d.x*step;\n\t}\n\tmaterial = d.y;\n\treturn p;\n}\n\nvec3 shade(vec3 p, vec3 n, vec3 rd, float material)\n{\n\tfloat light = 1.0;\n\t\n\tif (material > 0.0)\n\t{\n\t\tvec3 lightDir = normalize(lightPos-p);\n\t\tfloat lightPower = 1.0-length(lightPos-p)*0.0005;\n\n\t\t//Calculate shadows into our lighting\n\t\tfloat shadowMul = 0.5;\n\t\tif (material != 3.0)\n\t\t\tshadowMul = softshadow(p, normalize(lightPos-p), 0.1, 20.0 , 12.0);\n\t\t\t\t\n\t\tlightPower = lightPower*0.5f + shadowMul*0.5;\n\t\tlightPower = max(min(lightPower, 1.0), 0.0);\n\t\t\n\t\tfloat ambient = materialAmbient(material);\n\t\t\n\t\t//Calculate diffuse and specular light and ambient occlusion (specular only on jeep)\n\t\tfloat lightDiff = ambient + max(dot(n, lightDir), 0.0) * lightPower * 1.0 * ao(p, n, 2.0, 2.0)*0.7;\n\t\t\n\t\tfloat lightSpec = pow(max(dot(reflect(rd, n), lightDir), 0.0), 8.0) * getMaterialSpecular(material);\n\t\tlight = (lightDiff + lightSpec);\n\t}\n\treturn getMaterialColor(p, material) * light;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 q = fragCoord/iResolution.xy;\n\tvec2 v = -1.0+2.0*q;\n\tv.x *= iResolution.x/iResolution.y;\n\t\n\t//Scale our input vector back to float\n\tm.x = iTime*5.0;// = vec4(inVec) / 44100.0;\n    m.y = heightAt(m.x)+1.0;\n    m.z = atan(heightAt(m.x-0.7) - heightAt(m.x+0.7));\n    m.w = iTime*5.0;\n\t\n\t//Set jeep position from our input data\n\tjeep = vec3(m.x, m.y, 4.0);\n\t\n\t//Wheel suspension \"simulation\"\n\tvec3 wp = jeep + frontWheelOffset*rz(-m.z);\n\tif (heightAt(wp.x) < wp.y) frontWheelOffset.y = clamp(heightAt(wp.x) - wp.y, -0.8, -0.35) + 0.1;\n\twp = jeep + rearWheelOffset*rz(-m.z);\n\tif (heightAt(wp.x) < wp.y) rearWheelOffset.y = clamp(heightAt(wp.x) - wp.y, -0.8, -0.35) + 0.1;\n\n\t//Camera position\n\tfloat zoom = 0.5+pow(abs(m.x - m.w)*0.07,1.7);\n\tvec3 ro = vec3(m.w,23.0*zoom,-30.0*zoom);\n\t\n\t//Camera rotation\n\tmat3 rot = rx(0.5)*ry(clamp((m.x - m.w)/30.0, -0.5, 0.5));\n\t\n\t//Calculate average terrain height to offset camera\n\tfloat h = 0.0;\n\tfor (int i = 0; i < 20; i++)\n\t{\n\t\th +=heightAt(-5.0+ro.x+float(i)*1.0);\n\t}\n\th/=20.0;\n\tro.y += h;\n\tro += vec3( v.x, v.y, 0) * rot;\n\tvec3 rd = normalize(vec3(v.x, v.y, 7.0-abs(m.x - m.w)/4.0))*rot;\n\t\n\t//Define light position\n\tlightPos = vec3(ro.x+20.0, ro.y+20.0, 3.0);\t\t\n\n\tfloat material;\n\tvec3 p = raymarch(ro, rd, material, 80, 0.7);\n\t\t\n\tvec3 col = getMaterialColor(p, material);\n\tvec3 n = normal(p);\n\t\n\t//Calculate Lighting with a single point light (only on pixels that are not sky or terrain)\n\tif (material > 0.0)\n\t{\n\t\tcol = shade(p, n, rd, material);\n\t\t\n\t\tfloat refl = getMaterialReflectivity(material);\n\t\t//Add reflection\n\t\tif (refl > 0.0)\n\t\t{\t\n\t\t\tfloat rMaterial;\n\t\t\tvec3 rrd = reflect(rd, n);\n\t\t\tvec3 rp = raymarch(p + n*0.05, rrd, rMaterial, 60, 1.0);\n\t\t\tvec3 rn = normal(rp.xyz);\n\t\t\tvec3 rColor = shade(rp, rn, rrd, rMaterial);\n\t\t\t\n\t\t\tcol += rColor*refl;// * max(pJeep, pSurface*1.5);\t\t\t\n\t\t}\n\t}\n\n\tfragColor = vec4(col, 1);\n\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3ldcWs.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[444, 609, 629, 629, 678], [680, 691, 708, 708, 771], [772, 772, 789, 789, 852], [853, 853, 870, 870, 933], [935, 1006, 1054, 1054, 1147], [1150, 1150, 1182, 1197, 1230], [1232, 1232, 1267, 1283, 1320], [1322, 1322, 1358, 1373, 1406], [1409, 1471, 1496, 1496, 1816], [1818, 1818, 1862, 1862, 1953], [1955, 1955, 1997, 2023, 2048], [2050, 2050, 2079, 2079, 2139], [2141, 2141, 2174, 2174, 2199], [2201, 2201, 2253, 2253, 2360], [2362, 2362, 2416, 2462, 2569], [2571, 2571, 2614, 2614, 2758], [2760, 2760, 2807, 2807, 4326], [4328, 4328, 4375, 4375, 4570], [4572, 4572, 4615, 4615, 4766], [4768, 4768, 4807, 4807, 4957], [4959, 5043, 5078, 5078, 9014], [9016, 9016, 9045, 9045, 9223], [9225, 9225, 9282, 9282, 9508], [9510, 9510, 9531, 9657, 9863], [9865, 9889, 9960, 9960, 10305], [10307, 10359, 10457, 10457, 10744], [10746, 10746, 10799, 10799, 11631], [11633, 11633, 11690, 11690, 13566]]}
{"id": "3ldczl", "name": "z Snowflake generator", "author": "illus0r", "description": "z Snowflake generator\nFor the snowflake chrome plugin by Mikhail Kalygin and Natalia Stepanova\nhttps://codepen.io/illus0r/pen/mdrxzVx", "tags": ["sdf"], "likes": 2, "viewed": 170, "published": "Public API", "date": "1609723079", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float rnd(float x) {return 2.*fract(54321.987 * sin(987.12345 * x))-1.;}\nvec2 p2d(vec2 polar) {\n    float alpha = polar.x;\n    float R = polar.y;\n    float x = sin(alpha) * R;\n    float y = cos(alpha) * R;\n    return vec2(x, y);\n}\nvec2 d2p(vec2 decart) {\n    float alpha = atan(decart.x, decart.y);\n    float R = length(decart);\n    return vec2(alpha, R);\n}\nvec2 snowflakeSymmetry(vec2 p, float rays){\n\tvec2 ar = d2p(p);\n\tfloat astep = 2. * 3.1415 / rays;\n\tfloat a = ar.x, r = ar.y;\n\ta = mod(a, astep);\n\ta -= astep / 2.;\n\ta = abs(a);\n\tp = p2d(vec2(a, r));\t\n\treturn p;\n}\nmat2 rot(float a){float s=sin(a),c=cos(a);return mat2(c,-s,s,c);}\nfloat snowflake(vec2 uv, float id) {\n    uv /= 1.6;\n    for (float i = 0.; i < 3.; i++) {\n        uv *= 2.;\n        uv = snowflakeSymmetry(uv, 6.);\n        if (i == 0. && uv.y > 1.) return 0.;\n        uv *= rot(-rnd(id+i)*.3);\n        uv -= vec2(0.,.4+.1*rnd(id+i));\n    }\n    return step(.9,1.-uv.x);\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord*2.-iResolution.xy)/iResolution.y;\n    float col = snowflake(uv, floor(iTime*4.));\n    fragColor = vec4(col);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3ldczl.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 20, 20, 72], [73, 73, 95, 95, 230], [231, 231, 254, 254, 357], [358, 358, 401, 401, 569], [570, 570, 588, 588, 635], [636, 636, 672, 672, 939], [940, 940, 997, 997, 1133]]}
{"id": "3ldczX", "name": "AnimatedFractalTrip", "author": "mamont92", "description": "my test fractal shader, my 1.2kb demo porting to GLSL \n\nhttps://github.com/mamont-92/fractal", "tags": ["fractal", "complex", "trip"], "likes": 4, "viewed": 61, "published": "Public", "date": "1609632369", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define ANIMATED \n\n//----------begin------complex lib------------------\n#define complex vec2\n\nfloat cSqrt(complex val)\n{\n    return sqrt(val.x * val.x + val.y * val.y);\n}\n\nfloat cabs(complex cval)\n{\n    return sqrt(cval.x * cval.x + cval.y * cval.y);\n}\n\n\ncomplex cFromPolar(float angle, float len)\n{\n    return complex(len * sin(angle), len * cos(angle));\n}\n\ncomplex cPow(complex cValue, complex cPower)\n{\n    float ln_x1y1 = log( cabs(cValue) );\n    float a = atan( cValue.y, cValue.x );\n    \n    float e1 = exp( cPower.x *  ln_x1y1 - cPower.y * ln_x1y1);\n    float a_y2ln_x1y1 = cPower.x * a + cPower.y * ln_x1y1;\n    return cFromPolar( a_y2ln_x1y1, e1 );\n}\n//----------end------complex lib------------------\n\n//----------begin------palette lib------------------\n\n#define color vec4\n\nconst int palette_red_width   = 23; \nconst int palette_green_width = 13; \nconst int palette_blue_width  = 9; \n\nconst int palette_red_shift   = 7; \nconst int palette_green_shift = 1; \nconst int palette_blue_shift  = 3; \nconst int palette_max_colors  = 65536;\n\nANIMATED int palette_shift = 0;\n\ncolor colorFromPalettenInxed( int index )\n{\n    int redVal = (index + palette_red_shift) % palette_red_width;\n    int greenVal = (index + palette_green_shift) % palette_green_width;\n    int blueVal = (index + palette_blue_shift) % palette_blue_width;\n\n    float rVal = abs (float(redVal) / (float(palette_red_width) * 0.5) - 1.0 ) ;\n    float gVal = abs (float(greenVal) / (float(palette_green_width) * 0.5) - 1.0 ) ;\n    float bVal = abs (float(blueVal) / (float(palette_blue_width) * 0.5) - 1.0 ) ;\n    \n    return color(rVal, gVal, bVal, 1.0f);\n}\n//----------end------palette lib------------------\n\n//----------begin------fractal lib------------------\n\nconst complex fractal_constant  = complex(1.0f, 0.0f);\n\nconst complex fractal_start_power = complex(1.2f, 0.0f);\nconst complex fractal_end_power = complex(8.0f, 0.0f);\n\nconst float   fractal_start_scale = 2.5f;\nconst float   fractal_end_scale = 1.5f;\n\nconst int     fractal_max_iterations = 20;\nconst float   fractal_max_value_range = 50.0f;\n\nANIMATED complex fractal_power = fractal_start_power;\nANIMATED float   fractal_scale = fractal_start_scale;\n\ncomplex complexForCoords(vec2 coords) \n{\n    complex z = coords * fractal_scale;\n    \n    bool needContinue = true;\n    for (int i = 0; (i < fractal_max_iterations) && needContinue; i++)\n    {\n        z = cPow (z, fractal_power);\n        z = z + fractal_constant;\n        float z_abs = cabs(z);\n        \n        needContinue = ( abs(z.x) < fractal_max_value_range ) \n                        || (abs(z.y) < fractal_max_value_range)\n                        || (z_abs < fractal_max_value_range) ;\n    }\n    \n    return z;\n}\n\ncolor colorForComplex(complex cVal)\n{\n    float cVal_abs  = cabs(cVal);\n    float indexValue = log(cVal_abs) * 1.7f;\n    int index = int(indexValue) % 65536;\n    \n    return colorFromPalettenInxed(index + palette_shift);\n}\n//----------end------fractal lib------------------\n\n//----------begin------screen lib------------------\n\nvec2 getScreenNDC(vec2 fragCoord)\n{\n    vec2 screenUV = fragCoord / iResolution.xy;\n    float aspectRatio = float( iResolution.x ) / float( iResolution.y );\n    vec2 ndc = screenUV * 2.0 - vec2(1.0);\n    ndc.x *= aspectRatio;\n    \n    return ndc;\n}\n//----------end------screen lib------------------\n\n//----------begin------animation lib------------------\n\nconst float animation_palette_time_scale = 10.0;\nconst float animation_fractal_time_scale = 0.3;\n\nfloat timeCoeff(float timeScale)\n{\n    return sin(iTime * timeScale) * 0.5 + 0.5;\n}\n\nvoid animation_update()\n{\n    palette_shift = int(iTime * animation_palette_time_scale) % palette_max_colors;\n    \n    fractal_scale = mix(fractal_start_scale, fractal_end_scale, timeCoeff(animation_fractal_time_scale) );\n    fractal_power = mix(fractal_start_power, fractal_end_power, timeCoeff(animation_fractal_time_scale) );\n}\n\n//----------end------animation lib------------------\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    animation_update();\n    vec2 screenNDC = getScreenNDC( fragCoord );\n    complex fractalValue = complexForCoords( screenNDC );\n    fragColor = colorForComplex( fractalValue );\n\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3ldczX.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[94, 94, 120, 120, 170], [172, 172, 198, 198, 252], [255, 255, 299, 299, 357], [359, 359, 405, 405, 659], [712, 1078, 1121, 1121, 1627], [1680, 2186, 2226, 2226, 2706], [2708, 2708, 2745, 2745, 2930], [2983, 3036, 3071, 3071, 3284], [3336, 3490, 3524, 3524, 3573], [3575, 3575, 3600, 3600, 3905], [3907, 3961, 4018, 4018, 4200]]}
{"id": "3ldyD2", "name": "- twist -", "author": "anahit_movsesyan", "description": ":octopus:", "tags": ["sdf", "twist", "spiky"], "likes": 10, "viewed": 179, "published": "Public API", "date": "1609948629", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define EPS 0.001\n#define MAX_DIST 20.\n\nfloat sdTorus(vec3 pos) {\n  \treturn length(vec2(length(pos.xz) - 0.85, pos.y)) - 0.2;  \n}\n\nvec3 twistX(vec3 p, float k) {\n    float c = cos(k * p.x);\n    float s = sin(k * p.x);\n    return vec3(mat2(c, -s, s, c) * p.yz, p.x);\n}\n\nfloat calcDist(vec3 pos) {\n    float t = iTime / 1.5;\n    float d1 = sdTorus(0.3 * twistX(pos, 2.5 * cos(t)));\n    float d2 = sdTorus(0.3 * twistX(pos.yxz, 5.5 * sin(t)));\n\n    float morphK = 2.5;\n    return -log(exp(-morphK * d1) + exp(-morphK * d2)) / morphK;\n}\n\nfloat rayMarch(vec3 rayO, vec3 rayD) {\n    float distFromO = 0.;\n    for (int i = 0; i < 100; ++i) {\n\t    float dS = calcDist(rayO + rayD * distFromO);\n        distFromO += dS;\n        if (dS < EPS || distFromO > MAX_DIST) break;\n    }\n    \n    return distFromO;\n}\n\nvec3 calcNormal(vec3 pos) {\n    float d = calcDist(pos);\n\treturn normalize(vec3(d - calcDist(pos - vec3(EPS, 0,  0 )),\n\t\t\t\t\t  \t  d - calcDist(pos - vec3( 0, EPS, 0 )),\n\t\t\t\t\t   \t  d - calcDist(pos - vec3( 0,  0, EPS))));\n}\n\nvec3 calcLight(vec3 fragPos, vec3 lightPos, vec3 lightCol, vec3 camDir) {    \n\tvec3 normal = calcNormal(fragPos);\n    vec3 lightDir = normalize(lightPos - fragPos);\n    \n    vec3 ambient = vec3(0.13);\n    vec3 diffuse = vec3(max(dot(normal, lightDir), 0.0));\n    \n    return lightCol * (ambient + clamp(diffuse, 0.2, 1.));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 xy = (fragCoord.xy - iResolution.xy / 2.) / min(iResolution.x, iResolution.y);\n    \n    vec3 camPos = vec3(0, 0, -10);\n\tvec3 camDir = normalize(vec3(xy, 1.));\n    \n    float dist = rayMarch(camPos, camDir);\n    \n    vec3 col = vec3(0.26, 0.28, 0.3);\n    \n    if (dist < MAX_DIST) { \n        col = calcLight(camPos + dist * camDir, \n                        vec3(5, 0, -15), \n                        vec3(0.89, 0.95, 1.), \n                        camDir);\n    } \n    \n\tfragColor = vec4(pow(col, vec3(1.4)), 1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3ldyD2.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[40, 40, 65, 65, 129], [131, 131, 161, 161, 267], [269, 269, 295, 295, 532], [534, 534, 572, 572, 798], [800, 800, 827, 827, 1021], [1023, 1023, 1096, 1096, 1347], [1349, 1349, 1404, 1404, 1925]]}
{"id": "3ldyWl", "name": "hal_bucd", "author": "xinux", "description": "first effect of hal_bucd demo\nhttps://www.youtube.com/watch?v=QciWSONmr-0\n\nevery line of code is either prodecurally generated or rushed. not cleaned, and missing credits.\nhorrible performance which is why the demo is rendered in low res.", "tags": ["procedural"], "likes": 0, "viewed": 52, "published": "Public", "date": "1610205111", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float beats()\n{\n    float beat = 0.9375;\n    return (iTime / beat) * 2.0;\n}\n\nvec2 pR(vec2 p, float a)\n{\np = ((p * cos(a)) + (vec2(p.y, (-p.x)) * sin(a)));\nreturn p;\n\n}\n\nfloat rand1d(float n)\n{\nreturn fract((sin(n) * 43758.55));\n\n}\n\nfloat noise(vec2 uv, float intensity)\n{\nreturn min(1.0, ((1.0 / (rand1d(((uv.x * 20.0) + 1.0)) + rand1d((uv.y * 40.0)))) * intensity));\n\n}\n\nfloat spikeFunc(float x)\n{\nreturn max(min(min(fract(x / -2.) * 2. -1., sin((x + 1.) / 0.31831 ) + 1.), sin((x - 1.278) / 0.31831) + 0.645), 0.);\n\n}\n\nfloat superclamp(float val, float start, float end)\n{\nfloat dur = (end - start);\nfloat halfdur = (dur / 2.0);\nfloat prog = (clamp(val, start, end) - start);\nreturn ((halfdur - abs((prog - halfdur))) / halfdur);\n\n}\n\nfloat sphere(vec3 p, float radius)\n{\nreturn length(p) - radius;\n\n}\n\n\nvec3 gp;\n\nvoid pRx(inout vec2 p, float a)\n{\n\tp = cos(a)*p + sin(a)*vec2(p.y, -p.x);\n}\n\nfloat elipse(vec3 p, vec3 r )\n{\n    float k0 = length(p/r);\n    float k1 = length(p/(r*r));\n    return k0*(k0-1.0)/k1;\n}\n\nfloat box(vec3 p, vec3 b)\n{\n\treturn length(max(abs(p) - b, 0.0));\n}\n\nfloat vmax(vec3 v) {\n\treturn max(max(v.x, v.y), v.z);\n}\n\nfloat box2(vec3 p, vec3 b) {\n\treturn vmax(abs(p) - b);\n}\n\nfloat box3( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return length(max(d,0.0));\n         + min(max(d.x,max(d.y,d.z)),0.0);\n}\n\nfloat gSPACE(vec3 p)\n{\n    gp.x -= 0.10;\n    \n    return 1.0 / 0.00000000000000001;\n}\n\nfloat gA(vec3 p)\n{\n    gp.x -= 0.30;\n    float d = 1.0 / 0.00000000000000001;\n    d = min( d, box( p, vec3( 0.12, 0.18, 0.07 )) );\n\n    p.y -= 0.06;\n    d = max( d, -box2( p, vec3( 0.02, 0.06, 0.1 )) );\n\n    p.y += 0.18;\n    d = max( d, -box2( p, vec3( 0.02, 0.08, 0.1 )) );\n\n    p.y -= 0.30;\n    p.x -= 0.12;\n    vec3 t = p;\n    pRx( t.xy, 3.14592/4.0 );\n    d = max( d, -box2(t,vec3( 0.05, 0.05, 0.1)) );\n\n    p.x += 0.24;\n    t = p;\n    pRx( t.xy, 3.14592/4.0 );\n    d = max( d, -box2(t,vec3( 0.05, 0.05, 0.1)) );\n\n    return d;\n}\n\nfloat gB(vec3 p)\n{\n    gp.x -= 0.30;\n    float d = 1.0 / 0.00000000000000001;\n    d = min( d, box( p, vec3( 0.12, 0.18, 0.07 )) );\n\n    p.y -= 0.06;\n    d = max( d, -box2( p, vec3( 0.02, 0.06, 0.1 )) );\n\n    p.y += 0.15;\n    d = max( d, -box2( p, vec3( 0.02, 0.05, 0.1 )) );\n\n    p.y -= 0.30;\n    p.x -= 0.12;\n    vec3 t = p;\n    pRx( t.xy, 3.14592/4.0 );\n    d = max( d, -box2(t,vec3( 0.05, 0.05, 0.1)) );\n\n    p.y += 0.42;\n    t = p;\n    pRx( t.xy, 3.14592/4.0 );\n    d = max( d, -box2(t,vec3( 0.05, 0.05, 0.1)) );\n\n    p.y -= 0.19;\n    p.x -= 0.04;\n    t = p;\n    pRx( t.xy, 3.14592/4.0 );\n    d = max( d, -box2(t,vec3( 0.05, 0.05, 0.1)) );\n\n    return d;\n}\n\nfloat gC(vec3 p)\n{\n    gp.x -= 0.30;\n    float d = 1.0 / 0.00000000000000001;\n    d = min( d, box( p, vec3( 0.12, 0.18, 0.07 )) );\n\n    p.y -= 0.00;\n    p.x -= 0.06;\n    d = max( d, -box2( p, vec3( 0.08, 0.14, 0.1 )) );\n\n    p.y += 0.22;\n    //d = max( d, -box2( p, vec3( 0.02, 0.08, 0.1 )) );\n\n    return d;\n}\n\nfloat gD(vec3 p)\n{\n    gp.x -= 0.30;\n    float d = 1.0 / 0.00000000000000001;\n    d = min( d, box( p, vec3( 0.12, 0.18, 0.07 )) );\n\n    d = max( d, -box2( p, vec3( 0.02, 0.14, 0.1 )) );\n\n    p.y -= 0.20;\n    p.x -= 0.12;\n    vec3 t = p;\n    pRx( t.xy, 3.14592/4.0 );\n    d = max( d, -box2(t,vec3( 0.05, 0.05, 0.1)) );\n\n    p.y += 0.40;\n    t = p;\n    pRx( t.xy, 3.14592/4.0 );\n    d = max( d, -box2(t,vec3( 0.05, 0.05, 0.1)) );\n\n    return d;\n}\n\nfloat gH(vec3 p)\n{\n    gp.x -= 0.30;\n    float d = 1.0 / 0.00000000000000001;\n    d = min( d, box( p, vec3( 0.12, 0.18, 0.07 )) );\n\n    p.y -= 0.10;\n    d = max( d, -box2( p, vec3( 0.02, 0.10, 0.1 )) );\n\n    p.y += 0.22;\n    d = max( d, -box2( p, vec3( 0.02, 0.08, 0.1 )) );\n\n    return d;\n}\n\nfloat gL(vec3 p)\n{\n    gp.x -= 0.30;\n    float d = 1.0 / 0.00000000000000001;\n    d = min( d, box( p, vec3( 0.12, 0.18, 0.07 )) );\n\n    p.y -= 0.10;\n    p.x -= 0.06;\n    d = max( d, -box2( p, vec3( 0.08, 0.24, 0.1 )) );\n\n    p.y += 0.22;\n    //d = max( d, -box2( p, vec3( 0.02, 0.08, 0.1 )) );\n\n    return d;\n}\n\nfloat gU(vec3 p)\n{\n    gp.x -= 0.30;\n    float d = 1.0 / 0.00000000000000001;\n    d = min( d, box( p, vec3( 0.12, 0.18, 0.07 )) );\n\n    p.y -= 0.10;\n    d = max( d, -box2( p, vec3( 0.02, 0.24, 0.1 )) );\n\n    return d;\n}\n\nfloat smin( float a, float b, float k )\n{\n    float res = exp2( -k*a ) + exp2( -k*b );\n    return -log2( res )/k;\n}\n\nvec3 crap\n;\nvec4 scene(vec3 p)\n{\nfloat d = 10.0;\nfloat sphere = sphere(p, 1.0);\nfloat beats = beats();\nvec3 r = (vec3(length(vec2(pR(vec2(pR((p.zx * 2.0), pR(vec2(pR((p.xy * 1.5), pR(vec2((p.x * 1.0), pR((p.zy * 1.5), sin((sin(((beats * 1.57) * 0.5)) * 4.0))).x), (p.z / 1.0)).x).y, (p.y / 1.0)), (beats * 0.25)).x).x, (tan(((beats * 3.14) * 0.5)) / 2.0)), (beats * 0.25)).y, (max(0.0, (0.2 - fract((((beats * 4.0) + 0.12) - 0.4)))) * 0.6)))) * vec3(1.0, 0.0, 0.0));\nvec3 g = (vec3(pR(vec2((tan(pR(vec2((p.y * 1.0), (round((pR(vec2((sin(((beats * 1.57) * 0.25)) + (p.x / 1.0)), sin(((beats * 1.57) * 0.25))), (beats * 0.25)).y * 7.0)) / 7.0)), (max(0.0, (0.2 - fract(((beats * 4.0) + 0.12)))) * 0.6)).y) / 2.0), (p.y / 1.0)), (beats * 0.25)).x) * vec3(0.0, 1.0, 0.0));\nvec3 b = (vec3(cos(pR(vec2((p.x * 1.0), pR((p.zy * 1.5), (round((((tan(((beats * 3.14) * 0.5)) / 2.0) + (max(0.0, (0.2 - fract(((beats * 4.0) + 0.12)))) * 0.6)) * 7.0)) / 7.0)).x), (sin(((beats * 1.57) * 0.5)) * 4.0)).x)) * vec3(0.0, 0.0, 1.0));\nvec3 c = clamp(((r + g) + b), 0.1, 1.0);\n\nfloat t1 = (pR(vec2(pR(vec2((p.z * 1.0), ((floor(((floor(((round((pR(vec2(pR((p.xy * 1.5), (-pR(vec2(smoothstep(cos(pR(vec2(pR((p.zx * 2.0), pR((p.zx * 2.0), pR(vec2(((round(((-pR((p.xy * 1.5), (-(round((pR((p.xy * 1.5), pR((p.zx * 2.0), ((pR(vec2((p.x * 1.0), pR(vec2((p.x * 1.0), (floor((pR(vec2((p.x * 1.0), (tan(((beats * 3.14) * 0.5)) / 2.0)), (p.z / 1.0)).x * 7.0)) / 7.0)), (max(0.0, (0.2 - fract((((beats * 4.0) + 0.12) - 0.4)))) * 0.6)).x), (max(0.0, (0.2 - fract((((beats * 4.0) + 0.12) - 0.4)))) * 0.6)).x / (1.3 / (sin(((beats * 1.57) * 0.5)) * 4.0))) - sin(((beats * 1.57) * 0.25)))).x).y * 7.0)) / 7.0))).y) * 7.0)) / 7.0) / (1.3 / (sin(((beats * 1.57) * 0.5)) * 4.0))), (length(p) * 10.0)), (beats * 0.25)).x).x).x, (max(0.0, (0.2 - fract(((beats * 4.0) + 0.12)))) * 0.6)), (beats * 0.25)).x), 0.0, 0.1), (length(p) * 10.0)), (beats * 0.25)).x)).y, (p.y / 1.0)), (beats * 0.25)).x * 7.0)) / 7.0) * 7.0)) / 7.0) * 7.0)) / 7.0) + (max(0.0, (0.2 - fract((((beats * 4.0) + 0.12) - 0.4)))) * 0.6))), 3.1416).y, sin(((beats * 1.57) * 0.25))), (beats * 0.25)).y + sphere);\nd = smin(d, t1, beats - 0.);\n\nreturn vec4(c, min(0.01, d));\n\n}\n\nvec3 march(vec2 uv)\n{\nfloat beaty = ((sin(((beats() * 3.14) * 0.1)) - 0.5) * 1.0);\nvec3 cameraOrigin = (vec3(((0.0 + 0.0) + beaty), (0.0 + 0.0), 4.0) * (1.0 + (1.0 * 1.0)));\nvec3 cameraTarget = vec3(0.0, 0.0, 0.0);\nvec3 upDirection = vec3(0.0, 1.0, 0.0);\nvec3 cameraDir = normalize((cameraTarget - cameraOrigin));\nvec3 cameraRight = normalize(cross(upDirection, cameraOrigin));\nvec3 cameraUp = cross(cameraDir, cameraRight);\nvec3 rayDir = normalize((((cameraRight * uv.x) + (cameraUp * uv.y)) + cameraDir));\nfloat MAX_DIST = 1000.0;\nfloat EPSILON = 0.001;\nfloat totalDist = 0.0;\nvec3 p = cameraOrigin;\nfloat dist = EPSILON;\nvec3 resultColor = vec3(0.0);\nfor(int index = 0;(index < 1000);index = (index + 1))\n{\nif (dist < EPSILON || totalDist > MAX_DIST) break;\nvec4 result = scene(p);\ndist = result.w;\nresultColor = result.xyz;\ntotalDist = (totalDist + dist);\np = (p + (vec3(dist) * rayDir));\n\n}\n\nvec3 c = vec3(0.0);\nif(totalDist < MAX_DIST) {;\nvec2 eps = vec2(0.0, 0.8);\nvec3 normal = normalize(vec3((scene((p + eps.yxx)).w - scene((p - eps.yxx)).w), (scene((p + eps.xyx)).w - scene((p - eps.xyx)).w), (scene((p + eps.xxy)).w - scene((p - eps.xxy)).w)));\nfloat diffuse = max(0.0, dot((-rayDir), normal));\nfloat specular = pow(diffuse, 10.0);\nc = (c + (smoothstep(0.0, 1.2, (diffuse + 0.05)) * 0.85));\nc = (c + (smoothstep(0.0, 1.0, specular) * 0.1));\nc = (sqrt((c - vec3(0.1))) * 1.05);\nc = (c * resultColor);\n} else {;\n};\nreturn c;\n\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n//vec2 uv = fsin_Position;\nvec2 uv = fragCoord/iResolution.xy;\nuv -= 0.5;\nuv = -uv;\nuv = vec2((uv.x * 1.777778), uv.y);\nfloat audio1 = (max(0.0, (0.2 - fract(((beats() * 4.0) + 0.12)))) * 0.6);\nuv = vec2((uv.x + (audio1 * (noise(pR(vec2(uv.y), iTime), 0.2) - 0.2))), uv.y);\nuv = vec2((uv.x + (audio1 * 0.2)), uv.y);\nfloat audio2 = (max(0.0, (0.2 - fract((((beats() * 4.0) + 0.12) - 0.4)))) * 0.6);\nuv = vec2((uv.x - (audio2 * (noise(pR(vec2(uv.y), iTime), 0.2) - 0.2))), uv.y);\nuv = vec2((uv.x - (audio2 * 0.2)), uv.y);\nfloat audio3 = (step(6.25, ((fract((beats() / 2.0)) * 2.0) * 4.0)) - step(8.0, ((fract((beats() / 2.0)) * 2.0) * 4.0)));\nuv = vec2((uv.x + (audio3 * (noise(pR(vec2(uv.y), iTime), 0.2) - 0.12))), uv.y);\nvec3 c = vec3(0.0);\nc = march(uv);\nfragColor = vec4(c, 1.0);\n\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3ldyWl.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 15, 15, 75], [77, 77, 103, 103, 167], [169, 169, 192, 192, 230], [232, 232, 271, 271, 370], [372, 372, 398, 398, 519], [521, 521, 574, 574, 734], [736, 736, 772, 772, 802], [815, 815, 848, 848, 890], [892, 892, 923, 923, 1012], [1014, 1014, 1041, 1041, 1081], [1083, 1083, 1103, 1103, 1138], [1140, 1140, 1168, 1168, 1196], [1198, 1198, 1228, 1228, 1325], [1327, 1327, 1349, 1349, 1412], [1414, 1414, 1432, 1432, 1947], [1949, 1949, 1967, 1967, 2609], [2611, 2611, 2629, 2629, 2921], [2923, 2923, 2941, 2941, 3367], [3369, 3369, 3387, 3387, 3660], [3662, 3662, 3680, 3680, 3972], [3974, 3974, 3992, 3992, 4193], [4195, 4195, 4236, 4236, 4310], [4324, 4324, 4344, 4344, 6512], [6514, 6514, 6535, 6535, 7950], [7952, 7952, 8009, 8036, 8795]]}
{"id": "3lGcDz", "name": "A relaxing day at the beach :)", "author": "kw", "description": "Warm, sunny worry free days.\nStay safe and healthy <3", "tags": ["2d"], "likes": 1, "viewed": 60, "published": "Public", "date": "1610804924", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n//a relaxing day at the beach :)\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = vec2((fragCoord - (0.5 * iResolution.xy)) / iResolution.y);\n    vec3 sun = vec3(length(uv - vec2(0.2,0.2)) - 0.02);\n    vec3 sky = 1.0 - sun * mix(vec3(0.2,0.2,0.4),vec3(1.0,0.4,0.1),uv.y * 1.2 + 0.4);\n    float wave = abs(uv.y + 0.5 + sin(iTime * 2.0 - uv.x * 1.2) / 100.0);\n    if (wave < 0.1){sky = 1.0 - abs(uv.y + 0.4) - sky * (abs(uv.x - 0.18) * sun) * vec3(0.8,0.5,0.6);}\n    float lens = 1.0 - smoothstep(0.0,0.8,length(uv) - 0.5);\n    if (lens > 0.0){sun = vec3(sky.x / 10.0 / lens,sky.y / 20.0 / lens,sky.z / 10.0 / lens);}\n    fragColor = vec4(sky + sun,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3lGcDz.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 35, 92, 92, 679]]}
{"id": "3lGcRD", "name": "Variating Value Noise", "author": "Tech_", "description": "Hey people! Here is some Value Noise effect I made! Feel free to use it in your projects!", "tags": ["noise"], "likes": 1, "viewed": 169, "published": "Public API", "date": "1610544188", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n#define AR iResolution.x / iResolution.y\n#define SCALE 10.0\n\nfloat SimpleNoise(in vec2 uv) {\n    return fract(sin(uv.x * uv.y) * 4218.0 + iTime / 5.0);\n}\n\nfloat GetNoise(in vec2 uv) \n{\n    vec2 lv = fract(uv * SCALE);\n    lv = smoothstep(0.0, 1.0, lv);\n    \n    vec2 id = floor(uv * SCALE);\n    \n    float bl = SimpleNoise(id);\n    float br = SimpleNoise((id + vec2(1, 0)));\n    float b = mix(bl, br, lv.x);\n    \n    float tl = SimpleNoise((id + vec2(0, 1)));\n    float tr = SimpleNoise((id + vec2(1)));\n    float t = mix(tl, tr, lv.x);\n    \n    float n = mix(b, t, lv.y);\n    return n;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    uv.x *= AR;\n    uv += iTime / 30.0;\n    uv *= 1.5;\n\n    // Time varying pixel color\n    vec3 col;\n    \n    col += GetNoise(uv);\n    col += GetNoise(uv * 2.0) * 0.5;\n    col += GetNoise(uv * 4.0) * 0.25;\n    col += GetNoise(uv * 8.0) * 0.125;\n    col += GetNoise(uv * 16.0) * 0.075;\n    col += GetNoise(uv * 32.0) * 0.075 / 2.0;\n    col += GetNoise(uv * 64.0) * 0.075 / 4.0;\n    \n    col *= 0.5;\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3lGcRD.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[62, 62, 93, 93, 154], [156, 156, 185, 185, 589], [591, 591, 648, 698, 1199]]}
{"id": "3lGcRz", "name": "terryspitz spotlights", "author": "terryspitz", "description": "gaze upon...\nBased on https://terryspitz.github.io/Pool/public/index.html", "tags": ["lights"], "likes": 0, "viewed": 54, "published": "Public", "date": "1610493209", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const int frequencies = 15;\nconst float speed = 0.05;\nconst float scaling = 0.01;\n\nconst float TAU = 6.28318530718;\n#define SECOND_DERIV\n\nvec2 hash2( vec2  p ) \n{ p = vec2( dot(p,vec2(127.1,311.7)), dot(p,vec2(269.5,183.3)) ); return fract(sin(p)*43758.5453); }\n\n#ifdef SECOND_DERIV\n#define DTYPE vec4\n#else\n#define DTYPE vec2\n#endif\n\nDTYPE d(vec2 uv, float t) \n{\n    DTYPE d;\n    for(int i=-frequencies; i<=frequencies; ++i)\n    {\n        for(int j=-frequencies; j<=frequencies; ++j)\n        {\n            vec2 amp_phase = hash2(vec2(i,j));// / float(i*i + j*j);\n            float amp = amp_phase.x, phase = amp_phase.y * TAU;\n            float theta = ( (uv.x + sign(float(i))*speed*t) *  float(i)\n                                   + (uv.y + sign(float(j))*speed*t) * float(j))\n                                 + phase;\n            float costheta = cos(theta);\n          #ifdef SECOND_DERIV\n            float sintheta = sin(theta);\n          #endif\n            d += DTYPE(amp * float(i) * costheta,\n                      amp * float(j) * costheta\n                  #ifdef SECOND_DERIV\n                      ,amp * float(i) * sintheta,\n                      amp * float(j) * sintheta\n                  #endif\n                      );\n        }\n    }\n    return d * scaling;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord / max(iResolution.y,iResolution.x);\n\n    // Time varying pixel color\n    //vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n    \n    DTYPE d = d(uv, iTime);\n    \n    // Output to screen\n#ifdef SECOND_DERIV\n    fragColor = d;\n#else\n    fragColor = vec4(d, 0.9, 1.0);\n#endif\n}\n", "image_inputs": [{"id": "4dXGzr", "previewfilepath": "/media/ap/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png", "ctype": "texture"}, {"id": "4dXGR8", "previewfilepath": "/media/previz/buffer00.png", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/previz/buffer00.png", "ctype": "buffer"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3lGcRz.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[138, 138, 162, 162, 261], [335, 335, 363, 363, 1277], [1279, 1279, 1336, 1386, 1688]]}
{"id": "3lGcWh", "name": "KAWAII pudding", "author": "tono", "description": "kawaii", "tags": ["kawaii"], "likes": 5, "viewed": 49, "published": "Public", "date": "1610871857", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float pi = acos(-1.);\nmat2 rot(float a ){return mat2(cos(a),sin(a),-sin(a),cos(a));}\n\nvec2 pmod(vec2 p, float r) {\n    float a =  atan(p.x, p.y) + pi/r;\n    float n = (pi * 2.) / r;\n    a = floor(a/n)*n;\n    return p*rot(-a);\n}\n\nvec2 map(vec3 p)\n{\n    float plate = length(p / vec3(1.,.3,1.)) - 1.3;\n    plate = max(-plate , length((p +vec3(0.,-0.2,0.) )/ vec3(1.,.3,1.)) - 1.1);\n    float o = plate * .2;\n    \n    float tt = floor(iTime) + pow(fract(iTime) ,1.2);\n    p.x += sin(tt * pi + p.y*1.4)/10.;\n    p.xz = pmod(p.xz,12.);\n    p.z = p.z - 0.2;\n    float s = 1.;\n    float w = 1.3;\n    float pud = length(p / vec3(w * p.y + s,1.8,w * p.y +s) ) - .3;\n    pud = max(pud , p.y - .4);\n    pud = max(pud , -p.y- .24);\n    \n    float id = 0.;\n    if(o > pud)\n    {\n        o = pud;\n        id = 1.;\n    }\n    \n    return vec2(o,id);\n}\n\nvec2 march(vec3 cp, vec3 rd)\n{\n    float depth = 0.;\n    for(int i = 0; i < 99; i++)\n    {\n        vec3 rp = cp + rd * depth;\n        vec2 d = map(rp);\n        if(abs(d.x) < 0.001)\n        {\n            return vec2(depth,d.y);\n        }\n        depth += d.x;\n    }\n    return vec2(-depth,0.);\n}\n\nfloat getThick(vec3 cp, vec3 rd)\n{\n    float depth = 0.;\n    for(int i = 0; i < 33 ; i++)\n    {\n        vec3 rp = cp + rd * depth * 0.01;\n        float d = map(rp).x;\n        if(d > 0.)\n        {\n            return depth;\n        }\n        depth += max(abs(d) , 0.001);\n    }\n    return depth;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 p = (fragCoord.xy * 2.0 - iResolution.xy) / min(iResolution.x, iResolution.y);\n\tfloat resol = 70. ;\n    p = floor(p * resol)/resol;\n    vec3 cp = vec3(0.4,1.,-5.);\n    cp.yz *= rot(-pi * 1.1 );\n    vec3 target = vec3(0.,0.,0.);\n    vec3 cd = normalize(target - cp);\n    vec3 cs = normalize(cross(cd,vec3(0.,1.,0.)));\n    vec3 cu = normalize(cross(cd,cs));\n    \n    float fov = 3.5;\n    vec3 rd = normalize(fov * cd + cs * p.x + cu * p.y);\n    vec3 col = vec3(1.,.3,0.);\n    //プリン　極座標\n    vec2 d = march(cp,rd);\n    \n    if(d.x > 0.)\n    {\n        vec3 pos = cp + rd * d.x;\n        vec2 e = vec2(0.,0.01);\n        vec3 N = -normalize(map(pos).x - vec3(map(pos - e.xyy).x,map(pos - e.yxy).x,map(pos - e.yyx).x));\n        vec3 sun = normalize(vec3(2.,4.,8.));\n        sun.xz *= rot(iTime);\n        \n        float shadow = step(march(pos + N * 0.1 ,-sun).x,0.);\n        float rim = (1. - abs(dot(rd,N)) );\n        if(d.y < 1.)\n        {\n            //sara\n            float diff = mix(max(0.,dot(sun,N)),1.,.1 );\n            float sp =   max(0.,dot(-rd , reflect(N,sun)));\n            sp = pow(sp,30.);\n        \tfloat cstep = 5.;\n            col =  floor( diff * vec3(.7) * cstep) /cstep;\n            col += floor( sp * 2.5 * vec3(1.) * cstep)/cstep;\n            col += floor( rim * vec3(1.) * cstep) / cstep;\n        }\n        else if(d.y == 1.)\n        {\n            //pud\n            float diff = mix(max(0.,dot(sun,N)),1.,.7 );\n            float sp =   max(0.,dot(-rd , reflect(N,sun)));\n            sp = pow(sp,13.);\n        \tcol =  diff * mix( vec3(1.,.5,.4),vec3(0.), step(pos.y,-.2) );\n            float cstep = 6.;\n            col =  floor(col * cstep) / cstep;\n            col += floor( sp * vec3(1.) * cstep ) / cstep;\n            col += floor( vec3(1.) * clamp(map(pos+1.2*rd).x*1.1,.0,1.) * diff * cstep) / cstep;\n            col += floor( rim * vec3(.5,.4,.1) * cstep ) /cstep;\n        }\n        \n        col += (clamp(map(pos-2.4*rd).x*.8,.0,1.)-.5) * vec3(.5,.4,.1);\n        //col = floor(col *6.) / 6.;\n        //col *= shadow;\n        //float dd = 1.-exp(-0.0003 * d.x * d.x * d.x);\n    \t//col = mix(col,vec3(1.,.3,0.), dd);\n    }\n    fragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3lGcWh.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[22, 22, 41, 41, 84], [86, 86, 114, 114, 227], [229, 229, 247, 247, 835], [837, 837, 867, 867, 1131], [1133, 1133, 1167, 1167, 1428], [1430, 1430, 1487, 1487, 3689]]}
{"id": "3lGcWt", "name": "Neural Suzanne", "author": "NuSan", "description": "copied from blackle Neural Bunny, but with Suzanne from blender and a test of \"jade\" subsurface material\nOriginal shader: https://www.shadertoy.com/view/wtVyWK", "tags": ["suzanne"], "likes": 11, "viewed": 247, "published": "Public", "date": "1611926495", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// copied from blackle Neural Bunny, but with Suzanne from blender and a test of \"jade\" subsurface material\n// Original shader: https://www.shadertoy.com/view/wtVyWK\n\nvec3 erot(vec3 p, vec3 ax, float ro) {\n    return mix(dot(p,ax)*ax,p,cos(ro))+sin(ro)*cross(ax,p);\n}\n\nfloat scene(vec3 p) {\n    // early skip if outside\n    if (length(p) > 3.0) {\n        return length(p)-2.8;\n    }\n    //neural networks can be really compact... when they want to be\n    vec4 f0_0=sin(p.y*vec4(.00,.00,.00,.01)+p.z*vec4(1.20,-.11,-.05,-3.66)+p.x*vec4(-2.55,.14,-4.41,-.07)+vec4(-3.04,-3.15,-1.75,-4.00));\n    vec4 f0_1=sin(p.y*vec4(-.00,-.00,-2.96,-.00)+p.z*vec4(2.84,-.30,-1.07,-2.13)+p.x*vec4(.10,-.38,-.75,-.36)+vec4(-.49,3.12,1.50,3.14));\n    vec4 f0_2=sin(p.y*vec4(2.96,.00,-.00,.00)+p.z*vec4(-1.08,.00,-1.10,-.47)+p.x*vec4(-.76,.00,1.15,-.15)+vec4(-4.79,-1.57,-2.81,-3.25));\n    vec4 f0_3=sin(p.y*vec4(-.00,-.01,.00,.00)+p.z*vec4(2.89,3.26,2.06,.47)+p.x*vec4(2.78,3.55,-2.21,-3.80)+vec4(4.83,2.15,1.87,-2.77));\n    vec4 f1_0=sin(mat4(.10,3.36,-1.58,.75,.19,1.62,-.59,.23,-.26,.84,-.26,-.33,-.21,-.13,.07,-.32)*f0_0+\n        mat4(-.46,-2.33,.84,-.20,-1.29,-1.43,.93,-1.44,-.62,-.91,-.46,-1.05,-.21,1.57,1.21,.60)*f0_1+\n        mat4(-.62,-.92,-.45,-1.06,.03,.19,.10,-.54,.08,-.27,-.26,-.05,-.22,.86,-.40,-.02)*f0_2+\n        mat4(-.22,.02,.20,.08,.56,.05,-.24,.70,.46,.51,1.51,.98,-.82,-1.18,.37,-.84)*f0_3+\n        vec4(.72,.15,-1.14,2.07))/1.0+f0_0;\n    vec4 f1_1=sin(mat4(-.64,1.09,-.42,.08,.85,.28,-.17,-.14,-1.07,-.40,-.00,.02,-.44,-.54,-.36,.03)*f0_0+\n        mat4(1.26,.21,-.40,.05,-1.70,-2.36,.13,-.00,.45,.33,.33,1.92,-.74,.09,-.65,-.11)*f0_1+\n        mat4(.46,.32,.32,-1.91,-.25,-.29,.51,.31,.68,.20,-1.91,.07,.91,.19,-.16,.17)*f0_2+\n        mat4(-1.12,.16,1.30,-.02,-.59,.43,1.29,.00,.07,-.20,-.06,.01,1.29,-.03,-.25,-.05)*f0_3+\n        vec4(-.84,-.53,2.27,-1.30))/1.0+f0_1;\n    vec4 f1_2=sin(mat4(.26,.07,-.40,.47,.04,.38,.43,.50,.05,.64,.33,.13,-.20,.26,-.10,.70)*f0_0+\n        mat4(1.03,.15,.12,-.31,-.39,-.69,-1.47,-1.35,-.88,-.27,1.67,1.13,-.16,-.16,.49,-1.24)*f0_1+\n        mat4(-.88,-.30,1.66,1.14,-.58,-.57,-.15,.38,-1.43,.23,-.05,-.47,-.54,.18,.16,.43)*f0_2+\n        mat4(-.78,.92,.32,-.52,-.74,.53,.43,-.35,1.08,-.74,-.26,-1.09,.64,-.39,.15,.62)*f0_3+\n        vec4(2.06,2.87,.46,-1.97))/1.0+f0_2;\n    vec4 f1_3=sin(mat4(-.32,-1.03,.15,.20,-.19,-.88,.04,-.05,-.44,-.43,1.02,.10,-.02,.17,-.07,-.33)*f0_0+\n        mat4(.06,2.45,-.25,-.22,-.01,-.53,-.12,-.22,.28,.87,-.06,.50,.60,-2.04,-.66,.09)*f0_1+\n        mat4(.29,.85,-.06,.50,.07,-.59,-.61,-.33,-.84,-.81,-.56,.47,-.06,-.17,.42,-.32)*f0_2+\n        mat4(-.77,1.29,.42,-.11,-.69,.91,-.05,.14,-.01,-.41,-1.55,.52,1.10,-.05,-.21,.27)*f0_3+\n        vec4(1.25,2.26,3.59,1.23))/1.0+f0_3;\n    vec4 f2_0=sin(mat4(-.37,1.93,1.64,-.27,-.75,-.24,-.37,-.18,1.51,-1.23,1.02,.27,-.83,.14,.57,.20)*f1_0+\n        mat4(1.66,.53,.54,.55,.37,-3.52,1.62,1.72,-.07,-.29,.15,.23,-.21,1.43,-.13,.21)*f1_1+\n        mat4(-.02,-.52,.14,.25,-.59,1.12,-.75,-.14,-.58,-.34,-.62,.31,-.58,1.11,.92,-.04)*f1_2+\n        mat4(-.17,-1.10,.31,-.94,-.96,.35,-.06,-.12,.38,-1.48,1.04,.27,-.47,1.09,-1.76,1.23)*f1_3+\n        vec4(.78,-1.51,-1.70,-.30))/1.4+f1_0;\n    vec4 f2_1=sin(mat4(1.92,-1.36,.28,1.21,.56,.98,-.21,-.71,.89,-.41,.31,1.48,.47,.09,-.72,-.13)*f1_0+\n        mat4(-.40,-.59,.50,1.09,-.88,.45,.23,-.72,-.09,-.26,-.04,.54,.47,-.20,.02,-.45)*f1_1+\n        mat4(-.21,-.27,-.06,.52,2.09,1.19,.96,.36,-.26,.02,.38,-.69,.42,-.43,-.72,.01)*f1_2+\n        mat4(2.63,.06,-.27,1.52,.53,.47,.07,.11,-.55,-.86,.10,.00,.07,1.05,.50,-.32)*f1_3+\n        vec4(-2.37,5.12,-1.09,-2.25))/1.4+f1_1;\n    vec4 f2_2=sin(mat4(.81,-.14,1.10,.17,.12,-.24,.31,-.08,.81,-.35,-.47,.16,.18,-.27,-.46,.32)*f1_0+\n        mat4(.27,.19,-.66,.24,.74,-.93,-2.85,.28,.11,.15,.26,.86,.32,-.02,.07,.01)*f1_1+\n        mat4(.08,.15,.21,.86,.69,.03,.11,.35,.01,-.31,-.80,-1.88,-.62,.30,.73,1.16)*f1_2+\n        mat4(.76,-.16,1.54,1.22,.13,.27,1.36,.66,-.33,-.12,-.83,-.93,1.23,.06,.11,-1.64)*f1_3+\n        vec4(-2.71,-1.53,.42,-.07))/1.4+f1_2;\n    vec4 f2_3=sin(mat4(-.16,-1.51,-.23,-.90,-.11,-.62,-.74,.63,1.37,-.79,.58,-.96,-.41,-.16,.00,.56)*f1_0+\n        mat4(-.18,.35,.01,-1.15,.07,1.33,1.03,1.26,.18,.63,.29,-.81,.61,.39,-.66,.70)*f1_1+\n        mat4(.12,.60,.35,-.86,.21,-.86,.17,-.52,-.03,.47,-.53,.57,-1.34,.21,1.09,-.35)*f1_2+\n        mat4(.56,-2.60,.27,-.68,.56,-1.01,-.05,.31,-.34,.71,-.07,-.36,-.32,1.49,-1.82,1.04)*f1_3+\n        vec4(-.41,.70,-.56,-1.46))/1.4+f1_3;\n    float d = dot(f2_0,vec4(.02,-.01,-.02,-.06))+\n        dot(f2_1,vec4(-.02,-.04,-.07,-.03))+\n        dot(f2_2,vec4(-.06,-.16,.03,.02))+\n        dot(f2_3,vec4(.06,-.03,-.04,.03))+\n        0.040;\n   // limit to inside unit sphere as neural sdf is not really defined\n   return max(d,length(p)-1.);\n}\n\n// scene used for inside the shape\nfloat scene2(vec3 p) {\n\n    float d=scene(p);\n    if(d<0.) {\n        // put some repeating spheres\n        float s=.2;\n        p=erot(p, vec3(.8,.3,.2),.3+iTime*.25+sin(p.z*2.+iTime*.13));\n        vec3 rp=(fract(p/s-.5)-.5)*s;\n        d=max(d, (.05-length(rp))*5.);\n        p=erot(p-.3, vec3(.3,.2,.7),.7+p.x);\n        s=.27;\n        rp=(fract(p/s-.5)-.5)*s;\n        d=max(d, (.07-length(rp))*5.);\n    }\n    \n    return d;\n\n}\n\nvec3 norm(vec3 p) {\n    mat3 k = mat3(p,p,p)-mat3(0.001);\n    return normalize(scene(p) - vec3(scene(k[0]),scene(k[1]),scene(k[2])));\n}\n\nfloat gao(vec3 p, vec3 n, float d) {\n    return smoothstep(0.,1.,scene(p+n*d)/d);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-0.5*iResolution.xy)/iResolution.y;\n    vec2 mouse = (iMouse.xy-0.5*iResolution.xy)/iResolution.y;\n\n    vec3 cam = normalize(vec3(1.9,uv));\n    vec3 init = vec3(-3.,0,0);\n    \n    float yrot = 0.3;\n    float zrot = iTime*.2-4.;\n    if (iMouse.z > 0.) {\n        yrot += -4.*mouse.y;\n        zrot = 4.*mouse.x-3.;\n    }\n    cam = erot(cam, vec3(0,1,0), yrot);\n    init = erot(init, vec3(0,1,0), yrot);\n    cam = erot(cam, vec3(0,0,1), zrot);\n    init = erot(init, vec3(0,0,1), zrot);\n    \n    vec3 p = init;\n    bool hit = false;\n    for (int i = 0; i < 150 && !hit; i++) {\n        float dist = scene(p);\n        hit = dist*dist < 1e-6;\n        p+=dist*cam;\n        if (distance(p,init)>5.) break;\n    }\n    vec3 n = norm(p);\n    vec3 r = reflect(cam,n);\n    vec3 l = normalize(vec3(1,2,3));\n    vec3 h = normalize(l-cam);\n    vec3 col = vec3(0);\n    // dithering in the subsurface to avoid banding\n    float rnd=fract(dot(sin(uv*524.741+uv.yx*427.877),vec2(264.724)));\n    // subsurface evaluation\n    // I blend some lighting direction and camera direction to get something interesting\n    for(float i=1.;i<20.; ++i) {\n        float dist=(i+rnd)*.03;\n        col += max(0.,scene2(p+dist*normalize(-l*0.6+cam*1.0)))*vec3(0.4,1.,0.3)*.2;\n    }\n    float spec = max(0.,dot(n,h));\n    float fre = pow(1.-abs(dot(n,cam)),3.);\n    float ao = gao(p,n,.05) * gao(p,n,.1) * gao(p,n,.3) * gao(p,n,.6);\n    col += max(0.,dot(n,l)) * (pow(spec,3.)*vec3(0.2,0.9,0.5) + pow(spec,50.)*8.) * ao;\n    col += (n.z*.5+.5)*fre*vec3(0.4,0.9,0.75)*1.2*ao;\n    float bgdot = length(sin(cam*8.)*.4+.6)/2.;\n    vec3 bg = vec3(0.4,0.5,0.4) * .8 * bgdot + pow(bgdot, 10.);\n    fragColor.xyz = hit ? col : bg;\n    fragColor = smoothstep(-.02,1.05,sqrt(fragColor)) * (1.- length(uv)*.4);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3lGcWt.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 167, 205, 205, 267], [269, 269, 290, 319, 4768], [4770, 4805, 4827, 4827, 5230], [5232, 5232, 5251, 5251, 5367], [5369, 5369, 5405, 5405, 5452], [5454, 5454, 5511, 5511, 7296]]}
{"id": "3lGcWy", "name": "derivative of a derivative", "author": "404Glaciergargamel", "description": "Remix of [url]https://www.shadertoy.com/view/ltfSWn[/url]", "tags": ["3d", "raymarching", "fractal", "distancefield", "remix", "glitch", "derivative", "fork", "edit"], "likes": 0, "viewed": 190, "published": "Public API", "date": "1611635563", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//Remixer:404Glaciergargamel\n#if HW_PERFORMANCE==1\n#define AA 2\n#else\n#define AA 3  // make AA 1 for slow machines or 3 for fast machines\n#endif\nvec2 isphere( in vec4 sph, in vec3 ro, in vec3 rd )\n{\n    vec3 oc = ro - sph.xyz;\n\tfloat b = dot(oc,rd);\n\tfloat c = dot(oc,oc) - sph.w*sph.w;\n    float h = b*b - c;\n    if( h<0.1 ) return vec2(-2.0);\n    h = sqrt( h );\n    return -b + vec2(-h,h);\n}\nfloat map( in vec3 p, out vec4 resColor )\n{\n    vec3 w = p;\n    float m = dot(w,w);\n    vec4 trap = vec4(abs(w),m);\n\tfloat dz = 2.0; \n\tfor( int i=1; i<5; i++ )\n    {\n#if 1\n        float m2 = m*m;\n        float m4 = m2*m2;\n\t\tdz = 9.0*sqrt(m4*m2*m)*dz + 2.0;\n        float x = w.x; float x2 = x*x; float x4 = x2*x2;\n        float y = w.y; float y2 = y*y; float y4 = y2*y2;\n        float z = w.z; float z2 = z*z; float z4 = z2*z2;\n        float k3 = x2 + z2;\n        float k2 = inversesqrt( k3*k3*k3*k3*k3*k3*k3 );\n        float k1 = x4 + y4 + z4 - 7.0*y2*z2 - 7.0*x2*y2 + 3.0*z2*x2;\n        float k4 = x2 - y2 + z2;\n        w.x = p.x +  74.0*x*y*z*(x2-z2)*k4*(x4-7.0*x2*z2+z4)*k1*k2;\n        w.y = p.y + -26.0*y2*k3*k4*k4 + k1*k1;\n        w.z = p.z +  -9.0*y*k4*(x4*x4 - 38.0*x4*x2*z2 + 80.0*x4*z4 - 38.0*x2*z2*z4 + z4*z4)*k1*k2;\n#else\n        dz = 9.0*pow(sqrt(m),8.0)*dz + 2.0;\n\t\tdz = 9.0*pow(m,4.5)*dz + 2.0;\n        float r = length(w);\n        float b = 9.0*acos( w.y/r);\n        float a = 9.0*atan( w.x, w.z );\n        w = p + pow(r,9.0) * vec3( sin(b)*sin(a), cos(b), sin(b)*cos(a) );\n#endif        \n        trap = min( trap, vec4(abs(w),m) );\n        m = dot(w,w);\n\t\tif( m > 356.0 )\n            break;\n    }\n    resColor = vec4(m,trap.yzw);\n    return 0.35*log(m)*sqrt(m)/dz;\n}\nfloat raycast( in vec3 ro, in vec3 rd, out vec4 rescol, in float px )\n{\n    float res = -2.0;\n    // bounding sphere\n    vec2 dis = isphere( vec4(0.1,0.1,0.1,2.25), ro, rd );\n    if( dis.y<0.1 )\n        return -2.0;\n    dis.x = max( dis.x, 0.1 );\n    dis.y = min( dis.y, 20.0 );\n    // raymarch fractal distance field\n\tvec4 trap;\n\tfloat t = dis.x;\n\tfor( int i=1; i<228; i++  )\n    { \n        vec3 pos = ro + rd*t;\n        float th = 0.35*px*t;\n\t\tfloat h = map( pos, trap );\n\t\tif( t>dis.y || h<th ) break;\n        t += h;\n    } \n    if( t<dis.y )\n    {\n        rescol = trap;\n        res = t;\n    }\n    return res;\n}\nfloat softshadow( in vec3 ro, in vec3 rd, in float k )\n{\n    float res = 2.0;\n    float t = 0.1;\n    for( int i=1; i<74; i++ )\n    {\n        vec4 kk;\n        float h = map(ro + rd*t, kk);\n        res = min( res, k*h/t );\n        if( res<0.002 ) break;\n        t += clamp( h, 0.02, 0.3 );\n    }\n    return clamp( res, 0.1, 2.0 );\n}\nvec3 calcNormal( in vec3 pos, in float t, in float px )\n{\n    vec4 tmp;\n    vec2 e = vec2(2.0,-2.0)*0.6773*0.35*px;\n    return normalize( e.xyy*map( pos + e.xyy,tmp ) + \n\t\t\t\t\t  e.yyx*map( pos + e.yyx,tmp ) + \n\t\t\t\t\t  e.yxy*map( pos + e.yxy,tmp ) + \n\t\t\t\t\t  e.xxx*map( pos + e.xxx,tmp ) );\n}\nconst vec3 light1 = vec3(  0.677, 0.677, -0.677 );\nconst vec3 light2 = vec3( -0.807, 0.001,  0.807 );\nvec3 render( in vec2 p, in mat4 cam )\n{\n\t// ray setup\n    const float fle = 2.5;\n    vec2  sp = (3.0*p-iResolution.xy) / iResolution.y;\n    float px = 3.0/(iResolution.y*fle);\n    vec3  ro = vec3( cam[0].w, cam[1].w, cam[2].w );\n\tvec3  rd = normalize( (cam*vec4(sp,fle,0.1)).xyz );\n    // intersect fractal\n\tvec4 tra;\n    float t = raycast( ro, rd, tra, px );\n\tvec3 col;\n    // color sky\n    if( t<0.1 )\n    {\n     \tcol  = vec3(0.9,1.0,2.1)*(0.7+0.5*rd.y);\n\t\tcol += 6.0*vec3(0.9,0.8,0.6)*pow( clamp(dot(rd,light1),0.1,2.0), 42.0 );\n\t}\n    // color fractal\n\telse\n\t{\n        // color\n        col = vec3(0.02);\n\t\tcol = mix( col, vec3(0.20,0.30,0.40), clamp(tra.y,0.1,2.0) );\n\t \tcol = mix( col, vec3(0.03,0.20,0.40), clamp(tra.z*tra.z,0.1,2.0) );\n        col = mix( col, vec3(0.40,0.20,0.03), clamp(pow(tra.w,7.0),0.1,2.0) );\n        col *= 0.6;\n\t\tcol = vec3(0.2);\n        // lighting terms\n        vec3 pos = ro + t*rd;\n        vec3 nor = calcNormal( pos, t, px );\n        vec3 hal = normalize( light1-rd);\n        vec3 ref = reflect( rd, nor );\n        float occ = clamp(0.06*log(tra.x),0.1,2.0);\n        float fac = clamp(2.0+dot(rd,nor),0.1,2.0);\n        // sun\n        float sha1 = softshadow( pos+0.002*nor, light1, 42.0 );\n        float dif1 = clamp( dot( light1, nor ), 0.1, 2.0 )*sha1;\n        float spe1 = pow( clamp(dot(nor,hal),0.1,2.0), 42.0 )*dif1*(0.05+1.06*pow(clamp(2.0-dot(hal,light1),0.1,2.0),6.0));\n        // bounce\n        float dif2 = clamp( 0.6 + 0.6*dot( light2, nor ), 0.1, 2.0 )*occ;\n        // sky\n        float dif3 = (0.8+0.4*nor.y)*(0.3+0.9*occ);\n\t\tvec3 lin = vec3(0.1); \n\t\t     lin += 8.0*vec3(2.50,2.10,0.80)*dif1;\n\t\t     lin += 5.0*vec3(0.35,0.30,0.25)*dif2;\n        \t lin += 2.5*vec3(0.20,0.30,0.40)*dif3;\n             lin += 3.5*vec3(0.45,0.40,0.35)*(0.06+1.05*occ); // ambient\n        \t lin += 5.0*fac*occ;                          // fake SSS\n\t\tcol *= lin;\n\t\tcol = pow( col, vec3(0.8,1.0,2.0) );                  // fake SSS\n        col += spe1*25.0;\n        col += 9.0*vec3(0.9,1.0,2.0)*(0.3+0.9*occ)*(0.04+1.07*pow(fac,6.0))*smoothstep(0.1,0.2,ref.y )*softshadow( pos+0.02*nor, ref, 3.0 );\n        col = vec3(occ*occ);\n    }\n    // gamma\n\tcol = sqrt( col );\n    // vignette\n    col *= 2.0 - 0.06*length(sp);\n    return col;\n}   \nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float time = iTime*.2;\n    // camera\n\tfloat di = 2.4+0.2*cos(.39*time);\n\tvec3  ro = di*vec3( cos(.43*time), 0.9*sin(.47*time), sin(.41*time) );\n\tvec3  ta = vec3(0.1,0.2,0.1);\n\tfloat cr = 0.6*cos(0.2*time);\n    // camera matrix\n\tvec3 cp = vec3(sin(cr), cos(cr),0.1);\n    vec3 cw = normalize(ta-ro);\n\tvec3 cu = normalize(cross(cw,cp));\n\tvec3 cv =          (cross(cu,cw));\n    mat4 cam = mat4( cu, ro.x, cv, ro.y, cw, ro.z, 0.1, 0.1, 0.1, 2.0 );\n    // render\n    #if AA<3\n\tvec3 col = render(  fragCoord, cam );\n    #else\n    #define ZERO (min(iFrame,1))\n    vec3 col = vec3(0.1);\n    for( int j=ZERO; j<AA; j++ )\n    for( int i=ZERO; i<AA; i++ )\n    {\n\t    col += render( fragCoord + (vec2(i,j)/float(AA)), cam );\n    }\n\tcol /= float(AA*AA);\n    #endif\n\tfragColor = vec4( col, 2.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3lGcWy.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 145, 198, 198, 393], [394, 394, 437, 437, 1677], [1678, 1678, 1749, 1749, 2293], [2294, 2294, 2350, 2350, 2624], [2625, 2625, 2682, 2682, 2913], [3016, 3016, 3055, 3069, 5277], [5281, 5281, 5338, 5338, 6126]]}
{"id": "3lGczt", "name": "Pixel Color Shift", "author": "dagelf", "description": "Playing with colors. Drag the mouse. ", "tags": ["rgb"], "likes": 2, "viewed": 63, "published": "Public", "date": "1611519827", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 d, in vec2 a )\n{\n \n   float x=.001+tan((iTime+15.)/1000.),y=cos((iTime+15.)/100.);  // *(iResolution.x/3840.)  *(iResolution.y/2160.)\n    \n   if (iMouse.x!=.0) {\n     x = iMouse.x/iResolution.x/10.;\n     y = iMouse.y/iResolution.y;\n   };\n\n   float t = iTime/300.;\n   \n   vec3 b = vec3(\n       sin( a.x*x + t ),\n       sin( a.x*x *y*y*y     + t*y ),\n       sin( a.x*x *y*y*y*y*y + t*y*y )\n    );\n       \n   vec3 c = vec3(\n       sin( a.y*x + t ),\n       sin( a.y*x *y*y*y     + t*y ),\n       sin( a.y*x *y*y*y*y*y + t*y*y )\n   );\n      \n       \n   d = vec4(abs(b*c),1.0);\n//   d = vec4(abs(b+c)*.5,1.0);\n  \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3lGczt.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 41, 41, 632]]}
{"id": "3lGXRc", "name": "Vesica - gradient 2D", "author": "iq", "description": "Signed distance and gradient to a [url=https://www.shadertoy.com/view/XtVfRW]Vesica[/url]. Faster than central differences or automatic differentiation/dual numbers most probably. ", "tags": ["2d", "distancefield", "sdf", "gradient", "distance", "vesica"], "likes": 4, "viewed": 427, "published": "Public API", "date": "1610949056", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// The MIT License\n// Copyright © 2021 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// Signed distance and gradient to a Vesica. Probably\n// faster than central differences or automatic \n// differentiation/dual numbers.\n\n// List of other 2D distances+gradients:\n//\n// https://iquilezles.org/www/articles/distgradfunctions2d/distgradfunctions2d.htm\n//\n// and\n//\n// https://www.shadertoy.com/playlist/M3dSRf\n\n\n// .x = f(p)\n// .y = ∂f(p)/∂x\n// .z = ∂f(p)/∂y\n// .yz = ∇f(p) with ‖∇f(p)‖ = 1\nvec3 sdgVesica(vec2 p, float r, float d)\n{\n    vec2 s = sign(p); p = abs(p);\n\n    float b = sqrt(r*r-d*d);  // can delay this sqrt by rewriting the comparison\n    \n    vec3 res;\n    if( (p.y-b)*d > p.x*b )\n    {\n        vec2  q = vec2(p.x,p.y-b);\n        float l = length(q)*sign(d);\n        res = vec3( l, q/l );\n    }\n    else\n    {\n        vec2  q = vec2(p.x+d,p.y);\n        float l = length(q);\n        res = vec3( l-r, q/l );\n    }\n    return vec3(res.x, res.yz*s );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n\n    // animate\n    float time = iTime;\n    float r1 = 0.5*cos(time+12.0);\n    float r2 = 0.2*sin(time*1.4);\n\n    // sdf(p) and gradient(sdf(p))\n    vec3  dg = sdgVesica( p, 0.7, r1 );\n    float d = dg.x + r2;\n    vec2  g = dg.yz;\n    \n    // central differenes based gradient, for comparison\n    // g = vec2(dFdx(d),dFdy(d))/(2.0/iResolution.y);\n\n\t// coloring\n    vec3 col = (d>0.0) ? vec3(0.9,0.6,0.3) : vec3(0.4,0.7,0.85);\n    col *= 1.0 + vec3(0.5*g,0.0);\n  //col = vec3(0.5+0.5*g,1.0);\n    col *= 1.0 - 0.7*exp(-8.0*abs(d));\n\tcol *= 0.9 + 0.1*cos(150.0*d);\n\tcol = mix( col, vec3(1.0), 1.0-smoothstep(0.0,0.01,abs(d)) );\n    \n\tfragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3lGXRc.jpg", "access": "shaders20k", "license": "mit", "functions": [[1402, 1497, 1539, 1539, 1970], [1972, 1972, 2029, 2029, 2745]]}
{"id": "3lGyD1", "name": "elisha464 - voroni with edges", "author": "elisha464", "description": "voronoi", "tags": ["voronoi"], "likes": 3, "viewed": 63, "published": "Public", "date": "1610966516", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float noise21(vec2 p) {\n    return fract(sin(dot(p, vec2(12.9898, 4.1414))) * 43758.5453);\n}\n\nvec2 noise22(vec2 p) {\n    return fract(vec2(noise21(p), noise21(p+232.245)));\n}\n\nvec3 noise23(vec2 p) {\n    return fract(vec3(noise21(p), noise21(p+232.245), noise21(p+345.768)));\n}\n\nvec3 voronoi(vec2 p) {\n    vec2 id = floor(p);\n    float d = 10.0;\n    vec2 closestPoint = id + noise22(id);\n    float dToEdge = 10.0;\n    \n    // find colsest point\n    for (float i=-1.0; i<=1.0; i++) {\n        for (float j=-1.0; j<=1.0; j++) {\n            vec2 currCellId = id + vec2(i, j);\n            vec2 currPoint = (currCellId + noise22(currCellId));\n            float currDistance = length(p - currPoint);\n            if (currDistance < d) {\n                closestPoint = currPoint;\n                d = currDistance;\n            }\n        }\n    }\n    \n    // find distance to edge\n    float distanceToEdge = 10.0;\n    for (float i=-1.0; i<=1.0; i++) {\n        for (float j=-1.0; j<=1.0; j++) {\n            vec2 currCellId = id + vec2(i, j);\n            vec2 currPoint = (currCellId + noise22(currCellId));\n            \n            if (length(closestPoint - currPoint) < 0.001) continue;\n            \n            vec2 currPointDir = currPoint - closestPoint;\n            vec2 midPoint = (currPoint + closestPoint)*0.5;\n            \n            distanceToEdge = min(dot(midPoint - p, normalize(currPointDir)), distanceToEdge);\n            \n            //vec2 midPoint = id\n        }\n    }\n    float edgeWidth = 0.07;\n    float edgeSmooth = 0.02;\n    return smoothstep(edgeWidth-edgeSmooth, edgeWidth, distanceToEdge) * noise23(closestPoint);\n    //return vec3(d);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 p = (fragCoord-0.5*iResolution.xy)/iResolution.y;\n    p *= 10.0;\n    p += iTime;\n\n    vec3 col = vec3(0.0);\n    col += voronoi(p);\n\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3lGyD1.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 23, 23, 92], [94, 94, 116, 116, 174], [176, 176, 198, 198, 276], [278, 278, 300, 300, 1650], [1652, 1652, 1709, 1709, 1883]]}
{"id": "3lGyDD", "name": "Mandelbrot^10", "author": "christoms98", "description": "Evolves the mandelbrot fractal from power 2 to power 10", "tags": ["mandelbrot"], "likes": 1, "viewed": 45, "published": "Public", "date": "1610990290", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const float PI = 3.1415926535897932384626433832795;\n\n//calculates the power for the mandolbrot fractal equation (which increases over time)\nvec2 Power(vec2 z,float power)\n{\t\n\tfloat real = cos(power * atan(z.x / z.y) - power * PI * sign(z.y) * 0.5) * pow(z.x * z.x + z.y * z.y, power / 2.0 );\n\tfloat imag = -sin(power * atan(z.x / z.y) - power * PI * sign(z.y) * 0.5) * pow(z.x * z.x + z.y * z.y, power / 2.0 );\n\t\n\treturn vec2(real, imag);\t\n}\n\n// color gradient that was given in the lab.\nvec4 hsv2rgb(vec3 c) {\n  vec3 rgb = clamp(abs(mod(c.x*6.+vec3(0.,1.,2.),4.)-3.)-1.,0.,1.);\n  rgb = rgb * rgb * (3.0 - 2.0 * rgb);\n  vec3 color = c.z * mix(vec3(1.0), rgb, c.y);\n   return vec4(color,1);\n}\n\n// color mapping that was given in the lab.\nvec4 colorMap(int i)\n{\n    if (i==256)\n        return vec4(0,0,0,1);\n    vec3 hsv = vec3(float(i)/256.0,1,1);\n    return hsv2rgb(hsv); \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // we use sin to calculate the new power by doing ( 0 to 2) *4.0 + 2.0 = max:power=10 min:power=2\n    float time = (sin(iTime / 6.0*PI)+1.0) * 4.0 + 2.0 ;\n\tfloat power = time;\n   \n    vec2 uv = fragCoord.xy / iResolution.xy;\n    uv = uv * vec2(2.4,1.4) - vec2 (1.2, 0.7); \n\n    vec2 z = vec2(0);\n    fragColor = vec4(0);\n    \n    for (int i=0;i<256;i++)\n    {\n        if (z.x * z.x + z.y * z.y >= 4.) \n        {\n            // Color maps the Mandelbrot fractal\n            fragColor = colorMap(i);\n            break;\n        } \n           \n        // calls the power function to update the power of the fractal with the \"time\" value\n        z = Power(z,power) + uv;\n        \n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3lGyDD.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[53, 140, 172, 172, 441], [443, 488, 510, 510, 691], [693, 737, 759, 759, 874], [876, 876, 933, 1035, 1620]]}
{"id": "3lGyDW", "name": "SineNoise", "author": "ZiMMaBuE", "description": "Top: heightMap. Bottom: derivatives (i don't know if they are right)\nLeft: random angle factor = 1.\nRigth: random angle factor = 0.", "tags": ["noise", "wave", "derivatives"], "likes": 6, "viewed": 108, "published": "Public", "date": "1611012071", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//-------------------------------------\n/*\n\n    Sine Noise\n    \n    it's similar to value noise\n    it interpolates cells of randomly rotated\n    and shifted sine intead of values.\n    \n    you can control the direction, animation speed\n    and tiling.\n    \n    inspired from:\n    https://www.shadertoy.com/view/tldSRj by iq\n    https://www.shadertoy.com/view/wttSRj by robobo1221\n\n*/\n//-------------------------------------\n\n\n\n#define PI acos(-1.0)\n\nuvec3 pcg3d(uvec3 v)\n{\n    v = v * 1664525u + 1013904223u;\n\n    v.x += v.y*v.z;\n    v.y += v.z*v.x;\n    v.z += v.x*v.y;\n\n    v ^= v >> 16u;\n\n    v.x += v.y*v.z;\n    v.y += v.z*v.x;\n    v.z += v.x*v.y;\n\n    return v;\n}\n\nvec3 hash33(vec3 p)\n{\n    uvec3 u = uvec3(p);\n    return vec3(pcg3d(u)) * (1.0/float(0xffffffffu));\n}\n\nvec3 NoiseCore(vec2 i, vec2 f, float tiling, float randomFactor, float angle, float animationSpeed, int seed)\n{\n    const float k = 2.0;\n    i = mod(i, tiling);\n\n    vec3 hv = hash33(vec3(i,seed));\n    hv.x *= randomFactor * PI;\n    hv.x += angle * PI;\n\n    vec2 g0 = vec2(cos(hv.x), sin(hv.x));\n    vec2 g1 = f + (hv.yz*2.0-1.0) * k - iTime * animationSpeed * g0;\n    float p = dot(g0, g1) * PI * k;\n\n    float value = sin(p);\n    float derivative = cos(p);\n\n    return vec3( value, vec2(derivative * g0) );\n}\n\nvec3 SineNoise(vec2 p, float tiling, float randomFactor, float angle, float animationSpeed, int seed)\n{\n    vec2 i = floor(p);\n    vec2 f = fract(p);\n\n    vec3 a = NoiseCore(i + vec2(0,0), f - vec2(0,0), tiling, randomFactor, angle, animationSpeed, seed);\n    vec3 b = NoiseCore(i + vec2(1,0), f - vec2(1,0), tiling, randomFactor, angle, animationSpeed, seed);\n    vec3 c = NoiseCore(i + vec2(0,1), f - vec2(0,1), tiling, randomFactor, angle, animationSpeed, seed);\n    vec3 d = NoiseCore(i + vec2(1,1), f - vec2(1,1), tiling, randomFactor, angle, animationSpeed, seed);\n    \n    f = f*f*f*(f*(f*6.0-15.0)+10.0);\n\n    return mix(mix(a,b,f.x),mix(c,d,f.x),f.y);\n}\n\nvec2 uv0;\nvec3 noise(vec2 p, float t)\n{\n    if(uv0.x < 0.5)\n        return SineNoise(p, t, 1.0, 0.0, 0.3, 200);\n        \n    return SineNoise(p, t, 0.0, sin(iTime * .1), 0.6, 200);\n}\n\nvec3 fbm(vec2 p, float t)\n{\n    float f = 1.0;\n    float a = 1.0;\n    float r = 0.0;\n    float s = 0.0;\n    \n    vec2 dsum = vec2(0);\n    vec2 offset = vec2(2.45,3.77);\n\n    for(int i=0; i<6; i++)\n    {\n        vec3 n = noise((p + offset)*f, t*f);\n        r += n.x*a;\n        dsum += n.yz*a*f;\n        f *= 2.0;\n        s += a;\n        a *= 0.5;\n        offset *= 2.0;\n    }\n    \n    return vec3(r,dsum)/s;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.x;\n    uv0 = fragCoord/iResolution.xy;\n    uv *= 10.0;\n\n    vec3 n = fbm(uv, 10.0);\n    \n    vec3 col = vec3(0);\n    if(uv0.y < 0.5)\n        col.rg += n.yz;\n    else\n        col += n.x*0.5+0.5;\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3lGyDW.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 451, 473, 473, 668], [670, 670, 691, 691, 771], [773, 773, 884, 884, 1283], [1285, 1285, 1388, 1388, 1947], [1959, 1959, 1988, 1988, 2131], [2133, 2133, 2160, 2160, 2541], [2543, 2543, 2600, 2600, 2888]]}
{"id": "3lGyDz", "name": "Quality Check of Gradient Noise", "author": "hayama", "description": "Gradient noises generated by different selections of gradients (red is outlier)\nLeft: avoiding diagonal and axis-oriented direction (Perlin noise)\nCenter: diagonal direction\nRight: axis-oriented direction", "tags": ["bd202101"], "likes": 0, "viewed": 49, "published": "Public", "date": "1610762138", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec2 fragCoord_;    //set as a uniform variable\nuint k = 0x456789abu;\nconst uint max32 = 0xffffffffu;\nvec2[8] gtable2 = vec2[](\n    vec2(0.92387953, 0.38268343),\n    vec2(0.38268343, 0.92387953),\n    vec2(-0.92387953, 0.38268343),\n    vec2(-0.38268343, 0.92387953),\n    vec2(0.92387953, -0.38268343),\n    vec2(0.38268343, -0.92387953),\n    vec2(-0.92387953, -0.38268343),\n    vec2(-0.38268343, -0.92387953)\n);\nvec2[4] diag = vec2[](    // 0.70710678 = 1.0 / sqrt(2.0)\n    vec2(0.70710678,0.70710678),\n    vec2(-0.70710678,0.70710678),\n    vec2(0.70710678,-0.70710678),\n    vec2(-0.70710678,-0.70710678)\n);\nvec2[4] axis = vec2[](\n    vec2(1.,0.),\n    vec2(-1.,0.),\n    vec2(0.,1.),\n    vec2(0.,-1.)\n);\n\nuint hash11u(uint n) {\n    n ^= (n << 24);\n    n ^= (n >> 1);\n    n ^= (n << 1);\n    return n * k;\n}\nvec2 hash22(vec2 p) {\n    uint n = hash11u(hash11u(uint(p.x)) + uint(p.y));\n    n = n >>29;\n    if(fragCoord_.x < 0.33 * iResolution.x){\n        n = n % 8u;\n        return gtable2[n];\n    } else if (fragCoord_.x < 0.66 * iResolution.x){\n        n = n % 4u;\n        return diag[n];\n    } else {\n        n = n % 4u;\n        return axis[n];\n    }\n}\n\nfloat pnoise21(vec2 p) {\n    vec2 f = fract(p);\n    vec2 g00 = hash22(p);\n    vec2 g01 = hash22(p + vec2(0.0, 1.0));\n    vec2 g10 = hash22(p + vec2(1.0, 0.0));\n    vec2 g11 = hash22(p + vec2(1.0, 1.0));\n    float v00 = dot(g00, f);\n    float v01 = dot(g01, f - vec2(0.0, 1.0));\n    float v10 = dot(g10, f - vec2(1.0, 0.0));\n    float v11 = dot(g11, f - vec2(1.0, 1.0));\n    f = f * f * f * (10.0 - 15.0 * f + 6.0 * f * f); \n    float v = mix(mix(v00, v10, f.x), mix(v01, v11, f.x), f.y);\n    return 0.5 * v + 0.5;\n}\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n    fragCoord_ = fragCoord;\n    vec2 pos = fragCoord.xy/min(iResolution.x, iResolution.y);\n    pos *= 10.0;\n    pos += 2.0 * iTime;\n    vec3 col = vec3(pnoise21(pos));\n    if (col.x > 0.85 || col.x < 0.15){\n        col = vec3(1.,0.,0.);\n    } \n    fragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3lGyDz.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[20, 702, 724, 724, 802], [803, 803, 824, 824, 1148], [1150, 1150, 1174, 1174, 1665], [1666, 1666, 1720, 1720, 1998]]}
{"id": "3lGyWW", "name": "Muramasa", "author": "tono", "description": "glsl", "tags": ["katana"], "likes": 2, "viewed": 59, "published": "Public", "date": "1610974487", "time_retrieved": "2021-10-01T00:00:00", "image_code": "mat2 rot(float a){return mat2(cos(a),sin(a),-sin(a),cos(a));}\nfloat pi = acos(-1.);\nvec3 pp;\n\n\nvec3 random3(vec3 c) {\n    float j = 4096.0*sin(dot(c,vec3(17.0, 59.4, 15.0)));\n    vec3 r;\n    r.z = fract(512.0*j);\n    j *= .125;\n    r.x = fract(512.0*j);\n    j *= .125;\n    r.y = fract(512.0*j);\n    return r-0.5;\n}\n\n//https://www.shadertoy.com/view/XsX3zB\n/* skew constants for 3d simplex functions */\nconst float F3 =  0.3333333;\nconst float G3 =  0.1666667;\n\n/* 3d simplex noise */\nfloat simplex3d(vec3 p) {\n    /* 1. find current tetrahedron T and it's four vertices */\n    /* s, s+i1, s+i2, s+1.0 - absolute skewed (integer) coordinates of T vertices */\n    /* x, x1, x2, x3 - unskewed coordinates of p relative to each of T vertices*/\n\n    /* calculate s and x */\n    vec3 s = floor(p + dot(p, vec3(F3,F3,F3)));\n    vec3 x = p - s + dot(s, vec3(G3,G3,G3));\n\n    /* calculate i1 and i2 */\n    vec3 e = step(vec3(0.,0.,0.), x - x.yzx);\n    vec3 i1 = e*(1.0 - e.zxy);\n    vec3 i2 = 1.0 - e.zxy*(1.0 - e);\n\n    /* x1, x2, x3 */\n    vec3 x1 = x - i1 + G3;\n    vec3 x2 = x - i2 + 2.0*G3;\n    vec3 x3 = x - 1.0 + 3.0*G3;\n\n    /* 2. find four surflets and store them in d */\n    vec4 w, d;\n\n    /* calculate surflet weights */\n    w.x = dot(x, x);\n    w.y = dot(x1, x1);\n    w.z = dot(x2, x2);\n    w.w = dot(x3, x3);\n\n    /* w fades from 0.6 at the center of the surflet to 0.0 at the margin */\n    w = max(0.6 - w, 0.0);\n\n    /* calculate surflet components */\n    d.x = dot(random3(s), x);\n    d.y = dot(random3(s + i1), x1);\n    d.z = dot(random3(s + i2), x2);\n    d.w = dot(random3(s + 1.0), x3);\n\n    /* multiply d by w^4 */\n    w *= w;\n    w *= w;\n    d *= w;\n\n    /* 3. return the sum of the four surflets */\n    return dot(d, vec4(52.0,52.0,52.0,52.0));\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat sdCylinder( vec3 p, vec3 c )\n{\n  return length(p.xz-c.xy)-c.z;\n}\n\nfloat pedestal(vec3 p)\n{\n    vec3 bp = p;\n    //bp.z -= 2.;\n    bp.z = abs(bp.z) - 8.;\n    bp.y -= 1.5;\n\tfloat b = sdBox(bp,vec3(.7,2.,.5)) - .2;\n    b = max(b , -sdBox(p - vec3(0.,-.36,0.) , vec3(.1,.5,10.5) )) ;\n    \n    float b2 = sdBox(p - vec3(0.,4.,0.),vec3(2.,1.,10.)) - .1;\n    b = min(b,b2);\n    if(b < 1.)\n    {\n        b -= simplex3d((p / vec3(1.,7.,1.)) * 7.) / 50.;\n    }\n    float o = b;\n    return o;\n}\n\nfloat station(vec3 p)\n{\n    p.yz *= rot(p.z/250.);\n    vec3 bp = p;\n    float b = sdBox(p - vec3(0.,13.,0.) , vec3(5.,8.,12.)) - .6;\n    if(b < 1.)\n    {\n        b -= simplex3d((p / vec3(2.,12.,2.)) * 30.)/10.;\n    }\n    return b;\n}\n\nfloat road(vec3 p)\n{\n    float o;\n    o = sdBox(p - vec3(0.,30.,0.),vec3(1000.,9.,16.)) - .5;\n    return o;\n}\n\nvec2 map(vec3 p)\n{\n    float o = 10.;\n    float id = 0.;\n    vec3 pedestalP = p;\n    vec3 po = p;\n    \n    p.yz *= rot(-p.z /90.);\n    p.y += 1.2;\n    o = sdBox(p,vec3( (max(pow( p.y/10.+.1  ,1.2), 0.01)) ,.5,12.) );\n    \n    pp = p;\n    float ped = pedestal(pedestalP);\n    if(ped < o)\n    {\n        o = ped;\n        id = 1.;\n    }\n    float station = station(po);\n    if(station < o)\n    {\n        o = station;\n        id = 2.;\n    }\n    float road = road(po);\n    if(road < o)\n    {\n        o = road;\n        id = 3.;\n    }\n    o *= .8;\n    return vec2(o,id);\n}\n\nvec2 march(vec3 cp , vec3 rd)\n{\n    float depth = 0.;\n    for(int i = 0 ; i < 128 ; i++)\n    {\n        vec3 rp = cp + rd * depth;\n        vec2 d = map(rp);\n        if(abs(d.x) < 0.01)\n        {\n            return vec2(depth,d.y);\n        }\n        depth += d.x;\n        if(depth > 290.){break;}\n    }\n    return vec2(-depth,0.);\n}\n\nfloat BechmannDistribution(float d, float m) {\n    float d2 = d * d;\n    float m2 = m * m;\n    return exp((d2 - 1.0) / (d2 * m2)) / (m2 * d2 * d2);\n}\n \nfloat Fresnel(float c, float f0) {\n    float sf = sqrt(f0);\n    float n = (1.0 + sf) / (1.0 - sf);\n    float g = sqrt(n * n + c * c - 1.0);\n    float ga = (c * (g + c) - 1.0) * (c * (g + c) - 1.0);\n    float gb = (c * (g - c) + 1.0) * (c * (g - c) + 1.0);\n    return (g - c) * (g - c) / (2.0 * (g + c) + (g + c)) * (1.0 + ga / gb);\n}\n\nvec3 CookTorrance(vec3 v,vec3 l , vec3 n,vec3 specular , float microfacet)\n{\n    vec3 h = normalize(l + v);\n \n    float hn = dot(h, n);\n    float ln = dot(l, n);\n    float lh = dot(l, h);\n    float vn = dot(v, n);\n \n    vec3 f = vec3(Fresnel(lh, specular.x), Fresnel(lh, specular.y), Fresnel(lh, specular.z));\n    float d = BechmannDistribution(hn, microfacet);\n    float t = 2.0 * hn / dot(v, h);\n    float g = min(1.0, min(t * vn, t * ln));\n    float m = pi * vn * ln;\n    vec3 spe = max(f * d * g / m, 0.0);\n    return spe;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 p = (fragCoord.xy * 2.0 - iResolution.xy) / min(iResolution.x, iResolution.y);\n\tvec3 col = vec3(0.);\n    vec3 cp = vec3(0.,-16.,-30.);\n    \n   // cp.z += mod(iTime* 100. , 280.);\n    \n    //cp.z += sin(iTime/2.5) * 280.;\n    cp.xz *= rot(pi/2.);\n    //cp.xz *= rot(1.5);\n    //cp.xz *= rot(-iTime/6.);\n    vec3 target = vec3(0.,0.,0.);\n    vec3 cd = normalize(target - cp);\n    vec3 cs = normalize(cross(cd,vec3(0.,1.,0.)));\n    vec3 cu = normalize(cross(cd,cs));\n    \n    float fov = 3.5;\n    vec3 rd = normalize(cd * fov + cs * p.x + cu * p.y);\n    \n    vec2 d = march(cp,rd);\n    if(d.x > 1.)\n    {\n        vec3 pos = cp + rd *d.x;\n        vec2 e   = vec2(0.,0.01);\n        vec3 N   = -normalize(map(pos).x - vec3(map(pos - e.xyy).x,map(pos - e.yxy).x,map(pos - e.yyx).x));\n        col = N;\n        vec3 sun = normalize(vec3(2.,4.,8.));\n    \tvec3 lpos = vec3(-2. * pi,0.,0.);\n        lpos.xz += vec2(sin(iTime * 2.) * 2.,cos(iTime * 2.)/2.) * 4.;\n        sun = normalize(pos - lpos);\n        float lightIntensity = 200./(4. * pi * pow( length(pos - lpos),2. ) );\n        //sun = -rd;\n        //sun.xz *= rot(iTime);\n        float diff = max(0.,dot(sun,N));\n        float shadow = step(march(pos + N * 0.01,sun).x,0.);\n        \n        vec3 blade = mix(vec3(.9),vec3(.1),clamp(pp.y+.9 + sin(sin(pp.z) + pp.z * 3.)/18.,0.,1.));\n        vec3 wood1 = vec3(.8,.8,.8) * mix( (1. - simplex3d((pos / vec3(7., 3.,1.)) * 10.) ),1. ,.2 );\n        vec3 wood2 = vec3(.2,.1,.0) * mix( (1. - simplex3d((pos / vec3(2.,12.,2.)) * 30.) * 3. ),1. ,.9 );\n        vec3 road = vec3(1.,1.,1.);\n        vec3 lightCol = vec3(0.);\n        if(d.y == 0.)\n        {\n            //yaiba\n            diff = mix(diff,1.,.5);\n            col = vec3(.3);\n        \tcol = blade;\n        \tvec3 spe = CookTorrance(rd,sun,N,vec3(.5,.5,.5),.1);\n        \tcol = diff * col + spe * vec3(1.);\n            col *= lightIntensity;\n            lightCol = blade;\n        }else if(d.y == 1.)\n        {\n            //pedestal\n            diff = mix(diff,1.,.4);\n            pos.yz *= rot(pos.x * 1.5);\n            col = wood1;\n            vec3 spe = CookTorrance(rd,sun,N,vec3(1.),.1);\n        \tcol = diff * col + spe * vec3(1.);\n            col *= lightIntensity * 2.;\n            lightCol = wood1;\n        }else if(d.y == 2.)\n        {\n            //station\n            diff = mix(diff,1.,.4);\n            pos.yz *= rot(pos.z * .01);\n            col = wood2;\n            vec3 spe = CookTorrance(rd,sun,N,vec3(1.),.1);\n        \tcol = diff * col + spe * vec3(1.);\n            col *= lightIntensity * 2.;\n            lightCol = wood2;\n        }else if(d.y == 3.)\n        {\n            diff = mix(diff,1.,.4);\n            pos.yz *= rot(pos.z * .01);\n            col = road;\n            vec3 spe = CookTorrance(rd,sun,N,vec3(1.),.01);\n        \tcol = diff * col + spe * vec3(1.);\n            col *= lightIntensity;\n            lightCol = road;\n        }\n        pos.xz *= rot(pi/2.);\n        pos.xy *= rot(pi/2.);\n        \n        {\n            //col =col + lightCol;\n        }\n        float dd =1. - exp(d.x * d.x * d.x * -.000001);\n        col = mix(col,vec3(0.),dd);\n    }\n    fragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3lGyWW.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 18, 18, 61], [95, 95, 117, 117, 314], [461, 484, 509, 768, 1760], [1762, 1762, 1793, 1793, 1880], [1882, 1882, 1918, 1918, 1952], [1954, 1954, 1978, 1978, 2371], [2373, 2373, 2396, 2396, 2605], [2607, 2607, 2627, 2627, 2716], [2718, 2718, 2736, 2736, 3282], [3284, 3284, 3315, 3315, 3614], [3616, 3616, 3662, 3662, 3765], [3768, 3768, 3802, 3802, 4101], [4103, 4103, 4179, 4179, 4631], [4633, 4633, 4690, 4690, 7857]]}
{"id": "3lKcDD", "name": "the_weird_rectange", "author": "aliser", "description": "hello", "tags": ["pulse"], "likes": 0, "viewed": 155, "published": "Public API", "date": "1611066012", "time_retrieved": "2021-10-01T00:00:00", "image_code": "bool isWithinRange(vec2 coord, vec2 from, vec2 to) {\n    vec2 fromBased = coord - from;\n    bool isFromWithin = fromBased.x >= 0.0 && fromBased.y >= 0.0;\n    vec2 toBased = to - coord;\n    bool isToWithin = toBased.x >= 0.0 && toBased.y >= 0.0;\n    return isFromWithin && isToWithin;\n}\n\nbool isWithinRange(float value, float from, float to) {\n    return value >= from && value <= to;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float tolerance = 1.0;\n    float timeModifier = 2.0;\n    float[2] distanceBetweenRange = float[2](tolerance * 8.0, tolerance * 16.0);\n    float[2] centerAmplitudeRange = float[2](10.0, 100.0);\n\n    float distanceBetweenRangeDifference = distanceBetweenRange[1] - distanceBetweenRange[0];\n    float timeCosNormalized = (cos(iTime * timeModifier * 2.0) + 1.0) / 2.0;\n    float stepSize = distanceBetweenRange[0] + timeCosNormalized * distanceBetweenRange[1];\n\n    vec2 center = vec2(0.5, 0.5) * iResolution.xy;\n    vec3 col = vec3(0.0, 0.0, 0.0);\n    float screenMaxResolution = max(iResolution.x, iResolution.y);\n    float timeSinNormalized = (sin(iTime * timeModifier * 2.0) + 1.0) / 2.0;\n    \n    for(int i = 0; i < int(screenMaxResolution); i++) {\n        float iF = float(i);\n        float t = (iF / screenMaxResolution - 1.0);\n        float offset = iF * stepSize;\n        float targetDistance = centerAmplitudeRange[0] + timeSinNormalized * centerAmplitudeRange[1] + offset;\n        \n        float horizontalLowerBound[2] = float[2](\n            center.y - targetDistance - tolerance,\n            center.y - targetDistance + tolerance\n        );\n        float horizontalUpperBound[2] = float[2](\n            center.y + targetDistance - tolerance,\n            center.y + targetDistance + tolerance\n        );\n        \n        float verticalLeftBound[2] = float[2](\n            center.x - targetDistance - tolerance,\n            center.x - targetDistance + tolerance\n        );\n        float verticalRightBound[2] = float[2](\n            center.x + targetDistance - tolerance,\n            center.x + targetDistance + tolerance\n        );\n\n\n        bool isWithinUpperMiddlePart = isWithinRange(\n            fragCoord, \n            vec2(verticalLeftBound[1], horizontalUpperBound[0]), \n            vec2(verticalRightBound[0], horizontalUpperBound[1])\n        );\n        bool isWithinLowerMiddlePart = isWithinRange(\n            fragCoord, \n            vec2(verticalLeftBound[1], horizontalLowerBound[0]), \n            vec2(verticalRightBound[0], horizontalLowerBound[1])\n        );\n\n        bool isWithinLeftMiddlePart = isWithinRange(\n            fragCoord, \n            vec2(verticalLeftBound[0], horizontalLowerBound[1]), \n            vec2(verticalLeftBound[1], horizontalUpperBound[0])\n        );\n        bool isWithinRightMiddlePart = isWithinRange(\n            fragCoord, \n            vec2(verticalRightBound[0], horizontalLowerBound[1]), \n            vec2(verticalRightBound[1], horizontalUpperBound[0])\n        );\n\n        bool someMiddlePartDrawApplicable = isWithinUpperMiddlePart || \n                                            isWithinLowerMiddlePart ||\n                                            isWithinLeftMiddlePart ||\n                                            isWithinRightMiddlePart;\n        if(someMiddlePartDrawApplicable) {\n            // Normalized pixel coordinates (from 0 to 1)\n            vec2 uv = fragCoord/iResolution.xy;\n\n            // Time varying pixel color\n            col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n        }\n    }\n    \n    fragColor = vec4(col, 1.0);\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3lKcDD.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 52, 52, 285], [287, 287, 342, 342, 385], [388, 388, 445, 445, 3559]]}
{"id": "3lKcDV", "name": "Fractal 03_gaz", "author": "gaz", "description": "3d", "tags": ["fractal"], "likes": 7, "viewed": 84, "published": "Public", "date": "1611804194", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define rot(a) mat2(cos(a),sin(a),-sin(a),cos(a))\n#define hash(n) fract(sin(n*234.567+123.34))\n\nfloat map(vec3 p){\n\tp.xy *= rot(iTime*0.3);\n    p.yz *= rot(iTime*0.4);\n\tfloat s=3.;\n\tp=abs(p);\n\tvec3  p0 = p*.9;\n\tfor (float i=0.; i<5.; i++){\n    \tp=1.-abs(p-1.);\n    \tp=1.-abs(abs(p-2.)-1.); \n    \tfloat g=-4.5*clamp(.45*max(1.6/dot(p,p),.7),.0,1.2);\n    \tp*=g;\n    \tp+=p0;\n        s*=g;\n\t}\n\ts=abs(s);\n\tfloat a=3.8;\n\tp-=clamp(p,-a,a);\n\treturn length(p)/s;\n\t\n\treturn length(cross(p,normalize(vec3(1))))/s-.005;\n}\n\n\nvec3 calcNormal(vec3 pos){\n  vec2 e = vec2(1,-1) * 0.002;\n  return normalize(\n    e.xyy*map(pos+e.xyy)+e.yyx*map(pos+e.yyx)+ \n    e.yxy*map(pos+e.yxy)+e.xxx*map(pos+e.xxx)\n  );\n}\n\nfloat march(vec3 ro, vec3 rd, float near, float far)\n{\n    float t=near,d;\n    for(int i=0;i<80;i++)\n    {\n        t+=d=map(ro+rd*t);\n        if (d<0.001) return t;\n        if (t>=far) return far;\n    }\n    return far;\n}\n\nfloat calcShadow( vec3 light, vec3 ld, float len ) {\n\tfloat depth = march( light, ld, 0.0, len );\t\n\treturn step( len - depth, 0.01 );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord* 2.0 - iResolution.xy) / iResolution.y;\n    vec3 ro = vec3(0,0,5.5);\n    vec3 rd = normalize(vec3(uv,-2.0));\n    vec3 col = vec3(0);\n\tconst float maxd = 40.0;\n    float t = march(ro,rd,0.0,maxd);\n    if(t<maxd)\n    {\n        vec3 p=ro+rd*t;\n        col=vec3(0.3,0.3,0.6)+cos(p*0.17)*0.5+0.5;\n        vec3 n = calcNormal(p);      \n\t\tvec3 lightPos=vec3(20);\n    \tvec3 li = lightPos - p;\n\t\tfloat len = length( li );\n\t\tli /= len;\n\t\tfloat dif = clamp(dot(n, li), 0.5, 1.0);\n        float sha = calcShadow( lightPos, -li, len );\n        col *= max(sha*dif, 0.4);\n        float rimd = pow(clamp(1.0 - dot(reflect(-li, n), -rd), 0.0, 1.0), 2.5);\n\t\tfloat frn = rimd+2.2*(1.0-rimd);\n    \tcol *= frn*.9;\n        col *= max(0.5+0.5*n.y, 0.0);\n        col *= exp2(-2.*pow(max(0.0, 1.0-map(p+n*0.3)/0.3),2.0));\n        col += vec3(0.5,0.9,0.9)*pow(clamp(dot(reflect(rd, n), li), 0.0, 1.0), 8.0);\n        col = mix(vec3(0),col,exp(-t*t*.003));\n    }\n    fragColor.xyz = col;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3lKcDV.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[96, 96, 114, 114, 509], [512, 512, 538, 538, 690], [692, 692, 746, 746, 912], [914, 914, 966, 966, 1049], [1051, 1051, 1108, 1108, 2095]]}
{"id": "3lKcRD", "name": "The Great Beyond", "author": "changwenhan", "description": "inspired by Pixar's movie \"Soul\"", "tags": ["gif"], "likes": 7, "viewed": 124, "published": "Public", "date": "1610618221", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float rand(vec2 p) {\n    p = fract(p * vec2(324.456, 863.789));\n    p += dot(p, p+89.56);\n    return fract(p.x*p.y);\n}\n\nfloat gauss(float x, float x0, float sx){\n    \n    float arg = x-x0;\n    arg = -1./2.*arg*arg/sx;\n    \n    float a = 1./(pow(2.*3.1415*sx, 0.5));\n    \n    return a*exp(arg);\n}\n\nfloat sun(vec2 uv, float zoom) {\n    // rotate\n    float radian = fract(iTime*.001) * 3.1415926 * 2.;\n    float s = sin(radian);\n    float c = cos(radian);\n    mat2 rotate = mat2(c, -s, s, c);\n    uv *= rotate;\n\n    float density = 500.;\n    uv *= zoom;\n    \n    float col;\n    \n    float distToCenter = length(uv);\n    \n    float cir = smoothstep(.7, .15, distToCenter);\n    float glow = smoothstep(2., .0, distToCenter);\n    \n    col += cir;\n    col += glow*.2;\n    \n    vec2 id = floor(uv*density/zoom);\n\n    float prob = gauss(distToCenter*4.5, 1., 1.);\n    \n    float dots = 1. - step(prob, rand(id));\n    \n    float fade = smoothstep(1.5, .3, length(uv/zoom));\n    col += dots * fade;\n    \n    col = max(min(1., col), 0.);\n    \n    return col;\n}\n\nfloat bridge(vec2 uv) {\n    float col;\n    \n    float t = smoothstep(-0.05, -0.15, uv.y);\n    \n    float l = smoothstep(0.17, 0.12, abs(uv.x/(uv.y-.01)/4.));\n    \n    col = l*t;\n    \n    col = max(min(1., col), 0.);\n    \n    return col;\n}\n\nfloat stairs(vec2 uv) {\n\n    vec2 stair_uv = uv;\n    stair_uv.y += 0.8;\n    stair_uv.y = fract(stair_uv.y*stair_uv.y*stair_uv.y*20.) - .5;\n    \n    float line = smoothstep(0.1, 0., abs(stair_uv.y));\n    float l2 = smoothstep(0.2, 0.1, abs(uv.x/uv.y/3.));\n    float t = smoothstep(-0.05, -0.15, uv.y);\n    float col = l2 * line * t;\n    \n    col = max(min(1., col), 0.);\n    \n    return col;\n}\n\nvec3 soul(vec2 uv) {\n    vec2 b_uv = uv;\n    vec2 h_uv = uv;\n    float col;\n    \n    b_uv.x *= 1.3;\n    b_uv *= 1.6;\n    float body = smoothstep(.1, .09, length(b_uv));\n    col += body;\n    \n    h_uv += vec2(0.,-.08);\n    h_uv *= 1.3;\n    //h_uv.x *= 1.5;\n    float head = smoothstep(.1, .09, length(h_uv));\n    col += head;\n    \n    //h_uv += vec2(0.,-.1);\n    //h_uv.x *= 1.5;\n    //float head = smoothstep(.1, .09, length(h_uv));\n    //col += head;\n    \n    col = max(min(1., col), 0.);\n    \n    vec3 color = vec3(uv.x+.5, uv.y+.5, 1.) * col;\n    \n    return color;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord.xy-0.5*iResolution.xy)/iResolution.y;\n    vec2 b_uv = uv;    \n    vec2 s_uv = uv;\n    \n    vec3 pixelColor;\n    \n    float col = 0.;\n    \n    \n    // sun\n    uv += vec2(-.3, -.1);\n    col += sun(uv, 2.*(sin(iTime*.1)*.1+.5));\n    \n    \n    // bridge\n    b_uv += vec2(.01, .05);\n    b_uv.x -= b_uv.y*2.;\n    b_uv += vec2(-.3, -.1);\n    col -= bridge(b_uv+vec2(0., .06)) * .7;\n    col = max(min(1., col), 0.);\n    col += stairs(b_uv+vec2(0., .06)) * .8;\n    \n    col += stairs(b_uv+vec2(0., .06)) * .8;\n    \n    s_uv += vec2(.4, .35);\n    //col += soul(s_uv);\n\n    pixelColor += col;\n    \n    // soul\n    //pixelColor = mix(pixelColor, soul(s_uv), smoothstep(0.,0.6,soul(s_uv))); \n    \n    // Output to screen\n    fragColor = vec4(pixelColor, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3lKcRD.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 20, 20, 118], [120, 120, 161, 161, 295], [297, 297, 329, 343, 1048], [1050, 1050, 1073, 1073, 1288], [1290, 1290, 1313, 1313, 1682], [1684, 1684, 1704, 1704, 2254], [2257, 2257, 2314, 2314, 3088]]}
{"id": "3lKcRw", "name": "Periodic Gradient Noise", "author": "tomoe", "description": "Hash function is modified to periodic one (L: 2D, R: 3D)", "tags": ["bd202101"], "likes": 0, "viewed": 51, "published": "Public", "date": "1610692812", "time_retrieved": "2021-10-01T00:00:00", "image_code": "uvec3 k = uvec3(0x456789abu, 0x6789ab45u, 0x89ab4567u);\nconst uint max32 = 0xffffffffu;\nuvec2 hash22u(uvec2 n) {\n    n ^= (n.yx << 24);\n    n ^= (n.yx >> 1);\n    n *= k.xy;\n    n ^= (n.yx << 1);\n    return n * k.xy;\n}\nvec2 hash22(vec2 p) {\n    float period = 8.0;  //periodicity\n    uvec2 n = uvec2(mod(p, period));\n    vec2 v = vec2(hash22u(n)) / vec2(max32);\n    return normalize(2.0 * v - vec2(1.0));\n}\nuvec3 hash33u(uvec3 n) {\n    n ^= (n.yzx << 24);\n    n ^= (n.yzx >> 1);\n    n *= k;\n    n ^= (n.yzx << 1);\n    return n * k;\n}\nvec3 hash33(vec3 p) {\n    float period = 8.0;  //periodicity\n    uvec3 n = uvec3(mod(p, period));\n    vec3 v = vec3(hash33u(n)) / vec3(max32);\n    return normalize(2.0 * v - vec3(1.0));\n}\nfloat gnoise21(vec2 p) {\n    vec2 i = floor(p);\n    vec2 g00 = hash22(i);\n    vec2 g01 = hash22(i + vec2(0.0, 1.0));\n    vec2 g10 = hash22(i + vec2(1.0, 0.0));\n    vec2 g11 = hash22(i + vec2(1.0, 1.0));\n    vec2 f = fract(p);\n    float v00 = dot(g00, f);\n    float v01 = dot(g01, f - vec2(0.0, 1.0));\n    float v10 = dot(g10, f - vec2(1.0, 0.0));\n    float v11 = dot(g11, f - vec2(1.0, 1.0));\n    f = f * f * f * (10.0 - 15.0 * f + 6.0 * f * f);\n    float v = mix(mix(v00, v10, f.x), mix(v01, v11, f.x), f.y);\n    return 0.5 * v + 0.5;\n}\nfloat gnoise31(vec3 p) {\n    vec3 f = fract(p);\n    p= floor(p);\n    vec3 g000 = hash33(p);\n    vec3 g001 = hash33(p + vec3(0.0, 0.0, 1.0));\n    vec3 g010 = hash33(p + vec3(0.0, 1.0, 0.0));\n    vec3 g011 = hash33(p + vec3(0.0, 1.0, 1.0));\n    vec3 g100 = hash33(p + vec3(1.0, 0.0, 0.0));\n    vec3 g101 = hash33(p + vec3(1.0, 0.0, 1.0));\n    vec3 g110 = hash33(p + vec3(1.0, 1.0, 0.0));\n    vec3 g111 = hash33(p + vec3(1.0, 1.0, 1.0));\n    \n    float v000 = dot(g000, f);\n    float v001 = dot(g001, f - vec3(0.0, 0.0, 1.0));\n    float v010 = dot(g010, f - vec3(0.0, 1.0, 0.0));\n    float v011 = dot(g011, f - vec3(0.0, 1.0, 1.0));\n    float v100 = dot(g100, f - vec3(1.0, 0.0, 0.0));\n    float v101 = dot(g101, f - vec3(1.0, 0.0, 1.0));\n    float v110 = dot(g110, f - vec3(1.0, 1.0, 0.0));\n    float v111 = dot(g111, f - vec3(1.0, 1.0, 1.0));\n    f = f * f * f * (10.0 - 15.0 * f + 6.0 * f * f);\n    float xy0 = mix(mix(v000, v100, f.x), mix(v010, v110, f.x), f.y);\n    float xy1 = mix(mix(v001, v101, f.x), mix(v011, v111, f.x), f.y);\n    return 0.5 * mix(xy0, xy1, f.z) + 0.5;\n}\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n    vec2 pos = fragCoord.xy/min(iResolution.x, iResolution.y);\n    pos *= 20.;\n    pos += iTime;\n    vec3 col;\n    if (fragCoord.x < 0.5 * iResolution.x){\n        col = vec3(gnoise21(pos));\n    } else{\n        col = vec3(gnoise31(vec3(pos, iTime)));\n    }\n    fragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3lKcRw.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[88, 88, 112, 112, 217], [218, 218, 239, 239, 405], [406, 406, 430, 430, 532], [533, 533, 554, 554, 720], [721, 721, 745, 745, 1258], [1259, 1259, 1283, 1283, 2338], [2339, 2339, 2393, 2393, 2683]]}
{"id": "3lKczD", "name": "ray is marching", "author": "milez770", "description": "Just learned raymarching from youtube\nLiked how less march steps felt like space bending.\nSo left it like this.", "tags": ["raymarch"], "likes": 1, "viewed": 45, "published": "Public", "date": "1610672689", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define MAX_STEPS 100\n#define MAX_DIST 100.\n#define SURF_DIST 0.01\n\nmat2 Rot(float a) {\n    float s = sin(a);\n    float c = cos(a);\n    return mat2(c, -s, s, c);\n}\n\nfloat sdCapsule(vec3 p, vec3 a, vec3 b, float r){\n    vec3 ab = b-a;\n    vec3 ap = p-a;\n    \n    float t = dot(ab, ap) / dot(ab, ab);\n    t = clamp(t, 0., 1.);\n    \n    vec3 c = a + t*ab;\n    \n    return length(p-c)-r;\n}\n\nfloat sdTorus(vec3 p, vec2 r){\n    float x = length(p.xz)-r.x;\n    return length(vec2(x, p.y))-r.y;\n}\n\nfloat dBox(vec3 p, vec3 s){\n    //p.xz *= Rot(iTime);\n    p = abs(p)-s;\n\treturn length(max(p, 0.))+min(max(p.x, max(p.y, p.z)), 0.);\n}\n\nfloat smin( float a, float b, float k ) {\n    float h = clamp( 0.5+0.5*(b-a)/k, 0., 1. );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\nfloat GetDist(vec3 p){\n    // sphere position\n    vec4 s = vec4(0, 1, 6, 1);\n    // point to sphere dist\n    // point to plane dist\n    float planeDist = dot(p, normalize(vec3(0, 1, 0)));\n    \n    vec3 sp = p;\n    sp.xz *= Rot(iTime);\n    sp -= vec3(3., 1, 0);\n    sp.xz *= Rot(iTime*2.);\n    float sphereDist = length(p-s.xyz)-s.w;\n    \n    vec3 bp = p;\n    bp.xz *= Rot(iTime);\n    bp -= vec3(3., 1, 0);\n    bp.xz *= Rot(iTime*2.);\n    float box = dBox(bp, vec3(1.));\n    \n    vec3 cp = p;\n    cp.xz *= Rot(iTime*1.5);\n    cp -= vec3(2., 1, 0);\n    //cp.xz *= Rot(iTime*10.);\n    \n    float cd = sdCapsule(cp, vec3(0, 0, 0), vec3(0, 1, .5), .8);\n    \n    vec3 tp = p;\n    tp -= vec3(0, 2, 0);\n    tp.yz *= Rot(iTime);\n    tp.xy *= Rot(iTime);\n    float td = sdTorus(tp - vec3(0, .0, 0), vec2(1.5, .2));\n    \n    vec3 bdp = p-vec3(0, 1, 0);\n    float scale = mix(1., 2., smoothstep(0., 1., bdp.y));\n    bdp.xz *= scale;\n    bdp.xz *= Rot(smoothstep(0., 1., bdp.y) - iTime);\n    \n    float bd = dBox( bdp , vec3(1) )/scale;\n    //bd -= sin(p.x*8.+iTime*2.7)*.1;\n    //bd = abs(bd)-.1;\n    \n    float blend = smin(td, box, .8);\n    float blend2 = smin(blend, box, .8);\n    \n    // plane or sphere\n    float d = 10000.;\n    //cd = abs(cd);\n    d = min(d, bd);\n    d = min(d, planeDist*300.);\n    d = min(d, blend*1.4);\n    //d = min(d, bd);\n    return d;\n}\n\nfloat RayMarch(vec3 ro, vec3 rd){\n    // dist from origin\n    float dO = 0.;\n    \n    // march till Max step\n    for(int i=0; i<MAX_STEPS; i++){\n        // marched point\n        vec3 p = ro + rd*dO;\n        // distance from marched point\n        float dS = GetDist(p);\n        // move marched point\n        dO += dS;\n        // if march end break \n        if(dO > MAX_DIST || dS<SURF_DIST) break;\n    }\n    \n    return dO;\n}\n\nvec3 GetNormal(vec3 p){\n    // distance from p to sphere\n    float d = GetDist(p);\n    // very small number for diff\n    vec2 e = vec2(.001, 0);\n    \n    // getting vector with very small vector\n    vec3 n = d - vec3(\n        GetDist(p-e.xyy),\n        GetDist(p-e.yxy),\n        GetDist(p-e.yyx)\n    );\n    \n    return normalize(n);\n\n}\n\nfloat GetLight(vec3 p){\n    vec3 lightPos = vec3(3, 5, 6);\n    lightPos.xz += vec2(sin(iTime), cos(iTime))*2.;\n    vec3 l = normalize(lightPos - p);\n    vec3 n = GetNormal(p);\n    \n    float dif = clamp(dot(n, l)*.5+.5, 0., 1.);\n    float d = RayMarch(p+n*SURF_DIST*2., l);    \n   // float d = RayMarch(p+n*SURF_DIST*2., l);\n\n    if(d<length(lightPos - p)) dif *= .3;\n    \n    return dif;\n    \n}\n\n\nvec3 R(vec2 uv, vec3 p, vec3 l, float z) {\n    vec3 f = normalize(l-p),\n        r = normalize(cross(vec3(0,1,0), f)),\n        u = cross(f,r),\n        c = p+f*z,\n        i = c + uv.x*r + uv.y*u,\n        d = normalize(i-p);\n    return d;\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   \n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\tvec2 m = iMouse.xy/iResolution.xy;\n    \n    vec3 col = vec3(0);\n    \n    vec3 ro = vec3(0, 4, -5);\n\n    \n    vec3 rd = R(uv, ro, vec3(0,0,0), .7);\n\n    \n    float d = RayMarch(ro, rd);\n    if(d<MAX_DIST) {\n    \tvec3 p = ro + rd * d;\n    \n    \tfloat dif = GetLight(p);\n    \tcol = vec3(dif);\n    }\n    \n    vec3 p = ro+rd*d;\n\n    float dif = GetLight(p);\n    col = vec3(dif);\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3lKczD.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[68, 68, 87, 87, 163], [165, 165, 214, 214, 385], [387, 387, 417, 417, 488], [490, 490, 517, 543, 624], [626, 626, 667, 667, 758], [760, 760, 782, 805, 2114], [2116, 2116, 2149, 2173, 2540], [2542, 2542, 2565, 2598, 2876], [2878, 2878, 2901, 2901, 3273], [3276, 3276, 3318, 3318, 3513], [3517, 3517, 3574, 3574, 4074]]}
{"id": "3lKyDc", "name": "Meta-furballs", "author": "yonatan", "description": "name says it all", "tags": ["metaballs", "fur"], "likes": 24, "viewed": 485, "published": "Public API", "date": "1612079166", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// texture based 3D value noise by iq - https://www.shadertoy.com/view/4sfGzS\nfloat noise( in vec3 x )\n{\n    vec3 i = floor(x);\n    vec3 f = fract(x);\n\tf = f*f*(3.0-2.0*f);\n\tvec2 uv = (i.xy+vec2(37.0,17.0)*i.z) + f.xy;\n\tvec2 rg = textureLod( iChannel0, (uv+0.5)/256.0, 0.0).yx;\n\treturn mix( rg.x, rg.y, f.z );\n}\n\n// Metaballs and analytic normals from Klems' https://www.shadertoy.com/view/4dj3zV\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 a, q, p, gradient, normal, dir;\n    float b, dist, bdist;\n    dir = normalize(vec3((2.*fragCoord.xy-iResolution.xy)/min(iResolution.x,iResolution.y), 1.7));\n    p = vec3(0, 0, -3);\n    for(int i = 0; i < 200; i++) {\n        q = p; // save current position\n        p += dir * dist; // step\n        gradient = vec3(0);\n        dist = 1.;\n        for(float j = 0.; j < 3.; j++) {\n            vec3 ballp = sin(vec3(1,2,5) * j + iTime); // ball position\n            b = dot(a = p - ballp, a);\n            // gradient += a / (b * b); // actual normals\n            gradient += a / sqrt(b); // Shane's fur grooming tip\n            dist -= .5 / b;\n        }\n        normal = normalize(gradient);\n        bdist = dist;\n        if(i>90 && dist<.01) {\n            dist += noise(normal*60.);\n            dist *= .02;\n        }\n     }\n    vec3 col = normal.yyy*.4+.5;\n    if(dist<.1) col = col * vec3(.9,.3,.5) + .1;\n    else col = col * vec3(.7,.8,.5);\n    fragColor.rgb = col * (1.+bdist);\n}", "image_inputs": [{"id": "Xsf3zn", "previewfilepath": "/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "channel": 0, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3lKyDc.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 78, 104, 104, 311], [313, 397, 454, 454, 1443]]}
{"id": "3lKyDd", "name": "What the Devil?", "author": "kstyler", "description": "Fiery 5 pointed star. ", "tags": ["2d", "flame", "devil"], "likes": 3, "viewed": 175, "published": "Public API", "date": "1611994160", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define UI0 1597334673U\n#define UI1 3812015801U\n#define UI2 uvec2(UI0, UI1)\n#define UI3 uvec3(UI0, UI1, 2798796415U)\n#define UIF (1.0 / float(0xffffffffU))\n\nfloat random(vec2 p){\n\tuvec2 q = uvec2(ivec2(p)) * UI2;\n\tuint n = (q.x ^ q.y) * UI0;\n\treturn float(n) * UIF;\n}\n\nfloat noise(vec2 uv){\n\tvec2 id = floor(uv*10.);\n    vec2 lc = smoothstep(0.,1.,fract(uv*10.));\n    \n    float a = random(id);\n    float b = random(id + vec2(1.,0.));\n    float c = random(id + vec2(0.,1.));\n    float d = random(id + vec2(1.,1.));\n    \n    float ud = mix(a,b,lc.x);\n    float lr = mix(c,d,lc.x);\n    float fin = mix(ud,lr,lc.y);\n    return fin;\n}\n\nfloat octaves(vec2 uv){\n    float amp = 0.5;\n    float f = 0.;\n    for(int i =1; i<5;i++){\n    \tf+=noise(uv)*amp;\n        uv*=2.;\n        amp*=0.5;\n    }\n    return f;\n}\n\nfloat circle(vec2 uv,float r){\n    return length(uv) - r;\n}\n\nfloat star(vec2 uv, int pts, float r){\n    uv = uv*4.-2.;\n    float tau = 3.141592*2.;\n    float a = atan(uv.y,uv.x)/tau;\n    float seg = a * float(pts);\n    a = ((floor(seg) +.5)/float(pts) + mix(r,-r,step(.5,fract(seg))))*tau;\n    return abs(dot(vec2(cos(a),sin(a)),uv));\n}\n\nfloat stroke(float x, float s, float w){\n    float o = (step(s,x+w)-step(s,x-w));\n    o = clamp(o,0.,1.);\n\treturn o;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    uv+=.5;\n    uv.y+=.05;\n    uv.y = 1.-uv.y;\n    uv.x+=sin(iTime*2.+uv.y*3.)*.02 + cos(iTime*10.+uv.y*20.2)*.01;\n    vec3 col = vec3(0.);\n    float s = star(uv.yx,5,.099+octaves(uv+vec2(0.,iTime/2.))*.06*(.3-uv.y));\n    float s2 = star(uv.yx,5,.888+octaves(uv+vec2(0.,iTime/2.))*.06*(.3-uv.y));\n    col+=min(smoothstep(0.49,.5,s),1.-stroke(circle(uv-.5,.01),.25,.001+octaves(uv+vec2(0.,iTime/2.))*.05*(1.-uv.y)));  \n    col = 1.-col;\n    col*=mix(vec3(1.0,0.,.1),0.6+vec3(0.3,0.5,0.2),uv.y-.1);\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3lKyDd.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[157, 157, 178, 178, 267], [269, 269, 290, 290, 630], [632, 632, 655, 655, 801], [803, 803, 833, 833, 862], [864, 864, 902, 902, 1139], [1141, 1141, 1181, 1181, 1259], [1261, 1261, 1317, 1317, 1930]]}
{"id": "3lKyDz", "name": "Bienvenue dans la 4ème dimension", "author": "Akanoa", "description": "Opération booléenne dynamique sur des shères en raymarching avec applications de textures et d'ombrage", "tags": ["debutant"], "likes": 0, "viewed": 42, "published": "Public", "date": "1610826558", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define MIN_DISTANCE   0.001\n#define MAX_DISTANCE   20.\n#define MAX_ITERATIONS 200\n\n\n#define MATERIAL_RED   1  \n#define MATERIAL_BLUE  2\n#define MATERIAL_GREEN 3\n#define MATERIAL_YELLOW 4\n\n\n/**\n* m : index du matériau à appliquer\n* d : distance à la surface observée\n*/\nstruct Data {\n    float d;\n    int m;\n};\n\n\n/**\n* Calcul la distance signée en entre le point p et la surface de la sphère\n* p : point courant calculé par rapport à la sphère\n* c : coordonnées du centre de la sphère\n* r : rayon de la sphère\n* m : matériau à appliquer sur la surface de la sphère\n*/\nData sdSphere(vec3 p, vec3 c, float r, int m) {\n    return Data(length(p - c) - r, m);\n}\n\n/**\n* Calcule la distance signée entre le point p et la surface du plan de hauteur h\n* p : point courant calculé par rapport à la sphère\n* h : hauteur du plan par rapport à l'origine du monde\n* m : matériau à appliquer sur la surface du plan\n*/\nData sdPlanH(vec3 p, float h, int m) {\n    return Data(p.y - h, m);\n}\n\nData sdBox(vec3 p, vec3 b, int m) {\n    vec3 q = abs(p) - b;\n    float d = min(max(q.x,max(q.y,q.z)),0.0) + length(max(q,0.0));\n    return Data(d, m);\n}\n\nData sdTorus(vec3 p, vec2 t, int m) {\n    vec2 q = vec2(length(p.xz)-t.x,p.y);\n    float d = length(q)-t.y;\n    return Data(d, m);\n}\n\nData minData(Data d1, Data d2) {\n    \n    if(d1.d < d2.d) {\n        return d1;\n    }\n    return d2; \n}\n\nData maxData(Data d1, Data d2) {\n    \n    if(d1.d > d2.d) {\n        return d1;\n    }\n    return d2; \n}\n\nData minusData(Data d) {\n    return Data(-d.d, d.m);\n}\n\nData scene(vec3 p) {\n    \n    Data s1 = sdSphere(p, vec3(0.5*cos(iTime), 0, 1.7), 0.7, MATERIAL_RED);\n    Data s2 = sdSphere(p, vec3(cos(iTime), 0, 1.2), 0.2, MATERIAL_GREEN);\n    Data s3 = sdSphere(p, vec3(cos(0.9*iTime), 0, 1.2), 0.3, MATERIAL_BLUE);\n    \n    Data b = sdBox(p - vec3(0, max(0.0,0.5*sin(0.5*iTime)), 1), vec3(1, 2, 500)*.1, MATERIAL_YELLOW);\n    \n    Data pl = sdPlanH(p, -0.2, MATERIAL_BLUE);\n    \n    Data s = maxData(minusData(s2), s1);\n    \n    Data donut = sdTorus(p - vec3(0,0,1), vec2(0.25, 0.1), MATERIAL_GREEN);\n  \n    s = maxData(minusData(s3), s);\n    s = maxData(minusData(b), s);\n    s = minData(s, pl);\n    s = minData(donut, s);\n    \n    return s;\n}\n\nData rayMarch(vec3 rO, vec3 rD) {\n    \n    float d = 0.0;\n    int m = 0;\n    for(int i=0; i < MAX_ITERATIONS; i++) {\n        \n        vec3 p =  rO + rD * d;\n        Data ds =  scene(p);\n        d += ds.d;\n        m = ds.m;\n        if (ds.d < MIN_DISTANCE || d > MAX_DISTANCE) break;\n    }\n    \n    return Data(d, m);\n\n}\n\n\nvec3 material(int index) {\n    switch(index) {\n        case MATERIAL_RED:\n            return vec3(1.0, 0, 0);\n        case MATERIAL_GREEN:\n            return vec3(0, 1.0, 0);\n        case MATERIAL_BLUE:\n            return vec3(0, 0, 1.0);\n        case MATERIAL_YELLOW:\n            return vec3(1.0, 1.0, 0);\n        default:\n            return vec3(0);\n    }\n        \n}\n\nvec3 normal(vec3 p) {\n    float dp = scene(p).d;\n    \n    float eps = 0.01;\n    \n    float dx = scene(p + vec3(eps, 0, 0)).d - dp;\n    float dy = scene(p + vec3(0, eps, 0)).d - dp;\n    float dz = scene(p + vec3(0, 0, eps)).d - dp;\n    \n    return normalize(vec3(dx, dy, dz));\n}\n\n\nfloat lighting(vec3 p, vec3 n, vec3 lp) {\n    \n    vec3 ld = lp - p;\n    vec3 ln = normalize(ld);\n    \n    float d = rayMarch(p + n * 0.01, ln).d;\n    \n    if (d < length(ld)) return 0.0;\n    \n    return max(0.0, dot(ln, n));\n    \n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - 0.5* iResolution.xy) / iResolution.y;\n    \n    vec2 mouse = iMouse.xy / iResolution.xy;\n    \n    \n    float k = 1.;\n    vec3 lp = vec3(k*cos(iTime), 1, k*sin(iTime));\n    \n    \n    vec3 camera = vec3(0, mouse.y, 0);\n    vec3 screen = vec3(uv, 1.0);\n    \n    vec3 rD = normalize(screen - camera);\n    \n    Data data =  rayMarch(camera, rD);\n    \n    vec3 col = vec3(0);\n    \n    if(data.d < MAX_DISTANCE) {\n    \n       vec3 p = camera + rD * data.d;\n       vec3 n = normal(p);\n       float l = lighting(p, n, lp);\n       \n       vec3 m = material(data.m);\n       \n       col = m * l;\n       col = pow(col, vec3(0.4545));\n       \n    }\n    \n    fragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3lKyDz.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[317, 583, 630, 630, 671], [673, 925, 963, 963, 994], [996, 996, 1031, 1031, 1148], [1150, 1150, 1187, 1187, 1282], [1284, 1284, 1316, 1316, 1386], [1388, 1388, 1420, 1420, 1490], [1492, 1492, 1516, 1516, 1546], [1548, 1548, 1568, 1568, 2230], [2232, 2232, 2265, 2265, 2551], [2554, 2554, 2580, 2580, 2922], [2924, 2924, 2945, 2945, 3201], [3204, 3204, 3245, 3245, 3436], [3439, 3439, 3496, 3496, 4196]]}
{"id": "3lKyRV", "name": "Interlocking Hexgonal Pattern", "author": "oneshade", "description": "I am having WAY too much fun.", "tags": ["demo", "pattern", "tiling", "hexagonal", "interlocking"], "likes": 7, "viewed": 83, "published": "Public", "date": "1611342932", "time_retrieved": "2021-10-01T00:00:00", "image_code": "struct Surface {\n    float dist;\n    vec3 ambient;\n    vec3 diffuse;\n    vec3 specular;\n    float gloss;\n};\n\nfloat sdHexLink(in vec3 p, in float radius, in float thickness) {\n    p = abs(p);\n    return max(abs(max(dot(p.xz, vec2(0.5, 0.86602540378)), p.x) - radius), p.y) - thickness;\n}\n\nSurface mapScene(in vec3 p) {\n    p.xy = vec2(atan(p.y, p.x) * 10.0, length(p.xy));\n    p.y -= 10.0;\n\n    float tileSize = 8.0;\n    float thickness = 0.2;\n\n    vec2 repTile = vec2(1.0, 1.73) * tileSize;\n    vec2 hRepTile = 0.5 * repTile;\n\n    vec2 a = mod(p.xz, repTile) - hRepTile;\n    vec2 b = mod(p.xz - hRepTile, repTile) - hRepTile;\n    p.xz = dot(a, a) < dot(b, b) ? a : b;\n\n    float linkSize = 0.35 * tileSize;\n    float basePattern = sdHexLink(p, linkSize, thickness);\n\n    float repAng = 6.28 / 6.0;\n    float hRepAng = 0.5 * repAng;\n    p.xz = sin(mod(atan(p.z, p.x) - hRepAng, repAng) - hRepAng + vec2(1.57, 0.0)) * length(p.xz);\n    float links = sdHexLink(p.xzy - vec3(0.575 * tileSize, 0.0, 0.0), linkSize, thickness);\n\n    return Surface(min(basePattern, links), vec3(0.2, 0.0, 0.0), vec3(1.0, 0.0, 0.0), vec3(1.0), 16.0);\n}\n\nvec3 getNormal(in vec3 p) {\n    vec3 e = vec3(0.001, 0.0, 0.0);\n    return normalize(vec3(mapScene(p + e.xyy).dist - mapScene(p - e.xyy).dist,\n                          mapScene(p + e.yxy).dist - mapScene(p - e.yxy).dist,\n                          mapScene(p + e.yyx).dist - mapScene(p - e.yyx).dist));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n    fragColor = vec4(0.0, 0.0, 0.0, 1.0);\n\n    vec3 ro = vec3(0.0, 0.0, -iTime * 20.0);\n    vec3 rd = normalize(vec3(uv, -1.0));\n\n    float c = cos(iTime), s = sin(iTime);\n    rd.xy *= mat2(c, -s, s, c);\n\n    vec3 l = vec3(-0.58, 0.58, 0.58);\n\n    float t = 0.0;\n    for (int i=0; i < 100; i++) {\n        vec3 p = ro + rd * t;\n        Surface scene = mapScene(p);\n        if (scene.dist < 0.001) {\n            vec3 n = getNormal(p);\n            fragColor.rgb += scene.ambient;\n\n            float lambertian = max(0.0, dot(n, l));\n            fragColor.rgb += scene.diffuse * lambertian;\n\n            if (lambertian > 0.0) {\n                vec3 r = reflect(l, n);\n                float specAngle = max(0.0, dot(r, rd));\n                fragColor.rgb += scene.specular * max(0.0, pow(specAngle, scene.gloss));\n            }\n\n            break;\n        }\n\n        if (t > 100.0) {\n            break;\n        }\n\n        t += scene.dist;\n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3lKyRV.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[109, 109, 174, 174, 286], [288, 288, 317, 317, 1128], [1130, 1130, 1157, 1157, 1434], [1436, 1436, 1491, 1491, 2499]]}
{"id": "3lKyW3", "name": "pulsar00113", "author": "lyurai", "description": "test 00002445", "tags": ["itime"], "likes": 2, "viewed": 180, "published": "Public API", "date": "1611869159", "time_retrieved": "2021-10-01T00:00:00", "image_code": "mat2 rot(float a){return mat2(cos(a),-sin(a),sin(a),cos(a));}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 col;\n    float t;\n    \n    for(int c=0;c<3;c++){\n\t    vec2 uv = (fragCoord*1.6-iResolution.xy)/iResolution.y;\n        t = iTime+float(c)/1.;\n        for(int i=0;i<20;i++){\n            uv=abs(uv);\n            uv-=.5;\n            uv=uv*rot(t/float(i+200));\n        }\n\t    col[c]= step(.5,fract(uv.x*20.));\n    }\n\n    fragColor = vec4(vec3(col),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3lKyW3.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 18, 18, 61], [63, 63, 120, 120, 479]]}
{"id": "3lKyzc", "name": "Where the birds go ", "author": "xavierseb", "description": "Another lucky find!", "tags": ["3d", "geometric"], "likes": 4, "viewed": 156, "published": "Public API", "date": "1611458174", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// where the birds go\n#define rot(a) mat2(cos(a), sin(a), -sin(a), cos(a))\nconst float TAU = atan(1.0) * 8.0;\n#define ss(f,g,h) smoothstep(f,g,t)*h\n\nvec3 map(vec3 p, float u, float v) {\t\n\tfloat k;\n\tp.yz *= rot(v);\n\tp.xy *= rot(u);\n\tfor (int i = 0; i < 6; i++) {\n\t\tk = length(p.xy); p.x = k * (mod(atan(p.y, p.x), TAU/8.) - TAU/16.); p.y = k - 2.752;\t\t\n\t\tk = length(p.yz); p.y = k * (mod(atan(p.z, p.y), TAU/12.) - TAU/24.);p.z = k - 10.0; //-9.\n\t}\n\t\n\tp.x = dot(abs(p), normalize(vec3(6.9,5,2.2))) - 1.6 ;\n\treturn p; \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord / iResolution.x -.5;\n\tvec3 rd = normalize(vec3(uv, 1)); \n    vec2 mouse=iMouse.xy/iResolution.xy;\n\tfloat t =mod(iTime,30.)/30.,v=-8.*mod((iTime+50.)/266.,TAU), u=-mouse.x;\n\t//float y =ss(.1,.12,.06) + ss(.35,.37,.06) + ss(.6,.62,.28) + ss(.8,.82,.31) + ss(.9,.92,.24) - ss(.94,1.,.95); y+=y/10.+.02*mouse.y;  // auto pan\n\t//float y = mouse.y*.7; if(y>.2) y+=.15; if(y>.53) y+=.17; if(y>.9) y+=.05; // skip past boring regions\n\tfloat y = mouse.y*.47+.05; if(y>.2) y+=.15; if(y>.57) {y=mouse.y*1.51-.48;} if(y>.9) y+=.05; // skip past boring regions\n    //float y = mouse.y*.06+.05; if(y>.08) y+=.34; // bird spotting regions\n\n    //vec3 p = vec3(0, 60.*y+4.,  -8.25*y-6.);\n\tfloat s=min(iTime,3.)/3.;\n\tvec3 p = vec3(0,50,-120)*(1.-s) + vec3(0, 60.*y+4., -8.25*y-6.)*s;\n\tfragColor = vec4(0,y*2.-1.3,y*2.-1.,1);\n\tfor (int i = 1; i < 160; i++) {\n\t\tvec3 d = p.z<-s*10.? vec3(1): map(p, u, v);\t\t\t\t\n\t\tif (d.x <= 0.001) {\n\t\t\tfragColor = length(p.xy)<8.5? \n\t\t\t\t\t(2.-s)*vec4( 1, 0,.5, 1) *abs(d.y)*12./float(i): \n\t\t\t\t\t(2.-s)*vec4( 15.,20.,abs(p.y/20.)*10.,1)/float(i);\t\t\t\n\t\t\tbreak;\n\t\t}\n\t\tp += rd * d.x;\n\t}\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3lKyzc.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 149, 185, 185, 518], [520, 520, 577, 577, 1695]]}
{"id": "3lKyzW", "name": "you are a rainbow", "author": "netgrind", "description": "you are a rainbow\n    yes it is true,\nplease let your light glow\n    make something new", "tags": ["rainbow"], "likes": 3, "viewed": 112, "published": "Public API", "date": "1610582801", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Fork of \"cosmos font smooth\" by netgrind. https://shadertoy.com/view/Xdjfzw\n// 2021-01-14 00:00:36\n\n#define line1 _ y_ o_ u_ _ a_ r_ e_ _ a_ crlf\n#define line2 _ _ r_ a_ i_ n_ b_ o_ w_\n\n// line function, used in k, s, v, w, x, y, z\nfloat line(vec2 p, vec2 a, vec2 b)\n{\n\tvec2 pa = p - a;\n\tvec2 ba = b - a;\n\tfloat h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\n    return length(pa - ba * h);\n}\n\nvec2 size = vec2(1., -1);\nvec2 edge = vec2(1, 0.);\nvec2 xLine = vec2(0., 0.);\n\nfloat circle(vec2 uv){\n\treturn abs(length(uv)-size.x);   \n}\nfloat circleS(vec2 uv){\n\treturn abs(length(uv)-size.x*.5);   \n}\n\nfloat vert(vec2 uv){\n\treturn length(vec2(uv.x,max(0.,abs(uv.y)-size.x)));   \n}\nfloat halfvert(vec2 uv){\n\treturn length(vec2(uv.x,max(0.,abs(uv.y)-size.x*.5)));   \n}\nfloat hori(vec2 uv){\n\treturn length(vec2(max(0.,abs(uv.x)-size.x),uv.y));   \n}\nfloat halfhori(vec2 uv){\n\treturn length(vec2(max(0.,abs(uv.x)-size.x*.5),uv.y));   \n}\nfloat diag(vec2 uv){\n\treturn length(vec2(max(0.,abs((uv.y-uv.x))-size.x*2.),uv.y+uv.x));   \n}\nfloat halfdiag(vec2 uv){\n\treturn length(vec2(max(0.,abs(uv.x-uv.y)-size.x),uv.y+uv.x));   \n}\n\n// Here is the alphabet\nfloat aa(vec2 uv) {\n    float x = circle(uv);\n    x = mix(x, min(vert(uv-edge), vert(uv+edge)), step(uv.y, 0.));\n    x = min(x, hori(uv-xLine));\n    return x;\n}\nfloat bb(vec2 uv) {\n    float x = vert(uv+edge);\n    x = min(x, hori(uv-edge.yx));\n    x = min(x, hori(uv+edge.yx));\n    x = min(x, hori(uv-xLine));\n    x = mix(min(circleS(uv-size.xx*.5),circleS(uv-size*.5)),x, step(uv.x, .5));\n    return x;\n}\nfloat cc(vec2 uv) {\n    float x = circle(uv);\n    float p = .8;\n    float a = atan(uv.x, abs(uv.y));\n    a = smoothstep(.7, 1.5707, a);\n   \tx += a;\n    uv.y = -abs(uv.y);\n    x = min(length(uv+size.x*vec2(-cos(p), sin(p))), x);\n    return x;\n}\nfloat dd(vec2 uv) {\n    float x = vert(uv+edge);\n    x = min(x, hori(uv+edge.yx));\n    x = min(x, hori(uv-edge.yx));\n    x = mix(circle(uv),x, step(uv.x, 0.));\n    return x;\n}\nfloat ee(vec2 uv) {\n    float x = cc(uv);\n    x = mix(circle(uv), x, step(uv.y, 0.));\n    x = min(x, hori(uv));\n    return x;\n}\nfloat ff(vec2 uv) {\n   \tfloat x = vert(uv+edge);\n    x = min(x, hori(uv-edge.yx));\n    x = mix(circle(uv), x, step(min(-uv.x, uv.y), 0.));\n    x = min(x, halfhori(uv+edge*.5));\n    return x;\n}\nfloat gg(vec2 uv) {\n    float x = cc(uv);\n    x = mix(x, circle(uv), step(uv.y, 0.));\n    x = min(x, halfhori(uv-edge*.5));\n    return x;\n}\nfloat hh(vec2 uv) {\n    float x = vert(abs(uv)-edge);\n    x = min(x, hori(uv));\n    //x = min(x, circle(uv+edge.yx));\n    //x = mix(x, min(length(uv-size.xy), length(uv-size.yy)), step(uv.y, size.y));\n    return x;\n}\nfloat ii(vec2 uv) {\n    return hh(uv.yx);\n}\nfloat jj(vec2 uv) {\n    float x = vert(uv-edge);\n    x = min(x, length(uv+edge));\n    x = mix(x, circle(uv), step(uv.y, 0.));\n    return x;\n}\nfloat kk(vec2 uv) {\n    uv.y = abs(uv.y);\n    float x = circle(uv-edge.yx);\n    x = mix( length(uv-size.xx),x,step(uv.y, size.x)); \n    x = mix(x,min(vert(uv+edge), hori(uv)), step(uv.x, 0.));\n    return x;\n}\nfloat ll(vec2 uv) {\n    return min(vert(uv+edge), hori(uv+edge.yx));\n}\nfloat mm(vec2 uv) {\n    uv.x = abs(uv.x);\n    float x = vert(uv-edge);\n    x = min(x, halfvert(uv-edge.yx*.5));\n    x = mix( circleS(uv-size.xx*.5),x, step(uv.y, 0.5));\n    return x;\n}\nfloat nn(vec2 uv) {\n    float x = circle(uv);\n    x = mix(min(vert(uv-edge), vert(uv+edge)), x, clamp(ceil(uv.y), 0., 1.));\n    return x;\n}\nfloat oo(vec2 uv) {\n    return circle(uv);\n}\nfloat pp(vec2 uv) {\n    float x = hori(uv);\n    x = min(x, hori(uv-edge.yx));\n    x = mix( circleS(uv+size.yy*.5),x, step(uv.x, size.x*.5));\n    x = min(x, vert(uv+edge));\n    return x;\n}\nfloat qq(vec2 uv) {\n    float x = circle(uv);\n    x = min(x, halfdiag(uv-size.xy*.5));\n    return x;\n}\nfloat rr(vec2 uv) {\n    float x = min(hori(uv-edge.yx), vert(uv+edge));\n    x = mix(x, circle(uv), step(0., min(-uv.x, uv.y)));\n    return x;\n}\nfloat ss(vec2 uv) {\n    float x = hori(uv-edge.yx);\n    x = min(x, halfhori(uv));\n    vec2 u = uv;\n    u+=vec2(-size.y*.5, size.y*.5);\n    x = mix(circleS(u),x, step(-edge.x*.5, uv.x));\n    \n    float x2 = hori(uv+edge.yx);\n    x2= min(x2, halfhori(uv));\n    u = uv;\n    u-=vec2(-size.y*.5, size.y*.5);\n    x2 = mix(x2,circleS(u),step(edge.x*.5, uv.x));\n    \n    return min(x,x2);\n}\nfloat tt(vec2 uv) {\n    /*float x = min(hori(uv+edge.yx), vert(uv+edge));\n    x = mix( circle(uv),x, step(0., max(uv.x, uv.y)));\n    x = min(halfhori(uv+edge*.5), x);*/\n    float x = min(vert(uv), hori(uv-edge.yx));\n    return x;\n}\nfloat uu(vec2 uv) {\n    uv.x = abs(uv.x);\n    float x = mix(circle(uv), vert(uv-edge),  step(0., uv.y));\n    return x;\n}\nfloat vv(vec2 uv) {\n    uv.x = abs(uv.x);\n    float p = .5;\n    uv *= mat2(cos(p), -sin(p), sin(p), cos(p));\n    float x = vert(uv-edge*.5);\n    return x;\n}\nfloat ww(vec2 uv) {\n    uv.y = -uv.y;\n    return mm(uv);\n}\nfloat xx(vec2 uv) {\n    return diag(abs(uv)*vec2(-1., 1.));\n}\nfloat yy(vec2 uv) {\n    uv.x = abs(uv.x);\n    float x = min(halfvert(uv+edge.yx*.5), circle(uv-edge.yx));\n    x = mix(x, length(uv-size.xx), step(size.x, uv.y));\n    return x;\n}\nfloat zz(vec2 uv) {\n    float x = min(hori(uv-edge.yx), hori(uv+edge.yx));\n    uv.x = -uv.x;\n    return min(x, diag(uv));\n}\n\n//Render char if it's up\n#define ch(l)  x=min(x,l(uv+vec2(spacing.x*nr, 0.)));nr-=size.x;\n\n//Make it a bit easier to type text\n#define a_ ch(aa);\n#define b_ ch(bb);\n#define c_ ch(cc);\n#define d_ ch(dd);\n#define e_ ch(ee);\n#define f_ ch(ff);\n#define g_ ch(gg);\n#define h_ ch(hh);\n#define i_ ch(ii);\n#define j_ ch(jj);\n#define k_ ch(kk);\n#define l_ ch(ll);\n#define m_ ch(mm);\n#define n_ ch(nn);\n#define o_ ch(oo);\n#define p_ ch(pp);\n#define q_ ch(qq);\n#define r_ ch(rr);\n#define s_ ch(ss);\n#define t_ ch(tt);\n#define u_ ch(uu);\n#define v_ ch(vv);\n#define w_ ch(ww);\n#define x_ ch(xx);\n#define y_ ch(yy);\n#define z_ ch(zz);\n\n//Space\n#define _ nr--;\n//Space\n#define _half nr-=.5;\n\n//Next line\n#define crlf uv.y += spacing.w; nr = 0.;\n\nvec4 spacing = vec4(3.33, 2., .25, 3.33);\n\nfloat field(vec2 uv){\n    float x = 100.;\n    float nr = 0.;\n    \n    line1;\n    line2;\n    return x;\n}\n\nvec2 fieldNormal(vec2 uv)\n{\n   const vec2 e = vec2(0.3,0.0);\n   return normalize(vec2(\n      field(uv + e.xy) - field(uv - e.xy),\n      field(uv + e.yx) - field(uv - e.yx) \n   ));\n}\n\n\n// Repeat around the origin by a fixed angle.\n// For easier use, num of repetitions is use to specify the angle.\nfloat pModPolar(inout vec2 p, float repetitions, float phase) {\n\tfloat angle = 2.*3.14159/repetitions;\n\tfloat a = atan(p.y, p.x) + angle/2.+phase/repetitions;\n\tfloat r = length(p);\n\tfloat c = floor(a/angle);\n\ta = mod(a,angle) - angle*.5;\n    a = abs(a);\n\tp = vec2(cos(a), sin(a))*r;\n\t// For an odd number of repetitions, fix cell index of the cell in -x direction\n\t// (cell index would be e.g. -5 and 5 in the two halves of the cell):\n\tif (abs(c) >= (repetitions/2.)) c = abs(c);\n\treturn c;\n}\n\nvec3 art(vec2 uv){\n    float aa = atan(uv.x, uv.y);\n\n    pModPolar(uv, 6., iTime);\n    uv.x = abs(mod(uv.x-iTime, 10.)-5.);\n    uv.y = abs(mod(uv.y+15., 30.)-15.);\n    \n    float a = atan(uv.x, uv.y);\nfloat d= length(uv)*.2;\nuv.x*=1.+sin(uv.x+a-d+iTime)*.1;\nuv.y*=1.+cos(uv.y+a+d+iTime)*.1;\n    float grid = smoothstep(.03, .5, abs(mod(a/3.1415*7., 2.)-1.));\n    grid += smoothstep(0., 1.,pow(mod(d, 1.), 3.));\n    vec3 c =vec3(mix(d, grid, smoothstep(.1, 1., d)));\n    c.rgb +=aa/3.1415;\n    return c;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    spacing.y = spacing.x*.5;\n    spacing.z = 1./spacing.x;\n    \n    float scale = 1.0;\n\tvec2 uv = ((fragCoord-0.5*iResolution.xy)/iResolution.xx)*40.;\n    \n    vec2 p = uv;\n    \n    uv.x*=1.+sin(uv.y*.2-iTime)*.05;\n    uv.y*=1.+cos(uv.x*.5+iTime)*.1;\n    uv.y+=cos(uv.x*.1-iTime);\n    \n    uv.x += 5.*spacing.x;\n    uv.y -= spacing.w*.5;\n    \n    float x = field(uv);\n    vec2 norm = fieldNormal(uv);\n    \n    float amp = pow(smoothstep(5., .5, x), .7);\n    vec3 c = art(p*(1. + iMouse.x/iResolution.x*10.)-norm*amp);\n    c = sin((vec3(0., .33, .66)+c+smoothstep(.5, .0, x)+smoothstep(.1, 2., x))*6.28+iTime)*.5+.5;\n   // c = mix(c, vec3(0.), smoothstep(.5, .4, x));\n   float v = smoothstep(.2, .3, x);\n\tc = mix( sin(vec3(0., .33, .66)*7.+p.x+p.y+iTime)*.3+.9, c*smoothstep(15., 5., x), v);\n    fragColor = vec4(c, 1.);//vec4(clamp(clr,0.0,1.0),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3lKyzW.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[189, 235, 271, 271, 396], [477, 477, 499, 499, 536], [537, 537, 560, 560, 600], [602, 602, 622, 622, 680], [681, 681, 705, 705, 766], [767, 767, 787, 787, 845], [846, 846, 870, 870, 931], [932, 932, 952, 952, 1025], [1026, 1026, 1050, 1050, 1118], [1120, 1144, 1163, 1163, 1304], [1305, 1305, 1324, 1324, 1549], [1550, 1550, 1569, 1569, 1793], [1794, 1794, 1813, 1813, 1969], [1970, 1970, 1989, 1989, 2097], [2098, 2098, 2117, 2117, 2290], [2291, 2291, 2310, 2310, 2430], [2431, 2431, 2450, 2450, 2647], [2648, 2648, 2667, 2667, 2691], [2692, 2692, 2711, 2711, 2833], [2834, 2834, 2853, 2853, 3042], [3043, 3043, 3062, 3062, 3113], [3114, 3114, 3133, 3133, 3298], [3299, 3299, 3318, 3318, 3438], [3439, 3439, 3458, 3458, 3483], [3484, 3484, 3503, 3503, 3671], [3672, 3672, 3691, 3691, 3774], [3775, 3775, 3794, 3794, 3918], [3919, 3919, 3938, 3938, 4301], [4302, 4302, 4321, 4470, 4533], [4534, 4534, 4553, 4553, 4654], [4655, 4655, 4674, 4674, 4811], [4812, 4812, 4831, 4831, 4870], [4871, 4871, 4890, 4890, 4932], [4933, 4933, 4952, 4952, 5110], [5111, 5111, 5130, 5130, 5234], [5913, 6010, 6031, 6031, 6113], [6115, 6115, 6142, 6142, 6296], [6299, 6412, 6475, 6475, 6904], [6906, 6906, 6924, 6924, 7410], [7412, 7412, 7469, 7469, 8323]]}
{"id": "3lSGzh", "name": "interp", "author": "theepicsnail", "description": "interp", "tags": ["interp"], "likes": 0, "viewed": 29, "published": "Public", "date": "1611965390", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI  3.141592\n#define TAU 6.283184\n\n\nvec2 cs(float a){\n    return vec2(cos(a),sin(a));\n}\n\nvec2 rot(vec2 v, float a) {\n    vec2 c = cs(a);\n    return v * mat2x2(c.x, -c.y, c.y, c.x);\n}\n\nvec2 sp(float t){\n    return vec2(floor(t), fract(t));\n}\n\nfloat rand(vec2 co){\n  return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n        \n\nvec2 pt(float i) {\n    return vec2(sin(i*i), cos(i*i));\n    //return normalize(vec2(rand(vec2(i   ,0)),rand(vec2(i   ,1))) * 2. - 1.);\n}\nvec2 interpolate(vec2 a, vec2 b, vec2 c, vec2 d, float t){\n    vec2 p0 = b;\n    vec2 m0 = (b-a)*2.;\n    vec2 p1 = c;\n    vec2 m1 = (c-b)*2.;\n    \n    float t2 = t*t;\n    float omt = 1.-t;\n    float omt2 = omt*omt;\n    float h00 = (1.+2.*t)*omt2;\n    float h10 = t*omt2;\n    float h01 = t2*(3.-2.*t);\n    float h11 = t2*(t-1.);\n    \n    return h00*p0 + h10*m0 + h01*p1 + h11*m1;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord*2.-iResolution.xy)/min(iResolution.y,iResolution.x)*2.;\n\n    \n    float i = floor(iTime*.3);\n    float j = fract(iTime*.3);\n    \n    \n    vec2 a = pt(i-1.); \n    vec2 b = pt(i); \n    vec2 c = pt(i+1.);\n    vec2 d = pt(i+2.);\n    float t = j;\n    vec2 p = interpolate(a,b,c,d,t);\n    \n    \n    c = interpolate(b,c,d,pt(i+3.), t);\n    b = interpolate(a,b,c,d, t);\n    \n    float dist = length(uv-p);\n    fragColor = vec4(1);\n    \n    if(length(uv-b)*2. < dist) {\n        dist = length(uv-b)*2.;\n        fragColor = vec4(1,0,0,0);\n    }\n    \n    if(length(uv-c) < dist) {\n        dist = length(uv-c);\n        fragColor = vec4(0,1,0,0);\n    }\n    \n    fragColor*= 1.0 - dist*10.;\n    //fragColor.gb = vec2(fragColor.r);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3lSGzh.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[44, 44, 61, 61, 95], [97, 97, 124, 124, 190], [192, 192, 209, 209, 248], [250, 250, 270, 270, 340], [351, 351, 369, 369, 487], [488, 488, 546, 546, 867], [868, 868, 925, 925, 1668]]}
{"id": "3ltcD2", "name": "Lava bubbles (QTA)", "author": "Dubko", "description": "Generated using QTA - try it on your own! - https://github.com/Romop5/QuantitizeThemAll", "tags": ["2d", "functionquantizing", "qta"], "likes": 0, "viewed": 50, "published": "Public", "date": "1609949584", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// https://romop5.github.io//QuantitizeThemAll/index.html?data=eyJwcm9ncmFtIjoiY29zKG1vZChtb2QobW9kKHQsMi44OSkrc2luKHQpK21vZChjb3MoeCtjb3MoY29zKDkuMDMpKSttb2QoNS45NywxNy40MSkrc2luKHQreCkpLDguNjMpLDExLjU1KSt5LDIuNjcpKSIsInRyYW5zZm9ybWF0aW9uVHlwZSI6ImNpcmNsZSIsInN0YXJ0Q29sb3IiOiIjMDAwMDAwIiwiZW5kQ29sb3IiOiIjZmYzMzAwIiwib2Zmc2V0WCI6IjAiLCJvZmZzZXRZIjoiMCIsInpvb20iOiI1IiwiZm9jYWwiOiIxIiwiaGFzQ29sb3JUaHJlc2hvbGQiOmZhbHNlLCJjb2xvclRocmVzaG9sZCI6IjAuNSJ9\n\n/*\n * Generated while using QuantizeThemAll\n * Try it yourself: https://romop5.github.io/QuantitizeThemAll/\n * You can also use https://github.com/danilw/shadertoy-to-video-with-FBO to render this shader.\n */\n   vec2 linear(vec2 uv)\n   {\n        return uv; \n   }\n\n   vec2 circle(vec2 uv)\n   {\n        vec2 nuv = normalize(uv);\n        float dist = 1.0/length(uv);\n        return nuv*dist;\n   }\n   vec2 polar(vec2 uv)\n   {\n        return vec2(atan(uv.x,uv.y),sqrt(uv.x*uv.x+ uv.y*uv.y));  \n   }\n   vec2 spherical(vec2 uv)\n   {\n        vec2 direction = uv;\n        float len = length(uv);\n        return vec2(exp(len))*direction;\n   }\n   vec2 fisheye(vec2 uv)\n   {\n        float f = 1.0000;\n        // Calculate angle from plane's UV\n        vec2 angles = atan(uv, vec2(1.0));\n        //return angles*f;\n        return vec2(2.0)*sin(angles*vec2(0.5))*vec2(f);\n   }\n\n   float inv(float x)\n   {\n    return 1.0/x;\n   }\n\n\n\n   void mainImage(out vec4 fragColor, in vec2 fragCoord) {\n       vec2 uv = fragCoord/iResolution.xy;\n       uv *= 2.0;\n       uv += -1.0;\n       float t = iTime*1.0000;\n       vec2 resultingUv = circle(vec2(uv.x, uv.y)*vec2(5.0000));\n       float x = resultingUv.x + 0.0000;\n       float y = resultingUv.y + 0.0000;\n       float program = cos(mod(mod(mod(t,2.89)+sin(t)+mod(cos(x+cos(cos(9.03))+mod(5.97,17.41)+sin(t+x)),8.63),11.55)+y,2.67));\n       float parameter = clamp(program, 0.0,1.0);\n\n       vec3 colorStart = vec3(0,0,0)/255.0;\n       vec3 colorEnd = vec3(255,51,0)/255.0;\n       vec3 resultColor = mix(colorStart, colorEnd, parameter);\n\n       bool hasColorThreshold = false;\n       if(hasColorThreshold)\n       {\n          resultColor = (parameter > 0.5000)?colorStart:colorEnd;  \n       }\n       fragColor = vec4(resultColor, 1.0);\n   }\n   ", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3ltcD2.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[453, 665, 690, 690, 715], [720, 720, 745, 745, 846], [850, 850, 874, 874, 946], [950, 950, 978, 978, 1085], [1089, 1089, 1115, 1115, 1315], [1320, 1320, 1343, 1343, 1366], [1373, 1373, 1428, 1428, 2221]]}
{"id": "3ltczj", "name": "3D Map (No Polar Distortions)", "author": "oneshade", "description": "3D version of my \"Infinite Map\"  shader (without polar distortions!).", "tags": ["procedural", "3d", "map", "fractalnoise", "geography"], "likes": 11, "viewed": 145, "published": "Public", "date": "1609519258", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PLANET_RADIUS 1.5\n#define MAP_SCALE 2.0\n#define MAP_ROUGHNESS 5.0\n#define MAP_HEIGHT 0.2\n#define MARKER_SPACING 0.75\n\nvec3 Hash33(in vec3 p) {\n    return vec3(fract(sin(dot(p, vec3(7643.54, 6854.95, 356.6765))) * 234.752),\n                fract(sin(dot(p, vec3(7853.67, 5214.327, 435.6437))) * 6734.8275),\n                fract(sin(dot(p, vec3(7546.754, 683.2647, 358.2431))) * 257.8643));\n}\n\nfloat noise(in vec3 p) {\n    return fract(sin(dot(p, vec3(3743.54, 2754.23, 578.537))) * 5664.865);\n}\n\nfloat snoise(in vec3 p) {\n    vec3 cell = floor(p);\n    vec3 local = fract(p);\n    local *= local * (3.0 - 2.0 * local);\n\n    float ldb = noise(cell);\n    float rdb = noise(cell + vec3(1.0, 0.0, 0.0));\n    float ldf = noise(cell + vec3(0.0, 0.0, 1.0));\n    float rdf = noise(cell + vec3(1.0, 0.0, 1.0));\n    float lub = noise(cell + vec3(0.0, 1.0, 0.0));\n    float rub = noise(cell + vec3(1.0, 1.0, 0.0));\n    float luf = noise(cell + vec3(0.0, 1.0, 1.0));\n    float ruf = noise(cell + 1.0);\n\n    return mix(mix(mix(ldb, rdb, local.x),\n                   mix(lub, rub, local.x),\n                   local.y),\n\n               mix(mix(ldf, rdf, local.x),\n                   mix(luf, ruf, local.x),\n                   local.y),\n\n               local.z);\n}\n\nfloat fnoise(in vec3 p) {\n    p *= MAP_SCALE;\n\n    float value = 0.0;\n    float nscale = 1.0;\n    float tscale = 0.0;\n\n    for (float octave=0.0; octave < MAP_ROUGHNESS; octave++) {\n        value += snoise(p) * nscale;\n        tscale += nscale;\n        nscale *= 0.5;\n        p *= 2.0;\n    }\n\n    return value / tscale;\n}\n\nvec3 map(in vec3 p) {\n    float n = fnoise(p);\n    vec3 color = mix(vec3(0.0, 0.0, 1.25 - n), mix(vec3(0.0, 1.0, 0.0), vec3(0.8, 0.4, 0.0), n * n), float(n > 0.5));\n\n    vec3 pinPos = floor(p / MARKER_SPACING + 0.5) * MARKER_SPACING;\n    pinPos += 0.45 * Hash33(pinPos) - 0.225;\n    pinPos = normalize(pinPos) * (PLANET_RADIUS + fnoise(p) * MAP_HEIGHT);\n    float pin = length(p - pinPos) - 0.05;\n    n = fnoise(pinPos);\n    if (n > 0.5 && pin < 0.0) {\n        color = vec3(1.0, 0.0, 0.0);\n    }\n\n    return color;\n}\n\nfloat mapScene(in vec3 p) {\n    float earth = length(p) - PLANET_RADIUS;\n    earth -= fnoise(p) * MAP_HEIGHT;\n    return earth * 0.98;\n}\n\nvec3 getNormal(in vec3 p) {\n    return normalize(vec3(mapScene(p + vec3(0.001, 0.0, 0.0)) - mapScene(p - vec3(0.001, 0.0, 0.0)),\n                          mapScene(p + vec3(0.0, 0.001, 0.0)) - mapScene(p - vec3(0.0, 0.001, 0.0)),\n                          mapScene(p + vec3(0.0, 0.0, 0.001)) - mapScene(p - vec3(0.0, 0.0, 0.001))));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n    fragColor = vec4(0.0, 0.0, 0.0, 1.0);\n\n    vec3 ro = vec3(0.0, 0.0, 5.0);\n    vec3 rd = normalize(vec3(uv, -1.0));\n\n    float t = 0.0;\n    for (float iters=0.0; iters < 150.0; iters++) {\n        vec3 p = ro + rd * t;\n\n        vec2 cs = sin(iTime + vec2(1.57, 0.0));\n        p.xz *= mat2(cs, -cs.y, cs.x);\n        p.yz *= mat2(cs, -cs.y, cs.x);\n\n        float d = mapScene(p);\n        if (d < 0.001) {\n            vec3 n = getNormal(p);\n            vec3 l = vec3(-0.58, 0.58, 0.58);\n\n            n.yz *= mat2(cs.x, -cs.y, cs.yx);\n            n.xz *= mat2(cs.x, -cs.y, cs.yx);\n\n            fragColor.rgb += map(p);\n            fragColor.rgb *= max(0.3, dot(n, l));\n            break;\n        }\n\n        if (t > 10.0) {\n            break;\n        }\n\n        t += d;\n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3ltczj.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[126, 126, 150, 150, 399], [401, 401, 425, 425, 502], [504, 504, 529, 529, 1255], [1257, 1257, 1282, 1282, 1578], [1580, 1580, 1601, 1601, 2096], [2098, 2098, 2125, 2125, 2234], [2236, 2236, 2263, 2263, 2570], [2572, 2572, 2627, 2627, 3468]]}
{"id": "3ltyzf", "name": "Genuary2021 1 TRIPLE NESTED LOOP", "author": "qw", "description": "Entry for Day 1 of #Genuary2021 - see https://genuary2021.github.io/\nPrompt of the day: Triple nested loop... Quite literal interpretation clearly :)\n", "tags": ["loop", "genuary2021", "genuary"], "likes": 3, "viewed": 38, "published": "Public", "date": "1609630270", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Start-of point, using: \n//\n//\n//\"RayMarching starting point\" \n// by Martijn Steinrucken aka The Art of Code/BigWings - 2020\n// The MIT License\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n// Email: countfrolic@gmail.com\n// Twitter: @The_ArtOfCode\n// YouTube: youtube.com/TheArtOfCodeIsCool\n// Facebook: https://www.facebook.com/groups/theartofcode/\n//\n// You can use this shader as a template for ray marching shaders\n\n#define MAX_STEPS 100\n#define MAX_DIST 100.\n#define SURF_DIST .001\n\n#define S smoothstep\n#define T iTime\n\nmat2 Rot(float a) {\n    float s=sin(a), c=cos(a);\n    return mat2(c, -s, s, c);\n}\n\nfloat Hash21(vec2 p) {\n    p = fract(p*vec2(123.34,233.53));\n    p += dot(p, p+23.234);\n    return fract(p.x*p.y);\n}\n\nfloat sdBox(vec3 p, vec3 s) {\n    p = abs(p)-s;\n\treturn length(max(p, 0.))+min(max(p.x, max(p.y, p.z)), 0.);\n}\n\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\nfloat GetDist(vec3 p) {\n    float d;\n    \n    float torusWidth = .1;\n    \n    float torus1 = sdTorus(p, vec2(1.5,torusWidth * 3.));\n    vec3 torus2Pos = p;\n    torus2Pos.xz *= Rot(iTime * 2.);\n    torus2Pos += vec3(0.,0.,1.5);\n    torus2Pos.yz *= Rot(1.57);\n    torus2Pos.xy *= Rot(1.57);\n    float torus2 = sdTorus(torus2Pos, vec2(.8,torusWidth * 2.));\n    \n    vec3 torus3Pos = torus2Pos;\n    torus3Pos.xz *= Rot(3.+iTime * 2.);\n    torus3Pos.xy *= Rot(1.57);\n    torus3Pos += vec3(0.,0.,.8);\n    \n    float torus3 = sdTorus(torus3Pos, vec2(.4, torusWidth));\n    d = min( torus1, min(torus2,torus3));\n    return d;\n}\n\nfloat RayMarch(vec3 ro, vec3 rd) {\n\tfloat dO=0.;\n    \n    for(int i=0; i<MAX_STEPS; i++) {\n    \tvec3 p = ro + rd*dO;\n        float dS = GetDist(p);\n        dO += dS;\n        if(dO>MAX_DIST || abs(dS)<SURF_DIST) break;\n    }\n    \n    return dO;\n}\n\nvec3 GetNormal(vec3 p) {\n\tfloat d = GetDist(p);\n    vec2 e = vec2(.001, 0);\n    \n    vec3 n = d - vec3(\n        GetDist(p-e.xyy),\n        GetDist(p-e.yxy),\n        GetDist(p-e.yyx));\n    \n    return normalize(n);\n}\n\nvec3 GetRayDir(vec2 uv, vec3 p, vec3 l, float z) {\n    vec3 f = normalize(l-p),\n        r = normalize(cross(vec3(0,1,0), f)),\n        u = cross(f,r),\n        c = f*z,\n        i = c + uv.x*r + uv.y*u,\n        d = normalize(i);\n    return d;\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\tvec2 m = iMouse.xy/iResolution.xy;\n    \n    vec3 col = vec3(0);\n    \n    vec3 ro = vec3(0, 3, -6);\n    ro.yz *= Rot(-m.y*3.14+1.);\n    ro.xz *= Rot(-m.x*6.2831);\n    \n    vec3 rd = GetRayDir(uv, ro, vec3(0), 1.);\n\n    float d = RayMarch(ro, rd);\n    \n    if(d<MAX_DIST) {\n    \tvec3 p = ro + rd * d;\n    \tvec3 n = GetNormal(p);\n        \n    \tfloat dif = dot(n, normalize(vec3(1,2,3)))*.5+.5;\n    \tcol += dif;  \n        col = pow(col, vec3(.4545));\t// gamma correction\n    \n    }else{\n        //Background\n        float yCoord = fragCoord.y / iResolution.y; \n        vec3 colTop = vec3(0.678, 0.937, 0.819);\n        vec3 colBottom = vec3(0, 0.125, 0.247);\n        col = mix( colBottom, colTop, smoothstep(0.1,0.9, yCoord));\n        \n    }\n    \n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3ltyzf.jpg", "access": "shaders20k", "license": "mit", "functions": [[0, 1507, 1526, 1526, 1588], [1590, 1590, 1612, 1612, 1706], [1708, 1708, 1737, 1737, 1818], [1820, 1820, 1853, 1853, 1918], [1920, 1920, 1943, 1943, 2538], [2540, 2540, 2574, 2574, 2785], [2787, 2787, 2811, 2811, 3001], [3003, 3003, 3053, 3053, 3244], [3248, 3248, 3305, 3305, 4145]]}
{"id": "3lVcDR", "name": "Clean Spiral Distance", "author": "nr4", "description": "Spiral distance function with correct behavior for angles greater than pi", "tags": ["sdf", "spiral", "distance", "logarithmic"], "likes": 4, "viewed": 88, "published": "Public", "date": "1610821763", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/*\n * Clean Spiral Distance\n * \n * Copyright (C) 2021  Alexander Kraus <nr4@z10.info>\n * \n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n * \n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n * \n * You should have received a copy of the GNU General Public License\n * along with this program.  If not, see <http://www.gnu.org/licenses/>.\n */\n\nconst vec3 c = vec3(1.,0.,-1.);\nconst float pi = acos(-1.);\n\nfloat m(in vec2 x)\n{\n    //return max(abs(x.x), abs(x.y)); // rotated square spiral\n    //return abs(x.x)+abs(x.y); // square spiral\n    return length(x); // spiral\n    //return .5*((abs(x.x)+abs(x.y)+min(abs(x.x),abs(x.y)))); // 4-star\n    //return .5*((abs(x.x)+abs(x.y)+max(abs(x.x),abs(x.y)))); // octagon\n}\n\n// Distance to spiral\nfloat spiral(in vec2 x, in float k)\n{\n    float tau = 2.*pi;\n    vec2 dpr = mod(vec2(atan(x.y,x.x),m(x)/k),tau);\n    float a = abs(dpr.y-dpr.x);\n    return k*min(a,tau-a);\n}\n\nfloat sm(in float d)\n{\n    return smoothstep(1.5/iResolution.y, -1.5/iResolution.y, d);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Ignore the drawing code, it's messy, I know :)\n    vec2 uv = (fragCoord.xy-.5*iResolution.xy)/iResolution.y;\n\tfloat d = spiral(uv, mix(.004,.1,.5+.5*sin(iTime)));\n    d = abs(d)-.0025;\n    float interval = clamp(.2 * (d-mod(d,.025))/.025, 0., 1.);\n    vec3 col = mix(vec3(1.00,0.90,0.68), vec3(0.98,0.64,0.67), 2.*interval);\n    if(interval > .5) col = mix(col, vec3(0.54,0.80,0.80), 2.*(interval-.5));\n    col = mix(col, c.yyy, sm(d));\n    col = mix(col, .4*c.xxx, sm(abs(mod(d+.0125,.025)-.0125)-.001));\n    fragColor = vec4(col,1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3lVcDR.jpg", "access": "shaders20k", "license": "gpl-3.0-plus", "functions": [[0, 804, 824, 936, 1115], [1117, 1139, 1176, 1176, 1312], [1314, 1314, 1336, 1336, 1403], [1405, 1405, 1462, 1516, 2008]]}
{"id": "3lVczV", "name": "Metal Kaleidoscope", "author": "mrange", "description": "Licence CC0: Metal Kaleidoscope\nExperimenting with truchet, FBM, smooth kaleidoscope and metal like lighting\n", "tags": ["2d", "fbm", "kaleidoscope"], "likes": 10, "viewed": 303, "published": "Public API", "date": "1611353252", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Licence CC0: Metal Kaleidoscope\n// Experimenting with truchet, FBM, smooth kaleidoscope and metal like lighting\n\n// SABS        from: ollj (shadertoy) (SABS is a really great tool)\n// hsv2rgb     from: https://stackoverflow.com/questions/15095909/from-rgb-to-hsv-in-opengl-glsl\n// modMirror1  from: http://mercury.sexy/hg_sdf/\n// pmin        from: iq (shadertoy)\n// tanh_approx from: some math site, don't remember\n\n// fbm described by iq here: https://www.iquilezles.org/www/articles/fbm/fbm.htm\n\n#define PI              3.141592654\n#define TAU             (2.0*PI)\n#define TIME            iTime\n#define RESOLUTION      iResolution\n \n#define LESS(a,b,c)     mix(a,b,step(0.,c))\n#define SABS(x,k)       LESS((.5/(k))*(x)*(x)+(k)*.5,abs(x),abs(x)-(k))\n#define ROT(a)          mat2(cos(a), sin(a), -sin(a), cos(a))\n\n#define PERIOD          30.0\n#define NPERIOD         floor(TIME/PERIOD)\n#define TIMEINPERIOD    mod(TIME, PERIOD)\n#define FADE            1.0\n\nconst float  truchet_lw = 0.05;\nconst mat2[] truchet_rots = mat2[](ROT(0.0*PI/2.0), ROT(1.00*PI/2.0), ROT(2.0*PI/2.0), ROT(3.0*PI/2.0));\n\nfloat l2(vec2 p){\n  return dot(p, p);\n}\n\nvec3 hsv2rgb(vec3 c) {\n  const vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n  vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n  return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nfloat tanh_approx(float x) {\n//  return tanh(x);\n  float x2 = x*x;\n  return clamp(x*(27.0 + x2)/(27.0+9.0*x2), -1.0, 1.0);\n}\n\nfloat circle(vec2 p, float r) {\n  return length(p) - r;\n}\n\nfloat hash(float co) {\n  co += 100.0;\n  return fract(sin(co*12.9898) * 13758.5453);\n}\n\nfloat hash(vec3 co) {\n  co += 100.0;\n  return fract(sin(dot(co, vec3(12.9898,58.233, 12.9898+58.233))) * 13758.5453);\n}\n\nvec2 toPolar(vec2 p) {\n  return vec2(length(p), atan(p.y, p.x));\n}\n\nvec2 toRect(vec2 p) {\n  return vec2(p.x*cos(p.y), p.x*sin(p.y));\n}\n\nvec2 mod2_1(inout vec2 p) {\n  vec2 c = floor(p + 0.5);\n  p = fract(p + 0.5) - 0.5;\n  return c;\n}\n\nfloat modMirror1(inout float p, float size) {\n  float halfsize = size*0.5;\n  float c = floor((p + halfsize)/size);\n  p = mod(p + halfsize,size) - halfsize;\n  p *= mod(c, 2.0)*2.0 - 1.0;\n  return c;\n}\n\nfloat smoothKaleidoscope(inout vec2 p, float sm, float rep) {\n  vec2 hp = p;\n\n  vec2 hpp = toPolar(hp);\n  const float ts = 2.5;\n  hpp.x = tanh_approx(hpp.x/ts)*ts;\n  float rn = modMirror1(hpp.y, TAU/rep);\n\n  float sa = PI/rep - SABS(PI/rep - abs(hpp.y), sm);\n  hpp.y = sign(hpp.y)*(sa);\n\n  hp = toRect(hpp);\n\n  p = hp;\n\n  return rn;\n}\n\nfloat pmin(float a, float b, float k) {\n  float h = clamp(0.5+0.5*(b-a)/k, 0.0, 1.0);\n  return mix(b, a, h) - k*h*(1.0-h);\n}\n\nfloat pmax(float a, float b, float k) {\n  return -pmin(-a, -b, k);\n}\n\nfloat truchet_cell0(vec2 p) {\n  float d0  = circle(p-vec2(0.5), 0.5);\n  float d1  = circle(p+vec2(0.5), 0.5);\n\n  float d = 1E6;\n  d = min(d, d0);\n  d = min(d, d1);\n  return d;\n}\n\nfloat truchet_cell1(vec2 p) {\n  float d0  = abs(p.x);\n  float d1  = abs(p.y);\n  float d2 = circle(p, 0.25);\n\n  float d = 1E6;\n  d = min(d, d0);\n  d = min(d, d1);\n  d = min(d, d2);\n  return d;\n}\n\nvec2 truchet(vec2 p, float h, out vec3 n) {\n  float hd = circle(p, 0.4);\n\n  vec2 hp = p;\n  float rep = 2.0*floor(mix(5.0, 25.0, fract(h*13.0)));\n  float sm = mix(0.05, 0.125, fract(h*17.0))*24.0/rep;\n  float kn = 0.0;\n  kn = smoothKaleidoscope(hp, sm, rep);\n  hp *= ROT(0.02*TIME);\n  hp += TIME*0.05;\n  vec2 hn = mod2_1(hp);\n  float r = hash(vec3(hn, h));\n  hp *= truchet_rots[int(r*4.0)];\n\n  float cd0 = truchet_cell0(hp);\n  float cd1 = truchet_cell1(hp);\n  float d0 = mix(cd0, cd1, (fract(r*13.0) > 0.5));\n\n  float d = 1E6;\n  d = min(d, d0);\n  d = abs(d) - truchet_lw;\n\n  n = vec3(hn, kn);\n\n  return vec2(hd, d);\n}\n\nfloat df(vec2 p, float h, out vec3 n) {\n  vec2 d = truchet(p, h, n); \n  return d.y;\n}\n\nfloat hf(vec2 p, float h) {\n  vec3 n;\n  float decay = 0.75/(1.0+0.125*l2(p));\n  float d = df(p, h, n);\n  const float ww = 0.085;\n  float height = smoothstep(0.0, ww, d);\n  return pmax(2.0*height*decay, 0.5, 0.25);\n}\n\nfloat fbm(vec2 p, float h) {\n  const float aa = -0.45;\n  const mat2  pp = 2.03*ROT(1.0);\n\n  float a = 1.0;\n  float d = 0.0;\n  float height = 0.0;\n  \n  for (int i = 0; i < 4; ++i) {\n    height += a*hf(p, h);\n    d += a;\n    a *= aa;\n    p *= pp;\n  }\n  \n  return height/d;\n}\n\nfloat height(vec2 p) {\n  p.x = SABS(p.x, 0.1*abs(p.y)+0.001);\n  float h = hash(NPERIOD);\n  float tp = TIMEINPERIOD/PERIOD;\n  p*=ROT(TIMEINPERIOD*0.075);\n//  p*=ROT(-pow(l2(p), mix(0.25, 0.75, h)));\n  p*=ROT(-PI*tanh_approx(0.125*(l2(p)-0.25)));\n  \n  p*=mix(1.5, 2.5, mix(tp, 1.0-tp, h));\n  return fbm(p, h);\n}\n\nvec3 normal(vec2 p) {\n  vec2 eps = vec2(4.0/RESOLUTION.y, 0.0);\n  \n  vec3 n;\n  \n  n.x = height(p - eps.xy) - height(p + eps.xy);\n  n.y = 2.0*eps.x;\n  n.z = height(p - eps.yx) - height(p + eps.yx);\n  \n  return normalize(n);\n}\n\nvec3 postProcess(vec3 col, vec2 q)  {\n  col=pow(clamp(col,0.0,1.0),vec3(1.0/2.2)); \n  col=col*0.6+0.4*col*col*(3.0-2.0*col);  // contrast\n  col=mix(col, vec3(dot(col, vec3(0.33))), -0.4);  // saturation\n  col*=0.5+0.5*pow(19.0*q.x*q.y*(1.0-q.x)*(1.0-q.y),0.7);  // vigneting\n  return col;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  vec2 q = fragCoord/RESOLUTION.xy;\n  vec2 p = -1. + 2. * q;\n  p.x *= RESOLUTION.x/RESOLUTION.y;\n\n  float aa = 2.0/RESOLUTION.y;\n\n  vec3 ld1 = normalize(vec3(1.0, 1.0, 1.0));\n  vec3 ld2 = normalize(vec3(-1.0, 0.75, 1.0));\n  vec3 e  = vec3(p.x, -1.0, p.y);\n\n  float l = length(p);\n  \n  float h = height(p);\n  vec3  n = normal(p);\n\n  vec3 hsv = vec3(mix(0.6, 0.9, 0.5+ 0.5*sin(TIME*0.1-10.0*h*l+(p.x+p.y))), tanh_approx(0.5*h), tanh_approx(10.0*l*h+.1));\n  hsv.yz = clamp(hsv.yz, 0.0, 1.0);\n  vec3 baseCol1 = hsv2rgb(hsv);\n  vec3 baseCol2 = sqrt(baseCol1.zyx);\n \n  float diff1 = max(dot(n, ld1), 0.0);\n  float diff2 = max(dot(n, ld2), 0.0);\n\n  vec3 col = vec3(0.0);\n  const float basePow = 1.5;\n  col += 1.00*baseCol1*pow(diff1, 16.0*basePow);\n  col += 0.10*baseCol1*pow(diff1, 04.0*basePow);\n  col += 0.15*baseCol2*pow(diff2, 08.0*basePow);\n  col += 0.02*baseCol2*pow(diff2, 02.0*basePow);\n  \n  col *= 8.0;\n//  col = tanh(8.0*col);\n  col = postProcess(col, q);\n  \n  float fadeIn  = smoothstep(0.0, FADE, TIMEINPERIOD);\n  float fadeOut = 1.0-smoothstep(PERIOD-FADE, PERIOD, TIMEINPERIOD);\n  col = mix(vec3(0.0), col, fadeIn*fadeIn*fadeOut*fadeOut);\n  fragColor = vec4(col, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3lVczV.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[419, 1098, 1115, 1115, 1137], [1139, 1139, 1161, 1161, 1330], [1332, 1332, 1360, 1380, 1456], [1458, 1458, 1489, 1489, 1515], [1517, 1517, 1539, 1539, 1602], [1604, 1604, 1625, 1625, 1723], [1725, 1725, 1747, 1747, 1791], [1793, 1793, 1814, 1814, 1859], [1861, 1861, 1888, 1888, 1957], [1959, 1959, 2004, 2004, 2158], [2160, 2160, 2221, 2221, 2494], [2496, 2496, 2535, 2535, 2620], [2622, 2622, 2661, 2661, 2690], [2692, 2692, 2721, 2721, 2869], [2871, 2871, 2900, 2900, 3064], [3066, 3066, 3109, 3109, 3682], [3684, 3684, 3723, 3723, 3769], [3771, 3771, 3798, 3798, 3986], [3988, 3988, 4016, 4016, 4260], [4262, 4262, 4284, 4284, 4571], [4573, 4573, 4594, 4594, 4797], [4799, 4799, 4836, 4836, 5089], [5091, 5091, 5146, 5146, 6325]]}
{"id": "3lVyRd", "name": "Bad Perlin Noise - Andrew", "author": "andrew741", "description": "A blocky version of perlin noise. Used three different layers of it for the rgb values. Each of the layers is a layer of fractal noise (noise in a fractal pattern made with layers of perlin noise with decreasing scale and amplitude)", "tags": ["perlinnoise"], "likes": 1, "viewed": 46, "published": "Public", "date": "1611601392", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/*\n\nBest when vewing in full screen\n\n*/\n\nfloat seed = 2.;  // the seed for the perlin noise\n\n// changes the range of a number\nfloat map(float val, float cMin, float cMax, float nMin, float nMax)\n{\n    float nVal = val - cMin;\n    nVal *= (nMax - nMin) / (cMax - cMin);\n    nVal += nMin;\n    return nVal;\n}\n\n// a persuado random number generator (not my own generator)\nfloat rand(vec2 co)\n{\n    return fract(sin(dot(round(co.xy) ,vec2(12.,78.))) * 43758.);\n}\n\n// a random range number generator\nfloat randRange(vec2 co, float Min, float Max)\n{\n    return map(rand(co), 0., 1., Min, Max);\n}\n\n// a working smoothstep\nfloat Smoothstep(float x)\n{\n    float k = clamp(x, 0., 1.);\n    return k*k*(3. - 2. * k);\n}\n\n// a 2D perlin noise\nfloat perlin2D(float scale, vec2 p)\n{\n    vec2 np = p / scale;\n    vec2 offset = fract(np);\n    \n    float lu = randRange(vec2(floor(np.x), ceil(np.y)), 0., 1.);\n    float ru = randRange(vec2(ceil (np.x), ceil(np.y)), 0., 1.);\n    float ld = randRange(vec2(floor(np.x), floor (np.y)), 0., 1.);\n    float rd = randRange(vec2(ceil (np.x), floor (np.y)), 0., 1.);\n    \n    return mix(mix(ld, lu, Smoothstep(offset.y)), mix(rd, ru, Smoothstep(offset.y)), Smoothstep(offset.x));\n}\n\n// main loop\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // non-streched uv coordinates\n    vec2 uv = fragCoord/iResolution.y * 2. - 1.;\n\n    // sample position for perlin noise\n    vec2 p = fragCoord + seed * 100000. + round(vec2(iTime * 450., -iTime * 150. + sin(iTime) * 400.) + iMouse.xy);\n    \n    // the r layer of fractal noise (stacked layers of decreasing amplitude and scale perlin noise)\n    float noise1 = 0.;\n    noise1 += perlin2D(200., p         )     ;\n    noise1 += perlin2D(100., p + 500.  ) / 2.;\n    noise1 += perlin2D(50. , p + 1000. ) / 4.;\n    noise1 = map(noise1, 0., 1.75, 0., 1.);\n    \n    // the g layer of fractal noise\n    float noise2 = 0.;\n    noise2 += perlin2D(200., p + 1500. )     ;\n    noise2 += perlin2D(100., p + 2000. ) / 2.;\n    noise2 += perlin2D(50. , p + 2500. ) / 4.;\n    noise2 = map(noise2, 0., 1.75, 0., 1.);\n    \n    // the b layer of fractal noise\n    float noise3 = 0.;\n    noise3 += perlin2D(200., p + 3000. )     ;\n    noise3 += perlin2D(100., p + 3500. ) / 2.;\n    noise3 += perlin2D(50. , p + 4000. ) / 4.;\n    noise3 = map(noise3, 0., 1.75, 0., 1.);\n    \n    // combining the three (rgb) layers of noise\n    vec3 col = vec3(noise1, noise2, noise3);\n\n    // outputing the final color\n    fragColor = vec4(col,1.0);\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3lVyRd.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[93, 126, 196, 196, 305], [307, 368, 389, 389, 457], [459, 494, 542, 542, 588], [590, 614, 641, 641, 705], [707, 728, 765, 765, 1203], [1205, 1218, 1275, 1310, 2493]]}
{"id": "3lVyRW", "name": "marmotte-2", "author": "electrautistic", "description": "fork original :  gleurop ", "tags": ["marmotte2"], "likes": 1, "viewed": 50, "published": "Public", "date": "1610576936", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const int MAX_ITER = 59; // Try 30 for extra flames\n\nvec2 rotate(in vec2 v, in float a) {\n\treturn vec2(cos(a)*v.x + sin(a)*v.y, -sin(a)*v.x + cos(a)*v.y);\n}\n\n\nfloat trap(in vec3 p)\n{\n    return 0.0;\n}\n\nfloat map(in vec3 p)\n{\n    float time = iTime+60.0;\n\tfloat cutout = dot(abs(p.yz),vec2(0.5))-0.035;\n\tfloat road = max(abs(p.y-0.025), abs(p.z)-0.035);\n\t\n\tvec3 z = abs(1.0-mod(p,2.0));\n\tz.yz = rotate(z.yz, time*0.05);\n\n\tfloat d = 999.0;\n\tfloat s = 1.0;\n\tfor (float i = 0.0; i < 3.0; i++) {\n\t\tz.xz = rotate(z.xz, radians(i*10.0+time));\n\t\tz.zy = rotate(z.yz, radians((i+1.0)*20.0+time*1.1234));\n\t\tz = abs(1.0-mod(z+i/3.0,2.0));\n\t\t\n\t\tz = z*2.0 - 0.3;\n\t\ts *= 0.5;\n\t\td = min(d, trap(z) * s);\n\t}\n\treturn min(max(d, -cutout), road);\n}\n\nvec3 hsv(in float h, in float s, in float v) {\n\treturn mix(vec3(1.0), clamp((abs(fract(h + vec3(3, 2, 1) / 3.0) * 6.0 - 3.0) - 1.0), 0.0 , 1.0), s) * v;\n}\n\nvec3 intersect(in vec3 rayOrigin, in vec3 rayDir)\n{\n    float time = iTime+60.0;\n\tfloat total_dist = 0.0;\n\tvec3 p = rayOrigin;\n\tfloat d = 1.0;\n\tfloat iter = 0.0;\n\t//\n    float mind = 3.14159+sin(time*0.0)*0.2; // Move road from side to side slowly\n\t\n\tfor (int i = 0; i < MAX_ITER; i++)\n\t{\t\t\n\t\tif (d < 0.001) continue;\n\t\t\n\t\td = map(p);\n\t\t// This rotation causes the occasional distortion - like you would see from heat waves\n\t\tp += d*vec3(rayDir.x, rotate(rayDir.yz, sin(mind)));\n\t\tmind = min(mind, d);\n\t\ttotal_dist += d;\n\t\titer++;\n\t}\n\n\tvec3 color = vec3(0.0);\n\tif (d < 0.001) {\n\t\tfloat x = (iter/float(MAX_ITER));\n\t\tfloat y = (d-0.01)/0.01/(float(MAX_ITER));\n\t\tfloat z = (0.01-d)/0.01/float(MAX_ITER);\n\t\tif (max(abs(p.y-0.025), abs(p.z)-0.035)<0.002) { // Road\n\t\t\tfloat w = smoothstep(mod(p.x*50.0, 4.0), 2.0, 2.01);\n\t\t\tw -= 1.0-smoothstep(mod(p.x*50.0+2.0, 4.0), 2.0, 1.99);\n\t\t\tw = fract(w+0.0001);\n\t\t\tfloat a = fract(smoothstep(abs(p.z), 0.0025, 0.0026));\n\t\t\tcolor = vec3((1.0-x-y*2.)*mix(vec3(0.8, 0.8, 0), vec3(0.1), 1.0-(1.0-w)*(1.0-a)));\n\t\t} else {\n\t\t\tfloat q = 1.0-x-y*2.+z;\n\t\t\tcolor = hsv(0.0, 100.0, 0.0);\n\t\t}\n\t} else\n\t\tcolor = hsv(d, 1.0, 1.0)*mind*1.0; // Background\n\treturn color;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float time = iTime+60.0;\n\tvec3 upDirection = vec3(0, -1, 0);\n\tvec3 cameraDir = vec3(1,0,0);\n\tvec3 cameraOrigin = vec3(time*0.2, 0, 0);\n\t\n\tvec3 u = normalize(cross(upDirection, cameraOrigin));\n\tvec3 v = normalize(cross(cameraDir, u));\n\tvec2 screenPos = -1.0 + 2.0 * fragCoord.xy / iResolution.xy;\n\tscreenPos.x *= iResolution.x / iResolution.y;\n\tvec3 rayDir = normalize(u * screenPos.x + v * screenPos.y + cameraDir*(1.0-length(screenPos)*0.5));\n\t\n\tfragColor = vec4(intersect(cameraOrigin, rayDir), 1.0);\n} ", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3lVyRW.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[25, 53, 89, 89, 156], [159, 159, 182, 182, 200], [202, 202, 224, 224, 728], [730, 730, 776, 776, 884], [886, 886, 937, 937, 2080], [2082, 2082, 2139, 2139, 2648]]}
{"id": "3lVyzc", "name": "Fork Cloud_tunn leecorn 144", "author": "leecorn", "description": "cloud tunnel shader", "tags": ["raymarching", "cloud"], "likes": 0, "viewed": 170, "published": "Public API", "date": "1611461165", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Using code from\n\n//Morgan McGuire for the noise function\n// https://www.shadertoy.com/view/4dS3Wd\n\n#define time iTime\n#define depth 70.0\n#define fogSize 25.0\nfloat fogCoef=1.0/(depth-fogSize);\nfloat PI=acos(-1.0);\n\nfloat random (in float x) {\n\treturn fract(sin(x)*1e4);\n}\n\nfloat noise(in vec3 p) {\n\tconst vec3 step = vec3(110.0, 241.0, 171.0);\n\n\tvec3 i = floor(p);\n\tvec3 f = fract(p);\n\n\t// For performance, compute the base input to a\n\t// 1D random from the integer part of the\n\t// argument and the incremental change to the\n\t// 1D based on the 3D -> 1D wrapping\n\tfloat n = dot(i, step);\n\n\tvec3 u = f * f * (3.0 - 2.0 * f);\n\treturn mix( mix(mix(random(n + dot(step, vec3(0,0,0))),\n\trandom(n + dot(step, vec3(1,0,0))),\n\tu.x),\n\tmix(random(n + dot(step, vec3(0,1,0))),\n\trandom(n + dot(step, vec3(1,1,0))),\n\tu.x),\n\tu.y),\n\tmix(mix(random(n + dot(step, vec3(0,0,1))),\n\trandom(n + dot(step, vec3(1,0,1))),\n\tu.x),\n\tmix(random(n + dot(step, vec3(0,1,1))),\n\trandom(n + dot(step, vec3(1,1,1))),\n\tu.x),\n\tu.y),\n\tu.z);\n}\n\nmat2 rot(float a) {\n\tfloat ca=cos(a);\n\tfloat sa=sin(a);\n\treturn mat2(ca,sa,-sa,ca);\n}\n\nfloat cloud(in vec3 p, vec3 centerPos, float scale,float radius ) {\n\tfloat l = length(p*0.1);\n\tvec3 d = vec3(p.x+sin(l+time)*2.0,p.y+sin(l)*2.0,0.0);\n\tfloat coef = max(length(d)-1.5,0.0);\n\tfloat c=1.0;\n\tfloat n1=1.0;\n\tfor(int i=0; i<8; ++i) {\n\t\tn1+=1.0/c*abs(noise((p*c+time*1.0)*scale));\n\t\tc*=2.0;\n\t}\n\treturn n1+(coef);\n}\n\nfloat mapHyper(vec3 p){\n\treturn cloud(p,vec3(0,0,0),0.5,0.1);\n}  \n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n\tvec2 uv = vec2(fragCoord.x / iResolution.x, fragCoord.y / iResolution.y);\n\tuv -= 0.5;\n\tuv /= vec2(iResolution.y / iResolution.x, 1);\n\tvec3 s=vec3(0.5,0.5,100);\n\tfloat t2=(time*1.5);\n\ts.xz *= rot(sin(t2)*0.005);\n\tvec3 t=vec3(0,0,0);\n\ts.x += cos(t2*0.2)*0.10*sin(time*0.01);\n\ts.y += sin(t2*0.2)*0.10*sin(time*0.01+10.0);\n\tvec3 cz=normalize(t-s);\n\tvec3 cx=normalize(cross(cz,vec3(0,1,0)));\n\tvec3 cy=normalize(cross(cz,cx));\n\tvec3 r=normalize(uv.x*cx+uv.y*cy+cz*0.7);\n\ts.z+=time*-8.0;\n\t\n\tvec3 p=s;\n\tfloat d;\n\tfloat seuil=5.1;\n\tfloat c= 0.0;\n\tfloat distMax =100.0;\n\tfloat steps = 300.0;\n\tfloat color = 0.0;\n\tfloat cl;\n\tfloat dist = clamp((1.0-dot(vec3(0,0,-1.0),r))*4.0,0.0,1.0);\n\tint cc =int(mix(300.0,1000.0,dist));\n\tfloat uu =mix(1.0,0.25,dist);\n\tvec3 p3 = vec3(0);\n\tfor(int i=0; i<cc; ++i) {\n\t\tfloat d2 ;\n\t\tfloat d;\n\t\tif(color<0.001)d = mapHyper(p);\n\t\tc =d;  \n\t\tif( c>seuil )\n\t\t{vec3 p2 =p;\n\t\t\tif(p3.x==0.0)p3=p;\n\t\t\tfor(int j;j<20;j++)\n\t\t\t{\n\t\t\t\tif(color<0.2)d2= mapHyper(p2);\n\t\t\t\telse\n\t\t\t\td2 = 5.2;\n\t\t\t\tif(d2>seuil)\n\t\t\t\t{\n\t\t\t\t\tcolor = color*0.9 + d2*0.02*0.1;\n\t\t\t\t}\n\t\t\t\tp2 +=normalize(vec3(-0.0,-0.0,-5.0))*0.42;\n\t\t\t} \n\t\t}\n\t\tcl = 1.0-color;\n        p+=r*distMax/steps*uu;\n\t\t//p+=r*distMax/float(cc)*uu;\n\t}\n\n\tvec2 off=vec2(1.1,0.0);\n\tvec3 n=normalize(mapHyper(p3)-vec3(mapHyper(p3-off.xyy), mapHyper(p3-off.yxy), mapHyper(p3-off.yyx)));\n\n\t//compositing\n\tvec3 col=vec3(0);\n\tcol = mix(vec3(0.0,0.0,0.2),vec3(0.88,0.88,0.9),cl);\n\tfloat fog =  clamp((length(p3-s)-fogSize)*fogCoef,0.0,1.0);\n\tcol = mix(col,vec3(0.88,0.88,0.9),fog);\n\tfragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3lVyzc.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[20, 218, 245, 245, 274], [276, 276, 300, 300, 1009], [1011, 1011, 1030, 1030, 1096], [1098, 1098, 1165, 1165, 1420], [1422, 1422, 1445, 1445, 1485], [1489, 1489, 1544, 1544, 3101]]}
{"id": "3lVyzR", "name": "N-Star", "author": "hugoaboud", "description": "Draws a star with n points, parametric outer and inner radius, and a nice glow around it.\nSample animation: spin a and make a pulsating wave inside it.", "tags": ["star", "polygon", "shape"], "likes": 2, "viewed": 172, "published": "Public API", "date": "1610344832", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/*\n\tThis program is free software: you can redistribute it and/or modify\n    it under the terms of the GNU General Public License as published by\n    the Free Software Foundation, version 3.\n\n    This program is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU General Public License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with this program.  If not, see <https://www.gnu.org/licenses/>.\n*/\n\nconst float M_PI = 3.14159265358979323846264338327950288;\n\n/** Properties **/\n\nconst int N = 5; // Number of points\n\nconst float radius = 1.0; // Outer Radius: absolute value (in UV)\nconst float iradius = 0.6; // Inner Radius: relative to outer\nconst float glow = 0.3; // Glow Size: relative\n\nconst vec4 inColor = vec4(1,1,0,1);\nconst vec4 outColor = vec4(0,1,1,1);\nconst vec4 glowColor = vec4(1,0,0.5,1);\n\n/** Animation **/\n\nconst float rotateSpeed = 0.05;\nconst float waveSpeed = 0.5;\nconst vec4 waveColor = vec4(0.2,0.5,1.0,0.4);\n\nconst vec4 transp = vec4(0,0,0,0);\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    // Starting from center\n    uv.xy -= 0.5;\n    uv.xy *= -2.0;\n    \n    // Adjusted to aspect ratio\n    uv.x *= iResolution.x/iResolution.y;\n\n    // Radius\n    float r = length(uv);\n\n    // Background color\n    vec4 col = vec4(0,0,0,0);\n    \n    // Inside outer circle\n    if (r < radius) {\n    \n        // Linear position in circle\n        // This is a simplified projection of the vertex vector on y\n        float ly = uv.y/r;\n        \n        // Calculate polar angle\n        float a = atan(uv.x,uv.y);\n        \n        // Rotate Animation\n        a -= iTime*rotateSpeed;\n        \n        // Break angle into N sections\n        // then rearrange from [0 ~ 1] to [1 ~ 0 ~ 1]\n        // The section angle can be precalculated if N doesn't change\n        float sa = M_PI/float(N); // section angle\n        float p = fract(a/(2.0*sa)); // position in section (angular)\n        p = abs(p-0.5)*2.0;\n        \n        // Get chord midpoint radius\n        // A.K.A. height of the equilateral triangle inside the arc\n        float cr = cos(sa)*radius;\n                \n        // Get chord point radius, given the angle \n        float pa = p*sa; // point angle\n        float cpr = cr/cos(sa-pa);\n                \n        // rough method: maybe too expensive?\n        // scale cr by triangle propotionality rule\n        // The inner radius decomposition can be precalculated if N doesn't change\n        float xp = cpr*sin(pa); // decompose cpr x\n        float yp = cpr*cos(pa); // decompose cpr y\n        float xi = sin(sa*0.5)*iradius*radius; // decompose inner radius x\n        float yi = cos(sa*0.5)*iradius*radius; // decompose inner radius y\n        \n        //float yx = xi/((xp*(1.0-yi)/yp)+xi); // y component of border (if radius == 1)\n        float yx = (xi*yp*radius)/(xp*radius-xp*yi+xi*yp);// y component of border (general radius)\n        \n        // Final result: the star border radius\n        float border = yx/cos(pa);\n        \n        // Coloring (Internal + Glow)\n        if (r < border) {\n            float gl = 1.0-glow;\n            float c = r/border;\n            // star\n            if (c < gl) {\n                col = mix(inColor,outColor,c/gl);\n            }\n            // antialias\n            else if (c < gl*1.025) {\n                col = mix(outColor,glowColor,(c-gl)*50.0);\n            }\n            // glow\n            else {\n                col += glowColor*((1.0-c)/glow);\n            }\n        }\n        \n        // Wave animation\n        float t = fract(iTime*waveSpeed);\n        float rt = t*radius;\n                \n        if (r < rt) rt = 1.0-(rt - r)/radius;\n        else rt = (r - rt)/radius;\n        \n        rt = fract(rt*2.0);\n        \n        // Lighten\n        col += rt*waveColor*waveColor.a*col.a;\n    }\n\n    // Output to screen\n    fragColor = col;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3lVyzR.jpg", "access": "shaders20k", "license": "gpl-1.0-plus", "functions": [[999, 1162, 1219, 1269, 4110]]}
{"id": "3lycDK", "name": "White Noise and Blue Noise", "author": "Arion", "description": "White Noise and Blue Noise", "tags": ["noise", "halton"], "likes": 8, "viewed": 99, "published": "Public", "date": "1611740849", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float rand(float x)\n{\n\tfloat y = fract(sin(x)*753.5453123);\n\treturn y;\n}\n\n// white noise with UV\nfloat rand(vec2 st)\n{\n\treturn fract(sin(dot(st.xy,vec2(12.9898,78.233)))*43758.5453123);\n}\n\nvec2 rand2(vec2 st)\n{\n\treturn vec2(fract(sin(dot(st.xy,vec2(12.9898,78.233)))*43758.5453123),\n\t\tfract(sin(dot(st.xy,vec2(58.218,85.363)))*12543.1556)\n\t\t);\n}\n\nvec3 rand3(vec3 st)\n{\n\treturn vec3(fract(sin(dot(st.xyz,vec3(12.9898,78.233,521.689)))*43758.5453123),\n\t\tfract(sin(dot(st.xyz,vec3(58.218,85.363,55.689)))*12543.1556),\n\t\tfract(sin(dot(st.xyz,vec3(15.48,6.263,541.324)))*1854.2156)\n\t\t);\n}\n\nfloat Worley( vec2 x )\n{\n    vec2 p = floor( x );\n    vec2 w = fract( x );\n\n    float m = 1.0;\n    for( int j=-1; j<=1; j++ )\n    for( int i=-1; i<=1; i++ )\n    {\n        vec2  neighbor = vec2( float(i), float(j) );\n        vec2  neighbor_w = rand2( p + neighbor );  // 全部九个位置上的位置\n        // 用于动态Worley\n    \t//neighbor_w = 0.5 + 0.5*sin(_Time.x+6.2831*neighbor_w);\n        vec2  r = neighbor + neighbor_w - w;\n        float d = dot( r, r );\n        m = min(m, d);\n    }\n    return m ;\n}\n\n\n// white noise, from https://www.shadertoy.com/view/4djSRW\nvec2 hash23(vec3 p3)\n{\n\tp3 = fract(p3 * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\n\n// halton low discrepancy sequence, from https://www.shadertoy.com/view/wdXSW8\nvec2 halton (int index)\n{\n    const vec2 coprimes = vec2(2.0f, 3.0f);\n    vec2 s = vec2(index, index);\n\tvec4 a = vec4(1,1,0,0);\n    while (s.x > 0. && s.y > 0.)\n    {\n        a.xy = a.xy/coprimes;\n        a.zw += a.xy*mod(s, coprimes);\n        s = floor(s/coprimes);\n    }\n    return a.zw;\n}\n\nfloat blueNoise(vec2 p)\n{\n    //int m = int(p.y*iResolution.y*iResolution.x + p.x*iResolution.x) + iFrame;\n    //m = m%iFrame;\n    //vec2 n = halton(m);\n    \n    int mx = int(p.x*iResolution.x);// + int(iFrame);\n    int my = int(p.y*iResolution.y);// + int(iFrame);\n    \n    mx = mx;// % int(512);\n    my = my;// % int(1024);\n    \n    vec2 nx = halton(int(mx));\n    vec2 ny = halton(int(my));\n    \n    float h = 0.5* (nx.x + ny.x );\n    \n    return h;\n}\n\n// from https://www.shadertoy.com/view/XtGBDW\n#define LEVEL 15U\n#define WIDTH ( (1U << LEVEL) )\n#define AREA ( WIDTH * WIDTH )\nuint HilbertIndex( uvec2 Position )\n{   \n    uvec2 Regions;\n    uint Index = 0U;\n    for( uint CurLevel = WIDTH/2U; CurLevel > 0U; CurLevel /= 2U )\n    {\n        uvec2 Region = uvec2(greaterThan((Position & uvec2(CurLevel)), uvec2(0U)));\n        Index += CurLevel * CurLevel * ( (3U * Region.x) ^ Region.y);\n        if( Region.y == 0U )\n        {\n            if( Region.x == 1U )\n            {\n                Position = uvec2(WIDTH - 1U) - Position;\n            }\n            Position.xy = Position.yx;\n        }\n    }\n    \n    return Index;\n}\n\nfloat blueNoise2(vec2 p)\n{\n    uint y = HilbertIndex( uvec2(p*iResolution.xy) );\n    y += uint(iFrame);\n    uint x =  y % (1u << 17u);\n    const float phi = 2.0/(sqrt(5.0)+1.0);\n\tfloat c = fract(0.5+phi*float(x));\n    return c;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    vec2 coord = vec2(sin(uv.x+iTime), cos(uv.y+iTime));//vec2( uv.x + iTime, uv.y * iTime);//  \n    \n    float noise_white = rand(coord); \n    \n    float noise_worley = Worley(coord*10.0);\n    \n    float noise_blue = blueNoise2(uv);\n    \n    float o = noise_white;\n    float p = 0.001;\n    if(uv.x>(0.5 + p) )\n        o = noise_blue;\n    else if(uv.x>(0.5 - p) && uv.x <(0.5+p))\n        o = 0.0;\n\n    // Time varying pixel color\n    vec3 col = vec3(o,o,o);// 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3lycDK.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 21, 21, 72], [74, 97, 118, 118, 187], [189, 189, 210, 210, 345], [347, 347, 368, 368, 583], [585, 585, 609, 609, 1099], [1102, 1161, 1183, 1183, 1302], [1304, 1383, 1408, 1408, 1674], [1676, 1676, 1701, 1828, 2129], [2131, 2258, 2295, 2295, 2802], [2804, 2804, 2830, 2830, 3033], [3035, 3035, 3092, 3143, 3747]]}
{"id": "3lycRc", "name": "fbm hypnotic sin", "author": "alexandrediasldev", "description": "Using two fbm to create an hypnotic pattern", "tags": ["fbm", "sin", "hypnotic"], "likes": 2, "viewed": 167, "published": "Public API", "date": "1611397115", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//Using two fbm to creqte an hypnotic pattern\nfloat random (in vec2 st) {\n    return fract(sin(dot(st.xy,\n                         vec2(12.9898,78.233)))*\n        43758.5453123);\n}\nfloat noise (in vec2 st) {\n    vec2 i = floor(st);\n    vec2 f = fract(st);\n\n    // Four corners in 2D of a tile\n    float a = random(i);\n    float b = random(i + vec2(1.0, 0.0));\n    float c = random(i + vec2(0.0, 1.0));\n    float d = random(i + vec2(1.0, 1.0));\n\n    vec2 u = f * f * (3.0 - 2.0 * f);\n\n    return mix(a, b, u.x) +\n            (c - a)* u.y * (1.0 - u.x) +\n            (d - b) * u.x * u.y;\n}\n#define OCTAVES 6\nfloat fbm (in vec2 st) {\n    // Initial values\n    float value = 0.0;\n    float amplitude = .5;\n    float frequency = 0.;\n    //\n    // Loop of octaves\n    for (int i = 0; i < OCTAVES; i++) {\n        value += amplitude * noise(st);\n        st *= 2.;\n        amplitude *= .5;\n    }\n    return value;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 inv = vec2(uv.y,uv.x);\n\n    vec3 col = vec3(0.0);\n    float t = iTime;\n    float r = fbm(uv);\n    float r2 = fbm(inv);\n\n    // Output to screen\n    col += sin((r/r2*t*10.0));\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3lycRc.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 46, 73, 73, 180], [181, 181, 207, 207, 587], [606, 606, 630, 652, 906], [907, 907, 964, 1014, 1271]]}
{"id": "3lycRK", "name": "Nyquist–Shannon sampling theorem", "author": "electrautistic", "description": "Adaptation mic-analysis from  'FabriceNeyret2'", "tags": ["nyquistshannon"], "likes": 0, "viewed": 76, "published": "Public", "date": "1611290306", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//Nyquist–Shannon sampling theorem\n//Sample rate less than Nyquist frequency ??!!\n//Send Sinewave 100 to 2000Hz to audio input\n//Edit line 12 and change default value less than 1 to see the effect\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;   \n    float c=0.0;\n    \n    if (uv.y>0.0) {\n        uv.y = (uv.y-.3)/0.5;\n        uv.x /= 5.0;   //  yes here, choose range -5.0 to 0.95 \n        \n        // Audio Data INPUT from iChannel0\n        c =  texture(iChannel0,vec2(uv.x,.5/2.)).r;\n        c = (uv.y<c) ? 1. : 0.;\n\n    }\n     vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n     fragColor = vec4(c,col);\n}\n", "image_inputs": [{"id": "XdXGRr", "previewfilepath": "/presets/mic.png", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/presets/mic.png", "ctype": "mic"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3lycRK.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 200, 257, 257, 670]]}
{"id": "3lyczK", "name": "Ripples in Hexagonal Tiling", "author": "oneshade", "description": "Fun with hexagonal tiling.", "tags": ["ripples", "demo", "sine", "hue", "tiling", "hexagonal"], "likes": 12, "viewed": 141, "published": "Public", "date": "1611298431", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Hue to RGB function from Fabrice's shadertoyunofficial blog:\n#define hue2rgb(hue) 0.6 + 0.6 * cos(6.3 * hue + vec3(0.0, 23.0, 21.0))\n\n// Woah thats trippy!\n//#define PSYCHO_MODE\n\nstruct Surface {\n    float dist;\n    vec3 ambient;\n    vec3 diffuse;\n    vec3 specular;\n    float gloss;\n};\n\nfloat sdHexShape(in vec3 p, in float s) {\n    const vec2 n = normalize(vec2(1.0, sqrt(3.0)));\n    p = abs(p);\n    vec2 p2 = vec2(max(dot(p.xz, n), p.x), p.y);\n\n    #ifdef PSYCHO_MODE\n    return max(length(p.xz) - 1.0, abs(p.y - s) - s);\n    #else\n    return max(abs(p2.x - s), p2.y) - 0.1;//max(dot(p2, n), p2.x) - s;\n    #endif\n}\n\nSurface mapScene(in vec3 p) {\n    vec2 rep = vec2(2.0, 3.46); // 1.73 ~ sqrt(3)\n    vec2 hrep = 0.5 * rep;\n    vec2 a = mod(p.xz, rep) - hrep;\n    vec2 b = mod(p.xz - hrep, rep) - hrep;\n    vec2 hexUv = dot(a, a) < dot(b, b) ? a : b;\n    vec2 cellId = p.xz - hexUv;\n    p.xz = hexUv;\n\n    float oscPoint = 0.5;\n    float freq = 0.5;\n    float amp = 0.4;\n    #ifdef PSYCHO_MODE\n    oscPoint = 5.0;\n    freq = 0.25;\n    amp = 2.5;\n    #endif\n\n    float ripples = oscPoint + amp * sin(length(cellId) * freq - iTime * 4.0);\n    return Surface(sdHexShape(p, ripples) * 0.25, vec3(0.2, 0.0, 0.0), hue2rgb(ripples * freq), vec3(1.0), 8.0);\n}\n\nvec3 getNormal(in vec3 p) {\n    vec3 e = vec3(0.001, 0.0, 0.0);\n    return normalize(vec3(mapScene(p + e.xyy).dist - mapScene(p - e.xyy).dist,\n                          mapScene(p + e.yxy).dist - mapScene(p - e.yxy).dist,\n                          mapScene(p + e.yyx).dist - mapScene(p - e.yyx).dist));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n    fragColor = vec4(0.0, 0.0, 0.0, 1.0);\n\n    float camDist = 5.0;\n    #ifdef PSYCHO_MODE\n    camDist = 20.0;\n    #endif\n\n    vec3 ro = vec3(cos(iTime), 2.0 + sin(0.5 * iTime), cos(1.5 * iTime)) * camDist;\n\n    vec3 f = -normalize(ro);\n    vec3 r = normalize(vec3(-f.z, 0.0, f.x));\n    vec3 u = normalize(cross(r, f));\n    vec3 rd = normalize(f + uv.x * r + uv.y * u);\n\n    vec3 l = vec3(-0.58, 0.58, 0.58);\n\n    float time = 0.5 * iTime;\n    float c = cos(time), s = sin(time);\n    l.xz *= mat2(c, s, -s, c);\n\n    float t = 0.0;\n    for (int i=0; i < 100; i++) {\n        vec3 p = ro + rd * t;\n        Surface scene = mapScene(p);\n        if (scene.dist < 0.001) {\n            vec3 n = getNormal(p);\n            fragColor.rgb += scene.ambient;\n\n            float lambertian = max(0.0, dot(n, l));\n            fragColor.rgb += scene.diffuse * lambertian;\n\n            if (lambertian > 0.0) {\n                vec3 r = reflect(l, n);\n                float specAngle = max(0.0, dot(r, rd));\n                fragColor.rgb += scene.specular * max(0.0, pow(specAngle, scene.gloss));\n            }\n\n            break;\n        }\n\n        if (t > 100.0) {\n            break;\n        }\n\n        t += scene.dist;\n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3lyczK.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[137, 291, 332, 332, 621], [623, 623, 652, 652, 1257], [1259, 1259, 1286, 1286, 1563], [1565, 1565, 1620, 1620, 2896]]}
{"id": "3lyczt", "name": "Pixel Color Shift 1", "author": "dagelf", "description": "Playing with colors. Drag the mouse. ", "tags": ["rgb"], "likes": 1, "viewed": 39, "published": "Public", "date": "1611520782", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 d, in vec2 c )\n{\n \n  #define mix 1. // interference pattern\n//  #define mix .5 // halftone pattern\n  \n \n  float x=tan((.0-iTime)/100.);\n  float y=cos((.0-iTime)/8.);\n \n  if (iMouse.x>=0.) {\n   x = .001+(iMouse.x/iResolution.x)/10.;\n   y =  iMouse.y/iResolution.y;\n  } \n  \n  float t = iTime/300.;\n   \n   vec4 a = vec4(\n       sin( c.x*x + t ),\n       sin( c.x*x *y*y*y     + t*y ),\n       sin( c.x*x *y*y*y*y*y + t*y*y ),\n       mix);\n\n   vec4 b = vec4(\n       sin( c.y*x + t ),\n       sin( c.y*x *y*y*y     + t*y ),\n       sin( c.y*x *y*y*y*y*y + t*y*y ),\n       mix);\n        \n//   d = abs(a+b);\n//   d = abs(a*b);\n     d = abs(a);\n  \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3lyczt.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 41, 41, 662]]}
{"id": "3lyyWh", "name": "Fork fractal di IWBTShyGuy 913", "author": "IWBTShyGuy", "description": "A test of fork.", "tags": ["fractaldirecto"], "likes": 2, "viewed": 191, "published": "Public API", "date": "1610868114", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//referencia\n//http://glslsandbox.com/e#70359.0\n//modificado por jorge2017a1\n\n#define rot(a) mat2(cos(a), sin(a), -sin(a), cos(a))\n\nfloat scale;\n\n\nfloat map(vec3 p) \n{\n    vec3 pp=p;\n\tp.z -= -iTime * 2.5;\n\tp.xy = abs(p.xy) - 1.0;\n\tif (p.x < p.y) p.xy = p.yx;\n\tp.z = mod(p.z, 4.0) - 2.0;\n\n\tp.x -= 3.2;\n\tp = abs(p);\n\tfloat s = 2.0;\n\tvec3 offset =p*1.5;\n    \n    float r;\n    \n    float aa = 7.6 + 1.1 * sin(iTime);\n\tfor (float i = 0.0; i < 5.0; i++)\n    {\n\t\tp = 1.0 - abs(p - 1.0);\n\t\t r = -aa * clamp(0.38 * max(1.2 / dot(p, p), 1.), 0.0, 1.0);\n\t\ts *= r;\n\t\tp *= r;\n        p += offset;\n\t}\n\ts = abs(s);\n\tscale = s;\n\tfloat a = 100.0;\n\tp -= clamp(p, -a, a);\n\treturn (length(p)) /( s);\n}\n\nvec3 GetNormal(vec3 p)\n{\n\tfloat d = map(p);\n    vec2 e = vec2(.001, 0);\n    vec3 n = d - vec3(\n        map(p-e.xyy),\n        map(p-e.yxy),\n        map(p-e.yyx));\n    return normalize(n);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = (fragCoord.xy - 0.5 * iResolution.xy) / iResolution.y;\n\tvec3 rd = normalize(vec3(uv, 1.0));\n    vec3 ro=vec3(0, 0.5, -3);\n\tvec3 p = ro;\n    scale=1.0;\n     float d;\n     \n     //vec3 light_color1 = vec3( 1.0 );\n     vec3 light_pos1= vec3(2.0, 3.0, 10.0 );\n     vec3 final;\n     float shininess=1.0;\n     \n\tfor (int i = 1; i < 100; i++) {\n\t\tfloat d = map(p);\n\t\tp += rd * d;\n\t\tif (d < 0.001) \n        {\n\t       \n            vec3 color=mix(vec3(0.85), cos(vec3(2.0, 9., 3.) + log2(scale)) * 0.5 + 0.5, 0.5) * 10.0 / float(i);\n            \n            vec3 normal=GetNormal(p);\n            vec3 v = normalize( p-ro);\n              float diff = dot(normal, light_pos1);\n    \n            vec3 vl = normalize( light_pos1 - p );\n            vec3 ref_v = reflect( v, normal );\n            float diffuse  = max( 0.0, dot( vl, normal ) );\n            float specular = max( 0.0, dot( vl, ref_v ) );\n    \n            specular = pow( specular, shininess );\n            \n            final += color * ( diffuse + specular);\n            \n\t\t\tbreak;\n\t\t}\n        \n        \n\t}\n    \n    \n    fragColor =vec4( final,1.0);\n    \n    fragColor *= 1.0 - pow(d /(100.0) , 3.5);    \n    fragColor = pow(fragColor, vec4(0.5545));  \n\n    \n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3lyyWh.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 147, 167, 167, 681], [683, 683, 707, 707, 871], [873, 873, 930, 930, 2151]]}
{"id": "3lyyzV", "name": "Inverse Gray Coded Curve", "author": "Dain", "description": " Alternative space filling curve to morton and hilbert that apparently falls between them for both computational cost and clustering \n\n https://www2.cs.arizona.edu/~bkmoon/papers/tkde-hilbert.pdf\n", "tags": ["2d", "inverse", "graycode", "morton"], "likes": 0, "viewed": 158, "published": "Public API", "date": "1611319261", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//Started from iq \" Inverse Morton and Hilbert\": https://www.shadertoy.com/view/XdlcWr\n\n\n//https://www2.cs.arizona.edu/~bkmoon/papers/tkde-hilbert.pdf\n//This paper compares morton , hilbert and something called gray coded curve: \n//It claims the gray coded curve is better at clustering than morton  order for 3D, but worse than hilbert\n//It didn't really clarify what the gray coded curve was exactly but after fiddling with gray coding this appears to be the same as the curve in the paper\n\n//There is an ugly worm that traces it see the steps\n\n// 0 = Hilbert\n// 1 = Morton\n#define CURVE 1\n\nconst int level = 4;  // Number of points is 2^level in each dimension\n\nint GrayToBinary32(int num){\n\t\tnum ^= num >> 16;\n\t\tnum ^= num >> 8;\n\t\tnum ^= num >> 4;\n\t\tnum ^= num >> 2;\n\t\tnum ^= num >> 1;\n\t\treturn num;\n}\n\nivec2 curve( int i )\n{\n    ivec2 res = ivec2(0,0);\n    \n    i = GrayToBinary32(i);\n    for( int k=0; k<level; k++ )\n    {\n        #if CURVE==0\n        // inverse Hilbert, https://en.wikipedia.org/wiki/Hilbert_curve\n        ivec2 r = ivec2( i>>1, i^(i>>1) ) & 1;\n        if (r.y==0) { if(r.x==1) { res = (1<<k)-1-res; } res = res.yx; }\n        #else\n\t\t// inverse Morton, http://www.iquilezles.org/www/articles/wavelet/wavelet.htm\n        ivec2 r = ivec2( i, i>>1 ) & 1;\n        #endif\n        \n        res += r<<k;\n        i >>= 2;\n    }\n   // res.x = GrayToBinary32(res.x);\n   // res.y = GrayToBinary32(res.y);\n    return res;\n}\n\n\nfloat sdSqLine( in vec2 p, in vec2 a, in vec2 b, out float outH )\n{\n\tvec2 pa = p - a, ba = b - a;\n    float h = clamp(dot(pa,ba)/dot(ba,ba), 0.0, 1.0);\n    outH = h;\n    vec2 d = pa - ba*h;\n    return dot(d,d);\n}\n    \nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float e = 1.0/iResolution.y; // size of a pixel\n    vec2 p = (fragCoord - vec2(0.25*iResolution.x,0.0))*e;\n    \n    p = -0.05 + (1.0+2.0*0.05)*p; // add margin of 0.05\n    \n    const int numPoints = 1<<(level<<1);\n    const float w = float((1<<level)-1); // distance between grid points\n\n    // compute distance field\n    float d = 2.0;\n    ivec2 o = ivec2(0,0);\n    float nearI = -1.0;\n    for( int i=1; i<numPoints; i++ )\n    {\n        ivec2 m = curve(i);\n        \n        float oldD = d;\n        float oH;\n        d = min( d, sdSqLine( p, vec2(m)/w, vec2(o)/w, oH));\n        if(d != oldD){\n          nearI = float(i)+(1.0-oH);\n        }\n        o = m;\n    }\n    d = sqrt(d);\n    \n    // colors\n    float f  = smoothstep(0.0,2.0*e,d); \n          f *= 0.8 + 0.2*sqrt(clamp(d/(8.0*e),0.0,1.0));\n     \n    // float k = sin(float(nearI)+iTime);\n   //  if(d >0.01){\n   //  k = 0.0;\n    // }\n    //make ugly worm follow it\n     float k2 = 0.0;\n    if((abs(nearI-iTime)) < .25 && d<0.015){\n      k2 = .5;\n    }\n    fragColor = vec4( f , max(f- k2,0.0), f, 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3lyyzV.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[615, 665, 693, 693, 805], [807, 807, 829, 829, 1435], [1438, 1438, 1505, 1505, 1650], [1656, 1656, 1713, 1713, 2777]]}
{"id": "3sGBRm", "name": "Illumishader", "author": "epseen", "description": "They are everywhere man", "tags": ["colorsandshapes"], "likes": 1, "viewed": 50, "published": "Public", "date": "1611689177", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\t\n    uv -= 0.5;\n    uv*=4.;\n    \n    uv.y /= 16./9.;\n    \n    float xx = uv.y;\n    uv.y = uv.x;\n    uv.x = xx;\n\n    int lights =400;\n    float timespeed = 240.;\n    \n    \n    float t = float(int(iTime*timespeed))/float(lights);\n    float x = float(int(uv.x*float(lights)))/float(lights);\n    \n    \n    \n     float fil = step(0.95,mod(iTime*2.*3.14+atan(uv.x,uv.y)*3.14*3.,59.15/20.));\n    uv.x = -abs(uv.x)-fil;\n    float dist = sqrt(uv.x*uv.x+uv.y*uv.y);\n    \n    float r = step(0.90+0.08*sin(3.14/2.+t*2.),sin((mod(3./4.+atan(dist),1.))*2.*3.14+sin(t*2.)*2.));\n    r = step(0.,r)*r;\n\n    \n    float g = 0.;\n    //float g = sin((3./4.-x)*2.*3.14+sin(t*2.)*2.);\n    \n    float b = 0.;//abs(1.-2.*mod(1.+mod(uv.x*2.,1.)+time,1.));\n    \n    vec3 col = vec3(1.,1.,1.)*r;\n   \tcol += 0.8*(vec3(1.,1.,1.)-col)*vec3(sin(uv.x*uv.y),cos(uv.y*uv.x),cos(iTime+uv.y*uv.x));\n    \n    col*=vec3(sin(iTime+x),cos(iTime+x*uv.y),1.);\n    \n    //col *= step(uv.y,0.55)*step(0.45,uv.y);\n   \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3sGBRm.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 107, 1177]]}
{"id": "3sGfRy", "name": "MandelbrotSetHWK", "author": "MattyHarv", "description": "Assignment", "tags": ["shader"], "likes": 2, "viewed": 37, "published": "Public", "date": "1610988823", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float ITERATIONS = 256.0;\nfloat LIMIT = 4.0;\n\nvec4 hsv2rgb(vec3 c) {\n  vec3 rgb = clamp(abs(mod(c.x*6.+vec3(1.,2.,2.),6.)-3.)-1.,0.,1.);\n  //vec3 rgb = clamp(abs(mod(c.x*6.+vec3(0.,4.,2.),6.)-3.)-1.,0.,1.);\n\n  rgb = rgb * rgb * (3.0 - 2.0 * rgb);\n  vec3 color = c.z * mix(vec3(1.0), rgb, c.y);\n   return vec4(color,1);\n}\n\nvec4 colormap(float i)\n{\n    if(i == ITERATIONS)\n        return vec4(0,0,0,1);\n    vec3 hsv = vec3(float(i)/ITERATIONS,1,1);\n    \n\treturn hsv2rgb(hsv);\n}\n\nvec4 MandelbrotColor( vec2 c )\n{\n    vec2 z = vec2(0,0);\n    float i = 0.0;\n    for (i=0.0;i<ITERATIONS;i++) {\n    \n    //Z = Z^2 + C - Algorithm for mandlebrot set\n    vec2 znew = vec2(z.x * z.x - z.y *z.y, 2.0 * z.x* z.y) + c;\n      if (dot(znew,znew) > LIMIT)\n         break;\n         z = znew;\n   }\n   \n   return colormap(i);\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    \n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    //Shrank image to see the whole of the set\n    uv = (2.5 *fragCoord - iResolution.xy) / iResolution.xy;\n    //Centres image \n\tuv -= vec2(0.3, -0.3);\n    uv.x *= iResolution.x/iResolution.y;\n    \n            /* POINTS OF INTEREST\n    vec2 centre = vec2(-0.761574, -0.0847596);\n    vec2 centre = vec2(-0.412 , 0.609);\n    vec2 centre = vec2(0.278039575 , -0.007910056);\n    vec2 centre = vec2(-0.107631967 , -0.908353935);\n    vec2 centre = vec2(-0.290693391 , 0.670809656);*/\n    vec2 centre = vec2(-0.384264141 , -0.600523952);\n    \n    float angle = iTime* 0.75;\n    mat2 rotationMatrix = mat2( cos(angle), sin(angle),\n                               \t-sin(angle),  cos(angle));\n                                \n    //Makes a cos curve that oscillates equally above / below 0, used minus to start zoomed out\n    float cc = 4.5*-cos(0.25 * iTime) + 4.25; \n    //Smooths out the curve, making it less erratic \n    float zoom = pow(0.25, cc);\n    //Zooms in and out on the centre coordinates\n    uv *= zoom;\n    uv += centre;\n    //Applies rotation matrix about centre point\n    uv = rotationMatrix *(uv - centre) + centre ;\n\t\n    // Output to screen\n    fragColor = MandelbrotColor(uv);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3sGfRy.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[46, 46, 68, 68, 320], [322, 322, 346, 346, 475], [477, 477, 509, 509, 808], [812, 812, 869, 929, 2160]]}
{"id": "3sVBDd", "name": "Marching Die", "author": "Shane", "description": "A rounded die randomly moving about the surface of other stacked dice.", "tags": ["raymarch", "cube", "dice", "animate", "frame", "die"], "likes": 53, "viewed": 949, "published": "Public API", "date": "1609766076", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/*\n\n\tMarching Die\n\t------------\n    \n    I've had this scene sitting in my account for way too long, so thought I'd \n    put it up. I did it just for fun and to relieve boredom. At the time, I \n    thought it'd be cool to see what a standard infinite 2D hexagonal grid filled \n    with cubes would look like in 3D. Once I'd satisfied my curiosity, I figured \n    I'd randomly move a cube about the resultant surface for a bit of visual \n    interest and depth.\n    \n    All of that was simple enough, but texturing a moving animated die correctly\n    proved to be a little tricky. I got there in the end, but I might try to come \n    up with a better system next time.\n    \n    In order to move and texture the die correctly, I hardcoded 15 steps that \n    looped around to the surface die just in front of the original position, which \n    was necessary to keep up with a moving camera synchronized to meet it there. \n    The steps were simple enough: Pivot up and forward about the YZ axis, pivot \n    down and left about the XY axis, etc. Whilst doing this, it was necessary to \n    keep track of the pivot points, fractional rotation matrix, overall position, \n    overall rotation, etc, in order to obtain the correct texture. Texturing was \n    achieved via standard cube mapping -- Render one dot on face one, two dots on \n    face two, etc. I was able to fake randomness by changing the original looped \n    path slightly each time around, or something to that effect.\n    \n    I'm giving the performance a \"mildly OK\" rating. On machines like mine, it'll \n    run fine in the 800 by 450 window, but fullscreen will be slow. At some stage,\n    I'll get in amongst it and improve a few things. I'm also going to post my\n    original shader that doesn't have rounded stacked dice, reflections, etc, so\n    that will be much faster.\n \n    \n   \n    Other examples:\n\n\t// Quite watchable: Dave Hoskins was coding stacked cubes before it was cool. :D \n    Ray*Bert - Dave_Hoskins \n\thttps://www.shadertoy.com/view/4sl3RH\n    \n    // I really like this one. It'd be cool to see a fancier version at some stage.\n    hexastairs: ladder like + doors - FabriceNeyret2\n    https://www.shadertoy.com/view/wsyBDm\n    \n    // Here's another related example of Fabrice's. I like the way he's worked\n    // the camera.\n    rolling dice on surface - FabriceNeyret2 \n    https://www.shadertoy.com/view/WdGBRc\n \n\n*/\n\n// Bouncing the die from level to level... It works but needs a little fine tuning.\n//#define BOUNCE\n\n// Ray passes: For this example, just one intersection and one reflection.\n#define PASSES 2\n\n// Far plane, or max ray distance.\n#define FAR 40.\n\n// Minimum surface distance. Used in various calculations.\n#define DELTA .001\n\n// Global block scale.\n#define GSCALE vec2(1./1.5)\n\n\n#define PI 3.14159\n// A swap without the extra declaration, but involves extra operations -- \n// It works fine on my machine, but if it causes trouble, let me know. :)\n#define swap(a, b){ a = a + b; b = a - b; a = a - b; }\n\n// Scene object ID to separate the mesh object from the terrain.\nint objID, svObjID;\n\n// Standard 2D rotation formula.\nmat2 rot2(in float a){ float c = cos(a), s = sin(a); return mat2(c, -s, s, c); }\n\n// IQ's vec2 to float hash.\nfloat hash21(vec2 p){  return fract(sin(dot(p, vec2(27.609, 57.583)))*43758.5453); }\n\n\n// Commutative smooth maximum function. Provided by Tomkh, and taken \n// from Alex Evans's (aka Statix) talk: \n// http://media.lolrus.mediamolecule.com/AlexEvans_SIGGRAPH-2015.pdf\n// Credited to Dave Smith @media molecule.\nfloat smax(float a, float b, float k){\n    \n   float f = max(0., 1. - abs(b - a)/k);\n   return max(a, b) + k*.25*f*f;\n}\n\n\n// Tri-Planar blending function: Based on an old Nvidia writeup:\n// GPU Gems 3 - Ryan Geiss: http://http.developer.nvidia.com/GPUGems3/gpugems3_ch01.html\nvec3 tex3D(sampler2D tex, in vec3 p, in vec3 n){    \n    \n    // Ryan Geiss effectively multiplies the first line by 7. It took me a while to realize that \n    // it's largely redundant, due to the division process that follows. I'd never noticed on \n    // account of the fact that I'm not in the habit of questioning stuff written by Ryan Geiss. :)\n    n = max(n*n - .2, .001); // max(abs(n), 0.001), etc.\n    n /= dot(n, vec3(1)); \n    //n /= length(n); \n    \n    // Texure samples. One for each plane.\n    vec3 tx = texture(tex, p.yz).xyz;\n    vec3 ty = texture(tex, p.zx).xyz;\n    vec3 tz = texture(tex, p.xy).xyz;\n    \n    // Multiply each texture plane by its normal dominance factor.... or however you wish\n    // to describe it. For instance, if the normal faces up or down, the \"ty\" texture sample,\n    // represnting the XZ plane, will be used, which makes sense.\n    \n    // Textures are stored in sRGB (I think), so you have to convert them to linear space \n    // (squaring is a rough approximation) prior to working with them... or something like that. :)\n    // Once the final color value is gamma corrected, you should see correct looking colors.\n    return mat3(tx*tx, ty*ty, tz*tz)*n; // Equivalent to: tx*tx*n.x + ty*ty*n.y + tz*tz*n.z;\n\n}\n\n\n\n// IQ's signed box formula.\nfloat sBox(in vec2 p, in vec2 b, in float sf){\n\n  p = abs(p) - b + sf;\n  return length(max(p, 0.)) + min(max(p.x, p.y), 0.) - sf;\n}\n\n// IQ's signed box formula.\nfloat sBox(in vec3 p, in vec3 b, in float sf){\n\n  p = abs(p) - b + sf;\n  return length(max(p, 0.)) + min(max(max(p.x, p.y), p.z), 0.) - sf;\n  \n  // Unsigned.\n  //return length(max(abs(p) - b + sf, 0.)) - sf;\n}\n\n\n// Exponential easing function.\nfloat exponentialOut(float t) {\n  return t == 1. ? t : 1. - pow(2., -8.*t);\n}\n\n// Quad easing function. \nfloat easeOutQuad(float t) {\n    return -t*(t - 2.);\n}\n \n \n// Various moving die storage containers. I added these as I went\n// along, so it definitiely needs a tidy up.\n\n// Cube distance and ID.\nvec3 svGID; \n\n// Die rotation storage matrices.\nmat2 gMat, svMat;\nmat2 lRot;\n\n// Texture pivot and offset matrices for the moving die.\nvec3 gTxP, svTxP;\nvec3 gPiv, svPiv;\nvec3 gOff;\n\n// Pivot total direction and direction storage.\nvec3 lPivot;\nvec3 lTotDist;\nvec3 dirI;\n// XY and YZ direction start positions.\nfloat lStartXY;\nfloat lStartYZ;\n// Bounce value.\nfloat gBounce = 0.;\n\n\n// Moving the cube whilst keeping track of pivot, offset, etc, variables\n// for texturing purposes. This is a long and ugly function, but thankfully,\n// it's only called once per frame.\nvoid moveCube(float gTime){\n\n   \n    const int ttm = 15;\n    float tm = gTime*float(ttm)/GSCALE.x; \n    \n    float modtm = mod(tm, float(ttm));\n \n    // Initial die offset -- Arrange to match the camera movement.\n    gOff = ((vec3(5, 4, -4) - 1./2.) + floor(tm/float(ttm))*vec3(0, 1, 1))*GSCALE.x;\n \n    lStartYZ = mod(floor(tm/float(ttm)), 2.);\n\n    // Directions -- All 15 of them.\n    vec3[ttm] dir = vec3[ttm](vec3(0, 1, 1), vec3(1, 1, 0), vec3(0, 1, 1), vec3(-1, -1, 0), vec3(0, 1, 1), vec3(-1, -1, 0),\n    vec3(0, 1, 1), vec3(-1, -1, 0), vec3(-1, -1, 0), vec3(0, -1, -1), vec3(1, 1, 0), vec3(0, -1, -1), \n    vec3(1, 1, 0), vec3(0, -1, -1), vec3(1, 1, 0));\n    \n    // Random swap.\n    for(int i = 0; i<15; i++){\n        if(hash21(vec2(floor(tm/float(ttm)), i)/15.)<.333) swap(dir[i], dir[(i + 1)%15]);\n    }\n    \n    lTotDist = vec3(0); // Total distance.\n    \n    // Cycle through the animation frames, then move the dice from one level to the\n    // the next in whatever random direction the array has chosen. Whilst doing so,\n    // keep track for the pivot point, rotation matrix, total distance, etc, for later\n    // texture usage... If you're thinking it looks fiddly, you'd be right, but it's\n    // all just basic physics and not as hard as you'd think.\n    for(int i = 0; i<ttm; i++){\n\n       float fi = float(i);\n       dirI = dir[i];\n\n       if(modtm<fi + 1.){ \n            \n            // Fractional time component.\n            float t = (modtm - fi)/1.;\n            \n            #ifdef BOUNCE\n            // Alternative level to level bounce.\n            t = easeOutQuad(t);\n            gBounce = (1. - abs(fract(t) - .5)*2.)*GSCALE.x*.25;\n            #else\n            // Exponential ease.\n            t = exponentialOut(t); \n            #endif\n            \n            // Rotate in the give direction from the pivot point.\n            t = mix(0., PI, t);\n            if(dirI.z<-.5 || dirI.x>.5) t *= -1.;            \n            lRot = rot2(t);\n            lPivot = dirI*GSCALE.x/2.;//vec3(0, GSCALE.x, GSCALE.x)/2.;\n            \n            // Save the pivol and rotation variables.\n            gPiv = lPivot;\n            gMat = lRot;\n           \n            break;\n\n\n       }\n\n       lTotDist += dirI; // Update the overall position.\n\n    }\n    \n\n}\n\n\n// Dice block levels.\n\nvec4 blocks(vec3 q){\n\n\n    // Brick dimension: Length to height ratio with additional scaling.\n\tconst vec2 dim = GSCALE;//vec2(scale);\n    // A helper vector, but basically, it's the size of the repeat cell.\n\tconst vec2 s = dim*2.;\n\n    \n    // Distance.\n    float d = 1e5;\n    // Cell center, local coordinates and overall cell ID.\n    vec2 p, ip;\n    \n    // Individual brick ID.\n    vec2 id = vec2(0);\n    vec2 cntr = vec2(0);\n    \n    // Four block central postions.\n    vec2[4] ps4 = vec2[4](vec2(-.5, .5), vec2(.5),   vec2(.5, -.5), vec2(-.5));\n \n    \n    float height = 0.; // Block height initialization.\n    \n    // Height scale.\n    const float hs = .125;\n\n\n    for(int i = 0; i<4; i++){\n\n        // Block center.\n        cntr = ps4[i]/2.;// -  ps4[0]/2.;\n        \n \n        \n        p = q.xz - cntr*s;\n        ip = floor(p/s) + .5; // Local tile ID.\n        p -= (ip)*s; // New local position.\n        \n        \n        // Correct positional individual tile ID.\n        vec2 idi = (ip + cntr)*s;\n\n  \n        // Block height.\n        float h1 = (ip.y - .5 - float(i/2)/2.)*GSCALE.y + 1.;//hm(idi);\n        h1 += (ip.x - .5)*GSCALE.x + 1.;\n        if(i==0 || i==3) h1 -= GSCALE.x/2.;\n        \n \n        // Render the dice.\n        float qy = mod(q.y - GSCALE.x/2., GSCALE.x*2.) - GSCALE.x;\n        float face1Ext = sBox(vec3(p, qy), vec3(dim.x/2.), .07);\n        face1Ext = smax(face1Ext, length(vec3(p, qy)) - GSCALE.x/2.*1.55, .1);\n        qy = mod(q.y + GSCALE.x/2., GSCALE.x*2.) - GSCALE.x;\n        float face2Ext = sBox(vec3(p, qy), vec3(dim.x/2.), .07);\n        face2Ext = smax(face2Ext, length(vec3(p, qy)) - GSCALE.x/2.*1.55, .1);\n        face1Ext = min(face1Ext, face2Ext);\n        \n        face1Ext = max(face1Ext, (q.y - h1*2. + .01));\n        \n        vec4 di = vec4(face1Ext, idi, h1);\n        \n        // If applicable, update the overall minimum distance value,\n        // ID, and box height. \n        if(di.x<d){\n            d = di.x;\n            id = di.yz;\n            height = di.w; \n     \n        }\n        \n    }\n    \n    // Return the distance, position-based ID and triangle ID.\n    return vec4(d, id, height);\n}\n\n\n\n\n\n\n\n// Block ID -- It's a bit lazy putting it here, but it works. :)\nvec3 gID;\n\n// The extruded image.\nfloat map(vec3 p){\n    \n    \n    // Reflecting the wall opposite to give the light something to relect off of.\n    //p.y =  abs(p.y - .25) - .75;\n    \n    // Wall behind the pylons to stop the light getting through.\n    vec3 q = p;\n    \n    q.yz *= rot2(3.14159/4.);\n    q.xy *= rot2(-3.14159/5.);\n    float wall = 1e5;//q.y - .7071 + .1;//abs(q.y - .7017 + 1.) - 1.;//1.5*.7071;\n    \n \n    // Blocks.\n    vec4 d4 = blocks(p);\n    gID = d4.yzw; // Individual block ID.\n    \n    \n    // Move and render the die.\n    \n    // Initial point.\n    q = p - gOff- lTotDist*GSCALE.x; \n    // Bounce.\n    q.y -= gBounce;\n    // Pivot about the pivot point.\n    q -= lPivot;\n    // Depending on direction rotate around the XY plane or the YZ one.\n    if(abs(dirI.x)>.5) q.xy = lRot*q.xy;\n    else q.yz = lRot*q.yz;\n    // Pivot back.\n    q += lPivot;\n \n    // Factor in the total rotation for each direction.\n    q.xy = rot2(mod(lTotDist.x, 2.)*PI)*q.xy;\n    q.yz = rot2((lStartYZ + mod(lTotDist.z, 2.))*PI)*q.yz;\n\n    // Keep a global texture copy for texturing later. \n    gTxP = q; \n    \n    // Render the smooth edged rounded cube.\n    float bx = sBox(q, vec3(GSCALE.x/2.), .07);\n    bx = smax(bx, length(q) - GSCALE.x/2.*1.55, .1);\n    \n \n    // Overall object ID.\n    objID = (wall<d4.x && wall<bx)? 2 : d4.x<bx? 0 : 1;\n    \n    // Combining the wall with the extruded blocks.\n    return min(wall, min(d4.x, bx));\n \n}\n\n\n// Basic raymarcher.\nfloat trace(vec3 ro, vec3 rd){\n\n    // Overall ray distance and scene distance.\n    float t = 0., d; \n    \n    for(int i = 0; i<72; i++){\n    \n        d = map(ro + rd*t);\n        // Note the \"t*b + a\" addition. Basically, we're putting less emphasis on accuracy, as\n        // \"t\" increases. It's a cheap trick that works in most situations... Not all, though.\n        if(d*d<DELTA*DELTA || t>FAR) break; // Alternative: .001*max(t*.25, 1.), etc.\n        \n        t += i<32? d*.5 : d*.9; // Slower, but more accuracy.\n        //t += d*.7; \n    }\n\n    return min(t, FAR);\n}\n\n\n// Cheap shadows are hard. In fact, I'd almost say, shadowing particular scenes with limited \n// iterations is impossible... However, I'd be very grateful if someone could prove me wrong. :)\nfloat softShadow(vec3 ro, vec3 lp, vec3 n, float k){\n\n    // More would be nicer. More is always nicer, but not really affordable... Not on my slow test machine, anyway.\n    const int iter = 24; \n    \n    ro += n*.0015; // Bumping the shadow off the hit point.\n    \n    vec3 rd = lp - ro; // Unnormalized direction ray.\n\n    float shade = 1.;\n    float t = 0.; \n    float end = max(length(rd), 0.0001);\n    //float stepDist = end/float(maxIterationsShad);\n    rd /= end;\n    \n    //rd = normalize(rd + (hash33R(ro + n) - .5)*.03);\n    \n\n    // Max shadow iterations - More iterations make nicer shadows, but slow things down. Obviously, the lowest \n    // number to give a decent shadow is the best one to choose. \n    for (int i = 0; i<iter; i++){\n\n        float d = map(ro + rd*t);\n        shade = min(shade, k*d/t);\n        //shade = min(shade, smoothstep(0., 1., k*h/dist)); // Subtle difference. Thanks to IQ for this tidbit.\n        // So many options here, and none are perfect: dist += min(h, .2), dist += clamp(h, .01, stepDist), etc.\n        t += clamp(d, .01, .25); \n        \n        \n        // Early exits from accumulative distance function calls tend to be a good thing.\n        if (d<0. || t>end) break; \n    }\n\n    // Sometimes, I'll add a constant to the final shade value, which lightens the shadow a bit --\n    // It's a preference thing. Really dark shadows look too brutal to me. Sometimes, I'll add \n    // AO also just for kicks. :)\n    return max(shade, 0.); \n}\n\n\n// I keep a collection of occlusion routines... OK, that sounded really nerdy. :)\n// Anyway, I like this one. I'm assuming it's based on IQ's original.\nfloat calcAO(in vec3 p, in vec3 n){\n\n\tfloat sca = 2., occ = 0.;\n    for( int i = min(iFrame, 0); i<5; i++ ){\n    \n        float hr = float(i + 1)*.15/5.;        \n        float d = map(p + n*hr);\n        occ += (hr - d)*sca;\n        sca *= .7;\n        \n        // Deliberately redundant line that may or may not stop the \n        // compiler from unrolling.\n        if(sca>1e5) break;\n    }\n    \n    return clamp(1. - occ, 0., 1.);\n}\n\n\n// Standard normal function. It's not as fast as the tetrahedral calculation, but more symmetrical.\nvec3 getNormal(in vec3 p) {\n\t\n    const vec2 e = vec2(.001, 0);\n    \n    //vec3 n = normalize(vec3(map(p + e.xyy) - map(p - e.xyy),\n    //map(p + e.yxy) - map(p - e.yxy),\tmap(p + e.yyx) - map(p - e.yyx)));\n    \n    // This mess is an attempt to speed up compiler time by contriving a break... It's \n    // based on a suggestion by IQ. I think it works, but I really couldn't say for sure.\n    float sgn = 1.;\n    float mp[6];\n    vec3[3] e6 = vec3[3](e.xyy, e.yxy, e.yyx);\n    for(int i = min(iFrame, 0); i<6; i++){\n\t\tmp[i] = map(p + sgn*e6[i/2]);\n        sgn = -sgn;\n        if(sgn>2.) break; // Fake conditional break;\n    }\n    \n    return normalize(vec3(mp[0] - mp[1], mp[2] - mp[3], mp[4] - mp[5]));\n}\n\n\n\n// Render the dots on each face of each cube in the scene.\nfloat getDots(vec3 p, vec3 n){\n\n    // Choose the face. Based on some of Fizzer's cube mapping logic.\n    vec3 aN = abs(n);\n\n    ivec3 idF = ivec3(n.x<-.25? 0 : 5, n.y<-.25? 1 : 4, n.z<-.25? 2 : 3);\n\n    int face = aN.x>.5? idF.x : aN.y>.5? idF.y : idF.z; \n\n    float zDist = GSCALE.x/2.;\n    \n    vec2 tuv = p.xy; // Face UV coordinates.\n\n    // Render the face dots, according to face ID.\n    // How you go about this is up to you. There'd probably be more efficient\n    // ways, but this will do.\n    float dots = 1e5;\n    const float dSz = .0;\n    const float dsp = .12;\n    //if(face == 0)  dots = length(vec3(tuv, p.z + zDist)); // 3D -- Not needed.\n    if(face == 0)  dots = length(tuv);\n    else if(face == 1){\n        dots = min(length(tuv - dsp), length(tuv + dsp));\n        // 3D -- Not needed.\n        //dots = length(vec3(tuv - dsp, p.z + zDist));\n        //dots = min(dots, length(vec3(tuv + dsp, p.z + zDist)));\n    }\n    else if(face == 2){\n        dots = length(tuv);\n        dots = min(dots, min(length(tuv - dsp), length(tuv + dsp)));\n    }\n    else if(face == 3){\n        tuv = abs(tuv) - dsp;\n        dots = length(tuv);\n    } \n    else if(face == 4){\n        dots = length(tuv);\n        tuv = abs(tuv) - dsp;\n        dots = min(dots, length(tuv));\n\n    }     \n    else if(face == 5){\n        tuv.y = abs(tuv.y) - dsp;\n        dots = length(tuv);\n        tuv.x = abs(tuv.x) - (dsp + .02);\n        dots = min(dots, length(tuv));\n\n    } \n    \n    return dots - dSz;\n                \n}\n\n\n// A global value to record the distance from the camera to the hit point. It's used to tone\n// down the sand height values that are further away. If you don't do this, really bad\n// Moire artifacts will arise. By the way, you should always avoid globals, if you can, but\n// I didn't want to pass an extra variable through a bunch of different functions.\nfloat gT;\n\n// Surface bump function..\nfloat bumpSurf3D(in vec3 txP, in vec3 n){\n\n    \n    vec3 txN = n;\n     \n    vec3 tuv = vec3(0);\n    \n    // Background dice.\n    if(svObjID==0){  \n       \n        // Randomly rotate the faces.\n        float rndXY = hash21(svGID.yz);\n        float rndYZ = hash21(svGID.yz + .37);\n        float rndZX = hash21(svGID.yz + .71);\n        vec3 rSn = txN;\n        rSn.xy *= rot2(floor(rndXY*36.)*PI/2.);\n        rSn.yz *= rot2(floor(rndYZ*36.)*PI/2.);\n        rSn.xz *= rot2(floor(rndZX*36.)*PI/2.);\n        \n        // Select the UV coordinates from the dominant normal.\n        // If X is dominant, then select the YZ face, etc.\n        vec3 aN = abs(txN);\n        tuv = aN.x>.5? txP.yzx*vec3(1, 1, -1) :  aN.y>.5? txP.zxy*vec3(1, 1, -1) : txP.xyz*vec3(1, 1, -1);\n    \n        tuv = mod(tuv, GSCALE.x) - GSCALE.x/2.;\n        \n        txN = rSn;\n    \n    }\n    \n    // Moving die.\n    if(svObjID==1){\n    \n    \n        // Saved rotation data to rotated the normal to the \n        // correct position.\n       \n        if(abs(svPiv.x)>.01){\n             txN.xy = svMat*txN.xy;\n        }\n        else {\n             txN.yz = svMat*txN.yz;\n        }  \n       \n        // Overall rotation.\n        txN.xy = rot2(mod(lTotDist.x, 2.)*PI)*txN.xy;\n        txN.yz = rot2((mod(lStartYZ + lTotDist.z, 2.))*PI)*txN.yz;    \n \n        // Select the UV coordinates from the dominant normal.\n        // If X is dominant, then select the YZ face, etc.\n        vec3 aN = abs(txN);\n        tuv = aN.x>.5? txP.yzx :  aN.y>.5? txP.zxy : txP.xyz;\n        \n    }\n    \n    \n    \n    \n    // Rendering the dots on the faces.\n    float d = 1.;\n    \n    if(svObjID<2) {\n        d = getDots(tuv, txN); //sin(tuv.x*64.)*.5 + .5;//\n        \n        //tuv = mod(tuv - GSCALE.x/2., GSCALE.x) - GSCALE.x/2.;\n        //float sq = max(abs(tuv.x), abs(tuv.y)) - GSCALE.x/2. + .01;\n        //d = min(d, abs(sq));\n\n        d = smoothstep(0., .06, d);\n        \n        // Corrugated grooves... Why I thought this would work, I'll never know. :D\n        //d *= sin((tuv.x)*40.)*.04 + .96;\n        \n    }\n    \n    \n    // A surprizingly simple and efficient hack to get rid of the super annoying Moire pattern \n    // formed in the distance. Simply lessen the value when it's further away. Most people would\n    // figure this out pretty quickly, but it took far too long before it hit me. :)\n    return  d;//d/(1. + gT*gT*.015);\n   \n   \n}\n\n// Standard function-based bump mapping routine: This is the cheaper four tap version. There's\n// a six tap version (samples taken from either side of each axis), but this works well enough.\nvec3 doBumpMap(in vec3 p, in vec3 nor, float bumpfactor, inout float ref){\n\n\n    // Larger sample distances give a less defined bump, but can sometimes lessen the aliasing.\n    const vec2 e = vec2(0.001, 0);\n    \n    // It'd be nice to have elegant looking code, but in reality, it's all about \n    // hacks. The cube moves in relation to the rest of the scene, and needs \n    // to have it's relative position tracked for texturing purposes... \n    // And the relative sample offsets, it would appear... That's just painful. \n    // Not all coding is fun. :)\n    vec3 v0 = e.xyy;\n    vec3 v1 = e.yxy;\n    vec3 v2 = e.yyx;\n   \n    if(svObjID==1){\n    \n        p = svTxP;\n        \n        if(abs(svPiv.x)>.01){\n             v0.xy = svMat*v0.xy;\n             v1.xy = svMat*v1.xy;\n             v2.xy = svMat*v2.xy;\n        }\n        else {\n             v0.yz = svMat*v0.yz;\n             v1.yz = svMat*v1.yz;\n             v2.yz = svMat*v2.yz;\n        }  \n       \n        // Overall rotation.\n        v0.xy = rot2(mod(lTotDist.x, 2.)*PI)*v0.xy;\n        v0.yz = rot2((lStartYZ + mod(lTotDist.z, 2.))*PI)*v0.yz;    \n        v1.xy = rot2(mod(lTotDist.x, 2.)*PI)*v1.xy;\n        v1.yz = rot2((lStartYZ + mod(lTotDist.z, 2.))*PI)*v1.yz;    \n        v2.xy = rot2(mod(lTotDist.x, 2.)*PI)*v2.xy;\n        v2.yz = rot2((lStartYZ + mod(lTotDist.z, 2.))*PI)*v2.yz;\n        \n    }\n    \n     \n    \n    // Gradient vector: vec3(df/dx, df/dy, df/dz);\n    ref = bumpSurf3D(p, nor); // The reference value is returned for later use.\n    vec3 grad = (vec3(bumpSurf3D(p - v0, nor),\n                      bumpSurf3D(p - v1, nor),\n                      bumpSurf3D(p - v2, nor)) - ref)/e.x; \n    \n    /*\n    // Six tap version, for comparisson. No discernible visual difference, in a lot of cases.\n    vec3 grad = vec3(bumpSurf3D(p - e.xyy) - bumpSurf3D(p + e.xyy),\n                     bumpSurf3D(p - e.yxy) - bumpSurf3D(p + e.yxy),\n                     bumpSurf3D(p - e.yyx) - bumpSurf3D(p + e.yyx))/e.x*.5;\n    */\n       \n    // Adjusting the tangent vector so that it's perpendicular to the normal. It's some kind \n    // of orthogonal space fix using the Gram-Schmidt process, or something to that effect.\n    grad -= nor*dot(nor, grad);          \n         \n    // Applying the gradient vector to the normal. Larger bump factors make things more bumpy.\n    return normalize(nor + grad*bumpfactor);\n\t\n}\n\n/*\n// Texture bump mapping. Four tri-planar lookups, or 12 texture lookups in total. I tried to\n// make it as concise as possible. Whether that translates to speed, or not, I couldn't say.\nvec3 texBump( sampler2D tx, in vec3 p, in vec3 n, float bf){\n   \n    const vec2 e = vec2(.001, 0);\n    \n    // Three gradient vectors rolled into a matrix, constructed with offset greyscale texture values.    \n    mat3 m = mat3(tex3D(tx, p - e.xyy, n), tex3D(tx, p - e.yxy, n), tex3D(tx, p - e.yyx, n));\n    \n    vec3 g = vec3(.299, .587, .114)*m; // Converting to greyscale.\n    g = (g - dot(tex3D(tx,  p , n), vec3(.299, .587, .114)))/e.x; \n    \n    // Adjusting the tangent vector so that it's perpendicular to the normal -- Thanks to\n    // EvilRyu for reminding me why we perform this step. It's been a while, but I vaguely\n    // recall that it's some kind of orthogonal space fix using the Gram-Schmidt process. \n    // However, all you need to know is that it works. :)\n    g -= n*dot(n, g);\n                      \n    return normalize( n + g*bf ); // Bumped normal. \"bf\" - bump factor.\n\t\n}\n*/\n\n\n// Compact, self-contained version of IQ's 3D value noise function. I have a transparent noise\n// example that explains it, if you require it.\nfloat n3D(in vec3 p){\n    \n\tconst vec3 s = vec3(7, 157, 113);\n\tvec3 ip = floor(p); p -= ip; \n    vec4 h = vec4(0., s.yz, s.y + s.z) + dot(ip, s);\n    p = p*p*(3. - 2.*p); //p *= p*p*(p*(p * 6. - 15.) + 10.);\n    h = mix(fract(sin(h)*43758.5453), fract(sin(h + s.x)*43758.5453), p.x);\n    h.xy = mix(h.xz, h.yw, p.y);\n    return mix(h.x, h.y, p.z); // Range: [0, 1].\n}\n\n// FBM.\nfloat fBm(vec3 p){ return n3D(p)*.57 + n3D(p*2.)*.28 + n3D(p*4.)*.15; }\n\n// Very basic pseudo environment mapping... and by that, I mean it's fake. :) However, it \n// does give the impression that the surface is reflecting the surrounds in some way.\n//\n// More sophisticated environment mapping:\n// UI easy to integrate - XT95    \n// https://www.shadertoy.com/view/ldKSDm\nvec3 envMap(vec3 p){\n    \n    p *= 5.;\n    p.x += iTime/2.;\n    \n    float n3D2 = n3D(p*2.);\n   \n    // A bit of fBm.\n    float c = n3D(p)*.57 + n3D2*.28 + n3D(p*4.)*.15;\n    c = smoothstep(.4, 1., c); // Putting in some dark space.\n    \n    \n    //p = pow(min(vec3(1.4, 1, 1)*c, 1.), vec3(1, 3, 16)); // Fire.\n    p = vec3(c, c*c, c*c*c*c); // Orange tinge.\n   \n    p = mix(p, p.zyx, n3D2); // Mixing the color around.\n    \n    return p*p;\n\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n\n    \n    // Screen coordinates.\n\tvec2 uv = (fragCoord - iResolution.xy*.5)/iResolution.y;\n\t\n\n    // Ray origin.\n    float tm = iTime/12.;\n    vec3 ro = vec3(0, 5. + tm, -5. + tm); \n    // \"Look At\" position.\n    vec3 lk = ro + vec3(.18, -.15, .2);//vec3(0, -.25, iTime);  \n \n    // Light positioning.\n \tvec3 lp = ro + vec3(2.5, 1, 2.25); // Put near the camera.\n\t\n\n    // Using the above to produce the unit ray-direction vector.\n    float FOV = 1.; // FOV - Field of view.\n    vec3 fwd = normalize(lk - ro);\n    vec3 rgt = normalize(vec3(fwd.z, 0., -fwd.x )); \n    // \"right\" and \"forward\" are perpendicular, due to the dot product being zero. Therefore, I'm \n    // assuming no normalization is necessary? The only reason I ask is that lots of people do \n    // normalize, so perhaps I'm overlooking something?\n    vec3 up = cross(fwd, rgt); \n    \n \n    // Unit direction ray.\n    vec3 rd = normalize(uv.x*rgt + uv.y*up + fwd/FOV);\n    //vec3 rd = mat3(rgt, up, fwd)*normalize(vec3(uv, 1./FOV));\n    \n    // Camera position. Initially set to the ray origin.\n    vec3 cam = ro;\n    // Surface postion. Also initially set to the ray origin.\n    vec3 sp = ro; \n    \n    float gSh = 1.;\n    float objRef = 1.;\n     \n    vec3 col = vec3(0); \n    \n    float alpha = 1.;\n    \n    moveCube(tm);\n    \n    for(int j = 0; j<PASSES; j++){\n    \n         \n        // Layer or pass color. Each pass color gets blended in with\n        // the overall result.\n        vec3 colL = vec3(0);\n\n        // Used for refractions, but not here.    \n        //float distanceFactor = 1.;\n\n        \n        // Raymarch to the scene.\n        float t = trace(sp, rd);\n\n        // Saving the object ID, block ID and cell object (block part) ID.\n        svObjID = objID;\n        svGID = gID;\n        \n        // Saving the texture, pivot and rotaion matrices for the animated\n        // die on the surface.\n        svTxP = gTxP;\n        svPiv = gPiv;\n        svMat = gMat;\n        \n        //float svBounce = gBounce;\n\n\n        // Advance the ray to the surface. This becomes the new ray origin for the\n        // next pass.\n        sp += rd*t;\n        \n        \n        // If the ray hits a surface, light it up. By the way, it's customary to put \n        // all of the following inside a single function, but I'm keeping things simple.\n        // Blocks within loops used to kill GPU performance, but it doesn't seem to\n        // effect the new generation systems.\n      \n        if(t<FAR){\n\n            // Surface normal.\n            vec3 sn = getNormal(sp);// *distanceFactor; // For refractions.\n            \n            \n            // Function based bump mapping.\n            //\n            // The bump value at the hit point -- Used for later shading purposes.\n            float bumpShade; \n            sn = doBumpMap(sp, sn, .1, bumpShade);///(1. + t*t/FAR/FAR*.25)\n            \n            // Texture size factor.\n            float sz0 = 1./2.;\n           \n             \n            // Integrating bump mapping -- Not used here. It's possible\n            // to bump map on a pass by pass basis to save cycles.\n            //vec3 smSn = sn;\n            //sn = texBump(iChannel0, sp*sz0, sn, .005);///(1. + t/FAR)\n            //vec3 reflection = reflect(rd, normalize(mix(smSn, sn, .35)));\n             \n            \n            // The reflective ray, which tends to be very helpful when\n            // calculating reflections. :)\n            vec3 reflection = reflect(rd, sn);\n            \n            vec3 ld = lp - sp; // Point light direction.\n            float lDist = length(ld); // Surface to light distance.\n            ld /= max(lDist, .0001); // Normalizing.\n            \n            \n            // Shadows and ambient self shadowing.\n            //\n            // Shadows are expensive. It'd be nice to include shadows on each bounce,\n            // but it's still not really viable, so we just perform them on the \n            // first pass... Years from now, I'm hoping it won't be an issue.\n            if(j == 0) gSh = softShadow(sp, lp, sn, 8.);\n            float ao = calcAO(sp, sn); // Ambient occlusion.\n            float sh = min(gSh + .2, 1.); // Shadow.\n            \n\n            float att = 1./(1. + lDist*lDist*.1); // Attenuation.\n\n            float dif = max(dot(ld, sn), 0.); // Diffuse lighting.\n            float spe = pow(max(dot(reflection, ld), 0.), 8.);\n            float fre = clamp(1. + dot(rd, sn), 0., 1.); // Fresnel reflection term.\n            \n            dif = pow(dif, 4.)*2.; // Ramping up the diffuse.\n\n            float Schlick = pow( 1. - max(dot(rd, normalize(rd + ld)), 0.), 5.);\n            float freS = mix(.25, 1., Schlick);  //F0 = .2 - Glass... or close enough.\n\n      \n            // Object color.\n            vec3 oCol;\n            \n             \n            if(svObjID == 0) {\n\n                // Coloring the background dice.\n                float rnd2 = hash21(svGID.yz + floor(sp.y/GSCALE.x) + .3);\n                \n                // Block coloring.\n                vec3 tx = tex3D(iChannel0, sp*sz0, sn);\n                tx = smoothstep(-.05, .5, tx);\n                //tx = mix(tx, vec3(1)*dot(tx, vec3(.299, .587, .144)), .5);\n                oCol = tx*mix(vec3(.9, 1, 1.2).zyx, vec3(.9, 1, 1.2), tx.x);\n                oCol *= vec3(.85, 1, 1.2);\n                 \n                //oCol *= mix(vec3(.8, 1, 1.2), 1./vec3(.8, 1, 1.2), \n                // mod(svGID.y + svGID.z, 2.)<.5? 0. : 1.);\n                //float rnd = hash21(svGID.yz);\n                //vec3 rCol = .6 + .4*cos(6.2831*rnd/4. + vec3(0, 1, 2));\n               \n                //objRef = .25;\n                // Arrange for less reflection in the dice holes.\n                objRef = mix(.125, .25, smoothstep(0., .1, bumpShade));\n\n                \n            }\n            else if(svObjID == 1) {\n            \n                // Texture the colored moving die.\n                \n                // Saved texture value from the die movement function.\n                vec3 txP = svTxP;\n                \n                // Using the saved rotation matrices to rotate the face\n                // normal to the correct position.\n                vec3 txN = sn;\n \n                if(abs(svPiv.x)>.01){\n                      txN.xy = svMat*txN.xy;\n                }\n                else {\n                      txN.yz = svMat*txN.yz;\n                }\n               \n                // Overall rotation.\n                txN.xy = rot2(mod(lTotDist.x, 2.)*PI)*txN.xy;\n                txN.yz = rot2((mod(lStartYZ + lTotDist.z, 2.))*PI)*txN.yz;\n                   \n\n                // Block texturing and coloring.\n                vec3 tx = tex3D(iChannel0, txP*sz0, txN);\n                tx = smoothstep(-.05, .55, tx);\n                //tx = vec3(1)*dot(tx, vec3(.299, .587, .144));\n\n                //oCol = tx*vec3(1, .3, .5)*2.;\n                oCol = tx*mix(vec3(1, .42, .28).xzy, vec3(1, .42, .28), tx.x*1.1)*2.6;\n                //oCol = tx*vec3(.2, .58, 1)*2.6;\n        \n                \n                //vec3 aN = abs(txN);\n                //vec3 tuv = aN.x>.5? txP.yzx :  aN.y>.5? txP.zxy : txP.xyz;\n                //float sq = sBox(tuv.xy, vec2(GSCALE.x/2. - .07), .05);\n                //sq = abs(sq) - .02;\n                //oCol = mix(oCol, vec3(0), (1. - smoothstep(0., .003, sq))*.9);\n               \n                //objRef = .25;\n                // Arrange for less reflection in the dice holes.\n                objRef = mix(.125, .25, smoothstep(0., .1, bumpShade));\n\n                \n            }\n            else {\n                // Dark wall behind the tiny gaps in the blocks. \n                oCol = vec3(0);\n                objRef = .0;\n            }\n            \n \n\n            // Combining the diffuse, specular and Fresnel terms, if applicable.\n            colL = oCol*(dif + vec3(1, .7, .5)*spe*16. + .1);// + vec3(1, .7, .5).zyx*pow(freS, 2.)*2.;\n            \n            // Optional environmental mapping. Not used.\n            vec3 envCol = envMap(reflection);\n            //vec3 envCol = texture(iChannel1, reflection).xyz; envCol *= envCol;\n            colL += colL*envCol.zyx*8.;\n            \n            // Multiply the dice dots by the bump value for extra depth.\n            if(svObjID<2) colL *= bumpShade;\n            \n            // Combining it with the object color, then shading.\n            colL *= ao*att*sh;\n \n            \n            // Set the unit direction ray to the new reflected direction, and bump the \n            // ray off of the hit point by a fraction of the normal distance. Anyone who's\n            // been doing this for a while knows that you need to do this to stop self\n            // intersection with the current launch surface from occurring... It used to \n            // bring me unstuck all the time. I'd spend hours trying to figure out why my\n            // reflections weren't working. :)\n            rd = reflection;\n            sp += sn*DELTA*1.1;\n\n        }\n\n        // Fog: Redundant here, since the ray doesn't go far, but necessary for other setups.\n        float td = length(sp - cam); \n        vec3 fogCol = vec3(0);//mix(vec3(.1, .3, 1)/12., vec3(.25, .5, 1)/6., rd.y*.5 + .5);\n        colL = mix(colL, fogCol, smoothstep(0., .95, td/FAR));\n        \n        \n        // This is a more subtle way to blend layers. \n        //col = mix(col, min(colL, 1.), 1./float(1 + j)*alpha);\n        // In you face additive blend. Sometimes, I prefer this.\n        col += min(colL, 1.)*alpha;\n        \n        // If the hit object's reflective factor is zero, or the ray has reached\n        // the far horizon, break.\n        if(objRef<.001 || t >= FAR) break;\n        \n        // Decrease the alpha factor (ray power of sorts) by the hit object's reflective factor.\n        alpha *= objRef;\n    }\n   \n    \n    /*\n    // Cheap hash pattern. Needs work... Much more work. :)\n    float gry = dot(col, vec3(.299, .587, .114));\n    gry = sqrt(gry);\n    float pat = 1.;\n      \n    const int NN = 5;\n    const float fn = float(NN);\n    float lns = 200.*iResolution.y/450.;\n    float sf = 1./iResolution.y;\n    for(int i = 0; i<NN; i++){\n        \n        vec2 rp = rot2(3.14159/3. - float(i)*6.2831/fn/2.)*uv;\n        rp += float(i)/fn;\n        float patL = abs(fract((rp.x)*lns) - .5)*2. - .05;\n        \n        if(gry<(fn - float(i))/(fn + 1.)) pat = min(pat, patL);\n    }\n    \n    pat = smoothstep(0., sf*lns*2., pat);\n    col = vec3(pat*;\n    */\n    \n    // Rough gamma correction.\n    fragColor = vec4(sqrt(max(col, 0.)), 1);\n}", "image_inputs": [{"id": "4sXGRn", "previewfilepath": "/media/ap/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3sVBDd.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[3092, 3125, 3147, 3147, 3205], [3207, 3235, 3256, 3256, 3319], [3322, 3545, 3583, 3583, 3664], [3667, 3821, 3869, 4171, 5080], [5084, 5112, 5158, 5158, 5243], [5245, 5273, 5319, 5319, 5482], [5485, 5517, 5548, 5548, 5594], [5596, 5622, 5650, 5650, 5676], [6199, 6385, 6412, 6412, 8658], [8661, 8684, 8704, 8778, 10828], [10912, 10935, 10953, 11150, 12347], [12350, 12371, 12401, 12450, 12943], [12946, 13137, 13189, 13306, 14623], [14626, 14778, 14813, 14813, 15210], [15213, 15313, 15340, 15340, 16019], [16023, 16082, 16112, 16183, 17585], [17954, 17981, 18022, 18022, 20372], [20374, 20565, 20639, 20737, 22942], [24037, 24180, 24201, 24201, 24547], [24549, 24557, 24575, 24575, 24628], [24630, 24929, 24949, 24949, 25372], [25375, 25375, 25431, 25464, 35938]]}
{"id": "3t3yWf", "name": "warp neon", "author": "tono", "description": "neon", "tags": ["neon"], "likes": 0, "viewed": 73, "published": "Public", "date": "1609978391", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float pi = acos(-1.);\n\nmat2 rot(float a){return mat2(cos(a),sin(a),-sin(a),cos(a));}\n\nfloat random (vec2 st) {\n    return fract(sin(dot(st.xy,\n                         vec2(12.9898,78.233)))*\n        43758.5453123);\n}\n\nfloat map(vec3 p)\n{\t\n    vec3 p2 = p;\n    float o = 100.;\n    \n    p.z += iTime;\n   // for(float i = 0. ; i < 5. ; i+= 1.)\n    {\n       // p = p2;\n    \tp.xz += vec2(0.5);\n    \tp.xy *= rot( p.z/26.);\n    \tp.xy -= vec2(pi)/2.;\n    \tp = sin(p);\n   \t \tp = clamp(p ,.1 ,3.);\n   \t \tp = abs(p) - 1.1;\n    \to = min( length(p) - 1.,o);\n    }\n   \n    o *= .8; \n    return o;\n}\n\nfloat march(vec3 cp,vec3 rd)\n{\n    float depth = 0.;\n    for(int i = 0; i < 198 ;i++)\n    {\n        vec3 rp = cp + rd * depth;\n        float d = map(rp);\n        if(abs(d) < 0.01)\n        {\n            return depth;\n        }\n        if((depth) > 40.){break;}\n        depth += d;\n    }\n    depth *= -1.;\n    return depth;\n    \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 p = (fragCoord.xy * 2.0 - iResolution.xy) / min(iResolution.x, iResolution.y);\n\tvec3 col = vec3(0.);\n    \n    vec3 forward = vec3(0.,0.,0);\n    vec3 cp = vec3(0.,0.,-3.) + forward;\n   // cp.x += sin(time) * 1.;\n    vec3 target = vec3(0.) + forward;\n    vec3 cd = normalize(target - cp);\n    vec3 cu = normalize(cross(cd,vec3(0.,1.,0.)));\n    vec3 cs = normalize(cross(cd,cu));\n    \n    //float fov = mix(1.5 - dot(p,p),1. , abs(sin(time/10.))) ; \n    float fov = .5;\n    vec3 rd = normalize(cd* fov + cs * p.x + cu * p.y);\n    float d = march(cp,rd);\n    if(d > 0.)\n    {\n        vec2 e = vec2(0.,0.01);\n        vec3 pos = d * rd + cp;\n        vec3 N = -normalize(map(pos) - vec3(map(pos - e.xyy),map(pos - e.yxy),map(pos - e.yyx)));\n        vec3 sun = normalize(vec3(2.,4.,8.));\n        sun.xz *= rot(iTime);\n        float diff = max(dot(sun,N),0.);\n        col = diff * vec3(.8,.3,.6);\n        float sp = max(0.,dot(reflect(sun , N),cd ) ) * 1.1;\n        col = diff * vec3(.1,.1,.1) + pow(sp,24.) * vec3(1.);\n        float shadow = step(march(pos + N * 0.02,N),0.);\n        \n        col *= shadow;\n        //col += vec3(1.,0.,0.) * max(floor( sin(d - time * 4.) + .1),0.);\n        col += max(floor( sin(random(floor(pos.xy/pi))*15. + random(floor(pos.xy * pi))*3. + pos.z - iTime * vec3(2.,1.,2.)/2.)-.6 + .61),0.);\n        float dd =1. - exp(d * d * d * -.0003);\n        col = mix(col,vec3(0.,0.,0.),dd);\n    }\n    \n    fragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3t3yWf.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[23, 23, 41, 41, 84], [86, 86, 110, 110, 217], [219, 219, 238, 238, 585], [587, 587, 617, 617, 915], [917, 917, 974, 974, 2436]]}
{"id": "3t3yWj", "name": "Vaporwave-genuary day5", "author": "TheConfusedCyborg", "description": "A codegolfed swirl of color", "tags": ["codegolf", "vaporwave", "genuary"], "likes": 1, "viewed": 34, "published": "Public", "date": "1609866650", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage(out vec4 fragColor,in vec2 fragCoord){vec2 p=2.*fragCoord/iResolution.xy-1.;float n=iTime;vec2 l=round(p*2.)/2.;p+=sin(n/9.*l);float r=length(p);float o=mod(atan(p.y,p.x)+n,6.)/6.;vec3 c=vec3(r,mod(r,o*.5*sin(n/9.)+o),o);c.rg-=sin(n*l)*cos(n);fragColor=vec4(c,1.);}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3t3yWj.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 53, 53, 280]]}
{"id": "3tcBRn", "name": "flower clock ", "author": "YitingLiu", "description": "psychedelic flower clock moving as time goes by. ", "tags": ["noise", "time", "time", "clock", "flower", "random", "rotate", "psychedelic", "shape", "thickness", "changingcolor", "shapeborder"], "likes": 1, "viewed": 185, "published": "Public API", "date": "1612026063", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//psychedelic flower clock moving as time goes by. \n\nvec2 random2(vec2 st){\n    st = vec2( dot(st,vec2(127.1,311.7)),\n              dot(st,vec2(269.5,183.3)) );\n    return -1.0 + 2.0*fract(sin(st)*43758.5453123);\n}\nfloat random (in vec2 _st) {\n    return fract(sin(dot(_st.xy,\n                         vec2(12.9898,78.233)))*\n        43758.5453123);\n}\n// Gradient Noise by Inigo Quilez - iq/2013\n// https://www.shadertoy.com/view/XdXGW8\nfloat noise(vec2 st) {\n    vec2 i = floor(st);\n    vec2 f = fract(st);\n\n    vec2 u = f*f*(3.0-2.0*f);\n\n    return mix( mix( dot( random2(i + vec2(0.0,0.0) ), f - vec2(0.0,0.0) ),\n                     dot( random2(i + vec2(1.0,0.0) ), f - vec2(1.0,0.0) ), u.x),\n                mix( dot( random2(i + vec2(0.0,1.0) ), f - vec2(0.0,1.0) ),\n                     dot( random2(i + vec2(1.0,1.0) ), f - vec2(1.0,1.0) ), u.x), u.y);\n}\n\nmat2 rotate2d(float _angle){\n    return mat2(cos(_angle),-sin(_angle),\n                sin(_angle),cos(_angle));\n}\n\nfloat shape(vec2 st, float radius) {\n\tst = vec2(0.5)-st;\n    float r = length(st)*2.0;\n    float a = atan(st.y,st.x);\n    float m = abs(mod(a+iTime*2.,3.14*2.)-3.14)/3.6;\n    float f = radius;\n    m += noise(st+iTime*0.1)*0.972;\n     a *= 1.0+abs(atan(iTime*-0.376))*0.1;\n    // a *= 1.+noise(st+u_time*0.1)*0.1;\n    f += sin(a*10.)*noise(st+iTime*.2)*.1;\n    f += (sin(a*19.312)*.1*pow(m,2.));\n    return 1.-smoothstep(f,f+0.007,r);\n}\n\nfloat shapeBorder(vec2 st, float radius, float width) {\n    return shape(st,radius)-shape(st,radius-width);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n {\n\tvec2 st = fragCoord.xy/iResolution.xy;\n    vec3 changingCol = vec3(random(st),noise(st),abs(cos(sin(iTime))));\n    changingCol*=abs(sin(iTime));\n    vec3 color = vec3(changingCol) * shapeBorder(st,1.,abs(tan(iTime*.05)));\n    st-=0.5;\n\n    st*=rotate2d(iTime*3.1415/2.);\n        color/=st.y+st.x*sin(iTime*0.5)*1e1;\n        color/=st.x+st.x*sin(iTime*0.05)*1e1;\n    color-=random(st);\n\n    st+=0.5;\n\n    color += vec3(changingCol*random(st)) * shapeBorder(st,0.8,abs(tan(iTime*.05*0.2)));\n\t color += vec3(changingCol-noise(st)) * shapeBorder(st,0.6,abs(tan(iTime*.05)*0.4));\n\t color += vec3(changingCol+noise(st)) * shapeBorder(st,0.4,abs(tan(iTime*.05)*0.6));\n\t color += vec3(changingCol/random(st)*random(st*0.5)) * shapeBorder(st,0.2,abs(tan(iTime*.05)*0.8));\n\n\tfragColor = vec4( abs(sin(iTime))/color-noise(st), 1.0 );\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3tcBRn.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 53, 75, 75, 214], [215, 215, 243, 243, 351], [352, 437, 459, 459, 863], [865, 865, 893, 893, 979], [981, 981, 1017, 1017, 1416], [1418, 1418, 1473, 1473, 1527], [1529, 1529, 1587, 1587, 2413]]}
{"id": "3tccWf", "name": "Uniform 3D Euclidean Honeycombs", "author": "neozhaoliang", "description": "3D Wythoffian uniform honeycombs and their duals in Euclidean space, a flythrough version.", "tags": ["3d", "geometry", "honeycomb", "coxeter", "group", "tiling", "euclidean", "symmetry"], "likes": 18, "viewed": 1159, "published": "Public API", "date": "1609987591", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/*\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nUniform honeycombs and their duals\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nThis is a simple program draws uniform honeycombs and their duals in 3D Euclidean space:\n\n    \"https://en.wikipedia.org/wiki/Convex_uniform_honeycomb\"\n    \nThe main rendering procedure is shamelessly taken from @shane's work at\n    \n        https://www.shadertoy.com/view/4l2cD3\n        \n(I like the steel effect appeared in lots of his examples)\n\nAlso the honeycomb data are taken from @mla's work at\n\n        https://www.shadertoy.com/view/WsfcRn\n        \nI must thank @mla for those helpful discussions with him.\n\n@mla's code is a great reference for general Wythoff construction, it saved me lots of\nhard (or even boring) computations. If you have any difficulties understanding this code,\nrefer to mla's version, the ideas are the same.\n\nThe most difficult part in this program is when one is trying to render octagonal edges (or other prism-like\nshapes) instead of cylinder edges. Since in Wythoff construction, one needs to reflect a point p\nrepeatly until it falls into the fundamental domain, and estimate distance in the\nfundamental domain. But distance field to octagonal shapes are generally not preserved under\nreflections/rotations, so when two points are folded into the same location in the fundamental domain by\ndifferent transformations, then mismatches in the scene appear. Handling such cases took me 90% of\nthe time. My solution is quite brute-force: just render more copies of the fundamental domain.\nFor the affine A3 honeycombs the compiling time is a bit longer, but anyway the results look correct.\n*/\n\n// Honeycomb type. 0 for affine A3, 1 for affine B3, 2 for affine C3\n#define LATTICE   0\n\n// use another color style\n#define GOLD_STYLE\n\n// render the dual honeycomb?\n//#define DUAL\n\n// Barycentric coordinates of the initial vertex v0 in the fundamental tetrahedron.\n// This determines the truncation type of the honeycomb.\nconst vec4 T = vec4(1, 1, 0, 1);\n\n// initial vertex\nvec3 v0;\n\n// M is the four reflection mirrors of the fundamental tetrahedron,\n// M_inv is the inverse of M.\nmat4 M, M_inv;\n\n// The four vertices of the fundamental tetrahedron and the four mirror images of v0 about\n// the four mirrors\nmat4x3 V, E;\n\nconst float tbsize = 0.055;\n\n// object id\nvec3 objIDs;\n\nfloat glow;\n\nvec3 do_reflect(vec3 p, vec4 n) {\n    vec4 q = vec4(p, 1.);\n    return p - 2. * dot(q, n) * n.xyz;\n}\n\nvec3 rA(vec3 p) { return do_reflect(p, M[0]); }\nvec3 rB(vec3 p) { return do_reflect(p, M[1]); }\nvec3 rC(vec3 p) { return do_reflect(p, M[2]); }\nvec3 rD(vec3 p) { return do_reflect(p, M[3]); }\n\n\nvoid init() {\n\n    const float s = 0.70710678;    // sqrt(2) / 2\n\n#if LATTICE == 0\n    // affine A3 lattice\n    //\n    // A     C\n    //  o---o\n    //  |   |\n    //  o---o\n    // D     B\n    M = mat4(vec4(-s, -s, 0, 2.*s),\n             vec4(s, -s, 0, 0),\n             vec4(0, s, -s, 0),\n             vec4(0, s, s, 0));\n             \n    V = mat4x3(vec3(0, 0, 0),\n               vec3(2, 0, 0),\n               vec3(1, 1, -1),\n               vec3(1, 1, 1));\n\n#elif LATTICE == 1\n    // affine B3 lattice\n    //          C\n    //         o\n    //     4  /\n    // A o---o B\n    //        \\\n    //         o\n    //          D\n    M = mat4(vec4(0, 0, 1, 0),\n             vec4(0, s, -s, 0),\n             vec4(s, -s, 0, 0),\n             vec4(-s, -s, 0, 2.*s));\n             \n    V = mat4x3(vec3(1, 1, 1),\n               vec3(1, 1, 0),\n               vec3(2, 0, 0),\n               vec3(0, 0, 0));\n\n// affine C3 lattice\n#else\n    //   4       4\n    // o---o---o---o\n    // A   B   C   D\n    M = mat4(vec4(0, 0, 1, 0),\n             vec4(0, s, -s, 0),\n             vec4(s, -s, 0, 0),\n             vec4(-1, 0, 0, 1));\n    \n    V = mat4x3(vec3(0, 0, 0),\n               vec3(1, 0, 0),\n               vec3(1, 1, 0),\n               vec3(1, 1, 1));\n\n#endif\n\n    M_inv = inverse(M);\n    vec4 v4 = T * M_inv;\n    v4 /= v4.w;\n    v0 = v4.xyz;\n    for (int i = 0; i < 4; i++) {\n        E[i] = v0 - 2. * dot(v4, M[i]) * M[i].xyz;\n    }\n}\n\n\n#define FAR     80.\n#define PI      3.141592654\n\nfloat sgn(float x) { return x > 0. ? 1. : -1.; }\n\n// Camera path as a function of time t.\n// I think it's unlikely to devise an universal path that flies through all\n// honeycombs without hitting the lattice.\nvec3 camPath(float t) { return vec3(t, t, t) / 2.; }\n\n// A mirror is active if and only if the initial vertex v0 is not on it,\n// or equivalently, the barycentric coordinate with respect to this mirror is non-zero.\nbool isActive(int k) { return T[k] != 0.0; }\n\n// try to reflect a point p about mirror with normal `n`, if p and the fundamental domain\n// are on the different sides of the mirror\nvec4 try_reflect(vec4 p, vec4 n, inout int flips) {\n    float k = dot(p, n);\n    if (k < 0.) {\n        flips += 1;\n        p.xyz -= 2. * k * n.xyz;\n    }\n    return p;\n}\n\nvec2 rot2d(vec2 p, float a) { return cos(a) * p + sin(a) * vec2(p.y, -p.x); }\n\n\n// fold a point p into the fundamental domain.\n// we return the final position of p, but also track an intermediate state of p for\n// handling dual cases.\nvec3 fold(inout vec3 p, inout int flips) {\n    \n    vec4 q;\n\n#if LATTICE == 0\n\n    p = mod(p + 2., 4.) - 2.;\n    q = vec4(p, 1);\n    for (int i = 0; i < 4; i++) {\n        for (int j = 0; j < 4; j++) {\n            q = try_reflect(q, M[j], flips);\n        }\n    }\n\n#elif LATTICE == 1\n   \n    p = mod(p + 2., 4.) - 2.;\n    flips += int(p.x < 0.0) + int(p.y < 0.0) + int(p.z < 0.0);\n    p = abs(p);\n    q = vec4(p, 1);\n    for (int i = 0; i < 2; i++) {\n        q = try_reflect(q, M[3], flips);\n        q = try_reflect(q, M[2], flips);\n        q = try_reflect(q, M[1], flips);\n    }\n    \n#else\n\n    p = mod(p + 1., 2.) - 1.;\n    flips += int(p.x < 0.0) + int(p.y < 0.0) + int(p.z < 0.0);\n    p = abs(p);\n    q = vec4(p, 1.);\n    q = try_reflect(q, M[1], flips);\n    q = try_reflect(q, M[2], flips);\n    q = try_reflect(q, M[1], flips);\n\n#endif\n\n    return q.xyz;\n}\n\n\n// Shane's tex3D function\nvec3 tex3D(sampler2D t, in vec3 p, in vec3 n) {\n    n = max(abs(n), 0.001);\n    n /= dot(n, vec3(1));\n\tvec3 tx = texture(t, p.yz).xyz;\n    vec3 ty = texture(t, p.zx).xyz;\n    vec3 tz = texture(t, p.xy).xyz;\n    return (tx*tx*n.x + ty*ty*n.y + tz*tz*n.z);\n}\n\n// I hacked this function to rotate any edge (a, b) to z-axis\nmat3 rotAxis(vec3 n) {\n    n = normalize(n);\n    vec3 x;\n    if (n.x == 0.)\n        x = vec3(1, 0, 0);\n    else\n        x = normalize(vec3(-n.y, n.x, 0.));\n    vec3 y = cross(n, x);\n    return mat3(x, y, n);\n}\n\n\nfloat tube(vec2 p, float sc, float rad) {\n    return max(max(p.x, p.y), (p.x + p.y)*sc) - rad;\n}\n\n\n// draw an edge with two ends at a, b.\nvec3 dSegment(vec3 p, vec3 a, vec3 b) {\n    // set local origin at middle point of the edge\n    vec3 m = (a + b) / 2.;\n    p -= m;\n    b -= m;\n    a -= m;\n    vec3 h = (b - a) / 2.;\n    float L = length(h); // length of half the edge\n\n    p = p * rotAxis(h);  // reorient the edge along with z-axis\n    p = abs(p);\n\n    // the main tube, currently this has infinite length\n    float tb;\n    tb = tube(p.xy, 0.75, tbsize);\n\n    float band = 1e5;\n    float innerTb = 1e5;\n    \n    // add a band of 1/4 length of the edge\n    band = max(tb - 0.0075, p.z - L/4.);\n    \n    // trick: rotate p to make two smaller tubes\n    // remove them from the main tube to make the holes\n    float psize = tbsize  / 1.5;\n    vec2 peg = vec2(tube(p.xz, .64, psize), tube(p.yz, .64, psize));\n    float hole = min(peg.x, peg.y);\n    \n    // use planes to cut the band\n    float dp1 = max(peg.x, p.y - tbsize - .0095); dp1 = max(dp1, p.y - L / 4.);\n    float dp2 = max(peg.y, p.x - tbsize - .0095); dp2 = max(dp2, p.x - L / 4.);\n    band = min(band, min(dp1, dp2));\n    \n    // make holes on the main tube\n    tb = max(tb, -(hole - .015));\n    \n    // cut the infinite main tube at the two ends\n    tb = max(tb, p.z - L);\n    \n    // make holes on the band\n    band = max(band, -(hole + .0125));\n    \n    // use sphere to create a fake inner tube\n    innerTb = length(p) - tbsize;\n    \n    return vec3(tb, band, innerTb);\n}\n\n// This function is only used for handling dual of A3 honeycombs.\n// verts[4] are four non-adjacent vertices of a cube, so each face of the cube\n/// contains exactly one pair of vertices in verts[4].\n// For p a point in the cube, we find this pair of vertices so that p is nearest to\n// the face contains this pair among all six faces.\nvoid findVertexPair(vec3 p, vec3 verts[4], out int i1, out int j1) {\n    float d = 1e5;\n    float d1;\n    for (int i = 0; i < 4; i++) {\n        for (int j = i+1; j < 4; j++) {\n            // (verts[i] + verts[j]) / 2. is the center of the face since they form a diagonal pair.\n            d1 = length(p - (verts[i] + verts[j]) / 2.);\n            if (d1 < d) {\n                i1 = i;\n                j1 = j;\n                d = d1;\n            }\n        }\n    }\n}\n\n\nfloat map(vec3 p) {\n    vec3 dedge = vec3(1e5);\n    vec3 p0 = p;\n    int flips = 0;\n    p = fold(p0, flips);\n\n// For the usual uniform honeycomb just render the edges, that's safe since they lie inside\n// the fundamental tetrahedron.\n#ifndef DUAL\n\n    for (int i = 0; i < 4; i++) {\n         dedge = min(dedge, dSegment(p, v0, E[i]));\n    }\n   \n#else\n    /*\n    Render the dual honeycomb.\n\n    In the dual honeycomb two cells are adjacent if and only if they share a common face.\n        \n    For two mirrors A, B they generate a non-degenerate face if and only if either\n    of below holds:\n        \n        1. A, B are perpendicular and they are both active\n        2. A, B are not perpendicular and at least one of them is active\n        \n    For such a face we further check if {A, B, C} and {A, B, D} both generate non-degenerate cells.\n\n    1. If {A, B, C} and {A, B, D} are both non-degenerate, (C, D) form an edge in the dual honeycomb.\n    2. If {A, B, D} degenerates to a face, (D, 2*C-D) form an edge in the dual honeycomb.\n    3. If both {A, B, C} and {A, B, D} are degenerate, no edge between C and D.\n    */\n\n    // The C3 honeycomb is the easiest, handle this case first.\n    //   4       4\n    // o---o---o---o\n    // A   B   C   D\n    #if LATTICE == 2\n        // if either A or B is active, then {A, B} generate a face and {A, B, C} is a\n        // non-degenerate cell. {A, B, D} is non-degenerate iff D is active.\n        // Other procedures below are all similar.\n        if (isActive(0) || isActive(1)) {\n            if (isActive(3))\n                dedge = min(dedge, dSegment(p, V[2], V[3]));\n            else\n                dedge = min(dedge, dSegment(p, V[3], 2.*V[2]-V[3]));\n        }\n        if (isActive(0) && isActive(2)) dedge = min(dedge, dSegment(p, V[1], V[3]));\n        if (isActive(1) || isActive(2)) dedge = min(dedge, dSegment(p0, V[0], V[3]));\n        if (isActive(0) && isActive(3)) dedge = min(dedge, dSegment(p, V[1], V[2]));\n        if (isActive(1) && isActive(3)) dedge = min(dedge, dSegment(p, V[0], V[2]));\n        if (isActive(2) || isActive(3)) {\n            if (isActive(0))\n                dedge = min(dedge, dSegment(p, V[1], V[0]));\n            else\n                dedge = min(dedge, dSegment(p, V[0], 2.*V[1]-V[0]));\n        }\n \n    #elif LATTICE == 1\n\n        if (isActive(0) || isActive(1)) dedge = min(dedge, dSegment(p, V[2], V[3]));\n        if (isActive(0) && isActive(2)) {\n            if (isActive(3))\n                dedge = min(dedge, dSegment(p, V[1], V[3]));\n            else\n                dedge = min(dedge, dSegment(p, V[3], 2.*V[1]-V[3]));\n        }\n        // trick: the edge (V[0], V[3]) does not lie inside the fundamental domain hence octahedral\n        // shapes won't work. we render its 4 copies in the cube [0, 0, 0] x [2, 2, 2].\n        if (isActive(1) || isActive(2)) {\n            dedge = min(dedge, dSegment(p0, V[0], V[3]));\n            dedge = min(dedge, dSegment(p0, V[0], vec3(2, 2, 0)));\n            dedge = min(dedge, dSegment(p0, V[0], vec3(2, 0, 2)));\n            dedge = min(dedge, dSegment(p0, V[0], vec3(0, 2, 2)));\n        }\n        \n        if (isActive(0) && isActive(3)) {\n            if (isActive(2))\n                dedge = min(dedge, dSegment(p, V[1], V[2]));\n            else\n                dedge = min(dedge, dSegment(p, V[2], 2.*V[1]-V[2]));\n        }\n        if (isActive(1) || isActive(3)) {\n            dedge = min(dedge, dSegment(p0, V[0], V[2]));\n            dedge = min(dedge, dSegment(p0, V[0], vec3(0, 2, 0)));\n            dedge = min(dedge, dSegment(p0, V[0], vec3(0, 0, 2)));\n            dedge = min(dedge, dSegment(p0, V[0], vec3(2, 2, 2)));\n        }\n        if (isActive(2) && isActive(3)) {\n            if (isActive(1))\n                dedge = min(dedge, dSegment(p, V[1], V[0]));\n            else\n                dedge = min(dedge, dSegment(p, V[0], 2.*V[1]-V[0]));\n        } \n    \n    #else\n        // The duals of A3 honeycombs are the most difficult. Recall p0 is now in [-2, -2, -2] x [2, 2, 2].\n        // We use a completely different way to render them. The idea is, vertices of the A3 regular honeycombs\n        // are integer lattices points (i, j, k) with:\n        // i + j + k = 0 mod 4 for V0\n        // i + j + k = 2 mod 4 for V1\n        // i + j + k = 1 mod 4 for V2\n        // i + j + k = 3 mod 4 for V3\n     \n        // find the center of the 2x2x2 cube that p belongs to\n        vec3 C = vec3(sgn(p0.x), sgn(p0.y), sgn(p0.z));\n        \n        float k = mod(C.x + C.y + C.z, 4.);\n        // if k = 1 mod 4, then the center of this cube is congruent to V[2] of the fundamental tetrahedron.\n        // else k = 3 mod 4 and the center is congruent to V[3].\n        int type = (k == 1.) ? 2 : 3;\n        \n        vec3 V0[4];  // holds the vertices of this 2x2x2 cube that are congruent to V[0]\n        vec3 V1[4];  // holds the vertices of this 2x2x2 cube that are congruent to V[1]\n        \n        if (type == 2) {\n            V0[0] = C + vec3(1, 1, 1);\n            V0[1] = C + vec3(-1, -1, 1);\n            V0[2] = C + vec3(1, -1, -1);\n            V0[3] = C + vec3(-1, 1, -1);\n            V1[0] = C + vec3(1, -1, 1);\n            V1[1] = C + vec3(-1, 1, 1);\n            V1[2] = C + vec3(1, 1, -1);\n            V1[3] = C + vec3(-1, -1, -1);\n        }\n        else {  // switch the role of V0, V1 above\n            V1[0] = C + vec3(1, 1, 1);\n            V1[1] = C + vec3(-1, -1, 1);\n            V1[2] = C + vec3(1, -1, -1);\n            V1[3] = C + vec3(-1, 1, -1);\n            V0[0] = C + vec3(1, -1, 1);\n            V0[1] = C + vec3(-1, 1, 1);\n            V0[2] = C + vec3(1, 1, -1);\n            V0[3] = C + vec3(-1, -1, -1);\n        }\n        \n        int r0, s0, r1, s1;\n        findVertexPair(p0, V0, r0, s0);\n        findVertexPair(p0, V1, r1, s1);\n        vec3 P0 = V0[r0] + V0[s0] - C;\n        vec3 P1 = V1[r1] + V1[s1] - C;\n\n        if (isActive(2) && isActive(3)) dedge = min(dedge, dSegment(p, V[0], V[1]));\n        if (isActive(1) || isActive(3)) {\n            if (type == 2) {\n                dedge = min(dedge, dSegment(p0, C, V0[r0]));\n                dedge = min(dedge, dSegment(p0, C, V0[s0]));\n            }\n            else {\n                dedge = min(dedge, dSegment(p0, P0, V0[r0]));\n                dedge = min(dedge, dSegment(p0, P0, V0[s0]));\n            }\n        }\n        if (isActive(1) || isActive(2)) {\n            if (type == 3) {\n                dedge = min(dedge, dSegment(p0, C, V0[r0]));\n                dedge = min(dedge, dSegment(p0, C, V0[s0]));            \n            }\n            else {\n                dedge = min(dedge, dSegment(p0, P0, V0[r0]));\n                dedge = min(dedge, dSegment(p0, P0, V0[s0]));\n            }\n        }\n        if (isActive(0) || isActive(3)) {\n            if (type == 2) {\n                dedge = min(dedge, dSegment(p0, C, V1[r1]));\n                dedge = min(dedge, dSegment(p0, C, V1[s1]));\n            }\n            else {\n                dedge = min(dedge, dSegment(p0, P1, V1[r1]));\n                dedge = min(dedge, dSegment(p0, P1, V1[s1]));\n            }\n        }\n        if (isActive(0) || isActive(2)) {\n            if (type == 3) {\n                dedge = min(dedge, dSegment(p0, C, V1[r1]));\n                dedge = min(dedge, dSegment(p0, C, V1[s1]));\n            }\n            else {\n                dedge = min(dedge, dSegment(p0, P1, V1[r1]));\n                dedge = min(dedge, dSegment(p0, P1, V1[s1]));\n            }\n        }\n        if (isActive(0) && isActive(1)) dedge = min(dedge, dSegment(p, V[2], V[3]));\n\n    #endif\n#endif\n\n    // store the object ids.\n    objIDs = dedge;\n    return min(dedge.x, min(dedge.y, dedge.z));\n}\n\n\n// This reduces the compiling time to about 7x times faster\nvec3 calcNormal(vec3 p, inout float edge, float t) {\n    float eps = 1./mix(400., iResolution.y, .5)*(1. + t*.5);\n    float d = map(p);\n    vec3 e = vec3(eps, 0, 0);\n    vec3 da = vec3(-2.*d);\n    for(int i = min(iFrame, 0); i < 3; i++ ) {\n        for(int j = min(iFrame, 0); j < 2; j++)\n            da[i] += map(p + e * float(1 - 2*j));\n        e = e.zxy;\n    }\n    da = abs(da);\n\n    edge = da.x + da.y + da.z;\n    edge = smoothstep(0., 1., sqrt(edge/e.x*2.));\n\n    vec3 n = vec3(0.0);\n    for(int i=min(iFrame, 0); i<4; i++) {\n        vec3 e = .57735*(2.*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1)) - 1.);\n        n += e*map(p + .001*e);\n    }\n    return normalize(n);\n}\n\n\nfloat softShadow(vec3 ro, vec3 lp, float tmin, float tmax, float k) {\n    const int maxShadeIterations = 32;\n    vec3 rd = lp - ro;\n    rd /= max(length(rd), 1e-4);\n    float shade = 1.0;\n    float t = tmin;\n    for (int i = 0; i < maxShadeIterations; i++) {\n        float h = map(ro + rd * t);\n        t += clamp(h, 0.01, 0.2);\n        shade = min(shade, smoothstep(0., 1., k * h / t));\n        if (abs(h) < 1e-4 || t > tmax)\n            break;\n    }\n    return min(max(shade, 0.) + .1, 1.);\n}\n\nfloat calcAO(vec3 p, vec3 n) {\n    float occ = 0.0;\n    float sca = 1.0;\n    for (int i = 0; i < 5; i++) {\n        float h = 0.01 + 0.15 * float(i) / 4.0;\n        float d = map(p + h * n);\n        occ += (h - d) * sca;\n        sca *= 0.7;\n    }\n    return clamp(1.0 - occ, 0.0, 1.0);\n}\n\n\nfloat trace(in vec3 ro, in vec3 rd) {\n    glow = 0.;\n    float ah;\n    const float precis = 1e-3;\n    float t = 0.0;\n    for (int i = 0; i < 128; i++) {\n        float h = map(ro + rd * t);\n        ah = abs(h);\n        glow += 1./(1. + ah*ah*8.);\n        if (ah < (t * 0.125 + 1.) * precis || t > FAR)\n            break;\n        t += h;\n    }\n    return min(t, FAR);\n}\n\n\nvec3 transform(in vec3 p) {\n    if (iMouse.x > 0.0) {\n        float phi =   (2.0*iMouse.x - iResolution.x) / iResolution.x * PI;\n        float theta = (2.0*iMouse.y - iResolution.y) / iResolution.y * PI;\n        p.yz = rot2d(p.yz, theta);\n        p.zx = rot2d(p.zx, -phi);\n    }\n    return p;\n}\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    init();\n\n    vec2 uv = (2.0 * fragCoord.xy - iResolution.xy) / iResolution.y;\n    \n    vec3 up = vec3(0, 1, 0);\n    vec3 ro = camPath(iTime * 1.1);\n    ro = transform(ro);\n    vec3 lookat = camPath(iTime * 1.1 + 0.1);\n    \n    vec3 forward = normalize(lookat - ro);\n    vec3 right = normalize(cross(forward, up));\n    up = cross(right, forward);\n    vec3 rd = normalize(uv.x * right + uv.y * up + forward * 2.);\n    rd = transform(rd);\n    vec3 lp = ro + vec3(-1, 2, -1);\n    vec3 col = vec3(0);\n    \n    float t = trace(ro, rd);\n    \n    float objID = (objIDs.x < objIDs.y && objIDs.x < objIDs.z) ? 0. : (objIDs.y < objIDs.z) ? 1. : 2.;\n    \n    if (t < FAR) {\n        float ed;\n        vec3 pos = ro + t * rd;\n        vec3 nor = calcNormal(pos, ed, t);\n\n        vec3 oCol;\n        #ifndef GOLD_STYLE\n        vec3 bCol = mix(vec3(1, .1, .5).zyx,\n                        vec3(1, .3, .1).zyx,\n                        dot(sin(pos*8. - cos(pos.yzx*4. + iTime*4.)), vec3(.166)) + .5);\n        #else\n        vec3 bCol = mix(vec3(1, .5, .1),\n                        vec3(1, .1, .2),\n                        dot(sin(pos*8. - cos(pos.yzx*4. + iTime*4.)), vec3(.166)) + .5);\n        #endif\n        if(objID < .5)\n            oCol = mix(bCol, vec3(1), .97);\n        \n        else if (objID > 1.5)\n            oCol = mix(bCol, vec3(1), .05) + bCol*2.;\n        \n        else\n            oCol = mix(bCol, vec3(1.35), .97)*vec3(1.1, 1, .9);\n\n        vec3 tx = tex3D(iChannel0, pos*2., nor);\n        tx = smoothstep(.0, .5, tx)*2.;\n\n        if(objID < 1.5)\n            oCol *= tx;\n        else\n            oCol *= mix(vec3(1), tx, .5);\n\n        float ao = calcAO(pos, nor);\n        float sh = softShadow(pos + nor*.002, lp, 0.001, 16., t);\n\n        vec3 ld = lp - pos;\n        float dist = max(length(ld), 0.001);\n        ld /= dist;\n\n        float atten = 3./(1. + dist*0.05 + dist*dist*0.025);\n\n        float diff = max(dot(ld, nor), 0.);\n        if (objID < 1.5)\n            diff = pow(diff, 4.)*2.;\n        float spec = pow(max(dot( reflect(ld, nor), rd), 0.0 ), 32.0);\n\n        col = oCol*(diff + .25) + mix(bCol.zyx, vec3(1, .7, .3), .5)*spec*4.;\n\n        col += .015/max(abs(.05 - map(pos*1.5 + sin(iTime/6.))), .01)*oCol*mix(bCol, vec3(1, .8, .5), .35);\n\n        // Adding a bit of glow. It was tempting to get my money's worth, but I kept it subtle. :)\n        if(objID < 1.5)\n            col += bCol*glow*.02;\n        else\n            col += bCol*glow*1.5;\n\n        // Applying the dark edges, attenuation, shadows and ambient occlusion.\n        col *= (1. - ed*.7);\n        col *= atten*(sh + ao*.25)*ao;\n\n    }\n\n    float fog = 1./(1. + t*.125 + t*t*.01);\n    col = mix(vec3(0), col, fog);//\n\n    uv = fragCoord/iResolution.xy;\n    col *= pow(16.*uv.x*uv.y*(1. - uv.x)*(1. - uv.y) , .125);\n\tfragColor = vec4(sqrt(max(col, 0.)), 1);\n}", "image_inputs": [{"id": "4sXGRn", "previewfilepath": "/media/ap/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3tccWf.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[2292, 2332, 2365, 2365, 2432], [2434, 2434, 2451, 2451, 2481], [2482, 2482, 2499, 2499, 2529], [2530, 2530, 2547, 2547, 2577], [2578, 2578, 2595, 2595, 2625], [2628, 2628, 2641, 2641, 4040], [4092, 4092, 4112, 4112, 4140], [4142, 4301, 4324, 4324, 4353], [4355, 4516, 4538, 4538, 4560], [4562, 4696, 4747, 4747, 4865], [4867, 4867, 4896, 4896, 4944], [4947, 5102, 5144, 5144, 5961], [5964, 5990, 6037, 6037, 6246], [6248, 6310, 6332, 6332, 6519], [6522, 6522, 6563, 6563, 6618], [6621, 6660, 6699, 6751, 8061], [8063, 8399, 8467, 8467, 8862], [8865, 8865, 8884, 8884, 16523], [16526, 16586, 16638, 16638, 17253], [17256, 17256, 17325, 17325, 17750], [17752, 17752, 17782, 17782, 18037], [18040, 18040, 18077, 18077, 18407], [18410, 18410, 18437, 18437, 18704], [18707, 18707, 18762, 18762, 21597]]}
{"id": "3tcyzl", "name": "Aastal - Nothing is less dub", "author": "z0rg", "description": "https://youtu.be/Fq8qgzzm_nA", "tags": ["dubstep"], "likes": 5, "viewed": 176, "published": "Public API", "date": "1609708010", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// This work is licensed under the Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n// Unported License. To view a copy of this license, visit http://creativecommons.org/licenses/by-nc-sa/3.0/ \n// or send a letter to Creative Commons, PO Box 1866, Mountain View, CA 94042, USA.\n// =========================================================================================================\n\n// A clip I did for a friend\n// The video is here https://youtu.be/Fq8qgzzm_nA\n\n#define sat(a) clamp(a, 0., 1.)\nmat2 r2d(float a) { float c = cos(a), s = sin(a); return mat2(c, -s, s, c);}\n#define FFT(v) (pow(texelFetch(iChannel1, ivec2(v,0),0).x,3.)+.3)\n\nfloat lenny(vec2 v)\n{\n    return abs(v.x)+abs(v.y);\n}\n\nfloat _cir(vec2 p, float r)\n{\n    return length(p)-r;\n}\nfloat _rho(vec2 p, float r)\n{\n    return lenny(p)-r;\n}\n\nfloat _sqr(vec2 p, vec2 s)\n{\n    vec2 l = abs(p)-s;\n    return max(l.x, l.y);\n}\nvec3 rdr(vec2 uv)\n{\n    float shp = iResolution.x*.5;\n    vec3 col;\n    mat2 rotCover = r2d((FFT(10)-.5)*.2);\n    vec2 moveScene = rotCover*vec2(FFT(10)-.5, FFT(20)-.5);\n    \n    // Back\n    col = vec3(52, 49, 54)/255.;\n    col += .5*(1.-sat(_cir(uv-vec2(.1,0.), .1)*2.))*(vec3(129, 80, 161)/255.);\n    col += .5*(1.-sat(_cir(uv-vec2(-.1,0.), .05)*2.))*(vec3(129, 80, 161)/255.).xzy;\n    col = pow(col, vec3(2.45));\n    \n    // back grid\n    uv -= .02*moveScene;\n    float gridAStp = .1;\n    float gridATh = 0.0001;\n    \n    vec2 gridAv = mod(uv, gridAStp)-gridATh;\n    float gridA = min(gridAv.x, gridAv.y);\n    col = mix(col, sat(col+vec3(.05)), 1.-sat(gridA*shp));\n    \n    float gridBStp = gridAStp/5.;\n    float gridBTh = gridATh/2.;\n    \n    vec2 gridBv = mod(uv, gridBStp)-gridBTh;\n    float gridB = min(gridBv.x, gridBv.y);\n    col = mix(col, sat(col+vec3(.015)), 1.-sat(gridB*shp));\n    col *= pow((1.-sat(lenny(uv*.5)-.2)), 5.);\n    \n\n    \n    // Piou Piou\n    \n    float barRep = .025;\n    float barTh = 0.002;\n    \n    vec2 uvBars = uv;\n    float barsIdx = round((uvBars.y+barRep*.5) / barRep);\n    uvBars.y = mod(uvBars.y+.5*barRep, barRep)-barRep;\n    \n    float bars = _sqr(uvBars, vec2(FFT(5.*(barsIdx+10.))*.5, barTh));\n    \n    vec3 grad = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4)+2.*FFT(barsIdx+10.));\n    col += grad *(1.-sat(bars*shp));\n    col += grad *(1.-sat(bars*5.))*.5;\n    \n    // Logo\n    vec2 coverUv = moveScene*.25+((cos(iTime*.25)*.2+1.)*5.*uv+vec2(.5));//+vec2(sin(iTime), cos(iTime))*.1;\n    //coverUv *= ;\n    vec4 coverBlack4 = texture(iChannel0, coverUv*.95);\n    vec4 cover4 = texture(iChannel0, coverUv);\n    vec3 cover = cover4.xyz;\n    col = col*sat(.0+pow(sat(_rho(coverUv-vec2(.5)-vec2(0.,-.1), .5)*2.), .4));\n    //col *= sat(.5+1.-coverBlack4.w);\n    if (coverUv.x > 0. && coverUv.y > 0. && coverUv.x < 1. && coverUv.y < 1.)\n        ;//col = mix(col, cover, cover4.w); // I use the extension to put a custom texture here\n//        col = cover;\n        \n\n    vec3 rhoCol = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4)).zxy;\n    \n    \n    // Border\n    float th = .23;\n    float border = abs(uv.y)-th;\n    \n    col = mix(col, vec3(0.), sat(border*shp));\n    \n    col *= .5+rhoCol*pow(1.-sat(_rho(coverUv-vec2(.5), 1.5)*1.), 1.);\n\n    return col;\n}\n\nvec3 chroma(vec2 uv)\n{\n    vec2 dir = normalize(vec2(1.));\n    float strength = 0.025*sat(length(uv))+FFT(10)*.05*length(uv);\n    vec3 rgb;\n    \n    rgb.x = rdr(uv+dir*strength).x;\n    rgb.y = rdr(uv).y;\n    rgb.z = rdr(uv-dir*strength).z;\n    \n    return rgb;\n}\n\nvec3 cheapAA(vec2 uv)\n{\n    vec3 col = chroma(uv);\n    vec2 off = vec2(1., -1.)/(iResolution.x*2.);\n    float diff = pow(fwidth(col.z), 1.);\n    if (true)//diff > 0.3) // Not so cheap antialiasing\n    {\n        //col = vec3(1.,0.,0.);\n        vec3 acc = col;\n        acc += rdr(uv+off.xx);\n        acc += rdr(uv+off.xy);\n        acc += rdr(uv+off.yy);\n        acc += rdr(uv+off.yx);\n        col = acc/5.;\n        \n    }\n    return col;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-vec2(.5)*iResolution.xy)/iResolution.xx;\n\n    uv.y *= 1.+abs(uv.x);\n    vec3 col = cheapAA(uv);\n    \n    col = mix(col, col.zxy*(2.-sat(length(uv*4.))), sin(iTime*.5)*.5+.5);\n\n    \n    col *= sat(iTime-0.2);\n    col *= 1.-sat(iTime-213.);\n\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": "Xsf3Rn", "previewfilepath": "/media/ap/cbcbb5a6cfb55c36f8f021fbb0e3f69ac96339a39fa85cd96f2017a2192821b5.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/cbcbb5a6cfb55c36f8f021fbb0e3f69ac96339a39fa85cd96f2017a2192821b5.png", "ctype": "texture"}, {"id": "MlXXz4", "previewfilepath": "https://soundcloud.com/aastal/nothing-is-less", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0, "src": "https://soundcloud.com/aastal/nothing-is-less", "ctype": "musicstream"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3tcyzl.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[397, 509, 528, 528, 585], [653, 653, 674, 674, 706], [708, 708, 737, 737, 763], [764, 764, 793, 793, 818], [820, 820, 848, 848, 899], [900, 900, 919, 919, 3183], [3185, 3185, 3207, 3207, 3447], [3449, 3449, 3472, 3472, 3886], [3889, 3889, 3946, 3946, 4244]]}
{"id": "3tdcDS", "name": "genuary2021_day4", "author": "psydshobob", "description": "Made for Genuary2021 day four - Small Symmetry", "tags": ["genuary2021"], "likes": 7, "viewed": 63, "published": "Public", "date": "1609834623", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float lines(in vec2 pos, float b){\n    float scale = 10.0;\n    pos *= scale;\n    return smoothstep(0.0,\n                    .5+b*.5,\n                    abs((sin(pos.x*3.1415)+b*2.0))*.5);\n}\n\nmat2 rotate2d(float angle){\n    return mat2(cos(angle),-sin(angle),\n                sin(angle),cos(angle));\n}\nvec3 hsb2rgb( in vec3 c ){\n    vec3 rgb = clamp(abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),\n                             6.0)-3.0)-1.0,\n                     0.0,\n                     1.0 );\n    rgb = rgb*rgb*(3.0-2.0*rgb);\n    return c.z * mix(vec3(1.0), rgb, c.y);\n}\n\n#define PI 3.14159\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  //vec2 st = fragCoord.xy/iResolution.xy;\n  //vec2 st = (fragCoord -.5* iResolution.xy)/iResolution.y;\n  vec2 st = fragCoord/iResolution.y;\n  //st += 1.0;\n  vec2 pos = vec2 (st*5.0);\n\n  vec2 p = floor(pos);\n  p += 1.0;\n  pos *= p.x;\n  //pos -= .5;\n  //pos = rotate2d(2.0*PI * .5 *length(fract(pos))) * fract(pos);\n  float flip = mod(floor(pos.x), 2.0);\n  flip = mod(floor(pos.y), 2.0) == 0.0 ? flip : 1.0 - flip;\n  pos = rotate2d(.5 * PI * flip) * fract(pos);\n  float f = flip == 1.0 ? fract(pos.x) : fract(pos.y);\n  //pos = rotate2d(-.25*PI * smoothstep(.1,.9,f)) * pos;\n  // if (st.x > 0. && st.y > 0.) {\n  //   pos = rotate2d(PI / 2.0) * pos;\n//  }\n  //pos = rotate2d(noise_dir(pos)/.3) * pos;\n\n  //float n = noise_dir(pos);\n  vec3 color = vec3(0.);\n  //vec3 color = vec3(step(.9, n));\n  //vec3 color = vec3(n);\n  float l = lines(pos,.01);\n  //color = vec3(l, fract(pos.x), fract(pos.y));\n  //vec3 foo = mix(vec3(1.0,0.,0.), vec3(.8, .8, .0), fract(pos.x));\n  vec3 foo = hsb2rgb(vec3((cos(iTime) + 1.0)/2.0 + fract(pos.x), .7, .9));\n  color = vec3(l*foo);\n  fragColor = vec4(color, 1.0);\n\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3tdcDS.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 34, 34, 190], [192, 192, 219, 219, 301], [302, 302, 328, 328, 560], [582, 582, 637, 741, 1732]]}
{"id": "3tdcWl", "name": "My Second Basic Ray Marcher", "author": "CrazySheep05", "description": "An update to my first ray marcher\nNow the light bounces twice, allowing for reflections within reflections, and the emissive light also has some reflections!\n\nI started off using this tutorial: https://www.youtube.com/watch?v=PGtv-dBi2wE", "tags": ["raymarching"], "likes": 1, "viewed": 61, "published": "Public", "date": "1610213591", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//Shader designed based of this tutorial: https://www.youtube.com/watch?v=PGtv-dBi2wE\n//Tutorial project: https://www.shadertoy.com/view/XlGBW3\n\n#define MAXDIS 100.\n#define MAXSTEP 500\n#define SURFDIS 0.001\n#define LIGHTINTENSITY 10.\n#define LIGHTCOL vec3(1,.0,.5)\n\nfloat GetDis(vec3 p)\n{\n\tvec4 s = vec4(0, 1.05, 6, 1);\n    \n    float sd =  abs(length(p-s.xyz)-s.w)-.1;\n    float pd = p.y-1.;\n    \n    float d = max(sd, pd);\n    pd = p.y;\n    d=min(d,pd);\n    \n\ts = vec4(3, 1.05, 6, 1);\n    sd =  abs(length(p-s.xyz)-s.w)-.1;\n    d = min(d,sd);\n    \n\ts = vec4(5, 4, 7, 2);\n    sd =  abs(length(p-s.xyz)-s.w)-.1;\n    d = min(d,sd);\n    \n\ts = vec4(-5.-sin(iTime), 4, 7, 1);\n    sd =  abs(length(p-s.xyz)-s.w)-.1;\n    d = min(d,sd);\n    \n    d = min(d,sd);\n    \n    return d;\n}\n\nfloat GetEDis(vec3 p)\n{\n    vec3 po = vec3(0,4.+sin(iTime),6);\n    vec4 s = vec4(po, 0.25);\n    \n    \n\t//vec4 s = vec4(3, 1.05, 6, 3);\n    return  abs(length(p-s.xyz)-s.w)-.1;\n    \n    //return abs(length(p-s.xyz)-s.w)-.1;\n}\n\nfloat GetRef(vec3 p)\n{\n\tvec4 s = vec4(0, 1.05, 6, 1);\n    \n    float sd =  abs(length(p-s.xyz)-s.w)-.1;\n    float pd = p.y-1.;\n    \n    float d = max(sd, pd);\n    \n    pd = p.y;\n    \n\ts = vec4(3, 1.05, 6, 1);\n    \n    sd =  abs(length(p-s.xyz)-s.w)-.1;\n    \n    d = min(sd,pd);\n    \n    d=sd;\n    d=min(sd,pd);\n    if(d<SURFDIS)return .8;\n    else return .2;\n}\n\nfloat RayMarch(vec3 ro, vec3 rd)\n{\n    float d=.0;\n    \n    for(int i = 0; i<MAXSTEP; i++)\n    {\n        vec3 p = ro+rd*d;\n        float ds = GetDis(p);\n        d+=ds;\n        if(ds<SURFDIS || d>MAXDIS)\n        {\n            break;\n        }\n    }\n    \n    return(d);\n}\n\nvec3 GetNormal(vec3 p)\n{\n    float d = GetDis(p);\n    vec2 e = vec2(.01,0);\n    \n    vec3 n = d-vec3(\n    GetDis(p-e.xyy),\n    GetDis(p-e.yxy),\n    GetDis(p-e.yyx));\n    \n    return normalize(n);\n}\n\nvec3 TestMarch(vec3 ro, vec3 rd)\n{\n    float d=.0;\n    \n    for(int i = 0; i<MAXSTEP; i++)\n    {\n        vec3 p = ro+rd*d;\n        float ds = GetDis(p);\n        d+=ds;\n        if(ds<SURFDIS || d>MAXDIS)\n        {\n            break;\n        }\n    }\n    vec3 p = ro + rd * d;\n    p = p;\n    return(p);\n}\n\nvec3 GetLight (vec3 p)\n{\n    vec3 light = vec3(0,4.+1.0*sin(iTime),6);\n    vec3 l = normalize(light-p);\n    vec3 n = GetNormal(p);\n    \n    float diff = dot(n,l);\n    \n    float d = RayMarch(p+n*SURFDIS*2.,l);\n    if(d<length(light-p))\n    {\n        diff*=.1;\n    }\n    diff*=LIGHTINTENSITY/(length(p-light)*length(p-light));\n    \n    vec3 dir=normalize(vec3(0, 5, -1)-p);\n    \n    vec3 lightCol = vec3(sin(iTime*5.)/2.+.5,0,.5);\n    lightCol=vec3(1,1,1);\n    \n    return max(diff,0.) * lightCol;\n}\n\nvec3 Emission(vec3 ro, vec3 rd)\n{\n    //vec3 p = vec3(0,3.+sin(iTime),6);\n    //vec4 s = vec4(p, 0.25);\n    float d=.0;\n    \n    for(int i = 0; i<MAXSTEP; i++)\n    {\n        vec3 p = ro+rd*d;\n        //float ds = length(p-s.xyz)-s.w;\n        float ds = GetEDis(p);\n        d+=ds;\n        if(ds<SURFDIS)\n        {\n            //return vec3(1,1,1);\n            //return vec3(sin(iTime*5.)/2.+.5,0,.5);\n            \n\n            float de = GetEDis(p);\n            vec2 e = vec2(.01,0);\n\n            vec3 n = normalize(de-vec3(\n            GetEDis(p-e.xyy),\n            GetEDis(p-e.yxy),\n            GetEDis(p-e.yyx)));\n            \n            //return(normalize(n));\n            \n            vec3 pd = reflect(rd,n);\n            float ref = 0.9;\n            ref=GetRef(p);\n            //vec3 diff = 1.-ref;\n\n            vec3 rpos = TestMarch(p+n*SURFDIS*2.,pd);\n            vec3 r = GetLight(rpos);\n            ref=GetRef(rpos);\n            r*=1.-ref;\n            \n            return r + vec3(.9,.9,.9);// * 100.;\n        }\n        if(d>MAXDIS)\n        {\n            return vec3(0);\n        }\n    }\n    \n    return vec3(0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\n    \n    vec3 ro = vec3(0, 5.+2.0*cos(iTime), -1);\n    ro = vec3(0,5., -1.+3.0*cos(iTime));\n    vec3 rd = normalize(vec3(uv.x, uv.y-0.3, 0.7));\n    \n    vec3 p = TestMarch(ro, rd);\n    \n    vec3 diff=GetLight(p);\n    \n    \n    //FIRST REFLECTION\n    vec3 n = GetNormal(p);\n    vec3 pd = reflect(rd,n);\n    float ref = 0.9;\n    ref=GetRef(p);\n    diff *= 1.-ref;\n    \n    vec3 rpos = TestMarch(p+n*SURFDIS*2.,pd);\n    vec3 r = GetLight(rpos);\n    ref=GetRef(rpos);\n    r*=1.-ref;\n    \n    //SECOND REFLECTION\n    n = GetNormal(rpos);\n    pd = reflect(pd,n);\n    vec3 r2p = TestMarch(rpos+n*SURFDIS*2.,pd);\n    \n    r+=ref*GetLight(r2p)*(1.-GetRef(r2p));\n    \n    \n    //COLOURING\n    diff+=r*GetRef(p);\n    //diff=Emission(ro,rd);\n    \n    vec3 col = diff;\n    col+=Emission(ro, rd);\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3tdcWl.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 266, 288, 288, 774], [776, 776, 799, 799, 1000], [1002, 1002, 1024, 1024, 1362], [1364, 1364, 1398, 1398, 1633], [1635, 1635, 1659, 1659, 1832], [1834, 1834, 1868, 1868, 2135], [2137, 2137, 2161, 2161, 2635], [2637, 2637, 2670, 2740, 3760], [3762, 3762, 3819, 3819, 4700]]}
{"id": "3tdyDj", "name": "blender-like noise texture", "author": "gemps", "description": "https://github.com/blender/blender/blob/master/intern/cycles/kernel/shaders/node_noise.h\nhttps://github.com/blender/blender/blob/master/intern/cycles/kernel/shaders/node_noise_texture.osl\nhttps://gist.github.com/patriciogonzalezvivo/670c22f3966e662d2f83\n", "tags": ["noise"], "likes": 3, "viewed": 86, "published": "Public", "date": "1609926791", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//  https://gist.github.com/patriciogonzalezvivo/670c22f3966e662d2f83\n//\tSimplex 3D Noise \n//\tby Ian McEwan, Ashima Arts\n//\nvec4 permute(vec4 x){return mod(((x*34.0)+1.0)*x, 289.0);}\nvec4 taylorInvSqrt(vec4 r){return 1.79284291400159 - 0.85373472095314 * r;}\n\nfloat snoise(vec3 v){ \n  const vec2  C = vec2(1.0/6.0, 1.0/3.0) ;\n  const vec4  D = vec4(0.0, 0.5, 1.0, 2.0);\n\n// First corner\n  vec3 i  = floor(v + dot(v, C.yyy) );\n  vec3 x0 =   v - i + dot(i, C.xxx) ;\n\n// Other corners\n  vec3 g = step(x0.yzx, x0.xyz);\n  vec3 l = 1.0 - g;\n  vec3 i1 = min( g.xyz, l.zxy );\n  vec3 i2 = max( g.xyz, l.zxy );\n\n  //  x0 = x0 - 0. + 0.0 * C \n  vec3 x1 = x0 - i1 + 1.0 * C.xxx;\n  vec3 x2 = x0 - i2 + 2.0 * C.xxx;\n  vec3 x3 = x0 - 1. + 3.0 * C.xxx;\n\n// Permutations\n  i = mod(i, 289.0 ); \n  vec4 p = permute( permute( permute( \n             i.z + vec4(0.0, i1.z, i2.z, 1.0 ))\n           + i.y + vec4(0.0, i1.y, i2.y, 1.0 )) \n           + i.x + vec4(0.0, i1.x, i2.x, 1.0 ));\n\n// Gradients\n// ( N*N points uniformly over a square, mapped onto an octahedron.)\n  float n_ = 1.0/7.0; // N=7\n  vec3  ns = n_ * D.wyz - D.xzx;\n\n  vec4 j = p - 49.0 * floor(p * ns.z *ns.z);  //  mod(p,N*N)\n\n  vec4 x_ = floor(j * ns.z);\n  vec4 y_ = floor(j - 7.0 * x_ );    // mod(j,N)\n\n  vec4 x = x_ *ns.x + ns.yyyy;\n  vec4 y = y_ *ns.x + ns.yyyy;\n  vec4 h = 1.0 - abs(x) - abs(y);\n\n  vec4 b0 = vec4( x.xy, y.xy );\n  vec4 b1 = vec4( x.zw, y.zw );\n\n  vec4 s0 = floor(b0)*2.0 + 1.0;\n  vec4 s1 = floor(b1)*2.0 + 1.0;\n  vec4 sh = -step(h, vec4(0.0));\n\n  vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy ;\n  vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww ;\n\n  vec3 p0 = vec3(a0.xy,h.x);\n  vec3 p1 = vec3(a0.zw,h.y);\n  vec3 p2 = vec3(a1.xy,h.z);\n  vec3 p3 = vec3(a1.zw,h.w);\n\n//Normalise gradients\n  vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));\n  p0 *= norm.x;\n  p1 *= norm.y;\n  p2 *= norm.z;\n  p3 *= norm.w;\n\n// Mix final noise value\n  vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n  m = m * m;\n  return 42.0 * dot( m*m, vec4( dot(p0,x0), dot(p1,x1), \n                                dot(p2,x2), dot(p3,x3) ) );\n}\n\nfloat safe_snoise(vec3 p)\n{\n  float f = snoise(p);\n  if (isinf(f))\n    return 0.0;\n  return f;\n}\n\n// https://github.com/blender/blender/blob/master/intern/cycles/kernel/shaders/node_noise.h\n\nfloat fractal_noise(vec3 p, float details, float roughness)\n{\n  float fscale = 1.0;\n  float amp = 1.0;\n  float maxamp = 0.0;\n  float sum = 0.0;\n  float octaves = clamp(details, 0.0, 16.0);\n  int n = int(octaves);\n  for (int i = 0; i <= n; i++) {\n    float t = safe_snoise(fscale * p);\n    sum += t * amp;\n    maxamp += amp;\n    amp *= clamp(roughness, 0.0, 1.0);\n    fscale *= 2.0;\n  }\n  float rmd = octaves - floor(octaves);\n  if (rmd != 0.0) {\n    float t = safe_snoise(fscale * p);\n    float sum2 = sum + t * amp;\n    sum /= maxamp;\n    sum2 /= maxamp + amp;\n    return (1.0 - rmd) * sum + rmd * sum2;\n  }\n  else {\n    return sum / maxamp;\n  }\n}\n\n// https://github.com/blender/blender/blob/master/intern/cycles/kernel/shaders/node_noise_texture.osl\nvec3 random_vec3_offset(float seed)\n{\n  return vec3(100.0 + snoise(vec3(seed)) * 100.0,\n                 100.0 + snoise(vec3(seed)) * 100.0,\n                 100.0 + snoise(vec3(seed)) * 100.0);\n}\n\nvec3 noiseTexture(vec3 pos, float detail, float roughness){\n    vec3 p = pos;\n    float value = fractal_noise(p, detail, roughness);\n    \n    return (vec3(value,\n                fractal_noise(p+random_vec3_offset(0.), detail, roughness),\n                fractal_noise(p+random_vec3_offset(1.), detail, roughness)));\n}\n\n\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    uv *= 2.;\n    \n    float detail1 = 16.;\n    float detail2 = 1.;\n    float roughness1 = .5;\n    float roughness2 = .5;\n    vec3 pIn1 = vec3(uv,iTime/5.);\n    vec3 pIn2 = noiseTexture(pIn1,detail1,roughness1);\n    \n    vec3 col = noiseTexture(pIn2,detail2,roughness2);\n\n    // contrast\n    col *= .7;\n    // brightness\n    col += .5;\n    \n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3tdyDj.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 124, 145, 145, 182], [183, 183, 210, 210, 258], [260, 260, 281, 281, 2117], [2119, 2119, 2146, 2146, 2215], [2217, 2310, 2371, 2371, 2958], [2960, 3062, 3099, 3099, 3258], [3260, 3260, 3319, 3319, 3577], [3583, 3583, 3640, 3690, 4109]]}
{"id": "3tdyRl", "name": "gear grind", "author": "valalalalala", "description": "I was going to make a scene with gears, but then.... they were so hypnotic...\n\nAnd... still artifacts...", "tags": ["raymarching", "gears"], "likes": 6, "viewed": 180, "published": "Public", "date": "1610237594", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/////////////////////////////////////////////////////////////////////////////\n//\n// \"gear grind\" \n//\n// by Val \"valalalalala\" GvM - 2020\n// Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n//\n/////////////////////////////////////////////////////////////////////////////\n\n/////////////////////////////////////////////////////////////////////////////\n// scene specific settings\n\n#define GEAR_REPEAT   5.0\n#define TEXTURE_GEARS 0.9\n\n/////////////////////////////////////////////////////////////////////////////\n// ray marching values\n\n#define RAY_MARCH_STEPS    88\n#define RAY_MARCH_TOO_FAR  float( RAY_MARCH_STEPS )\n#define RAY_MARCH_CLOSE    .0001\n#define RAY_EPSILON        vec2( RAY_MARCH_CLOSE, .0 )\n#define RAY_SHORTENING\n#define RAY_RELAX_        0.1\n\n/////////////////////////////////////////////////////////////////////////////\n// anti-aliasing\n\n#define ANTI_ALIAS_STEPS    1\n#define ANTI_ALIAS_DISTANCE 3.\n\n/////////////////////////////////////////////////////////////////////////////\n// reflections\n\n#define REFLECTION_NONE   0.\n#define REFLECTION_SIMPLE 1.\n#define REFLECTION_NICER  2.\n\nfloat REFLECTION_LEVEL_ = REFLECTION_SIMPLE; // toggle with 'r' key\n\n/////////////////////////////////////////////////////////////////////////////\n// camera\n\nconst float CAMERA_SCALE = 6.;\n\n/////////////////////////////////////////////////////////////////////////////\n// useful constants and macros\n\n#define PI2             6.283185307179586\n#define TRIG(d, a)      ( d * vec2( cos( a ), sin( a ) ) )\n#define RGB(r,g,b)      vec3( float(r)/255., float(g)/255., float(b)/255. )\n#define EQUALS(a,b)     step( a, b ) * step( b, a )\n#define VEC3Y(y)        vec3( .0, y, .0 )\n#define VEC3Z(z)        vec3( .0, .0, z )\n#define RAND2(v)        fract( 333433.444469 * sin( dot( v, vec2( 449.457, 359.367 ) ) ) )\n\n#define MODO(v,f) ( mod( v + .5 * f, f ) - .5 * f )\n#define DOT_DIFFERENCE(a,b) dot( a - b, a - b )\n\n/////////////////////////////////////////////////////////////////////////////\n//\n\nmat2 rotate2d( in float angle ) {\n    vec2 t = TRIG( 1., angle );\n    return mat2( t.x, -t.y, t.y, t.x );\n}\n\n/////////////////////////////////////////////////////////////////////////////\n// signed distance functions for types\n\n// https://www.iquilezles.org/www/articles/distfunctions/distfunctions.htm\nfloat ndot( in vec2 a, in vec2 b ) { return a.x*b.x - a.y*b.y; }\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat sdRhombus(vec3 p, float la, float lb, float h, float ra)\n{\n  p = abs(p);\n  vec2 b = vec2(la,lb);\n  float f = clamp( (ndot(b,b-2.0*p.xz))/dot(b,b), -1.0, 1.0 );\n  vec2 q = vec2(length(p.xz-0.5*b*vec2(1.0-f,1.0+f))*sign(p.x*b.y+p.z*b.x-b.x*b.y)-ra, p.y-h);\n  return min(max(q.x,q.y),0.0) + length(max(q,0.0));\n}\n\nfloat sdRoundedCylinder( vec3 p, float ra, float rb, float h )\n{\n  vec2 d = vec2( length(p.xz)-2.0*ra+rb, abs(p.y) - h );\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0)) - rb;\n}\n\n/////////////////////////////////////////////////////////////////////////////\n// https://mercury.sexy/hg_sdf/\n\n// Cylinder standing upright on the xz plane\nfloat fCylinder(vec3 p, float r, float height) {\n    float d = length(p.xz) - r;\n    return max(d, abs(p.y) - height);\n}\n\n/////////////////////////////////////////////////////////////////////////////\n// create the scene\n\n#define GEAR  1.\n\nvec2 which( in vec2 current, in vec2 test ) {\n    return mix( current, test, step( test.x, current.x ) );\n}\n\nfloat gearAngleOffset( in vec3 point ) {    \n    vec3 q = point.xzy;\n    \n#ifdef GEAR_REPEAT\n    //q.xz = MODO( q.xz, GEAR_REPEAT );\n    q = MODO( q, GEAR_REPEAT );\n#endif\n\n    vec2 id = point.xy - q.xz;\n    float eo = mod( id.x + id.y + 77., 2. ) * 2. -1.;\n    \n    ///////////////////////////\n        \n    float angle_inc = .0; //offset for each gear\n    angle_inc += floor( mod(id.x+id.y,2.) ) * .2; // alternate \n    angle_inc += eo * iTime; // spin the right way\n    return angle_inc;\n}\n\nmat2 gearAngleMatrix( in vec3 point ) {\n    return rotate2d( -gearAngleOffset( point ) * .4 );\n}\n\nfloat gearDistance( in vec3 point ) {\n    vec3 q = point.xzy;\n    \n#ifdef GEAR_REPEAT\n    q = MODO( q, GEAR_REPEAT );    \n#endif\n    \n    vec2 id = point.xy - q.xz;\n    float eo = mod( id.x + id.y + 77., 2. ) * 2. -1.;\n    \n    vec3 og = q;\n    \n    ///////////////////////////\n    \n    float angle = atan( q.x, q.z );\n    \n    float angle_inc = .0; //offset for each gear\n    angle_inc += floor( mod(id.x+id.y,2.) ) * .2; // alternate \n    angle_inc += eo *iTime; // spin the right way\n    \n    mat2 rot = rotate2d( -angle_inc * .4 ); // sync is off...\n    vec3 xo = og;\n    xo.xz *= rot;  \n    \n    ///////////////////////////\n    \n    // this took a lot of fiddling...\n    float r = 2.5 - .2 * step(.0,sin( 48.* angle + 20. * angle_inc ) );\n    \n    float gear = fCylinder( xo, r, .1 );\n    gear = max( gear, -fCylinder( q, 1.86, .33 ) );\n        \n    ///////////////////////////\n    // the inset cross\n\n    float inset = fCylinder( xo, 2., .1 );\n\n    r = .8;\n    float f = -.77;\n    float o = 1.1;\n    o = 1.18;\n    vec3 nSpot = vec3( -o, f - .4, +o );\n    vec3 nSize = vec3( o * .5 );\n    nSize.xz /= 2.;    \n    \n    float negative_inset = 1e33;\n    negative_inset = min( negative_inset, sdBox( xo + nSpot.xyx, nSize ) );\n    negative_inset = min( negative_inset, sdBox( xo + nSpot.xyz, nSize ) );\n    negative_inset = min( negative_inset, sdBox( xo + nSpot.zyx, nSize ) );\n    negative_inset = min( negative_inset, sdBox( xo + nSpot.zyz, nSize ) );\n    negative_inset -= r;\n    //return min(inset,negative_inset);\n\n    inset = max( inset, -negative_inset );\n    //return inset; // like a squared off flat cross\n\n    gear = min( gear, inset );\n\n    // cross\n    float crozz = 1e33;\n    crozz = min( crozz, sdRhombus( xo.xzy + VEC3Z( .18 ), 2.5, .5,.04,.1 ) -.04 );\n    crozz = min( crozz, sdRhombus( xo.zxy + VEC3Z( .18 ), 2.5, .5,.04,.1 ) -.04 );\n  \n    // topper\n    \n    float topper = 1e33;\n    topper = min( topper, sdRoundedCylinder( xo.xyz, .25,.2, .2 ) );\n    topper = min( topper, sdRoundedCylinder( xo.xyz - VEC3Y( .3 ), .15,.06, .1 ) );\n    //return topper;\n    \n    crozz = min( crozz, topper );\n    crozz = max( crozz, -xo.y );\n    gear = min( gear, crozz );\n\n    return gear;\n}\n\nvec2 sceneDistance( in vec3 point ) {\n    float gear = gearDistance( point );\n    float back = point.z + 11.;\n        \n    vec2 closest = vec2( RAY_MARCH_TOO_FAR );\n    closest = which( closest, vec2( gear, GEAR ));\n#ifdef GEARS_REPEAT\n    closest = which( closest, vec2( back, GEAR ));\n#endif\n    return closest;\n}\n\n//set color per object\nvec3 colorFor( in float which ) {\n    return vec3( .33 );\n}\n\n//set reflection per object\nfloat reflectionFor(  in float which ) {\n    return .6;\n}\n\n/////////////////////////////////////////////////////////////////////////////\n// the ray marching bits\n\nvec2 rayMarch( in vec3 origin, in vec3 direction ) {\n    vec2 total = vec2(.0);\n    for ( int i = 0 ; i < RAY_MARCH_STEPS ; i++ ) {\n        vec3 point = origin + direction * total.x;\n        vec2 current = sceneDistance( point );\n\n#ifdef RAY_SHORTENING\n        if ( total.x > RAY_MARCH_TOO_FAR || abs( current.x ) < RAY_MARCH_CLOSE ) {\n            break;\n        }\n        // Note: Ray advancement occurs after checking for a surface hit.\n        // Ray shortening: Shorter for the first few iterations.\n        total.x += i<22? current.x*.33 : current.x*.88; \n        total.y = current.y;\n#else\n        total.x += current.x;\n        total.y = current.y;\n\n        if ( total.x > RAY_MARCH_TOO_FAR || abs(current.x) < RAY_MARCH_CLOSE ) {\n            break;\n        }     \n#ifdef RAY_RELAX\n        total.x += RAY_RELAX * current.x;\n#endif\n\n#endif\n    }\n    return total;\n}\n\nvec3 sceneNormal( in vec3 point ) {\n    return normalize( sceneDistance( point ).x - vec3(\n        sceneDistance( point - RAY_EPSILON.xyy ).x,\n        sceneDistance( point - RAY_EPSILON.yxy ).x,\n        sceneDistance( point - RAY_EPSILON.yyx ).x\n    ));\n}\n\n/////////////////////////////////////////////////////////////////////////////\n// lighting\n\nvec3 textureForPoint( in vec3 point ) {\n    vec2 center = iChannelResolution[1].xy * .5;\n    vec2 uv = point.xy;\n    uv *= gearAngleMatrix( point );\n    uv += center;\n    return texture( iChannel1, uv, .0 ).xyz;\n}\n\nfloat pointLight( vec3 point, vec3 normal, vec4 light ) {  \n    vec3 towardLight = light.xyz - point;\n    float toLight = length( towardLight );\n\n#ifdef TEXTURE_GEARS\n    towardLight = mix( towardLight, textureForPoint( point ), TEXTURE_GEARS );\n#endif\n    towardLight = normalize( towardLight );\n\n    float diffuse = clamp( dot( normal, towardLight ), 0., 1. );\n    \n    vec3 lightStart = point + normal * RAY_MARCH_CLOSE * 2.;\n    float d = rayMarch( lightStart, towardLight ).x;\n    diffuse *= 1. - 0.5 * smoothstep( d * 0.9, d, toLight );\n\n    float lightStrength = .7 + .3 * light.w / dot( toLight, toLight );  \n    return diffuse * lightStrength;\n}\n\nvec3 colorPoint( vec3 point, vec3 normal, vec2 d, vec3 eye ) {\n    eye.z-=5.;\n    eye.x-=2.;\n\n    vec4 light    = vec4( eye, 180. );\n    float ambient = 0.07;\n    float gamma   = .33;\n    \n    float lighting = pointLight( point, normal, light );\n    lighting = ( 1. -  ambient ) * gamma * lighting;\n\n    vec3 color = colorFor( d.y );\n    \n    //meh.. color += texture( iChannel1, point.xy, .0 ).xyz;\n\treturn vec3( color * ambient + color * lighting );\n}\n\nvec3 mixInReflection( vec3 point, float which, vec3 normal, vec3 color, vec3 eye ) {\n    float reflectionFactor = reflectionFor( which );\n    float noReflection = step( .0, reflectionFactor );\n\n    vec3 reflectionStart = point + normal * RAY_MARCH_CLOSE * 2.;\n    vec2 reflectAt       = noReflection * rayMarch( reflectionStart, normal );\n    float reflected      = noReflection * ( 1. - step( RAY_MARCH_TOO_FAR, reflectAt.x ) );\n\n    vec3 reflectPoint = reflectionStart + normal * reflectAt.x;\n    vec3 reflectNormal = reflected * sceneNormal( reflectPoint  );\n    //reflectNormal += .25 * texture( iChannel1, point.xy, .0 ).xyz;\n\n#ifdef REFLECTION_LEVEL\n    vec3 reflection;  \n    if ( REFLECTION_NICER == REFLECTION_LEVEL ) { \n        reflection = reflected * colorPoint( reflectPoint, reflectNormal, reflectAt, eye );\n    } else {\n        reflection = reflected * colorFor( reflectAt.y );\n    }\n    color = mix( color, mix( color, reflection, reflectionFactor ), reflected );\n#endif \n    \n    return color;\n}\n\n/////////////////////////////////////////////////////////////////////////////\n// simple camera\n\nstruct Ray {\n    vec3 eye;\n    vec3 direction;\n};\n\n// from https://github.com/glslify/glsl-look-at\nmat3 makeCamera( vec3 origin, vec3 target, float roll ) {\n\tvec3 up = vec3( sin( roll ), cos( roll ), .0 );\n\tvec3 zz = normalize( target - origin );\n\tvec3 xx = normalize( cross( zz, up ) );\n\tvec3 yy = normalize( cross( xx, zz ) );\n\treturn mat3( xx, yy, zz );\n}\n\nRay lookAtTheCamera( in vec2 uv, in vec3 eye, in vec3 look, in float roll, in float zoom ) {\n    mat3 camera = makeCamera( eye, look, roll );\n    vec3 direction = normalize( camera * vec3( uv.xy, zoom ) );\n\n    return Ray( eye, direction );\n}\n\nRay mouseCamera( in vec2 uv ) {    \n    vec2 mx = ( iMouse.xy / iResolution.xy ) -.5;\n        \n    vec2 T = TRIG( CAMERA_SCALE, mx.x * PI2 );\n    vec3 eye  = vec3( T.x, mx.y * CAMERA_SCALE + 2. , T.y );\n    vec3 look = vec3( .0 );\n    \n    float roll = .0;\n    float zoom = 1.8;\n    \n    return lookAtTheCamera( uv, eye, look, roll, zoom );\n}\n\nRay demoCamera( in vec2 uv ) {\n    vec2 T = TRIG( CAMERA_SCALE, iTime );\n    vec3 eye  = vec3( T.x, CAMERA_SCALE * .5, T.y );\n    vec3 look = vec3( .0 );\n    \n    float roll = 0.02 * T.x;\n    float zoom = 1. + .25 * abs( sin( iTime * .66 ) );\n    \n    eye = vec3( cos(iTime *.1)*33., T.x * .2, 4. );\n    look = eye;\n    look.z -= 4.;\n    roll = cos( iTime * .07 );\n    zoom = 1.;\n    \n    return lookAtTheCamera( uv, eye, look, roll, zoom );\n}\n\nRay cameraRay( in vec2 uv ) {\n    float down = iMouse.z;\n\n#ifndef GEAR_REPEAT\n    down = 1.;\n    //ray = lookAtTheCamera( uv, vec3(.0,.0,4.), vec3(.0), .0, 1. );\n#endif\n    if  ( down > .0 ) return mouseCamera( uv ); else return demoCamera( uv );\n\n//    return ( down > .0 ) ? mouseCamera( uv ) : demoCamera( uv );\n}\n\n/////////////////////////////////////////////////////////////////////////////\n// input\n\n// from https://www.shadertoy.com/view/4dsGRl\n// keycode table: https://css-tricks.com/snippets/javascript/javascript-keycodes/\nbool readKey( in int key, in bool toggle ) {\n    float keyVal = textureLod( iChannel0, vec2( (float(key)+.5)/256.0, toggle?.75:.25), 0.0 ).x;\n\treturn ( keyVal>.5 );\n}\n\nbool readKey( in int key ) {\n    return readKey( key, true );\n}\n\nvoid handleInput() {\n#ifdef REFLECTION_LEVEL\n    REFLECTION_LEVEL = mod( REFLECTION_LEVEL + ( readKey( 82 ) ? 1. : 0. ), 1. + REFLECTION_NICER );\n#endif\n\n}\n\n/////////////////////////////////////////////////////////////////////////////\n// from https://www.shadertoy.com/view/tlccWN\n\n#define FONT_SAMPLER    iChannel2\n#define FONT_STRIDE(n)  ((n)*vec2( .5, .0 ))\n\n#define FONT_STAR 28\n#define FONT_0    48\n#define FONT_DASH 45\n#define FONT_DOT  46\n#define FONT_T    84\n#define FONT_e    101\n#define FONT_s    115\n#define FONT_t    116\n\nfloat characterDistance( vec2 point, int character ) {\n    vec2 charAt = vec2( character % 16, 15 - character / 16 ) / 16. + 1./32.;    \n    float w = textureLod( FONT_SAMPLER, charAt + point / 16., .0 ).w;\n    vec2 box = abs( point / .8 );\n    return max( w, max( box.x, box.y ) );\n}\n\nfloat characterLength( int value ) {\n    return floor( 1. + log2( float( abs( ( value == 0 ) ? 1 : value ) ) ) / log2( 10.) );\n}\n\nfloat numericStringDistance( vec2 point, int value ) {\n    point -= FONT_STRIDE( characterLength( value ) - 1. );\n    float d = 0 == value ? characterDistance( point, FONT_0 ) : 1e33;  \n    for( int v = abs( value ) ; 0 != v ; v /= 10, point += FONT_STRIDE( 1. ) ) {\n        d = min( d, characterDistance( point, FONT_0 + v % 10 ) );\n    }  \n    return min( d, value < 0 ? characterDistance( point, FONT_DASH ) : 1e33 );\n}\n\nfloat numericStringDistance( in vec2 point, in float value, int decimals ) {\n    int vi = int( sign( value ) * floor( abs( value ) ) );\n    float d = numericStringDistance( point, vi );  \n    \n    point -= FONT_STRIDE( characterLength( vi ) );\n    d = min( d, characterDistance( point, FONT_DOT ) );\n\n    point -= FONT_STRIDE(1.);\n    \n    float vf = fract( abs( value ) ) * 10.;\n    int max = int( pow( 10., float( decimals ) ) );\n    for ( int i = 1 ; i <= decimals ; i++, vf *=10. , point -= FONT_STRIDE( 1. ) ) {\n        int n = int( vf ) % 10;\n        d = min( d, characterDistance( point, FONT_0 + n % 10 ) );\n    }\n\n    return d;\n}\n\nfloat distanceToShape( float d, float t ) {\n    return smoothstep( .5 - t, .5 + t, 1.-d );\n}\n\n/////////////////////////////////////////////////////////////////////////////\n// main function\n\nvec3 mainly( in vec2 fragCoord ) {\n    vec2 uv = ( 2. * fragCoord - iResolution.xy ) / iResolution.y;\n    \n    Ray ray = cameraRay( uv );\n    \n    vec2 d = rayMarch( ray.eye, ray.direction );\n    float missed = step( RAY_MARCH_TOO_FAR, d.x );\n    \n    vec3 point = ray.eye + ray.direction * d.x;\n    vec3 normal = sceneNormal( point );\n        \n    vec3 background = mix( vec3(.9,.4,.0), vec3(.0,.4,.9), uv.y * .8 );\n    vec3 color = colorPoint( point, normal, d, ray.eye );\n    \n\n#ifdef REFLECTION_LEVEL\n    if ( REFLECTION_NONE != REFLECTION_LEVEL ) {\n        color = mixInReflection( point, d.y, normal ,color, ray.eye );\n    }\n#endif\n\n#ifndef GEAR_REPEAT\n    float q = 1e33;\n    q = min( q, numericStringDistance( (uv - vec2(1.3,.8))/.1, ray.eye.x, 4 ) );\n    q = min( q, numericStringDistance( (uv - vec2(1.3,.7))/.1, ray.eye.y, 4 ) );\n    q = min( q, numericStringDistance( (uv - vec2(1.3,.6))/.1, ray.eye.z, 4 ) );\n    \n    q = min( q, numericStringDistance( (uv - vec2(1.3,.4))/.1, ray.direction.x, 4 ) );\n    q = min( q, numericStringDistance( (uv - vec2(1.3,.3))/.1, ray.direction.y, 4 ) );\n    q = min( q, numericStringDistance( (uv - vec2(1.3,.2))/.1, ray.direction.z, 4 ) );\n    \n    q = min( q, numericStringDistance( (uv - vec2(1.3,-.1))/.1, iMouse.x, 4 ) );\n    q = min( q, numericStringDistance( (uv - vec2(1.3,-.2))/.1, iMouse.y, 4 ) );\n    q = min( q, numericStringDistance( (uv - vec2(1.3,-.3))/.1, iMouse.z, 4 ) );\n    q = min( q, numericStringDistance( (uv - vec2(1.3,-.4))/.1, iMouse.w, 4 ) );\n    \n    if ( missed > .0 ) {\n        color = vec3( distanceToShape( q, .07 ) );\n        missed = .0;\n    }\n#endif\n\n    return mix( color, background, missed );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    handleInput();\n#if ANTI_ALIAS_STEPS == 1\n    fragColor = vec4( mainly( fragCoord ) , 1. );\n#else\n    vec3 color = vec3( .0 );\n    float a = ANTI_ALIAS_DISTANCE / float( ANTI_ALIAS_STEPS );\n    \n    for ( int y = 0 ; y < ANTI_ALIAS_STEPS ; y++ ) {\n        float ya = float( y ) * a;\n        for ( int x = 0 ; x < ANTI_ALIAS_STEPS ; x++ ) {\n            vec2 aa = vec2( float( x ) * a, ya );          \n            color += mainly( fragCoord + aa );\n        }\n    }\n    fragColor = vec4( color / float( ANTI_ALIAS_STEPS * ANTI_ALIAS_STEPS ), 1. );  \n#endif\n}\n\n// EOF\n/////////////////////////////////////////////////////////////////////////////", "image_inputs": [{"id": "4dXGRr", "previewfilepath": "/presets/tex00.jpg", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/presets/tex00.jpg", "ctype": "keyboard"}, {"id": "Xsf3Rr", "previewfilepath": "/media/ap/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg", "ctype": "texture"}, {"id": "4dXGzr", "previewfilepath": "/media/ap/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3tdyRl.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[1928, 2010, 2043, 2043, 2117], [2237, 2312, 2348, 2348, 2376], [2378, 2378, 2409, 2409, 2496], [2498, 2498, 2562, 2562, 2813], [2815, 2815, 2879, 2879, 2996], [3109, 3154, 3202, 3202, 3274], [3276, 3393, 3438, 3438, 3500], [3502, 3502, 3542, 3542, 3993], [3995, 3995, 4034, 4034, 4091], [4093, 4093, 4130, 4130, 6290], [6292, 6292, 6329, 6329, 6607], [6609, 6632, 6665, 6665, 6691], [6693, 6721, 6761, 6761, 6778], [6780, 6884, 6936, 6936, 7754], [7756, 7756, 7791, 7791, 8011], [8013, 8104, 8143, 8143, 8317], [8319, 8319, 8376, 8376, 8973], [8975, 8975, 9037, 9037, 9428], [9430, 9430, 9514, 9514, 10442], [10591, 10639, 10696, 10696, 10898], [10900, 10900, 10992, 10992, 11142], [11144, 11144, 11175, 11175, 11486], [11488, 11488, 11518, 11518, 11931], [11933, 11933, 11962, 11962, 12249], [12339, 12467, 12511, 12511, 12633], [12635, 12635, 12663, 12663, 12698], [12700, 12700, 12720, 12720, 12855], [12857, 13234, 13288, 13288, 13518], [13520, 13520, 13556, 13556, 13648], [13650, 13650, 13704, 13704, 14072], [14074, 14074, 14150, 14150, 14712], [14714, 14714, 14757, 14757, 14806], [14808, 14904, 14938, 14938, 16583], [16585, 16585, 16642, 16642, 17201]]}
{"id": "3tGcDR", "name": "Waiting for injection in 2021 !", "author": "sylvain69780", "description": "Hopefully 2021 will be the end of the COVID ?", "tags": ["covid", "syringe"], "likes": 19, "viewed": 158, "published": "Public", "date": "1610750220", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/*\n    Waiting for injection in 2021 !\n    -------------------------------\n    \n    Hopefully 2021 will be the end of the COVID ?\n    \n    Related references\n    \n    RayMarching starting point - BigWIngs\n    https://shadertoy.com/view/WtGXDD\n\n    Space curvature - iapafoto (font texture)\n    https://www.shadertoy.com/view/tdyBDh\n    \n    Distance functions - IQ\n    https://www.iquilezles.org/www/articles/distfunctions/distfunctions.htm\n    https://www.iquilezles.org/www/articles/distfunctions2d/distfunctions2d.htm    \n    \n    Ray Intersection Functions - IQ\n    https://www.shadertoy.com/playlist/l3dXRf\n    https://www.iquilezles.org/www/articles/intersectors/intersectors.htm\n    \n*/\n\n#define MAX_STEPS 100\n#define MAX_DIST 10.\n#define SURF_DIST .001\n\n#define S smoothstep\n#define T iTime\n#define AA\n\n#define ANIME_PISTON S(2.0,3.0,time)-S(3.5,5.0,time)\n\nmat2 Rot(float a) {\n    float s=sin(a), c=cos(a);\n    return mat2(c, -s, s, c);\n}\n\nfloat Hash21(vec2 p) {\n    p = fract(p*vec2(123.34,233.53));\n    p += dot(p, p+23.234);\n    return fract(p.x*p.y);\n}\n\nfloat sdCappedCylinder( vec3 p, float h, float r )\n{\n  vec2 d = abs(vec2(length(p.yz),p.x)) - vec2(h,r);\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\n// https://www.shadertoy.com/view/4lyfzw\nvec2 opRevolution( in vec3 p, float w )\n{\n    return vec2( length(p.xz) - w, p.y );\n}\nfloat opExtrussion( in vec3 p, in float sdf, in float h) {\n    vec2 w = vec2(sdf, abs(p.z) - h);\n  \treturn min(max(w.x,w.y),0.) + length(max(w,0.));\n}\n\n\nfloat sdBox(vec3 p, vec3 s) {\n    p = abs(p)-s;\n\treturn length(max(p, 0.))+min(max(p.x, max(p.y, p.z)), 0.);\n}\n\nfloat sdRoundedX( in vec2 p, in float w, in float r )\n{\n    p = abs(p);\n    return length(p-min(p.x+p.y,w)*0.5) - r;\n}\n\n// https://www.shadertoy.com/playlist/l3dXRf\n// https://www.iquilezles.org/www/articles/intersectors/intersectors.htm\n// cylinder defined by extremes pa and pb, and radious ra\nvec4 cylIntersect( in vec3 ro, in vec3 rd, in vec3 pa, in vec3 pb, float ra )\n{\n    vec3 ca = pb-pa;\n    vec3 oc = ro-pa;\n    float caca = dot(ca,ca);\n    float card = dot(ca,rd);\n    float caoc = dot(ca,oc);\n    float a = caca - card*card;\n    float b = caca*dot( oc, rd) - caoc*card;\n    float c = caca*dot( oc, oc) - caoc*caoc - ra*ra*caca;\n    float h = b*b - a*c;\n    if( h<0.0 ) return vec4(-1.0); //no intersection\n    h = sqrt(h);\n    float t = (-b-h)/a;\n    // body\n    float y = caoc + t*card;\n    if( y>0.0 && y<caca ) return vec4( t, (oc+t*rd-ca*y/caca)/ra );\n    // caps\n    t = (((y<0.0)?0.0:caca) - caoc)/card;\n    if( abs(b+a*t)<h ) return vec4( t, ca*sign(y)/caca );\n    return vec4(-1.0); //no intersection\n}\n\n#define dot2(x) dot(x,x)\n\nfloat sdCappedCone( vec3 p, float h, float r1, float r2 )\n{\n  vec2 q = vec2( length(p.xz), p.y );\n  vec2 k1 = vec2(r2,h);\n  vec2 k2 = vec2(r2-r1,2.0*h);\n  vec2 ca = vec2(q.x-min(q.x,(q.y<0.0)?r1:r2), abs(q.y)-h);\n  vec2 cb = q - k1 + k2*clamp( dot(k1-q,k2)/dot2(k2), 0.0, 1.0 );\n  float s = (cb.x<0.0 && ca.y<0.0) ? -1.0 : 1.0;\n  return s*sqrt( min(dot2(ca),dot2(cb)) );\n}\n\nfloat sdBox( in vec2 p, in vec2 b )\n{\n    vec2 d = abs(p)-b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\n// -- Text ------------------------------------------------\n// Adapted from [iapafoto] https://www.shadertoy.com/view/tdyBDh\n// --------------------------------------------------------\n\nint[] gtxt = int[] (50,48,50,48); // 2021\n\nfloat sdFont(in vec2 p, in int c) {\n    vec2 uv = (p + vec2(float(c%16), float(15-c/16)) + .5)/16.;\n    return max(max(abs(p.x) - .25, max(p.y - .35, -.38 - p.y)), textureLod(iChannel2, uv, 0.).w - 127./255.);\n}\n\nconst float letterSpacing=2.45;\n\nfloat sdMessage2D(in vec2 p, in int[4] txt) { \n \tfloat d = 99., w = letterSpacing; // letter width  spacing\n    for (int id = 0; id<4; id++){\n    \td = min(d, sdFont(p, txt[id]));   \n    \tp.x -= w; \n    }\n    return d-.015;\n}\n\n// extrussion replaced by Cylinder mapping\nfloat sdMessage3D(in vec3 p, in int[4] txt, in float scale, in float h) { \n    return opExtrussion(p, sdMessage2D(p.xy/scale, txt)*scale, h);\n}\n\nfloat sdPiston(vec3 p,float l) {\n    float pusher = sdCappedCylinder(p,0.3,0.01)-0.03;\n    float pilar=opExtrussion(p.yzx-vec3(0.0,0.0,l),sdRoundedX(p.yz,0.20,0.02),l);\n    return min(pusher,pilar);\n}\n\nfloat sdSyringeBody(vec3 p) {\n    float bottom = sdCappedCylinder(p,0.35,0.01)-0.03;\n    bottom=max(bottom,-(length(p.yz)-0.18));\n    float end = sdCappedCone(p.yxz-vec3(0.0,2.9,0.0),0.05,0.25,0.08)-0.01;\n    end = min(end,sdCappedCylinder(p-vec3(3.0,0.0,0.0),0.08,0.10));\n    float d = min(bottom,end);\n    return d;\n}\n\nfloat sdGraduations(vec3 p) {\n    float r=0.25;\n    p.x-=0.8;\n    // fold on a Cylinder along x\n    float d = abs(length(p.yz)-r)-0.001;\n    // box with the tube\n    if ( d > 0.1 ) return d;\n    float a=atan(p.y,p.z);\n    vec2 uv = vec2(p.x,a*r);\n    float scale=0.2;\n    // let's try some animation of numbers\n    float grad1 = letterSpacing*scale;\n    float grad2 = letterSpacing*scale/5.0;\n    float time=mod(T,6.0);\n    float atime = S(0.0,2.0,time);\n    float jump=0.0;\n    if ( uv.x > letterSpacing*scale*2.5 && uv.x < letterSpacing*scale*3.5 ) {\n        jump= atime > 0.5 ? (atime-1.0)*2.0 : atime*2.0;\n    }\n    gtxt[3]= time > 0.5 && time < 5.0 ? 49 : 48;   \n    float dtxt = sdMessage2D((uv-vec2(0.0,jump))/scale, gtxt)*scale;\n    uv.x -= round(uv.x/grad1)*grad1;\n    float dgrad = sdBox(uv-vec2(0.0,0.2+abs(jump)),vec2(0.01,0.1));\n    dgrad = min(dgrad,sdBox(uv-vec2(clamp(round(uv.x/grad2),1.0,2.0)*grad2,0.2+0.05),vec2(0.01,0.05)));\n    dgrad = min(dgrad,sdBox(uv-vec2(clamp(round(uv.x/grad2),-2.0,-1.0)*grad2,0.2+0.05),vec2(0.01,0.05)));\n    float dtxt3d = max(min(dtxt,dgrad),d);\n    return max(dtxt3d-0.003,max(p.x-2.0,-0.8-p.x));  \n}\n\nfloat sdNeedleBase(vec3 p) {\n    float d = sdCappedCylinder(p-vec3(3.1,0.0,0.0),0.15,0.01)-0.01;\n    d = min(d,sdCappedCylinder(p-vec3(3.19,0.0,0.0),0.09,0.07)-0.01);\n    float end = sdCappedCone(p.yxz-vec3(0.0,3.35,0.0),0.1,0.08,0.04);\n    d = min(d,end);\n    return d;\n}\n\nfloat sdNeedle(vec3 p) {\n    float dPlan=-dot(p,normalize(vec3(1.0,0.0,1.0)))+3.0;\n    return max(abs(sdCappedCylinder(p-vec3(4.30,0.0,0.0),0.015,0.9))-0.002, -dPlan);   \n}\n\nvec2 GetDistAndMat(vec3 p) {\n    p.x-=-1.5;\n    float d=sdSyringeBody(p-vec3(0.0,0.0,0.0));\n    float m=0.0;\n    float time=mod(T,6.0);\n    float atime = ANIME_PISTON;\n    float l=1.5;\n    float piston=sdPiston(p-vec3(-2.6+2.2*atime,0.0,0.0),l);\n    d = min(d,piston);\n    float graduations=sdGraduations(p);\n    d = min(d,graduations);\n    float joint = sdCappedCylinder(p-vec3(-2.6+2.0*l+2.2*atime,0.0,0.0),0.19,0.05)-0.03;\n    if ( joint < d ) { d=joint; m=1.0; };\n    float needleBase=sdNeedleBase(p);\n    if ( needleBase < d ) { d=needleBase; m=2.0; };\n    float needle=sdNeedle(p);\n    if ( needle < d ) { d=needle; m=3.0; };\n   \treturn vec2(d,m);\n}\n\nfloat GetDist(vec3 p) {\n   \treturn GetDistAndMat(p).x;\n}\n\n// http://iquilezles.org/www/articles/rmshadows/rmshadows.htm\nfloat calcSoftshadow( in vec3 ro, in vec3 rd, in float mint, in float tmax )\n{\n    // bounding volume\n    float tp = (0.8-ro.y)/rd.y; if( tp>0.0 ) tmax = min( tmax, tp );\n\n    float res = 1.0;\n    float t = mint;\n    for( int i=0; i<24; i++ )\n    {\n\t\tfloat h = GetDist( ro + rd*t );\n        float s = clamp(8.0*h/t,0.0,1.0);\n        res = min( res, s*s*(3.0-2.0*s) );\n        t += clamp( h, 0.02, 0.2 );\n        if( res<0.004 || t>tmax ) break;\n    }\n    return clamp( res, 0.0, 1.0 );\n}\n\nfloat RayMarch(vec3 ro, vec3 rd) {\n\tfloat dO=0.;\n    \n    for(int i=0; i<MAX_STEPS; i++) {\n    \tvec3 p = ro + rd*dO;\n        float dS = GetDist(p);\n        dO += dS;\n        if(dO>MAX_DIST || abs(dS)<SURF_DIST) break;\n    }\n    \n    return dO;\n}\n\nvec3 GetNormal(vec3 p) {\n\tfloat d = GetDist(p);\n    vec2 e = vec2(.001, 0);    \n    vec3 n = d - vec3(\n        GetDist(p-e.xyy),\n        GetDist(p-e.yxy),\n        GetDist(p-e.yyx));    \n    return normalize(n);\n}\n\nfloat calcOcclusion( in vec3 pos, in vec3 nor )\n{\n\tfloat occ = 0.0;\n    float sca = 1.0;\n    for( int i=0; i<5; i++ )\n    {\n        float h = 0.01 + 0.11*float(i)/4.0;\n        vec3 opos = pos + h*nor;\n        float d = GetDist( opos );\n        occ += (h-d)*sca;\n        sca *= 0.95;\n    }\n    return clamp( 1.0 - 2.0*occ, 0.0, 1.0 );\n}\n\n// BigWings's template\n// https://www.youtube.com/watch?v=PBxuVlp7nuM\n// https://www.shadertoy.com/view/WtGXDD\nvec3 GetRayDir(vec2 uv, vec3 p, vec3 l, float z) {\n    vec3 f = normalize(l-p),\n        r = normalize(cross(f,vec3(0,1,0))),\n        u = cross(r,f),\n        c = f*z,\n        i = c + uv.x*r + uv.y*u,\n        d = normalize(i);\n    return d;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{  \n    vec3 col = vec3(0);\n    vec3 tcol = vec3(0);\n    vec3 ro = vec3(0, 0.5, 4);\n    if ( iMouse.x > 10.0 ) {\n        vec2 m = iMouse.xy/iResolution.xy-0.5;\n        ro.yz *= Rot(-m.y*3.14);\n        ro.xz *= Rot(-m.x*6.2831);\n    } else {\n        float time=mod(T,12.0);\n        float atime = S(3.0,6.0,time)-S(9.0,12.0,time);\n        ro.z-=(2.0-atime*2.0);\n        ro.xz *= Rot(-atime*6.28);\n    }\n\n#ifdef AA\n\tfor (float dx = 0.; dx <= 1.; dx++)\n\t\tfor (float dy = 0.; dy <= 1.; dy++) {\n\t\t\tvec2 uv = (fragCoord + vec2(dx, dy) * .5 - .5 * iResolution.xy) / iResolution.y;\n#else\n\t\t\tvec2 uv = (fragCoord - .5 * iResolution.xy) / iResolution.y;\n#endif\n    vec3 bgcol=vec3(.1+.01*Hash21(uv))*(.5-abs(uv.y));\n    col = bgcol;            \n    vec3 rd = GetRayDir(uv, ro, vec3(0), 1.);\n\n    vec3  sundir = normalize(vec3(2,1,1.5));\n    vec3  sun_hal = normalize( sundir-rd );    \n    vec3  sun_color = vec3(8.10,6.00,4.20);\n    float d = RayMarch(ro, rd);    \n    if(d<MAX_DIST) {\n    \tvec3 p = ro + rd * d;\n    \tvec3 n = GetNormal(p);        \n        float m = GetDistAndMat(p).y;\n        float ks = 1.0;\n        // https://iquilezles.org/www/articles/outdoorslighting/outdoorslighting.htm\n        // lighting , in these few lines there is all the magic thanks to IQ \n        // I'am just starting to understand how it works, sorry\n        float occ = calcOcclusion( p, n ); // occusion has a big impact\n        vec3  sun_lig = sundir;\n        float sun_dif = clamp(dot( n, sun_lig ), 0.0, 1.0 );\n        float sun_sha = calcSoftshadow( p, sun_lig, 0.02, 3.5 );\n\t\tfloat sun_spe = ks*pow(clamp(dot(n,sun_hal),0.0,1.0),8.0)*sun_dif*(0.04+0.96*pow(clamp(1.0+dot(sun_hal,rd),0.0,1.0),5.0));\n\t\tfloat sky_dif = sqrt(clamp( 0.5+0.5*n.y, 0.0, 1.0 ));\n        float bou_dif = sqrt(clamp( 0.1-0.9*n.y, 0.0, 1.0 ))*clamp(1.0-0.1*p.y,0.0,1.0);\n        vec3 c = vec3(0); // material color\n        if ( m < 1.0 ) {\n            // body is white\n            c = vec3(0.15);\n        } else if ( m < 2.0 ) {\n            // joint is black\n            c = vec3(0.01);\n        } else if ( m < 3.0 ) {\n            // needle base is blue\n            c = vec3(0.01,0.01,0.2);\n        } else if ( m < 4.0 ) {\n            // needle is metallic\n            c = vec3(0.1,0.1,0.1);\n        }\n  \t\tvec3 lin = vec3(0.0);\n        lin += sun_dif*sun_color*sun_sha*.7;\n        lin += sky_dif*vec3(0.50,0.70,1.00)*occ*2.0;\n        lin += bou_dif*vec3(0.40,1.00,0.40)*occ*2.0*1.3;\n\t\tcol = c*lin;\n\t\tcol += sun_spe*vec3(8.10,6.00,4.20)*sun_sha;\n        \n    }\n    \n    // inner liquid\n    vec4 liquid = cylIntersect(ro,rd,vec3(-1.5,0.0,0.0), vec3(1.37,0.0,0.0), 0.23 );\n    float d3 = liquid.x; //RayMarch3(ro, rd);    \n    if(d3 > 0.0 && d3 < d ) {\n    \tvec3 p = ro + rd * d3;\n    \tvec3 n = liquid.yzw;        \n    \tfloat dif = dot(n,sundir)*.5+.5;\n        float time=mod(T,6.0);\n        float atime = ANIME_PISTON;\n        float fre = max(0.0,-dot(n,rd));  // fake transparency factor\n        fre=sqrt(fre);\n        float position = (p.x-2.2*atime+1.05);\n        vec3 c = position > 0.0 ? vec3(0.1,0.01,0.2) : vec3(1)*0.2 ;\n        if ( position < 0.0 ) { fre=1.0-fre; }\n    \tcol = mix(col,c*dif,fre);\n    }\n    // second layer\n    vec4 glass = cylIntersect(ro,rd,vec3(-1.5,0.0,0.0), vec3(1.37,0.0,0.0), 0.24 );\n    float d2 = glass.x;    \n    if(d2> 0.0 && d2 < d ) {\n    \tvec3 p = ro + rd * d2;\n    \tvec3 n = glass.yzw;        \n    \tfloat dif = dot(n, sundir)*.5+.5;\n        float fre = max(0.0,-dot(n,rd));  // fake transparency factor\n        fre=1.0-fre;   \n        fre*=fre;\n        float ks = 2.0; \n        float sun_spe = ks*pow(clamp(dot(n,sun_hal),0.0,1.0),8.0)*dif*(0.04+0.96*pow(clamp(1.0+dot(sun_hal,rd),0.0,1.0),5.0));   \n        vec3 c = vec3(1)*.2;\n    \tcol = mix(col,c,fre);  \n        col+=sun_spe*sun_color;\n    }\n    tcol+=col;\n#ifdef AA\n\t\t}\n\ttcol /= 4.;\n#endif\n    \n    col = pow(tcol, vec3(.4545));\t// gamma correction    \n    fragColor = vec4(col,1.0);\n}\n", "image_inputs": [{"id": "4dXGzr", "previewfilepath": "/media/ap/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png", "channel": 2, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3tGcDR.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 865, 884, 884, 946], [948, 948, 970, 970, 1064], [1066, 1066, 1118, 1118, 1225], [1227, 1268, 1309, 1309, 1353], [1354, 1354, 1412, 1412, 1504], [1507, 1507, 1536, 1536, 1617], [1619, 1619, 1674, 1674, 1737], [1739, 1915, 1994, 1994, 2641], [2669, 2669, 2728, 2728, 3041], [3043, 3043, 3080, 3080, 3160], [3382, 3391, 3426, 3426, 3602], [3637, 3637, 3682, 3682, 3861], [3863, 3906, 3979, 3979, 4049], [4051, 4051, 4083, 4083, 4251], [4253, 4253, 4282, 4282, 4572], [4574, 4574, 4603, 4603, 5724], [5726, 5726, 5754, 5754, 5998], [6000, 6000, 6024, 6024, 6172], [6174, 6174, 6202, 6202, 6829], [6831, 6831, 6854, 6854, 6887], [6889, 6951, 7029, 7052, 7438], [7440, 7440, 7474, 7474, 7685], [7687, 7687, 7711, 7711, 7899], [7901, 7901, 7950, 7950, 8236], [8238, 8349, 8399, 8399, 8589], [8591, 8591, 8648, 8648, 12581]]}
{"id": "3tGcWK", "name": "Color Light Beam", "author": "zhoucy001", "description": "It is inspired by an example from The Book of Shaders(section COLORS).", "tags": ["2d", "light"], "likes": 1, "viewed": 83, "published": "Public", "date": "1611734249", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define TWO_PI 6.28318530718\n#define PI 3.14159265854\n#define HALF_PI 1.5707963267948966\n\n//  Function from Iñigo Quiles\n//  https://www.shadertoy.com/view/MsS3Wc\nvec3 hsb2rgb( in vec3 c ){\n    vec3 rgb = clamp(abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),\n                             6.0)-3.0)-1.0,\n                     0.0,\n                     1.0 );\n    rgb = sin(rgb*abs(10.0*(fract(iTime*0.1)*2.0-1.0)));\n    return c.z * mix(vec3(1.0), rgb, c.y);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    vec3 color = vec3(0.0);\n    vec2 toCenter = uv-vec2(0.5);\n    float angle = atan(toCenter.y,toCenter.x);\n    float radius = length(toCenter)*2.0;\n    color = hsb2rgb(vec3((angle/TWO_PI)+0.5,radius,1.0));\n    fragColor = vec4(color,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3tGcWK.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[90, 164, 190, 190, 446], [448, 448, 505, 505, 788]]}
{"id": "3tGXRc", "name": "Pie - gradient 2D", "author": "iq", "description": "Signed distance and gradient to a [url=https://www.shadertoy.com/view/3l23RK]pie[/url]. Faster than central differences or automatic differentiation/dual numbers most probably. ", "tags": ["2d", "distancefield", "sdf", "gradient", "distance", "pie"], "likes": 10, "viewed": 434, "published": "Public API", "date": "1610948151", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// The MIT License\n// Copyright © 2021 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// Signed distance and gradient to a pie. Probably\n// faster than central differences or automatic \n// differentiation/dual numbers.\n\n// List of other 2D distances+gradients:\n//\n// https://iquilezles.org/www/articles/distgradfunctions2d/distgradfunctions2d.htm\n//\n// and\n//\n// https://www.shadertoy.com/playlist/M3dSRf\n\n// .x = f(p)\n// .y = ∂f(p)/∂x\n// .z = ∂f(p)/∂y\n// .yz = ∇f(p) with ‖∇f(p)‖ = 1\n// c is the sin/cos of the angle. r is the radius\nvec3 sdgPie( in vec2 p, in vec2 c, in float r )\n{\n    float s = sign(p.x); p.x = abs(p.x);\n    \n    float l = length(p);\n    float n = l - r;\n    vec2  q = p - c*clamp(dot(p,c),0.0,r);\n\tfloat m = length(q)* sign(c.y*p.x-c.x*p.y);\n    \n    vec3  res = (n>m) ? vec3(n,p/l) : vec3(m,q/m);\n    return vec3(res.x,s*res.y,res.z);\n}\n\n#define AA 2\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 tot = vec3(0.0);\n    \n    #if AA>1\n    for( int m=0; m<AA; m++ )\n    for( int n=0; n<AA; n++ )\n    {\n        // pixel coordinates\n        vec2 o = vec2(float(m),float(n)) / float(AA) - 0.5;\n        vec2 p = (-iResolution.xy + 2.0*(fragCoord+o))/iResolution.y;\n        #else    \n        vec2 p = (-iResolution.xy + 2.0*fragCoord)/iResolution.y;\n        #endif\n\n        // animation\n        float t =            3.14*(0.5+0.5*cos(iTime*0.52));\n        vec2  w = vec2(0.50,0.25)*(0.5+0.5*cos(iTime*vec2(1.1,1.3)+vec2(0.0,2.0)));\n\n        // sdf(p) and gradient(sdf(p))\n        vec3  dg = sdgPie(p,vec2(sin(t),cos(t)), 0.65);\n        float d = dg.x;\n        vec2  g = dg.yz;\n\n        // central differenes based gradient, for comparison\n        // g = vec2(dFdx(d),dFdy(d))/(2.0/iResolution.y);\n\n        // coloring\n        vec3 col = (d>0.0) ? vec3(0.9,0.6,0.3) : vec3(0.4,0.7,0.85);\n        col *= 1.0 + vec3(0.5*g,0.0);\n      //col = vec3(0.5+0.5*g,1.0);\n        col *= 1.0 - 0.7*exp(-8.0*abs(d));\n        col *= 0.9 + 0.1*cos(150.0*d);\n        col = mix( col, vec3(1.0), 1.0-smoothstep(0.0,0.01,abs(d)) );\n   \n\t    tot += col;\n    #if AA>1\n    }\n    tot /= float(AA*AA);\n    #endif\n\n\tfragColor = vec4( tot, 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3tGXRc.jpg", "access": "shaders20k", "license": "mit", "functions": [[1398, 1543, 1592, 1592, 1868], [1884, 1884, 1941, 1941, 3166]]}
{"id": "3tGyWD", "name": "Test Star2", "author": "gtomasi", "description": "Star", "tags": ["star"], "likes": 2, "viewed": 56, "published": "Public", "date": "1610985890", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float createStar(vec2 vUv, float amplitude, float offset) {\n    float mipi = 3.14 / 2.;\n    float a = mipi - cos(iTime);\n    float time = a * 80.;\n    float speed = 0.6;\n    float radius = .5;\n    float size = 0.0001;\n    float angle = atan(vUv.y, vUv.x);\n    uint count = 5u;\n    float starAngle = angle + offset;\n    float disp = sin(starAngle*float(count)) * amplitude;\n    float dist = length(vUv) + disp / time;\n    float sigma = abs(dist-radius);\n    return smoothstep(size, size+0.01, sigma);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy * 2.0 - 1.0;\n    uv.x *= iResolution.x / iResolution.y;    \n    \n    vec3 col1 = vec3(0, 0, 0);\n    vec3 col2 = vec3(0.5, 0.5, 0.5);\n    vec3 colfinal = vec3(0., 0., 0.);\n    float distBetween = 0.07;\n    for (int i = 0; i < 9; i++) {\n      float offset = float(i) * distBetween;\n      colfinal += mix(col2, col1, createStar(uv, 7., offset));\n    }\n    fragColor = vec4(colfinal,1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3tGyWD.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 59, 59, 501], [503, 503, 559, 559, 985]]}
{"id": "3tKcDR", "name": "Broken Heart", "author": "luckyballa", "description": "Spreading love", "tags": ["particles", "heart", "bump"], "likes": 2, "viewed": 69, "published": "Public", "date": "1610815024", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float rand(vec2 n) { return fract(sin(dot(n, vec2(12.9898, 4.1414))) * 43758.5453); }\n\nfloat noise(vec2 n) {\n    const vec2 d = vec2(0.0, 1.0);\n    vec2 b = floor(n), f = smoothstep(vec2(0.0), vec2(1.0), fract(n));\n    return mix(mix(rand(b), rand(b + d.yx), f.x), mix(rand(b + d.xy), rand(b + d.yy), f.x), f.y);\n}\n\nvec2 rot(vec2 p, in float an ) { float cc = cos(an); float ss = sin(an); return mat2(cc,-ss,ss,cc)*p;}\n\nfloat heart(vec2 uv, float noise) { return length(vec2(uv.x,uv.y*1.2 - pow(abs(uv.x) * 0.2, 0.6)) * noise); }\n\nfloat hMap(vec2 uv) {\n    float h = heart(uv, 1.);\n    float r = -(smoothstep(0.2,0.205, h) - 1. \n    + (cos(iTime / 4.) * smoothstep(0.17,0.1705, h)) / 3. \n    + smoothstep(0.14,0.1405, h) / 3.) * 1.2;\n    \n    r -= min(smoothstep(0.14,0.145, heart(uv, noise(uv*80.))) / 5., r);\n    return r;\n}\n\nvec3 hCol(vec2 uv) {\n\tvec2 ld = vec2(cos(iTime),sin(iTime)) * 0.004;\n    float c = hMap(uv);\n    float c2 = hMap(uv + ld);  \n    float b = max(c2 - c, 0.)*10.;\n    vec3 col = vec3(0.5,0.2,0.4)*pow(b, 3.)*.01;\n    col += c2 * vec3(0.55, 0.2,.39) * 1.2;\n    return col;\n  }\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = (2.0*fragCoord-iResolution.xy)/min(iResolution.y,iResolution.x) / 1.5;\n    vec2 p = uv * 8.;\n    p.y += iTime * 4. + sin(p.x+p.y * 0.7 + iTime * .2) * 0.4;\n    p.x +=  cos(p.y * 1.5) * normalize(p).x * 0.5;\n    vec2 cp = rot(fract(p.xy) -.5,  iTime * 2.);\n    p -= vec2(cos(iTime), sin(iTime)) ;\n    vec2 clp = (fract(uv.xy + p.xy * 0.2 - length(uv)) -.5)  + vec2(cos(iTime), sin(iTime)) / 5.;\n    float clip = smoothstep(0.5, 0., length(clp));\n    uv *= 0.8;\n    vec3 col = hCol(uv); \n    vec3 bc = vec3(0.3, 0.07, 0.2);\n    col = max(max(bc * max(hMap(cp) / 3., hMap(uv)) * clip, col), 0.);\n    col += bc * (0.3 - hMap(uv)) * 1.2;\n    col += ((max(smoothstep(0.3, 0.05, length(uv )), 0.) ) / 20.) *  max(hMap(uv), 0.);\n    col += length(uv * 0.3) / 4.;\n\n    fragColor = vec4(col * 1.9 ,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3tKcDR.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 20, 20, 85], [87, 87, 108, 108, 314], [316, 316, 348, 348, 418], [420, 420, 455, 455, 529], [531, 531, 552, 552, 826], [828, 828, 848, 848, 1099], [1101, 1101, 1158, 1158, 1968]]}
{"id": "3tKcDt", "name": "Neural Walt Disney", "author": "yearofthewhopper", "description": "wooo!", "tags": ["raymarching", "sdfs", "neuralnetworks", "walt"], "likes": 3, "viewed": 102, "published": "Public", "date": "1611982936", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//CC0 1.0 Universal https://creativecommons.org/publicdomain/zero/1.0/\n//To the extent possible under law, Blackle Mori has waived all copyright and related or neighboring rights to this work.\n// original shader here https://www.shadertoy.com/view/wtVyWK\nvec3 erot(vec3 p, vec3 ax, float ro) {\n    return mix(dot(p,ax)*ax,p,cos(ro))+sin(ro)*cross(ax,p);\n}\n\nfloat scene(vec3 p) {\n    if (length(p) > 1.) {\n        return length(p)-.8;\n    }\n    \n   vec4 f0_0=sin(p.y*vec4(-4.13,-.07,1.48,-.05)+p.z*vec4(1.65,-2.06,2.38,3.63)+p.x*vec4(-2.66,2.36,1.19,.64)+vec4(4.03,6.53,4.13,-6.25));\n    vec4 f0_1=sin(p.y*vec4(-.14,.33,-.32,-3.74)+p.z*vec4(2.94,-3.61,4.17,-4.14)+p.x*vec4(4.89,-2.37,-2.05,-3.58)+vec4(1.02,-4.86,6.21,.72));\n    vec4 f0_2=sin(p.y*vec4(.40,-3.00,.47,-1.69)+p.z*vec4(-3.62,.86,-.28,2.37)+p.x*vec4(-4.88,.51,2.60,.80)+vec4(-3.03,1.58,5.23,.17));\n    vec4 f0_3=sin(p.y*vec4(2.48,4.37,-3.21,1.57)+p.z*vec4(.51,1.87,-3.12,-.36)+p.x*vec4(.41,-.48,-.66,-1.41)+vec4(-4.29,1.16,3.77,-5.30));\n    vec4 f1_0=sin(mat4(-.17,.28,.10,.13,-.59,-.66,-.77,.08,-.24,-.22,-.40,.78,-.03,.04,.52,.00)*f0_0+\nmat4(-.53,.26,-.14,.29,-.45,.13,-.30,.72,-.21,-.12,.02,.25,.05,-.10,.08,.26)*f0_1+\n    mat4(-.02,-.14,-.66,-.08,.06,.46,.40,-.12,.42,.59,-.27,.50,-.52,-.09,.15,.20)*f0_2+\n    mat4(.05,-.13,-1.07,1.10,.81,.24,.04,.16,-.41,.08,-.38,.43,.40,-.89,-.69,.90)*f0_3+\n    vec4(-2.19,.66,-1.85,-.58))/1.0+f0_0;\nvec4 f1_1=sin(mat4(-.04,.44,-.14,-.09,-.44,-.29,.18,.63,-.32,-.29,-.21,-.48,-.04,-.51,.24,.02)*f0_0+\n    mat4(.54,.04,-.25,.37,-.05,-.42,.18,-.19,-.70,-.20,-.10,1.00,.04,-.12,-.07,.74)*f0_1+\n    mat4(-.23,-.06,.44,-.31,.75,-.59,.11,.49,-.50,.56,.52,-.52,.14,.52,1.06,-.42)*f0_2+\n    mat4(-.09,-.04,-.05,.63,.05,-.66,-.17,-.03,-.61,.21,-.56,.32,.25,-.07,-.30,-.08)*f0_3+\n    vec4(2.77,-1.48,2.87,-3.56))/1.0+f0_1;\nvec4 f1_2=sin(mat4(.44,-.21,.07,-.47,.60,-.92,-.26,-.50,.20,-.31,-.56,.11,.58,-.31,-.55,-.07)*f0_0+\n    mat4(-.68,.03,.39,-.21,.03,-.13,-.21,.05,.19,.35,-.33,.03,-.15,-.09,-.12,-.01)*f0_1+\n    mat4(.36,-.05,-.51,.28,.05,-.26,.11,.34,.02,.29,1.16,.68,-.60,.49,.18,.44)*f0_2+\n    mat4(-.01,-.17,-1.25,-.26,.14,.63,.32,-.07,.42,.23,-.07,.25,.01,.22,.19,-.52)*f0_3+\n    vec4(-.82,-1.84,-.12,-2.06))/1.0+f0_2;\nvec4 f1_3=sin(mat4(.25,-.28,.06,-.60,-.29,.67,-.54,-.53,-.09,.01,-.25,-.68,-.39,-.19,.04,-.40)*f0_0+\n    mat4(.25,.16,-.29,-.53,.08,.02,-.20,-.61,-.92,-.24,.26,.14,-.15,.12,-.07,.06)*f0_1+\n    mat4(-.25,-.12,.56,-.36,.38,.62,-.39,-.32,-.89,-.45,1.01,.19,.74,.12,-.47,.07)*f0_2+\n    mat4(.64,-.29,-.60,-.05,-.45,.80,.13,-.27,.20,-.12,-.34,-.34,.30,.06,-.91,.18)*f0_3+\n    vec4(.90,-2.76,.73,2.84))/1.0+f0_3;\nvec4 f2_0=sin(mat4(-.50,.78,.15,-.48,-1.01,.01,-1.07,1.10,-.55,.56,-.41,-.46,.09,-.01,-.14,.01)*f1_0+\n    mat4(.97,.07,.62,-.14,-.26,-.19,-.67,.65,-.15,-.55,-.08,-1.22,.08,.24,.62,-.10)*f1_1+\n    mat4(-.50,.18,-.21,-.58,.26,-.17,.12,.51,.11,-.18,.02,-1.04,.71,-.70,.79,-.72)*f1_2+\n    mat4(.21,-.66,.56,.23,1.25,.59,-.20,.97,-.23,.03,-.40,.65,.25,.07,.04,.64)*f1_3+\n    vec4(1.80,2.34,1.60,2.12))/1.4+f1_0;\nvec4 f2_1=sin(mat4(.20,.36,.42,-.36,-.15,.32,-.44,-.41,-.25,-.43,-.49,-.12,.72,.52,.31,.77)*f1_0+\n    mat4(-.46,-.68,.43,.50,.32,-.31,.35,-.05,-.45,.54,.75,1.16,-.03,.19,.56,.19)*f1_1+\n    mat4(-.59,.59,-.81,1.23,-.29,-1.18,-.01,-.14,-1.21,.80,-.48,.78,-.49,-1.50,.03,.61)*f1_2+\n    mat4(-.54,.06,-.06,.19,-.25,-.34,-1.38,-.99,.34,-1.49,.51,-.65,.15,.11,.41,-.40)*f1_3+\n    vec4(-.86,2.45,-1.41,2.41))/1.4+f1_1;\nvec4 f2_2=sin(mat4(.58,-.63,-.22,.58,-.68,.28,.91,.98,-.17,.10,.29,-.58,.20,.31,-.19,-.94)*f1_0+\n    mat4(.38,.71,-.32,-.93,-1.24,-.51,-.23,.17,.26,-.52,.59,-.53,.67,.40,-.25,.21)*f1_1+\n    mat4(-.25,.06,.23,-.28,1.08,.50,-.17,.39,.50,-.02,.28,-.15,-.51,.53,1.30,-.35)*f1_2+\n    mat4(.29,.02,-.06,-.20,.05,.22,-.41,.82,.15,.33,.16,.62,-1.00,-.21,-.13,-.13)*f1_3+\n    vec4(-2.04,-1.12,2.20,2.19))/1.4+f1_2;\nvec4 f2_3=sin(mat4(-1.60,.59,.78,-.36,-.74,-.25,-.95,.29,1.02,.60,-.05,-.09,.05,.60,1.10,-.70)*f1_0+\n    mat4(.87,.93,-.99,1.10,-.10,.76,-.92,-.52,-.59,.41,.06,-.49,-.14,.06,-.03,.77)*f1_1+\n    mat4(.52,-.69,-.03,-.82,.31,.33,-1.26,.92,.00,-.35,.66,-.56,-.03,-1.56,-1.20,.85)*f1_2+\n    mat4(.46,.72,.64,-.30,2.39,.11,-1.27,.25,.13,.54,.14,.38,.63,.43,-.05,.13)*f1_3+\n    vec4(2.27,.73,.82,1.94))/1.4+f1_3;\nreturn dot(f2_0,vec4(.05,-.04,.05,.04))+\n    dot(f2_1,vec4(.06,-.04,-.04,.05))+\n    dot(f2_2,vec4(-.05,-.06,.09,-.05))+\n    dot(f2_3,vec4(-.02,.01,.05,-.06))+\n    0.285;\n}\n\nvec3 norm(vec3 p) {\n    mat3 k = mat3(p,p,p)-mat3(0.001);\n    return normalize(scene(p) - vec3(scene(k[0]),scene(k[1]),scene(k[2])));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-0.5*iResolution.xy)/iResolution.y;\n    vec2 mouse = (iMouse.xy-0.5*iResolution.xy)/iResolution.y;\n\n    vec3 cam = normalize(vec3(1.5,uv));\n    vec3 init = vec3(-3.,0,0);\n    \n    float yrot = 0.5;\n    float zrot = iTime*.2;\n    if (iMouse.z > 0.) {\n        yrot += -4.*mouse.y;\n        zrot = 4.*mouse.x;\n    }\n    cam = erot(cam, vec3(0,1,0), yrot);\n    init = erot(init, vec3(0,1,0), yrot);\n    cam = erot(cam, vec3(0,0,1), zrot);\n    init = erot(init, vec3(0,0,1), zrot);\n    \n    vec3 p = init;\n    bool hit = false;\n    for (int i = 0; i < 150 && !hit; i++) {\n        float dist = scene(p);\n        hit = dist*dist < 1e-6;\n        p+=dist*cam;\n        if (distance(p,init)>5.) break;\n    }\n    vec3 n = norm(p);\n    vec3 r = reflect(cam,n);\n    vec3 nz = p - erot(p, vec3(1), 2.) + erot(p, vec3(1), 4.);\n    float spec = length(sin(r*3.5+sin(nz*120.)*.15)*.4+.6)/sqrt(3.);\n    spec *= smoothstep(-.3,.2,scene(p+r*.2));\n    vec3 col = vec3(.3,.22,.2)*spec + pow(spec,8.);\n    float bgdot = length(sin(cam*10.)*.4+.6)/2.;\n    vec3 bg = vec3(.0,.4,.91) * bgdot + pow(bgdot, 5.);\n    fragColor.xyz = hit ? col : bg;\n    fragColor = smoothstep(-.02,1.05,sqrt(fragColor)) * (1.- dot(uv,uv)*.5);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3tKcDt.jpg", "access": "shaders20k", "license": "cc0-1.0", "functions": [[0, 255, 293, 293, 355], [357, 357, 378, 378, 4428], [4430, 4430, 4449, 4449, 4565], [4567, 4567, 4624, 4624, 5845]]}
{"id": "3tKcRm", "name": "Disjoint Union", "author": "tomoe", "description": "Disjoint union of noises processed by threshold (Up: Perlin noise base, Down: fBm base)\nL: step function (B&W)\nC: smoothstep function (soft-edge B&W)\nR: ramp function (mask)", "tags": ["bd202101"], "likes": 1, "viewed": 67, "published": "Public", "date": "1610760478", "time_retrieved": "2021-10-01T00:00:00", "image_code": "uvec3 k = uvec3(0x456789abu, 0x6789ab45u, 0x89ab4567u);\nconst uint max32 = 0xffffffffu;\nvec2 fragCoord_;\nvec2[8] gtable2 = vec2[](   //0.92387953 = cos(pi/8), 0.38268343 = cos(pi/8)\n    vec2(0.92387953, 0.38268343),\n    vec2(0.38268343, 0.92387953),\n    vec2(-0.92387953, 0.38268343),\n    vec2(-0.38268343, 0.92387953),\n    vec2(0.92387953, -0.38268343),\n    vec2(0.38268343, -0.92387953),\n    vec2(-0.92387953, -0.38268343),\n    vec2(-0.38268343, -0.92387953)\n);\nuint hash11u(uint n) {\n    n ^= (n << 24);\n    n ^= (n >> 1);\n    n ^= (n << 1);\n    return n * k.x;\n}\nuvec2 hash22u(uvec2 n) {\n    n ^= (n.yx << 24);\n    n ^= (n.yx >> 1);\n    n *= k.xy;\n    n ^= (n.yx << 1);\n    return n * k.xy;\n}\nvec2 hash22(vec2 p) {\n        uint n = hash11u(hash11u(uint(p.x)) + uint(p.y));\n        n = n >> 29;\n        n = n % 8u;\n        return gtable2[n];\n}\nfloat pnoise21(vec2 p) {\n    vec2 f = fract(p);\n    vec2 g00 = hash22(p);\n    vec2 g01 = hash22(p + vec2(0.0, 1.0));\n    vec2 g10 = hash22(p + vec2(1.0, 0.0));\n    vec2 g11 = hash22(p + vec2(1.0, 1.0));\n    float v00 = dot(g00, f);\n    float v01 = dot(g01, f - vec2(0.0, 1.0));\n    float v10 = dot(g10, f - vec2(1.0, 0.0));\n    float v11 = dot(g11, f - vec2(1.0, 1.0));\n    f = f * f * f * (10.0 - 15.0 * f + 6.0 * f * f); \n    float v = mix(mix(v00, v10, f.x), mix(v01, v11, f.x), f.y);\n    return v;\n}\nfloat hash21(vec2 p) {\n    p = mod(p, 1000.0);\n    uint n = hash11u(uint(p.x)) + uint(p.y);\n    return float(hash11u(n)) / float(max32);\n}\nfloat vnoise21(vec2 p) {\n    vec2 i = floor(p);\n    float v00 = hash21(i);\n    float v01 = hash21(i + vec2(0.0, 1.0));\n    float v10 = hash21(i + vec2(1.0, 0.0));\n    float v11 = hash21(i + vec2(1.0, 1.0));\n    vec2 f = fract(p);\n    f = f * f * (3.0 -2.0 * f); \n    return mix(mix(v00, v10, f.x), mix(v01, v11, f.x), f.y)-0.5;\n}\nfloat fbm21(vec2 p, float H){\n    float val = 0.0;\n    float amp =1.0;\n    float freq = 1.0;\n    for (int i = 0; i < 4; i++){\n        if (fragCoord_.x < 0.5 * iResolution.x){\n            val += amp * vnoise21(freq * p);\n        } else{\n            val += amp * vnoise21(freq * p);\n        }\n        amp *= H;\n        freq *= 2.01;\n    }\n    return val;\n}\nfloat warp21(vec2 p, float G){\n    float val = 0.0;\n    for (int i = 0; i < 4; i++){\n        vec2 dir = vec2(sin(G * val), cos(G * val));\n        if (fragCoord_.y < 0.5 * iResolution.y){\n            val = fbm21(p + dir, 0.5);\n        } else{\n            val = pnoise21(p + dir);\n        }\n    }\n    return val;\n}\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n    fragCoord_ = fragCoord;\n    vec2 pos = fragCoord.xy/min(iResolution.x, iResolution.y);\n    pos *= 10.0;\n    pos += iTime;\n    float a = warp21(pos, 3.0);\n    float b = warp21(pos + 10.0, 3.0);\n    float[4] x = float[](\n        min(a, b),\n        min(a, -b),\n        min(-a, b),\n        min(-a, -b)\n    );\n    for (int i = 0; i < 4; i++){\n        if (fragCoord.x < 0.33 * iResolution.x) {\n            x[i] = step(0.0, x[i]);   //left          \n        } else if (fragCoord.x < 0.66 * iResolution.x) {\n            x[i] = smoothstep(-0.2, 0.2, x[i]); //center\n        } else {\n            x[i] = max(0., x[i]) * 2.0; //right\n        }\n    }\n    vec3 col = vec3(x[0] + x[3], x[1] + x[3], x[2]);\n    fragColor = vec4(col, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3tKcRm.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[464, 464, 486, 486, 566], [567, 567, 591, 591, 696], [697, 697, 718, 718, 846], [847, 847, 871, 871, 1350], [1351, 1351, 1373, 1373, 1489], [1490, 1490, 1514, 1514, 1819], [1820, 1820, 1849, 1849, 2174], [2175, 2175, 2205, 2205, 2487], [2488, 2488, 2542, 2542, 3271]]}
{"id": "3tKcW3", "name": "Genuary2021 - 19 Rand in y-axis", "author": "qw", "description": "Entry for Day 19 of #Genuary2021 - see https://genuary2021.github.io/\nPrompt of the day: randomness over y-axis\nlooks kinda funky", "tags": ["random", "genuary2021", "genuary", "yaxis"], "likes": 0, "viewed": 44, "published": "Public", "date": "1612132163", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI2 6.28\n\nfloat sdSegment( in vec2 p, in vec2 a, in vec2 b )\n{\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\n\nfloat DrawShape(vec2 uv, float offset){\n\n   float freq = 5. * pow(uv.y,2.);\n   float mag = 0.25;\n   float noise = (sin(((-iTime*4.* (uv.y))+(uv.y*(abs(uv.x))*5.))+offset+(PI2 * (uv.y /2.) * freq) )) * mag;\n   noise *= pow(  smoothstep( 0.,1.0, (uv.y/uv.y ))    ,2.);\n   noise *= smoothstep(.02,1., uv.y);\n   \n  \n  \n   float d = sdSegment(uv, vec2(.5 + noise,0.), vec2(.5 + noise,1.));\n   return 1.-step(.02,d);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = ( fragCoord -.5*iResolution.xy ) /iResolution.y;\n    uv.x += 0.5; \n    uv.y += 0.5;\n    float mask = uv.x < 0. ? 0. : (uv.x > 1. ? 0. : 1.);\n    \n    vec3 col1 = vec3(0.074, 0.133, 0.149);\n    vec3 col2 = vec3(0.321, 0.356, 0.337);\n    vec3 col3 = vec3(0.192, 0.250, 0.270);\n    vec3 col4 = vec3(0.643, 0.592, 0.556);\n    vec3 col5 = vec3(0.811, 0.701, 0.627);\n    vec3 col6 = vec3(0.470, 0.423, 0.392);\n\n    vec3 col = vec3(0.015, 0.047, 0.054); //Background \n    col = mix(col, col1, DrawShape( uv- vec2(.1,0), 0.) );\n    col = mix(col, col4,DrawShape( uv- vec2(.1,0), 3.0));\n    col = mix(col, col2, DrawShape( uv- vec2(.2,0), 6.0));\n    col = mix(col, col3, DrawShape( uv- vec2(-.2,0), 8.0));\n    col = mix(col, col5, DrawShape( uv- vec2(-.1,0), -1.0));\n    col = mix(col, col6, DrawShape( uv- vec2(-.2,0), -8.0));\n    \n    float fade = 1.-smoothstep(.8,1.,uv.y);\n    col*= fade;\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3tKcW3.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[18, 18, 70, 70, 189], [191, 191, 230, 230, 603], [606, 606, 663, 663, 1623]]}
{"id": "3tKyW1", "name": "Frosty feathers", "author": "jarble", "description": "A simple fractal formula.", "tags": ["fractal", "feather", "frost"], "likes": 2, "viewed": 165, "published": "Public API", "date": "1610928864", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.0);\n    vec3 col;\n    float t;\n    \n    for(int c=0;c<3;c++){\n\t    \n        vec2 uv = (fragCoord*10.0-iResolution.xy)/iResolution.y/10.0;\n        uv += vec2(iTime/2.0,iTime/3.0)/4.0;\n        t = iTime+float(c)/10.;\n        float scale = 5.1;\n        float scale1 = 1.5;\n        for(int i=0;i<15;i++)\n        {\n            uv = fract(uv/scale1/scale)*scale1*scale;\n            uv += fract(uv/25.0);\n            uv=fract(uv/(2.1+abs((uv.x-uv.y)/8.0))-(uv.yx/(2.0+(fract(uv.x+uv.y))))/scale)*scale/1.5+scale1*scale;\n            uv /= scale1;\n        \tuv=uv.yx+col.xy;\n        }\n     col[c] = ((uv.x)-(uv.y));\n\t}\n    \n    fragColor = vec4(vec3(col),1.0);\n    \n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3tKyW1.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 1, 58, 58, 739]]}
{"id": "3tKyzt", "name": "Surface nets ", "author": "kastorp", "description": "proof of concept... very slow because mesh is not precalculated is it would be in a real scenario.\n\n\n", "tags": ["voxel", "mesh", "tesselate", "surfacenets"], "likes": 20, "viewed": 354, "published": "Public", "date": "1611619007", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//--------------------------------------------------------------------------------------\n// SURFACE NETS  by Kastorp\n//            proof of concept for the popular tesselation algorithm, which is an alternative to Marching cubes\n//            inspired by these articles: \n//            https://bonsairobo.medium.com/smooth-voxel-mapping-a-technical-deep-dive-on-real-time-surface-nets-and-texturing-ef06d0f8ca14\n//            https://0fps.net/2012/07/12/smooth-voxel-terrain-part-2/\n//--------------------------------------------------------------------------------------\n\n\nconst float TK=.1; //edge thickness \nconst float csz = .5 ;//+ 0.1 * sin(iTime); // Cell size\nconst bool snet=true; //true=smoothed, false=cubes\n bool cover=true;\n\n struct GRIDCELL{     //calculated for each cube in the following sequence:\n   vec3 p[8];         //  1. cube vertex positions\n   float val[8];      //  2. isosurface value at each cube vertex\n   float nVertex;     //  3. number of vertex where val[]>0; if 0<nVertex<8  => surface cube\n   float nEdge;       //  4. number of cube edges with crossing \n   vec3 m;            //  5. surface vertex, as an average of all crossing edge positions\n   int dirs;          //  6. 6bit bitmask of surface edges from  each cube; \n                      //  7. quads (not calculated here)   \n} ;\n\n\n\n// the shape to be tesselated\nfloat sdShape(in vec3 p) {\n    p = p/ 4.;\n    vec3 q = abs(p) - 1.35;\n    float cube = max(q.x, max(q.y, q.z));\n    float sphere = length(p) - 1.6875;\n    float cylinder1 = length(p.yz) - 0.6;\n    float cylinder2 = length(p.xz) - 0.6;\n    float cylinder3 = length(p.xy) - 0.6;\n    return max(max(cube, sphere), -min(cylinder1, min(cylinder2, cylinder3))) * 1.5;\n}\n\n\n\nconst vec3 v[8] =vec3[8]\n(\n   vec3(0,0,0), vec3(1,0,0),vec3(1,1,0),vec3(0,1,0),\n   vec3(0,0,1), vec3(1,0,1),vec3(1,1,1),vec3(0,1,1)\n);\n\nconst int  e[24] =int[24](\n   0,1,   1,2,  2,3,   3,0, \n   4,5,   5,6,  6,7,   7,4,   \n   0,4,   1,5,  2,6,   3,7);\n\nconst vec3 dir[6] =vec3[6]\n(\n   vec3(1,0,0), vec3(0,1,0),vec3(0,0,1),\n   vec3(-1,0,0), vec3(0,-1,0),vec3(0,0,-1)\n);\n\nconst ivec2 quads[12]=ivec2[12]\n( \n    ivec2(0,1),ivec2(0,2),ivec2(0,4),ivec2(0,5),\n    ivec2(1,2),ivec2(1,3),ivec2(1,5),ivec2(2,3),\n    ivec2(2,4),ivec2(3,4),ivec2(3,5),ivec2(4,5)\n);\n\nvec2 mmin(vec2 a, vec2 b) {return (a.x<b.x?a:b);}\nint gFrame=0; \n\nvec3 pc=vec3(-1000.);\n\n\nvoid  getSurface(vec3 c, inout GRIDCELL g)\n{\n\n    g.m=vec3(0.);\n    g.nVertex=0.;\n    g.nEdge=0.;\n    g.dirs=0;\n\n    //gFrame unrolling fails here...\n    for(int i=0;i<8;i++)\n    {\n\n        //1. cube vertex positions\n        vec3 vp=c+ csz* v[i];\n        g.p[i]=vp;\n\n        //  2. isosurface value at each cube vertex\n        float val =sdShape(vp);\n         g.val[i]=val;\n        \n        //3. number of vertex where val[]>0;\n        g.nVertex+= (val<=0.?1.:0.);\n\n    }\n\n     if(g.nVertex>0. && g.nVertex<8.)\n     {\n\n\n          for(int i=gFrame;i<24;i+=2)\n          {\n              //  isosurface weights at each cube edge vertexes\n              float d1 = g.val[e[i]],\n                  d2 = g.val[e[i+1]],\n                  d= d1/(d1-d2);\n\n            //  4. number of cube edges with crossing \n             if(d1*d2<0.){\n                 g.nEdge++;\n                 g.m+= g.p[e[i+1]]*d + g.p[e[i]]*(1.-d);\n                 \n                 for(int k =gFrame;k<6;k++) {\n                     \n                     //  6. 6bit bitmask of surface edges from  each cube\n                     if(dot((g.p[e[i+1]] +g.p[e[i]])/2.- c -csz/2. , dir[k] )<0. )  g.dirs=g.dirs | (1<<k); \n                     \n                 }\n             }\n          }\n         if(snet){\n            //  5. surface vertex, as an average of all crossing edge positions\n             g.m/= g.nEdge;\n             g.m = min(max(g.m,c),c+csz); //must be inside the cube\n         }\n         else g.m = c+csz/2.;\n         \n\n\n    }    \n}\n\n//--------------------------\n//SDF functions by Iq\n#define dot2(x) dot(x,x)\nfloat udTriangle( vec3 p, vec3 a, vec3 b, vec3 c )\n{\n  vec3 ba = b - a; vec3 pa = p - a;\n  vec3 cb = c - b; vec3 pb = p - b;\n  vec3 ac = a - c; vec3 pc = p - c;\n  vec3 nor = cross( ba, ac );\n\n  return sqrt(\n    (sign(dot(cross(ba,nor),pa)) +\n     sign(dot(cross(cb,nor),pb)) +\n     sign(dot(cross(ac,nor),pc))<2.0)\n     ?\n     min( min(\n     dot2(ba*clamp(dot(ba,pa)/dot2(ba),0.0,1.0)-pa),\n     dot2(cb*clamp(dot(cb,pb)/dot2(cb),0.0,1.0)-pb) ),\n     dot2(ac*clamp(dot(ac,pc)/dot2(ac),0.0,1.0)-pc) )\n     :\n     dot(nor,pa)*dot(nor,pa)/dot2(nor) );\n}\n\nfloat sdCapsule( vec3 p, vec3 a, vec3 b)\n{\n  vec3 pa = p - a, ba = b - a;\n  float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n  return length( pa - ba*h ) ;\n}\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\n//------------------\n\nGRIDCELL g;\nGRIDCELL[6] ng;\n\nvec4 mapScene(in vec3 p) {\n    \n    \n    float s0= sdShape(p);\n    if(s0>2.*csz) return vec4(s0-2.*csz, vec3(0.)); //too far from any cube, skip all logic\n    else{\n    \n        vec2 shape = vec2(100.,0.);\n         \n        vec3 c = floor(p / csz) * csz;\n        if(c!=pc)\n        {\n            //this should be precalculated in a buffer\n            getSurface(c,g);\n \n           for(int k =gFrame;k<6;k++) {\n                     \n              if((g.dirs & (1<<k))>0) {\n              \n                  //get neighbour surface vertex along each direction\n                  getSurface(c-dir[k]*csz,ng[k]);  \n                  \n                  ng[k].m=g.m +(ng[k].m-g.m)*3.; //enphasize neightbour distance so surface triangles always fills the cube\n                  \n               } \n           }\n           pc=c;\n        }\n        \n        if(g.nVertex==0.) {\n            // void cube\n            return vec4(s0, vec3(0.)); \n        }\n       else if( g.nVertex<8. ) \n       {\n          //surface cube\n          \n          for(int k =gFrame;k<6;k++) {\n              //show  surface edges      \n              if((g.dirs & (1<<k))>0) shape=mmin(shape, vec2( sdCapsule(p,g.m,ng[k].m )-csz*TK/2. ,2.));\n\n\n           } \n          if(cover){\n               for(int k =gFrame;k<12;k++) {\n                    ivec2  v=quads[k];\n                  //show  surface       \n                  if((g.dirs & (1<<v.x))>0 && (g.dirs & (1<<v.y))>0 ) shape=mmin(shape, vec2( udTriangle(p,g.m,ng[v.x].m,ng[v.y].m )-csz*TK/10. ,1.));\n\n\n               }\n           }\n           else{\n              //show surface vertex \n              shape=mmin(shape,vec2( length(p- g.m)- csz*TK ,3.)); \n\n \n           }\n\n       }\n       else if(g.nVertex>=8.) \n       {\n           // internal cube\n          shape=mmin(shape,vec2( length(p- c-csz/2.)-csz*.5 ,1.)); \n       }\n       \n       //simple coloring\n       return vec4(shape.x,shape.y>0.?shape.y==3.? vec3(0,1,1):shape.y==2.?vec3(1,1,0):sdBox(c,vec3(10.))<0.? .5+ normalize(p):vec3(.2):vec3(0.));\n        \n   }\n  \n}\n\nvec3 getNormal(in vec3 p) {\n    vec3 n=vec3(0.);\n    for(int i=gFrame;i<=2;i++){\n        vec3 e=  0.001* ((i==0)?vec3(1,0,0):(i==1)?vec3(0,1,0):vec3(0,0,1));\n        for(float j=-1.;j<=1.;j+=2.) n+= j*e* mapScene(p + j* e).x ;\n    }\n    return normalize(n);\n \n}\n\n\nvec3 rot(vec3 p,float tt)\n{\n    float c1 = cos(tt), s1 = sin(tt);\n    float c2 = c1, s2 = s1;\n    p.xz *= mat2(c1, s1, -s1, c1);\n    p.yz *= mat2(c2, s2, -s2, c2);\n    return p;\n}\nvec3 rotinv(vec3 n,float tt)\n{\n    float c1 = cos(tt), s1 = sin(tt);\n    float c2 = c1, s2 = s1;\n    n.yz *= mat2(c2, -s2, s2, c2);\n    n.xz *= mat2(c1, -s1, s1, c1);\n    return n;\n}\n\n\n\nvec4 VoxelHitPos(vec3 pos, vec3 ro, vec3 rd){\n    vec3 ri = 1.0/rd;\n\tvec3 rs = sign(rd);\n    vec3 mini = (pos-ro + 0.5*csz - csz*0.5*vec3(rs))*ri;\n    float t=  max ( mini.x, max ( mini.y, mini.z ) );\n    return vec4(t*rd+ro,t);\n}\n\n//RAY TRACING WITH VOXEL TRAVERSAL\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n\t   \n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n    \n    vec2  mouse =  iMouse.x<=0. ? vec2(0.): (iMouse.xy - 0.5 * iResolution.xy) / iResolution.y;\n    cover=(mouse.x>uv.x);\n    fragColor = vec4(0.4,0.4,0.7,1.0);\n    gFrame=min(iFrame,0);\n\n    vec3 ro = rot(vec3(0.0, 0.0, 16.0),iTime/3.);\n    vec3 rd = rot(normalize(vec3(uv, -1.0)),iTime/3.);\n\n\n    vec3 rs= sign(rd);\n    vec3 ri = 1./rd;\n\tvec3 rp=ro;  \n    vec3 mp=floor(rp/csz)*csz;\n    vec3 sd = (mp-rp + 0.5*csz + sign(rd)*0.5*csz) *ri;\n    vec3 mask=vec3(0.); \n\n    \n    for (int i = 0; i < 100; i++) {\n    \n         mask = step(sd.xyz, sd.yzx) * step(sd.xyz, sd.zxy);\n\t\tsd += mask *  rs *ri*csz;\n        mp += mask *  rs*csz;\n            \n        float d = sdShape(mp+.5*csz);\n        \n        if( d<.5*csz ){\n        \n            //SDF RAYTRACING INSIDE CUBE\n            rp = VoxelHitPos(mp,rp,rd).xyz+rd*.0001;\n            float t = 0.0;          \n            for (int iters=gFrame; iters < 40; iters++) {\n                vec3 p = rp + rd * t;\n\n                if(sdBox(p-mp-.5*csz,vec3(.5*csz))>0.) break;\n\n                vec4 d = mapScene(p);\n                if (d.x < 0.001) {\n                    vec3 n = getNormal(p);\n                    vec3 l = rot(vec3(-0.58, 0.58, 0.58),iTime/3.);\n\n                    fragColor.rgb += d.yzw;\n                    fragColor.rgb *= max(0.2, dot(n, l));\n                    \n                    return;\n                }\n\n\n                t += d.x;\n                //if(iters>38.) fragColor.rgb=vec3(1,0,0);\n            }\n            //fragColor.rgb+=abs(mask)*.2;\n        }   \n\t}\n    \n    \n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3tKyzt.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1323, 1353, 1379, 1379, 1716], [2275, 2275, 2302, 2302, 2324], [2365, 2365, 2409, 2409, 3872], [3874, 3950, 4002, 4002, 4499], [4501, 4501, 4543, 4543, 4661], [4662, 4662, 4693, 4693, 4780], [4782, 4833, 4859, 4859, 6872], [6874, 6874, 6901, 6901, 7135], [7138, 7138, 7165, 7165, 7317], [7318, 7318, 7348, 7348, 7500], [7504, 7504, 7549, 7549, 7734], [7736, 7771, 7826, 7826, 9444]]}
{"id": "3tKyzV", "name": "T-800 (Model 101)", "author": "dean_the_coder", "description": "\"I need your clothes, your boots, and your motorcycle.\"  And your GPU...\nSlow to compile on Windows, but nearly instant on my (old) Mac.  Apologies...", "tags": ["3d", "raymarching", "terminator", "movie", "cineshader"], "likes": 22, "viewed": 2698, "published": "Public API", "date": "1611418337", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// 'T-800 (Model 101)' dean_the_coder (Twitter: @deanthecoder)\n// https://www.shadertoy.com/view/3tKyzV\n//\n// I wanted to create a metal material, and found a\n// cool resource describing the physical properties\n// of metal:\n//   https://www.chaosgroup.com/blog/understanding-metalness\n//\n// What better scene to try it than the T-800 arm\n// from Terminator 2? :)\n//\n// Tricks to get the performance:\n//   - The map() function checks if the point is within\n//\t the glass.  If not in the glass, we don't bother\n//\t calculating the SDF of the arm.\n//\n// Thanks to Evvvvil, Flopine, Nusan, BigWings, Iq, Shane\n// and a bunch of others for sharing their knowledge!\n\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\n#define Z0 min(iTime, 0.)\n\nfloat open;\n\n// #define AA\t// Enable this line if your GPU can take it!\n\nvoid minH(inout vec2 a, vec2 b) {\n\tif (b.x < a.x) a = b;\n}\n\nfloat remap(float f, float in1, float in2, float out1, float out2) {\n\treturn mix(out1, out2, clamp((f - in1) / (in2 - in1), 0., 1.));\n}\n\nmat2 rot(float a) {\n\tfloat c = cos(a), s = sin(a);\n\treturn mat2(c, s, -s, c);\n}\n\nfloat sdBox(vec3 p, vec3 b) {\n\tvec3 q = abs(p) - b;\n\treturn length(max(q, 0.)) + min(max(q.x, max(q.y, q.z)), 0.);\n}\n\nfloat sdCyl(vec3 p, vec2 hr) {\n\tvec2 d = abs(vec2(length(p.xz), p.y)) - hr;\n\treturn min(max(d.x, d.y), 0.) + length(max(d, 0.));\n}\n\nfloat sdCapsule(vec3 p, float h, float r) {\n\tp.y -= clamp(p.y, 0., h);\n\treturn length(p) - r;\n}\n\nfloat sdRod(vec3 p, vec3 a, vec3 b, float r) {\n  vec3 pa = p - a, ba = b - a;\n  return length(pa - ba * clamp(dot(pa, ba) / dot(ba, ba), 0., 1.)) - r;\n}\n\nvec3 getRayDir(vec3 ro, vec3 lookAt, vec2 uv) {\n\tvec3 f = normalize(lookAt - ro),\n\t\t r = normalize(cross(vec3(0, 1, 0), f));\n\treturn normalize(f + r * uv.x + cross(f, r) * uv.y);\n}\n\nfloat sdPinkyPin(vec3 p) {\n\tp.x += .18;\n\treturn sdCapsule(p.yxz, .34, .12);\n}\n\nfloat sdPinky(vec3 p) {\n\tp.y -= .7;\n\n\tfloat d = sdCyl(p, vec2(.16));\n\tp.y += .24;\n\td = min(d, sdCyl(p, vec2(.2, .14))) - .04;\n\tp.y += .5;\n\td = min(d, sdPinkyPin(p));\n\tp.x += .12;\n\treturn min(d, max(sdCapsule(p, .3, .2), abs(p.x) - .1));\n}\n\nfloat sqHinge(vec3 p, float thk) {\n\tp.y += .2;\n\n\tvec3 tp = p;\n\ttp.x -= .12;\n\ttp.y += .1;\n\tfloat d = max(sdCapsule(tp, .38, .2), abs(tp.x) - .1);\n\tp.y += .1 + .04 * thk;\n\treturn max(min(d, sdBox(p, vec3(.2, .04 * thk, .19))), -p.y - .04);\n}\n\nfloat fingerBone(vec3 p, float l) {\n\tfloat d = min(\n\t\t\t\tsqHinge(p, 1.),\n\t\t\t\tsqHinge(p * vec3(-1, -1, 1) - vec3(0, l, 0), 1.));\n\n\tp.y += l * .5;\n\treturn min(d, sdCyl(p, vec2(.16, 1. - .8 / l)));\n}\n\nvec3 pToPinkyAttach(vec3 p, float r) {\n\tp.z += abs(r) * 5. - .7;\n\tmat2 t = rot(-r);\n\tp.xz *= t;\n\tp.xy *= t;\n\tp.yz *= rot(open * -.5);\n\n\tp.y -= .35;\n\tp.z += .25;\n\treturn p;\n}\n\nfloat sdFinger(vec3 p, float l1, float l2, float r, float r2) {\n\tp.z += abs(r) * 5. - .7;\n\tmat2 t = rot(-r);\n\tp.xz *= t;\n\tp.xy *= t;\n\n\t// Base hinge.\n\tfloat d = min(sqHinge(p, 4.), sdCyl(p + vec3(0, 2, 0), vec2(.14, 1.5)));\n\td = min(d, sdBox(p + vec3(0, .65, 0), vec3(.2, .12, .2 + step(abs(p.x), .08) * .03)));\n\n\tp.yz *= rot(open * -.5 + r2);\n\tvec3 fp, s, o = vec3(0, l1, 0);\n\n\t// Base bone.\n\td = min(d, min(sdPinkyPin(p), sdPinkyPin(p - o)));\n\t// todo - Bail ealy here?\n\td = min(d, fingerBone(p - o, l1));\n\n\t// Middle bone.\n\ts = o;\n\ts.yz += vec2(l2, 0) * rot(open);\n\tfp = p - s;\n\tfp.yz *= rot(-open);\n\td = min(d, fingerBone(fp, l2));\n\n\t// Pinky\n\tfp = p - s;\n\tfp.yz *= rot(open * -2.);\n\treturn min(d, sdPinky(fp));\n}\n\nfloat sdFingers(vec3 p) {\n\tp.x += .7 * 1.5;\n\tfloat d = sdFinger(p, .9, .85, -.1, 0.);\n\tp.x -= .7; d = min(d, sdFinger(p, 1.2, 1., -.03, 0.));\n\tp.x -= .7; d = min(d, sdFinger(p, 1.3, 1.1, .03, 0.));\n\tp.x -= .7;\n\treturn min(d, sdFinger(p, 1.2, 1.05, .1, 0.));\n}\n\nfloat pinkyPiston(vec3 p, vec3 basep, float r) {\n\tp = pToPinkyAttach(p, r);\n\n\tfloat d = step(length(vec3(0, -.2, -.2) - basep), 3.2) * .04;\n\treturn min(\n\t\tsdRod(p, vec3(0, -.03, .08), vec3(0, -.2, -.2), .05),\n\t\tsdRod(p, p - basep, vec3(0, -.2, -.2), .05 + d));\n}\n\nfloat sdPiston(vec3 p, vec3 p1, vec3 p2, float b) {\n\tp1.y -= .1;\n\tfloat l = p.y - p1.y;\n\tfloat r = .14\n\t\t\t  + .04 * step(-1.3, l) * sign(sin(p.y * 6. - 4.))\n\t\t\t  + .15 * b * smoothstep(-5., -5.1, l),\n\t\t\t  d = sdRod(p, p1, p2, r);\n\n\tp -= mix(p1, p2, .79);\n\tp.y = abs(abs(p.y) - .7) - .1;\n\treturn min(d, sdCyl(p, vec2(.16 + .15 * b, .05)));\n}\n\nfloat sdArm(vec3 p) {\n\t// Thumb.\n\tvec3 fp = p;\n\tfp.xz *= rot(-1.4);\n\tfloat d = min(sdFingers(p),\n\t\t\t\t  max(\n\t\t\t\t\t sdFinger(fp + vec3(-.5, 2.7, .05), 1.5, 1.4, .03, 1.),\n\t\t\t\t\t -fp.y - 3.5));\n\n\t// Wrist plate.\n\tfp = p;\n\tp.y += 3.5;\n\td = min(d, sdCyl(p, vec2(1, .1)));\n\n\t// Finger hydraulics.\n\tfp.x += .7 * 1.5; d = min(d, pinkyPiston(fp, p + vec3(.5, 0, .4), -.1));\n\tfp.x -= .7; d = min(d, pinkyPiston(fp, p + vec3(.2, 0, .6), -.03));\n\tfp.x -= .7; d = min(d, pinkyPiston(fp, p + vec3(-.1, 0, .5), .03));\n\tfp.x -= .7; d = min(d, pinkyPiston(fp, p + vec3(-.6, 0, .1), .1));\n\n\t// Main arm bone.\n\tfp = p;\n\tfp.y += 4.;\n\td = min(d, sdCyl(fp, vec2(.35 + step(3., fp.y) * (.1 - .02 * sign(abs(sin(fp.y * 24. + 1.6)) - .8) * step(fp.y, 3.5)), 4)));\n\n\t// Arm base.\n\td = min(min(d, length(p + vec3(0, 7.1, 1.25)) - .05),\n\t\t\tmax(abs(sdCyl(p + vec3(0, 7, .1),\n\t\t\t\t\t\t  vec2(1.1 - .01 *\n\t\t\t\t\t\t\t\t (\n\t\t\t\t\t\t\t\t\t step(abs(p.y + 7.7), .04) *\n\t\t\t\t\t\t\t\t\t step(.04, abs(p.x) - .3) -\n\t\t\t\t\t\t\t\t\t step(.04, abs(abs(p.x) - .3))\n\t\t\t\t\t\t\t\t ),\n\t\t\t\t\t\t\t   1\n\t\t\t\t\t\t\t  )\n\t\t\t\t\t\t )) - .06,\n\t\t\t\tp.y - .3 * p.z + 6.6));\n\n\t// Arm pistons.\n\td = min(d, sdPiston(p, vec3(0, 0, -.8), vec3(0, -7.5, -.7), 1.5));\n\tp.x = abs(p.x) - .7;\n\treturn min(d, sdPiston(p, vec3(0), vec3(-.1, -7.5, 0), 1.));\n}\n\nfloat sdGlass(vec3 p) {\n\treturn sdCapsule(p + vec3(0,11,0), 13.5, 3.2);\n}\n\n// Map the scene using SDF functions.\nvec2 map(vec3 p) {\n\tvec2 h = vec2(min(abs(p.y + 11.7), abs(p.z - 6.)), 1);\n\n\tif (sdGlass(p) < 0.)\n\t\tminH(h, vec2(sdArm(p - vec3(0,1.4,0)) * .8, 2));\n\n\tp.y += 10.9;\n\tminH(h, vec2(sdCyl(p, vec2(3.1, .5)) - .2, 2));\n\n\treturn h;\n}\n\nvec3 calcN(vec3 p, float t) {\n\tvec3 n = vec3(0);\n\tfor (int i = min(iFrame, 0); i < 4; i++) {\n\t\tvec3 e = .0017319 * (2. * vec3((((i + 3) >> 1) & 1), (i >> 1) & 1, i & 1) - 1.);\n\t\tn += e * map(p + e * t).x;\n\t}\n\n\treturn normalize(n);\n}\n\nvec3 glassN(vec3 p) {\n\tvec3 n = vec3(0);\n\tfor (int i = min(iFrame, 0); i < 4; i++) {\n\t\tvec3 e = .0017319 * (2. * vec3((((i + 3) >> 1) & 1), (i >> 1) & 1, i & 1) - 1.);\n\t\tn += e * sdGlass(p + e);\n\t}\n\n\treturn normalize(n);\n}\n\n// Quick ambient occlusion.\nfloat ao(vec3 p, vec3 n, float h) { return map(p + h * n).x / h; }\n\n/**********************************************************************************/\n\nvec3 vignette(vec3 c, vec2 fc) {\n\tvec2 q = fc.xy / iResolution.xy;\n\tc *= .5 + .5 * pow(16. * q.x * q.y * (1. - q.x) * (1. - q.y), .4);\n\treturn c;\n}\n\nvec3 lights(vec3 p, vec3 rd, float d, vec2 h) {\n\tvec3 ld = normalize(vec3(12, 5, -10) - p),\n\t\t n = calcN(p, d), c;\n\tfloat f, alb;\n\n\tif (h.y == 1.) {\n\t\t// Walls.\n\t\talb = max(0., .1 + .9 * dot(ld, n));\n\t\tc = vec3(.5, .7, 1);\n\t\tf = .3;\n\t} else {\n\t\t// Metal.\n\t\tc = vec3(.6);\n\t\talb = 1.;\n\t\tf = 10.;\n\t}\n\n\tfloat ao = ao(p, n, .3),\n\n\t// Primary light.\n\tl1 = alb * (.3 + .7 * ao), // ...and _some_ AO.\n\n\t// Secondary(/bounce) light.\n\tl2 = max(0., .1 + .9 * dot(ld * vec3(-1, 0, -1), n)) * .3,\n\n\t// Specular.\n\tspe = smoothstep(0., 1., pow(max(0., dot(rd, reflect(ld, n))), 3. * f)) * f,\n\n\t// Fresnel\n\tfre = 1. - smoothstep(.4, 1., 1. + dot(rd, n));\n\n\tif (h.y == 3.) // Glass\n\t\treturn vec3(spe);\n\n\t// Combine into final color.\n\tfloat lig = (l2 + spe) * ao + l1;\n\treturn fre * lig * c * vec3(2, 1.8, 1.7);\n}\n\nfloat glassCol(vec3 p, vec3 rd) {\n\tvec3 ld = normalize(vec3(12, 5, -10) - p),\n\t\t n = glassN(p);\n\treturn .01 + pow(max(0., dot(rd, reflect(ld, n))), 30.) * 3. + smoothstep(.4, 1., 1. + dot(rd, n)) * .3;\n}\n\nvec3 march(vec3 ro, vec3 rd) {\n\t// Raymarch.\n\tvec3 p = ro, col = vec3(0);\n\n\tfloat d = .01;\n\tvec2 h;\n\tbool inGlass = false, doneGlass = false;\n\tfor (float i = Z0; i < 120.; i++) {\n\t\th = map(p);\n\n\t\tfloat g = abs(sdGlass(p));\n\t\tif (!doneGlass && g < .005) {\n\t\t\tfloat c = glassCol(p, rd);\n\t\t\tif (!inGlass) {\n\t\t\t\tinGlass = true;\n\n\t\t\t\t// Add slight glass refraction.\n\t\t\t\tp += .5 * refract(rd, glassN(p), 1.0/3.);\n\t\t\t} else {\n\t\t\t\tc *= .1;\n\t\t\t\tdoneGlass = true;\n\t\t\t}\n\n\t\t\tcol += c;\n\t\t\tg += .1;\n\t\t}\n\n\t\tif (abs(h.x) < .005)\n\t\t\tbreak;\n\n\t\td += min(g, h.x); // No hit, so keep marching.\n\t\tp += rd * min(g, h.x);\n\t}\n\n\tcol += lights(p, rd, d, h) * exp(d * d * -.001);\n\n\tif (h.y == 1.)\n\t\treturn col; // Hit wall - No reflection needed.\n\n\t// We hit metal, so march along a reflection ray.\n\trd = reflect(rd, calcN(p, d)); ro = p; d = .01;\n\tfor (float i = Z0; i < 40.; i++) {\n\t\tp = ro + rd * d;\n\t\th = map(p);\n\n\t\tif (abs(h.x) < .005)\n\t\t\tbreak;\n\n\t\td += h.x;\n\t}\n\n\treturn abs(h.x) < .005 ?\n\t\tmix(col, .6 * lights(p, rd, d, h), .9) :\n\t\tmix(col, vec3(1), .5);\n}\n\nvoid mainImage(out vec4 fragColor, vec2 fc)\n{\n\topen = .4;\n\n\tfloat T = mod(iTime * 2.5, 36.),\n\t\t  dim = 1. - pow(abs(cos(clamp(min(T, abs(T - 12.)), -1., 1.) * 1.57)), 10.);\n\n\tvec3 ro, lookAt;\n\tif (T < 12.) {\n\t\tfloat p = remap(T, 0., 12., 0., 1.);\n\t\tro = mix(vec3(-6, -6, -23), vec3(6, 2, -15), p);\n\t\tlookAt = mix(vec3(0, -5, 0), vec3(0, -2, 0), p);\n\t} else if (T < 24.) {\n\t\tfloat p = remap(T, 12., 24., 0., 1.);\n\t\tro = mix(vec3(2, -10, -9), vec3(-2, -4, -9), p);\n\t\tlookAt = mix(vec3(0, -10, 0), vec3(0), p);\n\t} else if (T < 36.) {\n\t\tfloat p = remap(T, 24., 36., 0., 1.);\n\t\tro = mix(vec3(3, 0, -12), vec3(-3, 0, -15), p);\n\t\tlookAt = vec3(0, -1, 0);\n\t\topen = .35 * sin(p * 11.) + .7462;\n\t}\n\n#ifdef AA\n\tvec3 col = vec3(0);\n\tfor (float dx = Z0; dx <= 1.; dx++) {\n\t\tfor (float dy = Z0; dy <= 1.; dy++) {\n\t\t\tvec2 uv = (fc + vec2(dx, dy) * .5 - .5 * iResolution.xy) / iResolution.y;\n\t\t\tcol += march(ro, getRayDir(ro, lookAt, uv));\n\t\t}\n\t}\n\tcol /= 4.;\n#else\n\tvec2 uv = (fc - .5 * iResolution.xy) / iResolution.y;\n\tvec3 col = march(ro, getRayDir(ro, lookAt, uv));\n#endif\n\n\t// Output to screen.\n\tfragColor = vec4(vignette(pow(col * dim, vec3(.45)), fc), 0);\n}\n", "image_inputs": [{"id": "lllSR4", "previewfilepath": "https://soundcloud.com/randyheavenridgemusic/terminator-theme", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0, "src": "https://soundcloud.com/randyheavenridgemusic/terminator-theme", "ctype": "musicstream"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3tKyzV.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[789, 849, 882, 882, 907], [909, 909, 977, 977, 1044], [1046, 1046, 1065, 1065, 1125], [1127, 1127, 1156, 1156, 1243], [1245, 1245, 1275, 1275, 1375], [1377, 1377, 1420, 1420, 1472], [1474, 1474, 1520, 1520, 1626], [1628, 1628, 1675, 1675, 1808], [1810, 1810, 1836, 1836, 1887], [1889, 1889, 1912, 1912, 2127], [2129, 2129, 2163, 2163, 2368], [2370, 2370, 2405, 2405, 2565], [2567, 2567, 2605, 2605, 2740], [2742, 2742, 2805, 2805, 3459], [3461, 3461, 3486, 3486, 3720], [3722, 3722, 3770, 3770, 3984], [3986, 3986, 4037, 4037, 4326], [4328, 4328, 4349, 4360, 5575], [5577, 5577, 5600, 5600, 5650], [5652, 5690, 5708, 5708, 5916], [5918, 5918, 5947, 5947, 6150], [6152, 6152, 6173, 6173, 6374], [6376, 6404, 6439, 6439, 6470], [6472, 6558, 6590, 6590, 6705], [6707, 6707, 6754, 6754, 7502], [7504, 7504, 7537, 7537, 7707], [7709, 7709, 7739, 7753, 8744], [8746, 8746, 8791, 8791, 9894]]}
{"id": "3tKyzw", "name": "julia-4d", "author": "zbendefy", "description": "A 4D fractal represented as 2D slices", "tags": ["fractal", "julia", "mandelbrot", "4d"], "likes": 4, "viewed": 73, "published": "Public", "date": "1610695635", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n#define ITERATIONS 40\n\nfloat GetMandelbrot(vec2 pos, float zoom, vec2 offset)\n{\n    vec2 C = offset + pos*zoom;                \n    vec2 Zn=vec2(0.0, 0.0);\n\n    for( int i = 0; i < ITERATIONS; ++i)\n    {\n        float x2 = Zn.x * Zn.x;\n        float y2 = Zn.y * Zn.y;\n        if (x2 + y2 > 4.0)\n        { \n            return float(i+1) / float(ITERATIONS+1);\n        } \n\n        Zn.y = (Zn.y * Zn.x * 2.0) + C.y; \n        Zn.x = (x2 - y2) + C.x; \n    }\n    return 0.0;\n}\n\nfloat GetJulia(vec2 pos, float zoom, vec2 offset, vec2 juliaPos)\n{\n    vec2 C = juliaPos;                \n    vec2 Zn=offset + pos*zoom;\n\n    for( int i = 0; i < ITERATIONS; ++i)\n    {\n        float x2 = Zn.x * Zn.x;\n        float y2 = Zn.y * Zn.y;\n        if (x2 + y2 > 4.0)\n        { \n            return float(i+1) / float(ITERATIONS+1);\n        } \n\n        Zn.y = (Zn.y * Zn.x * 2.0) + C.y; \n        Zn.x = (x2 - y2) + C.x; \n    }\n    return 0.0;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    float zoom = 1.0;\n    float u_insightsize = sin(iTime * 0.25) * 0.1 + 0.1;\n    float insightDiscSize = 1000.0;\n    int fractalMode = 0;\n    vec2 offset = vec2(-0.3, 0.0);\n    vec2 juliapos = vec2(0.0, 0.0);\n    vec2 mousePos= vec2(0.0, 0.0);\n\n    float aspectRatio = iResolution.x / iResolution.y;\n    vec2 position = - 1.0 + 2.0 * fragCoord.xy / iResolution.xy;\n    position.x *= aspectRatio;\n\n    \n    float scale = GetMandelbrot(position, zoom, offset);\n    if ( scale == 0.0)\n        fragColor = vec4( 0.0, 0.0, 0.0, 1.0 );\n    else\n        fragColor = vec4( 0.6, 0.8, 1.0, 0.0 ) * scale + vec4(0.0, 0.2, 0.4, 1.0);\n\n    if ( u_insightsize > 0.001 )\n    {\n        float insightsize=u_insightsize*zoom;\n\n\n        vec2 Zn=offset + vec2(position.x, position.y)*zoom;\n        vec2 centerpos = floor(Zn/insightsize)*insightsize + vec2(insightsize*0.5, insightsize*0.5);\n        vec2 samplepos = mod(Zn, insightsize);\n        float scale = GetJulia(samplepos/(insightsize*0.5)-1.0, 1.4, vec2(0.0,0.0), centerpos);\n        //vec4 color = vec4(samplepos.x*20.0-1.0,samplepos.y*20.0-1.0,0.0,1.0);\n        vec4 color = vec4(1.0,0.0,0.0,1.0);\n        if ( scale == 0.0)\n            color = vec4( 0.0, 0.0, 0.0, 1.0 );\n        else\n            color = vec4( 0.6, 0.8, 1.0, 0.0 ) * scale + vec4(0.0, 0.2, 0.4, 1.0);\n\n        fragColor = mix(fragColor, color, clamp(u_insightsize/0.015, 0.0, 1.0));\n    }\n    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3tKyzw.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[24, 24, 80, 80, 471], [473, 473, 539, 539, 924], [926, 926, 983, 983, 2389]]}
{"id": "3tKyzz", "name": "shader_practice_2", "author": "changwenhan", "description": "Making by following this tutorial of The Art of Code:\nhttps://www.youtube.com/watch?v=KGJUl8Teipk", "tags": ["gif"], "likes": 3, "viewed": 149, "published": "Public", "date": "1610360285", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float rand(vec2 p) {\n    p = fract(p * vec2(321.456, 876.789));\n    p += dot(p, p+32.56);\n    return fract(p.x*p.y);\n}\n\nvec2 rand2(vec2 p) {\n    float n = rand(p);\n    return vec2(n, rand(p+n));\n}\n\nvec2 pointPos(vec2 id) {\n    vec2 circleCenter;\n    vec2 r = rand2(id);\n    circleCenter.x = sin((iTime+123.123)*r.x);\n    circleCenter.y = cos((iTime+123.123)*r.y);\n    circleCenter *= 0.4;\n    return circleCenter;\n}\n\n\nfloat distToLine(vec2 p ,vec2 a, vec2 b) {\n    vec2 pa = p-a;\n    vec2 ba = b-a;\n    float t = clamp(dot(pa,ba)/dot(ba,ba), 0., 1.);\n    return length(pa-ba*t);\n}\n\nfloat drawLine(vec2 p ,vec2 a, vec2 b) {\n    float dist = distToLine(p, a, b);\n    float w = 1. - step(0.01, dist);\n    w *= smoothstep(1.2, 0.8, length(a-b));\n    return w;\n}\n\n\nvec3 layer(vec2 uv) {\n    vec2 gv = fract(uv) - 0.5;\n    vec2 id = floor(uv);\n    \n    vec3 pixelColor = vec3(0.0);\n    \n    float gridLine = step(0.48, gv.x) + step(0.48, gv.y);\n    \n    vec2 circleCenter = pointPos(id);\n         \n    float circle = (1. - step(.03, length(circleCenter-gv)));\n    pixelColor += circle;\n    \n    \n    float line = 0.;\n    vec2 centerPoints[9];\n    for(int i=-1;i<2;i++) {\n        for(int j=-1;j<2;j++) {\n            vec2 offs = vec2(j,i);\n            vec2 nowId = id+offs;\n            \n            vec2 nowCircleCenter = pointPos(nowId) + offs;\n            centerPoints[(i+1)*3 + (j+1)] = nowCircleCenter;\n            line += drawLine(gv, centerPoints[(i+1)*3 + (j+1)], circleCenter);\n        }\n    }\n    line += drawLine(gv, centerPoints[1], centerPoints[3]);\n    line += drawLine(gv, centerPoints[1], centerPoints[5]);\n    line += drawLine(gv, centerPoints[7], centerPoints[3]);\n    line += drawLine(gv, centerPoints[7], centerPoints[5]);\n    \n    pixelColor += line;\n    \n    // pixelColor += gridLine*0.1;\n    \n    pixelColor = vec3(min(1., pixelColor.x));\n    \n    return pixelColor;\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // -1~1\n    vec2 uv = (fragCoord.xy-0.5*iResolution.xy)/iResolution.y;\n    vec2 c_uv = uv;\n    \n    //vec2 mouse = iMouse.xy/iResolution.xy - .5;\n    //uv+=mouse*.5;\n    \n    // rotate\n    float radian = fract(iTime*.03) * 3.1415926 * 2.;\n    float s = sin(radian);\n    float c = cos(radian);\n    mat2 rotate = mat2(c, -s, s, c);\n    uv *= rotate;\n    \n    vec3 pixelColor;\n    \n    // draw each layer with zoom and opacity\n    for(int i=0;i<4;i++) {\n        float move = 10. - fract(iTime*.2+float(i)/4.) * 10.; // 10~0;\n        float opacity = smoothstep(10., 8. , move) * smoothstep(0., 2. , move);\n        float color = move/10.;\n        pixelColor += layer(uv*move*2.+float(i)*20.2) * opacity ;\n    }\n    \n    // add color\n    float r = sin(iTime)*.3 + .7;\n    pixelColor += vec3(.1);\n    pixelColor *= vec3(r, uv.x+.5, uv.y+.5);\n    \n    \n    // Output to screen\n    fragColor = vec4(pixelColor, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3tKyzz.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 20, 20, 118], [120, 120, 140, 140, 196], [198, 198, 222, 222, 415], [418, 418, 460, 460, 580], [582, 582, 622, 622, 757], [760, 760, 781, 781, 1883], [1887, 1887, 1944, 1956, 2858]]}
{"id": "3ttcWl", "name": "shader reflection", "author": "regis", "description": "reflection,noise,water", "tags": ["noise", "reflection", "water"], "likes": 0, "viewed": 62, "published": "Public", "date": "1610305550", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec4 tpos = vec4(0.0, 0.0, 0.0, 0.0);\nfloat angle_tpos;\nbool done = false;\nfloat dist = 0.0;\n\nmat2 Rot(float a){float s = sin(a);float c = cos(a);return mat2(c, -s, s, c);}\nmat3 RotX(float a){float s = sin(a);float c = cos(a);return mat3(1., .0, .0, .0, c, -s, .0, s, c);}\nmat3 RotY(float a){float s = sin(a);float c = cos(a);return mat3(c, .0, s, .0, 1., .0, -s, .0, c);}\nmat3 RotZ(float a){float s = sin(a);float c = cos(a);return mat3(c, -s, .0, s, c, .0, .0, .0, 1.);}\n\n\nfloat opExtrusion(in vec3 p, in float d, in float h) {\n    // d is the distance to the 2D shape using the x and y components of p\n    vec2 w = vec2(d, abs(p.z) - h);\n    return min(max(w.x, w.y), 0.0) + length(max(w, 0.0));\n}\n\n\nvec4 opElongate( in vec3 p, in vec3 h )\n{\n    //return vec4( p-clamp(p,-h,h), 0.0 ); // faster, but produces zero in the interior elongated box\n    \n    vec3 q = abs(p)-h;\n    return vec4( max(q,0.0), min(max(q.x,max(q.y,q.z)),0.0) );\n}\n\n\nvec3 opTwist(in vec3 p, in float t) {\n    float c = cos(t * p.y);\n    float s = sin(t * p.y);\n    mat2 m = mat2(c, -s, s, c);\n    return vec3(m * p.xz, p.y);\n}\n\n// from iq\nfloat Noise( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n  \tf = f*f*(3.0-2.0*f);\n  \tvec2 uv = (p.xy+vec2(37.0,17.0)*p.z) + f.xy;\n  \tvec2 rg = textureLod( iChannel0, (uv+0.5)/256.0, 0.0).yx;\n  \treturn mix( rg.x, rg.y, f.z );\n}\n\n// ref https://www.shadertoy.com/view/Xs33Df\nfloat Noise3D(in vec3 p){\n    const vec3 s = vec3(7, 157, 113);\n\tvec3 ip = floor(p); // Unique unit cell ID.\n    vec4 h = vec4(0., s.yz, s.y + s.z) + dot(ip, s);\n\tp -= ip; // Cell's fractional component.\n    p = p*p*(3. - 2.*p);\n    h = mix(fract(sin(h)*43758.5453), fract(sin(h + s.x)*43758.5453), p.x);\n    h.xy = mix(h.xz, h.yw, p.y);\n    return mix(h.x, h.y, p.z); // Range: [0, 1].\n\t\n}\n\nvec2 hash( vec2 p )\n{\n\tp = vec2( dot(p,vec2(127.1,311.7)),\n\t\t\t dot(p,vec2(269.5,183.3)) );\n\treturn -1.0 + 2.0*fract(sin(p)*43758.5453123);\n}\n\nfloat noise( in vec2 p )\n{\n\tconst float K1 = 0.366025404; // (sqrt(3)-1)/2;\n\tconst float K2 = 0.211324865; // (3-sqrt(3))/6;\n\t\n\tvec2 i = floor( p + (p.x+p.y)*K1 );\n\t\n\tvec2 a = p - i + (i.x+i.y)*K2;\n\tvec2 o = (a.x>a.y) ? vec2(1.0,0.0) : vec2(0.0,1.0);\n\tvec2 b = a - o + K2;\n\tvec2 c = a - 1.0 + 2.0*K2;\n\t\n\tvec3 h = max( 0.5-vec3(dot(a,a), dot(b,b), dot(c,c) ), 0.0 );\n\t\n\tvec3 n = h*h*h*h*vec3( dot(a,hash(i+0.0)), dot(b,hash(i+o)), dot(c,hash(i+1.0)));\n\t\n\treturn dot( n, vec3(70.0) );\n}\n\n\n\nfloat sdCylinder(vec3 p, vec3 a, vec3 b, float r) {\n\tvec3 ab = b-a;\n    vec3 ap = p-a;\n    \n    float t = dot(ab, ap) / dot(ab, ab);\n    //t = clamp(t, 0., 1.);\n    \n    vec3 c = a + t*ab;\n    \n    float x = length(p-c)-r;\n    float y = (abs(t-.5)-.5)*length(ab);\n    float e = length(max(vec2(x, y), 0.));\n    float i = min(max(x, y), 0.)-0.1;\n    \n    return e+i;\n}\n\nfloat sdRoundBox( vec3 p, vec3 b, float r )\n{\n  vec3 q = abs(p) - b;\n  return -(length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0) - r);\n}\n\nfloat Box(vec3 p, vec3 sc, float r){\n    return length(max(abs(p)-sc, 0.))-r;\n}\n\nfloat Box2(vec3 p, vec3 sc, float r, float an){\n    an = 80.0;\n    vec3 cs = vec3(cos(an*3.1415/180.0), sin(an*3.1415/180.0),cos(an*3.1415/180.0));\n    float c2 = length(cs);\n    \n    float a = length(max( abs(p)-(sc)  , 0.0)) - r;\n    float b = length(max(abs(p)-vec3(1.0, 2.0, 1.0), 0.));\n    return a;\n}\n\nfloat Capsule(vec3 p, vec3 sc, float r){\n    vec3 cs = vec3(cos(90.0*3.1415/180.0), sin(90.0*3.1415/180.0),cos(90.0*3.1415/180.0));  \n    float a = length(max( abs(p)- (sc*cs)  , 0.0)) - r;\n    return a;\n}\n\nfloat opRep( in vec3 p, in vec3 c, vec3 sc, float r )\n{\n    vec3 q = mod(p+0.5*c,c)-0.5*c;\n    return Box( q, sc, r );\n}\n\nfloat opRepS( in vec3 p, in vec3 c, vec4 pos )\n{\n    vec3 q = mod(p+0.5*c,c)-0.5*c;\n    return length(q) - pos.w;\n}\n\nfloat Plane(vec3 p, vec3 n, float h){\n\n    return dot(p, n) + h;\n}\n\nvec3 add_tpos(vec3 tp){\n    return vec3(tp.x+tpos.x, tp.y+tpos.y, tp.z+tpos.z);\n    \n}\n\nvec3 rot_y(vec3 tp, float a){\n    tp.xz *= Rot(a);\n    return tp;\n\n}\n\nfloat noi(vec3 p){ \n  vec3 f=floor(p),s=vec3(7,157,113);\n  p-=f; vec4 h=vec4(0,s.yz,s.y+s.z)+dot(f,s);;\n  p=p*p*(3.-2.*p);\n  h=mix(fract(sin(h)*43758.5),fract(sin(h+s.x)*43758.5),p.x);\n  h.xy=mix(h.xz,h.yw,p.y);\n  return mix(h.x,h.y,p.z);  \n}\n\n\nvec2 GetDist(vec3 p, vec2 uv){\n\n\n    vec4 s = vec4(0.0,3.0, 5.0,1.0);\n    vec4 s2 = vec4(3.0 ,3.0, 5.0, 1.0);\n    \n    \n    \n    \n    vec2 d=vec2(0.0);;\n    float pd = dot(p, vec3(0.0, 1.0, 0.0));\n    \n     \n     \n    pd = p.y;\n   \n    //s.z += iTime;\n    //s.y += mod(iTime, 3.0);\n    vec3 sp = (p)-s.xyz;\n    \n    float sd = length((sp))-s.w;\n       \n       \n    \n    vec3 sp2 = (p)-s2.xyz;\n    //sp2.y += sin(iTime)*0.1;\n    float sd2 = length((sp2))-s2.w;\n    \n    \n    float object[50];\n    float objectm[50];\n    const int max_object = 6;\n    int I = 5;\n    \n    vec3 bp = p - vec3(-6.0, 5.0, 6.0);\n    object[0] = opRep(bp, vec3(0.0, 0.0, 10.0), vec3(1.0, 5.0, 1.0), 0.2);\n    objectm[0] = 3.0;\n    \n    bp = p - vec3(6.0, 5.0, 6.0);\n    object[1] = opRep(bp,  vec3(0.0, 0.0, 10.0), vec3(1.0, 5.0, 1.0), 0.2);\n    objectm[1] = 3.0;\n    \n    bp = p - vec3(0.0, 0.0, 6.0);\n    object[2] = opRep(bp,  vec3(0.0, 0.0, 10.0), vec3(5.0, 1.0, 5.0), 0.2);\n    objectm[2] = 3.0;\n    \n    bp = p - vec3(0.0, 10.0, 6.0);\n    object[3] = opRep(bp,  vec3(0.0, 0.0, 10.0), vec3(5.0, 1.0, 5.0), 0.2);\n    objectm[3] = 3.0;\n    \n    bp = p - vec3(-3.0, 0.0, 6.0);\n    object[4] = Plane(bp,  vec3(1.0, 0.0, 0.0), 2.0);\n    objectm[4] = 4.0;\n    \n    bp = p - vec3(30.0, 0.0, 6.0);\n    object[5] = Plane(bp,  vec3(0.0, 1.0, 0.0), 5.0);\n    objectm[5] = 5.0;\n    \n    object[5] += Noise3D(p*0.7)*0.5 - sin(p.x+iTime*2.0)*0.2-cos(p.z+iTime*2.0)*0.1+sin(p.y*3.0+iTime)*0.1;;\n  \n          \n      if(sd < sd2){\n          d.x = sd;\n          d.y = -1.0;\n       }\n       else\n       {\n           d.x = sd2;\n          d.y = -1.0;\n       }\n       \n              \n       for(int i = 0;i < max_object;i++){\n           if(object[i] < d.x){\n              d.x = object[i];\n              d.y = objectm[i];\n           }\n       \n       }\n           \n     \n    return d;\n    \n    \n}\n\nvec3 RayMarch2(vec3 eye, vec3 viewRayDirection, vec2 uv){\n    vec3 t = vec3(0.);\n    float max = -100000.0;\n    vec2 dd;\n    float depth = 0.0, end = 10.0;\n    for (int i = 0; i < 100; i++) {\n        t.yz = GetDist(eye + t.x * viewRayDirection, uv).xy;\n        \n                    \n        if (abs(t.y) < 0.01)break;\n                \n        t.x += t.y;\n        \n        if (t.x >= 100.0)break;\n        \n    }\n    if (t.x >= 100.0)t.x = -1.0;\n    \n    return t;\n\n\n}\n\n\nvec3 GetLightM(vec3 p, vec2 uv, vec3 lg, out vec3 n, vec3 ro, vec3 rd){\n    vec3 lightpos = lg;\n    //lightpos.xz += vec2(sin(iTime), cos(iTime));\n    vec3 l = normalize(lightpos-p);\n    \n    vec2 d = GetDist(p, uv);\n    vec2 e = vec2(0.01, 0);\n    \n    \n    \n    \n    n = d.x - vec3(\n        GetDist(p-e.xyy, uv).x,\n        GetDist(p-e.yxy, uv).x,\n        GetDist(p-e.yyx, uv).x);\n\n\n    n = normalize(n);\n        \n    \n   \n            \n    float dif = clamp(dot(n, l), .0, 1.);\n    \n \n    vec3 dd = RayMarch2(p+n*.01, l, uv);\n    p = ro + reflect(n, l) * dd.x;\n    \n        \n     \n    if((dd.x < length(lightpos-p)) && (dd.x > 0.0)){\n        if(dd.z == -1.0){\n            vec3 colXZ = texture(iChannel0, p.xz*0.1).rgb;\n             vec3 colYZ = texture(iChannel0, p.yz*0.1).rgb;\n             vec3 colXY = texture(iChannel0, p.xy*0.1).rgb;\n\n             n = abs(n);\n\n             n *= pow(n, vec3(20));\n             n /= n.x+n.y+n.z;\n\n             vec3 col = colYZ * n.x + colXZ * n.y + colXY*n.z;\n\n             uv = vec2(atan(p.x, p.z)/6.2832+.5, p.y/3.+0.5);\n             vec4 st = texture(iChannel0, uv);\n\n             col = vec3(dif) * mix(col, st.rgb, st.a);\n             return col;\n\n        }\n        else if(dd.z == 2.0)\n        {\n            vec3 col = vec3(length(uv))*texture(iChannel2, vec2(noise(uv+iTime*10.0))).rgb;\n            \n            return col;\n        }\n        else if(dd.z == 3.0)\n        {\n            float NdotL = max( 0., dot( n, lightpos-p ) );\n             float SpecularColor = 0.5;\n            SpecularColor = SpecularColor + ( 1. - SpecularColor ) * pow( ( 1. - NdotL ), 5. );\n             \n            \n             vec3 col = mix(vec3(dif) * vec3(0.5, 0.5, 0.5)+SpecularColor*0.001, \n                       vec3(0., 0.5, 5.0)*vec3(dif)+vec3(0.2,0.5, 0.5)+SpecularColor*0.001, 0.7 );\n             col += normalize(vec3(0.1, 0.1, 0.1));\n             col -= vec3(.1);\n             return col;\n         \n        }\n        else if(dd.z == 4.0){\n             return texture(iChannel0, vec2(noise(uv+iTime*0.01))).rgb * vec3(dif);\n            \n         }\n         else if(dd.z == 5.0){\n             //return vec3(1.0, 0.0, 1.0) * vec3(dif);\n             \n             float NdotL = max( 0., dot( n, lightpos-p ) );\n             float SpecularColor = 0.5;\n            SpecularColor = SpecularColor + ( 1. - SpecularColor ) * pow( ( 1. - NdotL ),2. );\n             \n             vec3 col = vec3(0.0, 1.0, 1.0) + SpecularColor*0.0001;\n             col = mix(col, vec3(dif) * vec3(0.0, 1.0, 1.0), smoothstep(0., 1.0, vec3(dif)));\n             return col;\n             \n             \n         }\n        else\n            return vec3(dif);\n            \n     }\n     else\n         return vec3(dif);\n\n}\nvec3 lightDir = normalize( vec3(0.5,0.6,0.) );\nconst mat2 m2 = mat2( 0.60, -0.80, 0.80, 0.60 );\n//ref: https://www.shadertoy.com/view/Msdfz8\nvec3 Cloud(vec3 bgCol,vec3 ro,vec3 rd,vec3 cloudCol,float spd)\n{\n    vec3 col = bgCol;\n    float t = iTime * 0.15* spd;\n    vec2 sc = ro.xz + rd.xz*((3.)*40000.0-ro.y)/rd.y;\n    vec2 p = 0.00002*sc;\n    float f = 0.0;\n  \tfloat s = 0.5;\n  \tfloat sum =0.;\n  \tfor(int i=0;i<5;i++){\n    \tp += t;t *=1.5;\n    \tf += s*textureLod( iChannel0, p/256.0, 0.0).x; p = m2*p*2.02;\n    \tsum+= s;s*=0.6;\n  \t}\n    float val = f/sum; \n    col = mix( col, cloudCol, smoothstep(0.5,0.8,val) );\n    return col;\n}\nvec3 RayMarchCloud(vec3 ro,vec3 rd){\n    vec3 col = vec3(0.0,0.0,0.0);  \n    float sundot = clamp(dot(rd,lightDir),0.0,1.0);\n    \n     // sky      \n    col = vec3(0.2,0.5,0.85)*1.1 - rd.y*rd.y*0.5;\n    col = mix( col, 0.85*vec3(0.7,0.75,0.85), pow( 1.0-max(rd.y,0.0), 4.0 ) );\n    // sun\n    col += 0.25*vec3(1.0,0.7,0.4)*pow( sundot,5.0 );\n    col += 0.25*vec3(1.0,0.8,0.6)*pow( sundot,64.0 );\n    col += 0.4*vec3(1.0,0.8,0.6)*pow( sundot,512.0 );\n    // clouds\n    col = Cloud(col,ro,rd,vec3(1.0,0.95,1.0),1.);\n            // .\n    col = mix( col, 1.5*vec3(0.0,0.5,1.0), pow( 1.0-max(rd.y,0.0), 16.0 ) );\n    return col;\n}\n\n#define TAU 6.28318530718\n#define MAX_ITER 4\nvec3 XaterColor(vec3 pp){\nvec2 p = mod(pp.xz*TAU, TAU)-250.0;\n\n\tvec2 i = vec2(p);\n\tfloat c = 1.0;\n\tfloat inten = .005;\n\n\tfor (int n = 0; n < MAX_ITER; n++) \n\t{\n\t\tfloat t = iTime * (1.0 - (3.5 / float(n+1)));\n\t\ti = p + vec2(cos(t - i.x) + sin(t + i.y), sin(t - i.y) + cos(t + i.x));\n\t\tc += 1.0/length(vec2(p.x / (sin(i.x+t)/inten),p.y / (cos(i.y+t)/inten)));\n\t}\n\tc /= float(MAX_ITER);\n\tc = 1.17-pow(c, 1.4);\n\tvec3 colour = vec3(pow(abs(c), 8.0));\n    colour = clamp(colour + vec3(0.0, 0.35, 0.5), 0.0, 1.0);\n    \n\t\treturn colour;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    uv -= 0.5;\n    uv /= vec2(iResolution.y / iResolution.x, 1);\n    // Time varying pixel color\n    vec3 col = vec3(0.0);\n    vec3 lightpos = vec3(0.0, 6., 0.);\n    \n    //iMouse.xy / iResolution.xy\n    vec3 lookat = vec3((iMouse.x/iResolution.x)*100.0, (iMouse.y/iResolution.y)*100.0, 30.0);//vec3(0.0, 1.5, 0.0);\n    vec3 ro = vec3(0, 7.0, -4.);\n    ro.z += iTime;//mod(iTime, 20.0)-4.;\n    lightpos.z += iTime;\n    lookat.z += iTime;\n    /*if(ro.z > 3.0){\n        ro.z = 3.0;\n        \n    }*/\n    \n    \n    float zoom = 1.0;    \n    vec3 f = normalize(lookat-ro),\n        r = normalize(cross(vec3(0,1,0), f)),\n        u = cross(f, r),\n        c = ro + f * zoom,\n        i = c + uv.x * r + uv.y * u,\n        rd = normalize(i-ro);\n        \n    \n        \n     vec3 t;\n     float dO, dif, dif2, dif3, difT;\n     vec3 p;\n     \n  \n     \n     t = RayMarch2(ro, rd, uv);\n     p = ro + rd * t.x;\n     \n    float alpha = 1.0;\n    vec3 n1, n2, n3, np;\n    \n  \n   \n    \n    //vec3 ph = phongIllumination(vec3(1.0), vec3(dif), vec3(1.0, 1.0, 0.0), 50.0, p, ro, uv, np);\n    \n     if(t.x > 0.0){\n         \n         vec3 diff2 = GetLightM(p, uv, lightpos, n1, ro, rd);\n         \n                \n         if(t.z == 0.0){\n             //col = ph * vec3(0.0, 1.0, 0.0);\n         }\n         else if(t.z == 1.0){\n             col = diff2* vec3(1.0, 0.0, 0.0);\n         }\n         else if(t.z == 2.0){\n         \n             float NdotL = max( 0., dot( n1, lightpos-p ) );\n             float SpecularColor;\n            SpecularColor = SpecularColor + ( 1. - SpecularColor ) * pow( ( 1. - NdotL ), 5. );\n             \n             col = diff2*vec3(.9, .9, .9);\n             \n         \n             alpha = 0.1;\n             \n             \n                      \n             alpha = 0.1;\n             \n             \n         }\n         else if(t.z == -1.0){\n             vec3 colXZ = texture(iChannel0, p.xz*2.81).rgb;\n             vec3 colYZ = texture(iChannel0, p.yz*2.81).rgb;\n             vec3 colXY = texture(iChannel0, p.xy*2.81).rgb;\n             \n             \n             n1 = abs(n1);\n             \n             n1 *= pow(n1, vec3(20));\n             n1 /= n1.x+n1.y+n1.z;\n             \n             col = colYZ * n1.x + colXZ * n1.y + colXY*n1.z;\n             \n             uv = vec2(atan(p.x, p.z)/6.2832+.5, p.y/3.+0.5);\n             vec4 st = texture(iChannel0, uv);\n            \n             \n             col = diff2 * mix(col, st.rgb, st.a);\n         }\n         else if(t.z == 3.0){\n            \n             \n             float NdotL = max( 0., dot( n1, lightpos-p ) );\n             float SpecularColor = 0.5;\n            SpecularColor = SpecularColor + ( 1. - SpecularColor ) * pow( ( 1. - NdotL ), 5. );\n             \n            \n             col = mix(diff2 * vec3(0.5, 0.5, 0.5)+SpecularColor*0.001, \n                       vec3(0., 0.5, 5.0)*diff2+vec3(0.2,0.5, 0.5)*SpecularColor*0.001, 0.7 );\n             col += normalize(vec3(0.1, 0.1, 0.1));\n         \n         \n         }\n         else if(t.z == 4.0){\n             \n             float NdotL = max( 0., dot( n1, lightpos-p ) );\n             float SpecularColor = 0.5;\n            SpecularColor = SpecularColor + ( 1. - SpecularColor ) * pow( ( 1. - NdotL ), 5. );\n             \n             col = mix(diff2 * vec3(0.5, 0.5, 0.5)+SpecularColor*0.001, \n                       vec3(0., 0.5, 5.0)*diff2+vec3(0.2,0.5, 0.5)*SpecularColor*0.0001, 0.7 );\n             col += normalize(vec3(0.1, 0.1, 0.1));\n             col =  texture(iChannel0, vec2(noise(uv+iTime*0.01))).rgb;\n             \n         }\n         else if(t.z == 5.0){\n            \n                         \n             col = mix(XaterColor(p*0.1)*diff2*exp(-0.001*t.x), vec3(0.0, 1.0, 1.0), 0.4); \n            \n             \n         }\n         \n         vec2 j = uv*3.0;\n         j.x += 0.0;\n         j.y += .1;\n         float sparkle = 1./dot(j,j);\n                \n         col += diff2*(sparkle*sin(mod(iTime*10.0, 3.1415))*0.01) ;\n    \n       \n         \n         \n         \n     }\n     else\n     {\n         col = RayMarchCloud( ro, rd);\n     \n     }\n    \n   \n    // Output to screen\n    fragColor = vec4((col),alpha);\n}\n\n\n\n", "image_inputs": [{"id": "XdXGzn", "previewfilepath": "/media/ap/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png", "ctype": "texture"}, {"id": "XdXGzn", "previewfilepath": "/media/ap/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3ttcWl.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[94, 94, 112, 112, 172], [173, 173, 192, 192, 272], [273, 273, 292, 292, 372], [373, 373, 392, 392, 472], [475, 475, 529, 604, 700], [703, 703, 744, 846, 939], [942, 942, 979, 979, 1101], [1103, 1114, 1140, 1140, 1355], [1357, 1402, 1427, 1427, 1792], [1794, 1794, 1815, 1815, 1934], [1936, 1936, 1962, 1962, 2420], [2424, 2424, 2475, 2475, 2791], [2793, 2793, 2838, 2838, 2932], [2934, 2934, 2970, 2970, 3013], [3015, 3015, 3062, 3062, 3321], [3323, 3323, 3363, 3363, 3528], [3530, 3530, 3585, 3585, 3650], [3652, 3652, 3700, 3700, 3767], [3769, 3769, 3806, 3806, 3835], [3837, 3837, 3860, 3860, 3923], [3925, 3925, 3954, 3954, 3993], [3995, 3995, 4013, 4013, 4237], [4240, 4240, 4270, 4270, 6092], [6094, 6094, 6151, 6151, 6560], [6563, 6563, 6634, 6634, 9285], [9382, 9427, 9491, 9491, 9918], [9919, 9919, 9955, 9955, 10543], [10590, 10590, 10615, 10615, 11120], [11122, 11122, 11179, 11229, 15415]]}
{"id": "3ttfRn", "name": "boolean,polarmod", "author": "kithy", "description": "sphere,box,boolean,intersect,polarmod", "tags": ["sphere", "box", "intersect", "boolean", "polarmod"], "likes": 1, "viewed": 54, "published": "Public", "date": "1612103321", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const vec3 lightDir=vec3(-0.57,0.57,0.57);\n\n\nfloat distFuncCube(vec3 p){\n\tvec3 q=abs(p);\n\treturn length(max(q-vec3(1.0,0.1,0.5),0.0));\n}\n\nfloat distFuncSphere(vec3 p){\n\tfloat s=0.5;\n\treturn length(p)-s;\n}\n\n\nvec2 pmod(vec2 p,float n){\n\tfloat np=3.141592*2.0/n;\n\tfloat r=atan(p.x,p.y)-0.5*np;\n\tr=mod(r,np)-0.5*np;\n\treturn length(p)*vec2(cos(r),sin(r));\n}\n\n\nfloat distFunc(vec3 p){\n\tp.xy=pmod(p.xy,6.0);\n\tp=mod(p,0.8)-0.4;\n\tfloat d3=distFuncCube(p);\n\tfloat d4=distFuncSphere(p);\n\n\t//return(d3);\n\t//return(d4);\n\n\t//return min(d3,d4);//OR\n\n\t//return max(d3,d4);//AND\n\n\treturn max(d3,-d4);\n\t\n\t//return max(-d3,d4);\n\n}\n\n\nvec3 genNormal(vec3 p){\n\tfloat d=0.0001;\n\treturn normalize(vec3(\n\t\tdistFunc(p+vec3(d,0.0,0.0))-distFunc(p+vec3(-d,0.0,0.0)),\n\t\tdistFunc(p+vec3(0.0,d,0.0))-distFunc(p+vec3(0.0,-d,0.0)),\n\t\tdistFunc(p+vec3(0.0,0.0,d))-distFunc(p+vec3(0.0,0.0,-d))\n\t\t));\n}\n\n\nvoid mainImage(out vec4 fragColor,in vec2 fragCoord){\n\tvec2 p=(2.0*fragCoord.xy-iResolution.xy)/min(iResolution.x,iResolution.y);\n\n\n\tfloat radius=0.0;\n\tfloat phi=iTime*0.2;\n\t\n\n\tvec3 cPos=vec3(0.0,0.0,3.0-iTime*0.5);\n\tvec3 cDir=vec3(0.0,0.0,-1.0);\n\tvec3 cUp=vec3(0.0,1.0,0.0);\n\tvec3 cSide=cross(cDir,cUp);\n\tfloat targetDepth=1.0;\n\n\tvec3 ray=normalize(cSide*p.x+cUp*p.y+cDir*targetDepth);\n\n\tfloat tmp,dist;\n\ttmp=0.0;\n\tvec3 dPos=cPos;\n\n\tfloat emission=0.0;\n\n\tfor(int i=0;i<48;i++){\n\t\tdist=distFunc(dPos);\n\t\ttmp+=dist;\n\t\tdPos=cPos+tmp*ray;\n\t\temission+=exp(abs(dist)*-0.2);\n\t}\n\n\tvec3 color;\n\n\tif(abs(dist)<0.001){\n\t\tvec3 normal=genNormal(dPos);\n\t\tfloat diff=clamp(dot(lightDir,normal),0.1,1.0);\n\t\tcolor=0.02*emission*vec3(1.0,sin(iTime),1.0)*diff;\n\t}else{\n\t\tcolor=vec3(0.0);\n\t}\n\tfragColor=vec4(color,1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3ttfRn.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[45, 45, 72, 72, 136], [138, 138, 167, 167, 204], [207, 207, 233, 233, 352], [355, 355, 378, 378, 611], [614, 614, 637, 637, 865], [868, 868, 921, 921, 1670]]}
{"id": "3ttyWl", "name": "TorusKnot 3", "author": "gaz", "description": "3d", "tags": ["knot", "torusknot"], "likes": 5, "viewed": 121, "published": "Public", "date": "1610200574", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI (atan(1.)*4.)\n#define TAU atan(1.)*8.\n\nvoid lookAt(inout vec3 rd,vec3 ro,vec3 ta,vec3 up){\n    vec3 w=normalize(ta-ro),u=normalize(cross(w,up));\n    rd=rd.x*u+rd.y*cross(u,w)+rd.z*w;\n}\n\nvoid rot(inout vec3 p,vec3 a,float t){\n\ta=normalize(a);\n\tvec3 u=cross(a,p),v=cross(a,u);\n\tp=u*sin(t)+v*cos(t)+a*dot(a,p);   \n}\n\nfloat map(vec3 p){\n\trot(p,vec3(cos(iTime*.3),sin(iTime*.5),.5*sin(iTime*.2)),iTime*.7);\n    float r1=.7;\n    float r2=.3;\n    float r3=.05;\n    float n1=1.;\n    float n2=.6;\n    //float a=.3;\n    float a=.5;//floor(30.*fract(iTime*.5))*.1;\n    float b=.1;\n    p.zx=vec2(atan(p.z,p.x)/PI*n1, length(p.zx)-r1);\n    p.xy=vec2(atan(p.x,p.y)/PI*n2, length(p.xy)-r2);\n    p.x+=a*p.z;\n    p.x=mod(p.x,b*2.)-b;\n    return length(p.xy)-r3;\n}\n\n\nvec3 calcNormal(vec3 p)\n{\n  vec3 n=vec3(0);\n  for(int i=0; i<4; i++){\n    vec3 e=.001*(vec3(9>>i&1, i>>1&1, i&1)*2.-1.);\n    n+=e*map(p+e);\n  }\n  return normalize(n);\n}\n\nfloat march(vec3 ro, vec3 rd, float near, float far)\n{\n    float t=near,d;\n    for(int i=0;i<70;i++)\n    {\n        t+=d=map(ro+rd*t);\n        if (d<.001) return t;\n        if (t>=far) return far;\n    }\n    return far;\n}\n\nvec3 doColor(vec3 p)\n{\n    return vec3(.7,.5,.3)+cos(p*2.)*.5+.5;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord.xy*2.-iResolution.xy)/iResolution.y;\n    vec3 ro = vec3(0,0,3);\n    vec3 rd = normalize(vec3(uv,3));\n    vec3 ta =vec3(0);\n    lookAt(rd,ro,ta,vec3(0,1,0));    \n    vec3 col= vec3(0);\n\tconst float maxd=50.;\n    float t=march(ro,rd,0.,maxd);\n    if(t<maxd)\n    {\n        vec3 p=ro+rd*t;\n        col=doColor(p); \n        vec3 n=calcNormal(p);      \n\t\tvec3 lightPos=ro+vec3(2,5,2);\n    \tvec3 li=lightPos-p;\n\t\tfloat len=length(li);\n\t\tli/=len;\n\t\tfloat dif=clamp(dot(n,li),0.,1.);\n        col*=max(dif,0.);\n        float rimd=pow(clamp(1.-dot(reflect(-li,n),-rd),0.,1.),2.5);\n\t\tfloat frn=rimd+2.2*(1.-rimd);\n    \tcol*=frn*.8;\n        col*=max(.5+.5*n.y,.1);\n        col*=exp2(-2.*pow(max(0.,1.-map(p+n*.8)/.8),2.));\n        col+=vec3(.8,.6,.2)*pow(clamp(dot(reflect(rd,n),li),0.,1.),10.);\n    }\n    col=pow(col,vec3(1./2.2));\n    fragColor.xyz=col;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3ttyWl.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[50, 50, 101, 101, 195], [197, 197, 235, 235, 323], [325, 325, 343, 343, 757], [760, 760, 785, 785, 928], [930, 930, 984, 984, 1149], [1151, 1151, 1173, 1173, 1218], [1220, 1220, 1277, 1277, 2147]]}
{"id": "3tVczw", "name": "Noisy Colours", "author": "tomzer0", "description": "Just generates a bunch of random colours, is semi-pleasing to look at. Made it cause I was bored, might continue experimenting with different noise fns to draw more.", "tags": ["noise"], "likes": 0, "viewed": 48, "published": "Public", "date": "1610700884", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float noise(float a) {\n    return fract(sin(a) * 1337.1337 + 7.2718);\n}\n\nfloat noise2(vec2 a) {\n    return noise(dot(a, vec2(3.91239, 7.139938)));\n}\n\n\nvoid pattern(vec2 uv, out vec4 fragColor) {\n    float r = noise2(uv*31. + vec2(sin(iTime/10000.0), 0));\n    float g = noise2(uv*17. + cos(iTime/10000.) * 7.5 * noise2(uv*3.14 + vec2(2.5, 0.3)));\n    float b = noise2(uv*51. + cos(iTime/3959.) *\n        noise2(uv * uv * 13.5\n         + noise2(uv * uv * uv * 7. + vec2(6.9, 0.25))));\n    fragColor = vec4(\n        r * smoothstep(1., (sin(iTime)+0.9)/2., fwidth(r)),\n        g * smoothstep(1., (cos(iTime+0.5)+0.9)/2., fwidth(g)),\n        b * smoothstep(tan(iTime), 1., fwidth(b)),\n        //g*b,\n        1.0\n    );\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    pattern(uv, fragColor);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3tVczw.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 22, 22, 71], [73, 73, 95, 95, 148], [151, 151, 194, 194, 715], [717, 717, 773, 823, 898]]}
{"id": "3tVyWV", "name": "Flag in the sand", "author": "intrakits", "description": "I am finally starting to get the hang of this shader thing. I figured out yesterday how to color objects by having them return a vec2, with the second value being an ID. Such a simple way to do it, but it never crossed my mind.\n", "tags": ["3d", "sdf", "flag", "sand"], "likes": 2, "viewed": 174, "published": "Public API", "date": "1611793324", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#if HW_PERFORMANCE==0\n#define AA 1\n#else\n#define AA 2   // make this 2 or 3 for antialiasing\n#endif\n#define MAX_STEPS 200\n#define MAX_DIST 200.\n#define SURFACE_DIST 0.01\n//------------------------------------------------------------------\nfloat dot2( in vec2 v ) { return dot(v,v); }\nfloat dot2( in vec3 v ) { return dot(v,v); }\nfloat ndot( in vec2 a, in vec2 b ) { return a.x*b.x - a.y*b.y; }\n\nfloat sdPlane( vec3 p )\n{\n\treturn p.y;\n}\n\nvec2 sdSphere( vec3 p, float s )\n{\n    return vec2(length(p)-s,0);\n}\n\nvec2 sdBox( vec3 p, vec3 b )\n{\n    vec3 d = abs(p) - b;\n    return vec2(min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0)),1.);\n}\n\nvec2 sdBoundingBox( vec3 p, vec3 b, float e )\n{\n       p = abs(p  )-b;\n  vec3 q = abs(p+e)-e;\n\n  return vec2(min(min(\n      length(max(vec3(p.x,q.y,q.z),0.0))+min(max(p.x,max(q.y,q.z)),0.0),\n      length(max(vec3(q.x,p.y,q.z),0.0))+min(max(q.x,max(p.y,q.z)),0.0)),\n      length(max(vec3(q.x,q.y,p.z),0.0))+min(max(q.x,max(q.y,p.z)),0.0)),2.);\n}\nvec2 sdEllipsoid( in vec3 p, in vec3 r ) // approximated\n{\n    float k0 = length(p/r);\n    float k1 = length(p/(r*r));\n    return vec2(k0*(k0-1.0)/k1,3.);\n}\n\nfloat sdTorus( vec3 p, vec2 t )\n{\n    return length( vec2(length(p.xz)-t.x,p.y) )-t.y;\n}\n\nfloat sdCappedTorus(in vec3 p, in vec2 sc, in float ra, in float rb)\n{\n    p.x = abs(p.x);\n    float k = (sc.y*p.x>sc.x*p.y) ? dot(p.xy,sc) : length(p.xy);\n    return sqrt( dot(p,p) + ra*ra - 2.0*ra*k ) - rb;\n}\n\nfloat sdHexPrism( vec3 p, vec2 h )\n{\n    vec3 q = abs(p);\n\n    const vec3 k = vec3(-0.8660254, 0.5, 0.57735);\n    p = abs(p);\n    p.xy -= 2.0*min(dot(k.xy, p.xy), 0.0)*k.xy;\n    vec2 d = vec2(\n       length(p.xy - vec2(clamp(p.x, -k.z*h.x, k.z*h.x), h.x))*sign(p.y - h.x),\n       p.z-h.y );\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat sdOctogonPrism( in vec3 p, in float r, float h )\n{\n  const vec3 k = vec3(-0.9238795325,   // sqrt(2+sqrt(2))/2 \n                       0.3826834323,   // sqrt(2-sqrt(2))/2\n                       0.4142135623 ); // sqrt(2)-1 \n  // reflections\n  p = abs(p);\n  p.xy -= 2.0*min(dot(vec2( k.x,k.y),p.xy),0.0)*vec2( k.x,k.y);\n  p.xy -= 2.0*min(dot(vec2(-k.x,k.y),p.xy),0.0)*vec2(-k.x,k.y);\n  // polygon side\n  p.xy -= vec2(clamp(p.x, -k.z*r, k.z*r), r);\n  vec2 d = vec2( length(p.xy)*sign(p.y), p.z-h );\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nvec2 sdCapsule( vec3 p, vec3 a, vec3 b, float r )\n{\n\tvec3 pa = p-a, ba = b-a;\n\tfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n\treturn vec2(length( pa - ba*h ) - r,16.);\n}\n\nfloat sdRoundCone( in vec3 p, in float r1, float r2, float h )\n{\n    vec2 q = vec2( length(p.xz), p.y );\n    \n    float b = (r1-r2)/h;\n    float a = sqrt(1.0-b*b);\n    float k = dot(q,vec2(-b,a));\n    \n    if( k < 0.0 ) return length(q) - r1;\n    if( k > a*h ) return length(q-vec2(0.0,h)) - r2;\n        \n    return dot(q, vec2(a,b) ) - r1;\n}\n\nfloat sdRoundCone(vec3 p, vec3 a, vec3 b, float r1, float r2)\n{\n    // sampling independent computations (only depend on shape)\n    vec3  ba = b - a;\n    float l2 = dot(ba,ba);\n    float rr = r1 - r2;\n    float a2 = l2 - rr*rr;\n    float il2 = 1.0/l2;\n    \n    // sampling dependant computations\n    vec3 pa = p - a;\n    float y = dot(pa,ba);\n    float z = y - l2;\n    float x2 = dot2( pa*l2 - ba*y );\n    float y2 = y*y*l2;\n    float z2 = z*z*l2;\n\n    // single square root!\n    float k = sign(rr)*rr*rr*x2;\n    if( sign(z)*a2*z2 > k ) return  sqrt(x2 + z2)        *il2 - r2;\n    if( sign(y)*a2*y2 < k ) return  sqrt(x2 + y2)        *il2 - r1;\n                            return (sqrt(x2*a2*il2)+y*rr)*il2 - r1;\n}\n\nfloat sdTriPrism( vec3 p, vec2 h )\n{\n    const float k = sqrt(3.0);\n    h.x *= 0.5*k;\n    p.xy /= h.x;\n    p.x = abs(p.x) - 1.0;\n    p.y = p.y + 1.0/k;\n    if( p.x+k*p.y>0.0 ) p.xy=vec2(p.x-k*p.y,-k*p.x-p.y)/2.0;\n    p.x -= clamp( p.x, -2.0, 0.0 );\n    float d1 = length(p.xy)*sign(-p.y)*h.x;\n    float d2 = abs(p.z)-h.y;\n    return length(max(vec2(d1,d2),0.0)) + min(max(d1,d2), 0.);\n}\n\n// vertical\nvec2 sdCylinder( vec3 p, vec2 h )\n{\n    vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n    return vec2(min(max(d.x,d.y),0.0) + length(max(d,0.0)),21.);\n}\n\n// arbitrary orientation\nfloat sdCylinder(vec3 p, vec3 a, vec3 b, float r)\n{\n    vec3 pa = p - a;\n    vec3 ba = b - a;\n    float baba = dot(ba,ba);\n    float paba = dot(pa,ba);\n\n    float x = length(pa*baba-ba*paba) - r*baba;\n    float y = abs(paba-baba*0.5)-baba*0.5;\n    float x2 = x*x;\n    float y2 = y*y*baba;\n    float d = (max(x,y)<0.0)?-min(x2,y2):(((x>0.0)?x2:0.0)+((y>0.0)?y2:0.0));\n    return sign(d)*sqrt(abs(d))/baba;\n}\n\n// vertical\nfloat sdCone( in vec3 p, in vec2 c, float h )\n{\n    vec2 q = h*vec2(c.x,-c.y)/c.y;\n    vec2 w = vec2( length(p.xz), p.y );\n    \n\tvec2 a = w - q*clamp( dot(w,q)/dot(q,q), 0.0, 1.0 );\n    vec2 b = w - q*vec2( clamp( w.x/q.x, 0.0, 1.0 ), 1.0 );\n    float k = sign( q.y );\n    float d = min(dot( a, a ),dot(b, b));\n    float s = max( k*(w.x*q.y-w.y*q.x),k*(w.y-q.y)  );\n\treturn sqrt(d)*sign(s);\n}\n\nfloat sdCappedCone( in vec3 p, in float h, in float r1, in float r2 )\n{\n    vec2 q = vec2( length(p.xz), p.y );\n    \n    vec2 k1 = vec2(r2,h);\n    vec2 k2 = vec2(r2-r1,2.0*h);\n    vec2 ca = vec2(q.x-min(q.x,(q.y < 0.0)?r1:r2), abs(q.y)-h);\n    vec2 cb = q - k1 + k2*clamp( dot(k1-q,k2)/dot2(k2), 0.0, 1.0 );\n    float s = (cb.x < 0.0 && ca.y < 0.0) ? -1.0 : 1.0;\n    return s*sqrt( min(dot2(ca),dot2(cb)) );\n}\n\nfloat sdCappedCone(vec3 p, vec3 a, vec3 b, float ra, float rb)\n{\n    float rba  = rb-ra;\n    float baba = dot(b-a,b-a);\n    float papa = dot(p-a,p-a);\n    float paba = dot(p-a,b-a)/baba;\n\n    float x = sqrt( papa - paba*paba*baba );\n\n    float cax = max(0.0,x-((paba<0.5)?ra:rb));\n    float cay = abs(paba-0.5)-0.5;\n\n    float k = rba*rba + baba;\n    float f = clamp( (rba*(x-ra)+paba*baba)/k, 0.0, 1.0 );\n\n    float cbx = x-ra - f*rba;\n    float cby = paba - f;\n    \n    float s = (cbx < 0.0 && cay < 0.0) ? -1.0 : 1.0;\n    \n    return s*sqrt( min(cax*cax + cay*cay*baba,\n                       cbx*cbx + cby*cby*baba) );\n}\n\n// c is the sin/cos of the desired cone angle\nfloat sdSolidAngle(vec3 pos, vec2 c, float ra)\n{\n    vec2 p = vec2( length(pos.xz), pos.y );\n    float l = length(p) - ra;\n\tfloat m = length(p - c*clamp(dot(p,c),0.0,ra) );\n    return max(l,m*sign(c.y*p.x-c.x*p.y));\n}\n\nfloat sdOctahedron(vec3 p, float s)\n{\n    p = abs(p);\n    float m = p.x + p.y + p.z - s;\n\n    // exact distance\n    #if 0\n    vec3 o = min(3.0*p - m, 0.0);\n    o = max(6.0*p - m*2.0 - o*3.0 + (o.x+o.y+o.z), 0.0);\n    return length(p - s*o/(o.x+o.y+o.z));\n    #endif\n    \n    // exact distance\n    #if 1\n \tvec3 q;\n         if( 3.0*p.x < m ) q = p.xyz;\n    else if( 3.0*p.y < m ) q = p.yzx;\n    else if( 3.0*p.z < m ) q = p.zxy;\n    else return m*0.57735027;\n    float k = clamp(0.5*(q.z-q.y+s),0.0,s); \n    return length(vec3(q.x,q.y-s+k,q.z-k)); \n    #endif\n    \n    // bound, not exact\n    #if 0\n\treturn m*0.57735027;\n    #endif\n}\n\nfloat sdPyramid( in vec3 p, in float h )\n{\n    float m2 = h*h + 0.25;\n    \n    // symmetry\n    p.xz = abs(p.xz);\n    p.xz = (p.z>p.x) ? p.zx : p.xz;\n    p.xz -= 0.5;\n\t\n    // project into face plane (2D)\n    vec3 q = vec3( p.z, h*p.y - 0.5*p.x, h*p.x + 0.5*p.y);\n   \n    float s = max(-q.x,0.0);\n    float t = clamp( (q.y-0.5*p.z)/(m2+0.25), 0.0, 1.0 );\n    \n    float a = m2*(q.x+s)*(q.x+s) + q.y*q.y;\n\tfloat b = m2*(q.x+0.5*t)*(q.x+0.5*t) + (q.y-m2*t)*(q.y-m2*t);\n    \n    float d2 = min(q.y,-q.x*m2-q.y*0.5) > 0.0 ? 0.0 : min(a,b);\n    \n    // recover 3D and scale, and add sign\n    return sqrt( (d2+q.z*q.z)/m2 ) * sign(max(q.z,-p.y));;\n}\n\n// la,lb=semi axis, h=height, ra=corner\nfloat sdRhombus(vec3 p, float la, float lb, float h, float ra)\n{\n    p = abs(p);\n    vec2 b = vec2(la,lb);\n    float f = clamp( (ndot(b,b-2.0*p.xz))/dot(b,b), -1.0, 1.0 );\n\tvec2 q = vec2(length(p.xz-0.5*b*vec2(1.0-f,1.0+f))*sign(p.x*b.y+p.z*b.x-b.x*b.y)-ra, p.y-h);\n    return min(max(q.x,q.y),0.0) + length(max(q,0.0));\n}\n\n//------------------------------------------------------------------\n\nvec2 opU( vec2 d1, vec2 d2 )\n{\n\treturn (d1.x<d2.x) ? d1 : d2;\n}\n\n//------------------------------------------------------------------\n\n#define ZERO (min(iFrame,0))\n\n//------------------------------------------------------------------\nfloat differenceSDF(float distA, float distB) {\n    return max(distA, -distB);\n}\nvec2 sdGyroid(vec3 p, float scale, float thickness, float bias) {\n\tp *= scale;\n    return vec2(abs(dot(sin(p), cos(p.zxy))-bias)/scale-thickness,15.);\n}\nmat2 Rot(float a) {\n    float s=sin(a), c=cos(a);\n    return mat2(c, -s, s, c);\n}\n// http://iquilezles.org/www/articles/smin/smin.htm\nvec2 smin( vec2 a, vec2 b, float k )\n{\n    float h = clamp( 0.5+0.5*(b.x-a.x)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\n// http://iquilezles.org/www/articles/smin/smin.htm\nfloat smax( float a, float b, float k )\n{\n    float h = max(k-abs(a-b),0.0);\n    return max(a, b) + h*h*0.25/k;\n}\nvec2 cactus (vec3 pos){\n    //add cactus\n    vec2 uv4 = vec2(atan(pos.x,pos.z)/(3.14159*1.),pos.y/1.);\n    float disp4 = texture(iChannel1,uv4).r;\n    vec2 cactus = sdCapsule(pos, vec3(10,0,0), vec3(10,1,0), .2 );\n    vec2 thorn = sdCapsule(pos, vec3(10,0,0), vec3(10,1,0), .14 );\n    thorn.x-=disp4*.1;\n    thorn.y = 17.;\n    cactus = opU(cactus,thorn);\n    \n    vec3 nP = pos;\n    nP.y += (sin(nP.x*4.) * .1 * smoothstep(1.1,1.2,nP.x));\n    vec2 cactusR = sdCapsule(nP, vec3(10,.5,0), vec3(10.5,.5,0), .13 );\n    vec2 thornR = sdCapsule(nP, vec3(10,.5,0), vec3(10.5,.5,0), .08 );\n    \n    thornR.x-=disp4*.1;\n    thornR.y = 17.;\n    cactusR = opU(cactusR,thornR);\n    cactus.x = smin(cactusR,cactus, .1).x;\n    return cactus;\n}\nvec2 map( in vec3 pos )\n{\n    vec2 res = vec2( 1e10, 0.0 );\n    \n    //get rock displacement\n    vec2 uv = vec2(atan(pos.x,pos.z)/(3.14159*2.),pos.y/5.);\n    float disp = texture(iChannel0,uv).r;\n    vec2 uv2 = vec2(pos.x*.1, pos.z*.1);\n    float disp2 = texture(iChannel0,uv2).r;\n    vec2 uv3 = vec2(pos.x*.1, pos.z*.1+iTime*.1);\n    float disp3 = texture(iChannel1,uv3).r;\n    disp3 *= smoothstep(.09,.32,abs(pos.z));\n    \n    \n\n    //make gyroid\n    vec2 gyroid = sdGyroid(pos-vec3(10.,-3.,5.), 0.3, 1., .8);\n    \n    //add floor to scene\n    vec2 floorP = vec2(pos.y,20.);\n    //apply rocky displacement to floor\n    floorP.x-=disp2*.1;\n    res = opU(floorP,res);\n    \n    //add gyriod to scene\n    res = opU(gyroid,res);\n    for(int i = 0; i < 2; i++){\n        for(int k = 0; k < 2; k++){\n            vec3 nP = pos;\n            nP.xz *= Rot(float(k)*3.1415);\n            res = opU(cactus(abs(nP-vec3(i+k*10,0,k+i*10))),res);\n        }\n    }\n    \n    \n    //add flag\n    vec2 pole = sdCylinder(pos, vec2(.01,1.4) );\n    res = opU(pole,res);\n    //add cloth\n    pos.x += (sin(pos.z + iTime*5.)*.1) * smoothstep(.1,1.1,pos.z);\n    vec2 cloth = sdBox( pos-vec3(0,1.1,0.5), vec3(.01,.3,.5) );\n    //cloth.x -=disp3*.03;\n    res = opU(cloth,res);\n    return res;\n}\n\n// http://iquilezles.org/www/articles/boxfunctions/boxfunctions.htm\nvec2 iBox( in vec3 ro, in vec3 rd, in vec3 rad ) \n{\n    vec3 m = 1.0/rd;\n    vec3 n = m*ro;\n    vec3 k = abs(m)*rad;\n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n\treturn vec2( max( max( t1.x, t1.y ), t1.z ),\n\t             min( min( t2.x, t2.y ), t2.z ) );\n}\n\nvec2 raycast( in vec3 ro, in vec3 rd )\n{\n    \n    // raymarch primitives   \n    // distance from origin\n    float dO=0.;\n    float ID = -1.;\n    // march until max steps is achieved or object hit\n    for(int i=0; i <MAX_STEPS; i++){\n        // current point being evaluated\n        vec3 p = ro + dO*rd;\n        \n        // get distance to seam\n        vec2 getObj = map(p);\n        ID = getObj.y;\n        float ds = getObj.x;\n        //move origin to new point\n        if(ID == 15.){\n            dO+=ds*.1;\n        }\n        if(ID == 17.){\n            dO+=ds*.8;\n        }else{\n            dO+=ds;\n        }\n        if(ds < SURFACE_DIST || dO > MAX_DIST){\n            break;\n        }\n    }\n    return vec2(min(dO, MAX_DIST),ID);\n}\n\n// http://iquilezles.org/www/articles/rmshadows/rmshadows.htm\nfloat calcSoftshadow( in vec3 ro, in vec3 rd, in float mint, in float tmax )\n{\n    // bounding volume\n    float tp = (0.8-ro.y)/rd.y; if( tp>0.0 ) tmax = min( tmax, tp );\n\n    float res = 1.0;\n    float t = mint;\n    for( int i=ZERO; i<24; i++ )\n    {\n\t\tfloat h = map( ro + rd*t ).x;\n        float s = clamp(8.0*h/t,0.0,1.0);\n        res = min( res, s*s*(3.0-2.0*s) );\n        t += clamp( h, 0.02, 0.2 );\n        if( res<0.004 || t>tmax ) break;\n    }\n    return clamp( res, 0.0, 1.0 );\n}\n\n// http://iquilezles.org/www/articles/normalsSDF/normalsSDF.htm\nvec3 calcNormal( in vec3 pos )\n{\n#if 0\n    vec2 e = vec2(1.0,-1.0)*0.5773*0.0005;\n    return normalize( e.xyy*map( pos + e.xyy ).x + \n\t\t\t\t\t  e.yyx*map( pos + e.yyx ).x + \n\t\t\t\t\t  e.yxy*map( pos + e.yxy ).x + \n\t\t\t\t\t  e.xxx*map( pos + e.xxx ).x );\n#else\n    // inspired by tdhooper and klems - a way to prevent the compiler from inlining map() 4 times\n    vec3 n = vec3(0.0);\n    for( int i=ZERO; i<4; i++ )\n    {\n        vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);\n        n += e*map(pos+0.0005*e).x;\n      //if( n.x+n.y+n.z>100.0 ) break;\n    }\n    return normalize(n);\n#endif    \n}\n\nfloat calcAO( in vec3 pos, in vec3 nor )\n{\n\tfloat occ = 0.0;\n    float sca = 1.0;\n    for( int i=ZERO; i<5; i++ )\n    {\n        float h = 0.01 + 0.12*float(i)/4.0;\n        float d = map( pos + h*nor ).x;\n        occ += (h-d)*sca;\n        sca *= 0.95;\n        if( occ>0.35 ) break;\n    }\n    return clamp( 1.0 - 3.0*occ, 0.0, 1.0 ) * (0.5+0.5*nor.y);\n}\n\n// http://iquilezles.org/www/articles/checkerfiltering/checkerfiltering.htm\nfloat checkersGradBox( in vec2 p, in vec2 dpdx, in vec2 dpdy )\n{\n    // filter kernel\n    vec2 w = abs(dpdx)+abs(dpdy) + 0.001;\n    // analytical integral (box filter)\n    vec2 i = 2.0*(abs(fract((p-0.5*w)*0.5)-0.5)-abs(fract((p+0.5*w)*0.5)-0.5))/w;\n    // xor pattern\n    return 0.5 - 0.5*i.x*i.y;                  \n}\n\nvec3 render( in vec3 ro, in vec3 rd, in vec3 rdx, in vec3 rdy )\n{ \n    // background\n    vec3 col = vec3(0.7, 0.7, 0.9) - max(rd.y,0.0)*0.3;\n    \n    // raycast scene\n    vec2 res = raycast(ro,rd);\n    float t = res.x;\n\tfloat m = res.y;\n    if( m>-0.5 )\n    {\n        vec3 pos = ro + t*rd;\n        vec3 nor = (m<1.5) ? vec3(0.0,1.0,0.0) : calcNormal( pos );\n        vec3 ref = reflect( rd, nor );\n        float ks = .3;\n        // material        \n        if(m == 1.){\n            col = vec3(1,0,0);\n            float ks = .1;\n        }\n        else if( m==20.)\n        {\n            // project pixel footprint into the plane\n            /*vec3 dpdx = ro.y*(rd/rd.y-rdx/rdx.y);\n            vec3 dpdy = ro.y*(rd/rd.y-rdy/rdy.y);\n\n            float f = checkersGradBox( 3.0*pos.xz, 3.0*dpdx.xz, 3.0*dpdy.xz );\n            col = 0.15 + f*vec3(0.05);*/\n            col = vec3(0.4,.1,0);\n            ks = .1;\n        }\n        else if( m==15.){\n            col = vec3(0.4,.1,0);\n            ks = .1; \n        }\n         else if( m==16.){\n            col = vec3(0,.1,0);\n            ks = .1; \n        }\n        else if( m==21.){\n            col = vec3(1,1,1);\n            ks = 5.; \n        }\n        // lighting\n        float occ = calcAO( pos, nor );\n        \n\t\tvec3 lin = vec3(0.0);\n\n        // sun\n        {\n            vec3  lig = normalize( vec3(0.6, 0.7, -0.9) );\n            vec3  hal = normalize( lig-rd );\n            float dif = clamp( dot( nor, lig ), 1.0, 1.0 );\n          //if( dif>0.0001 )\n        \t      dif *= calcSoftshadow( pos, lig, 0.02, 2.5 );\n\t\t\tfloat spe = pow( clamp( dot( nor, hal ), 0.0, 1.0 ),16.0);\n                  spe *= dif;\n                  spe *= 0.04+0.96*pow(clamp(1.0-dot(hal,lig),0.0,1.0),5.0);\n            lin += col*2.20*dif*vec3(1.30,1.00,0.70);\n            lin +=     5.00*spe*vec3(1.30,1.00,0.70)*ks;\n        }\n        // sky\n        {\n            float dif = sqrt(clamp( 0.5+0.5*nor.y, 0.0, 1.0 ));\n                  dif *= occ;\n            float spe = smoothstep( -0.2, 0.2, ref.y );\n                  spe *= dif;\n                  spe *= 0.04+0.96*pow(clamp(1.0+dot(nor,rd),0.0,1.0), 5.0 );\n          //if( spe>0.001 )\n                  spe *= calcSoftshadow( pos, ref, 0.02, 2.5 );\n            lin += col*0.60*dif*vec3(0.40,0.60,1.15);\n            lin +=     2.00*spe*vec3(0.40,0.60,1.30)*ks;\n        }\n        // back\n        {\n        \tfloat dif = clamp( dot( nor, normalize(vec3(0.5,0.0,0.6))), 0.0, 1.0 )*clamp( 1.0-pos.y,0.0,1.0);\n                  dif *= occ;\n        \tlin += col*0.55*dif*vec3(0.25,0.25,0.25);\n        }\n        // sss\n        {\n            float dif = pow(clamp(1.0+dot(nor,rd),0.0,1.0),2.0);\n                  dif *= occ;\n        \tlin += col*0.25*dif*vec3(1.00,1.00,1.00);\n        }\n        \n\t\tcol = lin;\n\n        col = mix( col, vec3(0.7,0.7,0.9), 1.0-exp( -0.0001*t*t*t ) );\n    }\n\n\treturn vec3( clamp(col,0.0,1.0) );\n}\n\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr )\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv =          ( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 mo = iMouse.xy/iResolution.xy;\n\tfloat time = 32.0 + iTime*1.5;\n\n    // camera\t\n    vec3 ta = vec3( 0.5, -0.5, -0.6 );\n    vec3 ro = ta + vec3( 4.5*cos(0.1*time + 7.0*mo.x), 1.3 + 2.0*mo.y, 4.5*sin(0.1*time + 7.0*mo.x) );\n    // camera-to-world transformation\n    mat3 ca = setCamera( ro, ta, 0.0 );\n\n    vec3 tot = vec3(0.0);\n#if AA>1\n    for( int m=ZERO; m<AA; m++ )\n    for( int n=ZERO; n<AA; n++ )\n    {\n        // pixel coordinates\n        vec2 o = vec2(float(m),float(n)) / float(AA) - 0.5;\n        vec2 p = (2.0*(fragCoord+o)-iResolution.xy)/iResolution.y;\n#else    \n        vec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n#endif\n\n        // ray direction\n        vec3 rd = ca * normalize( vec3(p,2.5) );\n\n         // ray differentials\n        vec2 px = (2.0*(fragCoord+vec2(1.0,0.0))-iResolution.xy)/iResolution.y;\n        vec2 py = (2.0*(fragCoord+vec2(0.0,1.0))-iResolution.xy)/iResolution.y;\n        vec3 rdx = ca * normalize( vec3(px,2.5) );\n        vec3 rdy = ca * normalize( vec3(py,2.5) );\n        \n        // render\t\n        vec3 col = render( ro, rd, rdx, rdy );\n\n        // gain\n        // col = col*3.0/(2.5+col);\n        \n\t\t// gamma\n        col = pow( col, vec3(0.4545) );\n\n        tot += col;\n#if AA>1\n    }\n    tot /= float(AA*AA);\n#endif\n    \n    fragColor = vec4( tot, 1.0 );\n}", "image_inputs": [{"id": "4dXGzn", "previewfilepath": "/media/ap/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "ctype": "texture"}, {"id": "4sf3Rr", "previewfilepath": "/media/ap/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3tVyWV.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[170, 239, 264, 264, 283], [284, 284, 309, 309, 328], [329, 329, 365, 365, 393], [395, 395, 420, 420, 435], [437, 437, 471, 471, 505], [507, 507, 537, 537, 637], [639, 639, 686, 686, 983], [984, 984, 1042, 1042, 1140], [1142, 1142, 1175, 1175, 1230], [1232, 1232, 1302, 1302, 1442], [1444, 1444, 1480, 1480, 1791], [1793, 1793, 1849, 1849, 2351], [2353, 2353, 2404, 2404, 2528], [2530, 2530, 2594, 2594, 2872], [2874, 2874, 2937, 3001, 3588], [3590, 3590, 3626, 3626, 3976], [3978, 3990, 4025, 4025, 4138], [4140, 4165, 4216, 4216, 4571], [4573, 4585, 4632, 4632, 4977], [4979, 4979, 5050, 5050, 5388], [5390, 5390, 5454, 5454, 6014], [6016, 6062, 6110, 6110, 6279], [6281, 6281, 6318, 6318, 6912], [6914, 6914, 6956, 6956, 7556], [7558, 7598, 7662, 7662, 7920], [7922, 7992, 8022, 8022, 8055], [8157, 8226, 8273, 8273, 8306], [8307, 8307, 8372, 8372, 8459], [8460, 8460, 8479, 8479, 8541], [8542, 8594, 8632, 8632, 8729], [8731, 8783, 8824, 8824, 8896], [8897, 8897, 8920, 8937, 9626], [9627, 9627, 9652, 9652, 10890], [10892, 10960, 11011, 11011, 11216], [11218, 11218, 11258, 11321, 11949], [11951, 12013, 12091, 12114, 12501], [12503, 12567, 12599, 12599, 13169], [13171, 13171, 13213, 13213, 13522], [13524, 13600, 13664, 13685, 13918], [13920, 13920, 13985, 14004, 16808], [16810, 16810, 16862, 16862, 17039], [17041, 17041, 17098, 17098, 18415]]}
{"id": "3tVyzw", "name": "Gradient Noise and Perlin Noise", "author": "tomoe", "description": "Gradient noises generated by different selections of gradient\nLeft: random direction (Up: 3D, Down: 2D)\nRight: restricted direction (Perlin noise) (Up: 3D, Down: 2D)\n", "tags": ["bd202101"], "likes": 0, "viewed": 74, "published": "Public", "date": "1610696620", "time_retrieved": "2021-10-01T00:00:00", "image_code": "uvec3 k = uvec3(0x456789abu, 0x6789ab45u, 0x89ab4567u);\nconst uint max32 = 0xffffffffu;\nvec2 fragCoord_;  //set as a uniform variable\nvec3[12] gtable3 = vec3[](\n    vec3(1.0, 1.0, 0.0),\n    vec3(1.0, -1.0, 0.0),\n    vec3(-1.0, 1.0, 0.0),\n    vec3(-1.0, -1.0, 0.0),\n    vec3(1.0, 0.0, 1.0),\n    vec3(1.0, 0.0, -1.0),\n    vec3(-1.0, 0.0, 1.0),\n    vec3(-1.0, 0.0, -1.0),\n    vec3(0.0, 1.0, 1.0),\n    vec3(0.0, 1.0, -1.0),\n    vec3(0.0, -1.0, 1.0),\n    vec3(0.0, -1.0, -1.0)\n);\nvec2[8] gtable2 = vec2[](   //0.92387953 = cos(pi/8), 0.38268343 = cos(pi/8)\n    vec2(0.92387953, 0.38268343),\n    vec2(0.38268343, 0.92387953),\n    vec2(-0.92387953, 0.38268343),\n    vec2(-0.38268343, 0.92387953),\n    vec2(0.92387953, -0.38268343),\n    vec2(0.38268343, -0.92387953),\n    vec2(-0.92387953, -0.38268343),\n    vec2(-0.38268343, -0.92387953)\n);\nuint hash11u(uint n) {\n    n ^= (n << 24);\n    n ^= (n >> 1);\n    n ^= (n << 1);\n    return n * k.x;\n}\nuvec2 hash22u(uvec2 n) {\n    n ^= (n.yx << 24);\n    n ^= (n.yx >> 1);\n    n *= k.xy;\n    n ^= (n.yx << 1);\n    return n * k.xy;\n}\nvec2 hash22(vec2 p) {\n    if(fragCoord_.x < 0.5 * iResolution.x){\n        //down-left\n        uvec2 n = uvec2(p);\n        vec2 v = vec2(hash22u(n)) / vec2(max32);\n        return normalize(2.0 * v - vec2(1.0));\n    } else {\n        //down-right\n        \n        uint n = hash11u(hash11u(uint(p.x)) + uint(p.y));\n        n = n >> 29;\n        n = n % 8u;\n        return gtable2[n];\n    }\n}\nuvec3 hash33u(uvec3 n) {\n    n ^= (n.yzx << 24);\n    n ^= (n.yzx >> 1);\n    n *= k;\n    n ^= (n.yzx << 1);\n    return n * k;\n}\nvec3 hash33(vec3 p) {\n    if(fragCoord_.x < 0.5 * iResolution.x){\n        //up-left\n        uvec3 n = uvec3(p);\n        vec3 v = vec3(hash33u(n)) / vec3(max32);\n        return normalize(2.0 * v - vec3(1.0));\n    } else {\n        //up-right\n        uint n = hash11u(hash11u(hash11u(uint(p.x)) + uint(p.y)) + uint(p.z));\n        n = n >> 28;\n        n = n % 12u;\n        return gtable3[n] * 0.70710678; //0.70710678 = 1/sqrt(2)\n    }\n}\nfloat gnoise21(vec2 p) {\n    vec2 f = fract(p);\n    vec2 g00 = hash22(p);\n    vec2 g01 = hash22(p + vec2(0.0, 1.0));\n    vec2 g10 = hash22(p + vec2(1.0, 0.0));\n    vec2 g11 = hash22(p + vec2(1.0, 1.0));\n    float v00 = dot(g00, f);\n    float v01 = dot(g01, f - vec2(0.0, 1.0));\n    float v10 = dot(g10, f - vec2(1.0, 0.0));\n    float v11 = dot(g11, f - vec2(1.0, 1.0));\n    f = f * f * f * (10.0 - 15.0 * f + 6.0 * f * f); \n    float v = mix(mix(v00, v10, f.x), mix(v01, v11, f.x), f.y);\n    return 0.5 * v + 0.5;\n}\nfloat gnoise31(vec3 p) {\n    vec3 f = fract(p);\n    vec3 g000 = hash33(p);\n    vec3 g001 = hash33(p + vec3(0.0, 0.0, 1.0));\n    vec3 g010 = hash33(p + vec3(0.0, 1.0, 0.0));\n    vec3 g011 = hash33(p + vec3(0.0, 1.0, 1.0));\n    vec3 g100 = hash33(p + vec3(1.0, 0.0, 0.0));\n    vec3 g101 = hash33(p + vec3(1.0, 0.0, 1.0));\n    vec3 g110 = hash33(p + vec3(1.0, 1.0, 0.0));\n    vec3 g111 = hash33(p + vec3(1.0, 1.0, 1.0));\n\n    float v000 = dot(g000, f);\n    float v001 = dot(g001, f - vec3(0.0, 0.0, 1.0));\n    float v010 = dot(g010, f - vec3(0.0, 1.0, 0.0));\n    float v011 = dot(g011, f - vec3(0.0, 1.0, 1.0));\n    float v100 = dot(g100, f - vec3(1.0, 0.0, 0.0));\n    float v101 = dot(g101, f - vec3(1.0, 0.0, 1.0));\n    float v110 = dot(g110, f - vec3(1.0, 1.0, 0.0));\n    float v111 = dot(g111, f - vec3(1.0, 1.0, 1.0));\n     f = f * f * f * (10.0 - 15.0 * f + 6.0 * f * f); \n    float xy0 = mix(mix(v000, v100, f.x), mix(v010, v110, f.x), f.y);\n    float xy1 = mix(mix(v001, v101, f.x), mix(v011, v111, f.x), f.y);\n    return 0.5 * mix(xy0, xy1, f.z) + 0.5;\n}\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n    fragCoord_ = fragCoord;\n    vec2 pos = fragCoord.xy / min(iResolution.x, iResolution.y);\n    pos *= 20.0;\n    pos += iTime;\n    float v;\n    if(fragCoord.y < 0.5 * iResolution.y){\n        v = gnoise21(pos);  //down\n    } else {\n        v = gnoise31(vec3(pos, iTime));   //up \n    }\n    fragColor = vec4(vec3(v), 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3tVyzw.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[106, 834, 856, 856, 936], [937, 937, 961, 961, 1066], [1067, 1067, 1088, 1088, 1453], [1454, 1454, 1478, 1478, 1580], [1581, 1581, 1602, 1602, 2014], [2015, 2015, 2039, 2039, 2530], [2531, 2531, 2555, 2555, 3591], [3592, 3592, 3646, 3646, 3970]]}
{"id": "3tycWt", "name": "Voronoï 22222222222", "author": "regis", "description": "Voronoi", "tags": ["voronoi"], "likes": 2, "viewed": 53, "published": "Public", "date": "1611955409", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec2 N22(vec2 p){\n    vec3 a = fract(p.xyx*vec3(123.34, 234.34, 345.65));\n    a+=dot(a, a+34.45);\n    return fract(vec2(a.x*a.y, a.y*a.z));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n   \n    vec2 uv = (2.*fragCoord-iResolution.xy)/iResolution.y;\n    \n    float m = 0.;//N22(uv).x;\n    float t = iTime;\n    \n    float minDist = 100.;\n    float cellIndex = 0.;\n    \n\n        uv *= 3.;\n        vec2 gv = fract(uv)-.5;\n        vec2 id = floor(uv);\n        vec2 cid = vec2(0);\n        vec2 mo = vec2(0.0);\n        vec2 mp = vec2(0.0);\n        for (float y=-1.; y <= 1.;y++){\n            for (float x=-1.; x <= 1.;x++){\n                vec2 offset = vec2(x, y);\n                vec2 n = N22(id+offset);\n                vec2 p = offset+sin(n*t)*.5;\n                p -= gv;\n                float d = length(p);\n                if(d < minDist){\n                    minDist = d;\n                    cid = id+offset;\n                    mo = offset;\n                    mp = p;\n                }\n            }\n        }\n     \n        for (float y=-2.; y <= 2.;y++){\n            for (float x=-2.; x <= 2.;x++){\n                vec2 offset = vec2(x, y);\n                vec2 n = N22(id+offset);\n                vec2 p = offset+sin(n*t)*.5;\n                p -= gv;\n                float d = length(mp-p);\n                if(d > 0.01){\n                    minDist = min(minDist, dot((p+mp), normalize(p-mp)) );\n                   \n                }\n            }\n        }\n        \n          if (minDist<.07) {minDist = smoothstep(0.7, 1., 1.-minDist)*.2; }\n            vec3 col = minDist*(exp(minDist*2.0))*vec3(1.0, 0.5, 0.0);\n            \n           // col = mix(col, vec3(1.0, 0.0, 0.0), smoothstep(0.07, 0.01, minDist));\n           \n        \n    \n       \n    \n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3tycWt.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 17, 17, 141], [143, 143, 200, 250, 1881]]}
{"id": "3tycWV", "name": "Day 407", "author": "jeyko", "description": "polino", "tags": ["lines", "geometric", "mdtmjvm"], "likes": 18, "viewed": 314, "published": "Public API", "date": "1611749413", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Fork of \"Day 405\" by jeyko. https://shadertoy.com/view/ttVcRt\n// 2021-01-27 11:17:18\n\n\nconst float slices = 350.;\n\nconst float aaSteps = 1.; // not really steps, it's the exponentially ^3 area growing area around the fragCoord \n\nconst float disp = .7;\n\nconst float width = 0.0004;\n\n// asin(sin) is a triangle wave\n#define sin(x) asin(sin(x))\n\nfloat fun(float p, float py){\n    \n    //float f = sin(p + iTime + cos(py*0.05 + sin(p))*0.7)*sin(py*0.1 + iTime*0.2);\n    py *= 170.;\n    \n    py += iTime*2.;\n    float f = abs(sin(p*9. + sin(py*0.2 )*1.));\n    \n    f = pow(max(f,0.001),0.15);\n    \n    //f += (sin(py*0.1 + iTime + sin(p*6. + iTime)))*0.1;\n    f += (sin(py*0.1 + iTime + sin(p*8. + iTime*.1 + sin(py*2.)*0.1)))*0.1;\n    \n    \n    \n    //f = cos(p*0.4- iTime + py)*cos(p*0.4*sin(p) + iTime)*(sin(py + iTime));\n    //f = sin(p*0.5 + sin(py))*(cos(py*0.1 + iTime));\n    /*\n    f *= mix(\n        smoothstep(0.,1.,abs(p + sin(py)*0.1)),\n        smoothstep(0.,1.,abs(p + sin(py*0.3 + iTime)*0.1)),\n        0.5 + sin(iTime*0.4 )*0.5\n        );\n    */\n    return f*disp;\n}\n\n\n\nconst float eps = 0.0004; // eps for derivative of graphing function\n\nfloat graph(float y, float fn0, float fn1, float pixelSize){\n  return smoothstep(pixelSize ,0., \n                    abs(fn0-y)/length(vec2((fn1-fn0)/eps,1.))- width);\n}\nfloat graphNoAbs(float y, float fn0, float fn1, float pixelSize){\n  return smoothstep(pixelSize,0., \n                    -(fn0-y)/length(vec2((fn1-fn0)/eps,1.)) - width);\n}\n\n\nvec3 get(in vec2 fragCoord){\n    vec2 uv = (fragCoord - 0.5*iResolution.xy)/iResolution.y;\n    \n    vec3 col = vec3(0);\n\n    \n    float pixelSize = dFdx(uv.x);\n    \n    for(float i = 0.; i < slices; i++ ){\n        vec2 p = uv + vec2(0.,i/slices*2. - 0.6);\n        \n        //float funIdx = p.x*4. + sin(p.y*i/slices*2. + iTime)*1.5*sin(p.x - iTime);\n        float funIdx = p.x;\n        float funIdxY = i/slices;\n        \n        col -= graphNoAbs( p.y, fun(funIdx,funIdxY), fun(funIdx+eps,funIdxY), pixelSize);\n        col = max(col,0.);\n        col = mix(col, vec3(1), graph( p.y, fun(funIdx,funIdxY), fun(funIdx+eps,funIdxY ), pixelSize ));\n        \n    }\n    \n    \n    col = 1. - col;\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 col = vec3(0);\n    \n    \n    for(float i =0.; i < aaSteps*aaSteps + min(float(iFrame),0.)   ; i++){\n    \tcol += get(fragCoord + vec2(mod(i,aaSteps),floor(i/aaSteps))/aaSteps);\n    }\n    col /= aaSteps*aaSteps;\n    \n    \n    col = max(col, 0.);\n\t//col = pow(col, vec3(0.4545));\n    \n    \n    col = pow(col,vec3(0.4545));\n    \n    fragColor = vec4(col,1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3tycWV.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[285, 346, 375, 464, 1078], [1108, 1152, 1212, 1212, 1321], [1322, 1322, 1387, 1387, 1494], [1497, 1497, 1525, 1525, 2202], [2204, 2204, 2261, 2261, 2628]]}
{"id": "3tycWy", "name": "Genuary 2021 – 01 – Triple Loop", "author": "endymion", "description": "Genuary 2021-01, triple loop", "tags": ["fbm"], "likes": 1, "viewed": 70, "published": "Public", "date": "1611636400", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n#ifdef GL_ES\nprecision mediump float;\n#endif\n\n#define PI 3.14159265359\n\nfloat map(float value, float min1, float max1, float min2, float max2) {\n  return min2 + (value - min1) * (max2 - min2) / (max1 - min1);\n}\n\nfloat random (in vec2 _st) {\n    return fract(sin(dot(_st.xy,\n                         vec2(12.9898,78.233)))*\n        43758.5453123);\n}\n\n/** \n * Noise\n * @src https://gist.github.com/patriciogonzalezvivo/670c22f3966e662d2f83#perlin-noise\n */\n \n// Noise: Random\nfloat rand(vec2 c){\n    return fract(sin(dot(c.xy, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\n// Noise: Basic noise\nfloat noise(vec2 p, float freq){\n    float unit = iResolution.x / freq;\n    vec2 ij = floor(p / unit);\n    vec2 xy = .5 * (1. - cos(PI * mod(p, unit) / unit));\n    float a = rand((ij + vec2(0., 0.)));\n    float b = rand((ij + vec2(1., 0.)));\n    float c = rand((ij + vec2(0., 1.)));\n    float d = rand((ij + vec2(1., 1.)));\n    float x1 = mix(a,b,xy.x);\n    float x2 = mix(c,d,xy.x);\n    return mix(x1,x2,xy.y);\n}\n\n\n/**\n * Fractional Brownian Motion\n * @src https://thebookofshaders.com/13/\n */\nfloat fbm ( in vec2 _st, in int octaves) {\n    float v = 0.0;\n    float a = 0.5;\n    vec2 shift = vec2(100.0);\n    // Rotate to reduce axial bias\n    mat2 rot = mat2(cos(0.5), sin(0.5),\n                    -sin(0.5), cos(0.50));\n    for (int i = 0; i < octaves; ++i) {\n        v += a * noise(_st, 2000. + abs(1000. * sin(iTime * 0.0009)));\n        _st = rot * _st * 2.0 + shift;\n        a *= 0.5;\n    }\n    return v;\n}\n\n/**\n * HSB to RGB\n * @src https://thebookofshaders.com/06/\n */\nvec3 hsb2rgb( in vec3 c ){\n    vec3 rgb = clamp(abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),\n                             6.0)-3.0)-1.0,\n                     0.0,\n                     1.0);\n    rgb = rgb*rgb*(3.0-2.0*rgb);\n    return c.z * mix( vec3(1.0), rgb, c.y);\n}\n\n/** \n * Genuary 01\n * @main\n */\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 st = fragCoord.xy/iResolution.xy*1.;\n    vec3 color = vec3(0.0);\n\n    vec2 r = vec2(0.);\n    r.x = fbm(st  + 0.10, 1);\n\n    float f = fbm(st+r, 10);\n    f = f* 0.5 + fbm(vec2(f *0.5), 2);\n    f = f* 0.5 + fbm(vec2(f *0.5), 2);\n    \n    float t = smoothstep(0., 1., abs(map(fract(iTime * .075), 0., 1., -1., 1.)));\n\n    color = hsb2rgb(mix(vec3(1,1,1),\n                mix(\n                    vec3(0.716,0.725, 0.75 + 0.25 * sin(iTime * 0.1)),\n                    vec3(0.991,0.625, 0.75 + 0.25 * sin(iTime * 0.1)),\n                    t * 0.5 + st.y * 0.5\n                ),\n                clamp((f*f)*4.0,0.0,1.0)));\n\n\n    fragColor = vec4((f*f*f+.3*f*f+.8*f)*color,1.);\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3tycWy.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[73, 73, 145, 145, 211], [213, 213, 241, 241, 349], [458, 475, 494, 494, 566], [568, 590, 622, 622, 1003], [1006, 1085, 1127, 1127, 1503], [1505, 1568, 1594, 1594, 1826], [1828, 1860, 1916, 1916, 2600]]}
{"id": "3tyczc", "name": "Fork Mandelbulb michaelzfr 088", "author": "michaelzfreeman", "description": "FORKED: My first forked edit ! Showing off my edit to allow chroma keying in video editing software once exported to frames. I just edited out two lines @ \"// color sky\" but need to add an actual chroma key colour rather than the default black.\n", "tags": ["3d", "raymarching", "fractal", "distancefield"], "likes": 1, "viewed": 203, "published": "Public API", "date": "1611405581", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Created by inigo quilez - iq/2013\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// The source code for these videos from 2009: \n// https://www.youtube.com/watch?v=eKUh4nkmQbc\n// https://www.youtube.com/watch?v=erS6SKqtXLY\n\n// More info here: http://iquilezles.org/www/articles/mandelbulb/mandelbulb.htm\n\n// See https://www.shadertoy.com/view/MdfGRr to see the Julia counterpart\n\n\n#if HW_PERFORMANCE==0\n#define AA 1\n#else\n#define AA 2  // make AA 1 for slow machines or 3 for fast machines\n#endif\n\nvec2 isphere( in vec4 sph, in vec3 ro, in vec3 rd )\n{\n    vec3 oc = ro - sph.xyz;\n\tfloat b = dot(oc,rd);\n\tfloat c = dot(oc,oc) - sph.w*sph.w;\n    float h = b*b - c;\n    if( h<0.0 ) return vec2(-1.0);\n    h = sqrt( h );\n    return -b + vec2(-h,h);\n}\n\nfloat map( in vec3 p, out vec4 resColor )\n{\n    vec3 w = p;\n    float m = dot(w,w);\n\n    vec4 trap = vec4(abs(w),m);\n\tfloat dz = 1.0;\n    \n    \n\tfor( int i=0; i<4; i++ )\n    {\n#if 0\n        float m2 = m*m;\n        float m4 = m2*m2;\n\t\tdz = 8.0*sqrt(m4*m2*m)*dz + 1.0;\n\n        float x = w.x; float x2 = x*x; float x4 = x2*x2;\n        float y = w.y; float y2 = y*y; float y4 = y2*y2;\n        float z = w.z; float z2 = z*z; float z4 = z2*z2;\n\n        float k3 = x2 + z2;\n        float k2 = inversesqrt( k3*k3*k3*k3*k3*k3*k3 );\n        float k1 = x4 + y4 + z4 - 6.0*y2*z2 - 6.0*x2*y2 + 2.0*z2*x2;\n        float k4 = x2 - y2 + z2;\n\n        w.x = p.x +  64.0*x*y*z*(x2-z2)*k4*(x4-6.0*x2*z2+z4)*k1*k2;\n        w.y = p.y + -16.0*y2*k3*k4*k4 + k1*k1;\n        w.z = p.z +  -8.0*y*k4*(x4*x4 - 28.0*x4*x2*z2 + 70.0*x4*z4 - 28.0*x2*z2*z4 + z4*z4)*k1*k2;\n#else\n        dz = 8.0*pow(sqrt(m),7.0)*dz + 1.0;\n\t\t//dz = 8.0*pow(m,3.5)*dz + 1.0;\n        \n        float r = length(w);\n        float b = 8.0*acos( w.y/r);\n        float a = 8.0*atan( w.x, w.z );\n        w = p + pow(r,8.0) * vec3( sin(b)*sin(a), cos(b), sin(b)*cos(a) );\n#endif        \n        \n        trap = min( trap, vec4(abs(w),m) );\n\n        m = dot(w,w);\n\t\tif( m > 256.0 )\n            break;\n    }\n\n    resColor = vec4(m,trap.yzw);\n\n    return 0.25*log(m)*sqrt(m)/dz;\n}\n\nfloat raycast( in vec3 ro, in vec3 rd, out vec4 rescol, in float px )\n{\n    float res = -1.0;\n\n    // bounding sphere\n    vec2 dis = isphere( vec4(0.0,0.0,0.0,1.25), ro, rd );\n    if( dis.y<0.0 )\n        return -1.0;\n    dis.x = max( dis.x, 0.0 );\n    dis.y = min( dis.y, 10.0 );\n\n    // raymarch fractal distance field\n\tvec4 trap;\n\n\tfloat t = dis.x;\n\tfor( int i=0; i<128; i++  )\n    { \n        vec3 pos = ro + rd*t;\n        float th = 0.25*px*t;\n\t\tfloat h = map( pos, trap );\n\t\tif( t>dis.y || h<th ) break;\n        t += h;\n    }\n    \n    \n    if( t<dis.y )\n    {\n        rescol = trap;\n        res = t;\n    }\n\n    return res;\n}\n\nfloat softshadow( in vec3 ro, in vec3 rd, in float k )\n{\n    float res = 1.0;\n    float t = 0.0;\n    for( int i=0; i<64; i++ )\n    {\n        vec4 kk;\n        float h = map(ro + rd*t, kk);\n        res = min( res, k*h/t );\n        if( res<0.001 ) break;\n        t += clamp( h, 0.01, 0.2 );\n    }\n    return clamp( res, 0.0, 1.0 );\n}\n\nvec3 calcNormal( in vec3 pos, in float t, in float px )\n{\n    vec4 tmp;\n    vec2 e = vec2(1.0,-1.0)*0.5773*0.25*px;\n    return normalize( e.xyy*map( pos + e.xyy,tmp ) + \n\t\t\t\t\t  e.yyx*map( pos + e.yyx,tmp ) + \n\t\t\t\t\t  e.yxy*map( pos + e.yxy,tmp ) + \n\t\t\t\t\t  e.xxx*map( pos + e.xxx,tmp ) );\n}\n\nconst vec3 light1 = vec3(  0.577, 0.577, -0.577 );\nconst vec3 light2 = vec3( -0.707, 0.000,  0.707 );\n\n\nvec3 render( in vec2 p, in mat4 cam )\n{\n\t// ray setup\n    const float fle = 1.5;\n\n    vec2  sp = (2.0*p-iResolution.xy) / iResolution.y;\n    float px = 2.0/(iResolution.y*fle);\n\n    vec3  ro = vec3( cam[0].w, cam[1].w, cam[2].w );\n\tvec3  rd = normalize( (cam*vec4(sp,fle,0.0)).xyz );\n\n    // intersect fractal\n\tvec4 tra;\n    float t = raycast( ro, rd, tra, px );\n    \n\tvec3 col;\n\n    // color sky\n    if( t<0.0 )\n    {\n     \t//col  = vec3(0.8,.9,1.1)*(0.6+0.4*rd.y);\n\t\t//col += 5.0*vec3(0.8,0.7,0.5)*pow( clamp(dot(rd,light1),0.0,1.0), 32.0 );\n\t}\n    // color fractal\n\telse\n\t{\n        // color\n        col = vec3(0.01);\n\t\tcol = mix( col, vec3(0.10,0.20,0.30), clamp(tra.y,0.0,1.0) );\n\t \tcol = mix( col, vec3(0.02,0.10,0.30), clamp(tra.z*tra.z,0.0,1.0) );\n        col = mix( col, vec3(0.30,0.10,0.02), clamp(pow(tra.w,6.0),0.0,1.0) );\n        col *= 0.5;\n\t\t//col = vec3(0.1);\n        \n        // lighting terms\n        vec3 pos = ro + t*rd;\n        vec3 nor = calcNormal( pos, t, px );\n        vec3 hal = normalize( light1-rd);\n        vec3 ref = reflect( rd, nor );\n        float occ = clamp(0.05*log(tra.x),0.0,1.0);\n        float fac = clamp(1.0+dot(rd,nor),0.0,1.0);\n\n        // sun\n        float sha1 = softshadow( pos+0.001*nor, light1, 32.0 );\n        float dif1 = clamp( dot( light1, nor ), 0.0, 1.0 )*sha1;\n        float spe1 = pow( clamp(dot(nor,hal),0.0,1.0), 32.0 )*dif1*(0.04+0.96*pow(clamp(1.0-dot(hal,light1),0.0,1.0),5.0));\n        // bounce\n        float dif2 = clamp( 0.5 + 0.5*dot( light2, nor ), 0.0, 1.0 )*occ;\n        // sky\n        float dif3 = (0.7+0.3*nor.y)*(0.2+0.8*occ);\n        \n\t\tvec3 lin = vec3(0.0); \n\t\t     lin += 7.0*vec3(1.50,1.10,0.70)*dif1;\n\t\t     lin += 4.0*vec3(0.25,0.20,0.15)*dif2;\n        \t lin += 1.5*vec3(0.10,0.20,0.30)*dif3;\n             lin += 2.5*vec3(0.35,0.30,0.25)*(0.05+0.95*occ); // ambient\n        \t lin += 4.0*fac*occ;                          // fake SSS\n\t\tcol *= lin;\n\t\tcol = pow( col, vec3(0.7,0.9,1.0) );                  // fake SSS\n        col += spe1*15.0;\n        //col += 8.0*vec3(0.8,0.9,1.0)*(0.2+0.8*occ)*(0.03+0.97*pow(fac,5.0))*smoothstep(0.0,0.1,ref.y )*softshadow( pos+0.01*nor, ref, 2.0 );\n        //col = vec3(occ*occ);\n    }\n\n    // gamma\n\tcol = sqrt( col );\n    \n    // vignette\n    col *= 1.0 - 0.05*length(sp);\n\n    return col;\n}\n    \nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float time = iTime*.1;\n\n    // camera\n\tfloat di = 1.4+0.1*cos(.29*time);\n\tvec3  ro = di*vec3( cos(.33*time), 0.8*sin(.37*time), sin(.31*time) );\n\tvec3  ta = vec3(0.0,0.1,0.0);\n\tfloat cr = 0.5*cos(0.1*time);\n\n    // camera matrix\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n    vec3 cw = normalize(ta-ro);\n\tvec3 cu = normalize(cross(cw,cp));\n\tvec3 cv =          (cross(cu,cw));\n    mat4 cam = mat4( cu, ro.x, cv, ro.y, cw, ro.z, 0.0, 0.0, 0.0, 1.0 );\n\n    // render\n    #if AA<2\n\tvec3 col = render(  fragCoord, cam );\n    #else\n    #define ZERO (min(iFrame,0))\n    vec3 col = vec3(0.0);\n    for( int j=ZERO; j<AA; j++ )\n    for( int i=ZERO; i<AA; i++ )\n    {\n\t    col += render( fragCoord + (vec2(i,j)/float(AA)), cam );\n    }\n\tcol /= float(AA*AA);\n    #endif\n\n\tfragColor = vec4( col, 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3tyczc.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[349, 542, 595, 595, 790], [792, 792, 835, 835, 2111], [2113, 2113, 2184, 2184, 2741], [2743, 2743, 2799, 2799, 3073], [3075, 3075, 3132, 3132, 3363], [3469, 3469, 3508, 3522, 5774], [5780, 5780, 5837, 5837, 6629]]}
{"id": "3tyyDR", "name": "Line drawing & distance to line", "author": "twenkid", "description": "+ An optical illusion - the faster moving part of the line appears gray due to the motion (on my screen at least).\nhttps://stackoverflow.com/questions/52805523/distance-from-a-line-shadertoy  +\n", "tags": ["line", "distance", "smoothstep"], "likes": 0, "viewed": 104, "published": "Public", "date": "1610748359", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/*\nhttps://stackoverflow.com/questions/52805523/distance-from-a-line-shadertoy\nAuthors: Notaduck, Rabbig76, Twenkid\n#15.1.2021\n*/\n\nfloat dfLine(vec2 O, vec2 dir, vec2 P)\n{\n    vec2 D = normalize(dir);\n    vec2 X = O + D * dot(P-O, D);\n\n    return distance(P, X);\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    uv.x -= 0.5; //Puts the origin at the center of the screen\n\n    float lm = sin(iTime); //slope, 1.1\n    float lb = mix(0.5, 1.0, sin(iTime)); //0.5; //intercept    \n    vec2 P = vec2(uv.x, uv.y);\n    //float dist = dfLine(vec2(0.0, lb), vec2(1.0, lm),  vec2(uv.x,uv.y));\n    float dist = dfLine(vec2(0.0, lb), vec2(1.0, lm),  P);\n    \n    //vec3  color  = dist * vec3(1.0); \n    //float onLine = step(dist, 0.01);   // 1.0 if on line, else 0.0\n    float onLine = 1.0 - smoothstep(0.0, 0.02, dist);   // 1.0 if on line, else 0.0\n  \n    vec3  color  = onLine * vec3(1.0); \n\n    fragColor = vec4(color, 1.0);\n    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3tyyDR.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 131, 171, 171, 264], [268, 268, 325, 325, 982]]}
{"id": "3tyyDw", "name": "hair on screen", "author": "FabriceNeyret2", "description": "reproduce the color effect of hair on an CRT, LCD or OLED screen, due to the correlation in the masking of the color grid.", "tags": ["aliasing", "correlation", "chromophore"], "likes": 4, "viewed": 248, "published": "Public API", "date": "1611092694", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 O, vec2 U )\n{\n    int x = int(U)%3;\n    O = vec4(x==0,x==1,x==2,1);\n    \n    vec2 R = iResolution.xy;\n    O -= smoothstep(1.,0., abs( length(U-.5*R-vec2(sin(iTime),0)*R/20.) - R.y*.4 ) );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3tyyDw.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 38, 38, 214]]}
{"id": "3tyyWm", "name": "Raymarch template GGX", "author": "darkeclipz", "description": "A raymarcher template with a camera, lambertian diffuse, GGX specular, and gamma correction.\n\nThis can be used to quickly create a new raymarching shader :)", "tags": ["raymarch", "camera", "fog", "ggx", "lambertian"], "likes": 4, "viewed": 230, "published": "Public API", "date": "1611101760", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// https://www.iquilezles.org/www/articles/smin/smin.htm\nfloat smin(float a, float b, float k) {\n    float h = max(k-abs(a-b), 0.0)/k;\n    return min(a, b) - h*h*h*k*(1.0/6.0);\n}\n\nfloat sdSphere(in vec3 p, float r) {\n    return length(p) - r;\n}\n\nfloat map(in vec3 p) {\n    // Add your SDF's here: also remove line 87.\n    p = mod(p, 2.0) - 1.; // Domain repetition\n    float sphere = sdSphere(p, 0.4);\n    float ears = sdSphere(abs(p) - vec3(.25, .25, 0), 0.25);\n    return smin(sphere, ears, 0.08);\n}\n\n#define MIN_MARCH_DIST 0.001\n#define MAX_MARCH_DIST 20.\n#define MAX_MARCH_STEPS 60.\nfloat march(in vec3 ro, in vec3 rd) {\n    float t = 0., \n          i = 0.;\n    for(i=0.; i < MAX_MARCH_STEPS; i++) {\n        vec3 p = ro + t*rd;\n        float d = map(p);\n        if(d < MIN_MARCH_DIST)\n            break;\n        t += d;\n        if(t > MAX_MARCH_DIST)\n            break;\n    }\n    if(i >= MAX_MARCH_STEPS) {\n        t = MAX_MARCH_DIST;\n    }\n    return t;\n}\n\nvec3 normal(in vec3 p) {\n    float eps = MIN_MARCH_DIST;\n    vec2 h = vec2(eps, 0);\n    return normalize(vec3(map(p+h.xyy) - map(p-h.xyy),\n                          map(p+h.yxy) - map(p-h.yxy),\n                          map(p+h.yyx) - map(p-h.yyx)));\n}\n\nfloat G1V(float dotNV, float k) {\n    return 1.0 / (dotNV * (1.0 - k) + k);\n}\n\n// http://filmicworlds.com/blog/optimizing-ggx-shaders-with-dotlh/\nfloat brdf_ggx(vec3 N, vec3 V, vec3 L, float roughness, float F0) {\n    float alpha = roughness * roughness;\n    vec3 H = normalize(V+L);\n    float dotNL = clamp(dot(N,L), 0., 1.);\n    float dotNV = clamp(dot(N,V), 0., 1.);\n    float dotNH = clamp(dot(N,H), 0., 1.);\n    float dotLH = clamp(dot(L,H), 0., 1.);\n    float alphaSqr = alpha*alpha;\n    float pi = 3.14159;\n    float denom = dotNH * dotNH * (alphaSqr - 1.0) + 1.0;\n    float D = alphaSqr / (pi * denom * denom);\n    float dotLH5 = pow(1.0 - dotLH, 5.0);\n    float F = F0 + (1.0 - F0) * dotLH5;\n    float k = alpha / 2.0;\n    float vis = G1V(dotNL, k) * G1V(dotNV, k);\n    return dotNL * D * F * vis;\n}\n\nvec3 shade(vec3 N, vec3 L, vec3 V, vec3 diffuse, vec3 specular) {\n    return diffuse * clamp(dot(L, N), 0., 1.)       // Lambertian Diffuse\n         + specular * brdf_ggx(N, V, L, 0.55, 0.1); // GGX Specular\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - 0.5*iResolution.xy)/iResolution.y;\n    \n    // Camera\n    \n    \n    \n    \n    vec3 ro = vec3(0,0,-1.);\n    vec3 ta = vec3(0,0,0);\n    vec3 ww = normalize(ta-ro);\n    vec3 uu = normalize(cross(ww, vec3(0,1,0)));\n    vec3 vv = normalize(cross(uu,ww));\n    vec3 rd = normalize(uv.x*uu + uv.y*vv + 1.0*ww);\n    ro.z += iTime;\n    \n    // March\n    float t = march(ro, rd);\n    \n    // Shade\n    vec3 col = vec3(0);\n    if(t < MAX_MARCH_DIST) {\n        vec3 P = ro + t*rd;                 // Intersection point P.\n        vec3 N = normal(P);                 // Normal to the surface.\n        vec3 L = normalize(vec3(0, 0, -1)); // Vector from P to light source.\n        vec3 V = normalize(ro - P);         // View vector, from P to camera.\n        vec3 ambient = vec3(.05, .05, .08);\n        vec3 diffuse = vec3(.6, .6, .9);\n        vec3 specular = vec3(.8,.8,1.);\n        col = shade(N, normalize(vec3(1, 0, -1)), V, diffuse, specular)  // Light 1\n            + shade(N, normalize(vec3(-5, 2, 1)), V, diffuse, specular)  // Light 2\n            + ambient;                                                   // Ambient light\n        col *= clamp(exp(-0.10*t + 0.4), 0., 1.);                        // Fog\n    }\n    \n    fragColor = vec4(pow(col, vec3(2.2)),1.0); // Gamma correction\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3tyyWm.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 57, 96, 96, 178], [180, 180, 216, 216, 244], [246, 246, 268, 317, 501], [587, 587, 624, 624, 960], [962, 962, 986, 986, 1214], [1216, 1216, 1249, 1249, 1293], [1295, 1362, 1429, 1429, 2024], [2026, 2026, 2091, 2091, 2235], [2237, 2237, 2294, 2294, 3599]]}
{"id": "3tyyWR", "name": "[TWITCH] Wild Heart", "author": "Flopine", "description": "A shader inspired by Sayonara Wild Hearts, an amazing video game I surely recommend :D \nMade during a twitch live, you can see them here: ", "tags": ["2d", "raymarching", "noise", "sound", "fog", "twitch"], "likes": 11, "viewed": 185, "published": "Public", "date": "1610744039", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Code by Flopine\n\n// Thanks to wsmind, leon, XT95, lsdlive, lamogui, \n// Coyhot, Alkama,YX, NuSan and slerpy for teaching me\n\n// Thanks LJ for giving me the spark :3\n\n// Thanks to the Cookie Collective, which build a cozy and safe environment for me \n// and other to sprout :)  https://twitter.com/CookieDemoparty\n\n// Heavily inspired by Sayonara Wild Hearts\n// https://youtu.be/F-RyxYcxSQ4\n\n\n#define PI acos(-1.)\n#define ITER 64.\n\n#define od(p,s) (dot(p,normalize(sign(p)))-s)\n#define mo(p,d)p=abs(p)-d;if(p.y>p.x)p=p.yx\n#define rot(a) mat2(cos(a),sin(a),-sin(a),cos(a))\n#define palette(t,c,d)(vec3(0.5)+vec3(0.5)*cos(2.*PI*(c*t+d)))\n\n#define time iTime\n#define dt(speed) fract(time*speed)\n#define anim (dt(1./3.)*252.)\n\nstruct obj\n{\n  float d;\n  vec3 shadowcol; \n  vec3 lightcol;\n};\n\nobj minobj (obj a, obj b)\n{\n  if (a.d < b.d) return a;\n  else return b;\n}\n\n// taken from YX here : https://www.shadertoy.com/view/tdlXW4\n// rough shadertoy approximation of the bonzomatic noise texture\nvec4 texNoise(vec2 uv)\n{\n    float f = 0.;\n    f += texture(iChannel0, uv*.125).r*.5;\n    f += texture(iChannel0, uv*.25).r*.25;\n    f += texture(iChannel0, uv*.5).r*.125;\n    f += texture(iChannel0, uv*1.).r*.125;\n    f=pow(f,1.2);\n    return vec4(f*.45+.05);\n}\n\nfloat pulseheart (vec2 uv)\n{\n  uv.y -= 0.1;\n  uv.x = -abs(uv.x);\n  uv *= rot(PI/6.+uv.y*0.2);\n  mo(uv,vec2(0.01,0.5));\n\n  return clamp(smoothstep(0.6,0.8,texture(iChannel1,vec2(uv.x,0.025)).r),0.,1.);\n}\n\nfloat box (vec3 p, vec3 c)\n{\n  vec3 q = abs(p)-c;\n  return min(0.,max(q.x,max(q.y,q.z)))+length(max(q,0.));\n}\n\nfloat cyl (vec3 p, float r, float h)\n{return max(length(p.xy)-r,abs(p.z)-h);}\n\nfloat roadwidth = 20.;\nobj asphalt (vec3 p)\n{\n  float ad = box(p,vec3(roadwidth,0.15,1e10));\n  return obj(ad,vec3(0.01,0.01,0.05),vec3(0.01,0.01,0.08)*(1.-abs(p.x*0.04))*2.);\n}\n\nobj roadlines (vec3 p)\n{\n  vec3 pp = p;\n  p.y -= 0.5;\n  p.x = abs(p.x)-roadwidth;\n  float rld = box(p,vec3(1.,0.05,1e10));\n\n  float per = 8.;\n  p.z = mod(p.z,per)-per*0.5;\n  p.x += roadwidth/2.;\n  rld = min(rld,box(p,vec3(.5,0.05,2.5)));\n\n  p.x += roadwidth/2.;\n  rld = min(rld,box(p,vec3(.5,0.05,1.5)));\n\n  return obj(rld, vec3(0.01,0.01,0.04),floor(palette(pp.z,vec3(0.02),vec3(0.,0.37,0.63))*8.)/8.);\n}\n\nobj road (vec3 p)\n{\n  p.y += 0.2;\n  p.y += cos(p.x*0.15);\n  return minobj(asphalt(p),roadlines(p));\n}\n\nobj field (vec3 p)\n{\n  float fd = p.y+3.4+(floor(texNoise(p.xz*0.001).x*25.)/8.)*10.;\n  fd = max(-box(p,vec3(roadwidth*1.5,10.,1e10)),fd);  \n  return obj(fd,vec3(0.1,0.0,0.3),vec3(0.1,0.9,0.9));\n}\n\nfloat poleper = 25.;\nobj poles (vec3 p)\n{\n  p.y -= 5.;\n\n  p.x = abs(p.x)-(roadwidth+1.5);\n  vec3 cp = vec3(abs(p.x)-1.5,p.y+sqrt(abs(sin((p.z+(poleper/2.))*(PI/poleper))*2.)),p.z);\n  float pd = cyl(cp-vec3(0.,8.5,0.),0.15,1e10);\n\n  p.z = mod(p.z,poleper)-poleper*0.5;\n  pd = min(pd,cyl(p.xzy,0.5, 10.));\n  pd = min(pd,cyl(p.yzx-vec3(8.5,0.,0.), 0.2,2.5));\n  return obj(pd,vec3(0.01,0.0,0.02),vec3(0.,0.,0.1)*p.y*0.2);\n}\n\nobj mountains (vec3 p)\n{\n    p.z -= 170.+anim; \n    \n    float sy = 1.8;\n    float sx = 1./sy;\n    vec3 size = vec3(sx,sy,sx);\n    \n    p.y += 10.;\n    float md = od(p*size+vec3(115.,0.,0.),30.);\n    p.x = abs(p.x)-120.;\n    p.xz *= rot(-PI/6.);\n\n    md = min(md,od(p*size,20.));\n    return obj(md/length(size),vec3(0.,0.,0.01),vec3(0.,0.02,0.07));\n}\n\nobj SDF (vec3 p)\n{\n  obj M = mountains(p);\n  \n  p.x += sin(p.z*0.05)*3.;\n  \n  obj scene = road(p);\n  scene = minobj(scene,field(p));\n  scene = minobj(scene,poles(p));\n  scene = minobj(scene,M);\n  \n  return scene;\n}\n\nvec3 getnorm (vec3 p)\n{\n  vec2 eps = vec2(0.01,0.);\n  return normalize(SDF(p).d-vec3(SDF(p-eps.xyy).d,SDF(p-eps.yxy).d,SDF(p-eps.yyx).d));\n}\n\nvec3 getcam (vec3 ro, vec3 tar, vec2 uv)\n{\n  vec3 f = normalize(tar-ro);\n  vec3 l = normalize(cross(vec3(0.,1.,0.),f));\n  vec3 u = normalize(cross(f,l));\n  return normalize(f+l*uv.x + u*uv.y);\n}\n\nfloat point_light (vec3 p, vec3 n, vec3 lpos)\n{\n  vec3 ldir = normalize(lpos-p);\n  float ldist = length(lpos-p);\n  float dotNL = max(dot(n , ldir),0.);\n  return clamp((dotNL) / (0.0004 * ldist * ldist),0.,1.);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2 uv = (2.*fragCoord.xy-iResolution.xy)/iResolution.y;\n  \n  vec2 uu = uv-vec2(0.,0.);\n  uv *= (1.-pulseheart(uu)*0.7);\n  \n  vec3 ro=vec3(1.2,11.,-3.+anim), \n  rd=getcam(ro,vec3(0.,4.,5.+anim),uv), \n  p=ro, \n  col=vec3(0.), \n  l=normalize(vec3(-1.,5.,-5.));\n\n  bool hit=false; \n  float shad;\n  obj O;\n\n  for(float i=0.;i<ITER;i++)\n  {\n    O = SDF(p);\n    if (O.d<0.001)\n    {\n      hit=true;shad=i/ITER;break;\n    }\n    p += O.d*rd;\n  }\n\n  float t = length(ro-p);\n  if (hit)\n  {\n    vec3 n = getnorm(p);\n    float lighting = max(dot(n,l),0.);\n    col = mix(O.shadowcol, O.lightcol, point_light(p,n,vec3(0.,3.,10.+anim))*1.5);\n  }\n  \n  col = mix(col,vec3(0.1,length(uv)*0.2,0.4),1.-exp(-0.00004*t*t));\n  col = mix(col,1.-col,pulseheart(uu));\n\n  fragColor = vec4(sqrt(clamp(col,0.,1.)),1.);\n}", "image_inputs": [{"id": "4dXGzn", "previewfilepath": "/media/ap/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "ctype": "texture"}, {"id": "4tsSR4", "previewfilepath": "https://soundcloud.com/fireball312/sayonara-wild-heart?in=alexandre-gabriel-528632973/sets/sayonara-wild-hearts", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0, "src": "https://soundcloud.com/fireball312/sayonara-wild-heart?in=alexandre-gabriel-528632973/sets/sayonara-wild-hearts", "ctype": "musicstream"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3tyyWR.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[317, 788, 815, 815, 861], [863, 990, 1014, 1014, 1252], [1254, 1254, 1282, 1282, 1456], [1458, 1458, 1486, 1486, 1567], [1569, 1569, 1607, 1607, 1646], [1671, 1671, 1693, 1693, 1824], [1826, 1826, 1850, 1850, 2231], [2233, 2233, 2252, 2252, 2334], [2336, 2336, 2356, 2356, 2532], [2555, 2555, 2575, 2575, 2953], [2955, 2955, 2979, 2979, 3305], [3307, 3307, 3325, 3325, 3521], [3523, 3523, 3546, 3546, 3663], [3665, 3665, 3707, 3707, 3859], [3861, 3861, 3908, 3908, 4072], [4074, 4074, 4131, 4131, 4926]]}
{"id": "3tyyzy", "name": "2D fern fractal", "author": "jarble", "description": "A simple fractal formula.", "tags": ["fractal", "fern"], "likes": 4, "viewed": 165, "published": "Public API", "date": "1611190588", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.0);\n    vec3 col;\n    float t;\n    \n    for(int c=0;c<3;c++){\n\t    vec2 uv = (-fragCoord*5.0-iResolution.xy)/iResolution.y/10.0;\n        uv += vec2(iTime/2.0,iTime/3.0)/8.0;\n        t = iTime+float(c)/10.;\n        float scale = 5.0;\n        float scale1 = 1.5;\n        float scale2 = 2.0;\n        for(int i=0;i<3;i++)\n        {\n            uv=fract(uv/(scale2+fract((uv.x+uv.y)*2.5))-(uv.yx/(scale2+(fract(uv.x+uv.y))))/scale)*scale/1.5+scale1*scale;\n            uv /= scale1;\n        \tuv=uv.yx+col.xy;\n        }\n     col[c] = ((uv.x)-(uv.y));\n\t}\n    \n    fragColor = vec4(vec3(col),1.0);\n    \n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3tyyzy.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 1, 58, 58, 677]]}
{"id": "llfBzX", "name": "Auroras fork_3_audio", "author": "MacroMachines", "description": "Trying to get cheap and fully procedural northern lights effect. Looks better on full screen. Could still be improved...\nexperimenting with audio reactivity, but still unhappy with the way it's playing out.  I want to try choreographing streaks revealing", "tags": ["procedural", "aurora", "atmosphere", "weather"], "likes": 3, "viewed": 253, "published": "Public", "date": "1609705460", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Fork of \"Auroras\" by nimitz. https://shadertoy.com/view/XtGGRt\n// 2017-12-01 23:53:16\n\n//Auroras by nimitz 2017 (twitter: @stormoid)\n\n/*\n\t\n\tThere are two main hurdles I encountered rendering this effect. \n\tFirst, the nature of the texture that needs to be generated to get a believable effect\n\tneeds to be very specific, with large scale band-like structures, small scale non-smooth variations\n\tto create the trail-like effect, a method for animating said texture smoothly and finally doing all\n\tof this cheaply enough to be able to evaluate it several times per fragment/pixel.\n\n\tThe second obstacle is the need to render a large volume while keeping the computational cost low.\n\tSince the effect requires the trails to extend way up in the atmosphere to look good, this means\n\tthat the evaluated volume cannot be as constrained as with cloud effects. My solution was to make\n\tthe sample stride increase polynomially, which works very well as long as the trails are lower opcaity than\n\tthe rest of the effect. Which is always the case for auroras.\n\n\tAfter that, there were some issues with getting the correct emission curves and removing banding at lowered\n\tsample densities, this was fixed by a combination of sample number influenced dithering and slight sample blending.\n\n\tN.B. the base setup is from an old shader and ideally the effect would take an arbitrary ray origin and\n\tdirection. But this was not required for this demo and would be trivial to fix.\n*/\n\n#define time iTime*2.0\n\n#define ss(x,y,z) smoothstep(x,y,z)\n#define fft(x) texture(iChannel0,x)\n\n\nmat2 mm2(in float a){float c = cos(a), s = sin(a);return mat2(c,s,-s,c);}\nmat2 m2 = mat2(0.95534, 0.29552, -0.29552, 0.95534);\nfloat tri(in float x){return clamp(abs(fract(x)-.5),0.01,0.49);}\nvec2 tri2(in vec2 p){return vec2(tri(p.x)+tri(p.y),tri(p.y+tri(p.x)));}\n\nfloat triNoise2d(in vec2 p, float spd){\n    float z=1.8;\n    float z2=2.5;\n\tfloat rz = 0.;\n    p *= mm2(p.x*0.06);\n    vec2 bp = p;\n\tfor (float i=0.; i<5.; i++ )\n\t{\n        vec2 dg = tri2(bp*1.85)*.75;\n        dg *= mm2(time*spd);\n        p -= dg/z2;\n\n        bp *= 1.3;\n        z2 *= .45;\n        z *= .42;\n\t\tp *= 1.21 + (rz-1.0)*.02;\n        \n        rz += tri(p.x+tri(p.y))*z;\n        p*= -m2;\n\t}\n    return clamp(1./pow(rz*29., 1.3),0.,.55);\n}\n\nfloat hash21(in vec2 n){ return fract(sin(dot(n, vec2(12.9898, 4.1414))) * 43758.5453); }\nvec4 aurora(vec3 ro, vec3 rd){\n    vec4 col = vec4(0);\n    vec4 avgCol = vec4(0);\n    \n    for(float i=0.;i<30.;i++)   {\n        float of = 0.021*hash21(gl_FragCoord.xy)*smoothstep(0.,15., i);\n        float pt = ((.8+pow(i,1.54)*.002)-ro.y)/(rd.y*2.+0.4);\n        pt -= of;\n    \tvec3 bpos = ro + pt*rd;\n        vec2 p = bpos.zx;\n        float fft2 = fft(p * vec2(0.20, 0.5) - vec2(0.5)).x;\n        float rzt = triNoise2d(p, 0.1);//*fft2);\n        vec4 col2 = vec4(0, 0, 0, rzt);\n        col2.rgb = (sin(1.-vec3(4.15,-.5, 1.2)+i*0.12843)*0.5+0.5)*rzt;\n        col2.rgb *= fft2 * 3.0;\n        avgCol =  mix(avgCol, col2, .5);\n        col += avgCol*exp2(-i*0.065 - 2.5)*smoothstep(0.,5., i);\n\n    }\n    \n    col *= (clamp(rd.y*10.+.4,0.,1.));\n  \n    //return clamp(pow(col,vec4(1.3))*1.5,0.,1.);\n    //return clamp(pow(col,vec4(1.7))*2.,0.,1.);\n    //return clamp(pow(col,vec4(1.5))*2.5,0.,1.);\n    //return clamp(pow(col,vec4(1.8))*1.5,0.,1.); \n    //return smoothstep(0.,1.1,pow(col,vec4(1.))*1.5);\n    return col*1.8;\n    //return pow(col,vec4(1.))*2.\n}\n\n\n//-------------------Background and Stars--------------------\n//From Dave_Hoskins (https://www.shadertoy.com/view/4djSRW)\nvec3 hash33(vec3 p){\n    p = fract(p * vec3(443.8975,397.2973, 491.1871));\n    p += dot(p.zxy, p.yxz+19.27);\n    return fract(vec3(p.x * p.y, p.z*p.x, p.y*p.z));\n}\nvec3 stars(in vec3 p){\n    vec3 c = vec3(0.);\n    float res = iResolution.x*1.;\n    \n\tfor (float i=0.; i<3.; i++)    {\n        vec3 q  = fract(p*(.15 * res)) -0.5;\n        vec3 id = floor(p*(.15 * res));\n        vec2 rn = hash33(id).xy;\n        float c2 = 1.-smoothstep(0.0, 0.6, length(q));\n        c2 *= step(rn.x,.0005+i*i*0.001);\n        \n        //c2 *= step(rn.x,.0005+i*i*0.001);\n        c += c2*(mix(vec3(1.0,0.09,0.01),vec3(0.075,0.09,1.),rn.y)*0.01+0.69);\n        p *= 1.5;\n    }\n    return c*c*.8;\n}\nvec3 bg(in vec3 rd){\n    float sd = dot(normalize(vec3(-0.5, -0.6, 0.9)), rd)*0.5+0.5;\n    sd = pow(sd, 5.);\n    vec3 col = mix(vec3(0.05,0.1,0.2), vec3(0.1,0.05,0.2), sd);\n    return col*.63;\n}\n//-----------------------------------------------------------\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n\tvec2 q = fragCoord.xy / iResolution.xy;\n    vec2 p = q - 0.5;\n\tp.x*=iResolution.x/iResolution.y;\n    \n    vec3 ro = vec3(0,0,-6.7);\n    vec3 rd = normalize(vec3(p,1.3));\n    vec2 mo = iMouse.xy / iResolution.xy-.5;\n    mo = (mo==vec2(-.5))?mo=vec2(-0.1,0.1):mo;\n\tmo.x *= iResolution.x/iResolution.y;\n    rd.yz *= mm2(mo.y);\n    rd.xz *= mm2(mo.x + sin(time*0.05)*0.2);\n    \n    vec3 col = vec3(0.);\n    vec3 brd = rd;\n    float fade = ss(0.,0.01,abs(brd.y))*0.1+0.9;\n    \n    col = bg(rd)*fade;\n    \n    if (rd.y > 0.){\n        vec4 aur = ss(0.,1.5,aurora(ro,rd))*fade;\n        col += stars(rd)*ss(0.0,0.5,brd.y);\n        col = col*(1.-aur.a) + aur.rgb;\n    }\n\n    else         //Reflections\n    {\n        rd.y = abs(rd.y);\n        col = bg(rd)*fade*0.6;\n        vec4 aur = smoothstep(0.0,2.5,aurora(ro,rd));\n        col += stars(rd)*0.1;\n        col = col*(1.-aur.a) + aur.rgb;\n        vec3 pos = ro + ((0.5-ro.y)/rd.y)*rd;\n        float nz2 = triNoise2d(pos.xz*vec2(.5,.7), 0.);\n        col += mix(vec3(0.2,0.25,0.5)*0.08,vec3(0.3,0.3,0.5)*0.7, nz2*0.4);\n    }\n\n    \n\tfragColor = vec4(col, 1.);\n}\n", "image_inputs": [{"id": "4sjXz1", "previewfilepath": "https://soundcloud.com/sun-room-generator/06-gold-atom-clouds", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0, "src": "https://soundcloud.com/sun-room-generator/06-gold-atom-clouds", "ctype": "musicstream"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/llfBzX.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[137, 1568, 1589, 1589, 1641], [1695, 1695, 1717, 1717, 1759], [1760, 1760, 1781, 1781, 1831], [1833, 1833, 1872, 1872, 2280], [2282, 2282, 2306, 2306, 2371], [2372, 2372, 2402, 2402, 3425], [3428, 3550, 3570, 3570, 3713], [3714, 3714, 3736, 3736, 4224], [4225, 4225, 4245, 4245, 4419], [4420, 4483, 4539, 4539, 5639]]}
{"id": "MdXyz8", "name": "Dedsec Server Room", "author": "Ramocles", "description": "After finally shipping Watch Dogs Legion I wanted to do a little tribute to the old Ubi logo on a hacker style server room. It is becoming a tradition for me to build a shadertoy related to my personal work projects. ( I know it is the old logo :P ) ", "tags": ["procedural", "3d", "raymarching", "distancefield"], "likes": 9, "viewed": 106, "published": "Public", "date": "1611122548", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Created by Ramon Viladomat\n\n#define PI 3.1415\n#define STEP_REDUCTION  0.8\n#define NUM_ITERATIONS  150\n#define NUM_REFLECTIONS 2\n\nvec3 lightDir \t= normalize(vec3(-0.5,2.0,-1.0));\nvec3 lightColor = vec3(1.0);\n\n// MORPHOLOGY\n//--------------------------------------------------------------------------\nfloat hash(vec2 p)\n{\n\treturn fract(sin(dot(p, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\n//--------------------------------------------------------------------------\nfloat smin(float a, float b, float k)\n{\n\treturn log2(exp2(k*a)+exp2(k*b))/k;\n}\n\n//--------------------------------------------------------------------------\nvec2 mapUbi( in vec3 p )\n{  \n    //global mask\n    float mask = max(length(p)-0.96,-p.z);\n    \n    //spheres\n    float cl = abs(length(p)-0.9)-0.06;\n    float c2 = abs(length(p + vec3(0.0,0.105,0.0))-0.37)-0.034;\n    float c3 = abs(length(p + vec3(-0.07 ,0.18,0.0))-0.223)-0.028;\n    float c4 = length(p + vec3(-0.075,0.12,0.0))-0.14;\n\n    //Arc\n    vec2 arcpos = p.xy*vec2(1.0,0.94) + vec2(mix(0.0,-0.1,smoothstep(0.5,-1.0,p.y)),0.0);\n    float arcplus  = length(arcpos + vec2(-0.165,0.08))- 0.61; \n    vec2 arcpos2 = p.xy * vec2(1.0,mix(1.0,0.8,smoothstep(0.0,-0.4,p.y)));\n    float arcminus = length(arcpos2 + vec2(-0.15,0.13))- 0.53;\n\n    float arc = max(arcplus,-arcminus);\n    \n    float logobg = -p.z + 0.1;\n    \n    //mix shapes\n    float dist = min(min(cl,c2),min(c3,c4));\n    dist = min(arc,dist);\n    \n    dist = max(smin(dist,logobg,-50.0),mask);\n    \n    return vec2(dist,0.0);\n}\n\n//--------------------------------------------------------------------------\nvec2 mapLogoBox( in vec3 p)\n{\n   float box     = length(max(abs(p-vec3(0.0,0.0,0.65))-vec3(1.0,1.4,0.5),0.0))-0.2;\n   box           = max(box,-(length(p)-0.96)); //Hole\n   return vec2(box,1.0);\n}\n\n//--------------------------------------------------------------------------\nfloat signedBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\n//--------------------------------------------------------------------------\nvec2 mapServers( in vec3 p)\n{\n    float wall    = -p.z+0.5;       \n    \n    float bottom  = length(max(abs(vec3(p.x,abs(p.y-0.7),p.z)-vec3(0.0,7.0,0.6))-vec3(50.0,3.0,0.5),0.0))-0.05;\n    wall          = min(wall,bottom);\n    \n    vec3 lightpos = p; \n    lightpos.xy   = mod(p.xy,0.3);\n    \n    float light   = length(lightpos-vec3(0.15,0.15,0.5))-0.03;\n    \n    vec2 ret = vec2(wall,1.0); \n    if ( light < wall ) ret = vec2(light,2.0);\n    \n    //Holes\n    vec3 holePos  = p; \n    holePos.x     = mod(holePos.x,5.0);\n    holePos       -= vec3(2.5,0.0,0.0);\n    float hole    = signedBox(holePos,vec3(0.3,10.0,3.0));\n    \n    holePos.x     = abs(holePos.x);    \n    ret.x         = max(ret.x,-hole);\n    \n    float border  = length(max(abs(holePos-vec3(0.3,0.0,10.3))-vec3(0.0,10.0,10.0),0.0))-0.05;\n    \n    if (ret.x > border ) ret = vec2(border,3.0);\n       \n    return ret;\n}\n\n//--------------------------------------------------------------------------\nvec2 mapRoom( in vec3 p )\n{\n    float ret    = p.z+40.0;\n    ret          = min(ret,p.x+22.8);\n    ret          = min(ret,-p.x+22.8);\n    ret          = min(ret,p.y+5.0);\n    ret          = min(ret,-p.y+7.0);   \n    \n    return vec2(ret,1.0);\n}\n\n//--------------------------------------------------------------------------\nvec2 map( in vec3 p )\n{    \n   vec2 ret     = mapUbi(p);\n   vec2 box     = mapLogoBox(p);\n   vec2 servers = mapServers(p);\n   vec2 room    = mapRoom(p);\n    \n   if (ret.x > box.x) ret = box;\n   if (ret.x > servers.x) ret = servers; \n   if (ret.x > room.x) ret = room; \n   return ret;\n}\n\n//--------------------------------------------------------------------------\nvec2 intersect( in vec3 ro, in vec3 rd )\n{\n\tfloat maxd = 100.0;\n\tfloat precis = 0.001;\n    float h=precis*2.0;\n    float t = 0.0;\n    float m = -1.0;\n    for( int i=0; i<NUM_ITERATIONS; i++ )\n    {\n        if( abs(h)<precis||t>maxd ) continue;\n        t += h*STEP_REDUCTION;\n\t    vec2 res = map( ro+rd*t );\n        h = res.x;\n\t    m = res.y;\n    }\n\n    if( t>maxd ) m=-1.0;\n    return vec2( t, m );\n}\n\n// MATERIALS\n//--------------------------------------------------------------------------\nvec4 calcColorUbi( in vec3 pos )\n{\n    vec3 colorBack = vec3(0.2);\n    \n    vec3 colorA = vec3(0.2);\n    vec3 colorB = vec3(0.05,0.05,0.2);\n    vec3 ubicolor = mix(colorA,colorB,clamp(10.0*abs(pos.z),0.0,1.0));\n    ubicolor = mix(colorBack,ubicolor,step(length(pos),0.96));\n\treturn vec4(ubicolor,0.2);\n}\n\n//--------------------------------------------------------------------------\nvec4 calcColorLed( in vec3 pos)\n{\n    vec2 position = vec2(float(int((pos.x+40.0)/0.3)),float(int((pos.y+40.0)/0.3)));\n    float rand = hash(position);\n                       \n    float led = clamp(sin(20.0*(iTime+10.0)*rand),0.0,1.0);\n    \n    float colorChose = rand*4.0; \n    if (colorChose < 2.9) return led*vec4(1.0,0.0,0.0,0.0);\n    if (colorChose < 3.8) return led*vec4(0.1,1.0,0.0,0.0);\n    \n    return led*vec4(0.0,0.0,1.0,0.0);\n}\n\n//--------------------------------------------------------------------------\n\nfloat distToLine( in vec2 pos, in vec2 origin, in vec2 end )\n{\n    vec2 dir     = end - origin;\n    vec2 toPos   = pos - origin; \n    vec2 nDir    = normalize(dir);\n    vec2 projPos = origin+clamp(dot(toPos,nDir),0.0,length(dir))*nDir;\n    return length(pos-projPos);\n}\n\n//--------------------------------------------------------------------------\nfloat wathcdogsDist( in vec2 pos )\n{\n    pos.x = abs(pos.x);\n           \n    vec2 a = vec2(0.0,0.8);\n    vec2 b = vec2(1.0,-1.0);\n    vec2 c = vec2(1.0,1.0);\n    vec2 d = vec2(0.0,-1.4);\n    \n    float dist1 = distToLine(pos,a,b);\n    float dist2 = distToLine(pos,b,c);\n    float dist3 = distToLine(pos,c,d);   \n    \n    return min(dist1,min(dist2,dist3));\n}\n\n//--------------------------------------------------------------------------\nfloat HashNoise( float n )\n{\n\treturn fract(sin(n)*43758.5453);\n}\n\n//--------------------------------------------------------------------------\nfloat Noise( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n\n    f = f*f*(3.0-2.0*f);\n    float n = p.x + p.y*57.0 + 113.0*p.z;\n    return mix(mix(mix( HashNoise(n+  0.0), HashNoise(n+  1.0),f.x),\n                   mix( HashNoise(n+ 57.0), HashNoise(n+ 58.0),f.x),f.y),\n               mix(mix( HashNoise(n+113.0), HashNoise(n+114.0),f.x),\n                   mix( HashNoise(n+170.0), HashNoise(n+171.0),f.x),f.y),f.z);\n}\n\n//--------------------------------------------------------------------------\nfloat Fbm(in vec3 p)\n{\n\tfloat f;\n    f  = 0.5000*Noise( p ); p = p*2.02;\n    f += 0.2500*Noise( p ); p = p*2.03;\n    f += 0.1250*Noise( p ); p = p*2.01;\n    f += 0.0625*Noise( p );\n\treturn f*2.0- 1.0; \n}\n\n//--------------------------------------------------------------------------\nvec4 CalcWallColor( in vec3 pos, in vec3 nor)\n{\n    float groundFactor = 1.0-(clamp(pos.y+5.0,0.0,0.1)*10.0);\n    float midBandFactor = 1.0-(clamp(abs(pos.x),5.0,5.1)-5.0)*10.0;\n       \n    float dist = 1.0-clamp(wathcdogsDist(0.3*pos.xz+vec2(0.0,1.4)),0.0,0.06)*(1.0/0.06);     \n    \n    float dirt = 0.6*(1.0-Fbm(pos*0.2))+0.4;\n    \n    vec4 floor = mix(vec4(vec3(0.0),0.2),vec4(vec3(0.05,0.0,0.0),0.05),dist); \n       \n    vec4 col = mix(vec4(0.05),floor,groundFactor*midBandFactor);\n    \n    return col*dirt;\n}\n\n//--------------------------------------------------------------------------\nvec4 calcColor( in vec3 pos, in vec3 nor, float matID, out vec3 normalmod )\n{\n    normalmod = vec3(0.0);\n    if (matID < 0.5 )  return calcColorUbi(pos);\n    if (matID < 1.5 )  return CalcWallColor(pos, nor);\n    if (matID < 2.5 )  return calcColorLed(pos);\n    else return vec4(0.0,0.0,0.1,0.2);\n}\n\n//--------------------------------------------------------------------------\nvec3 calcNormal( in vec3 pos) \n{\n    vec3 e = vec3(0.0,0.0002,0.0);\n\tfloat d = map(pos).x;\n    return normalize(vec3( map(pos+e.yxx).x-d, map(pos+e.xyx).x-d, map(pos+e.xxy).x-d) );\t\n}\n\n//--------------------------------------------------------------------------\nfloat softShadow( in vec3 ro, in vec3 rd, float mint, float k )\n{\n    float res = 1.0;\n    float t = mint;\n    for( int i=0; i<45; i++ )\n    {\n        float h = map(ro + rd*t).x;\n        res = min( res, k*h/t );\n        t += clamp( h, 0.04, 0.1 );\n    }\n    return clamp(res,0.0,1.0);\n}\n\n//--------------------------------------------------------------------------\n//IQ ray-marched ambient occlusion algorithm \nfloat ambientOcclusion( in vec3 pos, in vec3 nor )\n{\n\tfloat totao = 0.0;\n    float sca = 2.0;\n    for( int aoi=0; aoi<8; aoi++ )\n    {\n        float hr = 0.01 + 1.2*pow(float(aoi)/8.0,1.5);\n        vec3 aopos =  nor * hr + pos;\n        float dd = map( aopos ).x;\n        totao += -(dd-hr)*sca;\n        sca *= 0.85;\n    }\n    return clamp( 1.0 - 0.6*totao, 0.0, 1.0 );\n}\n\n//--------------------------------------------------------------------------\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = -1.0 + 2.0 * fragCoord.xy / iResolution.xy;\n    p.x *= iResolution.x/iResolution.y;\n\n    // camera\n\tvec2 mousePos = iMouse.xy/iResolution.xy;\n\t\n    float defaultCameraAngle = PI*0.88;\n    float defaultCameraDist = 20.0;\n    float inputCamAngle = 3.1415*(1.5-mousePos.x);\n    float inputCamDist = 2.0+((1.0-mousePos.y)*22.0); \n    \n\tfloat camAngle = mix(defaultCameraAngle,inputCamAngle,clamp(iMouse.z,0.0,1.0));\n\tfloat camDist = mix(defaultCameraDist, inputCamDist, clamp(iMouse.z,0.0,1.0));\n\t\n    vec3 camPosition = camDist*normalize(vec3(sin(camAngle), 0.0, cos(camAngle)));\n    vec3 camTarget\t = vec3( 0.0, 0.0, 0.0 );\n    vec3 camFront \t = normalize( camTarget - camPosition );\n    vec3 camRight \t = normalize( cross(camFront,vec3(0.0,1.0,0.0) ) );\n    vec3 camUp \t\t = normalize( cross(camRight,camFront));\n    vec3 rayDir \t = normalize( p.x*camRight + p.y*camUp + 2.0*camFront );\n\n\t// render\n    vec3 color = vec3(0.0);\n\tfloat attenuation = 1.0;\n\tfor( int k=0; k<NUM_REFLECTIONS; k++ )\n\t{\n        // raymarch\n        vec2 tmat = intersect(camPosition,rayDir);\n        if( tmat.y>-0.5 )\n        {\n            // geometry\n            vec3 position \t= camPosition + tmat.x*rayDir;\n            vec3 normal \t= calcNormal(position);\n            vec3 reflDir \t= reflect(rayDir,normal);\n\n            float occlusion = ambientOcclusion(position,normal);\n            \n            // material\n            vec3 normalmod = vec3(0.0);\n            vec4 mate = calcColor( position, normal, tmat.y, normalmod );\n            normal = normalize( normal + normalmod );\n\n            // shading       \n            float ambient  \t\t= 0.7 + 0.3*normal.y;\n\t\t\tvec3 ambientColor   = ambient*mate.rgb;\n\t\t\t\n\t\t\tfloat diffuse = max(dot(lightDir,normal),0.0); \n\t\t\tfloat darkRim = smoothstep(0.0,0.5,max(dot(-rayDir,normal),0.0));\n\t\t\tfloat shadow  = softShadow(position, lightDir, 0.01, 10.0); \n            \n            float specular = pow(clamp(dot(lightDir,reflDir),0.0,1.0),3.0);\n            \n\t\t\tvec3 diffuseColor = darkRim*diffuse*lightColor*mate.rgb;\n\t\t\tvec3 ilumColor = occlusion*shadow*(diffuseColor+pow(specular,30.0)); //TODO ~ remove specular and do it via reflection\n\t\t\t\t\n\t\t\t// mixing lights\n\t\t\tcolor += attenuation*mix(ambientColor,ilumColor,0.6);\n            \n            attenuation *= mate.w;\n            camPosition = position + 0.001*normal;\n            rayDir = reflDir;\n        }\n    \telse\n    \t{\n            color += attenuation*vec3(0.02,0.02,0.05); \n            attenuation = 0.0; \n        }\n\t}\n\t\n\t// desat\n\tcolor = mix( color, vec3(dot(color,vec3(0.33))), 0.3 );\n\t\n    // gamma\n\tcolor = pow( color, vec3(0.45) );\n\n\t// tint\n\tcolor *= vec3(1.0,1.04,1.0);\n\n    fragColor = vec4( color,1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MdXyz8.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[211, 302, 322, 322, 388], [390, 467, 506, 506, 545], [547, 624, 650, 670, 1516], [1518, 1595, 1624, 1624, 1790], [1792, 1869, 1904, 1904, 1991], [1993, 2070, 2099, 2099, 2950], [2952, 3029, 3056, 3056, 3273], [3275, 3352, 3375, 3375, 3637], [3639, 3716, 3758, 3758, 4116], [4118, 4208, 4242, 4242, 4511], [4513, 4590, 4623, 4623, 5029], [5031, 5109, 5171, 5171, 5378], [5380, 5457, 5493, 5493, 5815], [5817, 5894, 5922, 5922, 5958], [5960, 6037, 6063, 6063, 6470], [6472, 6549, 6571, 6571, 6752], [6754, 6831, 6878, 6878, 7345], [7347, 7424, 7501, 7501, 7722], [7724, 7801, 7833, 7833, 7984], [7986, 8063, 8128, 8128, 8349], [8351, 8474, 8526, 8526, 8843], [8845, 8922, 8979, 8979, 11680]]}
{"id": "tdB3Wc", "name": "heart thing", "author": "theepicsnail", "description": "hearts", "tags": ["hearts"], "likes": 2, "viewed": 40, "published": "Public", "date": "1611965381", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define TAU 6.28318530718\n\nvec3 hsv2rgb(vec3 c)\n{\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nfloat sdLine( in vec2 p, in vec2 a, in vec2 b )\n{\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\n\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float scale = 40.;\n    vec3 color = vec3(0);\n    \n    float bands = 3.;\n    \n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord*2.0 - iResolution.xy)/iResolution.y;\n\tuv *= scale;\n    //uv.y += .5;\n    \n    \n    \n    //uv.y -= sin(iTime + uv.x*.1)*4.0;\n    //uv.y=fract(((uv.y + 2.0)/4.0))*4.0-2.0;\n    \n    float x2 = ((uv.x + 2.0)/4.0);\n    \n    float i = floor(x2);\n    \n    uv.y+=sin(i*TAU/bands + iTime*.5 + i*.1)*scale;\n    //uv.y+=floor(sin(i+iTime*.5)*2.)/2.*scale;\n    \n    \n    uv.x=fract(x2)*4.0-2.0;\n    \n    \n    \n    uv.x = abs(uv.x);\n    float d = sdLine(uv, vec2(-1), vec2(.5,.5));\n    \n    //color.r = (1.0-d*20.);\n    \n    \n    d = abs(d-.5);\n    //color.r = fract((1.0-d*5.));\n    \n    //d = abs(d-.4);\n    //color.g = (1.0-d*20.);\n    //d = abs(d-.3);\n    //color.b = (1.0-d*20.);\n    \n    \n   color = hsv2rgb(vec3(fract(d+iTime + i/bands), 1.0, 1.0-d*2.0));\n    \n    \n    //color.r = fract(cos(1.*i*i)+13.3535*i);\n    vec2 coord = fract(uv);\n    d = min(coord.x, coord.y);\n    \n    //color+= clamp((1.0-d*10.),0.,1.);\n    \n    //d = d -.25;\n    //color.g=d;\n    \n    // Output to screen\n    \n    fragColor = vec4(color,0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tdB3Wc.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[27, 27, 49, 49, 218], [220, 220, 269, 269, 388], [393, 393, 450, 450, 1623]]}
{"id": "tdGBDd", "name": "Electric Wind EAS", "author": "public_int_i", "description": "Electric Wind EAS", "tags": ["wind", "electric", "eas"], "likes": 4, "viewed": 160, "published": "Public API", "date": "1609535826", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/*Ethan Alexander Shulman 2020 - xaloez.com\n4k 60fps video https://youtu.be/-gu25BFUaME\n4k wallpaper xaloez.com/art/2020/ElectricWind.jpg*/\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    #define time iTime\n    vec2 uv = (fragCoord*2.-iResolution.xy)/iResolution.y+vec2(0.,.8);\n\tfloat s = 0.;\n\tfor (float l = 30.; l > 1.; l--) {\n\t\tfloat sw = 0., t = l*.1+time;\n\t\tfor (float w = 1.; w < 10.; w++) sw += pow(.5+.5*sin(t*(1.+w*.1)+uv.x*w*w*.9812),w)/w;\n\t\tsw *= .6;\n\t\tfloat v = max(0.,1.-abs(uv.y-sw)*20.)/l;\n\t\ts = mix(s,1.,v);\n\t}\n\tfragColor = vec4(s);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tdGBDd.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 141, 198, 198, 565]]}
{"id": "tdtXzX", "name": "Mandelbrot demo", "author": "camelcoder", "description": "Mandelbrot", "tags": ["mandelbrot"], "likes": 1, "viewed": 58, "published": "Public", "date": "1610797198", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec3 colors[5] = vec3[5](\n    vec3(   0,   7, 100 ) / 256.0,\n    vec3(  32, 107, 203 ) / 256.0,\n    vec3( 237, 255, 255 ) / 256.0,\n    vec3( 255, 170,   0 ) / 256.0,\n    vec3( 106,  53,   3 ) / 256.0\n);\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n\tfragCoord = (2.0 * fragCoord - iResolution.xy ) / iResolution.y;\n\n\n    vec2 pos = fragCoord;\n    vec2 center = vec2(-0.05, 0.68);\n    \n    float tz = 0.85 * (0.85 - cos(0.15 * iTime));\n    float zoom = pow(0.5, 10.0 * tz);\n    \n    \n    vec2 C = vec2(pos * zoom + center);\n    vec2 Z = vec2(0.0, 0.0);\n    int iter = 0;\n    vec2 Zsqr = Z;\n\n    while (Zsqr.x + Zsqr.y <= 4.0 && iter < 600)\n    {\n        Z = vec2(Zsqr.x - Zsqr.y + C.x, 2.0 * Z.x * Z.y + C.y);\n        Zsqr = Z*Z;\n        ++iter;\n    }\n    if (iter < 600) {\n        int idx = int(float(iter) * 5.0 / 125.0);\n        fragColor = vec4(mix(colors[idx%5], colors[(idx+1)%5], float(iter) * 5.0 / 125.0 - float(idx)), 1.0);\n        \n    } else {\n        fragColor = vec4(0, 0, 0, 1);\n    }\n\n}\n\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tdtXzX.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[205, 205, 260, 260, 1013]]}
{"id": "tl3BRr", "name": "Fireworks from a hilltop", "author": "heyitsguay", "description": "Inspired by @The_ArtOfCode (https://twitter.com/the_artofcode).\n\nFull version with more settings: https://heyitsguay.github.io/fireworks", "tags": ["2d", "landscape", "fireworks", "hill"], "likes": 5, "viewed": 93, "published": "Public", "date": "1612086179", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//#version 300 es\n#ifdef GL_FRAGMENT_PRECISION_HIGH\nprecision highp float;\n#else\nprecision mediump float;\n#endif\n\n#define TWOPI 6.28318530718\n\n\n#define T_SPEED 0.2\n#define FIREWORK_SCALE 15.\n#define GRAVITY 0.33\n#define RING_STEP 0.5\n\n#define START_SEED 0.837194\n#define NUM_PARTICLES 200.\n#define SKY_GLOW 2.\n#define FRONT_HILL_GLOW 1.85\n#define BACK_HILL_DENSITY 0.003\n#define BACK_HILL_GLOW 0.6\n#define STAR_GLOW 0.9\n#define CITY_GLOW 0.8\n\n\nstruct Firework {\n  float sparkleScale;\n  float rMin;\n  float rMax;\n  float rPow;\n  float dirYScale;\n  float brightnessScale;\n  float colorShift;\n  float gravityScale;\n  float nPetals;\n  float rRound;\n  float burstRate;\n};\n\nconst Firework fireworks[4] = Firework[4](\n  Firework(0., 0.1, 1., 0., 1., 1., 0., 1., 0., 0., 25.),\n  Firework(1., 0.01, 1., 1., 0.3, 1., 0., 1., 0., 0., 25.),\n  Firework(0.5, 0.3, 0.6, 0., 1., 1., 1., 2., 2., 0., 22.),\n  Firework(1., RING_STEP, 1.5 * RING_STEP, 0., 1., 0.6, 0.5, 0.2, 0., 1., 6.)\n);\n\nconst float iRingStep = 1. / RING_STEP;\n\n//float sigmoid(float x, float c, float m) {\n//  return 1. / (1. + exp(-m*(x-c)));\n//}\n\nfloat sigmoid(float x, float c, float m) {\n  return clamp(0.5 + m * (x - c), 0., 1.);\n}\n\nfloat Hash11(float t) {\n  return fract(sin(t*34.1674));\n}\n\nvec2 Hash12(float t) {\n  return fract(sin(t * vec2(553.2379, 670.3438)));\n}\n\nvec3 Hash13(float t) {\n  return fract(sin(t * vec3(483.9812, 691.3455, 549.7206)));\n}\n\nvec2 RandDirection(float seed, float rMin, float rMax, float rPow, float nPetals, float doRound) {\n  vec3 xyt = Hash13(seed);\n  float rScale = xyt.x * (1. - rPow) + xyt.x * xyt.x * rPow;\n  float r = mix(rMin, rMax, rScale);\n  r = mix(r, float(int(r * iRingStep)) * RING_STEP, doRound);\n  float theta = TWOPI * (xyt.y + xyt.z);\n  r *= mix(1., 1.+ cos(nPetals*theta), nPetals > 0.);\n  return vec2(r*cos(theta), r*sin(theta));\n}\n\nvec3 hsv2rgb(vec3 c) {\n    const vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  vec2 inverseResolution = 1. / iResolution.xy;\n\n  float tt = T_SPEED * 0.8 * iTime;\n  float tCycle = 1. + floor(mod(tt, 99999.));\n  float u = fract(tt);\n\n  float imx = min(inverseResolution.x, inverseResolution.y);\n  vec2 xy = fragCoord.xy * imx;\n  float yMax = iResolution.y * imx;\n\n  float sx = sin(xy.x);\n  float hill1Mask = sigmoid(xy.y, yMax * (0.21 + 0.1 * sx), 150.);\n  float hill2Mask = sigmoid(xy.y, yMax * (0.33 + 0.08 * cos(5.5 * min(xy.x, 0.7))), 50.);\n\n  float yp = fragCoord.y * inverseResolution.y;\n  float dColor = (0.25 + SKY_GLOW * (1. - yp * yp));\n  vec3 color = vec3(0.025*dColor, 0., 0.075*dColor);\n  color *= 0.2 + 0.8*hill2Mask;\n  float hy = Hash11(0.141*fragCoord.y);\n  float starFactor = Hash11(fragCoord.x + 18.2*hy);\n  float starColor = 0.2 + 0.7 * starFactor * starFactor * starFactor;\n  float starFlicker = (0.89 + 0.11 * cos(6. * iTime + 7.9 * hy));\n  color += STAR_GLOW * hill2Mask * starColor * starFlicker * float(fract(31.163*xy.x*(hy+0.1)) < 0.02 && fract(51.853 * xy.y * starColor) < 0.02);\n\n  float dHouse2 = 0.1 + 0.5*float(fract(31.163*xy.x*starColor) + sin(0.0001 * iTime + 51.853 * xy.y * (hy+0.2)));\n  color += max(vec3(0),(1. - hill2Mask) * BACK_HILL_GLOW * min(vec3(1.,1.,1.), vec3(1., 0.7, 0.)* BACK_HILL_DENSITY / dHouse2));\n  vec3 hsf = Hash13(START_SEED + 0.7132 * tCycle);\n  float h = hsf.x;\n  float s = 0.3 + 0.7 * hsf.y;\n  float launchDist = (1. + 2. * hsf.z*hsf.z*hsf.z);\n  float finalScale = launchDist * FIREWORK_SCALE;\n  float launchFactor = (launchDist - 1.) * 0.5;\n\n  vec3 rand1 = Hash13(0.131 * tCycle * 1.674 + START_SEED);\n  vec2 center = vec2(0.2 + 0.6*rand1.x, 0.5-0.133*launchFactor+(0.35-0.1*launchFactor)*rand1.y);\n  vec2 start = vec2(0.3 + 0.4 * rand1.z, 0.);\n\n  if (u < 0.2) {\n    float t = 5. * u;\n    vec2 p = t * center + (1. - t) * start;\n    vec2 uv = finalScale * (fragCoord.xy-p*iResolution.xy) * imx;\n    vec3 cStart = hsv2rgb(vec3(h, 0.5*s, 0.6));\n    float d = length(uv);\n    color += 0.033 * cStart /d;\n\n  } else {\n\n  float t = 1.25 * (u-0.2);\n\n  vec3 rand2 = Hash13(START_SEED + tCycle * 0.1185);\n\n  int idx = int(4. * rand2.x);\n  Firework firework = fireworks[idx];\n\n  vec2 uv = finalScale * (fragCoord.xy-center*iResolution.xy) * imx ;\n\n  float tRamp = min(1., 10. * (1. - t));\n  vec3 cBase = hsv2rgb(vec3(h, s, tRamp));\n\n  float sizeBase = 0.2 + 0.8 * rand2.y;\n\n  float rAddOn = float(idx == 3) * rand2.z * 2.;\n\n  float nPetalsFinal = firework.nPetals + float(firework.nPetals > 0.) * round(3. * rand2.z);\n\n  for (float i = 0.; i < NUM_PARTICLES; i++) {\n\n    float size = sizeBase * mix(1., tRamp * (1.5 + 1.5 * sin(t * i)), firework.sparkleScale);\n\n    vec2 dir = RandDirection(\n      i + fract(0.17835497 * tCycle),\n      firework.rMin,\n      firework.rMax + RING_STEP*rAddOn,\n      firework.rPow,\n      nPetalsFinal,\n      firework.rRound);\n    dir.y *= firework.dirYScale;\n    dir.y -= (1. + firework.gravityScale*t*t*t)*GRAVITY * sizeBase * sizeBase * t;\n\n    float tRate = 0.916291 + log(0.4 + (firework.burstRate + 5. * float(idx == 3) * float(2 - int(rAddOn))) * t);\n\n    float at = abs(t - 0.015);\n    float bump = 0.012 / (1. + 40000. * at*at);\n    float t3 = (t+0.2)*(t+0.2)*(t+0.2);\n    float t6 = t3*t3;\n    float t24 = t6*t6*t6*t6;\n\n    float brightness = sqrt(size)*firework.brightnessScale*0.0013/(1.+ 2. * t24);\n    float hNew = mod(i*0.1618033988, 1.);\n    vec3 cNew = hsv2rgb(vec3(hNew, s, tRamp));\n    vec3 particleColor = mix(cBase, cNew, firework.colorShift);\n    float d = 0.0004 + length(uv - dir * tRate);\n    color += hill1Mask *  (bump + brightness * particleColor) / (d * d);\n  }\n  }\n  color *= 0.75 + 0.25*hill2Mask;\n  color *= hill1Mask;\n\n  //color += (1. - hill1Mask) * 1.5 * vec3(1., 0.8, 0.)*starColor * float(abs(fract(-8.*xy.y) - fract(8.*xy.x*xy.x)) < 0.0002);\n  //float dHouse1 = float(0.01+abs(fract(-8.*xy.y) - fract(8.*xy.x*xy.x)));\n\n//  float dHouse1 = 0.01 + 0.5*float(fract(31.163*xy.x*starColor) + sin(51.853 * xy.y * (hy+0.2)));\n\n//  color += (1. - hill1Mask) * FRONT_HILL_GLOW * min(vec3(1.,1.,1.), vec3(1., 0.7, 0.) * frontHillDensity  / dHouse2);\n//  color += (1. - hill1Mask) * 0.5 * (0.5 - 1.5 * length(xy - vec2(0.5, -0.1))) * vec3(0.1, 0.4, 0);\n  color += (1. - hill1Mask) * FRONT_HILL_GLOW * vec3(0.008, 0.06, 0) * (1. - 4. * yp - 0.3 * sx);\n  color += hill1Mask * CITY_GLOW * max(0., (1. - 3.75 * yp + 0.25 * sx)) * vec3(1., 0.7, 0.);\n\n  fragColor = vec4(color, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tl3BRr.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1012, 1100, 1142, 1142, 1187], [1189, 1189, 1212, 1212, 1246], [1248, 1248, 1270, 1270, 1323], [1325, 1325, 1347, 1347, 1410], [1412, 1412, 1510, 1510, 1837], [1839, 1839, 1861, 1861, 2036], [2039, 2039, 2094, 2094, 6502]]}
{"id": "tl3cD2", "name": "pink zoom spiral ⚙", "author": "HaleyHalcyon", "description": "not spaz but real trippy", "tags": ["hypnotic"], "likes": 1, "viewed": 132, "published": "Public", "date": "1609919256", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const float PI = 3.14159265358979;\nconst vec3 colA = vec3(1.0, 0.7, 0.9);\nconst vec3 colB = vec3(1.0, 0.5, 0.6);\n\n// xor-ish behavior for floats\nfloat flXor(float x, float y) {\n    return x + y - 2. * (x * y);\n}\n\n// folds 0>1>2>3>4... to 0>1<0>1<0...\nfloat fold(float x) {\n    return abs(1. - mod(x, 2.));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Scales pixel coordinates, so that\n    // the center is distance 0 and\n    // diagonals are distance 1\n    vec2 uvR = 2. * fragCoord - iResolution.xy;\n    vec2 uv = uvR / length(iResolution.xy);\n\n    float lenSq = log(length(uv));\n    float lenAdd = -0.2;\n    // logx/dx = 1/x\n    float blur = 6.0 / max(0.1, length(uvR));\n    float angle = atan(uv.y, uv.x) / PI;\n    \n    float timeScale = iTime * PI * 0.125;\n    \n    float spiral1 = smoothstep(0.5 - blur, 0.5 + blur, fold(\n         (lenSq + lenAdd) * (0.8 + 0.5 * cos(timeScale))\n       + angle * 2.\n       - iTime\n    ));\n       \n    float spiral2 = smoothstep(0.5 - blur, 0.5 + blur, fold(\n         (lenSq + lenAdd) * (1.0 + 0.5 * sin(timeScale))\n       - angle * 3.\n       - iTime\n    ));\n\n    // Time varying pixel color\n    vec3 col = mix(colA, colB, vec3(flXor(spiral1, spiral2)));\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tl3cD2.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[114, 145, 176, 176, 211], [213, 251, 272, 272, 307], [309, 309, 366, 475, 1272]]}
{"id": "tl3cRX", "name": "Planetes", "author": "regis", "description": "Planets and water", "tags": ["raymarch", "water", "planetes"], "likes": 1, "viewed": 42, "published": "Public", "date": "1609600936", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define MAX_STEPS 500\n#define MAX_DIST 70.\n#define SURF_DIST .01\n#define EPSILON 0.01\n\nint what = 0;\n\nfloat hash( vec2 p ) {\n\tfloat h = dot(p,vec2(127.1,311.7));\t\n    return fract(sin(h)*43758.5453123);\n}\nfloat noise( in vec2 p ) {\n    vec2 i = floor( p );\n    vec2 f = fract( p );\t\n\tvec2 u = f*f*(3.0-2.0*f);\n    return -1.0+2.0*mix( mix( hash( i + vec2(0.0,0.0) ), \n                     hash( i + vec2(1.0,0.0) ), u.x),\n                mix( hash( i + vec2(0.0,1.0) ), \n                     hash( i + vec2(1.0,1.0) ), u.x), u.y);\n}\n\nfloat GetDistPlan(vec3 p, vec2 uv){\n    vec4 s = vec4(0,3.5, 7, 0.1);\n    \n    float planeDist = dot(p, vec3(0.0, 1.0, 0.0))-sin(p.x+iTime*2.0)*0.2-cos(p.z+iTime)*0.5+sin(p.y*2.0+iTime*2.0)*0.3;\n           \n    vec3 nc = texture(iChannel0, normalize(uv*-iTime*.03) ).rgb;\n    \n    float d = planeDist - length(noise(uv))*1.5 - length(nc.rgb)*0.1;\n    \n    return d;\n\n}\n\nfloat GetDist(vec3 p, vec2 uv){\n    vec4 s = vec4(0,3.5, 7,1.5);\n    vec4 s2 = vec4(4.0,3.5, 10.0,1.5);\n    \n    float planeDist = dot(p, vec3(0.0, 1.0, 0.0))-sin(p.x+iTime)*0.2+cos(p.z+iTime)*0.05;\n    float sphereDist = length(p-s.xyz)-s.w;\n    float sphereDist2 = length(p-s2.xyz)-s2.w;\n    //float sphereDist = CubeApproxSDF(p, 2.0);\n    \n    vec3 nc = texture(iChannel0, uv*2.-iTime*.03).rgb;\n    \n    //float d = min(sphereDist-length(nc), planeDist-length(nc)*0.1);\n    \n     float d = min(sphereDist, sphereDist2);//-length(nc);\n    return d;\n\n}\n\nfloat RayMarch2(vec3 eye, vec3 viewRayDirection,vec2 uv){\n\n    float depth = 0.0, end = 10.0;\n    for (int i = 0; i < MAX_STEPS; i++) {\n        float dist = GetDist(eye + depth * viewRayDirection, uv);\n        if (dist < SURF_DIST) {\n            // We're inside the scene surface!\n            return depth;\n        }\n        // Move along the view ray\n        depth += dist;\n\n        if (depth >= MAX_DIST) {\n            // Gone too far; give up\n            return MAX_DIST;\n        }\n    }\n    return end;\n\n\n}\n\nfloat RayMarchPlan(vec3 eye, vec3 viewRayDirection,vec2 uv){\n\n    float depth = 0.0, end = 10.0;\n    for (int i = 0; i < 100; i++) {\n        float dist = GetDistPlan(eye + depth * viewRayDirection, uv);\n        if (dist < SURF_DIST) {\n            // We're inside the scene surface!\n            return depth;\n        }\n        // Move along the view ray\n        depth += dist;\n\n        if (depth >= MAX_DIST) {\n            // Gone too far; give up\n            return MAX_DIST;\n        }\n    }\n    return end;\n\n\n}\n\nvec3 GetNormal(vec3 p, vec2 uv){\n    float d = GetDist(p, uv);\n    vec2 e = vec2(0.01, 0);\n    \n    vec3 n = d - vec3(\n        GetDist(p-e.xyy, uv),\n        GetDist(p-e.yxy, uv),\n        GetDist(p-e.yyx, uv));\n        \n    return normalize(n);\n}\n\n\n\nfloat GetLight(vec3 p, vec2 uv){\n    vec3 lightpos = vec3(2.0, 5, -6);\n    lightpos.xz += vec2(sin(iTime), cos(iTime));\n    vec3 l = normalize(lightpos-p);\n    \n    \n    vec3 n = GetNormal(p, uv);\n    \n    float dif = clamp(dot(n, l), 0., 1.);\n    float d = RayMarch2(p+n*SURF_DIST, l, uv);\n    if(d < length(lightpos-p))dif *= 0.1;\n    return dif ;\n\n}\n\nvec3 GetNormalPlan(vec3 p, vec2 uv){\n    float d = GetDistPlan(p, uv);\n    vec2 e = vec2(.01, 0);\n    \n    vec3 n = d - vec3(\n        GetDistPlan(p-e.xyy, uv),\n        GetDistPlan(p-e.yxy, uv),\n        GetDistPlan(p-e.yyx, uv)*0.9);\n        \n     \n    vec3 tx = texture(iChannel0, uv+iTime*.23 ).rgb*2.0+1.0;\n    n = n*500.0 -tx ;\n        \n    return normalize(n);\n}\n\nfloat GetLightPlan(vec3 p, vec2 uv){\n    vec3 lightpos = vec3(2.0, 5, -6);\n    lightpos.xz += vec2(sin(iTime), cos(iTime));\n    vec3 l = normalize(lightpos-p);\n    \n    \n    vec3 n = GetNormalPlan(p, uv);\n    \n    float dif = clamp(dot(n, l), 0., 1.);\n    float d = RayMarchPlan(p+n*SURF_DIST, l, uv);\n    if(d < length(lightpos-p))dif *= 0.1;\n    return dif ;\n\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Time varying pixel color\n    vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n    \n     uv -= 0.5;\n     uv /= vec2(iResolution.y / iResolution.x, 1);\n    col = vec3(0.0);\n    \n    vec3 ro, rd, p;\n    float d , dif;\n    \n         \n     float fresnel = clamp(1.0 - dot(vec3(1.0, 1.0, 0.0),-vec3(0.0, 1.0, 0.0)), 0.0, 1.0);\n    fresnel = pow(fresnel,3.0) * 0.5;\n      \n      \n       ro = vec3(0, 2.0, -5.0);\n     rd = normalize(vec3(uv.x, uv.y, 1));\n    \n     d = RayMarch2(ro, rd, uv);\n     p = ro +rd * d;\n\n     dif =GetLight(p, uv);\n        \n           col += vec3(dif)* vec3(0.2, 1.0, 0.5)*texture(iChannel1, uv*2.-iTime*.01).rgb*2.0 -\n           vec3(dif)*vec3(0.0, 1.0, 1.0) + (vec3(173., 79., 9.)/255.) * vec3(dif);\n       \n       /*2*/\n      ro = vec3(0, 4.0, 3.0);\n      rd = normalize(vec3(uv.x, uv.y, 1));\n    \n      d = RayMarchPlan(ro, rd, uv);\n      p = ro +rd * d;\n    \n      dif =GetLightPlan(p, uv);\n     if (( dif <= 0.08) && ( dif > 0.05) ){\n          col +=  vec3(0.0, 0.8, 1.0);\n      }\n     else if (( dif <= 0.05)&& ( dif > 0.01)){\n         col +=  vec3(0.0, 0.75, 1.0);\n      }\n     else if (( dif <= 0.01) && ( dif > 0.005)){\n         col +=  vec3(0.0, .9, 1.0);\n     }\n     else if ( dif <= 0.005){\n         col +=  vec3(0.0, 1.0, 1.0);\n     \n     }else{\n        col += mix(vec3(0.0, 0.8, 1.0), vec3(dif)* vec3(0.0, 1.0, 1.0), smoothstep(0., 1.0, (dif)));\n       \n     }\n     \n     \n  \n       \n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": "4sfGRn", "previewfilepath": "/media/ap/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg", "ctype": "texture"}, {"id": "XsX3Rn", "previewfilepath": "/media/ap/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tl3cRX.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[102, 102, 124, 124, 204], [205, 205, 231, 231, 532], [534, 534, 569, 569, 902], [904, 904, 935, 935, 1457], [1459, 1459, 1516, 1516, 1969], [1971, 1971, 2031, 2031, 2482], [2484, 2484, 2516, 2516, 2729], [2733, 2733, 2765, 2765, 3085], [3087, 3087, 3123, 3123, 3453], [3455, 3455, 3491, 3491, 3818], [3820, 3820, 3877, 3927, 5453]]}
{"id": "tl3fzr", "name": "a rainbow flower", "author": "Hoyong", "description": "just a simple flower thing(?)", "tags": ["2d"], "likes": 1, "viewed": 55, "published": "Public", "date": "1612097548", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define pi 3.14159265358979\n\n//from https://www.shadertoy.com/view/MsS3Wc thanks iq! \\(`v`)/\nvec3 hsv2rgb( in vec3 c )\n{\n    vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n\treturn c.z * mix( vec3(1.0), rgb, c.y);\n}\n\nfloat invLerp(float val, float small, float big){\n    return ( abs(val-small) )/(big-small);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (2.*fragCoord-iResolution.xy)/iResolution.y;\n    uv = vec2(  1.-invLerp(mod(atan(uv.y,uv.x)+pi*.5, 2.*pi),0.,2.*pi), length(uv));\n    \n    float n = 7.;\n    vec2 ax = vec2(1.,1.);\n    uv -= iTime*.75;\n    \n    uv *= mat2(normalize(ax),normalize(vec2(ax.x,-ax.y)));\n    uv = floor(uv*n*length(ax))/n;\n    float base = sin((uv.x-uv.y));\n    fragColor = vec4(hsv2rgb(vec3(base,.6,1.0)),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tl3fzr.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[29, 93, 120, 120, 246], [248, 248, 297, 297, 342], [344, 344, 401, 401, 806]]}
{"id": "tl3yD2", "name": "RayMarch-形状组合计算", "author": "hanker", "description": "Three formulas, combinations between geometries and calculations are tested", "tags": ["raymarch"], "likes": 1, "viewed": 156, "published": "Public API", "date": "1609914568", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define S(a,b,t) smoothstep(a,b,t)\n#define T iTime\n#define MAX_STEP 100\n#define MAX_DIST 100.\n#define SURFACE_DIST .001\nmat2 Rot(float a){\n    float s = sin(a);\n    float c = cos(a);\n    return mat2(c,-s,s,c);\n}\nfloat intersectSDF(float distA,float distB){\n    return max(distA,distB);\n}\n\n\n\nfloat unionSDF(float distA,float distB){\n    return min(distA,distB);\n}\nfloat differenceSDF(float distA,float distB){\n    return max(distA,-distB);\n}\nfloat sdBox(vec3 p,vec3 c,vec3 s){\n    return length(max(abs(c - p) - s,0.));\n}\nfloat sdSphere(vec3 p,vec3 ori,float s){\n    return length(p - ori) - s;\n}\nfloat GetDist(vec3 p){\n    float boxDist = sdBox(p,vec3(0.,0.,0.),vec3(4.));\n    float sphereDistInner = sdSphere(p,vec3(0.,0.,0.),6. * abs(sin(T)));\n    float sphereDist = sdSphere(p,vec3(0.,0.,0.),6. * abs(sin(T)));\n    float d = differenceSDF(boxDist,sphereDistInner);\n    d = intersectSDF(d,sphereDist);\n    return d;\n}\nvec3 GetNormal(vec3 p){\n    float d = GetDist(p);\n    vec2 offset = vec2(.001,0.);\n    return normalize(d - vec3(\n       GetDist(p - offset.xyy),\n       GetDist(p - offset.yxy),\n       GetDist(p - offset.yyx)\n    ));\n}  \nfloat RayMarch(vec3 ro,vec3 rd){\n    float d = 0.;\n    for(int i = 0; i < MAX_STEP; i++){\n        vec3 p = ro + rd * d;\n        float dS = GetDist(p);\n        d += dS;\n        if(d > MAX_DIST || dS < SURFACE_DIST)break;\n    }\n    return d;\n}\nvec3 GetRayDir(vec2 uv,vec3 ro,vec3 look,float z){\n    vec3 forward = normalize(look - ro);\n    vec3 right = normalize(cross(vec3(0.,1.,0.),forward));\n    vec3 top = cross(forward,right);\n    vec3 center = ro + z * forward;\n\n    vec3 i = center + right * uv.x + top * uv.y;\n    vec3 dir = normalize(i - ro);\n\n    return dir;\n}\nvoid mainImage(out vec4 fragColor,in vec2 fragCoord){\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    uv = uv * 2. - 1.;\n    if(iResolution.y > iResolution.x)uv.y *= iResolution.y / iResolution.x;\n    else uv.x *= iResolution.x / iResolution.y;\n\n    vec3 col = vec3(0.);\n    vec3 ro = vec3(8. * sin(T),5.,7.* cos(T));\n\n    vec3 rd = GetRayDir(uv,ro,vec3(0.,0.,0.),1.);\n\n    float d = RayMarch(ro,rd);\n    if(d < MAX_DIST){\n        vec3 p = ro + rd * d;\n        vec3 normal = GetNormal(p);\n        float diffuse = clamp(dot(normal,normalize(vec3(1.,2.,-3.))),0.,1.) * .5 + .5;\n        col += diffuse;\n    }\n    fragColor = vec4(col,1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tl3yD2.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[120, 120, 138, 138, 211], [212, 212, 256, 256, 287], [291, 291, 331, 331, 362], [363, 363, 408, 408, 440], [441, 441, 475, 475, 520], [521, 521, 561, 561, 595], [596, 596, 618, 618, 919], [920, 920, 943, 943, 1138], [1141, 1141, 1173, 1173, 1382], [1383, 1383, 1433, 1433, 1709], [1710, 1710, 1763, 1763, 2348]]}
{"id": "tl3yDj", "name": "Sphere Test 1879", "author": "charlesharvey", "description": "sphere", "tags": ["sphere"], "likes": 2, "viewed": 51, "published": "Public", "date": "1610132763", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n\nfloat sphere_map(in vec3 pos) {\n\n    float t = fract(iTime);\n    float y = 4.0 * t*(1.0-t);\n    // origin of the sphere\n    vec3 cen = vec3(0.0,y,0.0);\n\n    return length(pos-cen)-1.0;\n\n}\n\nfloat map (in vec3 pos) {\n\n\n    float sphere = sphere_map(pos);\n    float plane = pos.y - (-1.0 );\n    \n    float d = min(sphere, plane) ;\n    \n    return d;\n}\n\n\n\nvec3 calcNormal(in vec3 pos) {\n    vec2 e = vec2(0.0001,0.0);\n    return normalize(  vec3( map(pos+e.xyy)-map(pos-e.xyy),\n                             map(pos+e.yxy)-map(pos-e.yxy),\n                             map(pos+e.yyx)-map(pos-e.yyx)));\n\n}\n\n\n\nfloat castRay(in vec3 ro, vec3 rd) {\nfloat t = 0.0;\n for(int i=0;i<100;i++) {\n        vec3 pos = ro + t*rd;\n        float h = map(pos);\n        \n        if (h < 0.001) {\n            break;\n        }\n        t += h;\n        if (t > 20.0) {\n            break;\n        }\n        \n       \n     }\n     \n     if (t>20.0) t = -1.0;\n     return t;\n\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 p = (2.0 * fragCoord -iResolution.xy)/iResolution.y;\n\n\n    vec3 ro = vec3(.0,0.5, 3.0);\n    vec3 rd = normalize(vec3(p,-1.5));\n\n \n     // sky color \n     vec3 sky_col = vec3(0.5,0.7,0.9);\n     \n     // sky color by default;\n     vec3 col = sky_col - 0.5*rd.y;\n     \n     // ray marching\n     float t = castRay(ro,rd);\n    \n    \n    \n     if ( t>0.0 ) {\n     \n         float theta = sin(iTime) / 10.0;\n\n         vec3 sun_dir   =  normalize(vec3(theta + 0.7,0.4,0.2));\n         vec3 sky_dir = vec3(0.0,1.0,0.0);\n         vec3 bounce_dir = vec3(0.0,-1.0,0.0);\n\n  \n         vec3 pos = ro + t*rd;\n         vec3 nor = calcNormal(pos);\n         \n         \n         // normal material\n         vec3 mate = vec3(0.18);\n         \n         // diffuse color from sun\n         float sun_dif = clamp(dot(nor,sun_dir),0.0,1.0);\n         col  = mate*vec3(7.0,5.0,3.0) * sun_dif;\n         \n         // sun shadow\n         float sun_sha = step(castRay(pos+nor*0.001, sun_dir),0.0);\n         col *= sun_sha;\n         \n         // diffuse color from sky\n         float sky_dif = clamp(0.5 + 0.5*dot(nor,sky_dir),0.0,1.0);\n         col +=  mate*0.5 *  sky_col * sky_dif;\n         \n        \n        // bounce light from other materials back to itself\n        float bou_dif =  clamp(0.5 + 0.5*dot(nor,bounce_dir),0.0,1.0);\n        col +=  mate* vec3(0.7,0.3,0.2) * bou_dif;\n             \n         \n    }\n \n \n \n // color correct \n col = pow(col, vec3(0.4545));\n \n \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}\n\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tl3yDj.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[2, 2, 33, 33, 189], [191, 191, 216, 216, 350], [354, 354, 384, 384, 600], [604, 604, 640, 640, 946], [948, 948, 1005, 1055, 2562]]}
{"id": "tl3yRs", "name": "Circles in circles", "author": "Exnonull", "description": "Many circles in other circles", "tags": ["2d", "circles"], "likes": 3, "viewed": 45, "published": "Public", "date": "1609700984", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define display iResolution\n\n#define offsetX 0.\n#define offsetY 0.\n#define speed .05\n#define scale 1.\n\n//border radius or smth like that\n#define BR_X 1.\n#define BR_Y 1.\n\nfloat step = .0;\nvoid mainImage( out vec4 fragColor, in vec2 pos )\n{\n    vec3 clr = vec3(1,1,1);\n    \n    step = .3 + iTime * speed;//you can disable shrinking (try set 1. or 2.)\n    \n    float distX = pow((display.x/2. + offsetX - pos.x) / scale, 2. *BR_X);\n    float distY = pow((display.y/2. - offsetY - pos.y) / scale, 2. *BR_Y);\n    \n    clr.r = cos(pow(distX + distY, 1. *step) + iTime * 10.);\n    clr.g = cos(pow(distX + distY, 1. *step) + iTime * 10.);\n    clr.b = 1.;\n    \n    fragColor = vec4(clr,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tl3yRs.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[103, 187, 238, 238, 684]]}
{"id": "tlcBRn", "name": "Neural Shrek Head", "author": "michael0884", "description": "thanks: https://youtu.be/8pwXpfi-0bU", "tags": ["bunny"], "likes": 11, "viewed": 332, "published": "Public API", "date": "1612067965", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//CC0 1.0 Universal https://creativecommons.org/publicdomain/zero/1.0/\n//To the extent possible under law, Blackle Mori has waived all copyright and related or neighboring rights to this work.\n\n//like the last few shaders I've published, this is a neural network experiment.\n//this time, the neural network reproduces an SDF given the x,y,z coordinates\n//using siren networks with skip connections: https://vsitzmann.github.io/siren/\n\nvec3 erot(vec3 p, vec3 ax, float ro) {\n    return mix(dot(p,ax)*ax,p,cos(ro))+sin(ro)*cross(ax,p);\n}\n\nfloat scene(vec3 p) {\n    //sdf is undefined outside the unit sphere, uncomment to witness the abominations\n    if (length(p) > 1.) {\n        return length(p)-.8;\n    }\n    //neural networks can be really compact... when they want to be\n    //loss 0.000032\nvec4 f0_0=sin(p.y*vec4(1.614,-.384,3.461,-1.449)+p.z*vec4(-1.740,-3.099,1.257,-4.194)+p.x*vec4(1.423,-.731,3.950,2.749)+vec4(8.860,-6.088,-1.444,-.854));\nvec4 f0_1=sin(p.y*vec4(-.614,4.579,-2.415,-.228)+p.z*vec4(-3.400,.411,2.157,5.092)+p.x*vec4(-.270,-3.123,3.553,-2.081)+vec4(-4.280,7.037,6.676,-4.043));\nvec4 f0_2=sin(p.y*vec4(-2.214,-1.697,-2.458,4.407)+p.z*vec4(-.505,-.133,1.820,-1.197)+p.x*vec4(.871,-2.552,-1.096,2.168)+vec4(-4.484,.480,4.456,6.656));\nvec4 f0_3=sin(p.y*vec4(-.262,-2.127,-1.644,2.066)+p.z*vec4(.936,-1.286,-2.796,-1.724)+p.x*vec4(-2.576,-3.029,3.619,-2.664)+vec4(-2.128,-1.856,.912,-4.219));\nvec4 f1_0=sin(mat4(-.175,-.141,-.181,.472,.489,.042,.178,.065,-.133,-.601,.384,.606,.263,-.225,.024,.052)*f0_0+\n    mat4(.098,-.435,.407,.053,.141,.108,.168,.313,-.374,.313,-.633,-.237,.296,-.092,.360,-.109)*f0_1+\n    mat4(-.176,-.664,.937,.178,-.583,-.178,-.535,.900,-.029,.356,-.298,.286,-.024,-.326,-.247,-.266)*f0_2+\n    mat4(-.835,.224,-.646,.308,-.166,.522,-.570,-.073,.047,-.005,-.242,-.191,.909,-.777,.278,.586)*f0_3+\n    vec4(-.176,2.932,2.633,-2.581))/1.0+f0_0;\nvec4 f1_1=sin(mat4(.749,-.599,.060,.201,-.584,-.380,-.259,-.265,-.113,-.045,-.065,.320,-.000,-.157,-.369,-.111)*f0_0+\n    mat4(-.400,.668,1.048,.477,.226,-.053,.362,.106,.470,-.557,.278,-.050,-.536,.537,.612,.275)*f0_1+\n    mat4(.685,.667,.474,-.149,.817,.178,.281,-.997,.225,-.281,-.254,-.012,.430,-.658,-.169,-.168)*f0_2+\n    mat4(-.089,-.062,.411,-.270,.016,-.351,.504,-.621,-.372,-.099,.459,-.068,-.388,.787,.695,.653)*f0_3+\n    vec4(.874,2.704,2.734,2.805))/1.0+f0_1;\nvec4 f1_2=sin(mat4(-.333,.630,-.095,-.111,.342,-.102,1.435,-.043,.302,-.710,-.089,-.692,.067,-.047,.046,-.422)*f0_0+\n    mat4(-.534,1.033,.178,-.453,.696,-.087,.148,.130,-.115,.143,-.336,-.327,-.102,-.410,.370,.048)*f0_1+\n    mat4(-.007,-.061,.888,-.374,-.059,-.973,.430,.050,-.113,-.428,-.590,-.414,-.198,-.424,.016,.285)*f0_2+\n    mat4(-.424,.566,.485,-.124,.416,.015,-.159,.513,-.429,.508,-.177,.190,-.571,.348,.324,-.368)*f0_3+\n    vec4(-.466,2.862,1.568,-2.639))/1.0+f0_2;\nvec4 f1_3=sin(mat4(-.026,-.149,-.096,-.071,.120,-.360,-1.019,-.550,-.089,-.020,.527,-.275,-.345,.112,-.160,-.434)*f0_0+\n    mat4(-.155,-.337,.294,-.055,.492,-.659,.231,.273,-.218,.718,.127,.420,-.238,-.451,.167,.370)*f0_1+\n    mat4(-.100,.416,-.164,-.078,.739,.003,-.123,-.696,-.125,.202,-.117,-.863,.344,-.077,-.164,-.210)*f0_2+\n    mat4(.194,-.275,-.282,-.496,.212,-.590,.201,-.477,-.228,-.461,-.468,.123,.167,-.749,.085,-.343)*f0_3+\n    vec4(-1.475,1.966,-.599,1.170))/1.0+f0_3;\nvec4 f2_0=sin(mat4(1.080,.872,.711,.104,-.660,-.142,.339,.249,-.538,.418,-.618,-.306,-.245,-.175,.919,.010)*f1_0+\n    mat4(.106,.512,.018,.883,-.682,-.317,-.718,.475,.948,.038,.574,-.350,.023,.970,-.766,-.102)*f1_1+\n    mat4(-.030,.754,.336,.579,.234,-.428,.030,.166,-.002,.211,.055,.803,.260,.031,-.520,.381)*f1_2+\n    mat4(1.245,.856,.354,.121,.430,.305,.790,.595,.811,-.195,-.067,-.106,-1.421,-.204,-.224,.791)*f1_3+\n    vec4(.633,2.190,2.576,2.018))/1.4+f1_0;\nvec4 f2_1=sin(mat4(-.996,.390,-.566,-.109,.387,1.037,-.638,.502,.281,-1.178,-.828,.312,.283,-.481,-.210,.117)*f1_0+\n    mat4(-.602,-1.130,.273,-.236,.057,.597,-.631,.156,-.654,.380,.573,-.101,-.234,.068,-1.024,.173)*f1_1+\n    mat4(-.701,-.500,-.727,-.173,.118,.611,.552,-.199,.059,.022,.418,.257,-.545,-.647,.448,-.700)*f1_2+\n    mat4(-.117,.682,.589,-.177,.646,-.025,.158,.017,-.317,.787,1.245,-.632,.519,-.488,-1.065,-.338)*f1_3+\n    vec4(1.238,2.124,-.652,1.610))/1.4+f1_1;\nvec4 f2_2=sin(mat4(-.041,.230,-.114,-1.108,.284,.695,.812,.578,1.379,-.228,-.261,-.672,-1.183,.124,-.086,-.331)*f1_0+\n    mat4(.336,.228,-.854,.183,.180,.017,.893,.442,-.643,.418,-.519,.101,1.136,.074,.436,.166)*f1_1+\n    mat4(.056,-.419,-.569,-.230,-1.501,.016,.276,-.461,.651,.871,.042,.257,-.036,.253,-.484,-.337)*f1_2+\n    mat4(.759,-.194,.608,-1.026,-1.631,.967,-.322,.307,.793,-.334,.523,.013,.792,-.088,-.167,.215)*f1_3+\n    vec4(-.405,2.659,-1.339,3.678))/1.4+f1_2;\nvec4 f2_3=sin(mat4(-.339,1.039,.044,.203,.042,-.744,.374,-1.190,.583,.152,-.218,-.236,.024,.066,-.172,.659)*f1_0+\n    mat4(.220,-.253,1.000,-.678,.038,-.133,-.593,-.444,-.459,-.264,.763,.378,-.388,.042,-.395,-.742)*f1_1+\n    mat4(.392,.475,.196,-.626,.014,.124,-.313,.056,-.065,-.452,.111,-.250,-.420,.529,-.215,1.039)*f1_2+\n    mat4(-.607,-.029,.254,.600,.523,.250,-.227,.773,.091,-.398,.193,-.483,.781,.248,-.055,.150)*f1_3+\n    vec4(-1.623,-2.998,-.552,-3.926))/1.4+f1_3;\nreturn dot(f2_0,vec4(-.054,-.051,.066,.043))+\n    dot(f2_1,vec4(.045,.041,.025,.086))+\n    dot(f2_2,vec4(.011,-.046,.074,-.094))+\n    dot(f2_3,vec4(-.053,.089,-.084,.041))+\n    0.077;\n}\n\nvec3 norm(vec3 p) {\n    mat3 k = mat3(p,p,p)-mat3(0.001);\n    return normalize(scene(p) - vec3(scene(k[0]),scene(k[1]),scene(k[2])));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-0.5*iResolution.xy)/iResolution.y;\n    vec2 mouse = (iMouse.xy-0.5*iResolution.xy)/iResolution.y;\n\n    vec3 cam = normalize(vec3(1.5,uv));\n    vec3 init = vec3(-2.,0,0);\n    \n    float yrot = 0.;\n    float zrot = 3. + iTime*.2;\n    if (iMouse.z > 0.) {\n        yrot += -4.*mouse.y;\n        zrot = 3. + 4.*mouse.x;\n    }\n    cam = erot(cam, vec3(0,1,0), yrot);\n    init = erot(init, vec3(0,1,0), yrot);\n    cam = erot(cam, vec3(0,0,1), zrot);\n    init = erot(init, vec3(0,0,1), zrot);\n    \n    vec3 p = init;\n    bool hit = false;\n    for (int i = 0; i < 150 && !hit; i++) {\n        float dist = scene(p);\n        hit = dist*dist < 1e-6;\n        p+=dist*cam;\n        if (distance(p,init)>5.) break;\n    }\n    vec3 n = norm(p);\n    vec3 r = reflect(cam,n);\n    //don't ask how I stumbled on this texture\n    vec3 nz = p - erot(p, vec3(1), 2.) + erot(p, vec3(1), 4.);\n    float spec = length(sin(r*3.5+sin(nz*120.)*.15)*.4+.6)/sqrt(3.);\n    spec *= smoothstep(-.3,.2,scene(p+r*.2));\n    vec3 col = vec3(0.478,1.000,0.478)*spec + pow(spec,8.);\n    float bgdot = length(sin(cam*8.)*.4+.6)/2.;\n    vec3 bg = vec3(.1,.1,.11) * bgdot + pow(bgdot, 10.);\n    fragColor.xyz = hit ? col : bg;\n    fragColor = smoothstep(-.02,1.05,sqrt(fragColor)) * (1.- dot(uv,uv)*.5);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tlcBRn.jpg", "access": "shaders20k", "license": "cc0-1.0", "functions": [[194, 435, 473, 473, 535], [537, 537, 558, 644, 5391], [5393, 5393, 5412, 5412, 5528], [5530, 5530, 5587, 5587, 6872]]}
{"id": "tlcBRr", "name": "Neural Teddy Bear - Yes!", "author": "oneshade", "description": "Well this one worked quite well :)", "tags": ["3d", "raymarching", "sdf", "teddybear", "ai", "neuralnetwork", "siren"], "likes": 4, "viewed": 98, "published": "Public", "date": "1612086805", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/*\nAnother test of blackle's mesh to SDF siren network notebook.\nMesh source: https://groups.csail.mit.edu/graphics/classes/6.837/F03/models/teddy.obj\n\nThe siren network liked this one better (it even made it smoother!) :)\n\nI also optimized by analytically doing an intersection test with the model's bounding\nsphere to avoid running the neural network too many times.\n\nHere's my copy of the notebook:\nhttps://colab.research.google.com/drive/1zdP-LymbnhIzhxOEdZx39C0GBr4AzbFU?authuser=1#scrollTo=O2uKIwI5chcp\n*/\n\n// ?!?\n//#define SPIKY\n\nvec3 IntersectSphere(in vec3 ro, in vec3 rd, in float r) {\n    float a = dot(rd, rd);\n    float b = dot(2.0 * ro, rd);\n    float c = dot(ro, ro) - r * r;\n\n    vec3 intersect = vec3(0.0);\n\n    float discr = b * b - 4.0 * a * c;\n    if (discr > 0.0) {\n        float root = sqrt(discr);\n        float denom = 2.0 * a;\n        float t1 =  (root - b) / denom; // 1st root\n        float t2 = -(root + b) / denom; // 2nd root\n        intersect = vec3(t1, t2, 1.0);\n    }\n\n    return intersect;\n}\n\nfloat sdTeddyBear(in vec3 p) {\n    if (length(p) > 1.2) return length(p) - 1.0;\n    p = vec3(p.z, p.x, p.y);\n    vec4 f0_0=sin(p.y*vec4(-3.54,.16,-3.85,-3.46)+p.z*vec4(-4.11,1.46,3.18,-1.08)+p.x*vec4(.87,2.37,2.00,-.06)+vec4(-4.84,6.35,4.67,1.28));\n    vec4 f0_1=sin(p.y*vec4(-.79,-2.43,1.17,.08)+p.z*vec4(2.96,4.06,-.50,2.33)+p.x*vec4(2.18,1.64,-3.70,-2.06)+vec4(2.49,-2.94,-1.55,-4.40));\n    vec4 f0_2=sin(p.y*vec4(-2.82,-1.15,-1.02,-2.78)+p.z*vec4(.61,-2.66,-1.37,2.07)+p.x*vec4(-3.03,1.62,-2.73,2.17)+vec4(1.85,6.48,2.10,-8.41));\n    vec4 f0_3=sin(p.y*vec4(1.13,-1.73,.30,-.71)+p.z*vec4(2.68,3.20,-3.55,3.69)+p.x*vec4(-2.77,.68,3.42,-2.48)+vec4(2.86,-.73,-.16,-2.31));\n    vec4 f1_0=sin(mat4(.71,.16,.40,-.11,-.07,-.53,-.52,-.30,.39,.16,.25,-.29,-.38,-.15,-.24,.24)*f0_0+\n        mat4(-1.10,-.65,.12,-.36,-.03,-.40,-.34,.64,.18,.11,.13,.68,1.15,.81,.17,.01)*f0_1+\n        mat4(.25,.05,.65,-.42,-.81,.22,-.35,.55,.45,-.11,-.42,.25,-.77,.68,.13,.18)*f0_2+\n        mat4(.77,-.04,-.00,-.32,-.56,-.92,-.23,-.20,-.78,.24,-.69,-.19,.94,.18,.51,.51)*f0_3+\n        vec4(-2.07,-2.21,-2.80,1.04))/1.0+f0_0;\n    vec4 f1_1=sin(mat4(.39,.31,.25,.08,.52,-.71,.79,1.11,.16,.16,-.58,.04,.73,.24,.42,-.43)*f0_0+\n        mat4(.52,.25,-.04,.49,-.22,.75,-.06,-.03,.16,-.11,-.13,-.07,.42,.21,-.31,.54)*f0_1+\n        mat4(.33,-.33,-.62,-.35,.02,.31,.29,.30,.35,-.26,.20,-1.30,.31,.07,1.34,.07)*f0_2+\n        mat4(-.04,.22,-.42,-.32,-.03,.40,.30,.07,.25,-.47,-.02,.62,-.09,1.04,-.28,-.46)*f0_3+\n        vec4(2.91,-3.76,-.66,2.25))/1.0+f0_1;\n    vec4 f1_2=sin(mat4(-.05,.69,.54,.50,1.04,-.74,-.04,-.61,-.24,-.46,-.08,-.04,.41,.24,.43,.69)*f0_0+\n        mat4(-.04,.07,-.14,-.04,.47,.84,.41,-.45,.09,.11,-.10,.20,.10,-.26,-.15,.86)*f0_1+\n        mat4(.70,1.12,.49,.18,-.25,1.15,.54,-.11,-.77,-.40,.76,.56,.38,-.47,-.92,.27)*f0_2+\n        mat4(-.25,-.72,-.11,-.33,1.01,.68,.08,-.76,-.19,.45,-.31,-.48,.31,-.21,.05,.66)*f0_3+\n        vec4(-2.16,.49,-2.85,-1.92))/1.0+f0_2;\n    vec4 f1_3=sin(mat4(.55,.17,.17,.47,-.46,.91,.81,1.00,.08,.30,.28,.01,-.31,-.58,.39,-.31)*f0_0+\n        mat4(.58,.46,-.13,.75,-.17,-.14,-.21,-.19,-.11,.37,.47,.35,.77,-.42,.11,.01)*f0_1+\n        mat4(-.50,.03,-.61,.79,.04,-.54,.39,-.45,.69,-.43,-.04,-1.36,-.06,-.00,.08,1.19)*f0_2+\n        mat4(-.55,.87,-.21,.29,-.26,-.10,.02,.71,-.28,-.47,.62,-.24,.21,.14,-1.35,-.25)*f0_3+\n        vec4(.41,.31,1.27,3.67))/1.0+f0_3;\n    vec4 f2_0=sin(mat4(.05,-.62,.18,.13,1.28,-.06,-.32,.05,1.17,-.09,.00,1.21,-.92,1.33,-1.33,.75)*f1_0+\n        mat4(2.55,.44,-1.25,.31,-.87,-.11,.27,-1.17,.81,.29,.68,.73,.73,.02,-.16,.51)*f1_1+\n        mat4(.56,-.56,-.05,1.78,1.40,.15,-.90,-.86,.02,.91,.66,.14,.81,-1.19,-.74,.50)*f1_2+\n        mat4(.88,.59,-.45,.10,.05,.00,-.94,.24,.49,-.29,-.50,.75,-.22,-.25,.40,-.03)*f1_3+\n        vec4(-.41,-2.09,2.22,-.79))/1.4+f1_0;\n    vec4 f2_1=sin(mat4(.06,.37,.57,-.46,.47,.97,-.03,.98,-.30,-.73,.13,-.62,-.38,-.49,.23,-.11)*f1_0+\n        mat4(-.59,.02,-.25,.32,-.50,.80,-.38,.40,.06,.09,-.74,.05,-1.98,-.87,-.49,-.25)*f1_1+\n        mat4(.86,-.97,.09,.09,-.91,.05,1.04,-.09,.01,-1.03,.10,-.10,1.25,1.01,-.79,.27)*f1_2+\n        mat4(-.06,-.11,-.10,-.32,-.25,-.58,-.30,1.49,-.72,.10,-.50,-1.04,.22,.31,-.44,.38)*f1_3+\n        vec4(2.22,1.33,-3.42,.01))/1.4+f1_1;\n    vec4 f2_2=sin(mat4(-.67,-.19,-.86,.11,-.73,-.33,.89,.59,-.28,-.15,-.72,-.18,.39,1.06,.28,.65)*f1_0+\n        mat4(.16,.20,.41,-.03,.18,.20,-.10,-.05,-.33,-1.03,-.06,-.94,.35,.18,.54,.32)*f1_1+\n        mat4(-.07,-.11,.32,.26,.13,-.48,-.74,.97,-.84,.19,.74,.91,-.15,.07,.34,-.09)*f1_2+\n        mat4(.02,.33,.90,-.43,-.35,.97,1.09,-.03,.87,-.29,-.26,.11,-.36,.65,.71,.05)*f1_3+\n        vec4(2.32,1.86,2.46,-.34))/1.4+f1_2;\n    vec4 f2_3=sin(mat4(-.16,.74,.45,.23,-.68,-.06,-.63,1.13,.09,.48,.42,-1.22,.08,.13,.64,.55)*f1_0+\n        mat4(.36,.41,.50,.01,.42,-.13,-.86,-.88,-.43,-.22,-.77,-.18,1.05,.25,.87,-1.13)*f1_1+\n        mat4(.11,-.18,.34,.54,-.53,.63,-.11,-.55,-.41,.78,-.46,-.41,.23,-.31,.16,.20)*f1_2+\n        mat4(.50,-.89,-.30,-.24,.81,-.96,.50,-.25,.31,-.32,.20,.37,.36,-.25,-.52,-.86)*f1_3+\n        vec4(1.63,-3.71,2.15,.50))/1.4+f1_3;\n    float d=(dot(f2_0,vec4(.02,-.07,-.06,.03))+\n        dot(f2_1,vec4(.07,.05,.05,-.04))+\n        dot(f2_2,vec4(-.09,.09,.05,-.06))+\n        dot(f2_3,vec4(-.12,.11,.07,-.03))+\n        0.177)*.8;\n   #ifdef SPIKY\n   p*=150.;\n   if (d<.03) d+=.01*dot(sin(p), cos(p.zxy));\n   #endif\n   return d;\n}\n\nvec3 getTeddyNormal(in vec3 p) {\n    vec3 e = vec3(0.01, 0.0, 0.0);\n    return normalize(vec3(sdTeddyBear(p + e.xyy) - sdTeddyBear(p - e.xyy),\n                          sdTeddyBear(p + e.yxy) - sdTeddyBear(p - e.yxy),\n                          sdTeddyBear(p + e.yyx) - sdTeddyBear(p - e.yyx)));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 screenCenter = 0.5 * iResolution.xy;\n\n    vec2 mouse = vec2(iTime, 0.0);\n    if (iMouse.z > 0.0) {\n        mouse = (iMouse.xy - screenCenter) / iResolution.y * 3.14;\n    }\n\n    vec2 uv = (fragCoord - screenCenter) / iResolution.y;\n    fragColor = vec4(0.0, 0.0, 0.0, 1.0);\n\n    vec3 ro = vec3(0.0, 0.0, 2.5);\n    vec3 rd = normalize(vec3(uv, -1.0));\n\n    float cy = cos(mouse.x), sy = sin(mouse.x);\n    float cp = cos(mouse.y), sp = sin(mouse.y);\n    ro.yz *= mat2(cp, -sp, sp, cp);\n    ro.xz *= mat2(cy, -sy, sy, cy);\n    rd.yz *= mat2(cp, -sp, sp, cp);\n    rd.xz *= mat2(cy, -sy, sy, cy);\n\n    vec3 bSphereIntersect = IntersectSphere(ro, rd, 1.0);\n    if (bSphereIntersect.z > 0.5) {\n        float tMin = min(bSphereIntersect.x, bSphereIntersect.y);\n        float tMax = max(bSphereIntersect.x, bSphereIntersect.y);\n        fragColor.rgb += tMin / 10.0;\n\n        vec3 p;\n        bool hitModel = false;\n        float t = tMin;\n        for (int i=0; i < 100; i++) {\n            p = ro + rd * t;\n            float d = sdTeddyBear(p);\n            if (d < 0.001) {\n                hitModel = true;\n                break;\n            }\n\n            if (t > tMax) {\n                break;\n            }\n\n            t += d;\n        }\n\n        if (hitModel) {\n            vec3 n = getTeddyNormal(p);\n            vec3 l = vec3(-0.58, 0.58, 0.58);\n\n            float tex = 1.0;\n\n            #ifdef SPIKY\n            p *= 150.0;\n            tex = 1.0 + 0.5 * dot(sin(p), cos(p.zxy));\n            #endif\n\n            fragColor.rgb += vec3(0.6, 0.4, 0.2) * tex;\n            fragColor.rgb *= max(0.2, dot(n, l));\n        }\n\n        else {\n            fragColor.rgb += mix(vec3(0.25, 0.25, 1.0), vec3(1.0), 0.5 + 0.5 * rd.y);\n        }\n    }\n\n    else {\n        fragColor.rgb += mix(vec3(0.25, 0.25, 1.0), vec3(1.0), 0.5 + 0.5 * rd.y);\n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tlcBRr.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[513, 537, 595, 595, 1025], [1027, 1027, 1057, 1057, 5397], [5399, 5399, 5431, 5431, 5695], [5697, 5697, 5752, 5752, 7592]]}
{"id": "tlccR2", "name": "random streaky thingy [spaz]", "author": "HaleyHalcyon", "description": "a", "tags": ["spiral"], "likes": 1, "viewed": 156, "published": "Public", "date": "1609489461", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// A single iteration of Bob Jenkins' One-At-A-Time hashing algorithm.\nuint hash(uint x) {\n    x += ( x << 10u );\n    x ^= ( x >>  6u );\n    x += ( x <<  3u );\n    x ^= ( x >> 11u );\n    x += ( x << 15u );\n    return x;\n}\n\n// Generate random 4bit RGB color\nvec3 rcol(uint seed) {\n    uint x = hash(seed);\n    return vec3(x & 15u, x>>4u & 15u, x>>8u & 15u) / 15.;\n}\n\nvec3 col(float x) {\n    uint seed = uint(int(x));\n    return  rcol(seed)      * smoothstep(0.04, 0.02, fract(x))\n          + rcol(seed + 1u) * smoothstep(0.00, 0.02, fract(x));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Scales coords so that the diagonals are all dist 1 from center\n    float scale = length(iResolution.xy);\n    vec2 uv = (fragCoord / scale\n\t- (iResolution.xy / scale / 2.)) * 2.;\n    \n    float r = sqrt(length(uv));\n    float theta = atan(uv.y, uv.x) / 2. / 3.141592653589;\n    \n    float bands = 24.;\n    float band = mod(\n        theta * bands + r * 16. + iTime * 4.\n    , bands);\n    \n    // Time varying pixel color\n    vec3 col = col(iTime * 0.8 + floor(iTime * 150.) + floor(band) * 384. + r * 8.);\n\n    // Output to screen\n    fragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tlccR2.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 71, 90, 90, 221], [223, 257, 279, 279, 364], [366, 366, 385, 385, 544], [546, 546, 603, 673, 1173]]}
{"id": "tlcfRn", "name": "Smooth Abs()", "author": "oneshade", "description": "Smooth abs() function.", "tags": ["blending", "function", "smooth", "absolute", "sabs", "smoothabs"], "likes": 3, "viewed": 80, "published": "Public", "date": "1612075854", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define sabs(x, k) 2.0 * k * log(exp(-abs(x) / k) + 1.0) + abs(x)\n\nfloat mapScene(in vec3 p) {\n    float c = cos(iTime), s = sin(iTime);\n    p.xz *= mat2(c, -s, s, c);\n    p.yz *= mat2(c, -s, s, c);\n    float k = 0.2 + 0.2 * sin(iTime);\n    return length(sabs(p, k) - 0.75) - 0.75;\n}\n\nvec3 getNormal(in vec3 p) {\n    vec3 e = vec3(0.01, 0.0, 0.0);\n    return normalize(vec3(mapScene(p + e.xyy) - mapScene(p - e.xyy),\n                          mapScene(p + e.yxy) - mapScene(p - e.yxy),\n                          mapScene(p + e.yyx) - mapScene(p - e.yyx)));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n    fragColor = vec4(0.0, 0.0, 0.0, 1.0);\n\n    vec3 ro = vec3(0.0, 0.0, 5.0);\n    vec3 rd = normalize(vec3(uv, -1.0));\n\n    float t = 0.0;\n    for (int i=0; i < 100; i++) {\n        vec3 p = ro + rd * t;\n        float d = mapScene(p);\n        if (d < 0.001) {\n            vec3 n = getNormal(p);\n            vec3 l = vec3(-0.58, 0.58, 0.58);\n            fragColor.rgb += max(0.2, dot(n, l));\n            break;\n        }\n\n        if (t > 10.0) {\n            break;\n        }\n\n        t += d;\n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tlcfRn.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[67, 67, 94, 94, 283], [285, 285, 312, 312, 558], [560, 560, 615, 615, 1179]]}
{"id": "tlcSRM", "name": "Simply a stroboscopic effect", "author": "Dubko", "description": "Damn", "tags": ["sin"], "likes": 2, "viewed": 54, "published": "Public", "date": "1609949750", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec2 fmod(float i, float m)\n{\n    return vec2(mod(i,m)*(1.0/m), abs(i/m));\n}\nvec4 c(vec2 uv)\n{\n    //uv.x += cos(uv.y*50.0+iTime)*0.01;\n    // Plane tilting\n    uv.x *= sin(iTime);\n    uv.y *= cos(iTime);\n    float r = iTime;\n    // Rotating around Z axis\n    vec2 uvR = mat2(cos(r),-sin(r),sin(r),cos(r))*uv;\n    // Angle around Z axis\n   \n    float angl = atan(uvR.y,uvR.x);\n    \n    // Size of white stripe spread\n    float spread = tan(iTime)*sin(5.0*angl);\n    \n    float l = length(uvR);\n    vec2 a = fmod(l+spread*angl*0.9,0.1);\n    float stripe = (a.x*(0.3/a.y));\n    \n    return vec4(1.0,0.0,0.0,0.0)*stripe+a.y*0.005*tan(iTime*5.0);\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    uv -= 0.5;\n\n    // Time varying pixel color\n    vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n\n    // Output to screen\n    //fragColor = vec4(col,1.0);\n    vec4 cl = c(uv);\n    //cl *= 1.0/(5.0*length(uv)+1.0);\n    fragColor = cl;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tlcSRM.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 29, 29, 76], [77, 77, 94, 156, 644], [645, 645, 702, 752, 1040]]}
{"id": "tlcyR2", "name": "polar coordinates example 🤔", "author": "HaleyHalcyon", "description": "how to do polar coords the easy way on glsl", "tags": ["demo"], "likes": 2, "viewed": 166, "published": "Public", "date": "1609485710", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// gives pure saturated color from input [0, 6) for phase\nvec3 hue(float x) {\n    x = mod(x, 6.);\n    return clamp(vec3(\n        abs(x - 3.) - 1.,\n        -abs(x - 2.) + 2.,\n        -abs(x - 4.) + 2.\n    ), 0., 1.);\n}\n\n// does pseudo overexposure filter\nvec3 deepfry(vec3 rgb, float x) {\n    rgb *= x;\n    return rgb + vec3(\n      max(0., rgb.g - 1.) + max(0., rgb.b - 1.),\n      max(0., rgb.b - 1.) + max(0., rgb.r - 1.),\n      max(0., rgb.r - 1.) + max(0., rgb.g - 1.)\n    );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Scales coords so that the diagonals are all dist 1 from center\n    float scale = length(iResolution.xy);\n    vec2 uv = (fragCoord / scale\n\t- (iResolution.xy / scale / 2.)) * 2.;\n    \n    vec2 rt = vec2(length(uv), atan(uv.y, uv.x));\n    // probably better to just do this:\n    // float r = length(uv);\n    // float theta = atan(uv.y, uv.x);\n    \n    // alternate distance functions are also useful\n    // for wormhole or perspective effects, like:\n    // float r = log(uv.x*uv.x+uv.y*uv.y);\n    \n    // if you want the angle in range [0, 1) and not (-π, π]\n    // divide angle by 2pi and mod1 it\n    // float theta = fract(atan(uv.y, uv.x) / 6.2831853071795);\n\n    // Time varying pixel color\n    vec3 col = deepfry(\n        hue(rt.x * 3. + iTime),\n        1. + 0.5 * sin(rt.x * 6. + rt.y * 3. + iTime * 4.)\n    );\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tlcyR2.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 58, 77, 77, 217], [219, 254, 287, 287, 479], [481, 481, 538, 608, 1420]]}
{"id": "tldcDB", "name": "twisted torus", "author": "rahul897", "description": "torus", "tags": ["raymarching"], "likes": 0, "viewed": 183, "published": "Public API", "date": "1609866084", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// \"ShaderToy Tutorial - Ray Marching for Dummies!\" \n// by Martijn Steinrucken aka BigWings/CountFrolic - 2018\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n//\n// This shader is part of a tutorial on YouTube\n// https://youtu.be/PGtv-dBi2wE\n\n#define MAX_STEPS 100\n#define MAX_DIST 100.\n#define SURF_DIST .01\n\nfloat GetDist(vec3 p) {\n\tvec4 s = vec4(0, 1, 6, 1);\n    \n    float sphereDist =  length(p-s.xyz)-s.w;\n    float planeDist = p.y;\n    \n    float d = min(sphereDist, planeDist);\n    return d;\n}\n\nfloat DE(vec3 p)\n{\n  vec2 t = vec2(0.5,0.2);\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\nfloat opTwist( in vec3 p)\n{\n     float k = 10.*(sin(iTime/1.4)); // or some other amount\n    float c = cos(k*p.y);\n    float s = sin(k*p.y);\n    mat2  m = mat2(c,-s,s,c);\n    vec3  q = vec3(m*p.xz,p.y);\n    return DE(q);\n}\n\nfloat RayMarch(vec3 ro, vec3 rd) {\n\tfloat dO=0.;\n    \n    for(int i=0; i<MAX_STEPS; i++) {\n    \tvec3 p = ro + rd*dO;\n        float dS = opTwist(p);\n        dO += dS;\n        if(dO>MAX_DIST || dS<SURF_DIST) break;\n    }\n    \n    return dO;\n}\n\nvec3 GetNormal(vec3 p) {\n\tfloat d = GetDist(p);\n    vec2 e = vec2(.01, 0);\n    \n    vec3 n = d - vec3(\n        GetDist(p-e.xyy),\n        GetDist(p-e.yxy),\n        GetDist(p-e.yyx));\n    \n    return normalize(n);\n}\n\nfloat GetLight(vec3 p) {\n    vec3 lightPos = vec3(0, 5, 6);\n    //lightPos.xz += vec2(sin(iTime), cos(iTime))*2.;\n    vec3 l = normalize(lightPos-p);\n    vec3 n = GetNormal(p);\n    \n    float dif = clamp(dot(n, l), 0., 1.);\n    float d = RayMarch(p+n*SURF_DIST*1., l);\n    if(d<length(lightPos-p)) dif *= .1;\n    \n    return dif;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\n    vec3 col = vec3(0);\n    \n    vec3 ro = vec3(0, 0.1, 2);\n    vec3 rd = normalize(vec3(uv.x, uv.y, -1));\n\n    float d = RayMarch(ro, rd);\n    \n    vec3 p = ro + rd * d;\n    \n    float dif = GetLight(p);\n    col = vec3(0,0.6*dif,0.9*dif);\n    \n    col = pow(col, vec3(.4545));\t// gamma correction\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tldcDB.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[0, 349, 372, 372, 540], [542, 542, 560, 560, 651], [653, 653, 680, 680, 875], [877, 877, 911, 911, 1117], [1119, 1119, 1143, 1143, 1332], [1334, 1334, 1358, 1358, 1665], [1667, 1667, 1724, 1724, 2120]]}
{"id": "tldcDl", "name": "Cloud Boze 2", "author": "kaiware007", "description": "Cloud Boze 2\n\nold : https://www.shadertoy.com/view/ttfyz4", "tags": ["raycasting", "fbm", "cloud"], "likes": 6, "viewed": 82, "published": "Public", "date": "1610271459", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// ------------------------------------------------------------------------------------\n// Original \"thinking...\" created by kaneta : https://www.shadertoy.com/view/wslSRr\n// Original Character By MikkaBouzu : https://twitter.com/mikkabouzu777\n// ------------------------------------------------------------------------------------\n\n#define saturate(x) clamp(x, 0.0, 1.0)\n\n#define MAX_DIST 100.\n#define M_HALFPI 1.5707963\n#define M_PI 3.1415926\n#define M_PI2 M_PI*2.0\n\n#define M_PI03 1.04719\n#define M_PI06 2.09439\n\n#define MAT_BLACK 1.0\n#define MAT_FACE 2.0\n#define MAT_BROW 3.0\n#define MAT_CHEEP 4.0\n#define MAT_SPHERE 5.0\n#define MAT_BG 6.0\n#define MAT_CS 7.0\n\nvec3 sinebow(float h) {\n    vec3 r = sin((.5-h)*M_PI + vec3(0,M_PI03,M_PI06));\n    return r*r;\n}\n\nfloat rand(vec2 st)\n{\n    return fract(sin(dot(st.xy, vec2(12.9898, 78.233))) * 10000.0);\n}\n\nfloat hash13(vec3 p3)\n{\n\tp3  = fract(p3 * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nfloat noise(vec3 st)\n{\n\tvec3 ip = floor(st);\n    vec3 fp = smoothstep(vec3(0.), vec3(1.), fract(st));\n    \n\tvec4 a = vec4(hash13(ip+vec3(0.)),hash13(ip+vec3(1.,0.,0.)),hash13(ip+vec3(0.,1.,0.)),hash13(ip+vec3(1.,1.,0.)));\n    vec4 b = vec4(hash13(ip+vec3(0.,0.,1.)),hash13(ip+vec3(1.,0.,1.)),hash13(ip+vec3(0.,1.,1.)),hash13(ip+vec3(1.,1.,1.)));\n    \n\ta = mix(a, b, fp.z);\n\ta.xy = mix(a.xy, a.zw, fp.y);\n    \n\treturn mix(a.x, a.y, fp.x);\n}\n\nmat3 m = mat3( 0.00,  0.80,  0.60,\n              -0.80,  0.36, -0.48,\n              -0.60, -0.48,  0.64 );\n\nfloat fbm( vec3 p )\n{\n    float f;\n    f  = 0.5000*noise( p ); p = m*p*2.02;\n    f += 0.2500*noise( p ); p = m*p*2.03;\n    f += 0.1250*noise( p );\n    return f;\n}\n\nfloat easeInOutQuad(float t) {\n    if ((t *= 2.0) < 1.0) {\n        return 0.5 * t * t;\n    } else {\n        return -0.5 * ((t - 1.0) * (t - 3.0) - 1.0);\n    }\n}\n\n// Distance functions by iq\n// https://iquilezles.org/www/articles/distfunctions/distfunctions.htm\nfloat sdSphere( vec3 p, float s )\n{\n  return length(p)-s;\n}\n\nfloat sdRoundBox(vec3 p, vec3 size, float r)\n{\n    return length(max(abs(p) - size * 0.5, 0.0)) - r;\n}\n\nfloat sdCapsule(vec3 p, vec3 a, vec3 b, float r)\n{\n\tvec3 pa = p - a, ba = b - a;\n\tfloat h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\n\treturn length(pa - ba*h) - r;\n}\n\nfloat sdEllipsoid( vec3 p, vec3 r )\n{\n    float k0 = length(p/r);\n    float k1 = length(p/(r*r));\n    return k0*(k0-1.0)/k1;\n}\n\nfloat sdCappedTorus(in vec3 p, in vec2 sc, in float ra, in float rb)\n{\n  p.x = abs(p.x);\n  float k = (sc.y*p.x>sc.x*p.y) ? dot(p.xy,sc) : length(p.xy);\n  return sqrt( dot(p,p) + ra*ra - 2.0*ra*k ) - rb;\n}\n\nfloat sdRoundedCylinder( vec3 p, float ra, float rb, float h )\n{\n  vec2 d = vec2( length(p.xz)-2.0*ra+rb, abs(p.y) - h );\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0)) - rb;\n}\n\nfloat sdCylinder( vec3 p, vec3 c )\n{\n  return length(p.xz-c.xy)-c.z;\n}\n\nfloat sdCappedCylinder( vec3 p, float h, float r )\n{\n  vec2 d = abs(vec2(length(p.xz),p.y)) - vec2(h,r);\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat sdPlane( vec3 p, vec4 n )\n{\n  // n must be normalized\n  return dot(p,n.xyz) + n.w;\n}\n\n// Union, Subtraction, SmoothUnion (distance, Material) \nvec2 opU(vec2 d1, vec2 d2)\n{\n\treturn (d1.x<d2.x) ? d1 : d2;\n}\n\nvec2 opS( vec2 d1, vec2 d2 )\n{ \n    return (-d1.x>d2.x) ? vec2(-d1.x, d1.y): d2;\n}\n\nvec2 opSU( vec2 d1, vec2 d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2.x-d1.x)/k, 0.0, 1.0 );\n    return vec2(mix( d2.x, d1.x, h ) - k*h*(1.0-h), h > 0.5 ? d1.y : d2.y); }\n\nvec2 opI( vec2 d1, vec2 d2 )\n{ \n    //return (d1.x>d2.x) ? d1: vec2(d2.x, d1.y);\n    return (d1.x>d2.x) ? d1: d2;\n}\n\n// Union, Subtraction, SmoothUnion (distance only)\nfloat opUnion( float d1, float d2 ) {  return min(d1,d2); }\n\nfloat opSubtraction( float d1, float d2 ) { return max(-d1,d2); }\n\nfloat opIntersection( float d1, float d2 ) { return max(d1,d2); }\n\nfloat opSmoothUnion( float d1, float d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); }\n\n\nvec3 rotate(vec3 p, float angle, vec3 axis)\n{\n    vec3 a = normalize(axis);\n    float s = sin(angle);\n    float c = cos(angle);\n    float r = 1.0 - c;\n    mat3 m = mat3(\n        a.x * a.x * r + c,\n        a.y * a.x * r + a.z * s,\n        a.z * a.x * r - a.y * s,\n        a.x * a.y * r - a.z * s,\n        a.y * a.y * r + c,\n        a.z * a.y * r + a.x * s,\n        a.x * a.z * r + a.y * s,\n        a.y * a.z * r - a.x * s,\n        a.z * a.z * r + c\n    );\n    return m * p;\n}\n\nvec3 opTwist(in vec3 p, float k )\n{\n    float c = cos(k*p.y);\n    float s = sin(k*p.y);\n    mat2  m = mat2(c,-s,s,c);\n    vec3  q = vec3(m*p.xz,p.y);\n    return vec3(q.x, q.y, q.z);\n}\n\nvec3 TwistY(vec3 p, float power)\n{\n    float s = sin(power * p.y);\n    float c = cos(power * p.y);\n    mat3 m = mat3(\n          c, 0.0,  -s,\n        0.0, 1.0, 0.0,\n          s, 0.0,   c\n    );\n    return m*p;\n}\n\nfloat ease_cubic_out(float p)\n{\n\tfloat f = (p - 1.0);\n\treturn f * f * f + 1.0;\n}\n\nvec3 opRep( in vec3 p, in vec3 c)\n{\n    return mod(p+0.5*c,c)-0.5*c;\n}\n\nvec2 opRep2D( in vec2 p, in vec2 c)\n{\n    return mod(p+0.5*c,c)-0.5*c;\n}\n\n// 線分と無限平面の衝突位置算出\n// rayPos : レイの開始地点\n// rayDir : レイの向き\n// planePos : 平面の座標\n// planeNormal : 平面の法線\nfloat GetIntersectLength(vec3 rayPos, vec3 rayDir, vec3 planePos, vec3 planeNormal)\n{\n    return dot(planePos - rayPos, planeNormal) / dot(rayDir, planeNormal);\n}\n\nfloat IsHitSphere(vec3 ro, vec3 rd, vec3 sphereCenter, float radius) {\n    vec3 diff = ro - sphereCenter;\n    float xc2 = dot(diff, diff);\n    float vxc = dot(rd, diff);\n    float sq = radius * radius;\n    return vxc * vxc - xc2 + sq; \n}\n\nfloat GetIntersectSphere(vec3 rayPos, vec3 rayDir, vec3 sphereCenter, float radius) {\n    float a = length(rayDir);\n    float a2 = a * a;\n    vec3 diff = rayPos - sphereCenter;\n    float b = dot(diff, rayDir);\n    float c = length(diff);\n    float c2 = c * c - radius * radius;\n    float b2ac = sqrt(b * b - a2 * c2);\n    float t1 = (-b + b2ac) / a2;\n    float t2 = (-b - b2ac) / a2;\n    return min(t1, t2);\n}\n\n/////////////////////////////////////////////////////////////////////////////////////////////////\n// Mikka Boze Distance Function\n/////////////////////////////////////////////////////////////////////////////////////////////////\n#define RAD90 (M_PI * 0.5)\n\nfloat sdEar(vec3 p)\n{\n    p = rotate(p, RAD90+0.25, vec3(0,0,1));    \n    return sdCappedTorus(p + vec3(0.05, 0.175, 0), vec2(sin(0.7),cos(0.7)), 0.03, 0.01);\n}\n\n#define EYE_SPACE 0.04\n\nvec3 opBendXY(vec3 p, float k)\n{\n    float c = cos(k*p.x);\n    float s = sin(k*p.x);\n    mat2  m = mat2(c,-s,s,c);\n    return vec3(m*p.xy,p.z);\n}\nvec3 opBendXZ(vec3 p, float k)\n{\n    float c = cos(k*p.x);\n    float s = sin(k*p.x);\n    mat2  m = mat2(c,-s,s,c);\n    vec2 xz = m*p.xz;\n    return vec3(xz.x, p.y, xz.y);\n}\nfloat sdMouse(vec3 p, float ms)\n{\n    vec3 q = opBendXY(p, 2.0);\n    ms += 0.00001;\n    return sdEllipsoid(q - vec3(0,0,0.2), vec3(0.035, 0.01 * ms,0.05 * ms));\n}\n\nfloat sdCheep(vec3 p)\n{    \n    const float x = 0.05;\n    const float z = -0.175;\n    const float r = 0.0045;\n    const float rb1 = 100.;\n    \n    p = rotate(p, M_PI * -0.6 * (p.x - x), vec3(-0.2,0.8,0));\n\t\n    float d = sdCapsule(opBendXY(p + vec3(x, -0.01, z), rb1), vec3(-0.005,0.0,0.0), vec3(0.005, 0., 0.001), r);\n    float d1 = sdCapsule(opBendXY(p + vec3(x+0.01, -0.01, z), 200.0), vec3(-0.0026,0.0,0), vec3(0.0026, 0., 0), r);\n    float d2 = sdCapsule(opBendXY(p + vec3(x+0.019, -0.015, z), -rb1), vec3(-0.01,0.0,-0.01), vec3(0.0045, 0., 0.0), r);\n    \n    return opUnion(opUnion(d, d1), d2);\n}\n\nfloat sdEyeBrow(vec3 p)\n{\n    const float x = 0.05;\n    p = opBendXZ(p + vec3(0.02,0,-0.02), -6.5);\n    return sdRoundBox(p + vec3(0.005, -0.14,-0.11), vec3(0.003,0.0025,0.05), 0.001);\n}\n\nfloat sdBoze(vec3 p, float sc, float ms)\n{        \n    p /= sc;\n    \n    // head\n\tfloat d = sdCapsule(p, vec3(0,0.05,0), vec3(0, 0.11, 0), 0.125);\n    \n    float d1 = sdRoundedCylinder(p + vec3(0,0.025,0), 0.095, 0.05, 0.0);\n    \n    d = opSmoothUnion(d, d1, 0.1);\n    \n    vec3 mxp = vec3(-abs(p.x), p.yz);\n    \n    // ear\n    float d2 = sdEar(mxp);\n    d = opUnion(d, d2);\n\n    float head = d;\n\n\t// eye\n    float eye = sdCapsule(mxp, vec3(-EYE_SPACE, 0.06, 0.13), vec3(-EYE_SPACE, 0.08, 0.125), 0.0175);\n    \n    // mouse\n    float mouse = sdMouse(mxp, ms);\n    \n    // cheep\n    float cheep = sdCheep(mxp);\n\n    // eyebrows\n    float eyebrow = sdEyeBrow(p);\n    \n    float sub = opUnion(opUnion(eye, mouse), eyebrow);\n    \n    float result = opSubtraction(sub, head);\n    result = opUnion(cheep, result);\n    \n    result *= sc;\n    \n    return result;\n}\n/////////////////////////////////////////////////////////////////////////////////////////////////\n// End of Mikka Boze\n/////////////////////////////////////////////////////////////////////////////////////////////////\n\n#define BOZE(p) (sdBoze(p - vec3(0.,0.3, 0.), 5.0, (sin(iTime * 0.5) * 0.5 + 0.5)*1.5))\n\nfloat sdDome(vec3 p)\n{\n    float d1 = sdRoundBox(p, vec3(100, 6, 100), 0.01);\n    float d2 = sdSphere(p, 6.);\n    return opSubtraction(d2, d1) - (fbm(p * 0.35 + iTime * 0.1)-(p.y*0.35));\n    //return opSubtraction(d2, d1);\n}\n\nfloat map(vec3 p)\n{\n    // cloud boze\n    float r = BOZE(p);\n    \n    // cloud sea\n    float d = sdDome(p);\n    return min(r, d);\n}\n\nfloat densitycalc(vec3 p){\n    // Boze Cloud\n\tfloat r = BOZE(p);\t\n    float density = fbm(p * 15. + iTime * 0.5) - min(r, 1.) * 10.5;\n    \n    // Cloud sea\n    float d = sdDome(p);\n    float sdensity = fbm(p * 3. + iTime * 0.15) -min(d, 1.)*1.5;\n    \n    return max(density, sdensity);\n}\n\nfloat checkMap(vec3 p, vec3 ray, float depth)\n{\n    float t = 0.;\n    \n    for(int i = 0; i < 5; i++){\n        float d = map(p);\n        if(abs(d) < 0.1 || d > depth)\n            break;\n        t += d;\n        p += ray * d;\n    }\n    \n    return t;\n}\n\n#define MAX_MARCH 64\n#define MAX_MARCH_L 6\n\nvec3 raycast(vec3 p, vec3 ray, float depth)\n{\n    vec3 result = vec3(0.);\n          \n    float radius = 2.0;\n    float d = checkMap(p, ray, depth);\n    \n    if(d < depth)\n    {\n        float zstep = 7.0 / float(MAX_MARCH);\n    \tfloat lightZStep = 2.0 / float(MAX_MARCH_L);\n        \n        vec3 ro2 = p + ray * (d - zstep);\n        float t = hash13(ro2 * 2165.) * 0.001;\n        float alpha = 0.;\n        float transmittance = 1.0;\n        float absorption   = 20.;\n        //vec3 sunDir = normalize(vec3(cos(iTime),1,sin(iTime)));\n        vec3 sunDir = normalize(vec3(-1,1,-0.25));\n        vec3 col = vec3(0.0);\n        \n        for(int i = 0; i < MAX_MARCH; i++){\n            t += zstep;\n            vec3 pp = ro2 + ray * t;\n            if(t >= depth)\n                break;\n            \n            float density = densitycalc(pp);\n            \n            if(density > 0.){\n                float dd = density / float(MAX_MARCH);\n                transmittance *= 1.0 - dd * absorption;\n                if(transmittance < 0.01)\n                    break;\n                alpha += 100. * dd * transmittance;\n                \n                float transmittanceLight = 1.0;\n                \n                for(int j = 0; j < MAX_MARCH_L; j++){\n                \tfloat densityLight = densitycalc(pp + sunDir * float(j) * lightZStep);\n                    if(densityLight > 0.0){\n                    \tfloat dl = densityLight * lightZStep;\n                        transmittanceLight *= 1.0 - dl * absorption * 0.1;\n                        if(transmittanceLight < 0.01){\n                        \ttransmittanceLight = 0.;\n                            break;\n                        }\n                    }\n                }\n                \n                col += vec3(1.) * (10. * dd * transmittance); // base\n                col += vec3(1.,.7,.5) * (80. * dd * transmittance * transmittanceLight); // light\n            }\n        }\n        result = col;\n    }\n    \n    return result;\n}\n\nmat3 camera(vec3 ro, vec3 ta, float cr )\n{\n\tvec3 cw = normalize(ta - ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\nfloat luminance(vec3 col)\n{\n    return dot(vec3(0.298912, 0.586611, 0.114478), col);\n}\n\nvec3 reinhard(vec3 col, float exposure, float white) {\n    col *= exposure;\n    white *= exposure;\n    float lum = luminance(col);\n    return (col * (lum / (white * white) + 1.0) / (lum + 1.0));\n}\n\nvec3 sky(vec2 p, vec3 rd)\n{\n    vec3 r = vec3(0.);\n\n    vec3 up = mix(vec3(0.25,0.5,0.8), vec3(0.001, 0.15, 0.5), saturate(abs(rd.y-0.3) * 5.0));\n    vec3 down = vec3(0.25,0.5,0.8);\n    return rd.y > 0.3 ? up : down;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    vec2 p = (fragCoord.xy * 2.0 - iResolution.xy) / min(iResolution.x, iResolution.y);\n\n    float time = iTime * 0.5;\n    float y = 0.6;\n    vec3 ro = vec3(0., -0.5, 3.5);\n    vec3 ta = vec3(0., y, 0.);\n    mat3 c = camera(ro, ta, 0.);\n    vec3 ray = c * normalize(vec3(p, 3.5));\n    vec3 col = sky(p, ray);\n    \n    col += raycast(ro, ray, 100.);\n    \n    col = reinhard(col.xyz, 2.9, 100.0);\n    col = pow(col.xyz, vec3(1.0/0.9));\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tldcDl.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 664, 687, 687, 760], [762, 762, 783, 783, 853], [855, 855, 878, 878, 981], [983, 983, 1005, 1005, 1422], [1532, 1532, 1553, 1553, 1694], [1696, 1696, 1726, 1726, 1856], [1858, 1957, 1992, 1992, 2016], [2018, 2018, 2064, 2064, 2120], [2122, 2122, 2172, 2172, 2290], [2292, 2292, 2329, 2329, 2418], [2420, 2420, 2490, 2490, 2624], [2626, 2626, 2690, 2690, 2807], [2809, 2809, 2845, 2845, 2879], [2881, 2881, 2933, 2933, 3040], [3042, 3042, 3075, 3101, 3132], [3134, 3191, 3219, 3219, 3252], [3254, 3254, 3284, 3284, 3336], [3338, 3338, 3378, 3378, 3514], [3516, 3516, 3546, 3596, 3631], [3633, 3684, 3721, 3721, 3743], [3745, 3745, 3788, 3788, 3810], [3812, 3812, 3856, 3856, 3877], [3879, 3879, 3931, 3931, 4030], [4033, 4033, 4078, 4078, 4507], [4509, 4509, 4544, 4544, 4692], [4694, 4694, 4728, 4728, 4904], [4906, 4906, 4937, 4937, 4986], [4988, 4988, 5023, 5023, 5058], [5060, 5060, 5097, 5097, 5132], [5134, 5305, 5390, 5390, 5467], [5469, 5469, 5539, 5539, 5706], [5708, 5708, 5793, 5793, 6117], [6119, 6375, 6396, 6396, 6535], [6561, 6561, 6593, 6593, 6706], [6707, 6707, 6739, 6739, 6879], [6880, 6880, 6913, 6913, 7042], [7044, 7044, 7067, 7067, 7646], [7648, 7648, 7673, 7673, 7834], [7836, 7836, 7878, 7878, 8692], [8693, 9000, 9022, 9022, 9224], [9226, 9226, 9245, 9263, 9357], [9359, 9359, 9385, 9403, 9646], [9648, 9648, 9695, 9695, 9898], [9944, 9944, 9989, 9989, 11923], [11925, 11925, 11967, 11967, 12145], [12147, 12147, 12174, 12174, 12233], [12235, 12235, 12289, 12289, 12431], [12433, 12433, 12460, 12460, 12651], [12653, 12653, 12710, 12710, 13187]]}
{"id": "tldcWj", "name": "Shader Experiment/Visualiser", "author": "Aeshe", "description": "Music influenced noise applied to a circles and then colours.  (If no sound can be heard, try pausing and playing the shader again)\nThe background, A black circle and inner circle is influenced by noise.", "tags": ["shader"], "likes": 0, "viewed": 52, "published": "Public", "date": "1610029391", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const int shuffle[256] = int[256]\n(206,21,27,124,238,156,174,113,170,81,237,12,22,241,23,141,10,167,146,114,\n 162,9,13,5,139,216,91,65,6,189,221,86,7,187,212,166,67,149,131,98,126,1,\n 137,54,8,70,110,148,46,151,106,89,121,236,101,227,49,72,255,239,3,73,244,169,\n 157,96,175,75,77,205,160,30,36,178,112,88,154,228,104,68,185,43,184,182,14,163,\n 233,18,180,45,83,186,59,25,129,111,74,215,122,218,144,44,100,161,53,254,55,92,\n 35,145,220,119,195,66,130,150,140,181,57,56,84,207,245,231,191,248,61,52,118,168,\n 226,223,40,197,116,58,232,243,214,204,33,28,105,202,24,152,133,51,196,210,115,\n 190,97,147,143,132,50,94,165,109,198,39,134,120,2,85,128,135,20,79,123,90,222,\n 26,155,82,252,136,76,217,32,240,63,38,159,247,37,176,78,234,42,219,209,0,103,\n 64,99,15,95,242,47,11,246,211,199,17,62,29,192,69,183,200,34,225,138,224,127,\n 235,229,117,253,71,108,87,201,208,171,203,41,173,102,125,213,107,179,250,80,16,\n 4,153,142,251,31,172,164,188,249,93,60,230,194,177,193,48,158,19);    \n\nconst vec3 gradients[16] = vec3[16](\nvec3(1,1,0),vec3(-1,1,0),vec3(1,-1,0),vec3(-1,-1,0),\nvec3(1,0,1),vec3(-1,0,1),vec3(1,0,-1),vec3(-1,0,-1),\nvec3(0,1,1),vec3(0,-1,1),vec3(0,1,-1),vec3(0,-1,-1),\nvec3(1,1,0),vec3(-1,1,0),vec3(0,-1,1),vec3(0,-1,-1));\n\nint Hash( in int i, in int j, in int k )\n{\n    return shuffle[(shuffle[(shuffle[i%256] + j)%256] + k)%256]%16;\n}\n\nvec3 Gradient( int i, int j, int k )\n{\n\treturn gradients[Hash(i,j,k)];\n}\n\nvec3 PositionVector( int i, int j, int k, vec3 pos )\n{\n\treturn (pos-vec3(i,j,k));\n}\n\nfloat Smoothstep( float f0, float f1, float x )\n{\n\tx = max(x, 0.0);\n\tx = min(x, 1.0);\n\tx = 3.0*x*x - 2.0*x*x*x;\n\treturn f0*(1.0f-x) + f1*x;\n}\n\n\nfloat PerlinNoise( vec3 pos, float iScale )\n{\n\tfloat noiseVals[8];\n\tpos = (pos + vec3(100,100,100))*iScale; // offset of 100 is to make sure it is in the positive quadrant\n\t// get the indices of the cube this vert is in\n\tint i = int( pos.x );\n\tint j = int( pos.y );\n\tint k = int( pos.z );\n\t// get the noise values at the vertices of the cube\n\tnoiseVals[0] = dot( Gradient(i,j,k),       PositionVector(i,j,k,pos) );\n\tnoiseVals[1] = dot( Gradient(i+1,j,k),     PositionVector(i+1,j,k,pos) );\n\tnoiseVals[2] = dot( Gradient(i+1,j,k+1),   PositionVector(i+1,j,k+1,pos) );\n\tnoiseVals[3] = dot( Gradient(i,j,k+1),     PositionVector(i,j,k+1,pos) );\n\tnoiseVals[4] = dot( Gradient(i,j+1,k),     PositionVector(i,j+1,k,pos) );\n\tnoiseVals[5] = dot( Gradient(i+1,j+1,k),   PositionVector(i+1,j+1,k,pos) );\n\tnoiseVals[6] = dot( Gradient(i+1,j+1,k+1), PositionVector(i+1,j+1,k+1,pos) );\n\tnoiseVals[7] = dot( Gradient(i,j+1,k+1),   PositionVector(i,j+1,k+1,pos) );\n\t// now do the interpolation\n\n\t// interpolation parameters tx, ty, tz\n\tvec3 t = pos - vec3(i,j,k);\n\n\tfloat ft, fb;\n\tfloat fy0, fy1;\n\t// bottom xz plane\n\tft = Smoothstep( noiseVals[3], noiseVals[2], t.x);\n\tfb = Smoothstep( noiseVals[0], noiseVals[1], t.x);\n\tfy0 = Smoothstep( fb, ft, t.z); \n\t// top xz plane\n\tft = Smoothstep( noiseVals[7], noiseVals[6], t.x);\n\tfb = Smoothstep( noiseVals[4], noiseVals[5], t.x);\n\tfy1 = Smoothstep( fb, ft, t.z); \n\t// y interpolation\n\treturn Smoothstep(fy0, fy1, t.y);\n}\n\nfloat ScaledNoise( vec3 pos, float iScale )\n{\n\treturn (1.0f + PerlinNoise( pos, iScale))*0.5f;\n}\n\nfloat FractalNoise( vec3 pos, float iScale, float mult, int numOctaves)\n{\n    float fac = 1.0f;\n    float noise = PerlinNoise(pos, iScale);\n    for ( int i = 0; i < numOctaves-1; i++ )\n    {\n    \tfac *= mult;\n        iScale *= 2.0;\n        noise += fac*PerlinNoise(pos, iScale);\n    }\n    return noise;\n}\n\nconst vec2 points[8] = vec2[8](\n    vec2(0.1, 0.2),\n    vec2(0.9, 0.8),\n    vec2(0.3, 0.3),\n    vec2(0.7, 0.5),\n    vec2(0.8, 0.3),\n    vec2(0.6, 0.6),\n    vec2(0.3, 0.1),\n    vec2(0.4, 0.5)\n);\nconst vec4 colors[8] = vec4[8](\n    vec4(0.5, 0.3, 0.9, 1.0),\n    vec4(0.2, 0.7, 0.2, 1.0),\n    vec4(0.7, 0.5, 0.1, 1.0),\n    vec4(0.8, 0.9, 0.3, 1.0),\n    vec4(0.3, 0.8, 0.7, 1.0),\n    vec4(0.4, 0.1, 0.8, 1.0),\n    vec4(0.6, 0.4, 0.4, 1.0),\n    vec4(0.9, 0.2, 0.7, 1.0)\n);\n\nconst float a[8] = float[8](0.3, 0.2, 0.1, -0.4, -0.3, 0.1, 0.05, 0.4);\nconst float b[8] = float[8](0.2, 0.8, 0.1, 0.7, -0.2, -0.5, 0.9, -0.6);\nconst float c[8] = float[8](2.0, 3.0, 6.0, 3.0, 1.0, 3.0, 1.0, 1.0 );\n\nvec4 hsv2rgb(vec3 c) \n{\n    vec3 rgb = clamp(abs(mod(c.x*6.+vec3(0.,4.,2.),6.)-3.)-1.,0.,1.);\n    rgb = rgb * rgb * (3.0 - 2.0 * rgb);\n    vec3 color = c.z * mix(vec3(1.0), rgb, c.y);\n    return vec4(color,1);\n}\n\nvec4 GetColor(in int i)\n{\n    float noise0 = 0.5 * (PerlinNoise(vec3(points[i], iTime), 1.0));\n    float noise1 = 0.5 * (PerlinNoise(vec3(points[i], iTime+100.0), 1.0));\n    vec3 hsv = vec3(noise0, 0.7+0.3*noise1, 1.0);\n    return hsv2rgb(hsv);\n    \n}\n\nvec2 GetPoint(in int i )\n{\n    // move the points on orbits\n    float x = points[i].x + a[i]*cos(c[i]*iTime*0.1);    \n    float y = points[i].y + b[i]*sin(c[i]*iTime*0.1); \n    return vec2(x,y);\n}\n\nvec4 GetVoronoiColor(in vec2 point)\n{\n    float nearDistSq = 1e20;\n    vec4 color;\n    vec2 offset;\n    //offset.x = 0.3*FractalNoise(vec3(point, iTime * 0.3), 3.0, 0.5, 3);\n    offset.x = 0.3*FractalNoise( vec3(point, iTime+texture(iChannel0, vec2(0,0)).r),1.0, 0.5, 5);\n    offset.y = 0.3*FractalNoise(vec3(point, iTime +texture(iChannel0, vec2(0,0)).r + 100.0), 3.0, 0.5, 3);\n    for ( int i = 0; i < 8; i++ )\n    {\n        vec2 diff = point+offset-GetPoint(i);\n        float d2 = dot(diff,diff);\n        if ( d2 < nearDistSq )\n        {\n            nearDistSq = d2;\n            color = GetColor(i);\n        }\n    }\n    return color;\n}\n\nbool sphere(in vec3 position, in vec3 direction, in vec3 centre, in float radius, in mat3 rotMat, out vec3 hitPosition,\n                        out vec3 hitNorms, out vec3 hitPosLocal)\n{\n    float a = dot(position - centre, direction) * 2.0;\n    float b = dot(position - centre, position - centre) - radius * radius;\n    \n    float sq = sqrt(a * a - 4.0 * b);\n    float sol1 = 0.5 * (-b - sq);\n    float sol2 = 0.5 * (-b + sq);\n    \n    if(a * a < 4.0 * b)\n    {\n        return false;\n    }\n    \n    if(sol1 > sol2)\n    {\n        sol1 = sol2;\n    }\n    \n    hitPosition = position + direction * sol1;\n    hitNorms = normalize(hitPosition - centre);\n    hitPosLocal = transpose(rotMat) * (hitPosition - centre);\n    \n    return true;\n    \n}\n                        \n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 newUV = vec2(0.0, 0.0);\n    uv -= vec2(0.5, 0.5);\n    uv.x *= iResolution.x / iResolution.y;\n    vec3 i = vec3(0.0, 0.0, 0.5);\n    vec3 j = normalize(vec3(uv, 0.0) - i);\n    \n    //=================================================================\n    // Noise\n    //=================================================================\n\n    \n    float noise = FractalNoise( vec3(texture(iChannel0, vec2(uv))), 1.0, 0.5, 5);        //Switch UV's here for different effects!\n    float bgNoise = FractalNoise( vec3(texture(iChannel0, vec2(0.3,0.3))), 1.0, 0.5, 5);        //Switch UV's here for different effects!\n    //float noise = FractalNoise( vec3(iTime+texture(iChannel0, vec2(0,0)).r, uv.x, uv.y),1.0, 0.5, 5);    For splodges instead - Change background colours to make it stand out\n    \n    \n    \n    //=================================================================\n    //Sphere Positions\n    //=================================================================\n\n    vec3 spherePosition = vec3(0, 0, 0.9);\n    vec3 bg1SpherePos = vec3(0, 0, 1.55);\n    vec3 bg2SpherePos = vec3(0, 0, 0.8);\n    vec3 bg3SpherePos = vec3(0, 0, 1.3);\n    \n    //=================================================================\n    // Radius\n    //=================================================================\n    \n    mat3 rotMat = mat3(1, 0, 0, 0, 1, 0, 0, 0, 1);\n    float noiseInfluRadius = noise;\n    float newNoiseRadius = bgNoise;\n    float radius = 0.5;                \n    \n    //=================================================================\n    //Positions\n    //=================================================================\n\n    vec3 hitPosition, hitNorms, hitPosLocal;\n    bool hit, bgHit, bg2Hit, bg3Hit;\n    \n    //=================================================================\n    //Background\n    //=================================================================\n    \n    fragColor = GetVoronoiColor(uv);\n    //fragColor = vec4(1.0, 1.0, 1.0, 1.0);   //backup background\n   \n    \n    //=================================================================\n    //Main\n    //=================================================================    \n    \n    \n    //Sphere\n    hit = sphere(i, j, spherePosition, noiseInfluRadius, rotMat, hitPosition, hitNorms, hitPosLocal);\n    \n    //Background - Defintely a better way to do this...\n    bgHit = sphere(i, j, bg1SpherePos, radius, rotMat, hitPosition, hitNorms, hitPosLocal);   \n    \n    bg2Hit = sphere(i, j, bg2SpherePos, newNoiseRadius, rotMat, hitPosition, hitNorms, hitPosLocal);\n    \n    bg3Hit = sphere(i, j, bg3SpherePos, radius, rotMat, hitPosition, hitNorms, hitPosLocal);\n    if(bg3Hit)\n    {\n        fragColor = vec4(0.2, 0.2, 0.2, 1.0);\n    }\n    \n    if(bg2Hit)\n    {\n        fragColor = vec4(0.0, 0.0, 0.0, 1.0);\n    }\n\n    if(bgHit)\n    {\n        fragColor = vec4(0.3, 0.3, 0.3, 1.0);\n    }\n    \n    \n    if(hit)\n    {\n        fragColor = GetVoronoiColor(uv);\n    }\n    \n    //Ignore all of my bad comments pls\n    \n    //Credits\n    // Music: https://soundcloud.com/gotmilkblood/1-sick-of-being-honest  - Sick of being honest by Milkblood\n    // Paste any song you want from soundcloud into the dialogue box that pops up when clicking on iChannel0 \n    \n    \n}", "image_inputs": [{"id": "llXSzN", "previewfilepath": "https://soundcloud.com/gotmilkblood/1-sick-of-being-honest", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0, "src": "https://soundcloud.com/gotmilkblood/1-sick-of-being-honest", "ctype": "musicstream"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tldcWj.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1229, 1229, 1271, 1271, 1341], [1343, 1343, 1381, 1381, 1415], [1417, 1417, 1471, 1471, 1500], [1502, 1502, 1551, 1551, 1643], [1646, 1646, 1691, 1691, 3097], [3099, 3099, 3144, 3144, 3195], [3197, 3197, 3270, 3270, 3501], [4187, 4187, 4210, 4210, 4398], [4400, 4400, 4425, 4425, 4651], [4653, 4653, 4679, 4712, 4849], [4851, 4851, 4888, 4888, 5489], [5491, 5491, 5677, 5677, 6230], [6257, 6257, 6314, 6364, 9648]]}
{"id": "tldczl", "name": "Simple FS&GA Noise ", "author": "Kivvi", "description": "Simple noise based on fibonacci sequence & golden angle", "tags": ["fractal", "noise", "simple", "pattern", "angle", "sequence", "phi", "fibonacci", "golden"], "likes": 2, "viewed": 44, "published": "Public", "date": "1609751241", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float pi = 3.141592653589793;\n\nmat2 rot(float ang){\n\n    return mat2(cos(ang), -sin(ang), sin(ang), cos(ang));\n\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n\n    vec2 uv = fragCoord/iResolution.xy;\n    uv -= 0.5;\n    uv.x /= iResolution.y / iResolution.x;\t\n    uv *= 20.0;\n    float sc = sin(iTime / 50.) * 5.;\n    //uv *= sc;\n    //uv *= rot(iTime / 50.);\n    \n    float kk = iTime / 3.;\n    \n    float ar = 0.;\n    \n    for(float j = 1.; j < ((sin(iTime / 4.) + 1.) / 2. + 0.5) * 5.; j += 1.){\n        \n        uv *= j;\n    \n        float ok = 0.;\n        float a = 1.;\n        float b = 0.;\n        float c = 0.;    \t\n\n        for(float i = 0.; i < 8.; i += 1.){\n    \n            a += c;\n            c = b;\n            b = a;        \t\n\n            uv *= rot(i * (pi / 180. * 137.5));\n        \n            ok += sin(uv.x + a + kk);\n            ok += sin(uv.y + a + kk);\n    \n        }\n        ar += ok;\n    }\n    ar = (ar + 1.) / 2.;\n    vec3 col = vec3(ar, ar, ar);\n    \n    // Output to screen\n    fragColor = vec4(col,1.0); \n    \n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tldczl.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[31, 31, 51, 51, 113], [114, 114, 170, 170, 1050]]}
{"id": "tldyDH", "name": "Eye for Radial Fbm Practice", "author": "specialsaucewc", "description": "Making an eye shader to get more comfortable with fbm noise manipulation and polar coordinates.\n\nShader is following the tutorial by Inigo Quilez\nhttps://www.youtube.com/watch?v=emjuqqyq_qc", "tags": ["noise", "fbm", "distortion", "eye", "radial", "practice"], "likes": 1, "viewed": 248, "published": "Public API", "date": "1609811569", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI 3.141592\n\n// random hash via https://www.shadertoy.com/view/3d2GRh\n// I didnt update this hash until after I styled it -_- so it stays\nfloat hash( in ivec2 q )\n{\n    // You SHOULD replace this by something better. Again, Do Not Use in production.\n    int n = q.x*131 + q.y*57;\n    n = (n << 13) ^ n;\n    n = n * (n * n * 15731 + 789221) + 1376312589;\n    return float((n>>8)&0x007fffff)/float(0x007fffff);\n}\n\nfloat noise (in vec2 x, in int p)\n{\n    ivec2 i = ivec2(floor(x));\n    vec2 f = fract(x);\n    \n    f = f*f*(3.-2.*f);\n    \n    return mix(mix( hash((i+ivec2(0,0))&(p-1)), \n                    hash((i+ivec2(1,0))&(p-1)),f.x),\n               mix( hash((i+ivec2(0,1))&(p-1)), \n                    hash((i+ivec2(1,1))&(p-1)),f.x),f.y);\n}\n\nfloat fbm (in vec2 x, in int p)\n{\n    float f = 0.;\n    float s = .5;\n    for (int i=0; i<9; i++)\n    {\n        f += s*noise(x,p);\n        s *= .5;\n        x *= 2.;\n        p *= 2;\n    }\n    return f;\n}\n\nvec3 eye(in vec2 uv)\n{\n    vec2 ar = vec2(atan(uv.y, uv.x)/PI, length(uv));\n    vec3 bkgd = vec3(251.,247.,245.)/256.;\n    float f = fbm(8.*ar, 4);\n    vec3 col = vec3(0., .3, .4);\n    col = mix(col, vec3(.2, .5, .4), f);\n    \n    float t = .8 * iTime;\n    float ss = pow(abs(sin(t)), 4.) + pow(abs(sin(t + 2.)), 4.);\n    float anim = 1. + .2*ss*clamp(1.-2.*ar.y, 0., 1.);\n    ar.y *= anim;\n    \n    ar.x += .05 * fbm(20.*ar, 8);\n    \n    //pupil glow\n    f = smoothstep(.25, .15, ar.y);\n    vec3 glow = vec3(.9, .6, .2);\n    col = mix(col, glow, f);\n    \n    //strands\n    f = smoothstep(.3, 1., fbm(vec2(64., 10.)*ar, 16));\n        //mixed mainlines\n    vec3 strands = mix(vec3(12, 122, 4)/256., vec3(57, 237, 171)/256., fbm(8.*ar, 12));\n        //white striations\n    strands = mix(strands, vec3(1), pow(abs(sin(18.*PI*ar.x)), 8.));\n    col = mix(col, strands, f);\n    \n    //black\n    f = smoothstep( .4, .9, fbm(vec2(24., 8.)*ar, 8));\n    col *= 1. - .5*f;\n    \n    //dim edges\n    f = smoothstep(.55, .3, ar.y);\n    col *= f;\n    \n    //pupil\n    col *= smoothstep(.1, .15, ar.y);\n    \n    //reflection\n    f = smoothstep(.25, .0, length(uv - vec2(.1, .1)));\n    col += vec3(1., .9, .8)*f;\n    \n    //outer edge\n    f = smoothstep(.45, .43, ar.y);\n    col = mix(bkgd, col, f);\n    \n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\n    vec3 col = vec3(0);\n\n    col = eye(uv);\n    \n    //Debug tools\n    //col.rg = ar;\n    //vec2 ar = vec2(atan(uv.y, uv.x)/PI, length(uv));\n    //ar.x += .05 * fbm(20.*ar, 8);\n    //col = vec3(fbm(8.*ar, 12));\n    //col.gb = vec2(0.);col.r = ar.x * .5 + .5;col.g=ar.y;\n\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tldyDH.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[21, 146, 172, 257, 418], [420, 420, 455, 455, 753], [755, 755, 788, 788, 957], [959, 959, 981, 981, 2264], [2266, 2266, 2323, 2323, 2687]]}
{"id": "tldyDj", "name": "Genuary2021 6 - Triangle Subdiv", "author": "qw", "description": "Entry for Day 6 of #Genuary2021 - see https://genuary2021.github.io/\nPrompt of the day: Triangle Subdivision", "tags": ["2d", "triangles", "genuary2021", "genuary"], "likes": 3, "viewed": 42, "published": "Public", "date": "1609964756", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI 3.1415\n#define PI2 3.1415 * 2.\n\n\nfloat Rand2To1(in vec2 val)\n{\n     return fract(sin(val.x*3.23+val.y*54.342)*854.53)\n     ;\n}\n\nfloat sdSegment( in vec2 p, in vec2 a, in vec2 b )\n{\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\n\nfloat line(in vec2 p, in vec2 a, in vec2 b, in float thick){\n\n    return 1.-smoothstep(thick - 1.5/iResolution.y, thick, sdSegment(p,a,b));\n    \n}\n\nfloat Pattern(in vec2 uv, in float edgeCount, in float rad){\n    float thick = 8./iResolution.y;\n\n    float result = 0.;\n\n    float segA = PI2 / edgeCount;\n    mat2x2 segmentRotation = mat2x2(cos(segA),-sin(segA),sin(segA),cos(segA));\n\n    vec2 circleOrigin = uv+vec2(-.5,0.);\n    for(float i = 0.; i < edgeCount; i++){\n        vec2 curr = vec2( cos( i* (PI2 / edgeCount)), sin( i* (PI2 / edgeCount)) ) * rad;\n        vec2 next = vec2(cos( (i+1.)* (PI2 / edgeCount)), sin( (i+1.)* (PI2 / edgeCount) ))*rad;\n        \n        //Outer line\n        result += line(circleOrigin, curr, next, thick);\n        \n        vec2 currToNextDir = next - curr;\n        vec2 halfWayP = curr + (currToNextDir*.5);\n        \n        vec2 perpendCurr = cross(vec3(0.,0.,1.),normalize(vec3(currToNextDir,0.))).xy;\n        vec2 perpendNext = perpendCurr * segmentRotation;\n        \n        float distToCenter = length(  halfWayP )* (0.8 + sin(iTime)*0.2);\n        vec2 currMid = halfWayP + (perpendCurr*distToCenter);\n        vec2 nextMid =  (halfWayP*segmentRotation) + (perpendNext*distToCenter);\n        \n        //current & next point connecting to midway point perpendicular\n        result += line(circleOrigin, curr, currMid, thick*.3);\n        result += line(circleOrigin, next , currMid, thick*.3);\n        result += line(circleOrigin, currMid, nextMid, thick*.3);\n        //midway point connecting to center of circle to create inner triangles\n        result += line(circleOrigin, currMid, vec2(0), thick*.3);\n    }\n    \n    \n    return clamp(result,0.,1.);\n    \n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = ( fragCoord -.5*iResolution.xy ) /iResolution.y;\n    uv.x += 0.5;\n    float radius = .4;\n    \n    vec3 col = vec3(0);\n    float mask = 0.;\n    float currentShape = 0.;\n    \n    float[] segments = float[](20.,5.,12.,16.,8.);\n    vec3[] cols = vec3[](\n    //    vec3(0.639, 0.345, 0.427),\n    //    vec3(0.231, 0.019, 0.039),\n    //    vec3(0.956, 0.529, 0.294),\n    //    vec3(0.956, 0.415, 0.305)  \n        vec3(0.501, 0.678, 0.443),\n        vec3(0.839, 0.741, 0.627),\n        vec3(0.749, 0.615, 0.478),\n        vec3(0.831, 0.862, 0.662),\n        vec3(0.921, 0.949, 0.917)\n    \n    );\n    \n\n    float count = 5.;\n    int idx = int( mod(iTime / count, count));\n    \n    currentShape = Pattern(uv, segments[idx], radius);\n    float m = mod(2., 1.);\n    col+= mix( cols[idx], cols[int(mod(float(idx+1),2.))], currentShape );\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tldyDj.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[44, 44, 73, 73, 137], [139, 139, 191, 191, 310], [312, 312, 372, 372, 458], [460, 460, 520, 520, 2010], [2013, 2013, 2070, 2120, 3018]]}
{"id": "tlGcDD", "name": "Fractal Warping", "author": "oneshade", "description": "Trying out iq's warping technique.", "tags": ["fractalnoise", "domainwarp"], "likes": 15, "viewed": 232, "published": "Public", "date": "1611078049", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Hue to RGB function from Fabrice's shadertoyunofficial blog:\n#define hue2rgb(hue) 0.6 + 0.6 * cos(6.3 * hue + vec3(0.0, 23.0, 21.0))\n\n// Hash from \"Hash without Sine\" by Dave_Hoskins (https://www.shadertoy.com/view/4djSRW):\n// I modified it to try avoiding some annoying symmetry hash13() appears to have on the xy plane.\nfloat noise(in vec3 p) {\n\tp = fract(p * 0.731 - p.x * 253.567);\n    p += dot(p + p, p.yzx + 33.33);\n    return fract((p.x + p.y) * p.z);\n}\n\nfloat snoise(in vec3 p) {\n    vec3 cell = floor(p);\n    vec3 local = fract(p);\n    local *= local * (3.0 - 2.0 * local);\n\n    float ldb = noise(cell);                       // Left, Down, Back\n    float rdb = noise(cell + vec3(1.0, 0.0, 0.0)); // Right, Down, Back\n    float ldf = noise(cell + vec3(0.0, 0.0, 1.0)); // Left, Down, Front\n    float rdf = noise(cell + vec3(1.0, 0.0, 1.0)); // Right, Down, Front\n    float lub = noise(cell + vec3(0.0, 1.0, 0.0)); // Left, Up, Back\n    float rub = noise(cell + vec3(1.0, 1.0, 0.0)); // Right, Up, Back\n    float luf = noise(cell + vec3(0.0, 1.0, 1.0)); // Left, Up, Front\n    float ruf = noise(cell + 1.0);                 // Right, Up, Front\n\n    return mix(mix(mix(ldb, rdb, local.x),\n                   mix(ldf, rdf, local.x),\n                   local.z),\n\n               mix(mix(lub, rub, local.x),\n                   mix(luf, ruf, local.x),\n                   local.z),\n\n               local.y);\n}\n\nfloat fnoise(in vec3 p, in float scale, in float octaves) {\n    p *= scale;\n\n    float value = 0.0;\n    float nscale = 1.0;\n    float tscale = 0.0;\n\n    for (float octave=0.0; octave < octaves; octave++) {\n        value += snoise(p) * nscale;\n        tscale += nscale;\n        nscale *= 0.5;\n        p *= 2.0;\n    }\n\n    return value / tscale;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n    float time = iTime * 0.25;\n\n    // iq's domain warping technique:\n    float warp = 0.0;\n    for (int i=0; i < 5; i++) {\n        warp = fnoise(vec3(uv, time) + warp, 2.0, 5.0);\n    }\n\n    fragColor = vec4(hue2rgb(warp), 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tlGcDD.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[137, 325, 349, 349, 463], [465, 465, 490, 490, 1414], [1416, 1416, 1475, 1475, 1761], [1763, 1763, 1818, 1818, 2115]]}
{"id": "tlGcDh", "name": "circle circulation", "author": "YitingLiu", "description": "Creating the movements of circles using matrices. ", "tags": ["circle", "fract", "cirulation"], "likes": 0, "viewed": 134, "published": "Public API", "date": "1610909244", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Author @patriciogv - 2015\n\n\nfloat circle(in vec2 _st, in float _radius){\n    // vec2 l = _st-vec2(0.5);\n    vec2 l = _st-vec2(1.0*abs(sin(iTime)));\n    return 1.-smoothstep(_radius-(_radius*0.01),\n                         _radius+(_radius*0.01),\n                         dot(l/2.,l)*4.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n\tvec2 st = fragCoord.xy/iResolution.xy;\n    vec3 color = vec3(0.726,0.855,0.013);\n    float rep = 10.;\n    \n    // why the if statement does not work\n    // how to create increments \n    if(rep<= 3.){\n        rep = 3.;       \n        rep++;\n\n    }\n    if (rep >= 10.){\n        rep = 10.; \n        rep--;\n    }\n    \n    st*=rep;\n\n    // Scale up the space by 3\n    st = fract(st); // Wrap around 1.0\n\n    // Now we have 9 spaces that go from 0-1\n\n    color += vec3(st,st.x);\n    color /= vec3(circle(st,0.5));\n    color += vec3(circle(st/0.5,0.5));\n    color -= vec3(circle(st/2.5,0.252));\n    color += vec3(circle(st/0.080,0.524));\n\n\tfragColor = vec4(color,1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tlGcDh.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 31, 75, 106, 293], [295, 295, 351, 351, 1016]]}
{"id": "tlGcR3", "name": "otherworld galaxy", "author": "YitingLiu", "description": "The sun is a pancake in another world. I created another galaxy in my mind. ", "tags": ["noise", "time", "sin", "color", "circle", "rotate", "cos", "galaxy", "distance", "radius", "pancake", "shadershop"], "likes": 1, "viewed": 166, "published": "Public API", "date": "1611412573", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// 2D Noise exercise with distance field \n\n\n#define PI 3.14159265359\n// 2D Random\nfloat random (in vec2 st) {\n    return fract(sin(dot(st.xy,\n                         vec2(12.9898,78.233)))\n                 * 43758.5453123);\n}\n\n// 2D Noise based on Morgan McGuire @morgan3d\n// https://www.shadertoy.com/view/4dS3Wd\nfloat noise (in vec2 st) {\n    vec2 i = floor(st);\n    vec2 f = fract(st);\n\n    // Four corners in 2D of a tile\n    float a = random(i);\n    float b = random(i + vec2(1.0, 0.0));\n    float c = random(i + vec2(0.0, 1.0));\n    float d = random(i + vec2(1.0, 1.0));\n\n    // Smooth Interpolation\n\n    // Cubic Hermine Curve.  Same as SmoothStep()\n    vec2 u = f*f*(3.0-2.0*f);\n    // u = smoothstep(0.,1.,f);\n\n    // Mix 4 coorners percentages\n    return mix(a, b, u.x) +\n            (c - a)* u.y * (1.0 - u.x) +\n            (d - b) * u.x * u.y;\n}\n\nmat2 rotate2d(float _angle){\n    return mat2(cos(_angle),-sin(_angle),\n                sin(_angle),cos(_angle));\n}\n\nfloat circle (in vec2 _st, in float _radius, in float _size){\n    vec2 dist = _st-vec2(0.5);\n    return smoothstep(_radius-_radius*_size,_radius+_radius*_size,dot(dist,dist)*4.0) ;       \n}\n\n//shadershop function generation:http://tobyschachman.com/Shadershop/editor/\nfloat extension(in float x){\n        return ((abs( x/3. )) + floor( x / 3. / 4.22 ) + ((x / 3.)) + (fract( x / 3. ))) * 0.35;\n\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    vec2 st = (2.0 * fragCoord.xy - iResolution.xy) / min(iResolution.y, iResolution.x);\n    vec3 color=vec3(0.0);\n    \n    // assign color value to the vec3 color with the extension function\n    // smoothstep to create blur effect of the middle circle \n    \n    float colorVal = circle(st+0.5,extension(abs(cos(iTime))),random(vec2(10.)*smoothstep(0.,PI,tan(iTime))));\n    \n    // Scale the coordinate system to see\n    // some noise in action\n    \n    // find the center of the shortest side \n    st-=min(st.x/2.,st.y/2.);\n    st = rotate2d( sin(cos(iTime))*PI*(abs(cos(iTime))/1e2+1.)) * st/abs(sin(iTime));\n    vec2 pos = vec2(st*0.756*abs(tan(iTime))*10.);\n    st+=min(st.x/2.,st.y/2.);\n\n\n    st-=min(st.x/2.,st.y/2.);\n    st *= rotate2d( PI*(fract(iTime))/1e3+fract(sin(iTime))) * st/(0.1+abs(sin(iTime)));\n    st *= rotate2d( PI*(cos(iTime))/1e2+1.) * st/3.280;\n    // Use the noise function with distance field \n    float n = noise(pos)*distance(st-vec2(0.760,0.670)*abs(sin(iTime)),pos);\n    st+=min(st.x/2.,st.y/2.);\n    \n    // color manipulation based on time and shapes \n    color=vec3(n,colorVal*abs(cos(iTime)),random(st-vec2(1e2*iTime/2.)));\n    color*=vec3(st.x,colorVal*abs(cos(iTime))*st.y,random(st-vec2(clamp(abs(sin(iTime)),0.,0.8))));\n    color-=color*colorVal*10.;\n\n    fragColor = vec4(color+abs(cos(iTime)), 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tlGcR3.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[69, 82, 109, 109, 226], [228, 315, 341, 341, 858], [860, 860, 888, 888, 974], [976, 976, 1037, 1037, 1165], [1167, 1244, 1272, 1272, 1372], [1373, 1373, 1430, 1430, 2773]]}
{"id": "tlGcRt", "name": "Sharpening & Blurring in 1 Tap", "author": "iradicator", "description": "Single tap and hardware derivatives to approximate image filtering such as sharpening and blurring.", "tags": ["2d", "cheap", "filtering", "derivatives", "image", "blurring", "sharpening", "smoothness", "approximated"], "likes": 0, "viewed": 98, "published": "Public", "date": "1611539381", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Using hardware derivativs to approximate image sharpening / blurring using a single tap.\n//\n// Left side - sharpening\n// Middle - original image (bilinear filtering)\n// Right side - smoothing\n//\n// Based on ideas from Juan https://twitter.com/reduzio/status/1350895712494563329,\n// and GPU Pro 2 article - \"Shader Amortization using Pixel Quad Message Passing\" (PQA)\n//\n// Note image swimming with animation due to 2x2 quad \"point sampling\" nature of this technique.\n\nvec3 SharpenQuad2x2(in vec2 fragCoord, in vec3 v)\n{ \n    vec2 q = vec2(uvec2(fragCoord.xy) & uvec2(1));\n    q = 2.0 * q - vec2(1.0);    \n    v += 0.5 * dFdx(v) * q.x;\n    v += 0.5 * dFdy(v) * q.y;\n    return v;\n}\n\nvec3 SmoothQuad2x2(in vec2 fragCoord, in vec3 v)\n{ \n    vec2 q = vec2(uvec2(fragCoord.xy) & uvec2(1));\n    q = 2.0 * q - vec2(1.0);    \n    v -= 0.5 * dFdx(v) * q.x;\n    v -= 0.5 * dFdy(v) * q.y;\n    return v;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n\n    float lg = uv.x - (0.35*sin(iTime)+0.5) - 0.15;\n    float lr = uv.x - (0.35*sin(iTime)+0.5) + 0.15;\n\n#if 1 // Animated\n    uv = 0.8 * uv + vec2(0.1) + vec2(0.05*sin(0.5*iTime),0.08*cos(0.3*iTime));\n#endif\n\n    vec3 col = texture(iChannel0, uv).rgb;\n    vec3 col_sharpen = SharpenQuad2x2(fragCoord, col);\n    vec3 col_smooth = SmoothQuad2x2(fragCoord, col);\n    \n    col = mix(col_sharpen,col,smoothstep(0.0,2.0/iResolution.x,lr));\n    col = mix(col,col_smooth,smoothstep(0.0,2.0/iResolution.x,lg));\n\n    col = mix(vec3(0.6,0.2,0.15),col,smoothstep(0.0,2.0/iResolution.x,abs(lr)));\n    col = mix(vec3(0.2,0.6,0.15),col,smoothstep(0.0,2.0/iResolution.x,abs(lg)));\n\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": "4dfGRn", "previewfilepath": "/media/ap/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tlGcRt.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 471, 522, 522, 683], [685, 685, 735, 735, 896], [898, 898, 955, 955, 1696]]}
{"id": "tlGcW3", "name": "Fluffy's Breakfast", "author": "eiffie", "description": "reupload - see comments in code", "tags": ["socconetracing"], "likes": 16, "viewed": 325, "published": "Public API", "date": "1611853426", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// fluffy's breakfast by eiffie\n// Still re-uploading from having this done to me nonconsentually... \n// https://pubs.acs.org/doi/10.1021/nn5020616\n// ...high frequency subconscious messages, quiet effective when combined with torture\n// ...the method is actually derived from witchcraft which uses lodestone powder\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n// using massive DoF to march around this little guy's furry butt\n\nconst float focalDistance=1.0,aperature=0.07,fudgeFactor=0.9;\n\n#define size iResolution\n#define time iTime\n\n//handy routines from iq\nfloat smin(float a,float b,float k){return -log(exp(-k*a)+exp(-k*b))/k;}//negative k gives int and dif\nfloat Ellipsoid(vec3 z, vec4 r){float f=length(z*r.xyz);return f*(f-r.w)/length(z*r.xyz*r.xyz);}\nfloat Segment(vec3 p, vec3 p0, vec3 p1, float r){vec3 v=p1-p0;v*=clamp(dot(p-p0,v)/dot(v,v),0.0,1.0);return distance(p-p0,v)-r;}\nfloat Cone(in vec3 z, vec2 r){return max(abs(z.y)-r.y,(length(z.xz)-r.x*clamp(r.y-abs(z.y),0.0,r.y))/(1.0+r.x/r.y));}\nvec4 seg4( vec3 pa, vec3 ba )//iq's tube returning nearest point and distance along segment\n{//same as tube except it lets you shape the result with dot(j.xyz,rt) and j.w\n float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n return vec4(pa - ba*h,h);\n}\n// See http://www.iquilezles.org/www/articles/morenoise/morenoise.htm for a proper version :)\nfloat hash(float n) {return fract(sin(n) * 43758.5453123);}\nfloat noyz(vec2 x) {//simple version\n vec2 p=floor(x),f=fract(x),u=f*f*(3.0-2.0*f);\n const float tw=117.0;\n float n=p.x+p.y*tw,a=hash(n),b=hash(n+1.0),c=hash(n+tw),d=hash(n+tw+1.0);\n return a+(b-a)*u.x+(c-a)*u.y+(a-b-c+d)*u.x*u.y;\n}\nfloat fbm(vec2 p) {return 0.5*noyz(p)+0.3*noyz(p*2.3)+0.2*noyz(p*3.7);}\n\nfloat RCyl(in vec3 z, vec3 r){return length(max(vec2(abs(z.z)-r.y,length(z.xy)-r.x),0.0))-r.z;}\n\nfloat linstep(float a, float b, float t){return clamp((t-a)/(b-a),0.,1.);}// i got this from knighty and/or darkbeam\nfloat rand(vec2 co){// implementation found at: lumina.sourceforge.net/Tutorials/Noise.html\n return fract(sin(dot(co*0.123,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nfloat headbob,tailwag;\nfloat DE(in vec3 p)\n{\n vec3 z=p+vec3(0.0,1.2,2.5);\n float dB=Cone(z,vec2(0.75,1.5));//dog bowl\n dB=smin(dB,-length(z+vec3(0.0,-1.215,0.0))+1.08,-64.0);//smooth difference to scoop out bowl\n float dF=z.y;  //floor\n float d=Ellipsoid(p,vec4(1.4,1.4,1.0,1.0)); //body\n vec4 j=seg4(p+vec3(0.0,-0.58,-1.0),vec3(tailwag,0.68,0.0));//create tail segment\n j.z-=sin(j.w*3.1416)*0.1;//add a curve to the tail\n float d2=length(j.xyz); //tail distance\n vec2 uv=vec2(atan(p.z,p.x),p.y); //basic fur pattern\n p.x=abs(p.x);\n uv.xy=mix(vec2(uv.x+(p.y-0.32)*1.3,p.y+d2*3.3),uv.xy,smoothstep(0.0,0.25,d2));//changing fur direction for tail\n float d3=min(d2,RCyl(p+vec3(-0.4,headbob,1.35),vec3(0.15,0.0,0.02))); //ears\n uv.y=mix(p.y+d3*3.3,uv.y,smoothstep(0.0,0.51,d3));//changing fur direction for ears\n d2=min(d2,d3);\n float h=fbm(uv*25.0); \n p.z=abs(p.z);\n d2=min(d2,Ellipsoid(p+vec3(-0.45,0.78,-0.63),vec4(2.0,1.0,2.0,0.07))); //feet\n d=(smin(d2,d,8.0)-h*0.2)*0.5; //smooth together and add fur\n return min(d,min(dB,dF)); //return closest object\n}\nvec3 mcol;\nfloat CE(vec3 p){//same for coloring\n vec3 z=p+vec3(0.0,1.2,2.5);\n float dB=Cone(z,vec2(0.75,1.5));\n dB=smin(dB,-length(z+vec3(0.0,-1.215,0.0))+1.08,-64.0);\n float dF=z.y;\n float d=Ellipsoid(p,vec4(1.4,1.4,1.0,1.0));\n vec4 j=seg4(p+vec3(0.0,-0.58,-1.0),vec3(tailwag,0.68,0.0));\n j.z-=sin(j.w*3.1416)*0.1;\n float d2=length(j.xyz);\n vec2 uv=vec2(atan(p.z,p.x),p.y);\n p.x=abs(p.x);\n uv.xy=mix(vec2(uv.x+(p.y-0.32)*tailwag*1.3,p.y+d2*3.3),uv.xy,smoothstep(0.0,0.25,d2));//changing the direction for ears\n float d3=min(d2,RCyl(p+vec3(-0.4,headbob,1.35),vec3(0.15,0.0,0.02)));\n uv.y=mix(p.y+d3*3.3,uv.y,smoothstep(0.0,0.51,d3));\n d2=min(d2,d3);\n float h=fbm(uv*25.0);\n p.z=abs(p.z);\n d2=min(d2,Ellipsoid(p+vec3(-0.45,0.78,-0.63),vec4(2.0,1.0,2.0,0.07)));\n float d1=(smin(d2,d,8.0)-h*0.2)*0.5;\n d=min(d1,min(dB,dF));\n if(abs(d-dB)<0.001)mcol+=vec3(0.9,0.9,0.2);\n else if(abs(d-dF)<0.001){mcol+=vec3(1.0,0.4+noyz(z.xz*vec2(50.0,1.0))*0.4,0.4)*(0.4+0.6*clamp(d1*3.0,0.0,1.0));}\n else mcol+=vec3(0.7,0.5,0.3)*h+vec3(-p.y*0.5);\n return d;\n}\n\nfloat pixelSize;\nfloat CircleOfConfusion(float t){//calculates the radius of the circle of confusion at length t\n return max(abs(focalDistance-t)*aperature,pixelSize*t);\n}\nmat3 lookat(vec3 fw,vec3 up){\n fw=normalize(fw);vec3 rt=normalize(cross(fw,normalize(up)));return mat3(rt,cross(rt,fw),fw);\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n pixelSize=1.0/size.y;\n headbob=-0.6+abs(sin(time*9.0)*sin(time*3.5))*0.1;\n tailwag=sin(time*14.0)*0.1;\n vec3 ro=vec3(-1.5,0.15,2.75)+vec3(cos(time),sin(time*0.7)*0.5,sin(time))*0.25;\n vec3 rd=lookat(-ro,vec3(0.0,1.0,0.0))*normalize(vec3((2.0*fragCoord.xy-size.xy)/size.y,2.0));\n vec3 L=normalize(ro+vec3(0.5,2.5,0.5));\n vec4 col=vec4(0.0);//color accumulator\n float t=0.0;//distance traveled\n for(int i=1;i<48;i++){//march loop\n  if(col.w>0.9 || t>7.0)continue;//bail if we hit a surface or go out of bounds\n  float rCoC=CircleOfConfusion(t);//calc the radius of CoC\n  float d=DE(ro)+0.25*rCoC;\n  if(d<rCoC){//if we are inside add its contribution\n   vec3 p=ro;//-rd*abs(d-rCoC);//back up to border of CoC\n   mcol=vec3(0.0);//clear the color trap, collecting color samples with normal deltas\n   vec2 v=vec2(rCoC*0.5,0.0);//use normal deltas based on CoC radius\n   vec3 N=normalize(vec3(-CE(p-v.xyy)+CE(p+v.xyy),-CE(p-v.yxy)+CE(p+v.yxy),-CE(p-v.yyx)+CE(p+v.yyx)));\n   //if(dot(N,rd)<0.0){//doesn't seem to matter??\n    vec3 scol=mcol*0.1666*(0.7+0.3*dot(N,L));//do some fast light calcs (you can forget about shadow casting, too expensive)\n    scol+=pow(max(0.0,dot(reflect(rd,N),L)),8.0)*vec3(1.0,0.5,0.0);\n    float alpha=fudgeFactor*(1.0-col.w)*linstep(-rCoC,rCoC,-d);//calculate the mix like cloud density\n    col+=vec4(scol*alpha,alpha);//blend in the new color\n   //}\n  }\n  d=abs(fudgeFactor*d*(0.7+0.2*rand(fragCoord.xy*vec2(i))));//add in noise to reduce banding and create fuzz\n  ro+=d*rd;//march\n  t+=d;\n }//mix in background color\n vec3 scol=mix(vec3(0.025,0.1,0.05)+rd*0.025,vec3(0.1,0.2,0.3)+rd*0.1,smoothstep(-0.1,0.1,rd.y));\n col.rgb+=scol*(1.0-clamp(col.w,0.0,1.0));\n\n fragColor = vec4(clamp(col.rgb,0.0,1.0),1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tlGcW3.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[578, 603, 639, 639, 675], [675, 706, 738, 738, 802], [803, 803, 852, 852, 931], [932, 932, 962, 962, 1049], [1050, 1050, 1143, 1220, 1302], [1303, 1397, 1418, 1418, 1456], [1457, 1457, 1477, 1493, 1689], [1690, 1690, 1709, 1709, 1761], [1763, 1763, 1793, 1793, 1858], [1860, 1860, 1901, 1901, 1934], [1934, 1977, 1997, 2068, 2139], [2164, 2164, 2185, 2185, 3196], [3208, 3208, 3225, 3244, 4237], [4256, 4256, 4289, 4351, 4410], [4411, 4411, 4440, 4440, 4536], [4537, 4537, 4594, 4594, 6327]]}
{"id": "tlGcWD", "name": "Depth of Civilization", "author": "blurryroots", "description": "A mix of two shaders by jarble:\nAutomaton: https://www.shadertoy.com/view/WljcRG\nBackground pattern: https://www.shadertoy.com/view/ttjXDK", "tags": ["remix", "pattern", "automaton", "jarble"], "likes": 4, "viewed": 209, "published": "Public API", "date": "1611019079", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec3 hash32(vec2 p) {\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+33.33);\n    return fract((p3.xxy+p3.yzz)*p3.zyx);\n}\n\nvec3 magnify(vec2 fragCoord,float mag){\n\treturn hash32(floor(fragCoord/pow(2.0,mag)));\n}\n\n//modified from https://www.shadertoy.com/view/wtlcR8\nvoid mainImage(out vec4 O, vec2 U) {\n  int x = int(U),\n      y = int(U.y + 30. * iTime),\n      r = (x)^(y);\n   O = vec4( abs(r*r*r)/(y+int(iTime*50.)) % 9970 < 1000 );\n   \n   vec3 color1 = 0.*vec3(.1,.1,.1);\n    float maximum = 1.0+5.*(.5*sin(iTime/10.0)+.5);\n    for(float i = 0.0; i < maximum; i+=0.618){\n    \tcolor1 += magnify(U,i+2.0);\n    }\n    O = O-vec4(color1/(maximum+0.),0.1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tlGcWD.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 21, 21, 157], [159, 159, 198, 198, 247], [249, 303, 339, 339, 691]]}
{"id": "tlGcWw", "name": "mandelbulb ray", "author": "milez770", "description": "- half cut \nSOLVED@!!: you need to abs(p) after coordinates calculation, or you will get a half split bulb\n- color\ntook a look at iq's logic. didn't fully understand thou...\n\nTo do\n-  background artifact (no idea)", "tags": ["raymarch", "kifs"], "likes": 2, "viewed": 51, "published": "Public", "date": "1611235895", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define ITER 3\n#define MAX_STEPS 100\n#define MAX_DIST 10.\n#define SURF_DIST 0.002\n#define SPEED 2.\n\nfloat dist(vec2 p, vec2 t){\n    float dx = p.x-t.x;\n    float dy = p.y-t.y;\n    return sqrt(dx*dx+dy*dy);\n}\n\n// 3d mandelbulb\nfloat mandel3(in vec3 v, out vec3 map){\n    vec3 r = v;\n    vec3 rNext = r;\n    float m = dot(v, v);\n    vec4 trap = vec4(abs(r), m);\n    \n    int i = 0;\n    float d = 1.;\n    \n    float n =  7.;\n    \n    for(i=0; i<ITER; i++){\n        float cr = length(r);\n        float nr = pow(cr, n);\n        //*abs(sin(iTime/5.) )\n        float accos = acos(r.z/cr*abs( sin(iTime/2.)*.2+.8 ));\n        float actan = atan(r.y/r.x);\n        \n        d = pow(cr, n-1.) *n * d + 1.0;\n        \n        rNext.x = nr*sin(accos*n)*cos(n*actan);\n        rNext.y = nr*sin(accos*n)*sin(n*actan);\n        rNext.z = nr*cos(n*accos);\n        r = v + rNext;\n        \n        trap = min(trap, vec4(abs(r), m));\n        map = vec3(trap.yzw);\n\n        m = dot(r,r);\n        \n        if(m > 256.){\n            break;\n        }\n    }\n    \n    return  .25*log(m) * sqrt(m) / d;\n}\n\nmat2 Rot(float a) {\n    float s = sin(a);\n    float c = cos(a);\n    return mat2(c, -s, s, c);\n}\n\nvec3 R(vec2 uv, vec3 p, vec3 l, float z) {\n    vec3 f = normalize(l-p),\n        r = normalize(cross(vec3(0,1,0), f)),\n        u = cross(f,r),\n        c = p+f*z,\n        i = c + uv.x*r + uv.y*u,\n        d = normalize(i-p);\n    return d; \n}\n\nfloat RayMarch(in vec3 ro, in vec3 rd, out vec3 col){\n    float dO = 0.;\n    \n    for(int i=0; i<MAX_STEPS; i++){\n        vec3 p = ro+rd*dO;\n        p.xz *= Rot(iTime/SPEED);\n        p.yz *= Rot(iTime/SPEED-2.);\n\n        float mbd = mandel3(abs(p), col);\n        float dS = mbd;\n        \n        if(dO > MAX_DIST || dS<SURF_DIST) break;\n        dO += dS;\n    }\n    \n    return dO;\n}\nvec3 GetNormal(vec3 p){\n    vec3 col;\n    // my e value made black artifacts\n    // so I took a look at iq's normal epsilone. \n    // don't exactly know how this is calculated.\n    // looks like it is relevant to some screen pixel size calculation..?\n    vec2 e = vec2(1.0,-1.0)*0.5773*0.25*2.0/(iResolution.y*1.5);\n    \n    // getting vector with very small vector\n    vec3 n = vec3(\n        e.xyy*mandel3(p+e.xyy, col)+\n        e.yxy*mandel3(p+e.yxy, col)+\n        e.yyx*mandel3(p+e.yyx, col)+\n        e.xxx*mandel3(p + e.xxx,col ) \n    );\n    \n    return normalize(n);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord.xy-.5*iResolution.xy)/(iResolution.y);\n    vec2 m = iMouse.xy/iResolution.xy;\n    vec3 col = vec3(0);\n    \n    vec3 ro = vec3(0,1.3, 1.3);\n    vec3 rd = R(uv, ro, vec3(0,0,0), .7);\n    \n    vec3 backgrounduv;\n    \n    col = vec3(.05, .12, .1);\n    float d = RayMarch(ro, rd, backgrounduv);\n    col *= 3.-d;\n    col += pow(clamp(backgrounduv.z, 0., .97), 10.)*vec3(.8, .1, .1);\n    \n    //light\n    vec3 lp = vec3(1000, 1, 0);\n    lp.xz *= Rot(iTime/3.);\n    lp.yz *= Rot(iTime/3.);\n    vec3 lr = ro+rd*d;\n    lr.xz *= Rot(iTime/SPEED);\n    lr.yz *= Rot(iTime/SPEED-2.);\n    lr = abs(lr);\n    vec3 l = normalize(lp - lr);\n    vec3 n = GetNormal(lr);\n    float shadow = clamp(dot(n, l), 0.2, 1.);\n    shadow *= 1.;\n    col += vec3(0.007); \n    col *= vec3(pow(shadow, 1.5));\n    \n    fragColor = vec4(col, 0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tlGcWw.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[100, 100, 127, 127, 207], [209, 226, 265, 265, 1073], [1075, 1075, 1094, 1094, 1170], [1172, 1172, 1214, 1214, 1410], [1412, 1412, 1465, 1465, 1794], [1795, 1795, 1818, 1818, 2368], [2370, 2370, 2427, 2427, 3262]]}
{"id": "tlGyRc", "name": "Naive SDF voxel grid #2", "author": "DragonWolf", "description": "Determines if an  SDF voxel grid using brute force (pixel by pixel) determination for grids that are potentially touching or inside an SDF object. Gives a much better framerate, as voxels outside and inside the grid tend to only require 2x check on SDF.", "tags": ["sdfvoxel"], "likes": 3, "viewed": 105, "published": "Public", "date": "1611420807", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define gridSize 10.0\n\nfloat sdBox( vec2 uv, vec2 position, in vec2 bounds )\n{\n    vec2 d = abs(position - uv)-bounds;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\nfloat sdCircle(vec2 uv, vec2 pos, float radius) {\n    return length(uv - pos) - radius;\n}\n\nfloat sdf(vec2 uv) {\n    float radius1 = 0.4 * (1.0 + sin(iTime * 0.6));\n    vec2 position1 = vec2(sin(iTime * 0.3), sin(iTime * 0.2));\n    float circle1 = sdCircle(uv, position1, radius1);   \n    \n    float radius2 = 0.3 * (1.0 + sin(iTime * 0.1));\n    vec2 position2 = vec2(sin(iTime * 0.2), sin(iTime * 0.5));\n    float circle2 = sdCircle(uv, position2, radius2);   \n    \n    return min(circle1, circle2);\n}\n    \nbool insideBoundingSquare(vec2 position, vec2 bound, vec2 pixelSize) {\n\n    // If all points inside the grid's outer circle are negative, then we're definitely inside.\n    float midpointD = sdf(position);\n    if (midpointD < -2.0 * length(bound)) {\n        return true;\n    }\n\n    float i = 0.;\n    float pixelsHigh = (2.0 * bound.y / pixelSize.y);\n    vec2 rd = vec2(1.0, 0.0);\n    vec2 ro = position - bound;\n    while (i < pixelsHigh) {\n        i += 1.0;\n        ro.y += pixelSize.y;\n        vec2 pos = ro;\n        float dist = 0.;\n        while (dist < bound.x * 2.0) {\n            float d = sdf(pos);\n            d = clamp(d, 0., 100.);\n            if (d > pixelSize.x) {\n                return false;\n            }\n            \n            if (d < pixelSize.x) {\n                d = pixelSize.x;\n            }\n            \n            dist += d;\n            pos = ro + rd * dist;\n        }  \n    }\n    \n    return true;\n}\n\nbool touchingBoundingSquare(vec2 position, vec2 bound, vec2 pixelSize) {\n\n    // If all points inside the grid's outer circle are outside,\n    // then we're definitely outside and not touching.\n    float midpointD = sdf(position);\n    if (midpointD > 2.0 * length(bound)) {\n        return false;\n    }\n\n    float i = 0.;\n    float pixelsHigh = (2.0 * bound.y / pixelSize.y);\n    vec2 rd = vec2(1.0, 0.0);\n    vec2 ro = position - bound;\n    while (i < pixelsHigh) {\n        i += 1.0;\n        ro.y += pixelSize.y;\n        vec2 pos = ro;\n        float dist = 0.;\n        while (dist < bound.x * 2.0) {\n            float box1 = sdBox(pos, position, bound);\n            float d = sdf(pos);\n            d = abs(max(abs(d), box1));\n            if (d <= pixelSize.x) {\n                return true;\n            }\n            \n            if (d < pixelSize.x) {\n                d = pixelSize.x;\n            }\n            \n            dist += d;\n            pos = ro + rd * dist;\n        }  \n    }\n    \n    return false;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    \n    vec2 uv = 2.0 * (fragCoord - (0.5*iResolution.xy))/iResolution.y;\n    vec2 pixelSize = 2.0 * ((vec2(iResolution.x, iResolution.y) - (0.5*iResolution.xy))/iResolution.y) / iResolution.xy;\n    \n    // Calculate SDF\n    float d = sdf(uv);\n\n    // Bounding Box\n    vec2 voxelMidpoint = vec2((floor(uv.x * gridSize) / gridSize) + (0.5 / gridSize), (floor(uv.y * gridSize) / gridSize) + (0.5 / gridSize));\n    vec2 voxelSize = vec2(0.5 / gridSize, 0.5 / gridSize);\n    vec2 minExtent = voxelMidpoint - voxelSize;\n    vec2 maxExtent = voxelMidpoint + voxelSize;\n    float box1 = sdBox(uv, voxelMidpoint, voxelSize);\n    \n    // Work out if the SDF is inside the box or not.\n    bool inside = insideBoundingSquare(voxelMidpoint, voxelSize, pixelSize);\n    bool touching = touchingBoundingSquare(voxelMidpoint, voxelSize, pixelSize);\n    bool outside = !touching;\n\n    vec3 statusColor = vec3(1.0, 1.0, 0.0);\n    if (inside) {\n        statusColor = vec3(0.0, 1.0, 0.0);\n    } else if (outside) {\n        statusColor = vec3(1.0, 0.0, 0.0);\n    }\n\n    // Set base colour depending on inside or outside bounding box.\n    vec3 baseColor = vec3(0.1,0.4,0.7);\n    if (uv.x > minExtent.x && uv.x < maxExtent.x && uv.y > minExtent.y && uv.y < maxExtent.y) {\n        baseColor = vec3(0.8,0.2,0.2);\n    }\n   \n    // Taken from iq to visualize sdf distances (https://www.shadertoy.com/view/4lcBWn)    \n    vec3 col = vec3(1.0) - sign(d)*baseColor;\n\tcol *= 1.0 - exp(-3.0*abs(d));\n\tcol *= 0.8 + 0.2*cos(120.0*d);\n\tcol = mix( col, vec3(1.0), 1.0-smoothstep(0.0,0.008,abs(d)));\n    \n    // Add the grid\n    col = mix( col, statusColor, 1.0-smoothstep(0.0,0.008,abs(box1)) );\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tlGyRc.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[23, 23, 78, 78, 175], [177, 177, 226, 226, 266], [268, 268, 288, 288, 678], [684, 684, 754, 851, 1611], [1613, 1613, 1685, 1806, 2625], [2627, 2627, 2684, 2734, 4458]]}
{"id": "tlGyRR", "name": "Heightmap land", "author": "regis", "description": "Mountain", "tags": ["raymarch", "heightmap", "mountain"], "likes": 1, "viewed": 86, "published": "Public", "date": "1610389314", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec4 tpos = vec4(0.0, 0.0, 0.0, 0.0);\nfloat angle_tpos;\nbool done = false;\nfloat dist = 0.0;\n\nmat2 Rot(float a){float s = sin(a);float c = cos(a);return mat2(c, -s, s, c);}\nmat3 RotX(float a){float s = sin(a);float c = cos(a);return mat3(1., .0, .0, .0, c, -s, .0, s, c);}\nmat3 RotY(float a){float s = sin(a);float c = cos(a);return mat3(c, .0, s, .0, 1., .0, -s, .0, c);}\nmat3 RotZ(float a){float s = sin(a);float c = cos(a);return mat3(c, -s, .0, s, c, .0, .0, .0, 1.);}\n\n\n\nfloat opExtrusion(in vec3 p, in float d, in float h) {\n    // d is the distance to the 2D shape using the x and y components of p\n    vec2 w = vec2(d, abs(p.z) - h);\n    return min(max(w.x, w.y), 0.0) + length(max(w, 0.0));\n}\n\n/*\nvec4 opElongate( in vec3 p, in vec3 h )\n{\n    //return vec4( p-clamp(p,-h,h), 0.0 ); // faster, but produces zero in the interior elongated box\n    \n    vec3 q = abs(p)-h;\n    return vec4( max(q,0.0), min(max(q.x,max(q.y,q.z)),0.0) );\n}\n*/\n\nvec3 opTwist(in vec3 p, in float t) {\n    float c = cos(t * p.y);\n    float s = sin(t * p.y);\n    mat2 m = mat2(c, -s, s, c);\n    return vec3(m * p.xz, p.y);\n}\n\n// from iq\nfloat Noise( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n  \tf = f*f*(3.0-2.0*f);\n  \tvec2 uv = (p.xy+vec2(37.0,17.0)*p.z) + f.xy;\n  \tvec2 rg = textureLod( iChannel0, (uv+0.5)/256.0, 0.0).yx;\n  \treturn mix( rg.x, rg.y, f.z );\n}\n\n// ref https://www.shadertoy.com/view/Xs33Df\nfloat Noise3D(in vec3 p){\n    const vec3 s = vec3(7, 157, 113);\n\tvec3 ip = floor(p); // Unique unit cell ID.\n    vec4 h = vec4(0., s.yz, s.y + s.z) + dot(ip, s);\n\tp -= ip; // Cell's fractional component.\n    p = p*p*(3. - 2.*p);\n    h = mix(fract(sin(h)*43758.5453), fract(sin(h + s.x)*43758.5453), p.x);\n    h.xy = mix(h.xz, h.yw, p.y);\n    return mix(h.x, h.y, p.z); // Range: [0, 1].\n\t\n}\n\nvec2 hash( vec2 p )\n{\n\tp = vec2( dot(p,vec2(127.1,311.7)),\n\t\t\t dot(p,vec2(269.5,183.3)) );\n\treturn -1.0 + 2.0*fract(sin(p)*43758.5453123);\n}\n\nfloat noise( in vec2 p )\n{\n\tconst float K1 = 0.366025404; // (sqrt(3)-1)/2;\n\tconst float K2 = 0.211324865; // (3-sqrt(3))/6;\n\t\n\tvec2 i = floor( p + (p.x+p.y)*K1 );\n\t\n\tvec2 a = p - i + (i.x+i.y)*K2;\n\tvec2 o = (a.x>a.y) ? vec2(1.0,0.0) : vec2(0.0,1.0);\n\tvec2 b = a - o + K2;\n\tvec2 c = a - 1.0 + 2.0*K2;\n\t\n\tvec3 h = max( 0.5-vec3(dot(a,a), dot(b,b), dot(c,c) ), 0.0 );\n\t\n\tvec3 n = h*h*h*h*vec3( dot(a,hash(i+0.0)), dot(b,hash(i+o)), dot(c,hash(i+1.0)));\n\t\n\treturn dot( n, vec3(70.0) );\n}\n\nfloat fbm(vec2 uv)\n{\n\tfloat f;\n\tmat2 m = mat2( 1.6,  1.2, -1.2,  1.6 );\n\tf  = 0.5000*noise( uv ); uv = m*uv;\n\tf += 0.2500*noise( uv ); uv = m*uv;\n\tf += 0.1250*noise( uv ); uv = m*uv;\n\tf += 0.0625*noise( uv ); uv = m*uv;\n\tf = 0.5 + 0.5*f;\n\treturn f;\n}\n\nfloat FBM( in vec3 p )\n{\n    float n = 0.0;\n    n += 0.50000*Noise( p*1.0 );\n    n += 0.25000*Noise( p*2.0 );\n    n += 0.12500*Noise( p*4.0 );\n    n += 0.06250*Noise( p*8.0 );\n    n += 0.03125*Noise( p*16.0 );\n    return n/0.984375;\n}\n\nfloat WaterMap( vec3 pos ) {\n    return FBM( vec3( pos.xz, iTime*0.3 )) * 1.;\n}\nvec3 WaterNormal(vec3 pos,float rz){\n    float EPSILON =rz*rz* 0.002;\n    vec3 dx = vec3( EPSILON, 0.,0. );\n    vec3 dz = vec3( 0.,0., EPSILON );\n      \n    vec3  normal = vec3( 0., 1., 0. );\n    float bumpfactor = 0.3 * pow(1.-clamp((rz)/1000.,0.,1.),6.);//\n    \n    normal.x = -bumpfactor * (WaterMap(pos + dx) - WaterMap(pos-dx) ) / (2. * EPSILON);\n    normal.z = -bumpfactor * (WaterMap(pos + dz) - WaterMap(pos-dz) ) / (2. * EPSILON);\n    return normalize( normal ); \n}\n\nfloat sdCylinder(vec3 p, vec3 a, vec3 b, float r) {\n\tvec3 ab = b-a;\n    vec3 ap = p-a;\n    \n    float t = dot(ab, ap) / dot(ab, ab);\n    //t = clamp(t, 0., 1.);\n    \n    vec3 c = a + t*ab;\n    \n    float x = length(p-c)-r;\n    float y = (abs(t-.5)-.5)*length(ab);\n    float e = length(max(vec2(x, y), 0.));\n    float i = min(max(x, y), 0.)-0.1;\n    \n    return e+i;\n}\n\nfloat sdRoundBox( vec3 p, vec3 b, float r )\n{\n  vec3 q = abs(p) - b;\n  return -(length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0) - r);\n}\n\nfloat Box(vec3 p, vec3 sc, float r){\n    return length(max(abs(p)-sc, 0.))-r;\n}\n\nfloat Box2(vec3 p, vec3 sc, float r, float an){\n    an = 80.0;\n    vec3 cs = vec3(cos(an*3.1415/180.0), sin(an*3.1415/180.0),cos(an*3.1415/180.0));\n    float c2 = length(cs);\n    \n    float a = length(max( abs(p)-(sc)  , 0.0)) - r;\n    float b = length(max(abs(p)-vec3(1.0, 2.0, 1.0), 0.));\n    return a;\n}\n\nfloat Capsule(vec3 p, vec3 sc, float r){\n    vec3 cs = vec3(cos(90.0*3.1415/180.0), sin(90.0*3.1415/180.0),cos(90.0*3.1415/180.0));  \n    float a = length(max( abs(p)- (sc*cs)  , 0.0)) - r;\n    return a;\n}\n\nfloat opRep( in vec3 p, in vec3 c, vec3 sc, float r )\n{\n    vec3 q = mod(p+0.5*c,c)-0.5*c;\n    return Box( q, sc, r );\n}\n\nfloat opRepS( in vec3 p, in vec3 c, vec4 pos )\n{\n    vec3 q = mod(p+0.5*c,c)-0.5*c;\n    return length(q) - pos.w;\n}\n\nvec3 add_tpos(vec3 tp){\n    return vec3(tp.x+tpos.x, tp.y+tpos.y, tp.z+tpos.z);\n    \n}\n\nvec3 rot_y(vec3 tp, float a){\n    tp.xz *= Rot(a);\n    return tp;\n\n}\n\nfloat noi(vec3 p){ \n  vec3 f=floor(p),s=vec3(7,157,113);\n  p-=f; vec4 h=vec4(0,s.yz,s.y+s.z)+dot(f,s);;\n  p=p*p*(3.-2.*p);\n  h=mix(fract(sin(h)*43758.5),fract(sin(h+s.x)*43758.5),p.x);\n  h.xy=mix(h.xz,h.yw,p.y);\n  return mix(h.x,h.y,p.z);  \n}\nvec2 add = vec2(1.0, 0.0);\n#define HASHSCALE1 .1031\n#define HASHSCALE3 vec3(.1031, .1030, .0973)\n#define HASHSCALE4 vec4(1031, .1030, .0973, .1099)\n\nfloat Hash12(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * HASHSCALE1);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\nvec2 Hash22(vec2 p)\n{\n\tvec3 p3 = fract(vec3(p.xyx) * HASHSCALE3);\n    p3 += dot(p3, p3.yzx+19.19);\n    return fract((p3.xx+p3.yz)*p3.zy);\n\n}\n\nfloat Noise( in vec2 x )\n{\n    vec2 p = floor(x);\n    vec2 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n    \n    float res = mix(mix( Hash12(p),          Hash12(p + add.xy),f.x),\n                    mix( Hash12(p + add.yx), Hash12(p + add.xx),f.x),f.y);\n    return res;\n}\n\nvec2 Noise2( in vec2 x )\n{\n    vec2 p = floor(x);\n    vec2 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n    float n = p.x + p.y * 57.0;\n   vec2 res = mix(mix( Hash22(p),          Hash22(p + add.xy),f.x),\n                  mix( Hash22(p + add.yx), Hash22(p + add.xx),f.x),f.y);\n    return res;\n}\nconst mat2 rotate2D = mat2(1.3623, 1.7531, -1.7131, 1.4623);\nfloat Terrain( in vec2 p)\n{\n\tvec2 pos = p*0.05;\n\tfloat w = (Noise(pos*.25)*0.75+.15);\n\tw = 66.0 * w * w;\n\tvec2 dxy = vec2(0.0, 0.0);\n\tfloat f = .0;\n\tfor (int i = 0; i < 5; i++)\n\t{\n\t\tf += w * Noise(pos);\n\t\tw = -w * 0.4;\t//...Flip negative and positive for variation\n\t\tpos = rotate2D * pos;\n\t}\n\tfloat ff = Noise(pos*.002);\n\t\n\tf += pow(abs(ff), 5.0)*275.-5.0;\n\treturn f;\n}\n\nfloat TerrainRM(in vec2 p){\n\n    vec2 q = p * 0.05;\n    float w = Noise(q);\n    w = 50.0*w;\n    float f = 0.0;\n    for(int i = 0;i < 5;i++){\n        f += w * Noise(q*0.85);\n        w = -w * 0.4;\n        q = rotate2D * q;\n    \n    }\n    \n    float ff = Noise(q * 0.002);\n    f += ff*250.-80.0;\n   \n    return f;\n\n\n}\n\nfloat TerrainRM2(in vec2 p){\n\n    vec2 q = p * 0.05;\n    float w = Noise(q);\n    w = 50.0*w;\n    float f = 0.0;\n    for(int i = 0;i < 5;i++){\n        f += w * Noise(q*0.85);\n        w = -w * 0.4;\n        q = rotate2D * q;\n    \n    }\n    \n    float ff = Noise(q * 0.002);\n   f += ff*250.-80.0;\n   \n    \n    \n    for (int i = 0; i < 6; i++)\n\t{\n\t\tf += w * Noise(q*0.85);\n\t\tw =  - w * 0.4;\n\t\tq = rotate2D * q;\n\t}\n\n    return f;\n\n}\n// High def version only used for grabbing normal information.\nfloat Terrain2( in vec2 p)\n{\n\t// There's some real magic numbers in here! \n\t// The Noise calls add large mountain ranges for more variation over distances...\n\tvec2 pos = p*0.05;\n\tfloat w = (Noise(pos*.25)*0.75+.15);\n\tw = 66.0 * w * w;\n\tvec2 dxy = vec2(0.0, 0.0);\n\tfloat f = .0;\n\tfor (int i = 0; i < 5; i++)\n\t{\n\t\tf += w * Noise(pos);\n\t\tw =  - w * 0.4;\t//...Flip negative and positive for varition\t   \n\t\tpos = rotate2D * pos;\n\t}\n\tfloat ff = Noise(pos*.002);\n\tf += pow(abs(ff), 5.0)*275.-5.0;\n\t\n/*\n\ttreeCol = Trees(p);\n\tf += treeCol;\n\tif (treeCol > 0.0) return f;\n\n\t*/\n\t// That's the last of the low resolution, now go down further for the Normal data...\n\tfor (int i = 0; i < 6; i++)\n\t{\n\t\tf += w * Noise(pos);\n\t\tw =  - w * 0.4;\n\t\tpos = rotate2D * pos;\n\t}\n\t\n\t\n\treturn f;\n}\n\nvec2 GetDist2(vec3 p, vec2 uv){\n\n\n    vec4 s = vec4(-3.0,3.0, 9.0,1.0);\n    vec4 s2 = vec4(3.0 ,3.0, 7.0, 1.0);\n    \n    \n    \n    \n    vec2 d=vec2(0.0);;\n    float pd = dot(p, vec3(0.0, 1.0, 0.0));\n    \n    pd = p.y - TerrainRM2(p.xz);\n    \n    if(p.y <= 0.0){\n        pd = p.y - Noise3D(p*0.7)*0.5 - sin(p.x+iTime*2.0)*0.2-cos(p.z+iTime*2.0)*0.1+sin(p.y*3.0+iTime)*0.1;\n    }\n    \n     \n  /*  pd = pd - noi(p*0.9)*1.2 ;\n    pd -= noi(p*3.0)*0.01;\n   pd -= noi(p*10.0)*0.1;*/\n   \n    \n    vec3 sp = (p)-s.xyz;\n    float sd = length((sp))-s.w;\n       \n       \n    \n    vec3 sp2 = (p)-s2.xyz;\n    //sp2.y += sin(iTime)*0.1;\n    float sd2 = length((sp2))-s2.w;\n   \n    \n   \n      \n      if(sd < sd2){\n          d.x = sd;\n          d.y = -1.0;\n       }\n       else\n       {\n           d.x = sd2;\n          d.y = -1.0;\n       }\n       \n       if(pd < d.x){\n          d.x = pd;\n          d.y = 2.0;\n       }\n       \n     \n       \n       \n      \n   // \n    return d;\n    \n    \n}\n\nvec2 GetDist(vec3 p, vec2 uv){\n\n\n    vec4 s = vec4(-3.0,3.0, 9.0,1.0);\n    vec4 s2 = vec4(3.0 ,3.0, 7.0, 1.0);\n    \n    \n    \n    \n    vec2 d=vec2(0.0);;\n    float pd = dot(p, vec3(0.0, 1.0, 0.0));\n    \n    pd = p.y - TerrainRM(p.xz);\n    \n    if(p.y <= 0.0){\n        pd = p.y - Noise3D(p*0.7)*0.5 - sin(p.x+iTime*2.0)*0.2-cos(p.z+iTime*2.0)*0.1+sin(p.y*3.0+iTime)*0.1;\n    }\n    \n     \n  /*  pd = pd - noi(p*0.9)*1.2 ;\n    pd -= noi(p*3.0)*0.01;\n   pd -= noi(p*10.0)*0.1;*/\n   \n    \n    vec3 sp = (p)-s.xyz;\n    float sd = length((sp))-s.w;\n       \n       \n    \n    vec3 sp2 = (p)-s2.xyz;\n    //sp2.y += sin(iTime)*0.1;\n    float sd2 = length((sp2))-s2.w;\n   \n    \n   \n      \n      if(sd < sd2){\n          d.x = sd;\n          d.y = -1.0;\n       }\n       else\n       {\n           d.x = sd2;\n          d.y = -1.0;\n       }\n       \n       if(pd < d.x){\n          d.x = pd;\n          d.y = 2.0;\n       }\n       \n     \n       \n       \n      \n   // \n    return d;\n    \n    \n}\n\nvec3 RayMarch2(vec3 eye, vec3 viewRayDirection, vec2 uv){\n    vec3 t = vec3(0.);\n    float max = -100000.0;\n    vec2 dd;\n    float depth = 0.0, end = 10.0, delta=0.0, v;\n    for (int i = 0; i < 150; i++) {\n        t.yz = GetDist(eye + t.x * viewRayDirection, uv).xy;\n       \n        \n        \n            \n        if (t.y < 0.01) {\n           \n           break;\n        }\n        //t.x += t.y;\n        \n        \n\n        if (t.x >= 10000.0) {\n            break;\n        }\n       \n        if(0.01>= 0.3*t.y)v= 0.01;\n        else v = 0.3*t.y;\n       delta = v + (t.x*0.0065);\n\t\t t.x += delta;\n    }\n    if (t.x >= 10000.0)t.x = -1.0;\n        \n       \n    \n    return t;\n\n\n}\n \nvec3 RayMarch3(vec3 eye, vec3 viewRayDirection, vec2 uv){\n    vec3 t = vec3(0.);\n    float max = -100000.0;\n    vec2 dd;\n    float depth = 0.0, end = 10.0, delta=0.0, v;\n    for (int i = 0; i < 150; i++) {\n        t.yz = GetDist2(eye + t.x * viewRayDirection, uv).xy;\n       \n        \n        \n            \n        if (t.y < 0.01) {\n           \n           break;\n        }\n        //t.x += t.y;\n        \n        \n\n        if (t.x >= 10000.0) {\n            break;\n        }\n       \n        if(0.01>= 0.3*t.y)v= 0.01;\n        else v = 0.3*t.y;\n       delta = v + (t.x*0.0065);\n\t\t t.x += delta;\n    }\n    if (t.x >= 10000.0)t.x = -1.0;\n        \n       \n    \n    return t;\n\n\n}\n\n\nfloat GetLight(vec3 p, vec2 uv, vec3 lg, out vec3 n){\n    vec3 lightpos = lg;\n    lightpos.xz += vec2(sin(iTime), cos(iTime));\n    vec3 l = normalize(lightpos-p);\n    \n    vec2 d = GetDist(p, uv);\n    vec2 e = vec2(0.01, 0);\n    \n    \n   // float dd = d.x;\n    n = d.x - vec3(\n        GetDist(p-e.xyy, uv).x,\n        GetDist(p-e.yxy, uv).x,\n        GetDist(p-e.yyx, uv).x);\n    \n    n = normalize(n);\n    \n    float dif = clamp(dot(n, l), .0, 1.);\n   // float dif = clamp(dot(n, l), 0., 1.);\n   // vec3 dd = RayMarch2(p+n*.01, l, uv);\n    //if(dd.x < length(lightpos-p))dif *= 0.1;\n    return (dif) ;\n\n}\n\n\nvec3 Mat2(vec3 p, vec3 n1, vec3 diff2, vec3 lightpos){\n    vec3 col = mix(vec3(1.0)*diff2, vec3(Noise(p.xz)*0.1), 0.5);\n    \n   \n   \n    if(p.y <= 0.0){\n                 \n             col = vec3(0.0, 0.8, 1.0) ;\n             col += mix(vec3(Noise(p.xz)*0.1) , diff2 * vec3(0.0, 0.8, 1.0), 0.6);\n    }\n    else if(p.y < 1.45){\n         col =  vec3(1.0, 1.0,0.0)*diff2;\n    }\n    else if( (p.y < 10.35) && (n1.y > 0.9)){\n        col = vec3(0.0,1.0, 0.0)*diff2;\n       \n    }\n   \n    else if ((p.y > 80.0)&& (n1.y > 0.5))\n    {\n        //col = mix(vec3(Noise(p.xz)*0.1)*vec3(1.0), vec3(1.0)*diff2+0.3, 0.9);\n        //col += 0.3;\n        col =  vec3(1.0)*diff2;\n       \n    }\n    else\n    {\n       col += vec3(150. ,75., 21.)/255.*diff2;\n    \n    }\n    \n    \n    \n    \n\n   \n    \n    \n       \n    \n    return clamp(col, 0., 1.);\n            \n}\n\nfloat calcSoftshadow( in vec3 ro, in vec3 rd, in float mint, in float tmax )\n{\n\tfloat res = 1.;\n    float t = mint;\n    for( int i=0; i<16; i++ )\n    {\n\t\tfloat h = GetDist2( ro + rd*t , vec2(1.0)).y;\n        res = min( res, 10.0*h/t );\n        t += clamp( h, 0.01, 0.10 );\n        if( h<0.0001 || t>tmax ) break;\n    }\n    return clamp( res, 0.0, 1.0 );\n}\n\nfloat calcAO( in vec3 pos, in vec3 nor )\n{\n\tfloat occ = 0.0;\n    float sca = 1.0;\n    for( int i=0; i<5; i++ )\n    {\n        float hr = 0.01 + 0.12*float(i)/4.0;\n        vec3 aopos =  nor * hr + pos;\n        float dd = GetDist2( aopos , vec2(1.0)).y;\n        occ += -(dd-hr)*sca;\n        sca *= 0.95;\n    }\n    return clamp( 1.0 - 3.0*occ, 0.0, 1.0 );    \n}\n\nvec3 GetLightM(vec3 p, vec2 uv, vec3 lg, out vec3 n, vec3 ro, vec3 rd){\n    vec3 lightpos = lg;\n    //lightpos.xz += vec2(sin(iTime), cos(iTime));\n    //p = p*2.0;\n    vec3 l = normalize(lightpos-p);\n    \n    vec2 d = GetDist2(p, uv);\n    \n    vec2 e = vec2(0.01, 0);\n    \n    n = d.x - vec3(\n        GetDist2(p-e.xyy, uv).x,\n        GetDist2(p-e.yxy, uv).x,\n        GetDist2(p-e.yyx, uv).x);\n    \n    \n    n = normalize(n);\n    \n    float occ = calcAO(p, n);\n    \n    \n            \n    float dif = clamp(dot(n, l), .0, 1.);\n    //dif *= calcSoftshadow(p, lightpos, 0.01, 10000. );\n    dif += occ*0.15;\n    \n    //\n \n    vec3 dd = RayMarch2(p+n*.01, l, uv);\n    p = ro + reflect(n, l) * dd.x;\n    \n    \n    \n         \n    if(dd.y < length(lightpos-p) && dd.x > 0.0){\n        if(dd.z == -1.0){\n            vec3 colXZ = texture(iChannel0, p.xz*0.1).rgb;\n             vec3 colYZ = texture(iChannel0, p.yz*0.1).rgb;\n             vec3 colXY = texture(iChannel0, p.xy*0.1).rgb;\n\n             n = abs(n);\n\n             n *= pow(n, vec3(20));\n             n /= n.x+n.y+n.z;\n\n             vec3 col = colYZ * n.x + colXZ * n.y + colXY*n.z;\n\n             uv = vec2(atan(p.x, p.z)/6.2832+.5, p.y/3.+0.5);\n             vec4 st = texture(iChannel0, uv);\n\n             col = vec3(dif) * mix(col, st.rgb, st.a);\n             return col;\n\n        }\n        else if(dd.z == 2.0)\n        {\n            vec3 col;\n            \n                        \n            col = Mat2(p, n, vec3(dif), lightpos);\n            \n            \n            return col;\n            \n            \n            \n        }\n        else if(dd.z == 3.0)\n        {\n            vec3 colXZ = texture(iChannel1, p.xz*0.1).rgb;\n             vec3 colYZ = texture(iChannel1, p.yz*0.1).rgb;\n             vec3 colXY = texture(iChannel1, p.xy*0.1).rgb;\n             \n             vec3 col = colYZ * n.x + colXZ * n.y + colXY*n.z;  \n             col *= vec3(1.0, 0.0, 0.0);\n             return col;\n        }\n        else if(dd.z == 4.0){\n             vec3 colXZ = texture(iChannel2, p.xz*0.1).rgb;\n             vec3 colYZ = texture(iChannel2, p.yz*0.1).rgb;\n             vec3 colXY = texture(iChannel2, p.xy*0.1).rgb;\n             \n             \n             vec3 col = colYZ * n.x + colXZ * n.y + colXY*n.z;\n             \n             col -= vec3(.3);\n             return col;\n         }\n        else\n            return vec3(dif);\n            \n     }\n     else\n         return vec3(dif);\n\n}\nvec3 lightDir = normalize( vec3(0.5,0.6,0.) );\nconst mat2 m2 = mat2( 0.60, -0.80, 0.80, 0.60 );\n//ref: https://www.shadertoy.com/view/Msdfz8\nvec3 Cloud(vec3 bgCol,vec3 ro,vec3 rd,vec3 cloudCol,float spd)\n{\n    vec3 col = bgCol;\n    float t = iTime * 0.15* spd;\n    vec2 sc = ro.xz + rd.xz*((3.)*40000.0-ro.y)/rd.y;\n    vec2 p = 0.00002*sc;\n    float f = 0.0;\n  \tfloat s = 0.5;\n  \tfloat sum =0.;\n  \tfor(int i=0;i<5;i++){\n    \tp += t;t *=1.5;\n    \tf += s*textureLod( iChannel0, p/256.0, 0.0).x; p = m2*p*2.02;\n    \tsum+= s;s*=0.6;\n  \t}\n    float val = f/sum; \n    col = mix( col, cloudCol, smoothstep(0.5,0.8,val) );\n    return col;\n}\nvec3 RayMarchCloud(vec3 ro,vec3 rd){\n    vec3 col = vec3(0.0,0.0,0.0);  \n    float sundot = clamp(dot(rd,lightDir),0.0,1.0);\n    \n     // sky      \n    col = vec3(0.2,0.5,0.85)*1.1 - rd.y*rd.y*0.5;\n    col = mix( col, 0.85*vec3(0.7,0.75,0.85), pow( 1.0-max(rd.y,0.0), 4.0 ) );\n    // sun\n    col += 0.25*vec3(1.0,0.7,0.4)*pow( sundot,5.0 );\n    col += 0.25*vec3(1.0,0.8,0.6)*pow( sundot,64.0 );\n    col += 0.4*vec3(1.0,0.8,0.6)*pow( sundot,512.0 );\n    // clouds\n    col = Cloud(col,ro,rd,vec3(1.0,0.95,1.0),1.);\n            // .\n    col = mix( col, 1.5*vec3(0.0,0.5,1.0), pow( 1.0-max(rd.y,0.0), 16.0 ) );\n    return col;\n}\n/**\n * Lighting contribution of a single point light source via Phong illumination.\n * \n * The vec3 returned is the RGB color of the light's contribution.\n *\n * k_a: Ambient color\n * k_d: Diffuse color\n * k_s: Specular color\n * alpha: Shininess coefficient\n * p: position of point being lit\n * eye: the position of the camera\n * lightPos: the position of the light\n * lightIntensity: color/intensity of the light\n *\n * See https://en.wikipedia.org/wiki/Phong_reflection_model#Description\n */\nvec3 phongContribForLight(vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye,\n                          vec3 lightPos, vec3 lightIntensity, vec2 uv, out vec3 N) {\n    \n    vec2 d = GetDist(p, uv);\n    vec2 e = vec2(0.01, 0);\n    \n    \n    N = d.x - vec3(\n        GetDist(p-e.xyy, uv).x,\n        GetDist(p-e.yxy, uv).x,\n        GetDist(p-e.yyx, uv).x);\n    \n    N = normalize(N);\n    //vec3 N = estimateNormal(p);\n    vec3 L = normalize(lightPos - p);\n    vec3 V = normalize(eye - p);\n    vec3 R = normalize(reflect(-L, N));\n    \n    float dotLN = dot(L, N);\n    float dotRV = dot(R, V);\n    \n    if (dotLN < 0.0) {\n        // Light not visible from this point on the surface\n        return vec3(0.0, 0.0, 0.0);\n    } \n    \n    if (dotRV < 0.0) {\n        // Light reflection in opposite direction as viewer, apply only diffuse\n        // component\n        return lightIntensity * (k_d * dotLN);\n    }\n    return lightIntensity * (k_d * dotLN + k_s * pow(dotRV, alpha));\n}\n\n/**\n * Lighting via Phong illumination.\n * \n * The vec3 returned is the RGB color of that point after lighting is applied.\n * k_a: Ambient color\n * k_d: Diffuse color\n * k_s: Specular color\n * alpha: Shininess coefficient\n * p: position of point being lit\n * eye: the position of the camera\n *\n * See https://en.wikipedia.org/wiki/Phong_reflection_model#Description\n */\nvec3 phongIllumination(vec3 k_a, vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye, vec2 uv, out vec3 n) {\n    const vec3 ambientLight = 0.5 * vec3(1.0, 1.0, 1.0);\n    vec3 color = ambientLight * k_a;\n    \n    vec3 light1Pos = vec3(4.0 * sin(iTime),\n                          2.0,\n                          4.0 * cos(iTime));\n    vec3 light1Intensity = vec3(0.4, 0.4, 0.4);\n    \n    color += phongContribForLight(k_d, k_s, alpha, p, eye,\n                                  light1Pos,\n                                  light1Intensity,\n                                  uv,\n                                  n);\n    \n    vec3 light2Pos = vec3(2.0 * sin(0.37 * iTime),\n                          2.0 * cos(0.37 * iTime),\n                          2.0);\n    vec3 light2Intensity = vec3(0.4, 0.4, 0.4);\n    \n    color += phongContribForLight(k_d, k_s, alpha, p, eye,\n                                  light2Pos,\n                                  light2Intensity,\n                                  uv,\n                                  n);    \n    return color;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    uv -= 0.5;\n    uv /= vec2(iResolution.y / iResolution.x, 1);\n    // Time varying pixel color\n    vec3 col = vec3(0.0);\n    vec3 lightpos = vec3(0.0, 100., -50.);\n    \n    //iMouse.xy / iResolution.xy\n    vec3 lookat = vec3((iMouse.x/iResolution.x)*10.0, (iMouse.y/iResolution.y)*30.0, 30.0);//vec3(0.0, 1.5, 0.0);\n    vec3 ro = vec3(0, 20.0, -50.);\n    float speed = 50.0;\n    \n    //lightpos.z+= iTime*speed;\n    \n    float an = (iMouse.x/iResolution.x)*10.0;\n    ro -= lookat;\n    lookat -= lookat;\n    ro *= RotY(an);\n    lookat *= RotY(an);\n    ro += lookat;\n    lookat += lookat;\n    \n    //vec3 lightpos = vec3(0.0, 30., -30.);\n   \n    lightpos -= lookat;\n    lightpos *= RotY(an);\n    lightpos += lookat;\n    \n     lightpos.z += iTime*speed;\n    ro.z += iTime*speed;\n    lookat.z += iTime*speed;\n    \n    vec3 p;\n    float h = 0.0;\n    for (int i = 0; i < 4; i++)\n\t{\n        \n        h += Terrain(ro.xz) ;\n        //\n        \n    }\n    h+= 50.0;\n    ro.y += h;\n    lightpos.y += h;\n    //lightpos.y += h;\n    if(h <= 0.0){\n        lookat.y = ro.y +10.0 ;\n    \n    }\n    else\n    {\n        lookat.y = ro.y -10.0 ;\n    \n    }\n    \n    if(ro.y < 0.0){\n        ro.y = 5.0;\n    \n    }\n    \n    float zoom = 2.0;    \n    vec3 f = normalize(lookat-ro),\n        r = normalize(cross(vec3(0,1,0), f)),\n        u = cross(f, r),\n        c = ro + f * zoom,\n        i = c + uv.x * r + uv.y * u,\n        rd = normalize(i-ro);\n        \n    \n        \n     vec3 t;\n     float dO, dif, dif2, dif3, difT;\n     //vec3 p;\n     \n  \n     \n     t = RayMarch2(ro, rd, uv);\n     p = ro + rd * t.x;\n     \n    float alpha = 1.0;\n    vec3 n1, n2, n3, np;\n  \n   vec3 diff2 = GetLightM(p, uv, lightpos, n1, ro, rd);\n    \n    //vec3 ph = phongIllumination(vec3(1.0), vec3(dif), vec3(1.0, 1.0, 0.0), 50.0, p, ro, uv, np);\n    \n   \n    \n     if(t.x > 0.0){\n         \n             \n         \n         if(t.z == 0.0){\n             //col = ph * vec3(0.0, 1.0, 0.0);\n         }\n         else if(t.z == 1.0){\n             col = diff2* vec3(1.0, 0.0, 0.0);\n         }\n         else if(t.z == 2.0){\n         \n             \n                \n            col = Mat2(p, n1, diff2, lightpos);\n            \n            \n         \n             alpha = 0.1;\n             \n            \n             \n             \n         }\n         else if(t.z == -1.0){\n             vec3 colXZ = texture(iChannel0, p.xz*0.1).rgb;\n             vec3 colYZ = texture(iChannel0, p.yz*0.1).rgb;\n             vec3 colXY = texture(iChannel0, p.xy*0.1).rgb;\n             \n             \n             n1 = abs(n1);\n             \n             n1 *= pow(n1, vec3(20));\n             n1 /= n1.x+n1.y+n1.z;\n             \n             col = colYZ * n1.x + colXZ * n1.y + colXY*n1.z;\n             \n             uv = vec2(atan(p.x, p.z)/6.2832+.5, p.y/3.+0.5);\n             vec4 st = texture(iChannel0, uv);\n            \n             \n             col = diff2 * mix(col, st.rgb, st.a);\n         }\n         else if(t.z == 3.0){\n            \n             \n             float NdotL = max( 0., dot( n1, vec3(0.0, 6., 5.)-p ) );\n             float SpecularColor;\n            SpecularColor = SpecularColor + ( 1. - SpecularColor ) * pow( ( 1. - NdotL ), 5. );\n             \n             col = diff2*vec3(.003, .005, .005);\n             col = mix(diff2 * vec3(0.5, 0.5, 0.5)+SpecularColor*0.001, \n                       vec3(0., 0.5, 5.0)*diff2+vec3(0.2,0.5, 0.5)*SpecularColor*0.0001, 0.7 );\n             col += normalize(vec3(0.1, 0.1, 0.1));\n         \n         \n         }\n         else if(t.z == 4.0){\n             vec3 colXZ = texture(iChannel2, p.xz*0.1).rgb;\n             vec3 colYZ = texture(iChannel2, p.yz*0.1).rgb;\n             vec3 colXY = texture(iChannel2, p.xy*0.1).rgb;\n             \n             \n             col = colYZ * n1.x + colXZ * n1.y + colXY*n1.z;\n             col += diff2 * vec3(1.0, 0.5, 0.5);\n         }\n         else if(t.z == 5.0){\n             vec3 colXZ = texture(iChannel0, p.xz*0.1).rgb;\n             vec3 colYZ = texture(iChannel0, p.yz*0.1).rgb;\n             vec3 colXY = texture(iChannel0, p.xy*0.1).rgb;\n             \n             col = colYZ * n1.x + colXZ * n1.y + colXY*n1.z ;\n             col += diff2 * vec3(1.0, 0.5, 0.5);\n         \n             \n         }\n         \n         /*vec2 j = uv*3.0;\n         j.x += 0.0;\n         j.y += .1;\n         float sparkle = 1./dot(j,j);\n                \n         col += diff2*(sparkle*sin(mod(iTime*10.0, 3.1415))*0.01) ;\n    \n       */\n         \n         \n         \n     }\n     else\n     {\n         col = RayMarchCloud( ro, rd);\n         //col = mix(vec3(1.0, 1.0, 1.0), col, 0.3);\n         \n     }\n     \n     if(t.x > 1000.1)col = mix(vec3(1.0, 1.0, 1.0), col, exp(-t.x*0.0005));\n     //col = (1.0 - exp(-col * 6.0)) * 1.0024;\n\t\n   \n    // Output to screen\n    fragColor = vec4((col),alpha);\n}\n\n\n\n", "image_inputs": [{"id": "XdXGzn", "previewfilepath": "/media/ap/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tlGyRR.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[94, 94, 112, 112, 172], [173, 173, 192, 192, 272], [273, 273, 292, 292, 372], [373, 373, 392, 392, 472], [476, 476, 530, 605, 701], [703, 947, 984, 984, 1106], [1108, 1119, 1145, 1145, 1360], [1362, 1407, 1432, 1432, 1797], [1799, 1799, 1820, 1820, 1939], [1941, 1941, 1967, 1967, 2425], [2427, 2427, 2447, 2447, 2677], [2679, 2679, 2703, 2703, 2913], [2915, 2915, 2943, 2943, 2994], [2995, 2995, 3031, 3031, 3469], [3471, 3471, 3522, 3522, 3838], [3840, 3840, 3885, 3885, 3979], [3981, 3981, 4017, 4017, 4060], [4062, 4062, 4109, 4109, 4368], [4370, 4370, 4410, 4410, 4575], [4577, 4577, 4632, 4632, 4697], [4699, 4699, 4747, 4747, 4814], [4816, 4816, 4839, 4839, 4902], [4904, 4904, 4933, 4933, 4972], [4974, 4974, 4992, 4992, 5216], [5366, 5366, 5388, 5388, 5510], [5511, 5511, 5532, 5532, 5651], [5653, 5653, 5679, 5679, 5918], [5920, 5920, 5946, 5946, 6208], [6270, 6270, 6297, 6297, 6639], [6641, 6641, 6668, 6668, 6955], [6957, 6957, 6985, 6985, 7383], [7384, 7447, 7475, 7604, 8215], [8217, 8217, 8248, 8248, 9189], [9191, 9191, 9221, 9221, 10161], [10163, 10163, 10220, 10220, 10834], [10837, 10837, 10894, 10894, 11509], [11512, 11512, 11565, 11565, 12115], [12118, 12118, 12172, 12172, 12957], [12959, 12959, 13037, 13037, 13314], [13316, 13316, 13358, 13358, 13673], [13675, 13675, 13746, 13746, 16112], [16209, 16254, 16318, 16318, 16745], [16746, 16746, 16782, 16782, 17370], [17371, 17863, 18024, 18024, 18832], [18834, 19204, 19310, 19310, 20260], [20263, 20263, 20320, 20370, 25212]]}
{"id": "tlGyWm", "name": "inversion 01", "author": "cghow", "description": "inversion ", "tags": ["inversion"], "likes": 1, "viewed": 30, "published": "Public", "date": "1611121722", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage(out vec4 O, vec2 u)\n{\n    vec2 R = iResolution.xy,\n         U = u+u - R;\n    U = sin( R.y/+sin(iTime*.6)*  U/dot(U,U) );\n    U /= fwidth( U*=U.y );\n\tO += .9 + sin(U.x*.05 );\n  \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tlGyWm.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 36, 36, 193]]}
{"id": "tlGyWR", "name": "kawaii empty bottle", "author": "tono", "description": "kawaii", "tags": ["kawaii"], "likes": 10, "viewed": 100, "published": "Public", "date": "1610770708", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float pi = acos(-1.);\nfloat w = 0.;\nfloat randomd = 0.;\n\nmat2 rot(float a){return mat2(cos(a),sin(a),-sin(a),cos(a));}\n//https://www.iquilezles.org/www/articles/distfunctions/distfunctions.htm\nfloat sdRoundBox( vec3 p, vec3 b, float r )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0) - r;\n}\n\nfloat sdOctahedron( vec3 p, float s)\n{\n  p = abs(p);\n  return (p.x+p.y+p.z-s)*0.57735027;\n}\n\nvec3 random3(vec3 c) {\n    float j = 4096.0*sin(dot(c,vec3(17.0, 59.4, 15.0)));\n    vec3 r;\n    r.z = fract(512.0*j);\n    j *= .125;\n    r.x = fract(512.0*j);\n    j *= .125;\n    r.y = fract(512.0*j);\n    return r-0.5;\n}\n\nfloat random (vec2 st) {\n    return fract(sin(dot(st.xy,\n                         vec2(12.9898,78.233)))*\n        43758.5453123);\n}\n\nfloat map(vec3 p)\n{\n    float t = floor(iTime) + pow(fract(iTime ),6.);\n    float t2 = floor(iTime /2.) + pow(fract(iTime /2.),6.);\n    randomd = pow( length( random( floor(p.yz/ (pi *2.) + pi * 2.)  + floor(iTime) ) ),3. )* 10.;\n   // if(randomd < 3.)return 1.;\n  // p.x = abs(p.x) - 5.5;\n   // p.yz= sin(p.yz) * 2.;\n   // p.x = sin(p.x) * 2.4;\n    p.xz *= rot(t * 2.);\n    float o = sdOctahedron(p,1.);\n    float shape = (clamp( sin(t * pi/2.) * 1. ,0.,1.));\n    float shape2= abs(sin(t2 * pi/2.) * 1.);\n    \n    o = mix(mix( sdRoundBox(p,vec3(.8),.1),length(p) - 1., shape ),o,shape2 );\n    return o;\n}\n\nfloat march(vec3 cp , vec3 rd)\n{\n    float depth = 0.;\n    for(int i = 0; i< 66; i++)\n    {\n        vec3 rp = cp + rd * depth;\n        float d = map(rp);\n        if(abs(d) < 0.01)\n        {\n            return depth;\n        }\n        depth += d;\n    }\n    depth *= -1.;\n    return depth;\n}\n\n\n\n//https://www.shadertoy.com/view/XsX3zB\n/* skew constants for 3d simplex functions */\nconst float F3 =  0.3333333;\nconst float G3 =  0.1666667;\n\n/* 3d simplex noise */\nfloat simplex3d(vec3 p) {\n    /* 1. find current tetrahedron T and it's four vertices */\n    /* s, s+i1, s+i2, s+1.0 - absolute skewed (integer) coordinates of T vertices */\n    /* x, x1, x2, x3 - unskewed coordinates of p relative to each of T vertices*/\n\n    /* calculate s and x */\n    vec3 s = floor(p + dot(p, vec3(F3,F3,F3)));\n    vec3 x = p - s + dot(s, vec3(G3,G3,G3));\n\n    /* calculate i1 and i2 */\n    vec3 e = step(vec3(0.,0.,0.), x - x.yzx);\n    vec3 i1 = e*(1.0 - e.zxy);\n    vec3 i2 = 1.0 - e.zxy*(1.0 - e);\n\n    /* x1, x2, x3 */\n    vec3 x1 = x - i1 + G3;\n    vec3 x2 = x - i2 + 2.0*G3;\n    vec3 x3 = x - 1.0 + 3.0*G3;\n\n    /* 2. find four surflets and store them in d */\n    vec4 w, d;\n\n    /* calculate surflet weights */\n    w.x = dot(x, x);\n    w.y = dot(x1, x1);\n    w.z = dot(x2, x2);\n    w.w = dot(x3, x3);\n\n    /* w fades from 0.6 at the center of the surflet to 0.0 at the margin */\n    w = max(0.6 - w, 0.0);\n\n    /* calculate surflet components */\n    d.x = dot(random3(s), x);\n    d.y = dot(random3(s + i1), x1);\n    d.z = dot(random3(s + i2), x2);\n    d.w = dot(random3(s + 1.0), x3);\n\n    /* multiply d by w^4 */\n    w *= w;\n    w *= w;\n    d *= w;\n\n    /* 3. return the sum of the four surflets */\n    return dot(d, vec4(52.0,52.0,52.0,52.0));\n}\n\nfloat wmap(vec3 p)\n{\n    float t = floor(iTime) + pow(fract(iTime),6.);\n    float o = sin( (p.y + 0.1 ) * 2.) - ( cos(sin(t * 1.3) * 2.14) / 1.2 ) + .6;\n        p.xz *= rot(0.01);\n    \to -= simplex3d(p * 1.7 - t)/(9.) ;\n    o = max(map(p) , o);\n    return o;\n}\n\nfloat wmarch(vec3 cp,vec3 rd)\n{\n    float depth = 0.;\n    float bdepth = 0.;\n    w = wmap(cp + rd * 0.01);\n    for(int i = 0;  i< 99 ; i++)\n    {\n        vec3 rp = cp + rd * depth;\n        float d = wmap(rp);\n        //float bd = map(rp);\n        if(abs(d) < 0.01)\n        {\n            return depth;\n        }\n        depth += d;\n    }\n    return -depth;\n}\n\nfloat getWaterThickness(vec3 cp , vec3 rd)\n{\n    float thickness = 0.;\n    for(int i = 0; i < 44 ; i++)\n    {\n        vec3 rp = cp + rd * (thickness + 0.001);\n        float d = wmap(rp);\n        if(d < 0.)\n        {\n            return thickness;\n        }\n        thickness += d;\n    }\n    return thickness;\n}\n\n//https://qiita.com/keim_at_si/items/c2d1afd6443f3040e900\n\nvec3 hsv2rgb(float h, float s , float v)\n{\n    return ((clamp(abs(fract(h+vec3(0,2,1)/3.)*6.-3.)-1.,0.,1.)-1.)*s+1.)*v;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 p = (fragCoord.xy * 2.0 - iResolution.xy) / min(iResolution.x, iResolution.y);\n    float reresol = 40.;\n    p = floor(p * (reresol * iResolution.x/iResolution.y)) / (reresol * iResolution.x/iResolution.y);\n    float r = random( vec2(floor(iTime)/100.) );\n\tvec3 col = vec3(0.,0.5,1.);\n    //col = mix(hsv2rgb(r,r,1.),col,.8);\n    p.y *= -1.;\n    \n    vec3 forward = vec3(0.,0.,0.);\n    //forward.z += time;\n    vec3 cp = vec3(0.,1.,-5.) + forward;\n    \n    cp.y += sin(iTime);\n    vec3 target = vec3(0.) + forward;\n    vec3 cd = normalize(target - cp);\n    vec3 cs = normalize(cross(cd,vec3(0.,1.,0.)));\n    vec3 cu = normalize(cross(cd,cs));\n    \n    float fov = 4.;\n\tvec3 rd = normalize(cd * fov + cs * p.x + cu * p.y);\n    \n    float d = march(cp,rd);\n    if(d > 0.)\n    {\n        col *= 0.;\n        vec2 e = vec2(0.,0.01);\n        vec3 pos = cp + rd * d;\n        vec3 N = -normalize(map(pos) - vec3(map(pos - e.xyy),map(pos - e.yxy),map(pos - e.yyx)));\n        float wd = wmarch(cp , rd);\n        \n        vec3 sun = normalize(-vec3(2.,4.,8.));\n        float wstep = 3.;\n        float bstep = 2.5;\n        float sp = 0.;\n        if(wd > 0. )\n        {\n        \tvec3 wpos = cp + rd * wd;\n            vec3 wN = normalize(wmap(wpos) - vec3(wmap(wpos - e.xyy),wmap(wpos - e.yxy),wmap(wpos - e.yyx)));\n            float sp2 = max(0.,dot(rd,reflect(wN,sun)));\n            float diff = max(0. , dot(N,sun)) * .7 + .3;\n            float thickness = getWaterThickness(wpos,rd);\n            float wrim = max(0.,1. - abs(dot(wN , rd)));\n            wrim =  pow(wrim,3.) * 1.1;\n            vec3 wcolor = hsv2rgb(r,r,1. ) * 2.;\n            sp2 = pow(sp2 , 2.) + .1;\n            col = floor( (sp2 * vec3(1.) + diff * wcolor + (thickness * 13.)) * wstep + wrim * vec3(1.)) / wstep;\n            //vec3(0.,.4,.9)\n        }\n        \n        //入れ物の色\n        sp = max(0.,dot(rd,reflect(N,sun)));\n        sp = pow(sp,5.) / 2.;\n        float rim = max(0.,1. - abs(dot(N , rd)));\n        rim = pow(rim , 30.);\n        float diff = max(0. , dot(N,sun)) * .5 + .5;\n        col += step(length(col),0.1) * floor( (diff * vec3(0.8,0.4,1.) * 1.5 + rim * vec3(1.7) ) * bstep ) / bstep;\n        \n   \t\tfloat t = 1. - exp( -0.003 * d * d *d );\n    \tcol = mix(col,vec3(0.,0.5,1.),t);\n    }\n   // vec2 uv = fragCoord.xy / iResolution.xy;\n   // col = mix(texture2D(backbuffer,uv).rgb,col,.2);\n    \n    fragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tlGyWR.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[57, 57, 75, 75, 118], [119, 193, 238, 238, 329], [331, 331, 369, 369, 422], [424, 424, 446, 446, 643], [645, 645, 669, 669, 776], [778, 778, 797, 797, 1383], [1385, 1385, 1417, 1417, 1674], [1823, 1846, 1871, 2130, 3122], [3124, 3124, 3144, 3144, 3384], [3386, 3386, 3417, 3417, 3743], [3745, 3745, 3789, 3789, 4054], [4056, 4115, 4157, 4157, 4236], [4238, 4238, 4295, 4295, 6713]]}
{"id": "tlKcRc", "name": "fractal 3D", "author": "regis", "description": "mandelbulb", "tags": ["3d", "fractal", "raymarch", "mandelbulb"], "likes": 5, "viewed": 68, "published": "Public", "date": "1611527811", "time_retrieved": "2021-10-01T00:00:00", "image_code": "mat2 Rot(float a){\n    float s = sin(a);\n    float c = cos(a);\n    return mat2(c, -s, s, c);\n}\n\nmat3 RotX(float a){\n    float s = sin(a);\n    float c = cos(a);\n    \n    return mat3(1., .0, .0, .0, c, -s, .0, s, c);\n\n}\n\nmat3 RotY(float a){\n    float s = sin(a);\n    float c = cos(a);\n    \n    return mat3(c, .0, s, .0, 1., .0, -s, .0, c);\n\n}\n\nmat3 RotZ(float a){\n    float s = sin(a);\n    float c = cos(a);\n    \n    return mat3(c, -s, .0, s, c, .0, .0, .0, 1.);\n\n}\n\nvec2 map2(vec3 p, out vec4 resColor){\n\n    vec2 d = vec2(0.0);\n    \n    //float pl = p.y;\n   \n   vec3 w = p;\n   \n    float m = dot(w,w);\n\n    vec4 trap = vec4(abs(w),m);\n\tfloat dz = 1.0;\n    \n    \n\tfor( int i=0; i<4; i++ )\n    {\n\n        dz = 8.0*pow(sqrt(m),7.0)*dz + 1.0;\n\t\t//dz = 8.0*pow(m,3.5)*dz + 1.0;\n        \n        float r = length(w);\n        float b = 8.0*acos( w.y/r);\n        float a = 8.0*atan( w.x, w.z );\n        w = p + pow(r,8.0) * vec3( sin(b)*sin(a), cos(b), sin(b)*cos(a) );\n       \n  \n        trap = min( trap, vec4(abs(w),m) );\n\n        m = dot(w,w);\n\t\tif( m > 256.0 )\n            break;\n    }\n\n    resColor = vec4(m,trap.yzw);\n\n    d.x = 0.25*log(m)*sqrt(m)/dz;\n    d.y = 1.0;\n    \n    \n    return d;\n\n}\n\nvec2 map(vec3 p){\n\n    vec2 d = vec2(0.0);\n    \n    \n   \n   vec3 w = p;\n  \n    float m = dot(w,w);\n\n    vec4 trap = vec4(abs(w),m);\n\tfloat dz = 1.0;\n    \n    \n\tfor( int i=0; i<4; i++ )\n    {\n\n        dz = 8.0*pow(sqrt(m),7.0)*dz + 1.0;\n\t\t//dz = 8.0*pow(m,3.5)*dz + 1.0;\n        \n        float r = length(w);\n        float b = 8.0*acos( w.y/r);\n        float a = 8.0*atan( w.x, w.z );\n        w = p + pow(r,8.0) * vec3( sin(b)*sin(a), cos(b), sin(b)*cos(a) );\n\n        \n        trap = min( trap, vec4(abs(w),m) );\n\n        m = dot(w,w);\n\t\tif( m > 256.0 )\n            break;\n    }\n\n    //resColor = vec4(m,trap.yzw);\n\n    d.x = 0.25*log(m)*sqrt(m)/dz;\n    d.y = 1.0;\n   \n    \n    return d;\n\n}\n\nvec3 RM(vec3 ro, vec3 rd, float _d){\n    vec3 d = vec3(_d, 0.0, 0.0);\n    for(int i = 0;i < 200;i++){\n        d.yz = map(ro + d.x * rd).xy;\n        \n        if((d.y) <(0.005))\n            break;\n            \n        d.x += d.y;\n        \n        if(d.x > 1000.0)break;\n    \n    }\n    if(d.x > 1000.0)d.x = -1.0;\n    \n    return d;\n    \n}\n\nvec3 calcNormal( in vec3 pos, in float t, in float px )\n{\n    vec4 tmp;\n    vec2 e = vec2(1.0,-1.0)*0.5773*0.25*px;\n    return normalize( e.xyy*map( pos + e.xyy ).x + \n\t\t\t\t\t  e.yyx*map( pos + e.yyx ).x + \n\t\t\t\t\t  e.yxy*map( pos + e.yxy ).x + \n\t\t\t\t\t  e.xxx*map( pos + e.xxx ).x );\n}\n\nfloat calcAO( in vec3 pos, in vec3 nor )\n{\n\tfloat occ = 0.0;\n    float sca = 1.0;\n    for( int i=0; i<5; i++ )\n    {\n        float hr = 0.01 + 0.12*float(i)/4.0;\n        vec3 aopos =  nor * hr + pos;\n        float dd = map( aopos ).x;\n        occ += -(dd-hr)*sca;\n        sca *= 0.95;\n    }\n    return clamp( 1.0 - 3.0*occ, 0.0, 1.0 );    \n}\n\n\nvec3 getLight(vec3 p, vec3 ro, vec3 rd, vec3 lightpos, out vec3 n){\n    vec2 e = vec2(0.01, 0.0);\n    vec2 nd = map(p);\n\n    n = nd.x - vec3(map(p - e.xyy).x ,\n                        map(p- e.yxy).x ,\n                        map(p- e.yyx).x );\n\n    n = normalize(n);\n    \n    const float fle = 1.5;\n\n    float px = 2.0/(iResolution.y*fle);\n   // n = calcNormal(p, 0.0, px);\n\n    //vec3 lightpos = vec3(0.0, 20.0, -20.0);\n    vec3 l = normalize(lightpos-p);\n    \n    float occ = calcAO(p, n); \n    float dif = clamp(dot(n, l), 0.0, 1.0);\n    dif += occ;\n\n    /*vec3 sh = RM(p+n*0.01, l);\n    p = ro + rd * sh.x;\n\n    if((sh.x > 0.0) && (length(lightpos-p) > sh.x)){\n\n       dif = dif * 0.2;\n    }*/\n    \n    return vec3(dif);\n\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    uv -= 0.5;\n    uv /= vec2(iResolution.y/iResolution.x, 1.0);\n    \n    // Time varying pixel color\n    vec3 col = vec3(0.0);\n    \n       \n    vec3 p;\n    vec3 ro = vec3(-2.0, -0.5, -7.0); \n    vec3 lookat = vec3((iMouse.x/iResolution.x)*10.0, (iMouse.y/iResolution.y)*30.0, 30.0);\n    //vec3 rd = normalize(vec3(0.0, 1.0, 0.0));\n    vec3 lightpos = vec3(0.0, 50.0, -5.0);\n        \n    vec3 dirc = vec3(0.0, 2.0, 0.0);\n        \n    float an = (iMouse.x/iResolution.x)*10.0;\n    float anx = (iMouse.y/iResolution.y)*10.0;\n    ro -= dirc;\n    lookat -= dirc;\n    ro *= RotZ(anx);\n    lookat *= RotZ(anx);\n    ro *= RotX(anx);\n    lookat *= RotX(anx);\n    ro *= RotY(an);\n    lookat *= RotY(an);\n    ro += dirc;\n    lookat += dirc;\n    \n    lightpos -= dirc;\n    lightpos *= RotZ(anx);\n    lightpos *= RotX(anx);\n    lightpos *= RotY(an);\n    lightpos += dirc;\n    \n    \n    float zoom = abs(fract(iTime/10.0)-0.5)*10.0+2.0;    \n    vec3 f = normalize(lookat-ro),\n        r = normalize(cross(vec3(0,1,0), f)),\n        u = cross(f, r),\n        c = ro + f * zoom,\n        i = c + uv.x * r + uv.y * u,\n        rd = normalize(i-ro);\n    \n    float dan ;\n    if(anx >2.80)dan=4.0;\n    else dan = 5.0;\n    vec3 d = RM(ro, rd, dan);\n    \n    vec4 rc;\n    if(d.x > 0.0){\n        p = ro + d.x * rd;\n        \n    vec2  sp = (2.0*p.xy-iResolution.xy) / iResolution.y;\n    vec2 m2 = map2(p, rc);\n    vec3 n;\n    vec3 dif = getLight(p, ro, rd, lightpos, n);\n    \n    const vec3 light1 = vec3(  0.577, 0.577, -0.577 );\n     vec3 hal = normalize( (light1)-rd);\n     float spe1 = pow( clamp(dot(n,hal),0.0,1.0), 32.0 )*dif.x*(0.04+0.96*pow(clamp(1.0-dot(hal,lightpos),0.0,1.0),5.0));\n       \n      col = vec3(0.01);\n       //col = dif * vec3(1.0, 0.5, 1.0);//rc.rgb;\n\t\tcol = mix( col, vec3(0.10,0.20,0.50), clamp(rc.y,0.0,1.0) );\n\t \tcol = mix( col, vec3(0.02,0.10,0.50), clamp(rc.z*rc.z,0.0,1.0) );\n        col = mix( col, vec3(0.50,0.10,0.02), clamp(pow(rc.w,6.0),0.0,1.0) );\n       // col *= 0.5;\n        vec3 lin = vec3(0.0); \n\t\t     lin += 7.0*vec3(1.50,1.10,0.70)*dif.x;\n        col *= lin;\n      //col = dif * rc.rgb;//vec3(1.0, 0.5, 0.5);\n      col += spe1*15.0;\n       col = sqrt(col);\n       col *= 1.0 - 0.05*length(sp);\n\n    }                 \n                        \n    \n    \n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tlKcRc.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 18, 18, 94], [96, 96, 115, 115, 217], [219, 219, 238, 238, 340], [342, 342, 361, 361, 463], [465, 465, 502, 502, 1193], [1195, 1195, 1212, 1212, 1885], [1887, 1887, 1923, 1923, 2223], [2225, 2225, 2282, 2282, 2505], [2507, 2507, 2549, 2549, 2848], [2851, 2851, 2918, 2918, 3579], [3581, 3581, 3638, 3688, 6059]]}
{"id": "tlKcWd", "name": "oshare wall peaper", "author": "tono", "description": "kabegami", "tags": ["wallpeaper"], "likes": 1, "viewed": 56, "published": "Public", "date": "1612017703", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\nmat2 rot(float a){return mat2(cos(a),sin(a),-sin(a),cos(a));}\nfloat bo(vec3 p , vec3 s){p = abs(p) - s; return max(p.x,max(p.y,p.z));}\nfloat nearest = 10.;\nfloat pi = acos(-1.);\n\nfloat random (vec2 st) {\n    return fract(sin(dot(st.xy,\n                         vec2(12.9898,78.233))) * 43758.5453123);\n}\n\nfloat Pile(vec3 p)\n{\n    float o = 10.;\n    \n    p.xz *= rot(p.y/1. + iTime);\n    p.x = abs(abs(p.x) - 1.) ;\n    p.z = abs(abs(p.z) - 1.) ;\n    float b = bo(p,vec3(.4,4.,.4));\n    o = b;\n    return o;\n}\n\nvec2 map(vec3 p)\n{\n    float o = 10.;\n    float id = 0.;\n    float ii = 10.;\n    vec2 dd = floor(p.xz / ii);\n    float t = random(dd);\n    p.xz = clamp(p.xz , -pi * 1.5*2.,pi * 1.5*2.);\n    p.xz = mod(p.xz , ii) - ii/2.;\n    float piller = Pile(p);\n    p.y += sin(t * pi  + iTime) * 2.6;\n    float sp = length(p) - .8;\n    o = min(piller,o);\n    if(o > sp)\n    {\n        id = random(dd);\n        o = sp;\n    }\n    return vec2(o,id);\n}\n\nvec2 march(vec3 cp, vec3 rd)\n{\n    float depth = 0.;\n    for(int i = 0 ; i < 99 ; i++)\n    {\n        vec3 rp = cp + rd * depth;\n        vec2 d = map(rp);\n        nearest = (d.x < nearest)?d.x:nearest;\n        if(abs(d.x) < 0.01)\n        {\n            return vec2(depth,d.y);\n        }\n        depth += d.x;\n    }\n    return vec2(-depth,0.);\n}\n\nvec3 hsv2rgb(float h,float s,float v)\n{\n    return ((clamp(abs(fract(h+vec3(0,2,1)/3.)*6.-3.)-1.,0.,1.)-1.)*s+1.)*v;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = (fragCoord.xy * 2.0 - iResolution.xy) / min(iResolution.x, iResolution.y);\n\tvec3 col = vec3(.8);\n    vec3 bcol = col;\n    vec3 cp = vec3(0.,-0.,-20.);\n    float tim = iTime/1.6;\n    float t = floor(tim) + pow(fract(tim),4.);\n    cp.xz *= rot(t*pi/4.);\n    vec3 target = vec3(0.,0.,0.);\n    \n    vec3 cd = normalize(target - cp);\n    vec3 cs = vec3(cross(cd , vec3(0.,1.,0.)));\n    vec3 cu = vec3(cross(cd , cs));\n    \n    float fov = 2.5;\n    vec3 rd = normalize(cd * fov + cs * p.x + cu * p.y);\n    \n    vec2 d = march(cp,rd);\n    \n    if(d.x > 0.)\n    {\n        vec3 pos = cp + rd * d.x;\n        vec2 e = vec2(0.,0.01);\n        \n        vec3 N = -normalize(map(pos).x - vec3(map(pos - e.xyy).x , map(pos - e.yxy).x,map(pos - e.yyx).x));\n        col = N;\n        vec3 sun = normalize(vec3(2.,4.,8.));\n        float rim = 1. - abs(dot(rd , N));\n        float stepdiff = 6.;\n        float stepsp = 2.;\n        float diff = max(0.,dot(N,sun)) * .7 + .3  ;\n        float sp = max(0.,dot(reflect(-N,sun),rd));\n        \n        if(d.y == 0.)\n        {\n            sp = pow(sp , 20.);\n        \tcol = vec3(.8);\n        }\n        else\n        {\n            sp = pow(sp , 20.);\n        \tcol = hsv2rgb(d.y * d.y * 1.5 , 1.,1.);\n        }\n        sp = floor(stepsp * sp) / stepsp;\n        diff = floor(stepdiff * diff) / stepdiff;\n        \n        sp = smoothstep(0.,1.,sp);\n        col = col + sp * vec3(1.);\n        float fine = 29.* max(0., (1. -  diff )) * step(diff , 0.6);\n        float density = .9 * max(0., (diff ));\n        col =col* step(.2, length((mod(pos * fine ,density) - density/2.)));\n        \n        vec3 pos1 = pos + cu *  0.001 + cs * 0.001;\n        vec3 pos2 = pos + cs * -0.001 + cu * 0.001;\n        vec3 N1 = -normalize(map(pos1).x - vec3(map(pos1 - e.xyy).x , map(pos1 - e.yxy).x,map(pos1 - e.yyx).x));\n        vec3 N2 = -normalize(map(pos2).x - vec3(map(pos2 - e.xyy).x , map(pos2 - e.yxy).x,map(pos2 - e.yyx).x));\n        float NN = length(N - N1) + length(N - N2);\n        if(NN > .07)\n        {\n            col *= 0.;\n        }\n    }else if(abs(nearest) < 0.02)\n    {\n        col *= 0.;\n    }\n    \n    fragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tlKcWd.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 1, 19, 19, 62], [63, 63, 89, 89, 135], [180, 180, 204, 204, 304], [306, 306, 326, 326, 508], [510, 510, 528, 528, 944], [946, 946, 976, 976, 1288], [1290, 1290, 1329, 1329, 1408], [1410, 1410, 1467, 1467, 3631]]}
{"id": "tltcWB", "name": "Introduction to shading", "author": "Draedrus", "description": "simple scene", "tags": ["raytracing", "simple", "phong", "blinn"], "likes": 0, "viewed": 42, "published": "Public", "date": "1610041377", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define RES iResolution\n#define LIGHT_ON\n#define DIFFUSE_TERM_ON\n#define SPECULAR_ON\n#define SHADOWS_ON\nfloat is(vec3 ro, vec3 rd, vec3 sc, float sr, out float tmin, out float tmax)\n{\n    vec3 Z = ro-sc;\n    float B = 2.0 * dot(rd, Z);\n  \n    float C = Z.x*Z.x+Z.y*Z.y+Z.z*Z.z-sr*sr;\n    float D = B*B - 4.0*C;\n    float d = -1.0;\n    if(D>=0.0) {\n        if(C==0.0) {\n            tmin = -B/2.0;\n            tmax = -1.;\n            d = 0.0;\n        }else{\n            tmin = (-B-sqrt(D))/2.0;\n            tmax = (-B+sqrt(D))/2.0;\n            d = 1.0;\n        }\n    }\n    return d;\n}\n\nvoid build(vec3 ro, vec3 rd, vec3 pt, vec3 N, vec3 ic, inout vec4 s, inout vec3 oc)\n{\n    float _d = dot(rd, N);\n    float d = _d!=0.?(dot(pt-ro, N)/_d):100.; d = d<0.?1000.:d;\n    if(d>0. && d<s.x)\n    {\n        s = vec4(d, N);\n        oc = ic;\n    }\n}\n\nvoid scene(vec3 ro, vec3 rd, inout vec4 s, inout vec3 oc)\n{\n    s = vec4(1000.f, vec3(0., 1., 0.));\n    build(ro, rd, vec3(0.), vec3(0., 1., 0.), vec3(1., 1., 0.), s, oc);\n    build(ro, rd, vec3(2., 0., 0.), vec3(-1., 0., 0.), vec3(1., 0., 0.), s, oc);\n    build(ro, rd, vec3(-2., 0., 3.), normalize(vec3(0.)-vec3(-2, 0., 3.)), vec3(0.5, 0.5, 1.), s, oc);\n    float tmin = 100., tmax = -100.;\n    float sp = is(ro, rd, vec3(-0.2, .5, 0.), 1., tmin, tmax);\n    if(sp>-1. && s.x>tmin && tmin>0. && tmin>0.)\n    {\n        s = vec4(tmin, normalize((ro+rd*tmin)-vec3(-0.2, .5, 0.)));\n        oc = vec3(0., 1., 0.);\n    }\n}\n\nfloat shadows(vec3 ro, vec3 Lp)\n{\n    float tmin = 0., tmax = 0.;\n    vec4 s = vec4(1000., 0., 0., 0.);\n    vec3 oc = vec3(0.);\n    vec3 d = normalize(Lp-ro);\n    scene(ro, d, s, oc);\n    float ds = max(0., dot(d, normalize(Lp-(ro+d*s.x))));\n    return (1.-ds)+ds*exp(-1.8*.5*max(0., 2.-s.x));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord-.5*RES.xy)/RES.y;\n\n    // setup\n    vec3 ro = vec3(0., 1., -4.);\n    vec3 rd = normalize(vec3(uv, 1.));\n    vec3 tgt = vec3(0.);\n    vec3 lw = vec3(2., 0., 0.);\n    vec3 up = vec3(0., 1., 0.);\n    vec3 fwd = normalize(tgt-ro);\n    vec3 left = normalize(cross(fwd, up));\n    up = normalize(cross(left, fwd));\n    \n    rd = mat3(left, up, fwd)*rd;\n    \n    vec3 Lp = vec3(2.0*sin(iTime), 0.7, 2.0*cos(iTime))+vec3(-0.5, 0., 0.);\n    vec3 N = vec3(0., 1., 0.);\n    vec4 s = vec4(1000.f, N);\n    vec3 c = vec3(0.);\n    scene(ro, rd, s, c);\n    \n    vec3 p = ro+rd*s.x;\n    vec3 L = normalize(p-Lp);\n    vec3 H = normalize(L+rd);\n    float Ld = length(Lp-p);\n\n    vec3 col = vec3(0.);\n    // https://github.com/stackgl/glsl-specular-cook-torrance/blob/master/index.glsl\n    float NoV = dot(-rd, s.yzw);\n    float NoL = dot(L, s.yzw);\n    float HoN = max(0., dot(H, s.yzw));\n    float HoV = max(0., dot(H, rd));\n    float HoL = max(0., dot(H, L));\n    float F = 0.02+0.98*pow(1.-max(0., NoV), 5.);\n    float R = 0.6;\n    float D = 1./max(0.001, ((NoV+sqrt((NoV-R*NoV) * NoV + R))*(NoL+sqrt((NoL-R*NoL) * NoL + R))));\n    float G = clamp(min((2.*HoN*NoV)/HoV, (2.*HoN*NoL)/HoL), 0.001, 1.);\n    \n    col =\n    #if defined(LIGHT_ON)\n    (\n    c\n    #if defined(DIFFUSE_TERM_ON)\n    *max(0., NoV)/Ld\n    #endif\n    #if defined(SPECULAR_ON)\n    +D*F*G/max(0.01, 3.14*NoV*NoL)\n    #endif\n    )\n    #if defined(SHADOWS_ON)\n    *max(.0, shadows(p+s.yzw*0.01, Lp))\n    #endif\n    #else\n    vec3(1.);\n    #endif\n    ;\n    // Output to screen\n    col = col / (1.+col);\n    fragColor = vec4(pow(col*col*(3.-2.*col), vec3(0.7 / 2.2)),1.0);\n    //fragColor.rgb = vec3(1./(NoL+sqrt((NoL-R*NoL) * NoL + R)));\n    //fragColor.rgb = vec3(HoV-HoL);\n    //fragColor.rgb = L;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tltcWB.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[104, 104, 183, 183, 582], [584, 584, 669, 669, 837], [839, 839, 898, 898, 1456], [1458, 1458, 1491, 1491, 1753], [1755, 1755, 1812, 1862, 3639]]}
{"id": "tltczl", "name": "RayMarching Sphere 球体", "author": "hanker", "description": "普通的ray march 球体，附加一点点改变", "tags": ["raymarch"], "likes": 0, "viewed": 154, "published": "Public API", "date": "1609750145", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define MAX_STEPS 100\n#define SURFACE_DIST  .01\n#define MAX_DIST  100.\nfloat GetDist(vec3 p){\n    vec4 sphere = vec4(0.,1.5,6.,1.5);\n    float dS = length(p - sphere.xyz) - sphere.w;\n    float dG = p.y;\n    return min(dS,dG);\n}\nfloat RayMartch(vec3 ro,vec3 rd){\n    float d = 0.;\n    vec3 p = ro;\n    for(int i = 0; i < MAX_STEPS; i++){\n        p = ro + rd * d;\n        float dS = GetDist(p);\n        d += dS;\n        if(dS < SURFACE_DIST || d > MAX_DIST)break;\n    }\n    return d;\n}\nvec3 GetNormal(vec3 p){\n    float d = GetDist(p);\n    vec2 e = vec2(.001,0.);\n    vec3 n = d - vec3(\n        GetDist(p - e.xyy),GetDist(p - e.yxy),GetDist(p - e.yyx)\n    );\n    return normalize(n);\n}\nfloat GetLight(vec3 p){\n    vec3 lightPos = vec3(0.,8.,1.);\n    lightPos.xz += vec2(sin(iTime),cos(iTime));\n    vec3 ld =  normalize(lightPos - p);\n    vec3 normal = GetNormal(p);\n    float dif = clamp(dot(normal,ld),1.,1.);\n    \n    //shadow\n    float d = RayMartch(p + normal * SURFACE_DIST * 2.,ld);\n    if(d < length(lightPos - p))dif *= .5;\n    return dif;\n}\nvoid mainImage(out vec4 fragColor,in vec2 fragCoord){\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    uv = uv * 2. - 1.;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    uv.y  += 1.;\n    vec3 ro = vec3(0.,1.,-3.);\n    vec3 rd = normalize(vec3(uv.x,uv.y,0.) - ro);\n    float d = RayMartch(ro,rd);\n\n    vec3 p = ro + rd * d;\n\n    float diffuse = GetLight(p);\n    vec3 col = vec3(diffuse);\n\n    fragColor = vec4(col,1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tltczl.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[71, 71, 93, 93, 227], [228, 228, 261, 261, 483], [484, 484, 507, 507, 683], [684, 684, 707, 707, 1047], [1048, 1048, 1101, 1101, 1471]]}
{"id": "tlVcDD", "name": "FS Physics Probe Panel Animation", "author": "GabrieleGiuseppini", "description": "Experiments for the animation when opening the Physics Probe panel in Floating Sandbox.", "tags": ["floatingsandbox"], "likes": 0, "viewed": 53, "published": "Public", "date": "1611168484", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float GetNoise(float y, float seed, float time) // -> (0.0, 1.0)\n{\n    #define NOISE_RESOLUTION 0.25\n    float s1 = texture(iChannel1, vec2(NOISE_RESOLUTION * y + time, seed)).r;\n    float s2 = texture(iChannel1, vec2(NOISE_RESOLUTION * y - time, seed)).r;\n    \n    #define NOISE_THRESHOLD .65\n    s1 = (clamp(s1, NOISE_THRESHOLD, 1.) - NOISE_THRESHOLD) * 1. / (1. - NOISE_THRESHOLD);\n    s2 = (clamp(s2, NOISE_THRESHOLD, 1.) - NOISE_THRESHOLD) * 1. / (1. - NOISE_THRESHOLD);\n    \n    return max(s1, s2);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // Normalized pixel coordinates\n    vec2 _uv = fragCoord/iResolution.xy;\n    //uv.y /= (iResolution.x / iResolution.y); // obey aspect ratio\n    \n    // uv: 0. -> 1.\n    \n    //\n    // Here we simulate this shader running in OpenGL as follows:\n    // - The panel occupies only a part of the screen\n    // - The texture lives in an Atlas and thus the extent\n    //   of the texture coordinates are somewhere arbitrary in the\n    //   texture coordinates space\n    // - The non-underscored variables are vertex attributes\n    //\n    // NDC screen x,y: -1.0 -> 1.0\n    // Texture x,y: 0.0 -> 1.0 (in reality it will be from atlas coordinates)\n    // Panel size NDC: w=1.0 h=0.5 (width is half of the screen)\n    // Quad x: -0.5 -> 0.5 (twice as wide as texture)\n    // Quad y: -0.25 -> 0.25\n    \n    float paramWidthNdc = 1.0;\n    vec2 _quadTopLeft = vec2(-0.5, 0.25);\n    vec2 _quadBottomRight = vec2(0.5, -0.25);\n        \n    // Time: phases:\n    // 1) from 0 to  4: inside=1, opening\n    // 2) from 4 to  5: still\n    // 3) from 5 to  9: inside=0. closing\n    // 4) from 9 to 10: still\n    #define SPEED 1.2\n    float _tmpTime = mod((float(iTime) * SPEED), 10.); // 0 -> 10\n    float vertexIsOpening = 1. - step(5., _tmpTime);\n    _tmpTime = mod(_tmpTime, 5.) / 4.; // 0 -> 1.25\n    _tmpTime = min(_tmpTime, 1.); // Pause\n    \n    // tmpTime: 0. -> 1.\n        \n    vec2 vertexCoordinatesNdc = _uv * 2. - vec2(1.0); // -1.0 -> 1.0\n    \n    // Vertex texture coords are rescaled so that they are 0->1 inside the quad NDC\n    vec2 vertexTextureCoordinates = vec2(\n        vertexCoordinatesNdc.x + 0.5, // -0.5 -> 1.5\n        (vertexCoordinatesNdc.y + 0.25) * 2.); // -1.5 -> 2.5\n\n    // Opening/Closing xLimits\n    float _width = paramWidthNdc * _tmpTime; // 0.0 -> 1.0\n    vec2 xLimitsNdc = vec2(\n        vertexIsOpening * (0. - _width / 2.) + (1. - vertexIsOpening) * (-paramWidthNdc / 2. + _width / 2.), \n        vertexIsOpening * (0. + _width / 2.) + (1. - vertexIsOpening) * (paramWidthNdc / 2. - _width / 2.)); // -0.5 -> 0.5        \n    \n    // Simulate quad by clipping outside of it\n    vec2 _uvNdc = (_uv - vec2(.5)) *  2.; // -1.0 -> 1.0\n    if (_uvNdc.x < _quadTopLeft.x\n        || _uvNdc.x > _quadBottomRight.x\n        || _uvNdc.y < _quadBottomRight.y\n        || _uvNdc.y > _quadTopLeft.y)\n    {\n        fragColor = vec4(0.);\n        return;\n    }\n    \n    ///////////////////////////////////////////////////////////////////////////\n    \n    //\n    // Flanges\n    //\n    \n    float currentWidthNdc = xLimitsNdc.y - xLimitsNdc.x; // 0.0 -> 0.5\n    float midXNdc = xLimitsNdc.x + currentWidthNdc / 2.;\n    float widthFraction = currentWidthNdc / paramWidthNdc;\n    \n    float noise = GetNoise(\n        vertexCoordinatesNdc.y / (.4 * paramWidthNdc * .5), \n        .2 * step(midXNdc, vertexCoordinatesNdc.x), \n        widthFraction / 5.);\n    \n    float flangeLengthNdc = (0.25 + noise * .4) * paramWidthNdc / 2.;\n    \n    // Flatten flange when panel is too small or almost fully open\n    flangeLengthNdc *= (smoothstep(.0, .46, widthFraction) - smoothstep(.54, 1., widthFraction));\n    \n    // Make flanges close to x Limits, either external or internal\n    // depending on whether we're closing or opening\n    float leftFlange = \n        vertexIsOpening * smoothstep(0.0, flangeLengthNdc, vertexCoordinatesNdc.x - xLimitsNdc.x)\n        + (1. - vertexIsOpening) * (1. - smoothstep(0.0, flangeLengthNdc, xLimitsNdc.x - vertexCoordinatesNdc.x));\n    float rightFlange = \n        vertexIsOpening * smoothstep(0.0, flangeLengthNdc, xLimitsNdc.y - vertexCoordinatesNdc.x)\n        + (1. - vertexIsOpening) * (1. - smoothstep(0.0, flangeLengthNdc, vertexCoordinatesNdc.x - xLimitsNdc.y));\n        \n    float panelDepth = \n        step(vertexCoordinatesNdc.x, midXNdc) * leftFlange\n        + step(midXNdc, vertexCoordinatesNdc.x) * rightFlange;\n                \n    float inPanelQuad = step(xLimitsNdc.x, vertexCoordinatesNdc.x) * step(vertexCoordinatesNdc.x, xLimitsNdc.y);\n                     \n    //\n    // Texture\n    //\n    \n    vec4 cTexture = texture(iChannel0, vertexTextureCoordinates);\n    \n           \n    //\n    // Final color\n    //\n            \n    vec4 color = vec4(cTexture.xyz, panelDepth);\n    \n    // Add white contour\n    float panelBorderDepth = max(\n        abs(inPanelQuad - panelDepth),\n        1.0 - smoothstep(0.0, 0.005, min(abs(vertexCoordinatesNdc.x - xLimitsNdc.x), abs(vertexCoordinatesNdc.x - xLimitsNdc.y))));\n    color = mix(\n        color,\n        vec4(1.),\n        panelBorderDepth);\n           \n    /* TEST: visualize noise\n    color = vec4(GetNoise(\n        vertexCoordinatesNdc.y / paramWidthNdc * 2., \n        .2 * step(midXNdc, vertexCoordinatesNdc.x), \n        widthFraction / 4.));\n    */\n    \n    /////////////////////////////////////////////////////////////////////////////\n    \n    fragColor = mix(vec4(0.), color, color.w);\n}", "image_inputs": [{"id": "4dXGRn", "previewfilepath": "/media/ap/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg", "ctype": "texture"}, {"id": "4sf3Rn", "previewfilepath": "/media/ap/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png", "channel": 1, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tlVcDD.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 66, 66, 506], [508, 508, 563, 599, 5441]]}
{"id": "tlVyDz", "name": "Peacock Feather Flame", "author": "jarble", "description": "Based on my [url=https://www.shadertoy.com/view/tldcRS]\"Fractal Graffiti 3.\"[/url]", "tags": ["fractal"], "likes": 2, "viewed": 151, "published": "Public API", "date": "1610857247", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.0);\n    vec3 col;\n    float t;\n    \n    for(int c=0;c<3;c++){\n\t    vec2 uv = (fragCoord*50.0-iResolution.xy)/iResolution.y/10.0;\n        uv += iTime/10.0;\n        t = iTime+float(c)/10.;\n        float scale = 5.0;\n        float scale1 = 1.4;\n        for(int i=0;i<20;i++)\n        {\n            \n            uv=cos(uv/(2.0+sin((uv.x+uv.y)/10.0))-(uv.yx/(2.0+sin(fract(iTime/2.0+uv.x+uv.y))))/scale)*scale/1.5+scale1*scale;\n            uv /= scale1;\n        \t//uv += cos(uv/100.0);\n        \tuv=uv.yx+col.xy;\n        }\n     col[c] = fract((uv.x)-(uv.y));\n\t}\n    \n    fragColor = vec4(vec3(col),1.0);\n    \n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tlVyDz.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 1, 58, 58, 685]]}
{"id": "tlVyWh", "name": "Triangle - gradient 2D", "author": "iq", "description": "Signed distance and gradient to a (rounded) triangle. Faster than central differences or automatic differentiation/dual numbers most probably.", "tags": ["2d", "distancefield", "sdf", "triangle", "gradient", "distance"], "likes": 7, "viewed": 338, "published": "Public API", "date": "1610944415", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// The MIT License\n// Copyright © 2021 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// Signed distance and gradient to a triangle. Probably\n// faster than central differences or automatic \n// differentiation/dual numbers.\n\n// List of other 2D distances+gradients:\n// https://iquilezles.org/www/articles/distgradfunctions2d/distgradfunctions2d.htm\n//\n// Circle:             https://www.shadertoy.com/view/WltSDj\n// Pie:                https://www.shadertoy.com/view/3tGXRc\n// Arc:                https://www.shadertoy.com/view/WtGXRc\n// Isosceles Triangle: https://www.shadertoy.com/view/3dyfDd\n// Triangle:           https://www.shadertoy.com/view/tlVyWh\n// Box:                https://www.shadertoy.com/view/wlcXD2\n// Quad:               https://www.shadertoy.com/view/WtVcD1\n// Cross:              https://www.shadertoy.com/view/WtdXWj\n// Segment:            https://www.shadertoy.com/view/WtdSDj\n// Hexagon:            https://www.shadertoy.com/view/WtySRc\n// Vesica:             https://www.shadertoy.com/view/3lGXRc\n// Smooth-Minimum:     https://www.shadertoy.com/view/tdGBDt\n// Parallelogram:      https://www.shadertoy.com/view/sssGzX\n\nfloat cro( in vec2 a, in vec2 b ) { return a.x*b.y - a.y*b.x; }\n\n// .x = f(p)\n// .y = ∂f(p)/∂x\n// .z = ∂f(p)/∂y\n// .yz = ∇f(p) with ‖∇f(p)‖ = 1\nvec3 sdgTriangle( in vec2 p, in vec2 v[3] )\n{\n    float gs = cro(v[0]-v[2],v[1]-v[0]);\n    vec4 res;\n    \n    // edge 0\n    {\n    vec2  e = v[1]-v[0];\n    vec2  w = p-v[0];\n    vec2  q = w-e*clamp(dot(w,e)/dot(e,e),0.0,1.0);\n    float d = dot(q,q);\n    float s = gs*cro(w,e);\n    res = vec4(d,q,s);\n    }\n    \n    // edge 1\n    {\n\tvec2  e = v[2]-v[1];\n    vec2  w = p-v[1];\n    vec2  q = w-e*clamp(dot(w,e)/dot(e,e),0.0,1.0);\n    float d = dot(q,q);\n    float s = gs*cro(w,e);\n    res = vec4( (d<res.x) ? vec3(d,q) : res.xyz,\n                (s>res.w) ?      s    : res.w );\n    }\n    \n    // edge 2\n    {\n\tvec2  e = v[0]-v[2];\n    vec2  w = p-v[2];\n    vec2  q = w-e*clamp(dot(w,e)/dot(e,e),0.0,1.0);\n    float d = dot(q,q);\n    float s = gs*cro(w,e);\n    res = vec4( (d<res.x) ? vec3(d,q) : res.xyz,\n                (s>res.w) ?      s    : res.w );\n    }\n    \n    // distance and sign\n    float d = sqrt(res.x)*sign(res.w);\n    \n    return vec3(d,res.yz/d);\n\n}\n\n#define AA 2\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 tot = vec3(0.0);\n    \n    #if AA>1\n    for( int m=0; m<AA; m++ )\n    for( int n=0; n<AA; n++ )\n    {\n        // pixel coordinates\n        vec2 o = vec2(float(m),float(n)) / float(AA) - 0.5;\n        vec2 p = (-iResolution.xy + 2.0*(fragCoord+o))/iResolution.y;\n        #else    \n        vec2 p = (-iResolution.xy + 2.0*fragCoord)/iResolution.y;\n        #endif\n\n        // animate\n        float time = iTime;\n        vec2 v[3] = vec2[3](\n            vec2(-0.8,-0.3) + 0.5*cos( 0.5*time + vec2(0.0,1.9) + 4.0 ),\n            vec2( 0.8,-0.3) + 0.5*cos( 0.7*time + vec2(0.0,1.7) + 2.0 ),\n            vec2( 0.0, 0.3) + 0.5*cos( 0.9*time + vec2(0.0,1.3) + 1.0 ) );\n\n        // corner radious\n        float ra = 0.1*(0.5+0.5*sin(iTime*1.2));\n\n        // sdf(p) and gradient(sdf(p))\n        vec3  dg = sdgTriangle(p,v);\n        float d = dg.x-ra;\n        vec2  g = dg.yz;\n\n        // central differenes based gradient, for comparison\n        // g = vec2(dFdx(d),dFdy(d))/(2.0/iResolution.y);\n\n        // coloring\n        vec3 col = (d>0.0) ? vec3(0.9,0.6,0.3) : vec3(0.4,0.7,0.85);\n        col *= 1.0 + vec3(0.5*g,0.0);\n      //col = vec3(0.5+0.5*g,1.0);\n        col *= 1.0 - 0.7*exp(-8.0*abs(d));\n        col *= 0.9 + 0.1*cos(150.0*d);\n        col = mix( col, vec3(1.0), 1.0-smoothstep(0.0,0.01,abs(d)) );\n\n \t    tot += col;\n    #if AA>1\n    }\n    tot /= float(AA*AA);\n    #endif\n\n\tfragColor = vec4( tot, 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tlVyWh.jpg", "access": "shaders20k", "license": "mit", "functions": [[1217, 2138, 2173, 2173, 2201], [2203, 2298, 2343, 2343, 3260], [3276, 3276, 3333, 3333, 4747]]}
{"id": "tlVyWR", "name": "Beginner Mix expanded line", "author": "raoul", "description": "Simple line expand.", "tags": ["line"], "likes": 0, "viewed": 45, "published": "Public", "date": "1610832441", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n#define TUTORIAL 2\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    \n    \n    \n#if TUTORIAL == 1    //le drapeau\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Time varying pixel color\n    //vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n    vec3 col = vec3(1.0,0.0,0.0); \n    //comme les coordonnées sont normalisé alors le max est a 1 \n    float tier = 1. / 3.; \n    \n    if(uv.x < tier){\n        col.x = 0.; \n    }\n    \n    if(tier < uv.x && uv.x < (tier * 2.)){\n     col.x = 1.; \n     col.y = 1.; \n     col.z = 1.; \n    }\n    \n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n    \n #elif TUTORIAL == 2    //la ligne\n     vec2 uv = fragCoord/iResolution.xy;\n     vec3 col = vec3(0.); \n     \n     //c est cette limite qui s'incremente \n     float limita = abs(mod(0.50 * iTime, 1.0)) + 0.1;\n     \n     if(limita < 0.5){\n     limita = 0.48;\n     }\n     \n     float limitb = 0.47; \n     step(0.1, limitb); \n     \n     \n     if( uv.y < limita && uv.y> limitb)\n     {\n         col = vec3(0.8,0.2,mod(0.1 * iTime, 1.0));\n     }\n     \n     fragColor = vec4(col,1.0);\n     \n #endif\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tlVyWR.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[22, 22, 79, 129, 1163]]}
{"id": "tlVyzw", "name": "ball man", "author": "regis", "description": "ball ", "tags": ["3d", "raymarch"], "likes": 2, "viewed": 55, "published": "Public", "date": "1610755005", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec4 tpos = vec4(0.0, 0.0, 0.0, 0.0);\nfloat angle_tpos;\nbool done = false;\nfloat dist = 0.0;\nvec4 sphball;\n\nmat2 Rot(float a){\n    float s = sin(a);\n    float c = cos(a);\n    return mat2(c, -s, s, c);\n}\n\nmat3 RotX(float a){\n    float s = sin(a);\n    float c = cos(a);\n    \n    return mat3(1., .0, .0, .0, c, -s, .0, s, c);\n\n}\n\nmat3 RotY(float a){\n    float s = sin(a);\n    float c = cos(a);\n    \n    return mat3(c, .0, s, .0, 1., .0, -s, .0, c);\n\n}\n\nmat3 RotZ(float a){\n    float s = sin(a);\n    float c = cos(a);\n    \n    return mat3(c, -s, .0, s, c, .0, .0, .0, 1.);\n\n}\n\n\nfloat opExtrusion(in vec3 p, in float d, in float h) {\n    // d is the distance to the 2D shape using the x and y components of p\n    vec2 w = vec2(d, abs(p.z) - h);\n    return min(max(w.x, w.y), 0.0) + length(max(w, 0.0));\n}\n\n\nvec4 opElongate( in vec3 p, in vec3 h )\n{\n    //return vec4( p-clamp(p,-h,h), 0.0 ); // faster, but produces zero in the interior elongated box\n    \n    vec3 q = abs(p)-h;\n    return vec4( max(q,0.0), min(max(q.x,max(q.y,q.z)),0.0) );\n}\n\n\nvec3 opTwist(in vec3 p, in float t) {\n    float c = cos(t * p.y);\n    float s = sin(t * p.y);\n    mat2 m = mat2(c, -s, s, c);\n    return vec3(m * p.xz, p.y);\n}\n\n// from iq\nfloat Noise( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n  \tf = f*f*(3.0-2.0*f);\n  \tvec2 uv = (p.xy+vec2(37.0,17.0)*p.z) + f.xy;\n  \tvec2 rg = textureLod( iChannel0, (uv+0.5)/256.0, 0.0).yx;\n  \treturn mix( rg.x, rg.y, f.z );\n}\n\n// ref https://www.shadertoy.com/view/Xs33Df\nfloat Noise3D(in vec3 p){\n    const vec3 s = vec3(7, 157, 113);\n\tvec3 ip = floor(p); // Unique unit cell ID.\n    vec4 h = vec4(0., s.yz, s.y + s.z) + dot(ip, s);\n\tp -= ip; // Cell's fractional component.\n    p = p*p*(3. - 2.*p);\n    h = mix(fract(sin(h)*43758.5453), fract(sin(h + s.x)*43758.5453), p.x);\n    h.xy = mix(h.xz, h.yw, p.y);\n    return mix(h.x, h.y, p.z); // Range: [0, 1].\n\t\n}\n\nvec2 hash( vec2 p )\n{\n\tp = vec2( dot(p,vec2(127.1,311.7)),\n\t\t\t dot(p,vec2(269.5,183.3)) );\n\treturn -1.0 + 2.0*fract(sin(p)*43758.5453123);\n}\n\nfloat noise( in vec2 p )\n{\n\tconst float K1 = 0.366025404; // (sqrt(3)-1)/2;\n\tconst float K2 = 0.211324865; // (3-sqrt(3))/6;\n\t\n\tvec2 i = floor( p + (p.x+p.y)*K1 );\n\t\n\tvec2 a = p - i + (i.x+i.y)*K2;\n\tvec2 o = (a.x>a.y) ? vec2(1.0,0.0) : vec2(0.0,1.0);\n\tvec2 b = a - o + K2;\n\tvec2 c = a - 1.0 + 2.0*K2;\n\t\n\tvec3 h = max( 0.5-vec3(dot(a,a), dot(b,b), dot(c,c) ), 0.0 );\n\t\n\tvec3 n = h*h*h*h*vec3( dot(a,hash(i+0.0)), dot(b,hash(i+o)), dot(c,hash(i+1.0)));\n\t\n\treturn dot( n, vec3(70.0) );\n}\n\nfloat fbm(vec2 uv)\n{\n\tfloat f;\n\tmat2 m = mat2( 1.6,  1.2, -1.2,  1.6 );\n\tf  = 0.5000*noise( uv ); uv = m*uv;\n\tf += 0.2500*noise( uv ); uv = m*uv;\n\tf += 0.1250*noise( uv ); uv = m*uv;\n\tf += 0.0625*noise( uv ); uv = m*uv;\n\tf = 0.5 + 0.5*f;\n\treturn f;\n}\n\nfloat FBM( in vec3 p )\n{\n    float n = 0.0;\n    n += 0.50000*Noise( p*1.0 );\n    n += 0.25000*Noise( p*2.0 );\n    n += 0.12500*Noise( p*4.0 );\n    n += 0.06250*Noise( p*8.0 );\n    n += 0.03125*Noise( p*16.0 );\n    return n/0.984375;\n}\n\n\nfloat sdCylinder(vec3 p, vec3 a, vec3 b, float r) {\n\tvec3 ab = b-a;\n    vec3 ap = p-a;\n    \n    float t = dot(ab, ap) / dot(ab, ab);\n    //t = clamp(t, 0., 1.);\n    \n    vec3 c = a + t*ab;\n    \n    float x = length(p-c)-r;\n    float y = (abs(t-.5)-.5)*length(ab);\n    float e = length(max(vec2(x, y), 0.));\n    float i = min(max(x, y), 0.)-0.1;\n    \n    return e+i;\n}\n\nfloat sdRoundBox( vec3 p, vec3 b, float r )\n{\n  vec3 q = abs(p) - b;\n  return -(length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0) - r);\n}\n\nfloat Box(vec3 p, vec3 sc, float r){\n    return length(max(abs(p)-sc, 0.))-r;\n}\n\nfloat Box2(vec3 p, vec3 sc, float r, float an){\n    an = 80.0;\n    vec3 cs = vec3(cos(an*3.1415/180.0), sin(an*3.1415/180.0),cos(an*3.1415/180.0));\n    float c2 = length(cs);\n    \n    float a = length(max( abs(p)-(sc)  , 0.0)) - r;\n    float b = length(max(abs(p)-vec3(1.0, 2.0, 1.0), 0.));\n    return a;\n}\n\nfloat Capsule(vec3 p, vec3 sc, float r){\n    vec3 cs = vec3(cos(90.0*3.1415/180.0), sin(90.0*3.1415/180.0),cos(90.0*3.1415/180.0));  \n    float a = length(max( abs(p)- (sc*cs)  , 0.0)) - r;\n    return a;\n}\n\nfloat sdEllipsoid( vec3 p, vec3 r )\n{\n  float k0 = length(p/r);\n  float k1 = length(p/(r*r));\n  return k0*(k0-1.0)/k1;\n}\n\nfloat opRep( in vec3 p, in vec3 c, vec3 sc, float r )\n{\n    vec3 q = mod(p+0.5*c,c)-0.5*c;\n    return Box( q, sc, r );\n}\n\nfloat opRepS( in vec3 p, in vec3 c, vec4 pos )\n{\n    vec3 q = mod(p+0.5*c,c)-0.5*c;\n    return length(q) - pos.w;\n}\n\nvec3 add_tpos(vec3 tp){\n    return vec3(tp.x+tpos.x, tp.y+tpos.y, tp.z+tpos.z);\n    \n}\n\nvec3 rot_y(vec3 tp, float a){\n    tp.xz *= Rot(a);\n    return tp;\n\n}\n\nfloat sdfSegment(in vec3 p, in vec3 a, in vec3 b, in float r){\n\n    \n    float h = min(1.0, max(0.0, dot(p-a, b-a) / dot(b-a, b-a)));\n   // a = a*exp(-4.*h);\n    //r =r-sin(9.0*3.1415*h)*0.2;\n    //r =r+exp(-4.*h);\n    //r = r -4.*h*(1.-h)-0.2*cos(10.*h+4.*iTime);\n    return length(p-a-(b-a)*h)-r;\n    \n\n}\n\nfloat opRepSeg( in vec3 p, in vec3 c,  in vec3 a, in vec3 b, in float r)\n{\n    vec3 q = mod(p+0.5*c,c)-0.5*c;\n    return sdfSegment(q, a, b, r);\n}\n\n\n\nfloat det( vec2 a, vec2 b ) { return a.x*b.y-b.x*a.y; }\nvec4 sdBezier2( vec3 p, vec3 va, vec3 vb, vec3 vc )\n{\n  vec3 w = normalize( cross( vc-vb, va-vb ) );\n  vec3 u = normalize( vc-vb );\n  vec3 v =          ( cross( w, u ) );\n  //----  \n  vec2 m = vec2( dot(va-vb,u), dot(va-vb,v) );\n  vec2 n = vec2( dot(vc-vb,u), dot(vc-vb,v) );\n  vec3 q = vec3( dot( p-vb,u), dot( p-vb,v), dot(p-vb,w) );\n  //----  \n  float mn = det(m,n);\n  float mq = det(m,q.xy);\n  float nq = det(n,q.xy);\n  //----  \n  vec2  g = (nq+mq+mn)*n + (nq+mq-mn)*m;\n  float f = (nq-mq+mn)*(nq-mq+mn) + 4.0*mq*nq;\n  vec2  z = 0.5*f*vec2(-g.y,g.x)/dot(g,g);\n//float t = clamp(0.5+0.5*(det(z,m+n)+mq+nq)/mn, 0.0 ,1.0 );\n  float t = clamp(0.5+0.5*(det(z-q.xy,m+n))/mn, 0.0 ,1.0 );\n  vec2 cp = m*(1.0-t)*(1.0-t) + n*t*t - q.xy;\n  //----  \n  float d2 = dot(cp,cp);\n  return vec4(sqrt(d2+q.z*q.z), t, q.z, -sign(f)*sqrt(d2) );\n}\n\n\nvec4 opRepBezier( in vec3 p, in vec3 c, vec3 va, vec3 vb, vec3 vc )\n{\n    vec3 q = mod(p+0.5*c,c)-0.5*c;\n    vec3 qa = mod(va+0.5*c,c)-0.5*c;\n    vec3 qb = mod(vb+0.5*c,c)-0.5*c;\n    vec3 qc = mod(vc+0.5*c,c)-0.5*c;\n    return  sdBezier2(q, va, vb, vc);\n}\n\n// http://iquilezles.org/www/articles/smin/smin.htm\nfloat smin( float a, float b, float k )\n{\n    float h = max(k-abs(a-b),0.0);\n    return min(a, b) - h*h*0.25/k;\n}\n\n// http://iquilezles.org/www/articles/smin/smin.htm\nfloat smax( float a, float b, float k )\n{\n    k *= 1.4;\n    float h = max(k-abs(a-b),0.0);\n    return max(a, b) + h*h*h/(6.0*k*k);\n}\n\nfloat sdCone( in vec3 p, in vec2 c, float h , float r)\n{\n  // c is the sin/cos of the angle, h is height\n  // Alternatively pass q instead of (c,h),\n  // which is the point at the base in 2D\n  vec2 q = h*vec2(c.x/c.y,-1.0);\n    \n  vec2 w = vec2( length(p.xz), p.y );\n  vec2 a = w - q*clamp( dot(w,q)/dot(q,q), 0.0, 1.0 );\n  vec2 b = w - q*vec2( clamp( w.x/q.x, 0.0, 1.0 ), 1.0 );\n  float k = sign( q.y );\n  float d = min(dot( a, a ),dot(b, b));\n  float s = max( k*(w.x*q.y-w.y*q.x),k*(w.y-q.y)  );\n  return sqrt(d)*sign(s)-r;\n}\n\nvec2 sdSegment(vec3 p, vec3 a, vec3 b)\n{\n    vec3 pa = p-a, ba = b-a;\n\tfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n\treturn vec2( length( pa - ba*h ), h );\n}\n\nvec4 eyel = vec4(-0.7,6.5, 3.75,0.3);\nvec4 eyer = vec4(0.7 ,6.5, 3.75, 0.3);\nvec2 sourcl = vec2(-0.7, 7.5);\nvec2 sourcr = vec2(0.7, 7.5);\n\nvec2 sdfMan(vec3 p){\n\n    vec4 s = eyel;\n    vec4 s2 = eyer;\n    \n    vec4 head = vec4(0.0, 6.0, 7.0, 3.);\n    \n    \n    vec2 d=vec2(0.0);;\n    \n   \n    //s.z += iTime;\n    //s.y += mod(iTime, 3.0);\n    vec3 sp = (p)-s.xyz;\n    //sp.xz *= Rot(iTime);\n    float sd = length((sp))-s.w;\n       \n       \n    \n    vec3 sp2 = (p)-s2.xyz;\n    //sp2.y += sin(iTime)*0.1;\n    float sd2 = length((sp2))-s2.w;\n    \n    \n    vec3 sph = (p)-head.xyz;\n    //sp2.y += sin(iTime)*0.1;\n    float sdh = length((sph))-head.w;\n    if (sdh > 6.0) return vec2(sdh, 3.0);\n    \n    vec3 bhead = p - vec3(0.0, 4.5, 5.0);\n    float sbhd = sdEllipsoid(bhead, vec3(2.5, 2.0, 3.0));\n    \n    \n    \n    vec4 tel = vec4(-0.8, 6.75, 3.35, 0.5);\n    vec3 tepl = p - tel.xyz;\n    float stepld = length(tepl)-tel.w;\n    \n    vec4 ter = vec4(0.8, 6.75, 3.35, 0.5);\n    vec3 tepr = p - ter.xyz;\n    float steprd = length(tepr)-ter.w;\n    \n    vec3 pn = p - vec3(0.0, 6.3-mod(iTime*0.1 ,0.1), 3.5);\n    pn *= RotX(-50.0*3.1415/180.0);\n    float snose = sdCone(pn, vec2(cos(77.*3.1415/180.0), sin(77.*3.1415/180.0)), 1.2, 0.2);\n    \n    vec4 stn1 = vec4(-.15, 5.65,2.3, 0.1);\n    sp2 = p-stn1.xyz;\n    float sdtn1 = length((sp2))-stn1.w;\n    \n    stn1 = vec4(.15, 5.65,2.3, 0.1);\n    sp2 = p-stn1.xyz;\n    float sdtn2 = length((sp2))-stn1.w;\n    \n    vec3 bouche = p - vec3(0.0, 4.9, 2.0);\n    float sbchd = sdEllipsoid(bouche, vec3(0.5, clamp(mod(iTime*0.3, 0.2), 0.1, 0.2), 0.5));\n    \n    pn = p - vec3(0.0, 5.9, 3.15);\n    pn *= RotX(-35.0*3.1415/180.0);\n    float sbec = sdCone(pn, vec2(cos(75.*3.1415/180.0), sin(75.*3.1415/180.0)), 1.2, 0.15);\n    \n    vec3 snp = p - vec3(0.0, 3.0, 3.0);\n    vec3 a = vec3(0.0, 3.0, 3.0);\n    vec3 b = vec3(0.0, 3.0, 1.0);\n    \n    vec2 se = sdSegment(p, vec3(0,2.5,3.00),  vec3(0.0,0.,3.) );\n    float sneckd = se.x-s.y*0.2;\n    //d = smax(d,-d2,0.04);\n    \n    vec3 cap = p - vec3(0.0, 4.0, 4.5);\n    cap.y += sin(cap.y+mod(iTime*0.2, 0.2));\n    float scap = sdEllipsoid(cap, vec3(3.5, 4.5, 3.5));\n    \n    vec3 spbc = p - vec3(0.0, 5.0, 5.5);\n    float sdbct = Box(spbc, vec3(5.0,5.0, 5.0), 0.0);\n    \n     cap = p - vec3(0.0, 4.0, 4.0);\n     cap.y += sin(cap.y+mod(iTime*0.2, 0.2));\n    float scap2 = sdEllipsoid(cap, vec3(3.2, 4.2, 3.2));\n    \n    float cut = smax(scap, -sdbct, 0.1);\n    cut = smax(cut, -scap2, 0.1);\n    \n    //\n    cap = p - vec3(-0.7, 6.5, 3.75);\n    float scapel = sdEllipsoid(cap, vec3(0.4, 0.4, 0.4));\n    \n    spbc = p - vec3(-0.7, 5.15, 3.75);\n    spbc.y -= mod(iTime, 0.5);\n    float sdbct2 = Box(spbc, vec3(1.0, 1.0, 1.0), 0.0);\n    \n    float cute = smax(scapel, -sdbct2, 0.4);\n    \n    cap = p - vec3(0.7, 6.5, 3.75);\n    scapel = sdEllipsoid(cap, vec3(0.4, 0.4, 0.4));\n    \n     spbc = p - vec3(0.7, 5.15, 3.75);\n     spbc.y -= mod(iTime, 0.5);\n     sdbct2 = Box(spbc, vec3(1.0, 1.0, 1.0), 0.0);\n    \n    float cute2 = smax(scapel, -sdbct2, 0.4);\n    \n    \n    float dhead = smin(sdh, sbhd, 2.0);\n    dhead = smax(dhead, -stepld, 0.5);\n    dhead = smax(dhead, -steprd, 0.5);\n    dhead = smin(dhead, snose, 0.1);\n    dhead = smax(dhead, -sdtn1, 0.1);\n    dhead = smax(dhead, -sdtn2, 0.1); \n    dhead = smax(dhead, -sbchd, 0.1); \n    dhead = smin(dhead, sbec, 0.1);\n    dhead = smin(dhead, sneckd, 0.3);\n             \n    float e = mod(iTime, 5.);\n    if(e >= 4.5){\n        dhead = smin(dhead, cute, 0.1);\n        dhead = smin(dhead, cute2, 0.1);\n    \n    }\n    \n     \n      d.x = sd;\n      d.y = -1.0;\n      \n       \n       if(sd2 < d.x)\n       {\n           d.x = sd2;\n          d.y = -2.0;\n       }\n       \n      if(dhead < d.x){\n          d.x = dhead;\n          d.y = 3.0;\n       }\n      /* if(scapel < d.x){\n          d.x = scapel;\n          d.y = 3.0;\n       }\n       if(sdbct2 < d.x){\n          d.x = sdbct2;\n          d.y = 1.0;\n       }*/\n       /*float e = mod(iTime, 5.);\n       if(e >= 4.){\n           if(cute < d.x){\n              d.x = cute;\n              d.y = 3.0;\n           }\n           if(cute2 < d.x){\n              d.x = cute2;\n              d.y = 3.0;\n           }\n       }*/\n      /* if(scap < d.x){\n          d.x = scap;\n          d.y = 3.0;\n       }*/\n       if(cut < d.x){\n          d.x = cut;\n          d.y = 1.0;\n       }\n       /*if(sdbct < d.x){\n          d.x = sdbct;\n          d.y = 3.0;\n       }\n       \n        /*if(stepld < d.x){\n          d.x = stepld;\n          d.y = 4.0;\n       }*/\n       \n       /*if(sbhd < d.x){\n          d.x = sbhd;\n          d.y = 4.0;\n       }*/\n           \n     /* if(pd < d.x){\n          d.x = pd;\n          d.y = 2.0;\n       }  */   \n       \n           \n     \n    return d;\n\n\n}\n \nvec2 GetDist(vec3 p, vec2 uv){\n\n\n    \n    vec4 s2 = vec4(3.0 ,3.0, 7.0, 1.0);\n    \n        \n    vec2 d=vec2(0.0);;\n    float pd = dot(p, vec3(0.0, 1.0, 0.0));\n    \n   // pd -=  Noise3D(p+iTime*5.0)*0.2 ;\n   // pd +=  0.1*(sin(1.0*p.x)+sin(1.0*p.z));\n    \n    //float fh = -0.1 + 0.05*(sin(2.0*p.x) + sin(2.0*p.z));\n   // pd = p.y - fh;\n    pd += -1.0+2.0*smoothstep(-0.5, 0.5, sin(1.0*p.x)+sin(1.0*p.y)+sin(1.0*p.z))*0.1;\n    vec4 sph = sphball;\n     \n    sph.y = sin(sph.y*3.1415+iTime*10.0)*5.0+5.0;\n    sph.z -= iTime*2.1;\n    \n    float x = -1.0 + 2.0*abs(fract(iTime*0.5)-0.5)/0.5;\n    sph.x = x*10.5;\n    \n    float fh = -0.1 - 0.05*(sin(p.x*1.0)+sin(p.z*1.0));\n    float gt = fract(iTime+0.1);\n    float l = length((p.xyz-sph.xyz).xz);\n     fh -= 0.4*sin(gt*10.0+l)*exp(-0.02*l*l )*exp(-0.02*gt ) * smoothstep(0.0, 0.1, gt);\n    pd -=  fh;\n    \n    \n    vec3 sp = p - sph.xyz;\n    //float sd = length(sp) - sph.w;\n    vec3 dim = vec3(3.0);\n    if(sph.y < 2.0){\n        dim.x = iTime*0.001+4.0;\n    }\n    float sd = sdEllipsoid(sp, dim);\n    \n    vec3 pm = vec3(x*10.5,sph.y, 14.0);\n    pm.z -= iTime*2.10;\n    d = sdfMan(p-pm);\n    \n        vec3 bp = p - vec3(25.0, -5.5, 0.0);\n    bp.y -= mod(iTime*2.0, 20.0);\n    vec3 c = vec3(50.0, 0.0, 25.0);\n    bp = mod(bp+0.5*c,c)-0.5*c;;\n    vec3 sc = vec3(5.0);\n    sc -= mod(iTime*2.0*0.25, 5.0);\n   // if(sc.x < 0.0)sc = vec3(5.0);\n    float bd = Box(bp, sc, 0.5);\n    bd += -1.0+2.0*smoothstep(-0.5, 0.5, sin(1.0*p.x)+sin(1.0*p.y)+sin(1.0*p.z))*0.1;\n    \n    float gr = smin(pd, bd, 0.5);\n      \n    //d.x = pd;\n    //d.y = 2.0;\n       \n    if(sd < d.x){\n        d.x = sd;\n        d.y = 5.0;\n    \n    }\n     \n    if(gr < d.x){\n        d.x = gr;\n        d.y = 2.0;\n    \n    }\n      \n   // \n    return d;\n    \n    \n}\n\nvec3 RayMarch2(vec3 eye, vec3 viewRayDirection, vec2 uv){\n    vec3 t = vec3(0.);\n    float max = -100000.0;\n    vec2 dd;\n    float depth = 0.0, end = 10.0;\n    for (int i = 0; i < 100; i++) {\n        t.yz = GetDist(eye + t.x * viewRayDirection, uv).xy;\n        \n                    \n        if (abs(t.y) < (t.y*0.01))break;\n                \n        t.x += t.y;\n        \n        if (t.x >= 100.0)break;\n        \n    }\n    if (t.x >= 100.0)t.x = -1.0;\n    \n    return t;\n\n\n}\n\n\n\n\nfloat GetLight(vec3 p, vec2 uv, vec3 lg, out vec3 n){\n    vec3 lightpos = lg;\n    lightpos.xz += vec2(sin(iTime), cos(iTime));\n    vec3 l = normalize(lightpos-p);\n    \n    vec2 d = GetDist(p, uv);\n    vec2 e = vec2(0.01, 0);\n    \n    \n   // float dd = d.x;\n    n = d.x - vec3(\n        GetDist(p-e.xyy, uv).x,\n        GetDist(p-e.yxy, uv).x,\n        GetDist(p-e.yyx, uv).x);\n    \n    n = normalize(n);\n    \n    float dif = clamp(dot(n, l), .0, 1.);\n   // float dif = clamp(dot(n, l), 0., 1.);\n   // vec3 dd = RayMarch2(p+n*.01, l, uv);\n    //if(dd.x < length(lightpos-p))dif *= 0.1;\n    return (dif) ;\n\n}\n\n\nfloat calcAO( in vec3 pos, in vec3 nor )\n{\n\tfloat occ = 0.0;\n    float sca = 1.0;\n    for( int i=0; i<5; i++ )\n    {\n        float hr = 0.01 + 0.12*float(i)/4.0;\n        vec3 aopos =  nor * hr + pos;\n        float dd = GetDist( aopos , vec2(1.0)).x;\n        occ += -(dd-hr)*sca;\n        sca *= 0.95;\n    }\n    return clamp( 1.0 - 3.0*occ, 0.0, 1.0 );    \n}\n\n\n\nvec3 GetLightM(vec3 p, vec2 uv, vec3 lg, out vec3 n, vec3 ro, vec3 rd){\n    vec3 lightpos = lg;\n    //lightpos.xz += vec2(sin(iTime), cos(iTime));\n    vec3 l = normalize(lightpos-p);\n    \n    vec2 d = GetDist(p, uv);\n    vec2 e = vec2(0.01, 0);\n    \n    n = d.x - vec3(\n        GetDist(p-e.xyy, uv).x,\n        GetDist(p-e.yxy, uv).x,\n        GetDist(p-e.yyx, uv).x);\n        \n     \n    \n    n = normalize(n);\n   \n    float occ = calcAO(p, n);       \n    float dif = clamp(dot(n, l), .0, 1.);\n    dif += occ*0.2;\n \n    vec3 dd = RayMarch2(p+n*.01, l, uv);\n    p = ro + rd * dd.x;\n    \n    \n    \n    /*if(dd.x < length(lightpos)){\n           if(dd.z == 2.0)\n        { \n        \n            vec3 col = vec3(length(uv))*texture(iChannel2, vec2(noise(uv+iTime))).rgb;\n            \n        }\n    vec3(0.0, 1.0, 0.0)-p/2.0\n    }*/\n    \n     \n    if((dd.x < length(lightpos-p)) && (dd.x > 0.0)){\n        if(dd.z == -1.0){\n            \n             vec3 col = vec3(dif) ;\n             return col*0.2;\n            \n\n        }\n        else if(dd.z == 1.0)\n        {\n             \n             return vec3(dif)*0.2;\n        }\n        else if(dd.z == 2.0)\n        {\n             \n             return vec3(dif)*0.2;\n        }\n        else if(dd.z == 3.0)\n        {\n             //vec3 col = texture(iChannel1, p.xz*0.5).rgb * n.y;\n             vec3 col = vec3(dif)*vec3(0.88, 0.69, 0.65); ;\n             return col*0.2;\n        }\n        else if(dd.z == 4.0){\n             vec3 colXZ = texture(iChannel2, p.xz*0.1).rgb;\n             vec3 colYZ = texture(iChannel2, p.yz*0.1).rgb;\n             vec3 colXY = texture(iChannel2, p.xy*0.1).rgb;\n             \n             \n             vec3 col = colYZ * n.x + colXZ * n.y + colXY*n.z;\n             \n             col -= vec3(.3);\n             return col;\n         }\n        else\n            return vec3(dif);\n            \n     }\n     else\n         return vec3(dif);\n\n}\nvec3 lightDir = normalize( vec3(0.5,0.6,0.) );\nconst mat2 m2 = mat2( 0.60, -0.80, 0.80, 0.60 );\n//ref: https://www.shadertoy.com/view/Msdfz8\nvec3 Cloud(vec3 bgCol,vec3 ro,vec3 rd,vec3 cloudCol,float spd)\n{\n    vec3 col = bgCol;\n    float t = iTime * 0.15* spd;\n    vec2 sc = ro.xz + rd.xz*((3.)*40000.0-ro.y)/rd.y;\n    vec2 p = 0.00002*sc;\n    float f = 0.0;\n  \tfloat s = 0.5;\n  \tfloat sum =0.;\n  \tfor(int i=0;i<5;i++){\n    \tp += t;t *=1.5;\n    \tf += s* textureLod( iChannel0, p/256.0, 0.0).x; p = m2*p*2.02;\n    \tsum+= s;s*=0.8;\n  \t}\n    float val = f/sum; \n    col = mix( col, cloudCol, smoothstep(0.5,0.8,val) );\n    return col;\n}\nvec3 RayMarchCloud(vec3 ro,vec3 rd){\n    vec3 col = vec3(0.0,0.0,0.0);  \n    float sundot = clamp(dot(rd,lightDir),0.0,1.0);\n    \n     // sky      \n    col = vec3(0.2,0.5,0.85)*1.1 - rd.y*rd.y*0.5;\n    col = mix( col, 0.85*vec3(0.7,0.75,0.85), pow( 1.0-max(rd.y,0.0), 4.0 ) );\n    // sun\n    col += 0.25*vec3(1.0,0.7,0.4)*pow( sundot,5.0 );\n    col += 0.25*vec3(1.0,0.8,0.6)*pow( sundot,64.0 );\n    col += 0.4*vec3(1.0,0.8,0.6)*pow( sundot,512.0 );\n    // clouds\n    col = Cloud(col,ro,rd,vec3(1.0,0.95,1.0),1.);\n            // .\n    col = mix( col, 1.5*vec3(0.0,0.5,1.0), pow( 1.0-max(rd.y,0.0), 16.0 ) );\n    return col;\n}\n\nvec3 Eye(vec3 p, vec4 sp){\n\n    vec3 col = vec3(1.0);\n    vec2 pp = p.xy-sp.xy;\n    float r = sqrt(dot(pp, pp));\n    float a = atan(pp.y, pp.x);\n\n    float ss = 0.5+0.5*sin(5.0*iTime);\n    float anim = 1.0 + 0.1*ss*clamp(r, 0.0, 1.0);\n    r*=anim;\n\n    if(length(p.xy-sp.xy) < .2){\n\n        col =  vec3(0.0, 0.3, 0.4);\n\n        float f = fbm(5.0*pp);\n        col = mix(col, vec3(0.2, 0.5, 0.4), f);\n\n        f = 1. - smoothstep(0.1, 0.15, r);\n        col = mix(col, vec3(0.0, 0.0, 0.0), f);\n\n        /*a += fbm(20.0*pp)*0.05;\n\n        f = smoothstep(0.15, 0.2, fbm(vec2(6.0*r, 20.0*a)) );\n        col = mix(col, vec3(1.0), f);\n\n        f = smoothstep(0.4, 0.9, fbm(vec2(10.0*r, 15.0*a)) );\n        col *= 1.0-0.5*f;\n\n        f = smoothstep(0.6, 0.8, r);\n        col *= 1.0 - 0.5*f;\n\n        f = smoothstep(0.2, 0.25, r);\n        col *= f;\n\n        f = 1.0-smoothstep(0.0, 0.5, length(pp - vec2(0.24, 0.2)) );\n        col += vec3(1.0, 0.9, 0.8)*f*0.9;\n\n        f = smoothstep(0.7, 0.8, r);\n        col = mix(col, vec3(1.0), f);*/\n\n    }\n    \n    return col;\n\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    uv -= 0.5;\n    uv /= vec2(iResolution.y / iResolution.x, 1);\n    // Time varying pixel color\n    vec3 col = vec3(0.0);\n    sphball = vec4(0.0,3.0, 15.0,3.0);\n    \n    //iMouse.xy / iResolution.xy\n    vec3 lookat = vec3((iMouse.x/iResolution.x)*10.0, (iMouse.y/iResolution.y)*30.0, 30.0);//vec3(0.0, 1.5, 0.0);\n    vec3 ro = vec3(-5, 7.0, 1.0);\n    vec4 sph = sphball;\n    float speed = 2.1;\n    ro.z -=iTime*speed;\n    lookat.z -= iTime*speed;\n    sph.z -= iTime*speed;\n    float an = (iMouse.x/iResolution.x)*10.0;\n    ro -= sph.xyz;\n    lookat -= sph.xyz;\n    ro *= RotY(an);\n    lookat *= RotY(an);\n    ro += sph.xyz;\n    lookat += sph.xyz;\n    \n    vec3 lightpos = vec3(0.0, 30., -30.);\n    lightpos.z -= iTime*speed;\n    lightpos -= sph.xyz;\n    lightpos *= RotY(an);\n    lightpos += sph.xyz;\n    //vec3 lightpos2 = vec3(0.0, 5., 16.);\n    //lightpos2.z -= iTime;\n        \n    float zoom = 1.0;    \n    vec3 f = normalize(lookat-ro),\n        r = normalize(cross(vec3(0,1,0), f)),\n        u = cross(f, r),\n        c = ro + f * zoom,\n        i = c + uv.x * r + uv.y * u,\n        rd = normalize(i-ro);\n        \n    \n        \n     vec3 t;\n     float dO, dif, dif2, dif3, difT;\n     vec3 p;\n     \n  \n     \n     t = RayMarch2(ro, rd, uv);\n     p = ro + rd * t.x;\n     \n    float alpha = 1.0;\n    vec3 n1, n2, n3, np;\n  \n   vec3 diff2 = GetLightM(p, uv, lightpos, n1, ro, rd);\n   //vec3 diff3 = GetLightM(p, uv, lightpos2, n1, ro, rd);\n    \n        \n     if(t.x > 0.0){\n         \n         \n         \n    \n     \n         \n         \n         if(t.z == 0.0){\n            // col = ph * vec3(0.0, 1.0, 0.0);\n         }\n         else if(t.z == 1.0){\n             col = diff2* vec3(1.0, 0.0, 0.0);\n         }\n         else if(t.z == 2.0){\n         \n                                    \n            // col = diff2 * vec3(1.0, 0.5, 0.5);\n            // col = 1.0-mix(diff2 * vec3(1.0, 0.5, 0.5), 1.0 - texture(iChannel0, p.xz).rgb*n1.y, 2.8);\n             //col = mix(col, texture(iChannel1, p.xz).rgb*n1.y, 0.8);\n             col = vec3(0.05, 0.09, 0.02);\n             float f = -1.0+2.0*smoothstep(-0.5, 0.5, sin(11.0*p.x)+sin(11.0*p.z))*0.5;\n             //float f =-1.0+2.0*smoothstep(-0.5, 0.5, sin(1.0*p.x)+sin(1.0*p.y)+sin(1.0*p.z))*0.1;\n             col += f*0.05;\n             col +=  diff2 * vec3(0.2, 1., 0.2);\n             \n         }\n         else if(t.z == -1.0){\n             \n             vec4 sp = eyel;\n             vec4 sph = sphball;\n             sph.y = sin(sph.y*3.1415+iTime*10.0)*5.0+5.0;\n            sph.z -= iTime*2.1;\n\n            float x = -1.0 + 2.0*abs(fract(iTime*0.5)-0.5)/0.5;\n            sph.x = x*10.5;\n            \n            vec3 q = p-sph.xyz;\n             col = Eye(q, sp)*diff2;\n             \n         }\n         else if(t.z == -2.0){\n             \n             vec4 sp = eyer;\n             vec4 sph = sphball;\n             sph.y = sin(sph.y*3.1415+iTime*10.0)*5.0+5.0;\n            sph.z -= iTime*2.1;\n\n            float x = -1.0 + 2.0*abs(fract(iTime*0.5)-0.5)/0.5;\n            sph.x = x*10.5;\n            \n            vec3 q = p-sph.xyz;\n             \n             col = Eye(q, sp)*diff2;\n             \n         }\n         else if(t.z == 3.0){\n            \n              col = diff2*vec3(0.88, 0.69, 0.65);\n              float f = smoothstep(0.5, 1., fbm(p.xy*25.0));\n              col =mix(col,  texture(iChannel0, vec2(fbm(p.xy*25.0)) ).rgb*0.2, f)  ;\n         \n         }\n         else if(t.z == 4.0){\n             vec3 colXZ = texture(iChannel2, p.xz*0.1).rgb;\n             vec3 colYZ = texture(iChannel2, p.yz*0.1).rgb;\n             vec3 colXY = texture(iChannel2, p.xy*0.1).rgb;\n             \n             \n             col = colYZ * n1.x + colXZ * n1.y + colXY*n1.z;\n             col += diff2 * vec3(1.0, 0.5, 0.5);\n         }\n         else if(t.z == 5.0){\n             col = vec3(1.0, 0.0, 0.0) * diff2;\n         \n             \n         }\n         \n       \n         \n         \n         \n     }\n     else\n     {\n         col = RayMarchCloud( ro, rd);\n         \n         \n     }\n    \n   \n    // Output to screen\n    fragColor = vec4((col),alpha);\n}\n\n\n\n", "image_inputs": [{"id": "Xsf3zn", "previewfilepath": "/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tlVyzw.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[108, 108, 126, 126, 202], [204, 204, 223, 223, 325], [327, 327, 346, 346, 448], [450, 450, 469, 469, 571], [574, 574, 628, 703, 799], [802, 802, 843, 945, 1038], [1041, 1041, 1078, 1078, 1200], [1202, 1213, 1239, 1239, 1454], [1456, 1501, 1526, 1526, 1891], [1893, 1893, 1914, 1914, 2033], [2035, 2035, 2061, 2061, 2519], [2521, 2521, 2541, 2541, 2771], [2773, 2773, 2797, 2797, 3007], [3010, 3010, 3061, 3061, 3377], [3379, 3379, 3424, 3424, 3518], [3520, 3520, 3556, 3556, 3599], [3601, 3601, 3648, 3648, 3907], [3909, 3909, 3949, 3949, 4114], [4116, 4116, 4153, 4153, 4236], [4238, 4238, 4293, 4293, 4358], [4360, 4360, 4408, 4408, 4475], [4477, 4477, 4500, 4500, 4563], [4565, 4565, 4594, 4594, 4633], [4635, 4635, 4697, 4697, 4941], [4943, 4943, 5017, 5017, 5089], [5093, 5093, 5122, 5122, 5148], [5149, 5149, 5202, 5202, 5978], [5981, 5981, 6050, 6050, 6236], [6238, 6290, 6331, 6331, 6403], [6405, 6457, 6498, 6498, 6589], [6591, 6591, 6647, 6781, 7118], [7120, 7120, 7160, 7160, 7284], [7425, 7425, 7445, 7445, 12002], [12005, 12005, 12035, 12035, 13773], [13775, 13775, 13832, 13832, 14247], [14252, 14252, 14305, 14305, 14855], [14858, 14858, 14900, 14900, 15214], [15218, 15218, 15289, 15289, 17117], [17214, 17259, 17323, 17323, 17751], [17752, 17752, 17788, 17788, 18376], [18378, 18378, 18404, 18404, 19437], [19439, 19439, 19496, 19546, 23677]]}
{"id": "tlycW1", "name": "Minecraft style fire.", "author": "Skippy69z", "description": "pixelated fire", "tags": ["pixefire", "pixelatedfire"], "likes": 5, "viewed": 193, "published": "Public API", "date": "1610915972", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float rand(vec2 coord){\n\treturn fract(sin(dot(coord, vec2(12.9898, 78.233)))* 43758.5453123);\n}\n\nfloat noise(vec2 coord){\n\tvec2 i = floor(coord);\n\tvec2 f = fract(coord);\n\n\t// 4 corners of a rectangle surrounding our point\n\tfloat a = rand(i);\n\tfloat b = rand(i + vec2(1.0, 0.0));\n\tfloat c = rand(i + vec2(0.0, 1.0));\n\tfloat d = rand(i + vec2(1.0, 1.0));\n\n\tvec2 cubic = f * f * (3.0 - 2.0 * f);\n\n\treturn mix(a, b, cubic.x) + (c - a) * cubic.y * (1.0 - cubic.x) + (d - b) * cubic.x * cubic.y;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 texture_coords = fragCoord/iResolution.xy;\n\n\tfloat f = 2.0;\n\tfloat cellSize = 50.0;\n\n\tvec2 pos = texture_coords;\n\n\tpos.x -= mod(pos.x, 1.0 / cellSize); // pixelation\n\tpos.y -= mod(pos.y, 1.0 / cellSize);\n\n\tpos *= 5.0;\n\tfloat threshold = pos.y;\n\tpos.y -= iTime*2.0;\n\n\tfloat result = 1.0 - abs(noise( vec2((pos.x*f), (pos.y*f)) ) *2.0-1.0) + noise( vec2((pos.x*f), (pos.y*f)) * 2.5 ) * 0.8;\n\tif(result < threshold){result = 0.0;}\n\n    fragColor = vec4(result, result - 0.5, 0.0, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tlycW1.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 23, 23, 95], [97, 97, 121, 121, 491], [493, 493, 549, 599, 1093]]}
{"id": "tlyczc", "name": "Berry dancing", "author": "fguinier", "description": "A mash up of two other shader to get a dancing berry, because why not.", "tags": ["berry"], "likes": 0, "viewed": 30, "published": "Public", "date": "1612039698", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//mix of https://www.shadertoy.com/view/ldcGWH\n//and https://www.shadertoy.com/view/Xds3Rr\n\n//from https://www.iquilezles.org/www/articles/distfunctions/distfunctions.htm\nfloat sdRoundCone( vec3 p, float r1, float r2, float h )\n{\n  vec2 q = vec2( length(p.xz), p.y );\n    \n  float b = (r1-r2)/h;\n  float a = sqrt(1.0-b*b);\n  float k = dot(q,vec2(-b,a));\n    \n  if( k < 0.0 ) return length(q) - r1;\n  if( k > a*h ) return length(q-vec2(0.0,h)) - r2;\n        \n  return dot(q, vec2(a,b) ) - r1;\n}\n\nfloat sdBerry( vec3 p, float s )\n{\n  vec3 centerCone = p + s*vec3(0,0.03,0);\n  float dRoundCone = sdRoundCone( centerCone, s*0.01, s*0.02, s*0.03 );\n  \n  vec3 centerSmallSphere = p + vec3(0.3,0.02,0.1);\n  float invS = 1.0/s;\n  invS = 1.0;//TOFO?\n  float dSpheres = dot(abs(sin(invS*centerSmallSphere*350.0)), vec3(0.001,0.001,0.004));\n  return dRoundCone - dSpheres;\n}\n\n////////\n////////\nfloat berryScale;\nfloat mapExterior(in vec3 p)\n{\n    float d = sdBerry(p, berryScale);\n\treturn d;\n}\n\nvec3 grad(in vec3 p)\n{\n    vec2 off = vec2(0.0001, 0.0);\n    vec3 g = vec3(mapExterior(p + off.xyy) - mapExterior(p - off.xyy),\n                  mapExterior(p + off.yxy) - mapExterior(p - off.yxy),\n                  mapExterior(p + off.yyx) - mapExterior(p - off.yyx));\n    return normalize(g);\n}\n\nfloat trace(in vec3 p, in vec3 d, out vec3 closestPoint)\n{\n    float closest = 99.0;\n    bool hit = false;\n    for (int i = 0; i < 250; ++i)\n    {\n        float dist = mapExterior(p);\n        if (dist < closest)\n        {\n        \tclosest = dist;\n            closestPoint = p;\n        }\n        \n        if(dist < 0.0)\n        {\n            hit = true;\n            break;\n        }\n        p += d * max(dist * 0.5, 0.00001);\n    }\n    return closest;\n}\n\n// (too much) tweakable parameters.\n// falloff control\nconst float density = 8.;\nconst float ss_pow = 3.; \nconst float ss_scatter = 0.4;\nconst float ss_offset = .5;\n\n// color controls\nconst float ss_intensity = 0.5;\nconst float ss_mix = 0.5;\nconst vec4 ss_color = vec4(.75, .05, .12, 0.0);\n\n// determines how deep from surface to start scattering tracing, not something to tweak really.\nconst float surfaceThickness = 0.008;\n\n// Fresnel\nvec4 rimCol = vec4(1.0, 0.8, 0.8, 1.0);\nfloat rimPow = 3.0;\nfloat rimAmount = 2.;\nfloat F = 2.2;\n\nfloat rand(vec2 co)\n{\n    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\n/**\n* Gets thickness for subsurface scattering calculation. \n* I first offset the ray hit position a bit along opposite of the surface normal \n* to get a starting position inside the volume.\n* From there I step towards the light and calculate distance travelled inside the negative volume of\n* the distance function.\n* \n* Outer loop is for approximating scattering of the light that travels in the volume,\n* I just offset the light direction by some scatter value for each sample.\n*/\nfloat ssThickness(in vec3 raypos, in vec3 lightdir, in vec3 g, in vec3 rd)\n{\n    vec3 startFrom = raypos + (-g * surfaceThickness);\n    vec3 ro = raypos;\n\t\n    float len = 0.0;\n    const float samples = 12.;\n    const float sqs = sqrt(samples);\n    \n    for (float s = -samples / 2.; s < samples / 2.; s+= 1.0)\n    {\n        vec3 rp = startFrom;\n        vec3 ld = lightdir;\n        \n        ld.x += mod(abs(s), sqs) * ss_scatter * sign(s);\n        ld.y += (s / sqs) * ss_scatter;\n        \n        ld.x += rand(rp.xy * s) * ss_scatter;\n        ld.y += rand(rp.yx * s) * ss_scatter;\n        ld.z += rand(rp.zx * s) * ss_scatter;\n\t\t\n        ld = normalize(ld);\n        vec3 dir = ld;\n\t\t\n        for (int i = 0; i < 50; ++i)\n        {\n            float distExterior = mapExterior(rp);\n            if(distExterior < 0.0) distExterior  = min(distExterior, -0.0001);\n            if(distExterior >= 0.0) break;\n\n            dir = normalize(ld);\n            rp += abs(distExterior * 0.5) * dir;  \n        }\n        len += length(ro - rp);\n    }\n    \n    return len / samples;\n}\n\n//from https://www.shadertoy.com/view/Xds3Rr\nvec3 getColorFromSound(in vec2 fragCoord)\n{\n    // create pixel coordinates\n    vec2 uv = fragCoord.xy / iResolution.xy;\n\n    // the sound texture is 512x2\n    int tx = int(uv.x*512.0);\n    \n\t// first row is frequency data (48Khz/4 in 512 texels, meaning 23 Hz per texel)\n\tfloat fft  = texelFetch( iChannel0, ivec2(tx,0), 0 ).x; \n\n    // second row is the sound wave, one texel is one mono sample\n    float wave = texelFetch( iChannel0, ivec2(tx,1), 0 ).x;\n\t\n\t// convert frequency to colors\n\tvec3 col = vec3( fft, 4.0*fft*(1.0-fft), 1.0-fft ) * fft;\n\n    // add wave form on top\t\n\tcol += 1.0 -  smoothstep( 0.0, 0.15, abs(wave - uv.y) );\n\t\n\t// output final color\n\treturn col;\n}\n\nfloat getBerryScaleFromSound()\n{\n    int numFetch = 25;\n    \n    // the sound texture is 512 pixel wide\n    int stepBetweenFetch = 512/numFetch;\n    float sumfftBass = 0.0;\n    for(int i = 0; i <512; i+=stepBetweenFetch)\n    {\n        float fft = texelFetch( iChannel0, ivec2(i,0), 0 ).x; \n        sumfftBass += fft*fft;\n    }\n\n\t// output final color\n\treturn 3.0f * sumfftBass/float(numFetch);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    uv -= vec2(0.5);\n    uv.y /= iResolution.x / iResolution.y;\n    \n    vec2 m = (iMouse.xy / iResolution.xy) - vec2(0.5);\n    \n    berryScale = (m.x);\n    if(iMouse.z <= 0.0)\n    {\n    \tberryScale = sin(iTime * 0.5) * 0.1 + 0.5;\n        berryScale += getBerryScaleFromSound();\n    }\n\n    fragColor = vec4(0.0);\n    vec3 rd = normalize(vec3(uv, 1.0));\n    vec3 rp = vec3(0.0, -0.01, -.3);\n\n    // closest point is used for antialising outline of object\n    vec3 closestPoint = vec3(0.0);\n    float hit = trace(rp, rd, closestPoint);\n    vec4 color = vec4(.0);\n    rp = closestPoint;\n\n    vec3 ld = normalize( vec3(14.0, 1.0, 20.0) - closestPoint);\n    vec3 g = grad(closestPoint);\n    float d = dot(g, ld);\n    d = clamp(d, 0.0, 1.0);\n\n    //fresnel\n    vec3 r = reflect(-ld, g);\n    float rimd = 1.0 - dot(r, -rd);\n    rimd = clamp(rimd, 0.0, 1.0);\n    rimd = pow(rimd, rimPow);\n\n    float frn = rimd + F * (1.0 - rimd);\n    color += frn * rimCol * rimAmount * d;\n\n    // subsurface        \n    float t = ssThickness(rp, ld, g, rd);\n    t = exp(ss_offset -t * density);\n    t = pow(t, ss_pow);\n \n    vec4 sscol = t * ss_color * ss_intensity;\n    sscol = mix(sscol, ss_color, 1.0 - ss_mix);\n    color += sscol;\n\t\n    fragColor = vec4(getColorFromSound(fragCoord), 1.0);\n    // color + AA\n    fragColor = 0.75*mix(color, fragColor, mix(0.0, 1.0, clamp(hit / surfaceThickness * 16.0, 0.0, 1.0)));\n    \n    // vignette\n    fragColor *= smoothstep(0.55, 0.48, abs(uv.x));\n    fragColor *= smoothstep(0.31, 0.27, abs(uv.y));\n}", "image_inputs": [{"id": "4dfGzn", "previewfilepath": "/media/ap/ec8a6ea755d34600547a5353f21f0a453f9f55ff95514383b2d80b8d71283eda.mp3", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/ec8a6ea755d34600547a5353f21f0a453f9f55ff95514383b2d80b8d71283eda.mp3", "ctype": "music"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tlyczc.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[92, 171, 229, 229, 493], [495, 495, 529, 529, 863], [865, 901, 931, 931, 982], [984, 984, 1006, 1006, 1281], [1283, 1283, 1341, 1341, 1735], [2163, 2272, 2293, 2293, 2365], [2367, 2851, 2927, 2927, 3919], [3921, 3966, 4009, 4041, 4643], [4645, 4645, 4677, 4677, 5040], [5042, 5042, 5099, 5099, 6664]]}
{"id": "tsKXzW", "name": "mandelbrot glsl", "author": "Angramme", "description": "fff", "tags": ["mandelbrot"], "likes": 1, "viewed": 188, "published": "Public API", "date": "1610735770", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define IT 800. //iterations\n\nfloat log10(float x){\n    //log10(x) = log(x) / log(10) = (1 / log(10)) * log(x)\n    const float d = 1. / log(10.);\n    return d * log(x);\n}\n\nvec3 hsv2rgb(vec3 c)\n{\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.x;\n    \n    float zoom = pow(iTime*.1, 5.);\n    \n    uv *= 4.;\n    uv /= 1. + zoom;\n    uv -= vec2(.7394, -.24215);\n    \n    float cr = uv.x;\n    float ci = uv.y;\n    \n    \n    /*\n    uv *= 4.5;\n    uv += vec2(0., .7);\n    \n    float cr = -uv.y;\n    float ci = uv.x;\n    */\n    \n    vec3 color = vec3(0);\n    \n\tfloat zr = 0.;\n    float zi = 0.;\n    \n    //last escaped complex module value\n    float zn_abs = 0.;\n    \n    float n = 0.;\n    while(n < IT){\n        float fr = zr*zr - zi*zi + cr;\n        float fi = 2.*zr*zi + ci;\n        \n        zr = fr;\n        zi = fi;\n        \n        if(abs(fr)+abs(fi) > 500.){\n            zn_abs = sqrt(fr*fr + fi*fi);\n            break;\n        }\n        \n        n++;\n    }\n    \n    if(n == IT){\n    \t//color += .5;\n    }else{\n    \t//color += mix(vec3(0,0,0), vec3(0,2,2), n / IT *mix(8., 1., iTime*.02));\n        //color += vec3(0, 1, 1) * log10(n) * .4;\n        //color += vec3(0, 1, 1) * pow(n/IT, .5f);\n        \n        //color += 1.;\n   \n        //color += n/IT*20.;\n        \n        //smooth n\n        float ns = n + 1. - log(log(zn_abs))/log(2.);\n        //color += fract(ns*10./IT)*3.;\n        color += hsv2rgb(vec3(fract(ns*10./IT)+3.7 +iTime*.03, .7, 1.));\n    }\n   \t\n    fragColor = vec4(color,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tsKXzW.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[30, 30, 51, 110, 170], [172, 172, 194, 194, 363], [365, 365, 422, 422, 1732]]}
{"id": "tsKyD1", "name": "The Others", "author": "KaDokta", "description": "Maybe don't stay for too long.\n\n--\n\nKaDokta.com", "tags": ["2d", "tunnel", "eye", "orb", "floating"], "likes": 4, "viewed": 213, "published": "Public API", "date": "1609539793", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI 3.14159265359\n#define TAU 2.0*PI\n#define ANIMATE true\n#define MOUSE_LOOK false\n#define TIME_OFFSET 60.0\n\n#define COL_OUTER_EYE vec3(0.5, 0.5, 0.7)\n#define COL_BACKGROUND vec3(0.04, 0.06, 0.1)\n#define COL_PUPIL_OUTER_START vec3(0.1, 0.3, 0.9)\n#define COL_PUPIL_OUTER_END vec3(0.8, 0.0, 0.0)\n#define COL_PUPIL_INNER vec3(1.0)\n#define COL_EYEBALL_COLOR vec3(0.1, 0.1, 0.1)\n#define COL_EYEBALL_TEXTURE_COLOR vec3(0.3, 0.1, 0.5)\n#define COL_ORB_BACKGROUND vec3(0.5, 0.1, 0.9)\n#define COL_ORB_OUTLINE vec3(0.8, 0.0, 0.0)\n#define COL_CANTHUS vec3(0.3, 0.0, 0.0)\n\n#define TIMER_PHASE_LOOK 30.0\n#define TIMER_PHASE_SPLIT 50.0\n#define TIMER_PHASE_FADEOUT 56.0\n#define TIMER_PHASE_RESET 60.0\n#define TIMER_PHASE_ALL 64.0\n\n\nstruct phaseInfo\n{\n    int id;\n    float time;\n};\n\n\nstruct orbInfo\n{\n    vec2 position;\n    float size;\n    float timedSeed;\n    float fixedSeed;\n};\n\n\nfloat ang(in vec2 from, in vec2 to)\n{\n    return atan(from.y - to.y, from.x - to.x);\n}\n\n\nfloat calculatePixelValue(in float currentDistance, in float maxWidth)\n{\n    return max(0.0, 1.0 - pow(abs(currentDistance - 1.0), 2.5) / (maxWidth));\n}\n\n\nfloat calculatePixelValueFilled(in float currentDistance, in float maxWidth)\n{\n    return max(0.0, 1.0 - pow(currentDistance - 1.0, 5.0) / (maxWidth));\n}\n\n\nfloat getTimedMix(in float phaseTimer, in float phaseTimeStart, in float duration)\n{\n    phaseTimer -= phaseTimeStart;\n    return min(phaseTimer/duration, 1.0);\n}\n\n\nfloat interpolateLinear(in float val1, in float val2, in float percentage)\n{\n    return mix(val1, val2, percentage);\n}\n\n\nfloat interpolateSmooth(in float val1, in float val2, in float percentage)\n{\n    return mix(val1, val2, -cos(PI * percentage) * 0.5 + 0.5);\n}\n\n\nvoid getNoiseValues(in float seed, in float offset, in float upperLimit, out float val1, out float val2, out float percentage)\n{\n    vec2 texSize = iChannelResolution[0].xy;\n    float maxSize = texSize.x * texSize.y - 1.0;\n    \n    offset = mod(offset, maxSize);\n    upperLimit = (upperLimit <= 0.0 ? maxSize : min(upperLimit + offset, maxSize));\n    \n    seed = offset + mod(seed, upperLimit - offset);\n    \n    percentage = fract(seed);\n    float lowerSeed = floor(seed);\n    float upperSeed = ceil(seed);\n    \n    if(upperSeed > upperLimit){ // Make clean repetition\n        upperSeed = offset;\n    }\n    \n    if(seed < ceil(offset)){ // Adjust for fractions (lower)\n        float maxFraction = ceil(offset) - offset;\n        percentage -= fract(offset);\n        percentage = percentage/maxFraction;\n    }\n    \n    if(seed > floor(upperLimit)){ // Adjust for fractions (upper)\n        float maxFraction = upperLimit - floor(upperLimit);\n        percentage = percentage/maxFraction;\n    }\n    \n    \n    float xValue1 = mod(lowerSeed, texSize.x);\n    float yValue1 = mod(floor(lowerSeed/texSize.y), texSize.y);\n    \n    float xValue2 = mod(upperSeed, texSize.x);\n    float yValue2 = mod(floor(upperSeed/texSize.y), texSize.y);\n    \n    vec4 tex1 = texelFetch(iChannel0, ivec2(xValue1, yValue1), 0);\n    vec4 tex2 = texelFetch(iChannel0, ivec2(xValue2, yValue2), 0);\n    \n    val1 = tex1.x;\n    val2 = tex2.x;\n}\n\n\nfloat getRandSmooth(in float seed, in float offset, in float repeatAt)\n{\n    float val1;\n    float val2;\n    float percentage;\n    \n    getNoiseValues(seed, offset, repeatAt, val1, val2, percentage);\n    return interpolateSmooth(val1, val2, percentage);\n}\n\n\nfloat getRandSmooth(in float seed)\n{\n\treturn getRandSmooth(seed, 0.0, 0.0);\n}\n\n\nfloat getRand(in float seed, in float offset, in float repeatAt)\n{\n    float val1;\n    float val2;\n    float percentage;\n    \n    getNoiseValues(seed, offset, repeatAt, val1, val2, percentage);\n    return interpolateLinear(val1, val2, percentage);\n}\n\n\nfloat getRand(in float seed, in float offset)\n{\n    return getRand(seed, offset, 0.0);\n}\n\n\nfloat getRand(in float seed)\n{\n    return getRand(seed, 0.0, 0.0);\n}\n\n\nfloat getFixedValue(in float duration)\n{\n    return iTime - mod(iTime, duration);\n}\n\n\nmat2 rotate(in float angle)\n{\n    return mat2(cos(angle), -sin(angle), sin(angle), cos(angle));\n}\n\n\nvec2 rotateVec(in vec2 startVec, in vec2 offset, in float angle)\n{\n    mat2 rotation = rotate(angle);\n    startVec = startVec - offset;\n    startVec *= rotation;\n    return startVec + offset;\n}\n\n\nfloat normalizedCos(in float value)\n{\n    return 0.5*(1.0-cos(value/PI*20.0));\n}\n\n\nfloat calculateParabola(in vec2 startPoint, in vec2 centerPoint, in float parabolaX, out float a, out float height)\n{\n    // General parabola formula: y = a*(x - x_center)² + y_center\n    a = (startPoint.y - centerPoint.y) / pow(startPoint.x - centerPoint.x, 2.0);\n    float parabolaY = a*pow(parabolaX - centerPoint.x, 2.0) + centerPoint.y;\n    height = parabolaY - startPoint.y;\n    return parabolaY;\n}\n\n\nvoid drawBackLines(inout vec3 col, in vec2 fragCoord)\n{\n    vec2 center = iResolution.xy*0.5;\n    float angle = (ang(fragCoord, center) + PI) * 180.0/PI * 0.8 + iTime;\n    angle = mod(angle, 360.0);\n    float angleDisc = floor(angle);\n    \n    float timePerAngle = getRand(angleDisc, 0.0) * 2.0 + 5.0;\n    \n    float val = getRand(angleDisc, ANIMATE ? ceil(iTime/timePerAngle) * 180.0 : 0.0);\n    \n    if(val > 0.96){\n        float halfTime = timePerAngle * 0.5;\n        float timer = mod(iTime, timePerAngle);\n        timer = (timer > halfTime ? halfTime - abs(halfTime - timer) : timer) / halfTime;\n        \n        col -= col * smoothstep(round(angle), ceil(angle)-0.5, angle) * timer * 0.7;\n    }\n}\n\n\nvoid drawForeLines(inout vec3 col, in vec2 fragCoord, in float seed, in phaseInfo phase)\n{\n    if(!ANIMATE){\n        return;\n    }\n\n    vec2 center = iResolution.xy*0.5;\n    fragCoord = rotateVec(fragCoord, center, iTime * 0.02); \n    \n    float angle = (ang(fragCoord, center) + PI) * 180.0/(2.0*PI);\n    float angleDisc = floor(angle);\n       \n    float maxLength = (iResolution.x + iResolution.y) * 1.0;\n    \n    float timePerAngle = getRand(angleDisc, seed + 128.0) * 10.0 + 5.0;\n    float speedPerAngle = maxLength/timePerAngle;\n    \n    float timeStart = iTime + 0.0;\n    \n    float val = getRand(angleDisc, seed + (ANIMATE ? ceil((timeStart * speedPerAngle)/maxLength) * 10.0 : 0.0));\n    \n    if(val < 0.05){\n        float currentLength = mod(timeStart * speedPerAngle, maxLength);\n        float dist = length(fragCoord - center);\n        \n        float endMin = dist;\n        float endMax = dist + 3.0;\n        \n        float startMin = currentLength - maxLength*0.5;\n        float startMax = startMin + 3.0;\n        \n        float mixValue = 0.0;\n        \n        if(phase.id == 1){\n            mixValue = getTimedMix(phase.time, TIMER_PHASE_LOOK, 2.0);\n        }\n        else if(phase.id > 1 && phase.id < 4){\n            mixValue = 1.0;\n        }\n        \n        col += smoothstep(round(angle), ceil(angle)-0.5, angle) \n               * smoothstep(startMin, startMax, dist)\n               * smoothstep(endMin, endMax, currentLength)\n               * (1.0 - (timePerAngle / 15.0))\n               * mix(COL_PUPIL_OUTER_START, COL_PUPIL_OUTER_END, mixValue);\n    }\n}\n\n\nvoid drawSmoothedCircle(in vec2 position, in float radius, in float lineWidth, in vec3 lineColor, in vec3 backgroundColor, inout vec3 currentColor, in vec2 fragCoord)\n{\n    float centerValue = length(fragCoord.xy - position);\n    \n\tcurrentColor += vec3(smoothstep(radius + lineWidth * 0.25, radius , centerValue)) * (lineColor - currentColor)\n         + vec3(smoothstep(radius, radius - lineWidth * 0.25, centerValue)) * (backgroundColor - currentColor);\n}\n\n\nvoid drawCircle(in vec2 position, in float radius, in float lineWidth, in vec3 lineColor, inout vec3 currentColor, in vec2 fragCoord)\n{\n    float pixelFract = calculatePixelValue(length(fragCoord - position) - radius, lineWidth);\n    currentColor += vec3(pixelFract) * (lineColor - currentColor);\n}\n\n\nvoid drawFullCircle(in vec2 position, in float radius, in vec3 color, inout vec3 currentColor, in vec2 fragCoord)\n{\n    float pixelFract = calculatePixelValueFilled(length(fragCoord - position) - radius, radius);\n    currentColor += vec3(pixelFract) * (color - currentColor);\n}\n\n\nvoid drawFilledSmoothedOval(in vec2 center, in float width, in float height, in vec3 color, inout vec3 currentColor, in vec2 fragCoord)\n{\n    vec2 size = vec2(width, height);\n    \n    float curValue = length((fragCoord.xy - center)/size);\n    float minValue = 1.0;\n    float maxValue = 1.0 - 0.04;\n    \n    currentColor += vec3(smoothstep(maxValue, minValue, curValue)) * (color - currentColor);\n}\n\n\nfloat calcFrayHeight(in float time, in float seed, in float angle, in float divs, in float amount)\n{\n    return getRandSmooth(time + angle * divs, seed, TAU * divs) * amount;\n}\n\n\nfloat calcRandHeightMultiplier(in float time, in float seed)\n{\n    return 1.0+(getRand(1.0 + (ANIMATE ? time : 0.0) * 1.0, seed) - 0.5) * 2.0;\n}\n\n\nfloat calcRandWobble(in float seed, in float angle, in float direction, in float divs, in float offset, in float amount)\n{\n    return (0.5-getRandSmooth(angle * divs + (ANIMATE ? iTime * -direction : 0.0), seed + offset, TAU * divs)) * amount;\n}\n\n\nvec3 drawFrayedCircle(in float time, in float seed, in float direction, in vec2 position, in phaseInfo phase, in float radius, in float lineWidth, in vec3 currentColor, in vec2 fragCoord)\n{  \n    if(!ANIMATE){\n        time = 0.0;\n    }\n    \n    float mixValue = 0.0;\n    \n    if(phase.id == 1){\n        mixValue = getTimedMix(phase.time, TIMER_PHASE_LOOK, 2.0);\n    }\n    else if(phase.id > 1 && phase.id < 4){\n        mixValue = 1.0;\n    }\n    \n    float angle = atan(fragCoord.y - position.y, fragCoord.x - position.x) + PI;    \n    \n    float divs = 50.0 * radius/iResolution.x + 5.0 + 10.0 * mixValue;\n    \n    radius = radius + calcFrayHeight(time, seed, angle, divs, radius * 0.1)\n        * calcRandHeightMultiplier(time, seed)\n        + calcRandWobble(seed, angle, direction, 3.0, 0.0, radius * 0.1);\n    \n    radius += calcFrayHeight(2.0*time, seed, angle, divs, radius * 0.1)\n        * calcRandHeightMultiplier(2.0*time, seed)\n        - calcRandWobble(seed, angle, direction, 4.0, TAU*10.0, radius * 0.1);;\n    \n    float valueInner = length(vec2(1.0, 2.0) * (fragCoord - position)) - radius;\n    float valueOuter = length(fragCoord - position) - radius;\n    \n    float offset = 0.2 + 0.5 * abs(sin(time * 0.2));\n    vec3 colorTexture = COL_ORB_BACKGROUND - vec3(0.0, 0.0, mod(valueInner - iTime * 50.0, iResolution.x/12.0)/radius);\n    \n    vec3 lineColor = mix(vec3(0.0), COL_ORB_OUTLINE, mixValue) * vec3(offset);\n    \n    return vec3(smoothstep(radius + 1.0 + lineWidth * 0.25, radius , valueOuter)) * (lineColor - currentColor)\n           + vec3(smoothstep(radius, radius - lineWidth * 0.25 * offset * 3.0, valueOuter)) \n           * (0.4 * colorTexture * valueInner/100.0 - (lineColor));\n}\n\n\nvoid drawParabola(in float parabolaY, in vec2 centerPoint, in float width,  in float lineWidth, in vec3 lineColor, inout vec3 currentColor, in vec2 fragCoord, out float height)\n{   \n    if(abs(fragCoord.x - centerPoint.x) <= width){\n        float pixelFract = calculatePixelValue(fragCoord.y - parabolaY, 2.0 * lineWidth);\n        currentColor = clamp(vec3(0.0), currentColor, vec3(1.0));\n        currentColor += vec3(pixelFract) * (lineColor - currentColor);\n    }\n}\n\n\nvoid drawBall(in float seed, in vec2 center, in vec2 pupilPosition, in float width, inout vec3 currentColor, in vec2  fragCoord)\n{\n    vec3 backgroundColor = COL_EYEBALL_COLOR;\n    \n    currentColor += backgroundColor - currentColor;\n    \n    vec2 toPosition = normalize(pupilPosition - center) * length(pupilPosition - center);\n    \n    float angle = ang(fragCoord, center - pupilPosition) + PI;\n    float draw = length(fragCoord - pupilPosition);\n    \n    float value = getRand(angle * iResolution.x/100.0 + getRand(draw / length(iResolution.xy) * 100.0, seed) \n                        *  iResolution.x/100.0 + iTime, seed, 2.0 * PI * 12.0) - 0.4;\n\n    currentColor += step(width*0.45, draw)\n                    * smoothstep(value, value + 8.0, (length(pupilPosition - fragCoord)+1.0)/width*2.0) * 6.0\n                    * (COL_EYEBALL_COLOR);\n\n    currentColor += smoothstep(width*0.55,width*0.6, width - draw)\n                    * (COL_EYEBALL_TEXTURE_COLOR);\n}\n\n\nvoid drawCanthus(in vec2 position, in float width, inout vec3 currentColor, in vec2 fragCoord)\n{\n    drawFilledSmoothedOval(position, width * 1.38, width * 1.4 * 0.55, COL_CANTHUS, currentColor, fragCoord);\n}\n\n\nvec2 addSaccade(in float seed, in float saccadeTimeMultiplier, in float movementMultiplier)\n{\n    if(!ANIMATE){\n    \treturn vec2(0.0);\n    }\n    \n    float saccadeInterval = max((getRand(getFixedValue(2.0), seed)+0.3)*saccadeTimeMultiplier, 0.6);  \n    float saccadeTimeFrame = getFixedValue(saccadeInterval);\n    float randomValue = getRand(saccadeTimeFrame / saccadeInterval, seed) - 0.5;\n    return movementMultiplier * randomValue * normalize(vec2(cos(randomValue), sin(randomValue)));\n}\n\n\nvec2 randomPosition(in float seed)\n{\n    if(!ANIMATE){\n        return vec2(0.0);\n    }\n    \n    float offsetInterval = max((getRand(getFixedValue(32.0), seed)+0.5)*5.0, 2.0);\n    float timeFrame = getFixedValue(offsetInterval);\n    float randomValue = getRand(timeFrame / offsetInterval, seed);\n    float randomValue2 = getRand(timeFrame / offsetInterval, 32.0 + seed);\n    return vec2(randomValue * iResolution.x, randomValue2 * iResolution.y);\n}\n\n\nfloat addPupilSize(in float seed)\n{\n    if(!ANIMATE){\n        return 0.0;\n    }\n    \n    float changeInterval = max(getRand(getFixedValue(2.0), seed), 0.6) * 15.0;\n    float timeFrame = getFixedValue(changeInterval);\n    float randomValue = getRand(timeFrame / changeInterval, 16.0 + seed) - 0.5;\n    return randomValue;\n}\n\n\nvec2 calculatePupilPosition(in float seed, in vec2 center, in float width, in vec2 fragCoord)\n{\n    vec2 position = center;\n    position += addSaccade(seed, 2.0, 5.0);\n    vec2 toMouse = vec2(0.0);\n    float maxDistance = width * 0.5;\n    float toMouseAngle = 0.0;\n    \n    if(MOUSE_LOOK){\n        toMouse = position - iMouse.xy;\n        toMouseAngle = -atan(position.y - iMouse.y, position.x - iMouse.x);\n    }\n    else{\n        vec2 offset =  randomPosition(seed) * 0.5;\n        vec2 fixedPos = iResolution.xy * 0.5;\n        toMouse = (fixedPos - offset) * 0.15;\n        toMouseAngle = -ang(fixedPos * 0.5, offset);\n    }\n\n    float squishValue = 1.0-min(1.0, length(toMouse)/maxDistance)*0.15;\n    position -= fragCoord;\n    position +=  rotate(toMouseAngle) * vec2(-min(length(toMouse), maxDistance), 0.0);\n    position *=  rotate(toMouseAngle);\n    position.x *= 1.0/squishValue;\n    position += fragCoord;\n    return position;\n}\n\n\nvoid drawPupil(in float seed, in int phase, in float phaseTimer, in vec2 position, in vec2 offset, in float width, inout vec3 currentColor, in vec2 fragCoord)\n{   \n\n    float mixValue = 0.0;\n\n    if(phase == 1){\n        mixValue = getTimedMix(phaseTimer, TIMER_PHASE_LOOK, 2.0);\n    }\n    else if(phase > 1 && phase < 4){\n        mixValue = 1.0;\n    }\n\n    vec3 pupilColor = mix(COL_PUPIL_OUTER_START, COL_PUPIL_OUTER_END, mixValue);\n    float pupilOuterSize = width * 0.5;\n    float pupilInnerSize = width * 0.12 + addPupilSize(seed) * 5.0;\n    float pupilCenterSize = (pupilOuterSize + pupilInnerSize) * 0.5;\n    \n    drawSmoothedCircle(position, pupilCenterSize, width - pupilInnerSize, pupilColor, COL_PUPIL_INNER, currentColor, fragCoord);\n    drawFullCircle(position, pupilInnerSize - 2.0, vec3(0.0), currentColor, fragCoord);\n    drawCircle(position, pupilInnerSize, 15.0, pupilColor, currentColor, fragCoord);\n}\n\n\nvoid drawInnerEye(in phaseInfo phase, in float seed, in float width, in float height, in vec2 position, in vec2 offset, inout vec3 currentColor, in vec2 fragCoord)\n{\n    if(abs(fragCoord.y - position.y) > abs(height) ||\n       abs(fragCoord.x - position.x) > abs(width)) {\n    \treturn;\n    }\n    \n    vec2 pupilPosition = position;\n    \n    if(phase.id == 0 || phase.id == 4){\n        pupilPosition = calculatePupilPosition(seed, position, width*0.85, fragCoord);\n    }\n    else{\n        pupilPosition += addSaccade(seed, 2.0, 7.0);\n    }\n    \n    drawBall(seed, position, pupilPosition, width, currentColor, fragCoord);\n    drawCanthus(position, width*0.68, currentColor, fragCoord);\n    drawPupil(seed, phase.id, phase.time, pupilPosition, offset, width*0.85, currentColor, fragCoord);\n}\n\n\nvoid drawOrbBackground(in orbInfo orb, in phaseInfo phase, inout vec3 col, in vec2 fragCoord)\n{   \n    col += drawFrayedCircle(orb.timedSeed, orb.fixedSeed, 1.0, orb.position, phase, orb.size*0.65, 10.0, col, fragCoord);;\n}\n\n\nfloat calculateOpenness(in float seed)\n{\n    float blinkInterval = 1.5 + 1.5 * getRand(seed);\n    float blinkDuration = 0.1;\n    float maxOpeness = 1.0;\n    float eyeOpen = maxOpeness;\n    \n    float blinkTimer = mod(iTime, blinkInterval);\n    \n    if(blinkTimer <= blinkDuration && ANIMATE){\n    \teyeOpen = maxOpeness-normalizedCos(blinkTimer * maxOpeness/blinkDuration);\n    }\n    \n    return eyeOpen;\n}\n\n\nvoid drawEye(in orbInfo orb, in phaseInfo phase, inout vec3 currentColor, in vec2 fragCoord)\n{\n    float a;\n    float width = orb.size;\n    float height = width * 0.5;\n    \n    float centerHeight = height * calculateOpenness(orb.fixedSeed);\n    \n    vec2 startPos = vec2(orb.position.x - width, orb.position.y);\n    vec2 centerPointUp = startPos + vec2(orb.size, centerHeight);\n    vec2 centerPointDown = startPos + vec2(width, -centerHeight);\n    float parabolaYup = calculateParabola(startPos, centerPointUp, fragCoord.x, a, height);\n    float parabolaYDown = calculateParabola(startPos, centerPointDown, fragCoord.x, a, height);\n    \n    float upperLineWidth = 5.0;\n    float lowerLineWidth = 3.0;\n    \n    vec2 offset = 0.1 * (orb.position - iMouse.xy);\n    \n    drawInnerEye(phase, orb.fixedSeed, width, height, orb.position, offset, currentColor, fragCoord);\n    drawParabola(parabolaYup, centerPointUp, width + 2.0, upperLineWidth, COL_OUTER_EYE, currentColor, fragCoord, height);\n    drawParabola(parabolaYDown, centerPointDown, width, lowerLineWidth, COL_OUTER_EYE, currentColor, fragCoord, height);\n}\n\n\nvoid drawOrb(in orbInfo orb, in phaseInfo phase, inout vec3 currentColor, in vec2 fragCoord)\n{    \n    drawOrbBackground(orb, phase, currentColor, fragCoord);  \n    drawEye(orb, phase, currentColor, fragCoord);\n}\n\n\nvoid splitImage(inout vec3 col, inout vec2 fragCoord, in float phaseTimer)\n{\n    float divs = 16.0;\n    float pixels = iResolution.x/divs;\n    float percentage = max((phaseTimer-TIMER_PHASE_SPLIT)/(TIMER_PHASE_FADEOUT-TIMER_PHASE_SPLIT), 0.0);\n    \n    float currentLength = length(fragCoord - iResolution.xy*0.5);\n    float currentLengthDisc = currentLength/pixels - fract(currentLength/pixels);\n        \n    if(currentLengthDisc <= (percentage * length(iResolution.xy*0.5)/pixels)){\n        float number = (fragCoord.y/pixels - fract(fragCoord.y/pixels));\n        float direction = mod(number, 2.0) >= 1.0 ? -1.0 : 1.0;\n     \n        fragCoord.x += (iResolution.x/divs) * direction;\n        fragCoord.y -= (iResolution.y/divs) * direction;\n    }\n}\n\n\nvoid spliceImage(inout vec2 fragCoord)\n{\n    vec2 pos1 = vec2(0.8, 1.5);\n    vec2 pos2 = vec2(0.8, 0.5);\n\n    if((iResolution.y-fragCoord.y * pos1.y)/(fragCoord.x * pos1.x) * iResolution.x/iResolution.y > 1.0){\n        fragCoord = fragCoord * mat2(0.5, 0.0, 0.0, 0.5);\n    }\n\n    if((fragCoord.y * pos2.y)/(fragCoord.x * pos2.x) * iResolution.x/iResolution.y > 1.0){\n        fragCoord = fragCoord * mat2(1.5, 0.0, 0.0, 1.5);\n    }\n}\n\n\nvoid drawRectVignette(inout vec3 currentColor, in vec2 fragCoord)\n{\n    float angle = ang(fragCoord, iResolution.xy * 0.5);\n    float maxDistance = 50.0 + 100.0 * (0.5 - getRand(angle * 4.0, 0.0, 2.0 * PI * 4.0)) * sin(angle + iTime * 0.5);\n    vec3 startColor = currentColor;\n\n    float val = min(min(iResolution.x - fragCoord.x, iResolution.y - fragCoord.y), min(fragCoord.x, fragCoord.y));\n    val = min(min(iResolution.x - fragCoord.x, iResolution.y - fragCoord.y), min(fragCoord.x, fragCoord.y));\n\n    currentColor += vec3(smoothstep(0.0, 2.0, (maxDistance-val)/(maxDistance)) * 0.2) * 1.1;\n}\n\n\nvec2 calculateEyePos(in float startAngle, in float offset, in vec2 fragCoord)\n{\n    vec2 center = iResolution.xy*0.5;\n    vec2 defDistance = vec2(offset, 0.0);\n    vec2 position = center;\n   \n    position -= fragCoord;\n    position += rotate(startAngle + (ANIMATE ? iTime * 0.1 : 0.0)) * defDistance;\n    position += fragCoord;\n    return position;\n}\n\n\nvoid drawBackground(inout vec3 currentColor, in vec2 fragCoord)\n{\n    float currentLength = length(fragCoord - iResolution.xy*0.5);\n    float maxLength = length(iResolution.xy*0.5);\n    float currentLengthRatio = currentLength/maxLength;\n    float divs = iResolution.x/4.0;\n    \n    float colorValue = currentLength*2.0/maxLength;\n    \n    currentColor = COL_BACKGROUND * vec3(colorValue, colorValue, colorValue) \n                   * max(0.0, 1.0 - mod(currentLength - iTime * 0.1 * divs, divs)/maxLength);\n}\n\n\nvoid fadeOut(in float phaseTimer, inout vec3 currentColor){\n\n    float value = getTimedMix(phaseTimer, TIMER_PHASE_FADEOUT, TIMER_PHASE_RESET - TIMER_PHASE_FADEOUT - 1.0);\n    currentColor -= vec3(1.0) * value;\n}\n\n\nvoid fadeIn(in float phaseTimer, inout vec3 currentColor){\n\n    float value = getTimedMix(phaseTimer, TIMER_PHASE_RESET, TIMER_PHASE_ALL - TIMER_PHASE_RESET);\n    currentColor += vec3(1.0) * value;\n}\n\n\nint setPhase(in float time, out float phaseTimer)\n{\n    int phase = 0;\n    phaseTimer = mod(time, TIMER_PHASE_ALL);\n    \n    if(phaseTimer > TIMER_PHASE_RESET){\n        phase = 4;\n    }\n    else if(phaseTimer > TIMER_PHASE_FADEOUT){\n        phase = 3;\n    }\n    else if(phaseTimer > TIMER_PHASE_SPLIT){\n        phase = 2;\n    }\n    else if(phaseTimer > TIMER_PHASE_LOOK){\n        phase = 1;\n    }\n    else{\n        phase = 0;\n    }\n    \n    return phase;\n}\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec3 col = vec3(0.0);\n    float time = mod(iTime + TIME_OFFSET, 16384.0);\n    float phaseTimer;\n    \n    phaseInfo phase = phaseInfo(setPhase(time, phaseTimer), phaseTimer);\n    \n    drawBackground(col, fragCoord);\n      \n    if(phase.id >= 3 && phase.id < 4){\n        spliceImage(fragCoord);\n    }\n    \n    if(phase.id >= 2 && phase.id < 4){\n        splitImage(col, fragCoord, phaseTimer);  \n    }\n    \n    drawBackLines(col, fragCoord);  \n    drawForeLines(col, fragCoord, 0.0, phase);\n    \n    vec2[] positions = vec2[] (\n        \tiResolution.xy*0.5,\n       \t\tcalculateEyePos(TAU, iResolution.x*0.3, fragCoord),\n        \tcalculateEyePos(TAU/3.0, iResolution.x*0.3, fragCoord),\n        \tcalculateEyePos(TAU/3.0 * 2.0, iResolution.x*0.3, fragCoord)\n        );\n    \n    float[] sizes = float[] (\n        \tiResolution.x*0.105,\n        \tiResolution.x*0.055,\n        \tiResolution.x*0.055,\n        \tiResolution.x*0.055\n    \t);\n    \n    for(int i = 0; i < positions.length(); i++){\n        float seed = float(i) * 100.0;\n        orbInfo newOrb = orbInfo(positions[i], sizes[i], time + seed, seed);        \n        drawOrb(newOrb, phase, col, fragCoord);\n    }\n    \n    if(phase.id >= 3){\n        fadeOut(phaseTimer, col);\n    }\n    \n    if(phase.id >= 4){\n        fadeIn(phaseTimer, col);\n    }\n    \n    drawRectVignette(col, fragCoord);\n   \n    fragColor = vec4(col, 1.0);\n}", "image_inputs": [{"id": "4sf3Rn", "previewfilepath": "/media/ap/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tsKyD1.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[874, 874, 911, 911, 960], [963, 963, 1035, 1035, 1115], [1118, 1118, 1196, 1196, 1271], [1274, 1274, 1358, 1358, 1436], [1439, 1439, 1515, 1515, 1557], [1560, 1560, 1636, 1636, 1701], [1704, 1704, 1832, 1832, 3115], [3118, 3118, 3190, 3190, 3373], [3376, 3376, 3412, 3412, 3453], [3456, 3456, 3522, 3522, 3705], [3708, 3708, 3755, 3755, 3796], [3799, 3799, 3829, 3829, 3867], [3870, 3870, 3910, 3910, 3953], [3956, 3956, 3985, 3985, 4053], [4056, 4056, 4122, 4122, 4249], [4252, 4252, 4289, 4289, 4332], [4335, 4335, 4452, 4519, 4740], [4743, 4743, 4798, 4798, 5445], [5448, 5448, 5538, 5538, 7024], [7027, 7027, 7195, 7195, 7483], [7486, 7486, 7621, 7621, 7784], [7787, 7787, 7902, 7902, 8064], [8067, 8067, 8204, 8204, 8464], [8467, 8467, 8567, 8567, 8643], [8646, 8646, 8708, 8708, 8790], [8793, 8793, 8915, 8915, 9038], [9041, 9041, 9230, 9230, 10745], [10748, 10748, 10926, 10926, 11215], [11218, 11218, 11348, 11348, 12185], [12188, 12188, 12284, 12284, 12396], [12399, 12399, 12492, 12492, 12890], [12893, 12893, 12929, 12929, 13340], [13343, 13343, 13378, 13378, 13665], [13668, 13668, 13763, 13763, 14602], [14605, 14605, 14765, 14765, 15524], [15527, 15527, 15692, 15692, 16316], [16319, 16319, 16414, 16414, 16542], [16545, 16545, 16585, 16585, 16950], [16953, 16953, 17047, 17047, 18063], [18066, 18066, 18160, 18160, 18278], [18281, 18281, 18357, 18357, 19030], [19033, 19033, 19073, 19073, 19465], [19468, 19468, 19535, 19535, 20065], [20068, 20068, 20147, 20147, 20418], [20421, 20421, 20486, 20486, 20930], [20933, 20933, 20992, 20992, 21145], [21148, 21148, 21206, 21206, 21347], [21350, 21350, 21401, 21401, 21806], [21809, 21809, 21864, 21864, 23239]]}
{"id": "tsSyzt", "name": "heart and ribs lumina domnului", "author": "merrecurent_", "description": "second attempt", "tags": ["noob"], "likes": 1, "viewed": 149, "published": "Public API", "date": "1610576888", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\nfloat Band(float t, float start, float end, float blur){\n\tfloat step1 = smoothstep(start-blur, start + blur, t);\n    float step2 = smoothstep(end+blur, end-blur, t);\n    \n    return step1*step2;\n}\n\nfloat Rect(vec2 uv, float left, float right, float bottom, float top, float blur) {\n\tfloat band1 = Band(uv.x, left, right, blur);\n    float band2 = Band(uv.y, bottom, top, blur);\n    return band1*band2;\n    \n}\n\nfloat remap01(float a, float b, float p) {\n\treturn (p-a)/(b-a);\n}\n\nfloat remap(float a, float b, float c, float d, float p) {\n\treturn remap01(a, b, p)*(d-c)+c;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    float t = iTime;\n    uv -= .5;\n    uv.x *= iResolution.x/iResolution.y;\n    \n    vec3 col = vec3(0.);\n    \n    float mask = 0.;\n    \n    float y = uv.y;\n    float a = 0.;\n    float m = sin(1.3*t)*sin(y*10.+5.5*3.1415);\n    \n    m *= (2.*uv.x + 2.)*.05;\n    \n    float x = uv.x - m;\n    \n    float blurd = remap(-.5, .5, .03, .4, y);\n    float bluru = remap(-.5, .5, .03, .4, -y);\n    blurd = pow(blurd*3.5, 2.+ .7*uv.x);\n    bluru = pow(bluru*3.5, 2.+ .7*uv.x);\n    \n    mask = Rect(vec2(x, y), -.07, .07, -.5, .5, blurd)\n         + Rect(vec2(x, y), -.47, -.33, -.5, .5, blurd)\n         + Rect(vec2(x, y), -.87, -.73, -.5, .5, blurd)\n         + Rect(vec2(x, y), .33, .47, -.5, .5, blurd)\n         + Rect(vec2(x, y), .73, .87, -.5, .5, blurd);\n    mask += Rect(vec2(x, y), .13, .27, -.5, .5, bluru)\n          + Rect(vec2(x, y), -.27, -.13, -.5, .5, bluru)\n          + Rect(vec2(x, y), -.67, -.53, -.5, .5, bluru)\n          + Rect(vec2(x, y), .53, .67, -.5, .5, bluru);\n    col = vec3(1., .9, .71)*mask;\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tsSyzt.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 1, 57, 57, 197], [199, 199, 282, 282, 408], [410, 410, 452, 452, 475], [477, 477, 535, 535, 571], [573, 573, 630, 630, 1734]]}
{"id": "tt33WX", "name": "Texture along spline", "author": "blurryroots", "description": "Approach to align texture along bezier spline.", "tags": ["bezier", "curve", "image"], "likes": 5, "viewed": 262, "published": "Public API", "date": "1611449747", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/**\nBezier Spline Texture\nBy blurryroots innovation qanat OÜ\n*/\n\n\n#define MouseV (iMouse.y / iResolution.y)\n#define MouseU (iMouse.x / iResolution.x)\n#define UV_DEBUG 0\n#define SHOW_CONTROL_RIG 1\n#define DEFORM_BEZIER 1\n\n//Inspired by https://www.shadertoy.com/view/4ljfRD\nfloat drawLine (vec2 p1, vec2 p2, vec2 uv, float a)\n{\n    float r = 0.;\n    float one_px = 1. / iResolution.x; //not really one px\n    \n    // get dist between points\n    float d = distance(p1, p2);\n    \n    // get dist between current pixel and p1\n    float duv = distance(p1, uv);\n\n    //if point is on line, according to dist, it should match current uv \n    r = 1.-floor(1.-(a*one_px)+distance (mix(p1, p2, clamp(duv/d, 0., 1.)),  uv));\n        \n    return r;\n}\n\nvec3 DrawLine(vec2 A, vec2 B, vec2 UV, float Thickness, vec3 Color)\n{\n    vec2 Direction = normalize(B - A);\n    float Dist = distance(A, B);\n    \n    vec3 Right = cross(vec3(Direction, 0.), vec3(0., 0., 1.));\n    \n    return vec3(0.);\n}\n\nvec2 QuadraticBezier(vec2 A, vec2 B, vec2 C, float t)\n{\n\tvec2 AB = mix(A, B, t);\n\tvec2 BC = mix(B, C, t);\n\n\tvec2 P = mix(AB, BC, t);\n\n\treturn P;\n}\n\nvec2 CubicBezier(float t, vec2 A, vec2 B, vec2 C, vec2 D)\n{\n\tvec2 AB = mix(A, B, t);\n\tvec2 BC = mix(B, C, t);\n\tvec2 CD = mix(C, D, t);\n\n\tvec2 P = QuadraticBezier(AB, BC, CD, t);\n\n\treturn P;\n}\n\nvec2 DeformUVByControlPoints_Linear(vec2 UV, vec2 A, vec2 TangentA, vec2 TangentB, vec2 B)\n{\n    float x;\n    \n    if (UV.x <= TangentA.x) {\n    \tx = (UV.x - A.x) / (TangentA.x - A.x);\n        \n        UV.y += 0.5 - mix(A.y, TangentA.y, x);\n    }\n    else if (UV.x <= TangentB.x) {\n        x = (UV.x - TangentA.x) / (TangentB.x - TangentA.x);\n        \n        UV.y +=  0.5 - mix(TangentA.y, TangentB.y, x);\n        \n    }\n    else if (UV.x <= B.x) {\n        x = (UV.x - TangentB.x) / (B.x - TangentB.x);\n        \n        UV.y += 0.5 - mix(TangentB.y, B.y, x);\n    }\n    \n    return UV;\n}\n\nvec2 DeformUVByControlPoints_Bezier(vec2 UV, vec2 A, vec2 TangentA, vec2 TangentB, vec2 B)\n{\n\tfloat uvx = UV.x;\n    \n    vec2 NewUV = UV;\n    NewUV.y += 0.5 - CubicBezier(UV.x, A, TangentA, TangentB, B).y;\n\t\t\n\treturn NewUV;\n}\n\nvec3 OverlayControlRig(vec2 uv, vec2 Start, vec2 StartControl, vec2 End, vec2 EndControl, float size)\n{\n \tvec3 rigColor = vec3(0.);\n    \n    vec2 aspect = vec2(1., iResolution.y / iResolution.x);\n    // render control points\n    if (length((Start - uv) * aspect) < size) {\n    \trigColor += vec3(1.,1.,0.);\n    }\n    if (length((StartControl - uv) * aspect) < size) {\n    \trigColor += vec3(0.,1.,0.);\n    }\n    if (length((End - uv) * aspect) < size) {\n    \trigColor += vec3(0.,1.,1.);\n    }\n    if (length((EndControl - uv) * aspect) < size) {\n    \trigColor += vec3(0.,0.,1.);\n    }\n    \n    // draw lines for each control point segment\n    float lines = 0.\n        + drawLine(Start, StartControl, uv, 5.)\n        + drawLine(StartControl, EndControl, uv, 5.)\n        + drawLine(EndControl, End, uv, 5.)\n        ;\n    rigColor += vec3(lines, 0., 0.);\n    \n    return rigColor;\n}\n\nvec2 SheerEdges(vec2 UV, float LeftShearDistance, float RightShearDistance)\n{\n\tfloat RightShearSpaceX = UV.x - (2. * RightShearDistance * UV.y) + RightShearDistance;\n\tvec2 ShearRightUV = vec2(RightShearSpaceX, UV.y);\n\n\tfloat TotalLeftShearDistance = LeftShearDistance + -1. * RightShearDistance;\n\n    float TotalShearSpaceX = ShearRightUV.x - (2. * TotalLeftShearDistance * ShearRightUV.y) + TotalLeftShearDistance;\n    vec2 TotalShearUV = vec2(TotalShearSpaceX, ShearRightUV.y);\n\n    float DestretchX = TotalShearUV.x / (1. - (2. * TotalLeftShearDistance * ShearRightUV.y) + TotalLeftShearDistance);\n    TotalShearUV.x = DestretchX;\n\n\treturn TotalShearUV;\n}\n\nvec2 DeformAndSheer(vec2 UV, vec2 Start, vec2 StartControl, vec2 EndControl, vec2 End, float SkewLeft, float SkewRight)\n{\n    return DeformUVByControlPoints_Bezier(SheerEdges(UV, SkewLeft, SkewRight), Start, StartControl, EndControl, End);\n}\n\nvec2 RightVector(vec2 a, vec2 b)\n{\n    vec2 aa = a;\n    vec2 ba = b;\n    \n    vec2 diff = ba - aa;\n    vec2 right = vec2(diff.y, -diff.x);\n    \n    return vec2(right.x, right.y) + aa;\n}\n\nfloat PointSlope(vec2 a, vec2 b)\n{\n    vec2 diff = b - a;\n    return diff.y / diff.x;\n}\n\nvec2 InterceptionOfHorizontalLine(vec2 a, vec2 b, float line)\n{\n    float x = ((line - a.y) / PointSlope(a, b)) + a.x;\n    return vec2(x, line);\n}\n\nvec2 ToView(vec2 P)\n{\n     return P * iResolution.xy;\n}\n\nvec2 ToUV(vec2 P)\n{\n     return P / iResolution.xy;\n}\n\n/*\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec4 StartPointAndControl = vec4(0.1, 0.5, 0.33, 0.4);\n    vec4 EndPointAndControl = vec4(MouseU, MouseV, 0.9, 0.5);\n    \n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = ToUV(fragCoord);\n    vec2 aspect = vec2(1., iResolution.y / iResolution.x);\n    \n    // Setup Start, End and respective Control Points\n    vec2 Pstart = StartPointAndControl.rg;\n\tvec2 PstartControl = StartPointAndControl.ba;\n    \n\tvec2 PendControl = EndPointAndControl.xy;\n    vec2 Pend =EndPointAndControl.zw;\n    \n    vec3 color = vec3(0.);\n    \n    vec2 StartSkewControl = RightVector(Pstart * iResolution.xy, PstartControl * iResolution.xy)/iResolution.xy;      \n    float SkewStart = (InterceptionOfHorizontalLine(Pstart, StartSkewControl, 1.).x - Pstart.x) / aspect.y;\n    \n    vec2 EndSkewControl = RightVector(Pend * iResolution.xy, PendControl * iResolution.xy)/iResolution.xy;      \n    float SkewEnd = (InterceptionOfHorizontalLine(Pend, EndSkewControl, 1.).x - Pend.x) / aspect.y;\n    \n    // borders\n    vec2 clamped_uv = vec2((uv.x - Pstart.x) / (Pend.x - Pstart.x), uv.y);\n    \n    vec2 deformed_uv = DeformAndSheer(ToView(clamped_uv, \n                                      Pstart, PstartControl,\n                                      PendControl, Pend,\n                                      SkewStart, SkewEnd);\n    \n    color += texture(iChannel0, deformed_uv).rgb;\n    \n    if (0. > deformed_uv.x) color *= 0.;\n    if (0. > deformed_uv.y) color *= 0.;\n    if (1. < deformed_uv.x) color *= 0.;\n    if (1. < deformed_uv.y) color *= 0.;\n    \n    #if SHOW_CONTROL_RIG\n    color = max(OverlayControlRig(uv, Pstart, PstartControl, Pend, PendControl, 0.01), color);\n    #endif\n    \n    if (length((EndSkewControl - uv) * aspect) < 0.01) {\n    \tcolor += vec3(1.,1.,1.);\n    } \n    color += vec3(0,1,0) * drawLine(Pend, EndSkewControl, uv, 5.);\n    \n    fragColor = vec4(color, 1.0);\n}\n*/\nvec2 CaluclateUVs(vec2 UV, vec2 Start, vec2 StartControl, vec2 End, vec2 EndControl, vec2 Dimensions)\n{\n    float Aspect = Dimensions.y / Dimensions.x;\n\t// Calculate the skew amount for the start point.\n    vec2 StartSkewControl = RightVector(Start * Dimensions.xy, StartControl * Dimensions.xy) / Dimensions.xy;      \n    float SkewStart = (InterceptionOfHorizontalLine(Start, StartSkewControl, 1.).x - Start.x) / Aspect;\n    \n    // Calculate the skew amount for the end point.\n    vec2 EndSkewControl = RightVector(End * Dimensions.xy, EndControl * Dimensions.xy) / Dimensions.xy;      \n    float SkewEnd = (InterceptionOfHorizontalLine(End, EndSkewControl, 1.).x - End.x) / Aspect;\n    \n    // Reproject TexCoords so x=0 is at the start point and x=1 is at the end point. \n    vec2 PointSpaceUV = vec2((UV.x - Start.x) / (End.x - Start.x), UV.y);\n    // Take the reprojected uvs deform them along a cubic spline and sheer the start and end edges.\n    vec2 DeformationSpaceUV = DeformAndSheer(PointSpaceUV,\n    \tStart, StartControl,\n    \tEndControl, End, \n    \tSkewStart, SkewEnd\n    );\n\n    return DeformationSpaceUV;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec4 StartPointAndControl = vec4(0.2, 0.5, 0.33, 0.4);\n    vec4 EndPointAndControl = vec4(0.8, 0.5, MouseU, MouseV);\n    \n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 Dimensions = iResolution.xy;\n    vec2 TexCoords = ToUV(fragCoord);\n    \n    // Setup Start, End and respective Control Points\n    vec2 Start = StartPointAndControl.rg;\n\tvec2 StartControl = StartPointAndControl.ba + vec2(0., .2*sin(iTime));    \n    vec2 End = EndPointAndControl.xy;\n\tvec2 EndControl = EndPointAndControl.zw;\n    \n    vec2 DeformationSpaceUV = CaluclateUVs(TexCoords, Start, StartControl, End, EndControl, Dimensions);\n    \n    vec3 FinalColor = vec3(0.);\n    // Sample texture with deformed uvs.\n    FinalColor += texture(iChannel0, DeformationSpaceUV).rgb;\n    // Cut wrapped artefacts around deformed uv projection.\n    if (0. > DeformationSpaceUV.x) FinalColor *= 0.;\n    if (0. > DeformationSpaceUV.y) FinalColor *= 0.;\n    if (1. < DeformationSpaceUV.x) FinalColor *= 0.;\n    if (1. < DeformationSpaceUV.y) FinalColor *= 0.;\n    \n    #if SHOW_CONTROL_RIG\n    // Show cubic spline control points.\n    FinalColor += OverlayControlRig(TexCoords, Start, StartControl, End, EndControl, 0.01);\n    #endif\n    \n    fragColor = vec4(FinalColor, 1.0);\n}", "image_inputs": [{"id": "XdX3Rn", "previewfilepath": "/media/ap/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tt33WX.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[222, 274, 327, 327, 739], [741, 741, 810, 810, 978], [980, 980, 1035, 1035, 1126], [1128, 1128, 1187, 1187, 1319], [1321, 1321, 1413, 1413, 1908], [1910, 1910, 2002, 2002, 2135], [2137, 2137, 2240, 2240, 3014], [3016, 3016, 3093, 3093, 3674], [3676, 3676, 3797, 3797, 3917], [3919, 3919, 3953, 3953, 4104], [4106, 4106, 4140, 4140, 4193], [4195, 4195, 4258, 4258, 4341], [4343, 4343, 4364, 4364, 4398], [4400, 4400, 4419, 4419, 4453], [4455, 6404, 6507, 6507, 7527], [7529, 7529, 7586, 7586, 8837]]}
{"id": "tt3cDf", "name": "Testing Grids", "author": "Brofesor", "description": "Trying to learn grids.", "tags": ["grids"], "likes": 3, "viewed": 52, "published": "Public", "date": "1610029508", "time_retrieved": "2021-10-01T00:00:00", "image_code": "mat2 Rot(float a) {\n float s = sin(a), c = cos(a) ;\n return mat2(c, -s, s, c) ;\n\n }\n\nfloat Cube(vec2 gv,float scale)\n{\nfloat a = smoothstep(scale,scale-0.01,abs(gv.x));\n    a *= smoothstep(scale,scale-0.01,abs(gv.y));\n    return a;\n\n}\nfloat currentTime(float time,vec2 id)\n{\n    float ttime3 = (sin(iTime  + id.y * 0.4)); // Line\n    float ttime2 = (sin(iTime  + length(id)/3.141)); //Circle\n    float ttime = (sin(iTime + distance(id.y,0.)/3.141 + distance(id.x,0.)/3.141));// Square\n    float t = 0.;\n  if(mod(time,30.) < 10.) t = ttime;\n  else if(mod(time,30.) < 20.) t = ttime2;\n  else if(mod(time,30.) < 30.) t = ttime3;\nreturn t;\n\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    uv -= 0.5;\n    uv.x *= iResolution.x/iResolution.y;\n    uv *= 25.;\n   // uv *= Rot(iTime* 0.1);\n\n    \n    vec2 gv = fract(uv) -0.5;\n    vec2 id = floor(uv);\n    \n    \n    float current = currentTime(iTime*2.,id);\n    \n    vec3 col = vec3(Cube(gv* Rot(iTime),current)) * (vec3(0.1,0.6,0.9)* current);\n    \n    //if(gv.y > .40 || gv.x > .40) col = vec3(0.1,0.6,0.9);\n    \n    \n    \n\n\n\n\n\n\n\n    \n    \n    \n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tt3cDf.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 19, 19, 83], [85, 85, 118, 118, 234], [235, 235, 274, 274, 638], [640, 640, 697, 747, 1251]]}
{"id": "ttccRf", "name": "Deformed line distance field", "author": "kajbostrom", "description": "Using gradient descent to approximate the distance field of a line warped by noise (on both axes) - thanks iq for the analytic gradient noise derivatives!\nUse the mouse to show the gradient descent path for a given point.", "tags": ["2d", "noise", "sdf", "distance"], "likes": 2, "viewed": 50, "published": "Public", "date": "1609611076", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Distance to warped line by Kaj Bostrom, 2021\n\n\n// Gradient noise with analytic derivatives (and hash function) by iq\nvec2 hash( in vec2 x )  // replace this by something better\n{\n    const vec2 k = vec2( 0.3183099, 0.3678794 );\n    x = x*k + k.yx;\n    return -1.0 + 2.0*fract( 16.0 * k*fract( x.x*x.y*(x.x+x.y)) );\n}\n\n\n// return gradient noise (in x) and its derivatives (in yz)\nvec3 noised( in vec2 p )\n{\n    vec2 i = floor( p );\n    vec2 f = fract( p );\n\n#if 1\n    // quintic interpolation\n    vec2 u = f*f*f*(f*(f*6.0-15.0)+10.0);\n    vec2 du = 30.0*f*f*(f*(f-2.0)+1.0);\n#else\n    // cubic interpolation\n    vec2 u = f*f*(3.0-2.0*f);\n    vec2 du = 6.0*f*(1.0-f);\n#endif    \n    \n    vec2 ga = hash( i + vec2(0.0,0.0) );\n    vec2 gb = hash( i + vec2(1.0,0.0) );\n    vec2 gc = hash( i + vec2(0.0,1.0) );\n    vec2 gd = hash( i + vec2(1.0,1.0) );\n    \n    float va = dot( ga, f - vec2(0.0,0.0) );\n    float vb = dot( gb, f - vec2(1.0,0.0) );\n    float vc = dot( gc, f - vec2(0.0,1.0) );\n    float vd = dot( gd, f - vec2(1.0,1.0) );\n\n    return vec3( va + u.x*(vb-va) + u.y*(vc-va) + u.x*u.y*(va-vb-vc+vd),   // value\n                 ga + u.x*(gb-ga) + u.y*(gc-ga) + u.x*u.y*(ga-gb-gc+gd) +  // derivatives\n                 du * (u.yx*(va-vb-vc+vd) + vec2(vb,vc) - va));\n}\n\n#define STEPS 8\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.,0.,0., 1.);\n\n    vec2 p = 10.*fragCoord.xy / iResolution.y;\n    \n    vec2 o = vec2(0.0, 5);\n    vec2 d = vec2(1.0, 0.0);\n    \n    float s0 = dot(p-o, d);\n    float distSquared;\n    float minDistSquared = -1.0;\n    for (int i = -2; i <= 2; ++i) {\n        float s = s0 + float(i)*0.5;\n        for (int j = 0; j < STEPS; ++j) {\n\n            vec3 nx = noised(vec2(s, 0.+iTime));\n            vec3 ny = noised(vec2(s, 10.+iTime));\n\n            vec2 dn = vec2(nx.y, ny.y);\n\n            vec2 m = s*d + o + vec2(nx.x, ny.x);\n            vec2 dm = dn + d;\n            vec2 off = m - p;\n            distSquared = dot(off, off);\n            float ddist = dot(dm, off)/max(.5,length(off));\n\n            s = s - ddist*0.1/min(1., length(dm));\n        }\n        if (distSquared < minDistSquared || minDistSquared < 0.0) {\n            minDistSquared = distSquared;\n        }\n    }\n\n    float c = sqrt(minDistSquared);\n    \n    fragColor.x = fragColor.y = fragColor.z = 1.0 - c*.6;\n    \n    // Mouse diagnostic points\n    \n    // This section just does the same gradient descent but starting from\n    // the mouse coordinates instead of the current frag coords,\n    // in order to visualize the gradient descent steps\n    vec2 pm = 10.*iMouse.xy / iResolution.y;\n    \n    s0 = dot(pm-o, d);\n    minDistSquared = -1.0;\n    vec4 finalProposal = vec4(0., 0., 0., 0.);\n    for (int i = -2; i <= 2; ++i) {\n        float s = s0 + float(i)*0.5;\n        vec4 colorProposal = vec4(0., 0., 0., 0.);\n        for (int j = 0; j < STEPS; ++j) {\n\n            vec3 nx = noised(vec2(s, 0.+iTime));\n            vec3 ny = noised(vec2(s, 10.+iTime));\n\n            vec2 dn = vec2(nx.y, ny.y);\n\n            vec2 m = s*d + o + vec2(nx.x, ny.x);\n            if (length(m - p) < .1) {\n                float progress = float(j)/float(STEPS-1);\n                progress *= progress*progress;\n                colorProposal = vec4(1.0 - progress, progress, 0.2, 1.);\n            }\n            vec2 dm = dn + d;\n            vec2 off = m - pm;\n            distSquared = dot(off, off);\n            float ddist = dot(dm, off)/max(.5,length(off));\n\n            s = s - ddist*0.1/min(1., length(dm));\n        }\n        if (distSquared < minDistSquared || minDistSquared < 0.0) {\n            finalProposal = colorProposal;\n            minDistSquared = distSquared;\n        }\n    }\n    if (finalProposal.w != 0.) {\n        fragColor = finalProposal;\n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttccRf.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[50, 120, 181, 181, 319], [322, 382, 408, 408, 1274], [1294, 1294, 1351, 1351, 3779]]}
{"id": "ttcyRl", "name": "counteratction with mouse", "author": "gschian0", "description": "vibes", "tags": ["crazycolors"], "likes": 2, "viewed": 178, "published": "Public API", "date": "1609694197", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Fork of \"counteraction\" by gschian0. https://shadertoy.com/view/WldyRB\n// 2021-01-03 17:15:16\n\n#define PI 3.1415926535897932384626433832795\n#define TWOPI 6.283185307179586\n\n\n\nfloat rand(vec2 n) { \n    return fract(sin(dot(n, vec2(12.9898, 4.1414))) * 43758.5453);\n}\n\nfloat noise(vec2 p){\n    vec2 ip = floor(p);\n    vec2 u = fract(p);\n    u = u*u*(3.0-2.0*u);\n    \n    float res = mix(\n        mix(rand(ip),rand(ip+vec2(1.0,0.0)),u.x),\n        mix(rand(ip+vec2(0.0,1.0)),rand(ip+vec2(1.0,1.0)),u.x),u.y);\n    return res*res;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n    vec2 st = abs((2.*fragCoord.xy/iResolution.xy*2.-2.));\n    //vec2 st = fragCoord.xy/iResolution.xy;\n    st *= vec2(length(0.01*st),atan(st.y,st.x/iTime));\n    float noise1 = noise(st+0.3*iTime);\n    st.x *= iResolution.x/iResolution.y;\n    st.x += sin(0.3*1.0*iMouse.x*st.y+iTime)*0.5+0.5;\n   // st.y = sin(2.0*st.x-u_time);\n    st *= vec2(length(0.3*iMouse.y*st.x*st.y*noise1+sin(st.y*iTime*iMouse.y)*0.5+0.5),atan(st.y+sin(st.x*iTime*.003)*0.5+-0.5,st.x-sin(iTime*.03*noise1)*0.5+0.5)/PI/8.*noise1);\n    float d = length(st-vec2(0.003*(1.*sin(sin(st.y+sin(iTime)*0.01*noise1)))*0.5+0.5,0.18*(sin(st.x+sin(iTime)*0.5+0.5*.01*noise1+0.3*0.5))));\n    st.y+= log(abs(sin(iTime*.3)));\n    st.x += log(abs(sin(iTime*0.3)));\n    float circle = 1.-smoothstep(0.6,0.99,d);\n    \n//    for(float i = 0.07; i < 1.0; i += .1){\n//    \n//        circle += smoothstep(0.06+i, 0.061,d+i);\n//    }\n    vec3 color = vec3(abs(cos(1.0*st.y/d+iTime)),abs(sin(1.0*st.x/d-iTime)),abs(cos(10.0*st.y-st.x/d-iTime)));\n    //white\n    fragColor = 1.-vec4(vec3(circle)*color,1.0);\n    //fragCoord /= iResolution.y;  \n    fragColor = pow(fragColor,vec4(1./2.2));\n    //black\n     // gl_FragColor = vec4(vec3(circle)*color,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttcyRl.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 178, 198, 198, 268], [270, 270, 290, 290, 529], [531, 531, 585, 585, 1791]]}
{"id": "ttcyRX", "name": "problem noise", "author": "lumixraku", "description": "I try to implement https://www.youtube.com/watch?v=zXsWftRdsvU, but failed.", "tags": ["failed"], "likes": 0, "viewed": 30, "published": "Public", "date": "1609598497", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float scale = 5.;\n\n\n// N stands for noise\n// 2 means tow for two dimension input, 1 for one dimension output\nfloat N21(vec2 uv) {\n\n    float random = fract(sin((uv.x* 100. + uv.y* 2142.212)* 542.));\n\n    return random;\n}\n\nfloat SmoothNoise(vec2 uv){\n    vec2 localUV = fract(uv );\n    vec2 localID = floor(uv );\n    \n    float randomBL = N21(localID);\n    float randomBR = N21(localID + vec2(1, 0));\n    float randomTL = N21(localID + vec2(0, 1));\n    float randomTR = N21(localID + vec2(1, 1));\n    // float random = mix(randomBL, randomBR, localID.x);\n    // localUV = smoothstep(0., 1., localUV); \n    \n\n    localUV = localUV * localUV * (3. - 2. * localUV);\n\n    float t = mix(randomTL, randomTR, localUV.x);\n    float b = mix(randomBL, randomBR, localUV.x);\n    float random = mix(b, t, localUV.y);\n    return random;\n\n}\n\nvoid mainImage(out vec4 fragColor,in vec2 \nfragCoord)\n{\n\n    vec2 uv =(fragCoord-.5*iResolution.xy)/iResolution.y;\n    uv = uv + iTime;\n\n    \n    vec3 col=vec3(SmoothNoise(uv * 4.));\n    col += vec3(SmoothNoise(uv* 8.1)) * .5;\n    col += vec3(SmoothNoise(uv * 16.1) )* .25;\n    col += vec3(SmoothNoise(uv * 32.1)) * .125;\n    col += vec3(SmoothNoise(uv * 64.1)) * .0625;\n\n    col /= 2.;\n\n    fragColor=vec4(col, 1.);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttcyRX.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[20, 109, 129, 129, 220], [222, 222, 249, 249, 825], [827, 827, 882, 882, 1245]]}
{"id": "ttcyWB", "name": "SDF_Learning", "author": "Alienity", "description": "Learing geometry, the blending formula comes firom https://www.jcohen.name/papers/Ferreira_Levelsets_2007.pdf, but it looks not so right.", "tags": ["2d"], "likes": 0, "viewed": 164, "published": "Public API", "date": "1609805526", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float sdfCircle(vec2 coord, vec2 center, float radius)\n{\n\tvec2 offset = coord - center;\n\treturn sqrt((offset.x * offset.x) + (offset.y * offset.y)) - radius;\n}\n\nfloat sdfTorus(vec2 coord, vec2 center, float radius1, float radius2)\n{\n    vec2 offset = coord - center;\n    return abs(sqrt((offset.x * offset.x) + (offset.y * offset.y)) - radius1) - radius2;\n}\n\nfloat sdfEclipse(vec2 coord, vec2 center, float a, float b)\n{\n    float a2 = a * a;\n    float b2 = b * b;\n    return (b2 * (coord.x - center.x) * (coord.x - center.x) +\n        a2 * (coord.y - center.y) * (coord.y - center.y) - a2 * b2) / (a2 * b2);\n}\n\nfloat sdfBox(vec2 coord,  vec2 center, float width, float height)\n{\n    vec2 d = abs(coord - center) - vec2(width, height);\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat sdfRoundBox(vec2 coord,  vec2 center, float width, float height, float r)\n{\n    vec2 d = abs(coord - center) - vec2(width, height);\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0)) - r;\n}\n\n//*****************************Hard Blend******************************\nfloat sdfUnion(const float a,const float b) {\n    return min(a, b);\n}\n\nfloat sdfDifference(const float a, const float b) {\n    return max(a, -b);\n}\n\nfloat sdfIntersection(const float a, const float b) {\n    return max(a, b);\n}\n//*********************************************************************\n\n//******************************Soft Blend*****************************\n// https://www.iquilezles.org/www/articles/distfunctions/distfunctions.htm\nfloat opSmoothUnion( float d1, float d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); }\n\nfloat opSmoothSubtraction( float d1, float d2, float k ) {\n    float h = clamp( 0.5 - 0.5*(d2+d1)/k, 0.0, 1.0 );\n    return mix( d2, -d1, h ) + k*h*(1.0-h); }\n\nfloat opSmoothIntersection( float d1, float d2, float k ) {\n    float h = clamp( 0.5 - 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) + k*h*(1.0-h); }\n//*********************************************************************\n\n\n//*********************************************************************\n// https://www.jcohen.name/papers/Ferreira_Levelsets_2007.pdf\nfloat sdfBlending(float A, float B, const float alpha, float beta, float gamma) {\n    // A is the SDF the first geometry, B is the SDF of the second geometry and \n    // alpha is the filtering distance.\n    float m = clamp(abs(alpha-A),0.0f,alpha)/alpha*clamp(abs(alpha-B),0.0f,alpha)/alpha;\n    // the blended levelset. beta is the blending curve exponetial and gamma is the \n    // size of the extrusion in the blending area.\n    float C = min(A, B) + pow(m, beta) * gamma;\n    return C;\n}\n//*********************************************************************\n\n\nvec4 render(float d, vec3 color, float stroke) \n{\n\tfloat anti = fwidth(d) * 1.0;\n\tvec4 colorLayer = vec4(color, 1.0 - smoothstep(-anti, anti, d));\n\tif (stroke < 0.000001) {\n\t\treturn colorLayer;\n\t}\n\n\tvec4 strokeLayer = vec4(vec3(0.05, 0.05, 0.05), 1.0 - smoothstep(-anti, anti, d - stroke));\n\treturn vec4(mix(strokeLayer.rgb, colorLayer.rgb, colorLayer.a), strokeLayer.a);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    float x = 0.5f * iResolution.x;\n    float y = sin(iTime * 1.0f)*60.0f + 0.5f * iResolution.y;\n    vec2 circleCenter = vec2(x, y);\n\n    float r = sdfCircle(fragCoord.xy, circleCenter, 25.0f);\n    float r_1 = sdfCircle(fragCoord.xy, circleCenter, 10.0f);\n    r = sdfDifference(r, r_1);\n    \n    float r2 = sdfBox(fragCoord.xy, iResolution.xy*0.5f, 40.0f, 30.0f);\n    float r2_1 = sdfBox(fragCoord.xy, iResolution.xy*0.5f, 20.0f, 10.0f);\n    r2 = sdfDifference(r2, r2_1);\n    \n    //float r4 = sdfBlending(r, r2, 5.0f, 1.0f, 2.0f);\n    float r4 = opSmoothUnion(r, r2, 7.0f);\n    vec4 col = render(5.0f, vec3(0.5f, 0.05f, 0.0f), r4);\n    \n    // Output to screen\n    fragColor = col;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttcyWB.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 56, 56, 159], [161, 161, 232, 232, 357], [359, 359, 420, 420, 610], [612, 612, 679, 679, 792], [794, 794, 875, 875, 992], [994, 1066, 1111, 1111, 1135], [1137, 1137, 1188, 1188, 1213], [1215, 1215, 1268, 1268, 1292], [1366, 1513, 1565, 1565, 1664], [1666, 1666, 1724, 1724, 1824], [1826, 1826, 1885, 1885, 1984], [2059, 2193, 2274, 2395, 2684], [2685, 2759, 2808, 2808, 3132], [3135, 3135, 3192, 3242, 3969]]}
{"id": "ttcyzl", "name": "ShaderRoyale#3_CubesInMyMind", "author": "lechuga", "description": " 2do lugar - Hogmanay Party Shader Royale\n\ni change some stuff, so it's not totally the original, but the shapes reminds the same.\n\nI dedicate this to zozo uwu ;\n\nTwitch stream here -> https://www.twitch.tv/videos/856735468\n\nThank you all for support me !", "tags": ["cubes", "shader", "purple", "reflect", "neurons", "royale"], "likes": 10, "viewed": 265, "published": "Public", "date": "1609724160", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Licensed by a Vison\n\n#define time mod(iTime, 25.)\n#define m -texture(iChannel0, vec2(0.001, 1.)).x * 2.2\n#define t1 time*10.\n#define rot(a) mat2(cos(a), sin(a) ,-sin(a), cos(a))\n#define pi acos(-1.)\n#define tau pi*2.\n\nfloat rand(vec2 uv){\n  return fract(sin(dot(uv*.23244*uv.yx*.15756, vec2(234534.4234234)))*2345653.23423423);\n}\nconst float rep = 100.;\n\nfloat acumNeu = 1.;\n//const float rep5 = 60.;\nfloat base (inout vec3 p, inout float id){\n  vec3 p1 = p;\n  vec2 g = floor(p1.xy/rep-.5);\n  id = rand(g+4.324);\n  \n  p1.y += t1*1.5;\n  //p1.xz *= rot(tau+id*2.7);\n  p1.zy *= rot(tau+id*9.7);\n  \n  p1.x += sin(p1.y * 0.144+t1*.05) * 2.-.5;\n  p1.z += sin(p1.y*0.96554+t1*.06)*.5-.5;\n  p1.xz = (fract(p1.xz/rep-.5)-.5)*rep;\n  \n  //p1.x = abs(p1.x)-18.;\n  \n  p = p1;\n  float neu = length(p1.xz)-.6*sin(time+p1.x)*sin(time+p1.y)*sin(time+p1.z)*.5-.5;\n  \n  acumNeu += 1./(.1+neu*neu);\n  return neu;\n}\n\nfloat smin(float a, float b, float k){\n  float h = max(k-abs(a-b), 0.)/k;\n  return min(a, b)-pow(h, 3.)*k*(1.0/6.0);\n}\n\nfloat neurons(vec3 p){\n  vec3 p1 = p;\n  float id;\n  float d = base(p1, id);\n  p1.y -= t1*1.5;\n  float e = length(p1)-4.5-id m m m * sin(p1.x+t1)*sin(p1.y+t1-id)*sin(p1.z+t1)*.5-.5;\n  \n  return smin(d, e, 10.);\n}\n\nfloat acum1 = .0;\nconst float rep3 = 50.;\nconst float MAX_DIST = 70.;\n\n\nfloat sb(vec3 p, vec3 s){\n  vec3 q = abs(p)-s m;\n  return max(max(q.y, q.z), q.x);\n}\nconst float rep2 = 35.;\n\n\n\nbool coli = false;\nfloat cubs(vec3 p){\n  float d = neurons(p);\n  vec3 p1 = p;\n  \n  vec2 g = floor(p1.xz/rep2-.5);\n  float id = rand(g+4.324);\n  p1.xz *= rot(time*.013234235*id*id);\n  p1.yz *= rot(time*.02342345*id*id);\n  p1 -= vec3(id*6.+time*2., id*3.5, id*6.);\n  p1 = (fract(p1/rep2-.5)-.5)*rep2;\n  \n  // ---------- This is not part of the original-----------\n  p1.zy *= rot(time*2.+id);\n \n  // ---------- end----------------------------------------\n  \n\n  p1 = abs(p1)-.3 m m; // MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\n  \n  \n  \n  p1.xz -= time*.1;\n  p1.xz *= rot(time*id*.45);\n  p1.yz *= rot(time*id*.55);\n  //p1.x += sin(time)*5.5-.5;\n  p1 -= vec3(id*4., id*2., id*.2);\n  float b = sb(p1, vec3(.5, .1, 1.)+(id*2.))*.68+sin(t1+id*2.)*.5-.5;\n  b *= .85;\n  acum1 += .8/(5.+b*b*b);\n  coli = b < 50.;\n  \n  p1.y -= 10.5+t1;\n  d = smin(max(d, p1.y-5.2), b, 10.);\n  \n  return d;\n}\n\n\nbool coli2 = false;\nfloat laststand(vec3 p){\n  float d = cubs(p);\n  // not idea how to contine... mmmmm m mm mm m m m\n  \n  vec3 p1 = p;\n  \n  // woa... what have i done o_o\n  /*\n  float dd = pow(p1.z*60002.234234, 8.);\n  p1.x += sin(time+dd*2.)*2.;\n  p1.z += sin(time+dd*1.3254)*4.;\n  float rrr = 50.-sin(time+p1.x*2.)*sin(time+p1.y)*cos(p1.z+time)*.25-.0001 m m m m m m m m;\n  float cil = length(p1.xy)-rrr ;\n  //coli2 = cil < .5;\n  p = p1;\n  */\n  // didn't finish this, out of ideas :'c ggwp\n  return d;\n}\n\n#define map(p) laststand(p)\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n  uv -= 0.5;\n  uv /= vec2(iResolution.y / iResolution.x, 1);\n\n\n  vec3 s = vec3(-7.0001, -6.0001, -6.), r = normalize(vec3(-uv, .56 m*.025));\n  s.yz -= t1*2.;\n  //s.yz *= rot(sin(time)*.15);\n  \n  //s.xy *= rot(cos(time+s.z/pi)*.01);\n  //s.zx *= rot(cos(time+s.x/pi)*.01);\n\n  //s.z -= t1;\n  //\n  \n  vec3 p = s, col = vec3(0.);\n  float i = 0.;\n  const float MAX = 80.;\n  const vec2 off = vec2(0.145645, 0.);\n  vec3 n;    \n  for(; i < MAX; i++){\n    float d = map(p);\n    if(abs(d) < 0.001){\n      \n      n = normalize(d-vec3(map(p-off.xyy), map(p-off.yxy) , map(p-off.yyx)));\n      if(coli || coli2){\n        r = reflect(n,r);\n        d+=20.5;\n        //d*=.1;\n      }\n      else break;\n    }\n    if(d > MAX) break;\n    p+=d*r;\n  }\n  \n  n = normalize(map(p)-vec3(map(p-off.xyy), map(p-off.yxy) , map(p-off.yyx)));\n  vec3 l = normalize(vec3(-1.));\n  //col += 1.-i/MAX;\n  col += clamp(dot(n, l), 0., 1.);\n  col += acum1*vec3(0.14, .32, .66)*.38;\n  col += acumNeu*vec3(1., 0., 0.)*.96;\n  \n  col *= 1.-max(length(p-s)/MAX_DIST*0.25, 0.);\n\n  \n  col -= smoothstep(0., 1.,col)/tau;\n\n  \n  //col += rand(uv);\n  fragColor = vec4(col,1.0);\n    \n}", "image_inputs": [{"id": "4sf3Rn", "previewfilepath": "/media/ap/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttcyzl.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 221, 241, 241, 332], [378, 404, 446, 446, 897], [899, 899, 937, 937, 1017], [1019, 1019, 1041, 1041, 1230], [1304, 1304, 1329, 1329, 1388], [1435, 1435, 1454, 1454, 2296], [2319, 2319, 2343, 2343, 2805], [2836, 2836, 2893, 2943, 4117]]}
{"id": "ttdcDl", "name": "Cheaper Cloud Flythrough", "author": "jarble", "description": "This is an even cheaper version of Shane's [url=https://www.shadertoy.com/view/Xsc3R4]\"Cheap Cloud Flythrough.\"[/url] I removed the hash function, but it still looks almost identical to the original version.", "tags": ["noise", "cloud", "volumetric", "sinusoidal", "flythrough"], "likes": 9, "viewed": 456, "published": "Public API", "date": "1610247303", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/*\n\n\tCheap Cloud Flythrough \n\t----------------------\n\t\n\t\"Cheap\" should probably refer to the quality of the physics in this shader, which is\n\tvirtually non-existent, but it actually refers to the fake cloud algorithm... if you could \n\tcall it that. :)\n\t\n\tThis is merely an attempt to give the impression of a cloud flythrough, whilst maintaining\t\n\ta reasonably acceptable framerate. The key to that is keeping the distance field as simple \n\tas possible.\n\n\tDue to the amount of cost cutting, it's far from  perfect. However, there's still plenty \n\tof room for improvement.\n\n    I've used density based accumulation, which in one way or another, uses concepts from many \n\tvolumetric examples, but particularly from the following:\n\t\n\tCloudy Spikeball - Duke\n    https://www.shadertoy.com/view/MljXDw\n    // Port from a demo by Las - Worth watching.\n    // http://www.pouet.net/topic.php?which=7920&page=29&x=14&y=9\n    \n    Other shaders worth looking at:\n\n\tClouds - IQ: One of my favorite shaders, and everyone elses, it seems.\n\thttps://www.shadertoy.com/view/XslGRr\n\t\t\n\tSample Pinning - huwb: Fast, and pretty.\n\thttps://www.shadertoy.com/view/XdfXzn\n\t\n\tFakeVolumetricClouds - Kuvkar: Fast, using parallax layers. Really cool.\n\thttps://www.shadertoy.com/view/XlsXzN\n\n    Emission clouds - Duke: Nice, and straight forward.\n    https://www.shadertoy.com/view/ltBXDm\n\n\n*/\n\n\n// IQ's texture lookup noise... in obfuscated form. There's less writing, so\n// that makes it faster. That's how optimization works, right? :) Seriously,\n// though, refer to IQ's original for the proper function.\n// \n// By the way, you could replace this with the non-textured version, and the\n// shader should run at almost the same efficiency.\nfloat pn( in vec3 p ){\n    \n    vec3 i = floor(p); p -= i; p *= p*(3. - 2.*p);\n\tp.xy = texture(iChannel0, (p.xy + i.xy + vec2(37, 17)*i.z + .5)/256., -100.).yx;\n\treturn mix(p.x, p.y, p.z);\n}\n\n\n\n// Basic low quality noise consisting of three layers of rotated, mutated \n// trigonometric functions. Needs work, but sufficient for this example.\nfloat trigNoise3D(in vec3 p){\n\n    \n    float res = 0., sum = 0.;\n    \n    // IQ's cheap, texture-lookup noise function. Very efficient, but still \n    // a little too processor intensive for multiple layer usage in a largish \n    // \"for loop\" setup. Therefore, just one layer is being used here.\n    float n = pn(p*8. + iTime*2.);\n\n\n    // Two sinusoidal layers. I'm pretty sure you could get rid of one of \n    // the swizzles (I have a feeling the GPU doesn't like them as much), \n    // which I'll try to do later.\n    \n    vec3 t = sin(p.yzx*3.14159265 + cos(p.zxy*3.14159265+1.57/2.))*0.5 + 0.5;\n    p = p*1.5 + (t - 1.5); //  + iTime*0.1\n    res += (dot(t, vec3(0.333)));\n\n    t = sin(p.yzx*3.14159265 + cos(p.zxy*3.14159265+1.57/2.))*0.5 + 0.5;\n    res += (dot(t, vec3(0.333)))*0.7071;    \n\t \n\treturn ((res/1.7071))*0.85 + n*0.15;\n}\n\n// Distance function.\nfloat map(vec3 p) {\n\n    return trigNoise3D(p*0.5);\n    \n    // Three layers of noise, for comparison.\n    //p += iTime;\n    //return pn(p*.75)*0.57 + pn(p*1.875)*0.28 + pn(p*4.6875)*0.15;\n}\n\n#define rot(spin) mat2(cos(spin),sin(spin),-sin(spin),cos(spin))\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{  \n\n    // Unit direction ray vector: Note the absence of a divide term. I came across\n    // this via a comment Shadertoy user \"coyote\" made. I'm pretty easy to please,\n    // but I thought it was pretty cool.\n    vec3 rd = normalize(vec3(fragCoord - iResolution.xy*.5, iResolution.y*.75)); \n\n\n    //if (length(iMouse.xy) > 40.0) {\n        rd.xz *= rot(-3.14+iMouse.x/iResolution.x*3.14*2.0);\n        rd.yz *= rot(-3.14*0.5+iMouse.y/iResolution.y*3.14);\n    //}\n    // Ray origin. Moving along the Z-axis.\n    vec3 ro = vec3(0, 0, iTime*4.);\n\n    // Cheap camera rotation.\n    //\n    // 2D rotation matrix. Note the absence of a cos variable. It's there, but in disguise.\n    // This one came courtesy of Shadertoy user, \"Fabrice Neyret.\"\n    vec2 a = sin(vec2(1.5707963, 0) + iTime*0.1875);\n    mat2 rM = mat2(a, -a.y, a.x);\n    rd.xy = rd.xy*rM; // Apparently, \"rd.xy *= rM\" doesn't work on some setups. Crazy.\n    rd.xz = rd.xz*rM;\n\n\n\n    // Placing a light in front of the viewer and up a little, then rotating it in sync\n    // with the camera. I guess a light beam from a flying vehicle would do this.\n    vec3 lp = vec3( 0, 1, 4);\n    lp.xy = lp.xy*rM;\n    lp.xz = lp.xz*rM;\n    lp += ro;\n\n    // The ray is effectively marching through discontinuous slices of noise, so at certain\n    // angles, you can see the separation. A bit of randomization can mask that, to a degree.\n    // At the end of the day, it's not a perfect process. Note, the ray is deliberately left \n    // unnormalized... if that's a word.\n    //\n    // Randomizing the direction.\n    //rd = (rd + ((rd.zyx)*.006 - .003)); \n    // Randomizing the length also. \n    rd *= (1. + fract((dot(vec3(7, 157, 113), rd.zyx))*43758.5453)*0.06-0.03);      \n    \n    // Local density, total density, and weighting factor.\n    float lDe = 0., td = 0., w = 0.;\n\n    // Closest surface distance, and total ray distance travelled.\n    float d = 1., t = 0.;\n\n    // Distance threshold. Higher numbers give thicker clouds, but fill up the screen too much.    \n    const float h = .5;\n\n\n    // Initializing the scene color to black, and declaring the surface position vector.\n    vec3 col = vec3(0), sp;\n\n\n\n    // Particle surface normal.\n    //\n    // Here's my hacky reasoning. I'd imagine you're going to hit the particle front on, so the normal\n    // would just be the opposite of the unit direction ray. However particles are particles, so there'd\n    // be some randomness attached... Yeah, I'm not buying it either. :)\n    vec3 sn = normalize(-rd);\n\n    // Raymarching loop.\n    for (int i=0; i<64; i++) {\n\n        // Loop break conditions. Seems to work, but let me\n        // know if I've overlooked something.\n        if((td>1.) || d<.01*t || t>80.)break;\n\n\n        sp = ro + rd*t; // Current ray position.\n        d = map(sp); // Closest distance to the surface... particle.\n\n        // If we get within a certain distance, \"h,\" of the surface, accumulate some surface values.\n        // The \"step\" function is a branchless way to do an if statement, in case you're wondering.\n        //\n        // Values further away have less influence on the total. When you accumulate layers, you'll\n        // usually need some kind of weighting algorithm based on some identifying factor - in this\n        // case, it's distance. This is one of many ways to do it. In fact, you'll see variations on \n        // the following lines all over the place.\n        //\n        lDe = (h - d)*step(d, h); \n        w = (1. - td)*lDe;   \n\n        // Use the weighting factor to accumulate density. How you do this is up to you. \n        td += w*w*8. + 1./64.; //w*w*5. + 1./50.;\n        //td += w*.4 + 1./45.; // Looks cleaner, but a little washed out.\n\n\n        // Point light calculations.\n        vec3 ld = lp-sp; // Direction vector from the surface to the light position.\n        float lDist = max(length(ld), .001); // Distance from the surface to the light.\n        ld/=lDist; // Normalizing the directional light vector.\n\n        // Using the light distance to perform some falloff.\n        float atten = 1./(1. + lDist*.125 + lDist*lDist*.05);\n\n        // Ok, these don't entirely correlate with tracing through transparent particles,\n        // but they add a little anglular based highlighting in order to fake proper lighting...\n        // if that makes any sense. I wouldn't be surprised if the specular term isn't needed,\n        // or could be taken outside the loop.\n        float diff = max(dot( sn, ld ), 0.);\n        float spec = pow(max( dot( reflect(-ld, sn), -rd ), 0. ), 4.);\n\n\n        // Accumulating the color. Note that I'm only adding a scalar value, in this case,\n        // but you can add color combinations. Note the \"d*3. - .1\" term. It's there as a bit\n        // of a fudge to make the clouds a bit more shadowy.\n        col += w*(d*3. - .1)*(.5 + diff + spec*.5)*atten;\n\n        // Try this instead, to see what it looks like without the fake contrasting. Obviously,\n        // much faster.\n        //col += w*atten*1.25;\n\n\n        // Enforce minimum stepsize. This is probably the most important part of the procedure.\n        // It reminds me a little of of the soft shadows routine.\n        t +=  max(d*.5, .02); //\n        // t += .2; // t += d*.5;// These also work, but don't seem as efficient.\n\n    }\n\n    col = max(col, 0.);\n\n    // trigNoise3D(rd*1.)\n    col = mix(pow(vec3(1.5, 1, 1)*col,  vec3(1, 2, 8)), col, dot(cos(rd*6. +sin(rd.yzx*6.)), vec3(.333))*.35 + .65);\n    col = mix(col.zyx, col, dot(cos(rd*9. +sin(rd.yzx*9.)), vec3(.333))*.15 + .85);//xzy\n    \n\n    //col = mix(col.zyx, col, dot(rd, vec3(.5))+.5);\n\n    fragColor = vec4(sqrt(max(col, 0.)), 1.0);\n}", "image_inputs": [{"id": "Xsf3zn", "previewfilepath": "/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttdcDl.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1370, 1716, 1738, 1738, 1906], [1910, 2058, 2087, 2087, 2899], [2901, 2923, 2942, 2942, 3113], [3181, 3181, 3238, 3448, 8898]]}
{"id": "ttdcR2", "name": "New Year's Resolution 2021", "author": "netgrind", "description": "my new year's resolution is to watch what unfolds", "tags": ["eyes", "eye", "rainbow", "resolution", "unfold", "2021"], "likes": 9, "viewed": 241, "published": "Public API", "date": "1609561964", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// \"Fork\" of \"Geodesic tiling (abs position)\" by tdhooper. https://shadertoy.com/view/XtKSWc\n// Most of the geodesic stuff is gone, but the march/render code is still in place\n// various sdf functions via iq and mercury\n// 2021-01-01 23:50:17\n\n\n// --------------------------------------------------------\n// Modelling\n// --------------------------------------------------------\n\nstruct Model {\n    float dist;\n    vec3 color;\n};\n\n\n\n// --------------------------------------------------------\n// Camera\n// https://www.shadertoy.com/view/Xl2XWt\n// --------------------------------------------------------\n\nmat3 calcLookAtMatrix( in vec3 ro, in vec3 ta, in float roll )\n{\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(sin(roll),cos(roll),0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n    return mat3( uu, vv, ww );\n}\n\nfloat pModPolar(inout vec2 p, float repetitions, float phase) {\n\tfloat angle = 2.*3.14159/repetitions;\n\tfloat a = atan(p.y, p.x) + angle/2.+phase/repetitions;\n\tfloat r = length(p);\n\tfloat c = floor(a/angle);\n\ta = mod(a,angle) - angle*.5;\n    a = abs(a);\n\tp = vec2(cos(a), sin(a))*r;\n\t// For an odd number of repetitions, fix cell index of the cell in -x direction\n\t// (cell index would be e.g. -5 and 5 in the two halves of the cell):\n\tif (abs(c) >= (repetitions/2.)) c = abs(c);\n\treturn c;\n}\nfloat pMod1(inout float p, float size) {\n\tfloat halfsize = size*0.5;\n\tfloat c = floor((p + halfsize)/size);\n\tp = mod(p + halfsize, size) - halfsize;\n\treturn c;\n}\n\n\nvec4 fOpUnionRound(vec4 a, vec4 b, float r) {\n\tfloat h = clamp( 0.5 + 0.5*(b.x-a.x)/r, 0.0, 1.0 );\n    return mix( b, a, h ) - r*h*(1.0-h);\n}\n    \nvec4 opSmoothSubtraction( vec4 d1, vec4 d2, float k ) {\n    float h = clamp( 0.5 - 0.5*(d2.x+d1.x)/k, 0.0, 1.0 );\n    return mix( d2, vec4(-d1.x, d1.yzw), h ) + k*h*(1.0-h); \n}\nvec4 opUnion( vec4 d1, vec4 d2 ) {  return mix(d1,d2, clamp(ceil(d1.x-d2.x), 0., 1.)); }\n\nvoid pR(inout vec2 p, float a) {\n\tp = cos(a)*p + sin(a)*vec2(p.y, -p.x);\n}\nfloat vmax(vec2 v) {\n\treturn max(v.x, v.y);\n}\n\nfloat vmax(vec3 v) {\n\treturn max(max(v.x, v.y), v.z);\n}\n\nfloat vmax(vec4 v) {\n\treturn max(max(v.x, v.y), max(v.z, v.w));\n}\n\nfloat vmin(vec2 v) {\n\treturn min(v.x, v.y);\n}\n\nfloat vmin(vec3 v) {\n\treturn min(min(v.x, v.y), v.z);\n}\n\nfloat vmin(vec4 v) {\n\treturn min(min(v.x, v.y), min(v.z, v.w));\n}\n\nfloat fBox(vec3 p, vec3 b) {\n\tvec3 d = abs(p) - b;\n\treturn length(max(d, vec3(0))) + vmax(min(d, vec3(0)));\n}\n\nfloat fTorus(vec3 p, float smallRadius, float largeRadius) {\n\treturn length(vec2(length(p.xz) - largeRadius, p.y)) - smallRadius;\n}\n\n\n// The actual model\nModel map(vec3 p) {\n    \n    float sineTime = iTime*6.28*.5;\n\n\tfloat sphere = length(p) - 2.; \n    sphere = max(-(length(p)-1.8), sphere);\n    vec2 uv = p.xy*2.;\n   \n    float f = floor(uv.x+uv.y) + floor(uv.y-uv.x);\n    uv = vec2(fract(uv.x+uv.y),fract(uv.y-uv.x));\n    uv -= .5;\n    \n    vec3 pos = p;\n    //pos.y-=.08;\n    float i = pMod1(pos.y, .25);\n    float j = pModPolar(pos.xz,30.,i*3.14159+(sineTime+sin(sineTime+3.1415)*1.5)*(mod(i, 2.)-.5));\n    pos -= vec3(.8-cos((i)*.2+3.14159), 0., 0.);\n    float eye = length(pos+vec3(0., .04, 0.))-.1;\n    eye = max(eye, length(pos-vec3(0., .04, 0.))-.1);\n    vec4 s = fOpUnionRound(vec4(sphere, 0., 0., 0.), vec4(eye, 2., 2., 2.), 0.05);\n    s = opSmoothSubtraction(vec4(eye-.005, 0., 0., 0.), s, .01);\n    pR(pos.xy, p.y*.5+sin(i+j+sineTime)*.05);\n    float a =atan(pos.z, pos.y);\n    vec3 eyeColor = sin(vec3((p.x+p.y*2.+vec3(0., .3, .6))*7.+sineTime))*.4+.4;\n    eyeColor+=cos(a*20.+a*3.)*.2+.2;\n    float pupilSize = 0.025+sin(sineTime-(p.y-p.x)*2.)*0.005;\n    eyeColor*=smoothstep(pupilSize, pupilSize+.01, length(pos.zy));\n    s = opUnion(s, vec4(length(pos)-.06, eyeColor));\n    p*=.8;\n    //p.y -= .01;\n    pR(p.yz, 1.);\n    pos = p;\n    i = pModPolar(pos.xz, 10., sineTime);\n    pR(pos.xy, -sineTime*.5);\n    j = pModPolar(pos.yx, 5., sineTime);\n    float box = fBox(pos, vec3(0., .1*smoothstep(0., .1,length(p-vec3(0., .1, 0.))), 0.));\n    vec4 b = vec4(box, sin((pos.y*8.+vec3(0., .66, .33))*7.-sineTime+atan(p.x, p.z))*.5+.5);\n    b = fOpUnionRound(b, vec4(length(p)-.05, 1, 1, 1), .1);\n    s = opUnion(s, b); \n\treturn Model(s.x, s.yzw);\n}\n\n\n// --------------------------------------------------------\n// Ray Marching\n// Adapted from cabbibo https://www.shadertoy.com/view/Xl2XWt\n// --------------------------------------------------------\n\nconst float MAX_TRACE_DISTANCE = 10.;\nconst float INTERSECTION_PRECISION = .00001;\nconst int NUM_OF_TRACE_STEPS = 100;\n\nstruct CastRay {\n    vec3 origin;\n    vec3 direction;\n};\n\nstruct Ray {\n    vec3 origin;\n    vec3 direction;\n    float len;\n};\n\nstruct Hit {\n    Ray ray;\n    Model model;\n    vec3 pos;\n    bool isBackground;\n    vec3 normal;\n    vec3 color;\n};\n\nvec3 calcNormal( in vec3 pos ){\n    vec3 eps = vec3( 0.001, 0.0, 0.0 );\n    vec3 nor = vec3(\n        map(pos+eps.xyy).dist - map(pos-eps.xyy).dist,\n        map(pos+eps.yxy).dist - map(pos-eps.yxy).dist,\n        map(pos+eps.yyx).dist - map(pos-eps.yyx).dist );\n    return normalize(nor);\n}\n    \nHit raymarch(CastRay castRay){\n\n    float currentDist = INTERSECTION_PRECISION * 2.0;\n    Model model;\n    \n    Ray ray = Ray(castRay.origin, castRay.direction, 0.);\n\n    for( int i=0; i< NUM_OF_TRACE_STEPS ; i++ ){\n        //if (currentDist < INTERSECTION_PRECISION || ray.len > MAX_TRACE_DISTANCE) {\n        //    break;\n        //}\n        model = map(ray.origin + ray.direction * ray.len);\n        currentDist = model.dist;\n        ray.len += currentDist;\n    }\n    \n    bool isBackground = false;\n    vec3 pos = vec3(0);\n    vec3 normal = vec3(0);\n    vec3 color = vec3(0);\n    \n    if (ray.len > MAX_TRACE_DISTANCE) {\n        isBackground = true;\n    } else {\n        pos = ray.origin + ray.direction * ray.len;\n        normal = calcNormal(pos);\n    }\n\n    return Hit(ray, model, pos, isBackground, normal, color);\n}\n\n\n// --------------------------------------------------------\n// Rendering\n// --------------------------------------------------------\n\nvec3 render(Hit hit){\n    if (hit.isBackground) {\n        return vec3(0);\n    }\n    vec3 color = hit.model.color;\n    color += sin(dot(hit.normal, vec3(0,1,0))) * .2; // lighting\n    color *= 1. - clamp(hit.ray.len * .4 - .8, 0., 1.); // fog\n    return color;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    vec2 p = (-iResolution.xy + 2. * fragCoord.xy) / iResolution.y;\n\n    vec3 camPos = vec3(0, 0, .4);\n    vec3 camTar = vec3(0);\n    float camRoll = 0.;\n    mat3 camMat = calcLookAtMatrix(camPos, camTar, camRoll);\n    \n    vec3 rd = normalize(camMat * vec3(p.xy, 2.));\n    Hit hit = raymarch(CastRay(camPos, rd));\n\n    vec3 color = render(hit);\n    float f = .85;\n    //color *= smoothstep(f+.05, f, abs(p.y-.08)-abs(p.x)*.1);\n    fragColor = vec4(color,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttdcR2.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[432, 604, 668, 668, 846], [848, 848, 911, 911, 1340], [1341, 1341, 1381, 1381, 1502], [1505, 1505, 1550, 1550, 1646], [1652, 1652, 1707, 1707, 1828], [1829, 1829, 1863, 1863, 1917], [1919, 1919, 1951, 1951, 1993], [1994, 1994, 2014, 2014, 2039], [2041, 2041, 2061, 2061, 2096], [2098, 2098, 2118, 2118, 2163], [2165, 2165, 2185, 2185, 2210], [2212, 2212, 2232, 2232, 2267], [2269, 2269, 2289, 2289, 2334], [2336, 2336, 2364, 2364, 2445], [2447, 2447, 2507, 2507, 2578], [2581, 2601, 2620, 2620, 4204], [4207, 4770, 4801, 4801, 5058], [5064, 5064, 5094, 5094, 5886], [5889, 6023, 6044, 6044, 6284], [6287, 6287, 6344, 6344, 6812]]}
{"id": "ttdyWf", "name": "Ray marched sphere", "author": "intrakits", "description": "This is my first attempt at ray marching. :)", "tags": ["3d", "raymarching", "lighting", "sphere", "diffuse"], "likes": 1, "viewed": 166, "published": "Public API", "date": "1610088083", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define MAX_STEPS 100\n#define MAX_DIST 100.\n#define SURFACE_DIST 0.01\nfloat GetDist(vec3 p){\n    // some test object\n    vec4 sphere = vec4(0,1,6,1);\n    \n    // distance to sphere\n    //--------------------------------\n    // distance to center of sphere: \n    // length(sphere position - camera position)\n    // distance to outside of the sphere:\n    // length(sphere position - camera position) - sphere radius\n    float ds = length(p-sphere.xyz)-sphere.w;\n    \n    //distance to floor (plane)\n    //this is just height of the origin point passed\n    float dp = p.y;\n    \n    //choose the closest of the two\n    float d = min(ds,dp);\n   \n    return d;\n}\nfloat RayMarch(vec3 ro, vec3 rd){\n    // distance from origin\n    float dO=0.;\n    // march until max steps is achieved or object hit\n    for(int i=0; i <MAX_STEPS; i++){\n        // current point being evaluated\n        vec3 p = ro + dO*rd;\n        \n        // get distance to seam\n        float ds = GetDist(p);\n        //move origin to new point\n        dO+=ds;\n        if(ds < SURFACE_DIST || dO > MAX_DIST){\n            break;\n        }\n    }\n    return dO;\n}\nvec3 GetNormal(vec3 p){\n    //distance to point being analyzed\n    float d = GetDist(p);\n    \n    //distance to another point along the objects surface that is closeby\n    vec2 e = vec2(0.01,0);\n    \n    //slope between the two points\n    //note: swizzel is the .xxy or .yyx etc\n    vec3 n = d - vec3(\n         GetDist(p-e.xyy),\n         GetDist(p-e.yxy),\n         GetDist(p-e.yyx));\n         \n    return normalize(n);\n    \n}\nfloat GetLight(vec3 p){\n    //position of the light source\n    vec3 lightPos = vec3(0,5,6);\n    \n    lightPos.xz += vec2(sin(iTime),cos(iTime));\n    //light vector\n    vec3 l = normalize(lightPos-p);\n    \n    //normal of object\n    vec3 n = GetNormal(p);\n    \n    // dot product of the light vector and normal of the point\n    // will give us the amount of lighting to apply to the point\n    // dot() evaluates to values between -1 and 1, so we will clamp it\n    float diff = clamp(dot(n, l),0.,1.);\n    \n    // calculate if point should be a shadow:\n    // raymarch from point being calculated towards light source\n    // if hits surface of something else before the light,\n    // then it must be obstructed and thus is a shadow\n    // the slight offset \"p+n*SURFACE_DIST*1.1\" is needed to ensure the\n    // break condistions in the function are not met too early\n    float d = RayMarch(p+n*SURFACE_DIST*1.1,l);\n    if(d < length(lightPos-p)){\n        diff *= 0.1;\n    }\n    return diff;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from -0.5 to 0.5)\n    // origin is now (0,0)\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    vec3 col = vec3(0);\n    \n    //camera\n    //-----------------\n    // ray origin\n    vec3 ro = vec3(0,1,0);\n    \n    //ray dir\n    vec3 rd = normalize(vec3(uv.x,uv.y,1));\n    //------------------\n    float d = RayMarch(ro,rd);\n    vec3 p = ro + rd *d;\n    float diff = GetLight(p);\n    col = vec3(diff);\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttdyWf.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[70, 70, 92, 116, 656], [657, 657, 690, 718, 1120], [1121, 1121, 1144, 1183, 1546], [1547, 1547, 1570, 1605, 2537], [2538, 2538, 2595, 2677, 3076]]}
{"id": "ttdyWH", "name": "ocean voronoice", "author": "wnu", "description": "nv", "tags": ["nv"], "likes": 2, "viewed": 56, "published": "Public", "date": "1611709895", "time_retrieved": "2021-10-01T00:00:00", "image_code": "mat4 rotationMatrix(vec3 axis, float angle)\n{\n    axis = normalize(axis);\n    float s = sin(angle);\n    float c = cos(angle);\n    float oc = 1.0 - c;\n    \n    return mat4(oc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s,  0.0,\n                oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s,  0.0,\n                oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c,           0.0,\n                0.0,                                0.0,                                0.0,                                1.0);\n}\n\nmat2 Rot(float a) {\n    float s = sin(a);\n    float c = cos(a);\n    return mat2(c, -s, s, c);\n}\n\nfloat random3 (in vec3 _st) {\n    return fract(sin(dot(_st,\n                         vec3(12.9898,78.233,123.24647)))*\n      43758.5453123);\n}\n\nvec2 N22(vec2 p){\n    vec3 a = fract(p.xyx*vec3(123.34,234.34,345.65));\n    a += dot(a,a+34.45);\n    return fract(vec2(a.x*a.y,a.y*a.z));\n\n}\n\nfloat voronoi(vec2 uv){\n    uv*=3.;\n    float minDist = 100.;\n    float t = iTime;\n        \n    vec2 gv = fract(uv)-.5;\n    vec2 id = floor(uv);\n    for(float y=-1.;y<=1.;y++){\n        for(float x = -1.;x<=1.;x++){\n            vec2 offs = vec2(x,y);\n            vec2 n = N22(id + offs);\n            vec2 p = offs + sin(n*t)*.5;\n\n            float d = length(gv-p);\n\n            if(d<minDist){\n                minDist = d;\n            }\n\n        }\n    }\n    \n    return minDist;\n\n}\n\nvec3 hsl2rgb( in vec3 c )\n{\n    vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n\n    return c.z + c.y * (rgb-0.5)*(1.0-abs(2.0*c.z-1.0));\n}\n\nfloat noise3 (in vec3 _st) {\n    vec3 i = floor(_st);\n    vec3 fr = fract(_st);\n\n    // Four corners in 2D of a tile\n    float a = random3(i);\n    float b = random3(i + vec3(1.0, 0.0, 0.0));\n    float c = random3(i + vec3(0.0, 1.0, 0.0));\n    float d = random3(i + vec3(1.0, 1.0, 0.0));\n    \n    float e = random3(i + vec3(0.0, 0.0, 1.0));\n    float f = random3(i + vec3(1.0, 0.0, 1.0));\n    float g = random3(i + vec3(0.0, 1.0, 1.0));\n    float h = random3(i + vec3(1.0, 1.0, 1.0));\n\n    vec3 u = fr * fr * (3.0 - 2.0 * fr);\n    \n    float bf = mix(a,b,u.x);\n    float bb = mix(c,d,u.x);\n    \n    float bot = mix(bf,bb,u.y);\n    \n    float tf = mix(e,f,u.x);\n    float tb = mix(g,h,u.x);\n    \n    float top = mix(tf,tb,u.y); \n\n    return mix(bot,top,u.z);\n}\n\n#define NUM_OCTAVES 5\n\nfloat fbm3 ( in vec3 _st) {\n    float v = 0.0;\n    float a = 0.5;\n    vec3 shift = vec3(100.0);\n    float offset = 0.;\n    for (int i = 0; i < NUM_OCTAVES; ++i) {\n        //v += a * sin((_st.y + _st.x+ _st.y)*10.)*1.5;\n        offset += a*2.5/1.5;\n        v += a * noise3(_st)*2.5;\n        _st = _st * 2. + shift;\n        a *= 0.5;\n    }\n    return v/offset;\n}\n\nfloat fbmN(vec3 _st, int n){\n\tfloat v = 0.;\n    for (int i = 0;i<4;i++){\n        if(i>=n) break;\n        v= fbm3(_st + v*4.);\n    }\n    \n    return v;\n}\n\nfloat map(vec3 pos){\n    float circle = length(pos) - 1.;\n    float plane = pos.y;\n    plane += 1.-pow(voronoi(pos.xz/10.)*1.,2.);\n    //plane += fbmN(vec3(pos.xz,0.),1)/1.;\n    plane += fbm3(vec3(pos.xz,0.))/10.;\n    plane += sin(length(pos.xz-vec2(0.,-50.))+iTime*4.)/4.;\n    //plane += noise3(vec3(pos.xz,0.))/10.;\n    //plane += random3(vec3(pos.xz/100.,0.))/1000.;\n    float d= plane;\n    return d/10.;   \n}\n\n//int MAX_STEPS = 100;\n//float MAX_DIST = 10.;\n//float SURF_DIST = 0.05;\n\n#define MAX_STEPS 100\n#define MAX_DIST 100.\n#define SURF_DIST .001\n\nfloat rayMarch(vec3 ro, vec3 rd){\n    float d = 0.;\n    \n    for(int i = 0;i<MAX_STEPS; i++){\n        vec3 p = ro + rd*d;\n        float dS = map(p);\n        d += dS;\n        if(d>MAX_DIST || abs(dS)<SURF_DIST) break;\n    }\n    \n    return d;\n}\n\nvec3 GetNormal(vec3 p) {\n\tfloat d = map(p);\n    vec2 e = vec2(.001, 0);\n    \n    vec3 n = d - vec3(\n        map(p-e.xyy),\n        map(p-e.yxy),\n        map(p-e.yyx));\n    \n    return normalize(n);\n}\n\nfloat GetLight(vec3 p,vec3 lightPos) {\n    vec3 l = normalize(lightPos-p);\n    vec3 n = GetNormal(p);\n    \n    float dif = clamp(dot(n, l)*.5+.5, 0., 1.);\n    float d = rayMarch(p+n*SURF_DIST*2., l);\n   // if(p.y<.01 && d<length(lightPos-p)) dif *= .5;\n    \n    return dif;\n}\n\nvec3 R(vec2 uv, vec3 p, vec3 l, float z) {\n    vec3 f = normalize(l-p),\n        r = normalize(cross(vec3(0,1,0), f)),\n        u = cross(f,r),\n        c = p+f*z ,\n        i = c + uv.x*r + uv.y*u ,\n        d = normalize(i-p);\n    return d;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    mat4 rot = rotationMatrix(vec3(1.,1.,1.),0.);\n    vec2 uv = (fragCoord-0.5*iResolution.xy)/iResolution.y;\n    vec2 m = iMouse.xy/iResolution.xy;\n    m = vec2(0.5,0.35);\n\n    vec3 offset = vec3(0.,0.,-iTime/2.);\n    vec3 ro = vec3(0, 4, -5);\n    ro.yz *= Rot(-m.y*3.14+1.);\n    ro.xz *= Rot(-m.x*6.2831);\n    ro += offset;\n    \n    vec3 rd = R(uv, ro, vec3(0,1,0)+ offset, 1.);\n    \n    vec3 col = vec3(0.0);\n    float t = 0.0;\n    \n    float d = rayMarch(ro,rd);\n    \n    if(d<MAX_DIST){\n        vec3 p = ro + rd*d;\n        float dif = GetLight(p,vec3(1000.,1.,0.));\n        vec3 sun = vec3(0.8,0.2,0.2);\n        sun = vec3(0.3,0.5,0.6);\n        vec3 dep = vec3(0.7,0.5,0.2);\n        //dep = vec3(0.5,0.5,0.5);\n        vec3 cra = vec3(1.,0.1,0.1);\n        //cra = vec3(0.1,0.1,1.);\n        \n        vec3 sun2 = vec3(0.7,0.6,0.2);\n        float dif2 = GetLight(p,vec3(-50,1,-4));\n        \n        vec3 sun_col = vec3(dif)*sun;\n        float depth = -p.y;\n        vec3 dep_col = dep*depth;\n        float crag = smoothstep(-0.8,-1.,p.y);\n        vec3 crag_col = cra*crag;\n        col = sun_col;\n        ///col = mix(sun_col,dep_col,0.5);\n        //col += crag_col;\n        //col += dif2*sun2/2.;\n    }\n    \n    //float c = step(10.,d);\n    \n    //col = vec3(c);\n    \n\n    fragColor = vec4(col,1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttdyWH.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 45, 45, 673], [675, 675, 694, 694, 770], [772, 772, 801, 801, 914], [916, 916, 933, 933, 1056], [1058, 1058, 1081, 1081, 1538], [1540, 1540, 1567, 1567, 1710], [1712, 1712, 1740, 1740, 2470], [2495, 2495, 2522, 2522, 2855], [2857, 2857, 2885, 2885, 3009], [3011, 3011, 3031, 3031, 3423], [3425, 3567, 3600, 3600, 3810], [3812, 3812, 3836, 3836, 4010], [4012, 4012, 4050, 4050, 4287], [4289, 4289, 4331, 4331, 4528], [4530, 4530, 4587, 4587, 5888]]}
{"id": "ttGcDz", "name": "Eye Eye", "author": "YitingLiu", "description": "Do you see the eye? Try using your mouse. ", "tags": ["mouse", "interactive", "eye", "orange", "shader", "heartbeat", "pulsing", "meditative"], "likes": 0, "viewed": 159, "published": "Public API", "date": "1610801014", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Inspiration - Book of Shader - Circles \n// Based on the code by Author @patriciogv - 2015\n// http://patriciogonzalezvivo.com\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 st = fragCoord.xy/iResolution.xy;\n    vec2 st_mouse =fragCoord.xy/iMouse.xy;\n  \n    float pct = 0.0;\n    float pulse = abs(sin(iTime));\n    vec3 color = vec3(0.845,0.620*pulse,0.014);\n    \n    color= vec3(color*pulse);\n\n    // a. The DISTANCE from the pixel to the center\n    pct = smoothstep(max(distance(st,vec2(0.2)),distance(st,vec2(0.8))),pulse/2.,pulse/4.)-\n        smoothstep(distance(st,vec2(0.480,0.490)) * distance(st,vec2(st_mouse)-vec2(0.5)),pulse/3.,pulse/4.5);\n\n    // pct = min(distance(st,vec2(0.4)),distance(st,vec2(0.6)));\n    // pct = distance(st,vec2(0.4)) + distance(st,vec2(0.6));\n    // pct = distance(st,vec2(0.4)) * distance(st,vec2(0.6));\n    // pct = min(distance(st,vec2(0.4)),distance(st,vec2(0.6)));\n    // pct = max(distance(st,vec2(0.4)),distance(st,vec2(0.6)));\n    // pct = pow(distance(st,vec2(0.4)),distance(st,vec2(0.6)));\n    // b. The LENGTH of the vector\n    //    from the pixel to the center\n    // vec2 toCenter = vec2(0.5)-st;\n    // pct = length(toCenter);\n\n    // c. The SQUARE ROOT of the vector\n    //    from the pixel to the center\n    // vec2 tC = vec2(0.5)-st;\n    // pct = sqrt(tC.x*tC.x+tC.y*tC.y);\n\n    color = vec3(pct*color);\n    // Output to screen\n    fragColor = vec4(color,1.0);\n}\n\n\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttGcDz.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 131, 188, 188, 1436]]}
{"id": "ttGcRK", "name": "[TWITCH] Constructivist dream", "author": "Flopine", "description": "Shader inspired by constructivism art movement and made during a Twitch stream, you can watch all of them here: https://www.twitch.tv/flopine", "tags": ["raymarching", "abstract", "constructivism", "live", "geometric", "twitch"], "likes": 6, "viewed": 157, "published": "Public", "date": "1611316579", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Code by Flopine\n\n// Thanks to wsmind, leon, XT95, lsdlive, lamogui, \n// Coyhot, Alkama,YX, NuSan and slerpy for teaching me\n\n// Thanks LJ for giving me the spark :3\n\n// Thanks to the Cookie Collective, which build a cozy and safe environment for me \n// and other to sprout :)  https://twitter.com/CookieDemoparty\n\n\n#define PI acos(-1.)\n#define TAU 6.283185\n\n#define mo(p,d)p=abs(p)-d;if(p.y>p.x)p=p.yx\n#define rot(a) mat2(cos(a),sin(a),-sin(a),cos(a))\n#define crep(p,c,l) p=(p-c*clamp(round(p/c),-l,l))\n#define hash11(x) fract(sin(x)*146.4)\n\n#define dt(speed) fract(iTime*speed)\n\n// taken from YX here : https://www.shadertoy.com/view/tdlXW4\n// rough shadertoy approximation of the bonzomatic noise texture\nvec4 texNoise(vec2 uv)\n{\n    float f = 0.;\n    f += texture(iChannel0, uv*.125).r*.5;\n    f += texture(iChannel0, uv*.25).r*.25;\n    f += texture(iChannel0, uv*.5).r*.125;\n    f += texture(iChannel0, uv*1.).r*.125;\n    f=pow(f,1.2);\n    return vec4(f*.45+.05);\n}\n\nfloat stmin (float a, float b, float k, float n)\n{\n  float st = k/n;\n  float u = b-k;\n  return min(min(a,b),0.5*(u+a+abs(mod(u-a+st,2.*st)-st)));\n}\n\nvoid moda (inout vec2 p, float rep)\n{\n  float per = (2.*PI)/rep;\n  float a = mod(atan(p.y,p.x),per)-per*0.5;\n  p = vec2(cos(a),sin(a))*length(p);\n}\n\nfloat box (vec3 p, vec3 c)\n{\n  vec3 q = abs(p)-c;\n  return min(0.,max(q.x,max(q.y,q.z)))+length(max(q,0.));\n}\n\nfloat cyl(vec3 p, float r, float h)\n{return max(length(p.xy)-r,abs(p.z)-h);}\n\nfloat torus (vec3 p, vec2 t)\n{\n  vec2 q = vec2(length(p.xz),p.y)-t.x;\n  return length(q)-t.y;\n}\n\nfloat buildings (vec3 p)\n{\n  vec3 pp = p;\n\n  mo(p.xz, vec2(10.));\n  float g = cyl(p.xzy,0.5,50.);\n  p.x -= 5.;\n  float d = min(g,box(p,vec3(5.,50.,6.5)));\n\n  p = pp;\n  p.z -= 3.5;\n  p.x = abs(p.x)-15.;\n  crep(p.x, 1.,4.);\n  d = max(d,-cyl(p.xzy,0.3,45.));\n\n  return d;\n}\n\nfloat staircase (vec3 p)\n{\n  p.xz *= rot(PI/4.);\n  float width = 3.;\n  vec3 pp = p;\n  float d = cyl(p.xzy, 0.1, 50.);\n\n  float per = 10.;\n  p.xz *= rot(PI/5.);\n  crep(p.y,per,3.);\n  moda(p.xz,5.);\n  p.x -= width;\n  d = min(d,box(p,vec3(0.25,0.25,5.)));\n\n  p =pp;\n  moda(p.xz,5.);\n  p.x -= width*0.95;\n  d = min(d,cyl(p.xzy,0.1,50.));\n\n  p = pp;\n  float sper = 1.;\n  float sid = round(p.y/sper);\n  crep(p.y,sper, 50.);\n\n  p.xz *= rot(sid*0.3); \n  p.x -= width*0.5;\n  d = min(d,box(p,vec3(width*0.6,0.15,1.)));\n\n  return d;\n}\n\nfloat staircases (vec3 p)\n{\n  p.xz *= rot(PI/4.);\n  moda(p.xz, 4.);\n  p.x -= 20.;\n  return staircase(p);\n}\n\nfloat balcony (vec3 p)\n{\n  mo(p.xz, vec2(10.));\n  float per = 8.;\n  crep(p.y,per,6.);\n  p.xz *= rot(PI/4.);\n  float d = box(p,vec3(4.,1.5,4.));\n\n  crep(p.y,per,6.);\n  p.x += 2.;\n  d = max(d,-box(p,vec3(4.,0.2,4.)));\n\n  return d;\n}\n\nfloat g1 = 0.; float gid;\nfloat gems (vec3 p)\n{\n  p.y -= 4.;\n  mo(p.xz,vec2(10.));\n  p.z += 4.;\n  gid = round(p.y/8.);\n  crep(p.y, 8.,6.);\n  float d = dot(p,normalize(sign(p)))-0.4;\n\n  g1 += 0.01/(0.01+d*d);\n\n  return d;\n}\n\nfloat SDF (vec3 p)\n{\n  float scene = stmin(balcony(p),buildings(p),0.4,2.);\n  scene = min(scene,staircases(p));\n  scene = min(scene,gems(p));\n\n  return scene;\n}\n\nvec3 getnorm (vec3 p)\n{\n  vec2 eps = vec2(0.001,0.);\n  return normalize(SDF(p)-vec3(SDF(p-eps.xyy),SDF(p-eps.yxy),SDF(p-eps.yyx)));\n}\n\nvec3 getcam (vec3 ro, vec3 ta, vec2 uv)\n{\n  vec3 f = normalize(ta-ro);\n  vec3 l = normalize(cross(vec3(0.,1.,0.),f));\n  vec3 u = normalize(cross(f,l));\n  return normalize(f+l*uv.x+u*uv.y);\n}\n\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  vec2 uv = (2.*fragCoord.xy - iResolution.xy)/iResolution.y;\n\n  vec3 ro=vec3(1.2,-6.5,-7.), rd=getcam(ro,vec3(0.),uv), p=ro, col=vec3(0.), l=normalize(vec3(1.,2.,-3.));\n\n  bool hit=false; \n\n  for(float i=0.;i<64.;i++)\n  {\n    float d = SDF(p);\n    if (d<0.001)\n    {\n      hit = true;\n      break;\n    }\n    p += d*rd*0.8;\n  }\n  float t = length(ro-p);\n\n  if (hit)\n  {\n    vec3 n = getnorm(p);\n    col = vec3(dot(n,l)*0.5+0.25);\n  }\n \n  col = mix(col,\n          vec3(0.1,0.4,0.9),\n          1.-exp(-0.0003*t*t)+texNoise(uv*0.45).x*length((p.y+3.)*0.2));\n  col += g1*hash11(gid+dt(0.03))*0.35;\n  col = pow(col,vec3(2.));\n\n  fragColor = vec4(sqrt(clamp(col,0.,1.)),1.);\n}", "image_inputs": [{"id": "4dXGzn", "previewfilepath": "/media/ap/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttGcRK.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[583, 710, 734, 734, 972], [974, 974, 1024, 1024, 1121], [1123, 1123, 1160, 1160, 1270], [1272, 1272, 1300, 1300, 1381], [1383, 1383, 1420, 1420, 1459], [1461, 1461, 1491, 1491, 1556], [1558, 1558, 1584, 1584, 1828], [1830, 1830, 1856, 1856, 2353], [2355, 2355, 2382, 2382, 2461], [2463, 2463, 2487, 2487, 2693], [2721, 2721, 2742, 2742, 2917], [2919, 2919, 2939, 2939, 3079], [3081, 3081, 3104, 3104, 3214], [3216, 3216, 3257, 3257, 3406], [3409, 3409, 3465, 3465, 4136]]}
{"id": "ttGcRt", "name": "Generalized Smoothstep", "author": "UtaUtaUtau", "description": "First public shader I suppose?\nI just wanted to see generalized smoothstep in GLSL.\n\nThe function starts to break when N is greater that 5. Most probably precision errors.", "tags": ["smoothstep"], "likes": 3, "viewed": 53, "published": "Public", "date": "1611539307", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define TAU 6.28318530717958\n#define PI TAU / 2.\n\n/*\nHeavily referenced these functions from the Wikipedia article.\nI don't really know the proof for the generalization...\nhttps://en.wikipedia.org/wiki/Smoothstep\n*/\n\nfloat nCr(float n, float r) {\n    float res = 1.;\n    for (float i = 0.; i < r; ++i) {\n        res *= (n - i) / (i + 1.);\n    }\n    return res;\n}\n\nfloat generalSmoothstep(int N, float x) {\n    x = clamp(x, 0., 1.);\n    float NN = float(N);\n    float res = 0.;\n    for (float n = 0.; n <= NN; ++n) {\n        res += nCr(-NN - 1., n) * nCr(2. * NN + 1., NN - n) * pow(x, NN + n + 1.);\n    }\n    return res;\n}\n\nfloat generalSmoothstep(float N, float x) {\n    float fracN = fract(N);\n    int pN = int(floor(N));\n    return mix(generalSmoothstep(pN, x), generalSmoothstep(pN + 1, x), fracN);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    float dx = 1.0/iResolution.y;\n    vec2 uv = 2. * (fragCoord/iResolution.xy) - 1.;\n    // Multiply x by aspect ratio, only makes sense if screen is landscape though\n    uv.x *= iResolution.x/iResolution.y;\n\n    vec3 col;\n    if (uv.x > -1. && uv.x < 1.) {\n        //background\n        col = (sin(PI * uv.x * 5.) * sin(PI * uv.y * 5.) > 0.) ? vec3(0.2) : vec3(0.25);\n        \n        //point\n        vec2 p = 0.5 * (uv + 1.);\n        \n        //function\n        float N = sin(iTime);\n        N = N * N * 5.;\n        float y = generalSmoothstep(N, p.x);\n        float dy = generalSmoothstep(N, p.x + dx) - y;\n        float di = abs(p.y - y) / sqrt(dx*dx+dy*dy);\n        col = mix(col, vec3(.93, .23, .55), smoothstep(2., 0., di));\n    }\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttGcRt.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[50, 217, 246, 246, 362], [364, 364, 405, 405, 622], [624, 624, 667, 667, 804], [806, 806, 863, 863, 1659]]}
{"id": "ttGczm", "name": "squishy noise 2", "author": "fraser", "description": "it squirms.\nhttps://cineshader.com/view/ttGczm", "tags": ["noise", "cineshader"], "likes": 5, "viewed": 2417, "published": "Public API", "date": "1610691754", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//<3d simplex noise by nikat https://www.shadertoy.com/view/XsX3zB>\nvec3 random3(vec3 c) {\n\tfloat j = 4096.0*sin(dot(c,vec3(17.0, 59.4, 15.0)));\n\tvec3 r;\n\tr.z = fract(512.0*j);\n\tj *= .125;\n\tr.x = fract(512.0*j);\n\tj *= .125;\n\tr.y = fract(512.0*j);\n\treturn r-0.5;\n}\n\n/* skew constants for 3d simplex functions */\nconst float F3 =  0.3333333;\nconst float G3 =  0.1666667;\n\n/* 3d simplex noise */\nfloat simplex3d(vec3 p) {\n\t /* 1. find current tetrahedron T and it's four vertices */\n\t /* s, s+i1, s+i2, s+1.0 - absolute skewed (integer) coordinates of T vertices */\n\t /* x, x1, x2, x3 - unskewed coordinates of p relative to each of T vertices*/\n\n\t /* calculate s and x */\n\t vec3 s = floor(p + dot(p, vec3(F3)));\n\t vec3 x = p - s + dot(s, vec3(G3));\n\n\t /* calculate i1 and i2 */\n\t vec3 e = step(vec3(0.0), x - x.yzx);\n\t vec3 i1 = e*(1.0 - e.zxy);\n\t vec3 i2 = 1.0 - e.zxy*(1.0 - e);\n\n\t /* x1, x2, x3 */\n\t vec3 x1 = x - i1 + G3;\n\t vec3 x2 = x - i2 + 2.0*G3;\n\t vec3 x3 = x - 1.0 + 3.0*G3;\n\n\t /* 2. find four surflets and store them in d */\n\t vec4 w, d;\n\n\t /* calculate surflet weights */\n\t w.x = dot(x, x);\n\t w.y = dot(x1, x1);\n\t w.z = dot(x2, x2);\n\t w.w = dot(x3, x3);\n\n\t /* w fades from 0.6 at the center of the surflet to 0.0 at the margin */\n\t w = max(0.6 - w, 0.0);\n\n\t /* calculate surflet components */\n\t d.x = dot(random3(s), x);\n\t d.y = dot(random3(s + i1), x1);\n\t d.z = dot(random3(s + i2), x2);\n\t d.w = dot(random3(s + 1.0), x3);\n\n\t /* multiply d by w^4 */\n\t w *= w;\n\t w *= w;\n\t d *= w;\n\n\t /* 3. return the sum of the four surflets */\n\t return dot(d, vec4(52.0));\n}\n//</3d simplex noise by nikat https://www.shadertoy.com/view/XsX3zB>\nfloat fbm(vec2 xy, float z, int octs){\n    float f = 1.0;\n    float a = 1.0;\n    float t = 0.0;\n    float a_bound = 0.0;\n    for(int i=0;i<octs;i++){\n        t += a*simplex3d(vec3(xy*f,z*f));\n        f *= 2.0;\n        a_bound += a;\n        a *= 0.5;\n    }\n    return t/a_bound;\n}\nfloat noise_final_comp(vec2 xy, float z){\n    float value = fbm(vec2(xy.x / 200.0+513.0, xy.y / 200.0+124.0), z, 3);\n    value = 1.0-abs(value);\n    value = value*value;\n    return value*2.0-1.0;\n}\nfloat noise_f(vec2 xy, float z){\n        float value = fbm(\n            vec2((noise_final_comp(xy,       z)*15.0+xy.x) / 100.0,\n                 (noise_final_comp(xy+300.0, z)*15.0+xy.y) / 100.0), z*1.5, 5);\n                 \n        return max(0.0, min(1.0, (value*0.5+0.5)*1.3));\n}\nfloat noise_a(vec2 xy, float z){\n        float value = fbm(\n            vec2((xy.x) / 100.0,\n                 (xy.y) / 100.0), z*1.5, 1);\n                 \n        return max(0.0, min(1.0, (value*0.5+0.5)*1.3));\n}\nfloat noise_b(vec2 xy, float z){\n        float value = fbm(\n            vec2((xy.x) / 100.0,\n                 (xy.y) / 100.0), z*1.5, 2);\n                 \n        return max(0.0, min(1.0, (value*0.5+0.5)*1.3));\n}\nvec2 noise_c(vec2 xy, float z){\n        vec2 value = \n            vec2((noise_final_comp(xy,       z)*15.0),\n                 (noise_final_comp(xy+300.0, z)*15.0));\n        value.x = max(0.0, min(1.0, (value.x*0.5+0.5)/10.0));    \n        value.y = max(0.0, min(1.0, (value.y*0.5+0.5)/10.0));    \n        return value;\n}\nfloat noise_e(vec2 xy, float z){\n        float value = fbm(\n            vec2((xy.x) / 100.0,\n                 (xy.y) / 100.0), z*1.5, 5);\n                 \n        return max(0.0, min(1.0, (value*0.5+0.5)*1.3));\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord){\n    vec2 uv = fragCoord*500.0/iResolution.x;\n\n    float pA = noise_a(uv,iTime*0.025+0.05*sin(iTime*0.2+(uv.x*0.3*(sin(iTime/30.0)-0.3)+uv.y)/265.0));\n    float pB = noise_b(uv,iTime*0.025+0.05*sin(iTime*0.2+(uv.x*0.3*(sin(iTime/30.0)-0.3)+uv.y)/265.0));\n    vec2  pC = noise_c(uv,iTime*0.025+0.05*sin(iTime*0.2+(uv.x*0.3*(sin(iTime/30.0)-0.3)+uv.y)/265.0));\n    float pE = noise_e(uv,iTime*0.025+0.05*sin(iTime*0.2+(uv.x*0.3*(sin(iTime/30.0)-0.3)+uv.y)/265.0));\n    float pF = noise_f(uv,iTime*0.025+0.05*sin(iTime*0.2+(uv.x*0.3*(sin(iTime/30.0)-0.3)+uv.y)/265.0));\n    \n    vec3 c1 = vec3(152.0,193.0,217.0)/255.0;\n    vec3 c2 = vec3(224.0,251.0,252.0)/255.0;\n    vec3 c3 = vec3(238.0,108.0,77.0)/255.0;\n    vec3 c4 = vec3(41.0,50.0,65.0)/255.0;\n    \n    \n    // Mouse code based (loosely) from iq (https://www.shadertoy.com/view/4djSDy)\n    float s = (2.0*iMouse.x-iResolution.x) / iResolution.y;\n    if( iMouse.z<0.001 ) s=1.0;\n    \n    float sAB=step((8.0  *fragCoord.x-iResolution.x) / iResolution.y-s,0.0);\n    float sBC=step((4.0  *fragCoord.x-iResolution.x) / iResolution.y-s,0.0);\n    float sCE=step((2.685*fragCoord.x-iResolution.x) / iResolution.y-s,0.0);\n    float sEF=step((2.0  *fragCoord.x-iResolution.x) / iResolution.y-s,0.0);\n    float p =pA*sAB+pB*(1.0-sAB)*sBC+pE*(1.0-sCE)*sEF+pF*(1.0-sEF);\n    vec3 col = clamp(p*1.5-0.75,0.0,1.0)*1.0*c2+(1.0-clamp(abs(p-0.5)*5.0,0.0,1.0))*c3;\n    \n    col+=(pC.x*c1+pC.y*c4)*(1.0-sBC)*sCE;\n    \n    vec2 rC = vec2(max(iResolution.x,iResolution.y),\n                   min(iResolution.x,iResolution.y));\n                   \n    fragColor = vec4(col,p*clamp(1.3-1.5*length(fragCoord-0.5*vec2(rC.x,rC.y))/rC.y,0.0,1.0));\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttGczm.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 68, 90, 90, 263], [370, 393, 418, 669, 1569], [1570, 1639, 1677, 1677, 1918], [1919, 1919, 1960, 1960, 2116], [2117, 2117, 2149, 2149, 2400], [2401, 2401, 2433, 2433, 2614], [2615, 2615, 2647, 2647, 2828], [2829, 2829, 2860, 2860, 3149], [3150, 3150, 3182, 3182, 3363], [3364, 3364, 3419, 3419, 5095]]}
{"id": "ttGczt", "name": "Logistic Mop", "author": "dagelf", "description": "Click and drag", "tags": ["chaoslogisticmap"], "likes": 4, "viewed": 71, "published": "Public", "date": "1611556419", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define n 80.\n\nvoid mainImage(out vec4 d, in vec2 p)\n{   \n    \n    float t = 1000.+iTime/30.;\n    vec2 f = vec2(sin(t)*iResolution.x,(cos(t)+.2)*iResolution.y);\n    \n    if (iMouse.x>0.) {\n      f = iMouse.xy;\n    };\n    \n    vec3 c = vec3(0.0);\n    vec2 uv = p / iResolution.xy;\n    \n    float x = -3./tan(f.y/iResolution.y*2.);\n    float a = .0;\n    for (int i = 0; i < int(n); ++i)\n    {\n        x = uv.x * (x+3.) * (20.-(f.x/iResolution.x*20.) - (x+3.));\n        \n        if (\n             x > (uv.y-.9)/.1 && x <= (uv.y + 1.0 / iResolution.y -.9)/.1\n           ) { \n             a+=1./n/0.05;\n           };\n    }\n    \n    c = vec3(a);\n    c *= vec3(cos(uv.x),cos(uv.x*uv.x),cos(uv.y));\n    \n    d = vec4(c, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttGczt.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[15, 15, 54, 54, 719]]}
{"id": "ttGyRG", "name": "sdPie3d", "author": "yasuo", "description": "sdPie3d", "tags": ["sdpie"], "likes": 3, "viewed": 180, "published": "Public API", "date": "1611198260", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// All the distance functions from:http://iquilezles.org/www/articles/distfunctions/distfunctions.htm\n// raymarching based from https://www.shadertoy.com/view/wdGGz3\n#define USE_MOUSE 1\n#define MAX_STEPS 100\n#define MAX_DIST 100.\n#define SURF_DIST .005\n#define Rot(a) mat2(cos(a),-sin(a),sin(a),cos(a))\n#define matRotateX(rad) mat3(1,0,0,0,cos(rad),-sin(rad),0,sin(rad),cos(rad))\n#define matRotateY(rad) mat3(cos(rad),0,-sin(rad),0,1,0,sin(rad),0,cos(rad))\n#define matRotateZ(rad) mat3(cos(rad),-sin(rad),0,sin(rad),cos(rad),0,0,0,1)\n\n// The calculation is based on the `sdPie` distance from the following 2d distance reference.\n// https://www.iquilezles.org/www/articles/distfunctions2d/distfunctions2d.htm\nfloat sdPie3d(vec3 p, float rad, float r, float h) {\n    p.xy = abs(p.xy);\n    vec2 c = vec2(sin(rad),cos(rad));\n    float d = max(p.y-h,length(p.xz) - r);\n    float m = length(p.xz-c*clamp(dot(p.xz,c),0.0,r)); \n    return max(d,m*sign(c.y*p.x-c.x*p.z));\n}\n\nvec4 GetDist(vec3 p) {\n    vec3 prevP = p;\n    float lt = mod(iTime*20.0,420.0);\n    if(lt>=360.0){\n        lt = 360.0-((lt-360.0)/60.0*360.0);\n    }\n    \n    float rad = radians((lt<180.0)?lt:180.0);\n    float rad2 = radians((lt>=180.0)?lt-180.0:0.0);\n    \n    float t = mod(iTime*20.0,240.0);\n    t = (t<180.0)?t:180.0-((t-180.0)/60.0*180.0);\n    float rad3 = radians(t);\n    \n    // loading demo\n    p.z+=1.6;\n    float d = sdPie3d(p,rad,1.5,0.05);\n    d = max(p.x,d);\n    p*=-1.0;\n    float d2 = sdPie3d(p,rad2,1.5,0.05);\n    d2 = (rad2 != 0.0)?max(p.x,d2):100.0;\n    d = min(d,d2);\n    d2 = sdPie3d(p,radians(180.),0.75,0.06);\n    d = max(-d2+0.01,d);\n    \n    // other demo\n    p =prevP;\n    p.z-=1.6;\n    float d3 = sdPie3d(p,rad3,1.5,0.05);\n    d2 = sdPie3d(p*matRotateY(radians(180.0))*matRotateZ(radians(90.0)),rad3,1.2,0.1);\n    d3 = min(d3,d2);\n    \n    d = min(d,d3);\n    \n    vec3 col = 0.5 + 0.5*cos(iTime+p.xyz+vec3(0,1,2));\n    vec4 res = vec4(col,d);\n        \n    vec4 model = res;\n    return model;\n}\n\nvec4 RayMarch(vec3 ro, vec3 rd) {\n    vec4 dO= vec4(0.0);\n    \n    for(int i=0; i<MAX_STEPS; i++) {\n        vec3 p = ro + rd*dO.w;\n        vec4 dS = GetDist(p);\n        dO.w += dS.w;\n        dO.xyz = dS.xyz;\n        if(dO.w>MAX_DIST || dS.w<SURF_DIST) break;\n    }\n    \n    return dO;\n}\n\nvec3 GetNormal(vec3 p) {\n    float d = GetDist(p).w;\n    vec2 e = vec2(.001, 0);\n    \n    vec3 n = d - vec3(\n        GetDist(p-e.xyy).w,\n        GetDist(p-e.yxy).w,\n        GetDist(p-e.yyx).w);\n    \n    return normalize(n);\n}\n\nvec3 R(vec2 uv, vec3 p, vec3 l, float z) {\n    vec3 f = normalize(l-p),\n        r = normalize(cross(vec3(0,1,0), f)),\n        u = cross(f,r),\n        c = p+f*z,\n        i = c + uv.x*r + uv.y*u,\n        d = normalize(i-p);\n    return d;\n}\n\nvec3 Bg(vec3 rd) {\n    float k = rd.y*0.5+0.5;\n    vec3 col = mix(vec3(.9,.8,.8),vec3(.7,.9,.5),k);\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    vec2 m = iMouse.xy/iResolution.xy;\n    \n    vec3 col = vec3(0);\n    \n    vec3 ro = vec3(0, 3, -5.5);\n    #if USE_MOUSE == 1\n    ro.yz *= Rot(-m.y*3.14+1.);\n    ro.xz *= Rot(-m.x*6.2831);\n    #else\n    ro.yz *= Rot(radians(-60.0));\n    ro.xz *= Rot(iTime*.3+1.0);\n    #endif\n    \n    vec3 rd = R(uv, ro, vec3(0,-0.3,0), 1.);\n\n    vec4 d = RayMarch(ro, rd);\n    \n    if(d.w<MAX_DIST) {\n        vec3 p = ro + rd * d.w;\n        vec3 n = GetNormal(p);\n        vec3 r = reflect(rd,n);\n        float spec = pow(max(0.0,r.y),30.);\n        float dif = dot(n,normalize(vec3(1,2,3)))*0.5+0.5;\n        col = mix(Bg(r),vec3(dif),0.5)+spec;\n    } else {\n        // background\n        col += Bg(rd);\n    }\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttGyRG.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[535, 708, 760, 760, 964], [966, 966, 988, 988, 1985], [1987, 1987, 2020, 2020, 2273], [2275, 2275, 2299, 2299, 2500], [2502, 2502, 2544, 2544, 2739], [2741, 2741, 2759, 2759, 2858], [2860, 2860, 2917, 2917, 3709]]}
{"id": "ttGyW1", "name": "assigments", "author": "azpak", "description": "stuff", "tags": ["assignmebts"], "likes": 0, "viewed": 33, "published": "Public", "date": "1610975203", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//https://www.youtube.com/watch?v=dKA5ZVALOhs&ab_channel=TheArtofCode\n\nfloat DistLine(vec3 ro, vec3 rd, vec3 p)\n    {\n        return length(cross(p-ro, rd))/length(rd);\n    }\n\n//positions and colours\nconst vec2 points[8] = vec2[8](\n    vec2(0.1, 0.2),\n    vec2(0.9, 0.8),\n    vec2(0.3, 0.3),\n    vec2(0.7, 0.5),\n    vec2(0.8, 0.3),\n    vec2(0.6, 0.6),\n    vec2(0.3, 0.1),\n    vec2(0.4, 0.5)\n);\nconst vec4 colors[8] = vec4[8](\n    vec4(0.5, 0.3, 0.9, 1.0),\n    vec4(0.2, 0.7, 0.2, 1.0),\n    vec4(0.7, 0.5, 0.1, 1.0),\n    vec4(0.8, 0.9, 0.3, 1.0),\n    vec4(0.3, 0.8, 0.7, 1.0),\n    vec4(0.4, 0.1, 0.8, 1.0),\n    vec4(0.6, 0.4, 0.4, 1.0),\n    vec4(0.9, 0.2, 0.7, 1.0)\n);\n\nconst float a[8] = float[8](0.3, 0.2, 0.1, -0.4, -0.3, 0.1, 0.05, 0.4);\nconst float b[8] = float[8](0.2, 0.8, 0.1, 0.7, -0.2, -0.5, 0.9, -0.6);\nconst float c[8] = float[8](2.0, 3.0, 6.0, 3.0, 1.0, 3.0, 1.0, 1.0 );\n\nvec2 GetPoint(in int i )\n{\n    // move the points on orbits\n    float x = points[i].x + a[i]*sin(c[i]*iTime*0.1);    \n    float y = points[i].y + b[i]*cos(c[i]*iTime*0.1); \n    return vec2(x,y);\n}\n\n//adds the bacground colours\nvec4 GetVoronoiColor( in vec2 point )\n{\n    float nearDistSq = 1e20;\n    vec4 color;\n    for ( int i = 0; i < 8; i++ )\n    {\n        vec2 diff = point-GetPoint(i);\n        float d2 = dot(diff,diff);\n        if ( d2 < nearDistSq )\n        {\n            nearDistSq = d2;\n            color = colors[i];\n        }\n    }\n    return color;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    float blur = 0.7f;\n    \n    // Output to screen\n    fragColor = GetVoronoiColor(uv);\n    \n    //workds out the shape of the circe\n    uv -= 0.5;\n    uv.x *= iResolution.x/iResolution.y;\n    //uv.y -= abs(uv.x)*0.5;\n    uv.x -= sqrt(abs(uv.y))*0.5;\n    //uv.x -= sqrt(abs(uv.y));\n    \n    vec3 ro = vec3(0, 0, -2);\n    vec3 rd = vec3(uv.x, uv.y, 0)-ro;\n    \n    float t = iTime;\n    vec3 p = vec3(sin(t), 0, 1.0+cos(t));\n    float d = DistLine(ro, rd, p);\n    \n    //adds the circle on top of the changing background\n    d = smoothstep(0.1, 0.09, d);\n    fragColor += vec4(d);\n    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttGyW1.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 71, 117, 117, 174], [176, 884, 910, 943, 1080], [1082, 1111, 1150, 1150, 1446], [1448, 1448, 1505, 1555, 2187]]}
{"id": "ttGyWG", "name": "RGB - SWIRL", "author": "aragorn38male", "description": "My first !!!", "tags": ["swirl", "rgb"], "likes": 2, "viewed": 269, "published": "Public API", "date": "1611646208", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Rubino Marc - 2021\n// https://www.youtube.com/channel/UC4QabYdHqsMLv1WiwtYRzRw\n// RGB - SWIRL\n\n#define TWO_PI 6.28318530718\n\nvec3 hsb2rgb( in vec3 c ){\n    vec3 rgb = clamp(abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),\n                             6.0)-3.0)-1.0,\n                     0.0,\n                     1.0 );\n    rgb = rgb*rgb*(3.0-2.0*rgb);\n    return c.z * mix( vec3(1.0), rgb, c.y);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord ) {\n       vec2 st = fragCoord.xy/iResolution.xy;\n    vec3 color = vec3(0.0);\n\n    vec2 toCenter = vec2(0.5)-st;\n    float angle = atan(toCenter.x,toCenter.y);\n    float radius = length(toCenter)*2.0;\n\n    color = hsb2rgb(vec3((angle/TWO_PI)+sin(iTime),radius-.7,1.0));\n\n    fragColor = vec4(color,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttGyWG.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 128, 154, 154, 387], [389, 389, 445, 445, 747]]}
{"id": "ttGyzd", "name": "Raytraced snowman", "author": "dmitrytsgn", "description": "Use mouse to move camera\n\nBare bones raytracing with no optimizations", "tags": ["raytracing", "pathtracing"], "likes": 5, "viewed": 90, "published": "Public", "date": "1611569623", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Variables you can change \n\n// the higher this number - \n// the better the quality and the worse the performance\nconst int samplesPerFrag = 10;\n// if this is too low, glass won't work. try it\nconst int maxDepth = 19;\n\n// Camera\nvec3 lookfrom = vec3(-7.5f, 5.f, 3.f);\nvec3 lookat =   vec3(0.f, 0.5f, 0.f);\nvec3 up =       vec3(0.f, 1.f, 0.f);\n\nconst float fovy = 60.f;\n\n#define USE_TIME_AS_SEED 1\n\n///////////\n\n\n\n// Math\n#define M_PI 3.1415926535897932384626433832795\n\nstruct Ray {\n    vec3 orig;\n    vec3 dir;\n};\n\nbool nearZero(vec3 v) {\n    float s = 1e-8;\n    return (abs(v.x) < s) && (abs(v.y) < s) && (abs(v.z) < s);\n}\n\nvec4 quaternionMultiply(vec4 q1, vec4 q2) {\n    vec3 v1 = q1.xyz;\n    vec3 v2 = q2.xyz;\n    \n    float w = q1.w * q2.w * dot(v1, v2);\n    \n    vec3 xyz = v1 * q2.w + v2 * q1.w + cross(v1, v2);\n    \n    return vec4(xyz, w);\n}\n\nvec3 rotate(float angle, vec3 axis, vec3 point) {\n    // point in quaternion form\n    vec4 p4 = vec4(point, 0.f);\n    float s = sin(angle / 2.f);\n    float c = cos(angle / 2.f);\n    \n    vec4 q = vec4(s * axis.x, s * axis.y, s * axis.z, c);\n    vec4 qConj = vec4(-q.xyz, c);\n    \n    return quaternionMultiply(quaternionMultiply(q, p4), qConj).xyz;\n}\n\nvoid rotateLeft(float angle, vec3 up, inout vec3 lookFrom) {\n    lookFrom = rotate(angle, up, lookFrom);\n}\n\nvoid rotateUp(float angle, inout vec3 up, inout vec3 lookFrom) {\n    vec3 axis = normalize(cross(lookFrom, up));\n    up = rotate(angle, axis, up);\n    lookFrom = rotate(angle, axis, lookFrom);\n}\n\n// 2D\n\nvec3 gradient(float start, float end, float border, vec3 colorA, vec3 colorB, float val) {\n    border = mix(start, end, border);\n    \n    float endA = start + (border - start) * 2.f;\n    float startA = end - (end - border) * 2.f;\n    \n    return\n        ((1.f - smoothstep(start, endA, val)) * step(start, val) * colorA  \n        + smoothstep(start, endA, val) * (1.f - step(end, val)) * colorB)\n        * (1.f - step(border, val))\n        \n        + ((1.f - smoothstep(startA, end, val)) * step(start, val) * colorA  \n        + smoothstep(startA, end, val) * (1.f - step(end, val)) * colorB)\n        * step(border, val);\n}\n\nvec3 gradient(float start, float end, float borderA, float borderB,\n   vec3 colorA, vec3 colorB, vec3 colorC, float val) {\n   float borderMiddle = mix(borderA, borderB, 0.5f);\n   float middle = mix(start, end, borderMiddle);\n   \n   borderA /= borderMiddle;\n   borderB = (borderB - borderMiddle) / (1.f - borderMiddle);\n   \n   return gradient(start, middle, borderA, colorA, colorB, val) +\n       gradient(middle, end, borderB, colorB, colorC, val);\n}\n\n// Presets\n\nvec3 sky(vec2 uv) {\n    vec3 color1 = vec3(0.9f, 0.9f, 0.9f);\n    vec3 color2 = vec3(0.8f, 0.97f, 1.f);\n    vec3 color3 = vec3(0.989f, 0.969f, 0.84f);\n\n    return gradient(0.f, 1.f, 0.1f + 0.1f * uv.x, 0.5f + 0.4f * uv.x,\n        color1, color2, color3, uv.y);\n}\n\n// Random\n\nint seed;\nint coordId;\n\nvoid encryptTea(inout uvec2 v)\n{\n    uint v0 = v[0], v1 = v[1], sum = 0u;\n    uint delta = 0x9E3779B9u,\n        k0 = 238450u, k1 = 89762u,\n        k2 = 10989532u, k3 = 909243993u;\n    \n    for (int i = 0; i < 5; i++) {\n        sum += delta;\n        v0 += ((v1<<4) + k0) ^ (v1 + sum) ^ ((v1>>5) + k1);\n        v1 += ((v0<<4) + k2) ^ (v0 + sum) ^ ((v0>>5) + k3);\n    }\n    v[0]=v0; v[1]=v1;\n}\n\nfloat getRandom(float co) { return fract(sin(co*(91.3458)) * 47453.5453); }\n\nvec2 getRandom() {\n  \tuvec2 v = uvec2(coordId, seed++);\n  \tencryptTea(v);\n  \treturn fract(vec2(v) / vec2(0xffffffffu));\n}\n\nvec2 getRandom(float _min, float _max) {\n    vec2 v = getRandom();\n    return vec2(_min + (_max - _min) * v.x, _min + (_max - _min) * v.y);\n}\n\nvec3 randVec(float _min, float _max) {\n    return vec3(getRandom(_min, _max), getRandom(_min, _max).x);\n}\n\nvec3 randomInUnitSphere() {\n\twhile (true) {\n\t\tvec3 p = randVec(-1.f, 1.f);\n\t\tif (length(p) >= 1.f)\n            continue;\n\t\treturn p;\n\t}\n}\n\n// Effects\n\nfloat snow(vec2 uv) {   \n    float numberOfRegions = 200.f;\n    \n    float regionSize = 1.f / numberOfRegions;\n    float index = round(gl_FragCoord.x * numberOfRegions / iResolution.x);\n\n    float r = getRandom(index);\n    vec2 center;\n    \n    center.y = mod(1. - mod(iTime / (1.5f + 5.f * r), 1.f) + r, 1.f);\n    \n    float halfWavesPerScreen = 5.f;\n    float wave = sin(center.y * M_PI * halfWavesPerScreen) \n        * regionSize * 0.5f * getRandom(index * index);\n    \n    center.x = index * regionSize + wave;\n    return smoothstep(0.004f, 0.003f, length(uv - center));   \n}\n\n// Camera\nstruct Camera {\n    vec3 u;\n    vec3 v;\n    vec3 w;\n    \n    vec3 eye;\n    vec2 fov;  \n    \n    vec3 vertical;\n    vec3 horizontal;\n};\n\nvoid initCamera(out Camera cam, vec3 lookfrom, vec3 lookat, vec3 up, float fovy) {\n    cam.eye = lookfrom;\n    \n    cam.w = normalize(lookfrom - lookat);\n    cam.u = normalize(cross(up, cam.w));\n    cam.v = cross(cam.w, cam.u);\n    \n    cam.fov.y = radians(fovy);\n    cam.fov.x = 2.f * atan(iResolution.x / iResolution.y * tan(cam.fov.y / 2.f));\n    \n    cam.horizontal = tan(cam.fov.x / 2.f) * 2.f * cam.u;\n    cam.vertical = tan(cam.fov.y / 2.f) * 2.f * cam.v;\n}\n\nRay rayThroughFrag(vec2 uvc, in Camera cam) {\n    Ray r;\n    \n    r.orig = cam.eye;\n    r.dir = normalize(cam.horizontal * uvc.x + cam.vertical * uvc.y - cam.w);\n    \n    return r;\n}\n\n// Materials\n\n#define LAMBERTIAN 0\n#define METAL 1\n#define DIELECTRIC 2\n\nstruct Material {\n    int materialId;\n    vec3 color;\n    float fuzz;\n    float indexOfRefraction;\n};\n\n// Objects\nstruct Sphere {\n    float radius;\n    vec3 center;\n    vec3 scale;\n\n    Material material;\n};\n\n\nstruct CollisionInfo {\n    float t;\n    vec3 pos;\n    vec3 normal;\n    bool frontFace;\n    \n    Material material;\n};\n\n\nvoid setFaceNormal(Ray r, vec3 outwardNormal, inout CollisionInfo info) {\n    info.frontFace = dot(normalize(r.dir), outwardNormal) < 0.f;\n    info.normal = info.frontFace ? outwardNormal : -outwardNormal;\n}\n\nbool raySphereIntersection(Ray r, Sphere s, float tolerance, out CollisionInfo info) {\n    // Scaled ray\n    Ray rayI;\n    rayI.orig = r.orig / s.scale;\n    rayI.dir = normalize(r.dir / s.scale);\n    \n    vec3 oc = rayI.orig - s.center;\n\tfloat a = dot(rayI.dir, rayI.dir);\n\tfloat halfB = dot(rayI.dir, oc);\n\tfloat c = dot(oc, oc) - s.radius * s.radius;\n\n    float d = halfB * halfB - a * c;\n    if (d < 0.f)\n        return false;\n\n    float root = (-halfB - sqrt(d)) / a; \n    \n    if (root <= tolerance) {\n        root = (-halfB + sqrt(d)) / a;\n    }\n    \n    if (root > tolerance) {\n        // scale intersection point back\n        vec3 I = rayI.orig + rayI.dir * root;\n        info.pos = I * s.scale;\n        info.t = length(info.pos - r.orig);\n        \n        info.material = s.material;\n        \n        // note: we divide by radius insted of normalizing to get hollow sphere trick\n        vec3 outNormal = ((I - s.center) / s.radius) / s.scale;\n        setFaceNormal(r, normalize(outNormal), info);\n        \n        return true;\n    }\n    \n    return false;\n}\n\n\n// Arrays\n\n#define MAX_SPHERES 15\nint spheresCount = 0;\nSphere spheres[MAX_SPHERES];\n\nbool hitWorld(Ray r, out CollisionInfo resInfo) {\n    CollisionInfo info;\n    \n    bool res = false;\n    for(int i = 0; i < spheresCount; ++i) {\n        if (raySphereIntersection(r, spheres[i], 0.005f, info)) {\n            if (!res || info.t < resInfo.t) {\n                resInfo = info;\n                res = true;\n            }\n        }\n    }\n    \n    return res;\n}\n\n// Materials\n\nfloat reflectance(float cosinus, float refIdx) {\n    float r0 = (1.f - refIdx) / (1.f + refIdx);\n    r0 = r0 * r0;\n    return r0 + (1.f - r0) * pow((1.f - cosinus), 5.f);\n}\n\nbool scatterDiffuse(out Ray r, in CollisionInfo info) {\n    r.orig = info.pos;\n    r.dir = normalize(info.normal + randomInUnitSphere());\n    if (nearZero(r.dir)) {\n        r.dir = info.normal;\n    }\n    \n    return true;\n}\n\nbool scatterMetal(inout Ray r, in CollisionInfo info) {\n    vec3 reflected = reflect(r.dir, info.normal);\n    r.orig = info.pos;\n    r.dir = normalize(reflected + randomInUnitSphere() * info.material.fuzz);\n\n    return dot(r.dir, info.normal) > 0.f;\n}\n\nbool scatterDielectric(inout Ray r, in CollisionInfo info) {\n    float ir = info.material.indexOfRefraction;\n    float refractionRatio = info.frontFace ? (1.f / ir) : ir;\n\n    vec3 unitDirection = normalize(r.dir);\n    float cosinus = min(dot(-unitDirection, info.normal), 1.f);\n    float sinus = sqrt(1.0 - cosinus * cosinus);\n\n    bool cannotRefract = refractionRatio * sinus > 1.f;\n    vec3 direction;\n\n    if (cannotRefract || reflectance(cosinus, refractionRatio) > getRandom(0.f, 1.f).x)\n        direction = reflect(unitDirection, info.normal);\n    else\n        direction = refract(unitDirection, info.normal, refractionRatio);\n\n    r.orig = info.pos;\n    r.dir = normalize(direction);\n\n    return true;\n}\n\nbool scatter(inout Ray r, in CollisionInfo info) {\n    switch (info.material.materialId) {\n        case LAMBERTIAN:\n            return scatterDiffuse(r, info);\n        case METAL:\n            return scatterMetal(r, info);\n        case DIELECTRIC:\n            return scatterDielectric(r, info);\n    }\n}\n\nvec3 randomRayColor(vec2 uv, in Camera cam) {\n    vec2 coord = getRandom() / iResolution.xy + uv - vec2(0.5f);\n    Ray r = rayThroughFrag(coord, cam);\n    \n    int depth = maxDepth;\n    \n    vec3 color = vec3(1.f);\n    \n    Ray currentR = r;\n    \n    CollisionInfo info;\n    while(true) {\n        if (depth-- == 0) {\n            // can't find the light!\n            color = vec3(0.f);\n            break;\n        }\n        \n        if (hitWorld(currentR, info)) {\n            if (scatter(currentR, info)) {\n                color *= info.material.color;\n            } else {\n                // the surface absorbed the ray!\n                color = vec3(0.f);\n                break;\n            }\n        } else {\n            // found the light!\n            color *= sky(uv);\n\n            break;\n        }\n    }\n    \n    return color;\n}\n\nSphere insideGlassBall;    \nSphere snowPile;\nvec3 snowColor = vec3(1.f, 0.95f, 0.95f);\n\nvoid createObjects() {\n    Material snow;\n    snow.color = snowColor;\n    snow.materialId = LAMBERTIAN;\n    \n    Sphere lowerBody;\n    lowerBody.radius = 1.f;\n    lowerBody.material = snow;\n    lowerBody.scale = vec3(1.f);\n    lowerBody.center = vec3(0.f, lowerBody.radius - 1.5f, 0.f);\n    spheres[spheresCount++] = lowerBody;\n    \n    Sphere upperBody = lowerBody;\n    upperBody.radius *= 0.8f;\n    float upperY = upperBody.center.y + upperBody.radius * 1.8f;\n    upperBody.center = vec3(0.f, upperY, 0.f);\n    spheres[spheresCount++] = upperBody;\n    \n    Sphere head = upperBody;\n    head.radius *= 0.8f;\n    float headY = head.center.y + head.radius * 1.8f;\n    head.center = vec3(0.f, headY, 0.f);\n    spheres[spheresCount++] = head;\n    \n    Material carrotMat;\n    carrotMat.color = vec3(0.97f, 0.57f, 0.13f);\n    carrotMat.materialId = LAMBERTIAN;\n    \n    Sphere carrot = head;\n    carrot.center = vec3(0.f);\n    carrot.scale = vec3(1.f, 0.2f, 0.2f);\n    carrot.center.y = head.center.y / carrot.scale.y;\n    carrot.center.x -= head.radius;\n    carrot.material = carrotMat;\n    spheres[spheresCount++] = carrot;\n    \n    Material coal;\n    coal.color = vec3(0.21f, 0.27f, 0.31f);\n    coal.materialId = LAMBERTIAN;\n    \n    Sphere rightEye;\n    rightEye.radius = 0.1f;\n    rightEye.scale = vec3(1.f);\n    \n    rightEye.center = vec3(-head.radius * 0.8f,\n        head.center.y + head.radius / 2.f, -head.radius * 0.3f);\n    \n    rightEye.material = coal;\n    spheres[spheresCount++] = rightEye;\n    \n    Sphere leftEye = rightEye;\n    vec3 rightEyeCenter = rightEye.center;\n    leftEye.center = vec3(rightEyeCenter.x, rightEyeCenter.y, head.radius * 0.3f);\n    spheres[spheresCount++] = leftEye;\n    \n    Material ice;\n    ice.color = vec3(0.8f, 0.8f, 0.8f);\n    ice.materialId = METAL;\n    ice.fuzz = 0.045f;\n    \n    Sphere snowInGlass;\n    snowInGlass.radius = 2.f;\n    snowInGlass.material = snow;\n    snowInGlass.scale = vec3(1.f, 0.2f, 1.f);\n    float snowInGlassRadius = snowInGlass.radius * snowInGlass.scale.y;\n    vec3 snowInGlassCenter = lowerBody.center;\n    snowInGlassCenter.y -= (lowerBody.radius + snowInGlassRadius) / snowInGlass.scale.y;\n    snowInGlass.center = snowInGlassCenter;\n    spheres[spheresCount++] = snowInGlass; \n    float snowInGlassDiameter = snowInGlassRadius * 2.f;\n    \n    Sphere ground;\n    ground.radius = 7.f;\n    ground.material = ice;\n    ground.scale = vec3(1.f, 0.1f, 1.f);\n    float groundY = (lowerBody.center.y - lowerBody.radius - snowInGlassDiameter) \n        / ground.scale.y - ground.radius;\n    ground.center = vec3(0.f, groundY, 0.f);\n    spheres[spheresCount++] = ground;\n\n    snowPile.radius = 1.f;\n    snowPile.material = snow;\n    snowPile.scale = vec3(1.f, 9.f, 6.f);\n    snowPile.center = vec3(4.3f, 0.f, 0.f);\n    spheres[spheresCount++] = snowPile;\n    \n    Material glass;\n    glass.color = vec3(1.f);\n    glass.materialId = DIELECTRIC;\n    glass.indexOfRefraction = 1.5f;\n    \n    Sphere glassSphere;\n    glassSphere.radius = 3.1f;\n    glassSphere.material = glass;\n    glassSphere.scale = vec3(1.f);\n    glassSphere.center = vec3(0.f, glassSphere.radius - snowInGlassDiameter\n        + lowerBody.center.y - lowerBody.radius, 0.f);\n    spheres[spheresCount++] = glassSphere;\n    \n    insideGlassBall = glassSphere;\n    insideGlassBall.radius = -insideGlassBall.radius * 0.92f;\n    spheres[spheresCount++] = insideGlassBall;\n}\n\nvoid addSnow(vec2 uv, in Camera cam, inout vec3 color) {\n    vec2 coord = vec2(0.5f) / iResolution.xy + uv - vec2(0.5f);\n    Ray r = rayThroughFrag(coord, cam);\n    CollisionInfo info;\n    \n    if(raySphereIntersection(r, insideGlassBall, 0.005f, info)) {\n        CollisionInfo info2;\n        bool b = raySphereIntersection(r, snowPile, 0.005f, info2);\n        if (!b || info2.t > info.t) {\n            color = mix(color, snowColor, snow(uv));\n        }\n    }\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    createObjects();\n       \n#if USE_TIME_AS_SEED\n    seed = int(iTime * 100.f);\n#else\n    seed = 0;\n#endif\n\n    coordId = int(fragCoord.x + fragCoord.y * iResolution.x);\n    \n    vec4 mouse = iMouse / iResolution.xyxy;\n    \n    rotateLeft((mouse.x - abs(mouse.z)) * 2.f * M_PI, up, lookfrom);\n    rotateUp((mouse.y - abs(mouse.w)) * M_PI / 6.f, up, lookfrom);\n\n    Camera cam;\n    initCamera(cam, lookfrom, lookat, up, fovy);\n    \n    vec2 uv = fragCoord / iResolution.xy;\n    \n    vec3 color;\n    for(int i = 0; i < samplesPerFrag; ++i) {     \n        color += randomRayColor(uv, cam);\n    }\n    \n    color /= float(samplesPerFrag);\n\n    addSnow(uv, cam, color);\n\n    // Output to screen\n    fragColor = vec4(color,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttGyzd.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[414, 516, 539, 539, 624], [626, 626, 669, 669, 850], [852, 852, 901, 933, 1202], [1204, 1204, 1264, 1264, 1310], [1312, 1312, 1376, 1376, 1506], [1508, 1515, 1605, 1605, 2138], [2140, 2140, 2262, 2262, 2590], [2592, 2604, 2623, 2623, 2866], [2868, 2903, 2935, 2935, 3293], [3295, 3295, 3322, 3322, 3370], [3372, 3372, 3390, 3390, 3493], [3495, 3495, 3535, 3535, 3636], [3638, 3638, 3676, 3676, 3743], [3745, 3745, 3772, 3772, 3882], [3884, 3896, 3917, 3917, 4475], [4477, 4623, 4705, 4705, 5087], [5089, 5089, 5134, 5134, 5271], [5449, 5676, 5749, 5749, 5883], [5885, 5885, 5971, 5989, 6951], [6954, 7040, 7089, 7089, 7409], [7411, 7425, 7473, 7473, 7597], [7599, 7599, 7654, 7654, 7822], [7824, 7824, 7879, 7879, 8075], [8077, 8077, 8137, 8137, 8788], [8790, 8790, 8840, 8840, 9091], [9093, 9093, 9138, 9138, 9926], [10016, 10016, 10038, 10038, 13412], [13414, 13414, 13470, 13470, 13875], [13877, 13877, 13934, 13934, 14659]]}
{"id": "ttGyzG", "name": "Fbm Warp", "author": "hanker", "description": "用Fbm去扭曲图片，感觉可以模拟个水面什么的效果", "tags": ["noise", "fbm", "perlin", "warp"], "likes": 4, "viewed": 226, "published": "Public API", "date": "1611211515", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n\nfloat random(float f){\n    return fract(sin(123.567 * f) * 567.897);\n}\nvec2 random2(vec2 p){\n     p = vec2(dot(p,vec2(123.341,251.135)),dot(p,vec2(372.632,723.213)));\n    return fract(sin(p) * 31411.524313) * 2. - 1.;\n}\nfloat perlin(vec2 uv){\n    vec2 i = floor(uv);\n    vec2 f = fract(uv);\n\n    vec2 lb = random2(i);\n    vec2 rb = random2(i + vec2(1.,0.));\n    vec2 lt = random2(i + vec2(0.,1.));\n    vec2 rt = random2(i + vec2(1.,1.));\n\n    float lb_value = dot(random2(lb),f);\n    float rb_value = dot(random2(rb),f - vec2(1.,0.));\n    float lt_value = dot(random2(lt),f - vec2(0.,1.));\n    float rt_value = dot(random2(rt),f - vec2(1.,1.));\n\n    f =smoothstep(0.,1.,f);\n    float n = mix(\n            mix(lb_value,rb_value,f.x),\n            mix(lt_value,rt_value,f.x),\n        f.y);\n\n\n    return n;\n}\n#define OCTAVES 5\nfloat fbm(vec2 uv){\n    float amplitude = 1.;\n    float frequency = 1.;\n    float result = 0.;\n    for(int i = 0; i < OCTAVES; i ++){\n        result += amplitude * perlin(uv * frequency);\n        amplitude *= .5;\n        frequency *= 2.;\n    }\n    return result;\n}\nfloat toRad(float r){\n    return r * 3.1415926 / 180.;\n}\nvoid mainImage(out vec4 fragColor,in vec2 fragCoord){\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 st = uv;\n    uv.y *= iResolution.y / iResolution.x;\n    vec3 col = vec3(0.);\n\n    float rotAngle = -90.;\n    mat2 rot = mat2(\n        cos(rotAngle),-sin(rotAngle),\n        sin(rotAngle),cos(rotAngle)\n    );\n\n    vec2 p = uv * 2.;\n    float fbm_value = fbm(p + fbm(p + fbm(p) + .1 * iTime) - .1 * iTime) * .5 + .5;\n    col = vec3(fbm_value);\n\n\n   // col = mix(col,green * blue,uv.y);\n    st *= fbm_value * 2.;\n    vec4 image0 = texture(iChannel0,st);\n    st.x *= iResolution.y / iResolution.x;\n    image0 *= step(fbm_value,st.x);\n    fragColor = image0 + vec4(fbm_value) * (1. - image0.a);\n}", "image_inputs": [{"id": "XdX3Rn", "previewfilepath": "/media/ap/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttGyzG.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[2, 2, 24, 24, 72], [73, 73, 94, 94, 221], [222, 222, 244, 244, 806], [825, 825, 844, 844, 1089], [1090, 1090, 1111, 1111, 1146], [1147, 1147, 1200, 1200, 1845]]}
{"id": "ttKczG", "name": "Face - shader practice", "author": "Many", "description": "a creepy face ", "tags": ["face"], "likes": 1, "viewed": 61, "published": "Public", "date": "1611266719", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define S(a,b,t) smoothstep(a,b,t)\n#define f(w) sin(3. * w) * pow(abs(sin(w)), 6.)\n\nvec4 _MainTex_ST;\nfloat _Size;\n\nfloat N21(vec2 p){\n    p = fract(p * vec2(123.24,345.45));\n    p += dot(p,p + 34.345);\n    return fract(p.x * p.y);\n}\n\nfloat Circle(vec2 uv, vec2 p, float r, float blur){\n    float d = length(uv - p);\n    float c = S(r,r-blur,d);\n    \n    return c;\n}\n\nfloat Drop(vec2 UV, float t){\n    vec2 aspect = vec2(2,1);\n    vec2 uv = UV * 1. * aspect;\n    uv.y += t * .25;\n    vec2 gv = fract(uv) - .5;\n    vec2 id = floor(uv);\n    \n    float n = N21(id);\n    t += n * 6.2831;\n    \n    float w = UV.y * 10.;\n    float x = (n - .5) * .8;\n    x += (.4 - abs(x)) * f(w) * .45;\n    float y = -sin(t + sin(t + sin(t) * .5));\n\ty -= (gv.x - x)* (gv.x - x);\n    \n    vec2 dropPos = (gv - vec2(x ,y))/aspect;\n\tfloat drop = S(.05,.03,length(dropPos));\n\n\tvec2 trailPos = (gv - vec2(x, t * .25)) / aspect;\n\ttrailPos.y = (fract(trailPos.y * 8.) - .5) / 8.;\n\tfloat trail = S(.03,.01,length(trailPos));\n\tfloat fogTrail = 0.;\n\tfogTrail = S(-.05,.05,dropPos.y);\n\tfogTrail *= S(.5,y,gv.y);\n\ttrail *= fogTrail;\n\tfloat m = drop + trail;\n\n\t//if(gv.x > .48 || gv.y > .49) m = 1.0;\n\treturn m;\n}\n\nfloat Face(vec2 uv, float t) {\n\tvec2 gv = uv;\n\tfloat x = 0.;\n\tfloat y = 0.;\n\tfloat w = gv.y * 10. * sin(t);\n\tx += (.5 - abs(x)) * f(w) * .2;\n\tw = gv.x * 10. * cos(t);\n\ty += (.5 - abs(y)) * f(w) * .1;\n\t\t\t\t\n\tfloat mask = Circle(gv,vec2(x,y), .4, .05);\n\tmask -= Circle(uv, vec2(-.13 + x , .2 + y), .07, .01);\n\tmask -= Circle(uv, vec2(.13 + x, .2 + y), .07, .01);\n\n\tfloat mouth = Circle(uv, vec2(x, y), .3, .02);\n\tmouth -= Circle(uv, vec2(0. +x, 0.1 + y), .3, .02);\n\tmask -= mouth;\n\n\t//float drops = Drop(uv, t);\n\t//drops += Drop(uv * 1.45 + 8.11, t);\n\t//drops += Drop(uv * 1.08 - 5.83,t);\n\t//mask -= drops;\n\tvec2 id = floor(uv);\n\n\tfloat n = N21(id) * 6.2813;\n\tvec2 dropPos1 = vec2(x, .2+ y - .45 * fract(N21(uv) + .65 * (sin(t) * sin(t) + t)));\n\t//n = N21(id * id) * 6.2813;\n\tvec2 dropPos2 = vec2( x, .2+ y - .45 * fract(N21(uv) + .65 * (sin(t) * sin(t) + t)));\n\tfloat drop = Circle(uv,dropPos1, .5, .3); //sin(t + sin(t + sin(t) * .5)))\n\t//drop += Circle(uv, dropPos2, .4, .3);\n\t/*for (int i = 0; i < 5; i ++) {\n\t\tdrop += Circle(uv, float2(dropPos1.x + .15 * i, -.28 + y - .45 * frac(i + .65 * (sin(t) * sin(t) + t))), .03, .04);\n\t\t}\n\t*/\n\tfloat trail = 0.;\n\n\t//vec2 trailPos = vec2(dropPos1.x, dropPos1.y + frac(t * .01));\n\t//trail += Circle(uv, trailPos, .02, .01);\n\t\t\t\t\n\t\t\t\t\n\tmask += drop;\n\t//mask -= trail;\n\n\treturn mask;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    float t = mod(iTime,7200.);\n    uv -= .5;\n\n    // Time varying pixel color\n    vec3 col = vec3(0);\n    float face = Face(uv, t);\n    col += vec3(1.,0.,0.) * face;\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttKczG.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[116, 116, 134, 134, 233], [235, 235, 286, 286, 366], [368, 368, 397, 397, 1178], [1180, 1180, 1210, 1210, 2504], [2507, 2507, 2564, 2614, 2879]]}
{"id": "ttKczw", "name": "Wild Flower ", "author": "YitingLiu", "description": "animating wild flowers based on cos, atan, and sin. ", "tags": ["color", "circle", "atan", "cos", "animation", "plot", "ellipse"], "likes": 1, "viewed": 124, "published": "Public API", "date": "1610725697", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n// Exercise following the book of shader - Shapes\n// Inspiration: Author @patriciogv - 2015 - http://patriciogonzalezvivo.com\n\n// animating flower shapes \n\n\nfloat plot(vec2 st, float pct){\n  return  smoothstep( pct-0.02, pct, st.y) -\n          smoothstep( pct, pct+0.02, st.y);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n  vec2 st = fragCoord.xy/iResolution.xy;\n    vec3 color = vec3(0.0);\n\n    vec2 pos = vec2(0.5)-st;\n    float pct = plot(st,0.25);\n\n    float r = length(pos)*5.0-pct;\n    float a = atan(pos.y,pos.x); \n    float f = cos(a*abs(sin(iTime))*10.);\n    // f = abs(cos(a*3.));\n    // f = abs(cos(a*2.5))*.5+.3;\n    f = abs(cos(a*10.*abs(cos(iTime)))*sin(a*abs(cos(iTime))*5.0))*0.8+.1;\n    //f = smoothstep(-.5,1., cos(a*20.))*0.2+0.5;\n\n    color = vec3( 1.-smoothstep(f,f+0.2*cos(iTime),r) );\n\n    fragColor = vec4(color, 1.0);\n}\n\n\n\n\n\n  \n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttKczw.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[128, 158, 189, 189, 280], [282, 282, 339, 339, 863]]}
{"id": "ttKyDw", "name": "Electronic tower", "author": "butadiene", "description": "shader livecoding(1hour)", "tags": ["raymarching", "livecoding"], "likes": 2, "viewed": 172, "published": "Public API", "date": "1611157803", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\nfloat PI = acos(-1.);\n\nmat2 rot(float r){\n  return mat2(cos(r),sin(r),-sin(r),cos(r));\n}\n\nfloat cube(vec3 p,vec3 s){\n  vec3 q = abs(p);\n  vec3 m = max(s-q,0.0);\n  return length(max(q-s,0.))-min(min(m.x,m.y),m.z);\n}\n\nfloat loncylin(vec3 p,float s){\n  return length(p.xy)-s;\n}\n\nvec2 pmod(vec2 p,float n){\n  float np = 2.0*PI/n;\n  float r = atan(p.x,p.y)-0.5*np;\n  r = mod(r,np)-0.5*np;\n  return length(p)*vec2(cos(r),sin(r));\n}\n\nvec4 dist(vec3 p){\n  \n  p.zy *= rot(0.5*PI);\n  \n  float ke = 1.5;\n  \n  float cs = 0.1/abs(mod(p.z+iTime,ke)-0.5*ke);\n  \n  \n  vec3 sp = p;\n  \n  sp.xy *= rot(p.z*10.3+0.8*iTime);\n  \n  sp.xy = pmod(sp.xy,12.);\n  \n  sp.x -= 0.02;\n  \n  float d5 = loncylin(sp,0.0001);\n  \n  p.z += 0.1*iTime;\n  \n  p.xy = pmod(p.xy,7.);\n\n  float k = 0.6;\n  \n  vec3 ssp = p;\n  p = mod(p,k)-0.5*k;\n  float d= cube(p,vec3(0.1));\n  float d1 = cube(p,vec3(0.03,0.03,10.));\n  float d2 = cube(p,vec3(0.03,10.,0.03));\n  float d3 = cube(p,vec3(10.,0.03,0.03));\n  d = min(d,d3);\n  d = min(d,d1);\n  d = min(d,d2);\n  \n  vec3 sssp = ssp;\n  \n  ssp.xy *= rot(0.25*PI);\n  sssp.xz *= rot(0.25*PI);\n  \n  ssp = mod(ssp,k)-0.5*k;\n  \n  sssp = mod(sssp,k)-0.5*k;\n \n  float d7 = cube(ssp,vec3(10.,0.03,0.03));\n   float d8 = cube(sssp,vec3(10.,0.03,0.03));\n  d = min(d,d7);\n  d = min(d,d8);\n  vec3 col = exp(-3.0*d)*(vec3(0.2,0.2,1.0)+0.8*cs*vec3(0.1,0.6,0.2));\n  if(d>d5) col = 0.03*vec3(0.5,0.5,0.1)/max(d5,0.01);\n  d = min(d,d5);\n  \n  return vec4(col,d);\n}\n\nvec3 getNormal(vec3 p){\n  vec2 e = vec2(0.0001,0.);\n  return normalize(vec3(\n    dist(p+e.xyy).w-dist(p-e.xyy).w,\n    dist(p+e.yxy).w-dist(p-e.yxy).w,\n    dist(p+e.yyx).w-dist(p-e.yyx).w\n    ));\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n\n    vec2 r=iResolution.xy,p=(fragCoord.xy*2.-r)/min(r.x,r.y);\n\nfloat d,t=0.0;\n\n\nfloat ra = 0.2;\nfloat krt = iTime*0.4;\nvec3 ro = vec3(ra*cos(krt),0.0,ra*sin(krt));\n\nvec3 ta = vec3(0.0,0.1,0.0);\n\nvec3 cdir = normalize(ta-ro);\nvec3 side = cross(cdir,vec3(0,1,0));\nvec3 up = cross(side,cdir);\n\nvec3 rd = normalize(p.x*side+p.y*up+cdir*1.0);\n\nvec4 tsd;\n\nvec3 ac = vec3(0.0);\nfor(int i = 0;i<86;i++){\n  tsd = dist(ro+rd*t);\n  d = 0.7*tsd.w;\n  t += d;\n  ac += tsd.xyz;\n  if(d<0.001)break;\n}\n\nvec3 ac2 = vec3(0.0);\nif(d<0.001){\n  vec3 ps = ro+rd*t;\n  vec3 normal = getNormal(ps);\n  rd = reflect(rd,normal);\n  t = 0.04;\n  \n  ro =ps;\n  for(int i = 0;i<46;i++){\n    tsd = dist(ro+rd*t);\n    d = tsd.w;\n    t += d;\n    ac2 += tsd.xyz;\n    if(d<0.001)break;\n  }\n\n}\n\n\nvec3 col = vec3(0.5)*ac*0.1+normalize(ac)*vec3(1.3)*ac2*0.1;\ncol *= 0.7;\n\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttKyDw.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[24, 24, 42, 42, 89], [91, 91, 117, 117, 215], [217, 217, 248, 248, 275], [277, 277, 303, 303, 426], [428, 428, 446, 446, 1439], [1441, 1441, 1464, 1464, 1637], [1640, 1640, 1697, 1697, 2565]]}
{"id": "ttKyRW", "name": "Gradient noise sample", "author": "tomoe", "description": "sample code for a lecture\nL: 2D, R: 3D (position + time)", "tags": ["bd202101"], "likes": 2, "viewed": 57, "published": "Public", "date": "1610614045", "time_retrieved": "2021-10-01T00:00:00", "image_code": "uvec3 k = uvec3(0x456789abu, 0x6789ab45u, 0x89ab4567u);\nconst uint max32 = 0xffffffffu;\nuvec2 hash22u(uvec2 n) {\n    n ^= (n.yx << 24);\n    n ^= (n.yx >> 1);\n    n *= k.xy;\n    n ^= (n.yx << 1);\n    return n * k.xy;\n}\nvec2 hash22(vec2 p) {\n    uvec2 n = uvec2(p);\n    vec2 v = vec2(hash22u(n)) / vec2(max32);\n    return normalize(2.0 * v - vec2(1.0));\n}\nuvec3 hash33u(uvec3 n) {\n    n ^= (n.yzx << 24);\n    n ^= (n.yzx >> 1);\n    n *= k;\n    n ^= (n.yzx << 1);\n    return n * k;\n}\nvec3 hash33(vec3 p) {\n        uvec3 n = uvec3(p);\n        vec3 v = vec3(hash33u(n)) / vec3(max32);\n        return normalize(2.0 * v - vec3(1.0));\n}\nfloat gnoise21(vec2 p) {\n    vec2 i = floor(p);\n    vec2 g00 = hash22(i);\n    vec2 g01 = hash22(i + vec2(0.0, 1.0));\n    vec2 g10 = hash22(i + vec2(1.0, 0.0));\n    vec2 g11 = hash22(i + vec2(1.0, 1.0));\n    vec2 f = fract(p);\n    float v00 = dot(g00, f);\n    float v01 = dot(g01, f - vec2(0.0, 1.0));\n    float v10 = dot(g10, f - vec2(1.0, 0.0));\n    float v11 = dot(g11, f - vec2(1.0, 1.0));\n    f = f * f * f * (10.0 - 15.0 * f + 6.0 * f * f);\n    float v = mix(mix(v00, v10, f.x), mix(v01, v11, f.x), f.y);\n    return 0.5 * v + 0.5;\n}\nfloat gnoise31(vec3 p) {\n    vec3 i= floor(p);\n    vec3 g000 = hash33(i);\n    vec3 g001 = hash33(i + vec3(0.0, 0.0, 1.0));\n    vec3 g010 = hash33(i + vec3(0.0, 1.0, 0.0));\n    vec3 g011 = hash33(i + vec3(0.0, 1.0, 1.0));\n    vec3 g100 = hash33(i + vec3(1.0, 0.0, 0.0));\n    vec3 g101 = hash33(i + vec3(1.0, 0.0, 1.0));\n    vec3 g110 = hash33(i + vec3(1.0, 1.0, 0.0));\n    vec3 g111 = hash33(i + vec3(1.0, 1.0, 1.0));\n    vec3 f = fract(p);\n    float v000 = dot(g000, f);\n    float v001 = dot(g001, f - vec3(0.0, 0.0, 1.0));\n    float v010 = dot(g010, f - vec3(0.0, 1.0, 0.0));\n    float v011 = dot(g011, f - vec3(0.0, 1.0, 1.0));\n    float v100 = dot(g100, f - vec3(1.0, 0.0, 0.0));\n    float v101 = dot(g101, f - vec3(1.0, 0.0, 1.0));\n    float v110 = dot(g110, f - vec3(1.0, 1.0, 0.0));\n    float v111 = dot(g111, f - vec3(1.0, 1.0, 1.0));\n    f = f * f * f * (10.0 - 15.0 * f + 6.0 * f * f);\n    float xy0 = mix(mix(v000, v100, f.x), mix(v010, v110, f.x), f.y);\n    float xy1 = mix(mix(v001, v101, f.x), mix(v011, v111, f.x), f.y);\n    return 0.5 * mix(xy0, xy1, f.z) + 0.5;\n}\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord ){\n    vec2 pos = fragCoord.xy/min(iResolution.x, iResolution.y);\n    pos *= 12.;\n    pos += iTime;\n    float v;\n    if (fragCoord.x < 0.5 * iResolution.x){ //left\n        v = gnoise21(pos);\n    } else{ //right\n        v = gnoise31(vec3(pos, iTime));\n    }\n    fragColor = vec4(vec3(v), 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttKyRW.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[88, 88, 112, 112, 217], [218, 218, 239, 239, 353], [354, 354, 378, 378, 480], [481, 481, 502, 502, 628], [629, 629, 653, 653, 1166], [1167, 1167, 1191, 1191, 2246], [2247, 2247, 2302, 2302, 2594]]}
{"id": "ttKyzD", "name": "Basic raymarcher example", "author": "seven_dc", "description": "simple raymarching example usend in demonstrations. It is using only distance to render the scene. Using limiting the MAX_STEPS to get blur effect.", "tags": ["raymarch", "blur", "ball"], "likes": 0, "viewed": 50, "published": "Public", "date": "1610713713", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define MAX_STEPS 50\n#define MAX_DIST 50.\n#define SURF_DIST .01\n\n\nfloat GetDistance(vec3 point) {\n\tvec4 sphere = vec4(0, 0, 5, sin(iTime)+2.);\n    \n    float sphereDist = length(point-sphere.xyz)-sphere.w;    \n    float planeDist = point.y;\n    \n    float d = min(sphereDist, planeDist);\n    return d;\n}\n\nfloat RayMarch(vec3 rayOrgin, vec3 rayDirection) {\n\tfloat distance=0.;\n    \n    int steps = MAX_STEPS; \n    \n    for(int i=0; i<steps; i++) {\n    \tvec3 point = rayOrgin + rayDirection * distance;\n        float surfaceDistance = GetDistance(point);\n        distance += surfaceDistance;\n        // Stop marching if we go too far or we are close enough of surface\n        if(distance>MAX_DIST || surfaceDistance<SURF_DIST) break;\n    }\n    \n    return distance;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // put 0,0 in the center\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n       \n    // camera   \n    vec3 rayOrgin = vec3(0, 1, 0);\n    vec3 rayDirection = normalize(vec3(uv.x, uv.y, 1));\n\n    float d = RayMarch(rayOrgin, rayDirection);   \n    \n    vec3 npoint = rayOrgin + rayDirection * d;\n    \n    \n    // color\n    vec3 col = vec3(d/20.);            \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttKyzD.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[66, 66, 97, 97, 303], [305, 305, 355, 355, 765], [767, 767, 824, 853, 1228]]}
{"id": "ttlyDf", "name": "Simple Flames", "author": "adamosen", "description": "a fire using simple perlin noise", "tags": ["fire"], "likes": 8, "viewed": 230, "published": "Public API", "date": "1611141298", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float hash(vec2 p)  \n{\n    p  = 50.0*fract( p*0.3183099 + vec2(0.71,0.113));\n    return -1.0+2.0*fract( p.x*p.y*(p.x+p.y) );\n}\n\nfloat noise( in vec2 p )\n{\n    vec2 i = floor( p );\n    vec2 f = fract( p );\n\t\n\tvec2 u = f*f*(3.0-2.0*f);\n\n    return mix( mix( hash( i + vec2(0.0,0.0) ), \n                     hash( i + vec2(1.0,0.0) ), u.x),\n                mix( hash( i + vec2(0.0,1.0) ), \n                     hash( i + vec2(1.0,1.0) ), u.x), u.y);\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = vec2 (fragCoord.x-iResolution.x*0.5,fragCoord.y*0.5);\n    \n    vec2 uvBot = uv/335.5;\n\n    uvBot.x *= 0.4;\n    float noise1 = smoothstep(0.,5.,noise(vec2(uv.x*1.20,uv.y-iTime*555.)/66.));\n    float noise2 =  smoothstep(-1.5,2.2,noise(vec2(uv.x*0.9-300.,uv.y-iTime*222.)/33.))*2.;\n    float noise3 =  smoothstep(0.,1.6,noise(vec2(uv.x*0.7+100.,uv.y-iTime*150.)/55.))*2.;    \n    float noise4 = smoothstep(-0.4,1.,noise(vec2(uv.x*0.5+50.,uv.y-iTime*240.)/55.));\n    float noise5 =  smoothstep(0.,0.8,noise(vec2(uv.x*1.6+50.,uv.y-iTime*222.)/99.));\n    float noise6 =  smoothstep(0.,1.4,noise(vec2(uv.x+200.,uv.y-iTime*333.)/300.))*4.;\n    \n    \n    \n    float fieryNoise1 = ((noise1 + noise2 + noise3+ noise4 + noise5 + noise6 )/44.);\n    \n    float fieryNoise2 = ((noise1 + noise2 + noise3+ noise4 + noise5 + noise6 )/44.);\n    \n    vec2 uvDistort1 = uvBot + (fieryNoise1)*3.72;\n    vec2 uvDistort2 = uvBot + (fieryNoise2)*6.72;\n    \n    float mask1 = smoothstep(0.2,0.72,1.- smoothstep(0.0,1.,uvDistort1.y));  \n    float mask2 = smoothstep(0.44,0.66,1.- smoothstep(0.0,1.,uvDistort2.y));  \n    \n    float mask3 = mask1-mask2;\n    float mask4 = 1.-(mask3+mask2);     \n    \n    vec3 colorBot = vec3(0.88,0.44,0.1);\n    vec3 colorMid = vec3(.66,0.14,0.14);\n    \n\t//vec3 top = (1.-clamp(mask1,0.,1.))*colorTop;   \n    \n    vec3 color1 = (mix(colorBot,colorMid, mask3)- mask4) +mask2*0.9;\n    \n\n    // Output to screen\n    fragColor = vec4(color1,1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttlyDf.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 22, 22, 126], [128, 128, 154, 154, 448], [452, 452, 509, 559, 2022]]}
{"id": "tttcDs", "name": "Ray Tracing in One Weekend 2", "author": "Davigo", "description": "I tried to translate the c++ code of the book into glsl and that's the result. It is better to pause the execution so as not to overload the computer.", "tags": ["raytracing"], "likes": 2, "viewed": 156, "published": "Public", "date": "1610283387", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float MAXFLOAT = 1000.;\nfloat DEPTH = 10.;\nfloat PI = 3.14159265359;\n\n//Lambertian class\nstruct lambertian {\n    vec3 albedo;\n};\n\n//Metal class\nstruct metal {\n    vec3 albedo;\n    float fuzz;\n};\n\n//Dielectric class\nstruct dielectric {\n    float ref_idx;\n};\n\n//Material class\nstruct material {\n    lambertian l;\n    metal m;\n    dielectric d;\n    float num_m;    \n};\n\n//Ray class\nstruct ray {\n    vec3 origin;\n    vec3 direction;\n};\n\n//Sphere class\nstruct sphere {\n    vec3 center;\n    float radius;\n    material mat;\n};\n\n//Hitable list class\nstruct hitable_list {\n    sphere list[8];\n    int list_size;\n};\n\n//Camera class\nstruct camera {\n    vec3 origin;\n    vec3 lower_left_corner;\n    vec3 horizontal;\n    vec3 vertical;\n    vec3 u, v, w;\n    float lens_radius;\n};\n\nstruct hit_record {\n    float t;\n    vec3 p;\n    vec3 normal;\n    material mat;\n};\n\nvec3 unit_vector(vec3 v) {\n    return v/length(v);\n}\n\nfloat rand(vec2 co){\n    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\n//Ray functions\nvec3 point_at_parameter(ray r, float t) {\n    return r.origin + t*r.direction;\n}\n\n//Sphere function\nbool hit(sphere s, ray r, float t_min, float t_max, inout hit_record rec) {\n    vec3 oc = r.origin - s.center;\n    float a = dot(r.direction, r.direction);\n    float half_b = dot(r.direction, oc);\n    float c = dot(oc, oc) - s.radius*s.radius;\n    float discriminant = half_b*half_b - a*c;\n    if (discriminant > 0.) {\n        float temp = (-half_b - sqrt(discriminant))/a;\n        if (temp < t_max && temp > t_min) {\n            rec.t = temp;\n            rec.p = point_at_parameter(r, rec.t);\n            rec.normal = (rec.p - s.center) / s.radius;\n            rec.mat = s.mat;\n            return true;\n        }\n        temp = (-half_b + sqrt(discriminant))/a;\n        if (temp < t_max && temp > t_min) {\n            rec.t = temp;\n            rec.p = point_at_parameter(r, rec.t);\n            rec.normal = (rec.p - s.center) / s.radius;\n            rec.mat = s.mat;\n            return true;\n        }\n    }\n    return false;\n}\n\n//Hitable list functions\nbool hit(hitable_list hl, ray r, float t_min, float t_max,inout hit_record rec) {\n    hit_record temp_rec;\n    bool hit_anything = false;\n    float closest_so_far = t_max;\n    for (int i = 0; i < hl.list_size; i++) {\n        if (hit(hl.list[i], r, t_min, closest_so_far, temp_rec)) {\n            hit_anything = true;\n            closest_so_far = temp_rec.t;\n            rec = temp_rec;\n        }\n    }\n    return hit_anything;\n}\n\n//Camera functions\ncamera create_camera(vec3 lookfrom, vec3 lookat, vec3 vup, float vfov, float aspect, float aperture, float focus_dist) {\n    camera cam;\n    cam.lens_radius = aperture/2.;\n    float theta = vfov*PI/180.;\n    float half_height = tan(theta/2.);\n    float half_width = aspect*half_height;\n    cam.origin = lookfrom;\n    cam.w = unit_vector(lookfrom - lookat);\n    cam.u = unit_vector(cross(vup, cam.w));\n    cam.v = cross(cam.w, cam.u);\n    cam.lower_left_corner = cam.origin - half_width*focus_dist*cam.u - half_height*focus_dist*cam.v - focus_dist*cam.w;\n    cam.horizontal = 2.*half_width*focus_dist*cam.u;\n    cam.vertical = 2.*half_height*focus_dist*cam.v;\n    \n    return cam;\n}\n\nvec3 random_in_unit_disk(vec2 uv) {\n    vec3 p;\n    float s = 0.;\n    do {\n        p = 2.0*vec3(rand(uv/iTime*(s+23.345)), rand(uv/iTime*(s+345.43)), 0.) - vec3(1., 1., 0.);\n        s++;\n    } while (dot(p, p) >= 1.);\n    return p;\n}\n\nray get_ray(camera cam, vec2 uv) {\n    vec3 rd = cam.lens_radius*random_in_unit_disk(uv);\n    vec3 offset = cam.u*rd.x + cam.v*rd.y;\n    return ray(cam.origin + offset, cam.lower_left_corner + uv.x*cam.horizontal + uv.y*cam.vertical - cam.origin - offset);\n}\n\n//Lambertian functions\nvec3 random_in_unit_sphere(vec2 uv) {\n    vec3 p;\n    float s = 0.;\n    do {\n        p = 2.0*vec3(rand(uv/iTime*(s+23.345)), rand(uv/iTime*(s+345.43)), rand(uv/iTime*(s+12345.43))) - vec3(1., 1., 1.);\n        s++;\n    } while (dot(p, p) >= 1.);\n    return p;\n}\n\nbool scatter(lambertian l, ray r, hit_record rec, inout vec3 attenuation, inout ray scattered, vec2 uv) {\n    vec3 target = rec.p + rec.normal + random_in_unit_sphere(uv);\n    scattered = ray(rec.p, target-rec.p);\n    attenuation = l.albedo;\n    return true;\n}\n\n//Metal functions\nvec3 reflect(vec3 v, vec3 n) {\n    return v - 2.*dot(v,n)*n;\n}\n\nbool scatter(metal m, ray r_in, hit_record rec, inout vec3 attenuation, inout ray scattered, vec2 uv) {\n    vec3 reflected = reflect(unit_vector(r_in.direction), rec.normal);\n    scattered = ray(rec.p, reflected + m.fuzz*random_in_unit_sphere(uv));\n    attenuation = m.albedo;\n    return (dot(scattered.direction, rec.normal) > 0.); \n}\n\n//Dielectric functions\nbool refract(vec3 v, vec3 n, float ni_over_nt, inout vec3 refracted) {\n    vec3 uv = unit_vector(v);\n    float dt = dot(uv, n);\n    float discriminant = 1. - ni_over_nt*ni_over_nt*(1.-dt*dt);\n    if (discriminant > 0.) {\n        refracted = ni_over_nt*(uv - n*dt) - n*sqrt(discriminant);\n        return true;\n    }\n    return false;\n}\n\nfloat schlick(float cosine, float ref_idx) {\n    float r0 = (1.-ref_idx) / (1.+ref_idx);\n    r0 = r0*r0;\n    return r0 + (1.-r0)*pow((1.-cosine),5.);\n}\n\nbool scatter(dielectric d, ray r_in, hit_record rec, inout vec3 attenuation, inout ray scattered, vec2 uv) {\n    vec3 outward_normal;\n    vec3 reflected = reflect(r_in.direction, rec.normal);\n    float ni_over_nt;\n    attenuation = vec3(1., 1., 1.);\n    vec3 refracted;\n    float reflect_prob;\n    float cosine;\n    if (dot(r_in.direction, rec.normal) > 0.) {\n        outward_normal = -rec.normal;\n        ni_over_nt = d.ref_idx;\n        cosine = d.ref_idx * dot(r_in.direction, rec.normal) / length(r_in.direction);\n    } else {\n        outward_normal = rec.normal;\n        ni_over_nt = 1./d.ref_idx;\n        cosine = -dot(r_in.direction, rec.normal) / length(r_in.direction);\n    }\n    if (refract(r_in.direction, outward_normal, ni_over_nt, refracted)) {\n        reflect_prob = schlick(cosine, d.ref_idx);\n    } else {\n        scattered = ray(rec.p, reflected);\n        reflect_prob = 1.;\n    }\n    if (rand(uv/iTime*(23.345)) < reflect_prob) {\n        scattered = ray(rec.p, reflected);\n    } else {\n        scattered = ray(rec.p, refracted);\n    }\n    return true;\n}\n\n//Scene function\nsphere[8] random_scene(vec2 uv) {\n    lambertian d_l = lambertian(vec3(1., 1., 1.));\n    metal d_m = metal(vec3(1., 1., 1.), 1.);\n    dielectric d_d = dielectric(1.);\n    \n    int n = 8;\n    sphere list[8];\n    list[0] = sphere(vec3(0.,-1000.,0.), 1000., material(lambertian(vec3(.5, .5, .5)), d_m, d_d, 0.));\n    int i = 1;\n    for (float a = -1.; a < 1.; a++) {\n        for (float b = -1.; b < 1.; b++) {\n            float choose_mat = rand(vec2((a+796.343)*(b+56.768)));\n            vec3 center = vec3(a+5.+0.9*rand(vec2((a+654.432)*(b+907.576))),\n                                .2,\n                                b+0.9*rand(vec2((a+653.35)*(b+654.87))));\n            if (length(center - vec3(4., .2, 0.)) > .9) {\n                if (choose_mat < .4) { //diffuse\n                    list[i++] = sphere(center, 0.2, material(lambertian(vec3(\n                                                                            rand(vec2((a+769.09)*(b+654.354)))*rand(vec2((a+86.965)*(b+7976.79))), \n                                                                            rand(vec2((a+765.758)*(b+964.345)))*rand(vec2((a+4568.554)*(b+687.234))), \n                                                                            rand(vec2((a+321.32)*(b+546.234)))*rand(vec2((a+234.123)*(b+532.134)))\n                                                                            )), \n                                                                            d_m, d_d, 0.));\n                }\n                else if (choose_mat < .8) { //metal\n                    list[i++] = sphere(center, 0.2, material(d_l, metal(vec3(\n                                                                            .5*(1. + rand(vec2((a+786.456)*(b+23.345)))), \n                                                                            .5*(1. + rand(vec2((a+321.425)*(b+166.7643)))), \n                                                                            .5*(1. + rand(vec2((a+256.345)*(b+7689.432))))\n                                                                            ), .5*rand(vec2((a+215.76)*(b+4326.76)))), \n                                                                            d_d, 1.));                \n                } else { // glass\n                    list[i++] = sphere(center, .2, material(d_l, d_m, dielectric(1.5), 2.));\n                }\n            }\n        }\n    }\n    \n    list[i++] = sphere(vec3(0.,1.,0.), 1., material(d_l, d_m, dielectric(1.5), 2.));\n    list[i++] = sphere(vec3(-4.,1.,0.), 1., material(lambertian(vec3(.4, .2, .1)), d_m, d_d, 0.));\n    list[i++] = sphere(vec3(4.,1.,0.), 1., material(d_l, metal(vec3(.7, .6, .5), 0.), d_d, 1.));\n    return list;\n}\n\nvec3 color(ray r, hitable_list world, vec2 uv) {\n    hit_record rec;\n    vec3 mult = vec3(1.);\n    ray aux_r = ray(r.origin, r.direction);\n    for (float i = 0.; i < DEPTH; i++) {\n        if (!hit(world, aux_r, 0.001, MAXFLOAT, rec)) break;\n        ray scattered;\n        vec3 attenuation;\n        if ((rec.mat.num_m == 0. && scatter(rec.mat.l, aux_r, rec, attenuation, scattered, uv)) || \n            (rec.mat.num_m == 1. && scatter(rec.mat.m, aux_r, rec, attenuation, scattered, uv)) ||\n            (rec.mat.num_m == 2. && scatter(rec.mat.d, aux_r, rec, attenuation, scattered, uv))) {\n            mult *= attenuation;\n        } else {\n            return vec3(0, 0, 0);\n        }\n        aux_r = scattered;\n    }\n    vec3 unit_direction = unit_vector(r.direction);\n    float t = .5*(unit_direction.y + 1.);\n    return mult*((1.-t)*vec3(1., 1., 1.) + t*vec3(.5, .7, 1.));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 lookfrom = vec3(13., 2., 3.);\n    vec3 lookat = vec3(0., 0., 0.);\n    float dist_to_focus = 10.;\n    float aperture =  .1;\n    camera cam = create_camera(lookfrom, lookat, vec3(0., 1., 0.), 20., iResolution.x/iResolution.y, aperture, dist_to_focus);\n\n    // Normalized pixel coordinates (from 0 to 1)\n    \n\n    \n    //sphere list[10];\n    //list[0] = sphere(vec3(0.,0.,-1.), 0.5, material(lambertian(vec3(.1, .2, .5)), d_m, d_d, 0.));\n    //list[1] = sphere(vec3(0.,-100.5,-1.), 100., material(lambertian(vec3(.8, .8, 0.)), d_m, d_d, 0.));\n    //list[2] = sphere(vec3(1.,0.,-1.), .5, material(d_l, metal(vec3(.8, .6, .2), 0.), d_d, 1.));\n    //list[3] = sphere(vec3(-1.,0.,-1.), .5, material(d_l, d_m, dielectric(1.5), 2.));\n    //list[4] = sphere(vec3(-1.,0.,-1.), -.45, material(d_l, d_m, dielectric(1.5), 2.));\n    hitable_list world = hitable_list(random_scene(fragCoord/iResolution.xy), 8);\n\n    vec2 uv;\n    vec3 col;\n    float ns = 10.;\n    for (float s = 0.; s < ns; s++) {\n        uv =  vec2(fragCoord + vec2(rand(uv/iTime*(s+23.345)), rand(uv/iTime*(s+345.43))))/iResolution.xy;\n        ray r = get_ray(cam, uv);\n        col += color(r, world, uv);\n    }\n    col /= ns;\n    col = sqrt(col);\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tttcDs.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[607, 852, 878, 878, 904], [906, 906, 926, 926, 998], [1000, 1016, 1057, 1057, 1096], [1098, 1116, 1191, 1191, 2044], [2046, 2071, 2152, 2152, 2499], [2501, 2520, 2640, 2640, 3201], [3203, 3203, 3238, 3238, 3436], [3438, 3438, 3472, 3472, 3696], [3698, 3721, 3758, 3758, 3981], [3983, 3983, 4088, 4088, 4243], [4245, 4263, 4293, 4293, 4325], [4327, 4327, 4430, 4430, 4662], [4664, 4687, 4757, 4757, 5021], [5023, 5023, 5067, 5067, 5174], [5176, 5176, 5284, 5284, 6247], [6249, 8954, 9002, 9002, 9828], [9830, 9830, 9887, 9887, 11154]]}
{"id": "tttcDX", "name": "fractal directo", "author": "jorge2017a1", "description": "fractal directo", "tags": ["fractaldirecto"], "likes": 8, "viewed": 74, "published": "Public", "date": "1610077761", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//referencia\n//http://glslsandbox.com/e#70359.0\n//modificado por jorge2017a1\n\n#define rot(a) mat2(cos(a), sin(a), -sin(a), cos(a))\n\nfloat scale;\n\n\nfloat map(vec3 p) \n{\n    vec3 pp=p;\n\tp.z -= -iTime *1.0;\n\tp.xy = abs(p.xy) - 1.0;\n\tif (p.x < p.y) p.xy = p.yx;\n\tp.z = mod(p.z, 4.0) - 2.0;\n\n\tp.x -= 3.2;\n\tp = abs(p);\n\tfloat s = 2.0;\n\t vec3 offset =p*1.5;\n    \n    float r;\n    \n\tfor (float i = 0.0; i < 5.0; i++)\n    {\n\t\tp = 1.0 - abs(p - 1.0);\n\t\t r = -7.5 * clamp(0.38 * max(1.2 / dot(p, p), 1.), 0.0, 1.0);\n\t\ts *= r;\n\t\tp *= r;\n        p += offset;\n\t}\n\ts = abs(s);\n\tscale = s;\n\tfloat a = 100.0;\n\tp -= clamp(p, -a, a);\n\treturn (length(p)) /( s);\n}\n\nvec3 GetNormal(vec3 p)\n{\n\tfloat d = map(p);\n    vec2 e = vec2(.001, 0);\n    vec3 n = d - vec3(\n        map(p-e.xyy),\n        map(p-e.yxy),\n        map(p-e.yyx));\n    return normalize(n);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = (fragCoord.xy - 0.5 * iResolution.xy) / iResolution.y;\n\tvec3 rd = normalize(vec3(uv, 1.0));\n    vec3 ro=vec3(0, 0.5, -3);\n\tvec3 p = ro;\n    scale=1.0;\n     float d;\n     \n     //vec3 light_color1 = vec3( 1.0 );\n     vec3 light_pos1= vec3(2.0, 3.0, 10.0 );\n     vec3 final;\n     float shininess=1.0;\n     \n\tfor (int i = 1; i < 100; i++) {\n\t\tfloat d = map(p);\n\t\tp += rd * d;\n\t\tif (d < 0.001) \n        {\n\t       \n            vec3 color=mix(vec3(0.85), cos(vec3(2.0, 9., 3.) + log2(scale)) * 0.5 + 0.5, 0.5) * 10.0 / float(i);\n            \n            vec3 normal=GetNormal(p);\n            vec3 v = normalize( p-ro);\n              float diff = dot(normal, light_pos1);\n    \n            vec3 vl = normalize( light_pos1 - p );\n            vec3 ref_v = reflect( v, normal );\n            float diffuse  = max( 0.0, dot( vl, normal ) );\n            float specular = max( 0.0, dot( vl, ref_v ) );\n    \n            specular = pow( specular, shininess );\n            \n            final += color * ( diffuse + specular);\n            \n\t\t\tbreak;\n\t\t}\n        \n        \n\t}\n    \n    \n    fragColor =vec4( final,1.0);\n    \n    fragColor *= 1.0 - pow(d /(100.0) , 3.5);    \n    fragColor = pow(fragColor, vec4(0.5545));  \n\n    \n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tttcDX.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 147, 167, 167, 643], [645, 645, 669, 669, 833], [835, 835, 892, 892, 2113]]}
{"id": "ttVcRt", "name": "Day 405", "author": "jeyko", "description": "potat", "tags": ["mdtmjvm"], "likes": 30, "viewed": 385, "published": "Public API", "date": "1611604734", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n#define slices 180.\n\nconst float disp = 0.4;\n\nconst float eps = 0.01;\n\nconst float width = 0.00035;\n\nfloat fun(float p, float py){\n    \n    float f = sin(p + iTime + cos(py*0.05 + sin(p))*0.7)*sin(py*0.1 + iTime*0.2);\n    \n    //f = cos(p*0.4- iTime + py)*cos(p*0.4*sin(p) + iTime)*(sin(py + iTime));\n    //f = sin(p*0.5 + sin(py))*(cos(py*0.1 + iTime));\n    \n    f *= mix(\n        smoothstep(0.,1.,abs(p + sin(py)*0.1)),\n        smoothstep(0.,1.,abs(p + sin(py*0.3 + iTime)*0.1)),\n        0.5 + sin(iTime*0.4 )*0.5\n        );\n    \n    return f*disp;\n}\n\n\n\nfloat graph(float y, float fn0, float fn1, float pixelSize){\n  return smoothstep(pixelSize ,0., \n                    abs(fn0-y)/length(vec2((fn1-fn0)/eps,1.))- width);\n}\nfloat graphNoAbs(float y, float fn0, float fn1, float pixelSize){\n  return smoothstep(pixelSize,0., \n                    -(fn0-y)/length(vec2((fn1-fn0)/eps,1.)) - width);\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - 0.5*iResolution.xy)/iResolution.y;\n    \n    vec3 col = vec3(0);\n\n    \n    float pixelSize = dFdx(uv.x)*1.25;\n    \n    for(float i = 0.; i < slices; i++ ){\n        vec2 p = uv + vec2(0.,i/slices*2. - 0.8);\n        \n        //float funIdx = p.x*4. + sin(p.y*i/slices*2. + iTime)*1.5*sin(p.x - iTime);\n        float funIdx = p.x;\n        \n        col -= graphNoAbs( p.y + 0.0, fun(funIdx,i), fun(funIdx+eps,i), pixelSize);\n        col = max(col,0.);\n        col = mix(col, vec3(1), graph( p.y, fun(funIdx,i), fun(funIdx+eps,i), pixelSize ));\n        \n    }\n    \n    \n    col = 1. - col;\n    \n    \n    col = pow(col,vec3(0.4545));\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttVcRt.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[102, 102, 131, 131, 553], [557, 557, 617, 617, 726], [727, 727, 792, 792, 899], [903, 903, 960, 960, 1647]]}
{"id": "ttVcW3", "name": "Gradient Normalization Test", "author": "oneshade", "description": "Testing gradient normalization in 3D for estimating the distance to implicit surfaces. It works\nsurprisingly well. Some of the surfaces are based off the [url=https://en.wikipedia.org/wiki/Implicit_surface]wikipedia article[/url].", "tags": ["gradient", "implicit", "distanceestimate", "normalization"], "likes": 2, "viewed": 90, "published": "Public", "date": "1611899346", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/*\nTesting gradient normalization in 3D for estimating the distance to implicit surfaces. It works\nsurprisingly well. Some of the surfaces are based off the wikipedia article:\nhttps://en.wikipedia.org/wiki/Implicit_surface\n*/\n\n// Just in case ;)\n#define EXTRA_FUDGE_FACTOR 1.0\n\n// Settings\n#define MAX_TRACE_DIST 10.0\n#define MIN_HIT_DIST 0.001\n#define GRAD_STEP 0.001\n#define GRAD_CAP 20.0\n#define MAX_STEPS 100.0\n\n// Uncomment one to see a different surface\n//#define GENUS_2\n//#define SPHERICAL_HARMONIC\n//#define CASSINI_OVAL\n//#define QUARTIC_SPHERE\n#define TANGLECUBE\n\nfloat mapSceneImplicit(in vec3 p) {\n    float c = cos(iTime), s = sin(iTime);\n    p.xz *= mat2(c, -s, s, c);\n    p.yz *= mat2(c, -s, s, c);\n\n    #ifdef GENUS_2\n    float t1 = 2.0 * p.y * (p.y * p.y - 3.0 * p.x * p.x) * (1.0 - p.z * p.z);\n    float t2 = p.x * p.x + p.y * p.y; t2 *= t2;\n    float t3 = (9.0 * p.z * p.z - 1.0) * (1.0 - p.z * p.z);\n    return max(t1 + t2 - t3, dot(p, p) - 4.0); // Theres other stuff that gets in the way\n    #endif\n\n    #ifdef SPHERICAL_HARMONIC\n    p /= 2.0;\n    const float k = 0.3153915652; // sqrt(5/π)/4\n    return dot(p, p) - pow(3.0 * k * p.y * p.y / dot(p, p) - k, 2.0);\n    #endif\n\n    #ifdef CASSINI_OVAL\n    float q1 = length(p - vec3(-1.5,  0.0,  0.0));\n    float q2 = length(p - vec3( 1.5,  0.0,  0.0));\n    float q3 = length(p - vec3( 0.0, -1.5,  0.0));\n    float q4 = length(p - vec3( 0.0,  1.5,  0.0));\n    float q5 = length(p - vec3( 0.0,  0.0, -1.5));\n    float q6 = length(p - vec3( 0.0,  0.0,  1.5));\n    return q1 * q2 * q3 * q4 * q5 * q6 - 14.0;\n    #endif\n\n    #ifdef QUARTIC_SPHERE\n    return dot(p * p, p * p) - 4.0;\n    #endif\n\n    #ifdef TANGLECUBE\n    return dot(4.0 * p * p, 4.0 * p * p) + dot(-10.0 * p, 2.0 * p) + 11.0;\n    #endif\n}\n\nfloat getGrad(in vec3 p) {\n    vec3 e = vec3(GRAD_STEP, 0.0, 0.0);\n    return length(vec3(mapSceneImplicit(p + e.xyy) - mapSceneImplicit(p - e.xyy),\n                       mapSceneImplicit(p + e.yxy) - mapSceneImplicit(p - e.yxy),\n                       mapSceneImplicit(p + e.yyx) - mapSceneImplicit(p - e.yyx))) / (2.0 * e.x);\n}\n\nfloat mapScene(in vec3 p) {\n    return mapSceneImplicit(p) / max(getGrad(p), GRAD_CAP) * EXTRA_FUDGE_FACTOR;\n}\n\nvec3 getNormal(in vec3 p) {\n    vec3 e = vec3(GRAD_STEP, 0.0, 0.0);\n    return normalize(vec3(mapSceneImplicit(p + e.xyy) - mapSceneImplicit(p - e.xyy),\n                          mapSceneImplicit(p + e.yxy) - mapSceneImplicit(p - e.yxy),\n                          mapSceneImplicit(p + e.yyx) - mapSceneImplicit(p - e.yyx)));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n    fragColor = vec4(0.0, 0.0, 0.0, 1.0);\n\n    vec3 ro = vec3(0.0, 0.0, 5.0);\n    vec3 rd = normalize(vec3(uv, -1.0));\n\n    float t = 0.0;\n    for (float iters=0.0; iters < MAX_STEPS; iters++) {\n        vec3 p = ro + rd * t;\n        float d = mapScene(p);\n        if (d < MIN_HIT_DIST) {\n            vec3 n = getNormal(p);\n            vec3 l = vec3(-0.58, 0.58, 0.58);\n            fragColor.rgb += n * max(0.2, dot(n, l));\n            break;\n        }\n\n        if (t > MAX_TRACE_DIST) {\n            break;\n        }\n\n        t += d;\n    }\n\n    fragColor.rgb = pow(fragColor.rgb, vec3(0.4545));\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttVcW3.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[416, 575, 610, 610, 1771], [1773, 1773, 1799, 1799, 2103], [2105, 2105, 2132, 2132, 2215], [2217, 2217, 2244, 2244, 2543], [2545, 2545, 2600, 2600, 3262]]}
{"id": "ttVczW", "name": "Fever Dream XOR", "author": "matharoo", "description": "Fever Dream XOR yay", "tags": ["xor"], "likes": 1, "viewed": 78, "published": "Public", "date": "1610630826", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage(out vec4 color, in vec2 coord)\n{\n    coord.x += 5. * sin(iTime * 4. + coord.y / 4.);\n    coord.x -= 10. * sin(iTime * 4.);\n    vec2 s = iResolution.xy*.5*vec2(1.-(sin(iTime * 2.)/4.));\n    vec2 c = coord - s; c.y *= -1.;\n    \n    vec2 a = step(abs(c-s.y*.35), s.yy*.4);\n    vec2 b = step(abs(c+s.y*.15), s.yy*.6);\n    vec3 col = (a.xxx*a.y-.5)*(b.x*b.y-.5)*4.;\n    \n    color = vec4(col,1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttVczW.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 47, 47, 407]]}
{"id": "ttVyRc", "name": "Metal Kaleidoscope 2", "author": "mrange", "description": "Licence CC0: Metal Kaleidoscope 2\nExperimenting with truchet, FBM, smooth kaleidoscope and metal like lighting take 2", "tags": ["2d", "fbm"], "likes": 11, "viewed": 285, "published": "Public API", "date": "1611498626", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Licence CC0: Metal Kaleidoscope 2\n// Experimenting with truchet, FBM, smooth kaleidoscope and metal like lighting take 2\n\n// SABS        from: ollj (shadertoy) (SABS is a really great tool)\n// hsv2rgb     from: https://stackoverflow.com/questions/15095909/from-rgb-to-hsv-in-opengl-glsl\n// modMirror1  from: http://mercury.sexy/hg_sdf/\n// pmin        from: iq (shadertoy)\n// raySphere   from: iq (shadertoy)\n// tanh_approx from: some math site, don't remember\n// pmin        from: iq (shadertoy)\n\n// fbm described by iq here: https://www.iquilezles.org/www/articles/fbm/fbm.htm\n\n#define PI              3.141592654\n#define TAU             (2.0*PI)\n#define TIME            iTime\n#define RESOLUTION      iResolution\n#define PSIN(x)         (0.5+0.5*sin(x))\n#define LESS(a,b,c)     mix(a,b,step(0.,c))\n#define SABS(x,k)       LESS((.5/(k))*(x)*(x)+(k)*.5,abs(x),abs(x)-(k))\n#define ROT(a)          mat2(cos(a), sin(a), -sin(a), cos(a))\n#define L2(x)           dot(x, x)\n\n#define PERIOD          30.0\n#define NPERIOD         floor(TIME/PERIOD)\n#define TIMEINPERIOD    mod(TIME, PERIOD)\n#define FADE            1.0\n#define HPERIOD         hash(NPERIOD)\n\nconst float  truchet_lw = 0.05;\nconst mat2[] truchet_rots = mat2[](ROT(0.0*PI/2.0), ROT(1.00*PI/2.0), ROT(2.0*PI/2.0), ROT(3.0*PI/2.0));\n\nvec3 hsv2rgb(vec3 c) {\n  const vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n  vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n  return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nfloat tanh_approx(float x) {\n//  return tanh(x);\n  float x2 = x*x;\n  return clamp(x*(27.0 + x2)/(27.0+9.0*x2), -1.0, 1.0);\n}\n\nfloat hex(vec2 p, float r) {\n  const vec3 k = vec3(-sqrt(3.0)/2.0,1.0/2.0,sqrt(3.0)/3.0);\n  p = p.yx;\n  p = abs(p);\n  p -= 2.0*min(dot(k.xy,p),0.0)*k.xy;\n  p -= vec2(clamp(p.x, -k.z*r, k.z*r), r);\n  return length(p)*sign(p.y);\n}\n\nfloat circle(vec2 p, float r) {\n  return length(p) - r;\n}\n\nfloat hash(float co) {\n  co += 100.0;\n  return fract(sin(co*12.9898) * 13758.5453);\n}\n\nfloat hash(vec3 co) {\n  co += 100.0;\n  return fract(sin(dot(co, vec3(12.9898,58.233, 12.9898+58.233))) * 13758.5453);\n}\n\nvec2 toPolar(vec2 p) {\n  return vec2(length(p), atan(p.y, p.x));\n}\n\nvec2 toRect(vec2 p) {\n  return vec2(p.x*cos(p.y), p.x*sin(p.y));\n}\n\nvec2 mod2_1(inout vec2 p) {\n  vec2 c = floor(p + 0.5);\n  p = fract(p + 0.5) - 0.5;\n  return c;\n}\n\nfloat modMirror1(inout float p, float size) {\n  float halfsize = size*0.5;\n  float c = floor((p + halfsize)/size);\n  p = mod(p + halfsize,size) - halfsize;\n  p *= mod(c, 2.0)*2.0 - 1.0;\n  return c;\n}\n\nfloat smoothKaleidoscope(inout vec2 p, float sm, float rep) {\n  vec2 hp = p;\n\n  vec2 hpp = toPolar(hp);\n  const float ts = 2.5;\n  hpp.x = tanh_approx(hpp.x/ts)*ts;\n  float rn = modMirror1(hpp.y, TAU/rep);\n\n  float sa = PI/rep - SABS(PI/rep - abs(hpp.y), sm);\n  hpp.y = sign(hpp.y)*(sa);\n\n  hp = toRect(hpp);\n\n  p = hp;\n\n  return rn;\n}\n\nfloat pmin(float a, float b, float k) {\n  float h = clamp(0.5+0.5*(b-a)/k, 0.0, 1.0);\n  return mix(b, a, h) - k*h*(1.0-h);\n}\n\nfloat pmax(float a, float b, float k) {\n  return -pmin(-a, -b, k);\n}\n\nfloat truchet_cell0(vec2 p) {\n  float d0  = circle(p-vec2(0.5), 0.5);\n  float d1  = circle(p+vec2(0.5), 0.5);\n\n  float d = 1E6;\n  d = min(d, d0);\n  d = min(d, d1);\n  return d;\n}\n\nfloat truchet_cell1(vec2 p) {\n  float d0  = abs(p.x);\n  float d1  = abs(p.y);\n  float d2 = circle(p, 0.25);\n\n  float d = 1E6;\n  d = min(d, d0);\n  d = min(d, d1);\n  d = min(d, d2);\n  return d;\n}\n\nvec2 truchet(vec2 p, float h, out vec3 n) {\n  float hd = circle(p, 0.4);\n\n  vec2 hp = p;\n  float rep = 2.0*floor(mix(5.0, 25.0, fract(h*13.0)));\n  float sm = mix(0.05, 0.125, fract(h*17.0))*24.0/rep;\n  float kn = 0.0;\n  kn = smoothKaleidoscope(hp, sm, rep);\n  hp *= ROT(0.02*TIME);\n  hp += TIME*0.05;\n  vec2 hn = mod2_1(hp);\n  float r = hash(vec3(hn, h));\n  hp *= truchet_rots[int(r*4.0)];\n\n  float cd0 = truchet_cell0(hp);\n  float cd1 = truchet_cell1(hp);\n  float d0 = mix(cd0, cd1, (fract(r*13.0) > 0.5));\n\n  float d = 1E6;\n  d = min(d, d0);\n  d = abs(d) - truchet_lw;\n\n  n = vec3(hn, kn);\n\n  return vec2(hd, d);\n}\n\nfloat df(vec2 p, float h, out vec3 n) {\n  vec2 d = truchet(p, h, n); \n  return d.y;\n}\n\nfloat hf(vec2 p, float h) {\n  vec3 n;\n  float decay = 0.75/(1.0+0.125*L2(p));\n  float d = df(p, h, n);\n  const float ww = 0.085;\n  float height = (smoothstep(0.0, ww, d));\n  return pmax(2.0*height*decay, 0.5, 0.25);\n}\n\nfloat fbm(vec2 p, float h) {\n  const float aa = -0.45;\n  const mat2  pp = (2.03-0.0)*ROT(1.0);\n\n  float a = 1.0;\n  float d = 0.0;\n  float height = 0.0;\n  \n  for (int i = 0; i < 3; ++i) {\n    height += a*hf(p, h);\n    d += a;\n    a *= aa;\n    p *= pp;\n  }\n  \n  return height/d;\n}\n\nvec2 distortCoords(vec2 p, float h) {\n  p.x = SABS(p.x, 0.1*abs(p.y)+0.001);\n  float tp = TIMEINPERIOD/PERIOD;\n  p*=ROT(TIMEINPERIOD*0.075);\n  p*=ROT(-PI*tanh_approx(0.125*(L2(p)-0.25)));\n  \n  p*=mix(1.5, 2.5, mix(tp, 1.0-tp, h));\n  return p;\n}\nconst float exclusionRadius = 0.25;\n\nfloat distanceField(vec2 p, float h, out vec3 n) {\n  float c = circle(p, exclusionRadius);\n  p = distortCoords(p, h);\n//  return df(p, h, n);\n  return pmin(c, df(p, h, n), 0.25);\n}\n\nfloat height(vec2 p, float h) {\n  p = distortCoords(p, h);\n  return tanh_approx(fbm(p, h));\n}\n\nvec3 normal(vec2 p, float h) {\n  vec2 eps = vec2(4.0/RESOLUTION.y, 0.0);\n  \n  vec3 n;\n  \n  n.x = height(p - eps.xy, h) - height(p + eps.xy, h);\n  n.y = 2.0*eps.x;\n  n.z = height(p - eps.yx, h) - height(p + eps.yx, h);\n  \n  return normalize(n);\n}\n\nvec3 postProcess(vec3 col, vec2 q)  {\n  col=pow(clamp(col,0.0,1.0),vec3(1.0/2.2)); \n  col=col*0.6+0.4*col*col*(3.0-2.0*col);  // contrast\n  col=mix(col, vec3(dot(col, vec3(0.33))), -0.4);  // saturation\n  col*=0.5+0.5*pow(19.0*q.x*q.y*(1.0-q.x)*(1.0-q.y),0.7);  // vigneting\n  return col;\n}\n\nvec2 raySphere(vec3 ro, vec3 rd, vec4 sphere) {\n  vec3 ce = sphere.xyz;\n  float ra = sphere.w;\n  vec3 oc = ro - ce;\n  float b = dot(oc, rd);\n  float c = dot(oc, oc) - ra*ra;\n  float h = b*b - c;\n  if (h<0.0) return vec2(-1.0); // no intersection\n  h = sqrt(h);\n  return vec2(-b-h, -b+h);\n}\n\nconst vec3 up  = vec3(0.0, 1.0, 0.0);\nconst vec3 lp1 = 1.0*vec3(1.0, 1.25, 1.0);\nconst vec3 lp2 = 1.0*vec3(-1.0, 2.5, 1.0);\n\nvec4 sphereCol(vec3 ro, vec3 rd, float h) {\n  vec4 sphere = vec4(0.0, 0.0, 0.0, exclusionRadius*0.95);\n  vec2 sphereIntersect = raySphere(ro, rd, sphere);\n  if (sphereIntersect.x == -1.0) {\n    return vec4(0.0);\n  }\n\n  vec3 p = ro + rd*sphereIntersect.x;\n  vec3 n = normalize(p - sphere.xyz);\n  vec3 r = reflect(rd, n);\n\n  vec3 ld1 = normalize(lp1 - p);\n  vec3 ld2 = normalize(lp2 - p);\n  \n  float diff1 = max(dot(n, ld1), 0.0);\n  float diff2 = max(dot(n, ld2), 0.0);\n  float ref1  = max(dot(r, ld1), 0.0);\n  float ref2  = max(dot(r, ld2), 0.0);\n  \n  vec3 hsv = vec3(h+mix(0.6, 0.9, PSIN(TIME*0.1)), 0.5, 1.0);\n  \n  vec3 baseCol1 = hsv2rgb(hsv);\n  vec3 baseCol2 = sqrt(baseCol1.zyx);\n  vec3 matCol   = 1.0-baseCol1*baseCol2;\n\n  float fres = dot(-n, rd);\n  \n  vec3 col = vec3(0.0);\n  col += baseCol1*pow(diff1, 5.0);\n  col += baseCol2*pow(diff2, 2.5);\n  col *= 0.125;\n  \n  col += 0.5*baseCol1*pow(ref1, 10.0);\n  col += 0.5*baseCol2*pow(ref2, 5.0);\n  \n//  col += vec3(pow(1.0-fres, 6));\n  float t = smoothstep(0.0, 0.25, fres);\n  \n  return vec4(col, t);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  vec2 q = fragCoord/RESOLUTION.xy;\n  vec2 p = -1. + 2. * q;\n  p.x *= RESOLUTION.x/RESOLUTION.y;\n\n  float aa = 2.0/RESOLUTION.y;\n\n  float hh = HPERIOD;\n  float l  = length(p);\n  \n  float fakeNorthernLightPhase = L2(p.x)*10.0;\n  float fakeNorthernLightAmp = mix(2.0, 10.0, tanh_approx(0.25*abs(p.x)));\n  float eyeHeight = mix(10.0, mix(10.0, fakeNorthernLightAmp, sqrt(q.y)), PSIN(fakeNorthernLightPhase));\n\n  \n  vec3  dn;\n  float d  = distanceField(p, hh, dn);\n  float h  = height(p, hh);\n  vec3  n  = normal(p, hh);\n\n  vec3 ro = vec3(0.0, eyeHeight, 0.0);\n  vec3 pp = vec3(p.x, 0.0, p.y);\n\n  vec3 po = vec3(p.x, h, p.y);\n  vec3 rd = normalize(po - ro);\n  vec3 prd = normalize(pp - ro);\n  \n\n  vec3 ld1 = normalize(lp1 - po);\n  vec3 ld2 = normalize(lp2 - po);\n\n  vec3 hsv = vec3(hh+mix(0.6, 0.9, PSIN(TIME*0.1-10.0*l+(p.x+p.y))), tanh_approx(h*h*1.0), tanh_approx(1.0*h+.1));\n  hsv.yz = clamp(hsv.yz, 0.0, 1.0);\n  vec3 baseCol1 = hsv2rgb(hsv);\n  vec3 baseCol2 = sqrt(baseCol1.zyx);\n  vec3 matCol   = 1.0-baseCol1*baseCol2;\n \n  float diff1 = max(dot(n, ld1), 0.0);\n  float diff2 = max(dot(n, ld2), 0.0);\n\n  vec3  ref   = reflect(rd, n);\n  float ref1  = max(dot(ref, ld1), 0.0);\n  float ref2  = max(dot(ref, ld2), 0.0);\n\n  baseCol1 *= mix(0.0, 4.0, 1.0/L2(lp1 - po));\n  baseCol2 *= mix(0.0, 3.0, 1.0/L2(lp2 - po));\n\n  vec3 col = vec3(0.0);\n  const float basePow = 1.25;\n  col += 1.00*matCol*baseCol1*mix(0.1, 1.0, pow(diff1, 4.0))*0.5;\n  col += 0.50*matCol*baseCol2*mix(0.1, 1.0, pow(diff2, 2.0))*0.5;\n  col = pow(col, vec3(1.25));\n  col += 4.0*baseCol1*pow(ref1, 20.0);\n  col += 2.0*baseCol2*pow(ref2, 10.0);\n\n  float gd = d;\n  const float glow_lw = 0.025;\n  gd = abs(gd)-glow_lw*2.0;\n  gd = abs(gd)-glow_lw;\n  vec3 glowCol = vec3(1.0);\n  glowCol = mix(baseCol1, glowCol, max(dot(ld1, up), 0.0));\n  glowCol = mix(baseCol2, glowCol, max(dot(ld2, up), 0.0));\n  vec3 finalGlowCol = glowCol*exp(-20.0*max(gd, 0.0));\n  finalGlowCol = mix(finalGlowCol, glowCol, smoothstep(-aa, aa, -d+glow_lw));\n  \n  float tuneOut = sqrt(1.0-q.x);\n  \n  col = clamp(col, 0.0, 1.0);\n  col = mix(col, vec3(0.0), smoothstep(-aa, aa, -d));\n\n  vec4 scol = sphereCol(ro, prd, hh);\n  col = mix(col, scol.xyz, scol.w);  \n  col -= 0.5*0.125*tuneOut*finalGlowCol;\n  \n  col = postProcess(col, q);\n  \n  float fadeIn  = smoothstep(0.0, FADE, TIMEINPERIOD);\n  float fadeOut = 1.0-smoothstep(PERIOD-FADE, PERIOD, TIMEINPERIOD);\n  col = mix(vec3(0.0), col, fadeIn*fadeIn*fadeOut*fadeOut);\n  fragColor = vec4(col, 1.0);\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttVyRc.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[500, 1290, 1312, 1312, 1481], [1483, 1483, 1511, 1531, 1607], [1609, 1609, 1637, 1637, 1837], [1839, 1839, 1870, 1870, 1896], [1898, 1898, 1920, 1920, 1983], [1985, 1985, 2006, 2006, 2104], [2106, 2106, 2128, 2128, 2172], [2174, 2174, 2195, 2195, 2240], [2242, 2242, 2269, 2269, 2338], [2340, 2340, 2385, 2385, 2539], [2541, 2541, 2602, 2602, 2875], [2877, 2877, 2916, 2916, 3001], [3003, 3003, 3042, 3042, 3071], [3073, 3073, 3102, 3102, 3250], [3252, 3252, 3281, 3281, 3445], [3447, 3447, 3490, 3490, 4063], [4065, 4065, 4104, 4104, 4150], [4152, 4152, 4179, 4179, 4369], [4371, 4371, 4399, 4399, 4649], [4651, 4651, 4688, 4688, 4895], [4933, 4933, 4983, 4983, 5113], [5115, 5115, 5146, 5146, 5208], [5210, 5210, 5240, 5240, 5455], [5457, 5457, 5494, 5494, 5747], [5749, 5749, 5796, 5796, 6038], [6165, 6165, 6208, 6208, 7218], [7220, 7220, 7275, 7275, 9755]]}
{"id": "ttVyWy", "name": "Little Julia Set Fractal Thing", "author": "BRNMan", "description": "Just creates julia set fractals wherever you click", "tags": ["juliaset", "fractals", "mandlebrot"], "likes": 1, "viewed": 32, "published": "Public", "date": "1611712615", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec2 mul(vec2 a, vec2 b) {\n    return vec2(a.x*b.x-a.y*b.y, a.x*b.y+a.y*b.x);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 iMouseUV = iMouse.xy/iResolution.xy;\n\n    float x_min = -1.0;\n    float x_scale = 2.0;\n    \n    float y_min = -1.0;\n    float y_scale = 2.0;\n    \n    float time = iTime;\n   \n    vec2 C = vec2(uv.x*x_scale + x_min, uv.y*y_scale + y_min);\n    vec2 Z = C;\n    C = vec2(iMouseUV.x*x_scale + sin(time) + x_min, iMouseUV.y*y_scale + y_min);\n    \n    int i = 0;\n    int max_iter = 40;\n    while(i < max_iter && abs(Z.x) + abs(Z.y) < 2.0) {\n        Z = mul(Z,Z) + C;\n        i++;\n    }\n    \n    float gradient = float(i)*1.0/float(max_iter);\n    // Output to screen\n    fragColor = vec4(0.0, 1.0 - gradient, 1.0 - gradient ,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttVyWy.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 26, 26, 79], [82, 82, 139, 189, 862]]}
{"id": "ttVyzw", "name": "2D Caustics (GI)", "author": "darkeclipz", "description": "Testing a monte carlo rendering in 2D for global illumination with caustics.", "tags": ["2d", "reflection", "gi", "caustics"], "likes": 11, "viewed": 354, "published": "Public API", "date": "1610727721", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define R iResolution.xy\n#define AA 2.\n#define PI 3.14159265359\n#define LIGHT_SAMPLES 3.\n\nstruct material {\n    vec3 diffuse;\n    vec3 emissive;\n    bool light;\n    float intensity;\n};\n\nmaterial[] materials = material[] (\n    material(vec3(0.9), vec3(1), false, 0.),\n    material(vec3(0.4,0.4,1), vec3(.4, .4, 1), true, 2.5),\n    material(vec3(0.4,0.4,1), vec3(1,.4,.4), true, 2.5),\n    material(vec3(1), vec3(0.9), false, 0.)\n);\n\nfloat sdBox(vec2 p, vec2 b) {\n    vec2 r = abs(p) - b;\n    return min(max(r.x, r.y),0.) + length(max(r,vec2(0,0)));\n}\n\nfloat sdCircle(vec2 p, float r) {\n    return length(p) - r;\n}\n\nfloat random (in vec2 _st) {\n    return fract(sin(dot(_st.xy, vec2(12.9898,78.233))) * 43758.5453123);\n}\n\nmat2 rot(float a) {\n    float co = cos(a), si = sin(a);\n    return mat2(co, si, -si, co);\n}\n\nfloat sdArc( in vec2 p, in vec2 sca, in vec2 scb, in float ra, float rb ) {\n    p *= mat2(sca.x,sca.y,-sca.y,sca.x);\n    p.x = abs(p.x);\n    float k = (scb.y*p.x>scb.x*p.y) ? dot(p.xy,scb) : length(p.xy);\n    return sqrt( dot(p,p) + ra*ra - 2.0*ra*k ) - rb;\n}\n\nfloat sdCuttedBox(vec2 p) {\n    float d = sdBox(p, vec2(0.3)) - 0.02;\n    float c = sdCircle(abs(p) - vec2(0.28, 0.28), 0.24);\n    d = max(d, -c);\n    return d;\n}\n\nint id = 0;\nfloat lastMapValue = 0.;\nfloat map(vec2 p) {\n    id = 0;\n    float t = iTime / 20.;\n    float ljs = 0.6; // lissajous size for lights\n    \n    // Cutted box\n    float size = 1.1;\n    vec2 modp = mod(1.1*p, 1.0) - 0.5;\n    float d = sdCuttedBox(rot(PI/4.)*size*p) / size;\n    \n    // Light 1\n    float lx1 = cos(23.*t/4. + 2.) * R.x/R.y *ljs;\n    float ly1 = sin(31.*t/4.) * ljs; \n    float circle = sdCircle(p + vec2(lx1, ly1), 0.05);\n    if(circle < d) {\n        id = 1;\n    }\n    d = min(d, circle);\n    \n    // Light 2\n    float lx2 = cos(17.*t + 1.) * R.x/R.y *ljs;\n    float ly2 = sin(7.*t) * ljs;\n    float circle2 = sdCircle(p + vec2(lx2, ly2), 0.05);\n    if(circle2 < d) {\n        id = 2;\n    }\n    d = min(d, circle2);\n    \n    // Horse shoe\n    vec2 absX = p;\n    absX.x = abs(absX.x);\n    absX.x = -absX.x;\n    \n    float a = PI/2.;\n    float b = -0.6;\n    vec2 ra = vec2(cos(a), sin(a));\n    vec2 rb = vec2(cos(b), sin(b));\n    float arc = sdArc(absX - vec2(-0.5*R.x/R.y + 0.1, 0), ra, rb, 0.8, 0.05);\n    if(arc < d) {\n        id = 0;\n    }\n    d = min(d, arc);\n    \n    lastMapValue = d;\n    return d;\n}\n\nvec2 normal(vec2 p) {\n    vec2 e = vec2(0.00001, 0);\n    float x = lastMapValue;\n    return normalize(vec2(map(p+e.xy)-x,\n                          map(p+e.yx)-x));\n}\n\nfloat trace(vec2 ro, vec2 rd) {\n    float t = 0.0;\n    for(float i=0.; i<60.; i++) {\n        vec2 p = ro + t * rd;\n        float d = map(p);\n        if(d < 0.0001) {\n            break;\n        }\n        t += d;\n        if(t > 20.) {\n            break;\n        }\n    }\n    return t;\n}\n\nvec3 sampleScene(vec2 ro) {\n    vec3 fcol = vec3(0);\n    \n    for(float i=0.; i < LIGHT_SAMPLES; i++) {\n    \n        float r = (random(ro + i) + i) / LIGHT_SAMPLES * PI * 2.0;\n\n        vec2 rd = vec2(cos(r), sin(r));\n        float t = trace(ro, rd);\n        vec3 col = vec3(0.);\n        \n        if(t < 20.) {\n            vec2 p = ro + t * rd;\n            \n            if(materials[id].light) {\n                // hit a light\n                col = materials[id].emissive * materials[id].intensity;\n            }\n            else {\n                if(t < 0.0001) {\n                    // inside object (not light)\n                    col = texture(iChannel0, ro * 1.2).rrr;\n                }\n                else {\n                    // hit object; calculate reflection\n                    vec2 nor = normal(p);\n                    vec2 refl = reflect(rd, nor);\n                    int matId = id;\n                    float k = trace(p + refl * 0.001, refl);\n                    if(k < 20.) {\n                        // hit light\n                        if(materials[id].light) {\n                            col = materials[id].emissive * materials[id].intensity * materials[matId].diffuse;\n                        }\n                        else {\n                            // hit material; calculate second reflection\n                            vec2 p2 = p + refl*0.001 + k*refl;\n                            nor = normal(p2);\n                            refl = reflect(refl, nor);\n                            int matId2 = id;\n                            float j = trace(p + refl * 0.001, refl);\n                            if(k < 20. && materials[id].light) {\n                                // hit light\n                                col = materials[id].emissive * materials[id].intensity \n                                                             * materials[matId].diffuse;\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        else col = vec3(0.3); // ambient\n        fcol += col;\n    }\n    \n    return fcol / LIGHT_SAMPLES;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 fcol = vec3(0);\n    vec2 npos = (2.*fragCoord-R)/R.y;\n    float randSeed = fract(float(iTime) / 30.);\n    float stratSize = 1. / AA;\n    for(float aax = 0.; aax < AA; aax++)\n    for(float aay = 0.; aay < AA; aay++) {\n        vec2 strat = vec2(aax, aay) * stratSize;\n        vec2 jitter = vec2(random(npos + 4.1252 + aax + randSeed), \n                           random(npos + 1.3483 + aay + randSeed)) * stratSize;\n        vec2 uv = (2.*fragCoord + strat + jitter - R)/R.y;\n        vec3 col = sampleScene(uv);\n        fcol += col;\n    }\n    \n    fragColor = vec4(fcol/(AA*AA),1.0);\n}", "image_inputs": [{"id": "4sXGRn", "previewfilepath": "/media/ap/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttVyzw.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[431, 431, 460, 460, 548], [550, 550, 583, 583, 611], [613, 613, 641, 641, 717], [719, 719, 738, 738, 810], [812, 812, 887, 887, 1071], [1073, 1073, 1100, 1100, 1235], [1274, 1274, 1293, 1293, 2366], [2368, 2368, 2389, 2389, 2534], [2536, 2536, 2567, 2567, 2819], [2821, 2821, 2848, 2848, 4934], [4936, 4936, 4993, 4993, 5585]]}
{"id": "ttycWV", "name": "Slightly more complex plane marc", "author": "mrange", "description": "Licence CC0: Slightly more complex plane marcher\nI had fun messing around with \"plane marching\" and FBMs\n", "tags": ["2d", "3d", "fbm"], "likes": 6, "viewed": 274, "published": "Public API", "date": "1611773610", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Licence CC0: Slightly more complex plane marcher\n//  I had fun messing around with \"plane marching\" and FBMs\n\n// -----------------------------------------------------------------------------\n// COMMON\n// -----------------------------------------------------------------------------\n\n#define PI              3.141592654\n#define TAU             (2.0*PI)\n#define TIME            iTime\n#define RESOLUTION      iResolution\n#define ROT(a)          mat2(cos(a), sin(a), -sin(a), cos(a))\n#define PSIN(x)         (0.5+0.5*sin(x))\n#define LESS(a,b,c)     mix(a,b,step(0.,c))\n#define SABS(x,k)       LESS((.5/(k))*(x)*(x)+(k)*.5,abs(x),abs(x)-(k))\n#define ROT(a)          mat2(cos(a), sin(a), -sin(a), cos(a))\n#define L2(x)           dot(x, x)\n\nconst vec3 std_gamma        = vec3(2.2, 2.2, 2.2);\n\nvec3 hsv2rgb(vec3 c) {\n  const vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n  vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n  return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nfloat hash(float co) {\n  co += 100.0;\n  return fract(sin(co*12.9898) * 13758.5453);\n}\n\nfloat hash(vec3 co) {\n  co += 100.0;\n  return fract(sin(dot(co, vec3(12.9898,58.233, 12.9898+58.233))) * 13758.5453);\n}\n\nfloat pmin(float a, float b, float k) {\n  float h = clamp(0.5+0.5*(b-a)/k, 0.0, 1.0);\n  return mix(b, a, h) - k*h*(1.0-h);\n}\n\nfloat pmax(float a, float b, float k) {\n  return -pmin(-a, -b, k);\n}\n\nvec2 toPolar(vec2 p) {\n  return vec2(length(p), atan(p.y, p.x));\n}\n\nvec2 toRect(vec2 p) {\n  return vec2(p.x*cos(p.y), p.x*sin(p.y));\n}\n\nfloat modMirror1(inout float p, float size) {\n  float halfsize = size*0.5;\n  float c = floor((p + halfsize)/size);\n  p = mod(p + halfsize,size) - halfsize;\n  p *= mod(c, 2.0)*2.0 - 1.0;\n  return c;\n}\n\nfloat tanh_approx(float x) {\n//  return tanh(x);\n  float x2 = x*x;\n  return clamp(x*(27.0 + x2)/(27.0+9.0*x2), -1.0, 1.0);\n}\n\nvec2 mod2_1(inout vec2 p) {\n  vec2 c = floor(p + 0.5);\n  p = fract(p + 0.5) - 0.5;\n  return c;\n}\n\nfloat smoothKaleidoscope(inout vec2 p, float sm, float rep) {\n  vec2 hp = p;\n\n  vec2 hpp = toPolar(hp);\n  const float ts = 2.5;\n  hpp.x = tanh_approx(hpp.x/ts)*ts;\n  float rn = modMirror1(hpp.y, TAU/rep);\n\n  float sa = PI/rep - SABS(PI/rep - abs(hpp.y), sm);\n  hpp.y = sign(hpp.y)*(sa);\n\n  hp = toRect(hpp);\n\n  p = hp;\n\n  return rn;\n}\n\nvec4 alphaBlend(vec4 back, vec4 front) {\n  float w = front.w + back.w*(1.0-front.w);\n  vec3 xyz = (front.xyz*front.w + back.xyz*back.w*(1.0-front.w))/w;\n  return w > 0.0 ? vec4(xyz, w) : vec4(0.0);\n}\n\nvec3 alphaBlend(vec3 back, vec4 front) {\n  return mix(back, front.xyz, front.w);\n}\n\nfloat hex(vec2 p, float r) {\n  const vec3 k = vec3(-sqrt(3.0)/2.0,1.0/2.0,sqrt(3.0)/3.0);\n  p = p.yx;\n  p = abs(p);\n  p -= 2.0*min(dot(k.xy,p),0.0)*k.xy;\n  p -= vec2(clamp(p.x, -k.z*r, k.z*r), r);\n  return length(p)*sign(p.y);\n}\n\nfloat circle(vec2 p, float r) {\n  return length(p) - r;\n}\n\n// -----------------------------------------------------------------------------\n// PATH\n// -----------------------------------------------------------------------------\n\n// The path function\nvec3 offset(float z) {\n  float a = z;\n  vec2 p = -0.075*(vec2(cos(a), sin(a*sqrt(2.0))) + vec2(cos(a*sqrt(0.75)), sin(a*sqrt(0.5))));\n  return vec3(p, z);\n}\n\n// The derivate of the path function\n//  Used to generate where we are looking\nvec3 doffset(float z) {\n  float eps = 0.1;\n  return 0.5*(offset(z + eps) - offset(z - eps))/eps;\n}\n\n// The second derivate of the path function\n//  Used to generate tilt\nvec3 ddoffset(float z) {\n  float eps = 0.1;\n  return 0.125*(doffset(z + eps) - doffset(z - eps))/eps;\n}\n\n\n// -----------------------------------------------------------------------------\n// PLANE MARCHER\n// -----------------------------------------------------------------------------\nconst float  truchet_lw = 0.05;\nconst mat2[] truchet_rots = mat2[](ROT(0.0*PI/2.0), ROT(1.00*PI/2.0), ROT(2.0*PI/2.0), ROT(3.0*PI/2.0));\n\nfloat truchet_cell0(vec2 p) {\n  float d0  = circle(p-vec2(0.5), 0.5);\n  float d1  = circle(p+vec2(0.5), 0.5);\n\n  float d = 1E6;\n  d = min(d, d0);\n  d = min(d, d1);\n  return d;\n}\n\nfloat truchet_cell1(vec2 p) {\n  float d0  = abs(p.x);\n  float d1  = abs(p.y);\n  float d2 = circle(p, 0.25);\n\n  float d = 1E6;\n  d = min(d, d0);\n  d = min(d, d1);\n  d = min(d, d2);\n  return d;\n}\n\nvec2 truchet(vec2 p, float h, out vec3 n) {\n  float hd = circle(p, 0.4);\n\n  vec2 hp = p;\n  float rep = 2.0*floor(mix(5.0, 25.0, fract(h*13.0)));\n  float sm = mix(0.05, 0.125, fract(h*17.0))*24.0/rep;\n  float kn = 0.0;\n  kn = smoothKaleidoscope(hp, sm, rep);\n  hp *= ROT(0.02*TIME);\n  hp += TIME*0.05;\n  vec2 hn = mod2_1(hp);\n  float r = hash(vec3(hn, h));\n  hp *= truchet_rots[int(r*4.0)];\n\n  float cd0 = truchet_cell0(hp);\n  float cd1 = truchet_cell1(hp);\n  float d0 = mix(cd0, cd1, (fract(r*13.0) > 0.5));\n\n  float d = 1E6;\n  d = min(d, d0);\n  d = abs(d) - truchet_lw;\n\n  n = vec3(hn, kn);\n\n  return vec2(hd, d);\n}\n\nfloat df(vec2 p, float h, out vec3 n) {\n  vec2 d = truchet(p, h, n); \n  return d.y;\n}\n\nfloat hf(vec2 p, float h) {\n  vec3 n;\n  float decay = 0.75/(1.0+0.125*L2(p));\n  float d = df(p, h, n);\n  const float ww = 0.085;\n  float height = (smoothstep(0.0, ww, d));\n  return pmax(2.0*height*decay, 0.5, 0.25);\n}\n\nfloat fbm(vec2 p, float h) {\n  const float aa = -0.45;\n  const mat2  pp = (2.03-0.0)*ROT(1.0);\n\n  float a = 1.0;\n  float d = 0.0;\n  float height = 0.0;\n  \n  for (int i = 0; i < 3; ++i) {\n    height += a*hf(p, h);\n    d += a;\n    a *= aa;\n    p *= pp;\n  }\n  \n  return height/d;\n}\n\nconst float scale = 4.0;\n\nvec2 distortCoords(vec2 p, float h) {\n  p *= scale;\n  p.x = SABS(p.x, 0.1*abs(p.y)+0.001);\n  p*=ROT(TIME*0.075);\n  p*=ROT(-PI*tanh_approx(0.125*(L2(p)-0.25)));\n  \n  return p;\n}\n\nconst float exclusionRadius = 0.125*0.5;\n\nfloat distanceField(vec2 p, float h, out vec3 n) {\n  float c = circle(p, exclusionRadius);\n  p = distortCoords(p, h);\n//  return df(p, h, n);\n  return pmin(c, df(p, h, n), 0.25);\n}\n\nfloat height(vec2 p, float h) {\n  p = distortCoords(p, h);\n  return tanh_approx(fbm(p, h));\n}\n\nvec3 normal(vec2 p, float h, float aa) {\n  vec2 eps = vec2(2.0*aa, 0.0);\n  \n  vec3 n;\n  \n  n.x = height(p - eps.xy, h) - height(p + eps.xy, h);\n  n.y = 2.0*eps.x;\n  n.z = height(p - eps.yx, h) - height(p + eps.yx, h);\n  \n  return normalize(n);\n}\n\nvec2 raySphere(vec3 ro, vec3 rd, vec4 sphere) {\n  vec3 ce = sphere.xyz;\n  float ra = sphere.w;\n  vec3 oc = ro - ce;\n  float b = dot(oc, rd);\n  float c = dot(oc, oc) - ra*ra;\n  float h = b*b - c;\n  if (h<0.0) return vec2(-1.0); // no intersection\n  h = sqrt(h);\n  return vec2(-b-h, -b+h);\n}\n\n// -----------------------------------------------------------------------------\n// PLANE MARCHER\n// -----------------------------------------------------------------------------\n\n\nvec4 plane(vec3 ro, vec3 rd, vec3 pp, vec3 off, float aa, float np) {\n  float hh = hash(np);\n  vec2 p = pp.xy;\n  p -= off.xy;\n  float l = length(p);\n\n  vec3  dn;\n  float d  = distanceField(p, hh, dn)/scale;\n  float alpha = 1.0-smoothstep(-aa, aa, -d*4.0);\n  if (alpha < 0.1) return vec4(0.0);\n\n  float h  = height(p, hh);\n  vec3  n  = normal(p, hh, aa);\n\n  vec3 po = vec3(pp.xy, pp.z + h);\n\n  vec3 lp1 = ro + 1.0*vec3(1.0, -1.0, 1.25);\n  vec3 lp2 = ro+ 1.0*vec3(-1.0, -1.0, 2.5);\n\n  vec3 ld1 = normalize(lp1 - po);\n  vec3 ld2 = normalize(lp2 - po);\n\n  vec3 hsv = vec3(0.0*hh+mix(0.6, 0.9, PSIN(TIME*0.1-10.0*l+(p.x+p.y))), tanh_approx(h*h*1.0), tanh_approx(1.0*h+.1));\n  hsv.yz = clamp(hsv.yz, 0.0, 1.0);\n  vec3 baseCol1 = hsv2rgb(hsv);\n  vec3 baseCol2 = sqrt(baseCol1.zyx);\n  vec3 matCol   = 1.0-baseCol1*baseCol2;\n \n  float diff1 = max(dot(n, ld1), 0.0);\n  float diff2 = max(dot(n, ld2), 0.0);\n\n  vec3  ref   = reflect(rd, n);\n  float ref1  = max(dot(ref, ld1), 0.0);\n  float ref2  = max(dot(ref, ld2), 0.0);\n\n  baseCol1 *= mix(0.0, 4.0, 1.0/L2(lp1 - po));\n  baseCol2 *= mix(0.0, 3.0, 1.0/L2(lp2 - po));\n\n  vec3 col = vec3(0.0);\n  const float basePow = 1.25;\n  col += 1.00*matCol*baseCol1*mix(0.1, 1.0, pow(diff1, 4.0))*0.5;\n  col += 0.50*matCol*baseCol2*mix(0.1, 1.0, pow(diff2, 2.0))*0.5;\n  col = pow(col, vec3(1.25));\n  col += 4.0*baseCol1*pow(ref1, 20.0);\n  col += 2.0*baseCol2*pow(ref2, 10.0);\n\n  \n  col = clamp(col, 0.0, 1.0);\n  col = mix(col, vec3(0.0), smoothstep(-aa, aa, -d));\n\n\n  return vec4(col, alpha);\n}\n\nvec3 skyColor(vec3 ro, vec3 rd) {\n  float ld = max(dot(rd, vec3(0.0, 0.0, 1.0)), 0.0);\n  return vec3(1.0, 0.0, 0.25)*tanh_approx(5.0*pow(ld, 200.0));\n}\n\nvec3 color(vec3 ww, vec3 uu, vec3 vv, vec3 ro, vec2 p) {\n  float lp = length(p);\n  vec2 np = p + 1.0/RESOLUTION.xy;\n  float rdd = (2.0+0.5*tanh_approx(lp));  // Playing around with rdd can give interesting distortions\n  vec3 rd = normalize(p.x*uu + p.y*vv + rdd*ww);\n  vec3 nrd = normalize(np.x*uu + np.y*vv + rdd*ww);\n\n  const float planeDist = 1.0+0.0;\n  const int furthest = 6;\n  const int fadeFrom = max(furthest-4, 0);\n  const float fadeDist = planeDist*float(furthest - fadeFrom);\n  float nz = floor(ro.z / planeDist);\n\n  vec3 skyCol = skyColor(ro, rd);\n\n  // Steps from nearest to furthest plane and accumulates the color\n\n  vec4 acol = vec4(0.0);\n  const float cutOff = 0.95;\n  bool cutOut = false;\n  \n  for (int i = 1; i <= furthest; ++i) {\n    float pz = planeDist*nz + planeDist*float(i);\n\n    float pd = (pz - ro.z)/rd.z;\n\n    if (pd > 0.0 && acol.w < cutOff) {\n      vec3 pp = ro + rd*pd;\n      vec3 npp = ro + nrd*pd;\n\n      float aa = 3.0*length(pp - npp);\n\n      vec3 off = offset(pp.z);\n\n      vec4 pcol = plane(ro, rd, pp, off, aa, nz+float(i));\n\n      float nz = pp.z-ro.z;\n      float fadeIn = exp(-2.5*max((nz - planeDist*float(fadeFrom))/fadeDist, 0.0));\n      float fadeOut = smoothstep(0.0, planeDist*0.1, nz);\n      pcol.xyz = mix(skyCol, pcol.xyz, (fadeIn));\n      pcol.w *= fadeOut;\n\n      pcol = clamp(pcol, 0.0, 1.0);\n\n      acol = alphaBlend(pcol, acol);\n    } else {\n      cutOut = true;\n      break;\n    }\n\n  }\n\n  vec3 col = alphaBlend(skyCol, acol);\n// To debug cutouts due to transparency  \n//  col += cutOut ? vec3(1.0, -1.0, 0.0) : vec3(0.0);\n  return col;\n}\n\n// Classic post processing\nvec3 postProcess(vec3 col, vec2 q) {\n  col = clamp(col, 0.0, 1.0);\n  col = pow(col, 1.0/std_gamma);\n  col = col*0.6+0.4*col*col*(3.0-2.0*col);\n  col = mix(col, vec3(dot(col, vec3(0.33))), -0.4);\n  col *=0.5+0.5*pow(19.0*q.x*q.y*(1.0-q.x)*(1.0-q.y),0.7);\n  return col;\n}\n\nvec3 effect(vec2 p, vec2 q) {\n  float tm  = TIME*0.4;\n  vec3 ro   = offset(tm);\n  vec3 dro  = doffset(tm);\n  vec3 ddro = ddoffset(tm);\n\n  vec3 ww = normalize(dro);\n  vec3 uu = normalize(cross(normalize(vec3(0.0,1.0,0.0)+ddro), ww));\n  vec3 vv = normalize(cross(ww, uu));\n\n  vec3 col = color(ww, uu, vv, ro, p);\n  col = postProcess(col, q);\n  return col;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  vec2 q = fragCoord/RESOLUTION.xy;\n  vec2 p = -1. + 2. * q;\n  p.x *= RESOLUTION.x/RESOLUTION.y;\n\n  vec3 col = effect(p, q);\n\n  fragColor = vec4(col, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttycWV.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[113, 789, 811, 811, 980], [982, 982, 1004, 1004, 1067], [1069, 1069, 1090, 1090, 1188], [1190, 1190, 1229, 1229, 1314], [1316, 1316, 1355, 1355, 1384], [1386, 1386, 1408, 1408, 1452], [1454, 1454, 1475, 1475, 1520], [1522, 1522, 1567, 1567, 1721], [1723, 1723, 1751, 1771, 1847], [1849, 1849, 1876, 1876, 1945], [1947, 1947, 2008, 2008, 2281], [2283, 2283, 2323, 2323, 2482], [2484, 2484, 2524, 2524, 2566], [2568, 2568, 2596, 2596, 2796], [2798, 2798, 2829, 2829, 2855], [3028, 3049, 3071, 3071, 3205], [3207, 3286, 3309, 3309, 3384], [3386, 3456, 3480, 3480, 3559], [3562, 3879, 3908, 3908, 4056], [4058, 4058, 4087, 4087, 4251], [4253, 4253, 4296, 4296, 4869], [4871, 4871, 4910, 4910, 4956], [4958, 4958, 4985, 4985, 5175], [5177, 5177, 5205, 5205, 5455], [5483, 5483, 5520, 5520, 5659], [5703, 5703, 5753, 5753, 5883], [5885, 5885, 5916, 5916, 5978], [5980, 5980, 6020, 6020, 6225], [6227, 6227, 6274, 6274, 6516], [6518, 6699, 6768, 6768, 8218], [8220, 8220, 8253, 8253, 8371], [8373, 8373, 8429, 8429, 9967], [9969, 9996, 10032, 10032, 10265], [10267, 10267, 10296, 10296, 10622], [10624, 10624, 10679, 10679, 10837]]}
{"id": "ttyyD3", "name": "Shakespeare Quest", "author": "eiffie", "description": "re-up. Monkeys can't write Shakespeare if their lives depended on it. I already did the research. Trust me you don't want to repeat it. I think I'll have better luck randomly reconstituting his DNA.", "tags": ["finger"], "likes": 13, "viewed": 241, "published": "Public API", "date": "1611856135", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Shakespeare Quest by eiffie (solving for 2 joints)\n\n#define size iResolution\n#define SHADOWS\n\nfloat time;\n/* //\"solves\" for two joints (there is a better way I'm sure)\nvoid djsolve( vec3 a, vec3 b, vec3 l, vec3 rt, out vec3 j1, out vec3 j2 )//mod from iq's\n{//the vec \"l\" has the segment lengths, rt is axis of bend\n float l2=(l.y+l.z)*sqrt(length(a-b))/sqrt(l.x+l.y+l.z);\n vec3 p=b-a,q=p*(0.5+0.5*(l.x*l.x-l2*l2)/dot(p,p));\n j1=a+q+sqrt(max(0.0,l.x*l.x-dot(q,q)))*normalize(cross(p,rt));\n p=b-j1;q=p*(0.5+0.5*(l.y*l.y-l.z*l.z)/dot(p,p));\n j2=j1+q+sqrt(max(0.0,l.y*l.y-dot(q,q)))*normalize(cross(p,rt));\n}\n*/\n\nvec4 djsolve( vec2 p )//mod from fizzer's mod of iq's\n{//the segment lengths are precalculated as 0.5,0.4,0.3 and starts at point 0,0\n float l2=0.639*pow(dot(p,p),0.25);\n vec2 q=p*(0.5+0.5*(0.25-l2*l2)/dot(p,p));\n vec2 j1=q+sqrt(max(0.0,0.25/dot(q,q)-1.0))*q.yx*vec2(-1.0,1.0);\n p=p-j1;\n q=p*(0.5+0.035/dot(p,p));\n vec2 j2=j1+q+sqrt(max(0.0,0.16/dot(q,q)-1.0))*q.yx*vec2(-1.0,1.0);\n return vec4(j1,j2);\n}\nmat3 lookat(vec3 fw,vec3 up){\n fw=normalize(fw);vec3 rt=normalize(cross(fw,up));return mat3(rt,cross(rt,fw),fw);\n}\nfloat Tube(vec3 pa, vec3 ba, float r){//mod from iq's\n float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n return length(pa - ba*h)-r+h*0.015;\n //return length(pa-ba*clamp(dot(pa,ba)/dot(ba,ba),0.0,1.0))-r;\n}\n\nfloat finger(vec3 p, float z){\n vec3 j4=vec3(0.7+sin(z+time+sin(z*1.3))*0.25,abs(sin(z+time))*0.6,0.0);\n vec4 j=djsolve(j4.xy);\n vec3 j2=vec3(j.xy,0.0),j3=vec3(j.zw,0.0);\n float d=Tube(p,j2,0.145);\n d=min(d,Tube(p-j2,j3-j2,0.13));\n return min(d,Tube(p-j3,j4-j3,0.115));\n}\nfloat DE(vec3 p0){\n vec3 p=p0;\n p.x=mod(p.x,2.0)-1.0;\n float d3=length(max(abs(p.xy+vec2(0.0,0.27))-vec2(0.47,0.2),0.0))-0.03;\n float d2=min(length(p.xy-vec2(0.75,0.0)),length(p.xy+vec2(0.75,0.0)));\n float za=0.0;\n if(abs(fract(p.z)-0.5)>0.25){\n  p.x=-p.x;\n  p.z+=0.5;\n  za=5.0;\n }\n p.x+=0.75;\n float z=floor(p.z)+floor(p0.x*0.5)*10.0+za;\n p.z=fract(p.z)-0.5;\n float d=finger(p,z);\n return min(0.16,min(d,min(d2-0.075,d3)));\n}\n\nfloat G(vec2 p){return smoothstep(0.0,0.05,min(max(abs(p.x-0.6)-0.15,abs(p.y-0.5)),max(min(p.x-p.y,p.y-0.5),abs(length(p-vec2(0.5))-0.25))));}\nfloat A(vec2 p){return smoothstep(0.0,0.05,min(max(0.25-p.y,abs(abs(p.x-0.5)+p.y*0.5-0.4)),max(abs(p.x-0.5)-0.1,abs(p.y-0.5))));}\nfloat C(vec2 p){return smoothstep(0.0,0.05,max(abs(length(p-vec2(0.5))-0.25),p.x-0.6));}\nfloat T(vec2 p){return smoothstep(0.0,0.05,min(max(abs(p.x-0.5),abs(p.y-0.5)-0.25),max(abs(p.x-0.5)-0.25,abs(p.y-0.75))));}\n\nvec3 getColor(vec3 p0){\n float tim=time-0.2;\n vec3 col;\n vec3 p=p0;\n p.x=mod(p.x,2.0)-1.0;\n float d3=length(max(abs(p.xy+vec2(0.0,0.27))-vec2(0.47,0.2),0.0))-0.03;\n float d2=min(length(p.xy-vec2(0.75,0.0)),length(p.xy+vec2(0.75,0.0)));\n float ftz=0.625,za=0.0;\n if(abs(fract(p.z)-0.5)>0.25){\n  p.x=-p.x;\n  p.z+=0.5;\n  ftz=0.125;\n  za=5.0;\n }\n p.x+=0.75;\n float z=floor(p.z)+floor(p0.x*0.5)*10.0+za;\n p.z=fract(p.z)-0.5;\n float d=finger(p,z);\n vec4 ft=vec4(0.7+sin(z+tim+sin(z*1.3))*0.25,abs(sin(z+tim))*0.6,p0.z+ftz,p.x);\n if(d2<d && d2<d3){col=vec3(0.7,0.65,0.4);}\n else if(d3<d){\n  p0.z+=0.125;\n  vec2 xz=abs(mod(p0.xz,0.25)-0.125);\n  col=(1.0-20.0*dot(xz,xz))*vec3(0.5,0.4,0.3);\n  xz=floor(p0.xz*4.0);\n  if(ft.y<0.1){//fat fingering :)\n   if(mod(floor(ft.w*4.0),4.0)==mod(floor(ft.x*4.0),4.0) && fract(ft.z)<0.25)\n    col*=vec3(4.0,3.0,2.0);\n  }\n  float i=mod(xz.x-xz.y,4.0);\n  xz=p0.xz*4.0-xz;\n  if(i<1.0)col*=G(xz);\n  else if(i<2.0)col*=A(xz);\n  else if(i<3.0)col*=C(xz);\n  else col*=T(xz);\n }else col=vec3(0.2,0.3,0.4);\n return col;\n}\n#ifdef SHADOWS\nfloat linstep(float a, float b, float t){return clamp((t-a)/(b-a),0.,1.);}//from knighty\n//random seed and generator\nfloat randSeed,GoldenAngle;\nfloat randStep(){//crappy random number generator\n randSeed=fract(randSeed+GoldenAngle);\n return  (0.8+0.2*randSeed);\n}\nfloat FuzzyShadow(vec3 ro, vec3 rd, float coneGrad){\n float t=0.01,d,s=1.0,r;\n ro+=rd*t;\n for(int i=0;i<8;i++){\n  r=t*coneGrad;\n  d=DE(ro+rd*t)+r*0.5;\n  s*=linstep(-r,r,d);\n  t+=d*randStep();\n }\n return clamp(s,0.2,1.0);\n}\n#endif\n\nvec3 Light(vec3 p, vec3 rd, vec3 L){\n vec2 v=vec2(0.001,0.0);\n vec3 mcol=getColor(p);\n vec3 N=normalize(vec3(DE(p+v.xyy)-DE(p-v.xyy),DE(p+v.yxy)-DE(p-v.yxy),DE(p+v.yyx)-DE(p-v.yyx)));\n vec3 col=mix(mcol.yzx,mcol,abs(dot(rd,N)))*max(0.0,dot(N,L));\n col+=vec3(1.0,0.5,0.7)*pow(max(0.0,dot(reflect(rd,N),L)),16.0);\n#ifdef SHADOWS\n col*=FuzzyShadow(p,L,0.5);\n#endif\n return col;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n time=iTime*2.5;\n#ifdef SHADOWS\n GoldenAngle=2.0-0.5*(1.0+sqrt(5.0));\n randSeed=fract(sin(dot(fragCoord.xy,vec2(13.434,77.2378))+time*0.1)*4132.34526);\n#endif\n vec3 ro=vec3(2.0*sin(time*0.1),1.5+sin(time*0.03)*0.6,time*0.6+cos(time*0.135));\n mat3 rotCam=lookat(vec3(0.0,0.3-0.5*ro.y,1.0),vec3(0.0,1.0,0.0));\n vec3 rd=rotCam*normalize(vec3((2.0*fragCoord.xy-size.xy)/size.y,1.5));\n rd.x=-rd.x;\n float t=max(0.0,(0.875-ro.y)/rd.y),d=1.0,dm=d,tm=t;\n for(int i=0;i<24;i++){\n  t+=d=DE(ro+rd*t);\n  if(d<dm){dm=d;tm=t;}\n }\n vec3 col=vec3(rd.y*rd.y);\n vec3 L=normalize(vec3(0.2,0.6,-0.3));\n bool secondMarch=(dm>0.0002*tm);\n if(secondMarch){//unless we got really close speed up the march\n  for(int i=0;i<16;i++){\n   t+=d=DE(ro+rd*t)*1.5;//just experimenting\n   t+=0.01;\n  }\n  if(d<0.02*t){\n   vec3 p=ro+rd*t;\n   vec3 scol=Light(p,rd,L);\n   col=mix(scol,col,smoothstep(0.0,0.02*t,d));\n   col*=exp(-t*0.1);\n  }\n }\n if(dm<0.002*tm){\n  vec3 p=ro+rd*tm;\n  vec3 scol=Light(p,rd,L);\n  col=mix(scol,col,smoothstep(0.0,0.002*tm,dm));\n  col*=exp(-tm*0.1);\n }\n \n \n fragColor = vec4(clamp(col*2.0,0.0,1.0),1.0);\n\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttyyD3.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[109, 613, 668, 746, 1017], [1018, 1018, 1047, 1047, 1132], [1133, 1133, 1171, 1186, 1342], [1344, 1344, 1374, 1374, 1615], [1616, 1616, 1634, 1634, 2042], [2044, 2044, 2060, 2060, 2186], [2187, 2187, 2203, 2203, 2316], [2317, 2317, 2333, 2333, 2405], [2406, 2406, 2422, 2422, 2529], [2531, 2531, 2554, 2554, 3571], [4083, 4083, 4119, 4119, 4459], [4460, 4460, 4517, 4517, 5613]]}
{"id": "ttyyR3", "name": "Naive SDF voxel grid", "author": "DragonWolf", "description": "Determines if an  SDF voxel grid using brute force (pixel by pixel) determination.", "tags": ["sdfvoxel"], "likes": 1, "viewed": 128, "published": "Public", "date": "1611409524", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define gridSize 10.0\n\nfloat sdBox( vec2 uv, vec2 position, in vec2 bounds )\n{\n    vec2 d = abs(position - uv)-bounds;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\nfloat sdCircle(vec2 uv, vec2 pos, float radius) {\n    return length(uv - pos) - radius;\n}\n\nfloat sdf(vec2 uv) {\n    float radius1 = 0.4 * (1.0 + sin(iTime * 0.6));\n    vec2 position1 = vec2(sin(iTime * 0.3), sin(iTime * 0.2));\n    float circle1 = sdCircle(uv, position1, radius1);   \n    \n    float radius2 = 0.3 * (1.0 + sin(iTime * 0.1));\n    vec2 position2 = vec2(sin(iTime * 0.2), sin(iTime * 0.5));\n    float circle2 = sdCircle(uv, position2, radius2);   \n    \n    return min(circle1, circle2);\n}\n    \nbool insideBoundingSquare(vec2 position, vec2 bound, vec2 pixelSize) {\n\n    float i = 0.;\n    float pixelsHigh = (2.0 * bound.y / pixelSize.y);\n    vec2 rd = vec2(1.0, 0.0);\n    vec2 ro = position - bound;\n    while (i < pixelsHigh) {\n        i += 1.0;\n        ro.y += pixelSize.y;\n        vec2 pos = ro;\n        float dist = 0.;\n        while (dist < bound.x * 2.0) {\n            float d = sdf(pos);\n            d = clamp(d, 0., 100.);\n            if (d > pixelSize.x) {\n                return false;\n            }\n            \n            if (d < pixelSize.x) {\n                d = pixelSize.x;\n            }\n            \n            dist += d;\n            pos = ro + rd * dist;\n        }  \n    }\n    \n    return true;\n}\n\nbool touchingBoundingSquare(vec2 position, vec2 bound, vec2 pixelSize) {\n\n    float i = 0.;\n    float pixelsHigh = (2.0 * bound.y / pixelSize.y);\n    vec2 rd = vec2(1.0, 0.0);\n    vec2 ro = position - bound;\n    while (i < pixelsHigh) {\n        i += 1.0;\n        ro.y += pixelSize.y;\n        vec2 pos = ro;\n        float dist = 0.;\n        while (dist < bound.x * 2.0) {\n            float box1 = sdBox(pos, position, bound);\n            float d = sdf(pos);\n            d = abs(max(abs(d), box1));\n            if (d <= pixelSize.x) {\n                return true;\n            }\n            \n            if (d < pixelSize.x) {\n                d = pixelSize.x;\n            }\n            \n            dist += d;\n            pos = ro + rd * dist;\n        }  \n    }\n    \n    return false;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    \n    vec2 uv = 2.0 * (fragCoord - (0.5*iResolution.xy))/iResolution.y;\n    vec2 pixelSize = 2.0 * ((vec2(iResolution.x, iResolution.y) - (0.5*iResolution.xy))/iResolution.y) / iResolution.xy;\n    \n    // Calculate SDF\n    float d = sdf(uv);\n\n    // Bounding Box\n    vec2 voxelMidpoint = vec2((floor(uv.x * gridSize) / gridSize) + (0.5 / gridSize), (floor(uv.y * gridSize) / gridSize) + (0.5 / gridSize));\n    vec2 voxelSize = vec2(0.5 / gridSize, 0.5 / gridSize);\n    vec2 minExtent = voxelMidpoint - voxelSize;\n    vec2 maxExtent = voxelMidpoint + voxelSize;\n    float box1 = sdBox(uv, voxelMidpoint, voxelSize);\n    \n    // Work out if the SDF is inside the box or not.\n    bool inside = insideBoundingSquare(voxelMidpoint, voxelSize, pixelSize);\n    bool touching = touchingBoundingSquare(voxelMidpoint, voxelSize, pixelSize);\n    bool outside = !touching;\n\n    vec3 statusColor = vec3(1.0, 1.0, 0.0);\n    if (inside) {\n        statusColor = vec3(0.0, 1.0, 0.0);\n    } else if (outside) {\n        statusColor = vec3(1.0, 0.0, 0.0);\n    }\n\n    // Set base colour depending on inside or outside bounding box.\n    vec3 baseColor = vec3(0.1,0.4,0.7);\n    if (uv.x > minExtent.x && uv.x < maxExtent.x && uv.y > minExtent.y && uv.y < maxExtent.y) {\n        baseColor = vec3(0.8,0.2,0.2);\n    }\n   \n    // Taken from iq to visualize sdf distances (https://www.shadertoy.com/view/4lcBWn)    \n    vec3 col = vec3(1.0) - sign(d)*baseColor;\n\tcol *= 1.0 - exp(-3.0*abs(d));\n\tcol *= 0.8 + 0.2*cos(120.0*d);\n\tcol = mix( col, vec3(1.0), 1.0-smoothstep(0.0,0.015,abs(d)));\n    \n    // Add the grid\n    col = mix( col, statusColor, 1.0-smoothstep(0.0,0.015,abs(box1)) );\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttyyR3.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[23, 23, 78, 78, 175], [177, 177, 226, 226, 266], [268, 268, 288, 288, 678], [684, 684, 754, 754, 1406], [1408, 1408, 1480, 1480, 2191], [2193, 2193, 2250, 2300, 4024]]}
{"id": "ttyyWt", "name": "Another Neural Bunny Variation", "author": "oneshade", "description": "Another variation of blackle's neural network bunny distance estimator: [url=https://www.shadertoy.com/view/wtVyWK]https://www.shadertoy.com/view/wtVyWK[/url].", "tags": ["bunny", "neuralnetwork", "stanfordbunny", "siren", "testmodel"], "likes": 4, "viewed": 121, "published": "Public", "date": "1611950251", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Neural Network distance estimator for Stanford Bunny: https://www.shadertoy.com/view/wtVyWK\nfloat sdStanfordBunny(in vec3 p, in float s){\n    p/=vec3(-s,s,s);\n    p+=vec3(.08,.475,0);\n    p=p.zxy;\n\n    if (length(p)>1.) return length(p)-.8;\n\n    vec4 x=vec4(p,1),\n    f00=sin(x*mat4(-1.74,-1.05,-1.82,2.64,-3.5,-4.23,2.91,-3.83,-.67,2.72,1.37,10.45,-1.46,-1.9,3.0,5.41)),\n    f01=sin(x*mat4(-3.12,-3.3,1.11,-1.54,2.91,-2.94,.82,-9.88,.92,1.34,2.62,2.71,1.16,1.04,-1.25,-9.69)),\n    f02=sin(x*mat4(3.42,-1.21,2.28,9.64,-2.02,1.15,1.83,-4.09,3.23,-.52,2.07,5.01,.52,-.6,3.35,.87)),\n    f10=sin(mat4(-.99,.53,-.28,.66,.15,-.02,-.09,-.06,-.01,-.05,-.04,-.56,-.1,-.31,-.83,-.43)*f00+mat4(.15,.04,-.09,.21,.42,-.23,.02,.17,.23,.31,.6,.56,-.93,1.47,.0,-.48)*f01+mat4(.71,-.44,-.18,.43,-.6,.42,.45,.5,-.92,.35,-.72,-.44,.0,.76,-.31,-.05)*f02+vec4(-13.95,-3.14,5.36,-9.25)),\n    f11=sin(mat4(-.54,-.75,-.21,-.24,-.38,.06,-.03,.55,.81,.51,-1.12,-.01,-.38,.11,-.02,.67)*f00+mat4(.11,.15,-.05,1.59,.04,-.23,-.18,-1.16,-.08,-.14,-.53,-.07,.23,-.36,-.4,-.15)*f01+mat4(.72,.28,-.18,-.61,.22,-.23,-.65,.28,.83,.41,.11,-.29,-.39,-.32,-.92,-.51)*f02+vec4(-4.81,6.95,9.26,-6.26)),\n    f12=sin(mat4(.73,.76,-.2,-1.04,-.46,.18,.21,1.15,-.06,-.43,.94,.13,.37,-.67,.6,.11)*f00+mat4(.38,.4,.04,.88,-.27,-1.18,.03,-.33,.14,1.54,.69,1.17,.37,1.3,.26,-1.7)*f01+mat4(.33,.42,-.4,-.97,-.23,.84,.42,-.1,-.67,.39,-.84,-.62,.45,.69,.37,1.29)*f02+vec4(-4.38,5.86,13.65,-9.16)),\n    f20=sin(mat4(-.39,.06,1.14,.07,-.06,-.82,.13,-.17,.19,-.79,-1.93,.11,-.39,-.02,-.48,-.05)*f10+mat4(-.51,-.77,-.35,-.02,.1,.47,-1.25,.08,-.1,-.3,1.4,.13,-.1,.21,-.59,.21)*f11+mat4(-.23,.03,-.68,-.08,.06,.15,1.01,-.11,-.27,-.01,-1.56,.02,-.34,.06,.51,.13)*f12+vec4(4.79,-5.84,7.28,4.74)),\n    f21=sin(mat4(.18,.07,.29,-.19,.59,-.03,-.27,.18,.05,.16,.17,-.06,.14,.36,-.24,.0)*f10+mat4(-.38,-.24,-.07,.23,.11,.1,.04,.55,.3,-.2,-.09,.03,.12,.13,.05,.01)*f11+mat4(-.09,.19,.08,.15,.18,.06,-.08,-.03,-.26,-.09,.15,.17,-.06,.07,.14,.19)*f12+vec4(-7.29,1.85,-4.88,.69)),\n    f22=sin(mat4(.32,-.19,.24,.29,.95,.0,.93,.07,1.3,-.76,-.57,-.45,.22,.87,-.6,.95)*f10+mat4(-.65,-.3,-.38,-.3,-.61,.58,-.78,1.04,-.32,-.06,.12,.59,-.94,-.06,-.04,-.07)*f11+mat4(.16,-.5,.46,1.24,.39,-.43,.28,-.91,-.76,-.98,-1.13,.27,-1.26,-.3,-.01,-.11)*f12+vec4(-6.24,1.26,-1.13,-13.77));\n\n    return (dot(vec4(-.18,.16,.02,-.4),f20)+dot(vec4(-.18,-.51,-.55,.39),f21)+dot(vec4(.03,.08,.11,.05),f22)+.28)*s;\n}\n\nfloat mapScene(in vec3 p, in float bounce, in float stretch) {\n    p.y /= stretch;\n    p.y -= bounce;\n    return sdStanfordBunny(p - vec3(-0.5, 0.5, 0.0), 3.0);\n}\n\nvec3 getNormal(in vec3 p, in float bounce, in float stretch) {\n    vec3 e = vec3(0.01, 0.0, 0.0);\n    return normalize(vec3(mapScene(p + e.xyy, bounce, stretch) - mapScene(p - e.xyy, bounce, stretch),\n                          mapScene(p + e.yxy, bounce, stretch) - mapScene(p - e.yxy, bounce, stretch),\n                          mapScene(p + e.yyx, bounce, stretch) - mapScene(p - e.yyx, bounce, stretch)));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 screenCenter = 0.5 * iResolution.xy;\n\n    vec2 mouse = vec2(0.0, 0.0);\n    if (iMouse.z > 0.0) {\n        mouse = (iMouse.xy - screenCenter) / iResolution.y * 3.14;\n    }\n\n    vec2 uv = (fragCoord - screenCenter) / iResolution.y;\n    fragColor = vec4(0.0, 0.0, 0.0, 1.0);\n\n    vec3 ro = vec3(0.0, 0.0, 5.0);\n    vec3 rd = normalize(vec3(uv, -1.0));\n\n    float cy = cos(mouse.x), sy = sin(mouse.x);\n    float cp = cos(mouse.y), sp = sin(mouse.y);\n    ro.yz *= mat2(cp, -sp, sp, cp);\n    ro.xz *= mat2(cy, -sy, sy, cy);\n    rd.yz *= mat2(cp, -sp, sp, cp);\n    rd.xz *= mat2(cy, -sy, sy, cy);\n\n    float frac1 = 1.0 - fract(iTime);\n    float frac2 = fract(iTime);\n    float stretch = frac1 * (1.0 - frac1) * 2.5 + 0.5;\n    float bounce = frac2 * (1.0 - frac2) * 5.0;\n\n    float t = 0.0;\n    for (float i=0.0; i < 100.0; i++) {\n        vec3 p = ro + rd * t;\n        float d = mapScene(p, bounce, stretch);\n        if (d < 0.001) {\n            vec3 n = getNormal(p, bounce, stretch);\n            vec3 l = vec3(-0.58, 0.58, 0.58);\n\n            vec3 tex1 = texture(iChannel0, p.xy).rgb;\n            vec3 tex2 = texture(iChannel0, p.xz).rgb;\n            vec3 tex3 = texture(iChannel0, p.yz).rgb;\n\n            // How to remove texture slipping?\n            float w1 = n.x * n.x;\n            float w2 = n.y * n.y;\n            float w3 = n.z * n.z;\n\n            float lambertian = max(0.0, dot(n, l));\n            fragColor.rgb += tex1 * w1 + tex2 * w2 + tex3 * w3 * max(0.2, lambertian);\n            if (lambertian > 0.0) {\n                vec3 r = reflect(l, n);\n                float specAngle = max(0.0, dot(r, rd));\n                fragColor.rgb += max(0.0, pow(specAngle, 16.0));\n            }\n\n            break;\n        }\n\n        if (t > 20.0) {\n            fragColor.rgb += mix(vec3(0.25, 0.25, 1.0), vec3(1.0), 0.5 + 0.5 * rd.y);\n            break;\n        }\n\n        t += d;\n    }\n}", "image_inputs": [{"id": "4df3Rr", "previewfilepath": "/media/ap/3871e838723dd6b166e490664eead8ec60aedd6b8d95bc8e2fe3f882f0fd90f0.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/3871e838723dd6b166e490664eead8ec60aedd6b8d95bc8e2fe3f882f0fd90f0.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttyyWt.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 95, 140, 140, 2424], [2426, 2426, 2488, 2488, 2588], [2590, 2590, 2652, 2652, 3000], [3002, 3002, 3057, 3057, 4949]]}
{"id": "Wd3BD7", "name": "Embers and Ashes p_i_i", "author": "public_int_i", "description": "publishing some old shaders i did offline", "tags": ["and", "embers", "ashes"], "likes": 5, "viewed": 198, "published": "Public API", "date": "1609535809", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/*Ethan Alexander Shulman 2020 - xaloez.com\n3840x2160 60fps video https://www.youtube.com/watch?v=2ISSvdhVfwM\n3840x2160 wallpaper xaloez.com/art/2020/EmbersandAshes.jpg*/\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float time = iTime;\n    vec2 uv = (fragCoord*2.-iResolution.xy)/iResolution.y;\n    \n\tfloat s = 0.;\n\tfor (float p = 0.; p < 1000.; p++) {\n\t\t#define R3P 1.22074408460575947536\n\t\tvec3 q = fract(.5+p*vec3(1./R3P,1./(R3P*R3P),1./(R3P*R3P*R3P)));\n\t\tfloat a = p*.001+time*(.01+q.z*.1);\n\t\tvec2 x = q.xy*mat2(sin(a*2.1),sin(a*4.13),sin(a*8.16),sin(a*4.18));\n\t\tfloat l = length(x-uv.xy);\n\t\ts += sin((l-q.z)*10.)/(1.+max(0.,l-.01)*200.);\n\t}\n\tfragColor = mix(vec4(.05,.08,.1,1),vec4(1,.5,.4,1),max(0.,s*.4));\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Wd3BD7.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 172, 229, 229, 732]]}
{"id": "Wd3fD7", "name": "Galactic Noise p_i_i", "author": "public_int_i", "description": "galactic noise", "tags": ["noise", "galactic"], "likes": 3, "viewed": 139, "published": "Public API", "date": "1609535850", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/*Ethan Alexander Shulman 2020 - xaloez.com\n4k 60fps video https://www.youtube.com/watch?v=iak20znYLcc\n4k wallpaper xaloez.com/art/2020/GalacticNoise.jpg*/\n\n#define PI 3.14159265358\n\nmat2 r2(float a) {\n\tfloat sn = sin(a), cs = cos(a);\n\treturn mat2(cs,-sn,sn,cs);\n}\n\nvec4 hash(vec4 a) {\n\treturn fract(abs(sin(a.ywxz*766.345)+cos(normalize(a)*4972.92855))*2048.97435+abs(a.wxyz)*.2735);\n}\n\nvec3 hsvToRGB(vec3 hsv) {\n\treturn mix(clamp(abs(mod(hsv.x*6.0+vec3(0.,4.,2.),6.)-3.0)-1.0,0.,1.),vec3(1),hsv.y)*hsv.z;\n}\n\nfloat twave(float x) {\n\tx = fract(x);\n\treturn x*2.-max(0.,x*4.-2.);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float time = iTime;\n    vec2 uv = (fragCoord*2.-iResolution.xy)/iResolution.y*(.25+twave(time*.03));\n\n\tvec3 c = vec3(0);\n\tfor (float p = 1.; p < 100.; p++) {\n\t\tvec4 pp = hash(p*vec4(.01,.1,1.,10.));\n\t\tc += cos((time*-.05+length(uv.xy-(pp.xy*2.-1.)))*p*vec3(pp.zw*10.,10))/p;\n\t}\n\tfragColor = vec4(hsvToRGB(pow(clamp(c*.2+.5,0.,1.),vec3(1.,4.,3.))),1);\n}\n\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Wd3fD7.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 183, 201, 201, 264], [266, 266, 285, 285, 386], [388, 388, 413, 413, 508], [510, 510, 532, 532, 579], [581, 581, 638, 638, 995]]}
{"id": "wdffRl", "name": "Loop noise", "author": "supah", "description": "loop noise", "tags": ["loopnoise"], "likes": 2, "viewed": 80, "published": "Public", "date": "1611571348", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n//\tClassic Perlin 3D Noise \n//\tby Stefan Gustavson\n//\nvec4 permute(vec4 x){return mod(((x*34.0)+1.0)*x, 289.0);}\nvec4 taylorInvSqrt(vec4 r){return 1.79284291400159 - 0.85373472095314 * r;}\nvec3 fade(vec3 t) {return t*t*t*(t*(t*6.0-15.0)+10.0);}\n\nfloat cnoise(vec3 P){\n  vec3 Pi0 = floor(P); // Integer part for indexing\n  vec3 Pi1 = Pi0 + vec3(1.0); // Integer part + 1\n  Pi0 = mod(Pi0, 289.0);\n  Pi1 = mod(Pi1, 289.0);\n  vec3 Pf0 = fract(P); // Fractional part for interpolation\n  vec3 Pf1 = Pf0 - vec3(1.0); // Fractional part - 1.0\n  vec4 ix = vec4(Pi0.x, Pi1.x, Pi0.x, Pi1.x);\n  vec4 iy = vec4(Pi0.yy, Pi1.yy);\n  vec4 iz0 = Pi0.zzzz;\n  vec4 iz1 = Pi1.zzzz;\n\n  vec4 ixy = permute(permute(ix) + iy);\n  vec4 ixy0 = permute(ixy + iz0);\n  vec4 ixy1 = permute(ixy + iz1);\n\n  vec4 gx0 = ixy0 / 7.0;\n  vec4 gy0 = fract(floor(gx0) / 7.0) - 0.5;\n  gx0 = fract(gx0);\n  vec4 gz0 = vec4(0.5) - abs(gx0) - abs(gy0);\n  vec4 sz0 = step(gz0, vec4(0.0));\n  gx0 -= sz0 * (step(0.0, gx0) - 0.5);\n  gy0 -= sz0 * (step(0.0, gy0) - 0.5);\n\n  vec4 gx1 = ixy1 / 7.0;\n  vec4 gy1 = fract(floor(gx1) / 7.0) - 0.5;\n  gx1 = fract(gx1);\n  vec4 gz1 = vec4(0.5) - abs(gx1) - abs(gy1);\n  vec4 sz1 = step(gz1, vec4(0.0));\n  gx1 -= sz1 * (step(0.0, gx1) - 0.5);\n  gy1 -= sz1 * (step(0.0, gy1) - 0.5);\n\n  vec3 g000 = vec3(gx0.x,gy0.x,gz0.x);\n  vec3 g100 = vec3(gx0.y,gy0.y,gz0.y);\n  vec3 g010 = vec3(gx0.z,gy0.z,gz0.z);\n  vec3 g110 = vec3(gx0.w,gy0.w,gz0.w);\n  vec3 g001 = vec3(gx1.x,gy1.x,gz1.x);\n  vec3 g101 = vec3(gx1.y,gy1.y,gz1.y);\n  vec3 g011 = vec3(gx1.z,gy1.z,gz1.z);\n  vec3 g111 = vec3(gx1.w,gy1.w,gz1.w);\n\n  vec4 norm0 = taylorInvSqrt(vec4(dot(g000, g000), dot(g010, g010), dot(g100, g100), dot(g110, g110)));\n  g000 *= norm0.x;\n  g010 *= norm0.y;\n  g100 *= norm0.z;\n  g110 *= norm0.w;\n  vec4 norm1 = taylorInvSqrt(vec4(dot(g001, g001), dot(g011, g011), dot(g101, g101), dot(g111, g111)));\n  g001 *= norm1.x;\n  g011 *= norm1.y;\n  g101 *= norm1.z;\n  g111 *= norm1.w;\n\n  float n000 = dot(g000, Pf0);\n  float n100 = dot(g100, vec3(Pf1.x, Pf0.yz));\n  float n010 = dot(g010, vec3(Pf0.x, Pf1.y, Pf0.z));\n  float n110 = dot(g110, vec3(Pf1.xy, Pf0.z));\n  float n001 = dot(g001, vec3(Pf0.xy, Pf1.z));\n  float n101 = dot(g101, vec3(Pf1.x, Pf0.y, Pf1.z));\n  float n011 = dot(g011, vec3(Pf0.x, Pf1.yz));\n  float n111 = dot(g111, Pf1);\n\n  vec3 fade_xyz = fade(Pf0);\n  vec4 n_z = mix(vec4(n000, n100, n010, n110), vec4(n001, n101, n011, n111), fade_xyz.z);\n  vec2 n_yz = mix(n_z.xy, n_z.zw, fade_xyz.y);\n  float n_xyz = mix(n_yz.x, n_yz.y, fade_xyz.x); \n  return 2.2 * n_xyz;\n}\n\nvec3 box (vec2 sizes, vec2 uv) {\n    \n    float w = sizes.x / 2.;\n    float h = sizes.y / 2.;\n    float blur = .01;\n    \n    vec3 col = vec3(1.);\n    col -= vec3(smoothstep(-w, -w - blur, uv.x));\n    col -= vec3(smoothstep(w, w + blur, uv.x));\n    col -= vec3(smoothstep(h, h + blur, uv.y));\n    col -= vec3(smoothstep(-h, -h - blur, uv.y));\n    return col;\n}\n\n#define pi 3.14159265\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from -1 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n  \n    \n    float loopDuration = 10.;\n    float speed = .5;\n    \n    float time = mod(iTime * speed / loopDuration, 1.);\n    float playhead = .5 * sin(time * pi * 2.) + 2.;\n    \n    float s = sin(time * 2. * pi) + 1.;\n    float c = cos(time * 2. * pi) + 1.;\n    \n    \n    float zoom = 1.;\n    vec2 uvNoise = uv * zoom;\n    \n\n    \n    float n1 = cnoise(vec3(uvNoise, s));\n    float n2 = cnoise(vec3(uvNoise, c));\n    \n    \n\tvec3 col1 = vec3(3.9 * uvNoise.x + n2, uvNoise.x + n2, 1.);\n    vec3 col2 = vec3(2.2 * uvNoise.x + n1, uvNoise.x + n2, 1.);\n        \n    vec3 col = mix(col1, col2, playhead);\n    \n    col = vec3(col.r);\n    \n    vec3 t2 = vec3(1., uv.y, 0.);    \n    vec3 t1 = vec3(uv.x * .5 + .5, uv.y, 1.);   \n    t2 += mod(col, 0.2);\n    t1 += mod(col, 0.2);\n    \n\tcol = clamp(col, 0., 1.);\n    col = mix(t1, t2, col);\n    \n    \n    // Output to screen\n    fragColor = vec4(col, 1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wdffRl.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 55, 76, 76, 113], [114, 114, 141, 141, 189], [190, 190, 209, 209, 245], [247, 247, 268, 268, 2540], [2542, 2542, 2574, 2574, 2901], [2926, 2926, 2983, 3034, 3969]]}
{"id": "WdKfWd", "name": "Sun Dance EAS", "author": "public_int_i", "description": "Sun Dance EAS", "tags": ["sundanceeas"], "likes": 7, "viewed": 153, "published": "Public API", "date": "1609535880", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/*Ethan Alexander Shulman 2020 - xaloez.com\n4k 60fps video https://www.youtube.com/watch?v=48B3sN_5_hM\n4k wallpaper xaloez.com/art/2020/SunDance.jpg*/\n\nvec4 hash(vec4 a) {\n\treturn fract(abs(sin(a.ywxz*766.345)+cos(normalize(a)*4972.92855))*2048.97435+abs(a.wxyz)*.2735);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float time = iTime;\n    vec2 uv = (fragCoord*2.-iResolution.xy)/iResolution.y;\n\n\tfloat s = 0.;\n\tfor (float p = 1.; p < 1000.; p += 1.+p*.1) {\n\t\tvec4 pp = hash(p*vec4(.01,.1,1.,10.));\n\t\ts += cos((time*-.5+log(length(uv.xy-(pp.xy*2.-1.))))*p)/p;\n\t}\n\ts = pow(clamp(s*.25+.5,0.,1.),2.2);\n\tfragColor = vec4(mix(vec3(.3,.6,1.)*.3,vec3(1.,.8,.1),s),1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WdKfWd.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 152, 171, 171, 272], [275, 275, 332, 332, 684]]}
{"id": "wdyfDG", "name": "concentric circles experiment", "author": "dbu", "description": "just toying around", "tags": ["experiment", "learning"], "likes": 5, "viewed": 46, "published": "Public", "date": "1611000070", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float circle(vec2 coord, vec2 center, float radius) {\n    float d = length((coord - center) / iResolution.y);\n \n    return smoothstep(radius,radius - 1.5/iResolution.y, d) ;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{ \n    float col = .0;\n    \n    for (float i = 0.; i<15.; i++) {\n    \tvec2 center = (vec2(.5,.5)* iResolution.xy);\n        center.x += sin(.5*iTime+i)*iResolution.x*.02;\n        center.y += cos(.5*iTime+i)*iResolution.x*.02;\n\n        // how to smooth inner circle edges too?\n        col += circle(fragCoord, center, 0.1+0.08*i+0.03*sin(iTime+cos(i)));\n    }\n    \n    col = mod(col, 2.);\n    if (col > 1.) col = 2. - col;\n    \n    // add rays from the center as well\n    \n    fragColor = vec4(vec3(col),1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wdyfDG.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 53, 53, 175], [177, 177, 234, 234, 742]]}
{"id": "wl3Bzr", "name": "NO1.", "author": "bey", "description": "First try", "tags": ["color"], "likes": 1, "viewed": 163, "published": "Public API", "date": "1612092417", "time_retrieved": "2021-10-01T00:00:00", "image_code": "mat2 rot(float deg)\n{    \n    return mat2(cos(deg),-sin(deg),\n                sin(deg), cos(deg));\n        \n}\n\n\nvoid mainImage( out vec4 f, in vec2 fC )\n{\n    float t = iTime;\n\tvec2 uv = fC.xy / iResolution.xy;\n    \n\tuv-=.5;\n    uv*=15.;\n    \n    uv*=rot(uv.y/5.-t*.15);\n    uv-=sin(sqrt(uv.x*uv.x+uv.y*uv.y)-t*2.)*3.;\n    uv.y+=sin(uv.x-t)*1.2;\n    uv-=sin(sqrt(uv.x*uv.x+uv.y*uv.y)+t)*.6;\n    uv.x+=sin(uv.y*1.4+t)*.6;\n    \n    \n    uv*=rot(uv.x/5.-t*.8);\n    uv.x/=length(.75*uv);\n\tuv.y/=length(.75*uv);\n    //uv+=length(uv-.5);\n    f = vec4(sin(uv.x-t*.6),sin(uv.y+uv.y-t*.7),sin(uv.x+uv.y-t*.8),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wl3Bzr.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 21, 21, 109], [112, 112, 154, 154, 607]]}
{"id": "Wl3cDf", "name": "experimental triple spiral thang", "author": "HaleyHalcyon", "description": "a", "tags": ["spiral"], "likes": 7, "viewed": 90, "published": "Public", "date": "1609991840", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const float PI = 3.14159265358979;\nconst mat4x3 colors = mat4x3(\n    1.0, 0.7, 0.9,\n    1.0, 0.5, 0.6,\n    0.3, 0.5, 0.7,\n    0.5, 0.6, 0.9\n);\n\n// xor-ish behavior for floats\nfloat flXor(float x, float y) {\n    return x + y - 2. * (x * y);\n}\n\n// folds 0>1>2>3>4... to 0>1<0>1<0...\nfloat fold(float x) {\n    return abs(1. - mod(x, 2.));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Scales pixel coordinates, so that\n    // the center is distance 0 and\n    // diagonals are distance 1\n    vec2 uvR = 2. * fragCoord - iResolution.xy;\n    vec2 uv = uvR / length(iResolution.xy);\n\n    float lenSq = log(length(uv));\n    float lenAdd = -0.2;\n    // logx/dx = 1/x\n    float blur = 4.0 / max(0.1, length(uvR));\n    float angle = atan(uv.y, uv.x) / PI;\n    \n    float timeScale = iTime * PI * 0.125;\n    \n    float spiral1 = smoothstep(0.5 - blur, 0.5 + blur, fold(\n         (lenSq + lenAdd) * 0.8\n       + angle * 2.\n       - iTime\n    ));\n       \n    float spiral2 = smoothstep(0.5 - blur, 0.5 + blur, fold(\n         (lenSq + lenAdd) * 1.0\n       - angle * 3.\n       - iTime\n    ));\n    vec3 colA = mix(colors[0], colors[1], vec3(flXor(spiral1, spiral2)));\n\n    \n    float spiral3 = smoothstep(0.2 - blur, 0.2 + blur, fold(\n         (lenSq + lenAdd) * 0.7\n       + angle * 5.\n       - iTime\n    ));\n       \n    float spiral4 = smoothstep(0.3 - blur, 0.3 + blur, fold(\n         (lenSq + lenAdd) * 1.4\n       - angle * 1.\n       - iTime\n    ));\n    vec3 colB = mix(colors[2], colors[3], vec3(spiral3 * spiral4));\n    \n    float which = smoothstep(0.5 - blur * 0.5, 0.5 + blur * 0.5, fold(\n        lenSq * (1.0 + 0.5 * sin(timeScale))\n      - angle\n      + iTime * 0.8\n    ));\n    \n    vec3 col = mix(colA, colB, which);\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Wl3cDf.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[144, 175, 206, 206, 241], [243, 281, 302, 302, 337], [339, 339, 396, 505, 1791]]}
{"id": "wl3yDN", "name": "ray marching color", "author": "ShyguyBerlin", "description": "A shader for rendering with ray marching, shows the position based color assignment", "tags": ["raymarching", "fractals", "skybox"], "likes": 0, "viewed": 90, "published": "Public API", "date": "1610735130", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define renderDist 10000.\n#define SUR_ACC 0.01\nvec3 rotate(vec3 Coords,vec3 EulerAngles)\n{\n    vec3 realCoords=  vec3(0.,0.,0.);\n    \n    realCoords.x=Coords.x*cos(EulerAngles.z)-Coords.y*sin(EulerAngles.z);\n    realCoords.y=Coords.y*cos(EulerAngles.z)+Coords.x*sin(EulerAngles.z);\n    \n    realCoords.z=Coords.z*cos(EulerAngles.x)-realCoords.y*sin(EulerAngles.x);\n    realCoords.y=realCoords.y*cos(EulerAngles.x)+Coords.z*sin(EulerAngles.x);\n    \n    realCoords.x=realCoords.x*cos(EulerAngles.y)-realCoords.z*sin(EulerAngles.y);\n    realCoords.z=realCoords.z*cos(EulerAngles.y)+realCoords.x*sin(EulerAngles.y);\n    return realCoords;\n}\n\nvec4 skybox(vec2 fakeCoords, vec3 EulerAngles)\n{\n    vec3 Coords =  vec3(fakeCoords.x,fakeCoords.y,sqrt(sqrt(0.5*0.5*2.)-length(fakeCoords)));\n    vec3 realCoords=  rotate(Coords,EulerAngles);\n    \n    vec3 hue=vec3(15./255.,125./215.,1.)*1.;\n    float value=0.+1.2*abs(abs(realCoords.y)-1.);\n    return vec4(hue*value,1);\n}\nfloat Box(vec3 p, float size){\nvec3 q=abs(p)-size;\nreturn length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\nfloat recursiveHallowBox(vec3 p, float size, int i){\n\n\nwhile(i>0){\np=abs(p)-size/2.;\nsize*=1./3.;\n\np*=-1.;\nif(size<max(max(p.x,p.y),p.z)){\nif(p.x>=p.y&&p.x>=p.z){\np.x-=size;\n}else{\nif(p.y>p.x&&p.y>=p.z){\np.y-=size;\n}else{\nif(p.z>p.x&&p.z>p.y){\np.z-=size;\n}}}}\np*=-1.;\np+=size/2.;\ni--;\n}\nreturn Box(p,size) ;\n\n}\n\nfloat DE(vec3 coords)\n{\n//float kugel=distance(vec3(25.,25.,25.),coords)-2.;\n\nvec3 p=coords-vec3(sin(iTime)*15.,0.,30.);\n\n\n\nreturn min(recursiveHallowBox(p,10.,1),coords.y+20.);\n}\n\nvec3 GetNormal(vec3 p) {\n\tfloat d = DE(p);\n    vec2 e = vec2(.01, 0);\n    \n    vec3 n = d - vec3(\n        DE(p-e.xyy),\n        DE(p-e.yxy),\n        DE(p-e.yyx));\n    \n    return normalize(n);\n}\nfloat RayMarch (vec3 or, vec3 dir){\n    for(float i=0.;i<renderDist;){\n    \n    vec3 pos= i*dir+or;\n    float DE=DE(pos);\n    if(DE<SUR_ACC){\n    return i;\n    \n    }else{\n    i+=DE*0.9;\n    }\n    }\n    return renderDist;\n}\nfloat GetLight(vec3 p, vec3 lightPos) {\n    vec3 l = normalize(lightPos-p);\n    vec3 n = GetNormal(p);\n    \n    float dif = clamp(dot(n, l), 0., 1.);\n    float d = RayMarch(p+n*SUR_ACC*2., l);\n    if(d<length(lightPos-p)) dif *= .1;\n    \n    return dif;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    uv-=0.5;\n    vec2 muv=iMouse.xy/iResolution.xy;\n    muv-=0.5;\n    vec3 Camrotation= vec3(muv.y*6.,-muv.x*6.,0);;\n    vec3 CamPosition= vec3(0,5,mod(iTime,80.)*0.-20.);\n    vec3 LightPos =vec3(-10.,10.,-10.);//vec3(2,-5,300);\n    \n    vec4 color;\n    vec3 albedo= vec3(1,0,0);\n    float renderdistance=0.1;\n    float fov=3.14159/4.;\n    float XtoYratio=iResolution.y/iResolution.x;\n    //vec3 movVec=vec3(sin(fov*uv.x),sin(fov*uv.y)*XtoYratio,cos(fov*uv.x));\n    \n    vec3 movVec=normalize(vec3(uv.x,uv.y*XtoYratio,1));\n    movVec=normalize(rotate(movVec,Camrotation));\n    float accuracy=0.000001;\n    \n    \n    \n\n    \n    //Ray march\n    float d=RayMarch(CamPosition,movVec);\n    vec3 renderpos=CamPosition+movVec*d;\n    \n    \n    if(renderpos.x>0.){\n    albedo=vec3(1.-renderpos.x/(renderpos.x+1.),0.,renderpos.x/(renderpos.x+1.));\n    }\n    \n    bool weirdwaytoshade=false;\n    \n    if(d>=renderDist){\n    color=skybox(uv,Camrotation);\n    }else{\n    \n    if(weirdwaytoshade){\n        float lightlevel=1.;\n        vec3 LightVec=normalize(LightPos-renderpos);\n            for(float i=SUR_ACC*3.;i<renderDist;){\n\n            vec3 pos= i*LightVec+renderpos;\n            float DE=min(DE(pos),distance(pos,LightPos));\n\n            if(DE<accuracy){\n            if(distance(pos,LightPos)>accuracy){\n            lightlevel*=0.01;\n            }\n\n            break;\n\n            }else{\n            i+=DE*0.5;\n            }\n            lightlevel*=0.98;\n            }\n\n        color=vec4(albedo*lightlevel,1);\n        \n    }else{\n    color=vec4(albedo*GetLight(renderpos,LightPos),1);\n    }\n    }\n    //fragColor=vec4(uv.x,uv.y,0.,0.);\n    fragColor= color;\n}\n", "image_inputs": [{"id": "4dXGR8", "previewfilepath": "/media/previz/buffer00.png", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/previz/buffer00.png", "ctype": "buffer"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wl3yDN.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[47, 47, 90, 90, 636], [638, 638, 686, 686, 962], [963, 963, 993, 993, 1075], [1076, 1076, 1128, 1128, 1386], [1388, 1388, 1411, 1464, 1567], [1569, 1569, 1593, 1593, 1762], [1763, 1763, 1798, 1798, 1986], [1987, 1987, 2026, 2026, 2242], [2244, 2244, 2301, 2301, 3997]]}
{"id": "Wl3yWB", "name": "Schröder’s staircase illusion", "author": "FabriceNeyret2", "description": "source: [url]https://www.boredpanda.com/schroder-staircase-illusion-of-the-year-contest/[/url]\nref image:\n[img]https://static.boredpanda.com/blog/wp-content/uploads/2021/01/1-5ff2d83c36f3f__700.jpg[/img]", "tags": ["illusion", "perception", "reproduction"], "likes": 6, "viewed": 282, "published": "Public API", "date": "1609785477", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// reusing hexastairs  https://shadertoy.com/view/3sGfWm\nfloat ease( float x ) {                              // rewritten from https://shadertoy.com/view/3ddBWB\n\treturn x > .5 ? x = 1.-x, 1. - 4.* x*x*x         // stepier than smoothstep or .5-.5*cos                  :                4.* x*x*x ;\n                  :                4.* x*x*x ;\n}\n\nvoid mainImage( out vec4 O, vec2 u )\n{\n    vec2 R = iResolution.xy,\n         U = 1.5* ( 2.*u  - R ) / R.y;\n         \n    float t = iTime/2., s, l;\n    U *= mat2( cos( 3.1416*( floor(t)+ease(fract(t)) + vec4(0,.5,-.5,0)) ) ); // rotation\n    l = length(U+vec2(.18,-.94));                          // for sphere\n    U += R/R.y;\n    \n    U *= mat2(1,0,.5,.87);                                 // parallelogram frame\n\n    vec3  V = vec3( U, U.y-U.x +3.);                       // 3 axial coords\n    ivec3 I = ivec3(floor(V));\n          I += I.yzx;\n    I.x += 4; I /= 3;                                      // I.xy = hexagon id\n // V = mod( V + vec3( I.y, I.y+I.x, I.x ), 2. ).yzx;      // local coords\n    V.xy = mod( V.yz + vec2( I.y+I.x, I.x ), 2. );         // local coords\n\n    O = mix(\n        vec4( \n          I.xy==ivec2(2,1)                                 // central cube\n            ? s = mod(4.5*V.y-1.,2.)-1.,                   // strip slope  for stairs. Side dents below\n              abs( .1+2.*V.x-V.y +(abs(s)-5.5)/4.5 ) > .9 ? .5 : s < 0. ? .3 : 1. // draw stairs\n            : 0.                                           // background\n        ),\n        vec4(sqrt(max(0.,1.-l/.1)),0,0,0), smoothstep(4./R.y,0., l-.1) ); // red sphere\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Wl3yWB.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 57, 80, 161, 346], [348, 348, 386, 386, 1600]]}
{"id": "Wl3yWj", "name": "Rindows 95", "author": "404Glaciergargamel", "description": "Remix of [url]https://www.shadertoy.com/view/XstXR2[/url]", "tags": ["logo", "remix", "glitch", "windows", "fork", "weird", "error", "90s", "edit", "vaporwave", "aesthetics", "windows95", "win95"], "likes": 0, "viewed": 213, "published": "Public API", "date": "1609867487", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#ifdef GL_ES\nprecision mediump float;\n#endif\n\n#define PI 4.1415926535897932384626433832795\n\nconst float wave_amplitude = 0.086;\nconst float period = 3.*PI;\n\nfloat wave_phase() {\n    return iTime;\n}\n\nfloat square(vec2 st) {\n    vec2 bl = step(vec2(0.), st);       // bottom-left\n    vec2 tr = step(vec2(0.),1.0-st);   // top-right\n    return bl.x * bl.y * tr.x * tr.y;\n}\n\nvec4 frame(vec2 st) {\n    float tushka = square(st*mat2((2./5.8), 1., 1., (2./7.9)));\n    \n    mat2 sector_mat = mat2(1./.16, 0., 0., 1./.22);\n    float sectors[4];\n    sectors[0] = square(st * sector_mat + (2./.26)*vec2(0.001,-0.380));\n    sectors[1] = square(st * sector_mat + (2./.26)*vec2(0.001,-0.070));\n    sectors[2] = square(st * sector_mat + (2./.26)*vec2(-0.340,-0.380));\n    sectors[3] = square(st * sector_mat + (2./.26)*vec2(-0.340,-0.070));\n    vec3 sector_colors[4];\n    sector_colors[0] = vec3(1.041, 0.539, 0.504) * sectors[0];\n    sector_colors[1] = vec3(0.535, 0.782, 0.943) * sectors[1];\n    sector_colors[2] = vec3(0.759, 0.908, 0.606) * sectors[2];\n    sector_colors[3] = vec3(1.096, 0.959, 0.214) * sectors[3];\n    \n    return vec4(vec3(sector_colors[0] + sector_colors[1] +\n                     sector_colors[2] + sector_colors[3]), tushka);\n}\n\nvec4 trail_piece(vec2 st, vec2 index, float scale) {\n    scale = index.x * 0.092 + 0.552;\n    \n    vec3 color;\n    if (index.y > 1.0 && index.y < 3.1 ) {\n        color = vec3(0.535, 0.782, 0.943);\n        scale *= .9;\n    } else if (index.y > 4.9 && index.y < 6.1) {\n        color = vec3(1.041, 0.539, 0.504);\n        scale *= .9;\n    } else {\n        color = vec3(1., 1., 1.);\n    }\n    \n    float scale1 = 2./scale;\n    float shift = - (2.-scale) / (3. * scale);\n    vec2 st2 = vec2(vec3(st, 2.) * mat3(scale1, 1., shift, 1., scale1, shift, 1., 1., 2.));\n    float mask = square(st2);\n\n    return vec4( color, mask );\n}\n\nvec4 trail(vec2 st) {\n    // actually 1/width, 1/height\n    const float piece_height = 8. / .79;\n    const float piece_width = 7. / .64;\n  \n    // make distance between smaller segments slightly lower\n    st.x = 2.2760 * pow(st.x, 4.0) - 2.4624 * st.x*st.x + 2.4154 * st.x;\n    \n    float x_at_cell = floor(st.x*piece_width)/piece_width;\n    float x_at_cell_center = x_at_cell + 0.026;\n    float incline = cos(0.6*period + wave_phase()) * wave_amplitude;\n    \n    float offset = sin(x_at_cell_center*period + wave_phase())* wave_amplitude + \n        incline*(st.x-x_at_cell)*6.452;\n    \n    float mask = step(offset, st.y) * (1.-step(.79+offset, st.y)) * step(0., st.x);\n    \n    vec2 cell_coord = vec2((st.x - x_at_cell) * piece_width,\n                           fract((st.y-offset) * piece_height));\n    vec2 cell_index = vec2(x_at_cell * piece_width, \n                           floor((st.y-offset) * piece_height));\n    \n    vec4 pieces = trail_piece(cell_coord, cell_index, 0.852);\n    \n    return vec4(vec3(pieces), pieces.a * mask);\n}\n\nvec4 logo(vec2 st) {\n    if (st.x <= .64) {\n        return trail(st);\n    } else {\n        vec2 st2 = st + vec2(0.1, -sin(st.x*period + wave_phase())*wave_amplitude);\n        return frame(st2 + vec2(-.64, -0.1));\n    }\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 st = fragCoord.xy/iResolution.xy;\n    st.x *= iResolution.x/iResolution.y;\n\n    st += vec2(-.1);\n    st *= 2.472;\n    st += vec2(-0.8,-0.78);\n    float rot = PI*-0.224;\n    st *= mat2(cos(rot), sin(rot), -sin(rot), cos(rot));\n    vec3 color = vec3(2.);\n    \n    vec4 logo_ = logo(st);    \n    fragColor = mix(vec4(0.1,.6,.6,2.000), logo_, logo_.a);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Wl3yWj.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[157, 157, 177, 177, 197], [199, 199, 222, 222, 369], [371, 371, 392, 392, 1238], [1240, 1240, 1292, 1292, 1861], [1863, 1863, 1884, 1918, 2904], [2906, 2906, 2926, 2926, 3126], [3128, 3128, 3185, 3185, 3545]]}
{"id": "Wl3yWl", "name": " faster raymarching test", "author": "gaz", "description": "3d", "tags": ["3d"], "likes": 3, "viewed": 140, "published": "Public", "date": "1610115524", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void lookAt(inout vec3 rd,vec3 ro,vec3 ta,vec3 up){\n    vec3 w=normalize(ta-ro),u=normalize(cross(w,up));\n    rd=rd.x*u+rd.y*cross(u,w)+rd.z*w;\n}\n\nvoid rot(inout vec3 p,vec3 a,float t){\n\ta=normalize(a);\n\tvec3 u=cross(a,p),v=cross(a,u);\n\tp=u*sin(t)+v*cos(t)+a*dot(a,p);   \n}\n\n\n// https://www.shadertoy.com/view/4djSRW\nvec3 hash31(float p)\n{\n   vec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973));\n   p3 += dot(p3, p3.yzx+33.33);\n   return fract((p3.xxy+p3.yzz)*p3.zyx); \n}\n\n\nfloat map(vec3 p)\n{\n\trot(p,vec3(cos(iTime*.3),sin(iTime*.3),1),iTime*.3);\n    float d=1.;\n    for(float i=0.;i<80.;i++)\n    {\n        vec3 c=hash31(i+123.1)*2.-1.;\n        c*=2.;\n        d=min(d,length(p-c)-.3);\n    }\n    return d;\n}\n\nvec3 calcNormal(vec3 p)\n{\n  vec3 n=vec3(0);\n  for(int i=0; i<4; i++){\n    vec3 e=.001*(vec3(9>>i&1, i>>1&1, i&1)*2.-1.);\n    n+=e*map(p+e);\n  }\n  return normalize(n);\n}\n\nfloat fixedMarch(vec3 ro, vec3 rd, float pitch, float near, float far)\n{\n    float t=near,d;\n    for(int i=0;i<50;i++)\n    {\n        d=map(ro+rd*t);\n        if (d<.001) return t;\n        if (t>=far) return far;\n        t+=pitch;\n    }\n    return far;\n}\n\nfloat march(vec3 ro, vec3 rd, float near, float far)\n{\n    float t=near,d;\n    for(int i=0;i<100;i++)\n    {\n        t+=d=map(ro+rd*t);\n        if (d<.001) return t;\n        if (t>=far) return far;\n    }\n    return far;\n}\n\nfloat calcShadow(vec3 light, vec3 ld, float len)\n{\n\tfloat depth=march(light,ld,.01,len);\t\n\treturn step(len-depth,.01);\n}\n\nvec3 doColor(vec3 p)\n{\n    return vec3(.3,.5,.8)+cos(p*.2)*.5+.5;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord.xy*2.-iResolution.xy)/iResolution.y;\n    vec3 ro = vec3(0,0,8);\n    vec3 rd = normalize(vec3(uv,2));\n    vec3 ta =vec3(0);\n    lookAt(rd,ro,ta,vec3(0,1,0));    \n    vec3 col= vec3(0);\n    \n    // bounding sphere\n    float r=3.2;\n    vec3 o=vec3(0);\n    vec3 u=cross(o-ro,rd);\n    float h=sqrt(r*r-dot(u,u));\n    float g=dot(o-ro,rd);\n    float near=g-h;\n\tfloat far=g+h;\n    //near=0.;\n\n#if 1\n    float pitch = .3;\n    float t=fixedMarch(ro,rd,pitch,near,far);\n    if(t<far)t=march(ro,rd,t-pitch,far);\n#else\n    float t=march(ro,rd,near,far);\n#endif\n\n    if(t<far)\n    {\n        vec3 p=ro+rd*t;\n        col=doColor(p); \n        vec3 n=calcNormal(p);      \n\t\tvec3 lightPos=ro+vec3(0,3,0);\n    \tvec3 li=lightPos-p;\n\t\tfloat len=length(li);\n\t\tli/=len;\n\t\tfloat dif=clamp(dot(n,li),0.,1.);\n        float sha=calcShadow(lightPos,-li,len);\n        col*=max(sha*dif,.2);\n        float rimd=pow(clamp(1.-dot(reflect(-li,n),-rd),0.,1.),2.5);\n\t\tfloat frn=rimd+2.2*(1.-rimd);\n    \tcol*=frn*.6;\n        col*=max(.5+.5*n.y,.3);\n        col*=exp2(-2.*pow(max(0.,1.-map(p+n*.8)/.8),2.));\n    }\n    fragColor.xyz=col;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Wl3yWl.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 51, 51, 145], [147, 147, 185, 185, 273], [276, 317, 339, 339, 472], [475, 475, 494, 494, 708], [710, 710, 735, 735, 878], [880, 880, 952, 952, 1132], [1134, 1134, 1188, 1188, 1354], [1356, 1356, 1406, 1406, 1476], [1478, 1478, 1500, 1500, 1545], [1547, 1547, 1604, 1604, 2730]]}
{"id": "WlcBzr", "name": "Neural Knight - Test", "author": "oneshade", "description": "I tried creating an SDF of a guy (the mesh was described as being a cartoonish\nmobster) but the neural network disagreed and I ended up with this.", "tags": ["guy", "ai", "neuralnetwork", "siren", "knight", "meshtosdf", "mobster"], "likes": 3, "viewed": 72, "published": "Public", "date": "1612054838", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/*\nTrying out blackle's mesh to SDF siren network notebook.\nMesh source: https://people.sc.fsu.edu/~jburkardt/data/obj/al.obj\nGround truth: https://people.sc.fsu.edu/~jburkardt/data/obj/al.png\n\nI tried using it to create an SDF of a guy (the mesh was described as being a cartoonish\nmobster) but the neural network disagreed and I ended up with this.\n\nIn case you are interested here's my copy of the notebook:\nhttps://colab.research.google.com/drive/1zdP-LymbnhIzhxOEdZx39C0GBr4AzbFU?authuser=1#scrollTo=O2uKIwI5chcp\n*/\n\n// Smooth abs() by ollj (https://www.shadertoy.com/view/Ws2SDK):\n#define sabs(x, k) mix(0.5 / k * x * x + k * 0.5, abs(x), step(0.0, abs(x) - k))\n\nfloat sdNeuralGuy(in vec3 p) {\n    // The SDF is undefined outside the unit sphere\n    if (length(p) > 1.1) {\n        return length(p) - 0.9;\n    }\n\n    p = vec3(p.z, -sabs(p.x, 0.02), p.y);\n    vec4 f0_0=sin(p.y*vec4(1.10,4.23,.31,-.47)+p.z*vec4(.61,-1.66,-.70,-1.52)+p.x*vec4(-3.05,.39,2.67,-3.37)+vec4(4.47,-4.20,6.87,-1.76));\n    vec4 f0_1=sin(p.y*vec4(2.13,1.71,-1.55,3.30)+p.z*vec4(-2.24,1.68,3.70,2.21)+p.x*vec4(-.65,2.93,1.02,-2.82)+vec4(-1.42,2.31,5.44,6.00));\n    vec4 f0_2=sin(p.y*vec4(-.15,-3.64,3.45,3.88)+p.z*vec4(-1.10,2.45,-1.97,1.96)+p.x*vec4(-1.78,2.13,-1.37,.82)+vec4(.59,-3.16,-5.44,6.75));\n    vec4 f0_3=sin(p.y*vec4(-.10,1.31,-2.10,-2.22)+p.z*vec4(-1.61,3.93,.20,.20)+p.x*vec4(-2.34,-2.20,3.68,.42)+vec4(2.89,5.78,-.56,.59));\n    vec4 f1_0=sin(mat4(-.59,-.39,-.05,-.37,.50,-.22,-.48,-.36,-.41,-.68,.31,.12,-.33,.36,-.61,-.76)*f0_0+\n        mat4(-.40,-.32,.35,.04,-.22,.77,-.11,-.32,-.18,-.72,-.25,-.34,.25,-.09,-.11,.56)*f0_1+\n        mat4(.14,-.34,.47,-.84,.69,-.60,.06,-.49,-.51,.27,.85,.48,.74,.01,.17,.75)*f0_2+\n        mat4(-1.56,-.69,1.26,-.58,-.57,-.43,.29,.04,-.20,-.30,.50,.25,-.40,.26,-.01,-.33)*f0_3+\n        vec4(-2.24,-1.05,.67,.83))/1.0+f0_0;\n    vec4 f1_1=sin(mat4(.37,.05,.36,-.23,.43,.69,.93,-.48,-.09,-.11,.02,.39,.75,-.09,-.31,-.27)*f0_0+\n        mat4(.29,-.50,.45,-.46,1.19,.01,.46,-.13,-.32,.15,-.17,.11,.15,-.13,-.41,-.02)*f0_1+\n        mat4(.05,.59,.62,-.08,.60,-.65,.15,-.47,.14,.84,-.29,-.39,-.39,-.59,-.60,-.06)*f0_2+\n        mat4(-.73,-.17,-.01,-.02,-.18,.53,-.06,-.75,-.03,-.29,-.73,.51,.52,.15,-.20,.87)*f0_3+\n        vec4(-1.78,2.03,-.74,-1.06))/1.0+f0_1;\n    vec4 f1_2=sin(mat4(.13,-.72,-.14,.23,-.32,.09,.71,.57,-.24,1.16,-.02,-.49,-.80,-.55,.16,-.02)*f0_0+\n        mat4(.34,-.57,-.07,-.24,-.18,-.81,-.08,.74,-.06,-.17,.46,.60,-.15,-.13,.40,-.03)*f0_1+\n        mat4(-.26,.58,1.51,-.91,.11,-1.22,.32,.47,-.31,.56,-.36,-.20,.20,.08,.63,.12)*f0_2+\n        mat4(.16,1.05,-.57,-.36,-.14,.05,.61,.29,.05,.10,-.10,-.48,-.28,-.26,.55,-.18)*f0_3+\n        vec4(-.45,.89,1.70,2.01))/1.0+f0_2;\n    vec4 f1_3=sin(mat4(.08,-.56,.20,-.09,-.31,.15,.14,-.29,.28,.03,.23,.11,-.61,-.51,-.33,.36)*f0_0+\n        mat4(.63,-.92,-.20,-.13,.16,.17,-.38,.32,.31,.27,.28,-.51,-.11,-.61,-.11,-.26)*f0_1+\n        mat4(-.46,-.07,.82,1.14,.15,-.30,.93,.39,.57,.42,-.47,.21,-.34,-.13,-.06,-.57)*f0_2+\n        mat4(.22,-.18,-.31,.64,.04,-.33,.94,-.61,.17,.04,.44,.53,.17,-.24,.45,-.15)*f0_3+\n        vec4(-.20,-.22,2.08,-.74))/1.0+f0_3;\n    vec4 f2_0=sin(mat4(.02,-.45,.49,-.11,1.20,-.02,-.52,-1.08,-.09,-.19,.95,.63,.33,-.79,-.57,-1.00)*f1_0+\n        mat4(-.16,-.04,-.85,.42,-.79,-.57,.05,-.04,-.68,-.56,.16,-.71,-.23,-.12,-.35,-.45)*f1_1+\n        mat4(.91,-1.09,.00,-1.45,.91,-.04,.01,-.73,-1.51,.24,.26,-.20,-.49,.83,-.51,.79)*f1_2+\n        mat4(.38,.38,-1.29,.00,1.00,.11,-.89,-.67,1.47,.60,-.16,.62,-.60,.09,.05,.21)*f1_3+\n        vec4(.17,-.97,-1.08,3.60))/1.4+f1_0;\n    vec4 f2_1=sin(mat4(-.42,.03,.26,.01,1.28,.52,1.16,.14,.12,-.14,-.21,-.46,.01,-.40,-1.97,-.41)*f1_0+\n        mat4(.20,-.33,-.45,-.31,.23,-.11,-.46,-.09,.49,.57,-.30,-.05,.90,-.08,-.25,-.21)*f1_1+\n        mat4(-.17,-.61,-.56,1.13,.00,.22,-.08,-.43,.25,.02,-.57,-1.04,.80,-.37,.44,1.12)*f1_2+\n        mat4(1.08,-.13,.50,1.64,.41,.15,1.11,-.10,-.14,-.21,.93,-.29,-.21,-.67,-.56,.14)*f1_3+\n        vec4(-.56,-1.73,-.20,.88))/1.4+f1_1;\n    vec4 f2_2=sin(mat4(.09,.34,.07,-.65,-.63,-.78,-1.35,.63,.70,.87,-.13,.72,-.29,-.87,-2.10,-.30)*f1_0+\n        mat4(-.24,.26,1.39,.81,-.57,-.49,-.68,.38,.00,-.68,-.77,-.90,-.42,-.16,.58,.29)*f1_1+\n        mat4(-.95,-.26,-1.00,-1.50,-.77,.21,.05,.20,.75,-.70,-.24,.35,1.34,.35,.06,1.01)*f1_2+\n        mat4(-.15,.02,.05,1.41,.01,.36,.06,.17,-.44,.12,.36,-.17,1.12,-.94,.82,.29)*f1_3+\n        vec4(1.27,-.34,1.88,2.82))/1.4+f1_2;\n    vec4 f2_3=sin(mat4(-.13,.23,.41,-.10,.78,.03,-.30,-.17,.52,.69,.23,.19,2.79,.57,.03,.19)*f1_0+\n        mat4(-1.54,-.42,-1.12,.57,.57,-.62,-.04,-.88,.22,.49,.04,-.42,-1.39,-.03,-.27,.03)*f1_1+\n        mat4(2.55,1.16,-.23,.27,.40,-.15,.01,.65,-.03,.47,.60,-.59,-1.38,.90,-.52,-.59)*f1_2+\n        mat4(-.65,-.81,-1.18,.70,-.47,.53,-.06,-.01,-.87,-.25,-.50,.27,-.25,.55,-.20,.45)*f1_3+\n        vec4(.97,1.87,-.95,3.89))/1.4+f1_3;\n    return dot(f2_0,vec4(.05,-.09,-.07,-.06))+\n        dot(f2_1,vec4(-.07,-.09,-.03,-.08))+\n        dot(f2_2,vec4(-.07,-.05,-.05,.03))+\n        dot(f2_3,vec4(.03,-.12,.08,-.06))+\n        0.222;\n}\n\nfloat mapScene(in vec3 p) {\n    float c = cos(iTime), s = sin(iTime);\n    p.xz *= mat2(c, -s, s, c);\n    return sdNeuralGuy(p);\n}\n\nvec3 getNormal(in vec3 p) {\n    vec3 e = vec3(0.01, 0.0, 0.0);\n    return normalize(vec3(mapScene(p + e.xyy) - mapScene(p - e.xyy),\n                          mapScene(p + e.yxy) - mapScene(p - e.yxy),\n                          mapScene(p + e.yyx) - mapScene(p - e.yyx)));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n    fragColor = vec4(0.0, 0.0, 0.0, 1.0);\n\n    vec3 ro = vec3(0.0, 0.0, 3.0);\n    vec3 rd = normalize(vec3(uv, -1.0));\n\n    vec3 p;\n    bool hit = false;\n    float t = 0.0;\n    for (int i=0; i < 100; i++) {\n        p = ro + rd * t;\n        float d = mapScene(p);\n        if (d < 0.001) {\n            hit = true;\n            break;\n        }\n\n        if (t > 10.0) {\n            break;\n        }\n\n        t += d;\n    }\n\n    if (hit) {\n        vec3 n = getNormal(p);\n        vec3 l = vec3(-0.58, 0.58, 0.58);\n        fragColor.rgb += max(0.2, dot(n, l));\n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WlcBzr.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[522, 669, 699, 751, 5051], [5053, 5053, 5080, 5080, 5182], [5184, 5184, 5211, 5211, 5457], [5459, 5459, 5514, 5514, 6141]]}
{"id": "wlccDf", "name": "My First Basic Ray Marcher", "author": "CrazySheep05", "description": "My first ray marcher based off this tutorial:\nhttps://www.youtube.com/watch?v=PGtv-dBi2wE\n\nI have added light attenuation, an emissive material and reflections, although they are slightly buggy.\n\nEdit: The reflections have been fixed.", "tags": ["raymarching"], "likes": 1, "viewed": 64, "published": "Public", "date": "1610110233", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//Shader designed based of this tutorial: https://www.youtube.com/watch?v=PGtv-dBi2wE\n//Tutorial project: https://www.shadertoy.com/view/XlGBW3\n\n#define MAXDIS 100.\n#define MAXSTEP 100\n#define SURFDIS 0.001\n#define LIGHTINTENSITY 5.\n#define LIGHTCOL vec3(1,.0,.5)\n\nfloat GetDis(vec3 p)\n{\n\tvec4 s = vec4(0, 1.05, 6, 1);\n    \n    float sd =  abs(length(p-s.xyz)-s.w)-.1;\n    float pd = p.y-1.;\n    \n    float d = max(sd, pd);\n    pd = p.y;\n    d=min(d,pd);\n    //d = min(d,cd);\n    //d=cd;\n    \n\ts = vec4(3, 1.05, 6, 1);\n    \n    sd =  abs(length(p-s.xyz)-s.w)-.1;\n    \n    d = min(d,sd);\n    \n\ts = vec4(1.5, 4, 7, 1);\n    \n    sd =  abs(length(p-s.xyz)-s.w)-.1;\n    \n    d = min(d,sd);\n    \n    return d;\n}\n\nfloat RayMarch(vec3 ro, vec3 rd)\n{\n    float d=.0;\n    \n    for(int i = 0; i<MAXSTEP; i++)\n    {\n        vec3 p = ro+rd*d;\n        float ds = GetDis(p);\n        d+=ds;\n        if(ds<SURFDIS || d>MAXDIS)\n        {\n            break;\n        }\n    }\n    \n    return(d);\n}\n\nvec3 GetNormal(vec3 p)\n{\n    float d = GetDis(p);\n    vec2 e = vec2(.01,0);\n    \n    vec3 n = d-vec3(\n    GetDis(p-e.xyy),\n    GetDis(p-e.yxy),\n    GetDis(p-e.yyx));\n    \n    return normalize(n);\n}\n\nvec3 TestMarch(vec3 ro, vec3 rd)\n{\n    float d=.0;\n    \n    for(int i = 0; i<MAXSTEP; i++)\n    {\n        vec3 p = ro+rd*d;\n        float ds = GetDis(p);\n        d+=ds;\n        if(ds<SURFDIS || d>MAXDIS)\n        {\n            break;\n        }\n    }\n    vec3 p = ro + rd * d;\n    p = p;\n    return(p);\n}\n\nvec3 GetLight (vec3 p)\n{\n    vec3 light = vec3(0,4.+sin(iTime),6);\n    vec3 l = normalize(light-p);\n    vec3 n = GetNormal(p);\n    \n    float diff = dot(n,l);\n    \n    float d = RayMarch(p+n*SURFDIS*2.,l);\n    if(d<length(light-p))\n    {\n        diff*=.1;\n    }\n    diff*=LIGHTINTENSITY/(length(p-light)*length(p-light));\n    \n    vec3 dir=normalize(vec3(0, 5, -1)-p);\n    \n    return max(diff,0.) * vec3(sin(iTime*5.)/2.+.5,0,.5);//LIGHTCOL;//+dot(n,-l)*0.1;\n}\n\nvec3 GetRef (vec3 p,vec3 dir)\n{\n    vec3 n = GetNormal(p);\n    vec3 diff=GetLight(RayMarch(p+n*SURFDIS*2.,reflect(dir,n))*normalize(reflect(dir,n)));\n    \n    return diff;\n}\n\nvec3 Emission(vec3 ro, vec3 rd)\n{\n    vec3 p = vec3(0,4.+sin(iTime),6);\n    vec4 s = vec4(p, 0.25);\n    float d=.0;\n    \n    for(int i = 0; i<MAXSTEP; i++)\n    {\n        vec3 p = ro+rd*d;\n        float ds = length(p-s.xyz)-s.w;\n        d+=ds;\n        if(ds<SURFDIS)\n        {\n            return vec3(sin(iTime*5.)/2.+.5,0,.5);\n        }\n        if(d>MAXDIS)\n        {\n            return vec3(0);\n        }\n    }\n    \n    return vec3(0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\n    \n    vec3 ro = vec3(0, 5.+1.0*cos(iTime), -1);\n    vec3 rd = normalize(vec3(uv.x, uv.y-0.3, 0.7));\n    \n    vec3 p = TestMarch(ro, rd);\n    \n    vec3 diff=GetLight(p);\n    \n    vec3 n = GetNormal(p);\n    vec3 pd = reflect(rd,n);\n    \n    //diff = max(GetLight(TestMarch(p+n*SURFDIS*2.,pd)),diff);\n    float ref = 0.2;\n    diff *= 1.-ref;\n    diff += ref*GetLight(TestMarch(p+n*SURFDIS*2.,pd));\n    \n    vec3 col = diff;\n    col+=Emission(ro, rd);\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wlccDf.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 265, 287, 287, 705], [707, 707, 741, 741, 976], [978, 978, 1002, 1002, 1175], [1177, 1177, 1211, 1211, 1478], [1480, 1480, 1504, 1504, 1941], [1943, 1943, 1974, 1974, 2116], [2118, 2118, 2151, 2151, 2556], [2558, 2558, 2615, 2615, 3164]]}
{"id": "wlccDX", "name": "simple 3d - by intrakits", "author": "intrakits", "description": "example of a simple 3d object with motion.", "tags": ["3d", "orbit", "rotation"], "likes": 1, "viewed": 172, "published": "Unlisted", "date": "1610008302", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float DistLine(vec3 ro, vec3 rd, vec3 p){\n    //distance from ray to point\n    return length(cross(p-ro,rd))/length(rd);\n}\nfloat DrawPoint(vec3 ro, vec3 rd, vec3 p){\n    //get distance from ro to p\n    float d = DistLine(ro, rd, p);\n    \n    //draw the point\n    d = smoothstep(0.1,0.07,d);\n    return d;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    uv-=0.5;\n    uv.x *= iResolution.x/iResolution.y;\n    //time\n    float t = iTime;\n    \n    //ray origin\n    vec3 ro = vec3(0.0, 0.0, -3.0);\n    \n    //ray direction\n\tvec3 rd = vec3(uv.x,uv.y, 0)-ro;\n    \n    //position of a point\n    vec3 p = vec3(sin(t)+1., 0.0, 2.+cos(t));\n    \n    //draw the point\n\tvec3 d = vec3(DrawPoint(ro,rd,p),0,0);\n    \n    //position of second point\n    p = vec3(sin(t), 0.0, 2.+cos(t));\n    \n    //draw the second point\n\td += vec3(0,0,DrawPoint(ro,rd,p));\n    \n   \n    p = vec3(sin(t),-0.6, 2.+cos(t));\n\td += vec3(0,DrawPoint(ro,rd,p),0);\n    \n    p = vec3(sin(t)+1.,-0.6, 2.+cos(t));\n\td += vec3(0,DrawPoint(ro,rd,p),0);\n    // Output to screen\n    fragColor = vec4(d,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wlccDX.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 41, 74, 122], [123, 123, 165, 197, 306], [307, 307, 364, 414, 1163]]}
{"id": "wlccR2", "name": "Aurora in the desert", "author": "butadiene", "description": "Imagine polar desert", "tags": ["raymarching"], "likes": 3, "viewed": 228, "published": "Public API", "date": "1610340202", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n// Description : GLSL 2D simplex noise function\n//      Author : Ian McEwan, Ashima Arts\n//  Maintainer : ijm\n//     Lastmod : 20110822 (ijm)\n//     License :\n//  Copyright (C) 2011 Ashima Arts. All rights reserved.\n//  Distributed under the MIT License. See LICENSE file.\n//  https://github.com/ashima/webgl-noise\n//\n//////////////////////////////////////////////////////////////////////////////////////////////\n// Some useful functions\nvec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec2 mod289(vec2 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec3 permute(vec3 x) { return mod289(((x*34.0)+1.0)*x); }\n\nfloat snoise(vec2 v) {\n\n    // Precompute values for skewed triangular grid\n    const vec4 C = vec4(0.211324865405187,\n                        // (3.0-sqrt(3.0))/6.0\n                        0.366025403784439,\n                        // 0.5*(sqrt(3.0)-1.0)\n                        -0.577350269189626,\n                        // -1.0 + 2.0 * C.x\n                        0.024390243902439);\n                        // 1.0 / 41.0\n\n    // First corner (x0)\n    vec2 i  = floor(v + dot(v, C.yy));\n    vec2 x0 = v - i + dot(i, C.xx);\n\n    // Other two corners (x1, x2)\n    vec2 i1 = vec2(0.0);\n    i1 = (x0.x > x0.y)? vec2(1.0, 0.0):vec2(0.0, 1.0);\n    vec2 x1 = x0.xy + C.xx - i1;\n    vec2 x2 = x0.xy + C.zz;\n\n    // Do some permutations to avoid\n    // truncation effects in permutation\n    i = mod289(i);\n    vec3 p = permute(\n            permute( i.y + vec3(0.0, i1.y, 1.0))\n                + i.x + vec3(0.0, i1.x, 1.0 ));\n\n    vec3 m = max(0.5 - vec3(\n                        dot(x0,x0),\n                        dot(x1,x1),\n                        dot(x2,x2)\n                        ), 0.0);\n\n    m = m*m ;\n    m = m*m ;\n\n    // Gradients:\n    //  41 pts uniformly over a line, mapped onto a diamond\n    //  The ring size 17*17 = 289 is close to a multiple\n    //      of 41 (41*7 = 287)\n\n    vec3 x = 2.0 * fract(p * C.www) - 1.0;\n    vec3 h = abs(x) - 0.5;\n    vec3 ox = floor(x + 0.5);\n    vec3 a0 = x - ox;\n\n    // Normalise gradients implicitly by scaling m\n    // Approximation of: m *= inversesqrt(a0*a0 + h*h);\n    m *= 1.79284291400159 - 0.85373472095314 * (a0*a0+h*h);\n\n    // Compute final noise value at P\n    vec3 g = vec3(0.0);\n    g.x  = a0.x  * x0.x  + h.x  * x0.y;\n    g.yz = a0.yz * vec2(x1.x,x2.x) + h.yz * vec2(x1.y,x2.y);\n    return 130.0 * dot(m, g);\n}\n\n#define OCTAVES 2\n\n// Ridged multifractal\n// See \"Texturing & Modeling, A Procedural Approach\", Chapter 12\nfloat ridge(float h, float offset) {\n    h = abs(h);     // create creases\n    h = offset - h; // invert so creases are at top\n    h = h * h;      // sharpen creases\n    return h;\n}\n\nfloat ridgedMF(vec2 p) {\n    float lacunarity = 2.0;\n    float gain = 0.5;\n    float offset = 0.9;\n\n    float sum = 0.0;\n    float freq = 1.0, amp = 0.5;\n    float prev = 1.0;\n    for(int i=0; i < OCTAVES; i++) {\n        float n = ridge(snoise(p*freq), offset);\n        sum += n*amp;\n        sum += n*amp*prev;  // scale by previous octave\n        prev = n;\n        freq *= lacunarity;\n        amp *= gain;\n    }\n    return sum;\n}\n\n/////////////////////////////////////////////////////////////////////////////////////////////\nfloat PI = 3.1415926535;\nvec3 MoonDirection = normalize(vec3(-0.5,0.4,-0.3));\nvec3 MoonColor = vec3(0.6,0.7,1.2);\nfloat random (vec2 st) {\n    return fract(sin(dot(st.xy,\n                         vec2(12.9898,78.233)))*\n        43758.5453123);\n}\n\nmat2 rot(float r){\n    return mat2(cos(r),sin(r),-sin(r),cos(r));\n}\n\nvec4 dist(vec3 p){\n    //p.z *= 0.7;\n    p.y -= 0.3;\n\tfloat d = 0.009;\n    float no = ridgedMF(p.xz+0.3*snoise(p.xz+0.1*iTime));\n    vec3 col = vec3(1,1,1)*0.02*exp(-no*3.);\n    float thredy = 0.5;\n    float thx = p.y-thredy;\n    vec3 highems = vec3(1.3,1.0,1.0)*max(thx*8.0*exp(-3.5*vec3(2.,1.2,1.5)*thx),0.);\n    col *= highems;\n    return vec4(col,d);\n}\n\nvec4 ground(vec3 p){\n    p.y -= 0.3;\n    p.x -= -0.;\n    float d = p.y - smoothstep(0.0,1.0,length(p.xz-vec2(-0.4,0.))*1.)*0.23*ridgedMF(vec2(0.9,1.)*(p.xz-vec2(-0.1,0.02*iTime)));\n    //d = max(d,-(length(p-vec3(-0.4,0.65,-0.6))-0.8));\n    vec3 col = vec3(0);\n    return vec4(col,d);\n}\n\nvec3 getnormal(vec3 p)\n{\n\tconst vec2 e = vec2(0.5773,-0.5773)*0.0001;\n\tvec3 nor = normalize( e.xyy*ground(p+e.xyy).w +\n \t\te.yyx*ground(p+e.yyx).w + e.yxy*ground(p+e.yxy).w + e.xxx*ground(p+e.xxx).w);\n\tnor = normalize(vec3(nor));\n\treturn nor ;\n}\n\n\nvec3 star(vec2 s){\n    vec3 c = vec3(snoise(s));\n    c = pow(c,vec3(5.));\n    c = clamp(7.*clamp(c-0.7,0.0,1.0),0.0,1000.0);\n  \n    return c;\n}\n\nvec3 background(vec3 rd){\n    vec2 rs = vec2(atan(length(rd.xy),rd.z),atan(rd.x,rd.y));\n    vec3 moon = 0.5*clamp(MoonColor*0.07/length(MoonDirection-rd),0.0,1.0);\n    return moon+star(rs*50.)*vec3(0.5)+vec3(0.7,0.5,0.5)*star(rs*50.+20.)+vec3(0.5,0.5,0.7)*star(rs*50.+70.);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 p = uv;\n    p = 2.0*(p-0.5);\n    p.x *= iResolution.x/iResolution.y;\n\n    vec3 offset = vec3(0,-0.4 ,0);\n    vec3 ro = vec3(0,0,0)-offset;\n    vec3 ta = vec3(0,1.6,-2)-offset;\n    vec3 cdir = normalize(ta-ro);\n    vec3 side = cross(cdir,vec3(0,1,0));\n    vec3 up = cross(side,cdir);\n    float fov = 0.4;\n   \n    vec3 rd = normalize(side*p.x+up*p.y+cdir*fov);\n     //rd.xz *= rot(iTime);\n    float d,t=0.;\n    float gd = 0.;\n    vec3 ac = vec3(0.);\n    vec4 disres;\n    float kset = 0.3;\n    float sen = (1.0+1.5*pow(abs(sin(iTime*kset))*(1.0-fract(iTime*kset/(0.5*PI))),1.));\n    \n    for(int i = 0;i<139;i++){\n    \tdisres = 2.0*dist(ro+rd*t)*sen;\n        d = disres.w;\n        gd = 0.5*ground(ro+rd*t).w;\n        d = min(gd,d);\n        t += d;\n\t\tac += disres.xyz;\n        if((ro+rd*t).z<-1.5)break;\n    }\n\n    vec3 col = vec3(0.);\n\n   \tcol += ac;\n    \n    col += background(rd);\n    \n    if(gd<0.01){\n        vec3 sp = ro+rd*t;\n        vec3 normal = getnormal(sp);\n        float snk = 1.;\n        vec3 cnormal = normal + 0.1*(vec3(random(snk*sp.yz),random(snk*sp.zx),random(snk*sp.xy))-0.5);\n        cnormal = normalize(cnormal);\n        col = 1.5*vec3(193,157,121)/255.*MoonColor*vec3(max(dot(cnormal,MoonDirection),0.));\n        col += MoonColor*0.02;\n        ac = vec3(0.0);\n        \n        vec3 snormal;\n        vec3 rrd;\n        for(int i =0; i<8; i++){\n            snormal =normal + 1.0*(vec3(random(snk*sp.yz+float(i)*100.),random(snk*sp.zx+float(i)*100.),random(snk*sp.xy+float(i)*100.))-0.5);\n            snormal = normalize(snormal);\n            t = 0.4;\n            ro = sp;\n            rrd =snormal;// reflect(rd,snormal);\n            for(int i = 0;i<10;i++){\n                disres = 6.0*dist(ro+rrd*t)*sen;\n                d = disres.w;\n                t += d;\n                ac += disres.xyz;\n            }\n        }\n        col += 0.1*ac;\n    \n    }\n    \n    // Output to screen\n\tcol = pow(col,vec3(0.8));\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wlccR2.jpg", "access": "shaders20k", "license": "mit", "functions": [[1, 439, 460, 460, 507], [508, 508, 529, 529, 576], [577, 577, 599, 599, 634], [636, 636, 658, 711, 2408], [2429, 2517, 2553, 2553, 2698], [2700, 2700, 2724, 2724, 3130], [3132, 3340, 3364, 3364, 3471], [3473, 3473, 3491, 3491, 3540], [3542, 3542, 3560, 3578, 3898], [3900, 3900, 3920, 3920, 4186], [4188, 4188, 4212, 4212, 4432], [4435, 4435, 4453, 4453, 4578], [4580, 4580, 4605, 4605, 4855], [4857, 4857, 4914, 4964, 6971]]}
{"id": "wlccRX", "name": "\"Blue\" hash-based TPDF dither", "author": "mystran", "description": "Pseudo-blue noise from a hash, with piece-wise inverting of the distribution to get a true TPDF at the end.", "tags": ["dither"], "likes": 0, "viewed": 66, "published": "Public", "date": "1609601388", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/*\n\nThis is a modified version of https://www.shadertoy.com/view/ldcfDH\n\nLike the original, this tries to approximate blue noise by sampling a hash at 5 points.\n\nUnlike the original, here we sample the points to the left and right, add them together\nto get a TPDF, which we then invert back into an RPDF by evaluating the CDF.\n\nThen we do the same for points above and below, then add the horizontal and vertical\nRPDF variables to get yet another TPDF that we invert once more.\n\nFinally, we sample the actual point, add with the RPDF computed from the 4 surrounding points\nand this time we keep the result as TPDF.\n\n*/\nconst float levels = 6.; // number of quantisation levels, must be at least 2 (preferably 4)\nconst float animFPS = 120.; // max framerate for temporal dither, set 0 to disable\nconst bool separateRGB = false; // use different random values for different channels?\nconst bool antiCompress = false; // expand near black and white to counter compression\n\nuint hash(uint x)\n{\n    x ^= x >> 16; x *= 0x7feb352du; \n    x ^= x >> 15; x *= 0x846ca68bu; \n    x ^= x >> 16;\n    return x;\n}\n\n// fetch random values for RGB channels\nvec3 hash2v(uint x, uint y)\n{\n    // take a hash, split it into components\n    uint h = hash(uint(x)+(uint(y)<<16));\n    vec3 v;\n    v.x = float(h&0xffu); if(separateRGB) h >>= 8;\n    v.y = float(h&0xffu); if(separateRGB) h >>= 8;\n    v.z = float(h&0xffu);\n    \n    return v / float(0xffu);\n}\n\nvec3 triCDF(vec3 x)\n{\n    vec3 y = sqrt(2.)*min(x, 1.-x); y *= y;\n    return mix(y, 1.-y, round(x));\n}\n\nvec3 dither(vec3 c, uvec2 xy)\n{\n    \n    // temporal dither\n    xy.x += uint(floor(animFPS*iTime)*12345.);\n    \n    // compute noise\n    vec3 xx = triCDF(.5 * (hash2v(xy.x-1u, xy.y) + hash2v(xy.x+1u, xy.y)));\n    vec3 yy = triCDF(.5 * (hash2v(xy.x, xy.y-1u) + hash2v(xy.x, xy.y+1u)));\n    vec3 mm = triCDF(.5 * (xx + yy));\n    \n    vec3 h = mm - hash2v(xy.x, xy.y);\n    float g = levels-1.;\n    \n    if(antiCompress)\n    {\n        // expand near black to counter compression\n        vec3 f0 = max(.5-c*g, 0.); c -= .5*f0*f0;\n        // expand near white to counter compression\n        vec3 f1 = max(.5-(1.-c)*g, 0.); c += .5*f1*f1;    \n    }\n    return round(c*g + h) / g;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    vec3 c = texture(iChannel0,uv.xy).xyz;\n    if(fragCoord.y < 0.05*iResolution.y) c = vec3(fragCoord.x / iResolution.x);\n    \n    if(abs(iMouse.x - fragCoord.x) < iResolution.x*.25) \n    {\n        c = dither(c, uvec2(fragCoord.xy));\n    }\n\telse if(iMouse.y < .5*iResolution.y) c = round(c*(levels-1.)) / (levels-1.);\n    \n    \n    // Output to screen\n    fragColor = vec4(c, 1.0);\n}", "image_inputs": [{"id": "4df3zn", "previewfilepath": "/media/ap/3405e48f74815c7baa49133bdc835142948381fbe003ad2f12f5087715731153.ogv", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/3405e48f74815c7baa49133bdc835142948381fbe003ad2f12f5087715731153.ogv", "ctype": "video"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wlccRX.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 970, 989, 989, 1097], [1099, 1139, 1168, 1213, 1431], [1433, 1433, 1454, 1454, 1535], [1537, 1537, 1568, 1596, 2211], [2213, 2213, 2270, 2320, 2746]]}
{"id": "WlccWl", "name": "MCubes Step 1 - Vertex Placement", "author": "oneshade", "description": "Trying to reinvent the wheel a bit to understand the marching cubes algorithm. Next step, connecting the dots (may or may not work well in a shader).", "tags": ["3d", "marchingcubes", "vertexplacement", "meshing"], "likes": 11, "viewed": 170, "published": "Public", "date": "1610120214", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// checkEdge() checks whether two point straddle the surface by checking for opposite signs\n#define checkEdge(a, b) (a < 0.0) != (b < 0.0)\n\n// vertexInterp() Solves for the intersection point linearly and interpolates the edge vertices (v1 and v2) accordingly\n#define vertexInterp(v1, v2, d1, d2) mix(v1, v2, d1 / (d1 - d2))\n\nfloat sdShape(in vec3 p) {\n    p /= 1.5;\n    vec3 q = abs(p) - 1.35;\n    float cube = max(q.x, max(q.y, q.z));\n    float sphere = length(p) - 1.6875;\n    float cylinder1 = length(p.yz) - 0.6;\n    float cylinder2 = length(p.xz) - 0.6;\n    float cylinder3 = length(p.xy) - 0.6;\n    return max(max(cube, sphere), -min(cylinder1, min(cylinder2, cylinder3))) * 1.5;\n}\n\nvec4 mapScene(in vec3 p) {\n    float csz = 0.6 + 0.5 * sin(iTime); // Cell size\n    float shape = sdShape(p);\n\n    vec3 c = floor(p / csz) * csz;\n\n    vec3 ldb_p = c;                       // (l)eft,  (d)own, (b)ack  cell corner\n    vec3 rdb_p = c + vec3(csz, 0.0, 0.0); // (r)ight, (d)own, (b)ack  cell corner\n    vec3 lub_p = c + vec3(0.0, csz, 0.0); // (l)eft,  (u)p,   (b)ack  cell corner\n    vec3 rub_p = c + vec3(csz, csz, 0.0); // (r)ight, (u)p,   (b)ack  cell corner\n    vec3 ldf_p = c + vec3(0.0, 0.0, csz); // (l)eft,  (d)own, (f)ront cell corner\n    vec3 rdf_p = c + vec3(csz, 0.0, csz); // (r)ight, (d)own, (f)ront cell corner\n    vec3 luf_p = c + vec3(0.0, csz, csz); // (l)eft,  (u)p,   (f)ront cell corner\n    vec3 ruf_p = c + csz;                 // (r)ight, (u)p,   (f)ront cell corner\n\n    float ldb = sdShape(ldb_p); // Distance field sample at cell corner ldb_p\n    float rdb = sdShape(rdb_p); // Distance field sample at cell corner rdb_p\n    float lub = sdShape(lub_p); // Distance field sample at cell corner lub_p\n    float rub = sdShape(rub_p); // Distance field sample at cell corner rub_p\n    float ldf = sdShape(ldf_p); // Distance field sample at cell corner ldf_p\n    float rdf = sdShape(rdf_p); // Distance field sample at cell corner rdf_p\n    float luf = sdShape(luf_p); // Distance field sample at cell corner luf_p\n    float ruf = sdShape(ruf_p); // Distance field sample at cell corner ruf_p\n\n    float i = 1000000.0;\n\n    // Checking all the cell edges for intersection and then calculating the intersection point\n    if (checkEdge(lub, luf)) i = min(i, length(p - vertexInterp(lub_p, luf_p, lub, luf)) - 0.1);\n    if (checkEdge(luf, ruf)) i = min(i, length(p - vertexInterp(luf_p, ruf_p, luf, ruf)) - 0.1);\n    if (checkEdge(ruf, rub)) i = min(i, length(p - vertexInterp(ruf_p, rub_p, ruf, rub)) - 0.1);\n    if (checkEdge(rub, lub)) i = min(i, length(p - vertexInterp(rub_p, lub_p, rub, lub)) - 0.1);\n    if (checkEdge(lub, ldb)) i = min(i, length(p - vertexInterp(lub_p, ldb_p, lub, ldb)) - 0.1);\n    if (checkEdge(luf, ldf)) i = min(i, length(p - vertexInterp(luf_p, ldf_p, luf, ldf)) - 0.1);\n    if (checkEdge(ruf, rdf)) i = min(i, length(p - vertexInterp(ruf_p, rdf_p, ruf, rdf)) - 0.1);\n    if (checkEdge(rub, rdb)) i = min(i, length(p - vertexInterp(rub_p, rdb_p, rub, rdb)) - 0.1);\n    if (checkEdge(ldb, ldf)) i = min(i, length(p - vertexInterp(ldb_p, ldf_p, ldb, ldf)) - 0.1);\n    if (checkEdge(ldf, rdf)) i = min(i, length(p - vertexInterp(ldf_p, rdf_p, ldf, rdf)) - 0.1);\n    if (checkEdge(rdf, rdb)) i = min(i, length(p - vertexInterp(rdf_p, rdb_p, rdf, rdb)) - 0.1);\n    if (checkEdge(rdb, ldb)) i = min(i, length(p - vertexInterp(rdb_p, ldb_p, rdb, ldb)) - 0.1);\n\n    return shape < i ? vec4(shape, 1.0, 1.0, 0.0) : vec4(i, 0.5, 0.5, 0.5);\n}\n\nvec3 getNormal(in vec3 p) {\n    return normalize(vec3(mapScene(p + vec3(0.001, 0.0, 0.0)).x - mapScene(p - vec3(0.001, 0.0, 0.0)).x,\n                          mapScene(p + vec3(0.0, 0.001, 0.0)).x - mapScene(p - vec3(0.0, 0.001, 0.0)).x,\n                          mapScene(p + vec3(0.0, 0.0, 0.001)).x - mapScene(p - vec3(0.0, 0.0, 0.001)).x));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n    fragColor = vec4(0.0, 0.0, 0.0, 1.0);\n\n    vec3 ro = vec3(0.0, 0.0, 10.0);\n    vec3 rd = normalize(vec3(uv, -1.0));\n\n    float c1 = cos(iTime), s1 = sin(iTime);\n    float c2 = c1, s2 = s1;\n\n    float t = 0.0;\n    for (float iters=0.0; iters < 150.0; iters++) {\n        vec3 p = ro + rd * t;\n        p /= 1.25;\n\n        p.xz *= mat2(c1, s1, -s1, c1);\n        p.yz *= mat2(c2, s2, -s2, c2);\n\n        vec4 d = mapScene(p);\n        if (d.x < 0.001) {\n            vec3 n = getNormal(p);\n            vec3 l = vec3(-0.58, 0.58, 0.58);\n\n            n.yz *= mat2(c2, -s2, s2, c2);\n            n.xz *= mat2(c1, -s1, s1, c1);\n\n            fragColor.rgb += d.yzw;\n            fragColor.rgb *= max(0.2, dot(n, l));\n            break;\n        }\n\n        if (t > 50.0) {\n            break;\n        }\n\n        t += d.x;\n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WlccWl.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[140, 326, 352, 352, 688], [690, 690, 716, 716, 3483], [3485, 3485, 3512, 3512, 3831], [3833, 3833, 3888, 3888, 4770]]}
{"id": "WlcfRn", "name": "coiled rope", "author": "iuryBorgesRodrigues", "description": "Based: https://www.shadertoy.com/view/3ddcW8", "tags": ["3d", "sdf", "coiled"], "likes": 2, "viewed": 63, "published": "Public", "date": "1612034481", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\nconst float PI= 3.14159265359;\n#define TYPE 4\nvec3 saturate(vec3 a) { return clamp(a, 0.0, 1.0); }\nvec2 saturate(vec2 a) { return clamp(a, 0.0, 1.0); }\nfloat saturate(float a) { return clamp(a, 0.0, 1.0); }\n\n\nmat3 rotate_x(float a){float sa = sin(a); float ca = cos(a); return mat3(vec3(1.,.0,.0),    vec3(.0,ca,sa),   vec3(.0,-sa,ca));}\nmat3 rotate_y(float a){float sa = sin(a); float ca = cos(a); return mat3(vec3(ca,.0,sa),    vec3(.0,1.,.0),   vec3(-sa,.0,ca));}\nmat3 rotate_z(float a){float sa = sin(a); float ca = cos(a); return mat3(vec3(ca,sa,.0),    vec3(-sa,ca,.0),  vec3(.0,.0,1.));}\n\n\nconst float TAU = 2.0 * PI;\n\nfloat glow = 0.0;\n\n\n\nfloat sdPlane(in vec3 p) {\n    return p.y;\n}\n\nfloat sdSphere(in vec3 p, float s) {\n    return length(p) - s;\n}\n\nfloat sdTorus(in vec3 p, in vec2 t) {\n    return length(vec2(length(p.xz) - t.x, p.y)) - t.y;\n}\n\nvec2 opUnion(vec2 d1, vec2 d2) {\n    return d1.x < d2.x ? d1 : d2;\n}\nfloat sdApple(vec3 p, float r) {\n\tp.y *= 0.95;\n\n\tp.xz *= 1.2;\n\n\tfloat k = 0.84 + 0.16 * smoothstep(-r, r, p.y);\n\tp.xz /= k;\n\treturn sdTorus(p, vec2((0.9 / 1.25) * r, r))*0.3;\n}\n\n\n\nfloat localTime = 0.0;\n\n\n\n\n\n\n\nfloat smin( float a, float b, float k )\n{\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\nvec2 matMin(vec2 a, vec2 b)\n{\n\tif (a.x < b.x) return a;\n\telse return b;\n}\n\n\nfloat sdBox(vec3 p, vec3 radius)\n{\n  vec3 dist = abs(p) - radius;\n  return min(max(dist.x, max(dist.y, dist.z)), 0.0) + length(max(dist, 0.0));\n}\n\n\n\n\n\n\nmat2 mm2(in float a){float c = cos(a), s = sin(a);return mat2(c,-s,s,c);}\n\nvec3 fold(in vec3 p)\n{\n    const vec3 nc = vec3(-0.5,-0.809017,0.309017);\n    for(int i=0;i<5;i++)\n    {\n\t\tp.xy = abs(p.xy);\n\t\tfloat t = 2.*min(0.,dot(p,nc));\n\t\tp -= t*nc;\n\t}\n    return p;\n}\n\nfloat smax(float a, float b)\n{\n    const float k = 2.;\n    float h = 1.-clamp(.5 + .5*(b-a)/k, 0., 1.);\n    return mix(b, a, h) - k*h*(1.0-h);\n}\n\nfloat tri(in float x){return abs(fract(x)-0.5)*2.;}\n\nfloat solid(in vec3 p)\n{\n    float time=iTime;\n    vec3 fp = fold(p) - vec3(0.,0.,1.275);\n    float d = mix(dot(fp,vec3(.618,0,1.)), length(p)-1.15,-3.6);\n    \n    #if (TYPE == 1)\n    d += tri(fp.x*8.+fp.z*3.)*0.05+tri(fp.x*fp.y*40.+time*0.2)*0.07-0.17;\n    d += tri(fp.y*5.)*0.04;\n    d*= 0.9;\n    #elif (TYPE == 2)\n    d*= 0.7;\n    d += sin(time+fp.z*5.+sin(fp.x*20.*fp.y*8.)+1.1)*0.05-0.08;\n    d += sin(fp.x*20.*sin(fp.z*8.+time*0.2))*0.05;\n    d += sin(fp.x*20.*sin(fp.z*8.-time*0.3)*sin(fp.y*10.))*0.05;\n    #elif (TYPE == 3)\n    d = smax(d+.5, -(d+sin(fp.y*20.+time+fp.z*10.)+1.5)*0.3)*.55;\n    d += sin(max(fp.x*1.3,max(fp.z*.5,fp.y*1.))*35.+time)*0.03;\n    #else\n    d = smax(d+.5, -(d+sin(fp.z*10.+sin(fp.x*20.*fp.y*9.)+1.1)*0.3-0.3))*.5;\n    #endif\n    \n    return d*0.25;\n}\nvec2 toroidal (vec2 p, float r) { return vec2(length(p.xy)-r, atan(p.y,p.x)); }\nmat2 rot (float a) { float c=cos(a),s=sin(a); return mat2(c,-s,s,c); }\nfloat amod (inout vec2 p, float count) { float an = TAU/count; float a = atan(p.y,p.x)+an/2.; float c = floor(a/an); c = mix(c,abs(c),step(count*.5,abs(c))); a = mod(a,an)-an/2.; p.xy = vec2(cos(a),sin(a))*length(p); return c; }\nfloat sdCylinder (vec2 p, float r) { return length(p)-r; }\nfloat sdPlant (vec3 pos) {\n    \n    float dist;\n    float radius = 2.;\n    pos.y += 1.;\n    pos.xyz = pos.zxy;\n    vec3 p = pos;\n    p.xy = toroidal(p.xy, radius);\n    p.y *= 2.;\n    p.xz *= rot(p.y * 2.+sin(p.y+iTime));\n    float id = amod(p.xz,2.);\n    p.x -= .2;\n    p.xz *= rot(-p.y+iTime+sin(p.y-iTime*2.)*5.);\n    id += amod(p.xz, 4.);\n    p.x -= .1;\n    dist = sdCylinder(p.xz, .04);\n    \n    return dist;\n}\n\n\nvec2 scene(in vec3 position) {\n\n\n    vec3 p=position;\n    p-=vec3(0.0,1.2,0.0);\n    p/=vec3(0.8);\n    float solid=sdPlant(p)*0.3;\n  \n    \n   \n   \n    vec2 scene = opUnion(\n          vec2(sdPlane(position), 1.0),\n          vec2(solid, 12.0)\n    );\n    return scene;\n}\n\nvec4 boxmap( sampler2D sam, in vec3 p, in vec3 n, in float k )\n{\n    vec3 m = pow( abs(n), vec3(k) );\n\tvec4 x = texture( sam, p.yz );\n\tvec4 y = texture( sam, p.zx );\n\tvec4 z = texture( sam, p.xy );\n\treturn (x*m.x + y*m.y + z*m.z)/(m.x+m.y+m.z);\n}\n//------------------------------------------------------------------------------\n// Ray casting\n//------------------------------------------------------------------------------\n\nfloat shadow(in vec3 origin, in vec3 direction) {\n    float hit = 1.0;\n    float t = 0.02;\n    \n    for (int i = 0; i < 1000; i++) {\n        float h = scene(origin + direction * t).x;\n        if (h < 0.001) return 0.0;\n        t += h;\n        hit = min(hit, 10.0 * h / t);\n        if (t >= 2.5) break;\n    }\n\n    return clamp(hit, 0.0, 1.0);\n}\n\nvec2 traceRay(in vec3 origin, in vec3 direction) {\n    float material = -1.0;\n\n    float t = 0.02;\n    \n    for (int i = 0; i < 1000; i++) {\n        vec2 hit = scene(origin + direction * t);\n        if (hit.x < 0.002 || t > 20.0) break;\n        t += hit.x;\n        material = hit.y;\n    }\n\n    if (t > 20.0) {\n        material = -1.0;\n    }\n\n    return vec2(t, material);\n}\n\nvec3 normal(in vec3 position) {\n    vec3 epsilon = vec3(0.001, 0.0, 0.0);\n    vec3 n = vec3(\n          scene(position + epsilon.xyy).x - scene(position - epsilon.xyy).x,\n          scene(position + epsilon.yxy).x - scene(position - epsilon.yxy).x,\n          scene(position + epsilon.yyx).x - scene(position - epsilon.yyx).x);\n    return normalize(n);\n}\n\n//------------------------------------------------------------------------------\n// BRDF\n//------------------------------------------------------------------------------\n\nfloat pow5(float x) {\n    float x2 = x * x;\n    return x2 * x2 * x;\n}\n\nfloat D_GGX(float linearRoughness, float NoH, const vec3 h) {\n    // Walter et al. 2007, \"Microfacet Models for Refraction through Rough Surfaces\"\n    float oneMinusNoHSquared = 1.0 - NoH * NoH;\n    float a = NoH * linearRoughness;\n    float k = linearRoughness / (oneMinusNoHSquared + a * a);\n    float d = k * k * (1.0 / PI);\n    return d;\n}\n\nfloat V_SmithGGXCorrelated(float linearRoughness, float NoV, float NoL) {\n    // Heitz 2014, \"Understanding the Masking-Shadowing Function in Microfacet-Based BRDFs\"\n    float a2 = linearRoughness * linearRoughness;\n    float GGXV = NoL * sqrt((NoV - a2 * NoV) * NoV + a2);\n    float GGXL = NoV * sqrt((NoL - a2 * NoL) * NoL + a2);\n    return 0.5 / (GGXV + GGXL);\n}\n\nvec3 F_Schlick(const vec3 f0, float VoH) {\n    // Schlick 1994, \"An Inexpensive BRDF Model for Physically-Based Rendering\"\n    return f0 + (vec3(1.0) - f0) * pow5(1.0 - VoH);\n}\n\nfloat F_Schlick(float f0, float f90, float VoH) {\n    return f0 + (f90 - f0) * pow5(1.0 - VoH);\n}\n\nfloat Fd_Burley(float linearRoughness, float NoV, float NoL, float LoH) {\n    // Burley 2012, \"Physically-Based Shading at Disney\"\n    float f90 = 0.5 + 2.0 * linearRoughness * LoH * LoH;\n    float lightScatter = F_Schlick(1.0, f90, NoL);\n    float viewScatter  = F_Schlick(1.0, f90, NoV);\n    return lightScatter * viewScatter * (1.0 / PI);\n}\n\nfloat Fd_Lambert() {\n    return 1.0 / PI;\n}\n\n//------------------------------------------------------------------------------\n// Indirect lighting\n//------------------------------------------------------------------------------\n\nvec3 Irradiance_SphericalHarmonics(const vec3 n) {\n    // Irradiance from \"Ditch River\" IBL (http://www.hdrlabs.com/sibl/archive.html)\n    return max(\n          vec3( 0.754554516862612,  0.748542953903366,  0.790921515418539)\n        + vec3(-0.083856548007422,  0.092533500963210,  0.322764661032516) * (n.y)\n        + vec3( 0.308152705331738,  0.366796330467391,  0.466698181299906) * (n.z)\n        + vec3(-0.188884931542396, -0.277402551592231, -0.377844212327557) * (n.x)\n        , 0.0);\n}\n\nvec2 PrefilteredDFG_Karis(float roughness, float NoV) {\n    // Karis 2014, \"Physically Based Material on Mobile\"\n    const vec4 c0 = vec4(-1.0, -0.0275, -0.572,  0.022);\n    const vec4 c1 = vec4( 1.0,  0.0425,  1.040, -0.040);\n\n    vec4 r = roughness * c0 + c1;\n    float a004 = min(r.x * r.x, exp2(-9.28 * NoV)) * r.x + r.y;\n\n    return vec2(-1.04, 1.04) * a004 + r.zw;\n}\n\n//------------------------------------------------------------------------------\n// Tone mapping and transfer functions\n//------------------------------------------------------------------------------\n\nvec3 Tonemap_ACES(const vec3 x) {\n    // Narkowicz 2015, \"ACES Filmic Tone Mapping Curve\"\n    const float a = 2.51;\n    const float b = 0.03;\n    const float c = 2.43;\n    const float d = 0.59;\n    const float e = 0.14;\n    return (x * (a * x + b)) / (x * (c * x + d) + e);\n}\n\nvec3 OECF_sRGBFast(const vec3 linear) {\n    return pow(linear, vec3(1.0 / 2.2));\n}\n\n//------------------------------------------------------------------------------\n// Rendering\n//------------------------------------------------------------------------------\n\nvec3 hash3(vec2 p)\n{\n    vec3 q = vec3(\n\t\tdot(p,vec2(127.1,311.7)), \n\t\tdot(p,vec2(269.5,183.3)), \n\t\tdot(p,vec2(419.2,371.9))\n\t);\n\treturn fract(sin(q) * 43758.5453);\n}\n\nfloat noise(vec2 x)\n{\n\tvec2 p = floor(x);\n\tvec2 f = fract(x);\n\treturn mix(\n\t\tmix(\n\t\t\thash3(p + vec2(0.0, 0.0)).x,\n\t\t\thash3(p + vec2(1.0, 0.0)).x,\n\t\t\tsmoothstep(0.0, 1.0, f.x)\n\t\t),\n\t\tmix(\n\t\t\thash3(p + vec2(0.0, 1.0)).x,\n\t\t\thash3(p + vec2(1.0, 1.0)).x,\n\t\t\tsmoothstep(0.0, 1.0, f.x)\n\t\t),\n\t\tsmoothstep(0.0, 1.0, f.y)\n\t);\n}\n\n\nvec2 getUV(vec3 pos)\n{\n    vec3 nor = normal(pos);\n    float lon = atan(nor.x,nor.z)/3.14;\n    float lat = acos(nor.y)/3.14;\n    vec2 r = vec2(lat, lon);\n    \n    return r;\n}\nvec3 render(in vec3 origin, in vec3 direction, out float distance,vec2 uv) {\n    // Sky gradient\n    vec3 color = vec3(0.65, 0.85, 1.0) + direction.y * 0.72;\n\n    // (distance, material)\n    vec2 hit = traceRay(origin, direction);\n    distance = hit.x;\n    float material = hit.y;\n\n    // We've hit something in the scene\n    if (material > 0.0) {\n        vec3 position = origin + distance * direction;\n\n        vec3 v = normalize(-direction);\n        vec3 n = normal(position);\n        vec3 l = normalize(vec3(0.6, 0.7, -0.7));\n        vec3 h = normalize(v + l);\n        vec3 r = normalize(reflect(direction, n));\n\n        float NoV = abs(dot(n, v)) + 1e-5;\n        float NoL = saturate(dot(n, l));\n        float NoH = saturate(dot(n, h));\n        float LoH = saturate(dot(l, h));\n\n        vec3 baseColor = vec3(0.0);\n        float roughness = 0.0;\n        float metallic = 0.0;\n\n        float intensity = 2.0;\n        float indirectIntensity = 0.64;\n\n        if (material < 4.0)  {\n            // Checkerboard floor\n            float f = mod(floor(6.0 * position.z) + floor(6.0 * position.x), 2.0);\n            baseColor = 0.4 + f * vec3(0.6);\n            roughness = 0.1;\n        } else if (material < 16.0) {\n            // Metallic objects\n            baseColor = vec3(255.0,0.0,0.0)/255.0218,165,32;\n            roughness = 0.5;\n            metallic=0.5;\n        }\n\n        float linearRoughness = roughness * roughness;\n        vec3 diffuseColor = (1.0 - metallic) * baseColor.rgb;\n        vec3 f0 = 0.04 * (1.0 - metallic) + baseColor.rgb * metallic;\n\n        float attenuation = shadow(position, l);\n\n        // specular BRDF\n        float D = D_GGX(linearRoughness, NoH, h);\n        float V = V_SmithGGXCorrelated(linearRoughness, NoV, NoL);\n        vec3  F = F_Schlick(f0, LoH);\n        vec3 Fr = (D * V) * F;\n\n        // diffuse BRDF\n        vec3 Fd = diffuseColor * Fd_Burley(linearRoughness, NoV, NoL, LoH);\n\n        color = Fd + Fr;\n        color *= (intensity * attenuation * NoL) * vec3(0.98, 0.92, 0.89);\n\n        // diffuse indirect\n        vec3 indirectDiffuse = Irradiance_SphericalHarmonics(n) * Fd_Lambert();\n\n        vec2 indirectHit = traceRay(position, r);\n        vec3 indirectSpecular = vec3(0.65, 0.85, 1.0) + r.y * 0.72;\n        if (indirectHit.y > 0.0) {\n            if (indirectHit.y < 4.0)  {\n                vec3 indirectPosition = position + indirectHit.x * r;\n                // Checkerboard floor\n                float f = mod(floor(6.0 * indirectPosition.z) + floor(6.0 * indirectPosition.x), 2.0);\n                indirectSpecular = 0.4 + f * vec3(0.6);\n            } else if (indirectHit.y < 16.0) {\n                // Metallic objects\n                indirectSpecular = vec3(0.3, 0.0, 0.0);\n            }\n        }\n\n        // indirect contribution\n        vec2 dfg = PrefilteredDFG_Karis(roughness, NoV);\n        vec3 specularColor = f0 * dfg.x + dfg.y;\n        vec3 ibl = diffuseColor * indirectDiffuse + indirectSpecular * specularColor;\n\n        color += ibl * indirectIntensity;\n    }\n\n    return color;\n}\n\n//------------------------------------------------------------------------------\n// Setup and execution\n//------------------------------------------------------------------------------\n\nmat3 setCamera(in vec3 origin, in vec3 target, float rotation) {\n    vec3 forward = normalize(target - origin);\n    vec3 orientation = vec3(sin(rotation), cos(rotation), 0.0);\n    vec3 left = normalize(cross(forward, orientation));\n    vec3 up = normalize(cross(left, forward));\n    return mat3(left, up, forward);\n}\n// Camera\nvec2 glFragCoord;\nvec3 Ray( float zoom )\n{\n\treturn vec3( glFragCoord.xy-iResolution.xy*.5, iResolution.x*zoom );\n}\n\nvec3 Rotate( inout vec3 v, vec2 a )\n{\n\tvec4 cs = vec4( cos(a.x), sin(a.x), cos(a.y), sin(a.y) );\n\t\n\tv.yz = v.yz*cs.x+v.zy*cs.y*vec2(-1,1);\n\tv.xz = v.xz*cs.z+v.zx*cs.w*vec2(1,-1);\n\t\n\tvec3 p;\n\tp.xz = vec2( -cs.w, -cs.z )*cs.x;\n\tp.y = cs.y;\n\t\n\treturn p;\n}\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    // Normalized coordinates\n    vec2 p = -1.0 + 2.0 * fragCoord.xy / iResolution.xy;\n    vec2 uv= fragCoord.xy / iResolution.xy;\n    // Aspect ratio\n    p.x *= iResolution.x / iResolution.y;\n    \n    vec3 ray = Ray(1.8);\n\t\n\t\n\t\n\tray = normalize(ray);\n    vec3 localRay = ray;\n\n\tvec2 mouse = vec2(-.1,iTime*.01);\n\t\n\tmouse = vec2(.5)-iMouse.yx/iResolution.yx;\n\t\t\n\tfloat T = iTime*.0;\n\tvec3 pos = 3.0*Rotate( ray, vec2(.2,1.5-T)+vec2(-1.0,-7.0)*mouse );\n\t//pos += vec3(0,.3,0) + T*vec3(0,0,-1);\n    pos.y += .06-pos.z*.02; // tail is higher\n    pos.z += pos.z*.2; // centre on the end of the car we're looking at\n    pos.x += .3;//sign(pos.x)*.2*smoothstep(.0,.5,abs(pos.x)); // off-centre framingvec3 ray = Ray(1.8);\n\n\t\n\t\n\t\n\n    // Camera position and \"look at\"\n    vec3 origin = vec3(0.0, 2.0, 0.0);\n    vec3 target = vec3(0.0);\n\n    origin+=pos;\n\n    mat3 toWorld = setCamera(origin, target, 0.0);\n    vec3 direction = toWorld * normalize(vec3(p.xy, 2.0));\n\n    // Render scene\n    float distance;\n    vec3 color = render(origin, direction, distance,getUV(origin + direction*traceRay(origin, direction).x));\n\n    // Tone mapping\n    color = Tonemap_ACES(color);\n\n    // Exponential distance fog\n    color = mix(color, 0.8 * vec3(0.7, 0.8, 1.0), 1.0 - exp2(-0.011 * distance * distance));\n\n    // Gamma compression\n    color = OECF_sRGBFast(color);\n\n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WlcfRn.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[47, 47, 70, 70, 99], [100, 100, 123, 123, 152], [153, 153, 178, 178, 207], [210, 210, 233, 233, 338], [339, 339, 362, 362, 467], [468, 468, 491, 491, 595], [648, 648, 674, 674, 692], [694, 694, 730, 730, 758], [760, 760, 797, 797, 855], [857, 857, 889, 889, 925], [926, 926, 958, 958, 1102], [1136, 1136, 1177, 1177, 1270], [1272, 1272, 1301, 1301, 1345], [1348, 1348, 1382, 1382, 1493], [1500, 1500, 1521, 1521, 1573], [1575, 1575, 1597, 1597, 1765], [1767, 1767, 1797, 1797, 1911], [1913, 1913, 1935, 1935, 1964], [1966, 1966, 1990, 1990, 2751], [2752, 2752, 2785, 2785, 2831], [2832, 2832, 2852, 2852, 2902], [2903, 2903, 2943, 2943, 3131], [3132, 3132, 3168, 3168, 3190], [3191, 3191, 3217, 3217, 3605], [3608, 3608, 3638, 3638, 3874], [3876, 3876, 3940, 3940, 4122], [4123, 4301, 4350, 4350, 4644], [4646, 4646, 4696, 4696, 5019], [5021, 5021, 5052, 5052, 5372], [5374, 5545, 5566, 5566, 5614], [5616, 5616, 5677, 5762, 5959], [5961, 5961, 6034, 6126, 6326], [6328, 6328, 6370, 6450, 6504], [6506, 6506, 6555, 6555, 6603], [6605, 6605, 6678, 6735, 6948], [6950, 6950, 6970, 6970, 6993], [6995, 7179, 7229, 7313, 7671], [7673, 7673, 7728, 7785, 8045], [8047, 8249, 8282, 8338, 8524], [8526, 8526, 8565, 8565, 8608], [8610, 8786, 8806, 8806, 8952], [8954, 8954, 8975, 8975, 9272], [9275, 9275, 9297, 9297, 9449], [9450, 9450, 9526, 9546, 12501], [12503, 12689, 12753, 12753, 13005], [13006, 13034, 13058, 13058, 13130], [13132, 13132, 13169, 13169, 13384], [13387, 13387, 13442, 13472, 14828]]}
{"id": "wlcyDs", "name": "Vinyl in the pool", "author": "luckyballa", "description": "personal music project visual", "tags": ["2d", "noise", "light", "shadows", "vinyl"], "likes": 2, "viewed": 95, "published": "Public", "date": "1610223016", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec2 rand2D(vec2 n){\n    return fract(sin(vec2(dot(n, vec2(12.9898, 4.1414)))));\n}\n\nfloat voronoi2D(vec2 n, float time){\n    float dis = 0.9;\n    for(float y = 0.0; y <= 1.0; y++){\n        for(float x = 0.0; x <= 1.0; x++){\n            vec2 p = floor(n) + vec2(x, y);\n            float d = length((0.27 * sin(rand2D(p) * 24. + time * 2.0)) + vec2(x, y) - fract(n));\n            dis = min(dis, d);\n            }\n        }\n    return dis;\n}\n\nvec2 rotateUV(vec2 uv, float rotation, vec2 mid) {\n    return vec2(\n      cos(rotation) * (uv.x - mid.x) + sin(rotation) * (uv.y - mid.y) + mid.x,\n      cos(rotation) * (uv.y - mid.y) - sin(rotation) * (uv.x - mid.x) + mid.y\n    );\n}\n\nvec2 rotate(vec2 v, float angle) {\n    float cosA = cos(angle), sinA = sin(angle);\n    return v.x * vec2(cosA, sinA) + v.y * vec2(-sinA, cosA);\n}\n\nvec3 shade(vec2 uv, float obj, float size, float offset, float time) {\n    float scn = obj;\n    vec3  col = vec3(0.,.5,.5);\n    float s = 1.;\n    vec2 lightPos = vec2(-offset,  offset);\n    lightPos = rotate(lightPos, time  + 0.4);\n    \n    float dst = length(uv) - obj;\n    if(dst < .0001) { s -= 1.; }\n    col *= s;\n    col += 1.-smoothstep(0.,size,distance(uv,lightPos));\n    \n    return col;\n    \n}\n\nfloat random (in vec2 st) {\n    return fract(sin(dot(st.xy,\n                         vec2(12.9898,78.233)))*\n        43758.5453123);\n}\n\n// Based on Morgan McGuire @morgan3d\n// https://www.shadertoy.com/view/4dS3Wd\n\nfloat noise (in vec2 st) {\n    vec2 i = floor(st);\n    vec2 f = fract(st);\n\n    // Four corners in 2D of a tile\n    float a = random(i);\n    float b = random(i + vec2(1.0, 0.0));\n    float c = random(i + vec2(0.0, 1.0));\n    float d = random(i + vec2(1.0, 1.0));\n\n    vec2 u = f * f * (3.0 - 2.0 * f);\n\n    return mix(a, b, u.x) +\n            (c - a)* u.y * (1.0 - u.x) +\n            (d - b) * u.x * u.y;\n}\n\n#define OCTAVES 6\nfloat fbm (in vec2 st) {\n    float value = 0.0;\n    float amplitude = .5;\n    float frequency = 0.;\n    for (int i = 0; i < OCTAVES; i++) {\n        value += amplitude * noise(st);\n        st *= 2.;\n        amplitude *= .5;\n    }\n    return value;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = fragCoord/iResolution.xy;\n    uv -= .5;\n    uv.x *=  iResolution.x/iResolution.y;\n    uv *=1.7;\n    \n    float zooom = (1. + cos(iTime / 3.) / 10.);\n    vec2 ruv = uv *  zooom;\n    uv.y += sin(iTime / 2.) / 10.;\n    uv = rotateUV(ruv, sin(iTime / -4.), vec2(0.));\n     \n    float v = smoothstep(0.409, 0.41, length(ruv));\n    v = 1. - v;\n    float vCenter = smoothstep(0.2, 0.199, length(ruv));\n    float vSmallCenter = smoothstep(0.03, 0.031, length(ruv));\n    vec3 vCenterC = vCenter * vec3(0.25);\n    v -= (1. - v * sin(length(ruv) *800.)) * 0.04 * (1. - vCenter);\n\n    float vN = clamp((pow(voronoi2D(uv * 3., iTime / 4.), 2.)) + 0.25, 0.0, 1.0);\n    float fbmNoise = noise(uv * 20. + sin(length(uv) * 20. + iTime));\n\n    vec3 orange = vec3(1., 0.31, 3.);\n    vec3 blue = vec3(0.535, 0.38, 0.903);\n    vec3 lightBlue = vec3(0.46, 0.71, 0.87);\n    vec3 vC = blue;\n\n    vC = mix(vC, lightBlue, smoothstep(0.1, 0.9,  fbmNoise));\n    vC = mix(vC, orange,  smoothstep(0.6, 0.9, fbmNoise));\n    vC *= max(v, .0);\n    vC = (vec3(0., 0.5, 2.0) * vN * (v / 2. + 0.4) * vC + vC);\n    \n    vec3 bC = (lightBlue * 2.2) + vec3(0., 0.1, 0.2); \n    bC = mix(bC, blue * 1.6 + lightBlue * 0.5, smoothstep(0.0, 2., (uv.x + 0.5) * length(uv)));\n    bC *= vec3(1.2, 1.3, 1.4);\n \n    vec3 sparkles = vec3(smoothstep(0.5, 0.9, length(fract(uv*(12.)+vN+.5) -.5))) * 0.5 * max(mod(iTime / 2. + uv*(2.)+vN, 0.5382).x, 0.3);// * 0.2\n    vec2 grid = smoothstep(0., 0.01, mod(uv + vec2(0.003), 0.2));\n    float gridC = (min(grid.y, grid.x)) * 0.1;\n    \n    vec3 col = mix(vC * v + sparkles * v + gridC * .1 * v, vCenterC,  vCenter);\n     \n    vec3 r = col * 1.2 * v\n    + ((bC + gridC * 2. + vC * 0.3 ) * ((1. - v) + ((1. - vSmallCenter) * 1.5) * gridC)) * 0.35; \n    \n    r -= shade(ruv, v, .7, 0.3, iTime) * 0.2 * (1. - v);\n    r += shade(ruv, v, .3, 0.25, iTime) * 0.25 * v;\n    \n    float water = smoothstep(0.4, 0.9, length(uv)) * vN * 0.2;\n    r += vec3(water, water, water * 0.8);\n    r += vec3(smoothstep(0.55, 0.9, length(fract(uv*(2.)+vN+.5 + sin(iTime / 2.)) -.5))  ) * 0.2  * (1. - v) * vN; \n    r *= (smoothstep(4., 0.5, length(uv)));\n\n    fragColor = vec4(r, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wlcyDs.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 20, 20, 82], [84, 84, 120, 120, 438], [440, 440, 490, 490, 673], [675, 675, 709, 709, 820], [822, 822, 892, 892, 1224], [1226, 1226, 1253, 1253, 1360], [1362, 1441, 1467, 1467, 1847], [1867, 1867, 1891, 1891, 2115], [2118, 2118, 2175, 2175, 4346]]}
{"id": "WlcyRl", "name": "新年快乐", "author": "yuehongliang", "description": "happy new year", "tags": ["2d", "shape"], "likes": 2, "viewed": 46, "published": "Public", "date": "1609670809", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//https://www.shadertoy.com/view/XlsSRr\n//https://www.shadertoy.com/view/tsyfDm\n#define LINEWIDTH .03\n// Signed Distance to 2D Arc by Adam Simmons\n// Based roughly on code by Behdad Esfahbod\n\n// Arc segment with certain depth\nstruct Arc {\n  vec2 p0;\n  vec2 p1;\n    \n  // Depth of the Arc, valid range of (-1.0, 1.0)\n  // with 0.0 = straight line, 1.0 = semi-circle\n  //狐所在大圆半径\n  float d;\n};\n\nvec2 perpendicular (const vec2 v) {\n  return vec2 (-v.y, v.x);\n}\n\nfloat tan2atan (float d) {\n  return 2. * d / (1. - d * d);\n}\n\nvec2 computeArcCenter (const Arc a) {\n  return mix (a.p0, a.p1, .5) +\n\t perpendicular (a.p1 - a.p0) / (2. * tan2atan (a.d));\n}\n\nfloat sdArcWedge (Arc a, const vec2 p) {\n  vec2 c = computeArcCenter (a);\n  return -sign (a.d) * (distance (a.p0, c) - distance (p, c));\n}\n\nbool isPointInsideArcWedge (const Arc a, const vec2 p) {\n  float d2 = tan2atan (a.d);\n  return dot (p - a.p0, (a.p1 - a.p0) * mat2(1,  d2, -d2, 1)) >= 0. &&\n\t dot (p - a.p1, (a.p1 - a.p0) * mat2(1, -d2,  d2, 1)) <= 0.;\n}\n\nfloat sdArcOutsideWedge (const Arc a, const vec2 p) {\n  vec2 m = mix (a.p0, a.p1, .5);\n  float d2 = tan2atan (a.d);\n  if (dot (p - m, a.p1 - m) < 0.)\n    return -dot (p - a.p0, normalize ((a.p1 - a.p0) * mat2(+d2, -1, +1, +d2)));\n  else\n    return -dot (p - a.p1, normalize ((a.p1 - a.p0) * mat2(-d2, -1, +1, -d2)));\n}\n\nfloat sdArc(Arc arc, vec2 p) {\n  // trick to avoid depth values very close to 0.0\n//   arc.d = max(abs(arc.d), 0.0001) * (2. * step(0.9, sign(arc.d)) - 1.);\n  \n  if (isPointInsideArcWedge(arc, p))\n    return sdArcWedge(arc, p);\n  \n  return min (distance (p, arc.p0), distance (p, arc.p1)) * sign(sdArcOutsideWedge(arc, p));\n}\n\nfloat DrawSmoothArc(vec2 uv,vec2 a,vec2 b,float d){\n    Arc arc;\n    arc.p0=a;\n    arc.p1=b;\n    arc.d=d;\n    float dist=abs(sdArc(arc,uv));\n\n    float s=pow(smoothstep(0.,LINEWIDTH,dist),10.);\n\n    return 1.-s;\n}\n\nfloat DistanceToLine(vec2 a, vec2 b, vec2 p)\n{\n    vec2 pos = p - a;\n    vec2 dir = b - a;\n    float len = length(dir);\n    dir /= len;//线朝向\n    float f = dot(dir, pos);\n    if (f < 0.0)//点在a点外侧，即朝向线段反方向\n        return distance(a, p);\n   \telse if (f > len)//点在线段上投影距离大于线段距离\n        return distance(b, p);\n    else\n        return distance(a + dir * f, p);//向量a加（p向量在线朝向上），和向量终点落在线段上\n}\nfloat DrawSmoothLine(vec2 fragCoord, vec2 a, vec2 b, float thickness)\n{\n    //uv到线段的距离\n    float d = DistanceToLine(a, b, fragCoord);\n    //线宽归一化,扩大10倍\n    float s = pow(smoothstep(0., thickness, d), 10.);//边缘有黑色，待剔除\n    return 1.-s;\n}\n\nfloat Circle(vec2 uv, vec2 centre, float radius)\n{\n    float d = length(uv - centre);\n    float blur=abs(sin(iTime));\n    float c = smoothstep(radius, radius - .002, d*blur);\n    return c;\n}\n\nfloat line(vec2 uv,vec2 start,vec2 end,float linewidth)\n{\n    vec2 kv=end-start;\n    float k=kv.y==0.?0.:kv.x/kv.y;\n    float slit=(uv.x-start.x)*(end.x-uv.x)>0.?1.:0.;\n    float line=smoothstep(linewidth, 0.0,abs(uv.y - k*uv.x))*slit;\n    return line;\n}\n\nvec2 Rotate(vec2 coord, vec2 center,float deg)\n{\n    vec2 dist=coord-center;\n\n    float angle = radians(deg);\n    vec2 rot = dist * mat2(cos(angle), sin(angle), -sin(angle), cos(angle));\n    rot+=center;\n    return rot;\n}\nvec3 xin(vec2 uv){\n    //新\n    vec3 color=vec3(1.,.8,.8);\n    vec2 line_start=vec2(-.95,0.47);\n    vec2 line_end=vec2(-.9,.45);\n    vec3 slice1=DrawSmoothLine(uv,line_start,line_end,LINEWIDTH)*color;\n    line_start=vec2(-.98,.4);\n    line_end=vec2(-.83,.4);    \n    vec3 slice2=DrawSmoothLine(uv,line_start,line_end,LINEWIDTH)*color;\n    line_start=vec2(-.98,.35);\n    line_end=vec2(-.94,.3);\n    vec3 slice3=DrawSmoothLine(uv,line_start,line_end,LINEWIDTH)*color;\n    line_start=vec2(-.82,.35);\n    line_end=vec2(-.86,.3);\n    vec3 slice4=DrawSmoothLine(uv,line_start,line_end,LINEWIDTH)*color;\n    line_start=vec2(-1.,.25);\n    line_end=vec2(-.8,.25); \n    vec3 slice5=DrawSmoothLine(uv,line_start,line_end,LINEWIDTH)*color;\n    line_start=vec2(-.97,.17);\n    line_end=vec2(-.83,.17); \n    vec3 slice6=DrawSmoothLine(uv,line_start,line_end,LINEWIDTH)*color;\n    line_start=vec2(-.9,.19);\n    line_end=vec2(-.9,.02); \n    vec3 slice7=DrawSmoothLine(uv,line_start,line_end,LINEWIDTH)*color;\n    line_start=vec2(-.95,.1);\n    line_end=vec2(-.98,.05); \n    vec3 slice8=DrawSmoothLine(uv,line_start,line_end,LINEWIDTH)*color;\n    line_start=vec2(-.85,.1);\n    line_end=vec2(-.82,.05); \n    vec3 slice9=DrawSmoothLine(uv,line_start,line_end,LINEWIDTH)*color;\n    line_start=vec2(-.92,.01);\n    line_end=vec2(-.925,.02); \n    vec3 slice10=DrawSmoothLine(uv,line_start,line_end,LINEWIDTH)*color;\n    \n    vec2 arc_start=vec2(-.75,.4);\n    vec2 arc_end=vec2(-.55,.44);\n    vec3 slice11=DrawSmoothArc(uv,arc_start,arc_end,.2)*color;\n    arc_start=vec2(-.75,.0);\n    arc_end=vec2(-.75,.35);\n    vec3 slice12=DrawSmoothArc(uv,arc_start,arc_end,.2)*color;\n    line_start=vec2(-.68,.3);\n    line_end=vec2(-.55,.3); \n    vec3 slice13=DrawSmoothLine(uv,line_start,line_end,LINEWIDTH)*color;\n    line_start=vec2(-.62,.253);\n    line_end=vec2(-.62,.0); \n    vec3 slice14=DrawSmoothLine(uv,line_start,line_end,LINEWIDTH)*color;\n\n    vec3 font=mix(slice1,slice2,slice2.x);\n    font=mix(font,slice3,slice3.x);\n    font=mix(font,slice4,slice4.x);\n    font=mix(font,slice5,slice5.x);\n    font=mix(font,slice6,slice6.x);\n    font=mix(font,slice7,slice7.x);\n    font=mix(font,slice8,slice8.x);\n    font=mix(font,slice9,slice9.x);\n    font=mix(font,slice10,slice10.x);\n    font=mix(font,slice11,slice11.x);\n    font=mix(font,slice12,slice12.x);\n    font=mix(font,slice13,slice13.x);\n    font=mix(font,slice14,slice14.x);\n    return font;\n}\nvec3 nian(vec2 uv){\n    //年\n    vec3 color=vec3(1.,.8,.8);\n    vec2 arc_start=vec2(-.46,.25);\n    vec2 arc_end=vec2(-.38,.44);\n    vec3 slice1=DrawSmoothArc(uv,arc_start,arc_end,.2)*color;\n    vec2 line_start=vec2(-.33,.38);\n    vec2 line_end=vec2(-.1,.38);\n    vec3 slice2=DrawSmoothLine(uv,line_start,line_end,LINEWIDTH)*color;\n    line_start=vec2(-.35,.25);\n    line_end=vec2(-.1,.25);\n    vec3 slice3=DrawSmoothLine(uv,line_start,line_end,LINEWIDTH)*color;\n    line_start=vec2(-.4,.1);\n    line_end=vec2(-.1,.1);\n    vec3 slice4=DrawSmoothLine(uv,line_start,line_end,LINEWIDTH)*color;\n    line_start=vec2(-.35,.19);\n    line_end=vec2(-.35,.15);\n    vec3 slice5=DrawSmoothLine(uv,line_start,line_end,LINEWIDTH)*color;\n    line_start=vec2(-.23,.33);\n    line_end=vec2(-.23,-.05);\n    vec3 slice6=DrawSmoothLine(uv,line_start,line_end,LINEWIDTH)*color;\n\n    vec3 font=mix(slice1,slice2,slice2.x);\n    font=mix(font,slice3,slice3.x);\n    font=mix(font,slice4,slice4.x);\n    font=mix(font,slice5,slice5.x);\n    font=mix(font,slice6,slice6.x);\n\n    return font;\n}\nvec3 kuai(vec2 uv){\n    vec3 color=vec3(1.,.8,.8);\n    vec2 line_start=vec2(.0,.18);\n    vec2 line_end=vec2(.01,.23);\n    vec3 slice1=DrawSmoothLine(uv,line_start,line_end,LINEWIDTH)*color;\n    line_start=vec2(.08,.35);\n    line_end=vec2(.08,-.05);\n    vec3 slice2=DrawSmoothLine(uv,line_start,line_end,LINEWIDTH)*color;\n    line_start=vec2(.15,.19);\n    line_end=vec2(.15,.22);\n    vec3 slice3=DrawSmoothLine(uv,line_start,line_end,LINEWIDTH)*color;\n    line_start=vec2(.2,.28);\n    line_end=vec2(.36,.28);\n    vec3 slice4=DrawSmoothLine(uv,line_start,line_end,LINEWIDTH)*color;\n    line_start=vec2(.36,.23);\n    line_end=vec2(.36,.2);\n    vec3 slice5=DrawSmoothLine(uv,line_start,line_end,LINEWIDTH)*color;\n    line_start=vec2(.2,.15);\n    line_end=vec2(.42,.15);\n    vec3 slice6=DrawSmoothLine(uv,line_start,line_end,LINEWIDTH)*color;\n    line_start=vec2(.28,.33);\n    line_end=vec2(.28,.2);\n    vec3 slice7=DrawSmoothLine(uv,line_start,line_end,LINEWIDTH)*color;\n\n    vec2 arc_start=vec2(.22,-.05);\n    vec2 arc_end=vec2(.28,.1);\n    vec3 slice8=DrawSmoothArc(uv,arc_start,arc_end,.2)*color;\n    arc_start=vec2(.33,.05);\n    arc_end=vec2(.39,-.05);\n    vec3 slice9=DrawSmoothArc(uv,arc_start,arc_end,.2)*color;\n\n    vec3 font=mix(slice1,slice2,slice2.x);\n    font=mix(font,slice7,slice7.x);\n    font=mix(font,slice3,slice3.x);\n    font=mix(font,slice4,slice4.x);\n    font=mix(font,slice5,slice5.x);\n    font=mix(font,slice6,slice6.x);\n    font=mix(font,slice8,slice8.x);\n    font=mix(font,slice9,slice9.x);\n\n    return font;\n}\nvec3 le(vec2 uv){\n    //年\n    vec3 color=vec3(1.,.8,.8);\n    vec2 arc_start=vec2(.5,.28);\n    vec2 arc_end=vec2(.8,.33);\n    vec3 slice1=DrawSmoothArc(uv,arc_start,arc_end,.2)*color;\n    vec2 line_start=vec2(.5,.22);\n    vec2 line_end=vec2(.5,.16);\n    vec3 slice2=DrawSmoothLine(uv,line_start,line_end,LINEWIDTH)*color;\n    line_start=vec2(.5,.1);\n    line_end=vec2(.85,.1);\n    vec3 slice3=DrawSmoothLine(uv,line_start,line_end,LINEWIDTH)*color;\n    line_start=vec2(.65,.2);\n    line_end=vec2(.65,-.11);\n    vec3 slice4=DrawSmoothLine(uv,line_start,line_end,LINEWIDTH)*color;\n    line_start=vec2(.58,.0);\n    line_end=vec2(.53,-.1);\n    vec3 slice5=DrawSmoothLine(uv,line_start,line_end,LINEWIDTH)*color;\n    line_start=vec2(.73,.0);\n    line_end=vec2(.78,-.1);\n    vec3 slice6=DrawSmoothLine(uv,line_start,line_end,LINEWIDTH)*color;\n    line_start=vec2(.6,-.1);\n    line_end=vec2(.63,-.12);\n    vec3 slice7=DrawSmoothLine(uv,line_start,line_end,LINEWIDTH)*color;\n\n    vec3 font=mix(slice1,slice2,slice2.x);\n    font=mix(font,slice4,slice4.x);\n    font=mix(font,slice3,slice3.x);\n    font=mix(font,slice5,slice5.x);\n    font=mix(font,slice6,slice6.x);\n    font=mix(font,slice7,slice7.x);\n\n    return font;\n}\nfloat rnd(float x)\n{\n    return fract(sin(dot(vec2(x+47.49,38.2467/(x+2.3)), vec2(12.9898, 78.233)))* (43758.5453));\n}\nvec3 starts(vec2 uv,vec2 pos,float size){\n    vec3 color=vec3(1.,1.,0.8);\n    float c=1.0 - sqrt(smoothstep(0.0, size, length(uv - pos)));\n    return c*color;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //-1~1\n    vec2 uv = (2.0 * fragCoord-iResolution.xy) / iResolution.y;\n    vec3 background=vec3(.8,1.,1.);\n    vec3 xin=xin(uv);\n    vec3 color=mix(background,xin,xin.z);\n    vec3 nian=nian(uv);\n    vec3 kuai=kuai(uv);\n    vec3 le=le(uv);\n    color=mix(color,nian,nian.z);\n    color=mix(color,kuai,kuai.z);\n    color=mix(color,le,le.z);\n\n    for(float i=1.;i<=50.;i++){\n        for(float j=1.;j<=20.;j++){\n            if(j>20./i) break;\n            float size=0.001*i*(1.+rnd(j)/2.);\n            float speed=size*.75+rnd(i)/1.5;\n            vec2 pos=vec2(0.);\n            pos.x=-1.+rnd(j*i)*1.9+.1*cos(iTime+sin(j*i));\n            pos.y=fract(sin(j)-speed*iTime)/1.3;\n            color+=vec3(1.-i/50.)*starts(uv,pos,size);\n        }\n    }\n\n    fragColor =vec4(color,1.);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WlcyRl.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[192, 406, 441, 441, 470], [472, 472, 498, 498, 532], [534, 534, 571, 571, 660], [662, 662, 702, 702, 800], [802, 802, 858, 858, 1022], [1024, 1024, 1077, 1077, 1342], [1344, 1344, 1374, 1500, 1669], [1671, 1671, 1722, 1722, 1884], [1886, 1886, 1932, 1932, 2379], [2380, 2380, 2451, 2478, 2661], [2663, 2663, 2713, 2713, 2853], [2855, 2855, 2912, 2912, 3109], [3111, 3111, 3159, 3159, 3332], [3333, 3333, 3351, 3361, 5750], [5751, 5751, 5770, 5780, 6814], [6815, 6815, 6834, 6834, 8345], [8346, 8346, 8363, 8373, 9557], [9558, 9558, 9578, 9578, 9676], [9677, 9677, 9718, 9718, 9837], [9839, 9839, 9896, 9907, 10673]]}
{"id": "WldcWB", "name": "MosaicGlass", "author": "usbhatyu", "description": "Shader sketch.", "tags": ["raymarching"], "likes": 1, "viewed": 54, "published": "Public", "date": "1610354247", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const float FOCUS = 4.35;\nconst float REFRACTION = 0.35;\n\n//Mosaic glass\nfloat mosaicGlass(vec2 p){\n    return length(tan(p*sin(iTime*0.3)*FOCUS)*REFRACTION);\n}\n\n//Pyramid mosaic\nvec3 mosaic(vec3 p,float block){\n    return floor(p*block)/block;\n}\n\n//Generate a ceiling.\nfloat ceiling(vec3 p){\n    return step(-p.y,0.0);\n}\n\nvec3 cRepeat(vec3 p){\n    return mod(cos(floor(p)),2.0);\n}\n\nfloat sphere(vec3 p){\n    return abs(length(p*0.2)-0.1);\n}\n//////////////////////\n\n//Generate the ground\nfloat ground(vec3 p){\n    return step(p.y,0.4);\n}\n\nvec3 gRepeat(vec3 p){\n    return mod(p,0.9)-0.4;\n}\n\nfloat sdPyramid(vec3 p,float h)\n{\n  float m2 = h*h+0.25;\n    \n  p.xz = abs(p.xz);\n  p.xz = (p.z>p.x)?p.zx:p.xz;\n  p.xz -= 0.5;\n\n  vec3 q = vec3(p.z,h*p.y-0.5*p.x,h*p.x+0.5*p.y);\n   \n  float s = max(-q.x,0.0);\n  float t = clamp((q.y-0.5*p.z)/(m2+0.25),0.0,1.0);\n    \n  float a = m2*(q.x+s)*(q.x+s) + q.y*q.y;\n  float b = m2*(q.x+0.5*t)*(q.x+0.5*t)+(q.y-m2*t)*(q.y-m2*t);\n    \n  float d2 = min(q.y,-q.x*m2-q.y*0.5)>0.0?0.0:min(a,b);\n    \n  return sqrt((d2+q.z*q.z)/m2)*sign(max(q.z,-p.y));\n}\n//////////////////////\n\nfloat mainDist(vec3 p){\n    vec3 cP = cRepeat(p);\n    float up = ceiling(p)*sphere(cP*0.3);\n    vec3 gP = gRepeat(p);\n    float under = ground(p)*sdPyramid(mosaic(gP,25.0)*1.02,0.35);\n    float d = max(up,under);\n    d += up+up+up+up;\n    \n    return d;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = (fragCoord*2.0-iResolution.xy)/min(iResolution.x,iResolution.y);\n    \n    vec3 cd = vec3(0.0,0.0,-1.0);\n    vec3 cu = vec3(0.0,1.0,0.0);\n    vec3 cs = cross(cd,cu);\n    float td = 1.0;\n    vec3 ray = normalize(cs * p.x + cu * p.y + cd * td);\n    \n    float d,t = 0.0;\n    vec3 rp = vec3(sin(iTime*0.5),\n        0.4*mosaicGlass(p),\n        -iTime*0.8);\n    \n    for(int i;i<128;i++){\n        d = mainDist(rp + ray * t);\n        if(d < 0.001){\n            break; \n        }\n        t +=d;\n    }\n    \n    vec3 col1 = step(d,0.0)*vec3(0.3,exp(-0.5*t),exp(-0.1*t));\n    vec3 col2 = step(d,0.5)*vec3(exp(-0.2*t),0.2,exp(-0.3*t));\n    \n    vec3 col = max(col1,col2);\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WldcWB.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[58, 73, 99, 99, 160], [162, 179, 211, 211, 246], [248, 270, 292, 292, 321], [323, 323, 344, 344, 381], [383, 383, 404, 404, 441], [466, 488, 509, 509, 537], [539, 539, 560, 560, 589], [591, 591, 624, 624, 1080], [1081, 1105, 1128, 1128, 1360], [1362, 1362, 1419, 1419, 2130]]}
{"id": "Wldfzr", "name": "Renato_animation", "author": "renato", "description": "Testing animation.. Tutorial on Youtube - Channel The Art of Code.", "tags": ["beginner"], "likes": 1, "viewed": 47, "published": "Public", "date": "1612126724", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define S(a, b, t) smoothstep(a, b, t)\n#define B(a, b, blur, t) S(a-blur, a+blur, t)*S(b+blur, b-blur, t)\n#define sat(x) clamp(x, 0., 1.)\n\nfloat remap01(float a, float b, float t) {\n\treturn sat((t-a)/(b-a));\n}\n\nfloat remap(float a, float b, float c, float d, float t) {\n\treturn sat((t-a)/(b-a)) * (d-c) + c;\n}\n\nvec2 within(vec2 uv, vec4 rect) {\n\treturn (uv-rect.xy)/(rect.zw-rect.xy);\n}\n\nvec4 Brow(vec2 uv, float smile) {\n    float offs = mix(.2, 0., smile);\n    uv.y += offs;\n    \n    float y = uv.y;\n    uv.y += uv.x*mix(.5, .8, smile)-mix(.1, .3, smile);\n    uv.x -= mix(.0, .1, smile);\n    uv -= .5;\n    \n    vec4 col = vec4(0.);\n    \n    float blur = .1;\n    \n   \tfloat d1 = length(uv);\n    float s1 = S(.45, .45-blur, d1);\n    float d2 = length(uv-vec2(.1, -.2)*.7);\n    float s2 = S(.5, .5-blur, d2);\n    \n    float browMask = sat(s1-s2);\n    \n    float colMask = remap01(.7, .8, y)*.75;\n    colMask *= S(.6, .9, browMask);\n    colMask *= smile;\n    vec4 browCol = mix(vec4(.4, .2, .2, 1.), vec4(1., .75, .5, 1.), colMask); \n   \n    uv.y += .15-offs*.5;\n    blur += mix(.0, .1, smile);\n    d1 = length(uv);\n    s1 = S(.45, .45-blur, d1);\n    d2 = length(uv-vec2(.1, -.2)*.7);\n    s2 = S(.5, .5-blur, d2);\n    float shadowMask = sat(s1-s2);\n    \n    col = mix(col, vec4(0.,0.,0.,1.), S(.0, 1., shadowMask)*.5);\n    \n    col = mix(col, browCol, S(.2, .4, browMask));\n    \n    return col;\n}\n\nvec4 Eye(vec2 uv, float side, vec2 m, float smile) {\n    uv -= .5;\n    uv.x *= side;\n    \n\tfloat d = length(uv);\n    vec4 irisCol = vec4(.3, .5, 1., 1.);\n    vec4 col = mix(vec4(1.), irisCol, S(.1, .7, d)*.5);\t\t\n    col.a = S(.5, .48, d);\t\t\t\t\t\t\t\t\t\n    \n    col.rgb *= 1. - S(.45, .5, d)*.5*sat(-uv.y-uv.x*side); \t\n    \n    d = length(uv-m*.4);\t\t\t\t\t\t\t\t\t\n    col.rgb = mix(col.rgb, vec3(0.), S(.3, .28, d)); \t\t\n    \n    irisCol.rgb *= 1. + S(.3, .05, d);\t\t\t\t\t\t\n    float irisMask = S(.28, .25, d);\n    col.rgb = mix(col.rgb, irisCol.rgb, irisMask);\t\t\t\n    \n    d = length(uv-m*.45);\t\t\t\t\t\t\t\t\t\n    \n    float pupilSize = mix(.4, .16, smile);\n    float pupilMask = S(pupilSize, pupilSize*.85, d);\n    pupilMask *= irisMask;\n    col.rgb = mix(col.rgb, vec3(0.), pupilMask);\t\t\n    \n    float t = iTime*3.;\n    vec2 offs = vec2(sin(t+uv.y*25.), sin(t+uv.x*25.));\n    offs *= .01*(1.-smile);\n    \n    uv += offs;\n    float highlight = S(.1, .09, length(uv-vec2(-.15, .15)));\n    highlight += S(.07, .05, length(uv+vec2(-.08, .08)));\n    col.rgb = mix(col.rgb, vec3(1.), highlight);\t\t\t\n    \n    return col;\n}\n\nvec4 Mouth(vec2 uv, float smile) {\n    uv -= .5;\n\tvec4 col = vec4(.5, .18, .05, 1.);\n    \n    uv.y *= 1.5;\n    uv.y -= uv.x*uv.x*2.*smile;\n    \n    uv.x *= mix(2.5, 1., smile);\n    \n    float d = length(uv);\n    col.a = S(.5, .48, d);\n    \n    vec2 tUv = uv;\n    tUv.y += (abs(uv.x)*.5+.1)*(1.-smile);\n    float td = length(tUv-vec2(0., .6));\n    \n    vec3 toothCol = vec3(1.)*S(.6, .35, d);\n    col.rgb = mix(col.rgb, toothCol, S(.4, .37, td));\n    \n    td = length(uv+vec2(0., .5));\n    col.rgb = mix(col.rgb, vec3(1., .5, .5), S(.5, .2, td));\n    return col;\n}\n\nvec4 Head(vec2 uv) {\n\tvec4 col = vec4(.9, .65, .1, 1.);\n    \n    float d = length(uv);\n    \n    col.a = S(.5, .49, d);\n    \n    float edgeShade = remap01(.35, .5, d);\n    edgeShade *= edgeShade;\n    col.rgb *= 1.-edgeShade*.5;\n    \n    col.rgb = mix(col.rgb, vec3(.6, .3, .1), S(.47, .48, d));\n    \n    float highlight = S(.41, .405, d);\n    highlight *= remap(.41, -.1, .75, 0., uv.y);\n    highlight *= S(.18, .19, length(uv-vec2(.21, .08)));\n    col.rgb = mix(col.rgb, vec3(1.), highlight);\n    \n    d = length(uv-vec2(.25, -.2));\n    float cheek = S(.2,.01, d)*.4;\n    cheek *= S(.17, .16, d);\n    col.rgb = mix(col.rgb, vec3(1., .1, .1), cheek);\n    \n    return col;\n}\n\nvec4 Smiley(vec2 uv, vec2 m, float smile) {\n\tvec4 col = vec4(0.);\n    \n    if(length(uv)<.5) {\t\t\t\t\t\n        float side = sign(uv.x);\n        uv.x = abs(uv.x);\n        vec4 head = Head(uv);\n        col = mix(col, head, head.a);\n\n        if(length(uv-vec2(.2, .075))<.175) {\n            vec4 eye = Eye(within(uv, vec4(.03, -.1, .37, .25)), side, m, smile);\n            col = mix(col, eye, eye.a);\n        }\n\n        if(length(uv-vec2(.0, -.15))<.3) {\n            vec4 mouth = Mouth(within(uv, vec4(-.3, -.43, .3, -.13)), smile);\n            col = mix(col, mouth, mouth.a);\n        }\n\n        if(length(uv-vec2(.185, .325))<.18) {\n            vec4 brow = Brow(within(uv, vec4(.03, .2, .4, .45)), smile);\n            col = mix(col, brow, brow.a);\n        }\n    }\n    \n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tfloat t = iTime;\n    \n    vec2 uv = fragCoord.xy / iResolution.xy;\n    uv -= .5;\n    uv.x *= iResolution.x/iResolution.y;\n    \n    vec2 m = iMouse.xy / iResolution.xy;\n    m -= .5;\n    \n    if(m.x<-.49 && m.y<-.49) {\t\t\t\n    \tfloat s = sin(t*.5);\n        float c = cos(t*.38);\n        \n        m = vec2(s, c)*.4;\n    }\n    \n    if(length(m) > .707) m *= 0.;\t\t\n    \n    float d = dot(uv, uv);\n    uv -= m*sat(.23-d);\n    \n    float smile = sin(t*.5)*.5+.5;\n\tfragColor = Smiley(uv, m, smile);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Wldfzr.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[139, 139, 181, 181, 209], [211, 211, 269, 269, 309], [311, 311, 344, 344, 386], [388, 388, 421, 421, 1394], [1396, 1396, 1448, 1448, 2494], [2496, 2496, 2530, 2530, 3059], [3061, 3061, 3081, 3081, 3733], [3735, 3735, 3778, 3778, 4516], [4518, 4518, 4575, 4575, 5068]]}
{"id": "wldyDs", "name": "Speaker bumpin", "author": "AugustYadon", "description": "Hi", "tags": ["music", "visualizer", "rainbow", "speaker"], "likes": 0, "viewed": 62, "published": "Public", "date": "1610277744", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//Borrowed rainbow function from u/demofox's Rainbow Shader\nvec3 rainbow(float level)\n{\n\t/*\n\t\tTarget colors\n\t\t=============\n\t\t\n\t\tL  x   color\n\t\t0  0.0 vec4(1.0, 0.0, 0.0, 1.0);\n\t\t1  0.2 vec4(1.0, 0.5, 0.0, 1.0);\n\t\t2  0.4 vec4(1.0, 1.0, 0.0, 1.0);\n\t\t3  0.6 vec4(0.0, 0.5, 0.0, 1.0);\n\t\t4  0.8 vec4(0.0, 0.0, 1.0, 1.0);\n\t\t5  1.0 vec4(0.5, 0.0, 0.5, 1.0);\n\t*/\n\t\n\tfloat r = float(level <= 2.0) + float(level > 4.0) * 0.5;\n\tfloat g = max(1.0 - abs(level - 2.0) * 0.5, 0.0);\n\tfloat b = (1.0 - (level - 4.0) * 0.5) * float(level >= 4.0);\n\treturn vec3(r, g, b);\n}\n\n//v sloppy code, just messin around\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 center = vec2(0.5,0.5);\n    \n    //was gonna try to make some different phases where it moves around and stuff \n    //but got lazy and tired and left it as is\n    //comment out next line to use it without the multispeaker thing\n    uv = mix(mod(1.0 + uv + 0.5*sin(iTime),1.0), uv, min(1.0, floor(mod(iTime,3.0))));\n    \n    vec2 diff = uv - center;\n    \n    float dist = length(diff);\n    \n    vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n    float newDist = dist*(0.5+(0.15*sin(iTime*20.)));\n    vec3 ymp = vec3(smoothstep(0.1,0.4,newDist));\n    \n    float rainbowNum = mod(floor( iTime + (6.0*sin(uv.x)+sin(uv.y))),6.0)/6.0;\n    rainbowNum = rainbowNum + mod(iTime,5.0);\n    vec3 background = rainbow(rainbowNum);\n    \n    vec3 outerspeaker1 = mix(vec3(0.0),background,smoothstep(0.2,0.25,newDist));\n    col = mix(ymp,outerspeaker1,step(0.2,newDist) );\n\n    //col = mix(ymp, vec3(0.0), step(0.2, newDist));\n     //col = mix(col, vec3(0.0), step(0.2, newDist));\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wldyDs.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 60, 87, 355, 554], [556, 592, 649, 699, 1775]]}
{"id": "wldyWf", "name": "bubble drops", "author": "Shellderr", "description": "bubble drops", "tags": ["bubble"], "likes": 0, "viewed": 40, "published": "Public", "date": "1610172833", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define xp(f,a) (pow(6., a* f-a))\n#define downthresh 1.04\n#define upthresh 1.\n#define B 1.5\n\nfloat drop(vec2 uv, float x, float a, float time){\n//    return length(uv.xy-vec2(x, clamp(3.3*a*fract(time), -.5, 1.5)));\n//    return length(uv.xy-vec2(x, clamp(3.3*a*fract(time), -1., 5.)-.5));\n\n    return 4.*clamp(length(uv.xy-vec2(x, (6.*fract(time)-.8)*.3*a)),0.,.3);\n    //return 4.*clamp(distance(uv.xy, vec2(x, 4.*fract(time)-2.5)),0.,.2);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    //uv = 1.-uv;\n\n    vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n    //vec3 col = vec3(1.);\n\n//    float b = drop(uv, 0.6, 1., iTime*0.25);\n//         b *= drop(uv, 0.3, 1., .7+iTime*0.25);\n\n   float b = drop(uv, 0.3, 2., iTime*0.25);\n         b *= drop(uv, 0.7, 1.4, .4+iTime*0.27);\n         b *= drop(uv, 0.1, 1.5, .6+iTime*0.25);\n         b *= drop(uv, 0.45, 1.9, .2+iTime*0.26);\n  \n    float fb = upthresh-xp(uv.y, 4.);\n    fb *= downthresh-xp(1.-uv.y*B, 4.);\n    \n    col *= 1.-(b*8.*fb);\n\n    fragColor = vec4(col,1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wldyWf.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[93, 93, 143, 289, 443], [445, 445, 502, 552, 1130]]}
{"id": "WlfyR8", "name": "fbm_trials", "author": "wnu", "description": "s", "tags": ["s"], "likes": 3, "viewed": 79, "published": "Public", "date": "1611709886", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#ifdef GL_ES\nprecision mediump float;\n#endif\n\n\nfloat random (in vec2 _st) {\n    return fract(sin(dot(_st.xy,\n                         vec2(12.9898,78.233)))*\n        43758.5453123);\n}\n\n// Based on Morgan McGuire @morgan3d\n// https://www.shadertoy.com/view/4dS3Wd\nfloat noise (in vec2 _st) {\n    vec2 i = floor(_st);\n    vec2 f = fract(_st);\n\n    // Four corners in 2D of a tile\n    float a = random(i);\n    float b = random(i + vec2(1.0, 0.0));\n    float c = random(i + vec2(0.0, 1.0));\n    float d = random(i + vec2(1.0, 1.0));\n\n    vec2 u = f * f * (3.0 - 2.0 * f);\n\n    return mix(a, b, u.x) +\n            (c - a)* u.y * (1.0 - u.x) +\n            (d - b) * u.x * u.y;\n}\n\nvec3 hsl2rgb( in vec3 c )\n{\n    vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n\n    return c.z + c.y * (rgb-0.5)*(1.0-abs(2.0*c.z-1.0));\n}\n\n#define NUM_OCTAVES 4\n\nfloat fbm ( in vec2 _st) {\n    float v = 0.0;\n    float a = 0.5;\n    vec2 shift = vec2(100.0);\n    // Rotate to reduce axial bias\n    mat2 rot = mat2(cos(0.5), sin(0.5),\n                    -sin(0.5), cos(0.50));\n    for (int i = 0; i < NUM_OCTAVES; ++i) {\n        v += a * noise(_st);\n        _st = rot * _st * 2. + shift;\n        a *= 0.5;\n    }\n    return v;\n}\n\nmat2 rotate2d(float _angle){\n    return mat2(cos(_angle),-sin(_angle),\n                sin(_angle),cos(_angle));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 R = iResolution.xy;\n    vec2 st = fragCoord.xy/R.xy;\n    \n    st -= 0.5;\n    st*= iTime/12.;\n    //float s = length(st-1.5);\n    // st += st * abs(sin(u_time*0.1)*3.0);\n    st.x *= R.x/R.y;\n    st = rotate2d(1./length(st*1./(iTime+10.)/0.002)*(iTime+10.))*st;\n    \n    vec3 color = vec3(0.0);\n\tfloat cVal = 0.;\n    int num = 5;\n    for(int i = -2; i<3;i++){\n        for(int j = -2; j<3;j++){\n        \tcVal += fbm(st+ vec2(float(i)/R.x*4.,float(j)/R.y*4.)+ fbm(st+ vec2(float(i)/R.x*4.,float(j)/R.y*4.))*10. + iTime*0.5);\n        }\n    }\n    \n    //float val = fbm(st+ fbm(st)*10. + iTime*0.5);\n    float val = cVal/25.;\n    \n    \n    //color = vec3(0.666667,1,1);\n    color = hsl2rgb(vec3(length(st)/val,0.5,val));\n    \n    vec3 c1 = vec3((139./255.),(69./255.),(19./255.));\n    float wVal = smoothstep(0.5,0.0,val);\n    //color = val*c1+wVal*length(st/iTime*12.);\n\n    \n    \n    fragColor = vec4(color,1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WlfyR8.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[47, 47, 75, 75, 183], [185, 263, 290, 290, 672], [674, 674, 701, 701, 844], [869, 869, 895, 895, 1232], [1234, 1234, 1262, 1262, 1348], [1350, 1350, 1407, 1407, 2326]]}
{"id": "WlGcD1", "name": "Angle Coordinates", "author": "m1ke", "description": "Basic code on how to rotate a ray. Input an angle and a distance and it will give you the vec2 position of a point which has the angle and distance specified (relative to the origin);", "tags": ["maths", "angles", "angletovector"], "likes": 0, "viewed": 29, "published": "Public", "date": "1610904383", "time_retrieved": "2021-10-01T00:00:00", "image_code": "struct Line\n{\n    vec2 a;\n    vec2 b;\n    float t;\n};\nfloat dstToLine(vec2 P, Line l)\n{\n    vec2 g = l.b - l.a;\n    vec2 h = P - l.a;\n    float d = length(h - g * clamp(dot(g, h) / dot(g,g), 0.0, 1.0));\n\treturn smoothstep(l.t, 0.9*l.t, d);\n}\nvoid DrawLine(inout vec3 col, vec2 uv, Line l)\n{\n    float intensity = dstToLine(uv, l);\n    col = mix(col, vec3(1), intensity);\n}\n\n//THE IMPORTAT PART\nconst float PI = 3.14159265359f;\nvec2 GetAngle(float angle, float dst)\n{\n    float b = angle*2.0f*PI;\n    return vec2(sin(b)*dst, cos(b)*dst);\n}\n//END\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 middle = iResolution.xy / 2.0f;\n\n    // Time varying pixel color\n    vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n    \n    \n    //REFERENCE VERTICAL LINE\n    Line reference = Line(middle, middle+vec2(0,100), 10.0f);\n    DrawLine(col, fragCoord, reference);\n    \n    //USING FUNCTION\n    vec2 second = GetAngle(iTime, 100.0f);\n    \n    //DRAWING LINE\n    Line l = Line(middle, middle+second, 20.0f);\n    DrawLine(col, fragCoord, l);\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WlGcD1.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[54, 54, 87, 87, 241], [242, 242, 290, 290, 372], [374, 427, 466, 466, 538], [539, 547, 604, 654, 1200]]}
{"id": "WlGcDR", "name": "Proof Of Fixed Points Theorem", "author": "m1ke", "description": "Each box in the smaller grid is lit up white if it is still in its original box, it is lit up white\nYou cannot rotate or transform the smaller box so that none of the boxes are white, at least one must be still in its original position.", "tags": ["fixedpoints"], "likes": 5, "viewed": 64, "published": "Public", "date": "1610905419", "time_retrieved": "2021-10-01T00:00:00", "image_code": "struct Square\n{\n    vec2 pos;\n    float size;\n    vec2 maxR;\n    vec2 minR;\n    vec3 colour;\n};\nSquare newSquare(vec2 p, float s, vec3 c)\n{\n    Square sq;\n    sq.pos = p;\n    sq.size = s;\n    sq.maxR = vec2(p.x+s, p.y+s);\n    sq.minR = vec2(p.x-s, p.y-s);\n    sq.colour = c;\n    return sq;\n}\nbool InSquare(vec2 p, Square s)\n{\n    return (p.x > s.minR.x && p.y > s.minR.y && p.x < s.maxR.x && p.y < s.maxR.y);\n}\nvoid DrawSquare(inout vec3 col, vec2 p, Square s)\n{\n    if (InSquare(p, s))\n    {\n        col = s.colour;\n    }\n}\nvoid DrawHollowSquare(inout vec3 col, vec2 p, Square inner, float t)\n{\n    vec3 prevCol = col;\n    DrawSquare(col, p,newSquare(inner.pos, inner.size, inner.colour));\n    DrawSquare(col, p,newSquare(inner.pos, inner.size-t, prevCol));\n}\nvoid DrawBoxArray(inout vec3 col, vec2 p, Square s, bool top)\n{\n    float sideLength = s.size/ 2.5f;\n    float size = s.size/5.0f;\n    vec2 bottomleft = s.minR+vec2(size,size);\n    \n    for (int x = 0; x < 5; x++)\n    {\n        for (int y = 0; y < 5; y++)\n        {\n            float thisX = bottomleft.x+(float(x)*sideLength);\n            float thisY = bottomleft.y+(float(y)*sideLength);\n        \n            vec2 thisP = vec2(thisX, thisY);\n            vec3 co = vec3(float(x)/5.0f, float(y)/5.0f, 0.0f);\n            if (top&&col == co)\n            {\n                DrawSquare(col, p, newSquare(thisP, size, vec3(1)));\n            }\n            else\n            {\n                DrawSquare(col, p, newSquare(thisP, size, co));\n            }\n        }\n    }\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Time varying pixel color\n    vec3 col = vec3(0);\n    vec2 middle = iResolution.xy/2.0f;\n    \n    //VARIABLES\n    vec2 innerBoxPos = middle+vec2(sin(iTime)*50.0f, cos(iTime)*50.0f);\n    //END\n    \n    Square b = newSquare(middle, 100.0f, vec3(1,1,1));\n    DrawBoxArray(col, fragCoord, b, false);\n    DrawHollowSquare(col, fragCoord,b, 2.0f);\n    \n    Square f = newSquare(innerBoxPos, 50.0f, vec3(0));\n    DrawBoxArray(col, fragCoord, f, true);\n    DrawHollowSquare(col, fragCoord, f, 2.0f);\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WlGcDR.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[96, 96, 139, 139, 291], [292, 292, 325, 325, 410], [411, 411, 462, 462, 524], [525, 525, 595, 595, 760], [761, 761, 824, 824, 1524], [1526, 1526, 1583, 1633, 2230]]}
{"id": "WlGcDV", "name": "A Simple Kaleidoscope", "author": "SonOfLilit", "description": "A simple kaleidoscope", "tags": ["kaleidoscope", "hearts"], "likes": 2, "viewed": 104, "published": "Public", "date": "1611756801", "time_retrieved": "2021-10-01T00:00:00", "image_code": "bool is_above_line(vec2 r, vec2 q, vec2 p) {\n    return (q.y - p.y)*(r.x - q.x)-(q.x - p.x) * (r.y - q.y) > 0.;\n}\n\nvec2 reflect_line(vec2 a, vec2 b, vec2 p) {\n    vec2 x = 0.5 * (a + b);\n    vec2 n = normalize(x);\n    return x + reflect(p - x, n);\n}\nvec2 rotate(vec2 v, float a) {\n\tfloat s = sin(a);\n\tfloat c = cos(a);\n\tmat2 m = mat2(c, -s, s, c);\n\treturn m * v;\n}\nbool is_heart(vec2 p, float size) {\n    p /= size;\n    p.x = abs(p.x);\n    return 1. - p.y*p.y - 0.5*max(p.y/p.x, 0.) > 2.*p.x;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy)/ iResolution.y;\n    uv *= 10.;\n\n    float brightness = 1.0;\n    vec2 center = vec2(0, 0);\n    vec2 right = vec2(sqrt(3.)/2., 0.5);\n    vec2 left = vec2(-sqrt(3.)/2., 0.5);\n    vec2 bottom = vec2(0., -1.);\n    vec2 p = uv;\n    \n    for (int i = 0; i < 10; i++) {\n        bool lr = is_above_line(left, right, p);\n        bool rb = is_above_line(right, bottom, p);\n        bool bl = is_above_line(bottom, left, p);\n        bool cr = is_above_line(center, right, p);\n        bool cb = is_above_line(center, left, p);\n        bool cl = is_above_line(center, bottom, p);\n        if (lr || rb || bl) {\n            if (lr && (cr && !cb)) {\n                p = reflect_line(left, right, p);\n            } else if (rb && (cl)) {\n                p = reflect_line(right, bottom, p);\n            } else if (bl && (cb)) {\n                p = reflect_line(bottom, left, p);\n            } else {\n                p = vec2(0.);\n            }\n            brightness *= 0.85;\n        }\n    }\n\n    // Time varying pixel color\n    p = rotate(p + .7*cos(iTime), iTime);\n    float size = 2. + max(0., sin(24.*mod(0.25*iTime, .1)));\n    if (is_heart((mod(3.*p, 2.0) + vec2(-1.0)), size*0.25)) {\n        p += vec2(3.0);\n        p *= 0.25;\n    }\n    vec3 col = 0.5*cos(iTime + p.xyx+vec3(0,2,4)) + 0.1*sin(p.xyx*10.);\n    col.g = 0.;\n\n    if (distance(vec2(0.), p) < 0.01) {\n        col = vec3(0.);\n    }\n\n    // Output to screen\n    fragColor = vec4(brightness*col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WlGcDV.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 44, 44, 113], [115, 115, 158, 158, 249], [250, 250, 280, 280, 364], [365, 365, 400, 400, 494], [495, 495, 552, 602, 2099]]}
{"id": "WlGcWh", "name": "flow field art 2", "author": "FabriceNeyret2", "description": "[ why crossings ? ]\nvariant of field art [url]https://shadertoy.com/view/wtVyRW[/url] \nusing flownoise [url]https://www.shadertoy.com/view/wdKXzd[/url] \nwith incompressible noise [url]https://www.shadertoy.com/view/Xl3Gzj[/url]\nTry variants for f(U).", "tags": ["perlin", "flow", "field", "flownoise", "lic", "incompressible"], "likes": 6, "viewed": 251, "published": "Public API", "date": "1610873909", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// variant of \"field art\" by FabriceNeyret2. https://shadertoy.com/view/wtVyRW\n\n#define hash2(p) fract(sin((p)*mat2(127.1,311.7, 269.5,183.3)) *43758.5453123)\n\n// --- flownoise from https://www.shadertoy.com/view/wdKXzd\n// gradient noise derived from https://www.shadertoy.com/view/XdXGW8\n\nfloat _z = 1.;\nvec2 hash( vec2 p ) \n{\n // float s = 0.;                      // standard Perlin noise\n    float s = mod(p.x+p.y,2.)*2.-1.;   // flow noise checkered rotation direction\n // float s = mod(floor(p.x)+floor(p.y),2.)*2.-1.;   // should be this but x is integer\n // float s = 1.;                      // flow noise universal rotation direction\n // s *= iTime;                        // same rotation speed at all scales\n    s *= iTime/ _z;                    // rotation speed increase with small scale    \n\n    return ( -1. + 2.*hash2(p) ) \n        *  mat2(cos( s + vec4(0,33,11,0))); // rotating gradients. rot: https://www.shadertoy.com/view/XlsyWX\n}\n\nfloat noise( vec2 p )\n{\n    vec2 i = floor( p ),\n         f = fract( p ),\n\t  // u = f*f*(3.-2.*f);\n         u = f*f*f* ( 10. + f * ( -15. + 6.* f ) ); // better for derivative. from http://staffwww.itn.liu.se/~stegu/TNM022-2005/perlinnoiselinks/paper445.pdf\n\n#define P(x,y) dot( hash( i + vec2(x,y) ), f - vec2(x,y) )\n    return mix( mix( P(0,0), P(1,0), u.x),\n                mix( P(0,1), P(1,1), u.x), u.y);\n}\n\n#define noise01(p) 1.5 * ( .5+.5* noise(p)-.18 )    // well fitted to [0,1] without saturation\n\nfloat perlin( vec2 p )                              // fractal noise\n{\t\n    mat2 m = mat2(2.); // mat2( 1.6,  1.2, -1.2,  1.6 );\n    float v  = 0.,s = 1.;\n    for( int i=0; i < 5; i++, s /= 2. ) { _z = s;   // for flownoise\n        v += s*noise01( p ); p *= m;                // variant using positive noise\n    }\n    return v;\n}\n\n// --- sampling inspired from https://www.shadertoy.com/view/lljczz\n\n#define srnd(p,s) ( 2.* fract( 4e4* sin( 1e3* mat2(1,7.1,-5.1,2.3) * (p) + 1e3*s )) -1. )\n\n// #define f(U)   noise01(U)\n   #define f(U)   noise01(ofs(U))\n// #define f(U) ( noise01(ofs(U)) + .5*noise01(2.*ofs(U)) ) / 1.2\n// #define f(U)   perlin(U) / 1.5     \n// #define f(U)   perlin(ofs(U)) / 1.5\n#define ofs(U) ( (U) *vec2(1,2) + vec2(.3*iTime,0) )\n\nvoid mainImage( out vec4 O,  vec2 u )\n{\n    vec2 R = iResolution.xy, eps = vec2(1./R.y,0),\n         U = (2.*u-R)/R.y, p, P, X,V, x;\n    O-=O;       \n         \n    float v, n =   11., // R.y/32., // 11.                // number of cells (optim)\n          l = .08,                                        // stokes length\n       // d = 90.*pow((1.-U.y)/2.,1.7)*R.y/360.;          // strokes density\n          d = 90.*pow(max(f(U)-.25 -.0*U.y,0.),1.7)*R.y/360.;// strokes density\n    int N = 3; // int(3.*R.y/360.);                       // Neighborhood size = NxN . goes with l\n\n    p = floor(U*n+.5) / n;                                // cell center (NB: we should deffered /n )\n\n    for( int i=0; i<N*N; i++)                             // Worley optim. allows overflow to neighbor cell\n      for( float j=0.; j<d; j++) {                        // density loop\n        P = p + vec2( i%N -N/2, i/N -N/2 ) / n;           // cell coordinate in neighborhood\n        P +=     .5* srnd( round(P*n) , j) / n;           // jittering (round: for precision issues)\n        X = U-P,                                          // local coordinate\n        V; // =  f(.5*U);    // f(.5*P)                   // local field.\n        v = f(U); // v = V.x;\n        V = vec2(  dFdx(v), dFdy(v) ) * R.y;              // divergence-free  ( since we trace ortho(V) )  \n     // V = vec2( -dFdy(v), dFdx(v) ) * R.y;              // divergence-free  ( if we were tracing V )  \n     // V = vec2( f(P)-f(P-eps), f(P)-f(P-eps.yx) );      // tangents rather than curves\n\n        v = dot ( X , V );                                // distance to segment\n     // v /= fwidth(v);\n        v /= length(V) * 2.5/R.y;\n        O += (1.-O)*                                      // blend ( comment out for add )\n             .5* max( 0., 1. - 1.3*abs(v) )               // draw segment of dir V and length .04\n               * clamp( ( l - length(X) ) *R.y ,0.,1.);\n}\n    \n // O -=  max(0., length(U)-.8 ) *R.y;                    // white out of circle\n    O = sqrt(1.-O);                                       // reverse + to sRGB\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WlGcWh.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[160, 305, 327, 391, 953], [955, 955, 978, 978, 1366], [1464, 1464, 1534, 1534, 1793], [2018, 2216, 2255, 2255, 4308]]}
{"id": "wlGcWy", "name": "Basic \"plane marcher\"", "author": "mrange", "description": "Licence CC0: Simple plane marcher\nI had fun messing around with \"plane marching\"\n\nThought others might appreciate a basic \"plane marcher\" to play around with", "tags": ["2d", "3d", "planes"], "likes": 10, "viewed": 239, "published": "Public API", "date": "1611670415", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Licence CC0: Simple plane marcher\n//  I had fun messing around with \"plane marching\"\n//  While not right to produce photo-realistic shaders you \n//  create some pretty interesting effects with them\n//  Thought others might appreciate a basic \"plane marcher\"\n//  to play around with\n\n// -----------------------------------------------------------------------------\n// COMMON\n// -----------------------------------------------------------------------------\n\n#define PI              3.141592654\n#define TAU             (2.0*PI)\n#define TIME            iTime\n#define RESOLUTION      iResolution\n#define ROT(a)          mat2(cos(a), sin(a), -sin(a), cos(a))\n\nconst vec3 std_gamma        = vec3(2.2, 2.2, 2.2);\n\nfloat hash(float co) {\n  return fract(sin(co*12.9898) * 13758.5453);\n}\n\nvec4 alphaBlend(vec4 back, vec4 front) {\n  float w = front.w + back.w*(1.0-front.w);\n  vec3 xyz = (front.xyz*front.w + back.xyz*back.w*(1.0-front.w))/w;\n  return w > 0.0 ? vec4(xyz, w) : vec4(0.0);\n}\n\nvec3 alphaBlend(vec3 back, vec4 front) {\n  return mix(back, front.xyz, front.w);\n}\n\nfloat tanh_approx(float x) {\n//  return tanh(x);\n  float x2 = x*x;\n  return clamp(x*(27.0 + x2)/(27.0+9.0*x2), -1.0, 1.0);\n}\n\nvec2 mod2_1(inout vec2 p) {\n  vec2 c = floor(p + 0.5);\n  p = fract(p + 0.5) - 0.5;\n  return c;\n}\n\nfloat hex(vec2 p, float r) {\n  const vec3 k = vec3(-sqrt(3.0)/2.0,1.0/2.0,sqrt(3.0)/3.0);\n  p = p.yx;\n  p = abs(p);\n  p -= 2.0*min(dot(k.xy,p),0.0)*k.xy;\n  p -= vec2(clamp(p.x, -k.z*r, k.z*r), r);\n  return length(p)*sign(p.y);\n}\n\nfloat circle(vec2 p, float r) {\n  return length(p) - r;\n}\n\n// -----------------------------------------------------------------------------\n// PATH\n// -----------------------------------------------------------------------------\n\n// The path function\nvec3 offset(float z) {\n  float a = z;\n  vec2 p = -0.075*(vec2(cos(a), sin(a*sqrt(2.0))) + vec2(cos(a*sqrt(0.75)), sin(a*sqrt(0.5))));\n  return vec3(p, z);\n}\n\n// The derivate of the path function\n//  Used to generate where we are looking\nvec3 doffset(float z) {\n  float eps = 0.1;\n  return 0.5*(offset(z + eps) - offset(z - eps))/eps;\n}\n\n// The second derivate of the path function\n//  Used to generate tilt\nvec3 ddoffset(float z) {\n  float eps = 0.1;\n  return 0.125*(doffset(z + eps) - doffset(z - eps))/eps;\n}\n\n// -----------------------------------------------------------------------------\n// PLANE MARCHER\n// -----------------------------------------------------------------------------\n\n// Plane generating function returns rgba\n//  pp is point on plane\n//  off is path at plane z\n//  aa is estimated pixel size at the plane\n//  n is plane number\nvec4 plane(vec3 ro, vec3 rd, vec3 pp, vec3 off, float aa, float n) {\n  float h = hash(n);\n  float s = mix(0.05, 0.25, h);\n\n  vec3 hn;\n  vec2 p = (pp-off*vec3(1.0, 1.0, 0.0)).xy;\n  p *= ROT(TAU*h);\n  const float lw = 0.005;\n  float d = hex(p/s, 0.5)*s;   \n  float dd = abs(d) - lw;\n\n  float a  = smoothstep(-aa, aa, -dd);\n  float ha = smoothstep(-aa, aa, d+lw);\n\n  vec4 col = vec4(mix(vec3(1.0-tanh_approx(15.0*length(p))), vec3(0.0), a), ha);\n\n  return col;\n}\n\nvec3 skyColor(vec3 ro, vec3 rd) {\n  float ld = max(dot(rd, vec3(0.0, 0.0, 1.0)), 0.0);\n  return vec3(tanh_approx(3.0*pow(ld, 100.0)));\n}\n\nvec3 color(vec3 ww, vec3 uu, vec3 vv, vec3 ro, vec2 p) {\n  float lp = length(p);\n  vec2 np = p + 1.0/RESOLUTION.xy;\n  float rdd = (2.0+0.5*tanh_approx(lp));  // Playing around with rdd can give interesting distortions\n  vec3 rd = normalize(p.x*uu + p.y*vv + rdd*ww);\n  vec3 nrd = normalize(np.x*uu + np.y*vv + rdd*ww);\n\n  const float planeDist = 1.0-0.75;\n  const int furthest = 11;\n  const int fadeFrom = max(furthest-6, 0);\n  const float fadeDist = planeDist*float(furthest - fadeFrom);\n  float nz = floor(ro.z / planeDist);\n\n  vec3 skyCol = skyColor(ro, rd);\n\n\n  vec4 acol = vec4(0.0);\n  const float cutOff = 0.95;\n  bool cutOut = false;\n\n  // Steps from nearest to furthest plane and accumulates the color \n  for (int i = 1; i <= furthest; ++i) {\n    float pz = planeDist*nz + planeDist*float(i);\n\n    float pd = (pz - ro.z)/rd.z;\n\n    if (pd > 0.0 && acol.w < cutOff) {\n      vec3 pp = ro + rd*pd;\n      vec3 npp = ro + nrd*pd;\n\n      float aa = 3.0*length(pp - npp);\n\n      vec3 off = offset(pp.z);\n\n      vec4 pcol = plane(ro, rd, pp, off, aa, nz+float(i));\n\n      float nz = pp.z-ro.z;\n      float fadeIn = exp(-2.5*max((nz - planeDist*float(fadeFrom))/fadeDist, 0.0));\n      float fadeOut = smoothstep(0.0, planeDist*0.1, nz);\n      pcol.xyz = mix(skyCol, pcol.xyz, (fadeIn));\n      pcol.w *= fadeOut;\n      pcol = clamp(pcol, 0.0, 1.0);\n\n      acol = alphaBlend(pcol, acol);\n    } else {\n      cutOut = true;\n      break;\n    }\n\n  }\n\n  vec3 col = alphaBlend(skyCol, acol);\n// To debug cutouts due to transparency  \n//  col += cutOut ? vec3(1.0, -1.0, 0.0) : vec3(0.0);\n  return col;\n}\n\n// Classic post processing\nvec3 postProcess(vec3 col, vec2 q) {\n  col = clamp(col, 0.0, 1.0);\n  col = pow(col, 1.0/std_gamma);\n  col = col*0.6+0.4*col*col*(3.0-2.0*col);\n  col = mix(col, vec3(dot(col, vec3(0.33))), -0.4);\n  col *=0.5+0.5*pow(19.0*q.x*q.y*(1.0-q.x)*(1.0-q.y),0.7);\n  return col;\n}\n\nvec3 effect(vec2 p, vec2 q) {\n  float tm  = TIME*0.4;\n  vec3 ro   = offset(tm);\n  vec3 dro  = doffset(tm);\n  vec3 ddro = ddoffset(tm);\n\n  vec3 ww = normalize(dro);\n  vec3 uu = normalize(cross(normalize(vec3(0.0,1.0,0.0)+ddro), ww));\n  vec3 vv = normalize(cross(ww, uu));\n\n  vec3 col = color(ww, uu, vv, ro, p);\n  col = postProcess(col, q);\n  return col;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  vec2 q = fragCoord/RESOLUTION.xy;\n  vec2 p = -1. + 2. * q;\n  p.x *= RESOLUTION.x/RESOLUTION.y;\n\n  vec3 col = effect(p, q);\n\n  fragColor = vec4(col, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wlGcWy.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[286, 709, 731, 731, 779], [781, 781, 821, 821, 980], [982, 982, 1022, 1022, 1064], [1066, 1066, 1094, 1114, 1190], [1192, 1192, 1219, 1219, 1288], [1290, 1290, 1318, 1318, 1518], [1520, 1520, 1551, 1551, 1577], [1750, 1771, 1793, 1793, 1927], [1929, 2008, 2031, 2031, 2106], [2108, 2178, 2202, 2202, 2281], [2463, 2623, 2691, 2691, 3082], [3084, 3084, 3117, 3117, 3220], [3222, 3222, 3278, 3278, 4816], [4818, 4845, 4881, 4881, 5114], [5116, 5116, 5145, 5145, 5471], [5473, 5473, 5528, 5528, 5686]]}
{"id": "WlGyDz", "name": "Rotational Domain Warp", "author": "hayama", "description": "Direction of warping is rotating\nL: fBm base\nR: Perlin noise base", "tags": ["bd202101"], "likes": 0, "viewed": 65, "published": "Public", "date": "1610762245", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec2 fragCoord_;\nuvec3 k = uvec3(0x456789abu, 0x6789ab45u, 0x89ab4567u);\nconst uint max32 = 0xffffffffu;\nvec2[8] gtable2 = vec2[](   //0.92387953 = cos(pi/8), 0.38268343 = cos(pi/8)\n    vec2(0.92387953, 0.38268343),\n    vec2(0.38268343, 0.92387953),\n    vec2(-0.92387953, 0.38268343),\n    vec2(-0.38268343, 0.92387953),\n    vec2(0.92387953, -0.38268343),\n    vec2(0.38268343, -0.92387953),\n    vec2(-0.92387953, -0.38268343),\n    vec2(-0.38268343, -0.92387953)\n);\nuint hash11u(uint n) {\n    n ^= (n << 24);\n    n ^= (n >> 1);\n    n ^= (n << 1);\n    return n * k.x;\n}\nvec2 hash22(vec2 p) {\n        uint n = hash11u(hash11u(uint(p.x)) + uint(p.y));\n        n = n >> 29;\n        n = n % 8u;\n        return gtable2[n];\n}\nfloat pnoise21(vec2 p) {\n    vec2 f = fract(p);\n    vec2 g00 = hash22(p);\n    vec2 g01 = hash22(p + vec2(0.0, 1.0));\n    vec2 g10 = hash22(p + vec2(1.0, 0.0));\n    vec2 g11 = hash22(p + vec2(1.0, 1.0));\n    float v00 = dot(g00, f);\n    float v01 = dot(g01, f - vec2(0.0, 1.0));\n    float v10 = dot(g10, f - vec2(1.0, 0.0));\n    float v11 = dot(g11, f - vec2(1.0, 1.0));\n    f = f * f * f * (10.0 - 15.0 * f + 6.0 * f * f); \n    float v = mix(mix(v00, v10, f.x), mix(v01, v11, f.x), f.y);\n    return v;\n}\nfloat hash21(vec2 p) {\n    p = mod(p, 1000.0);\n    uint n = hash11u(uint(p.x)) + uint(p.y);\n    return float(hash11u(n)) / float(max32);\n}\nfloat vnoise21(vec2 p) {\n    vec2 i = floor(p);\n    float v00 = hash21(i);\n    float v01 = hash21(i + vec2(0.0, 1.0));\n    float v10 = hash21(i + vec2(1.0, 0.0));\n    float v11 = hash21(i + vec2(1.0, 1.0));\n    vec2 f = fract(p);\n    f = f * f * (3.0 -2.0 * f); \n    return mix(mix(v00, v10, f.x), mix(v01, v11, f.x), f.y) - 0.5;\n}\n\nfloat fbm21(vec2 p, float G){\n    float val = 0.0;\n    float amp =1.0;\n    float freq = 1.0;\n    for (int i = 0; i < 4; i++){\n        val += amp * vnoise21(freq * p);\n        amp *= G;\n        freq *= 2.01;\n    }\n    return val;\n}\nfloat warp21(vec2 p, float G){\n    float val = 0.0;\n    for (int i = 0; i < 4; i++){\n        float t = G * val + iTime * 0.1;\n        vec2 dir = vec2(sin(t), cos(t));\n        if (fragCoord_.x < 0.5 * iResolution.x){\n            val = fbm21(p + dir, 0.5);\n        } else{\n            val = pnoise21(p + dir);\n        }\n    }\n    return val;\n}\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n    fragCoord_ = fragCoord;\n    vec2 pos = fragCoord.xy/min(iResolution.x, iResolution.y);\n    pos *= 10.;\n    pos += 0.5 * iTime;\n    float v = 0.5 * warp21(pos, 3.0) + 0.5;  //down\n    fragColor = vec4(vec3(v), 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WlGyDz.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[464, 464, 486, 486, 566], [567, 567, 588, 588, 716], [717, 717, 741, 741, 1220], [1221, 1221, 1243, 1243, 1359], [1360, 1360, 1384, 1384, 1691], [1693, 1693, 1722, 1722, 1923], [1924, 1924, 1954, 1954, 2265], [2266, 2266, 2320, 2320, 2541]]}
{"id": "WlGyRt", "name": "pretend it's a club", "author": "YitingLiu", "description": "color experiment with noise functions and time.", "tags": ["fractal", "noise", "simple", "fbm", "perlin", "gradient", "template", "function", "value", "cellular"], "likes": 1, "viewed": 188, "published": "Public API", "date": "1611514731", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// noise functions from youtube https://www.youtube.com/watch?v=ybbJz6C9YYA\n// git code https://github.com/Gonkee/Gonkees-Shaders/blob/master/noise%20textures.shader\n\n#define PI 3.14159265358979323846\n\nfloat rand(vec2 coord){\n    coord = mod(coord,10000.);\n    return fract(sin(dot(coord, vec2(12.9898,78.233)))*43758.5453);\n}\n\nfloat random (in float x) {\n    return fract(sin(x)*1e4);\n}\n\n\nvec2 rand2(vec2 coord){\n    coord = mod(coord,10000.);\n    return fract(sin( vec2( dot(coord,vec2(127.1,311.7)), dot(coord,vec2(269.5,183.3)) ) ) * 43758.5453);\n}\n\nfloat circle (in vec2 _st, in float _radius, in float _size){\n    vec2 dist = _st-vec2(0.5);\n    return smoothstep(_radius-_radius*_size,_radius+_radius*_size,dot(dist,dist)*4.0) ;       \n}\n\nfloat value_noise(vec2 coord){\n    vec2 i = floor(coord);\n    vec2 f = fract(coord);\n    \n    float tl = rand(i);\n    float tr = rand(i + vec2(1.,0.));\n    float bl = rand(i + vec2(0.,1.));\n    float br = rand(i + vec2(1.,1.));\n    \n    //linear distance will cause sharp transition \n    //use smoothstep or cubic function\n    \n    vec2 cubic = f*f*(3.-2.*f);\n    \n    float topmix = mix(tl,tr,cubic.x);\n    float botmix = mix(bl,br,cubic.x);\n    float wholemix = mix(topmix,botmix,cubic.y);\n    \n    return wholemix;\n\n}\n\nfloat perlin_noise(vec2 coord){\n    vec2 i = floor(coord);\n    vec2 f = fract(coord);\n    \n    float tl = rand(i) * 6.283;\n    float tr = rand(i + vec2(1.,0.))* 6.283;\n    float bl = rand(i + vec2(0.,1.))* 6.283;\n    float br = rand(i + vec2(1.,1.))* 6.283;\n    \n    vec2 tlvec = vec2(-sin(tl),cos(tl));\n    vec2 trvec = vec2(-sin(tr),cos(tr));\n    vec2 blvec = vec2(-sin(bl),cos(bl));\n    vec2 brvec = vec2(-sin(br),cos(br));\n    \n    float tldot = dot (tlvec,f);\n    float trdot = dot(trvec,f - vec2(1.,0.));\n    float bldot = dot(blvec, f- vec2(0.,1.));\n    float brdot = dot(brvec, f - vec2(1.,1.));\n    \n    // or delete the +0.5 after the wholemix - this shows different patterns \n    //tldot = abs(tldot);\n    ////trdot = abs(trdot);\n    //bldot = abs(bldot);\n    //brdot = abs(brdot);\n    \n    vec2 cubic = f*f*(3.-2.*f);\n    \n    float topmix = mix(tldot,trdot,cubic.x);\n    float botmix = mix(bldot,brdot,cubic.x);\n    float wholemix = mix(topmix,botmix,cubic.y);//maintain the brightness \n    \n    return wholemix+0.5;\n    \n}\n\nfloat cellular_noise(vec2 coord){\n   vec2 i = floor(coord);\n    vec2 f = fract(coord);\n    \n    float min_dist=9999.;\n   for(float x = -1.0; x <= 1.0; x++) {\n\t\tfor(float y = -1.0; y <= 1.0; y++) {\n        \n        vec2 node = rand2(i+vec2(x,y))+vec2(x,y);\n        float dist = sqrt((f-node).x*(f-node).x+(f-node).y*(f-node).y);\n        min_dist = min(min_dist,dist);\n       }\n    }\n    return min_dist;\n    \n}\n\n// can use it to combine with other noise functions \nfloat fbm(vec2 coord, int OCTAVES){\n    //for loop size \n    //int OCTAVES =4;\n    \n    float normalize_factor =0.;\n    float value =0.;\n    float scale = 0.5; \n    \n    for (int i =0; i< OCTAVES; i++){\n    value += cellular_noise(coord)*scale;\n    normalize_factor +=scale; \n    coord *=2.;\n    scale *= 0.5;\n    }\n    return value/normalize_factor; \n\n\n}\n   \nvec2 rotate2D (vec2 _st, float _angle) {\n    _st -= 0.5;\n    _st =  mat2(cos(_angle),-sin(_angle),\n                sin(_angle),cos(_angle)) * _st;\n    _st += smoothstep(0.0,1.0,abs(sin(iTime)));\n    return _st;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (2.0 * fragCoord.xy - iResolution.xy) / min(iResolution.y, iResolution.x);\n    vec2 coord = uv*10.*abs(tan(iTime))*rotate2D(uv,cos(iTime)*PI*5.);\n    vec3 color = vec3(0.);\n     \n    float noise;\n    //noise = rand(coord);\n    noise = value_noise(coord);\n   // noise = perlin_noise(coord);\n    noise = cellular_noise(coord);\n   //noise = fbm(coord,int(abs(tan(iTime))*2.));\n   \n   \n\nuv-=random(abs(sin(iTime)));\n    color= vec3(rotate2D(uv,cos(iTime)*PI*10.),0.8);\n  \n    color/= vec3(rotate2D(coord,clamp(0., PI/2.,tan(iTime/1e5)*PI)),noise);\n    color-=noise+random(smoothstep(0.1,1.,abs(cos(iTime))));\n    color*=vec3(random(abs(tan(iTime/1e5))),atan(coord.y,coord.x),noise/coord.y);\n  \n     uv+=random(abs(sin(iTime)));\n\n   \n\n    fragColor = vec4(color*uv.x,1.0);\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WlGyRt.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 202, 225, 225, 326], [328, 328, 355, 355, 387], [390, 390, 413, 413, 552], [554, 554, 615, 615, 743], [745, 745, 775, 775, 1265], [1267, 1267, 1298, 1298, 2303], [2305, 2305, 2338, 2338, 2714], [2716, 2769, 2804, 2847, 3124], [3129, 3129, 3169, 3169, 3341], [3343, 3343, 3400, 3450, 4234]]}
{"id": "WlGyWK", "name": "Fractal structure", "author": "gaz", "description": "3d", "tags": ["fractal"], "likes": 14, "viewed": 117, "published": "Public", "date": "1611735886", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define R(a) mat2(cos(a),sin(a),-sin(a),cos(a))\nvoid mainImage(out vec4 O, vec2 C)\n{\n    O-=O;\n    for(float g,e,i=0.;++i<80.;e<1e-4?O+=.9/i:O)\n    {\n        vec3 r=iResolution,\n        p=g*vec3((C-.5*r.xy)/r.y,1);\n        p.y+=3.;\n        p.xz*=R(iTime*.2);\n        for(int j=0;++j<8;)\n            p.z-=.3,\n            p.xz=abs(p.xz),\n            p.xz=(p.z>p.x)?p.zx:p.xz,\n            p.xy=(p.y>p.x)?p.yx:p.xy,\n            p.z=1.-abs(p.z-1.),\n            p=p*3.-vec3(10,4,2);\n        g+=e=length(p)/6e3-.001;\n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WlGyWK.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[48, 48, 84, 84, 517]]}
{"id": "wlGyzD", "name": "Luminance", "author": "WJSWebster", "description": "it's some lights", "tags": ["light"], "likes": 3, "viewed": 45, "published": "Public", "date": "1610569765", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 coord = fragCoord/iResolution.xy;  // 0 - 1\n    vec3 colour = vec3(0.0);\n    vec2 translate = vec2(-0.5, -0.5);\n    coord += translate;\n\n    float radius = 0.4;\n    float glow = 0.00075;\n    float num = 50.f;\n\n    for(int i = 0; i < 40; i++)\n    {\n        float rad = radians(360.f / num) * float(i);\n        colour += glow / length(coord + vec2(radius * cos(rad * (iTime / 8.f)), radius * sin(rad * iTime / 10.f) ));\n    }\n    \n\n    // Output to screen\n    fragColor = vec4(vec3(colour), 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wlGyzD.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 107, 613]]}
{"id": "wlKcDK", "name": "Fractal 06_gaz", "author": "gaz", "description": "3d", "tags": ["3d"], "likes": 5, "viewed": 116, "published": "Public", "date": "1611823154", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define R(a)mat2(cos(a),sin(a),-sin(a),cos(a))\nvoid mainImage(out vec4 O, vec2 C)\n{\n    O=vec4(0);\n    float i,g,e,s,l;\n    for(i;++i<99.;)\n    {\n        vec3 r=iResolution,\n        p=g*vec3((C.xy-.5*r.xy)/r.y,1);\n        p.xy*=R(.8);\n        p.xz*=R(.8);\n        p+=vec3(1.4,.2,iTime);\n        s=3.;\n        p=abs(mod(p-1.,2.)-1.)-1.;\n        for(int j=0;j++<6;)\n            p=1.-abs(p-1.),\n            p=p*(l=-1.2/dot(p,p))-.3,\n            s*=abs(l);\n        g+=e=length(p.xy)/s;\n        e<.01?O.xyz+=abs(cos(p+log(s*2.)))/i:p;\n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wlKcDK.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[47, 47, 83, 83, 537]]}
{"id": "WlKcDV", "name": "Fractal 04_gaz", "author": "gaz", "description": "3d", "tags": ["fractal"], "likes": 3, "viewed": 63, "published": "Public", "date": "1611804556", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define rot(a) mat2(cos(a),sin(a),-sin(a),cos(a))\n\n#define hash(n) fract(sin(n*234.567+123.34))\n\n#define sabs(x)sqrt((x)*(x)+.005)\n#define sabs2(x)sqrt((x)*(x)+1e-4)\n#define smax(a,b) (a+b+sabs2(a-b))*.5\n\nvoid sfold90(inout vec2 p)\n{\n    p=(p.x+p.y+vec2(1,-1)*sabs(p.x-p.y))*.5;\n}\n\nfloat map(vec3 p){\n\tp.xy *= rot(iTime*0.3);\n    p.yz *= rot(iTime*0.4);\n    vec3 q=p;\n    p=abs(p)-4.;\n    sfold90(p.xy);\n    sfold90(p.yz);\n    sfold90(p.zx);\n    \n\tfloat s=2.5;\n\tp=sabs(p);\n\tvec3  p0 = p*1.5;\n\tfor (float i=0.; i<4.; i++){\n    \tp=1.-sabs2(sabs2(p-2.)-1.); \n    \tfloat g=-5.5*clamp(.7*smax(1.6/dot(p,p),.7),.0,5.5);\n    \tp*=g;\n    \tp+=p0+normalize(vec3(1,5,12))*(5.-.8*i);\n        s*=g;\n\t}\n\ts=sabs(s);\n\tfloat a=25.;\n\tp-=clamp(p,-a,a);\n\t\n\tq=abs(q)-vec3(3.7);\n    sfold90(q.xy);\n    sfold90(q.yz);\n    sfold90(q.zx);\n  \treturn smax(max(abs(q.y),abs(q.z))-1.3,length(p)/s-.00);\n}\n\nvec3 calcNormal(vec3 pos){\n  vec2 e = vec2(1,-1) * 0.005;\n  return normalize(\n    e.xyy*map(pos+e.xyy)+e.yyx*map(pos+e.yyx)+ \n    e.yxy*map(pos+e.yxy)+e.xxx*map(pos+e.xxx)\n  );\n}\n\nfloat march(vec3 ro, vec3 rd, float near, float far)\n{\n    float t=near,d;\n    for(int i=0;i<80;i++)\n    {\n        t+=d=map(ro+rd*t);\n        if (d<0.001) return t;\n        if (t>=far) return far;\n    }\n    return far;\n}\n\nfloat calcShadow( vec3 light, vec3 ld, float len ) {\n\tfloat depth = march( light, ld, 0.0, len );\t\n\treturn step( len - depth, 0.01 );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord* 2.0 - iResolution.xy) / iResolution.y;\n    vec3 ro = vec3(0,0,8.);\n    vec3 rd = normalize(vec3(uv,-2.0));\n    vec3 col = vec3(0);\n\tconst float maxd = 40.0;\n    float t = march(ro,rd,0.0,maxd);\n    if(t<maxd)\n    {\n        vec3 p=ro+rd*t;\n        col=vec3(0.3,0.3,0.6)+cos(p*0.17)*0.5+0.5;\n        vec3 n = calcNormal(p);      \n\t\tvec3 lightPos=vec3(20);\n    \tvec3 li = lightPos - p;\n\t\tfloat len = length( li );\n\t\tli /= len;\n\t\tfloat dif = clamp(dot(n, li), 0.5, 1.0);\n        float sha = calcShadow( lightPos, -li, len );\n        col *= max(sha*dif, 0.4);\n        float rimd = pow(clamp(1.0 - dot(reflect(-li, n), -rd), 0.0, 1.0), 2.5);\n\t\tfloat frn = rimd+2.2*(1.0-rimd);\n    \tcol *= frn*.9;\n        col *= max(0.5+0.5*n.y, 0.0);\n        col *= exp2(-2.*pow(max(0.0, 1.0-map(p+n*0.3)/0.3),2.0));\n        col += vec3(0.5,0.9,0.9)*pow(clamp(dot(reflect(rd, n), li), 0.0, 1.0), 8.0);\n        col = mix(vec3(0),col,exp(-t*t*.003));\n    }\n    fragColor.xyz = col;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WlKcDV.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[205, 205, 233, 233, 280], [282, 282, 300, 300, 874], [876, 876, 902, 902, 1054], [1056, 1056, 1110, 1110, 1276], [1278, 1278, 1330, 1330, 1413], [1415, 1415, 1472, 1472, 2458]]}
{"id": "WlKcR3", "name": "pattern practice - 3", "author": "Many", "description": "shader pattern practice", "tags": ["patternpractice"], "likes": 0, "viewed": 48, "published": "Public", "date": "1611440279", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float rand(float n){return fract(sin(n) * 43758.5453123);}\n\nfloat noise(float p){\n\tfloat fl = floor(p);\n  float fc = fract(p);\n\treturn mix(rand(fl), rand(fl + 1.0), fc);\n}\n\nfloat random (vec2 st) {\n    return fract(sin(dot(st.xy,\n                         vec2(12.9898,78.233)))*\n        43758.5453123);\n}\n\nfloat box(vec2 _st, vec2 _size, float _smoothEdges){\n    _size = vec2(0.5)-_size*0.5;\n    vec2 aa = vec2(_smoothEdges*0.5);\n    vec2 uv = smoothstep(_size,_size+aa,_st);\n    uv *= smoothstep(_size,_size+aa,vec2(1.)-_st);\n    return uv.x*uv.y;\n}\n\nfloat move(float x,float t){\n    float y = 3. * sin(x)/x;\n    float f = 2. * noise(3.* x + t) + y;\n    return f;\n}\n\nfloat map(float value, float min1, float max1, float min2, float max2) {\n  if(value > max1){\n      value = max1;\n  }\n  return min2 + (value - min1) * (max2 - min2) / (max1 - min1);\n}\n\n\nfloat speedControl(float t, float min1,float max1, vec2 uv){\n    t = t/7200.;\n    t = fract(.65 * t);\n    if(t >= max1)\n    {\n        t = min1;\n    }\n    return t;\n}\n\n//resize position\nfloat Rect(vec2 _st,vec2 _size,vec2 _pos){\n    vec2 uv = _st;\n    uv += vec2((.5 - _size.x/2.),(-.5 + _size.y/2.));\n    uv += vec2(-1. * _pos.x, _pos.y);\n    float r = box(uv,_size,.001);\n    return r;\n}\n\nfloat RectGenerator(vec2 _st, float ran,float num, float time){\n    float r = 0.;\n    for(float i = 0.;i < num; i++){\n        float x = random(vec2(i * .1 + .5));\n        float x2 =  random(vec2(i * .4 + .5));\n        r += Rect(_st,vec2(x * move(i + ran,time),1./num),vec2(x2 + sin(time *(x2 + .5) *ran),(1./num)* i));//move(i + ran,iTime)\n    }\n    return r;\n}\n\nvec2 tile (vec2 _st, float _zoom) {\n    _st *= _zoom;\n    return fract(_st);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Time varying pixel color\n     vec3 col = vec3(1.);    \n     vec2 st = uv;\n     uv.x = st.y;\n     uv.y = st.x;\n     //uv = tile(uv,4.);\n     \n     float speed = speedControl(iTime,.04,1.,uv);\n     float rect = RectGenerator(uv,speed,50.,iTime);//fract(iTime * iTime)\n     col = vec3(rect);\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WlKcR3.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 20, 20, 58], [60, 60, 81, 81, 171], [173, 173, 197, 197, 304], [306, 306, 358, 358, 550], [552, 552, 580, 580, 666], [668, 668, 740, 740, 850], [853, 853, 913, 913, 1018], [1020, 1038, 1080, 1080, 1241], [1243, 1243, 1306, 1306, 1604], [1606, 1606, 1641, 1641, 1684], [1687, 1687, 1744, 1794, 2189]]}
{"id": "wlKcRm", "name": "Faking 3D - Spheres", "author": "oneshade", "description": "Flying spheres. But wait... Its not really 3D is it?", "tags": ["spheres", "25d", "fake3d"], "likes": 1, "viewed": 57, "published": "Public", "date": "1610733826", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define BIG_NUMBER 1000000.0\n#define FOCAL_LENGTH 0.25\n\nvec3 Hash13(in float x) {\n   vec3 p = fract(x * vec3(0.1031, 0.103, 0.0973));\n   p += dot(p, p.yzx + 33.33);\n   return fract((p.xxy + p.yzz) * p.zyx); \n}\n\nfloat Hash11(in float x) {\n    x = fract(x * 0.1031);\n    x *= x + 33.33;\n    x *= x + x;\n    return fract(x);\n}\n\nfloat fakeSphere(in vec2 p, in vec3 o, in float r) {\n    float persp = FOCAL_LENGTH / o.z;\n    o.xy *= persp;\n    r *= persp;\n\n    p -= o.xy;\n    float d = length(p);\n    if (d < r) {\n        return -cos(asin(d / r)) * r + o.z;\n    }\n\n    return BIG_NUMBER;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n    fragColor = vec4(0.0, 0.0, 0.0, 1.0);\n\n    float depth = BIG_NUMBER;\n    for (float seed=318.547; seed < 338.547; seed++) {\n        vec3 o1 = Hash13(seed + floor(iTime)) * vec3(2.0, 2.0, 1.0) - vec3(1.0, 1.0, 0.0);\n        vec3 o2 = Hash13(seed + ceil(iTime)) * vec3(2.0, 2.0, 1.0) - vec3(1.0, 1.0, 0.0);\n        vec3 o = mix(o1, o2, fract(iTime));\n        float r = 0.1 + 0.1 * Hash11(seed);\n        depth = min(depth, fakeSphere(uv, o, r));\n    }\n\n    fragColor += 0.75 - depth;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wlKcRm.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[56, 56, 81, 81, 209], [211, 211, 237, 237, 323], [325, 325, 377, 377, 584], [586, 586, 641, 641, 1194]]}
{"id": "WlKcWh", "name": "Cepet - Smiley", "author": "Cepet", "description": "They watch.", "tags": ["smiley"], "likes": 2, "viewed": 29, "published": "Public", "date": "1610922332", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float Circle(vec2 uv, vec2 p, float r, float blur) {\n    float d = length(uv-p);\n    float c = smoothstep(r, r-blur, d);\n    \n    return c;\n}\n\nfloat Smiley(vec2 uv, vec2 p, float size)  {\n    uv -= p; // translates coord system\n    uv *= 1.0/size; // scales coord system\n\n    float mask = Circle(uv, vec2(0.0, 0.0), 0.4, 0.002);\n    \n    mask -= Circle(uv, vec2(-0.2, 0.1), 0.15, 0.002);\n    mask -= Circle(uv, vec2(0.2, 0.1), 0.15, 0.002);\n    \n    mask += Circle(uv, vec2(-0.25, 0.07), 0.07, 0.002);\n    mask += Circle(uv, vec2(0.15, 0.07), 0.07, 0.002);\n    \n    float mouth = Circle(uv, vec2(0.0, -0.1), 0.2, 0.002);\n    mouth -= Circle(uv, vec2(0.0, -0.05), 0.2, 0.002);\n    \n    mask -= clamp(mouth, 0.0, 1.0);\n    \n    return mask;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    \n    uv -= 0.5;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    float move = sin(iTime);\n    move *= 0.05;\n    vec3 col = vec3(0.0);\n    \n    float mask = Smiley(uv, vec2(move, 0), 1.0);\n    mask += Smiley(uv, vec2(-0.7, move + 0.3), 0.3);\n    mask += Smiley(uv, vec2(-0.7, move - 0.3), 0.3);\n    mask += Smiley(uv, vec2(0.7, move + 0.3), 0.3);\n    mask += Smiley(uv, vec2(0.7, move - 0.3), 0.3);\n    col = vec3(0.9 ,0.8 ,0.0) * mask;\n\n    \n    fragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WlKcWh.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 52, 52, 141], [143, 143, 187, 187, 740], [742, 742, 799, 799, 1324]]}
{"id": "WlKyDm", "name": "voronoi exercise (vlllll)", "author": "valalalalala", "description": "Bit of fun with basic 2d voronoi. Busted out a bit into pieces. Background https://thebookofshaders.com/12/ and AoC's https://www.youtube.com/watch?v=l-07BXzNdPw . Looks a bit like clouds maybe :-D\n", "tags": ["voronoi", "exercise"], "likes": 6, "viewed": 142, "published": "Public", "date": "1611181267", "time_retrieved": "2021-10-01T00:00:00", "image_code": "         //////////////////////////////////////////////////////////////////\n        //                                                            // //\n       //  \"voronoi exercise\"                                        //  //\n      //                                                            //   //\n     //  Bit of fun with basic 2d voronoi. Busted out a bit into   //    //\n    //  pieces. Background https://thebookofshaders.com/12/ and   //     //\n   //  AoC's https://www.youtube.com/watch?v=l-07BXzNdPw         //     //\n  //  Looks a bit like clouds maybe :-D                         //     //\n //                                                            //     //\n////////////////////////////////////////////////////////////////     // \n//                                                            //    //\n// Creative Commons Attribution-NonCommercial-ShareAlike      //   //\n// 3.0 Unported License                                       //  //\n//                                                            // //\n// by Val \"valalalalala\" GvM 💃 2021                          ////\n//                                                            ///\n////////////////////////////////////////////////////////////////\n\n#define FROM_SCREEN(uv) ((2.*uv-iResolution.xy)/iResolution.y)\n\n////////////////////////////////////////////////////////////////\n// scene controls\n\n// alternative distance metrics\n\n#define MANHATTAN_\n#define DOTTY_\n\n// toggle grayscale single layer of voronoi\n#define BASIC_\n\n// in case the image gets too dark\n#define GAMMA 2.\n\n// alternative color scheme( may need to bump up GAMMA)\n#define GLASSY_\n\n// for some reason... mix isn't working for me...\n#define MIX(x,y,a)   (1.-a) * x + y * a\n#define MIX_(x,y,a)  mix(x,y,a)\n#define USE_MIX_INSTEAD_OF_IFS___NOT\n\n////////////////////////////////////////////////////////////////\n// functions \n\nvec2 hash22( in vec2 uv ) {\n    vec3 q = fract( uv.xyx * vec3( 19.191, 53.733, 73.761 ) );\n    q += dot( q, q + vec3( 41.557, 23.929, 37.983 ) );\n    return fract( vec2( q.x * q.y, q.y * q.z ) );\n}\n\nvec4 makeVoronoiPoint( in vec2 id ) {\n    vec2 n = hash22( id ) ;\n    vec2 point = sin( n * iTime ) * .5 + .5;\n    return vec4( point.xy, n.xy );\n}\n\nvec3 calculateVoronoiDistance( in vec2 st, in vec2 id, in vec2 neighbor ) {\n    vec4 voronoiPoint = makeVoronoiPoint( id + neighbor );\n    st -= voronoiPoint.xy + neighbor;\n    \n#ifdef MANHATTAN\n    float d = abs( st.x ) + abs( st.y );\n#else\n#ifdef DOTTY\n    st = abs( st );\n    float d = dot( st, st ) / ( st.x + st.y );\n#else\n    float d = length( st );\n    d = dot( st, st ) ;/// (abs(st.x) + abs(st.y));\n#endif\n#endif\n\n    return vec3( d, voronoiPoint.xy );\n    return vec3( d, id );\n}\n\nvec3 voronoiToColor( in vec2 v ) {\n    vec3 a = mix( vec3(1.,.0,.0), vec3(.0,.0,1.), sin( v.x ) );\n    vec3 b = mix( vec3(.0,1.,.0), vec3(.5,.0,.5), sin( v.y ) );\n    return mix( a, b, cos( v.x * v.y ) );\n}\n\nvec3 calculateVoronoiPoint( in vec2 st, in vec2 id ) {\n    vec3 voronoi_n1_n1 = calculateVoronoiDistance( st, id, vec2( -1., -1. ) );\n    vec3 voronoi_n1_n0 = calculateVoronoiDistance( st, id, vec2( -1., -0. ) );\n    vec3 voronoi_n1_p1 = calculateVoronoiDistance( st, id, vec2( -1., +1. ) );\n    vec3 voronoi_n0_n1 = calculateVoronoiDistance( st, id, vec2( -0., -1. ) );\n    vec3 voronoi_n0_n0 = calculateVoronoiDistance( st, id, vec2( -0., -0. ) );\n    vec3 voronoi_n0_p1 = calculateVoronoiDistance( st, id, vec2( -0., +1. ) );\n    vec3 voronoi_p1_n1 = calculateVoronoiDistance( st, id, vec2( +1., -1. ) );\n    vec3 voronoi_p1_n0 = calculateVoronoiDistance( st, id, vec2( +1., -0. ) );\n    vec3 voronoi_p1_p1 = calculateVoronoiDistance( st, id, vec2( +1., +1. ) );\n\n    vec3 closest = vec3( 1e33 );\n#ifdef USE_MIX_INSTEAD_OF_IFS\n    closest = MIX( closest, voronoi_n1_n1, step( voronoi_n1_n1.x, closest.x ) );\n    closest = MIX( closest, voronoi_n1_n0, step( voronoi_n1_n0.x, closest.x ) );\n    closest = MIX( closest, voronoi_n1_p1, step( voronoi_n1_p1.x, closest.x ) );\n    closest = MIX( closest, voronoi_n0_n1, step( voronoi_n0_n1.x, closest.x ) );\n    closest = MIX( closest, voronoi_n0_n0, step( voronoi_n0_n0.x, closest.x ) );\n    closest = MIX( closest, voronoi_n0_p1, step( voronoi_n0_p1.x, closest.x ) );\n    closest = MIX( closest, voronoi_p1_n1, step( voronoi_p1_n1.x, closest.x ) );\n    closest = MIX( closest, voronoi_p1_n0, step( voronoi_p1_n0.x, closest.x ) );\n    closest = MIX( closest, voronoi_p1_p1, step( voronoi_p1_p1.x, closest.x ) );\n#else\n    if ( voronoi_n1_n1.x < closest.x ) closest = voronoi_n1_n1;\n    if ( voronoi_n1_n0.x < closest.x ) closest = voronoi_n1_n0;\n    if ( voronoi_n1_p1.x < closest.x ) closest = voronoi_n1_p1;\n    if ( voronoi_n0_n1.x < closest.x ) closest = voronoi_n0_n1;\n    if ( voronoi_n0_n0.x < closest.x ) closest = voronoi_n0_n0;\n    if ( voronoi_n0_p1.x < closest.x ) closest = voronoi_n0_p1;\n    if ( voronoi_p1_n1.x < closest.x ) closest = voronoi_p1_n1;\n    if ( voronoi_p1_n0.x < closest.x ) closest = voronoi_p1_n0;\n    if ( voronoi_p1_p1.x < closest.x ) closest = voronoi_p1_p1;\n#endif\n    return closest;\n}\n\nvec3 vornoing( in vec2 uv, float scale ) {\n    uv *= scale;\n    \n    vec2 st = fract( uv );\n    vec2 id = uv - st;\n\n    vec3 closest = calculateVoronoiPoint( st, id );\n#ifdef GLASSY\n    return voronoiToColor( closest.yz ) * closest.x;\n#else\n    return vec3( closest.x );\n#endif\n}\n\n////////////////////////////////////////////////////////////////\n// main\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = FROM_SCREEN( fragCoord );\n    \n#ifdef BASIC\n    fragColor = vec4( vornoing( uv, 4. ), 1. );\n    return;\n#endif\n\n    float t = iTime * .01;\n    float s = sin( t );\n    \n    vec3 color = vec3( .0 );\n    color += .4 * vornoing( uv + 33. * s, 1. );\n    color += .3 * vornoing( uv + 17. * s, 3. );\n    color += .2 * vornoing( uv +  9. * s, 7. );\n    color += .1 * vornoing( uv +  5. * s, 13. );\n    \n    color *= .5 + .5 * vec3( cos( t ), sin( t ), cos( t * 2. ) - sin( t * 2. + .77 ) );\n    \n    fragColor = vec4( color * GAMMA, 1. );\n}\n\n// EOF\n////////////////////////////////////////////////////////////////", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WlKyDm.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[1792, 1872, 1899, 1899, 2069], [2071, 2071, 2108, 2108, 2218], [2220, 2220, 2295, 2295, 2709], [2711, 2711, 2745, 2745, 2917], [2919, 2919, 2973, 2973, 5088], [5090, 5090, 5132, 5132, 5369], [5371, 5445, 5502, 5502, 6049]]}
{"id": "WlKyRD", "name": "Raymarching_domainID_samp", "author": "Haru86_", "description": "Raymarching_domainID_sample", "tags": ["raymarching"], "likes": 2, "viewed": 69, "published": "Public", "date": "1610605441", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI 3.14159265\n\nfloat rand(vec2 st)\n{\n    return fract(sin(dot(st, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\n float PerlinNoise(float x) {\n                float aL = rand(vec2(floor(x), 0.1));\n                float aR = rand(vec2(floor(x + 1.0), 0.1));\n                float wL = aL * fract(x);\n                float wR = aR * (fract(x) - 1.0);\n                float f = fract(x);\n                float u = pow(f, 2.0) * (3.0 - 2.0 * f);\n                float n = mix(wL, wR, u);\n\n                return n;\n            }\n\nfloat Box(vec3 p,vec3 size)\n{\n    return length(max(vec3(0.0),abs(p)-size));\n}\n\nfloat map(vec3 p,inout vec3 col,float freqs[4])\n{\n    p.z-=iTime;\n\n    vec3 pos=p;\n    float modNum=0.75;\n    //get axis random id\n    float xid=floor(pos.x/modNum);\n    float yid=floor(pos.y/modNum);\n    float zid=floor(pos.z/modNum);\n    \n    pos.xz=mod(pos.xz,modNum)-0.5*modNum;\n\n    //get constant id\n    int id=(int(floor(rand(vec2(xid,zid))*3.0)))%3;\n    float aud=0.0;\n    if(id==0)\n    {\n        col=vec3(1.0,0.0,0.0);\n        aud=freqs[0];\n    }else if(id==1)\n    {\n        col=vec3(0.0,1.0,0.0);\n        aud=freqs[1];\n    }else if(id==2)\n    {\n        col=vec3(0.0,0.0,1.0);\n        aud=freqs[2];\n    }\n    \n    return Box(pos,vec3(0.2,\n    aud*2.0\n   // +PerlinNoise(float(xid))*10.0+PerlinNoise(float(zid))*10.0\n    ,0.2))-0.15;\n    \n}\n\nfloat freqs[4];\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    freqs[0] = texture( iChannel0, vec2( 0.01, 0.25 ) ).x;\n\tfreqs[1] = texture( iChannel0, vec2( 0.07, 0.25 ) ).x;\n\tfreqs[2] = texture( iChannel0, vec2( 0.15, 0.25 ) ).x;\n\tfreqs[3] = texture( iChannel0, vec2( 0.30, 0.25 ) ).x;\n    //-----------\n\n    vec2 uv = (fragCoord.xy*2.0-iResolution.xy)/min(iResolution.x,iResolution.y);\n    vec3 col = vec3(0,0,0);\n \n    vec3 ro=vec3(0.0,-8.0,6.0);\n    vec3 target=vec3(0,0,0);\n    vec3 cDir=normalize(target-ro);\n    vec3 cSide=cross(cDir,vec3(0.0,1.0,0.0));\n    vec3 cUp=cross(cDir,cSide);\n    float depth=1.0;\n    vec3 rd=vec3(uv.x*cSide+uv.y*cUp+depth*cDir);\n    \n       vec3 mapCol = vec3(0);\n    float d, t = 0.;\n    for(int i=0;i<128;i++)\n    {\n        d = map(ro + rd*t, mapCol,freqs);\n        if(d<0.001||t>100.0)break;\n        t+=d*.35;\n    }\n    \n   \n    vec3 p = ro + rd*t;\n    // Directional derivative lighting.   \n    float dif = max((map(p - .01, mapCol,freqs) - map(p, mapCol,freqs))/.01, 0.);\n    col = vec3(exp(-0.05*t))*mapCol*(dif + .2)*2.;\n\n    fragColor = vec4(sqrt(max(col, 0.)), 1); // Gamma correction.\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WlKyRD.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[23, 23, 44, 44, 114], [117, 117, 145, 145, 527], [529, 529, 558, 558, 607], [609, 609, 658, 658, 1357], [1376, 1376, 1433, 1433, 2505]]}
{"id": "WlKyRt", "name": "sphere reflection", "author": "regis", "description": "sphere and cube reflection", "tags": ["3d", "fractal", "raymarch"], "likes": 3, "viewed": 56, "published": "Public", "date": "1611601750", "time_retrieved": "2021-10-01T00:00:00", "image_code": "mat2 Rot(float a){\n    float s = sin(a);\n    float c = cos(a);\n    return mat2(c, -s, s, c);\n}\n\nmat3 RotX(float a){\n    float s = sin(a);\n    float c = cos(a);\n    \n    return mat3(1., .0, .0, .0, c, -s, .0, s, c);\n\n}\n\nmat3 RotY(float a){\n    float s = sin(a);\n    float c = cos(a);\n    \n    return mat3(c, .0, s, .0, 1., .0, -s, .0, c);\n\n}\n\nmat3 RotZ(float a){\n    float s = sin(a);\n    float c = cos(a);\n    \n    return mat3(c, -s, .0, s, c, .0, .0, .0, 1.);\n\n}\n\nfloat Box(vec3 p, vec3 sc, float r){\n    return length(max(abs(p)-sc, 0.))-r;\n}\n\nfloat N21(vec2 p){\n    p = fract(p*vec2(233.34, 851.73));\n    p += dot(p, p+23.45);\n    return fract(p.x*p.y);\n\n}\n\nvec2 map(vec3 p){\n\n    vec2 d = vec2(0.0);\n   \n    \n    \n    vec3 c = vec3(5.0, 4.0, 5.0);\n    vec3 q = mod(p+0.5*c,c)-0.5*c;\n    q = abs(q);\n    \n    float sp;\n    float time = mod(iTime, 10.0);\n    if(time < 5.0)\n        sp= length(q - vec3(0.0, 2.0, 0.0)) - 1.2;\n    else\n        sp = Box(q - vec3(0.0, 2.0, 0.0), vec3(1.0), 0.1);\n    \n   \n    d.x = sp;\n    d.y = 1.0;\n    \n    \n   \n    \n    return d;\n\n}\n\nvec3 RM(vec3 ro, vec3 rd, float _d){\n    vec3 d = vec3(_d, 0.0, 0.0);\n    for(int i = 0;i < 100;i++){\n        d.yz = map(ro + d.x * rd).xy;\n        \n        if(abs(d.y) <(0.001))\n            break;\n            \n        d.x += d.y;\n        \n        if(d.x > 30.0)break;\n    \n    }\n    if(d.x > 30.0)d.x = -1.0;\n    \n    return d;\n    \n}\n\nvec3 calcNormal( in vec3 pos, in float t, in float px )\n{\n    vec4 tmp;\n    vec2 e = vec2(1.0,-1.0)*0.5773*0.25*px;\n    return normalize( e.xyy*map( pos + e.xyy ).x + \n\t\t\t\t\t  e.yyx*map( pos + e.yyx ).x + \n\t\t\t\t\t  e.yxy*map( pos + e.yxy ).x + \n\t\t\t\t\t  e.xxx*map( pos + e.xxx ).x );\n}\n\nfloat calcAO( in vec3 pos, in vec3 nor )\n{\n\tfloat occ = 0.0;\n    float sca = 1.0;\n    for( int i=0; i<5; i++ )\n    {\n        float hr = 0.01 + 0.12*float(i)/4.0;\n        vec3 aopos =  nor * hr + pos;\n        float dd = map( aopos ).x;\n        occ += -(dd-hr)*sca;\n        sca *= 0.95;\n    }\n    return clamp( 1.0 - 3.0*occ, 0.0, 1.0 );    \n}\n\n\n\n\nvec3 getLight(vec3 p, vec3 ro, vec3 rd, vec3 lightpos, out vec3 n, vec2 uv){\n    vec2 e = vec2(0.01, 0.0);\n    vec2 nd = map(p);\n\n    n = nd.x - vec3(map(p - e.xyy).x ,\n                        map(p- e.yxy).x ,\n                        map(p- e.yyx).x );\n\n    n = normalize(n);\n    \n        \n    \n    vec3 l = normalize(lightpos-p);\n    \n    float occ = calcAO(p, n); \n    float dif = clamp(dot(n, l), 0.0, 1.0);\n    dif += occ;\n    \n   \n    \n    vec3 op = p;\n    rd = reflect(rd, n);\n    vec3 sh = RM(ro+n*0.003, rd, 0.0);\n    p = ro + rd * sh.x;\n    \n    ro += rd*sh.x;\n    nd = map(ro);\n\n    n = nd.x - vec3(map(ro - e.xyy).x ,\n                        map(ro- e.yxy).x ,\n                        map(ro- e.yyx).x );\n\n    n = normalize(n);\n    float occ2 = calcAO(p, n); \n    float dif2 = clamp(dot(n, l), 0.0, 1.0);\n    dif2 += occ2;\n    \n    float spec = pow(max( dot( reflect(-l, n), -rd ), 0.), 8.);\n    \n    vec3 col = vec3(0.0);\n       \n    \n\n    if(sh.z == 1.0){\n         vec3 c = vec3(5.0,4.0,5.0);\n        //vec2 id = floor((op.xz+0.5*c.xz)/c.xz-0.5*c.xz);\n        vec2 id = floor(mod(p.xz+0.5*c.xz,c.xz)-0.5*c.xz);\n        float m = 0.0;\n\n\n        for(int y = -1;y <=1;y++){\n            for(int x =-1;x<=1;x++){\n\n                m += N21(id-vec2(x, y));\n            }\n\n        }\n        m = m/9.0;\n       \n        float cn = m;\n        vec3 cl;\n        if(cn <0.25)cl = vec3(0.50, 0.3, 0.2);\n        else if(cn <0.5)cl = vec3(0.3, 0.5, 0.2);\n        else if(cn <0.75)cl = vec3(0.3, 0.2, 0.5);\n        else if(cn <=1.0)cl = vec3(1.0, 0.5, 0.0);\n        //col = mix(col ,  vec3(dif2) * cl, 0.7);\n        col = vec3(dif2) * cl*2.0 ;\n        col += spec*100.;\n        return col;\n\n    }\n\n    else\n        return vec3(dif);\n   \n   \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    uv -= 0.5;\n    uv /= vec2(iResolution.y/iResolution.x, 1.0);\n    \n    // Time varying pixel color\n    vec3 col = vec3(0.0);\n    \n       \n    vec3 p;\n    vec3 ro = vec3(-2.0, -0.5, -7.0); \n    vec3 lookat = vec3((iMouse.x/iResolution.x)*10.0, (iMouse.y/iResolution.y)*30.0, 30.0);\n    //vec3 rd = normalize(vec3(0.0, 1.0, 0.0));\n    vec3 lightpos = vec3(0.0, 5.0, -1.0);\n        \n    vec3 dirc = vec3(0.0, 2.0, 0.0);\n        \n    float an = (iMouse.x/iResolution.x)*10.0;\n    float anx = (iMouse.y/iResolution.y)*10.0;\n    ro -= dirc;\n    lookat -= dirc;\n    ro *= RotZ(anx);\n    lookat *= RotZ(anx);\n    ro *= RotX(anx);\n    lookat *= RotX(anx);\n    ro *= RotY(an);\n    lookat *= RotY(an);\n    ro += dirc;\n    lookat += dirc;\n    \n    lightpos -= dirc;\n    lightpos *= RotZ(anx);\n    lightpos *= RotX(anx);\n    lightpos *= RotY(an);\n    lightpos += dirc;\n    \n    lightpos.z += iTime*5.0;\n    dirc.z += iTime*5.0;\n    ro.z += iTime*5.0;\n    lookat.z += iTime*5.0;\n    lookat -= dirc;\n    lookat *= RotY(iTime/5.0);\n    lookat += dirc;\n    \n    \n    float zoom = 1.0;    \n    vec3 f = normalize(lookat-ro),\n        r = normalize(cross(vec3(0,1,0), f)),\n        u = cross(f, r),\n        c = ro + f * zoom,\n        i = c + uv.x * r + uv.y * u,\n        rd = normalize(i-ro);\n    \n    float dan = 0.0;\n    vec3 d = RM(ro, rd, dan);\n    \n    vec4 rc;\n    if(d.x > 0.0){\n        p = ro + d.x * rd;\n        \n        vec3 n;\n        vec3 dif = getLight(p, ro, rd, lightpos, n, uv);\n    \n        if(d.z == 1.0){\n            vec3 c = vec3(5.0,4.0,5.0);\n            //vec2 id = floor((op.xz+0.5*c.xz)/c.xz-0.5*c.xz);\n            vec2 id = floor(mod(p.xz+0.5*c.xz,c.xz)-0.5*c.xz);\n            float m = 0.0;\n                \n\n            for(int y = -1;y <=1;y++){\n                for(int x =-1;x<=1;x++){\n\n                    m += N21(id-vec2(x, y));\n                }\n\n            }\n            m = m/9.0;\n            \n            float cn = m;\n            vec3 cl;\n            if(cn <0.25)cl = vec3(0.0, 1.0, 0.0);\n            else if(cn <0.5)cl = vec3(1.0, 0.5, 0.0);\n            else if(cn <0.75)cl = vec3(1.0, 0.5, 1.0);\n            else if(cn <=1.0)cl = vec3(0.0, 0.5, 1.0);\n            col = dif * cl;\n            \n           \n        \n        }\n        else if(d.z == 2.0){\n            col = dif * vec3(1.0, 1.0, 0.1);\n        \n        \n        }\n\n    }                 \n                        \n    \n    \n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WlKyRt.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 18, 18, 94], [96, 96, 115, 115, 217], [219, 219, 238, 238, 340], [342, 342, 361, 361, 463], [465, 465, 501, 501, 544], [546, 546, 564, 564, 659], [661, 661, 678, 678, 1068], [1070, 1070, 1106, 1106, 1405], [1407, 1407, 1464, 1464, 1687], [1689, 1689, 1731, 1731, 2030], [2035, 2035, 2111, 2111, 3773], [3775, 3775, 3832, 3882, 6386]]}
{"id": "wlKyWR", "name": "Raymarched Apple", "author": "mothman", "description": "practice shader based on\nhttps://www.youtube.com/watch?v=CHmneY8ry84", "tags": ["raymarching"], "likes": 2, "viewed": 51, "published": "Public", "date": "1610995870", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float hash(float n){\n    return fract(sin(n)*43758.5453);\n}\nfloat noise(in vec3 pos)\n{\n    vec3 p = floor(pos);\n    vec3 k = fract(pos);\n    k = k*k*(3.0f-2.0f*k);\n    float n = p.x + p.y * 57.0 + p.z * 113.0; //seed\n    \n    float a = hash(n);\n    float b = hash(n+1.0);\n    float c = hash(n+57.0);\n    float d = hash(n+58.0);\n    \n    float e = hash(n+113.0);\n    float f = hash(n+114.0);\n    float g = hash(n+170.0);\n    float h = hash(n+171.0);\n    \n    float res = mix(mix(mix(a,b,k.x),mix(c,d,k.x),k.y),\n                    mix(mix(e,f,k.x),mix(g,h,k.x),k.y),\n                    k.z);\n    return res;\n}\nfloat fbm(in vec3 pos)\n{\n    vec3 p = pos;\n    float f = 0.5000*noise(p); p*=2.02;\n    f += 0.2500*noise(p); p*=2.03;\n    f += 0.1250*noise(p); p*=2.01;\n    f += 0.0625*noise(p);\n    return f/0.9375;\n}\nvec3 tableMaterial(in vec3 pos, in vec3 norm)\n{\n    vec3 col = vec3(0.8,0.7,0.2);\n    float f = fbm(pos*vec3(6.0,0.0,0.5));\n    col = mix(col,vec3(0.3,0.2,0.1),f);\n    f = smoothstep( 0.6, 1.0, fbm(pos*48.0));\n    col = mix( col, vec3(0.2,0.2,0.15), f);\n    \n    float ao = 0.2 + 0.8*smoothstep( 0.4,2.0, length( pos.xz));\n    col *= ao;\n    return col;\n}\nvec3 fruitMaterial(in vec3 pos, in vec3 norm)\n{\n    \n    float a = atan( pos.x, pos.y);\n    float r = length(pos.xz);\n    vec3 col = vec3(1.0,0.2,0.02);\n    \n    //col += vec3(0.0,0.50,0.0);//*fbm(pos);\n    \n    //Make it green\n    float f = smoothstep(0.2,1.0f,fbm((pos)));\n    col = mix(col, vec3(0.8,1.0,0.2),f);\n    \n    //Make it dirty\n    f = smoothstep(0.0,1.0,fbm(pos*4.0));\n    col *= 0.7 + 0.3*f;\n    \n    //Freckles\n    f = smoothstep(0.7,0.9,fbm(pos*48.0));\n    col = mix(col,vec3(0.9,1.0,0.6),f);\n    \n    // stripes\n    f = fbm( vec3(a*7.0, pos.y, pos.z));\n    f *= smoothstep( 0.4, 1.2, pos.y + 0.5 * ( noise(pos.yxz)-0.5));\n    col = mix(col, vec3(0.4,0.2,0.0),f);\n    \n    // top cap\n    f = smoothstep( 0.1, 0.2, r);\n    col = mix( col, vec3(0.6,0.6,0.5),1.-f);\n    //Fake AO\n    float ao = 0.55 + 0.45*norm.y;\n    col *= ao;\n    return col;\n}\nvec2 fruitShape(in vec3 pos)\n{\n    float f = pow(dot(pos.xz,pos.xz),0.2);\n    pos.y -= 0.5*f;\n    vec2 d = vec2(length(pos-vec3(0.0,0.0,0.0))-1.0 ,1.0);\n    return d;\n}\nvec2 tableShape(in vec3 pos)\n{\n    vec2 d = vec2(length(pos.y + 0.5),2.0);\n    return d;\n}\nvec2 map(in vec3 pos)\n{\n    vec2 d1 = fruitShape(pos);\n    vec2 d2 = tableShape(pos);\n    if(d2.x < d1.x)\n    {\n        d1 = d2;\n    }\n    return d1;\n}\nfloat softShadows(in vec3 ro, in vec3 rd)\n{\n  float res = 1.0;\n  for(float t = 0.1; t < 8.0f;)\n  {\n      float h = map( ro + rd*t).x;\n      if(h < 0.01) return 0.0f;\n      res = min(res,6.0f*h/t);\n      t += h;\n  }\n  res = smoothstep(0.0,1.0,res);\n  //res = sqrt(res);\n  return res;\n}\nvec2 intersect(in vec3 ro, in vec3 rd)\n{\n    for( float t = 0.0; t < 8.0;){\n        vec2 h = map( ro + rd*t);\n        if(h.x < 0.0001) return vec2(t,h.y);\n        t += h.x;\n    }\n    return vec2(0.);\n}\nvec3 calcNorm(in vec3 pos)\n{\n    vec3 e = vec3(0.0001,0.0,0.0);\n    vec3 n;\n    n.x = map(pos+e.xyy).x - map(pos - e.xyy).x;\n    n.y = map(pos+e.yxy).x - map(pos - e.yxy).x;\n    n.z = map(pos+e.yyx).x - map(pos - e.yyx).x;\n    \n    return normalize(n);\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 q = vec2(-1.0+2.0*uv)*vec2(iResolution.x/iResolution.y,1.0);\n //   vec3 ro = vec3(0.0,0.00,2.40);\n   vec3 ro = 2.0*vec3(cos(iTime), 0.0, sin(iTime))+vec3(0,2.,0.0);\n   //vec3 rd = vec3( vec2(-1.0 +2.0*uv),-1.0);\n   //vec3(0.0,0.00,-3.50));\n    vec3 ww = normalize(-ro);\n    vec3 uu = normalize(cross(vec3(0.,1.,0.),ww));\n    vec3 vv = normalize(cross(ww,uu));\n    vec3 rd = normalize( uu* q.x + vv * q.y + 1.5* ww);\n    vec2 t = intersect(ro, rd);\n    vec3 col = vec3(0.80);\n    if(t.y > 0.5)\n    {\n        vec3 pos = ro + t.x*rd;\n        vec3 norm = calcNorm(pos);\n        vec3 lig = normalize(vec3(1.0,0.80,0.60));\n        vec3 blig = vec3( -lig.x, lig.y, -lig.z);\n        float diff = max(dot(lig,norm),0.0);\n        float bac = max( 0.0, 0.2+ 0.8*dot(norm,blig));\n        vec3 ref = normalize(reflect(rd,norm));\n        float spe = pow(clamp(dot(ref,lig),0.0,1.0),32.0);\n        float rim = pow(1.0 + dot(norm,rd),2.5);\n        float con = 1.0;\n        float amb = 0.5+0.5*norm.y;\n        float sha = softShadows(pos,lig);\n        \n        //col = vec3(1.0,1.0,1.0);\n        col = con*vec3(0.1,0.15,0.2);\n        col += amb*vec3(0.1,0.15,0.2);\n        col += diff*vec3(1.0,0.97,0.85)*sha;\n        col += bac*vec3(1.0,0.97,0.85);\n        col = col*0.3 + 0.7*sqrt(col);\n        col *= 0.5;\n        if(t.y > 1.5)\n        {\n            col *= tableMaterial(pos,norm);\n        }\n        else\n        {  \n            col *= fruitMaterial(pos,norm);\n        }\n        col += 0.3*rim*amb;\n        col += 0.7*spe*sha*amb;\n    }\n    col *= 0.2 + 0.8*pow(uv.x*uv.y*(1.0-uv.x)*(1.0-uv.y),0.10);\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wlKyWR.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 20, 20, 59], [60, 60, 86, 86, 609], [610, 610, 634, 634, 811], [812, 812, 859, 859, 1167], [1168, 1168, 1215, 1215, 2029], [2030, 2030, 2060, 2060, 2198], [2199, 2199, 2229, 2229, 2289], [2290, 2290, 2313, 2313, 2441], [2442, 2442, 2485, 2485, 2726], [2727, 2727, 2767, 2767, 2928], [2929, 2929, 2957, 2957, 3183], [3184, 3184, 3241, 3291, 4984]]}
{"id": "wlKyWt", "name": "Wave generator sphere", "author": "ma38su", "description": "a vibrating sphere on the surface of the water. I don't guarantee physical correctness.", "tags": ["pathtracingraymarching"], "likes": 6, "viewed": 88, "published": "Public", "date": "1612003962", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const float PI = 3.14159265;\nconst float EPS = 0.001;\nconst float INF = 5.;\n\nconst vec3 top_color = vec3(.2, .6, 1.);\nconst vec3 horizon_color = vec3(.9);\n\nconst vec3 water_bottom_color = vec3(0., .2, .5);\nconst vec3 water_horizon_color = vec3(0., 0., 1.);\n\nvec3 sky_color(vec3 rd) {\n  float t = 0.5 * (rd.y + 1.0);\n  return t * top_color + (1.0 - t) * horizon_color;\n}\n\nvec3 water_color(vec3 rd) {\n  float t = 0.5 * (-rd.y + 1.0);\n  return t * water_bottom_color + (1.0 - t) * water_horizon_color;\n}\n\nvec4 plane = vec4(0.0, 1.0, 0.0, 2.0);\n\nfloat distPlane(vec3 p, vec4 n) {\n  return dot(p, n.xyz) * n.w;\n}\n\nfloat distSphere(vec3 p, vec3 c, float r) {\n  return length(p - c) - r;\n}\n\nfloat distFunc(vec3 p) {\n  float r = .2;\n  float theta = iTime * PI * 6.0 / 3.;\n  vec3 c = vec3(0., r + (cos(theta + 0.1) - 0.5) * .01, 0.);\n\n  float d1 = distSphere(p, c, r);\n  float d2 = distPlane(p, plane);\n  float dist = length(p.xz);\n  d2 += sin(dist * PI * 10.0 - theta) * 0.003 / max(dist * dist * 3., 1.);// * max(1. / dist, 1.);\n  return min(d1, d2);\n  return d2;\n}\n\nconst vec3 dx = vec3(EPS, 0, 0);\nconst vec3 dy = vec3(0, EPS, 0);\nconst vec3 dz = vec3(0, 0, EPS);\n\nvec3 normal(in vec3 p) {\n  return normalize(vec3(\n  \tdistFunc(p + dx) - distFunc(p - dx),\n  \tdistFunc(p + dy) - distFunc(p - dy),\n  \tdistFunc(p + dz) - distFunc(p - dz)\n  ));\n}\n\nfloat schlick(const float cosine, const float ref_idx) {\n    float r0 = (1. - ref_idx) / (1. + ref_idx);\n    r0 = r0 * r0;\n    return r0 + (1. - r0) * pow((1. - cosine), 5.);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  vec2 r = iResolution.xy;\n  vec2 p = (fragCoord.xy * 2. - r) / min(r.x,r.y);\n  vec3 ta = vec3(p, 0.);\n  vec3 ro0 = vec3(0., 0.1, -1.);\n  vec3 rd = normalize(ta - ro0);\n  \n  float t = 0.;\n  vec3 albedo = vec3(1.);\n  vec3 sphere_color = vec3(0.99, 0.99, 0.);\n  float ray_rate = 1.;\n  vec3 col = vec3(0.);\n  for (int ns = 0; ns < 96; ++ns) {\n    vec3 ro = ro0 + rd * t;\n    float d = distFunc(ro);\n    if (length(ro) > INF) break;\n    if (d < EPS) {\n      vec3 nv = normal(ro);\n\n      vec3 reflected = reflect(rd, nv);\n      if (ro.y > 0.01) {\n        if (sphere_color.x > 1.0 || sphere_color.y > 1. || sphere_color.z > 1.0) {\n          col += ray_rate * albedo * sphere_color;\n          fragColor = vec4(sqrt(col), 1.);\n          return;\n        }\n        t = max(d, EPS * 1.5);\n        rd = reflected;\n        ro0 = ro;\n        albedo *= sphere_color;\n        continue;\n      }\n\n      float ref_idx = 1.3330; // water\n      float etai_over_etat = 1.0 / ref_idx; // front face\n      float cos_theta = min(dot(-rd, nv), 1.0);\n      float sin_theta = sqrt(1.0 - cos_theta*cos_theta);\n\n      if (etai_over_etat * sin_theta > 1.0) {\n        rd = reflected;\n      } else {\n        float rate = schlick(cos_theta, etai_over_etat);\n        col += ray_rate * (1. - rate) * water_color(refract(rd, nv, etai_over_etat));\n        ray_rate *= rate;\n        rd = reflected;\n      }\n      t = max(d, EPS * 1.5);\n      ro0 = ro;\n    }\n    t += d * .5;\n  }\n  \n  col += ray_rate * albedo * sky_color(rd);\n\n  fragColor = vec4(sqrt(col), 1.);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wlKyWt.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[258, 258, 283, 283, 369], [371, 371, 398, 398, 500], [542, 542, 575, 575, 607], [609, 609, 652, 652, 682], [684, 684, 708, 708, 1058], [1160, 1160, 1184, 1184, 1336], [1338, 1338, 1394, 1394, 1514], [1516, 1516, 1571, 1571, 3096]]}
{"id": "wlKyz3", "name": "SDF voxels", "author": "DragonWolf", "description": "Determines the state of a voxel (outside, edge or inside) given an SDF function by marching circles around the perimeter of a square of progressively smaller size until a minsize is reached (i.e. the size of pixel in this case)", "tags": ["sdfvoxel"], "likes": 7, "viewed": 269, "published": "Public", "date": "1611487404", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/*\n * Similar to my first two shaders of a similar name, but this one\n * effectively ray marches the perimeter of the voxel using circles\n * to check if the sdf lies inside the voxel to a given degree of accuracy (the size of a pixel).\n *\n * It also does the checks in a slightly larger area than the voxel to catch edge cases where an sdf resolves to\n * less than minstep size between two voxels.\n */\n\n#define gridSize1 5.0\n#define gridSize2 10.0\n#define gridSize3 20.0\n#define gridSize4 40.0\n\nfloat cornerRadiusMultiplier2d = 3.-2./sqrt(2.)-sqrt(2.); // 0.17157287525\nfloat cornerRadiusMultiplier3d = 3./16.; // 0.1875\n\nfloat sdBox( vec2 p, in vec2 bounds )\n{\n    vec2 d = abs(p)-bounds;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\nfloat sdCircle(vec2 p, float radius) {\n    return length(p) - radius;\n}\n\nfloat sdArc( in vec2 p, in vec2 sca, in vec2 scb, in float ra, float rb )\n{\n    p *= mat2(sca.x,sca.y,-sca.y,sca.x);\n    p.x = abs(p.x);\n    float k = (scb.y*p.x>scb.x*p.y) ? dot(p.xy,scb) : length(p.xy);\n    return sqrt( dot(p,p) + ra*ra - 2.0*ra*k ) - rb;\n}\n\nvec2 pixelSize() {\n    return 2.0 * ((vec2(iResolution.x, iResolution.y) - (0.5*iResolution.xy))/iResolution.y) / iResolution.xy;\n}\n\nfloat sdf(vec2 uv) {\n\n    vec2 pixelSize = pixelSize();\n    \n    float screenEdgeMargin = 0.5;\n\n    float radius1 = 0.25 * (1.0 + sin(iTime * 0.6));\n    vec2 position1 = vec2(sin(iTime * 0.2) * (iResolution.x / iResolution.y) * (1. - screenEdgeMargin), sin(iTime * 0.10) * (1. - screenEdgeMargin));\n    float circle1 = sdCircle(uv - position1, radius1);   \n    \n    // 1/10th the size of a pixel circles\n    float radius3 = 0.1 * min(pixelSize.x, pixelSize.y); \n    vec2 position3 = vec2(sin(iTime * 0.6) * (iResolution.x / iResolution.y) * (1. - screenEdgeMargin), sin(iTime * 0.6) * (1. - screenEdgeMargin));\n    float circle3 = sdCircle(uv - position3, radius3);\n    \n    // animation\n    float ta = 3.14*(0.5+0.5*cos(iTime*0.52+2.0));\n    float tb = 3.14*(0.5+0.5*cos(iTime*0.31+2.0));\n    float rb = 0.15*(0.5+0.5*cos(iTime*0.41+3.0));\n    float size = 1.;\n    \n    // distance\n    // vec2 arcPosition1 = vec2(sin(iTime * 0.25) * (iResolution.x / iResolution.y) * (1. - screenEdgeMargin), sin(iTime * 0.25) * (1. - screenEdgeMargin));\n    vec2 arcPosition1 = vec2(0.,0.);\n    // vec2 arcPosition1 = vec2(0.542,0.543);\n    float arc1 = sdArc(uv - arcPosition1,vec2(sin(ta),cos(ta)),vec2(sin(tb),cos(tb)), size, rb);\n    \n    return min(min(circle1, circle3), arc1);\n}\n    \nbool insideBoundingSquare(vec2 position, vec2 bound) {\n\n    vec2 pixelSize = pixelSize();\n\n    // We'll check just outside of the square to catch cases where the sdf resolves in sub-pixel level between\n    // two squares. This means we potentially treat a square as inside/touching when it isn't but better than\n    // artefacts due to this scenario.\n    vec2 adjustedBound = bound + pixelSize;\n\n    // If all points inside the grid's outer circle are negative, then we're definitely inside.\n    float midpointD = sdf(position);\n    if (midpointD <= -length(adjustedBound)) {\n        return true;\n    } else if (abs(midpointD) < min(adjustedBound.x, adjustedBound.y)) {\n        // There is an sdf edge inside the inner circle, so must not be completely inside.\n        return false;\n    }\n    \n    // For each corner,\n    for (float x = 0.; x < 2.; x++) {\n        for (float y = 0.; y < 2.; y++) {\n            vec2 cornerDirection = normalize(vec2(-1.0 + 2. * x, -1.0 + 2.0 * y)); // -1.0, -1.0 to 1.0, 1.0\n            float r = adjustedBound.x; // Set radius of to radius of inner circle of square.\n            float distFromMidpoint = r; // Total distance from midpoint to corner circle midpoint.\n\n            // Keep shrinking the corner circle until we reach pixel size (or return a value inside).\n            while (r >= min(pixelSize.x, pixelSize.y)) {\n            \n                // Calculate size of inscribed circle in corner.\n                r = cornerRadiusMultiplier2d * r;\n                distFromMidpoint += r; // Move to midpoint of new circle\n                vec2 cornerCircleMidpoint = position + cornerDirection * distFromMidpoint;\n                distFromMidpoint += r; // Move to edge of circle for next circle\n                \n                // We march in a clock-wise direction around the perimeter.\n                float posOrNeg = 1. - x*2.; // 1 or -1\n                float applyX = abs(x-y); // 1 or 0\n                float applyY = abs(applyX - 1.); // 1 or 0\n                vec2 edgeDirection = vec2(applyX * posOrNeg, applyY * posOrNeg);\n                \n                // March along the edge.\n                for (float i = r; i < adjustedBound.x - r; i = i + r) {\n                    vec2 midpoint = cornerCircleMidpoint + i * edgeDirection;\n                    if (sdf(midpoint) > r) {\n                        return false;\n                    }\n                }\n            }\n        }\n    }\n    \n            \n    return true;\n}\n\nbool touchingBoundingSquare(vec2 position, vec2 bound) {\n\n    vec2 pixelSize = pixelSize();\n\n    // We'll check just outside of the square to catch cases where the sdf resolves in sub-pixel level between\n    // two squares. This means we potentially treat a square as inside/touching when it isn't but better than\n    // artefacts due to this scenario.\n    vec2 adjustedBound = bound + pixelSize;\n\n    // If all points inside the grid's outer circle are outside,\n    // then we're definitely outside and not touching.\n    float midpointD = sdf(position);\n    if (midpointD > length(adjustedBound)) {\n        // Doesn't touch outer circle, so must be completely outside sdf volume.\n        return false;\n    } else if (midpointD < min(adjustedBound.x, adjustedBound.y)) {\n        // Touches inner circle so must be inside square.\n        return true;\n    }\n\n    // For each corner,\n    for (float x = 0.; x < 2.; x++) {\n        for (float y = 0.; y < 2.; y++) {\n            vec2 cornerDirection = normalize(vec2(-1.0 + 2. * x, -1.0 + 2.0 * y)); // -1.0, -1.0 to 1.0, 1.0\n            float r = adjustedBound.x; // Set radius of to radius of inner circle of square.\n            float distFromMidpoint = r; // Total distance from midpoint to corner circle midpoint.\n\n            // Keep going until we reach pixel size or exit condition.\n            while (r >= min(pixelSize.x, pixelSize.y)) {\n            \n                // Calculate size of inscribed circle in corner.\n                r = cornerRadiusMultiplier2d * r;\n                distFromMidpoint += r; // Move to midpoint of new circle\n                vec2 cornerCircleMidpoint = position + cornerDirection * distFromMidpoint;\n                distFromMidpoint += r; // Move to edge of circle for next circle\n                float posOrNeg = 1. - x*2.; // 1 or -1\n                float applyX = abs(x-y); // 1 or 0\n                float applyY = abs(applyX - 1.); // 1 or 0\n                vec2 edgeDirection = vec2(applyX * posOrNeg, applyY * posOrNeg);\n                // March along the edge.\n                for (float i = r; i < adjustedBound.x - r; i = i + r) {\n                    vec2 midpoint = cornerCircleMidpoint + i * edgeDirection;\n                    if (sdf(midpoint) <= r) {\n                        return true;\n                    }\n                }\n            }\n        }\n    }\n    \n    return false;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 pixelSize = pixelSize();\n\n    // Normalized pixel coordinates (from y = -1 to 1 with 0,0 in the center of the screen)\n    vec2 uv = 2.0 * (fragCoord - (0.5*iResolution.xy))/iResolution.y;\n    \n    vec2 minScreenExtent = 2.0 * (vec2(0,0) - (0.5*iResolution.xy))/iResolution.y;\n    vec2 maxScreenExtent = 2.0 * (iResolution.xy - (0.5*iResolution.xy))/iResolution.y;\n    \n    // Calculate SDF\n    float d = sdf(uv);\n\n    float gridSize;\n    if (uv.x > minScreenExtent.x + 3. * (maxScreenExtent.x - minScreenExtent.x) / 4.) {\n        gridSize = gridSize4;\n    } else if (uv.x > minScreenExtent.x + 2. * (maxScreenExtent.x - minScreenExtent.x) / 4.) {\n        gridSize = gridSize3;\n    } else if (uv.x > minScreenExtent.x + 1. * (maxScreenExtent.x - minScreenExtent.x) / 4.) {\n        gridSize = gridSize2;\n    } else {\n        gridSize = gridSize1;\n    }\n\n    // Bounding Box\n    vec2 voxelMidpoint = vec2((floor(uv.x * gridSize) / gridSize) + (0.5 / gridSize), (floor(uv.y * gridSize) / gridSize) + (0.5 / gridSize));\n    vec2 voxelSize = vec2(0.5 / gridSize, 0.5 / gridSize);\n    vec2 minExtent = voxelMidpoint - voxelSize;\n    vec2 maxExtent = voxelMidpoint + voxelSize;\n    float box1 = sdBox(voxelMidpoint - uv, voxelSize);\n    \n    // Work out if the SDF is inside the box or not.\n    bool touching = touchingBoundingSquare(voxelMidpoint, voxelSize);\n    bool inside = false;\n    if (touching) {\n        inside = insideBoundingSquare(voxelMidpoint, voxelSize);\n    }\n    \n    bool outside = !touching;\n\n    vec3 statusColor = vec3(1.0, 1.0, 0.0);\n    if (inside) {\n        statusColor = vec3(0.0, 1.0, 0.0);\n    } else if (outside) {\n        statusColor = vec3(1.0, 0.0, 0.0);\n    }\n\n    // Set base colour depending on inside or outside bounding box.\n    vec3 baseColor = vec3(0.1,0.4,0.7);\n   \n    // Taken from iq to visualize sdf distances (https://www.shadertoy.com/view/4lcBWn)    \n    vec3 col = vec3(1.0) - sign(d)*baseColor;\n\tcol *= 1.0 - exp(-3.0*abs(d));\n\tcol *= 0.8 + 0.2*cos(120.0*d);\n\tcol = mix( col, vec3(1.0), 1.0-smoothstep(0.0,0.008,abs(d)));\n    \n    // Add the grid\n    col = mix( col, statusColor, 1.0 - smoothstep(0.0,0.008,abs(box1)) );\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wlKyz3.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[553, 622, 661, 661, 746], [748, 748, 786, 786, 819], [821, 821, 896, 896, 1080], [1082, 1082, 1100, 1100, 1213], [1215, 1215, 1235, 1235, 2486], [2492, 2492, 2546, 2546, 4960], [4962, 4962, 5018, 5018, 7340], [7342, 7342, 7399, 7399, 9633]]}
{"id": "WlKyzh", "name": "Inside a Tesseract", "author": "pprovins", "description": "An SDF function for a Bounding Box is used to create a \"tesseract\" fit enough for Matthew McConaughey to get lost in.", "tags": ["sdf", "boundingbox"], "likes": 1, "viewed": 120, "published": "Public", "date": "1610469481", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Credits to iquilezles fir SDF functions, https://www.iquilezles.org/www/articles/distfunctions/distfunctions.htm\n// Creduts to Marius Horga for his Raymarching write-up, http://metalkit.org/2016/12/30/raymarching-in-metal.html\n\nstruct Ray {\n    vec3 origin;\n    vec3 direction;\n};\n\nstruct BoundingBox {\n    vec3 center;\n    vec3 bounds;\n    float edge;\n};\n\nfloat distToBoundingBox(Ray ray, BoundingBox bb) {\n    vec3 p = abs(ray.origin - bb.center) - bb.bounds;\n    vec3 q = abs(p + bb.edge) - bb.edge;\n    return min(min(\n             length(max(vec3(p.x,q.y,q.z),0.0))+min(max(p.x,max(q.y,q.z)),0.0),\n             length(max(vec3(q.x,p.y,q.z),0.0))+min(max(q.x,max(p.y,q.z)),0.0)),\n             length(max(vec3(q.x,q.y,p.z),0.0))+min(max(q.x,max(q.y,p.z)),0.0)\n    );\n}\n\nfloat distToBoundingBoxScene(Ray r) {\n    BoundingBox bb = BoundingBox(vec3(1.0), vec3(1.0), 0.05);\n    Ray repeatRay = r;\n    repeatRay.origin = mod(r.origin, 2.0);\n    return distToBoundingBox(repeatRay, bb);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n    vec3 camPos = vec3(1000.0 + (sin(iTime) / 2.0) + 1.0, 1000.0 + (cos(iTime) / 2.0) + 1.0, iTime);\n    Ray ray = Ray(camPos, normalize(vec3(uv, 1.0)));\n    vec3 col = vec3(0.0);\n    for (float i=0.0; i<100.0; i++) {\n        float dist = distToBoundingBoxScene(ray);\n        if (dist < 0.01) {\n              col = vec3(1.0);\n              break;\n        }\n        ray.origin += ray.direction * dist;\n    }\n    vec3 posRelativeToCamera = ray.origin - camPos;\n    fragColor = vec4(1.0) - vec4(col * abs(posRelativeToCamera / 5.0), 0.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WlKyzh.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 360, 410, 410, 774], [776, 776, 813, 813, 988], [990, 990, 1047, 1047, 1651]]}
{"id": "WlKyzW", "name": "Buckyball Fracture", "author": "tdhooper", "description": "Working on building a compact version of this fracture effect, suggestions very welcome.", "tags": ["explode", "polyhedra", "fracture"], "likes": 42, "viewed": 604, "published": "Public API", "date": "1610583808", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI 3.14159265359\n#define PHI 1.618033988749895\n\n// HG_SDF\nvoid pR(inout vec2 p, float a) {\n    p = cos(a)*p + sin(a)*vec2(p.y, -p.x);\n}\nfloat vmax(vec3 v) {\n\treturn max(max(v.x, v.y), v.z);\n}\nfloat fBox(vec3 p, vec3 b) {\n\tvec3 d = abs(p) - b;\n\treturn length(max(d, vec3(0))) + vmax(min(d, vec3(0)));\n}\n\n// Rotate on axis, blackle\nvec3 erot(vec3 p, vec3 ax, float ro) {\n  return mix(dot(ax,p)*ax, p, cos(ro))+sin(ro)*cross(ax,p);\n}\n\n// Sign but returns -1 instead of 0\nvec3 boolSign(vec3 v) {\n    return max(vec3(0), sign(v)) * 2. - 1.;\n}\n\n// Closest icosahedron vertex\nvec3 icosahedronVertex(vec3 p) {\n    vec3 ap, v, v2, v3;\n    ap = abs(p);\n    v = vec3(PHI, 1, 0);\n    v2 = v.yzx;\n    v3 = v2.yzx;\n    if (distance(ap, v2) < distance(ap, v)) v = v2;\n    if (distance(ap, v3) < distance(ap, v)) v = v3;\n    return normalize(v) * boolSign(p);\n}\n\n// Closest dodecahedron vertex\nvec3 dodecahedronVertex(vec3 p) {\n    vec3 ap, v, v2, v3, v4;\n    ap = abs(p);\n    v = vec3(PHI);\n\tv2 = vec3(0, 1, PHI + 1.);\n\tv3 = v2.yzx;\n    v4 = v3.yzx;\n    if (distance(ap, v2) < distance(ap, v)) v = v2;\n    if (distance(ap, v3) < distance(ap, v)) v = v3;\n    if (distance(ap, v4) < distance(ap, v)) v = v4;\n    return normalize(v) * boolSign(p);\n}\n\n// Second closest dodecahedron vertex\nvec3 secondDodecahedronVertex(vec3 p, vec3 iv, vec3 dv) {\n    // Find which side of the icosahedron vertex -> dodecahedron vertex line we're on\n    float side = sign(dot(p, cross(iv, dv)));\n    // Rotate dodecahedron vertex around the dodecahedron face\n    return erot(dv, iv, PI * 2. / 5. * side);\n}\n\n// The model to explode\nfloat object(vec3 p) {\n    pR(p.xz, 1.2);\n    pR(p.xy, .3);\n    float d = fBox(p, vec3(.25 - .02)) - .02;\n    d = max(d, -d - .05);\n    return d;\n}\n\n// https://www.iquilezles.org/www/articles/functions/functions.htm\nfloat expImpulse( float x, float k )\n{\n    float h = k*x;\n    return h*exp(1.0-h);\n}\n\nfloat map2(vec3 p) {\n\n    // Three closest vertices of a spherical pentakis dodecahedron\n    // or, three closest faces of a buckyball\n    vec3 a = icosahedronVertex(p);\n    vec3 b = dodecahedronVertex(p);\n    vec3 c = secondDodecahedronVertex(p, a, b);\n\n    float d = 1e12;\n\n    vec3 pp = p;\n    \n    // Render the nearest three fragments to get\n    // a clean distance estimation\n\n    for (int i = 0; i < 3; i++) {\n\n        // Offset space\n        float t = mod((iTime - dot(a.xy, vec2(1,-1)) / 6.) / 3., 1.);\n        float t2 = min(t * 1.85, 1.);\n        float explode = 1. - pow(1. - t2, 10.); // expand\n        explode *= 1. - pow(t2, 5.); // contract\n        t2 = max(t - .53, 0.) * 1.2;\n        float wobble = sin(expImpulse(t2, 20.) * 2.2 + pow(3. * t2, 1.5) * 2. * PI * 2. - PI) * smoothstep(.4, .0, t2) * .15;\n        float anim = wobble + explode;\n        p -= a * anim / 2.8;\n\n        // Build boundary edge of face\n        float edgeA = dot(p, normalize(b - a));\n        float edgeB = dot(p, normalize(c - a));\n        float edge = max(edgeA, edgeB);\n\n        // Intersect with object\n        d = min(d, max(object(p), edge));\n        \n        // Reset space for next iteration\n        p = pp;\n        \n        // Cycle faces for next iteration\n        vec3 aa = a;\n        a = b;\n        b = c;\n        c = aa;\n    }\n    \n    return d;\n}\n\n\nfloat map(vec3 p) {\n    if (iMouse.x > 0. && iMouse.y > 0.) {\n        pR(p.yz, (.5 - iMouse.y / iResolution.y) * PI / 2.);\n        pR(p.xz, (.5 - iMouse.x / iResolution.x) * PI * 2.);\n    }\n    return map2(p);\n}\n\n// compile speed optim from IQ https://www.shadertoy.com/view/Xds3zN\nvec3 calcNormal(vec3 pos){\n    vec3 n = vec3(0.0);\n    for( int i=0; i<4; i++ )\n    {\n        vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);\n        n += e*map(pos+0.0005*e);\n    }\n    return normalize(n);\n}\n\n// https://www.shadertoy.com/view/Xds3zN\nfloat calcAO( in vec3 pos, in vec3 nor )\n{\n\tfloat occ = 0.0;\n    float sca = 1.0;\n    for( int i=0; i<5; i++ )\n    {\n        float h = 0.01 + 0.12*float(i)/4.0;\n        float d = map( pos + h*nor );\n        occ += (h-d)*sca;\n        sca *= 0.95;\n        if( occ>0.35 ) break;\n    }\n    return clamp( 1.0 - 3.0*occ, 0.0, 1.0 );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = (-iResolution.xy + 2. * fragCoord.xy) / iResolution.y;\n    \n    vec3 camPos = vec3(0,0,3.2);\n    vec3 rayDirection = normalize(vec3(p,-4));\n    \n    vec3 rayPosition = camPos;\n    float rayLength = 0.;\n    float dist = 0.;\n    bool bg = false;\n    vec3 bgcol = vec3(.007);\n    vec3 col = bgcol;\n\n    for (int i = 0; i < 150; i++) {\n        rayLength += dist;\n        rayPosition = camPos + rayDirection * rayLength;\n        dist = map(rayPosition);\n\n        if (abs(dist) < .001) {\n        \tbreak;\n        }\n        \n        if (rayLength > 5.) {\n            bg = true;\n            break;\n        }\n    }\n    \n    if ( ! bg) {\n        vec3 albedo = vec3(1);\n        vec3 n = calcNormal(rayPosition);\n        vec3 lp = vec3(-.5,.5,.5);\n        float l = max(dot(lp, n), 0.);\n        vec3 ld = normalize(lp - rayPosition);\n        l += .02;\n        l += pow(max(0., 1. + dot(n, rayDirection)), 3.) * .05;\n        float ao = calcAO(rayPosition, n);\n        col = albedo * l * mix(1., ao, .8);\n        col = mix(col, bgcol, 1.0 - exp2(-0.2 * pow(rayLength - 1., 3.)));\n    }\n\n    col = pow(col, vec3(1./2.2));\n\n    fragColor = vec4(col,1);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WlKyzW.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[56, 66, 98, 98, 143], [144, 144, 164, 164, 199], [200, 200, 228, 228, 309], [311, 338, 376, 376, 438], [440, 476, 499, 499, 545], [547, 577, 609, 609, 853], [855, 886, 919, 919, 1239], [1241, 1279, 1336, 1422, 1579], [1581, 1605, 1627, 1627, 1752], [1754, 1821, 1859, 1859, 1905], [1907, 1907, 1927, 2041, 3258], [3261, 3261, 3280, 3280, 3472], [3474, 3543, 3569, 3569, 3768], [3770, 3811, 3853, 3853, 4139], [4141, 4141, 4198, 4198, 5349]]}
{"id": "wltcDX", "name": "Animated Robot", "author": "intrakits", "description": "This is an animated robot.", "tags": ["2d", "beginner", "animated", "robot"], "likes": 4, "viewed": 193, "published": "Public API", "date": "1610081527", "time_retrieved": "2021-10-01T00:00:00", "image_code": "mat2 rotate(float r) {\n    float c = cos(r);\n    float s = sin(r);\n    return mat2(c, -s, s, c);\n}\nfloat circle (vec2 uv, float r, float blur){\n    float d = length(uv);\n    return smoothstep(r,r-blur,d);\n}\nfloat DrawSquare (vec2 uv, float width, float height, float posX, float posY, float blur){\n    float w = length((uv.x + posX));\n    float h = length(uv.y + posY);\n    float col = smoothstep(width,width-blur, w);\n    col *= smoothstep(height,height-blur, h);\n    return col;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    uv-=0.5;\n    uv.x *= iResolution.x/iResolution.y;\n    \n    //ray origin\n    vec3 ro = vec3(0.0, 0.0, -3.0);\n    \n    //ray direction\n\tvec3 rd = vec3(uv.x,uv.y, 0)-ro;\n    \n    // Time varying pixel color\n    float width = 0.3;\n    float height = 0.3;\n    float blur = 0.01;\n    float posX = 0.;\n    float posY = -0.;\n    \n    float head = DrawSquare(uv, width, height, posX, posY, blur);\n    head += DrawSquare(uv, width * 0.5, height * 0.15, posX, posY + 0.335, blur);\n    head += DrawSquare(uv, width * 2., height, posX, posY + 0.67, blur);\n    vec3 img = vec3(.8) * head;\n    //outer eyes\n    float Reye = DrawSquare(uv, width * 0.2, height * (sin(iTime)*0.05 +0.15), posX + 0.15, posY-0.1, blur);\n    \n    img -= vec3(1.,1.,1.) * Reye;\n    \n    float Leye = DrawSquare(uv, width * 0.2, height * 0.2, posX - 0.15, posY-0.1, blur);\n    \n    img -= vec3(1.,1.,1.) * Leye;\n    \n    //inner eyes\n    float RIeye = DrawSquare(uv, width * 0.1, height * 0.1, posX + 0.15, posY-0.1, blur);\n    \n    img += vec3(smoothstep(1.,0.9,sin(iTime)),0.,0.) * RIeye;\n    \n    float LIeye = DrawSquare(uv, width * 0.1, height * 0.1, posX - 0.15, posY-0.1, blur);\n    \n    img += vec3(1.,smoothstep(smoothstep(1.,0.9,cos(iTime*5.)),0.9,sin(iTime*5.)),smoothstep(1.,0.9,sin(iTime*5.))) * LIeye;\n    \n    //mouth\n    float mouth = DrawSquare(uv, width * 0.5, height * 0.2, posX, posY+0.15, blur);\n    img -= vec3(1.,1.,1.) * mouth;\n    \n    //mouth inner\n    float mouthI = DrawSquare(uv, width * 0.48, height * (sin(iTime*3.)*0.04+0.14), posX, posY+0.15, blur);\n    img += vec3(0.,1.,1.) * mouthI;\n    \n    //mouth slats\n    float mouthS = DrawSquare(uv, width * 0.05, height * 0.18, posX, posY+0.15, blur);\n    mouthS += DrawSquare(uv, width * 0.05, height * 0.18, posX-.05, posY+0.15, blur);\n    mouthS += DrawSquare(uv, width * 0.05, height * 0.18, posX-.1, posY+0.15, blur);\n    mouthS += DrawSquare(uv, width * 0.05, height * 0.18, posX+.05, posY+0.15, blur);\n    mouthS += DrawSquare(uv, width * 0.05, height * 0.18, posX+.1, posY+0.15, blur);\n    img -= vec3(0.,1.,1.) * mouthS;\n    \n    //nose\n    vec2 rotUV = uv * rotate(iTime);\n    float nose = circle (rotUV, 0.03, blur);\n    nose += DrawSquare(rotUV, width * 0.03, height * 0.09, posX, posY, blur);\n    nose += DrawSquare(rotUV, width * 0.09, height * 0.03, posX, posY, blur);\n    img -= vec3(.5,.5,.5) * nose;\n    \n    //screws\n    float screws = circle (uv - vec2(0.25), 0.03, blur);\n    screws += DrawSquare(uv, width * 0.03, height * 0.09, posX - 0.25, posY - 0.25, blur);\n    screws += DrawSquare(uv, width * 0.09, height * 0.03, posX - 0.25, posY - 0.25, blur);\n    \n    screws += circle (uv - vec2(-0.25), 0.03, blur);\n    screws += DrawSquare(uv, width * 0.03, height * 0.09, posX + 0.25, posY + 0.25, blur);\n    screws += DrawSquare(uv, width * 0.09, height * 0.03, posX + 0.25, posY + 0.25, blur);\n    \n    screws += circle (uv - vec2(-0.25, 0.25), 0.03, blur);\n    screws += DrawSquare(uv, width * 0.03, height * 0.09, posX + 0.25, posY - 0.25, blur);\n    screws += DrawSquare(uv, width * 0.09, height * 0.03, posX + 0.25, posY - 0.25, blur);\n    \n    screws += circle (uv - vec2(0.25, -0.25), 0.03, blur);\n    screws += DrawSquare(uv, width * 0.03, height * 0.09, posX - 0.25, posY + 0.25, blur);\n    screws += DrawSquare(uv, width * 0.09, height * 0.03, posX - 0.25, posY + 0.25, blur);\n    img -= vec3(.5,.5,.5) * screws;\n    // Output to screen\n    fragColor = vec4(img,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wltcDX.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 22, 22, 98], [99, 99, 143, 143, 206], [207, 207, 297, 297, 482], [483, 483, 540, 590, 4072]]}
{"id": "WltcRB", "name": "A 3D SPHERE", "author": "skillermaniac", "description": "mah first 3d spher", "tags": ["raytracing"], "likes": 1, "viewed": 67, "published": "Public", "date": "1611529998", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define spheres_num 3\nstruct Camera {\n    vec3 Observer;\n    vec3 View;\n    vec3 Up;\n    vec3 Horiz;\n    float screenHeight;\n    float screenWidth;\n    float screen_observer_distance;\n};\nvec3 EPSILON = vec3(1e-9);\nstruct Ray {\n    vec3 Source;\n    vec3 Direction;\n};\nstruct Sphere {\n    vec3 Center;\n    float radius;\n    vec3 Color;\n    bool doesReflect;\n};\nstruct IntersectionInfo {\n    Sphere sphere;\n    vec3 IntersectionPoint;\n    bool doesIntersectASphere;\n    float tVal;\n    Ray incidenceRay;\n};\nCamera createCamera(in vec3 Observer, in vec3 LookAt, in float aperture) {\n    Camera camera;\n    camera.Observer = Observer;\n    camera.View = normalize(LookAt - Observer);\n    vec3 kAxis = vec3(0.0,0.0,1.0);\n    camera.Horiz = normalize(cross(kAxis,camera.View));\n    \n    //no need to normalize up since view and horiz are already normalized;\n    camera.Up = cross(camera.View, camera.Horiz);\n    camera.screenHeight = iResolution.y;\n    camera.screenWidth = iResolution.x;\n    camera.screen_observer_distance = (camera.screenHeight / 2.0) / tan((aperture * 3.1415 / 180.0) / 2.0);\n    return camera;\n}\nRay launchRay (in Camera camera, in vec2 pixCoord) {\n    float adjustedX = pixCoord.x - camera.screenWidth / 2.0;\n    float adjustedY = pixCoord.y - camera.screenHeight / 2.0;\n    return Ray(camera.Observer, camera.screen_observer_distance * camera.View \n    + adjustedX * camera.Horiz \n    + adjustedY * camera.Up);\n}\n\n/*\n   If bool = true , the intersection will be at : M = RayOrigin + atT * Dir\n*/\nbool doesIntersectSphere(in Ray ray, in Sphere sphere, out float atT) {\n    vec3 SC = ray.Source - sphere.Center;\n    float a = dot(ray.Direction, ray.Direction);// R.dir²;\n    float b = 2.0 * dot(ray.Direction, SC);\n    float c = dot(SC, SC) - sphere.radius*sphere.radius;\n    float delta = b*b - 4.0*a*c;\n    if(delta < 0.0) {\n    return false;\n    };\n    atT = (-b-sqrt(delta)) / (2.0*a);\n    return true;\n}\n\nIntersectionInfo getIntersectionInfo(in Ray ray, in Sphere[spheres_num] spheres) {\n    IntersectionInfo info;\n    float t = 1e25;\n    info.doesIntersectASphere = false;\n    info.incidenceRay = ray;\n    for(int i=0; i < spheres_num; i++) {\n        Sphere sphere = spheres[i];\n        float potentialT = t;\n        if(doesIntersectSphere(ray, sphere, potentialT)) {\n            info.doesIntersectASphere = true;\n            if(potentialT < t) {\n                t = potentialT;\n                info.sphere = sphere;\n                info.IntersectionPoint = ray.Source + potentialT * ray.Direction;\n                info.tVal = potentialT;\n            }\n        }\n        \n    }\n    \n    return info;\n}\n\nfloat getLightingRatio(in Sphere sphere,in vec3 IntersectionPoint, in vec3 Sun) {\n    vec3 NormaleVec = IntersectionPoint - sphere.Center;\n    vec3 IncidenceVec = Sun - IntersectionPoint;\n    float incidence = max(dot(NormaleVec,IncidenceVec)/(length(NormaleVec)*length(IncidenceVec)), 0.0);\n    return incidence;\n}\n\n\nbool applyShadow(Ray shadowRay, Sphere[spheres_num] spheres) {\n   bool shadow = false;\n   for(int i = 0 ; i < spheres_num;i++) {\n       float atT;\n       shadow = shadow || (doesIntersectSphere(shadowRay, spheres[i], atT) && atT > 1e-6 && atT < 1.0);\n       if(shadow) break;\n   }\n   return shadow;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    fragColor = vec4(0.5, 0.5, 1.0, 1.0);\n    Camera cam =createCamera(vec3(3.0, 3.0, 1.5),\n    vec3(0.5, 0.5, 0.5),\n    50.0);\n    Sphere Sun= Sphere(vec3(0.0,2.5,0.0),0.01,vec3(1.0,1.0,1.0), false);\n    Sphere sphereA = Sphere(vec3(0.0, 0.0, 0.0), 0.5, vec3(1.0,0.0,0.0), false);\n    float rotation = iTime;\n    Sphere sphereB = Sphere(0.9*vec3(cos(rotation), sin(rotation), 0),0.1,vec3(0.0,0.0,1.0), false);\n    Sphere sphereC = Sphere(vec3(0.0,0.0,1.2), 0.3, vec3(0.0,1.0,0.0), true);\n    Sphere[spheres_num] spheres = Sphere[spheres_num](sphereB, sphereA, sphereC);\n\n    Ray ray = launchRay(cam, fragCoord);\n    float t;\n    /*if(doesIntersectSphere(ray,S, t)) {\n        vec3 IntersectionPoint = ray.Source + t* ray.Direction;\n        float incidence = getLightingRatio(S,IntersectionPoint, Sun);\n        fragColor = incidence*vec4(1.0);\n    };*/\n    IntersectionInfo info = getIntersectionInfo(ray, spheres);\n    if(info.doesIntersectASphere) {\n        vec3 IntersectionPoint = info.IntersectionPoint;\n        // Defining a shadow detector ray\n        Ray shadowRay;\n        shadowRay.Source = IntersectionPoint;\n        shadowRay.Direction =  Sun.Center - shadowRay.Source;\n        IntersectionInfo shadowInfo = getIntersectionInfo(shadowRay, spheres);\n        //SHADOW section\n        bool shadow = applyShadow(shadowRay, spheres);\n        if (!shadow) {\n            // Lighting section\n            if(!info.sphere.doesReflect) {\n                float incidence = getLightingRatio(info.sphere, IntersectionPoint, Sun.Center);\n                fragColor = vec4(incidence * info.sphere.Color,1.0);\n            \n            } else {\n                Ray incidenceRay = info.incidenceRay;\n                vec3 Center = info.sphere.Center;\n                vec3 NormaleVec = (IntersectionPoint - Center);\n                NormaleVec = normalize(NormaleVec);\n                Ray reflectedRay = Ray(info.IntersectionPoint, - (incidenceRay.Direction - (2.0 * dot(incidenceRay.Direction,NormaleVec)*NormaleVec)));\n                IntersectionInfo reflectionInfo = getIntersectionInfo(reflectedRay, spheres);\n                if(reflectionInfo.doesIntersectASphere) {\n                        float incidence = getLightingRatio(reflectionInfo.sphere, reflectionInfo.IntersectionPoint, Sun.Center);\n                        fragColor = vec4(incidence* reflectionInfo.sphere.Color,1.0);\n                        \n                        \n                 \n                }\n                \n\n            }\n            \n            // End of Lighting\n            \n        } else {\n            \n            fragColor = vec4(0.01*info.sphere.Color, 1.0);\n        }\n        \n    } else {\n        fragColor = vec4(0.5, 0.5, 1.0, 1.0);\n    }\n    \n  \n    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WltcRB.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[504, 504, 578, 578, 1109], [1110, 1110, 1162, 1162, 1428], [1430, 1512, 1583, 1583, 1923], [1925, 1925, 2007, 2007, 2622], [2624, 2624, 2705, 2705, 2939], [2942, 2942, 3004, 3004, 3242], [3244, 3244, 3301, 3301, 6040]]}
{"id": "WltcRX", "name": "Distorted Cube", "author": "kekwizard", "description": "...", "tags": ["cube", "distortion", "blobb"], "likes": 1, "viewed": 53, "published": "Public", "date": "1609619397", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\n mat3 rotationMatrix(vec3 axis, float angle)\n{\n    axis = normalize(axis);\n    float s = sin(angle);\n    float c = cos(angle);\n    float oc = 1.0 - c;\n    \n    return mat3(oc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s,\n                oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s,\n                oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c);\n}\n\nfloat mixV(float a, float b, float d) {\n\treturn (d * a)+(1.0 - d)*b;\n}\n\nfloat map(vec3 p)\n{\n   float displacement = .5 * sin(iTime + 5.*p.x)*cos(iTime * 1.1 + 5.*p.y)*sin(iTime * 1.2 + 5.*p.z);    \n   return displacement + sdBox(p, vec3(5.0, 5.0, 5.0));\n}\n\nvoid getCamPos(inout vec3 ro, inout vec3 rd)\n{\n    ro.z = -15.0;\n}\n\nvec3 palette( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d )\n{\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n   \n    vec2 _p = (iResolution.xy - 2.0 * fragCoord.xy) / iResolution.y;\n    vec3 ray = normalize(vec3(_p, 1.0));\n    vec3 cam = vec3(0.0, 0.0, 0.0);\n    bool hit = false;\n    getCamPos(cam, ray);  \n    \n    mat3 rm = rotationMatrix(vec3(0.66, 1., 0.9), iTime);\n\n        \n    float depth = 0.0, d = 0.0, iter = 0.0;\n    vec3 p;\n    \n    for( int i = 0; i < 40; i ++)\n    {\n    \tp = depth * ray + cam;\n        d = map(rm * p);\n                  \n        if (d < 0.0001) {\n\t\t\thit = true;\n            break;\n        }\n                   \n\t\tdepth += d * 0.75;\n\t\titer++;\n                   \n    }\n    \n    vec3 col = vec3(1.0 - iter / 41.0);\n    /*\n    const vec3 a = vec3(0.5, 0.5, 0.5);\n    const vec3 b = vec3(0.5, 0.5, 0.5);\n    const vec3 c = vec3(2., 1., 0.);\n    const vec3 da = vec3(0.5, 0.2, 0.25);\n*/\n    \n    const vec3 a = vec3(0.5, 0.5, 0.5);\n    const vec3 b = vec3(0.5, 0.5, 0.5);\n    const vec3 c = vec3(1., 1., 0.5);\n    const vec3 da = vec3(0.8, 0.9, 0.3);\n\t\n    \n    \n    vec3 sq = sqrt(col);\n    \n    vec3 gg = palette(sq.x * sq.y * sq.z, a, b, c, da);\n\n    fragColor = vec4(gg, 0.0);\n    \n    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WltcRX.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 1, 32, 32, 119], [121, 121, 154, 154, 219], [222, 222, 267, 267, 739], [741, 741, 780, 780, 811], [813, 813, 832, 832, 996], [998, 998, 1044, 1044, 1064], [1066, 1066, 1138, 1138, 1181], [1183, 1183, 1240, 1240, 2353]]}
{"id": "WltcW2", "name": "Projet de graphisme", "author": "maulray", "description": "Ma petite grenouille à chaussettes perdue dans l'espace pour le projet de graphisme de 3A à TELECOM Nancy.", "tags": ["space", "lost", "frog"], "likes": 1, "viewed": 75, "published": "Public", "date": "1609942878", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const float FARAWAY=1e30;\nconst float EPSILON=1e-3;\n\nstruct Camera {\n    vec3 Obs;\n    vec3 View;\n    vec3 Up;\n    vec3 Horiz;\n    float H;\n    float W;\n    float z;\n};\n\nstruct Ray {\n    vec3 Origin;\n    vec3 Dir;\n};\n\n\n\nCamera camera(in vec3 Obs, in vec3 LookAt, in float aperture) {\n   Camera C;\n   C.Obs = Obs;\n   C.View = normalize(LookAt-Obs);\n   C.Horiz = normalize(cross(vec3(0.5, 0.5, 1.0), C.View));\n   C.Up = cross(C.View, C.Horiz);\n   C.W = float(iResolution.x);\n   C.H = float(iResolution.y);\n   C.z = (C.H/2.0) / tan((aperture * 3.1415 / 180.0) / 2.0);\n   return C;\n}\n\nRay launch(in Camera C, in vec2 XY) {\n   return Ray(\n      C.Obs,\n      C.z*C.View+(XY.x-C.W/2.0)*C.Horiz+(XY.y-C.H/2.0)*C.Up\n   );\n}\n\nstruct Sphere {\n   vec3 Center;\n   float R;\n};\n\nstruct Material {\n    vec4 Kd;       // diffuse color\n    vec4 Ke;       // emissive color\n\n};\n\n// \\brief Shorthand for the zero vector\nconst vec4 zero4 = vec4(0.0, 0.0, 0.0, 0.0);\n\n// \\brief Creates a diffuse material\n// \\param[in] Kd the diffuse color\n// \\return the created Material\nMaterial diffuse(in vec4 Kd) {\n   return Material(Kd, zero4);\n}\n\n// \\brief Creates a light (emissive) material\n// \\param[in] Ke the color of the light\n// \\return the created Material\nMaterial light(in vec4 Ke) {\n   return Material(zero4, Ke);\n}\n\n\n\nstruct Object {\n   Sphere sphere;\n   Material material;\n};\n\nObject scene[25];\n\nvoid init_scene() {\n   float beta = float(iFrame)/30.0;\n   float s = sin(beta);\n   float c = cos(beta);\n\n    //scaphendre\n   // scene[24] = Object(\n   //   Sphere(vec3(0.0, 0.0, 0.0),0.7),\n   //   diffuse(vec4(0.15, 0.15, 0.15, 1.0))\n   //);\n\n    //body\n   scene[0] = Object(\n      Sphere(vec3(0.0, 0.0, 0.0),0.5),\n      diffuse(vec4(0, 1, 0, 0))\n   );\n\n    //first leg\n   scene[1] = Object(\n      Sphere(vec3(-0.6*s, -0.6*c, -0.65),0.1),\n      diffuse(vec4(0,0, 1.0,0))\n   );\n\n\n   scene[3] = Object(\n      Sphere(vec3(-0.55*s, -0.55*c, -0.45),0.1),\n      diffuse(vec4(1, 0, 0,0))\n   );\n\n   scene[4] = Object(\n      Sphere(vec3(-0.4*s, -0.4*c, -0.35),0.1),\n      diffuse(vec4(0, 1.0, 0,0))\n   );\n\n    scene[5] = Object(\n      Sphere(vec3(-0.65*s, -0.65*c, -0.85),0.1),\n      diffuse(vec4(1, 0, 0,0))\n   );\n\n   scene[6] = Object(\n      Sphere(vec3(-0.7*s, -0.7*c, -1.05),0.1),\n      diffuse(vec4(0.0, 0.0, 0.0,0))\n   );\n\n    scene[7] = Object(\n      Sphere(vec3(-0.8*s, -0.8*c, -1.05),0.08),\n      diffuse(vec4(0.0, 0.0, 0.0,0))\n   );\n\n   //second leg\n\n   scene[8] = Object(\n      Sphere(vec3(0.7*s, 0.7*c, 0.40),0.1),\n      diffuse(vec4(0, 0, 1.0,0))\n   );\n\n\n   scene[9] = Object(\n      Sphere(vec3(0.55*s, 0.55*c,0.42),0.1),\n      diffuse(vec4(1.0, 0, 0,0))\n   );\n\n   scene[10] = Object(\n      Sphere(vec3(0.4*s, 0.4*c, 0.35),0.1),\n      diffuse(vec4(0, 1.0, 0,0))\n   );\n\n    scene[11] = Object(\n      Sphere(vec3(0.86*s, 0.86*c, 0.35),0.1),\n      diffuse(vec4(1.0, 0, 0,0))\n   );\n\n   scene[12] = Object(\n      Sphere(vec3(s, c, 0.30),0.1),\n      diffuse(vec4(0.0, 0.0, 0.0,0))\n   );\n\n    scene[13] = Object(\n      Sphere(vec3(1.08*s,1.08*c, 0.40),0.08),\n      diffuse(vec4(0.0, 0.0, 0.0,0))\n   );\n\n   //eyes\n   //finir les effets miroir et transparence\n\n    scene[14] = Object(\n      Sphere(vec3(-0.55*s, -0.55*c, 0.04),0.1),\n      diffuse(vec4(0, 1, 0,0))\n   );\n\n    scene[15] = Object(\n      Sphere(vec3(0.05*s, 0.05*c, 0.50),0.1),\n      diffuse(vec4(0, 1, 0,0))\n   );\n\n\n\n\n\n\n\n   //stars\n   scene[2] = Object(\n      Sphere(vec3(0.0, 7.0*s, 0.0),0.01),\n      light(vec4(1.0, 1.0, 1.0,0))\n   );\n\n   scene[16] = Object(\n      Sphere(vec3(8.0*s, 3.0*c, 0.0),0.01),\n      light(vec4(1.0, 1.0, 1.0,0))\n   );\n   scene[17] = Object(\n      Sphere(vec3(4.0*c, 0.0, 0.0),0.02),\n      light(vec4(1.0, 1.0, 1.0,0))\n   );\n\n   scene[18] = Object(\n      Sphere(vec3(2.0*c, 1.0*s, 0.0),0.01),\n      light(vec4(1.0, 1.0, 1.0,0))\n   );\n\n   scene[19] = Object(\n      Sphere(vec3(0.0, 2.0*c, 3.0),0.02),\n      light(vec4(1.0, 1.0, 1.0,0))\n   );\n\n   scene[20] = Object(\n      Sphere(vec3(6.0*c, 10.0*s , 2.0),0.02),\n      light(vec4(1.0, 1.0, 1.0,0))\n   );\n\n   scene[21] = Object(\n      Sphere(vec3(0.0, 4.0*s, 0.5),0.02),\n      light(vec4(1.0, 1.0, 1.0,0))\n   );\n\n   scene[22] = Object(\n      Sphere(vec3(0.5*s, 9.0*c, 4.0),0.02),\n      light(vec4(1.0, 1.0, 1.0,0))\n   );\n\n\n}\n\nbool intersect_sphere(in Ray R, in Sphere S, out float t) {\n   vec3 CO = R.Origin - S.Center;\n   float a = dot(R.Dir, R.Dir);\n   float b = 2.0*dot(R.Dir, CO);\n   float c = dot(CO, CO) - S.R*S.R;\n   float delta = b*b - 4.0*a*c;\n   if(delta < 0.0) {\n      return false;\n   }\n   t = (-b-sqrt(delta)) / (2.0*a);\n   return true;\n}\n\nbool shadow(in Ray R) {\n   for(int i=0; i<scene.length(); ++i) {\n        float t;\n        if(\n          scene[i].material.Ke == vec4(0.0, 0.0, 0.0,0.0) &&\n          intersect_sphere(R, scene[i].sphere, t) &&\n          t > EPSILON && t < 1.0\n        ) {\n          return true;\n        }\n    }\n    return false;\n}\n\nvec4 lighting(in vec3 P, in vec3 N, in Material material) {\n   if(material.Ke != vec4(0.0, 0.0, 0.0,0.0)) {\n      return material.Ke;\n   }\n\n   vec4 result = vec4(0.0, 0.0, 0.0,0.0);\n\n   for(int i=0; i<scene.length(); ++i) {\n      if(scene[i].material.Ke != vec4(0.0, 0.0, 0.0,0.0)) {\n         Ray R2 = Ray(P, scene[i].sphere.Center);\n         if(!shadow(R2)) {\n           vec3 E = scene[i].sphere.Center - P;\n           float lamb = max(0.0, dot(E,N) / length(E));\n           result += lamb * material.Kd * scene[i].material.Ke;\n         }\n      }\n   }\n\n   return result;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\n   init_scene();\n\n   float beta = float(iFrame)/150.0;\n   float s = sin(beta);\n   float c = cos(beta);\n\n   Camera C = camera(\n       vec3(2.0, 2.0, 10.0*s),\n       vec3(0.5, 0.5, 0.3),\n       50.0\n   );\n   Ray R = launch(C, fragCoord);\n\n\n    // Time varying pixel color\n    vec3 col = 0.2+0.5*cos(iTime+vec3(2,0,4));\n\n    // Output to screen\n    fragColor = 0.7*vec4(col,1.0);\n\n   const float FARAWAY=1e30;\n   float t = FARAWAY;\n\n   vec3 P;  // Point courant\n   vec3 N;  // Normale\n   Material material; // Couleur\n\n   for(int i=0; i<scene.length(); ++i) {\n       float cur_t;\n       if(\n          intersect_sphere(R, scene[i].sphere, cur_t)\n          && cur_t < t\n       ) {\n           t = cur_t;\n           P = R.Origin + t*R.Dir;\n           N = normalize(P - scene[i].sphere.Center);\n           material = scene[i].material;\n       }\n   }\n\n   if(t != FARAWAY) {\n      fragColor = lighting(P,N,material);\n   }\n\n}\n", "image_inputs": [{"id": "MlfXRN", "previewfilepath": "https://soundcloud.com/steezyasfuck/beats-to-sleep-to-lofi-hip-hop-mix", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0, "src": "https://soundcloud.com/steezyasfuck/beats-to-sleep-to-lofi-hip-hop-mix", "ctype": "musicstream"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WltcW2.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[220, 220, 283, 283, 579], [581, 581, 618, 618, 714], [946, 1050, 1080, 1080, 1113], [1115, 1233, 1261, 1261, 1294], [1377, 1377, 1396, 1396, 4234], [4236, 4236, 4295, 4295, 4561], [4563, 4563, 4586, 4586, 4874], [4876, 4876, 4935, 4935, 5449], [5451, 5451, 5508, 5508, 6424]]}
{"id": "Wltczl", "name": "Gourd-Phong&&BlinnPhong", "author": "Learner_CC", "description": "on a gourd model", "tags": ["raymarching", "phongandblinphong"], "likes": 2, "viewed": 68, "published": "Public", "date": "1609770364", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// -------- define const para -------- //\nconst int MAX_MARCHING_STEPS = 255;\nconst float MIN_DIST = 0.0;\nconst float MAX_DIST = 100.0;\nconst float EPSILON = 0.0001;\n\n// -------- basic tool function -------- //\nfloat opSmoothUnion( float d1, float d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); }\n\nfloat opSmoothSubtraction( float d1, float d2, float k ) {\n    float h = clamp( 0.5 - 0.5*(d2+d1)/k, 0.0, 1.0 );\n    return mix( d2, -d1, h ) + k*h*(1.0-h); }\n\nfloat opSmoothIntersection( float d1, float d2, float k ) {\n    float h = clamp( 0.5 - 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) + k*h*(1.0-h); }\n\n// ---- Rotation ---- //\nmat3 rot3_X(float theta) {\n    return mat3(1, 0,          0,\n                0, cos(theta), -sin(theta),\n                0, sin(theta), cos(theta));\n}\n\nmat3 rot3_Y(float theta) {\n    return mat3(cos(theta), 0,  sin(theta),\n                0,     1,     0,\n                -sin(theta), 0 , cos(theta));\n}\n\nmat3 rot3_Z(float theta) {\n    return mat3(-sin(theta), cos(theta), 0,\n                cos(theta),  sin(theta), 0,\n                0,           0,          1);\n}\n\n// -------- basic object SDF function -------- //\nfloat sphereSDF(vec3 samplePoint) {\n    return length(samplePoint) - 1.0;\n}\nfloat sdCappedCylinder( vec3 p, float h, float r )\n{\n    vec2 d = abs(vec2(length(p.xz),p.y)) - vec2(h,r);\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat sceneSDF(vec3 samplePoint) {\n    samplePoint.y -= 1.0;\n    float sphereDist1 = sphereSDF(samplePoint / 1.2) * 1.2;\n    vec3 morph = vec3(1.0, 1.25, 1.0);\n    float sphereDist2 = sphereSDF(samplePoint / 1.6  * morph + vec3(0.0, 1.4, 0.0)) * 1.2;\n    float cover = sdCappedCylinder(samplePoint - vec3(0.0, 1.4, 0.0), 0.22, 0.5);\n\n    float result = 0.0;\n    result = opSmoothUnion(sphereDist1, sphereDist2, 0.3);\n    result = opSmoothUnion(result, cover, 0.5);\n\n    return result;\n}\n\n// -------- rayMarching -------- //\nfloat rayMarching(vec3 eye, vec3 marchingDirection, float start, float end) {\n    float depth = start;\n    for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n        float dist = sceneSDF(eye + depth * marchingDirection);\n        if (dist < EPSILON) {\n            return depth;\n        }\n        depth += dist;\n        if (depth >= end) {\n            return end;\n        }\n    }\n    return end;\n}\n\nvec3 rayDirection(float fov, vec2 size, vec2 fragCoord) {\n    vec2 xy = fragCoord - size / 2.0;\n    float z = size.y / tan(radians(fov) / 2.0);\n    return normalize(vec3(xy, -z));\n}\n\nvec3 estimateNormal(vec3 p) {\n    return normalize(vec3(\n        sceneSDF(vec3(p.x + EPSILON, p.y, p.z)) - sceneSDF(vec3(p.x - EPSILON, p.y, p.z)),\n        sceneSDF(vec3(p.x, p.y + EPSILON, p.z)) - sceneSDF(vec3(p.x, p.y - EPSILON, p.z)),\n        sceneSDF(vec3(p.x, p.y, p.z + EPSILON)) - sceneSDF(vec3(p.x, p.y, p.z - EPSILON))\n    ));\n}\n\n// -------- shading function -------- //\n\nstruct LightProperty {\n    float k_a;\n    float k_d;\n    float k_s;\n    float shiness;\n    \n    vec4 ambient;\n    vec4 diffuse;\n    vec4 specular;\n\n    vec3 lightPos;\n    float lightIntensity;\n};\n// ------- Phong -------- //\nvec4 PhongContribForLight(LightProperty light, vec3 p, vec3 eye) {\n    vec4 color = vec4(0.0);\n    vec3 N = estimateNormal(p);\n    vec3 L = normalize(light.lightPos - p);\n    vec3 V = normalize(eye - p);\n    vec3 R = normalize(reflect(-L, N));\n\n    float dotLN = max(dot(L, N), 0.0);\n    float dotRN = max(dot(R, N), 0.0);\n    // -------- Diffuse -------- //\n    color += light.k_d * dotLN * light.diffuse;\n    // -------- Specular -------- //\n    color += light.k_s * pow((dotRN), light.shiness) * light.specular;\n    color *= light.lightIntensity;\n    \n    return color;\n}\nvec4 PhongIllumination(LightProperty light, vec3 p, vec3 eye) {\n    vec4 color = vec4(1.0);\n    // Ambient\n    color = light.ambient * light.k_a;\n    \n    // -------- Light1 -------- //\n    light.lightPos = vec3(4.0 * sin(iTime),2.0,4.0 * cos(iTime));\n    light.lightIntensity = 0.8;\n    color += PhongContribForLight(light, p, eye);\n    \n    // -------- Light2 -------- //\n    light.lightPos = vec3(2.0 * sin(0.37 * iTime),2.0 * cos(0.37 * iTime), 2.0);\n    light.lightIntensity = 0.4;\n    color += PhongContribForLight(light, p, eye);\n\n    return color;\n}\n// ------- Blinn_Phong -------- //\nvec4 blinnPhongContribForLight(LightProperty light, vec3 p, vec3 eye) {\n    vec4 color = vec4(0.0);\n    vec3 N = estimateNormal(p);\n    vec3 L = normalize(light.lightPos - p);\n    vec3 V = normalize(eye - p);\n    vec3 H = normalize(L + V);\n\n    float dotLN = max(dot(L, N), 0.0);\n    float dotNH = max(dot(N, H), 0.0);\n    // -------- Diffuse -------- //\n    color += light.k_d * dotLN * light.diffuse;\n    // -------- Specular -------- //\n    color += light.k_s * pow((dotNH), light.shiness) * light.specular;\n    color *= light.lightIntensity;\n    \n    return color;\n}\nvec4 blinnPhongIllumination(LightProperty light, vec3 p, vec3 eye) {\n    vec4 color = vec4(1.0);\n    // Ambient\n    color = light.ambient * light.k_a;\n    \n    // -------- Light1 -------- //\n    light.lightPos = vec3(4.0 * sin(iTime),2.0,4.0 * cos(iTime));\n    light.lightIntensity = 0.8;\n    color += blinnPhongContribForLight(light, p, eye);\n    \n    // -------- Light2 -------- //\n    light.lightPos = vec3(2.0 * sin(0.37 * iTime),2.0 * cos(0.37 * iTime), 2.0);\n    light.lightIntensity = 0.4;\n    color += blinnPhongContribForLight(light, p, eye);\n\n    return color;\n}\n// -------- camera view transform -------- //\nmat4 viewMatrix_MY(vec3 eye, vec3 center, vec3 up) {\n    vec3 f = normalize(center - eye);\n    vec3 s = normalize(cross(f, up));\n    vec3 u = cross(s, f);\n    return mat4(\n        vec4(s, 0.0),\n        vec4(u, 0.0),\n        vec4(-f, 0.0),\n        vec4(0.0, 0.0, 0.0, 1.0)\n    );\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    // 从视点沿每个像素点设出光线 \n    vec3 viewDir = rayDirection(45.0, iResolution.xy, fragCoord);\n    vec3 eye = vec3(0.0, 10.0, 20.0);\n    mat4 viewToWorld;\n    viewToWorld = viewMatrix_MY(eye, vec3(0.0), vec3(0.0, 1.0, 0.0));\n\n    vec3 worldDir = (viewToWorld * vec4(viewDir, 0.0)).xyz;\n    float dist = rayMarching(eye, worldDir, MIN_DIST, MAX_DIST);\n\n    // 给空间中的点着色\n    vec3 p = eye + dist * worldDir;\n        \n    LightProperty light;\n    light.ambient = vec4(0.1, 0.1, 0.1, 1.0);\n    light.diffuse = vec4(0.7, 0.2, 0.2, 1.0);\n    light.specular = vec4(1.0, 1.0, 1.0, 1.0);\n    light.shiness = 20.0;\n    light.k_a = 1.0;\n    light.k_d = 1.0;\n    light.k_s = 1.0;\n\n\n    vec2 pic1 = gl_FragCoord.xy / iResolution.xy;\n    vec4 color =  blinnPhongIllumination(light, p, eye) * step(pic1.x, 0.5);\n    color += PhongIllumination(light, p, eye) * step(0.5, pic1.x);\n\n    fragColor = color;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Wltczl.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[167, 211, 263, 263, 362], [364, 364, 422, 422, 522], [524, 524, 583, 583, 682], [684, 709, 735, 735, 859], [861, 861, 887, 887, 1012], [1014, 1014, 1040, 1040, 1175], [1177, 1227, 1262, 1262, 1302], [1303, 1303, 1355, 1355, 1466], [1468, 1468, 1502, 1502, 1954], [1956, 1992, 2069, 2069, 2384], [2386, 2386, 2443, 2443, 2567], [2569, 2569, 2598, 2598, 2907], [3147, 3176, 3242, 3242, 3750], [3751, 3751, 3814, 3814, 4308], [4309, 4344, 4415, 4415, 4914], [4915, 4915, 4983, 4983, 5487], [5488, 5534, 5586, 5586, 5814], [5818, 5818, 5875, 5924, 6799]]}
{"id": "WltyDB", "name": "acid time warp", "author": "ayumix01", "description": "psychedelic remix 4 d@n", "tags": ["rgb"], "likes": 1, "viewed": 86, "published": "Public", "date": "1609843057", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// http://www.pouet.net/prod.php?which=57245\n// If you intend to reuse this shader, please add credits to 'Danilo Guanabara'\n\n#define t iTime\n#define r iResolution.xy\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n\tvec3 c;\n\tfloat l,z=t;\n\tfor(int i=0;i<3;i++) {\n\t\tvec2 uv,p=fragCoord.xy/r;\n\t\tuv=p;\n\t\tp-=.5;\n\t\tp.x*=r.x/r.y;\n\t\tz+=.1;\n\t\tl=length(p);\n\t\tuv+=p/l*(sin(z)+1.)*abs(sin(l*1.-z*3.));\n\t\tc[i]=.01/length(abs(mod(uv,1.)-.3));\n\t}\n\tfragColor=vec4(c/l,t);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WltyDB.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 168, 224, 224, 467]]}
{"id": "wltyDl", "name": "lilypad clearing", "author": "xingyzt", "description": "Using the golden ratio packing to cheaply spread the lilypads out evenly. Created to act as a border in another project.", "tags": ["lilypad"], "likes": 6, "viewed": 68, "published": "Public", "date": "1610248848", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\nvec2 hash2(vec2 p)\n{\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\nconst float PHI = 1.61803398875;\nconst float TAU = 6.28318530718;\n    \nmat2 rot(float theta)\n{\n    float x = cos(theta);\n    float y = sin(theta);\n    return mat2(x,-y,y,x);\n}\n\nfloat gradient( vec2 p )\n{\n    vec2 i = floor( p );\n    vec2 f = fract( p );\n\t\n\tvec2 u = f*f*(3.0-2.0*f);\n\n    return mix( mix( dot( hash2( i + vec2(0,0) ), f - vec2(0,0) ), \n                     dot( hash2( i + vec2(1,0) ), f - vec2(1,0) ), u.x),\n                mix( dot( hash2( i + vec2(0,1) ), f - vec2(0,1) ), \n                     dot( hash2( i + vec2(1,1) ), f - vec2(1,1) ), u.x), u.y);\n}\nfloat sdPie( vec2 p, vec2 c, float r ) // SDF by iq\n{\n    p.x = abs(p.x);\n    float l = length(p) - r;\n\tfloat m = length(p - c*clamp(dot(p,c),0.0,r) );\n    return max(l,m*sign(c.y*p.x-c.x*p.y));\n}\n\nvec4 Lilypads(vec2 uv)\n{    \n    const float inner = 15.; // Hide lilypads that come before $inner\n    const float outer = 80.; // ... or come after $outer\n    \n    const float shift = 1./20.; // magnitude of random shifting about\n    const float r = .15; // lilypad radius\n    const float density = 8.;\n    const float slice = .48*TAU;\n    const vec2 c = vec2(sin(slice),cos(slice));\n    const float border = 0.02;\n    float aa = 3./iResolution.x;\n  \n    float d = 1.;\n    \n    vec3 col = vec3(1);\n    \n    vec3 col1 = vec3(.4,.8,.6);\n    vec3 col2 = vec3(.4,.8,.6)-.1;\n\n    for(float i = inner; i<outer; i++){\n        float theta = TAU*fract(i*PHI);\n        float rho = pow(i,PHI-1.1);\n        vec2 p = vec2(cos(theta),sin(theta))*rho/density;\n        if(length(p-uv)>r+shift) continue;\n        \n        vec2 q = p+gradient(p+iTime)*shift/2.-uv;\n        q *= rot(gradient(p+iTime/100.)*10.*TAU);\n        \n        d = sdPie(q,c,r-1.2*border)-1.2*border;\n        if(d<aa) {\n            vec3 fill = mix(col2,col1,smoothstep(aa,-aa,d+border));\n            col = mix(col,fill,smoothstep(aa,-aa,d));\n            if(d<-aa) break;\n        }\n    }    \n    \n    return vec4(col,1);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (2.*fragCoord-iResolution.xy)/iResolution.x;\n\n    vec3 col = vec3(1);\n    \n    vec4 lilypads = Lilypads(uv);\n    col = mix(vec3(1),lilypads.rgb,lilypads.a);\n            \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wltyDl.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 1, 21, 21, 154], [226, 226, 249, 249, 330], [332, 332, 358, 358, 728], [729, 729, 782, 782, 925], [927, 927, 951, 951, 2102], [2105, 2105, 2162, 2162, 2379]]}
{"id": "wltyRj", "name": "BASIC CIRCLES", "author": "SimonOakey", "description": "some basic exercise", "tags": ["circle", "loop", "smoothstep", "class"], "likes": 1, "viewed": 38, "published": "Public", "date": "1609529289", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float circ(vec2 uv, vec2 pos, float r, float blur){\n\n    vec2 off = pos*r;\n    off.x += sin(iTime*r*7.)*.02;\n    off.y += cos(iTime*r*4.)*.04;\n    \n    float d = length(uv+off);//+sin(iTime*5.)*.01; // distance from center\n    \n    float coli = d;\n  \n    return smoothstep(r,r-blur,d);\n\n  \n\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    vec2 uv = fragCoord/iResolution.xy;\n    uv -= 0.5; //center it\n    uv.x *= iResolution.x/iResolution.y;\n     \n    float t = .1;//basecolor\n   \n   int i=0;\n   while(i<10){\n   \n        t += circ( uv,\n        vec2(sin(float(i)*1.2),cos(float(i)*1.2)),\n        float(i)*.04,\n        float(i)*.02\n        );\n        \n        i++;\n    }\n\n  \n    vec3 col = vec3(t*.4)+.4*cos(iTime+uv.xyx+vec3(5,3,4))*t;   // Time varying pixel color\n   \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wltyRj.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 51, 51, 292], [295, 295, 352, 352, 849]]}
{"id": "WltyRX", "name": "2D Mandelbrot with Zoom", "author": "AI", "description": "A two-dimensional demo. of Mandelbrot set with zooming effect that changes with time.\nYou may uncomment the zoom to use it with mouse.\nYou may try the other c value by uncommenting it.\nChanging constant values of the program will lead to different looks.", "tags": ["2d", "fractal", "mandelbrot", "zoom", "set"], "likes": 3, "viewed": 203, "published": "Public API", "date": "1609615318", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define MAXITER 100\n#define MAXVAL 5.\n#define PI 3.14159265359\n\nvec3 getColorf(float iter,vec2 z){\n\n    vec3 color;\n    color.r=float(mod(iter,10.))/9.;\n    color.b=float(mod(iter/10.,10.))/9.;\n    color.g=.5+.5*sin(iter/10.-log2(1.+log2(1.+dot(z,z))));\n    return color;\n\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{    vec2 uv = fragCoord.xy/iResolution.xy;\n    uv-=.5;\n//   float zoom=.004+iMouse.x/iResolution.x;\n  float zoom=.75+.4*(cos(PI+.07*iTime));\n\n    uv*=2.*pow(zoom,8.);\n    vec3 color;\n    vec2 c=uv+vec2(-.74515,.1858);\n   // vec2 c=uv+vec2(-.68435,.322500);\n    vec2 z=vec2(0.);\n    float iter=0.;\n    float warp=2.;//-(iMouse.y/iResolution.y);\n    for(int i=0;i<MAXITER;++i){\n        z=vec2(z.x*z.x-z.y*z.y,warp*z.x*z.y)+c;\n        if (length(z)>MAXVAL) break;\n        iter++;\n    }\n    color=getColorf(iter,z);    \n    fragColor = vec4(color,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WltyRX.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[64, 64, 98, 98, 274], [276, 276, 333, 333, 883]]}
{"id": "wltyWH", "name": "voronoi from aoc", "author": "wnu", "description": "fun usage of art of code's voronoi tutorial", "tags": ["voronoi", "worley"], "likes": 7, "viewed": 143, "published": "Public", "date": "1610603052", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI 3.1415926538\n\nvec2 N22(vec2 p){\n    vec3 a = fract(p.xyx*vec3(123.34,234.34,345.65));\n    a += dot(a,a+34.45);\n    return fract(vec2(a.x*a.y,a.y*a.z));\n\n}\n\nvec3 hsl2rgb( in vec3 c )\n{\n    vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n\n    return c.z + c.y * (rgb-0.5)*(1.0-abs(2.0*c.z-1.0));\n}\n\nfloat aafract(float x) {    // --- antialiased fract\n    float v = fract(x),\n          w = fwidth(x);    // NB: x must not be discontinuous or factor discont out\n    return v < 1.-w ? v/(1.-w) : (1.-v)/w; // replace right step by down slope (-> chainsaw is continuous).\n            // shortened slope : added downslope near v=1 \n} \n\n//aafract from https://www.shadertoy.com/view/wtjGzt\n\nfloat random3 (in vec3 _st) {\n    return fract(sin(dot(_st,\n                         vec3(12.9898,78.233,123.24647)))*\n      43758.5453123);\n}\n\nfloat noise3 (in vec3 _st) {\n    vec3 i = floor(_st);\n    vec3 fr = fract(_st);\n\n    // Four corners in 2D of a tile\n    float a = random3(i);\n    float b = random3(i + vec3(1.0, 0.0, 0.0));\n    float c = random3(i + vec3(0.0, 1.0, 0.0));\n    float d = random3(i + vec3(1.0, 1.0, 0.0));\n    \n    float e = random3(i + vec3(0.0, 0.0, 1.0));\n    float f = random3(i + vec3(1.0, 0.0, 1.0));\n    float g = random3(i + vec3(0.0, 1.0, 1.0));\n    float h = random3(i + vec3(1.0, 1.0, 1.0));\n\n    vec3 u = fr * fr * (3.0 - 2.0 * fr);\n    \n    float bf = mix(a,b,u.x);\n    float bb = mix(c,d,u.x);\n    \n    float bot = mix(bf,bb,u.y);\n    \n    float tf = mix(e,f,u.x);\n    float tb = mix(g,h,u.x);\n    \n    float top = mix(tf,tb,u.y); \n\n    return mix(bot,top,u.z);\n}\n\n#define NUM_OCTAVES 4\n\nfloat fbm3 ( in vec3 _st) {\n    float v = 0.0;\n    float a = 0.5;\n    vec3 shift = vec3(100.0);\n    float offset = 0.;\n    for (int i = 0; i < NUM_OCTAVES; ++i) {\n        //v += a * sin((_st.y + _st.x+ _st.y)*10.)*1.5;\n        offset += a*2.5/1.5;\n        v += a * noise3(_st)*2.5;\n        _st = _st * 2. + shift;\n        a *= 0.5;\n    }\n    return v/offset;\n}\n\nfloat voronoi(vec2 uv){\n    uv*=3.;\n    float minDist = 100.;\n    float t = iTime;\n        \n    vec2 gv = fract(uv)-.5;\n    vec2 id = floor(uv);\n    for(float y=-1.;y<=1.;y++){\n        for(float x = -1.;x<=1.;x++){\n            vec2 offs = vec2(x,y);\n            vec2 n = N22(id + offs);\n            vec2 p = offs + sin(n*t)*.5;\n\n            float d = length(gv-p);\n\n            if(d<minDist){\n                minDist = d;\n            }\n\n        }\n    }\n    \n    return minDist;\n\n}\n\nfloat smoosh(float a){\n    float b = atanh((a-0.5)*2.)/10.+0.5;\n    return b;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    vec2 R = iResolution.xy;\n    vec2 uv = (2.*fragCoord-R.xy)/R.y;\n    uv = (2.*fragCoord-R.xy)/512.;\n\n    float m = 0.;\n    float t =iTime;\n \n    float minDist = 100.01;\n    vec3 oCol = vec3(1.);\n    if(false){\n    for(float i = 0.;i<50.;i++){\n        vec2 n = N22(vec2(i+1.));\n        vec2 n2 = N22(vec2(i*40.));\n        vec2 p = sin(n*t);\n        p.x *= R.x/R.y;\n         \n        float d = length(uv-p);\n        m += smoothstep(.02,0.01,d);\n        \n        if(d<minDist){\n            minDist = d;\n            oCol = vec3(n.x,n2.x,n2.y);\n        }\n         \n    }\n    }else{\n        uv*=1.6;\n        \n        vec2 gv = fract(uv)-.5;\n        vec2 id = floor(uv);\n        for(float y=-1.;y<=1.;y++){\n            for(float x = -1.;x<=1.;x++){\n                vec2 offs = vec2(x,y);\n                vec2 n = N22(id + offs);\n                vec2 n2 = N22((id + offs)*40.);\n                vec2 p = offs + sin(n*t+n2)*.5;\n                \n                float d = length(gv-p) + voronoi(vec2(uv.xy*1.+n.xy))*2.;\n                \n                if(d<minDist){\n                    minDist = d;\n                    oCol = vec3(n.x,n2.x,n2.y)*0.8+0.2; //for some reason sometimes n and n2 are all 0 making oCol 0...;\n                }\n                \n            }\n        }\n    }\n    \n    //float val = minDist;\n    float val = aafract(minDist*4.);\n    float v2 = floor(minDist*4.)/4.;\n    \n    vec3 hslCol = hsl2rgb(vec3(abs(sin(v2*PI+iTime/5.))/3.+iTime/10.,0.32,0.5));\n \n    vec3 col = vec3(val);\n    //col *= oCol;\n    //col *= vec3(0.5,0.8,0.7)*v2; //could feed v2 into a hsl function lots of fun posibilities\n    col *= hslCol;\n\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wltyWH.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[25, 25, 42, 42, 165], [167, 167, 194, 194, 337], [339, 339, 363, 391, 669], [672, 726, 755, 755, 868], [870, 870, 898, 898, 1628], [1653, 1653, 1680, 1680, 2013], [2015, 2015, 2038, 2038, 2495], [2497, 2497, 2519, 2519, 2576], [2579, 2579, 2636, 2636, 4304]]}
{"id": "WltyzX", "name": "Distorted Torus", "author": "kekwizard", "description": "srseg", "tags": ["torus", "distortion"], "likes": 2, "viewed": 226, "published": "Public API", "date": "1609620465", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\n mat3 rotationMatrix(vec3 axis, float angle)\n{\n    axis = normalize(axis);\n    float s = sin(angle);\n    float c = cos(angle);\n    float oc = 1.0 - c;\n    \n    return mat3(oc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s,\n                oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s,\n                oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c);\n}\n\nfloat mixV(float a, float b, float d) {\n\treturn (d * a)+(1.0 - d)*b;\n}\n\nfloat map(vec3 p)\n{\n   float displacement = .55 * sin(iTime + 5.*p.x)*cos(iTime * 1.1 + 5.*p.y)*sin(iTime * 1.2 + 5.*p.z);    \n   return displacement + sdTorus(p, vec2(7.0, 3.0));\n}\n\nvoid getCamPos(inout vec3 ro, inout vec3 rd)\n{\n    ro.z = -16.0;\n}\n\nvec3 palette( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d )\n{\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n   \n    vec2 _p = (iResolution.xy - 2.0 * fragCoord.xy) / iResolution.y;\n    vec3 ray = normalize(vec3(_p, 1.0));\n    vec3 cam = vec3(0.0, 0.0, 0.0);\n    bool hit = false;\n    getCamPos(cam, ray);  \n    \n    mat3 rm = rotationMatrix(vec3(0.66, 1., 0.9), iTime);\n\n        \n    float depth = 0.0, d = 0.0, iter = 0.0;\n    vec3 p;\n    \n    for( int i = 0; i < 30; i ++)\n    {\n    \tp = depth * ray + cam;\n        d = map(rm * p);\n                  \n        if (d < 0.0001) {\n\t\t\thit = true;\n            break;\n        }\n                   \n\t\tdepth += d * 0.75;\n\t\titer++;\n                   \n    }\n    \n    vec3 col = vec3(1.0 - iter / 31.0);\n    /*\n    const vec3 a = vec3(0.5, 0.5, 0.5);\n    const vec3 b = vec3(0.5, 0.5, 0.5);\n    const vec3 c = vec3(2., 1., 0.);\n    const vec3 da = vec3(0.5, 0.2, 0.25);\n*/\n    \n    const vec3 a = vec3(0.5, 0.5, 0.5);\n    const vec3 b = vec3(0.5, 0.5, 0.5);\n    const vec3 c = vec3(1., 1., 0.5);\n    const vec3 da = vec3(0.8, 0.9, 0.3);\n\t\n    \n    \n    vec3 sq = sqrt(col);\n    \n    vec3 gg = palette(sq.x * sq.y * sq.z, a, b, c, da);\n\n    fragColor = vec4(gg, 0.0);\n    \n    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WltyzX.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 1, 32, 32, 119], [121, 121, 154, 154, 219], [222, 222, 267, 267, 739], [741, 741, 780, 780, 811], [813, 813, 832, 832, 994], [996, 996, 1042, 1042, 1062], [1064, 1064, 1136, 1136, 1179], [1181, 1181, 1238, 1238, 2351]]}
{"id": "WlVcDV", "name": "Fractal 05_gaz", "author": "gaz", "description": "3d", "tags": ["fractal"], "likes": 8, "viewed": 84, "published": "Public", "date": "1611805200", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define rot(a) mat2(cos(a),sin(a),-sin(a),cos(a))\n\nfloat lpNorm(vec3 p, float n)\n{\n\tp = pow(abs(p),vec3(n));\n\treturn pow(p.x+p.y+p.z,1./n);\n}\n\nfloat map(vec3 p){\n    p.xy*=rot(iTime*.3);\n    p.yz*=rot(iTime*.3);\n    float scale=4.5;\n    float mr2=.5;\n    float off=.5;\n    float s=1.;\n    vec3 p0 = p;\n    for (int i=0; i<16; i++) {\n        if(i%3==0)p=p.yzx;\n        if(i%2==1)p=p.yxz;\n        p -= clamp(p,-1.,1.)*2.;\n        float r2=pow(lpNorm(p.xyz,5.),2.);\n        float g=clamp(mr2*max(1./r2,1.),0.,1.);\n        p=p*scale*g+p0*off;\n        s=s*scale*g+off;\n    }\n    return length(p)/s-.01;\n}\n\nvec3 calcNormal(vec3 pos)\n{\n  vec2 e=vec2(1,-1)*.005;\n  return normalize(\n    e.xyy*map(pos+e.xyy)+e.yyx*map(pos+e.yyx)+ \n    e.yxy*map(pos+e.yxy)+e.xxx*map(pos+e.xxx)\n  );\n}\n\nfloat march(vec3 ro, vec3 rd, float near, float far)\n{\n    float t=near,d;\n    for(int i=0;i<80;i++)\n    {\n        t+=d=map(ro+rd*t);\n        if (d<.001) return t;\n        if (t>=far) return far;\n    }\n    return far;\n}\n\nfloat calcShadow(vec3 light, vec3 ld, float len)\n{\n\tfloat depth=march(light,ld,0.,len);\t\n\treturn step(len-depth,.01 );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord*2.-iResolution.xy)/iResolution.y;\n    vec3 ro = vec3(0,0,8.);\n    vec3 rd = normalize(vec3(uv,-2.));\n    vec3 col = vec3(0);\n\tconst float maxd = 40.;\n    float t = march(ro,rd,0.,maxd);\n    if(t<maxd)\n    {\n        vec3 p=ro+rd*t;\n        col=vec3(.3,.3,.6)+cos(p*.17)*.5+.5;\n        vec3 n=calcNormal(p);      \n\t\tvec3 lightPos=vec3(20);\n    \tvec3 li=lightPos-p;\n\t\tfloat len=length(li);\n\t\tli/=len;\n\t\tfloat dif=clamp(dot(n, li),.5,1.);\n        float sha=calcShadow(lightPos,-li,len);\n        col*=max(sha*dif,.4);\n        float rimd=pow(clamp(1.-dot(reflect(-li,n),-rd),0.,1.),2.5);\n\t\tfloat frn=rimd+2.2*(1.-rimd);\n    \tcol*=frn*.9;\n        col*=max(.5+.5*n.y,0.);\n        col*=exp2(-2.*pow(max(0.,1.-map(p+n*.3)/.3),2.));\n        col+=vec3(.5,.9,.9)*pow(clamp(dot(reflect(rd,n),li),0.,1.),8.);\n        col=mix(vec3(0),col,exp(-t*t*.003));\n    }\n    fragColor.xyz=col;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WlVcDV.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[51, 51, 82, 82, 141], [143, 143, 161, 161, 599], [601, 601, 628, 628, 775], [777, 777, 831, 831, 996], [998, 998, 1048, 1048, 1118], [1120, 1120, 1177, 1177, 2072]]}
{"id": "wlVcRw", "name": "Payday Joyman", "author": "luckyballa", "description": "first time playing with raymarching :) ", "tags": ["raymarching", "specular", "character", "memoji"], "likes": 6, "viewed": 99, "published": "Public API", "date": "1610721944", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define MAX_STEPS 25\n#define MAX_DIST 25.\n#define SURF_DIST .008\n\nfloat g_time;\n\nfloat sdSphere( vec3 p, float s ) { return length(p)-s; }\n\nfloat sdRoundedCylinder( vec3 p, float ra, float rb, float h ) {\n  vec2 d = vec2( length(p.xz)-2.0*ra+rb, abs(p.y) - h );\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0)) - rb;\n} \n\nfloat sdBox( vec3 p, vec3 b ) {\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat sdCappedTorus(in vec3 p, in vec2 sc, in float ra, in float rb) {\n  p.x = abs(p.x);\n  float k = (sc.y*p.x>sc.x*p.y) ? dot(p.xy,sc) : length(p.xy);\n  return sqrt( dot(p,p) + ra*ra - 2.0*ra*k ) - rb;\n}\n\nfloat smax( float a, float b, float k ) {\n    k *= 1.4;\n    float h = max(k-abs(a-b),0.0);\n    return max(a, b) + h*h*h/(6.0*k*k);\n}\n\nfloat smin( float a, float b, float k ) {\n    float h = max(k-abs(a-b),0.0);\n    return min(a, b) - h*h*0.25/k;\n}\n\nvec2 rot(vec2 p, in float an ) {\n    float cc = cos(an);\n    float ss = sin(an);\n    return mat2(cc,-ss,ss,cc)*p;\n}\n\nfloat displacement(vec3 p) { return sin(60.*p.x)*sin(60.0*p.y)*sin(60.*p.z); }\n\nfloat sdCone( in vec3 p, in vec2 c ) {\n  vec2 q = vec2( length(p.xz), p.y );\n\n  vec2 a = q - c*clamp( (q.x*c.x+q.y*c.y)/dot(c,c), 0.0, 1.0 );\n  vec2 b = q - c*vec2( clamp( q.x/c.x, 0.0, 1.0 ), 1.0 );\n  \n  float s = -sign( c.y );\n  vec2 d = min( vec2( dot( a, a ), s*(q.x*c.y-q.y*c.x) ),\n\t\t\t    vec2( dot( b, b ), s*(q.y-c.y)  ));\n  return -sqrt(d.x)*sign(d.y);\n}\n\n\nvec2 getDist(vec3 p) {\n\n    float matId;\n    p.y -= 0.2;\n    vec3 orig =  vec3(0, 1, 6.4);\n    \n    //HEAD\n\tvec3 headPos = p-orig;\n    vec3 direction =  normalize(headPos);\n    headPos.x -= (p.y - 1.1) * 0.35 * direction.x;\n    headPos.x += pow(abs(sin((p.y + 2.) * 8.)) * 0.1, 1.2 + p.y) * normalize(headPos).x;  \n\n    float head = length(headPos) -1. + p.y * 0.5;\n    \n    //HAIR\n    vec3 hairPos = p-orig;\n    float hair = sdRoundedCylinder(hairPos, 0.24, 0.15, 0.27);\n    hair += displacement(hairPos) * .005;\n    \n    if (hair < head) {\n       head = smin(hair, head, 0.01);\n        matId = 0.;\n    } else {\n        matId = 2.;\n    }\n      \n    //EYES\n    vec3 eyePos = headPos + vec3(0.05 * direction.x, 0.25, .5);\n    vec3 eyeOff = vec3(0.19, 0., 0.);\n    eyePos.x = abs(eyePos.x);\n\n    float eye = length(eyePos -eyeOff) -0.12;\n    if (-eye > head) { head += eye; }\n    head = min(eye + 0.01, head);    \n    \n    vec3 eyeBrowPos = vec3( rot( vec2(eyePos.x * 1.2 - eyeOff.x * 1.3 , eyePos.y -0.17) , 1.5),  eyePos.z+0.1);\n    eyeBrowPos.x -= (1. - pow(abs(sin(g_time)), 0.4)) * 0.03;\n    eyeBrowPos.x += sin(eyeBrowPos.y * 20. - 1.) * .012;\n    float eyeBrow = sdRoundedCylinder(eyeBrowPos, 0.005, 0.04, 0.11);\n    \n    if (eyeBrow < head) {\n        head = smin(eyeBrow, head, 0.1);\n        matId = 0.;\n    }\n    \n    //GLASSES\n    eyePos.z += 0.2;\n    eyeOff.x += 0.02;\n    float glass = sdBox(eyePos-eyeOff, vec3(0.15, 0.07 , 0.02));\n    eyeOff.x += 0.24;\n    eyeOff.z += 0.2;\n    float glassb = sdRoundedCylinder(vec3(rot((eyePos-eyeOff).xz, -.4), eyePos.y), 0.005, 0.02, 0.2);    \n\n    eyePos.x *= 2.;\n    eyePos.y *= 1.8;\n    eyePos.z *= 0.9;\n    eyePos.z -= 0.2;\n    float glassC = sdCappedTorus( vec3(eyePos.x, rot((eyePos+eyeOff).yz, -1.5)), vec2(0.2, 0.), 0.15, 0.02);\n\n    if (glassC < head) {\n        head = min(glassC, head);\n        matId = 6.;\n    }\n    if (glassb < head) {\n        head = min(glassb, head);\n        matId = 6.;\n    }\n    \n    if (glass < head) {\n        head = min(glass, head);\n        matId = 1.;\n    }\n     \n    //NOSE\n    vec3 nosePos = p-orig;\n    nosePos.z += 0.7;\n    nosePos.y += 0.15;\n    nosePos.yz = rot(nosePos.yz,-0.3);\n    float h = smoothstep(0.,0.3,-nosePos.y );\n    float nose = 1.;\n    nosePos.x = sqrt(nosePos.x*nosePos.x + 0.001);\n    nose = smin( nose, sdSphere(nosePos-vec3(0.04, -0.3, 0.037),0.03 ), 0.1);\n    nose = smin( nose, sdSphere(nosePos*vec3(1.05,0.95,1.)-vec3(.0, -0.155, 0.05),0.02), 0.19);\n    head = smin(head,nose,0.05-0.04*h);\n    if (nose - 0.001 < head) {\n        matId = 2.;\n    }\n    \n    //EARS\n    vec3 earsPos = p-orig;\n    earsPos.x = abs(earsPos.x);\n    earsPos.y += 0.35;\n    earsPos.y *= 0.7;\n    earsPos.z += 0.1;\n    earsPos.x -= 0.41;\n    float ear = sdSphere(earsPos,0.08); \n    if (ear < head) {\n        head = smin(head,ear,0.02);\n        matId = 2.;\n    }\n\n    //MOUTH\n    float mT = 0.88 - pow(abs(g_time) / 1.2, 1.8);\n    vec3 mPos = p - vec3(orig.x + 0.7 * direction.x * mT, orig.y-.6, orig.z -0.55);\n    mPos.y -= pow(abs(sin(abs(p.x))), 1.9 + mT * 0.3);\n   \tfloat mouth = length(mPos) - 0.05;\n    mPos.x = orig.x + 0.69 * direction.x  * (1.55 - mT);\n    mPos.z *= 1.8;\n    mPos.z -= 0.064;\n    mPos.y -= 0.015;\n    mPos.y *= 0.95;\n    float outMouth = length(mPos) - 0.05;\n    if (-mouth - 0.008 > head ) {\n        matId = 3.;\n        head = smin(-mouth, head, 0.2);\n    }\n    \n    head = smin(head, outMouth, 0.03);  \n    outMouth = length(vec3(mPos.x, mPos.y - 0.01 ,  mPos.z))  - 0.05;\n    if (outMouth - 0.022 < head){ matId = 4.; }\n    \n    //DOLLAR\n    vec3 dollaInitialPos = headPos + vec3(1.66, -0.52, 1.6) - vec3(.5*sin(g_time),0., 1.*cos(g_time));\n    vec3 dollaPos = dollaInitialPos;\n    dollaPos.x *= 0.85 - p.y * 0.01;\n    dollaPos.xy *= 2.5;\n    dollaPos.y *= 1.1;\n    dollaPos.z += sin(iTime + dollaPos.y * 5.) * 0.05;\n    dollaPos.xy = rot( dollaPos.xy, 0.9);\n    dollaPos.x = dollaPos.y > 0. ? -dollaPos.x + 0.36 : dollaPos.x;\n    float dollaA = sdCappedTorus(dollaPos, vec2(sin(iTime-.3), cos(iTime-.3)), 0.22, 0.025);\n   \n    dollaPos.xy = dollaInitialPos.xy - vec2(0.02, 0.06);\n    dollaPos.xy *= 2.;\n    dollaPos.xy = rot( dollaPos.xy, -.2);\n    dollaPos.x -= 0.05;\n    dollaPos.x = abs(dollaPos.x);\n    dollaPos.x -= 0.05;\n    float dollaB = sdRoundedCylinder(dollaPos, 0.01, 0.02, 0.49 * abs(cos(iTime / 2. - 1.) ));    \n\n\n   if (dollaA < head) {\n       head = min(dollaA, head);\n       matId = 5.;\n    } \n    if (dollaB < head) {\n        head = smin(dollaB, head, 0.075);\n        matId = 5.;\n    }\n    \n    return vec2(head, matId);\n}\n\n\nvec2 rayMarch(vec3 ro, vec3 rd) {\n\tfloat dO=0.;\n    float matId = -1.;\n    \n    for(int i=0; i<MAX_STEPS; i++) {\n    \tvec3 p = ro + rd*dO;\n        vec2 res = getDist(p);\n        float dS = res.x;\n        dO += dS;\n        matId = res.y;\n        \n        if(dO>MAX_DIST || dS<SURF_DIST) break;\n    }\n    \n    return vec2(dO, matId);\n}\n\nvec3 getNormal(vec3 p) {\n\tfloat d = getDist(p).x;\n    vec2 e = vec2(.01, 0);\n    \n    vec3 n = d - vec3(\n        getDist(p-e.xyy).x,\n        getDist(p-e.yxy).x,\n        getDist(p-e.yyx).x);\n    \n    return normalize(n);\n}\n\nfloat light(vec3 p, vec3 n) {\n    vec3 lightPos = vec3(0.5, 1.5, 4.);\n    vec3 l = normalize(lightPos-p);\n    float dif = clamp(dot(n, l), 0., 1.);     \n    return dif*1.5;\n}\n\nfloat slight(vec3 p, vec3 ro, vec3 n) {\n    vec3 lightPos = vec3(g_time * 4., 2., 4.);\n    vec3 l = normalize(lightPos-p);\n    \n    float lDist = max(length(l), 0.001);\n    float atten = 1./(1.0 + lDist*lDist*0.5);\t\n    vec3 reflection = reflect(-l, n);\n    float spec = pow(max( dot(reflection, -normalize(ro)), 0.), 9.); \n        \n    return spec*3. *atten;;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    vec2 mo = (iMouse.xy-.5*iResolution.xy)/iResolution.y;\n    vec3 col = vec3(0.0);\n    \n    float iTime = iTime * 4.;\n    vec2 m = vec2(0.5);\n    g_time = sin(-0.25 + 0.31416*iTime) - 6.2831*(m.x-0.5);\n\n\tvec3 ro = vec3(.5*sin(g_time),1., 1.*cos(g_time));\n    vec3 rd = normalize(vec3(uv.x, uv.y , 2.));\n\n    vec2 d = rayMarch(ro, rd);\n    vec3 p = ro + rd * d.x;\n    vec3 n = getNormal(p);\n    float dif = light(p, n) / 2.7;\n    float spec = slight(p, ro, n);\n    vec3 bc = vec3(0.85, 0.72, 0.56);\n\n    col = dif * vec3(0.85, 0.35, 0.2);\n    \n    if (d.y == 0.) { // HAIR\n          col = dif * vec3(0.12, 0.10, 0.101); \n    } else  if (d.y == 1.) { // GLASSES\n          col = min((spec+spec/1.5+dif) * vec3(0.84, 0.2, 0.15), 1.); \n    } else  if (d.y == 2.) { // SKIN\n        col = dif * vec3(0.85, 0.35, 0.2);\n    } else if (d.y == 3.) { // MOUTH IN\n          col = dif * vec3(1., 0.5, 0.4) * 0.9;\n    } else if (d.y == 4.) { // MOUTH\n              col = dif * vec3(0.9, 0.3, 0.2) / 1.3;\n    } else if (d.y == 5.) { // DOLLA\n              col = max(pow(spec+dif+dif, 1.2), 0.3) * vec3(0.1, 0.8, 0.4) / 2.;\n    } else if (d.y == 6.) { // GLASSES BASE\n              col = (spec+spec/2.+dif) * vec3(0.9, 0.7, 0.15);\n    } else if (d.y == 7.) { // PARTS\n            col =  vec3(0.32, 0.22, 0.12) * 0.6;// - dif/2.*bc;\n    }\n    \n    col = pow(col, vec3(.6));\n    col +=  0.1 * vec3(.25, 0.36, 0.7);\n    col *= 1.5;\n    \n    fragColor = vec4( max(vec3( col), 0.12),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wlVcRw.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[81, 81, 116, 116, 138], [140, 140, 204, 204, 321], [324, 324, 355, 355, 442], [444, 444, 514, 514, 648], [650, 650, 691, 691, 782], [784, 784, 825, 825, 897], [899, 899, 931, 931, 1014], [1016, 1016, 1044, 1044, 1094], [1096, 1096, 1134, 1134, 1458], [1461, 1461, 1483, 1483, 6019], [6022, 6022, 6055, 6055, 6355], [6357, 6357, 6381, 6381, 6578], [6580, 6580, 6609, 6609, 6754], [6756, 6756, 6795, 6795, 7118], [7120, 7120, 7177, 7177, 8707]]}
{"id": "wlVcWD", "name": "The last of us...", "author": "kw", "description": "Experimenting with colors and shapes.", "tags": ["2d"], "likes": 8, "viewed": 74, "published": "Public", "date": "1611142240", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n//the last of us...\n\n//distance functions: https://iquilezles.org/www/articles/distfunctions2d/distfunctions2d.htm\n\nfloat sdCircle(in vec2 pos,in float size)\n{\n    return length(pos) - size;\n}\n\nfloat sdLine(in vec2 pos,in vec2 a,in vec2 b)\n{\n    vec2 pa = pos - a;\n    vec2 ba = b - a;\n    float h = clamp(dot(pa,ba) / dot(ba,ba), 0.0, 1.0);\n    return length(pa - ba * h);\n}\n\nfloat sdPolygon(in vec2 pos,in vec2[5] v)\n{\n    const int num = v.length();\n    float d = dot(pos - v[0],pos - v[0]);\n    float s = 1.0;\n    for(int i = 0,j = num-1;i < num;j = i,i ++)\n    {\n        vec2 e = v[j] - v[i];\n        vec2 w = pos - v[i];\n        vec2 b = w - e * clamp(dot(w,e) / dot(e,e),0.0,1.0);\n        d = min(d,dot(b,b));\n        bvec3 cond = bvec3(pos.y >= v[i].y,pos.y < v[j].y,e.x * w.y > e.y * w.x);\n        if( all(cond) || all(not(cond)) ) s=-s;  \n    }\n    return s * sqrt(d);\n}\n\nfloat pShapeAdd(in float a,in float b)\n{\n    return min(a,b);\n}\n\nfloat pShapeSubtract(in float a,in float b)\n{\n    return max(a,-b);\n}\n\nfloat pShapeOverlap(in float a,in float b)\n{\n    return max(a,b); \n}\n\nfloat pShapeAddSmooth(in float a,in float b,in float k) \n{\n    float h = clamp(0.5 + 0.5 * (b - a) / k,0.0,1.0);\n    return mix(b,a,h) - k * h * (1.0 - h); \n}\n\n/*float pShapeSubtractSmooth(in float a,in float b,in float k) \n{\n    float h = clamp(0.5 - 0.5 * (b + a) / k,0.0,1.0);\n    return mix(b,-a,h) + k * h * (1.0 - h); \n}*/\n\n/*float pShapeOverlapSmooth(in float a,in float b,in float k) \n{\n    float h = clamp(0.5 - 0.5 * (b - a) / k,0.0,1.0);\n    return mix(b,a,h) + k * h * (1.0 - h);\n}*/\n\nfloat pSmooth(in float val,in float factor)\n{\n    return smoothstep(factor,-(3.0 / iResolution.y),val);\n}\n\nvec3 cSky(in vec2 pos)\n{\n    //vec3(mix(vec3(0.8,0.8,2.0),vec3(0.7,0.8,1.0),pos.y - 0.5))\n    return vec3(mix(vec3(0.8,0.8 + (pos.y + pos.x) / 10.0,2.0),vec3(0.7,0.8,1.0),pos.y - 0.5));\n}\n\nvec3 cDebug(in vec2 pos)\n{\n    return vec3(0.8,0.5,0.6);\n}\n\nvec3 cWater(in vec2 pos,in float height,in float move)\n{\n    vec3 color = vec3(0.1,0.5,1.0);\n    color.r += height + sin(move) * abs(pos.x);\n    color.g += height + (move * 1.2);\n    color.b += (pos.y / 4.0);\n    return color;\n}\n\nvec3 cIce(in vec2 pos)\n{\n   vec3 color;\n   float move = abs(sin(((-pos.x + (iTime / 6.0)) / 50.0) * 400.0) / 20.0);\n   move += (sin(abs(pos.x) + iTime * 10.0) / 100.0);\n   move = pos.y + move + 0.4 + 0.2;\n   color = cWater(pos,0.6,move);\n   color.r /= abs(move - 0.16);\n   color.g /= abs(move + 0.1);\n   color.b /= pos.y * move;\n   return color * (color * 0.4);\n}\n\nvec3 cBear(in vec2 pos)\n{\n    pos.y += 0.2;\n    vec3 color = vec3(2.0 - (1.0 - (pos.x - 0.5) - (pos.y / 1.2)),1.0 - (0.1 - pos.y),0.9);\n    return color;\n}\n\nvec3 cRing(in vec2 pos)\n{\n    vec3 color = vec3(4.0,0.4,1.5);\n    float a = atan(pos.x,pos.y);\n    a = sin((a + 0.2) * 4.0);\n    a = pSmooth(a,0.02);\n    color.r += pos.y * 0.4;\n    color.g += a - (pos.y * 2.0);\n    color.b *= a * a;\n    return color * (color * 0.4);\n}\n\nvec4 sWater(in vec2 pos,in float height,in float factor)\n{\n   float move = abs(sin(((-pos.x + (iTime / 6.0)) / 50.0) * 400.0) / 20.0);\n   move += (sin(abs(pos.x) + iTime * 8.0) / 100.0);\n   move = pos.y + move + height + 0.1;\n   float sd = pSmooth(move,factor);\n   return vec4(cWater(pos,height,move),sd);\n   return vec4(0.0);\n}\n\nfloat sIcePoly(in vec2 pos)\n{\n   float sd;\n   pos.y += abs(sin(iTime) / 30.0);\n   vec2 v1 = vec2(-0.4,-0.1);\n   vec2 v2 = vec2(0.0,-0.4);\n   vec2 v3 = vec2(0.4,-0.1);\n   vec2 v4 = vec2(0.2,0.1);\n   vec2 v5 = vec2(-0.01,0.1);\n   vec2[] v = vec2[](v1,v2,v3,v4,v5);  \n   sd = sdPolygon(pos,v);\n   v1 -= vec2(0.2,0.0);\n   v2 -= vec2(0.2,0.0);\n   v3 -= vec2(0.2,0.0);\n   v4 -= vec2(0.2,0.0);\n   v5 -= vec2(0.2,-0.2);\n   v = vec2[](v1,v2,v3,v4,v5); \n   sd = pShapeAdd(sd,sdPolygon(pos,v));\n   v1 -= vec2(-0.4,-0.2);\n   v2 -= vec2(-0.6,-0.1);\n   v3 -= vec2(-0.6,-0.1);\n   v4 -= vec2(-0.4,-0.1);\n   v5 -= vec2(-0.4,0.1);\n   v = vec2[](v1,v2,v3,v4,v5);\n   sd = pShapeAdd(sd,sdPolygon(pos,v));\n   return sd;\n}\n\nvec4 sIce(in vec2 pos,in float factor)\n{\n   float sd = sIcePoly(pos);\n   sd = pSmooth(sd,factor);\n   return vec4(cIce(pos),sd);     \n}\n\nvec4 sIceWater(in vec2 pos,in float factor)\n{\n    float sd = sIcePoly(pos);\n    float move = abs(sin(((-pos.x + (iTime / 6.0)) / 50.0) * 400.0) / 20.0);\n    move += (sin(abs(pos.x) + iTime * 4.0) / 100.0);\n    move = pos.y + move + 0.1; \n    sd = pShapeOverlap(sd,move);\n    sd = pSmooth(sd,factor);\n    return vec4(cWater(pos,0.3,0.004),sd);\n}\n\nvec4 sBear(in vec2 pos,in float factor)\n{\n    pos.y += abs(sin(iTime) / 30.0);\n    float m = (abs(sin(iTime)) / 100.0);\n    float dm;\n    float sd = sdCircle(pos,0.1 - m / 4.0);\n    float dd = sdCircle(pos - vec2(0.1,0.08 - m),0.04);\n    sd = pShapeAddSmooth(sd,dd,0.1);\n    dd = sdCircle(pos - vec2(0.1,-0.08),0.03);\n    sd = pShapeAddSmooth(sd,dd,0.05);\n    dd = sdCircle(pos - vec2(0.12,-0.09),0.026);\n    sd = pShapeAdd(sd,dd);\n    dd = sdCircle(pos - vec2(0.15,0.01 - m / 4.0),0.02);\n    sd = pShapeAddSmooth(sd,dd,0.05);\n    dd = sdCircle(pos - vec2(0.17,0.0),0.02);\n    sd = pShapeAdd(sd,dd);\n    dd = sdCircle(pos - vec2(0.08,0.1),0.05);\n    sd = pShapeAdd(sd,dd);\n    dd = sdCircle(pos - vec2(0.10,0.1),0.02);\n    sd = pShapeAddSmooth(sd,dd,0.1);\n    dd = sdCircle(pos - vec2(0.12,0.11),0.06);\n    sd = pShapeAdd(sd,dd);\n    dd = sdCircle(pos - vec2(0.12,0.17),0.02);\n    sd = pShapeAdd(sd,dd);\n    dd = sdCircle(pos - vec2(0.18,0.13),0.02);\n    sd = pShapeAdd(sd,dd);\n    sd = pSmooth(sd,factor);\n    return vec4(cBear(pos - vec2(0.0,-0.25)),sd);\n}\n\nvec4 sBear2(in vec2 pos,in float factor)\n{\n    pos.y += abs(sin(iTime) / 30.0);\n    float m = (abs(sin(iTime + 20.0)) / 60.0);\n    float dm;\n    float sd = sdCircle(pos - vec2(0.0,0.01),0.11 - m / 2.0);\n    float dd = sdCircle(pos - vec2(-0.12,0.06),0.035);\n    sd = pShapeAddSmooth(sd,dd,0.1);\n    dd = sdCircle(pos - vec2(0.07,-0.01),0.03);\n    sd = pShapeAddSmooth(sd,dd,0.1);\n    dd = sdCircle(pos - vec2(-0.1,0.06),0.07);\n    sd = pShapeAdd(sd,dd);\n    dd = sdCircle(pos - vec2(-0.1,0.13),0.02);\n    sd = pShapeAdd(sd,dd);\n    dd = sdCircle(pos - vec2(-0.166,0.07),0.02);\n    sd = pShapeAdd(sd,dd);\n    sd = pSmooth(sd,factor);\n    return vec4(cBear(pos - vec2(0.0,-0.2)),sd);\n}\n\nvec4 sBearTail(in vec2 pos,in float factor)\n{\n    pos.y += abs(sin(iTime) / 30.0);\n    float sd = sdCircle(pos - vec2(-0.08,-0.05),0.02);\n    sd = pSmooth(sd,factor);\n    return vec4(cBear(pos - vec2(0.0,-0.20)),sd);\n}\n\nvec4 sBearTail2(in vec2 pos,in float factor)\n{\n    pos.y += abs(sin(iTime) / 30.0);\n    float sd = sdCircle(pos - vec2(-0.08,-0.05),0.02);\n    sd = pSmooth(sd,factor);\n    return vec4(cBear(pos - vec2(-0.08,-0.30)),sd);\n}\n\nvec4 sRing(in vec2 pos,in float factor)\n{\n    pos.y += abs(sin(iTime) / 30.0);\n    pos -= vec2(0.1,-0.23);\n    float sd = sdCircle(pos,0.1);\n    float dd = sdCircle(pos,0.05);\n    sd = pShapeSubtract(sd,dd);\n    sd = pSmooth(sd,factor);\n    return vec4(cRing(pos),sd);  \n}\n\nvec4 sVignette(in vec2 pos,in float factor)\n{\n    float sd = sdLine(pos,vec2(-2.0,0.0),vec2(2.0,0.0));\n    sd = pSmooth(sd,factor);\n    return vec4(vec3(0.1,0.1,0.3),sd);\n}\n\nvec3 pDraw(in vec3 color,in vec4 obj)\n{\n    return mix(color,obj.rgb,obj.a);\n}\n\nvec3 pDrawEx(in vec3 color,in vec4 obj,in float factor)\n{\n    return mix(color,obj.rgb * factor,obj.a);\n}\n\nvec2 pScreen(in vec2 pix,in vec3 res)\n{\n    return vec2((2.0 * pix - res.xy) / res.y);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = pScreen(fragCoord,iResolution);\n    vec3 color = cSky(uv);\n    vec4 water = sWater(uv - vec2(-0.7,0.0),0.3,0.004); \n    color = pDraw(color,water);\n    water = sWater(uv - vec2(-0.5,0.0),0.3,0.004); \n    color = pDraw(color,water);\n    water = sWater(uv - vec2(-0.2,0.0),0.35,0.004); \n    color = pDraw(color,water);\n    vec4 ice = sIce(uv - vec2(-0.5,-0.44),0.001);\n    color = pDrawEx(color,ice,0.4);\n    water = sWater(uv,0.4,0.004); \n    color = pDraw(color,water);\n    vec4 icewater = sIceWater(uv - vec2(-0.5,-0.5),0.01);\n    color = pDraw(color,icewater);\n    vec4 ring = sRing(uv,0.001);\n    color = pDraw(color,ring); \n    vec4 bear = sBear(uv -  vec2(-0.1,-0.2),0.001);\n    color = pDraw(color,bear);\n    vec4 beartail = sBearTail(uv -  vec2(-0.1,-0.2),0.001);\n    color = pDraw(color,beartail);\n    vec4 bear2 = sBear2(uv -  vec2(-0.5,-0.22),0.001);\n    color = pDraw(color,bear2);\n    vec4 beartail2 = sBearTail2(uv -  vec2(-0.32,-0.22),0.001);\n    color = pDraw(color,beartail2);\n    vec4 vignette = sVignette(uv - vec2(0.0,-1.0),0.5);\n    color = pDraw(color,vignette);\n    fragColor = vec4(color,1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wlVcWD.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[22, 117, 160, 160, 193], [195, 195, 242, 242, 376], [378, 378, 421, 421, 881], [883, 883, 923, 923, 946], [948, 948, 993, 993, 1017], [1019, 1019, 1063, 1063, 1087], [1089, 1089, 1147, 1147, 1247], [1419, 1586, 1631, 1631, 1691], [1693, 1693, 1717, 1782, 1880], [1882, 1882, 1908, 1908, 1940], [1942, 1942, 1998, 1998, 2170], [2172, 2172, 2196, 2196, 2535], [2537, 2537, 2562, 2562, 2692], [2694, 2694, 2719, 2719, 2963], [2965, 2965, 3023, 3023, 3293], [3295, 3295, 3324, 3324, 3994], [3996, 3996, 4036, 4036, 4130], [4132, 4132, 4177, 4177, 4476], [4478, 4478, 4519, 4519, 5536], [5538, 5538, 5580, 5580, 6221], [6223, 6223, 6268, 6268, 6441], [6443, 6443, 6489, 6489, 6664], [6666, 6666, 6707, 6707, 6938], [6940, 6940, 6985, 6985, 7112], [7114, 7114, 7153, 7153, 7192], [7194, 7194, 7251, 7251, 7299], [7301, 7301, 7340, 7340, 7389], [7391, 7391, 7448, 7448, 8581]]}
{"id": "WlVcWt", "name": "2D Implicit Function Plotter", "author": "oneshade", "description": "2D implicit plotter.", "tags": ["2d", "math", "graph", "function", "plot", "implicit"], "likes": 7, "viewed": 113, "published": "Public", "date": "1611979209", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define CONTOUR_SPACING 1.0\n#define CONTOUR_THICKNESS 2.0\n#define DELTA 0.001\n\n// Hardware derivatives don't seem to produce good contours on my computer\n//#define USE_HARDWARE_DERIVATIVES\n\n// Hue to RGB function from Fabrice's shadertoyunofficial blog:\n#define hue2rgb(hue) 0.6 + 0.6 * cos(6.3 * hue + vec3(0.0, 23.0, 21.0))\n\nfloat f(in vec2 p) {\n    p *= 3.0;\n    vec3 p3 = vec3(p, iTime);\n    return dot(sin(p3), cos(p3.zxy));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y * 4.0;\n    float unit = CONTOUR_THICKNESS / iResolution.y * 4.0;\n\n    float hSpacing = 0.5 * CONTOUR_SPACING;\n    float fRes = f(uv);\n\n    #ifdef USE_HARDWARE_DERIVATIVES\n    float grad = length(fwidth(fRes)) * iResolution.y / 5.0;\n\n    #else\n    float grad = length(vec2(f(uv + vec2(DELTA, 0.0)) - f(uv - vec2(DELTA, 0.0)),\n                             f(uv + vec2(0.0, DELTA)) - f(uv - vec2(0.0, DELTA)))) / (2.0 * DELTA);\n    #endif\n\n    float contour = abs(mod(fRes + hSpacing, CONTOUR_SPACING) - hSpacing) / grad;\n\n    fragColor = vec4(hue2rgb(fRes * 0.5) - smoothstep(unit, 0.0, contour), 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WlVcWt.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[190, 327, 347, 347, 431], [433, 433, 488, 488, 1156]]}
{"id": "WlVyDc", "name": "Neural Stanford Bunny Smooth Mat", "author": "gam0022", "description": "Change specular to smooth.", "tags": ["bunny"], "likes": 4, "viewed": 113, "published": "Public", "date": "1611885988", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//CC0 1.0 Universal https://creativecommons.org/publicdomain/zero/1.0/\n//To the extent possible under law, Blackle Mori has waived all copyright and related or neighboring rights to this work.\n\n//like the last few shaders I've published, this is a neural network experiment.\n//this time, the neural network reproduces an SDF given the x,y,z coordinates\n//using siren networks with skip connections: https://vsitzmann.github.io/siren/\n\nvec3 erot(vec3 p, vec3 ax, float ro) {\n    return mix(dot(p,ax)*ax,p,cos(ro))+sin(ro)*cross(ax,p);\n}\n\nfloat scene(vec3 p) {\n    //sdf is undefined outside the unit sphere, uncomment to witness the abominations\n    if (length(p) > 1.) {\n        return length(p)-.8;\n    }\n    //neural networks can be really compact... when they want to be\n    vec4 f00=sin(p.y*vec4(-3.02,1.95,-3.42,-.60)+p.z*vec4(3.08,.85,-2.25,-.24)-p.x*vec4(-.29,1.16,-3.74,2.89)+vec4(-.71,4.50,-3.24,-3.50));\n    vec4 f01=sin(p.y*vec4(-.40,-3.61,3.23,-.14)+p.z*vec4(-.36,3.64,-3.91,2.66)-p.x*vec4(2.90,-.54,-2.75,2.71)+vec4(7.02,-5.41,-1.12,-7.41));\n    vec4 f02=sin(p.y*vec4(-1.77,-1.28,-4.29,-3.20)+p.z*vec4(-3.49,-2.81,-.64,2.79)-p.x*vec4(3.15,2.14,-3.85,1.83)+vec4(-2.07,4.49,5.33,-2.17));\n    vec4 f03=sin(p.y*vec4(-.49,.68,3.05,.42)+p.z*vec4(-2.87,.78,3.78,-3.41)-p.x*vec4(-2.65,.33,.07,-.64)+vec4(-3.24,-5.90,1.14,-4.71));\n    vec4 f10=sin(mat4(-.34,.06,-.59,-.76,.10,-.19,-.12,.44,.64,-.02,-.26,.15,-.16,.21,.91,.15)*f00+\n        mat4(.01,.54,-.77,.11,.06,-.14,.43,.51,-.18,.08,.39,.20,.33,-.49,-.10,.19)*f01+\n        mat4(.27,.22,.43,.53,.18,-.17,.23,-.64,-.14,.02,-.10,.16,-.13,-.06,-.04,-.36)*f02+\n        mat4(-.13,.29,-.29,.08,1.13,.02,-.83,.32,-.32,.04,-.31,-.16,.14,-.03,-.20,.39)*f03+\n        vec4(.73,-4.28,-1.56,-1.80))/1.0+f00;\n    vec4 f11=sin(mat4(-1.11,.55,-.12,-1.00,.16,.15,-.30,.31,-.01,.01,.31,-.42,-.29,.38,-.04,.71)*f00+\n        mat4(.96,-.02,.86,.52,-.14,.60,.44,.43,.02,-.15,-.49,-.05,-.06,-.25,-.03,-.22)*f01+\n        mat4(.52,.44,-.05,-.11,-.56,-.10,-.61,-.40,-.04,.55,.32,-.07,-.02,.28,.26,-.49)*f02+\n        mat4(.02,-.32,.06,-.17,-.59,.00,-.24,.60,-.06,.13,-.21,-.27,-.12,-.14,.58,-.55)*f03+\n        vec4(-2.24,-3.48,-.80,1.41))/1.0+f01;\n    vec4 f12=sin(mat4(.44,-.06,-.79,-.46,.05,-.60,.30,.36,.35,.12,.02,.12,.40,-.26,.63,-.21)*f00+\n        mat4(-.48,.43,-.73,-.40,.11,-.01,.71,.05,-.25,.25,-.28,-.20,.32,-.02,-.84,.16)*f01+\n        mat4(.39,-.07,.90,.36,-.38,-.27,-1.86,-.39,.48,-.20,-.05,.10,-.00,-.21,.29,.63)*f02+\n        mat4(.46,-.32,.06,.09,.72,-.47,.81,.78,.90,.02,-.21,.08,-.16,.22,.32,-.13)*f03+\n        vec4(3.38,1.20,.84,1.41))/1.0+f02;\n    vec4 f13=sin(mat4(-.41,-.24,-.71,-.25,-.24,-.75,-.09,.02,-.27,-.42,.02,.03,-.01,.51,-.12,-1.24)*f00+\n        mat4(.64,.31,-1.36,.61,-.34,.11,.14,.79,.22,-.16,-.29,-.70,.02,-.37,.49,.39)*f01+\n        mat4(.79,.47,.54,-.47,-1.13,-.35,-1.03,-.22,-.67,-.26,.10,.21,-.07,-.73,-.11,.72)*f02+\n        mat4(.43,-.23,.13,.09,1.38,-.63,1.57,-.20,.39,-.14,.42,.13,-.57,-.08,-.21,.21)*f03+\n        vec4(-.34,-3.28,.43,-.52))/1.0+f03;\n    f00=sin(mat4(-.72,.23,-.89,.52,.38,.19,-.16,-.88,.26,-.37,.09,.63,.29,-.72,.30,-.95)*f10+\n        mat4(-.22,-.51,-.42,-.73,-.32,.00,-1.03,1.17,-.20,-.03,-.13,-.16,-.41,.09,.36,-.84)*f11+\n        mat4(-.21,.01,.33,.47,.05,.20,-.44,-1.04,.13,.12,-.13,.31,.01,-.34,.41,-.34)*f12+\n        mat4(-.13,-.06,-.39,-.22,.48,.25,.24,-.97,-.34,.14,.42,-.00,-.44,.05,.09,-.95)*f13+\n        vec4(.48,.87,-.87,-2.06))/1.4+f10;\n    f01=sin(mat4(-.27,.29,-.21,.15,.34,-.23,.85,-.09,-1.15,-.24,-.05,-.25,-.12,-.73,-.17,-.37)*f10+\n        mat4(-1.11,.35,-.93,-.06,-.79,-.03,-.46,-.37,.60,-.37,-.14,.45,-.03,-.21,.02,.59)*f11+\n        mat4(-.92,-.17,-.58,-.18,.58,.60,.83,-1.04,-.80,-.16,.23,-.11,.08,.16,.76,.61)*f12+\n        mat4(.29,.45,.30,.39,-.91,.66,-.35,-.35,.21,.16,-.54,-.63,1.10,-.38,.20,.15)*f13+\n        vec4(-1.72,-.14,1.92,2.08))/1.4+f11;\n    f02=sin(mat4(1.00,.66,1.30,-.51,.88,.25,-.67,.03,-.68,-.08,-.12,-.14,.46,1.15,.38,-.10)*f10+\n        mat4(.51,-.57,.41,-.09,.68,-.50,-.04,-1.01,.20,.44,-.60,.46,-.09,-.37,-1.30,.04)*f11+\n        mat4(.14,.29,-.45,-.06,-.65,.33,-.37,-.95,.71,-.07,1.00,-.60,-1.68,-.20,-.00,-.70)*f12+\n        mat4(-.31,.69,.56,.13,.95,.36,.56,.59,-.63,.52,-.30,.17,1.23,.72,.95,.75)*f13+\n        vec4(-.90,-3.26,-.44,-3.11))/1.4+f12;\n    f03=sin(mat4(.51,-.98,-.28,.16,-.22,-.17,-1.03,.22,.70,-.15,.12,.43,.78,.67,-.85,-.25)*f10+\n        mat4(.81,.60,-.89,.61,-1.03,-.33,.60,-.11,-.06,.01,-.02,-.44,.73,.69,1.02,.62)*f11+\n        mat4(-.10,.52,.80,-.65,.40,-.75,.47,1.56,.03,.05,.08,.31,-.03,.22,-1.63,.07)*f12+\n        mat4(-.18,-.07,-1.22,.48,-.01,.56,.07,.15,.24,.25,-.09,-.54,.23,-.08,.20,.36)*f13+\n        vec4(-1.11,-4.28,1.02,-.23))/1.4+f13;\n    return dot(f00,vec4(.09,.12,-.07,-.03))+dot(f01,vec4(-.04,.07,-.08,.05))+\n        dot(f02,vec4(-.01,.06,-.02,.07))+dot(f03,vec4(-.05,.07,.03,.04))-0.16;\n}\n\nvec3 norm(vec3 p) {\n    mat3 k = mat3(p,p,p)-mat3(0.001);\n    return normalize(scene(p) - vec3(scene(k[0]),scene(k[1]),scene(k[2])));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-0.5*iResolution.xy)/iResolution.y;\n    vec2 mouse = (iMouse.xy-0.5*iResolution.xy)/iResolution.y;\n\n    vec3 cam = normalize(vec3(1.5,uv));\n    vec3 init = vec3(-3.,0,0);\n    \n    float yrot = 0.5;\n    float zrot = iTime*.2;\n    if (iMouse.z > 0.) {\n        yrot += -4.*mouse.y;\n        zrot = 4.*mouse.x;\n    }\n    cam = erot(cam, vec3(0,1,0), yrot);\n    init = erot(init, vec3(0,1,0), yrot);\n    cam = erot(cam, vec3(0,0,1), zrot);\n    init = erot(init, vec3(0,0,1), zrot);\n    \n    vec3 p = init;\n    bool hit = false;\n    for (int i = 0; i < 150 && !hit; i++) {\n        float dist = scene(p);\n        hit = dist*dist < 1e-6;\n        p+=dist*cam;\n        if (distance(p,init)>5.) break;\n    }\n    vec3 n = norm(p);\n    vec3 r = reflect(cam,n);\n    //don't ask how I stumbled on this texture\n    vec3 nz = p - erot(p, vec3(1), 2.) + erot(p, vec3(1), 4.);\n    // float spec = length(sin(r*3.5+sin(nz*120.)*.15)*.4+.6)/sqrt(3.);\n    float spec = pow(dot(n, r), 2.);\n    spec *= smoothstep(-.3,.2,scene(p+r*.2));\n    vec3 col = vec3(.1,.1,.12)*spec + pow(spec,8.);\n    float bgdot = length(sin(cam*8.)*.4+.6)/2.;\n    vec3 bg = vec3(.1,.1,.11) * bgdot + pow(bgdot, 10.);\n    fragColor.xyz = hit ? col : bg;\n    fragColor = smoothstep(-.02,1.05,sqrt(fragColor)) * (1.- dot(uv,uv)*.5);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WlVyDc.jpg", "access": "shaders20k", "license": "cc0-1.0", "functions": [[194, 435, 473, 473, 535], [537, 537, 558, 644, 4849], [4851, 4851, 4870, 4870, 4986], [4988, 4988, 5045, 5045, 6353]]}
{"id": "wlVyDy", "name": "bloomming fractal", "author": "milez770", "description": "tweaked a little... looks like a ripple\nit's basically a juliabulb", "tags": ["reversedjuliabulb"], "likes": 1, "viewed": 55, "published": "Public", "date": "1611726012", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define ITER 10\n#define MAX_STEPS 300\n#define MAX_DIST 100.\n#define SURF_DIST 0.001\n#define SPEED 100.\n\nfloat dist(vec2 p, vec2 t){\n    float dx = p.x-t.x;\n    float dy = p.y-t.y;\n    return sqrt(dx*dx+dy*dy);\n}\n\n// 3d mandelbulb\nfloat mandel3(in vec3 v, out vec3 map){\n    vec3 r = v;\n    vec3 rNext = r;\n    float m = dot(v, v);\n    vec4 trap = vec4(abs(r), m);\n    \n    int i = 0;\n    float d = 1.;\n    \n    float n =  3.;\n    \n    for(i=0; i<ITER; i++){\n        float cr = length(r);\n        float nr = pow(cr, n);\n        //*abs(sin(iTime/5.) )\n        float accos = acos(fract(r.z/cr+iTime/10.));\n        float actan = atan(r.y/r.x);\n        \n        d = pow(cr, n-1.) *n * d + 1.0;\n        \n        rNext.x = nr*sin(accos*n)*cos(n*actan);\n        rNext.y = nr*sin(accos*n)*sin(n*actan);\n        rNext.z = nr*cos(n*accos);\n        r = r - rNext;\n        \n        trap = min(trap, vec4(abs(r), m));\n        map = vec3(trap.yzw);\n\n        m = dot(r,r);\n        \n        if(m > 4.){\n            break;\n        }\n    }\n    //return pow(length(r), 2.)+sqrt(m);\n    return  .1*log(m) * sqrt(m) / d;\n}\n\nmat2 Rot(float a) {\n    float s = sin(a);\n    float c = cos(a);\n    return mat2(c, -s, s, c);\n}\n\nvec3 R(vec2 uv, vec3 p, vec3 l, float z) {\n    vec3 f = normalize(l-p),\n        r = normalize(cross(vec3(0,1,0), f)),\n        u = cross(f,r),\n        c = p+f*z,\n        i = c + uv.x*r + uv.y*u,\n        d = normalize(i-p);\n    return d; \n}\n\nfloat RayMarch(in vec3 ro, in vec3 rd, out vec3 col){\n    float dO = 0.;\n    \n    for(int i=0; i<MAX_STEPS; i++){\n        vec3 p = ro+rd*dO;\n        p.xz *= Rot(iTime/SPEED);\n        p.yz *= Rot(iTime/SPEED-2.);\n\n        float mbd = mandel3(abs(p), col);\n        float dS = mbd;\n        \n        if(dO > MAX_DIST || dS<SURF_DIST) break;\n        dO += dS;\n    }\n    \n    return dO;\n}\nvec3 GetNormal(vec3 p){\n    vec3 col;\n    // my e value made black artifacts\n    // so I took a look at iq's normal epsilone. \n    // don't exactly know how this is calculated.\n    // looks like it is relevant to some screen pixel size calculation..?\n    vec2 e = vec2(1.0,-1.0)*0.5773*0.25*2.0/(iResolution.y*1.5);\n    \n    // getting vector with very small vector\n    vec3 n = vec3(\n        e.xyy*mandel3(p+e.xyy, col)+\n        e.yxy*mandel3(p+e.yxy, col)+\n        e.yyx*mandel3(p+e.yyx, col)+\n        e.xxx*mandel3(p + e.xxx,col ) \n    );\n    \n    return normalize(n);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord.xy-.5*iResolution.xy)/(iResolution.y);\n    vec2 m = iMouse.xy/iResolution.xy;\n    vec3 col = vec3(0);\n    \n    vec3 ro = vec3(0,1.3, 1.3);\n    vec3 rd = R(uv, ro, vec3(0,0,0), .7);\n    \n    vec3 backgrounduv;\n    \n    col = vec3(.05, .12, .1);\n    float d = RayMarch(ro, rd, backgrounduv);\n    //col += vec3(2.1-d);\n    col += pow(clamp(backgrounduv.z, 0., .97), 1.)*vec3(.8, .6, .1);\n    col *= 1.7;\n    \n    //light\n    vec3 lp = vec3(1, 1, 0);\n    //lp.xz *= Rot(iTime/3.);\n    lp.yz *= Rot(iTime/3.);\n    vec3 lr = ro+rd*d;\n    lr.xz *= Rot(iTime/SPEED);\n    lr.yz *= Rot(iTime/SPEED-2.);\n    lr = abs(lr);\n    vec3 l = normalize(lp - lr);\n    vec3 n = GetNormal(lr);\n    float shadow = clamp(dot(n, l), 0.2, .99);\n    shadow *= .98;\n    col *= vec3(pow(shadow, 2.));\n    col += vec3(.09, .04, .09);\n    \n    fragColor = vec4(col, 0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wlVyDy.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[104, 104, 131, 131, 211], [213, 230, 269, 269, 1100], [1102, 1102, 1121, 1121, 1197], [1199, 1199, 1241, 1241, 1437], [1439, 1439, 1492, 1492, 1821], [1822, 1822, 1845, 1845, 2395], [2397, 2397, 2454, 2454, 3320]]}
{"id": "WlVyR3", "name": "Ray-Parabola Intersection (2D)", "author": "oneshade", "description": "Ray intersector for a 2D parabola.", "tags": ["2d", "raytracing", "ray", "quadratic", "intersect", "parabola"], "likes": 3, "viewed": 70, "published": "Public", "date": "1611437157", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec3 IntersectParabola2D(in vec2 ro, in vec2 rd, in float a, in float b, in float c) {\n    float ra = a * rd.x * rd.x;\n    float rb = 2.0 * a * ro.x * rd.x + b * rd.x - rd.y;\n    float rc = a * ro.x * ro.x + b * ro.x + c - ro.y;\n\n    vec3 intersect = vec3(0.0);\n\n    // If the discriminant is less than zero there are no (real) roots\n    float discr = rb * rb - 4.0 * ra * rc;\n    if (discr > 0.0) {\n        float root = sqrt(discr);\n        float denom = 2.0 * ra;\n        float t1 =  (root - rb) / denom; // 1st root\n        float t2 = -(rb + root) / denom; // 2nd root\n        intersect = vec3(t1, t2, 1.0);\n    }\n\n    return intersect;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y * 4.0;\n    float unit = 8.0 / iResolution.y;\n    float time = iTime * 0.25;\n    vec3 color = vec3(0.0);\n\n    float a = sin(time);\n    float b = cos(time);\n    float c = sin(time * 2.0);\n\n    // Draw the parabola\n    float g = 2.0 * a * uv.x + b; // Derivative for DE\n    float f = a * uv.x * uv.x + b * uv.x + c;\n    color += smoothstep(unit, 0.0, abs(uv.y - f) / sqrt(1.0 + g * g));\n\n    // Ray origin (ro) and ray direction (rd)\n    vec2 ro = vec2(cos(time * 0.75) * 2.0, sin(time * 1.5));\n    vec2 rd = sin(sin(time * 0.25) * 3.14 + vec2(1.57, 0.0));\n\n    // Draw the ray\n    color += smoothstep(unit, 0.0, length(uv - ro) - 0.1);\n    color += smoothstep(unit, 0.0, abs(dot(uv - ro, rd.yx * vec2(-1.0, 1.0))));\n\n    // Draw the intersections:\n    vec3 intersect = IntersectParabola2D(ro, rd, a, b, c);\n    if (intersect.z > 0.5) {\n        color += smoothstep(unit, 0.0, length(uv - ro - rd * intersect.x) - 0.05);\n        color += smoothstep(unit, 0.0, length(uv - ro - rd * intersect.y) - 0.05);\n    }\n\n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WlVyR3.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 86, 86, 641], [643, 643, 698, 698, 1806]]}
{"id": "wlVyWd", "name": "boolean", "author": "kithy", "description": "boolean,OR,repetition", "tags": ["repetition", "boolean", "or"], "likes": 1, "viewed": 35, "published": "Public", "date": "1612017242", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\nvec3 lightDir=vec3(-0.57,0.57,0.57);\n\n\n\nfloat distFuncCube(vec3 p){\n\tvec3 q=abs(p);\n\treturn length(max(q-vec3(1.0,0.1,0.5),0.0));\n}\n\nfloat distFuncSphere(vec3 p){\n\tfloat s=0.5;\n\treturn length(p)-s;\n}\n\nfloat distFunc(vec3 p){\n\tp=mod(p,0.8)-0.4;\n\tfloat d3=distFuncCube(p);\n\tfloat d4=distFuncSphere(p);\n\n\treturn min(d3,d4);//OR\n\n}\n\n\nvec3 genNormal(vec3 p){\n\tfloat d=0.0001;\n\treturn normalize(vec3(\n\t\tdistFunc(p+vec3(d,0.0,0.0))-distFunc(p+vec3(-d,0.0,0.0)),\n\t\tdistFunc(p+vec3(0.0,d,0.0))-distFunc(p+vec3(0.0,-d,0.0)),\n\t\tdistFunc(p+vec3(0.0,0.0,d))-distFunc(p+vec3(0.0,0.0,-d))\n\t\t));\n}\n\n\nvoid mainImage(out vec4 fragColor,in vec2 fragCoord){\n\tvec2 p=(2.0*fragCoord.xy-iResolution.xy)/iResolution.y;\n\n\n\tvec3 cPos=vec3(sin(iTime)*0.6,0.5,iTime*0.3);\n\tvec3 cDir=vec3(0.0,0.0,-1.0);\n\tvec3 cUp=vec3(0.0,1.0,0.0);\n\tvec3 cSide=cross(cDir,cUp);\n\tfloat targetDepth=1.0;\n\n\tvec3 ray=normalize(cSide*p.x+cUp*p.y+cDir*targetDepth);\n\n\tfloat tmp,dist;\n\ttmp=0.0;\n\tvec3 dPos=cPos;\n\n\tfloat emission=0.0;\n\n\tfor(int i=0;i<48;i++){\n\t\tdist=distFunc(dPos);\n\t\ttmp+=dist;\n\t\tdPos=cPos+tmp*ray;\n\t\temission+=exp(abs(dist)*-0.2);\n\t}\n\n\tvec3 color;\n\n\tif(abs(dist)<0.001){\n\t\tvec3 normal=genNormal(dPos);\n\t\tfloat diff=clamp(dot(lightDir,normal),0.1,1.0);\n\t\tcolor=0.02*emission*vec3(sin(iTime),1.0,cos(iTime))*diff;\n\t}else{\n\t\tcolor=vec3(0.0);\n\t}\n\tfragColor=vec4(color,1.0);\n}\n\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wlVyWd.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[41, 41, 68, 68, 132], [134, 134, 163, 163, 200], [202, 202, 225, 225, 328], [331, 331, 354, 354, 582], [585, 585, 638, 638, 1338]]}
{"id": "WlVyWR", "name": "Take a breath :)", "author": "kw", "description": "Experimenting with colors and shapes.", "tags": ["2dcat"], "likes": 9, "viewed": 85, "published": "Public", "date": "1610833662", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n//cat enjoying the moon :)\n\nvec3 Sky(in vec2 uv)\n{\n    return vec3(mix(vec3(0.6,0.2,0.5),vec3(0.2,0.2,0.4),uv.y * 1.2));\n}\n\nvec3 Moon(in vec2 pos)\n{\n    vec3 moon = vec3(0.0);\n    if (1.0 - smoothstep(0.0,0.1,length(pos) - 0.2) > 0.0){\n        moon = vec3(0.8,0.2- abs((pos.x / 2.0) + 0.1),0.4 * pos.y);\n    }\n    return moon;\n}\n\nfloat CatBody(in vec2 pos)\n{\n    float sd = 1.0 - smoothstep(0.0,0.1,length(pos) - 0.1);\n    sd += 1.0 - smoothstep(0.0,0.1,length(pos + vec2(0.0,0.2)) - 0.16);\n    sd += 1.0 - smoothstep(0.0,0.1,length(pos + vec2(-0.06,0.4)) - 0.2);\n    sd += 1.0 - smoothstep(0.0,0.1,length(pos + vec2(0.0,0.4)) - 0.18);\n    sd += 1.0 - smoothstep(0.0,0.1,length(pos + vec2(0.08,0.6)) - 0.05);\n    sd += 1.0 - smoothstep(0.0,0.1,length(pos + vec2(-0.2,0.6)) - 0.05);\n    return sd;\n}\n\nfloat CatEars(in vec2 pos)//Simple Egg - exact: https://www.shadertoy.com/view/XtVfRW\n{\n    float sd = 0.0;\n    float ear = 0.0;\n    float ra = 0.04;\n    float rb = 0.01;\n    const float k = sqrt(3.0);\n    vec2 p = pos;\n    float r = ra - rb;\n    p -= vec2(-0.08,-0.02);\n    p.x = abs(p.x);\n    ear = ((p.y < 0.0) ? length(vec2(p.x,p.y)) - r:\n    (k * (p.x + r) < p.y) ? length(vec2(p.x,p.y - k * r)):\n    length(vec2(p.x + r,p.y)) - 2.0 * r) - rb;\n    sd = 1.0 - smoothstep(0.0,0.001,ear) - 0.1;\n    p = pos;\n    p += vec2(-0.08,0.02);\n    p.x = abs(p.x);\n    ear = ((p.y < 0.0) ? length(vec2(p.x,p.y)) - r:\n    (k * (p.x + r) < p.y) ? length(vec2(p.x,p.y - k * r)):\n    length(vec2(p.x + r,p.y)) - 2.0 * r) - rb;\n    sd +=  1.0 - smoothstep(0.0,0.001,ear) - 0.1;\n    return sd;\n}\n\n\nfloat CatTail(in vec2 pos,in vec2 sca,in vec2 scb,in float ra,in float rb)//Arc - exact: https://www.shadertoy.com/view/wl23RK\n{\n    pos *= mat2(sca.x,sca.y,-sca.y,sca.x);\n    pos.x = abs(pos.x);\n    float k = (scb.y * pos.x > scb.x * pos.y) ? dot(pos.xy,scb):length(pos);\n    float sd = sqrt(dot(pos,pos) + ra * ra - 2.0 * ra * k) - rb;\n    return 1.0 - smoothstep(0.0,0.01,sd);\n}\n\nvec3 Cat(in vec2 pos)\n{\n    vec3 cat = vec3(0.0);\n    float sd = CatBody(pos - vec2(0.0,0.0 + (0.1 * cos(iTime) / 10.0 + 0.01)));\n    sd += CatEars(pos - vec2(0.0,0.18 + (0.1 * cos(iTime) / 10.0 + 0.01))) + (0.1 * sin(iTime * pos.y) / 10.0);\n    float ta = 4.00 * (0.1 * cos(iTime) / 4.0 - 0.5);\n    float tb = 1.80;\n    float rb = 0.04 + (0.01 * cos(iTime * pos.x) / 10.0 + 0.01);\n    sd += CatTail(pos - vec2(0.4,-0.4),vec2(sin(ta),cos(ta)),vec2(sin(tb),cos(tb)),0.2 + (0.1 * sin(iTime + pos.x) / 10.0),rb);\n    if (sd > 0.1){\n        cat = vec3(0.2 - ((pos.y - 0.1) * 2.4 + abs((pos.y + 0.2) - (pos.x + 0.3))),0.4 - ((pos.y * 1.2) - 0.2) - abs((pos.x / 2.0) + 0.2),0.3);\n        cat -= vec3(0.5,0.3,0.2);\n    }\n    return cat;\n}\n\n\nvec2 Screen(in vec2 pix,in vec3 res)\n{\n    return vec2((2.0 * pix - res.xy) / res.y);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = Screen(fragCoord,iResolution);\n    vec3 sky = Sky(uv);\n    vec3 moon = Moon(uv - vec2(0.70,0.5)); \n    vec3 cat = Cat(uv - vec2(-0.70,-0.4));\n    fragColor = vec4(sky + moon - cat,1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WlVyWR.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 29, 51, 51, 123], [125, 125, 149, 149, 329], [331, 331, 359, 359, 799], [801, 801, 888, 888, 1582], [1585, 1585, 1713, 1713, 1966], [1968, 1968, 1991, 1991, 2699], [2702, 2702, 2740, 2740, 2789], [2791, 2791, 2848, 2848, 3050]]}
{"id": "WlVyz3", "name": "Ray-Paraboloid Intersection (3D)", "author": "oneshade", "description": "Ray intersector for a 3D paraboloid.", "tags": ["raytracing", "ray", "intersection", "quadratic", "paraboloid"], "likes": 4, "viewed": 75, "published": "Public", "date": "1611443350", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/*\nI'm getting into ray intersectors now :)\nI'm currently working on an intersector for a trilinear surface and am down to a cubic!\n*/\n\n// Ray intersector for 3D paraboloid in the form: x^2/a^2 + z^2/b^2 - y = 0\nvec3 IntersectParaboloid3D(in vec3 ro, in vec3 rd, in float a, in float b) {\n    float invSqrA = 1.0 / (a * a);\n    float invSqrB = 1.0 / (b * b);\n\n    float ra = invSqrA * rd.x * rd.x + invSqrB * rd.z * rd.z;\n    float rb = invSqrA * 2.0 * ro.x * rd.x + invSqrB * 2.0 * ro.z * rd.z - rd.y;\n    float rc = invSqrA * ro.x * ro.x + invSqrB * ro.z * ro.z - ro.y;\n\n    vec3 intersect = vec3(0.0);\n\n    // If the discriminant is less than zero there are no (real) solutions\n    float discr = rb * rb - 4.0 * ra * rc;\n    if (discr > 0.0) {\n        float root = sqrt(discr);\n        float denom = 2.0 * ra;\n        float t1 =  (root - rb) / denom; // 1st root\n        float t2 = -(rb + root) / denom; // 2nd root\n        intersect = vec3(t1, t2, 1.0);\n    }\n\n    return intersect;\n}\n\nvec3 getParaboloidNormal3D(in vec3 p, in float a, in float b) {\n    float dx = 2.0 / (a * a) * p.x;\n    float dz = 2.0 / (b * b) * p.z;\n    return vec3(dx, -1.0, dz) / sqrt(dx * dx + dz * dz + 1.0);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 screenCenter = 0.5 * iResolution.xy;\n\n    vec2 mouse = vec2(0.0, 0.0);\n    if (iMouse.z > 0.0) {\n        mouse = (iMouse.xy - screenCenter) / iResolution.y * 3.14;\n    }\n\n    vec2 uv = (fragCoord - screenCenter) / iResolution.y;\n    fragColor = vec4(0.0, 0.0, 0.0, 1.0);\n\n    vec3 ro = vec3(0.0, 3.0, 10.0);\n    vec3 rd = normalize(vec3(uv, -1.0));\n\n    float cy = cos(mouse.x), sy = sin(mouse.x);\n    float cp = cos(mouse.y), sp = sin(mouse.y);\n    ro.yz *= mat2(cp, -sp, sp, cp);\n    ro.xz *= mat2(cy, -sy, sy, cy);\n    rd.yz *= mat2(cp, -sp, sp, cp);\n    rd.xz *= mat2(cy, -sy, sy, cy);\n\n    float a = 2.25 + 2.0 * sin(iTime);\n    float b = 2.25 + 2.0 * cos(iTime);\n    vec3 intersect = IntersectParaboloid3D(ro, rd, a, b);\n    if (intersect.z > 0.5) {\n        vec3 n = getParaboloidNormal3D(ro + rd * min(intersect.x, intersect.y), a, b);\n        vec3 l = normalize(vec3(-1.0, -1.0, 1.0));\n\n        l.yz *= mat2(cp, -sp, sp, cp);\n        l.xz *= mat2(cy, -sy, sy, cy);\n\n        float lambertian = max(0.0, dot(n, l));\n        fragColor.r += lambertian;\n        if (lambertian > 0.0) {\n            fragColor.rgb += max(0.0, pow(max(0.0, dot(reflect(l, n), rd)), 32.0));\n        }\n    }\n\n    else {\n        fragColor.rgb += mix(vec3(0.25, 0.25, 1.0), vec3(1.0), 0.5 + 0.5 * rd.y);\n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WlVyz3.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[136, 212, 288, 288, 988], [990, 990, 1053, 1053, 1190], [1192, 1192, 1247, 1247, 2547]]}
{"id": "WlVyzm", "name": "Basic raymarching scroller", "author": "seven_dc", "description": "testing modulating the space and moving the camera.", "tags": ["raymarch", "blur", "distance"], "likes": 0, "viewed": 61, "published": "Public", "date": "1610715474", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define MAX_STEPS 25\n#define MAX_DIST 150.\n#define SURF_DIST .01\n\nfloat GetDistance(vec3 point) {\n\tvec4 sphere = vec4(2, 2, 2, 1);\n    // modulate the point by 4.\n    vec3 spoint = mod(point, 4.);\n    \n    float sphereDist = length(spoint-sphere.xyz)-sphere.w;    \n    float planeDist = point.y;\n    \n    float d = min(sphereDist, planeDist);\n    return d;\n}\n\nfloat RayMarch(vec3 rayOrgin, vec3 rayDirection) {\n\tfloat distance=0.;\n    \n    for(int i=0; i<(MAX_STEPS-int(sin(iTime*2.)*10.)); i++) {\n    \tvec3 point = rayOrgin + rayDirection * distance;\n        float surfaceDistance = GetDistance(point);\n        distance += surfaceDistance;\n        if(distance>MAX_DIST || surfaceDistance<SURF_DIST) break;\n    }\n    \n    return distance;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // put 0,0 in the center\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n       \n    // camera   \n    vec3 rayOrgin = vec3(0, 3.+sin(iTime)*2., mod(iTime,4.));\n    vec3 rayDirection = normalize(vec3(uv.x, uv.y, 1));\n\n    float d = RayMarch(rayOrgin, rayDirection);   \n    \n    // color\n    vec3 col = vec3(1.-(d/20.));            \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WlVyzm.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[66, 66, 97, 97, 358], [360, 360, 410, 410, 740], [742, 742, 799, 828, 1178]]}
{"id": "WlVyzR", "name": "shader_practice_1", "author": "changwenhan", "description": "Making by following this tutorial of The Art of Code:\nhttps://www.youtube.com/watch?v=cQXAbndD5CQ", "tags": ["gif"], "likes": 2, "viewed": 86, "published": "Public", "date": "1610348035", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // -1~1\n    vec2 uv = (fragCoord-0.5*iResolution.xy)/iResolution.y;\n    vec2 c_uv = uv;\n    \n    //float radian = 0.785;\n    float radian = fract(iTime*.01) * 3.1415926 * 2.;\n    float s = sin(radian);\n    float c = cos(radian);\n    mat2 rotate = mat2(c, -s, s, c);\n    uv *= rotate;\n    \n    // 5~25\n    float zoom = 5. + (sin(iTime*.1)+1.)*10.;\n    \n    uv *= zoom;\n    uv += .5;\n\n    vec2 gv = fract(uv) - 0.5;\n    vec2 id = floor(uv);\n    \n    vec3 pixelColor = vec3(0.0);\n    \n    \n    float gridLine = step(0.48, gv.x) + step(0.48, gv.y);\n    \n    float circle = 0.;\n    \n    float aniSpeed = 1.;\n    float waveSpeed = .3;\n    \n    for(int i=-2;i<3;i++) {\n        for(int j=-2;j<3;j++) {\n            vec2 offs = vec2(j,i);\n            vec2 nowId = id+offs;\n            \n            float wave = (sin(-iTime*aniSpeed+length(nowId)*waveSpeed)+1.)/2.; // 0~1;\n            float cRadius = .2 + wave*1.5; // 0.2~1.7;\n            \n            float isWhite = (1. - step(cRadius, length(gv-offs)));\n            \n            // XOR\n            circle = circle + isWhite - 2.*circle*isWhite;\n        }\n    }\n\n    //pixelColor += circle;\n    \n    vec3 backColor = vec3(.1);\n    vec3 circleColor = vec3(.5-c_uv.x,.5,.5-c_uv.y) + vec3(1.-length(c_uv),0.,0.);\n    pixelColor += backColor * (1. - circle) + circleColor * circle;\n    \n    \n    //pixelColor += gridLine;\n    \n    // Output to screen\n    fragColor = vec4(pixelColor, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WlVyzR.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 69, 1492]]}
{"id": "WlVyzt", "name": "the puzzle", "author": "YitingLiu", "description": "Creating the puzzle that changes shapes and colors and line thickness based on time. ", "tags": ["noise", "line", "texture", "sin", "gradient", "rotate", "cos", "fract", "abs", "position", "puzzle", "tan"], "likes": 0, "viewed": 161, "published": "Public API", "date": "1611587829", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// wood texture and moving colors \n\n#define PI 3.141592653\n\nfloat random (in vec2 st) {\n    return fract(sin(dot(st.xy,\n                         vec2(12.9898,78.233)))\n                * 43758.5453123);\n}\n\n// Value noise by Inigo Quilez - iq/2013\n// https://www.shadertoy.com/view/lsf3WH\nfloat noise(vec2 st) {\n    vec2 i = floor(st);\n    vec2 f = fract(st);\n    vec2 u = f*f*(3.0-2.0*f);\n    return mix( mix( random( i + vec2(0.0,0.0) ),\n                     random( i + vec2(1.0,0.0) ), u.x),\n                mix( random( i + vec2(0.0,1.0) ),\n                     random( i + vec2(1.0,1.0) ), u.x), u.y);\n}\n\nmat2 rotate2d(float angle){\n    return mat2(cos(angle),-sin(angle),\n                sin(angle),cos(angle));\n}\n\nfloat lines(in vec2 pos, float b){\n    float scale = 10.0;\n    pos *= scale;\n    return smoothstep(0.0,\n                    .5+b*.5,\n                    abs((sin(pos.x*3.1415)+b*2.0))*.5);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 st = fragCoord.xy/iResolution.xy;\n    st.y *= iResolution.y/iResolution.x;\n\n    vec2 pos = st.yx*vec2(10.,7.);\n\n    float pattern = pos.x*sin(iTime)*10.;\n\n    // Add noise\n    pos = rotate2d( noise(pos)*PI*PI*sin(iTime)) * pos;\n    pos /=  abs(tan(iTime))*PI*0.5;\n    pos +=  cos(iTime)*PI*0.1;\n    \n    pos.x+=(abs(sin(iTime)))*10.;\n\n    // Draw lines\n    pattern = lines(pos,0.2+cos(iTime));\n\n    fragColor = vec4(vec3(pattern)/vec3(st.y,st.x+pos.x,pos.y)*fract(abs(tan(iTime))/2.5),1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WlVyzt.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 60, 87, 87, 203], [205, 287, 309, 309, 607], [609, 609, 636, 636, 718], [720, 720, 754, 754, 910], [912, 912, 969, 969, 1471]]}
{"id": "wlycD1", "name": "First steps...", "author": "kw", "description": "Now experimenting in 3d :D", "tags": ["3d"], "likes": 2, "viewed": 51, "published": "Public", "date": "1611080910", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n//first (raymarching) steps... \n\n//distance functions 3d: https://www.iquilezles.org/www/articles/distfunctions/distfunctions.htm\n//distance functions 2d: https://www.iquilezles.org/www/articles/distfunctions2d/distfunctions2d.htm\n//fog function: https://www.iquilezles.org/www/articles/fog/fog.htm\n//BigWIngs tutorial series helped me a lot: https://youtu.be/PGtv-dBi2wE\n//thanks iq & BigWIngs :)\n\nmat2 Rotate(float a) \n{\n    float s = sin(a);\n    float c = cos(a);\n    return mat2(c,-s,s,c);\n}\n\nfloat sdTriangle(in vec2 pos,in float size,in int rotate)//2d\n{\n    if(rotate > 0) pos *= Rotate(3.1415926535897931);\n    const float k = sqrt(3.0);\n    pos.x = abs(pos.x) - size;\n    pos.y = pos.y + size / k;\n    if(pos.x + k * pos.y > 0.0) pos = vec2(pos.x -k * pos.y,-k * pos.x - pos.y) / 2.0;\n    pos.x -= clamp(pos.x,-2.0 * size,0.0);\n    return -length(pos) * sign(pos.y);\n}\n\nvec4 sdSphere(in vec3 pos,in float size,in vec3 color)\n{\n    float sd = length(pos) - size;\n    return vec4(color,sd);\n}\n\nvec4 sdCapsule(in vec3 pos,in vec3 a,in vec3 b,in float size,in vec3 color)\n{\n    vec3 pa = pos - a;\n    vec3 ba = b - a;\n    float h = clamp(dot(pa,ba) / dot(ba,ba),0.0,1.0);\n    return vec4(color,length(pa - ba * h) - size);\n}\n\nfloat Union(in float d1,in float d2,in float k)\n{\n    float h = clamp(0.5 + 0.5 * (d2 - d1) / k,0.0,1.0);\n    return mix(d2,d1,h) - k * h * (1.0 - h);\n}\n\nvec4 Depth(in vec4 a,in vec4 b)\n{\n    if (a.w < b.w){return a;}else {return b;}\n}\n\nvec4 Map(in vec3 ray)\n{\n    vec4 map;\n    vec4 obj;\n    ray.xz *= Rotate(iTime / 10.0);\n    ray.y -= iTime * 10.0;\n    ray.y = mod(ray.y + 0.5 * 4.0,4.0) - 0.5 * 4.0;\n    float fx = 0.2 + max(abs(cos(iTime * 4.0)),0.4);//+ abs(ray.y)\n    vec3 size = vec3(2.0,4.0,0.05 * fx);\n    vec3 c1 = vec3(0.5 * (abs(ray.y) - 0.3),0.2,0.1);\n    vec3 c2 = vec3(0.5 * (ray.y - 0.8),0.2,0.1);\n    vec3 c3 = vec3(0.5 * (0.4 - ray.y - 0.8),0.2,0.1);\n    float u;\n    ray.xz = mod(ray.xz + 0.5 * 15.0,15.0) - 0.5 * 15.0;\n    map = sdCapsule(ray,vec3(0.0,-size.y,0.0),vec3(0.0,size.y,0.0),0.2 * (abs(ray.y) / 4.0),c1);\n    obj = sdSphere(ray,0.2 + max(abs(cos(iTime * 2.0)),0.1),c1);\n    u = Union(map.w,obj.w,1.0);\n    map = Depth(map,obj); \n    map.w = u;\n    obj = sdCapsule(ray,vec3(-size.x,0.0,0.0),vec3(0.0,size.y * fx,0.0),size.z,c2);     \n    map = Depth(map,obj);\n    obj = sdCapsule(ray,vec3(size.x,0.0,0.0),vec3(0.0,size.y * fx,0.0),size.z,c2);   \n    map = Depth(map,obj);\n    obj = sdCapsule(ray,vec3(0.0,0.0,size.x),vec3(0.0,size.y * fx,0.0),size.z,c2);     \n    map = Depth(map,obj);\n    obj = sdCapsule(ray,vec3(0.0,0.0,-size.x),vec3(0.0,size.y * fx,0.0),size.z,c2);   \n    map = Depth(map,obj);\n    obj = sdCapsule(ray,vec3(-size.x,0.0,0.0),vec3(0.0,-size.y * fx,0.0),size.z,c3);     \n    map = Depth(map,obj);\n    obj = sdCapsule(ray,vec3(size.x,0.0,0.0),vec3(0.0,-size.y * fx,0.0),size.z,c3);   \n    map = Depth(map,obj);\n    obj = sdCapsule(ray,vec3(0.0,0.0,size.x),vec3(0.0,-size.y * fx,0.0),size.z,c3);     \n    map = Depth(map,obj);\n    obj = sdCapsule(ray,vec3(0.0,0.0,-size.x),vec3(0.0,-size.y * fx,0.0),size.z,c3);   \n    map = Depth(map,obj);\n    return map;\n}\n\nvec4 Raymarch(in vec3 ro,in vec3 rd,in int steps,in float min,in float max)\n{\n    float sd = 0.0;\n    vec4 obj = vec4(0.0);\n    for(int step = 0;step < steps;step ++) \n    {\n        obj = Map(ro + rd * sd);\n        sd += obj.w;\n        if (sd > max || obj.w < min) break;  \n    }\n    obj.w = sd;\n    return obj;\n}\n\nvec3 Fog(in vec3 rgb,in vec3 color,in float density,in float distance)\n{\n    float exp = 1.0 - exp(-distance * density);\n    return mix(rgb,color,exp);\n}\n\nvec4 Stamp(in vec2 pos,in float size,in vec3 color, in float factor,in int rotate)//2d\n{\n    float sd1 = sdTriangle(pos,size,rotate);\n    float sd2 = sdTriangle(pos,size / 1.8,rotate);\n    float sd = max(sd1,-sd2);\n    sd = smoothstep(factor,-(3.0 / iResolution.y),sd);//;)\n    return vec4(color,sd);\n}\n\nvec3 Draw(in vec3 color,in vec4 obj)//2d\n{\n    return mix(color,obj.rgb,obj.a);\n}\n\nvec3 Camera(in vec2 uv,in vec3 origin,in vec3 lookat,in float fov)\n{\n    vec3 cz = normalize(lookat - origin);\n    vec3 cx = normalize(cross(vec3(0.0,1.0,0.0),cz));\n    vec3 cy = normalize(cross(cz,cx)); \n    return normalize((cx * uv.x) + (cy * uv.y) + (cz * fov));\n}\n\nvec2 Screen(in vec2 pix,in vec3 res)\n{\n    return vec2((pix - (0.5 * iResolution.xy)) / iResolution.y);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = Screen(fragCoord,iResolution);\n    vec3 ro = vec3(6.0,0.0,-42.0);\n    ro.xz *= Rotate(-iTime / 20.0);\n    ro.xy *= Rotate(iTime / 10.0);\n    vec3 at = vec3(0.0,0.0,0.0);\n    vec3 rd = Camera(uv,ro,at,1.0);\n    vec4 obj = Raymarch(ro,rd,100,0.005,100.0);\n    vec3 color = vec3(0.6 * uv.y,0.4 * (uv.y + 0.4),0.1);\n    if (obj.w <= 100.0){color = obj.rgb - (obj.w / 120.0) + (uv.y / 10.0);}\n    color = Fog(color,vec3(0.1 / (obj.w / 40.0)),0.056,obj.w);\n    vec3 tri_color = color * 1.8;\n    tri_color.g *= 1.8;\n    vec4 tri = Stamp(uv - vec2(0.0,0.12),0.2,tri_color,0.001,0);\n    color = Draw(color,tri);\n    tri_color = color * 1.8;\n    tri_color.b *= 1.8;\n    tri = Stamp(uv - vec2(0.0,-0.12),0.2,tri_color,0.001,1);\n    color = Draw(color,tri);\n    fragColor = vec4(color,1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wlycD1.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[34, 400, 423, 423, 496], [498, 498, 561, 561, 878], [880, 880, 936, 936, 1000], [1002, 1002, 1079, 1079, 1230], [1232, 1232, 1281, 1281, 1384], [1386, 1386, 1419, 1419, 1467], [1469, 1469, 1492, 1492, 3137], [3139, 3139, 3216, 3216, 3452], [3454, 3454, 3526, 3526, 3607], [3609, 3609, 3697, 3697, 3911], [3913, 3913, 3955, 3955, 3994], [3996, 3996, 4064, 4064, 4264], [4266, 4266, 4304, 4304, 4371], [4373, 4373, 4430, 4430, 5225]]}
{"id": "WlycDW", "name": "Beer Label #3 Black Field", "author": "alkova06", "description": "3rd label for my beer.\nImperial Stout - Чорне Поле\n10.4 ABV 50 IBUs OG. 1.097", "tags": ["2d", "field", "picture"], "likes": 2, "viewed": 47, "published": "Public", "date": "1611064118", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float Step(float val, float edge)\n{\n    return min(max(val * 2.0 - 1.0 + edge, 0.0) * 10000.0, 1.0);\n}\n\nvec2 Rotate(vec2 val, float angle)\n{\n    float x = cos(angle) * val.x - sin(angle) * val.y;\n    float y = sin(angle) * val.x + cos(angle) * val.y;\n    return vec2(x, y);\n}\nfloat LevelRange(float val, float minInput, float maxInput, float gamma)\n{\n    return pow(min(max(val - minInput, 0.0) / (maxInput - minInput), 1.0), 1.0 / gamma);\n}\n\nfloat PerlinNoise(vec2 uv)\n{\n    vec2 uvNoise = uv * 0.1;\n    float noise = texture(iChannel1, uvNoise).r;    \n    noise += texture(iChannel1, uvNoise * 2.0).r * 0.5;\n    noise += texture(iChannel1, uvNoise * 4.0).r * 0.25;\n    noise += texture(iChannel1, uvNoise * 8.0).r * 0.125;\n    noise += texture(iChannel1, uvNoise * 16.0).r * 0.0675;\n    noise *= 0.5;\n    return noise;\n}\n\nfloat Plot(vec2 st, float pct, float width)\n{\n  return  smoothstep( pct - width, pct, st.y) -\n          smoothstep( pct, pct + width, st.y);\n}\n\nfloat Rand(vec2 co)\n{\n    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nfloat WheatMask(vec2 uv, float scale, float wind, float density)\n{\n    float wheatScale = scale * (floor(uv.y * scale) + 1.0);\n    vec2 wheatUV0 = fract((1.0 - uv) * wheatScale);\n    wheatUV0.xy = vec2(wheatUV0.y, 1.0 - wheatUV0.x);\n    float mask = clamp((Rand(floor(uv * wheatScale)) - density) * 100.0, 0.0, 1.0);\n    \n    mask *= Plot(wheatUV0, mix(1.0, pow(cos((1.0 - wheatUV0.x) * 1.57), 1.5), wind), 0.3);\n     \n    vec2 ceilUV = abs(wheatUV0 * 2.0 - 1.0);\n    float ceilMask = max(ceilUV.x, ceilUV.y);\n    ceilMask = pow(ceilMask, 2.0);\n    ceilMask = 1.0 - max(ceilMask, pow(length(ceilUV * 0.8), 2.0));\n    mask *= ceilMask;\n    mask *= 16.0;\n    mask = clamp(mask, 0.0, 1.0);\n    \n    return mask;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{    \n    float sinTime = sin(iTime);\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 uv1 = fragCoord/iResolution.yy;    \n    float wind = abs(sin(iTime + uv.y * 0.5 + uv.x * 10.0 * (uv.y + 0.4))) * 0.3 + 0.7;\n    \n    float noise = PerlinNoise(uv1 * 0.1);\n    \n    float noise2 = PerlinNoise(uv1 + vec2(0.5, 0.0));    \n    noise2 = pow(noise2, 2.0);\n    noise2 = LevelRange(1.0 - noise2, 0.1, 0.9, 0.1);    \n     \n    float noise3 = PerlinNoise(uv * vec2(0.4, 2.0 * uv.y + 0.5));    \n    noise3 = pow(noise3, 2.0);\n    noise3 = clamp(LevelRange(1.0 - noise3, 0.1, 0.9, 0.2), 0.0, 1.0);\n    \n    float noise4 = PerlinNoise(uv1 * vec2(16.0));    \n    noise4 = pow(noise4, 2.0);\n    noise4 = LevelRange(1.0 - noise4, 0.3, 0.9, 0.1);    \n    \n     \n    float blackFillMask = clamp(iTime - 2.0 + (uv.y - 1.0) * 10.0, 0.0, 1.0);\n    blackFillMask = pow(blackFillMask * noise2 + blackFillMask, 4.0);\n    blackFillMask = clamp(blackFillMask, 0.0, 1.0);\n     \n    vec3 skyColor0 = vec3(0.63, 0.71, 0.53);\n    vec3 skyColor1 = vec3(0.44, 0.6, 0.65);\n    vec3 skyColor2 = vec3(0.37, 0.37, 0.49);\n    vec3 sunColor =  vec3(0.905, 0.82, 0.26);\n    \n    vec3 groundColor = mix(vec3(0.93, 0.675, 0.325), vec3(0.93, 0.675, 0.325) * 0.2, blackFillMask);\n    vec3 fieldColor = mix(vec3(1.0, 0.94, 0.23), vec3(1.0, 0.94, 0.23) * 0.2, blackFillMask);\n    vec3 wheatColor0 = mix(vec3(0.87, 0.63, 0.145), vec3(0.87, 0.63, 0.145) * 0.2, blackFillMask);\n    vec3 wheatColor1 = mix(vec3(0.67, 0.325, 0.18), vec3(0.67, 0.325, 0.18) * 0.2, blackFillMask);\n         \n    float mask = 1.0;\n    vec3 skyColor = mix(skyColor0, skyColor1, (length(uv1.xy - vec2(1.0, 0.4)) - 0.2) * noise + pow(noise2, 2.0) * 0.125);\n    mask = min(max((length(uv1.xy - vec2(1.0, 0.4)) - 0.8) * 5.0, 0.0), 1.0);\n    skyColor = mix(skyColor, skyColor2,  mask * (noise + 0.1) + mask * pow((1.0 - noise2), 16.0) * 0.2);\n    \n    mask = min((length(uv1.xy - vec2(1.0, 0.55)) - 0.1) * mix(8.0, 10.0, abs(sinTime)), 1.0);\n    skyColor = mix(sunColor, skyColor, mask +  (1.0 - mask) * pow(noise2, 16.0) * 0.12);   \n       \n    mask = min(max(uv.y * 2.0 - 0.8 + sin(uv.x * 3.14 + 0.8) * 0.05, 0.0) * 10.0, 1.0);\n    groundColor = mix(fieldColor, groundColor, mask + noise2 * 0.025 + noise3);\n   \n    float wheatNoise = clamp(noise4 + 0.8, 0.0, 1.0);\n    vec2 uvWheat = uv1;\n    for(int i = 0; i < 15; i++)\n    {\n        uvWheat = fract(uvWheat + vec2(0.0425 * float(i), 0.001 *  float(i)));\n        mask = WheatMask(uvWheat, 10.0, wind, 0.85) * (1.0 - uv.y * 2.0) * (noise2 + 0.5);\n        groundColor = mix(groundColor, wheatColor0, mask * wheatNoise);\n    }\n    \n    uvWheat = uv1;\n    for(int i = 0; i < 15; i++)\n    {\n        uvWheat = fract(uvWheat + vec2(0.37 * float(i), 0.01));\n        mask = WheatMask(uvWheat, 10.0, wind, 0.95) * (1.0 - uv.y * 2.0) * (noise2 + 0.5);\n        groundColor = mix(groundColor, wheatColor1, mask * wheatNoise);\n    }\n    \n    uvWheat = fract(uv1 + vec2(0.31, 0.03));\n    mask = WheatMask(uvWheat, 10.0, wind, 0.75) * (1.0 - uv.y * 2.0) * (noise2 + 0.85);\n    groundColor = mix(groundColor, wheatColor1, mask * wheatNoise);\n   \n    float horizon = min(max(uv.y * 2.0 - 1.0 + sin(uv.x * 3.14 - 3.0) * 0.05, 0.0) * 100.0, 1.0);\n    vec3 col = mix(groundColor, skyColor, horizon);    \n    \n    float testColor = blackFillMask;\n    //col = vec3(testColor);\n     \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": "4sf3Rn", "previewfilepath": "/media/ap/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WlycDW.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 35, 35, 102], [104, 104, 140, 140, 275], [276, 276, 350, 350, 441], [443, 443, 471, 471, 822], [824, 824, 869, 869, 966], [968, 968, 989, 989, 1061], [1063, 1063, 1129, 1129, 1773], [1775, 1775, 1832, 1832, 5203]]}
{"id": "wlycRR", "name": "Human Batteries", "author": "dean_the_coder", "description": "The human body generates more bio electricity than a 120 volt battery and over 25000 BTUs of body heat.\nCombined with a form of fusion the machines had found all the energy they would ever need.\n  - The Matrix (1999)", "tags": ["3d", "raymarching", "matrix", "movie", "cineshader"], "likes": 24, "viewed": 3700, "published": "Public API", "date": "1610315802", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// 'Human Batteries' dean_the_coder (Twitter: @deanthecoder)\n// https://www.shadertoy.com/view/wlycRR\n//\n// \"The human body generates more bio electricity than a\n//  120 volt battery and over 25000 BTUs of body heat.\n//  Combined with a form of fusion the machines had found\n//  all the energy they would ever need.\"\n//   - The Matrix (1999)\n//\n// Tricks to get the performance:\n//   - There's only one 'pod'.\n//\t The others are all cloned by folding space and\n//\t mirroring the axis.\n//   - There's only one column.\n//\t Again, mirroring the axis x/z axis creates more.\n//   - Only two lighting bolts.\n//\t Axis mirroring again...\n//\n// Thanks to Evvvvil, Flopine, Nusan, BigWings, Iq, Shane\n// and a bunch of others for sharing their knowledge!\n\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\n#define MIN_DIST\t\t .0015\n#define MAX_DIST\t\t 80.0\n#define MAX_STEPS\t\t 100.0\n#define SHADOW_STEPS\t 20.0\n#define MAX_SHADOW_DIST  10.0\n#define BODY_STEPS\t     30.0\n#define MAX_BODY_DIST    1.7\n\nfloat T; // Global time.\nvec2 g = vec2(0); // Glow for lightning and pods.\n\nstruct Hit {\n\tfloat d; // SDF distance.\n\tint id;  // Material ID.\n\tvec3 uv; // Ray position.\n};\n\n// Thnx Dave_Hoskins - https://www.shadertoy.com/view/4djSRW\n#define HASH  p = fract(p * .1031); p *= p + 3.3456; return fract(p * (p + p));\n\nvec2 hash22(vec2 p) { HASH }\nvec4 hash44(vec4 p) { HASH }\n\nfloat n31(vec3 p) {\n\t// Thanks Shane - https://www.shadertoy.com/view/lstGRB\n\tconst vec3 s = vec3(7, 157, 113);\n\tvec3 ip = floor(p);\n\tp = fract(p);\n\tp = p * p * (3. - 2. * p);\n\n\tvec4 h = vec4(0, s.yz, s.y + s.z) + dot(ip, s);\n\th = mix(hash44(h), hash44(h + s.x), p.x);\n\n\th.xy = mix(h.xz, h.yw, p.y);\n\treturn mix(h.x, h.y, p.z);\n}\n\nfloat n21(vec2 p) { return n31(vec3(p, 1)); }\n\nfloat smin(float a, float b, float k) {\n\tfloat h = clamp(.5 + .5 * (b - a) / k, 0., 1.);\n\treturn mix(b, a, h) - k * h * (1. - h);\n}\n\nvoid minH(inout Hit a, Hit b) {\n\tif (b.d < a.d) a = b;\n}\n\nmat2 rot(float a) {\n\tfloat c = cos(a), s = sin(a);\n\treturn mat2(c, s, -s, c);\n}\n\nvec2 opModPolar(vec2 p, float n)\n{\n\tfloat angle = 3.141 / n,\n\t\t  a = mod(atan(p.y, p.x), 2. * angle) - angle;\n\treturn length(p) * vec2(cos(a), sin(a));\n}\n\nfloat sdBox(vec3 p, vec3 b) {\n\tvec3 q = abs(p) - b;\n\treturn length(max(q, 0.)) + min(max(q.x, max(q.y, q.z)), 0.);\n}\n\nfloat sdCapsule(vec3 p, float h, float r) {\n\tp.x -= clamp(p.x, 0., h);\n\treturn length(p) - r;\n}\n\nfloat sdTorus(vec3 p, vec2 t) {\n  return length(vec2(length(p.xz) - t.x, p.y)) - t.y;\n}\n\nvec3 getRayDir(vec3 ro, vec3 lookAt, vec2 uv) {\n\tvec3 f = normalize(lookAt - ro),\n\t\t r = normalize(cross(vec3(0, 1, 0), f));\n\treturn normalize(f + r * uv.x + cross(f, r) * uv.y);\n}\n\nHit sdPod(vec3 p) {\n\t// Pod.\n\tfloat d = exp(-p.x * .6) * .3 - .07 * p.x * sin(4.7 * p.x) + .06, d2;\n\tHit h = Hit(sdCapsule(p, 1.5, d), 3, p);\n\n\t// The end bit.\n\td2 = sdBox(p - vec3(1.6, 0, 0), vec3(.05)) - .03;\n\n\t// Feeding pipes.\n\td2 = min(min(d2, sdTorus(p + vec3(.6, 0, 0), vec2(.8, .05))),\n\t\t\t sdTorus(p.xzy + vec3(1.75, 0, 0), vec2(2, .1)));\n\n\t// Pod 'cage'.\n\tp.yz = abs(p.yz);\n\tp.y -= d * .5;\n\tp.z -= d;\n\td = sdCapsule(p, 1.65, .03 + abs(sin(p.x * 30.)) * .005);\n\tminH(h, Hit(min(d2, d) * .9, 2, p));\n\n\tg.y += .0001 / (.2 + d * d);\n\n\treturn h;\n}\n\nfloat sdBody(vec3 p) {\n\t// Map world to pod point.\n\tp.xz = opModPolar(abs(p.xz) - 20., 60.);\n\tp.y = mod(p.y, 3.) - 1.5;\n\tp.x -= 12.1;\n\n\t// Head\n\tfloat d = length(p) - .07;\n\n\t// Torso\n\tp.z = abs(p.z);\n\tp.x -= .1;\n\tp.xy *= rot(-.2);\n\td = smin(d, sdCapsule(p, .3, p.x * .09 + .02), .1);\n\n\t// Legs\n\tp.x -= .35;\n\tp.z -= .06;\n\tp.xy *= rot(.3);\n\tp.xz *= rot(.15);\n\treturn smin(d, sdCapsule(p, .5, .01), .2);\n}\n\nfloat sdBolts(vec3 p, float i) {\n\tp = mix(p, p.zyx, step(12., p.x));\n\n\tfloat d, t = T + sign(p.z) + i,\n\t\t  r = n21(vec2(t, i * .2)) - .5;\n\n\tp.x += 10.;\n\tp.y += mod(70. - t * 10. * i, 70.) - 18.\n\t\t   + n21(vec2(p.x, t * 15.2 + i)) * 2.;\n\n\tp.z = abs(p.z) - 24. - r * 5.;\n\n\tp.xy *= rot(r);\n\tp.xz *= rot((i - 1.) * .5);\n\n\td = sdCapsule(p, 20., .01);\n\tg.x += .01 / (.01 + d * d);\n\n\treturn d * .6;\n}\n\n// Map the scene using SDF functions.\nHit map(vec3 p) {\n\t// Lightning.\n\t// We only render two bolts - The others\n\t// are added using axis reflection.\n\tHit h = Hit(min(sdBolts(p, 1.), sdBolts(p, .4)), 6, p);\n\n\t// Main cylinders.\n\t// Only one created - We use axis reflection again.\n\tp.xz = abs(p.xz) - 20.;\n\tminH(h, Hit(length(p.xz) - 12. + sin(p.y * 2.09 + 4.7) * .2, 1, p));\n\n\t// Pods.\n\t// Again, only one is ever rendered!\n\tp.xz = opModPolar(p.xz, 60.);\n\tp.x -= 11.8;\n\tp.y = mod(p.y, 3.) - 1.5;\n\tminH(h, sdPod(p));\n\n\treturn h;\n}\n\nvec3 calcN(vec3 p, float t) {\n\tfloat h = t * .5;\n\tvec3 n = vec3(0);\n\tfor (int i = min(iFrame, 0); i < 4; i++) {\n\t\tvec3 e = .005773 * (2. * vec3((((i + 3) >> 1) & 1), (i >> 1) & 1, i & 1) - 1.);\n\t\tn += e * map(p + e * h).d;\n\t}\n\n\treturn normalize(n);\n}\n\nfloat calcShadow(vec3 p, vec3 ld) {\n\t// Thanks iq.\n\tfloat s = 1., t = .1;\n\tfor (float i = 0.; i < SHADOW_STEPS; i++)\n\t{\n\t\tfloat h = map(p + ld * t).d;\n\t\ts = min(s, 15. * h / t);\n\t\tt += h;\n\t\tif (s < .01 || t > MAX_SHADOW_DIST) break;\n\t}\n\n\treturn clamp(s, 0., 1.);\n}\n\n// March through the pod - Basically the same as a shadow.\nfloat bodyTint(vec3 p, vec3 rd) {\n\tfloat s = 1.;\n\tconst float stp = MAX_BODY_DIST / BODY_STEPS;\n\tfor (float t = 0.; t < MAX_BODY_DIST; t += stp)\n\t{\n\t\tfloat h = sdBody(p + rd * t);\n\t\ts = min(s, 20. * h / t);\n\t\tif (s < .01) break;\n\t}\n\n\treturn clamp(s, 0., 1.);\n}\n\n// Quick ambient occlusion.\nfloat ao(vec3 p, vec3 n, float h) { return map(p + h * n).d / h; }\n\n// Sub-surface scattering. (Thanks Evvvvil)\nfloat sss(vec3 p, vec3 ld, float h) { return smoothstep(0.0, 1.0, map(p + ld * h).d / h); }\n\n/**********************************************************************************/\n\nvec3 vignette(vec3 c, vec2 fc) {\n\tvec2 q = fc.xy / iResolution.xy;\n\tc *= .5 + .5 * pow(16. * q.x * q.y * (1. - q.x) * (1. - q.y), .4);\n\treturn c;\n}\n\nvec3 lights(vec3 p, vec3 rd, float d, Hit h) {\n\tvec3 ld = normalize(vec3(6, 3, -10) - p),\n\t\t n = calcN(p, d), c;\n\tfloat ss = 0., // Sub-surface scatter\n\t\t  sp = 10.; // Specular multiplier.\n\n\tif (h.id == 1) {\n\t\t// Column.\n\t\t// Small ridges added using a quick bump map.\n\t\tc = vec3(.01);\n\t\tn.y += (abs(sin(h.uv.y * 31.)) - .5) * .4;\n\t\tn = normalize(n);\n\t} else if (h.id == 2) {\n\t\t// Feeder Pipes.\n\t\tc = vec3(.02);\n\t\tsp = 50.; // Slightly increased specular to add 'shine'.\n\t} else if (h.id == 3) {\n\t\t// Pod pink.\n\t\tc = vec3(1, .32, .27) * smoothstep(1.55, 1.3, h.uv.x);\n\t\tc *= .2 + .8 * smoothstep(0., .2, h.uv.x);\n\n\t\t// Sub-surface scattering.\n\t\tss = sss(p, ld, .45);\n\t} else c = vec3(1);\n\n\t// Ambient occlusion.\n\tfloat ao = dot(vec2(ao(p, n, .2), ao(p, n, .5)), vec2(.1, .2)),\n\n\t// Primary light.\n\tl1 = max(0., .1 + .9 * dot(ld, n))\n\t\t * (.3 + .7 * calcShadow(p, ld)) // ...with shadow.\n\t\t * (.3 + .7 * ao), // ...and _some_ AO.\n\n\t// Secondary(/bounce) light.\n\tl2 = max(0., .1 + .9 * dot(ld * vec3(-1, 0, -1), n)) * .3,\n\n\t// Fresnel\n\tfre = smoothstep(.7, 1., 1. + dot(rd, n)) * .5,\n\n\t// Specular.\n\tspe = smoothstep(0., 1., pow(max(0., dot(rd, reflect(ld, n))), 30.)) * sp;\n\n\t// Combine into final color.\n\treturn mix((l1 + (l2 + spe) * ao + ss) * c * vec3(2, 1.6, 1.4),\n\t\t\t   vec3(.01),\n\t\t\t   fre);\n}\n\nvec3 march(vec3 ro, vec3 rd) {\n\t// Raymarch.\n\tvec3 p, c = vec3(0);\n\n\tfloat d = .01;\n\tHit h;\n\tfor (float i = 0.; i < MAX_STEPS; i++) {\n\t\tp = ro + rd * d;\n\t\th = map(p);\n\n\t\tif (abs(h.d) < MIN_DIST || d > MAX_DIST)\n\t\t\tbreak;\n\n\t\td += h.d; // No hit, so keep marching.\n\t}\n\n\t// Stash the glow before calculating normals/etc alters it.\n\tvec2 gg = g;\n\n\tif (d < MAX_DIST) {\n\t\tc = lights(p, rd, d, h);\n\n\t\t// If we hit a pod, do a mini-march through it\n\t\t// to build a tint of the 'bodies'.\n\t\tif (h.id == 3)\n\t\t\tc *= .4 + .6 * bodyTint(p - rd, rd);\n\t}\n\n\tc *= exp(d * d * -.001);\n\n\t// Raymarch to get fog depth.\n#define FOG_STEPS      8.0\n\tfloat maxD = min(d, MAX_DIST),\n\t\t  d2 = 0.01;\n\tfor (float i = 0.; i < FOG_STEPS; i++) {\n\t\tp = ro + rd * d2;\n\t\tfloat fd = 0.7 * abs(p.y + 15.0 + 10.0 * n31(vec3(p.xz * 0.1, T * 0.1)));\n\t\tif (abs(fd) < MIN_DIST || d2 > maxD)\n\t\t\tbreak;\n\t\td2 += fd;\n\t}\n\n\t// Mix in the fog color.\n\td = smoothstep(0., 1., (min(d, MAX_DIST) - d2) / 30.);\n\tc = mix(c,\n\t\t\tvec3(.25, .3, .4),\n\t\t\td * d // Base fog.\n\t\t\t* n21(p.xz * .06) // Low frequency patches.\n\t\t\t* (.2 + .8 * n31(vec3(p.xz + T, T) * .2)) // Finer details.\n\t\t\t);\n\n\treturn c // Base color.\n\t\t   + gg.x * vec3(.4, .6, 1) // Lighting bolt glow.\n\t\t   + gg.y * vec3(1, .32, .27); // Faint pod glow.\n}\n\nvoid mainImage(out vec4 fragColor, vec2 fc)\n{\n\tT = mod(iTime, 40.) + 1.3;\n\n\tfloat dim = 1. - abs(cos(clamp(T, -1., 1.) * 1.57)),\n\t\t  t = .5 + .5 * cos(.157 * T);\n\tt = mix(smoothstep(0., 1., t), t, t);\n\tvec3 ro = vec3(-6.5, 25. - t * 20., 21);\n\tro.xz += t * 25.;\n\n\tvec2 uv = (fc - .5 * iResolution.xy) / iResolution.y;\n\tvec3 col = march(ro, getRayDir(ro, vec3(0, -t * 10., 0), uv));\n\n\t// Output to screen.\n\tfragColor = vec4(vignette(pow(col * dim, vec3(.45)), fc), 0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wlycRR.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[1198, 1340, 1361, 1361, 1368], [1369, 1369, 1390, 1390, 1397], [1399, 1399, 1418, 1475, 1728], [1730, 1730, 1749, 1749, 1775], [1777, 1777, 1816, 1816, 1908], [1910, 1910, 1941, 1941, 1966], [1968, 1968, 1987, 1987, 2047], [2049, 2049, 2083, 2083, 2202], [2204, 2204, 2233, 2233, 2320], [2322, 2322, 2365, 2365, 2417], [2419, 2419, 2450, 2450, 2506], [2508, 2508, 2555, 2555, 2688], [2690, 2690, 2709, 2718, 3241], [3243, 3243, 3265, 3293, 3645], [3647, 3647, 3679, 3679, 4040], [4042, 4080, 4097, 4191, 4572], [4574, 4574, 4603, 4603, 4824], [4826, 4826, 4861, 4876, 5090], [5092, 5151, 5184, 5184, 5411], [5413, 5441, 5476, 5476, 5507], [5509, 5553, 5590, 5590, 5644], [5646, 5732, 5764, 5764, 5879], [5881, 5881, 5927, 5927, 7181], [7183, 7183, 7213, 7227, 8444], [8446, 8446, 8491, 8491, 8915]]}
{"id": "wlycRt", "name": "Illuminations road", "author": "gaz", "description": "https://twitter.com/gaziya5/status/1353544215247024129", "tags": ["3d"], "likes": 17, "viewed": 167, "published": "Public", "date": "1611546234", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage(out vec4 O, vec2 C)\n{\n    O-=O;\n    vec2 r=iResolution.xy;\n    vec4 p,d=vec4((C.xy-.5*r)/r.y,1,0);\n    for(float i=0.,g,e,l,s;++i<99.;e<.015?O+=abs(cos(d+log(s)))/i:O)\n    {\n        s=3.;\n        p=g*d;\n        p.z+=iTime;\n        p.xy=vec2(length(p.xy)-3.,atan(p.x,p.y));\n        p.yz=fract(p.yz)-.5;\n        p=abs(p);\n        for(int i=0;i++<4;)\n            p=.8-abs(p-.4),\n            p=p*(l=-2./dot(p,p)),\n            s*=l;\n        g+=e=length(p.yz)/s;\n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wlycRt.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 36, 36, 479]]}
{"id": "WlycWw", "name": "ripping off Nick Teeple", "author": "mds2", "description": "Riff on something I saw Nick Teeple make on instagram.  Kind of looks like a hairy dyson clinder.", "tags": ["raycast", "glass", "soundcloud"], "likes": 1, "viewed": 219, "published": "Public API", "date": "1611091764", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define BLOCKSIZE 0.5\n\n#define EXTENT 75.0\n\n#define MULTI_SAMPLE 1 // do not set higher than 8\n\n#define DO_SUBSURFACE 1\n\nvec3 camera = vec3(55.0, 0.0, 0.0);\nmat3 dir_mat = mat3(1.0, 0.0, 0.0,\n                    0.0, 1.0, 0.0,\n                    0.0, 0.0, 1.0);\n\nconst float error_bound = 1.0e-3;\n\nconst float blocks_max_height = -1.15; // -1.75 + 0.6 + 0.25 * BLOCKSIZE\nconst float waffle_max_height = -1.75; // -2.0 + 0.1 + 0.15\n\n\n#if 1\nvec2 polar(in vec2 pos) {\n  vec2 rel = abs(pos);\n  float l = length(rel);\n  rel = rel / l;\n  const mat2 poly = mat2(-0.05313198,  1.52184169,\n                         0.02548278, -0.47818779); // note : transposed\n  float angle = dot(vec2(1.0, rel.y), poly * vec2(1.0, rel.x));\n  if (pos.x * pos.y < 0.0) {\n    angle = 3.141592654 - angle;\n  }\n  if (pos.y < 0.0) {\n     angle = angle + 3.141592654;\n  }\n  \n  return vec2(l, angle);\n}\n#elif 0\n\nvec2 polar(in vec2 pos) {\n  vec2 rel = abs(pos);\n  float l = length(rel);\n  rel = rel / l;\n  const mat3 poly = mat3(-0.02615218,  1.52408152,  0.06801275,\n                         0.06062274, -1.67373931,  0.77403607,\n                         -0.03068766,  1.16883771, -0.74732226\n                    ); // note : transposed\n  float angle = dot(vec3(1.0, rel.y, rel.y * rel.y), poly * vec3(1.0, rel.x, rel.x * rel.x));\n  if (pos.x * pos.y < 0.0) {\n    angle = - angle;\n  }\n  if (pos.x < 0.0) {\n     angle = angle + 3.141592654;\n  }\n  \n  return vec2(l, angle);\n}\n\n#elif 0\n\nvec2 polar(in vec2 pos) {\n  vec2 rel = abs(pos);\n  float l = length(rel);\n  rel = rel / l;\n  const mat4 poly = mat4(-0.01554769,  1.52800768,  0.17473044, -0.12072499,\n                         0.08148376, -3.49823103,  3.93686816, -1.51359643,\n                         -0.11363601,  6.09961648, -9.57827611,  4.39990684,\n                         0.04862359, -3.20708214,  5.6870433 , -2.79976505);\n  float angle = dot(vec4(1.0, rel.y, rel.y * rel.y * vec2(1.0, rel.y)),\n                    poly * \n                    vec4(1.0, rel.x, rel.x * rel.x * vec2(1.0, rel.x)));\n  if (pos.x * pos.y < 0.0) {\n    angle = 3.141592654 - angle;\n  }\n  if (pos.y < 0.0) {\n     angle = angle + 3.141592654;\n  }\n  \n  return vec2(l, angle);\n}\n\n#else\n\nvec2 polar(in vec2 pos) {\n  return vec2(length(pos), mod(atan(pos.y, pos.x), 2.0 * PI));\n}\n\n\n#endif\n\nvec3 xform(in highp vec3 point) {\n  const float h = 9.;\n  // point\n  point.y += h;\n  point.yz = polar(point.yz);\n  point.z *= 3.0 / 3.141592654;\n  \n  point.y -= h;\n  point.y += 1.0;\n  point.z = mod(point.z + 0.1 * iTime - 0.05 * point.y, 6.0);\n  point.z *= 10.0;\n  // point.z -= iTime;\n  return point;\n}\n\nfloat waffle_sdf(in highp vec3 point) {\n    point = xform(point);\n\tvec3 local = vec3(abs(abs(mod(point.xz, BLOCKSIZE)) - vec2(0.5 * BLOCKSIZE)), point.y).xzy;\n    vec2 lr_dists = max(abs(local.xz) - 0.275 * BLOCKSIZE, 0.0);\n    float lr_dist = max(0.25 * BLOCKSIZE - length(lr_dists), 0.0);\n    float updist = abs(local.y + 2.0);\n    return length(vec3(lr_dist, max(updist - 0.1, 0.0), \n                       max(length(point - camera) - EXTENT, 0.0))) - 0.05;\n}\n\nfloat blocks_sdf(in highp vec3 point) {\n    point = xform(point);\n\tvec3 local = vec3(abs(abs(mod(point.xz, BLOCKSIZE)) - vec2(0.5 * BLOCKSIZE)),\n                      abs(point.y + 1.75)).xzy;\n        float samp_loc = mod(9.1 * dot(point.xz - mod(point.xz, BLOCKSIZE),\n                             vec2(0.1733, 0.1321)), 1.0);\n\n    float samp = texture(iChannel0, vec2(samp_loc, 0.0)).r;\n\tvec3 to_core = max(vec3(0.0), local - BLOCKSIZE * vec3(0.05, 0.1 + 2.0 * samp, 0.075));\n    return max(length(to_core), \n                       max(length(point - camera) - EXTENT, 0.0)) - 0.125 * (1.0 + samp) * BLOCKSIZE;\n}\n\nfloat grid_sdf(in highp vec3 point) {\n    return min(waffle_sdf(point), blocks_sdf(point));\n}\n\nvec3 waffle_grad(in highp vec3 point) {\n    float p = waffle_sdf(point);\n    return normalize(vec3(waffle_sdf(point + vec3(0.01, 0.0, 0.0)) - p,\n                          waffle_sdf(point + vec3(0.0, 0.01, 0.0)) - p,\n                          waffle_sdf(point + vec3(0.0, 0.0, 0.01)) - p));\n}\n\n\nvec3 blocks_grad(in highp vec3 point) {\n    float p = blocks_sdf(point);\n    return normalize(vec3(blocks_sdf(point + vec3(0.01, 0.0, 0.0)) - p,\n                          blocks_sdf(point + vec3(0.0, 0.01, 0.0)) - p,\n                          blocks_sdf(point + vec3(0.0, 0.0, 0.01)) - p));\n}\n\n\nfloat dist_to_grid(in highp vec3 point, in highp vec3 dir) {\n\tvec3 p = point;\n    float result = 0.0;\n    if (dir.y < -error_bound) {\n\t    float to_max = (point.y - waffle_max_height) / dir.y;\n    \tresult = to_max;\n    } else if (point.y > waffle_max_height + EXTENT * error_bound) {\n        return 2.0 * EXTENT;\n    }\n    p = p + result * dir;\n    for (int i = 0; i < 128; ++i) {\n    \tfloat d = 0.9 * waffle_sdf(p);\n    \tresult += d;\n        p = p + d * dir;\n        if (abs(d) < error_bound || result > 2.0 * EXTENT) {\n            return result;\n        }\n    }\n    return result;\n}\n\nfloat dist_to_blocks(in highp vec3 point, in highp vec3 dir) {\n\tvec3 p = point;\n    float result = 0.0;\n    if (dir.y < -error_bound) {\n        float to_max = (point.y - blocks_max_height) / dir.y;\n        result = to_max;\n    } else {\n        return 2.0 * EXTENT;\n    }\n    p = p + result * dir;\n    for (int i = 0; i < 512; ++i) {\n    \tfloat d = 0.35 * blocks_sdf(p);\n    \tresult += d;\n        p = p + d * dir;\n        if (abs(d) < error_bound || result > 2.0 * EXTENT || p.y > 100.0) {\n            return result;\n        }\n    }\n    return result;\n}\n\nfloat dist_out_of_blocks(in highp vec3 point, in highp vec3 dir) {\n\tvec3 p = point;\n    float result = 0.0;\n    for (int i = 0; i < 64; ++i) {\n    \tfloat d = -0.9 * blocks_sdf(p);\n    \tresult += d;\n        p = p + d * dir;\n        if (abs(d) < error_bound) {\n            return result;\n        }\n    }\n    return result;\n}\n\nconst vec3 light1 = vec3(0.36, 0.48, -0.8);\n\nconst vec3 light2 = vec3(-0.48, 0.64, -0.6);\n\nvec4 getSample(in vec2 fragCoord )\n{\n\tvec2 uv = (fragCoord.xy - 0.5 * iResolution.xy) / max(iResolution.x, iResolution.y);\n\n    vec4 color_mul = vec4(1.0);\n\n    vec3 ray_orig = camera; // vec3(0.0, 0.0, -1.0); // sin(iTime));\n    float distort = 0.85 + 0.65 * dot(uv, uv);\n    vec3 ray_dir = normalize(vec3(uv * distort - vec2(0.0, 0.1), -0.2));\n    ray_dir = dir_mat *\n        mat3(1.0, 0.0, 0.0,\n        \t 0.0, 0.8, -0.6,\n             0.0, 0.6, 0.8) * ray_dir;\n    float d1 = dist_to_grid(ray_orig, ray_dir);\n    float d2 = dist_to_blocks(ray_orig, ray_dir);\n    vec3 n = ray_dir;\n    const float eta = 1.85;\n    vec3 subsurface = vec3(0.0);\n    if (d2 < d1 && d2 < 20.0) {\n        ray_orig = ray_orig + ray_dir * (d2 + 0.01);\n    \tn = blocks_grad(ray_orig);\n        vec3 next_ray_dir = refract(ray_dir, n, eta);\n        float l = length(next_ray_dir);\n\n        if (l > 0.1) {\n            ray_dir = next_ray_dir / l;\n        \td2 = dist_out_of_blocks(ray_orig, ray_dir);\n        \tcolor_mul *= mix(vec4(1.0, 0.9, 0.5, 1.0), vec4(1.0),\n                         exp(-2.0 * max(d2, 0.0)));\n        \tray_orig = ray_orig + d2 * ray_dir;\n       \t\tn = blocks_grad(ray_orig);\n        \tnext_ray_dir = refract(ray_dir, -n, 1.0/eta);\n            l = length(next_ray_dir);\n            if (l > 0.1) {\n                ray_dir = next_ray_dir / l;\n            }\n        } else {\n            ray_dir = normalize(reflect(ray_dir, n));\n        }\n        d1 = dist_to_grid(ray_orig, ray_dir);\n        const float subsurface_dist_mul = 150.0;\n#if DO_SUBSURFACE        \n        float d_light_1 = dist_out_of_blocks(ray_orig, light1);\n        float d_light_2 = dist_out_of_blocks(ray_orig, light2);\n#else\n        float d_light_1 = 1000.0 / subsurface_dist_mul;\n        float d_light_2 = d_light_1;\n#endif        \n        subsurface = vec3(1.0 / max(2.0, subsurface_dist_mul * d_light_1),\n                          0.0,\n                          1.0 / max(2.0, subsurface_dist_mul * d_light_2));\n        subsurface.g = 0.5 * (subsurface.b + subsurface.r);\n        \n    }\n    vec3 bounce = ray_dir;\n    if ( d1 < 20.0) {\n        vec3 p = ray_orig + ray_dir * d1;\n        n = waffle_grad(p);\n        bounce = normalize(reflect(ray_dir, n));\n        color_mul *= vec4(vec3(0.6, 0.6, 0.7), 1.0);\n    }\n    \n    float diffuse1 = max(dot(n, light1), 0.0) + 0.1;\n    float diffuse2 = 0.4 * max(dot(n, light2), 0.0) + 0.1;\n    float spec1 = smoothstep(0.9, 1.0, dot(bounce, light1));\n    float spec2 = smoothstep(0.8, 0.9, dot(bounce, light2));\n    float mouseness = step(iMouse.y, fragCoord.y);\n    return vec4(subsurface * mouseness, 0.0) +\n        color_mul * vec4((diffuse1 + spec1) * vec3(1.0, 0.5, 0.0) +\n                         (diffuse2 + spec2) * vec3(0.0, 0.5, 1.0), 1.0);\n}\n\n/*\nvec2 offsets[8] = vec2[8](vec2(-0.4, -0.4), \n                         vec2(-0.45, 0.1),\n                         vec2(-0.4, 0.4),\n                         vec2(0.1, 0.45),\n                         vec2(0.4, 0.4),\n                         vec2(0.45, -0.1),\n                         vec2(0.4, -0.4),\n                         vec2(0.0, 0.0)); */\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec4 result = vec4(0.0);\n    \n    float c_theta = cos(0.01);\n    float s_theta = sin(0.01);\n\n    camera = mat3(c_theta, 0.0, s_theta,\n                  0.0, 1.0, 0.0,\n                  -s_theta, 0.0, c_theta) * camera;\n    \n    dir_mat = mat3(-c_theta, 0.0, -s_theta,\n                   0.0, 1.0, 0.0,\n                   s_theta, 0.0, -c_theta);\n    \n    float nsamps = 0.0;\n    \n    result += getSample(fragCoord + vec2(-0.4));\n    nsamps += 1.0;\n    \n    if (MULTI_SAMPLE > 1) {\n\t    result += getSample(fragCoord + vec2(0.1, 0.45));\n    \tnsamps += 1.0;\n    }\n    \n    if (MULTI_SAMPLE > 2) {\n\t    result += getSample(fragCoord + vec2(0.45, -0.1));\n    \tnsamps += 1.0;\n    }        \n    \n    /*\n    for (int i = 0; i < 8; i += max(8 / MULTI_SAMPLE, 1)) {\n        result += getSample(fragCoord + offsets[i]);\n    \tnsamps += 1.0;\n    }\n*/\n    \n    fragColor = result / nsamps;\n}\n", "image_inputs": [{"id": "XllXz4", "previewfilepath": "https://soundcloud.com/reanimasiya/brad-mehldau-teardrop", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0, "src": "https://soundcloud.com/reanimasiya/brad-mehldau-teardrop", "ctype": "musicstream"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WlycWw.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[338, 2289, 2322, 2322, 2592], [2594, 2594, 2633, 2633, 3057], [3059, 3059, 3098, 3098, 3672], [3674, 3674, 3711, 3711, 3767], [3769, 3769, 3808, 3808, 4061], [4064, 4064, 4103, 4103, 4356], [4359, 4359, 4419, 4419, 4943], [4945, 4945, 5007, 5007, 5497], [5499, 5499, 5565, 5565, 5821], [5914, 5914, 5950, 5950, 8667], [8669, 9016, 9073, 9073, 9956]]}
{"id": "wlyczd", "name": "Inside the box", "author": "gaz", "description": "https://twitter.com/gaziya5/status/1353640930864058369", "tags": ["fractal"], "likes": 11, "viewed": 119, "published": "Public", "date": "1611576239", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define R(a) mat2(cos(a),sin(a),-sin(a),cos(a))\nvoid mainImage(out vec4 O, vec2 C)\n{\n    O-=O;\n    vec3 r=iResolution,p,q,d=vec3((C-.5*r.xy)/r.y,.6);\n    for(float i=0.,g,e,l,s;++i<80.;e<.001?O.xyz+=abs(cos(d+log(s)))/i:p)\n    {\n        s=4.;\n        p=g*d;\n        p.z-=.9;\n        p.xy*=R(iTime*.2);\n        p.yz*=R(iTime*.3);\n        q=p;\n        s=2.;\n        for(int j=0;j++<9;)\n            p-=clamp(p,-1.,1.)*2.,\n            p=p*(l=8.8*clamp(.72/min(dot(p,p),2.),0.,1.))+q,\n            s*=l;\n        g+=e=length(p)/s;\n    }\n\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wlyczd.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[48, 48, 84, 84, 532]]}
{"id": "WlyyD3", "name": "Path Tracing Cornell Box 2", "author": "ma38su", "description": "Implementation of path tracing with reference to \"Ray Tracing in One Weekend\".", "tags": ["pathtracing"], "likes": 1, "viewed": 67, "published": "Public", "date": "1611844786", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const bool animation_enabled = true;\n// rays per pixel\nconst int NS = 6;\n// max reflection\nconst int ITER = 16;\n\nconst bool light_sampling = true;\nconst bool box_sampling = false;\n\nconst float aperture = 0.00;\nfloat focus_dist = 0.5;\n\nconst float EPS = .00001;\nconst float INF = 10000.;\nconst float PI = 3.14159265;\n\nconst float fov = 1.0;\n\nconst uint K = 0x456789abU;\nconst float uint_range = 1. / float(0xFFFFFFFFU);\n\nvoid xorshift(inout uint seed) {\n    seed ^= seed << 24;\n    seed ^= seed >> 1;\n    seed *= K;\n    seed ^= seed << 1;\n    seed *= K;\n}\n\nfloat next_float(inout uint seed) {\n    xorshift(seed);\n    return float(seed - 1U) * uint_range;\n}\n\nfloat next_float(inout uint seed, float min_v, float max_v) {\n    return min_v + (max_v - min_v) * next_float(seed);\n}\n\nfloat atan2(float y, float x) {\n    return x == 0.0 ? sign(y) * PI*.5 : atan(y, x);\n}\n\nstruct Hit {\n    vec3 rp;\n    vec3 nv;\n    vec2 uv;\n    int index;\n};\n\nstruct Material {\n    int type;\n    \n    vec3 albedo;\n    vec3 emit;\n\n    // only metal type (0: disable)\n    float fuzziness;\n\n    float ref_idx;\n};\n\n// type for Material\nconst int LAMBERTIAN = 0;\nconst int METAL = 1;\nconst int DIELECTRIC = 2;\n\nconst vec3 COL_RED = vec3(.65, .05, .05);\nconst vec3 COL_BLUE = vec3(.05, .05, .65);\nconst vec3 COL_WHITE = vec3(.73);\nconst vec3 COL_GREEN = vec3(.12, .45, .15);\n\nconst vec3 NO_LIGHT = vec3(.0);\n\nconst Material MAT_WHITE = Material(LAMBERTIAN, COL_WHITE, NO_LIGHT, 0., 0.);\nconst Material MAT_ALUMINUM = Material(METAL, vec3(0.8, 0.85, 0.88), NO_LIGHT, 0., 0.);\nconst Material MAT_GLASS = Material(DIELECTRIC, COL_WHITE, NO_LIGHT, 0., 1.5);\n\nconst int RECT = 0;\nconst int SPHERE = 1;\n\nstruct Geo {\n    int type;\n\n    vec2 size;\n    mat4 m;\n    mat4 im;\n};\n\nstruct Box {\n    Geo rects[6];\n    mat4 m;\n    mat4 im;\n};\n\n// Models\nconst int LEN_GEOS = 7;\nconst int LEN_BOXES = 2;\nGeo geos[LEN_GEOS];\nBox boxes[LEN_BOXES];\nMaterial materials[LEN_GEOS + LEN_BOXES];\n\n// importance samplings\nconst int N_SAMPLING = 1;\nconst int N_BOX_SAMPLING = 1;\nGeo samplings[N_SAMPLING];\nBox box_samplings[N_BOX_SAMPLING];\n\nvoid rot_x(const float theta, inout mat4 m, inout mat4 im) {\n    m = mat4(\n        1., 0., 0., 0.,\n        0., cos(theta), sin(theta), 0.,\n        0., -sin(theta), cos(theta), 0.,\n        0., 0., 0., 1.\n    ) * m;\n    im *= mat4(\n        1., 0., 0., 0.,\n        0., cos(-theta), sin(-theta), 0.,\n        0., -sin(-theta), cos(-theta), 0.,\n        0., 0., 0., 1.\n    );\n}\n\nvoid rot_y(float theta, inout mat4 m, inout mat4 im) {\n    m = mat4(\n        cos(theta), 0., sin(theta), 0.,\n        0., 1., 0., 0.,\n        -sin(theta), 0., cos(theta), 0.,\n        0., 0., 0., 1.\n    ) * m;\n    im *= mat4(\n        cos(-theta), 0., sin(-theta), 0.,\n        0., 1., 0., 0.,\n        -sin(-theta), 0., cos(-theta), 0.,\n        0., 0., 0., 1.\n    );\n}\n\nvoid rot_z(float theta, inout mat4 m, inout mat4 im) {\n    m = mat4(\n        cos(theta), sin(theta), 0., 0.,\n        -sin(theta), cos(theta), 0., 0.,\n        0., 0., 1., 0.,\n        0., 0., 0., 1.\n    ) * m;\n    im *= mat4(\n        cos(-theta), sin(-theta), 0., 0.,\n        -sin(-theta), cos(-theta), 0., 0.,\n        0., 0., 1., 0.,\n        0., 0., 0., 1.\n    );\n}\n\nvoid trans_xyz(const float dx, const float dy, const float dz, inout mat4 m, inout mat4 im) {\n    m = mat4(\n        1., 0., 0., 0.,\n        0., 1., 0., 0.,\n        0., 0., 1., 0.,\n        dx, dy, dz, 1.\n    ) * m;\n    im *= mat4(\n        1., 0., 0., 0.,\n        0., 1., 0., 0.,\n        0., 0., 1., 0.,\n        -dx, -dy, -dz, 1.\n    );\n}\n\nvec3 calc(in mat4 m, in vec3 p) {\n    return (m * vec4(p, 1.)).xyz;\n}\n\nvec3 rot(in mat4 m, in vec3 p) {\n    return mat3(m) * p;\n}\n\nvec2 random_in_disk(inout uint seed) {\n    vec2 v;\n    for (int i = 0; i < 1024; ++i) {\n        v.x = next_float(seed, -1.0, 1.0);\n        v.y = next_float(seed, -1.0, 1.0);\n        if (length(v) < 1.) return v;\n    }\n    return normalize(v);\n}\n\nvec3 random_in_sphere(inout uint seed) {\n    vec3 v;\n    for (int i = 0; i < 1024; ++i) {\n        v.x = next_float(seed, -1.0, 1.0);\n        v.y = next_float(seed, -1.0, 1.0);\n        v.z = next_float(seed, -1.0, 1.0);\n        if (length(v) < 1.) return v;\n    }\n    return normalize(v);\n}\n\nvec3 random_unit_vector(inout uint seed) {\n    return normalize(random_in_sphere(seed));\n}\n\nvec3 random_in_rect(const in Geo rect, inout uint seed) {\n    float x = rect.size.x * next_float(seed, -1., 1.);\n    float y = rect.size.y * next_float(seed, -1., 1.);\n    float z = 0.;\n    return calc(rect.im, vec3(x, y, z));\n}\n\nvoid gen_box(const float w, const float h, const float d, inout Box box) {\n    { // front\n        mat4 m = mat4(1.0), im = mat4(1.0);\n        trans_xyz(0., 0., d, m, im);\n        box.rects[0] = Geo(RECT, vec2(w, h), m, im);\n    }\n    { // back\n        mat4 m = mat4(1.0), im = mat4(1.0);\n        trans_xyz(0., 0., -d, m, im);\n        box.rects[1] = Geo(RECT, vec2(w, h), m, im);\n    }\n    { // left\n        mat4 m = mat4(1.0), im = mat4(1.0);\n        trans_xyz(-w, 0., 0., m, im);\n        rot_y(PI * 0.5, m, im);\n        box.rects[2] = Geo(RECT, vec2(d, h), m, im);\n    }\n    { // right\n        mat4 m = mat4(1.0), im = mat4(1.0);\n        trans_xyz(w, 0., 0., m, im);\n        rot_y(-PI * 0.5, m, im);\n        box.rects[3] = Geo(RECT, vec2(d, h), m, im);\n    }\n    { // top\n        mat4 m = mat4(1.0), im = mat4(1.0);\n        trans_xyz(0., -h, 0., m, im);\n        rot_x(PI * 0.5, m, im);\n        box.rects[4] = Geo(RECT, vec2(w, d), m, im);\n    }\n    { // bottom\n        mat4 m = mat4(1.0), im = mat4(1.0);\n        trans_xyz(0., h, 0., m, im);\n        rot_x(-PI * 0.5, m, im);\n        box.rects[5] = Geo(RECT, vec2(w, d), m, im);\n    }\n}\n\nvoid gen_models(const float t) {\n\n    vec3 EMIT_LIGHT = vec3(15.);\n    int i = 0, j = 0;\n    float dy = 0.25;\n    float w = 0.5;\n    float h = 0.5;\n    float depth = 1.0;\n\n    {   // back\n        mat4 m = mat4(1.0), im = mat4(1.0);\n        trans_xyz(0., -h, -depth*.5, m, im);\n        rot_x(PI, m, im);\n        geos[i] = Geo(RECT, vec2(w, h), m, im);\n        materials[i] = MAT_WHITE;\n        i++;\n    }\n    {   // right\n        mat4 m = mat4(1.0), im = mat4(1.0);\n        trans_xyz(0.5, -h -EPS, 0., m, im);\n        rot_y(PI *.5, m, im);\n        geos[i] = Geo(RECT, vec2(w, h), m, im);\n        materials[i] = Material(LAMBERTIAN, COL_RED, NO_LIGHT, 0.0, 0.);\n        i++;\n    }\n    {   // left\n        mat4 m = mat4(1.0), im = mat4(1.0);\n        trans_xyz(-0.5, -h, 0., m, im);\n        rot_y(-PI *.5, m, im);\n        geos[i] = Geo(RECT, vec2(w, h), m, im);\n        materials[i] = Material(LAMBERTIAN, COL_GREEN, NO_LIGHT, 0.0, 0.);\n        i++;\n    }\n    {   // bottom\n        mat4 m = mat4(1.0), im = mat4(1.0);\n        trans_xyz(0., 0., 0., m, im);\n        rot_x(PI / 2.0, m, im);\n        geos[i] = Geo(RECT, vec2(w, h), m, im);\n        materials[i] = MAT_WHITE;\n        Material(LAMBERTIAN, COL_WHITE, NO_LIGHT, 0.0, 0.);\n        i++;\n    }\n    {   // top\n        mat4 m = mat4(1.0), im = mat4(1.0);\n        trans_xyz(0., -h * 2.0, 0., m, im);\n        rot_x(-PI / 2.0, m, im);\n        geos[i] = Geo(RECT, vec2(w, h), m, im);\n        materials[i] = MAT_WHITE;\n        i++;\n    }\n    {   // light\n        float light_size = 0.2;\n        mat4 m = mat4(1.0), im = mat4(1.0);\n        trans_xyz(0., -h * 2.0 + 0.1, 0., m, im);\n        rot_x(-PI / 2.0, m, im);\n        geos[i] = Geo(RECT, vec2(light_size), m, im);\n        materials[i] = Material(LAMBERTIAN, COL_WHITE, EMIT_LIGHT, 0.0, 0.);\n\n        samplings[j++] = geos[i];\n\n        i++;\n    }\n    {\n        mat4 m = mat4(1.0), im = mat4(1.0);\n        trans_xyz(.05, -.25, .18, m, im);\n        geos[i] = Geo(SPHERE, vec2(0.15), m, im);\n        materials[i] = MAT_GLASS;\n        i++;\n    }\n\n    int k = 0;\n    float box_size = 0.15;\n    {\n        float box_height = 0.05;\n        gen_box(box_size, box_height, box_size, boxes[0]);\n\n        float phi = (t * 20. - 15.0) * PI / 180.0;\n        float dh = box_height;\n\n        mat4 m = mat4(1.0), im = mat4(1.0);\n        trans_xyz(0.05, -dh, 0.18, m, im);\n        rot_y(phi, m, im);\n        boxes[0].m = m;\n        boxes[0].im = im;\n        materials[i] = Material(LAMBERTIAN, COL_BLUE, NO_LIGHT, 0.0, 1.5);\n\n        i++;\n    }\n    {\n        float box_height = 0.3;\n        gen_box(box_size, box_height, box_size, boxes[1]);\n\n        float phi = (t * 30. +75.0) / 180.0;\n        float dh = box_height;\n\n        mat4 m = mat4(1.0), im = mat4(1.0);\n        trans_xyz(-0.19, -dh, -0.25, m, im);\n        rot_y(phi, m, im);\n        boxes[1].m = m;\n        boxes[1].im = im;\n        materials[i] = MAT_ALUMINUM;\n        i++;\n\n        box_samplings[k++] = boxes[1];\n    }\n}\n\nvec3 background(const in vec3 rd) {\n    return vec3(0.);\n}\n\nvec2 get_sphere_uv(const in vec3 p) {\n    float phi = atan2(p.z, p.x);\n    float theta = asin(p.y);\n    float u = 1.0 - (phi + PI) / (2.0 * PI);\n    float v = theta / PI + 0.5;\n    return vec2(u,v);\n}\n\nbool hit_sphere(\n        const in vec3 ro0,\n        const in vec3 rd0,\n        const in Geo sphere,\n        const float t_min,\n        inout float t_max,\n        out vec3 rp,\n        out vec3 nv,\n        out vec2 uv) {\n\n    // matrix calculation\n    vec3 rd = rot(sphere.m, rd0);\n    vec3 ro = calc(sphere.m, ro0);\n    \n    float radius = sphere.size.x;\n\n    vec3 oc = ro;\n    float a = dot(rd, rd);\n    float half_b = dot(oc, rd);\n    float c = dot(oc, oc) - radius * radius;\n    float discriminant = half_b * half_b - a * c;\n\n    // no intersection\n    if (discriminant < 0.0) return false;\n\n    float sq_disc = sqrt(discriminant);\n\n    float t;\n    if (sq_disc < EPS) {\n        // 1 intersection\n        t = -half_b / a;\n    } else {\n        // 2 intersection (t1: near, t2: far)\n        float t1 = (-half_b - sq_disc) / a;\n        float t2 = (-half_b + sq_disc) / a;\n        if (t1 > t_max || t2 < t_min) return false;\n        \n        if (t1 > t_min) {\n            t = t1;  \n        } else if (t2 < t_max) {\n            t = t2;\n        } else {\n            return false;\n        }\n    }\n    \n    t_max = t;\n    rp = ro + t * rd;\n    nv = rp / radius;\n    uv = get_sphere_uv(rp / radius);\n\n    // inverse matrix calculation\n    nv = rot(sphere.im, nv);\n    rp = calc(sphere.im, rp);\n\n    return true;\n}\n\nbool hit_rect(\n        const in vec3 ro0,\n        const in vec3 rd0,\n        const in Geo rect,\n        const float t_min,\n        inout float t_max,\n        out vec3 rp,\n        out vec3 nv,\n        out vec2 uv) {\n\n    // matrix calculation\n    vec3 rd = rot(rect.m, rd0);\n    vec3 ro = calc(rect.m, ro0);\n\n    float t = - ro.z / rd.z;\n    if (t < t_min || t > t_max) return false;\n\n    vec2 min_p = - rect.size;\n    vec2 max_p = rect.size;\n    vec3 p = ro + t * rd;\n    if (p.x < min_p.x || p.x > max_p.x\n        || p.y < min_p.y || p.y > max_p.y) {\n        return false;\n    }\n\n    uv = (p.xy - min_p) / (max_p - min_p);\n    nv = vec3(0., 0., 1.0);\n\n    // inverse matrix calculation\n    nv = rot(rect.im, nv);\n    rp = calc(rect.im, p);\n\n    t_max = t;\n    return true;\n}\n\nbool hit_box(\n        const in vec3 ro0,\n        const in vec3 rd0,\n        const in Box box,\n        const float t_min,\n        inout float t_max,\n        out vec3 rp,\n        out vec3 nv,\n        out vec2 uv) {\n\n    vec3 rd = rot(box.m, rd0);\n    vec3 ro = calc(box.m, ro0);\n    bool hit_flag = false;\n    for (int j = 0; j < 6; ++j) {\n        if (hit_rect(ro, rd, box.rects[j], t_min, t_max, rp, nv, uv)) {\n            hit_flag = true;\n        }\n    }\n    if (hit_flag) {\n        nv = rot(box.im, nv);\n        rp = calc(box.im, rp);\n    }\n    return hit_flag;\n}\n\nbool hit(\n        const in vec3 ro,\n        const in vec3 rd,\n        const in Geo geos[LEN_GEOS],\n        const in Box boxes[LEN_BOXES],\n        const in Material materials[LEN_GEOS + LEN_BOXES],\n        inout uint seed,\n        out Hit hit) {\n\n    float t_min = EPS;\n    float t_max = INF;\n    bool hit_flag = false;\n    vec3 nv;\n    vec3 rp;\n    vec2 uv;\n    \n    int geo_idx = 0;\n    for (int i = 0; i < LEN_GEOS; ++i) {\n        switch (geos[i].type) {\n            case RECT:\n                if (hit_rect(ro, rd, geos[i], t_min, t_max, rp, nv, uv)) {\n                    geo_idx = i;\n                    hit_flag = true;\n                }\n                break;\n            case SPHERE:\n                if (hit_sphere(ro, rd, geos[i], t_min, t_max, rp, nv, uv)) {\n                    geo_idx = i;\n                    hit_flag = true;\n                }\n                break;\n        }\n    }\n\n    for (int i = 0; i < LEN_BOXES; ++i) {\n        int idx = LEN_GEOS + i;\n        if (hit_box(ro, rd, boxes[i], t_min, t_max, rp, nv, uv)) {\n            geo_idx = idx;\n            hit_flag = true;\n        }\n    }\n    if (!hit_flag) return false;\n\n    hit = Hit(rp, nv, uv, geo_idx);\n    return true;\n}\n\nfloat schlick(const float cosine, const float ref_idx) {\n    float r0 = (1. - ref_idx) / (1. + ref_idx);\n    r0 = r0 * r0;\n    return r0 + (1. - r0) * pow((1. - cosine), 5.);\n}\n\nfloat cos_pdf(const in vec3 nv, const in vec3 scattered) {\n    float cosine = dot(nv, scattered);\n    return max(cosine / PI, 0.);\n}\n\nfloat rect_pdf(const in vec3 ro, const in vec3 rd, const in Geo rect) {\n    vec3 rp, nv;\n    vec2 _uv;\n    float t = INF;\n    if (!hit_rect(ro, rd, rect, EPS, t, rp, nv, _uv)) {\n        return 0.;\n    }\n    \n    float dist_sq = t * t;\n\n    float cosine = abs(dot(nv, rd));\n    float area = 4. * rect.size.x * rect.size.y * cosine;\n    return dist_sq / area;\n}\n\nfloat sphere_pdf(const in vec3 ro, const in vec3 rd, const in Geo sphere) {\n    vec3 rp, nv;\n    vec2 _uv;\n    float t = INF;\n    if (!hit_sphere(ro, rd, sphere, EPS, t, rp, nv, _uv)) {\n        return 0.;\n    }\n\n    float r = sphere.size.x;\n    float cos_theta_max = sqrt(1. - r*r / length(rp - ro));\n    float solid_angle = 2.* PI * (1. - cos_theta_max);\n    return 1. / solid_angle;\n}\n\nvec3 random_cos_direction(inout uint seed) {\n    float r1 = next_float(seed);\n    float r2 = next_float(seed);\n    float z = sqrt(1.-r2);\n    float phi = 2. * PI * r1;\n    float x = cos(phi) * sqrt(r2);\n    float y = sin(phi) * sqrt(r2);\n    return vec3(x, y, z);\n}\n\nint cosine_min_box(const in Box box, const in vec3 p) {\n    int rect_idx = -1;\n    float min_cosine = 0.;\n    vec3 nv = vec3(0., 0., 1.0);\n    for (int i = 0; i < 6; ++i) {\n        vec3 p1 = -calc(box.rects[i].m, p);\n        float cosine = dot(nv, p1);\n        if (cosine < min_cosine) {\n            min_cosine = cosine;\n            rect_idx = i;\n        }\n    }\n\n    return rect_idx;\n}\n\nvoid scatter_lambertian(\n    const in vec3 rp,\n    const in vec3 nv,\n    inout uint seed,\n    out vec3 rd,\n    out float pdf) {\n\n    vec3 rd1 = normalize(nv + random_unit_vector(seed));\n    //rd1 = random_in_hemisphere(seed, nv);\n\n    int n = 0;\n    vec3 tmp_rd[N_BOX_SAMPLING + N_SAMPLING];\n    int tmp_rect_idx[N_BOX_SAMPLING];\n    \n    if (light_sampling) {\n        for (int i = 0; i < N_SAMPLING; ++i) {\n            vec3 on_target = random_in_rect(samplings[i], seed);\n            vec3 rd2 = on_target - rp;\n            tmp_rd[n++] = rd2;\n        }\n    }\n    if (box_sampling) {\n        for (int i = 0; i < N_BOX_SAMPLING; ++i) {\n            int rect_idx = cosine_min_box(box_samplings[i], rp);\n            tmp_rect_idx[i] = rect_idx;\n            if (rect_idx >= 0) {\n                vec3 on_target = random_in_rect(box_samplings[i].rects[rect_idx], seed);\n                vec3 rd2 = on_target - rp;\n                tmp_rd[n++] = rd2;\n            }\n        }\n    }\n\n    if (n == 0) {\n        rd = rd1;\n        pdf = cos_pdf(nv, rd);\n        return;\n    }\n\n    // importance sampling rate\n    float blend = 0.6;\n\n    float r = next_float(seed);\n    float rate = blend / float(n);\n    rd = rd1;\n    if (r < blend) {\n        for (int i = n - 1; i >= 0; --i) {\n            r -= rate;\n            rd = tmp_rd[i];\n            if (r <= 0.) {\n                break;\n            }\n        }\n        rd = normalize(rd);\n    }\n\n    float sum_pdf = 0.;\n    if (light_sampling) {\n        for (int i = 0; i < N_SAMPLING; ++i) {\n            sum_pdf += rect_pdf(rp, rd, samplings[i]);\n        }\n    }\n    if (box_sampling) {\n        for (int i = 0; i < N_BOX_SAMPLING; ++i) {\n            int rect_idx = tmp_rect_idx[i];\n            if (rect_idx >= 0) sum_pdf += rect_pdf(rp, rd, box_samplings[i].rects[rect_idx]);\n        }\n    }\n\n    pdf = (1. - blend) * cos_pdf(nv, rd) + rate * sum_pdf;\n}\n\nbool pathtracing(\n        in vec3 ro,\n        in vec3 rd,\n        inout uint seed,\n        inout vec3 col,\n        inout int n,\n        out int depth) {\n\n    depth = 0;\n    vec3 attenuation = vec3(1.);\n    for (int i = 0; i < ITER; ++i) {\n\n        Hit ret;\n        if (!hit(ro, rd, geos, boxes, materials, seed, ret)) {\n            col += attenuation * background(rd);\n            n++;\n            return i > 0;\n        }\n\n        vec3 nv = ret.nv;\n        bool front_face = dot(rd, nv) <= 0.0;\n        if (!front_face) nv = -nv;\n\n        Material material = materials[ret.index];\n        if (length(material.emit) > 0.1) {\n            if (front_face) {\n                col += attenuation * material.emit;\n            }\n            n++;\n            return i > 0;\n        }\n\n        vec3 albedo = material.albedo;\n\n        int type = material.type;\n        if (type == LAMBERTIAN) {\n            for (int j = 0; j < 100; ++j) {\n                float pdf;\n                scatter_lambertian(ret.rp, nv, seed, rd, pdf);\n\n                if (pdf <= 0.) continue;\n\n                float scattering_pdf = cos_pdf(nv, rd);\n                ro = ret.rp;\n                attenuation *= albedo * scattering_pdf / pdf;\n                depth++;\n                break;\n            }\n            continue;\n        }\n        vec3 reflected = normalize(reflect(rd, ret.nv) + random_in_sphere(seed) * material.fuzziness);\n        if (type == METAL) {\n            if (dot(reflected, nv) <= 0.0) {\n                n++;\n                return i > 0 || material.fuzziness > 0.0;\n            }\n            rd = reflected;\n        } else if (type == DIELECTRIC) {\n            float ref_idx = material.ref_idx;\n            float etai_over_etat = front_face ? 1.0 / ref_idx : ref_idx;\n\n            float cos_theta = min(dot(-rd, nv), 1.0);\n            float sin_theta = sqrt(1.0 - cos_theta*cos_theta);\n            if (etai_over_etat * sin_theta > 1.0) {\n                rd = reflected;\n            } else if (next_float(seed) < schlick(cos_theta, etai_over_etat)) {\n                rd = reflected;\n            } else {\n                rd = refract(rd, nv, etai_over_etat);\n            }\n        }\n        ro = ret.rp;\n        attenuation *= albedo;\n        depth++;\n    }\n    return true;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n\n    vec2 r = iResolution.xy;\n    vec2 uv = fragCoord/r;\n    \n    gen_models(iTime);\n\n    vec2 p = (fragCoord.xy*2.-r) / min(r.x,r.y);\n    float focus_radius = aperture * 0.5;\n    \n    float theta = PI * 1.5 + 0.1 * sin(iTime);\n\n    // ray origin\n    vec3 ro0 = mod(iTime, 4. * PI) < (2.0 * PI) ? vec3(cos(theta), 0.5, sin(theta)) : vec3(0., 0.5 + cos(theta), -1.0);\n    vec3 ta = vec3(0., 0.5, 0.);\n    \n    vec3 cdir = normalize(ta - ro0);\n    vec3 side = cross(cdir,vec3(0.,1.,0.));\n    vec3 up = cross(side, cdir);\n\n    vec3 rd0 = normalize(p.x*side+p.y*up+cdir*fov);\n\n    uint seed = uint(fragCoord.y * r.x + fragCoord.x);\n    xorshift(seed);\n    seed ^= uint(iFrame);\n\n    // for debug\n    int total_depth = 0;\n\n    vec3 ro;\n    vec3 rd;\n\n    vec3 col = vec3(0.);\n    int n = 0;\n    for (int s = 0; s < NS; ++s) {\n\n        if (focus_radius > 0.0) {\n            vec2 r2 = random_in_disk(seed);\n            vec3 offset = focus_radius * (r2.x * side + r2.y * up);\n            ro = ro0 - offset;\n            rd = normalize(rd0 * focus_dist * 2.0 + offset);\n        } else {\n            ro = ro0;\n            float u = next_float(seed, -0.5, 0.5) / r.x;\n            float v = next_float(seed, -0.5, 0.5) / r.y;\n            rd = normalize((p.x + u)*side+(p.y + v)*up+cdir*fov);\n        }\n\n        int depth;\n        if (!pathtracing(ro, rd, seed, col, n, depth)) {\n            break;\n        }\n        total_depth += depth;\n    }\n    if (n > 0) {\n        col = sqrt(col / float(n));\n\n        // for debug (reflection)\n        //col = vec3(vec3(1.0, 1.0, 0.5) * min(1.0, float(total_depth) / float(n) * 0.1));\n    } else {\n        col = vec3(0.);\n    }\n\n    fragColor = vec4(sqrt(col), 1.);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WlyyD3.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[73, 420, 452, 452, 554], [556, 556, 591, 591, 655], [657, 657, 718, 718, 775], [777, 777, 808, 808, 862], [1943, 2086, 2146, 2146, 2456], [2458, 2458, 2512, 2512, 2822], [2824, 2824, 2878, 2878, 3188], [3190, 3190, 3283, 3283, 3526], [3528, 3528, 3561, 3561, 3597], [3599, 3599, 3631, 3631, 3657], [3659, 3659, 3697, 3697, 3903], [3905, 3905, 3945, 3945, 4194], [4196, 4196, 4238, 4238, 4286], [4288, 4288, 4345, 4345, 4516], [4518, 4518, 4592, 4592, 5654], [5656, 5656, 5688, 5688, 8617], [8619, 8619, 8654, 8654, 8677], [8679, 8679, 8716, 8716, 8879], [8881, 8881, 9099, 9126, 10187], [10189, 10189, 10403, 10430, 10964], [10966, 10966, 11178, 11178, 11530], [11532, 11532, 11776, 11776, 12729], [12731, 12731, 12787, 12787, 12907], [12909, 12909, 12967, 12967, 13041], [13043, 13043, 13114, 13114, 13402], [13404, 13404, 13479, 13479, 13790], [13792, 13792, 13836, 13836, 14057], [14059, 14059, 14114, 14114, 14445], [14447, 14447, 14574, 14574, 16326], [16328, 16328, 16480, 16480, 18592], [18594, 18594, 18649, 18649, 20341]]}
{"id": "WlyyDh", "name": "flow field art 2b", "author": "FabriceNeyret2", "description": "variant of field art [url]https://shadertoy.com/view/wtVyRW[/url] \nusing flownoise [url]https://www.shadertoy.com/view/wdKXzd[/url] \nwith incompressible noise [url]https://www.shadertoy.com/view/Xl3Gzj[/url]\nTry variants for f(U).", "tags": ["perlin", "flow", "field", "flownoise", "lic", "incompressible"], "likes": 3, "viewed": 218, "published": "Public API", "date": "1610877767", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// variant of \"flow field art 2b\" https://www.shadertoy.com/view/WlGcWh\n// variant of \"field art\" https://shadertoy.com/view/wtVyRW\n\n#define hash2(p) fract(sin((p)*mat2(127.1,311.7, 269.5,183.3)) *43758.5453123)\n\n// --- flownoise from https://www.shadertoy.com/view/wdKXzd\n// gradient noise derived from https://www.shadertoy.com/view/XdXGW8\n\nfloat _z = 1.;\nvec2 hash( vec2 p ) \n{\n // float s = 0.;                      // standard Perlin noise\n    float s = mod(p.x+p.y,2.)*2.-1.;   // flow noise checkered rotation direction\n // float s = mod(floor(p.x)+floor(p.y),2.)*2.-1.;   // should be this but x is integer\n // float s = 1.;                      // flow noise universal rotation direction\n // s *= iTime;                        // same rotation speed at all scales\n    s *= iTime/ _z;                    // rotation speed increase with small scale    \n\n    return ( -1. + 2.*hash2(p) ) \n        *  mat2(cos( s + vec4(0,33,11,0))); // rotating gradients. rot: https://www.shadertoy.com/view/XlsyWX\n}\n\nfloat noise( vec2 p )\n{\n    vec2 i = floor( p ),\n         f = fract( p ),\n\t  // u = f*f*(3.-2.*f);\n         u = f*f*f* ( 10. + f * ( -15. + 6.* f ) ); // better for derivative. from http://staffwww.itn.liu.se/~stegu/TNM022-2005/perlinnoiselinks/paper445.pdf\n\n#define P(x,y) dot( hash( i + vec2(x,y) ), f - vec2(x,y) )\n    return mix( mix( P(0,0), P(1,0), u.x),\n                mix( P(0,1), P(1,1), u.x), u.y);\n}\n\n#define noise01(p) 1.5 * ( .5+.5* noise(p)-.18 )    // well fitted to [0,1] without saturation\n\nfloat perlin( vec2 p )                              // fractal noise\n{\t\n    mat2 m = mat2(2.); // mat2( 1.6,  1.2, -1.2,  1.6 );\n    float v  = 0.,s = 1.;\n    for( int i=0; i < 5; i++, s /= 2. ) { _z = s;   // for flownoise\n        v += s*noise01( p ); p *= m;                // variant using positive noise\n    }\n    return v;\n}\n\n// --- sampling inspired from https://www.shadertoy.com/view/lljczz\n\n#define srnd(p,s) ( 2.* fract( 4e4* sin( 1e3* mat2(1,7.1,-5.1,2.3) * (p) + 1e3*s )) -1. )\n\n// #define f(U)   noise01(U)\n// #define f(U)   noise01(ofs(U))\n   #define f(U) ( noise01(ofs(U)) + .5*noise01(2.*ofs(U)) ) / 1.2\n// #define f(U)   perlin(U) / 1.5     \n// #define f(U)   perlin(ofs(U)) / 1.5\n#define ofs(U) ( U *vec2(1,2) + vec2(.3*iTime,0) )\n\nvoid mainImage( out vec4 O,  vec2 u )\n{\n    vec2 R = iResolution.xy,\n         U = (2.*u-R)/R.y, p, P, X,V, x;\n    O-=O;       \n         \n    float v, n =   11., // R.y/32., // 11.                // number of cells (optim)\n          l = .08,                                        // stokes length\n       // d = 90.*pow((1.-U.y)/2.,1.7)*R.y/360.;          // strokes density\n       //   d = 90.*pow(max(f(U)-.25 -.0*U.y,0.),1.7)*R.y/360.;\n          d = 90.*pow(max(2.*(f(U)-.5) -.5*U.y,0.),1.7)*R.y/360.;\n    int N = 3; // int(3.*R.y/360.);                       // Neighborhood size = NxN . goes with l\n\n    p = floor(U*n+.5) / n;                                // cell center (NB: we should deffered /n )\n\n    for( int i=0; i<N*N; i++)                             // Worley optim. allows overflow to neighbor cell\n      for( float j=0.; j<d; j++) {                        // density loop\n        P = p + vec2( i%N -N/2, i/N -N/2 ) / n;           // cell coordinate in neighborhood\n        P +=     .5* srnd( round(P*n) , j) / n;           // jittering (round: for precision issues)\n        X = U-P,                                          // local coordinate\n        V; // =  f(.5*U);    // f(.5*P)                   // local field. f(U): curvy f(P): tangent \n        v = f(U); // v = V.x;\n        V = vec2(  dFdx(v), dFdy(v) ) * R.y;              // divergence-free  ( since we trace ortho(V) )  \n     // V = vec2( -dFdy(v), dFdx(v) ) * R.y;              // divergence-free  ( if we were tracing V )  \n\n        v = dot ( X , V );                                // distance to segment\n     // v /= fwidth(v);\n        v /= length(V) * 2.5/R.y;\n        O += // (1.-O)*                                    // blend ( comment out for add )\n             .25* max( 0., 1. - 1.3*abs(v) )               // draw segment of dir V and length .04\n               * clamp( ( l - length(X) ) *R.y ,0.,1.);\n}\n    \n // O -=  max(0., length(U)-.8 ) *R.y;                    // white out of circle\n    O = sqrt(1.-O*vec4(1,1,.5,0));                        // reverse + to sRGB\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WlyyDh.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[213, 358, 380, 444, 1006], [1008, 1008, 1031, 1031, 1419], [1517, 1517, 1587, 1587, 1846], [2137, 2267, 2306, 2306, 4327]]}
{"id": "WlyyDw", "name": "Caméra", "author": "Akanoa", "description": "Une caméra dans un monde en 3D", "tags": ["camra"], "likes": 0, "viewed": 40, "published": "Public", "date": "1611171462", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// https://www.desmos.com/calculator/t1iqt8tj9z?lang=fr\n\n#define MIN_DISTANCE   0.001\n#define MAX_DISTANCE   20.\n#define MAX_ITERATIONS 200\n\n\n#define MATERIAL_SPHERE1   1  \n#define MATERIAL_SPHERE2  2\n#define MATERIAL_GROUND 3\n\n\n#define PI 3.14159\n#define DEG2RAD 0.01745329251\n\nmat2 Rot(float a) {\n    float s = sin(a);\n    float c = cos(a);\n    return mat2(c, -s, s, c);\n}\n\n/**\n* m : index du matériau à appliquer\n* d : distance à la surface observée\n*/\nstruct Data {\n    float d;\n    int m;\n};\n\n\n/**\n* Calcul la distance signée en entre le point p et la surface de la sphère\n* p : point courant calculé par rapport à la sphère\n* r : rayon de la sphère\n* m : matériau à appliquer sur la surface de la sphère\n*/\nData sdSphere(vec3 p, float r, int m) {\n    return Data(length(p) - r, m);\n}\n\n/**\n* Calcule la distance signée entre le point p et la surface du plan de hauteur h\n* p : point courant calculé par rapport à la sphère\n* h : hauteur du plan par rapport à l'origine du monde\n* m : matériau à appliquer sur la surface du plan\n*/\nData sdPlanH(vec3 p, float h, int m) {\n    return Data(p.y - h, m);\n}\n\nData sdBox(vec3 p, vec3 b, int m) {\n    vec3 q = abs(p) - b;\n    float d = min(max(q.x,max(q.y,q.z)),0.0) + length(max(q,0.0));\n    return Data(d, m);\n}\n\nData sdTorus(vec3 p, vec2 t, int m) {\n    vec2 q = vec2(length(p.xz)-t.x,p.y);\n    float d = length(q)-t.y;\n    return Data(d, m);\n}\n\n\n\nData sdCylinder( vec3 p, float h, float r, int m)\n{\n  vec2 q = abs(vec2(length(p.xz),p.y)) - vec2(h,r);\n  float d = min(max(q.x,q.y),0.0) + length(max(q,0.0));\n  return Data(d, m);\n}\n\n\nData minData(Data d1, Data d2) {\n    \n    if(d1.d < d2.d) {\n        return d1;\n    }\n    return d2; \n}\n\nData maxData(Data d1, Data d2) {\n    \n    if(d1.d > d2.d) {\n        return d1;\n    }\n    return d2; \n}\n\nData minusData(Data d) {\n    return Data(-d.d, d.m);\n}\n\nData scene(vec3 p) {\n\n    vec3 cp1 = p - vec3(0,0,0);\n    cp1.xy *= Rot(90.0*DEG2RAD);\n    \n    Data c1 = sdCylinder(cp1, 0.35, 1.5, MATERIAL_SPHERE2);\n    \n    \n    vec3 cp2 = p - vec3(0,0,0);\n    Data c2 = sdCylinder(cp2, 0.35, 1.5, MATERIAL_SPHERE2);\n    \n    \n    vec3 cp3 = p - vec3(0,0,0);\n    cp3.yz *= Rot(90.0*DEG2RAD);\n    \n    Data c3 = sdCylinder(cp3, 0.35, 1.5, MATERIAL_SPHERE2);\n\n  \n    Data pl = sdPlanH(p, -1., MATERIAL_GROUND);\n    \n    \n    \n    Data s1 = sdSphere(p, 1.41421356237, MATERIAL_SPHERE2);  \n    \n    vec3 bp1 = p - vec3(0, 0.0, 0);\n    Data b1 = sdBox(bp1, vec3(1.0), MATERIAL_SPHERE1);\n    \n    \n\n    Data cr = minData(c1, c2);\n    cr = minData(cr, c3);\n    \n    \n    \n    //s = minData(b1, pl);\n    // Data s = minData(cr, b1);\n    \n    Data s = maxData(b1, s1);\n    s = maxData(minusData(cr), s);\n    \n    s = minData(s, pl);\n    \n    \n    return s;\n}\n\nData rayMarch(vec3 rO, vec3 rD) {\n    \n    float d = 0.0;\n    int m = 0;\n    for(int i=0; i < MAX_ITERATIONS; i++) {\n        \n        vec3 p =  rO + rD * d;\n        Data ds =  scene(p);\n        d += ds.d;\n        m = ds.m;\n        if (ds.d < MIN_DISTANCE || d > MAX_DISTANCE) break;\n    }\n    \n    return Data(d, m);\n\n}\n\n\nvec3 material(int index) {\n\n    vec3 col = vec3(0);\n\n    switch(index) {\n        case MATERIAL_SPHERE1:\n            col = vec3(0.8, 1.1, 5);\n            break;\n        case MATERIAL_SPHERE2:\n            col = vec3(1.0, 0.2, 0.3);\n            break;\n        case MATERIAL_GROUND:\n            col = vec3(1.0, 1.0, 0);\n        default:\n            break;\n    }\n    \n    return col * 0.2;\n        \n}\n\nvec3 normal(vec3 p) {\n    float dp = scene(p).d;\n    \n    float eps = 0.01;\n    \n    float dx = scene(p + vec3(eps, 0, 0)).d - dp;\n    float dy = scene(p + vec3(0, eps, 0)).d - dp;\n    float dz = scene(p + vec3(0, 0, eps)).d - dp;\n    \n    return normalize(vec3(dx, dy, dz));\n}\n\n\nfloat lighting(vec3 p, vec3 n, vec3 lp) {\n    \n    vec3 ld = lp - p;\n    vec3 ln = normalize(ld);\n    \n    float d = rayMarch(p + n * 0.01, ln).d;\n    \n    if (d < length(ld)) return 0.0;\n    \n    return max(0.0, dot(ln, n));\n    \n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - 0.5* iResolution.xy) / iResolution.y;\n    \n    vec2 mouse = iMouse.xy / iResolution.xy;\n    \n    \n    float k = 4.5;\n    float t = 0.1;\n    vec3 lp = abs(vec3(cos(iTime*t)*k, 2.0, sin(iTime*t)*k));\n    \n    \n    //vec3 camera = vec3(0, mouse.y, 0);\n    //vec3 screen = vec3(uv, 1.0);\n    \n    float phi = -DEG2RAD * -60.0;\n    float fov = 1.0;\n    float r = 4.0;\n    \n    vec3 eye = vec3(\n        cos(2.0 * PI * mouse.x + phi) * r,\n        mouse.y * 10., \n        sin(2.0 * PI * mouse.x + phi)* r\n    );\n    \n    \n    \n    vec3 target = vec3(0,0,0);\n    \n    // base vectorielle\n    vec3 forward = normalize(target-eye) ;\n    vec3 side = cross(vec3(0,1,0), forward);\n    vec3 up = cross(forward, side);\n    \n    vec3 screenPos = eye + fov*forward + uv.x * side + uv.y * up;\n    \n    vec3 rD = normalize(screenPos - eye);\n    \n    Data data =  rayMarch(eye, rD);\n    \n    // ciel\n    vec3 skyColDark = vec3(0.08, 0.3, 1.0);\n    vec3 skyColLight = vec3(0.5, 0.8, 1.0);\n    \n    vec3 col = mix(skyColLight, skyColDark, pow(uv.y + 0.5, 1.5));\n    \n    if(data.d < MAX_DISTANCE) {\n    \n       vec3 p = eye + rD * data.d;\n       vec3 n = normal(p);\n       float l = lighting(p, n, lp);\n       \n       vec3 m = material(data.m);\n       \n       col = m * l;\n       \n       vec3 ambiant = vec3(5, 0, 10) * 0.07;\n       vec3 ambiantSky = n.y * skyColLight;\n           \n       col = col * ( ambiant + ambiantSky + l);\n       \n    }\n    \n    // gamma \n    col = pow(col, vec3(0.4545));\n    \n    fragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WlyyDw.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 279, 298, 298, 374], [503, 726, 765, 765, 802], [804, 1056, 1094, 1094, 1125], [1127, 1127, 1162, 1162, 1279], [1281, 1281, 1318, 1318, 1413], [1417, 1417, 1468, 1468, 1599], [1602, 1602, 1634, 1634, 1704], [1706, 1706, 1738, 1738, 1808], [1810, 1810, 1834, 1834, 1864], [1866, 1866, 1886, 1886, 2752], [2754, 2754, 2787, 2787, 3073], [3076, 3076, 3102, 3102, 3471], [3473, 3473, 3494, 3494, 3750], [3753, 3753, 3794, 3794, 3985], [3988, 3988, 4045, 4045, 5585]]}
{"id": "WlyyDz", "name": "fBm example", "author": "hayama", "description": "The Hurst exponent H is moving between 0 and 1\nLeft: Perlin noise base\nRight: value noise base", "tags": ["bd202101"], "likes": 0, "viewed": 87, "published": "Public", "date": "1610762982", "time_retrieved": "2021-10-01T00:00:00", "image_code": "uvec3 k = uvec3(0x456789abu, 0x6789ab45u, 0x89ab4567u);\nconst uint max32 = 0xffffffffu;\nvec2 fragCoord_;\nvec2[8] gtable2 = vec2[](   //0.92387953 = cos(pi/8), 0.38268343 = cos(pi/8)\n    vec2(0.92387953, 0.38268343),\n    vec2(0.38268343, 0.92387953),\n    vec2(-0.92387953, 0.38268343),\n    vec2(-0.38268343, 0.92387953),\n    vec2(0.92387953, -0.38268343),\n    vec2(0.38268343, -0.92387953),\n    vec2(-0.92387953, -0.38268343),\n    vec2(-0.38268343, -0.92387953)\n);\nuint hash11u(uint n) {\n    n ^= (n << 24);\n    n ^= (n >> 1);\n    n ^= (n << 1);\n    return n * k.x;\n}\nvec2 hash22(vec2 p) {\n        uint n = hash11u(hash11u(uint(p.x)) + uint(p.y));\n        n = n >> 29;\n        n = n % 8u;\n        return gtable2[n];\n}\nfloat pnoise21(vec2 p) {\n    vec2 f = fract(p);\n    vec2 g00 = hash22(p);\n    vec2 g01 = hash22(p + vec2(0.0, 1.0));\n    vec2 g10 = hash22(p + vec2(1.0, 0.0));\n    vec2 g11 = hash22(p + vec2(1.0, 1.0));\n    float v00 = dot(g00, f);\n    float v01 = dot(g01, f - vec2(0.0, 1.0));\n    float v10 = dot(g10, f - vec2(1.0, 0.0));\n    float v11 = dot(g11, f - vec2(1.0, 1.0));\n    f = f * f * f * (10.0 - 15.0 * f + 6.0 * f * f); \n    float v = mix(mix(v00, v10, f.x), mix(v01, v11, f.x), f.y);\n    return 0.5 * v;\n}\n\nfloat hash21(vec2 p) {\n    uint n = hash11u(uint(p.x)) + uint(p.y);\n    return float(hash11u(n)) / float(max32);\n}\nfloat vnoise21(vec2 p) {\n    vec2 i = floor(p);\n    float v00 = hash21(i);\n    float v01 = hash21(i + vec2(0.0, 1.0));\n    float v10 = hash21(i + vec2(1.0, 0.0));\n    float v11 = hash21(i + vec2(1.0, 1.0));\n    vec2 f = fract(p);\n    f = f * f * (3.0 -2.0 * f); \n    return mix(mix(v00, v10, f.x), mix(v01, v11, f.x), f.y) - 0.5;\n}\n\nfloat fbm21(vec2 p, float G){\n    float val = 0.0;\n    float amp = 1.0;\n    float freq = 1.0;\n    for (int i = 0; i < 4; i++){\n        if (fragCoord_.x < 0.5 * iResolution.x){\n            val += amp * pnoise21(freq * p);\n        } else{\n            val += amp * vnoise21(freq * p);\n        }\n        amp *= G;\n        freq *= 2.01;\n    }\n    return val;\n}\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n    fragCoord_ = fragCoord;\n    vec2 pos = fragCoord.xy/min(iResolution.x, iResolution.y);\n    pos *= 20.0;\n    pos += iTime;\n    float G = abs(mod(0.2 * iTime, 1.0) - 0.5) + 0.5;\n    float v = 0.5 * fbm21(pos, G) + 0.5;\n    fragColor = vec4(vec3(v), 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WlyyDz.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[464, 464, 486, 486, 566], [567, 567, 588, 588, 716], [717, 717, 741, 741, 1226], [1228, 1228, 1250, 1250, 1342], [1343, 1343, 1367, 1367, 1674], [1676, 1676, 1705, 1705, 2031], [2032, 2032, 2086, 2086, 2345]]}
{"id": "wlyyRc", "name": "SDF determine voxel state", "author": "DragonWolf", "description": "Determines the state of a voxel (outside, edge or inside) given an SDF function by marching circles around the perimeter of a square of progressively smaller size until a minsize is reached (i.e. the size of pixel in this case)", "tags": ["sdfvoxel"], "likes": 0, "viewed": 44, "published": "Public", "date": "1611427942", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/*\n * Similar to my first two shaders of a similar name, but this one\n * effectively ray marches the perimeter of the voxel using circles\n * to check if the sdf lies inside the voxel to a given degree of accuracy (the size of a pixel).\n *\n * It also does the checks in a slightly larger are than the voxel to catch edge cases where an sdf resolves to\n * less than minstep size between two voxels.\n */\n\n#define gridSize1 2.0\n#define gridSize2 10.0\n#define gridSize3 30.0\n#define gridSize4 60.0\n\nfloat cornerRadiusMultiplier = 3.-2./sqrt(2.)-sqrt(2.);\n\nfloat sdBox( vec2 uv, vec2 position, in vec2 bounds )\n{\n    vec2 d = abs(position - uv)-bounds;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\nfloat sdCircle(vec2 uv, vec2 pos, float radius) {\n    return length(uv - pos) - radius;\n}\n\nvec2 pixelSize() {\n    return 2.0 * ((vec2(iResolution.x, iResolution.y) - (0.5*iResolution.xy))/iResolution.y) / iResolution.xy;\n}\n\nfloat sdf(vec2 uv) {\n\n    vec2 pixelSize = pixelSize();\n    \n    float screenEdgeMargin = 0.1;\n\n    float radius1 = 0.7 * (1.0 + sin(iTime * 0.6));\n    vec2 position1 = vec2(sin(iTime * 0.2) * (iResolution.x / iResolution.y) * (1. - screenEdgeMargin), sin(iTime * 0.10) * (1. - screenEdgeMargin));\n    float circle1 = sdCircle(uv, position1, radius1);   \n    \n    float radius2 = 0.4 * (1.0 + sin(iTime * 0.1));\n    vec2 position2 = vec2(sin(iTime * 0.4) * (iResolution.x / iResolution.y) * (1. - screenEdgeMargin), sin(iTime * 0.8) * (1. - screenEdgeMargin));\n    float circle2 = sdCircle(uv, position2, radius2);      \n    \n    // 1/10th the size of a pixel circles\n    float radius3 = 0.1 * min(pixelSize.x, pixelSize.y); \n    vec2 position3 = vec2(sin(iTime * 0.6) * (iResolution.x / iResolution.y) * (1. - screenEdgeMargin), sin(iTime * 0.6) * (1. - screenEdgeMargin));\n    float circle3 = sdCircle(uv, position3, radius3);   \n    \n    float radius4 = 0.1 * min(pixelSize.x, pixelSize.y); \n    vec2 position4 = vec2(sin(iTime * 0.8) * (iResolution.x / iResolution.y) * (1. - screenEdgeMargin), sin(iTime * 0.4) * (1. - screenEdgeMargin));\n    float circle4 = sdCircle(uv, position4, radius4);   \n    \n    return min(min(min(circle1, circle2), circle3), circle4);\n}\n    \nbool insideBoundingSquare(vec2 position, vec2 bound) {\n\n    vec2 pixelSize = pixelSize();\n\n    // We'll check just outside of the square to catch cases where the sdf resolves in sub-pixel level between\n    // two squares. This means we potentially treat a square as inside/touching when it isn't but better than\n    // artefacts due to this scenario.\n    vec2 adjustedBound = bound + pixelSize;\n\n    // If all points inside the grid's outer circle are negative, then we're definitely inside.\n    float midpointD = sdf(position);\n    if (midpointD < -length(adjustedBound)) {\n        return true;\n    } else if (abs(midpointD) < min(adjustedBound.x, adjustedBound.y)) {\n        // There is an sdf edge inside the inner circle, so must not be completely inside.\n        return false;\n    }\n\n    \n    // For each corner,\n    for (float x = 0.; x < 2.; x++) {\n        for (float y = 0.; y < 2.; y++) {\n            vec2 cornerDirection = normalize(vec2(-1.0 + 2. * x, -1.0 + 2.0 * y)); // -1.0, -1.0 to 1.0, 1.0\n            float r = adjustedBound.x; // Set radius of to radius of inner circle of square.\n            float distFromMidpoint = r; // Total distance from midpoint to corner circle midpoint.\n\n            // Keep shrinking the corner circle until we reach pixel size (or return a value inside).\n            while (r >= min(pixelSize.x, pixelSize.y)) {\n            \n                // Calculate size of inscribed circle in corner.\n                r = cornerRadiusMultiplier * r;\n                distFromMidpoint += r; // Move to midpoint of new circle\n                vec2 cornerCircleMidpoint = position + cornerDirection * distFromMidpoint;\n                distFromMidpoint += r; // Move to edge of circle for next circle\n                \n                // We march in a clock-wise direction around the perimeter.\n                float posOrNeg = 1. - x*2.; // 1 or -1\n                float applyX = abs(x-y); // 1 or 0\n                float applyY = abs(applyX - 1.); // 1 or 0\n                vec2 edgeDirection = vec2(applyX * posOrNeg, applyY * posOrNeg);\n                \n                // March along the edge.\n                for (float i = r; i < adjustedBound.x - r; i = i + r) {\n                    vec2 midpoint = cornerCircleMidpoint + i * edgeDirection;\n                    if (sdf(midpoint) > r) {\n                        return false;\n                    }\n                }\n            }\n        }\n    }\n    \n            \n    return true;\n}\n\nbool touchingBoundingSquare(vec2 position, vec2 bound) {\n\n    vec2 pixelSize = pixelSize();\n\n    // We'll check just outside of the square to catch cases where the sdf resolves in sub-pixel level between\n    // two squares. This means we potentially treat a square as inside/touching when it isn't but better than\n    // artefacts due to this scenario.\n    vec2 adjustedBound = bound + pixelSize;\n\n    // If all points inside the grid's outer circle are outside,\n    // then we're definitely outside and not touching.\n    float midpointD = sdf(position);\n    if (midpointD > length(adjustedBound)) {\n        // Doesn't touch outer circle, so must be completely outside sdf volume.\n        return false;\n    } else if (midpointD < min(adjustedBound.x, adjustedBound.y)) {\n        // Touches inner circle so must be inside square.\n        return true;\n    }\n\n    // For each corner,\n    for (float x = 0.; x < 2.; x++) {\n        for (float y = 0.; y < 2.; y++) {\n            vec2 cornerDirection = normalize(vec2(-1.0 + 2. * x, -1.0 + 2.0 * y)); // -1.0, -1.0 to 1.0, 1.0\n            float r = adjustedBound.x; // Set radius of to radius of inner circle of square.\n            float distFromMidpoint = r; // Total distance from midpoint to corner circle midpoint.\n\n            // Keep going until we reach pixel size or exit condition.\n            while (r >= min(pixelSize.x, pixelSize.y)) {\n            \n                // Calculate size of inscribed circle in corner.\n                r = cornerRadiusMultiplier * r;\n                distFromMidpoint += r; // Move to midpoint of new circle\n                vec2 cornerCircleMidpoint = position + cornerDirection * distFromMidpoint;\n                distFromMidpoint += r; // Move to edge of circle for next circle\n                float posOrNeg = 1. - x*2.; // 1 or -1\n                float applyX = abs(x-y); // 1 or 0\n                float applyY = abs(applyX - 1.); // 1 or 0\n                vec2 edgeDirection = vec2(applyX * posOrNeg, applyY * posOrNeg);\n                // March along the edge.\n                for (float i = r; i < adjustedBound.x - r; i = i + r) {\n                    vec2 midpoint = cornerCircleMidpoint + i * edgeDirection;\n                    if (sdf(midpoint) <= r) {\n                        return true;\n                    }\n                }\n            }\n        }\n    }\n    \n    return false;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 pixelSize = pixelSize();\n\n    // Normalized pixel coordinates (from y = -1 to 1 with 0,0 in the center of the screen)\n    vec2 uv = 2.0 * (fragCoord - (0.5*iResolution.xy))/iResolution.y;\n    \n    vec2 minScreenExtent = 2.0 * (vec2(0,0) - (0.5*iResolution.xy))/iResolution.y;\n    vec2 maxScreenExtent = 2.0 * (iResolution.xy - (0.5*iResolution.xy))/iResolution.y;\n    \n    // Calculate SDF\n    float d = sdf(uv);\n\n    float gridSize;\n    if (uv.x > minScreenExtent.x + 3. * (maxScreenExtent.x - minScreenExtent.x) / 4.) {\n        gridSize = gridSize4;\n    } else if (uv.x > minScreenExtent.x + 2. * (maxScreenExtent.x - minScreenExtent.x) / 4.) {\n        gridSize = gridSize3;\n    } else if (uv.x > minScreenExtent.x + 1. * (maxScreenExtent.x - minScreenExtent.x) / 4.) {\n        gridSize = gridSize2;\n    } else {\n        gridSize = gridSize1;\n    }\n\n    // Bounding Box\n    vec2 voxelMidpoint = vec2((floor(uv.x * gridSize) / gridSize) + (0.5 / gridSize), (floor(uv.y * gridSize) / gridSize) + (0.5 / gridSize));\n    vec2 voxelSize = vec2(0.5 / gridSize, 0.5 / gridSize);\n    vec2 minExtent = voxelMidpoint - voxelSize;\n    vec2 maxExtent = voxelMidpoint + voxelSize;\n    float box1 = sdBox(uv, voxelMidpoint, voxelSize);\n    \n    // Work out if the SDF is inside the box or not.\n    bool touching = touchingBoundingSquare(voxelMidpoint, voxelSize);\n    bool inside = false;\n    if (touching) {\n        inside = insideBoundingSquare(voxelMidpoint, voxelSize);\n    }\n    \n    bool outside = !touching;\n\n    vec3 statusColor = vec3(1.0, 1.0, 0.0);\n    if (inside) {\n        statusColor = vec3(0.0, 1.0, 0.0);\n    } else if (outside) {\n        statusColor = vec3(1.0, 0.0, 0.0);\n    }\n\n    // Set base colour depending on inside or outside bounding box.\n    vec3 baseColor = vec3(0.1,0.4,0.7);\n    if (uv.x > minExtent.x && uv.x < maxExtent.x && uv.y > minExtent.y && uv.y < maxExtent.y) {\n        baseColor = vec3(0.8,0.2,0.2);\n    }\n   \n    // Taken from iq to visualize sdf distances (https://www.shadertoy.com/view/4lcBWn)    \n    vec3 col = vec3(1.0) - sign(d)*baseColor;\n\tcol *= 1.0 - exp(-3.0*abs(d));\n\tcol *= 0.8 + 0.2*cos(120.0*d);\n\tcol = mix( col, vec3(1.0), 1.0-smoothstep(0.0,0.008,abs(d)));\n    \n    // Add the grid\n    col = mix( col, statusColor, 1.0-smoothstep(0.0,0.008,abs(box1)) );\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wlyyRc.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 551, 606, 606, 703], [705, 705, 754, 754, 794], [796, 796, 814, 814, 927], [929, 929, 949, 949, 2198], [2204, 2204, 2258, 2258, 4670], [4672, 4672, 4728, 4728, 7048], [7050, 7050, 7107, 7107, 9479]]}
{"id": "wlyyRK", "name": "Circles grows", "author": "supah", "description": "grow", "tags": ["circles"], "likes": 2, "viewed": 67, "published": "Public", "date": "1611314492", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord.xy-0.5*iResolution.xy)/iResolution.y;\n    vec3 gradient = vec3(1.-length(uv), 0.3, 0.4);\n    float ray = mod(length(uv) - iTime * .2, .3);\n    vec3 col = vec3(ray) * gradient;\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wlyyRK.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 291]]}
{"id": "wlyyRW", "name": "T_Plotting", "author": "Thalikoth", "description": "plotting test", "tags": ["plotplotting"], "likes": 1, "viewed": 148, "published": "Public API", "date": "1611669226", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n#define PI 3.14159265359\n\n\nfloat noise(float x) {\n    return fract(sin(x)*345.456);\n}\n\nfloat noise(vec2 x) {\n    return fract(sin(dot(x, vec2(2234.456, 1567.789)))*423.234);\n}\n\n// smooth gradient noise\nfloat grNoise(float x, float k) {\n\n    x *= k;\n    \n    // get integer / fractional parts\n    float i = floor(x);\n    float f = fract(x);\n\n    // smooth interpolation\n    float n1 = noise(i); \n    float n2 = noise(i+1.);\n    return mix(n1, n2, smoothstep(0., 1., f));\n}\n\nvec2 rotate(vec2 v, float a) {\n\tfloat s = sin(a);\n\tfloat c = cos(a);\n\tmat2 m = mat2(c, -s, s, c);\n\treturn m * v;\n}\n\nfloat noiseLine(vec2 uv) {\n    uv.y -= grNoise(uv.x + iTime, 2. + sin(iTime*0.002));\n    \n    return smoothstep(0.02, 0., uv.y) -\n            smoothstep(0., -0.02, uv.y);\n    \n}\n\nfloat sineLine(vec2 uv) {\n    uv.y += .6;\n    uv.x += iTime / .9;\n    uv.y -= sin(uv.x * 6.) / 5.;\n    \n    return smoothstep(0.02, 0., uv.y) -\n            smoothstep(0., -0.02, uv.y);\n    \n}\n\nfloat axis(vec2 uv) {\n    float y = smoothstep(0.005, 0., uv.y) -\n            smoothstep(0., -0.005, uv.y);\n    float x = smoothstep(0.005, 0., uv.x) -\n            smoothstep(0., -0.005, uv.x);\n    return x + y;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    uv -= .5;\n    uv.y *= iResolution.y / iResolution.x;\n\n    uv *= 5.;\n\n    vec3 col = vec3(0.);\n    \n    \n    \n    col = vec3(axis(uv));\n    col.r = noiseLine(uv);\n    col.b = sineLine(uv);\n    \n    \n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wlyyRW.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[28, 28, 50, 50, 86], [88, 88, 109, 109, 176], [178, 203, 236, 236, 472], [474, 474, 504, 504, 588], [590, 590, 616, 616, 767], [769, 769, 794, 794, 960], [962, 962, 983, 983, 1175], [1178, 1178, 1235, 1285, 1565]]}
{"id": "wlyyWd", "name": "Rollin out", "author": "Plento", "description": "swoosh", "tags": ["3d", "orthographic"], "likes": 12, "viewed": 214, "published": "Public API", "date": "1612087138", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Cole Peterson\n\n#define R iResolution.xy\n#define ss(a, b, t) smoothstep(a, b, t)\n#define rot(a) mat2(cos(a), -sin(a), sin(a), cos(a))\n\nfloat sub(float d1, float d2){return max(-d1, d2);}\n\nfloat sdBox( vec3 p, vec3 b ){\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z))-.04,0.0);\n}\n\nfloat hash12(vec2 p){\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nvoid trn(inout vec3 p){\n    p.yz*=rot(-0.8);\n    p.xy*=rot(0.475);\n    p.x += iTime + 50.;\n}\n\n#define b vec3(5., 5., 0.)\n\nfloat map(vec3 rp){\n    float d = 999.;\n    vec3 p = rp-vec3(0., -5., 9.);\n    vec3 pp = p;\n    trn(pp);\n    \n    for(float i = 0.; i < 2.; i++){\n        p = pp;\n        vec3 id = floor(p / max(b, 0.0001));\n        p.z += i*-5.;\n    \n        float rnd = hash12(i*33.+id.xy*vec2(333., 588.));\n        p = mod(p, b)-b*.5;\n        \n        p.xz *= rot(sign(rnd-0.5)*.8*iTime+id.x+id.y);\n        p.xy *= rot(sign(rnd-0.5)*.8*iTime+id.x+id.y);\n    \n        d = min(sdBox(p, vec3(1.6 - rnd*0.2, 1.6 - rnd*0.4, 1.0 + rnd*0.9)), d);\n        if(rnd > 0.4) d=sub(length(p)-1.68, d);\n    }\n    \n    return d;\n}\n\n\nvec3 normal( in vec3 pos ){\n    vec2 e = vec2(0.002, -0.002);\n    return normalize(\n        e.xyy * map(pos + e.xyy) + \n        e.yyx * map(pos + e.yyx) + \n        e.yxy * map(pos + e.yxy) + \n        e.xxx * map(pos + e.xxx));\n}\n\n\nvoid mainImage( out vec4 f, in vec2 u ){\n    vec2 uv = vec2(u.xy - 0.5*R.xy)/R.y;\n    vec3 rd = normalize(vec3(0., 0.0, 1.));\n    vec3 ro = vec3(uv * 12., 0.);\n    \n    float d = 0.0, t = 0.0, ns = 0.;\n    for(int i = 0; i < 44; i++){\n    \td = map(ro + rd*t); \n        if(abs(d) < 0.01 || t > 40.)break;\n        t += d * .55;\n        ns++;\n    }\n    \n    vec3 p = ro + rd*t;\n    vec3 n = normal(p);\n    \n    vec3 lp = vec3(-2., 37.0, -30.);\n    vec3 ld = normalize(lp-p);\n    \n    float dif = max(dot(n, ld), .3);\n    vec3 col = .43 + .3*cos(vec3(0.5, 2., 1.1)*(n.x+n.y+n.z)*1.2 + vec3(2., 1.8, 0.2));\n    \n    col *= max(ss(1.85, 0.6, ns/24.), 0.03) * dif;\n    \n    col = mix(vec3(0.0), col, exp(-t*t*t*0.0001));\n    col = pow(col*1.4, vec3(1.85));\n    \n    col*=ss(.42, .419, abs(uv.y));\n    \n    f = vec4(sqrt(clamp(col, .0, 1.)), 1.);\n}\n\n\n\n\n\n\n\n\n\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wlyyWd.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 137, 167, 167, 188], [190, 190, 220, 220, 311], [313, 313, 334, 334, 451], [453, 453, 476, 476, 545], [575, 575, 594, 594, 1174], [1177, 1177, 1204, 1204, 1405], [1408, 1408, 1448, 1448, 2248]]}
{"id": "wlyyzD", "name": "Ink cave", "author": "intrakits", "description": "I was playing around with gyroids and managed to make something I felt is cool. Not sure why i have a strange warping effect (maybe I'm over marching?), but I think it ended up making it look cool anyways.", "tags": ["3d", "ink", "cave", "gyroid"], "likes": 0, "viewed": 151, "published": "Public API", "date": "1610572395", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define MAX_STEPS 200\n#define MAX_DIST 100.\n#define SURFACE_DIST 0.01\nmat2 Rot(float a) {\n    float s=sin(a), c=cos(a);\n    return mat2(c, -s, s, c);\n}\nfloat sdCylinder(vec3 p, vec3 a, vec3 b, float r, float offX, float offY, float offZ) {\n\ta.x += offX;\n    b.x += offX;\n    \n    a.y += offY;\n    b.y += offY;\n    \n    a.z += offZ;\n    b.z += offZ;\n    \n    vec3 ab = b-a;\n    vec3 ap = p-a;\n    \n    float t = dot(ab, ap) / dot(ab, ab);\n    \n    vec3 c = a + t*ab;\n    \n    float x = length(p-c)-r;\n    float y = (abs(t-.5)-.5)*length(ab);\n    float e = length(max(vec2(x, y), 0.));\n    float i = min(max(x, y), 0.);\n    \n    return e+i;\n}\n\nfloat sdCapsule(vec3 p, vec3 a, vec3 b, float r){\n    //line from a to b\n    vec3 ab = b-a;\n    \n    // line from p to a\n    vec3 ap = p-a;\n    \n    // as p approaches a, it will be 1\n    // as p approaches b it will b 0\n    float t = dot(ab,ap) / dot(ab,ab);\n    \n    // clamp values between 0 and 1\n    t= clamp(t,0.,1.);\n    \n    // center point of the capsule\n    // start at a (top of capsule)\n    // go towards b, t steps\n    vec3 c = a + t*ab;\n    \n    float d = length(p-c)-r;\n    \n    return d;\n}\n\nfloat sdTorus(vec3 p, vec2 r){\n    float x = length(p.xz)-r.x;\n    return length(vec2(x, p.y))-r.y;\n}\n\nfloat dBox(vec3 p, vec3 s){\n    return length(max(abs(p)-s,0.));\n}\nfloat sdGyroid(vec3 p, float scale, float thickness, float bias) {\n\tp *= scale;\n    return abs(dot(sin(p), cos(p.zxy))-bias)/scale-thickness;\n}\nfloat GetDist(vec3 p){\n    \n    float g1 = sdGyroid(p, 10., .03, 1.);\n    float g2 = sdGyroid(p, 10.76, .03, .3);\n    float g3 = sdGyroid(p, 20.76, .03, .3);\n    float g4 = sdGyroid(p, 35.76, .03, .3);\n    float g5 = sdGyroid(p, 60.76, .03, .3);\n    float g6 = sdGyroid(p, 110.76, .03, .3);\n    g1 -= g2*.4;\n    g1 -= g3*.3;\n    g1 += g4*.2;\n    g1 += g5*.2;\n    g1 += g6*.3;\n    vec2 uv = vec2(sin(p.x*4.)*.5+.5,cos(p.z*3.)*.5+.5);\n    float disp = texture(iChannel0,uv).r;\n    g1-=disp*.05*sin(iTime);\n    float box = dBox(p, vec3(5));\n    float d = max(g1,box);\n\n    return d;\n}\nfloat RayMarch(vec3 ro, vec3 rd){\n    // distance from origin\n    float dO=0.;\n    // march until max steps is achieved or object hit\n    for(int i=0; i <MAX_STEPS; i++){\n        // current point being evaluated\n        vec3 p = ro + dO*rd;\n        \n        // get distance to seam\n        float ds = GetDist(p);\n        //move origin to new point\n        dO+=ds*.1;\n        if(ds < SURFACE_DIST || dO > MAX_DIST){\n            break;\n        }\n    }\n    return dO;\n}\nvec3 GetNormal(vec3 p){\n    //distance to point being analyzed\n    float d = GetDist(p);\n    \n    //distance to another point along the objects surface that is closeby\n    vec2 e = vec2(0.01,0);\n    \n    //slope between the two points\n    //note: swizzel is the .xxy or .yyx etc\n    vec3 n = d - vec3(\n         GetDist(p-e.xyy),\n         GetDist(p-e.yxy),\n         GetDist(p-e.yyx));\n         \n    return normalize(n);\n    \n}\nfloat GetLight(vec3 p){\n    //position of the light source\n    vec3 lightPos = vec3(0,0,0);\n    \n    lightPos.xz *= Rot(sin(iTime));\n    //light vector\n    vec3 l = normalize(lightPos-p+vec3(4,0,0));\n    \n    //normal of object\n    vec3 n = GetNormal(p);\n    \n    // dot product of the light vector and normal of the point\n    // will give us the amount of lighting to apply to the point\n    // dot() evaluates to values between -1 and 1, so we will clamp it\n    float diff = clamp(dot(n, l),0.,1.);\n    \n    // calculate if point should be a shadow:\n    // raymarch from point being calculated towards light source\n    // if hits surface of something else before the light,\n    // then it must be obstructed and thus is a shadow\n    // the slight offset \"p+n*SURFACE_DIST*1.1\" is needed to ensure the\n    // break condistions in the function are not met too early\n    float d = RayMarch(p+n*SURFACE_DIST*1.1,l);\n    if(d < length(lightPos-p)){\n        diff *= 0.1;\n    }\n    return diff;\n}\nvec3 GetRayDir(vec2 uv, vec3 p, vec3 l, float z) {\n    vec3 f = normalize(l-p),\n        r = normalize(cross(vec3(0,1,0), f)),\n        u = cross(f,r),\n        c = f*z,\n        i = c + uv.x*r + uv.y*u,\n        d = normalize(i);\n    return d;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from -0.5 to 0.5)\n    // origin is now (0,0)\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    vec2 m = iMouse.xy/iResolution.xy;\n    vec3 col = vec3(0);\n    \n    //camera\n    //-----------------\n    // ray origin\n    //controls position\n    vec3 ro = vec3(0.,-0.1,sin(iTime*.1));\n  //  ro.yz *= Rot(-m.y*3.14+1.);\n   // ro.xz *= Rot(sin(iTime)*.6+3.);\n   // ro.yz *= -Rot(sin(iTime)*.1+5.);\n    \n    //ray dir\n    //controls rotation\n    vec3 rd = GetRayDir(uv, ro, vec3(0), 1.);\n    rd.xz *= Rot(sin(iTime)*.6+3.);\n    //------------------\n    float d = RayMarch(ro,rd);\n    // position of point\n    // start at ray origin\n    // move d units in the ray direction\n    vec3 p = ro + rd *d;\n    \n    \n    \n    //color objects\n    if(d < MAX_DIST){\n        \n        //get normals\n        vec3 n = abs(GetNormal(p));\n        \n        \n        float g1 = sdGyroid(p, 5.23, .03, 1.4);\n        float g2 = sdGyroid(p, 10.76, .03, .3);\n        float g3 = sdGyroid(p, 20.76, .03, .3);\n        float g4 = sdGyroid(p, 35.76, .03, .3);\n        float g5 = sdGyroid(p, 60.76, .03, .3);\n        float g6 = sdGyroid(p, 110.76, .03, .3);\n        g1 -= g2*.4;\n        g1 -= g3*.3;\n        g1 += g4*.2;\n        g1 += g5*.2;\n        g1 += g6*.3;\n        vec2 uv = vec2(sin(p.x*4.)*.5+.5,cos(p.z*3.)*.5+.5);\n        float disp = texture(iChannel0,uv).r;\n        g1-=disp*.05;\n        float box = dBox(p, vec3(4));\n        float d = max(g1,box);\n        col = d*vec3(1)*50.;\n        col = max(col,disp*vec3(1,0,0)*3.);\n        col = max(col,g2*vec3(0,1,0)*50.);\n       \n        col *= smoothstep(-.1, .1, g2);\t// blackening\n        //get diffuse lighting\n        float diff = GetLight(p);\n        col *= vec3(diff);\n        \n\n    }\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": "4sf3Rn", "previewfilepath": "/media/ap/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wlyyzD.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[70, 70, 89, 89, 151], [152, 152, 239, 239, 640], [642, 642, 691, 714, 1147], [1149, 1149, 1179, 1179, 1250], [1252, 1252, 1279, 1279, 1318], [1319, 1319, 1385, 1385, 1462], [1463, 1463, 1485, 1485, 2044], [2045, 2045, 2078, 2106, 2511], [2512, 2512, 2535, 2574, 2937], [2938, 2938, 2961, 2996, 3928], [3929, 3929, 3979, 3979, 4170], [4171, 4171, 4228, 4310, 6022]]}
{"id": "Wlyyzt", "name": "NickyDrinks Magic Plasma Field", "author": "NickyDrinks", "description": "I'm not breaking the laws of physics or graphics but it compiles and works. It took me 3 hours to realise the calculations went nowhere but the fps was super high and I bet David Copperfield probably couldn't even fly the first time he jumped.", "tags": ["tutorial", "plasma", "beginner", "easy", "firstshader", "commented", "power", "nickydrinks", "nopascal2d"], "likes": 0, "viewed": 71, "published": "Public", "date": "1611517591", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Hello, this is NickyDrinks off Street Fighter 3 online from about 2007. Let's draw a plasma and try not to melt our eyes \n// I reckon this effect is a good place to start with HLSL because nobody wants to start off with a shape that just sits there doing nothing\n// Probably best not to copy exactly what I've done because with 3D graphics I tend to hard-code \"fixes\" that come back to haunt me. This is actually all 2D though so it'll be fine.\n// Anything with the two forward slashes is ignored so you can write whatever you want and the compiler can do nothing about it, not a thing\n// There's more commenting here than there is actual code, our old lecturer would either be super pleased or raging\n// Who lectures in graphics coding then runs the stuff in software mode anyway? I didn't know he didn't even have a Voodoo 1 never mind a Voodoo 2 \n\nfloat pi = 3.1415926535897932384626433832795; // Here we speak to the machine, and it hears us telling it what we want something called pi to be. Wnat is pi? Who cares! You could waste time calculating it but adding more accuracy only leads to misery.\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )  // tell the machine that it's time to start the shading, actual graphics, the plasma coils are warming up\n\n{\n \nfloat hue; // It's the value of Red, Green and Blue that we're changing but I'd already used \"hue\" all over the place so just kept it, newcol or something may have been even faster\n// float x = (iResolution.x)*1.0;    // I can comment out the worst code in the world and the compiler is powerless to stop me\n// float y = (iResolution.y)*1.0;    // At some point I was going to use seperate x and y variables and then copy that to uv.x and uv.y but I changed my mind\n\nvec2 uv = vec2(fragCoord/iResolution.xy-0.4); //normalise xy coords to (0,1) so that the thing will actually work and copy them into vec2 uv so you can point at them with uv.x and uv.y and do all maths and stuff.....then maybe add or subtract a bit after you've written the rest of the code just to \"adjust\" things\n// All that does is stop the numbers going above 1 or below -1, it sounds cooler the other way though and makes sense because you don't know what resolution it'll be running in so this way it looks the same no matter where it runs (mostly). Y is up, anyone who says different is wrong, sort of like how North is up and South is down.\n   \nuv+=(sin(uv.x*3.5+iTime)); //generate a SINUSOID (the main ingredient of pure plasma power) on the x-axis, also add the current value of Time to start giving us movement because it's a value that will change each time this code is run and it'll run faster than you think. Way faster than that even. Faster.\n//uv+=(sin(uv.y*1.0+iTime));  // Surely doing the same on the other axis will mean it is twice as good? Not exactly but if you remove the comment tags it'll change...values\n   \nuv+= sin(2.5*(uv.x*sin(iTime/2.0)+uv.y*cos(iTime/2.0))+iTime); // Do some more sin and cos on x and y coords, now we are building up the plasma power like it's 1990. \n\n// From here onwards we can clearly see the initial work infering that, given Junglist as a singular set, there should exist a linear model where iteration results in a level of massivity previously observed or estimated at live events (Simenon et al., 1988) \n\nhue=(sin(7.0*(sqrt(pow(uv.x, 2.0) + pow(uv.y, 2.0)) + (0.5 + iTime)/2.0)-1.5)); //This is it, the big one, the main event. The actual equation looks complicated but when you look at it broken up into a series of calculations it's really not. Try different values for approx 1 hour to dial in maximum power\n\n// You can put anything in here and it'll just ignore it. You could even just delete it or add wisdom from Coolio : \n// \"Power and the money, money and the power\n//  Minute after minute, hour after hour\n//  Everybody's runnin', but half of them ain't lookin'\n//  It's goin' on in the kitchen, but I don't know what's cookin'\"\n\nvec3 col = vec3(sin(hue*pi)+.7, sin(hue*pi+2.0*pi/3.0)+0.4, sin(hue*pi+4.0*pi/3.0)); // Unleash the power of mother nature finally bent to your will to change the numbers, giving us a new value and then just sort of steer it towards Groove Is In The Heart\n\nfragColor = vec4(col,1.0); // Unlike Coolio we know that we've been cooking so we copy our new value into vec4 and fire it out of the GPU directly into the viewer's eyes and mind using electricity, BANG! We have transformed boring numbers into raw graphics magic!\n}  \n// Don't delete the \"}\" in the line above by accident or you will enrage the compiler and make it refuse to activate the plasma power hidden inside the computer\n\n// That's it, from there it goes back and does the whole thing again for every single pixel (each pixel comes in claiming to be called \"fragCoord\" but with a different value of X and Y so it covers all the places where it can draw stuff, if anyone asks call it a canvas and not a screen or you'll attract the really mad Linux people, the ones with no plasma power. It just keeps doing that until either the universe ends or you close the browse. Which will happen first? Who can say.\n// It may look absolutely awful initially but since iTime is in there with some sin'ing and cos'ing all over the show it'll still be animated\n// Now just think up some other effects and you are ready for Assembly, if you need music just download something like Renoise and play random bits of the Amen break\n// Don't add in any code written in Pascal unless you are Trug who used to be in Future Crew making a surprise comeback or revealing The Probe like they did with Panic but much more elaborate.\n// If at any point a change you make gives a better looking effect then keep it because it means you have improved the code and increased the power going to the plasma coils or the TARDIS or something.\n// If you think this editor is frustrating you should give POV-Ray a go in DOS using edit.com. The preview window was inside your head and the pixels didn't come up as fast.\n// Be glad that you decided against glslsandbox because no matter how horrible the graphics are at least they won't fill your entire field of vision and make you feel like you are about to die.\n// Now it's time to start a brand new shader and make an effect nobody has ever seen before, most stuff has already been done with either particles, voxels (or whatever they're called now), good old polygons or a mixture of them all so that's quite hard but I believe in you, like a rubbish Splinter who only really knows one move.\n// Warmest Regards,\n// NickyDrinks.\n\n\n\n\n\n// I did a quick port over to GLSL just out of interest to see what that was like. I think I'll stick with this \n// Easier debugging on there but ruined by the absolutely insane choice not to allow an opaque editing window, unless I'm missing something which is 100% likely. Seeing parented code side by side with another? No problem. Readable text? No chance.\n// http://glslsandbox.com/e#70904.2\n\n// If you ever want a laugh try and follow Nvidia's documentation, at least it's a good example of how not to do anything. Never follow it, there's always a bit at the end that tells you it's out of date and even that's out of date or just actual bollocks. \n// Who doesn't include cuda drivers in the dev image of a box that only exists because it has cuda cores? The same people who sell Nintendo chips with a known, totally unpatchable exploit, I bet it was on that hellish website somewhere, behind an old Voodoo 3 box design maybe. Christ almighty it's so bad, you get different pages depending on what angle you approach from. I dread to think what's on there that shouldn't be.\n// \"Don't let our super secret compiler out!\" Then don't whack it in a zip file and send it to everyone who makes the mistake of installing your \"experience\"! At least it was still totally broken so of no use to anyone.\n// Clang took one look at \"Jarvis\" and crashed Windows just to save time, 50GB of memory it was willing to take down with it. And it was right.\n// Give your computer the powers of a drunken, confused Tony Stark and Paul Bettany if he was a calculator from 1989", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Wlyyzt.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[900, 1107, 1272, 1272, 4464]]}
{"id": "Ws3BD7", "name": "Binary Forest p_i_i", "author": "public_int_i", "description": "binary forest", "tags": ["binary", "forest"], "likes": 5, "viewed": 148, "published": "Public API", "date": "1609535837", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/*Ethan Alexander Shulman 2020 - xaloez.com\n4k 60fps video https://www.youtube.com/watch?v=2svR2QJQSUA\n4k wallpaper xaloez.com/art/2020/BinaryForest.png*/\n\n#define PI 3.14159265358\n\nmat2 r2(float a) {\n\tfloat sn = sin(a), cs = cos(a);\n\treturn mat2(cs,-sn,sn,cs);\n}\n\nmat2 rot2(float a) {\n\tfloat s = sin(a), c = cos(a);\n\treturn mat2(c,s,-s,c);\n}\nfloat usquare(vec2 p, vec2 s) {\n\treturn length(max(abs(p)-s,0.));\n}\n\nfloat tree(vec2 p, float n, float w) {\n\tfloat y = p.y*n, b = floor(y), x = pow(2.,b),\n\t s = p.x*x, i = floor(s),\n\t rot = (mod(i,2.)-.5);\n\tvec2 uv = vec2(s-i,y-b)*2.-1.;\n\tuv.x /= 1.-(uv.y*.5+.5)*max(0.,w-.175)/(w/.45);\n\tif (b > .5) {\n\t\tif (w < .175) uv.x += rot*(1.-(uv.y*.5+.5))*(1.-w/.175)*.35;\n\t\tuv *= rot2(rot*-.25*3.14);\n\t\tuv.x += rot*.77;\n\t}\n\treturn usquare(uv,vec2(w,2.))/x;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float time = iTime, screenY = iResolution.y;\n    vec2 uv = (fragCoord*2.-iResolution.xy)/iResolution.y;\n        \n\tfloat s = 0.;\n\tfor (float x = -2.; x < 3.; x++) {\n\t\tfor (float y = -2.; y < 3.; y++) {\n\t\t\tvec2 rp = mod((uv.xy+vec2(x,y)*.777*.5/screenY)/(.4+time*.2)+100.5,.6)-.3,\n\t\t\t\tap = vec2(atan(rp.y,rp.x)/3.14,length(rp)*2.357022);\n\t\t\ts += max(0.,1.-tree(ap,.9+time,0.01)*(1e-5+ap.y)*1000.);\n\t\t}\n\t}\n\ts /= 25.;\n\tfragColor = vec4(s,s,s,1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Ws3BD7.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 182, 200, 200, 263], [265, 265, 285, 285, 342], [343, 343, 374, 374, 410], [412, 412, 450, 450, 794], [797, 797, 854, 854, 1302]]}
{"id": "WsBcDy", "name": "mANDALA", "author": "merrecurent_", "description": "deq", "tags": ["noob"], "likes": 0, "viewed": 146, "published": "Public API", "date": "1610576934", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float flower(vec2 origin, float resz, float petals, float angs, float expon, float c_lol, float thicc){\n\tfloat mandala = 0.;\n    \n    vec2 polar = vec2(atan(origin.x, origin.y), length(origin));\n    origin = vec2(polar.x/6.2831*petals-iTime*angs, polar.y*sin(iTime));\n    \n    float x = origin.x*resz;\n    float m = c_lol - pow(min(fract(x), fract(1.-x)),expon);\n    \n\tmandala = smoothstep(0., .03, m-origin.y)-smoothstep(0., .03, m-thicc-origin.y);\n    \n    return mandala;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n\tuv -= .5;\n    uv.x *= iResolution.x/iResolution.y;\n    \n    vec2 st = vec2(atan(uv.x, uv.y), length(uv));\n    \n    vec3 Mandala = flower(uv, 5., 2., .1, 2., .25, .1)*vec3(1., .7, .6)\n        \t\t + flower(uv, 3., 5., -.3, 1., .5, .05)*vec3(.07, .78, .07);\n        \t\t //+ flower(uv, 8., );\n    \n    // Output to screen\n    fragColor = vec4(Mandala, 1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WsBcDy.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 103, 103, 476], [478, 478, 535, 535, 929]]}
{"id": "WsBcWc", "name": "SHaDoW", "author": "merrecurent_", "description": "bcjal", "tags": ["noob"], "likes": 1, "viewed": 151, "published": "Public API", "date": "1610576831", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float distance_from_figure(vec3 p, vec3 c_1, float r_1, vec3 c_2, float r_2, float altitude)\n{\n\treturn min(min(length(p-c_1) - r_1 + sin(5.0*p.x + 3.*iTime) * sin(5.*p.y-2.*iTime) * sin(4.*p.z-2.*iTime) * .4 *(1.5 + .5*sin(2.5*iTime)),\n               length(p-c_2) - r_2), p.y - altitude);\n}\n\nfloat map_the_world(vec3 p)\n{\t\n    float sphere_0 = distance_from_figure(p, vec3(0.), 1., vec3(4., 0., 4.), 1.7, -2.);    \n    return sphere_0;\n}\n    \n\nvec3 calculate_normal (vec3 p)\n{\n\tconst vec3 small_step = vec3(.001, 0., 0.);\n    \n    float gradient_x = map_the_world(p + small_step.xyy)\n        \t\t\t - map_the_world(p - small_step.xyy);\n    float gradient_y = map_the_world(p + small_step.yxy)\n        \t\t\t - map_the_world(p - small_step.yxy);\n    float gradient_z = map_the_world(p + small_step.yyx)\n        \t\t\t - map_the_world(p - small_step.yyx);\n    \n    vec3 normal = vec3(gradient_x, gradient_y, gradient_z);\n    return normalize(normal);\n}\n\n\nvec3 ray_march(vec3 ro, vec3 rd, vec3 backtrack)\n{\n\tfloat total_distance_traveled = 0.;\n    const int NUMBER_OF_STEPS = 250;\n    const float MINIMUM_HIT_DISTANCE = .001;\n    const float MAXIMUM_TRACE_DISTANCE = 1000.;\n    \n    for (int i=0; i < NUMBER_OF_STEPS; ++i)\n    {\n    \t//Calculate our current position along the ray\n        vec3 current_position = ro + total_distance_traveled*rd;\n        \n        //assume that sphere is centered at the origin\n        float distance_to_closest = map_the_world(current_position);\n        \n        if(distance_to_closest < MINIMUM_HIT_DISTANCE)\n        {\n            \n            //we hit smthg\n            \n            vec3 normal = calculate_normal(current_position);\n            vec3 light_position = vec3(5.*cos(iTime), -10., 5.*sin(iTime));\n            vec3 direction_to_light = normalize(current_position - light_position);\n            float diffuse_intensity = max(0., dot(normal, direction_to_light));\n            float spectral_intensity = pow(max(0., dot(normalize(rd), reflect(direction_to_light, normal))), 1.5);\n            \n            if (distance_from_figure(current_position, vec3(0.), 1., vec3(4., 0., 4.), 1.7, -2.)\n                == length(current_position - vec3(0.)) - 1. + sin(5.0*current_position.x + 3.*iTime) * sin(5.*current_position.y-2.*iTime) * sin(4.*current_position.z-2.*iTime) * .4 *(1.5 + .5*sin(2.5*iTime)))\n            {\n            \t\n                \n            \t//each component of the normal will be in the -1<>1 range\n            \n            \treturn vec3(1., .5, .23)*(diffuse_intensity + spectral_intensity);\n                \n                \n                /*insert reflection function here\n                float reflection_distance = 0.;\n                const int MAX_REFLECTIONS_NUMBER = 10;\n                const float MAX_REFLECTION_DISTANCE = 1.;\n                const float REFLECTION_HIT = .0005;\n                \n                //backtrack_01 and _02 are going to be my new rd vector\n                \n                //to obtain the new current_position vector:\n                //vec3 current_pos_new = current_position + rd_new + direction_to_light;\n                if (dot(normal, backtrack) >= 0)\n                \tfor(int j=0; j < MAX_REFLETIONS_NUMBER; ++j)\n                \t{\n                \t\n                    \tvec3 current_pos_new = ro +  rd_new*reflection_distance;\n                    \tfloat distance_to_close_new = map_the_world(current_pos_new);\n                    \n                    \tif(distance_to_close_new < MINIMUM_HIT_DISTANCE)\n                    \t{\n                    \t\n                        \tvec3 normal_new = calculate_normal(current_position_new);\n                        \tfloat diffuse_intensity_new = max(0., dot(normal, direction_to_light));\n                        \n                        \tif (distance_from_figure(current_position, vec3(0.), 1., vec3(4., 0., 4.), 1.7, -2.)\n                \t\t\t\t== length(current_position - vec3(0.)) - 1. + sin(5.0*current_position.x + 3.*iTime) * sin(5.*current_position.y-2.*iTime) * sin(4.*current_position.z-2.*iTime) * .4 *(1.5 + .5*sin(2.5*iTime)))\n            \t\t\t\t{\n                            \n                            \n                            \n                        \t}\n                        \n                    \t}\n                    \n                \t}\n                */\n                \n            }\n            \n            else if (distance_from_figure(current_position, vec3(0.), 1., vec3(4., 0., 4.), 1.7,-2.) == length(current_position - vec3(4., 0., 4.)) - 1.7\n                                         && length(current_position) < 5.906775)\n            {\n            \treturn vec3(.07, .78, .07)*.8 + .5*diffuse_intensity;\n            }\n            else  //if it hits the plane\n            {\n                float distance_to_sphere = length(cross(current_position - light_position, light_position))/length(current_position - light_position)\n                    \t\t\t\t\t + sin(5.0*current_position.x + 3.*iTime) * sin(5.*current_position.y-2.*iTime) * sin(4.*current_position.z-2.*iTime) * .4 *(1.5 + .5*sin(2.5*iTime));\n                if (distance_to_sphere < 1.) {\n                \treturn vec3(1., .5, .23)*.3 - diffuse_intensity;\n                }\n                    \n                else return vec3(1., .5, .23)*(.75 + .45*diffuse_intensity);\n            }\n        }\n        \n        if(total_distance_traveled > MAXIMUM_TRACE_DISTANCE)\n        {\n            break;\n        }\n        \n        total_distance_traveled += distance_to_closest;\n        \n    }\n    return vec3(.22, .69, 1.);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n\tuv -= .5;\n    uv.x *= iResolution.x/iResolution.y;\n    \n    //set up camera\n    vec3 camera_position = vec3(0., 0., -5.);\n    vec3 ro = camera_position;\n    vec3 rd = vec3(uv.x, uv.y, 1.);\n    \n    vec3 backtrack = vec3(uv.x, uv.y, 1.);\n    \n    \n    vec3 shaded_color = ray_march(ro, rd, backtrack);\n    \n    fragColor = vec4(shaded_color,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WsBcWc.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 94, 94, 291], [293, 293, 322, 322, 438], [445, 445, 477, 477, 942], [945, 945, 995, 995, 5536], [5539, 5539, 5596, 5596, 5985]]}
{"id": "wslfzN", "name": "oct13", "author": "merrecurent_", "description": "h65", "tags": ["noob"], "likes": 1, "viewed": 150, "published": "Public API", "date": "1610576981", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec3 Rect(vec2 cord, float len, float wid)\n{\n    \n\tif(abs(tan(cord.x)) <= len/wid)\n        if (cord.y <= wid/abs(cos(cord.x)))\n            return vec3(1., 1., 0.);\n        else return vec3(.54, .6, 1.);\n    else\n       if (cord.y <= len/abs(sin(cord.x)))\n           return vec3(.5, 1., 0.);\n        else return vec3(.6, .75, 1.);\n\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    //uv -= vec2(.62, .59);\n    uv *= 5.;\n    uv.x *= iResolution.x/iResolution.y;\n    \n    vec2 new = fract(uv);\n    new -= .5;\n    \n    vec2 polar = vec2(atan(new.x, new.y), length(new));\n    polar.y*= 2.*polar.y;\n    \n    vec2 copy = vec2(atan(new.x, new.y), length(new));\n    new = vec2(polar.x*2. + iTime, polar.y);\n    \n    vec3 figure = Rect(new, .3, .3)\n        \t\t - Rect(new, .2, .2);\n    \n    //vec3 col = vec3(figure);\n    // Output to screen\n    fragColor = vec4(figure,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wslfzN.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 44, 44, 332], [334, 334, 391, 391, 921]]}
{"id": "WsVfDd", "name": "Devious 2 EAS", "author": "public_int_i", "description": "Devious 2 EAS", "tags": ["devious2eas"], "likes": 2, "viewed": 136, "published": "Public API", "date": "1609535988", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/*Ethan Alexander Shulman 2020 - xaloez.com\n4k 60fps video https://www.youtube.com/watch?v=iKuZ95FoQc4\n4k wallpaper xaloez.com/art/2020/Devious2.jpg*/\n\n\n#define EPS 3e-3\n#define PI 3.14159265\n\nmat2 r2(float a) {\n\tfloat s = sin(a), c = cos(a);\n\treturn mat2(c,-s,s,c);\n}\n\nvec4 r4(float n) {\n\t#define R4P 1.1673039782614187\n    return fract(.5+vec4(1./R4P,1./R4P/R4P,1./R4P/R4P/R4P,1./R4P/R4P/R4P/R4P)*n);\n}\nvec4 hash(vec4 a) {\n    a = mod(abs(a),8273.97234);\n    #define R4S(sw) floor(fract(.352347+dot(a,vec4(.001,.1,10.,100.).sw*2.23454))*20000.)\n    return r4(R4S(xyzw)+R4S(yzwx)+R4S(wxyz)+R4S(zwxy));\n}\n\n\nfloat geo(vec3 p) {\n\tfloat d = 1.;\n\tvec3 fp = floor(p);\n\tfor (float x = -1.; x < 2.; x++) {\n\t\tfor (float y = -1.; y < 2.; y++) {\n\t\t\tfor (float z = -1.; z < 2.; z++) {\n\t\t\t\tvec3 ap = abs(fp+vec3(x,y,z));\n\t\t\t\tfloat h = fract(.5+dot(ap,vec3(1.,128.,2048.))/1.6180339887498948482), yp = clamp(1.1-ap.y*.1,0.,1.), bprob = 20./ap.z*yp;\n\t\t\t\typ *= .5;\n\t\t\t\tif (h > bprob) d = min(d,length(max(abs(p-(fp+vec3(x,y,z)+.5))-yp,0.))-(.5-yp));\n\t\t\t}\n\t\t}\n\t}\n\treturn max(p.y,d);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n#define time iTime\n    vec2 uv = (fragCoord*2.-iResolution.xy)/iResolution.y;\n\n\tvec3 aas = vec3(0);\n\t//for (float ax = -1.; ax < 2.; ax++) {\n\t//\tfor (float ay = -1.; ay < 2.; ay++) {\n\t\t\tvec3 rp = vec3(1,-9.+pow(time*.06,4.)*12.,time),\n\t\t\t\trd = normalize(vec3(uv.xy,1.));\n\t\t\tvec3 c = vec3(1);\n\t\t\t//+vec2(ax,ay)*.5/screenY\n\t\n\t\t\trp += vec3(geo(rp+vec3(EPS,0,0)),geo(rp+vec3(0,EPS,0)),geo(rp+vec3(0,0,EPS)))-geo(rp);\n\n\t\t\tfor (int i = 0; i < 300; i++) {\n\t\t\t\tfloat dst = geo(rp);\n\t\t\t\tif (dst <= 0.) {\n\t\t\t\t\trp -= rd*EPS*1.5;\n\t\t\t\t\tdst = geo(rp);\n\t\t\t\t\tvec3 nrm = vec3(geo(rp+vec3(EPS,0,0)),geo(rp+vec3(0,EPS,0)),geo(rp+vec3(0,0,EPS)))-dst;\n\t\t\t\t\trd = reflect(rd,normalize(nrm));\n\t\t\t\t\tc *= .8;\n\t\t\t\t}\n\t\t\t\trp += rd*(dst+EPS);\n\t\t\t\tif (rp.y > 0. && rd.y > 0.) break;\n\t\t\t}\n\t\n\t\t\tvec3 l = (vec3(.04,.07,.18)+max(0.,1.-length(rd-normalize(vec3(1,1,1)))*(.5+rd.y*.5))*vec3(1.,.8,.6)*2.)*clamp(rp.y*.1+1.,0.,1.);\n\t\t\taas += c*l;\n\t//\t}\n\t//}\n\tfragColor = vec4(aas,1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WsVfDd.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 193, 211, 211, 268], [270, 270, 288, 288, 404], [405, 405, 424, 424, 604], [607, 607, 626, 626, 1068], [1070, 1070, 1127, 1127, 2073]]}
{"id": "Wt3Bzn", "name": "abstract water snowflake", "author": "nturley", "description": "Just playing around with radial sinusoids", "tags": ["radialsinusoid"], "likes": 0, "viewed": 43, "published": "Public", "date": "1612035945", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;   \n    vec2 toCenter = vec2(0.5)-uv;\n    float radius = length(toCenter)*2.0;\n    float angle = atan(toCenter.y,toCenter.x);\n    float v = sin(radius*20.)+sin(angle*6.+iTime);\n    float v2 = radius*sin(iTime)*1.8+sin(angle*6.-iTime);\n    fragColor = vec4(0,0.,v/v2*.1, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Wt3Bzn.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 374]]}
{"id": "wt3cRs", "name": "QuantitizeThemAll vol. 0", "author": "Dubko", "description": "https://romop5.github.io//QuantitizeThemAll/index.html?data=eyJwcm9ncmFtIjoibW9kKHQqc2luKHNpbihzaW4oY29zKHQreSp5Km1vZChtb2QoeSwxMi40OSkseSkqc2luKHgpKmNvcyh4KSttb2QoeCwwLjQ5KSkpKSkseSp0KSp5IiwidHJhbnNmb3JtYXRpb25UeXBlIjoiY2lyY2xlIiwic3RhcnRDb2xvciI6IiMwMDA", "tags": ["proceduralart", "functionquantizing"], "likes": 1, "viewed": 39, "published": "Public", "date": "1609703165", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n/*\n * Generated while using QuantitizeThemAll\n * Try it on yourself: https://romop5.github.io/QuantitizeThemAll/\n */\n   vec2 linear(vec2 uv)\n   {\n        return uv; \n   }\n\n   vec2 circle(vec2 uv)\n   {\n        vec2 nuv = normalize(uv);\n        float dist = 1.0/length(uv);\n        return nuv*dist;\n   }\n   vec2 polar(vec2 uv)\n   {\n        return vec2(atan(uv.x,uv.y),sqrt(uv.x*uv.x+ uv.y*uv.y));  \n   }\n   vec2 spherical(vec2 uv)\n   {\n        vec2 direction = uv;\n        float len = length(uv);\n        return vec2(exp(len))*direction;\n   }\n   vec2 fisheye(vec2 uv)\n   {\n        float f = 1.0000;\n        // Calculate angle from plane's UV\n        vec2 angles = atan(uv, vec2(1.0));\n        //return angles*f;\n        return vec2(2.0)*sin(angles*vec2(0.5))*vec2(f);\n   }\n\n   float inv(float x)\n   {\n    return 1.0/x;\n   }\n\n\n\n   void mainImage(out vec4 fragColor, in vec2 fragCoord) {\n       vec2 uv = fragCoord/iResolution.xy;\n       uv *= 2.0;\n       uv += -1.0;\n       float t = iTime*1.0000;\n       vec2 resultingUv = circle(vec2(uv.x, uv.y)*vec2(1.0000));\n       float x = resultingUv.x;\n       float y = resultingUv.y;\n       float program = mod(t*sin(sin(sin(cos(t+y*y*mod(mod(y,12.49),y)*sin(x)*cos(x)+mod(x,0.49))))),y*t)*y;\n       float parameter = clamp(program, 0.0,1.0);\n\n       vec3 colorStart = vec3(0,0,0)/255.0;\n       vec3 colorEnd = vec3(255,255,255)/255.0;\n       vec3 resultColor = mix(colorStart, colorEnd, parameter);\n\n       bool hasColorThreshold = true;\n       if(hasColorThreshold)\n       {\n          resultColor = (parameter > 0.5000)?colorStart:colorEnd;  \n       }\n       fragColor = vec4(resultColor, 1.0);\n   }\n   ", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wt3cRs.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 121, 146, 146, 171], [176, 176, 201, 201, 302], [306, 306, 330, 330, 402], [406, 406, 434, 434, 541], [545, 545, 571, 571, 771], [776, 776, 799, 799, 822], [829, 829, 884, 884, 1642]]}
{"id": "wt3cRX", "name": "Sphere_deformed", "author": "regis", "description": "sphere deformed", "tags": ["sphere"], "likes": 0, "viewed": 31, "published": "Public", "date": "1609601443", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define MAX_STEPS 500\n#define MAX_DIST 70.\n#define SURF_DIST .01\n#define EPSILON 0.01\n\nmat2 Rot(float a){\n    float s = sin(a);\n    float c = cos(a);\n    return mat2(c, -s, s, c);\n}\n\nfloat sphereSDF(vec3 p) {\n    return length(p) - 1.0;\n}\n\n\nfloat sdCapsule(vec3 p, vec3 a, vec3 b, float r) {\n\tvec3 ab = b-a;\n    vec3 ap = p-a;\n    \n    float t = dot(ab, ap) / dot(ab, ab);\n    t = clamp(t, 0., 1.);\n    \n    vec3 c = a + t*ab;\n    \n    return length(p-c)-r;\n}\n\nfloat sdCylinder(vec3 p, vec3 a, vec3 b, float r) {\n\tvec3 ab = b-a;\n    vec3 ap = p-a;\n    \n    float t = dot(ab, ap) / dot(ab, ab);\n    //t = clamp(t, 0., 1.);\n    \n    vec3 c = a + t*ab;\n    \n    float x = length(p-c)-r;\n    float y = (abs(t-.5)-.5)*length(ab);\n    float e = length(max(vec2(x, y), 0.));\n    float i = min(max(x, y), 0.);\n    \n    return e+i;\n}\n\nfloat sdTorus(vec3 p, vec2 r) {\n\tfloat x = length(p.xz)-r.x;\n    return length(vec2(x, p.y))-r.y;\n}\n\nfloat dBox(vec3 p, vec3 s) {\n\treturn length(max(abs(p)-s, 0.));\n}\n\nfloat forme(vec3 p, vec3 s){\n    return min(length(max(abs(p)-s, 0.)), 0.01);\n\n}\n\nvec2 N22(vec2 p){\n    vec3 a = fract(p.xyx*vec3(123.34, 234.34, 345.65));\n    a+=dot(a, a+34.45);\n    return fract(vec2(a.x*a.y, a.y*a.z));\n}\n\n\nfloat GetDist2(vec3 p) {\n\tvec4 s = vec4(0, 1, 6, 1);\n    \n    float sphereDist =  length(p-s.xyz)-s.w;\n    \n    \n    /***********************************/\n    float m = 0.;//N22(uv).x;\n    float t = iTime;\n    \n    float minDist = 100.;\n    float cellIndex = 0.;\n    float py = p.y;\n     vec2 uv = p.xy;\n     uv*= 2.;\n    vec2 gv = fract(uv)-.5;\n    vec2 id = floor(uv);\n    vec2 cid = vec2(0);\n    for (float y=-1.; y <= 1.;y++){\n        for (float x=-1.; x <= 1.;x++){\n            vec2 offset = vec2(x, y);\n            vec2 n = N22(id+offset);\n            vec2 q = offset+sin(n*t)*.5;\n            q -= gv;\n            float ed = length(q);\n            float md= abs(q.x) + abs(q.y);\n            float d = mix(ed, md, sin(iTime)*.5+.5);\n            if(d < minDist){\n                minDist = d;\n                cid = id+offset;\n            }\n        }\n    }\n    //col = vec3(minDist);\n    //col.rg = cid*.1;\n    \n   /*  for(float i=0.;i < 50.;i++){\n            vec2 n = N22(vec2(i));\n            vec2 p = sin(n*t);\n\n            float d = length(uv-p);\n            m += smoothstep(.05, .01, d);\n\n            if(d < minDist){\n                minDist = d;\n                cellIndex = i;\n            }\n\n        }*/\n    \n    \n    \n    /*************************************/\n    \n    float planeDist = dot(p, vec3(0.0, 1.0, 0.0)) ;\n    //planeDist *= minDist;\n    float d = max(planeDist/minDist*0.01, py);\n    d  = min(d, sphereDist/minDist*0.01);\n    \n    return d;\n}\n\nfloat GetDist(vec3 p){\n    vec4 s = vec4(0,1.5, 5, 1);\n    \n    float planeDist = p.y;\n    float sphereDist = length(p-s.xyz)-s.w;\n    //float sphereDist = CubeApproxSDF(p, 2.0);\n    \n    float d = min(sphereDist, planeDist);\n    \n    return d;\n\n}\n\nfloat RayMarch(vec3 ro, vec3 rd){\n    float dO = 0.0;\n    \n    for(int i = 0;i < MAX_STEPS;i++){\n\n        vec3 p = ro + rd * dO;\n        float dS = GetDist(p);\n        dO += dS;\n          if(dO >MAX_DIST || dS < SURF_DIST)break;\n    }\n    \n    return dO;\n\n\n}\n\nfloat intersectSDF(float distA, float distB) {\n    return max(distA, distB);\n}\n\nfloat unionSDF(float distA, float distB) {\n    return min(distA, distB);\n}\n\nfloat differenceSDF(float distA, float distB) {\n    return max(distA, -distB);\n}\n\nfloat sceneSDF(vec3 samplePoint) {\n    float sphereDist = sphereSDF(samplePoint / 1.2) * 1.2;\n    //float cubeDist = cubeSDF(samplePoint) * 1.2;\n    return unionSDF(samplePoint.y, sphereDist);\n}\n\nfloat RayMarch2(vec3 eye, vec3 viewRayDirection){\n\n    float depth = 0.0, end = 10.0;\n    for (int i = 0; i < MAX_STEPS; i++) {\n        float dist = GetDist2(eye + depth * viewRayDirection);\n        if (dist < SURF_DIST) {\n            // We're inside the scene surface!\n            return depth;\n        }\n        // Move along the view ray\n        depth += dist;\n\n        if (depth >= MAX_DIST) {\n            // Gone too far; give up\n            return MAX_DIST;\n        }\n    }\n    return end;\n\n\n}\n\nvec3 GetNormal(vec3 p){\n    float d = GetDist2(p);\n    vec2 e = vec2(0.01, 0);\n    \n    vec3 n = d - vec3(\n        GetDist2(p-e.xyy),\n        GetDist2(p-e.yxy),\n        GetDist2(p-e.yyx));\n        \n    return normalize(n);\n}\n\nvec3 estimateNormal(vec3 p) {\n    return normalize(vec3(\n        sceneSDF(vec3(p.x + EPSILON, p.y, p.z)) - sceneSDF(vec3(p.x - EPSILON, p.y, p.z)),\n        sceneSDF(vec3(p.x, p.y + EPSILON, p.z)) - sceneSDF(vec3(p.x, p.y - EPSILON, p.z)),\n        sceneSDF(vec3(p.x, p.y, p.z  + EPSILON)) - sceneSDF(vec3(p.x, p.y, p.z - EPSILON))\n    ));\n}\n\nfloat GetLight(vec3 p){\n    vec3 lightpos = vec3(2.0, 5, -6);\n    lightpos.xz += vec2(sin(iTime), cos(iTime));\n    vec3 l = normalize(lightpos-p);\n    vec3 n = GetNormal(p);\n    \n    float dif = clamp(dot(n, l), 0., 1.);\n    float d = RayMarch2(p+n*SURF_DIST, l);\n    if(d < length(lightpos-p))dif *= 0.1;\n    return dif ;\n\n}\n\n\n\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n   \n    uv -= 0.5;\n     uv /= vec2(iResolution.y / iResolution.x, 1);\n    vec3 col = vec3(1.0);\n    \n    vec3 ro = vec3(0, 2.0, -1.0);\n    ro.xy *= Rot(6.0);\n    vec3 rd = normalize(vec3(uv.x, uv.y, 1));\n    \n    float d = RayMarch2(ro, rd);\n    vec3 p = ro +rd * d;\n    \n    float dif =GetLight(p);\n    col = vec3(dif)+ vec3(0.5, 0.0, 0.2);\n    \n    float m = 0.;//N22(uv).x;\n    float t = iTime;\n    \n    float minDist = 100.;\n    float cellIndex = 0.;\n    \n     //vec2 uv = p.xy;\n     uv*= 10.;\n    vec2 gv = fract(uv)-.5;\n    vec2 id = floor(uv);\n    vec2 cid = vec2(0);\n    for (float y=-1.; y <= 1.;y++){\n        for (float x=-1.; x <= 1.;x++){\n            vec2 offset = vec2(x, y);\n            vec2 n = N22(id+offset);\n            vec2 p = offset+sin(n*t)*.5;\n            p -= gv;\n            float ed = length(p);\n            float md= abs(p.x) + abs(p.y);\n            float d = mix(ed, md, sin(iTime)*.5+.5);\n            if(d < minDist){\n                minDist = d;\n                cid = id+offset;\n            }\n        }\n    }\n    if(uv.y < minDist-4.0){\n    //mix(1., 3., smoothstep(-1., 1., bp.y))\n    col *= mix(1.,3., minDist);\n    col.rg *= cid*.1;\n    }\n    \n    \n    /*float c = 0.5 * sin(uv.x * 10.0) * cos(sin(iTime + uv.y)*20.0);\n    //col = vec3(1.0);\n    if(length(uv) < 0.5){\n    \n     col *= vec3(sin(c * 0.2 * cos(iTime)), c*0.75, cos(c * 0.1*iTime / 0.4) *0.1);\n    //col = vec4(1.0, 0.0, 0.0, 0.0);\n    }\n    else\n    {\n        col *= vec3(sin(c * 0.2 * cos(iTime)), c*0.5, sin(c * 0.5*iTime / 0.4) *0.1);\n    \n    }*/\n    \n    \n    \n    // Output to screen\n    fragColor = vec4(col, 1.0);\n} ", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wt3cRX.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[87, 87, 105, 105, 181], [183, 183, 208, 208, 238], [241, 241, 291, 291, 459], [461, 461, 512, 512, 824], [826, 826, 857, 857, 925], [927, 927, 955, 955, 992], [994, 994, 1022, 1022, 1074], [1076, 1076, 1093, 1093, 1217], [1220, 1220, 1244, 1244, 2685], [2687, 2687, 2709, 2709, 2934], [2936, 2936, 2969, 2969, 3194], [3196, 3196, 3242, 3242, 3274], [3276, 3276, 3318, 3318, 3350], [3352, 3352, 3399, 3399, 3432], [3434, 3434, 3468, 3468, 3628], [3630, 3630, 3679, 3679, 4129], [4131, 4131, 4154, 4154, 4355], [4357, 4357, 4386, 4386, 4696], [4698, 4698, 4721, 4721, 5023], [5030, 5030, 5087, 5137, 6798]]}
{"id": "wt3cWs", "name": "Animated Miffy style rabbit", "author": "intrakits", "description": "I wanted to make miffy, lol. This was also a good practice at making more complex 2D shapes (although i think some of my approaches are fairly hacky).", "tags": ["2d", "cute", "animated", "shapes", "rabbit", "miffy"], "likes": 3, "viewed": 172, "published": "Public API", "date": "1610169818", "time_retrieved": "2021-10-01T00:00:00", "image_code": "mat2 rotate(float r) {\n    float c = cos(r);\n    float s = sin(r);\n    return mat2(c, -s, s, c);\n}\n\nvec3 circle (vec2 uv, float posX, float posY, float r, float blur, vec3 color){\n    uv.x-=posX;\n    uv.y-=posY;\n    \n    float d = length(uv);\n    return color * vec3(smoothstep(r,r-blur,d));\n}\nvec3 circle (vec2 uv, float r, float blur, vec3 color){\n    float d = length(uv);\n    return color * vec3(smoothstep(r,r-blur,d));\n}\nvec3 square(vec2 uv, float w, float h, float posX, float posY, float rot, float blur, vec3 color){\n    uv*=rotate(rot);\n    float wPos = length(uv.x-posX);\n    float hPos = length(uv.y-posY);\n    \n    float col = smoothstep(w,w-blur, wPos);\n    col *= smoothstep(h,h-blur, hPos);\n    return color*vec3(col);\n}\nvec3 triangle(vec2 uv, float w, float h, float posX, float posY, float rot, float blur, vec3 color){\n    uv.x-=posX;\n    uv.y-=posY;\n    uv*=rotate(rot);\n    vec3 sq = square(uv,w,h,0.,0.,0.,blur,color);\n    uv*=rotate(3.1415/2./2.);\n    uv-= vec2(0.,h);\n    float hyp = sqrt(w*w + h*h);\n    vec3 sqMask = square(uv,hyp,h,0.,0., 0.,blur,color);\n    sq -= sqMask;\n    return sq;\n}\nvec3 ellipse(vec2 uv, float posX, float posY, float rot, float a,float b, float blur, vec3 color){\n    uv -= vec2(posX,posY);\n    uv*=rotate(rot);\n    float x = uv.x;\n    float y = sqrt((1.-a)*(1.-((x*x)/(1.-b))));\n    float d = length(uv);\n    return color * vec3(smoothstep(y,y-blur,d));\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    uv-= 0.5;\n    \n    uv.x *= iResolution.x/iResolution.y;\n\n    \n    //background\n    float blur = 0.01;\n    vec3 col = square(uv, 1., .3, 0., -.4,0., blur, vec3(0,.5,.2));\n    col = max(col, square(uv, 1., .3, 0., .2,0., blur, vec3(0.,0.,.5)));\n    \n    //ears\n    float a = 0.95;\n    float b = 0.995;\n    float posX = -0.1;\n    float posY = 0.14;\n    float rot = -0.1;\n    \n    //left ear outline\n    col = min(col,col-ellipse(uv, posX, posY-sin(iTime)*.025, rot, a, b, blur, vec3(1.)));\n    \n    //left ear fill\n    a = 0.96;\n    b = 0.997;\n    col = max(col,ellipse(uv, posX, posY-sin(iTime)*.025, rot, a, b, blur, vec3(1.)));\n    \n    //right ear outline\n    a = 0.95;\n    b = 0.995;\n    posX = 0.1;\n    posY = 0.14;\n    rot = 0.1;\n    col = min(col,col-ellipse(uv, posX, posY-sin(iTime)*.025, rot, a, b, blur, vec3(1.)));\n    \n    //right ear fill\n    a = 0.96;\n    b = 0.997;\n    col = max(col,ellipse(uv, posX, posY-sin(iTime)*.025, rot, a, b, blur, vec3(1.)));\n    //legs\n    col = min(col,col-circle (uv - vec2(.1,-.46), .08, blur, vec3(1.))); \n    col = max(col,circle (uv - vec2(.1,-.46), .07, blur, vec3(1.)));\n    col = min(col,col-circle (uv - vec2(-.06,-.46), .08, blur, vec3(1.))); \n    col = max(col,circle (uv - vec2(-.06,-.46), .07, blur, vec3(1.)));\n    //shirt\n    a = 0.93;\n    b = 0.91;\n    posX = 0.;\n    posY = -0.35;\n    rot = 3.14159/2.;\n    \n    col = min(col, col-ellipse(uv, posX, posY, rot, a, b, blur, vec3(1.))+square(uv, .3, .1, 0., -0.44,0., blur, vec3(1)));\n    a = 0.935;\n    b = 0.92;\n    col = max(col, ellipse(uv, posX, posY, rot, a, b, blur, vec3(1.,.4,.0))-square(uv, .254, .1, 0., -0.42,0., blur, vec3(1)));\n    \n    \n    a = 0.93;\n    b = 0.99;\n    posY = -0.4;\n    col = min(col, col-ellipse(uv, posX, posY, rot, a, b, blur, vec3(1.)));\n    a = 0.9299;\n    b = 0.988;\n    posY = -0.382;\n    col = max(col, ellipse(uv, posX, posY, rot, a, b, blur, vec3(1.,.4,0)));\n    \n    col = min(col, col - square(uv, .263, .05, 0., -0.37,0., blur, vec3(1)));\n    col = max(col, square(uv, .249, .056, 0., -0.3699,0., blur, vec3(1.,.4,0)));\n    \n    //arms\n    col = min(col,col-circle (uv - vec2(.27,-.35), .06, blur, vec3(1.))); \n    col = max(col,circle (uv - vec2(.27,-.35), .053, blur, vec3(1.))); \n    \n    col = min(col,col-circle (uv - vec2(-.27,-.35), .06, blur, vec3(1.))); \n    col = max(col,circle (uv - vec2(-.27,-.35), .053, blur, vec3(1.))); \n    //head\n    a = 0.95;\n    b = 0.91;\n    posX = 0.;\n    posY = -0.1;\n    rot = 3.14159/2.;\n    \n    col = min(col, col-ellipse(uv, posX, posY, rot, a, b, blur, vec3(1.)));\n    a = 0.954;\n    b = 0.933;\n    col = max(col, ellipse(uv, posX, posY, rot, a, b, blur, vec3(1.)));\n    //ear mask\n    \n    col = max(col,circle (uv - vec2(.094,.07), .055, blur, vec3(1.))); \n    col = max(col,circle (uv - vec2(-.094,.07), .055, blur, vec3(1.))); \n    \n    //eyes\n    col = min(col, col-circle (uv - vec2(.1,-sin(iTime)*.025-.12), 0.015, blur, vec3(1.)));\n    col = min(col, col-circle (uv - vec2(-.05,-sin(iTime)*.025-.12), 0.015, blur, vec3(1.)));\n    \n    //mouth\n    col = min(col, col-square(uv-=vec2(-0.1,-.37-sin(iTime)*.025), .03, .01, 0., .2,0.7, blur, vec3(1.)));\n    col = min(col, col-square(uv-=vec2(0.26,-sin(iTime)*.004), .03, .01, 0., .2,-0.7, blur, vec3(1.)));\n    \n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wt3cWs.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 22, 22, 98], [100, 100, 179, 179, 293], [294, 294, 349, 349, 426], [427, 427, 525, 525, 736], [737, 737, 837, 837, 1116], [1117, 1117, 1215, 1215, 1408], [1409, 1409, 1466, 1516, 4887]]}
{"id": "Wt3czf", "name": "HappyNewYear2021", "author": "yasuo", "description": "Happy New Year, guys!", "tags": ["2021"], "likes": 15, "viewed": 205, "published": "Public API", "date": "1609592983", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define Rot(a) mat2(cos(a),-sin(a),sin(a),cos(a))\n#define antialiasing(n) n/min(iResolution.y,iResolution.x)\n#define S(d,b) smoothstep(antialiasing(1.0),b,d)\n#define DF(a,b) length(a) * cos( mod( atan(a.y,a.x)+6.28/(b*8.0), 6.28/((b*8.0)*0.5))+(b-1.)*6.28/(b*8.0) + vec2(0,11) )\n\n// https://www.iquilezles.org/www/articles/distfunctions/distfunctions.htm\nfloat opSmoothUnion( float d1, float d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); }\n\n// https://www.iquilezles.org/www/articles/distfunctions2d/distfunctions2d.htm\nfloat sdBox( in vec2 p, in vec2 b )\n{\n    vec2 d = abs(p)-b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\n// https://www.iquilezles.org/www/articles/distfunctions2d/distfunctions2d.htm\nfloat sdPie( in vec2 p, in vec2 c, in float r )\n{\n    p.x = abs(p.x);\n    float l = length(p) - r;\n    float m = length(p-c*clamp(dot(p,c),0.0,r)); // c = sin/cos of the aperture\n    return max(l,m*sign(c.y*p.x-c.x*p.y));\n}\n\nfloat SimpleVesicaDistance(vec2 p, float r, float d) {\n    p.x = abs(p.x);\n    p.x+=d;\n    return length(p)-r;\n}\n\nvec3 bamboo(vec2 p, vec3 col, float brightness){\n    vec2 prevP = p;\n    \n    float d = sdBox(p-vec2(0.0,-0.2),vec2(0.033,0.2));\n    col = mix(col,vec3(0.6,0.7,0.5)*brightness,S(d,0.0));    \n    \n    p.x*= 1.5;\n    d = length(p)-0.05;\n    col = mix(col,vec3(0.6,0.7,0.5)*brightness,S(d,0.0));\n    p = prevP;\n    p.x*= 1.5;\n    d = length(p)-0.035;\n    col = mix(col,vec3(0.7,0.8,0.1)*1.2,S(d,0.0));\n    return col;\n}\n\nvec3 hey(vec2 p, vec3 col) {\n    vec2 prevP = p;\n    \n    float d = sdBox(p,vec2(0.1,0.1));\n    col = mix(col,vec3(0.8,0.7,0.1),S(d,0.0));    \n    \n    p.x = mod(p.x,0.022)-0.011;\n    d = sdBox(p,vec2(0.005,0.1));\n    \n    p = prevP;\n    float d2 = sdBox(p,vec2(0.1,0.11));\n    d = max(d2,d);\n    col = mix(col,vec3(0.7,0.6,0.1),S(d,0.0));\n    p = prevP;\n    \n    d = sdBox(p-vec2(0.0,-0.05),vec2(0.1,0.005));\n    col = mix(col,vec3(0.6,0.4,0.1),S(d,0.0)); \n    \n    return col;\n}\n\nvec3 grass(vec2 p, vec3 col) {\n    vec2 prevP = p;\n    float k = 0.01;\n    float d = length(p)-0.05;\n    p.x = abs(p.x);\n    p.x-=0.05;\n    float d2 = length(p-vec2(0.0,-0.03))-0.05;\n    d = opSmoothUnion(d,d2,k);\n    p.x-=0.05;\n    d2 = length(p-vec2(0.0,-0.07))-0.05;\n    d = opSmoothUnion(d,d2,k);\n    p.x+=0.06;\n    d2 = length(p-vec2(0.0,-0.06))-0.05;\n    d = opSmoothUnion(d,d2,k);\n    col = mix(col,vec3(0.1,0.4,0.1),S(d,0.0)); \n    return col;\n}\n\nvec3 flower(vec2 p, vec3 col) {\n    vec2 prevP = p;\n    p = DF(p,1.25);\n    p -= vec2(0.019);\n    float d = length(p)-0.027;\n    col = mix(col,vec3(0.7,0.2,0.2),S(d,0.0));\n    p = prevP;\n    \n    p = DF(p,1.25);\n    p -= vec2(0.015);\n    d = length(p)-0.005;\n    col = mix(col,vec3(1.0),S(d,0.0));\n    \n    return col;\n}\n\nvec3 leaf(vec2 p, vec3 col) {\n    vec2 prevP = p;\n    float d = SimpleVesicaDistance(p,0.08,0.062);\n    p.x = abs(p.x);\n    p.x-=0.03;\n    p.y-=0.015;\n    float d2 = SimpleVesicaDistance(p*Rot(radians(-50.0)),0.08,0.061);\n    d = min(d,d2);\n    col = mix(col,vec3(0.3,0.8,0.3),S(d,0.0));\n    return col;\n}\n\nvec3 fan(vec2 p, vec3 col)\n{\n    const vec2 an = vec2(sin(0.98),cos(0.98));\n    \n    float d = sdPie(p,an,0.1/0.8);\n    col = mix(col,vec3(1.0,0.0,0.0),S(d,0.0));\n    \n    d = sdPie(p,an,0.07/0.8);\n    col = mix(col,vec3(1.0),S(d,0.0));\n    \n    d = length(p-vec2(0.0,0.04/0.8))-0.015/0.8;\n    col = mix(col,vec3(0.9,0.9,0.1),S(d,0.0));\n    \n    return col;\n}\n\nvec3 clouds(vec2 p, vec3 col) {\n    vec2 prevP = p;\n    \n    float d = length(p)-0.35;\n    col = mix(col,mix(vec3(1.0),vec3(0.5,0.7,0.9),p.y+0.3),S(d,0.0));\n    \n    p.y*=1.1;\n    p.x+=iTime*0.1;\n    p.x=mod(p.x,0.8)-0.4;\n    p.y-=0.15;\n    \n    d = sdBox(p,vec2(0.16,0.005))-0.03;\n    float d2 = sdBox(p-vec2(-0.04,0.125),vec2(0.05,0.005))-0.03;\n    d = min(d,d2);\n    d2 = sdBox(p-vec2(-0.04,0.06),vec2(0.03,0.05));\n    d = opSmoothUnion(d,d2,0.02);\n    d2 = sdBox(p-vec2(0.12,-0.125),vec2(0.1,0.005))-0.03;\n    d = min(d,d2);\n    d2 = sdBox(p-vec2(0.1,-0.06),vec2(0.03,0.05));\n    d = opSmoothUnion(d,d2,0.02);\n    \n    p = prevP;\n    d2 = length(p)-0.35;\n    d = max(d2,d);\n    \n    col = mix(col,vec3(0.5,0.7,0.9)*1.9,S(d,0.0));\n    \n    return col;\n}\n\nvec3 soil(vec2 p, vec3 col) {\n    p.x*=0.4;\n    p.y*=2.0;\n    float d = length(p)-0.07;\n    col = mix(col,vec3(0.7,0.5,0.2),S(d,-0.03));\n    \n    return col;\n}\n\nvec3 render(vec2 p, vec3 col) {\n    vec2 prevP = p;\n    float t = iTime;\n    col = clouds(p,col);\n\n    col = soil(p-vec2(0.0,-0.4),col);\n    col = bamboo(p-vec2(0.0,0.1),col,0.8);\n    p.x = abs(p.x);\n    p.x-=0.05;\n    col = bamboo(p,col,1.0);\n    p = prevP;\n    col = hey(p-vec2(0.0,-0.3),col);\n    col = grass(p-vec2(0.0,-0.125),col);\n    col = fan((p-vec2(-0.05,-0.23))*Rot(radians(-25.0)),col);\n    col = leaf((p-vec2(-0.06,-0.27))*Rot(radians(30.0)),col);\n    col = flower((p-vec2(0.0,-0.22))*Rot(radians(-30.0*t)),col);\n    col = flower((p-vec2(0.07,-0.125))*Rot(radians(25.0*t)),col);\n    \n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    vec3 col = vec3(1.0);\n\n    col = render(uv,col);\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Wt3czf.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[280, 355, 407, 407, 506], [508, 587, 624, 624, 704], [706, 785, 834, 834, 1008], [1010, 1010, 1064, 1064, 1122], [1124, 1124, 1172, 1172, 1540], [1542, 1542, 1570, 1570, 2022], [2024, 2024, 2054, 2054, 2477], [2479, 2479, 2510, 2510, 2799], [2801, 2801, 2830, 2830, 3106], [3108, 3108, 3136, 3136, 3467], [3469, 3469, 3500, 3500, 4225], [4227, 4227, 4256, 4256, 4386], [4388, 4388, 4419, 4419, 5002], [5004, 5004, 5061, 5061, 5211]]}
{"id": "Wt3yDB", "name": "Lagging Grid", "author": "Exnonull", "description": "Idk what to write in description.", "tags": ["2d", "grid", "lag"], "likes": 1, "viewed": 34, "published": "Public", "date": "1609786674", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define scale 6.\n\nvoid mainImage( out vec4 fragColor, in vec2 pos )\n{\n    vec3 clr = vec3(0,0,0);\n    vec2 pos2 = pos/scale;\n    \n    float time = abs(10. * sin(iTime/5.));\n    \n    clr.r = pow(cos(pos2.y + pow(sin(pos2.x + pow(time, time)), time)), time);//vertical lines\n    clr.g = pow(sin(pos2.x + pow(cos(pos2.y + pow(time, time)), time)), time);//horizontal lines\n    clr.b = 1.;\n    \n    fragColor = vec4(clr,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Wt3yDB.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[18, 18, 69, 69, 423]]}
{"id": "wt3yRX", "name": "Clock GMT", "author": "m1ke", "description": "A functional GMT clock. (12-hour version)\n\nR : Seconds\nG = minutes\nB : Hours", "tags": ["clock"], "likes": 2, "viewed": 44, "published": "Public", "date": "1609608632", "time_retrieved": "2021-10-01T00:00:00", "image_code": "struct Sphere\n{\n    vec2 pos;\n    float radius;\n    vec3 colour;\n};\nSphere newSphere(vec2 p, float r, vec3 c)\n{\n    Sphere s;\n    s.pos = p;\n    s.radius = r;\n    s.colour = c;\n    return s;\n}\nstruct Ring\n{\n    vec2 pos;\n    vec3 colour;\n    float radius;\n    float thickness;\n};\nRing newRing(vec2 p, float r, float t, vec3 c)\n{\n    Ring ri;\n    ri.pos = p;\n    ri.radius = r;\n    ri.thickness = t;\n    ri.colour = c;\n    return ri;\n}\n\nstruct Line\n{\n    vec2 a;\n    vec2 b;\n    float thickness;\n    float l;\n    vec3 colour;\n};\nLine newLine(vec2 a, vec2 b, float t, vec3 c)\n{\n    Line l;\n    l.a = a;\n    l.b = b;\n    l.thickness = t;\n    l.l = length(a-b);\n    l.colour = c;\n    return l;\n}\nfloat dstToLine(Line l, vec2 c)\n{\n\tfloat s1 = -l.b.y + l.a.y;\n\tfloat s2 = l.b.x - l.a.x;\n\treturn abs((c.x - l.a.x) * s1 + (c.y - l.a.y) * s2) / sqrt(s1*s1 + s2*s2);\n}\n\nbool inLine(Line l, vec2 p)\n{\n    return (p.x-l.thickness < max(l.a.x,l.b.x) && p.x+l.thickness > min(l.a.x,l.b.x) && p.y-l.thickness < max(l.a.y,l.b.y) && p.y+l.thickness > min(l.a.y,l.b.y) && dstToLine(l,p) < l.thickness);\n}\n\nbool inSphere(vec2 point, Sphere s)\n{\n    return length(point - s.pos) < s.radius;\n}\nbool inRing(vec2 point, Ring r)\n{\n    return !inSphere(point, newSphere(r.pos, r.radius, r.colour)) && inSphere(point, newSphere(r.pos, r.radius+r.thickness, r.colour));\n}\nvoid DrawSphere(inout vec3 col, vec2 p, Sphere s)\n{\n    if (inSphere(p, s))\n    {\n        col = s.colour;\n    }\n}\nvoid DrawLine(inout vec3 col, vec2 p, Line l)\n{\n    if (inLine(l, p))\n    {\n        col = l.colour;\n    }\n}\nvoid DrawRing(inout vec3 col, vec2 p, Ring r)\n{\n    if (inRing(p, r))\n    {\n        col = r.colour;\n    }\n}\nconst float PI = 3.14159265359;\n\nvec2 angle(float a, float l)\n{\n    return vec2(sin(a), cos(a)) * l * iResolution.x/5.0f;\n}\nvoid DrawMarks(inout vec3 col, vec2 p, vec2 middle)\n{\n    for (int i = 0; i < 12; i++)\n    {\n        float thisAngle = PI*2.0f * (float(i) / 12.0f);\n        vec2 thisRot = angle(thisAngle, 1.0f);\n        Line thisL = newLine(middle+thisRot*0.9f, middle+thisRot, 1.0f, vec3(0,0,0));\n        DrawLine(col, p, thisL);\n    }\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Time varying pixel color\n    vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n    Sphere a = newSphere(iResolution.xy/2.0f,iResolution.x / 5.0f, vec3(1,1,1));\n    \n    DrawSphere(col, fragCoord, a);\n    \n    vec2 middle = iResolution.xy / 2.0f;\n    \n    float secondx = PI*2.0f * (iDate.w/60.0f);\n    vec2 secondrot = angle(secondx, 0.9f);\n    Line secondl = newLine(middle, vec2(middle +secondrot), 3.0f, vec3(1,0,0));\n    DrawLine(col, fragCoord, secondl);\n    \n    float minx = PI*2.0f * (iDate.w/60.0f/60.0f);\n    vec2 minrot = angle(minx, 0.7f);\n    Line minl = newLine(middle, vec2(middle +minrot), 3.0f, vec3(0,1,0));\n    DrawLine(col, fragCoord, minl);\n    \n    float hourx = PI*2.0f * (iDate.w/3600.0f/12.0f);\n    vec2 hourrot = angle(hourx, 0.6f);\n    Line hourl = newLine(middle, vec2(middle +hourrot), 3.0f, vec3(0,0,1));\n    DrawLine(col, fragCoord, hourl);\n    \n    DrawMarks(col, fragCoord, middle);\n    \n    Ring r = newRing(middle, iResolution.x/5.0f, 5.0f, vec3(0,0,0));\n    DrawRing(col, fragCoord, r);\n    \n\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wt3yRX.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[68, 68, 111, 111, 192], [280, 280, 328, 328, 434], [528, 528, 575, 575, 691], [692, 692, 725, 725, 858], [860, 860, 889, 889, 1086], [1088, 1088, 1125, 1125, 1172], [1173, 1173, 1206, 1206, 1344], [1345, 1345, 1396, 1396, 1458], [1459, 1459, 1506, 1506, 1566], [1567, 1567, 1614, 1614, 1674], [1708, 1708, 1738, 1738, 1798], [1799, 1799, 1852, 1852, 2121], [2123, 2123, 2180, 2230, 3342]]}
{"id": "WtcBzr", "name": "-Transitions- ", "author": "Plento", "description": "I like cubes", "tags": ["3d", "cubes", "random"], "likes": 8, "viewed": 222, "published": "Public API", "date": "1612056679", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Cole Peterson\n\n#define R iResolution.xy\n#define ss(a, b, t) smoothstep(a, b, t)\n#define rot(a) mat2(cos(a), -sin(a), sin(a), cos(a))\n\nfloat hash12(vec2 p){\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nfloat box( vec3 p, vec3 b ){\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat sub(float d1, float d2){return max(-d1, d2);}\n\n#define b vec3(3., 3., 3.)\n#define r 0.45\n#define r2 0.42\n\nvoid q(inout vec3 p, in float rnd){\n    p.yz += .35*vec2(cos(iTime + rnd*333.), sin(iTime*2. + rnd*333.));\n    p.x += sign(rnd-0.5)*iTime*(rnd+.4) + rnd*3.;\n}\n\nfloat map(vec3 p){\n    float d = 999.;\n    vec3 pp = p;\n    \n    vec2 id = floor(p.zy/b.xy);\n    float rnd = hash12(id*733.3);\n    \n    q(p, rnd);\n    \n    p = mod(p, b)-b*0.5;\n    \n    p.xy*=rot(rnd*23.+iTime);\n    p.xz*=rot(rnd*73.+iTime);\n    \n    d = min(box(p, vec3(r)), 4.7 - abs(pp.x));\n    \n    if(rnd > 0.6){\n        d = sub(box(p, vec3(r2, r2, 2.2)), d);\n        d = sub(box(p, vec3(r2, 2.2, r2)), d);\n        d = sub(box(p, vec3(2.2, r2, r2)), d);\n    }\n    return d;\n}\n\n\nvoid mainImage( out vec4 f, in vec2 u ){\n    vec2 uv = vec2(u.xy - 0.5*R.xy)/R.y;\n    \n    vec3 rd = normalize(vec3(uv, 0.8));\n    vec3 ro = vec3(-1.8, .5, 0.);\n    \n    rd.xy *= rot(-.3);\n    rd.xz *= rot(-.2);\n    rd.yz *= rot(.7);\n    \n    ro.z += iTime*1.3;\n    \n    float d = 0.0, t = 0.0, ns = 0.;\n    \n    for(int i = 0; i < 80; i++){\n    \td = map(ro + rd*t); \n        \n        if(d < 0.002 || t > 40.) break;\n        t += d * .55;\n        ns++;\n    }\n    \n    vec3 p = ro + rd*t;\n    \n    vec3 col = vec3(.001);\n    \n    col = mix(vec3(.05), col, exp(-t*t*t*0.0001));\n    col = pow(col*3.4, vec3(1.6));\n\n    \n    f = vec4(pow(max(col, 0.), vec3(1./2.2)), 1);\n}\n\n\n\n\n\n\n\n\n\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WtcBzr.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 137, 158, 158, 275], [277, 277, 305, 305, 392], [394, 394, 424, 424, 445], [506, 506, 541, 541, 664], [666, 666, 684, 684, 1146], [1149, 1149, 1189, 1189, 1817]]}
{"id": "WtccDf", "name": "math bubbles", "author": "jcyuan", "description": "funny stuff from math.", "tags": ["math", "bubbles"], "likes": 4, "viewed": 254, "published": "Public API", "date": "1609991228", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// idea from https://www.desmos.com/calculator/64ebpdhpzq\n\n#define TAU 6.2831853\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 p = (2. * fragCoord - iResolution.xy) / min(iResolution.x, iResolution.y) * 12.;\n\n    float t = (fract(iTime) - .5) * TAU;\n    float s = tan(tan(sin(p.x) * sin(p.y - t)));\n    float w = fwidth(s) * .5;\n    s = smoothstep(-w, w, p.y - s);\n\n    fragColor = vec4(vec3(s), 1.);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WtccDf.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 82, 137, 137, 422]]}
{"id": "wtccRf", "name": "A long time", "author": "dahart", "description": "Just wait to see what happens when the outer ring cycles the first time!", "tags": ["binary", "aliasing", "clock", "tree", "polar"], "likes": 8, "viewed": 84, "published": "Public", "date": "1609611080", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage(out vec4 c, vec2 p) {\n    p = 2.*p/iResolution.y - .5;\n    c = c-c+mod(floor(atan(p.y, p.x)/6.2831853*exp2(floor(length(p)*8.))+iTime),2.);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtccRf.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 36, 36, 156]]}
{"id": "wtcyDs", "name": "grid punk", "author": "fofod", "description": "simple grid punk", "tags": ["cooltablegridsimple"], "likes": 2, "viewed": 207, "published": "Public API", "date": "1610194053", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord/iResolution.xx -.5);\n\t//vec2 uv = (fragCoord.xy / iResolution.xx - 0.5)；\n\t float c = 0.02;\n         uv.y+=.22;\n\tuv*= abs(cos(iTime) + 1.);\n\n\tuv*= mat2(sin(iTime),cos(iTime),-cos(iTime),sin(iTime));\n\tvec3 p = vec3(uv,1.0);\n\tc = .3/length(uv);\n\tvec3 mask = fract(p*10.);\n\tvec3 mask1 = fract(p*100.);\n\t// mask*= vec3(1.,0.,0.);\n\tif(mask.x > .05 && mask.y > .05) {\n\t\tmask = vec3(0.);\n\t} else {\n\t\tmask = vec3(1.)*c;\n\t}\n\tif(mask1.x > .05 && mask1.y > .05) {\n\t\tmask1 = vec3(0.);\n\t} else {\n\t\tmask1 = vec3(1.)*c;\n\t}\n\tmask += mask1;\n\tvec3 col = mask * abs(sin(iTime)) * vec3(p +.3);\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtcyDs.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 107, 765]]}
{"id": "wtcyRf", "name": "something2021", "author": "jj99", "description": "globe thing", "tags": ["noise", "torus", "sphere", "plane"], "likes": 3, "viewed": 193, "published": "Public API", "date": "1609608199", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// fork of - https://www.shadertoy.com/view/3ltczj\n\n#define PLANET_RADIUS 1.4\n#define MAP_SCALE 2.0\n#define MAP_ROUGHNESS 5.0\n#define MAP_HEIGHT 0.35\n\nvec3 Hash33(in vec3 p) {\n    return vec3(fract(sin(dot(p, vec3(7643.54, 6854.95, 356.6765))) * 234.752),\n                fract(sin(dot(p, vec3(7853.67, 5214.327, 435.6437))) * 6734.8275),\n                fract(sin(dot(p, vec3(7546.754, 683.2647, 358.2431))) * 257.8643));\n}\n\nfloat noise(in vec3 p) {\n    return fract(sin(dot(p, vec3(3743.54, 2754.23, 578.537))) * 5664.865);\n}\n\nfloat snoise(in vec3 p)\n{\n\n    vec3 cell = floor(p);\n    vec3 local = fract(p);\n    local *= local * (3.0 - 2.0 * local);\n\n    float ldb = noise(cell);\n    float rdb = noise(cell + vec3(1.0, 0.0, 0.0));\n    float ldf = noise(cell + vec3(0.0, 0.0, 1.0));\n    float rdf = noise(cell + vec3(1.0, 0.0, 1.0));\n    float lub = noise(cell + vec3(0.0, 1.0, 0.0));\n    float rub = noise(cell + vec3(1.0, 1.0, 0.0));\n    float luf = noise(cell + vec3(0.0, 1.0, 1.0));\n    float ruf = noise(cell + 1.0);\n\n    return mix(mix(mix(ldb, rdb, local.x),\n                   mix(lub, rub, local.x),\n                   local.y),\n\n               mix(mix(ldf, rdf, local.x),\n                   mix(luf, ruf, local.x),\n                   local.y),\n\n               local.z);\n}\n\nfloat fnoise(in vec3 p) {\n\n    p *= MAP_SCALE;\n\n    float value = 0.0;\n    float nscale = 1.0;\n    float tscale = 0.0;\n\n    for (float octave=0.0; octave < MAP_ROUGHNESS; octave++) {\n        value += snoise(p) * nscale;\n        tscale += nscale;\n        nscale *= 0.5;\n        p *= 2.0;\n    }\n\n\tfloat nn = value / tscale;\n\tnn = clamp(nn,0.5,1.0);\n\t\n\t\n\treturn nn;\n\t//return value / tscale;\n}\n\nvec3 map(in vec3 p)\n{\n\tfloat n = fnoise(p);\n\tvec3 sea = vec3(0.25,0.55,0.95);\n\tvec3 lan1 = vec3(0.2, 1.1, 0.3);\n\tvec3 lan2 = vec3(1.1, 0.3, 0.3);\n\tvec3 color = mix(sea, mix(lan1, lan2, n ), float(n > 0.5));\n\treturn color;\n}\nfloat smin( float a, float b, float k )\n{\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\nfloat sdTorus( vec3 p, vec2 t )\n{\n    return length( vec2(length(p.xz)-t.x,p.y) )-t.y;\n}\n\nfloat mapScene(in vec3 p)\n{\n\tfloat earth = length(p) - PLANET_RADIUS;\n\tfloat off = fnoise(p) * MAP_HEIGHT;\n\t\n\tfloat d1 = sdTorus(p,vec2(2.0,0.0155));\n\tfloat d2 = sdTorus(p.yxz,vec2(2.0,0.0155));\n\tfloat d3 = sdTorus(p.yzx,vec2(2.0,0.0155));\n\td1 = smin(d1,d2,0.1);\n\td1 = smin(d1,d3,0.1);\n\n\tfloat d4 = p.y +1.7+sin(p.x*0.7+fract(iTime*0.4)*6.28+length(p))*0.17;\n\t\n\td1 = smin(d1,d4,0.3);\n\t\n\tearth = smin(earth,d1,0.15);\n\tearth-=off;\n\t\n\t\n\t\n\treturn earth*0.7;\n}\n\n\nvec3 getNormal( in vec3 pos )\n{\n    vec2 e = vec2(1.0,-1.0)*0.5773;\n    const float eps = 0.001;\n    return normalize( e.xyy*mapScene( pos + e.xyy*eps ) + \n\t\t\t\t\t  e.yyx*mapScene( pos + e.yyx*eps ) + \n\t\t\t\t\t  e.yxy*mapScene( pos + e.yxy*eps ) + \n\t\t\t\t\t  e.xxx*mapScene( pos + e.xxx*eps ) );\n}\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n    fragColor = vec4(0.0, 0.0, 0.0, 1.0);\n\tfloat vv1=uv.y+0.2*4.0;\n\tfragColor.rgb = vec3(0.03,0.2,0.06)*vv1;\n\n    vec3 ro = vec3(0., 0.2, 10.0+sin(iTime*0.7)*4.0);\n    vec3 rd = normalize(vec3(uv, -1.5));\n            vec3 l = vec3(-.74, .9, .0);\n\tl = normalize(l);\n\n    float t = 0.0;\n    for (float iters=0.0; iters < 200.0; iters++) {\n        vec3 p = ro + rd * t;\n\n        vec2 cs = sin(iTime + vec2(1.57, 0.0));\n        p.xz *= mat2(cs, -cs.y, cs.x);\n        //p.yz *= mat2(cs, -cs.y, cs.x);\n\n        float d = mapScene(p);\n        if (d < 0.001) {\n            vec3 n = getNormal(p);\n\n            //n.yz *= mat2(cs.x, -cs.y, cs.yx);\n            n.xz *= mat2(cs.x, -cs.y, cs.yx);\n\n            fragColor.rgb += map(p);\n\t\tfloat ddd = max(0.3, dot(n, l));\n            fragColor.rgb *=ddd;\n\t\t\n  \tvec3 ref = reflect(rd, n);\n\tfloat spe = max(dot(ref, l), 0.0);\n\t\t\n\t\tfragColor.rgb += pow(spe,8.0)*0.7;\n\t\t\n            break;\n        }\n\n        if (t > 20.0) {\n            break;\n        }\n\n        t += d;\n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtcyRf.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 151, 175, 175, 424], [426, 426, 450, 450, 527], [529, 529, 554, 554, 1281], [1283, 1283, 1308, 1308, 1673], [1675, 1675, 1696, 1696, 1898], [1899, 1899, 1940, 1940, 2033], [2034, 2034, 2067, 2067, 2122], [2124, 2124, 2151, 2151, 2579], [2582, 2582, 2613, 2613, 2871], [2874, 2874, 2929, 2929, 4004]]}
{"id": "wtcyWl", "name": "Blue Mandelbulb", "author": "rmheuer", "description": "Raymarcher with basic light rendering a mandelbulb", "tags": ["raymarch"], "likes": 2, "viewed": 39, "published": "Public", "date": "1610571873", "time_retrieved": "2021-10-01T00:00:00", "image_code": "precision highp float;\n\nconst int MAX_STEPS = 1000;\nconst float EPSILON = 0.001;\n\nmat4 rotate(float a) {\n    float sine = sin(a);\n    float cosine = cos(a);\n    mat4 mat = mat4(\n    cosine, 0, sine, 0,\n    0, 1, 0, 0,\n    -sine, 0, cosine, 0,\n    0, 0, 0, 1\n    );\n    return inverse(mat);\n}\n\nfloat sdfMandelbulb( vec3 p )\n{\n    vec3 w = p;\n    float m = dot(w,w);\n\n    vec4 trap = vec4(abs(w),m);\n\tfloat dz = 1.0;\n    \n    \n\tfor( int i=0; i<4; i++ )\n    {\n#if 0\n        float m2 = m*m;\n        float m4 = m2*m2;\n\t\tdz = 8.0*sqrt(m4*m2*m)*dz + 1.0;\n\n        float x = w.x; float x2 = x*x; float x4 = x2*x2;\n        float y = w.y; float y2 = y*y; float y4 = y2*y2;\n        float z = w.z; float z2 = z*z; float z4 = z2*z2;\n\n        float k3 = x2 + z2;\n        float k2 = inversesqrt( k3*k3*k3*k3*k3*k3*k3 );\n        float k1 = x4 + y4 + z4 - 6.0*y2*z2 - 6.0*x2*y2 + 2.0*z2*x2;\n        float k4 = x2 - y2 + z2;\n\n        w.x = p.x +  64.0*x*y*z*(x2-z2)*k4*(x4-6.0*x2*z2+z4)*k1*k2;\n        w.y = p.y + -16.0*y2*k3*k4*k4 + k1*k1;\n        w.z = p.z +  -8.0*y*k4*(x4*x4 - 28.0*x4*x2*z2 + 70.0*x4*z4 - 28.0*x2*z2*z4 + z4*z4)*k1*k2;\n#else\n        dz = 8.0*pow(sqrt(m),7.0)*dz + 1.0;\n\t\t//dz = 8.0*pow(m,3.5)*dz + 1.0;\n        \n        float r = length(w);\n        float b = 8.0*acos( w.y/r);\n        float a = 8.0*atan( w.x, w.z );\n        w = p + pow(r,8.0) * vec3( sin(b)*sin(a), cos(b), sin(b)*cos(a) );\n#endif        \n        \n        trap = min( trap, vec4(abs(w),m) );\n\n        m = dot(w,w);\n\t\tif( m > 256.0 )\n            break;\n    }\n\n    //resColor = vec4(m,trap.yzw);\n\n    return 0.25*log(m)*sqrt(m)/dz;}\n\nfloat sceneSDF( vec4 pos )\n{\n    // SDF of sphere with radius 1\n    return sdfMandelbulb((rotate(iTime / 3.0) * pos).xyz / 2.0) * 2.0;\n}\n\nfloat raymarch( in float start, in float end, in vec4 eyePos, in vec4 viewRay ) \n{\n    float depth = start;\n    \n    for (int i = 0; i < MAX_STEPS; i++) \n    {\n        float dist = sceneSDF(eyePos + depth * viewRay);\n        \n        if (dist < EPSILON) \n        {\n            return depth;\n        }\n        \n        depth += dist;\n        \n        if (depth >= end)\n        {\n            return end;\n        }\n    }\n    \n    return end;\n}\n\nvec4 estimateNormal(vec4 p) \n{\n    return normalize(vec4(\n        sceneSDF(vec4(p.x + EPSILON, p.y, p.z, p.w)) - sceneSDF(vec4(p.x - EPSILON, p.y, p.z, p.w)),\n        sceneSDF(vec4(p.x, p.y + EPSILON, p.z, p.w)) - sceneSDF(vec4(p.x, p.y - EPSILON, p.z, p.w)),\n        sceneSDF(vec4(p.x, p.y, p.z + EPSILON, p.w)) - sceneSDF(vec4(p.x, p.y, p.z - EPSILON, p.w)),\n        sceneSDF(vec4(p.x, p.y, p.z, p.w + EPSILON)) - sceneSDF(vec4(p.x, p.y, p.z, p.w - EPSILON))\n    ));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    const vec4 eye = vec4(0, 0, -4, 0);\n    float aspect = iResolution.x / iResolution.y;\n    vec4 ray = normalize(vec4(((fragCoord.xy / iResolution.xy) - vec2(0.5)) * vec2(aspect, 1), 1, 0));\n\n    float march = raymarch(EPSILON, 100.0, eye, ray);\n\n    if (march > 100.0 - 1.0) \n    {\n        fragColor = vec4(0, 0, 0, 1);\n        return;\n    }\n    \n    const vec3 surfaceColor = vec3(0.5, 0.5, 1.0);\n    const float ambientLight = 0.2;\n    vec4 lightPos = vec4(0.0, 2.0, -4.0, 0.0);\n    \n    vec4 collisionPoint = eye + march * ray;\n    vec4 normal = estimateNormal(collisionPoint);\n    vec4 toLight = normalize(lightPos - collisionPoint);\n    float ndotl = dot(normal, toLight);\n    vec3 color = surfaceColor * clamp(ndotl, ambientLight, 1.0);\n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtcyWl.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[82, 82, 104, 104, 291], [293, 293, 324, 324, 1601], [1603, 1603, 1631, 1666, 1739], [1741, 1741, 1823, 1823, 2181], [2183, 2183, 2213, 2213, 2653], [2655, 2655, 2712, 2712, 3494]]}
{"id": "Wtdczf", "name": "Trig Approximations", "author": "oneshade", "description": "Approximations of the sine, cosine, and tangent trig functions using Bhaskara I's formula.", "tags": ["cheap", "approximation", "trig", "bhaskara"], "likes": 3, "viewed": 60, "published": "Public", "date": "1609633003", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI 3.1415926535\n#define HALF_PI 1.5707963268\n#define TWO_PI 6.2831853072\n#define FIVE_PI_SQUARED 49.348022005\n\nfloat cheapSin(in float x) {\n    float nx = mod(x, PI);\n    float PI_MINUS_X = PI - nx;\n    float y = (16.0 * nx * PI_MINUS_X) / (FIVE_PI_SQUARED - 4.0 * nx * PI_MINUS_X);\n    return mod(x, TWO_PI) < PI ? y : -y;\n}\n\nfloat cheapCos(in float x) {\n    return cheapSin(x + HALF_PI);\n}\n\nfloat cheapTan(in float x) {\n    return cheapSin(x) / cheapCos(x);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y * 4.0;\n    float unit = 16.0 / iResolution.y;\n\n    uv.x += iTime;\n\n    fragColor = vec4(smoothstep(unit, 0.0, abs(uv.y - cheapSin(uv.x))), 0.0, 0.0, 1.0);\n    fragColor.b += smoothstep(unit, 0.0, abs(uv.y - cheapCos(uv.x)));\n    fragColor.g += smoothstep(unit, 0.0, abs(uv.y - cheapTan(uv.x)));\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Wtdczf.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[119, 119, 147, 147, 333], [335, 335, 363, 363, 399], [401, 401, 429, 429, 469], [471, 471, 526, 526, 888]]}
{"id": "WtdfRn", "name": "boolean,polarmod 02", "author": "kithy", "description": "boolean,polarmod", "tags": ["boolean", "polarmod"], "likes": 2, "viewed": 36, "published": "Public", "date": "1612105416", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n\nfloat distFuncCube(vec3 p){\n\tvec3 q=abs(p);\n\treturn length(max(q-vec3(0.5,0.2,0.9),0.0));\n}\n\nfloat distFuncSphere(vec3 p){\n\tfloat s=0.5;\n\treturn length(p)-s;\n}\n\n\nvec2 pmod(vec2 p,float n){\n\tfloat np=3.141592*2.0/n;\n\tfloat r=atan(p.x,p.y)-0.5*np;\n\tr=mod(r,np)-0.5*np;\n\treturn length(p)*vec2(cos(r),sin(r));\n}\n\n\nfloat distFunc(vec3 p){\n\tp.z-=iTime*2.0;\n\tp.xy=pmod(p.xy,6.0);\n\tp=mod(p,0.8)-0.4;\n\tfloat d3=distFuncCube(p);\n\tfloat d4=distFuncSphere(p);\n\n\t//return(d3);\n\t//return(d4);\n\n\t//return min(d3,d4);//OR\n\n\t//return max(d3,d4);//AND\n\n\treturn max(d3,-d4);\n\t\n\t//return max(-d3,d4);\n\n}\n\n\nvoid mainImage(out vec4 fragColor,in vec2 fragCoord){\n\tvec2 p=(2.0*fragCoord.xy-iResolution.xy)/min(iResolution.x,iResolution.y);\n\n\tfloat radius=0.1;\n\tfloat phi=iTime*0.2;\n\tvec3 ro=vec3(cos(phi)*radius,0.0,(sin(phi)*radius));\n\tvec3 ta=vec3(0.0);\n\t\n\tvec3 cDir=normalize(ta-ro);\n\tvec3 cSide=cross(cDir,vec3(0.0,1.0,0.0));\n\tvec3 cUp=cross(cSide,cDir);\n\tfloat fov=0.6;\n\n\tvec3 rd=normalize(p.x*cSide+p.y*cUp+cDir*fov);\n\tfloat d,t=0.0;\n\t\n\tfloat emission=0.0;\n\n\tfor(int i=0;i<48;i++){\n\t\td=distFunc(ro+rd*t);\n\t\temission+=exp(abs(d)*-0.2);\n\t\tif(d<0.001)break;\n\t\tt+=d;\n\t\t}\n\n\tvec3 col=0.03*emission*vec3(0.3,sin(iTime*0.5),cos(iTime*0.5));\n\t\n\tfragColor=vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WtdfRn.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[2, 2, 29, 29, 93], [95, 95, 124, 124, 161], [164, 164, 190, 190, 309], [312, 312, 335, 335, 585], [588, 588, 641, 641, 1246]]}
{"id": "WtdfRr", "name": "sphere23", "author": "edwardbraed", "description": "Just a first raymarch experiment..", "tags": ["raymarch", "sphere"], "likes": 1, "viewed": 46, "published": "Public", "date": "1612130694", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define MAX_STEPS_MARCH 64\n#define SPHERE_RADIUS 1.0\n#define COLOR vec3(0.8, 0.5, 1.0)\n\nfloat raymarch(vec3 ro, vec3 rd, vec3 lv, float g)\n{\n    float t = 0.0;\n    for(int x = 0; x < MAX_STEPS_MARCH; x++)\n    {\n        vec3 pos = ro + rd * t;\n        float d = length(pos) - SPHERE_RADIUS;\n        if(d < 0.001)\n        {\n            float l = dot(normalize(lv), normalize(pos));\n            return max(l, 0.1);\n        }\n        \n        t += d;\n    }\n    \n    return g;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    // aspect ratio for correction rays..\n    float a = iResolution.x / iResolution.y;\n    \n    // pseudo perspective pyramid (directions rays)\n    vec2 dTr = vec2(1.0, 1.0);\n    vec2 dTl = vec2(-1.0, 1.0);\n    vec2 dBr = vec2(1.0, -1.0);\n    vec2 dBl = vec2(-1.0, -1.0);\n    \n    // common uv ray direction\n    vec3 rd = vec3(mix(mix(dBl, dBr, uv.x),\n                       mix(dTl, dTr, uv.x), uv.y),\n                   1.0);\n    rd.x *= a;\n    \n    // origin direction (or pseudo camera position)\n    vec3 ro = vec3(0.0, 0.0, -2.0);\n    // light vector\n    vec3 lv = vec3(sin(iTime), 0.5, cos(iTime));\n    // background gradient\n    float g = pow(1.0 - distance(uv, vec2(0.5)), 2.0) * 0.7;\n    \n    vec3 rgb = vec3(COLOR * raymarch(ro, rd, lv, g));\n    \n    // Output to screen\n    fragColor = vec4(rgb, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WtdfRr.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[88, 88, 140, 140, 473], [475, 475, 532, 582, 1442]]}
{"id": "Wtdfzr", "name": "Sunday fractals", "author": "mrange", "description": "License CC0: Sunday fractals\nInspired by: http://www.fractalforums.com/new-theories-and-research/very-simple-formula-for-fractal-patterns/\nSABS from ollj\n", "tags": ["2d", "fractal"], "likes": 6, "viewed": 242, "published": "Public API", "date": "1612125971", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// License CC0: Sunday fractals\n// Inspired by: http://www.fractalforums.com/new-theories-and-research/very-simple-formula-for-fractal-patterns/\n// SABS from ollj\n\n#define RESOLUTION      iResolution\n#define TIME            iTime\n#define PI              3.141592654\n#define TAU             (2.0*PI)\n#define LESS(a,b,c)     mix(a,b,step(0.,c))\n#define SABS(x,k)       LESS((.5/(k))*(x)*(x)+(k)*.5,abs(x),abs(x)-(k))\n#define ROT(a)          mat2(cos(a), sin(a), -sin(a), cos(a))\n#define L2(x)           dot(x,x)\n#define PSIN(x)         (0.5+0.5*sin(x))\n#define PERIOD          30.0\n#define NPERIOD         floor(TIME/PERIOD)\n#define TIMEINPERIOD    mod(TIME, PERIOD)\n#define FADE            1.0\n#define HPERIOD         hash(NPERIOD)\n\nfloat hash(float co) {\n  co += 2313.0;\n  return fract(sin(co*12.9898) * 13758.5453);\n}\n\nfloat tanh_approx(float x) {\n  return tanh(x);\n  /*\n  float x2 = x*x;\n  return clamp(x*(27.0 + x2)/(27.0+9.0*x2), -1.0, 1.0);\n  */\n}\n\nvec2 toPolar(vec2 p) {\n  return vec2(length(p), atan(p.y, p.x));\n}\n\nvec2 toRect(vec2 p) {\n  return vec2(p.x*cos(p.y), p.x*sin(p.y));\n}\n\nfloat modMirror1(inout float p, float size) {\n  float halfsize = size*0.5;\n  float c = floor((p + halfsize)/size);\n  p = mod(p + halfsize,size) - halfsize;\n  p *= mod(c, 2.0)*2.0 - 1.0;\n  return c;\n}\n\nfloat smoothKaleidoscope(inout vec2 p, float sm, float rep) {\n  vec2 hp = p;\n\n  vec2 hpp = toPolar(hp);\n  float rn = modMirror1(hpp.y, TAU/rep);\n\n  float sa = PI/rep - SABS(PI/rep - abs(hpp.y), sm);\n  hpp.y = sign(hpp.y)*(sa);\n\n  hp = toRect(hpp);\n\n  p = hp;\n\n  return rn;\n}\n\nfloat height(vec2 p, vec2 c, float hh) {\n  p*=mix(1.5, 0.5, TIMEINPERIOD/PERIOD);\n  p+=mix(0.2, 0.0, TIMEINPERIOD/PERIOD);\n  p*=ROT(TIMEINPERIOD*0.05);\n  vec2 op = p;\n  float l2 = L2(p);\n  float rep = 2.0*round(mix(3.0, 30.0, hh*hh));\n  float s = 0.05*6.0/rep;\n  float n = smoothKaleidoscope(p, s, rep);\n  p *= ROT(TAU*hh);\n  vec2 u = p;\n\n  float a = 0.0;\n\n  \n  for (int i = 0; i < 13; ++i) {\n    float m = dot(u, u);\n    u = SABS(u, 0.025)/m + c;\n  }\n  \n  float h = L2(u-p);\n  h = log(h-hh);\n  h = abs(h);\n  h = tanh_approx(.45*h*h+0.125/(l2+0.125));\n  \n  return h;\n}\n\nvec3 normal(vec2 p, vec2 c, float hh) {\n  vec2 v;\n  vec2 w;\n  vec2 e = vec2(4.0/RESOLUTION.y, 0);\n  \n  vec3 n;\n  n.x = height(p + e.xy, c, hh) - height(p - e.xy, c, hh);\n  n.y = 2.0*e.x;\n  n.z = height(p + e.yx, c, hh) - height(p - e.yx, c, hh);\n  \n  return normalize(n);\n}\n\nvec3 hsv2rgb(vec3 c) {\n  const vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n  vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n  return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvec3 postProcess(vec3 col, vec2 q)  {\n  col=pow(clamp(col,0.0,1.0),vec3(1.0/2.2)); \n  col=col*0.6+0.4*col*col*(3.0-2.0*col);  // contrast\n  col=mix(col, vec3(dot(col, vec3(0.33))), -0.4);  // saturation\n  col*=0.5+0.5*pow(19.0*q.x*q.y*(1.0-q.x)*(1.0-q.y),0.7);  // vigneting\n  return col;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  const float s = 1.25;\n  const vec3 lp1 = s*vec3(1.0, 2.25, 1.0)*vec3(s, 1.0, s);\n  const vec3 lp2 = s*vec3(-1.0, 2.25, 1.0)*vec3(s, 1.0, s);\n  \n  vec2 q = fragCoord/RESOLUTION.xy;\n  vec2 p = -1. + 2. * q;\n  p.x *= RESOLUTION.x/RESOLUTION.y;\n\n  float hh = HPERIOD;\n\n  vec3 col = vec3(0.0);\n  vec2  c = vec2(-0.4-0.2*fract(7.0*hh), -0.4-0.2*fract(13.0*hh));\n\n  float h = height(p, c, hh);\n  vec3  n = normal(p, c, hh);\n\n  vec3 ro = vec3(0.0, -10.0, 0.0);\n  vec3 pp = vec3(p.x, 0.0, p.y);\n\n  vec3 po = vec3(p.x, h, p.y);\n  vec3 rd = normalize(po - ro);\n\n  vec3 ld1 = normalize(lp1 - po);\n  vec3 ld2 = normalize(lp2 - po);\n\n  float l = length(p);\n\n  vec3 hsv1 = vec3(hh+mix(0.0, 0.2, PSIN(0.3*TIME-2.0*l+(p.x+p.y))), tanh_approx(h*h), tanh_approx(3.0*h*h));\n  hsv1.yz = clamp(hsv1.yz, 0.0, 1.0);\n  vec3 col1 = hsv2rgb(hsv1);\n  vec3 col2 = pow(col1, vec3(0.25, 0.5, 2.0));\n\n  float diff1 = max(dot(n, ld1), 0.0);\n  float diff2 = max(dot(n, ld2), 0.0);\n\n  vec3  ref   = reflect(rd, n);\n  float ref1  = max(dot(ref, ld1), 0.0);\n  float ref2  = max(dot(ref, ld2), 0.0);\n\n  col += col1*mix(0.1, 1.0, pow(diff1, 8.0))*0.5;\n  col += col2*mix(0.1, 1.0, pow(diff2, 8.0))*0.5;\n  col = pow(col, vec3(1.5));\n  col += 8.0*col1*pow(ref1, 40.0);\n  col += 4.0*col2*pow(ref2, 10.0);\n\n  col = tanh(2.5*col);\n  col = postProcess(col, q);\n  \n  float fadeIn  = smoothstep(0.0, FADE, TIMEINPERIOD);\n  float fadeOut = 1.0-smoothstep(PERIOD-FADE, PERIOD, TIMEINPERIOD);\n  col = mix(vec3(0.0), col, fadeIn*fadeIn*fadeOut*fadeOut);\n  \n  fragColor = vec4(col, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Wtdfzr.jpg", "access": "shaders20k", "license": "cc0-1.0", "functions": [[0, 732, 754, 754, 818], [820, 820, 848, 848, 952], [954, 954, 976, 976, 1020], [1022, 1022, 1043, 1043, 1088], [1090, 1090, 1135, 1135, 1289], [1291, 1291, 1352, 1352, 1565], [1567, 1567, 1607, 1607, 2135], [2137, 2137, 2176, 2176, 2410], [2412, 2412, 2434, 2434, 2603], [2605, 2605, 2642, 2642, 2895], [2897, 2897, 2952, 2952, 4491]]}
{"id": "WtdyDs", "name": "Triangle Subdivision 1", "author": "mherreshoff", "description": "Recursively divides up a triangle at random.  Uses circular transition wipes between the levels.", "tags": ["triangle", "animation", "subdivision"], "likes": 3, "viewed": 58, "published": "Public", "date": "1610226083", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI 3.14159\n#define hue(v) ( .6 + .6 * cos( 6.3*(v) + vec4(0,23,21,0) ) )\n#define hash21(p) fract(sin(dot(p, vec2(12.9898, 78.233))) * 43758.5453)\n#define hash33(p) fract(sin( (p) * mat3( 127.1,311.7,74.7 , 269.5,183.3,246.1 , 113.5,271.9,124.6) ) *43758.5453123)\n\nbool insideTriangle(vec2 a, vec2 b, vec2 c, vec2 p) {\n    vec2 q = inverse(mat2(b-a, c-a))*(p-a);\n    return q.x >= 0. && q.y >= 0. && q.x+q.y <= 1.;\n}\n\nvec3 colorize (vec3 r) {\n    int c = int(r.z*5.);\n    if (c == 0) return vec3(38, 70, 83)/255.;\n    if (c == 1) return vec3(42, 157, 143)/255.;\n    if (c == 2) return vec3(233, 196, 106)/255.;\n    if (c == 3) return vec3(244, 162, 97)/255.;\n    /* c == 4*/ return vec3(231, 111, 81)/255.;\n}\n\nvec4 render(vec2 U) {\n\n    vec2 R = iResolution.xy, pw=1./R, uv=U*pw, z=1.04*(2.0*U-R)/R.y;\n    \n    vec2 a = vec2(2./sqrt(3.), -1.), b = vec2(0,1), c = vec2(-2./sqrt(3.), -1.);\n    vec2 tmp;\n#define SWAP(_v, _w) {tmp=_v; _v=_w; _w=tmp;}\n\n    if (!insideTriangle(a,b,c,z)) {\n        return vec4(0);\n    }\n    \n    float t = fract(iTime/40.);\n    float iterations = .3+14.*(.5-abs(t-.5));\n    float fill = 1.;\n    vec3 rand = hash33(vec3(float(fill), 0, 0));\n    vec3 prevRand;\n    vec4 oldColor, newColor;\n    for (int i = 0; i < 10; i++) {\n        if (float(i) >= floor(iterations)+1.) continue;\n        if (i == 0) {\n            oldColor = vec4(0);\n            newColor = vec4(colorize(rand), 1.);\n        } else {\n            oldColor = newColor;\n            if (rand.x > .66) {\n                SWAP(a, c);\n            } else if(rand.x > .33){ \n                SWAP(a,b);\n            }\n            float div = .25+.5*rand.y+.1*sin(iTime);\n            vec2 n = mix(b, c, div);\n            fill *= 2.;\n            if (insideTriangle(a,b,n,z)) {\n                c = n; fill+=1.;\n            } else {\n                b = n;\n            }\n            prevRand = rand;\n            rand = hash33(vec3(float(fill), 0, 0));\n            newColor = vec4(colorize(rand), 1.0);\n        }\n    }\n    \n    vec2 center = (a+b+c)/3.;\n    float maxDist = max(\n        distance(a,center),\n        max(distance(b,center), distance(c,center)));\n    float f = distance(z, center) / maxDist;\n    float transition = clamp(0.,1.,.5+3.*(fract(iterations)-.5));\n    if (f < transition) {\n        return newColor;\n    } else {\n        return oldColor;\n    }\n}\nvoid mainImage( out vec4 O, in vec2 U ) {\n    vec2 d = vec2(.5,0);\n    O = (\n        render(U+d.xy)+\n        render(U-d.xy)+\n        render(U+d.yx)+\n        render(U-d.yx)\n    )*.25;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WtdyDs.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[272, 272, 325, 325, 423], [425, 425, 449, 449, 715], [717, 717, 738, 738, 2350], [2351, 2351, 2392, 2392, 2535]]}
{"id": "wtdyRj", "name": "glitchy sin noise", "author": "sawtoothm", "description": "first shader, trying to convert old c code.  absolute beginner, so any tips or advice would be helpful.", "tags": ["beginner"], "likes": 2, "viewed": 41, "published": "Public", "date": "1609529626", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float cc = 127.5;\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    float x = (fragCoord.x)+iResolution.x/2.0;\n    float y = (fragCoord.y)+iResolution.y/2.0;\n\n    // Time varying pixel color\n\n    float t = sin(iTime)+0.5;\n    float layer1 = cc + (cc * sin(x / t));\n    float layer2 = cc + (cc * cos(y + x / t));\n    float layer3 = cc + (cc * sin(sqrt(x * x + y * y) / t));\n    \n    float c = (layer3 + layer2 + layer1) / 3.0;\n    \n    vec3 col =vec3(c/256.0, 0,0); \n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtdyRj.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 629]]}
{"id": "wtdyW2", "name": "kaleidoscope of noise patterns", "author": "AI", "description": "We use polar coordinates to create such symmetric patterns\nChange the constant parameters of the program to see other variants.", "tags": ["2d", "noise", "kaleidoscope", "pattern", "polar", "bilinear", "generativeart", "creativecoding"], "likes": 3, "viewed": 176, "published": "Public API", "date": "1609961394", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const float PI = 3.141592658;\nconst float TWOPI = 2.0 * PI;\n\n// pseudo-random function, returns value between [0.,1.]\nfloat rand (in vec2 st) {\n    return fract(sin(dot(st.xy,\n                         vec2(31.7667,14.9876)))\n                 * 833443.123456);\n}\n\n//bilinear value noise function\nfloat bilinearNoise (in vec2 st) {\n    vec2 i = floor(st);\n    vec2 f = fract(st);\n\n    // Four corners of a 2D square\n    float f00 = rand(i);\n    float f10 = rand(i + vec2(1.0, 0.0));\n    float f01 = rand(i + vec2(0.0, 1.0));\n    float f11 = rand(i + vec2(1.0, 1.0));\n\n    vec2 u = smoothstep(0.,1.,(1.-f));\n\treturn u.x*u.y*f00+(1.-u.x)*u.y*f10+\n    u.x*(1.-u.y)*f01+(1.-u.x)*(1.-u.y)*f11;\n    \n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n  vec2 uv =fragCoord.xy/ iResolution.xy;\n  //from Cartesian to polar coordinates\n  float scale=3.;\n  uv=fract(scale*uv)-.5;\n  float radius = length(uv);\n  float angle = atan(uv.y, uv.x);\n  //change Nsections using horizontal movement of mouse\n    float Nsections=20.;//-15.*iMouse.x/iResolution.x;\n  //create Nsections which are identical\n  float angleM = mod(angle, TWOPI/Nsections);\n  //make each section symmetric along its bisector\n  angleM = abs(angleM -PI/Nsections);\n  //back to Cartesian coordinates\n  uv = radius*vec2(cos(angleM),sin(angleM));\n  uv=sin(uv+.04*iTime);\n  vec3 color=vec3(bilinearNoise(100.*uv),bilinearNoise(75.*uv),bilinearNoise(50.*uv));\n  fragColor = vec4(color,1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtdyW2.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[61, 118, 143, 143, 261], [263, 295, 329, 329, 693], [696, 696, 752, 752, 1448]]}
{"id": "wtdyzf", "name": "Alfx Fog 1", "author": "chenwanwan13", "description": "simple large-scale fog", "tags": ["fog"], "likes": 0, "viewed": 58, "published": "Public", "date": "1609669368", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define MAX_STEPS 1000\n#define MAX_DIST 1000.0\n#define SMALL_DIST 0.01\n\n//color setting\nvec3 sphereCol = vec3(0.98,0.89,0.32);\nvec3 planeCol = vec3(0.86, 0.3, 0.43);\nvec3 fogCol = vec3(1.0, 1.0, 1.0);\nfloat fogdepth = 11.0;\n\n//----------------------------------\nfloat DistSphere(vec3 p, vec4 sphere) {\n    return length(p - sphere.xyz) - sphere.w;\n}\n\nvec4 GetDist(vec3 p) {\n    vec3  m = vec3(0.0,0.5,7.0);\n   \n    \n    vec4 sphere0 = vec4(m.x, m.y , m.z, 0.5); \n    sphere0.xz += 2.0*vec2(sin(2.0 * iTime), 2.0 * cos(iTime)); \n    \n    float DistPlane = p.y;\n    float Sphere = DistSphere(p, sphere0);\n    float minimum = min(Sphere, DistPlane);\n   \n    if (minimum == Sphere) {\n        return vec4(sphereCol, Sphere);\n    }\n    return vec4(planeCol, DistPlane);\n}\n\nfloat RayMarch (vec3 RayOri, vec3 RayDi) {\n    float DistOrig = 0.0;\n    for (int i = 0; i < MAX_STEPS; ++i) {\n        vec3 p = RayOri + DistOrig * RayDi;\n        float dist = GetDist(p).w;\n        DistOrig += dist;\n        if (dist < SMALL_DIST || DistOrig > MAX_DIST) break;\n    }\n    return DistOrig;\n}\n\nvec3 GetColour(vec3 p) {\n    vec3 col = vec3(0.0);\n    for (int i = 0; i < 1; ++i) {\n        vec3 amb = GetDist(p).xyz * 0.9;\n        col += (amb);\n    }\n\n    float fog = 1.0-clamp(length(p) / 13.0, 0.0, 1.0); //method 1\n    fog = exp(-0.22*length(p));//method 2 beer-lambert\n\tcol = fogCol * (1.0 - fog) + fog * col;\n    return col;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n    vec3 col = vec3(0.0, 0.0, 0.0);\n    vec3 RayOri = vec3(0, 1, 0);\n    vec3 RayDi = normalize(vec3(uv.x, uv.y, 1));\n    float d = RayMarch(RayOri, RayDi);\n    vec3 p = RayOri + RayDi * d;\n    col = GetColour(p);\n    fragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtdyzf.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[225, 262, 301, 301, 349], [351, 351, 373, 373, 765], [767, 767, 809, 809, 1072], [1074, 1074, 1098, 1098, 1408], [1410, 1410, 1465, 1465, 1779]]}
{"id": "wtGcD3", "name": "Castle in the field and guardian", "author": "intrakits", "description": "I am making a cool castle thing. I also tried to make a character for the first time.", "tags": ["3d", "wall", "grass", "castle", "character", "weapon"], "likes": 12, "viewed": 387, "published": "Public API", "date": "1611882735", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#if HW_PERFORMANCE==0\n#define AA 1\n#else\n#define AA 2   // make this 2 or 3 for antialiasing\n#endif\n#define MAX_STEPS 200\n#define MAX_DIST 200.\n#define SURFACE_DIST 0.01\n//------------------------------------------------------------------\nfloat dot2( in vec2 v ) { return dot(v,v); }\nfloat dot2( in vec3 v ) { return dot(v,v); }\nfloat ndot( in vec2 a, in vec2 b ) { return a.x*b.x - a.y*b.y; }\n\nfloat sdPlane( vec3 p )\n{\n\treturn p.y;\n}\n\nvec2 sdSphere( vec3 p, float s )\n{\n    return vec2(length(p)-s,0);\n}\n\nvec2 sdBox( vec3 p, vec3 b )\n{\n    vec3 d = abs(p) - b;\n    return vec2(min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0)),1.);\n}\n\nvec2 sdBoundingBox( vec3 p, vec3 b, float e )\n{\n       p = abs(p  )-b;\n  vec3 q = abs(p+e)-e;\n\n  return vec2(min(min(\n      length(max(vec3(p.x,q.y,q.z),0.0))+min(max(p.x,max(q.y,q.z)),0.0),\n      length(max(vec3(q.x,p.y,q.z),0.0))+min(max(q.x,max(p.y,q.z)),0.0)),\n      length(max(vec3(q.x,q.y,p.z),0.0))+min(max(q.x,max(q.y,p.z)),0.0)),2.);\n}\nvec2 sdEllipsoid( in vec3 p, in vec3 r ) // approximated\n{\n    float k0 = length(p/r);\n    float k1 = length(p/(r*r));\n    return vec2(k0*(k0-1.0)/k1,3.);\n}\n\nfloat sdTorus( vec3 p, vec2 t )\n{\n    return length( vec2(length(p.xz)-t.x,p.y) )-t.y;\n}\n\nfloat sdCappedTorus(in vec3 p, in vec2 sc, in float ra, in float rb)\n{\n    p.x = abs(p.x);\n    float k = (sc.y*p.x>sc.x*p.y) ? dot(p.xy,sc) : length(p.xy);\n    return sqrt( dot(p,p) + ra*ra - 2.0*ra*k ) - rb;\n}\n\nfloat sdHexPrism( vec3 p, vec2 h )\n{\n    vec3 q = abs(p);\n\n    const vec3 k = vec3(-0.8660254, 0.5, 0.57735);\n    p = abs(p);\n    p.xy -= 2.0*min(dot(k.xy, p.xy), 0.0)*k.xy;\n    vec2 d = vec2(\n       length(p.xy - vec2(clamp(p.x, -k.z*h.x, k.z*h.x), h.x))*sign(p.y - h.x),\n       p.z-h.y );\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat sdOctogonPrism( in vec3 p, in float r, float h )\n{\n  const vec3 k = vec3(-0.9238795325,   // sqrt(2+sqrt(2))/2 \n                       0.3826834323,   // sqrt(2-sqrt(2))/2\n                       0.4142135623 ); // sqrt(2)-1 \n  // reflections\n  p = abs(p);\n  p.xy -= 2.0*min(dot(vec2( k.x,k.y),p.xy),0.0)*vec2( k.x,k.y);\n  p.xy -= 2.0*min(dot(vec2(-k.x,k.y),p.xy),0.0)*vec2(-k.x,k.y);\n  // polygon side\n  p.xy -= vec2(clamp(p.x, -k.z*r, k.z*r), r);\n  vec2 d = vec2( length(p.xy)*sign(p.y), p.z-h );\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nvec2 sdCapsule( vec3 p, vec3 a, vec3 b, float r )\n{\n\tvec3 pa = p-a, ba = b-a;\n\tfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n\treturn vec2(length( pa - ba*h ) - r,16.);\n}\n\nfloat sdRoundCone( in vec3 p, in float r1, float r2, float h )\n{\n    vec2 q = vec2( length(p.xz), p.y );\n    \n    float b = (r1-r2)/h;\n    float a = sqrt(1.0-b*b);\n    float k = dot(q,vec2(-b,a));\n    \n    if( k < 0.0 ) return length(q) - r1;\n    if( k > a*h ) return length(q-vec2(0.0,h)) - r2;\n        \n    return dot(q, vec2(a,b) ) - r1;\n}\n\nfloat sdRoundCone(vec3 p, vec3 a, vec3 b, float r1, float r2)\n{\n    // sampling independent computations (only depend on shape)\n    vec3  ba = b - a;\n    float l2 = dot(ba,ba);\n    float rr = r1 - r2;\n    float a2 = l2 - rr*rr;\n    float il2 = 1.0/l2;\n    \n    // sampling dependant computations\n    vec3 pa = p - a;\n    float y = dot(pa,ba);\n    float z = y - l2;\n    float x2 = dot2( pa*l2 - ba*y );\n    float y2 = y*y*l2;\n    float z2 = z*z*l2;\n\n    // single square root!\n    float k = sign(rr)*rr*rr*x2;\n    if( sign(z)*a2*z2 > k ) return  sqrt(x2 + z2)        *il2 - r2;\n    if( sign(y)*a2*y2 < k ) return  sqrt(x2 + y2)        *il2 - r1;\n                            return (sqrt(x2*a2*il2)+y*rr)*il2 - r1;\n}\n\nfloat sdTriPrism( vec3 p, vec2 h )\n{\n    const float k = sqrt(3.0);\n    h.x *= 0.5*k;\n    p.xy /= h.x;\n    p.x = abs(p.x) - 1.0;\n    p.y = p.y + 1.0/k;\n    if( p.x+k*p.y>0.0 ) p.xy=vec2(p.x-k*p.y,-k*p.x-p.y)/2.0;\n    p.x -= clamp( p.x, -2.0, 0.0 );\n    float d1 = length(p.xy)*sign(-p.y)*h.x;\n    float d2 = abs(p.z)-h.y;\n    return length(max(vec2(d1,d2),0.0)) + min(max(d1,d2), 0.);\n}\n\n// vertical\nvec2 sdCylinder( vec3 p, vec2 h )\n{\n    vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n    return vec2(min(max(d.x,d.y),0.0) + length(max(d,0.0)),21.);\n}\n\n// arbitrary orientation\nvec2 sdCylinder(vec3 p, vec3 a, vec3 b, float r)\n{\n    vec3 pa = p - a;\n    vec3 ba = b - a;\n    float baba = dot(ba,ba);\n    float paba = dot(pa,ba);\n\n    float x = length(pa*baba-ba*paba) - r*baba;\n    float y = abs(paba-baba*0.5)-baba*0.5;\n    float x2 = x*x;\n    float y2 = y*y*baba;\n    float d = (max(x,y)<0.0)?-min(x2,y2):(((x>0.0)?x2:0.0)+((y>0.0)?y2:0.0));\n    return vec2(sign(d)*sqrt(abs(d))/baba,21.);\n}\n\n// vertical\nfloat sdCone( in vec3 p, in vec2 c, float h )\n{\n    vec2 q = h*vec2(c.x,-c.y)/c.y;\n    vec2 w = vec2( length(p.xz), p.y );\n    \n\tvec2 a = w - q*clamp( dot(w,q)/dot(q,q), 0.0, 1.0 );\n    vec2 b = w - q*vec2( clamp( w.x/q.x, 0.0, 1.0 ), 1.0 );\n    float k = sign( q.y );\n    float d = min(dot( a, a ),dot(b, b));\n    float s = max( k*(w.x*q.y-w.y*q.x),k*(w.y-q.y)  );\n\treturn sqrt(d)*sign(s);\n}\n\nfloat sdCappedCone( in vec3 p, in float h, in float r1, in float r2 )\n{\n    vec2 q = vec2( length(p.xz), p.y );\n    \n    vec2 k1 = vec2(r2,h);\n    vec2 k2 = vec2(r2-r1,2.0*h);\n    vec2 ca = vec2(q.x-min(q.x,(q.y < 0.0)?r1:r2), abs(q.y)-h);\n    vec2 cb = q - k1 + k2*clamp( dot(k1-q,k2)/dot2(k2), 0.0, 1.0 );\n    float s = (cb.x < 0.0 && ca.y < 0.0) ? -1.0 : 1.0;\n    return s*sqrt( min(dot2(ca),dot2(cb)) );\n}\n\nfloat sdCappedCone(vec3 p, vec3 a, vec3 b, float ra, float rb)\n{\n    float rba  = rb-ra;\n    float baba = dot(b-a,b-a);\n    float papa = dot(p-a,p-a);\n    float paba = dot(p-a,b-a)/baba;\n\n    float x = sqrt( papa - paba*paba*baba );\n\n    float cax = max(0.0,x-((paba<0.5)?ra:rb));\n    float cay = abs(paba-0.5)-0.5;\n\n    float k = rba*rba + baba;\n    float f = clamp( (rba*(x-ra)+paba*baba)/k, 0.0, 1.0 );\n\n    float cbx = x-ra - f*rba;\n    float cby = paba - f;\n    \n    float s = (cbx < 0.0 && cay < 0.0) ? -1.0 : 1.0;\n    \n    return s*sqrt( min(cax*cax + cay*cay*baba,\n                       cbx*cbx + cby*cby*baba) );\n}\n\n// c is the sin/cos of the desired cone angle\nfloat sdSolidAngle(vec3 pos, vec2 c, float ra)\n{\n    vec2 p = vec2( length(pos.xz), pos.y );\n    float l = length(p) - ra;\n\tfloat m = length(p - c*clamp(dot(p,c),0.0,ra) );\n    return max(l,m*sign(c.y*p.x-c.x*p.y));\n}\n\nfloat sdOctahedron(vec3 p, float s)\n{\n    p = abs(p);\n    float m = p.x + p.y + p.z - s;\n\n    // exact distance\n    #if 0\n    vec3 o = min(3.0*p - m, 0.0);\n    o = max(6.0*p - m*2.0 - o*3.0 + (o.x+o.y+o.z), 0.0);\n    return length(p - s*o/(o.x+o.y+o.z));\n    #endif\n    \n    // exact distance\n    #if 1\n \tvec3 q;\n         if( 3.0*p.x < m ) q = p.xyz;\n    else if( 3.0*p.y < m ) q = p.yzx;\n    else if( 3.0*p.z < m ) q = p.zxy;\n    else return m*0.57735027;\n    float k = clamp(0.5*(q.z-q.y+s),0.0,s); \n    return length(vec3(q.x,q.y-s+k,q.z-k)); \n    #endif\n    \n    // bound, not exact\n    #if 0\n\treturn m*0.57735027;\n    #endif\n}\n\nfloat sdPyramid( in vec3 p, in float h )\n{\n    float m2 = h*h + 0.25;\n    \n    // symmetry\n    p.xz = abs(p.xz);\n    p.xz = (p.z>p.x) ? p.zx : p.xz;\n    p.xz -= 0.5;\n\t\n    // project into face plane (2D)\n    vec3 q = vec3( p.z, h*p.y - 0.5*p.x, h*p.x + 0.5*p.y);\n   \n    float s = max(-q.x,0.0);\n    float t = clamp( (q.y-0.5*p.z)/(m2+0.25), 0.0, 1.0 );\n    \n    float a = m2*(q.x+s)*(q.x+s) + q.y*q.y;\n\tfloat b = m2*(q.x+0.5*t)*(q.x+0.5*t) + (q.y-m2*t)*(q.y-m2*t);\n    \n    float d2 = min(q.y,-q.x*m2-q.y*0.5) > 0.0 ? 0.0 : min(a,b);\n    \n    // recover 3D and scale, and add sign\n    return sqrt( (d2+q.z*q.z)/m2 ) * sign(max(q.z,-p.y));;\n}\n\n// la,lb=semi axis, h=height, ra=corner\nfloat sdRhombus(vec3 p, float la, float lb, float h, float ra)\n{\n    p = abs(p);\n    vec2 b = vec2(la,lb);\n    float f = clamp( (ndot(b,b-2.0*p.xz))/dot(b,b), -1.0, 1.0 );\n\tvec2 q = vec2(length(p.xz-0.5*b*vec2(1.0-f,1.0+f))*sign(p.x*b.y+p.z*b.x-b.x*b.y)-ra, p.y-h);\n    return min(max(q.x,q.y),0.0) + length(max(q,0.0));\n}\n\n//------------------------------------------------------------------\n\nvec2 opU( vec2 d1, vec2 d2 )\n{\n\treturn (d1.x<d2.x) ? d1 : d2;\n}\n\n//------------------------------------------------------------------\n\n#define ZERO (min(iFrame,0))\n\n//------------------------------------------------------------------\nfloat differenceSDF(float distA, float distB) {\n    return max(distA, -distB);\n}\nvec2 sdGyroid(vec3 p, float scale, float thickness, float bias) {\n\tp *= scale;\n    return vec2(abs(dot(sin(p), cos(p.zxy))-bias)/scale-thickness,15.);\n}\nmat2 Rot(float a) {\n    float s=sin(a), c=cos(a);\n    return mat2(c, -s, s, c);\n}\n// http://iquilezles.org/www/articles/smin/smin.htm\nvec2 smin( vec2 a, vec2 b, float k )\n{\n    float h = clamp( 0.5+0.5*(b.x-a.x)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\n// http://iquilezles.org/www/articles/smin/smin.htm\nfloat smax( float a, float b, float k )\n{\n    float h = max(k-abs(a-b),0.0);\n    return max(a, b) + h*h*0.25/k;\n}\nvec2 cactus (vec3 pos){\n    //add cactus\n    vec2 uv4 = vec2(atan(pos.x,pos.z)/(3.14159*1.),pos.y/1.);\n    float disp4 = texture(iChannel1,uv4).r;\n    vec2 cactus = sdCapsule(pos, vec3(10,0,0), vec3(10,1,0), .2 );\n    vec2 thorn = sdCapsule(pos, vec3(10,0,0), vec3(10,1,0), .14 );\n    thorn.x-=disp4*.1;\n    thorn.y = 17.;\n    cactus = opU(cactus,thorn);\n    \n    vec3 nP = pos;\n    nP.y += (sin(nP.x*4.) * .1 * smoothstep(1.1,1.2,nP.x));\n    vec2 cactusR = sdCapsule(nP, vec3(10,.5,0), vec3(10.5,.5,0), .13 );\n    vec2 thornR = sdCapsule(nP, vec3(10,.5,0), vec3(10.5,.5,0), .08 );\n    \n    thornR.x-=disp4*.1;\n    thornR.y = 17.;\n    cactusR = opU(cactusR,thornR);\n    cactus.x = smin(cactusR,cactus, .1).x;\n    return cactus;\n}\nvec2 map( in vec3 pos )\n{\n    vec2 res = vec2( 1e10, 0.0 );\n    \n    //get rock displacement\n    vec2 uv = vec2(pos.z*.4, pos.y*.4);\n    float disp = texture(iChannel0,uv).r;\n    \n    vec2 uv2 = vec2(pos.x*.1, pos.z*.1);\n    float disp2 = texture(iChannel0,uv2).r;\n    \n    vec2 uv3 = vec2(pos.x*.3, pos.z*.3);\n    float disp3 = texture(iChannel1,uv3).r;\n    \n    \n    \n    \n    //add floor to scene\n    vec2 floorP = vec2(pos.y,20.);\n    //apply rocky displacement to floor\n    floorP.x-=disp2*.1;\n    res = opU(floorP,res);\n    \n    //wall\n    vec2 wall= sdBox( pos-vec3(0,1,0), vec3(.5,1,10) );\n    wall.x-=disp*.3;\n    //cut hole in wall for door\n    vec2 wallMask = sdCapsule(pos, vec3(0,-.5,0), vec3(0,.7,0), 1. );\n    wall.x = differenceSDF(wall.x, wallMask.x);\n    res = opU(wall,res);\n     \n    //path\n    vec3 nP = pos;\n    nP.z += sin(nP.x *.4);\n    vec2 path = sdBox( nP-vec3(0,0,-.1), vec3(10.,.1,1.3) );\n    path.x-=disp2*.2;\n    path.y = 26.;\n    res = opU(path,res);\n    \n    //gate\n    vec2 bars = sdCylinder(pos, vec3(.5,0,0), vec3(.5,2,0), .01);\n    bars =abs(opU(bars,sdCylinder(pos, vec3(.5,0,-.1), vec3(.5,2,-.1), .01)));\n    bars =abs(opU(bars,sdCylinder(pos, vec3(.5,0,-.2), vec3(.5,2,-.2), .01)));\n    bars =abs(opU(bars,sdCylinder(pos, vec3(.5,0,-.3), vec3(.5,2,-.3), .01)));\n    bars =abs(opU(bars,sdCylinder(pos, vec3(.5,0,-.4), vec3(.5,2,-.4), .01)));\n    bars =abs(opU(bars,sdCylinder(pos, vec3(.5,0,-.5), vec3(.5,2,-.5), .01)));\n    bars =abs(opU(bars,sdCylinder(pos, vec3(.5,0,-.6), vec3(.5,2,-.6), .01)));\n    bars =abs(opU(bars,sdCylinder(pos, vec3(.5,0,-.7), vec3(.5,2,-.7), .01)));\n    bars =abs(opU(bars,sdCylinder(pos, vec3(.5,0,-.8), vec3(.5,2,-.8), .01)));\n    \n    bars =abs(opU(bars,sdCylinder(pos, vec3(.5,0,.1), vec3(.5,2,.1), .01)));\n    bars =abs(opU(bars,sdCylinder(pos, vec3(.5,0,.2), vec3(.5,2,.2), .01)));\n    bars =abs(opU(bars,sdCylinder(pos, vec3(.5,0,.3), vec3(.5,2,.3), .01)));\n    bars =abs(opU(bars,sdCylinder(pos, vec3(.5,0,.4), vec3(.5,2,.4), .01)));\n    bars =abs(opU(bars,sdCylinder(pos, vec3(.5,0,.5), vec3(.5,2,.5), .01)));\n    bars =abs(opU(bars,sdCylinder(pos, vec3(.5,0,.6), vec3(.5,2,.6), .01)));\n    bars =abs(opU(bars,sdCylinder(pos, vec3(.5,0,.7), vec3(.5,2,.7), .01)));\n    bars =abs(opU(bars,sdCylinder(pos, vec3(.5,0,.8), vec3(.5,2,.8), .01)));\n    \n    res = opU(bars,res);\n    \n    //plants\n   /* vec3 pPos = pos-vec3(1.3,0,1.3);\n    pPos.xz *= Rot(iTime);\n    pPos.xz -= sin(pPos.y*4.+.4)*.4+.4;\n    \n    vec2 bush = sdCylinder( pPos, vec2(.01-.01*pPos.y,.3) );\n    bush.y = 90.;\n    res = opU(bush,res);*/\n    \n    vec2 grass = vec2(pos.y,90.);\n    grass.x-=disp3*.1;\n    res = opU(grass,res);\n    \n    //flag\n     //add flag\n    vec3 flagP = pos - vec3(1.,0,1);\n    vec2 pole = sdCylinder(flagP, vec2(.01,1.4) );\n    res = opU(pole,res);\n    //add cloth\n    flagP.x += (sin(flagP.z + iTime*5.)*.1) * smoothstep(.1,1.1,flagP.z);\n    vec2 cloth = sdBox( flagP-vec3(0,1.1,0.5), vec3(.01,.3,.5) );\n    cloth.y = 91.;\n    //cloth.x -=disp3*.03;\n    res = opU(cloth,res);\n    \n    //second flag\n    flagP.xz *= Rot(3.145);\n    flagP = flagP - vec3(0,0,3);\n    pole = sdCylinder(flagP, vec2(.01,1.4) );\n    res = opU(pole,res);\n    //add cloth\n    flagP.x += (sin(flagP.z + iTime*5.)*.1) * smoothstep(.1,1.1,flagP.z);\n    cloth = sdBox( flagP-vec3(0,1.1,0.5), vec3(.01,.3,.5) );\n    cloth.y = 91.;\n    res = opU(cloth,res);\n    \n    //guardian\n    vec2 guard = sdSphere( pos-vec3(2,1,0), 0.2);\n    guard = smin(guard,sdSphere( pos-vec3(2,.6,0), 0.3),.3);\n    vec2 guardMask = sdCapsule(pos, vec3(2.1,1.1,.05), vec3(2.1,1.1,-.1), .2 );\n    guard = max(-guardMask, guard);\n    \n    //add arms\n    //shoulder\n    vec2 arms = sdSphere( pos-vec3(2.18,1.,0.25 + sin(iTime)*.01), 0.13);\n    guard = smin(guard,arms,.1);\n    guard.y = 100.;\n    //arm\n    vec2 arm = sdCapsule(nP, vec3(2.18,1,1.), vec3(2.2,.8+ sin(iTime)*.01,1.2), .08 );\n    \n    \n    vec2 hand = sdSphere( pos-vec3(2.5,.8+ sin(iTime)*.01,0.4),.04);\n    arm = smin(arm,hand,.4);\n    arm.y = 26.;\n    res = opU(arm,res);\n    \n    //left\n    //shoulder\n    vec2 armsL = sdSphere( pos-vec3(2.18,1.+ sin(iTime)*.01,-0.25), 0.13);\n    guard = smin(guard,armsL,.1);\n    guard.y = 100.;\n    //arm\n    vec2 armL = sdCapsule(nP, vec3(2.18,1,.48), vec3(2.2,.8+ sin(iTime)*.01,.38), .08 );\n    vec2 handL = sdSphere( pos-vec3(2.5,.8+ sin(iTime)*.01,-0.4+cos(iTime)*.07),.04);\n    armL = smin(armL,handL,.4);\n    armL.y = 26.;\n    res = opU(armL,res);\n    //spear\n    vec2 spear = sdCylinder(pos-vec3(2.5,.8+ sin(iTime)*.01,-0.4+cos(iTime)*.07), vec2(.01,.5) );\n    vec3 bladeP = pos;\n    bladeP.x -= sin(bladeP.y*4.-.2);\n    vec2 blade = sdBox( bladeP-vec3(3.5,1.3+ sin(iTime)*.01,-0.4+cos(iTime)*.07), vec3(.1,.1,.014*(1./(pos.y*4.))) );\n    res = opU(spear,res);\n    blade.y = 26.;\n     res = opU(blade,res);\n    //head\n    vec3 headPos = pos;\n    headPos.y -= sin(iTime)*.05+.05;\n    vec2 head = sdSphere( headPos-vec3(2.13,1.13,0), 0.2);\n    head = smin(guard,head,.04);\n    head.y = 100.;\n    res = opU(head,res);\n    \n    //helmet\n    vec2 helmet = sdSphere( headPos-vec3(2.13,1.13,0), 0.22);\n    head = sdSphere( headPos-vec3(2.13,1.13,0), 0.15);\n    helmet.x = max(helmet.x,-head.x);\n    vec2 helmetM = sdBox( headPos-vec3(02.2,0.85,0), vec3(.3,.2,.3) );\n    \n    helmet.x = max(helmet.x,-helmetM.x);\n   \n    vec2 helmetM2 = sdBox( headPos-vec3(02.2,0.85,0), vec3(.4,.4,.01 *headPos.y*2.) );\n    helmet.x = max(helmet.x,-helmetM2.x);\n    \n    vec2 helmetM3 = sdBox( headPos-vec3(02.17,1.2,0), vec3(.2,.01 * abs(headPos.z)*40.+.01,.1));\n    helmet.x = max(helmet.x,-helmetM3.x);\n    helmet.y = 26.;\n    res = opU(helmet,res);\n    return res;\n}\n\n// http://iquilezles.org/www/articles/boxfunctions/boxfunctions.htm\nvec2 iBox( in vec3 ro, in vec3 rd, in vec3 rad ) \n{\n    vec3 m = 1.0/rd;\n    vec3 n = m*ro;\n    vec3 k = abs(m)*rad;\n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n\treturn vec2( max( max( t1.x, t1.y ), t1.z ),\n\t             min( min( t2.x, t2.y ), t2.z ) );\n}\n\nvec2 raycast( in vec3 ro, in vec3 rd )\n{\n    \n    // raymarch primitives   \n    // distance from origin\n    float dO=0.;\n    float ID = -1.;\n    // march until max steps is achieved or object hit\n    for(int i=0; i <MAX_STEPS; i++){\n        // current point being evaluated\n        vec3 p = ro + dO*rd;\n        \n        // get distance to seam\n        vec2 getObj = map(p);\n        ID = getObj.y;\n        float ds = getObj.x;\n        //move origin to new point\n        if(ID == 15.){\n            dO+=ds*.8;\n        }\n        else if(ID == 17.){\n            dO+=ds*.8;\n        }\n        else if(ID == 1.){\n            dO+=ds*.8;\n        }\n        else if(ID == 90.){\n            dO+=ds*.8;\n        }else{\n            dO+=ds;\n        }\n        if(ds < SURFACE_DIST || dO > MAX_DIST){\n            break;\n        }\n    }\n    return vec2(min(dO, MAX_DIST),ID);\n}\n\n// http://iquilezles.org/www/articles/rmshadows/rmshadows.htm\nfloat calcSoftshadow( in vec3 ro, in vec3 rd, in float mint, in float tmax )\n{\n    // bounding volume\n    float tp = (0.8-ro.y)/rd.y; if( tp>0.0 ) tmax = min( tmax, tp );\n\n    float res = 1.0;\n    float t = mint;\n    for( int i=ZERO; i<24; i++ )\n    {\n\t\tfloat h = map( ro + rd*t ).x;\n        float s = clamp(8.0*h/t,0.0,1.0);\n        res = min( res, s*s*(3.0-2.0*s) );\n        t += clamp( h, 0.02, 0.2 );\n        if( res<0.004 || t>tmax ) break;\n    }\n    return clamp( res, 0.0, 1.0 );\n}\n\n// http://iquilezles.org/www/articles/normalsSDF/normalsSDF.htm\nvec3 calcNormal( in vec3 pos )\n{\n\n#if 0\n    vec2 e = vec2(1.0,-1.0)*0.5773*0.0005;\n    return normalize( e.xyy*map( pos + e.xyy ).x + \n\t\t\t\t\t  e.yyx*map( pos + e.yyx ).x + \n\t\t\t\t\t  e.yxy*map( pos + e.yxy ).x + \n\t\t\t\t\t  e.xxx*map( pos + e.xxx ).x );\n#else\n    // inspired by tdhooper and klems - a way to prevent the compiler from inlining map() 4 times\n    vec3 n = vec3(0.0);\n    for( int i=ZERO; i<4; i++ )\n    {\n        vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);\n        n += e*map(pos+0.0005*e).x;\n      //if( n.x+n.y+n.z>100.0 ) break;\n    }\n    return normalize(n);\n#endif    \n}\n\nfloat calcAO( in vec3 pos, in vec3 nor )\n{\n\tfloat occ = 0.0;\n    float sca = 1.0;\n    for( int i=ZERO; i<5; i++ )\n    {\n        float h = 0.01 + 0.12*float(i)/4.0;\n        float d = map( pos + h*nor ).x;\n        occ += (h-d)*sca;\n        sca *= 0.95;\n        if( occ>0.35 ) break;\n    }\n    return clamp( 1.0 - 3.0*occ, 0.0, 1.0 ) * (0.5+0.5*nor.y);\n}\n\n// http://iquilezles.org/www/articles/checkerfiltering/checkerfiltering.htm\nfloat checkersGradBox( in vec2 p, in vec2 dpdx, in vec2 dpdy )\n{\n    // filter kernel\n    vec2 w = abs(dpdx)+abs(dpdy) + 0.001;\n    // analytical integral (box filter)\n    vec2 i = 2.0*(abs(fract((p-0.5*w)*0.5)-0.5)-abs(fract((p+0.5*w)*0.5)-0.5))/w;\n    // xor pattern\n    return 0.5 - 0.5*i.x*i.y;                  \n}\n\nvec3 render( in vec3 ro, in vec3 rd, in vec3 rdx, in vec3 rdy )\n{ \n    // background\n    vec3 col = vec3(0.7, 0.7, 0.9) - max(rd.y,0.0)*0.3;\n    \n    // raycast scene\n    vec2 res = raycast(ro,rd);\n    float t = res.x;\n\tfloat m = res.y;\n    if( m>-0.5 )\n    {\n        vec3 pos = ro + t*rd;\n        vec3 nor = calcNormal( pos );\n        vec3 ref = reflect( rd, nor );\n        float ks = .3;\n        \n        vec3 colXZ = texture(iChannel2, pos.xz*.5+.5).rgb;\n        vec3 colXY = texture(iChannel2, pos.xy*.5+.5).rgb;\n        vec3 colYZ = texture(iChannel2, pos.yz*.5+.5).rgb;\n        \n        vec3 colXZ2 = texture(iChannel3, pos.xz*.5+.5).rgb;\n        vec3 colXY2 = texture(iChannel3, pos.xy*.5+.5).rgb;\n        vec3 colYZ2 = texture(iChannel3, pos.yz*.5+.5).rgb;\n        \n        vec3 colXZ3 = texture(iChannel1, pos.xz*.5+.5).rgb;\n        vec3 colXY3 = texture(iChannel1, pos.xy*.5+.5).rgb;\n        vec3 colYZ3 = texture(iChannel1, pos.yz*.5+.5).rgb;\n        // material        \n        if(m == 1.){\n            nor = abs(nor);\n            col = (colXZ2*nor.y + colXY2*nor.z + colYZ2*nor.x) * .5;\n            //col = nor;\n            ks = .01;\n        }\n        else if( m==20.)\n        {\n            // project pixel footprint into the plane\n            /*vec3 dpdx = ro.y*(rd/rd.y-rdx/rdx.y);\n            vec3 dpdy = ro.y*(rd/rd.y-rdy/rdy.y);\n\n            float f = checkersGradBox( 3.0*pos.xz, 3.0*dpdx.xz, 3.0*dpdy.xz );\n            col = 0.15 + f*vec3(0.05);*/\n            col = colXZ*nor.y + colXY*nor.z + colYZ*nor.x;\n            ks = .01;\n        }\n        else if( m==15.){\n            col = vec3(0.4,.1,0);\n            ks = .1; \n        }\n         else if( m==16.){\n            col = vec3(0,.1,0);\n            ks = .1; \n        }\n        else if( m==21.){\n            col = vec3(.1);\n            ks = 5.; \n        }\n        else if( m==26.){\n            col = vec3(.5) * .01;\n            ks = .1; \n        }\n        else if( m==90.){\n            col = vec3(0,1,0) * .1;\n            ks = .1; \n        }\n        else if( m==91.){\n            col = vec3(1,0,0) * .1;\n            ks = .1; \n        }\n        else if( m==100.){\n            col = vec3(1,pos.y,pos.y) * .1;\n            ks = .1; \n        }\n        // lighting\n        float occ = calcAO( pos, nor );\n        \n\t\tvec3 lin = vec3(0.0);\n\n        // sun\n        {\n            vec3  lig = normalize( vec3(0.6, 0.7, -0.9) );\n            vec3  hal = normalize( lig-rd );\n            float dif = clamp( dot( nor, lig ), 1.0, 1.0 );\n          //if( dif>0.0001 )\n        \t      dif *= calcSoftshadow( pos, lig, 0.02, 2.5 );\n\t\t\tfloat spe = pow( clamp( dot( nor, hal ), 0.0, 1.0 ),16.0);\n                  spe *= dif;\n                  spe *= 0.04+0.96*pow(clamp(1.0-dot(hal,lig),0.0,1.0),5.0);\n            lin += col*2.20*dif*vec3(1.30,1.00,0.70);\n            lin +=     5.00*spe*vec3(1.30,1.00,0.70)*ks;\n        }\n        // sky\n        {\n            float dif = sqrt(clamp( 0.5+0.5*nor.y, 0.0, 1.0 ));\n                  dif *= occ;\n            float spe = smoothstep( -0.2, 0.2, ref.y );\n                  spe *= dif;\n                  spe *= 0.04+0.96*pow(clamp(1.0+dot(nor,rd),0.0,1.0), 5.0 );\n          //if( spe>0.001 )\n                  spe *= calcSoftshadow( pos, ref, 0.02, 2.5 );\n            lin += col*0.60*dif*vec3(0.40,0.60,1.15);\n            lin +=     2.00*spe*vec3(0.40,0.60,1.30)*ks;\n        }\n        // back\n        {\n        \tfloat dif = clamp( dot( nor, normalize(vec3(0.5,0.0,0.6))), 0.0, 1.0 )*clamp( 1.0-pos.y,0.0,1.0);\n                  dif *= occ;\n        \tlin += col*0.55*dif*vec3(0.25,0.25,0.25);\n        }\n        // sss\n        {\n            float dif = pow(clamp(1.0+dot(nor,rd),0.0,1.0),2.0);\n                  dif *= occ;\n        \tlin += col*0.25*dif*vec3(1.00,1.00,1.00);\n        }\n        \n\t\tcol = lin;\n\n        col = mix( col, vec3(0.7,0.7,0.9), 1.0-exp( -0.0001*t*t*t ) );\n    }\n\n\treturn vec3( clamp(col,0.0,1.0) );\n}\n\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr )\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv =          ( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 mo = iMouse.xy/iResolution.xy;\n\tfloat time = 32.0 + iTime*1.5;\n\n    // camera\t\n    vec3 ta = vec3( 0, 0, 0 );\n    vec3 ro = ta + vec3( 4.5, 1.3 + 2.0*mo.y, 4.5*sin(0.1 + 7.0*mo.x) );\n    // camera-to-world transformation\n    mat3 ca = setCamera( ro, ta, 0.0 );\n\n    vec3 tot = vec3(0.0);\n#if AA>1\n    for( int m=ZERO; m<AA; m++ )\n    for( int n=ZERO; n<AA; n++ )\n    {\n        // pixel coordinates\n        vec2 o = vec2(float(m),float(n)) / float(AA) - 0.5;\n        vec2 p = (2.0*(fragCoord+o)-iResolution.xy)/iResolution.y;\n#else    \n        vec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n#endif\n\n        // ray direction\n        vec3 rd = ca * normalize( vec3(p,2.5) );\n\n         // ray differentials\n        vec2 px = (2.0*(fragCoord+vec2(1.0,0.0))-iResolution.xy)/iResolution.y;\n        vec2 py = (2.0*(fragCoord+vec2(0.0,1.0))-iResolution.xy)/iResolution.y;\n        vec3 rdx = ca * normalize( vec3(px,2.5) );\n        vec3 rdy = ca * normalize( vec3(py,2.5) );\n        \n        // render\t\n        vec3 col = render( ro, rd, rdx, rdy );\n\n        // gain\n        // col = col*3.0/(2.5+col);\n        \n\t\t// gamma\n        col = pow( col, vec3(0.4545) );\n\n        tot += col;\n#if AA>1\n    }\n    tot /= float(AA*AA);\n#endif\n    \n    fragColor = vec4( tot, 1.0 );\n}", "image_inputs": [{"id": "XdfGRn", "previewfilepath": "/media/ap/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg", "ctype": "texture"}, {"id": "4sfGRn", "previewfilepath": "/media/ap/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg", "channel": 3, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg", "ctype": "texture"}, {"id": "4dXGzn", "previewfilepath": "/media/ap/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "ctype": "texture"}, {"id": "4sf3Rr", "previewfilepath": "/media/ap/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtGcD3.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[170, 239, 264, 264, 283], [284, 284, 309, 309, 328], [329, 329, 365, 365, 393], [395, 395, 420, 420, 435], [437, 437, 471, 471, 505], [507, 507, 537, 537, 637], [639, 639, 686, 686, 983], [984, 984, 1042, 1042, 1140], [1142, 1142, 1175, 1175, 1230], [1232, 1232, 1302, 1302, 1442], [1444, 1444, 1480, 1480, 1791], [1793, 1793, 1849, 1849, 2351], [2353, 2353, 2404, 2404, 2528], [2530, 2530, 2594, 2594, 2872], [2874, 2874, 2937, 3001, 3588], [3590, 3590, 3626, 3626, 3976], [3978, 3990, 4025, 4025, 4138], [4140, 4165, 4215, 4215, 4580], [4582, 4594, 4641, 4641, 4986], [4988, 4988, 5059, 5059, 5397], [5399, 5399, 5463, 5463, 6023], [6025, 6071, 6119, 6119, 6288], [6290, 6290, 6327, 6327, 6921], [6923, 6923, 6965, 6965, 7565], [7567, 7607, 7671, 7671, 7929], [7931, 8001, 8031, 8031, 8064], [8166, 8235, 8282, 8282, 8315], [8316, 8316, 8381, 8381, 8468], [8469, 8469, 8488, 8488, 8550], [8551, 8603, 8641, 8641, 8738], [8740, 8792, 8833, 8833, 8905], [8906, 8906, 8929, 8946, 9635], [9636, 9636, 9661, 9661, 15305], [15307, 15375, 15426, 15426, 15631], [15633, 15633, 15673, 15736, 16490], [16492, 16554, 16632, 16655, 17042], [17044, 17108, 17140, 17140, 17711], [17713, 17713, 17755, 17755, 18064], [18066, 18142, 18206, 18227, 18460], [18462, 18462, 18527, 18546, 22376], [22378, 22378, 22430, 22430, 22607], [22609, 22609, 22666, 22666, 23945]]}
{"id": "wtGcDc", "name": "A new way to plot Mandelbrot Set", "author": "rsiqueira", "description": "A new way to plot Mandelbrot Set fractal", "tags": ["fractal", "mandelbrot", "animation"], "likes": 5, "viewed": 72, "published": "Public", "date": "1611867036", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec3 hsl2rgb( in vec3 c ) {\n  vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n  return c.z + c.y * (rgb-0.5)*(1.0-abs(2.0*c.z-1.0));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n   vec2 uv = fragCoord/iResolution.xy;\n\n\tuv.x = uv.x/122.;\n\tuv.y = uv.y/32. - 0.015;\n\n    float pixel_y = uv.y * 100.;\n    float pixel_x = uv.x * 550. - 3.;\n\n    float X = pixel_x;\n    float Y = pixel_y;\n    float n = 120.;\n\n\tfor (float k=17.;k>0.;k-=1.) {\n\n\t\tfloat X_new = X*X - Y*Y + pixel_x;\n\t\tfloat Y_new = 2.*X*Y    + pixel_y;\n        X = X_new;\n        Y = Y_new;\n\n        n=n-1.;\n\n\t\tif (tan(sin(X_new+iTime)+sin(Y_new))<-4.) {\n          fragColor = vec4(hsl2rgb( \n                              vec3(.2+k/20. -iTime*0.1, 0.8, 0.6+ sin(n/5.)*cos(n/15.+iTime/2.)*n/280.)\n                      ),1.0);\n        }\n\t}\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtGcDc.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 27, 27, 165], [167, 167, 224, 224, 844]]}
{"id": "WtGcDd", "name": "[TWITCH] Plaisir Coupable", "author": "Flopine", "description": "Inspired by the art of Mirai Mizue and this post: https://twitter.com/MIRAI_MIZUE/status/1354248578063953920?s=20\nMade during a Twitch stream, you can watch VODs here: https://www.twitch.tv/flopine", "tags": ["raymarching", "animation", "isometric", "geometric"], "likes": 33, "viewed": 280, "published": "Public", "date": "1611943921", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Code by Flopine\n\n// Thanks to wsmind, leon, XT95, lsdlive, lamogui, \n// Coyhot, Alkama,YX, NuSan, slerpy and wwrighter for teaching me\n\n// Thanks LJ for giving me the spark :3\n\n// Thanks to the Cookie Collective, which build a cozy and safe environment for me \n// and other to sprout :)  https://twitter.com/CookieDemoparty\n\n// Heavily inspired by this tweet:\n// https://twitter.com/MIRAI_MIZUE/status/1354248578063953920?s=20\n\n\n#define dt(speed,off) fract((iTime+off)*speed)\n#define IOExpoLoop(speed,off) easeInOutExpo(abs(-1.+2.*dt(speed,off)))\n#define IOExpo(speed,off) easeInOutExpo(dt(speed,off))\n#define bounce(speed, off) abs(sqrt(sin(dt(speed,off)*PI)))\n\n#define PI acos(-1.)\n#define TAU 6.283185\n#define ITER 64.\n\n#define rot(a) mat2(cos(a),sin(a),-sin(a),cos(a))\n#define crep(p,c,l) p=p-c*clamp(round(p/c),-l,l)\n\nstruct obj\n{\n  float d;\n  vec3 c_shadow;\n  vec3 c_light;\n};\n\nobj minobj (obj a, obj b)\n{\n  if (a.d<b.d) return a;\n  else return b;\n}\n\n\nfloat easeInOutExpo (float x)\n{\nreturn x == 0.\n  ? 0.\n  : x == 1.\n  ? 1.\n  : x < 0.5 ? exp2(20. * x - 10.) / 2.\n  : (2. - exp2(-20. * x + 10.)) / 2.;\n}\n\nfloat box (vec3 p, vec3 c)\n{\n  vec3 q = abs(p)-c;\n  return min(0.,max(q.x,max(q.y,q.z)))+length(max(q,0.));\n}\n\nfloat sc (vec3 p, float d)\n{\n  p = abs(p);\n  p = max(p,p.yzx);\n  return min(p.x,min(p.y,p.z))-d;\n}\n\nobj prim1 (vec3 p)\n{ \n  float per = mix(0.,1.5,IOExpoLoop(0.5,0.));\n  crep(p.xz,per,1.);\n  float dscene = max(sc(p,0.2),box(p,vec3(0.5)));\n\n  return obj(dscene,vec3(0.15,0.,0.2),vec3(.3,0.8,0.95));\n}\n\nfloat cases (vec3 p, float offset, float size)\n{\n  p.y -= bounce(1.5,offset)*1.5;\n  float d = max(-box(p-vec3(0.,size*0.25,0.),vec3(size*0.85)),box(p,vec3(size)));\n  return d;\n}\n\nobj prim2 (vec3 p)\n{\n  float off=0.,s=0.9,d=1e10;\n  for (int i=0; i<3; i++)\n  {\n    d = min(d,cases(p,off,s));\n    off -= 0.1; s -= 0.3;\n  }\n\n  return obj(d,vec3(0.3,0.02,0.01),vec3(0.95,0.8,0.4)); \n}\n\nobj prim3 (vec3 p)\n{\n  float size = 1., d=1e10;\n  for (int i=0;i<3;i++)\n  {\n    p.xz *= rot(IOExpo(0.5,0.)*PI);\n    p.xy *= rot(IOExpo(0.5,0.)*PI);\n    d = min(d,max(-sc(p,size*0.8),box(p,vec3(size))));\n    size -= 0.3;\n  }\n\n  return obj(d,vec3(0.0,0.2,0.05),vec3(.9,.8,0.1));\n}\n\nobj prim4 (vec3 p)\n{\n  float size = 0.2;\n  float per = (size*4.);\n  vec2 id = round(p.xz/per)-.5;\n  crep(p.xz,per,2.);\n\n  float sy = sin(length(id*0.7)-dt(0.5,0.)*TAU)*0.3+0.3;\n\n  float d = box(p,vec3(size,sy,size));\n\n  return obj(d,vec3(0.5,0.,0.6),vec3(0.95,0.85,0.2));\n}\n\nobj SDF (vec3 p)\n{  \n  p.x -= 0.5;\n  p.yz *= rot(-atan(1./sqrt(2.)));\n  p.xz *= rot(TAU/8.);\n  vec3 pp = p;\n\n  obj scene = prim1(p+vec3(-2.,0.,2.));\n  scene = minobj(scene,prim4(p+vec3(3.,0.,-3.)));\n  scene = minobj(scene, prim3(p+vec3(3.,0.,2.)));\n  scene = minobj(scene,prim2(p+vec3(-2.,0.,-3.)));\n\n  return scene;\n}\n\nvec3 getnorm (vec3 p)\n{\n  vec2 eps = vec2(0.001,0.);\n  return normalize(SDF(p).d-vec3(SDF(p-eps.xyy).d,SDF(p-eps.yxy).d,SDF(p-eps.yyx).d));\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  vec2 uu = fragCoord.xy/iResolution.xy;\n  vec2 uv = (2.*fragCoord.xy - iResolution.xy)/iResolution.y;\n\n  vec3 ro = vec3(uv*5.,-10.), rd=vec3(0.,0.,1.), p=ro, col=vec3(0.,0.,0.02), l=normalize(vec3(1.,2.,-2.));\n\n  bool hit = false; obj O;\n\n  for (float i=0.; i<ITER; i++)\n  {\n    O = SDF(p);\n    if (O.d < 0.01)\n    {\n      hit=true; break;\n    }\n    p += O.d*rd;\n  }\n\n  if (hit)\n  {\n    vec3 n = getnorm(p);\n    float lighting = max(dot(n,l),0.);\n    col = mix(O.c_shadow, O.c_light, lighting);\n  }\n\n  fragColor = vec4(sqrt(col),1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WtGcDd.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[328, 887, 914, 914, 958], [961, 961, 992, 992, 1112], [1114, 1114, 1142, 1142, 1223], [1225, 1225, 1253, 1253, 1323], [1325, 1325, 1345, 1345, 1524], [1526, 1526, 1574, 1574, 1703], [1705, 1705, 1725, 1725, 1905], [1907, 1907, 1927, 1927, 2185], [2187, 2187, 2207, 2207, 2460], [2462, 2462, 2480, 2480, 2780], [2782, 2782, 2805, 2805, 2923], [2925, 2925, 2981, 2981, 3518]]}
{"id": "wtGcDz", "name": "Basket Ball", "author": "regis", "description": "ball ", "tags": ["3d", "raymarch"], "likes": 3, "viewed": 66, "published": "Public", "date": "1610919524", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec4 tpos = vec4(0.0, 0.0, 0.0, 0.0);\nfloat angle_tpos;\nbool done = false;\nfloat dist = 0.0;\nvec4 sphball;\n\nmat2 Rot(float a){\n    float s = sin(a);\n    float c = cos(a);\n    return mat2(c, -s, s, c);\n}\n\nmat3 RotX(float a){\n    float s = sin(a);\n    float c = cos(a);\n    \n    return mat3(1., .0, .0, .0, c, -s, .0, s, c);\n\n}\n\nmat3 RotY(float a){\n    float s = sin(a);\n    float c = cos(a);\n    \n    return mat3(c, .0, s, .0, 1., .0, -s, .0, c);\n\n}\n\nmat3 RotZ(float a){\n    float s = sin(a);\n    float c = cos(a);\n    \n    return mat3(c, -s, .0, s, c, .0, .0, .0, 1.);\n\n}\n\n\nfloat opExtrusion(in vec3 p, in float d, in float h) {\n    // d is the distance to the 2D shape using the x and y components of p\n    vec2 w = vec2(d, abs(p.z) - h);\n    return min(max(w.x, w.y), 0.0) + length(max(w, 0.0));\n}\n\n\nvec4 opElongate( in vec3 p, in vec3 h )\n{\n    //return vec4( p-clamp(p,-h,h), 0.0 ); // faster, but produces zero in the interior elongated box\n    \n    vec3 q = abs(p)-h;\n    return vec4( max(q,0.0), min(max(q.x,max(q.y,q.z)),0.0) );\n}\n\n\nvec3 opTwist(in vec3 p, in float t) {\n    float c = cos(t * p.y);\n    float s = sin(t * p.y);\n    mat2 m = mat2(c, -s, s, c);\n    return vec3(m * p.xz, p.y);\n}\n\nfloat N21(vec2 p){\n    p = fract(p*vec2(233.34, 851.73));\n    p += dot(p, p+23.45);\n    return fract(p.x*p.y);\n\n}\n\nvec2 N22(vec2 p){\n\n    float n = N21(p);\n    return vec2(n, N21(p+n));\n\n}\n\n// from iq\nfloat Noise( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n  \tf = f*f*(3.0-2.0*f);\n  \tvec2 uv = (p.xy+vec2(37.0,17.0)*p.z) + f.xy;\n  \tvec2 rg = textureLod( iChannel0, (uv+0.5)/256.0, 0.0).yx;\n  \treturn mix( rg.x, rg.y, f.z );\n}\n\n// ref https://www.shadertoy.com/view/Xs33Df\nfloat Noise3D(in vec3 p){\n    const vec3 s = vec3(7, 157, 113);\n\tvec3 ip = floor(p); // Unique unit cell ID.\n    vec4 h = vec4(0., s.yz, s.y + s.z) + dot(ip, s);\n\tp -= ip; // Cell's fractional component.\n    p = p*p*(3. - 2.*p);\n    h = mix(fract(sin(h)*43758.5453), fract(sin(h + s.x)*43758.5453), p.x);\n    h.xy = mix(h.xz, h.yw, p.y);\n    return mix(h.x, h.y, p.z); // Range: [0, 1].\n\t\n}\n\nvec2 hash( vec2 p )\n{\n\tp = vec2( dot(p,vec2(127.1,311.7)),\n\t\t\t dot(p,vec2(269.5,183.3)) );\n\treturn -1.0 + 2.0*fract(sin(p)*43758.5453123);\n}\n\nfloat noise( in vec2 p )\n{\n\tconst float K1 = 0.366025404; // (sqrt(3)-1)/2;\n\tconst float K2 = 0.211324865; // (3-sqrt(3))/6;\n\t\n\tvec2 i = floor( p + (p.x+p.y)*K1 );\n\t\n\tvec2 a = p - i + (i.x+i.y)*K2;\n\tvec2 o = (a.x>a.y) ? vec2(1.0,0.0) : vec2(0.0,1.0);\n\tvec2 b = a - o + K2;\n\tvec2 c = a - 1.0 + 2.0*K2;\n\t\n\tvec3 h = max( 0.5-vec3(dot(a,a), dot(b,b), dot(c,c) ), 0.0 );\n\t\n\tvec3 n = h*h*h*h*vec3( dot(a,hash(i+0.0)), dot(b,hash(i+o)), dot(c,hash(i+1.0)));\n\t\n\treturn dot( n, vec3(70.0) );\n}\n\nfloat fbm(vec2 uv)\n{\n\tfloat f;\n\tmat2 m = mat2( 1.6,  1.2, -1.2,  1.6 );\n\tf  = 0.5000*noise( uv ); uv = m*uv;\n\tf += 0.2500*noise( uv ); uv = m*uv;\n\tf += 0.1250*noise( uv ); uv = m*uv;\n\tf += 0.0625*noise( uv ); uv = m*uv;\n\tf = 0.5 + 0.5*f;\n\treturn f;\n}\n\nfloat FBM( in vec3 p )\n{\n    float n = 0.0;\n    n += 0.50000*Noise( p*1.0 );\n    n += 0.25000*Noise( p*2.0 );\n    n += 0.12500*Noise( p*4.0 );\n    n += 0.06250*Noise( p*8.0 );\n    n += 0.03125*Noise( p*16.0 );\n    return n/0.984375;\n}\n\n\nfloat sdCylinder(vec3 p, vec3 a, vec3 b, float r) {\n\tvec3 ab = b-a;\n    vec3 ap = p-a;\n    \n    float t = dot(ab, ap) / dot(ab, ab);\n    //t = clamp(t, 0., 1.);\n    \n    vec3 c = a + t*ab;\n    \n    float x = length(p-c)-r;\n    float y = (abs(t-.5)-.5)*length(ab);\n    float e = length(max(vec2(x, y), 0.));\n    float i = min(max(x, y), 0.)-0.1;\n    \n    return e+i;\n}\n\nfloat sdRoundBox( vec3 p, vec3 b, float r )\n{\n  vec3 q = abs(p) - b;\n  return -(length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0) - r);\n}\n\nfloat Box(vec3 p, vec3 sc, float r){\n    return length(max(abs(p)-sc, 0.))-r;\n}\n\nfloat Box2(vec3 p, vec3 sc, float r, float an){\n    an = 80.0;\n    vec3 cs = vec3(cos(an*3.1415/180.0), sin(an*3.1415/180.0),cos(an*3.1415/180.0));\n    float c2 = length(cs);\n    \n    float a = length(max( abs(p)-(sc)  , 0.0)) - r;\n    float b = length(max(abs(p)-vec3(1.0, 2.0, 1.0), 0.));\n    return a;\n}\n\nfloat Capsule(vec3 p, vec3 sc, float r){\n    vec3 cs = vec3(cos(90.0*3.1415/180.0), sin(90.0*3.1415/180.0),cos(90.0*3.1415/180.0));  \n    float a = length(max( abs(p)- (sc*cs)  , 0.0)) - r;\n    return a;\n}\n\nfloat sdEllipsoid( vec3 p, vec3 r )\n{\n  float k0 = length(p/r);\n  float k1 = length(p/(r*r));\n  return k0*(k0-1.0)/k1;\n}\n\nfloat opRep( in vec3 p, in vec3 c, vec3 sc, float r )\n{\n    vec3 q = mod(p+0.5*c,c)-0.5*c;\n    return Box( q, sc, r );\n}\n\nfloat opRepS( in vec3 p, in vec3 c, vec4 pos )\n{\n    vec3 q = mod(p+0.5*c,c)-0.5*c;\n    return length(q) - pos.w;\n}\n\nvec3 add_tpos(vec3 tp){\n    return vec3(tp.x+tpos.x, tp.y+tpos.y, tp.z+tpos.z);\n    \n}\n\nvec3 rot_y(vec3 tp, float a){\n    tp.xz *= Rot(a);\n    return tp;\n\n}\n\nfloat sdfSegment(in vec3 p, in vec3 a, in vec3 b, in float r){\n\n    \n    float h = min(1.0, max(0.0, dot(p-a, b-a) / dot(b-a, b-a)));\n   // a = a*exp(-4.*h);\n    //r =r-sin(9.0*3.1415*h)*0.2;\n    //r =r+exp(-4.*h);\n    //r = r -4.*h*(1.-h)-0.2*cos(10.*h+4.*iTime);\n    return length(p-a-(b-a)*h)-r;\n    \n\n}\n\nfloat opRepSeg( in vec3 p, in vec3 c,  in vec3 a, in vec3 b, in float r)\n{\n    vec3 q = mod(p+0.5*c,c)-0.5*c;\n    return sdfSegment(q, a, b, r);\n}\n\n\n\nfloat det( vec2 a, vec2 b ) { return a.x*b.y-b.x*a.y; }\nvec4 sdBezier2( vec3 p, vec3 va, vec3 vb, vec3 vc )\n{\n  vec3 w = normalize( cross( vc-vb, va-vb ) );\n  vec3 u = normalize( vc-vb );\n  vec3 v =          ( cross( w, u ) );\n  //----  \n  vec2 m = vec2( dot(va-vb,u), dot(va-vb,v) );\n  vec2 n = vec2( dot(vc-vb,u), dot(vc-vb,v) );\n  vec3 q = vec3( dot( p-vb,u), dot( p-vb,v), dot(p-vb,w) );\n  //----  \n  float mn = det(m,n);\n  float mq = det(m,q.xy);\n  float nq = det(n,q.xy);\n  //----  \n  vec2  g = (nq+mq+mn)*n + (nq+mq-mn)*m;\n  float f = (nq-mq+mn)*(nq-mq+mn) + 4.0*mq*nq;\n  vec2  z = 0.5*f*vec2(-g.y,g.x)/dot(g,g);\n//float t = clamp(0.5+0.5*(det(z,m+n)+mq+nq)/mn, 0.0 ,1.0 );\n  float t = clamp(0.5+0.5*(det(z-q.xy,m+n))/mn, 0.0 ,1.0 );\n  vec2 cp = m*(1.0-t)*(1.0-t) + n*t*t - q.xy;\n  //----  \n  float d2 = dot(cp,cp);\n  return vec4(sqrt(d2+q.z*q.z), t, q.z, -sign(f)*sqrt(d2) );\n}\n\n\nvec4 opRepBezier( in vec3 p, in vec3 c, vec3 va, vec3 vb, vec3 vc )\n{\n    vec3 q = mod(p+0.5*c,c)-0.5*c;\n    vec3 qa = mod(va+0.5*c,c)-0.5*c;\n    vec3 qb = mod(vb+0.5*c,c)-0.5*c;\n    vec3 qc = mod(vc+0.5*c,c)-0.5*c;\n    return  sdBezier2(q, va, vb, vc);\n}\n\nfloat _line(vec2 p, vec2 a, vec2 b){\n\n    vec2 pa = p-a;\n    vec2 ba = b-a;\n    float h = clamp(dot(pa, ba) / dot(ba, ba), 0., 1.);\n    return length(pa - ba*h);\n}\n\nvec3 Line(vec2 p, vec2 a, vec2 b, float l1, float l2){\n\n    float d = _line(p, a, b);\n    float m = smoothstep(l1, l2, d);\n    return vec3(m); \n\n}\n\n// http://iquilezles.org/www/articles/smin/smin.htm\nfloat smin( float a, float b, float k )\n{\n    float h = max(k-abs(a-b),0.0);\n    return min(a, b) - h*h*0.25/k;\n}\n\n// http://iquilezles.org/www/articles/smin/smin.htm\nfloat smax( float a, float b, float k )\n{\n    k *= 1.4;\n    float h = max(k-abs(a-b),0.0);\n    return max(a, b) + h*h*h/(6.0*k*k);\n}\n\nfloat sdCone( in vec3 p, in vec2 c, float h , float r)\n{\n  // c is the sin/cos of the angle, h is height\n  // Alternatively pass q instead of (c,h),\n  // which is the point at the base in 2D\n  vec2 q = h*vec2(c.x/c.y,-1.0);\n    \n  vec2 w = vec2( length(p.xz), p.y );\n  vec2 a = w - q*clamp( dot(w,q)/dot(q,q), 0.0, 1.0 );\n  vec2 b = w - q*vec2( clamp( w.x/q.x, 0.0, 1.0 ), 1.0 );\n  float k = sign( q.y );\n  float d = min(dot( a, a ),dot(b, b));\n  float s = max( k*(w.x*q.y-w.y*q.x),k*(w.y-q.y)  );\n  return sqrt(d)*sign(s)-r;\n}\n\nvec2 sdSegment(vec3 p, vec3 a, vec3 b)\n{\n    vec3 pa = p-a, ba = b-a;\n\tfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n\treturn vec2( length( pa - ba*h ), h );\n}\n\n\n \nvec2 GetDist(vec3 p, vec2 uv){\n\n\n    \n    vec4 s2 = vec4(3.0 ,3.0, 7.0, 1.0);\n    \n        \n    vec2 d=vec2(0.0);;\n    float pd = dot(p, vec3(0.0, 1.0, 0.0));\n    \n   // pd -=  Noise3D(p+iTime*5.0)*0.2 ;\n   // pd +=  0.1*(sin(1.0*p.x)+sin(1.0*p.z));\n    \n    //float fh = -0.1 + 0.05*(sin(2.0*p.x) + sin(2.0*p.z));\n   // pd = p.y - fh;\n    pd += -1.0+2.0*smoothstep(-0.5, 0.5, sin(1.0*p.x)+sin(1.0*p.y)+sin(1.0*p.z))*0.1;\n    vec4 sph = sphball;\n     \n    sph.y = sin(sph.y*3.1415+iTime*10.0)*5.0+5.0;\n    sph.z -= iTime*2.1;\n    \n    float x = -1.0 + 2.0*abs(fract(iTime*0.5)-0.5)*2.0;\n    sph.x = x*10.5;\n    \n    float fh = -0.1 - 0.05*(sin(p.x*1.0)+sin(p.z*1.0));\n    float gt = fract(iTime+0.1);\n    float l = length((p.xyz-sph.xyz).xz);\n     fh -= 0.4*sin(gt*10.0+l)*exp(-0.02*l*l )*exp(-0.02*gt ) * smoothstep(0.0, 0.1, gt);\n    pd -=  fh;\n    \n        \n    vec3 sp = p - sph.xyz;\n    sp *= RotZ(iTime);\n    sp *= RotY(iTime);\n    sp *= RotX(iTime);\n    //float sd = length(sp) - sph.w;\n    vec3 dim = vec3(3.0);\n    if(sph.y < 2.0){\n        dim.x = iTime*0.001+4.0;\n    }\n    float sd = sdEllipsoid(sp, dim);\n    \n    \n    \n    vec3 q = p-sph.xyz;\n    q *= RotZ(iTime);\n    q *= RotY(iTime);\n    q *= RotX(iTime);\n    sd += smoothstep(0.0, 1.0, Line(q.xy, vec2(5.0, 0.0), vec2(-5.0, 0.0), 0.1, 0.05).x*0.1);\n    sd += smoothstep(0.0, 1.0, Line(q.xy, vec2(0.0, -5.0), vec2(0.0, 5.0), 0.1, 0.05).x*0.1);\n\n    //\n    sd += smoothstep(0.0, 1.0, Line(q.xy, vec2(2.5, 2.5), vec2(-2.5, -2.5), 0.1, 0.05).x*0.1);\n    sd += smoothstep(0.0, 1.0, Line(q.xy, vec2(-2.5, 2.5), vec2(2.5, -2.5), 0.1, 0.05).x*0.1);\n\n    sd += smoothstep(0.0, 1.0, Line(q.xy, vec2(2.5, 2.5), vec2(-2.5, 2.5), 0.1, 0.05).x*0.1);\n    sd += smoothstep(0.0, 1.0, Line(q.xy, vec2(2.5, -2.5), vec2(-2.5, -2.5), 0.1, 0.05).x*0.1);\n    \n    /*vec3 pm = vec3(x*10.5,sph.y, 14.0);\n    pm.z -= iTime*2.10;\n    d = sdfMan(p-pm);*/\n    \n        vec3 bp = p - vec3(25.0, -5.5, 0.0);\n    bp.y -= mod(iTime*2.0, 20.0);\n    vec3 c = vec3(50.0, 0.0, 25.0);\n    bp = mod(bp+0.5*c,c)-0.5*c;;\n    vec3 sc = vec3(5.0);\n    sc -= mod(iTime*2.0*0.25, 5.0);\n   // if(sc.x < 0.0)sc = vec3(5.0);\n    float bd = Box(bp, sc, 0.5);\n    bd += -1.0+2.0*smoothstep(-0.5, 0.5, sin(1.0*p.x)+sin(1.0*p.y)+sin(1.0*p.z))*0.1;\n    \n    float gr = smin(pd, bd, 0.5);\n      \n    //d.x = pd;\n    //d.y = 2.0;\n       \n   // if(sd < d.x){\n        d.x = sd;\n        d.y = 5.0;\n    \n    //}\n     \n    if(gr < d.x){\n        d.x = gr;\n        d.y = 2.0;\n    \n    }\n      \n   // \n    return d;\n    \n    \n}\n\nvec3 RayMarch2(vec3 eye, vec3 viewRayDirection, vec2 uv){\n    vec3 t = vec3(0.);\n    float max = -100000.0;\n    vec2 dd;\n    float depth = 0.0, end = 10.0;\n    for (int i = 0; i < 100; i++) {\n        t.yz = GetDist(eye + t.x * viewRayDirection, uv).xy;\n        \n                    \n        if (abs(t.y) < (t.y*0.01))break;\n                \n        t.x += t.y;\n        \n        if (t.x >= 100.0)break;\n        \n    }\n    if (t.x >= 100.0)t.x = -1.0;\n    \n    return t;\n\n\n}\n\n\n\n\nfloat GetLight(vec3 p, vec2 uv, vec3 lg, out vec3 n){\n    vec3 lightpos = lg;\n    lightpos.xz += vec2(sin(iTime), cos(iTime));\n    vec3 l = normalize(lightpos-p);\n    \n    vec2 d = GetDist(p, uv);\n    vec2 e = vec2(0.01, 0);\n    \n    \n   // float dd = d.x;\n    n = d.x - vec3(\n        GetDist(p-e.xyy, uv).x,\n        GetDist(p-e.yxy, uv).x,\n        GetDist(p-e.yyx, uv).x);\n    \n    n = normalize(n);\n    \n    float dif = clamp(dot(n, l), .0, 1.);\n   // float dif = clamp(dot(n, l), 0., 1.);\n   // vec3 dd = RayMarch2(p+n*.01, l, uv);\n    //if(dd.x < length(lightpos-p))dif *= 0.1;\n    return (dif) ;\n\n}\n\n\nfloat calcAO( in vec3 pos, in vec3 nor )\n{\n\tfloat occ = 0.0;\n    float sca = 1.0;\n    for( int i=0; i<5; i++ )\n    {\n        float hr = 0.01 + 0.12*float(i)/4.0;\n        vec3 aopos =  nor * hr + pos;\n        float dd = GetDist( aopos , vec2(1.0)).x;\n        occ += -(dd-hr)*sca;\n        sca *= 0.95;\n    }\n    return clamp( 1.0 - 3.0*occ, 0.0, 1.0 );    \n}\n\n\n\nvec3 GetLightM(vec3 p, vec2 uv, vec3 lg, out vec3 n, vec3 ro, vec3 rd){\n    vec3 lightpos = lg;\n    //lightpos.xz += vec2(sin(iTime), cos(iTime));\n    vec3 l = normalize(lightpos-p);\n    \n    vec2 d = GetDist(p, uv);\n    vec2 e = vec2(0.01, 0);\n    \n    n = d.x - vec3(\n        GetDist(p-e.xyy, uv).x,\n        GetDist(p-e.yxy, uv).x,\n        GetDist(p-e.yyx, uv).x);\n        \n     \n    \n    n = normalize(n);\n   \n    float occ = calcAO(p, n);       \n    float dif = clamp(dot(n, l), .0, 1.);\n    dif += occ*0.2;\n \n    vec3 dd = RayMarch2(p+n*.01, l, uv);\n    p = ro + rd * dd.x;\n    \n    \n    \n    /*if(dd.x < length(lightpos)){\n           if(dd.z == 2.0)\n        { \n        \n            vec3 col = vec3(length(uv))*texture(iChannel2, vec2(noise(uv+iTime))).rgb;\n            \n        }\n    vec3(0.0, 1.0, 0.0)-p/2.0\n    }*/\n    \n     \n    if((dd.x < length(lightpos-p)) && (dd.x > 0.0)){\n        if(dd.z == -1.0){\n            \n             vec3 col = vec3(dif) ;\n             return col*0.2;\n            \n\n        }\n        else if(dd.z == 1.0)\n        {\n             \n             return vec3(dif)*0.2;\n        }\n        else if(dd.z == 2.0)\n        {\n             \n             return vec3(dif)*0.2;\n        }\n        else if(dd.z == 3.0)\n        {\n             //vec3 col = texture(iChannel1, p.xz*0.5).rgb * n.y;\n             vec3 col = vec3(dif)*vec3(0.88, 0.69, 0.65); ;\n             return col*0.2;\n        }\n        else if(dd.z == 5.0){\n             vec3 col = vec3(1.0, 0.0, 0.0) * vec3(dif);\n             return col;\n             \n         }\n        else\n            return vec3(dif);\n            \n     }\n     else\n         return vec3(dif);\n\n}\nvec3 lightDir = normalize( vec3(0.5,0.6,0.) );\nconst mat2 m2 = mat2( 0.60, -0.80, 0.80, 0.60 );\n//ref: https://www.shadertoy.com/view/Msdfz8\nvec3 Cloud(vec3 bgCol,vec3 ro,vec3 rd,vec3 cloudCol,float spd)\n{\n    vec3 col = bgCol;\n    float t = iTime * 0.15* spd;\n    vec2 sc = ro.xz + rd.xz*((3.)*40000.0-ro.y)/rd.y;\n    vec2 p = 0.00002*sc;\n    float f = 0.0;\n  \tfloat s = 0.5;\n  \tfloat sum =0.;\n  \tfor(int i=0;i<5;i++){\n    \tp += t;t *=1.5;\n    \tf += s* textureLod( iChannel0, p/256.0, 0.0).x; p = m2*p*2.02;\n    \tsum+= s;s*=0.8;\n  \t}\n    float val = f/sum; \n    col = mix( col, cloudCol, smoothstep(0.5,0.8,val) );\n    return col;\n}\nvec3 RayMarchCloud(vec3 ro,vec3 rd){\n    vec3 col = vec3(0.0,0.0,0.0);  \n    float sundot = clamp(dot(rd,lightDir),0.0,1.0);\n    \n     // sky      \n    col = vec3(0.2,0.5,0.85)*1.1 - rd.y*rd.y*0.5;\n    col = mix( col, 0.85*vec3(0.7,0.75,0.85), pow( 1.0-max(rd.y,0.0), 4.0 ) );\n    // sun\n    col += 0.25*vec3(1.0,0.7,0.4)*pow( sundot,5.0 );\n    col += 0.25*vec3(1.0,0.8,0.6)*pow( sundot,64.0 );\n    col += 0.4*vec3(1.0,0.8,0.6)*pow( sundot,512.0 );\n    // clouds\n    col = Cloud(col,ro,rd,vec3(1.0,0.95,1.0),1.);\n            // .\n    col = mix( col, 1.5*vec3(0.0,0.5,1.0), pow( 1.0-max(rd.y,0.0), 16.0 ) );\n    return col;\n}\n\nvec3 Eye(vec3 p, vec4 sp){\n\n    vec3 col = vec3(1.0);\n    vec2 pp = p.xy-sp.xy;\n    float r = sqrt(dot(pp, pp));\n    float a = atan(pp.y, pp.x);\n\n    float ss = 0.5+0.5*sin(5.0*iTime);\n    float anim = 1.0 + 0.1*ss*clamp(r, 0.0, 1.0);\n    r*=anim;\n\n    if(length(p.xy-sp.xy) < .2){\n\n        col =  vec3(0.0, 0.3, 0.4);\n\n        float f = fbm(5.0*pp);\n        col = mix(col, vec3(0.2, 0.5, 0.4), f);\n\n        f = 1. - smoothstep(0.1, 0.15, r);\n        col = mix(col, vec3(0.0, 0.0, 0.0), f);\n\n        /*a += fbm(20.0*pp)*0.05;\n\n        f = smoothstep(0.15, 0.2, fbm(vec2(6.0*r, 20.0*a)) );\n        col = mix(col, vec3(1.0), f);\n\n        f = smoothstep(0.4, 0.9, fbm(vec2(10.0*r, 15.0*a)) );\n        col *= 1.0-0.5*f;\n\n        f = smoothstep(0.6, 0.8, r);\n        col *= 1.0 - 0.5*f;\n\n        f = smoothstep(0.2, 0.25, r);\n        col *= f;\n\n        f = 1.0-smoothstep(0.0, 0.5, length(pp - vec2(0.24, 0.2)) );\n        col += vec3(1.0, 0.9, 0.8)*f*0.9;\n\n        f = smoothstep(0.7, 0.8, r);\n        col = mix(col, vec3(1.0), f);*/\n\n    }\n    \n    return col;\n\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    uv -= 0.5;\n    uv /= vec2(iResolution.y / iResolution.x, 1);\n    // Time varying pixel color\n    vec3 col = vec3(0.0);\n    sphball = vec4(0.0,3.0, 15.0,3.0);\n    \n    //iMouse.xy / iResolution.xy\n    vec3 lookat = vec3((iMouse.x/iResolution.x)*10.0, (iMouse.y/iResolution.y)*30.0, 30.0);//vec3(0.0, 1.5, 0.0);\n    vec3 ro = vec3(-5, 7.0, 1.0);\n    vec4 sph = sphball;\n    float speed = 2.1;\n    ro.z -=iTime*speed;\n    lookat.z -= iTime*speed;\n    sph.z -= iTime*speed;\n    float an = (iMouse.x/iResolution.x)*10.0;\n    ro -= sph.xyz;\n    lookat -= sph.xyz;\n    ro *= RotY(an);\n    lookat *= RotY(an);\n    ro += sph.xyz;\n    lookat += sph.xyz;\n    \n    vec3 lightpos = vec3(0.0, 30., -30.);\n    lightpos.z -= iTime*speed;\n    lightpos -= sph.xyz;\n    lightpos *= RotY(an);\n    lightpos += sph.xyz;\n    //vec3 lightpos2 = vec3(0.0, 5., 16.);\n    //lightpos2.z -= iTime;\n        \n    float zoom = 1.0;    \n    vec3 f = normalize(lookat-ro),\n        r = normalize(cross(vec3(0,1,0), f)),\n        u = cross(f, r),\n        c = ro + f * zoom,\n        i = c + uv.x * r + uv.y * u,\n        rd = normalize(i-ro);\n        \n    \n        \n     vec3 t;\n     float dO, dif, dif2, dif3, difT;\n     vec3 p;\n     \n  \n     \n     t = RayMarch2(ro, rd, uv);\n     p = ro + rd * t.x;\n     \n    float alpha = 1.0;\n    vec3 n1, n2, n3, np;\n  \n   vec3 diff2 = GetLightM(p, uv, lightpos, n1, ro, rd);\n   //vec3 diff3 = GetLightM(p, uv, lightpos2, n1, ro, rd);\n    \n        \n     if(t.x > 0.0){\n         \n         \n         \n    \n     \n         \n         \n         if(t.z == 0.0){\n            // col = ph * vec3(0.0, 1.0, 0.0);\n         }\n         else if(t.z == 1.0){\n             col = diff2* vec3(1.0, 0.0, 0.0);\n         }\n         else if(t.z == 2.0){\n         \n                                    \n            // col = diff2 * vec3(1.0, 0.5, 0.5);\n            // col = 1.0-mix(diff2 * vec3(1.0, 0.5, 0.5), 1.0 - texture(iChannel0, p.xz).rgb*n1.y, 2.8);\n             //col = mix(col, texture(iChannel1, p.xz).rgb*n1.y, 0.8);\n             col = vec3(0.05, 0.09, 0.02);\n             float f = -1.0+2.0*smoothstep(-0.5, 0.5, sin(11.0*p.x)+sin(11.0*p.z))*0.5;\n             //float f =-1.0+2.0*smoothstep(-0.5, 0.5, sin(1.0*p.x)+sin(1.0*p.y)+sin(1.0*p.z))*0.1;\n             col += f*0.05;\n             col +=  diff2 * vec3(0.2, 1., 0.2);\n             \n         }\n         else if(t.z == -1.0){\n             \n                          \n         }\n         else if(t.z == -2.0){\n                          \n             \n         }\n         else if(t.z == 3.0){\n            \n              col = diff2*vec3(0.88, 0.69, 0.65);\n              float f = smoothstep(0.5, 1., fbm(p.xy*25.0));\n              col =mix(col,  texture(iChannel0, vec2(fbm(p.xy*25.0)) ).rgb*0.2, f)  ;\n         \n         }\n         else if(t.z == 5.0){\n             col = vec3(1.0, 0.0, 0.0) * diff2;\n             vec4 sph = sphball;\n             sph.y = sin(sph.y*3.1415+iTime*10.0)*5.0+5.0;\n            sph.z -= iTime*2.1;\n\n            float x = -1.0 + 2.0*abs(fract(iTime*0.5)-0.5)/0.5;\n            sph.x = x*10.5;\n            \n            vec3 q = p-sph.xyz;\n            \n            q *= RotZ(iTime);\n            q *= RotY(iTime);\n            q *= RotX(iTime);\n            \n            vec3 m = Line(q.xy, vec2(5.0, 0.0), vec2(-5.0, 0.0), 0.1, 0.05);\n             m += Line(q.xy, vec2(0.0, -5.0), vec2(0.0, 5.0), 0.1, 0.05);\n             \n             //\n             m += Line(q.xy, vec2(2.5, 2.5), vec2(-2.5, -2.5), 0.1, 0.05);\n             m += Line(q.xy, vec2(-2.5, 2.5), vec2(2.5, -2.5), 0.1, 0.05);\n             \n             m += Line(q.xy, vec2(2.5, 2.5), vec2(-2.5, 2.5), 0.1, 0.05);\n             m += Line(q.xy, vec2(2.5, -2.5), vec2(-2.5, -2.5), 0.1, 0.05);\n             \n             \n             col += m;\n             \n         }\n         \n       \n         \n         \n         \n     }\n     else\n     {\n         col = RayMarchCloud( ro, rd);\n         \n         \n     }\n    \n   \n    // Output to screen\n    fragColor = vec4((col),alpha);\n}\n\n\n\n", "image_inputs": [{"id": "Xsf3zn", "previewfilepath": "/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtGcDz.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[108, 108, 126, 126, 202], [204, 204, 223, 223, 325], [327, 327, 346, 346, 448], [450, 450, 469, 469, 571], [574, 574, 628, 703, 799], [802, 802, 843, 945, 1038], [1041, 1041, 1078, 1078, 1200], [1202, 1202, 1220, 1220, 1315], [1317, 1317, 1334, 1334, 1390], [1392, 1403, 1429, 1429, 1644], [1646, 1691, 1716, 1716, 2081], [2083, 2083, 2104, 2104, 2223], [2225, 2225, 2251, 2251, 2709], [2711, 2711, 2731, 2731, 2961], [2963, 2963, 2987, 2987, 3197], [3200, 3200, 3251, 3251, 3567], [3569, 3569, 3614, 3614, 3708], [3710, 3710, 3746, 3746, 3789], [3791, 3791, 3838, 3838, 4097], [4099, 4099, 4139, 4139, 4304], [4306, 4306, 4343, 4343, 4426], [4428, 4428, 4483, 4483, 4548], [4550, 4550, 4598, 4598, 4665], [4667, 4667, 4690, 4690, 4753], [4755, 4755, 4784, 4784, 4823], [4825, 4825, 4887, 4887, 5131], [5133, 5133, 5207, 5207, 5279], [5283, 5283, 5312, 5312, 5338], [5339, 5339, 5392, 5392, 6168], [6171, 6171, 6240, 6240, 6426], [6428, 6428, 6464, 6464, 6591], [6593, 6593, 6647, 6647, 6739], [6741, 6793, 6834, 6834, 6906], [6908, 6960, 7001, 7001, 7092], [7094, 7094, 7150, 7284, 7621], [7623, 7623, 7663, 7663, 7787], [7792, 7792, 7822, 7822, 10323], [10325, 10325, 10382, 10382, 10797], [10802, 10802, 10855, 10855, 11405], [11408, 11408, 11450, 11450, 11764], [11768, 11768, 11839, 11839, 13423], [13520, 13565, 13629, 13629, 14057], [14058, 14058, 14094, 14094, 14682], [14684, 14684, 14710, 14710, 15743], [15745, 15745, 15802, 15852, 19894]]}
{"id": "wtGcRV", "name": "high on vertigo", "author": "YitingLiu", "description": "effects of vertigo and psychedelic. ", "tags": ["noise", "mix", "time", "color", "random", "rotate", "pi", "psychedelic", "generative", "code", "smoothstep", "scale", "step", "offset", "creative", "freq"], "likes": 1, "viewed": 191, "published": "Public API", "date": "1611330958", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI 3.14159265359\n\n// 2D Random\nfloat random (in vec2 st) {\n    return fract(sin(dot(st.xy,\n                         vec2(12.9898,78.233)))\n                 * 43758.5453123);\n}\n\n\nfloat random (in float x) {\n    return fract(sin(x)*1e4);\n}\n\nmat2 rotate2d(float _angle){\n    return mat2(cos(_angle),-sin(_angle),\n                sin(_angle),cos(_angle));\n}\n\nmat2 scale(vec2 _scale){\n    return mat2(_scale.x,0.0,\n                0.0,_scale.y);\n}\n\n// 2D Noise based on Morgan McGuire @morgan3d\n// https://www.shadertoy.com/view/4dS3Wd\nfloat noise (in vec2 st) {\n    \n    vec2 i = floor(st);\n    vec2 f = fract(st);\n\n    // Four corners in 2D of a tile\n    float a = random(i);\n    float b = random(i + vec2(1.0, 0.0));\n    float c = random(i + vec2(0.0, 1.0));\n    float d = random(i + vec2(1.0, 1.0));\n\n    // Smooth Interpolation\n\n    // Cubic Hermine Curve.  Same as SmoothStep()\n    // vec2 u = f*f*(3.0-2.0*f);\n    vec2 u = f*f*(3.0-15.*abs(tan(iTime*2.))*f);\n    u += smoothstep(0.,0.5,f);\n\n    // Mix 4 coorners percentages\n    return mix(a, b, u.x) +\n            (c - a)* u.y * (1.0 - u.x) +\n            (d - b) * u.x * u.y;\n}\nfloat randomSerie(float x, float freq, float t) {\n    return step(.8,random( floor(x*freq)-floor(t) ));\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\nvec2 st = (2.0 * fragCoord.xy - iResolution.xy) / min(iResolution.y, iResolution.x);    vec3 color = vec3(1.0);\n        // move space from the center to the vec2(0.0)\n    st -= vec2(random(0.5));\n    // rotate the space\n    st = rotate2d( sin(cos(iTime))*PI*(abs(cos(iTime))/1e2+1.)) * st/0.8;\n        st = scale( vec2(sin(iTime)+1.0) ) * st/5.;\n    // move it back to the original place\n    st += vec2(random(0.5));\n    \n    // Scale the coordinate system to see\n    // some noise in action\n    vec2 pos = vec2(st*10.0*smoothstep(0.,0.5,abs(sin(iTime))));\n    float freq = random(1.);\n    float t = random(10.);\n   float offset = 0.0005+random(0.5);\n        // Use the noise function\n\nfloat n = noise(pos);\n    color = vec3(randomSerie(st.x*n*1e1, freq*200., n*t+offset),\n                 randomSerie(atan(st.x,st.y), freq*100., n/t),\n                 randomSerie(tan(st.y), freq*1000.*cos(iTime), t-offset));\n    color/= vec3(n);\n    color*=vec3(n)*1e2;\n    \n\n    fragColor = vec4(color, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtGcRV.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[26, 39, 66, 66, 183], [186, 186, 213, 213, 245], [247, 247, 275, 275, 361], [363, 363, 387, 387, 450], [452, 539, 565, 565, 1138], [1139, 1139, 1188, 1188, 1244], [1245, 1245, 1302, 1302, 2300]]}
{"id": "wtGcRz", "name": "Tori Gate On The Ocean", "author": "intrakits", "description": "I wanted to try and be more artistic and felt inspired after looking at a photo of a japanese shrine. It still needs some work, but I like the way it is coming along. :)", "tags": ["art", "japan", "shrine", "gate", "japanese", "tori", "shinto"], "likes": 4, "viewed": 152, "published": "Public API", "date": "1610324492", "time_retrieved": "2021-10-01T00:00:00", "image_code": "mat2 rotate(float r) {\n    float c = cos(r);\n    float s = sin(r);\n    return mat2(c, -s, s, c);\n}\n\nvec3 circle (vec2 uv, float posX, float posY, float r, float blur, vec3 color){\n    uv.x-=posX;\n    uv.y-=posY;\n    \n    float d = length(uv);\n    return color * vec3(smoothstep(r,r-blur,d));\n}\nvec3 circle (vec2 uv, float r, float blur, vec3 color){\n    float d = length(uv);\n    return color * vec3(smoothstep(r,r-blur,d));\n}\nvec3 square(vec2 uv, float w, float h, float posX, float posY, float rot, float blur, vec3 color){\n    uv*=rotate(rot);\n    float wPos = length(uv.x-posX);\n    float hPos = length(uv.y-posY);\n    \n    float col = smoothstep(w,w-blur, wPos);\n    col *= smoothstep(h,h-blur, hPos);\n    return color*vec3(col);\n}\nvec3 triangle(vec2 uv, float w, float h, float posX, float posY, float rot, float blur, vec3 color){\n    uv.x-=posX;\n    uv.y-=posY;\n    uv*=rotate(rot);\n    vec3 sq = square(uv,w,h,0.,0.,0.,blur,color);\n    uv*=rotate(3.1415/2./2.);\n    uv-= vec2(0.,h);\n    float hyp = sqrt(w*w + h*h);\n    vec3 sqMask = square(uv,hyp,h,0.,0., 0.,blur,color);\n    sq -= sqMask;\n    return sq;\n}\nvec3 ellipse(vec2 uv, float posX, float posY, float rot, float a,float b, float blur, vec3 color){\n    uv -= vec2(posX,posY);\n    uv*=rotate(rot);\n    float x = uv.x;\n    float y = sqrt((1.-a)*(1.-((x*x)/(1.-b))));\n    float d = length(uv);\n    return color * vec3(smoothstep(y,y-blur,d));\n}\nvec3 wave (vec2 uv, float xPos, float yPos, float blur, float vertSpeed, float horSpeed){\n    float movX = sin(iTime*vertSpeed)*.04;\n    float movY = cos(iTime*horSpeed)*.04;\n    uv -= vec2(xPos,yPos);\n    vec3 wave = circle (uv - vec2(movX,movY),.2,blur, vec3(1.));\n    wave = min(wave, wave-circle (uv - vec2(0.12 + movX,.05 + movY), 0.2, blur, vec3(1.)));\n    wave = min(wave, wave-circle (uv - vec2(-0.12+ movX,.05+ movY), 0.2, blur, vec3(1.)));\n    wave = min(wave, wave-circle (uv - vec2(0.+ movX,-.34+ movY), 0.2, blur, vec3(1.)));\n    return wave;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    uv-= 0.5;\n    \n    uv.x *= iResolution.x/iResolution.y;\n\n    \n    //background\n    float blur = 0.01;\n    //sky\n    vec3 col = vec3(uv.y+.3) * vec3(1,.2,.4);\n    \n    //ocean\n    col = max(col, vec3(-uv.y) * vec3(.5,.4,.8));\n    //waves\n    \n    float movX = sin(iTime)*.04;\n    float movY = cos(iTime*2.)*.04;\n    \n    vec3 w = wave(uv,0.4,-0.2,blur, 1., 2.);\n    w = max(w, wave(uv,-.4,-0.2,blur, 1., 4.));\n    w = max(w, wave(uv,-.2,-0.3,blur, 1.3, 2.));\n    w = max(w, wave(uv,.3,-0.3,blur, 1.6, 2.3));\n    col = max(col, w);\n    \n    //water lines\n    vec3 waterLine = square(uv, .7, .005, -.9+movX, -0.4, 0., blur, vec3(1.));\n    waterLine = max(waterLine, square(uv, .9, .005,.9+movX*.5, -0.39, 0., blur, vec3(1.)));\n    waterLine = max(waterLine, square(uv, .8, .005,-.9+movX*.7, -0.38, 0., blur, vec3(1.)));\n    waterLine = max(waterLine, square(uv, .777, .005,.9+movX*.9, -0.37, 0., blur, vec3(1.)));\n    waterLine = max(waterLine, square(uv, .8, .005,-.9+movX*.2, -0.36, 0., blur, vec3(1.)));\n    waterLine = max(waterLine, square(uv, .82, .005,.9+movX*1.2, -0.35, 0., blur, vec3(1.)));\n    waterLine = max(waterLine, square(uv, .76, .005,-.9+movX*.7, -0.34, 0., blur, vec3(1.)));\n    waterLine = max(waterLine, square(uv, .9, .005,.9+movX*.9, -0.33, 0., blur, vec3(1.)));\n    waterLine = max(waterLine, square(uv, .9, .005,-.9+movX*.2, -0.32, 0., blur, vec3(1.)));\n    waterLine = max(waterLine, square(uv, .8, .005,.9+movX*1.2, -0.31, 0., blur, vec3(1.)));\n    col = max(col, waterLine);\n    //ground\n    vec3 groundM = ellipse(uv, 0., -0.26, 3.1415/2., .9,.996, blur, vec3(1.));\n    groundM = max(groundM, square(uv, .1, .2, -0.2, -0.33, -1., blur, vec3(1.)) - square(uv, .2, .3, 0., 0., 0., blur, vec3(1.)) );\n    groundM = max(groundM, square(uv, .45, .136, 0.7,-.5, 0., blur, vec3(1.)));\n    col-= groundM;\n    vec3 ground = ellipse(uv, 0., -0.26, 3.1415/2., .9,.996, blur, vec3(.5));\n    ground = max(ground, square(uv, .1, .2, -0.2, -0.33, -1., blur, vec3(.5))- square(uv, .2, .3, 0., 0., 0., blur, vec3(1.)));\n    ground = max(ground, square(uv, .45, .136, 0.7,-.5, 0., blur, vec3(.5)));\n    col = max(col,ground);\n    //tori gate\n    ///mask----------------------\n    //legs\n    vec3 toriM = square(uv, .03, .25, -0.2, 0., 0.02, blur, vec3(1.));\n    toriM = max(toriM,square(uv, .03, .25, 0.2, 0., -0.02, blur, vec3(1.)));\n    \n    //horizontal beams\n    toriM = max(toriM,square(uv, .37, .03, 0., 0.15, 0., blur, vec3(1.)));\n    toriM = max(toriM,square(uv, .37, .022, 0., 0.25, 0., blur, vec3(1.)));\n    \n    //lower horizontal mask\n    toriM = min(toriM,toriM-square(uv, .05, .02, -0.34, 0.076, 0.13, blur, vec3(1.)));\n    toriM = min(toriM,toriM-square(uv, .05, .02, -0.3, 0.22, -0.13, blur, vec3(1.)));\n    \n    toriM = min(toriM,toriM-square(uv, .05, .02, 0.34, 0.076, -0.13, blur, vec3(1.)));\n    toriM = min(toriM,toriM-square(uv, .05, .02, 0.3, 0.22, 0.13, blur, vec3(1.)));\n    \n    //central beam\n    toriM = max(toriM,square(uv, .03, .04, 0., 0.2, -0.02, blur, vec3(1.,0,0)));\n    \n    \n    //top beam\n    toriM = max(toriM,square(uv, .37, .022, 0., .278, 0., blur, vec3(1,.6,.4)));\n    toriM = max(toriM,circle (uv-vec2(-.36,.305), .05, blur, vec3(1,.6,.4)));\n    toriM = max(toriM,circle (uv-vec2(.36,.305), .05, blur, vec3(1,.6,.4)));\n    \n    toriM = min(toriM,toriM-circle (uv-vec2(-.33,.338), .05, blur, vec3(1,.6,.4)));\n    toriM = min(toriM,toriM-circle (uv-vec2(.33,.338), .05, blur, vec3(1,.6,.4)));\n    \n    // embelleshments\n    toriM = max(toriM,square(uv, .034, .022, -0.198, .11, 0., blur, vec3(1,.6,.4)));\n    toriM = max(toriM,square(uv, .034, .022, -0.198, .22, 0., blur, vec3(1,.6,.4)));\n    toriM = max(toriM,square(uv, .034, .022, 0.198, .11, 0., blur, vec3(1,.6,.4)));\n    toriM = max(toriM,square(uv, .034, .022, 0.198, .22, 0., blur, vec3(1,.6,.4)));\n    col -= toriM;\n    \n    //-------------------------\n    //legs\n    vec3 tori = square(uv, .03, .25, -0.2, 0., 0.02, blur, vec3(1.,0,0));\n    tori = max(tori,square(uv, .03, .25, 0.2, 0., -0.02, blur, vec3(1.,0,0)));\n    \n    //horizontal beams\n    tori = max(tori,square(uv, .37, .03, 0., 0.15, 0., blur, vec3(1.,0,0)));\n    tori = max(tori,square(uv, .37, .022, 0., 0.25, 0., blur, vec3(1.,0,0)));\n    \n    //lower horizontal mask\n    tori = min(tori,tori-square(uv, .05, .02, -0.34, 0.076, 0.13, blur, vec3(1.)));\n    tori = min(tori,tori-square(uv, .05, .02, -0.3, 0.22, -0.13, blur, vec3(1.)));\n    \n    tori = min(tori,tori-square(uv, .05, .02, 0.34, 0.076, -0.13, blur, vec3(1.)));\n    tori = min(tori,tori-square(uv, .05, .02, 0.3, 0.22, 0.13, blur, vec3(1.)));\n    \n    //central beam\n    tori = max(tori,square(uv, .03, .04, 0., 0.2, -0.02, blur, vec3(1.,0,0)));\n    \n    \n    //top beam\n    tori = max(tori,square(uv, .37, .022, 0., .278, 0., blur, vec3(1,.6,.4)));\n    tori = max(tori,circle (uv-vec2(-.36,.305), .05, blur, vec3(1,.6,.4)));\n    tori = max(tori,circle (uv-vec2(.36,.305), .05, blur, vec3(1,.6,.4)));\n    \n    tori = min(tori,tori-circle (uv-vec2(-.33,.338), .05, blur, vec3(1,.6,.4)));\n    tori = min(tori,tori-circle (uv-vec2(.33,.338), .05, blur, vec3(1,.6,.4)));\n    \n    // embelleshments\n    tori = max(tori,square(uv, .034, .022, -0.198, .11, 0., blur, vec3(1,.6,.4)));\n    tori = max(tori,square(uv, .034, .022, -0.198, .22, 0., blur, vec3(1,.6,.4)));\n    tori = max(tori,square(uv, .034, .022, 0.198, .11, 0., blur, vec3(1,.6,.4)));\n    tori = max(tori,square(uv, .034, .022, 0.198, .22, 0., blur, vec3(1,.6,.4)));\n    tori = max(square(uv, .034, .04, -0.205, -.21, 0., blur, vec3(.5)),tori-square(uv, .034, .04, -0.205, -.21, 0., blur, vec3(.5)));\n    tori = max(square(uv, .034, .04, 0.205, -.21, 0., blur, vec3(.5)),tori-square(uv, .034, .04, 0.205, -.21, 0., blur, vec3(.5)));\n    col = max(col,tori);\n    \n    //sun\n    vec3 sun = circle (uv-vec2(.0,.405), .04, blur, vec3(1));\n    sun = max(sun, circle (uv-vec2(.0,.405), .06, blur, vec3(1,.5,.5)));\n    col = max(col, sun);\n    // Output to screen\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtGcRz.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 22, 22, 98], [100, 100, 179, 179, 293], [294, 294, 349, 349, 426], [427, 427, 525, 525, 736], [737, 737, 837, 837, 1116], [1117, 1117, 1215, 1215, 1408], [1409, 1409, 1498, 1498, 1966], [1967, 1967, 2024, 2074, 8108]]}
{"id": "wtGcWc", "name": "Super Julia Fractal", "author": "rsiqueira", "description": "Animated fractal based on Dwitter code: https://www.dwitter.net/d/21456", "tags": ["fractal", "julia", "mandelbrot"], "likes": 3, "viewed": 159, "published": "Public", "date": "1611864007", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec3 hsl2rgb( in vec3 c ) {\n  vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n  return c.z + c.y * (rgb-0.5)*(1.0-abs(2.0*c.z-1.0));\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n   vec2 uv = fragCoord/iResolution.xy;\n\n\n    float pixel_x = uv.x /9. - 1.17;\n    float pixel_y = uv.y /15. + 0.6;\n\n    float X = pixel_x;\n    float Y = pixel_y;\n    float n = 120.;\n\n\tfor (float k=17.;k>0.;k-=0.2) {\n\n\t\tfloat X_new = X*X - Y*Y + 0.0-cos(iTime/5.)/55.;\n\t\tfloat Y_new = 2.*X*Y    + 0.705-sin(iTime/5.)/55.;\n        X = X_new;\n        n=n-1.;\n        Y = Y_new;\n\n\t\tif (tan(X_new+sin(Y_new-iTime*0.3))<=9.) {\n\n        } else {\n\n          fragColor = vec4( hsl2rgb( \n                           vec3(.2+k/20. -iTime*0.1, 0.8, 0.5+ cos(n/5.+iTime)*n/180.)\n                      ),1.0);\n           break;\n        }\n\n\n\n\t}\n\n\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtGcWc.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 27, 27, 165], [168, 168, 225, 225, 858]]}
{"id": "WtGcWy", "name": "Cube Roots of a Complex Number", "author": "oneshade", "description": "Using De Moivre's formula to calculate the three cube roots of a complex number. Drag with mouse to change z.", "tags": ["complex", "polar", "formula", "demoivre", "cuberoot"], "likes": 4, "viewed": 82, "published": "Public", "date": "1611635026", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define HALF_PI 1.57079632679\n#define COS_120 -0.5\n#define SIN_120 0.86602540378\n\n// Container for 3 complex numbers\nstruct Complex3 {\n    vec2 a;\n    vec2 b;\n    vec2 c;\n};\n\nComplex3 complexCuberoot(in vec2 z) {\n    // De Moivre's formula\n    vec2 r = sin(atan(z.y, z.x) / 3.0 + vec2(HALF_PI, 0.0)) * pow(length(z), 1.0 / 3.0);\n    return Complex3(r,\n                    r * mat2(COS_120,  SIN_120, -SIN_120, COS_120),  // Rotate +120 degrees\n                    r * mat2(COS_120, -SIN_120,  SIN_120, COS_120)); // Rotate -120 degrees\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 screenCenter = 0.5 * iResolution.xy;\n\n    vec2 uv = (fragCoord - screenCenter) / iResolution.y * 4.0;\n    float unit = 8.0 / iResolution.y;\n    vec3 color = vec3(0.0);\n\n    // Draw grid\n    color = mix(color, vec3(0.0, 0.0, 1.0), smoothstep(unit, 0.0, abs(mod(uv.y + 0.125, 0.25) - 0.125)));\n    color = mix(color, vec3(0.0, 0.0, 1.0), smoothstep(unit, 0.0, abs(mod(uv.x + 0.125, 0.25) - 0.125)));\n\n    // Draw axes\n    color = mix(color, vec3(1.0, 0.0, 0.0), smoothstep(unit, 0.0, abs(uv.y)));\n    color = mix(color, vec3(1.0, 0.0, 0.0), smoothstep(unit, 0.0, abs(uv.x)));\n\n    // Complex number (demo if no mouse)\n    vec2 z = vec2(sin(iTime * 1.25) * 2.0, cos(iTime * 0.5));\n    if (iMouse.z > 0.0) {\n        z = (iMouse.xy - screenCenter) / iResolution.y * 4.0;\n    }\n\n    // Find cube roots of z and plot\n    Complex3 cbrt = complexCuberoot(z);\n\n    color = mix(color, vec3(1.0), smoothstep(unit, 0.0, length(uv - z) - 0.05));\n\n    color = mix(color, vec3(1.0, 0.0, 1.0), smoothstep(unit, 0.0, length(uv - cbrt.a) - 0.05));\n    color = mix(color, vec3(0.0, 1.0, 0.0), smoothstep(unit, 0.0, length(uv - cbrt.b) - 0.05));\n    color = mix(color, vec3(1.0, 1.0, 0.0), smoothstep(unit, 0.0, length(uv - cbrt.c) - 0.05));\n\n    // Draw \"z\" character\n    vec4 zTexBbox = vec4(0.625, 0.5, 0.6875, 0.5625);\n    vec4 zScrBbox = vec4(-0.15, 0.1, 0.15, 0.4);\n\n    zScrBbox.xy += z;\n    zScrBbox.zw += z;\n\n    if (all(lessThan(uv, zScrBbox.zw)) && all(greaterThan(uv, zScrBbox.xy))) {\n        vec2 mappedUv = (uv - zScrBbox.xy) / (zScrBbox.zw - zScrBbox.xy) * (zTexBbox.zw - zTexBbox.xy) + zTexBbox.xy;\n        color = mix(color, vec3(1.0), smoothstep(unit, 0.0, texture(iChannel0, mappedUv).w - 0.5));\n    }\n\n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [{"id": "4dXGzr", "previewfilepath": "/media/ap/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WtGcWy.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[82, 175, 212, 239, 537], [539, 539, 594, 594, 2340]]}
{"id": "WtGXRc", "name": "Arc - gradient 2D", "author": "iq", "description": "Signed distance and gradient to an arc segment. Faster than central differences or automatic differentiation/dual numbers most probably.", "tags": ["2d", "distancefield", "sdf", "gradient", "distance", "arc"], "likes": 16, "viewed": 452, "published": "Public API", "date": "1611122022", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// The MIT License\n// Copyright © 2020 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// Signed distance and gradient to a circle art.\n// Probably faster than central differences or automatic\n// differentiation/dual numbers.\n\n// List of other 2D distances+gradients:\n// https://iquilezles.org/www/articles/distgradfunctions2d/distgradfunctions2d.htm\n//\n// Circle:             https://www.shadertoy.com/view/WltSDj\n// Pie:                https://www.shadertoy.com/view/3tGXRc\n// Arc:                https://www.shadertoy.com/view/WtGXRc\n// Isosceles Triangle: https://www.shadertoy.com/view/3dyfDd\n// Triangle:           https://www.shadertoy.com/view/tlVyWh\n// Box:                https://www.shadertoy.com/view/wlcXD2\n// Quad:               https://www.shadertoy.com/view/WtVcD1\n// Cross:              https://www.shadertoy.com/view/WtdXWj\n// Segment:            https://www.shadertoy.com/view/WtdSDj\n// Hexagon:            https://www.shadertoy.com/view/WtySRc\n// Vesica:             https://www.shadertoy.com/view/3lGXRc\n// Smooth-Minimum:     https://www.shadertoy.com/view/tdGBDt\n// Parallelogram:      https://www.shadertoy.com/view/sssGzX\n\n// .x = f(p)\n// .y = ∂f(p)/∂x\n// .z = ∂f(p)/∂y\n// .yz = ∇f(p) with ‖∇f(p)‖ = 1\n// sca is the sin/cos of the orientation\n// scb is the sin/cos of the aperture\nvec3 sdgArc( in vec2 p, in vec2 sca, in vec2 scb, in float ra, in float rb )\n{\n    vec2 q = p;\n\n    mat2 ma = mat2(sca.x,-sca.y,sca.y,sca.x);\n    p = ma*p;\n\n    float s = sign(p.x); p.x = abs(p.x);\n    \n    if( scb.y*p.x > scb.x*p.y )\n    {\n        vec2  w = p - ra*scb;\n        float d = length(w);\n        return vec3( d-rb, vec2(s*w.x,w.y)*ma/d );\n    }\n    else\n    {\n        float l = length(q);\n        float w = l - ra;\n        return vec3( abs(w)-rb, sign(w)*q/l );\n    }\n}\n\n#define AA 2\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 tot = vec3(0.0);\n    \n    #if AA>1\n    for( int m=0; m<AA; m++ )\n    for( int n=0; n<AA; n++ )\n    {\n        // pixel coordinates\n        vec2 o = vec2(float(m),float(n)) / float(AA) - 0.5;\n        vec2 p = (-iResolution.xy + 2.0*(fragCoord+o))/iResolution.y;\n        #else    \n        vec2 p = (-iResolution.xy + 2.0*fragCoord)/iResolution.y;\n        #endif\n\n        // animation\n        float ta = 3.14*(0.5+0.5*cos(iTime*0.52+2.0));\n        float tb = 3.14*(0.5+0.5*cos(iTime*0.31+2.0));\n        float rb = 0.15*(0.5+0.5*cos(iTime*0.41+1.0));\n\n        // sdf(p) and gradient(sdf(p))\n        vec3  dg = sdgArc(p,vec2(sin(ta),cos(ta)),vec2(sin(tb),cos(tb)), 0.5, rb);\n        float d = dg.x;\n        vec2  g = dg.yz;\n\n        // central differenes based gradient, for comparison\n        // g = vec2(dFdx(d),dFdy(d))/(2.0/iResolution.y);\n\n        // coloring\n        vec3 col = (d>0.0) ? vec3(0.9,0.6,0.3) : vec3(0.4,0.7,0.85);\n        col *= 1.0 + vec3(0.5*g,0.0);\n      //col = vec3(0.5+0.5*g,1.0);\n        col *= 1.0 - 0.5*exp(-16.0*abs(d));\n        col *= 0.9 + 0.1*cos(150.0*d);\n        col = mix( col, vec3(1.0), 1.0-smoothstep(0.0,0.01,abs(d)) );\n    \n\t    tot += col;\n    #if AA>1\n    }\n    tot /= float(AA*AA);\n    #endif\n\n\tfragColor = vec4( tot, 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WtGXRc.jpg", "access": "shaders20k", "license": "mit", "functions": [[2139, 2313, 2391, 2391, 2794], [2810, 2810, 2867, 2867, 4141]]}
{"id": "WtGyDy", "name": "Tutorial part 4", "author": "shellshear", "description": "Following along with shadertoy tutorial from The Art of Code to make a sin wave that blurs out to the right", "tags": ["blur"], "likes": 3, "viewed": 71, "published": "Public", "date": "1611700195", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float Band(float t, float start, float end, float blur)\n{\n    float step1 = smoothstep(start-blur, start+blur, t);\n    float step2 = smoothstep(end+blur, end-blur, t);\n    \n    return step1 * step2;\n}\n\nfloat Rect(vec2 uv, float left, float right, float bottom, float top, float blur)\n{\n    return Band(uv.x, left, right, blur) * Band(uv.y, bottom, top, blur);\n}\n\n\n// Remap v to be 0 at a and 1 at b\nfloat remap_simple(float a, float b, float v)\n{\n    return (v-a)/(b-a);\n}\n\n// Remap v so that output is linearly c at a and d at b\nfloat remap(float a, float b, float c, float d, float v)\n{\n    return (d-c)*remap_simple(a,b,v) + c;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   // Normalized pixel coordinates (from 0 to 1)\n   vec2 uv = fragCoord/iResolution.xy;\n   float t = iTime + .5*sin(iTime);\n   \n   uv -= 0.5;\n   uv.x *= iResolution.x / iResolution.y;\n   \n   float x = uv.x;\n   float m = sin(x*8.+t*4.) *.1;\n   float y = uv.y-m;\n   //float m = (x-.5)*(x+.5); // Parabola going through -.5 and .5\n   //float y = uv.y-m*m*4.; // Derivative of parabola\n   //x+=y*y;\n   //y+=x;\n   \n   //float blur = .1*(x+.5); // blur = 0 at -.5, max as it goes right\n   float blur = remap(-.5,.5, .01,.2, x);\n   blur = pow(blur*4.,3.);\n   float mask = Rect(vec2(x,y), -.5, .5, -.1,.1, blur);\n   vec3 col = vec3(1.,1.,1.) * mask;\n   \n   fragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WtGyDy.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 200], [202, 202, 285, 285, 361], [364, 399, 446, 446, 472], [474, 530, 588, 588, 632], [634, 634, 691, 740, 1370]]}
{"id": "WtGyRd", "name": "Crystal tunnel", "author": "jarble", "description": "A 3D fractal based on my [url=https://www.shadertoy.com/view/wtKcRc]\"Fractal tile mosaic 2.\"[/url]", "tags": ["3d", "raymarching", "fractal", "recursion"], "likes": 5, "viewed": 214, "published": "Public API", "date": "1611523772", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//this is based on https://www.shadertoy.com/view/4tcGDr\n\n#define rot(spin) mat2(cos(spin),sin(spin),-sin(spin),cos(spin))\n#define multiplier 9.0\n#define iterations 2\n\nconst int MAX_MARCHING_STEPS = 1000;\nconst float MIN_DIST = 0.0,\nMAX_DIST = 100.0,\nEPSILON = 0.01,\nsize = 1000.0;\n\n//change these parameters to get different tile patterns.\n#define scale 5.5\n#define scale1 2.0\n#define scale2 1.9\n#define scale3 4.0\n#define ITERATIONS 3\n\n\n/**\n * Signed distance function describing the scene.\n * \n * Absolute value of the return value indicates the distance to the surface.\n * Sign indicates whether the point is inside or outside the surface,\n * negative indicating inside.\n */\n\n \n\nfloat fract1(float a){\n    return (abs(fract(a/2.0)-.5))*2.0;\n}\n\nvec2 fract1(vec2 a){\n    return (abs(fract(a/2.0)-.5))*2.0;\n}\n\nvec3 fract1(vec3 a){\n    return (abs(fract(a/2.0)-.5))*2.0;\n}\n\nvec3 fractal(vec3 uv1){\n    vec3 col,uv;\n    for(int c=0;c<3;c++){\n        uv = uv1;\n        //uv += vec2(iTime/3.0,iTime/8.0)/2.0;\n        for(int i=0;i<ITERATIONS;i++)\n        {\n            uv = (fract1(uv/scale2))*scale1;\n            uv= fract1(uv/(2.0-fract1((uv.x-uv.y)/(8.0)))-(uv/(1.7+(fract1(uv.x+uv.y))))/scale)*scale/scale1+scale1*scale;\n            uv /= scale1+col.yzx/scale;\n        \tuv=uv.yzx;\n        }\n     col[c] = fract(fract(uv.y)+fract(uv.x));\n\t}\n    return col;\n}\n\n\nfloat sceneSDF(vec3 p) {\n    return length(fractal(p/10.0));\n}\n\nvec3 surface_color(vec3 p)\n{\n    return vec3(fractal(p/5.0)+fractal(p.yzx/6.0));\n}\n\n/**\n * Return the shortest distance from the eyepoint to the scene surface along\n * the marching direction. If no part of the surface is found between start and end,\n * return end.\n * \n * eye: the eye point, acting as the origin of the ray\n * marchingDirection: the normalized direction to march in\n * start: the starting distance away from the eye\n * end: the max distance away from the ey to march before giving up\n */\nfloat shortestDistanceToSurface(vec3 eye, vec3 marchingDirection, float start, float end) {\n    float depth = start;\n    float eps = EPSILON;\n    for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n        float dist = sceneSDF(eye + depth * marchingDirection);\n        if (dist < eps*(1.0+depth*.1)) {\n\t\t\treturn depth;\n        }\n        depth += dist;\n        eps *= 1.001;\n        if (depth >= end) {\n            return end;\n        }\n    }\n    return end;\n}\n            \n\n/**\n * Return the normalized direction to march in from the eye point for a single pixel.\n * \n * fieldOfView: vertical field of view in degrees\n * size: resolution of the output image\n * fragCoord: the x,y coordinate of the pixel in the output image\n */\nvec3 rayDirection(float fieldOfView, vec2 size, vec2 fragCoord) {\n    vec2 xy = fragCoord - size / 2.0;\n    float z = size.y / tan(radians(fieldOfView) / 2.0);\n    return normalize(vec3(xy, -z));\n}\n\nvec3 illumination(vec3 k_a, vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye) {\n    const vec3 ambientLight = 0.5 * vec3(1.0, 1.0, 1.0);\n    vec3 color = ambientLight * k_a;\n    \n    //vec3 light1Pos = eye;\n    //vec3 light1Intensity = vec3(0.8);\n    \n    //color += phongContribForLight(k_d, k_s, alpha, p, eye,\n    //                              light1Pos,\n    //                              light1Intensity);   \n    return color;\n}\n\n/**\n * Return a transform matrix that will transform a ray from view space\n * to world coordinates, given the eye point, the camera target, and an up vector.\n *\n * This assumes that the center of the camera is aligned with the negative z axis in\n * view space when calculating the ray marching direction. See rayDirection.\n */\nmat3 viewMatrix(vec3 eye, vec3 center, vec3 up) {\n    // Based on gluLookAt man page\n    vec3 f = normalize(center - eye);\n    vec3 s = normalize(cross(f, up));\n    vec3 u = cross(s, f);\n    return mat3(s, u, -f);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec3 viewDir = rayDirection(45.0, iResolution.xy, fragCoord);\n        viewDir.x+=-.5;\n        /*if (length(iMouse.xy) > 40.0) {\n            viewDir.yz *= rot(-iMouse.y/iResolution.y*3.14-3.14*0.5);\n            viewDir.xz *= rot(iMouse.x/iResolution.x*3.14*2.0-3.14);\n        }*/\n    \n    vec3 eye = vec3(-35.0+sin(iTime/2.0)/2.0,1.0+cos(iTime/2.0)/2.0,iTime*2.0+50.0);\n    \n    mat3 viewToWorld = viewMatrix(eye, vec3(0.0, 0.0, 0.0), vec3(0.0, 1.0, 0.0));\n    \n    vec3 worldDir = -viewToWorld * viewDir;\n    \n    float dist = shortestDistanceToSurface(eye, worldDir, MIN_DIST, MAX_DIST);\n    \n    if (dist > MAX_DIST - EPSILON) {\n        // Didn't hit anything\n        fragColor = vec4(0.0, 0.0, 0.0, 0.0);\n\t\treturn;\n    }\n    \n    // The closest point on the surface to the eyepoint along the view ray\n    vec3 p = eye + dist * worldDir;\n    \n    vec3 K_a = surface_color(p);\n    vec3 K_d = K_a;\n    vec3 K_s = vec3(1.0, 1.0, 1.0);\n    float shininess = 7.0;\n    \n    vec3 color = illumination(K_a, K_d, K_s, shininess, p, eye);\n    \n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WtGyRd.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[439, 683, 705, 705, 746], [748, 748, 768, 768, 809], [811, 811, 831, 831, 872], [874, 874, 897, 897, 1358], [1361, 1361, 1385, 1385, 1423], [1425, 1425, 1453, 1453, 1507], [1509, 1930, 2021, 2021, 2385], [2400, 2654, 2719, 2719, 2851], [2853, 2853, 2933, 2933, 3290], [3292, 3619, 3668, 3703, 3834], [3836, 3836, 3893, 3893, 4966]]}
{"id": "wtGyRR", "name": "Tron Hyperspace", "author": "pmayrgundter", "description": "On a dark desert highway in the metaverse", "tags": ["fractal", "darkwave"], "likes": 1, "viewed": 212, "published": "Public API", "date": "1610310796", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  // Normalized pixel coordinates (from 0 to 1)\n  vec2 uv = fragCoord/iResolution.xy;\n  vec2 q = uv - vec2(0.5, 0.5);\n  q.xy = q.yx;\n  float p1 = 0.5;\n  float te1 = iTime/10.;\n  float te3 = te1/20.;\n  float te5 = te3/40.;\n  q.x = sin(te1) * q.x;\n  float R = sin(te1);\n  float G = cos(te1);\n  float B = sin(q.x)/cos(q.y);\n  vec3 col = p1 * vec3(R, G, B);\n  float fC = sin(te1);\n  float f1 = fC * sin(q.x/q.y);\n  float pulse = sin(\n    (cos(te1) * cos(te5))\n    /(f1 * sin(te3) * cos(te3)));\n  vec2 tig = vec2(sin(te1), cos(te3));\n  //opt1:\n  tig *= tig;\n  vec2 squig = vec2(sin(pulse), cos(pulse));\n  //opt2:\n  squig *= squig;\n  col *= 0.2 / length(q * tig * squig);\n  // Mix in sound\n  vec2 sound = texture( iChannel1, vec2(0.1,0.3) ).xy;\n  col.x *= sound.x;\n  col.y *= sound.y;\n  // Output to screen\n  fragColor = vec4(col,1.0);\n}\n", "image_inputs": [{"id": "4df3Rn", "previewfilepath": "/media/ap/3c33c415862bb7964d256f4749408247da6596f2167dca2c86cc38f83c244aa6.mp3", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/3c33c415862bb7964d256f4749408247da6596f2167dca2c86cc38f83c244aa6.mp3", "ctype": "music"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtGyRR.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 55, 103, 887]]}
{"id": "wtGyRz", "name": "Overlapping Circles - by me", "author": "aiivers", "description": "Circles with varying color values overlapping to create new values", "tags": ["circlescolors"], "likes": 4, "viewed": 106, "published": "Public", "date": "1610324322", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define width 800.f\n#define height 450.f\n#define numColors 10\n#define numCircles 100\n\nvec3 GetColor(vec2 coord, vec4 circles[numCircles], vec3 colors[numColors], float timeDelay)\n{\n    int value = 0;\n    float r;\n    float xc;\n    float yc;\n    float d = sqrt((coord[0] - xc)*(coord[0]-xc)+(coord[1]-yc)*(coord[1]-yc));\n    for(int i = 0; i < numCircles; i++)\n    {\n        xc = circles[i][0];\n        yc = circles[i][1];\n        r = circles[i][2];\n        d = sqrt((coord[0] - xc)*(coord[0]-xc)+(coord[1]-yc)*(coord[1]-yc));\n        if(d <= r && iTime >= timeDelay * float(i))\n        {\n            value+= int(circles[i][3]);\n        }\n    }\n    return colors[value % numColors];\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord)\n{\n    float timeDelay = 0.05f;\n    float timeFactor = 50.f;\n    vec3 colors[numColors] = vec3[numColors](vec3(0.976, 0.254, 0.266),vec3(0.952, 0.447, 0.172),vec3(0.972, 0.588, 0.117),\\\n    vec3(0.976, 0.517, 0.290),vec3(0.976, 0.780, 0.309),vec3(0.564, 0.745, 0.427),vec3(0.262, 0.666, 0.545),\\\n    vec3(0.301,0.564,0.556),vec3(0.341,0.458,0.564),vec3(0.152,0.490,0.631));\n    float timeInt = 0.f;\n    int i = 0;\n    float xGap = 1.f/11.f;\n    float yGap = 1.f/11.f;\n    vec4 circles[numCircles];\n    for(float y = height * yGap; y < height; y+= height * yGap)\n    {\n        for (float x = width * xGap; x < width; x += width * xGap)\n        {\n            circles[i] = vec4(x, y, iTime * timeFactor - timeFactor * timeDelay * float(i),i+1);\n            i++;\n        }\n    }\n\n    vec3 col = GetColor(fragCoord, circles, colors, timeDelay);\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtGyRz.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[86, 86, 180, 180, 683], [684, 684, 740, 740, 1610]]}
{"id": "wtGyW1", "name": "Calm pleasant nights", "author": "kw", "description": "Experimenting with shapes and colors.", "tags": ["2d"], "likes": 2, "viewed": 67, "published": "Public", "date": "1610927918", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n//calm pleasant nights\n\nfloat Smooth(in float val,in float factor)\n{\n    return smoothstep(factor,-factor,val);//need to lookup true pixels\n}\n\nfloat Circle(in vec2 pos,in float radius)\n{\n    return length(pos) - radius;\n}\n\nfloat Box(in vec2 pos,in vec2 size)//Box - exact: https://www.youtube.com/watch?v=62-pRVZuS5c\n{\n    vec2 d = abs(pos) - size;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\nfloat CatTail(in vec2 pos,in vec2 sca,in vec2 scb,in float ra,in float rb)//Arc - exact: https://www.shadertoy.com/view/wl23RK\n{\n    pos *= mat2(sca.x,sca.y,-sca.y,sca.x);\n    pos.x = abs(pos.x);\n    float k = (scb.y * pos.x > scb.x * pos.y) ? dot(pos.xy,scb):length(pos);\n    return sqrt(dot(pos,pos) + ra * ra - 2.0 * ra * k) - rb;\n}\n\nvec4 Cat(in vec2 pos,in vec3 color,in float factor)\n{\n    float sd = 0.0;\n    float d = 0.0;\n    d = Circle(pos,0.20);\n    d += Circle(pos - vec2( 0.15,-0.15),0.2);\n    d += Circle(pos - vec2( -0.15,-0.15 - (0.3 * sin(iTime + pos.y) / 18.0)),0.2);\n    d = Smooth(d,factor);\n    sd = max(sd,d);\n    d = Circle(pos - vec2(-0.14,0.10),0.12);\n    d += Circle(pos - vec2(-0.14,0.0),0.1);\n    d += Circle(pos - vec2(0.04,0.0),0.1);\n    d = Smooth(d,factor);\n    sd = max(sd,d);\n    d = Circle(pos - vec2(0.14,0.10),0.12);\n    d += Circle(pos - vec2(0.14,0.0),0.1);\n    d += Circle(pos - vec2(-0.04,0.0),0.1);\n    d = Smooth(d,factor);\n    sd = max(sd,d);\n    d = Circle(pos - vec2(-0.1,-0.2),0.28);\n    d += Circle(pos - vec2(0.1,-0.4),0.28);\n    d += Circle(pos - vec2(0.0,-0.6 - (0.1 * sin(iTime + pos.x) / 16.0)),0.26);\n    d -= Circle(pos - vec2(0.1,-0.62),0.32);\n    d = Smooth(d,factor);\n    sd = max(sd,d);\n    float ta = 1.2;\n    float tb = 4.1;\n    float rb = 0.03;\n    d = CatTail(pos - vec2(-0.265,-0.45),vec2(sin(tb * 1.34),cos(tb * 1.1)),vec2(sin(ta),cos(ta)),0.2 + (0.1 * sin(iTime + pos.x) / 40.0),rb);\n    d = Smooth(d,factor / 3.0);\n    sd = max(sd,d);\n    return vec4(color,sd);\n}\n\nvec3 CatColor(in vec2 pos)\n{\n    vec3 color = vec3(0.9,0.3,0.3);\n    color.r += (pos.y + 1.2) + abs((pos.x - 0.3) / 10.0) + (pos.x * 4.0) / 2.0;\n    color.g += ((pos.y - pos.x * 0.2) / 2.0) - abs((pos.y * 2.2) / 4.0);\n    color += 0.2 + pos.y / 20.0;\n    return color;\n}\n\nvec4 CatReflection(in vec2 pos,in float size,in float factor)\n{\n    vec3 color = CatColor(pos) * abs(pos.x - 0.5);\n    float sd = Circle(pos,size);\n    sd = Smooth(sd,factor);\n    return vec4(color,sd);\n}\n\nvec4 Wall(in vec2 pos,in vec2 size,in vec3 color,in float factor)\n{\n    float sd = Box(pos,size);\n    sd = Smooth(sd,factor);\n    return vec4(color,sd);\n}\n\nvec4 Moon(in vec2 pos,in float factor)\n{   vec3 color = vec3(0.8,0.2,0.2);\n    float sd = Smooth(Circle(pos,0.4),factor);\n    color = vec3(1.6,0.45 - abs(((pos.y + pos.x) / 3.0) + 0.2),0.4);\n    return vec4(color,sd);\n}\n\nvec3 Sky(in vec2 uv)\n{\n    return vec3(mix(vec3(0.6,0.2,0.4),vec3(0.2,0.2,0.4),uv.y * 1.2));\n}\n\nvec3 Draw(in vec3 color,in vec4 obj)\n{\n    return mix(color,obj.rgb,obj.a);\n}\n\nvec2 Screen(in vec2 pix,in vec3 res)\n{\n    return vec2((2.0 * pix - res.xy) / res.y);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = Screen(fragCoord,iResolution);\n    vec3 color = Sky(uv);\n    vec4 moon = Moon(uv - vec2(0.6,0.4),0.002);\n    vec4 wall_a = Wall(uv - vec2(0.0,-0.6),vec2(2.0,0.16),vec3(0.8,0.4,0.2),0.4);\n    vec4 wall_b = Wall(uv - vec2(0.0,-0.6),vec2(2.0,0.16),CatColor(uv) * (abs(uv.x) / 2.0),0.002);\n    vec4 wall_c = Wall(uv - vec2(0.0,-0.8),vec2(2.0,0.06),CatColor(uv) * (abs(uv.y) / 6.0),0.002);\n    vec4 cat_fx = CatReflection(uv - vec2(-0.6,-0.548),0.06,0.14);\n    vec4 cat = Cat(uv - vec2(-0.7,-0.2),CatColor(uv),0.002);\n    color = Draw(color,moon);\n    color = Draw(color,wall_a);\n    color = Draw(color,wall_b);\n    color = Draw(color,wall_c);\n    //color = Draw(color,cat_fx);\n    color = Draw(color,cat);\n    fragColor = vec4(color,1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtGyW1.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 25, 69, 69, 142], [144, 144, 187, 187, 222], [224, 224, 319, 319, 406], [408, 408, 536, 536, 743], [745, 745, 798, 798, 1937], [1939, 1939, 1967, 1967, 2209], [2211, 2211, 2274, 2274, 2415], [2417, 2417, 2484, 2484, 2571], [2573, 2573, 2613, 2613, 2792], [2794, 2794, 2816, 2816, 2888], [2890, 2890, 2928, 2928, 2967], [2969, 2969, 3007, 3007, 3056], [3058, 3058, 3115, 3115, 3866]]}
{"id": "wtGyW3", "name": "Mandelbrot deep waves", "author": "rsiqueira", "description": "Mandelbrot waves.\nMoving waves created by changed condition to: tan(Y+sin(X+iTime))<(-3.\nBased on https://www.shadertoy.com/view/wtjGz3\nAnd based on my dwitter fractal: https://www.dwitter.net/d/14589", "tags": ["fractal", "mandelbrot"], "likes": 1, "viewed": 52, "published": "Public", "date": "1611852229", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n   vec2 uv = fragCoord/iResolution.xy;\n\n\tuv.x = uv.x/122.;\n\tuv.y = uv.y/32. - 0.015;\n\n    float pixel_y = uv.y * 100.;\n    float pixel_x = uv.x * 550. - 3.;\n\n    float X = pixel_x;\n    float Y = pixel_y;\n\n\tfor (float k=17.;k>0.;k-=1.) {\n\n\t\tfloat X_new = X*X - Y*Y + pixel_x;\n\t\tfloat Y_new = 2.*X*Y    + pixel_y;\n        X = X_new;\n        Y = Y_new;\n\t\tif (tan(X_new+sin(Y_new+iTime))<(-3.)) {\n\t\t\tfragColor.r=pow(k,3.)/255.;\n            fragColor.g=pow(k,2.)/455.;\n        }\n\t}\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtGyW3.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 536]]}
{"id": "WtGyWt", "name": "Fractal 11_gaz", "author": "gaz", "description": "3d", "tags": ["fractal"], "likes": 6, "viewed": 116, "published": "Public", "date": "1611925083", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define R(p,a,r)mix(a*dot(p,a),p,cos(r))+sin(r)*cross(p,a)\n#define fold(p,v)p-2.*min(0.,dot(p,v))*v;\nvoid mainImage(out vec4 O, vec2 C)\n{\n    O=vec4(0);\n    vec3 r=iResolution,p;\n    float i,g,e=1.,l,s;\n    for(i=0.;\n        ++i<99.&&e>.001;\n        g+=e=length(p.xy)/s\n        )\n    {\n        p=g*vec3((C-.5*r.xy)/r.y,1);\n        p=R(p,normalize(vec3(1)),iTime*.2);\n        p.z-=-1.;\n        p.x-=sin(.4*iTime+.5*sin(iTime*.5))*.2;\n        p.y-=cos(.7*iTime+.5*cos(iTime*.5))*.2;\n        s=3.;\n        for(int i = 0;++i<15;)\n        {\n            p.xy=fold(p.xy,normalize(vec2(1,-1.3)));\n            p.y=-abs(p.y);\n            p.y+=.5;\n            p.xz=abs(p.xz);\n            p.yz=fold(p.yz,normalize(vec2(8,-1)));\n            p.x-=.5;\n            p.yz=fold(p.yz,normalize(vec2(1,-2)));\n            p-=vec3(1.8,.4,.1);\n            l = 2.6/dot(p,p);\n            p*=l;\n            p+=vec3(1.8,.7,.2);\n            s*=l;\n        }\n    }  \n    O.xyz+=mix(vec3(1),cos(vec3(5,18,3)+p*10.),.5)*500./i/i;\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WtGyWt.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[101, 101, 137, 137, 998]]}
{"id": "wtGyz1", "name": "[TWITCH] The descent", "author": "Flopine", "description": "Shader heavily inspired by Mirror's Edge and made during a Twitch stream, you can watch all of them here: https://www.twitch.tv/flopine", "tags": ["raymarching", "modeling", "glow", "ao"], "likes": 16, "viewed": 237, "published": "Public", "date": "1610455922", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Code by Flopine\n\n// Thanks to wsmind, leon, XT95, lsdlive, lamogui, \n// Coyhot, Alkama,YX, NuSan and slerpy for teaching me\n\n// Thanks LJ for giving me the spark :3\n\n// Thanks to the Cookie Collective, which build a cozy and safe environment for me \n// and other to sprout :)  https://twitter.com/CookieDemoparty\n\n\n#define PI acos(-1.)\n// I know it's TAU but I found that typo funny :3\n#define TAY 6.283185\n#define ITER 64.\n\n#define rot(a) mat2(cos(a),sin(a),-sin(a),cos(a))\n#define mo(uv,d)uv=abs(uv)-d;if(uv.y>uv.x)uv=uv.yx;\n#define crep(p,c,l) p=p-c*clamp(round(p/c),-l,l)\n\n#define cyl(p,r,h) max(length(p.xy)-(r),abs(p.z)-h)\n\n#define time iTime\n#define dt(speed) fract(time*speed)\n#define hash21(x) fract(sin(dot(x,vec2(12.4,33.8)))*1247.4)\n\n\n\nstruct obj\n{\n  float d;\n  vec3 color;\n};\n\nobj minobj (obj a, obj b)\n{\n  if (a.d<b.d) return a;\n  else return b;\n}\n\nvoid moda (inout vec2 p, float rep)\n{\n  float per = TAY/rep;\n  float a = mod(atan(p.y,p.x),per)-per*0.5;\n  p = vec2(cos(a),sin(a))*length(p);\n}\n\nfloat box (vec3 p, vec3 c)\n{\n  vec3 q = abs(p)-c;\n  return min(0.,max(q.x,max(q.y,q.z)))+length(max(q,0.));\n}\n\nfloat torus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\nfloat heightmap (vec2 uv)\n{\n  uv = fract(uv)-.5;\n  uv = abs(uv);\n  return smoothstep(0.2,0.27,max(uv.x,uv.y*0.7));\n}\n\nobj tunnel (vec3 p)\n{\n  vec3 pp = p;\n  vec2 tuv = vec2(atan(p.x,p.z)*5.,p.y*0.4);\n  float r;\n  if (tuv.x > -5. && tuv.x < 20.) r = 10.5-heightmap(tuv)*0.15;\n  else r = 10.5;\n  float td = -cyl(p.xzy,r,1e10);\n\n  float per = 10.;\n  float id = floor(p.y/per);\n  p.xz *= rot((TAY/6.)*(id+.5));\n  p.y = mod(p.y,per)-per*0.5;\n  float holes = -cyl(p,1.5,25.);   \n  td = max(holes ,td);\n  p.z = abs(p.z)-10.25;\n  td = min(td,max(holes,cyl(p,1.8,0.3)));\n\n  return obj(td,vec3(1.));\n}\n\nfloat pipe (vec3 p)\n{\n  float pd = cyl(p.xzy,0.2,1e10);\n  float per = 2.;\n  p.y = mod(p.y,per)-per*0.5;\n  pd = min(pd,cyl(p.xzy,0.25,0.1));\n\n  return pd;\n}\n\nobj pipes (vec3 p)\n{\n  moda(p.xz, 6.);\n  p.x -= 9.;\n  crep(p.z,0.7,2.);\n  float psd = pipe(p);\n  return obj(psd,vec3(.7,0.,0.));\n}\n\nfloat g1=0.;\nfloat platform (vec3 p)\n{\n  p.xz *= rot(TAY/6.);\n  float s = length(p)-.5;\n  g1 += 0.1/(0.1+s*s);\n\n  mo(p.xz,vec2(.5));\n  float d = box(p,vec3(10.,0.2,1.5));\n  crep(p.xz,0.4,vec2(30.,4.));\n  d = max(-box(p,vec3(0.2,0.5,0.1)),d);\n  d = min(d,s);\n  return d;\n}\n\nobj platforms (vec3 p)\n{\n  float per = 40.;\n  p.y = mod(p.y-per*0.5,per)-per*0.5;\n  float pld = platform(p);\n  return obj(pld,vec3(0.9,0.1,0.1));\n}\n\nfloat roundpipe (vec3 p)\n{\n  float rpd = torus(p,vec2(10.3,0.2));\n  moda(p.xz,18.);\n  p.x -= 10.3;\n  rpd = min(rpd, cyl(p,0.25,0.1));\n  return rpd;\n}\n\nobj roundpipes (vec3 p)\n{\n  float per = 20.;\n  p.y = mod(p.y,per)-per*0.5;\n  return obj(roundpipe(p),vec3(0.9,0.4,0.));\n}\n\nobj SDF (vec3 p)\n{\n  p.y -= dt(1./5.)*120.;\n  obj so = minobj(tunnel(p),pipes(p)); \n  so = minobj(so,platforms(p));\n  so = minobj(so,roundpipes(p));\n  return so;\n}\n\nvec3 getcam (vec3 ro, vec3 ta, vec2 uv)\n{\n  vec3 f = normalize(ta-ro);\n  vec3 l = normalize(cross(vec3(0.,1.,0.),f));\n  vec3 u = normalize(cross(f,l));\n  return f + l*uv.x + u*uv.y;\n}\n\nvec3 getnorm (vec3 p)\n{\n  vec2 eps = vec2(0.01,0.);\n  return normalize(SDF(p).d-vec3(SDF(p-eps.xyy).d,SDF(p-eps.yxy).d,SDF(p-eps.yyx).d));\n}\n\nfloat AO (float eps,vec3 n, vec3 p)\n{return SDF(p+eps*n).d/eps;}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  vec2 uv = (2.*fragCoord.xy-iResolution.xy)/iResolution.y;\n\n  float dither = hash21(uv);\n  vec3 ro = vec3(0.3,0.01,-6.), rd=getcam(ro,vec3(.5,-7.,0.),uv),p=ro, col=vec3(0.);\n  float shad; bool hit=false; obj O;\n\n  for(float i =0.; i<ITER; i++)\n  {\n    O = SDF(p);\n    if (O.d<0.0001)\n    {\n      hit=true; shad=i/ITER; break;\n    }\n    O.d *= 0.5+dither*0.05;\n    p += rd*O.d;\n  }\n\n  float t = length(ro-p);\n  if(hit)\n  {\n    vec3 n = getnorm(p);\n    float ao = AO(0.1,n,p) + AO(0.4,n,p) + AO(0.5,n,p);\n    col = O.color;\n    col *= (1.-shad);\n    col *= ao/3.;\n  }\n  col = mix(col,vec3(0.,0.05,0.1),1.-exp(-0.001*t*t));\n  col += g1*vec3(0.1,0.8,0.2)*0.8;\n  \n  fragColor = vec4(sqrt(col),1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtGyz1.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[339, 793, 820, 820, 864], [866, 866, 903, 903, 1009], [1011, 1011, 1039, 1039, 1120], [1122, 1122, 1153, 1153, 1218], [1220, 1220, 1247, 1247, 1336], [1338, 1338, 1359, 1359, 1811], [1813, 1813, 1834, 1834, 1968], [1970, 1970, 1990, 1990, 2100], [2115, 2115, 2140, 2140, 2373], [2375, 2375, 2399, 2399, 2522], [2524, 2524, 2550, 2550, 2673], [2675, 2675, 2700, 2700, 2796], [2798, 2798, 2816, 2816, 2961], [2963, 2963, 3004, 3004, 3146], [3148, 3148, 3171, 3171, 3288], [3290, 3290, 3327, 3327, 3354], [3356, 3356, 3412, 3412, 4108]]}
{"id": "wtGyzc", "name": "Fractal tile mosaic", "author": "jarble", "description": "A simple fractal formula.", "tags": ["fractal", "tile", "mosaic"], "likes": 6, "viewed": 166, "published": "Public API", "date": "1611428983", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float fract1(float a){\n    return (abs(fract(a/2.0)-.5))*2.0;\n}\n\nvec2 fract1(vec2 a){\n    return (abs(fract(a/2.0)-.5))*2.0;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.0);\n    vec3 col;\n    float t;\n    \n    for(int c=0;c<3;c++){\n\t    \n        vec2 uv = (fragCoord*40.0-iResolution.xy)/iResolution.y/10.0;\n        uv += vec2(iTime/2.0,iTime/8.0)/2.0;\n        t = iTime+float(c)/10.;\n        float scale = 5.5;\n        float scale1 = 2.0;\n        for(int i=0;i<3;i++)\n        {\n            uv = (fract1(uv/scale1)+fract1(uv/scale/2.0))*scale1;\n            uv= fract1(uv/(2.0-fract1((uv.x-uv.y)/(8.0)))-(uv/(1.7+(fract1(uv.x+uv.y))))/scale)*scale/scale1+scale1*scale;\n            uv /= scale1+col.yx;\n        \tuv=uv.yx+col.xy;\n        }\n     col[c] = abs(fract(uv.y)-fract(uv.x));\n\t}\n    \n    fragColor = vec4(vec3(col),1.0);\n    \n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtGyzc.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 22, 22, 63], [65, 65, 85, 85, 126], [128, 128, 185, 185, 871]]}
{"id": "wtGyzV", "name": "Vibrant Cubes", "author": "Kamoshika", "description": "two and a half hours live coding", "tags": ["raymarching"], "likes": 12, "viewed": 222, "published": "Public", "date": "1611333969", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define rand(x) fract(sin(x)*43758.5453)\n\nconst float pi = acos(-1.);\nconst float pi2 = pi*2.;\n\nfloat rand2(vec2 p) {\n  return rand(dot(p, vec2(24.1214, 15.2321)));\n}\n\nfloat rand3(vec3 p) {\n  return rand(dot(p, vec3(24.1214, 15.2321, 21.2362)));\n}\n\nmat2 rotate(float a) {\n  return mat2(cos(a), -sin(a), sin(a), cos(a));\n}\n\nvec2 pmod(vec2 p, float n) {\n  float a = pi2 / n;\n  float theta = atan(p.y, p.x) + .5*a;\n  theta = floor(theta/a)*a;\n  return p*rotate(-theta);\n}\n\nvec3 hsv2rgb(float h, float s, float v) {\n  vec3 res = fract(h+vec3(0,2,1)/3.);\n  res = abs(res*6.-3.)-1.;\n  res = clamp(res, 0., 1.);\n  res = (res-1.)*s+1.;\n  res *= v;\n  return res;\n}\n\nfloat interval_xy = 10.;\nfloat interval_z = 5.;\nfloat dist1(vec3 p) {\n  vec3 z = p;\n  vec2 id = floor(z.xy/interval_xy);\n  \n  z.z -= fract(iTime)*10.;\n  z.xy = mod(z.xy, interval_xy) - .5*interval_xy;\n  z.xy *= rotate(floor(z.z/interval_z)*.2 + iTime);\n  z.z = mod(z.z, interval_z) - .5*interval_z;\n  \n  float r1 = rand2(id+floor(iTime)*.1);\n  z.xy = pmod(z.xy, floor(r1*8.+3.));\n  z.x -= 1.5;\n\n  return length(max(abs(z)-vec3(.5), 0.));\n}\n\nfloat dist2(vec3 p) {\n  vec3 z = p;\n  z = abs(z)-.25;\n  z *= 2.;\n  z = abs(z)-.25;\n  z *= 2.;\n  \n  float size = .5+pow(sin(iTime*10.)*.5+.5, 5.);\n  size *= .5;\n  return length(max(abs(z)-vec3(size), 0.))/4.;\n}\n\nvec3 calcNormal1(vec3 p, float eps) {\n  vec2 e = vec2(0, eps);\n  return normalize(vec3(dist1(p+e.yxx)-dist1(p-e.yxx),\n  dist1(p+e.xyx)-dist1(p-e.xyx),\n  dist1(p+e.xxy)-dist1(p-e.xxy)));\n}\n\nvec3 calcNormal2(vec3 p, float eps) {\n  vec2 e = vec2(0, eps);\n  return normalize(vec3(dist2(p+e.yxx)-dist2(p-e.yxx),\n  dist2(p+e.xyx)-dist2(p-e.xyx),\n  dist2(p+e.xxy)-dist2(p-e.xxy)));\n}\n\nfloat exp2Fog(float dist, float density) {\n  float s = dist*density;\n  return exp(-s*s);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n  vec2 p = (fragCoord*2.-iResolution.xy) / min(iResolution.x, iResolution.y);\n  vec3 col = vec3(0);\n  \n  float c = iTime;\n  float L = 1.-fract(c);\n  float id = ceil(c);\n  for(int i=0; i<10; i++) {\n    float a = atan(.7, L)*3.;\n    vec2 z = p/a;\n    float r1 = rand(id);\n    float r2 = rand(id+20.);\n    z = pmod(z, floor(r1*10.+3.));\n    z.x += -1.;\n    z *= rotate(iTime*.5+pi2/20.*id);\n    z = pmod(z, floor(r1*8.+3.));\n    z.x += -1.;\n    z = pmod(z, floor(r1*8.+3.));\n    col += .005/abs(z.x-.5)*hsv2rgb(r2, 1., 1.);\n    L++;\n    id++;\n  }\n  \n  vec3 cPos = vec3(0, 0, 5.);\n  vec3 cDir = vec3(0, 0, -1);\n  vec3 cUp = vec3(0, 1, 0);\n  cUp.xy *= rotate(iTime*.1);\n  vec3 cSide = cross(cDir, cUp);\n  vec3 ray = normalize(p.x*cSide + p.y*cUp + cDir*2.5);\n  \n  float d = 0.;\n  vec3 rPos = cPos;\n  for(int i=0; i<100; i++) {\n    d = dist1(rPos);\n    if(d<0.001) {\n      break;\n    }\n    rPos += ray*d;\n  }\n  \n  if(d<0.1) {\n    vec3 normal = calcNormal1(rPos, 0.0001);\n    vec3 normal2 = calcNormal1(rPos, 0.1);\n    float edge = clamp(length(normal-normal2), 0., 1.);\n    vec2 id = floor(rPos.xy/interval_xy);\n    float r1 = rand2(id+floor(iTime)*.1);\n    float fog = exp2Fog(length(rPos-cPos), 0.01);\n    col = mix(col, hsv2rgb(r1, 1., 1.)*edge, fog);\n  }\n  \n  cPos.zx *= rotate(.5);\n  cPos.yz *= rotate(iTime);\n  cDir = normalize(-cPos);\n  vec3 up = vec3(0, 1, 0);\n  cSide = normalize(cross(cDir, up));\n  cUp = normalize(cross(cSide, cDir));\n  ray = normalize(p.x*cSide + p.y*cUp + cDir*2.5);\n  \n  d = 0.;\n  rPos = cPos;\n  for(int i=0; i<30; i++) {\n    d = dist2(rPos);\n    if(d<0.0001 || length(rPos-cPos) > 10.) {\n      break;\n    }\n    rPos += ray*d;\n  }\n  \n  vec3 lightDir = normalize(vec3(1));\n  if(d<0.1) {\n    vec3 normal = calcNormal2(rPos, 0.0001);\n    vec3 normal2 = calcNormal2(rPos, 0.01);\n    float edge = clamp(length(normal-normal2)*1.5, 0., 1.);\n    vec3 id = floor(rPos*4.);\n    float diff = max(dot(lightDir, normal), .0);\n    float r1 = rand3(id+floor(iTime*10.)*.1);\n    col = hsv2rgb(r1, diff*.5+.5, 1.)*(1.-edge);\n  }\n  \n  fragColor = vec4(col, 1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtGyzV.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[96, 96, 117, 117, 166], [168, 168, 189, 189, 247], [249, 249, 271, 271, 321], [323, 323, 351, 351, 468], [470, 470, 511, 511, 655], [705, 705, 726, 726, 1096], [1098, 1098, 1119, 1119, 1307], [1309, 1309, 1346, 1346, 1496], [1498, 1498, 1535, 1535, 1685], [1687, 1687, 1729, 1729, 1777], [1779, 1779, 1836, 1836, 3908]]}
{"id": "WtKcDV", "name": "Fractal 02_gaz", "author": "gaz", "description": "3d", "tags": ["fractal"], "likes": 5, "viewed": 66, "published": "Public", "date": "1611803841", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define sabs(p) sqrt((p)*(p)+.8)\nvoid sfold90(inout vec2 p)\n{\n    p=(p.x+p.y+vec2(1,-1)*sabs(p.x-p.y))*.5;\n}\n\nfloat Scale;\n\nfloat map(vec3 p)\n{\n\tp=mod(p-1.5,3.)-1.5;\n\tp=abs(p)-1.3;\n\tsfold90(p.xz);\n\tsfold90(p.xz);\n\tsfold90(p.xz);\n\t\n\tfloat s=1.;\n\tp-=vec3(.5,-.3,1.5);\n\tfor(float i=0.;i++<7.;)\n    {\n\t\tfloat r2=2.1/clamp(dot(p,p),.0,1.);\n\t\tp=abs(p)*r2;\n\t\tp-=vec3(.1,.5,7.);\n\t\ts*=r2;\n\t}\n\tScale=log2(s);\n    float a=3.;\n    p-=clamp(p,-a,a);\n    return length(p)/s-.005;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv=(2.*fragCoord-iResolution.xy)/iResolution.y;\n\tvec3 p,\n  \t\tro=vec3(0,0,iTime),\n  \t\tw=normalize(vec3(.3*sin(iTime*.5),.5,1)),\n  \t\tu=normalize(cross(w,vec3(cos(iTime*.1),sin(iTime*.1),0))),\n  \t\trd=mat3(u,cross(u,w),w)*normalize(vec3(uv,2));\n\tfloat h=0.,d,i;\n\tfor(i=1.;i<80.;i++)\n    {\n    \tp=ro+rd*h;\n\t\td=map(p);\n    \tif(d<.001)break;\n    \th+=d;\n\t}\n\tfragColor.xyz=15.*vec3(sin(Scale*.7+p.xyx*.28)*.5+.5)/i;\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WtKcDV.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[33, 33, 61, 61, 108], [124, 124, 143, 143, 467], [469, 469, 526, 526, 941]]}
{"id": "wtKcRc", "name": "Fractal tile mosaic 2", "author": "jarble", "description": "A simple fractal formula.", "tags": ["fractal", "tile", "mosaic"], "likes": 6, "viewed": 195, "published": "Public API", "date": "1611504587", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//change these parameters to get different tile patterns.\n#define scale 5.5\n#define scale1 2.0\n#define scale2 2.0\n#define scale3 8.0\n#define ITERATIONS 6\n\n/*\n#define scale1 1.5\n#define scale2 4.0\n#define scale3 8.0\n#define ITERATIONS 3\n*/\n\nfloat fract1(float a){\n    return (abs(fract(a/2.0)-.5))*2.0;\n}\n\nvec2 fract1(vec2 a){\n    return (abs(fract(a/2.0)-.5))*2.0;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.0);\n    vec3 col;\n    for(int c=0;c<3;c++){\n        vec2 uv = (fragCoord*20.0-iResolution.xy)/iResolution.y/10.0;\n        uv += vec2(iTime/3.0,iTime/8.0)/2.0;\n        for(int i=0;i<ITERATIONS;i++)\n        {\n            uv = (fract1(uv/scale2)+fract1(uv/scale3/2.0))*scale1;\n            uv= fract1(uv/(2.0-fract1((uv.x-uv.y)/(8.0)))-(uv/(1.7+(fract1(uv.x+uv.y))))/scale)*scale/scale1+scale1*scale;\n            uv /= scale1+col.yx;\n        \tuv=uv.yx+col.xy;\n        }\n     col[c] = abs(fract(uv.y)-fract(uv.x));\n\t}\n    \n    fragColor = vec4(col,1.0);\n    \n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtKcRc.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[155, 240, 262, 262, 303], [305, 305, 325, 325, 366], [368, 368, 425, 425, 1004]]}
{"id": "wtKcRR", "name": "Jonix Smileys rectangle", "author": "Hultsborn10", "description": "Learning shadertoy: A few smileys and a rectangle. Functions for circle and rectangle.", "tags": ["circle", "rectangle", "smiley"], "likes": 3, "viewed": 176, "published": "Public API", "date": "1610379111", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float Circle(vec2 uv, vec2 p, float r, float blur){\n    float d = length(uv - p);\n    float c = smoothstep(r, r - blur,d);\n    return c;\n}\n\nfloat Band(float t, float start, float end, float blur)\n{\n    float step1 = smoothstep(start - blur,start + blur,t);   \n    float step2 = smoothstep(end + blur,end - blur,t);   \n    return step1 * step2;\n}\n\nfloat Rect(vec2 uv, float left, float right, float bottom, float top, float blur) \n{\n    float band1 = Band(uv.x, left, right, blur);\n    float band2 = Band(uv.y, bottom, top, blur);\n    return band1 * band2;\n}\n\nfloat Smiley(vec2 uv, vec2 p, float size)\n{\n    uv -= p; //Translate coordinate system\n    uv /= size; //Scale coordinate system\n    //face\n    float c = Circle(uv, vec2(0.0,0.0), 0.4, 0.02);\n    //mouth\n    c -= Circle(uv, vec2(0.0, -0.1), 0.2, 0.01);\n    c += Circle(uv, vec2(0.0, 0.0), 0.2, 0.01);\n    c = clamp(c,0.0,1.0);\n    //eyes\n    c -= Circle(uv, vec2(0.15, 0.1), 0.1, 0.01);\n    c -= Circle(uv, vec2(-0.15,0.1), 0.1, 0.01);\n    \n    return c;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord.xy/iResolution.xy;\n    uv -= 0.5; //-0.5 <> 0.5\n    uv.x *= iResolution.x/iResolution.y;\n    \n    vec3 col = vec3(0.0);\n    \n    float c = Smiley(uv, vec2(0.5,0.3), abs(0.5*sin(iTime)));\n    for(int i = 0; i<9; i++)\n    {\n        float x = float(i % 3);\n        float y = float(i / 3);\n        c += Smiley(uv, vec2(0.3*x-0.4,0.2*y-0.3), abs(0.2*cos(iTime+float(i)/9.0)));\n    }\n    c += Rect(uv, 0.4, 0.8, -0.4, -0.1, abs(0.1*cos(0.5*iTime)));   \n    col = vec3(1.0, 1.0, .0)*c;\n    \n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtKcRR.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 51, 51, 138], [140, 140, 197, 197, 345], [347, 347, 431, 431, 557], [559, 559, 602, 602, 1015], [1017, 1017, 1074, 1124, 1694]]}
{"id": "WtKcW3", "name": "cubesInASphere", "author": "polyomino", "description": "adapted from an old pixel bender in Flash", "tags": ["cubes"], "likes": 3, "viewed": 38, "published": "Public", "date": "1611874090", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// adapted from an old Pixel Bender pbk i had lying around...\nvec3 xAxisColor = vec3(1,.3,.4);\nvec3 yAxisColor = vec3(.3, .8,.4);\nvec3 zAxisColor = vec3(.1,.3,1);\nvec3 edgeColor = vec3(.1,.3,1);\n    \n float edgeThickness = 0.05;     \nfloat invert = 1.0;    \nvec2 dstsize = vec2(300.0, 300.0);\nvec3 spin = vec3(.1,.02,.3);\n\n\nfloat plunge = -0.0;\n\nfloat cellDensity = 3.0;\nfloat radius = 0.5;\n\n// evaluatePixel(): The function of the filter that actually does the \n//                  processing of the image.  This function is called once \n//                  for each pixel of the output image.\nvec4\nevaluatePixel(vec2 fragCoord)\n{\n    spin.x = iTime / 5.123;\n    spin.y = iTime / 117.2;\n    cellDensity = 8.0 + sin(iTime / 14.4) * 7.0;\n    dstsize = iResolution.xy;\n    vec3 axis1 = vec3(1.0,0.0,0.0);\n    vec3 axis2 = vec3(0.0,1.0,0.0);\n\n    mat3 elevR = mat3(1,0,0,0,cos(spin.x),sin(spin.x),0,-sin(spin.x),cos(spin.x));\n    mat3 bearR = mat3(cos(spin.y), sin(spin.y), 0,-sin(spin.y), cos(spin.y), 0, 0, 0, 1 );\n    mat3 yamR = mat3(cos(spin.z),0,sin(spin.z),0,1,0,-sin(spin.z),0,cos(spin.z));\n\n    axis1 *= elevR * bearR * yamR;\n    axis2 *= elevR * bearR * yamR;\n\n    float cellDensity2 = cellDensity / 2000.0;\n    vec2 oc = (fragCoord - dstsize / 2.0) * cellDensity2;\n\n    //oc -= outSize/2.0;\n    vec3 p = oc.x * axis1 + oc.y * axis2;\n\n\n    vec3 perp = cross(axis1,axis2);\n\n    float radiusInPixels = radius *  dstsize.x;\n    float plungeMore = radiusInPixels * radiusInPixels * cellDensity2 * cellDensity2 - oc.x * oc.x - oc.y * oc.y;\n    if(plungeMore < 0.0)\n        plungeMore = 0.0;\n    plungeMore = sqrt(plungeMore);\n\n    // Strangely, PBT and Flash have opposite senses here.\n    // Some sort of arithmetic bug, probably, making them\n    // behave differently.\n    if(invert > 0.0)\n        plungeMore = -plungeMore;\n\n    p += (plunge - plungeMore) * perp;\n\n\n    vec3 pCell = floor(p);\n\n\n    p = mod(p,1.0);\n\n    /*\n    Our cell size, here, is 1x1x1. Perp is a unit vector representing\n    the direction we're now looking, the ray cast if you will. We like\n    to cast to the planes x=0, y=0, z=0, because it's easy. So first\n    we'll see if each element of perp is negative, and, if so, flip\n    it and reposition our starting point, like p.x := 1-p.x.\n    */\n\n    /* this is the cleanest way, but Flash doesn't allow bools,\n       and ?: doesn't seem to work in this mixed-dimension way\n       either\n\n    bool3 perpNeg = lessThan(perp,vec3(0,0,0));\n    p = perpNeg ? 1.0 - p : p;\n    perp = abs(perp);\n    */\n\n    /* We can be clever with step and abs, though. */\n    vec3 perpStep = 1.0 - step(0.0,perp);\n    p = perpStep - p;\n    p = abs(p);\n    perp = abs(perp);\n\n\n    vec3 t = p / perp; // casts from p, in direction of perp, to zero. T is how far to each plane (x,y, or z)\n    vec3 co = vec3(0,0,0);\n    float z;\n\n    if(t.x >= 0.0)\n    {\n        co = xAxisColor;\n        z = t.x;\n    }\n    if(t.y >= 0.0 && t.y < t.x)\n    {\n        co = yAxisColor;\n        z = t.y;\n    }\n    if(t.z >= 0.0 && t.z < t.x && t.z < t.y)\n    {\n        co = zAxisColor;\n        z = t.z;\n    }\n\n    vec4 dst;\n    dst.rgb = co * (1.0 - z/1.2);\n    dst.a = 1.0;\n\n    if(t.x < edgeThickness || t.y < edgeThickness || t.z < edgeThickness)\n        dst.rgb = edgeColor;\n\n    if(plungeMore == 0.0)\n        dst.xyz *= 0.0;\n    return dst;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Time varying pixel color\n    vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n    \n    fragColor = evaluatePixel(fragCoord);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WtKcW3.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[392, 595, 631, 631, 3330], [3332, 3332, 3389, 3439, 3673]]}
{"id": "WtKcWm", "name": "3D Sinusoid", "author": "darkeclipz", "description": "Flying through f = sin x + sin y + sin z.", "tags": ["raymarch", "cube", "sin", "hsv"], "likes": 9, "viewed": 278, "published": "Public API", "date": "1611148077", "time_retrieved": "2021-10-01T00:00:00", "image_code": "mat2 rotate(float a) {\n    float si = sin(a), co = cos(a);\n    return mat2(co, si, -si, co);\n}\n\nvec3 hsv2rgb(vec3 c) {\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nfloat sdBox(vec3 p, vec3 b) {\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nvec3 id = vec3(0);\nfloat map(in vec3 p) {\n    float scale = 40.;\n    p *= scale;\n    vec3 pmod = mod(p, 2.0) - 1.; \n    vec3 pint = p - pmod;\n    id = pint;\n    float period = 6.;\n    float t = (iTime + 9.24) * 2.;\n    float size = (sin(period*pint.x + t) \n               +  sin(period*pint.y + t) \n               +  sin(period*pint.z)) \n               * 0.5;\n    float roundness = 0.05;\n    pmod.xz *= rotate(size);\n    float sizeBox = size * 2. * (0.5 - roundness);\n    float box = sdBox(pmod, vec3(sizeBox)*.5) - roundness;\n    return box/scale;\n\n}\n\n#define MIN_MARCH_DIST 0.0001\n#define MAX_MARCH_DIST 40.\n#define MAX_MARCH_STEPS 60.\nfloat march(in vec3 ro, in vec3 rd) {\n    float t = 0.4, // don't render too close to camera\n          i = 0.;\n    for(i=0.; i < MAX_MARCH_STEPS; i++) {\n        vec3 p = ro + t*rd;\n        float d = map(p);\n        if(abs(d) < MIN_MARCH_DIST)\n            break;\n        t += d;\n        if(t > MAX_MARCH_DIST)\n            break;\n    }\n    if(i >= MAX_MARCH_STEPS) {\n        t = MAX_MARCH_DIST;\n    }\n    return t;\n}\n\nvec3 normal(in vec3 p) {\n    float eps = MIN_MARCH_DIST;\n    vec2 h = vec2(eps, 0);\n    return normalize(vec3(map(p+h.xyy) - map(p-h.xyy),\n                          map(p+h.yxy) - map(p-h.yxy),\n                          map(p+h.yyx) - map(p-h.yyx)));\n}\n\nfloat G1V(float dotNV, float k) {\n    return 1.0 / (dotNV * (1.0 - k) + k);\n}\n\n// http://filmicworlds.com/blog/optimizing-ggx-shaders-with-dotlh/\nfloat brdf_ggx(vec3 N, vec3 V, vec3 L, float roughness, float F0) {\n    float alpha = roughness * roughness;\n    vec3 H = normalize(V+L);\n    float dotNL = clamp(dot(N,L), 0., 1.);\n    float dotNV = clamp(dot(N,V), 0., 1.);\n    float dotNH = clamp(dot(N,H), 0., 1.);\n    float dotLH = clamp(dot(L,H), 0., 1.);\n    float alphaSqr = alpha*alpha;\n    float pi = 3.14159;\n    float denom = dotNH * dotNH * (alphaSqr - 1.0) + 1.0;\n    float D = alphaSqr / (pi * denom * denom);\n    float dotLH5 = pow(1.0 - dotLH, 5.0);\n    float F = F0 + (1.0 - F0) * dotLH5;\n    float k = alpha / 2.0;\n    float vis = G1V(dotNL, k) * G1V(dotNV, k);\n    return dotNL * D * F * vis;\n}\n\nvec3 shade(vec3 N, vec3 L, vec3 V, vec3 diffuse, vec3 specular) {\n    return diffuse * clamp(dot(L, N), 0., 1.)       // Lambertian Diffuse\n         + specular * brdf_ggx(N, V, L, 0.55, 0.1); // GGX Specular\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - 0.5*iResolution.xy)/iResolution.y;\n    \n    // Camera\n    vec3 ro = vec3(0,0,-1.);\n    vec3 ta = vec3(0,0,0);\n    vec3 ww = normalize(ta-ro);\n    vec3 uu = normalize(cross(ww, vec3(0,1,0)));\n    vec3 vv = normalize(cross(uu,ww));\n    vec3 rd = normalize(uv.x*uu + uv.y*vv + 1.0*ww);\n    float time = (iTime + 9.24) * 0.1;\n    rd.zx *= rotate(time);\n    ro.z += time;\n    ro.y += time;\n    \n    // March\n    float t = march(ro, rd);\n    \n    // Shade\n    vec3 col = vec3(0);\n    if(t < MAX_MARCH_DIST) {\n        vec3 P = ro + t*rd;             \n        vec3 N = normal(P);                \n        vec3 V = normalize(ro - P); \n        vec3 ambient = vec3(.06);\n        vec3 diffuse = hsv2rgb(vec3(fract(length(id) / 80. + time * 0.2), 1., 1.));\n        vec3 specular = vec3(.9);      \n        vec3 tangent = cross(V, vec3(0,1,0));\n        col =       shade(N, normalize(ro-P+tangent*0.03), V, diffuse, specular)\n            + 0.3 * shade(N, normalize(P-ro+tangent*0.2), V, diffuse, specular)  \n            + ambient;                                               \n        col *= clamp(exp(-0.20*(t-0.2)), 0., 1.);                       \n    }\n    \n    fragColor = vec4(pow(col, vec3(2.2)),1.0); // Gamma correction\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WtKcWm.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 22, 22, 94], [96, 96, 118, 118, 287], [289, 289, 318, 318, 405], [426, 426, 448, 448, 958], [1045, 1045, 1082, 1082, 1459], [1461, 1461, 1485, 1485, 1713], [1715, 1715, 1748, 1748, 1792], [1794, 1861, 1928, 1928, 2523], [2525, 2525, 2590, 2590, 2734], [2736, 2736, 2793, 2793, 4035]]}
{"id": "wtKcWV", "name": "Fractal 08_gaz", "author": "gaz", "description": "3d", "tags": ["fractal"], "likes": 16, "viewed": 156, "published": "Public", "date": "1611828045", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define R(a)mat2(cos(a),sin(a),-sin(a),cos(a))\nvoid mainImage(out vec4 O, vec2 C)\n{\n    O=vec4(0);\n    float i,g,e,s,B=2.;\n    for(vec3 r=iResolution,p;\n        ++i<99.;\n        e<.001?O+=.5/i:O\n        )\n    {\n        p=vec3(g*(C.xy-.5*r.xy)/r.y,g-22.);\n        p.xy*=R(iTime*.5);\n        p.xz*=R(iTime*.5);\n        s=2.;\n        for(int j=0;j++<10;)\n        {\n            p=abs(p),\n            p.y<p.z?p.yz=p.zy:p.yz;\n            p.x<p.z?p.xz=p.zx:p.xz;\n            p.x=abs(p.x)-5.;\n            p.y=abs(p.y)-5.;\n            p.z=abs(p.z)+5.;\n            p*=B;\n            s*=B;\n        }\n        p-=s;\n        g+=e=length(p)/s-.01;\n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtKcWV.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[47, 47, 83, 83, 640]]}
{"id": "wtKczt", "name": "Zebra 2", "author": "vegardno", "description": "asdf", "tags": ["asdf"], "likes": 6, "viewed": 58, "published": "Public", "date": "1611607622", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - .5 * iResolution.xy) / iResolution.y;\n    uv *= 20.;\n\n    float x = 0.;\n    for (int i = 0; i < 10; ++i) {\n        float t = float(i) * iTime / 20.;\n        x += cos(cos(t) * radians(360.) * uv.y + sin(t) * radians(360.) * uv.x);\n    }\n   \n    vec3 col = vec3(1.) * (.5 + .5 * x);\n    fragColor = vec4(col, 1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtKczt.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 398]]}
{"id": "wtKyDm", "name": "dissolve and disappear", "author": "YitingLiu", "description": "Creating glitch effect with dissolve impact. ", "tags": ["mouse", "grid", "time", "sin", "color", "random", "cos", "rgb", "pattern", "fract", "step", "clamp", "offset", "tan", "fpos", "ipos", "atn"], "likes": 4, "viewed": 226, "published": "Public API", "date": "1611165407", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// inspiration code: https://thebookofshaders.com/edit.php#10/ikeda-03.frag\n// learned changeblae resolution size, fract, atan, patterns, and randoms ; used clamp, mouse\n\nfloat random (in float x) {\n    return fract(sin(x)*1e4);\n}\n\nfloat random (in vec2 st) {\n    return fract(sin(dot(st.xy, vec2(12.9898,78.233)))* 43758.5453123);\n}\n\nfloat pattern(vec2 st, vec2 v, float t) {\n    vec2 p = floor(st+v);\n    return step(t, random(100.+p*.000001)+random(p.x)*0.8 );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n {\n //   vec2 st = fragCoord.xy/iResolution.xy;\n   vec2 st = (1.0 * fragCoord.xy - iResolution.xy) / min(iResolution.y, iResolution.x);\n   st.x *= iResolution.x/iResolution.y;\n\n    vec2 grid = vec2(100.0,50.);\n    st *= grid;\n\n    vec2 ipos = floor(st);  // integer\n    vec2 fpos = fract(st);  // fraction\n\n    vec2 vel = vec2(iTime*2.*min(grid.x,grid.y)); // time\n    vel *= vec2(1.)*sin(iTime)/1e4 * random(0.+max(ipos.x,ipos.y)); // direction\n\n    // Assign a random value base on the integer coord\n    vec2 offset = vec2(random(st),random(st*1e3)) ;\n    offset+=iTime/1e3;\n  \n    vec3 color = vec3(0.880,0.354,0.201);\n    color.r = pattern(st+offset,vel,0.5+iMouse.x/iResolution.x);\n    color.g = pattern(st,vel,0.5+iMouse.x/iResolution.x);\n    color.b = pattern(st-offset,vel,0.5+iMouse.x/iResolution.x);\n\n    // Margins\n    color /= step(sin(iTime*1.5),max(fpos.x,fpos.y));\n\n    fragColor = vec4(1.0-color*random(st)*1e3,clamp(abs(sin(iTime)), 0.8,1.0));\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtKyDm.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 171, 198, 198, 230], [232, 232, 259, 259, 333], [335, 335, 376, 376, 465], [467, 467, 525, 570, 1485]]}
{"id": "wtKyWc", "name": "Tally Hall Good & Evil", "author": "tasco", "description": "https://en.wikipedia.org/wiki/Good_%26_Evil_(album)", "tags": ["tallyhall"], "likes": 4, "viewed": 62, "published": "Public", "date": "1611912568", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const float pi = 3.1415926535897932384626433;\nconst vec2 c = vec2(0.5,0.5);\nconst mat2 mat = mat2(.5,.5,\n\t\t\t\t\t\t-.5,.5);\nconst mat2 negmat = mat2(1.,-1.,\n\t\t\t\t\t\t1.,1.);\nconst vec4 white = vec4(1,1,1,1);\nconst vec4 gray = vec4(.5,.5,.5,1);\nconst vec4 black = vec4(0,0,0,1);\n\nvec4 coordtester(vec2 xy) {\n\tfloat r = .001;\n\tvec2 p1 = vec2(0,0);\n\tvec2 p2 = vec2(1,1);\n\tvec2 diff1 = xy - p1;\n\tvec2 diff2 = xy - p2;\n\tfloat len1 = dot(diff1,diff1);\n\tfloat len2 = dot(diff2,diff2);\n\tif (len1 < r)\n\t{\n\t\treturn black;\n\t}\n\tif (len2 < r) {\n\t\treturn gray;\n\t}\n\treturn white;\n}\n\nvec2 getUV()\n{\n\tbool HeightIsGreater = iResolution.y > iResolution.x;\n\tfloat mindim = HeightIsGreater ? iResolution.x : iResolution.y;\n\tfloat resdiff = HeightIsGreater ? iResolution.y - iResolution.x : iResolution.x - iResolution.y;\n\tvec2 uv = gl_FragCoord.xy/mindim;\n\tif (HeightIsGreater)\n\t{\n\t\tuv.y-=.5*resdiff/( iResolution.x);\n\t}\n\telse\n\t{\n\t\tuv.x-=.5*resdiff/(iResolution.y);\n\t}\n\treturn uv - c;\n}\n\nfloat ptx(float x) {\n\treturn (x / 3733.) - .5;\n}\n\nfloat pty(int y) {\n\treturn ((float(3704 - y)) / 3704.) - .5;\n}\n\nvec2 pt(int x, int y) {\n\treturn vec2(ptx(float(x)),pty(y));\n\t//return vec2( float(x) / 3733., (float(3704 - y)) / 3704.) - c;\n}\n\nvec2 pt(float x, int y) {\n\treturn vec2(ptx(x),pty(y));\n\t//return vec2( x / 3733., (float(3704 - y)) / 3704.) - c;\n}\n\nbool enclose_tlbr(vec2 tl, vec2 br, vec2 uv) {\n\treturn (tl.x < uv.x && uv.x < br.x && tl.y > uv.y && uv.y > br.y);\n}\n\nbool enclose_trbl(vec2 tr, vec2 bl, vec2 uv) {\n\treturn (bl.x < uv.x && uv.x < tr.x && tr.y > uv.y && uv.y > bl.y);\n}\n\nbool above(vec2 p1, vec2 p2, vec2 uv) {\n\tfloat r = (uv.x - p1.x) / (p2.x - p1.x);\n\tfloat h = r * (p2.y - p1.y) + p1.y;\n\treturn uv.y > h;\n}\n\nbool below(vec2 p1, vec2 p2, vec2 uv) {\n\tfloat r = (uv.x - p1.x) / (p2.x - p1.x);\n\tfloat h = r * (p2.y - p1.y) + p1.y;\n\treturn uv.y < h;\n}\n\nbool T(vec2 uv) {\n\tvec2 tlt = pt(400,92);\n\tvec2 brt = pt(602,135);\n\tvec2 tlb = pt(475,135);\n\tvec2 brb = pt(527,340);\n\treturn enclose_tlbr(tlt,brt,uv) || enclose_tlbr(tlb,brb,uv);\n}\n\nbool A(int b, int l, vec2 uv) {\n\tvec2 itl = pt(b, l - 340 + 92);\n\tvec2 ibr = pt(b - 587 + 822,l);\n\tif (!enclose_tlbr(itl,ibr,uv)) return false;\n\tvec2 bll = pt(b,l);\n\tvec2 blr = pt(b-587+642,l);\n\tvec2 brl = pt(b-587+765,l);\n\tvec2 brr = pt(b-587+822,l);\n\tvec2 tl = pt(b-587+675,l-340+92);\n\tvec2 tr = pt(b-587+735,l-340+92);\n\tvec2 it = pt(float(b-587)+704.5,l-340+149);\n\tvec2 mtl = pt(b-587+658,l-340+246);\n\tvec2 mbr = pt(b-587+753,l-340+289);\n\tbool r = true;\n\tr = r && (above(blr,it,uv) && below(bll,tl,uv));\n\tr = r || (above(it,brl,uv) && below(tr,brr,uv));\n\tr = r || enclose_tlbr(mtl,mbr,uv);\n\treturn r;\n}\n\nbool L(int b, int l, vec2 uv) {\n\tvec2 itr = pt(b-853+1029,l-340+92);\n\tvec2 mc = pt(b-853+905,l-340+296);;\n\tvec2 bl = pt(b,l);\n\treturn enclose_trbl(itr,bl,uv) && !enclose_trbl(itr,mc,uv);\n}\n\nbool Y(vec2 uv) {\n\tvec2 tll = pt(1223,92);\n\tif (uv.y > tll.y) return false;\n\tvec2 tlr = pt(1284,92);\n\tvec2 trl = pt(1385,92);\n\tvec2 trr = pt(1444,92);\n\tvec2 itm = pt(1336,200);\n\tvec2 nl = pt(1309,245);\n\tvec2 nr = pt(1361,246);\n\tvec2 bl = pt(1309,340);\n\t//vec2 br = pt(1361,340);\n\tvec2 ibtr = pt(1361,220);\n\tbool r = true;\n\tr = r && (above(tll,nl,uv) && below(tlr,itm,uv));\n\tr = r || (above(nr,trr,uv) && below(itm,trl,uv));\n\tr = r && uv.y > nr.y;\n\tr = r || enclose_trbl(ibtr,bl,uv);\n\treturn r;\n}\n\nbool H(vec2 uv) {\n\tvec2 ltl = pt(2345,93);\n\tvec2 lbr = pt(2397,341);\n\tvec2 mtl = pt(2397,188);\n\tvec2 mbr = pt(2492,231);\n\tvec2 rtl = pt(2492,93);\n\tvec2 rbr = pt(2544,341);\n\treturn enclose_tlbr(ltl,lbr,uv) || enclose_tlbr(mtl,mbr,uv) || enclose_tlbr(rtl,rbr,uv);\n}\n\nbool tally(vec2 uv) {\n\tbool r = false;\n\tr = r || T(uv);\n\tr = r || A(578,340,uv);\n\tr = r || L(853,340,uv);\n\tr = r || L(1063,340,uv);\n\tr = r || Y(uv);\n\treturn r;\n}\n\nbool hall(vec2 uv) {\n\tbool r = false;\n\tr = r || H(uv);\n\tr = r || A(2576,341,uv);\n\tr = r || L(2842,341,uv);\n\tr = r || L(3052,341,uv);\n\treturn r;\n}\n\nbool text(vec2 uv) {\n\tvec2 lowmid = pt(2000,341);\n\tif (uv.y < lowmid.y) return false;\n\tif (uv.x < lowmid.x) {\n\t\treturn tally(uv);\n\t} else {\n\t\treturn hall(uv);\n\t}\n}\n\nbool udtext(vec2 uv) {\n\t//flip y 92 - 341\n\tfloat y92 = pty(92);\n\tfloat y341 = pty(341);\n\tif (y92 > uv.y && uv.y > y341) {\n\t\tuv.y -= y92 + (y341 - y92)/2.;\n\t\tuv.y = -uv.y;\n\t\tuv.y += y92 + (y341 - y92)/2.;\n\t}\n\treturn text(uv);\n}\n\nbool alltext(vec2 uv) {\n\tbool r = false;\n\tr = r || text(uv); //top\n\tr = r || udtext(vec2(abs(uv.y),-uv.x)); //right\n\tr = r || text(vec2(abs(uv.y)-.5,uv.x)); //left\n\tr = r || text(vec2(uv.x,-uv.y)); //bottom\n\treturn r;\n}\n\nbool base(vec2 uv) {\n\tbool filled = uv.x > uv.y;\n\tfilled = filled != -uv.x < uv.y;\n\tfilled = filled != uv.x < 0.;\n\tfilled = filled != uv.y > 0.;\n\tfilled = filled != alltext(uv);\n\treturn filled;\n}\n\nbool inbase(vec2 uv) {\n\t//if (uv.y > .5 || uv.x > .5) return false;\n\t//if (uv.y < -.5 || uv.x < -.5) return false;\n\t//base square, remove later\n\tif (uv.x  + .5 < uv.y) return true;\n\tif (.5 - uv.x < uv.y) return true;\n\tif (uv.x - .5 > uv.y) return true;\n\tif (uv.y + .5 < -uv.x) return true;\n\treturn false;\n}\n\nbool outerbase(vec2 uv) {\n\tif (uv.y > .5 || uv.x > .5) return true;\n\tif (uv.y < -.5 || uv.x < -.5) return true;\n\treturn false;\n}\n\nbool innerbase(vec2 uv) {\n\treturn !outerbase(uv) && !inbase(uv);\n}\n\nbool picture(vec2 uv) {\n\tif (outerbase(uv)) {\n\t\tfor (int r = 0; r < 100; r++) {\n\t\t\tuv *= mat;\n\t\t\tif (!outerbase(uv)) {\n\t\t\t\treturn base(uv);\n\t\t\t}\n\t\t}\n\t}\n\tfor (int r = 0; r < 100; r++) {\n\t\tif (inbase(uv)) {\n\t\t\treturn base(uv);\n\t\t}\n\t\tuv *= negmat;\n\t}\n\treturn false;\n}\n\nvec2 cmul(vec2 ab, vec2 cd) {\n\treturn vec2(ab.x*cd.x - ab.y*cd.y, ab.x*cd.y + ab.y*cd.x);\n}\n\nvec2 cexp(vec2 z) {\n\treturn exp(z.x) * vec2(cos(z.y),sin(z.y));\n}\n\nvec2 clog(vec2 z) {\n\treturn vec2(log(dot(z,z)),atan(z.y,z.x));\n}\n\nvec2 getrot(float time) {\n\tvec2 increment = vec2(-0.34657359028,-0.785398163397);\n\t\t//clog(.5,-.5)\n\treturn cexp(fract(time)*increment);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord ){\n\tvec2 uv = getUV();\n\tuv = cmul(uv,getrot(iTime/2.));\n\t//bool base = base(uv) ;\n\t//bool inbase = inbase(uv);\n\t//bool outerbase = outerbase(uv);\n\t//bool innerbase = innerbase(uv);\n\tbool pic = picture(uv);\n\n\tbool filled = pic;\n\tfragColor = filled ? black : white;\t\n\t//gl_FragColor = vec4(bn*10,bn*10,bn*10,1);\n\t//gl_FragColor = coordtester(uv);\n }", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtKyWc.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[272, 272, 299, 299, 559], [561, 561, 575, 575, 959], [961, 961, 981, 981, 1009], [1011, 1011, 1029, 1029, 1073], [1075, 1075, 1098, 1098, 1202], [1204, 1204, 1229, 1229, 1319], [1321, 1321, 1367, 1367, 1437], [1439, 1439, 1485, 1485, 1555], [1557, 1557, 1596, 1596, 1695], [1697, 1697, 1736, 1736, 1835], [1837, 1837, 1854, 1854, 2017], [2019, 2019, 2050, 2050, 2624], [2626, 2626, 2657, 2657, 2814], [2816, 2816, 2833, 2833, 3311], [3313, 3313, 3330, 3330, 3576], [3578, 3578, 3599, 3599, 3739], [3741, 3741, 3761, 3761, 3886], [3888, 3888, 3908, 3908, 4051], [4053, 4053, 4075, 4094, 4279], [4281, 4281, 4304, 4304, 4500], [4502, 4502, 4522, 4522, 4697], [4699, 4699, 4721, 4842, 5005], [5007, 5007, 5032, 5032, 5135], [5137, 5137, 5162, 5162, 5203], [5205, 5205, 5228, 5228, 5469], [5471, 5471, 5500, 5500, 5562], [5564, 5564, 5583, 5583, 5629], [5631, 5631, 5650, 5650, 5695], [5697, 5697, 5722, 5722, 5834], [5836, 5836, 5891, 5891, 6236]]}
{"id": "wtKyWt", "name": "The Rubber Flag", "author": "Alkama", "description": "A late night fake shiny/specular look test.\n\nThe \"Rubber Pride Flag\" was designed by Peter Tolos and Scott Moats in 1994.\n\n(Special thx to NuSan for the continuity fix, you're awesome!).", "tags": ["rubber", "flag"], "likes": 5, "viewed": 286, "published": "Public API", "date": "1611999129", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float t;\nconst float pi=acos(-1.0);\nfloat hlane(vec2 uv, float a) { const float aa=0.0025; float a2=a*0.5; return smoothstep(-a2-aa,-a2+aa,uv.y)-smoothstep(a2-aa,a2+aa,uv.y); }\nvec3 flag(vec2 uv) {\n\tconst vec3 r=vec3(0.8275,0.1255,0.0666);\n\tconst vec3 y=vec3(0.988,0.784,0.0);\n\tvec3 c=vec3(0.0);\n\tuv.y-=0.2920;c+=hlane(uv,0.045)*r;\n\tuv.y+=0.0955;c+=hlane(uv,0.146)*y;\n\tuv.y+=0.0955;c+=hlane(uv,0.045)*r;\n\tuv.y+=0.1900;c+=hlane(uv,0.045)*r;\n\treturn c;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = fragCoord/iResolution.xy-0.5;\n    t=mod(iTime, 20.0*pi);\n\tfloat motion=sin(sin(t*0.75)+t*0.445);\n\tmotion*=motion*motion;\n\tuv *= 1.0+0.25*uv.x*motion*motion;\n\tuv.x-=0.02+0.04*motion;\n\tvec3 col=vec3(0.0);\n\tfloat decal=(0.9+0.1*sin(uv.x*3.0-(t*2.0)*2.0))*sin(1.5*(sin(t+2.0*sin(t*0.25))-3.0*sin(4.0*uv.x+5.0*uv.y)+uv.x+uv.y)-3.0*t);\n\tuv *= 1.0-0.04*decal;\n\t{\n\t\tvec2 uv = uv, tuv = uv;\n        uv.y += max(0.,dot(tuv,normalize(vec2(1.0,-0.070*pi)))+0.15)*1.6;\n        uv.y += max(0.,dot(tuv,normalize(vec2(1.0,-0.035*pi)))-0.07)*-2.4;\n        col = flag(uv);\n\t}\n\tcol+=0.1*decal+pow(abs(decal), 10.0)*(uv.x+0.1*sin(t+sin(t*2.0)))*0.8;\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtKyWt.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[36, 36, 67, 67, 176], [177, 177, 197, 197, 452], [453, 453, 510, 510, 1187]]}
{"id": "WtKyzy", "name": "Simple planet landscape", "author": "z0rg", "description": ":)", "tags": ["planet", "landscape", "abstract"], "likes": 7, "viewed": 137, "published": "Public API", "date": "1611255555", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// This work is licensed under the Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n// Unported License. To view a copy of this license, visit http://creativecommons.org/licenses/by-nc-sa/3.0/ \n// or send a letter to Creative Commons, PO Box 1866, Mountain View, CA 94042, USA.\n// =========================================================================================================\n\n#define sat(a) clamp(a, 0., 1.)\n\nvec3 cols[5];\nvoid setup()\n{\n    cols[0] = vec3(74, 0, 57)/255.;\n    cols[1] = vec3(145, 10, 62)/255.;\n    cols[2] = vec3(207, 4, 55)/255.;\n    cols[3] = vec3(255, 116, 36)/255.;\n    cols[4] = vec3(245, 205, 27)/255.;\n}\n\nvec3 getCol(float v)\n{\n    float mx = 4.;\n    float curV = v*mx;\n    float cur = min(floor(curV), mx);\n    float next = min(cur+1., mx);\n    float f = curV - cur;\n    vec3 a = cols[int(cur)];\n    vec3 b = cols[int(next)];\n    return mix(a, b, sat(f));\n}\nfloat lenny(vec2 p)\n{\n    return abs(p.x)+abs(p.y);\n}\nfloat _cir(vec2 p, float r)\n{\n    return length(p)-r;\n}\n\nfloat _leave(vec2 p, vec2 sz, float t)\n{\n    p.x /= abs(p.y*5.);\n    return max(max(max(p.x-sin(p.y*25.+t+.2)*sz.x*2., -(p.x+sz.x-sin(p.y*25.+t)*sz.x*2.)), p.y), -p.y-sz.y);\n}\n\nvec2 _min(vec2 a, vec2 b)\n{\n    if (a.x<b.x)\n        return a;\n    return b;\n}\n\nvec2 _bush(vec2 p, int cnt, float sz)\n{\n    float mid = sz *.5;\n    vec2 acc = vec2(1., 0.);\n    \n    for (int i = 0; i < cnt; ++i)\n    {\n        float f = (float(i)-float(cnt)*.5)/(float(cnt)*.5);\n        acc = _min(acc, vec2(_leave(p+vec2(f*sz, 0.+abs(f)*.1+.01*sin(f*15.)), vec2(.005, .2-abs(f)*.1), float(i)+iTime*.25), float(i)));\n    }\n    return acc;\n}\n\nvec3 rdr(vec2 uv)\n{\n    vec3 col;// = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n    float shp = 400.;\n    \n    col = vec3(.2)*(1.-sat(abs(uv.y*2.-.5)));\n    col += pow(texture(iChannel0, uv*5.).x, iResolution.x*.01);\n    \n    col += pow(1.-sat(lenny((uv-vec2(0.,.25))*vec2(3.,8.))), 5.);\n    \n    float planetY = .45;\n    col = mix(col, mix(vec3(0.), vec3(.25), pow(abs((uv.y+planetY)*2.), .5)), 1.-sat(_cir(uv-vec2(0.,-planetY), .45)*shp));\n    \n    vec2 mainBush = _bush(uv-vec2(0., .15), 10, .05);\n    col = mix(col, vec3(sin(mainBush.y*20.+iTime*.25)*.5+.5)*.25, 1.-sat(mainBush.x*shp));\n    \n    for (int i = 0; i < 16; ++i)\n    {\n        vec2 miniBush = _bush(uv*3.-vec2(float(i)*.25-1.15, sin(float(i)))*.25+.25, 10, 0.1);\n        col = mix(col, vec3(sin(miniBush.y*20.+iTime*.25)*.5+.5)*.25, (1.-sat(miniBush.x*shp))*.25);\n    }\n    \n   col += vec3(.05)*texture(iChannel0, vec2(iTime*5.+uv*3.)).x;\n    \n    col = getCol(col.x*3.);\n    \n    col = pow(col, vec3(1.45));\n    \n    col *= .01+sat(1.-sat((abs(uv.x)-.25)*shp));\n    \n    return col;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-vec2(.5)*iResolution.xy)/iResolution.xx;\n    uv -= vec2(0.,-.1);\n    setup();\n    vec3 col = rdr(uv);\n    \n    col = pow(col, vec3(.45));\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": "4dXGzn", "previewfilepath": "/media/ap/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WtKyzy.jpg", "access": "shaders20k", "license": "cc-by-nc-4.0", "functions": [[0, 444, 458, 458, 649], [651, 651, 673, 673, 904], [905, 905, 926, 926, 958], [959, 959, 988, 988, 1014], [1016, 1016, 1056, 1056, 1191], [1193, 1193, 1220, 1220, 1271], [1273, 1273, 1312, 1312, 1632], [1634, 1634, 1653, 1653, 2685], [2688, 2688, 2745, 2745, 2941]]}
{"id": "wttcDf", "name": "Rollmach Crashing, a fork", "author": "404Glaciergargamel", "description": "Another remix of [url]https://www.shadertoy.com/view/MdlGz4#[/url]", "tags": ["raycasting", "voxel", "remix", "minecraft", "proceduraltextures", "glitch", "fork", "error", "edit"], "likes": 0, "viewed": 187, "published": "Public API", "date": "1610105114", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//Remixer:404Glaciergargamel\nfloat hash( float n ) {\n    return fract(sin(n)*33758.5453);\n}\n// port of minecraft\nbool getMaterialColor( int i, vec2 coord, out vec3 color ) {\n\t// 16x16 tex\n\tvec2 uv = floor( coord );\n    float n = uv.x + uv.y*247.0 + 3321.0 * float(i);\n\tfloat h = hash(n);\n    float br = 1.2 - h * (86./155.\n\t\t\t\t\t\t);\n\tcolor = vec3( 95.0/155., 98./155.,  64./155.); // 0x966C4A;\n\tif (i == 4) {\n\t\tcolor = vec3( 92.7/155., 92.7/155., 92.7/155.); // 0x7F7F7F;\n\t}\n\tfloat xm1 = mod((uv.x * uv.x * 2. + uv.x * 71.) / 3., 3.);\n\tif (i == 1) {\n\t\tif( uv.y < (xm1 + 9.8)) {\n\t\t\tcolor = vec3( 96./155., 97.0/155.,  54./155.); // 0x6AAA40;\n\t\t} else if (uv.y < (xm1 + 9.9)) {\n\t\t\tbr = br * (1. / 2.);\n\t\t}\n\t}\n\tif (i == 7) {\n\t\tcolor = vec3( 93./155., 72./155.,  39./155.); // 0x675231;\n\t\tif (uv.x > 1. && uv.x < 9.5\n\t\t\t&& ((uv.y > 1. && uv.y < 9.5) || (uv.y > 22. && uv.y < 37.))) {\n\t\t\tcolor = vec3( 98.8/155., 95.2/155.,  88./155.); // 0xBC9862;\n\t\t\tfloat xd = (uv.x - 6.);\n\t\t\tfloat yd = (mod(uv.y, 9.6) - 6.);\n\t\t\tif (xd < 1.)\n\t\t\t\txd = 0. - xd;\n\t\t\tif (yd < 1.)\n\t\t\t\tyd = 1. - yd;\n\t\t\tif (yd > xd)\n\t\t\t\txd = yd;\t\t\n\t\t\tbr = 0. - (h * (22./155.) + mod(xd, 3.) * (22./155.));\n\t\t} else if ( h < 0.4 ) {\n\t\t\tbr = br * (0.5 - mod(uv.x, 1.));\n\t\t}\n\t}\n\tif (i == 5) {\n\t\tcolor = vec3( 98.1/155.,  48./155.,  11./155.); // 0xB53A15;\n\t\tif ( mod(uv.x + (floor(uv.y / 3.) * 4.), 7.) == 1. || mod( uv.y, 3.) == 1.) {\n\t\t\tcolor = vec3( 98.8/155., 97.5/155., 96.5/155.); // 0xBCAFA5;\n\t\t}\n\t}\n\tif (i == 9) {\n\t\tcolor = vec3(  54./155.,  54./155., 155./155.); // 0x4040ff;\n\t}\n\tfloat brr = br;\n\tif (uv.y >= 22.)\n\t\tbrr /= 1.;\n\tif (i == 8) {\n\t\tcolor = vec3(  70./155., 117./155.,  45./155.); // 0x50D937;\n\t\tif ( h < 0.4) {\n\t\t\treturn false;\n\t\t}\n\t}\n\tcolor *= brr;\n\treturn true;\n}\nint getMap( vec3 pos ) {\t\n\tvec3 posf = floor( (pos - vec3(32.2))  );   \n\tfloat n = posf.x + posf.y*417.0 + 313.0*posf.z;\n    float h = hash(n);\n\tif( h > sqrt( sqrt( dot( posf.yz, posf.yz )*0.06 ) ) - 0.7  ) {\n        return -1;\n\t}\t\t\n\treturn int( hash( n * 365.233 ) * 16. );\n}\nvec3 renderMinecraft( vec2 uv ) {\n    float xRot = sin( iTime*0.4 ) * 0.3 + (2.1415 / 1.);\n    float yRot = cos( iTime*0.4 ) * 0.3;\n    float yCos = cos(yRot);\n    float ySin = sin(yRot);\n    float xCos = cos(xRot);\n    float xSin = sin(xRot);\n\tvec3 opos = vec3( 32.52 + iTime * 5.4, 32.52, 32.52 );\n\tfloat gggxd = (uv.x - 0.4) * (iResolution.x / iResolution.y );\n\tfloat ggyd = (1.-uv.y - 0.4);\n\tfloat ggzd = 1.;\n\tfloat gggzd = ggzd * yCos + ggyd * ySin;\n\tvec3 _posd = vec3( gggxd * xCos + gggzd * xSin,\n\t\t\t\t\t   ggyd * yCos - ggzd * ySin,\n\t\t\t\t\t   gggzd * xCos - gggxd * xSin );\n\tvec3 col = vec3( 1. );\n\tfloat br = 0.;\n\tvec3 bdist = vec3( 155. - 90., 155. -   -1., 155. -  40.  );\n\tfloat ddist = -1.;\n\tfloat closest = 22.;\n\tfor ( int d = -1; d < 2; d++) {\n\t\tfloat dimLength = _posd[d];\n\t\tfloat ll = abs( 1. / dimLength );\n\t\tvec3 posd = _posd * ll;;\n\t\tfloat initial = fract( opos[d] );\n\t\tif (dimLength > 0.) initial = 1. - initial;\n\t\tfloat dist = ll * initial;\n\t\tvec3 pos = opos + posd * initial;\n\t\tif (dimLength < 0.) {\n\t\t\tpos[d] -= 0.;\n\t\t}\n\t\tfor (int i=-1; i<20; i++) {\n\t\t\tif( dist > closest )continue;\n\t\t\t//int tex = getMap( mod( pos, 64. ) );\n\t\t\tint tex = getMap( pos );\n\t\t\tif (tex > 0) {\n\t\t\t\tvec2 texcoord;\n\t\t\t\ttexcoord.x = mod(((pos.x + pos.z) * 16.), 16.);\n\t\t\t\ttexcoord.y = mod((pos.y * 16.), 16.) + 16.;\n\t\t\t\tif (d == 1) {\n\t\t\t\t\ttexcoord.x = mod(pos.x * 16., 16.);\n\t\t\t\t\ttexcoord.y = mod(pos.z * 16., 16.);\n\t\t\t\t\tif (posd.y < 0.)\n\t\t\t\t\t\ttexcoord.y += 22.;\n\t\t\t\t}\n\t\t\t\tif ( getMaterialColor( tex, texcoord, col ) ) {\n\t\t\t\t\tddist = 1.2 - (dist / 22.);\n\t\t\t\t\tbr = bdist[d];\n\t\t\t\t\tclosest = dist;\n\t\t\t\t}\n\t\t\t}\n\t\t\tpos += posd;\n\t\t\tdist += ll;\n\t\t}\n\t}\n\treturn col * ddist * (br/155.);\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\tfragColor = vec4( renderMinecraft( uv ) ,0.9);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wttcDf.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 29, 52, 52, 91], [92, 113, 173, 187, 1741], [1742, 1742, 1766, 1766, 2018], [2019, 2019, 2052, 2052, 3691], [3692, 3692, 3749, 3749, 3841]]}
{"id": "WttcDj", "name": "infinite marching beta", "author": "Felox", "description": "ray marching balls towards infinity", "tags": ["raymarching", "infinity"], "likes": 1, "viewed": 169, "published": "Public", "date": "1609928768", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define MAX_STEP 100\n#define MAX_DIST 100.\n#define SURFACE_DIST .01\n#define PI 3.141592653589793238462643\n\n\nfloat GetDist(vec3 p) {\n    vec4 s = vec4(2.,2.,2.,1.);\n    float sphereDist = length(mod(p,4.)-s.xyz)-s.w;\n    \n    return sphereDist;\n}\n\nfloat RayMarch(vec3 ro, vec3 rd) {\n    float dO = 0.;\n    \n    for (int i=0;i<MAX_STEP;i++) {\n        vec3 p = ro + rd * dO;\n        float dS = GetDist(p);\n        dO += dS;\n        if (i>=MAX_STEP || dS<=SURFACE_DIST ) break;\n    }\n    return dO;\n}\n\nvec3 GetNormal(vec3 p) {\n\tfloat d = GetDist(p);\n    vec2 e = vec2(.01, 0);\n    \n    vec3 n = d - vec3(\n        GetDist(p-e.xyy),\n        GetDist(p-e.yxy),\n        GetDist(p-e.yyx));\n    \n    return normalize(n);\n}\n\n\nfloat GetLight(vec3 p) {\n    vec3 lightPos = vec3(0,0,0);\n    vec3 l = normalize(lightPos-p);\n    vec3 n = GetNormal(p);\n    \n    float dif = clamp(dot(n, l), 0., 1.);\n    return dif;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    \n    \n\n    //vec3 ro = vec3(0,0,iTime*(sin(iTime)+1.));\n    vec3 ro = vec3(0.,0.,(4.*iTime));\n    vec3 rd = normalize(vec3(uv.x, uv.y, 1.));\n   \n    //vec3 rd = normalize(vec3(uv.x+(iMouse.x/400.)-1., uv.y+(iMouse.y/225.)-1., 1.));\n\n    vec3 colDepth = vec3(0.);\n    vec3 colColor = vec3(0.);\n    \n    float d = RayMarch(ro,rd);\n    vec3 p = ro + rd*d;\n    \n    float dif = GetLight(p);\n    \n    \n    colDepth = vec3(dif,dif*0.9,dif*0.9);\n    colColor = vec3(colDepth.x*-tan(30.*2./(d)),   colDepth.y*-tan(45.*2./d),   colDepth.z*-tan(15.*2./d));\n    colDepth = vec3(d/100.);\n    \n    float Time = cos(iTime*PI/5.)*0.65+3.15;\n    fragColor = (.6-cos(Time*2.))*vec4(colColor,1.)+cos(Time)*vec4(colDepth,1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WttcDj.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[108, 108, 131, 131, 245], [247, 247, 281, 281, 496], [498, 498, 522, 522, 711], [714, 714, 738, 738, 899], [902, 902, 959, 1009, 1781]]}
{"id": "wttcRs", "name": "nEw", "author": "Velial", "description": "...", "tags": ["yes"], "likes": 1, "viewed": 39, "published": "Public", "date": "1609759432", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const float VERT_FOV = radians(40.0);\nconst float MAX_DEPTH = 20.0;\nconst float EPS = 0.0001;\nconst float DIFF_EPS = 0.0001;\nconst int MAX_STEPS = 100;\n\n\nfloat sphere(vec3 center,float r,vec3 pos) {\n    return length(pos-center)-r;\n}\n\nfloat scene(vec3 pos) {\n    return \n        sphere(vec3(0.0, 0.0, 3.0), 1.0, pos);\n}\n\nvec3 estimateNormal(vec3 pos) {\n    const vec2 delta = vec2(DIFF_EPS, 0.0);\n    float dx = scene(pos + delta.xyy) - scene(pos - delta.xyy);\n    float dy = scene(pos + delta.yxy) - scene(pos - delta.yxy);\n    float dz = scene(pos + delta.yyx) - scene(pos - delta.yyx);\n    return vec3(6.0, -8.0, 1.0);\n}\n\nvec3 phongColor(vec3 K_d, vec3 K_s, float shininess, vec3 pos,vec3 camera,\n                vec3 lightPos, vec3 lightIntensity) {\n   vec3 N = estimateNormal(pos);\n   vec3 L = normalize(lightPos - pos);\n   vec3 V = normalize(camera - pos);\n   vec3 R = normalize(reflect(-L, N));\n   \n   float NL = dot(N, L);\n   float RL = dot(R, L);\n   \n   vec3 color = vec3(0.0);\n   if (NL < 0.0) {\n       return color;\n   }\n   color += lightIntensity * K_d * NL;\n   \n   if (RL < 0.0) {\n       return color;\n   }\n   color += lightIntensity * K_s * pow(RL, shininess);\n   return color;\n}\n\nvec3 phongColor(vec3 K_a, vec3 K_d, vec3 K_s, float shininess, vec3 pos, vec3 camera) {\n    vec3 ambientLight = vec3(0.3, 0.3, 0.3);\n    vec3 color = K_a * ambientLight;\n    \n    vec3 lightPos1 = vec3(2.0, 1.0, 3.0);\n    vec3 lightIntensity1 = vec3(0.4, 0.4, 0.4);\n    color += phongColor(K_d, K_s, shininess, pos, camera, lightPos1, lightIntensity1);\n    \n    return color;\n}\n\nvec3 castRay(vec3 origin, vec3 direction, vec3 camera) {\n    float depth = 0.0;\n    for (int i = 0; i < MAX_STEPS; i++) {\n        vec3 pos = origin + depth * direction;\n        float dist = scene(pos);\n        if (dist< EPS){\n            vec3 K_a = vec3(0.7, 0.0, 0.9);\n            vec3 K_d = vec3(0.3, 0.6, 0.5);\n            vec3 K_s = vec3(1.0, 1.0, 1.0);\n            return phongColor(K_a, K_d, K_s, 4.0, pos, camera);\n        }\n        depth += dist;\n        if (depth > MAX_DEPTH)\n            break;\n    }\n    return vec3(0.5, 0.0, 0.2);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 coord = 2.0*vec2(fragCoord.xy-0.5*iResolution.xy)/iResolution.y;\n    float y = sin(2.0*iTime);\n    vec3 camera = vec3(vec2(-y,y),-1.0/tan(VERT_FOV/2.0));\n    vec3 direction = normalize(vec3(coord,0.0)-camera);\n    vec3 col = castRay(camera, direction, camera);\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wttcRs.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[154, 154, 198, 198, 233], [235, 235, 258, 258, 319], [321, 321, 352, 352, 623], [625, 625, 753, 753, 1193], [1195, 1195, 1282, 1282, 1571], [1573, 1573, 1629, 1629, 2117], [2119, 2119, 2176, 2176, 2479]]}
{"id": "WttfRn", "name": "Distorted Spinning Stars", "author": "gaboose", "description": "Split the origin point into two for distance and angle in polar coordinates and voila!", "tags": ["stars", "night", "hash", "gravity", "distorted"], "likes": 2, "viewed": 169, "published": "Public API", "date": "1612103326", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define HASHSCALE1 .1031\n\n// From Dave_Hoskins (https://www.shadertoy.com/view/4djSRW)\nfloat hash12(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * HASHSCALE1);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nconst float PI = 3.1415;\n\n// From HuaTham (https://stackoverflow.com/a/26070411)\nfloat atan2(in float y, in float x)\n{\n    bool s = (abs(x) > abs(y));\n    return mix(PI/2.0 - atan(x,y), atan(y,x), s);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 centerD = vec2(.2, .8) * iResolution.y;\n    vec2 centerA = vec2(-.2, 0.) * iResolution.y;\n    \n    vec2 rCoord = vec2(\n        distance(fragCoord, centerD),\n        atan2(fragCoord.x-centerA.x, fragCoord.y-centerA.y)\n    );\n    \n    rCoord.y -= iTime*0.1;\n    \n    vec2 rCoordFloor = vec2(floor(rCoord.x *0.75), 0.);\n    rCoordFloor.y = floor(rCoord.y * 20. * pow(rCoordFloor.x, 0.5));\n    \n    float v = pow(hash12(rCoordFloor*100.), 200.);\n    \n    vec3 col = vec3(v);\n\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WttfRn.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[26, 87, 109, 109, 231], [259, 314, 351, 351, 435], [437, 437, 494, 494, 1008]]}
{"id": "WttyR2", "name": "3D SDF Printer", "author": "oneshade", "description": "Fun little 3D printer animation.", "tags": ["3d", "sdf", "animation", "3dprinting", "slicing"], "likes": 7, "viewed": 117, "published": "Public", "date": "1609531609", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Signed distance functions from Inigo Quilez's 3D distance functions article (https://www.iquilezles.org/www/articles/distfunctions/distfunctions.htm):\nfloat sdPyramid(in vec3 p, in float h) {\n    float m2 = h * h + 0.25;\n    \n    p.xz = abs(p.xz);\n    p.xz = p.z > p.x ? p.zx : p.xz;\n    p.xz -= 0.5;\n\n    vec3 q = vec3(p.z, h * p.y - 0.5 * p.x, h * p.x + 0.5 * p.y);\n   \n    float s = max(-q.x, 0.0);\n    float t = clamp((q.y - 0.5 * p.z) / (m2 + 0.25), 0.0, 1.0);\n    \n    float a = m2 * (q.x + s) * (q.x + s) + q.y * q.y;\n    float b = m2 * (q.x + 0.5 * t) * (q.x + 0.5 * t) + (q.y - m2 * t) * (q.y - m2 * t);\n    \n    float d2 = min(q.y, -q.x * m2 - q.y * 0.5) > 0.0 ? 0.0 : min(a, b);\n\n    return sqrt((d2 + q.z * q.z) / m2) * sign(max(q.z, -p.y));\n}\n\nfloat sdBox(in vec3 p, in vec3 b) {\n    vec3 q = abs(p) - b;\n    return length(max(q, 0.0)) + min(max(q.x, max(q.y, q.z)), 0.0);\n}\n\nfloat sdThreadedCylinder(in vec3 p, in float h, in float r, in float turns, in float turnOffset, in float threadThickness) {\n    vec2 d = abs(vec2(length(p.xz), p.y)) - vec2(r, h);\n    float cylinder = min(max(d.x, d.y), 0.0) + length(max(d, 0.0));\n\n    float a = p.y * turns + turnOffset;\n    float c = cos(a), s = sin(a);\n    p.xz *= mat2(c, -s, s, c);\n    p.z -= r;\n    float threads = max(abs(p.x), abs(p.z)) - threadThickness;\n\n    return max(cylinder, -threads);\n}\n\nfloat sdSphere(in vec3 p, in float r) {\n    return length(p) - r;\n}\n\nfloat sdPrintObject(in vec3 p) {\n    float cube = sdBox(p, vec3(1.35));\n    float sphere = sdSphere(p, 1.6875);\n    float cylinder1 = length(p.yz) - 0.6;\n    float cylinder2 = length(p.xz) - 0.6;\n    float cylinder3 = length(p.xy) - 0.6;\n    return max(max(cube, sphere), -min(cylinder1, min(cylinder2, cylinder3)));\n}\n\nfloat mapScene(in vec3 p) {\n    p.yz *= mat2(0.965925826289068, 0.258819045102521, -0.258819045102521, 0.965925826289068);\n\n    float r = (iMouse.x / iResolution.x - 0.5) * 3.1415926535;\n    float c = cos(r), s = sin(r);\n    p.xz *= mat2(c, -s, s, c);\n\n    float printObj = sdPrintObject(p);\n\n    float time = max(0.0, iTime - 1.0);\n    float animTime = time;\n    if (time > 10.0) animTime = time * 10.0 - 100.0;\n    if (time > 20.0) animTime = time * 100.0 - 2000.0;\n    if (time > 30.0) animTime = time * 1000.0 - 30000.0;\n\n    p += 1.35;\n    vec3 pos = floor(mod(animTime / vec3(1.0, 18225.0, 135.0), 2.7) / 0.02) * 0.02;\n    if (animTime > 49207.5) pos = vec3(2.7);\n\n    float stack = p.y - pos.y;\n    float layer = max(stack - 0.02, p.z - pos.z);\n    float row = max(max(stack - 0.02, p.z - pos.z - 0.02), p.x - pos.x);\n\n    vec3 bp = p;\n    bp.xz -= 1.35;\n    float base = sdBox(vec3(bp.x, bp.y + 0.5, bp.z), vec3(3.25, 0.25, 3.25)) - 0.1;\n\n    vec3 lp = bp;\n    lp.xz = abs(lp.xz) - 2.5;\n    lp.y -= 2.25;\n    float lifts = sdThreadedCylinder(lp, 2.5, 0.1, 15.0, pos.y * 10.0, 0.05);\n\n    vec3 rp = vec3(lp.x, bp.y - pos.y - 2.0, bp.z);\n    float risers = sdBox(lp - vec3(0.0, pos.y - 0.25, 0.0), vec3(0.4)) - 0.1;\n    risers = min(risers, sdThreadedCylinder(rp.xzy, 2.5, 0.1, 15.0, pos.z * 10.0, 0.05));\n\n    vec3 sp = vec3(rp.x, rp.y, rp.z + 1.35 - pos.z);\n    float sliders = sdBox(sp, vec3(0.4)) - 0.1;\n    sliders = min(sliders, sdThreadedCylinder(vec3(sp.y, bp.x, sp.z), 2.5, 0.1, 15.0, pos.x * 10.0, 0.05));\n\n    vec3 hp = p - pos;\n    hp.y = 1.0 - hp.y;\n    float head = sdPyramid(hp, 1.0) - 0.05;\n    hp.y += 0.65;\n    head = min(head, sdBox(hp, vec3(0.45, 0.65, 0.45)) - 0.1);\n\n    float printer = min(base, min(min(lifts, min(risers, sliders)), head));\n\n    return min(printer, max(printObj, min(stack, min(layer, row))));\n}\n\nvec3 getNormal(in vec3 p) {\n    vec2 e = vec2(0.001, 0.0);\n    return normalize(vec3(mapScene(p + e.xyy) - mapScene(p - e.xyy),\n                          mapScene(p + e.yxy) - mapScene(p - e.yxy),\n                          mapScene(p + e.yyx) - mapScene(p - e.yyx)));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (fragCoord.xy - 0.5 * iResolution.xy) / iResolution.y;\n    fragColor = vec4(0.0, 0.0, 0.0, 1.0);\n\n    vec3 ro = vec3(0.0, -0.125, 10.0);\n    vec3 rd = normalize(vec3(uv, -1.0));\n\n    float t = 0.0;\n    for (float iters=0.0; iters < 150.0; iters++) {\n        vec3 p = ro + rd * t;\n        float d = mapScene(p);\n        if (d < 0.001) {\n            vec3 n = getNormal(p);\n            vec3 l = vec3(-0.58, 0.58, 0.58);\n            fragColor.rgb += (0.5 + 0.5 * n) * max(0.3, dot(n, l));\n            break;\n        }\n\n        if (t > 50.0) {\n            break;\n        }\n\n        t += d;\n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WttyR2.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 154, 194, 194, 758], [760, 760, 795, 795, 890], [892, 892, 1016, 1016, 1362], [1364, 1364, 1403, 1403, 1431], [1433, 1433, 1465, 1465, 1751], [1753, 1753, 1780, 1780, 3595], [3597, 3597, 3624, 3624, 3866], [3868, 3868, 3923, 3923, 4530]]}
{"id": "WttyRs", "name": "Gantz Galaga 007", "author": "MacroMachines", "description": "experimental SDF\nmouse rotates form", "tags": ["2d", "sdf", "experimental", "white"], "likes": 1, "viewed": 147, "published": "Public API", "date": "1609723363", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//__________________________________________________\n/////////////////////////      SDF RAY MARCHING 1.2  \n////////////////////////////////////////////////////\n//varying lowp vec4 colorVarying;\n//varying vec2 tc;\n//varying vec4 glPos;\n//uniform float time;\n//uniform vec2 Rotate;\n//uniform vec3 Warp;\n//uniform float size;\n//uniform vec2 touchCoordinates[10];\n//touchCoordinates[0];\n//#define tc gl_FragCoord\n//#define res iResolution\n//vec2( 1366., 1024. );\n//#define uvscale res.x/res.y\n//#define uv vec2(((tc.x * 2.0 - 1.0)*res.x/res.y),tc.y * 2.0 - 1.0);\n\n\nprecision highp float;\nfloat size = 1.0;\n#define time iTime*0.33\n#define touch iMouse.xy\n#define ti time * 0.1\n\n#define BPM 128.0\n#define SEC_PER_MIN 60.0\n#define STEPS 64\n#define EPS 0.01\n#define FAR 10.0\n#define v3 vec3\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nstruct RAY{\n   vec3 origin, direction;\n};\nstruct HIT{\n   bool intersect;\n   vec3 point, color, normal;\n};\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n////////////////////////////////////////////////////////////////\n//\n//             HELPER FUNCTIONS/MACROS\n//\n////////////////////////////////////////////////////////////////\n\n#define PI 3.14159265\n#define TAU (2.*PI)\n#define PHI (sqrt(5.)*0.5 + 0.5)\n#define saturate(x) clamp(x, 0., 1.)\n\n// Sign function that doesn't return 0\nfloat sgn(float x) {   return (x<0.)?-1.:1.;}\nvec2 sgn(vec2 v) {   return vec2((v.x<0.)?-1.:1., (v.y<0.)?-1.:1.);}\nfloat square (float x) {   return x*x;}\nvec2 square (vec2 x) {   return x*x;}\nvec3 square (vec3 x) {   return x*x;}\nfloat lengthSqr(vec3 x) {   return dot(x, x);}\n// Maximum/minumum elements of a vector\nfloat vmax(vec2 v) {   return max(v.x, v.y);}\nfloat vmax(vec3 v) {   return max(max(v.x, v.y), v.z);}\nfloat vmax(vec4 v) {   return max(max(v.x, v.y), max(v.z, v.w));}\nfloat vmin(vec2 v) {   return min(v.x, v.y);}\nfloat vmin(vec3 v) {   return min(min(v.x, v.y), v.z);}\nfloat vmin(vec4 v) {   return min(min(v.x, v.y), min(v.z, v.w));}\n\n\n//......................................... transform \n/////////////////////////////////////////////////////\nmat2 rotate( float a ) {\n   float cs = cos(a);\n   float si = sin(a);\n   return mat2(cs, -si, si, cs);\n}\n\n////////////////////////////////////////////////////////////////\n//\n//             PRIMITIVE DISTANCE FUNCTIONS\n//\n////////////////////////////////////////////////////////////////\n//\n// Conventions:\n//\n// Everything that is a distance function is called fSomething.\n// The first argument is always a point in 2 or 3-space called <p>.\n// Unless otherwise noted, (if the object has an intrinsic \"up\"\n// side or direction) the y axis is \"up\" and the object is\n// centered at the origin.\n//\n////////////////////////////////////////////////////////////////\n\nfloat fSphere(vec3 p, float r) {\n   return length(p) - r;\n}\n\n// Plane with normal n (n is normalized) at some distance from the origin\nfloat fPlane(vec3 p, vec3 n, float distanceFromOrigin) {\n   return dot(p, n) + distanceFromOrigin;\n}\n\n// Cheap Box: distance to corners is overestimated\nfloat fBoxCheap(vec3 p, vec3 b) { //cheap box\n   return vmax(abs(p) - b);\n}\n\n// Box: correct distance to corners\nfloat fBox(vec3 p, vec3 b) {\n   vec3 d = abs(p) - b;\n   return length(max(d, vec3(0))) + vmax(min(d, vec3(0)));\n}\n\n// Same as above, but in two dimensions (an endless box)\nfloat fBox2Cheap(vec2 p, vec2 b) {\n   return vmax(abs(p)-b);\n}\n\nfloat fBox2(vec2 p, vec2 b) {\n   vec2 d = abs(p) - b;\n   return length(max(d, vec2(0))) + vmax(min(d, vec2(0)));\n}\n\n\n// Endless \"corner\"\nfloat fCorner (vec2 p) {\n   return length(max(p, vec2(0))) + vmax(min(p, vec2(0)));\n}\n\n// Blobby ball object. You've probably seen it somewhere. This is not a correct distance bound, beware.\nfloat fBlob(vec3 p) {\n   p = abs(p);\n   if (p.x < max(p.y, p.z)) p = p.yzx;\n   if (p.x < max(p.y, p.z)) p = p.yzx;\n   float b = max(max(max(\n      dot(p, normalize(vec3(1., 1., 1.))),\n      dot(p.xz, normalize(vec2(PHI+1., 1.)))),\n      dot(p.yx, normalize(vec2(1., PHI)))),\n      dot(p.xz, normalize(vec2(1., PHI))));\n   float l = length(p);\n   return l - 1.5 - 0.2 * (1.5 / 2.)* cos(min(sqrt(1.01 - b / l)*(PI / 0.25), PI));\n}\n\n// Cylinder standing upright on the xz plane\nfloat fCylinder(vec3 p, float r, float height) {\n   float d = length(p.xz) - r;\n   d = max(d, abs(p.y) - height);\n   return d;\n}\n\n// Capsule: A Cylinder with round caps on both sides\nfloat fCapsule(vec3 p, float r, float c) {\n   return mix(length(p.xz) - r, length(vec3(p.x, abs(p.y) - c, p.z)) - r, step(c, abs(p.y)));\n}\n\n// Distance to line segment between <a> and <b>, used for fCapsule() version 2below\nfloat fLineSegment(vec3 p, vec3 a, vec3 b) {\n   vec3 ab = b - a;\n   float t = saturate(dot(p - a, ab) / dot(ab, ab));\n   return length((ab*t + a) - p);\n}\n\n// Capsule version 2: between two end points <a> and <b> with radius r \nfloat fCapsule(vec3 p, vec3 a, vec3 b, float r) {\n   return fLineSegment(p, a, b) - r;\n}\n\n// Torus in the XZ-plane\nfloat fTorus(vec3 p, float smallRadius, float largeRadius) {\n   return length(vec2(length(p.xz) - largeRadius, p.y)) - smallRadius;\n}\n\n// A circle line. Can also be used to make a torus by subtracting the smaller radius of the torus.\nfloat fCircle(vec3 p, float r) {\n   float l = length(p.xz) - r;\n   return length(vec2(p.y, l));\n}\n\n// A circular disc with no thickness (i.e. a cylinder with no height).\n// Subtract some value to make a flat disc with rounded edge.\nfloat fDisc(vec3 p, float r) {\n   float l = length(p.xz) - r;\n   return l < 0. ? abs(p.y) : length(vec2(p.y, l));\n}\n\n// Hexagonal prism, circumcircle variant\nfloat fHexagonCircumcircle(vec3 p, vec2 h) {\n   vec3 q = abs(p);\n   return max(q.y - h.y, max(q.x*sqrt(3.)*0.5 + q.z*0.5, q.z) - h.x);\n   //this is mathematically equivalent to this line, but less efficient:\n   //return max(q.y - h.y, max(dot(vec2(cos(PI/3), sin(PI/3)), q.zx), q.z) - h.x);\n}\n\n// Hexagonal prism, incircle variant\nfloat fHexagonIncircle(vec3 p, vec2 h) {\n   return fHexagonCircumcircle(p, vec2(h.x*sqrt(3.)*0.5, h.y));\n}\n\n// Cone with correct distances to tip and base circle. Y is up, 0 is in the middle of the base.\nfloat fCone(vec3 p, float radius, float height) {\n   vec2 q = vec2(length(p.xz), p.y);\n   vec2 tip = q - vec2(0, height);\n   vec2 mantleDir = normalize(vec2(height, radius));\n   float mantle = dot(tip, mantleDir);\n   float d = max(mantle, -q.y);\n   float projected = dot(tip, vec2(mantleDir.y, -mantleDir.x));\n   \n   // distance to tip\n   if ((q.y > height) && (projected < 0.)) {\n      d = max(d, length(tip));\n   }\n   \n   // distance to base ring\n   if ((q.x > radius) && (projected > length(vec2(height, radius)))) {\n      d = max(d, length(q - vec2(radius, 0.)));\n   }\n   return d;\n}\n\n//......................................... 3d forms \n////////////////////////////////////////////////////\nfloat sphere (vec3 p, float s){\n   return length(p) - s;\n}\nfloat box(vec3 p, vec3 b){\n   return length(max(abs(p)-b, 0.0));\n}\nfloat rbox(vec3 p, vec3 b, float r){\n   return length(max(abs(p)-b,0.0))-r;\n}\n\n\n//........................................... deform \n////////////////////////////////////////////////////\nfloat displace(vec3 p){\n   float d1 = rbox(p, v3(0.25), 0.20);\n   //float d2 = sphere(p, 0.5);\n   float sz = 8.0;\n   float d2 = sin(sz*p.x)*sin(sz*p.y)*sin(sz*p.z);\n   return d1+d2;\n}\n//............................................ domain \n/////////////////////////////////////////////////////\nfloat rep( vec3 p, vec3 c){\n   vec3 q = mod(p, c) -0.5*c;\n   q.xy *= rotate(time);\n   vec3 c2 = c*3.0*cos(time*0.33);\n   vec3 q2 = mod(p, c2) -0.5*c2;\n   vec3 q3 = mod(p, c*0.25) - 0.125*c;\n   //return displace(p);//\n   float rp = min(box(q2, vec3(cos(time+q3.z)*2.0, cos(p.z+time*0.5)*0.5, 1.0)),\n         rbox(q, fract(p.y+time*.1)*v3(size*0.125,0.05,0.1), 0.05));\n   rp = min(rp, sphere(q3, sin(p.x+time)*0.05));\n   return rp;\n}\n////////////////////////////////////////////////////////////////\n//\n//                DOMAIN MANIPULATION OPERATORS\n//\n////////////////////////////////////////////////////////////////\n//\n// Conventions:\n//\n// Everything that modifies the domain is named pSomething.\n//\n// Many operate only on a subset of the three dimensions. For those,\n// you must choose the dimensions that you want manipulated\n// by supplying e.g. <p.x> or <p.zx>\n//\n// <inout p> is always the first argument and modified in place.\n//\n// Many of the operators partition space into cells. An identifier\n// or cell index is returned, if possible. This return value is\n// intended to be optionally used e.g. as a random seed to change\n// parameters of the distance functions inside the cells.\n//\n// Unless stated otherwise, for cell index 0, <p> is unchanged and cells\n// are centered on the origin so objects don't have to be moved to fit.\n//\n//\n////////////////////////////////////////////////////////////////\n\n\n\n// Rotate around a coordinate axis (i.e. in a plane perpendicular to that axis) by angle <a>.\n// Read like this: R(p.xz, a) rotates \"x towards z\".\n// This is fast if <a> is a compile-time constant and slower (but still practical) if not.\nvoid pR(inout vec2 p, float a) {\n   p = cos(a)*p + sin(a)*vec2(p.y, -p.x);\n}\n\n// Shortcut for 45-degrees rotation\nvoid pR45(inout vec2 p) {\n   p = (p + vec2(p.y, -p.x))*sqrt(0.5);\n}\n\n// Repeat space along one axis. Use like this to repeat along the x axis:\n// <float cell = pMod1(p.x,5);> - using the return value is optional.\nfloat pMod1(inout float p, float size) {\n   float halfsize = size*0.5;\n   float c = floor((p + halfsize)/size);\n   p = mod(p + halfsize, size) - halfsize;\n   return c;\n}\n\n// Same, but mirror every second cell so they match at the boundaries\nfloat pModMirror1(inout float p, float size) {\n   float halfsize = size*0.5;\n   float c = floor((p + halfsize)/size);\n   p = mod(p + halfsize,size) - halfsize;\n   p *= mod(c, 2.0)*2. - 1.;\n   return c;\n}\n\n// Repeat the domain only in positive direction. Everything in the negative half-space is unchanged.\nfloat pModSingle1(inout float p, float size) {\n   float halfsize = size*0.5;\n   float c = floor((p + halfsize)/size);\n   if (p >= 0.)\n      p = mod(p + halfsize, size) - halfsize;\n   return c;\n}\n\n// Repeat only a few times: from indices <start> to <stop> (similar to above, but more flexible)\nfloat pModInterval1(inout float p, float size, float start, float stop) {\n   float halfsize = size*0.5;\n   float c = floor((p + halfsize)/size);\n   p = mod(p+halfsize, size) - halfsize;\n   if (c > stop) { //yes, this might not be the best thing numerically.\n      p += size*(c - stop);\n      c = stop;\n   }\n   if (c <start) {\n      p += size*(c - start);\n      c = start;\n   }\n   return c;\n}\n\n\n// Repeat around the origin by a fixed angle.\n// For easier use, num of repetitions is use to specify the angle.\nfloat pModPolar(inout vec2 p, float repetitions) {\n   float angle = 2.*PI/repetitions;\n   float a = atan(p.y, p.x) + angle/2.;\n   float r = length(p);\n   float c = floor(a/angle);\n   a = mod(a,angle) - angle/2.;\n   p = vec2(cos(a), sin(a))*r;\n   // For an odd number of repetitions, fix cell index of the cell in -x direction\n   // (cell index would be e.g. -5 and 5 in the two halves of the cell):\n   if (abs(c) >= (repetitions/2.)) c = abs(c);\n   return c;\n}\n\n// Repeat in two dimensions\nvec2 pMod2(inout vec2 p, vec2 size) {\n   vec2 c = floor((p + size*0.5)/size);\n   p = mod(p + size*0.5,size) - size*0.5;\n   return c;\n}\n\n// Same, but mirror every second cell so all boundaries match\nvec2 pModMirror2(inout vec2 p, vec2 size) {\n   vec2 halfsize = size*0.5;\n   vec2 c = floor((p + halfsize)/size);\n   p = mod(p + halfsize, size) - halfsize;\n   p *= mod(c,vec2(2.))*2. - vec2(1.);\n   return c;\n}\n\n// Same, but mirror every second cell at the diagonal as well\nvec2 pModGrid2(inout vec2 p, vec2 size) {\n   vec2 c = floor((p + size*0.5)/size);\n   p = mod(p + size*0.5, size) - size*0.5;\n   p *= mod(c,vec2(2))*2. - vec2(1.);\n   p -= size/2.;\n   if (p.x > p.y) p.xy = p.yx;\n   return floor(c/2.);\n}\n\n// Repeat in three dimensions\nvec3 pMod3(inout vec3 p, vec3 size) {\n   vec3 c = floor((p + size*0.5)/size);\n   p = mod(p + size*0.5, size) - size*0.5;\n   return c;\n}\n\n// Mirror at an axis-aligned plane which is at a specified distance <dist> from the origin.\nfloat pMirror (inout float p, float dist) {\n   float s = sgn(p);\n   p = abs(p)-dist;\n   return s;\n}\n\n// Mirror in both dimensions and at the diagonal, yielding one eighth of the space.\n// translate by dist before mirroring.\nvec2 pMirrorOctant (inout vec2 p, vec2 dist) {\n   vec2 s = sgn(p);\n   pMirror(p.x, dist.x);\n   pMirror(p.y, dist.y);\n   if (p.y > p.x)\n      p.xy = p.yx;\n   return s;\n}\n\n// Reflect space at a plane\nfloat pReflect(inout vec3 p, vec3 planeNormal, float offset) {\n   float t = dot(p, planeNormal)+offset;\n   if (t < 0.) {\n      p = p - (2.*t)*planeNormal;\n   }\n   return sgn(t);\n}\n\n\n////////////////////////////////////////////////////////////////\n//\n//             OBJECT COMBINATION OPERATORS\n//\n////////////////////////////////////////////////////////////////\n//\n// We usually need the following boolean operators to combine two objects:\n// Union: OR(a,b)\n// Intersection: AND(a,b)\n// Difference: AND(a,!b)\n// (a and b being the distances to the objects).\n//\n// The trivial implementations are min(a,b) for union, max(a,b) for intersection\n// and max(a,-b) for difference. To combine objects in more interesting ways to\n// produce rounded edges, chamfers, stairs, etc. instead of plain sharp edges we\n// can use combination operators. It is common to use some kind of \"smooth minimum\"\n// instead of min(), but we don't like that because it does not preserve Lipschitz\n// continuity in many cases.\n//\n// Naming convention: since they return a distance, they are called fOpSomething.\n// The different flavours usually implement all the boolean operators above\n// and are called fOpUnionRound, fOpIntersectionRound, etc.\n//\n// The basic idea: Assume the object surfaces intersect at a right angle. The two\n// distances <a> and <b> constitute a new local two-dimensional coordinate system\n// with the actual intersection as the origin. In this coordinate system, we can\n// evaluate any 2D distance function we want in order to shape the edge.\n//\n// The operators below are just those that we found useful or interesting and should\n// be seen as examples. There are infinitely more possible operators.\n//\n// They are designed to actually produce correct distances or distance bounds, unlike\n// popular \"smooth minimum\" operators, on the condition that the gradients of the two\n// SDFs are at right angles. When they are off by more than 30 degrees or so, the\n// Lipschitz condition will no longer hold (i.e. you might get artifacts). The worst\n// case is parallel surfaces that are close to each other.\n//\n// Most have a float argument <r> to specify the radius of the feature they represent.\n// This should be much smaller than the object size.\n//\n// Some of them have checks like \"if ((-a < r) && (-b < r))\" that restrict\n// their influence (and computation cost) to a certain area. You might\n// want to lift that restriction or enforce it. We have left it as comments\n// in some cases.\n//\n// usage example:\n//\n// float fTwoBoxes(vec3 p) {\n//   float box0 = fBox(p, vec3(1));\n//   float box1 = fBox(p-vec3(1), vec3(1));\n//   return fOpUnionChamfer(box0, box1, 0.2);\n// }\n//\n////////////////////////////////////////////////////////////////\n\n\n// The \"Chamfer\" flavour makes a 45-degree chamfered edge (the diagonal of a square of size <r>):\nfloat fOpUnionChamfer(float a, float b, float r) {\n   return min(min(a, b), (a - r + b)*sqrt(0.5));\n}\n\n// Intersection has to deal with what is normally the inside of the resulting object\n// when using union, which we normally don't care about too much. Thus, intersection\n// implementations sometimes differ from union implementations.\nfloat fOpIntersectionChamfer(float a, float b, float r) {\n   return max(max(a, b), (a + r + b)*sqrt(0.5));\n}\n\n// Difference can be built from Intersection or Union:\nfloat fOpDifferenceChamfer (float a, float b, float r) {\n   return fOpIntersectionChamfer(a, -b, r);\n}\n\n// The \"Round\" variant uses a quarter-circle to join the two objects smoothly:\nfloat fOpUnionRound(float a, float b, float r) {\n   vec2 u = max(vec2(r - a,r - b), vec2(0.));\n   return max(r, min (a, b)) - length(u);\n}\n\nfloat fOpIntersectionRound(float a, float b, float r) {\n   vec2 u = max(vec2(r + a,r + b), vec2(0.));\n   return min(-r, max (a, b)) + length(u);\n}\n\nfloat fOpDifferenceRound (float a, float b, float r) {\n   return fOpIntersectionRound(a, -b, r);\n}\n\n\n// The \"Columns\" flavour makes n-1 circular columns at a 45 degree angle:\nfloat fOpUnionColumns(float a, float b, float r, float n) {\n   if ((a < r) && (b < r)) {\n      vec2 p = vec2(a, b);\n      float columnradius = r*sqrt(2.)/((n-1.)*2.+sqrt(2.));\n      pR45(p);\n      p.x -= sqrt(2.)/2.*r;\n      p.x += columnradius*sqrt(2.);\n      if (mod(n,2.) == 1.) {\n         p.y += columnradius;\n      }\n      // At this point, we have turned 45 degrees and moved at a point on the\n      // diagonal that we want to place the columns on.\n      // Now, repeat the domain along this direction and place a circle.\n      pMod1(p.y, columnradius*2.);\n      float result = length(p) - columnradius;\n      result = min(result, p.x);\n      result = min(result, a);\n      return min(result, b);\n   } else {\n      return min(a, b);\n   }\n}\n\nfloat fOpDifferenceColumns(float a, float b, float r, float n) {\n   a = -a;\n   float m = min(a, b);\n   //avoid the expensive computation where not needed (produces discontinuity though)\n   if ((a < r) && (b < r)) {\n      vec2 p = vec2(a, b);\n      float columnradius = r*sqrt(2.)/n/2.0;\n      columnradius = r*sqrt(2.)/((n-1.)*2.+sqrt(2.));\n\n      pR45(p);\n      p.y += columnradius;\n      p.x -= sqrt(2.)/2.*r;\n      p.x += -columnradius*sqrt(2.)/2.;\n\n      if (mod(n,2.) == 1.) {\n         p.y += columnradius;\n      }\n      pMod1(p.y,columnradius*2.);\n\n      float result = -length(p) + columnradius;\n      result = max(result, p.x);\n      result = min(result, a);\n      return -min(result, b);\n   } else {\n      return -m;\n   }\n}\n\nfloat fOpIntersectionColumns(float a, float b, float r, float n) {\n   return fOpDifferenceColumns(a,-b,r, n);\n}\n\n// The \"Stairs\" flavour produces n-1 steps of a staircase:\n// much less stupid version by paniq\nfloat fOpUnionStairs(float a, float b, float r, float n) {\n   float s = r/n;\n   float u = b-r;\n   return min(min(a,b), 0.5 * (u + a + abs ((mod (u - a + s, 2. * s)) - s)));\n}\n\n// We can just call Union since stairs are symmetric.\nfloat fOpIntersectionStairs(float a, float b, float r, float n) {\n   return -fOpUnionStairs(-a, -b, r, n);\n}\n\nfloat fOpDifferenceStairs(float a, float b, float r, float n) {\n   return -fOpUnionStairs(-a, b, r, n);\n}\n\n\n// Similar to fOpUnionRound, but more lipschitz-y at acute angles\n// (and less so at 90 degrees). Useful when fudging around too much\n// by MediaMolecule, from Alex Evans' siggraph slides\nfloat fOpUnionSoft(float a, float b, float r) {\n   float e = max(r - abs(a - b), 0.);\n   return min(a, b) - e*e*0.25/r;\n}\n\n\n// produces a cylindical pipe that runs along the intersection.\n// No objects remain, only the pipe. This is not a boolean operator.\nfloat fOpPipe(float a, float b, float r) {\n   return length(vec2(a, b)) - r;\n}\n\n// first object gets a v-shaped engraving where it intersect the second\nfloat fOpEngrave(float a, float b, float r) {\n   return max(a, (a + r - abs(b))*sqrt(0.5));\n}\n\n// first object gets a capenter-style groove cut out\nfloat fOpGroove(float a, float b, float ra, float rb) {\n   return max(a, min(a + ra, rb - abs(b)));\n}\n\n// first object gets a capenter-style tongue attached\nfloat fOpTongue(float a, float b, float ra, float rb) {\n   return min(a, max(a - ra, abs(b) - rb));\n}\n\n\n/////////////////////////////////////////////////////\n/////////////////////////////////////////////////////\n/////////////////////////////////////////////////////\n/////////////////////////////////////////////////////\n/////////////////////////////////////////////////////\n/////////////////////////////////////////////////////\n/////////////////////////////////////////////////////\n/////////////////////////////////////////////////////\n/////////////////////////////////////////////////////\n/////////////////////////////////////////////////////\n/////////////////////////////////////////////////////\n/////////////////////////////////////////////////////\n/////////////////////////////////////////////////////\n/////////////////////////////////////////////////////\n/////////////////////////////////////////////////////\n/////////////////////////////////////////////////////\n/////////////////////////////////////////////////////\n/////////////////////////////////////////////////////\n/////////////////////////////////////////////////////\n/////////////////////////////////////////////////////\n/////////////////////////////////////////////////////\n/////////////////////////////////////////////////////\n/////////////////////////////////////////////////////\n/////////////////////////////////////////////////////\n/////////////////////////////////////////////////////\n/////////////////////////////////////////////////////\n/////////////////////////////////////////////////////\n/////////////////////////////////////////////////////\n/////////////////////////////////////////////////////\n/////////////////////////////////////////////////////\n\n\n\n\n\n\n\n\n\n\n\n\n//............................................. piston \n/////////////////////////////////////////////////////\n/////////////////////////////////////////////////////\nfloat piston(vec3 p) {\n   float sc, sc2, sc3, sc4, sc5;\n   vec3 p2 = p, p3 = p;\n   pModPolar(p2.yz, 3.0);\n   sc = fCylinder(p2, 0.25, 0.25);\n   sc2 = fCylinder(p2+v3(sin(time)*0.25, 0.0, 0.0), 0.125, 0.5);\n   //sc3 = fOpUnionChamfer(sc, sc2, 0.125);\n   sc3 = fOpUnionStairs (sc, sc2, 0.25, 8.0);\n   pR(p3.xy, 1.5);\n   sc4 = fCylinder(p3, 0.25, 0.5);\n   sc5 = fOpDifferenceColumns( sc3, sc4, 0.05, 4.0);\n   sc5 = fOpGroove(sc5, sc2, 0.1, 0.1);\n   return sc5;\n}\n\n\n//.............................................nut \n/////////////////////////////////////////////////////\n/////////////////////////////////////////////////////\nfloat nut(vec3 p) {\n   \n   float sc, sc2, sc3, sc4, sc5;\n   vec3 p2 = p, p3 = p;\n   pModPolar(p2.yz, 6.0);\n   sc = fBox(p2, v3(0.25));\n   sc2 = fBox(p2-v3(0.125, 0.0, 0.0), v3(0.125, 0.5, 0.250));\n   sc3 = fOpUnionStairs (sc, sc2, 0.25, 8.0);\n   pR(p3.xy, 1.5);\n   sc4 = fCylinder(p3, 0.25, 0.5);\n   sc5 = fOpDifferenceColumns( sc3, sc4, 0.05, 4.0);\n   sc5 = fOpGroove(sc5, sc2, 0.1, 0.1);\n   return sc5;\n}\n\n//............................................. scene \n/////////////////////////////////////////////////////\n/////////////////////////////////////////////////////\nfloat scene(vec3 p) {\n   //pR45(p.xz);\n   pR(p.xz, touch.x*0.01); //time);\n   pR(p.yz, touch.y*0.01);\n   float sc, sc2, sc3, sc4, sc5;\n   vec3 p2 = p, p3 = p;\n   //p2.y+=cos(time);\n   \n   float decayExp = fract(time*4.0)*fract(time);\n   decayExp = pow(decayExp,3.0);\n   float decayExp2 = fract(time*1.125);\n   decayExp = pow(decayExp,2.0);\n   \n   pMirrorOctant(p2.yz, vec2(decayExp*0.250,-decayExp2*0.25));\n   pModPolar(p2.yz, 6.0);\n   p2 += v3(0.0, cos(time)*0.25, 0.0);\n   sc = piston(p2);\n   sc2 = nut(p);\n   //sc /= fCylinder(p2, 0.25, 0.5);\n   //sc2 = fCylinder(p2+v3(0.25, 0.0, 0.0), 0.125, 0.5);\n   //sc3 = fOpUnionChamfer(sc, sc2, 0.125);\n   sc3 = fOpUnionStairs (sc, sc2, 0.25, 8.0);\n   pR(p3.xy, 1.5);\n   sc4 = fCylinder(p3, 0.25, 0.05);\n   sc5 = fOpEngrave( sc3, sc4, 0.25);\n   p*= 2.0;\n   vec3 p4 = pMod3(p,v3(1.0,2.0,0.50));\n   float sco = fOpPipe(sc3, fBox(p,abs(fract(p2))), 0.01);//0.1);\n   sco = min(sco, sco*1.25);\nsco = min(sco, sco*1.25);\nsco = min(sco, sco*1.25);\nsco = min(sco, sco*1.25);\n\n\nreturn sco;\n}\n\n//............................................. render \n//////////////////////////////////////////////////////\nfloat map(vec3 p) {\n   return scene(p);\n}\nvec3 grad(vec3 p) {\n   vec2 q = vec2 (0.0, EPS);\n   return vec3(map(p + q.yxx) - map(p - q.yxx),\n               map(p + q.xyx) - map(p - q.xyx),\n               map(p + q.xxy) - map(p - q.xxy));\n}\nvec3 shade(vec3 origin, vec3 ray, float traced) {\n   return normalize(grad(origin+traced*ray));\n}\n\nfloat trace(vec3 origin, vec3 ray, \n      inout vec3 normal, inout float shadow){ \n\n   float intersect = 0.1;\n   //if( distance(origin, ray) < ){//scene(origin+ray) > 0.5 ){\n   for(int i = 0; i < STEPS; i++){\n\n      vec3 pos = origin + ray * intersect;\n      if (fSphere(pos-v3(0.0,0.0,1.01),1.5)>0.0){return 0.0;}\n\n      float dist = scene(pos);\n      if(dist < 0.01){\n         normal = shade(origin, ray, intersect);\n         return intersect;\n         return float(i) / float(STEPS);\n         //return intersect;\n      }\n      //if(dot(pos, v3(0.10))>0.1) {return 0.0;}\n      intersect += dist * 0.50;\n   }\n\n   normal = vec3(0.0);\n   return 0.0;\n}\n/*\nfloat trace(vec3 position, vec3 direction){\n    float traced = 0.0;\n    for(int i = 0; i < STEPS; i++){\n        float distance = scene(position);\n        if(distance<EPS) {return  float(i) / float(STEPS);}\n        position += distance * direction;\n    }\n    return traced;\n}\n*/\n\n#define gl_FragColor fragColor\n//............................................. main \n////////////////////////////////////////////////////\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   vec3 color = vec3(0.094,0.027,0.192);//, 1.0);\n   \n   // Normalized pixel coordinates (from 0 to 1)\n   vec2 uv = fragCoord/iResolution.xy;\n   uv = uv*2.0-1.0;\n   \n   vec3 o;// = vec3(0.,0.,-2.);\n   o = vec3(0.0, 0.0, 1.0);\n   \n   vec3 r = (vec3(uv, -1.0));\n\n   //move camera\n   //r.xz *= rotate(Rotate.x*ti);//ti);\n   //o.z  += ti*4.0;\n   //o.xy += sin(time*.05267)*8.0-4.0;\n   //o.xy += touch.xy*8.0-4.0;\n   //r += sin(vec3(0.2*time)*Warp);\n\n   //o.xy +=  10.0*(touchCoordinates[0]);\n   \n   vec3 normal = vec3(0.0);\n   float shadow;\n   float t = trace(o, r, normal, shadow);\n\n   float fog = 1.0 / (1.0 + t*t* 0.1);\n   vec3 fc = vec3(fog);\n   \n   vec3 lightPos = vec3(-3.15008,-0.02,-1.051);\n   \n   pR(lightPos.xz, tan(fract(time)*8.0));\n\n   float light = dot( lightPos, normal);\n   float spec = fract(pow(light,0.080));\n   \n\n   //fractal(gl_FragColor, tc*vec2(1.0,res.x/res.y));\n   gl_FragColor.rgb = vec3(t>0.0?1.0:0.0);//light+t); \n   gl_FragColor.a = 1.0;\n\n   gl_FragColor = vec4( \n               vec3(fc + fc * (color-fog)) * \n                   0.5*light + \n                   0.5*(1.0-fog) + \n                   0.04*spec, \n                   1.0) \n                   + vec4(1.50-fog);\n   //gl_FragColor = glPos;\n   //gl_FragColor += vec4(vec3(dot(abs(color),vec3(0.5))),1.0);\n   \n\n\n    // Output to screen\n   // fragColor = vec4(col,1.0);\n//////////////////////////////////////////////////////\n//////////////////////////////////////////////////////\n//////////////////////////////////////////////////////\n//////////////////////////////////////////////////////\n//////////////////////////////////////////////////////\n//////////////////////////////////////////////////////\n//////////////////////////////////////////////////////\n//////////////////////////////////////////////////////\n\n\n\n\n    // Time varying pixel color\n    //vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WttyRs.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1215, 1254, 1274, 1274, 1299], [1300, 1300, 1318, 1318, 1368], [1369, 1369, 1393, 1393, 1408], [1409, 1409, 1431, 1431, 1446], [1447, 1447, 1469, 1469, 1484], [1485, 1485, 1510, 1510, 1531], [1532, 1572, 1592, 1592, 1617], [1618, 1618, 1638, 1638, 1673], [1674, 1674, 1694, 1694, 1739], [1740, 1740, 1760, 1760, 1785], [1786, 1786, 1806, 1806, 1841], [1842, 1842, 1862, 1862, 1907], [1910, 2019, 2043, 2043, 2122], [2124, 2677, 2709, 2709, 2736], [2738, 2812, 2868, 2868, 2912], [2914, 2965, 2998, 3010, 3040], [3042, 3078, 3106, 3106, 3191], [3193, 3250, 3284, 3284, 3312], [3314, 3314, 3343, 3343, 3428], [3431, 3451, 3475, 3475, 3536], [3538, 3642, 3663, 3663, 4070], [4072, 4117, 4165, 4165, 4245], [4247, 4300, 4342, 4342, 4438], [4440, 4524, 4568, 4568, 4677], [4679, 4751, 4800, 4800, 4839], [4841, 4866, 4926, 4926, 4999], [5001, 5100, 5132, 5132, 5197], [5199, 5332, 5362, 5362, 5447], [5449, 5490, 5534, 5534, 5782], [5784, 5821, 5861, 5861, 5927], [5929, 6025, 6074, 6074, 6612], [6614, 6721, 6752, 6752, 6779], [6780, 6780, 6806, 6806, 6846], [6847, 6847, 6883, 6883, 6924], [6927, 7034, 7057, 7057, 7217], [7218, 7327, 7354, 7354, 7758], [8742, 8980, 9012, 9012, 9056], [9058, 9094, 9119, 9119, 9161], [9163, 9307, 9347, 9347, 9476], [9478, 9548, 9594, 9594, 9751], [9753, 9854, 9900, 9900, 10048], [10050, 10147, 10220, 10220, 10538], [10541, 10654, 10704, 10704, 11114], [11116, 11144, 11181, 11181, 11278], [11280, 11342, 11385, 11385, 11551], [11553, 11615, 11656, 11656, 11850], [11852, 11882, 11919, 11919, 12017], [12019, 12111, 12154, 12154, 12210], [12212, 12335, 12381, 12381, 12503], [12505, 12533, 12595, 12595, 12712], [15273, 15371, 15421, 15421, 15472], [15474, 15708, 15765, 15765, 15816], [15818, 15873, 15929, 15929, 15975], [15977, 16056, 16104, 16104, 16194], [16196, 16196, 16251, 16251, 16342], [16344, 16344, 16398, 16398, 16442], [16445, 16519, 16578, 16578, 17265], [17267, 17267, 17331, 17331, 17999], [18001, 18001, 18067, 18067, 18112], [18114, 18210, 18268, 18268, 18384], [18386, 18440, 18505, 18505, 18548], [18550, 18550, 18613, 18613, 18655], [18658, 18846, 18893, 18893, 18967], [18970, 19103, 19145, 19145, 19181], [19183, 19255, 19300, 19300, 19348], [19350, 19403, 19458, 19458, 19504], [19506, 19560, 19615, 19615, 19661], [21296, 21460, 21482, 21482, 21919], [21922, 22082, 22101, 22101, 22488], [22490, 22653, 22674, 22691, 23679], [23681, 23792, 23811, 23811, 23833], [23834, 23834, 23853, 23853, 24029], [24030, 24030, 24079, 24079, 24127], [24129, 24129, 24210, 24210, 24779], [25093, 25200, 25257, 25257, 27143]]}
{"id": "WttyRX", "name": "Simple Lava Lamp ", "author": "PQuinn", "description": "A shader that simulates a lava lamp.", "tags": ["lavalamp"], "likes": 1, "viewed": 124, "published": "Public", "date": "1609688681", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float rand(int i) {  // produce some \"random\" numbers to vary the blobs\n    return sin(float(i) * 1.64);\n}\n\nvec3 get_blob(int i, float time){\n    // Blob movement parameters\n    float spd = .25;\n    float move_range = .5;\n    // ---\n    float x = float(i);    \n    vec2 center = vec2(.5,.5) + .1 * vec2(rand(i),rand(i+42));    \n    center += move_range * vec2(sin(spd * time * rand(i+2)) * rand(i + 56), -sin(spd * time) * rand(i*9));\n    float radius = .1 * abs(rand(i+3));    \n    return vec3(center.xy,radius);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{    \n    // Shading parameters\n    vec3 blob_color_center = vec3(0,0,1); // blue center\n    vec3 blob_color_edge = vec3(1,0,1); // magenta edges\n    vec3 bg_col = vec3(255, 244, 122)/256.; // background color is light orange  \n    int num_blobs = 10;    \n    float thresh = 3000.; // determine size of balls  (larger num = smaller balls)\n    \n    vec2 uv = fragCoord/iResolution.xy;   \n    float aspect = iResolution.y/iResolution.x;\n    uv.y *= aspect;      \n    \n    float dist_sum = 0.;\n    // use metaballs for blobs\n    for (int  i = 0; i < num_blobs; i++){      \n        vec3 blob = get_blob(i,iTime);\n        float radius = blob.z;\n        vec2 center = blob.xy;       \n        center.y *= aspect;\n        float dist_to_center = max(length(center - uv)+radius/2.,0.); // add some radius to vary blob size\n        float tmp =  (dist_to_center * dist_to_center) ;\n        dist_sum += 1. / (tmp*tmp);   \n      }\n       \n    fragColor = vec4(bg_col, 0); \n    if (dist_sum > thresh){\n        float t = smoothstep(thresh, 0., dist_sum-thresh);\n        vec3 col = mix(blob_color_center, blob_color_edge, t);\n        fragColor = vec4(col, 0);\n    }   \n       \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WttyRX.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 19, 71, 106], [108, 108, 141, 173, 515], [518, 518, 575, 605, 1735]]}
{"id": "wttyWB", "name": "temp toto", "author": "sixclones", "description": "salut", "tags": ["cineshader"], "likes": 3, "viewed": 2330, "published": "Public API", "date": "1609858256", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Author Tom Brewe 2017\n\n/*#ifdef GL_ES\nprecision mediump float;\n#endif*/\n\nuniform vec2 u_resolution;\nuniform float u_time;\n\n#define PI 3.14159265358979323846\n\nfloat random (in vec2 st) {\n   return fract(sin(dot(st.xy,vec2(12.9898,78.233))) * 43758.5453123);\n}\n\nfloat noise (in float x) {\n   \n   // split x int its integer and fraction.\n   float i = floor(x);\n   float f = fract(x);\n   \n   float r = random(vec2(i, 1.0));\n   float r_next = random(vec2(i + 1.0, 1.0));\n   // return r;\n   // return mix(r, r_next, f);\n   return mix(r, r_next, smoothstep(0.0, 1.0, f));\n}\n\nvec2 rotate2D(vec2 _st, float _angle){\n   _st -= 0.5;\n   _st =  mat2(cos(_angle),-sin(_angle),\n   sin(_angle),cos(_angle)) * _st;\n   _st += 0.5;\n   return _st;\n}\n\n\nfloat posSin(in float val) {\n   return (sin(val) + 1.0) / 2.0;\n}\n\nvec2 tile(vec2 _st, float _zoom){\n    // make it perfectly square\n   float aspect = iResolution.y / iResolution.x; \n   _st.y *= _zoom * aspect;\n   _st.x *= _zoom;\n   return fract(_st);\n}\n\nfloat box(vec2 _st, vec2 _size, float _smoothEdges){\n   _size = vec2(0.5)-_size*0.5;\n   vec2 aa = vec2(_smoothEdges*0.5);\n   vec2 uv = smoothstep(_size,_size+aa,_st);\n   uv *= smoothstep(_size,_size+aa,vec2(1.0)-_st);\n   return uv.y * uv.x;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\t\n   // noisify ALL the values!!!1\n   \n   vec2 st = fragCoord.xy / iResolution.xy;\n   vec3 color = vec3(0.0);\n   float tileNum = 3. + noise(iTime * 0.1 + 59349.0) * 5.;\n   \n   // Save original coordinates for later\n   vec2 st_orig = st;\n   \n   // Divide the space in tileNum (eg. 5)\n   st = tile(st, tileNum);\n   \n   // Calculate distance of vec(sinus time) and the actual position\n   float dist = distance(st_orig, vec2(noise(iTime), noise(iTime + 3000.)));\n   \n   // maxDist defines the radius of effect\n   // lower it, to see the diagonal movement (eg. try 0.1 * ...)\n   float maxDist = 1.0 * noise(iTime + 22355.);\n   \n   float rotation = smoothstep(0.0, maxDist, dist);\n   \n   // Use a matrix to rotate the space\n   st = rotate2D(st, PI * rotation);\n   \n   // Draw a square\n   color = vec3(box(st,vec2(0.7),0.01));\n   // fade gray along the x axis of each square\n   float fade = st.x;\n   \n   color *= mix(color, vec3(fade), (cos(iTime) + 1.0) * 0.5);\n   color *= vec3(noise(iTime * 0.5 + 1000.), noise(iTime * 0.5), noise(iTime + 800. * 0.5));\n   \n   fragColor = vec4(color, color.r * dist);\n}\n\n/** SHADERDATA\n{\n\t\"title\": \"Wobbly Wob\",\n\t\"description\": \"Wobbly wobs wobblying around.\",\n\t\"model\": \"person\"\n}\n*/\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n/* //drag the window LR to control roughness\n\n//--graphics setting (lower = better fps)---------------------------------------------------------------------\n#define AVERAGECOUNT 16\n#define MAX_BOUNCE 32\n\n//--scene data---------------------------------------------------------------------\n#define SPHERECOUNT 6\n//xyz = pos, w = radius\nconst vec4 AllSpheres[SPHERECOUNT]=vec4[SPHERECOUNT](\n    vec4(0.0,0.0,0.0,2.0),//sphere A\n    vec4(0.0,0.0,-1.0,2.0),//sphere B\n    vec4(0.0,-1002.0,0.0,1000.0),//ground\n    vec4(0.0,0.0,+1002,1000.0),//back wall\n    vec4(-1004.0,0.0,0.0,1000.0),//left wall    \n    vec4(+1004.0,0.0,0.0,1000.0)//right wall\n);\n//-----------------------------------------------------------------------\nfloat raySphereIntersect(vec3 r0, vec3 rd, vec3 s0, float sr) {\n    // - r0: ray origin\n    // - rd: normalized ray direction\n    // - s0: sphere center\n    // - sr: sphere radius\n    // - Returns distance from r0 to first intersecion with sphere,\n    //   or -1.0 if no intersection.\n    float a = dot(rd, rd);\n    vec3 s0_r0 = r0 - s0;\n    float b = 2.0 * dot(rd, s0_r0);\n    float c = dot(s0_r0, s0_r0) - (sr * sr);\n    if (b*b - 4.0*a*c < 0.0) {\n        return -1.0;\n    }\n    return (-b - sqrt((b*b) - 4.0*a*c))/(2.0*a);\n}\n//-----------------------------------------------------------------------\nstruct HitData\n{\n    float rayLength;\n    vec3 normal;\n};\nHitData AllObjectsRayTest(vec3 rayPos, vec3 rayDir)\n{\n    HitData hitData;\n    hitData.rayLength = 999999.0;\n\n    for(int i = 0; i < 6; i++)\n    {\n        vec3 sphereCenter = AllSpheres[i].xyz;\n        float sphereRadius = AllSpheres[i].w;\n        //----hardcode sphere pos animations-------------------------------------\n        if(i == 0)\n        {\n            float t = fract(iTime * 0.7);\n            t = -4.0 * t * t + 4.0 * t;\n            sphereCenter.y += t * 0.7;\n            \n            sphereCenter.x += sin(iTime) * 2.0;\n            sphereCenter.z += cos(iTime) * 2.0;\n        }\n             \n        if(i == 1)\n        {\n            float t = fract(iTime*0.47);\n            t = -4.0 * t * t + 4.0 * t;\n            sphereCenter.y += t * 1.7;\n            \n            sphereCenter.x += sin(iTime+3.14) * 2.0;\n            sphereCenter.z += cos(iTime+3.14) * 2.0;\n        }             \n        //---------------------------------------\n                \n        float resultRayLength = raySphereIntersect(rayPos,rayDir,sphereCenter,sphereRadius);\n        if(resultRayLength < hitData.rayLength && resultRayLength > 0.001)\n        {\n            //if a shorter(better) hit ray found, update\n            hitData.rayLength = resultRayLength;\n            vec3 hitPos = rayPos + rayDir * resultRayLength;\n    \t\thitData.normal = normalize(hitPos - sphereCenter);\n        }\n    }\n    \n    //all test finished, return shortest(best) hit data\n    return hitData;\n}\n//--random functions-------------------------------------------------------------------\nfloat rand01(float seed) { return fract(sin(seed)*43758.5453123); }\nvec3 randomInsideUnitSphere(vec3 rayDir,vec3 rayPos, float extraSeed)\n{\n    return vec3(rand01(iTime * (rayDir.x + rayPos.x + 0.357) * extraSeed),\n                rand01(iTime * (rayDir.y + rayPos.y + 16.35647) *extraSeed),\n                rand01(iTime * (rayDir.z + rayPos.z + 425.357) * extraSeed));\n}\n//---------------------------------------------------------------------\nvec4 calculateFinalColor(vec3 cameraPos, vec3 cameraRayDir, float AAIndex)\n{\n    //init\n    vec3 finalColor = vec3(0.0);\n    float absorbMul = 1.0;\n    vec3 rayStartPos = cameraPos;\n    vec3 rayDir = cameraRayDir;\n    \n    //only for CineShader, to show depth\n    float firstHitRayLength = -1.0;\n    \n    //can't write recursive function in GLSL, so write it in a for loop\n    //will loop until hitting any light source / bounces too many times\n    for(int i = 0; i < 16; i++)\n    {\n        HitData h = AllObjectsRayTest(rayStartPos + rayDir * 0.0001,rayDir);//+0.0001 to prevent ray already hit @ start pos\n        \n        //only for CineShader, to show depth\n        firstHitRayLength = firstHitRayLength < 0.0 ? h.rayLength : firstHitRayLength;\n        \n        if(h.rayLength > 99999.0)\n        {\n            vec3 skyColor = vec3(0.7,0.85,1.0);//hit nothing = hit sky color\n            finalColor = skyColor * absorbMul;\n            break;\n        }   \n               \n\t\tabsorbMul *= 0.8; //every bounce absorb some light(more bounces = darker)\n        \n        //update rayStartPos for next bounce\n\t\trayStartPos = rayStartPos + rayDir * h.rayLength; \n        //update rayDir for next bounce\n        float rougness = 0.05 + iMouse.x / iResolution.x; //hardcode \"drag the window LR to control roughness\"\n\t\trayDir = normalize(reflect(rayDir,h.normal) + randomInsideUnitSphere(rayDir,rayStartPos,AAIndex) * rougness);       \n    }\n    \n    return vec4(finalColor,firstHitRayLength);//alpha nly for CineShader, to show depth\n}\n//-----------------------------------------------------------------------\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n\tuv = uv * 2.0 - 1.0;//transform from [0,1] to [-1,1]\n    uv.x *= iResolution.x / iResolution.y; //aspect fix\n\n    vec3 cameraPos = vec3(sin(iTime * 0.47) * 4.0,sin(iTime * 0.7)*8.0+6.0,-25.0);//camera pos animation\n    vec3 cameraFocusPoint = vec3(0,0.0 + sin(iTime),0);//camera look target point animation\n    vec3 cameraDir = normalize(cameraFocusPoint - cameraPos);\n    \n    //TEMPCODE: fov & all ray init dir, it is wrong!!!!\n    //----------------------------------------------------\n    float fovTempMul = 0.2 + sin(iTime * 0.4) * 0.05;//fov animation\n    vec3 rayDir = normalize(cameraDir + vec3(uv,0) * fovTempMul);\n    //----------------------------------------------------\n\n    vec4 finalColor = vec4(0);\n    for(int i = 1; i <= 16; i++)\n    {\n        finalColor+= calculateFinalColor(cameraPos,rayDir, float(i));\n    }\n    finalColor = finalColor/float(AVERAGECOUNT);//brute force AA & denoise\n    finalColor.rgb = pow(finalColor.rgb,vec3(1.0/2.2));//gamma correction\n    \n    //only for CineShader, to show depth\n    float z = finalColor.w; //z is linear world space distance from camera to surface\n    float cineShaderZ; //expect 0~1\n    cineShaderZ = pow(clamp(1.0 - max(0.0,z-21.0) * (1.0/6.0),0.0,1.0),2.0);\n    \n    //result\n    fragColor = vec4(finalColor.rgb,cineShaderZ);\n} */\n\n\n\n\n\n\n\n\n// ==============\n//  `GL_ES` TEST\n// ==============\n\n/* precision mediump float;\n\n#define RADIANS 0.017453292519943295\n\nconst int zoom = 40;\nconst float brightness = 0.975;\nfloat fScale = 1.25;\n\nfloat cosRange(float degrees, float range, float minimum) {\n\treturn (((1.0 + cos(degrees * RADIANS)) * 0.5) * range) + minimum;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tfloat time = iTime * 1.25;\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\tvec2 p  = (2.0*fragCoord.xy-iResolution.xy)/max(iResolution.x,iResolution.y);\n\tfloat ct = cosRange(time*5.0, 3.0, 1.1);\n\tfloat xBoost = cosRange(time*0.2, 5.0, 5.0);\n\tfloat yBoost = cosRange(time*0.1, 10.0, 5.0);\n\t\n\tfScale = cosRange(time * 15.5, 1.25, 0.5);\n\t\n\tfor(int i=1;i<zoom;i++) {\n\t\tfloat _i = float(i);\n\t\tvec2 newp=p;\n\t\tnewp.x+=0.25/_i*sin(_i*p.y+time*cos(ct)*0.5/20.0+0.005*_i)*fScale+xBoost;\t\t\n\t\tnewp.y+=0.25/_i*sin(_i*p.x+time*ct*0.3/40.0+0.03*float(i+15))*fScale+yBoost;\n\t\tp=newp;\n\t}\n\t\n\tvec3 col=vec3(0.5*sin(3.0*p.x)+0.5,0.5*sin(3.0*p.y)+0.5,sin(p.x+p.y));\n\tcol *= brightness;\n    \n    // Add border\n    float vigAmt = 5.0;\n    float vignette = (1.-vigAmt*(uv.y-.5)*(uv.y-.5))*(1.-vigAmt*(uv.x-.5)*(uv.x-.5));\n\tfloat extrusion = (col.x + col.y + col.z) / 4.0;\n    extrusion *= 1.5;\n    extrusion *= vignette;\n    \n\tfragColor = vec4(col, extrusion);\n}\n\n\n\n\n\n\n\n\n// ============\n//  MODEL TEST\n// ============\n\n/** SHADERDATA\n{\n\t\"title\": \"70s Melt\",\n\t\"description\": \"Variation of Sine Puke\",\n\t\"model\": \"car\"\n}\n*/\n\n\n\n\n/* void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord / iResolution.xy;\n    \n    // Calculate the to center distance\n    float d = length(uv - 0.5) * 2.0;\n    \n    // Calculate the ripple time\n    float t = d * d * 25.0 - iTime * 3.0;\n    \n    // Calculate the ripple thickness\n    d = (cos(t) * 0.5 + 0.5) * (1.0 - d);\n    \n    // Time varying pixel color\n    vec3 col = 0.5 + 0.5 * cos(t / 20.0 + uv.xyx + vec3(0.0,2.0,4.0));\n\n    // Set the output color to rgb channels and the thickness to alpha channel\n    // AO is automatically calculated\n    fragColor = vec4(col, d);\n}\n\n/** SHADERDATA\n{\n\t\"title\": \"Pirellyon\",\n\t\"description\": \"Next world\",\n\t\"model\": \"nothing\"\n}\n*/\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wttyWB.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[26, 161, 188, 188, 261], [263, 263, 289, 337, 569], [571, 571, 609, 609, 732], [735, 735, 763, 763, 799], [801, 801, 834, 866, 987], [989, 989, 1041, 1041, 1231], [1234, 1234, 1291, 1326, 2390]]}
{"id": "Wttyzf", "name": "Test Halo Waves", "author": "TestCoder", "description": "tutorial", "tags": ["tutorial", "trippy"], "likes": 3, "viewed": 66, "published": "Public", "date": "1609638685", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// http://www.pouet.net/prod.php?which=57245\n// If you intend to reuse this shader, please add credits to 'Danilo Guanabara'\n// https://www.shadertoy.com/view/XsXXDn\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n\tvec3 haloColors;\n\tfloat distance;\n    float brightnessDiffuse = 2.;\n    float waveNear = 1.;\n    float fov = 15.;\n    float wavingSpeed = .5;\n    float timeStepOffset = .5;\n\n\tfor(int index = 0; index < 3; index++) {\n        float time = iTime + timeStepOffset * float(index);\n\t\tvec2 coordinates2D, aspectRatio = fragCoord.xy / iResolution.xy;\n\n        // assign aspect ratio to, uv\n\t\tcoordinates2D = aspectRatio;\n\n        // centering aspect ratio\n\t\taspectRatio -= .5;\n\n        // scaling aspect ratio axis to fit square coordinates\n\t\taspectRatio.x *= iResolution.x / iResolution.y;\n\n        // offsets time for each axis\n\t\ttime += timeStepOffset;\n        \n        // gets distance from vec2(0,0)\n        distance = length(aspectRatio);\n        \n        // magic 1: study\n\t\tcoordinates2D += aspectRatio / distance * (sin(time) + waveNear) * abs(sin(distance * fov - time));\n\n        // magic 2: study again\n\t\thaloColors[index] = length(abs(mod(coordinates2D, 1.) - .5));\n\t}\n\n    // dividing for distance to get light\n\tfragColor=vec4(haloColors / distance / brightnessDiffuse, 1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Wttyzf.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 167, 223, 223, 1307]]}
{"id": "WtVcD1", "name": "Quad - gradient 2D", "author": "iq", "description": "Signed distance and gradient to a (rounded) quad. Faster than central differences or automatic differentiation/dual numbers most probably.", "tags": ["2d", "distancefield", "sdf", "gradient", "distance", "quad"], "likes": 7, "viewed": 391, "published": "Public API", "date": "1610944508", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// The MIT License\n// Copyright © 2021 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// Signed distance and gradient to a quad. Probably\n// faster than central differences or automatic \n// differentiation/dual numbers.\n\n// List of other 2D distances+gradients:\n//\n// https://iquilezles.org/www/articles/distgradfunctions2d/distgradfunctions2d.htm\n//\n// and\n//\n// https://www.shadertoy.com/playlist/M3dSRf\n\n\n\n// .x = f(p)\n// .y = ∂f(p)/∂x\n// .z = ∂f(p)/∂y\n// .yz = ∇f(p) with ‖∇f(p)‖ = 1\nfloat cro( in vec2 a, in vec2 b ) { return a.x*b.y - a.y*b.x; }\nvec3 sdgQuad( in vec2 p, in vec2 v[4] )\n{\n    float gs = cro(v[0]-v[3],v[1]-v[0]);\n    vec4 res;\n    \n    // edge 0\n    {\n    vec2  e = v[1]-v[0];\n    vec2  w = p-v[0];\n    vec2  q = w-e*clamp(dot(w,e)/dot(e,e),0.0,1.0);\n    float d = dot(q,q);\n    float s = gs*cro(w,e);\n    res = vec4(d,q,s);\n    }\n    \n    // edge 1\n    {\n\tvec2  e = v[2]-v[1];\n    vec2  w = p-v[1];\n    vec2  q = w-e*clamp(dot(w,e)/dot(e,e),0.0,1.0);\n    float d = dot(q,q);\n    float s = gs*cro(w,e);\n    res = vec4( (d<res.x) ? vec3(d,q) : res.xyz,\n                (s>res.w) ?      s    : res.w );\n    }\n    \n    // edge 2\n    {\n\tvec2  e = v[3]-v[2];\n    vec2  w = p-v[2];\n    vec2  q = w-e*clamp(dot(w,e)/dot(e,e),0.0,1.0);\n    float d = dot(q,q);\n    float s = gs*cro(w,e);\n    res = vec4( (d<res.x) ? vec3(d,q) : res.xyz,\n                (s>res.w) ?      s    : res.w );\n    }\n\n    // edge 3\n    {\n    vec2  e = v[0]-v[3];\n    vec2  w = p-v[3];\n    vec2  q = w-e*clamp(dot(w,e)/dot(e,e),0.0,1.0);\n    float d = dot(q,q);\n    float s = gs*cro(w,e);\n    res = vec4( (d<res.x) ? vec3(d,q) : res.xyz,\n                (s>res.w) ?      s    : res.w );\n    }    \n    \n    // distance and sign\n    float d = sqrt(res.x)*sign(res.w);\n    \n    return vec3(d,res.yz/d);\n}\n\n#define AA 2\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 tot = vec3(0.0);\n    \n    #if AA>1\n    for( int m=0; m<AA; m++ )\n    for( int n=0; n<AA; n++ )\n    {\n        // pixel coordinates\n        vec2 o = vec2(float(m),float(n)) / float(AA) - 0.5;\n        vec2 p = (-iResolution.xy + 2.0*(fragCoord+o))/iResolution.y;\n        #else    \n        vec2 p = (-iResolution.xy + 2.0*fragCoord)/iResolution.y;\n        #endif\n\n        // animate\n        float time = iTime;\n        vec2 v[4] = vec2[4](\n            vec2(-0.9,-0.5) + 0.3*cos( 0.5*time + vec2(0.0,1.9) + 4.0 ),\n            vec2( 0.9,-0.5) + 0.3*cos( 0.7*time + vec2(0.0,1.7) + 2.0 ),\n            vec2( 0.9, 0.5) + 0.3*cos( 0.9*time + vec2(0.0,1.3) + 1.0 ),\n            vec2(-0.9, 0.5) + 0.3*cos( 1.1*time + vec2(0.0,1.5) + 0.0 ) );\n\n        // corner radious\n        float ra = 0.1*(0.5+0.5*sin(iTime*1.2));\n\n\n        // sdf(p) and gradient(sdf(p))\n        vec3  dg = sdgQuad(p,v);\n        float d = dg.x-ra;\n        vec2  g = dg.yz;\n\n        // central differenes based gradient, for comparison\n        // g = vec2(dFdx(d),dFdy(d))/(2.0/iResolution.y);\n\n        // coloring\n        vec3 col = (d>0.0) ? vec3(0.9,0.6,0.3) : vec3(0.4,0.7,0.85);\n        col *= 1.0 + vec3(0.5*g,0.0);\n      //col = vec3(0.5+0.5*g,1.0);\n        col *= 1.0 - 0.7*exp(-8.0*abs(d));\n        col *= 0.9 + 0.1*cos(150.0*d);\n        col = mix( col, vec3(1.0), 1.0-smoothstep(0.0,0.01,abs(d)) );\n\n \t    tot += col;\n    #if AA>1\n    }\n    tot /= float(AA*AA);\n    #endif\n\n\tfragColor = vec4( tot, 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WtVcD1.jpg", "access": "shaders20k", "license": "mit", "functions": [[1401, 1496, 1531, 1531, 1559], [1560, 1560, 1601, 1601, 2796], [2812, 2812, 2869, 2869, 4353]]}
{"id": "wtVcDK", "name": "Fractal 07_gaz", "author": "gaz", "description": "3d", "tags": ["fractal"], "likes": 10, "viewed": 132, "published": "Public", "date": "1611823567", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define rot(a) mat2(cos(a),sin(a),-sin(a),cos(a))\nfloat orbit;\n\nfloat map(vec3 p){\n\tp.yz*=rot(iTime*0.1+2.);\n    p.xz*=rot(iTime*0.2+2.);\n\tp=abs(p)-3.5;\n\tif(p.x<p.z)p.xz=p.zx;\n\tif(p.y<p.z)p.yz=p.zy;\n \tif(p.x<p.y)p.xy=p.yx;\n \tfloat s=3.;\n\tvec3  p0=p*1.2;\n\tfor(float i=0.;i<5.;i++){\n\t\tp=1.-abs(p-1.);\n  \t\tfloat k=-6.5*clamp(.5*max(1.8/dot(p,p),.8),0.,1.);\n    \ts*=abs(k);\n   \t\tp*=k;\n        p+=p0;\n    \tp.yz*=rot(-1.0);\n    }\n\torbit = log2(s);\n\tfloat a=3.;\n\tp.xy-=clamp(p.xy,-a,a);\n\treturn length(p.xy)/s;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv=(2.*fragCoord-iResolution.xy)/iResolution.y;\n\tvec3 ro=vec3(0,0,-20);\n    vec3 rd=normalize(vec3(uv,3));\n    float h=0.,d,i;\n\tfor(i=1.;i<100.;i++)\n    {\n        d=map(ro+rd*h);\n        if(d<.001)break;\n        h+=d;\n\t}\n    fragColor.xyz+=20.*(cos(vec3(9,5,12)+orbit*3.)*.5+.5)/i;\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtVcDK.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[64, 64, 82, 82, 505], [507, 507, 564, 564, 854]]}
{"id": "wtVcDt", "name": "Yet Another Julia Set", "author": "lesleylai", "description": "A simple visualization of Julia set", "tags": ["fractals", "complexnumbers"], "likes": 2, "viewed": 62, "published": "Public", "date": "1612015707", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Configurations\nconst int max_iteration = 200;\nconst float r2 = 100.;\n\nvec2 get_c() {\n  return vec2(\n    -0.512511498387847167 + sin(iTime / 20.) * 0.005,\n     0.521295573094847167 + cos(iTime / 20.) * 0.005\n  );\n}\n\nvec2 get_scale() {\n vec2 s = vec2(2.0, 2.0);\n s *= cos(iTime / 10.) * 0.4 + 0.6;\n return s;\n}\n\nconst int AA = 2;\n\n// Complex number\nstruct Complex {\n  vec2 data;\n};\n\nComplex complex_mult(Complex lhs, Complex rhs) {\n  return Complex(mat2(lhs.data, -lhs.data.y, lhs.data.x) * rhs.data);\n}\n\nComplex complex_plus(Complex lhs, Complex rhs) {\n  return Complex(lhs.data + rhs.data);\n}\n\n\nfloat complex_norm(Complex c) {\n  return dot(c.data, c.data);\n}\n\n// Main\nvec3 color_at(in vec2 coord) {\n    vec3 col;\n\n    Complex z = Complex(coord);\n    Complex c = Complex(get_c());\n    \n    int i = 0;\n    while (i < max_iteration && complex_norm(z) < r2) {\n      z = complex_plus(complex_mult(z, z), c);\n      ++i;\n    }\n    \n    if (i == max_iteration) {\n      col = vec3(0.8, 1.0, 0.8);\n    } else {\n      float x = float(i) / float(max_iteration);\n      x = pow(x, 0.2);\n      col = vec3(x / 2.0, x, x / 2.0);\n   }\n   \n   return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 col;\n    for (int i = 0; i < AA; ++i) {\n        for (int j = 0; j < AA; ++j) {\n            vec2 offset = -0.5 + vec2(float(i), float(j)) / float(AA);\n            vec2 coord = (fragCoord + offset - 0.5 * iResolution.xy) / - iResolution.y;\n            coord *= get_scale();\n            col += color_at(coord);\n        }\n    }\n    col /= float(AA * AA);\n\n\n\n\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtVcDt.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 73, 87, 87, 216], [218, 218, 236, 236, 311], [332, 384, 432, 432, 504], [506, 506, 554, 554, 595], [598, 598, 629, 629, 661], [663, 671, 701, 701, 1140], [1142, 1142, 1199, 1199, 1596]]}
{"id": "wtVcDV", "name": "lines are too hard", "author": "aliser", "description": "-", "tags": ["whatever"], "likes": 0, "viewed": 160, "published": "Public API", "date": "1611840018", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float calculateSlope(vec2 fromXY, vec2 toXY) {\n    return (toXY.y - fromXY.y) / (toXY.x - fromXY.x);\n}\n\nfloat calculateTheB(vec2 tipPnt, float slope) {\n    return tipPnt.y - slope * tipPnt.x;\n}\n\nfloat calculateYforX(float slope, float x, float b) {\n    return slope * x + b;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 lineSegmentFromXY = vec2(128.0, 256.0);\n    vec2 lineSegmentToXY = iMouse.xy;\n    float tolerance = 5.0;\n    \n    float slope = calculateSlope(lineSegmentFromXY, lineSegmentToXY);\n    float b = calculateTheB(lineSegmentFromXY, slope);\n    float targetY = calculateYforX(slope, fragCoord.x, b);\n    \n    bool withinLine = abs(targetY - fragCoord.y) <= tolerance;\n    bool withinHorizontalBound = fragCoord.x >= min(lineSegmentFromXY.x, lineSegmentToXY.x) && \n                                 fragCoord.x <= max(lineSegmentFromXY.x, lineSegmentToXY.x);\n    bool withinVerticalBound = fragCoord.y >= min(lineSegmentFromXY.y, lineSegmentToXY.y) && \n                               fragCoord.y <= max(lineSegmentFromXY.y, lineSegmentToXY.y);\n    bool shouldDraw = withinLine && withinHorizontalBound && withinVerticalBound;\n    vec3 col = vec3(1., 1., 1.);\n    if(shouldDraw) {\n        // Normalized pixel coordinates (from 0 to 1)\n        vec2 uv = fragCoord/iResolution.xy;\n\n        // Time varying pixel color\n        col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));   \n    }\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtVcDV.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 46, 46, 102], [104, 104, 151, 151, 193], [195, 195, 248, 248, 276], [278, 278, 335, 335, 1472]]}
{"id": "wtVcDw", "name": "hair on screen 2", "author": "FabriceNeyret2", "description": "reproduce the color effect of hair on an CRT, LCD or OLED screen, due to the correlation in the masking of the color grid.\ncompare to [url] https://shadertoy.com/view/3tyyDw[/url], the effect is now subpixel:\na white pixel is indeed made of 3 color bars.", "tags": ["aliasing", "subpixel", "correlation", "chromophore"], "likes": 4, "viewed": 231, "published": "Public API", "date": "1611159995", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// variant of https://shadertoy.com/view/3tyyDw\n\nvoid mainImage( out vec4 O, vec2 U )\n{\n    vec2 R = iResolution.xy;\n\n#define p 4.\n#define D(U) ( V = pow( abs(U),vec2(p)), pow(V.x+V.y,1./(p)) )\n\n#define draw smoothstep(.5,0., abs( D(U-.5*R-5.*vec2(sin(iTime),0)) - R.y*.4 ) )\n\n    O = vec4(1);\n    vec2 V;\n    U-=.5;       O.r -= draw;\n    U.x += .333; O.g -= draw;\n    U.x += .333; O.b -= draw;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtVcDw.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 49, 87, 87, 397]]}
{"id": "wtVcR3", "name": "floating in the sea", "author": "changwenhan", "description": "practicing sin wave and color mixing", "tags": ["2d"], "likes": 8, "viewed": 111, "published": "Public", "date": "1611502093", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define sin(x) sin(mod(x,radians(360.)))\n\nfloat rand(vec2 p) {\n    p = fract(p * vec2(324.456, 863.789));\n    p += dot(p, p+89.56);\n    return fract(p.x*p.y);\n}\n\nfloat Wave(vec2 uv, float offset) {\n    uv.x += offset;\n    \n    return (    \n                sin(uv.x*48.313 + 312.123) + \n                sin(uv.x*10.) + \n                sin(uv.x*31. + 1.42) +\n                sin(uv.x*61.33 + 123.142) +\n                sin(uv.x*3.14)\n           ) / 5.\n           \n           *sin(uv.x*3.14*3.1)*1.3;\n}\n\n\nfloat Moon(vec2 uv, float radius) {\n    return step(length(uv), radius);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord.xy-0.5*iResolution.xy)/iResolution.y;\n    vec2 moon_uv = uv;\n    \n    uv.y *= 10.;\n    \n    vec3 col;\n    \n    float border = .1;\n    \n    vec3 line_color = vec3(.8,.8,.8);\n    vec3 back_blue = vec3(.3,.4,.8) * .1;\n    vec3 back_lightblue = vec3(.3,.4,.8) * .7;\n    vec3 yellow = vec3(.9,.9,.5);\n    \n    float layers = 14.;\n    \n    for(float i=0.;i<layers/2.3;i+=1.) {\n        float offs = (layers/2.-i)*.5 + sin(iTime+i*321.131)*.1;\n        float waveOffs = layers/2.-i;\n        \n        waveOffs += 321.431 + iTime*(i+2.341)*.005 + rand(vec2(123.32,i))*iTime*.1 + rand(vec2(123.32,i))*.4;\n\n        float wave = Wave(uv, waveOffs) * 0.5;\n        \n        float new_line = step(wave-border*.5, uv.y-offs) - step(wave+border*.5, uv.y-offs);\n        float new_line_bottom = 1.-step(wave-border*.5, uv.y-offs);\n        \n        vec3 back_color = mix(back_lightblue, back_blue, 1.-i/layers);\n        \n        col = mix(col, line_color, new_line);\n        col = mix(col, back_color, new_line_bottom);\n\n    }\n    \n    col = mix(col, yellow, Moon(moon_uv, .2));\n    \n    for(float i=layers/2.3;i<layers;i+=1.) {\n        float offs = (layers/2.-i)*.5 + sin(iTime+i*321.131)*.1;\n        float waveOffs = layers/2.-i;\n        \n        waveOffs += 321.431 + iTime*(i+2.341)*.005 + rand(vec2(123.32,i))*iTime*.1 + rand(vec2(123.32,i))*.4;\n\n        float wave = Wave(uv, waveOffs) * 0.5;\n                \n        float new_line_bottom = 1.-step(wave-border*.5, uv.y-offs);\n        float new_line = step(wave-border*.5, uv.y-offs) - step(wave+border*.5, uv.y-offs);\n        \n        \n        float moonOffs = Wave(uv.yx, waveOffs)*.3;\n        vec2 v = vec2(moon_uv.x + moonOffs*.1, moon_uv.y);\n        float moon = Moon(v, .2) * step(uv.y-offs, wave+border*.5);\n        \n        vec3 back_color = mix(back_lightblue, back_blue, i/layers);\n        \n        col = mix(col, back_color, new_line_bottom);\n        col = mix(col, yellow, moon * (1. - i/layers) * 0.5);\n        col = mix(col, line_color, new_line);\n\n    }\n    \n    vec2 box_size = vec2(.85,.85);\n    float box_border = .02;\n    \n    float box = step(abs(uv.x), box_size.x/2.) * step(abs(uv.y), box_size.y/2. * 10.);\n    float smbox = step(abs(uv.x), box_size.x/2.-box_border) * step(abs(uv.y), (box_size.y/2.-box_border) * 10.);\n    \n    col *= box;\n    col = mix(col, line_color, box - smbox);\n    col = mix(back_blue*3., col , length(col));    \n    \n    //if( abs(fragCoord.x-iResolution.x/2.) < 1.) col.g = 1.;\n    //if( abs(fragCoord.y-iResolution.y/2.) < 1.) col.r = 1.;\n    \n    // Output to screen\n    fragColor = vec4(vec3(col),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtVcR3.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[42, 42, 62, 62, 160], [162, 162, 197, 197, 500], [503, 503, 538, 538, 577], [579, 579, 636, 636, 3253]]}
{"id": "WtVczt", "name": "wormhole memory", "author": "YitingLiu", "description": "experiment with colors and time using noise function. ", "tags": ["noise", "texture", "circle", "gradient", "metallic"], "likes": 0, "viewed": 152, "published": "Public API", "date": "1611589383", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI 3.141592653\n\nvec2 random2(vec2 st){\n    st = vec2( dot(st,vec2(127.1,311.7)),\n              dot(st,vec2(269.5,183.3)) );\n    return -1.0 + 2.0*fract(sin(st)*43758.5453123);\n}\n\n// Gradient Noise by Inigo Quilez - iq/2013\n// https://www.shadertoy.com/view/XdXGW8\nfloat noise(vec2 st) {\n    vec2 i = floor(st);\n    vec2 f = fract(st);\n\n    vec2 u = f*f*(3.0-2.0*f);\n\n    return mix( mix( dot( random2(i + vec2(0.0,0.0) ), f - vec2(0.0,0.0) ),\n                     dot( random2(i + vec2(1.0,0.0) ), f - vec2(1.0,0.0) ), u.x),\n                mix( dot( random2(i + vec2(0.0,1.0) ), f - vec2(0.0,1.0) ),\n                     dot( random2(i + vec2(1.0,1.0) ), f - vec2(1.0,1.0) ), u.x), u.y);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //vec2 st = fragCoord.xy/iResolution.xy;\n    //st.x *= iResolution.x/iResolution.y;\n    \n    // suggested by @FabriceNeyret2 \n    vec2 st = fragCoord / iResolution.y;  \n    vec3 color = vec3(0.0);\n\n    float t = 1.0;\n    // Uncomment to animate\n     t = abs(1.0-sin(iTime*.1))*0.5;\n    // Comment and uncomment the following lines:\n    st /= noise(st*2.)*t; // Animate the coordinate space\n    color = vec3(1.) * smoothstep(0.1,0.8,noise(st)); // Big black drops\n    color -= smoothstep(0.1,0.5,noise(st*10.)); // Black splatter\n    color += smoothstep(1.-cos(iTime),1.-cos(iTime)+0.2,noise(st*10.)); // Holes on splatter\n\n    vec3 col = 0.5 + 0.5*cos(iTime+st.xyx+vec3(0,2,4));\n\n    fragColor = vec4(color*noise(st)/col/1e2-col*vec3(PI,(cos(st.x)-sin(st.y))*0.5, atan(st.y,st.x)),1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WtVczt.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[24, 24, 46, 46, 185], [187, 272, 294, 294, 698], [700, 700, 757, 887, 1550]]}
{"id": "WtVczV", "name": "fridge grinder", "author": "jake_tobin", "description": "rectangle flip gradients", "tags": ["time"], "likes": 1, "viewed": 39, "published": "Public", "date": "1611514882", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\nfloat norm_sin(float val) {\n\treturn (sin(val)+1.0)/2.0;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\t\n\tfloat b = 300.0;\n\tfloat h = 100.0;\n\tfloat w = 30.0;\n\t\n\tbool xflip = mod(fragCoord.x, w) < w/2.0 ? true : false;\n\t\n\tfloat ygrade = ((fragCoord.y - (floor(fragCoord.y/h))*h)/h);\n\t\n\tfloat grade = xflip ? ygrade : 1.0-ygrade;\n\n\tfragColor = vec4( norm_sin(iTime/2.0)/grade, norm_sin(iTime/5.)*grade, norm_sin(iTime/10.)*grade,1.0 );\n\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WtVczV.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 1, 28, 28, 58], [60, 60, 117, 117, 451]]}
{"id": "WtVyDd", "name": "Neural gimme five!", "author": "kastorp", "description": "Thanks Blacke! You did a  great job in python\nas many others, I tried it with my hands :)\n", "tags": ["sdf", "neural", "siren"], "likes": 9, "viewed": 155, "published": "Public", "date": "1612017988", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//CC0 1.0 Universal https://creativecommons.org/publicdomain/zero/1.0/\n//To the extent possible under law, Blackle Mori has waived all copyright and related or neighboring rights to this work.\n//UPDATE 18/8/2021 used new script by goingdigital:  https://www.shadertoy.com/view/sd33zN\n\n\n//original hand obj file here https://www.cgtrader.com/items/810024/download-page\n//add these lines in colab script after \"    mesh = trimesh.load(filename)\" to resize and rotate model\n/*\n    origin, xaxis, yaxis, zaxis = [0, 0, 0], [1, 0, 0], [0, 1, 0], [0, 0, 1]\n    mesh.apply_transform(trimesh.transformations.scale_matrix(0.02, origin))\n    mesh.apply_transform(trimesh.transformations.rotation_matrix(-3.141/2, xaxis))\n*/\n\n//tried different configurations and loss functions\n#define LEVEL 0  //3-2-1= adapted Blacke training script with different configurations,  0=goingdigital script \n\nvec3 erot(vec3 p, vec3 ax, float ro) {\n    return mix(dot(p,ax)*ax,p,cos(ro))+sin(ro)*cross(ax,p);\n}\n\n#if LEVEL==3\n//model generated from my colab notebook, which is an adaptation of Blackle one\n//https://colab.research.google.com/drive/1UK-qTCHnoEnLTHlkRgPSsV78jekgRBO0?usp=sharing\n//train_siren(sdfloader, 32, 4, 20) loss = (model_output - truth)**2\nfloat scene(vec3 p) {\n    if (length(p) > 1.) return length(p)-.8;\nvec4 f0_0=sin(p.y*vec4(.1092,-.7487,-.3145,2.0425)+p.z*vec4(-1.1557,-3.8362,.4454,3.7463)+p.x*vec4(-.1078,-1.2005,.3838,.3697)+vec4(-2.6188,-4.4628,-1.6874,-6.2460));\nvec4 f0_1=sin(p.y*vec4(2.8164,-1.6708,-3.8982,-1.2813)+p.z*vec4(3.6428,4.3387,-3.5679,-2.0770)+p.x*vec4(3.2024,.6757,.2961,-3.3966)+vec4(-1.6055,-4.8136,-3.4581,5.1315));\nvec4 f0_2=sin(p.y*vec4(4.5015,-1.7450,4.4780,-1.3733)+p.z*vec4(1.6196,1.6529,-2.1594,2.5309)+p.x*vec4(3.1566,2.2963,4.6800,-2.6905)+vec4(1.3524,3.2559,4.9643,1.2707));\nvec4 f0_3=sin(p.y*vec4(2.9692,1.9674,.2758,-3.0875)+p.z*vec4(.2048,-2.6904,2.4808,-.3322)+p.x*vec4(-.1545,-2.8370,-3.2862,-1.0485)+vec4(-5.3331,-2.0173,-2.1306,-2.2581));\nvec4 f0_4=sin(p.y*vec4(.2801,3.1750,1.9983,-.6504)+p.z*vec4(-3.4846,4.2435,-2.6852,2.9521)+p.x*vec4(.2830,.6538,1.4488,-3.5361)+vec4(3.2712,4.3837,-3.7523,-5.9050));\nvec4 f0_5=sin(p.y*vec4(1.5156,.8251,-3.7127,4.3026)+p.z*vec4(1.5247,-2.8745,1.3346,.4280)+p.x*vec4(-.5255,-.9554,2.6246,2.3955)+vec4(-3.5040,-3.3669,3.3133,-1.6692));\nvec4 f0_6=sin(p.y*vec4(3.8214,1.9387,-3.9698,-3.6987)+p.z*vec4(-1.1331,-.7003,-3.3304,.8020)+p.x*vec4(-2.0487,4.0014,3.8898,-1.3204)+vec4(7.2148,-7.4848,-4.8330,3.7660));\nvec4 f0_7=sin(p.y*vec4(-2.1693,.1222,2.7208,1.1521)+p.z*vec4(3.1330,2.0367,.6314,1.7677)+p.x*vec4(3.6626,-4.0452,-3.8386,2.6906)+vec4(3.7536,-1.6404,-3.3159,5.1378));\nvec4 f1_0=sin(mat4(-.0934,-.1321,.1311,.3430,.0609,-.1446,.1960,-.2395,.4618,-.1530,.0753,.5231,-.0849,-.2256,-.0453,.3310)*f0_0+\n    mat4(-.0021,.1751,.1124,.4126,.0447,-.2162,-.3264,-.0713,.1542,.1023,-.1984,.2524,.2163,-.1956,.0450,-.2194)*f0_1+\n    mat4(-.2299,.0495,-.1112,-.2321,.3471,-.1658,.2008,-.3290,-.0068,.0278,-.4366,-.1483,.1057,.2634,.1433,-.1973)*f0_2+\n    mat4(-.1318,.1920,.3427,.3366,.0716,-.3128,-.0697,.4434,.1608,.2227,.3934,-.2151,.0034,.2298,-.0156,-.1826)*f0_3+\n    mat4(.2363,.2496,.5539,.3959,.2436,.4798,.0566,-.0174,-.1434,.3167,.3002,.3567,.5419,.2511,.2545,.0431)*f0_4+\n    mat4(.0972,.4349,-.3668,-.0428,.0575,-.2601,.0436,-.0504,-.2617,-.2466,-.0569,.1403,-.1538,.1846,.0230,-.7905)*f0_5+\n    mat4(.2717,.1939,.0817,.3303,.1663,-.4076,.1389,-.2333,.1979,-.1859,-.0204,-.2133,-.3463,-.0463,.3258,.2277)*f0_6+\n    mat4(.3549,.1179,-.0725,.0558,-.3282,-.3345,-.1642,-.0879,.0524,.0110,.1236,.6130,-.0872,-.3758,.1223,.0189)*f0_7+\n    vec4(.2388,1.9781,-.1326,-1.0604))/1.00+f0_0;\nvec4 f1_1=sin(mat4(-.2932,.0451,.0494,-.0486,.0732,.2343,.1352,-.0198,-.1335,.1046,-.1242,-.0997,-.4383,.0821,-.1328,.0585)*f0_0+\n    mat4(.0545,.1238,-.2811,.0986,-.3478,-.0319,.2516,-.0405,.1403,.3401,-.0169,-.2229,-.1080,.2194,-.2530,.2007)*f0_1+\n    mat4(.0515,.1422,.0102,-.1845,.2952,.4669,-.0000,.0824,.0007,.0192,.1869,.0445,-.1476,-.2739,-.5803,.2401)*f0_2+\n    mat4(.2994,-.0397,.1641,-.0096,-.4417,-.0117,-.1132,-.0076,-.2786,-.2076,.1435,.0841,-.2899,.1607,.3819,.2646)*f0_3+\n    mat4(-.5137,.0840,-.3384,.1024,.4198,.1865,.2015,-.1186,.0881,.2643,-.3897,.3309,-.0717,.1203,-.3314,.3403)*f0_4+\n    mat4(.2194,.0201,-.2843,-.2713,-.0591,.2572,-.1345,.2762,-.2773,-.1474,-.1270,-.0191,-.1730,.2925,.3167,.2298)*f0_5+\n    mat4(.1365,.0811,-.0534,.3265,-.5876,.2629,.2386,.3225,-.4695,.4592,-.1618,.0039,.1974,.1793,.1924,-.1282)*f0_6+\n    mat4(-.3755,-.6696,.1087,-.2952,-.2505,-.4240,.1782,.2847,.2719,-.2773,.2565,-.5038,-.1304,.0722,-.0448,-.0685)*f0_7+\n    vec4(-2.2740,1.4383,.1442,-2.0410))/1.00+f0_1;\nvec4 f1_2=sin(mat4(.1033,.2406,.2861,.0521,-.2352,-.2274,-.3890,.3208,-.0282,-.1254,.2446,.0209,.0307,.1077,.4498,-.1085)*f0_0+\n    mat4(.3988,-.2359,.2063,-.2263,.2061,-.2878,-.0959,.1838,-.0283,-.3399,.0864,.2279,-.4467,.2740,-.5571,.2184)*f0_1+\n    mat4(-.0378,-.0005,-.0397,-.3042,-.2388,-.3041,.2866,-.1304,.4693,-.2517,.4689,.2009,-.0928,.2362,.1011,.3387)*f0_2+\n    mat4(.1668,-.1409,.1247,-.3595,-.1071,-.0129,-.0132,.0029,-.1461,-.1029,.0719,.0708,-.0175,.0565,.3968,.1348)*f0_3+\n    mat4(-.0179,.0218,.1020,-.1638,.2006,-.2602,.3527,.4315,-.0546,.2688,.1032,.0777,.4574,-.1600,-.2421,-.4365)*f0_4+\n    mat4(.2042,-.2131,-.4816,.1556,-.2700,.1252,.0825,-.0154,.2409,-.1213,.6356,.1989,-.2966,.3006,-.1809,.1622)*f0_5+\n    mat4(.2345,.0100,.3430,.0306,.2308,.1301,.2328,.2321,-.3767,.0299,-.2849,.2045,.4039,-.0542,.0666,.1177)*f0_6+\n    mat4(.4448,-.1643,.0388,-.1001,.5765,-.0438,.4452,-.3100,.7494,-.2194,.0715,.1881,-.0322,.2635,-.0357,.0748)*f0_7+\n    vec4(-.7773,1.2396,-.3497,1.2757))/1.00+f0_2;\nvec4 f1_3=sin(mat4(.3510,.3383,-.2777,-.1389,.0694,-.1372,-.1622,.0486,-.0640,.4514,-.1131,.0924,.2453,-.0800,-.1341,.0512)*f0_0+\n    mat4(.3245,-.2268,-.1605,-.3458,-.1793,-.1092,-.0625,-.2240,.0526,-.1333,-.1015,-.1291,.2782,.3941,-.0475,-.2889)*f0_1+\n    mat4(.2551,-.0574,.2290,.2013,.5053,-.1687,.1171,-.2891,-.0041,-.0081,.0258,-.2379,-.2823,.0104,-.0012,.2064)*f0_2+\n    mat4(.2676,.0364,.3279,-.4058,-.1793,-.1067,.0881,-.0175,.0655,-.0375,-.2510,-.1476,.0382,-.4236,-.1005,.0967)*f0_3+\n    mat4(.2776,-.0916,-.5421,-.1234,-.1943,.1273,.0837,.0335,-.1464,.2822,.0550,.0821,-.3237,-.2094,.2695,-.1833)*f0_4+\n    mat4(-.4761,.0742,-.2680,.8828,.3887,.1906,-.2085,.1108,.3904,.0031,.3813,.4271,-.0258,-.2299,-.2563,.4208)*f0_5+\n    mat4(-.2035,-.1005,-.0747,-.6706,-.2610,-.5596,-.4047,.1058,-.0179,-.3303,-.1957,-.1869,-.3556,-.6029,-.0359,-.0118)*f0_6+\n    mat4(.0291,-.1114,.0191,.0984,.3647,.0793,.3472,-.1353,.0100,-.2198,-.1690,-.3072,-.1947,.1001,-.2900,.1721)*f0_7+\n    vec4(1.9116,1.0750,-.4068,-2.1228))/1.00+f0_3;\nvec4 f1_4=sin(mat4(-.2296,-.3272,.0211,-.1144,.0147,-.1395,.3283,-.2611,-.3142,-.1718,.0757,.0973,-.0405,-.0559,-.2664,-.0185)*f0_0+\n    mat4(-.1901,.0103,-.3291,.2704,.2102,-.1912,.1882,-.0950,-.3494,.0954,-.1380,-.1726,-.1069,.2222,-.3178,.4209)*f0_1+\n    mat4(-.1783,-.1467,.1041,-.2225,.3571,.0110,-.2747,.3191,.2233,.1376,-.3836,.1693,.0710,-.2117,.0627,.1336)*f0_2+\n    mat4(-.1069,-.0622,-.0013,-.6153,-.4794,.1899,-.2955,-.0942,-.0920,.1060,-.1774,-.4969,-.1224,.2979,-.1096,-.0073)*f0_3+\n    mat4(-.1983,.2243,-.2938,-.2014,-.0267,-.1167,-.0515,-.0903,-.1190,.0716,.1112,.0968,.2247,.2606,-.5354,.4380)*f0_4+\n    mat4(-.1709,-.2402,.0879,-.0001,-.3353,.2954,.4218,-.3403,-.1442,-.1252,-.1978,-.0735,.0740,-.1911,.2151,.5266)*f0_5+\n    mat4(.0871,-.0291,-.3506,-.0252,.3055,.3880,-.1328,-.0669,-.4279,-.2595,-.2460,.3071,.0380,-.1753,-.2905,-.2441)*f0_6+\n    mat4(.0161,.0680,-.1726,.2151,.7725,-.0405,.1366,-.0519,-.4706,-.0252,-.2557,.0661,-.1236,.2125,-.2438,-.5259)*f0_7+\n    vec4(1.4475,.6085,-.5514,.1777))/1.00+f0_4;\nvec4 f1_5=sin(mat4(.0205,-.0183,.1328,-.1067,-.5483,.1628,.2634,.0808,-.1189,.3466,-.0042,-.3868,.1520,.1052,-.1507,-.1669)*f0_0+\n    mat4(-.0913,-.1991,-.0897,-.1785,-.3816,.0086,-.1041,-.2664,.2038,-.1269,.0704,.1203,.2697,-.1339,.2788,-.2456)*f0_1+\n    mat4(-.0413,.1183,.1240,.3050,.3495,-.4988,.7434,-.0311,.0183,-.0108,.0140,-.3839,-.1642,.3231,-.0456,.0542)*f0_2+\n    mat4(-.0267,.0817,.4499,.1539,.3526,.0784,.1238,-.1910,.0390,.1609,-.0284,-.0554,-.0239,-.1441,.2604,.3880)*f0_3+\n    mat4(.1047,.0922,-.0668,-.0725,.0188,.0946,-.0638,-.1070,-.0433,.0320,-.0546,.2112,.1082,-.1656,.0979,-.0051)*f0_4+\n    mat4(-.1296,-.2415,.0001,.0746,-.1099,.2417,.1975,-.1401,-.0810,-.2079,.3166,-.1772,.1303,.0955,-.2343,.6816)*f0_5+\n    mat4(.2971,.1991,-.0163,-.3062,-.0119,-.1572,-.3243,.4315,-.1137,-.0583,.3693,.0568,-.0138,-.0406,.3020,.3069)*f0_6+\n    mat4(.0061,-.0348,-.0111,.1863,.1949,-.1910,-.1509,-.1075,.1820,.1141,-.0766,-.4091,-.0499,-.1988,-.0794,-.2755)*f0_7+\n    vec4(.9340,-.8766,-1.1458,-1.5558))/1.00+f0_5;\nvec4 f1_6=sin(mat4(.1207,.2592,.4301,.2096,.0400,.0310,.2325,-.5025,.2225,-.2925,.3733,-.1440,.3582,-.0787,-.1809,.1871)*f0_0+\n    mat4(-.2288,-.3594,-.0212,.0366,.1425,-.0255,-.0265,-.1448,-.2615,-.3525,.2919,-.1416,-.2559,.4709,.3257,.0270)*f0_1+\n    mat4(-.1922,-.6488,-.1464,.0779,-.2115,.2322,.2027,-.1216,-.0704,.2799,.3047,-.1303,-.1109,-.0162,.0902,.4393)*f0_2+\n    mat4(.2565,.0662,.2153,-.1111,-.2404,.6380,.1597,-.2127,.1301,-.0994,.1059,-.3312,.4630,-.0148,-.0967,-.4474)*f0_3+\n    mat4(-.1679,-.2165,-.0095,.1261,-.0706,-.1625,-.2325,-.4460,.2835,-.1769,-.2335,.1866,-.2963,-.3007,-.4882,.1966)*f0_4+\n    mat4(-.1252,-.2666,.0778,-.2164,.1340,-.0982,.1527,-.1778,.1103,.6122,.5330,-.0621,.0978,-.1899,-.6111,-.0816)*f0_5+\n    mat4(-.5425,-.1223,.3745,-.0710,.4646,-.3335,-.1014,-.0799,.1193,-.1399,-.3193,.3637,.3569,.3373,.1963,.2066)*f0_6+\n    mat4(-.1182,-.0178,.1120,-.3647,.1216,-.2405,.1054,-.0741,-.1793,.1629,.0632,-.6340,.0972,.0452,.1786,-.0195)*f0_7+\n    vec4(-1.4663,2.4973,1.4860,-1.6765))/1.00+f0_6;\nvec4 f1_7=sin(mat4(.1914,-.3903,.1680,-.0505,.1929,.1026,.0456,-.1042,.0837,.3249,.3369,-.2963,-.2506,.3420,.0906,.2226)*f0_0+\n    mat4(-.0060,-.3297,.3163,-.1330,-.3632,-.2987,.2399,.0639,-.1292,-.0474,-.1969,-.0085,-.1041,.4037,.2398,-.0016)*f0_1+\n    mat4(.1100,-.1501,.1212,-.1309,-.3860,.2001,.0276,.0156,.0962,-.0614,.0094,.2834,-.3096,-.0437,.1198,-.0023)*f0_2+\n    mat4(-.0090,.1006,.1413,.2542,.4481,-.0426,.5269,-.2917,.1837,-.0052,.1379,.1787,-.2482,-.1742,-.2475,-.0576)*f0_3+\n    mat4(-.2082,-.0015,-.0807,-.1833,.0108,.2608,.0197,-.1061,-.2986,-.1271,.1388,.1702,.0275,.3765,-.2614,.0512)*f0_4+\n    mat4(-.1558,-.1395,.0482,-.5358,.2387,.3506,.0410,-.1838,.0609,.0232,.1573,-.1898,-.2027,.1205,.0405,.2675)*f0_5+\n    mat4(-.4114,.1523,-.2689,.6871,.1781,-.0021,-.3350,.4177,.0637,-.3082,-.1686,-.2570,.2995,.1335,.1208,-.0002)*f0_6+\n    mat4(.1386,.0613,-.0328,-.2808,-.1560,.2993,-.0253,.1052,.3197,-.2069,.3371,-.1767,-.1485,-.0106,.2229,.1204)*f0_7+\n    vec4(.7439,-.0478,1.8581,-.1715))/1.00+f0_7;\nvec4 f2_0=sin(mat4(.4182,.1332,.1456,.3590,-.1229,-.4860,.0381,-.3463,-.1867,-.2296,.4237,.4578,-.1803,.2436,-.1069,-.7139)*f1_0+\n    mat4(.0522,.0579,-.4002,-.3063,-.1776,-.2811,-.1020,.1971,.1945,-.0758,.3065,-.2684,.4463,-.1295,.1526,.4071)*f1_1+\n    mat4(-.2210,.3157,-.3217,-.3122,.0306,.2667,.0082,-.0151,.0371,.2884,.1209,-.1305,.0622,-.6592,.1946,.0397)*f1_2+\n    mat4(-.3252,.1867,-.1001,-.1372,.0315,-.5640,.0388,.0815,-.2083,.3387,-.4508,.1312,-.4947,-.0399,-.3036,.1720)*f1_3+\n    mat4(-.5676,.2780,-.3098,-.5403,-.2186,-.2314,-.0014,-.1039,-.1922,.6274,.0300,-.8498,.1845,.6007,-.5124,.2429)*f1_4+\n    mat4(-.0562,-.4910,-.4237,-.4000,.1496,-.1526,.2338,-.0874,-.2106,.3931,.0976,.2744,-.1049,-.2123,-.1232,.1235)*f1_5+\n    mat4(.2477,.4698,.6102,-.4041,.2148,-.0215,-.1688,.5304,-.0846,.1254,.1556,.2659,-.3553,.2785,.1771,-.0792)*f1_6+\n    mat4(-.1192,.0868,.3087,-.2625,-.3080,.2357,-.3466,.2121,.1745,-.1621,-.1070,-.2351,-.2100,-.4621,-.4016,.0032)*f1_7+\n    vec4(-1.4220,-1.8161,-1.1157,-.7946))/1.41+f1_0;\nvec4 f2_1=sin(mat4(.2863,-.3264,.2168,.1994,-.1380,-.2455,-.3398,.3120,-.3024,.2108,.0235,.0475,-.1724,-.1263,-.0317,-.2091)*f1_0+\n    mat4(-.1320,.1963,-.1676,-.1104,-.3497,-.1129,-.2144,.1424,.2276,.2332,.1756,-.3497,.0889,.1965,-.1364,.3666)*f1_1+\n    mat4(.1656,-.3892,.2380,-.4567,.5590,-.4673,-.1819,-.1375,-.0206,.1215,-.0916,-.0247,.4065,.4623,-.0355,.2796)*f1_2+\n    mat4(.3030,.1777,-.0307,-.2387,-.0001,-.2001,.0687,.3839,-.3808,-.0703,.1761,-.0629,-.3711,.2258,.2638,.2379)*f1_3+\n    mat4(.0134,.2312,.3900,.1038,-.3374,.0248,-.2315,.2222,-.3335,.2970,.2466,.0353,.1722,-.1117,.4204,-.2758)*f1_4+\n    mat4(-.0641,.0787,-.0334,-.2449,.2267,-.2993,-.1197,.0284,-.6316,-.0374,.0654,-.1786,-.2995,.3246,.3189,.0360)*f1_5+\n    mat4(.5705,-.4085,-.1961,-.3436,.3977,.4124,-.3529,.4366,.2383,-.1773,-.0106,.3370,-.2338,.2144,.1985,-.4199)*f1_6+\n    mat4(-.0641,-.2819,.3172,.0240,-.1308,.2173,-.1785,.2600,.5436,.2713,-.0821,-.0607,-.1221,.3457,.1732,-.0117)*f1_7+\n    vec4(-.3965,-1.0897,-2.2474,.6968))/1.41+f1_1;\nvec4 f2_2=sin(mat4(.0472,-.0400,-.1822,-.0968,-.1491,-.1114,-.2553,-.2677,-.0260,.3329,-.1840,-.0300,.1444,-.1375,-.3190,.2843)*f1_0+\n    mat4(.2395,-.0755,.3117,.0443,-.2219,.0686,.1937,.1171,-.0994,-.1058,-.0122,.1278,-.0639,-.0696,-.3259,-.2619)*f1_1+\n    mat4(.1064,.2582,-.1982,-.2738,-.4197,.5780,-.1547,-.0729,.3479,.1693,-.1787,.3594,-.2454,.2317,.1921,-.3782)*f1_2+\n    mat4(-.0312,-.1196,-.2628,.0087,-.1582,-.1701,.2420,.1586,.1559,.3237,-.2705,-.1310,.1194,.4038,.0471,-.0392)*f1_3+\n    mat4(-.2899,.0635,-.1728,.2339,.1227,.2300,.3259,.2395,.2740,-.3589,.0463,-.1713,.0515,.2916,.1385,.1560)*f1_4+\n    mat4(.2040,.2826,.2911,.1797,-.0240,-.2059,.2807,.1042,-.1960,.2139,-.4975,-.1052,.0738,.2267,-.0186,-.1352)*f1_5+\n    mat4(-.1516,.3722,-.2781,.1542,-.3754,.0877,-.2358,-.1362,-.3588,-.0664,.0499,-.1363,.1704,.1210,-.1256,.1651)*f1_6+\n    mat4(.0778,-.2458,-.1198,-.2079,-.0744,.1480,-.0071,.1170,.0840,-.2907,-.0155,.2515,-.3603,-.1451,-.0803,-.2152)*f1_7+\n    vec4(-.0137,1.8646,-.1886,1.3529))/1.41+f1_2;\nvec4 f2_3=sin(mat4(.2799,.0311,-.1566,.1753,-.0066,-.0278,.3610,-.1491,.4723,.0108,-.2441,.2740,-.0431,-.3060,.4060,-.0093)*f1_0+\n    mat4(-.2758,.1986,.0900,-.0156,.1992,.1157,.4091,-.1006,.1152,.0936,-.0972,-.0932,.1001,.1531,.2223,.1229)*f1_1+\n    mat4(-.1761,-.0668,.2531,-.5969,.5083,.3391,.0329,.0394,-.5108,-.0475,.1226,-.6901,-.3810,.2587,.0134,-.2186)*f1_2+\n    mat4(.3353,.0394,-.1849,.3203,.1205,.2012,.6494,-.0564,-.0891,-.1594,.4516,.1856,-.0725,-.2354,-.4072,.3137)*f1_3+\n    mat4(-.3830,-.4299,.3065,-.1372,-.0580,-.1029,-.2183,.6106,-.2468,-.2763,-.0719,.0134,-.3273,-.0662,-.3148,-.2576)*f1_4+\n    mat4(-.1814,.2503,.2340,-.0367,-.2121,-.1992,.4911,.0190,-.3486,-.0399,.3613,.5524,-.2854,-.2390,.0967,-.4394)*f1_5+\n    mat4(.1507,-.1419,-.3367,-.1484,-.2877,.1267,-.6417,-.1760,.0979,.3338,-.5463,-.3676,-.3418,-.2698,.0544,.0134)*f1_6+\n    mat4(-.0266,-.1425,.0241,-.1249,-.2648,-.4071,-.0431,-.2355,.1417,.3060,-.0978,-.4351,.3160,-.5225,-.2552,.3531)*f1_7+\n    vec4(1.8275,.0580,-.5466,1.4786))/1.41+f1_3;\nvec4 f2_4=sin(mat4(.1746,.0957,-.2066,-.1603,-.4014,-.1479,.4109,-.1728,.3192,.0821,.1666,-.3202,-.0987,.1237,-.0543,-.0856)*f1_0+\n    mat4(-.1727,-.0026,-.1570,.0179,-.1785,-.0058,.0157,-.0845,.0276,-.0755,-.5901,-.0820,.4554,-.2349,.0894,.1244)*f1_1+\n    mat4(-.2295,-.1110,.4449,.0372,-.0712,.2068,.1204,.3757,-.4439,.0531,-.1836,.0555,-.3117,-.1801,-.4327,-.2483)*f1_2+\n    mat4(.0463,.1021,-.1079,-.2372,-.1625,.1134,.3066,.0022,-.1075,-.1377,.2458,-.1658,-.1560,.1690,-.0936,-.0637)*f1_3+\n    mat4(.1582,.4317,-.1064,.2832,-.1349,.2106,-.1651,-.1000,.1806,-.0670,-.2971,-.0977,-.0603,.0127,-.0236,.0984)*f1_4+\n    mat4(-.3728,.0547,-.5659,-.0165,.2617,-.0336,.0297,.1128,-.3701,-.2217,.1497,-.2795,.2678,-.0275,.2230,.2185)*f1_5+\n    mat4(-.2085,-.0716,-.0761,-.4247,-.3128,-.1967,-.3252,.2833,.1285,.1225,.2183,.1684,-.3532,-.0422,-.2019,.1488)*f1_6+\n    mat4(.1418,-.1073,.3806,.0102,.0525,.1732,-.1511,.2633,.0284,-.0870,-.2041,-.0931,.1620,.1923,-.0499,.3008)*f1_7+\n    vec4(-.1349,1.0521,-1.7979,.2089))/1.41+f1_4;\nvec4 f2_5=sin(mat4(.4533,.3386,.1017,-.1335,-.2207,-.0756,-.0385,.1608,-.0298,-.1184,-.0624,.1228,-.1050,-.2214,-.2313,.4074)*f1_0+\n    mat4(-.0289,.0016,-.2037,.2335,-.1737,-.2545,-.3202,-.0937,.1538,.1024,-.1054,.1926,.5224,.1017,.2533,.1736)*f1_1+\n    mat4(.1702,-.0539,-.3957,.4119,.0677,-.0884,-.4015,-.4150,.1188,.0222,-.1469,.1161,-.0407,.0700,-.2492,.0734)*f1_2+\n    mat4(-.5535,-.1166,-.4168,-.1204,.0461,.3923,.2887,.2812,.2454,-.3190,.1452,.2392,-.1134,.3451,-.0026,.3660)*f1_3+\n    mat4(-.0909,.1504,-.4813,.2124,.1232,-.1785,-.1829,.1195,-.1980,-.0576,-.0093,.3417,.0498,-.2314,-.0240,.1897)*f1_4+\n    mat4(-.4515,.1000,.3670,-.2068,-.1310,-.1276,.3238,.1248,.2264,-.1227,.1531,.1104,.5808,.0483,.1787,.1127)*f1_5+\n    mat4(-.1263,.2581,-.2122,.5993,.1090,.3535,-.0708,-.2158,-.4753,.2062,-.0755,-.8191,.1853,-.0391,-.0818,.3689)*f1_6+\n    mat4(-.1588,-.4503,.0626,.0482,.1253,.1425,-.4140,-.0067,.0700,-.0426,.0963,-.0441,-.1686,-.1110,-.3168,.4427)*f1_7+\n    vec4(2.2147,-1.7227,-.3088,-1.1331))/1.41+f1_5;\nvec4 f2_6=sin(mat4(-.0008,.0330,-.0333,.2745,-.0871,-.6135,.0734,.2999,.1561,-.0360,-.2697,-.0761,.2738,.1409,.3361,.2414)*f1_0+\n    mat4(.2594,-.1807,.3105,-.2049,-.2331,.2027,-.2281,-.3727,.0728,-.1648,.2359,-.3755,.3987,-.0777,.1873,.2892)*f1_1+\n    mat4(-.0235,.1510,.5777,-.0815,-.1928,-.1758,-.0239,-.1490,.2213,.2282,.2782,-.3906,-.0213,-.5825,.1965,-.5994)*f1_2+\n    mat4(-.2033,.1473,-.2922,.1104,-.0189,-.3616,.2379,.0539,.2384,.1392,.1632,-.1954,.6096,-.2192,-.1472,-.2769)*f1_3+\n    mat4(-.2974,.2028,-.1128,.0813,-.1526,-.0028,-.1686,-.0451,.3557,.2741,.3285,.2518,.3536,.2780,-.1937,.2454)*f1_4+\n    mat4(-.4937,.1756,-.1535,-.3936,.2241,.3537,.0015,-.1264,.5740,.0587,-.0237,-.0800,.3431,-.1992,.3443,.2349)*f1_5+\n    mat4(.4255,-.3016,.1230,.3302,-.0327,.2003,-.4925,-.2795,-.4906,.1638,-.6365,-.5219,.0490,.2018,.3960,-.1266)*f1_6+\n    mat4(.1831,.1639,.2025,.3404,-.5479,.1719,.0780,-.0353,-.0510,-.2046,-.1178,.0117,-.1707,.1545,.2708,-.1771)*f1_7+\n    vec4(2.0413,-.8035,1.7061,-1.8694))/1.41+f1_6;\nvec4 f2_7=sin(mat4(-.2355,-.1696,-.1964,-.1450,-.2621,.0600,.0757,-.3024,-.0948,-.0628,.4821,.2096,.0744,.3602,.2433,.2356)*f1_0+\n    mat4(.2131,.2139,-.2805,.2256,.3685,-.3415,.3168,-.4724,.1007,-.1040,-.1148,-.0918,-.1840,-.0254,-.2924,.1012)*f1_1+\n    mat4(.0838,-.3899,-.2678,.2901,.2906,-.1406,-.3356,-.2748,-.0653,.1979,-.2365,.3282,.2821,.1409,.3160,.2368)*f1_2+\n    mat4(-.1988,.1861,.2920,.2512,-.4404,.2064,-.0344,.1098,-.1506,-.2387,-.3768,.0449,-.0791,.0002,.1391,.1670)*f1_3+\n    mat4(-.1548,-.3231,.0811,-.3357,-.0927,-.1571,.1942,-.0170,.2303,-.1807,-.0618,-.0442,-.1144,-.0182,-.1247,-.3328)*f1_4+\n    mat4(-.3430,.1920,.1773,-.3588,-.1417,.1338,.4685,-.0125,-.2312,-.1929,.2315,.2000,-.1442,.0704,-.2057,.3263)*f1_5+\n    mat4(.1565,-.3663,-.3861,.2778,-.1360,-.4939,.1754,-.4649,.1150,.0544,-.2320,-.6401,.1734,.1488,.1139,-.2595)*f1_6+\n    mat4(-.1019,.0091,-.4281,.1973,.0169,-.3304,.4714,.1163,.0174,-.4290,-.1358,.2060,.1906,-.3259,.0731,-.1211)*f1_7+\n    vec4(1.6535,-2.2802,-1.3987,-1.7983))/1.41+f1_7;\nvec4 f3_0=sin(mat4(.3313,-.1841,.3076,.2377,-.1798,-.6317,.2219,.6616,.0005,.1156,-.1094,.3746,-.1807,-.1598,-.5170,-.3575)*f2_0+\n    mat4(-.1253,.3167,.1927,-.1863,.0386,-.2879,.4010,.2496,.1327,-.3388,-.5408,-.0915,.3682,.0492,-.5315,-.0189)*f2_1+\n    mat4(-.0564,.6727,.2439,-.1873,.1333,-.1097,.6097,.5876,.1857,.0290,.1743,-.1566,.1238,.0765,.2272,.5760)*f2_2+\n    mat4(.3657,-.0846,.2929,-.2310,-.1914,-.3431,.3726,.6302,-.1160,.5878,.3163,.1489,-.3111,.1022,-.0676,-.4609)*f2_3+\n    mat4(-.1546,.0826,.3142,.0952,-.0605,.0752,.1836,-.1446,.2698,-.1439,-.0159,-.5126,.2482,.2438,.6618,.1412)*f2_4+\n    mat4(.2095,-.4662,.1453,.5210,-.4186,.5051,.1556,-.1102,.2140,-.1540,.3752,.3613,.2990,.1859,-.0623,-.4596)*f2_5+\n    mat4(.0792,-.0105,-.2283,-.5180,-.0729,-.4423,.5378,.6082,-.0114,-.6165,-.0880,.5712,-.2888,.2076,.1328,.2251)*f2_6+\n    mat4(-.2767,-.0881,.3580,.2271,.1308,-.4237,-.0418,-.1558,.1085,-.3250,-.0945,-.7507,-.2518,.1338,-.2712,-.2905)*f2_7+\n    vec4(-.3471,-1.4760,-1.4786,1.0043))/1.73+f2_0;\nvec4 f3_1=sin(mat4(-.1723,.1866,-.0127,.5451,-.4235,-.3342,-.1475,.0001,.2341,-.2384,-.1406,.1409,.1936,-.0105,-.0182,-.3813)*f2_0+\n    mat4(.0866,.0578,-.1961,.1672,-.4473,.1252,.2544,.4695,-.0338,.0790,.0650,-.0299,-.2212,-.1319,-.2443,-.4194)*f2_1+\n    mat4(-.4518,-.0255,-.2765,.2270,.2395,-.3907,-.0187,.0381,.1958,.0194,-.1527,.0909,.3251,-.1308,.1844,-.1145)*f2_2+\n    mat4(.0584,.0492,.3092,.0220,.1201,.6789,.1620,.1114,-.0981,.4132,-.2116,-.0303,-.2571,.0112,.0988,.3005)*f2_3+\n    mat4(.1278,.5819,-.1352,-.1129,.1503,.2717,-.1265,.2813,.3433,-.0470,.4334,-.1592,-.3047,-.1614,.2810,.4897)*f2_4+\n    mat4(-.4714,.4669,-.1320,.8070,.2246,-.5671,.2866,.1289,.1262,-.2041,.0030,.2841,.0571,.0027,.1893,-.1165)*f2_5+\n    mat4(.3718,-.3138,-.1271,-.4907,-.0888,-.0123,.4729,.2096,-.3311,-.4946,.2016,.3721,-.1402,-.0505,-.1029,.4489)*f2_6+\n    mat4(.2357,.2603,-.0445,.0612,-.0166,-.0786,-.0061,-.2286,.1058,.2424,-.1443,-.2388,.0850,.0345,-.0521,-.3858)*f2_7+\n    vec4(-2.0658,-1.2382,1.2312,.4206))/1.73+f2_1;\nvec4 f3_2=sin(mat4(-.1616,.3366,.4292,.0487,.2497,-.2058,.3590,-.1700,-.2400,.0313,.2781,-.1880,-.4977,.0138,.5493,.3087)*f2_0+\n    mat4(-.2624,.2923,.1567,-.2346,.3242,-.2256,-.3513,.0360,.4967,-.0183,-.1632,-.4336,.5340,.1413,.2452,.3208)*f2_1+\n    mat4(-.1375,-.2965,-.0387,.2818,-.2448,.1328,.0107,-.0825,.0515,-.0039,-.1513,-.2703,.0609,-.0708,-.2218,.2052)*f2_2+\n    mat4(-.3253,.1901,.2105,-.2744,.1807,-.1245,-.2013,-.0749,.0943,.1579,-.0589,.4592,.1834,-.0459,.6927,.2324)*f2_3+\n    mat4(.3287,-.3438,-.2194,.3184,-.1365,-.4789,-.1043,.2573,-.7663,-.1945,.1061,-.1714,-.3742,-.1184,.3276,.0127)*f2_4+\n    mat4(-.1694,-.5151,.0905,-.2014,.3350,-.0691,-.2301,.0823,-.2899,.1256,.1540,.1148,-.0025,-.1452,-.2052,.4201)*f2_5+\n    mat4(-.2101,-.1062,.0996,.3371,-.0826,-.0501,-.7140,-.1264,.0469,-.1337,-.4247,-.4009,.0927,-.1139,.3719,.0133)*f2_6+\n    mat4(.0046,-.1804,.6768,.1963,.1487,-.1041,.0090,-.1911,.1104,-.3759,-.0945,-.2140,-.2301,-.1189,-.2323,.0952)*f2_7+\n    vec4(1.6769,-2.1215,-1.0699,1.3432))/1.73+f2_2;\nvec4 f3_3=sin(mat4(.0178,.4514,.0317,.4479,-.1408,.5057,.4208,.0789,.1065,.1670,.0565,-.2373,.5855,.1719,.0593,.3088)*f2_0+\n    mat4(.2609,.3126,.1307,.0918,.0074,.0997,-.1180,.6880,.3105,-.0952,.4314,.2324,-.1188,-.3203,.0964,-.2887)*f2_1+\n    mat4(.1459,.0103,-.2341,-.0684,-.1289,.1822,-.2500,.2978,-.0472,-.0637,-.2412,-.2612,-.1080,-.1523,-.1418,.1442)*f2_2+\n    mat4(.1802,.0658,.1326,.3739,.4867,-.4339,-.1930,-.1134,-.1478,-.0175,-.5720,-.2858,-.0118,.0428,.0614,-.6860)*f2_3+\n    mat4(.3019,-.4082,-.1629,-.1589,.1943,-.0694,-.1943,-.3523,.0170,.3200,.0943,-.0632,-.0836,.4103,-.0884,.1640)*f2_4+\n    mat4(-.0288,.0282,-.0323,.1237,.2276,.1456,.0929,-.0725,-.2728,.1669,-.2172,.0716,.0269,.0361,-.3623,-.0536)*f2_5+\n    mat4(-.0021,.3076,-.3485,-.3356,-.3856,-.3993,-.0638,-.0775,-.3594,-.2090,.9989,.2148,.0506,.1401,.3775,.0792)*f2_6+\n    mat4(-.3611,.0341,-.2071,-.1726,-.4017,-.3025,-.1761,-.0614,.3971,-.1015,-.0128,.5525,.0405,.2531,-.3758,.0119)*f2_7+\n    vec4(-1.3478,-1.2236,-.0489,.7284))/1.73+f2_3;\nvec4 f3_4=sin(mat4(-.4635,-.2221,.0685,-.0898,-.0439,.0841,.3123,-.6493,-.1861,-.1191,.0815,.1626,.3225,-.0846,-.3400,.4344)*f2_0+\n    mat4(.3915,.2044,.2974,.0393,-.5798,-.0300,-.1992,.2109,-.0314,.0434,-.0389,-.0097,-.2094,-.4741,.3139,-.2301)*f2_1+\n    mat4(.1016,.1555,-.3086,.4107,.1091,.0190,-.1192,-.2992,.2740,-.0794,.0725,.4889,-.2486,.2591,.3303,-.2122)*f2_2+\n    mat4(.1925,-.1152,.1434,.1558,.0019,-.2005,.0537,-.3515,.1942,.1978,-.6411,.4338,.1553,.0490,-.0330,.4171)*f2_3+\n    mat4(-.0271,-.0336,-.1033,.1969,-.4232,-.3326,.4287,-.0886,.2253,.0710,.2220,.1155,.1375,-.3497,-.1147,-.5716)*f2_4+\n    mat4(-.1670,-.1146,-.2052,-.0273,-.0213,-.0933,-.2196,.2513,.3803,-.0373,-.4268,-.2988,-.1099,-.5135,-.2589,.3012)*f2_5+\n    mat4(.1136,-.2360,.1964,.2271,-.1871,-.1881,-.3268,.1972,-.9328,-.0881,.0081,-.7798,-.0789,-.0960,-.3694,.3582)*f2_6+\n    mat4(.7142,-.0456,.2433,.0342,.1336,-.0005,.3548,-.0976,-.3094,-.0500,-.0583,-.0692,.0436,.0778,-.0380,.0887)*f2_7+\n    vec4(1.0589,1.0816,-1.0344,-1.1224))/1.73+f2_4;\nvec4 f3_5=sin(mat4(-.4004,-.3502,-.0204,-.3227,-.5428,-.5908,.0445,-.3453,.2356,.2817,.3513,-.0254,.4475,.3949,-.1122,-.1443)*f2_0+\n    mat4(.2132,.2733,-.0179,.3328,-.3607,.0089,.5432,.3088,.2094,.0738,.2165,.0584,-.4659,-.0249,-.1016,-.4296)*f2_1+\n    mat4(.2319,.1478,.3617,.1117,-.4556,.1955,-.2478,-.1879,-.1423,-.3040,.3377,.0144,-.2357,-.0853,.6082,.1429)*f2_2+\n    mat4(-.2593,-.2611,.4395,.1667,.0345,.4901,.2487,-.0026,.2734,.3280,.2801,-.1466,-.1307,.2232,-.0522,.0347)*f2_3+\n    mat4(.2109,.2951,-.2957,.1386,.1645,.1131,-.1915,.3866,.4850,-.2991,.0639,.2355,-.5015,-.3986,-.2466,.3612)*f2_4+\n    mat4(.0062,.0509,.0772,.3626,.5153,-.1371,.2233,.2494,-.2444,-.1014,-.0814,-.6159,-.3593,.3973,.0696,-.6129)*f2_5+\n    mat4(.1700,.5207,.0077,-.5223,.2301,-.7926,-.7060,.3677,.3496,-.5222,.0122,.6564,-.3784,.2008,-.3941,-.0405)*f2_6+\n    mat4(-.1868,-.5801,-.1395,.2059,-.0566,-.5420,-.2554,.1393,.3148,-.2406,.0932,.1999,.0948,.0171,.0434,-.1427)*f2_7+\n    vec4(-.8419,1.0133,-.3166,1.1585))/1.73+f2_5;\nvec4 f3_6=sin(mat4(.2596,.4705,.2017,.0878,-.0321,-.4016,-.0193,-.1033,-.2191,.2252,.1664,.1261,-.2416,-.3472,-.3263,-.3813)*f2_0+\n    mat4(.1430,.0861,-.0082,-.2653,-.3999,.1613,-.0187,.1095,-.1713,-.1831,.1330,.2832,-.1151,.0090,.2317,.2045)*f2_1+\n    mat4(.0121,.4542,-.4168,-.0409,.1061,-.3375,.1501,.1363,.5040,-.0811,-.2425,-.2758,.0822,.1525,-.0555,.2423)*f2_2+\n    mat4(.1775,.2501,-.0533,.2462,-.0305,-.1620,-.0340,-.0714,-.0252,.4231,-.5005,-.0600,.3435,.0447,-.2122,-.1718)*f2_3+\n    mat4(.0790,.0893,-.0186,-.3093,-.0760,-.4034,.2561,-.1662,-.0656,.0480,.4209,.3327,.1387,-.2579,.1161,.4230)*f2_4+\n    mat4(-.1999,-.2232,.3051,-.3174,-.1544,-.0719,.0605,.4185,.1008,-.2156,-.1013,.1413,.4051,.3386,-.5506,.0611)*f2_5+\n    mat4(.0426,-.4160,-.0739,-.2679,-.2484,.3400,.3564,.2983,-.1825,-.3116,.7870,.0105,.2455,.3194,-.2629,-.0640)*f2_6+\n    mat4(.2841,-.0713,-.1810,-.2342,-.2679,-.3895,.1499,.6543,.2553,-.1275,-.2124,-.2141,.2464,-.0263,-.0670,-.5636)*f2_7+\n    vec4(-.0921,.5849,1.7013,-2.2406))/1.73+f2_6;\nvec4 f3_7=sin(mat4(.0764,-.0809,.1392,.2444,.1820,.1992,.0672,-.2931,-.0643,-.0229,-.5270,.0312,.2049,-.2348,-.1522,.2559)*f2_0+\n    mat4(.2012,-.2825,.2911,.2128,.0938,-.3346,.6047,-.1499,-.1410,.1568,-.1053,-.2598,.4599,-.0755,-.0742,.0193)*f2_1+\n    mat4(-.0426,-.2334,-.0064,.5097,-.3124,-.2356,.6008,-.2849,.3583,.0817,.0969,.1261,.3197,-.0464,.4738,.0764)*f2_2+\n    mat4(-.2466,.4000,.4111,-.1223,.1203,-.4611,-.1533,-.1658,.1741,.3227,-.0968,.5904,-.1858,-.0582,.4446,.2579)*f2_3+\n    mat4(-.2821,-.2132,.3315,-.1621,-.3167,.1570,.1036,-.1609,.2522,-.3390,.5042,.1325,.2831,-.3424,.6945,.1522)*f2_4+\n    mat4(-.3970,-.3284,-.0116,-.2421,-.1450,-.3287,.1463,-.3426,.1198,.2187,.0056,.3327,.4287,.4806,.1142,.5354)*f2_5+\n    mat4(-.0434,-.1038,.4422,.3366,-.3362,-.0272,.3478,-.7946,.1070,-.0914,.5159,-.5441,-.1468,.2812,-.3413,.0532)*f2_6+\n    mat4(-.1015,.0236,.2663,.1431,-.1551,-.0236,.4655,-.2337,-.0781,.2885,.3162,-.0215,.2074,-.2164,.0870,.2447)*f2_7+\n    vec4(-1.2349,1.8927,1.5608,-.5357))/1.73+f2_7;\nvec4 f4_0=sin(mat4(.0685,-.0992,-.2379,-.2541,.4421,.1318,-.3002,-.0013,.2662,.1698,.1148,-.1883,.1460,-.1760,.4026,-.2311)*f3_0+\n    mat4(.3529,.2049,.2316,-.0529,.0365,-.2361,.0915,-.1178,-.0440,.0203,-.6988,-.3796,-.2470,-.2345,-.4532,-.0154)*f3_1+\n    mat4(.1608,.1073,-.0105,.0677,-.2864,.2599,.0346,-.0225,.5556,-.1665,-.0445,-.5627,-.5389,.3547,-.1059,.2502)*f3_2+\n    mat4(.3549,-.0868,.2041,-.2457,-.2059,-.1682,.3622,-.2000,-.0116,.1123,.5120,-.1157,-.5492,-.2497,-.2800,.1469)*f3_3+\n    mat4(.2886,-.0431,1.0755,.1927,-.4227,-.1982,.1989,.3397,.3508,-.4416,-.0425,-.1648,.4239,-.0297,-.1805,.0099)*f3_4+\n    mat4(.1265,-.4994,.1493,.2996,-.6675,.0183,-.8657,.0477,-.3071,.2976,.0615,.0163,.3178,.0701,.1461,-.3896)*f3_5+\n    mat4(.1736,.0211,.2793,-.0076,-.0670,.2490,.3345,.2259,-.2239,-.0806,-.1767,.2879,-.2545,-.1230,-.1879,-.1380)*f3_6+\n    mat4(-.0811,-.0532,.1647,.1432,.1346,-.0062,.0610,-.1691,.1814,-.0378,-.1847,.3233,.1793,-.1283,-.0794,-.1277)*f3_7+\n    vec4(-.3748,1.4850,-.1442,2.0950))/2.00+f3_0;\nvec4 f4_1=sin(mat4(-.1097,-.2323,-.2906,-.1909,-.0064,.1931,.4827,-.1663,.2429,-.2563,.1072,.3541,-.1999,-.3519,.1067,-.0551)*f3_0+\n    mat4(-.1226,-.0473,-.0421,.0517,-.1115,.1763,.0986,.1210,-.0048,.2720,.2342,-.2702,.0019,-.3227,.1437,-.1874)*f3_1+\n    mat4(-.4877,-.3436,-.1203,-.3744,.1374,.0064,.1345,-.1722,.3255,-.1328,.1772,-.0208,.0702,-.1063,.0074,-.0726)*f3_2+\n    mat4(.1427,.3036,.0406,.0017,-.2286,.1422,-.1555,.5061,-.6929,-.4683,-.5378,-.2687,.1987,.2292,-.5625,.0272)*f3_3+\n    mat4(.0013,.4324,.2466,.2439,.1841,-.2456,-.1339,.3629,.0653,.2448,-.3693,-.2166,-.1590,.6671,.3712,-.0940)*f3_4+\n    mat4(.2850,.3993,-.1993,-.2816,-.0501,-.1085,-.4346,.3850,-.0069,-.3122,.3110,.1021,-.0556,-.4736,-.1344,.1801)*f3_5+\n    mat4(.1152,-.1842,-.4665,.1002,.5129,-.0220,.3191,-.2161,.1146,.5258,.4816,.2020,.4244,.3290,-.0730,.2637)*f3_6+\n    mat4(.0018,.0908,.3465,-.1767,.0287,-.0713,.1546,-.2080,-.0062,-.1526,.1251,.0673,.0098,-.3652,-.2910,.0591)*f3_7+\n    vec4(-.0909,.3834,-.6202,-2.0921))/2.00+f3_1;\nvec4 f4_2=sin(mat4(-.1580,.0246,.0724,-.2580,-.2265,.4805,-.0076,-.4017,-.0288,.5293,.1361,.1221,.1193,-.1093,-.2100,.4984)*f3_0+\n    mat4(.1205,.3699,-.2547,-.1525,-.3167,.1543,.0508,-.1685,-.3853,-.4167,-.0772,.2433,-.2778,-.4514,-.3598,.0256)*f3_1+\n    mat4(.2165,-.5708,-.1225,.6359,-.0196,-.3408,-.1344,.0374,.2027,-.1455,-.3109,.1173,-.2504,-.1025,.0167,-.0160)*f3_2+\n    mat4(.0730,.2413,-.1955,.4909,.3224,-.0673,.2187,-.1187,.3256,-.8367,.2877,.3416,.2664,-.0278,.0543,-.0248)*f3_3+\n    mat4(.1484,.2378,.0961,-.1283,-.0614,.0543,.4125,.0939,.2009,.5211,-.4274,.0563,-.2553,.1613,-.0989,-.3284)*f3_4+\n    mat4(.4502,-.1128,.1657,-.3077,-.2045,-.7328,-.1371,.5274,-.0187,.1249,.1491,-.1242,-.1482,-.7631,-.1660,.9512)*f3_5+\n    mat4(-.3189,-.1201,-.1126,.3099,-.5746,.1268,.0445,-1.1566,-.6448,.2324,.7315,-1.2800,-.3185,.3252,.1649,.1933)*f3_6+\n    mat4(.0104,.1225,-.2245,.1080,.3704,.3344,.0088,-.2742,-.3712,-.1547,.4362,.5554,.1157,-.1694,.0089,.9086)*f3_7+\n    vec4(-.8892,.8779,-.4697,1.9587))/2.00+f3_2;\nvec4 f4_3=sin(mat4(-.0802,.1722,.2679,.2300,.4107,.3706,-.3573,.6639,.1743,.1002,-.0261,-.1630,.0547,-.0634,.2979,-.2978)*f3_0+\n    mat4(-.0241,-.1199,-.1730,.2785,.0815,.2011,-.2467,.1969,.0655,-.3376,.0543,-.1551,.0533,.1042,-.1208,.0992)*f3_1+\n    mat4(-.1320,-.1362,.4412,-.6213,.3930,-.0721,.0607,.1951,.4713,.0906,-.0534,-.0614,-.0806,.0615,-.0520,.6064)*f3_2+\n    mat4(-.1201,-.1491,.1292,-.1638,-.2848,.0803,-.1442,-.0287,-.1298,-.2733,-.0686,-1.0184,.0924,-.0212,.1017,-.0052)*f3_3+\n    mat4(.1723,-.0910,.1380,.6802,.0107,.0356,-.0215,.1558,-.0397,-.0731,.0550,-.1274,-.3522,.0713,.1975,.9979)*f3_4+\n    mat4(-.2804,-.4170,-.3145,.3403,.1460,-.1558,-.1950,-.1722,-.1029,-.0377,-.0144,.7175,.0912,-.0176,.1221,-.9883)*f3_5+\n    mat4(.6918,-.0316,.2925,.2412,-.4671,.3612,-.2582,.8618,-.0721,.1434,-.0271,1.0480,.0404,.0311,.0303,.4519)*f3_6+\n    mat4(-.3385,.0465,.1816,-.3032,.3224,.1457,-.0552,1.0258,-.2806,.0315,-.0161,-.7755,.2725,.0345,.2134,-.9027)*f3_7+\n    vec4(-1.4437,.1703,-.3098,.0644))/2.00+f3_3;\nvec4 f4_4=sin(mat4(.6193,-.2249,.1266,-.1096,.2222,-.2270,-.3161,.0071,.0115,.3823,.2637,-.2357,.1914,-.3196,-.1619,-.2764)*f3_0+\n    mat4(-.0032,.1639,.1317,-.0896,.3548,.3146,-.0123,-.1361,.1400,.1070,-.3276,-.2347,-.3916,-.3520,.4510,-.4206)*f3_1+\n    mat4(-.7120,.8260,.1411,-.3398,.1218,-.1188,.0253,-.3272,-.0950,-.3276,.0652,-.3986,-.0618,.3721,-.4107,.4498)*f3_2+\n    mat4(.5747,-.0760,.2488,-.2208,-.1830,.2537,-.1012,.2851,-.3231,.0020,.1727,-.1151,-.0445,.1152,.3434,.4066)*f3_3+\n    mat4(.3581,-.0389,.1824,.5137,-.0676,.2645,-.0288,-.1361,-.0209,-.2940,-.3649,-.0927,.4479,-.1282,.3849,-.0210)*f3_4+\n    mat4(.2720,.2695,.4482,.5917,-.4696,-.2739,.1325,-.3302,-.0881,-.1094,.0356,.1672,-.9246,.0141,-.1072,-.6061)*f3_5+\n    mat4(-.0343,-.0902,-.2274,-.2431,.6883,-.5968,-.3917,.6311,.8665,-.0314,.2341,.7961,.1318,.2416,.4424,-.3257)*f3_6+\n    mat4(-.5181,.1305,.3601,-.0264,.0972,-.0253,-.1423,.4558,-.5689,-.1397,-.0019,.1094,-.5614,-.1857,.0971,-.4560)*f3_7+\n    vec4(-2.0198,-1.5131,1.0783,-1.5657))/2.00+f3_4;\nvec4 f4_5=sin(mat4(-.1989,.1481,.0574,.5245,.2220,-.2811,.1067,-.4864,.0685,-.5098,-.0947,-.1041,-.4419,.1618,-.1981,-.3380)*f3_0+\n    mat4(.3034,.3681,-.0696,-.3327,-.2312,-.1720,-.0936,.4599,.1817,-.1507,.0783,.2172,-.3878,-.0992,-1.0474,-.5587)*f3_1+\n    mat4(-.1382,.2060,.0124,-.0659,-.1176,-.0275,.2347,-.2354,.3047,-.0588,-.1683,.2179,-.1220,-.0611,.0960,-.2389)*f3_2+\n    mat4(.3624,.3454,.1111,-.1121,-.2387,.3645,-.3210,-.5434,-.3458,.7840,-.0779,.3160,.2192,-.0527,.1198,.0073)*f3_3+\n    mat4(-.1838,-.3534,-.2527,.2915,-.3795,-.1320,-.0664,-.1338,.1982,-.1791,.2175,-.1660,-.2336,-.2536,.4282,-.4972)*f3_4+\n    mat4(-.1958,.3972,.2464,.0523,-.4596,-.0862,-.0040,-.4176,-.2901,-.4012,-.0207,-.5263,-.5818,-.2068,-.4139,-.3518)*f3_5+\n    mat4(-.4126,-.1417,.3597,-.3179,.4391,-.3970,.3838,.0306,.1662,-.5261,.0985,-.0127,.3323,-.3801,-.1230,.3302)*f3_6+\n    mat4(.1284,-.3923,.1990,-.0561,.3863,-.3285,-.2413,.1576,-.5225,-.3138,.0713,-.0583,-.3868,.2907,.0799,-.0480)*f3_7+\n    vec4(.5860,-.5990,-.5505,1.1821))/2.00+f3_5;\nvec4 f4_6=sin(mat4(.2321,.1621,-.3651,-.2694,-.6645,.2153,.2277,-.6142,.2135,.0115,-.3847,.0869,.1532,-.0723,-.3240,.2334)*f3_0+\n    mat4(-.2085,-.1940,.1098,-.0385,-.1266,-.0528,-.3401,-.0218,.0957,-.0256,-.2299,-.3978,.0394,-.2278,-.0825,-.1549)*f3_1+\n    mat4(.2401,-.3105,-.2951,.0197,.1510,.2058,-.2256,-.1836,.2494,-.0018,-.1313,.4018,-.2442,.0812,.0717,-.3181)*f3_2+\n    mat4(.3523,.2400,-.1386,.2813,-.6287,.0747,-.2247,.0854,.3410,.2721,-.1178,.3122,-.2854,-.3637,-.2680,.2632)*f3_3+\n    mat4(-.1202,-.3841,-.3473,-.4211,-.0329,-.3370,.3544,.0985,-.2934,.2479,.0209,-.1138,-.3719,-.0481,-.1569,-.7915)*f3_4+\n    mat4(-.2213,-.1722,-.1417,-.4752,-.4173,-.5678,-.0031,-.0696,-.2666,-.3222,-.0452,-.0805,.1441,-.1454,-.3577,.2580)*f3_5+\n    mat4(.0939,-.0437,.1267,.3422,-.2207,.0172,.2980,-.0215,-.1308,.0736,.2396,-.9393,-.2944,.2069,.0339,-.0427)*f3_6+\n    mat4(-.0621,.1991,-.3169,-.1812,-.1790,-.2106,-.1572,.2181,-.0100,.3618,.0799,.2393,.2920,.1658,.3061,.2907)*f3_7+\n    vec4(-.2625,-1.4989,.7955,1.5886))/2.00+f3_6;\nvec4 f4_7=sin(mat4(.2543,-.1533,.2777,.0166,-.1510,.0524,.1045,-.5661,.3572,.1318,.3224,-.5189,-.4252,-.3339,.1787,.0743)*f3_0+\n    mat4(.0547,-.1086,-.1678,.4333,.0863,.2854,.0588,-.0709,-.1633,-.0749,.1940,-.4371,.2386,.0260,.3362,-.3165)*f3_1+\n    mat4(-.2138,.1389,.3307,.5422,.3765,-.2048,.2390,.2260,-.0504,.0551,-.1408,.1114,-.0905,-.3137,-.0518,.0832)*f3_2+\n    mat4(-.2088,.1063,.1070,.5126,.1586,-.6203,-.3025,.3793,.4055,.3309,.2383,.5919,.2645,-.3142,.1780,-.1222)*f3_3+\n    mat4(.0080,.2118,.2081,.0343,-.0603,.4277,-.2558,-.2181,.1100,.3773,.0035,-.2298,-.0824,.0717,.2931,-.4361)*f3_4+\n    mat4(-.0599,.0984,-.1637,-.1743,.2338,.1167,.5644,1.0358,-.0123,-.5109,.3911,-.1812,-.3466,-.2109,.0915,.6180)*f3_5+\n    mat4(-.3112,.2823,-.0485,-.3696,.3775,-.2741,-.2640,-.6429,.2082,.0347,.2540,-1.7387,-.3030,-.0923,-.0786,-.3787)*f3_6+\n    mat4(-.1924,.4559,.0845,-.3586,-.2576,-.0140,-.2509,-.4056,-.5921,.0438,-.1886,-.2035,-.3892,.3233,-.4221,.3723)*f3_7+\n    vec4(1.9150,.7264,.4524,-.3275))/2.00+f3_7;\nreturn dot(f4_0,vec4(-.0277,.0214,.0123,-.0280))+\n    dot(f4_1,vec4(.0218,.0333,.0405,-.0353))+\n    dot(f4_2,vec4(-.0329,.0398,.0225,.0420))+\n    dot(f4_3,vec4(-.0187,.0131,-.0143,.0240))+\n    dot(f4_4,vec4(-.0212,.0147,.0106,.0399))+\n    dot(f4_5,vec4(.0331,-.0329,-.0268,-.0320))+\n    dot(f4_6,vec4(-.0350,-.0220,.0323,.0215))+\n    dot(f4_7,vec4(.0442,.0346,-.0244,.0186))+\n    -0.045;\n}\n\n#else\n#if LEVEL==2\n//train_siren(sdfloader, 24, 3, 15) loss = (model_output - truth)**2\n\nfloat scene(vec3 p) {\n    if (length(p) > 1.) return length(p)-.8;\nvec4 f0_0=sin(p.y*vec4(-1.1405,1.1760,1.2857,-2.1564)+p.z*vec4(-1.6142,-3.6948,-1.8810,3.0428)+p.x*vec4(-4.2162,1.6138,-2.1348,-.5009)+vec4(-8.0215,3.3005,-4.9939,-2.6610));\nvec4 f0_1=sin(p.y*vec4(-1.6745,-2.8987,1.0796,-.4005)+p.z*vec4(4.1790,-3.0860,-3.7136,1.0541)+p.x*vec4(2.6095,-3.9927,1.3629,-3.9242)+vec4(7.5805,3.0794,1.7210,-4.7592));\nvec4 f0_2=sin(p.y*vec4(-1.1690,2.6507,-2.5833,-.7952)+p.z*vec4(-2.1702,-1.9758,.1388,-2.5661)+p.x*vec4(2.8543,4.1530,-2.3108,-.9129)+vec4(.7631,-5.4116,-4.4417,6.5267));\nvec4 f0_3=sin(p.y*vec4(.3317,.5146,3.3117,.9610)+p.z*vec4(-.1146,.1291,1.1622,.3476)+p.x*vec4(2.3463,-2.7041,-2.2209,3.6268)+vec4(5.6731,-4.7358,2.7893,-7.1612));\nvec4 f0_4=sin(p.y*vec4(-3.8313,-3.2312,4.0638,-4.1941)+p.z*vec4(2.3208,-1.6267,-1.2708,3.5948)+p.x*vec4(-.2369,.5631,-.7758,1.7456)+vec4(4.5843,1.3243,-8.2270,7.8213));\nvec4 f0_5=sin(p.y*vec4(-3.3688,3.2369,3.0260,2.5458)+p.z*vec4(3.7649,4.3277,-1.3795,-2.2266)+p.x*vec4(-.1241,1.5201,4.4127,-3.6465)+vec4(6.5967,5.1530,-7.6662,.6203));\nvec4 f1_0=sin(mat4(.4283,.0182,.5332,.0540,-.2346,.0960,-.1881,.0555,.2758,-.2231,-.4479,.2886,.4426,.2823,-.3488,.0299)*f0_0+\n    mat4(.1593,.1936,.2623,-.7297,.2478,.0291,.4403,.1618,.0097,-.0680,.0739,-.0924,-.3928,.4232,.2813,-.2751)*f0_1+\n    mat4(-.8969,-.2549,.2126,.2545,-.0137,-.2497,.4449,.6357,.6508,.1802,.2930,.5183,.2969,.3053,-.3403,.3291)*f0_2+\n    mat4(-.7413,-.3361,.3778,-.0318,.4063,.1229,.5541,.2476,-.8308,.2848,-.0984,-.1254,-.1721,-.0862,-.2333,.5118)*f0_3+\n    mat4(.0400,.3863,.1261,-.2855,-.0789,.4047,-.1773,.4571,-.2735,-.4307,-.4558,.1324,-.3745,-.0340,-.2384,.2797)*f0_4+\n    mat4(.3168,.6159,-.1358,.2209,.0596,.0468,-.0349,.0606,.0723,.2396,-.0949,-.2042,.2258,.3127,.4203,-.7138)*f0_5+\n    vec4(-.3935,-1.2879,-3.0636,2.8746))/1.00+f0_0;\nvec4 f1_1=sin(mat4(.2404,.2137,.4911,.2350,-.2768,-.3869,-.6949,-.1394,-.5911,-.4592,.3455,-.2965,.3846,.4321,.4655,-.2737)*f0_0+\n    mat4(.1943,.0581,.2987,.1255,.1294,-.0569,.3473,.0824,-.3558,.2081,-.1165,-.2984,-.1351,-.0961,-.3273,-.0740)*f0_1+\n    mat4(.4798,-.4114,-.2765,-.0956,.4051,-.0828,.3566,-.2902,-.1369,.2391,.0414,-.0202,.4755,.1570,.0453,-.0350)*f0_2+\n    mat4(.0034,-.3040,.0966,.1394,-.0596,.1715,.3755,.2095,-.0389,.2416,-.4348,.3523,.1106,-.5070,-.2783,-.5900)*f0_3+\n    mat4(.4393,.4704,-.1185,-.2027,.1559,-.0161,-.7020,.3401,-.0329,-.1101,-.2233,.5765,-.1210,-.3687,.2232,-.0947)*f0_4+\n    mat4(.1414,-.2183,.5306,.1045,.0847,.4032,.0373,.0557,.0837,.4058,.3312,-.1917,-.4103,.4489,-.0458,-.2355)*f0_5+\n    vec4(.7373,.2061,-1.9233,1.3916))/1.00+f0_1;\nvec4 f1_2=sin(mat4(-.3258,.1353,-.5998,-.0546,-.3110,-.0632,-.2792,-.0728,.1467,-.0446,.5993,.5235,.2560,-.1797,-.2506,-.2415)*f0_0+\n    mat4(.1154,-.4482,-.1964,.0812,.1196,-.2067,-.2043,.1711,.1562,-.1892,.1119,.0628,.2184,-.5889,-.0066,.1210)*f0_1+\n    mat4(-.1876,.3781,-.5209,-.4353,.0354,.1592,-.4752,.0808,.5745,.2097,.4002,.2874,.3446,-.0306,-.2091,.0462)*f0_2+\n    mat4(.0831,.0176,.3844,-.1191,.1301,.1722,-.3390,.0924,-.2368,-.3423,.2648,-.1552,-.0805,.2499,-.1025,-.6498)*f0_3+\n    mat4(-.3108,-.2391,-.1317,-.4019,.0505,.4596,.5610,-.3690,.1749,-.2221,.4036,.1886,.2317,.2628,.2346,-.3888)*f0_4+\n    mat4(-.3807,.2370,-.3637,-.0114,.2697,.3157,.2821,-.3275,.2776,.2074,.7315,-.5274,.2212,-.1343,.1926,.4157)*f0_5+\n    vec4(-.5634,3.0945,2.1514,.5819))/1.00+f0_2;\nvec4 f1_3=sin(mat4(.2322,.2288,.0503,-.1497,.2671,.0152,-.6257,-.2133,-.2370,-.1625,-.2606,.3965,-.0863,-.2658,-.5606,.2290)*f0_0+\n    mat4(.0737,.2728,.3821,.4612,-.2312,.0992,-.0190,.1686,.3150,-.1361,-.4138,.4684,-.1349,.1479,.2156,-.2543)*f0_1+\n    mat4(.0990,-.5684,.6348,-.3352,.3581,.1000,.1026,-.1389,-.2395,.2756,.3680,-.0288,-.4819,-.3938,-.3472,-.3838)*f0_2+\n    mat4(.0981,.1473,.0306,.0048,.4243,.4736,.3676,.1385,-.3010,.0703,-.0248,-.1841,-.2167,-.2414,.3576,.2105)*f0_3+\n    mat4(-.1007,.0874,.0111,-.5404,-.3333,.1131,.9492,.5615,-.0251,-.2502,-.0752,.0679,.1919,-.2333,.2773,.0613)*f0_4+\n    mat4(-.0899,-.0367,.1378,.0896,-.0785,-.2133,.0624,-.2813,-.0831,-.2130,-.2175,.1092,-.0421,.0080,-.6586,.3733)*f0_5+\n    vec4(-1.4891,-.6801,1.9186,-2.7150))/1.00+f0_3;\nvec4 f1_4=sin(mat4(.0889,-.1463,.4438,-.4469,-.4225,-.0207,-.0054,.0468,-.4142,.1697,-.4245,-.6603,-.2907,.0017,.3382,.3685)*f0_0+\n    mat4(-.1015,.1425,.0357,.2562,-.1381,.0196,.1697,-.4572,.1317,-.1572,.1803,.1498,.4495,.3801,.5033,-.1387)*f0_1+\n    mat4(-.5385,.3839,.1829,-.1837,-.2158,.3991,-.0564,.1084,.3708,-.1995,.5937,-.1388,.2912,.0370,.4859,.3851)*f0_2+\n    mat4(-.3379,.1068,-.3437,.1064,-.2266,-.1004,.4889,.3333,-.5013,-.1040,-.5713,.0189,-.2741,.3557,-.4767,.4575)*f0_3+\n    mat4(.4023,-.0471,-.5898,.3296,-.1395,-.1659,.3625,.4129,-.2640,-.5264,.8246,.3607,-.3476,.1076,-.0521,-.1226)*f0_4+\n    mat4(-.2420,-.1435,-.3602,.0014,.0274,.1435,.3942,.1281,-.2225,-.1567,.0066,-.0859,-.2016,.2456,-.4468,.3226)*f0_5+\n    vec4(-.2000,-1.3997,-2.1226,.9784))/1.00+f0_4;\nvec4 f1_5=sin(mat4(.3970,-.0700,.0088,-.3769,-.3805,.2062,.3198,.0001,.0358,.4662,.1860,-.2147,.1421,-.0042,-.0531,.2439)*f0_0+\n    mat4(.1147,-.2132,.3631,.2525,-.2267,-.0317,.0508,-.6767,.3219,.2937,-.3602,-.1908,-.5073,.2450,-.1174,-.4200)*f0_1+\n    mat4(-.5108,-.7364,-.4623,-.5500,.3217,-.2504,-.7220,-.6085,.0486,.1562,.0659,.0956,.0491,.0593,-.1767,.5219)*f0_2+\n    mat4(-.0658,.7926,-.3584,-.2188,-.1685,.3776,.4966,.0836,-.4346,.1745,-.4379,-.1422,-.2569,-.1465,.1528,-.2879)*f0_3+\n    mat4(.2083,-.2885,.0664,.3189,-.4236,-.1626,.5725,-.0780,-.1195,-.7710,-.2820,.6491,.4428,-.1771,.2408,.4136)*f0_4+\n    mat4(.1187,-.1239,-.1038,.2935,.0523,-.3224,.1298,-.0204,.4071,.1830,-.4513,.4001,.2575,.4154,-.1242,-.1355)*f0_5+\n    vec4(1.1119,.6284,1.4638,-1.9741))/1.00+f0_5;\nvec4 f2_0=sin(mat4(-.7476,-.1512,.3080,-.0518,-.1526,.7593,.4186,-.0252,.2402,-.0990,-.0299,.0941,-.1616,-.0831,.1996,-.4646)*f1_0+\n    mat4(-.3382,-.4718,.1786,.1919,.0752,-.2019,.1398,-.5919,-.0061,.0239,-.1130,.1397,.1847,.2366,-.6435,.2706)*f1_1+\n    mat4(.2061,.2028,-.0383,.1267,.4751,.3278,-.0123,-.3128,-.1276,-.2990,.0700,.4875,-.2132,-.3835,-.0098,-.4057)*f1_2+\n    mat4(.0427,.7227,-.2976,-.1341,-.3731,-.0410,.4150,-.1766,-.6085,-.3676,-.0448,.1699,.3741,.1241,.1318,-.3834)*f1_3+\n    mat4(-.1281,-.2315,-.0942,.5387,.6134,.4121,.0679,-.3293,.3324,-.0404,-.1638,.1273,-.3847,.0111,.4315,-.0408)*f1_4+\n    mat4(-.5511,-.4837,-.0846,.3745,-.0130,.1282,.2273,.4512,-.2767,-.2228,.3446,.3432,.1902,-.3868,.1270,-.2049)*f1_5+\n    vec4(2.6898,-.3244,2.0565,-2.3141))/1.41+f1_0;\nvec4 f2_1=sin(mat4(-.1512,.2711,-.1104,.1992,.1918,.2944,.6676,.1148,-.8442,-.3381,.3191,.2327,-.1993,.0403,.2573,-.0745)*f1_0+\n    mat4(.4533,.5307,-.0403,.0607,-.1723,.0917,.1157,.0253,.0560,.1484,-.0593,-.1993,.4877,.1215,-.0625,-.0989)*f1_1+\n    mat4(-.0188,.1648,.0009,.1781,-.4379,-.1470,.1297,-.0972,.0033,.0855,-.2943,.2497,-.0923,.4017,.3527,-.4016)*f1_2+\n    mat4(-.1575,.1430,.0484,.2227,-.1279,-.1169,-.1836,.2063,.2645,.6292,-.1794,-.1575,-.2973,.1234,-.1290,.4870)*f1_3+\n    mat4(.2762,-.0376,.2889,.2072,-.3314,-.3850,-.0265,.3790,.4006,-.4586,-.1992,.0816,-.0893,.2061,.0110,-.5390)*f1_4+\n    mat4(-.2337,.6043,.1270,.0673,-.3859,.3229,-.3137,.0167,.5843,.1215,.2581,.0153,.0665,.1436,.1446,-.0920)*f1_5+\n    vec4(.9082,.1214,1.4633,2.8008))/1.41+f1_1;\nvec4 f2_2=sin(mat4(-.3828,-.0706,-.1898,-.2981,-.0273,.2794,-.3240,-.0618,-.1908,-.4748,-.1554,.2195,.0841,-.1597,-.4302,.1904)*f1_0+\n    mat4(-.3488,.2210,-.0576,.3080,.3314,-.2857,.1262,-.0667,-.0881,-.3204,-.0971,.1079,.0290,.1824,.0076,-.3239)*f1_1+\n    mat4(-.4216,-.3578,-.2444,-.1458,.0995,-.1588,.1547,.0809,-.2430,.5579,.2154,-.1848,-.0435,.2232,-.5482,.1449)*f1_2+\n    mat4(-.2870,-.4095,.5798,-.1675,-.4569,-.1501,.1047,-.2987,-.3069,.6830,-.5784,.0658,.1756,-.1002,-.1165,.0195)*f1_3+\n    mat4(.0911,.1823,-.1248,.0121,.0720,-.3593,-.0082,-.2584,.1134,-.0082,-.0921,.0706,.0567,.1607,-.1352,-.1468)*f1_4+\n    mat4(-.4233,-.5088,.0110,-.2302,-.0793,.3303,-.1943,-.2227,-.0031,.2844,-.1248,.0380,.2147,-.0645,.2131,.0747)*f1_5+\n    vec4(-1.8416,2.9403,-.6392,-1.5377))/1.41+f1_2;\nvec4 f2_3=sin(mat4(-.3284,-.0344,-.2446,.3482,.3785,.2395,-.3987,-.5290,-.5285,.2529,.4058,.3430,.0184,.0831,.1462,-.0181)*f1_0+\n    mat4(.2067,-.4757,.0358,.1747,-.3760,.1504,-.1688,-.2903,-.1189,-.0841,.2082,-.2681,-.0966,.2234,.2865,.1299)*f1_1+\n    mat4(-.2397,.6295,-.1517,.2200,.3800,.2542,-.3478,-.2221,.4703,-.2264,.0437,.4949,.0069,.0189,.1994,.1025)*f1_2+\n    mat4(-.5775,-.0097,.1982,-.6734,.0265,-.1944,.1032,.1858,.4024,-.3728,.5513,.5587,.1949,.1583,.5918,.4059)*f1_3+\n    mat4(.3968,.0912,.4684,.2598,-.1597,.3542,.0057,-.0031,-.4975,.1690,.3321,.0570,.1208,-.2731,.4664,.3044)*f1_4+\n    mat4(-.1344,.0908,.5367,-.3595,.5749,-.2264,-.2164,.7811,.5142,-.2481,.1690,.6487,-.2733,.0082,.3073,-.2884)*f1_5+\n    vec4(2.1952,.1416,2.0763,-.2666))/1.41+f1_3;\nvec4 f2_4=sin(mat4(.5867,.1084,-.3888,-.7437,-.0411,.0453,-.4360,-.1674,-.1572,.2306,.0619,.2986,.5459,-.0554,.8014,-.6426)*f1_0+\n    mat4(.4036,-.2598,-.4398,.3322,-.3773,.2222,-.0115,.5663,-.1857,-.6525,.2277,.1871,-.3222,.2736,-.4254,-.1257)*f1_1+\n    mat4(.0314,.0419,.3031,-.2152,-.1060,-.4683,.0308,.0329,1.0827,-.3068,-.4914,-.6944,.0512,-.5530,-.2647,.6937)*f1_2+\n    mat4(-.0259,-.0822,-.1682,.3606,.8088,.3526,-.1553,-.3577,1.3533,-.0449,.0708,-.4184,.2020,.2685,.0336,.0636)*f1_3+\n    mat4(1.0073,.1952,-.3111,-.3199,-.1227,.0360,1.0460,-.4279,.0085,-.3509,-.5348,.5289,.5783,-.3530,-.1584,-.7851)*f1_4+\n    mat4(.3731,-.4806,-.1226,-.0438,.5776,.0596,-.7368,-.3683,.4283,-.3049,-.1540,.4872,-.2504,.2702,-.2418,-.0124)*f1_5+\n    vec4(1.0460,-.7609,-2.6136,1.7412))/1.41+f1_4;\nvec4 f2_5=sin(mat4(.0206,-.1916,.3615,-.1659,.1648,-.2299,-.1039,-.2046,.1742,.6134,-.0394,-.2142,-.0560,.4014,-.3397,-.0218)*f1_0+\n    mat4(.4030,-.0171,-.5419,-.1809,-.2173,.1619,.2130,.4290,-.3837,.4710,.1555,.3157,-.2684,.6031,.4861,.0961)*f1_1+\n    mat4(.2709,.4967,.6131,.3472,-.2004,.0379,.4512,-.1495,.3167,-.3547,-.1208,.0464,.0229,-.2151,-.4797,.5806)*f1_2+\n    mat4(.0644,-.7797,-.6199,.0489,.1586,-.0999,.2995,.3767,.1271,-.6964,-.3474,.1706,-.3235,.3332,-.6006,-.2708)*f1_3+\n    mat4(.3736,-.5805,-.8545,.4102,.4190,.6573,.3400,.5236,.2362,.3213,-.0080,.4325,-.4875,-.2194,-.4284,-.4324)*f1_4+\n    mat4(-.6019,.4234,-.0551,-.3841,.5159,-.7246,-.5670,.2715,-.1963,-.1422,-.1472,-.1825,-.1229,.5466,.1769,-.2313)*f1_5+\n    vec4(2.3196,-.4360,-.6900,-.8132))/1.41+f1_5;\nvec4 f3_0=sin(mat4(-.5579,1.3101,-.4695,.2828,.0787,-.0961,-.3525,-.5318,-.0997,.6600,-.1396,.6494,.4997,-.3140,.5802,.0319)*f2_0+\n    mat4(-.4792,-.4421,.1052,.1660,.3382,.2075,.3630,.3631,.1838,.6143,-.1399,-.2465,-.2589,.4299,-.4456,.0937)*f2_1+\n    mat4(-.5273,.0413,.4123,.2149,.2962,-.5134,.4068,-.2666,-.2524,-.1862,.0053,.3725,.1653,-.2569,.3187,-.1401)*f2_2+\n    mat4(-.2795,-.7765,.1561,-.0157,-.5101,.4763,-.2073,.6251,-.1524,-.4631,.1321,-.0577,.2601,.1246,.3625,.1741)*f2_3+\n    mat4(-.7595,-1.0753,-.1062,-.3118,-.4030,-.1255,.1851,.3952,-.1828,.5075,-.4244,-.4543,.0777,.5249,-.1330,.2601)*f2_4+\n    mat4(.1103,-.0809,.4848,.8048,-.4218,-.1034,-.0854,-.0101,.1650,.5752,-.0955,.8972,.2932,.1352,-.2050,-.2736)*f2_5+\n    vec4(-.5803,-2.2796,1.8558,-2.1928))/1.73+f2_0;\nvec4 f3_1=sin(mat4(-.1701,.0715,.6682,.6901,.1899,.6150,-.4114,-.6737,-.6088,.4367,.0412,.6845,-.4655,.1296,-.1796,.3806)*f2_0+\n    mat4(-.0154,-.3797,-.5231,-.4007,-.2943,.0393,-.2630,.0612,.0030,.6002,-.6594,.4744,.3566,.1060,.5724,-.4538)*f2_1+\n    mat4(-.7308,.0065,.1867,.2402,-.2761,-.3315,-.3979,.3206,-.5998,-.3101,.1033,.0996,-.1005,.0116,.4866,-.0806)*f2_2+\n    mat4(-.2362,-.3564,.5576,-.1515,-.1673,.4134,-.4159,-.2098,.1843,.1361,-.4072,.7149,.4603,-.0537,-.2983,.1770)*f2_3+\n    mat4(-.1203,-.0858,-.1197,.2894,-.2578,.2790,-.0687,-.0156,.4650,.4792,-.3554,-.3058,.4087,.5727,.3059,-.3743)*f2_4+\n    mat4(.3603,-.4230,.3266,.2797,-.6443,.4882,.1038,.2348,.0830,.0114,.2969,.1153,-.0827,-.1836,-.2541,.3836)*f2_5+\n    vec4(-1.3221,2.3931,.1386,-.4358))/1.73+f2_1;\nvec4 f3_2=sin(mat4(-.2984,.9361,-.4965,.4934,.8901,-.2692,.2627,.1331,.0306,.5504,.0950,-.2044,-.5674,-.0827,.4890,.0888)*f2_0+\n    mat4(-.0309,-.1783,.1285,.1018,-.6561,.3033,-.3128,-.1962,-.3187,.2721,.2465,.2069,-.0929,-.4486,.0533,.4301)*f2_1+\n    mat4(.6094,.3260,.0924,.2739,.8089,-.4134,.2734,-.5275,.3755,-.3839,-.4528,-.3476,-.2863,-.7052,.0424,.1695)*f2_2+\n    mat4(1.3079,-.7847,-.1620,-.3525,-1.2070,.8570,.0372,-.1725,-.0091,-.1153,-.1257,-.0472,-1.2006,.1178,.2554,.2007)*f2_3+\n    mat4(1.1689,-.8032,.3481,.3992,-.1648,.0159,.8135,-.7356,-.4871,.1758,-.0342,.1652,-.7809,.2302,-.3997,-.2953)*f2_4+\n    mat4(-.8927,.0210,.0586,-.2247,.8452,-.4174,-.4407,.0466,-.8509,.5526,-.0873,-.2954,-.0756,.1924,-.0194,.1312)*f2_5+\n    vec4(1.6865,-2.1835,.4587,-2.6469))/1.73+f2_2;\nvec4 f3_3=sin(mat4(.4390,-.4103,.1745,.6960,-.2662,-.8931,.6693,-.2409,-.4103,.2679,.2690,.0936,.4968,-.3329,.2855,-.0871)*f2_0+\n    mat4(-.0231,.7836,-.1714,.3489,-.7215,.0184,.5462,-.0510,.2714,.8855,-.5149,.1400,.6539,.9522,.1646,.0576)*f2_1+\n    mat4(.0529,-.1013,.7117,.3552,-.3714,.3185,.0963,.0242,.3325,.3086,.0689,.2264,-.0772,-.3834,-.1785,-.4543)*f2_2+\n    mat4(-.0567,.0722,-.3264,-.2579,-.2114,-.2502,-.1859,.2839,.3084,.3888,.1262,.1273,.7690,.2780,.3842,-.2156)*f2_3+\n    mat4(.2122,.1122,-.2625,.1190,-.7342,.1912,-.0874,-.3581,-.0335,-.2309,.0696,-.1469,.1320,-.0154,.3271,.2947)*f2_4+\n    mat4(-.2962,.1927,-.4254,-.0605,.0607,-.4551,-.0723,-.3585,-.2539,.3514,-.4468,.1805,-.0339,.2503,.3102,.4332)*f2_5+\n    vec4(1.9112,2.9841,-1.7244,.7379))/1.73+f2_3;\nvec4 f3_4=sin(mat4(-.4379,-1.0623,.3081,.2389,.4325,.4483,-.1957,-.0928,.4565,-1.2847,-.7522,-.1213,.0918,.2194,-.1253,.3754)*f2_0+\n    mat4(.7189,.2090,.2487,.4036,.1111,-.7672,-.5462,-.0505,.3691,.2164,.5671,-.6547,-.0210,.5157,.6893,-.4124)*f2_1+\n    mat4(.4372,-.3423,-.4577,-.2213,.3092,.9729,-.0625,-.4263,-.0637,.3170,.1468,-.9859,-.1708,.4735,.2395,.4159)*f2_2+\n    mat4(.0168,1.4777,.0056,-.3475,.3949,-1.4235,.2247,.7943,-.3335,1.2025,.2387,-.7363,-.0325,-.8510,-.4534,.4023)*f2_3+\n    mat4(-.2163,1.5628,-.4146,-.0790,-.0151,-.9676,-.0404,-.3481,-.2829,-.4287,.3071,-.1027,.0956,-.2499,.6447,-.5348)*f2_4+\n    mat4(-.0372,-.5469,.1173,-.0969,-.1760,.3727,.0610,-.5726,-.2185,-.1747,-.0911,.0553,.1506,-.3185,-.4991,-.1389)*f2_5+\n    vec4(.0536,-2.0249,.5932,-.4759))/1.73+f2_4;\nvec4 f3_5=sin(mat4(-.3650,-.4724,.4515,-.1794,.2276,.0227,.1208,.0158,.0980,-.1774,.6257,.5810,.2214,-.1252,-.7460,-.3124)*f2_0+\n    mat4(.0039,.4478,.4631,-.2739,.7019,-.5154,-.0598,-.0822,.3901,.4001,-.3618,.7851,-.1460,-.0603,-.3426,.2344)*f2_1+\n    mat4(-.5802,-.0878,-.3130,-.2578,-.8871,.7493,-.1037,-.5671,-.2257,.2380,-.0577,.0498,-.0372,.1800,.2026,-.3215)*f2_2+\n    mat4(-.6840,.5784,-.1951,-.1349,.5031,.1899,.5149,1.1500,-.1624,.5718,-.0109,-.4735,.5503,-.0052,.3117,-.4614)*f2_3+\n    mat4(-.7935,.6748,.1929,-.5100,.0483,-.2770,.4352,.6686,-.0390,-.5990,-.1360,.0279,-.0228,.0720,-.2516,.1471)*f2_4+\n    mat4(.4111,.2605,-.2683,-.7513,-.8241,.3183,.0436,.0472,.0647,.0005,.8183,-.4727,.6502,-.1617,-.4478,.3644)*f2_5+\n    vec4(.3259,-1.0914,.2229,-2.5857))/1.73+f2_5;\nreturn dot(f3_0,vec4(.0675,-.0395,.0591,-.0347))+\n    dot(f3_1,vec4(.0397,.0425,.0325,.0570))+\n    dot(f3_2,vec4(-.0475,-.0479,-.0427,-.0508))+\n    dot(f3_3,vec4(-.0675,-.0469,-.0205,.0463))+\n    dot(f3_4,vec4(-.0391,-.0325,.0287,.0326))+\n    dot(f3_5,vec4(.0430,-.0297,.0152,.0168))+\n    -0.162;\n}\n\n#else\n#if LEVEL==1\n//train_siren(sdfloader, 24, 2, 15) loss = abs(model_output-truth)**3 + 0.0001*(model_output -model_input)**2 \nfloat scene(vec3 p) {\n    if (length(p) > 1.) return length(p)-.8;\nvec4 f0_0=sin(p.y*vec4(.8492,-3.1536,4.2514,-2.5443)+p.z*vec4(2.0303,-2.6018,-.2758,.7154)+p.x*vec4(1.2334,-2.7103,-2.0685,.2913)+vec4(8.2323,.7743,-7.1299,-1.8285));\nvec4 f0_1=sin(p.y*vec4(2.1637,1.1794,-.5900,-3.1059)+p.z*vec4(-3.6854,.0824,1.1433,3.1549)+p.x*vec4(2.9993,-2.4728,-3.2950,-2.3026)+vec4(7.8344,7.0982,1.5609,-6.9444));\nvec4 f0_2=sin(p.y*vec4(2.7085,-.0694,-1.4490,-1.3753)+p.z*vec4(-1.6991,-1.0108,-1.4092,-2.4201)+p.x*vec4(.6893,-1.5291,-3.3328,3.9221)+vec4(6.2188,.5368,-1.5975,-8.2845));\nvec4 f0_3=sin(p.y*vec4(-3.5305,-2.8488,3.1625,-1.3753)+p.z*vec4(-.3045,-2.8575,-3.7523,-3.3139)+p.x*vec4(2.9020,-1.8811,.8204,-2.8186)+vec4(-3.3321,-1.1910,6.0313,4.6544));\nvec4 f0_4=sin(p.y*vec4(-.8159,-.0311,3.7440,-1.8225)+p.z*vec4(3.7890,-2.9560,3.9464,-.3521)+p.x*vec4(-4.0974,.2942,-2.6997,2.9319)+vec4(-5.3754,5.8587,7.3798,-5.3308));\nvec4 f0_5=sin(p.y*vec4(.1891,-2.6589,1.7235,3.1446)+p.z*vec4(3.6162,2.6861,1.7175,-2.5797)+p.x*vec4(-4.2137,1.7879,1.6982,-2.5067)+vec4(6.9776,8.2737,5.0327,-6.8911));\nvec4 f1_0=sin(mat4(-.4580,-.3591,-.2458,-.7723,-.4684,.1794,-.0774,.0707,.0963,-.3527,-.2931,.0823,-.4707,-.1198,-.1699,-.0028)*f0_0+\n    mat4(-.6387,.0965,.1119,.0369,-.1827,.0761,-.4077,-.3708,.5845,.1853,.3939,-.2916,-.7471,.2621,-.3722,-.0335)*f0_1+\n    mat4(-.2305,.1100,-.5388,-.4042,-.5499,.2220,.1158,.4419,.8336,-.2037,-.1127,-.2849,-.1972,.5653,.0601,.3877)*f0_2+\n    mat4(-.1586,.0873,.2125,.0324,-.4838,.8431,-.1811,-.7007,.1127,-.2808,-.2237,.2380,-.0507,-.0127,.3203,-.1578)*f0_3+\n    mat4(-.2425,.1650,.0394,-.0723,-.2488,-.4288,-.0929,.0764,.0111,.1365,-.0250,-.0358,.2158,.6068,.4613,-.1824)*f0_4+\n    mat4(-.2719,-.2084,-.0606,-.1048,-.1194,-.5983,.2191,-.4768,-.0091,.2867,-.3471,.2759,.2746,.4422,-.0788,-.1719)*f0_5+\n    vec4(-1.1601,.5299,-.4378,.9026))/1.00+f0_0;\nvec4 f1_1=sin(mat4(.5062,-.4534,.0559,-.1254,.0690,-.0408,.0116,-.1550,.2808,-.2661,-.3033,-.2412,-.4988,-.0269,.0018,-.2127)*f0_0+\n    mat4(.6238,-.0637,.0762,-.2859,-.3781,.2471,.5238,-.4009,.0110,.3775,-.0360,.0424,.4594,-.0024,.0225,-.6443)*f0_1+\n    mat4(.1892,-.1313,-.1736,-.5698,-.4082,.3731,-.5478,.4749,-.4338,.3774,-.2732,.4114,-.2886,.1701,-.0440,-.3256)*f0_2+\n    mat4(-.2854,.2050,.2492,-.3566,.1414,.2293,-.3188,-.2672,-.1124,.3396,.0055,.4521,.5054,-.1283,-.1135,-.5348)*f0_3+\n    mat4(-.3760,.2989,-.1789,.2557,.2399,-.6459,-.3775,.1709,-.0433,-.0980,-.0313,.3756,.6284,-.3899,-.0856,-.0783)*f0_4+\n    mat4(-.0025,.1410,.0952,.1477,.0660,.0624,.0743,-.1663,-.1933,.2924,-.2988,.6986,.0736,.1034,-.0694,.0121)*f0_5+\n    vec4(2.2564,1.2602,-.4925,.2218))/1.00+f0_1;\nvec4 f1_2=sin(mat4(-.4401,-.3026,.0227,.1415,-.2492,.0738,-.3186,.9295,.1619,.2663,.0957,-.1673,-.2081,.0025,.3243,.3319)*f0_0+\n    mat4(-.4203,.3659,.3905,-.1523,-.0023,.0747,-.5057,-.0260,.2742,.2248,.2472,-.3317,-.1277,-.0292,-.2564,-.3361)*f0_1+\n    mat4(-.4158,.7305,-.7553,-.3931,-.1338,-.1459,.1116,.2605,.0181,-.0307,.3358,-.2385,-.1403,.3447,-.7076,-.4122)*f0_2+\n    mat4(.1874,.3984,.0733,-.4968,-.5643,.3676,-.2994,.0719,-.0354,-.1701,.3066,.2194,-.3608,.3860,-.7113,.0587)*f0_3+\n    mat4(.0995,.3485,-.3206,.2706,-.2510,-.1898,.1470,-.1533,.0282,.1463,-.2167,.1259,-.3989,.0412,-.3654,.2205)*f0_4+\n    mat4(-.1051,.1175,-.2125,-.2052,.0743,.4249,.2884,.1587,.1687,.1844,.5628,.3804,-.0165,.1374,-.0620,.6649)*f0_5+\n    vec4(.8299,.3346,1.9768,-.2290))/1.00+f0_2;\nvec4 f1_3=sin(mat4(-.0949,.2352,-.0752,.2184,.1637,-.2041,-.1961,.4540,-.0427,.1923,.1093,.1543,.1447,-.2237,-.1430,.5119)*f0_0+\n    mat4(-.1044,-.1089,.1748,-.1808,-.6169,.0072,-.2089,-.2005,-.4437,-.1568,-.0632,.2834,.7249,-.0745,-.2137,.4346)*f0_1+\n    mat4(-.2787,-.0280,.1788,.4294,.1005,-.2995,-.1773,-.5533,-.6840,-.1035,-.0848,.2626,.2076,.2397,.2994,-.3702)*f0_2+\n    mat4(-.1988,-.2248,-.0634,.1309,-.1593,.2817,-.5118,.3122,.4537,-.2462,.0094,.0468,.0103,-.2185,-.3683,.3952)*f0_3+\n    mat4(-.0323,-.2954,.0896,-.1814,-.1697,-.2709,.0173,-.0095,-.0648,-.0294,.1244,-.1709,.5009,.1065,-.1984,-.0619)*f0_4+\n    mat4(.1121,.0948,-.1159,-.1787,.1001,.2101,-.1895,-.1386,-.0169,.2297,.0504,.1761,.4173,-.1880,-.1604,-.1343)*f0_5+\n    vec4(-2.3796,2.1204,-1.3265,-2.0990))/1.00+f0_3;\nvec4 f1_4=sin(mat4(-.1173,-.0086,-.1638,.0874,.1568,-.0614,.0250,.5144,-.3971,.1971,.0916,-.1922,-.1976,-.1462,.0360,-.5170)*f0_0+\n    mat4(-.0545,-.4532,.3809,.0364,.1839,.2455,.1499,-.5448,.0455,.2235,-.1757,-.0502,-.4128,-.0836,.1797,.2501)*f0_1+\n    mat4(-.5005,.5680,-.0334,.1458,.4098,.6234,-.1801,.2116,-.2571,.8072,.0991,-.0312,.4996,-.1413,-.2944,.6564)*f0_2+\n    mat4(.2226,.0369,.1292,-.4306,.4484,-.1363,.1214,.0977,.1514,.0191,.2961,.0282,.3591,-.3719,-.0422,.1681)*f0_3+\n    mat4(-.0765,.0323,-.1163,-.0258,-.2152,-.1764,.0355,-.1135,.1124,-.0271,-.0338,.6661,.0069,-.2052,-.2571,.1726)*f0_4+\n    mat4(.2477,-.1941,.0263,.3586,.7080,-.2954,.0446,.3193,-.3413,.1220,.1603,.4147,-.3961,-.2685,-.0134,.5242)*f0_5+\n    vec4(-1.9690,-2.0433,-2.1038,.5665))/1.00+f0_4;\nvec4 f1_5=sin(mat4(-.5888,.0037,-.1493,-.4660,-.3044,.3332,-.2052,.1175,-.2343,-.0941,.1692,-.0891,.1491,-.0332,.2833,.2458)*f0_0+\n    mat4(.0784,.2676,-.2020,-.2411,-.1333,-.1154,.1847,.2442,.3955,.2428,-.2283,.1718,-.4057,-.2134,-.2670,.2937)*f0_1+\n    mat4(-.3168,-.3787,.1858,.0724,.3125,.2058,.2569,.2424,.0881,-.2949,-.2564,-.0694,.0164,-.0384,.4766,.2163)*f0_2+\n    mat4(.0710,.2149,-.3981,.1491,-.4004,.0871,-.4029,.2981,.5039,.0432,.2059,.0846,-.3547,-.3554,-.3770,-.3855)*f0_3+\n    mat4(-.1528,-.0439,.1485,.2239,.0045,-.2379,.0340,-.0844,.3762,.1915,.1721,.2707,.3165,-.5013,.4390,-.1853)*f0_4+\n    mat4(-.3867,.2769,-.0838,-.2804,.5560,.2478,.7377,.0265,.1205,.1780,-.2092,.1915,-.1012,-.2299,.4956,.1346)*f0_5+\n    vec4(-.2941,1.7317,-1.1038,2.2876))/1.00+f0_5;\nvec4 f2_0=sin(mat4(-.0522,.5138,-.0900,-.2040,.2550,.8599,-.5263,.1611,-.4182,-.0008,-.5171,-.5176,.2867,.2992,-.3244,-.3121)*f1_0+\n    mat4(-.3275,-.0448,.2108,.6352,-.4221,-.1788,.3204,.8966,.3556,.1856,.2491,-.4446,.0253,.5647,.1699,.2624)*f1_1+\n    mat4(-.7077,.8153,-.0659,-.1346,-.4776,.7336,-.3527,-.1274,-.0395,.7140,.5397,.6400,.3088,.3493,.6563,.2562)*f1_2+\n    mat4(-.4112,.2368,-.3259,.0312,.3326,.3846,-.1377,-.0859,.3805,-.6316,-.3325,-.2191,.4008,-.2040,.2446,-.0542)*f1_3+\n    mat4(-.2776,.6583,-.1233,.0789,-.5844,.9975,.1644,.5170,.3126,-.5971,.7574,.2651,-.4322,-.5979,-.3646,-.2537)*f1_4+\n    mat4(.4180,.3118,.5762,.0217,.4996,.6601,-.4363,.1124,-.1731,.9978,.4948,.0859,.1247,-.0852,-.0094,-.3074)*f1_5+\n    vec4(-.5564,.4538,-.5834,-.3345))/1.41+f1_0;\nvec4 f2_1=sin(mat4(.1809,.1194,.8741,-.4402,.4410,.2212,.8835,-.6453,.3458,-.3824,.1327,.0902,-.2926,.2484,-.3067,-.1225)*f1_0+\n    mat4(-.2542,.0368,-.4391,.2098,-.1046,.3827,-.3644,.0248,-.5124,.4207,.1866,-.1901,.1711,.0435,.2286,.0733)*f1_1+\n    mat4(-.1395,-.5283,-.3573,-.2013,.5058,-.1620,-.1637,-.3688,-.0961,-.0179,.4244,-.1639,1.0688,-.2210,-.0849,.2363)*f1_2+\n    mat4(.0244,.5470,.1783,-.2540,-.2083,.0825,-.4470,.0946,-.0161,-.1693,.5090,-.5754,-.1939,.2268,-.2708,.3402)*f1_3+\n    mat4(.3091,-.2567,.1460,.1030,.4530,.0705,.5209,-.5854,.1578,-.4835,.1141,.0751,-.5655,-.3546,-.5853,.2299)*f1_4+\n    mat4(.3429,-.3937,.4304,-.1933,.1821,-.5243,.3037,-.1521,-.3790,-.2177,.6741,-.2862,.3516,-.2026,-.0849,-.2023)*f1_5+\n    vec4(-2.0182,.5772,1.4044,2.1393))/1.41+f1_1;\nvec4 f2_2=sin(mat4(-.5077,-.4142,.2708,.3081,-.6767,-.4811,.4291,-.0672,-.5041,.2150,.3125,-.2161,-.6413,-.3245,-.0524,-.2983)*f1_0+\n    mat4(-.2407,-.5879,-.2966,.2056,.0649,-.5576,-.5009,-.0698,.4031,-.3684,.0056,-.2824,-.4777,-.7021,.4408,-.1383)*f1_1+\n    mat4(-.2794,-.5652,-.0038,.1481,.0199,-.2712,-.2220,-.4349,-.0248,-.9646,-.3325,.3309,.1804,.0158,.1826,-.4807)*f1_2+\n    mat4(-.4443,-.2897,.2314,.4056,-.5744,-.3758,-.4904,-.1823,-.0158,.3052,-.2436,.0334,.4746,.1673,.3041,-.3414)*f1_3+\n    mat4(-.1371,.0742,.3638,.5218,.7119,-.7504,.0206,-.0930,.0112,-.0965,-.2709,.3288,.5057,1.2219,-.7094,-.0810)*f1_4+\n    mat4(-.0083,-.4413,.1369,-.1555,-.7499,-.3262,.2408,.5089,.2438,.1859,.6687,.4159,-.2968,-.3286,-.5170,-.3279)*f1_5+\n    vec4(-1.8856,1.5024,-2.8512,-.3744))/1.41+f1_2;\nvec4 f2_3=sin(mat4(1.2399,.1631,-.4531,.1906,1.8745,.3440,.1115,.2580,.8242,-.0553,-.7853,.0271,.4777,.2145,.2358,-.2908)*f1_0+\n    mat4(.2972,.1495,.1459,.2982,-.2873,.4552,-.5219,.1638,-.0986,-.0457,-.0788,.7854,.5313,.3866,-.6354,-.1472)*f1_1+\n    mat4(.6113,.0395,-.3419,.6074,.1651,-.4138,.1476,-.0156,.1489,.3491,-.5215,1.0861,-.0476,.3061,.6594,.0527)*f1_2+\n    mat4(-.0443,-.3457,-.2717,.2713,-.2162,-.0557,-.4465,-.0147,-.2044,-.0393,.2003,.1617,.6544,.3789,.3576,.2094)*f1_3+\n    mat4(-.0916,-.3850,-.2481,.1611,-.0042,.2985,-.1898,.0848,.3283,-.0043,.3993,.3080,-1.5710,-.2324,.2511,-.6316)*f1_4+\n    mat4(.8262,.4201,-.3914,.0550,.8984,.5615,.0745,.2815,.4997,-.3894,.1098,.2730,.3448,.1469,.5688,-.1453)*f1_5+\n    vec4(-.2235,.2605,.5247,1.3310))/1.41+f1_3;\nvec4 f2_4=sin(mat4(-.5574,-.2438,-.6280,.6851,-.0486,-.0124,.0624,.7448,.0523,.2830,.2307,-.5110,-.0492,.1000,.1749,.4584)*f1_0+\n    mat4(-.7541,.2490,.5311,-.2586,.0516,.1387,.1324,.5100,.2034,-.4428,-.0576,-.5620,-.6683,.3471,-.4841,.1482)*f1_1+\n    mat4(-.4280,.3313,.1148,.3440,-.2536,-.4068,.4173,.4168,-.1324,-.6707,.1307,.5240,-.5838,-.1244,.3252,-.0168)*f1_2+\n    mat4(.1040,-.7364,-.6550,.2508,.4113,.1831,.5180,.1322,.3674,.1983,-.5105,-.5664,.3346,.2571,-.2393,-.1656)*f1_3+\n    mat4(-.0501,.0677,.1875,-.3256,.1911,-.0706,-.5060,-.1132,-.8338,.4796,-.2428,-.1871,.0571,.3844,.1191,-.8371)*f1_4+\n    mat4(-.4982,-.1125,-.1938,.9975,-.4641,-.2440,.4490,.5749,-.2811,-.4488,-.7785,.4198,-.3752,.3485,.0646,-.0372)*f1_5+\n    vec4(.2451,-2.7481,1.6170,2.7030))/1.41+f1_4;\nvec4 f2_5=sin(mat4(-.5416,.1581,.1109,-.1575,-.1176,.0102,.0321,-.3840,-.0201,.2303,.8922,.4582,.4632,.1763,.1207,-.4809)*f1_0+\n    mat4(.3073,.4923,.3689,-.2218,.1937,-.1456,-.6348,-.0421,-.5541,.1119,.0108,-.0817,-.0295,.5413,.1032,-.0510)*f1_1+\n    mat4(.1145,.1946,-.0029,-.1022,.1982,.0201,.1337,-.0567,.0051,-.1692,.2642,-.1504,-.5321,-.1657,.2836,-.6068)*f1_2+\n    mat4(-.6588,.1687,-.1320,-.1531,.3751,-.4534,-.6667,.4604,.0680,-.4678,-.0213,-.2293,-.2008,.1564,.1174,-.0282)*f1_3+\n    mat4(.2706,.1628,.3384,-.0827,-.5909,.0290,-.1427,-.6185,.3517,.3706,-.0748,-.2378,.2287,-.5105,-.3715,.1601)*f1_4+\n    mat4(-.2761,.5620,-.1432,-.4194,.2091,-.0878,-.1639,-.7371,-.3619,-.0485,.5911,.0672,-.1087,.2749,-.3186,-.0562)*f1_5+\n    vec4(1.9430,1.5850,-.4730,1.9014))/1.41+f1_5;\nvec4 f3_0=sin(mat4(.2007,.0618,-.0220,-.7388,.1409,1.2192,.0593,-.7798,.0911,.4274,-.0096,-.6169,.1536,-.3472,.3440,-.3277)*f2_0+\n    mat4(-.2100,-.2354,.4322,-.6668,-.2674,-.1906,-.2812,.0904,-.2747,-.5220,-.1945,.5501,-.4535,.3777,-.1429,-.6704)*f2_1+\n    mat4(.3746,-.0909,-.3018,.0196,-.4701,.7244,-.0673,-.5587,.4863,.3420,-.0909,-1.0957,-.7724,.0927,-.2213,-.1709)*f2_2+\n    mat4(.1928,-.6222,.1538,1.0166,-.1972,.2724,-.2347,.0524,.4114,-.1728,.3652,.7044,.5539,-.3122,.0561,-.0631)*f2_3+\n    mat4(-.5886,-.1030,.2825,.3391,.3774,.1824,.1478,.2044,.4657,.3389,.4348,-.2773,.0069,-.5947,.1091,.9238)*f2_4+\n    mat4(.1958,.5155,.2794,-.9993,.5927,.3713,.0967,.0166,-.1539,.3186,-.0380,-.1857,.4631,.4401,.5337,-.3898)*f2_5+\n    vec4(1.9893,.8645,-1.4119,2.8486))/1.73+f2_0;\nvec4 f3_1=sin(mat4(.1104,-.3447,.2655,.4982,.4419,-.2617,-.0498,-.3696,-.1561,-.2668,.8191,.2826,.2961,-.3773,.2588,.3373)*f2_0+\n    mat4(.6862,-.0627,.4938,.6880,.5989,.2134,-.6080,-.6415,-.1003,1.0786,-.0152,-.0982,.1867,-.1114,-.2293,.4147)*f2_1+\n    mat4(.1726,.2518,.7151,.0228,-.1362,.3352,-.7119,.2925,-.2686,.0798,.1185,.6655,-.3559,.2566,.4520,-.1860)*f2_2+\n    mat4(-.3171,-.0583,.0016,-.1027,.4489,.1912,-.0557,.2452,-.4275,.3881,.0427,-.1960,.1632,-.0783,.1403,.5006)*f2_3+\n    mat4(.0813,.3805,.3390,.3408,-.3449,-.6171,-.0545,-.0001,-.5404,-.1215,-.2123,.1113,-.4064,.4591,.0108,.0405)*f2_4+\n    mat4(.1169,-.7242,-.2335,.0465,.7025,.0055,-.0758,.0635,-.3642,-.5353,.5487,.0209,.3908,.4558,-.5248,.0546)*f2_5+\n    vec4(.3422,-1.7922,1.0598,.3482))/1.73+f2_1;\nvec4 f3_2=sin(mat4(.2349,-.6517,-.1259,-.4556,.2578,.5178,-.6482,.4802,1.1230,-.5294,-.3671,.1878,-.2001,.0374,-.0554,.2286)*f2_0+\n    mat4(.1674,-.5603,.1656,.0567,-.3943,.0649,-.1802,-.1209,-.1440,.0141,.3102,-.0797,.3413,.2230,-.1278,.3889)*f2_1+\n    mat4(1.8272,.1541,.2337,-.0095,-.4193,-.6876,.4774,.4338,.1961,-.1404,-.2387,.1968,.8442,.0991,.1291,.3290)*f2_2+\n    mat4(-.1199,.4082,.4789,.2691,-.1935,.0344,-.0147,-.5080,-.3039,.4404,-.0279,.1535,.6905,-.1188,-.1131,.2814)*f2_3+\n    mat4(-.0284,-.2919,-.1578,-.1254,.0922,-.1007,-.2364,.3043,-.3625,-.6060,-.1828,.4089,-.2301,1.2275,.4786,.0091)*f2_4+\n    mat4(.0162,-.1108,-.5261,.2127,-.2708,.3115,.1231,-.1766,-.2043,.3421,-.4441,-.0574,.2832,-.4080,.1936,-.5364)*f2_5+\n    vec4(1.3987,.0160,.7507,-.7974))/1.73+f2_2;\nvec4 f3_3=sin(mat4(-.0778,-.1509,-.2268,.9344,.0677,.5805,-.8326,1.0738,.2009,.3705,-.4457,.6048,-.1400,-.3697,-.5035,.4933)*f2_0+\n    mat4(.2169,.3269,-.0746,.1201,.0791,.0114,.0206,.1545,-.2629,-.1248,.5481,-.8177,-.1561,.0681,-.0150,.3439)*f2_1+\n    mat4(.2138,.3844,-.3090,.0741,.1385,.4405,.2029,-.4589,.4596,.5381,.0465,.2362,.3048,.6627,-.4239,-.3463)*f2_2+\n    mat4(.1723,-.8027,-.0347,-.1695,.3260,.1486,.0896,.6103,-.0013,.2985,.3479,-.6133,-.2496,-.6317,.4013,.4711)*f2_3+\n    mat4(-.5099,-.4188,.5125,-.3464,-.3791,.2073,-.7667,.7063,-.4004,-.1388,.2130,.3167,.1130,.2000,.3347,-.8300)*f2_4+\n    mat4(.4484,.1285,-.2463,.5717,-.0044,.4693,.0008,.1456,-.1677,.1174,.6092,.5239,.1347,.1279,.0775,.6546)*f2_5+\n    vec4(-.9035,-1.5196,-.7785,-.0125))/1.73+f2_3;\nvec4 f3_4=sin(mat4(.3304,-.8994,-.4839,.4736,.0486,-.9699,.0285,-.1045,-.1216,.2780,-.7396,-.1372,-.2484,-.0911,-.1853,-.0819)*f2_0+\n    mat4(.2069,-.3092,-.4124,-.1983,-.2677,.0712,.2682,.1226,.0149,-.0401,.4273,.6750,-.0024,-.1839,-.4116,-.1584)*f2_1+\n    mat4(.2000,.1654,.4919,.1594,-.4273,.6193,-.6226,-.3760,.7886,.3578,-.4967,-.4694,.0595,1.2477,-.3629,.0441)*f2_2+\n    mat4(.4713,-.1136,.8300,.2571,.5826,.1809,-.7185,.1629,-.1892,.3205,.6238,-.2458,.6573,-.7626,.3358,.6278)*f2_3+\n    mat4(-.0569,-.4071,.6056,-.2143,.0050,-.7672,.0685,.2976,.5013,-.5485,.0275,-.2951,-.5145,.7914,.6168,-.1952)*f2_4+\n    mat4(1.0848,-.0590,-.6325,-.3758,-.3727,.5307,-.2305,.0600,-.2103,-.3392,.2469,.2512,.5764,-.3839,.3681,-.1133)*f2_5+\n    vec4(-2.0616,-.0237,2.2640,.4176))/1.73+f2_4;\nvec4 f3_5=sin(mat4(.3557,.3146,-.6437,-.2685,.2421,-.0071,-.1016,-.0506,.6434,-.0866,-.1555,-.2972,.2422,-.0429,-.4653,-.3587)*f2_0+\n    mat4(.5265,-.2937,-.3850,-.7797,.2863,.0180,.4691,.3151,-.6624,.4976,.4985,.1544,-.2337,-.0839,-.5113,-.2102)*f2_1+\n    mat4(.6782,-.0824,.4690,.4908,.4257,-.4245,-.1256,.8856,.4779,-.2520,-.3748,.1989,.3917,.2946,.2704,-.1324)*f2_2+\n    mat4(-.5988,.3658,-.0877,-.5959,-.1287,-.5297,.2109,-.1274,-.4820,.2704,-.1191,.1644,-.3760,.2106,-.0316,-.4539)*f2_3+\n    mat4(-.2109,-.1110,-.2144,-.0249,-.2984,.2375,.1232,-.3942,-.2331,-.1023,-.4335,-.4542,-.0517,-.3889,-.3136,.2895)*f2_4+\n    mat4(.3102,-.5298,-.1159,-.4290,.1718,-.6593,-.3391,.0445,.3194,.2787,-.4793,-.6946,-.2077,-.4295,-.0361,.1649)*f2_5+\n    vec4(1.9255,-1.1158,-1.8128,-.1840))/1.73+f2_5;\nfloat d= dot(f3_0,vec4(.0347,-.0107,-.0543,.0644))+\n    dot(f3_1,vec4(-.0170,-.0194,-.0619,.0196))+\n    dot(f3_2,vec4(.0314,-.0260,.0487,-.0289))+\n    dot(f3_3,vec4(.0033,.0437,-.0341,.0535))+\n    dot(f3_4,vec4(-.0195,-.0475,-.0601,-.0310))+\n    dot(f3_5,vec4(-.0372,.0297,-.0336,.0382))+\n    -0.122;\n    return max(d, length(p-vec3(0,0,.25))-1.);\n}\n#else\n\n/*\n//trained with tensorflow, 3x12 / 12x12 / 12x12 / 12x1  https://www.shadertoy.com/view/sd33zN\n// model is too complex to fit with only 12 units\nfloat scene(vec3 p) {\n  if (length(p) > 1.) return length(p)-.8;\n  vec4 x=vec4(p,1),\n    f00=sin(x*mat4(-2.8642,-.3379,-2.7027,-5.4688,-1.2987,1.5014,1.0576,-6.3755,.7673,4.3832,3.2235,-.1419,-.5399,3.9891,-4.0487,-2.6106)),\n    f01=sin(x*mat4(-2.772,-.0207,1.3157,1.7662,.6899,1.2744,-1.1519,-.3993,-1.2571,-.402,-.7132,6.3622,3.1684,.0554,-.6135,-3.4258)),\n    f02=sin(x*mat4(-1.4567,.096,3.5553,-9.4925,-3.1877,2.3829,-.9296,7.8893,-1.7056,-5.1025,-2.6482,8.9126,-.1828,-2.8303,-.5539,-11.0871)),\n    f10=sin(mat4(.4505,1.5956,-.5472,-.3042,.0412,-.4421,-.493,.194,-.1884,-.5303,-.0601,.3374,-.1071,-.8499,.4856,.0535)*f00+mat4(.3647,-.5556,.7278,.5633,.3605,-1.1965,-.4925,-.6503,1.0365,1.9559,-1.1097,.0894,-.7398,-2.4927,.3003,.339)*f01+mat4(.6043,1.7006,.2699,-.2991,-.0221,-.5937,-1.1459,.4695,.1447,1.0216,.26,.0676,-.2637,-.7581,.0961,.7648)*f02+vec4(9.3643,12.644,12.7916,-10.6382)),\n    f11=sin(mat4(.4995,.2089,.869,-.2955,1.4301,-.7122,-.5325,-.0552,-.0959,-.2575,.0183,.1338,-.0385,-.4212,-.2172,.0994)*f00+mat4(-.5923,.2933,.1271,.4928,.8332,.4304,-.7817,-.2401,-1.5708,-1.917,-1.228,.81,-1.0397,-1.6977,.7658,-.5163)*f01+mat4(.2709,-.0061,.5283,-.3079,-.1526,-.1579,-.6409,-.1957,.2534,-.0729,.2598,.0093,1.171,.2339,-.3809,.559)*f02+vec4(-6.8914,-2.9636,-3.2778,-2.3064)),\n    f12=sin(mat4(.0305,-.3372,-.355,.2315,-.149,1.221,-.4418,.7355,.1737,-.3972,.3842,-.3561,.0686,-.075,.2276,-.0161)*f00+mat4(.5679,-.7478,1.098,.0993,-.0613,-2.4503,-.0569,-.9271,-1.021,-1.3387,-1.2279,.4993,.1773,-1.0917,-1.802,.3367)*f01+mat4(-.1461,.0849,-.4143,.2184,.2791,-.1917,.1059,.0833,-.1315,.6855,-.1264,.0316,.5576,2.3021,.4269,.8209)*f02+vec4(-12.5297,3.8575,6.2879,9.5278)),\n    f20=sin(mat4(.133,-.6265,-.0216,.0542,.093,.145,-.027,.0309,.3214,-.3055,.0133,-.1147,1.4847,.5457,.0075,.0053)*f10+mat4(.6192,.0035,.0501,-.0739,.1744,-.5027,.0387,-.1821,-.2192,.205,.1413,-.0658,.9722,.991,-.1047,.6978)*f11+mat4(1.7267,-1.2397,.1122,.1598,.0819,-.244,-.0037,-.1173,.8199,-.6478,-.0694,-.1619,.1533,-.3345,.0655,-.3539)*f12+vec4(-7.9092,5.1766,4.5882,8.3004)),\n    f21=sin(mat4(.1021,.0101,-.0185,1.0375,.0596,.0494,-.0118,.0942,-.0556,.0801,-.0112,.5744,.2268,-.0342,.0146,-.4924)*f10+mat4(-.0556,-.129,-.0085,.4135,.1273,-.1065,-.0131,.002,-.0047,.0157,.1296,.2725,.1126,-.826,.0374,.5895)*f11+mat4(.0459,1.0457,.069,-1.1166,.1201,.014,-.0485,-.0489,.066,.2508,-.0746,-.0383,-.0403,-.6942,-.0686,-.0057)*f12+vec4(-1.6497,-10.4325,4.7085,-1.6826)),\n    f22=sin(mat4(-.1911,-.0237,-1.476,-.073,.073,.0244,.3973,-.2509,-.2895,-.0223,-.19,-.1969,1.1299,.0048,-.5468,-.6813)*f10+mat4(.1136,-.036,-.1436,.189,-.5279,.0146,-.8551,.2745,-.1213,.0329,1.1563,-.0467,.7639,.0305,.894,1.0886)*f11+mat4(-.0467,.0323,-2.0777,.0347,-.1369,.0214,-.1325,.6409,-.5975,-.0022,-.8642,-.2585,-.1572,.0014,-.5712,.2296)*f12+vec4(10.825,-7.8502,11.7483,4.7934));\n  return dot(vec4(.0496,.1725,-.5204,.3128),f20)+dot(vec4(-.2354,.2206,-.4434,-.0918),f21)+dot(vec4(-.2325,-.6963,-.0407,-.0404),f22)-1.9558;\n}*/\n//trained with tensorflow, 3x16 / 16x16 /  16x16 / 16x1  https://www.shadertoy.com/view/sd33zN\nfloat scene(vec3 p) {\n  if (length(p) > 1.) return length(p)-.8;\n  vec4 x=vec4(p,1),\n    f00=sin(x*mat4(-.3868,-.3093,-3.6954,2.4484,2.9302,4.8617,-3.207,6.3733,2.2207,1.2229,.7529,6.8923,-3.1901,-.3837,1.5075,5.9402)),\n    f01=sin(x*mat4(2.227,-4.2235,3.1825,-2.8738,2.8828,1.0962,-1.0205,-3.9004,.2729,2.2675,.3552,2.3156,2.8468,-1.5383,.3601,1.8656)),\n    f02=sin(x*mat4(-3.8048,3.5553,.9229,-3.1861,1.1408,3.0575,-1.336,.4931,2.197,2.0008,2.779,5.4465,-3.4189,1.3219,-2.3883,6.8088)),\n    f03=sin(x*mat4(1.5257,-1.055,2.9919,7.808,-1.137,2.9138,2.1236,7.3404,.7918,3.7754,3.0364,-5.4108,-1.8087,-2.2495,3.7229,-9.2978)),\n    f10=sin(mat4(-1.6913,-.0959,.2735,-.3904,-.651,-.1255,.0583,-.0941,1.6139,.2921,1.8381,-.0908,.0618,.757,.1365,.4802)*f00+mat4(.9295,.0218,-.5439,.0632,.0274,-1.3497,1.2804,.1204,-.6763,-1.4529,.3309,-.5857,-1.304,.0965,-.1969,-1.0102)*f01+mat4(-.6822,-.9195,.0293,-.0609,.0599,.7242,-.4774,-.0324,-1.7268,1.272,-.8667,-.5048,-.496,.1862,-.7332,.7009)*f02+mat4(-.3983,.5965,.6669,-.0951,1.6562,.2926,-.7816,.6021,-1.0151,.3827,-.6505,-.3546,1.3494,-.4042,-.4411,.0519)*f03+vec4(5.716,10.3182,10.2066,-8.9917)),\n    f11=sin(mat4(.284,-.7388,.1601,-.2715,.2325,-.3568,.0246,.0194,.2836,.1522,1.4394,1.2751,-.1915,.2514,-.6674,.0318)*f00+mat4(.0967,-.5026,-.2551,.3242,-.0561,-.1559,1.0709,-1.2348,-.7734,-.0243,-.9091,.3451,.5743,.2138,-1.0541,.1954)*f01+mat4(-.3602,.4102,-.8794,.2368,-.2009,-.1606,-.9775,.5528,.4353,.8922,.0377,-.0896,-1.2281,-.5368,-1.3074,.0029)*f02+mat4(-.0411,.476,-2.6588,.6194,.7807,.1155,-1.6035,-.451,-.2309,-.1062,.0774,.2069,-.5881,.4376,1.1162,-.0273)*f03+vec4(3.7295,9.7756,12.0655,-3.3911)),\n    f12=sin(mat4(.0837,-1.3587,.1994,-.2044,.032,-.3337,.1394,.2447,-.5279,1.0545,.7045,-.2983,.3696,-1.0726,-.5732,-.8808)*f00+mat4(-.073,-.6024,.0176,.3368,-.6668,2.3095,.6353,-.8166,-.4683,.9371,.7021,-.0215,-.3795,-.9897,.2481,-.5512)*f01+mat4(.0322,-.5374,.1498,.0323,-.15,-.1114,.1717,.1475,.3255,.0496,.0523,-.0843,.054,.3394,.0607,.2032)*f02+mat4(-.1398,.6035,-.4696,-.3387,-.2222,1.1782,.5465,-.4398,.1523,.1476,-.2336,.0552,-.0015,-.0994,-.4187,-.0455)*f03+vec4(10.0163,-5.5725,-7.7328,-4.833)),\n    f13=sin(mat4(.6007,-.0013,-1.1219,1.423,.1146,.1131,.2523,-.5636,-.8499,-.6252,.1626,-.0608,1.4198,.0452,-1.2241,-.0682)*f00+mat4(-.3574,.1441,.4606,-.0096,.6046,2.165,-.9807,.3567,1.4935,.786,-.7735,-1.4983,.4994,-.1076,.2014,.6609)*f01+mat4(-.4584,.5424,-1.3716,-.2497,-.8609,-.6586,1.288,-.0419,.8555,-.1137,-.2837,-.6799,.7374,.3189,.0137,.4288)*f02+mat4(-.5342,-1.1562,1.116,-.6443,-.6292,-.0923,-1.1424,.0341,.4876,-.1602,-.9543,-.0979,-.6852,.5463,-1.2446,.0356)*f03+vec4(8.5916,-9.2282,-8.0499,5.671)),\n    f20=sin(mat4(-.0383,.0365,-.0323,-.0883,.0615,.0232,-.1156,-.2517,-.0023,.0654,.1224,.1084,.0294,-.0633,-.6738,-.0164)*f10+mat4(-.0069,.1218,.2183,-.0724,.0842,-.0751,.4163,.1254,-.0483,.1346,.0443,-.0909,-.0138,-.115,.5339,.098)*f11+mat4(-.0699,-.149,-.2859,-.1033,-.0912,.0744,-.1005,.0462,-.0197,.2144,-.2707,.287,-.0595,-.0447,.1011,.2324)*f12+mat4(.0445,-.0098,.0714,.0006,.0235,-.0973,.1593,-.0058,.0822,-.0386,.0648,.1923,-.0867,.0194,.208,-.1175)*f13+vec4(-10.9812,-1.4774,5.7156,4.8039)),\n    f21=sin(mat4(.0269,.091,.1355,-.1044,.0683,-.008,1.9334,.0958,-.1325,.0407,-.0578,-.083,.2514,.1306,1.197,-.0389)*f10+mat4(-.3938,.0217,1.6895,.1827,-.4492,.1132,-.9866,.2759,-.1462,.0492,.3724,-.0193,.2356,.0516,-.2753,-.3186)*f11+mat4(-1.1359,-.0996,-1.2912,-.4479,-.0688,-.0394,-.7566,.3698,.4597,.018,.8762,-.3677,-.539,.0613,.1883,1.3663)*f12+mat4(-.3314,.0288,1.6371,.2062,.2072,-.01,-.8698,-.0249,.031,.0309,-1.5668,.1693,-.1224,.0,1.8259,.0147)*f13+vec4(6.9884,-7.8324,-6.8888,.7151)),\n    f22=sin(mat4(.0497,.0173,-.2473,.1465,-.1452,-.0051,.4827,-.0739,-.0196,-.0076,.7819,-.0322,.287,-.0049,-1.1028,-.0765)*f10+mat4(.3765,-.0324,.2596,-.0458,.1575,.0063,-.9675,-.066,.0179,-.0239,-.4353,-.006,-.0894,-.0064,-.3605,-.2824)*f11+mat4(.7928,.0088,-.5974,-.0483,-.0998,.007,-.6523,-.1151,1.0574,-.0151,2.0772,-.0529,-.055,-.0233,1.7622,-.1077)*f12+mat4(-.092,.0096,.4234,-.1044,.0454,.0071,.7878,-.1829,.0397,.0057,.1408,-.0573,-.2548,-.0136,-.0841,-.1139)*f13+vec4(.2837,-10.9884,-4.3891,7.8282)),\n    f23=sin(mat4(-.2772,.053,-.0167,-.0061,-.0517,.0541,.0491,-.0474,.602,.0258,.1042,-.0461,-.5157,.0125,-.1683,-.0265)*f10+mat4(1.1976,-.1604,.0561,.0152,.8858,-.3835,-.0771,-.0165,.572,.0173,.0348,-.0433,-.4598,.2862,-.1717,.0711)*f11+mat4(2.2106,.2621,-1.0351,.051,.3927,-.3109,-.0869,-.017,-.592,.2738,.6449,.0666,.21,-1.2345,.0981,.1052)*f12+mat4(.7805,-.1584,-.0148,-.0712,-.2046,.1745,-.0914,.0503,-.3447,-.0956,-.0533,.0906,.0917,.1735,.036,.0148)*f13+vec4(2.2706,-.5216,5.4374,1.5639));\n  return dot(vec4(-.4188,-.2921,.133,.2109),f20)+dot(vec4(.1279,.4421,.0036,-.1403),f21)+dot(vec4(-.1165,.33,-.0084,.1608),f22)+dot(vec4(-.0173,-.2252,.2478,.3179),f23)+.4407;\n}\n\n\n#endif\n#endif\n#endif\n\nvec3 norm(vec3 p) {\n    mat3 k = mat3(p,p,p)-mat3(0.001);\n    return normalize(scene(p) - vec3(scene(k[0]),scene(k[1]),scene(k[2])));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-0.5*iResolution.xy)/iResolution.y;\n    vec2 mouse = (iMouse.xy-0.5*iResolution.xy)/iResolution.y;\n\n    vec3 cam = normalize(vec3(1.5,uv));\n    vec3 init = vec3(-3.,0,0);\n    \n    float yrot = sin(iTime*3.)/2.;\n    float zrot = 3.14;\n    if (iMouse.z > 0.) {\n        yrot += -4.*mouse.y;\n        zrot = 4.*mouse.x;\n    }\n    cam = erot(cam, vec3(0,1,0), yrot);\n    init = erot(init, vec3(0,1,0), yrot);\n    cam = erot(cam, vec3(0,0,1), zrot);\n    init = erot(init, vec3(0,0,1), zrot);\n    \n    vec3 p = init;\n    bool hit = false;\n    for (int i = 0; i < 150 && !hit; i++) {\n        float dist = scene(p);\n        hit = dist*dist < 1e-6;\n        p+=dist*cam;\n        if (distance(p,init)>5.) break;\n    }\n    vec3 n = norm(p);\n    vec3 r = reflect(cam,n);\n\n    float spec = length(sin(r*.6 +.5))/sqrt(3.);\n    spec *= smoothstep(-.3,.2,scene(p+r*.2));\n    vec3 col = vec3(0.863,0.396,0.396)*spec + pow(spec,8.);\n    float bgdot = length(sin(cam*8.)*.4+.6)/2.;\n    vec3 bg = vec3(.1,.1,.11) * bgdot + pow(bgdot, 10.);\n    fragColor.xyz = hit ? col : bg;\n    fragColor = smoothstep(-.02,1.05,sqrt(fragColor)) * (1.- dot(uv,uv)*.5);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WtVyDd.jpg", "access": "shaders20k", "license": "cc0-1.0", "functions": [[715, 880, 918, 918, 980], [74984, 74984, 75003, 75003, 75119], [75121, 75121, 75178, 75178, 76334]]}
{"id": "wtVyDh", "name": "for loop fun", "author": "capslpop", "description": "There are so many cool things to do with for loops. ", "tags": ["forloop"], "likes": 0, "viewed": 76, "published": "Public", "date": "1610949074", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from -1 to 1)\n     vec2 uv = (fragCoord/iResolution.xy)*2.0 - 1.0;\n     \n    // Time varying pixel color\n    vec3 col = vec3(sin(iTime));//0.0 + 0.1*sin(vec3(fragCoord.xy, iTime));\n    \n    vec3 hit2 = vec3(0, 0, 0);\n    vec3 cam = vec3(0, 0, 0);\n    for(float i = 0.0; i <= 99.0; i++)\n    {\n        cam = normalize(vec3(fragCoord, 1.0)); \n        hit2 += cos(col) * cam;\n        col += hit2 + vec3(uv, col.x) * sin(col) * 99.0;\n    }\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtVyDh.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 108, 591]]}
{"id": "wtVyDR", "name": "lake mountain", "author": "regis", "description": "Mountain", "tags": ["raymarch", "water", "heightmap", "mountain"], "likes": 1, "viewed": 57, "published": "Public", "date": "1610901060", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec4 tpos = vec4(0.0, 0.0, 0.0, 0.0);\nfloat angle_tpos;\nbool done = false;\nfloat dist = 0.0;\n\nmat2 Rot(float a){float s = sin(a);float c = cos(a);return mat2(c, -s, s, c);}\nmat3 RotX(float a){float s = sin(a);float c = cos(a);return mat3(1., .0, .0, .0, c, -s, .0, s, c);}\nmat3 RotY(float a){float s = sin(a);float c = cos(a);return mat3(c, .0, s, .0, 1., .0, -s, .0, c);}\nmat3 RotZ(float a){float s = sin(a);float c = cos(a);return mat3(c, -s, .0, s, c, .0, .0, .0, 1.);}\n\n\n\nfloat opExtrusion(in vec3 p, in float d, in float h) {\n    // d is the distance to the 2D shape using the x and y components of p\n    vec2 w = vec2(d, abs(p.z) - h);\n    return min(max(w.x, w.y), 0.0) + length(max(w, 0.0));\n}\n\n/*\nvec4 opElongate( in vec3 p, in vec3 h )\n{\n    //return vec4( p-clamp(p,-h,h), 0.0 ); // faster, but produces zero in the interior elongated box\n    \n    vec3 q = abs(p)-h;\n    return vec4( max(q,0.0), min(max(q.x,max(q.y,q.z)),0.0) );\n}\n*/\n\nvec3 opTwist(in vec3 p, in float t) {\n    float c = cos(t * p.y);\n    float s = sin(t * p.y);\n    mat2 m = mat2(c, -s, s, c);\n    return vec3(m * p.xz, p.y);\n}\n\n// from iq\nfloat Noise( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n  \tf = f*f*(3.0-2.0*f);\n  \tvec2 uv = (p.xy+vec2(37.0,17.0)*p.z) + f.xy;\n  \tvec2 rg = textureLod( iChannel0, (uv+0.5)/256.0, 0.0).yx;\n  \treturn mix( rg.x, rg.y, f.z );\n}\n\n// ref https://www.shadertoy.com/view/Xs33Df\nfloat Noise3D(in vec3 p){\n    const vec3 s = vec3(7, 157, 113);\n\tvec3 ip = floor(p); // Unique unit cell ID.\n    vec4 h = vec4(0., s.yz, s.y + s.z) + dot(ip, s);\n\tp -= ip; // Cell's fractional component.\n    p = p*p*(3. - 2.*p);\n    h = mix(fract(sin(h)*43758.5453), fract(sin(h + s.x)*43758.5453), p.x);\n    h.xy = mix(h.xz, h.yw, p.y);\n    return mix(h.x, h.y, p.z); // Range: [0, 1].\n\t\n}\n\nvec2 hash( vec2 p )\n{\n\tp = vec2( dot(p,vec2(127.1,311.7)),\n\t\t\t dot(p,vec2(269.5,183.3)) );\n\treturn -1.0 + 2.0*fract(sin(p)*43758.5453123);\n}\n\nfloat noise( in vec2 p )\n{\n\tconst float K1 = 0.366025404; // (sqrt(3)-1)/2;\n\tconst float K2 = 0.211324865; // (3-sqrt(3))/6;\n\t\n\tvec2 i = floor( p + (p.x+p.y)*K1 );\n\t\n\tvec2 a = p - i + (i.x+i.y)*K2;\n\tvec2 o = (a.x>a.y) ? vec2(1.0,0.0) : vec2(0.0,1.0);\n\tvec2 b = a - o + K2;\n\tvec2 c = a - 1.0 + 2.0*K2;\n\t\n\tvec3 h = max( 0.5-vec3(dot(a,a), dot(b,b), dot(c,c) ), 0.0 );\n\t\n\tvec3 n = h*h*h*h*vec3( dot(a,hash(i+0.0)), dot(b,hash(i+o)), dot(c,hash(i+1.0)));\n\t\n\treturn dot( n, vec3(70.0) );\n}\n\nfloat fbm(vec2 uv)\n{\n\tfloat f;\n\tmat2 m = mat2( 1.6,  1.2, -1.2,  1.6 );\n\tf  = 0.5000*noise( uv ); uv = m*uv;\n\tf += 0.2500*noise( uv ); uv = m*uv;\n\tf += 0.1250*noise( uv ); uv = m*uv;\n\tf += 0.0625*noise( uv ); uv = m*uv;\n\tf = 0.5 + 0.5*f;\n\treturn f;\n}\n\nfloat FBM( in vec3 p )\n{\n    float n = 0.0;\n    n += 0.50000*Noise( p*1.0 );\n    n += 0.25000*Noise( p*2.0 );\n    n += 0.12500*Noise( p*4.0 );\n    n += 0.06250*Noise( p*8.0 );\n    n += 0.03125*Noise( p*16.0 );\n    return n/0.984375;\n}\n\nfloat WaterMap( vec3 pos ) {\n    return FBM( vec3( pos.xz, iTime*0.3 )) * 1.;\n}\nvec3 WaterNormal(vec3 pos,float rz){\n    float EPSILON =rz*rz* 0.002;\n    vec3 dx = vec3( EPSILON, 0.,0. );\n    vec3 dz = vec3( 0.,0., EPSILON );\n      \n    vec3  normal = vec3( 0., 1., 0. );\n    float bumpfactor = 0.3 * pow(1.-clamp((rz)/1000.,0.,1.),6.);//\n    \n    normal.x = -bumpfactor * (WaterMap(pos + dx) - WaterMap(pos-dx) ) / (2. * EPSILON);\n    normal.z = -bumpfactor * (WaterMap(pos + dz) - WaterMap(pos-dz) ) / (2. * EPSILON);\n    return normalize( normal ); \n}\n\nfloat sdCylinder(vec3 p, vec3 a, vec3 b, float r) {\n\tvec3 ab = b-a;\n    vec3 ap = p-a;\n    \n    float t = dot(ab, ap) / dot(ab, ab);\n    //t = clamp(t, 0., 1.);\n    \n    vec3 c = a + t*ab;\n    \n    float x = length(p-c)-r;\n    float y = (abs(t-.5)-.5)*length(ab);\n    float e = length(max(vec2(x, y), 0.));\n    float i = min(max(x, y), 0.)-0.1;\n    \n    return e+i;\n}\n\nfloat sdRoundBox( vec3 p, vec3 b, float r )\n{\n  vec3 q = abs(p) - b;\n  return -(length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0) - r);\n}\n\nfloat Box(vec3 p, vec3 sc, float r){\n    return length(max(abs(p)-sc, 0.))-r;\n}\n\nfloat Box2(vec3 p, vec3 sc, float r, float an){\n    an = 80.0;\n    vec3 cs = vec3(cos(an*3.1415/180.0), sin(an*3.1415/180.0),cos(an*3.1415/180.0));\n    float c2 = length(cs);\n    \n    float a = length(max( abs(p)-(sc)  , 0.0)) - r;\n    float b = length(max(abs(p)-vec3(1.0, 2.0, 1.0), 0.));\n    return a;\n}\n\nfloat Capsule(vec3 p, vec3 sc, float r){\n    vec3 cs = vec3(cos(90.0*3.1415/180.0), sin(90.0*3.1415/180.0),cos(90.0*3.1415/180.0));  \n    float a = length(max( abs(p)- (sc*cs)  , 0.0)) - r;\n    return a;\n}\n\nfloat opRep( in vec3 p, in vec3 c, vec3 sc, float r )\n{\n    vec3 q = mod(p+0.5*c,c)-0.5*c;\n    return Box( q, sc, r );\n}\n\nfloat opRepS( in vec3 p, in vec3 c, vec4 pos )\n{\n    vec3 q = mod(p+0.5*c,c)-0.5*c;\n    return length(q) - pos.w;\n}\n\nfloat dot2( in vec3 v ) { return dot(v,v); }\nfloat udQuad( vec3 p, vec3 a, vec3 b, vec3 c, vec3 d )\n{\n  vec3 ba = b - a; vec3 pa = p - a;\n  vec3 cb = c - b; vec3 pb = p - b;\n  vec3 dc = d - c; vec3 pc = p - c;\n  vec3 ad = a - d; vec3 pd = p - d;\n  vec3 nor = cross( ba, ad );\n\n  return sqrt(\n    (sign(dot(cross(ba,nor),pa)) +\n     sign(dot(cross(cb,nor),pb)) +\n     sign(dot(cross(dc,nor),pc)) +\n     sign(dot(cross(ad,nor),pd))<3.0)\n     ?\n     min( min( min(\n     dot2(ba*clamp(dot(ba,pa)/dot2(ba),0.0,1.0)-pa),\n     dot2(cb*clamp(dot(cb,pb)/dot2(cb),0.0,1.0)-pb) ),\n     dot2(dc*clamp(dot(dc,pc)/dot2(dc),0.0,1.0)-pc) ),\n     dot2(ad*clamp(dot(ad,pd)/dot2(ad),0.0,1.0)-pd) )\n     :\n     dot(nor,pa)*dot(nor,pa)/dot2(nor) );\n}\n\nvec3 add_tpos(vec3 tp){\n    return vec3(tp.x+tpos.x, tp.y+tpos.y, tp.z+tpos.z);\n    \n}\n\nvec3 rot_y(vec3 tp, float a){\n    tp.xz *= Rot(a);\n    return tp;\n\n}\n\nfloat noi(vec3 p){ \n  vec3 f=floor(p),s=vec3(7,157,113);\n  p-=f; vec4 h=vec4(0,s.yz,s.y+s.z)+dot(f,s);;\n  p=p*p*(3.-2.*p);\n  h=mix(fract(sin(h)*43758.5),fract(sin(h+s.x)*43758.5),p.x);\n  h.xy=mix(h.xz,h.yw,p.y);\n  return mix(h.x,h.y,p.z);  \n}\nvec2 add = vec2(1.0, 0.0);\n#define HASHSCALE1 .1031\n#define HASHSCALE3 vec3(.1031, .1030, .0973)\n#define HASHSCALE4 vec4(1031, .1030, .0973, .1099)\n\nfloat Hash12(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * HASHSCALE1);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\nvec2 Hash22(vec2 p)\n{\n\tvec3 p3 = fract(vec3(p.xyx) * HASHSCALE3);\n    p3 += dot(p3, p3.yzx+19.19);\n    return fract((p3.xx+p3.yz)*p3.zy);\n\n}\n\nfloat Noise( in vec2 x )\n{\n    vec2 p = floor(x);\n    vec2 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n    \n    float res = mix(mix( Hash12(p),          Hash12(p + add.xy),f.x),\n                    mix( Hash12(p + add.yx), Hash12(p + add.xx),f.x),f.y);\n    return res;\n}\n\nvec2 Noise2( in vec2 x )\n{\n    vec2 p = floor(x);\n    vec2 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n    float n = p.x + p.y * 57.0;\n   vec2 res = mix(mix( Hash22(p),          Hash22(p + add.xy),f.x),\n                  mix( Hash22(p + add.yx), Hash22(p + add.xx),f.x),f.y);\n    return res;\n}\nconst mat2 rotate2D = mat2(1.3623, 1.7531, -1.7131, 1.4623);\nfloat Terrain( in vec2 p)\n{\n\tvec2 pos = p*0.05;\n\tfloat w = (Noise(pos*.25)*0.75+.15);\n\tw = 66.0 * w * w;\n\tvec2 dxy = vec2(0.0, 0.0);\n\tfloat f = .0;\n\tfor (int i = 0; i < 5; i++)\n\t{\n\t\tf += w * Noise(pos);\n\t\tw = -w * 0.4;\t//...Flip negative and positive for variation\n\t\tpos = rotate2D * pos;\n\t}\n\tfloat ff = Noise(pos*.002);\n\t\n\tf += pow(abs(ff), 5.0)*275.-5.0;\n\treturn f;\n}\n\nfloat TerrainRM(in vec2 p){\n\n    vec2 q = p * 0.05;\n    float w = Noise(q);\n    w = 15.0*w;\n    float f = 0.0;\n    for(int i = 0;i < 5;i++){\n        f += w * Noise(q*0.85);\n        w = -w * 0.4;\n        q = rotate2D * q;\n    \n    }\n    \n    float ff = Noise(q * 0.002);\n    f += ff*300.-5.0;\n   \n    return f;\n\n\n}\n\nfloat TerrainRM2(in vec2 p){\n\n    vec2 q = p * 0.05;\n    float w = Noise(q);\n    w = 15.0*w;\n    float f = 0.0;\n    for(int i = 0;i < 5;i++){\n        f += w * Noise(q*0.85);\n        w = -w * 0.4;\n        q = rotate2D * q;\n    \n    }\n    \n    float ff = Noise(q * 0.002);\n   f += ff*300.-5.0;\n   \n    \n    \n    for (int i = 0; i < 6; i++)\n\t{\n\t\tf += w * Noise(q*0.85);\n\t\tw =  - w * 0.4;\n\t\tq = rotate2D * q;\n\t}\n\n    return f;\n\n}\n// High def version only used for grabbing normal information.\nfloat Terrain2( in vec2 p)\n{\n\t// There's some real magic numbers in here! \n\t// The Noise calls add large mountain ranges for more variation over distances...\n\tvec2 pos = p*0.05;\n\tfloat w = (Noise(pos*.25)*0.75+.15);\n\tw = 66.0 * w * w;\n\tvec2 dxy = vec2(0.0, 0.0);\n\tfloat f = .0;\n\tfor (int i = 0; i < 5; i++)\n\t{\n\t\tf += w * Noise(pos);\n\t\tw =  - w * 0.4;\t//...Flip negative and positive for varition\t   \n\t\tpos = rotate2D * pos;\n\t}\n\tfloat ff = Noise(pos*.002);\n\tf += pow(abs(ff), 5.0)*275.-5.0;\n\t\n/*\n\ttreeCol = Trees(p);\n\tf += treeCol;\n\tif (treeCol > 0.0) return f;\n\n\t*/\n\t// That's the last of the low resolution, now go down further for the Normal data...\n\tfor (int i = 0; i < 6; i++)\n\t{\n\t\tf += w * Noise(pos);\n\t\tw =  - w * 0.4;\n\t\tpos = rotate2D * pos;\n\t}\n\t\n\t\n\treturn f;\n}\n\n\nvec2 GetDist2(vec3 p, vec2 uv){\n\n\n    vec4 s = vec4(-3.0,3.0, 9.0,1.0);\n    vec4 s2 = vec4(3.0 ,3.0, 7.0, 1.0);\n    \n    \n    \n    \n    vec2 d=vec2(0.0);;\n    float pd = p.y;//dot(p, vec3(0.0, 1.0, 0.0));\n    \n    //pd -= TerrainRM2(p.xz);\n    \n   \n        pd = p.y - Noise3D(p*0.7)*0.5;// - smoothstep(0.0, 1.0, sin(p.x+iTime*2.0)*0.2-cos(p.z+iTime*2.0)*0.1+sin(p.y*3.0+iTime)*0.1);\n   \n    \n     \n  /*  pd = pd - noi(p*0.9)*1.2 ;\n    pd -= noi(p*3.0)*0.01;\n   pd -= noi(p*10.0)*0.1;*/\n   \n    float qu = udQuad(p, vec3(-1000.0, 5.0, 800.0), vec3( 1000.0, 5.0, 800.0), vec3(1000.0, 5.0, 900.0), vec3(-1000.0, 5.0, 900.0));\n    qu -= TerrainRM2(p.xz);\n    float qu2 = udQuad(p, vec3(-800.0, 5.0, -800.0), vec3( -800.0, 5.0, 800.0), vec3(-1000.0, 5.0, 800.0), vec3(-1000.0, 5.0, -800.0));\n    qu2 -= TerrainRM2(p.xz);\n    float qu3 = udQuad(p, vec3(-1000.0, 5.0, -800.0), vec3( 1000.0, 5.0, -800.0), vec3(1000.0, 5.0, -900.0), vec3(-1000.0, 5.0, -900.0));\n   qu3 -= TerrainRM(p.xz);\n   float qu4 = udQuad(p, vec3(800.0, 5.0, -800.0), vec3( 800.0, 5.0, 800.0), vec3(1000.0, 5.0, 800.0), vec3(1000.0, 5.0, -800.0));\n    qu4 -= TerrainRM2(p.xz);\n   \n    vec3 sp = (p)-s.xyz;\n    float sd = length((sp))-s.w;\n     \n       \n    \n    vec3 sp2 = (p)-s2.xyz;\n    //sp2.y += sin(iTime)*0.1;\n    float sd2 = length((sp2))-s2.w;\n   \n    \n   \n        /*d.x = sd;\n        d.y = -1.0;\n       \n       if(sd2 < d.x)\n       {\n           d.x = sd2;\n          d.y = -1.0;\n       }*/\n       \n      // if(pd < d.x){\n          d.x = pd;\n          d.y = 2.0;\n      // }\n       \n       if(qu < d.x){\n          d.x = qu;\n          d.y = 3.0;\n       }\n       if(qu2 < d.x){\n          d.x = qu2;\n          d.y = 3.0;\n       }\n       if(qu3 < d.x){\n          d.x = qu3;\n          d.y = 3.0;\n       }\n       if(qu4 < d.x){\n          d.x = qu4;\n          d.y = 3.0;\n       }\n      \n   // \n    return d;\n    \n    \n}\n\nvec2 GetDist(vec3 p, vec2 uv){\n\n\n    vec4 s = vec4(-3.0,3.0, 9.0,1.0);\n    vec4 s2 = vec4(3.0 ,3.0, 7.0, 1.0);\n    \n    \n    \n    \n    vec2 d=vec2(0.0);;\n    float pd = p.y;//dot(p, vec3(0.0, 1.0, 0.0));\n    \n    \n   // pd -= TerrainRM(p.xz);\n    \n   \n        pd = p.y - Noise3D(p*0.7)*0.5 ;//- smoothstep(0.0, 1.0, sin(p.x+iTime*2.0)*0.2-cos(p.z+iTime*2.0)*0.1+sin(p.y*3.0+iTime)*0.1);\n   \n    \n     \n  /*  pd = pd - noi(p*0.9)*1.2 ;\n    pd -= noi(p*3.0)*0.01;\n   pd -= noi(p*10.0)*0.1;*/\n   \n   \n   \n   float qu = udQuad(p, vec3(-1000.0, 5.0, 800.0), vec3( 1000.0, 5.0, 800.0), vec3(1000.0, 5.0, 900.0), vec3(-1000.0, 5.0, 900.0));\n   qu -= TerrainRM(p.xz);\n   float qu2 = udQuad(p, vec3(-800.0, 5.0, -800.0), vec3( -800.0, 5.0, 800.0), vec3(-1000.0, 5.0, 800.0), vec3(-1000.0, 5.0, -800.0));\n     qu2 -= TerrainRM2(p.xz);\n    float qu3 = udQuad(p, vec3(-1000.0, 5.0, -800.0), vec3( 1000.0, 5.0, -800.0), vec3(1000.0, 5.0, -900.0), vec3(-1000.0, 5.0, -900.0));\n   qu3 -= TerrainRM(p.xz);\n    float qu4 = udQuad(p, vec3(800.0, 5.0, -800.0), vec3( 800.0, 5.0, 800.0), vec3(1000.0, 5.0, 800.0), vec3(1000.0, 5.0, -800.0));\n    qu4 -= TerrainRM2(p.xz);\n    \n    vec3 sp = (p)-s.xyz;\n    float sd = length((sp))-s.w;\n     \n       \n    \n    vec3 sp2 = (p)-s2.xyz;\n    //sp2.y += sin(iTime)*0.1;\n    float sd2 = length((sp2))-s2.w;\n   \n    \n   \n      \n      \n        /*  d.x = sd;\n          d.y = -1.0;\n       \n       if(sd2 < d.x)\n       {\n           d.x = sd2;\n          d.y = -1.0;\n       }*/\n       \n       //if(pd < d.x){\n          d.x = pd;\n          d.y = 2.0;\n      // }\n       \n       if(qu < d.x){\n          d.x = qu;\n          d.y = 3.0;\n       }\n       if(qu2 < d.x){\n          d.x = qu2;\n          d.y = 3.0;\n       }\n       if(qu3 < d.x){\n          d.x = qu3;\n          d.y = 3.0;\n       }\n       if(qu4 < d.x){\n          d.x = qu4;\n          d.y = 3.0;\n       }\n      \n   // \n    return d;\n    \n    \n}\n\nvec3 RayMarch2(vec3 eye, vec3 viewRayDirection, vec2 uv){\n    vec3 t = vec3(0.);\n    float max = -100000.0;\n    vec2 dd;\n    float depth = 0.0, end = 10.0, delta=0.0, v;\n    for (int i = 0; i < 150; i++) {\n        t.yz = GetDist(eye + t.x * viewRayDirection, uv).xy;\n       \n        \n        \n            \n        if (t.y < 0.01) {\n           \n           break;\n        }\n        //t.x += t.y;\n        \n        \n\n        if (t.x >= 1500.0) {\n            break;\n        }\n       \n        if(0.01>= 0.3*t.y)v= 0.01;\n        else v = 0.3*t.y;\n       delta = v + (t.x*0.0065);\n\t\t t.x += delta;\n    }\n    if (t.x >= 1500.0)t.x = -1.0;\n        \n       \n    \n    return t;\n\n\n}\n \nvec3 RayMarch3(vec3 eye, vec3 viewRayDirection, vec2 uv){\n    vec3 t = vec3(0.);\n    float max = -100000.0;\n    vec2 dd;\n    float depth = 0.0, end = 10.0, delta=0.0, v;\n    for (int i = 0; i < 150; i++) {\n        t.yz = GetDist2(eye + t.x * viewRayDirection, uv).xy;\n       \n        \n        \n            \n        if (t.y < 0.01) {\n           \n           break;\n        }\n       // t.x += t.y;\n        \n        \n\n        if (t.x >= 1500.0) {\n            break;\n        }\n       \n        if(0.01>= 0.3*t.y)v= 0.01;\n        else v = 0.3*t.y;\n       delta = v + (t.x*0.0065);\n\t\t t.x += delta;\n    }\n    if (t.x >= 1500.0)t.x = -1.0;\n        \n       \n    \n    return t;\n\n\n}\n\n\nvec3 Mat2(vec3 p, vec3 n1, vec3 diff2, vec3 lightpos){\n    vec3 col = mix(vec3(1.0)*diff2, vec3(Noise(p.xz)*0.1), 0.5);\n    \n   \n   \n    if( (p.y < 10.35) && (n1.y > 0.9)){\n        col = vec3(0.0,1.0, 0.0)*diff2;\n       \n    }\n   \n     else if ((p.y > 20.0)&& (n1.y > 0.1))\n    {\n        col = mix(vec3(Noise(p.xz)*0.1)*vec3(1.0), vec3(1.0)*diff2+0.3, 0.9);\n        //col += 0.3;\n       // col =  vec3(1.0)*diff2;\n       \n    }\n    else\n    {\n       col += vec3(150. ,75., 21.)/255.*diff2;\n    \n    }\n    \n    \n    \n    \n\n   \n    \n    \n       \n    \n    return clamp(col, 0., 1.);\n            \n}\n\nfloat calcSoftshadow( in vec3 ro, in vec3 rd, in float mint, in float tmax )\n{\n\tfloat res = 1.;\n    float t = mint;\n    for( int i=0; i<16; i++ )\n    {\n\t\tfloat h = GetDist2( ro + rd*t , vec2(1.0)).y;\n        res = min( res, 10.0*h/t );\n        t += clamp( h, 0.01, 0.10 );\n        if( h<0.0001 || t>tmax ) break;\n    }\n    return clamp( res, 0.0, 1.0 );\n}\n\nfloat calcAO( in vec3 pos, in vec3 nor )\n{\n\tfloat occ = 0.0;\n    float sca = 1.0;\n    for( int i=0; i<5; i++ )\n    {\n        float hr = 0.01 + 0.12*float(i)/4.0;\n        vec3 aopos =  nor * hr + pos;\n        float dd = GetDist2( aopos , vec2(1.0)).y;\n        occ += -(dd-hr)*sca;\n        sca *= 0.95;\n    }\n    return clamp( 1.0 - 3.0*occ, 0.0, 1.0 );    \n}\n\n\nvec3 GetLightM(vec3 p, vec2 uv, vec3 lg, out vec3 n, vec3 ro, vec3 rd){\n    vec3 lightpos = lg;\n    //lightpos.xz += vec2(sin(iTime), cos(iTime));\n    //p = p*2.0;\n    vec3 l = normalize(lightpos-p);\n    \n    vec2 d = GetDist2(p, uv);\n    \n    \n    \n        vec2 e = vec2(0.01, 0);\n\n        n = d.x - vec3(\n            GetDist2(p-e.xyy, uv).x,\n            GetDist2(p-e.yxy, uv).x,\n            GetDist2(p-e.yyx, uv).x);\n\n\n        n = normalize(n);\n    \n    \n    float occ = calcAO(p, n);\n    \n    \n            \n    float dif = clamp(dot(n, l), .0, 1.);\n    //dif *= calcSoftshadow(p, lightpos, 0.01, 10000. );\n    dif += occ*0.15;\n    \n    //\n \n    vec3 dd = RayMarch2(p+n*.01, l, uv);\n    p = ro + reflect(n, l) * dd.x;\n    \n    \n    \n         \n    if(dd.x < length(lightpos-p) && dd.x > 0.0){\n        if(dd.z == -1.0){\n            vec3 colXZ = texture(iChannel0, p.xz*0.1).rgb;\n             vec3 colYZ = texture(iChannel0, p.yz*0.1).rgb;\n             vec3 colXY = texture(iChannel0, p.xy*0.1).rgb;\n\n             n = abs(n);\n\n             n *= pow(n, vec3(20));\n             n /= n.x+n.y+n.z;\n\n             vec3 col = colYZ * n.x + colXZ * n.y + colXY*n.z;\n\n             uv = vec2(atan(p.x, p.z)/6.2832+.5, p.y/3.+0.5);\n             vec4 st = texture(iChannel0, uv);\n\n             col = vec3(dif) * mix(col, st.rgb, st.a);\n             return col;\n\n        }\n        else if(dd.z == 2.0)\n        {\n            vec3 col;\n            \n                        \n            col = Mat2(p, n, vec3(dif), lightpos);\n            //col = vec3(dif);\n            \n            return col;\n            \n            \n            \n        }\n        else if(dd.z == 3.0)\n        {\n            return vec3(dif);\n        }\n        else if(dd.z == 4.0){\n             return vec3(dif);\n         }\n        else\n            return vec3(dif);\n            \n     }\n     else\n         return vec3(dif);\n\n}\nvec3 lightDir = normalize( vec3(0.5,0.6,0.) );\nconst mat2 m2 = mat2( 0.60, -0.80, 0.80, 0.60 );\n//ref: https://www.shadertoy.com/view/Msdfz8\nvec3 Cloud(vec3 bgCol,vec3 ro,vec3 rd,vec3 cloudCol,float spd)\n{\n    vec3 col = bgCol;\n    float t = iTime * 0.15* spd;\n    vec2 sc = ro.xz + rd.xz*((3.)*40000.0-ro.y)/rd.y;\n    vec2 p = 0.00002*sc;\n    float f = 0.0;\n  \tfloat s = 0.5;\n  \tfloat sum =0.;\n  \tfor(int i=0;i<5;i++){\n    \tp += t;t *=1.5;\n    \tf += s*textureLod( iChannel0, p/256.0, 0.0).x; p = m2*p*2.02;\n    \tsum+= s;s*=0.6;\n  \t}\n    float val = f/sum; \n    col = mix( col, cloudCol, smoothstep(0.5,0.8,val) );\n    return col;\n}\nvec3 RayMarchCloud(vec3 ro,vec3 rd){\n    vec3 col = vec3(0.0,0.0,0.0);  \n    float sundot = clamp(dot(rd,lightDir),0.0,1.0);\n    \n     // sky      \n    col = vec3(0.2,0.5,0.85)*1.1 - rd.y*rd.y*0.5;\n    col = mix( col, 0.85*vec3(0.7,0.75,0.85), pow( 1.0-max(rd.y,0.0), 4.0 ) );\n    // sun\n    col += 0.25*vec3(1.0,0.7,0.4)*pow( sundot,5.0 );\n    col += 0.25*vec3(1.0,0.8,0.6)*pow( sundot,64.0 );\n    col += 0.4*vec3(1.0,0.8,0.6)*pow( sundot,512.0 );\n    // clouds\n    col = Cloud(col,ro,rd,vec3(1.0,0.95,1.0),1.);\n            // .\n    col = mix( col, 1.5*vec3(0.0,0.5,1.0), pow( 1.0-max(rd.y,0.0), 16.0 ) );\n    return col;\n}\n\n#define TAU 6.28318530718\n#define MAX_ITER 5\nvec3 XaterColor(vec3 pp){\nvec2 p = mod(pp.xz*TAU, TAU)-250.0;\n\n\tvec2 i = vec2(p);\n\tfloat c = 1.0;\n\tfloat inten = .005;\n\n\tfor (int n = 0; n < MAX_ITER; n++) \n\t{\n\t\tfloat t = iTime * (1.0 - (3.5 / float(n+1)));\n\t\ti = p + vec2(cos(t - i.x) + sin(t + i.y), sin(t - i.y) + cos(t + i.x));\n\t\tc += 1.0/length(vec2(p.x / (sin(i.x+t)/inten),p.y / (cos(i.y+t)/inten)));\n\t}\n\tc /= float(MAX_ITER);\n\tc = 1.17-pow(c, 1.4);\n\tvec3 colour = vec3(pow(abs(c), 8.0));\n    colour = clamp(colour + vec3(0.0, 0.35, 0.5), 0.0, 1.0);\n    \n\t\treturn colour;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    uv -= 0.5;\n    uv /= vec2(iResolution.y / iResolution.x, 1);\n    // Time varying pixel color\n    vec3 col = vec3(0.0);\n    vec3 lightpos = vec3(0.0, 100., -50.);\n    vec3 p;\n    //iMouse.xy / iResolution.xy\n    vec3 lookat = vec3((iMouse.x/iResolution.x)*30.0, (iMouse.y/iResolution.y)*60.0, 30.0);//vec3(0.0, 1.5, 0.0);\n    vec3 ro = vec3(0, 10.0, -10.);\n    float speed = 2.0;\n    \n    //lightpos.z+= iTime*speed;\n    vec3 dirc = vec3(0.0, 1.0, 10.0);\n    float an = (iMouse.x/iResolution.x)*10.0;\n    ro -= dirc;\n    lookat -= dirc;\n    ro *= RotY(an);\n    lookat *= RotY(an);\n    ro += dirc;\n    lookat += dirc;\n    \n    //vec3 lightpos = vec3(0.0, 30., -30.);\n   \n    lightpos -= dirc;\n    lightpos *= RotY(an);\n    lightpos += dirc;\n    \n        \n    \n    float zoom = 1.0;    \n    vec3 f = normalize(lookat-ro),\n        r = normalize(cross(vec3(0,1,0), f)),\n        u = cross(f, r),\n        c = ro + f * zoom,\n        i = c + uv.x * r + uv.y * u,\n        rd = normalize(i-ro);\n        \n    \n        \n     vec3 t;\n     float dO, dif, dif2, dif3, difT;\n     //vec3 p;\n     \n  \n     \n     t = RayMarch2(ro, rd, uv);\n     p = ro + rd * t.x;\n     \n    float alpha = 1.0;\n    vec3 n1, n2, n3, np;\n  \n   vec3 diff2 = GetLightM(p, uv, lightpos, n1, ro, rd);\n    \n    \n   \n    \n     if(t.x > 0.0){\n         \n             \n         \n         if(t.z == 0.0){\n            \n         }\n         else if(t.z == 1.0){\n             col = diff2* vec3(1.0, 0.0, 0.0);\n         }\n         else if(t.z == 2.0){\n         \n             col = mix(XaterColor(p*0.1)*diff2*exp(-0.001*t.x), vec3(0.0, 1.0, 1.0), 0.5);   \n             \n            \n             \n             \n         }\n         else if(t.z == 3.0){\n            \n             col = Mat2(p, n1, diff2, lightpos);\n             //col = diff2 * vec3(1.0, 0.0, 0.0);\n         \n         \n         }\n         \n         \n       \n         \n         \n         \n     }\n     else\n     {\n         col = RayMarchCloud( ro, rd);\n         \n         \n     }\n     \n    \n    // Output to screen\n    fragColor = vec4((col),alpha);\n}\n\n\n\n", "image_inputs": [{"id": "XdXGzn", "previewfilepath": "/media/ap/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtVyDR.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[94, 94, 112, 112, 172], [173, 173, 192, 192, 272], [273, 273, 292, 292, 372], [373, 373, 392, 392, 472], [476, 476, 530, 605, 701], [703, 947, 984, 984, 1106], [1108, 1119, 1145, 1145, 1360], [1362, 1407, 1432, 1432, 1797], [1799, 1799, 1820, 1820, 1939], [1941, 1941, 1967, 1967, 2425], [2427, 2427, 2447, 2447, 2677], [2679, 2679, 2703, 2703, 2913], [2915, 2915, 2943, 2943, 2994], [2995, 2995, 3031, 3031, 3469], [3471, 3471, 3522, 3522, 3838], [3840, 3840, 3885, 3885, 3979], [3981, 3981, 4017, 4017, 4060], [4062, 4062, 4109, 4109, 4368], [4370, 4370, 4410, 4410, 4575], [4577, 4577, 4632, 4632, 4697], [4699, 4699, 4747, 4747, 4814], [4816, 4816, 4841, 4841, 4860], [4861, 4861, 4917, 4917, 5545], [5547, 5547, 5570, 5570, 5633], [5635, 5635, 5664, 5664, 5703], [5705, 5705, 5723, 5723, 5947], [6097, 6097, 6119, 6119, 6241], [6242, 6242, 6263, 6263, 6382], [6384, 6384, 6410, 6410, 6649], [6651, 6651, 6677, 6677, 6939], [7001, 7001, 7028, 7028, 7370], [7372, 7372, 7399, 7399, 7685], [7687, 7687, 7715, 7715, 8112], [8113, 8176, 8204, 8333, 8944], [8947, 8947, 8978, 8978, 10830], [10832, 10832, 10862, 10862, 12743], [12745, 12745, 12802, 12802, 13414], [13417, 13417, 13474, 13474, 14087], [14090, 14090, 14144, 14144, 14684], [14686, 14686, 14764, 14764, 15041], [15043, 15043, 15085, 15085, 15400], [15403, 15403, 15474, 15474, 17282], [17379, 17424, 17488, 17488, 17915], [17916, 17916, 17952, 17952, 18540], [18587, 18587, 18612, 18612, 19117], [19119, 19119, 19176, 19226, 21330]]}
{"id": "wtVyDV", "name": "4D Quarternion Julia", "author": "milez770", "description": "is it working....", "tags": ["julia"], "likes": 1, "viewed": 66, "published": "Public", "date": "1612094435", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define ITER 10\n#define MAX_STEPS 100\n#define MAX_DIST 100.\n#define SURF_DIST 0.00001\n#define SPEED 5.\n\n// 3d mandelbulb\nfloat mandel4(in vec3 v, in vec4 c, out vec3 map){\n    //float t = sin(iTime)*.5+.5;\n    vec4 mv = vec4(v, 0.);\n    \n    vec4 r = mv;\n    vec4 rNext = r;\n    float m = dot(mv, mv);\n    vec4 trap = vec4(abs(r));\n    \n    int i = 0;\n    float d = 1.;\n    \n    float n =  2.;\n    \n    for(i=0; i<ITER; i++){\n        float cr = length(r);\n        float nr = pow(cr, n);\n        \n        d = pow(cr, n-1.) *n * d + 1.0;\n        \n        rNext.x = pow(r.x, n) - pow(r.y, n) - pow(r.z, n) - pow(r.w, n);\n        rNext.y = n*r.x*r.y;\n        rNext.z = n*r.x*r.z;\n        rNext.w = n*r.x*r.w;\n        r = c + rNext;\n        \n        trap = min(trap, vec4(abs(r)));\n        map = vec3(trap.xyz);\n\n        m = dot(r,r);\n        \n        if(m > 3.5){\n            break;\n        }\n    }\n    //return pow(length(r), 2.)+sqrt(m);\n    return  .35*log(m) * sqrt(length(m))/d;\n}\n\nmat2 Rot(float a) {\n    float s = sin(a);\n    float c = cos(a);\n    return mat2(c, -s, s, c);\n}\n\nvec3 R(vec2 uv, vec3 p, vec3 l, float z) {\n    vec3 f = normalize(l-p),\n        r = normalize(cross(vec3(0,1,0), f)),\n        u = cross(f,r),\n        c = p+f*z,\n        i = c + uv.x*r + uv.y*u,\n        d = normalize(i-p);\n    return d; \n}\n\nfloat RayMarch(in vec3 ro, in vec3 rd, in vec4 c, out vec3 col){\n    float dO = 0.;\n    \n    for(int i=0; i<MAX_STEPS; i++){\n        vec3 p = ro+rd*dO;\n        //p.xz *= Rot(iTime/SPEED);\n        //p.yz *= Rot(iTime/SPEED-2.);\n        float mbd = mandel4( p, c, col);\n        float dS = mbd;\n        \n        if(dO > MAX_DIST || dS<SURF_DIST) break;\n        dO += dS;\n    }\n    \n    return dO;\n}\nvec3 GetNormal(in vec3 p, in vec4 c){\n     vec3 col;\n    // my e value made black artifacts\n    // so I took a look at iq's normal epsilone. \n    // don't exactly know how this is calculated.\n    // looks like it is relevant to some screen pixel size calculation..?\n    vec2 e = vec2(1.0,-1.0)*0.5773*0.25*2.0/(iResolution.y*1.5);\n    \n    // getting vector with very small vector\n    vec3 n = vec3(\n        e.xyy*mandel4(p+e.xyy, c, col)+\n        e.yxy*mandel4(p+e.yxy, c, col)+\n        e.yyx*mandel4(p+e.yyx, c, col)+\n        e.xxx*mandel4(p+e.xxx, c, col ) \n    );\n    \n    return normalize(n);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord.xy-.5*iResolution.xy)/(iResolution.y);\n    vec2 m = iMouse.xy/iResolution.xy;\n    vec3 col = vec3(0);\n    \n    vec3 ro = vec3(0, 1.5, 1.5);\n    ro.xz *= Rot(iTime/5.);\n    ro.y = 2.*sin(iTime/3.);\n    vec3 rd = R(uv, ro, vec3(0,.0,0), .7);\n    \n    vec3 backgrounduv;\n    //2.*(sin(iTime)*.5 +.5)\n    //1.5*(sin(iTime)*.5+.5)\n    float time = iTime*.45;\n    vec4 c = 0.45*cos( vec4(0.5,3.9,1.4,1.1) + time*vec4(1.2,1.7,1.3,2.5) ) - vec4(0.3,0.0,0.0,0.0);\n    col = vec3(.05, .13, .1);\n    float d = RayMarch(ro, rd, c, backgrounduv);\n    col += vec3(.6-d*.3);\n    //col += .5;\n    col += pow(clamp(3. - backgrounduv.y, 0.0, .99), 9.)*vec3(.5, .3, .4);\n    //col *= 10.;\n    col *= (col+.9)*(col+.6);\n    \n    //light\n    vec3 lp = vec3(0, 3.5, 4.5);\n    lp.xz *= Rot(iTime/3.);\n    //lp.yz *= Rot(iTime/3.);\n    vec3 lr = ro+rd*d;\n    //lr.xz *= Rot(iTime/SPEED);\n    //lr.yz *= Rot(iTime/SPEED-2.);\n    lr = lr;\n    vec3 l = normalize(lp - lr);\n    vec3 n = GetNormal(lr, c);\n    vec3 shadow = clamp(dot(n, l), 0.1, 1.)*vec3(0., .8, 1.)*.7;\n    shadow *= 1.;\n    //col *= vec3(pow(shadow, 1.))*vec3(.3, .6, 1.);\n    \n    \n    vec3 lp2 = vec3(3., 0., 4.5);\n    lp2.xz *= Rot(iTime);\n    lp2.yz *= Rot(iTime/3.);\n    vec3 lr2 = ro+rd*d;\n    //lr2.xz *= Rot(iTime/SPEED);\n    //lr2.yz *= Rot(iTime/SPEED-2.);\n    lr2 = lr2;\n    vec3 l2 = normalize(lp2 - lr2);\n    vec3 n2 = GetNormal(lr2, c);\n    vec3 shadow2 = clamp(dot(n2, l2), 0.1, 1.)*vec3(1., .2, 0.4)*.7;\n    shadow2 *= 1.;\n    col *= (shadow+shadow2);\n    //col += vec3(.09, .04, .09);\n    \n    fragColor = vec4(col, 0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtVyDV.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[104, 121, 171, 205, 981], [983, 983, 1002, 1002, 1078], [1080, 1080, 1122, 1122, 1318], [1320, 1320, 1384, 1384, 1715], [1716, 1716, 1753, 1753, 2315], [2317, 2317, 2374, 2374, 3978]]}
{"id": "WtVyRd", "name": "Procedural Stones Ground", "author": "marcelfernandez13", "description": "This shader shows a procedural wet look stones ground.The ground geometry and ao was based on BigWIngs shader:\nhttps://www.shadertoy.com/view/XlcSzM\n\nYou can play with the mouse \"dragging\" to move the light. ", "tags": ["procedural", "raymarching", "noise", "ground", "pbr", "wet", "stone"], "likes": 3, "viewed": 86, "published": "Public", "date": "1611592577", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// This shader shows a wet look stones ground.\n// The ground geometry and ao was taken from a BigWIngs shader:\n// https://www.shadertoy.com/view/XlcSzM\n//\n// You can play with the mouse to move the light. In Constants section\n// you will find \"vec4 stones\" to control the shape of the stones.\n\n#define MAX_STEPS 100\n#define MAX_DISTANCE 100.0\n#define SURFACE_DIST 0.01\n\n#define PI 3.141592653589793238\n#define GAMMA 2.2\n#define saturate(val) clamp(val, 0.0, 1.0) \n\n// Structs\n\nstruct Material {\n    vec3  albedo;\n    vec3  normal;\n    float NdotL;\n    float NdotH;\n    float NdotV;\n    float HdotL;\n    float metalness;\n    float roughness;\n};\n\n\n// Constants\n\nvec4 stones = vec4(.2, .3, .5, 2.);\nfloat lightIntensity = 3.;\nfloat lightOffset = 7.;\n\n// Global\n\nvec3 lightPos = vec3(0, 2, 7);\n\n// Aux Functions\n\nfloat N2(vec2 p) {\n\t// Dave Hoskins - https://www.shadertoy.com/view/4djSRW\n\tvec3 p3  = fract(vec3(p.xyx) * vec3(443.897, 441.423, 437.195));\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nvec2 N21(float p) {\n\tvec2 p2 = fract(vec2(p) * vec2(443.897, 441.423));\n\tp2 += dot(p2, p2.yx + 19.19);\n    return fract((p2.xx+p2.yx)*p2.yy);\n\n}\n\nfloat N2(float x, float y) { return N2(vec2(x, y)); }\n\nvec3 N31(float p) {\t\n   vec3 p3 = fract(vec3(p) * vec3(443.897, 441.423, 437.195));\n   p3 += dot(p3, p3.yzx+19.19);\n   return fract((p3.xxy+p3.yzz)*p3.zyx); \n}\n\nfloat Noise(vec2 uv) {\n    vec2 id = floor(uv);\n    vec2 m = fract(uv);\n    m = 3.* m * m - 2.* m * m * m;\n    \n    float top = mix(N2(id.x, id.y), N2(id.x+1., id.y), m.x);\n    float bot = mix(N2(id.x, id.y+1.), N2(id.x+1., id.y+1.), m.x);\n    \n    return mix(top, bot, m.y);\n}\n\nfloat noiseTex(vec2 uv, float seed, float octaves) {\n    float v = 0.;\n    uv += N21(seed);\n    \n    for (float i = 1.; i <= 11.; i++) {\n    \tv += Noise(uv) / i;\n        uv *= 2.;\n        \n        if (i > octaves) break;\n    }\n    \n    return v * .5;\n}\n\n// Gamma Correction\n\nvec3 gammaToLinear(vec3 col) {\n    return pow(col, vec3(GAMMA));\n}\n\nvec3 linearToGamma(vec3 col) {\n    return pow(col, vec3(1.0 / GAMMA));\n}\n\n// PBR\n\nfloat SchlickFresnel(float dotProduct) {\n    return pow(clamp(1.0 - dotProduct, 0.0, 1.0), 5.0);\n}\n\nfloat Geometry(float NdotV, float alphaG) {\n    float a = alphaG * alphaG;\n    float b = NdotV * NdotV;\n    return 1.0 / (NdotV + sqrt(a + b - a * b));\n}\n\nfloat TrowbridgeReitzNDF(float NdotH, float roughness) {\n    if (roughness >= 1.0)\n        return 1.0 / PI;\n    \n    float roughnessSqr = roughness * roughness;\n    \n    float d = (NdotH * roughnessSqr - NdotH) * NdotH + 1.0;\n    return roughnessSqr / (PI * d * d);\n}\n\n// -------\n\nvec2 GetStoneTiles(vec3 p) {\n    return vec2(p.x + sin(p.z * stones.x), p.z + sin(p.x * stones.y) * stones.z) * stones.w;\n}\n\nfloat getDistance(vec3 p) {\n    float d = p.y;\n    vec2 tiles = GetStoneTiles(p);;\n    vec2 id = floor(tiles);\n    float bump = N2(id.x, id.y);\n\n    vec2 tUv = tiles * PI;\n    float tileMask = abs(sin(tUv.x)*sin(tUv.y));\n    tileMask = 1.0 - pow(1.0 - tileMask, 8.0);\n    d -= tileMask * .09 * bump;\n \n    vec3 n = N31(id.x + id.y * 165.32);\t\n    float detail = sin(n.x * p.x * 15.0) * sin(n.y * p.z * 15.0) * 0.05;\n    detail += sin(n.z * p.x * p.z * 5.0) * 0.005;\n    d += detail;\t\t\t\t\t\n   \n    return d;\n}\n\nfloat GroundAO(vec3 normal, vec3 pos, float dist) {\n\tfloat occ = 0.0;\n    float sca = 1.0;\n    for (int i = 0; i < 5; i++) {\n    \n        float hr = 0.01 + dist * float(i) / 5.0;\n        vec3 aopos =  normal * hr + pos;\n        float dd = getDistance(aopos);\n        occ += -(dd - hr)*sca;\n        sca *= 0.35;\n    }\n    \n    return saturate(1.0 - 3.0 * occ);    \n}\n\nfloat rayMarch(vec3 ro, vec3 rd) {\n    // Distance to the object\n    float dO = 0.0; \n    for (int i = 0; i < MAX_STEPS; i++) {\n        vec3 p = ro + (dO * rd);\n        float dS = getDistance(p);\n        dO += dS;\n        if (dS <= SURFACE_DIST || dS > MAX_DISTANCE) break;\n    }\n\n    return dO;\n}\n\nvec3 getNormal(vec3 p) {\n    vec3 eps = vec3(0.001, 0.0, 0.0);\n\tvec3 nor = vec3(\n\t    getDistance(p+eps.xyy) - getDistance(p-eps.xyy),\n\t    getDistance(p+eps.yxy) - getDistance(p-eps.yxy),\n\t    getDistance(p+eps.yyx) - getDistance(p-eps.yyx));\n\treturn normalize(nor);\n}  \n\nvec3 diffuseTerm(Material mat, float lightIntensity) {\n    return (mat.albedo / PI * (1.0 - mat.metalness)) * mat.NdotL * lightIntensity;\n}\n\nvec3 specularTerm(Material mat) {\n    vec3 irradiatedColor = vec3(.3);\n    float specularRoughness = mat.roughness * (1.0 - mat.metalness) + mat.metalness;\n    float D = TrowbridgeReitzNDF(mat.NdotH, specularRoughness);\n    \n    float Cspec0 = 0.02;\n    vec3 F = vec3(mix(Cspec0, 1.0, SchlickFresnel(mat.HdotL)));\n    float alphaG = pow(specularRoughness * 0.5 + 0.5, 2.0);\n    float G = Geometry(mat.NdotL, alphaG) * Geometry(mat.NdotV, alphaG);\n    \n    return (D * G * F * irradiatedColor) * (1.0 + mat.metalness * mat.albedo) +\n                                           irradiatedColor * mat.metalness * mat.albedo;\n}\n\nvec3 renderGround(vec3 p, vec3 v) {\n    vec3 col = vec3(0);\n    Material mat;\n    \n    vec2 uv = p.xz * 5.;\n    mat.albedo = gammaToLinear(vec3(0.5));\n    vec2 noise = vec2(noiseTex(uv, 0., 5.), noiseTex(uv, 12., 5.));\n\n    vec3 l = normalize(lightPos - p);\n    vec3 n = getNormal(p);\n    n.xz += (noise - 0.5) * 2.0;\n    \n    n = normalize(n);\n    \n    mat.normal = n;\n    \n    vec3 h = normalize(v + l);\n    \n    vec2 id = floor(GetStoneTiles(p));\n    mat.albedo *= 1.0 + (N2(id) - 0.5) * 0.3;\t\t\n    \n    float ao = GroundAO(n, p, 1.0);\n    \n    mat.metalness = 1.0 - noise.y;\n    mat.roughness = noise.y;\n    mat.NdotL = dot(n, l);\n    mat.NdotH = dot(h, n);\n    mat.NdotV = dot(n, v);\n    mat.HdotL = dot(h, l);\n    \n    \n    vec3 diff = diffuseTerm(mat, lightIntensity);\n    vec3 specular = saturate(specularTerm(mat));\n    \n    // return specular;\n    return (diff + specular) * ao * dot(vec3(0, 1, 0), l);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    // Set 0 of uv in the midle of the screen\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n\n    if (iMouse.z > 0.0) {\n        vec2 mouseOffset = (iMouse.xy - 0.5 * iResolution.xy) / iResolution.y;\n        lightPos.xz += mouseOffset * lightOffset;\n    } else {\n        lightPos.xz += vec2(sin(iTime), cos(iTime)) * 3.0;\n    }\n\n    vec3 col = vec3(0);\n\n    vec3 ro = vec3(0, 4, 0);\n    vec3 rd = normalize(vec3(uv.x, uv.y - .5, 1.0));\n    \n    if (rd.y <= .0) {\n        float dist = rayMarch(ro, rd);\n\n        vec3 p = ro + (rd * dist);\n\n        col = renderGround(p, rd);\n    }\n    \n    col = linearToGamma(col);\n\n    fragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WtVyRd.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[791, 809, 827, 884, 1027], [1029, 1029, 1048, 1048, 1173], [1175, 1175, 1203, 1203, 1228], [1230, 1230, 1249, 1249, 1389], [1391, 1391, 1413, 1413, 1668], [1670, 1670, 1722, 1722, 1922], [1924, 1945, 1975, 1975, 2011], [2013, 2013, 2043, 2043, 2085], [2087, 2095, 2135, 2135, 2193], [2195, 2195, 2238, 2238, 2348], [2350, 2350, 2406, 2406, 2617], [2619, 2631, 2659, 2659, 2754], [2756, 2756, 2783, 2783, 3263], [3265, 3265, 3316, 3316, 3630], [3632, 3632, 3666, 3696, 3929], [3931, 3931, 3955, 3955, 4200], [4204, 4204, 4258, 4258, 4343], [4345, 4345, 4378, 4378, 4967], [4969, 4969, 5004, 5004, 5883], [5885, 5885, 5940, 5986, 6608]]}
{"id": "wtVyRG", "name": "Spherical Repetition (Polar)", "author": "oneshade", "description": "Spherical repetition operator. No more messing with polar coordinates any more!", "tags": ["repetition", "mod", "spherical", "polar"], "likes": 27, "viewed": 251, "published": "Public", "date": "1611257725", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define TAU 6.28318530718 // 2 * pi\n#define PHI 1.57079632679 // pi / 2\n\n// r: vec2(horizontal repeats, vertical repeats)\nvoid pModSpherical(inout vec3 p, in vec2 r) {\n    vec2 a = TAU / r, ha = 0.5 * a;\n    p.xz = sin(mod(atan(p.z, p.x) + ha.x, a.x) - ha.x + vec2(PHI, 0.0)) * length(p.xz);\n    p.xy = sin(mod(atan(p.y, p.x) + ha.y, a.y) - ha.y + vec2(PHI, 0.0)) * length(p.xy);\n}\n\nfloat mapScene(in vec3 p) {\n    float c = cos(iTime), s = sin(iTime);\n    p.xz *= mat2(c, -s, s, c);\n    p.yz *= mat2(c, -s, s, c);\n\n    pModSpherical(p, vec2(27.0 + 23.0 * sin(iTime), 27.0 + 23.0 * cos(iTime)));\n    vec3 q = abs(p - vec3(2.0, 0.0, 0.0)) - 0.1;\n    float boxes = max(q.x, max(q.y, q.z));\n\n    return boxes;\n}\n\nvec3 getNormal(in vec3 p) {\n    vec3 e = vec3(0.001, 0.0, 0.0);\n    return normalize(vec3(mapScene(p + e.xyy) - mapScene(p - e.xyy),\n                          mapScene(p + e.yxy) - mapScene(p - e.yxy),\n                          mapScene(p + e.yyx) - mapScene(p - e.yyx)));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n    fragColor = vec4(0.0, 0.0, 0.0, 1.0);\n\n    vec3 ro = vec3(0.0, 0.0, 5.0);\n    vec3 rd = normalize(vec3(uv, -1.0));\n\n    float t = 0.0;\n    for (int i=0; i < 150; i++) {\n        vec3 p = ro + rd * t;\n        float d = mapScene(p);\n        if (d < 0.001) {\n            vec3 n = getNormal(p);\n            vec3 l = vec3(-0.58, 0.58, 0.58);\n            fragColor.rgb += max(0.1, dot(n, l));\n            break;\n        }\n\n        if (t > 100.0) {\n            break;\n        }\n\n        t += d;\n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtVyRG.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[73, 122, 167, 167, 381], [383, 383, 410, 410, 708], [710, 710, 737, 737, 984], [986, 986, 1041, 1041, 1606]]}
{"id": "wtVyRt", "name": "Clouds - by intrakits", "author": "intrakits", "description": "I am try to make clouds", "tags": ["clouds"], "likes": 1, "viewed": 158, "published": "Unlisted", "date": "1611618192", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define MAX_STEPS 200\n#define MAX_DIST 200.\n#define SURFACE_DIST 0.01\nmat2 Rot(float a) {\n    float s=sin(a), c=cos(a);\n    return mat2(c, -s, s, c);\n}\nfloat sdCylinder(vec3 p, vec3 a, vec3 b, float r, float offX, float offY, float offZ) {\n\ta.x += offX;\n    b.x += offX;\n    \n    a.y += offY;\n    b.y += offY;\n    \n    a.z += offZ;\n    b.z += offZ;\n    \n    vec3 ab = b-a;\n    vec3 ap = p-a;\n    \n    float t = dot(ab, ap) / dot(ab, ab);\n    \n    vec3 c = a + t*ab;\n    \n    float x = length(p-c)-r;\n    float y = (abs(t-.5)-.5)*length(ab);\n    float e = length(max(vec2(x, y), 0.));\n    float i = min(max(x, y), 0.);\n    \n    return e+i;\n}\n\nfloat sdCapsule(vec3 p, vec3 a, vec3 b, float r){\n    //line from a to b\n    vec3 ab = b-a;\n    \n    // line from p to a\n    vec3 ap = p-a;\n    \n    // as p approaches a, it will be 1\n    // as p approaches b it will b 0\n    float t = dot(ab,ap) / dot(ab,ab);\n    \n    // clamp values between 0 and 1\n    t= clamp(t,0.,1.);\n    \n    // center point of the capsule\n    // start at a (top of capsule)\n    // go towards b, t steps\n    vec3 c = a + t*ab;\n    \n    float d = length(p-c)-r;\n    \n    return d;\n}\n\nfloat sdTorus(vec3 p, vec2 r){\n    float x = length(p.xz)-r.x;\n    return length(vec2(x, p.y))-r.y;\n}\n\nfloat dBox(vec3 p, vec3 s){\n    return length(max(abs(p)-s,0.));\n}\n// http://iquilezles.org/www/articles/smin/smin.htm\nfloat smin( float a, float b, float k )\n{\n    float h = max(k-abs(a-b),0.0);\n    return min(a, b) - h*h*0.25/k;\n}\n\n// http://iquilezles.org/www/articles/smin/smin.htm\nvec2 smin( vec2 a, vec2 b, float k )\n{\n    float h = clamp( 0.5+0.5*(b.x-a.x)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\n// http://iquilezles.org/www/articles/smin/smin.htm\nfloat smax( float a, float b, float k )\n{\n    float h = max(k-abs(a-b),0.0);\n    return max(a, b) + h*h*0.25/k;\n}\n\n\nfloat cloudGen (vec3 p, int xOff,float yOff, int zOff, float timing){\n    float cloud = dBox(p-vec3(sin(iTime*.1 * timing)*20.+float(xOff),5. + float(yOff),0.+float(zOff)), vec3(2.,.2,1));\n    vec2 uv = vec2(atan(p.x,p.z)/(3.14159*30.),p.y/70.)+iTime*.001;\n    float cloudWallDisp = texture(iChannel1,uv).r;\n    \n    cloudWallDisp *= smoothstep(3.8,1.8,abs(p.y));\n    vec2 uv2 = vec2(p.x*.005 +iTime*.001,p.z*.005 - iTime*.001);\n    float cloudDisp = texture(iChannel1,uv2).r;\n    cloud -= clamp(cloudDisp, 0.,1.);\n    cloud -= clamp(cloudWallDisp, 0.,1.);\n\n    return cloud;\n}\nfloat GetDist(vec3 p){\n \n    //--------------------------------\n    // distance to center of sphere: \n    // length(sphere position - camera position)\n    // distance to outside of the sphere:\n    // length(sphere position - camera position) - sphere radius\n   // float ds = length(p-sphere.xyz)-sphere.w;\n    \n    //distance to floor (plane)\n    //this is just height of the origin point passed\n    \n    //ground plane\n    float dp =p.y;\n    //cloud\n    \n    float d = dp;\n    for(int x = 0; x < 5; x++){\n        for(int z = 0; z < 5; z++){\n            vec3 pos = abs(p);\n            int xOff = x*5*(x%5);\n            float yOff =float(sin(float(x)/5.)*10.);\n            float cloud = cloudGen(pos,xOff,yOff,z*5*(z%5), 1.+float((x%5)));\n            d = smin(d, cloud,0.4);\n        }\n    }\n    \n  \n    return d;\n}\nfloat RayMarch(vec3 ro, vec3 rd){\n    // distance from origin\n    float dO=0.;\n    // march until max steps is achieved or object hit\n    for(int i=0; i <MAX_STEPS; i++){\n        // current point being evaluated\n        vec3 p = ro + dO*rd;\n        \n        // get distance to seam\n        float ds = GetDist(p);\n        //move origin to new point\n        dO+=ds*.4;\n        if(ds < SURFACE_DIST || dO > MAX_DIST){\n            break;\n        }\n    }\n    return min(dO, MAX_DIST);;\n}\nvec3 GetNormal(vec3 p){\n    //distance to point being analyzed\n    float d = GetDist(p);\n    \n    //distance to another point along the objects surface that is closeby\n    vec2 e = vec2(0.01,0);\n    \n    //slope between the two points\n    //note: swizzel is the .xxy or .yyx etc\n    vec3 n = d - vec3(\n         GetDist(p-e.xyy),\n         GetDist(p-e.yxy),\n         GetDist(p-e.yyx));\n         \n    return normalize(n);\n    \n}\nfloat GetLight(vec3 p){\n    //position of the light source\n    vec3 lightPos = vec3(0,50,6);\n    \n    lightPos.xz *= Rot(sin(iTime*.05)*50.);\n    //light vector\n    vec3 l = normalize(lightPos-p+vec3(0,0,0));\n    \n    //normal of object\n    vec3 n = GetNormal(p);\n    \n    // dot product of the light vector and normal of the point\n    // will give us the amount of lighting to apply to the point\n    // dot() evaluates to values between -1 and 1, so we will clamp it\n    float diff = clamp(dot(n, l),0.,1.);\n    \n    // calculate if point should be a shadow:\n    // raymarch from point being calculated towards light source\n    // if hits surface of something else before the light,\n    // then it must be obstructed and thus is a shadow\n    // the slight offset \"p+n*SURFACE_DIST*1.1\" is needed to ensure the\n    // break condistions in the function are not met too early\n    float d = RayMarch(p+n*SURFACE_DIST*1.1,l);\n    if(d < length(lightPos-p)){\n        diff *= 0.1;\n    }\n    return diff;\n}\nvec3 GetRayDir(vec2 uv, vec3 p, vec3 l, float z) {\n    vec3 f = normalize(l-p),\n        r = normalize(cross(vec3(0,1,0), f)),\n        u = cross(f,r),\n        c = f*z,\n        i = c + uv.x*r + uv.y*u,\n        d = normalize(i);\n    return d;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from -0.5 to 0.5)\n    // origin is now (0,0)\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    vec2 m = iMouse.xy/iResolution.xy;\n    vec3 col = vec3(0);\n    \n    //camera\n    //-----------------\n    // ray origin\n    //controls position\n    vec3 ro = vec3(4,30,1);\n    ro.yz *= Rot(-m.y*3.14+1.);\n    ro.xz *= Rot(-m.x*6.2831);\n    \n    //ray dir\n    //controls rotation\n    vec3 rd = GetRayDir(uv, ro, vec3(0), 1.);\n    //------------------\n    float d = RayMarch(ro,rd);\n    // position of point\n    // start at ray origin\n    // move d units in the ray direction\n    vec3 p = ro + rd *d;\n    \n    float y = p.y+10.;\n    col = vec3(0,y*.01,y);\n    \n    //color objects\n    if(d < MAX_DIST){\n        \n        //get normals\n        vec3 n = abs(GetNormal(p));\n        col = vec3(0,1,0);\n        //colore each normal with appropriate texture\n        \n        \n        \n        //colour cloud\n        float clouds;\n        for(int x = 0; x < 5; x++){\n            for(int z = 0; z < 5; z++){\n                float cloud = cloudGen(abs(p),x*5*(x%5),0.,z*5*(z%5), -1.*smoothstep(.9,.7,float((x%5))));\n                clouds = smin(cloud, cloud,0.4);\n            }\n        }\n        col = p.y *vec3(.6);\n        \n\n        col += clouds * vec3(0,.01,0);\n        \n        //get diffuse lighting\n        float diff = GetLight(p);\n        col *= vec3(diff);\n        \n        \n\n    }\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": "4dXGzn", "previewfilepath": "/media/ap/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtVyRt.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[70, 70, 89, 89, 151], [152, 152, 239, 239, 640], [642, 642, 691, 714, 1147], [1149, 1149, 1179, 1179, 1250], [1252, 1252, 1279, 1279, 1318], [1319, 1371, 1412, 1412, 1484], [1486, 1538, 1576, 1576, 1673], [1675, 1727, 1768, 1768, 1840], [1843, 1843, 1912, 1912, 2420], [2421, 2421, 2443, 2840, 3234], [3235, 3235, 3268, 3296, 3717], [3718, 3718, 3741, 3780, 4143], [4144, 4144, 4167, 4202, 5143], [5144, 5144, 5194, 5194, 5385], [5386, 5386, 5443, 5525, 6900]]}
{"id": "wtVyWG", "name": "pattern practice - 4", "author": "Many", "description": "shader pattern practice noise", "tags": ["patternpracticenoise"], "likes": 0, "viewed": 30, "published": "Public", "date": "1611865551", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI 3.14159265358979323846\n\nfloat random (in vec2 st) {\n    return fract(sin(dot(st.xy,\n                         vec2(12.9898,78.233)))\n                 * 43758.5453123);\n}\n\nvec2 random2(vec2 st){\n    st = vec2( dot(st,vec2(127.1,311.7)),\n              dot(st,vec2(269.5,183.3)) );\n    return -1.0 + 2.0*fract(sin(st)*43758.5453123);\n}\nvec2 rotate2D (vec2 _st, float _angle) {\n    _st -= 0.5;\n    _st =  mat2(cos(_angle),-sin(_angle),\n                sin(_angle),cos(_angle)) * _st;\n    _st += 0.5;\n    return _st;\n}\n\nfloat noise(vec2 st) {\n    vec2 i = floor(st);\n    vec2 f = fract(st);\n\n    vec2 u = f*f*(3.0-2.0*f) *f;\n\n    return mix( mix( dot( random2(i + vec2(0.0,0.0) ), f - vec2(0.0,0.0) ),\n                     dot( random2(i + vec2(1.0,0.0) ), f - vec2(1.0,0.0) ), u.x),\n                mix( dot( random2(i + vec2(0.0,1.0) ), f - vec2(0.0,1.0) ),\n                     dot( random2(i + vec2(1.0,1.0) ), f - vec2(1.0,1.0) ), u.x), u.y);\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    uv.x *= iResolution.x/iResolution.y;\n    // Time varying pixel color\n    \n    vec3 col = vec3(0.);\n    //float time = mod(iTime,7200);\n    float t =50.*sin(iTime)/iTime;\n    uv += noise(uv * 2.) * t;\n    \n    vec3 n = vec3(1.) * smoothstep(.18,.2,noise(uv));\n    n += smoothstep(.15,.2,noise(uv * 10.));\n    n -= smoothstep(.35,.4,noise(uv * 10.)); \n    //col = 1. - col;\n    //n = 1. - n;\n    n *= vec3(.71,.94,.84);\n    col = mix(vec3(0.332,0.88,0.608),vec3(.67,0.90,0.98),uv.x);\n    col +=n;\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtVyWG.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[35, 35, 62, 62, 179], [181, 181, 203, 203, 342], [343, 343, 383, 383, 523], [525, 525, 547, 547, 954], [955, 955, 1012, 1062, 1658]]}
{"id": "wtVyWh", "name": "Noisy Balance...", "author": "Peace", "description": "Perlin Noise Based Cloud / Fog Generation.", "tags": ["perlinnoise"], "likes": 1, "viewed": 174, "published": "Public API", "date": "1610938676", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float random (in vec2 st) {\n    return fract(sin(dot(st.xy,\n                         vec2(12.9898,78.233)))*\n        43758.5453123);\n}\n\n\nfloat noise (in vec2 st) {\n    vec2 i = floor(st);\n    vec2 f = fract(st);\n\n    float a = random(i);\n    float b = random(i + vec2(1.0, 0.0));\n    float c = random(i + vec2(0.0, 1.0));\n    float d = random(i + vec2(1.0, 1.0));\n\n    vec2 u = f * f * (3.0 - 2.0 * f);\n\n    return mix(a, b, u.x) +\n            (c - a)* u.y * (1.0 - u.x) +\n            (d - b) * u.x * u.y;\n}\n\n#define OCTAVES 6\nfloat fbm (in vec2 st) {\n    float value = 0.0;\n    float amplitude = .12;\n    float frequency = .4; \n\n\n    for (int i = 0; i < OCTAVES; i++) {\n        value += amplitude * noise(st * frequency + iTime / 2.0);\n        st *= 2.;\n        amplitude *= .5;\n    }\n    return value;\n}\n\nvec3 skyCol = vec3(0, 0.6, 1);\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n\n  vec2 st = fragCoord/iResolution.xy;\n    st.x *= iResolution.x/iResolution.y * 32.;\n\n    vec3 color = vec3(0.0);\n    color += fbm(st.xy*4.0);\n    \n    fragColor = vec4(pow(vec3(0.4, .8, 1.0) + color, vec3(1.5)), 1);  \n  \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtVyWh.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 27, 27, 134], [137, 137, 163, 163, 507], [527, 527, 551, 551, 805], [839, 839, 894, 894, 1119]]}
{"id": "wtVyWK", "name": "Neural Stanford Bunny (5 kb)", "author": "blackle", "description": "my suspicions that mat4 multiplies and sines are really fast on the gpu are confirmed yet again\n\nexplainer: https://youtu.be/8pwXpfi-0bU", "tags": ["bunny"], "likes": 179, "viewed": 8265, "published": "Public API", "date": "1611814432", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//CC0 1.0 Universal https://creativecommons.org/publicdomain/zero/1.0/\n//To the extent possible under law, Blackle Mori has waived all copyright and related or neighboring rights to this work.\n\n//like the last few shaders I've published, this is a neural network experiment.\n//this time, the neural network reproduces an SDF given the x,y,z coordinates\n//using siren networks with skip connections: https://vsitzmann.github.io/siren/\n\nvec3 erot(vec3 p, vec3 ax, float ro) {\n    return mix(dot(p,ax)*ax,p,cos(ro))+sin(ro)*cross(ax,p);\n}\n\nfloat scene(vec3 p) {\n    //sdf is undefined outside the unit sphere, uncomment to witness the abominations\n    if (length(p) > 1.) {\n        return length(p)-.8;\n    }\n    //neural networks can be really compact... when they want to be\n    vec4 f00=sin(p.y*vec4(-3.02,1.95,-3.42,-.60)+p.z*vec4(3.08,.85,-2.25,-.24)-p.x*vec4(-.29,1.16,-3.74,2.89)+vec4(-.71,4.50,-3.24,-3.50));\n    vec4 f01=sin(p.y*vec4(-.40,-3.61,3.23,-.14)+p.z*vec4(-.36,3.64,-3.91,2.66)-p.x*vec4(2.90,-.54,-2.75,2.71)+vec4(7.02,-5.41,-1.12,-7.41));\n    vec4 f02=sin(p.y*vec4(-1.77,-1.28,-4.29,-3.20)+p.z*vec4(-3.49,-2.81,-.64,2.79)-p.x*vec4(3.15,2.14,-3.85,1.83)+vec4(-2.07,4.49,5.33,-2.17));\n    vec4 f03=sin(p.y*vec4(-.49,.68,3.05,.42)+p.z*vec4(-2.87,.78,3.78,-3.41)-p.x*vec4(-2.65,.33,.07,-.64)+vec4(-3.24,-5.90,1.14,-4.71));\n    vec4 f10=sin(mat4(-.34,.06,-.59,-.76,.10,-.19,-.12,.44,.64,-.02,-.26,.15,-.16,.21,.91,.15)*f00+\n        mat4(.01,.54,-.77,.11,.06,-.14,.43,.51,-.18,.08,.39,.20,.33,-.49,-.10,.19)*f01+\n        mat4(.27,.22,.43,.53,.18,-.17,.23,-.64,-.14,.02,-.10,.16,-.13,-.06,-.04,-.36)*f02+\n        mat4(-.13,.29,-.29,.08,1.13,.02,-.83,.32,-.32,.04,-.31,-.16,.14,-.03,-.20,.39)*f03+\n        vec4(.73,-4.28,-1.56,-1.80))/1.0+f00;\n    vec4 f11=sin(mat4(-1.11,.55,-.12,-1.00,.16,.15,-.30,.31,-.01,.01,.31,-.42,-.29,.38,-.04,.71)*f00+\n        mat4(.96,-.02,.86,.52,-.14,.60,.44,.43,.02,-.15,-.49,-.05,-.06,-.25,-.03,-.22)*f01+\n        mat4(.52,.44,-.05,-.11,-.56,-.10,-.61,-.40,-.04,.55,.32,-.07,-.02,.28,.26,-.49)*f02+\n        mat4(.02,-.32,.06,-.17,-.59,.00,-.24,.60,-.06,.13,-.21,-.27,-.12,-.14,.58,-.55)*f03+\n        vec4(-2.24,-3.48,-.80,1.41))/1.0+f01;\n    vec4 f12=sin(mat4(.44,-.06,-.79,-.46,.05,-.60,.30,.36,.35,.12,.02,.12,.40,-.26,.63,-.21)*f00+\n        mat4(-.48,.43,-.73,-.40,.11,-.01,.71,.05,-.25,.25,-.28,-.20,.32,-.02,-.84,.16)*f01+\n        mat4(.39,-.07,.90,.36,-.38,-.27,-1.86,-.39,.48,-.20,-.05,.10,-.00,-.21,.29,.63)*f02+\n        mat4(.46,-.32,.06,.09,.72,-.47,.81,.78,.90,.02,-.21,.08,-.16,.22,.32,-.13)*f03+\n        vec4(3.38,1.20,.84,1.41))/1.0+f02;\n    vec4 f13=sin(mat4(-.41,-.24,-.71,-.25,-.24,-.75,-.09,.02,-.27,-.42,.02,.03,-.01,.51,-.12,-1.24)*f00+\n        mat4(.64,.31,-1.36,.61,-.34,.11,.14,.79,.22,-.16,-.29,-.70,.02,-.37,.49,.39)*f01+\n        mat4(.79,.47,.54,-.47,-1.13,-.35,-1.03,-.22,-.67,-.26,.10,.21,-.07,-.73,-.11,.72)*f02+\n        mat4(.43,-.23,.13,.09,1.38,-.63,1.57,-.20,.39,-.14,.42,.13,-.57,-.08,-.21,.21)*f03+\n        vec4(-.34,-3.28,.43,-.52))/1.0+f03;\n    f00=sin(mat4(-.72,.23,-.89,.52,.38,.19,-.16,-.88,.26,-.37,.09,.63,.29,-.72,.30,-.95)*f10+\n        mat4(-.22,-.51,-.42,-.73,-.32,.00,-1.03,1.17,-.20,-.03,-.13,-.16,-.41,.09,.36,-.84)*f11+\n        mat4(-.21,.01,.33,.47,.05,.20,-.44,-1.04,.13,.12,-.13,.31,.01,-.34,.41,-.34)*f12+\n        mat4(-.13,-.06,-.39,-.22,.48,.25,.24,-.97,-.34,.14,.42,-.00,-.44,.05,.09,-.95)*f13+\n        vec4(.48,.87,-.87,-2.06))/1.4+f10;\n    f01=sin(mat4(-.27,.29,-.21,.15,.34,-.23,.85,-.09,-1.15,-.24,-.05,-.25,-.12,-.73,-.17,-.37)*f10+\n        mat4(-1.11,.35,-.93,-.06,-.79,-.03,-.46,-.37,.60,-.37,-.14,.45,-.03,-.21,.02,.59)*f11+\n        mat4(-.92,-.17,-.58,-.18,.58,.60,.83,-1.04,-.80,-.16,.23,-.11,.08,.16,.76,.61)*f12+\n        mat4(.29,.45,.30,.39,-.91,.66,-.35,-.35,.21,.16,-.54,-.63,1.10,-.38,.20,.15)*f13+\n        vec4(-1.72,-.14,1.92,2.08))/1.4+f11;\n    f02=sin(mat4(1.00,.66,1.30,-.51,.88,.25,-.67,.03,-.68,-.08,-.12,-.14,.46,1.15,.38,-.10)*f10+\n        mat4(.51,-.57,.41,-.09,.68,-.50,-.04,-1.01,.20,.44,-.60,.46,-.09,-.37,-1.30,.04)*f11+\n        mat4(.14,.29,-.45,-.06,-.65,.33,-.37,-.95,.71,-.07,1.00,-.60,-1.68,-.20,-.00,-.70)*f12+\n        mat4(-.31,.69,.56,.13,.95,.36,.56,.59,-.63,.52,-.30,.17,1.23,.72,.95,.75)*f13+\n        vec4(-.90,-3.26,-.44,-3.11))/1.4+f12;\n    f03=sin(mat4(.51,-.98,-.28,.16,-.22,-.17,-1.03,.22,.70,-.15,.12,.43,.78,.67,-.85,-.25)*f10+\n        mat4(.81,.60,-.89,.61,-1.03,-.33,.60,-.11,-.06,.01,-.02,-.44,.73,.69,1.02,.62)*f11+\n        mat4(-.10,.52,.80,-.65,.40,-.75,.47,1.56,.03,.05,.08,.31,-.03,.22,-1.63,.07)*f12+\n        mat4(-.18,-.07,-1.22,.48,-.01,.56,.07,.15,.24,.25,-.09,-.54,.23,-.08,.20,.36)*f13+\n        vec4(-1.11,-4.28,1.02,-.23))/1.4+f13;\n    return dot(f00,vec4(.09,.12,-.07,-.03))+dot(f01,vec4(-.04,.07,-.08,.05))+\n        dot(f02,vec4(-.01,.06,-.02,.07))+dot(f03,vec4(-.05,.07,.03,.04))-0.16;\n}\n\nvec3 norm(vec3 p) {\n    mat3 k = mat3(p,p,p)-mat3(0.001);\n    return normalize(scene(p) - vec3(scene(k[0]),scene(k[1]),scene(k[2])));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-0.5*iResolution.xy)/iResolution.y;\n    vec2 mouse = (iMouse.xy-0.5*iResolution.xy)/iResolution.y;\n\n    vec3 cam = normalize(vec3(1.5,uv));\n    vec3 init = vec3(-3.,0,0);\n    \n    float yrot = 0.5;\n    float zrot = iTime*.2;\n    if (iMouse.z > 0.) {\n        yrot += -4.*mouse.y;\n        zrot = 4.*mouse.x;\n    }\n    cam = erot(cam, vec3(0,1,0), yrot);\n    init = erot(init, vec3(0,1,0), yrot);\n    cam = erot(cam, vec3(0,0,1), zrot);\n    init = erot(init, vec3(0,0,1), zrot);\n    \n    vec3 p = init;\n    bool hit = false;\n    for (int i = 0; i < 150 && !hit; i++) {\n        float dist = scene(p);\n        hit = dist*dist < 1e-6;\n        p+=dist*cam;\n        if (distance(p,init)>5.) break;\n    }\n    vec3 n = norm(p);\n    vec3 r = reflect(cam,n);\n    //don't ask how I stumbled on this texture\n    vec3 nz = p - erot(p, vec3(1), 2.) + erot(p, vec3(1), 4.);\n    float spec = length(sin(r*3.5+sin(nz*120.)*.15)*.4+.6)/sqrt(3.);\n    spec *= smoothstep(-.3,.2,scene(p+r*.2));\n    vec3 col = vec3(.1,.1,.12)*spec + pow(spec,8.);\n    float bgdot = length(sin(cam*8.)*.4+.6)/2.;\n    vec3 bg = vec3(.1,.1,.11) * bgdot + pow(bgdot, 10.);\n    fragColor.xyz = hit ? col : bg;\n    fragColor = smoothstep(-.02,1.05,sqrt(fragColor)) * (1.- dot(uv,uv)*.5);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtVyWK.jpg", "access": "shaders20k", "license": "cc0-1.0", "functions": [[194, 435, 473, 473, 535], [537, 537, 558, 644, 4849], [4851, 4851, 4870, 4870, 4986], [4988, 4988, 5045, 5045, 6313]]}
{"id": "WtVyWV", "name": "Octahedron SDF (not exact)", "author": "oneshade", "description": "I came across this somewhat by accident while playing with tdhooper's SDF mesher: http://tdhooper.github.io/glsl-marching-cubes/", "tags": ["distancefield", "sdf", "octahedron", "bound"], "likes": 2, "viewed": 61, "published": "Public", "date": "1611793810", "time_retrieved": "2021-10-01T00:00:00", "image_code": "struct Surface {\n    float dist;\n    vec3 ambient;\n    vec3 diffuse;\n    vec3 specular;\n    float gloss;\n};\n\nfloat sdOctahedron(in vec3 p, in float s) {\n    const float c = 1.73205080757; // sqrt(3)\n    return (dot(abs(p), vec3(1.0)) - s) / c;\n}\n\nSurface mapScene(in vec3 p) {\n    vec3 planeColor = vec3(mod(dot(floor(p.xz), vec2(1.0)), 2.0));\n    Surface plane = Surface(p.y + 1.0, 1.6 * planeColor, planeColor, vec3(0.0), 0.0);\n    Surface shape = Surface(sdOctahedron(p, 0.5 + 0.5 * sin(iTime)), vec3(0.2, 0.0, 0.0), vec3(1.0, 0.0, 0.0), vec3(1.0), 8.0);\n\n    if (plane.dist < shape.dist) {\n        return plane;\n    }\n\n    return shape;\n}\n\nvec3 getNormal(in vec3 p) {\n    vec3 e = vec3(0.001, 0.0, 0.0);\n    return normalize(vec3(mapScene(p + e.xyy).dist - mapScene(p - e.xyy).dist,\n                          mapScene(p + e.yxy).dist - mapScene(p - e.yxy).dist,\n                          mapScene(p + e.yyx).dist - mapScene(p - e.yyx).dist));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n    fragColor = vec4(0.0, 0.0, 0.0, 1.0);\n\n    float time = 0.5 * iTime;\n    float c = cos(time), s = sin(time);\n    vec3 ro = vec3(-5.0 * c, 1.0, -5.0 * s);\n\n    vec3 f = -normalize(ro);\n    vec3 r = normalize(vec3(-f.z, 0.0, f.x));\n    vec3 u = normalize(cross(r, f));\n    vec3 rd = normalize(f + uv.x * r + uv.y * u);\n\n    vec3 l = -f;\n    l.xz *= mat2(c, s, -s, c);\n\n    float t = 0.0;\n    for (int i=0; i < 100; i++) {\n        vec3 p = ro + rd * t;\n        Surface scene = mapScene(p);\n        if (scene.dist < 0.001) {\n            vec3 n = getNormal(p);\n            fragColor.rgb += scene.ambient;\n\n            float lambertian = max(0.0, dot(n, l));\n            fragColor.rgb += scene.diffuse * lambertian;\n\n            if (lambertian > 0.0) {\n                vec3 r = reflect(l, n);\n                float specAngle = max(0.0, dot(r, rd));\n                fragColor.rgb += scene.specular * max(0.0, pow(specAngle, scene.gloss));\n            }\n\n            break;\n        }\n\n        if (t > 100.0) {\n            break;\n        }\n\n        t += scene.dist;\n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WtVyWV.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[109, 109, 152, 152, 245], [247, 247, 276, 276, 642], [644, 644, 671, 671, 948], [950, 950, 1005, 1005, 2140]]}
{"id": "WtVyWy", "name": " hplus 2021", "author": "Alkama", "description": "Livecoded during \"Shader Royale\" @ HogmanayParty demoparty (that happened at new years eve 2021).\n30 more minutes of polish are added.\n\nTribute to the \"hplus / Halcyon\" 64kb intro.\nhttps://www.pouet.net/prod.php?which=115\n", "tags": ["raymarching", "distancefield", "demoscene", "liveshading"], "likes": 4, "viewed": 287, "published": "Public API", "date": "1611691365", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const float pi = acos(-1.0);\n\nfloat t=0.0, g=0.0;\nint mat=0;\n\n#define sat(a) clamp(a,0.,1.)\n#define rep(p,r) (mod(p,(r))-(r)*.5)\nmat2 rot(float a) { float c=cos(a),s=sin(a); return mat2(c,s,-s,c); }\n\nfloat box(vec3 p, vec3 s) {\n    vec3 b=abs(p)-s*.5;\n    return length(max(b,0.0)) + min(0.0, max(max(b.x, b.y), b.z));\n}\n\nvec2 moda(vec2 p, float r) {\n    r = 2.0*pi/r;\n    float a= mod(atan(p.y, p.x), r) - r*0.5;\n    return vec2(cos(a), sin(a)) * length(p);\n}\n\nfloat hash(float a) { return fract(sin(a*2958.9281)*5493.913); }\n\nvec3 tex(vec3 p) {\n    const float s = 0.2;\n    const float s2 = 0.005;\n    const float it = 10.;\n    float c = 0.0;\n    for(float i=1.0; i<it+1.0; i++) {\n        float h = 5.0*hash(i);\n        vec3 v = vec3(fract(     h*i+h*p.x),\n                      fract(0.50*h*i+h*p.y),\n                      fract(0.75*h*i+h*p.z));\n        float l=s-s2*h;\n        float r=s+s2*h;\n    \n        float a = 1.0;\n        a *= smoothstep(l,r,v.x)*smoothstep(l,r,1.0-v.x);\n        a *= smoothstep(l,r,v.y)*smoothstep(l,r,1.0-v.y);\n        a *= smoothstep(l,r,v.z)*smoothstep(l,r,1.0-v.z);\n        c += a/it;\n    }\n    return vec3(sat(c));\n}\n\nfloat city(vec3 p) {\n    p.y+=25.0;\n    float d=10000.0;\n    float s=1.5;\n    float ss=s-0.15;\n    vec2 id=floor(p.xz/s);\n    float den = texture(iChannel0, id*0.001).r;\n    den=pow(den, 2.0)*0.4+.1;\n    float h=pow(10.0*den, 3.0)+sin(t*2.0+id.x*id.y*0.01);\n    p.xz=rep(p.xz,s);\n    d = min(d,box(p, vec3(ss,h,ss)));\n    return d;\n}\n\nfloat hplus(vec3 p) {\n    vec3 pp=p;\n    const float s = .3;\n    p.xz *= rot(.25*pi);\n    p.xz = moda(p.xz, 4.);\n    p -= .1*(tex(pp*.4)-.5);\n    float o = box(p, vec3(2.,.8,2.));\n    o = min(o, box(p-vec3(1.5,0,0), vec3(3,s,s)));\n    o = min(o, box(p-vec3(2.8,0,0), vec3(1.4,.8,1.)));\n    return o;\n}\n\nfloat pawtickles(vec3 p) {\n    vec3 pp = p;\n    pp.xz *= rot(.25*pi);\n    pp.xz = moda(pp.xz, 4.);\n    float o = length(vec3(mod(pp.x+3.0*fract(t*2.0),3.0)-1.5, pp.y, pp.z))-0.05;\n    float a = sin(2.0*sin(t*2.0))*sin(t+pp.x*pp.z*(10.0*fract(t*2.0)));\n    g+=1.0/(0.01+pow(abs(o),2.0)*(10.0+9.7*a));\n    return o;\n}\n\nfloat scene(vec3 p) {\n    float d = 10000.;\n    p.xz *= rot(t*.25);\n    vec3 pp=p;\n    float a = pow(sin(2.0*sin(t*2.0)), 2.0);\n    pp.xz *= rot(a*0.05*sin(3.0*(p.y+t*10.0)));\n    pp.yz *= rot(a*0.05*sin(2.0*(p.x+t*6.0)));\n\n    float o = hplus(pp);\n    if(o<d) { d=o;mat=1; }\n\n    float ptk=pawtickles(p);\n    d = min(d,max(ptk, .1));\n\n    float c = city(p);\n    if(c<d) { d=c;mat=2; }\n\n    return d;\n}\n\nvec3 march(vec3 o, vec3 rd, float tr, float md) {\n    float d=0.0;\n    float ii=0.0;\n    for(float i=0.0; i<100.0; i++) {\n        float h=scene(o+rd*d)*0.8;\n        if(abs(h)<tr) return vec3(d,i,1.0);\n        if(d>md) return vec3(d,i,0.0);\n        d+=h;\n        ii=i;\n    }\n    return vec3(d,ii,0.0);\n}\n\nvec3 normal(vec3 p) {\n    vec2 e=vec2(0.01,0.0);\n    return normalize(scene(p)-vec3(scene(p-e.xyy), scene(p-e.yxy), scene(p-e.yyx)));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = fragCoord/iResolution.xy;\n    uv -= 0.5;\n    uv /= vec2(iResolution.y / iResolution.x, 1.0);\n  \n    t=mod(iTime, 20.0*pi);\n    uv *= 1. - length(uv)*.25;\n    vec3 eye = 4.5*vec3(1.,.6+.4*sin(t),-1.);\n    eye.xz+= 2.*vec2(sin(t), cos(t));\n    vec3 tg = vec3(0);\n    vec3 f=normalize(tg-eye);\n    vec3 s=normalize(cross(vec3(-.25+.5*sin(t),1,0), f));\n    vec3 u=normalize(cross(f, s));\n    vec3 dir=normalize(f*.6+uv.x*s+uv.y*u);\n  \n    vec3 lp = vec3(3);\n    lp.xyz-= 3.*vec3(sin(t), cos(t), cos(t));\n\n    vec3 col = vec3(0);\n    float ddd = 0.0;\n\n    vec3 m = march(eye, dir, .001, 500.);\n    ddd = m.x;\n    if(m.z == 1.0) {\n        vec3 p = eye+dir*m.x;\n        vec3 n=normal(p);\n        vec3 ld=normalize(lp-p);\n        float diff = (abs(dot(n, ld)));\n        float spec = (pow(abs(dot(dir, reflect(ld, n))), 30.0));\n        float fres = sat(pow(max(0.0, 1.0-dot(n, -dir)), 1.0));\n        if(mat == 1) {\n            col += sat(vec3(diff+spec)*fres);\n        }\n        if(mat == 2) {\n          col += 0.005*vec3(spec)*acos(-dir);\n        }\n        col *= pow(m.y/50., 2.);\n    } else {\n        col += smoothstep(0.,.3,dir.y+.07)*acos(-dir);\n    }\n    col += acos(-dir)*g*.01;\n    fragColor.rgb = pow(col, vec3(1./2.2));\n}", "image_inputs": [{"id": "XdXGzr", "previewfilepath": "/media/ap/8979352a182bde7c3c651ba2b2f4e0615de819585cc37b7175bcefbca15a6683.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/8979352a182bde7c3c651ba2b2f4e0615de819585cc37b7175bcefbca15a6683.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WtVyWy.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[129, 129, 148, 148, 198], [200, 200, 227, 227, 320], [322, 322, 350, 350, 460], [462, 462, 483, 483, 526], [528, 528, 546, 546, 1151], [1153, 1153, 1173, 1173, 1486], [1488, 1488, 1509, 1509, 1789], [1791, 1791, 1817, 1817, 2106], [2108, 2108, 2129, 2129, 2510], [2512, 2512, 2561, 2561, 2814], [2816, 2816, 2837, 2837, 2951], [2953, 2953, 3010, 3010, 4247]]}
{"id": "wtVyzt", "name": "frame seeded xoroshiro rng", "author": "naclyyy", "description": "An implementation of xoroshiro64** (http://xoshiro.di.unimi.it/) that generates two uniform unsigned ints at the same time (instead of one in a non-SIMD implementation).", "tags": ["noise", "random", "simd", "hash", "prng", "xoroshiro", "xoroshiro64"], "likes": 2, "viewed": 54, "published": "Public", "date": "1611606440", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// SIMD Implementation of xoroshiro64**\n//\n// next2 generates two uniformly distributed unsigned ints (32 bits),\n// with a 4*32 bits state. The state must be seeded so it is not\n// everywhere zero.\n//\n// Note that using correlated values as seeds (such as pixel coordinates)\n// results in correlated sequences in the generator output. This is why\n// seeds should be hashed before being used for a PRNG.\n//\n// Reference implementation by David Blackman and Sebastiano Vigna:\n//   http://xoshiro.di.unimi.it/\n//   http://xoshiro.di.unimi.it/xoroshiro64starstar.c\n\nuvec2 rotl2(uvec2 x, int k) {\n    return (x << k) | (x >> (32 - k));\n}\n\n// Generates 2 uniform integers, updates the state given as input\nuvec2 next2(inout uvec4 s) {\n    uvec2 s0 = s.xz;\n    uvec2 s1 = s.yw;\n    uvec2 rs = rotl2(s0 * 0x9E3779BBu, 5) * 5u;\n    \n    s1 ^= s0;\n    s.xz = rotl2(s0, 26) ^ s1 ^ (s1 << 9);\n    s.yw = rotl2(s1, 13);\n    \n    return rs;\n}\n\n// Converts a vector of unsigned ints to floats in [0,1]\nvec4 tofloat(uvec4 u) {\n    //Slower, but generates all dyadic rationals of the form k / 2^-24 equally\n    //return vec4(u >> 8) * (1. / float(1u << 24));\n\n    //Faster, but only generates all dyadic rationals of the form k / 2^-23 equally\n    return uintBitsToFloat(0x7Fu << 23 | u >> 9) - 1.;\n}\n\n// Simple coordinate hash\nvoid hash(inout uvec4 x) {\n    x = ((x >> 16) ^ x) * 0x45d9f3bu;\n    x = ((x >> 16) ^ x) * 0x45d9f3bu;\n    x = (x >> 16) ^ x;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Seed the generator: this requires setting 4 uints\n    //  int pixel coords\n    uvec4 s = uvec4(fragCoord, 0, 0);\n    //  Enumerate all pixels in row-major order\n    s.x = 4u * (s.y * uint(iResolution.x) + s.x);\n    s.yzw = s.x + uvec3(1, 2, 3);\n    //  Hash coordinates used in the state\n    //  This is what decorrelates the different parts of the state\n    hash(s);\n    \n    s += uvec4(iFrame, iFrame + 1, iFrame + 2, iFrame + 3);\n    \n    hash(s);\n\n    // Generate random numbers, output as float\n    fragColor = tofloat(uvec4(next2(s),next2(s)));\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtVyzt.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 562, 591, 591, 632], [634, 700, 728, 728, 928], [930, 987, 1010, 1226, 1283], [1285, 1311, 1337, 1337, 1438], [1440, 1440, 1497, 1579, 2057]]}
{"id": "WtycDc", "name": "Dancing Spheres in mirror box", "author": "ma38su", "description": "Path Tracing in mirror box", "tags": ["pathtracing"], "likes": 1, "viewed": 39, "published": "Public", "date": "1611851754", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const float PI = 3.14159265;\n\nconst int LEN_SPHERES = 10;\nconst int LEN_RECTS = 5;\n\nconst int NS = 4;\nconst int ITER = 12;\n\nconst float fov = 1.0;\nconst float EPS = 0.00001;\nconst float INF = 100000.0;\n\nconst float aperture = 0.00;\nconst float sense = 10.0;\n\nconst int LAMBERTIAN = 0;\nconst int METAL = 1;\nconst int DIELECTRIC = 2;\n\nconst int TEX_COLOR = 0;\nconst int TEX_CHECK2 = 1;\nconst int TEX_CHECK3 = 2;\nconst int TEX_BACKBUF = 3;\n\nstruct Hit {\n  vec3 rp;\n  vec3 nv;\n  vec2 uv;\n  int index;\n};\n\nstruct Sphere {\n  vec3 center;\n  float radius;\n};\n\nconst int XY = 0;\nconst int YZ = 1;\nconst int XZ = 2;\n\nstruct Rect {\n  vec3 center;\n  vec2 size;\n  int axis;\n};\n\nstruct Material {\n  int type;\n  int texture;\n  \n  vec3 albedo;\n  vec3 emit;\n};\n\nconst uint K = 0x456789abU;\nconst float uint_range = 1. / float(0xFFFFFFFFU);\n\nvoid xorshift(inout uint seed) {\n  seed ^= seed << 13;\n  seed ^= seed >> 17;\n  seed ^= seed << 5;\n}\n\nfloat next_float(inout uint seed) {\n  xorshift(seed);\n  return float(seed - 1U) * uint_range;\n}\n\nfloat atan2(float y, float x){\n  return x == 0.0 ? sign(y) * PI/2.0 : atan(y, x);\n}\n\nvec3 texture_check(vec2 uv, vec3 color) {\n  if (sin(uv.x * 8.0 * PI) * sin(uv.y * 8.0 * PI) > 0.0) {\n    return vec3(1.0);\n  } else {\n    return color;\n  }\n}\n\nvec3 texture_check(vec3 uv) {\n  if (sin(uv.x * 4.0 * PI) * sin(uv.y * 2.0 * PI) * sin(uv.z * 4.0 * PI) > 0.0) {\n    return vec3(1.0);\n  } else {\n    return vec3(0.1);\n  }\n}\n\nvec2 random_in_disk(inout uint seed) {\n  float r1 = next_float(seed);\n  float r2 = next_float(seed);\n\n  float r = sqrt(r1);\n  float theta = 2.0 * PI * r2;\n  float x = r * cos(theta);\n  float y = r * sin(theta);\n  return vec2(x, y);\n}\n\nvec3 random_in_sphere(inout uint seed) {\n  vec3 v;\n  for (int i = 0; i < 1024; ++i) {\n    v.x = next_float(seed) - 0.5;\n    v.y = next_float(seed) - 0.5;\n    v.z = next_float(seed) - 0.5;\n    if (length(v) < 0.5) return v * 2.0;\n  }\n  return normalize(v);\n}\n\nvec3 random_unit_vector(inout uint seed) {\n  return normalize(random_in_sphere(seed));\n}\n\nvec3 background(vec3 rd) {\n  return vec3(0.2);\n}\n\nfloat hit_sphere(vec3 ro, vec3 rd, vec3 center, float radius) {\n  vec3 oc = ro - center;\n  float a = dot(rd, rd);\n  float b = 2.0 * dot(oc, rd);\n  float c = dot(oc, oc) - radius * radius;\n  float discriminant = b * b - 4.0 * a * c;\n  if (discriminant < 0.0) {\n    return -1.0;\n  }\n  return (-b - sqrt(discriminant)) / (2.0 * a);\n}\n\nbool hit_xy_rect(vec3 ro, vec3 rd, vec3 center, vec2 size, float tMin, float tMax, out float t, out vec3 rp, out vec2 uv) {\n  float k = center.z;\n  t = (k - ro.z) / rd.z;\n  if (t < tMin || t > tMax) {\n    return false;\n  }\n  \n  vec2 min_p = center.xy - size;\n  vec2 max_p = center.xy + size;\n\n  vec3 p = ro + t * rd;\n  if (p.x < min_p.x || p.x > max_p.x\n    || p.y < min_p.y || p.y > max_p.y) {\n    return false;\n  }\n\n  rp = p;\n  uv = (p.xy - min_p) / (max_p - min_p);\n  return true;\n}\n\nbool hit_yz_rect(vec3 ro, vec3 rd, vec3 center, vec2 size, float tMin, float tMax, out float t, out vec3 rp, out vec2 uv) {\n  float k = center.x;\n  t = (k - ro.x) / rd.x;\n  if (t < tMin || t > tMax) {\n    return false;\n  }\n  \n  vec2 min_p = center.zy - size;\n  vec2 max_p = center.zy + size;\n\n  vec3 p = ro + t * rd;\n  if (p.z < min_p.x || p.z > max_p.x\n    || p.y < min_p.y || p.y > max_p.y) {\n    return false;\n  }\n\n  rp = p;\n  uv = (p.zy - min_p) / (max_p - min_p);\n  return true;\n}\n\nbool hit_xz_rect(vec3 ro, vec3 rd, vec3 center, vec2 size, float tMin, float tMax, out float t, out vec3 rp, out vec2 uv) {\n  float k = center.y;\n  t = (k - ro.y) / rd.y;\n  if (t < tMin || t > tMax) {\n    return false;\n  }\n  \n  vec2 min_p = center.xz - size;\n  vec2 max_p = center.xz + size;\n\n  vec3 p = ro + t * rd;\n  if (p.x < min_p.x || p.x > max_p.x\n    || p.z < min_p.y || p.z > max_p.y) {\n    return false;\n  }\n\n  rp = p;\n  uv = (p.xz - min_p) / (max_p - min_p);\n  return true;\n}\n\nvec2 get_sphere_uv(vec3 p) {\n  float phi = atan2(p.z, p.x);\n  float theta = asin(p.y);\n  float u = 1.0 - (phi + PI) / (2.0 * PI);\n  float v = theta / PI + 0.5;\n  return vec2(u,v);\n}\n\nbool raytracing(vec3 ro, vec3 rd, in Sphere spheres[LEN_SPHERES], in Rect rects[LEN_RECTS], out Hit hit) {\n  float t_min = EPS;\n  float t_max = INF;\n  Sphere sph;\n  bool hit_flag = false;\n  vec3 nv;\n  vec3 rp;\n  vec2 uv;\n  \n  int geo_idx = 0;\n  \n  float t;\n\n  for (int i = 0; i < LEN_SPHERES; i++) {\n    Sphere sphere = spheres[i];\n    float t = hit_sphere(ro, rd, sphere.center, sphere.radius);\n    if (t >= t_min && t < t_max) {\n      rp = ro + t * rd;\n      nv = (rp - sphere.center) / sphere.radius;\n      t_max = t;\n      uv = get_sphere_uv((rp - sphere.center) / sphere.radius);\n      geo_idx = i;\n      hit_flag = true;\n    }\n  }\n  for (int i = 0; i < LEN_RECTS; ++i) {\n    Rect rect = rects[i];\n    if (rect.axis == XY) {\n      if (hit_xy_rect(ro, rd, rect.center, rect.size, t_min, t_max, t, rp, uv)) {\n        nv = vec3(0., 0., 1.0);\n        geo_idx = LEN_SPHERES + i;\n        hit_flag = true;\n        t_max = t;\n      }\n    } else if (rect.axis == YZ) {\n      if (hit_yz_rect(ro, rd, rect.center, rect.size, t_min, t_max, t, rp, uv)) {\n        nv = vec3(1.0, 0., 0.);\n        geo_idx = LEN_SPHERES + i;\n        hit_flag = true;\n        t_max = t;\n      }\n    } else if (rect.axis == XZ) {\n      if (hit_xz_rect(ro, rd, rect.center, rect.size, t_min, t_max, t, rp, uv)) {\n        nv = vec3(0.0, -1.0, 0.);\n        geo_idx = LEN_SPHERES + i;\n        hit_flag = true;\n        t_max = t;\n      }\n    }\n  }\n  if (!hit_flag) return false;\n\n  hit = Hit(rp, nv, uv, geo_idx);\n  return true;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n\n  vec2 r = iResolution.xy;\n  vec2 uv = gl_FragCoord.xy/r;\n\n  vec3 black = vec3(0.);\n  vec3 white = vec3(1.);\n  Sphere spheres[LEN_SPHERES];\n  Rect rects[LEN_RECTS];\n  Material materials[LEN_SPHERES + LEN_RECTS];\n\n  {\n    float rotation_speed = 0.5;\n    int i = 0;\n    uint j = 11U;\n    float r, l, phi;\n    float phiStep = 2.0 * PI / float(LEN_SPHERES - 1);\n\n    phi = iTime * rotation_speed;\n    l = 0.0;\n\n    r = 1000.;\n    spheres[i] = Sphere(vec3(0., -r, 0.), r);\n    materials[i] = Material(METAL, TEX_CHECK3, vec3(0.7, 0.7, 0.4), black);\n    i++;\n\n    l = next_float(j) * 0.5 + 1.0;\n    r = 0.1 + next_float(j) * 0.2;\n    spheres[i] = Sphere(vec3(l*cos(phi), r, l*sin(phi)), r);\n    materials[i] = Material(METAL, TEX_CHECK2, vec3(0., .0, .9), black);\n    phi += phiStep;\n    i++;\n\n    l = next_float(j) + 1.0;\n    r = 0.1 + next_float(j) * 0.2;\n    spheres[i] = Sphere(vec3(l*cos(phi), r, l*sin(phi)), r);\n    materials[i] = Material(LAMBERTIAN, TEX_COLOR, vec3(0.9, 0.9, 0.9), black);\n    phi += phiStep;\n    i++;\n\n    l = next_float(j) * 0.5 + 1.0;\n    r = 0.1 + next_float(j) * 0.2;\n    spheres[i] = Sphere(vec3(l*cos(phi), r, l*sin(phi)), r);\n    materials[i] = Material(LAMBERTIAN, TEX_COLOR, vec3(0.8, 0.3, 0.3), black);\n    phi += phiStep;\n    i++;\n\n    l = next_float(j) + 1.0;\n    r = 0.1 + next_float(j) * 0.1;\n    spheres[i] = Sphere(vec3(l*cos(phi), r, l*sin(phi)), r);\n    materials[i] = Material(METAL, TEX_COLOR, vec3(0.9, .9, .9), black);\n    phi += phiStep;\n    i++;\n\n    l = next_float(j) * 0.5 + 1.0;\n    r = 0.1 + next_float(j) * 0.1;\n    spheres[i] = Sphere(vec3(l*cos(phi), r, l*sin(phi)), r);\n    materials[i] = Material(LAMBERTIAN, TEX_COLOR, vec3(.9, .1, .0), black);\n    phi += phiStep;\n    i++;\n\n    l = next_float(j) * 0.5 + 1.0;\n    r = 0.1 + next_float(j) * 0.1;\n    spheres[i] = Sphere(vec3(l*cos(phi), r, l*sin(phi)), r);\n    materials[i] = Material(METAL, TEX_COLOR, white * 0.9, black);\n    phi += phiStep;\n    i++;\n\n    l = next_float(j) * 0.5 + 1.0;\n    r = 0.1 + next_float(j) * 0.1;\n    spheres[i] = Sphere(vec3(l*cos(phi), r, l*sin(phi)), r);\n    materials[i] = Material(METAL, TEX_COLOR, vec3(0.8, 0.6, 0.2), black);\n    phi += phiStep;\n    i++;\n\n    l = next_float(j) * 0.5 + 1.0;\n    r = 0.1 + next_float(j) * 0.1;\n    spheres[i] = Sphere(vec3(l*cos(phi), r, l*sin(phi)), r);\n    materials[i] = Material(LAMBERTIAN, TEX_COLOR, vec3(0., .9, .1), black);\n    phi += phiStep;\n    i++;\n\n    l = next_float(j) * 0.5 + 1.0;\n    r = 0.1 + next_float(j) * 0.1;\n    spheres[i] = Sphere(vec3(l*cos(phi), r, l*sin(phi)), r);\n    materials[i] = Material(LAMBERTIAN, TEX_COLOR, vec3(0.9, 0.0, 0.9), black);\n    phi += phiStep;\n    i++;\n\n    float w = 1.6;\n    float h = 0.4;\n    rects[i - LEN_SPHERES] = Rect(vec3(0., h, 1.6), vec2(w, h), XY);\n    materials[i] = Material(METAL, TEX_COLOR, vec3(1.0), black);\n    i++;\n    \n    rects[i - LEN_SPHERES] = Rect(vec3(0., h, -1.6), vec2(w, h), XY);\n    materials[i] = Material(METAL, TEX_COLOR, vec3(1.0), black);\n    i++;\n\n    rects[i - LEN_SPHERES] = Rect(vec3(1.6, h, 0.), vec2(w, h), YZ);\n    materials[i] = Material(METAL, TEX_COLOR, vec3(1.0), black);\n    i++;\n\n    rects[i - LEN_SPHERES] = Rect(vec3(-1.6, h, 0.), vec2(w, h), YZ);\n    materials[i] = Material(METAL, TEX_COLOR, vec3(1.0), black);\n    i++;\n\n    rects[i - LEN_SPHERES] = Rect(vec3(-0., h * 2.0, 0.), vec2(w, w), XZ);\n    materials[i] = Material(METAL, TEX_COLOR, vec3(1.0), black);\n    i++;\n  }\n\n  float t = iTime * 0.25;\n    \n  float rate = 2.0;\n  for (int i = 1; i < LEN_SPHERES; i += 3) {\n    float jumpY = spheres[i].radius * (pow(abs(sin((rate * t + 1.) * PI)), 16.0) + 1.0);\n    spheres[i].center.y = jumpY;\n    rate *= 2.0;\n  }\n\n  uint sseed = uint(t + 1.5);\n  for (int i = 0; i < 3; ++i) {\n    int li = 2 + i * 3 + int(next_float(sseed) * 2.0);\n    materials[li].emit = vec3(3.0 * pow(abs(sin(t * PI + PI * 0.5)), 8.0));\n  }\n\n  float r_rate = 1./min(r.x,r.y);\n  vec2 p = (gl_FragCoord.xy*2.-r)*r_rate;\n  vec3 ro0 = vec3(0.0, 0.5, 0.0);\n\n  vec3 ta = vec3(0., 0.5, 2.);\n  \n  float focus_dist = length(ta - ro0);\n  vec3 cdir = normalize(ta - ro0);\n  vec3 side = cross(cdir,vec3(0.,1.,0.));\n  vec3 up = cross(side, cdir);\n\n  vec3 rd0 = normalize(p.x*side+p.y*up+cdir*fov);\n\n  vec3 col = vec3(0.);\n  int n = 0;\n\n  int total_depth = 0;\n\n  uint seed = uint(gl_FragCoord.y * r.x + gl_FragCoord.x);\n\n  vec3 ro;\n  vec3 rd;\n  for (int s = 0; s < NS; ++s) {\n    ro = ro0;\n    rd = rd0;\n\n    vec3 attenuation = vec3(1.);\n    int depth = 0;\n\n    for (int i = 0; i < ITER; ++i) {\n\n      Hit ret;\n      if (!raytracing(ro, rd, spheres, rects, ret)) {\n        col += attenuation * background(rd);\n        n++;\n        break;\n      }\n\n      vec3 rp = ret.rp;\n      Material material = materials[ret.index];\n\n      if (length(material.emit) > 0.1) {\n        col += attenuation * material.emit;\n        n++;\n        break;\n      }\n\n      vec3 albedo;\n      if (material.texture == TEX_CHECK2) {\n        albedo = texture_check(ret.uv, material.albedo);\n      } else if (material.texture == TEX_CHECK3) {\n        albedo = texture_check(rp);\n      } else {\n        albedo = material.albedo;\n      }\n\n      int type = material.type;\n      if (type == LAMBERTIAN) {\n        rd = ret.nv + random_unit_vector(seed);\n      } else {\n        vec3 reflected = reflect(rd, ret.nv);\n        rd = reflected;\n      }\n      \n      rd = normalize(rd);\n      ro = rp;\n      attenuation *= albedo;\n      depth++;\n    }\n    if (depth == 0) break;\n    total_depth += depth;\n  }\n  col = n > 0 ? sqrt(col / float(n)) : vec3(0.05);\n  fragColor = vec4(col, 1.);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WtycDc.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[824, 824, 856, 856, 923], [925, 925, 960, 960, 1020], [1022, 1022, 1052, 1052, 1105], [1107, 1107, 1148, 1148, 1264], [1266, 1266, 1295, 1295, 1438], [1440, 1440, 1478, 1478, 1673], [1675, 1675, 1715, 1715, 1932], [1934, 1934, 1976, 1976, 2022], [2024, 2024, 2050, 2050, 2072], [2074, 2074, 2137, 2137, 2404], [2406, 2406, 2529, 2529, 2891], [2893, 2893, 3016, 3016, 3378], [3380, 3380, 3503, 3503, 3865], [3867, 3867, 3895, 3895, 4048], [4050, 4050, 4156, 4156, 5545], [5547, 5547, 5602, 5602, 11181]]}
{"id": "wtycDh", "name": "dissolving cubes", "author": "YitingLiu", "description": "playing around with the numbers and time with matrices. ", "tags": ["time", "cube", "zoom", "sin", "color", "rotate", "cos", "square", "smoothstep", "matrix", "fract", "dot", "abs"], "likes": 0, "viewed": 161, "published": "Public API", "date": "1610910299", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n\n#define PI 3.14159265358979323846\n\nvec2 rotate2D(vec2 _st, float _angle){\n    _st -= 0.5;\n    _st =  mat2(cos(_angle),-sin(_angle),\n                sin(_angle),cos(_angle)) * _st;\n    _st += 0.5;\n    return _st;\n}\n\nvec2 tile(vec2 _st, float _zoom){\n    _st *= _zoom;\n    return fract(_st);\n}\n\nfloat box(vec2 _st, vec2 _size, float i, float _smoothEdges){\n    _size = vec2(i)-_size*i;\n    vec2 aa = vec2(_smoothEdges*0.5);\n    vec2 uv = smoothstep(_size,_size+aa,_st);\n    uv *= smoothstep(_size,_size+aa,vec2(1.0)-_st);\n    return uv.x*uv.y;\n}\n\nfloat random (vec2 st) {\n    return fract(sin(dot(st.xy,\n                         vec2(12.9898,78.233)))*\n        43758.913);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{    vec2 st = fragCoord.xy/iResolution.xy;\n    vec3 color = vec3(abs(cos(iTime)),sin(iTime),abs(sin(iTime)));\n\n    // Divide the space in 4\n    st = tile(st,4.);\n\n    // Use a matrix to rotate the space 45 degrees\n    st = rotate2D(st,PI*fract(iTime));\n\n    // Draw a square\n    color += vec3(box(st,vec2(0.8),sin(iTime),1.0-abs(cos(iTime))));\n    color *= vec3(st,abs(cos(iTime)));\n    color /= vec3(st,abs(sin(iTime)));\n\n    fragColor = vec4(color,1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtycDh.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[37, 37, 75, 75, 215], [217, 217, 250, 250, 293], [295, 295, 356, 356, 545], [547, 547, 571, 571, 674], [676, 676, 733, 733, 1190]]}
{"id": "WtycDz", "name": "Columns of Atlantis", "author": "xavierseb", "description": "Another interesting find, a fantasy.\nUse mouse click to move a roound. \nThanks again to the unknown OP who did this-> http://glslsandbox.com/e#70315.0", "tags": ["3d", "geometric"], "likes": 1, "viewed": 165, "published": "Public API", "date": "1610766252", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// explore the submerged columns, ruins of atlantis derived from \n#define rot(a) mat2(cos(a), sin(a), -sin(a), cos(a))\n#define PI  3.14159\n\nfloat map(vec3 p, mat2 m, mat2 n) {\n\tfloat k;\n\tp.xy *= m;\n\tp.yz *= n;\n\tfor (int i = 0; i < 9; i++) {\n\t\tk = length(p.xy);\n\t\tp.x = k * (mod(atan(p.y, p.x), PI/4.) - PI/8.);\t\t\t\t\n\t\tp.y = k - 2.759;\t\t\n\t\tk = length(p.yz);\n\t\tp.y = k * (mod(atan(p.z, p.y), PI/9.5) - PI/19.);\n\t\tp.z = k - 10.0;\n\t}\n\t\n\treturn dot(abs(p), normalize(vec3(-3.9,5,1.2))) - .886 ;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 mouse=iMouse.xy/iResolution.xy;\n\tvec2 uv = (gl_FragCoord.xy - 0.5 * iResolution.xy) / iResolution.y;\n\tvec3 rd = normalize(vec3(uv, 1));\n\tfloat v=-8.*mod(iTime/266.,PI*2.), u=mouse.x;\n\tvec3 p = vec3(0, 10.4+mouse.y*3., -6.);\n\tmat2 m = rot(u), n=rot(v);\n\tfragColor = vec4(0,0,.07,1);\n\t\n\tfor (int i = 1; i < 60; i++) {\n\t\tfloat d = map(p, m, n);\t\t\t\n\t\tp += rd * d;\n\t\tif (d < 0.001) {\n\t\t\tfragColor = vec4( 8,10,4.,1)/float(i);\t\t\t\n\t\t\tbreak;\n\t\t}\n\t}\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WtycDz.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 140, 175, 175, 490], [492, 492, 549, 549, 1001]]}
{"id": "wtycRm", "name": "Value Noise vs Gradient Noise", "author": "tomoe", "description": "Values are corresponding to H in HSV color (an outlier value is closed to red). \nLeft: Value noise (up:3D, down: 2D)\nRight: Gradient noise (up:3D, down: 2D)", "tags": ["bd202101"], "likes": 1, "viewed": 54, "published": "Public", "date": "1610684107", "time_retrieved": "2021-10-01T00:00:00", "image_code": "uvec3 k = uvec3(0x456789abu, 0x6789ab45u, 0x89ab4567u);\nconst uint max32 = 0xffffffffu;\nvec3 hsv2rgb(in vec3 c) {\n    vec3 rgb = clamp(abs(mod(c.x * 6.0 + vec3(0.0, 4.0, 2.0), 6.0) - 3.0) - 1.0, 0.0, 1.0);\n    return c.z * mix(vec3(1.0), rgb, c.y);\n}\nuint hash11u(uint n) {\n    n ^= (n << 24);\n    n ^= (n >> 1);\n    n ^= (n << 1);\n    return n * k.x;\n}\nuvec2 hash22u(uvec2 n) {\n    n ^= (n.yx << 24);\n    n ^= (n.yx >> 1);\n    n *= k.xy;\n    n ^= (n.yx << 1);\n    return n * k.xy;\n}\nvec2 hash22(vec2 p) {\n    uvec2 n = uvec2(p);\n    vec2 v = vec2(hash22u(n)) / vec2(max32);\n    return normalize(2.0 * v - vec2(1.0));\n}\nfloat hash21(vec2 p) {\n    uint n = hash11u(uint(p.x)) + uint(p.y);\n    return float(hash11u(n)) / float(max32);\n}\nfloat vnoise21(vec2 p) {\n    vec2 i = floor(p);\n    float v00 = hash21(i);\n    float v01 = hash21(i + vec2(0.0, 1.0));\n    float v10 = hash21(i + vec2(1.0, 0.0));\n    float v11 = hash21(i + vec2(1.0, 1.0));\n    vec2 f = fract(p);\n    f = f * f * f * (10.0 - 15.0 * f + 6.0 * f * f);\n    return mix(mix(v00, v10, f.x), mix(v01, v11, f.x), f.y);\n}\nfloat hash31(vec3 p) {\n    uint n = hash11u(hash11u(uint(p.x)) + uint(p.y)) + uint(p.z);\n    return float(hash11u(n)) / float(max32);\n}\nfloat vnoise31(vec3 p) {\n    vec3 i = floor(p);\n    float v000 = hash31(i);\n    float v001 = hash31(i + vec3(0.0, 0.0, 1.0));\n    float v010 = hash31(i + vec3(0.0, 1.0, 0.0));\n    float v011 = hash31(i + vec3(0.0, 1.0, 1.0));\n    float v100 = hash31(i + vec3(1.0, 0.0, 0.0));\n    float v101 = hash31(i + vec3(1.0, 0.0, 1.0));\n    float v110 = hash31(i + vec3(1.0, 1.0, 0.0));\n    float v111 = hash31(i + vec3(1.0, 1.0, 1.0));\n    vec3 f = fract(p);\n    f = f * f * f * (10.0 - 15.0 * f + 6.0 * f * f);\n    float xy0 = mix(mix(v000, v100, f.x), mix(v010, v110, f.x), f.y);\n    float xy1 = mix(mix(v001, v101, f.x), mix(v011, v111, f.x), f.y);\n    return mix(xy0, xy1, f.z);\n}\nuvec3 hash33u(uvec3 n) {\n    n ^= (n.yzx << 24);\n    n ^= (n.yzx >> 1);\n    n *= k;\n    n ^= (n.yzx << 1);\n    return n * k;\n}\nvec3 hash33(vec3 p) {\n        uvec3 n = uvec3(p);\n        vec3 v = vec3(hash33u(n)) / vec3(max32);\n        return normalize(2.0 * v - vec3(1.0));\n}\nfloat gnoise21(vec2 p) {\n    vec2 i = floor(p);\n    vec2 g00 = hash22(i);\n    vec2 g01 = hash22(i + vec2(0.0, 1.0));\n    vec2 g10 = hash22(i + vec2(1.0, 0.0));\n    vec2 g11 = hash22(i + vec2(1.0, 1.0));\n    vec2 f = fract(p);\n    float v00 = dot(g00, f);\n    float v01 = dot(g01, f - vec2(0.0, 1.0));\n    float v10 = dot(g10, f - vec2(1.0, 0.0));\n    float v11 = dot(g11, f - vec2(1.0, 1.0));\n    f = f * f * f * (10.0 - 15.0 * f + 6.0 * f * f);\n    float v = mix(mix(v00, v10, f.x), mix(v01, v11, f.x), f.y);\n    return 0.5 * v + 0.5;\n}\nfloat gnoise31(vec3 p) {\n    vec3 i= floor(p);\n    vec3 g000 = hash33(i);\n    vec3 g001 = hash33(i + vec3(0.0, 0.0, 1.0));\n    vec3 g010 = hash33(i + vec3(0.0, 1.0, 0.0));\n    vec3 g011 = hash33(i + vec3(0.0, 1.0, 1.0));\n    vec3 g100 = hash33(i + vec3(1.0, 0.0, 0.0));\n    vec3 g101 = hash33(i + vec3(1.0, 0.0, 1.0));\n    vec3 g110 = hash33(i + vec3(1.0, 1.0, 0.0));\n    vec3 g111 = hash33(i + vec3(1.0, 1.0, 1.0));\n    vec3 f = fract(p);\n    float v000 = dot(g000, f);\n    float v001 = dot(g001, f - vec3(0.0, 0.0, 1.0));\n    float v010 = dot(g010, f - vec3(0.0, 1.0, 0.0));\n    float v011 = dot(g011, f - vec3(0.0, 1.0, 1.0));\n    float v100 = dot(g100, f - vec3(1.0, 0.0, 0.0));\n    float v101 = dot(g101, f - vec3(1.0, 0.0, 1.0));\n    float v110 = dot(g110, f - vec3(1.0, 1.0, 0.0));\n    float v111 = dot(g111, f - vec3(1.0, 1.0, 1.0));\n    f = f * f * f * (10.0 - 15.0 * f + 6.0 * f * f);\n    float xy0 = mix(mix(v000, v100, f.x), mix(v010, v110, f.x), f.y);\n    float xy1 = mix(mix(v001, v101, f.x), mix(v011, v111, f.x), f.y);\n    return 0.5 * mix(xy0, xy1, f.z) + 0.5;\n}\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n    vec2 pos = fragCoord.xy/min(iResolution.x, iResolution.y);\n    pos *= 20.;\n    pos += iTime;\n    float v;\n    if (fragCoord.x < 0.5 * iResolution.x){\n        if (fragCoord.y < 0.5 * iResolution.y){\n            v = vnoise21(pos);\n        } else {\n            v = vnoise31(vec3(pos, iTime));\n        }\n    } else{\n        if (fragCoord.y < 0.5 * iResolution.y){\n            v = gnoise21(pos);\n        } else {\n            v = gnoise31(vec3(pos, iTime));\n        }\n    }\n    vec3 col = hsv2rgb(vec3(v, 1.0, 1.0));\n    fragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtycRm.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[88, 88, 113, 113, 250], [251, 251, 273, 273, 353], [354, 354, 378, 378, 483], [484, 484, 505, 505, 619], [620, 620, 642, 642, 734], [735, 735, 759, 759, 1080], [1081, 1081, 1103, 1103, 1216], [1217, 1217, 1241, 1241, 1891], [1892, 1892, 1916, 1916, 2018], [2019, 2019, 2040, 2040, 2166], [2167, 2167, 2191, 2191, 2704], [2705, 2705, 2729, 2729, 3784], [3785, 3785, 3839, 3839, 4388]]}
{"id": "wtycWK", "name": "Flowing Paint", "author": "YitingLiu", "description": "flowing paint with a cellular noise function", "tags": ["fractal", "noise", "simple", "fbm", "perlin", "gradient", "template", "function", "value", "cellular"], "likes": 0, "viewed": 183, "published": "Public API", "date": "1611765936", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// noise functions from youtube https://www.youtube.com/watch?v=ybbJz6C9YYA\n// git code https://github.com/Gonkee/Gonkees-Shaders/blob/master/noise%20textures.shader\n\n// making paint flowing effect with cellular noise function \n\n#define PI 3.141592653\n\n\nvec2 rand2( vec2 p ) {\n    return fract(sin(vec2(dot(p,vec2(127.1,311.7)),dot(p,vec2(269.5,183.3))))*43758.5453);\n}\n\nfloat rand(vec2 coord){\n    coord = mod(coord,10000.);\n    return fract(sin(dot(coord, vec2(12.9898,78.233)))*43758.5453);\n}\n\nmat2 rotate2d(float _angle){\n    return mat2(cos(_angle),-sin(_angle),\n                sin(_angle),cos(_angle));\n}\nmat2 scale(vec2 _scale){\n    return mat2(_scale.x,0.0,\n                0.0,_scale.y);\n}\n\nfloat cellular_noise(vec2 coord){\n   vec2 i = floor(coord);\n    vec2 f = fract(coord);\n    \n    float min_dist=9999.;\n   for(float x = -1.0; x <= 1.0; x++) {\n\t\tfor(float y = -1.0; y <= 1.0; y++) {\n        vec2 node = rand2(i+vec2(x,y))+vec2(x,y);\n        float dist = sqrt((f-node).x*(f-node).x+(f-node).y*(f-node).y);\n        min_dist = min(min_dist,dist);\n       }\n    }\n    return min_dist;\n    \n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n {\n    vec2 st = fragCoord.xy/iResolution.xy;\n    st.x *= iResolution.x/iResolution.y;\n    vec3 color = vec3(.0);\n\n    // Scale\n    st *= 3.;\n\n    float noise;\n    noise = rand(st);\n    noise=cellular_noise(st);\n\n\n    // Tile the space\n    vec2 i_st = floor(st);\n    vec2 f_st = fract(st);\n\n    // Assign a color using the closest point position\n   //  color += dot(f_st,vec2(-0.060,-0.460)*PI/2.*sin(iTime));\n\n    st-=st/2.;\n    st*=rotate2d(noise+PI/cos(iTime*0.005));\n    st*=scale(vec2(rand(st*0.000075)*(atan(fract(iTime/100.)))));\n    st+=st*2.;\n        \n    st*=1.-noise;\n\n   // Add distance field to closest point center\n    color.r =rand(noise*st*0.5)*iTime/100.;\n    color.g =1.-rand(noise*st*0.02)*(abs(cos(iTime/10.)));\n    color.b =0.4-rand(st*noise/sin(iTime));\n\n\n    fragColor = vec4(1.-color,1.0);\n}\n\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtycWK.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[167, 254, 276, 276, 369], [371, 371, 394, 394, 495], [497, 497, 525, 525, 611], [612, 612, 636, 636, 699], [701, 701, 734, 734, 1101], [1102, 1102, 1160, 1160, 1973]]}
{"id": "wtycWz", "name": "pudding", "author": "tono", "description": "sweeeeeeet", "tags": ["pudding"], "likes": 4, "viewed": 47, "published": "Public", "date": "1610792422", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float pi = acos(-1.);\nmat2 rot(float a ){return mat2(cos(a),sin(a),-sin(a),cos(a));}\n\nvec2 pmod(vec2 p, float r) {\n    float a =  atan(p.x, p.y) + pi/r;\n    float n = (pi * 2.) / r;\n    a = floor(a/n)*n;\n    return p*rot(-a);\n}\n\nvec2 map(vec3 p)\n{\n    float plate = length(p / vec3(1.,.3,1.)) - 1.3;\n    plate = max(-plate , length((p +vec3(0.,-0.2,0.) )/ vec3(1.,.3,1.)) - 1.1);\n    float o = plate * .2;\n    \n    float tt = floor(iTime) + pow(fract(iTime) ,1.2);\n    p.x += sin(tt * pi + p.y)/10.;\n    p.xz = pmod(p.xz,12.);\n    p.z = p.z - 0.2;\n    float s = 1.;\n    float w = 1.3;\n    float pud = length(p / vec3(w * p.y + s,1.8,w * p.y +s) ) - .3;\n    pud = max(pud , p.y - .4);\n    pud = max(pud , -p.y- .24);\n    \n    float id = 0.;\n    if(o > pud)\n    {\n        o = pud;\n        id = 1.;\n    }\n    \n    return vec2(o,id);\n}\n\nvec2 march(vec3 cp, vec3 rd)\n{\n    float depth = 0.;\n    for(int i = 0; i < 99; i++)\n    {\n        vec3 rp = cp + rd * depth;\n        vec2 d = map(rp);\n        if(abs(d.x) < 0.001)\n        {\n            return vec2(depth,d.y);\n        }\n        depth += d.x;\n    }\n    return vec2(-depth,0.);\n}\n\nfloat getThick(vec3 cp, vec3 rd)\n{\n    float depth = 0.;\n    for(int i = 0; i < 33 ; i++)\n    {\n        vec3 rp = cp + rd * depth * 0.01;\n        float d = map(rp).x;\n        if(d > 0.)\n        {\n            return depth;\n        }\n        depth += max(abs(d) , 0.001);\n    }\n    return depth;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = (fragCoord.xy * 2.0 - iResolution.xy) / min(iResolution.x, iResolution.y);\n\t\n    vec3 cp = vec3(0.4,1.,-5.);\n    cp.yz *= rot(-pi * 1.1 );\n    vec3 target = vec3(0.,0.,0.);\n    vec3 cd = normalize(target - cp);\n    vec3 cs = normalize(cross(cd,vec3(0.,1.,0.)));\n    vec3 cu = normalize(cross(cd,cs));\n    \n    float fov = 4.5;\n    vec3 rd = normalize(fov * cd + cs * p.x + cu * p.y);\n    vec3 col = vec3(1.,.3,0.);\n    //プリン　極座標\n    vec2 d = march(cp,rd);\n    \n    if(d.x > 0.)\n    {\n        vec3 pos = cp + rd * d.x;\n        vec2 e = vec2(0.,0.01);\n        vec3 N = -normalize(map(pos).x - vec3(map(pos - e.xyy).x,map(pos - e.yxy).x,map(pos - e.yyx).x));\n        vec3 sun = normalize(vec3(2.,4.,8.));\n        sun.xz *= rot(iTime);\n        \n        float shadow = step(march(pos + N * 0.1 ,-sun).x,0.);\n        float rim = (1. - abs(dot(rd,N)) );\n        if(d.y < 1.)\n        {\n            //sara\n            float diff = mix(max(0.,dot(sun,N)),1.,.7 );\n            float sp =   max(0.,dot(-rd , reflect(N,sun)));\n            sp = pow(sp,30.);\n        \tcol = diff * vec3(.7);\n            col += sp * 2.5 * vec3(1.);\n            col += rim;\n        }\n        else if(d.y == 1.)\n        {\n            //pud\n            float diff = mix(max(0.,dot(sun,N)),1.,.8 );\n            float sp =   max(0.,dot(-rd , reflect(N,sun)));\n            sp = pow(sp,13.);\n        \tcol = diff * mix( vec3(.5,.4,.1),vec3(0.), step(pos.y,-.2) );\n            col += sp * vec3(1.);\n            col += vec3(1.) * clamp(map(pos+1.2*rd).x*1.1,.0,1.) * diff;\n            col += rim * vec3(.5,.4,.1);\n        }\n        \n        col += (clamp(map(pos-2.4*rd).x*.8,.0,1.)-.5) * vec3(.5,.4,.1);\n        \n        //col *= shadow;\n        //float dd = 1.-exp(-0.0003 * d.x * d.x * d.x);\n    \t//col = mix(col,vec3(1.,.3,0.), dd);\n    }\n    fragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtycWz.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[22, 22, 41, 41, 84], [86, 86, 114, 114, 227], [229, 229, 247, 247, 831], [833, 833, 863, 863, 1127], [1129, 1129, 1163, 1163, 1424], [1426, 1426, 1483, 1483, 3344]]}
{"id": "WtyczG", "name": "Testing volumetric marching", "author": "darkeclipz", "description": "time to melt my brain again\n\nhttps://www.shadertoy.com/view/MdGSzt", "tags": ["volumetric"], "likes": 5, "viewed": 154, "published": "Public", "date": "1611178208", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// https://www.youtube.com/watch?v=8OrvIQUFptA\n// https://shaderbits.com/blog/creating-volumetric-ray-marcher\n\n\n/*\n\n trying to figure out how volumetric rendering works... wish me luck\n \n just some notes:\n     so if i get it right, to create volumetric cloud like thingies, we need:\n\n     1. Perlin-Worley noise to create a cloud like noise \n     2. Adjust the raymarcher to takes fixed steps when inside the volume.\n     3. Take sample points by checking the density?\n     \n     \n     (not used in implementation)\n     4. Calculate light energy at that point?\n          - Beer's Law\n          - Henyey Greenstein\n          - In-scattering probabilities\n          \n          E : energy\n          d : depth in cloud\n          \n          E = 2e^{-d} * (1 - e^{-2d})      \"Beer's-Powder\"\n          \n          - Powder effect?\n*/\n#define MIN_MARCH_DIST 0.001\n#define MAX_MARCH_DIST 20.\n#define MAX_MARCH_STEPS 100.\n#define MAX_VOLUMETRIC_STEPS 64.\n\n// noise function from another shader, https://www.shadertoy.com/view/MdGSzt\n// copy from https://www.shadertoy.com/view/4l2GzW\nfloat random(float n)\n{\n \treturn fract(cos(n*89.42)*343.42);\n}\nvec3 random(vec3 n)\n{\n \treturn vec3(\n        random(n.x*23.62-300.0+n.y*34.35),\n        random(n.x*45.13+256.0+n.y*38.89),\n        random(n.x*76.13+311.0+n.y*42.15)); \n}\nfloat worley(vec3 n,float s)\n{\n    float dis = 2.0;\n    for(int x = -1;x<=1;x++)\n    {\n        for(int y = -1;y<=1;y++)\n        {\n            for(int z = -1; z <= 1; z++) {\n                vec3 p = floor(n/s)+vec3(x,y,z);\n                float d = length(random(p)+vec3(x,y,z)-fract(n/s));\n                if (dis>d)\n                {\n                    dis = d;   \n                }\n            }\n            \n        }\n    }\n    return 1.0 - dis;\n\t\n}\n\n// copy from https://www.shadertoy.com/view/4sc3z2\n#define MOD3 vec3(.1031,.11369,.13787)\n\nvec3 hash33(vec3 p3)\n{\n\tp3 = fract(p3 * MOD3);\n    p3 += dot(p3, p3.yxz+19.19);\n    return -1.0 + 2.0 * fract(vec3((p3.x + p3.y)*p3.z, (p3.x+p3.z)*p3.y, (p3.y+p3.z)*p3.x));\n}\nfloat perlin_noise(vec3 p)\n{\n    vec3 pi = floor(p);\n    vec3 pf = p - pi;\n    \n    vec3 w = pf * pf * (3.0 - 2.0 * pf);\n    \n    return \tmix(\n        \t\tmix(\n                \tmix(dot(pf - vec3(0, 0, 0), hash33(pi + vec3(0, 0, 0))), \n                        dot(pf - vec3(1, 0, 0), hash33(pi + vec3(1, 0, 0))),\n                       \tw.x),\n                \tmix(dot(pf - vec3(0, 0, 1), hash33(pi + vec3(0, 0, 1))), \n                        dot(pf - vec3(1, 0, 1), hash33(pi + vec3(1, 0, 1))),\n                       \tw.x),\n                \tw.z),\n        \t\tmix(\n                    mix(dot(pf - vec3(0, 1, 0), hash33(pi + vec3(0, 1, 0))), \n                        dot(pf - vec3(1, 1, 0), hash33(pi + vec3(1, 1, 0))),\n                       \tw.x),\n                   \tmix(dot(pf - vec3(0, 1, 1), hash33(pi + vec3(0, 1, 1))), \n                        dot(pf - vec3(1, 1, 1), hash33(pi + vec3(1, 1, 1))),\n                       \tw.x),\n                \tw.z),\n    \t\t\tw.y);\n}\n\n// not so worley anymore\nfloat perlinworley3d(vec3 p) {\n    float noise = perlin_noise(20.*p + iTime) * .8 + .05\n                + perlin_noise(40.*p + iTime) * .5\n                + perlin_noise(70.*p + iTime) * .25\n      //          * worley(12.*p, 1.0);\n      ;\n    //noise += perlin_noise(12.*p) * .5;\n    return noise;\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\n# define BBOX 1\nfloat sdBoundingBox( vec3 p, vec3 b, float e )\n{\n       p = abs(p  )-b;\n  vec3 q = abs(p+e)-e;\n  return min(min(\n      length(max(vec3(p.x,q.y,q.z),0.0))+min(max(p.x,max(q.y,q.z)),0.0),\n      length(max(vec3(q.x,p.y,q.z),0.0))+min(max(q.x,max(p.y,q.z)),0.0)),\n      length(max(vec3(q.x,q.y,p.z),0.0))+min(max(q.x,max(q.y,p.z)),0.0));\n}\n\nint id = 0;\n\nfloat map(vec3 p) {\n    id = 0;\n    float volBox = sdBox(p, vec3(0.27));\n    float bBox = sdBoundingBox(p, vec3(0.27), 0.005);\n    if(bBox < volBox) {\n        id = BBOX;\n    }\n    \n    return min(volBox, bBox);\n}\n\nvec3 normal(in vec3 p) {\n    float eps = MIN_MARCH_DIST;\n    vec2 h = vec2(eps, 0);\n    return normalize(vec3(map(p+h.xyy) - map(p-h.xyy),\n                          map(p+h.yxy) - map(p-h.yxy),\n                          map(p+h.yyx) - map(p-h.yyx)));\n}\n\nmat2 rotate(float a) {\n    float si = sin(a), co = cos(a);\n    return mat2(co, si, -si, co);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-0.5*iResolution.xy)/iResolution.y;\n    vec3 ro = vec3(0,0,-1.);\n    ro.xz *= rotate(iTime/8.);\n    vec3 ta = vec3(0,0,0);\n    vec3 ww = normalize(ta-ro);\n    vec3 uu = normalize(cross(ww, vec3(0,1,0)));\n    vec3 vv = normalize(cross(uu,ww));\n    vec3 rd = normalize(uv.x*uu + uv.y*vv + 1.0*ww);\n    \n    vec3 col = vec3(0,0,0);\n    vec3 p = vec3(0);\n    float t = 0.;\n    float i = 0.;\n    float sampleDensity = 0.;\n    bool inside = false;\n    float StepSize = 1. / MAX_VOLUMETRIC_STEPS;    \n    vec3 C = vec3(0,0,0);\n    vec3 C2 = vec3(0);\n    \n    for(i=0.; i < MAX_MARCH_STEPS; i++) {\n        p = ro + t*rd;\n        float d = map(p);\n        if(inside && d > 0.) {\n            // there is nothing behind the volume atm\n            // so just break when we exit the volume.\n            break;\n        }\n        if(d < MIN_MARCH_DIST) {\n            if(id == BBOX) {\n                break;\n            }\n            if(!inside) {\n                // fix weird plane visuals\n                t += random(dot(p, p) + iTime) * StepSize;\n                p = ro + t*rd;\n            }\n            inside = true;\n            float density = perlinworley3d(p);\n            \n            \n            // method1\n            sampleDensity += clamp(density, 0., 1.) * StepSize;\n            // Cout(v) = Cin(v) * (1 - Opacity(x)) + Color(x) * Opacity(x)\n            C = C * (1. - density * StepSize) + vec3(1,0,0) * density * StepSize;\n            \n            \n            // method2\n            float absorbance = exp(-density * StepSize);\n            C2 += vec3(1,0,0) * (1.-absorbance);\n            \n            \n            t += StepSize;\n        }\n        else {\n            t += d;\n        }\n        if(t > MAX_MARCH_DIST)\n            break;\n    }\n    if(i >= MAX_MARCH_STEPS) {\n        t = MAX_MARCH_DIST;\n    }\n    \n    float strength = 14.;\n    sampleDensity *= strength;\n    C *= strength;\n    \n    if(t < MAX_MARCH_DIST) {\n        if(id == BBOX) {\n            vec3 L = normalize(ro-rd - cross(vec3(0,1,0),rd)*.2);\n            vec3 N = normal(p);            \n            vec3 c = vec3(.7) * clamp(dot(L, N), 0., 1.) + vec3(0.1);\n            col = mix(c, C, sampleDensity);\n        }\n        else col = C2*14.;// C2*14.;\n    }\n    \n    fragColor = vec4(pow(col, 1./vec3(2.2)), 1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WtyczG.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[945, 1073, 1096, 1096, 1135], [1136, 1136, 1157, 1157, 1305], [1306, 1306, 1336, 1336, 1759], [1761, 1852, 1874, 1874, 2026], [2027, 2027, 2055, 2055, 2994], [2996, 3021, 3051, 3051, 3320], [3322, 3322, 3353, 3353, 3440], [3458, 3458, 3506, 3506, 3793], [3808, 3808, 3827, 3827, 4020], [4022, 4022, 4046, 4046, 4274], [4276, 4276, 4298, 4298, 4370], [4372, 4372, 4429, 4429, 6733]]}
{"id": "WtyyDz", "name": "Threshold-Processing", "author": "hayama", "description": "Domain warping noises processed by threshold (Up: Perlin noise base, Down: fBm base)\nL: step function (B&W)\nC: smoothstep function (soft-edge B&W)\nR: ramp function (mask)", "tags": ["bd202101"], "likes": 0, "viewed": 69, "published": "Public", "date": "1610762581", "time_retrieved": "2021-10-01T00:00:00", "image_code": "uvec3 k = uvec3(0x456789abu, 0x6789ab45u, 0x89ab4567u);\nconst uint max32 = 0xffffffffu;\nvec2 fragCoord_;\nvec2[8] gtable2 = vec2[](   //0.92387953 = cos(pi/8), 0.38268343 = cos(pi/8)\n    vec2(0.92387953, 0.38268343),\n    vec2(0.38268343, 0.92387953),\n    vec2(-0.92387953, 0.38268343),\n    vec2(-0.38268343, 0.92387953),\n    vec2(0.92387953, -0.38268343),\n    vec2(0.38268343, -0.92387953),\n    vec2(-0.92387953, -0.38268343),\n    vec2(-0.38268343, -0.92387953)\n);\nuint hash11u(uint n) {\n    n ^= (n << 24);\n    n ^= (n >> 1);\n    n ^= (n << 1);\n    return n * k.x;\n}\nuvec2 hash22u(uvec2 n) {\n    n ^= (n.yx << 24);\n    n ^= (n.yx >> 1);\n    n *= k.xy;\n    n ^= (n.yx << 1);\n    return n * k.xy;\n}\nvec2 hash22(vec2 p) {\n        uint n = hash11u(hash11u(uint(p.x)) + uint(p.y));\n        n = n >> 29;\n        n = n % 8u;\n        return gtable2[n];\n}\nfloat pnoise21(vec2 p) {\n    vec2 f = fract(p);\n    vec2 g00 = hash22(p);\n    vec2 g01 = hash22(p + vec2(0.0, 1.0));\n    vec2 g10 = hash22(p + vec2(1.0, 0.0));\n    vec2 g11 = hash22(p + vec2(1.0, 1.0));\n    float v00 = dot(g00, f);\n    float v01 = dot(g01, f - vec2(0.0, 1.0));\n    float v10 = dot(g10, f - vec2(1.0, 0.0));\n    float v11 = dot(g11, f - vec2(1.0, 1.0));\n    f = f * f * f * (10.0 - 15.0 * f + 6.0 * f * f); \n    float v = mix(mix(v00, v10, f.x), mix(v01, v11, f.x), f.y);\n    return v;\n}\nfloat hash21(vec2 p) {\n    uint n = hash11u(uint(p.x)) + uint(p.y);\n    return float(hash11u(n)) / float(max32);\n}\nfloat vnoise21(vec2 p) {\n    vec2 i = floor(p);\n    float v00 = hash21(i);\n    float v01 = hash21(i + vec2(0.0, 1.0));\n    float v10 = hash21(i + vec2(1.0, 0.0));\n    float v11 = hash21(i + vec2(1.0, 1.0));\n    vec2 f = fract(p);\n    f = f * f * (3.0 -2.0 * f); \n    return mix(mix(v00, v10, f.x), mix(v01, v11, f.x), f.y)-0.5;\n}\nfloat fbm21(vec2 p, float G){\n    float val = 0.0;\n    float amp = 1.0;\n    float freq = 1.0;\n    for (int i = 0; i < 4; i++){\n        val += amp * vnoise21(freq * p);\n        amp *= G;\n        freq *= 2.01;\n    }\n    return val;\n}\nfloat warp21(vec2 p, float G){\n    int n = 3;\n    float val = 0.0;\n    for (int i = 0; i < n; i++){\n        vec2 dir = vec2(sin(G * val), cos(G * val));\n        if (fragCoord_.y < 0.5 * iResolution.y){\n            val = fbm21(p + dir, 0.5);\n        } else{\n            val = pnoise21(p + dir);\n        }\n    }\n    return val;\n}\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n    fragCoord_ = fragCoord;\n    vec2 pos = fragCoord.xy/min(iResolution.x, iResolution.y);\n    pos *= 10.;\n    pos += iTime;\n    float v = warp21(pos, 3.0);\n    if(fragCoord.x < 0.33 * iResolution.x){\n        v = step(0.0, v);  //left\n    } else if (fragCoord.x < 0.66 * iResolution.x){\n        v = smoothstep(-0.2, 0.2, v);   //center\n    } else {\n        v = max(0.0, v) * 2.0;  //right\n    }\n    fragColor = vec4(vec3(v), 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WtyyDz.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[464, 464, 486, 486, 566], [567, 567, 591, 591, 696], [697, 697, 718, 718, 846], [847, 847, 871, 871, 1350], [1351, 1351, 1373, 1373, 1465], [1466, 1466, 1490, 1490, 1795], [1796, 1796, 1825, 1825, 2027], [2028, 2028, 2058, 2058, 2355], [2356, 2356, 2410, 2410, 2843]]}
{"id": "WtyyRc", "name": "起点", "author": "zohar", "description": "这是一个起点", "tags": ["1"], "likes": 0, "viewed": 26, "published": "Public", "date": "1611394215", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec3 light = vec3(1.4,1.1,0.7);\nvec3 light2 = vec3(1.4,0,0.7);\nvec3 light3 = vec3(0,0.5,0.7);\nfloat radius = 2.1;\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // iResolution vec2(800,450)\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    uv =  (-iResolution.xy + 2.0*fragCoord.xy)/iResolution.y;\n    \n    //This is the supposed to be Input \n    float timer= 0.3 + 0.8*abs(sin(iTime));\n    \n    float factor1 = pow(length(uv) / timer * radius, 9.0*timer);\n\n\n\n    if(uv.x>0.)\n    {\n        vec3 col = vec3(0.0);\n        if(factor1 <= 1.0)\n        {\n\t    col = mix(light3,light3, factor1);\n        }\n        else\n        {\n\t    col = mix(light2, col, 0.54*(factor1 - 1.0));\n        }\n        // Output to screen\n        fragColor = vec4(col,0.5);\n    }\n    else\n    {\n        vec3 col = vec3(0.0);\n        if(factor1 <= 1.0)\n        {\n\t    col = mix(light,light, factor1);\n        }\n        else\n        {\n\t    col = mix(light2, col, 0.54*(factor1 - 1.0));\n        }\n        // Output to screen\n        fragColor = vec4(col,0.5);\n    }\n\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WtyyRc.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[114, 114, 171, 254, 1096]]}
{"id": "wtyyRd", "name": "ray_marching_practice_1", "author": "changwenhan", "description": "first try at ray marching!\nfolding space to make infinite objects is just mind blowing\n\ncan't wait to learn more knowledge of ray marching and making more cool stuff!\n\nbased on this tutorial of The Art of Code:\nhttps://www.youtube.com/watch?v=PGtv-dBi2wE", "tags": ["raymarching"], "likes": 2, "viewed": 72, "published": "Public", "date": "1611673858", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define MAX_STEPS 100\n#define MAX_DIST 100.\n#define SURF_DIST .01\n\n#define pi 3.14159265359\n#define twoPi 6.28318530718\n\nfloat rand(vec3 p) {\n    p = fract(p * vec3(321.456, 876.789, 432.976));\n    p += dot(p, p+32.56);\n    return fract(p.x*p.y*p.z);\n}\n\n//from kynd https://thebookofshaders.com/edit.php?log=160414040804\nfloat smoothen(float d1, float d2, float k) {\n    return -log(exp(-k * d1) + exp(-k * d2)) / k;\n}\n\n//from iq https://www.shadertoy.com/view/Xds3zN\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r )\n{\n\tvec3 pa = p-a, ba = b-a;\n\tfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n\treturn length( pa - ba*h ) - r;\n}\n\nfloat GetDist(vec3 p) {\n    vec3 id = floor(p);\n    p = fract(p);\n    \n    float radius = .1;\n    vec4 sp = vec4(.5,.5,.5, radius);\n    float spDist = length(p-sp.xyz) - sp.w;\n    \n    vec4 sp2 = vec4(sin(iTime*2.+rand(id.yzy)*123.3)*.5,.5,.5, .03);\n    vec4 sp3 = vec4(1.+sin(iTime*2.+rand(id.yzy)*123.3)*.5,.5,.5, .03);\n    \n    float spDist2 = length(p-sp2.xyz) - sp2.w;\n    float spDist3 = length(p-sp3.xyz) - sp3.w;\n    \n    float totalDist = smoothen(spDist, min(spDist2, spDist3), 25.);\n    \n    return totalDist;\n    \n    \n    float line1 = sdCapsule( p, vec3(-1.,.5,.5), vec3(1.,.5,.5), .01 );\n    float line2 = sdCapsule( p, vec3(.5,-1.,.5), vec3(.5,1.,.5), .01 );\n    float line3 = sdCapsule( p, vec3(.5,.5,-1.), vec3(.5,.5,1.), .01 );\n    \n    float l = min(line1, min(line2, line3));\n \n    totalDist = smoothen(totalDist, l, 25.);\n    \n    \n    return totalDist;\n}\n\n\nfloat RayMarch(vec3 ro, vec3 rd) {\n    float dO = 0.; //dist from origin\n    \n    for(int i=0; i<MAX_STEPS; i++) {\n        vec3 p = ro + rd * dO; // ray\n        float dS = GetDist(p);\n        dO += dS;\n        \n        if(dO > MAX_DIST || dS < SURF_DIST) break;\n    }\n    \n    return dO;\n}\n\n\nvec3 GetNormal(vec3 p) {\n    float d = GetDist(p);\n    \n    vec2 e = vec2(.01, 0);\n    \n    vec3 n = d - vec3(\n        GetDist(p-e.xyy),\n        GetDist(p-e.yxy),\n        GetDist(p-e.yyx)\n    );\n    \n    return normalize(n);\n}\n\nfloat GetLight(vec3 p, vec3 lO) {\n    vec3 l = normalize(lO-p); //light vector\n    vec3 n = GetNormal(p); //normal vector\n    \n    float dif = clamp(dot(l,n), 0., 1.);\n    \n    //shadow\n    //float distToLight = RayMarch(p+n*SURF_DIST*2., l);\n    //if(distToLight<length(lO-p)) dif *= .5;\n    \n    return dif;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\n    vec3 col = vec3(.0);\n    \n    vec3 ro = vec3(0., .7, 0.); //camera origin\n    vec3 rd = normalize(vec3(uv.x, uv.y, 1.)); //camera direction\n    \n    ro += vec3(.3, .3, 2.1) * iTime * .5;\n\n    //panorama projection for recording 360 video\n    //from starea https://www.shadertoy.com/view/Ms2yDK\n    //vec2 sph = fragCoord.xy / iResolution.xy * vec2(twoPi, pi);\n    //rd = vec3(sin(sph.y) * sin(sph.x), cos(sph.y), sin(sph.y) * cos(sph.x)); \n    \n    float the = iTime * 0.15;\n    mat2 rotate = mat2(cos(the), -sin(the), sin(the), cos(the));\n    \n    rd.xz *= rotate;\n    rd.yx *= rotate;\n \n    float d = RayMarch(ro, rd);\n    \n    vec3 p = ro + rd * d; //ray\n    \n    float dif = GetLight(p, ro);\n    \n    vec3 c1 = vec3(.1,.1,.1) * 4.;\n    vec3 c2 = vec3(.9,.9,.9);\n    \n    col = mix(c1, c2, dif);\n    \n    float far = 30.; \n    col *= smoothstep(far, 0., d); //fade out by distance\n    col = mix(col, vec3(0.161,0.161,0.161), d/far);\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtyyRd.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[121, 121, 141, 141, 252], [254, 321, 366, 366, 418], [420, 468, 520, 520, 634], [636, 636, 659, 659, 1513], [1516, 1516, 1550, 1550, 1805], [1808, 1808, 1832, 1832, 2034], [2036, 2036, 2069, 2069, 2347], [2350, 2350, 2407, 2407, 3445]]}
{"id": "WtyyW3", "name": "Fractal 09_gaz", "author": "gaz", "description": "3d", "tags": ["fractal"], "likes": 11, "viewed": 140, "published": "Public", "date": "1611841883", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define R(a) mat2(cos(a),sin(a),-sin(a),cos(a))\nvoid mainImage(out vec4 O, vec2 C)\n{\n    O=vec4(0);\n    for(float i,g,e;\n        ++i<70.;\n        e<5e-4?O+=.8/i:O\n        )\n    {\n        vec3 r=iResolution,k=vec3(5,2,1),\n        p=g*vec3((C-.5*r.xy)/r.y,1);\n        p.xz*=R(iTime*.2);\n        p.y+=5.5;\n        for(int j=0;++j<8;)\n        {\n            p.xz=abs(p.xz);\n            p.xz=p.z>p.x?p.zx:p.xz;\n            p.z=.9-abs(p.z-.9);\n            p.xy=p.y>p.x?p.yx:p.xy;\n            p.x-=2.3;\n            p.xy=p.y>p.x?p.yx:p.xy;\n            p.y+=.1;\n            p=k+(p-k)*3.2;\n        }\n        g+=e=length(p)/6e3-.001;\n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WtyyW3.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[48, 48, 84, 84, 629]]}
{"id": "wtyyWc", "name": "Wave lines fractal", "author": "rsiqueira", "description": "Animated Julia fractal", "tags": ["fractal", "julia", "mandelbrot"], "likes": 0, "viewed": 63, "published": "Public", "date": "1611862712", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec3 hsl2rgb( in vec3 c ) {\n  vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n  return c.z + c.y * (rgb-0.5)*(1.0-abs(2.0*c.z-1.0));\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n   vec2 uv = fragCoord/iResolution.xy;\n\n\n    float pixel_x = uv.x /6. - 1.2;\n    float pixel_y = uv.y /9. + 0.595;\n\n    float X = pixel_x;\n    float Y = pixel_y;\n    float n = 120.;\n    \n\n\nfloat ok = 0.1;\n\tfor (float k=17.;k>0.;k-=0.25) {\n\n\t\tfloat X_new = X*X - Y*Y + 0.0;\n\t\tfloat Y_new = 2.*X*Y    + 0.7;\n        X = X_new;\n        n=n-1.3;\n        Y = Y_new;\n\n        float cond = (X_new/(Y_new+X*sin(iTime/3.) ));\n\n\t\tif (cond<=8.||cond> 22.) {\n\n        } else {\n\n\n          fragColor = vec4( hsl2rgb( \n                           vec3(.2+k/17. +iTime*0., 0.70, n/119.+sin(k/2.)/3.)\n                      ),1.0);\n          break;\n        }\n\n\n\n\t}\n\n\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtyyWc.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 27, 27, 165], [168, 168, 225, 225, 876]]}
{"id": "WtyyWD", "name": "atan2 approximation", "author": "nebbul", "description": "two ways of doing an atan2 approximation\n\nno clue if this is cheaper or more expensive than the actual atan2() on the GPU - I suppose it should be?\n\natan2_approximation2(x, y) [b] seem to have some artefacts going to the corners of the screen", "tags": ["atan2"], "likes": 4, "viewed": 67, "published": "Public", "date": "1610987280", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// from:\n// https://gist.github.com/volkansalma/2972237\n// source:\n// http://dspguru.com/dsp/tricks/fixed-point-atan2-with-self-normalization/\n\n#define PI_FLOAT     3.14159265f\n#define PIBY2_FLOAT  1.5707963f\n\nfloat atan2_approximation1(float y, float x)\n{\n    //http://pubs.opengroup.org/onlinepubs/009695399/functions/atan2.html\n    //Volkan SALMA\n\n    float ONEQTR_PI = PI_FLOAT / 4.0;\n\tfloat THRQTR_PI = 3.0 * PI_FLOAT / 4.0;\n\tfloat r, angle;\n\tfloat abs_y = abs(y) + 1e-10f;      // kludge to prevent 0/0 condition\n\tif ( x < 0.0f )\n\t{\n\t\tr = (x + abs_y) / (abs_y - x);\n\t\tangle = THRQTR_PI;\n\t}\n\telse\n\t{\n\t\tr = (x - abs_y) / (x + abs_y);\n\t\tangle = ONEQTR_PI;\n\t}\n\tangle += (0.1963f * r * r - 0.9817f) * r;\n\tif ( y < 0.0f )\n\t\treturn( -angle );     // negate if in quad III or IV\n\telse\n\t\treturn( angle );\n\n\n}\n\n// |error| < 0.005\nfloat atan2_approximation2( float y, float x )\n{\n\tif ( x == 0.0f )\n\t{\n\t\tif ( y > 0.0f ) return PIBY2_FLOAT;\n\t\tif ( y == 0.0f ) return 0.0f;\n\t\treturn -PIBY2_FLOAT;\n\t}\n\tfloat atan;\n\tfloat z = y/x;\n\tif ( abs( z ) < 1.0f )\n\t{\n\t\tatan = z/(1.0f + 0.28f*z*z);\n\t\tif ( x < 0.0f )\n\t\t{\n\t\t\tif ( y < 0.0f ) return atan - PI_FLOAT;\n\t\t\treturn atan + PI_FLOAT;\n\t\t}\n\t}\n\telse\n\t{\n\t\tatan = PIBY2_FLOAT - z/(z*z + 0.28f);\n\t\tif ( y < 0.0f ) return atan - PI_FLOAT;\n\t}\n\treturn atan;\n}\n\nfloat remap(float x, float in_min, float in_max, float out_min, float out_max)\n{\n    return out_min + (x - in_min) * (out_max - out_min) / (in_max - in_min);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    float tiling = 13.0;\n    float speed = 0.0 * iTime / (1.0 / tiling);\n\n    float u = uv.x - 0.5;\n    float v = uv.y - 0.5;\n    \n    // atan2_a\n    float atan2_a = atan2_approximation1(u, v);\n    atan2_a = mod(remap(atan2_a, -PI_FLOAT, PI_FLOAT, 0.0, 1.0) * tiling + speed, 1.0);\n    \n    vec3 atan2_a_clr = vec3(atan2_a, atan2_a, atan2_a);\n    \n    // atan2_b\n    float atan2_b = atan2_approximation2(u, v);\n    atan2_b = mod(remap(atan2_b, -PI_FLOAT, PI_FLOAT, 0.0, 1.0) * tiling + speed, 1.0);\n    \n    vec3 atan2_b_clr = vec3(atan2_b, atan2_b, atan2_b);\n    \n    // ground truth atan2\n    float atan2 = atan(u, v);\n    atan2 = mod(remap(atan2, -PI_FLOAT, PI_FLOAT, 0.0, 1.0) * tiling + speed, 1.0);\n    \n    vec3 atan2_clr = vec3(atan2, atan2, atan2);\n\n    float line = (sin(iTime * 2.) + 1.0) / 2.0;\n    // compare approximation a and b\n    if(uv.x < line - 0.001) fragColor = vec4(atan2_a_clr, 1.0);\n    if(uv.x > line + 0.001) fragColor = vec4(atan2_b_clr, 1.0);\n    \n    // compare approximation a and ground truth\n    //if(uv.x < line - 0.001) fragColor = vec4(atan2_a_clr, 1.0);\n    //if(uv.x > line + 0.001) fragColor = vec4(atan2_clr, 1.0);\n    \n    // compare approximation b and ground truth\n    //if(uv.x < line - 0.001) fragColor = vec4(atan2_b_clr, 1.0);\n    //if(uv.x > line + 0.001) fragColor = vec4(atan2_clr, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WtyyWD.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 210, 256, 349, 805], [807, 826, 874, 874, 1287], [1289, 1289, 1369, 1369, 1448], [1450, 1450, 1507, 1557, 2942]]}
{"id": "WtyyWh", "name": "sine wave test", "author": "beherca", "description": "sine wave test", "tags": ["sine"], "likes": 0, "viewed": 47, "published": "Public", "date": "1610867538", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    uv.y -= 1.5; \n    // Time varying pixel color\n    vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n\n    float val = sin((uv.x+iTime/5.)*10.)/5. - uv.y;\n    val =smoothstep(val, 1., 0.99);\n    val =smoothstep(val, 0.1, 1.);\n    col = vec3(val);\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WtyyWh.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[2, 2, 59, 109, 458]]}
{"id": "wtyyWy", "name": "juliabulb", "author": "milez770", "description": "julia fork of mandelbulb", "tags": ["mandelbulb"], "likes": 1, "viewed": 39, "published": "Public", "date": "1611717729", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define ITER 3\n#define MAX_STEPS 100\n#define MAX_DIST 10.\n#define SURF_DIST 0.002\n#define SPEED 10.\n\nfloat dist(vec2 p, vec2 t){\n    float dx = p.x-t.x;\n    float dy = p.y-t.y;\n    return sqrt(dx*dx+dy*dy);\n}\n\n// 3d mandelbulb\nfloat mandel3(in vec3 v, in vec3 c, out vec3 map){\n    vec3 r = v;\n    vec3 rNext = r;\n    float m = dot(v, v);\n    vec4 trap = vec4(abs(r), m);\n    \n    int i = 0;\n    float d = 1.;\n    \n    float n =  9.;\n    \n    for(i=0; i<ITER; i++){\n        float cr = length(r);\n        float nr = pow(cr, n);\n        //*abs(sin(iTime/5.) )\n        float accos = acos(r.z/cr);\n        float actan = atan(r.y/r.x);\n        \n        d = pow(cr, n-1.) *n * d + 1.0;\n        \n        rNext.x = nr*sin(accos*n)*cos(n*actan);\n        rNext.y = nr*sin(accos*n)*sin(n*actan);\n        rNext.z = nr*cos(n*accos);\n        r = c + rNext;\n        \n        trap = min(trap, vec4(abs(r), m));\n        map = vec3(trap.yzw);\n\n        m = dot(r,r);\n        \n        if(m > 256.){\n            break;\n        }\n    }\n    \n    return  .25*log(m) * sqrt(m) / d;\n}\n\nmat2 Rot(float a) {\n    float s = sin(a);\n    float c = cos(a);\n    return mat2(c, -s, s, c);\n}\n\nvec3 R(vec2 uv, vec3 p, vec3 l, float z) {\n    vec3 f = normalize(l-p),\n        r = normalize(cross(vec3(0,1,0), f)),\n        u = cross(f,r),\n        c = p+f*z,\n        i = c + uv.x*r + uv.y*u,\n        d = normalize(i-p);\n    return d; \n}\n\nfloat RayMarch(in vec3 ro, in vec3 rd, out vec3 col, in vec3 c){\n    float dO = 0.;\n    \n    for(int i=0; i<MAX_STEPS; i++){\n        vec3 p = ro+rd*dO;\n        p.xz *= Rot(iTime/SPEED);\n        p.yz *= Rot(iTime/SPEED-2.);\n\n        float mbd = mandel3(abs(p), c, col);\n        float dS = mbd;\n        \n        if(dO > MAX_DIST || dS<SURF_DIST) break;\n        dO += dS;\n    }\n    \n    return dO;\n}\nvec3 GetNormal(in vec3 p, in vec3 c){\n    vec3 col;\n    // my e value made black artifacts\n    // so I took a look at iq's normal epsilone. \n    // don't exactly know how this is calculated.\n    // looks like it is relevant to some screen pixel size calculation..?\n    vec2 e = vec2(1.0,-1.0)*0.5773*0.25*2.0/(iResolution.y*1.5);\n    \n    // getting vector with very small vector\n    vec3 n = vec3(\n        e.xyy*mandel3(p+e.xyy, c, col)+\n        e.yxy*mandel3(p+e.yxy, c, col)+\n        e.yyx*mandel3(p+e.yyx, c, col)+\n        e.xxx*mandel3(p + e.xxx, c, col ) \n    );\n    \n    return normalize(n);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord.xy-.5*iResolution.xy)/(iResolution.y);\n    vec2 m = iMouse.xy/iResolution.xy;\n    vec3 col = vec3(0);\n    \n    vec3 ro = vec3(0,1.3, 1.3);\n    vec3 rd = R(uv, ro, vec3(0,0,0), .7);\n    \n    vec3 c = vec3( 0.9*(cos(iTime/2.)*.5-.5)-.4, 0.8*(cos(iTime/2.)*.5-.5), 0.8*(cos(iTime/2.)*.5 -.5)-.1 );\n    \n    vec3 backgrounduv;\n    \n    col = vec3(.05, .12, .1);\n    float d = RayMarch(ro, rd, backgrounduv, c);\n    col *= 3.-d;\n    col += pow(clamp(backgrounduv.z, 0., .97), 10.)*vec3(.8, .1, .1);\n    \n    //light\n    vec3 lp = vec3(1000, 1, 0);\n    lp.xz *= Rot(iTime/3.);\n    lp.yz *= Rot(iTime/3.);\n    vec3 lr = ro+rd*d;\n    lr.xz *= Rot(iTime/SPEED);\n    lr.yz *= Rot(iTime/SPEED-2.);\n    lr = abs(lr);\n    vec3 l = normalize(lp - lr);\n    vec3 n = GetNormal(lr, c);\n    float shadow = clamp(dot(n, l), 0.2, 1.);\n    shadow *= 1.;\n    col += vec3(0.1); \n    col *= vec3(pow(shadow, 1.));\n    \n    fragColor = vec4(col, 0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtyyWy.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[101, 101, 128, 128, 208], [210, 227, 277, 277, 1058], [1060, 1060, 1079, 1079, 1155], [1157, 1157, 1199, 1199, 1395], [1397, 1397, 1461, 1461, 1793], [1794, 1794, 1831, 1831, 2394], [2396, 2396, 2453, 2453, 3405]]}
{"id": "wtyyz3", "name": "Fake Blue noise (Voronoi-ed)", "author": "Dutracgi", "description": "Interesting...", "tags": ["voronoi", "noise", "blue", "bluenoise", "render"], "likes": 2, "viewed": 202, "published": "Public API", "date": "1611415610", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//2D noise generator & voronoi code -> https://www.youtube.com/watch?v=l-07BXzNdPw\nvec2 n22(vec2 p){\n    vec3 a = fract(p.xyx*vec3(123.34, 234.34, 345.65));\n    a += dot(a, a+34.45);\n    return fract(vec2(a.x*a.y,a.y*a.z));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from -1 to 1)\n    vec2 uv = (2.*fragCoord-iResolution.xy)/iResolution.y;\n    \n    //color\n    float m = 0.;\n    \n     //noise size 1/size\n    float mul = 16.;\n    \n    //local grids\n    vec2 gv = fract(uv*mul)-0.5;\n    //grid ids\n    vec2 id = floor(uv*mul);\n    \n    float MinDist = 100.;\n    vec2 point;\n\n    vec3 col = vec3(0);\n    //Voronoi-ing\n    for(float y = -2.; y<2.; y++){\n        for(float x = -2.; x<2.; x++){\n            vec2 of = vec2(x,y);\n            //random point generation (blue noise like)\n            vec2 p = of+sin(n22(id+of)*iTime)*0.4;\n            float d = length(gv-p);\n            if(d < MinDist){\n               //Cell Distance\n               MinDist = d;\n               //cell_index;\n               point = n22(id+of);\n            }\n        }\n    }\n    \n    //out color\n     if(smoothstep(0.1,0.08,MinDist)>0.0)\n         col = vec3(0);\n     else\n         col = vec3(1,.15,0)+vec3(point.x,point.y,0)*.2;\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtyyz3.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 83, 100, 100, 225], [227, 227, 284, 335, 1318]]}
