{"id": "4ddSzM", "name": "Morphing domain coloring", "author": "MBR", "description": "Blends between checkerboard and lifted domain coloring.  For highlighting different behaviors of quantites.", "tags": ["complex", "domaincoloring"], "likes": 13, "viewed": 262, "published": "Public", "date": "1481676488", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// GOTO FULLSCREEN - click on sub-plot\n\n// HACKED version of this shader: https://www.shadertoy.com/view/Mt2GDV\n//   Created by David Bargo - davidbargo/2015\n//   License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// Morphing between lifted coloring:\n//    https://www.shadertoy.com/view/4s3SRM\n// and showing a checker-pattern.  In between has similar information\n// as the standard coloring, the the unmodifed shader this is a hack of.\n\n// XXXX\n#define R_GRID 1.0\n#define R_GRID_M 0.75\n//#define SUPERSAMPLE\n#define ANIMATE\n\n#define PI (52707180.0/16777216.0)\n\n\n// --------------------------------------------\n// start of https://www.shadertoy.com/view/Mt2GDV\n\n#define E  2.71828182845\n\nvec2 sinz(vec2 c) \n{\n    float a = pow(E, c.y);\n    float b = pow(E,-c.y);\n    return vec2(sin(c.x)*(a + b)*0.5, cos(c.x)*(a - b)*0.5);\n}\n\nvec2 cosz(vec2 c) \n{\n    float a = pow(E, c.y);\n    float b = pow(E,-c.y);\n    return vec2(cos(c.x)*(a + b)*0.5, -sin(c.x)*(a - b)*0.5);\n}\n\nvec2 tanz(vec2 c) \n{\n    float a = pow(E, c.y);\n    float b = pow(E,-c.y);\n    float cosx = cos(c.x);\n    float sinhy = (a - b)*0.5;\n    return vec2(sin(c.x)*cosx, sinhy*(a + b)*0.5)/(cosx*cosx + sinhy*sinhy);\n}\n\nvec2 logz(vec2 c) \n{\n    return vec2(log(sqrt(dot(c, c))), atan(c.y, c.x));\n}\n\nvec2 sqrtz(vec2 c) \n{\n    float n = c.x + sqrt(dot(c, c));\n    return vec2(n, c.y)/sqrt(2.0*n);\n}\n\nvec2 exp2z(vec2 c) \n{\n\treturn vec2(c.x*c.x - c.y*c.y, 2.*c.x*c.y);   \n}\n\nvec2 epowz(vec2 c) \n{\n\treturn vec2(cos(c.y), sin(c.y))*pow(E, c.x);   \n}\n\nvec2 mulz(vec2 c1, vec2 c2)\n{\n    return c1*mat2(c2.x, -c2.y, c2.y, c2.x);\n}\n\nvec2 divz(vec2 n, vec2 d)\n{\n    return n*mat2(d.x, d.y, -d.y, d.x)/dot(d, d);\n}\n\nvec2 invz(vec2 c)\n{\n\treturn vec2(c.x, -c.y)/dot(c, c);\n}\n\nvec2 func(float cellID, vec2 c)\n{\n    vec2 fz = c;\n    if (cellID == 0.)       fz = c;\n    else if (cellID == 1.)  fz = sinz(c);\n   \telse if (cellID == 2.)  fz = sqrtz(divz(logz(vec2(-c.y - 6.0, c.x)), logz(vec2(-c.y + 2.0, c.x))));\n   \telse if (cellID == 3.)  fz = epowz(c);\n   \telse if (cellID == 4.)  fz = tanz(tanz(c));\n   \telse if (cellID == 5.)  fz = tanz(sinz(c));\n   \telse if (cellID == 6.)  fz = sqrtz(vec2(1.0 + c.x, c.y)) + sqrtz(vec2(1.0 - c.x, -c.y));\n   \telse if (cellID == 7.)  fz = divz(tanz(exp2z(c)), c);\n   \telse if (cellID == 8.)  fz = sinz(cosz(sinz(c)));\n   \telse if (cellID == 9.)  fz = invz(vec2(1.0, 0.0) + epowz(vec2(c.y, c.x)));\n   \telse if (cellID == 10.) fz = epowz(invz(sqrtz(-c)));\n   \telse if (cellID == 11.) fz = exp2z(invz(c));\n   \telse if (cellID == 12.) fz = epowz(sinz(epowz(cosz(c))));   \t\n    else if (cellID == 13.) fz = divz(sinz(c), c);\n   \telse if (cellID == 14.) fz = exp2z(c);\n   \telse if (cellID == 15.) fz = divz(sinz(c), cosz(exp2z(c)));\n    else if (cellID == 16.) fz = invz(c + vec2(1.0, 0.0)) + invz(c - vec2(1.0, 0.0));\n    else if (cellID == 17.) fz = logz(c - invz(c));\n   \telse if (cellID == 18.) fz = divz(sqrtz(vec2(c.x + 1.0, c.y)), sqrtz(vec2(c.x - 1.0, c.y)));\n   \telse if (cellID == 19.) fz = invz(vec2(1.0, 0.0) + mulz(c, exp2z(exp2z(c))));\n\n    return fz;   \n}\n\nvec2 animate(vec2 v) \n{\n#if defined(ANIMATE)\n\tfloat s = sin(iTime);\n    float c = cos(iTime);\n#else\n    float s = 0.0;\n    float c = 1.0;\n#endif\n    return v*mat2(c, -s, s, c);\n}\n\nvec2 gridSize = vec2(5.,4.);\n\nvec3 getCell(vec2 s, vec2 h) \n{\n    float cx = floor(h.x*gridSize.x/s.x);\n    float cy = floor(h.y*gridSize.y/s.y);\n    return vec3(cx, cy, (gridSize.y - 1.0 - cy)*gridSize.x + cx);\n}\n\nvec3 getSmallCells(vec2 s, vec2 h)\n{\n    vec3 c = getCell(s, h);\n    vec2 size = s/gridSize;\n    float ratio = size.x/size.y;\n    vec2 uv = PI*((2.*h-size)/size.y - 2.*vec2(c.x*ratio,c.y));    \n    return vec3(c.z, uv);\n}\n\n//--------------------------------------------------------------------\n//  Lifted domain coloring: https://www.shadertoy.com/view/4s3SRM\n//\n\n\n// coloring tweekable constants\n\n// growth indication constant (>=0). larger is less pronounced.\n// \n#define GROW_K  .9  \n\n// grid line scale (radial & concentric)\n#define GRID_K  0.04\n\n// radial grid lines: shown if defined\n#define RADIAL_GRID\n\n// number of radial lines\n#define RADIAL_LINES 12.0\n\n// concentric grid lines: shown if defined\n#define CONCENTRIC_GRID\n\n\n\n//----------------------\n\n// derived constants\n#define GROW_M  (1.0/(GROW_K+1.0))\n#define GRID_IK (1.0/GRID_K)\n#define RL (RADIAL_LINES/(2.0*PI))\n\nvec3 hsv2rgb(vec3 c)\n{\n  const vec4 K = vec4(1.0, 2.0/3.0, 1.0/3.0, 3.0);\n  vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n  return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nfloat grid_step(float t)\n{\n  t = min(t, 1.0-t);\n  return smoothstep(0.0, GRID_K, t);\n}\n\n// lifted domain plot color for point 'c'\nvec3 domainPlot(vec2 c)\n{\n  float d     = dot(c,c);\n  float theta = atan(c.y,c.x);\n  \n  // growth indication\n  float b1 = fract(0.5*log2(d));\n  float b0 = b1+b1;\n  \n  if (b0 >= 1.0) b0 -= 1.0;    // b0 = fract(2*b1) \n    \n  float b = GROW_M*(b0+GROW_K);\n    \n  // concentric grid covers branch-point\n  //if (b1 < 0.5) b = 1.0;    \n    \n  // saturation and value\n  float sat = 1.0;\n  float val = 1.0;\n\n  \n  // rectangular grid\n#if defined(R_GRID)\n  {\n    float x = floor(R_GRID*c.x);\n    float y = floor(R_GRID*c.y);\n    if (mod(x+y,2.0)==1.0)  \n      sat*= sin(iTime);\n      else val *= sin(iTime);\n  }\n#endif\n    \n  // radial and concentric grid lines\n  b   = mix(0.0, b,   grid_step(fract(theta*RL))); \n  //sat = mix(0.0, sat, grid_step(b0));\n  \n  // convert to RGB\n  float hue = theta*(1.0/(2.0*PI));\n  vec3  v   = hsv2rgb(vec3(hue,sat,val))*b;\n    \n   v = mix(vec3(1.0), v, grid_step(b0));\n    \n  return v;\n}\n\n// end: Lifted domain coloring\n//--------------------------------------------------------------------\n\n\n// Lazy..half-hearted supersamping rather than cleaning up the\n// base coloring function. This doesn't improve the quality\n// enough to really be worthwhile.\nvec3 domainColorQSS(vec3 cell)\n{ \n  vec2 z  = animate(func(cell.x, cell.yz));\n  vec2 dx = dFdx(z);\n  vec2 dy = dFdy(z);\n  vec2 dm = max(dx,dy);\n  vec3 c0 = 4.0*domainPlot(z);\n  vec3 c1 = domainPlot(animate(func(cell.x, cell.yz+dm)));\n  vec3 c2 = domainPlot(animate(func(cell.x, cell.yz-dm))); dm.y = -dm.y;\n  vec3 c3 = domainPlot(animate(func(cell.x, cell.yz+dm)));\n  vec3 c4 = domainPlot(animate(func(cell.x, cell.yz-dm)));\n  return (1.0/8.0)*(c0+c1+c2+c3+c4);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 res = iResolution.xy;\n    vec2 coord = fragCoord.xy;\n    \n    vec3 cell = iMouse.z>0.? \n        vec3(getCell(res, iMouse.xy).z, PI*(2.*coord-res)/(res.y)) : \n    \tgetSmallCells(res, coord);\n      \n#if !defined(SUPERSAMPLE)\n    vec2 z = animate(func(cell.x, cell.yz));\n   fragColor = vec4(domainPlot(z),1.0);\n#else\n   fragColor = vec4(domainColorQSS(cell),1.0);\n#endif\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4ddSzM.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[723, 723, 743, 743, 860], [862, 862, 882, 882, 1000], [1002, 1002, 1022, 1022, 1213], [1215, 1215, 1235, 1235, 1292], [1294, 1294, 1315, 1315, 1391], [1393, 1393, 1414, 1414, 1464], [1466, 1466, 1487, 1487, 1538], [1540, 1540, 1569, 1569, 1616], [1618, 1618, 1645, 1645, 1697], [1699, 1699, 1718, 1718, 1755], [1757, 1757, 1790, 1790, 3080], [3082, 3082, 3105, 3105, 3260], [3292, 3292, 3323, 3323, 3475], [3477, 3477, 3513, 3513, 3698], [4358, 4358, 4380, 4380, 4545], [4547, 4547, 4573, 4573, 4633], [4635, 4677, 4702, 4702, 5589], [5695, 5853, 5885, 5885, 6316], [6319, 6319, 6376, 6376, 6755]], "test": "valid"}
{"id": "4l3SRX", "name": "Pixelating A Shader", "author": "TrueBoolean", "description": "Pixelating a scene. This should work with any shader that uses UV.", "tags": ["procedural"], "likes": 4, "viewed": 172, "published": "Public", "date": "1480967269", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 c, vec2 p )\n{\n\tp = (p/iResolution.xy)*2.-1.;\n    \n    #define PIX 16\n    p = floor(p*float(PIX))/float(PIX);\n    \n    float shade=p.y;\n    p/=p.y-1.;\n    p= p*(sin(iTime)+2.) - iTime;\n\tc = vec4( vec3((mod( floor(p.x) + p.y, 2.) < 1.) ? 0. : 1.)-1.*shade, 1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4l3SRX.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 38, 38, 286]], "test": "valid"}
{"id": "4l3SW2", "name": "Mer + rayon", "author": "Mahazis", "description": "aezeaz", "tags": ["eazeza"], "likes": 0, "viewed": 69, "published": "Public", "date": "1481553565", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage(out vec4 color, in vec2 pixCoords)\n{\n    float radius = iResolution.x / 12.0;\n    float waveLevel1 = 100.0;\n    float waveLength1 = 20.0;\n    float waveWidth1 = 15.0;\n    float waveLevel2 = 120.0;\n    float waveLength2 = 15.0;\n    float waveWidth2 = 10.0;\n    \n    float lSunCenterX = 0.5*iResolution.x;\n    float lSunCenterY = 0.7*iResolution.y;\n    \n    float PI = 3.14;\n    float radToDeg = 180.0 / PI;\n    float lTan = sqrt(pow(lSunCenterX - pixCoords.x, 2.0) + pow(lSunCenterY - pixCoords.y, 2.0));\n    float lDeltaX = lSunCenterX - pixCoords.x;\n    float lDeltaY = lSunCenterY - pixCoords.y;\n    float lAngle = atan(lDeltaX, lDeltaY) * radToDeg;\n    float lDeltaRay = 30.0;\n    \n    if (lTan < radius)\n    {\n       \tcolor = vec4(1.0, 1.0, 0.0, 1.0);\n    }\n    else if (pixCoords.y < waveLevel1 + waveLength1 * (cos(iTime * 2.0 + pixCoords.x / waveWidth1)))\n    {\n        color = vec4(0.0, 0.5, 0.8, 1.0);\n    } \n    else if (pixCoords.y < waveLevel2 + waveLength2 * (cos(iTime * 2.0 + pixCoords.x / waveWidth2)))\n    {\n        color = vec4(0.0, 0.1, 0.8, 1.0);\n    } \n    else if ((mod(lAngle,20.0) <= 10.0 ) && (lTan > radius + 20.0) && (mod(lSunCenterX - lTan,25.0) < 15.0))\n    {\n        color = vec4(0.9, 0.9, 0.0, 1.0);\n    }\n    else\n    {\n        color = vec4(0.8, 0.8, 0.9, 1.0);\n    }  \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4l3SW2.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 51, 51, 1318]], "test": "valid"}
{"id": "4l3SWf", "name": "Color Space and Tone Mapping", "author": "acdimalev", "description": "Reverse-engineering 2v_S's PBR_Test to learn how all the pieces fit together.", "tags": ["tonemapping", "colorspace"], "likes": 13, "viewed": 961, "published": "Public", "date": "1481736335", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/*\n* 2v_S's Physically Based Rendering Test\n* https://www.shadertoy.com/view/MlB3DV\n*\n* Modified to visually demonstrate color space conversion and tone mapping.\n*\n* Left: all rendering performed in sRGB space\n*\n* Middle: rendering performed in linear RGB space, converted to sRGB for display\n*\n* Right: tone mapping applied before conversion to sRGB for display\n*/\n\n\n#define NB_LIGHTS 3\n\n// Metals values in linear space\n#define GOLD vec3(1.0, 0.71, 0.29)\n#define COPPER vec3(0.95, 0.64, 0.54)\n#define IRON vec3(0.56, 0.57, 0.58)\n#define ALUMINIUM vec3(0.91, 0.92, 0.92)\n#define SILVER vec3(0.95, 0.93, 0.88)\n\n// https://en.wikipedia.org/wiki/SRGB\nvec3 srgb_to_linear(vec3 srgb) {\n    float a = 0.055;\n    float b = 0.04045;\n    vec3 linear_lo = srgb / 12.92;\n    vec3 linear_hi = pow((srgb + vec3(a)) / (1.0 + a), vec3(2.4));\n    return vec3(\n        srgb.r > b ? linear_hi.r : linear_lo.r,\n        srgb.g > b ? linear_hi.g : linear_lo.g,\n        srgb.b > b ? linear_hi.b : linear_lo.b);\n}\n\n// https://en.wikipedia.org/wiki/SRGB\nvec3 linear_to_srgb(vec3 linear) {\n    float a = 0.055;\n    float b = 0.0031308;\n    vec3 srgb_lo = 12.92 * linear;\n    vec3 srgb_hi = (1.0 + a) * pow(linear, vec3(1.0/2.4)) - vec3(a);\n    return vec3(\n        linear.r > b ? srgb_hi.r : srgb_lo.r,\n        linear.g > b ? srgb_hi.g : srgb_lo.g,\n        linear.b > b ? srgb_hi.b : srgb_lo.b);\n}\n\n// https://twitter.com/jimhejl/status/633777619998130176\nvec3 ToneMapFilmic_Hejl2015(vec3 hdr, float whitePt) {\n    vec4 vh = vec4(hdr, whitePt);\n    vec4 va = 1.425 * vh + 0.05;\n    vec4 vf = (vh * va + 0.004) / (vh * (va + 0.55) + 0.0491) - 0.0821;\n    return vf.rgb / vf.www;\n}\n\nfloat splitFromFragCoord(vec2 fragCoord) {\n    return floor(3.0 * fragCoord.x / iResolution.x);\n}\n\nfloat fPlane( vec3 p, vec4 n )\n{\n  // n must be normalized\n  return dot(p,n.xyz) + n.w;\n}\n\nfloat fSphere( vec3 p, float s )\n{\n    return length(p)-s;\n}\nfloat opS( float d1, float d2 )\n{\n    return max(-d2,d1);\n}\n\nvec2 opU( vec2 d1, vec2 d2 )\n{\n\treturn (d1.x<d2.x) ? d1 : d2;\n}\n\nvec3 opRep( vec3 p, vec3 c )\n{\n    return mod(p,c)-0.5*c;\n}\n// ---- Scene definition\nvec2 fScene(vec3 p) {\n    \n    vec3 pSphere = p/*opRep(p, vec3( 2.0, 0.0, 2.0))*/;\n    \n \tvec2 sphere0 = vec2(fSphere(p, 1.0), 0.5); \t\n    vec2 sphere1 = vec2(fSphere(p+vec3(2.1, 0.0, 2.0), 1.0), 2.5);\n\tvec2 sphere2 = vec2(fSphere(p+vec3(-2.1, 0.0, 2.0), 1.0), 3.5);\n    vec2 sphere3 = vec2(fSphere(p+vec3(2.1, 0.0, -2.0), 1.0), 4.5);\n    vec2 sphere4 = vec2(fSphere(p+vec3(-2.1, 0.0, -2.0), 1.0), 5.5);\n\t\n\n\n    vec2 plane = vec2(fPlane(p, vec4(0, 1, 0, 1.0)), 1.5);\n    \n    return opU(opU(opU(opU(opU(plane, sphere0), sphere1), sphere2), sphere3), sphere4);\n}\n// -----\n\nvec2 castRay( in vec3 ro, in vec3 rd )\n{\n    float tmin = 1.0;\n    float tmax = 100.0;\n    \n    \n\tfloat precis = 0.00001;\n    float t = tmin;\n    float m = -1.0;\n    for( int i=0; i<50; i++ )\n    {\n\t    vec2 res = fScene( ro+rd*t );\n        if( res.x<precis || t>tmax ) break;\n        t += res.x;\n\t    m = res.y;\n    }\n\n    if( t>tmax ) m=-1.0;\n    return vec2( t, m );\n}\n\n\nfloat softshadow( in vec3 ro, in vec3 rd, in float mint, in float tmax )\n{\n\tfloat res = 1.0;\n    float t = mint;\n    for( int i=0; i<16; i++ )\n    {\n\t\tfloat h = fScene( ro + rd*t ).x;\n        res = min( res, 8.0*h/t );\n        t += clamp( h, 0.02, 0.10 );\n        if( h<0.001 || t>tmax ) break;\n    }\n    return clamp( res, 0.0, 1.0 );\n\n}\n\nvec3 calcNormal( in vec3 pos )\n{\n\tvec3 eps = vec3( 0.001, 0.0, 0.0 );\n\tvec3 nor = vec3(\n\t    fScene(pos+eps.xyy).x - fScene(pos-eps.xyy).x,\n\t    fScene(pos+eps.yxy).x - fScene(pos-eps.yxy).x,\n\t    fScene(pos+eps.yyx).x - fScene(pos-eps.yyx).x );\n\treturn normalize(nor);\n}\n\n\nstruct Light {\n \tvec3 pos;\n    vec3 color;\n};\nLight lights[NB_LIGHTS];\n\n\nfloat G1V ( float dotNV, float k ) {\n\treturn 1.0 / (dotNV*(1.0 - k) + k);\n}\n\nvec3 computePBRLighting ( in Light light, in vec3 position, in vec3 N, in vec3 V, in vec3 albedo, in float roughness, in vec3 F0 ) {\n\n\tfloat alpha = roughness*roughness;\n\tvec3 L = normalize(light.pos.xyz - position);\n\tvec3 H = normalize (V + L);\n\n\tfloat dotNL = clamp (dot (N, L), 0.0, 1.0);\n\tfloat dotNV = clamp (dot (N, V), 0.0, 1.0);\n\tfloat dotNH = clamp (dot (N, H), 0.0, 1.0);\n\tfloat dotLH = clamp (dot (L, H), 0.0, 1.0);\n\n\tfloat D, vis;\n\tvec3 F;\n\n\t// NDF : GGX\n\tfloat alphaSqr = alpha*alpha;\n\tfloat pi = 3.1415926535;\n\tfloat denom = dotNH * dotNH *(alphaSqr - 1.0) + 1.0;\n\tD = alphaSqr / (pi * denom * denom);\n\n\t// Fresnel (Schlick)\n\tfloat dotLH5 = pow (1.0 - dotLH, 5.0);\n\tF = F0 + (1.0 - F0)*(dotLH5);\n\n\t// Visibility term (G) : Smith with Schlick's approximation\n\tfloat k = alpha / 2.0;\n\tvis = G1V (dotNL, k) * G1V (dotNV, k);\n\n\tvec3 specular = /*dotNL **/ D * F * vis;\n\n\tvec3 ambient = vec3(.01);\n\n\tfloat invPi = 0.31830988618;\n\tvec3 diffuse = (albedo * invPi);\n\n\n\treturn ambient + (diffuse + specular) * light.color.xyz * dotNL ;\n}\n\nvec3 addPBR( in vec3 position, in vec3 N, in vec3 V, in vec3 baseColor, in float metalMask, in float smoothness, in float reflectance, in float split) {\n\tvec3 color = vec3(0.0);\n\n    float roughness = 1.0 - smoothness*smoothness;\n    vec3 F0 = 0.16*reflectance*reflectance * (1.0-metalMask) + baseColor*metalMask;\n    vec3 albedo;\n    if (split == 0.0) {\n        albedo = linear_to_srgb(baseColor);\n    } else {\n        albedo = baseColor;\n    }\n    \n    float s = 0.0;\n    \n    \n\tfor ( int i = 0; i < NB_LIGHTS; ++i ) {\n\t\tvec3 col = computePBRLighting ( lights[i], position, N, V, albedo, roughness, F0);\n\t\tcolor += col;\t\n        s += softshadow( position, normalize(lights[i].pos.xyz - position), 0.02, 2.5 );\n\t}\n\n\treturn color*s;\n}\n\nvec3 render( in vec3 ro, in vec3 rd, float split )\n{\n    vec3 col = vec3(0.8, 0.9, 1.0)*8.0; // Sky color\n    \n    vec2 res = castRay( ro, rd );\n    float t = res.x;\n    float m = res.y;\n    vec3 p = ro + t*rd;\n    \n    if(m>-0.5) { // Intersection found\n        if( m < 1.0 ) {\n           // float f = mod( floor( 5.0*p.z ) + floor( 5.0*p.x ), 2.0 );\n            vec3 sur = vec3(1.0,1.0,1.0)*smoothstep(-1.0,-0.6,sin(16.0*p.x));\n            col = addPBR( p, calcNormal( p ), -rd, GOLD*sur, sur.x, 0.3+0.6*sur.x, 0.5, split );\n        } \n        else if( m < 2.0 ) {\n            float f = mod( floor( 5.0*p.z ) + floor( 5.0*p.x ), 2.0 );\n            col = addPBR(p, calcNormal( p ), -rd, vec3(0.5), 0.0, 0.3+0.6*f, 0.5, split );\n        }\n        else if( m < 3.0 ) {\n            vec3 sur = vec3(1.0,1.0,1.0)*smoothstep(-1.0,-0.4,sin(18.0*p.x));\n            col = addPBR( p, calcNormal( p ), -rd, COPPER*sur, sur.x, 0.3+0.6*sur.x, 0.5, split );\n        }\n        else if( m < 4.0 ) {\n            vec3 sur = vec3(1.0,1.0,1.0)*smoothstep(-1.0,-0.0995,sin(106.0*p.x))*smoothstep(-1.0,-0.9,sin(47.0*p.z));\n            col = addPBR( p, calcNormal( p ), -rd, vec3(0.2), 1.0-sur.x, 0.9*sur.x, 0.5, split );\n        }\n        else if( m < 5.0 ) {\n            vec3 sur = vec3(1.0)*smoothstep(-1.0,-0.765,sin(24.0*p.x))*smoothstep(-1.0,-0.4,sin(70.9*p.z));\n            col = addPBR( p, calcNormal( p ), -rd, GOLD*(1.0-sur), sur.x, 0.3+0.6*sur.x, 0.5, split );\n        }\n        else if( m < 6.0 ) {\n            vec3 sur = vec3(1.0,1.0,1.0)*smoothstep(-1.0,-0.4,sin(18.0*p.x));\n            col = addPBR( p, calcNormal( p ), -rd, ALUMINIUM*sur, sur.x, 0.3+0.6*sur.x, 0.5, split );\n        }\n    }\n    \n\treturn col;\n}\n\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr )\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float time = 0.25*iTime;\n    \n    lights[0] = Light(vec3(0.0, 5.0, .0), vec3(1.0));   \n\tlights[1] = Light(vec3(12.0*sin(iTime), 8.0, 12.0*cos(iTime)), vec3(1.0));   \t\n    lights[2] = Light(vec3(-12.0*cos(-iTime), 8.0, 12.0*sin(-iTime)), vec3(.05));   \n\n   \n\n\tvec2 q = fragCoord.xy/iResolution.xy;\n    vec2 p = -1.0+2.0*q;\n\tp.x *= iResolution.x/iResolution.y;\n    vec2 mo = iMouse.xy/iResolution.xy;\n\t\t \n\t\n\n\t// camera\t\n\tvec3 ro = vec3( 7.0*sin(time), 3.6 , -7.0*cos(time) );\n\tvec3 ta = vec3( 0.0 );\n\t\n\t// camera-to-world transformation\n    mat3 ca = setCamera( ro, ta, 0.0 );\n    \n    // ray direction\n\tvec3 rd = ca * normalize( vec3(p.xy,2.5) );\n    \n    float split = splitFromFragCoord(fragCoord);\n    \n    // render\t\n    vec3 col = render( ro, rd, split );\n\n    #if 0\n        col = pow( col, vec3(0.4545) );\n        fragColor=vec4( col, 1.0 );\n    #else \n    \tfloat exposure = 0.06 + 0.02*sin(time-3.14);\n        if (split == 0.0) {\n            fragColor = vec4(col * exposure / 0.1, 1.0);\n        }\n        if (split == 1.0) {\n            fragColor = vec4(linear_to_srgb(col * exposure), 1.0);\n        }\n        if (split == 2.0) {\n            fragColor = vec4(linear_to_srgb(ToneMapFilmic_Hejl2015(col * exposure, 1.0)), 1.0);\n        }\n    #endif\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4l3SWf.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[611, 649, 681, 681, 991], [993, 1031, 1065, 1065, 1373], [1375, 1432, 1486, 1486, 1655], [1657, 1657, 1699, 1699, 1754], [1756, 1756, 1788, 1814, 1845], [1847, 1847, 1881, 1881, 1907], [1908, 1908, 1941, 1941, 1967], [1969, 1969, 1999, 1999, 2032], [2034, 2034, 2064, 2064, 2093], [2094, 2119, 2140, 2140, 2680], [2691, 2691, 2731, 2731, 3062], [3065, 3065, 3139, 3139, 3403], [3405, 3405, 3437, 3437, 3676], [3752, 3752, 3788, 3788, 3827], [3829, 3829, 3961, 3961, 4871], [4873, 4873, 5025, 5025, 5607], [5609, 5609, 5661, 5661, 7313], [7315, 7315, 7367, 7367, 7544], [7546, 7546, 7603, 7603, 8862]], "test": "valid"}
{"id": "4l3XDf", "name": "PS2 Force Fields", "author": "VoidChicken", "description": "A Planetside 2 inspired plasma forcefield shader.", "tags": ["2d", "noise", "plasma", "2", "chicken", "ps2", "planetside", "daybreak"], "likes": 2, "viewed": 217, "published": "Public", "date": "1481848666", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define time iTime\n#define resolution iResolution.xy\n#define mouse (iMouse.xy/iResolution.xy)\n#define R(x) (fract(x)<.5?floor(x):ceil(x))\nvec4 logo(vec2 u) {\n\tu-=.5;\n\tu.x*=resolution.x/resolution.y;\n\tvec3 c = vec3(0);\n\tfloat d = length(u);\n\td=sqrt(d);\n\tfloat q = 0.;\n\tfloat v = abs(d-.5);\n\tv=1.-pow(v,1./2.);\n\tfloat k = v*(dot(normalize(u),-vec2(1,-1.2))*(v*v));\n\tc.x+=k;c.y+=k/1.4;\n\tc=max(c,0.);\n\tfloat cu =length(u);\n\tif (cu<.25) {\n\t\tq=1.;\n\t\tc+=vec3(.6, .3,0.)*(.4-pow(cu,3.));\n\t}\n\tfloat x = abs(sin(u.y*23.)/10.-u.x);\n\tif (x<.025&&u.y<.15&&u.y>-.15) {\n\t\tfloat u = x/.025;\n\t\tc=vec3(1.-R(u*u))/1.;\n\t\tq=1.;\n\t}\n\treturn vec4(c-vec3(.2),q);\n}\nfloat rand(vec2 n) { \n    return fract(sin(dot(n, vec2(12.9898, 4.1414))) * 43758.5453);\n}\n \nfloat noise(vec2 p){\n    vec2 ip = floor(p);\n    vec2 u = fract(p);\n    u = u*u*(3.0-2.0*u);\n \n    float res = mix(\n        mix(rand(ip),rand(ip+vec2(1.0,0.0)),u.x),\n        mix(rand(ip+vec2(0.0,1.0)),rand(ip+vec2(1.0,1.0)),u.x),u.y);\n    return res*res;\n}\n \nvoid mainImage( out vec4 fragColor, vec2 fragCoord ) {\n\tfloat t = time;\n\tvec2 oa = vec2(t,.2+t);\n\tvec2 ob = vec2(-t,t*.5);\n\tvec2 uv = ( fragCoord.xy / resolution.xy*5. ) ;\n\tfloat a = noise(uv+oa), b = noise(uv+ob);\n\tfloat c = 1.-pow(abs(b-a),1./5.);\n\tvec4 q =  vec4( c/5., c/1.9, c/1., 0.);\n\tvec4 p =  vec4( c/1.9, c/5., 0., 0.);\n\tvec4 f =  vec4( c/3.9, 0., c/1., 0.);\n\tvec4 o = vec4(0);\n\tif (uv.x<.333*5.) {\n\t\to=vec4(0,.5,.9,0);\n\t}else\n\tif (uv.x<.666*5.) {\n\t\to=vec4(1,0,0,0);\n\t}else\n\tif (uv.x<5.) {\n\t\to=vec4(.5,0,1,0);\n\t}\n\tvec4 clo = q;\n\tif (mouse.x>.333) {\n\t\tclo=p;\n\t\t\n\t}\n\tif (mouse.x>.666) {\n\t\tclo=f;\t\n\t}\n\tif (uv.y<2.5) {\n\t\t\n\t\tif (uv.x<.333*5.) {\n\t\t\tclo=q;\n\t\t}else\n\t\tif (uv.x<.666*5.) {\n\t\t\tclo=p;\n\t\t}else\n\t\tif (uv.x<5.) {\n\t\t\tclo=f;\n\t\t}\t\n\t}\n\tif (uv.y<.1) clo=o;\n\tvec4 lg = logo(vec2(uv.x,uv.y-3.7));\n\tfragColor = clamp(lg,0.,1.)+clo*(1.-lg.w);\n \n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4l3XDf.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[138, 138, 157, 157, 639], [640, 640, 660, 660, 730], [733, 733, 753, 753, 989], [992, 992, 1046, 1046, 1841]], "test": "valid"}
{"id": "4l3XDj", "name": "Mer Soleil de Juillet (Picasso) ", "author": "Rioneto", "description": "Picasso was a great artist, I am his heir.", "tags": ["2d"], "likes": 0, "viewed": 82, "published": "Public", "date": "1481552799", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 color, in vec2 pixCoords )\n{\n    color = vec4(0.0,0.5,1.0,1.0);\n    \t\n    float centerX = iResolution.x / 2.0 + 275.0;\n    float centerY = iResolution.y / 2.0 + 125.0;\n    float radius = iResolution.x / 12.0; \n    \n    float amplitude = 25.0 ;\n    float period = 90.0 ;\n    float phi = 120.0 ;\n    \n    float distance = sqrt(pow(pixCoords.x - centerX, 2.0) + pow(pixCoords.y - centerY, 2.0)) ; \n           \n    if ( distance < radius ) \n    \t{\n     \t\tcolor = vec4(1.0,0.4,0.0,1.0);\n       \t}\n    \n    if ( pixCoords.y < cos ( pixCoords.x / period + iTime) * amplitude + phi )\n    \t{\n     \t\tcolor = vec4(0.0,0.0,0.6,1.0);\n       \t}\n    \t\n     if ( pixCoords.y < cos ( pixCoords.x / period - 2.0 * iTime) * amplitude + phi - 15.0 ) \n    \t{\n     \t\tcolor = vec4(0.0,0.0,0.8,1.0);\n       \t}\n    \n     if ( pixCoords.y < cos ( pixCoords.x / period + 3.0 * iTime) * amplitude + phi - 30.0 ) \n    \t{\n    \t\tcolor = vec4(0.0,0.0,1.0,1.0);\n       \t}\n                           \t\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4l3XDj.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 53, 53, 994]], "test": "valid"}
{"id": "4l3XW2", "name": "Lonely Cloud", "author": "Void_Scroll", "description": "A cloud that expands and retracts over time. What a lovely sight.\nBear in mind that I am a complete Shadertoy rookie, I'm trying my best !", "tags": ["2d", "draft", "experiment", "educational", "hypnotic", "relaxing"], "likes": 3, "viewed": 135, "published": "Public", "date": "1481559842", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Please enjoy\nvoid mainImage( out vec4 color, in vec2 pixCoords )\n{    \n    // We're going to create 6 circles somewhere on the picture !\n    float centerX = iResolution.x / 2.0;\n    float centerY = iResolution.y / 2.0;\n    float cloudHue = (cos(-iTime / 60.0) * 0.85) + 1.2;\n    float skyHue = (cos(-iTime / 60.0) * 0.75) + 0.3;\n    \n    // A bunch of gibberish - it means the circles are discentered.\n    float cloud1CenterX = centerX + iResolution.x / 9.0 + cos(iTime) * 20.0;\n    float cloud1CenterY = centerY + iResolution.y / 8.0;\n    \n    float cloud2CenterX = centerX + iResolution.x / 11.0 + -cos(iTime) * 20.0;\n    float cloud2CenterY = centerY - iResolution.y / 8.0;\n    \n    float cloud3CenterX = centerX - iResolution.x / 9.0;\n    float cloud3CenterY = centerY + iResolution.y / 8.0 + cos(iTime) * 5.0;\n    \n    float cloud4CenterX = centerX - iResolution.x / 11.0;\n    float cloud4CenterY = centerY - iResolution.y / 8.0 + sin(iTime) * 14.0;\n    \n    float cloud5CenterX = centerX - iResolution.x / 4.0 + sin(iTime) * 4.0;\n    float cloud5CenterY = centerY;\n    \n    float cloud6CenterX = centerX + iResolution.x / 4.0;\n    float cloud6CenterY = centerY - sin(iTime) * 6.0;\n    // End of gibberish\n    \n    // Play with this value to get bigger or smaller circles\n    float cloudRadius = iResolution.x / 6.0;\n    \n    float distance1 = cos(-iTime) * 10.0 + sqrt(pow(pixCoords.x - cloud1CenterX, 2.0) + pow(pixCoords.y - cloud1CenterY, 2.0));\n    float distance2 = cos(-iTime) * 10.0 + sqrt(pow(pixCoords.x - cloud2CenterX, 2.0) + pow(pixCoords.y - cloud2CenterY, 2.0));\n    float distance3 = cos(-iTime) * 10.0 + sqrt(pow(pixCoords.x - cloud3CenterX, 2.0) + pow(pixCoords.y - cloud3CenterY, 2.0));\n    float distance4 = cos(-iTime) * 10.0 + sqrt(pow(pixCoords.x - cloud4CenterX, 2.0) + pow(pixCoords.y - cloud4CenterY, 2.0));\n    float distance5 = cos(-iTime) * 10.0 + sqrt(pow(pixCoords.x - cloud5CenterX, 2.0) + pow(pixCoords.y - cloud4CenterY, 2.0));\n    float distance6 = cos(-iTime) * 10.0 + sqrt(pow(pixCoords.x - cloud6CenterX, 2.0) + pow(pixCoords.y - cloud4CenterY, 2.0));\n    \n\tcolor = vec4(0.00, skyHue - 0.15, skyHue - 0.0, 1.00);\n    if (distance1 < cloudRadius)\n    {\n        color = vec4(cloudHue, cloudHue, cloudHue, 1.00);\n    }\n    if (distance2 < cloudRadius)\n    {\n        color = vec4(cloudHue, cloudHue, cloudHue, 1.00);\n    }\n    if (distance3 < cloudRadius)\n    {\n        color = vec4(cloudHue, cloudHue, cloudHue, 1.00);\n    }\n    if (distance4 < cloudRadius)\n    {\n        color = vec4(cloudHue, cloudHue, cloudHue, 1.00);\n    }\n    if (distance5 < cloudRadius)\n    {\n        color = vec4(cloudHue, cloudHue, cloudHue, 1.00);\n    }\n    if (distance6 < cloudRadius)\n    {\n        color = vec4(cloudHue, cloudHue, cloudHue, 1.00);\n    }\n    \n    // I want to add more clouds in the background that move around.\n    // And stars when nighttime comes that lit up behind the Lonely Cloud\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4l3XW2.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 16, 69, 139, 2926]], "test": "valid"}
{"id": "4lcSW2", "name": "see level", "author": "Rod", "description": "ho wouaaaaa", "tags": ["wouaaaa"], "likes": 3, "viewed": 126, "published": "Public", "date": "1481554779", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float hEye = 0.5;\nfloat dScreen = 2.0;\nfloat Pi = 3.1416;\n\nbool sea( float distance, vec2 pixCoords) {\n    \n    float hauteur = hEye* ((distance-dScreen)/distance); \n    float amplitude = 0.10 / distance;\n    float periode = 1.0 / distance;\n    float phase   = 4.0 * iTime / distance;\n    \n    float seaLevel =  hauteur +  amplitude *cos((2.0 * Pi * (pixCoords.x / iResolution.y) / periode) + phase) ;\n    \n    return pixCoords.y < (seaLevel * iResolution.y) ;\n}\n\n\n\nvoid mainImage(out vec4 color, in vec2 pixCoords) {\n    \n    color =  vec4 (1.0, 1.0 , 1.0 , 1.0) ;\n    \n\tfloat centreX = iResolution.x- 50.0; \n    float centreY = iResolution.y- 50.0 ;\n    float radius = iResolution.x/14.0;\n    float distance = sqrt(pow(pixCoords.x-centreX,2.0)+pow(pixCoords.y-centreY,2.0)) ;\n    \n    \n    if (distance < radius ) {\n    \tcolor = vec4(1.0, 1.0, 0.0, 1.0);\n        return;\n    }\n    \n    \n    \n    if (sea(3.0, pixCoords )) {\n        color = vec4(0.0, 0.0 , 1.0 , 1.0 );\n        return;\n    }\n    \n    if (sea(4.0, pixCoords )) {\n        color = vec4(1.0, 0.0 , 1.0 , 1.0 );\n        return;\n    }\n    \n    \n    if (sea(5.0, pixCoords )) {\n        color = vec4(1.0, 0.5 , 1.0 , 1.0 );\n        return;\n    }\n    \n   \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4lcSW2.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[59, 59, 102, 102, 462], [466, 466, 517, 517, 1216]], "test": "valid"}
{"id": "4lcXDl", "name": "Shader night - changes over time", "author": "inantop", "description": "shader night", "tags": ["tutorial"], "likes": 0, "viewed": 85, "published": "Public", "date": "1482021096", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\t//iTime is the float time in seconds, matches the counter next to the pause button below the preview window.\n    //Since it will quickly get out of the 0..1 range, it's often desirable to map it back down somehow.\n    \n    //Periodic\n    float fPeriodic = sin(iTime) * 0.5 + 0.5; //Sin is [-1..1], sin*0.5 + 0.5 is [0..1]\n    float fRepeat = fract(iTime); //Fractional component of iTime, repeats 0..1 each second.\n    \n\tfragColor = vec4(fPeriodic, fRepeat, 0.0, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4lcXDl.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 292, 529]], "test": "valid"}
{"id": "4lcXRs", "name": "glowing piechart", "author": "zproxy", "description": "from https://www.shadertoy.com/view/MldXzf", "tags": ["raymarching"], "likes": 0, "viewed": 105, "published": "Public", "date": "1481059887", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// \"Quake Logo\" by Krzysztof Narkowicz @knarkowicz\n\nconst float MATH_PI = float( 3.14159265359 );\n\nfloat VisibilityTerm( float roughness, float ndotv, float ndotl )\n{\n\tfloat m2\t= roughness * roughness;\n\tfloat visV\t= ndotl * sqrt( ndotv * ( ndotv - ndotv * m2 ) + m2 );\n\tfloat visL\t= ndotv * sqrt( ndotl * ( ndotl - ndotl * m2 ) + m2 );\n\treturn 0.5 / max( visV + visL, 0.00001 );\n}\n\nfloat DistributionTerm( float roughness, float ndoth )\n{\n\tfloat m2\t= roughness * roughness;\n\tfloat d\t\t= ( ndoth * m2 - ndoth ) * ndoth + 1.0;\n\treturn m2 / ( d * d * MATH_PI );\n}\n\nvec3 FresnelTerm( vec3 specularColor, float vdoth )\n{\n\tvec3 fresnel = clamp( 50.0 * specularColor.y, 0.0, 1.0 ) * specularColor + ( 1.0 - specularColor ) * pow( ( 1.0 - vdoth ), 5.0 );\n\treturn fresnel;\n}\n\nvec3 LightSpecular( vec3 normal, vec3 viewDir, vec3 lightDir, vec3 lightColor, float roughness, vec3 specularColor )\n{\n\tvec3 halfVec = normalize( viewDir + lightDir );\n\n\tfloat vdoth = clamp( dot( viewDir,\thalfVec\t ), 0.0, 1.0 );\n\tfloat ndoth\t= clamp( dot( normal,\thalfVec\t ), 0.0, 1.0 );\n\tfloat ndotv = clamp( dot( normal,\tviewDir  ), 0.0, 1.0 );\n\tfloat ndotl = clamp( dot( normal,\tlightDir ), 0.0, 1.0 );\n    \n   \tvec3\tf = FresnelTerm( specularColor, vdoth );\n\tfloat\td = DistributionTerm( roughness, ndoth );\n\tfloat\tv = VisibilityTerm( roughness, ndotv, ndotl );\n    \n    vec3 specular;\n\tspecular = lightColor * f * ( d * v * MATH_PI * ndotl );\n\treturn specular;\n}\n\nfloat Cylinder( vec3 p, float r, float height ) \n{\n\tfloat d = length( p.xz ) - r;\n\td = max( d, abs( p.y ) - height );\n\treturn d;\n}\n\nfloat Sphere( vec3 p, float s )\n{\n\treturn length( p ) - s;\n}\n\nfloat Box( vec3 p, vec3 b )\n{\n\tvec3 d = abs( p ) - b;\n\treturn min( max( d.x, max( d.y, d.z ) ), 0.0 ) + length( max( d, 0.0 ) );\n}\n\nfloat Substract( float a, float b )\n{\n    return max( a, -b );\n}\n\nfloat SubstractRound( float a, float b, float r ) \n{\n\tvec2 u = max( vec2( r + a, r - b ), vec2( 0.0, 0.0 ) );\n\treturn min( -r, max( a, -b ) ) + length( u );\n}\n\nfloat Union( float a, float b )\n{\n    return min( a, b );\n}\n\nfloat UnionRound( float a, float b, float k )\n{\n    float h = clamp( 0.5 + 0.5 * ( b - a ) / k, 0.0, 1.0 );\n    return mix( b, a, h ) - k * h * ( 1.0 - h );\n}\n\nfloat TriPrism( vec3 p, float rot )\n{        \n    vec3 q = abs( p );\n    \n    // can we make it rotating?\n    //float rot = ;\n    \n    return max(\n        // creates some type of symmetry\n        q.y - 0.5, \n        \n       // p.y,\n        \n        //max( \n        \n        // 45 deg line\n        //p.x + p.z * 1.066025   \n        \n        // minus does hflip\n        //p.x * 1.0 + p.z * -1.066025   \n\n        \n        // p.x just moves it up. but also makes it steeper?\n        //p.x * 8.0 + p.z * 0.066025   \n\n        // vertical line yay\n\t\t//p.x * 0.0 + p.z * 1.066025   \n\n        // vertical line\n        p.x * cos(rot) + p.z * sin(rot)   \n\n        \n        //, \n        //    -p.x \n        //) \n        \n        \n        // moves into depth?\n        //- 0.8\n        //+ 0.1\n\n        \n        //- h.x * 0.5 \n    );\n}\n\nfloat Scene( vec3 p, mat3 localToWorld )\n{\n    p = p * localToWorld;\n    \n    \n    \n    float rot1 =   0.1 * iTime;\n    \n    float rot2a = mod(0.0 + 20. * iTime, 360.);\n\n    //float rot2a = (0.0 + 20. * iTime) % 360.;\n\n    float rot2 = 2.0 * MATH_PI / 360.0 * (180.0 - rot2a);\n    float rot22 = 2.0 * MATH_PI / 360.0 * (180.0 - rot2a);\n    \n    \n    \n    if (rot2a > 180.0)\n    \treturn min(TriPrism(  p, rot1 ) ,\n                \n                 TriPrism(  p, rot1-rot22  )\n                \n                );\n    \n    \n    return max(TriPrism(  p, rot1 ) ,\n                \n                 TriPrism(  p, rot1-rot2  )\n                \n                );\n    \n    //return 2.0;\n    \n    // all green\n    return 0.5;\n    \n    // all black\n    return 0.0;\n    \n    \n    // ring\n    float a = Cylinder( p, 0.3, 0.1 );\n    \n    \n    //return Union(ret, a);\n}\n\nvec2 CastRay( in vec3 ro, in vec3 rd, mat3 localToWorld )\n{\n    const float maxd = 5.0;\n    \n\tfloat h = 0.5;\n    float t = 0.0;\n    float steps = 0.0;\n   \n    for ( int i = 0; i < 50; ++i )\n    {\n        if ( h < 0.001 || t > maxd ) \n        {\n            break;\n        }\n        \n\t    h = Scene( ro + rd * t, localToWorld );\n        t += h;\n        steps += 0.03;\n    }\n\n    if ( t > maxd )\n    {\n        t = -1.0;\n    }\n\t\n    return vec2(t, steps);\n}\n\nvec3 SceneNormal( in vec3 pos, mat3 localToWorld )\n{\n\tvec3 eps = vec3( 0.001, 0.0, 0.0 );\n\tvec3 nor = vec3(\n\t    Scene( pos + eps.xyy, localToWorld ) - Scene( pos - eps.xyy, localToWorld ),\n\t    Scene( pos + eps.yxy, localToWorld ) - Scene( pos - eps.yxy, localToWorld ),\n\t    Scene( pos + eps.yyx, localToWorld ) - Scene( pos - eps.yyx, localToWorld ) );\n\treturn normalize( -nor );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 q = fragCoord.xy / iResolution.xy;\n    vec2 p = -1.0 + 2.0 * q;\n\tp.x *= iResolution.x / iResolution.y;\n\n    // have comera zoom in and out to reveal boundaries\n\tvec3 rayOrigin \t= vec3( 0.0, -0.0, -3.5 + sin( iTime * 2.0) );\n    vec3 rayDir \t= normalize( vec3( p.x, p.y, 2.0 ) );\n    \n    float theta = -0.5 * MATH_PI;\n    mat3 rotX = mat3(\n        vec3( cos( theta ), sin( theta ), 0.0 ),\n        vec3( -sin( theta ), cos( theta ), 0.0 ),\n\t\tvec3( 0.0, 0.0, 1.0 )\n        );    \n    \n    vec2 mo = iMouse.xy / iResolution.xy;    \n    //float phi = 0.25 * MATH_PI + 10.0 * mo.x;    \n    //float phi = 0.25 * MATH_PI; \n    \n    // look straight at it. no mouse\n    float phi = 0.5 * MATH_PI;    \n\n    mat3 rotY = mat3(\n        vec3( 1.0, 0.0, 0.0 ),\n        vec3( 0.0, cos( phi ), sin( phi ) ),\n        vec3( 0.0, -sin( phi ), cos( phi ) )\n        );\n    \n    //mat3 localToWorld = rotX * rotY;    \n    mat3 localToWorld = rotX * rotY;    \n\n\n\tvec3 color = texture( iChannel0, q ).yyy * 0.3;\n    \n\tvec2 result = CastRay( rayOrigin, rayDir, localToWorld );\n    \n    if ( result.x > 0.0 )\n    {\n      color = vec3(result.y*2.0, result.y*0.3, result.y*0.2);\n    }\n    else\n    {\n      color = vec3(0.0, result.y*abs(sin(iTime*1.8)),0.0);\n    }\n    \n    fragColor = vec4( color, 1.0 );\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4lcXRs.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[99, 99, 166, 166, 380], [382, 382, 438, 438, 559], [561, 561, 614, 614, 764], [766, 766, 884, 884, 1431], [1433, 1433, 1483, 1483, 1563], [1565, 1565, 1598, 1598, 1625], [1627, 1627, 1656, 1656, 1757], [1759, 1759, 1796, 1796, 1823], [1825, 1825, 1877, 1877, 1983], [1985, 1985, 2018, 2018, 2044], [2046, 2046, 2093, 2093, 2204], [2206, 2206, 2243, 2243, 3026], [3028, 3028, 3070, 3070, 3883], [3885, 3885, 3944, 3944, 4338], [4340, 4340, 4392, 4392, 4724], [4726, 4726, 4783, 4783, 6069]], "test": "error"}
{"id": "4lcXWs", "name": "color target with smoothstep", "author": "mxfh", "description": "forked from https://www.shadertoy.com/view/Xsl3RX by possum\nadded some pumping and rgb-color ringing", "tags": ["2d", "color", "smoothstep"], "likes": 5, "viewed": 126, "published": "Public", "date": "1482044094", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// forked from https://www.shadertoy.com/view/Xsl3RX by possum\nconst float rings      = 23.0;\nconst float velocity   = 1.5;\nconst vec3  pumpv      = vec3( 0.5 );\nconst vec3  pumpoffset = vec3( 0.05, 0.0, 0.0);\nconst vec3  pumpamp    = vec3( 1.90, 2.1, 1.7);\nconst float p          = 0.5;\nconst float b          = 0.01;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n  vec2  R      = iResolution.xy,\n        pos    = ( fragCoord - 0.5 * R ) / R.y;\n    \n  float dist   = pow( length ( pos ), p );\n  float offset = iTime * velocity;\n  vec3  conv   = ( sin( iTime * pumpv ) + pumpoffset ) * pumpamp + rings;\n  vec3  v      = dist * conv - offset;\n  vec3  ringr  = floor( v );\n  vec3  color  = smoothstep(\n                   -b, b,\n                   abs( dist - (\n                     ringr.x + float( fract( v.x ) > 0.5 ) + offset\n                   ) / conv ));\n  fragColor    = vec4( mix( color, 1.0 - color, mod( ringr, 2.0 )), 1.0 );      \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4lcXWs.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[320, 320, 377, 377, 954]], "test": "valid"}
{"id": "4lcXzs", "name": "rotating sliced rectangle", "author": "zproxy", "description": "from https://www.shadertoy.com/view/MldXzf", "tags": ["raymarching"], "likes": 0, "viewed": 86, "published": "Public", "date": "1481073117", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// \"Quake Logo\" by Krzysztof Narkowicz @knarkowicz\n\nconst float MATH_PI = float( 3.14159265359 );\n\nfloat VisibilityTerm( float roughness, float ndotv, float ndotl )\n{\n\tfloat m2\t= roughness * roughness;\n\tfloat visV\t= ndotl * sqrt( ndotv * ( ndotv - ndotv * m2 ) + m2 );\n\tfloat visL\t= ndotv * sqrt( ndotl * ( ndotl - ndotl * m2 ) + m2 );\n\treturn 0.5 / max( visV + visL, 0.00001 );\n}\n\nfloat DistributionTerm( float roughness, float ndoth )\n{\n\tfloat m2\t= roughness * roughness;\n\tfloat d\t\t= ( ndoth * m2 - ndoth ) * ndoth + 1.0;\n\treturn m2 / ( d * d * MATH_PI );\n}\n\nvec3 FresnelTerm( vec3 specularColor, float vdoth )\n{\n\tvec3 fresnel = clamp( 50.0 * specularColor.y, 0.0, 1.0 ) * specularColor + ( 1.0 - specularColor ) * pow( ( 1.0 - vdoth ), 5.0 );\n\treturn fresnel;\n}\n\nvec3 LightSpecular( vec3 normal, vec3 viewDir, vec3 lightDir, vec3 lightColor, float roughness, vec3 specularColor )\n{\n\tvec3 halfVec = normalize( viewDir + lightDir );\n\n\tfloat vdoth = clamp( dot( viewDir,\thalfVec\t ), 0.0, 1.0 );\n\tfloat ndoth\t= clamp( dot( normal,\thalfVec\t ), 0.0, 1.0 );\n\tfloat ndotv = clamp( dot( normal,\tviewDir  ), 0.0, 1.0 );\n\tfloat ndotl = clamp( dot( normal,\tlightDir ), 0.0, 1.0 );\n    \n   \tvec3\tf = FresnelTerm( specularColor, vdoth );\n\tfloat\td = DistributionTerm( roughness, ndoth );\n\tfloat\tv = VisibilityTerm( roughness, ndotv, ndotl );\n    \n    vec3 specular;\n\tspecular = lightColor * f * ( d * v * MATH_PI * ndotl );\n\treturn specular;\n}\n\nfloat Cylinder( vec3 p, float r, float height ) \n{\n\tfloat d = length( p.xz ) - r;\n\td = max( d, abs( p.y ) - height );\n\treturn d;\n}\n\nfloat Sphere( vec3 p, float s )\n{\n\treturn length( p ) - s;\n}\n\n\nvec3 bary(in vec3 a, in vec3 b, in vec3 c, in vec3 p)\n{\n    // The cross product of two vectors has a magnitude\n    // equal to twice the area of the triangle formed by \n    // the two vectors.\n    vec3 n = cross(b - a, c - a);    \n\tfloat area = dot(n, n);\n\t\n\tif(abs(area) < 0.0001) return vec3(0);\n\t\n\tvec3 v0 = a - p;\n\tvec3 v1 = b - p;\n\tvec3 v2 = c - p;\n\t\n\tvec3 asub = vec3(dot(cross(v1, v2), n),\n\t\t\t\t\t dot(cross(v2, v0), n),\n\t\t\t\t\t dot(cross(v0, v1), n));\n    \n\treturn asub / vec3(area);\n}\n\nbool test(in vec2 a, in vec2 b, in vec2 c, in vec2 p)\n{\n    vec3 v = bary(vec3(a.x, 0., a.y),\n                  vec3(b.x, 0., b.y),\n                  vec3(c.x, 0., c.y),\n                  vec3(p.x, 0., p.y));\n    \n    return v.x > 0. && v.y > 0. && v.z > 0.;\n}\n\n\n\nfloat Box( vec3 p, vec3 b )\n{\n    vec2 a0 = vec2( 1.73,  -1.05);\n    vec2 b0 = vec2(0.45,  .65);\n    vec2 c0 = vec2( .25, -.55);\n\n    vec2 mc = (p.zx    / b.xy * 2. - 1.) ;\n\n    bool t0 = test(a0, b0, c0, mc);\n    \n    \n\tvec3 d = abs( p ) - b;\n\t\n    float filler = min( \n        \n        max( d.x, max( d.y, d.z ) )\n        \n        , 0.0 ) + length( max( d, 0.0 ) );\n    \n    \n    //if (p.y > 0.0)\n    //    return 200.0;\n    \n    return filler;\n    return t0 ? filler: 0.0 ;\n}\n\nfloat Substract( float a, float b )\n{\n    return max( a, -b );\n}\n\nfloat SubstractRound( float a, float b, float r ) \n{\n\tvec2 u = max( vec2( r + a, r - b ), vec2( 0.0, 0.0 ) );\n\treturn min( -r, max( a, -b ) ) + length( u );\n}\n\nfloat Union( float a, float b )\n{\n    return min( a, b );\n}\n\nfloat UnionRound( float a, float b, float k )\n{\n    float h = clamp( 0.5 + 0.5 * ( b - a ) / k, 0.0, 1.0 );\n    return mix( b, a, h ) - k * h * ( 1.0 - h );\n}\n\nfloat TriPrism( vec3 p, float rot )\n{        \n    vec3 q = abs( p );\n    \n     return max(\n        // creates some type of symmetry\n        q.y - 0.5, \n     \n        // vertical line\n        p.x * cos(rot) + p.z * sin(rot)   \n     );\n}\n\nfloat Scene( vec3 p, mat3 localToWorld )\n{\n    // shadertoy should have time slider.\n    \n    p = p * localToWorld;\n    \n    \n    \n    \n    \n    \n      \n    float rot1deg =   20. * iTime;\n    \n    // align our triangle so we need to move union on x axis only.\n    //float rot1deg =   -25.;\n    \n    //float rot1deg =   -20.;\n    //float rot1deg =   -40.;\n    \n    float rot1 =   2.0 * MATH_PI / 360.0 * ( rot1deg);\n    \n    //float rot2a = mod(0.0 + 20. * iTime, 360.);\n    \n    // lets make our triangle slim. \n    float rot2a = 50.;\n\n    //float rot2a = (0.0 + 20. * iTime) % 360.;\n\n    float rot2 = 2.0 * MATH_PI / 360.0 * (180.0 - rot2a);\n    //float rot22 = 2.0 * MATH_PI / 360.0 * (180.0 - rot2a);\n    \n    \n    // one angle of a triangle cannot exceed 180 ever\n    \n    if (rot2a > 180.0)\n    \treturn 0.0;\n    \n    \n    float offset1 = sin(iTime) * 0.9 - 0.25;\n\n    \n    // can we move the objects?\n    \n    p += vec3(\n        \n        // up\n        0.0 ,\n              // back\n              -1.0,\n              \n              // right\n              0.0 );\n    \n    \n    \n    \n        float slice0 = TriPrism(  p + vec3(\n        \n        // up\n        1.0 * cos(rot1 + MATH_PI),\n              // back\n              -0.0,\n              \n              // right\n              1.0 * sin(rot1 + MATH_PI) \n        ), rot1 + MATH_PI);\n    \n    \n    float slice1 = TriPrism(  p + vec3(\n        \n        // up\n        1.0 * cos(rot1),\n              // back\n              -0.0,\n              \n              // right\n              1.0 * sin(rot1) \n        ), rot1);\n\n    \n    \n    \n    float slice = min(slice1,slice0)                    ;\n    \n    \n \n    \n     \n    \n    return \n                           \n                           // min means union\n                           // min\n                           \n                           // max means intersect\n                           \n                            max\n                           (slice,\n               Box(  p + vec3(0,0.5,0), vec3(\n                   \n                   // height\n                   1.5, \n                   \n                   //depth\n                   0.05, \n                   \n                   // width\n                   2.0)   )\n               );\n    \n    //return 2.0;\n    \n    // all green\n    return 0.5;\n    \n    // all black\n    return 0.0;\n    \n    \n    // ring\n    float a = Cylinder( p, 0.3, 0.1 );\n    \n    \n    //return Union(ret, a);\n}\n\nvec2 CastRay( in vec3 ro, in vec3 rd, mat3 localToWorld )\n{\n    const float maxd = 15.0;\n    \n\tfloat h = 0.5;\n    float t = 0.0;\n    float steps = 0.0;\n   \n    for ( int i = 0; i < 150; ++i )\n    {\n        if ( h < 0.001 || t > maxd ) \n        {\n            break;\n        }\n        \n\t    h = Scene( ro + rd * t, localToWorld );\n        t += h;\n        steps += 0.03;\n    }\n\n    if ( t > maxd )\n    {\n        t = -1.0;\n    }\n\t\n    return vec2(t, steps);\n}\n\nvec3 SceneNormal( in vec3 pos, mat3 localToWorld )\n{\n\tvec3 eps = vec3( 0.001, 0.0, 0.0 );\n\tvec3 nor = vec3(\n\t    Scene( pos + eps.xyy, localToWorld ) - Scene( pos - eps.xyy, localToWorld ),\n\t    Scene( pos + eps.yxy, localToWorld ) - Scene( pos - eps.yxy, localToWorld ),\n\t    Scene( pos + eps.yyx, localToWorld ) - Scene( pos - eps.yyx, localToWorld ) );\n\treturn normalize( -nor );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 q = fragCoord.xy / iResolution.xy;\n    vec2 p = -1.0 + 2.0 * q;\n\tp.x *= iResolution.x / iResolution.y;\n\n    // have comera zoom in and out to reveal boundaries\n\tvec3 rayOrigin \t= vec3( 0.0, -0.0, -3.5 + 0.1 *sin( iTime * 2.0) );\n    vec3 rayDir \t= normalize( vec3( p.x, p.y, 2.0 ) );\n    \n    float theta = -0.5 * MATH_PI;\n    mat3 rotX = mat3(\n        vec3( cos( theta ), sin( theta ), 0.0 ),\n        vec3( -sin( theta ), cos( theta ), 0.0 ),\n\t\tvec3( 0.0, 0.0, 1.0 )\n        );    \n    \n    vec2 mo = iMouse.xy / iResolution.xy;    \n    \n    float phi = 0.25 * MATH_PI + 10.0 * mo.x;    \n    //float phi = 0.25 * MATH_PI; \n    \n    // look straight at it. no mouse\n    //float phi = 0.5 * MATH_PI;    \n\n    mat3 rotY = mat3(\n        vec3( 1.0, 0.0, 0.0 ),\n        vec3( 0.0, cos( phi ), sin( phi ) ),\n        vec3( 0.0, -sin( phi ), cos( phi ) )\n        );\n    \n    //mat3 localToWorld = rotX * rotY;    \n    mat3 localToWorld = rotX * rotY;    \n\n\n\tvec3 color = texture( iChannel0, q ).yyy * 0.3;\n    \n\tvec2 result = CastRay( rayOrigin, rayDir, localToWorld );\n    \n    if ( result.x > 0.0 )\n    {\n      color = vec3(result.y*2.0, result.y*0.3, result.y*0.2);\n    }\n    else\n    {\n      color = vec3(0.0, result.y*abs(sin(iTime*1.8)),0.0);\n    }\n    \n    fragColor = vec4( color, 1.0 );\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4lcXzs.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[99, 99, 166, 166, 380], [382, 382, 438, 438, 559], [561, 561, 614, 614, 764], [766, 766, 884, 884, 1431], [1433, 1433, 1483, 1483, 1563], [1565, 1565, 1598, 1598, 1625], [1628, 1628, 1683, 1821, 2118], [2120, 2120, 2175, 2175, 2380], [2384, 2384, 2413, 2413, 2862], [2864, 2864, 2901, 2901, 2928], [2930, 2930, 2982, 2982, 3088], [3090, 3090, 3123, 3123, 3149], [3151, 3151, 3198, 3198, 3309], [3311, 3311, 3348, 3348, 3546], [3548, 3548, 3590, 3632, 5991], [5993, 5993, 6052, 6052, 6448], [6450, 6450, 6502, 6502, 6834], [6836, 6836, 6893, 6893, 8189]], "test": "error"}
{"id": "4ldSDl", "name": "Twisted shape", "author": "Frongo", "description": "Just a twisted shape thing modified from jlfwong's ray marching tutorial 6", "tags": ["raymarching"], "likes": 1, "viewed": 77, "published": "Public", "date": "1482186904", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/**\n * Part 6 Challenges:\n * - Make a scene of your own! Try to use the rotation transforms, the CSG primitives,\n *   and the geometric primitives. Remember you can use vector subtraction for translation,\n *   and component-wise vector multiplication for scaling.\n */\n\nconst int MAX_MARCHING_STEPS = 255;\nconst float MIN_DIST = 0.0;\nconst float MAX_DIST = 100.0;\nconst float EPSILON = 0.0001;\n\n/**\n * Rotation matrix around the X axis.\n */\nmat3 rotateX(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(1, 0, 0),\n        vec3(0, c, -s),\n        vec3(0, s, c)\n    );\n}\n\n/**\n * Rotation matrix around the Y axis.\n */\nmat3 rotateY(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(c, 0, s),\n        vec3(0, 1, 0),\n        vec3(-s, 0, c)\n    );\n}\n\n/**\n * Rotation matrix around the Z axis.\n */\nmat3 rotateZ(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(c, -s, 0),\n        vec3(s, c, 0),\n        vec3(0, 0, 1)\n    );\n}\n\n/**\n * Constructive solid geometry intersection operation on SDF-calculated distances.\n */\nfloat intersectSDF(float distA, float distB) {\n    return max(distA, distB);\n}\n\n/**\n * Constructive solid geometry union operation on SDF-calculated distances.\n */\nfloat unionSDF(float distA, float distB) {\n    return min(distA, distB);\n}\n\n/**\n * Constructive solid geometry difference operation on SDF-calculated distances.\n */\nfloat differenceSDF(float distA, float distB) {\n    return max(distA, -distB);\n}\n\n/**\n * Signed distance function for a cube centered at the origin\n * with dimensions specified by size.\n */\nfloat boxSDF(vec3 p, vec3 size) {\n    vec3 d = abs(p) - (size / 2.0);\n    \n    // Assuming p is inside the cube, how far is it from the surface?\n    // Result will be negative or zero.\n    float insideDistance = min(max(d.x, max(d.y, d.z)), 0.0);\n    \n    // Assuming p is outside the cube, how far is it from the surface?\n    // Result will be positive or zero.\n    float outsideDistance = length(max(d, 0.0));\n    \n    return insideDistance + outsideDistance;\n}\n\n/**\n * Signed distance function for a sphere centered at the origin with radius r.\n */\nfloat sphereSDF(vec3 p, float r) {\n    return length(p) - r;\n}\n\n/**\n * Signed distance function for an XY aligned cylinder centered at the origin with\n * height h and radius r.\n */\nfloat cylinderSDF(vec3 p, float h, float r) {\n    // How far inside or outside the cylinder the point is, radially\n    float inOutRadius = length(p.xy) - r;\n    \n    // How far inside or outside the cylinder is, axially aligned with the cylinder\n    float inOutHeight = abs(p.z) - h/2.0;\n    \n    // Assuming p is inside the cylinder, how far is it from the surface?\n    // Result will be negative or zero.\n    float insideDistance = min(max(inOutRadius, inOutHeight), 0.0);\n\n    // Assuming p is outside the cylinder, how far is it from the surface?\n    // Result will be positive or zero.\n    float outsideDistance = length(max(vec2(inOutRadius, inOutHeight), 0.0));\n    \n    return insideDistance + outsideDistance;\n}\n\n/**\n * Signed distance function describing the scene.\n * \n * Absolute value of the return value indicates the distance to the surface.\n * Sign indicates whether the point is inside or outside the surface,\n * negative indicating inside.\n */\nfloat sceneSDF(vec3 samplePoint) {    \n    // Slowly spin the whole scene\n    //samplePoint = rotateY(iTime / 2.0) * samplePoint;\n    \n    float cube = boxSDF(samplePoint * rotateX(samplePoint.x * 1.0), vec3(1.8, 1.8, 1.8));\n    \n    float sphere = sphereSDF(samplePoint, 1.1);\n    \n    float bigSphere = sphereSDF(samplePoint, 1.2);\n    \n    return intersectSDF(differenceSDF(cube, sphere), bigSphere);\n}\n\n/**\n * Return the shortest distance from the eyepoint to the scene surface along\n * the marching direction. If no part of the surface is found between start and end,\n * return end.\n * \n * eye: the eye point, acting as the origin of the ray\n * marchingDirection: the normalized direction to march in\n * start: the starting distance away from the eye\n * end: the max distance away from the ey to march before giving up\n */\nfloat shortestDistanceToSurface(vec3 eye, vec3 marchingDirection, float start, float end) {\n    float depth = start;\n    for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n        float dist = sceneSDF(eye + depth * marchingDirection);\n        if (dist < EPSILON) {\n\t\t\treturn depth;\n        }\n        depth += dist;\n        if (depth >= end) {\n            return end;\n        }\n    }\n    return end;\n}\n            \n\n/**\n * Return the normalized direction to march in from the eye point for a single pixel.\n * \n * fieldOfView: vertical field of view in degrees\n * size: resolution of the output image\n * fragCoord: the x,y coordinate of the pixel in the output image\n */\nvec3 rayDirection(float fieldOfView, vec2 size, vec2 fragCoord) {\n    vec2 xy = fragCoord - size / 2.0;\n    float z = size.y / tan(radians(fieldOfView) / 2.0);\n    return normalize(vec3(xy, -z));\n}\n\n/**\n * Using the gradient of the SDF, estimate the normal on the surface at point p.\n */\nvec3 estimateNormal(vec3 p) {\n    return normalize(vec3(\n        sceneSDF(vec3(p.x + EPSILON, p.y, p.z)) - sceneSDF(vec3(p.x - EPSILON, p.y, p.z)),\n        sceneSDF(vec3(p.x, p.y + EPSILON, p.z)) - sceneSDF(vec3(p.x, p.y - EPSILON, p.z)),\n        sceneSDF(vec3(p.x, p.y, p.z  + EPSILON)) - sceneSDF(vec3(p.x, p.y, p.z - EPSILON))\n    ));\n}\n\n/**\n * Lighting contribution of a single point light source via Phong illumination.\n * \n * The vec3 returned is the RGB color of the light's contribution.\n *\n * k_a: Ambient color\n * k_d: Diffuse color\n * k_s: Specular color\n * alpha: Shininess coefficient\n * p: position of point being lit\n * eye: the position of the camera\n * lightPos: the position of the light\n * lightIntensity: color/intensity of the light\n *\n * See https://en.wikipedia.org/wiki/Phong_reflection_model#Description\n */\nvec3 phongContribForLight(vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye,\n                          vec3 lightPos, vec3 lightIntensity) {\n    vec3 N = estimateNormal(p);\n    vec3 L = normalize(lightPos - p);\n    vec3 V = normalize(eye - p);\n    vec3 R = normalize(reflect(-L, N));\n    \n    float dotLN = dot(L, N);\n    float dotRV = dot(R, V);\n    \n    if (dotLN < 0.0) {\n        // Light not visible from this point on the surface\n        return vec3(0.0, 0.0, 0.0);\n    } \n    \n    if (dotRV < 0.0) {\n        // Light reflection in opposite direction as viewer, apply only diffuse\n        // component\n        return lightIntensity * (k_d * dotLN);\n    }\n    return lightIntensity * (k_d * dotLN + k_s * pow(dotRV, alpha));\n}\n\n/**\n * Lighting via Phong illumination.\n * \n * The vec3 returned is the RGB color of that point after lighting is applied.\n * k_a: Ambient color\n * k_d: Diffuse color\n * k_s: Specular color\n * alpha: Shininess coefficient\n * p: position of point being lit\n * eye: the position of the camera\n *\n * See https://en.wikipedia.org/wiki/Phong_reflection_model#Description\n */\nvec3 phongIllumination(vec3 k_a, vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye) {\n    const vec3 ambientLight = 0.5 * vec3(1.0, 1.0, 1.0);\n    vec3 color = ambientLight * k_a;\n    \n    vec3 light1Pos = vec3(6.0,\n                          2.0,\n                          4.0);\n    vec3 light1Intensity = vec3(0.4, 0.4, 0.4);\n    \n    color += phongContribForLight(k_d, k_s, alpha, p, eye,\n                                  light1Pos,\n                                  light1Intensity);\n    \n    //vec3 light2Pos = vec3(2.0 * sin(0.37 * iTime),\n      //                    2.0 * cos(0.37 * iTime),\n        //                  2.0);\n    //vec3 light2Intensity = vec3(0.4, 0.4, 0.4);\n    \n    //color += phongContribForLight(k_d, k_s, alpha, p, eye,\n      //                            light2Pos,\n        //                          light2Intensity);    \n    return color;\n}\n\n/**\n * Return a transform matrix that will transform a ray from view space\n * to world coordinates, given the eye point, the camera target, and an up vector.\n *\n * This assumes that the center of the camera is aligned with the negative z axis in\n * view space when calculating the ray marching direction. See rayDirection.\n */\nmat3 viewMatrix(vec3 eye, vec3 center, vec3 up) {\n    // Based on gluLookAt man page\n    vec3 f = normalize(center - eye);\n    vec3 s = cross(f, up);\n    vec3 u = cross(s, f);\n    return mat3(s, u, -f);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec3 viewDir = rayDirection(45.0, iResolution.xy, fragCoord);\n    vec3 eye = vec3(8.0, 5.0 * sin(0.2 * iTime), 7.0);\n    //vec3 eye = vec3(8.0, 5.0, 7.0);\n    \n    mat3 viewToWorld = viewMatrix(eye, vec3(0.0, 0.0, 0.0), vec3(0.0, 1.0, 0.0));\n    \n    vec3 worldDir = viewToWorld * viewDir;\n    \n    float dist = shortestDistanceToSurface(eye, worldDir, MIN_DIST, MAX_DIST);\n    \n    if (dist > MAX_DIST - EPSILON) {\n        // Didn't hit anything\n        fragColor = vec4(0.0, 0.0, 0.0, 0.0);\n\t\treturn;\n    }\n    \n    // The closest point on the surface to the eyepoint along the view ray\n    vec3 p = eye + dist * worldDir;\n    \n    // Use the surface normal as the ambient color of the material\n    //vec3 K_a = (estimateNormal(p) + vec3(1.0)) / 2.0;\n    vec3 K_a = vec3(0.5, 0.5, 0.5);\n    vec3 K_d = K_a;\n    vec3 K_s = vec3(1.0, 1.0, 1.0);\n    float shininess = 10.0;\n    \n    vec3 color = phongIllumination(K_a, K_d, K_s, shininess, p, eye);\n    \n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4ldSDl.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[394, 440, 467, 467, 614], [616, 662, 689, 689, 836], [838, 884, 911, 911, 1058], [1060, 1151, 1197, 1197, 1229], [1231, 1315, 1357, 1357, 1389], [1391, 1480, 1527, 1527, 1560], [1562, 1670, 1703, 1703, 2133], [2135, 2222, 2256, 2256, 2284], [2286, 2403, 2448, 2517, 3123], [3125, 3365, 3399, 3494, 3770], [3772, 4193, 4284, 4284, 4590], [4605, 4859, 4924, 4924, 5056], [5058, 5147, 5176, 5176, 5486], [5488, 5980, 6120, 6120, 6710], [6712, 7082, 7167, 7167, 7955], [7957, 8284, 8333, 8368, 8488], [8490, 8490, 8547, 8547, 9537]], "test": "valid"}
{"id": "4ldSRX", "name": "2D Fractal Particles 2", "author": "aiekick", "description": "2D Fractal Particles 2", "tags": ["2d", "fractal", "particles", "2"], "likes": 5, "viewed": 490, "published": "Public API", "date": "1480867531", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define particles_count 40.\n#define k 0.006\n#define threshold 16.\n\n#define zmul(a, b) vec2(a.x*b.x-a.y*b.y, a.x*b.y+b.x*a.y)\n#define zinv(a) vec2(a.x, -a.y) / dot(a,a)\n\nvec2 df(vec2 p)\n{\n\t//return abs(p)-uSlider;\n\tvec2 tri = vec2(max(abs(p.x)+p.y,-p.y)); // tri\n\tvec2 circle = vec2(length(p)); // circle\n\treturn mix(tri, circle, sin(iTime*0.2))-0.46;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 g = fragCoord.xy;\n\tvec2 si = iResolution.xy;\n    vec2 m = iMouse.xy/si;\n\tfloat t = iTime;\n    vec3 stars = vec3(0);\n    \n    vec2 uv = (g+g-si)/min(si.x,si.y) * 2.;\n    uv.x -= 0.5;\n    \n    vec2 z = uv;\n\tvec2 c = vec2(0.7,0.8);\n    \n    float r = 0.;\n\tfor (float i=0.;i<50.;i++)\n\t{\n\t\tif (r > threshold) break;\n        r = dot(z,z);\n\t\tz = zmul(z, z) + uv;  \n        \n        vec3 col = mix(vec3(0.5,0,0.5), vec3(0,1,0.29), i/5.);\n        \n        vec3 acc = vec3(0);\n        for (float j=0.;j<particles_count;j++)\n        {\n            float tt = t + j/(3.14159/(particles_count*k));\n            vec2 b = vec2(cos(tt), sin(tt)) * sqrt(threshold);\n        \tacc += col/r/dot(df(z-b), df(z-b));\n        }\n        stars += acc / particles_count / 0.75;\n    }\n \n    fragColor = vec4(stars*0.3,1);\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4ldSRX.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[169, 169, 186, 212, 352], [354, 354, 411, 411, 1211]], "test": "valid"}
{"id": "4ldSWX", "name": "Purple Twist", "author": "ptrgags", "description": "First attempt at using both radius and angle (relative to center of screen) in a shader.", "tags": ["2d", "wavy", "polar", "purple", "twist", "zigzag"], "likes": 2, "viewed": 126, "published": "Public", "date": "1481843910", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float triangle_wave(float x) {\n    return abs(mod(x, 2.0) - 1.0);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //Centered UV coordinates\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    uv -= 0.5;\n    //Fix aspect ratio\n    uv.x *= iResolution.x / iResolution.y;\n    \n    //Polar coordinates of this point relative to the center\n    float r = length(uv);\n    float theta = atan(uv.y, uv.x);\n    \n    //Okay, \"Violet\"...\n    vec4 purple = vec4(0.5, 0.0, 1.0, 1.0);\n    \n    //This factor will be used in a cosine w/r/t\n    //theta. it will create a number of spokes around\n    //the center of the screen\n    float spokes = 5.0;\n    \n    \n    //Rotate the spokes back and forth over time\n    float rotation = 30.0 * cos(0.5 * iTime);\n    \n    //Distort the spokes with a wave down the radius\n    //Take your pick, triangle ewave or cosine wave. I \n    //personally like the cosine wave for this shader\n    //float radius_shift = triangle_wave(10.0 * r);\n    float distortion_wave = cos(20.0 * r);\n    \n    \n    //combine the effects of rotation + radius wave\n    float spoke_distortion = rotation * distortion_wave;\n    \n    //calculate the overall twist shape\n    float twist = cos(spokes * theta + spoke_distortion);\n    \n    //Color the twist purple\n\tfragColor = twist * purple;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4ldSWX.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 30, 30, 67], [70, 70, 127, 157, 1299]], "test": "valid"}
{"id": "4lGSzh", "name": "formula bounded fractal mapper", "author": "towc", "description": "other small experiment to get to grasps with glsl :)", "tags": ["2d", "fractal", "mandelbrot"], "likes": 1, "viewed": 108, "published": "Public", "date": "1482689262", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec3 v3( float x, float y, float z ){\n\treturn vec3( x, y, z );\n}\n\nvec3 h2rgb( float hue ){\n    \n  float h = abs(hue - floor(hue)) * 6.;\n  vec3 c = vec3( 0., 0., 0. );\n   \n  int f = int(floor( h ));\n    \n  if(f==0)c=v3(1.,h,0.);else if(f==1)c=v3(2.-h,1.,0.);else if(f==2)c=v3(0.,1.,h-2.);else if(f==3)c=v3(0.,4.-h,1.);else if(f==4)c=v3(h-4.,0.,1.);else c=v3(1.,0.,6.-h);\n  return c;\n}\n\nvec2 r( vec2 p, vec2 c ){\n    \n   \treturn vec2( p.x*p.x - p.y*p.y + c.x, 2.*p.x*p.y + c.y );\n}\n\nfloat dist( vec2 v ){\n\treturn sqrt( v.x*v.x + v.y*v.y );\n}\nfloat f( float x, float y ){\n    \n    vec2 val = vec2( 0, 0 );\n    for( int i = 0; i < 500; ++i )\n        val = r( val, vec2( x, y ) );\n    \n\treturn dist(val);\n}\nvec2 rotate( vec2 v, float d ){\n\tfloat c = cos( d );\n    float s = sin( d );\n    \n    float v_x = v.x;\n    v.x = v.x * c - v.y * s;\n    v.y = v_x * s + v.y * c;\n    \n    return v;\n}\nconst float tx = -.156;\nconst float ty = 1.038;\nconst float threshold = 100000.;\n    \nconst float baseWaveAmount = .5;\nconst float addedWaveAmount = .4999;\nconst float waveFrequency = .5;\nconst float coordinateMultiplier = 1./90.;\n    \nconst float rotSpeed = .25;\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{   \n    \n\tvec2 q = fragCoord.xy - iResolution.xy / 2.;\n    q *= ( baseWaveAmount + addedWaveAmount * sin( iTime * waveFrequency ) ) * coordinateMultiplier;\n    \n    q = rotate( q, iTime * rotSpeed );\n    \n    float fx = f( q.x + tx, q.y + ty );\n    \n    bool isConsidered = fx < threshold && fx > -threshold;\n    vec3 rgb = h2rgb( fx + iTime / 2.);\n\tfragColor = vec4( \n        rgb * ( isConsidered ? 1. : 0. ), 1 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4lGSzh.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 37, 37, 64], [66, 66, 90, 90, 383], [385, 385, 410, 410, 479], [481, 481, 502, 502, 539], [540, 540, 568, 568, 701], [702, 702, 733, 733, 883], [1148, 1148, 1205, 1205, 1622]], "test": "valid"}
{"id": "4ltSDj", "name": "#Devember 2016 - day 12", "author": "theGiallo", "description": "I added sdf of hex prism given depth(or height) and radius. IQ's one takes half depth and triangle height.", "tags": ["raymarching", "prism", "hexprism", "devember"], "likes": 2, "viewed": 161, "published": "Public", "date": "1481653186", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define SQRT2 1.4142135623730950488016887242096980785696\n#define PI    3.1415926535897932384626433832795\n#define HPI   1.57079632679489661923132169\n#define QPI   0.785398163397448309615660845819875721\n#define TAU   6.283185307179586476925286766559\n\n#define INDEXED_MATERIALS 1\n\n#if INDEXED_MATERIALS\n#define MPt vec2\n#define distance x\n#else\n#define MPt Material_Point\n#endif\nstruct\nMaterial\n{\n    vec3 color;\n    float diffuse_reflection;\n    float specular_reflection;\n    float ambient_reflection;\n    float shininess;\n};\nstruct\nMaterial_Point\n{\n    float distance;\n    Material material;\n};\n    \n#define MAT_PLASTIC  0.0\n#define MAT_ORANGE   1.0\n#define MAT_RED      2.0\n#define MAT_GREEN    3.0\n#define MAT_BLUE     4.0\n#define MAT_FLOOR_W  5.0\n#define MAT_FLOOR_B  6.0\n#define MAT_COUNT    7\n\n////////////////////////////////////////////////////////////////////////////////\n\nfloat\nmanhattan( vec2 p )\n{\n    p = abs ( p );\n    float ret = p.x + p.y;\n    return ret;\n}\nfloat\nmanhattan( vec2 p0, vec2 p1 )\n{\n    float ret;\n    \n    vec2 d = abs ( p1 - p0 );\n    ret = d.x + d.y;\n    \n    return ret;\n}\nvec4\ncircle( vec4 color, vec2 pos, float radius, float border_width, vec2 point )\n{\n    vec4 ret = vec4(0);\n    color.rgb *= color.a;\n    \n    float dist = length( point - pos );\n    ret = color * (1.0 - smoothstep( radius, radius + border_width, dist ) );\n    \n    return ret;\n}\nvec4\nsquare( vec4 color, vec2 pos, float side, float border_width, float rot_rad, vec2 point )\n{\n    vec4 ret = vec4(0);\n    color.rgb *= color.a;\n    \n    float max_d = SQRT2 * side;\n    vec2 rd = point - pos;\n    float tot_rad = QPI + rot_rad;\n    vec2 rd_rot;\n    rd_rot.x = rd.x * cos( tot_rad ) + rd.y * sin( tot_rad );\n    rd_rot.y = rd.x * sin( tot_rad ) - rd.y * cos( tot_rad );\n    float dist = manhattan( rd_rot );\n    ret = color * (1.0 - smoothstep( max_d, max_d + border_width, dist ) );\n    \n    return ret;\n}\nvec4\nsquare_tex( vec4 color, vec2 pos, float side, float border_width, float rot_rad, vec2 point, sampler2D tex )\n{\n    vec4 ret = vec4(0);\n    color.rgb *= color.a;\n    \n    float max_d = SQRT2 * side;\n    vec2 rd = point - pos;\n    float tot_rad = QPI + rot_rad;\n    vec2 rd_rot;\n    rd_rot.x = rd.x * cos( tot_rad ) + rd.y * sin( tot_rad );\n    rd_rot.y = rd.x * sin( tot_rad ) - rd.y * cos( tot_rad );\n    float dist = manhattan( rd_rot );\n    ret = color * (1.0 - smoothstep( max_d, max_d + border_width, dist ) );\n    ret *= texture( tex, rd_rot * (0.5 / side ) + 0.5 );\n    \n    return ret;\n}\n\n// NOTE(theGiallo): pre-multiplied alpha\nvoid\nblend_pma( inout vec4 dst, in vec4 src )\n{\n    dst.rgb = src.rgb + dst.rgb * ( 1.0 - src.a );\n    dst.a = min( 1.0, dst.a + src.a );\n}\n\nfloat\nmirror( float x )\n{\n    x *= 0.5;\n    return 1.0 - abs( 2.0 * ( x - floor(x) ) - 1.0 );\n}\n\nfloat\ndecimal( float x )\n{\n    return x - floor(x);\n}\n\n// NOTE(theGiallo): h in [0,1)\nvec4\nrgb_from_hsv( vec4 hsv )\n{\n\tvec4 ret;\n\tret.a = hsv.a;\n\tfloat c = hsv.g * hsv.b;\n\tfloat hh = hsv.r * 6.0;\n\n\tfloat x = c * ( 1.0 - abs( hh - 2.0 * floor( hh / 2.0 ) - 1.0 ) );\n\n\tif ( hh < 1.0 || hh >= 6.0 )\n\t{\n\t\tret.r = c;\n\t\tret.g = x;\n\t\tret.b = 0.0;\n\t} else\n\tif ( hh < 2.0 )\n\t{\n\t\tret.r = x;\n\t\tret.g = c;\n\t\tret.b = 0.0;\n\t} else\n\tif ( hh < 3.0 )\n\t{\n\t\tret.r = 0.0;\n\t\tret.g = c;\n\t\tret.b = x;\n\t} else\n\tif ( hh < 4.0 )\n\t{\n\t\tret.r = 0.0;\n\t\tret.g = x;\n\t\tret.b = c;\n\t} else\n\tif ( hh < 5.0 )\n\t{\n\t\tret.r = x;\n\t\tret.g = 0.0;\n\t\tret.b = c;\n\t} else\n\tif ( hh < 6.0 )\n\t{\n\t\tret.r = c;\n\t\tret.g = 0.0;\n\t\tret.b = x;\n\t}\n\n\tfloat m = hsv.b - c;\n\tret.r += m;\n\tret.g += m;\n\tret.b += m;\n\n\treturn ret;\n}\n\n#define ORANGE_RGB vec3(1.0,0.4,0.0)\n#define T_EPS 0.001\n\nfloat\nminv( in vec3 v )\n{\n    return min( v.x, min( v.y, v.z ) );\n}\n\nfloat\nmaxv( in vec3 v )\n{\n    return max( v.x, max( v.y, v.z ) );\n}\n\nfloat\nminv( in vec2 v )\n{\n    return min( v.x, v.y );\n}\n\nfloat\nmaxv( in vec2 v )\n{\n    return max( v.x, v.y );\n}\n\n\n\nvec3\nat_pos( in vec3 pos, in vec3 p )\n{\n    return p-pos;\n}\n\nmat4\ntr( mat4 m )\n{\n    return mat4(\n       vec4(m[0][0],m[1][0],m[2][0],m[3][0]),\n       vec4(m[0][1],m[1][1],m[2][1],m[3][1]),\n       vec4(m[0][2],m[1][2],m[2][2],m[3][2]),\n       vec4(m[0][3],m[1][3],m[2][3],m[3][3])\n    );\n}\n\nvec3\nrotate( in vec3 r, in vec3 p )\n{\n\tmat4 Rx = mat4(\n\t   vec4( 1.0, 0.0,      0.0,       0.0 ),\n\t   vec4( 0.0, cos(r.x), -sin(r.x), 0.0 ),\n\t   vec4( 0.0, sin(r.x),  cos(r.x), 0.0 ),\n\t   vec4( 0.0, 0.0,      0.0,       0.0 ) );\n\tmat4 Ry = mat4(\n\t   vec4(  cos(r.y), 0.0, sin(r.y), 0.0 ),\n\t   vec4(  0.0,      1.0, 0.0,      0.0 ),\n\t   vec4( -sin(r.y), 0.0, cos(r.y), 0.0 ),\n\t   vec4(  0.0,      0.0, 0.0,      1.0 ) );\n\tmat4 Rz = mat4(\n\t   vec4( cos(r.z), -sin(r.z), 0.0, 0.0 ),\n\t   vec4( sin(r.z),  cos(r.z), 0.0, 0.0 ),\n\t   vec4( 0.0,      0.0,       1.0, 0.0 ),\n\t   vec4( 0.0,      0.0,       0.0, 1.0 ) );\n\tmat4 m = Rz * Ry * Rx;\n\treturn (vec4(p,1.0)*m).xyz;\n}\n\nvec3\nat_angle( in vec3 a, in vec3 p )\n{\n    return rotate( -a, p );\n}\n\n#if INDEXED_MATERIALS\nvec2\nunion_op( vec2 p0, vec2 p1 )\n{\n    if ( p0.x < p1.x )\n    {\n        return p0;\n    }\n    return p1;\n}\n#else\nMaterial_Point\nunion_op( Material_Point p0, Material_Point p1 )\n{\n    if ( p0.distance < p1.distance )\n    {\n        return p0;\n    }\n    return p1;\n}\n#endif\n\n#if INDEXED_MATERIALS\nvec2\nintersect_op( vec2 p0, vec2 p1 )\n{\n    if ( p0.x > p1.x )\n    {\n        return p0;\n    }\n    return p1;\n}\n#else\nMaterial_Point\nintersect_op( Material_Point p0, Material_Point p1 )\n{\n    if ( p0.distance > p1.distance )\n    {\n        return p0;\n    }\n    return p1;\n}\n#endif\n\nMaterial\nchange_color( Material m, vec3 color )\n{\n    Material ret = m;\n    ret.color = color;\n    return ret;\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\nfloat\nsphere_sd( in float sph_r, in vec3 p )\n{\n    return length( p ) - sph_r;\n}\n\nfloat\naab_sd( in vec3 sides, in vec3 p )\n{\n    sides *= 0.5;\n    p = abs( p );\n    vec3 d = p - sides;\n    return min( maxv( d ), 0.0 ) + length( max(d,0.0) );\n}\n\nfloat\nplane_sd( in vec3 p )\n{\n    return abs( p.z );\n}\n\n\nfloat\nhalf_space_sd( in vec3 p )\n{\n    return p.z;\n}\n\nfloat\nround_aab_ud( in vec3 sides, in float r, in vec3 p )\n{\n    sides *= 0.5;\n    p = abs( p );\n    vec3 d = p - sides;\n    return length( max(d, 0.0) ) - r;\n}\n\n// NOTE(theGiallo): torus.x = big radius torus.y = solid radius\nfloat\ntorus_sd( in vec2 torus, in vec3 p )\n{\n    vec2 q = vec2(length(p.xy)-torus.x,p.z);\n    return length(q)-torus.y;\n}\n\nfloat\ncylinder_sd( in float r, in vec3 p )\n{\n    return length( p.xy ) - r;\n}\n\nfloat\ncapped_cylinder_sd( in vec2 rh, in vec3 p )\n{\n    vec2 d = abs( vec2( length( p.xy ), p.z ) ) - rh;\n    return min( maxv(d), 0.0 ) + length( max(d, 0.0) );\n}\n\nfloat\nhalf_cone_pos_sd( in vec2 c, in vec3 p )\n{\n    vec2 c1 = vec2(c.y,-c.x);\n    return dot( c1, vec2(length(p.xy), p.z) );\n}\n\nfloat\ncone_sd( in vec2 c, in vec3 p )\n{\n    p = abs(p);\n    vec2 c1 = vec2(c.y,-c.x);\n    return dot( c1, vec2(length(p.xy), p.z) );\n}\n\nfloat\ncapped_cone_as_intersections_sd( in float h, in float r1, in float r2, in vec3 p )\n{\n    float R1z = (r1*h)/(r2-r1);\n    float R2z = R1z + h;\n    p = at_pos(vec3(0.0,0.0,-R1z),p);\n\tvec2 c = vec2(r2/R2z,1.0);\n\treturn\n\tmax( max( -half_space_sd( at_pos(vec3(0.0,0.0,R1z), p) ), half_space_sd( at_pos( vec3(0.0,0.0,R2z), p ) ) ),\n         half_cone_pos_sd( c, p )\n       );\n}\n\n// NOTE(theGiallo): d.x is the depth of the prism(or height), d.y the radius\n// NOTE(theGiallo): depth on x axis, diameter on y axis\nfloat\nhex_prism_sd( in vec2 dr, in vec3 p )\n{\n    p = abs(p);\n    return max(p.x-dr.x*0.5,max(p.y*0.866025+p.z*0.5,p.z)-0.866025*dr.y);\n}\n\nvec3 sky_color;\n\n#if INDEXED_MATERIALS\nvec2\n#else\nMaterial_Point\n#endif\nmap( in vec3 pos )\n{\n    #if 0\n    float r = 1.1;\n    float h = decimal( ( floor( pos.x / r + 0.5 ) + 50.0 ) / 10.0 );\n    float s = mirror( ( floor( pos.s / r + 0.5 ) + 50.0 ) / 30.0 );\n    vec3 color = rgb_from_hsv( vec4( h, s, 1.0, 1.0 ) ).rgb;\n    pos.x = mirror( pos.x / r ) * r;\n    pos.y = mirror( pos.y / r ) * r;\n    #else\n    vec3 color = ORANGE_RGB;\n    #endif\n    \n    MPt res;\n    #if INDEXED_MATERIALS\n    res.x = 1e38;\n    #else\n    res.distance = 1e38;\n    #endif\n    \n    #if !INDEXED_MATERIALS\n    Material plastic_m;\n    plastic_m.color = vec3(1.0);\n    plastic_m.diffuse_reflection  = 1.0;\n    plastic_m.specular_reflection = 1.0;\n    plastic_m.ambient_reflection  = 1.0;\n    plastic_m.shininess           = 15.0;\n\n    Material floor_m;\n    plastic_m.color = vec3(1.0);\n    floor_m.diffuse_reflection  = 1.0;\n    floor_m.specular_reflection = 0.2;\n    floor_m.ambient_reflection  = 0.5;\n    floor_m.shininess           = 1.0;\n\n    Material orange_m = plastic_m;\n    orange_m.color = ORANGE_RGB;\n    \n    Material red_m = plastic_m;\n    red_m.color = vec3(1.0,0.0,0.0);\n    Material green_m = plastic_m;\n    green_m.color = vec3(0.0,1.0,0.0);\n    Material blue_m = plastic_m;\n    blue_m.color = vec3(0.0,0.0,1.0);\n    #endif\n\n    float sr = 0.5;\n    float sd = 0.5;\n    #if 0\n    res =\n       union_op(\n          MPt( sphere_sd( sr, at_pos( sd * vec3(0.0, cos( HPI             ), sin( HPI             ) ), pos ) ),\n                          orange_mat ),\n\t      MPt( sphere_sd( sr, at_pos( sd * vec3(0.0, cos( HPI + TAU / 3.0 ), sin( HPI + TAU / 3.0 ) ), pos ) ),\n                          orange_mat ) );\n    res =\n       union_op(\n          MPt( sphere_sd( sr, at_pos( sd * vec3(0.0, cos( HPI - TAU / 3.0 ), sin( HPI - TAU / 3.0 ) ), pos ) ),\n               orange_mat ),\n          res );\n    #endif\n    \n    res = union_op( MPt( sphere_sd( 0.1, at_pos( vec3(0.0        ), pos ) ),\n                        #if INDEXED_MATERIALS\n                         MAT_PLASTIC\n                        #else\n                        plastic_m\n                        #endif\n                       ), res );\n    res = union_op( MPt( sphere_sd( 0.1, at_pos( vec3(1.0,0.0,0.0), pos ) ),\n                        #if INDEXED_MATERIALS\n                         MAT_RED\n                        #else\n                        red_m\n                        #endif\n                       ),res );\n    res = union_op( MPt( sphere_sd( 0.1, at_pos( vec3(0.0,1.0,0.0), pos ) ),\n                        #if INDEXED_MATERIALS\n                         MAT_GREEN\n                        #else\n                        green_m\n                        #endif\n                       ),res );\n    res = union_op( MPt( sphere_sd( 0.1, at_pos( vec3(0.0,0.0,1.0), pos ) ),\n                        #if INDEXED_MATERIALS\n                         MAT_BLUE\n                        #else\n                        blue_m\n                        #endif\n                       ),res );\n    float m = mod( floor(pos.x * 2.0) + floor(pos.y * 2.0), 2.0 );\n    res = union_op( MPt( plane_sd( pos ),\n                        #if INDEXED_MATERIALS\n                        MAT_FLOOR_B * (1.0 - m) + MAT_FLOOR_W * m\n                        #else\n                         change_color( floor_m, vec3( 0.7 + 0.3 * m ) )\n                        #endif\n                       ),\n                    res );\n\n\n    res =\n       union_op( MPt( aab_sd( vec3(1.0), at_angle( vec3(0.0,0.0,pos.z * HPI * sin(iTime)), at_pos(vec3(2.0,0.0,0.5),pos) ) ),\n                        #if INDEXED_MATERIALS\n                         MAT_ORANGE\n                        #else\n                         orange_m\n                        #endif\n                    ),\n                 res );\n    res = union_op( MPt( aab_sd( vec3(1.0), at_angle( vec3(0.0,0.0,iTime*0.05), at_pos(vec3(2.0,2.0,0.5),pos) ) ),\n                        #if INDEXED_MATERIALS\n                         MAT_ORANGE\n                        #else\n                         orange_m\n                        #endif\n                       ),\n                    res );\n    res = union_op( MPt( aab_sd( vec3(1.0), at_angle( vec3(0.0,pos.y * HPI,0.0), at_pos(vec3(-2.0,pos.y,0.5),pos) ) ),\n                        #if INDEXED_MATERIALS\n                         MAT_ORANGE\n                        #else\n                         orange_m\n                        #endif\n                       ),\n                    res );\n    res = union_op( MPt( round_aab_ud( vec3(0.9), 0.05, at_pos( vec3(2.0,-2.0,0.4), pos ) ),\n                        #if INDEXED_MATERIALS\n                         MAT_PLASTIC\n                        #else\n                         change_color( plastic_m, rgb_from_hsv( vec4(0.083,0.1,1.0,1.0) ).rgb )\n                        #endif\n                       ),\n                    res );\n    \n    res =\n       union_op( MPt( torus_sd( vec2(0.4,0.1), at_angle( vec3(0.0,0.0,0.0), at_pos(vec3(2.0,4.0,0.1),pos) ) ),\n                        #if INDEXED_MATERIALS\n                         MAT_ORANGE\n                        #else\n                         orange_m\n                        #endif\n                    ),\n                 res );\n    \n    res =\n       union_op( MPt( torus_sd( vec2(0.38,0.12), at_angle( vec3(0.0,HPI,iTime), at_pos(vec3(2.0,6.0,0.5),pos) ) ),\n                        #if INDEXED_MATERIALS\n                         MAT_ORANGE\n                        #else\n                         orange_m\n                        #endif\n                    ),\n                 res );\n    \n    res =\n       union_op( MPt( torus_sd( vec2(0.38,0.12), at_angle( vec3(0.0,HPI, iTime + TAU * pos.z), at_pos(vec3(2.0,8.0,0.5),pos) ) ),\n                        #if INDEXED_MATERIALS\n                         MAT_ORANGE\n                        #else\n                         orange_m\n                        #endif\n                    ),\n                 res );\n    \n    res =\n       union_op( MPt( cylinder_sd( 0.5, at_angle( vec3(0.0,/*sin(iTime*TAU/7.0)**/QPI*0.25,iTime*TAU/7.0), at_pos(vec3(2.0,10.0,2.0),pos) ) ),\n                        #if INDEXED_MATERIALS\n                         MAT_ORANGE\n                        #else\n                         orange_m\n                        #endif\n                    ),\n                 res );\n    \n    res =\n       union_op( MPt( capped_cylinder_sd( vec2( 0.5, 1.0 ), at_angle( vec3(0.0,0.25*QPI*iTime,iTime*TAU/7.0), at_pos(vec3(2.0,12.0,1.0),pos) ) ),\n                        #if INDEXED_MATERIALS\n                         MAT_ORANGE\n                        #else\n                         orange_m\n                        #endif\n                    ),\n                 res );\n    \n    res =\n       union_op( MPt( cone_sd( vec2( 0.5, 1.0 ),\n                               at_angle( vec3(0.0,0.125*PI*sin(iTime*TAU/11.0),iTime*TAU/17.0),\n                                         at_pos(vec3(2.0,14.0,1.0),pos) ) ),\n                        #if INDEXED_MATERIALS\n                         MAT_ORANGE\n                        #else\n                         orange_m\n                        #endif\n                    ),\n                 res );\n    \n    res =\n       union_op( MPt( half_cone_pos_sd( vec2( 0.5, 1.0 ),\n                                        at_angle( vec3(0.0,0.125*PI*sin(iTime*TAU/11.0),iTime*TAU/17.0),\n                                                  at_pos(vec3(2.0,16.0,1.0),pos) ) ),\n                        #if INDEXED_MATERIALS\n                         MAT_ORANGE\n                        #else\n                         orange_m\n                        #endif\n                    ),\n                 res );\n    \n    res =\n       union_op( MPt( half_cone_pos_sd( vec2( 0.5, 1.0 ),\n                                        vec3(1.0,1.0,-1.0) *\n                                        at_angle( vec3(0.0,0.125*PI*sin(iTime*TAU/11.0),iTime*TAU/17.0),\n                                                  at_pos(vec3(2.0,18.0,1.0), pos) ) ),\n                        #if INDEXED_MATERIALS\n                         MAT_ORANGE\n                        #else\n                         orange_m\n                        #endif\n                    ),\n                 res );\n    \n    res =\n       union_op(\n          intersect_op(\n             MPt( half_cone_pos_sd( vec2( 0.5, 1.0 ),\n                                    vec3(1.0,1.0,-1.0) * at_pos(vec3(2.0,20.0,2.0), pos) ),\n                        #if INDEXED_MATERIALS\n                         MAT_ORANGE\n                        #else\n                         orange_m\n                        #endif\n                    ),\n             intersect_op(\n                MPt( half_space_sd( at_pos(vec3(2.0,20.0,1.5), pos) ),\n                     #if INDEXED_MATERIALS\n                      MAT_ORANGE\n                     #else\n                      orange_m\n                     #endif\n                ),\n                MPt( -half_space_sd( at_pos(vec3(2.0,20.0,0.5), pos) ),\n                     #if INDEXED_MATERIALS\n                      MAT_ORANGE\n                     #else\n                      orange_m\n                     #endif\n                )\n             )\n          ),\n          res );\n    \n    res =\n       union_op( MPt( capped_cone_as_intersections_sd(\n                         1.0, 0.25, 0.5, at_pos(vec3(2.0,22.0,0.5), pos) ),\n                      #if INDEXED_MATERIALS\n                       MAT_ORANGE\n                      #else\n                       orange_m\n                      #endif\n                    ),\n                 res );  \n    res =\n       union_op( MPt( capped_cone_as_intersections_sd(\n                         1.0, 0.5, 0.25, at_pos(vec3(2.0,24,0.5), pos) ),\n                      #if INDEXED_MATERIALS\n                       MAT_ORANGE\n                      #else\n                       orange_m\n                      #endif\n                    ),\n                 res );  \n    res =\n       union_op( MPt( capped_cone_as_intersections_sd(\n                         1.0, 0.25, 0.5, at_pos(vec3(2.0,24,1.6 + 0.05 * sin(iTime * TAU / 4.0) ), pos) ),\n                      #if INDEXED_MATERIALS\n                       MAT_ORANGE\n                      #else\n                       orange_m\n                      #endif\n                    ),\n                 res );\n    res =\n       union_op( MPt( hex_prism_sd(vec2(0.5,0.5), at_angle( vec3(iTime*TAU/4.0,0.0,0.0), at_pos(vec3(2.0,26,0.5), pos) ) ),\n                      #if INDEXED_MATERIALS\n                       MAT_ORANGE\n                      #else\n                       orange_m\n                      #endif\n                    ),\n                 res );\n    res =\n       union_op( MPt( hex_prism_sd(vec2(0.5,1.0), at_angle( vec3(iTime*TAU/4.0,0.0,0.0), at_pos(vec3(2.0,28,0.866025), pos) ) ),\n                      #if INDEXED_MATERIALS\n                       MAT_ORANGE\n                      #else\n                       orange_m\n                      #endif\n                    ),\n                 res );\n\treturn res;\n}\n\nvec3\ncalc_normal( in vec3 pos, in float t )\n{\n    vec3 eps = vec3( max(0.02,T_EPS*t),0.0,0.0);\n\treturn normalize( vec3(\n           map( pos + eps.xyy ).distance - map( pos - eps.xyy ).distance,\n           map( pos + eps.yxy ).distance - map( pos - eps.yxy ).distance,\n           map( pos + eps.yyx ).distance - map( pos - eps.yyx ).distance ) );\n}\n\n\n#if INDEXED_MATERIALS\nvec2\n#else\nMaterial_Point\n#endif\nraymarch( in vec3 start, in vec3 dir, inout float t, in float t_max )\n{\n    MPt mp;\n    for ( int it=0; it!=120; ++it )\n    {\n        vec3 here = start + dir * t;\n        mp = map( here );\n        if ( mp.distance < ( T_EPS * t ) || t > t_max )\n        {\n        \tbreak;\n        }\n        #if 1\n        // NOTE(theGiallo): this is to sample nicely the twisted things\n        t += mp.distance * 0.4;\n        #else\n        t += mp.distance;\n        #endif\n    }\n    if ( t > t_max )\n    {\n        t = -1.0;\n    }\n    return mp;\n}\n\nfloat\nshadow( in vec3 start, in vec3 dir )\n{\n    float ret = 1.0;\n    float c = step( mod( iTime, 4.0 ), 2.0 );\n    float t = 0.02, t_max = 16.0;\n    MPt mp;\n    \n    for ( int it=0; it!=16; ++it )\n    {\n        vec3 here = start + dir * t;\n        mp = map( here );\n        ret = min( ret, 8.0*mp.distance/t);\n        if ( mp.distance < ( T_EPS * t ) || t > t_max )\n        {\n        \tbreak;\n        }\n        \n        float inc;\n        // NOTE(theGiallo): this is to sample nicely the twisted things\n        inc = c * mp.distance * 0.4;\n\t\tinc += ( 1.0 - c ) * clamp( mp.distance, 0.02, 0.1 );\n        t += inc;\n    }\n    if ( t > t_max )\n    {\n        t = -1.0;\n    }\n    if ( c == 0.0 ) return 1.0 - clamp( ret, 0.0, 1.0 );\n\n    if ( t < 0.0 )\n    {\n        return 0.0;\n    }\n    //return 1.0;\n    ret = 1.0 / pow(1.0 - 1e-30 + max( mp.distance, 1e-30 ), 5.0 );\n    float th = 0.1;\n    return smoothstep( 0.0, 1.0, ( ret*1.1 - th ) / (1.0-th) );\n}\n\n\nfloat\nimg_scale_given_h_fov( float near, float fov )\n{\n    float hw = iResolution.x / min( iResolution.y, iResolution.x );\n    return tan( fov * 0.5 ) * near / hw;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{    \n\tvec2 q = fragCoord.xy / iResolution.xy;\n    vec2 qc = 2.0 * q - 1.0;\n\tvec2 p = ( 2.0 * fragCoord.xy - iResolution.xy ) / min( iResolution.y, iResolution.x );\n    vec4 col = rgb_from_hsv(vec4(0.57,0.5,0.7,1.0));\n    sky_color = col.rgb;\n    vec3 sun_specular_color = vec3(0.8,1.0,1.0);\n        \n    vec3 sun_light_dir = normalize( vec3( 0.0, 1.0, -1.0 ) );\n    \n    float img_plane_dist = 0.05;\n    float img_scale = img_scale_given_h_fov( img_plane_dist, TAU / 3.0 );\n\n    float time = iTime * PI * 0.06125;\n    vec2 d = vec2(0.0,2.0);\n    #if 0\n    vec2 base = vec2(2.54,-2.0);\n    #else\n    vec2 base = vec2(4.0,-2.0);\n    #endif\n    vec3 camera_pos;\n    #if 1\n    const int p_count = 16;\n    float u = mirror( iTime / ( float(p_count) * 4.0 ) );\n    //u = 1.0;\n    float pu = 1.0 / float(p_count-1);\n    float pt = 0.0;\n    vec2 pxy = vec2(0.0);\n    for ( int i = 0; i!=p_count; ++i )\n    {\n        float s = pu * ( -0.5 + float(i) );\n        pxy +=\n           ( base + d * float(i) ) *\n           ( smoothstep( s - 0.1 * pu, s + 0.1 * pu, u ) - smoothstep( s + pu * 0.9, s + pu * 1.1, u ) );\n    }\n    camera_pos.xy = pxy;\n    camera_pos.z = 1.5;\n    vec3 look = normalize( vec3(-0.5,0.0,-0.1) );\n    #else\n    camera_pos = vec3(1.0,8.0,1.0);\n    vec3 look = normalize( vec3(0.5,0.0,-0.25) );\n    #endif\n\n    vec3 up = vec3(0.0,0.0,1.0);\n    vec3 right = cross( look, up );\n    vec3 img_up = cross( right, look );\n    vec3 dir = look * img_plane_dist + right * p.x * img_scale + img_up * p.y * img_scale;\n    vec3 start = camera_pos + dir;\n    dir = normalize( dir );\n    \n    Material materials_table[MAT_COUNT];\n\n    materials_table[int(MAT_PLASTIC)].color = rgb_from_hsv( vec4(0.083,0.1,1.0,1.0) ).rgb;\n    materials_table[int(MAT_PLASTIC)].diffuse_reflection  = 1.0;\n    materials_table[int(MAT_PLASTIC)].specular_reflection = 1.0;\n    materials_table[int(MAT_PLASTIC)].ambient_reflection  = 1.0;\n    materials_table[int(MAT_PLASTIC)].shininess           = 15.0;\n\n    materials_table[int(MAT_FLOOR_B)].color = vec3(0.7);\n    materials_table[int(MAT_FLOOR_B)].diffuse_reflection  = 1.0;\n    materials_table[int(MAT_FLOOR_B)].specular_reflection = 0.2;\n    materials_table[int(MAT_FLOOR_B)].ambient_reflection  = 0.5;\n    materials_table[int(MAT_FLOOR_B)].shininess           = 1.0;\n\n    materials_table[int(MAT_FLOOR_W)].color = vec3(1.0);\n    materials_table[int(MAT_FLOOR_W)].diffuse_reflection  = 1.0;\n    materials_table[int(MAT_FLOOR_W)].specular_reflection = 0.2;\n    materials_table[int(MAT_FLOOR_W)].ambient_reflection  = 0.5;\n    materials_table[int(MAT_FLOOR_W)].shininess           = 1.0;\n\n    materials_table[int(MAT_ORANGE)] = change_color(materials_table[int(MAT_PLASTIC)], ORANGE_RGB );\n    materials_table[int(MAT_RED   )] = change_color(materials_table[int(MAT_PLASTIC)], vec3(1.0,0.0,0.0) );\n    materials_table[int(MAT_GREEN )] = change_color(materials_table[int(MAT_PLASTIC)], vec3(0.0,1.0,0.0) );\n    materials_table[int(MAT_BLUE  )] = change_color(materials_table[int(MAT_PLASTIC)], vec3(0.0,0.0,1.0) );\n    \n    float t = 0.0;\n    MPt mp = raymarch( start, dir, t, 1e2 );\n    Material mat;\n    #if INDEXED_MATERIALS\n    for ( int i = 0; i != MAT_COUNT; ++i )\n    {\n        if ( i == int(mp.y) )\n        {\n            mat = materials_table[i];\n        }\n\t}\n    #else\n    mat = mp.material;\n    #endif\n    if ( t > 0.0 )\n    {\n        vec3 point = start + dir * t;\n        vec3 normal = calc_normal( point, t );\n        // col.rgb = 0.5 + normal * 0.5;\n        float sh = 1.0 - shadow( point, -sun_light_dir );\n        float diffuse = sh * max( 0.0, dot( normal, -sun_light_dir ) );\n        float spec = sh * pow( max( 0.0, dot( reflect( dir, normal ) , -sun_light_dir ) ), mat.shininess  );\n        float ambient = 0.3;\n        col.rgb = ( diffuse * mat.diffuse_reflection +\n                    ambient * mat.ambient_reflection ) * mat.color +\n                    spec    * mat.specular_reflection * sun_specular_color;\n    } else\n    if ( t == 0.0 )\n    {\n        col.rgb = mat.color / ( 1.0 - 20.0 * mp.distance );\n    }\n    \n    // NOTE(theGiallo): gamma correction\n\t// col.rgb = pow( col.rgb, vec3(0.4545) );\n\n    fragColor = vec4(col.rgb,1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4ltSDj.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[881, 881, 908, 908, 972], [973, 973, 1010, 1010, 1104], [1105, 1105, 1188, 1188, 1384], [1385, 1385, 1481, 1481, 1908], [1909, 1909, 2024, 2024, 2508], [2510, 2551, 2598, 2598, 2690], [2692, 2692, 2717, 2717, 2787], [2789, 2789, 2815, 2815, 2842], [2844, 2875, 2906, 2906, 3554], [3614, 3614, 3639, 3639, 3681], [3683, 3683, 3708, 3708, 3750], [3752, 3752, 3777, 3777, 3807], [3809, 3809, 3834, 3834, 3864], [3868, 3868, 3907, 3907, 3927], [3929, 3929, 3948, 3948, 4157], [4159, 4159, 4196, 4196, 4824], [4826, 4826, 4865, 4865, 4895], [5493, 5493, 5542, 5542, 5605], [5689, 5689, 5735, 5735, 5769], [5771, 5771, 5813, 5813, 5932], [5934, 5934, 5963, 5963, 5988], [5991, 5991, 6025, 6025, 6043], [6045, 6045, 6105, 6105, 6205], [6207, 6271, 6315, 6315, 6392], [6394, 6394, 6438, 6438, 6471], [6473, 6473, 6524, 6524, 6636], [6638, 6638, 6686, 6686, 6765], [6767, 6767, 6806, 6806, 6901], [6903, 6903, 6993, 6993, 7280], [7282, 7415, 7460, 7460, 7552]], "test": "error"}
{"id": "4ltSDl", "name": "Voronoi Diagram (MK)", "author": "Tryton", "description": "Simple Voronoi Diagram in different metrics.", "tags": ["voronoi", "diagram", "voronoidiagram"], "likes": 1, "viewed": 444, "published": "Public API", "date": "1482185976", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float test(vec2 s,vec2 e){\n \treturn mix(abs(reflect(s,e).x),abs(reflect(e,s).x),0.5);\n}\n    \nfloat metric(vec2 s, vec2 e, float p)\n{\n    return pow(pow(abs((e-s).x),p) + pow(abs((e-s).y),p),1.0f/p);\n}\n\nfloat triangular(vec2 s,vec2 e){\n \treturn max(abs((e-s).x)*0.866025+(e-s).y*0.5,-(e-s).y); \n}\n\nfloat supremum(vec2 s,vec2 e){\n \treturn max(abs((e-s).x), abs((e-s).y) );   \n}\n\nfloat manhattan(vec2 s,vec2 e){\n    return abs((e-s).x)+abs((e-s).y);\n}\n\nfloat euclid(vec2 s,vec2 e){\n    return sqrt(dot(s-e,s-e));\n}\n\nfloat river(vec2 s, vec2 e)\n{\n    float x_axis_shift = 0.5;\n    \n    if(s.x==s.y)\n    {\n        return abs(s.y-e.y);\n    }\n    else\n    {\n        return abs(s.y) + abs(e.y) - x_axis_shift + abs(s.x-e.x);\n    }\n}\n\nfloat station(vec2 s, vec2 e)\n{\n    vec2 station_pos = vec2(0.2, 0.2);\n    \n    s = s - station_pos;\n    e = e - station_pos;\n    \n    float s_angle = atan(s.y, s.x);\n  \tfloat e_angle = atan(e.y, e.x);\n    \n    if(s_angle == e_angle)\n    {\n        return euclid(s,e);\n    }\n    else\n    {\n        return euclid(s, station_pos) + euclid(station_pos, e);\n    }\n}\n\nfloat dist(vec2 s,vec2 e){\n \treturn metric(s,e,(sin(iTime) + 1.5f)*5.0f);  \n}\n\nvec3 color(vec2 p){\n    vec2 seeds[16];\n    vec3 colors[16];\n    \n    for(int i=0;i<16;i++){\n        float il = float(i+1);\n     \tvec2 pos = vec2(mod(il*16.0*log(il),1.0),mod(il*log(16.0*il)*exp(1.0/16.0),1.0));\n        float r = 1.0/(16.0+1.0);\n        \n        seeds[i] = vec2(pos.x+ r*cos(iTime+il),pos.y+r*sin(iTime+il));\n        colors[i] = vec3(mod(il*16.0*log(il),1.0),\n                         mod(il*log(16.0*il)*exp(1.0/16.0),1.0),\n                         mod(il*log(1.0/16.0)*exp(1.0/16.0*il),1.0));\n        \n    }\n    \n    float distb = dist(seeds[0], p);\n    vec3 color = colors[0];\n    for (int i = 0; i < 16; i++) {\n        float current = dist(seeds[i], p);\n        if (current < distb) {\n            color = colors[i];\n            distb = current;\n        }\n    }\n    \n    return color;//*(1.0-distb*2.5);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 p = fragCoord.xy / iResolution.y;\n\tfragColor = vec4(color(p),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4ltSDl.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 26, 26, 87], [93, 93, 132, 132, 200], [202, 202, 234, 234, 295], [297, 297, 327, 327, 375], [377, 377, 408, 408, 448], [450, 450, 478, 478, 511], [513, 513, 542, 542, 724], [726, 726, 757, 757, 1086], [1088, 1088, 1114, 1114, 1165], [1167, 1167, 1186, 1186, 1992], [1995, 1995, 2052, 2052, 2127]], "test": "valid"}
{"id": "4ltSDs", "name": "2x2 Voronoi", "author": "antoineMoPa", "description": "I wanted to see if it was possible to generate a Voronoi grid by looking at only 4 points. I've seen this method which uses a 3x3 grid: https://www.shadertoy.com/view/XlB3zW\n\nI made it alternate between Manhattan distance and euclidean distance for fun.", "tags": ["procedural", "2d", "voronoi"], "likes": 5, "viewed": 555, "published": "Public API", "date": "1482210495", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/*\n  I wanted to see if it was possible to generate a Voronoi grid by looking \n  at only 4 points. \n\n  I had seen this method which uses a 3x3 grid: https://www.shadertoy.com/view/XlB3zW\n\n  Conclusion: This seems to work under certain conditions. The points must not be\n  too far away from their grid position. When the factor is increased in point_for(),\n  glitches begin to appear.\n \n\n*/\nuniform float time;\nuniform float ratio;\nuniform vec2 mouse;\n\nfloat manhattan_distance(vec2 p1, vec2 p2){\n    return abs(p1.y - p2.y) + abs(p1.x - p2.x);\n}\n\nvec2 point_for(vec2 in_pos){\n    vec2 pos = vec2(0.0);\n    \n    // Change the 0.2 factor and you'll see glitches\n    pos = 0.2 * vec2(\n        sin(in_pos.x * 100.0 + cos(130.0 * in_pos.y) + 0.2 * sin(4.0 * pos.y)),\n        sin(in_pos.x * 35.0 + cos(220.0 * in_pos.y) + 0.3 * sin(4.0 * pos.y))\n        ) + 0.5;\n    \n    return in_pos + pos;\n}\n\n/*\n  r : distance to nearest point\n  g : nothing\n  b : index of point\n */\nvec4 voronoi(vec2 pos){\n    vec4 col = vec4(0.0);\n    vec2 fpos = floor(pos);\n\n    // Points\n    vec2 ps[4];\n    // Function value for these points\n    vec2 fs[4];\n    \n\t// Find points around current point        \n    ps[0] = fpos + vec2(-0.5,  0.5);\n    ps[1] = fpos + vec2(0.5,   0.5);\n    ps[2] = fpos + vec2(-0.5, -0.5);\n    ps[3] = fpos + vec2(0.5,  -0.5);\n    \n    // Function values\n    fs[0] = point_for(ps[0]);\n    fs[1] = point_for(ps[1]);\n    fs[2] = point_for(ps[2]);\n    fs[3] = point_for(ps[3]);\n    \n    float d = 10.0;\n    \n    for(int i = 0; i < 4; i++){\n        // Alternate between manhattan distance and \n        // euclidean distance\n        float dist_fac = 0.5 * sin(iTime) + 0.5;\n        float man = manhattan_distance(fs[i], pos);\n        float dist = distance(fs[i], pos);\n        float curr_dist = \n            dist_fac * \n            man +\n            (1.0 - dist_fac) *\n            dist;\n            \n        \n        if(curr_dist < d){\n            col.g = d - curr_dist;\n            d = curr_dist;\n            col.r = d;\n            col.b = float(i) / 4.0;\n        }\n    }\n\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.y;\n    vec2 pos = uv;\n    \n    vec4 col = vec4(0.4, 0.7, 1.0, 1.0);\n    \n    pos.x += 0.1 * iTime;\n    pos.y -= 0.1 * iTime;\n    \n    vec4 voro = voronoi(10.0 * pos);\n\tvec4 voro2 = voronoi(70.0 * pos);\n   \n    \n    float d = voro.r; // Distance\n\n    if(voro.g < 0.1){\n        // edge\n        col = vec4(0.1);\n    }\n    \n    if(voro2.g < 0.2){\n    \tcol *= 0.8;\n    }\n    \n    if(d < 0.08){\n    \tcol *= 0.8;\n    }\n    \n    col.a = 1.0;\n    \n    fragColor = col;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4ltSDs.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[452, 452, 495, 495, 545], [547, 547, 575, 575, 888], [890, 964, 987, 987, 2085], [2087, 2087, 2144, 2144, 2644]], "test": "error"}
{"id": "4ltSzf", "name": "Bryan's mushroom", "author": "bsugiarto", "description": "mushroom", "tags": ["mushroom"], "likes": 2, "viewed": 80, "published": "Public", "date": "1480911548", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const float MATH_PI = float( 3.14159265359 );\n\n/* documented in sun */\nfloat VisibilityTerm( float roughness, float ndotv, float ndotl )\n{\n    float m2    = roughness * roughness;\n    float visV  = ndotl * sqrt( ndotv * ( ndotv - ndotv * m2 ) + m2 );\n    float visL  = ndotv * sqrt( ndotl * ( ndotl - ndotl * m2 ) + m2 );\n    return 0.5 / max( visV + visL, 0.00001 );\n}\n\n/*documented in sun */\nfloat DistributionTerm( float roughness, float ndoth )\n{\n    float m2    = roughness * roughness;\n    float d     = ( ndoth * m2 - ndoth ) * ndoth + 1.0;\n    return m2 / ( d * d * MATH_PI );\n}\n\n/* documented in sun */\nvec3 FresnelTerm( vec3 specularColor, float vdoth )\n{\n    vec3 fresnel = clamp( 50.0 * specularColor.y, 0.0, 1.0 ) * specularColor + ( 1.0 - specularColor ) * pow( ( 1.0 - vdoth ), 5.0 );\n    return fresnel;\n}\n\n/* documented in sun */\nvec3 LightSpecular( vec3 normal, vec3 viewDir, vec3 lightDir, vec3 lightColor, float roughness, vec3 specularColor )\n{\n    vec3 halfVec = normalize( viewDir + lightDir );\n\n    float vdoth = clamp( dot( viewDir,  halfVec  ), 0.0, 1.0 );\n    float ndoth = clamp( dot( normal,   halfVec  ), 0.0, 1.0 );\n    float ndotv = clamp( dot( normal,   viewDir  ), 0.0, 1.0 );\n    float ndotl = clamp( dot( normal,   lightDir ), 0.0, 1.0 );\n    \n    vec3    f = FresnelTerm( specularColor, vdoth );\n    float   d = DistributionTerm( roughness, ndoth );\n    float   v = VisibilityTerm( roughness, ndotv, ndotl );\n    \n    vec3 specular;\n    specular = lightColor * f * ( d * v * MATH_PI * ndotl );\n    return specular;\n}\n\n/* documented in sun */\nfloat Sphere( vec3 p, float s )\n{\n    return length( p ) - s;\n}\n\n/* used to create a box function */\nfloat Box( vec3 p, vec3 b )\n{\n    vec3 d = abs( p ) - b;\n    return min( max( d.x, max( d.y, d.z ) ), 0.0 ) + length( max( d, 0.0 ) );\n}\n\n/* removes fu*/\nfloat Substract( float a, float b )\n{\n    return max( a, -b );\n}\n\n/* documented in sun */\nfloat UnionRound( float a, float b, float k )\n{\n    float h = clamp( 0.5 + 0.5 * ( b - a ) / k, 0.0, 1.0 );\n    return mix( b, a, h ) - k * h * ( 1.0 - h );\n}\n\n\n\n/* scene to make a mushroom */\nfloat Scene( vec3 p, mat3 localToWorld )\n{\n    p = p * localToWorld;\n    \n    float a = Sphere( p + vec3( -0.5, 0.0, 0.0 ), 1.6 );\n    float c = Box( p + vec3( -1.5, 0.0, 0.0 ), vec3( 1.5, 2.5, 2.5 ) );\n    float stem = Box( p + vec3( -1., 0.0, 0.0 ), vec3( .8, .2, .2 ) );\n    float ring2 = Substract( a, c );\n    float ring3 = UnionRound(ring2, stem, 1.);\n    return ring3;\n}\n\n/* documented in sun */\nfloat CastRay( in vec3 ro, in vec3 rd, mat3 localToWorld )\n{\n    const float maxd = 5.0;\n    \n    float h = 0.5;\n    float t = 0.0;\n   \n    for ( int i = 0; i < 50; ++i )\n    {\n        if ( h < 0.001 || t > maxd ) \n        {\n            break;\n        }\n        \n        h = Scene( ro + rd * t, localToWorld );\n        t += h;\n    }\n\n    if ( t > maxd )\n    {\n        t = -1.0;\n    }\n    \n    return t;\n}\n\n/* documented in sun */\nvec3 SceneNormal( in vec3 pos, mat3 localToWorld )\n{\n    vec3 eps = vec3( 0.001, 0.0, 0.0 );\n    vec3 nor = vec3(\n        Scene( pos + eps.xyy, localToWorld ) - Scene( pos - eps.xyy, localToWorld ),\n        Scene( pos + eps.yxy, localToWorld ) - Scene( pos - eps.yxy, localToWorld ),\n        Scene( pos + eps.yyx, localToWorld ) - Scene( pos - eps.yyx, localToWorld ) );\n    return normalize( -nor );\n}\n\n/* same main as sun except texture is modified */\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 q = fragCoord.xy / iResolution.xy;\n    vec2 p = -1.0 + 2.0 * q;\n    p.x *= iResolution.x / iResolution.y;\n\n    vec3 rayOrigin  = vec3( 0.0, -0.28, -3.5 );\n    vec3 rayDir     = normalize( vec3( p.x, p.y, 2.0 ) );\n    \n    float theta = -0.5 * MATH_PI  ;\n    mat3 rotX = mat3(\n        vec3( cos( theta ), sin( theta ), 0.0 ),\n        vec3( -sin( theta ), cos( theta ), 0.0 ),\n        vec3( 0.0, 0.0, 1.0 )\n        );    \n    \n    vec2 mo = iMouse.xy / iResolution.xy;    \n    float phi = 0.25 * MATH_PI + 2.0 * iTime + 10.0 * mo.x;  \n    \n    mat3 rotY = mat3(\n        vec3( 1.0, 0.0, 0.0 ),\n        vec3( 0.0, cos( phi ), sin( phi ) ),\n        vec3( 0.0, -sin( phi ), cos( phi ) )\n        );\n    \n    mat3 localToWorld = rotX * rotY;    \n\n\n    vec3 color = texture( iChannel1, q ).yyy * 0.3;\n    \n    float t = CastRay( rayOrigin, rayDir, localToWorld );\n    if ( t > 0.0 )\n    {\n        vec3 pos = rayOrigin + t * rayDir;\n        vec3 normal = SceneNormal( pos, localToWorld );\n        vec3 lightDir = normalize( vec3( 0.5, 0.3, 1.0 ) );\n        vec3 lightColor = vec3( 1.6 );\n        \n        vec3 posLS = pos * localToWorld;\n        vec3 nrmLS = normal * localToWorld;\n        vec2 uvX = posLS.yz;\n        vec2 uvY = posLS.xz;\n        vec2 uvZ = posLS.xy;\n        \n        vec3 textureX = texture( iChannel0, uvX ).xyz;\n        vec3 textureY = texture( iChannel0, uvY ).xyz;\n        vec3 textureZ = texture( iChannel0, uvZ ).xyz;\n        \n        vec3 weights = max( abs( nrmLS ), 0.00001 );\n        weights /= weights.x + weights.y + weights.z;\n        \n        vec3 texture = textureX * weights.x + textureY * weights.y + textureZ * weights.z;\n     \n        vec3 diffuseColor = texture + vec3(.1,.1,.5);\n        diffuseColor *= diffuseColor * vec3( 0.94, 0.72, 0.47 ) * 1.5;\n        vec3 specularColor =  vec3( 0.04 ) ;\n        float roughness =  1.3 ;\n        \n        vec3 diffuse = lightColor * clamp( dot( normal, lightDir ), 0.0, 1.0 );\n        color = diffuseColor * ( diffuse + 0.2 );\n        color += LightSpecular( normal, rayDir, lightDir, lightColor, roughness, specularColor );\n\n    }\n    \n    fragColor = vec4( color, 1.0 );\n}\n\n", "image_inputs": [{"id": "XsXGRn", "previewfilepath": "/media/ap/cd4c518bc6ef165c39d4405b347b51ba40f8d7a065ab0e8d2e4f422cbc1e8a43.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/cd4c518bc6ef165c39d4405b347b51ba40f8d7a065ab0e8d2e4f422cbc1e8a43.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4ltSzf.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[47, 71, 138, 138, 369], [371, 394, 450, 450, 586], [588, 612, 665, 665, 821], [823, 847, 965, 965, 1553], [1555, 1579, 1612, 1612, 1642], [1644, 1680, 1709, 1709, 1816], [1818, 1834, 1871, 1871, 1898], [1900, 1924, 1971, 1971, 2082], [2086, 2117, 2159, 2159, 2494], [2496, 2520, 2580, 2580, 2924], [2926, 2950, 3002, 3002, 3352], [3354, 3404, 3461, 3461, 5615]], "test": "error"}
{"id": "4ltXDB", "name": "Complex plotting", "author": "ichko", "description": "complex function plotter", "tags": ["math", "complex", "functions"], "likes": 3, "viewed": 135, "published": "Public", "date": "1481495870", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float gridSize = 0.05;\nfloat eps = 0.005;\n\nvec2 complexPow(vec2 c, float d) {\n    float a = atan(c.y, c.x) * d;\n    return pow(length(c), d) * vec2(cos(a), sin(a));\n}\n\nfloat grid(vec2 p) {\n    p *= vec2(1.);\n    p += vec2(0.025);\n    return min(abs(mod(p.y, gridSize)),\n               abs(mod(p.x, gridSize)));\n}\n\nvec2 transform(vec2 i, float param) {\n    vec2 r = i;\n    r.x *= sin(param + i.y) * 0.5 + 1.2;\n    r.y *= cos(param + i.x) * 0.5 + 1.2;\n    r = complexPow(r, 2.);\n    \n    return r;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n    vec2 res = iResolution.xy;\n\tvec2 uv = (fragCoord - 0.5 * res) / res.y;\n    \n    \n    float col = float(grid(transform(uv, iTime / 5.)) < eps);\n    \n\tfragColor = vec4(col);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4ltXDB.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[43, 43, 77, 77, 166], [168, 168, 188, 188, 312], [314, 314, 351, 351, 497], [499, 499, 553, 553, 731]], "test": "valid"}
{"id": "4ltXDs", "name": "Ballons", "author": "Seledorn", "description": " Just playing a little with 2D distance fields :) Based on Umbrellar by candycat.\n", "tags": ["2d"], "likes": 10, "viewed": 221, "published": "Public", "date": "1482235705", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// based on Umbrellar by candycat\n\nfloat circle(vec2 center, float radius, vec2 coord )\n{\n    return length(center-coord) - radius;\n}\n\nfloat square(vec2 center,float radius, vec2 coord)\n{\n    vec2 d = coord-center;\n\treturn max(abs(d.x),abs(d.y))-radius;\n}\n\nfloat rect(vec2 center, float half_width, float half_height,vec2 coord)\n{\n    vec2 p = coord-center;\n\treturn max(abs(p.x)-half_width,abs(p.y)-half_height);\n}\n\nfloat perc_in_range_clamped(float edge0, float edge1, float value)\n{\n    return clamp((value-edge0)/(edge1-edge0),0.0,1.0);\n}\n\nfloat trapetzoid(vec2 center, float upper_half_width, float lower_half_width, float half_height, vec2 coord)\n{\n    vec2 p = coord-center;\n    float width = mix(upper_half_width,lower_half_width,perc_in_range_clamped(-half_height,half_height,p.y));\n\treturn rect(center,width,half_height,coord);\n}\n\n\nfloat line(vec2 p0, vec2 p1, float width, vec2 coord)\n{\n    vec2 dir0 = p1 - p0;\n\tvec2 dir1 = coord - p0;\n\tfloat h = clamp(dot(dir0, dir1)/dot(dir0, dir0), 0.0, 1.0);\n\treturn (length(dir1 - dir0 * h) - width * 0.5);\n}\n\nfloat opSU( float a, float b, float k )\n{\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\n\nfloat opU( const float a, const float b )\n{\n    return min(a, b);\n}\n\nfloat opS( const float a, const float b)\n{\n    return max(a, -b);\n}\n\nfloat opI( const float a, const float b )\n{\n    return max(a, b);\n}\n\nfloat f_width(float f)\n{\n    return pow((pow(dFdx(f),2.0) + pow(dFdy(f),2.0)),0.5);\n}\n\n\n\nvec4 render(float d, vec3 color, float stroke)\n{\n    float fw = f_width(d);\n    float anti = fw * 1.0;\n    float fw_stroke = fw*stroke;\n    vec4 strokeLayer = vec4(vec3(0.05), 1.0-smoothstep(-anti, anti, d - fw_stroke));\n    vec4 colorLayer = vec4(color, 1.0-smoothstep(-anti, anti, d));\n\n    if (stroke < 0.000001) {\n    \treturn colorLayer;\n    }\n    //return mix(vec4(0.0),vec4(1.0),smoothstep(0.0,0.04,d));\n    return  vec4(mix(strokeLayer.rgb, colorLayer.rgb, colorLayer.a), strokeLayer.a);\n\n}\n\nfloat ballon(vec2 center, float radius, vec2 coord,float pearness)\n{\n    float enlongation = pearness*radius;\n    float l = line(center,center -vec2(0.0,enlongation+radius),0.75*radius,coord);\n    float c = circle(center,radius,coord);\n    float t = trapetzoid(center-vec2(0.0,enlongation+1.44*radius),0.1*radius,0.02*radius,0.1*radius,coord);\n    return opSU(t,opSU(l,c,0.5*radius),0.03*radius);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = (2.0*fragCoord.xy-iResolution.xy)/min(iResolution.y,iResolution.x);\n\n    float size = min(iResolution.x, iResolution.y);\n    float pixSize = 1.0 / size;\n\tvec2 uv = fragCoord.xy / iResolution.x;\n    float stroke = 1.5;\n    vec2 center = vec2(0.0,0.0);\n    \n    vec3 white = vec3(1.0);\n    vec3 black = vec3(0.0);\n    vec3 blue  = vec3(0.4,0.5,0.6);\n    vec3 red   = vec3(0.8,0.3,0.3);\n    vec3 green = vec3(0.4,0.7,0.4);\n   \tvec3 yellow = vec3(0.8,0.8,0.3);\n   \tvec3 orange = vec3(0.8,0.4,0.15);\n    vec3 colors[5];\n    colors[0]=blue;\n    colors[1]=red;\n    colors[2]=green;\n    colors[3]=yellow;\n    colors[4]=orange;\n\n    vec4 layer0 = vec4(0.0);\n\tvec4 layer1 = vec4(0.0);\n    vec3 bcol = blue*1.5*(1.0-0.30*length(p));\n    \n        \n    fragColor = vec4(bcol, 1.0);  \n    for(float i = 0.0; i < 20.0;i++)\n    {\n        float r = mod(i * 101.0,31.0);//silly random\n        float theta = iTime + r;\n        center = vec2(0.2*i-1.7,sin(theta)*2.3*sign(cos(theta))); //d/dx sin = cos, dir(sin) = sign(cos) \n        center += vec2(sin(center.y*2.0)/10.0,0.0);\n        \n        vec4 b = render(ballon(center,0.4+0.1*sin(theta),p,sin(r)*0.2),\n                        colors[int(mod(mod(i*101.0,31.0),5.0))],1.5); //rcalc r, can't store because of const\n        fragColor = mix(fragColor, b, b.a);\n    }\n    \n   \n    \n    fragColor.rgb = pow(fragColor.rgb, vec3(1.0/2.2));\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4ltXDs.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[35, 35, 89, 89, 133], [135, 135, 187, 187, 255], [257, 257, 330, 330, 414], [416, 416, 484, 484, 541], [543, 543, 653, 653, 838], [841, 841, 896, 896, 1058], [1060, 1060, 1101, 1101, 1194], [1197, 1197, 1240, 1240, 1264], [1266, 1266, 1308, 1308, 1333], [1335, 1335, 1378, 1378, 1402], [1404, 1404, 1428, 1428, 1489], [1493, 1493, 1541, 1541, 1990], [1992, 1992, 2060, 2060, 2390], [2392, 2392, 2449, 2449, 3832]], "test": "valid"}
{"id": "4ltXz2", "name": "Integer Noise Test", "author": "lherm", "description": "Playing with raymarching and noise on an plane", "tags": ["noise"], "likes": 11, "viewed": 297, "published": "Public", "date": "1480658007", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Structure based on https://www.shadertoy.com/view/Xt2XDt by Cabbibo\n\n#define MIRROR\n\nconst int S = 32; // steps\nconst float D = 100.; // max distance\nconst float P = 0.001; // intersection precision\n\n// iq noise\nfloat hash( float n )\n{\n    return fract(sin(n)*43758.5453123);\n}\n\nfloat noise( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n\t\n    float n = p.x + p.y*157.0 + 113.0*p.z;\n    return mix(mix(mix( hash(n+  0.0), hash(n+  1.0),f.x),\n                   mix( hash(n+157.0), hash(n+158.0),f.x),f.y),\n               mix(mix( hash(n+113.0), hash(n+114.0),f.x),\n                   mix( hash(n+270.0), hash(n+271.0),f.x),f.y),f.z);\n}\n\n//-------------------\n// Camera\n//-------------------\nmat3 calcLookAtMatrix( in vec3 ro, in vec3 ta, in float roll )\n{\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(sin(roll),cos(roll),0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n    return mat3( uu, vv, ww );\n}\n\n\nvec2 opU( vec2 d1, vec2 d2 )\n{\n    \n\treturn (d1.x<d2.x) ? d1 : d2;\n    \n}\n\nfloat sdPlane(in vec3 p, in vec4 n)\n{\n    return dot(p, n.xyz) + n.w;\n}\n\n\n//-------------------\n// Modelling\n//-------------------\n\nvec2 map(in vec3 p)\n{\n    vec3 ip = floor(p * 1.5);\n    vec3 np = vec3(noise(ip), noise(ip), noise(ip));\n    float s = sdPlane(vec3(p), vec4(0., 1., noise(np + iTime), 1.));\n    vec2 res = vec2(s, 1.);\n    return res;\n}\n\nvec2 trace(in vec3 ro, in vec3 rd)\n{\n    float h = P*2.;\n    float t = 0.;\n    float id = -1.;\n    float res = -1.;\n    \n    for (int i = 0; i < S; i++)\n    {\n        if (h<P || t>D) break;\n        vec3 r = ro + rd*t;\n        h = map(r).x;\n        t += h;\n        id = map(r).y;\n    }\n    \n    if (t < D) res = t;\n    if (t > D) id = -1.;\n    \n    return vec2(res, id);\n}\n\nvec3 calcNormal( in vec3 pos ){\n    \n\tvec3 eps = vec3( 0.001, 0.0, 0.0 );\n\tvec3 nor = vec3(\n\t    map(pos+eps.xyy).x - map(pos-eps.xyy).x,\n\t    map(pos+eps.yxy).x - map(pos-eps.yxy).x,\n\t    map(pos+eps.yyx).x - map(pos-eps.yyx).x );\n\treturn normalize(nor);\n}\n\nfloat calcAO( in vec3 pos, in vec3 nor )\n{\n\tfloat occ = 0.0;\n    float sca = 1.0;\n    for( int i=0; i<5; i++ )\n    {\n        float hr = 0.01 + 0.12*float(i)/4.0;\n        vec3 aopos =  nor * hr + pos;\n        float dd = map( aopos ).x;\n        occ += -(dd-hr)*sca;\n        sca *= 0.95;\n    }\n    return clamp( 1.0 - 3.0*occ, 0.0, 1.0 );    \n}\n\nvec3 render(in vec2 res, in vec3 ro, in vec3 rd)\n{\n    vec3 color = vec3(0.);\n    vec3 lightPos = vec3( 1. , 4. , 3. );\n    \n    if (res.y > -.5)\n    {\n        vec3 p = ro + rd*res.x;\n        vec3 norm = calcNormal(p);      \n        vec3 lightDir = normalize(lightPos - p);\n        float match = max( 0. , dot( lightDir , norm ));\n        float occ = calcAO(p, norm);\n        \n        if (res.y == 1.)\n        {\n            color = vec3(1.) * match * occ * (1.0-calcAO(p, rd));\n        }\n    }\n    \n    return color;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = (-iResolution.xy + 2.0*fragCoord.xy)/iResolution.y;\n    \n    #ifdef MIRROR\n    uv = -abs(uv);\n    #endif\n    \n    vec3 ro = vec3(0., 0., 4.);\n    vec3 ta = vec3(0., 0., 0.);\n    \n    // Camera Matrix\n    mat3 camMat = calcLookAtMatrix( ro, ta, 0. );  // 0.0 is the camera roll\n    \n    // Create view ray\n\tvec3 rd = normalize( camMat * vec3(uv.xy,2.0) ); // 2.0 is the lens length\n    \n    vec2 res = trace(ro, rd);\n    \n    vec3 color = render(res, ro, rd);\n    \n\tfragColor = vec4(color,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4ltXz2.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[203, 215, 238, 238, 280], [282, 282, 308, 308, 677], [679, 733, 797, 797, 975], [978, 978, 1008, 1008, 1051], [1053, 1053, 1090, 1090, 1124], [1185, 1185, 1206, 1206, 1404], [1406, 1406, 1442, 1442, 1777], [1779, 1779, 1810, 1810, 2036], [2038, 2038, 2080, 2080, 2379], [2381, 2381, 2431, 2431, 2899], [2901, 2901, 2958, 2958, 3465]], "test": "valid"}
{"id": "4lyXz1", "name": "2d rainbow rain", "author": "towc", "description": "trying to recreate a codepen thing of mine: http://codepen.io/towc/pen/VYbYvQ", "tags": ["2d", "rainbow"], "likes": 6, "viewed": 466, "published": "Public", "date": "1482744842", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define v3 vec3\n\nvec3 h2rgb( float hue ){\n    \n  float h = abs(hue - floor(hue)) * 6.;\n  vec3 c = vec3( 0., 0., 0. );\n   \n  int f = int(floor( h ));\n    \n  if(f==0)c=v3(1.,h,0.);else if(f==1)c=v3(2.-h,1.,0.);else if(f==2)c=v3(0.,1.,h-2.);else if(f==3)c=v3(0.,4.-h,1.);else if(f==4)c=v3(h-4.,0.,1.);else c=v3(1.,0.,6.-h);\n  return c;\n}\nfloat mod2( float x, float y ){\n\treturn fract(x*y)*y;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 q = fragCoord.xy;\n    \n    float light = mod2( iTime / 5000. + sin( q.y*q.y*q.y / 1e10 ) + cos( q.x * 3. ), iResolution.y );\n\tfragColor = vec4( h2rgb( q.x / iResolution.x ) / light, 1 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4lyXz1.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[17, 17, 41, 41, 334], [335, 335, 366, 366, 390], [392, 392, 449, 449, 644]], "test": "valid"}
{"id": "4t3SDl", "name": "Hifi Logo", "author": "jherico", "description": "Building a logo out of raymarched primitives", "tags": ["raymarching", "logo"], "likes": 0, "viewed": 461, "published": "Public API", "date": "1482013312", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Bradley Austin Davis on 2016/12/17\n// Based on https://www.shadertoy.com/view/Xds3zN created by inigo quilez - iq/2013\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\nfloat length2( vec2 p )\n{\n\treturn sqrt( p.x*p.x + p.y*p.y );\n}\n\nfloat length6( vec2 p )\n{\n\tp = p*p*p; p = p*p;\n\treturn pow( p.x + p.y, 1.0/6.0 );\n}\n\nfloat length8( vec2 p )\n{\n\tp = p*p; p = p*p; p = p*p;\n\treturn pow( p.x + p.y, 1.0/8.0 );\n}\n\nfloat sdTorus82( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length2(p.xz)-t.x,p.y);\n  return length8(q)-t.y;\n}\n\n//----------------------------------------------------------------------\n\nfloat opS( float d1, float d2 )\n{\n    return max(-d2,d1);\n}\n\nvec2 opU( vec2 d1, vec2 d2 )\n{\n\treturn (d1.x<d2.x) ? d1 : d2;\n}\n\nvec3 opRep( vec3 p, vec3 c )\n{\n    return mod(p,c)-0.5*c;\n}\n\n\nconst float WIDTH = 0.32;\nconst float HALF_WIDTH = WIDTH;\nconst float PI = 3.14159265359;\nconst vec3 AXIS = vec3(0.0, 1.0, 0.0);\nconst float ANGLE = PI / -3.0;\nconst float S = sin(ANGLE);\nconst float C = cos(ANGLE);\nconst float OC = 1.0 - C;\nconst mat3 ROT = mat3(\n    OC * AXIS.x * AXIS.x + C,           OC * AXIS.x * AXIS.y - AXIS.z * S,  OC * AXIS.z * AXIS.x + AXIS.y * S,\n    OC * AXIS.x * AXIS.y + AXIS.z * S,  OC * AXIS.y * AXIS.y + C,           OC * AXIS.y * AXIS.z - AXIS.x * S,\n    OC * AXIS.z * AXIS.x - AXIS.y * S,  OC * AXIS.y * AXIS.z + AXIS.x * S,  OC * AXIS.z * AXIS.z + C\n);\n\n\nvec2 map( in vec3 pos )\n{\n    vec2 res = vec2(1e9, 0.9);\n    res = opU( res, vec2( sdTorus82(pos.xzy, vec2(1.0,0.05) ), 25.0 ));\n    res = opU( res, vec2( sdTorus82(   pos.xzy - vec3(HALF_WIDTH, 0.0, 0.4), vec2(0.05,0.05) ), 95.0 ));\n    res = opU( res, vec2( sdTorus82(   pos.xzy - vec3(-HALF_WIDTH, 0.0, 0.6), vec2(0.05,0.05) ), 95.0 ));\n    res = opU( res, vec2( sdTorus82(   pos.xzy - vec3(-HALF_WIDTH, 0.0, -0.4), vec2(0.05,0.05) ), 95.0 ));\n    res = opU( res, vec2( sdTorus82(   pos.xzy - vec3(HALF_WIDTH, 0.0, -0.6), vec2(0.05,0.05) ), 95.0 ));\n    res = opU( res, vec2( sdBox(   pos.xzy - vec3(HALF_WIDTH, 0.0, -0.1), vec3(0.05,0.05,0.55) ), 95.0 ));\n    res = opU( res, vec2( sdBox(   pos.xzy - vec3(-HALF_WIDTH, 0.0, 0.1), vec3(0.05,0.05,0.55) ), 95.0 ));\n    res = opU( res, vec2( sdBox(  (ROT * pos.xzy), vec3(0.05,0.05,0.35) ), 95.0 ));\n    return res;\n}\n\nvec2 castRay( in vec3 ro, in vec3 rd )\n{\n    float tmin = 1.0;\n    float tmax = 20.0;\n\tfloat precis = 0.002;\n    float t = tmin;\n    float m = -1.0;\n    for( int i=0; i<50; i++ )\n    {\n\t    vec2 res = map( ro+rd*t );\n        if( res.x<precis || t>tmax ) break;\n        t += res.x;\n\t    m = res.y;\n    }\n\n    if( t>tmax ) m=-1.0;\n    return vec2( t, m );\n}\n\n\nfloat softshadow( in vec3 ro, in vec3 rd, in float mint, in float tmax )\n{\n\tfloat res = 1.0;\n    float t = mint;\n    for( int i=0; i<16; i++ )\n    {\n\t\tfloat h = map( ro + rd*t ).x;\n        res = min( res, 8.0*h/t );\n        t += clamp( h, 0.02, 0.10 );\n        if( h<0.001 || t>tmax ) break;\n    }\n    return clamp( res, 0.0, 1.0 );\n\n}\n\nvec3 calcNormal( in vec3 pos )\n{\n\tvec3 eps = vec3( 0.001, 0.0, 0.0 );\n\tvec3 nor = vec3(\n\t    map(pos+eps.xyy).x - map(pos-eps.xyy).x,\n\t    map(pos+eps.yxy).x - map(pos-eps.yxy).x,\n\t    map(pos+eps.yyx).x - map(pos-eps.yyx).x );\n\treturn normalize(nor);\n}\n\nfloat calcAO( in vec3 pos, in vec3 nor )\n{\n\tfloat occ = 0.0;\n    float sca = 1.0;\n    for( int i=0; i<5; i++ )\n    {\n        float hr = 0.01 + 0.12*float(i)/4.0;\n        vec3 aopos =  nor * hr + pos;\n        float dd = map( aopos ).x;\n        occ += -(dd-hr)*sca;\n        sca *= 0.95;\n    }\n    return clamp( 1.0 - 3.0*occ, 0.0, 1.0 );    \n}\n\n\n\n\nvec3 render( in vec3 ro, in vec3 rd )\n{ \n    vec3 col = vec3(0.7, 0.9, 1.0) +rd.y*0.8;\n    vec2 res = castRay(ro,rd);\n    float t = res.x;\n\tfloat m = res.y;\n    if( m>-0.5 )\n    {\n        vec3 pos = ro + t*rd;\n        vec3 nor = calcNormal( pos );\n        vec3 ref = reflect( rd, nor );\n        \n        // material        \n\t\tcol = 0.45 + 0.3*sin( vec3(0.05,0.08,0.10)*(m-1.0) );\n\t\t\n        if( m<1.5 )\n        {\n            \n            float f = mod( floor(5.0*pos.z) + floor(5.0*pos.x), 2.0);\n            col = 0.4 + 0.1*f*vec3(1.0);\n        }\n\n        // lighitng        \n        float occ = calcAO( pos, nor );\n\t\tvec3  lig = normalize( vec3(-0.6, 0.7, -0.5) );\n\t\tfloat amb = clamp( 0.5+0.5*nor.y, 0.0, 1.0 );\n        float dif = clamp( dot( nor, lig ), 0.0, 1.0 );\n        float bac = clamp( dot( nor, normalize(vec3(-lig.x,0.0,-lig.z))), 0.0, 1.0 )*clamp( 1.0-pos.y,0.0,1.0);\n        float dom = smoothstep( -0.1, 0.1, ref.y );\n        float fre = pow( clamp(1.0+dot(nor,rd),0.0,1.0), 2.0 );\n\t\tfloat spe = pow(clamp( dot( ref, lig ), 0.0, 1.0 ),16.0);\n        \n        dif *= softshadow( pos, lig, 0.02, 2.5 );\n        dom *= softshadow( pos, ref, 0.02, 2.5 );\n\n\t\tvec3 lin = vec3(0.0);\n        lin += 1.20*dif*vec3(1.00,0.85,0.55);\n\t\tlin += 1.20*spe*vec3(1.00,0.85,0.55)*dif;\n        lin += 0.20*amb*vec3(0.50,0.70,1.00)*occ;\n        lin += 0.30*dom*vec3(0.50,0.70,1.00)*occ;\n        lin += 0.30*bac*vec3(0.25,0.25,0.25)*occ;\n        lin += 0.40*fre*vec3(1.00,1.00,1.00)*occ;\n\t\tcol = col*lin;\n\n    \tcol = mix( col, vec3(0.8,0.9,1.0), 1.0-exp( -0.002*t*t ) );\n\n    }\n\n\treturn vec3( clamp(col,0.0,1.0) );\n}\n\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr )\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 q = fragCoord.xy/iResolution.xy;\n    vec2 p = -1.0+2.0*q;\n\tp.x *= iResolution.x/iResolution.y;\n    vec2 mo = iMouse.xy/iResolution.xy;\n\t\t \n\tfloat time = 15.0 + iTime;\n\n\t// camera\t\n\tvec3 ro = vec3( -0.5+3.5*cos(0.1*time + 6.0*mo.x), 1.0 + 2.0*mo.y, 0.5 + 3.5*sin(0.1*time + 6.0*mo.x) );\n\tvec3 ta = vec3( 0.0, 0.0, 0.0 );\n\t\n\t// camera-to-world transformation\n    mat3 ca = setCamera( ro, ta, 0.0 );\n    \n    // ray direction\n\tvec3 rd = ca * normalize( vec3(p.xy,2.0) );\n\n    // render\t\n    vec3 col = render( ro, rd );\n\n\tcol = pow( col, vec3(0.4545) );\n\n    fragColor=vec4( col, 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4t3SDl.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[210, 210, 241, 241, 328], [330, 330, 355, 355, 392], [394, 394, 419, 419, 477], [479, 479, 504, 504, 569], [571, 571, 606, 606, 673], [749, 749, 782, 782, 808], [810, 810, 840, 840, 873], [875, 875, 905, 905, 934], [1530, 1530, 1555, 1555, 2398], [2400, 2400, 2440, 2440, 2755], [2758, 2758, 2832, 2832, 3093], [3095, 3095, 3127, 3127, 3348], [3350, 3350, 3392, 3392, 3691], [3696, 3696, 3735, 3735, 5306], [5308, 5308, 5360, 5360, 5537], [5539, 5539, 5596, 5596, 6188]], "test": "error"}
{"id": "4t3SWS", "name": "Space manipulations", "author": "tiagosr", "description": "Old raymarching experiment I bundled with ofxShadertoy, without the camera matrix (for the moment)", "tags": ["raymarching", "shading"], "likes": 1, "viewed": 111, "published": "Public", "date": "1481300527", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const float VERY_LARGE_DISTANCE = 100.;\nconst float CAMERA_DISTORT = .6;\nconst int MAX_STEPS = 160;\nconst int MAX_SS_STEPS = 40;\n\n#define pMod(a, b) (mod(a,b)-0.5*b)\n#define STANDARD_RAYMARCH\n//#define WATCH_DISTANCE\n//#define WATCH_STEPS\n\nvec3 opRotX(in float x, in vec3 point) {\n    return vec3(point.x, point.y*cos(x)-point.z*sin(x), point.y*sin(x)+point.z*cos(x));\n}\n\nmat3 mRotX(in float x) {\n    return mat3(\n        1.0, 0.0, 0.0,\n        0.0, cos(x), -sin(x),\n        0.0, sin(x), cos(x)\n        );\n}\n\nvec3 opRotY(in float y, in vec3 point) {\n    return vec3(point.x*cos(y)-point.z*sin(y), point.y, point.x*sin(y)+point.z*cos(y));\n}\n\nmat3 mRotY(float y) {\n    return mat3(\n        cos(y), 0.0, -sin(y),\n        0.0, 1.0, 0.0,\n        sin(y), 0.0, cos(y)\n        );\n}\n\nvec3 opRotZ(in float z, in vec3 point) {\n    return vec3(point.x*cos(z)-point.y*sin(z), point.x*sin(z)+point.y*cos(z), point.z);\n}\n\nmat3 mRotZ(in float z) {\n    return mat3(\n        cos(z), -sin(z), 0.0,\n        sin(z), cos(z), 0.0,\n        0.0, 0.0, 1.0\n        );\n}\n\nvec3 hsv2rgb(in vec3 c)\n{\n    const vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nfloat fSphere(in vec3 p, in float r) {\n    return length(p)-r;\n}\nfloat sdTorus(in vec3 p, in vec2 t )\n{\n    vec2 q = vec2(length(p.xz)-t.x,p.y);\n    return length(q)-t.y;\n}\n\nfloat sdBox(in vec3 p, in vec3 b )\n{\n    vec3 d = abs(p) - b;\n    return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\nfloat sdCone(in vec3 p, in vec3 c) {\n    vec2 q = vec2(length(p.xz), p.y);\n    float d1 = -p.y-c.z;\n    float d2 = max(dot(q, c.xy), p.y);\n    return length(max(vec2(d1, d2),0.0)) + min(max(d1, d2), 0.0);\n}\n\nfloat sdCappedCone(in vec3 p, in vec2 c) {\n    float q = length(p.xy);\n    return dot(c, vec2(q, p.z));\n}\n\nfloat fCylinder(in vec3 p, in float r, in float height) {\n    return max(length(p.xz)-r,abs(p.y)-height);\n}\nfloat fInfCylinder(in vec2 p, in float r) {\n    return length(p)-r;\n}\n\nfloat fCapsule(in vec3 p, in float r, in float c) {\n    return mix(length(p.xz)-r,\n               length(vec3(p.x,abs(p.y)-c,p.z))-r,\n               step(c, abs(p.y)));\n}\n\nfloat fPlane(in vec3 p, in vec3 n) {\n    return dot(p, n);\n}\n\nvec3 opTx(in vec3 p, in mat4 m) {\n    return (inverse(m)*vec4(p,1.0)).xyz;\n}\n\n\n\n/*\nfloat wSphere(in vec3 center, in float radius, in vec3 pos, in vec3 dir, in float mindist) {\n    float r = radius+mindist;\n    vec3 cr = cross(center-pos, dir);\n    float dist = length(cr);\n    if(dist>r) return VERY_LARGE_DISTANCE;\n    float ra = sqrt(r*r-dist*dist);\n    return length(center-pos+cr)-ra;\n}\nfloat wYPlane(in float height, in vec3 pos, in vec3 dir, in float mindist) {\n    if (dir.y >=0.) return VERY_LARGE_DISTANCE;\n    else return (pos.y+height+mindist)/dir.y;\n}\n*/\n//=====================================================\n\nfloat map( in vec3 p )\n{\n    // ground plane\n    float ground = p.y + 1.0;\n    vec3 v1 = vec3(0.5, 0.5, -0.5)-p;\n    vec3 v2 = vec3(0.5, 0.4, -0.5)-p;\n    vec3 vt = opRotX(iTime+v1.x+v1.y, v1);\n    float d1 = sdTorus(vec3(pMod(v1.xz, 2.), v1.y).xzy, vec2(0.5,0.1+cos(iTime*4. + (floor(v1.x/2.0)+floor(v1.z/2.0))*0.5)*0.05));\n    float d3 = fSphere(vec3(pMod(v2.xz, 2.), v2.y).xzy, 0.15);\n    vec2 p4 = vec2(iTime*.1,1.2)-p.xy;\n    float d4 = fInfCylinder(vec2(pMod(p4.x, 5.), p4.y), 0.5);\n    \n    return min(ground,min(d1,min(d3, d4)));\t\n}\n\n\nfloat intersect( in vec3 ro, in vec3 rd )\n{\n\tconst float maxd = VERY_LARGE_DISTANCE;\n\tfloat h = 1.0;\n    float t = 0.0;\n    for( int i=0; i<MAX_STEPS; i++ )\n    {\n#ifdef WATCH_STEPS\n        if(h<0.001 || t>maxd) return float(i)/float(MAX_STEPS);\n#else\n        if( h<0.001 || t>maxd ) break;\n#endif\n\t    h = map( ro+rd*t );\n        t += h;\n    }\n\n    if( t>maxd ) t=-1.0;\n\t\n    return t;\n}\n\nvec3 calcNormal( in vec3 pos )\n{\n    vec3 eps = vec3(0.0002,0.0,0.0);\n\n\treturn normalize( vec3(\n           map(pos+eps.xyy) - map(pos-eps.xyy),\n           map(pos+eps.yxy) - map(pos-eps.yxy),\n           map(pos+eps.yyx) - map(pos-eps.yyx) ) );\n}\n\nfloat calcSoftshadow( in vec3 ro, in vec3 rd, float k )\n{\n    float res = 1.0;\n    float t = 0.0;\n\tfloat h = 1.0;\n    for( int i=0; i<MAX_SS_STEPS; i++ )\n    {\n        //t += max(warpzone(ro+rd*t, rd, k),0.);\n        h = map(ro + rd*t);\n        res = min( res, k*h/t );\n\t\tt += clamp( h, 0.01, 1.0 );\n\t\tif( h<0.0001 ) break;\n    }\n    return clamp(res,0.0,1.0);\n}\n\nfloat calcOcclusion( in vec3 pos, in vec3 nor )\n{\n    float occ = 0.0;\n    float sca = 1.0;\n    for( int i=0; i<5; i++ )\n    {\n        float hr = 0.02 + 0.025*float(i*i);\n        vec3 aopos =  nor * hr + pos;\n        float dd = map( aopos );\n        occ += -(dd-hr)*sca;\n        sca *= 0.95;\n    }\n    return 1.0 - clamp( occ, 0.0, 1.0 );\n}\n\nvec3 lig = normalize(vec3(1.0,0.9,0.7));\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 q = fragCoord.xy / iResolution.xy;\n    vec2 p = -1.0 + 2.0 * q;\n    p.x *= iResolution.x/iResolution.y;\n\n\tvec3 ro = (vec4(0., 0., 0., 1.0)).xyz;\n\tvec3 rd = vec3(p,1.0);\n    rd.z -= length(rd)*CAMERA_DISTORT;\n    rd = (vec4(normalize(rd), 1.)).xyz - ro;\n    vec3 col = vec3(0.0);\n\n\n#ifdef WATCH_DISTANCE\n    float t = intersect(ro,rd);\n    fragColor = vec4(vec3(1.-t/VERY_LARGE_DISTANCE),1.);\n#endif\n\n#ifdef WATCH_STEPS\n    fragColor = vec4(vec3(1.0-intersect(ro, rd)), 1.);\n#endif\n\n\n#ifdef STANDARD_RAYMARCH\n    float t = intersect(ro,rd);\n    if( t>0.0 )\n    {\n        vec3 pos = ro + t*rd;\n        vec3 nor = calcNormal(pos);\n\t\tfloat sha = calcSoftshadow( pos + nor*0.01, lig, 32.0 );\n\t\tfloat occ = calcOcclusion( pos, nor );\n\t\tcol =  vec3(0.9,0.6,0.3)*clamp( dot( nor, lig ), 0.0, 1.0 ) * sha;\n\t\tcol += vec3(0.5,0.6,0.7)*clamp( nor.y, 0.0, 1.0 )*occ;\n        col += 0.03;\n\t\tcol *= exp( -0.2*t );\n        col *= 1.0 - smoothstep( 5.0, 10.0, t );\n\t}\n\n\tcol = pow( clamp(col,0.0,1.0), vec3(0.45) );\n\tfragColor = vec4( col, 1.0);\n#endif\n    //fragColor = vec4( col.x, warpzone(ro,rd)*5., col.z, 1.0 );\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4t3SWS.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[240, 240, 280, 280, 370], [372, 372, 396, 396, 507], [509, 509, 549, 549, 639], [641, 641, 662, 662, 773], [775, 775, 815, 815, 905], [907, 907, 931, 931, 1042], [1044, 1044, 1069, 1069, 1244], [1246, 1246, 1284, 1284, 1310], [1311, 1311, 1349, 1349, 1418], [1420, 1420, 1456, 1456, 1547], [1549, 1549, 1585, 1585, 1755], [1757, 1757, 1799, 1799, 1862], [1864, 1864, 1921, 1921, 1971], [1972, 1972, 2015, 2015, 2041], [2043, 2043, 2094, 2094, 2213], [2215, 2215, 2251, 2251, 2275], [2277, 2277, 2310, 2310, 2353], [2901, 2901, 2925, 2945, 3441], [3444, 3444, 3487, 3487, 3832], [3834, 3834, 3866, 3866, 4079], [4081, 4081, 4138, 4138, 4443], [4445, 4445, 4494, 4494, 4785], [4829, 4829, 4886, 4886, 5994]], "test": "error"}
{"id": "4t3SWX", "name": "RedCircle", "author": "McShip", "description": "Circle going in ... circle", "tags": ["2d"], "likes": 0, "viewed": 119, "published": "Public", "date": "1481725098", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage(out vec4 color, in vec2 pixCoords) {\n    vec2 coords = pixCoords / iResolution.y;\n    \n    vec2 center = vec2(0.5, 0.5);\n    center.x += cos(iTime) * 0.3;\n    center.y += sin(iTime) * 0.3;\n    \n    float distance = length(coords - center);\n    float rayon = 0.2 + 0.1 * cos(iTime * 2.0);\n    \n    if (distance < rayon) {\n        color = vec4(1.0, 0.0, 0.0, 1.0);\n    }\n    \n    else {\n        color = vec4(1.0, 1.0, 1.0, 1.0);\n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4t3SWX.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 51, 51, 449]], "test": "valid"}
{"id": "4t3XRl", "name": "Orange Gate", "author": "Matnard", "description": "disks on a circle looped over", "tags": ["2d"], "likes": 1, "viewed": 482, "published": "Public API", "date": "1481025565", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\nconst float PI = 3.14159265358979;\nconst float TWO_PI = 2. * PI;\n\n\n float circle(vec2 circle_pos, vec2 coord, float circ_rad) {\n\t float circ_blur = 1.0;\n\t float dist = distance(circle_pos, coord);\n\t return smoothstep(circ_rad + circ_blur, circ_rad - circ_blur, dist); \n }\n\n void mainImage( out vec4 fragColor, in vec2 fragCoord ){\n     vec2 center = iResolution.xy * 0.5;\n          \n     vec3 color1 = vec3(113., 27., 134.) /255.;\n     vec3 color2 = vec3(255., 109., 40.) /255.;\n     \n     float circles;\n     float time = iTime * 2. * PI / 15.;\n     float rayon = 100.* abs(sin(time) / 5. + 1.5);\n     float maxIteration = rayon / 10.;\n     float circleRadius = rayon / 10.;\n     \n     const float numDisks = 32. ; \n          \n     for (float i = 0.0; i < 6.; i++) {\n         for (float j = 0.0; j < numDisks; j++) {\n             vec2 ptSurCercle = center + vec2(cos(TWO_PI/ numDisks * j), sin(TWO_PI / numDisks * j)) * ((rayon - rayon* i/rayon * 27. ))  ;\n             circles += circle( ptSurCercle, fragCoord.xy, circleRadius - circleRadius * i * 3. / circleRadius);\n         }\n     }     \n     \n     \n \n     fragColor = mix(vec4(color1, 1.), vec4(color2, 1.), circles );\n }", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4t3XRl.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[69, 69, 128, 128, 272], [275, 275, 331, 331, 1179]], "test": "valid"}
{"id": "4t3Xzl", "name": "Path-tracing sample", "author": "mmostajab", "description": "This shader toy sample is implemented based on the mini book by Peter Shirley called \"ray tracing in one weekend\".", "tags": ["materials", "specular", "lambertian", "dielectric", "defocusblur"], "likes": 0, "viewed": 926, "published": "Public API", "date": "1482067446", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//#define RENDER_WITH_SHADOWS\n//#define RENDER_WITH_LAMBERTIAN_MATERIALS\n//#define RENDER_WITH_METALIC_MATERIALS\n//#define RENDER_WITH_DIELECTRIC_MATERIALS\n#define RENDER_SCENE_DIFFERENT_MATERIALS\n\n#define DEPTH_OF_FIELD\n//#define FIXED_CAMERA\n\n// =======================================================\n// =======================================================\n// === Helper functions\n// =======================================================\n// =======================================================\n\n#define PI 3.141592\n\nvec3 noise3D( in vec3 x )\n{\n    vec3 ret;\n    \n    vec3 p = floor(x);\n    vec3 f = fract(x);\n\tf = f*f*(3.0-2.0*f);\n\t\n\tvec2 uv = (p.xy+vec2(37.0,17.0)*p.z) + f.xy;\n\tvec2 rg = texture( iChannel0, (uv * fract(iTime * 10.0) + 0.5)/256.0).yx;\n\tret.x = mix( rg.x, rg.y, f.z );\n    \n    uv = (p.xy+vec2(97.0,93.0)*p.z) + f.xy;\n    rg = texture( iChannel0, (uv * fract(iTime * 10.0) + 0.5)/256.0).yx;\n\tret.y = mix( rg.x, rg.y, f.z );\n    \n    uv = (p.xy+vec2(61.0,47.0)*p.z) + f.xy;\n    rg = texture( iChannel0, (uv * fract(iTime * 10.0)+ 0.5)/256.0).yx;\n\tret.z = mix( rg.x, rg.y, f.z );\n    \n    return ret;\n}\n\nfloat hash1( float n ){\n    float hash_res1 = fract(sin(n)*43758.5453123+22578.1459123);\n    float hash_res2 = 1.0;//fract(sin(iTime)*22578.1459123+19642.3490423);\n    return hash_res1 * hash_res2;\n}\n\nvec2 hash2( float n ){\n    vec2 hash3_res1 = fract(sin(vec2(n,n+1.0))*vec2(43758.5453123,22578.1459123));\n    vec2 hash3_res2 = vec2(1.0);//fract(sin(vec2(iTime / 173.0, iTime / 97.0))*vec2(22578.1459123,19642.3490423));\n    return normalize(hash3_res1 * hash3_res2);\n}\n\nvec3 hash3( float n ){\n    vec3 hash3_res1 = fract(sin(vec3(n,n+1.0,n+2.0))*vec3(43758.5453123,22578.1459123,19642.3490423));\n    vec3 hash3_res2 = vec3(1.0);//fract(sin(vec3(iTime / 13.0, iTime / 173.0, iTime / 97.0))*vec3(43758.5453123,22578.1459123,19642.3490423));\n    return normalize(hash3_res1 * hash3_res2);\n}\n\nfloat rand1(vec3 p){\n    vec3 rand = noise3D(p);\n    return rand.x + rand.y + rand.z;\n    //float texCoord = hash1(p.x+p.y+p.z);\n    //return texture(iChannel0, vec2(texCoord, texCoord)).y;\n}\n\nvec3 rand3(vec3 p){\n    vec2 texCoord = hash2(p.x+p.y+p.z);\n    return texture(iChannel0, texCoord).xyz;\n}\n\n\nvec4 correctGamma(vec4 color){\n    float lambda = 5.2;\n    return vec4(pow(color.x, 1.0 / lambda), pow(color.y, 1.0 / lambda), pow(color.z, 1.0 / lambda), color.w);\n}\n\nbool refractFunc(in vec3 v, in vec3 n, in float ni_over_nt, out vec3 refracted){\n    float dt = dot(normalize(v), n);\n    float discreminant = 1.0 - ni_over_nt*ni_over_nt*(1.0-dt*dt);\n    if(discreminant > 0.0){\n        refracted = refract(v, n, ni_over_nt);\n        return true;\n    }\n    return false;\n}\n\nfloat schlick(float cosine, float ref_idx){\n    float r0 = (1.0 - ref_idx) / (1.0 + ref_idx);\n    r0 = r0 * r0;\n    return r0 + (1.0-r0) * pow((1.0-cosine), 5.0);\n}\n\nvec3 random_in_unit_disk(in vec2 subSamplePos){\n    return texture(iChannel0, subSamplePos).xyz;\n}\n\n// =======================================================\n// =======================================================\n// === Primitive structures\n// =======================================================\n// =======================================================\n\nstruct Sphere {\n    vec3  center;\n    float radius;\n};\n    \nstruct Plane {\n    vec3 P0;\n    vec3 N;\n};\n\nstruct Ray {\n    vec3  origin;\n    vec3  dir;\n    float t_min;\n    float t_max;\n};\n    \nstruct HitRecord {\n    int   mat_id;  // 0 : for background\n                   // 1 : lambertian\n                   // 2 : metal\n                   // 3 : dielectric\n    float t;\n    vec3 normal;\n    vec3 color;\n    vec3 hitPoint;\n};\n   \n// =======================================================\n// =======================================================\n// === Primitive intersection test functions\n// =======================================================\n// =======================================================\n\nbool intersect_sphere(inout Ray ray, in Sphere sphere, out HitRecord hitRecord){\n    \n    vec3 sphereCenter = sphere.center - ray.origin;\n    \n    float a = dot(ray.dir, ray.dir);\n\tfloat bPrime = -dot(sphereCenter, ray.dir);\n\tfloat c = dot(sphereCenter, sphereCenter) - sphere.radius * sphere.radius;\n\tfloat deltaPrime  = bPrime * bPrime - a * c;\n\n\tif(deltaPrime >= 0.0){\n\t\tfloat t = -bPrime - sqrt(deltaPrime);\n    \n        if(t >= ray.t_min && t <= ray.t_max){\n\t\t    vec3 intersect_point = t * ray.dir;\n\t\t    hitRecord.normal = normalize(intersect_point - sphereCenter);\n            ray.t_max = t;\n            \n            hitRecord.t = t;\n            \n            hitRecord.hitPoint = ray.origin + t * ray.dir;\n            \n            return true;\n        }\n        \n        t = -bPrime + sqrt(deltaPrime);\n    \n        if(t >= ray.t_min && t <= ray.t_max){\n\t\t    vec3 intersect_point = t * ray.dir;\n\t\t    hitRecord.normal = normalize(intersect_point - sphereCenter);\n            ray.t_max = t;\n            \n            hitRecord.t = t;\n            \n            hitRecord.hitPoint = ray.origin + t * ray.dir;\n            \n            return true;\n        }\n\t} \n    \n    return false;\n    \n}\n\nbool intersect_plane(inout Ray ray, in Plane plane, out HitRecord hitRecord) {\n   float t = dot(plane.N, plane.P0 - ray.origin) / dot(plane.N, ray.dir);\n    if(t >= ray.t_min && t <= ray.t_max){\n        ray.t_max = t;\n        hitRecord.t = t;\n        hitRecord.normal = plane.N;\n        hitRecord.hitPoint = ray.origin + t * ray.dir;\n        float distToPlaneCenter = length(plane.P0 - ray.origin + t * ray.dir);\n        int randColorBand = int(distToPlaneCenter);\n        if(randColorBand - 4 * (randColorBand / 4) == 0){\n            hitRecord.color = vec3(1, 1, 1) ;\n        } else {\n            hitRecord.color = vec3(0, 0, 0);\n        }\n        return true;\n    } else {\n        return false;\n    }\n}\n\n// =======================================================\n// =======================================================\n// === Scene Description\n// =======================================================\n// =======================================================\n\nbool intersectScene(inout Ray ray, out vec4 color, out HitRecord hitRecord){\n    const vec3 objColor = vec3(0.5, 0.2, 0.4);\n    const vec3 groundColor = vec3(0.1, 0.8, 0.7);\n    const vec3 lightDir = normalize(vec3(1, 1, 1));\n    \n    bool intersect = false;\n    \n    float animLength = 6.14;\n    float t = iTime - float(int(iTime / animLength)) * animLength;\n      \n    Plane background;\n    background.P0 = - vec3(0, 0, 9000);\n    background.N = vec3(0, 0, 1);\n        \n    const int nSpheresDim = 5;\n    const float radius = 75.0;\n    vec3 sphereCenter = vec3(float(-nSpheresDim / 2 - 1) * 2.5 * radius, radius, float(-nSpheresDim / 2) * 2.5 * radius);\n    vec3 translationX = vec3(2.5 * radius, 0.0, 0.0);\n    vec3 translationZ = vec3(0.0, 0.0, 2.5 * radius);\n    \n    Sphere sphere;\n    sphere.center = sphereCenter;\n    sphere.radius = radius;\n    \n    Plane ground;\n    ground.P0 = sphereCenter - vec3(0.0, radius, 0.0);\n    ground.N = vec3(0, 1, 0);\n    \n    for(int j = 0; j < nSpheresDim; j++){\n        sphere.center = sphereCenter + float(j) * translationZ;\n    \tfor(int i = 0; i < nSpheresDim; i++){        \n            int mat_id = 3;\n\n            sphere.center = sphere.center + translationX;\n            if(i + j - 2 * ((i+j) / 2) == 1){\n                mat_id = 2;\n            }\n\n            if(intersect_sphere(ray, sphere, hitRecord)){\n               vec3 reflection_vec = reflect(hitRecord.normal, -lightDir);\n               hitRecord.mat_id = mat_id;\n               hitRecord.color = objColor;\n               //color = vec4(objColor * abs(dot(hitRecord.normal, lightDir)), 1.0);\n               //color = vec4(objColor, 1.0);\n               float ambient  = 0.4;                \n               float diffuse  = (dot(hitRecord.normal, -lightDir));\n               float specular = pow((dot(reflection_vec, -ray.dir)), 100.0);\n               color = vec4(objColor * clamp((diffuse + specular), ambient, 1.0), 1.0);\n               intersect = true;\n            }\n        }\n    }\n    \n    if(intersect_plane(ray, background, hitRecord)){\n        hitRecord.mat_id = 0;\n        hitRecord.color = (ray.dir + vec3(1.0)) / 2.0;\n        color = vec4((ray.dir + vec3(1.0)) / 2.0, 1.0) * vec4(hitRecord.color, 1.0);\n        intersect = true;\n    }\n    \n    if(intersect_plane(ray, ground, hitRecord)){\n        hitRecord.mat_id = 2;\n        hitRecord.color = groundColor;\n        color = vec4(groundColor * dot(hitRecord.color, lightDir), 1.0);\n        intersect = true;\n    }\n    \n    return intersect;\n\t//else fragColor = back_color(fragCoord2d);\n}\n\n    \n// =======================================================\n// =======================================================\n// === Material scattered ray calculation\n// =======================================================\n// =======================================================\n\nbool scatter_lambertian(in Ray rayIn, in HitRecord hitRecord, out Ray scattered_ray){\n    scattered_ray.origin = hitRecord.hitPoint;\n    scattered_ray.dir    = rand3(hitRecord.hitPoint);\n    scattered_ray.t_min  = 1.0;\n    scattered_ray.t_max  = 10000.0;\n    return true;\n}\n\nbool scatter_metalic(in Ray rayIn, in HitRecord hitRecord, in float fuzzy, out Ray scattered_ray){\n    \n    vec3 reflected = reflect(rayIn.dir, hitRecord.normal);\n    reflected += fuzzy * rand3(hitRecord.hitPoint);\n    \n    scattered_ray.origin = hitRecord.hitPoint;\n    scattered_ray.dir    = reflected;\n    scattered_ray.t_min  = 0.2;\n    scattered_ray.t_max  = 10000.0;\n    \n    return true;\n}\n\nbool scatter_dielectric(in Ray rayIn, in HitRecord hitRecord, in float ref_idx, out Ray scattered_ray){\n    \n    vec3 reflected = reflect(rayIn.dir, hitRecord.normal);\n    vec3 refracted;\n    \n    vec3 outward_normal;\n    float ni_over_nt;\n   \n    //attenuation = vec3(1.0);\n    \n    float reflection_prob;\n    float cosine;\n    \n    if(dot(rayIn.dir, hitRecord.normal) > 0.0){\n        outward_normal = -hitRecord.normal;\n        ni_over_nt = ref_idx;\n        cosine = ref_idx * dot(rayIn.dir, hitRecord.normal) / length(rayIn.dir);\n    } else {\n        outward_normal = hitRecord.normal;\n        ni_over_nt = 1.0 / ref_idx;\n        cosine = -dot(rayIn.dir, hitRecord.normal) / length(rayIn.dir);\n    }\n    if(refractFunc(rayIn.dir, outward_normal, ni_over_nt, refracted)){\n        reflection_prob = schlick(cosine, ref_idx);\n    } else {\n        reflection_prob = 1.0;\n    }\n    \n    scattered_ray.origin = hitRecord.hitPoint;\n    scattered_ray.t_min  = 0.2;\n    scattered_ray.t_max  = 10000.0;\n    if(rand1(hitRecord.hitPoint) > reflection_prob){\n        scattered_ray.dir = refracted;\n    } else {\n        scattered_ray.dir = reflected;\n    }\n    \n    return true;   \n}\n\n// =======================================================\n// =======================================================\n// === Different rendering modes\n// =======================================================\n// =======================================================\n\nvoid renderScene(inout Ray primaryRay, out vec4 fragColor){\n    const vec3 lightDir = normalize(vec3(1, 1, 1));\n    const int max_depth = 10;\n    \n    fragColor = vec4(1.0);\n    HitRecord hitRecord;    \n    Ray ray = primaryRay;\n    \n    float attenuation = 1.0;\n    float fuzzy = 0.1;\n    \n    for(int i = 0; i < max_depth; i++){\n\n        vec4 pathColor;\n        if(intersectScene(ray, pathColor, hitRecord) == false){\n            //fragColor *= pathColor;\n            break;\n        }\n\n        fragColor *= attenuation * pathColor;\n        \n        Ray nextRay;\n             if(hitRecord.mat_id == 0)  {} // reserved for background material\n        else if(hitRecord.mat_id == 1)  scatter_lambertian(ray, hitRecord, nextRay);\n        else if(hitRecord.mat_id == 2)  scatter_metalic(ray, hitRecord, fuzzy, nextRay);\n        else if(hitRecord.mat_id == 3)  scatter_dielectric(ray, hitRecord, 3.0, nextRay);\n        ray = nextRay;\n    }\n}\n\nvoid renderWithDiElectricMaterials(inout Ray primaryRay, out vec4 fragColor){\n    const vec3 lightDir = normalize(vec3(1, 1, 1));\n    const int max_depth = 10;\n    \n    fragColor = vec4(1.0);\n    HitRecord hitRecord;    \n    Ray ray = primaryRay;\n    \n    float attenuation = 1.0;\n    \n    for(int i = 0; i < max_depth; i++){\n\n        vec4 pathColor;\n        if(intersectScene(ray, pathColor, hitRecord) == false){\n            //fragColor *= pathColor;\n            break;\n        }\n\n        fragColor *= attenuation * pathColor;\n               \n        Ray nextRay;\n        scatter_dielectric(ray, hitRecord, 1.7, nextRay);\n        ray = nextRay;\n    }\n}\n\nvoid renderWithMetallicMaterials(inout Ray primaryRay, out vec4 fragColor){\n    const vec3 lightDir = normalize(vec3(1, 1, 1));\n    const int max_depth = 10;\n    \n    fragColor = vec4(1.0);\n    HitRecord hitRecord;    \n    Ray ray = primaryRay;\n    \n    float attenuation = 0.5;\n    float fuzzy = 0.1;\n    \n    for(int i = 0; i < max_depth; i++){\n\n        vec4 pathColor;\n        if(intersectScene(ray, pathColor, hitRecord) == false){\n            //fragColor *= pathColor;\n            break;\n        }\n\n        fragColor *= attenuation * pathColor;\n        \n        Ray nextRay;\n        scatter_metalic(ray, hitRecord, fuzzy, nextRay);\n        ray = nextRay;\n    }\n}\n\nvoid renderWithLambertianMaterials(inout Ray primaryRay, out vec4 fragColor){\n    const vec3 lightDir = normalize(vec3(1, 1, 1));\n    const int max_depth = 10;\n    const int numNewSampleForDiffuseMaterials = 1;\n    \n    \n    fragColor = vec4(1.0);\n    HitRecord hitRecord;    \n    Ray ray = primaryRay;\n    \n    vec4 accumColor = vec4(0.0);\n    for(int j = 0; j < numNewSampleForDiffuseMaterials; j++){\n        vec4 pathColor = vec4(1.0);\n        bool hit = false;\n        for(int i = 0; i < max_depth; i++){\n\n            vec4 bounceColor;\n            if(intersectScene(ray, bounceColor, hitRecord) == false){\n                //pathColor *= bounceColor;\n                //fragColor *= pathColor;\n                break;\n            }\n\n            pathColor *= bounceColor;\n\n            Ray nextRay;\n            scatter_lambertian(ray, hitRecord, nextRay);\n            ray = nextRay;\n            hit = true;\n        }\n        \n        if(hit) accumColor += pathColor;\n    }\n    \n    fragColor *= (accumColor / float(numNewSampleForDiffuseMaterials));\n}\n\nvoid renderWithShadow(inout Ray primaryRay, out vec4 fragColor){\n    const vec3 lightDir = normalize(vec3(1, 1, 1));\n    const int max_depth = 10;\n    \n    HitRecord hitRecord;    \n    Ray ray = primaryRay;\n\n    if(intersectScene(ray, fragColor, hitRecord) == false) return;\n    vec3 p = hitRecord.hitPoint;\n        \n    Ray shadowRay;\n    shadowRay.origin = p;\n    shadowRay.dir = lightDir;\n    shadowRay.t_min = 0.2;\n    shadowRay.t_max = 10000.0;\n        \n    HitRecord shadowRayHitRecord;\n    vec4 ShadowRayFragColor;\n    if(intersectScene(shadowRay, ShadowRayFragColor, shadowRayHitRecord) == true){\n       //fragColor = vec4(1, 1, 1, 1);\n       fragColor = vec4(0, 0, 0, 1);\n    }\n}\n\nvoid render(inout Ray primaryRay, out vec4 fragColor) {\n#ifdef RENDER_WITH_SHADOWS\n    renderWithShadow(primaryRay, fragColor);\n#elif defined  RENDER_WITH_LAMBERTIAN_MATERIALS\n    renderWithLambertianMaterials(primaryRay, fragColor);\n#elif defined  RENDER_WITH_METALIC_MATERIALS\n    renderWithMetallicMaterials(primaryRay, fragColor);\n#elif defined RENDER_WITH_DIELECTRIC_MATERIALS\n    renderWithDiElectricMaterials(primaryRay, fragColor);\n#elif defined RENDER_SCENE_DIFFERENT_MATERIALS\n    renderScene(primaryRay, fragColor);\n#endif\n    \n    // gamma correcting\n    fragColor = correctGamma(fragColor);\n}\n\n// =======================================================\n// =======================================================\n// === Main functions for fragment shaders for Image/VR\n// =======================================================\n// =======================================================\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord2d )\n{\n    fragColor = vec4(0.0);\n    \n    \n    Ray ray;\n    ray.t_min = 0.0;\n    ray.t_max = 1000000.0; \n\n    vec3 origin = vec3(0.0, 300.0, 700.0);\n#ifdef FIXED_CAMERA\n    origin += vec3(450.0, 200.0, -100.0);\n#else\n    origin += vec3(500.0*sin(iTime), 0, 500.0*cos(iTime));\n#endif\n    vec3 lookat = vec3(0.0, 100.0, 0.0);\n    const float viewPlaneDistance = 1.0;\n    const float fov   = PI / 2.0;\n    float aspectRatio = float(iResolution.x) / float(iResolution.y);\n    float halfHeight = tan(fov / 4.0);\n    float halfWidth  = aspectRatio * halfHeight;\n\n    vec3 w = normalize(lookat - origin);\n    vec3 u = normalize(cross(vec3(0.0, 1.0, 0.0), w));\n    vec3 v = normalize(cross(w, u));\n    \n    float aperture    = 70.0;\n    float lens_radius = aperture / 2.0;\n    float focalDist   = 1.0 * length( lookat - origin );\n    \n    vec3 lowerLeftCorner = origin + vec3(focalDist) * (-halfWidth*u-halfHeight*v+viewPlaneDistance*w);\n        \n    const int numSubSampleX = 4;\n    const int numSubSampleY = 4;\n    \n    for(int i = 0; i < numSubSampleX; i++)\n        for(int j = 0; j < numSubSampleY; j++){\n            vec2 subSamplePos = vec2(float(i+1) / float(numSubSampleX+1), float(j+1) / float(numSubSampleY+1));\n            subSamplePos = 2.0 * subSamplePos - 1.0;\n\n            vec2 normalizedCoords = (fragCoord2d + subSamplePos) / iResolution.xy;\n            vec3 fragCoord = lowerLeftCorner + 2.0 * focalDist * (u * normalizedCoords.x * halfWidth + v * normalizedCoords.y * halfHeight);\n           \n#ifdef DEPTH_OF_FIELD\n            vec3 rd = lens_radius * random_in_unit_disk(subSamplePos);\n            vec3 offset = u * rd.x + v * rd.y;\n#else\n            vec3 offset = vec3(0.0);\n#endif\n            ray.origin = origin + offset;            \n    \t\tray.dir = normalize(fragCoord - ray.origin);\n            \n            vec4 sampleColor;\n            render(ray, sampleColor);\n            fragColor += sampleColor;\n        }\n    fragColor /= float(numSubSampleX * numSubSampleY);\n}", "image_inputs": [{"id": "Xsf3zn", "previewfilepath": "/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4t3Xzl.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[527, 527, 554, 554, 1129], [1131, 1131, 1154, 1154, 1330], [1332, 1332, 1354, 1354, 1601], [1603, 1603, 1625, 1625, 1920], [1922, 1922, 1942, 1942, 2113], [2115, 2115, 2134, 2134, 2221], [2224, 2224, 2254, 2254, 2390], [2392, 2392, 2472, 2472, 2697], [2699, 2699, 2742, 2742, 2863], [2865, 2865, 2912, 2912, 2963], [3942, 3942, 4022, 4022, 5136], [5138, 5138, 5216, 5216, 5842], [6106, 6106, 6182, 6182, 8661], [8947, 8947, 9032, 9032, 9220], [9222, 9222, 9320, 9320, 9618], [9620, 9620, 9723, 9723, 10792], [11064, 11064, 11123, 11123, 12001], [12003, 12003, 12080, 12080, 12657], [12659, 12659, 12734, 12734, 13326], [13328, 13328, 13405, 13405, 14378], [14380, 14380, 14444, 14444, 15068], [15070, 15070, 15125, 15125, 15675], [15970, 15970, 16029, 16029, 18007]], "test": "error"}
{"id": "4tcXWj", "name": "Beach", "author": "GinCastaway", "description": "Beach", "tags": ["test"], "likes": 1, "viewed": 121, "published": "Public", "date": "1481550990", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage(out vec4 color, in vec2 pixCoords) {   \n\t/* == Background == */\n\tcolor = vec4(0.9, pixCoords.y / iResolution.y, 0.0, 1.0);\n    \n    /* == Sun == */ \n    vec2 center = vec2(3.0 * iResolution.x / 4.0, 3.0 * iResolution.y / 4.0);\n    float radius = cos(iTime) * 7.0 + (iResolution.y * 15.0) / 100.0;\n    \n    float distSun = sqrt(pow(pixCoords.x - center.x, 2.0) + pow(pixCoords.y - center.y, 2.0));\n    \n    if ( distSun < radius ) {\n    \tcolor = vec4(1.0, 1.0, 0.0, 1.0);\n    }\n    \n    /* == Rays == */\n    float angleRay = 30.0;\n    \n    float deltaX = center.x - pixCoords.x;\n    float deltaY = center.y - pixCoords.y;\n    float angleRad = ((atan(deltaX, deltaY) * 180.0) / 3.14) + iTime * 2.0;\n    if ( (mod(angleRad, angleRay) <= 7.0) && (distSun > radius + 25.0) ) {\n        color = vec4(1.0, 1.0, 0.0, 1.0);\n    }\n    \n    /* == Waves == */\n    vec2 dist = pixCoords.xy / iResolution.xy;\n    \n    float pi2 = 3.14 * 2.0;\n    float waves1 = 3.0; float height1 = 0.18;\n    float waves2 = 2.0; float height2 = 0.30;\n    \n    float ampli = 0.05;\n    \n    float wave1 = ampli * cos((iTime) + dist.x * waves1 * pi2) + height1;\n    float wave2 = ampli * cos((iTime * 1.5) + dist.x * waves2 * pi2) + height2;\n    \n    if (dist.y < wave2) {\n       color = vec4(0.2, 0.2, 0.5, 1.0);\n    }\n    \n    if (dist.y < wave1) {\n        color = vec4(0.2, 0.2, 0.7, 1.0);\n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4tcXWj.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 51, 78, 1380]], "test": "valid"}
{"id": "4tcXzf", "name": "Popcorn Picker", "author": "xbe", "description": "Playing with Pickover popcorn functions...", "tags": ["2d", "popcorn"], "likes": 3, "viewed": 518, "published": "Public API", "date": "1480812343", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Created by Xavier Benech - xbe/2016\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n//\n// Pickover Popcorn\n//\n\n#define PI 3.141592654\n#define NBIT 56\n#define NBITF 56.\n\nvec2 popcorn1(in vec2 r, in float h, in float a, in float b) {\n   return vec2(\n       h * cos(b*r.y + sin(a*r.y)),\n       h * sin(a*r.x + cos(b*r.x)));\n}\n\nvec2 popcorn2(in vec2 r, in float h, in float a, in float b) {\n   return vec2(\n       h * sin(b*r.y + sin(a*r.y)),\n       h * sin(a*r.x + sin(b*r.x)));\n}\n\nvec2 popcorn3(in vec2 r, in float h, in float a, in float b) {\n   return vec2(\n       h * cos(b*r.y + sin(a*r.y)),\n       h * cos(a*r.x + sin(b*r.x)));\n}\n\nvec2 popcorn4(in vec2 r, in float h, in float a, in float b) {\n   return vec2(\n       h * sin(b*r.y + cos(a*r.y)),\n       h * sin(a*r.x + cos(b*r.x)));\n}\n\nvec2 popcorn5(in vec2 r, in float h, in float a, in float b) {\n   return vec2(\n       h * sin(b*r.y + tan(a*r.y)),\n       h * sin(a*r.x + tan(b*r.x)));\n}\n\nvec3 iterate(in vec2 p, float t, float pc) {\n    float a = PI * (0.75 + 0.5 * sin(t));\n    float b = PI * (0.75 + 0.5 * cos(t));\n    float h = 0.04 + 0.02*cos(PI*t);\n    vec2 r = p;\n    float d = 0.;\n    for (int i=0; i < NBIT; ++i) {\n        if (pc < 1.)\n\t        r.xy -= popcorn1(r.xy, h, a, b);\n        else if (pc < 2.)\n\t        r.xy -= popcorn2(r.xy, h, a, b);\n        else if (pc < 3.)\n\t        r.xy -= popcorn3(r.xy, h, a, b);\n        else\n\t        r.xy -= popcorn4(r.xy, h, a, b);\n        d += distance(r.xy,p);\n   }\n    d /= NBITF;\n    vec3 s = vec3(0.);\n    s.x = 1.0/(0.1+d);\n    s.y = sin(atan( r.y-p.y, r.x-p.x ));\n    s.z = exp(-0.2*d);\n    return s;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 q = fragCoord.xy / iResolution.xy;\n\tvec2 p = -1.0 + 2.0*q;\n\tp.x *= iResolution.x/iResolution.y;\n    p *= 1.33;\n    \n    float t = 0.0625 * iTime;\n\n    float pcf = mod(0.025*iTime, 4.);\n    vec3 s = vec3(0.);\n    if (fract(pcf) < 0.5) {\n    \ts = iterate(p, t, pcf);\n    } else {\n    \ts = 0.7 * iterate(iterate(p, t + 0.5 * PI, pcf).xy, t, pcf+1.);\n    }\n    \n    vec3 col = 0.5 + 0.25*cos( vec3(0.0,0.4,0.6) + 2.5 + s.z*6.2831 );\n\t\n\tif (fract(pcf) < 0.5) {\n\t\tcol += 0.25 * vec3(0.8, 0.6, 0.4) * s.y;\n\t    col *= 0.33 * s.x;\n    \tcol *= 0.85+0.15*sin(10.0*abs(s.y));\n    } else {\n\t\tcol += 0.75 * vec3(0.8, 0.6, 0.4) * s.y;\n\t    col *= 0.66 * s.x;\n    \tcol *= 0.70 + 0.15*sin(10.0*abs(s.z)) + 0.15*sin(-6.*s.y);\n    }\n    \n    col *= vec3(0.7, 0.5, 0.35);\n    \n\tvec3 nor = normalize( vec3( dFdx(s.x), 0.02, dFdy(s.x) ) );\n\tfloat dif = dot( nor, vec3(0.7,0.1,0.7) );\n\tcol += 0.05*vec3(dif);\n\n\tcol *= 0.3 + 0.7*pow( 16.0*q.x*q.y*(1.0-q.x)*(1.0-q.y), 0.2 );\n\n    col = pow(clamp(col, 0., 1.), vec3(0.45));\n    fragColor = vec4(clamp(col, 0., 1.), 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4tcXzf.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[211, 211, 273, 273, 364], [366, 366, 428, 428, 519], [521, 521, 583, 583, 674], [676, 676, 738, 738, 829], [831, 831, 893, 893, 984], [986, 986, 1030, 1030, 1652], [1654, 1654, 1711, 1711, 2766]], "test": "valid"}
{"id": "4tdSD2", "name": "Ancient Tech", "author": "zackpudil", "description": "Heavily inspired by this [url=https://www.shadertoy.com/view/XtX3zj]this[/url].  Using the Apollonian fractal instead.\n\nNote: Before going fullscreen comment out the #define AA line, it'll run much smoother.", "tags": ["2d", "fractal", "kali"], "likes": 20, "viewed": 564, "published": "Public", "date": "1481744510", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Comment out this line before going full screen for a smoother experience.\n#define AA 7\n\nfloat time() { return iTime; }\nvec3 grey = vec3(0.21, 0.72, 0.07); // grey scale http://www.johndcook.com/blog/2009/08/24/algorithms-convert-color-grayscale/\nvec2 mouse() { return (-iResolution.xy + 2.0*iMouse.xy)/iResolution.y; } // proper mouse coords.\n\nmat2 r(float th) {  vec2 a = sin(vec2(1.5707963, 0) + th); return mat2(a, -a.y, a.x); } // cosine-less rotation.\n\n// screen movement. Need this for formula and textures.  \nvoid animate(inout vec2 p) {\n    p *= r(time()*0.1 + mouse().x);\n\tp.y += time()*0.3;\n\tp.x += 3.0*cos(time()*0.1);\n}\n\n\n// fractal is drawn via orbit trapping.\nvec2 orb(vec2 p) {\n\tanimate(p);\n    \n\tfloat s = 1.0;\n    float m = 1.0;\n\t\n    // appolonian gasket fractal https://en.wikipedia.org/wiki/Apollonian_gasket\n    // with a bit of a twist.\n\tfor(int i = 0; i < 3; i++) {\n\t\tp = -1.0 + 2.0*fract(0.5 - 0.5*p);\n\t\tp *= 2.3/max(dot(p, p), 0.4);\n       \n\t\ts = min(s, abs(cos(p.x)));\n        m = min(m, abs((p.y)));\n\t}\n\t\n\treturn vec2(s, m);\n}\n\n\n// simple 2.5d bump mapping.\nvec3 bump(vec2 p, float e, float z) {\n\tvec2 r = vec2(e, 0.0); vec2 l = r.yx;\n\tvec3 g = vec3(orb(p + l).x - orb(p - l).x,\n\t\t\t   orb(p + r).x - orb(p - r).x,\n\t\t\t   z); //The \"z\" coordinate should be between -1.0, 0.0.  The closer to zero the more pop the geometry has.\n\t\n\treturn normalize(g);\n}\n\n// texture 2.5d bump mapping.\nvec3 texbump(sampler2D s, vec2 p, float e) {\n    vec2 r = vec2(e, 0.0); vec2 l = r.yx;\n    float ce = dot(grey, texture(s, p).rgb);\n    vec3 g = (grey*mat3(\n        texture(s, p - r).rgb,\n        texture(s, p - l).rgb,\n        vec3(ce)) - ce)/e;\n    \n    return normalize(g);\n}\n\nvec3 render(vec2 p) {\n\tvec3 rd = normalize(vec3(p, 1.0)); // \"ray direction. This also doubles as the light.\n\tvec3 sn = bump(p, 0.01, -0.7);\n\tvec3 col = vec3(0);\n    \n    vec2 ma = orb(p);\n    \n    float occ = ma.x;\n    float tm = pow(ma.y, 10.0); //texture mask\n   \n    animate(p);\n    \n   \tsn = normalize(sn + 0.2*mix(texbump(iChannel1, p, 0.001), texbump(iChannel0, p, 0.01), tm)); // add bump mapping for textures.\n    vec3 re = reflect(rd, sn);\n\t\n    // diffuse and specular.\n\tcol += pow(clamp(dot(-rd, sn), 0.0, 1.0), 10.0);\n\tcol += pow(clamp(dot(-rd, re), 0.0, 1.0), 32.0);\n    \n    col *= mix(texture(iChannel1, p).rgb, texture(iChannel0, p).rgb, tm); // material\n    col *= 3.0*occ; // ambient occlusion.\n    \n    // emission.\n    p += vec2(1, 0);\n    p = mod(p + 1.0, 2.0) - 1.0;\n    float mask = smoothstep(0.7, 0.71, length(p));\n    \n    col += vec3(4.1, 4.2, 0.2)*pow(abs(occ), 8.0)*mask\n        *smoothstep(-1.0, 1.0, cos(10.0*time() + 3.0*p.y));\n    \n    col += vec3(0.1, 5.0, 3.5)*pow(abs(occ), 9.0)*(1.0 - mask)\n        *smoothstep(-1.0, 1.0, cos(5.0*time()));\n    \n\treturn col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\t\n\tvec2 uv = fragCoord;\n\tvec2 of = vec2(0.3);\n    \n    // small bit of anti-aliasing.\n    #ifdef AA\n\tconst float aa = float(AA);\n    #else\n    const float aa = 1.0;\n    #endif\n\t\n\tvec3 col = render((-iResolution.xy + 2.0*gl_FragCoord.xy)/iResolution.y);\n\tfor(float i = 0.0; i < aa - 1.0; i++) {\n\t\t// super-sample around the center of the pixel.\n\t\tvec2 p = (-iResolution.xy + 2.0*(uv + of))/iResolution.y;\n\t\tcol += render(p);\n\t\tof *= r(3.14159/8.0);\n\t}\n\t\n\tcol /= aa;\n\t\n\t//col += 0.2*clamp(col, 0.0, 0.5);\n\tcol = pow(col, vec3(1.0/2.2));\n\tfragColor = vec4(col, 1);\n}", "image_inputs": [{"id": "4dXGRn", "previewfilepath": "/media/ap/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg", "ctype": "texture"}, {"id": "4sXGRn", "previewfilepath": "/media/ap/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4tdSD2.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[91, 91, 105, 105, 121], [158, 249, 263, 263, 321], [347, 347, 365, 365, 434], [461, 519, 547, 547, 634], [637, 677, 695, 695, 1056], [1059, 1088, 1125, 1125, 1380], [1382, 1412, 1456, 1456, 1689], [1691, 1691, 1712, 1712, 2788], [2790, 2790, 2847, 2847, 3411]], "test": "error"}
{"id": "4tdSDj", "name": "dumb white stripes", "author": "antonOTI", "description": "this is no seven nation army (I should do that some day though)", "tags": ["2d", "noob", "stripes"], "likes": 4, "viewed": 671, "published": "Public API", "date": "1481654133", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n// Parameters\n#define FREQUENCE 3.\n#define TILT -.9\n#define SPEED .5\n#define THIKNESS .15\n#define SMOOTHNESS .01\n//\n\n\n\n#define _Smooth(p,r,s) smoothstep(-s, s, p-(r))\n#define time iTime * SPEED\n#define _thikness THIKNESS * .5\n\n//Compressed  by : FabriceNeyret2\nvoid mainImage( out vec4 O, in vec2 U )\n{\n\tfloat s = fract( dot(U/iResolution.xy, vec2(FREQUENCE,TILT)) + time );   \n    O = vec4( _Smooth(_thikness, abs(s - .5) ,SMOOTHNESS) ); // boldness\n}\n\n/*\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    \n    \n    float stripes = fract(uv.x * FREQUENCE + uv.y * TILT + time); // frequence tilt and animation\n\n    stripes = _Smooth(_thikness, abs(stripes - .5) ,SMOOTHNESS); // boldness\n    \n    \n    \n\tfragColor = vec4(1.) * stripes;\n}*/", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4tdSDj.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[228, 262, 303, 303, 453]], "test": "valid"}
{"id": "4tdSDS", "name": "Transformation Using Smin", "author": "Ark", "description": "Demo: a transformation by using smooth minimum and distance function\n\n A Japanese article about this work\nhttps://trapti.tech/blog/4273/", "tags": ["transformation"], "likes": 3, "viewed": 2191, "published": "Public", "date": "1481559441", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI 3.14159265359\n#define INF 1e10\n#define EPS 1e-10\n#define ITER_MAX 10000\n\nfloat crs(vec2 v1, vec2 v2) {\n    return v1.x*v2.y - v1.y*v2.x;\n}\n\n// smooth min\n// reference: http://iquilezles.org/www/articles/smin/smin.htm\nfloat smin(float a, float b, float k) {\n    float res = exp(-k*a) + exp(-k*b);\n    return -log(res)/k;\n}\n\nfloat ellipse(vec2 p, vec2 r) {\n    return (length(p/r) - 1.0) * min(r.x, r.y);\n}\n\nfloat line(vec2 p, vec2 v1, vec2 v2) {\n    p  -= v1;\n    vec2 v = v2-v1;\n    float t = dot(p, normalize(v));\n    if (t<0.0) {\n        return length(p);\n    } else if (t>length(v)) {\n        return length(p-v);\n    } else {\n        return abs(crs(p, normalize(v)));\n    }\n}\n\nbool innerTriangle(vec2 p, vec2 v1, vec2 v2, vec2 v3) {\n    float c1 = crs(v2-v1, p-v1);\n    float c2 = crs(v3-v2, p-v2);\n    float c3 = crs(v1-v3, p-v3);\n    return (c1>0.0&&c2>0.0&&c3>0.0) || (c1<0.0&&c2<0.0&&c3<0.0);\n}\n\nfloat StarPolygon(vec2 p, int n, int m, float r) {\n    float d = INF;\n    for (int i=0; i<ITER_MAX; i++) {\n        if (i >= n) break;\n        \n        float rad1 = 2.0*PI*float(i)/float(n);\n        float rad2 = 2.0*PI*float(i+m)/float(n);\n        vec2 v1 = vec2(cos(rad1), sin(rad1)) * r;\n        vec2 v2 = vec2(cos(rad2), sin(rad2)) * r;\n        bool flg = innerTriangle(p, vec2(0.0), v1, v2);\n        d = min(d, line(p, v1, v2) * (flg?-1.0:1.0));\n    }\n    return d;\n}\n\nvec3 calc(vec2 p) {\n    float t = iTime;\n    float r = (sin(t*PI)+1.0) * 0.3 + EPS;\n    float d1 = StarPolygon(p, 5, 2, r);\n    float d2 = ellipse(p, vec2(0.01));\n    float d = smin(d1, d2, 3.5);\n    return vec3(pow(clamp(1.0-d, 0.0, 1.0), 5.0));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\tvec2 uv = (2.0*fragCoord.xy-iResolution.xy) / min(iResolution.x, iResolution.y);\n\tfragColor = vec4(calc(uv),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4tdSDS.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[84, 84, 113, 113, 149], [151, 228, 267, 267, 332], [334, 334, 365, 365, 415], [417, 417, 455, 455, 689], [691, 691, 746, 746, 912], [914, 914, 964, 964, 1384], [1386, 1386, 1405, 1405, 1634], [1636, 1636, 1693, 1693, 1810]], "test": "valid"}
{"id": "4tGGW1", "name": "Clown.glsl", "author": "Flyguy", "description": "Testing basic run-length encoding to compress sprite data using the clown sprite from Space Station 13.\nThe scene is a remake of the video \"Clown.wmv\" https://youtu.be/d2xkpz-26jM", "tags": ["space", "stars", "sprite", "rle", "clown", "ss13"], "likes": 25, "viewed": 3886, "published": "Public API", "date": "1480787593", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n#define MAX_BLUR 12\n#define STAR_SCALE 1.75\n#define STAR_SPEED 1.8\n#define CLOWN_SCALE 2.0\n#define CLOWN_SPIN -0.2\n#define CLOWN_SPEED 0.1\n\n#define CLOWN_SIZE vec2(32,32)\n\n//Run length encoding helpers \n#define L(v,l) if(i >= addr){data = v;}addr+=l;\n#define P(v)   if(i >= addr){data = v;}addr++;\n\n//Palette index definition.\n#define PAL(i,r,g,b,a) if(idx == i){return vec4(r,g,b,a)/255.0;}\n\nfloat pi = atan(1.0)*4.0;\nfloat tau = atan(1.0)*8.0;\n\n//2D rotation matrix from angle.\nmat2 Rotate(float a)\n{\n\t return mat2(cos(a),sin(a),-sin(a),cos(a));\n}\n\n//Clown sprite palette\nvec4 ClownPalette(int idx)\n{\n    PAL(0x00, 0x00, 0x00, 0x00, 0x00) PAL(0x01, 0x00, 0x01, 0x00, 0xFF);\n    PAL(0x02, 0x16, 0x00, 0xFF, 0xFF) PAL(0x03, 0xA4, 0x04, 0x05, 0xFF);\n    PAL(0x04, 0xB0, 0x03, 0x00, 0xFF) PAL(0x05, 0xC4, 0x00, 0x00, 0xFF);\n    PAL(0x06, 0x00, 0x39, 0x59, 0xFF) PAL(0x07, 0xDE, 0x00, 0x04, 0xFF);\n    PAL(0x08, 0xFD, 0x00, 0x00, 0xFF) PAL(0x09, 0xCF, 0x00, 0x97, 0xFF);\n    PAL(0x0A, 0x0A, 0x53, 0x82, 0xFF) PAL(0x0B, 0x3A, 0x3F, 0xE1, 0xFF);\n    PAL(0x0C, 0x08, 0x5F, 0x98, 0xFF) PAL(0x0D, 0x54, 0x55, 0x53, 0xFF);\n    PAL(0x0E, 0x9D, 0x2E, 0xFF, 0xFF) PAL(0x0F, 0xFF, 0x26, 0x33, 0xFF);\n    PAL(0x10, 0xFF, 0x30, 0x97, 0xFF) PAL(0x11, 0x2B, 0x75, 0xA2, 0xFF);\n    PAL(0x12, 0xE3, 0x6B, 0x08, 0xFF) PAL(0x13, 0xF4, 0x7E, 0x14, 0xFF);\n    PAL(0x14, 0x6E, 0x97, 0xB1, 0xFF) PAL(0x15, 0xF9, 0x89, 0x8C, 0xFF);\n    PAL(0x16, 0xA1, 0xA3, 0xA0, 0xFF) PAL(0x17, 0xF4, 0x97, 0x36, 0xFF);\n    PAL(0x18, 0xFF, 0x99, 0x34, 0xFF) PAL(0x19, 0xF5, 0xB6, 0x71, 0xFF);\n    PAL(0x1A, 0x00, 0xFF, 0xFF, 0xFF) PAL(0x1B, 0xD8, 0xCB, 0xCC, 0xFF);\n    PAL(0x1C, 0xFF, 0xC9, 0x95, 0xFF) PAL(0x1D, 0xFF, 0xBF, 0xFD, 0xFF);\n    PAL(0x1E, 0xFF, 0xFF, 0x01, 0xFF) PAL(0x1F, 0xF9, 0xFC, 0xF8, 0xFF);\n    \n    return vec4(0);\n}\n\n//Run length encoded 32x32 clown sprite.\nvec4 Clown(vec2 uv)\n{\n    vec2 size = CLOWN_SIZE;\n    uv = floor(uv * size);\n    \n    if(all(greaterThanEqual(uv, vec2(0))) && all(lessThan(uv, size)))\n    {\n        uv.y = size.y - uv.y - 1.0;\n        int i = int(uv.y * size.x + uv.x);\n        int data = 0;\n        int addr = 0;\n        \n        L(0,41)L(19,3)L(0,7)L(19,3)L(0,18)L(19,6)L(0,3)L(19,6)L(0,16)L(19,6)L(27,5)L(19,6)L(0,15)L(19,4);\n        L(18,2)P(27)P(30)P(31)P(30)P(27)L(18,2)L(19,4)L(0,16)P(19)L(18,3)L(27,2)P(2)P(30)P(2)L(27,2)L(18,3);\n        P(19)L(0,18)L(18,3)P(27)P(31)P(30)P(31)P(30)P(31)P(27)L(18,3)L(0,21)P(22)P(27)P(31)P(21)P(15)P(21);\n        P(31)P(27)P(23)L(0,22)P(22)P(0)L(27,2)P(31)P(21)P(31)L(27,2)L(0,24)P(22)P(0)P(23)L(27,3)P(23)L(0,25);\n        P(20)P(3)P(29)L(25,3)P(29)P(3)P(20)L(0,22)P(20)P(17)P(29)P(3)L(31,3)P(3)P(29)P(17)P(20)L(0,20)P(3);\n        P(8)P(17)P(10)P(29)P(3)P(31)P(3)P(29)P(10)P(17)P(8)P(3)L(0,18)P(3)L(29,2)P(17)P(12)L(3,5)P(12)P(17);\n        L(29,2)P(3)L(0,17)P(3)L(8,2)P(17)P(10)P(13)L(8,4)P(10)P(17)L(8,2)P(3)L(0,16)P(3)P(29)L(3,2)P(17);\n        P(12)P(13)L(29,4)P(12)P(17)L(3,2)P(29)P(3)L(0,15)P(3)P(8)P(3)P(0)P(17)P(10)L(8,5)P(10)P(17)P(0)P(3);\n        P(8)P(3)L(0,15)L(3,3)P(0)P(17)P(10)L(29,5)P(10)P(17)P(0)L(3,3)L(0,15)P(23)P(28)P(25)P(23)P(17)P(10);\n        L(8,4)P(1)P(10)P(17)P(23)P(25)P(28)P(23)L(0,15)P(23)P(28)L(25,2)P(12)L(29,4)P(1)P(26)P(1)P(12)L(25,3);\n        P(23)L(0,15)P(23)P(25)P(28)P(23)P(3)P(17)P(10)L(6,3)P(10)P(17)P(3)P(23)L(25,2)P(23)L(0,14)L(3,2);\n        L(23,2)P(7)L(8,5)L(1,3)P(8)P(7)L(23,2)L(3,2)L(0,13)P(3)P(8)L(7,2)L(8,11)L(7,2)P(8)P(3)L(0,13)P(3);\n        L(8,2)L(7,5)P(5)L(7,4)P(5)L(7,3)P(8)P(3)L(0,13)P(3)L(8,2)L(7,2)L(5,4)L(7,3)P(5)L(4,2)P(5)P(7)P(8);\n        P(3)L(0,14)L(3,2)L(5,4)L(4,7)L(5,2)L(3,2)L(0,16)L(3,3)L(4,4)P(3)P(4)P(5)L(3,5)L(0,19)L(3,10)L(0,23);\n        L(3,4)P(0)L(3,4)L(0,17)L(3,4)P(0)L(3,2)L(30,2)P(3)P(0)P(3)L(30,2)L(3,2)P(0)L(3,4)L(0,10)P(3)P(11);\n        P(14)P(9)P(16)L(3,2)P(15)P(24)P(30)P(3)P(0)P(3)P(30)P(24)P(15)L(3,2)P(16)P(9)P(14)P(11)P(3)L(0,8);\n        L(3,12)P(0)L(3,12)L(0,4);\n        \n        return ClownPalette(data);\n    }\n    \n    return vec4(0);\n}\n\n//Overly complicated starfield effect.\nvec4 StarPlane(vec2 uv, float dens, int blur)\n{\n    dens = 1.0 - dens;\n    vec2 res = iChannelResolution[1].xy;\n    uv = floor(uv * res);\n    \n    vec4 acc = vec4(0.0);\n    \n    for(int i = -MAX_BLUR;i <= MAX_BLUR;i++)\n    {\n        if(i >= -blur && i <= blur)\n        {\n            vec4 n = step(dens, texture(iChannel1, (uv + vec2(i,0))/res));\n            acc += n * (cos(pi * float(i) / float(blur + 1)) * 0.5 + 0.5);\n        }\n    }\n    \n\treturn acc;\n}\n\nvec4 StarField(vec2 uv)\n{\n    vec4 scroll = STAR_SPEED * vec4(1.0, 0.25, 0.11, 0.0625) * iTime;\n    scroll = floor(scroll * iChannelResolution[1].x)/iChannelResolution[1].x;\n    \n    float s = 0.0;\n    \n    s += StarPlane(uv / STAR_SCALE + vec2(scroll.x,0), 0.001, 12).r * 1.00;\n    s += StarPlane(uv / STAR_SCALE + vec2(scroll.y,0), 0.001, 6).g * 0.75;\n    s += StarPlane(uv / STAR_SCALE + vec2(scroll.z,0), 0.005, 3).b * 0.50;\n    s += StarPlane(uv / STAR_SCALE + vec2(scroll.w,0), 0.005, 2).a * 0.25;\n    \n\treturn vec4(vec3(s), 1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 res = iResolution.xy / iResolution.y;\n\tvec2 uv = fragCoord.xy / iResolution.y;\n    uv -= res/2.0;\n    \n    vec4 color = vec4(0,0,0,1);\n    \n    vec2 cluv = uv;\n    \n    cluv.x -= mix(0.4, -res.x*0.75, 1.0/(1.0 + iTime * CLOWN_SPEED));\n    cluv.y -= 0.1 * sin(iTime * 0.2);\n    cluv *= Rotate(iTime * CLOWN_SPIN);\n    cluv *= CLOWN_SCALE;\n    cluv += 0.5;\n    \n    vec4 stars = StarField(uv);\n    vec4 clown = Clown(cluv);\n    \n    color.rgb = mix(color.rgb, stars.rgb, stars.a);\n    color.rgb = mix(color.rgb, clown.rgb, clown.a);    \n    \n\tfragColor = vec4(color);\n}", "image_inputs": [{"id": "Xsf3zn", "previewfilepath": "/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "channel": 1, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture"}, {"id": "Ms2GRD", "previewfilepath": "https://soundcloud.com/hppel32/clownwmv", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "https://soundcloud.com/hppel32/clownwmv", "ctype": "musicstream"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4tGGW1.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[448, 481, 503, 503, 550], [3971, 4010, 4057, 4057, 4466], [4468, 4468, 4493, 4493, 5006], [5008, 5008, 5065, 5065, 5642]], "test": "error"}
{"id": "4tGSRD", "name": "Double Phoenix", "author": "russ", "description": "The phoenix fractal with an extra feedback step.", "tags": ["julia"], "likes": 8, "viewed": 588, "published": "Public API", "date": "1483166024", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//A 'Double Phoenix' fractal\n//Julia is Zn+1 = Zn^2 + c\n//Phoenix is Zn+1 = Zn^2 + c + a * Zn-1\n//I added a term of b * Zn-2, just for fun\n//a, b, and c real-only for symmetry\n//It looks nice\n//Using Morgan's heatmap gradient\n//https://www.shadertoy.com/view/4dsSzr\n\nvec3 heatmapGradient(float t) {\n    t = 2.*abs(.5-fract(t));\n\treturn clamp((pow(t, 1.5) * 0.8 + 0.2) * vec3(smoothstep(0.0, 0.35, t) + t * 0.5, smoothstep(0.5, 1.0, t), max(1.0 - t * 1.7, t * 7.0 - 6.0)), 0.0, 1.0);\n}\n\nfloat phoenix(vec2 p, vec3 c){\n\tvec2 p1 = vec2(0), p2=p1;\n    for(int i=0;i<100;i++){\n     \tvec2 tmp = p, sq = p*p;\n        if(sq.x + sq.y > 65536.)\n            return float(i) - log2(log2(sq.x+sq.y)*.0625);\n        p = vec2(sq.x-sq.y+c.x,2.*p.x*p.y) + c.y*p1 + c.z*p2;\n        p2 = p1;\n        p1 = tmp;\n    }\n    return -1.;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = 3.*(fragCoord.xy -.5 * iResolution.xy) / iResolution.y;\n    float t = phoenix(uv.yx, sin(iTime*vec3(.13,.17,.19)));\n    vec3 col = t > 0. ? heatmapGradient(log(t) + .1*iTime) : vec3(.05);\n\tfragColor = vec4(col ,1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4tGSRD.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[267, 267, 298, 298, 484], [486, 486, 516, 516, 814], [816, 816, 873, 873, 1103]], "test": "valid"}
{"id": "4tKSzz", "name": "Alex Kluchikov's isosurface sd", "author": "klk", "description": "Kluchikov's isosurfce", "tags": ["isosurface", "kluchikov"], "likes": 12, "viewed": 612, "published": "Public API", "date": "1482532429", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI 3.1415926535897932384626433832795\n\n#define float3 vec3\n#define float2 vec2\n#define float4 vec4\n#define float3x3 mat3\n\nconst float MAX_RAY_LENGTH=10000.0;\n\nvoid RP(float3 tp0, float3 dp1, float3 dp2, float3 rp0, float3 rd, out float t, out float3 uv, out float3 n)\n{\n\tfloat3 dp0=rp0-tp0;\n\n\tfloat3 dett =cross(dp1,dp2);\n\tfloat3 detuv=cross(dp0,rd);\n\n\tfloat det=(-1.0)/dot(dett,rd);\n\n\tfloat u=(dot(detuv,dp2))*det;\n\tfloat v=(dot(detuv,dp1))*det;\n\tt=(dot(dett ,dp0))*det;\n    if(t<0.0)\n    {\n        t=MAX_RAY_LENGTH;\n        return;\n    }\n    \n\tuv=float3(u,v,0.0);\n    n=normalize(dett);\n}\n\nfloat arws(float2 p, float t)\n{\n    float2 p1=float2(p.x+p.y,p.x-p.y);\n    float2 f1xy=abs(fract(p1/sqrt(8.0))-0.5)-0.25;\n    f1xy=clamp(f1xy*t+0.5,0.0,1.0);\n    float f1=mix(f1xy.x,1.0-f1xy.x,f1xy.y);\n\n    float2 fxy=float2(p.x-sqrt(0.125),p.y);\n  \tfxy=abs(fract((fxy*sqrt(2.0)+0.5)/2.0)-0.5)-0.25;\n    fxy=clamp(fxy*t/sqrt(2.0)+0.5,0.0,1.0);\n    float f=mix(fxy.x,1.0-f1,fxy.y);\n\n    return f;\n}\n\nvoid trace(float3 rp0, float3 rd, out float t, out float3 pos, out float3 n)\n{\n    float t1=MAX_RAY_LENGTH;\n    float3 col1;\n    float3 n1;\n   \tRP(float3(0.0,-5.0,0.0),float3(-1.0,0.0,0.0),float3(0.0,0,1.0),rp0, rd, t1, col1, n1);\n    pos=rp0+rd*t1;\n    t=t1;\n}\n\nfloat value(float3 p)\n{\n    float mv=iMouse.x/iResolution.x;\n    p.y-=1.0;\n    float v=0.0;\n    float a=atan(p.x,p.z);\n    float a0=a*7.0/3.0+iTime;\n    float a1=a0+PI/3.0*2.0;\n    float a2=a0+PI/3.0*2.0*2.0;\n    \n    float d0=length(float2(p.x,p.z))-3.0;\n    float v0=length(float2(d0+sin(a0)*0.5,p.y+cos(a0)*0.5));\n    float v1=length(float2(d0+sin(a1)*0.5,p.y+cos(a1)*0.5));\n    float v2=length(float2(d0+sin(a2)*0.5,p.y+cos(a2)*0.5));\n    v=v0*v1/(v0+v1);\n    v=v*v2/(v+v2);\n   \n    return v-0.05-(sin(a*5.0)+1.0)*0.09;\n}\n\nbool raymarch(float3 start, float3 d, float t0, float t1,float stp, float th, out float t)\n{\n    t=t0;\n    \n    for(int i=0;i<300;i++)\n    {\n\t    float3 p=start+d*t;\n        float v=value(p);\n        if(v<0.0)\n            return true;\n        t+=0.0025+v;\n    }\n    return false;\n}\n\nfloat3 calcN(float3 p)\n{\n    float3 n;\n    float d=0.005;\n    float n0=value(p);\n    n.x=value(p+float3(d,0.0,0.0))-n0;\n    n.y=value(p+float3(0.0,d,0.0))-n0;\n    n.z=value(p+float3(0.0,0.0,d))-n0;\n\n    n=normalize(n);\n    return n;\n}\n\nfloat nrand( vec2 n )\n{\n\treturn fract(sin(dot(n.xy, vec2(12.9898, 78.233)))* 43758.5453);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float3 campos=float3(-10.0,3.0,0.0);\n    float3 look_at=float3(0.0,0.5,0.0);\n    float3 up=float3(0,1,0);\n    float3 forward;\n    float3 right;\n\n    float3 light=float3(0,10,10);\n\n    float T=iTime*0.45;\n    \n    light.x=cos(T)*10.0;\n    light.z=sin(T)*10.0;\n    light.y=5.0;\n    \n    float mposx=iMouse.x;\n    float mposy=iMouse.y;\n    if(iMouse.z<0.0)mposx=-iMouse.z;\n    if(iMouse.w<0.0)mposy=-iMouse.w;\n    \n    float a1=(0.6+(mposy/iResolution.y-0.5)*0.7)*PI;\n\n    if(iMouse.y<0.01)\n        a1=PI*0.75;\n\n    float a2=mposx/iResolution.x*PI*2.0-PI/3.0;\n    campos.y=cos(a1)*campos.x;\n    float camx=sin(a1)*campos.x;\n    campos.x=cos(a2)*camx;\n    campos.z=sin(a2)*camx;\n    light=campos*2.0;\n    light.x=0.0;\n    light.z=15.0;\n    light.y=25.0;\n//    campos+=look_at;\n    \n    forward=normalize(look_at-campos);\n    right=normalize(cross(up,forward));\n    up=normalize(cross(forward,right));\n    \n  \n\tfloat2 scr = fragCoord.xy /iResolution.xy;\n    scr=2.0*scr-1.0;\n\n    float2 scr2ray=scr;\n    scr2ray.x*=(iResolution.x/iResolution.y);\n\tfloat2 uv=scr2ray;\n    float3 ray=normalize(forward+(up*uv.y+right*uv.x)*0.5);\n\n    float3 col=float3(0.0,0.5,0.0);\n    float3 n;\n\tfloat t;\n\tfragColor.rgb=float3(0.5,0.3,0.1);\n    float3 fogcol=mix(float3(0.87,0.8,0.83),float3(0.3,0.6,1.0),1.0-(1.0-ray.y)*(1.0-ray.y));\n   \tfragColor.rgb=fogcol;\n    float3 tpos;\n    trace(campos, ray, t, tpos, n);\n    col=mix(float3(0.87,0.85,0.83),float3(0.1,0.15,0.4),\n                smoothstep(0.0,1.0,arws(tpos.xz*0.2,16000.0/t/t)));\n\n    if(t<MAX_RAY_LENGTH)\n\t{\n        \n        col=mix(fogcol,col,exp(-t*0.01));\n    \tfragColor.rgb=col;\n    }\n    {\n    \tfloat t1;\n        float3 start=campos;\n        if(raymarch(start,ray,2.5-nrand(scr),11.0,0.0,8.5,t1))\n        {\n            if(t1<t)\n            {\n            \tfloat3 p=start+ray*t1;\n            \tfloat3 n=calcN(p);\n                float3 tolight=normalize(light-p);\n\t\t\t    float3 halfn=normalize(tolight-ray);\n                \n                float lamb=pow(clamp(dot(n,tolight),0.0,1.0),1.5)*0.8+0.2;\n                float3 refray=reflect(ray,n);\n\n                float spec1=clamp(dot(halfn,n),0.0,1.0);\n                float spec2=clamp(dot(tolight,refray),0.0,1.0);\n\n\t\t\t    float3 reffog=mix(float3(0.87,0.8,0.83),float3(0.3,0.6,1.0),1.0-(1.0-refray.y)*(1.0-refray.y));\n\n                float3 n1;\n                col=lamb*float3(0.8,0.81,0.83)*1.3;\n                float3 rpos;\n                float3 rcol;\n\t\t\t\ttrace(p, reflect(ray,n), t1, rpos, n1);\n    \t\t\tif(t1<MAX_RAY_LENGTH)\n                {\n\t\t\t\t    rcol=mix(float3(0.87,0.85,0.83),float3(0.1,0.12,0.4),\n                \t\tsmoothstep(0.0,1.0,arws(rpos.xz*0.2,2000.0/t1/t1/t1)));\n\t\t\t        rcol=mix(reffog,rcol,exp(-t1*0.02));\n                }\n                else\n                {\n                    rcol=reffog;\n                }\n                {\n                    col=mix(col,rcol,pow(clamp(1.0-dot(ray,-n),0.0,1.0),0.8)*0.65+0.4);\n                    col*=float3(1.0,0.8,0.5);\n                    col=mix(col,float3(1,1.03,1.2),pow(spec1,20.0)*0.8+0.6*pow(spec2,80.0));\n                    col*=float3(1.1,0.95,0.65);\n//                    col=rcol;\n                    \n//\t\t\t    \tfragColor.rgb=mix(col,fragColor.rgb,pow(dot(ray,n),15.0));\n                }\n//                fragColor.rgb=0.5+n*0.5;\n                fragColor.rgb=col;\n//                fragColor.rgb=float3(pow(spec2,10.0));\n            }\n        }\n    }\n    \n    fragColor.a=1.0;\n   \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4tKSzz.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[166, 166, 276, 276, 597], [599, 599, 630, 630, 996], [998, 998, 1076, 1076, 1259], [1261, 1261, 1284, 1284, 1786], [1788, 1788, 1880, 1880, 2069], [2071, 2071, 2095, 2095, 2305], [2307, 2307, 2330, 2330, 2398], [2400, 2400, 2457, 2457, 5923]], "test": "valid"}
{"id": "4ttSDS", "name": "null vier", "author": "hencz", "description": ".", "tags": ["cubes"], "likes": 1, "viewed": 106, "published": "Public", "date": "1481460213", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define DISTANCE_ITERATIONS 120\n#define PI 3.14159\n\nvec3 rY(in vec3 p, float a)\n{\n\tfloat c,s;vec3 q=p;\n\tc = cos(a); s = sin(a);\n\tp.x = c * q.x + s * q.z;\n\tp.z = -s * q.x + c * q.z;\n    return p;\n}\n\nvec3 rZ(in vec3 p, float a)\n{\n\tfloat c,s;vec3 q=p;\n\tc = cos(a); s = sin(a);\n\tp.x = c * q.x - s * q.y;\n\tp.y = s * q.x + c * q.y;\n    return p;\n}\n\nfloat udBox(in vec3 p, in vec3 b)\n{\n    return length(max(abs(p)-b,0.0));\n}\n\nfloat render(in vec3 p)\n{\n    float d = 10000.0;\n    vec3 q = p + vec3(0., 0., 4.0);\n            \n    d = min(d, udBox(rZ(rY(p + vec3(-.75, 0., 4.0), .125 * .125 * iTime * PI), .25 * PI), vec3(.15, .25 + abs(cos(iTime * PI)) * .5, .15)));\n    d = min(d, udBox(rZ(rY(p + vec3(.75, 0., 4.0), .125 * .125 * iTime * PI), .25 * PI), vec3(.15, .25 + abs(sin(iTime * PI * 2.)) * .5, .15)));\n    return d;\n}\n\nfloat trace(in vec3 o, in vec3 d)\n{\n    float t = 0.0;\n    for (int i = 0; i < DISTANCE_ITERATIONS; i++)\n    {\n        vec3 p = o + d * t;\n        t += render(p) * 0.5;\n    }\n    return t;\n}\n\nmat3 getCameraMatrix(in vec3 forward, in vec3 up)\n{\n    vec3 left = normalize(cross(forward, up));\n    vec3 realUp = normalize(cross(left, -forward));\n    return mat3(left, realUp, -forward);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    uv = uv * 2.0 - 1.0;\n    vec2 uvO = uv;\n    uv.x *= iResolution.x / iResolution.y; \n    vec3 o = vec3(0.0, 0.0, 10.0);\n    float fov = 8.0;\n    vec3 forward = vec3(0, 0, 1.);\n    vec3 d = getCameraMatrix(forward, vec3(0.0, 1.0, 0.0)) * normalize(vec3(uv, fov));\n    float t = trace(o, d);\n    if (t > 100.0)\n        fragColor = vec4(mix(vec3(0.878, 0.604, 0.969), vec3(0.251, 0.941, 0.69), 0.5 - uvO.y * .5), 1.);\n    else\n        fragColor = vec4(mix(vec3(0.878, 0.604, 0.969), vec3(0.251, 0.941, 0.69), uvO.y * .5 + .5), 1.);\n}", "image_inputs": [{"id": "MdS3WD", "previewfilepath": "https://soundcloud.com/playmodul/playmodul-null-vier-b-zckr04", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "https://soundcloud.com/playmodul/playmodul-null-vier-b-zckr04", "ctype": "musicstream"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4ttSDS.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[52, 52, 81, 81, 196], [198, 198, 227, 227, 341], [343, 343, 378, 378, 418], [420, 420, 445, 445, 819], [821, 821, 856, 856, 1011], [1013, 1013, 1064, 1064, 1206], [1208, 1208, 1265, 1265, 1844]], "test": "valid"}
{"id": "4ttSRj", "name": "Endless Passageway", "author": "Shane", "description": "Using various cheap methods to produce a detailed, albeit rudimentary, looking scene without the extra cost.", "tags": ["raymarching", "map", "bump", "columns", "corridor"], "likes": 44, "viewed": 1339, "published": "Public API", "date": "1480781405", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/*\n\n\tEndless Passageway\n\t------------------\n\t\n    Combining techniques like normal-based edging, bump mapping and bump-based edging to produce \n\ta detailed looking surface without the high cost. I'm using concepts from my \"Twisted Geometry\"\n\texample, but applying them to a less abstract setting... Although, an endless corridor with \n\tdubious lighting and shadows is hardly realistic. :)\n\n\tI'd orginally started with a nice, ornate, carved-timber scene, then for some inexplicable reason \n\tdecided that a grungey, slightly mystical, pseudo-metallic-marble Islamic look was the order of \n\tthe day. I put it in the weird, but interesting category. :)\n\n\tThe distance function is very basic. It's possible to create a much more interesting setting,\n\tbut I wanted to keep the base geometry simple in order to achieve decent frame rates.\t\n\n\tAnyway, it's just a simple artsy example. Not to be taken seriously. I'll put up something more\n\tinteresting later.\n\n\t\n\t// Related example.\n\n\t// A room with columns example using much nicer distance function geometry and atmosphere.\n\tCatacombs - IQ\n\thttps://www.shadertoy.com/view/lsf3zr\n\n\t// Gorgeous example.\n    Castle Tunnel - Hamneggs\n\thttps://www.shadertoy.com/view/Xs3Xzn\n\n\n*/\n\n// Maximum ray distance.\n#define FAR 50.\n\n// Comment this out to omit the detailing. Basically, the bump mapping won't be included.\n#define SHOW_DETAILS\n\n// The edges give it subtle detail. Not entirely necessary, but adds just a little more depth.\n#define SHOW_EDGES\n\nfloat objID; // Structure object ID.\nfloat bObjID; // Bump map detail ID.\n\n// 2D rotation. Always handy. Angle vector, courtesy of Fabrice.\nmat2 rot( float th ){ vec2 a = sin(vec2(1.5707963, 0) - th); return mat2(a, -a.y, a.x); }\n\n// Camera path. Arranged to coincide with the frequency of the lattice.\nvec3 camPath(float t){\n  \n    //return vec3(0, 0, t); // Straight path.\n    \n    // Curvy path. Weaving around the columns.\n    float a = sin(t * 3.14159265/24. + 1.5707963);\n    float b = cos(t * 3.14159265/32.);\n    \n    return vec3(a*4.35, b*a, t);    \n}\n\n\n// Smooth minimum. Courtesy of IQ.\nfloat sminP( float a, float b, float smoothing ){\n\n    float h = clamp((b-a)/smoothing*.5 + .5, 0., 1.);\n    return mix(b, a, h) - smoothing*h*(1. - h);\n}\n\n// Smooth tiles. There are better ways, but it works.\nfloat tiles(vec2 p){\n\n    p = fract(p);\n    \n    float s = pow( 16.*p.x*p.y*(1.0-p.x)*(1.0-p.y), 0.125);\n    \n    return smoothstep(0., 1., s);\n\n}\n\n// Standard lattice variation, of which there are infinitely many. This is only called by the \n// bump mapping function to add some detail to the structure. You could certainly incorporate it\n// into the distance function, but it would slow it down considerably.\nfloat lattice(vec3 p){\n \n\n    // Repeat field entity one, which is just some square tubes repeated in all directions every \n    // two units, then combined with a minimum function. Otherwise known as a lattice.\n    p = abs(mod(p, 2.) - 1.);\n\tfloat x1 = min(max(p.x, p.y), min(max(p.y, p.z), max(p.x, p.z))) - .32;//.5 + p.y*.1;// - .32;\n    \n\n    // Repeat field entity two, which is just an abstract object repeated every half unit. \n    p = abs(mod(p,  .5) - .25);\n    float x2 = min(p.x, min(p.y, p.z));\n    \n    bObjID = step(x2, x1);\n    \n    \n\n    // Combining the two entities above.\n    return max(x1, x2) - .08;    \n    \n}\n\n// Standard lattice variation, of which there are infinitely many.\nfloat columns(vec3 p){\n    \n    // Repeat field entity one, which is just some square tubes repeated in all directions every \n    // four units.\n    p = abs(mod(p, 4.) - 2.);\n\t\n    float x1 = max(p.x, p.z)- .32; //Columns.\n\t//float x1 = min(max(p.x, p.y), min(max(p.y, p.z), max(p.x, p.z))) - .32; // Lattice, for comparison.\n    \n    float bl = max(max(p.x - .5, p.z - .5), p.y + .1); // Column header and footer. Boxes.\n    \n    \n    x1 = min(x1, bl); // Column with header and footer.\n    \n\n    // Repeat field entity two, which is just an abstract object repeated every half unit. \n    p = abs(mod(p,  .5) - .25);\n    float x2 = min(p.x, min(p.y, p.z)); // Carving out the columns with a repeat object.\n    \n    objID = step(x1, x2-.05); // ID, to give the column two different materials.\n\n    // Combining the two entities above.\n    return max(x1, x2) - .05;   \n    \n    \n}\n\n// Nothing more than some columns enclosed with a floor, ceiling and walls. Pretty simple.\nfloat map(vec3 p){\n    \n    \n    float d =  columns(p); // Repeat columns.\n    \n    float fl = p.y + 2.5; // Floor.\n\n    p = abs(p);\n    \n    d = sminP(d, -(p.y - 2.5 - d*.75), 1.5); // Add a smooth ceiling.\n    \n    d = min(d, -(p.x - 5.85)); // Add the Walls.\n    \n    d = sminP(d, fl, .25); // Smoothly combine the floor.\n     \n    return d*.75;\n}\n\n// Raymarching. Pretty standard. Nothing fancy.\nfloat trace(vec3 ro, vec3 rd){\n\n    float t = 0., d;\n    for (int i=0; i<80; i++){\n\n        d = map(ro + rd*t);\n        if(abs(d)<.001*(t*.125 + 1.) || t>FAR) break;\n        t += d;\n    }\n    \n    return min(t, FAR);\n}\n\n// Tri-Planar blending function. Based on an old Nvidia writeup:\n// GPU Gems 3 - Ryan Geiss: http://http.developer.nvidia.com/GPUGems3/gpugems3_ch01.html\nvec3 tex3D(sampler2D channel, vec3 p, vec3 n){\n\n    \n    n = max(abs(n) - .2, 0.001);\n    n /= dot(n, vec3(1));\n\tvec3 tx = texture(channel, p.yz).xyz;\n    vec3 ty = texture(channel, p.xz).xyz;\n    vec3 tz = texture(channel, p.xy).xyz;\n    \n    // Textures are stored in sRGB (I think), so you have to convert them to linear space \n    // (squaring is a rough approximation) prior to working with them... or something like that. :)\n    // Once the final color value is gamma corrected, you should see correct looking colors.\n    return tx*tx*n.x + ty*ty*n.y + tz*tz*n.z;\n}\n\n// The bump mapping function.\nfloat bumpFunction(in vec3 p){\n    \n   \n    // A reproduction of the lattice at higher frequency. Obviously, you could put\n    // anything here. Noise, Voronoi, other geometrical formulas, etc.\n    //return min(abs(columns(p*4.)*.34 + lattice(p*4.)*.66)*1.6, 1.);\n    float c = 0.;\n    \n    // The logic is simple, but a little messy.\n    if(p.y>2.15) c = min(abs(lattice(p*3.))*1.6, 1.); // Ceiling.\n    else if(p.y>-2.15) c = min(abs(lattice(p*4.))*1.6, 1.); // Columns.\n    else c = max(tiles(p.xz + .5) - min(abs(lattice(p*2.))*1.6, 1.), 0.)*.5; // Floor.\n    \n    return c;  \n   \n}\n\n// Standard function-based bump mapping function with some edging thrown into the mix.\nvec3 doBumpMap(in vec3 p, in vec3 n, float bumpfactor, inout float edge){\n    \n    // Resolution independent sample distance... Basically, I want the lines to be about\n    // the same pixel with, regardless of resolution... Coding is annoying sometimes. :)\n    vec2 e = vec2(3./iResolution.y, 0); \n    \n    float f = bumpFunction(p); // Hit point function sample.\n    \n    float fx = bumpFunction(p - e.xyy); // Nearby sample in the X-direction.\n    float fy = bumpFunction(p - e.yxy); // Nearby sample in the Y-direction.\n    float fz = bumpFunction(p - e.yyx); // Nearby sample in the Y-direction.\n    \n    float fx2 = bumpFunction(p + e.xyy); // Sample in the opposite X-direction.\n    float fy2 = bumpFunction(p + e.yxy); // Sample in the opposite Y-direction.\n    float fz2 = bumpFunction(p+ e.yyx);  // Sample in the opposite Z-direction.\n    \n     \n    // The gradient vector. Making use of the extra samples to obtain a more locally\n    // accurate value. It has a bit of a smoothing effect, which is a bonus.\n    vec3 grad = vec3(fx - fx2, fy - fy2, fz - fz2)/(e.x*2.);  \n    //vec3 grad = (vec3(fx, fy, fz ) - f)/e.x;  // Without the extra samples.\n\n\n    // Using the above samples to obtain an edge value. In essence, you're taking some\n    // surrounding samples and determining how much they differ from the hit point\n    // sample. It's really no different in concept to 2D edging.\n    edge = abs(fx + fy + fz + fx2 + fy2 + fz2 - 6.*f);\n    edge = smoothstep(0., 1., edge/e.x);\n    \n    // Some kind of gradient correction. I'm getting so old that I've forgotten why you\n    // do this. It's a simple reason, and a necessary one. I remember that much. :D\n    grad -= n*dot(n, grad);          \n                      \n    return normalize(n + grad*bumpfactor); // Bump the normal with the gradient vector.\n\t\n}\n\n// The normal function with some edge detection rolled into it. Sometimes, it's possible to get away\n// with six taps, but we need a bit of epsilon value variance here, so there's an extra six.\nvec3 nr(vec3 p, inout float edge, float t){ \n\t\n    vec2 e = vec2(3./iResolution.y, 0); // Larger epsilon for greater sample spread, thus thicker edges.\n\n    // Take some distance function measurements from either side of the hit point on all three axes.\n\tfloat d1 = map(p + e.xyy), d2 = map(p - e.xyy);\n\tfloat d3 = map(p + e.yxy), d4 = map(p - e.yxy);\n\tfloat d5 = map(p + e.yyx), d6 = map(p - e.yyx);\n\tfloat d = map(p)*2.;\t// The hit point itself - Doubled to cut down on calculations. See below.\n     \n    // Edges - Take a geometry measurement from either side of the hit point. Average them, then see how\n    // much the value differs from the hit point itself. Do this for X, Y and Z directions. Here, the sum\n    // is used for the overall difference, but there are other ways. Note that it's mainly sharp surface \n    // curves that register a discernible difference.\n    edge = abs(d1 + d2 - d) + abs(d3 + d4 - d) + abs(d5 + d6 - d);\n    //edge = max(max(abs(d1 + d2 - d), abs(d3 + d4 - d)), abs(d5 + d6 - d)); // Etc.\n    \n    // Once you have an edge value, it needs to normalized, and smoothed if possible. How you \n    // do that is up to you. This is what I came up with for now, but I might tweak it later.\n    edge = smoothstep(0., 1., sqrt(edge/e.x*2.));\n\t\n    // Redoing the calculations for the normal with a more precise epsilon value.\n    e = vec2(.005*min(1. + t, 5.), 0);\n\td1 = map(p + e.xyy), d2 = map(p - e.xyy);\n\td3 = map(p + e.yxy), d4 = map(p - e.yxy);\n\td5 = map(p + e.yyx), d6 = map(p - e.yyx); \n    \n    // Return the normal.\n    // Standard, normalized gradient mearsurement.\n    return normalize(vec3(d1 - d2, d3 - d4, d5 - d6));\n}\n\n// I keep a collection of occlusion routines... OK, that sounded really nerdy. :)\n// Anyway, I like this one. I'm assuming it's based on IQ's original.\nfloat cao(in vec3 p, in vec3 n){\n\t\n    float sca = 1., occ = 0.;\n    for(float i=0.; i<5.; i++){\n    \n        float hr = .01 + i*.5/4.;        \n        float dd = map(n * hr + p);\n        occ += (hr - dd)*sca;\n        sca *= 0.7;\n    }\n    return clamp(1.0 - occ, 0., 1.);    \n}\n\n\n// Cheap shadows are hard. In fact, I'd almost say, shadowing particular scenes with limited \n// iterations is impossible... However, I'd be very grateful if someone could prove me wrong. :)\nfloat softShadow(vec3 ro, vec3 lp, float k){\n\n    // More would be nicer. More is always nicer, but not really affordable... Not on my slow test machine, anyway.\n    const int maxIterationsShad = 20; \n    \n    vec3 rd = (lp-ro); // Unnormalized direction ray.\n\n    float shade = 1.0;\n    float dist = 0.05;    \n    float end = max(length(rd), 0.001);\n    //float stepDist = end/float(maxIterationsShad);\n    \n    rd /= end;\n\n    // Max shadow iterations - More iterations make nicer shadows, but slow things down. Obviously, the lowest \n    // number to give a decent shadow is the best one to choose. \n    for (int i=0; i<maxIterationsShad; i++){\n\n        float h = map(ro + rd*dist);\n        //shade = min(shade, k*h/dist);\n        shade = min(shade, smoothstep(0.0, 1.0, k*h/dist)); // Subtle difference. Thanks to IQ for this tidbit.\n        //dist += min( h, stepDist ); // So many options here: dist += clamp( h, 0.0005, 0.2 ), etc.\n        dist += clamp(h, 0.01, 0.2);\n        \n        // Early exits from accumulative distance function calls tend to be a good thing.\n        if (h<0.001 || dist > end) break; \n    }\n\n    // I've added 0.5 to the final shade value, which lightens the shadow a bit. It's a preference thing.\n    return min(max(shade, 0.) + 0.2, 1.0); \n}\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n\n    \n    // Screen coordinates.\n\tvec2 u = (fragCoord - iResolution.xy*0.5)/iResolution.y;\n\t\n\t// Camera Setup.\n    float speed = 3.;\n    vec3 ro = camPath(iTime*speed); // Camera position, doubling as the ray origin.\n    vec3 lk = camPath(iTime*speed + .1);  // \"Look At\" position.\n    //vec3 lp = camPath(iTime*speed + 4.); // Light position, somewhere near the moving camera.\n\tvec3 lp = vec3(0, 0, iTime*speed) + vec3(0, .5, 3.5);//\n\n\n    // Using the above to produce the unit ray-direction vector.\n    float FOV = 3.14159/3.; ///3. FOV - Field of view.\n    vec3 fwd = normalize(lk-ro);\n    vec3 rgt = normalize(vec3(fwd.z, 0., -fwd.x )); \n    vec3 up = cross(fwd, rgt);\n\n    // Unit direction ray.\n    //vec3 rd = normalize(fwd + FOV*(u.x*rgt + u.y*up));\n    \n    // Mild lens distortion. The sheer straight edged geometry is was getting to me. :) \n    vec3 rd = fwd + FOV*(u.x*rgt + u.y*up);\n    rd = normalize(vec3(rd.xy, (rd.z - length(rd.xy)*.125)*.75));\n    \n    // Swiveling the camera from left to right when turning corners.\n    rd.xy = rot(-camPath(lk.z).x/32. )*rd.xy;\n    \n    \n    // Raymarch.\n    float t = trace(ro, rd);\n    float svObjID = objID;\n    \n    // Surface hit point.\n    vec3 sp = ro + rd*t;\n    \n    // Normal with edge component.\n    float edge;\n    vec3 sn = nr(sp, edge, t);\n    \n    //float svObjID = objID;\n    \n    // Shadows and ambient self shadowing.\n    float sh = softShadow(sp, lp, 16.); // Soft shadows.\n    float ao = cao(sp, sn); // Ambient occlusion.\n    \n    // Light direction vector setup and light to surface distance.\n    lp -= sp;\n    float lDist = max(length(lp), .0001);\n    lp /= lDist;\n    \n    // Attenuation.\n    float atten = 1. / (1.0 + lDist*lDist*.15);\n    \n    \n    // More fake lighting. This was just a bit of trial-and-error to produce some repetitive,\n    // slightly overhead, spotlights throughout the space. Cylinder in XY, sine repeat\n    // in the Z direction over three rows... Something like that.\n    vec3 spl = sp;\n    spl.x = mod(spl.x, 2.) - 1.;\n    float spot = max(4. - length(spl.xy - vec2(0, 2.)), 0.)*(sin((spl.z + 1.)*3.14159/2.)*.5+.5);\n    spot = smoothstep(0.25, 1., spot); \n        \n\n   \n    // Heavy bump. We do this after texture lookup, so as not to disturb the normal too much.\n    float edge2 = 0.;\n    float svBObjID = 0.;\n    #ifdef SHOW_DETAILS\n    sn = doBumpMap(sp, sn, .15/(1. + t/FAR), edge2); \n    svBObjID = bObjID;\n    #endif    \n    \n    \n    // Diffuse, specular and Fresnel.\n    float dif = max(dot(lp, sn), 0.);\n    //dif = pow(dif, 4.)*0.66 + pow(dif, 8.)*0.34; // Ramping up the diffuse to make it shinier.\n    float spe = pow(max(dot(reflect(rd, sn), lp), 0.), 6.);\n    float fre = pow(clamp(dot(rd, sn) + 1., 0., 1.), 4.);\n    \n    \n    \n    // Texturing the object. I'm not a fan of this messy logic, epspecially the nesting, but it \n    // doesn't have a great impact on the speed, plus it's easy enough to follow.\n    vec3 tx;\n    if(sp.y>2.25) { // && sp.y<2.25\n        tx = tex3D(iChannel0, sp/2., sn)*1.; //Ceiling.\n    }\n    else if((sp.y)>1.88) {\n        tx = tex3D(iChannel1, sp/1., sn); // Top column footers.\n        tx = smoothstep(0.025, .7, tx);\n\n    }\n    else if(sp.y>-1.88) {\n        \n        // Columns.        \n        if(svObjID>.5) { \n        \ttx = tex3D(iChannel1, sp/1., sn);\n        \ttx = smoothstep(0.025, .7, tx);\n        }\n        else tx = tex3D(iChannel0, sp/4. + .5, sn)*1.; \n\n    }\n    else if((sp.y)>-2.25) {\n        tx = tex3D(iChannel1, sp/1., sn); // Bottom column footers.\n        tx = smoothstep(0.025, .7, tx);\n\n    }\n    else {\n        tx = tex3D(iChannel0, sp/4. + .5, sn); // Floor.\n        tx = smoothstep(-.15, .9, tx);\n        if (svBObjID>.5) tx *= 2./1.25; // Slighty lighten part of the bumped pattern.\n    }\n\n    \n    \n    #ifdef SHOW_EDGES\n    // Applying the normal-based and bump mapped edges.\n    tx *= (1.-edge*.7)*(1.-edge2*.7);\n    #endif\n    \n    \n    \n    // Combining the terms above to produce the final color.\n    vec3 fc = tx *(dif + .25 + vec3(.5, .7, 1)*fre*4.) + vec3(1, .7, .3)*spe*3. + spot*tx*3.;\n    fc *= atten*sh*ao;\n    \n    // Mixing in a bright sunny... distant light. Not really sure what it is. :) Setting\n    //  \"bg\" to black gives it a different, probably more realistic look, but is a bit dull.\n    vec3 bg = mix(vec3(1, .5, .3), vec3(1, .9, .5), rd.y*.5+.5);    \n    //bg /= 300.; \n    fc = mix(fc, bg*1.25, smoothstep(0., .9, t/FAR)); //1./(1. + t*t*.002)\n   \n    // Post processing.\n    fc = fc*.65 + vec3(1.2, 1.05, .9)*pow(max(fc, 0.), vec3(1, 1.2, 1.5))*.35; // Contrast, coloring.\n    \n\n    // Vignette.\n    u = fragCoord/iResolution.xy;\n    fc = min(fc, 1.)*pow( 16.0*u.x*u.y*(1.0-u.x)*(1.0-u.y) , .125);    \n \n\n    //fc = vec3(ao); // Uncomment this to see the AO and the scene without the bump detailing.\n    \n    // Approximate gamma correction.\n\tfragColor = vec4(sqrt(clamp(fc, 0., 1.)), 1.0);\n}", "image_inputs": [{"id": "XsXGRn", "previewfilepath": "/media/ap/cd4c518bc6ef165c39d4405b347b51ba40f8d7a065ab0e8d2e4f422cbc1e8a43.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/cd4c518bc6ef165c39d4405b347b51ba40f8d7a065ab0e8d2e4f422cbc1e8a43.jpg", "ctype": "texture"}, {"id": "XdfGRn", "previewfilepath": "/media/ap/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4ttSRj.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1565, 1630, 1651, 1651, 1719], [1721, 1793, 1815, 1916, 2050], [2053, 2088, 2137, 2137, 2242], [2244, 2298, 2318, 2318, 2444], [2446, 2709, 2731, 2919, 3340], [3342, 3409, 3431, 3553, 4288], [4290, 4381, 4399, 4399, 4731], [4733, 4781, 4811, 4811, 4999], [5001, 5155, 5201, 5201, 5726], [5728, 5758, 5788, 6021, 6344], [6346, 6433, 6506, 6689, 8254], [8256, 8450, 8493, 8493, 10111], [10113, 10265, 10297, 10297, 10543], [10546, 10737, 10781, 10898, 12013], [12016, 12016, 12070, 12103, 16969]], "test": "error"}
{"id": "4ttSWl", "name": "Factory Flythrough", "author": "dr2", "description": "  Building model based on imaginative \"Industrial Complex\" by Shane; use\n  mouse to look around.\n", "tags": ["raymarching", "fractal", "architecture", "flight"], "likes": 16, "viewed": 822, "published": "Public API", "date": "1482165995", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// \"Factory Flythrough\" by dr2 - 2016\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\n/*\n  Building model based on imaginative \"Industrial Complex\" by Shane; use\n  mouse to look around.\n*/\n\nconst float pi = 3.14159;\n\nfloat PrSphDf (vec3 p, float s);\nfloat PrCylDf (vec3 p, float r, float h);\nfloat PrCylAnDf (vec3 p, float r, float w, float h);\nfloat PrRCylDf (vec3 p, float r, float rt, float h);\nfloat PrRoundBoxDf (vec3 p, vec3 b, float r);\nvec2 Rot2D (vec2 q, float a);\nfloat Fbm1 (float p);\nfloat Fbm3 (vec3 p);\nvec3 VaryNf (vec3 p, vec3 n, float f);\n\nvec3 dronePos, ltPos, ltAx;\nvec2 aTilt;\nfloat tCur, dstFar, bumpShd;\nint idObj;\nconst int idBase = 1, idWall = 2, idFlCl = 3, idCyl = 4, idCol = 5, idRail = 6,\n   idWire = 7, idLt = 8, idDrBod = 11, idDrLamp = 12, idDrCam = 13;\n\nvec3 TrackPath (float t)\n{\n   return vec3 (cos (2. * t * pi / 64.) * 5.5, cos (0.5 * 2. * t * pi / 64.), t);\n}\n\nfloat DroneDf (vec3 p, float dMin)\n{\n  vec3 q, qq;\n  float d;\n  const float dSzFac = 6.;\n  dMin *= dSzFac;\n  qq = dSzFac * (p - dronePos);\n  qq.yz = Rot2D (qq.yz, - aTilt.y);\n  qq.yx = Rot2D (qq.yx, - aTilt.x);\n  q = qq;\n  q.y -= 0.05;\n  d = PrRCylDf (q.xzy, 0.2, 0.03, 0.07);\n  if (d < dMin) { dMin = d;  idObj = idDrBod; }\n  q.y -= 0.07;\n  d = PrRoundBoxDf (q, vec3 (0.06, 0.02, 0.12), 0.04);\n  if (d < dMin) { dMin = d;  idObj = idDrLamp; }\n  q = qq;\n  q.y -= -0.05;\n  d = PrSphDf (q, 0.17);\n  if (d < dMin) { dMin = d;  idObj = idDrCam; }\n  q = qq;\n  q.xz = abs (q.xz) - 0.7;\n  d = min (PrCylAnDf (q.xzy, 0.5, 0.05, 0.05), PrCylDf (q.xzy, 0.1, 0.03));\n  q -= vec3 (-0.4, -0.15, -0.4);\n  d = min (d, PrRCylDf (q.xzy, 0.05, 0.03, 0.2));\n  q -= vec3 (-0.3, 0.2, -0.3);\n  q.xz = Rot2D (q.xz, 0.25 * pi);\n  d = min (d, min (PrRCylDf (q, 0.05, 0.02, 1.), PrRCylDf (q.zyx, 0.05, 0.02, 1.)));\n  if (d < dMin) { dMin = d;  idObj = idDrBod; }\n  return dMin / dSzFac;\n}\n\nfloat ObjDf (vec3 p)\n{\n  vec3 w, q, qq;\n  float dMin, d, dm, dc;\n  dMin = dstFar;\n  w = vec3 (16., 8., 16.);\n  q = abs (mod (p + vec3 (4., 0., 0.), 2. * w) - w);\n  w = vec3 (16., 1., 8.);\n  qq = abs (mod (p, 2. * w) - w);\n  d = max (p.y + 3.5, 8. - max (qq.x + 0.35, q.z));\n  if (d < dMin) { dMin = d;  idObj = idBase; }\n  d = max (max (qq.x - 8., qq.z - 2.15),\n     min (1.75 - abs (abs (qq.x - 8.) - 4.), 0.5 - abs (q.y - 8.)));\n  if (d < dMin) { dMin = d;  idObj = idWall; }\n  dm = 2.85 - min (max (2.1 - p.y, q.z - 2.), abs (mod (p.z + 16., 32.) - 16.));\n  qq.x = abs (qq.x - 8.);\n  d = max (dm, min (max (qq.x, qq.y), max (qq.x, abs (mod (qq.z, 2.) - 1.))) - 0.15);\n  if (d < dMin) { dMin = d;  idObj = idRail; }\n  qq.y = abs (mod (qq.y + 0.1667, 0.333) - 0.1667);\n  d = max (dm, max (length (qq.xy) - 0.025, - p.y - 3.));\n  if (d < dMin) { dMin = d;  idObj = idWire; }\n  q.xz = abs (q.xz - vec2 (8.));\n  q.x = abs (q.x - 4.);\n  qq = abs (mod (q, 2.) - 1.);\n  dm = min (qq.x, min (qq.y, qq.z));\n  dc = max (max (q.x, q.y) - 3., - p.y);\n  d = max (dm, min (dc, max (q.y, q.z) * 0.55 + length (q.yz) * 0.45 - 5.1)) - 0.15;\n  if (d < dMin) { dMin = d;  idObj = idFlCl; }\n  d = max (dm, min (dc, max (q.x, q.z) - 2.)) - 0.15;\n  if (d < dMin)  { dMin = d;  idObj = idCol; }\n  d = length (vec2 (q.xz) * vec2 (0.7, 0.4)) - 1.;\n  if (d < dMin) { dMin = d;  idObj = idCyl; }\n  w = vec3 (16., 8., 8.);\n  qq = mod (p + vec3 (16., 0., 0.), 2. * w) - w;\n  qq.xz = abs (qq.xz);\n  qq.x = abs (qq.x - 4.);\n  qq.y += 5.2;\n  d = PrCylDf (qq.xzy, 0.3, 0.1);\n  if (d < dMin) { dMin = d;  idObj = idLt; }\n  dMin = DroneDf (p, dMin);\n  return dMin;\n}\n\nfloat ObjRay (vec3 ro, vec3 rd)\n{\n  float dHit, d;\n  dHit = 0.;\n  for (int j = 0; j < 80; j ++) {\n    d = ObjDf (ro + dHit * rd);\n    dHit += d;\n    if (d < 0.001 || dHit > dstFar) break;\n  }\n  return dHit;\n}\n\nfloat MengFun (vec3 p)\n{\n  vec3 q, qm;\n  float s, d, dd;\n  s = 16.;\n  p *= 4.;\n  q = abs (mod (p, s) - 0.5 * s);\n  qm = max (q.yzx, q.zxy);\n  d = max (0., min (qm.x, min (qm.y, qm.z)) - s / 3. + 1.);\n  s /= 3.;\n  q = abs (mod (p, s) - 0.5 * s);\n  qm = max (q.yzx, q.zxy);\n  d = max (d, min (qm.x, min (qm.y, qm.z)) - s / 3.);\n  s /= 3.;\n  q = abs (mod (p, s) - 0.5 * s);\n  qm = max (q.yzx, q.zxy);\n  dd = min (qm.x, min (qm.y, qm.z)) - s / 3.;\n  bumpShd = step (d, dd);\n  d = min (abs (max (d, dd)) * 1.6, 1.);\n  return d;\n}\n\nvec3 MengSurf (vec3 p, vec3 n, float f)\n{\n  vec3 g;\n  vec2 e = vec2 (0.001, 0);\n  g = vec3 (MengFun (p + e.xyy), MengFun (p + e.yxy), MengFun (p + e.yyx)) -\n     MengFun (p);\n  return normalize (n + f * (g - n * dot (n, g)));\n}\n\nfloat TileFun (vec2 p)\n{\n  p = abs (fract (4. * p) - 0.5);\n  return smoothstep (0., 0.3, max (p.x, p.y));\n}\n\nvec3 TileFloor (vec3 p, float f)\n{\n  vec2 g;\n  vec2 e = vec2 (0.001, 0);\n  g = f * (vec2 (TileFun (p.xz + e.xy), TileFun (p.xz + e.yx)) - TileFun (p.xz));\n  return normalize (vec3 (g.x, 1., g.y));\n}\n\nvec3 ObjNf (vec3 p)\n{\n  vec4 v;\n  vec3 e = vec3 (0.001, -0.001, 0.);\n  v = vec4 (ObjDf (p + e.xxx), ObjDf (p + e.xyy),\n     ObjDf (p + e.yxy), ObjDf (p + e.yyx));\n  return normalize (vec3 (v.x - v.y - v.z - v.w) + 2. * v.yzw);\n}\n\nvec4 DroneCol ()\n{\n  vec4 objCol;\n  if (idObj == idDrBod) objCol = vec4 (0.2, 0.9, 0.2, 1.);\n  else if (idObj == idDrLamp) objCol = mix (vec4 (0.3, 0.3, 1., -2.),\n     vec4 (2., 0., 0., 0.2), step (0., sin (10. * tCur)));\n  else if (idObj == idDrCam) objCol = vec4 (0.1, 0.1, 0.1, 1.);\n  return objCol;\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  vec4 col4;\n  vec3 col, vn, ltDir;\n  vec2 pb;\n  float dHit, f, ltDist, atten, brt;\n  int idObjT;\n  dHit = ObjRay (ro, rd);\n  if (dHit < dstFar) {\n    ro += rd * dHit;\n    idObjT = idObj;\n    vn = ObjNf (ro);\n    idObj = idObjT;\n    ltDir = ltPos - ro;\n    ltDist = length (ltDir);\n    ltDir /= ltDist;\n    atten = 1.2 * smoothstep (0.55, 0.65, dot (ltAx, - ltDir)) /\n       pow (max (ltDist, 1.), 1.2);\n    pb = abs (mod (ro.xz + vec2 (16., 0.), 2. * vec2 (16., 8.)) - vec2 (16., 8.));\n    pb.x = abs (pb.x - 4.);\n    brt = (ro.y < 2. && length (pb) < 0.7) ? 0.2 : 0.;\n    if (idObj == idLt) {\n      col = vec3 (1., 1., 0.3) * (0.9 - 0.1 * vn.y);\n    } else if (idObj >= idDrBod) {\n      col4 = DroneCol ();\n      col = col4.xyz;\n      if (col4.a >= 0.)\n        col = col * (0.2 + 0.8 * atten * max (dot (ltDir, vn), 0.)) +\n           atten * pow (max (dot (reflect (rd, vn), ltDir), 0.), 64.);\n    } else {\n      if (idObj == idBase) vn = TileFloor (ro, 150.);\n      else if (idObj != idRail && idObj != idWire)\n         vn = MengSurf (ro, vn, 150.);\n      if (idObj != idWire) {\n        vn = VaryNf (32. * ro, vn, 3.);\n        col = 1.5 * mix (vec3 (0.1, 0.2, 0.25), vec3 (0.2, 0.1, 0.05),\n           Fbm3 (3. * ro));\n      } else col = vec3 (0.5, 0.5, 0.6);\n      if (idObj == idBase) col *= TileFun (ro.xz);\n      else if (bumpShd > 0.) col *= 0.7;\n      col = col * (0.2 + 10. * atten * max (dot (ltDir, vn), 0.)) +\n         2. * atten * pow (max (dot (reflect (rd, vn), ltDir), 0.), 32.);\n      col = mix (col, vec3 (1., 1., 0.5), brt);\n      col = mix (col, vec3 (0.6, 0., 0.) * (0.3 + 0.7 * Fbm1 (5. * tCur)),\n         1. - smoothstep (-10., -4.2, ro.y));\n    }\n  } else col = vec3 (0.);\n  f = dHit / dstFar;\n  col = mix (col, 0.3 * vec3 (0.7, 0.9, 1.), smoothstep (0.4, 1., f * f));\n  return col;\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  mat3 vuMat;\n  vec4 mPtr;\n  vec3 ro, rd, vd;\n  vec2 canvas, uv, ori, ca, sa, aa;\n  float el, az, t;\n  canvas = iResolution.xy;\n  uv = 2. * fragCoord.xy / canvas - 1.;\n  uv.x *= canvas.x / canvas.y;\n  tCur = iTime;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / canvas - 0.5;\n  t = 4. * tCur;\n  ro = TrackPath (t);\n  ltPos = ro;\n  ltPos.y += 0.1;\n  dronePos = TrackPath (t + 1.);\n  aTilt = vec2 (6. * (TrackPath (t + 1.1).x - dronePos.x), 0.2);\n  vd = normalize (TrackPath (t + 0.1) - ro);\n  az = 1.2 * (0.5 * pi + atan (- vd.z, vd.x));\n  el = 0.;\n  if (mPtr.z > 0.) {\n    az += 2.1 * pi * mPtr.x;\n    el += pi * mPtr.y;\n  }\n  ori = vec2 (el, az);\n  ca = cos (ori);\n  sa = sin (ori);\n  vuMat = mat3 (ca.y, 0., - sa.y, 0., 1., 0., sa.y, 0., ca.y) *\n          mat3 (1., 0., 0., 0., ca.x, - sa.x, 0., sa.x, ca.x);\n  aa = atan (uv / 1.2);\n  rd = vuMat * normalize (vec3 (1.5 * sin (aa) / (0.5 + cos (aa)), 1.));\n  ltAx = vuMat * vec3 (0., 0., 1.);\n  dstFar = 80.;\n  fragColor = vec4 (pow (clamp (ShowScene (ro, rd), 0., 1.), vec3 (0.8)), 1.0);\n}\n\nfloat PrSphDf (vec3 p, float s)\n{\n  return length (p) - s;\n}\n\nfloat PrCylDf (vec3 p, float r, float h)\n{\n  return max (length (p.xy) - r, abs (p.z) - h);\n}\n\nfloat PrCylAnDf (vec3 p, float r, float w, float h)\n{\n  return max (abs (length (p.xy) - r) - w, abs (p.z) - h);\n}\n\nfloat PrRCylDf (vec3 p, float r, float rt, float h)\n{\n  vec2 dc;\n  float dxy, dz;\n  dxy = length (p.xy) - r;\n  dz = abs (p.z) - h;\n  dc = vec2 (dxy, dz) + rt;\n  return min (min (max (dc.x, dz), max (dc.y, dxy)), length (dc) - rt);\n}\n\nfloat PrRoundBoxDf (vec3 p, vec3 b, float r)\n{\n  return length (max (abs (p) - b, 0.)) - r;\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  return q * cos (a) + q.yx * sin (a) * vec2 (-1., 1.);\n}\n\nconst vec4 cHashA4 = vec4 (0., 1., 57., 58.);\nconst vec3 cHashA3 = vec3 (1., 57., 113.);\nconst float cHashM = 43758.54;\n\nvec2 Hashv2f (float p)\n{\n  return fract (sin (p + cHashA4.xy) * cHashM);\n}\n\nvec4 Hashv4f (float p)\n{\n  return fract (sin (p + cHashA4) * cHashM);\n}\n\nfloat Noiseff (float p)\n{\n  vec2 t;\n  float ip, fp;\n  ip = floor (p);\n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = Hashv2f (ip);\n  return mix (t.x, t.y, fp);\n}\n\nfloat Noisefv2 (vec2 p)\n{\n  vec4 t;\n  vec2 ip, fp;\n  ip = floor (p);\n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = Hashv4f (dot (ip, cHashA3.xy));\n  return mix (mix (t.x, t.y, fp.x), mix (t.z, t.w, fp.x), fp.y);\n}\n\nfloat Noisefv3 (vec3 p)\n{\n  vec4 t1, t2;\n  vec3 ip, fp;\n  float q;\n  ip = floor (p);\n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  q = dot (ip, cHashA3);\n  t1 = Hashv4f (q);\n  t2 = Hashv4f (q + cHashA3.z);\n  return mix (mix (mix (t1.x, t1.y, fp.x), mix (t1.z, t1.w, fp.x), fp.y),\n              mix (mix (t2.x, t2.y, fp.x), mix (t2.z, t2.w, fp.x), fp.y), fp.z);\n}\n\nfloat Fbm1 (float p)\n{\n  float f, a;\n  f = 0.;\n  a = 1.;\n  for (int i = 0; i < 5; i ++) {\n    f += a * Noiseff (p);\n    a *= 0.5;\n    p *= 2.;\n  }\n  return f * (1. / 1.9375);\n}\n\nfloat Fbm3 (vec3 p)\n{\n  float f, a;\n  f = 0.;\n  a = 1.;\n  for (int i = 0; i < 5; i ++) {\n    f += a * Noisefv3 (p);\n    a *= 0.5;\n    p *= 2.;\n  }\n  return f * (1. / 1.9375);\n}\n\nfloat Fbmn (vec3 p, vec3 n)\n{\n  vec3 s;\n  float a;\n  s = vec3 (0.);\n  a = 1.;\n  for (int i = 0; i < 3; i ++) {\n    s += a * vec3 (Noisefv2 (p.yz), Noisefv2 (p.zx), Noisefv2 (p.xy));\n    a *= 0.5;\n    p *= 2.;\n  }\n  return dot (s, abs (n));\n}\n\nvec3 VaryNf (vec3 p, vec3 n, float f)\n{\n  vec3 g;\n  float s;\n  const vec3 e = vec3 (0.1, 0., 0.);\n  s = Fbmn (p, n);\n  g = vec3 (Fbmn (p + e.xyy, n) - s, Fbmn (p + e.yxy, n) - s,\n     Fbmn (p + e.yyx, n) - s);\n  return normalize (n + f * (g - n * dot (n, g)));\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4ttSWl.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[826, 826, 852, 852, 936], [938, 938, 974, 974, 1900], [1902, 1902, 1924, 1924, 3535], [3537, 3537, 3570, 3570, 3745], [3747, 3747, 3771, 3771, 4271], [4273, 4273, 4314, 4314, 4500], [4502, 4502, 4526, 4526, 4609], [4611, 4611, 4645, 4645, 4809], [4811, 4811, 4832, 4832, 5039], [5041, 5041, 5059, 5059, 5345], [5347, 5347, 5382, 5382, 7191], [7193, 7193, 7249, 7249, 8283], [8285, 8285, 8318, 8318, 8345], [8347, 8347, 8389, 8389, 8440], [8442, 8442, 8495, 8495, 8556], [8558, 8558, 8611, 8611, 8790], [8792, 8792, 8838, 8838, 8885], [8887, 8887, 8917, 8917, 8975], [9098, 9098, 9122, 9122, 9172], [9174, 9174, 9198, 9198, 9245], [9247, 9247, 9272, 9272, 9418], [9420, 9420, 9445, 9445, 9644], [9646, 9646, 9671, 9671, 10015], [10017, 10017, 10039, 10039, 10193], [10195, 10195, 10216, 10216, 10371], [10373, 10373, 10402, 10402, 10614], [10616, 10616, 10655, 10655, 10878]], "test": "error"}
{"id": "4ttSWS", "name": "Circular Ray Marching Tunnel", "author": "micantre", "description": "Spinning circular tunnel made with ray marching", "tags": ["circleraymarching"], "likes": 3, "viewed": 119, "published": "Public", "date": "1481596324", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define ITER 16.\n#define SPEED 1.0\n#define ALTERNATE_COLORS false\n#define TWIST true\n\nbool isInCircle(vec2 center, float radius, vec2 point)\n{\n    if(distance(center,point) > radius) return true;\n    else return false;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = (fragCoord/iResolution.xy) * 2. - 1.;\n    uv.x*=iResolution.x/iResolution.y;\n    vec3 color = vec3(0.0);\n    vec2 ray;\n    for(float z=0.;z<ITER;z+=1.){\n        ray = uv*z;\n        float var;\n        if(TWIST){\n            var = (SPEED*iTime+float(z));\n        }\n        else{\n            var = (SPEED*iTime);\n        }\n        ray.x+=sin(var)/1.5;\n        ray.y+=cos(var)/2.0;\n        if(isInCircle(vec2(0.),1.0,ray)){\n            float col;\n            if(ALTERNATE_COLORS){\n            \tif(mod(  z , 2.) == 0.){ col = 0.; } //black\n            \telse { col = 1. -z/ITER;} //faded white\n            }\n            else{\n            \tcol = 1. - z/ITER;\n            }\n            \n            color=vec3(col);\n            break;\n        }\n    }\n    fragColor = vec4(color,1.0);\n}\n\n// credit to: https://www.shadertoy.com/view/Mt3SRf", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4ttSWS.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[86, 86, 142, 142, 220], [222, 222, 279, 279, 1068]], "test": "valid"}
{"id": "4ttXWf", "name": "Tri Col Sample", "author": "aiekick", "description": "Tri Col Sample", "tags": ["sample", "tri", "col"], "likes": 1, "viewed": 135, "published": "Public API", "date": "1481890107", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Created by Stephane Cuillerdier - @Aiekick/2016\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n// Tuned via XShade (http://www.funparadigm.com/xshade/)\n\nfloat shape,camd,time;\n\t\nmat3 RotX(float a){a = radians(a); return mat3(1.,0.,0.,0.,cos(a),-sin(a),0.,sin(a),cos(a));}\nmat3 RotY(float a){a = radians(a); return mat3(cos(a),0.,sin(a),0.,1.,0.,-sin(a),0.,cos(a));}\nmat3 RotZ(float a){a = radians(a); return mat3(cos(a),-sin(a),0.,sin(a),cos(a),0.,0.,0.,1.);}\n\nconst mat3 mx = mat3(0,0,0,0,2.6,0,0,0,2.6);\nconst mat3 my = mat3(2.6,0,0,0,0,0,0,0,2.6);\nconst mat3 mz = mat3(2.6,0,0,0,2.6,0,0,0,0);\n\nvec4 df(vec3 p)\n{\n    vec4 plane = vec4(p.y + 8., vec3(0));\n\tp.xz = mod(p.xz, 10.3) - 10.3 * 0.5; // XY domain repeat\n\tfloat a = p.y * 3. * sin(iTime*0.3); // rotation angle for each frame\n\tp.xz *= mat2(cos(a),sin(a),-sin(a),cos(a)); // XY domain rotation\n\tvec4 obj = vec4(max(abs(p.x)+p.z,-p.z) - 0.5); // triangle df\n\tif (obj.x < plane.x)\n\t\treturn obj;\n\treturn plane;\n}\n\n//FROM IQ Shader https://www.shadertoy.com/view/Xds3zN\nfloat softshadow( in vec3 ro, in vec3 rd, in float mint, in float tmax )\n{\n\tfloat res = 1.0;\n    float t = mint;\n    for( int i=0; i<80; i++ )\n    {\n\t\tfloat h = df( ro + rd*t ).x;\n        res = min( res, 8.*h/t );\n        t += clamp( h, 0.01, 0.10 );\n        if( h<0.001 || t>tmax ) break;\n    }\n    return clamp( res, 0.0, 1.0 );\n}\n\nvec3 nor( vec3 pos, float prec )\n{\n\tvec3 eps = vec3( prec, 0., 0. );\n\tvec3 nor = vec3(\n\t    df(pos+eps.xyy).x - df(pos-eps.xyy).x,\n\t    df(pos+eps.yxy).x - df(pos-eps.yxy).x,\n\t    df(pos+eps.yyx).x - df(pos-eps.yyx).x );\n\treturn normalize(nor);\n}\n\nvec3 shade(vec3 ro, vec3 rd, float d, vec3 lp, vec3 lc, float li)\n{\n\tvec3 p = ro + rd * d;\n\tvec3 ld = normalize(lp-p);\n\tvec3 n = nor(p, 0.1);\n\tvec3 refl = reflect(rd,n);\n\tfloat diff = clamp( dot( n, ld ), 0.0, 1.0 );\n\tfloat sha = softshadow( p, ld, 0.01, 50. );\n\tfloat fre = pow( clamp( 1. + dot(n,rd),0.0,1.0), 4. );\n\tfloat spe = pow(clamp( dot( refl, ld ), 0.0, 1.0 ),16.);\n\treturn ((diff * sha + fre + spe) * lc * li + spe) * sha;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 g = fragCoord.xy;\n    vec2 si = iResolution.xy;\n\tvec2 uv = (g+g-si)/si.y;\n\n    time = iTime;\n\tshape = 0.3;\n    camd = 13.;\n    if (iMouse.z > 0.)\n\t{\n\t\tshape = iMouse.x / si.x * 2. - 1.;\n\t\tcamd = 20. * iMouse.y / si.y; // distance to origin axis\n    }\n\t\n\tvec3 ro = vec3(cos(4.4), sin(2.2), sin(4.4)) * camd;\n  \tvec3 rov = normalize(vec3(0)-ro);\n    vec3 u = normalize(cross(vec3(0,1,0),rov));\n  \tvec3 v = cross(rov,u);\n  \tvec3 rd = normalize(rov + uv.x*u + uv.y*v);\n    \n    float s = 1.;float d = 0.;\n    for(int i=0;i<80;i++)\n    {      \n        if (0.<log(d/s/1e5)) break;\n        s = df(ro+rd*d).x * 0.3;\n        d += s;\n    }\n   \n\tvec3 lp0 = vec3(cos(time), 10., sin(time)); lp0.xz *= 20.;\n\tvec3 lp1 = vec3(cos(time + 1.6), 10., sin(time + 1.6)); lp1.xz *= 15.;\n\tvec3 lp2 = vec3(cos(time + 3.12), 10., sin(time + 3.12)); lp2.xz *= 10.;\n\t\n\tvec3 ca = shade(ro, rd, d, lp0, vec3(1,0.49,0.22), 3.5);\n\tvec3 cb = shade(ro, rd, d, lp1, vec3(0,0.33,0.56), 3.5);\n\tvec3 cc = shade(ro, rd, d, lp2, vec3(0,0.69,0.31), 3.5);\n\n\tfragColor.rgb = mix((ca+cb+cc)/3., df(ro+rd*d).yzw, 0.5);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4ttXWf.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[221, 221, 240, 240, 314], [315, 315, 334, 334, 408], [409, 409, 428, 428, 502], [640, 640, 657, 657, 1011], [1013, 1068, 1142, 1142, 1400], [1402, 1402, 1436, 1436, 1648], [1650, 1650, 1717, 1717, 2085], [2087, 2087, 2144, 2144, 3231]], "test": "valid"}
{"id": "4tVSR1", "name": "Ring Fade", "author": "cacheflowe", "description": "I'm going to attempt to really learn shaders in 2017. This is a warm up. Please let me know if there are better ways to do... everything :)", "tags": ["circle", "fade"], "likes": 13, "viewed": 1048, "published": "Public API", "date": "1482903797", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2  uv = (2. * fragCoord.xy - iResolution.xy) / iResolution.y,\n          center = vec2(0);\n    float speed = 3.0,\n          time = iTime * speed,\n          radius = 0.75 + 0.04 * sin(time),\n          thickness = 0.09 + 0.05 * cos(time),\n          dist = distance(uv, center);\n    fragColor = vec4(smoothstep(thickness/2., 0., abs(dist-radius)));\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4tVSR1.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 411]], "test": "valid"}
{"id": "4tVSzR", "name": "Gyroid", "author": "EvilRyu", "description": "Gyroid, Schwarz P, Schwarz D", "tags": ["raymarching", "geometry", "gyroid", "schwarzminimalsurface"], "likes": 15, "viewed": 717, "published": "Public API", "date": "1482508737", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Created by evilryu\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n#define ROT (iTime*0.5)\nfloat smin(float a, float b, float k)\n{\n    float h = clamp(0.5+0.5*(b-a)/k, 0.0, 1.0);\n    return mix(b, a, h) - k*h*(1.0-h);\n}\n\nfloat smax(float a, float b, float k)\n{\n    return smin(a, b, -k);\n}\n\nmat2 rot(float t)\n{\n    float c=cos(t);\n    float s=sin(t);\n    return mat2(c,-s,s,c);\n}\n\nvec4 texcube(sampler2D sam, vec3 p, vec3 n)\n{\n    p.xz*=rot(ROT);\n    vec4 p1=texture(sam, p.xy);\n    vec4 p2=texture(sam, p.xz);\n    vec4 p3=texture(sam, p.yz);\n    return p1*abs(n.z)+p2*abs(n.y)+p3*abs(n.x);\n}\n\nfloat matid=0.;\n\nfloat map(vec3 p)\n{\n    matid=0.;\n    vec3 q=p;\n    p.xz*=rot(ROT);\n    float time=mod(iTime, 15.0)+2.;\n    // Gyroid\n    float d0=dot(sin(p),cos(p));\n    \n    // Schwarz Primitive\n    //float d0=dot(vec3(1.0), cos(p));\n    \n    // Schwarz Diamond\n    //float d0=sin(p.x)*sin(p.y)*sin(p.z)+sin(p.x)*cos(p.y)*cos(p.z)+cos(p.x)*sin(p.y)*cos(p.z)+cos(p.x)*cos(p.y)*sin(p.z);\n    \n    // Try Shane's variation\n    //float d0=dot(sin(p),cos(p.yzx));\n    \n    float d1=abs(p.y+6.3);\n    float d2=length(p)-min(9.,time);\n    float d=smax(-d0,d2,3.);\n    if(d1<d){matid=1.;d=d1;}\n    return d*0.5;\n}\n\nfloat bump(vec3 p, vec3 n)\n{\n    return dot(texcube(iChannel0, 0.15*p, n).xyz, vec3(0.299, 0.587, 0.114)); \n}\n\nvec3 bump_mapping(vec3 p, vec3 n, float weight)\n{\n    vec2 e = vec2(2./iResolution.y, 0); \n    vec3 g=vec3(bump(p-e.xyy, n)-bump(p+e.xyy, n),\n                bump(p-e.yxy, n)-bump(p+e.yxy, n),\n                bump(p-e.yyx, n)-bump(p+e.yyx, n))/(e.x*2.);  \n    g=(g-n*dot(g,n));\n    return normalize(n+g*weight);\n}\n\nvec3 get_normal(vec3 p) {\n\tconst vec2 e = vec2(0.002, 0);\n\treturn normalize(vec3(map(p + e.xyy)-map(p - e.xyy), \n                          map(p + e.yxy)-map(p - e.yxy),\t\n                          map(p + e.yyx)-map(p - e.yyx)));\n}\n\nfloat intersect(vec3 ro, vec3 rd)\n{\n    float t=0.01,d=0.0;\n    for(int i=0;i<96;++i)\n    {\n        vec3 p=ro+t*rd; \n        d=map(p);\n        if(d<0.001*t||t>100.)\n           \tbreak;\n        t+=d;\n    }\n    if(t>100.)t=-1.0;\n   \n    return t;\n}\n\nfloat get_ao(vec3 p, vec3 n)\n{\n    float r = 0.0, w = 1.0, d;\n    for(float i=1.0; i<5.0+1.1; i++)\n    {\n        d = i/5.0;\n        r += w*(d - map(p + n*d));\n        w *= 0.5;\n    }\n    return 1.0-clamp(r,0.0,1.0);\n}\n\nfloat softshadow( in vec3 ro, in vec3 rd, float mint, float k )\n{\n    float res = 1.0;\n    float t = mint;\n\tfloat h = 1.0;\n    for( int i=0; i<128; i++ )\n    {\n        h = map(ro + rd*t);\n        res = min( res, k*h/t );\n        if( res<0.0001 ) break;\n        t += clamp( h, 0.01, 0.05 );\n    }\n    return clamp(res,0.0,1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 q = fragCoord.xy / iResolution.xy;\n    vec2 p = -1.0 + 2.0 * q;\n    p.x *= iResolution.x/iResolution.y;\n\n    \n    vec3 lookat = vec3(0.0, 0., 0.);\n\tvec3 ro = lookat + vec3(0., 7., -20.5);\n\n    vec3 forward=normalize(lookat-ro);\n    vec3 right=normalize(cross(forward, vec3(0.0, 1.0, 0.0)));\n    vec3 up=normalize(cross(right, forward));\n    \n    vec3 rd=normalize(p.x*right + p.y*up + 2.*forward);\n    \n    float t=intersect(ro,rd);\n    vec3 col=vec3(0.0);\n    if(t>-0.5)\n    {\n        vec3 pos=ro+t*rd;\n        vec3 n=get_normal(pos);\n        \n        vec3 ld0=normalize(vec3(-1.0, 1.0, -.7));\n        \n        vec3 material=vec3(0.4,1.1,0.3);\n        if(matid>0.5)material=vec3(1.0,1.,0.9);\n\t    n=bump_mapping(pos, n, 0.9/(1.+t*0.5));\n        \n        float ao=get_ao(pos,n);\n        \n        float amb=0.5+0.5*n.y;\n        float diff=max(0.0, dot(n,ld0));\n        float bac=max(0.0,dot(n,-ld0));\n        float spec=max(0.0, pow(clamp(dot(ld0, reflect(rd, n)), 0.0, 1.0), 16.0));\n        float sha=softshadow( pos+0.01*n, ld0, 0.0005, 28.0 );\n\t\tvec3 lin=vec3(0.0);\n        \n        lin+=vec3(0.3)*amb*ao;\n        lin+=vec3(7.,4.,3.)*diff*1.0*ao*sha;\n        lin+=vec3(1.0,0.8,0.3)*bac*1.0*ao;\n        lin+=vec3(spec*7.2)*sha;\n        \n        col=lin*0.2*material;\n        col *= min(2000.0*exp(-0.34*t),1.0);\n     }\n    col=pow(clamp(col,0.0,1.0),vec3(0.45));\n    col *= pow( 16.0*q.x*q.y*(1.0-q.x)*(1.0-q.y), 0.1 );\n    fragColor.xyz=col;\n}", "image_inputs": [{"id": "4dX3Rn", "previewfilepath": "/media/ap/bd6464771e47eed832c5eb2cd85cdc0bfc697786b903bfd30f890f9d4fc36657.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/bd6464771e47eed832c5eb2cd85cdc0bfc697786b903bfd30f890f9d4fc36657.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4tVSzR.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[134, 134, 173, 173, 262], [264, 264, 303, 303, 332], [334, 334, 353, 353, 422], [424, 424, 469, 469, 635], [654, 654, 673, 673, 1245], [1247, 1247, 1275, 1275, 1356], [1358, 1358, 1407, 1407, 1671], [1673, 1673, 1698, 1698, 1904], [1906, 1906, 1941, 1941, 2151], [2153, 2153, 2183, 2183, 2370], [2372, 2372, 2437, 2437, 2700], [2702, 2702, 2759, 2759, 4211]], "test": "error"}
{"id": "4tySz1", "name": "Disk - intersection (tweaks)", "author": "MobileForks01", "description": "By iq; forked so I could make it run faster on my phone.  So far haven't done anything interesting, just changed some defines and constants\n\noriginal : https://www.shadertoy.com/view/lsfGDB", "tags": ["3d", "raytracing", "intersection", "disk"], "likes": 3, "viewed": 551, "published": "Public API", "date": "1482731343", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Created by inigo quilez - iq/2013\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n#define SC 3.0\n\n#if 0\n//\n// Elegant way to intersect a planar coordinate system (3x3 linear system)\n//\nvec3 intersectCoordSys( in vec3 o, in vec3 d, vec3 c, vec3 u, vec3 v )\n{\n\tvec3 q = o - c;\n\treturn vec3(\n        dot( cross(u,v), q ),\n\t\tdot( cross(q,u), d ),\n\t\tdot( cross(v,q), d ) ) / \n        dot( cross(v,u), d );\n}\n\n#else\n//\n// Ugly (but faster) way to intersect a planar coordinate system: plane + projection\n//\nvec3 intersectCoordSys( in vec3 o, in vec3 d, vec3 c, vec3 u, vec3 v )\n{\n\tvec3  q = o - c;\n\tvec3  n = cross(u,v);\n    float t = -dot(n,q)/dot(d,n);\n    float r =  dot(u,q + d*t);\n    float s =  dot(v,q + d*t);\n    return vec3(t,s,r);\n}\n\n#endif\t\n\nvec3 hash3( float n )\n{\n    return fract(sin(vec3(n,n+1.0,n+2.0))*vec3(43758.5453123,12578.1459123,19642.3490423));\n}\n\nvec3 shade( in vec4 res )\n{\n    float ra = length(res.yz);\n    float an = atan(res.y,res.z) + 8.0*iTime;\n    float pa = sin(3.0*an);\n\n    vec3 cola = 0.5 + 0.5*sin( (res.w/64.0)*3.5 + vec3(0.0,1.0,2.0) );\n\t\n\tvec3 col = vec3(0.0);\n\tcol += cola*0.4*(1.0-smoothstep( 0.90, 1.00, ra) );\n    col += cola*1.0*(1.0-smoothstep( 0.00, 0.03, abs(ra-0.8)))*(0.5+0.5*pa);\n    col += cola*1.0*(1.0-smoothstep( 0.00, 0.20, abs(ra-0.8)))*(0.5+0.5*pa);\n\tcol += cola*0.5*(1.0-smoothstep( 0.05, 0.10, abs(ra-0.5)))*(0.5+0.5*pa);\n    col += cola*0.7*(1.0-smoothstep( 0.00, 0.30, abs(ra-0.5)))*(0.5+0.5*pa);\n\n\treturn col*.15;\n}\n\nvec3 render( in vec3 ro, in vec3 rd )\n{\n  \t// raytrace\n    vec3 col = vec3( 0.0 );\n\tfor( int i=0; i<32; i++ )\n\t{\n\t\t// position disk\n\t    vec3 r = 2.5*(-1.0 + 2.0*hash3( float(i) ));\nr *= SC;\n        \n        float th = iTime*.5;\n        r.xz = mat2(cos(th), sin(th), -sin(th), cos(th)) * r.xz;\n        \n        // orientate disk\n\t\tvec3 u = .60*normalize( r.zxy );\n        vec3 v = .60*normalize( cross( u, vec3(0.0,1.0,0.0 ) ) );\t\t\t\t\t\t   \n\t\t\n        // intersect coord sys\n        vec3 tmp = intersectCoordSys( ro, rd, r, u, v );\ntmp /= SC;\t\t\n\t    if( dot(tmp.yz,tmp.yz)<1.0 && tmp.x>0.0 ) \n\t    {\n            // shade\t\t\t\n\t\t    col += shade( vec4(tmp,float(i)) );\n\t    }\n\t}\n\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 q = fragCoord.xy / iResolution.xy;\n    vec2 p = -1.0 + 2.0 * q;\n    p.x *= iResolution.x/iResolution.y;\n\n    // camera\n\tvec3 ro = 2.0*vec3(cos(0.5*iTime*1.1),0.0,sin(0.5*iTime*1.1));\n    vec3 ta = vec3(0.0,0.0,0.0);\n    // camera matrix\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(0.0,1.0,0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n\t// create view ray\n\tvec3 rd = normalize( p.x*uu + p.y*vv + 1.0*ww );\n\n    vec3 col = render( ro*SC, rd );\n    \n    fragColor = vec4( col, 1.0 );\n}\n\nvoid mainVR( out vec4 fragColor, in vec2 fragCoord, in vec3 fragRayOri, in vec3 fragRayDir )\n{\n    vec3 off = 2.0*vec3(cos(0.5*iTime*1.1),0.0,sin(0.5*iTime*1.1));\n    vec3 col = render( off + fragRayOri, fragRayDir );\n\n    fragColor = vec4( col, 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4tySz1.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[790, 790, 813, 813, 907], [909, 909, 936, 936, 1516], [1518, 1518, 1557, 1572, 2210], [2212, 2212, 2269, 2269, 2793], [2795, 2795, 2889, 2889, 3049]], "test": "valid"}
{"id": "4tyXz1", "name": "green void (tweaked)", "author": "MobileForks01", "description": "forking to tweak and optimize on mobile\noriginal : https://www.shadertoy.com/view/MscGzj", "tags": ["raymarching"], "likes": 4, "viewed": 529, "published": "Public API", "date": "1482742375", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// various functions from:\n// http://mercury.sexy/hg_sdf/\n// https://www.shadertoy.com/view/Xds3zN\n\n#define PI 3.14159265\n\nfloat fScene(in vec3 p);\n\n///\\todo should really just change this to use the analytical normal from the sphere\nvec3 calcNormal( in vec3 pos )\n{\n\tvec3 eps = vec3( 0.025, 0.0, 0.0 );\n\tvec3 nor = vec3(\n\t    fScene(pos+eps.xyy) - fScene(pos-eps.xyy),\n\t    fScene(pos+eps.yxy) - fScene(pos-eps.yxy),\n\t    fScene(pos+eps.yyx) - fScene(pos-eps.yyx) );\n\treturn normalize(nor);\n}\n\nmat3 persp(in vec3 ro, in vec3 ta, float cr )\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\n\nfloat clamp01(float value)\n{\n    return clamp(value, 0.0, 1.0);\n}\n\nfloat fSphere(in vec3 p, float radius)\n{\n    return length(p) - radius;\n}\n\n// Repeat in three dimensions\nvec3 pMod3(inout vec3 p, vec3 size) {\n\tvec3 c = floor((p + size*0.5)/size);\n\tp = mod(p + size*0.5, size) - size*0.5;\n\treturn c;\n}\n\nfloat fScene(in vec3 p)\n{\n    p.z += iTime;\n    pMod3(p, vec3(3.0));\n    return fSphere(p, 0.5);\n}\n\nvec4 render(in vec3 ro, in vec3 rd)\n{\n    const float tMax = 100.0;\n    const float epsilon = 0.001;\n    \n    float t = 1.0;\n    \n    const vec3 bg = vec3(0);\n    vec3 col = bg;\n    \n    vec3 lightP = ro;\n    \n    for(int n = 0;n < 100; ++n)\n    {\n        vec3 p = ro + rd * t;\n        \n    \tfloat d = fScene(p);\n        \n        if (d > tMax) break;\n        if (d < epsilon)\n        {\n            vec3 light = normalize(lightP - p);\n            vec3 normal = calcNormal(p);\n            \n            // intensity of diffuse light\n            float diff = clamp01(dot(light, normal));\n            \n            // intensity of specular - phong\n            float shininess = 72.0;\n            vec3 reflection = reflect(light, normal);\n            float spec = pow(max(dot(rd, reflection), 0.0), shininess);\n             \n            float lightPower = 1.0 / (0.5 + length(lightP - p)*0.125);\n            \n            col = vec3(0,.1,0);\n            col += diff * vec3(0,0.8,0.0) * lightPower + spec * vec3(1,1,1) * lightPower;\n            break;\n        }\n\n        t += d;\n    }\n    \n    float fogStart = 10.0;\n    float fogDistance = length(rd * (fogStart - max(fogStart, t)));\n    float fogDensity = 0.18;\n    float fogAmount = 1.0 - exp( -fogDistance*fogDensity );\n    vec3  fogColor = vec3(0.);\n    col = mix( col, fogColor, fogAmount );\n    \n    col = pow(col, vec3(0.4545));\n    return vec4(col, 1.0);\n}\n\nvoid mainVR( out vec4 fragColor, in vec2 fragCoord, in vec3 fragRayOri, in vec3 fragRayDir ) \n{\n\tfragColor = render(fragRayOri, fragRayDir);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = -1.0 + 2.0 * fragCoord.xy / iResolution.xy;\n    uv.x *= iResolution.x/iResolution.y;\n    \n    // ray origin\n    vec3 ro = vec3(0.0,1.0,0.0);\n    \n    // mouse look\n    vec2 m = iMouse.xy/iResolution.xy;\n    vec3 look = 100.0*normalize(vec3(sin(-m.x*PI), 0.7*m.y, cos(-m.x*PI)));\n    \n    mat3 ca = persp(ro,look,0.0);\n        \n    // ray direction\n\tvec3 rd = ca * normalize( vec3(uv.xy,2.0) );\n\n\tfragColor = render(ro, rd);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4tyXz1.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[149, 234, 266, 266, 493], [495, 495, 542, 542, 719], [722, 722, 750, 750, 787], [789, 789, 829, 829, 862], [864, 894, 931, 931, 1023], [1025, 1025, 1050, 1050, 1123], [1125, 1125, 1162, 1162, 2531], [2533, 2533, 2628, 2628, 2675], [2677, 2677, 2734, 2734, 3171]], "test": "error"}
{"id": "ll3SD2", "name": "Icebreaker (Voronoi Cracks)", "author": "Hadyn", "description": "A modification of iq's awesome voronoi distance shader to create a fracturing/melting ice pattern.", "tags": ["voronoi"], "likes": 25, "viewed": 757, "published": "Public", "date": "1481710112", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Based on original code by by inigo quilez - iq/2013\n// https://www.shadertoy.com/view/ldl3W8\n// http://www.iquilezles.org/www/articles/voronoilines/voronoilines.htm\n\n// Modified by hadyn lander\n\n// #define ROUNDED_MODE\n#define PHASE_POWER 2.0\n\nvec2 hash2( vec2 p )\n{\n\t// texture based white noise\n\treturn texture( iChannel0, (p+0.5)/256.0, -100.0 ).xy;\n\t\n    // procedural white noise\t\n\t//return fract(sin(vec2(dot(p,vec2(127.1,311.7)),dot(p,vec2(269.5,183.3))))*43758.5453);\n}\n\nvec4 voronoi( in vec2 x )\n{\n    vec2 n = floor(x);\n    vec2 f = fract(x);\n\tvec2 o;\n    //----------------------------------\n    // first pass: regular voronoi\n    //----------------------------------\n\tvec2 mg, mr;\n\tfloat oldDist;\n    \n    float md = 8.0;\n    for( int j=-1; j<=1; j++ )\n    for( int i=-1; i<=1; i++ )\n    {\n        vec2 g = vec2(float(i),float(j));\n\t\to = hash2( n + g );\n        vec2 r = g + o - f;\n        float d = dot(r,r);\n\n        if( d<md )\n        {\n            md = d;\n            mr = r;\n            mg = g;\n        }\n    }\n\t\n    oldDist = md;\n    \n    //----------------------------------\n    // second pass: distance to borders\n    //----------------------------------\n    md = 8.0;\n    for( int j=-2; j<=2; j++ )\n    for( int i=-2; i<=2; i++ )\n    {\n        vec2 g = mg + vec2(float(i),float(j));\n\t\to = hash2( n + g );\n        vec2 r = g + o - f;\n\n        if( dot(mr-r,mr-r)>0.00001 )\n        md = min( md, dot( 0.5*(mr+r), normalize(r-mr) ) );\n    }\n\n    return vec4( md, mr, oldDist );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float timeStep = 0.05*iTime - 0.5;\n    \n    vec2 p = fragCoord.xy/iResolution.xx;\n    p *= 12.0; // higher values zoom out further - don't go too high or the sine waves will become quite obvious...\n    p.x += timeStep*6.0;\n    p.y += timeStep*3.0;\n    vec2 unscaledPos = fragCoord.xy/iResolution.xy;\n    vec4 c = voronoi( p );\n    c.x = 1.0-pow(1.0-c.x, 2.0);\n\n    float cellPhase = p.x + c.y + 2.0*sin((p.y + c.z)*0.8 + (p.x + c.y)*0.4);\n    cellPhase *= 0.025;\n    cellPhase = clamp(abs(mod(cellPhase -timeStep, 1.0)-0.5)*2.0, 0.0, 1.0);\n    cellPhase = pow(clamp(cellPhase*2.0-0.5, 0.0, 1.0), PHASE_POWER);\n    \n    float edgePhase = p.x + 2.0*sin(p.y*0.8 + p.x*0.4);\n    edgePhase *= 0.025;\n    edgePhase = clamp(abs(mod(edgePhase -timeStep, 1.0)-0.5)*2.0, 0.0, 1.0);\n    edgePhase = pow(clamp(edgePhase*2.0-0.5, 0.0, 1.0), PHASE_POWER);\n    \n    float phase = mix(edgePhase, cellPhase, smoothstep(0.0,0.2, edgePhase));\n    float shapedPhase = 1.0-pow(1.0-phase, 2.0);\n\n    vec3 col;\n    \n    #ifdef ROUNDED_MODE\n        col = mix( vec3(0.0,0.6,1.0), vec3(1.0,1.0,1.0), smoothstep( shapedPhase-mix(0.025, 0.001, shapedPhase), shapedPhase, mix(c.x, 0.999-c.w, shapedPhase) ) );\n\t#else\n   \t\tcol = mix( vec3(0.0,0.6,1.0), vec3(1.0,1.0,1.0), smoothstep( phase-0.025, phase, c.x ) );\n    #endif\t\n    \n\tfragColor = vec4(col,1.0);\n}\n", "image_inputs": [{"id": "Xsf3zn", "previewfilepath": "/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ll3SD2.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[247, 247, 269, 299, 480], [482, 482, 509, 509, 1499], [1501, 1501, 1558, 1558, 2892]], "test": "error"}
{"id": "ll3SRX", "name": "foil", "author": "emtower", "description": "foil sheet, test shader", "tags": ["foil"], "likes": 9, "viewed": 14531, "published": "Public API", "date": "1480776854", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// math\nfloat saturate(float x) { return clamp(x,0.0,1.0); }\nfloat mul(vec2 x) { return x.x*x.y; }\n\nmat3 fromEuler(vec3 ang) {\n\tvec2 a1 = vec2(sin(ang.x),cos(ang.x));\n    vec2 a2 = vec2(sin(ang.y),cos(ang.y));\n    vec2 a3 = vec2(sin(ang.z),cos(ang.z));\n    mat3 m;\n    m[0] = vec3(a1.y*a3.y+a1.x*a2.x*a3.x*0.8,a1.y*a2.x*a3.x+a3.y*a1.x*0.8,-a2.y*a3.x*0.8);\n\tm[1] = vec3(-a2.y*a1.x,a1.y*a2.y,a2.x);\n\tm[2] = vec3(a3.y*a1.x*a2.x+a1.y*a3.x*0.8,a1.x*a3.x-a1.y*a3.y*a2.x*0.8,a2.y*a3.y*0.8);\n\treturn m;\n}\nbool intersectionRayQuad(vec3 o, vec3 d, vec2 size, out vec3 p) {\n    p = o - d * o.z / d.z;\n    return bool(mul(step(abs(p.xy),size)));\n}\n\n// color\nfloat textureHologram(vec2 t, vec3 e) {\n    float r = length(t);\n    t.x += e.x * 0.2;\n    \n    float l3 = smoothstep(0.5,0.52,r);\n    float l0 = smoothstep(0.98,0.97,r) * l3;\n    float l1 = saturate(sin(t.y*40.0)*8.0) * saturate(sin((t.y-t.x)*10.0)*8.0+6.0);\n    float l2 = saturate(sin(t.y*160.0)*8.0) * saturate(sin((t.y+t.x)*40.0)*8.0+6.0);\n    float l4 = smoothstep(0.42,0.4,r) * smoothstep(0.39,0.399,r);\n    float l5 = smoothstep(1.0,0.99,r) * smoothstep(0.97,0.98,r);\n    \n    float sum = 0.0;\n    sum += (1.0-l3) * 0.5;\n    sum += l1 * l0;\n    sum += l2 * l0 * (1.0 - l1) * 0.2;\n    sum += l4 * 0.5;\n    sum += l5;\n    return 0.08;\n}\n\n\n// based on iq's https://www.shadertoy.com/view/MsS3Wc\nvec3 hologram(vec2 p, float sum) {\n    vec3 hue = clamp(abs(mod(p.y*0.15*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0); \n    vec3 gray = vec3(1.8);\n    float sat = (cos(p.y)*0.5+0.5) * (0.2+sum*0.8);\n    return mix(gray,hue,sat);\n}\n\nvec3 getObjectColor(vec3 p, vec3 n, vec3 e) {\n    float sum = textureHologram(p.xy,e);\n    \n    // vec\n    vec2 d = p.xy + (sum * 2.0 - 1.0);\n    d += dot(e,n) * 5.5;\n        \n    // get holo color\n    float bright = saturate(0.6 + sum * 0.4);\n    vec3 color = hologram(d,sum) * bright;\n    color *= pow(max(dot(e,-n),0.0),0.6);\n            \n    // reflection\n    vec3 refl = reflect(e,n) + sum * 0.1; \n    //vec3 color_refl = texture(iChannel0,refl).xyz;\n    //color = mix(color,color_refl,(1.0 - sum) * 0.2);    \n        \n    // lighting\n    n.xz += (sum * 2.0 - 1.0) * 0.6;\n    color += pow(max(dot(e,-normalize(n)),0.0), 20.0) * 0.6;\n        \n    return color;    \n}\n\n// main\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\tvec2 iuv = fragCoord.xy / iResolution.xy * 2.0 - 1.0;\n    vec2 uv = iuv;\n    uv.x *= iResolution.x / iResolution.y;    \n    vec2 mouse = iMouse.xy / iResolution.xy * 4.0 - 2.0;\n        \n    // ray\n    vec3 ang = vec3(0.0,sin(iTime)*0.05,cos(iTime*1.5)*0.75);\n    if(iMouse.z > 0.0) ang = vec3(0.0,-mouse.y,mouse.x);\n\tmat3 rot = fromEuler(ang/2.0);\n    \n    vec3 ori = vec3(0.0,0.0,5.0);\n    vec3 dir = normalize(vec3(uv.xy,-3.0));    \n    ori = ori * rot;\n    dir = dir * rot;\n             \n    // color\n    vec3 p;\n    vec3 color = vec3(0.0);\n    if(intersectionRayQuad(ori*1.2,dir,vec2(200.0),p))\n        color = getObjectColor(p,vec3(0.,0.,1.),dir);\n               \n\tfragColor = vec4(color,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ll3SRX.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 8, 33, 33, 60], [61, 61, 80, 80, 98], [100, 100, 126, 126, 496], [497, 497, 562, 562, 635], [637, 646, 685, 685, 1288], [1291, 1346, 1380, 1380, 1578], [1580, 1580, 1625, 1625, 2250], [2252, 2260, 2317, 2317, 3019]], "test": "valid"}
{"id": "ll3XRf", "name": "Bryan's Sky", "author": "bsugiarto", "description": "Sky", "tags": ["sky"], "likes": 2, "viewed": 140, "published": "Public", "date": "1480815700", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/* Bryan's Sky */\n#define MOD2 vec2(.166,.173)\n\n/* uses fractal function to return a float which creates a pattern like effect */\nfloat Hash(vec2 p)\n{\n\tp  = fract(p / MOD2);\n    p += dot(p.xy, p.yx+19.19);\n    return fract(p.x * p.y);\n}\n\n\n/* Noise function takes in a vec2 and mixes with hash function to create cloud pattern */\nfloat Noise( in vec2 x )\n{\n    vec2 p = floor(x);\n    vec2 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n    \n    float res = mix(mix( Hash(p), Hash(p+ vec2(1.0, 0.0)),f.x),\n                    mix( Hash(p+ vec2(.0, 1.0)), Hash(p+ vec2(1.0, 1.0)),f.x),f.y);\n    return res;\n}\n\n\n/* Noise function takes in a vec2 and mixes with the Noise function to create cloud pattern */\nfloat FractalNoise(in vec2 xy)\n{\n\tfloat w = .7;\n\tfloat f = 0.0;\n\n\tfor (int i = 0; i < 3; i++)\n\t{\n\t\tf += Noise(xy) * w;\n\t\tw = w*0.6;\n\t\txy = 2.0 * xy;\n\t}\n\treturn f;\n}\n\n\n/* sky function takes in ray direction and returns the sky color*/\nvec3 GetSky(in vec3 rd)\n{\n\t/* sun config */\n\tvec3 sunLight  = normalize( vec3(  0.33, 0.2,  0.3 ));\n\tvec3 sunColour = vec3(1.0, .58, .39);\n\tfloat sunAmount = max( dot( rd, sunLight), 0.0 );\n\tfloat v = pow(1.0-max(rd.y,0.0),6.);\n\n\t/* base sky */\n\tvec3  sky = mix(vec3(.1, .2, .3), vec3(.32, .32, .32), v);\n\t\n\t/* sun rays */\n\tsky = sky + sunColour * sunAmount * sunAmount * .25;\n\t\n\t/* actual sun */\n\tsky = sky + sunColour * min(pow(sunAmount, 800.0)*1.5, .4);\n\n\t/* clouds */\n\tvec2 cl = rd.xz * (1.0/rd.y);\n\tv = FractalNoise(cl) * .3;\n\tsky = mix(sky, sunColour, v*v);\n\n\treturn clamp(sky, 0.0, 1.0);\n}\n\n\n/* main image function */\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tfloat m = (iMouse.x/iResolution.x)*300.0;\n\tfloat gTime = (iTime*5.0+m+468.0)*.006;\n    vec2 xy = fragCoord.xy / iResolution.xy;\n\tvec2 uv = (-1.0 + 2.0 * xy) * vec2(iResolution.x/iResolution.y,1.0);\n\n\t/* get camera \"look at\" */\n    vec2 p = vec2(200.0 * sin(3.54 * gTime), 200.0 * cos(3.54 * gTime) );\n\tvec3 camTar = vec3(p.x + 5.0,  0.0, -94.0 + p.y);\n\t\n\t/* set camera rotation */\n\tfloat rotate = .3 * sin(gTime*3.0+.5);\n\tvec3 cw = normalize(vec3(camTar.x, 0, camTar.z));\n\tvec3 cp = vec3(sin(rotate), cos(rotate),0.0);\n\tvec3 cu = cross(cw,cp);\n\tvec3 cv = cross(cu,cw);\n\n\t/* set \"look at\" and rotation */\n\tvec3 dir = normalize(uv.x*cu + uv.y*cv + 1.3*cw);\n    \n\t/* create sky from get sky function */\n\tvec3 col;\n\tcol = GetSky(dir);\n    col += vec3(.2,.2,.2);\n\tfragColor=vec4(col,1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ll3XRf.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[48, 130, 150, 150, 236], [239, 329, 355, 355, 597], [600, 695, 727, 727, 859], [862, 929, 954, 972, 1526], [1529, 1555, 1612, 1612, 2399]], "test": "valid"}
{"id": "ll3XRs", "name": "glowing dynamic triangle hole", "author": "zproxy", "description": "from https://www.shadertoy.com/view/MldXzf", "tags": ["raymarching"], "likes": 0, "viewed": 104, "published": "Public", "date": "1481140748", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// \"Quake Logo\" by Krzysztof Narkowicz @knarkowicz\n\nconst float MATH_PI = float( 3.14159265359 );\n\nfloat VisibilityTerm( float roughness, float ndotv, float ndotl )\n{\n\tfloat m2\t= roughness * roughness;\n\tfloat visV\t= ndotl * sqrt( ndotv * ( ndotv - ndotv * m2 ) + m2 );\n\tfloat visL\t= ndotv * sqrt( ndotl * ( ndotl - ndotl * m2 ) + m2 );\n\treturn 0.5 / max( visV + visL, 0.00001 );\n}\n\nfloat DistributionTerm( float roughness, float ndoth )\n{\n\tfloat m2\t= roughness * roughness;\n\tfloat d\t\t= ( ndoth * m2 - ndoth ) * ndoth + 1.0;\n\treturn m2 / ( d * d * MATH_PI );\n}\n\nvec3 FresnelTerm( vec3 specularColor, float vdoth )\n{\n\tvec3 fresnel = clamp( 50.0 * specularColor.y, 0.0, 1.0 ) * specularColor + ( 1.0 - specularColor ) * pow( ( 1.0 - vdoth ), 5.0 );\n\treturn fresnel;\n}\n\nvec3 LightSpecular( vec3 normal, vec3 viewDir, vec3 lightDir, vec3 lightColor, float roughness, vec3 specularColor )\n{\n\tvec3 halfVec = normalize( viewDir + lightDir );\n\n\tfloat vdoth = clamp( dot( viewDir,\thalfVec\t ), 0.0, 1.0 );\n\tfloat ndoth\t= clamp( dot( normal,\thalfVec\t ), 0.0, 1.0 );\n\tfloat ndotv = clamp( dot( normal,\tviewDir  ), 0.0, 1.0 );\n\tfloat ndotl = clamp( dot( normal,\tlightDir ), 0.0, 1.0 );\n    \n   \tvec3\tf = FresnelTerm( specularColor, vdoth );\n\tfloat\td = DistributionTerm( roughness, ndoth );\n\tfloat\tv = VisibilityTerm( roughness, ndotv, ndotl );\n    \n    vec3 specular;\n\tspecular = lightColor * f * ( d * v * MATH_PI * ndotl );\n\treturn specular;\n}\n\nfloat Cylinder( vec3 p, float r, float height ) \n{\n\tfloat d = length( p.xz ) - r;\n\td = max( d, abs( p.y ) - height );\n\treturn d;\n}\n\nfloat Sphere( vec3 p, float s )\n{\n\treturn length( p ) - s;\n}\n\n\nvec3 bary(in vec3 a, in vec3 b, in vec3 c, in vec3 p)\n{\n    // The cross product of two vectors has a magnitude\n    // equal to twice the area of the triangle formed by \n    // the two vectors.\n    vec3 n = cross(b - a, c - a);    \n\tfloat area = dot(n, n);\n\t\n\tif(abs(area) < 0.0001) return vec3(0);\n\t\n\tvec3 v0 = a - p;\n\tvec3 v1 = b - p;\n\tvec3 v2 = c - p;\n\t\n\tvec3 asub = vec3(dot(cross(v1, v2), n),\n\t\t\t\t\t dot(cross(v2, v0), n),\n\t\t\t\t\t dot(cross(v0, v1), n));\n    \n\treturn asub / vec3(area);\n}\n\nbool test(in vec2 a, in vec2 b, in vec2 c, in vec2 p)\n{\n    vec3 v = bary(vec3(a.x, 0., a.y),\n                  vec3(b.x, 0., b.y),\n                  vec3(c.x, 0., c.y),\n                  vec3(p.x, 0., p.y));\n    \n    return v.x > 0. && v.y > 0. && v.z > 0.;\n}\n\n\n\nfloat Box( vec3 p, vec3 b )\n{\n    vec2 a0 = vec2( 1.73,  -1.05);\n    vec2 b0 = vec2(0.45,  .65);\n    vec2 c0 = vec2( .25, -.55);\n\n    vec2 mc = (p.zx    / b.xy * 2. - 1.) ;\n\n    bool t0 = test(a0, b0, c0, mc);\n    \n    \n\tvec3 d = abs( p ) - b;\n\t\n    float filler = min( \n        \n        max( d.x, max( d.y, d.z ) )\n        \n        , 0.0 ) + length( max( d, 0.0 ) );\n    \n    \n    //if (p.y > 0.0)\n    //    return 200.0;\n    \n    return filler;\n    return t0 ? filler: 0.0 ;\n}\n\nfloat Substract( float a, float b )\n{\n    return max( a, -b );\n}\n\nfloat SubstractRound( float a, float b, float r ) \n{\n\tvec2 u = max( vec2( r + a, r - b ), vec2( 0.0, 0.0 ) );\n\treturn min( -r, max( a, -b ) ) + length( u );\n}\n\nfloat Union( float a, float b )\n{\n    return min( a, b );\n}\n\nfloat UnionRound( float a, float b, float k )\n{\n    float h = clamp( 0.5 + 0.5 * ( b - a ) / k, 0.0, 1.0 );\n    return mix( b, a, h ) - k * h * ( 1.0 - h );\n}\n\nfloat TriPrism( vec3 p, float rot )\n{        \n    vec3 q = abs( p );\n    \n     return max(\n        // creates some type of symmetry\n        q.y - 0.5, \n     \n        // vertical line\n        p.x * cos(rot) + p.z * sin(rot)   \n     );\n}\n\nvoid AddTriangle(\n    // spatial point\n    inout vec3 p, \n    inout float canvas,\n\tvec2 A,\t\n    vec2 B,\n\tvec2 C\n\t)\n{\n      \tvec2 a1 = A ;\n    \n    // looks like a steam engine\n        vec2 b1 = B;\n    \n        vec2 c1 = C;\n            \n    \n      \n        float slice2AC = TriPrism(  p + vec3(\n        \n        // up\n        c1.y,\n              // back\n              -0.0,\n              \n              // right\n              c1.x\n        ), \n                                \n                                // rot1 + MATH_PI + 0.8\n                               \n                                -atan(a1.y-c1.y, a1.x-c1.x) + MATH_PI\n                               );\n    \n    \n    \n    // could we have atoolbar so we could move the dots?\n        float slice0BC = TriPrism(  p + vec3(\n        \n        // up\n        b1.y,\n              // back\n              -0.0,\n              \n              // right\n              b1.x\n        ),// rot1 + MATH_PI - 1.1\n                               \n                                -atan(b1.y-c1.y, b1.x-c1.x) \n                               );\n    \n    \n    \n    // atan2(deltaY, deltaX)\n    float slice1BA = TriPrism(  p + vec3(\n        \n        // up\n        a1.y,\n              // back\n              -0.0,\n              \n              // right\n              a1.x \n        ), -atan(b1.y-a1.y, b1.x-a1.x)+ MATH_PI);\n\n    \n    \n    \n        float slice = min(slice2AC,min(slice1BA,slice0BC))                    ;\n\t\t//float slice = slice0BC;\n    \t//float slice = min(slice0BC, slice1BA);\n    \n    \n    \n    float i = \n      \n                           // min means union\n                           // min\n                           \n                           // max means intersect\n                           \n                            max\n                           (slice,\n               Box(  p + vec3(0,0.5,0), vec3(\n                   \n                   // height\n                   2.0, \n                   \n                   //depth\n                   0.05, \n                   \n                   // width\n                   2.0)   )\n               );\n \n    \n    \n    // make A twice as big, while B moves\n     i = min(i,  Box(  p + vec3(a1.y,0.5,a1.x), vec3(\n                   \n                   // height\n                   0.2, \n                   \n                   //depth\n                   0.25, \n                   \n                   // width\n                   0.2)   )\n      );\n        \n    i = min(i,  Box(  p + vec3(b1.y,0.5,b1.x), vec3(\n                   \n                   // height\n                   0.1, \n                   \n                   //depth\n                   0.25, \n                   \n                   // width\n                   0.1)   )\n      );\n    \n        i = min(i,  Box(  p + vec3(c1.y,0.5,c1.x), vec3(\n                   \n                   // height\n                   0.1, \n                   \n                   //depth\n                   0.25, \n                   \n                   // width\n                   0.1)   )\n      );\n    \n    \n    // union\n    //canvas = min(canvas, i);\n    \n    canvas = i;\n}\n\nfloat Scene( vec3 p, mat3 localToWorld )\n{\n    // shadertoy should have time slider.\n    \n    p = p * localToWorld;\n    \n    \n    \n     \n    // can we move the objects?\n    \n    p += vec3(\n        \n        // up\n        0.0 ,\n              // back\n              -2.0,\n              \n              // right\n              0.0 );\n\n    vec2 a1 = vec2( 1.5,  0.6  + cos(iTime)) ;\n    // looks like a steam engine\n    vec2 b1 = vec2(-0.25 + sin(iTime),  1);\n    vec2 c1 = vec2( 0.5, -1);\n\n\n    float canvas = 0.0;\n    \n    AddTriangle(p, canvas, a1, b1, c1);\n    \n    return canvas;\n    \n}\n\nvec2 CastRay( in vec3 ro, in vec3 rd, mat3 localToWorld )\n{\n    const float maxd = 15.0;\n    \n\tfloat h = 0.5;\n    float t = 0.0;\n    float steps = 0.0;\n   \n    for ( int i = 0; i < 150; ++i )\n    {\n        if ( h < 0.001 || t > maxd ) \n        {\n            break;\n        }\n        \n\t    h = Scene( ro + rd * t, localToWorld );\n        t += h;\n        steps += 0.03;\n    }\n\n    if ( t > maxd )\n    {\n        t = -1.0;\n    }\n\t\n    return vec2(t, steps);\n}\n\nvec3 SceneNormal( in vec3 pos, mat3 localToWorld )\n{\n\tvec3 eps = vec3( 0.001, 0.0, 0.0 );\n\tvec3 nor = vec3(\n\t    Scene( pos + eps.xyy, localToWorld ) - Scene( pos - eps.xyy, localToWorld ),\n\t    Scene( pos + eps.yxy, localToWorld ) - Scene( pos - eps.yxy, localToWorld ),\n\t    Scene( pos + eps.yyx, localToWorld ) - Scene( pos - eps.yyx, localToWorld ) );\n\treturn normalize( -nor );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 q = fragCoord.xy / iResolution.xy;\n    vec2 p = -1.0 + 2.0 * q;\n\tp.x *= iResolution.x / iResolution.y;\n\n    // have comera zoom in and out to reveal boundaries\n\tvec3 rayOrigin \t= vec3( 0.0, -0.0, -3.5 + 0.1 *sin( iTime * 2.0) );\n    vec3 rayDir \t= normalize( vec3( p.x, p.y, 2.0 ) );\n    \n    float theta = -0.5 * MATH_PI;\n    mat3 rotX = mat3(\n        vec3( cos( theta ), sin( theta ), 0.0 ),\n        vec3( -sin( theta ), cos( theta ), 0.0 ),\n\t\tvec3( 0.0, 0.0, 1.0 )\n        );    \n    \n    vec2 mo = iMouse.xy / iResolution.xy;    \n    \n    float phi = 0.25 * MATH_PI + 10.0 * mo.x;    \n    //float phi = 0.25 * MATH_PI; \n    \n    // look straight at it. no mouse\n    //float phi = 0.5 * MATH_PI;    \n\n    mat3 rotY = mat3(\n        vec3( 1.0, 0.0, 0.0 ),\n        vec3( 0.0, cos( phi ), sin( phi ) ),\n        vec3( 0.0, -sin( phi ), cos( phi ) )\n        );\n    \n    //mat3 localToWorld = rotX * rotY;    \n    mat3 localToWorld = rotX * rotY;    \n\n\n\tvec3 color = texture( iChannel0, q ).yyy * 0.3;\n    \n\tvec2 result = CastRay( rayOrigin, rayDir, localToWorld );\n    \n    if ( result.x > 0.0 )\n    {\n      color = vec3(result.y*2.0, result.y*0.3, result.y*0.2);\n    }\n    else\n    {\n      color = vec3(0.0, result.y*abs(sin(iTime*1.8)),0.0);\n    }\n    \n    fragColor = vec4( color, 1.0 );\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ll3XRs.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[99, 99, 166, 166, 380], [382, 382, 438, 438, 559], [561, 561, 614, 614, 764], [766, 766, 884, 884, 1431], [1433, 1433, 1483, 1483, 1563], [1565, 1565, 1598, 1598, 1625], [1628, 1628, 1683, 1821, 2118], [2120, 2120, 2175, 2175, 2380], [2384, 2384, 2413, 2413, 2862], [2864, 2864, 2901, 2901, 2928], [2930, 2930, 2982, 2982, 3088], [3090, 3090, 3123, 3123, 3149], [3151, 3151, 3198, 3198, 3309], [3311, 3311, 3348, 3348, 3546], [3548, 3548, 3664, 3664, 6654], [6656, 6656, 6698, 6740, 7239], [7241, 7241, 7300, 7300, 7696], [7698, 7698, 7750, 7750, 8082], [8084, 8084, 8141, 8141, 9437]], "test": "error"}
{"id": "ll3Xzf", "name": "Disk - bounding box", "author": "iq", "description": "Analytical computation of the exact bounding box for an arbitrarily oriented disk.  See  [url]http://iquilezles.org/www/articles/diskbbox/diskbbox.htm[/url] for the derivation.", "tags": ["3d", "aabb", "disk", "bounding", "boundingbox"], "likes": 18, "viewed": 1511, "published": "Public API", "date": "1480916523", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// The MIT License\n// Copyright  2016 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n\n\n// See http://iquilezles.org/www/articles/diskbbox/diskbbox.htm\n//\n//\n// Analytical computation of the exact bounding box for an arbitrarily oriented disk. \n// It took me a good two hours to find the symmetries and term cancellations that \n// simplified the original monster equation into something pretty compact in its final form.\n//\n// For a disk of raius r centerd in the origin oriented in the direction n, has extent e:\n//\n// e = rsqrt(1-n)\n//\n// Derivation and more info in the link above\n\n\n// Other bounding box functions:\n//\n// Disk             - 3D BBox : https://www.shadertoy.com/view/ll3Xzf\n// Cylinder         - 3D BBox : https://www.shadertoy.com/view/MtcXRf\n// Ellipse          - 3D BBox : https://www.shadertoy.com/view/Xtjczw\n// Cone boundong    - 3D BBox : https://www.shadertoy.com/view/WdjSRK\n// Cubic     Bezier - 2D BBox : https://www.shadertoy.com/view/XdVBWd \n// Quadratic Bezier - 3D BBox : https://www.shadertoy.com/view/ldj3Wh\n// Quadratic Bezier - 2D BBox : https://www.shadertoy.com/view/lsyfWc\n\n\n#define AA 3\n\nstruct bound3\n{\n    vec3 mMin;\n    vec3 mMax;\n};\n\n//---------------------------------------------------------------------------------------\n// bounding box for a disk (http://iquilezles.org/www/articles/diskbbox/diskbbox.htm)\n//---------------------------------------------------------------------------------------\nbound3 DiskAABB( in vec3 cen, in vec3 nor, float rad )  // disk: center, normal, radius\n{\n    vec3 e = rad*sqrt( 1.0 - nor*nor );\n    return bound3( cen-e, cen+e );\n}\n\n\n// ray-disk intersection\nfloat iDisk( in vec3 ro, in vec3 rd,               // ray: origin, direction\n             in vec3 cen, in vec3 nor, float rad ) // disk: center, normal, radius\n{\n\tvec3  q = ro - cen;\n    float t = -dot(nor,q)/dot(rd,nor);\n    if( t<0.0 ) return -1.0;\n    vec3 d = q + rd*t;\n    if( dot(d,d)>(rad*rad) ) return -1.0;\n    return t;\n}\n\n\n// ray-box intersection (simplified)\nvec2 iBox( in vec3 ro, in vec3 rd, in vec3 cen, in vec3 rad ) \n{\n\t// ray-box intersection in box space\n    vec3 m = 1.0/rd;\n    vec3 n = m*(ro-cen);\n    vec3 k = abs(m)*rad;\n\t\n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n\n\tfloat tN = max( max( t1.x, t1.y ), t1.z );\n\tfloat tF = min( min( t2.x, t2.y ), t2.z );\n\t\n\tif( tN > tF || tF < 0.0) return vec2(-1.0);\n\n\treturn vec2( tN, tF );\n}\n\nfloat hash1( in vec2 p )\n{\n    return fract(sin(dot(p, vec2(12.9898, 78.233)))*43758.5453);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 tot = vec3(0.0);\n    \n#if AA>1\n    for( int m=0; m<AA; m++ )\n    for( int n=0; n<AA; n++ )\n    {\n        // pixel coordinates\n        vec2 o = vec2(float(m),float(n)) / float(AA) - 0.5;\n        vec2 p = (-iResolution.xy + 2.0*(fragCoord+o))/iResolution.y;\n#else    \n        vec2 p = (-iResolution.xy + 2.0*fragCoord)/iResolution.y;\n#endif\n\n    // camera position\n\tvec3 ro = vec3( -0.5, 0.4, 1.5 );\n    vec3 ta = vec3( 0.0, 0.0, 0.0 );\n    // camera matrix\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(0.0,1.0,0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n\t// create view ray\n\tvec3 rd = normalize( p.x*uu + p.y*vv + 1.5*ww );\n\n    // disk animation\n\tvec3  disk_center = 0.3*sin(iTime*vec3(1.11,1.27,1.47)+vec3(2.0,5.0,6.0));\n\tvec3  disk_axis = normalize( sin(iTime*vec3(1.23,1.41,1.07)+vec3(0.0,1.0,3.0)) );\n    float disk_radius = 0.4 + 0.2*sin(iTime*1.3+0.5);\n\n    // render\n   \tvec3 col = vec3(0.4)*(1.0-0.3*length(p));\n\n    // raytrace disk\n    float t = iDisk( ro, rd, disk_center, disk_axis, disk_radius );\n\tfloat tmin = 1e10;\n    if( t>0.0 )\n\t{\n    \ttmin = t;\n\t\tcol = vec3(1.0,0.75,0.3)*(0.7+0.2*abs(disk_axis.y));\n\t}\n\n    // compute bounding box for disk\n    bound3 bbox = DiskAABB( disk_center, disk_axis, disk_radius );\n\n    \n    // raytrace bounding box\n    vec3 bcen = 0.5*(bbox.mMin+bbox.mMax);\n    vec3 brad = 0.5*(bbox.mMax-bbox.mMin);\n\tvec2 tbox = iBox( ro, rd, bcen, brad );\n\tif( tbox.x>0.0 )\n\t{\n        // back face\n        if( tbox.y < tmin )\n        {\n            vec3 pos = ro + rd*tbox.y;\n            vec3 e = smoothstep( brad-0.03, brad-0.02, abs(pos-bcen) );\n            float al = 1.0 - (1.0-e.x*e.y)*(1.0-e.y*e.z)*(1.0-e.z*e.x);\n            col = mix( col, vec3(0.0), 0.25 + 0.75*al );\n        }\n        // front face\n        if( tbox.x < tmin )\n        {\n            vec3 pos = ro + rd*tbox.x;\n            vec3 e = smoothstep( brad-0.03, brad-0.02, abs(pos-bcen) );\n            float al = 1.0 - (1.0-e.x*e.y)*(1.0-e.y*e.z)*(1.0-e.z*e.x);\n            col = mix( col, vec3(0.0), 0.15 + 0.85*al );\n        }\n\t}\n\t\n        // no gamma required here, it's done in line 118\n\n        tot += col;\n#if AA>1\n    }\n    tot /= float(AA*AA);\n#endif\n\n    // dithering\n    tot += ((hash1(fragCoord.xy)+hash1(fragCoord.yx+13.1))/2.0-0.5)/256.0;\n\n\tfragColor = vec4( tot, 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ll3Xzf.jpg", "access": "shaders20k", "license": "mit", "functions": [[2175, 2441, 2530, 2530, 2607], [2610, 2635, 2796, 2796, 2966], [2969, 3006, 3070, 3108, 3388], [3390, 3390, 3416, 3416, 3483]], "test": "valid"}
{"id": "llcSRj", "name": "Yellow/Blue Bar Optical Illusion", "author": "micantre", "description": "These yellow and blue blocks appear to move one after another, right?\nWhen the black bars are removed, you see that theyre always parallel and that the black bars are distorting your brains perception of movement.\n(Click and hold to remove black bars)", "tags": ["opticalillusion"], "likes": 4, "viewed": 131, "published": "Public", "date": "1480664864", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define SPEED 0.3\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 r =  2.0*vec2(fragCoord.xy - 0.5*iResolution.xy)/iResolution.y;\n    float xMax = iResolution.x/iResolution.y;\n    \n    vec3 col1 = vec3(0.3137254902, 0.9568627451,1.0); // blue\n    vec3 col2 = vec3(1.00, 0.329, 0.298); // yellow\n    vec3 col3 = vec3(0.867, 0.910, 0.247); // red\n    \n    vec3 pixel = vec3(0.,0.,0.);\n    \n    \n    // set background\n    float xVal = r.x;\n    for(int i = 0; i < 20; i++)\n    {\n        if(xVal > xMax - 0.1 && xVal < xMax)\n        {\n            pixel = vec3(1.);\n        }\n        xVal += 0.2;\n    }\n    if(iMouse.z > 0.)\n    {\n        pixel = vec3(0.5);\n    }\n    \n    float lengthOfBoxes = 0.4;\n    float heightOfBoxes = 0.2;\n    float centerOfBoxes = mod(iTime*SPEED, xMax*2.0) - xMax;\n    \n    //set yellow box moving to the right\n    if(r.y > 0.2 && r.y < 0.2 + heightOfBoxes)\n    {\n        if(r.x > centerOfBoxes - lengthOfBoxes/2. && r.x < centerOfBoxes + lengthOfBoxes/2.)\n        {\n\t\t\tpixel = vec3(1.,1.,0.);\n        }\n    }\n    \n\t//set blue box moving to the right\n    if(r.y < -0.2 && r.y > -0.2 - heightOfBoxes)\n    {\n\t\tif(r.x > centerOfBoxes - lengthOfBoxes/2. && r.x < centerOfBoxes + lengthOfBoxes/2.)\n        {\n\t\t\tpixel = vec3(0.,0.,1.);\n        }\n    }\n    \n    fragColor = vec4(pixel, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/llcSRj.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[19, 19, 76, 76, 1327]], "test": "valid"}
{"id": "llcSW2", "name": "Half Area Madelbrot", "author": "max_leo", "description": "not sure just tweaked a previous code", "tags": ["fractal"], "likes": 0, "viewed": 73, "published": "Public", "date": "1481606616", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 o, vec2 p )\n{\n    p = (p+p-(o.xy=iResolution.xy))/o.y/.7;\n    vec2 z = p;\n    float a, r, d = 2.+2.*(1.-cos(iTime/5.));\n    o = vec4(0,0,0,1);\n    for( float i = 0. ; i < 100. ; i++ ) {\n        r = length(z);\n        a = d *.5* atan(z.y, z.x);\n        z = pow(r, d) * vec2(cos(a), sin(a)) + p;\n        if( r > 100.) {\n            o.r = d * i/100.;\n            break;\n        }\n    }\n    o = sqrt(o);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/llcSW2.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 38, 38, 426]], "test": "valid"}
{"id": "llcSWl", "name": "Interference", "author": "ptrgags", "description": "I made  this shader before I had a ShaderToy account. Simulation of interference patterns of two waves. Simple, but I love the look of it.", "tags": ["2d", "distancefield", "waves", "interference"], "likes": 4, "viewed": 98, "published": "Public", "date": "1482076539", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI 3.1415\n\n//Convert range [-1.0, 1.0] -> [0.0, 1.0]\nfloat normalize_trig(float trig_val) {\n    return (trig_val + 1.0) / 2.0;\n}\n\nfloat wave(float val, float freq, float pulse_speed) {\n    return cos(freq * val - pulse_speed * iTime);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float freq = PI / 24.0;\n    float pulse_speed = 4.0;\n    \n        \n\tvec2 center = iResolution.xy / 2.0;\n    float center_dist = distance(fragCoord, center);\n    float center_pulse = wave(center_dist, freq, pulse_speed);\n    \n    float mouse_dist = distance(fragCoord, iMouse.xy);\n    float mouse_pulse = wave(mouse_dist, freq, pulse_speed); \n    \n    float interference = (center_pulse + mouse_pulse) / 2.0;\n    \n    /* Uncomment to add mirrored mouse\n    vec2 mirror = vec2(iResolution.x - iMouse.x, iMouse.y);\n    float mirror_dist = distance(fragCoord, mirror);\n    float mirror_pulse = wave(mirror_dist, freq, 4.0);\n    \n    float interference = (center_pulse + mouse_pulse + mirror_pulse) / 3.0;\n\t*/\n    \n    \n    //Blue\n    vec3 color = vec3(0.212, 0.549, 0.714);\n    \n    fragColor.rgb = interference * color;\n    fragColor.a = 1.0;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/llcSWl.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[19, 61, 99, 99, 136], [138, 138, 192, 192, 244], [246, 246, 303, 303, 1149]], "test": "valid"}
{"id": "llcXDl", "name": "Repeating Columns", "author": "sea", "description": "columns", "tags": ["columns"], "likes": 1, "viewed": 110, "published": "Public", "date": "1482103999", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float box (vec3 p, vec3 o, vec3 s)\n{\n\tp = o - p;\n\tp = abs(p);\n\tvec3 b = vec3(max(p.x, s.x), max(p.y, s.x), max(p.z, s.x));\n\treturn max(p.x - s.x, max(p.y - s.y, p.z - s.z));\n}\n\nfloat arch (vec3 p)\n{\n\tfloat a = pow(p.x, 2.0) + pow(p.y, 2.0);\n\treturn p.x < 1.5 && p.x > -1.5 && abs(p.z) < 0.5 && p.y > 0.0 && p.y <= 2.0 ? 1.0 - a : 0.0;\n}\n\nvec3 rotate (vec3 p, vec3 r)\n{\n\tr = r / 180.0 * 3.1415926;\n\t\n\tmat4 pitch = mat4(\n\t\t1.0, 0.0, 0.0, 0.0,\n\t\t0.0, cos(r.x), -sin(r.x), 0.0,\n\t\t0.0, sin(r.x), cos(r.x), 0.0,\n\t\t0.0, 0.0, 0.0, 1.0\n\t);\n\t\n\tmat4 yaw = mat4(\n\t\tcos(r.y), 0.0, -sin(r.y), 0.0,\n\t\t0.0, 1.0, 0.0, 0.0,\n\t\tsin(r.y), 0.0, cos(r.y), 0.0,\n\t\t0.0, 0.0, 0.0, 1.0\n\t);\n\t\n\tmat4 roll = mat4(\n\t\tcos(r.z), -sin(r.z), 0.0, 0.0,\n\t\tsin(r.z), cos(r.z), 0.0, 0.0,\n\t\t0.0, 0.0, 1.0, 0.0,\n\t\t0.0, 0.0, 0.0, 1.0\n\t);\n\t\n\treturn (vec4(p, 1.0) * pitch * yaw * roll).xyz;\n}\n\nfloat a (vec3 p, vec3 o)\n{\n\tp = p - o;\n\tfloat a = arch(p);\n\tfloat b1 = box(p, vec3(-1.25, -2.0, 0.0), vec3(0.25, 2.0, 0.5));\n\tfloat b2 = box(p, vec3(1.25, -2.0, 0.0), vec3(0.25, 2.0, 0.5));\n\tfloat v = min(a, min(b1, b2));\n\treturn v;\n}\n\nvec3 normal (vec3 p)\n{\n    vec3 o = vec3(1.5, 2.0, 0.5);\n    return normalize(vec3(a(vec3(p.x - 0.01, p.y, p.z), o) - a(vec3(p.x + 0.01, p.y, p.z), o),\n                     a(vec3(p.x, p.y - 0.01, p.z), o) - a(vec3(p.x, p.y + 0.01, p.z), o),\n                     a(vec3(p.x, p.y, p.z - 0.01), o) - a(vec3(p.x, p.y, p.z + 0.01), o)));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tfloat time = iTime * 10.0;\n\tvec2 ws = fragCoord.xy / iResolution.xy * 2.0 - 1.0;\n\tws.x *= iResolution.x / iResolution.y;\n\t\n\tvec3 ro = vec3(0.0, 2.0, -2.0);\n\tvec3 rd = vec3(ws, 1.0);\n\t\n\tvec3 color = vec3(0.0, 0.0, 0.0);\n    vec3 light = rotate(vec3(2.0, 0.0, 0.0), vec3(0.0, time  * 10.0, 0.0));\n\t\n\tfor (float i = 0.0; i < 10.0; i += 0.01)\n\t{\n\t\tvec3 p = ro + rd * i;\n\t\t// p = rotate(p, vec3(-(i - 15.0) * 360.0 / 30.0, -(i - 15.0) * 360.0 / 30.0, 0.0));\n\t\t// p.y = -p.y;\n\t\t// p.z += time * 0.1;\n\t\tp = rotate(p, vec3(0.0, time, 0.0));\n        vec3 mp = p;\n\t\t\n\t\tp.x = mod(p.x, 3.0);\n\t\tp.z = mod(p.z, 3.0);\n\t\t\n\t\tif (a(p, vec3(1.5, 2.0, 0.5)) < 0.0)\n\t\t{\n\t\t\tcolor = vec3(dot(normalize(p - light), normal(p)) * 1.0 - distance(mp, light) * 0.1);\n\t\t\tbreak;\n\t\t}\n\t\t/*\n\t\tif (box(p, 1.0) < 1.0)\n\t\t{\n\t\t\tcolor = vec3(1.0);\n\t\t\tbreak;\n\t\t}\n\t\t*/\n\t}\n\t\n\tfragColor = vec4(color, 1.0);\n}\n\t", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/llcXDl.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 36, 36, 175], [177, 177, 198, 198, 336], [338, 338, 368, 368, 848], [850, 850, 876, 876, 1084], [1086, 1086, 1108, 1108, 1421], [1423, 1423, 1480, 1480, 2346]], "test": "valid"}
{"id": "llcXDn", "name": "View Shader Data", "author": "gPlatl", "description": "Display shader data: date, time, frameCount, runtime, fps and resolution.\nAdditional click and drag mouse button to display last and current mouse position.", "tags": ["mouse", "time", "shader", "coordinates", "date", "data", "view"], "likes": 10, "viewed": 215, "published": "Public", "date": "1481019530", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n//=================================================================\n// ViewShaderData.glsl    \n//   v1.0 2016-12-06  initial release\n//   v1.1 2017-02-19  rearranged for easier coding\n// Display shader data like date, time, frameCount, runtime, fps, \n//   resolution and mouse position.\n// Click and drag mouse button to display current mouse position.\n//=================================================================\n\n//------------------------------------------\n// GLSL Number Printing - @P_Malin\n// Creative Commons CC0 1.0 Universal (CC-0) \n// https://www.shadertoy.com/view/4sBSWW\n//------------------------------------------\n\n#define SPACE tp.x += 33.;\n\nvec2 vFontSize = vec2(8.0, 15.0);\t// multiples of 4x5 work best\n\nvec2 ppos = vec2(0);          // pixel position\nvec2 tp = vec2(0.0);          // text position\n\nconst vec3 backColor = vec3(0.15, 0.10, 0.10);\nvec3 drawColor = vec3(1.0, 1.0, 0.0);\nvec3 vColor = backColor;\n\n//----------------------------\nfloat DigitBin(const in int x)\n{\n    return x==0 ? 480599.0\n         : x==1 ? 139810.0\n         : x==2 ? 476951.0\n         : x==3 ? 476999.0\n         : x==4 ? 350020.0\n         : x==5 ? 464711.0\n         : x==6 ? 464727.0\n         : x==7 ? 476228.0\n         : x==8 ? 481111.0\n         : x==9 ? 481095.0\n         :             0.0;\n}\n//---------------------------------\nvoid WriteValue(const vec2 vPixelCoords\n               ,const float fValue\n               ,const int maxDigits\n               ,const int decimalPlaces )\n{\n  vec2 vCharCoords = (ppos.xy - vPixelCoords) / vFontSize;\n  float fDecimalPlaces = float(decimalPlaces);\n  if ((vCharCoords.y < 0.0) || (vCharCoords.y >= 1.0)) return;\n  float fLog10Value = log2(abs(fValue)) / log2(10.0);\n  float fBiggestIndex = max(floor(fLog10Value), 0.0);\n  float fDigitIndex = float(maxDigits) - floor(vCharCoords.x);\n  float fCharBin = 0.0;\n  if(fDigitIndex > (-fDecimalPlaces - 1.01)) \n  {\n    if(fDigitIndex > fBiggestIndex) \n    {\n\t  if((fValue < 0.0) && (fDigitIndex < (fBiggestIndex+1.5))) fCharBin = 1792.0;\n\t}\n    else \n    {\n      if(fDigitIndex == -1.0) \n      {\n        if(fDecimalPlaces > 0.0) fCharBin = 2.0;\n      }\n      else \n      {\n        float fReducedRangeValue = fValue;\n        if(fDigitIndex < 0.0) { fReducedRangeValue = fract( fValue ); fDigitIndex += 1.0; }\n        float fDigitValue = (abs(fReducedRangeValue / (pow(10.0, fDigitIndex))));\n        fCharBin = DigitBin(int(floor(mod(fDigitValue, 10.0))));\n      }\n    }\n  }\n  float cInt = floor(mod((fCharBin / pow(2.0, floor(fract(vCharCoords.x) * 4.0) \n                                + (floor(vCharCoords.y * 5.0) * 4.0))), 2.0));\n  vColor = mix(vColor, drawColor, cInt);\n}\n\n//=================================================================\n\nconst vec3 mpColor   = vec3(0.99, 0.99, 0.00);\nconst vec3 mxColor   = vec3(1.00, 0.00, 0.00);\nconst vec3 myColor   = vec3(0.00, 1.00, 0.00);\n      vec3 dotColor  = vec3(0.50, 0.50, 0.00);\n          \n//----------------------------------------------------------------\nvoid SetColor(float red, float green, float blue)\n{\n  drawColor = vec3(red,green,blue);    \n}\n//----------------------------------------------------------------\nvoid WriteMousePos(vec2 mPos)\n{\n  mPos = abs(mPos);\n  int digits = 3;\n  float radius = 3.0;\n\n  // print dot at mPos\n  if (iMouse.z > 0.0) dotColor = mpColor;\n  float fDistToPointB = length(mPos - ppos) - radius;\n  vColor += mix( vec3(0), dotColor, (1.0 - clamp(fDistToPointB, 0.0, 1.0)));\n\n  // print mouse.x\n  tp = mPos + vec2(-4.4 * vFontSize.x, radius + 4.0);\n  tp.x = max(tp.x, -vFontSize.x);\n  tp.x = min(tp.x, iResolution.x - 8.4*vFontSize.x);\n  tp.y = max(tp.y, 1.6 * vFontSize.y);\n  tp.y = min(tp.y, iResolution.y - 1.4*vFontSize.y);\n  drawColor = mxColor;\n  WriteValue(tp, mPos.x, digits, 0);\n\t\t\n  // print 2nd mouse value\n  SPACE\n  drawColor = myColor;\n  WriteValue(tp, mPos.y, digits, 0);\n}    \n//----------------------------------------------------------------\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  float time = iTime;\n  ppos = fragCoord;\n\n  // print mouse position & coordinates\n  WriteMousePos(iMouse.zw);  // last position\n  WriteMousePos(iMouse.xy);  // current position\n\n  // print Resolution\n  tp = iResolution.xy - vec2(111, 33);   // text position: right top\n  SetColor (0.8, 0.8, 0.8);\n  WriteValue(tp, iResolution.x, 4, 0);\n  SPACE SPACE\n  WriteValue(tp, iResolution.y, 4, 0);\n\n  // print Date\n  SetColor (0.9, 0.9, 0.4);\n  WriteValue(vec2( 0, 5), iDate.x, 4, 0);\n  WriteValue(vec2(42, 5), -(iDate.y +1.0), 2, 0);\n  WriteValue(vec2(68, 5), -iDate.z, 2, 0);\n\n  // print Time\n  SetColor (1.0, 0.0, 1.0);\n  WriteValue(vec2(96     , 5), mod(iDate.w / 3600.0, 24.0), 2, 0);\n  WriteValue(vec2(96 + 24, 5), mod(iDate.w / 60.0 ,  60.0), 2, 0);\n  WriteValue(vec2(96 + 48, 5), mod(iDate.w,          60.0), 2, 0);\n\n  // print Frame Counter\n  SetColor (0.4, 0.7, 0.4);\n  WriteValue(vec2(180, 5), float(iFrame)*1.0, 6, 0);\n\n  // print Shader Time\n  SetColor (0.0, 1.0, 1.0);\n  WriteValue(vec2(240, 5), time, 6, 2);\n\n  // print Frames Per Second - FPS  see https://www.shadertoy.com/view/lsKGWV\n  //float fps = (1.0 / iTimeDelta + 0.5);\n  float fps = iFrameRate;\n  SetColor (0.8, 0.6, 0.3);\n  WriteValue(vec2(320, 5), fps, 6, 1);\n\n  fragColor = vec4(vColor,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/llcXDn.jpg", "access": "shaders20k", "license": "cc0-1.0", "functions": [[1300, 1336, 1490, 1490, 2665], [2935, 3002, 3053, 3053, 3095], [3096, 3163, 3194, 3194, 3864]], "test": "error"}
{"id": "lldSD4", "name": "BlobImplicite", "author": "Idarn", "description": "Apprentissage de cration de forme implicite", "tags": ["3dimplicitelearning"], "likes": 0, "viewed": 112, "published": "Public", "date": "1480870370", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//Blobs\n//Eric Galin\n\nconst int Steps = 1000;\nconst float Epsilon = 0.05; //Pas de dplacement sur le rayon\n\nconst float factor = 10.0;\n\n//Distance min et max du rayon\nconst float rA=10.0; \nconst float rB=40.0; \n\n//Dfinition de diffrents vecteurs de couleur\nconst vec3 red=vec3(1.0,0.0,0.0);\nconst vec3 blue=vec3(0,0.0,1.0);\nconst vec3 green=vec3(0.0,1.0,0.0);\nconst vec3 grey = vec3(0.5,0.5,0.5);\nconst vec3 grey2 = vec3(0.2,0.2,0.2);\nconst vec3 jaune = vec3(1.0,0.9,0.3);\nconst vec3 orange = vec3(0.958,0.3,0.0);\nconst vec3 noir = vec3(0.0,0.0,0.0);\n\n\nvec3 warp(in vec3 p)\n{\n\tfloat b = 1.0;\n    vec3 pprime = p;\n    pprime.x += b;\n    pprime.y += cos(b)*b;\n    pprime.z += sin(b)*b;\n    return pprime;\n}\n\n//Transformation\nvec3 rotateX(vec3 p, float a)\n{\n  return vec3(p.x, cos(a)*p.y - sin(a)*p.z, sin(a)*p.y + cos(a)*p.z);\n}\n\nvec3 rotateY(vec3 p, float a)\n{\n  return vec3(cos(a)*p.x + sin(a)*p.z, p.y, -sin(a)*p.x + cos(a)*p.z);\n}\n\nvec3 rotateZ(vec3 p, float a)\n{\n  return vec3(cos(a)*p.x + sin(a)*p.y, -sin(a)*p.x + cos(a)*p.y, p.z);\n}\n\n\nfloat falloff( float r, float R )\n{\n  float x = clamp(r/R,0.0,1.0);\n  float y = (1.0-x*x);\n  return y*y*y;\n}\n\n//Primitive functions\n\n//Base d'un point\n//p : Point\n//c : Centre du squelette\n//e : Energy du squelette\n//R : Rayon du point (pour sphere)\nfloat point(vec3 p, vec3 c, float e,float R)\n{\n  return e*falloff(length(p-c),R);\n}\n\n//Base d'un segment\n//p : Point\n//a : Premier point du segment\n//b : Second point du segment\n//e : Energy du squelette\n//R : Distance du squelette  la forme\nfloat segment(vec3 p, vec3 a, vec3 b, float e, float R)\n{\n    vec3 dir = normalize(b-a);\n    float dist = length(a-b);\n    float n = dot(p-a,dir);\n    float d = 0.0;\n    if(n <= 0.0) {\n        d = length(p-a);\n    }\n    else {\n        if(n >= dist) {\n            d = length(p-b);\n        }\n        else {\n            d = length(p-(a+dir*n));\n        }\n    }\n    return e*falloff(d, R);   \n}\n\n//Base d'une boite\n//p : Point\n//a : Point de la boite en bas  gauche au premier plan\n//b : Point de la boite en haut  droite au second plan\nfloat boite(vec3 p, vec3 a, vec3 b, float e, float R)\n{\n\tfloat d = 0.0;\n    \n    if(p.x < a.x) \n        d += (a.x-p.x)*(a.x-p.x);\n    else if(p.x > b.x)\n        d += (b.x-p.x)*(b.x-p.x);\n\n        \n    if(p.y < a.y) \n        d += (a.y-p.y)*(a.y-p.y);\n    else if(p.y > b.y)\n        d += (b.y-p.y)*(b.y-p.y);\n\n    \n    if(p.z < a.z) \n        d += (a.z-p.z)*(a.z-p.z);\n    else if(p.z > b.z)\n        d += (b.z-p.z)*(b.z-p.z);\n\n    return e*falloff(d,R);\n}\n\n//Base d'un disque\n//p : Point\n//c : Centre du disque\n//n : Normale du plan du disque\n//r : Rayon du disque\n//e : Energie du squelette\n//E : Epaisseur du disque\nfloat disque(vec3 p, vec3 c, vec3 n, float r, float e, float E)\n{\n\tn = normalize(n);\n    vec3 pc = p-c;\n    float proj = dot(pc,n);\n    vec3 cn = c + proj*n;\n    vec3 cnp = normalize(p-cn);\n    vec3 h = c + r*cnp;\n    float projhc = dot(pc, cnp);\n    vec3 pprime = c + projhc * cnp;\n    float d = 0.0;\n    if(length(c-pprime) > r)\n    {\n    \td = length(p-h);   \n    }\n    else\n    {\n        d = length(p - pprime);\n        \n    }\n    return e*falloff(d, E);\n    \n}\n\nfloat cylindre(vec3 p, vec3 a, vec3 b, float r, float e, float R)\n{\n    vec3 dir = normalize(b-a);\n    float dist = dot(p-a, dir);\n    if(dist < 0.0)\n        return disque(p, a, dir, r, e, R);\n    else\n        if (dist > length(b-a))\n            return disque(p, b, dir, r, e, R);\n        else\n            return disque(p, a+dist*dir, dir, r, e, R);\n}\n\n//Base d'un cercle\n//p : Point\n//c : Centre du cercle\n//n : Normale du plan du cercle\n//e : Energie du squelette\n//r : Rayon du cercle\n//E : Epaisseur du cercle\nfloat cercle(vec3 p, vec3 c, vec3 n, float r, float e, float E)\n{\n\tn = normalize(n);\n    vec3 pc = p-c;\n    float proj = dot(pc,n);\n    vec3 cn = c + proj*n;\n    vec3 cnp = normalize(p-cn);\n    vec3 h = c + r*cnp;\n    return e*falloff(length(p-h), E);\n    \n}\n\n\nfloat Intersection(float a, float b, in vec3 color1, in vec3 color2, out vec3 colorOut)\n{\n    if(a < b)\n        colorOut = color1;\n    else\n        colorOut = color2;\n \treturn min(a,b);   \n}\n\n\nfloat Diff(float a,float b, in vec3 color1, in vec3 color2, out vec3 colorOut)\n{\n    colorOut = color1;\n    return a-b;\n}\n\n\nfloat Union(float a,float b, in vec3 color1, in vec3 color2, out vec3 colorOut)\n{\n    if( a > b)\n        colorOut = color1;\n    else\n        colorOut = color2;\n    return max(a,b);\n}\n\n\nfloat Blend(float a,float b, in vec3 color1, in vec3 color2, out vec3 colorOut)\n{\n    colorOut = (a*color1 + b*color2) / (a+b);\n    return a+b;\n}\n\n\nfloat Cut(float a, float b, float t, in vec3 color1, out vec3 colorOut)\n{\n    colorOut = color1;\n \treturn min(a, 2.0*t-b);   \n}\n\n\nfloat Lamp(vec3 p, out vec3 colorOut)\n{\n\t//Cration d'une premire boule\n    vec3 pointBoule1 = vec3(((1.3+cos(iTime*0.35))/2.0)*3.5-1.75, 0.2*sin(iTime), 0.2*cos(iTime));\n \tfloat boule1 = point(warp(p), pointBoule1, 1.5, 1.5);\n\t\n\t//Cration d'une seconde boule\n    vec3 pointBoule2 = vec3(((1.0+cos(iTime*0.35))/2.0)*3.5-1.75, 0.35*sin(iTime), 0.35*cos(iTime));\n \tfloat boule2 = point(warp(p), pointBoule2, 1.5, 1.5);\n\t\n\t//Cration d'une troisime boule\n    vec3 pointBoule3 = vec3(1.0+cos(iTime*3.0), (1.0+cos(iTime*3.0))*3.0-3.0, 1.0+sin(iTime*3.0));\n \tfloat boule3 = point(warp(p), pointBoule3, 1.75, 2.25);\n\t\n\t//Pour d'un segment\n\tfloat seg = segment(p, vec3(0.0,-5.5,0.0), vec3(0.0, 5.5, 0.0), 1.0, 0.5);\n\t//On blend la troisime au segment\n    float v1 = Blend(boule3, seg, red, jaune, colorOut);\n\t\n\t//Initialisation de la forme implicite\n\t//On intersect les deux premires boules\n    float v = Intersection(boule1, boule2, blue, green, colorOut);\n\t\n    //Puis on Blend v  v1\n    v = Blend(v, v1, colorOut, red, colorOut);\n    \n    vec3 colorLamp;\n\t//On initialise une quatrime sphre statique\n    float rsphere = point(p, vec3(0.0, 5.5, 0.0), 4.,4.);\n\t//Puis on vient l'extruder  partir d'un cylindre\n    rsphere = Cut(rsphere, cylindre(p, vec3(0.,0.,0.), vec3(0.0,3.5,0.), 1., 4.0, 2.0), 0.5, mix(grey, grey2, 0.5), colorLamp);\n\t//On l'ajoute  la scne\n    v = Union(v, rsphere, colorOut, orange, colorOut);\n\t\n\t//On cre ensuite un disque\n\tfloat ldisque = disque(p, vec3(0.0, -5.5, 0.0), vec3(0.0, 1.0, 0.0), 1.5, 2.5, 0.1);\n\t//On Blend le disque\n    v = Blend(v, ldisque, colorOut, grey, colorOut);\n    \n    return v;\n}\n\n//Potential field of the object\n//p : point\n//color : color of the point\nfloat object(vec3 p, out vec3 color)\n{\n\tp.z=-p.z;\n\n\tfloat v = Lamp(p, color);\n\n\treturn v-0.5;\n}\n\n//Calculate object normal\n//p : point\nvec3 ObjectNormal(in vec3 p )\n{\n  float eps = 0.0001;\n  vec3 n;\n    vec3 color;\n  float v = object(p, color);\n  n.x = object( vec3(p.x+eps, p.y, p.z) , color) - v;\n  n.y = object( vec3(p.x, p.y+eps, p.z) , color) - v;\n  n.z = object( vec3(p.x, p.y, p.z+eps) , color) - v;\n  return normalize(n);\n}\n\n//Trace ray using ray marching\n//o : ray origin\n//u : ray direction\n//h : hit\n//s : Number of steps\n//color : color of the point\nfloat Trace(vec3 o, vec3 u, out bool h,out int s, out vec3 color)\n{\n  h = false;\n\n    //Don't start at the origin, instead move a little bit forward\n    float t=rA;\n\n  for(int i=0; i<Steps; i++)\n  {\n    s=i;\n    vec3 p = o+t*u;\n    float v = object(p, color);\n    //Hit object\n      if (v > 0.0)\n      {\n          s=i;\n          h = true;\n          break;\n      }\n      //Move along ray\n      t += Epsilon;\n      //Escape marched far away\n      if (t>rB)\n      {\n          break;\n      }\n  }\n  return t;\n}\n\n//Trace ray using ray marching\n//o : ray origin\n//u : ray direction\n//h : hit\n//s : Number of steps\n//color : color of the point\nfloat SphereTrace(vec3 o, vec3 u, out bool h,out int s, out vec3 color)\n{\n  h = false;\n\n    //Don't start at the origin, instead move a little bit forward\n    float t=rA;\n  for(int i=0; i<Steps; i++)\n  {\n    s=i;\n    vec3 p = o+t*u;\n    float v = object(p, color);\n    //Hit object\n      if (v > 0.0)\n      {\n          s=i;\n          h = true;\n          break;\n      }\n      //Move along ray\n      t += max(Epsilon,abs(v)/factor);\n      //Escape marched far away\n      if (t>rB)\n      {\n          break;\n      }\n  }\n  return t;\n}\n\n\n//Background color\nvec3 background(vec3 rd)\n{\n  return mix(vec3(0.4, 0.3, 0.0), vec3(0.7, 0.8, 1.0), rd.y*0.5+0.5);\n}\n\n//Shading and lighting\n//p : point,\n//n : normal at point\n//color : color of the point\nvec3 Shade(vec3 p, vec3 n, in vec3 color)\n{\n  //point light\n  const vec3 lightPos = vec3(5.0, 5.0, 5.0);\n  const vec3 lightColor = vec3(0.5, 0.5, 0.5);\n\n  vec3 c = 0.5*color;\n  vec3 l = normalize(lightPos - p);\n\n  //Not even Phong shading, use weighted cosine instead for smooth transitions\n  float diff = 0.5*(1.0+dot(n, l));\n\n  c += diff*lightColor;\n\n  return c;\n}\n\n//Shading with number of steps\nvec3 ShadeSteps(int n)\n{\n   float t=float(n)/(float(Steps-1));\n   return vec3(t,0.25+0.75*t,0.5-0.5*t);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2 pixel = (gl_FragCoord.xy / iResolution.xy)*2.0-1.0;\n\n  //compute ray origin and direction\n  float asp = iResolution.x / iResolution.y;\n  vec3 rd = normalize(vec3(asp*pixel.x, pixel.y, -2.0));\n  vec3 ro = vec3(0.0, 0.0, 20.0);\n\n  float a=iTime;\n  //ro = rotateY(ro, 0.2);\n  //rd = rotateY(rd, 0.2);\n  //Trace ray\n  bool hit;\n\n  //Number of steps\n  int s;\n\tvec3 color;\n  float t = SphereTrace(ro, rd, hit,s, color);\n  vec3 pos=ro+t*rd;\n  //Shade background\n  vec3 rgb = background(rd);\n\n  if (hit)\n  {\n    //Compute normal\n    vec3 n = ObjectNormal(pos);\n\n    //Shade object with light\n    rgb = Shade(pos, n, color);\n  }\n\n  //Uncomment this line to shade image with false colors representing the number of steps\n\t//rgb = ShadeSteps(s);\n\n  fragColor=vec4(rgb, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/lldSD4.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[559, 559, 581, 581, 710], [712, 729, 760, 760, 832], [834, 834, 865, 865, 938], [940, 940, 971, 971, 1044], [1047, 1047, 1082, 1082, 1155], [1180, 1297, 1343, 1343, 1380], [1382, 1541, 1598, 1598, 1931], [1933, 2078, 2133, 2133, 2530], [2532, 2693, 2758, 2758, 3157], [3159, 3159, 3226, 3226, 3510], [3512, 3673, 3738, 3738, 3931], [3934, 3934, 4023, 4023, 4124], [4127, 4127, 4207, 4207, 4248], [4251, 4251, 4332, 4332, 4433], [4436, 4436, 4517, 4517, 4581], [4584, 4584, 4657, 4657, 4711], [4714, 4714, 4753, 4788, 6361], [6363, 6436, 6474, 6474, 6531], [6533, 6571, 6602, 6602, 6867], [6869, 6998, 7065, 7065, 7503], [7505, 7634, 7707, 7707, 8163], [8166, 8185, 8211, 8211, 8283], [8285, 8372, 8415, 8431, 8738], [8879, 8879, 8936, 8936, 9709]], "test": "valid"}
{"id": "lldSW2", "name": "TriangleOutCircle3D", "author": "gPlatl", "description": "This is an extented version of IQs triangle demo (see header comment).\nAdditional drawn are the outcircle center and the outcircle going to all 3 triangle vertices.\n\nBtw. any hints for shorter or faster TriangleOutCircle3d calculations are welcome!\n\n", "tags": ["3d", "triangle", "circle", "normal", "plane", "circumcircle", "circumscribe", "3point"], "likes": 4, "viewed": 180, "published": "Public", "date": "1481716893", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n//---------------------------------------------------------\n// TriangleOutCircle3D.glsl       by Gerd Platl\n//   v1.0  2016-12-15\n//   v1.1  2017-08-28\n//   v1.2  2021-01-18\n//---------------------------------------------------------\n// basic 3d scenery     https://www.shadertoy.com/view/4sXXRN\n// basic 3d primitives  https://www.shadertoy.com/view/4lSGRV     \n// Created by inigo quilez - iq/2013,2014\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n// info: http://iquilezles.org/www/articles/triangledistance/triangledistance.htm\n// tags: 3d, triangle, plane, normal, circumscribe, circle \n//---------------------------------------------------------\n\n// vector square: v^2 = v.v\nfloat sqr( in vec3 v ) { return dot(v,v); }\n\n//=== distance calculations ===\n\n//---------------------------------------------------------\n// return unsigned distance of point P to triangle A,B,C\n// http://iquilezles.org/www/articles/triangledistance/triangledistance.htm\n// https://www.shadertoy.com/view/4sXXRN\n//---------------------------------------------------------\nfloat udTriangle (in vec3 A, in vec3 B, in vec3 C, in vec3 P)\n{\n  vec3 u = B - A; vec3 pa = P - A;\n  vec3 v = C - B; vec3 pb = P - B;\n  vec3 w = A - C; vec3 pc = P - C;\n  vec3 nor = cross(u,w);\n\n  float d = sign(dot(cross(u,nor),pa))\n          + sign(dot(cross(v,nor),pb))\n          + sign(dot(cross(w,nor),pc));\n\n  if (d < 2.0)\n    return sqrt(min( min(\n                 sqr(u*clamp(dot(u,pa) / sqr(u),0.0,1.0)-pa),\n                 sqr(v*clamp(dot(v,pb) / sqr(v),0.0,1.0)-pb)),\n                 sqr(w*clamp(dot(w,pc) / sqr(w),0.0,1.0)-pc)));\n  \n  else return sqrt (dot(nor,pa)*dot(nor,pa) / sqr(nor));\n}\n//---------------------------------------------------------\n// sphere: p = position, radius = sphere radius\n//---------------------------------------------------------\nfloat sdSphere( vec3 p, float radius )\n{\n    return length(p) - radius;\n}\n//---------------------------------------------------------\n// cylinder: h.x=radius, h.y=height\n//---------------------------------------------------------\nfloat sdCylinder( vec3 p, vec2 h )\n{\n  vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n//---------------------------------------------------------\n// torus:  t.x = torus radius,  t.y = ring radius\n//---------------------------------------------------------\nfloat sdTorus( vec3 p, vec2 t )\n{\n  return length(vec2(length(p.xz)-t.x, p.y)) - t.y;\n}\n\n//=== geometric calculations ===\n\nconst float eps = 1E-6;        // sehr kleiner Wert\nconst float undefined = 0.0;   \n\n//---------------------------------------------------------\n// circumcircle of a triangle,    A,B,C = triangle vertices\n//   M,r = circle center & radius,   nn = normalized normal\n//---------------------------------------------------------\nbool TriangleOutCircle3d (in vec3 A, in vec3 B, in vec3 C,\n                         out vec3 M, out vec3 nn, out float r)\n{\n  vec3 u = B - A;           // u = A->B\n  vec3 v = C - A;           // v = A->C\n  vec3 n = cross (u,v);     // n = plane normal\n  float d = length(n);      // d = length of n\n  nn = normalize(n);        // |nn| = 1\n/*\n  if (d < eps)              // A,B,C on one line ?\n  {\n    M = A;                  // points A,B,C are \n    r = undefined;          //   on one line \n    return false;          \n  }\n*/  \n  float u2 = sqr (u);       // u2 = u^2\n  float v2 = sqr (v);       // v2 = v^2\n  float uv = dot (u,v);     // uv = u.v\n  d = 0.5 / (u2*v2-uv*uv);  // determinant\n  float k = v2*(u2-uv)*d;   \n  float l = u2*(v2-uv)*d;\n  vec3 w = k*u + l*v;       // w = A->M\n  M = A + w;\n  r = length(w);            // r = |w|\n  return true;\n}\n\n//---------------------------------------------------------\n// get matrix to rotate to plane given by 3 points\n//---------------------------------------------------------\nmat3 rotMatrix (vec3 v1, vec3 v2, vec3 v3)\n{               \n  vec3 u = normalize(v2 - v1);\n  vec3 n = normalize(cross(u, v3-v1));\n  return mat3 (u, n, cross(n,u));\n}\n                \n//=== rendering =======================================\n\nvec2 uv = vec2(0.0);\n\n// triangle vertices\nvec3 v1 = vec3(0.);     \nvec3 v2 = vec3(0.);\nvec3 v3 = vec3(0.);\n\n// circle data\nbool inCircle = true;\nbool outCircle = true;\nvec3 Mo = vec3(0.0, 0.0, 0.0);  \nvec3 nn = vec3(0.0, 1.0, 0.0);\nfloat rc = 0.05;    \n\n// rendering\nstruct aHit\n{ vec3  pos;   // position\n  float dist;  // distance to object\n  int steps;   // steps required\n  vec3 color;\n};\naHit hit;\n\n#define ANIMATE_TRIANGLE true \n\n//---------------------------------------------------------\nvoid init()\n{\n  hit = aHit(vec3(1,0,0), 99999., 0, vec3(0));\n  float time = (ANIMATE_TRIANGLE) ? 0.2 * iTime : 0.0;\n  v1 = 0.8*cos( time + vec3(0.0,1.0,1.0) + 1.0 );\n  v2 = 0.8*cos( time + vec3(0.0,2.0,3.0) + 2.0 );\n  v3 = 0.8*cos( time + vec3(0.0,3.0,5.0) + 4.0 );\n}\n//---------------------------------------------------------\nvoid hitCheck(float dist, vec3 color)\n{\n  if (dist < hit.dist)\n  {\n    hit.dist = dist;\n    hit.color = color;\n  }\n}\n//---------------------------------------------------------\nconst vec3 plane1Color    = vec3(0.50, 0.60, 0.70);\nconst vec3 plane2Color    = vec3(0.90, 0.60, 0.30);\nconst vec3 triangleColor  = vec3(0.00, 0.40, 0.80);\nconst vec3 normalColor    = vec3(0.80, 0.80, 0.0);\nconst vec3 outCircleColor = vec3(0.25, 0.80, 0.25);\nconst vec3 xAxisColor     = vec3(0.80, 0.0 , 0.0 );\nconst vec3 yAxisColor     = vec3(0.0 , 0.80, 0.0 );\nconst vec3 zAxisColor     = vec3(0.0 , 0.0 , 0.80);\n//---------------------------------------------------------\nfloat map( in vec3 p )\n{\n  // ground plane\n  float dist = p.y + 1.5;\n  hit = aHit(p, dist, 1, plane1Color);\n    \n  // triangle\n  dist = udTriangle(v1, v2, v3, p) - 0.01;\n  hitCheck(dist, triangleColor);\n    \n  // triangle center \n  vec3 center = (v1+v2+v3) / 3.;\n  dist = sdSphere(p - center, 0.04);\n  hitCheck(dist, triangleColor);\n              \n  mat3 rMatrix = rotMatrix(vec3(1,0,0),vec3(0,1,0),vec3(0,0,0));\n/*\n  // world origin\n  dist = sdSphere(p, 0.04);\n  hitCheck(dist, vec3(2.0, 0.0, 0.0));\n\n  // world axis\n  dist = sdCylinder (p, vec2(0.011, 1.6));\n  hitCheck(dist, xAxisColor);\n\n  dist = sdCylinder (p * rMatrix, vec2(0.011, 1.6));   \n  hitCheck(dist, yAxisColor);\n    \n  rMatrix = mat3 (vec3(0,1,0), vec3(1,0,0), vec3(0,0,1));\n  dist = sdCylinder (p * rMatrix, vec2(0.011, 1.6));   \n  hitCheck(dist, zAxisColor);\n*/\n  // plane normal\n  rMatrix = rotMatrix(v1,v2,v3);\n  vec3 r1 = (p - center) * rMatrix;\n  dist = sdCylinder (r1, vec2(0.01, 0.6));   \n  hitCheck(dist, normalColor);\n\n  // circumCircle\n  if (outCircle)\n  {\n    r1 = (p - Mo) * rMatrix;\n    dist = sdTorus(r1, vec2(rc,0.016));    \n    hitCheck(dist, outCircleColor);\n    \n    // draw circumCircle center  \n    dist = sdSphere(p - Mo, 0.04);\n    hitCheck(dist, outCircleColor);\n  }\n\n  return hit.dist;\n}\n//---------------------------------------------------------\n// get minimal object distance\n//---------------------------------------------------------\nfloat intersect(in vec3 ro, in vec3 rd)\n{\n  const float maxDist = 10.0;\n  float hd = 1.0;\n  float t = 0.0;\n  for (int i=0; i<64; i++)\n  {\n    hd = map (ro + rd*t);\n    if( hd < 0.001) return t;       // near object ?\n    t += hd;\n    if (t > maxDist) return -1.0;   // no intersection\n  }\n  return t;\n}\n//---------------------------------------------------------\nvec3 calcNormal( in vec3 pos )\n{\n  vec3 eps = vec3(0.002,0.0,0.0);\n  return normalize( vec3(\n           map(pos+eps.xyy) - map(pos-eps.xyy),\n           map(pos+eps.yxy) - map(pos-eps.yxy),\n           map(pos+eps.yyx) - map(pos-eps.yyx) ) );\n}\n//---------------------------------------------------------\nfloat calcSoftshadow( in vec3 ro, in vec3 rd, float k )\n{\n  float res = 1.0;\n  float t = 0.0;\n  float h = 1.0;\n  for( int i=0; i<20; i++ )\n  {\n    h = map(ro + rd*t);\n    res = min( res, k*h/t );\n    t += clamp( h, 0.01, 1.0 );\n    if( h<0.0001 ) break;\n  } \n  return clamp(res,0.0,1.0);\n}\n//---------------------------------------------------------\nfloat calcOcclusion( in vec3 pos, in vec3 nor )\n{\n    float occ = 0.0;\n    float sca = 1.0;\n    for( int i=0; i<5; i++ )\n    {\n        float hr = 0.02 + 0.025*float(i*i);\n        vec3 aopos =  nor * hr + pos;\n        float dd = map( aopos );\n        occ += -(dd-hr)*sca;\n        sca *= 0.95;\n    }\n    return 1.0 - clamp( occ, 0.0, 1.0 );\n}\n\nconst vec3 lightPos = normalize(vec3(1.0,0.9,0.7));\n\n//---------------------------------------------------------\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2 q = fragCoord.xy / iResolution.xy;\n  vec2 p = -1.0 + 2.0 * q;\n  p.x *= iResolution.x / iResolution.y;  \n  vec2 mo = iMouse.xy / iResolution.xy;\n\n  // camera\t\n  float rtime = 0.1*iTime;\n  float rAngle = 6.2*mo.x + rtime;\n  vec3 ro = vec3(2.*cos(rAngle), 0.25+mo.y, 2.*sin(rAngle) );  // ray origin\n  vec3 ta = vec3( 0.0, 0.0, 0.0 );   // target\n  vec3 cw = normalize( ta-ro );      // direction\n  vec3 cp = vec3( 0.0, 1.0, 0.0 );   // up\n  vec3 cu = normalize( cross(cw, cp) );\n  vec3 cv = normalize( cross(cu, cw) );\n  vec3 rd = normalize( p.x*cu + p.y*cv + 2.0*cw );\n\n  init();\n    \n  outCircle = TriangleOutCircle3d (v1,v2,v3,Mo,nn,rc);\n\n  float t = intersect(ro,rd);  // get distance\n  \n  vec3 col = vec3(0);\n\n  if( t > 0.0 )\n  {\n    hit.pos = ro + t*rd;\n    col = hit.color*2.0;\n    vec3 nor = calcNormal(hit.pos);\n    float sha = calcSoftshadow( hit.pos + nor*0.01, lightPos, 32.0 );\n    float occ = calcOcclusion( hit.pos, nor );\n    col *= plane1Color * clamp( dot( nor, lightPos ), 0.0, 1.0 ) * sha;\n    col += plane2Color * clamp( nor.y, 0.0, 1.0 ) * occ;\n    col += 0.03;\n    col *= exp( -0.2*t );\n    col *= 1.0 - smoothstep( 5.0, 10.0, t );\n  }\n  col = pow( clamp(col,0.0,1.0), vec3(0.45) );\n    \n  fragColor = vec4( col, 1.0 );\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/lldSW2.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[696, 724, 748, 748, 767], [802, 1096, 1159, 1159, 1701], [1702, 1870, 1910, 1910, 1943], [1944, 2100, 2136, 2136, 2235], [2236, 2406, 2439, 2439, 2493], [2614, 2854, 2977, 2977, 3709], [3711, 3882, 3926, 3926, 4047], [4559, 4619, 4632, 4632, 4886], [4887, 4947, 4986, 4986, 5063], [5539, 5599, 5623, 5641, 6877], [6878, 7029, 7070, 7070, 7331], [7332, 7392, 7424, 7424, 7634], [7635, 7695, 7752, 7752, 7984], [7985, 8045, 8094, 8094, 8385], [8440, 8500, 8557, 8557, 9807]], "test": "error"}
{"id": "lldSWX", "name": "VoidChicken Rewind 2016 Top 10", "author": "VoidChicken", "description": "Over about a year, I have made about 100 shaders on Shadertoy. Lets look at my top 10 ones this year. :D 93rd shader! (No particular order in rank)", "tags": ["2d", "3d", "chicken", "history", "movie", "rewind"], "likes": 2, "viewed": 177, "published": "Public", "date": "1481951370", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//Made by VoidChicken\n//Creative Commons 4.0 Attribution\n#define iRatio (iResolution.x/iResolution.y)\n#define ready(x, y) if (x>0.&&y<1.)\n#define MIN1(a,b) (a.x<b.x?a:b)\n#define T iTime\nconst float pi = acos(-1.);\nfloat timer(float gtime, float start, float end) {\n\treturn clamp((gtime-start)/(end-start), 0., 1.);\n}\nfloat trans1( vec2 uv, float time ) {\n\tfloat t = 0.;\n    if (uv.x+uv.y/10.<time*1.1) {\n    \tt=1.;    \n    }\n    return t;\n}\nvec3 opener( vec2 u,float t) {\n    u.x=(u.x-.5)*iRatio+.5;\n    vec3 c = vec3(.05);\n    vec2 k = u-.5;\n    if (abs(k).x<.25&&abs(k).y<.25) {\n    \tvec2 y = k/.5+.5;\n        float q = abs(y.y-.5)*2.;\n        vec3 o = c;\n        float au = mix(1.-y.x, y.x, (-cos(t*pi)*.5+.5));\n        if (q<au) {\n            float i = abs(q-au)/au;\n            \n            o=mix(o,vec3((.75+.25*sin(i+(1.-texture(iChannel3,vec2(0))).r*5.))),\n                pow(i,1./2.))\n                ;\n        }\n        \n        c=(o);\n    }\n    return c;\n}\n//SET 1\n\n\nvec3 L(vec3 d) {\n    return mix(vec3(0,.5,1), vec3(1), pow(max(dot(d, vec3(0, 1, 0)), 0.), .2));\n}\n\nvec3 shader1(  vec2 f )\n{\n\tvec2 R=iResolution.xy,u = f;\n    \n    vec3 d = vec3(u*2.-1., 1);\n   \n    vec3 po = vec3(0, 4, iTime);\n    vec3 p = po;\n    d.y*=R.y/R.x;\n     vec3 m = L(d+vec3(0, .6, 0));\n    \n    bool h = false;\n  \n    for (int i = 0; i < 96; ++i) {\n    \tfloat f = p.y+texture(iChannel0, p.xz/10.).r*2.+sin(p.x+p.z/10.)*cos(p.z-p.x/100.)-texture(iChannel0, p.xz/100.).r*2.;\n        if (length(p-po)>20.) break;\n        if (f < .2) {\n            h = true;\n           \n        }\n        p+=d*f/5.;\n    }\n    if (h)\n    \t    m = mix(\n                texture(iChannel1, p.xz).grb+(vec3(.8-length(p-po)/20.))/2.,\n                m, pow(length(p-po)/20., 25.))*(1.-texture(iChannel0, p.xz/10.).r*.7);\n    return pow(vec3(m)*(1.-length(u-.5)/1.62), vec3(1./1.5));\n}\n\n   //End1 \n//set 2 \nfloat R(float x) {return x+fract(x)<.5?0.:1.;}\nfloat cuboid ( vec3 p, vec3 b ) {\n\tfloat f = 0.;\n    vec3 a = abs(p)-b;\n    f = max(a.x, max(a.y, a.z));\n    \n    return f;\n}\n\nfloat lattice( vec3 p ) {\n\n    float f = 0.;\n    float r = .1;\n    float b = cuboid(p, vec3(1));\n   \n    f = max(abs(p.x)-r, abs(p.y)-r);\n    f = min(f, max(abs(p.x)-r, abs(p.z)-r));\n    f = min(f, max(abs(p.y)-r, abs(p.z)-r));\n  \n    return max(f, b);//+(length(p)-1.)/5.;\n    \n}\nmat3 rotationMatrix(vec3 axis, float angle)\n{\n    axis = normalize(axis);\n    float s = sin(angle);\n    float c = cos(angle);\n    float oc = 1.0 - c;\n    \n    return mat3(oc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s,  \n                oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s, \n                oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c);\n}\nfloat map ( vec3 p ) {\n\n    p=fract(p)-.5;\n\treturn lattice(p);    \n}\nvec3 calcNormal( in vec3 x )\n{\n    vec2 e = vec2( .001, 0.0 );\n    return normalize( vec3( map(x+e.xyy) - map(x-e.xyy),\n                            map(x+e.yxy) - map(x-e.yxy),\n                            map(x+e.yyx) - map(x-e.yyx) ) );\n}\nfloat trace (vec3 o, vec3 d) {\n\tfloat t = 0.;\n    for (int i = 0; i < 64; ++i) {\n        float f = map(o+t*d);\n        \n        if (t>50.||f<.002) break;\n        t+=f;\n    }\n    return t;\n}\n\nvec3 uniperp ( vec3 n ) {\n\treturn n.yzx+n;    \n}\nvec3 stx (vec2 u) {\n\treturn texture(iChannel1,u).rgb;    \n}\nvec3 render( vec2 uv ) {\n    vec3 col = vec3(0);\n\tvec3 ro = vec3 (0,0, 4.);\n    ro*=rotationMatrix(vec3(-1,0,0),iTime/5.);\n    vec3 rd = vec3 (vec2(1, iResolution.y/iResolution.x)*(uv*2.-1.), 1);\n    rd=normalize(rd);\n    rd*=rotationMatrix(vec3(0,0,1),iTime);\n    rd*=rotationMatrix(vec3(1,1,0),iTime/5.);\n    float t = trace( ro, rd );\n    vec3 i = ro+rd*t;\n    float m = map(i);\n    if (m<.2) {\n        \n         vec3 l = vec3 (0,0, 4.);\n    \tl*=rotationMatrix(vec3(-1,0,0),iTime/5.+.314);\n        \n        vec2 uv = vec2(0);\n        vec3 n = calcNormal(i);\n        \n        uv=vec2(dot(i,uniperp(n)),dot(i,cross(uniperp(n), n)));\n        float u = .3*distance(l, i);\n        u=sqrt(u);\n        u/=dot(n,normalize(l-i));\n    \tcol = (stx(uv))*(1./t)/(u);    \n    }    \n    return col;\n}\nvec3 shader2( vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy;\n\tvec3 col = vec3(0);\n\t\n    col+=render(uv);\n    return 1.-exp(-(vec3(col*(1.-length(uv-.5)))*sin(clamp(iTime-.25, 0., pi/2.)))*.6);\n}\n//end 2\n//set 3\n\n#define mul 2.0\nvec2 offset(vec2 uv) {\n\treturn (vec2(.5)-texture(iChannel0, uv+vec2(iTime/10.0)).xy)*mul;   \n}\nvec2 offseta(vec2 uv) {\n\treturn (vec2(.5, .5)-texture(iChannel0, uv+vec2(-iTime/10.0)).xy)*mul;\n}   \nvec3 shader3(  vec2 fragCoord )\n{\n\tvec2 uv = fragCoord;\n\treturn texture(iChannel0,uv+offset(uv)/100.0+offseta(uv)/100.0).rgb*vec3(0, 0.5,0.5);\n}\n//end 3\n//set 4\n\nvec3 mod289(vec3 x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 mod289(vec4 x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 permute(vec4 x) {\n     return mod289(((x*34.0)+1.0)*x);\n}\n\nvec4 taylorInvSqrt(vec4 r)\n{\n  return 1.79284291400159 - 0.85373472095314 * r;\n}\n\nfloat snoise(vec3 v)\n  { \n  const vec2  C = vec2(1.0/6.0, 1.0/3.0) ;\n  const vec4  D = vec4(0.0, 0.5, 1.0, 2.0);\n\n// First corner\n  vec3 i  = floor(v + dot(v, C.yyy) );\n  vec3 x0 =   v - i + dot(i, C.xxx) ;\n\n// Other corners\n  vec3 g = step(x0.yzx, x0.xyz);\n  vec3 l = 1.0 - g;\n  vec3 i1 = min( g.xyz, l.zxy );\n  vec3 i2 = max( g.xyz, l.zxy );\n\n  //   x0 = x0 - 0.0 + 0.0 * C.xxx;\n  //   x1 = x0 - i1  + 1.0 * C.xxx;\n  //   x2 = x0 - i2  + 2.0 * C.xxx;\n  //   x3 = x0 - 1.0 + 3.0 * C.xxx;\n  vec3 x1 = x0 - i1 + C.xxx;\n  vec3 x2 = x0 - i2 + C.yyy; // 2.0*C.x = 1/3 = C.y\n  vec3 x3 = x0 - D.yyy;      // -1.0+3.0*C.x = -0.5 = -D.y\n\n// Permutations\n  i = mod289(i); \n  vec4 p = permute( permute( permute( \n             i.z + vec4(0.0, i1.z, i2.z, 1.0 ))\n           + i.y + vec4(0.0, i1.y, i2.y, 1.0 )) \n           + i.x + vec4(0.0, i1.x, i2.x, 1.0 ));\n\n// Gradients: 7x7 points over a square, mapped onto an octahedron.\n// The ring size 17*17 = 289 is close to a multiple of 49 (49*6 = 294)\n  float n_ = 0.142857142857; // 1.0/7.0\n  vec3  ns = n_ * D.wyz - D.xzx;\n\n  vec4 j = p - 49.0 * floor(p * ns.z * ns.z);  //  mod(p,7*7)\n\n  vec4 x_ = floor(j * ns.z);\n  vec4 y_ = floor(j - 7.0 * x_ );    // mod(j,N)\n\n  vec4 x = x_ *ns.x + ns.yyyy;\n  vec4 y = y_ *ns.x + ns.yyyy;\n  vec4 h = 1.0 - abs(x) - abs(y);\n\n  vec4 b0 = vec4( x.xy, y.xy );\n  vec4 b1 = vec4( x.zw, y.zw );\n\n  //vec4 s0 = vec4(lessThan(b0,0.0))*2.0 - 1.0;\n  //vec4 s1 = vec4(lessThan(b1,0.0))*2.0 - 1.0;\n  vec4 s0 = floor(b0)*2.0 + 1.0;\n  vec4 s1 = floor(b1)*2.0 + 1.0;\n  vec4 sh = -step(h, vec4(0.0));\n\n  vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy ;\n  vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww ;\n\n  vec3 p0 = vec3(a0.xy,h.x);\n  vec3 p1 = vec3(a0.zw,h.y);\n  vec3 p2 = vec3(a1.xy,h.z);\n  vec3 p3 = vec3(a1.zw,h.w);\n\n//Normalise gradients\n  vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));\n  p0 *= norm.x;\n  p1 *= norm.y;\n  p2 *= norm.z;\n  p3 *= norm.w;\n\n// Mix final noise value\n  vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n  m = m * m;\n  return 42.0 * dot( m*m, vec4( dot(p0,x0), dot(p1,x1), \n                                dot(p2,x2), dot(p3,x3) ) );\n  }\nfloat MUL = 10.;\nvec2 FLOW = vec2(1);\nfloat h (vec3 v) {\n    return snoise(vec3(v.x*MUL-T*FLOW.x,T,v.z*MUL-T*FLOW.y));\n}\nfloat function(vec3 v) {\n    return v.y-h(v);\n}\nvec3 calcNormal( in vec3 x, in float eps )\n{\n    vec2 e = vec2( eps, 0.0 );\n    return normalize( vec3( function(x+e.xyy) - function(x-e.xyy),\n                            function(x+e.yxy) - function(x-e.yxy),\n                            function(x+e.yyx) - function(x-e.yyx) ) );\n}\nvec3 shader4(  in vec2 fragCoord )\n{\n   \tvec2 mm = iMouse.xy;\n    if (mm==vec2(0)) mm=iResolution.xy/2.;\n\tvec2 uv = fragCoord.xy;\n    //FLOW = normalize(vec2(iMouse.xy/iResolution.xy*2.-1.));\n    vec3  v = calcNormal(vec3(uv.x,1,uv.y),.01);\n    vec3 p = vec3(mm.x/iResolution.x*2.-1.,2,mm.y/iResolution.y*2.-1.);\n    vec3 d = vec3(uv.x*2.-1., 0, uv.y*2.-1.);\n\treturn vec3( texture(iChannel1,uv+(v.xz/15.*.25))*clamp(max(dot(v,p-d),0.)+.6,0.,1.)*clamp(3.-distance(d,p)+.6,0.,1.) );\n}\n\n//end 4\n//set 5\nvec4 hash4( vec2 p ) { return fract(sin(vec4( 1.0+dot(p,vec2(37.0,17.0)), \n                                              2.0+dot(p,vec2(11.0,47.0)),\n                                              3.0+dot(p,vec2(41.0,29.0)),\n                                              4.0+dot(p,vec2(23.0,31.0))))*103.0); }\nmat3 rotate(vec3 axis, float angle)\n{\n    axis = normalize(axis);\n    float s = sin(angle);\n    float c = cos(angle);\n    float oc = 1.0 - c;\n    \n    return mat3(oc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s,  \n                oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s,  \n                oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c         \n              );\n}\nvec3 tnt( sampler2D samp, in vec2 uv, float v )\n{\n    vec2 p = floor( uv );\n    vec2 f = fract( uv );\n    vec2 ddx = dFdx( uv );\n    vec2 ddy = dFdy( uv );\n    \n\tvec3 va = vec3(0.0);\n\tfloat wt = 0.0;\n    for( int j=-1; j<=1; j++ )\n    for( int i=-1; i<=1; i++ )\n    {\n        vec2 g = vec2( float(i),float(j) );\n\t\tvec4 o = hash4( p + g );\n\t\tvec2 r = g - f + o.xy;\n\t\tfloat d = dot(r,r);\n        float w = exp(-5.0*d );\n        vec3 c = textureGrad( samp, uv + v*o.zw, ddx, ddy ).xyz;\n\t\tva += w*c;\n\t\twt += w;\n    }\n\t\n    return va/wt;\n}\n\n\n\nfloat height( vec3 q ) {\n\tfloat f;\n    f  = 0.50000*snoise( q ); \n    f += 0.25000*snoise( q ); \n    f += 0.12500*snoise( q ); \n    f += 0.06250*snoise( q ); \n    f += 0.03125*snoise( q ); \n    return f;\n}\nfloat map2( vec3 r ) {\n\treturn \n         (r.y-height(vec3(r.xz/10.,0))*2.)+snoise(r/((tnt(iChannel2, r.xz/10., r.x+r.z).r+1.)/3.))/5./3.;\t\n}\nfloat cld( vec3 r ) {\n\treturn r.y-(height(vec3(r.xz/5.+iDate.w*vec2(0, 2),0))*4.+3.)+snoise(r)*2.+snoise(r*2.55);\t\n}\nconst float pr = .02;\nvec4 march(vec3 ro, vec3 rd) {\n    vec3 r = ro;\n    bool hit = false;\n    float t = 0.;\n    float q = 0.;\n   \tfloat tf = 0.;\n    int j = 0;\n    vec3 cdl = vec3(0);\n    bool cht = false;\n    for ( int i = 0; i < 90; ++i ) {\n        float df = map2(r);\n        t= ((r-ro)/rd).r;\n        if (df < pr*10.) {\n        \tq += df;\n        }\n        if ((df < pr&&df>-.5)||t>50.) {\n            if (df < pr) {\n                \n            hit = true;\n            }\n            break;\n        }\n        if (df<-.5) {\n\t\t\tdf = -df/2.;\n        }\n        float cl = cld(r);\n        tf += cl;    \n        if (cl < pr) {\n            j++;\n            vec3 a = tnt(iChannel2, (r.zy+r.xz+r.xy+vec2(iTime*0.)+float(j))/10., 1.).rrr*smoothstep(6., 0., clamp(tf, 0., 6.)/6.);\n        \tcdl += a*sqrt(float(j))*1.5*pow(smoothstep(0., 1., clamp(float(j)/15., 0., 1.)), 1./2.5);\n            cht = true;\n        }\n        r+=rd*df;\n    }\n    vec3 O = vec3(1.2, 1.1, 1);\n    vec3 COL = O;\n    \n    if (hit) {\n   \t\tvec3 sand = .5*(tnt(iChannel1, r.xz+snoise(r)/2., 1.)+tnt(iChannel2, r.xz/4., 2.).rrr*vec3(1.2, 1.1, 0)/2.)*vec3(1.1, 1.2, 1);\n        COL = sand*.8/(1.-height(vec3(r.xz/10.,0))*.6);\n        \n    }\n    COL += max(vec3(0.),cdl/float(j)*.2)*clamp((t-tf), 0., 1.);\n    float fog = clamp((50.-t)/(50.-30.), 0., 1.);\n    return vec4(mix(COL,O, 1.-fog), clamp(q/4., 0., 1.));\n}\n\nvec3 shader5(  in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord;\n    uv = uv*2.-1.;\n    uv.y*=iResolution.y/iResolution.x;\n\treturn march(vec3(0, mix(height(vec3(vec2(0, iTime*7.)/10.,0)*2.)+3.4, 7., iMouse.w>0.?iMouse.y/iResolution.y:.5*(sin(iTime/10.)+1.)), iTime*9.), vec3(uv, 1)*rotate(vec3(1,0,0),cos(iTime*1.*texture(iChannel3, vec2(iTime/30.)/10., 10.).r/10.)*.05-.05)*rotate(vec3(0,1,0),.6*sin(iTime/5.+texture(iChannel3, vec2(iTime)/50.).r/10.)*3.14/2.)).xyz;\n}\n//end 5\n//set 6\n#define R(x) (fract(x)<.6?floor(x):ceil(x))\nfloat M ( vec3 x ) {\n    return length(x)-2.;\n}\nfloat N(vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n\tf = f*f*(3.-2.*f);\n\t\n\tvec2 u = (p.xy+vec2(37.0,17.0)*p.z) + f.xy;\n\tvec2 g = texture( iChannel2, (u+.5)/256., -100. ).yx;\n\treturn mix( g.x, g.y, f.z );\n}\nfloat p=atan(1.)*4.;\nvec3 shader6(  vec2 f )\n{\n    float tt = iTime-99.;\n    tt*=15./20.;\n\tvec2 R=iResolution.xy,k=f;\n    float j = sin(min(.5,tt/24.)*p);\n    vec3 c,o=vec3(mix(2.8, 0., j), 0, -5.*j),d=normalize(vec3(vec2(1,R.y/R.x)*(k*2.-1.+(k-.5)/40.),1)),i;\n \n    float t = 0.;\n    for (int i = 0; i < 64; ++i)\n        t+=M(o+d*t);\n    i=o+d*t;\n    if (M(i)<.2){\n        vec3 g=vec3(.96,.66,.29),z=vec3(0,.35, .035),n = normalize(i);\n    \tfloat t,q,l=.5+max(0., dot(n, vec3(1,1,-3))), o=min(1.,tt/8.);\n        \n        t=N(i+o);\n        t=max(t,0.);\n       \tq=N(i*200.+o)+.2;\n        q=(max(.9,q)-.9)/.2;\n        c=R(t)*g*q*.7+.3*mix(z,vec3(0,.2,1),1.-t);\n    }\n\treturn c.xyz*min(tt*.25, 1.)*max(min(15.-tt,1.),0.)*(1.62-length(k-.5));\n}\n//end 6\n//set 7\nvec3 flag ( vec2 u ) {\n    vec3 c = vec3(1);\n    if (fract(u.y*13.5)>.5) {\n    \tc = vec3(1,0,0);    \n    }\n    if ((u.x<.3&&u.x<.31)&&u.y>.7) {\n       \n    \tc = vec3(0, 0, 1);    \n    }\n\treturn c;    \n}\nvec3 shader7(  in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy;\n    uv-=.5;\n    uv*=2.;\n    uv+=.5;\n    uv+=texture(iChannel2, vec2(1)*iTime/100./4.).rg/45.;\n    vec3 col = vec3(0.1, .4, 1.);\n    if (uv.y<cos(uv.x*3.)/3.) col = vec3(0,.3,0);\n    \n    {\n        vec2 u = uv+vec2(0, sin(iTime*5.-uv.x*20.)/20.*(uv.x-.2));\n        if (u.x>.2&&u.x<.5) {\n            if (u.y<.8&&u.y>.5) {\n                col = flag(u)*(1.8-max(.9, sin(iTime*5.-uv.x*20.)/4.+.8));\n            }    \n        }\n       \tif (abs(u.x-.2)<.002&&uv.y<.8)\n          \tcol = vec3(min(.7/(abs(u.x-.2)*700.), .8));\n    }\n    \n    if (uv.y<cos(uv.x*10.)/10.) col = vec3(0,.6,0);\n    if (uv.y<sin(uv.x*5.)/10.) col = vec3(0,1,0);\n    \n    col*=1.-length(uv-.5);\n    if (length(uv-.9)<.1) col = vec3(1,1,0)/(length(uv-.9)*13.);\n    \n\treturn col;\n}\n//end 7\n//set 8\n\nvec3 hsv2rgb(vec3 c)\n{\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\nvec3 shader8(  in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord;\n    uv-=.5;\n    uv.x*=iResolution.x/iResolution.y;\n    uv+=.5;\n    vec3 col = vec3(0);\n    float v = 0.;\n    \n    float u = texture(iChannel3, vec2(.25*uv.x+uv.y*.17, 1.)+iTime).r;\n    u+=texture(iChannel0, vec2(.17*uv.x+uv.y*.25, 1.)).r;\n    u/=2.;\n    v+=tan(u)/pow(u, 1.5);\n    v*=min(1., sin(min(iTime,4.)/4.*3.14159/2.));\n    col = hsv2rgb(fract(vec3(uv.x/5.-1.6, uv.y ,sin(iTime*2.-2.*u)/4.+.7)))*(1.-length(uv-.5));\n    if (abs(length(uv-.5)-(.1+v/10.))<.002) {\n\t\tcol = vec3(fract(u+uv.x*uv.y+.1*iTime), 1, 1);    \t    \n    }\n    \n\treturn hsv2rgb(col)/(abs(length(uv-.5)-(.1+v/10.))*1000.);\n}\n\n//end 8\n//set 9\n\nvec3 tex( vec2 u ) {\n    float k = 0.;\n    k=(sign(sin(u.x*3.14))+sign(sin(u.y*3.14)));\n    float jt =  ((sin(u.x*3.14))+(sin(u.y*3.14)));\n    vec3 i = vec3(.2,.1,0)*pow(abs(1.-clamp(jt, 0., 1.)), 10.);\n    i+=abs(jt)/2.;\n    return i;\n}\nfloat pRTd( vec3 o, vec3 d ) {\n    if (d.y>=0.) return 10.; \n    return ((o.y-2.)/(-d.y));\n}\nfloat smin( float a, float b )\n{\n    float k = 2.;\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\nfloat map ( vec3 o, vec3 d ) {\n    vec2 sph = (mod(o.xz, 10.)-5.);\n\treturn smin(pRTd(o, d), length(vec3(sph.x, o.y, sph.y))-(4.));    \n}\nfloat trace1( vec3 o, vec3 d ) {\n\tfloat t = 0.;\n    for (int i = 0; i < 64; ++i) {\n        float f = map(o+d*t, d);\n        if (t>30.||f<.02) break;\n        t+=f*.7;\n    }\n    return t;\n}\nvoid render ( vec2 u, out vec4 c ) {\n    vec3 col = vec3(1);\n    vec3 o = vec3 (0, 6, iTime*3.),\n        d = normalize(vec3(vec2(iResolution.x/iResolution.y, 1)*(u*2.-1.), 1));\n\t\n    float t = 0.;\n    float hit = 0.;\n    t=trace1(o, d);\n    \n    vec3 r = o+t*d;\n    hit=-(map(r, d)-.2);\n    \n    if (hit>=0.) {\n   \t\t col=mix(col, tex(r.xz).rgb, (1.-t/30.));   \n    }\n    col=col*col;\n    col+=texture(iChannel0, u.xy+1000.*(iTime)).r/20.;\n\tcol*=min(1.,iTime*.25);\n    c=1.-exp(-col.xyzx*(1.-pow(length(u-.5), 2.))*2.13);\n}\nvec3 shader9( in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord;\n    vec4 c = vec4(0);\n    render ( uv,c);\n    return c.rgb;\n}\n\n//end 9\n//set 10 \n\nfloat FOV = 60.; //60 degrees FOV\nvec2 project( vec3 p ) {\n    float RAD = FOV/360.*pi;\n    float DVN = p.z;\n    return p.xy/DVN+.5;\n}\nfloat line ( vec2 p, vec2 a, vec2 b, float r ) {\n\n    vec2 pa = p - a, ba = b - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    vec2 ac = abs( pa - ba*h );\n    return ac.x+ac.y - r;\n    \n}\nfloat lp(vec2 p, vec2 a, vec2 b) {\n\tfloat xP = (p.x-min(a.x,b.x));\n    float xFP = xP/abs(a.x-b.x);\n    float yP = (p.y-min(a.y,b.y));\n    float yFP = yP/abs(a.y-b.y);\n    return xFP>yFP?xP:yP;\n}\nmat3 rmx(vec3 axis, float angle)\n{\n    axis = normalize(axis);\n    float s = sin(angle);\n    float c = cos(angle);\n    float oc = 1.0 - c;\n    \n    return mat3(oc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s, \n                oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s,  \n                oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c\n              );\n}\nvec3 poly[4];\nvec2 proj[4];\nvec3 shader10( in vec2 fragCoord )\n{\n    poly[0]=vec3(-1, -1, 0);\n    poly[1]=vec3(1, -1, 0);\n    poly[2]=vec3(1, 1, 0);\n    poly[3]=vec3(-1,1,0);\n\tvec2 uv = fragCoord.xy;\n    float df = 5000000.;\n    for (int i = 0; i < 4; i++) {\n    \tproj[i]=project(poly[i]*rmx(vec3(cos(iTime),1,sin(iTime)), iTime)+vec3(0,0,3));    \n    }\n    float lv = 0.;\n    for (int i = 0; i < 4; i++) {\n        vec2 nv =  proj[i+1];\n        if (i+1>3){\n        \tnv=proj[0];    \n        }\n    \tdf=min(df,line(uv, proj[i],nv, .002)); \n\t\tlv=lp(uv,proj[i],nv);\n    }\n\n    vec3 c = vec3(0);\n    if (df<.02) {\n     \tvec3 ct = texture(iChannel0, vec2(lv)).rgb;\n        c=pow(1.-df/.02,5.)*ct;\n    }\n\treturn c;\n}\n\n//end 10\nfloat tval( float i ) {\n\treturn timer(iTime, i*20.-1.,i*20.);    \n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    vec3 c = vec3(0);\n  \n    float t1 = timer(iTime, 0., 1.);\n    float t2 = timer(iTime, 4., 5.);\n    float t3 = trans1(uv, tval( 1. ) );\n    float t4 = trans1(uv, tval( 2. ) );\n    float t5 = trans1(uv, tval( 3. ) );\n    float t6 = trans1(uv, tval( 4. ) );\n    float t7 = trans1(uv, tval( 5. ) );\n    float t8 = trans1(uv, tval( 6. ) );\n    float t9 = trans1(uv, tval( 7. ) );\n    float t10= trans1(uv, tval( 8. ) );\n    float t11= trans1(uv, tval( 9. ) );\n    vec3 s1 = vec3(0);\n    ready(t1, t2) s1=opener(uv,timer(iTime, 1.,4.));\n    \n    vec3 s2 = vec3(0);\n    ready(t2, t3) s2=shader1(uv);\n    \n    vec3 s3 = vec3(0);\n    ready(t3, t4) s3=shader2(uv);\n    \n    vec3 s4 = vec3(0);\n    ready(t4, t5) s4=shader3(uv);\n    \n    vec3 s5 = vec3(0);\n    ready(t5, t6) s5=shader4(uv);\n    \n   \tvec3 s6 = vec3(0);\n    ready(t6, t7) s6=shader5(uv);\n   \t\n    vec3 s7 = vec3(0);\n    ready(t7, t8) s7=shader6(uv);\n    \n    vec3 s8 = vec3(0);\n    ready(t8, t9) s8=shader7(uv);\n    \n    vec3 s9 = vec3(0);\n    ready(t9, 0.) s9=shader8(uv);\n    \n    vec3 s10 = vec3(0);\n    ready(t10, t11) s10=shader9(uv);\n    \n    vec3 s11 = vec3(0);\n    ready(t11, 0.) s11=shader10(uv);\n   \n    c=mix(vec3(0), s1, t1);\n    c=mix(c, s2, t2);\n    c=mix(c, s3, t3);\n    c=mix(c, s4, t4);\n    c=mix(c, s5, t5);\n    c=mix(c, s6, t6);\n    c=mix(c, s7, t7);\n    c=mix(c, s8, t8);\n    c=mix(c, s9, t9);\n    c=mix(c,s10,t10);\n    c=mix(c,s11,t11);\n    c=mix(c,vec3(0.),tval(10.));\n    \n    c-=max(0., pow(abs(uv.y-.5),5.))*3.;\n    float hot = timer(iTime,0., 200.);\n \n    vec2 q = vec2(hot,.095);\n    float cld= length(q*vec2(iResolution.x/iResolution.y,1)-vec2(uv.x*iResolution.x/iResolution.y,uv.y));\n    \n   \n    \n    if (uv.y<.1) {\n    \tc=mix(vec3(25./256.),c,.2);    \n        vec2 v = uv/.1;\n        if (uv.y >.09) {\n            vec3 a = c+.1;\n            if (uv.x<hot) {\n                a=vec3(1, 0,0)*clamp(cld*60.,.3,1.);\n            }\n        \tc=a;    \n        }else\n        if (v.x>.1&&v.x<.4&&v.y<.8&&v.y>.1&&abs(.1+.3/2.-v.x)>.05) {\n         \tc=vec3(1);   \n        }\n    }\n      if (cld<.009) {\n        \tc=vec3(1);\n          \n      \t\tif (cld<.006) {\n        \t\tc=vec3(1,0,0)*(1.-clamp(cld*100.,.3,1.));    \n        \t}\n        }\n    \n    float qm = 0.;\n    if (hot == 1.) {\n    \tqm = iTime/200.-1.;\n        qm *= 200.;\n    }\n\tfragColor = vec4(c,1)*(1.-clamp(qm,0.,1.));\n}", "image_inputs": [{"id": "XsfGRn", "previewfilepath": "/media/ap/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg", "ctype": "texture"}, {"id": "Xsf3zn", "previewfilepath": "/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture"}, {"id": "4sf3Rr", "previewfilepath": "/media/ap/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png", "ctype": "texture"}, {"id": "4sBGWw", "previewfilepath": "https://soundcloud.com/ma77/nightshade-4th-edit", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "https://soundcloud.com/ma77/nightshade-4th-edit", "ctype": "musicstream"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/lldSWX.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[214, 214, 264, 264, 316], [317, 317, 354, 354, 440], [441, 441, 471, 471, 968], [979, 979, 995, 995, 1077], [1079, 1079, 1104, 1104, 1849], [1854, 1871, 1889, 1889, 1917], [1918, 1918, 1951, 1951, 2043], [2045, 2045, 2070, 2070, 2325], [2326, 2326, 2371, 2371, 2846], [2847, 2847, 2869, 2869, 2915], [2916, 2916, 2946, 2946, 3155], [3156, 3156, 3186, 3186, 3345], [3347, 3347, 3372, 3372, 3395], [3396, 3396, 3415, 3415, 3455], [3456, 3456, 3480, 3480, 4244], [4245, 4245, 4277, 4277, 4436], [4470, 4470, 4492, 4492, 4564], [4565, 4565, 4588, 4588, 4662], [4666, 4666, 4699, 4699, 4810], [4828, 4828, 4849, 4849, 4898], [4900, 4900, 4921, 4921, 4970], [4972, 4972, 4994, 4994, 5034], [5036, 5036, 5064, 5064, 5116], [5118, 5118, 5142, 5142, 7288], [7327, 7327, 7345, 7345, 7409], [7410, 7410, 7434, 7434, 7457], [7458, 7458, 7502, 7502, 7740], [7741, 7741, 7777, 7777, 8223], [8225, 8241, 8263, 8263, 8548], [8549, 8549, 8586, 8586, 9086], [9087, 9087, 9136, 9136, 9621], [9625, 9625, 9649, 9649, 9830], [9831, 9831, 9853, 9853, 9971], [9972, 9972, 9993, 9993, 10088], [10111, 10111, 10141, 10141, 11466], [11468, 11468, 11504, 11504, 11931], [11992, 11992, 12012, 12012, 12039], [12040, 12040, 12058, 12058, 12258], [12280, 12280, 12305, 12305, 12999], [13000, 13016, 13038, 13038, 13218], [13219, 13219, 13255, 13255, 14027], [14045, 14045, 14067, 14067, 14236], [14237, 14237, 14273, 14273, 14895], [14914, 14914, 14934, 14934, 15151], [15152, 15152, 15182, 15182, 15244], [15245, 15245, 15277, 15277, 15388], [15389, 15389, 15419, 15419, 15525], [15526, 15526, 15558, 15558, 15713], [15714, 15714, 15750, 15750, 16236], [16237, 16237, 16272, 16272, 16356], [16394, 16411, 16435, 16435, 16511], [16512, 16512, 16560, 16560, 16715], [16716, 16716, 16750, 16750, 16911], [16912, 16912, 16946, 16946, 17436], [17465, 17465, 17501, 17501, 18145], [18147, 18156, 18179, 18179, 18223]], "test": "error"}
{"id": "lldXDS", "name": "Fail That Sun .exe ", "author": "TromasWideos", "description": "J'ai tout rat", "tags": ["fail"], "likes": 0, "viewed": 68, "published": "Public", "date": "1481534786", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 color, in vec2 pixCoords )\n{\n\tcolor = vec4(1.0, 1.0, 1.0, 1.0);\n    float distance = sqrt(pow(pixCoords.x - iResolution.x, 2.0) + cos(2.0 * 3.14 / 180.0 * pixCoords.x * iTime) + pow(pixCoords.y - iResolution.y / 2.0, 2.0) + sin(2.0 * 3.14 / 180.0 * pixCoords.y * iTime));\n        \n    if (pixCoords.y <  6.0 * cos(2.0 * 3.14 / 180.0 * pixCoords.x + 3.0*iTime) + iResolution.y / 3.0){\n        color = vec4(0.0, 0.0, 1.0, 1.0);\n    }\n    if (distance < pixCoords.y / 4.0){\n        if (distance < pixCoords.x / 2.0){\n        \t\tcolor = vec4(0.0, 0.0, 0.0, 1.0);\n        }\n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/lldXDS.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 53, 53, 600]], "test": "valid"}
{"id": "lldXRl", "name": "Sunset on Sea", "author": "azsteak", "description": "a small animation !", "tags": ["2d", "training"], "likes": 0, "viewed": 125, "published": "Public", "date": "1481285398", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Sun movement\nfloat mvtStart = 3.0;\nfloat mvtRadius;\nfloat speed = 30.0;\nvec2 offset;\n\n// Water\nfloat waterHeight = 0.2; // 0 to 1\nfloat waveMax = 0.5; \nfloat waveLength = 1.0;\nfloat waveSpeed = 0.02;\nfloat waveTransSpeed = 20.0;\n\nfloat waterLimit;\nfloat waveHeight;\n\n// Water color\nfloat degradeForce = 1.0;\nfloat degradeLength = 1.0;\n\n//tint\nfloat coefNuit;\n\n\nfloat rand( float n )\n{\n    return fract(sin(n)*43758.5453123);\n}float randFromVec2(vec2 v){\n    return rand(v.x*rand(v.y)*rand(v.y*v.x));\n}\n\nvoid drawSun(out vec4 color, vec2 pixCoords, vec2 point, float luminosity,float radius){\n    \n    float d = sqrt(pow(pixCoords.x-point.x,2.0)+pow(pixCoords.y-point.y,2.0))/radius*1000.0;\n    float coef = (1.0-d/iResolution.x)*luminosity;\n    \n    \n    coefNuit=max(0.0,min(1.0,point.y/offset.y));\n    \n    float red=max(0.4,coef) * pow(coefNuit,1.0);\n    float green=max(0.4,coef) * pow(coefNuit,4.0);\n    float blue=(1.0-coef) * pow(coefNuit,4.0);\n    \n    color = vec4(red,green,blue,1.0*waterHeight);\n}\nvoid drawStars(out vec4 color, vec2 pixCoords){\n    float randomCycle = randFromVec2(pixCoords);\n    float starBrightness = (cos(3.14*iTime*0.01+2.0*3.1415*randomCycle)*0.5+0.5)*(1.0-coefNuit);\n    color += vec4(starBrightness,starBrightness,starBrightness,1.0);\n}\nvoid drawWater(out vec4 color, in vec2 pixCoords,float horizonHeight){\n    float heightDegrade = -pixCoords.y*(pixCoords.y/horizonHeight)/(iResolution.y*(1.0-waterHeight))*coefNuit*2.0;\n    \n    float coefWaterColor = max(coefNuit*degradeLength,0.1)+heightDegrade*degradeForce;\n    \n    color = vec4(0.2*coefWaterColor,0.2*coefWaterColor,1.0*coefWaterColor,1);\n}\nbool isWater(vec2 pixCoords){\n    waveHeight = cos(3.14*float(iFrame)*waveSpeed);\n    float sinusoide = 1.0;\n    for(float i = 1.0 ; i < 5.0 ; i++){\n        sinusoide  += cos(2.0*3.14*pixCoords.x*waveLength*rand(i)*0.01 + (iTime+i)*waveTransSpeed);\n    }for(float i = 1.0 ; i < 5.0 ; i++){\n        sinusoide  += cos(3.14*pixCoords.x*waveLength*rand(i)*0.01 - (iTime+i)*waveTransSpeed);\n    }\n    \n    waterLimit = iResolution.y*waterHeight + waveHeight*sinusoide*waveMax;\n    \n    return pixCoords.y< waterLimit;\n}\nbool isStar(in vec2 realCoords, float proba){\n      \n    bool a = randFromVec2(realCoords)>proba;\n    vec2 mCoords = realCoords; \n    mCoords.x += 1.0;\n    \n    bool b = randFromVec2(mCoords)>proba;\n    mCoords = realCoords; \n    mCoords.x -= 1.0;\n    bool c = randFromVec2(mCoords)>proba;\n    \n    mCoords = realCoords; \n    mCoords.y += 1.0;\n    bool d = randFromVec2(mCoords)>proba;\n    mCoords = realCoords; \n    mCoords.y -= 1.0;\n    bool e = randFromVec2(mCoords)>proba;\n    \n    return a || b || c || d || e;\n}\nvoid mainImage( out vec4 color, in vec2 pixCoords )\n{   \n    offset = vec2(iResolution.x/2.0,iResolution.y*waterHeight);\n\tmvtRadius = iResolution.x / 3.0;\n    float y = sin(3.14*iTime/1000.0*speed+mvtStart)*mvtRadius+offset.y;\n    coefNuit=max(0.0,min(1.0,y/offset.y));\n    \n    if(isWater(pixCoords)){\n        drawWater(color,pixCoords,waterLimit);\n    }else{\n        float x = cos(3.14*iTime/1000.0*speed+mvtStart+3.14)*mvtRadius+offset.x;\n        \n    \tvec2 center = vec2(x,y);\n        drawSun(color,pixCoords,center,2.0,100.0);\n        \n        \n        vec2 starCoords;\n        starCoords.x = pixCoords.x - float(iFrame);\n        starCoords.y = pixCoords.y;\n        \n        if(isStar(starCoords,0.999)){\n            drawStars(color,starCoords);\n        }\n    }\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/lldXRl.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[364, 364, 387, 387, 429], [429, 429, 456, 456, 504], [506, 506, 594, 594, 1011], [1012, 1012, 1059, 1059, 1276], [1277, 1277, 1347, 1347, 1639], [1640, 1640, 1669, 1669, 2154], [2155, 2155, 2200, 2200, 2672], [2673, 2673, 2726, 2726, 3441]], "test": "valid"}
{"id": "lldXzj", "name": "sweep sphere vs triangle", "author": "xchip", "description": "Testing a capsule algorithm I found here: https://gist.github.com/jdryg/ecde24d34aa0ce2d4d87\n\nThe surface is not fully smooth, you can see the seams between the different primitives. I'll keep on searching...", "tags": ["sweepspheretriangle"], "likes": 4, "viewed": 208, "published": "Public", "date": "1480697980", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Computes when a sweeping sphere woudl collide with a triangle.\n// Uses the minkowski sum of geometry:\n//  - the sweeping A sweeping spherebecomes an ray\n//  - every point of the trienalge becomes an sphere, resulting in the image you are seeing\n//\n// The volume represents all the points where a sphere would collide with the triangle\n//\n// This code was a quick test to validate the capsule code I found here:\n// \t https://gist.github.com/jdryg/ecde24d34aa0ce2d4d87. \n//\n// As Iq pointer out a much better code is this one: https://www.shadertoy.com/view/Xt3SzX\n//   \n\n\nstruct Ray\n{\n\tvec3 m_Origin;\n\tvec3 m_Direction;\n};\n\nstruct Sphere\n{\n\tvec3 m_Center;\n\tfloat m_Radius;\n};\n\nstruct Capsule\n{\n\tvec3 m_A;\n\tvec3 m_B;\n\tfloat m_Radius;\n};\n\nbool IntersectRaySphere(const Ray ray, const Sphere sphere, out float tmin, out float tmax)\n{\n\tvec3 CO = ray.m_Origin - sphere.m_Center;\n\n\tfloat a = dot(ray.m_Direction,ray.m_Direction);\n\tfloat b = 2.0 * dot(CO,ray.m_Direction);\n\tfloat c = dot(CO,CO) - (sphere.m_Radius * sphere.m_Radius);\n\n\tfloat discriminant = b * b - 4.0 * a * c;\n\tif (discriminant < 0.0)\n\t\treturn false;\n\n\ttmin = (-b - sqrt(discriminant)) / (2.0 * a);\n\ttmax = (-b + sqrt(discriminant)) / (2.0 * a);\n\tif (tmin > tmax)\n\t{\n\t\tfloat temp = tmin;\n\t\ttmin = tmax;\n\t\ttmax = temp;\n\t}\n\n\treturn true;\n}\n\nbool IntersectRayTriangle(const Ray r, vec3 v0,vec3 v1,vec3 v2, out vec3 n1, out float tout) \n{\n    vec3 e0 = v1-v0, e1 = v2-v0;\n    vec3 normal = cross(e0,e1);\n    \n    // ray vs plane    \n    float t = (-dot(normal,r.m_Origin) + dot(normal,v0)) / dot(normal,r.m_Direction);\n    \n    // point inside triangle\n    vec3 point = r.m_Origin + r.m_Direction * t;\n    \n    if(dot(normal, cross(e0,point-v0)) < 0.0 ||\n       dot(normal, cross(e1,v2-point)) < 0.0 ||\n       dot(normal, cross(v2-v1,point-v1)) < 0.0) return false;   \n    \n    tout = t;\n    n1 = normalize(normal);\n    \n\treturn true;\n}\n\n\n\nbool IntersectRayCapsule(const Ray ray, const Capsule capsule, out vec3 p1, out vec3 n1, out float tout)\n{\n\t// http://pastebin.com/2XrrNcxb\n\n\t// Substituting equ. (1) - (6) to equ. (I) and solving for t' gives:\n\t//\n\t// t' = (t * dot(AB, d) + dot(AB, AO)) / dot(AB, AB); (7) or\n\t// t' = t * m + n where \n\t// m = dot(AB, d) / dot(AB, AB) and \n\t// n = dot(AB, AO) / dot(AB, AB)\n\t//\n\tvec3 AB = capsule.m_B - capsule.m_A;\n\tvec3 AO = ray.m_Origin - capsule.m_A;\n\n\tfloat AB_dot_d = dot(AB, ray.m_Direction);\n\tfloat AB_dot_AO = dot(AB, AO);\n\tfloat AB_dot_AB = dot(AB, AB);\n\n\tfloat m = AB_dot_d / AB_dot_AB;\n\tfloat n = AB_dot_AO / AB_dot_AB;\n\n\t// Substituting (7) into (II) and solving for t gives:\n\t//\n\t// dot(Q, Q)*t^2 + 2*dot(Q, R)*t + (dot(R, R) - r^2) = 0\n\t// where\n\t// Q = d - AB * m\n\t// R = AO - AB * n\n\tvec3 Q = ray.m_Direction - (AB * m);\n\tvec3 R = AO - (AB * n);\n\n\tfloat a = dot(Q,Q);\n\tfloat b = 2.0 * dot(Q,R);\n\tfloat c = dot(R,R) - (capsule.m_Radius * capsule.m_Radius);\n\n\tif (a == 0.0)\n\t{\n\t\t// Special case: AB and ray direction are parallel. If there is an intersection it will be on the end spheres...\n\t\t// NOTE: Why is that?\n\t\t// Q = d - AB * m =>\n\t\t// Q = d - AB * (|AB|*|d|*cos(AB,d) / |AB|^2) => |d| == 1.0\n\t\t// Q = d - AB * (|AB|*cos(AB,d)/|AB|^2) =>\n\t\t// Q = d - AB * cos(AB, d) / |AB| =>\n\t\t// Q = d - unit(AB) * cos(AB, d)\n\t\t//\n\t\t// |Q| == 0 means Q = (0, 0, 0) or d = unit(AB) * cos(AB,d)\n\t\t// both d and unit(AB) are unit vectors, so cos(AB, d) = 1 => AB and d are parallel.\n\t\t// \n\t\tSphere sphereA, sphereB;\n\t\tsphereA.m_Center = capsule.m_A;\n\t\tsphereA.m_Radius = capsule.m_Radius;\n\t\tsphereB.m_Center = capsule.m_B;\n\t\tsphereB.m_Radius = capsule.m_Radius;\n\n\t\tfloat atmin, atmax, btmin, btmax;\n\t\tif (!IntersectRaySphere(ray, sphereA, atmin, atmax) ||\n\t\t\t!IntersectRaySphere(ray, sphereB, btmin, btmax))\n\t\t{\n\t\t\t// No intersection with one of the spheres means no intersection at all...\n\t\t\treturn false;\n\t\t}\n\n\t\tif (atmin < btmin)\n\t\t{\n\t\t\tp1 = ray.m_Origin + (ray.m_Direction * atmin);\n\t\t\tn1 = p1 - capsule.m_A;\n\t\t\tn1 = normalize(n1);\n            tout = atmin;    \n\t\t}\n\t\telse\n\t\t{\n\t\t\tp1 = ray.m_Origin + (ray.m_Direction * btmin);\n\t\t\tn1 = p1 - capsule.m_B;\n\t\t\tn1 = normalize(n1);\n            tout = btmin;   \n\t\t}\n\n\t\treturn true;\n\t}\n\n\tfloat discriminant = b * b - 4.0 * a * c;\n\tif (discriminant < 0.0)\n\t{\n\t\t// The ray doesn't hit the infinite cylinder defined by (A, B).\n\t\t// No intersection.\n\t\treturn false;\n\t}\n\n\tfloat tmin = (-b - sqrt(discriminant)) / (2.0 * a);\n\tfloat tmax = (-b + sqrt(discriminant)) / (2.0 * a);\n\tif (tmin > tmax)\n\t{\n\t\tfloat temp = tmin;\n\t\ttmin = tmax;\n\t\ttmax = temp;\n\t}\n\n\t// Now check to see if K1 and K2 are inside the line segment defined by A,B\n\tfloat t_k1 = tmin * m + n;\n\tif (t_k1 < 0.0)\n\t{    \n\t\t// On sphere (A, r)...\n\t\tSphere s;\n\t\ts.m_Center = capsule.m_A;\n\t\ts.m_Radius = capsule.m_Radius;\n\n\t\tfloat stmin, stmax;\n\t\tif (IntersectRaySphere(ray, s, stmin, stmax))\n\t\t{\n\t\t\tp1 = ray.m_Origin + (ray.m_Direction * stmin);\n\t\t\tn1 = p1 - capsule.m_A;\n\t\t\tn1 = normalize(n1);\n            tout = stmin; \n\t\t}\n\t\telse\n\t\t\treturn false;\n\t}\n\telse if (t_k1 > 1.0)\n\t{\n\t\t// On sphere (B, r)...\n\t\tSphere s;\n\t\ts.m_Center = capsule.m_B;\n\t\ts.m_Radius = capsule.m_Radius;\n\n\t\tfloat stmin, stmax;\n\t\tif (IntersectRaySphere(ray, s, stmin, stmax))\n\t\t{\n\t\t\tp1 = ray.m_Origin + (ray.m_Direction * stmin);\n\t\t\tn1 = p1 - capsule.m_B;\n\t\t\tn1 = normalize(n1);\n            tout = stmin;    \n\t\t}\n\t\telse\n\t\t\treturn false;\n\t}\n\telse\n\t{\n\t\t// On the cylinder...\n\t\tp1 = ray.m_Origin + (ray.m_Direction * tmin);\n\n\t\tvec3 k1 = capsule.m_A + AB * t_k1;\n\t\tn1 = p1 - k1;\n\t\tn1 = normalize(n1);        \n        tout = tmin;    \n\t}\n \n\n\treturn true;\n}\n\nbool Triangle(const in Ray ray, in vec3 v1, in vec3 v2, in vec3 v3, out vec3 normal, out float tmin)\n{\n    Capsule capsule;\n    capsule.m_Radius = 1.;   \n\n    float t;    \n\tvec3 p1,n1; \n    \n    capsule.m_A = v1.xyz;\n    capsule.m_B = v2.xyz;    \n    \n    bool res = IntersectRayCapsule(ray, capsule, p1, n1, t);\n    if (res && t<tmin)\n    {\n        tmin = t;\n        normal = n1;\n    }\n   \n    capsule.m_A = v2.xyz;\n    capsule.m_B = v3.xyz;\n\n    res = IntersectRayCapsule(ray, capsule, p1, n1, t);\n    if (res && t<tmin)\n    {\n        tmin = t;\n        normal = n1;\n    }\n    \n    capsule.m_A = v3.xyz;\n    capsule.m_B = v1.xyz;\n\n    res = IntersectRayCapsule(ray, capsule, p1, n1, t);\n    if (res && t<tmin)\n    {\n        tmin = t;\n        normal = n1;\n    }\n   \n\n   vec3 e0 = v2-v1, e1 = v3-v1;\n   vec3 normal2 = normalize(cross(e0,e1)) * capsule.m_Radius; \n    \n   if (IntersectRayTriangle(ray, v1+normal2, v2+normal2, v3+normal2, n1, t))\n   {\n       if (t<tmin)\n       {\n       \t\ttmin = t;\n            normal = n1;\n       }\n   }\n\n   if (IntersectRayTriangle(ray, v2-normal2, v1-normal2, v3-normal2, n1, t))\n   {\n       if (t<tmin)\n       {\n       \t\ttmin = t;\n            normal = n1;\n       }\n   }\n    \n    \n    return true;    \n}\n\nvec3 RotY(float angle, vec3 pos)\n{\n    return vec3(cos(angle) * pos.x - sin(angle)* pos.z, pos.y, sin(angle) * pos.x + cos(angle) * pos.z);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = (2.0*fragCoord.xy-iResolution.xy) / iResolution.y;\n    float s = (2.0*iMouse.x-iResolution.x) / iResolution.y;\n    if( iMouse.z<0.001 ) s=0.0;\n\n    vec3 col = vec3(0.0);\n\n    Ray ray;\n    ray.m_Origin = vec3(0.0, -0.4, 8.0 );\n    ray.m_Direction = normalize( vec3(p,-2.0) );\n\n    vec3 v1 = RotY(iTime, vec3(-2.0,-2.0,0.0));\n    vec3 v2 = RotY(iTime, vec3(0.0,2.0,.0));\n    vec3 v3 = RotY(iTime, vec3(2.0,-2.0,0.0));\n\n    float tmin = 1e10;\n    vec3 nor = vec3(0.0, 0.0, 0.0 );\n    Triangle( ray, v1, v2, v3, nor, tmin );\n    if (tmin<1e10)\n    {\n    \tcol = nor;\n    }\n\n    \n   if (IntersectRayTriangle(ray, v1, v2, v3, nor, tmin))\n   {\n       col += vec3(.3,.3,.3);\n   }\n    \n    \n    \n    //col = pow( col, vec3(0.4545) );\n    fragColor = vec4( col, 1.0 );\n}    \n    ", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/lldXzj.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[739, 739, 832, 832, 1300], [1302, 1302, 1397, 1397, 1895], [1899, 1899, 2005, 2277, 5528], [6768, 6768, 6802, 6802, 6909], [6911, 6911, 6968, 6968, 7741]], "test": "error"}
{"id": "lldXzX", "name": "Bryan's Sun", "author": "bsugiarto", "description": "Sun", "tags": ["sun"], "likes": 0, "viewed": 75, "published": "Public", "date": "1480967075", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/* Bryan Sugiarto Sun */\n\n/* PI constant */\nconst float MATH_PI = float( 3.14159265359 );\n\n/* this is the visibility of light based on  */\nfloat VisibilityTerm( float roughness, float ndotv, float ndotl )\n{\n    float m2    = roughness * roughness;\n    float visV  = ndotl * sqrt( ndotv * ( ndotv - ndotv * m2 ) + m2 );\n    float visL  = ndotv * sqrt( ndotl * ( ndotl - ndotl * m2 ) + m2 );\n    return 0.5 / max( visV + visL, 0.00001 );\n}\n\n/* this is the diffuse lighting from light */\nfloat DistributionTerm( float roughness, float ndoth )\n{\n    float m2    = roughness * roughness;\n    float d     = ( ndoth * m2 - ndoth ) * ndoth + 1.0;\n    return m2 / ( d * d * MATH_PI );\n}\n\n/* \nfresnel is the light reflected from refrecation\nhttp://www.graphics.cornell.edu/~westin/misc/fresnel.html\n*/\nvec3 FresnelTerm( vec3 specularColor, float vdoth )\n{\n    vec3 fresnel = clamp( 50.0 * specularColor.y, 0.0, 1.0 ) * specularColor + ( 1.0 - specularColor ) * pow( ( 1.0 - vdoth ), 5.0 );\n    return fresnel;\n}\n\n\n/* this light specular term is calculated by this function  */\nvec3 LightSpecular( vec3 normal, vec3 viewDir, vec3 lightDir, vec3 lightColor, float roughness, vec3 specularColor )\n{\n    vec3 halfVec = normalize( viewDir + lightDir );\n\n    float vdoth = clamp( dot( viewDir,  halfVec  ), 0.0, 1.0 );\n    float ndoth = clamp( dot( normal,   halfVec  ), 0.0, 1.0 );\n    float ndotv = clamp( dot( normal,   viewDir  ), 0.0, 1.0 );\n    float ndotl = clamp( dot( normal,   lightDir ), 0.0, 1.0 );\n    \n    vec3    f = FresnelTerm( specularColor, vdoth );\n    float   d = DistributionTerm( roughness, ndoth );\n    float   v = VisibilityTerm( roughness, ndotv, ndotl );\n    \n    vec3 specular;\n    specular = lightColor * f * ( d * v * MATH_PI * ndotl );\n    return specular;\n}\n\n\n/* these two functions return > 0 if there is a point*/ \nfloat Sphere( vec3 p, float s )\n{\n    return length( p ) - s;\n}\nfloat Scene( vec3 p, mat3 localToWorld )\n{\n    p = p * localToWorld;\n    \n    /* create a spere with radius 1 at p */\n    float a = Sphere( p, 1.0 );\n    return a;\n}\n\n/* this returns a float of whether the ray hits the object \n-1  = it doesn't it\nro = ray origin\nrd = ray direction\nlocalToWorld = transformations\n*/\nfloat CastRay( in vec3 ro, in vec3 rd, mat3 localToWorld )\n{\n    const float maxd = 5.0;\n    \n    float h = 0.5;\n    float t = 0.0;\n   \n    for ( int i = 0; i < 50; ++i )\n    {\n        if ( h < 0.001 || t > maxd ) \n        {\n            break;\n        }\n        \n        h = Scene( ro + rd * t, localToWorld );\n        t += h;\n    }\n\n    if ( t > maxd )\n    {\n        t = -1.0;\n    }\n    \n    return t;\n}\n\n/* Creates a vector of the scene's normal value */\nvec3 SceneNormal( in vec3 pos, mat3 localToWorld )\n{\n    vec3 eps = vec3( 0.001, 0.0, 0.0 );\n    vec3 nor = vec3(\n        Scene( pos + eps.xyy, localToWorld ) - Scene( pos - eps.xyy, localToWorld ),\n        Scene( pos + eps.yxy, localToWorld ) - Scene( pos - eps.yxy, localToWorld ),\n        Scene( pos + eps.yyx, localToWorld ) - Scene( pos - eps.yyx, localToWorld ) );\n    return normalize( -nor );\n}\n\n/* main function */\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 q = fragCoord.xy / iResolution.xy;\n    vec2 p = -1.0 + 2.0 * q;\n    p.x *= iResolution.x / iResolution.y;\n\n    vec3 rayOrigin  = vec3( 0.0, -0.28, -3.5 );\n    vec3 rayDir     = normalize( vec3( p.x, p.y, 2.0 ) );\n    \n\n    /* rotation */\n    float theta = -0.5 * MATH_PI ;\n    mat3 rotX = mat3(\n        vec3( cos( theta ), sin( theta ), 0.0 ),\n        vec3( -sin( theta ), cos( theta ), 0.0 ),\n        vec3( 0.0, 0.0, 1.0 )\n        );    \n    \n    vec2 mo = iMouse.xy / iResolution.xy;    \n    float phi = 0.25 * MATH_PI + 2.0 * iTime + 10.0 * mo.x;    \n    mat3 rotY = mat3(\n        vec3( 1.0, 0.0, 0.0 ),\n        vec3( 0.0, cos( phi ), sin( phi ) ),\n        vec3( 0.0, -sin( phi ), cos( phi ) )\n        );\n    mat3 localToWorld = rotX * rotY;    \n\n\n    vec3 color = texture( iChannel1, q ).yyy * 0.3;\n    \n    /* cast ray and see if it hits */\n    float t = CastRay( rayOrigin, rayDir, localToWorld );\n    if ( t > 0.0 )\n    {\n        /* t = z value */\n        vec3 pos = rayOrigin + t * rayDir;\n        vec3 normal = SceneNormal( pos, localToWorld );\n        vec3 lightDir = normalize( vec3( 0.5, 0.3, 1.0 ) );\n        vec3 lightColor = vec3( 1.6 );\n        \n        /* get position of \"hit\" */\n        vec3 posLS = pos * localToWorld;\n        vec3 nrmLS = normal * localToWorld;\n        vec2 uvX = posLS.yz;\n        vec2 uvY = posLS.xz;\n        vec2 uvZ = posLS.xy;\n\n        /* load texure based on hit position*/\n        vec3 textureX = texture( iChannel0, uvX ).xyz;\n        vec3 textureY = texture( iChannel0, uvY ).xyz;\n        vec3 textureZ = texture( iChannel0, uvZ ).xyz;\n        vec3 weights = max( abs( nrmLS ), 0.00001 );\n        weights /= weights.x + weights.y + weights.z;\n        vec3 texture = textureX * weights.x + textureY * weights.y + textureZ * weights.z;\n        texture = vec3(1., .4, .3) + texture;\n       \n\n        /* add difuse lightning */\n        vec3 diffuseColor = texture ;\n        diffuseColor *= diffuseColor * vec3( 0.94, 0.72, 0.47 ) * 1.5;\n        vec3 specularColor =  vec3( 0.04 ) ;\n        float roughness =  0.6 ;\n        vec3 diffuse = lightColor * clamp( dot( normal, lightDir ), 0.0, 1.0 );\n        color = diffuseColor * ( diffuse + 0.2 );\n        color += LightSpecular( normal, rayDir, lightDir, lightColor, roughness, specularColor );\n    }\n    \n    fragColor = vec4( color, 1.0 );\n}\n\n", "image_inputs": [{"id": "XdfGRn", "previewfilepath": "/media/ap/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg", "ctype": "texture"}, {"id": "4sf3Rr", "previewfilepath": "/media/ap/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/lldXzX.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[91, 139, 206, 206, 437], [439, 485, 541, 541, 677], [679, 792, 845, 845, 1001], [1004, 1067, 1185, 1185, 1773], [1776, 1833, 1866, 1866, 1896], [1897, 1897, 1939, 1939, 2062], [2064, 2213, 2273, 2273, 2617], [2619, 2670, 2722, 2722, 3072], [3074, 3094, 3151, 3151, 5495]], "test": "error"}
{"id": "llGXRD", "name": "Blotter Logo", "author": "bradleygriffith", "description": "Blotter", "tags": ["blotter"], "likes": 0, "viewed": 61, "published": "Public", "date": "1483216888", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#ifdef GL_ES\nprecision mediump float;\n#endif\n\n\nfloat rand(vec2 co){\n    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n\n    // Setup ========================================================================\n\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    float time = iTime / 4.0;\n\n    vec4 finalColour = vec4(0.0);\n\n\n    // Create Heat Points ===========================================================\n\n    float heatDistanceScale = 35.0; // Larger value equates to smaller spread\n\n    // Define 2 heat points\n    float heatPoint1X = 0.5 - (sin(time) / 2.0);\n    float heatPoint1Y = 0.5 - ((cos(time) * abs(cos(time))) / 1.5);\n    vec2 heatPoint1Uv = vec2(heatPoint1X, heatPoint1Y) * iResolution.xy;\n\n    float heatPoint2X = 0.5 - (sin(time - 1.0) / 2.0);\n    float heatPoint2Y = 0.5 - ((cos(time - 1.0) * abs(cos(time))) / 1.0);\n    vec2 heatPoint2Uv = vec2(heatPoint2X, heatPoint2Y) * iResolution.xy;\n\n    // Calculate distances from current UV and combine\n    float heatPoint1Dist = smoothstep(0.0, 1.4, distance(fragCoord, heatPoint1Uv) / iResolution.y);\n    float heatPoint2Dist = smoothstep(0.0, 1.25, distance(fragCoord, heatPoint2Uv) / iResolution.y);\n    float combinedDist = (heatPoint1Dist * heatPoint2Dist);\n\n    // Invert and scale\n    float amount = 1.0 - smoothstep(0.15, 25.0, combinedDist * heatDistanceScale);\n    amount = smoothstep(-1.0, 1.0, amount);\n\n\n    // Create Darkness ==============================================================\n\n    const int darknessRadius = 10;\n\n    vec2 stepCoord = vec2(0.0);\n    vec2 stepUV = vec2(0.0);\n\n    vec4 stepSample = vec4(1.0);\n    vec4 darkestSample = vec4(1.0);\n\n    float stepDistance = 1.0;\n\n    vec2 maxDistanceCoord = fragCoord.xy + vec2(float(darknessRadius), 0.0);\n    vec2 maxDistanceUV = maxDistanceCoord.xy / iResolution.xy;\n    float maxDistance = distance(fragCoord, maxDistanceCoord);\n\n    float randNoise = rand(uv * sin(time * 0.025)) * 0.15;\n\n    // Find the darkest sample and some relevant meta data within a radius.\n    //   Note: You may notice some artifacts in our darkness. This is due to\n    //   us making steps on a `+=2` basis in the interest of performance. Play!\n    for (int i = -darknessRadius; i <= darknessRadius; i += 1) {\n        for (int j = -darknessRadius; j <= darknessRadius; j += 1) {\n            stepCoord = fragCoord + vec2(float(i), float(j));\n            stepUV = stepCoord / iResolution.xy;\n            stepSample = texture(iChannel0, stepUV);\n            vec4 sampleOnWhite = stepSample;\n            \n            stepDistance = distance(fragCoord, stepCoord) / smoothstep(-1.0, 1.0, amount);\n\n            float stepDarkestSampleWeight = 1.0 - clamp((stepDistance / maxDistance), 0.0, 1.0) + randNoise;\n            stepDarkestSampleWeight *= smoothstep(0.0, 7.5, amount);\n\n            vec4 mixedStep = mix(darkestSample, sampleOnWhite, stepDarkestSampleWeight);\n\n            if (mixedStep == min(mixedStep, darkestSample) && stepDistance <= maxDistance) {\n                darkestSample = mixedStep;\n            }\n        }\n    }\n\n\n    fragColor = darkestSample;\n}", "image_inputs": [{"id": "Xdf3zn", "previewfilepath": "/media/ap/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png", "channel": 0, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/llGXRD.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[47, 47, 67, 67, 139], [142, 142, 199, 287, 3159]], "test": "error"}
{"id": "llKXzh", "name": "Apollonian II", "author": "iq", "description": "A mini fork of [url]https://www.shadertoy.com/view/4ds3zn[/url].", "tags": ["3d", "raymarching", "fractal", "distancefield", "kleinian", "apollonian", "vr"], "likes": 59, "viewed": 5630, "published": "Public API", "date": "1483012278", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Copyright Inigo Quilez, 2015 - https://iquilezles.org/\n// I am the sole copyright owner of this Work.\n// You cannot host, display, distribute or share this Work in any form,\n// including physical and digital. You cannot use this Work in any\n// commercial or non-commercial product, website or project. You cannot\n// sell this Work and you cannot mint an NFTs of it.\n// I share this Work for educational purposes, and you can link to it,\n// through an URL, proper attribution and unmodified screenshot, as part\n// of your educational material. If these conditions are too restrictive\n// please contact me and we'll definitely work it out.\n\n// Antialiasing level. Make it 1 if you have a slow machine\n#define AA 1\n\n\nvec3 map( vec3 p )\n{\n\tfloat scale = 1.0;\n    \n    float orb = 10000.0;\n\n    for( int i=0; i<6; i++ )\n\t{\n\t\tp = -1.0 + 2.0*fract(0.5*p+0.5);\n\n        p -= sign(p)*0.04; // trick\n        \n        float r2 = dot(p,p);\n\t\tfloat k = 0.95/r2;\n\t\tp     *= k;\n\t\tscale *= k;\n\n        orb = min( orb, r2);\n\t}\n\n    float d1 = sqrt( min( min( dot(p.xy,p.xy), dot(p.yz,p.yz) ), dot(p.zx,p.zx) ) ) - 0.02;\n    float d2 = abs(p.y);\n    float dmi = d2;\n    float adr = 0.7*floor((0.5*p.y+0.5)*8.0);\n    if( d1<d2 )\n    {\n        dmi = d1;\n        adr = 0.0;\n    }\n    return vec3( 0.5*dmi/scale, adr, orb );\n}\n\nvec3 trace( in vec3 ro, in vec3 rd )\n{\n\tfloat maxd = 20.0;\n    float t = 0.01;\n    vec2  info = vec2(0.0);\n    for( int i=0; i<256; i++ )\n    {\n\t    float precis = 0.001*t;\n        \n        vec3  r = map( ro+rd*t );\n\t    float h = r.x;\n        info = r.yz;\n        if( h<precis||t>maxd ) break;\n        t += h;\n    }\n\n    if( t>maxd ) t=-1.0;\n    return vec3( t, info );\n}\n\nvec3 calcNormal( in vec3 pos, in float t )\n{\n    float precis = 0.0001 * t * 0.57;\n\n    vec2 e = vec2(1.0,-1.0)*precis;\n    return normalize( e.xyy*map( pos + e.xyy ).x + \n\t\t\t\t\t  e.yyx*map( pos + e.yyx ).x + \n\t\t\t\t\t  e.yxy*map( pos + e.yxy ).x + \n                      e.xxx*map( pos + e.xxx ).x );\n}\n\nvec3 forwardSF( float i, float n) \n{\n    const float PI  = 3.141592653589793238;\n    const float PHI = 1.618033988749894848;\n    float phi = 2.0*PI*fract(i/PHI);\n    float zi = 1.0 - (2.0*i+1.0)/n;\n    float sinTheta = sqrt( 1.0 - zi*zi);\n    return vec3( cos(phi)*sinTheta, sin(phi)*sinTheta, zi);\n}\n\nfloat calcAO( in vec3 pos, in vec3 nor )\n{\n\tfloat ao = 0.0;\n    for( int i=0; i<16; i++ )\n    {\n        vec3 w = forwardSF( float(i), 16.0 );\n\t\tw *= sign( dot(w,nor) );\n        float h = float(i)/15.0;\n        ao += clamp( map( pos + nor*0.01 + w*h*0.15 ).x*2.0, 0.0, 1.0 );\n    }\n\tao /= 16.0;\n\t\n    return clamp( ao*16.0, 0.0, 1.0 );\n}\n\n\nvec3 textureBox( sampler2D sam, in vec3 pos, in vec3 nor )\n{\n    vec3 w = nor*nor;\n    return (w.x*texture( sam, pos.yz ).xyz + \n            w.y*texture( sam, pos.zx ).xyz + \n            w.z*texture( sam, pos.xy ).xyz ) / (w.x+w.y+w.z);\n}\n\nvec3 render( in vec3 ro, in vec3 rd )\n{\n    vec3 col = vec3(0.0);\n    vec3 res = trace( ro, rd );;\n    float t = res.x;\n    if( t>0.0 )\n    {\n        vec3  pos = ro + t*rd;\n        vec3  nor = calcNormal( pos, t );\n        float fre = clamp(1.0+dot(rd,nor),0.0,1.0);\n        float occ = pow( clamp(res.z*2.0,0.0,1.0), 1.2 );\n              occ = 1.5*(0.1+0.9*occ)*calcAO(pos,nor);        \n        vec3  lin = vec3(1.0,1.0,1.5)*(2.0+fre*fre*vec3(1.8,1.0,1.0))*occ*(1.0-0.5*abs(nor.y));\n        \n      \tcol = 0.5 + 0.5*cos( 6.2831*res.y + vec3(0.0,1.0,2.0) );  \n        col *= textureBox( iChannel0, pos, nor ).xyz;\n        col = col*lin;\n        col += 0.6*pow(1.0-fre,32.0)*occ*vec3(0.5,1.0,1.5);        \n        col *= exp(-0.3*t);\n    }\n    col.z += 0.01;\n\n    return sqrt(col);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float time = iTime*0.15 + 0.005*iMouse.x;\n    \n    vec3 tot = vec3(0.0);\n    #if AA>1\n    for( int jj=0; jj<AA; jj++ )\n    for( int ii=0; ii<AA; ii++ )\n    #else\n    int ii = 0, jj = 0;\n    #endif\n    {\n        vec2 q = fragCoord+vec2(float(ii),float(jj))/float(AA);\n\n        // camera\n        vec3 ro = vec3( 2.8*cos(0.1+.33*time), 0.5 + 0.20*cos(0.37*time), 2.8*cos(0.5+0.35*time) );\n        vec3 ta = vec3( 1.9*cos(1.2+.41*time), 0.5 + 0.10*cos(0.27*time), 1.9*cos(2.0+0.38*time) );\n        float roll = 0.2*cos(0.1*time);\n        vec3 cw = normalize(ta-ro);\n        vec3 cp = vec3(sin(roll), cos(roll),0.0);\n        vec3 cu = normalize(cross(cw,cp));\n        vec3 cv = normalize(cross(cu,cw));\n\n        #if 1\n        vec2 p = (2.0*q-iResolution.xy)/iResolution.y;\n        vec3 rd = normalize( p.x*cu + p.y*cv + 2.0*cw );\n        #else\n        vec2 p = q/iResolution.xy;\n        vec2 an = 3.1415926535898 * (p*vec2(2.0, 1.0) - vec2(0.0,0.5));\n        vec3 rd = vec3(cos(an.y) * sin(an.x), sin(an.y), cos(an.y) * cos(an.x));\n\t\t#endif\n\n        tot += render( ro, rd );\n    }\n    \n    tot = tot/float(AA*AA);\n    \n\tfragColor = vec4( tot, 1.0 );\t\n\n}\n\nvoid mainVR( out vec4 fragColor, in vec2 fragCoord, in vec3 fragRayOri, in vec3 fragRayDir )\n{\n    vec3 col = render( fragRayOri + vec3(0.82,1.3,-0.3), fragRayDir );\n    fragColor = vec4( col, 1.0 );\n}", "image_inputs": [{"id": "XsfGRn", "previewfilepath": "/media/ap/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/llKXzh.jpg", "access": "shaders20k", "license": "proprietary-license", "functions": [[717, 717, 737, 737, 1307], [1309, 1309, 1347, 1347, 1681], [1683, 1683, 1727, 1727, 1982], [1984, 1984, 2020, 2020, 2284], [2286, 2286, 2328, 2328, 2622], [2625, 2625, 2685, 2685, 2863], [2865, 2865, 2904, 2904, 3646], [4860, 4860, 4954, 4954, 5061]], "test": "error"}
{"id": "lltSRf", "name": "Necromurlok - Binary", "author": "Necromurlok", "description": "Binary count", "tags": ["binary"], "likes": 2, "viewed": 997, "published": "Public", "date": "1480969732", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 coord = floor(uv * 32.0);\n    float time = iTime * 20.0;//floor(iTime);  \n    float col = mod(floor((time + coord.y) / pow(2.0, coord.x)), 2.0);\n                       \n\tfragColor = vec4(col, col, col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/lltSRf.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 318]], "test": "valid"}
{"id": "lltSWS", "name": "hhhzzzsss Perlin Noise", "author": "hhhzzzsss", "description": "This is fractal perlin noise.", "tags": ["perlin"], "likes": 2, "viewed": 145, "published": "Public", "date": "1481504998", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float hash(float n) {\n    return fract( sin(n*223.4023)*245.34685 )*16.0;\n}\nfloat grad(float hash, float x, float y, float z) {\n    if (hash<=1.0) {\n        return x+y;\n    }\n    else if(hash<=2.0) {\n        return -x+y;\n    }\n    else if(hash<=3.0) {\n        return x-y;\n    }\n    else if(hash<=4.0) {\n        return -x-y;\n    }\n    else if(hash<=5.0) {\n        return x+z;\n    }\n    else if(hash<=6.0) {\n        return -x+z;\n    }\n    else if(hash<=7.0) {\n        return x-z;\n    }\n    else if(hash<=8.0) {\n        return -x-z;\n    }\n    else if(hash<=9.0) {\n        return y+z;\n    }\n    else if(hash<=10.0) {\n        return -y+z;\n    }\n    else if(hash<=11.0) {\n        return y-z;\n    }\n    else if(hash<=12.0) {\n        return -y-z;\n    }\n    else if(hash<=13.0) {\n        return y+x;\n    }\n    else if(hash<=14.0) {\n        return -y+z;\n    }\n    else if(hash<=15.0) {\n        return y-x;\n    }\n    else {\n        return -y-z;\n    }\n}\nfloat perlin(vec3 x) {\n    \n    vec3 p = floor(x);\n    vec3 f = fract(x);\n    \n    float n = p.x + p.y*57.0 + p.z*113.0;\n    \n    float aaa = grad(hash( n ),f.x,f.y,f.z);\n    float baa = grad(hash( n+1.0 ),f.x-1.0,f.y,f.z);\n    float aba = grad(hash( n+57.0 ),f.x,f.y-1.0,f.z);\n    float bba = grad(hash( n+58.0 ),f.x-1.0,f.y-1.0,f.z);\n    \n    float aab = grad(hash( n+113.0 ),f.x,f.y,f.z-1.0);\n    float bab = grad(hash( n+114.0 ),f.x-1.0,f.y,f.z-1.0);\n    float abb = grad(hash( n+170.0 ),f.x,f.y-1.0,f.z-1.0);\n    float bbb = grad(hash( n+171.0 ),f.x-1.0,f.y-1.0,f.z-1.0);\n    \n    f = f*f*(3.0-2.0*f);\n    float res = mix( mix( mix(aaa,baa,f.x), mix(aba,bba,f.x), f.y ),\n                     mix( mix(aab,bab,f.x), mix(abb,bbb,f.x), f.y ),\n                    f.z );\n    \n    return res;\n    \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy/ iResolution.yy;\n    float pval = 0.0;\n    pval += perlin(vec3(uv,iTime));\n    pval += perlin(2.0*vec3(uv,iTime))/2.0;\n    pval += perlin(4.0*vec3(uv,iTime))/4.0;\n    pval += perlin(8.0*vec3(uv,iTime))/8.0;\n    pval += perlin(16.0*vec3(uv,iTime))/16.0;\n    pval += perlin(32.0*vec3(uv,iTime))/32.0;\n    pval += perlin(64.0*vec3(uv,iTime))/64.0;\n    fragColor = vec4(vec3(0.5+0.5*pval),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/lltSWS.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 21, 21, 75], [76, 76, 127, 127, 941], [942, 942, 964, 964, 1741], [1743, 1743, 1800, 1800, 2217]], "test": "valid"}
{"id": "lltXWS", "name": "Bevel Edge Box with Lighting", "author": "bolloxim", "description": "Procedurally generated bevel edge box with lighting highlights", "tags": ["lighting", "fresnel", "border", "curved", "beveledgebox"], "likes": 1, "viewed": 78, "published": "Public", "date": "1481532356", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Andi Smithers \n// button shader for smooth border edges\n// could also add shadow and shine effect as well using \n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // uniforms\n    float borderSize = 0.15;\n    float antiAliasSize = 0.02;\n    vec4 borderColor = vec4(0.8,0.9,1.0, 1);\n    vec4 centreColor = vec4(0.1,0.5,0.9,1);\n    float wobbly = iTime;\n\tfloat rounding = sin(wobbly)*3.0+4.0;\n    vec2 shadowVec = vec2(-0.05, 0.15);\n    float scaleBox = 1.2;\n\n    // alias thickness\n    float aascalar = 1.0 / antiAliasSize;\n    float outerAlias = 1.0 - antiAliasSize;\n\n    // convert UV into normalized coord\n    vec2 iuv = fragCoord.xy / iResolution.xy;\n\tvec2 uv = fragCoord.xy / iResolution.y;\n    vec2 uvUnit = (uv*2.0-1.0) * scaleBox;\n    vec2 shadowUnit = uvUnit + shadowVec;\n\n    // rounded edge - have to abs the value incase shader doesnt support negative powers\n    uvUnit = pow(abs(uvUnit), vec2(rounding));\n    shadowUnit = pow(abs(shadowUnit), vec2(rounding));\n    \n    // compute border\n    float borderEdge = pow(1.0-borderSize, rounding);\n    float borderAlias = borderEdge - antiAliasSize;\n    \n    // edge\n    float edge = length(uvUnit);\n    float outer = 1.0-(clamp(edge, outerAlias, 1.0)-outerAlias) * aascalar;\n    float inner = 1.0-(clamp(edge, borderAlias, borderEdge)-borderAlias) * aascalar;\n    float shadowInner = 1.0-(clamp(length(shadowUnit), borderAlias, borderEdge)-borderAlias) * aascalar;\n    float shadowOuter = 1.0-(clamp(length(shadowUnit), outerAlias, 1.0)-outerAlias) * aascalar;\n    \n    // blow out outer then chose minimum this ensures a mask around the alpha output\n    float outermask = min(outer*1000.0, 1.0);\n    \n    // fetch image and poor mans chromakey alpha\n    vec4 image = texture(iChannel0, iuv);\n    float alpha = length(image.rgb-vec3(0,1,0));\n    alpha = alpha> 0.5 ? 1.0 : 0.0;\n\n    // shadow\n    float shade = shadowInner<0.9 ? 0.8 + shadowInner*0.2: 1.0;\n    float shadeOut = shadowOuter>0.5 ? 0.0 + shadowOuter*0.2: 0.0;\n\t\n        \n    // blend inner/outer and image with image alpha\n    vec4 color = (centreColor*inner*(1.0-alpha)+image*alpha*inner)*shade + borderColor*(1.0-inner)*outermask;\n    color.a =  max(outer, shadeOut);\n    \n    // blend against a background texture - because shadertoy\n    vec4 background = texture(iChannel1, iuv);\n        \n    // and set the final color \n    fragColor = (color*color.a) + background*(1.0-color.a);\n}", "image_inputs": [{"id": "4dXGRn", "previewfilepath": "/media/ap/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg", "ctype": "texture"}, {"id": "XdfGRr", "previewfilepath": "/media/ap/35c87bcb8d7af24c54d41122dadb619dd920646a0bd0e477e7bdc6d12876df17.webm", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/35c87bcb8d7af24c54d41122dadb619dd920646a0bd0e477e7bdc6d12876df17.webm", "ctype": "video"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/lltXWS.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[117, 117, 174, 190, 2421]], "test": "error"}
{"id": "lltXz2", "name": "Ring Twister - 314 chars", "author": "GregRostami", "description": "I've loved Flyguy's Ring Twister since the first time I saw it. I always knew that we can make it smaller.\n[url]https://www.shadertoy.com/view/Xt23z3[/url]\nWe have it down to 316 chars, but I KNOW that we can get it smaller.\nPlease HELP!!", "tags": ["2d", "twist", "codegolf"], "likes": 11, "viewed": 676, "published": "Public API", "date": "1480712893", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Calling ALL code golfers (iq, Fabrice, coyote, LaBodilsen, 834144373)\n// Please help make this smaller.\n\n// Master Fabrice reduced the shader to 316 chars!!\n/**/\nvoid mainImage(out vec4 O, vec2 U)\n{\n    float\n        T = iTime,\n        r = length(U += U-(O.xy=iResolution.xy)) / O.y * 4. - 2.8,\n        a = atan(U.y, U.x),\n        B = mod( a+T + sin(a-=T) * sin(T) * 3.14, 1.57 )  - 2.;\n    \n    r -= T = sin( B += r > cos(B) ? 1.6 : 0.);\n    B = cos(B)- T;   \n\n    O =  vec4(5, 9, 9, 0)*B - vec4(-5, 3, 9, 0) * r;\n    O *= smoothstep(.45, .4, T = abs(r/B-.5) ) + .5;\n  \n    O *= T<.5 ? sin(r/B * 13.) * cos(a * 16.) < 0. ? .04 : .05 \n              : 0.;\n}\n/**/\n\n// 349 chars - DjinnKahn and GregRostami shaved a few more chars ...\n/**\nfloat T = iDate.w, P = 1.57, r, a, w, A, B;\n\nvoid mainImage(out vec4 O,vec2 U)\n{\n    r = length(U = (U+U-(O.xy=iResolution.xy)) / O.y * 4.) - 2.8;\n    A = sin(B += r > cos(B = mod( sin(a = atan(U.y, U.x) - T) * sin(T) * P * 2.+ a + T+T, P )\n                         - P*1.5) ? P : 0.);  \n    w = cos(B)- A;   \n    B = (r - A)/w;\n    O = (smoothstep(.45, .4, A = abs(B-.5)) + .5)\n      * (vec4(.5, .9, .95, P) - vec4(-.45, .3, .85, P) * B)\n      * w\n      * (.5 + sign(sin(B * P * 8.) * cos(a * 16.)) / 23.)\n      * step( A, .5 );\n}\n/**/\n\n// 334 chars - Smallest shader with some cheating.  ;-)\n/**\nfloat T = iDate.w, P = 1.57, r, a, w, A, B;\n\nvoid mainImage(out vec4 o,vec2 u)\n{\n    r = length(u = (u/iResolution.y-.5) * 8.) - 2.8;\n    A = sin(B += r > cos(B = mod( sin(a = atan(u.y, u.x) - T) * sin(T) * P * 2.+ a + T+T, P )\n                         - P*1.5) ? P : 0.);  \n    w = cos(B)- A;   \n    B = (r - A)/w;\n    o = (smoothstep(.45, .4, A = abs(B-.5)) + .5)\n      * (vec4(.5, .9, 1, P) - vec4(-.5, .3, .9, P) * B)\n      * w\n      * (.5 + sign(sin(B * P * 8.) * cos(a * 16.)) / 23.)\n      * step( A, .5 );\n}\n/**/\n\n// 382 chars - DjinnKahn showed us the power of the DARK SIDE!!\n/**\nfloat T = iDate.w, P = 3.14, r, a, u, v, A, B;\n\n#define s(A, w) ( u = (r - A)/w, v = abs(u-.5), mix(vec4(.5, .9, .95, P), vec4(.95, .6, .1, P), u) * w * (smoothstep(.45, .4, v) + .5) * (.5 + sign(sin(u * P * 4.) * cos(a * 16.)) / 23.) * step( v, .5 ) )\n\nvoid mainImage(out vec4 O,vec2 p)\n{\n    r = length(p = (p+p-(O.xy=iResolution.xy)) / O.y * 4.) - 2.8;\n    a = atan(p.y, p.x) + P - T;\n    B = mod( a + T+T + sin(a) * sin(T) * P, P*.5 ) - P*.75;\n    A = sin(B);\n    B = cos(B);      \n\tO = s(A, (B-A)) + s(B, (-A-B));\n}\n/**/\n\n// 451 chars - tabman came out of the shadows to school me in code golf!\n/**\nvoid mainImage(out vec4 o,vec2 u)\n{\n    vec2 R = iResolution.xy/2.;   \n    u = (u-R)/R.y;\n    float T = iTime, q = 1.57;\n    u = vec2(length(u)-.7,atan(u.y,u.x)+q+q);\n    o-= o-.05;\n    \n    for(float i = 0.;i < 4.;i++){\n        float a = u.y+2.*T+sin(u.y)*sin(T)*q*2.+q*i,\n              X = sin(a)/4.,\n              Y = sin(a+q)/4.,\n              w = Y-X,\n              U = (u.x-X)/w;\n\n        o = mix(o\n                ,\n                mix(vec4(.5,.9,.95,1),vec4(.95,.6,.1,1),U)\n                *w/sqrt((1.-cos(q))/8.)\n                *(smoothstep(.05,.1,U)*smoothstep(.95,.9,U)+.5)\n                *(sign(sin(U*q*8.)*cos((u.y+T*-.9)*16.))/16.+.7)\n                ,\n                vec4(U > 0. && U < 1. && X < Y)\n               );\n    }\n}\n/**/\n\n// 560 chars - Original reduced shader by Greg Rostami\n/**\nvec3 R = iResolution,c;\nfloat T = iDate.w, p = 3.14, t = p+p, a, f = 4.;\n\nvec4 s(float X, float Y, vec2 U)\n{\n    float w = Y - X, u = (U.x - X)/w;\n    vec3 c;\n    c = mix(vec3 (.5, .9, 1),vec3(1, .6, .1), u);\n    c *= w / sqrt( (1. - cos(t/f)) / 8. );\n    c *= smoothstep(.05, .1, u) * smoothstep(.95, .9, u) + .5;\n    U.y += T * -.9;\n    c *= sign(sin(u * p * f) * cos(U.y * 16.)) / 8. + .7;\n    return vec4(c, float((u > 0. && u < 1.) && X < Y));\n}\n\nvoid mainImage(out vec4 o,vec2 u)\n{\n    vec2 U, w = u / R.y;\n    w = 2.*w - R.xy / R.y,\n    U = vec2(length(w)-.7, atan(w.y, w.x) + p);\n    c = R-R + .05;\n    a = U.y + 2.*T + sin(U.y) * sin(T) * p;\n    for(float i = 0.;i < 4.;i++)\n        o = s(sin(a + t * i / f) / f, sin(a + t * ((i + 1.) / f)) / f, U),\n        c = mix(c, o.rgb, o.a);\n\to.rgb = c;\n}\n/**/", "image_inputs": [{"id": "Mdj3Wh", "previewfilepath": "https://soundcloud.com/algoritmos666/tron-legacy-soundtrack-ost-03", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "https://soundcloud.com/algoritmos666/tron-legacy-soundtrack-ost-03", "ctype": "musicstream"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/lltXz2.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[108, 165, 201, 201, 659]], "test": "valid"}
{"id": "lltXzj", "name": "2D Fractal : 1 / z^2 (it isol)", "author": "aiekick", "description": "iteration isolation", "tags": ["2dfractal"], "likes": 0, "viewed": 343, "published": "Public API", "date": "1480682357", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// z * z\nvec2 zmul(vec2 a, vec2 b)\n{\n\treturn vec2(a.x*b.x-a.y*b.y, a.x*b.y+b.x*a.y);\n}\n\n// 1 / z\nvec2 zinv(vec2 a)\n{\n\treturn vec2(a.x, -a.y) / dot(a,a);\n}\n\n// z^n ( n : 1 to 100 )\nvec2 zpow(vec2 a, int n)\n{\n\tvec2 res = a;\n\tfor (int k=1;k<100;k++)\n\t{\tif (k>n-1) break;\n\t\tres = zmul(res, a);\t}\n\treturn res;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 g = fragCoord.xy;\n    \n\tvec2 si = iResolution.xy;\n    \n\tvec2 uv = (g+g-si)/min(si.x,si.y) * 1.2;\n    \n\tvec2 v = vec2(490., 150. + 15. * sin(iTime*0.25));\n\t\n\tvec2 z = uv + vec2(0);\n\t\n\tvec2 c = (v*2.-vec2(900,300))/150.;\n\t\n\tfloat it = 0.;\n\tfloat d = 0.;\n    vec2 lz = z;\n\tfor (int i=0;i<100;i++)\n\t{\n        lz = z;\n\t\tif (dot(z,z) > 4.) break;\n\t\tz = zinv( zpow(z, 2)) + c;\n\t\tit++;\n\t}\n    \n    z = mix(lz,z,log2(log2(float(it)/(25. * sin(iTime*0.3)))));\n \n    // from iq code, but here i have not the smooth ieteration display... but why, and how i can smooth ?\n\tfloat sit = it - log2(log2(dot(z,z)))/log(4.) + 4.;\n    fragColor = 0.5 + 0.5 * cos( 2.88 + sit*0.2 + vec4(.3,1,0,1));\n   // fragColor = 1. - fragColor;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/lltXzj.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 9, 36, 36, 86], [88, 97, 116, 116, 154], [156, 180, 206, 206, 306], [308, 308, 365, 365, 1085]], "test": "valid"}
{"id": "llyXRW", "name": "message: click to see #2", "author": "FabriceNeyret2", "description": "Some shaders cannot give a working icon, typically when not all fragments are drawn at each frame.\nHere, we show how to add a text message to the icon to alert and invite the users to click to see the real thing.\nold: https://www.shadertoy.com/view/llXSRr", "tags": ["text", "font", "utils"], "likes": 3, "viewed": 1150, "published": "Public API", "date": "1483185763", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// === icon message: \"click to see\". link: https://www.shadertoy.com/view/MtyXRW\n\n// --- access to the image of ascii code c\n//#define C(c) U.x-=.5; T+= U.x<.0||U.x>1.||U.y<0.||U.y>1. ?vec4(0): texture( iChannel3, U/16. + fract( vec2(c, 15-c/16) / 16.))\n  #define C(c) U.x-=.5; T+= U.x<.0||U.x>1.||U.y<0.||U.y>1. ?vec4(0): textureGrad( iChannel3, U/16. + fract( vec2(c, 15-c/16) / 16.), dFdx(U/16.),dFdy(U/16.) )\n#define initMsg vec4 T = vec4(0)\n#define endMsg  return length(T.yz)==0. ? 0. : T.x\n\nfloat message(vec2 U) { // --- to alter in the icon with the alter message\n    vec4 T = vec4(0);  // or initMsg;\n    C(67);C(108);C(105);C(99);C(107);C(32);C(116);C(111);C(32);C(115);C(101);C(101); // message \"Click to see\"\n    return length(T.yz)==0. ? -1. : T.x; // or endMsg;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    //  if (iResolution.y<200.) to display only in the icon \n    if (iResolution.y<2000.) {float c=message((fragCoord/iResolution.y-vec2(.1,.2))*8.);if(c>=0.){fragColor=vec4(c);return;}}\n\n    \n    vec2 uv = fragCoord.xy / iResolution.xy;\n\tfragColor = vec4(uv,0.5+0.5*sin(iTime),1.0);\n\n}", "image_inputs": [{"id": "4dXGzr", "previewfilepath": "/media/ap/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png", "channel": 3, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/llyXRW.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[498, 498, 521, 572, 778], [780, 780, 837, 898, 1124]], "test": "error"}
{"id": "lt3SRX", "name": "Improved 3d Simplex Noise", "author": "panda1234lee", "description": "Improved 3d Simplex Noise", "tags": ["noise"], "likes": 8, "viewed": 272, "published": "Public", "date": "1480776193", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// ---------------------------------------------------------------\n// Based on \"Noise Lab (3D) \"https://www.shadertoy.com/view/4sc3z2\n// and \"3d simplex noise\" https://www.shadertoy.com/view/XsX3zB\n// ---------------------------------------------------------------\n\n// Bad random function\n/* discontinuous pseudorandom uniformly distributed in [-0.5, +0.5]^3 */\n/*vec3 random3(vec3 c) {\n\tfloat j = 4096.0 * sin(dot(c,vec3(17.0, 59.4, 15.0)));\n\tvec3 r;\n\tr.z = fract(512.0*j);\n\tj *= .125;\n\tr.x = fract(512.0*j);\n\tj *= .125;\n\tr.y = fract(512.0*j);\n\treturn r-0.5;\n}*/\n\n// ---------------------------------------------------\n// New random function, refered from \"Noise Lab (3D) \"\n// ---------------------------------------------------\n#define MOD3 vec3(.1031,.11369,.13787)\nvec3 random3(vec3 p3)\n{\n\tp3 = fract(p3 * MOD3);\n    p3 += dot(p3, p3.yxz+19.19);\n    return -1.0 + 2.0 * fract(vec3((p3.x + p3.y)*p3.z, (p3.x+p3.z)*p3.y, (p3.y+p3.z)*p3.x));\n}\n\n/* skew constants for 3d simplex functions */\nconst float F3 =  0.3333333;\nconst float G3 =  0.1666667;\n\n/* 3d simplex noise */\nfloat simplex3d(vec3 p) {\n\t /* 1. find current tetrahedron T and it's four vertices */\n\t /* s, s+i1, s+i2, s+1.0 - absolute skewed (integer) coordinates of T vertices */\n\t /* x, x1, x2, x3 - unskewed coordinates of p relative to each of T vertices*/\n\t \n\t /* calculate s and x */\n\t vec3 s = floor(p + dot(p, vec3(F3)));\n\t vec3 x = p - s + dot(s, vec3(G3));\n\t \n\t /* calculate i1 and i2 */\n\t vec3 e = step(vec3(0.0), x - x.yzx);\n\t vec3 i1 = e*(1.0 - e.zxy);\n\t vec3 i2 = 1.0 - e.zxy*(1.0 - e);\n\t \t\n\t /* x1, x2, x3 */\n\t vec3 x1 = x - i1 + G3;\n\t vec3 x2 = x - i2 + 2.0*G3;\n\t vec3 x3 = x - 1.0 + 3.0*G3;\n\t \n\t /* 2. find four surflets and store them in d */\n\t vec4 w, d;\n\t \n\t /* calculate surflet weights */\n\t w.x = dot(x, x);\n\t w.y = dot(x1, x1);\n\t w.z = dot(x2, x2);\n\t w.w = dot(x3, x3);\n\t \n\t /* w fades from 0.6 at the center of the surflet to 0.0 at the margin */\n\t w = max(0.6 - w, 0.0);\n\t \n\t /* calculate surflet components */\n\t d.x = dot(random3(s), x);\n\t d.y = dot(random3(s + i1), x1);\n\t d.z = dot(random3(s + i2), x2);\n\t d.w = dot(random3(s + 1.0), x3);\n\t \n\t /* multiply d by w^4 */\n\t w *= w;\n\t w *= w;\n\t d *= w;\n\t \n\t /* 3. return the sum of the four surflets */\n\t return dot(d, vec4(52.0));\n}\n\nfloat simplex3d_fractal(vec3 m) {\n    return   0.5333333*simplex3d(m)\n\t\t\t+0.2666667*simplex3d(2.0*m)\n\t\t\t+0.1333333*simplex3d(4.0*m)\n\t\t\t+0.0666667*simplex3d(8.0*m);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 p = fragCoord.xy/iResolution.x;\n\tvec3 p3 = vec3(p, iTime*0.025);\n\t\n\tfloat value;\n\t\n\tif (p.x <= 0.5) {\n\t\tvalue = simplex3d(p3*32.0);\n\t} else {\n\t\tvalue = simplex3d_fractal(p3*8.0+8.0);\n\t}\n\t\n\tvalue = 0.5 + 0.5*value;\n\tvalue *= smoothstep(0.0, 0.005, abs(0.5-p.x)); // hello, iq :)\n\t\n\tfragColor = vec4(\n\t\t\tvec3(value),\n\t\t\t1.0);\n\treturn;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/lt3SRX.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[769, 769, 792, 792, 944], [1051, 1074, 1099, 1352, 2269], [2271, 2271, 2304, 2304, 2436], [2438, 2438, 2495, 2495, 2836]], "test": "valid"}
{"id": "lt3XRf", "name": "Coin", "author": "bsugiarto", "description": "It's a coin", "tags": ["coin"], "likes": 0, "viewed": 90, "published": "Public", "date": "1480813360", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/* Coin by Bryan Sugiarto  */\n\nconst float MATH_PI = float( 3.14159265359 );\n\n/* documented in sun */\nfloat VisibilityTerm( float roughness, float ndotv, float ndotl )\n{\n\tfloat m2\t= roughness * roughness;\n\tfloat visV  = ndotl * sqrt( ndotv * ( ndotv - ndotv * m2 ) + m2 );\n\tfloat visL  = ndotv * sqrt( ndotl * ( ndotl - ndotl * m2 ) + m2 );\n\treturn 0.5 / max( visV + visL, 0.00001 );\n}\n\n/*documented in sun */\nfloat DistributionTerm( float roughness, float ndoth )\n{\n\tfloat m2\t= roughness * roughness;\n\tfloat d\t = ( ndoth * m2 - ndoth ) * ndoth + 1.0;\n\treturn m2 / ( d * d * MATH_PI );\n}\n\n/*documented in sun */\nvec3 FresnelTerm( vec3 specularColor, float vdoth )\n{\n\tvec3 fresnel = clamp( 50.0 * specularColor.y, 0.0, 1.0 ) * specularColor + ( 1.0 - specularColor ) * pow( ( 1.0 - vdoth ), 5.0 );\n\treturn fresnel;\n}\n\n/*documented in sun */\nvec3 LightSpecular( vec3 normal, vec3 viewDir, vec3 lightDir, vec3 lightColor, float roughness, vec3 specularColor )\n{\n\tvec3 halfVec = normalize( viewDir + lightDir );\n\n\tfloat vdoth = clamp( dot( viewDir,  halfVec  ), 0.0, 1.0 );\n\tfloat ndoth = clamp( dot( normal,   halfVec  ), 0.0, 1.0 );\n\tfloat ndotv = clamp( dot( normal,   viewDir  ), 0.0, 1.0 );\n\tfloat ndotl = clamp( dot( normal,   lightDir ), 0.0, 1.0 );\n\t\n\tvec3\tf = FresnelTerm( specularColor, vdoth );\n\tfloat   d = DistributionTerm( roughness, ndoth );\n\tfloat   v = VisibilityTerm( roughness, ndotv, ndotl );\n\t\n\tvec3 specular;\n\tspecular = lightColor * f * ( d * v * MATH_PI * ndotl );\n\treturn specular;\n}\n\n/* creates a cylinder */\nfloat Cylinder( vec3 p, float r, float height ) \n{\n\tfloat d = length( p.xz ) - r;\n\td = max( d, abs( p.y ) - height );\n\treturn d;\n}\n\n/*documented in sun */\nfloat Scene( vec3 p, mat3 localToWorld )\n{\n\tp = p * localToWorld;\n\tfloat a = Cylinder( p, 1.0, 0.1 );\n\treturn a;\n}\n\n/*documented in sun */\nfloat CastRay( in vec3 ro, in vec3 rd, mat3 localToWorld )\n{\n\tconst float maxd = 5.0;\n\t\n\tfloat h = 0.5;\n\tfloat t = 0.0;\n   \n\tfor ( int i = 0; i < 50; ++i )\n\t{\n\t\tif ( h < 0.001 || t > maxd ) \n\t\t{\n\t\t\tbreak;\n\t\t}\n\t\t\n\t\th = Scene( ro + rd * t, localToWorld );\n\t\tt += h;\n\t}\n\n\tif ( t > maxd )\n\t{\n\t\tt = -1.0;\n\t}\n\t\n\treturn t;\n}\n\n/*documented in sun */\nvec3 SceneNormal( in vec3 pos, mat3 localToWorld )\n{\n\tvec3 eps = vec3( 0.001, 0.0, 0.0 );\n\tvec3 nor = vec3(\n\t\tScene( pos + eps.xyy, localToWorld ) - Scene( pos - eps.xyy, localToWorld ),\n\t\tScene( pos + eps.yxy, localToWorld ) - Scene( pos - eps.yxy, localToWorld ),\n\t\tScene( pos + eps.yyx, localToWorld ) - Scene( pos - eps.yyx, localToWorld ) );\n\treturn normalize( -nor );\n}\n\n/* same main as sun but texture is modified */\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 q = fragCoord.xy / iResolution.xy;\n\tvec2 p = -1.0 + 2.0 * q;\n\tp.x *= iResolution.x / iResolution.y;\n\n\tvec3 rayOrigin  = vec3( 0.0, -0.28, -3.5 );\n\tvec3 rayDir\t = normalize( vec3( p.x, p.y, 2.0 ) );\n   \n\t\n\tvec2 mo = iMouse.xy / iResolution.xy;\t\n\tfloat phi = 0.25 * MATH_PI + 2.0 * iTime + 10.0 * mo.x;\t\n\tmat3 rotY = mat3(\n\t\tvec3( 1.0, 0.0, 0.0 ),\n\t\tvec3( 0.0, cos( phi ), sin( phi ) ),\n\t\tvec3( 0.0, -sin( phi ), cos( phi ) )\n\t);\n\t\n\tmat3 localToWorld = rotY;\t\n\n\n\tvec3 color = vec3(0,0,.2);\n\t\n\tfloat t = CastRay( rayOrigin, rayDir, localToWorld );\n\tif ( t > 0.0 )\n\t{\n\t\tvec3 pos = rayOrigin + t * rayDir;\n\t\tvec3 normal = SceneNormal( pos, localToWorld );\n\t\tvec3 lightDir = normalize( vec3( 0.5, 0.3, 1.0 ) );\n\t\tvec3 lightColor = vec3( 1.6 );\n\t\t\n\t\tvec3 posLS = pos * localToWorld;\n\t\tvec3 nrmLS = normal * localToWorld;\n\t\tvec2 uvX = posLS.yz;\n\t\tvec2 uvY = posLS.xz;\n\t\tvec2 uvZ = posLS.xy;\n\t\t\n\t\tvec3 textureX = texture( iChannel0, uvX ).xyz;\n\t\tvec3 textureY = texture( iChannel0, uvY ).xyz;\n\t\tvec3 textureZ = texture( iChannel0, uvZ ).xyz;\n\t\t\n\t\tvec3 weights = max( abs( nrmLS ), 0.00001 );\n\t\tweights /= weights.x + weights.y + weights.z;\n\t\t\n\t\tvec3 texture = textureX * weights.x + textureY * weights.y + textureZ * weights.z;\n\t\t\n\t\tfloat rustMask = 0.0;\n\t\t\t\t\n\t\tvec3 diffuseColor = mix( vec3( 0.0 ), texture, rustMask );\n\t\trustMask = 0.0;\n\t\tvec3 specularColor = mix( texture, vec3( 0.04 ), rustMask );\n\t\tfloat roughness = mix( 0.2, 0.6, rustMask );\n\t\t\n\t\tvec3 diffuse = lightColor * clamp( dot( normal, lightDir ), 0.0, 1.0 );\n\t\tcolor = diffuseColor * ( diffuse + 0.2 );\n\t\tcolor += LightSpecular( normal, rayDir, lightDir, lightColor, roughness, specularColor );\n\t}\n\t\n\tfragColor = vec4( color, 1.0 );\n}\n\n", "image_inputs": [{"id": "4dXGzn", "previewfilepath": "/media/ap/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/lt3XRf.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[78, 102, 169, 169, 385], [387, 410, 466, 466, 587], [589, 612, 665, 665, 815], [817, 840, 958, 958, 1504], [1506, 1531, 1581, 1581, 1661], [1663, 1686, 1728, 1728, 1800], [1802, 1825, 1885, 1885, 2142], [2144, 2167, 2219, 2219, 2542], [2544, 2591, 2648, 2648, 4347]], "test": "error"}
{"id": "lt3XW7", "name": "Spherical Images", "author": "soma_arc", "description": "Deformation of spherical images. Rotation -> Translation -> Scaling\nReference:\nSquares that Look Round: Transforming Spherical Images by Saul Schleimer and Henry Segerman\nhttp://archive.bridgesmathart.org/2016/bridges2016-15.html\n", "tags": ["3d", "equirectangular"], "likes": 25, "viewed": 734, "published": "Public", "date": "1481286899", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/*\nCreated by soma_arc - 2016\nThis work is licensed under Creative Commons Attribution-ShareAlike 3.0 Unported.\n*/\n\n\nvec2 rand2n(vec2 co, float sampleIndex) {\n    vec2 seed = co * (sampleIndex + 1.0);\n    seed+=vec2(-1,1);\n    // implementation based on: lumina.sourceforge.net/Tutorials/Noise.html\n    return vec2(fract(sin(dot(seed.xy ,vec2(12.9898,78.233))) * 43758.5453),\n                fract(cos(dot(seed.xy ,vec2(4.898,7.23))) * 23421.631));\n}\n\nconst float NO_ANSWER = -999999.;\n\nconst float PI = 3.14159265359;\nconst float fourPI = 12.566368;\nconst float EPSILON = 0.01;\n\nconst vec3 BLACK = vec3(0);\nconst vec3 WHITE = vec3(1);\nconst vec3 LIGHT_GRAY = vec3(0.78);\nconst vec3 RED = vec3(1, 0, 0);\nconst vec3 GREEN = vec3(0, .78, 0);\nconst vec3 BLUE = vec3(0, 0, 1);\nconst vec3 YELLOW = vec3(1, 1, 0);\nconst vec3 PINK = vec3(.78, 0, .78);\nconst vec3 LIGHT_BLUE = vec3(0, 1, 1);\n\nconst vec3 AMBIENT_FACTOR = vec3(0.1);\n\nconst float NO_HIT = 99999999.;\n\nconst int MTL_DIFFUSE = 0;\nconst int MTL_TRANSPARENT = 1;\n\nconst int OBJ_PLANE = 0;\nconst int OBJ_SPHERE = 1;\n\nstruct SL2C{\n\tvec2 a;\n    vec2 b;\n    vec2 c;\n    vec2 d;\n};\n    \nSL2C g_mobius;    \n\nconst vec2 COMPLEX_ONE = vec2(1, 0);\nconst vec2 COMPLEX_ZERO = vec2(0);\nconst SL2C MAT_UNIT = SL2C(COMPLEX_ONE, COMPLEX_ZERO,\n                      \t   COMPLEX_ZERO, COMPLEX_ONE);\nconst float PI_2 = PI / 2.;\nconst float TWO_PI = PI * 2.;\nconst float THREE_PI_2 = 3. * PI / 2.;\n\nvec2 equirectangularCoord(vec3 coordOnSphere){\n\tvec3 dir = (coordOnSphere);\n    float l = atan(dir.z, dir.x);\n    if (l < 0.) l += TWO_PI;\n    return vec2(l, acos(dir.y));\n}\n\nvec3 coordOnSphere(float theta, float phi){\n\treturn vec3(sin(phi) * cos(theta), \n                cos(phi),\n                sin(phi) * sin(theta));\n} \n\nvec2 compProd(const vec2 a, const vec2 b){\n\treturn vec2(a.x * b.x - a.y * b.y,\n                a.x * b.y + a.y * b.x);\n}\n\nvec2 compQuot(const vec2 a, const vec2 b){\n\tfloat denom = dot(b, b);\n    return vec2((a.x * b.x + a.y * b.y) / denom,\n                (a.y * b.x - a.x * b.y) / denom);\n}\n\nvec2 conjugate(const vec2 a){\n\tconst vec2 conj = vec2(1, -1);\n    return a * conj;\n}\n\nSL2C matInverse(const SL2C m){\n    vec2 invDet =  compQuot(COMPLEX_ONE, (compProd(m.a, m.d)-compProd(m.b, m.c)));\n\treturn SL2C(compProd(m.d, invDet), compProd(m.b * -1., invDet),\n                compProd(m.c * -1., invDet), compProd(m.a, invDet));\n}\n\nSL2C matProd(const SL2C m1, const SL2C m2){\n    return SL2C(compProd(m1.a, m2.a) + compProd(m1.b, m2.c),\n                compProd(m1.a, m2.b) + compProd(m1.b, m2.d),\n                compProd(m1.c, m2.a) + compProd(m1.d, m2.c),\n                compProd(m1.c, m2.b) + compProd(m1.d, m2.d));\n}\n\nvec4 applyMatVec(const SL2C m, const vec4 c){\n\treturn vec4(compProd(m.a, c.xy) + compProd(m.b, c.zw),\n                compProd(m.c, c.xy) + compProd(m.d, c.zw));\n}\n\nvec4 CP1FromSphere(vec3 pos){\n\tif(pos.y < 0.)\n        return vec4(pos.x, pos.z, 1. - pos.y, 0);\n    else\n        return vec4(1. + pos.y, 0, pos.x, -pos.z);\n}\n\nvec3 sphereFromCP1(vec4 p){\n\tvec2 z1 = p.xy;\n    vec2 z2 = p.zw;\n    if(length(z2) > length(z1)){\n    \tvec2 z = compQuot(z1, z2);\n        float denom = 1. + dot(z, z);\n        return vec3(2. * z.x / denom, (denom - 2.) / denom, 2. * z.y / denom);\n    }else{\n    \tvec2 z = conjugate(compQuot(z2, z1));\n        float denom = 1. + dot(z, z);\n        return vec3(2. * z.x / denom, (2. - denom) / denom, 2. * z.y / denom);\n    }\n}\n\nvec2 reverseStereoProject(const vec3 pos){\n\treturn vec2(pos.x, pos.z) / (1. - pos.z);\n}\n\nvec3 stereoProject(vec2 pos){\n    pos *= .5;\n    float x = pos.x;\n    float y = pos.y;\n    float x2y2 = x * x + y * y;\n    return vec3((2. * x) / (1. + x2y2),\n                (-1. + x2y2) / (1. + x2y2),\n                (2. * y) / (1. + x2y2));\n}\n\nSL2C infZeroOneToTriple(const vec4 p, const vec4 q, const vec4 r){\n\tvec2 p1 = p.xy; vec2 p2 = p.zw;\n    vec2 q1 = q.xy; vec2 q2 = q.zw;\n    vec2 r1 = r.xy; vec2 r2 = r.zw;\n    SL2C m = SL2C(p1, q1, p2, q2);\n    SL2C mInv = matInverse(m);\n    vec4 v = applyMatVec(mInv, r);\n    return SL2C(compProd(v.xy, p1), compProd(v.zw, q1),\n                compProd(v.xy, p2), compProd(v.zw, q2));\n}\n\nSL2C twoTriplesToSL(const vec4 a1, const vec4 b1, const vec4 c1,\n                    const vec4 a2, const vec4 b2, const vec4 c2){\n\treturn matProd(infZeroOneToTriple(a2, b2, c2), \n                   matInverse(infZeroOneToTriple(a1, b1, c1)));\n}\n\nvec3 vectorPerpToPQ(vec3 p, vec3 q){\n    if(abs(dot(p, q) + 1.) < 0.0001){\n        if(abs(dot(p, vec3(1, 0, 0))) > 0.999){\n        \treturn vec3(0, 1, 0);\n        }else{\n        \treturn normalize(cross(p, vec3(1, 0, 0)));\n        }\n    }else{\n    \treturn normalize(cross(p, q));\n    }\n}\n\nSL2C rotateAroundAxisSpherePointsPQ(const vec3 p, const vec3 q, const float theta){\n\tvec4 CP1p = CP1FromSphere(p);\n    vec4 CP1q = CP1FromSphere(q);\n\tvec3 r = vectorPerpToPQ(p, q);\n    vec4 CP1r = CP1FromSphere(r);\n    SL2C st = twoTriplesToSL(CP1p, CP1q, CP1r, \n            \t           vec4(0, 0, 1, 0),\n                           vec4(1, 0, 0, 0), \n                           vec4(1, 0, 1, 0));\n    SL2C mTheta = SL2C(vec2(cos(theta), sin(theta)), COMPLEX_ZERO,\n                       COMPLEX_ZERO, COMPLEX_ONE);\n    return matProd( matProd(matInverse(st), mTheta), st);\n}\n\nSL2C rotateSpherePointsPQ(const vec3 p, const vec3 q){\n\tvec4 CP1p = CP1FromSphere(p);\n    vec4 CP1q = CP1FromSphere(q);\n    if(abs(dot(p, q) - 1.) < 0.0001){\n    \treturn SL2C(COMPLEX_ONE, COMPLEX_ZERO, COMPLEX_ZERO, COMPLEX_ONE);\n    }else{\n    \tvec3 r = vectorPerpToPQ(p, q);\n        vec4 CP1r = CP1FromSphere(r);\n        vec4 CP1mr = CP1FromSphere(-r);\n        return twoTriplesToSL(CP1p, CP1r, CP1mr, CP1q, CP1r, CP1mr);\n    }\n}\n\nSL2C rotateAroundAxis(const vec3 p, const float theta){\n\treturn rotateAroundAxisSpherePointsPQ(p, -p, theta);\n}\n\nSL2C threePointsToThreePoints(const vec3 p1, const vec3 q1, const vec3 r1,\n                              const vec3 p2, const vec3 q2, const vec3 r2){\n\treturn twoTriplesToSL(CP1FromSphere(p1), CP1FromSphere(q1), CP1FromSphere(r1),\n                          CP1FromSphere(p2), CP1FromSphere(q2), CP1FromSphere(r2));\n}\n\nSL2C translateAlongAxis(const vec3 p, const vec3 q,\n                        const vec3 r1, const vec3 r2){\n\treturn threePointsToThreePoints(p, q, r1, p, q, r2);\n}\n\nSL2C zoomIn(const vec3 p, const float zoomFactor){\n\tSL2C rot = rotateSpherePointsPQ(p, coordOnSphere(0., 0.));\n    SL2C scl = SL2C(vec2(zoomFactor, 0), COMPLEX_ZERO,\n                    COMPLEX_ZERO, COMPLEX_ONE);\n    return matProd(matProd(matInverse(rot), scl), rot);\n}\n\nint g_objId = -1;\nint g_mtl = -1;\nvec4 intersectSphere(int objId, int mtl,\n                     vec3 sphereCenter, float radius,\n                     vec3 rayOrigin, vec3 rayDir,\n                     vec4 isect){\n    vec3 v = rayOrigin - sphereCenter;\n    float b = dot(rayDir, v);\n    float c = dot(v, v) - radius * radius;\n    float d = b * b - c;\n    if(d >= 0.){\n        float s = sqrt(d);\n        float t = -b - s;\n        if(t <= EPSILON) t = -b + s;\n        if(EPSILON < t && t < isect.x){\n            vec3 intersection = (rayOrigin + t * rayDir);\n            g_objId = objId;\n            g_mtl = mtl;\n            return vec4(t, normalize(intersection - sphereCenter));\n        }\n    }\n    return isect;\n}\n\nvec4 intersectPlane(int objId, int mtl,\n                    vec3 p, vec3 n,\n                    vec3 rayOrigin, vec3 rayDir, vec4 isect){\n    float d = -dot(p, n);\n    float v = dot(n, rayDir);\n    float t = -(dot(n, rayOrigin) + d) / v;\n    if(EPSILON < t && t < isect.x){\n        g_objId = objId;\n        g_mtl = mtl;\n        return vec4(t, n);\n    }\n    return isect;\n}\n\n\nvec2 circleInverse(vec2 pos, vec2 circlePos, float circleR){\n    return ((pos - circlePos) * circleR * circleR)/(length(pos - circlePos) * length(pos - circlePos) ) + circlePos;\n}\n\nconst float RECT_SIZE = PI/18.;\nvec3 equirectangularMap(const vec2 angles){\n    float theta = angles.x; float phi = angles.y;\n    if(abs(phi - PI_2) < .05) return BLUE;\n    if( phi <= .1 ) return PINK;\n    if( phi >= PI - .1) return LIGHT_BLUE;\n    if(abs(theta - PI) <= .05) return RED;\n    if(abs(theta - PI_2) <= .05) return GREEN;\n    if(abs(theta - THREE_PI_2) <= .05) return GREEN;\n    if(theta <= .025 || theta >= TWO_PI - .025) return RED;\n\n    int x = int(mod(floor(theta / RECT_SIZE)+floor(phi / RECT_SIZE), 2.));\n    if(x == 0){\n    \treturn WHITE;\n    }else{\n    \treturn BLACK;\n    }\n}\n\nvec3 hsv2rgb(vec3 c)\n{\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvec4 getIntersection(vec3 eye, vec3 ray){\n    vec4 isect = vec4(NO_HIT);\n    isect = intersectPlane(OBJ_PLANE, MTL_DIFFUSE,\n                           vec3(0, -1, 0), vec3(0, 1, 0),\n                           eye, ray, isect);\n    isect = intersectSphere(OBJ_SPHERE, MTL_DIFFUSE,\n                            vec3(0), 1.,\n                            eye, ray, isect);\n    return isect;\n}\n\nbool visible(vec3 eye, vec3 target){\n    vec3 v = normalize(target - eye);\n    return getIntersection(eye, v).x == NO_HIT;\n}\n\nvec3 diffuseLighting(const vec3 p, const vec3 n, const vec3 diffuseColor,\n                     const vec3 lightPos, const vec3 lightPower){\n    vec3 v = lightPos - p;\n    float d = dot(n, normalize(v));\n    float r = length(v);\n    return (d > 0. )//&& visible(p + EPSILON * n, lightPos)) \n        ?\n        (lightPower * (d / (fourPI * r * r))) * diffuseColor\n        : BLACK;\n}\n\nconst vec3 LIGHT_DIR = normalize(vec3(0.0, 1., 0.5));\nconst vec3 LIGHT_POS = vec3(3, 5, 0);\nconst vec3 LIGHT_POWER = vec3(300.);\n\nvec3 calcColor(vec3 eye, vec3 ray){\n    vec3 l = BLACK;\n    vec4 isect = getIntersection(eye, ray);\n\tif(isect.x != NO_HIT){\n\t\tvec3 matColor = WHITE;\n        vec3 normal = isect.yzw;\n\t\tvec3 intersection = eye + isect.x * ray;\n\t\tif(g_objId == OBJ_PLANE){\n\t\t\tvec4 z = CP1FromSphere(stereoProject(intersection.xz));\n            vec3 s = sphereFromCP1(applyMatVec(g_mobius, z));\n\t\t\tvec2 angles = equirectangularCoord(s);\n\t\t\tmatColor = equirectangularMap(angles);\n\t\t\t//matColor = LIGHT_GRAY;\n\t\t}else if(g_objId == OBJ_SPHERE){\n            vec4 z = CP1FromSphere(intersection);\n\t\t\tvec3 s = sphereFromCP1(applyMatVec(g_mobius, z));\n            vec2 angles = equirectangularCoord(s); \n\t\t\tmatColor = equirectangularMap(angles);\n\t\t}\n\t\t// diffuse lighting by directionalLight\n\t\t//vec3 diffuse = clamp(dot(normal, LIGHT_DIR), 0., 1.) * matColor;\n\t\tvec3 diffuse = diffuseLighting(intersection, normal, matColor,\n\t\t\t\t\t\t\t\t\t   LIGHT_POS, LIGHT_POWER);\n\t\tvec3 ambient = matColor * AMBIENT_FACTOR;\n\t\tl += (diffuse + ambient);\n\t}  \n    return l;\n}\n\nvec3 calcRay (const vec3 eye, const vec3 target,\n              const vec3 up, const float fov,\n              const float width, const float height, const vec2 coord){\n    float imagePlane = (height * .5) / tan(radians(fov) * .5);\n    vec3 v = normalize(target - eye);\n    vec3 focalXAxis = normalize(cross(v, up));\n    vec3 focalYAxis =  normalize(cross(v, focalXAxis ));\n    vec3 center = v * imagePlane;\n    vec3 origin = center - (focalXAxis * (width  * .5)) - (focalYAxis * (height * .5));\n    return normalize(origin + (focalXAxis * coord.x) + (focalYAxis * (height - coord.y)));\n}\n\nvec3 sphericalView(vec3 dir){\n    vec4 z = CP1FromSphere(dir);\n    vec2 angles = equirectangularCoord(sphereFromCP1(applyMatVec(g_mobius, z)));\n\treturn equirectangularMap(angles);\n\n}\n\nconst float DISPLAY_GAMMA_COEFF = 1. / 2.2;\nvec3 gammaCorrect(vec3 rgb) {\n\treturn vec3((min(pow(rgb.r, DISPLAY_GAMMA_COEFF), 1.)),\n\t\t\t\t(min(pow(rgb.g, DISPLAY_GAMMA_COEFF), 1.)),\n\t\t\t\t(min(pow(rgb.b, DISPLAY_GAMMA_COEFF), 1.)));\n}\n\nfloat scene(float t, float w, float s){\n    return clamp(t - w, 0.0, s) / s;  \n}\n\nconst float SAMPLE_NUM = 5.;\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float t = mod(iTime, 18.);\n    float rotateT = scene(t, 0., 6.) * TWO_PI;\n\tfloat translateT = scene(t, 6., 6.) * TWO_PI;\n\tfloat zoomT = scene(t, 12., 6.) * TWO_PI;\n\n    \n    vec3 s1 = coordOnSphere(PI, 0.);\n    vec3 s2 = coordOnSphere(PI, PI);\n    vec3 r1 = coordOnSphere(PI, PI_2);\n    vec3 r2 = coordOnSphere(PI + sin(translateT), PI_2 + sin(translateT));\n    vec3 s = coordOnSphere(PI, PI_2);\n    g_mobius = MAT_UNIT;\n    g_mobius = matProd(matInverse(rotateAroundAxis(s, PI/4. * sin(rotateT))),\n                       g_mobius);\n    g_mobius = matProd(translateAlongAxis(s1, s2, r1, r2),\n                       g_mobius);\n\tg_mobius = matProd(zoomIn(s, 1. + 2. * abs(sin(zoomT))),\n                       g_mobius);\n    float ratio = iResolution.x / iResolution.y / 2.0;\n    const vec3 up = vec3(0, 1, 0);\n    const float fov = 60.;\n    vec3 sum = vec3(0);\n    for(float i = 0. ; i < SAMPLE_NUM ; i++){\n        vec2 coordOffset = rand2n(fragCoord.xy, i);\n        if(fragCoord.x < iResolution.x/2.){\n            float r = 3.;\n            vec3 eye = vec3(r * sin(iTime), 1.5, r * cos(iTime));\n    \t\tvec3 target = vec3(0, 0, 0);\n        \tvec3 ray = calcRay(eye, target, up, fov,\n                         \t   iResolution.x/2., iResolution.y,\n                         \t   gl_FragCoord.xy + coordOffset);\n        \tsum += calcColor(eye, ray);\n        }else{\n            vec2 halfRes = iResolution.xy / 2.;\n            vec2 size = iResolution.xx / vec2(2, 4); // 2:1\n        \tvec2 p = vec2(fragCoord.x - size.x, fragCoord.y) / size;//[0, 1]\n            if(p.y <= 1.){\n                float theta = p.x * 2. * PI;\n                float phi = p.y * PI;\n                vec4 z = CP1FromSphere(coordOnSphere(theta, phi));\n\t\t\t\tvec2 angles = equirectangularCoord(sphereFromCP1(applyMatVec(g_mobius, z)));\n                sum += equirectangularMap(angles);\n                //sum += equirectangularMap(theta, phi);\n            }else{\n                vec3 eye = vec3(0, 0, 0);\n    \t\t\tvec3 target = vec3(1, 0, 0);//vec3(sin(iTime), sin(iTime), cos(iTime));\n            \tvec3 ray = calcRay(eye, target, up, fov,\n                         \t  \t   iResolution.x/2., iResolution.y - size.y,\n                         \t   \t   gl_FragCoord.xy - vec2(iResolution.x/2., size.y) + coordOffset);\n\n        \t\tsum += sphericalView(ray);\n            }\n        }\n    }\n    fragColor = vec4(gammaCorrect(sum/SAMPLE_NUM), 1.);\n\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/lt3XW7.jpg", "access": "shaders20k", "license": "unknown-license-reference", "functions": [[117, 117, 158, 158, 450], [1433, 1433, 1479, 1479, 1606], [1608, 1608, 1651, 1651, 1756], [1759, 1759, 1801, 1801, 1879], [1881, 1881, 1923, 1923, 2050], [2052, 2052, 2081, 2081, 2136], [2138, 2138, 2168, 2168, 2387], [2389, 2389, 2432, 2432, 2679], [2681, 2681, 2726, 2726, 2844], [2846, 2846, 2875, 2875, 3003], [3005, 3005, 3032, 3032, 3430], [3432, 3432, 3474, 3474, 3519], [3521, 3521, 3550, 3550, 3766], [3768, 3768, 3834, 3834, 4155], [4157, 4157, 4287, 4287, 4402], [4404, 4404, 4440, 4440, 4689], [4691, 4691, 4774, 4774, 5265], [5267, 5267, 5321, 5321, 5698], [5700, 5700, 5755, 5755, 5811], [5813, 5813, 5963, 5963, 6129], [6131, 6131, 6237, 6237, 6293], [6295, 6295, 6345, 6345, 6566], [6602, 6602, 6780, 6780, 7280], [7282, 7282, 7419, 7419, 7654], [7657, 7657, 7717, 7717, 7836], [7870, 7870, 7913, 7913, 8434], [8436, 8436, 8458, 8458, 8627], [8629, 8629, 8670, 8670, 9015], [9017, 9017, 9053, 9053, 9141], [9143, 9143, 9282, 9282, 9522], [9654, 9654, 9689, 9689, 10681], [10683, 10683, 10849, 10849, 11269], [11271, 11271, 11300, 11300, 11453], [11499, 11499, 11528, 11528, 11684], [11686, 11686, 11725, 11725, 11766], [11797, 11797, 11854, 11854, 14252]], "test": "error"}
{"id": "ltcSDl", "name": "#Devember 2016 - day 17", "author": "theGiallo", "description": "Exploring mix operation and smooth min.\nmix_op_9avg has similar results to smooth min polynomial, but worse and more expensive. ( line 577)", "tags": ["smin", "devember", "programming"], "likes": 1, "viewed": 125, "published": "Public", "date": "1482096909", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define SQRT2 1.4142135623730950488016887242096980785696\n#define PI    3.1415926535897932384626433832795\n#define HPI   1.57079632679489661923132169\n#define QPI   0.785398163397448309615660845819875721\n#define TAU   6.283185307179586476925286766559\n\n#define RENDER_REFLECTIONS 1\n#define DRAW_ITERATIONS_GRADIENT 0\n#define RAYM_MAX_ITERS 500\n\n#define MPt vec2\n#define distance x\n\nstruct\nMaterial\n{\n    vec3 color;\n    float diffuse_reflection;\n    float specular_reflection;\n    float ambient_reflection;\n    float shininess;\n};\nstruct\nMaterial_Point\n{\n    float distance;\n    Material material;\n};\n    \n#define MAT_PLASTIC  0.0\n#define MAT_ORANGE   1.0\n#define MAT_RED      2.0\n#define MAT_GREEN    3.0\n#define MAT_BLUE     4.0\n#define MAT_FLOOR_W  5.0\n#define MAT_FLOOR_B  6.0\n#define MAT_COUNT    7\n\n////////////////////////////////////////////////////////////////////////////////\n\nfloat\nmanhattan( vec2 p )\n{\n    p = abs ( p );\n    float ret = p.x + p.y;\n    return ret;\n}\nfloat\nmanhattan( vec2 p0, vec2 p1 )\n{\n    float ret;\n    \n    vec2 d = abs ( p1 - p0 );\n    ret = d.x + d.y;\n    \n    return ret;\n}\nfloat\nmanhattan( in vec3 p )\n{\n    p = abs ( p );\n    float ret = p.x + p.y + p.z;\n    return ret;\n}\nfloat\nsum( in vec2 p )\n{\n    float ret = p.x + p.y;\n    return ret;\n}\nfloat\nsum( in vec3 p )\n{\n    float ret = p.x + p.y + p.z;\n    return ret;\n}\n\nfloat\npow2( in float v )\n{\n    v = v*v;\n    return v;\n}\nvec2\npow2( in vec2 v )\n{\n    v = v*v;\n    return v;\n}\nvec3\npow2( in vec3 v )\n{\n    v = v*v;\n    return v;\n}\nfloat\npow3( in float v )\n{\n    v = v*v*v;\n    return v;\n}\nvec2\npow3( in vec2 v )\n{\n    v = v*v*v;\n    return v;\n}\nvec3\npow3( in vec3 v )\n{\n    v = v*v*v;\n    return v;\n}\nfloat\npow4( in float v )\n{\n    v = v*v;\n    v = v*v;\n    return v;\n}\nvec2\npow4( in vec2 v )\n{\n    v = v*v;\n    v = v*v;\n    return v;\n}\nvec3\npow4( in vec3 v )\n{\n    v = v*v;\n    v = v*v;\n    return v;\n}\nfloat\npow6( in float v )\n{\n    float ret = v*v;\n    ret = ret*ret;\n    ret = ret * v;\n    return ret;\n}\nvec2\npow6( in vec2 v )\n{\n    vec2 ret = v*v;\n    ret = ret*ret;\n    ret = ret * v;\n    return ret;\n}\nvec3\npow6( in vec3 v )\n{\n    vec3 ret = v*v;\n    ret = ret*ret;\n    ret = ret * v;\n    return ret;\n}\nvec2\npow8( in vec2 v )\n{\n    v = v*v;\n    v = v*v;\n    v = v*v;\n    return v;\n}\nvec3\npow8( in vec3 v )\n{\n    v = v*v;\n    v = v*v;\n    v = v*v;\n    return v;\n}\nvec2\npowv2( in vec2 v, in float exp )\n{\n    return pow( v, vec2(exp,exp) );\n}\nvec3\npowv3( in vec3 v, in float exp )\n{\n    return pow( v, vec3(exp,exp,exp) );\n}\n\nvec4\ncircle( vec4 color, vec2 pos, float radius, float border_width, vec2 point )\n{\n    vec4 ret = vec4(0);\n    color.rgb *= color.a;\n    \n    float dist = length( point - pos );\n    ret = color * (1.0 - smoothstep( radius, radius + border_width, dist ) );\n    \n    return ret;\n}\nvec4\nsquare( vec4 color, vec2 pos, float side, float border_width, float rot_rad, vec2 point )\n{\n    vec4 ret = vec4(0);\n    color.rgb *= color.a;\n    \n    float max_d = SQRT2 * side;\n    vec2 rd = point - pos;\n    float tot_rad = QPI + rot_rad;\n    vec2 rd_rot;\n    rd_rot.x = rd.x * cos( tot_rad ) + rd.y * sin( tot_rad );\n    rd_rot.y = rd.x * sin( tot_rad ) - rd.y * cos( tot_rad );\n    float dist = manhattan( rd_rot );\n    ret = color * (1.0 - smoothstep( max_d, max_d + border_width, dist ) );\n    \n    return ret;\n}\nvec4\nsquare_tex( vec4 color, vec2 pos, float side, float border_width, float rot_rad, vec2 point, sampler2D tex )\n{\n    vec4 ret = vec4(0);\n    color.rgb *= color.a;\n    \n    float max_d = SQRT2 * side;\n    vec2 rd = point - pos;\n    float tot_rad = QPI + rot_rad;\n    vec2 rd_rot;\n    rd_rot.x = rd.x * cos( tot_rad ) + rd.y * sin( tot_rad );\n    rd_rot.y = rd.x * sin( tot_rad ) - rd.y * cos( tot_rad );\n    float dist = manhattan( rd_rot );\n    ret = color * (1.0 - smoothstep( max_d, max_d + border_width, dist ) );\n    ret *= texture( tex, rd_rot * (0.5 / side ) + 0.5 );\n    \n    return ret;\n}\n\n// NOTE(theGiallo): pre-multiplied alpha\nvoid\nblend_pma( inout vec4 dst, in vec4 src )\n{\n    dst.rgb = src.rgb + dst.rgb * ( 1.0 - src.a );\n    dst.a = min( 1.0, dst.a + src.a );\n}\n\nfloat\nmirror( float x )\n{\n    x *= 0.5;\n    return 1.0 - abs( 2.0 * ( x - floor(x) ) - 1.0 );\n}\n\nfloat\ndecimal( float x )\n{\n    return x - floor(x);\n}\n\n// NOTE(theGiallo): h in [0,1)\nvec3\nrgb_from_hsv( vec3 hsv )\n{\n\tvec3 ret;\n\tfloat c = hsv.g * hsv.b;\n\tfloat hh = hsv.r * 6.0;\n\n\tfloat x = c * ( 1.0 - abs( hh - 2.0 * floor( hh / 2.0 ) - 1.0 ) );\n\n\tif ( hh < 1.0 || hh >= 6.0 )\n\t{\n\t\tret.r = c;\n\t\tret.g = x;\n\t\tret.b = 0.0;\n\t} else\n\tif ( hh < 2.0 )\n\t{\n\t\tret.r = x;\n\t\tret.g = c;\n\t\tret.b = 0.0;\n\t} else\n\tif ( hh < 3.0 )\n\t{\n\t\tret.r = 0.0;\n\t\tret.g = c;\n\t\tret.b = x;\n\t} else\n\tif ( hh < 4.0 )\n\t{\n\t\tret.r = 0.0;\n\t\tret.g = x;\n\t\tret.b = c;\n\t} else\n\tif ( hh < 5.0 )\n\t{\n\t\tret.r = x;\n\t\tret.g = 0.0;\n\t\tret.b = c;\n\t} else\n\tif ( hh < 6.0 )\n\t{\n\t\tret.r = c;\n\t\tret.g = 0.0;\n\t\tret.b = x;\n\t}\n\n\tfloat m = hsv.b - c;\n\tret.r += m;\n\tret.g += m;\n\tret.b += m;\n\n\treturn ret;\n}\n\n#define ORANGE_RGB vec3(1.0,0.4,0.0)\n#define T_EPS 0.001\n\nfloat\nminv3( in vec3 v )\n{\n    return min( v.x, min( v.y, v.z ) );\n}\n\nfloat\nmaxv3( in vec3 v )\n{\n    return max( v.x, max( v.y, v.z ) );\n}\n\nfloat\nminv2( in vec2 v )\n{\n    return min( v.x, v.y );\n}\n\nfloat\nmaxv2( in vec2 v )\n{\n    return max( v.x, v.y );\n}\n\n\nfloat\nlength3( in vec2 v )\n{\n    v = pow3(v);\n    return pow(sum(v),1.0/3.0);\n}\nfloat\nlength3( in vec3 v )\n{\n    v = pow3(v);\n    return pow(sum(v),1.0/3.0);\n}\n\nfloat\nlength4( in vec2 v )\n{\n    v = pow4(v);\n    return pow(sum(v),1.0/4.0);\n}\nfloat\nlength4( in vec3 v )\n{\n    v = pow4(v);\n    return pow(sum(v),1.0/4.0);\n}\nfloat\nlength6( in vec2 v )\n{\n    v = pow6(v);\n    return pow(sum(v),1.0/6.0);\n}\nfloat\nlength6( in vec3 v )\n{\n    v = pow6(v);\n    return pow(sum(v),1.0/6.0);\n}\nfloat\nlength8( in vec2 v )\n{\n    v = pow8(v);\n    return pow(sum(v),1.0/8.0);\n}\nfloat\nlength8( in vec3 v )\n{\n    v = pow8(v);\n    return pow(sum(v),1.0/8.0);\n}\n\n\n\nvec3\nat_pos( in vec3 pos, in vec3 p )\n{\n    return p-pos;\n}\n\nmat4\ntr( mat4 m )\n{\n    return mat4(\n       vec4(m[0][0],m[1][0],m[2][0],m[3][0]),\n       vec4(m[0][1],m[1][1],m[2][1],m[3][1]),\n       vec4(m[0][2],m[1][2],m[2][2],m[3][2]),\n       vec4(m[0][3],m[1][3],m[2][3],m[3][3])\n    );\n}\n\nvec3\nrotate( in vec3 r, in vec3 p )\n{\n\tmat4 Rx = mat4(\n\t   vec4( 1.0, 0.0,      0.0,       0.0 ),\n\t   vec4( 0.0, cos(r.x), -sin(r.x), 0.0 ),\n\t   vec4( 0.0, sin(r.x),  cos(r.x), 0.0 ),\n\t   vec4( 0.0, 0.0,      0.0,       0.0 ) );\n\tmat4 Ry = mat4(\n\t   vec4(  cos(r.y), 0.0, sin(r.y), 0.0 ),\n\t   vec4(  0.0,      1.0, 0.0,      0.0 ),\n\t   vec4( -sin(r.y), 0.0, cos(r.y), 0.0 ),\n\t   vec4(  0.0,      0.0, 0.0,      1.0 ) );\n\tmat4 Rz = mat4(\n\t   vec4( cos(r.z), -sin(r.z), 0.0, 0.0 ),\n\t   vec4( sin(r.z),  cos(r.z), 0.0, 0.0 ),\n\t   vec4( 0.0,      0.0,       1.0, 0.0 ),\n\t   vec4( 0.0,      0.0,       0.0, 1.0 ) );\n\tmat4 m = Rx * Ry * Rz;\n\treturn (vec4(p,1.0)*m).xyz;\n}\nvec3\nrotate_inv( in vec3 r, in vec3 p )\n{\n    r = -r;\n\tmat4 Rx = mat4(\n\t   vec4( 1.0, 0.0,      0.0,       0.0 ),\n\t   vec4( 0.0, cos(r.x), -sin(r.x), 0.0 ),\n\t   vec4( 0.0, sin(r.x),  cos(r.x), 0.0 ),\n\t   vec4( 0.0, 0.0,      0.0,       0.0 ) );\n\tmat4 Ry = mat4(\n\t   vec4(  cos(r.y), 0.0, sin(r.y), 0.0 ),\n\t   vec4(  0.0,      1.0, 0.0,      0.0 ),\n\t   vec4( -sin(r.y), 0.0, cos(r.y), 0.0 ),\n\t   vec4(  0.0,      0.0, 0.0,      1.0 ) );\n\tmat4 Rz = mat4(\n\t   vec4( cos(r.z), -sin(r.z), 0.0, 0.0 ),\n\t   vec4( sin(r.z),  cos(r.z), 0.0, 0.0 ),\n\t   vec4( 0.0,      0.0,       1.0, 0.0 ),\n\t   vec4( 0.0,      0.0,       0.0, 1.0 ) );\n\tmat4 m = Rz * Ry * Rx;\n\treturn (vec4(p,1.0)*m).xyz;\n}\n// NOTE(theGiallo): s.x radius, s.y Y axis rotation, s.z Z axis rotation\nvec3\ncartesian_from_spherical( in vec3 s )\n{\n\tmat4 Ry = mat4(\n\t   vec4(  cos(s.y), 0.0, sin(s.y), 0.0 ),\n\t   vec4(  0.0,      1.0, 0.0,      0.0 ),\n\t   vec4( -sin(s.y), 0.0, cos(s.y), 0.0 ),\n\t   vec4(  0.0,      0.0, 0.0,      1.0 ) );\n\tmat4 Rz = mat4(\n\t   vec4( cos(s.z), -sin(s.z), 0.0, 0.0 ),\n\t   vec4( sin(s.z),  cos(s.z), 0.0, 0.0 ),\n\t   vec4( 0.0,      0.0,       1.0, 0.0 ),\n\t   vec4( 0.0,      0.0,       0.0, 1.0 ) );\n\tmat4 m = Ry * Rz;\n\treturn (vec4(0.0,0.0,s.x,1.0)*m).xyz;\n}\n\nvec3\nat_angle( in vec3 a, in vec3 p )\n{\n    return rotate_inv( a, p );\n}\n\nvec3\nrepeat( in vec3 rep, in vec3 p )\n{\n    return mod(p,rep) + 0.5*rep;\n}\n\nvec2\nunion_op( in vec2 p0, in vec2 p1 )\n{\n    if ( p0.x < p1.x )\n    {\n        return p0;\n    }\n    return p1;\n}\n\nvec2\nintersect_op( in vec2 p0, in vec2 p1 )\n{\n    if ( p0.x > p1.x )\n    {\n        return p0;\n    }\n    return p1;\n}\n\nvec2\nsubtract_op( in vec2 p0, in vec2 p1 )\n{\n    p0.x = -p0.x;\n    if ( p0.x > p1.x )\n    {\n        return p0;\n    }\n    return p1;\n}\n\nvec2\nmix_op_( in vec2 p0, in vec2 p1, float max_dist )\n{\n    bool do_mix = p0.x > 0.0 && p0.x < max_dist &&\n                  p1.x > 0.0 && p1.x < max_dist;\n    if ( !do_mix && p0.x < p1.x )\n    {\n        return p0;\n    }\n    if ( !do_mix && p1.x < p0.x )\n    {\n        return p1;\n    }\n    float h_max_dist = max_dist * 0.5;\n    p0.x = (p0.x-h_max_dist)/h_max_dist;\n    p1.x = (p1.x-h_max_dist)/h_max_dist;\n    float p02 = p0.x*p0.x;\n    float p12 = p1.x*p1.x;\n    float v = ( p0.x + p1.x )*0.5;\n    vec2 ret = vec2(max_dist * v, p0.y );\n\n    return ret;\n}\nvec2\nmix_op_( in vec2 p0, in vec2 p1, float max_dist, float m0 )\n{\n    bool do_mix = p0.x > 0.0 && p0.x < max_dist &&\n                  p1.x > 0.0 && p1.x < max_dist;\n    if ( !do_mix && p0.x < p1.x )\n    {\n        return p0;\n    }\n    if ( !do_mix && p1.x < p0.x )\n    {\n        return p1;\n    }\n    float h_max_dist = max_dist * 0.5;\n    p0.x = (p0.x-h_max_dist)/h_max_dist;\n    p1.x = (p1.x-h_max_dist)/h_max_dist;\n    float v = mix( p0.x, p1.x, m0 );\n    vec2 ret = vec2(max_dist * v, p0.y );\n\n    return ret;\n}\nvec2\nmix_op_( in vec2 p0, in vec2 p1, vec2 max_dist )\n{\n    bool do_mix = p0.x > 0.0 && p0.x < max_dist.x &&\n                  p1.x > 0.0 && p1.x < max_dist.y;\n    if ( !do_mix && p0.x < p1.x )\n    {\n        return p0;\n    }\n    if ( !do_mix && p1.x < p0.x )\n    {\n        return p1;\n    }\n    vec2 h_max_dist = max_dist * 0.5;\n    p0.x = (p0.x-h_max_dist.x)/h_max_dist.x;\n    p1.x = (p1.x-h_max_dist.y)/h_max_dist.y;\n    float v = mix( p0.x, p1.x, 0.5 );\n    vec2 ret = vec2(minv2(max_dist) * v, p0.y );\n\n    return ret;\n}\n\nvec2\nmix_op_9avg( in vec2 p0, in vec2 p1, float max_dist )\n{\n    bool do_mix = p0.x > 0.0 && p0.x < max_dist &&\n                  p1.x > 0.0 && p1.x < max_dist;\n    if ( !do_mix && p0.x < p1.x )\n    {\n        return p0;\n    }\n    if ( !do_mix && p1.x < p0.x )\n    {\n        return p1;\n    }\n    vec2 m1 = mix_op_(p0,p1,vec2(max_dist*0.9, max_dist*0.1));\n    vec2 m2 = mix_op_(p0,p1,vec2(max_dist*0.8, max_dist*0.2));\n    vec2 m3 = mix_op_(p0,p1,vec2(max_dist*0.7, max_dist*0.3));\n    vec2 m4 = mix_op_(p0,p1,vec2(max_dist*0.6, max_dist*0.4));\n    vec2 m5 = mix_op_(p0,p1,vec2(max_dist*0.5, max_dist*0.5));\n    vec2 m6 = mix_op_(p0,p1,vec2(max_dist*0.4, max_dist*0.6));\n    vec2 m7 = mix_op_(p0,p1,vec2(max_dist*0.3, max_dist*0.7));\n    vec2 m8 = mix_op_(p0,p1,vec2(max_dist*0.2, max_dist*0.8));\n    vec2 m9 = mix_op_(p0,p1,vec2(max_dist*0.1, max_dist*0.9));\n    #if 0\n    return vec2((m1.x+m2.x+m3.x+m4.x+m5.x+m6.x+m7.x+m8.x+m9.x)/9.0,m9.y);\n    #else\n    return\n    vec2( minv3(\n       vec3( minv3(vec3(m1.x,m2.x,m3.x)),\n             minv3(vec3(m4.x,m5.x,m6.x)),\n             minv3(vec3(m7.x,m8.x,m9.x)) ) ), m9.y );\n    #endif\n}\n\nvec2\nmix_op_p2( in vec2 p0, in vec2 p1, float max_dist )\n{\n    bool do_mix = p0.x > 0.0 && p0.x < max_dist &&\n                  p1.x > 0.0 && p1.x < max_dist;\n    if ( !do_mix && p0.x < p1.x )\n    {\n        return p0;\n    }\n    if ( !do_mix && p1.x < p0.x )\n    {\n        return p1;\n    }\n    vec2 d;\n    d.x = p1.x - pow2( ( max_dist - p0.x ) / max_dist ) * max_dist;\n    d.y = p0.x - pow2( ( max_dist - p1.x ) / max_dist ) * max_dist;\n    return vec2((d.x+d.y)*0.5,p0.y);\n    //return vec2(min(d.x,d.y),p0.y);\n}\n\n// IQ's polynomial smooth min (k = 0.1);\nfloat\nsmin( float a, float b, float k )\n{\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\nvec2\nsmin_op( in vec2 p0, in vec2 p1, float max_dist )\n{\n    float m = smin(p0.x,p1.x,max_dist);\n    return vec2(m,m-p0.x>=m-p1.x?p0.y:p1.y);\n}\n\nvec2\nmix_op( in vec2 p0, in vec2 p1, float max_dist )\n{\n    if ( mod( iTime, 2.0 ) < 1.0 )\n    {\n        return smin_op(p0,p1,max_dist);\n    } else\n    {\n    \treturn mix_op_9avg(p0,p1,max_dist);\n    }\n#if 0\n\treturn mix_op_p2(p0,p1,max_dist);\n#endif\n}\n\nMaterial\nchange_color( Material m, vec3 color )\n{\n    Material ret = m;\n    ret.color = color;\n    return ret;\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\nfloat\nsphere_sd( in float sph_r, in vec3 p )\n{\n    return length( p ) - sph_r;\n}\n\nfloat\naab_sd( in vec3 sides, in vec3 p )\n{\n    sides *= 0.5;\n    p = abs( p );\n    vec3 d = p - sides;\n    return min( maxv3( d ), 0.0 ) + length( max(d,0.0) );\n}\n\nfloat\nplane_sd( in vec3 p )\n{\n    return abs( p.z );\n}\n\n\nfloat\nhalf_space_sd( in vec3 p )\n{\n    return p.z;\n}\n\nfloat\nround_aab_ud( in vec3 sides, in float r, in vec3 p )\n{\n    sides *= 0.5;\n    p = abs( p );\n    vec3 d = p - sides;\n    return length( max(d, 0.0) ) - r;\n}\n\n// NOTE(theGiallo): torus.x = big radius torus.y = solid radius\nfloat\ntorus_sd( in vec2 torus, in vec3 p )\n{\n    vec2 q = vec2(length(p.xy)-torus.x,p.z);\n    return length(q)-torus.y;\n}\n\nfloat\ncylinder_sd( in float r, in vec3 p )\n{\n    return length( p.xy ) - r;\n}\n\nfloat\ncapped_cylinder_sd( in vec2 rh, in vec3 p )\n{\n    vec2 d = abs( vec2( length( p.xy ), p.z ) ) - rh;\n    return min( maxv2(d), 0.0 ) + length( max(d, 0.0) );\n}\n\nfloat\nhalf_cone_pos_sd( in vec2 c, in vec3 p )\n{\n    vec2 c1 = vec2(c.y,-c.x);\n    return dot( c1, vec2(length(p.xy), p.z) );\n}\n\nfloat\ncone_sd( in vec2 c, in vec3 p )\n{\n    p = abs(p);\n    vec2 c1 = vec2(c.y,-c.x);\n    return dot( c1, vec2(length(p.xy), p.z) );\n}\n\nfloat\ncapped_cone_as_intersections_sd( in float h, in float r1, in float r2, in vec3 p )\n{\n    float R1z = (r1*h)/(r2-r1);\n    float R2z = R1z + h;\n    p = at_pos(vec3(0.0,0.0,-R1z),p);\n\tvec2 c = vec2(r2/R2z,1.0);\n\treturn\n\tmax( max( -half_space_sd( at_pos(vec3(0.0,0.0,R1z), p) ), half_space_sd( at_pos( vec3(0.0,0.0,R2z), p ) ) ),\n         half_cone_pos_sd( c, p )\n       );\n}\n\n// NOTE(theGiallo): d.x is the depth of the prism(or height), d.y the radius\n// NOTE(theGiallo): depth on x axis, diameter on y axis\nfloat\nhex_prism_sd( in vec2 dr, in vec3 p )\n{\n    p = abs(p);\n    return max(p.x-dr.x*0.5,max(p.y*0.866025+p.z*0.5,p.z)-0.866025*dr.y);\n}\n\nfloat\ntri_prism_sd( in vec2 ds, in vec3 p )\n{\n  \tp.xy = abs(p.xy);\n    \n    return max( p.x - ds.x*0.5, max( p.y * 0.866025 + 0.5 * p.z - ds.y * 0.433012702, -p.z ) );\n}\n\nfloat\ntri_prism_bary_sd( in vec2 ds, in vec3 p )\n{\n    p.z += ds.y * 0.288675135;\n    \n    return tri_prism_sd( ds, p );\n}\n\nfloat\ntri_prism_bary_r_sd( in vec2 dr, in vec3 p )\n{\n    dr.y = dr.y * 1.732050808;\n    \n    return tri_prism_bary_sd( dr, p );\n}\n\nfloat\ncline_sd( in vec3 a, in vec3 b, in float r, in vec3 p )\n{\n    vec3 ap = p - a, ab = b - a;\n    float t = clamp( dot(ap,ab)/dot(ab,ab), 0.0, 1.0 );\n    return length( ap - ab * t ) - r;\n}\n\nfloat\nellipsoid_sd( in vec3 r3, in vec3 p )\n{\n    return ( length( p/r3 ) - 1.0 ) * minv3(r3);\n}\n\nfloat\nsphere8_sd( in float sph_r, in vec3 p )\n{\n    return length8( p ) - sph_r;\n}\n\n// NOTE(theGiallo): torus.x = big radius torus.y = solid radius\nfloat\ntorus82_sd( in vec2 torus, in vec3 p )\n{\n    vec2 q = vec2(length(p.xy)-torus.x,p.z);\n    return length8(q)-torus.y;\n}\n\n// NOTE(theGiallo): torus.x = big radius torus.y = solid radius\nfloat\ntorus88_sd( in vec2 torus, in vec3 p )\n{\n    vec2 q = vec2(length8(p.xy)-torus.x,p.z);\n    return length8(q)-torus.y;\n}\n\n\nfloat\nsphere4_sd( in float sph_r, in vec3 p )\n{\n    return length4( p ) - sph_r;\n}\n\n// NOTE(theGiallo): torus.x = big radius torus.y = solid radius\nfloat\ntorus42_sd( in vec2 torus, in vec3 p )\n{\n    vec2 q = vec2(length(p.xy)-torus.x,p.z);\n    return length4(q)-torus.y;\n}\n\n// NOTE(theGiallo): torus.x = big radius torus.y = solid radius\nfloat\ntorus44_sd( in vec2 torus, in vec3 p )\n{\n    vec2 q = vec2(length4(p.xy)-torus.x,p.z);\n    return length4(q)-torus.y;\n}\n\nfloat\nsphere3_sd( in float sph_r, in vec3 p )\n{\n    return length3(abs(p)) - sph_r;\n}\n\n// NOTE(theGiallo): torus.x = big radius torus.y = solid radius\nfloat\ntorus32_sd( in vec2 torus, in vec3 p )\n{\n    vec2 q = vec2(length(p.xy)-torus.x,p.z);\n    return length3(abs(q))-torus.y;\n}\n\n// NOTE(theGiallo): torus.x = big radius torus.y = solid radius\nfloat\ntorus33_sd( in vec2 torus, in vec3 p )\n{\n    vec2 q = vec2(length3(abs(p.xy))-torus.x,p.z);\n    return length3(abs(q))-torus.y;\n}\n\nfloat\nspheremh_sd( in float sph_r, in vec3 p )\n{\n    return manhattan(p) - sph_r;\n}\n\n// NOTE(theGiallo): torus.x = big radius torus.y = solid radius\nfloat\ntorus2mh_sd( in vec2 torus, in vec3 p )\n{\n    vec2 q = vec2(manhattan(p.xy)-torus.x,p.z);\n    return length(q)-torus.y;\n}\n\n// NOTE(theGiallo): torus.x = big radius torus.y = solid radius\nfloat\ntorusmh2_sd( in vec2 torus, in vec3 p )\n{\n    vec2 q = vec2(length(p.xy)-torus.x,p.z);\n    return manhattan(q)-torus.y;\n}\n\n// NOTE(theGiallo): torus.x = big radius torus.y = solid radius\nfloat\ntorusmhmh_sd( in vec2 torus, in vec3 p )\n{\n    vec2 q = vec2(manhattan(p.xy)-torus.x,p.z);\n        return manhattan(q)-torus.y;\n}\n\n\nfloat\ncapped_cylinder8_sd( in vec2 rh, in vec3 p )\n{\n    vec2 d = abs( vec2( length8( p.xy ), p.z ) ) - rh;\n    return min( maxv2(d), 0.0 ) + length8( max(d, 0.0) );\n}\n\nfloat\ncapped_cylindermh_sd( in vec2 rh, in vec3 p )\n{\n    vec2 d = abs( vec2( manhattan( p.xy ), p.z ) ) - rh;\n    return min( maxv2(d), 0.0 ) + manhattan( max(d, 0.0) );\n}\n    \n//////////\n\nvec2\nmap( in vec3 pos )\n{    \n    float angle4 = iTime*TAU*0.25;\n    \n    MPt res;\n    res.distance = 1e38;\n\n    float m = mod( floor(pos.x * 2.0) + floor(pos.y * 2.0), 2.0 );\n    res = union_op( MPt( plane_sd( pos ),\n                         MAT_FLOOR_B * (1.0 - m) + MAT_FLOOR_W * m ),\n                    res );\n    \n    const float axis_r = 0.05;\n    res = union_op( MPt( sphere_sd( axis_r*2.0, at_pos( vec3(0.0), pos ) ),\n                         MAT_PLASTIC ), res );\n    res = union_op( MPt( cline_sd( vec3(0.0), vec3(1.0,0.0,0.0), axis_r, pos ),\n                         MAT_RED ),res );\n    res = union_op( MPt( cline_sd( vec3(0.0), vec3(0.0,1.0,0.0), axis_r, pos ),\n                         MAT_GREEN ),res );\n    res = union_op( MPt( cline_sd( vec3(0.0), vec3(0.0,0.0,1.0), axis_r, pos ),\n                         MAT_BLUE ),res );\n    \n    float Y;\n    float d = 2.0;\n    float base_y = -4.0;\n    float i = 0.0;\n\n    Y = base_y+d*i; i+=1.0;\n    res =\n       union_op(\n          subtract_op( MPt( aab_sd( vec3(1.0), at_pos(vec3(2.0,Y,0.5),pos) ), MAT_ORANGE ),\n                       MPt( sphere_sd( 0.65, at_pos(vec3(2.0,Y,0.5),pos) ), MAT_PLASTIC ) ),\n          res );\n    \n    Y = base_y+d*i; i+=1.0;\n    res =\n       union_op(\n          subtract_op( MPt( sphere_sd( 0.65, at_pos(vec3(2.0,Y,0.5),pos) ), MAT_PLASTIC ),\n                       MPt( aab_sd( vec3(1.0), at_pos(vec3(2.0,Y,0.5),pos) ), MAT_ORANGE ) ),\n          res );\n    \n    Y = base_y+d*i; i+=1.0;\n    res =\n       union_op(\n          subtract_op(\n              MPt( sphere_sd( 0.65, at_pos(vec3(2.0 + 0.25 * cos(pos.z*17.0),Y + 0.25 * sin(pos.z*17.0),0.5),pos) ), MAT_PLASTIC ),\n              MPt( aab_sd( vec3(1.0), at_pos(vec3(2.0,Y,0.5),pos) ), MAT_ORANGE ) ),\n          res );\n\n    Y = base_y+d*i; i+=1.0;\n    res =\n       union_op(\n          subtract_op(\n              MPt( sphere_sd( 0.65 + 0.2*sin(pos.z*17.0), at_pos(vec3(2.0,Y,0.5),pos) ), MAT_PLASTIC ),\n              MPt( aab_sd( vec3(1.0), at_pos(vec3(2.0,Y,0.5),pos) ), MAT_ORANGE ) ),\n          res );\n\n    Y = base_y+d*i; i+=1.0;\n    vec3 p = at_pos(vec3(2.0,Y,0.5),pos);\n    res =\n       union_op(\n          intersect_op(\n             MPt( sphere_sd( 0.7 +\n                             0.0025*sin(atan(p.y,p.x)*7.0)+\n                             0.0025*sin(atan(p.y,p.x)*17.0)+\n                             0.0025*sin(atan(p.y,p.x)*89.0)+\n                             0.0025*sin(p.z*11.0)+\n                             0.0025*sin(p.z*503.0)+\n                             0.0025*sin(p.z*193.0),\n                             p ), MAT_PLASTIC ),\n             MPt( aab_sd( vec3(1.0), at_pos(vec3(2.0,Y,0.5),pos) ), MAT_ORANGE ) ),\n          res );\n    \n\n    Y = base_y+d*i; i+=1.0;\n    res = union_op(\n        MPt( aab_sd( vec3(0.5,0.5,1.0),\n                     at_angle( vec3( 0.0, PI/6.0, angle4),\n                               at_pos( vec3(2.0,Y,0.7),pos)\n                             )\n                   ),\n              MAT_ORANGE ),\n        res\n    );\n\n    Y = base_y+d*i; i+=1.0;\n    res =\n       union_op(\n          mix_op(\n             MPt( aab_sd(vec3(2.5,1.0,0.7),at_pos(vec3(2.0,Y,0.5),pos) ), MAT_PLASTIC ),\n             MPt( aab_sd(vec3(1.0),        at_pos(vec3(2.0,Y,0.7),pos) ), MAT_ORANGE )\n             ,0.25\n          ),\n          res );\n\n\treturn res;\n}\n\nvec3\ncalc_normal( in vec3 pos, in float t )\n{\n    vec3 eps = vec3( max(0.02,T_EPS*t),0.0,0.0);\n\treturn normalize( vec3(\n           map( pos + eps.xyy ).distance - map( pos - eps.xyy ).distance,\n           map( pos + eps.yxy ).distance - map( pos - eps.yxy ).distance,\n           map( pos + eps.yyx ).distance - map( pos - eps.yyx ).distance ) );\n}\n\nvec2\nraymarch( in vec3 start, in vec3 dir, inout float t, in float t_max )\n{\n    MPt mp;\n    for ( int it=0; it!=RAYM_MAX_ITERS; ++it )\n    {\n        vec3 here = start + dir * t;\n        mp = map( here );\n        #if DRAW_ITERATIONS_GRADIENT\n        mp.y = mp.y * 10000.0 + float(it);\n        #endif\n        if ( mp.distance < ( T_EPS * t ) || t > t_max )\n        {\n        \tbreak;\n        }\n        #if 1\n        // NOTE(theGiallo): this is to sample nicely the twisted things\n        t += mp.distance * 0.4;\n        #else\n        t += mp.distance;\n        #endif\n    }\n    if ( t > t_max )\n    {\n        t = -1.0;\n    }\n    return mp;\n}\n\nfloat\nshadow( in vec3 start, in vec3 dir )\n{\n    float ret = 1.0;\n    float c = step( mod( iTime, 4.0 ), 2.0 );\n    float t = 0.02, t_max = 16.0;\n    MPt mp;\n    \n    #if DRAW_ITERATIONS_GRADIENT\n    int it_;\n    #endif\n    for ( int it=0; it!=16; ++it )\n    {\n\t    #if DRAW_ITERATIONS_GRADIENT\n\t    it_ = it;\n    \t#endif\n        vec3 here = start + dir * t;\n        mp = map( here );\n        ret = min( ret, 8.0*mp.distance/t);\n        if ( mp.distance < ( T_EPS * t ) || t > t_max )\n        {\n        \tbreak;\n        }\n        \n        float inc;\n        // NOTE(theGiallo): this is to sample nicely the twisted things\n        inc = c * mp.distance * 0.4;\n\t\tinc += ( 1.0 - c ) * clamp( mp.distance, 0.02, 0.1 );\n        t += inc;\n    }\n    #if DRAW_ITERATIONS_GRADIENT\n    return float(it_);\n    #endif\n    if ( t > t_max )\n    {\n        t = -1.0;\n    }\n    if ( c == 0.0 ) return 1.0 - clamp( ret, 0.0, 1.0 );\n\n    if ( t < 0.0 )\n    {\n        return 0.0;\n    }\n    //return 1.0;\n    ret = 1.0 / pow(1.0 - 1e-30 + max( mp.distance, 1e-30 ), 5.0 );\n    float th = 0.1;\n    return smoothstep( 0.0, 1.0, ( ret*1.1 - th ) / (1.0-th) );\n}\n\n\nfloat\nimg_scale_given_h_fov( float near, float fov )\n{\n    float hw = iResolution.x / min( iResolution.y, iResolution.x );\n    return tan( fov * 0.5 ) * near / hw;\n}\n\nvec3\nrender_no_reflections( in Material materials_table[MAT_COUNT],\n                       in vec3 start, in vec3 dir, in float max_dist,\n                       inout float t, out vec3 normal, out int material_index )\n{\n    vec3 ret = rgb_from_hsv(vec3(0.57,0.5,0.7));\n    vec3 sun_specular_color = vec3(0.8,1.0,1.0);\n    vec3 sun_light_dir = normalize( vec3( -0.5, 1.0, -1.0 ) );\n\n    MPt mp = raymarch( start, dir, t, 1e2 );\n    material_index = int(mp.y);\n    Material mat;\n    for ( int i = 0; i != MAT_COUNT; ++i )\n    {\n        if ( i == material_index )\n        {\n            mat = materials_table[i];\n        }\n\t}\n\n    if ( t > 0.0 )\n    {\n        vec3 point = start + dir * t;\n        normal = calc_normal( point, t );\n        // ret = 0.5 + normal * 0.5;return ret;\n        #if DRAW_ITERATIONS_GRADIENT\n        mp.y += shadow( point, -sun_light_dir );\n        #else\n        float sh = 1.0 - shadow( point, -sun_light_dir );\n        float diffuse = sh * max( 0.0, dot( normal, -sun_light_dir ) );\n        float spec = sh * pow( max( 0.0, dot( reflect( dir, normal ) , -sun_light_dir ) ), mat.shininess  );\n        float ambient = 0.3;\n        ret = ( diffuse * mat.diffuse_reflection +\n                ambient * mat.ambient_reflection ) * mat.color +\n                spec    * mat.specular_reflection * sun_specular_color;\n        #endif\n    } else\n    if ( t == 0.0 )\n    {\n        ret = mat.color / ( 1.0 - 20.0 * mp.distance );\n    }\n    #if DRAW_ITERATIONS_GRADIENT\n    material_index = int(mp.y);\n    #endif\n    return ret;\n}\n\nvoid\ncamera_linear_gallery( in vec3 start, in vec3 obj_dist, in float sec_per_obj,\n                       out vec3 camera_pos )\n{\n    const int obj_count = 7;\n\n    float u = mirror( iTime / ( float(obj_count) * sec_per_obj ) );\n\n    u = 1.0;\n\n    float pu = 1.0 / float(obj_count-1);\n    float pt = 0.0;\n    vec3 p = vec3(0.0);\n    for ( int i = 0; i!=obj_count; ++i )\n    {\n        float s = pu * ( -0.5 + float(i) );\n        p +=\n           ( start + obj_dist * float(i) ) *\n           ( smoothstep( s - 0.1 * pu, s + 0.1 * pu, u ) - smoothstep( s + pu * 0.9, s + pu * 1.1, u ) );\n    }\n    camera_pos.xyz = p;\n}\n\nvoid\ncamera_radial_gallery_mirror( in vec3 center, in vec2 radial_start, in vec2 obj_radial_dist, in float radius, in float sec_per_obj,\n                       out vec3 camera_pos )\n{\n    const int obj_count = 6;\n\n    float u = mirror( iTime / ( float(obj_count) * sec_per_obj ) );\n\n    //u = 1.0;\n\n    float pu = 1.0 / float(obj_count-1);\n    float pt = 0.0;\n    vec2 a = vec2(0.0);\n    for ( int i = 0; i!=obj_count; ++i )\n    {\n        float s = pu * ( -0.5 + float(i) );\n        a +=\n           ( obj_radial_dist * float(i) ) *\n           ( smoothstep( s - 0.1 * pu, s + 0.1 * pu, u ) - smoothstep( s + pu * 0.9, s + pu * 1.1, u ) );\n        \n    }\n    camera_pos.xyz = center + cartesian_from_spherical( vec3(radius,radial_start+a) );\n}\nvoid\ncamera_radial_gallery_loop( in vec3 center, in vec2 radial_start, in vec2 obj_radial_dist, in float radius, in float sec_per_obj,\n                       out vec3 camera_pos, out vec3 look )\n{\n    // NOT)theGiallo): set 1+ if you want a complete circle\n    const int obj_count = 9;\n\n    float u = decimal( iTime / ( float(obj_count) * sec_per_obj ) );\n\n    //u = 1.0;\n\n    float pu = 1.0 / float(obj_count-1);\n    float pt = 0.0;\n    vec2 a = vec2(0.0);\n    for ( int i = 0; i!=obj_count; ++i )\n    {\n        float s = pu * ( -0.5 + float(i) );\n        a +=\n           ( obj_radial_dist * float(i) ) *\n           ( smoothstep( s - 0.1 * pu, s + 0.1 * pu, u ) - smoothstep( s + pu * 0.9, s + pu * 1.1, u ) );\n        \n    }\n    camera_pos.xyz = cartesian_from_spherical( vec3(radius,radial_start+a) );\n    look = normalize(-camera_pos);\n    camera_pos.xyz += center;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{    \n\tvec2 q = fragCoord.xy / iResolution.xy;\n    vec2 qc = 2.0 * q - 1.0;\n\tvec2 p = ( 2.0 * fragCoord.xy - iResolution.xy ) / min( iResolution.y, iResolution.x );\n    vec4 col;\n    \n    float img_plane_dist = 0.05;\n    float img_scale = img_scale_given_h_fov( img_plane_dist, TAU / 3.0 );\n\n    float time = iTime * PI * 0.06125;\n\n    vec3 d = vec3(0.0,2.0,0.0);\n    vec3 base = vec3(3.5,-4.0,1.3);\n    \n    vec3 camera_pos;\n    vec3 look;\n    #if 0\n    camera_linear_gallery( base, d, 4.0, camera_pos );\n    vec3 look = normalize( vec3(-0.5,0.0,-0.1) );\n    #else\n    camera_radial_gallery_loop( vec3(2.0,8.0,0.0), vec2(HPI*0.5,-QPI), vec2(0.0,TAU/8.0), 2.2, 4.0, camera_pos, look );\n    #endif\n\n    vec3 up = vec3(0.0,0.0,1.0);\n    vec3 right = cross( look, up );\n    vec3 img_up = cross( right, look );\n\n    vec3 dir = look * img_plane_dist + right * p.x * img_scale + img_up * p.y * img_scale;\n    vec3 start = camera_pos + dir;\n    dir = normalize( dir );\n\n    float max_dist = 1e2;\n    float max_dist_reflection = 1e1;\n    float t = 0.0, t1 = 0.0;\n    vec3 normal, normal1;\n    vec3 pos, pos1, dir1;\n\n    Material materials_table[MAT_COUNT];\n\n    materials_table[int(MAT_PLASTIC)].color = rgb_from_hsv( vec3(0.083,0.1,1.0) );\n    materials_table[int(MAT_PLASTIC)].diffuse_reflection  = 1.0;\n    materials_table[int(MAT_PLASTIC)].specular_reflection = 1.0;\n    materials_table[int(MAT_PLASTIC)].ambient_reflection  = 1.0;\n    materials_table[int(MAT_PLASTIC)].shininess           = 15.0;\n\n    materials_table[int(MAT_FLOOR_B)].color = vec3(0.7);\n    materials_table[int(MAT_FLOOR_B)].diffuse_reflection  = 1.0;\n    materials_table[int(MAT_FLOOR_B)].specular_reflection = 0.2;\n    materials_table[int(MAT_FLOOR_B)].ambient_reflection  = 0.5;\n    materials_table[int(MAT_FLOOR_B)].shininess           = 1.0;\n\n    materials_table[int(MAT_FLOOR_W)].color = vec3(1.0);\n    materials_table[int(MAT_FLOOR_W)].diffuse_reflection  = 1.0;\n    materials_table[int(MAT_FLOOR_W)].specular_reflection = 0.2;\n    materials_table[int(MAT_FLOOR_W)].ambient_reflection  = 0.5;\n    materials_table[int(MAT_FLOOR_W)].shininess           = 1.0;\n\n    materials_table[int(MAT_ORANGE)] = change_color(materials_table[int(MAT_PLASTIC)], ORANGE_RGB );\n    materials_table[int(MAT_RED   )] = change_color(materials_table[int(MAT_PLASTIC)], vec3(1.0,0.0,0.0) );\n    materials_table[int(MAT_GREEN )] = change_color(materials_table[int(MAT_PLASTIC)], vec3(0.0,1.0,0.0) );\n    materials_table[int(MAT_BLUE  )] = change_color(materials_table[int(MAT_PLASTIC)], vec3(0.0,0.0,1.0) );\n    \n    int material_index;\n    col.rgb = render_no_reflections( materials_table, start, dir, max_dist, t, normal, material_index );\n    #if DRAW_ITERATIONS_GRADIENT\n    float it = mod( float(material_index), 10000.0 ),\n          it1 = 0.0;\n    material_index /= 10000;\n    #endif\n    \n#if RENDER_REFLECTIONS\n    pos = start + dir * t;\n    float fe = 0.01;\n    float cn = dot(normal,-dir);\n    float sn = 1.0 - cn*cn;\n    if ( t > 0.0 && ( material_index == int(MAT_FLOOR_W) || material_index == int(MAT_FLOOR_B) ) )\n    {\n        int material_index1;\n        dir1 = reflect(dir,normal);\n        t1 = 0.01;\n        vec3 reflection;\n    \treflection = render_no_reflections( materials_table, pos, dir1, max_dist_reflection, t1, normal1, material_index1 );\n        \n\t    #if DRAW_ITERATIONS_GRADIENT\n    \tit1 = mod( float(material_index1), 10000.0 );\n    \t#else\n        if ( t1 > 0.0 )\n        {\n            t1 += 1.0;\n        \tfloat a = ( sn*sn * 0.9 / t1 );\n        \tcol.rgb = col.rgb * ( 1.0 - a ) + a * reflection;\n        }\n        #endif\n    }\n#endif\n    #if DRAW_ITERATIONS_GRADIENT\n\t   col.rgb = rgb_from_hsv(vec3(float(it+it1)/(float(RAYM_MAX_ITERS) + 33.0),1.0,1.0));\n    #endif\n    \n    // NOTE(theGiallo): gamma correction\n\t// col.rgb = pow( col.rgb, vec3(0.4545) );\n\n    fragColor = vec4(col.rgb,1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ltcSDl.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[883, 883, 910, 910, 974], [975, 975, 1012, 1012, 1106], [1107, 1107, 1137, 1137, 1207], [1208, 1208, 1232, 1232, 1277], [1278, 1278, 1302, 1302, 1353], [1355, 1355, 1381, 1381, 1410], [1411, 1411, 1435, 1435, 1464], [1465, 1465, 1489, 1489, 1518], [1519, 1519, 1545, 1545, 1576], [1577, 1577, 1601, 1601, 1632], [1633, 1633, 1657, 1657, 1688], [1689, 1689, 1715, 1715, 1757], [1758, 1758, 1782, 1782, 1824], [1825, 1825, 1849, 1849, 1891], [1892, 1892, 1918, 1918, 1995], [1996, 1996, 2020, 2020, 2096], [2097, 2097, 2121, 2121, 2197], [2198, 2198, 2222, 2222, 2277], [2278, 2278, 2302, 2302, 2357], [2358, 2358, 2397, 2397, 2435], [2436, 2436, 2475, 2475, 2517], [2519, 2519, 2602, 2602, 2798], [2799, 2799, 2895, 2895, 3322], [3323, 3323, 3438, 3438, 3922], [3924, 3965, 4012, 4012, 4104], [4106, 4106, 4131, 4131, 4201], [4203, 4203, 4229, 4229, 4256], [4258, 4289, 4320, 4320, 4952], [5012, 5012, 5038, 5038, 5080], [5082, 5082, 5108, 5108, 5150], [5152, 5152, 5178, 5178, 5208], [5210, 5210, 5236, 5236, 5266], [5269, 5269, 5297, 5297, 5348], [5349, 5349, 5377, 5377, 5428], [5430, 5430, 5458, 5458, 5509], [5510, 5510, 5538, 5538, 5589], [5590, 5590, 5618, 5618, 5669], [5670, 5670, 5698, 5698, 5749], [5750, 5750, 5778, 5778, 5829], [5830, 5830, 5858, 5858, 5909], [5913, 5913, 5952, 5952, 5972], [5974, 5974, 5993, 5993, 6202], [6204, 6204, 6241, 6241, 6869], [6870, 6870, 6911, 6911, 7551], [7552, 7625, 7669, 7669, 8111], [8113, 8113, 8152, 8152, 8185], [8187, 8187, 8226, 8226, 8261], [8263, 8263, 8304, 8304, 8375], [8377, 8377, 8422, 8422, 8493], [8495, 8495, 8539, 8539, 8628], [8630, 8630, 8686, 8686, 9187], [9188, 9188, 9254, 9254, 9703], [9704, 9704, 9759, 9759, 10227], [10229, 10229, 10289, 10289, 11359], [11361, 11361, 11419, 11419, 11874], [11876, 11917, 11958, 11958, 12051], [12053, 12053, 12109, 12109, 12196], [12198, 12198, 12253, 12253, 12448], [12450, 12450, 12499, 12499, 12562], [12646, 12646, 12692, 12692, 12726], [12728, 12728, 12770, 12770, 12890], [12892, 12892, 12921, 12921, 12946], [12949, 12949, 12983, 12983, 13001], [13003, 13003, 13063, 13063, 13163], [13165, 13229, 13273, 13273, 13350], [13352, 13352, 13396, 13396, 13429], [13431, 13431, 13482, 13482, 13595], [13597, 13597, 13645, 13645, 13724], [13726, 13726, 13765, 13765, 13860], [13862, 13862, 13952, 13952, 14239], [14241, 14374, 14419, 14419, 14511], [14513, 14513, 14558, 14558, 14682], [14684, 14684, 14734, 14734, 14806], [14808, 14808, 14860, 14860, 14937], [14939, 14939, 15002, 15002, 15131], [15133, 15133, 15178, 15178, 15229], [15231, 15231, 15278, 15278, 15313], [15315, 15379, 15425, 15425, 15503], [15505, 15569, 15615, 15615, 15694], [15697, 15697, 15744, 15744, 15779], [15781, 15845, 15891, 15891, 15969], [15971, 16035, 16081, 16081, 16160], [16162, 16162, 16209, 16209, 16247], [16249, 16313, 16359, 16359, 16442], [16444, 16508, 16554, 16554, 16643], [16645, 16645, 16693, 16693, 16728], [16730, 16794, 16841, 16841, 16921], [16923, 16987, 17034, 17034, 17114], [17116, 17180, 17228, 17228, 17315], [17318, 17318, 17370, 17370, 17485], [17487, 17487, 17540, 17540, 17659], [17677, 17677, 17702, 17702, 20994], [20996, 20996, 21041, 21041, 21343], [21345, 21345, 21421, 21421, 21983], [21985, 21985, 22029, 22029, 23121], [23124, 23124, 23178, 23178, 23289], [23291, 23291, 23510, 23510, 24830]], "test": "error"}
{"id": "ltcSRj", "name": "Dynamic Graph", "author": "micantre", "description": "Change the definition of the function at the top of the code to change the visuals", "tags": ["sinecosine"], "likes": 0, "viewed": 89, "published": "Public", "date": "1480736165", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// change this to whatever function you want to graph (e.g. sin, tan, etc.)\n// also try using one of my specual functions I created\n#define FUNC mySpecialSin\n\n//change the thickness of the graph\n#define THICKNESS 0.2\n\n#define NUM_OF_LINES 5\n\n//SPECIAL FUNCTIONS\n\nfloat mySin(float x)\n{\n    return sin((x)*5. + iTime);\n}\n\nfloat myCos(float x)\n{\n    return cos((x)*5. + iTime);\n}\n\nfloat myParabola(float x)\n{\n    return pow(x,2.0) -1.0;\n}\n\nfloat mySqrt(float x)\n{\n    return pow(x,0.5) -1.0;\n}\n\n\nfloat mySpecialSin(float x)\n{\n    return sin(sin((x)*5. + iTime)*5. + iTime);\n}\n\nfloat myRain(float x)\n{\n    return sin(tan((x)*5. + iTime)*50. + iTime);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    uv = uv*2.0 - 1.0; // between -1 and +1\n    uv.x *= iResolution.x / iResolution.y;\n    float xMax = iResolution.x / iResolution.y;\n    \n    vec3 pixel = vec3(0.);\n    \n    float thickness = THICKNESS;\n    \n    \n    if(uv.x > -1.5 && uv.x < 1.5)\n    {\n        pixel = vec3(0.);\n        \n        for(int i = 0; i < NUM_OF_LINES; i++)\n        {\n            // get the y value\n            float yVal = FUNC(uv.x + float(i)*2.0);\n\n            // color within a certain thickness of that y value\n            if(uv.y + thickness/2. > yVal && uv.y - thickness/2. < yVal)\n            {\n                pixel = vec3(sin(iTime + uv.x), cos(iTime+ uv.x), 1.);\n            }\n        }\n    }\n    fragColor = vec4(pixel,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ltcSRj.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[263, 263, 285, 285, 319], [321, 321, 343, 343, 377], [379, 379, 406, 406, 436], [438, 438, 461, 461, 491], [494, 494, 523, 523, 573], [575, 575, 598, 598, 649], [651, 651, 708, 708, 1470]], "test": "valid"}
{"id": "ltcSzs", "name": "Christmas 2016 orbs", "author": "TambakoJaguar", "description": "After a long time without being on Shadertoy, here is my contribution for Christmas 2016!\nMove the view around with the mouse.\nYou can change the number of lamps on line 93.\n\nI had a hard time to give a 2D star form to the orbs!", "tags": ["christmas", "colorful", "stars", "ball", "rotating", "snow", "orbs", "gold", "lamps"], "likes": 15, "viewed": 616, "published": "Public", "date": "1481488226", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/*\n\"Christmas 2016 orbs\" by Emmanuel Keller aka Tambako - December 2016\nLicense Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\nContact: tamby@tambako.ch\n*/\n\n#define pi 3.14159265359\n\n// Switches, you can play with them!\n#define show_gold\n#define gold_bump\n#define specular\n#define star_orbs\n#define orbs_rings\n#define reflections\n#define ss_scatering\n#define show_snow\n\n//#define antialias\n\nstruct Lamp\n{\n  \tvec3 position;\n  \tvec3 color;\n  \tfloat intensity;\n  \tfloat attenuation;\n};\n\nstruct RenderData\n{\n  \tvec3 col;\n  \tvec3 pos;\n  \tvec3 norm;\n  \tint objnr;\n};\n   \n// Every object of the scene has its ID\n#define SKY_OBJ      0\n#define BALL_OBJ     1\n\nLamp lamps[3];\n\n// Campera parameters\nvec3 campos = vec3(0., -0., 10.);\nvec3 camtarget = vec3(0., 0., 0.);\nvec3 camdir = vec3(0., 0., 0.);\nfloat fov = 5.0;\n\n// Ambient light parameters\nconst vec3 ambientColor = vec3(0.5);\nconst float ambientint = 0.05;\n\n// Shading parameters\nconst float ssstrmr = 0.85;\nconst float sssInt = 0.39;\nconst vec3 sssColor = vec3(0.85, 0.92, 1.);\nconst float specint = 0.4;\nconst float specshin = 60.;\n\n// Gold parameters\nconst vec3 goldColor = vec3(1.1, 0.91, 0.52);\nconst vec3 goldColor2 = vec3(1.1, 0.97, 0.68);\nconst vec3 goldColor3 = vec3(1.06, 0.86, 0.55);\nconst float goldRef = 0.99;\nconst float goldTreshold = 0.8;\nconst float goldFrequency = 40.;\nconst float goldBump = 0.013;\n\n// Ball parameters\nconst vec3 ballColor = vec3(1.0, 0.97, 0.94);\nconst float ballRadius = 1.12;\nconst float ballIOR = 2.2;\n\n// Snow parameters\nconst vec3 snowColor = vec3(0.9, 0.95, 1.0);\nconst float snowHeight = 0.44;\nconst float snowHeightDist = 0.12;\nconst float snowPosVar = 0.28;\nconst float snowPosVarFreq = 2.5;\nconst float snowPosPow = 0.27;\nconst float snowThicknessFactor = 0.12;\nconst float snowBumpBig = 0.36;\nconst float snowBumpBigFreq = 3.2;\nconst float snowBumpSmall = 0.011;\nconst float snowBumpSmallFreq = 185.;\n\n// Tracing parameters\nconst float normdelta = 0.001;\nconst float maxdist = 40.;\n\nconst float stLampsInt = 0.55;\n// Rotating lamps parameters\nconst int nbLamps = 16;\nconst float lampsGenInt = 0.5;\nconst float lampsAttenuation = 0.6;\nconst float lampsMinRadius = 1.3;\nconst float lampsMaxRadius = 1.7;\nconst float lampsMinSpeed = 1.0;\nconst float lampsMaxSpeed = 4.7;\nconst float lampsMinIntensity = 0.7; \nconst float lampsMaxIntensity = 1.0;\nconst float lampsMinIntensityVariation = 0.25; \nconst float lampsMaxIntensityVariation = 0.65;\nconst float lampsMinIntensityFrequency = 8.; \nconst float lampsMaxIntensityFrequency = 42.;\n\n// Some parameters of the star of orbs\nconst float starRad = 30000.;\nconst float starRingRad = 0.028;\nconst float starNbBranches = 6.;\nconst float starPow = 3.;\nconst float starStrength = 0.5;\n\n// Antialias. Change from 1 to 2 or more AT YOUR OWN RISK! It may CRASH your browser while compiling!\nconst float aawidth = 0.8;\nconst int aasamples = 2;\n\nvec3 speccol = vec3(0.);\n\nvoid init()\n{\n    lamps[0] = Lamp(vec3(-500., 300., -500.), vec3(0.81, 0.89, 1.), 2.9, 0.001);\n    lamps[1] = Lamp(vec3(150., 400., 200.), vec3(0.74, 0.82, 1.), 2.2, 0.001);\n    lamps[2] = Lamp(vec3(250., -400., 100.), vec3(0.6, 0.73, 1.), 1., 0.001);\n}\n\nvec2 rotateVec(vec2 vect, float angle)\n{\n    vec2 rv;\n    rv.x = vect.x*cos(angle) - vect.y*sin(angle);\n    rv.y = vect.x*sin(angle) + vect.y*cos(angle);\n    return rv;\n}\n\nvec3 hsv2rgb(in vec3 c)\n{\n    vec3 rgb = clamp(abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0);\n\trgb = rgb*rgb*(3.0-2.0*rgb); // cubic smoothing\t\n\n\treturn c.z * mix(vec3(1.0), rgb, c.y);\n}\n\n// 1D hash function\nfloat hash(float n)\n{\n    return fract(sin(n)*753.5453123);\n}\n\n// From https://www.shadertoy.com/view/4sfGzS\nfloat noise(vec3 x)\n{\n    //x.x = mod(x.x, 0.4);\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n\t\n    float n = p.x + p.y*157.0 + 113.0*p.z;\n    return mix(mix(mix(hash(n+  0.0), hash(n+  1.0),f.x),\n                   mix(hash(n+157.0), hash(n+158.0),f.x),f.y),\n               mix(mix(hash(n+113.0), hash(n+114.0),f.x),\n                   mix(hash(n+270.0), hash(n+271.0),f.x),f.y),f.z);\n}\n\nfloat noisePattern(vec3 pos)\n{\n    return noise(normalize(pos)*2.5);\n}\n\nvec3 snowPos(vec3 pos)\n{\n    return pos + snowPosVar*noise(pos*snowPosVarFreq);\n}\n\nfloat snowValue(vec3 pos)\n{\n    #ifdef show_snow\n    return smoothstep(snowHeight - 0.004, snowHeight, snowPos(pos).y);\n    #else\n    return 0.;\n    #endif\n}\n\nfloat snowThickness(vec3 pos)\n{\n    #ifdef show_snow\n    vec3 pos2 = pos + 0.5*noise(pos*snowBumpSmallFreq*1.743);\n    float st = pow(smoothstep(snowHeight, snowHeight + snowHeightDist, snowPos(pos).y), snowPosPow);\n    return st*(1. + snowBumpBig*noise(pos*snowBumpBigFreq))*(1. + snowBumpSmall*noise(pos2*snowBumpSmallFreq));\n    //return st*(1. + snowBumpBig*noise(pos*snowBumpBigFreq));\n    #else\n    return 0.;\n    #endif\n}\n\nfloat goldValue(vec3 pos)\n{\n    #ifdef show_gold\n    vec3 pos2 = pos + 0.1*noise(pos*12.);\n    return (1. - snowValue(pos))*smoothstep(goldTreshold, goldTreshold + 0.01, sin(noisePattern(pos2)*goldFrequency));\n    #else\n    return 0.;\n    #endif\n}\n\nfloat map_ball(vec3 pos)\n{\n    float snow = snowThicknessFactor*snowThickness(pos);\n    float df = length(pos) - ballRadius - snow;\n    \n    #ifdef show_gold\n    #ifdef gold_bump\n    vec3 pos2 = pos + 0.1*noise(pos*12.);\n    df+= goldBump*(1. - snowValue(pos))*smoothstep(goldTreshold + 0.15, goldTreshold + 0.01, sin(noisePattern(pos2)*goldFrequency));\n    #endif\n    #endif\n    \n    return df;\n}\n\nvec2 map(vec3 pos)\n{\n    float ball = map_ball(pos);\n    vec2 res = vec2(ball, BALL_OBJ);\n    \n    return res;\n}\n\n// Main tracing function\nfloat lastDist;\nvec2 trace(vec3 cam, vec3 ray, float maxdist) \n{\n    float t = 0.1;\n    float objnr = 0.;\n    vec3 pos;\n    float dist;\n    \n  \tfor (int i = 0; i < 128; ++i)\n    {\n    \tpos = ray*t + cam;\n        vec2 res = map(pos);\n        dist = res.x;\n        if (dist>maxdist || abs(dist)<0.005)\n            break;\n        t+= dist*0.5;\n        objnr = abs(res.y);\n  \t}\n    lastDist = t;\n  \treturn vec2(t, objnr);\n}\n\nvec3 getNormal(vec3 pos, float e)\n{  \n    vec3 n = vec3(0.0);\n    for( int i=0; i<4; i++ )\n    {\n        vec3 e2 = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);\n        n += e2*map(pos + e*e2).x;\n    }\n    return normalize(n);\n}\n\nvec3 colorRamp3(vec3 col1, vec3 col2, vec3 col3, float v)\n{\n   return mix(mix(col1, col2, smoothstep(0.0, 0.5, v)), col3, smoothstep(0.5, 1.0, v));   \n}\n\n// Gets the color of the sky\nvec3 sky_color(vec3 ray)\n{ \n    //float r = texture(iChannel0, ray).r;\n    ray+= 0.35*noise(ray*6.2);\n    ray+= 0.05*noise(ray*21.5);\n    ray+= 0.02*noise(ray*72.5);\n    float r = 2.*ray.y;\n    vec3 col1 = vec3(0.0, 0.15, 0.35);\n    vec3 col2 = vec3(0.2, 0.3, 0.5);\n    vec3 col3 = vec3(0.5, 0.6, 0.7);\n    return colorRamp3(col1, col2, col3, r);\n}\n\nvec3 getGoldColor(vec3 pos)\n{\n    pos+= 0.4*noise(pos*24.);\n    float t = noise(pos*30.);\n    vec3 col = mix(goldColor, goldColor2, smoothstep(0.55, 0.95, t));\n    col = mix(col, goldColor3, smoothstep(0.45, 0.25, t));\n    return col;\n}\n\nvec3 getBallColor(vec3 pos)\n{\n\tvec3 col1 = mix(ballColor, getGoldColor(pos), pow(goldValue(pos), 4.));\n    return mix(col1, snowColor, snowValue(pos));\n}\n  \n// Combines the colors\nvec3 getColor(vec3 norm, vec3 pos, int objnr, vec3 ray)\n{\n   return objnr==BALL_OBJ?getBallColor(pos):sky_color(ray);\n}\n\n// Fresnel reflectance factor through Schlick's approximation: https://en.wikipedia.org/wiki/Schlick's_approximation\nfloat fresnel(vec3 ray, vec3 norm, float n2)\n{\n   float n1 = 1.; // air\n   float angle = acos(-dot(ray, norm));\n   float r0 = dot((n1-n2)/(n1+n2), (n1-n2)/(n1+n2));\n   float r = r0 + (1. - r0)*pow(1. - cos(angle), 5.);\n   return clamp(r, 0., 0.8);\n}\n\n// Shading of the objects pro lamp\nvec3 lampShading(Lamp lamp, vec3 norm, vec3 pos, vec3 ocol, int objnr, int lampnr)\n{   \n    vec3 pl = normalize(lamp.position - pos);\n    float dlp = distance(lamp.position, pos);\n    vec3 pli = pl/pow(1. + lamp.attenuation*dlp, 2.);\n    float dnp = dot(norm, pli);\n    \n    lamp.intensity*=stLampsInt;\n      \n    // Diffuse shading\n    vec3 col;\n    col = ocol*lamp.color*lamp.intensity*smoothstep(-0.1, 1., dnp); //clamp(dnp, 0., 1.);\n    \n    // Specular shading\n    #ifdef specular\n \n    float specint2 = specint*(1. - snowValue(pos));\n    //if (dot(norm, lamp.position - pos) > 0.0)\n        speccol+= lamp.color*lamp.intensity*specint2*pow(max(0.0, dot(reflect(pl, norm), normalize(pos - campos))), specshin);\n    #endif\n\n \t// Sub surface scattering from https://www.shadertoy.com/view/MdXSzX\n    #ifdef ss_scatering\n    float transmission = map(pos + pl*ssstrmr).x/ssstrmr;\n\tvec3 sssLight = sssColor*lamp.color*smoothstep(0.0,1.0, transmission);\n    float sssInt2 = sssInt*snowValue(pos);\n    col = col*(1. - sssInt2) + sssInt2*sssLight;\n    #endif\n    \n    return col;\n}\n\n// Shading of the objects over all static lamps\nvec3 lampsShading(vec3 norm, vec3 pos, vec3 ocol, int objnr)\n{\n    vec3 col = vec3(0.);\n    for (int l=0; l<3; l++) // lamps.length()\n        col+= lampShading(lamps[l], norm, pos, ocol, objnr, l);\n    \n    return col;\n}\n\nfloat getLampIntensity(int lampNr, float t)\n{\n    float li = lampsMinIntensity + (lampsMaxIntensity - lampsMinIntensity)*hash(float(lampNr*156 + 541));\n    float liv = lampsMinIntensityVariation + (lampsMaxIntensityVariation - lampsMinIntensityVariation)*hash(float(lampNr*674 + 247));\n    float lif = lampsMinIntensityFrequency + (lampsMaxIntensityFrequency - lampsMinIntensityFrequency)*hash(float(lampNr*842 + 617));\n    return lampsGenInt*(li + liv*(sin(t*lif)*0.5 + 0.5));\n}\n\nvec3 getLampColor(int lampNr)\n{\n    float hue = hash(float(lampNr*621 + 127));\n    vec3 hsv = vec3(hue, 1.0, 1.0);\n    return hsv2rgb(hsv);\n}\n\nvec3 getLampPosition(int lampNr, float t)\n{\n    t+= 15.*hash(float(lampNr*541 + 315));\n    float r = lampsMinRadius + (lampsMaxRadius - lampsMinRadius)*hash(float(lampNr*348 + 173));\n    float s = lampsMinSpeed + (lampsMaxSpeed - lampsMinSpeed)*hash(float(lampNr*447 + 914));\n    float a1 = 2.*pi*hash(float(lampNr*519 + 327));\n    float a2 = 2.*pi*hash(float(lampNr*864 + 616));\n    vec3 pos = vec3(0, rotateVec(vec2(r, 0), s*t));\n    pos.xz = rotateVec(pos.xz, a1);\n    pos.xy = rotateVec(pos.xy, a2);\n    return pos;\n}\n\n// Shading of the objects pro lamp\nvec3 lampShading2(float lintensity, vec3 lcolor, vec3 lpos, vec3 norm, vec3 pos, vec3 ocol)\n{   \n    vec3 pl = normalize(lpos - pos);\n    float dlp = distance(lpos, pos);\n    vec3 pli = pl/pow(1. + lampsAttenuation*dlp, 2.);\n    float dnp = dot(norm, pli);\n      \n    // Diffuse shading\n    vec3 col;\n    col = ocol*lcolor*lintensity*smoothstep(-0.1, 1., dnp); //clamp(dnp, 0., 1.);\n    \n    // Specular shading\n    #ifdef specular\n    float specint2 = 1.7*specint*(1. - snowValue(pos));\n    speccol+= lcolor*lintensity*specint2*pow(max(0.0, dot(reflect(pl, norm), normalize(pos - campos))), specshin);\n    #endif\n    \n    return col;\n}\n\n// Shading of the objects over all static lamps\nvec3 lampsShading2(vec3 norm, vec3 pos, vec3 ocol)\n{\n    vec3 col = vec3(0.);\n    float lintensity;\n    vec3 lcolor;\n    vec3 lpos;\n        \n    for (int l=0; l<nbLamps; l++)\n    {\n        lintensity = getLampIntensity(l, iTime);\n        lcolor = getLampColor(l);\n        lpos = getLampPosition(l, iTime);\n        col+= lampShading2(lintensity, lcolor, lpos, norm, pos, ocol);\n    }\n    return col;\n}\n\n// From https://www.shadertoy.com/view/lsSXzD, modified\nvec3 GetCameraRayDir(vec2 vWindow, vec3 vCameraDir, float fov)\n{\n\tvec3 vForward = normalize(vCameraDir);\n\tvec3 vRight = normalize(cross(vec3(0.0, 1.0, 0.0), vForward));\n\tvec3 vUp = normalize(cross(vForward, vRight));\n    \n\tvec3 vDir = normalize(vWindow.x * vRight + vWindow.y * vUp + vForward * fov);\n\n\treturn vDir;\n}\n\nvec3 getFlares(vec3 ray)\n{\n\tvec3 rc = vec3(0.);\n    float lintensity;\n    vec3 lcolor;\n    vec3 lpos;\n    \n    for (int l=0; l<nbLamps; l++)\n    {\n        lintensity = getLampIntensity(l, iTime);\n        lcolor = getLampColor(l);\n        lpos = getLampPosition(l, iTime);    \n        \n        if (distance(campos, lpos)<lastDist)\n        {\n            float lp = pow(max(0.0, dot(ray, normalize(lpos - campos))), 20000.);\n            #ifdef orbs_rings\n            float lp2 = 0.08*smoothstep(starRingRad*0.85, starRingRad, lp)*smoothstep(starRingRad*1.8, starRingRad, lp);\n            #endif\n            \n            #ifdef star_orbs\n            // Complicated stuff to calculate the projection of the lamp position on the image plane\n            // From: http://stackoverflow.com/questions/23472048/projecting-3d-points-to-2d-plane\n            vec3 v3 = (lpos - campos) - dot((lpos - campos), ray) * ray;\n            vec3 vx = vec3(0., 1., 0.);\n            vx = normalize(vx - dot(vx, ray)*ray);\n            //vec3 vy = cross(ray, vx);\n            vec3 vy = vec3(ray.y*vx.z - ray.z*vx.y, ray.z*vx.x - ray.x*vx.z, ray.x*vx.y - ray.y*vx.x);\n            float a = atan(dot(v3, vx)/dot(v3, vy));\n            // Gives the angle a star look\n            float spp = starRad*(1. + starStrength*pow(sin(a*starNbBranches), starPow));\n            lp = pow(max(0.0, dot(ray, normalize(lpos - campos))), spp);\n            #endif\n            \n            #ifdef orbs_rings\n            lp+= lp2;\n            #endif\n            \n            rc+= 5.5*clamp(normalize(mix(lcolor, vec3(1.), 0.55*pow(lp, 1.5)))*lintensity*specint*lp, 0., 1.);\n        }\n    }\n    return rc;\n}\n\n// Sets the position of the camera with the mouse and calculates its direction\nconst float axm = 4.;\nconst float aym = 1.5;\nvoid setCamera()\n{\n   vec2 iMouse2;\n   if (iMouse.x==0. && iMouse.y==0.)\n      iMouse2 = vec2(0.5, 0.5);\n   else\n      iMouse2 = iMouse.xy/iResolution.xy;\n   \n   campos = vec3(8.5, 0., 0.);\n   campos.xy = rotateVec(campos.xy, -iMouse2.y*aym + aym*0.5);\n   campos.yz = rotateVec(campos.yz, -iMouse2.y*aym + aym*0.5);\n   campos.xz = rotateVec(campos.xz, -iMouse2.x*axm);\n\n   camtarget = vec3(0.);\n   camdir = camtarget - campos;   \n}\n\n// Tracing and rendering a ray\nRenderData trace0(vec3 tpos, vec3 ray, float maxdist)\n{\n    vec2 tr = trace(tpos, ray, maxdist);\n    float tx = tr.x;\n    int objnr = int(tr.y);\n    vec3 col;\n    vec3 pos = tpos + tx*ray;\n    vec3 norm;\n    \n    if (tx<maxdist*0.95)\n    {\n        norm = getNormal(pos, normdelta);\n        col = getColor(norm, pos, objnr, ray);\n      \n        // Shading\n        col = ambientColor*ambientint + lampsShading(norm, pos, col, objnr) + lampsShading2(norm, pos, col);\n    }\n    else\n    {\n        objnr = SKY_OBJ;\n        col = vec3(0.);\n    }\n    return RenderData(col, pos, norm, objnr);\n}\n\n// Main render function with reflections and refractions\nvec4 render(vec2 fragCoord)\n{   \n  \tvec2 uv = fragCoord.xy / iResolution.xy; \n  \tuv = uv*2.0 - 1.0;\n  \tuv.x*= iResolution.x / iResolution.y;\n\n    speccol = vec3(0.);\n    \n  \tvec3 ray = GetCameraRayDir(uv, camdir, fov);\n  \tRenderData traceinf = trace0(campos, ray, maxdist);\n  \t//vec3 col = screen(traceinf.col, getFlares(ray);\n    vec3 col = traceinf.col;\n    vec3 refray;\n\n    if (traceinf.objnr==BALL_OBJ)\n    {\t \n        float gv = goldValue(traceinf.pos);\n            \n        #ifdef reflections\n        refray = reflect(ray, traceinf.norm);\n        float rf = fresnel(ray, traceinf.norm, ballIOR)*(1. - snowValue(traceinf.pos)); \n        vec3 colBa = mix(col, sky_color(refray), rf);\n        vec3 goldColor = getGoldColor(traceinf.pos);\n        vec3 colGo = mix(col, goldColor*sky_color(refray), goldRef);\n        col = mix(colBa, colGo, gv);\n        col+= speccol*mix(vec3(1.), goldColor*goldColor, gv);\n        #endif\n    }\n    if (traceinf.objnr==SKY_OBJ)\n    col+= sky_color(ray);\n    col+= getFlares(ray);\n\n  \treturn vec4(col, 1.0);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{   \n    init();\n    setCamera();\n    \n    // Antialiasing.\n    #ifdef antialias\n    vec4 vs = vec4(0.);\n    for (int j=0;j<aasamples ;j++)\n    {\n       float oy = float(j)*aawidth/max(float(aasamples-1), 1.);\n       for (int i=0;i<aasamples ;i++)\n       {\n          float ox = float(i)*aawidth/max(float(aasamples-1), 1.);\n          vs+= render(fragCoord + vec2(ox, oy));\n       }\n    }\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    fragColor = vs/vec4(aasamples*aasamples);\n    #else\n    fragColor = render(fragCoord);\n    #endif\n}", "image_inputs": [{"id": "4sX3zn", "previewfilepath": "/media/ap/0681c014f6c88c356cf9c0394ffe015acc94ec1474924855f45d22c3e70b5785.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/0681c014f6c88c356cf9c0394ffe015acc94ec1474924855f45d22c3e70b5785.png", "ctype": "cubemap"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ltcSzs.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[2931, 2931, 2944, 2944, 3184], [3186, 3186, 3226, 3226, 3356], [3358, 3358, 3383, 3383, 3557], [3559, 3579, 3600, 3600, 3640], [3642, 3688, 3709, 3736, 4101], [4103, 4103, 4133, 4133, 4173], [4175, 4175, 4199, 4199, 4256], [4258, 4258, 4285, 4285, 4415], [4417, 4417, 4448, 4448, 4845], [4847, 4847, 4874, 4874, 5094], [5096, 5096, 5122, 5122, 5493], [5495, 5495, 5515, 5515, 5607], [5650, 5650, 5698, 5698, 6053], [6055, 6055, 6090, 6090, 6293], [6295, 6295, 6354, 6354, 6447], [6449, 6478, 6504, 6548, 6826], [6828, 6828, 6857, 6857, 7064], [7066, 7066, 7095, 7095, 7219], [7223, 7246, 7303, 7303, 7365], [7367, 7484, 7530, 7530, 7733], [7735, 7770, 7854, 7854, 8847], [8849, 8897, 8959, 8959, 9117], [9119, 9119, 9164, 9164, 9598], [9600, 9600, 9631, 9631, 9741], [9743, 9743, 9786, 9786, 10264], [10266, 10301, 10394, 10394, 10937], [10939, 10987, 11039, 11039, 11387], [11389, 11445, 11509, 11509, 11762], [11764, 11764, 11790, 11790, 13421], [13547, 13547, 13565, 13565, 13978], [13980, 14011, 14066, 14066, 14598], [14600, 14657, 14686, 14686, 15701], [15703, 15703, 15758, 15758, 16293]], "test": "error"}
{"id": "ltcXDB", "name": "raymarching - glitching", "author": "generateme", "description": "ray marching errors test", "tags": ["raymarching"], "likes": 0, "viewed": 201, "published": "Public", "date": "1481416280", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// ray marching glitches\n// some parts taken from IQ\n\n#define STEPS 100 // ray marching steps, try 1 - 100\n#define LSTEPS 50 // shadow steps, try 5 - 100\n#define SHADOW_SOFT 4.0 // try 1.0 - 32.0\n#define OCCLUSION_DECAY 0.76 // -0.99 - 0.99\n#define UNION 1 // 1 = union, 0 = subtract\n\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr )\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\nfloat sdSphere( vec3 p, float s ) {\n    return length(p)-s;\n}\n\nfloat sdBox( vec3 p, vec3 b ) {\n  vec3 d = abs(p) - b;\n  return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\nfloat opS( float d1, float d2 ) {\n    return max(-d2,d1);\n}\n\nfloat opU( float d1, float d2 ) {\n    return min(d2,d1);\n}\n\nfloat map(in vec3 p) {\n\tfloat dd =  0.03*(sin(20.0*p.x)*sin(20.0*p.y)*sin(20.0*p.z));\n    vec3 d = p + vec3(dd,dd,dd);\n    float r = 0.0;\n    if(UNION==1) {\n    \tr = opU( sdBox(d, vec3(2.5, 2.5, 2.5)), sdSphere(d, 3.4));\n    } else {\n    \tr = opS( sdBox(d, vec3(2.5, 2.5, 2.5)), sdSphere(d, 3.4));\n    }\n    return min((p.y+1.0),r);\n}\n\n//----------------------------------------------------------------------\nfloat calcAO( in vec3 pos, in vec3 nor )\n{\n\tfloat occ = 0.0;\n    float sca = 1.0;\n    for( int i=0; i<5; i++ )\n    {\n        float hr = 0.01 + 0.3*float(i);\n        vec3 aopos =  nor * hr + pos;\n        float dd = map( aopos );\n        occ += (hr-dd)*sca;\n        sca *= OCCLUSION_DECAY;\n    }\n    return clamp( 1.0 - occ, 0.0, 1.0 );    \n}\n\n\nfloat castRay( in vec3 ro, in vec3 rd )\n{\n    float tmin = 0.001;\n    float tmax = 20.0;\n        \n\tfloat precis = 0.0001;\n    float t = tmin;\n    for( int i=0; i<STEPS; i++ )\n    {\n\t    float res = map( ro+rd*t );\n        if(i==0) res *= 0.3;\n        if( res<precis || t>tmax ) break;\n        t += res;\n    }\n\n   \tif(t>tmax) t=-1.0;\n    return t;\n}\n\n\nfloat softshadow( in vec3 ro, in vec3 rd, in float mint, in float tmax )\n{\n\tfloat res = 1.0;\n    float t = mint;\n    for( int i=0; i<LSTEPS; i++ )\n    {\n\t\tfloat h = map( ro + rd*t );\n        res = min( res, SHADOW_SOFT*h/t );\n        t += h;\n        if( h<0.001 || t>tmax ) break;\n    }\n    return clamp( res, 0.0, 1.0 );\n\n}\n\nvec3 calcNormal( in vec3 pos )\n{\n\tvec3 eps = vec3( 0.01, 0.0, 0.0 );\n\tvec3 nor = vec3(\n\t    map(pos+eps.xyy) - map(pos-eps.xyy),\n\t    map(pos+eps.yxy) - map(pos-eps.yxy),\n\t    map(pos+eps.yyx) - map(pos-eps.yyx) );\n\treturn normalize(nor);\n}\n\n\n\nvec3 render( in vec3 ro, in vec3 rd )\n{ \n    float t = castRay(ro,rd);\n    vec3 col = vec3(0.0,0.0,0.0);\n    \n    if( t>0.0 )\n    {\n        vec3 pos = ro + t*rd;\n        vec3 nor = calcNormal( pos );\n        \n        // material        \n\t\tcol = vec3(0.85,0.80,0.204);\n\n\t\tvec3  lig1 = normalize( vec3(-2.0,1.0,0.0) );\n        vec3  lig2 = normalize( vec3(0.0,4.5,4.0) );\n        \n        float dif1 = dot(nor,lig1);\n        float dif2 = dot(nor,lig2);\n        \n        float sha1 = softshadow( pos, lig1, 0.01, 20.0 );\n        float sha2 = softshadow( pos, lig2, 0.01, 20.0 );\n\n        float dif = 0.5 * (dif1*sha1 + dif2*sha2);\n        \n        float ao = calcAO(pos,nor);\n\t\tcol = col*ao*dif*1.6;\n\n    \tcol = mix( col, vec3(0.91,0.86,0.796), 1.0-exp( -0.001*t*t ) );\n\n    } else col = vec3(0.91,0.86,0.796);\n\n\treturn vec3( clamp(col,0.0,1.0) );\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 q = fragCoord.xy/iResolution.xy;\n    vec2 p = -2.0+4.0*q;\n\tp.x *= iResolution.x/iResolution.y;\n    \n    float st = sin(iTime)*4.0;\n    float ct = cos(iTime)*4.0;\n    vec3 ro = vec3(st,3.5,ct);\n    \n\t// camera-to-world transformation\n    mat3 ca = setCamera( ro, vec3(0.0, 0.0, 0.0), 0.0 );\n    \n    // ray direction\n\tvec3 rd = ca * normalize( vec3(p.xy,1.0) );\n\n    // render\t\n    vec3 col = render( ro, rd );\n\n\tcol = pow( col, vec3(0.8) );\n\n    fragColor=vec4( col, 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ltcXDB.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[285, 285, 337, 337, 514], [516, 516, 551, 551, 577], [579, 579, 610, 610, 697], [699, 699, 732, 732, 758], [760, 760, 793, 793, 818], [820, 820, 842, 842, 1154], [1156, 1229, 1271, 1271, 1569], [1572, 1572, 1613, 1613, 1920], [1923, 1923, 1997, 1997, 2247], [2249, 2249, 2281, 2281, 2489], [2493, 2493, 2532, 2532, 3339], [3342, 3342, 3399, 3399, 3881]], "test": "valid"}
{"id": "ltcXRf", "name": "Exploding Star.", "author": "slembcke", "description": "Hacking on Duke's Dusty Nebula 4: https://www.shadertoy.com/view/MsVXWW\n\nI wanted to experiment with changing the raymarching scheme a bit. Ended up adding a star, and making it more explodey. Might try adding self occlusion next.", "tags": ["nebula"], "likes": 69, "viewed": 1342, "published": "Public", "date": "1480822910", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Hacked up version of https://www.shadertoy.com/view/MsVXWW\n\n\n#define R(p, a) p=cos(a)*p+sin(a)*vec2(p.y, -p.x)\n\n//=====================================\n// otaviogood's noise from https://www.shadertoy.com/view/ld2SzK\n//--------------------------------------------------------------\n// This spiral noise works by successively adding and rotating sin waves while increasing frequency.\n// It should work the same on all computers since it's not based on a hash function like some other noises.\n// It can be much faster than other noise functions if you're ok with some repetition.\nconst float nudge = 0.739513;\t// size of perpendicular vector\nfloat normalizer = 1.0 / sqrt(1.0 + nudge*nudge);\t// pythagorean theorem on that perpendicular to maintain scale\nfloat SpiralNoiseC(vec3 p){\n    float n = 0.0;\t// noise amount\n    float iter = 1.0;\n    for (int i = 0; i < 6; i++){\n        // add sin and cos scaled inverse with the frequency\n        n += -abs(sin(p.y*iter) + cos(p.x*iter)) / iter;\t// abs for a ridged look\n        // rotate by adding perpendicular and scaling down\n        p.xy += vec2(p.y, -p.x) * nudge;\n        p.xy *= normalizer;\n        // rotate on other axis\n        p.xz += vec2(p.z, -p.x) * nudge;\n        p.xz *= normalizer;\n        // increase the frequency\n        iter *= 1.733733;\n    }\n    return n;\n}\n\nfloat SpiralNoise3D(vec3 p){\n    float n = 0.0;\n    float iter = 1.0;\n    for (int i = 0; i < 5; i++){\n        n += (sin(p.y*iter) + cos(p.x*iter)) / iter;\n        p.xz += vec2(p.z, -p.x) * nudge;\n        p.xz *= normalizer;\n        iter *= 1.33733;\n    }\n    return n;\n}\n\nfloat NebulaNoise(vec3 p){\n   float final = p.y + 4.5;\n    final -= SpiralNoiseC(p.xyz); // mid-range noise\n    final += SpiralNoiseC(p.zxy*0.5123 + 100.0)*4.0; // large scale features\n    final -= SpiralNoise3D(p); // more large scale features, but 3d\n\n    return final;\n}\n\nfloat map(vec3 p){\n\tR(p.xz, iTime*0.4);\n    \n    float r = length(p);\n    float star = r + 0.5;\n    float noise = 1.0 + pow(abs(NebulaNoise(p/0.5)*0.5), 1.5);\n    return mix(star, noise, smoothstep(0.45, 1.5, r) - smoothstep(2.0, 3.0, r));\n}\n\nbool RaySphereIntersect(vec3 org, vec3 dir, out float near, out float far){\n\tfloat b = dot(dir, org);\n\tfloat c = dot(org, org) - 8.;\n\tfloat delta = b*b - c;\n\tif(delta < 0.0) return false;\n\tfloat deltasqrt = sqrt(delta);\n\tnear = -b - deltasqrt;\n\tfar = -b + deltasqrt;\n\treturn far > 0.0;\n}\n\nconst vec3 starColor = vec3(1.0, 0.5, 0.25);\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord){\n\t// ro: ray origin\n\t// rd: direction of the ray\n\tvec3 rd = normalize(vec3((gl_FragCoord.xy-0.5*iResolution.xy)/iResolution.y, 1.0));\n\tvec3 ro = vec3(0.0, 0.0, -4.0);\n\t\n    const float rot = 0.01;\n    R(rd.yz, -iMouse.y*rot);\n    R(rd.xz,  iMouse.x*rot);\n    R(ro.yz, -iMouse.y*rot);\n    R(ro.xz,  iMouse.x*rot);\n\t\n    int steps = 0;\n    const int max_steps = 64;\n    const float max_advance = 1.0;\n    \n    float t = 0.0;\n\tvec4 sum = vec4(0.0);\n   \n    float min_dist=0.0, max_dist=0.0;\n    if(RaySphereIntersect(ro, rd, min_dist, max_dist)){\n        float dither = 0.5 - 1.5*texture(iChannel0, fragCoord.xy/256.0).r;\n        t = min_dist + max_advance*dither;\n\n        for(int i = 0; i < max_steps; i++){\n            if(sum.a > 0.95 || t > max_dist) break;\n            \n            vec3 pos = ro + t*rd;\n            float dist = map(pos);\n\t\t\tfloat advance = clamp(0.05*dist, 0.01, max_advance);\n            \n            float density = max(1.2 - dist, 0.0);\n            vec3 emit = starColor*(110.0*advance*density/dot(pos, pos));\n            float block = 1.0 - pow(0.05, density*advance/0.05);\n            sum += (1.0 - sum.a)*vec4(emit, block);\n\n            t += advance;\n            steps = i;\n        }\n\n\t}\n\t\n//    fragColor = vec4(vec3(smoothstep(min_dist, max_dist, t)), 1.0); return;\n//    fragColor = vec4(vec3(sum.a), 1.0); return;\n//    fragColor = vec4(vec3(float(steps)/float(max_steps)), 1.0); return;\n    \n    sum.rgb = pow(sum.rgb, vec3(2.2));\n    sum.rgb = sum.rgb/(1.0 + sum.rgb);\n    fragColor = vec4(sum.xyz,1.0);\n}", "image_inputs": [{"id": "4dXGzn", "previewfilepath": "/media/ap/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "channel": 0, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ltcXRf.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[115, 756, 783, 783, 1327], [1329, 1329, 1357, 1357, 1600], [1602, 1602, 1628, 1628, 1875], [1877, 1877, 1895, 1895, 2118], [2120, 2120, 2195, 2195, 2407], [2456, 2456, 2511, 2559, 4048]], "test": "error"}
{"id": "ltdXD2", "name": "Aidez moi  comprendre", "author": "TromasWideos", "description": "Je sais pas ce que j'ai fait ", "tags": ["nimportequoi"], "likes": 1, "viewed": 69, "published": "Public", "date": "1481724120", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 color, in vec2 pixCoords )\n{\n    color = vec4(1.0 - pixCoords.x/iResolution.x/0.05*sin(iTime), pixCoords.y/iResolution.y/cos(-iTime), pixCoords.x/iResolution.x/cos(-iTime), 1.0);\n    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ltdXD2.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 53, 53, 210]], "test": "valid"}
{"id": "ltdXRl", "name": "First Experiment", "author": "Teurkidosh", "description": "lorem", "tags": ["experiments", "maths"], "likes": 1, "viewed": 270, "published": "Public", "date": "1481723770", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 color, in vec2 pixCoords )\n{\n    const float PI = 3.1415;\n    /*\n\t//France flag\n    if(pixCoords.x < iResolution.x/3.0){\n        color = vec4(0.0,0.0,1.0,0.1);\n    }\n    if(pixCoords.x > iResolution.x/3.0){\n        color = vec4(1.0,1.0,1.0,0.1);\n    }\n    if(pixCoords.x > 2.0*iResolution.x/3.0){\n        color = vec4(1.0,0.0,0.0,0.1);\n    }\n\t*/\n    \n    /*\n    //Japan flag\n    float CentreX = iResolution.x/2.0;\n    float CentreY = iResolution.y/2.0;\n    float x = pixCoords.x - CentreX;\n    float y = pixCoords.y - CentreY;\n    \n    float radius = iResolution.y/4.0;\n    \n    x*=2.0;\n    y*=2.0;\n    \n    x+=cos(iTime*iTime)*radius;\n    y+=sin(iTime*iTime)*radius;\n    \n    \n    \n    color = vec4(1.0,1.0,1.0,0.1);\n    if(sqrt(pow(x,2.0)+pow(y,2.0))<radius){\n        color = vec4(1.0,0.0,0.0,0.1);\n    }\n    */\n\t\n\n    /*\n    //growing circle\n    color = vec4(1.0,1.0,1.0,0.1);\n    if(sqrt(pow(pixCoords.x - iResolution.x/2.0,2.0)+pow(pixCoords.y - iResolution.y/2.0,2.0)) < iTime*10.0){\n        color = vec4(1.0,0.0,0.0,0.1);\n    }\n    */\n    \n    //Nouveau repre\n    float angleRotationCamera = PI/30.0 * sin(iTime);\n    \n    vec2 centreRot = vec2(iResolution.x/2.0, 0.0);\n    \n    vec2 i = vec2(cos(angleRotationCamera),sin(angleRotationCamera));\n    vec2 j = vec2(cos(angleRotationCamera + PI/2.0),sin(angleRotationCamera + PI/2.0));\n    \n    vec2 centreCam = -1.0*centreRot;\n    float x = pixCoords.x - centreRot.x;\n    float y = pixCoords.y - centreRot.y;\n    \n    //dot product : rotation\n    float newX = x*i.x+y*i.y;\n    float newY = x*j.x+y*j.y;\n    x=newX;\n    y=newY;\n    \n    x = x - centreCam.x;\n    y = y - centreCam.y;\n    \n    float decalageY = iResolution.y/7.0;\n    \n    //Sun over blue sea and blue sky\n    float SoleilRadius = iResolution.y/6.0;\n    \n    float centreRotationSoleilX = iResolution.x/2.0;\n    float centreRotationSoleilY = 0.0;\n    float radiusRotationSoleil = iResolution.y - 100.0;\n    float angleRotationSoleil = iTime/7.0;\n    \n    //RotationSoleil\n    float SoleilX = cos(angleRotationSoleil) * radiusRotationSoleil + centreRotationSoleilX;\n    float SoleilY = sin(angleRotationSoleil) * radiusRotationSoleil + centreRotationSoleilY;\n    \n    float coefFiltre = clamp(SoleilY,decalageY,radiusRotationSoleil - centreRotationSoleilY) / (radiusRotationSoleil - centreRotationSoleilY);\n    \n    //Filtre couleur\n    vec4 filtre = vec4(1.0,1.0,1.0,1.0) * coefFiltre;\n    \n    //dessine le ciel\n    color = vec4(0.0,0.5,1.0,0.1) * filtre;\n    \n    //dessine soleil\n    if(sqrt(pow(x - SoleilX,2.0)+pow(y - SoleilY,2.0))<SoleilRadius + 4.0*cos(iTime*1.5)){\n        color = vec4(0.8,0.9,0.0,0.1);\n    }\n    \n    \n    \n    float amplitudeVague = iResolution.y/20.0;\n    float periodeVague = 25.0;\n    \n    //Vagues\n    if(y < cos(x/periodeVague + iTime)*amplitudeVague+decalageY){\n        color = vec4(0.15,0.7,0.6,0.1) * filtre;\n    }\n    if(y < cos(x/periodeVague + iTime*2.0+1.0)*amplitudeVague/1.5+decalageY){\n        color = vec4(0.15,0.65,0.6,0.1) * filtre;\n    }\n    if(y < cos(x/periodeVague + iTime*3.0+2.0)*amplitudeVague/2.0+decalageY){\n        color = vec4(0.15,0.6,0.6,0.1) * filtre;\n    }\n    if(y < cos(x/periodeVague + iTime*4.0+3.0)*amplitudeVague/2.5+decalageY){\n        color = vec4(0.15,0.55,0.6,0.1) * filtre;\n    }\n    \n    //Cloud\n    float centerCloudX = mod(iTime*12.0,iResolution.x+200.0) -50.0;\n    float centerCloudY = iResolution.y * 4.0 / 5.0;\n    float bottomMarginCloud = 25.0;\n    \n    if(sqrt(pow(x - centerCloudX,2.0)+pow(y - centerCloudY,2.0))<35.0 && y > (centerCloudY - bottomMarginCloud)){\n        color = vec4(1.0,1.0,1.0,0.1) * filtre;\n    }\n    if(sqrt(pow(x - (centerCloudX+40.0),2.0)+pow(y - (centerCloudY-10.0),2.0))<20.0 && y > (centerCloudY - bottomMarginCloud)){\n        color = vec4(1.0,1.0,1.0,0.1) * filtre;\n    }\n    if(sqrt(pow(x - (centerCloudX-50.0),2.0)+pow(y - centerCloudY-10.0,2.0))<20.0 && y > (centerCloudY - bottomMarginCloud)){\n        color = vec4(1.0,1.0,1.0,0.1) * filtre;\n    }\n    if(sqrt(pow(x - (centerCloudX-40.0),2.0)+pow(y - (centerCloudY-20.0),2.0))<30.0 && y > (centerCloudY - bottomMarginCloud)){\n        color = vec4(1.0,1.0,1.0,0.1) * filtre;\n    }\n   \t//End Sun over blue sea and blue sky\n\n\n    \n    \n    /*\n    //Creneau\n    float decalage = 100.0;\n    float amplitude = 20.0;\n    \n    float periode = 15.0;\n        \n    float frequence = 1.0/periode;\n    color = vec4(1.0,1.0,1.0,0.1);\n    if(pixCoords.y < (cos(pixCoords.x*frequence)/abs(cos(pixCoords.x*frequence)))*amplitude + decalage){\n        color = vec4(1.0,0.0,0.0,0.1);\n    }\n    */\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ltdXRl.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 53, 53, 4586]], "test": "valid"}
{"id": "ltdXzX", "name": "spiralTime", "author": "tamasaur", "description": "spiral\n", "tags": ["spiral"], "likes": 2, "viewed": 1969, "published": "Public", "date": "1480963487", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI 3.1415926535897932384626433832795\n\nvec4 hsv_to_rgb(float h, float s, float v, float a)\n{\n\tfloat c = v * s;\n\th = mod((h * 6.0), 6.0);\n\tfloat x = c * (1.0 - abs(mod(h, 2.0) - 1.0));\n\tvec4 color;\n \n\tif (0.0 <= h && h < 1.0) {\n\t\tcolor = vec4(c, x, 0.0, a);\n\t} else if (1.0 <= h && h < 2.0) {\n\t\tcolor = vec4(x, c, 0.0, a);\n\t} else if (2.0 <= h && h < 3.0) {\n\t\tcolor = vec4(0.0, c, x, a);\n\t} else if (3.0 <= h && h < 4.0) {\n\t\tcolor = vec4(0.0, x, c, a);\n\t} else if (4.0 <= h && h < 5.0) {\n\t\tcolor = vec4(x, 0.0, c, a);\n\t} else if (5.0 <= h && h < 6.0) {\n\t\tcolor = vec4(c, 0.0, x, a);\n\t} else {\n\t\tcolor = vec4(0.0, 0.0, 0.0, a);\n\t}\n \n\tcolor.rgb += v - c;\n \n\treturn color;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tfloat x = fragCoord.x - (iResolution.x / 2.0);\n\tfloat y = fragCoord.y - (iResolution.y );\n\t\n\tfloat r = length(vec2(x,y));\n\tfloat angle = atan(x,y) - sin(iTime)*r / 200.0 + 1.0*iTime;\n\tfloat intensity = 0.5 + 0.25*sin(15.0*angle);\n\t//float intensity = mod(angle, (PI / 8.0));\n\t//float intensity = 0.5 + 0.25*sin(angle*16.0-5.0*iTime);\n\t\n\tfragColor = hsv_to_rgb(angle/PI, intensity, 1.0, 0.5);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ltdXzX.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[46, 46, 99, 99, 677], [679, 679, 736, 736, 1131]], "test": "valid"}
{"id": "ltKXzz", "name": "New Yerar Tree", "author": "login22876534184820", "description": "741", "tags": ["238"], "likes": 0, "viewed": 393, "published": "Public API", "date": "1482656466", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define RADIUS 0.005\n#define RED vec4(1.0, 0.0, 0.0, 1.0)\n#define SKY_COLOR vec4(0.0, 0.0, 0.2, 1.0)\n#define GROUND_COLOR vec4(0.4, 0.3, 0.2, 1.0)\n#define LIGHT -abs(uv.x-0.5)*1.0-uv.y*0.3\n#define GREEN vec4(0.0, 0.5, 0.0, 1.0)\n#define TREE_MOVE_X -sin(iTime)*0.005\n#define TREE_MOVE_Y -abs(sin(iTime))*0.01\n#define TREE_MOVE vec2(TREE_MOVE_X, TREE_MOVE_Y)\n#define FIRST_TRIANGLE_POSITION vec2(0.4, 0.7)+TREE_MOVE, vec2(0.5, 0.98)+TREE_MOVE, vec2(0.6, 0.7)+TREE_MOVE\n#define SECOND_TRIANGLE_POSITION vec2(0.35, 0.35)+TREE_MOVE, vec2(0.5+TREE_MOVE_X, 0.7+TREE_MOVE_Y*0.5), vec2(0.65, 0.35)+TREE_MOVE\n#define THIRD_TRIANGLE_POS_X vec2(0.325, 0.675)\n#define THIRD_TRIANGLE_POS_Y_LOW 0.05\n#define THIRD_TRIANGLE_POSITION vec2(THIRD_TRIANGLE_POS_X.x, THIRD_TRIANGLE_POS_Y_LOW), vec2(0.5+TREE_MOVE_X, THIRD_TRIANGLE_POS_Y_LOW+0.3+TREE_MOVE_Y*0.5), vec2(THIRD_TRIANGLE_POS_X.y, THIRD_TRIANGLE_POS_Y_LOW)\n#define SHADOW_WIDTH 1.5\n#define TREE_SHADOW uv.y>SHADOW_WIDTH*uv.x+THIRD_TRIANGLE_POS_Y_LOW-SHADOW_WIDTH*THIRD_TRIANGLE_POS_X.y && uv.y>-SHADOW_WIDTH*uv.x+THIRD_TRIANGLE_POS_Y_LOW+SHADOW_WIDTH*THIRD_TRIANGLE_POS_X.x && uv.y>THIRD_TRIANGLE_POS_Y_LOW\n#define SHADOW_DARKNESS 4.0\n#define MOON_POSITION vec2(0.1, 0.9)\n#define MOON_WIDTH 0.012\n#define MOON_LIGHT 0.03-distance(MOON_POSITION,uv)*0.1\n#define TOY_1_POSITION vec2(0.47, 0.85) \n#define TOY_2_POSITION vec2(0.53, 0.77)\n#define TOY_3_POSITION vec2(0.5, 0.64) \n#define TOY_4_POSITION vec2(0.47, 0.53)\n#define TOY_5_POSITION vec2(0.45, 0.73) \n#define TOY_6_POSITION vec2(0.57, 0.43) \n#define TOY_7_POSITION vec2(0.4, 0.4)\n#define TOY_8_POSITION vec2(0.43, 0.2) \n#define TOY_9_POSITION vec2(0.6, 0.15) \n#define TOY_10_POSITION vec2(0.525, 0.25) \n#define DYNAMIC_COLOR_1 vec4(abs(sin(iTime)-uv.x),cos(iTime), abs(tan(iTime)) , 1.0)\n#define DYNAMIC_COLOR_2 vec4(sin(iTime),tan(iTime+uv.y), abs(cos(iTime)) , 1.0)\n#define DYNAMIC_COLOR_3 vec4(cos(iTime),abs(sin(iTime)), tan(iTime) , 1.0)\n#define DYNAMIC_COLOR_4 vec4(cos(iTime-uv.y),tan(iTime), abs(sin(iTime)) , 1.0)\n#define DYNAMIC_COLOR_5 vec4(tan(iTime),cos(iTime), abs(sin(iTime)+uv.x) , 1.0)\n\nfloat sdTriangle( in vec2 p1, in vec2 p2, in vec2 p3, in vec2 p )\n{\n    vec2 e0 = p2 - p1;  vec2 e1 = p3 - p2;  vec2 e2 = p1 - p3;\n\tvec2 v0 = p - p1;   vec2 v1 = p - p2;   vec2 v2 = p - p3;\n\n\tvec2 pq0 = v0 - e0*clamp( dot(v0,e0) / dot(e0,e0), 0.0, 1.0 );\n\tvec2 pq1 = v1 - e1*clamp( dot(v1,e1) / dot(e1,e1), 0.0, 1.0 );\n\tvec2 pq2 = v2 - e2*clamp( dot(v2,e2) / dot(e2,e2), 0.0, 1.0 );\n    \n    vec2 d = min( min( vec2( dot(pq0, pq0), v0.x*e0.y-v0.y*e0.x ),\n                       vec2( dot(pq1, pq1), v1.x*e1.y-v1.y*e1.x )),\n                       vec2( dot(pq2, pq2), v2.x*e2.y-v2.y*e2.x ));\n\n\treturn -sqrt(d.x)*sign(d.y);\n}\n\nfloat drawCircle(vec2 center, float radius, vec2 p)\n{\n    return 1.0 - smoothstep(0.0, radius, length(p-center));\n}\n\nfloat getDrobPart(float a)\n{\n    return a-float(int(a));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    \n    /// Sky and ground\n\tif(uv.y>0.3)\n        fragColor = SKY_COLOR+MOON_LIGHT;\n    else\n       \tif(TREE_SHADOW)\n            fragColor = GROUND_COLOR+LIGHT*SHADOW_DARKNESS;\n        else\n        \tfragColor = GROUND_COLOR+LIGHT;\n\n    /// Moon\n    if(drawCircle(MOON_POSITION, 0.05, uv)>0.0)\n    \tfragColor = vec4(1.0, 1.0, 0.0, 1.0);\n    if(drawCircle(vec2(MOON_POSITION.x-MOON_WIDTH, MOON_POSITION.y), 0.05, uv)>0.0)\n    \tfragColor = SKY_COLOR+MOON_LIGHT;\n    \n    /// Snowballs back (bidlokod)\n    if(drawCircle(vec2(0.1+0.12*cos(iTime), 1.0-getDrobPart(iTime+0.1)), RADIUS, uv)>0.0&& uv.y>0.12)\n    \tfragColor = vec4(1.0, 1.0, 1.0, 1.0)+LIGHT;\n    if(drawCircle(vec2(0.2+0.13*cos(iTime), 1.0-getDrobPart(iTime-0.2)), RADIUS, uv)>0.0 && uv.y>0.05)\n    \tfragColor = vec4(1.0, 1.0, 1.0, 1.0)+LIGHT;\n    if(drawCircle(vec2(0.4+0.2*cos(iTime), 1.0-getDrobPart(iTime+0.3)), RADIUS, uv)>0.0&& uv.y>0.1)\n    \tfragColor = vec4(1.0, 1.0, 1.0, 1.0)+LIGHT;\n    if(drawCircle(vec2(0.45+0.16*cos(iTime), 1.0-getDrobPart(iTime-0.5)), RADIUS, uv)>0.0&& uv.y>0.05)\n    \tfragColor = vec4(1.0, 1.0, 1.0, 1.0)+LIGHT;\n    if(drawCircle(vec2(0.6+0.17*cos(iTime), 1.0-getDrobPart(iTime+0.4)), RADIUS, uv)>0.0&& uv.y>0.06)\n    \tfragColor = vec4(1.0, 1.0, 1.0, 1.0)+LIGHT;\n    if(drawCircle(vec2(0.75+0.12*cos(iTime), 1.0-getDrobPart(iTime-0.1)), RADIUS, uv)>0.0&& uv.y>0.07)\n    \tfragColor = vec4(1.0, 1.0, 1.0, 1.0)+LIGHT;\n    if(drawCircle(vec2(0.21+0.11*cos(iTime), 1.0-getDrobPart(iTime+0.3)), RADIUS, uv)>0.0&& uv.y>0.08)\n    \tfragColor = vec4(1.0, 1.0, 1.0, 1.0)+LIGHT;\n        \n\t/// Tree\n    if(sdTriangle(FIRST_TRIANGLE_POSITION, uv)<=0.0 ||sdTriangle(SECOND_TRIANGLE_POSITION,uv)<=0.0 || sdTriangle(THIRD_TRIANGLE_POSITION,uv)<=0.0)\n        fragColor = GREEN+LIGHT;\n        \n   \t/// Toys\n    if(drawCircle(TOY_1_POSITION+TREE_MOVE, RADIUS, uv)>0.0 || drawCircle(TOY_10_POSITION+TREE_MOVE, RADIUS, uv)>0.0)\n        fragColor = DYNAMIC_COLOR_1;\n    if(drawCircle(TOY_3_POSITION+TREE_MOVE, RADIUS, uv)>0.0 || drawCircle(TOY_8_POSITION+TREE_MOVE, RADIUS, uv)>0.0)\n        fragColor = DYNAMIC_COLOR_2;\n    if(drawCircle(TOY_5_POSITION+TREE_MOVE, RADIUS, uv)>0.0 || drawCircle(TOY_6_POSITION+TREE_MOVE, RADIUS, uv)>0.0)\n        fragColor = DYNAMIC_COLOR_3;\n    if(drawCircle(TOY_7_POSITION+TREE_MOVE, RADIUS, uv)>0.0 || drawCircle(TOY_4_POSITION+TREE_MOVE, RADIUS, uv)>0.0)\n        fragColor = DYNAMIC_COLOR_4;\n    if(drawCircle(TOY_9_POSITION+TREE_MOVE, RADIUS, uv)>0.0 || drawCircle(TOY_2_POSITION+TREE_MOVE, RADIUS, uv)>0.0)\n        fragColor = DYNAMIC_COLOR_5;    \n        \n    /// Snowballs front (bidlokod)\n    if(drawCircle(vec2(0.35+0.09*sin(iTime), 1.0-getDrobPart(iTime+0.4)), RADIUS, uv)>0.0)\n    \tfragColor = vec4(1.0, 1.0, 1.0, 1.0);\n    if(drawCircle(vec2(0.73+0.2*sin(iTime), 1.0-getDrobPart(iTime-0.1)), RADIUS, uv)>0.0)\n    \tfragColor = vec4(1.0, 1.0, 1.0, 1.0);\n    if(drawCircle(vec2(0.45+0.11*sin(iTime), 1.0-getDrobPart(iTime+0.3)), RADIUS, uv)>0.0)\n    \tfragColor = vec4(1.0, 1.0, 1.0, 1.0);\n   \t\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ltKXzz.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[2097, 2097, 2164, 2164, 2720], [2722, 2722, 2775, 2775, 2837], [2839, 2839, 2867, 2867, 2897], [2899, 2899, 2956, 2956, 6006]], "test": "valid"}
{"id": "lttSzX", "name": "quaternion julia set", "author": "MacSlow", "description": "I needed to reach the next level, after being at ShaderToy for a year now. Doing a 4D/quaternion julia-set ray-marcher seemed fitting. Pretty intense math... uff! Happy with the result so far. The mouse moves the camera.\nhttp://blog.macslow.org/?p=161", "tags": ["fractal", "julia", "4d", "quaternion"], "likes": 13, "viewed": 957, "published": "Public API", "date": "1480971401", "time_retrieved": "2021-10-01T00:00:00", "image_code": "////////////////////////////////////////////////////////////////////////////////\n//\n// 4D/quaternion raymarching-renderer for julia-sets\n//\n// Copyright 2016 Mirco Mller\n//\n// Author(s):\n//   Mirco \"MacSlow\" Mller <macslow@gmail.com>\n//\n// This program is free software: you can redistribute it and/or modify it\n// under the terms of the GNU General Public License version 3, as published\n// by the Free Software Foundation.\n//\n// This program is distributed in the hope that it will be useful, but\n// WITHOUT ANY WARRANTY; without even the implied warranties of\n// MERCHANTABILITY, SATISFACTORY QUALITY, or FITNESS FOR A PARTICULAR\n// PURPOSE.  See the GNU General Public License for more details.\n//\n// You should have received a copy of the GNU General Public License along\n// with this program.  If not, see <http://www.gnu.org/licenses/>.\n//\n////////////////////////////////////////////////////////////////////////////////\n\n////////////////////////////////////////////////////////////////////////////////\n//\n// I never thought I'd get to this level, when I joined ShaderToy last year.\n// But reading, trying, failing and trying again (and standing on the shoulders\n// of giants like iq and others) helped me get the grip on many aspects of\n// computer graphics, I always wanted to touch and implement myself, but never\n// dared until recently... so this shader is also to be understood as a small\n// hommage to the demo-scene community as a whole... thanks folks!\n//\n////////////////////////////////////////////////////////////////////////////////\n\n// go and play with the components of c at line 187 to look at other julia-sets\n\n#define ESCAPE_DISTANCE   10.\n#define BOUNDING_DOMAIN_SIZE  3.\n#define VICINITY           .00001 \n#define MAX_ITERATIONS     9\n#define INTERSECTION_DEPTH 96\n#define EPSILON            .003\n#define SHADOWS            true\n\nvec4 qMult (vec4 q1, vec4 q2)\n{\n\tvec4 r;\n\n    r.x   = q1.x * q2.x - dot (q1.yzw, q2.yzw);\n\tr.yzw = q1.x * q2.yzw + q2.x * q1.yzw + cross (q1.yzw, q2.yzw);\n\n    return r;\n}\n\nvec4 qSquare (vec4 q)\n{\n\tvec4 r;\n\n    r.x   = q.x*q.x - dot (q.yzw, q.yzw);\n\tr.yzw = 2.*q.x*q.yzw;\n\n    return r;\n}\n\nvoid iterateIntersect (inout vec4 q,\n                       inout vec4 qp,\n                       vec4 c)\n{\n    for (int i = 0; i < MAX_ITERATIONS; i++) {\n\t    qp = 2.0 * qMult (q, qp);\n    \tq = qSquare (q) + c;\n    \tif (dot (q, q) > ESCAPE_DISTANCE) {\n            break;\n        }\n    }\n}\n\nvec3 normal (vec3 p, vec4 c)\n{\n\tvec3 N;\n    vec4 qP = vec4 (p, .0);\n\tfloat gradX;\n    float gradY;\n    float gradZ;\n\tvec4 gx1 = qP - vec4 (VICINITY, .0, .0, .0);\n\tvec4 gx2 = qP + vec4 (VICINITY, .0, .0, .0);\n    vec4 gy1 = qP - vec4 (.0, VICINITY, .0, .0);\n    vec4 gy2 = qP + vec4 (.0, VICINITY, .0, .0);\n    vec4 gz1 = qP - vec4 (.0, .0, VICINITY, .0);\n    vec4 gz2 = qP + vec4 (.0, .0, VICINITY, .0);\n\n    for (int i = 0; i < MAX_ITERATIONS; i++) {\n\t\tgx1 = qSquare (gx1) + c;\n\t\tgx2 = qSquare (gx2) + c;\n\t\tgy1 = qSquare (gy1) + c;\n\t\tgy2 = qSquare (gy2) + c;\n\t\tgz1 = qSquare (gz1) + c;\n\t\tgz2 = qSquare (gz2) + c;\n\t}\n\n\tgradX = length (gx2) - length (gx1);\n\tgradY = length (gy2) - length (gy1);\n\tgradZ = length (gz2) - length (gz1);\n\tN = normalize (vec3 (gradX, gradY, gradZ));\n\treturn N;\n}\n\nfloat intersectQJulia (inout vec3 rO,\n                       inout vec3 rD,\n                       vec4 c,\n                       float epsilon)\n{\n\tfloat dist;\n    float dummy = .0;\n    for (int i = 0; i < INTERSECTION_DEPTH; ++i)\n\t{\n\t\tvec4 z = vec4 (rO, .0);\n\t\tvec4 zp = vec4 (1., .0, .0, .0);\n\t\titerateIntersect (z, zp, c);\n\n\t\tfloat normZ = length (z);\n\t\tdist = .5 * normZ * log (normZ) / length (zp);\n\t\trO += rD * dist;\n        if (dist < epsilon || dot (rO, rO) > BOUNDING_DOMAIN_SIZE) {\n\t        break;\n        }\n\t}\n\n\treturn dist;\n}\n\nvec3 shade (vec3 light, vec3 eye, vec3 pt, vec3 N)\n{\n\tvec3 diffuse = vec3 (1., .45, .25);\n\tconst float specularExponent = 10.;\n\tconst float specularity = .45;\n\tvec3 L = normalize (light - pt);\n    vec3 E = normalize (eye - pt);\n\tfloat NdotL = dot (N, L);\n\tvec3 R = L - 2. * NdotL * N;\n\tdiffuse += abs (N) * .3;\n\n    return diffuse * max (NdotL, .0) + specularity * pow (max (dot (E,R),.0), specularExponent);\n}\n\nvec3 intersectSphere (vec3 rO, vec3 rD)\n{\n\tfloat B, C, d, t0, t1, t;\n\tB = 2. * dot (rO, rD);\n\tC = dot (rO, rO) - BOUNDING_DOMAIN_SIZE;\n\td = sqrt (B * B - 4. * C);\n\tt0 = (-B + d) * .5;\n\tt1 = (-B - d) * .5;\n\tt = min (t0, t1);\n\trO += t * rD;\n\treturn rO;\n}\n\nmat3 camera (vec3 ro, vec3 target, float cr)\n{\n    vec3 cw = normalize (target - ro);\n    vec3 cp = vec3 (sin (cr), cos (cr), .0);\n    vec3 cu = normalize (cross (cw, cp));\n    vec3 cv = normalize (cross (cu, cw));\n    return mat3 (cu, cv, cw);\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uvRaw = fragCoord.xy / iResolution.xy;\n    vec2 uv = uvRaw;\n    uv = uv * 2. - 1.;\n    uv *= vec2 (iResolution.x / iResolution.y, 1.);\n    uvRaw *= (iResolution.x / iResolution.y, 1.);\n\n    vec2 mouse = iMouse.xy / iResolution.xy;\n    vec3 eye = vec3 (.5 + 3.5 * cos (6. * mouse.x),\n                     -2. + 4. * sin (mouse.y),\n                     .5 + 3.5 * sin (6. * mouse.x));\n    vec3 aim = vec3 (.0, .0, .0);\n    mat3 ca = camera (eye, aim, .0);\n    float u = ((fragCoord.x / iResolution.x) * 2. - 1.) * (iResolution.x / iResolution.y);\n    float v = ((fragCoord.y /iResolution.y)* 2. - 1.);\n    vec3 rO = eye;\n    vec3 rD = normalize (ca * vec3 (u, -v, 2.));\n\n    // play with these components to select 3D-slices through the 4D julia-set\n    vec4 c = vec4 (-.2, .6, .5 * cos (iTime), .125 * sin (iTime));\n    //vec4 c = vec4 (-.137, -.63, -.475, -.046);\n\t//vec4 c = vec4 (-.125, -.256, .847, .0895);\n    //vec4 c = vec4 (-.445, .339, -.0889, -.562);\n    \n    vec3 light1 = vec3 (cos (iTime) * 2., 12., sin (iTime) * 15.);\n    vec3 light2 = vec3 (cos (iTime) * (-3.), -6., sin (iTime) * (-10.));\n\tconst vec4 backgroundColor = vec4 (.3, .3, .3, .0);\n\tvec4 color;\n\n    color = backgroundColor;\n\n    rD = normalize (rD);\n\trO = intersectSphere (rO, rD);\n\n    float dist = intersectQJulia (rO, rD, c, EPSILON);\n\tif(dist < EPSILON) {\n\t\tvec3 N = normal (rO, c);\n\t\tcolor.rgb = shade (light1, rD, rO, N);\n\t\tcolor.rgb += shade (light2, rD, rO, N);\n\t\tcolor.a = 1.;\n\t\tif (SHADOWS) {\n\t\t\tvec3 L = normalize (light1 - rO);\n\t\t\trO += N * EPSILON * 2.;\n\t\t\tdist = intersectQJulia (rO, L, c, EPSILON);\n            if (dist < EPSILON) {\n\t\t\t\tcolor.rgb *= .4;\n            }\n\t\t}\n\t}\n\n    // gamma-correction, tint, vingette\n    color.rgb = .2 * color.rgb + .8 * sqrt (color.rgb);\n    color.rgb *= vec3 (.9, .8, .7);\n    color.rgb *= .2 + .8 * pow (16. * uvRaw.x * uvRaw.y * (1. - uvRaw.x) * (1. - uvRaw.y), .3);\n\n\tfragColor = color;\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/lttSzX.jpg", "access": "shaders20k", "license": "gpl-3.0", "functions": [[1861, 1861, 1892, 1892, 2032], [2034, 2034, 2057, 2057, 2149], [2151, 2151, 2258, 2258, 2440], [2442, 2442, 2472, 2472, 3231], [3233, 3233, 3379, 3379, 3770], [3772, 3772, 3824, 3824, 4182], [4184, 4184, 4225, 4225, 4436], [4438, 4438, 4484, 4484, 4684], [4686, 4686, 4742, 4742, 6670]], "test": "valid"}
{"id": "lttXRj", "name": "Raymarching Christmas Tree ", "author": "micantre", "description": "Overlapping sets of spheres produced using some primitive ray marching in order to promote the holiday spirit.  Merry Christmas!", "tags": ["christmastreelightssnow"], "likes": 7, "viewed": 348, "published": "Public", "date": "1481409641", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define SNOW_INTENSITY .05\n#define SNOW_FALL_SPEED 1.0\n\nfloat map(vec3 p, float time)\n{\n    vec3 q = fract(p) * 2.0 - 1.0;\n    \n    // length of the point minus the radius of the sphere...\n    float radius = 0.25;\n    \n    // spheres get bigger and smaller depending on time\n    radius = (sin(time)*.05 + .1);\n    \n    return length(q) - radius;  //0.25;\n}\n\nfloat trace(vec3 origin, vec3 ray, float time)\n{\n    float t = 0.0;\n    for(int i = 0; i < 32; i++)\n    {\n        vec3 p = origin + ray*t;\n        float d = map(p, time);\n        t+= d * 0.5;\n    }\n    return t;\n}\n\nfloat snowMap(vec3 p)\n{\n    vec3 q = fract(p) * 2.0 - 1.0;\n    \n    // length of the point minus the radius of the sphere...\n    float radius = 0.25;\n    \n    // spheres get bigger and smaller depending on time\n    radius = SNOW_INTENSITY;\n\n    return length(q) - radius;  //0.25;\n}\n\nfloat snowTrace(vec3 origin, vec3 ray)\n{\n    float t = 0.0;\n    for(int i = 0; i < 32; i++)\n    {\n        vec3 p = origin + ray*t;\n        float d = snowMap(p);\n        t+= d * 0.5;\n    }\n    return t;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    uv = uv*2.0 - 1.0; // between -1 and +1\n    \n    uv.x *= iResolution.x / iResolution.y;\n    \n    vec3 ray = normalize(vec3(uv, 1.0));\n        \n    vec3 origin = vec3(0., 0.7, 0.); // camera location\n    \n    // GREEN LIGHTS\n    // rotation\n    float the = .7;\n    ray.xz *= mat2(cos(the), -sin(the), sin(the), cos(the));\n\n    float t = trace(origin, ray, iTime);\n    \n    float fog1 = 1.0/ (1. + t*t*0.1);\n    \n    // RED LIGHTS\n    // rotation\n    the = .2;\n    ray.xz *= mat2(cos(the), -sin(the), sin(the), cos(the));\n    origin = vec3(0., 0.4, 0.);\n\n    t = trace(origin, ray, iTime + 1.5);\n    \n    float fog2 = 1.0/ (1. + t*t*0.1);\n    \n    // BLUE LIGHTS\n    // rotation\n    the = .4;\n    ray.xz *= mat2(cos(the), -sin(the), sin(the), cos(the));\n\torigin = vec3(0., 0.2, 0.);\n    \n    t = trace(origin, ray, iTime + 3.5);\n    \n    float fog3 = 1.0/ (1. + t*t*0.1);\n    \n    \n    // combine all of the colors\n    vec3 fc = vec3(fog2, fog1,fog3);\n    if(uv.y > 1. - 2.5*uv.x || uv.y > 1. + 2.5*uv.x)\n    {\n        fc = vec3(0.);\n    }\n    \n    // now let's do the 2 snow things\n    uv = fragCoord.xy / iResolution.xy;\n    uv = uv*2.0 - 1.0; // between -1 and +1\n    uv.x *= iResolution.x / iResolution.y;\n    \n    //snow 1\n    ray = normalize(vec3(uv, 1.0));\n    \n    the = 1.0;\n    ray.xz *= mat2(cos(the), -sin(the), sin(the), cos(the));\n    \n    origin = vec3(0., iTime*.75*SNOW_FALL_SPEED, iTime*.75*SNOW_FALL_SPEED); // camera location\n    \n    t = snowTrace(origin, ray);\n    \n    float fogSnow1 = 1.0/ (1. + t*t*0.1);\n    \n    //snow 2\n    ray = normalize(vec3(uv, 1.0));\n    \n    the = -2.0;\n    ray.xz *= mat2(cos(the), -sin(the), sin(the), cos(the));\n    \n    origin = vec3(0., iTime*0.5*SNOW_FALL_SPEED, iTime*0.5*SNOW_FALL_SPEED); // camera location\n    \n    t = snowTrace(origin, ray);\n    \n    float fogSnow2 = 1.0/ (1. + t*t*0.1);\n    \n    \n    \n    vec3 snowFogColor = vec3(fogSnow1) + vec3(fogSnow2);\n    \n    \n    fc += snowFogColor;\n    \n    \n    \n    \n    fragColor = vec4(fc,1.0);\n}", "image_inputs": [{"id": "ldB3DD", "previewfilepath": "https://soundcloud.com/underthechristmastree/bing-crosby-its-beginning-to", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "https://soundcloud.com/underthechristmastree/bing-crosby-its-beginning-to", "ctype": "musicstream"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/lttXRj.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[56, 56, 87, 87, 356], [358, 358, 406, 406, 571], [573, 573, 596, 596, 855], [857, 857, 897, 897, 1060], [1063, 1063, 1120, 1120, 3176]], "test": "valid"}
{"id": "lttXzj", "name": "2D Fractal : 1 / z^2", "author": "aiekick", "description": "hwo i can smooth iterations ? i have applied the smooth itertation tech, but maybe im wrong, because i not see the smooth here..:)", "tags": ["2dfractal"], "likes": 1, "viewed": 378, "published": "Public API", "date": "1480680804", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// z * z\nvec2 zmul(vec2 a, vec2 b)\n{\n\treturn vec2(a.x*b.x-a.y*b.y, a.x*b.y+b.x*a.y);\n}\n\n// 1 / z\nvec2 zinv(vec2 a)\n{\n\treturn vec2(a.x, -a.y) / dot(a,a);\n}\n\n// z^n ( n : 1 to 100 )\nvec2 zpow(vec2 a, int n)\n{\n\tvec2 res = a;\n\tfor (int k=1;k<100;k++)\n\t{\tif (k>n-1) break;\n\t\tres = zmul(res, a);\t}\n\treturn res;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 g = fragCoord.xy;\n    \n\tvec2 si = iResolution.xy;\n    \n\tvec2 uv = (g+g-si)/min(si.x,si.y) * 1.2;\n    \n\tvec2 v = vec2(490., 150. + 15. * sin(iTime*0.25));\n\t\n\tvec2 z = uv + vec2(0);\n\t\n\tvec2 c = (v*2.-vec2(900,300))/150.;\n\t\n\tfloat it = 0.;\n\tfloat d = 0.;\n\tfor (int i=0;i<100;i++)\n\t{\n\t\tif (dot(z,z) > 4.) break;\n\t\tz = zinv( zpow(z, 2)) + c;\n\t\tit++;\n\t}\n    \n    // from iq code, but here i have not the smooth ieteration display... but why, and how i can smooth ?\n\tfloat sit = it - log2(log2(dot(z,z)))/log(4.) + 4.;\n    fragColor = 0.5 + 0.5 * cos( 2.88 + sit*0.2 + vec4(.3,1,0,1));\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/lttXzj.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 9, 36, 36, 86], [88, 97, 116, 116, 154], [156, 180, 206, 206, 306], [308, 308, 365, 365, 952]], "test": "valid"}
{"id": "ltVSRh", "name": "Mandel Universe", "author": "TomCat", "description": "Classic fractal zoomer with nice targets - my first shadertoy :)\nyou can see this here with more precision: https://youtu.be/lOXka6aarbQ", "tags": ["2d", "fractal", "mandelbrot"], "likes": 3, "viewed": 246, "published": "Public", "date": "1482971183", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Classic fractal zoomer with nice targets - by TomCat/Abaddon\n// not enough precision here :-(\n// you can see this with more precision: https://youtu.be/lOXka6aarbQ\n\n#define maxiter 92.0\n#define next 100.0\n#define Scale 0.875\n#define speed 6.0\n#define PI2 6.28318\n#define is 0.015\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float time = mod( speed*iTime,next*5.0 );\n    vec2 a = vec2( 0.34390699597256746411,-0.70062002023500613567 );\n    if( time>next )\n    {\n    \ttime = time-next;\n    \ta = vec2( -1.25764648790205013639,0.11831488894193964434 );\n    }\n    if( time>next )\n    {\n    \ttime = time-next;\n    \ta = vec2( -0.93789936639955584496,0.31736094066985742756 );\n    }\n    if( time>next )\n    {\n    \ttime = time-next;\n    \ta = vec2( -0.72568075954437072372,-0.27254962894836931575 );\n    }\n    if( time>next )\n    {\n    \ttime = time-next;\n    \ta = vec2( -0.15713601278801156424,-1.10494558202452419770 );\n    }\n    if( time>maxiter ) time = maxiter;\n\n    float zoom = is * pow( Scale,time );\n    vec2 c = a.xy - zoom*( iResolution.xy*0.5 - fragCoord.xy );\n    \n    float iter = 0.;\n    vec2 z = vec2( 0.,0. );\n    vec2 z2 = vec2( 0.,0. );\n    for( float i=0.; i<maxiter; i++ )\n    {\n\t\tz = vec2( z2.x-z2.y+c.x,2.0*z.x*z.y+c.y );\n        z2 = vec2( z.x*z.x,z.y*z.y );\n\t\tif( (z2.x+z2.y)>(4.0) ) break;\n        iter++;\n//\tif( iter>time ) break;\n    }\n\tfloat col = iter/maxiter;\n    vec3 pal = 0.5 + 0.5 * vec3( cos(PI2*(4.*col+.67)),cos(PI2*(2.*col+.33)),cos(PI2*(1.*col+.00)) );\n    if( iter>=time ) pal = vec3( 0.,0.,0. );\n    fragColor = vec4( pal,1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ltVSRh.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[284, 284, 341, 341, 1583]], "test": "valid"}
{"id": "ltVSRz", "name": "hhhzzzsss 3D Complex Grapher", "author": "hhhzzzsss", "description": "This graphs complex functions.\nImagine a complex plane along the x and z axis\nThen, you put each point through a complex function ( (x+yi)^(x+yi) in this case )\nThe y value of each point is set to the magnitude of the resulting complex number.", "tags": ["graphing"], "likes": 0, "viewed": 100, "published": "Public", "date": "1482605078", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI 3.1415926535897932384626433832795\n#define E 2.7182818284590452353602874713527\nfloat fardist = 12.0;\n\nfloat atan2(vec2 vec) {\n    if (vec.x == 0.0){\n        if (vec.y < 0.0) return 0.0;\n        else return PI;\n    }\n    return atan(vec.y,vec.x);\n}\n\nvec2 cmplxMUL(vec2 a, vec2 b) {\n    return vec2(a.x*b.x-a.y*b.y,a.x*b.y+b.x*a.y);\n}\n\nvec2 cmplxPOW(vec2 a, vec2 b) {\n    float arg = atan2(a);\n    float mag = pow(a.x*a.x + a.y*a.y, b.x/2.0)*pow(E,-b.y*arg);\n    float angle = b.x*arg+0.5*b.y*log(a.x*a.x + a.y*a.y);\n    return vec2(mag*cos(angle),mag*sin(angle));\n}\n\nvec2 func(vec2 xy) {\n    vec2 cmplxnum = cmplxPOW(xy,xy);//cmplxMUL(xy,xy)-1.7*xy+vec2(0.8,1.3);\n    return vec2(length(cmplxnum),4.0+0.5*atan2(cmplxnum));\n}\n\nvec2 map(vec3 p) {\n    vec2 f1 = func(p.xz);\n    vec2 d1 = vec2(abs(p.y-f1.x), f1.y);\n    return d1;\n}\n\nvec2 trace(vec3 ro, vec3 rd) {\n    float t = 0.0;\n    for (int i = 0; i < 20000; i++) {\n        if (t>fardist) break;\n        vec2 h = map(ro+t*rd);\n        if (h.x < 0.0001) return vec2(t, h.y);\n        t += 0.05*h.x;\n    }\n    return vec2(0.0);\n}\n\nvec3 surfaceNormal(vec3 p) {\n    vec2 e = vec2(0.0001,0.0);\n    vec3 n;\n    n.x = map(p+e.xyy).x - map(p-e.xyy).x;\n    n.y = map(p+e.yxy).x - map(p-e.yxy).x;\n    n.z = map(p+e.yyx).x - map(p-e.yyx).x;\n    return normalize(n);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = (2.0*fragCoord.xy / iResolution.xy-1.0)*vec2(iResolution.x/iResolution.y,1.0);\n    \n    float theta = iTime/5.0;\n    \n    vec3 ro = vec3(3.0*sin(-theta),3.0,-3.0*cos(-theta));\n    vec3 rd = normalize(vec3(uv,1.5));\n    float dTheta = -0.5;\n    mat2 dmat = mat2(cos(dTheta),sin(dTheta),-sin(dTheta),cos(dTheta));\n    mat2 rmat = mat2(cos(theta),sin(theta),-sin(theta),cos(theta));\n    rd.yz *= dmat;\n    rd.xz *= rmat;\n    \n    vec2 t = trace(ro, rd);\n    \n    vec3 col = vec3(0.8);\n    \n    if (t.y > 0.0) {\n        \n        col = vec3(0.2,cos(t.y),sin(t.y));\n        \n        vec3 pos = ro + t.x*rd;\n        vec3 nor = surfaceNormal(pos);\n        vec3 lig = normalize(vec3(1.0,0.8,-0.6));\n        \n        float amb = 0.5+0.5*nor.y;\n        float dif = 0.5+0.5*dot(nor,lig);\n        \n        vec3 shading = vec3(0.2) * amb + vec3(0.2,0.9,0.7) * dif;\n        col *= shading;\n        col = pow(col,vec3(0.9));\n    }\n    \n\tfragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ltVSRz.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[112, 112, 135, 135, 257], [259, 259, 290, 290, 342], [344, 344, 375, 375, 574], [576, 576, 596, 596, 733], [735, 735, 753, 753, 837], [839, 839, 869, 869, 1087], [1089, 1089, 1117, 1117, 1316], [1318, 1318, 1375, 1375, 2337]], "test": "valid"}
{"id": "ltVSzz", "name": "Mandelbulb - hhhzzzsss", "author": "hhhzzzsss", "description": "Yay fractals! I've always had an interest in fractals, and wanted to code a 3D fractal. This is my first time doing so, and I'm pretty happy with the result. The shading is now more than just ambient occlusion, which looks better to me.", "tags": ["3d", "fractal", "mandelbulb", "ambientocclusion"], "likes": 7, "viewed": 467, "published": "Public", "date": "1482797179", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define distfar 6.0\n#define iterations 4\n\nfloat calcfractal(vec3 coord) {\n    vec3 orbit = coord;\n    float dz = 1.0;\n    \n    for (int i=0; i<iterations; i++) {\n        \n        float r = length(orbit);\n    \tfloat o = acos(orbit.z/r);\n    \tfloat p = atan(orbit.y/orbit.x);\n        \n        dz = 8.0*r*r*r*r*r*r*r*dz + 1.0;\n        \n        r = r*r*r*r*r*r*r*r;\n        o = 8.0*o;\n        p = 8.0*p;\n        \n        orbit = vec3( r*sin(o)*cos(p), r*sin(o)*sin(p), r*cos(o) ) + coord;\n        \n        if (dot(orbit,orbit) > 4.0) break;\n    }\n    float z = length(orbit);\n    return 0.5*z*log(z)/dz;\n}\n\nvec2 map(vec3 p) {\n    return vec2(calcfractal(p.xzy),1.0);\n}\n\nvec3 trace(vec3 ro, vec3 rd) {\n    float t = 0.0;\n    for (float i = 0.0; i < 1000.0; i++) {\n        if (t>distfar) break;\n        vec2 h = map(ro + t*rd);\n        if (h.x < 0.0001) return vec3(t, h.y, i);\n        t += h.x;\n    }\n    return vec3(0.0);\n}\n\nvec3 calcnormal(vec3 p) {\n    vec2 e = vec2(0.0001,0.0);\n    vec3 n;\n    n.x = map(p+e.xyy).x - map(p-e.xyy).x;\n    n.y = map(p+e.yxy).x - map(p-e.yxy).x;\n    n.z = map(p+e.yyx).x - map(p-e.yyx).x;\n    return normalize(n);\n}\n\nfloat softshadow (vec3 ro, vec3 rd) {\n    float res = 1.0;\n    float t = 0.01;\n    for (float i = 0.0; i < 1000.0; i++) {\n        if (t>1.0) break;\n        vec2 h = map(ro + t*rd);\n        if (h.x < 0.0001) return 0.0;\n        res = min(res, 4.0*h.x/t);\n        t += h.x;\n    }\n    return res;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    uv = (2.0)*uv-1.0;\n    uv.x *= iResolution.x/iResolution.y;\n    \n    vec3 ro = vec3(0.0,0.0,-1.4);\n    vec3 rd = normalize(vec3(uv,1.5));\n    float the = 1.5*sin(iTime/30.0-1.0);\n    mat2 rmat = mat2(cos(the),sin(the),-sin(the),cos(the));\n    rd.yz *= rmat;\n    ro.yz *= rmat;\n    the = iTime/20.0;\n    rmat = mat2(cos(the),sin(the),-sin(the),cos(the));\n    rd.xz *= rmat;\n    ro.xz*= rmat;\n    \n    vec3 t = trace(ro, rd);\n    \n    vec3 col = vec3(0.8);\n    \n    if (t.z > 0.0) {\n        vec3 pos = ro + rd*t.x;\n        vec3 nor = calcnormal(pos);\n        vec3 lig = normalize(vec3(0.3,1.0,0.3));\n        vec3 rdy = dot(nor, rd) * nor;\n        vec3 rdx = rd - rdy;\n        vec3 ref = rdx - rdy;\n        \n        float occ = clamp(0.0,1.0,1.0/(1.0+pow(t.z/30.0,3.0)));\n        float sha = softshadow(pos, lig);\n        float dif = max(0.0,dot(lig,nor));\n        float sky = max(0.0,nor.y);\n        float ind = max(0.0,dot(-lig,nor));\n        float spec = pow( max(0.0,dot(ref,lig)) , 20.0);\n        \n        col  = dif*vec3(0.9,0.8,0.7)*vec3(sha);\n        col += sky*vec3(0.16,0.20,0.24)*occ;\n        col += ind*vec3(0.40,0.48,0.40)*occ;\n        col += 0.1*occ;\n        col += spec*sha*vec3(0.9,0.8,0.7);\n\n        \n        col = pow(col,vec3(0.45));\n    }\n    \n\tfragColor = vec4(col,1.0);\n    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ltVSzz.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[42, 42, 73, 73, 601], [603, 603, 621, 621, 664], [666, 666, 696, 696, 919], [921, 921, 946, 946, 1145], [1147, 1147, 1184, 1184, 1442], [1445, 1445, 1502, 1502, 2844]], "test": "valid"}
{"id": "ltVXRz", "name": "Interdimensional Fountain", "author": "lherm", "description": "Practicing shaping space a little. Thanks to Cabbibo for the tips", "tags": ["raymarch"], "likes": 3, "viewed": 431, "published": "Public API", "date": "1482622311", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Based on https://www.shadertoy.com/view/Xt2XDt by Cabbibo\n\n#define PI 3.14159165\n\nconst int S = 10; // steps\nconst float D = 10.; // max distance\nconst float P = 0.001; // intersection precision\nvec3 hash3( float n )\n{\n    return fract(sin(vec3(n,n+1.0,n+2.0))*vec3(13.5453123,31.1459123,37.3490423));\n}\n\nvec3 noise( in float x )\n{\n    float p = floor(x);\n    float f = fract(x);\n    f = f*f*(3.0-2.0*f);\n    return mix( hash3(p+0.0), hash3(p+1.0),f);\n}\n\n//-------------------\n// Camera\n//-------------------\nmat3 calcLookAtMatrix( in vec3 ro, in vec3 ta, in float roll )\n{\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(sin(roll),cos(roll),0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n    return mat3( uu, vv, ww );\n}\n\n\nvec2 opU( vec2 d1, vec2 d2 )\n{\n    \n\treturn (d1.x<d2.x) ? d1 : d2;\n    \n}\n\nfloat sdSphere(in vec3 p, in float r)\n{\n    return length(p) - r;\n}\n\n\n//-------------------\n// Modelling\n//-------------------\n\nvec2 map(in vec3 p)\n{\n    #define STEPS 9\n    for (int i = 0; i < STEPS; i++)\n    {\n    \tp.xyz += dot(p, p.yzx) * cos(p.yzx + iTime);\n    }\n    float s = sdSphere(p, 1.);\n    vec2 res = vec2(s, 1.);\n    return res;\n}\n\nvec2 trace(in vec3 ro, in vec3 rd)\n{\n    float h = P*2.;\n    float t = 0.;\n    float id = -1.;\n    float res = -1.;\n    \n    for (int i = 0; i < S; i++)\n    {\n        if (h<P || t>D) break;\n        vec3 r = ro + rd*t;\n        h = map(r).x;\n        t += h;\n        id = map(r).y;\n    }\n    \n    if (t < D) res = t;\n    if (t > D) id = -1.;\n    \n    return vec2(res, id);\n}\n\nvec3 calcNormal( in vec3 pos ){\n    \n\tvec3 eps = vec3( 0.001, 0.0, 0.0 );\n\tvec3 nor = vec3(\n\t    map(pos+eps.xyy).x - map(pos-eps.xyy).x,\n\t    map(pos+eps.yxy).x - map(pos-eps.yxy).x,\n\t    map(pos+eps.yyx).x - map(pos-eps.yyx).x );\n\treturn normalize(nor);\n}\n\n// From Connor Bell\nfloat softShadow( in vec3 ro, in vec3 rd, in float mint, in float tmax )\n{\n\tfloat res = 1.0;\n    float t = mint;\n    for( int i=0; i<16; i++ )\n    {\n\t\tfloat h = map( ro + rd*t ).x;\n        res = min( res, 8.0*h/t );\n        t += clamp( h, 0.02, 0.10 );\n        if( h<0.001 || t>tmax ) break;\n    }\n    return clamp( res, 0.0, 1.0 );\n\n}\n\nfloat calcAO( in vec3 pos, in vec3 nor )\n{\n\tfloat occ = 0.0;\n    float sca = 1.0;\n    for( int i=0; i<5; i++ )\n    {\n        float hr = 0.01 + 0.12*float(i)/4.0;\n        vec3 aopos =  nor * hr + pos;\n        float dd = map( aopos ).x;\n        occ += -(dd-hr)*sca;\n        sca *= 0.95;\n    }\n    return clamp( 1.0 - 3.0*occ, 0.0, 1.0 );    \n}\n\nvec3 render(in vec2 res, in vec3 ro, in vec3 rd)\n{\n    vec3 color = vec3(0.);\n    vec3 lightPos = vec3( 1. , 4. , 3. );\n    \n    if (res.y > -.5)\n    {\n        vec3 p = ro + rd*res.x;\n        vec3 norm = calcNormal(p);      \n        vec3 lightDir = normalize(lightPos - p);\n        float match = max( 0. , dot( lightDir , norm ));\n        float occ = calcAO(p, norm);\n        \n        if (res.y == 1.)\n        {\n            color = norm * match * occ * (1.0-calcAO(p, rd));\n        }\n    }\n    return color;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = (-iResolution.xy + 2.0*fragCoord.xy)/iResolution.y;\n    \n    vec3 ro = vec3(0., 0., 4.);\n    vec3 ta = vec3(0., 0., 0.);\n    \n    // Camera Matrix\n    mat3 camMat = calcLookAtMatrix( ro, ta, 0. );  // 0.0 is the camera roll\n    \n    // Create view ray\n\tvec3 rd = normalize( camMat * vec3(uv.xy,2.0) ); // 2.0 is the lens length\n    \n    vec2 res = trace(ro, rd);\n    \n    vec3 color = render(res, ro, rd);\n    \n\tfragColor = vec4(color,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ltVXRz.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[103, 198, 221, 221, 306], [308, 308, 334, 334, 456], [458, 512, 576, 576, 754], [757, 757, 787, 787, 830], [832, 832, 871, 871, 899], [960, 960, 981, 981, 1176], [1178, 1178, 1214, 1214, 1549], [1551, 1551, 1582, 1582, 1808], [1810, 1830, 1904, 1904, 2165], [2167, 2167, 2209, 2209, 2508], [2510, 2510, 2560, 2560, 3019], [3021, 3021, 3078, 3078, 3532]], "test": "valid"}
{"id": "ltVXzz", "name": "hsl 2d function mapper", "author": "towc", "description": "small glsl experiment to help me grasp the concepts :)", "tags": ["2d", "function", "hsl", "mapper"], "likes": 4, "viewed": 89, "published": "Public", "date": "1482663682", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec4 hToRGB( float hue ){\n    \n  hue = abs(hue - floor(hue));\n  vec4 color = vec4( 0., 0., 0., 1. );\n  float frac = 1.0/6.0;\n\n  if( hue < frac ){\n    color.r = 1.0;\n    color.g = hue / frac;\n    color.b = 0.0;\n  } else if( hue < frac * 2.0 ){\n    color.r = 1.0 - ( hue - frac ) / frac;\n    color.g = 1.0;\n    color.b = 0.0;\n  } else if( hue < frac * 3.0 ){\n    color.r = 0.0;\n    color.g = 1.0;\n    color.b = ( hue - frac * 2.0 ) / frac;\n  } else if( hue < frac * 4.0 ){\n    color.r = 0.0;\n    color.g = 1.0 - ( hue - frac * 3.0 ) / frac;\n    color.b = 1.0;\n  } else if( hue < frac * 5.0 ){\n    color.r = ( hue - frac * 4.0 ) / frac;\n    color.g = 0.0;\n    color.b = 1.0;\n  } else {\n    color.r = 1.0;\n    color.g = 0.0;\n    color.b = 1.0 - ( hue - frac * 5.0 ) / frac;\n  }\n\n  color = vec4( color.rgb, 1 );\n    \n  return color;\n}\nfloat f( float x, float y ){\n\treturn sin( x / 10.) * 6. + cos( y / 10. ) * 6. + x / 10. + y / 10.;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 xy = fragCoord.xy - iResolution.xy / 2.0;\n    \n\tfragColor = vec4(hToRGB( f( xy.x, xy.y ) / 100. + iTime / 10. ));\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ltVXzz.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 25, 25, 829], [830, 830, 858, 858, 930], [931, 931, 988, 988, 1110]], "test": "valid"}
{"id": "ltySR1", "name": "Basic : Descartes Planets", "author": "Gijs", "description": "Use your mouse.", "tags": ["descartes"], "likes": 12, "viewed": 445, "published": "Public", "date": "1482782864", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec2 Scale(vec2 p){\n    float MinRes = min(iResolution.y,iResolution.x);\n\treturn (p.xy*2.-iResolution.xy)/MinRes*2.;\n}\n\nvec2 complexMultiply(vec2 a, vec2 b){\n    return vec2(a.x*b.x-a.y*b.y,a.x*b.y+a.y*b.x);\n}\n\nvec2 complexSqrt(vec2 z){\n    float r = sqrt(length(z));\n    float a = atan(z.y,z.x)*.5;\n    return r*vec2(cos(a),sin(a));\n}\n\nmat2 getRotationMatrix(float a){\n    return mat2(cos(a),sin(a),-sin(a),cos(a));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    float MinRes = min(iResolution.y,iResolution.x);\n    \n    mat2  r = getRotationMatrix(iTime*.3);\n    \n    float  LineEpsilon =  1./MinRes;\n    \n\tvec2 z = Scale(fragCoord);\n    \n    //midpoint circles\n    vec2 m1 = (iMouse.z>0.)?Scale(iMouse.xy):vec2(.36602540378,0);\n    vec2 m2 = vec2(-.5, .5);\n    vec2 m3 = vec2(-.5,-.5);\n    \n    //distance from i to next\n    float d1 = distance(m1,m2);\n    float d2 = distance(m2,m3);\n    float d3 = distance(m3,m1);\n    \n    //radius circles\n    float r1 = ( d1-d2+d3)*.5;\n    float r2 = ( d1+d2-d3)*.5;//d1-r1\n    float r3 = (-d1+d2+d3)*.5;//d3-r1\n    \n    //curvature circles\n    float k1 = 1./r1;\n    float k2 = 1./r2;\n    float k3 = 1./r3;\n    \n    //curvature descarte circle\n    float k4 = k1+k2+k3-2.*sqrt(k1*k2+k2*k3+k3*k1);\n    \n    //radius descartes circles \n    float r4 = abs(1./k4);\n\n    //descarte circle midpoint, surprisingly difficult...\n    vec2 m4 = (m1*k1 \n             + m2*k2 \n             + m3*k3 \n             + 2.*complexSqrt(\n                 complexMultiply(m1,m2)*k1*k2 \n               + complexMultiply(m2,m3)*k2*k3 \n               + complexMultiply(m1,m3)*k1*k3 \n             ))/k4;\n    \n    \n    //fractal loop, basic scaling\n    //s keeps track of total scaling\n    float its = 0.;\n    float s = 1.;\n    for(int i=0;i<4;i++){\n        \n        if(distance(z,m1)<r1){\n             z = (z-m1)/r1;\n             s =      s/r1;\n            \n        }else if(distance(z,m2)<r2){\n             z = (z-m2)/r2; \n             s =      s/r2;\n            \n        }else if(distance(z,m3)<r3){\n             z = (z-m3)/r3;  \n             s =      s/r3;\n            \n        }else{\n            \n            break;\n            \n        }\n        \n                \n\t\tz *= r;\n           \n        z = m4 + z*r4;\n        s =    + s*r4;\n      \n        its++;\n    }\n\n    //get distance to the four circle edges\n    float dis = 1e20;\n    dis = min(dis,abs(distance(z,m1)-r1));\n    dis = min(dis,abs(distance(z,m2)-r2));\n    dis = min(dis,abs(distance(z,m3)-r3));\n    dis = min(dis,abs(distance(z,m4)-r4));\n    \n    dis /= s;//scale distance back to actual distance\n   \n    float smoothed = smoothstep(1./LineEpsilon,0.,1./dis)/(its*.1+1.);\n    \n\n    fragColor = vec4(smoothed);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ltySR1.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 19, 19, 118], [120, 120, 157, 157, 209], [211, 211, 236, 236, 335], [337, 337, 369, 369, 418], [420, 420, 476, 476, 2708]], "test": "valid"}
{"id": "ltySzh", "name": "Menger Factory Meltdown", "author": "s23b", "description": "how many shaders have you seen, where the camera is floating around aimlessly while traversing a fractal?\nit's my pleasure to present to you a 3d scene that gives the camera a very good reason to move!\n\nany tips on improving fps are more than welcome :D", "tags": ["fractal", "menger", "steel", "melting", "factory"], "likes": 30, "viewed": 1213, "published": "Public API", "date": "1482931613", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define SPEED .1\n#define FOV 1.5\n\n#define MAX_STEPS 100\n#define SHADOW_STEPS 100\n#define SHADOW_SOFTNESS 10.\n#define EPS .0001\n#define RENDER_DIST 5.\n#define AO_SAMPLES 5.\n#define AO_RANGE 10.\n#define LIGHT_COLOR vec3(1.,.5,.3)\n\n#define PI 3.14159265359\n#define saturate(x) clamp(x, 0., 1.)\n\nvec3 _ballPos = vec3(0);\nfloat _ballSize = .5;\n\n// simple hash function\nfloat hash(vec3 uv) {\n    float f = fract(sin(dot(uv, vec3(.009123898, .00231233, .00532234))) * 111111.5452313);\n    return f;\n}\n\n// 3d noise function (linear interpolation between hash of integer bounds)\nfloat noise(vec3 uv) {\n    vec3 fuv = floor(uv);\n    vec4 cell0 = vec4(\n        hash(fuv + vec3(0, 0, 0)),\n        hash(fuv + vec3(0, 1, 0)),\n        hash(fuv + vec3(1, 0, 0)),\n        hash(fuv + vec3(1, 1, 0))\n    );\n    vec2 axis0 = mix(cell0.xz, cell0.yw, fract(uv.y));\n    float val0 = mix(axis0.x, axis0.y, fract(uv.x));\n    vec4 cell1 = vec4(\n        hash(fuv + vec3(0, 0, 1)),\n        hash(fuv + vec3(0, 1, 1)),\n        hash(fuv + vec3(1, 0, 1)),\n        hash(fuv + vec3(1, 1, 1))\n    );\n    vec2 axis1 = mix(cell1.xz, cell1.yw, fract(uv.y));\n    float val1 = mix(axis1.x, axis1.y, fract(uv.x));\n    return mix(val0, val1, fract(uv.z));\n}\n\n// fractional brownian motion\nfloat fbm(vec3 uv) {\n    float f = 0.;\n    float r = 1.;\n    for (int i = 0; i < 3; ++i) {\n        f += noise((uv + 10.) * r) / (r *= 2.);\n    }\n    return f / (1. - 1. / r);\n}\n\n// rotate 2d space with given angle\nvoid tRotate(inout vec2 p, float angel) {\n    float s = sin(angel), c = cos(angel);\n\tp *= mat2(c, -s, s, c);\n}\n\n// repeat 3d space\nvec3 tRepeat3(inout vec3 p, vec3 r) {\n    vec3 id = floor((p + r * .5) / r);\n    p = mod(p + r * .5, r) - r * .5;\n    return id;\n}\n\n// sphere distance\nfloat sdSphere(vec3 p, float r) {\n\treturn length(p) - r;\n}\n\n// 3d cross distance\nfloat sdCross(vec3 p, vec3 r) {\n    p =abs(p) - r;\n    p.xy = p.x < p.y ? p.xy : p.yx;\n    p.yz = p.y < p.z ? p.yz : p.zy;\n    p.xy = p.x < p.y ? p.xy : p.yx;\n    return length(min(p.yz, 0.)) - max(p.y, 0.);\n}\n\n// union\nfloat opU(float a, float b) {\n    return min(a, b);\n}\n\n// intersection\nfloat opI(float a, float b) {\n    return max(a, b);\n}\n\n// smooth union\nfloat opSU(float a, float b, float k)\n{\n    float h = clamp(.5 + .5 * (b - a) / k, 0., 1.);\n    return mix(b, a, h) - k * h * (1. - h);\n}\n\n// distance estimation of the scene without the ball (for shadow calculation)\nfloat scene(vec3 p) {\n    float size = 1.;\n    float d = -2.;\n    \n    for (int i = 0; i < 5; ++i) {\n        \n        // scale and repeat the cross SDF, then intersect with the calculated distance\n        size *= 3.;\n        vec3 q = p * size;\n        tRepeat3(q, vec3(3));\n    \td = opI(d, sdCross(q, vec3(.5)) / size);\n    }\n    \n    // add the floor\n    d = opU(d, p.y + .169);\n    return d;\n}\n\n// distance estimation of everything together\nfloat map(vec3 p) {\n    return opSU(scene(p), sdSphere(p - _ballPos, _ballSize), .15);\n}\n\n// trace the scene from ro (origin) to rd (direction, normalized)\n// until hit or reached maxDist, outputs distance traveled and the number of steps\nfloat trace(vec3 ro, vec3 rd, float maxDist, out float steps) {\n    float total = 0.;\n    steps = 0.;\n    \n    for (int i = 0; i < MAX_STEPS; ++i) {\n        ++steps;\n        float d = map(ro + rd * total);\n        total += d;\n        if (d < EPS || maxDist < total) break;\n    }\n    \n    return total;\n}\n\n// get the soft shadow value\nfloat softShadow(vec3 ro, vec3 rd, float maxDist) {\n    float total = 0.;\n    float s = 1.;\n    \n    for (int i = 0; i < SHADOW_STEPS; ++i) {\n        float d = scene(ro + rd * total);\n        if (d < EPS) {\n            s = 0.;\n            break;\n        }\n        if (maxDist < total) break;\n        s = min(s, SHADOW_SOFTNESS * d / total);\n        total += d;\n    }\n    \n    return s;\n}\n\n// calculate the normal vector\nvec3 getNormal(vec3 p) {\n    vec2 e = vec2(.0001, 0);\n    return normalize(vec3(\n        map(p + e.xyy) - map(p - e.xyy),\n        map(p + e.yxy) - map(p - e.yxy),\n        map(p + e.yyx) - map(p - e.yyx)\n\t));\n}\n\n// ambient occlusion\nfloat calculateAO(vec3 p, vec3 n) {\n    \n    float r = 0., w = 1., d;\n    \n    for (float i = 1.; i <= AO_SAMPLES; i++){\n        d = i / AO_SAMPLES / AO_RANGE;\n        r += w * (d - scene(p + n * d));\n        w *= .5;\n    }\n    \n    return 1.-saturate(r * AO_RANGE);\n}\n\n// texture function\nvec3 _texture(vec3 p) {\n    vec3 t = fbm((p*50.)) * vec3(.9, .7, .5) * .75\n        + smoothstep(.4, .9, fbm((p*10. + 2.))) * vec3(1., .4, .3)\n        - smoothstep(.5, .9, fbm((p*100. + 4.))) * vec3(.4, .3, .2);\n    return saturate(t);\n}\n\n// the glow of the melting metal\nvec3 glow(vec3 p) {\n    return pow(smoothstep(_ballSize * 1.8,_ballSize, distance(p, _ballPos)), 5.) * LIGHT_COLOR * 3.;\n}\n\n// a lovely function that goes up and down periodically between 0 and 1, pausing at the extremes\nfloat pausingWave(float x, float a, float b) { //    ___          ___          ___\n    x = abs(fract(x) - .5) * 1. - .5 + a;      //   /   \\        /   \\        /   \\ \n    return smoothstep(0., a - b, x);           // --     --------     --------     ------\n}\t\t\t\t\t\t\t\t\t\t\t   // basically like this :P\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    // transform screen coordinates\n\tvec2 uv = fragCoord.xy / iResolution.xy * 2. - 1.;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    // transform mouse coordinates\n\tvec2 mouse = iMouse.xy / iResolution.xy * 2. - 1.;\n    mouse.x *= iResolution.x / iResolution.y;\n    mouse *= 2.;\n    \n    float time = iTime * SPEED + .5;\n    \n    // the frequency of the steps\n    float jump = time * 80.;\n    \n    // set the position of that menacing ball of melting steel\n    _ballPos = vec3(0, -.15, time);\n    _ballPos.xy+= (noise(_ballPos * 20.) - .5) * .1;\n    \n    // the camera is trying to escape its impending doom\n    vec3 ro =  vec3(0, abs(sin(jump)) * .01 - .07, .75 + _ballPos.z);\n    vec3 rd = normalize(vec3(uv, FOV));\n    \n    // the scene is illuminated by the melting blob\n    vec3 light = _ballPos;\n    \n    if (iMouse.z > 0.) {\n        // rotate the scene using the mouse\n        mouse.y = max(mouse.y, -.5); // limit the view vertically, so you don't realize that I was too lazy to render a running human\n        tRotate(rd.yz, -mouse.y);\n        tRotate(rd.xz, -mouse.x);\n    } else {\n        // or face down / forward\n        tRotate(rd.xy, sin(jump) * .002);\n        tRotate(rd.yz, .2);\n        tRotate(rd.xz, sin(jump) * .02);\n        \n        // occasionally look up to the skies, beg the gods for mercy\n        tRotate(rd.yz, -pausingWave(time * .25 - .005, .04, .01) * 1.5);\n        \n        // pick a random direction\n        float dir = sign(hash(vec3(0, 0, floor(time - .5))) - .5);\n        \n        // periodically look in that direction\n        tRotate(rd.xz, dir * pausingWave(time, .15, .1) * 2.5);\n    }\n    \n    // add a camera shake for over-the-top dramatic effect\n    ro += noise(ro * 10000.) / 300.;\n    \n    // march\n    float steps, dist = trace(ro, rd, RENDER_DIST, steps); \n    \n    // calculate hit point coordinates\n    vec3 p = ro + rd * dist;\n    \n    // calculate normal\n    vec3 normal = getNormal(p);\n    \n    // light direction\n    vec3 l = normalize(light - p);\n    \n    // calculate shadow\n    vec3 shadowStart = p + normal * EPS * 10.;\n    float shadowDistance = distance(shadowStart,light) - _ballSize * .5;\n    float shadow = softShadow(shadowStart, l, shadowDistance);\n    \n    // ambient light\n    float ambient = .25;\n    \n    // diffuse light\n    float diffuse = max(0., dot(l, normal));\n    \n    // specular light\n    float specular = pow(max(0., dot(reflect(-l, normal), -rd)), 8.);\n    \n    // \"ambient occlusion\"\n    float ao = calculateAO(p, normal);\n    \n    // add this all up\n\tfragColor.rgb = (ao * _texture(p)) * (ambient * (2. - LIGHT_COLOR) * .5 + (specular + diffuse) * shadow * LIGHT_COLOR) + glow(p);\n    \n    // edge glow\n    fragColor *= .3 + sqrt(steps / float(MAX_STEPS)) * .7;\n    \n    // fog\n    fragColor = mix(fragColor, vec4((1. - LIGHT_COLOR) * .02, 1.), saturate(dist * dist * .05));\n    \n    // gamma correction\n    fragColor = pow(fragColor, vec4(1. / 2.2));\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ltySzh.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[340, 364, 385, 385, 493], [495, 570, 592, 592, 1215], [1217, 1247, 1267, 1267, 1423], [1425, 1461, 1502, 1502, 1571], [1573, 1592, 1629, 1629, 1722], [1724, 1743, 1776, 1776, 1801], [1803, 1824, 1855, 1855, 2033], [2035, 2044, 2073, 2073, 2097], [2099, 2115, 2144, 2144, 2168], [2170, 2186, 2225, 2225, 2323], [2325, 2403, 2424, 2424, 2798], [2800, 2846, 2865, 2865, 2934], [2936, 3085, 3148, 3148, 3388], [3390, 3419, 3470, 3470, 3806], [3808, 3839, 3863, 3863, 4048], [4050, 4071, 4106, 4106, 4339], [4341, 4361, 4384, 4384, 4597], [4599, 4632, 4651, 4651, 4754], [4756, 4853, 4899, 4935, 5112], [5153, 5153, 5208, 5244, 8149]], "test": "valid"}
{"id": "ltyXR1", "name": "Re Fractal land by Kali", "author": "wizgrav", "description": "Audio reactive remix of kali's awesome fractal land https://www.shadertoy.com/view/XsBXWt \n\nElectro https://goo.gl/9yBZnJ", "tags": ["fractal", "remix", "kali", "clubber"], "likes": 19, "viewed": 11977, "published": "Public API", "date": "1482787895", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// \"Fractal Cartoon\" - former \"DE edge detection\" by Kali\n\n// Cartoon-like effect using eiffies's edge detection found here: \n// https://www.shadertoy.com/view/4ss3WB\n// I used my own method previously but was too complicated and not compiling everywhere.\n// Thanks to the suggestion by WouterVanNifterick. \n\n// There are no lights and no AO, only color by normals and dark edges.\n\n// update: Nyan Cat cameo, thanks to code from mu6k: https://www.shadertoy.com/view/4dXGWH\n\n\n// The following block is needed for Clubber integration\n#ifndef CLUBBER\nvec4 iMusic[4];\nconst float iTransition = 1.0;\n#define CLUBBER_R 0.0\n#define CLUBBER_G 0.0\n#define CLUBBER_B 0.0\n#define CLUBBER_A 0.0\n#endif\n// Clubber end\n\n#define MUSICRAYS 1.2 * (CLUBBER_A)\n#define MUSICWAVES CLUBBER_R\n#define MUSICMOD1 CLUBBER_G / 4.4\n#define MUSICMOD2 CLUBBER_B / 6.6\n#define MUSICSUNSIZE length(vec2(CLUBBER_R, CLUBBER_G ))\n#define MUSICSUNSPIN length(vec2(CLUBBER_B, CLUBBER_A ))\n\n//#define SHOWONLYEDGES\n#define WAVES\n\n#define RAY_STEPS 150\n\n#define BRIGHTNESS 1.2\n#define GAMMA 1.4\n#define SATURATION .65\n\n\n#define detail .001\n#define t iTime*.5\n\n\nconst vec3 origin=vec3(-1.,.7,0.);\nfloat det=0.0;\n\n\n// 2D rotation function\nmat2 rot(float a) {\n\treturn mat2(cos(a),sin(a),-sin(a),cos(a));\t\n}\n\n// \"Amazing Surface\" fractal\nvec4 formula(vec4 p) {\n\t\tp.xz = abs(p.xz + 1.)-abs(p.xz - 1.2 + MUSICMOD1) - p.xz;\n\t\tp.y-=.25;\n\t\tp.xy *= rot(radians(35.));\n        p=p*2./clamp(dot(p.xyz,p.xyz),.2,min(1.05, 0.95 + MUSICMOD2));\n\treturn p;\n}\n\n// Distance function\nfloat de(vec3 pos) {\n#ifdef WAVES\n\tpos.y+=sin(pos.z-t*6.+MUSICWAVES)*.15; //waves!\n#endif\n\tfloat hid=0.;\n\tvec3 tpos=pos;\n\ttpos.z=abs(3.-mod(tpos.z,6.) );\n\tvec4 p=vec4(tpos,1.);\n\tfor (int i=0; i<4; i++) {p=formula(p);}\n\tfloat fr=(length(max(vec2(0.),p.yz-1.5))-1.)/p.w;\n\tfloat ro=max(abs(pos.x+1.)-.3,pos.y-.35);\n\t\t  ro=max(ro,-max(abs(pos.x+1.)-.1,pos.y-.5));\n\tpos.z=abs(.25 - mod(pos.z - 2. * length(iMusic[2].xz),.5));\n\t\t  ro=max(ro,-max(abs(pos.z)-.2,pos.y-.3));\n\t\t  ro=max(ro,-max(abs(pos.z)-.01,-pos.y+.32));\n\tfloat d=min(fr,ro);\n\treturn d;\n}\n\n\n// Camera path\nvec3 path(float ti) {\n\tti*=1.5;\n\tvec3  p=vec3(sin(ti),(1.-sin(ti*2.))*.5,-ti*5.)*.33;\n\treturn p;\n}\n\n// Calc normals, and here is edge detection, set to variable \"edge\"\n\nfloat edge=0.;\nvec3 normal(vec3 p) { \n\tvec3 e = vec3(0.0,det*5.,0.0);\n\n\tfloat d1=de(p-e.yxx),d2=de(p+e.yxx);\n\tfloat d3=de(p-e.xyx),d4=de(p+e.xyx);\n\tfloat d5=de(p-e.xxy),d6=de(p+e.xxy);\n\tfloat d=de(p);\n\tedge=abs(d-0.5*(d2+d1))+abs(d-0.5*(d4+d3))+abs(d-0.5*(d6+d5));//edge finder\n\tedge=min(1.,pow(edge,.55)*15.);\n\treturn normalize(vec3(d1-d2,d3-d4,d5-d6));\n}\n\n\n\n\n\n// Raymarching and 2D graphics\n\nvec3 raymarch(in vec3 from, in vec3 dir) \n\n{\n\tedge=0.;\n\tvec3 p, norm;\n\tfloat d=100.;\n\tfloat totdist=0.;\n\tfor (int i=0; i<RAY_STEPS; i++) {\n        if (d>det && totdist<25.0){\n\t\t\tp=from+totdist*dir;\n\t\t\td=de(p);\n\t\t\tdet=detail*exp(.13*totdist);\n\t\t\ttotdist+=d; \n    \t} else {\n    \t\tbreak;\n    \t}\n\t}\n\tvec3 col=vec3(0.);\n\tp-=(det-d)*dir;\n\tnorm=normal(p);\n    \n#ifdef SHOWONLYEDGES\n\tcol=1.-vec3(edge); // show wireframe version\n#else\n\tcol=mix(vec3(edge), (1.-abs(norm))*max(0.,1.-edge*.8), iTransition); // set normal as color with dark edges\n#endif\t\t\n\ttotdist=clamp(totdist,0.,26.);\n\tdir.y-=.02;\n\tfloat sunsize= 7. - MUSICSUNSIZE; // responsive sun size\n\tfloat an=atan(dir.x,dir.y)+iTime * 1.5 + MUSICSUNSPIN; // angle for drawing and rotating sun\n\tfloat s=pow(clamp(1.0-length(dir.xy)*sunsize-abs(.2-mod(an,.4)),0.,1.),.1); // sun\n\tfloat sb=pow(clamp(1.0-length(dir.xy)*(sunsize-.2)-abs(.2-mod(an,.4)),0.,1.),.1); // sun border\n\tfloat sg=pow(clamp(1.0-length(dir.xy)*(sunsize - 4.5 - MUSICRAYS )-.5*abs(.2-mod(an,.4)),0.,1.),3.); // sun rays\n\tfloat y=mix(.45,1.2,pow(smoothstep(0.,1.,.75-dir.y),2.))*(1.-sb*.5); // gradient sky\n\t\n\t// set up background with sky and sun\n\tvec3 backg=vec3(0.5,0.,1.)*iTransition*((1.-s)*(1.-sg)*y+(1.-sb)*sg*vec3(1.,.8,0.15)*3.);\n\t\t backg+=min(vec3(1.,.9,.1)*s,vec3(iTransition));\n\t\t backg=max(backg,sg*vec3(1.,.9,.5));\n\t\n\tcol=mix(vec3(1.,.9,.3)*iTransition,col,exp(-.004*totdist*totdist));// distant fading to sun color\n\tif (totdist>25.) col=backg; // hit background\n\tcol=pow(col,vec3(GAMMA))*BRIGHTNESS;\n\tcol=mix(vec3(length(col)),col,SATURATION);\n#ifdef SHOWONLYEDGES\n\tcol=1.-vec3(length(col));\n#else\n\tcol*=mix(vec3(length(col)), vec3(1.,.9,.85), iTransition);\n#endif\n\treturn col;\n}\n\n// get camera position\nvec3 move(inout vec3 dir) {\n\tvec3 go=path(t);\n\tvec3 adv=path(t+.7);\n\tfloat hd=de(adv);\n\tvec3 advec=normalize(adv-go);\n\tfloat an=adv.x-go.x; an*=min(1.,abs(adv.z-go.z))*sign(adv.z-go.z)*.7;\n\tdir.xy*=mat2(cos(an),sin(an),-sin(an),cos(an));\n    an=advec.y*1.7;\n\tdir.yz*=mat2(cos(an),sin(an),-sin(an),cos(an));\n\tan=atan(advec.x,advec.z);\n\tdir.xz*=mat2(cos(an),sin(an),-sin(an),cos(an));\n\treturn go;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy*2.-1.;\n\tvec2 oriuv=uv;\n\tuv.y*=iResolution.y/iResolution.x;\n\tvec2 mouse=(iMouse.xy/iResolution.xy-.5)*3.;\n\tif (iMouse.z<1.) mouse=vec2(0.,-0.05);\n\tfloat fov=.9-max(0.,.7-iTime*.3);\n\tvec3 dir=normalize(vec3(uv*fov,1.));\n\tvec3 from=origin+move(dir);\n\tvec3 color=raymarch(from,dir); \n\t#ifdef BORDER\n\tcolor=mix(vec3(0.),color,pow(max(0.,.95-length(oriuv*oriuv*oriuv*vec2(1.05,1.1))),.3));\n\t#endif\n\tfragColor = vec4(color,1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ltyXR1.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1175, 1199, 1218, 1218, 1265], [1267, 1296, 1318, 1318, 1503], [1505, 1526, 1546, 1546, 2073], [2076, 2091, 2112, 2112, 2189], [2275, 2275, 2296, 2296, 2616], [2654, 2654, 2698, 2698, 4364], [4366, 4389, 4416, 4416, 4785], [4787, 4787, 4844, 4844, 5308]], "test": "valid"}
{"id": "Ml3SRf", "name": "bp Turbulence", "author": "blackpolygon", "description": "Playing with the examples of Fractal brownian motion from the book of shaders\n\nhttps://thebookofshaders.com/13/", "tags": ["noise", "fbm", "fractalbrownianmotion"], "likes": 48, "viewed": 914, "published": "Public", "date": "1480804453", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Author: blackpolygon \n// Title: Turbulence\n// Date: December 2016\n\n// Based on the example from @patriciogv for Fractal Brownian Motion\n// https://thebookofshaders.com/13/\n\n\n#define PI 3.14159265359\n#define TWO_PI 6.28318530718\n\nfloat random (in vec2 _st) { \n    return fract(sin(dot(_st.xy, vec2(12.9898,78.233))) * 43758.54531237);\n}\n\n// Based on Morgan McGuire @morgan3d\n// https://www.shadertoy.com/view/4dS3Wd\nfloat noise (in vec2 _st) {\n    vec2 i = floor(_st);\n    vec2 f = fract(_st);\n\n    // Four corners in 2D of a tile\n    float a = random(i);\n    float b = random(i + vec2(1.0, 0.0));\n    float c = random(i + vec2(0.0, 1.0));\n    float d = random(i + vec2(1.0, 1.0));\n\n    vec2 u = f * f * (3. - 2.0 * f);\n\n    return mix(a, b, u.x) + \n            (c - a)* u.y * (1. - u.x) + \n            (d - b) * u.x * u.y;\n}\n\n#define NUM_OCTAVES 5\n\nfloat fbm ( in vec2 _st) {\n    float v = 0.0;\n    float a = 0.5;\n    vec2 shift = vec2(20.0);\n    // Rotate to reduce axial bias\n    mat2 rot = mat2(cos(0.5), sin(0.5), \n                    -sin(0.5), cos(0.50));\n    for (int i = 0; i < NUM_OCTAVES; ++i) {\n        v += a * noise(_st);\n        _st = rot * _st * 2.2 + shift;\n        a *= 0.5;\n    }\n    return v;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 st = (fragCoord.xy - 0.5*iResolution.xy )/min(iResolution.x,iResolution.y);\n    st *= 3.5;\n    \n    vec3 color = vec3(0.);\n    vec2 a = vec2(0.);\n    vec2 b = vec2(0.);\n    vec2 c = vec2(60.,800.);\n    \n    a.x = fbm( st);\n    a.y = fbm( st + vec2(1.0));\n    \n    b.x = fbm( st + 4.*a);\n    b.y = fbm( st);\n\n    c.x = fbm( st + 7.0*b + vec2(10.7,.2)+ 0.215*iTime );\n    c.y = fbm( st + 3.944*b + vec2(.3,12.8)+ 0.16*iTime);\n\n    float f = fbm(st+b+c);\n\n    color = mix(vec3(0.445,0.002,0.419), vec3(1.000,0.467,0.174), clamp((f*f),0.2, 1.0));\n    color = mix(color, vec3(0.413,0.524,0.880), clamp(length(c.x),0.480, 0.92));\n    \n    st = st/3.5;\n   \n    // Make the hexagon mask\n    int N = 6;\n    float ata = atan(st.x,st.y)+PI;\n    float r = TWO_PI/float(N);\n    float dist = cos(floor(.5+ata/r)*r-ata)*length(st);\n    \n    float hexagonMask = 1.0-smoothstep(.45,.452,dist);\n    float bgMask = 1.0 - hexagonMask;\n    \n    vec3 finalColor = vec3(f*1.9*color);\n    vec3 bgColor = vec3(0.950,0.951,0.90);\n\n    fragColor = vec4( bgColor*bgMask + finalColor*hexagonMask, 1.);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Ml3SRf.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[232, 232, 260, 260, 338], [340, 418, 445, 445, 827], [852, 852, 878, 878, 1216], [1218, 1218, 1275, 1275, 2359]], "test": "valid"}
{"id": "Ml3SRs", "name": "Winter Snow Effect", "author": "twitchingace", "description": "What can I say? I'm Canadian and it's wintertime.\nI try to do some parallax layers and vaguely Depth of Field type stuff.\n\nInspired by bleedingtiger2's Simple Snow and Blizzard.", "tags": ["2d", "parallax", "effect", "snow", "weather", "blizzard"], "likes": 14, "viewed": 1121, "published": "Public", "date": "1481140354", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// This is probably way too many layers/flakes for full-screen. Play around with them\n#define _NUMSHEETS 10.\n#define _NUMFLAKES 400.\n\nvec2 uv;\n\n// The classic GLSL random function\nfloat rnd(float x)\n{\n    return fract(sin(dot(vec2(x+47.49,38.2467/(x+2.3)), vec2(12.9898, 78.233)))* (43758.5453));\n}\n\n// From https://www.shadertoy.com/view/MscXD7\nfloat drawFlake(vec2 center, float radius)\n{\n    return 1.0 - sqrt(smoothstep(0.0, radius, length(uv - center)));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    uv = fragCoord.xy / iResolution.x;\n    vec3 col = vec3(0.63, .85, .95);\n    for (float i = 1.; i <= _NUMSHEETS; i++){\n        for (float j = 1.; j <= _NUMFLAKES; j++){\n            // We want fewer flakes as they get larger\n            if (j > _NUMFLAKES/i) break;\n            \n            // Later sheets should have, on average, larger and faster flakes\n            // (to emulate parallax scrolling)\n            float size = 0.002 * i * (1. + rnd(j)/2.);            \n            float speed = size * .75 + rnd(i) / 1.5;\n            \n            // The two terms randomize the x pos and spread it out enough that we don't\n            // get weird hard lines where no snow passes.\n            // The last term gives us some side-to-side wobble\n            vec2 center = vec2(0., 0.);\n            center.x = -.3 + rnd(j*i) * 1.4 + 0.1*cos(iTime+sin(j*i));\n            center.y = fract(sin(j) - speed * iTime) / 1.3;\n            \n            // TODO: Add in some kind of z-axis wobble\n            \n            // As the sheets get larger/faster/closer, we fade them more.\n            col += vec3( (1. - i/_NUMSHEETS) * drawFlake(center, size));\n        }\n    }\n\tfragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Ml3SRs.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[144, 180, 200, 200, 298], [300, 346, 390, 390, 461], [463, 463, 520, 520, 1713]], "test": "valid"}
{"id": "Ml3Szl", "name": "Gyroscope Hierarchy", "author": "sea", "description": "Work in progress.", "tags": ["gyroscope"], "likes": 1, "viewed": 171, "published": "Public", "date": "1481096500", "time_retrieved": "2021-10-01T00:00:00", "image_code": "mat4 roll (float r)\n{\n    return mat4(\n        cos(r),\tsin(r),\t0.0, 0.0,\n        -sin(r), cos(r), 0.0, 0.0,\n        0.0, 0.0, 1.0, 0.0,\n        0.0, 0.0, 0.0, 1.0\n    );\n}\n\nmat4 yaw (float r)\n{\n    return mat4(\n        cos(r),\t0.0, -sin(r), 0.0,\n        0.0, 1.0, 0.0, 0.0,\n        sin(r),\t0.0, cos(r), 0.0,\n        0.0, 0.0, 0.0, 1.0\n    );\n}\n\nmat4 pitch (float r)\n{\n    return mat4(\n       \t1.0, 0.0, 0.0, 0.0,\n        0.0, cos(r), sin(r), 0.0,\n        0.0, -sin(r), cos(r), 0.0,\n        0.0, 0.0, 0.0, 1.0\n    );\n}\n\nfloat ellipsoid (vec3 p, vec3 d)\n{\n    return pow(p.x / d.x, 2.0) + pow(p.y / d.y, 2.0) + pow(p.z / d.z, 2.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 ws = fragCoord.xy / iResolution.xy * 2.0 - 1.0;\n    ws.x *= iResolution.x / iResolution.y;\n    vec3 color = vec3(ws, 1.0);\n    \n    vec3 ro = vec3(0.0, 0.5, -2.0);\n    vec3 rd = vec3(ws, 1.0);\n    \n    vec3 p = vec3(0.0);\n    float eo, ei = 0.0;\n    bool hit = false;\n    \n    for (float i = 0.0; i < 3.0; i += 0.03)\n    {\n        p = ro + rd * i;\n        \n        for (int e = 1; e < 20; e++)\n        {\n            p = (vec4(p, 1.0) * roll(iTime * 0.1) * pitch(iTime * 0.1)).xyz;\n            \n            eo = float(e) * 0.1;\n            ei = float(e) * 0.1 - 0.1;\n            \n            if (ellipsoid(p, vec3(1.0) * eo) < 1.0 && !(ellipsoid(p, vec3(1.0) * ei) < 1.0) && p.y < 0.05 && p.y >= -0.05)\n            {\n            \tcolor = vec3(1.0 - float(e) * 0.05 - 0.1);\n                hit = true;\n                break;\n            }\n        }\n        \n        if (hit)\n            break;\n    }\n    \n\tfragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Ml3Szl.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 21, 21, 171], [173, 173, 193, 193, 343], [345, 345, 367, 367, 517], [519, 519, 553, 553, 631], [633, 633, 690, 690, 1632]], "test": "valid"}
{"id": "Ml3XRf", "name": "hhhzzzsss Normal Raymarch Shader", "author": "hhhzzzsss", "description": "This shader uses surface normals.\nThe object has a wood texture.\nIt's morphing like a liquid!", "tags": ["raymarching"], "likes": 3, "viewed": 175, "published": "Public", "date": "1480820147", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float ballshape( in vec3 p ) {\n    float d = length(p)-0.8;\n    d += 0.1*sin(10.0*p.x+iTime*2.0)*sin(10.0*p.y+iTime)*sin(10.0*p.z+iTime*3.0);\n    return d;\n}\n\nfloat floorshape(in vec3 p) {\n    return p.y + 1.2+0.1*(sin(5.0*p.x+iTime*10.0)+sin(5.0*p.z));\n}\n\nvec2 map( in vec3 p ) {\n    vec2 d1 = vec2( ballshape(p), 1.0 );\n    vec2 d2 = vec2( floorshape(p), 2.0 );\n    if (d2.x<d1.x) d1 = d2;\n    return d1;\n}\n\nvec3 calcNormal( in vec3 p ) {\n    vec3 e = vec3(0.0001,0.0,0.0);\n    vec3 n;\n    n.x = map(p+e.xyy).x - map(p-e.xyy).x;\n    n.y = map(p+e.yxy).x - map(p-e.yxy).x;\n    n.z = map(p+e.yyx).x - map(p-e.yyx).x;\n    return normalize(n);\n}\n\nfloat softShadow( in vec3 ro, in vec3 rd ) {\n    float res = 1.0;\n    float t = 0.01;\n    for( int i = 0; i < 1000; ++i) {\n        if(t>=6.0) break;\n        float h = map( ro+t*rd ).x;\n        if ( h<0.001 ) return 0.0;\n        res = min( res, 4.0*h/t );\n        t += h;\n    }\n    return res;\n}\n\nvec2 intersect( in vec3 ro, in vec3 rd ) {\n    float t = 0.0;\n    for( int i = 0; i < 1000; ++i ) {\n        if(t>=6.0) break;\n        vec2 h = map( ro+t*rd );\n        if ( h.x<0.0001 ) return vec2(t,h.y);\n        t += 0.5*h.x;\n    }\n    return vec2(0.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 q = fragCoord.xy / iResolution.xy;\n    \n    vec3 ro = vec3(2.0*sin(iTime*0.0),0.0,2.0*cos(iTime*0.0));\n    vec3 rd = normalize(vec3( (-1.0+2.0*q)*vec2(iResolution.x/iResolution.y,1.0), -1.5 ));\n    float theta = iTime*0.0;\n    mat2 rmat = mat2(cos(theta),sin(theta),-sin(theta),cos(theta));\n    rd.xz *= rmat;\n    \n    vec2 t = intersect( ro, rd );\n    vec3 col = vec3(0.8);\n    if( t.y>0.5 ) {\n        vec3 pos = ro + t.x*rd;\n        vec3 nor = calcNormal( pos );\n        vec3 lig = normalize( vec3(1.0,0.8,0.6) );\n        \n        float amb = 0.5+0.5*nor.y;\n        float dif = max( 0.0, dot(nor,lig) );\n        \n        float sha = 0.2+0.8*softShadow( pos, lig );\n        \n        vec4 tex = vec4(1.0);\n        if (t.y == 1.0) {\n            tex = (texture(iChannel0,vec2(nor.x,nor.y)));\n            tex.rgb*= 1.0;\n        }\n        col = amb*vec3(0.2);\n        col += dif*vec3(1.0)*sha;\n        col = pow(col,vec3(0.4545));\n        col *= tex.rgb;\n    }\n    \n\tfragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": "XsfGRn", "previewfilepath": "/media/ap/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Ml3XRf.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 30, 30, 157], [159, 159, 188, 188, 255], [257, 257, 280, 280, 408], [410, 410, 440, 440, 643], [645, 645, 689, 689, 939], [941, 941, 983, 983, 1197], [1199, 1199, 1256, 1256, 2254]], "test": "error"}
{"id": "Ml3XW2", "name": "krew-spiral", "author": "krew", "description": "Simple shader", "tags": ["learning"], "likes": 7, "viewed": 148, "published": "Public", "date": "1481609724", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define t iTime\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 p = (fragCoord - .5*iResolution.xy);\n    p = 2.*p/iResolution.y;\n    vec3 c = vec3(.1, .1, .1);\n    vec3 axis = vec3(1, 1, 1);\n    \n    //p += .25*vec2(-sin(t), cos(t));\n    \n    float a = atan(p.y, p.x);\n    float r = smoothstep(0.025, 2., length(p));\n    for (float i = 1.; i < 10.; ++i) {\n        float f = sin((i*log(r) - 6.*t) + a);\n        c = c*.85 - i/10.*vec3(.25, .25, .25) + 4.*vec3(r) * vec3(.5*i*cos(t), .5+.5*sin(t) + .5, .5 + .5 * cos(log(r+t))) * vec3(smoothstep(.75, 1., f));\n    }\n    \n    \n    //c *= axis * smoothstep(.005, .011, abs(p.y));\n    //c *= axis * smoothstep(.005, .011, abs(p.x));\n\t   \n\n    fragColor = vec4(c, 1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Ml3XW2.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[17, 17, 74, 74, 729]], "test": "valid"}
{"id": "Ml3XWB", "name": "Space Flora", "author": "zackpudil", "description": "Space Maintenance 2.  Sometimes the sequel is better than the original.", "tags": ["2d", "fractal"], "likes": 9, "viewed": 248, "published": "Public", "date": "1481397069", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float time() { return  iTime; }\nfloat hash(float n) {\n\treturn fract(sin(n)*43578.5453);\n}\n\nfloat noise(float n) {\n\tfloat p = floor(n);\n\tfloat f = fract(n);\n\tf = f*f*(3.0 - 2.0*f);\n\t\n\treturn mix(hash(p), hash(p + 1.0), f);\n}\n\nfloat formula(vec2 p) {\n  float at = 1.3 + time()*0.05;\n  p = 0.07*p - vec2(0.86*sin(at), 0.7*cos(at));\n  float d = 100.0;\n  \n  for(int i = 0; i < 10; i++) {\n    p = abs(p)/dot(p, p) - vec2(0.5);\n    d = min(d, abs(2.0*p.x)); \n  }\n  \n  return d;\n}\n\nvec3 bump(vec2 p, float e) {\n  vec2 h = vec2(e, 0.0);\n  vec3 g = vec3(\n    formula(p + h.xy) - formula(p - h.xy),\n    formula(p + h.yx) - formula(p - h.yx),\n    -0.3)/e;\n  \n  return g;\n}\n\nfloat lde(vec2 p) {\n    if(iMouse.z <= 0.0) {\n        float c = floor(time());\n        c = 3.14159*noise(time());\n\n        p *= mat2(cos(c), sin(c), -sin(c), cos(c));\n        p.y += 2.0*cos(time());\n    } else {\n        p -= (-iResolution.xy + 2.0*iMouse.xy)/iResolution.y;\n    }\n\treturn length(p) - 0.005;\n}\n\nvec3 light(vec2 p, float d) {\n\tvec2 h = vec2(max(d, 0.3), 0.0);\n\tvec3 l = normalize(vec3(\n\t\tlde(p + h) - lde(p - h),\n\t\tlde(p + h.yx) - lde(p - h.yx),\n\t\t0.3));\n\t\n\treturn -l;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\tvec2 p = (-iResolution.xy + 2.0*fragCoord)/iResolution.y;\n\tvec3 col = vec3(0);\n    \n\tvec3 rd = normalize(vec3(p, 1.97));\n\tvec3 sn = normalize(bump(p, 0.01));  \n\tvec3 re = reflect(rd, sn);\n    \n\tfloat dis = lde(p);\n\tvec3 lig = light(p, dis);\n\tfloat att = 1.0/(1.0 + 0.0*dis + 50.0*dis*dis);\n\tcol += att*vec3(0.2, 1.0, 0.3)*clamp(dot(lig, sn), 0.0, 1.0);\n    \n\tcol += 1.0*pow(clamp(dot(-rd, re), 0.0, 1.0), 8.0);\n\tcol *= 3.0*formula(p);\n    \n\tcol = mix(vec3(0.2, 1.0, 0.3), col, smoothstep(0.0, 0.04, lde(p)));\n    \n\tcol = pow(col, vec3(1.0/2.2));\n\tfragColor = vec4(col, 1);\n\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Ml3XWB.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 14, 14, 31], [32, 32, 53, 53, 89], [91, 91, 113, 113, 223], [225, 225, 248, 248, 472], [474, 474, 502, 502, 660], [662, 662, 681, 681, 970], [972, 972, 1001, 1001, 1146], [1148, 1148, 1205, 1205, 1782]], "test": "valid"}
{"id": "Ml3XWX", "name": "Tamby's Snowflakes", "author": "TambakoJaguar", "description": "A 3D, not really realistic but artistic presentation of falling snow... Please tell me what you think! :)\nUse the mouse to rotate around.\nI know if could be optimized to be faster...", "tags": ["3d", "bokeh", "star", "falling", "snow", "snowflakes"], "likes": 19, "viewed": 930, "published": "Public", "date": "1482097471", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/*\n\"Tamby's Snowflakes\" by Emmanuel Keller aka Tambako - December 2016\nLicense Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\nContact: tamby@tambako.ch\n*/\n\n#define pi 3.14159265359\n\n// Switches, you can play with them!\n#define diffraction\n#define sin_movement\n#define star_flakes\n\n// Campera parameters\nvec3 campos;\nvec3 camtarget = vec3(0., 0., 0.);\nvec3 camdir = vec3(0., 0., 0.);\nfloat fov = 3.8;\n\nconst vec3 skyColor = vec3(0.7, 0.73, 0.78);\nconst float fogdens = 0.08;\n\n// Snow parameters\nconst vec3 snowColor = vec3(0.9, 0.95, 1.0);\nconst int nbFlakes = 1000;\nconst float flakeGlobalIntensity = 1.8;\nconst vec3 flakedomain = vec3(10., 7., 10.);\nconst float flakeMinSpeed = 1.7;\nconst float flakeMaxSpeed = 4.2;\nconst float flakeMinSinVariation = 0.02;\nconst float flakeMaxSinVariation = 0.07;\nconst float flakeMinFreq = 5.;\nconst float flakeMaxFreq = 12.;\nconst vec2 flakeWindFact = vec2(0.45, 0.08);\n\n// Some parameters of the star of orbs\nconst float starNbBranches = 6.;\nconst float starPow = 1.5;\nconst float starStrength = 1.2;\n\nvec2 rotateVec(vec2 vect, float angle)\n{\n    vec2 rv;\n    rv.x = vect.x*cos(angle) - vect.y*sin(angle);\n    rv.y = vect.x*sin(angle) + vect.y*cos(angle);\n    return rv;\n}\n\n// 1D hash function\nfloat hash(float n)\n{\n    return fract(sin(n)*753.5453123);\n}\n\n// From https://www.shadertoy.com/view/4sfGzS\nfloat noise(vec3 x)\n{\n    //x.x = mod(x.x, 0.4);\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n\t\n    float n = p.x + p.y*157.0 + 113.0*p.z;\n    return mix(mix(mix(hash(n+  0.0), hash(n+  1.0),f.x),\n                   mix(hash(n+157.0), hash(n+158.0),f.x),f.y),\n               mix(mix(hash(n+113.0), hash(n+114.0),f.x),\n                   mix(hash(n+270.0), hash(n+271.0),f.x),f.y),f.z);\n}\n\nvec3 colorRamp3(vec3 col1, vec3 col2, vec3 col3, float v)\n{\n   return mix(mix(col1, col2, smoothstep(0.0, 0.5, v)), col3, smoothstep(0.5, 1.0, v));   \n}\n\n// Gets the color of the sky\nvec3 sky_color(vec3 ray)\n{ \n    return skyColor*(1. + 0.35*ray.y);\n}\n\nfloat rand(float min, float max, float seed)\n{\n    return min + (max - min)*hash(seed);\n}\n\nvec3 getFlakePosition(int flakeNr, float t)\n{\n    float fn = float(flakeNr);\n    float s = rand(flakeMinSpeed, flakeMaxSpeed, fn*348. + 173.);\n    float posY = mod(-(t + 15.*hash(fn*1613. + 1354.))*s, flakedomain.y*2.) - flakedomain.y;\n    float posX = rand(-flakedomain.x, flakedomain.x, fn*743. + 514.) + posY*flakeWindFact.x;\n    float posZ = rand(-flakedomain.z, flakedomain.z, fn*284. + 483.) + posY*flakeWindFact.y;\n\n    #ifdef sin_movement\n    float sinvar = rand(flakeMinSinVariation, flakeMaxSinVariation, fn*842. + 951.);\n    float sinfreq = rand(flakeMinFreq, flakeMaxFreq, fn*348. + 173.);\n    float dd = hash(fn*235. + 934.);\n    posX+= sinvar*sin(t*sinfreq)*dd;\n    posZ+= sinvar*sin(t*sinfreq)*sqrt(1. - dd*dd);\n    #endif\n    \n    vec3 pos = vec3(posX, posY, posZ);\n    return pos;\n}\n\nfloat nppow(float x, float p)\n{\n    return sign(x)*pow(abs(x), p);   \n}\n\nfloat getSnowProfile(float val, float dist, vec3 fpos, vec3 ray, int flakeNr)\n{\n    float val2 = -log(1. - val);\n    \n    #ifdef star_flakes\n    // Complicated stuff to calculate the star shape of the snow flakes by making a 3D to 2D projection\n    // From: http://stackoverflow.com/questions/23472048/projecting-3d-points-to-2d-plane\n    if (dist<1.2)\n    {\n        vec3 v3 = (fpos - campos) - dot((fpos - campos), ray) * ray;\n        vec3 vx = vec3(1., 0., 0.);\n        vx.xy = rotateVec(vx.xy, 2.*float(flakeNr)*152.5 + iTime*0.4);\n        vx = normalize(vx - dot(vx, ray)*ray);\n        vec3 vy = vec3(ray.y*vx.z - ray.z*vx.y, ray.z*vx.x - ray.x*vx.z, ray.x*vx.y - ray.y*vx.x);\n\n        float a = atan(dot(v3, vx)/dot(v3, vy));\n\n        float spp = 1. + starStrength*nppow(sin(a*starNbBranches), starPow);\n        val2+= 1.3*spp*pow(smoothstep(1.6, 0.1, dist), 2.0);\n    }\n    #endif  \n    \n    float delta = 1.5 - 0.9/pow(dist + 1., 0.3);\n    float midpoint = 10./pow(dist + 0.1, 0.3);\n    float pr = smoothstep(midpoint - delta*.5, midpoint + delta*.5, val2);\n    \n    float d = 1. - pow(abs(1. - 2.*pr), 2.);\n    float f = 1.3/(pow(dist + .8, 2.5));\n    \n    #ifdef diffraction\n    if (val2<8.)\n       pr+= 32.*pow(f, 1.5)*max(0., dist - 2.)*d*(0.5 + sin(val2*230./(3.8 + dist) - midpoint*90.)*0.5);\n    #endif\n    \n    return pr*f*flakeGlobalIntensity;\n}\n\nvec3 getFlakes(vec3 ray)\n{\n\tvec3 rc1 = vec3(0.);\n    vec3 rc2 = vec3(0.);\n    float lintensity;\n    vec3 fpos;\n    float lp;\n    \n    for (int l=0; l<nbFlakes; l++)\n    {\n        fpos = getFlakePosition(l, iTime);\n        \n        float val = max(0.0, dot(ray, normalize(fpos - campos)));\n        if (val>0.996)\n        {\n            float dist1 = distance(camtarget, fpos);\n            float dist2 = distance(campos, fpos);\n            float dist = max(5.2*pow(dist1 / dist2, 1.7), 0.32);\n            lp = getSnowProfile(val, dist, fpos, ray, l);\n\n            // Fog\n            lp*= clamp(exp(-pow(fogdens*dist2, 2.)), 0., 1.);\n        \n            // Flakes appear progressively in the domain along the y axis\n            lp*= smoothstep(-flakedomain.y, -flakedomain.y*0.75, fpos.y);\n            lp*= smoothstep(flakedomain.y, flakedomain.y*0.75, fpos.y);\n\n            rc1+= clamp(normalize(mix(snowColor, vec3(1.), 0.55*lp))*lp, 0., 1.);\n            rc2 = max(rc2, clamp(normalize(mix(snowColor, vec3(1.), 0.55*lp))*lp, 0., 1.));\n        }\n        else\n           lp = 0.;\n    }\n    return mix(rc1, rc2, 0.7);\n}\n\n// From https://www.shadertoy.com/view/lsSXzD, modified\nvec3 GetCameraRayDir(vec2 vWindow, vec3 vCameraDir, float fov)\n{\n\tvec3 vForward = normalize(vCameraDir);\n\tvec3 vRight = normalize(cross(vec3(0.0, 1.0, 0.0), vForward));\n\tvec3 vUp = normalize(cross(vForward, vRight));\n    \n\tvec3 vDir = normalize(vWindow.x * vRight + vWindow.y * vUp + vForward * fov);\n\n\treturn vDir;\n}\n\n// Sets the position of the camera with the mouse and calculates its direction\nconst float axm = 4.;\nconst float aym = 1.5;\nvoid setCamera()\n{\n   vec2 iMouse2;\n   if (iMouse.x==0. && iMouse.y==0.)\n      iMouse2 = vec2(0.5, 0.5);\n   else\n      iMouse2 = iMouse.xy/iResolution.xy;\n   \n   campos = vec3(8.5, 0., 0.);\n   campos.xy = rotateVec(campos.xy, -iMouse2.y*aym + aym*0.5);\n   campos.yz = rotateVec(campos.yz, -iMouse2.y*aym + aym*0.5);\n   campos.xz = rotateVec(campos.xz, -iMouse2.x*axm);\n\n   camtarget = vec3(0.);\n   camdir = camtarget - campos;   \n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{   \n    setCamera();\n    \n  \tvec2 uv = fragCoord.xy / iResolution.xy; \n  \tuv = uv*2.0 - 1.0;\n  \tuv.x*= iResolution.x / iResolution.y;\n  \tvec3 ray = GetCameraRayDir(uv, camdir, fov);\n    \n    vec3 col = sky_color(ray);\n    col+= getFlakes(ray);\n\n  \tfragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Ml3XWX.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[1069, 1069, 1109, 1109, 1239], [1241, 1261, 1282, 1282, 1322], [1324, 1370, 1391, 1418, 1783], [1785, 1785, 1844, 1844, 1937], [1939, 1968, 1994, 1994, 2036], [2038, 2038, 2084, 2084, 2127], [2129, 2129, 2174, 2174, 2928], [2930, 2930, 2961, 2961, 3001], [3003, 3003, 3082, 3082, 4364], [4366, 4366, 4392, 4392, 5481], [5483, 5539, 5603, 5603, 5856], [5982, 5982, 6000, 6000, 6413], [6415, 6415, 6470, 6470, 6747]], "test": "valid"}
{"id": "MlcSDX", "name": "Pretty Ground, Breaking.", "author": "Hadyn", "description": "A little update of my previous shader, adding in perspective projection and a second layer to help convey a sense of depth. Apologies for messy/un-commented source; I'll try to come back to tidy it up a bit later on.", "tags": ["voronoi"], "likes": 50, "viewed": 683, "published": "Public", "date": "1481970760", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Made by hadyn lander\n\n// Based on original code by by inigo quilez - iq/2013\n// https://www.shadertoy.com/view/ldl3W8\n// http://www.iquilezles.org/www/articles/voronoilines/voronoilines.htm\n\n#define MAXDEPTH 60.\n#define FOGSTART 8.\n#define FOGCOLOR vec3(1,1,1)\n#define FOV 120.\n#define NEARPLANE 0.0001\n#define UP vec3(0.0, 1.0, 0.0)\n\n\nvec2 hash2( vec2 p )\n{\n\t// texture based white noise\n\treturn texture( iChannel0, (p+0.5)/256.0, -100.0 ).xy;\n\t\n    // procedural white noise\t\n\t//return fract(sin(vec2(dot(p,vec2(127.1,311.7)),dot(p,vec2(269.5,183.3))))*43758.5453);\n}\n\nvec4 voronoi( in vec2 x )\n{\n    vec2 n = floor(x);\n    vec2 f = fract(x);\n\tvec2 o;\n    //----------------------------------\n    // first pass: regular voronoi\n    //----------------------------------\n\tvec2 mg, mr;\n\tfloat oldDist;\n    \n    float md = 8.0;\n    for( int j=-1; j<=1; j++ )\n    for( int i=-1; i<=1; i++ )\n    {\n        vec2 g = vec2(float(i),float(j));\n\t\to = hash2( n + g );\n        vec2 r = g + o - f;\n        float d = dot(r,r);\n\n        if( d<md )\n        {\n            md = d;\n            mr = r;\n            mg = g;\n        }\n    }\n\t\n    oldDist = md;\n    \n    //----------------------------------\n    // second pass: distance to borders\n    //----------------------------------\n    md = 8.0;\n    for( int j=-2; j<=2; j++ )\n    for( int i=-2; i<=2; i++ )\n    {\n        vec2 g = mg + vec2(float(i),float(j));\n\t\to = hash2( n + g );\n        vec2 r = g + o - f;\n\n        if( dot(mr-r,mr-r)>0.00001 )\n        md = min( md, dot( 0.5*(mr+r), normalize(r-mr) ) );\n    }\n\n    return vec4( md, mr, oldDist );\n}\n\n// I borrowed this useful function from: http://www.neilmendoza.com/glsl-rotation-about-an-arbitrary-axis/\nmat4 rotationMatrix(vec3 axis, float angle)\n{\n    axis = normalize(axis);\n    float s = sin(angle);\n    float c = cos(angle);\n    float oc = 1.0 - c;\n    \n    return mat4(oc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s,  0.0,\n                oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s,  0.0,\n                oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c,           0.0,\n                0.0,                                0.0,                                0.0,                                1.0);\n}\n\nvec3 getPlaneIntersectPhase(vec3 ro, vec3 rd, float planeY)\n{\n    \n    float intersect = (planeY-(ro+rd).y)/normalize(rd).y;\n    if( intersect > 0.0)\n    {        \n        float twistSpeed = 2.0;\n        float twistScale = 1.25;\n        \n        vec3 p = ro+rd+normalize(rd)*intersect;\n        vec4 c = voronoi( p.xz );\n         \n        float camDist = max(-0.35+max(p.z-ro.z, 0.0)*0.6, 0.0);\n        float edgePhase = abs(p.x+(sin(twistSpeed*p.z*0.35)*1.0+sin(twistSpeed*p.z*0.5156)*0.35+sin(twistSpeed*p.z*1.241)*0.15)*twistScale);\n\n        edgePhase *= 0.05;        \n\t\tedgePhase -= -0.925 + pow(0.065*camDist, 1.4);        \n        edgePhase = mix(edgePhase, 1.0, ( 1.0-clamp(0.25*camDist, 0.0, 1.0)));        \n        edgePhase = clamp(edgePhase, 0.0, 1.0);             \n\t\tedgePhase = 1.0- pow(edgePhase,2.0);\n        \n  //    p.xz += c.yz;\n  //    camDist = max(p.z-camPosition.z +1.0, 0.0)*1.4;\n  //    float cellPhase = abs(p.x+(sin(twistSpeed*p.z*0.35)*1.0+sin(twistSpeed*p.z*0.5156)*0.35+sin(twistSpeed*p.z*1.241)*0.15)*twistScale);\n  //    cellPhase -= 0.5;\n  //    cellPhase /= max(pow(camDist, 1.6), 1.0);        \n  //    cellPhase = pow(clamp(1.0-cellPhase, 0.0, 1.0), 16.0);\n  //    cellPhase *= min(0.05*camDist, 1.0);\n  //    cellPhase = pow(cellPhase, 2.0);\n        \n        return vec3(edgePhase, c.x, intersect);      \n     }\n    return vec3(0.0, 0.0, 1.0/0.0);  \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n\tvec2 uv = fragCoord.xy / iResolution.y;\n    uv -= 0.5*vec2(iResolution.x/iResolution.y, 1); \n    \n    float camDist = 1.0/tan(radians(FOV*0.5));\n    \n    vec2 mouse = vec2(0.0);    \n\tif( iMouse.z>0.0 )\n        mouse = 2.0*iMouse.xy/iResolution.y-vec2(iResolution.x/iResolution.y,1);\n    vec3 camForward = vec3(0, 0, 1);\n    camForward = mat3(rotationMatrix(UP, mouse.x*-radians(90.0))) * camForward;\n\tvec3 camRight = cross(UP, camForward);\n    camRight = mat3(rotationMatrix(camForward, radians(8.0))) * camRight;\n    camForward = mat3(rotationMatrix(camRight, mouse.y*radians(90.0) + radians(-40.0))) * camForward;\n\tvec3 camUp = cross(camForward, camRight);\n    vec3 vectorToPixel = vec3(uv.xy,camDist)*NEARPLANE;\n   \tvectorToPixel = (uv.x*camRight + uv.y*camUp + camDist*camForward)*NEARPLANE;\n    vec3 camPosition = vec3(2.0,3.0,0) + vec3(0,0,-3.5*iTime);// + vec3((iMouse.xy/iResolution.xy-vec2(0.5,0.5))*1.0,0.0);\n    \n //   float rumbleSpeed = 100.0;\n //   float rumbleAmount = 0.025*(sin(rumbleSpeed*iTime*0.35)*1.0+sin(rumbleSpeed*iTime*0.37)*0.35+sin(rumbleSpeed*iTime*1.241)*0.15);\n //   camPosition += vec3(0,rumbleAmount,0);\n    \n    vec4 pixel = vec4(0,0,0,1.0/0.0);\n    \n    vec3 phase = getPlaneIntersectPhase(camPosition, vectorToPixel, -1.0);\n    pixel.rgb = vec3(phase.y);\n    pixel.rgb = mix( vec3(1.0,0.1,0.0), vec3(0.6,0.05,0.0), smoothstep( phase.x-0.025, phase.x, phase.y ) );  \n    \n    phase = getPlaneIntersectPhase(camPosition, vectorToPixel, -0.9);\n    pixel.rgb = mix( pixel.rgb, vec3(1.0), smoothstep(phase.x-0.025, phase.x, phase.y) );\n    \n    //pixel.rgb = vec3(phase.x);\n    \n    pixel.w = phase.z; \n    \n    \n    float fogStrength = clamp(pow(max(pixel.w-FOGSTART,0.0)/(MAXDEPTH-FOGSTART), 0.85), 0.0, 1.0);\n    fragColor = vec4(pixel.rgb*(1.0-fogStrength) + FOGCOLOR*fogStrength, 1.0);\n}", "image_inputs": [{"id": "Xsf3zn", "previewfilepath": "/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MlcSDX.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[339, 339, 361, 391, 572], [574, 574, 601, 601, 1591], [1593, 1700, 1745, 1745, 2373], [2375, 2375, 2436, 2436, 3760], [3762, 3762, 3819, 3819, 5649]], "test": "error"}
{"id": "MlcXRl", "name": "Fractal Experiment 23", "author": "aiekick", "description": "click for see the full fractal 1/(z+c)", "tags": ["fractal", "experiment", "23"], "likes": 13, "viewed": 638, "published": "Public API", "date": "1481094225", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// z * z\nvec2 zmul(vec2 a, vec2 b)\n{\n\t//return vec2(a.x*b.x-a.y*b.y, a.x*b.y+b.x*a.y);\n    return mat2(a,-a.y,a.x)*b;\n}\n\n// 1 / z\nvec2 zinv(vec2 a)\n{\n\treturn vec2(a.x, -a.y) / dot(a,a);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 g = fragCoord.xy;\n    \n\tvec2 si = iResolution.xy;\n    \n    vec2 uv = (g+g-si)/min(si.x,si.y) ;\n    \n    uv *= 30. * (sin(10.6+iTime * 0.01)*.5+.5);//zoom\n    \n    uv += vec2(-0.46022,0.746155);\n    \n\tif (iMouse.z > 0.)\n        uv = (g+g-si)/min(si.x,si.y) * 2.;\n    \n\tvec2 z = uv;\n\t\n\tvec2 c = vec2(0.66,1.23);\n\t\n\tfloat it = 0.;\n    for (int i=0;i<600;i++)\n    {\n        z = zinv(zmul(z, z) + c);\n        if( dot(z,z)>4. ) break;\n        it++;\n    }\n    \n\tfloat sit = it-it/(log2(log2(dot(z,z))));\n    \n    fragColor = 0.5 + 0.5 * cos( 3. + sit*0.2 + vec4(0,0.6,1,1));\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MlcXRl.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 9, 36, 86, 119], [121, 130, 149, 149, 187], [189, 189, 246, 246, 822]], "test": "valid"}
{"id": "MldSDj", "name": "cycle jour/nuit", "author": "titgros35", "description": "jour/nuit", "tags": ["sun"], "likes": 0, "viewed": 64, "published": "Public", "date": "1481710548", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 color, in vec2 pixCoords )\n{\n   \tfloat PI = 3.14;\n    float centerX = iResolution.x / 2.0 + cos(iTime*0.2) * 666.0 ;\n    float centerY = iResolution.y / 3.6 + sin(iTime*0.2) * 666.0 ;\n    float centerX1 = iResolution.x / 2.0 - cos(iTime*0.2) * 666.0 ;\n    float centerY1 = iResolution.y / 3.0 - sin(iTime*0.2) * 666.0 ;\n    float radius = 50.0 ;\n    float lenght = sqrt(pow(centerX - pixCoords.x, 2.0) + pow(centerY - pixCoords.y, 2.00));\n    float lenght1 = sqrt(pow(centerX1 - pixCoords.x, 2.0) + pow(centerY1 - pixCoords.y, 2.00));\n    float sea1 = 80.0 + 20.0 * cos(iTime - pixCoords.x * 0.2 * 3.0/ 60.0)*cos(iTime * 0.4 * 20.0/ 10.0);\n    float sea2 = 110.0 + 20.0 * cos(iTime + pixCoords.x * 0.2 * 4.0/ 55.0)*cos(iTime * 0.3 * 20.0/ 10.0);\n    float sea3 = 140.0 + 20.0 * cos(iTime - pixCoords.x * 0.2 * 7.0/ 50.0)*cos(iTime * 0.4 * 20.0/ 10.0);\n    float sea4 = 170.0 + 20.0 * cos(iTime + pixCoords.x * 0.2 * 9.0/ 45.0)*cos(iTime * 0.3 * 20.0/ 10.0);\n    float sea5 = 200.0 + 20.0 * cos(iTime - pixCoords.x * 0.2 * 11.0/ 40.0)*cos(iTime * 0.4 * 20.0/ 10.0);\n    float beach = 20.0 * cos (pixCoords.x * 0.2 /20.0);\n        \n    if (pixCoords.y < beach) {\n        color = vec4(centerY / iResolution.y, centerY / iResolution.y, 0.0, 0.0);\n        return;\n        }\n    \n    if (pixCoords.y < sea1){\n        color = vec4(0.0, 0.0, 0.1 * centerY / iResolution.y, 1.0); \n\t\treturn;\n    }\n    \n    if (pixCoords.y < sea2){\n        color = vec4(0.0, 0.0, 0.3 * centerY / iResolution.y, 1.0);\n\t\treturn;\n    }\n    \n    if (pixCoords.y < sea3){\n        color = vec4(0.0, 0.0, 0.4 * centerY / iResolution.y, 1.0); \n\t\treturn;\n    }\n    \n    if (pixCoords.y < sea4){\n        color = vec4(0.0, 0.0, 0.5 * centerY / iResolution.y, 1.0); \n\t\treturn;\n    }\n    \n    if (pixCoords.y < sea5){\n        color = vec4(0.0, 0.0, 0.6 * centerY / iResolution.y, 1.0); \n\t\treturn;\n    }\n    \n    if (lenght < radius){\n        color= vec4(1.0, 1.0, 0.0, 1.0);\n        return;\n    }\n\t\n    else color = vec4(0.0, 0.0, 1.0, 1.0);\n    \n    if (lenght1 < radius){\n        color= vec4(0.8,0.8,0.8,0.8);\n        return;\n    }\n    \n    color = vec4 (0.05, 0.5 * centerY /  iResolution.y, 1.0 * centerY /  iResolution.y, 1.0);\n    \n   // color = texture(iChannel0, pixCoords/iResolution.xy); \n}   ", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MldSDj.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 53, 53, 2285]], "test": "valid"}
{"id": "MldSWB", "name": "Blue Tornado", "author": "Ark", "description": "https://www.shadertoy.com/view/4tdSDS", "tags": ["transformation"], "likes": 3, "viewed": 2118, "published": "Public", "date": "1481720649", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI 3.14159265359\n#define INF 1e10\n#define EPS 1e-10\n#define ITER_MAX 10000\n\nfloat crs(vec2 v1, vec2 v2) {\n    return v1.x*v2.y - v1.y*v2.x;\n}\n\nvec2 rotate(vec2 p, float rad) {\n    return mat2(cos(rad), -sin(rad), sin(rad), cos(rad)) * p;\n}\n\n// smooth min\n// reference: http://iquilezles.org/www/articles/smin/smin.htm\nfloat smin(float a, float b, float k) {\n    float res = exp(-k*a) + exp(-k*b);\n    return -log(res)/k;\n}\n\nfloat ellipse(vec2 p, vec2 r) {\n    return (length(p/r) - 1.0) * min(r.x, r.y);\n}\n\nfloat line(vec2 p, vec2 v1, vec2 v2) {\n    p  -= v1;\n    vec2 v = v2-v1;\n    float t = dot(p, normalize(v));\n    if (t<0.0) {\n        return length(p);\n    } else if (t>length(v)) {\n        return length(p-v);\n    } else {\n        return abs(crs(p, normalize(v)));\n    }\n}\n\nbool innerTriangle(vec2 p, vec2 v1, vec2 v2, vec2 v3) {\n    float c1 = crs(v2-v1, p-v1);\n    float c2 = crs(v3-v2, p-v2);\n    float c3 = crs(v1-v3, p-v3);\n    return (c1>0.0&&c2>0.0&&c3>0.0) || (c1<0.0&&c2<0.0&&c3<0.0);\n}\n\nfloat StarPolygon(vec2 p, int n, int m, float r) {\n    float d = INF;\n    for (int i=0; i<ITER_MAX; i++) {\n        if (i >= n) break;\n        \n        float rad1 = 2.0*PI*float(i)/float(n);\n        float rad2 = 2.0*PI*float(i+m)/float(n);\n        vec2 v1 = vec2(cos(rad1), sin(rad1)) * r;\n        vec2 v2 = vec2(cos(rad2), sin(rad2)) * r;\n        bool flg = innerTriangle(p, vec2(0.0), v1, v2);\n        d = min(d, line(p, v1, v2) * (flg?-1.0:1.0));\n    }\n    return d;\n}\n\nvec3 calc(vec2 p) {\n    float t = iTime;\n    float r = (sin(t*PI)+1.0) * 0.3 + EPS;\n    p = rotate(p, (length(p) * 2.0 - t*2.0)*PI);\n    float d1 = StarPolygon(p, 5, 2, r);\n    float d2 = ellipse(p, vec2(0.01));\n    float d = smin(d1, d2, 3.5);\n    return vec3(pow(clamp(1.0-d, 0.0, INF), 5.0)) * vec3(0.1, 0.35, 0.95);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\tvec2 uv = (2.0*fragCoord.xy-iResolution.xy) / min(iResolution.x, iResolution.y);\n\tfragColor = vec4(calc(uv),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MldSWB.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[84, 84, 113, 113, 149], [151, 151, 183, 183, 247], [249, 326, 365, 365, 430], [432, 432, 463, 463, 513], [515, 515, 553, 553, 787], [789, 789, 844, 844, 1010], [1012, 1012, 1062, 1062, 1482], [1484, 1484, 1503, 1503, 1805], [1807, 1807, 1864, 1864, 1981]], "test": "valid"}
{"id": "MldSWf", "name": "PBR Reference", "author": "acdimalev", "description": "Reverse-engineering 2v_S's PBR_Test to learn how all the pieces fit together.", "tags": ["pbr", "cooktorrance"], "likes": 5, "viewed": 218, "published": "Public", "date": "1481970449", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/*\n* 2v_S's Physically Based Rendering Test\n* https://www.shadertoy.com/view/MlB3DV\n*\n* Modified to experiment with physically-based rendering implementations.\n* https://en.wikipedia.org/wiki/Specular_highlight#Cook.E2.80.93Torrance_model\n* http://graphicrants.blogspot.com/2013/08/specular-brdf-reference.html\n*\n* Starting with:\n* - Geometric Attenuation (G): Cook-Torrance\n* - Distribution (D): Beckmann\n* - Fresnel (F): Schlick\n*\n* Left: a single, constant reflection coefficient for all materials\n*\n* Right: per-material, per-color-channel reflection coefficients\n*/\n\n\n#define NB_LIGHTS 3\n\n// Metals values in linear space\n#define GOLD vec3(1.0, 0.71, 0.29)\n#define COPPER vec3(0.95, 0.64, 0.54)\n#define IRON vec3(0.56, 0.57, 0.58)\n#define ALUMINIUM vec3(0.91, 0.92, 0.92)\n#define SILVER vec3(0.95, 0.93, 0.88)\n\nfloat splitFromFragCoord(vec2 fragCoord) {\n    return floor(2.0 * fragCoord.x / iResolution.x);\n}\n\nfloat fPlane( vec3 p, vec4 n )\n{\n  // n must be normalized\n  return dot(p,n.xyz) + n.w;\n}\n\nfloat fSphere( vec3 p, float s )\n{\n    return length(p)-s;\n}\nfloat opS( float d1, float d2 )\n{\n    return max(-d2,d1);\n}\n\nvec2 opU( vec2 d1, vec2 d2 )\n{\n\treturn (d1.x<d2.x) ? d1 : d2;\n}\n\nvec3 opRep( vec3 p, vec3 c )\n{\n    return mod(p,c)-0.5*c;\n}\n// ---- Scene definition\nvec2 fScene(vec3 p) {\n    \n    vec3 pSphere = p/*opRep(p, vec3( 2.0, 0.0, 2.0))*/;\n    \n \tvec2 sphere0 = vec2(fSphere(p, 1.0), 0.5); \t\n    vec2 sphere1 = vec2(fSphere(p+vec3(2.1, 0.0, 2.0), 1.0), 2.5);\n\tvec2 sphere2 = vec2(fSphere(p+vec3(-2.1, 0.0, 2.0), 1.0), 3.5);\n    vec2 sphere3 = vec2(fSphere(p+vec3(2.1, 0.0, -2.0), 1.0), 4.5);\n    vec2 sphere4 = vec2(fSphere(p+vec3(-2.1, 0.0, -2.0), 1.0), 5.5);\n\t\n\n\n    vec2 plane = vec2(fPlane(p, vec4(0, 1, 0, 1.0)), 1.5);\n    \n    return opU(opU(opU(opU(opU(plane, sphere0), sphere1), sphere2), sphere3), sphere4);\n}\n// -----\n\nvec2 castRay( in vec3 ro, in vec3 rd )\n{\n    float tmin = 1.0;\n    float tmax = 100.0;\n    \n    \n\tfloat precis = 0.00001;\n    float t = tmin;\n    float m = -1.0;\n    for( int i=0; i<50; i++ )\n    {\n\t    vec2 res = fScene( ro+rd*t );\n        if( res.x<precis || t>tmax ) break;\n        t += res.x;\n\t    m = res.y;\n    }\n\n    if( t>tmax ) m=-1.0;\n    return vec2( t, m );\n}\n\n\nfloat softshadow( in vec3 ro, in vec3 rd, in float mint, in float tmax )\n{\n\tfloat res = 1.0;\n    float t = mint;\n    for( int i=0; i<16; i++ )\n    {\n\t\tfloat h = fScene( ro + rd*t ).x;\n        res = min( res, 8.0*h/t );\n        t += clamp( h, 0.02, 0.10 );\n        if( h<0.001 || t>tmax ) break;\n    }\n    return clamp( res, 0.0, 1.0 );\n\n}\n\nvec3 calcNormal( in vec3 pos )\n{\n\tvec3 eps = vec3( 0.001, 0.0, 0.0 );\n\tvec3 nor = vec3(\n\t    fScene(pos+eps.xyy).x - fScene(pos-eps.xyy).x,\n\t    fScene(pos+eps.yxy).x - fScene(pos-eps.yxy).x,\n\t    fScene(pos+eps.yyx).x - fScene(pos-eps.yyx).x );\n\treturn normalize(nor);\n}\n\n\nstruct Light {\n \tvec3 pos;\n    vec3 color;\n};\nLight lights[NB_LIGHTS];\n\n\n#define PI 3.1415\n\nvec3 half_vector(vec3 v1, vec3 v2) {\n    return normalize(v1 + v2);\n}\n\n\n// https://en.wikipedia.org/wiki/Specular_highlight#Cook.E2.80.93Torrance_model\nfloat geometric_attenuation(vec3 n, vec3 v, vec3 l) {\n    vec3 h = half_vector(v, l);\n\n    float c = 2.0 * dot(h, n) / dot(v, h);\n    float g1 = c * dot(v, n);\n    float g2 = c * dot(l, n);\n\n    return min(1.0, min(g1, g2));\n}\n\n\n// https://en.wikipedia.org/wiki/Specular_highlight#Beckmann_distribution\nfloat beckmann_distribution(vec3 n, vec3 v, vec3 l, float roughness) {\n    vec3 h = half_vector(v, l);\n    float m = roughness;\n\n    float n_dot_h = dot(n, h);\n    float n_dot_h_sq = n_dot_h * n_dot_h;\n    float n_dot_h_qu = n_dot_h_sq * n_dot_h_sq;\n    float m_sq = m * m;\n\n    float expr1 = (n_dot_h_sq - 1.0) / (n_dot_h_sq * m_sq);\n    float expr2 = PI * m_sq * n_dot_h_qu;\n\n    return exp(expr1) / expr2;\n}\n\n\n// https://en.wikipedia.org/wiki/Schlick's_approximation\nfloat shlick_fresnel(vec3 n, vec3 v, vec3 l, float reflection_coefficient) {\n    vec3 h = half_vector(v, l);\n    float c = reflection_coefficient;\n\n    float hv = dot(h, v);\n    return c + (1.0 - c) * pow(1.0 - hv, 5.0);\n}\n\n// with a separate reflection coefficient for each color channel\nvec3 shlick_fresnel(vec3 n, vec3 v, vec3 l, vec3 reflection_coefficients) {\n    vec3 h = half_vector(v, l);\n    vec3 c = reflection_coefficients;\n\n    float hv = dot(h, v);\n    return c + (1.0 - c) * pow(1.0 - hv, 5.0);\n}\n\n\n// https://en.wikipedia.org/wiki/Specular_highlight#Cook.E2.80.93Torrance_model\nvec3 computePBRLighting ( in Light light, in vec3 position, in vec3 N, in vec3 V, in vec3 albedo, in float roughness, in vec3 F0, float split ) {\n    vec3 n = N;\n    vec3 v = V;\n    vec3 l = normalize(light.pos.xyz - position);\n    \n    float d = beckmann_distribution(n, v, l, roughness);\n    float g = geometric_attenuation(n, v, l);\n    \n    vec3 specular;\n    if (split == 0.0) {\n        // https://en.wikipedia.org/wiki/Schlick%27s_approximation\n        float n1 = 1.0;\n        float n2 = 3.0/8.0;\n        float reflection_coefficient = pow((n1 - n2) / (n1 + n2), 2.0);\n        float f = shlick_fresnel(n, v, l, reflection_coefficient);\n        float k = d * f * g / (4.0 * dot(v, n) * dot(n, l));\n        specular = vec3(k);\n    }\n    if (split == 1.0) {\n        vec3 reflection_coefficients = F0;\n        vec3 f = shlick_fresnel(n, v, l, reflection_coefficients);\n        vec3 k = d * f * g / (4.0 * dot(v, n) * dot(n, l));\n        specular = k;\n    }\n    \n\tvec3 ambient = vec3(0.01);\n\tvec3 diffuse = albedo / PI;\n\n\n\treturn ambient + (diffuse + specular) * light.color.xyz * dot(n, l);\n}\n\nvec3 addPBR( in vec3 position, in vec3 N, in vec3 V, in vec3 baseColor, in float metalMask, in float smoothness, in float reflectance, float split) {\n\tvec3 color = vec3(0.0);\n\n    float roughness = 1.0 - smoothness*smoothness;\n    vec3 F0 = 0.16*reflectance*reflectance * (1.0-metalMask) + baseColor*metalMask;\n    vec3 albedo = baseColor;\n    \n    float s = 0.0;\n    \n    \n\tfor ( int i = 0; i < NB_LIGHTS; ++i ) {\n\t\tvec3 col = computePBRLighting ( lights[i], position, N, V, albedo, roughness, F0, split);\n\t\tcolor += col;\t\n        s += softshadow( position, normalize(lights[i].pos.xyz - position), 0.02, 2.5 );\n\t}\n\n\treturn color*s;\n}\n\nvec3 render( in vec3 ro, in vec3 rd, float split )\n{ \n    vec3 col = vec3(0.8, 0.9, 1.0)*8.0; // Sky color\n    \n    vec2 res = castRay( ro, rd );\n    float t = res.x;\n    float m = res.y;\n    vec3 p = ro + t*rd;\n    \n    if(m>-0.5) { // Intersection found\n        if( m < 1.0 ) {\n           // float f = mod( floor( 5.0*p.z ) + floor( 5.0*p.x ), 2.0 );\n            vec3 sur = vec3(1.0,1.0,1.0)*smoothstep(-1.0,-0.6,sin(16.0*p.x));\n            col = addPBR( p, calcNormal( p ), -rd, GOLD*sur, sur.x, 0.3+0.6*sur.x, 0.5, split );\n        } \n        else if( m < 2.0 ) {\n            float f = mod( floor( 5.0*p.z ) + floor( 5.0*p.x ), 2.0 );\n            col = addPBR(p, calcNormal( p ), -rd, vec3(0.5), 0.0, 0.3+0.6*f, 0.5, split );\n        }\n        else if( m < 3.0 ) {\n            vec3 sur = vec3(1.0,1.0,1.0)*smoothstep(-1.0,-0.4,sin(18.0*p.x));\n            col = addPBR( p, calcNormal( p ), -rd, COPPER*sur, sur.x, 0.3+0.6*sur.x, 0.5, split );\n        }\n        else if( m < 4.0 ) {\n            vec3 sur = vec3(1.0,1.0,1.0)*smoothstep(-1.0,-0.0995,sin(106.0*p.x))*smoothstep(-1.0,-0.9,sin(47.0*p.z));\n            col = addPBR( p, calcNormal( p ), -rd, vec3(0.2), 1.0-sur.x, 0.9*sur.x, 0.5, split );\n        }\n        else if( m < 5.0 ) {\n            vec3 sur = vec3(1.0)*smoothstep(-1.0,-0.765,sin(24.0*p.x))*smoothstep(-1.0,-0.4,sin(70.9*p.z));\n            col = addPBR( p, calcNormal( p ), -rd, GOLD*(1.0-sur), sur.x, 0.3+0.6*sur.x, 0.5, split );\n        }\n        else if( m < 6.0 ) {\n            vec3 sur = vec3(1.0,1.0,1.0)*smoothstep(-1.0,-0.4,sin(18.0*p.x));\n            col = addPBR( p, calcNormal( p ), -rd, ALUMINIUM*sur, sur.x, 0.3+0.6*sur.x, 0.5, split );\n        }\n    }\n    \n\treturn col;\n}\n\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr )\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\nvec4 hejlToneMapping (in vec4 color) {\n \tvec4 x = max(vec4(0.0), color-vec4(0.004)); \n\treturn (x * ((6.2*x)+vec4(0.5))) / max(x * ((6.2*x)+vec4(1.7))+vec4(0.06), vec4(1e-8));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float time = 0.25*iTime;\n    \n    lights[0] = Light(vec3(0.0, 5.0, .0), vec3(1.0));   \n\tlights[1] = Light(vec3(12.0*sin(iTime), 8.0, 12.0*cos(iTime)), vec3(1.0));   \t\n    lights[2] = Light(vec3(-12.0*cos(-iTime), 8.0, 12.0*sin(-iTime)), vec3(.05));   \n\n   \n\n\tvec2 q = fragCoord.xy/iResolution.xy;\n    vec2 p = -1.0+2.0*q;\n\tp.x *= iResolution.x/iResolution.y;\n    vec2 mo = iMouse.xy/iResolution.xy;\n\t\t \n\t\n\n\t// camera\t\n\tvec3 ro = vec3( 7.0*sin(time), 3.6 , -7.0*cos(time) );\n\tvec3 ta = vec3( 0.0 );\n\t\n\t// camera-to-world transformation\n    mat3 ca = setCamera( ro, ta, 0.0 );\n    \n    // ray direction\n\tvec3 rd = ca * normalize( vec3(p.xy,2.5) );\n    \n    float split = splitFromFragCoord(fragCoord);\n    \n    // render\t\n    vec3 col = render( ro, rd, split );\n\n    #if 0\n        col = pow( col, vec3(0.4545) );\n        fragColor=vec4( col, 1.0 );\n    #else \n    \tfloat exposure = 1.0/8.0 + 0.023*sin(time-3.14);\n   \t\tfragColor = hejlToneMapping(vec4(col, 1.0) * exposure) ;\n    #endif\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MldSWf.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[816, 816, 858, 858, 913], [915, 915, 947, 973, 1004], [1006, 1006, 1040, 1040, 1066], [1067, 1067, 1100, 1100, 1126], [1128, 1128, 1158, 1158, 1191], [1193, 1193, 1223, 1223, 1252], [1253, 1278, 1299, 1299, 1839], [1850, 1850, 1890, 1890, 2221], [2224, 2224, 2298, 2298, 2562], [2564, 2564, 2596, 2596, 2835], [2930, 2930, 2966, 2966, 2999], [3002, 3082, 3135, 3135, 3308], [3311, 3385, 3455, 3455, 3795], [3798, 3855, 3931, 3931, 4077], [4079, 4144, 4219, 4219, 4365], [4368, 4448, 4593, 4593, 5542], [5544, 5544, 5693, 5693, 6179], [6181, 6181, 6233, 6233, 7886], [7888, 7888, 7940, 7940, 8117], [8119, 8119, 8157, 8157, 8295], [8297, 8297, 8354, 8354, 9345]], "test": "valid"}
{"id": "MldSz2", "name": "Sine Art", "author": "TrueBoolean", "description": "Patterns made from adding sine patterns.", "tags": ["plasma", "sine"], "likes": 1, "viewed": 94, "published": "Public", "date": "1480712205", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 OUT, vec2 uv )\n{\n    const float PI = atan(0.,-1.);\n\tuv=(uv/iResolution.y)*PI;\n    uv/=uv.x-PI;\n    float x=uv.x+sin(iTime), y=uv.y+iTime;\n    float func=sin(x * 2.)+sin(y * 8.)+sin((x+y) *4.);\n\tOUT = vec4( vec3(func + uv.y/20.), 1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MldSz2.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 41, 41, 261]], "test": "valid"}
{"id": "MldXD2", "name": "Sunset + Sun Pulse", "author": "AFlorent", "description": "Test d'un sunset", "tags": ["cours"], "likes": 0, "viewed": 72, "published": "Public", "date": "1481723931", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 color, in vec2 pixCoords )\n{\n\tcolor = vec4(1.0, 0.4, 0.0, 1.0);\n    vec2 center = iResolution.xy / 2.0;\n    float distance = sqrt(pow(pixCoords.x - iResolution.x, 2.0) + cos(2.0 * 3.14 / 180.0 * pixCoords.x * iTime) + pow(pixCoords.y - iResolution.y / 2.0, 2.0) + sin(2.0 * 3.14 / 180.0 * pixCoords.y * iTime));\n       \n     float distanceve = length( pixCoords - center);\n    float rayon = iResolution.x/8.0 + 10.0*cos(iTime);\n    \n    \n    if (distanceve < rayon ) {\n        color = vec4(1.0, 1.0, 0.0, 1.0);\n       }\n\n  \n    \n    \n     if (pixCoords.y <  6.0 * cos(4.0 * 3.14 / 160.0 * pixCoords.x + 3.0*(iTime)) + iResolution.y / 3.0){\n        color = vec4(0.5, 0.5, 1.0, 1.0);\n    }\n    \n    if (pixCoords.y <  6.0 * cos(3.0 * 3.14 / 170.0 * pixCoords.x + 3.0*(iTime)) + iResolution.y / 3.5){\n        color = vec4(0.0, 0.0, 1.0, 1.0);\n    }\n    if (pixCoords.y <  6.0 * cos(2.0 * 3.14 / 180.0 * pixCoords.x + 3.0*(iTime)) + iResolution.y / 4.5){\n        color = vec4(0.0, 0.0, 0.5, 1.0);\n    }\n    \n}\n// 3e partie affichier 3 vagues\n// 4e partie : faire une mre homogne : vague de la mme taille\n// 5e : faire 1 fonction 1 vague\n//aprs la fonction n'a qu'1 paramtre", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MldXD2.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 53, 53, 1030]], "test": "valid"}
{"id": "MldXzf", "name": "Glowing Quake Logo", "author": "Hofi", "description": "While trying to understand Raymarching I created that glowing effect. Use mouse to rotate it. The original logo is copied from knarkowicz's shader \"Quake Logo\". Thank you for your very readable shader :-)", "tags": ["raymarching", "logo", "quake"], "likes": 4, "viewed": 188, "published": "Public", "date": "1481014526", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// \"Quake Logo\" by Krzysztof Narkowicz @knarkowicz\n\nconst float MATH_PI = float( 3.14159265359 );\n\nfloat VisibilityTerm( float roughness, float ndotv, float ndotl )\n{\n\tfloat m2\t= roughness * roughness;\n\tfloat visV\t= ndotl * sqrt( ndotv * ( ndotv - ndotv * m2 ) + m2 );\n\tfloat visL\t= ndotv * sqrt( ndotl * ( ndotl - ndotl * m2 ) + m2 );\n\treturn 0.5 / max( visV + visL, 0.00001 );\n}\n\nfloat DistributionTerm( float roughness, float ndoth )\n{\n\tfloat m2\t= roughness * roughness;\n\tfloat d\t\t= ( ndoth * m2 - ndoth ) * ndoth + 1.0;\n\treturn m2 / ( d * d * MATH_PI );\n}\n\nvec3 FresnelTerm( vec3 specularColor, float vdoth )\n{\n\tvec3 fresnel = clamp( 50.0 * specularColor.y, 0.0, 1.0 ) * specularColor + ( 1.0 - specularColor ) * pow( ( 1.0 - vdoth ), 5.0 );\n\treturn fresnel;\n}\n\nvec3 LightSpecular( vec3 normal, vec3 viewDir, vec3 lightDir, vec3 lightColor, float roughness, vec3 specularColor )\n{\n\tvec3 halfVec = normalize( viewDir + lightDir );\n\n\tfloat vdoth = clamp( dot( viewDir,\thalfVec\t ), 0.0, 1.0 );\n\tfloat ndoth\t= clamp( dot( normal,\thalfVec\t ), 0.0, 1.0 );\n\tfloat ndotv = clamp( dot( normal,\tviewDir  ), 0.0, 1.0 );\n\tfloat ndotl = clamp( dot( normal,\tlightDir ), 0.0, 1.0 );\n    \n   \tvec3\tf = FresnelTerm( specularColor, vdoth );\n\tfloat\td = DistributionTerm( roughness, ndoth );\n\tfloat\tv = VisibilityTerm( roughness, ndotv, ndotl );\n    \n    vec3 specular;\n\tspecular = lightColor * f * ( d * v * MATH_PI * ndotl );\n\treturn specular;\n}\n\nfloat Cylinder( vec3 p, float r, float height ) \n{\n\tfloat d = length( p.xz ) - r;\n\td = max( d, abs( p.y ) - height );\n\treturn d;\n}\n\nfloat Sphere( vec3 p, float s )\n{\n\treturn length( p ) - s;\n}\n\nfloat Box( vec3 p, vec3 b )\n{\n\tvec3 d = abs( p ) - b;\n\treturn min( max( d.x, max( d.y, d.z ) ), 0.0 ) + length( max( d, 0.0 ) );\n}\n\nfloat Substract( float a, float b )\n{\n    return max( a, -b );\n}\n\nfloat SubstractRound( float a, float b, float r ) \n{\n\tvec2 u = max( vec2( r + a, r - b ), vec2( 0.0, 0.0 ) );\n\treturn min( -r, max( a, -b ) ) + length( u );\n}\n\nfloat Union( float a, float b )\n{\n    return min( a, b );\n}\n\nfloat UnionRound( float a, float b, float k )\n{\n    float h = clamp( 0.5 + 0.5 * ( b - a ) / k, 0.0, 1.0 );\n    return mix( b, a, h ) - k * h * ( 1.0 - h );\n}\n\nfloat TriPrism( vec3 p, vec3 h )\n{        \n    vec3 q = abs( p );\n    return max( q.y - h.y, max( q.z * 0.866025 + p.x * h.z, -p.x ) - h.x * 0.5 );\n}\n\nfloat Scene( vec3 p, mat3 localToWorld )\n{\n    p = p * localToWorld;\n    \n    // ring\n    float a = Cylinder( p, 1.0, 0.1 );\n    float b = Cylinder( p + vec3( 0.12, 0.0, 0.0 ), 0.9, 0.2 ); \n    float ring = Substract( a, b );\n    \n    // nail\n    float c = Box( p + vec3( -0.8, 0.0, 0.0 ), vec3( 0.4, 0.1, 0.1 ) );\n    float d = Box( p + vec3( -0.4, 0.0, 0.0 ), vec3( 0.02, 0.1, 0.25 ) );\n    float e = TriPrism( p + vec3( -1.274, 0.0, 0.0 ), vec3( 0.149, 0.1, 0.16 ) );\n    float nail = Union( UnionRound( c, d, 0.1 ), e );\n    \n    // dents\n    float f = TriPrism( p + vec3( +0.08, 0.0, -0.85 ), vec3( 0.1, 0.2, 0.5 ) );\n    float g = TriPrism( p + vec3( -0.45, 0.0, -0.4 ), vec3( 0.1, 0.2, 0.16 ) );\n    float h = TriPrism( p + vec3( -0.8, 0.0, -0.65 ), vec3( 0.08, 0.2, 0.16 ) );\n    float i = TriPrism( p + vec3( -0.9, 0.0, 0.3 ), vec3( 0.04, 0.2, 0.16 ) );\n    float j = TriPrism( p + vec3( +0.3, 0.0, 0.68 ), vec3( 0.28, 0.2, 0.16 ) );\n    float k = TriPrism( p + vec3( -0.45, 0.0, -0.94 ), vec3( 0.07, 0.2, 0.5 ) );\n    float l = TriPrism( p + vec3( 0.0, 0.0, 1.06 ), vec3( 0.1, 0.2, 0.5 ) );\n\n    float dents = Union( Union( Union( Union( Union( Union( f, g ), h ), i ), j ), k ), l );\n    ring = SubstractRound( ring, dents, 0.03 );\n    \n    float ret = Union( ring, nail );\n\treturn ret;\n}\n\nvec2 CastRay( in vec3 ro, in vec3 rd, mat3 localToWorld )\n{\n    const float maxd = 5.0;\n    \n\tfloat h = 0.5;\n    float t = 0.0;\n    float steps = 0.0;\n   \n    for ( int i = 0; i < 50; ++i )\n    {\n        if ( h < 0.001 || t > maxd ) \n        {\n            break;\n        }\n        \n\t    h = Scene( ro + rd * t, localToWorld );\n        t += h;\n        steps += 0.03;\n    }\n\n    if ( t > maxd )\n    {\n        t = -1.0;\n    }\n\t\n    return vec2(t, steps);\n}\n\nvec3 SceneNormal( in vec3 pos, mat3 localToWorld )\n{\n\tvec3 eps = vec3( 0.001, 0.0, 0.0 );\n\tvec3 nor = vec3(\n\t    Scene( pos + eps.xyy, localToWorld ) - Scene( pos - eps.xyy, localToWorld ),\n\t    Scene( pos + eps.yxy, localToWorld ) - Scene( pos - eps.yxy, localToWorld ),\n\t    Scene( pos + eps.yyx, localToWorld ) - Scene( pos - eps.yyx, localToWorld ) );\n\treturn normalize( -nor );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 q = fragCoord.xy / iResolution.xy;\n    vec2 p = -1.0 + 2.0 * q;\n\tp.x *= iResolution.x / iResolution.y;\n\n\tvec3 rayOrigin \t= vec3( 0.0, -0.28, -3.5 );\n    vec3 rayDir \t= normalize( vec3( p.x, p.y, 2.0 ) );\n    \n    float theta = -0.5 * MATH_PI;\n    mat3 rotX = mat3(\n        vec3( cos( theta ), sin( theta ), 0.0 ),\n        vec3( -sin( theta ), cos( theta ), 0.0 ),\n\t\tvec3( 0.0, 0.0, 1.0 )\n        );    \n    \n    vec2 mo = iMouse.xy / iResolution.xy;    \n    float phi = 0.25 * MATH_PI + 10.0 * mo.x;    \n    mat3 rotY = mat3(\n        vec3( 1.0, 0.0, 0.0 ),\n        vec3( 0.0, cos( phi ), sin( phi ) ),\n        vec3( 0.0, -sin( phi ), cos( phi ) )\n        );\n    \n    mat3 localToWorld = rotX * rotY;    \n\n\n\tvec3 color = texture( iChannel0, q ).yyy * 0.3;\n    \n\tvec2 result = CastRay( rayOrigin, rayDir, localToWorld );\n    \n    if ( result.x > 0.0 )\n    {\n      color = vec3(result.y*2.0, result.y*0.3, result.y*0.2);\n    }\n    else\n    {\n      color = vec3(0.0, result.y*abs(sin(iTime*1.8)),0.0);\n    }\n    \n    fragColor = vec4( color, 1.0 );\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MldXzf.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[99, 99, 166, 166, 380], [382, 382, 438, 438, 559], [561, 561, 614, 614, 764], [766, 766, 884, 884, 1431], [1433, 1433, 1483, 1483, 1563], [1565, 1565, 1598, 1598, 1625], [1627, 1627, 1656, 1656, 1757], [1759, 1759, 1796, 1796, 1823], [1825, 1825, 1877, 1877, 1983], [1985, 1985, 2018, 2018, 2044], [2046, 2046, 2093, 2093, 2204], [2206, 2206, 2240, 2240, 2355], [2357, 2357, 2399, 2399, 3656], [3658, 3658, 3717, 3717, 4111], [4113, 4113, 4165, 4165, 4497], [4499, 4499, 4556, 4556, 5609]], "test": "error"}
{"id": "MlGSzW", "name": "Re Cypher", "author": "wizgrav", "description": "Audio reactive version of https://www.shadertoy.com/view/MlsGRS by  @dila,  rewired for clubber. \n\nMetal/rock: https://goo.gl/epB0BX , https://goo.gl/411PTg\nPsytrance(needs work): https://goo.gl/kVdz0G\ndowntempo: https://goo.gl/SB7hie", "tags": ["block", "world", "ass", "clubber"], "likes": 22, "viewed": 7439, "published": "Public API", "date": "1483194642", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// The following block is needed for Clubber integration\n#ifndef CLUBBER\nvec4 iMusic[4];\nconst float iTransition = 1.0;\n#define CLUBBER_R len * 0.3\n#define CLUBBER_G len * 0.3\n#define CLUBBER_B len * 0.3\n#define CLUBBER_A 0.0\n#endif\n// Clubber end\n\n#define PI 3.14159\n\nmat3 xrot(float t)\n{\n    return mat3(1.0, 0.0, 0.0,\n                0.0, cos(t), -sin(t),\n                0.0, sin(t), cos(t));\n}\n\nmat3 yrot(float t)\n{\n    return mat3(cos(t), 0.0, -sin(t),\n                0.0, 1.0, 0.0,\n                sin(t), 0.0, cos(t));\n}\n\nmat3 zrot(float t)\n{\n    return mat3(cos(t), -sin(t), 0.0,\n                sin(t), cos(t), 0.0,\n                0.0, 0.0, 1.0);\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return min(max(d.x,max(d.y,d.z)),0.0) +\n         length(max(d,0.0));\n}\n\nfloat map(vec3 pos)\n{\n    float speed = 1.0;\n    vec3 grid = floor(pos);\n    vec3 gmod = mod(grid, 3.);\n    vec3 rmod = mod(grid, 4.0) - 2.0;\n    float j = iTime * speed + (CLUBBER_A);\n    float tm = fract(j);\n    rmod *= (cos(tm*PI)-1.0);\n    \n    float g = floor(mod(j,2.0));\n    if (g==0.0){\n        if (gmod.y*gmod.x==1.0) {\n            pos.z += rmod.x*rmod.y*0.5;\n        }\n    } else if (g==1.0){\n        if (gmod.y*gmod.z==1.0) {\n            pos.x += rmod.y;\n        }\n    } else if (g==2.0){\n        if (gmod.z==0.0) {\n            pos.y += rmod.z*rmod.x*0.5;\n        }\n    }\n        \n    grid = floor(pos);\n    pos = pos - grid;\n    pos = pos * 2.0 - 1.0;\n\n    float len = 0.9;\n\tvec3 sc = mix(vec3(0.5), vec3(0.96), vec3(CLUBBER_R,CLUBBER_G,CLUBBER_B));\n    float d = sdBox(pos, sc);\n\n    bool skip = false;\n\n    if (mod(grid.x,2.0)==0.0 && mod(grid.y,2.0)==0.0) {\n        skip = true;\n    }\n\n    if (mod(grid.x,2.0)==0.0 && mod(grid.z,2.0)==0.0) {\n        skip = true;\n    }\n\n    if (mod(grid.y,2.0)==0.0 && mod(grid.z,2.0)==1.0) {\n        skip = true;\n    }\n\t\n    if (skip) {\n        d = 100.0;\n        vec3 off = vec3(2.0,0.0,0.0);\n        for (int i = 0; i < 3; ++i) {\n            float a = sdBox(pos + off,vec3(sc));\n            float b = sdBox(pos - off,vec3(sc));\n            d = min(d,min(a,b));\n            off = off.zxy;\n        }\n        d *= 0.5 *(sc.x+sc.y +sc.z) * 0.33 ;\n    } else {\n        d *= 0.8 * (sc.x+sc.y +sc.z) * 0.33;   \n    }\n    \n    return d;\n}\n\nvec3 surfaceNormal(vec3 pos) {\n \tvec3 delta = vec3(0.01, 0.0, 0.0);\n    vec3 normal;\n    normal.x = map(pos + delta.xyz) - map(pos - delta.xyz);\n    normal.y = map(pos + delta.yxz) - map(pos - delta.yxz);\n    normal.z = map(pos + delta.zyx) - map(pos - delta.zyx);\n    return normalize(normal);\n}\n\nfloat aoc(vec3 origin, vec3 ray)\n{\n    float delta = 0.05;\n    const int samples = 8;\n    float r = 0.0;\n    for (int i = 1; i <= samples; ++i) {\n        float t = delta * float(i);\n     \tvec3 pos = origin + ray * t;\n        float dist = map(pos);\n        float len = abs(t - dist);\n        r += len * pow(2.0, -float(i));\n    }\n    return r;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    uv = uv * 2.0 - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n    \n\tvec3 eye = normalize(vec3(uv, 1.0 - dot(uv,uv) * 0.33));\n    vec3 origin = vec3(0.0);\n    \n    eye = eye * yrot(iTime) * xrot(iTime);\n    \n    float speed = 0.5;\n    \n    float j = iTime * speed + CLUBBER_A;\n    \n    float f = fract(j);\n    float g = 1.0 - f;\n    f = f*f * g + (1.0-g*g) * f;\n    f = f * 2.0 - 1.0;\n\tfloat a = floor(j) + f * floor(mod(j,2.0));\n    float b = floor(j) + f * floor(mod(j+1.0,2.0));\n    \n    origin.x += 0.5 + a;\n    origin.y += 0.5;\n    origin.z += 0.5 + b;\n    \n    float t = 0.0;\n    float d = 0.0;\n    \n    for (int i = 0; i < 32; ++i){\n        vec3 pos = origin + eye * t;\n        d = map(pos);\n        t += d;\n    }\n    \n    vec3 worldPos = origin + eye * t;\n    \n    vec3 norm = surfaceNormal(worldPos);\n    \n    float prod = max(0.0, dot(norm, -eye));\n    \n    float amb = aoc(worldPos, -eye);\n    \n    vec3 ref = reflect(eye, norm);\n    \n    vec3 spec = vec3(0.0);//texture(iChannel0, ref).xyz;\n    \n    prod = pow(1.0 - prod, 2.0);\n    \n    vec3 col = vec3(0.1, 0.3, 0.5);\n    \n    spec *= col;\n    \n    col = mix(col, spec, prod);\n    \n    float shade = pow(max(1.0 - amb, 0.0), 4.0);\n    \n    float fog = 1.0 / (1.0 + t * t * 0.2) * shade;\n    \n    vec3 final = col;\n    \n    final = mix(final, vec3(1.0), fog);\n    \n    fog = 1.0 / (1.0 + t * t * 0.1);\n    \n\tfragColor = vec4(final*fog,0.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MlGSzW.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[269, 269, 289, 289, 398], [400, 400, 420, 420, 529], [531, 531, 551, 551, 660], [662, 662, 693, 693, 789], [791, 791, 812, 812, 2272], [2274, 2274, 2304, 2304, 2570], [2572, 2572, 2606, 2606, 2916], [2918, 2918, 2975, 2975, 4428]], "test": "valid"}
{"id": "MlKSzR", "name": "StructureFlyThough", "author": "EvilRyu", "description": "ha", "tags": ["raymarching", "tunnel", "bump", "gyroid", "schwarz"], "likes": 25, "viewed": 853, "published": "Public API", "date": "1482679886", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Created by evilryu\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\nfloat smin(float a, float b, float k)\n{\n    float h = clamp(0.5+0.5*(b-a)/k, 0.0, 1.0);\n    return mix(b, a, h) - k*h*(1.0-h);\n}\n\nfloat smax(float a, float b, float k)\n{\n    return smin(a, b, -k);\n}\n\nmat2 rot(float t)\n{\n    float c=cos(t);\n    float s=sin(t);\n    return mat2(c,-s,s,c);\n}\n\nvec3 path(float p)\n{\n   return vec3(sin(p*0.01)*cos(p*0.025)*20., sin(p*0.02)*cos(p*0.0125)*18.,0.);\n}\n\nvec4 texcube(sampler2D sam, vec3 p, vec3 n)\n{\n    vec4 p1=texture(sam, p.xy);\n    vec4 p2=texture(sam, p.xz);\n    vec4 p3=texture(sam, p.yz);\n    return p1*abs(n.z)+p2*abs(n.y)+p3*abs(n.x);\n}\n\nfloat schwarz(vec3 p)\n{\n    return sin(p.x)*sin(p.y)*sin(p.z)+sin(p.x)*cos(p.y)*cos(p.z)+cos(p.x)*sin(p.y)*cos(p.z)+cos(p.x)*cos(p.y)*sin(p.z);\n}\n\nfloat map(vec3 p)\n{\n    p-=path(p.z);\n    float d0=4.0-length(p.xy*vec2(0.2,0.4));  // Tunnel\n    float d1=schwarz(p*0.08); // Schwarz\n    float d2=dot(sin(p*0.6),cos(p.yzx*0.3)); // Gyroid\n    float d=smax(d0,-d1,1.);\n    d=smax(d,-d2,1.0);\n    return d;\n}\n\nfloat bump(vec3 p, vec3 n)\n{\n    return dot(texcube(iChannel0, 0.1*p, n).xyz, vec3(0.299, 0.587, 0.114)); \n}\n\nvec3 bump_mapping(vec3 p, vec3 n, float weight)\n{\n    vec2 e = vec2(2./iResolution.y, 0); \n    vec3 g=vec3(bump(p-e.xyy, n)-bump(p+e.xyy, n),\n                bump(p-e.yxy, n)-bump(p+e.yxy, n),\n                bump(p-e.yyx, n)-bump(p+e.yyx, n))/(e.x*2.);  \n    g=(g-n*dot(g,n));\n    return normalize(n+g*weight);\n}\n\nvec3 get_normal(vec3 p) {\n\tconst vec2 e = vec2(0.002, 0);\n\treturn normalize(vec3(map(p + e.xyy)-map(p - e.xyy), \n                          map(p + e.yxy)-map(p - e.yxy),\t\n                          map(p + e.yyx)-map(p - e.yyx)));\n}\n\n\nfloat intersect( in vec3 ro, in vec3 rd )\n{\n    float pixel_size = 1.0/(iResolution.x * 3.0);\n    float t = 1.0;\n    float res_t = 0.0;\n    float res_d = 1000.0;\n    float c;\n    float max_error = 1000.0;\n\tfloat d = 1.0;\n    float pd = 100.0;\n    float os = 0.0;\n    float step = 0.0;\n    float error = 1000.0;\n    \n    for( int i=0; i<150; i++ )\n    {\n        if( error < pixel_size*0.5 || t > 200.0 )\n        {\n        }\n        else{  // avoid broken shader on windows\n        \n            c = map(ro + rd*t);\n            d = c;\n\n            if(d > os)\n            {\n                os = 0.5 * d*d/pd;\n                step = d + os;\n                pd = d;\n            }\n            else\n            {\n                step =-os; os = 0.0; pd = 100.0; d = 1.0;\n            }\n\n            error = d / t;\n\n            if(error < max_error) \n            {\n                max_error = error;\n                res_t = t;\n            }\n        \n            t += step;\n        }\n\n    }\n\tif( t>200.0) t=-1.0;\n    return t;\n}\n\n\nfloat get_ao(vec3 p, vec3 n)\n{\n    float r = 0.0, w = 1.0, d;\n    for(float i=1.0; i<5.0+1.1; i++)\n    {\n        d = i/5.0;\n        r += w*(d - map(p + n*d));\n        w *= 0.5;\n    }\n    return 1.0-clamp(r,0.0,1.0);\n}\n\nfloat softshadow( in vec3 ro, in vec3 rd, float k )\n{\n    float res = 1.0;\n    float t = 0.01;\n\tfloat h = 1.0;\n    for( int i=0; i<24; i++ )\n    {\n        h = map(ro + rd*t);\n        res = min( res, k*h/t );\n        if( res<0.001 )break;\n        t += clamp( h, 0.01, 2. );\n    }\n    return clamp(res,0.,1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 q = fragCoord.xy / iResolution.xy;\n    vec2 p = -1.0 + 2.0 * q;\n    p.x *= iResolution.x/iResolution.y;\n\n    if (abs(p.y)>.85) {\n        fragColor = vec4(0.0, 0.0, 0.0, 1.0);\n        return;\n    }\n    \n    vec3 ro = vec3(0.0, 0., iTime*6.);\n\tvec3 look = ro + vec3(0.3*sin(iTime*0.4), 0., 0.5);\n\n    ro+=path(ro.z);\n    look+=path(look.z);\n    vec3 forward=normalize(look-ro);\n    vec3 right=normalize(cross(forward, vec3(0.0, 1.0, 0.0)));\n    vec3 up=normalize(cross(right, forward));\n    \n    vec3 rd=normalize(p.x*right + p.y*up + 2.*forward);\n    float t=intersect(ro,rd);\n    vec3 col=0.1*vec3(1.1,0.8,0.5);\n    if(t>-0.5)\n    {\n        vec3 pos=ro+t*rd;\n        vec3 n=get_normal(pos);\n        \n        vec3 lp0=ro+vec3(0.0,50.0,0.0);\n        lp0+=path(lp0.z);\n        vec3 ld0=normalize(lp0-pos);\n        \n        vec3 material=texcube(iChannel0,pos*0.1,n).xyz;\n        material=pow(material,vec3(1.1,1.8,1.8));\n        \n\t    n=bump_mapping(pos, n, 2./(1.+t*0.5));\n        \n        float ao=get_ao(pos,n);\n        \n        float amb=0.5+0.5*n.y;\n        float diff=max(0.0, dot(n,ld0));\n        float bac=max(0.0,dot(n,-ld0));\n        float spec=max(0.0, pow(clamp(dot(ld0, reflect(rd, n)), 0.0, 1.0), 16.0));\n        float sha=softshadow( pos+0.2*ld0, ld0, 20.0 );\n\t\tvec3 lin=vec3(0.0);\n        \n        lin+=vec3(0.3)*amb*ao;\n        lin+=vec3(7.,4.,3.)*diff*1.0*ao*sha;\n        lin+=vec3(1.0,0.5,0.3)*bac*1.0*ao;\n        lin+=vec3(spec*8.2)*sha;\n        \n        col=lin*0.2*material;\n     }\n    col=mix(col, 0.1*vec3(1.1,0.8,0.5), 1.0-exp(-0.0001*t*t) );\n    col=pow(clamp(col,0.0,1.0),vec3(0.45));\n    col=pow(col,vec3(1.3,1.,1.));\n    col*=pow(16.0*q.x*q.y*(1.0-q.x)*(1.0-q.y), 0.1);\n    fragColor.xyz=col;\n}", "image_inputs": [{"id": "XsX3Rn", "previewfilepath": "/media/ap/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MlKSzR.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[110, 110, 149, 149, 238], [240, 240, 279, 279, 308], [310, 310, 329, 329, 398], [400, 400, 420, 420, 502], [504, 504, 549, 549, 695], [697, 697, 720, 720, 842], [844, 844, 863, 863, 1101], [1103, 1103, 1131, 1131, 1211], [1213, 1213, 1262, 1262, 1526], [1528, 1528, 1553, 1553, 1759], [1762, 1762, 1805, 1805, 2779], [2782, 2782, 2812, 2812, 2999], [3001, 3001, 3054, 3054, 3311], [3313, 3313, 3370, 3370, 5097]], "test": "error"}
{"id": "MlKXRh", "name": "Vector rotation", "author": "gigatron", "description": "This is the exact rotation i want :) (paranoimia logo )  thank you IQ ; \nLines mapped to iq rasterized triangle ...\ncross = crosse ", "tags": ["lines", "vector", "rotation"], "likes": 5, "viewed": 223, "published": "Public", "date": "1482967359", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Created by inigo quilez - iq/2013\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// a perspective correct triangle rasterizer, in a shader!! :D\n\n#define t iTime\n\nmat4 setRotation( float x, float y, float z )\n{\n    float a = sin(x); float b = cos(x); \n    float c = sin(y); float d = cos(y); \n    float e = sin(z); float f = cos(z); \n\n    float ac = a*c;\n    float bc = b*c;\n\n    return mat4( d*f,      d*e,       -c, 0.0,\n                 ac*f-b*e, ac*e+b*f, a*d, 0.0,\n                 bc*f+a*e, bc*e-a*f, b*d, 0.0,\n                 0.0,      0.0,      0.0, 1.0 );\n}\nmat4 RotationAxisAngle( vec3 v, float angle )\n{\n    float s = sin( angle );\n    float c = cos( angle );\n    float ic = 1.0 - c;\n\n    return mat4( v.x*v.x*ic + c,     v.y*v.x*ic - s*v.z, v.z*v.x*ic + s*v.y, 0.0,\n                 v.x*v.y*ic + s*v.z, v.y*v.y*ic + c,     v.z*v.y*ic - s*v.x, 0.0,\n                 v.x*v.z*ic - s*v.y, v.y*v.z*ic + s*v.x, v.z*v.z*ic + c,     0.0,\n\t\t\t     0.0,                0.0,                0.0,                1.0 );\n}\n\nmat4 setTranslation( float x, float y, float z )\n{\n    return mat4( 1.0, 0.0, 0.0, 0.0,\n\t\t\t\t 0.0, 1.0, 0.0, 0.0,\n\t\t\t\t 0.0, 0.0, 1.0, 0.0,\n\t\t\t\t x,     y,   z, 1.0 );\n}\n\nstruct Triangle\n{\n    vec3 a; vec2 aUV;\n    vec3 b; vec2 bUV;\n    vec3 c; vec2 cUV;\n    vec3 n;\n};\n\n\nTriangle triangles[4];\n\nvoid createCube( void )\n{\n    vec3 verts[8];\n\n    verts[0] = vec3( -1.0, -1.0, -0.0 );\n    verts[1] = vec3( -1.0, -1.0,  0.0 );\n    verts[2] = vec3( -1.0,  1.0, -0.0 );\n    verts[3] = vec3( -1.0,  1.0,  0.0 );\n    verts[4] = vec3(  1.0, -1.0, -0.0 );\n    verts[5] = vec3(  1.0, -1.0,  0.0 );\n    verts[6] = vec3(  1.0,  1.0, -0.0 );\n    verts[7] = vec3(  1.0,  1.0,  0.0 );\n\n    triangles[0].a = verts[1]; triangles[0].aUV = vec2(0.0,0.0);\n    triangles[0].b = verts[5]; triangles[0].bUV = vec2(1.0,0.0);\n    triangles[0].c = verts[7]; triangles[0].cUV = vec2(1.0,1.0);\n    triangles[0].n = vec3( 0.0, 0.0, 0.0 );\n    triangles[1].a = verts[1]; triangles[1].aUV = vec2(0.0,0.0),\n    triangles[1].b = verts[7]; triangles[1].bUV = vec2(1.0,1.0),\n    triangles[1].c = verts[3]; triangles[1].cUV = vec2(0.0,1.0),\n    triangles[1].n = vec3( 0.0, 0.0, 0.0 );\n\n    triangles[2].a = verts[5]; triangles[2].aUV = vec2(0.0,0.0);\n    triangles[2].b = verts[4]; triangles[2].bUV = vec2(1.0,0.0);\n    triangles[2].c = verts[6]; triangles[2].cUV = vec2(1.0,1.0);\n    triangles[2].n = vec3( 0.0, 0.0, 0.0 );\n    triangles[3].a = verts[5]; triangles[3].aUV = vec2(0.0,0.0);\n    triangles[3].b = verts[6]; triangles[3].bUV = vec2(1.0,1.0);\n    triangles[3].c = verts[7]; triangles[3].cUV = vec2(0.0,1.0);\n    triangles[3].n = vec3( 0.0, 0.0, 0.0 );\n\n     \n}\n\nfloat crosse( vec2 a, vec2 b )\n{\n    return a.x*b.y - a.y*b.x;\n}\n\nvec3 lig = normalize( vec3( 0.3,0.7,0.5) );\n\nvec4 bg = vec4(1.,0.,0.,0.0);\n \nvec4 l( in vec2 p, in vec2 a, in vec2 b,in float t,in vec4 c )\n{\n    vec2 pa = p - a;\n    vec2 ba = b - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    float d = length( pa - ba*h );\n    \n    return smoothstep(t/iResolution.y, 0., d ) * c;\n}\n\n\n\nvec3 pixelShader( in vec3 nor, in vec2 p, in float z, in vec3 wnor )\n{\n    vec4 cl = vec4(0);\n    p *= 2.0;\n    p.y = p.y-0.5;\n    \n    vec4 tcol=vec4(p,sin(t),1.0);\n    \n    float lh=8.0;\n    // S  5 segments \n  \tcl += l(p-vec2(.1,0.6),vec2(0.0,0.0),vec2(.0,-.15),lh,tcol);\n    cl += l(p-vec2(.1,0.6),vec2(0.0,0.0),vec2(.15,0.0),lh,tcol);\n    cl += l(p-vec2(.1,0.45),vec2(0.0,0.0),vec2(.15,0.0),lh,tcol);\n    cl += l(p-vec2(.25,0.45),vec2(0.0,0.0),vec2(.0,-.17),lh,tcol);\n    cl += l(p-vec2(.1,0.28),vec2(0.0,0.0),vec2(.15,0.0),lh,tcol);\n       \n    // H \n    cl += l(p-vec2(0.3,0.6),vec2(0.0,0.0),vec2(.0,-.32),lh,tcol);\n    cl += l(p-vec2(0.30,0.45),vec2(0.0,0.0),vec2(.15,.00),lh,tcol);\n    cl += l(p-vec2(0.45,0.6),vec2(0.0,0.0),vec2(.0,-.32),lh,tcol);\n    // A\n    cl += l(p-vec2(.60,0.6),vec2(0.0,0.0),vec2(-.1,-.32),lh,tcol);\n    cl += l(p-vec2(.60,0.6),vec2(0.0,0.0),vec2(.1,-.32),lh,tcol);\n    // D\n    cl += l(p-vec2(0.75,0.6),vec2(0.0,0.0),vec2(.0,-.32),lh,tcol);\n    cl += l(p-vec2(0.75,0.6),vec2(0.0,0.0),vec2(.15,-.16),lh,tcol);\n    cl += l(p-vec2(0.75,0.28),vec2(0.0,0.0),vec2(.15,0.16),lh,tcol);\n     // E\n    cl += l(p-vec2(0.95,0.6),vec2(0.0,0.0),vec2(.0,-.32),lh,tcol);\n    cl += l(p-vec2(0.95,0.45),vec2(0.0,0.0),vec2(.15,.00),lh,tcol);\n    cl += l(p-vec2(0.95,0.6),vec2(0.0,0.0),vec2(.15,.00),lh,tcol);\n    cl += l(p-vec2(0.95,0.28),vec2(0.0,0.0),vec2(.15,.00),lh,tcol);\n    // R    \n    cl += l(p-vec2(1.15,0.6),vec2(0.0,0.0),vec2(.0,-.32),lh,tcol);\n    cl += l(p-vec2(1.15,0.6),vec2(0.0,0.0),vec2(.15,0.0),lh,tcol);\n    cl += l(p-vec2(1.15,0.45),vec2(0.0,0.0),vec2(.15,0.0),lh,tcol);\n    cl += l(p-vec2(1.30,0.6),vec2(0.0,0.0),vec2(.0,-.15),lh,tcol);\n    cl += l(p-vec2(1.15,0.45),vec2(0.0,0.0),vec2(.15,-0.17),lh,tcol);\n    // T\n    cl += l(p-vec2(1.45,0.6),vec2(0.0,0.0),vec2(.0,-.32),lh,tcol);\n    cl += l(p-vec2(1.35,0.6),vec2(0.0,0.0),vec2(.20,.00),lh,tcol);\n    // O\n    \n    cl += l(p-vec2(1.60,0.6),vec2(0.0,0.0),vec2(.0,-.32),lh,tcol);\n    cl += l(p-vec2(1.60,0.6),vec2(0.0,0.0),vec2(.15,0.0),lh,tcol);\n    cl += l(p-vec2(1.60,0.28),vec2(0.0,0.0),vec2(.15,0.0),lh,tcol);\n    cl += l(p-vec2(1.75,0.6),vec2(0.0,0.0),vec2(.0,-.32),lh,tcol);\n    //yy\n    \n    cl += l(p-vec2(1.80,0.6),vec2(0.0,0.0),vec2(.10,-.16),lh,tcol);\n    cl += l(p-vec2(1.90,0.44),vec2(0.0,0.0),vec2(.10,.16),lh,tcol);\n    cl += l(p-vec2(1.9,0.45),vec2(0.0,0.0),vec2(.0,-.17),lh,tcol);\n    \n \n    return vec3(cl.xyz);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tmat4 mdv = setTranslation( 0.0, 0.0, -1.5 ) * \n\t\t       setRotation( t*3.,t*2. , 0. )*\n               RotationAxisAngle(vec3(0.0,0.0,0.0), 0.2 );\n \n    vec2 px = fragCoord / iResolution.xy*2.-1.;\n    \n    px.x *=iResolution.x/iResolution.y;\n    \n\n   createCube();\n\t \n    float scl =mod(fragCoord.y,3.0);\n    \n    vec3 color = vec3( 0.0, 0.0, 0.0 );\n\n \n        // transform to eye space\n        vec3 ep0 = (mdv * vec4(triangles[1].a,1.0)).xyz;\n        vec3 ep1 = (mdv * vec4(triangles[1].b,1.0)).xyz;\n        vec3 ep2 = (mdv * vec4(triangles[1].c,1.0)).xyz;\n        vec3 nor = (mdv * vec4(triangles[1].n,0.0)).xyz;\n\n        // transform to clip space\n        float w0 = 1.0/ep0.z;\n        float w1 = 1.0/ep1.z;\n        float w2 = 1.0/ep2.z;\n\n        vec2 cp0 = 2.0*ep0.xy * -w0;\n        vec2 cp1 = 2.0*ep1.xy * -w1;\n        vec2 cp2 = 2.0*ep2.xy * -w2;\n\n        // fetch vertex attributes, and divide by z\n        vec2 u0 = triangles[1].aUV * w0;\n        vec2 u1 = triangles[1].bUV * w1;\n        vec2 u2 = triangles[1].cUV * w2;\n \n        vec3 di = vec3( crosse( cp1 - cp0, px - cp0 ), \n\t\t\t\t\t    crosse( cp2 - cp1, px - cp1 ), \n\t\t\t\t\t    crosse( cp0 - cp2, px - cp2 ) );\n\t\t\n  \n            // calc barycentric coordinates\n            vec3 ba = di.yzx / (di.x+di.y+di.z);\n\n            // barycentric interpolation of attributes and 1/z\n            float iz = ba.x*w0 + ba.y*w1 + ba.z*w2;\n            vec2  uv = ba.x*u0 + ba.y*u1 + ba.z*u2;\n\n            // recover interpolated attributes\n            float z = 1.0/iz;\n            uv *= z;\n \n   \t\t\t color = pixelShader( nor, uv, z, triangles[1].n );\n    \n    fragColor = vec4(color,1.0)*scl;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MlKXRh.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[206, 206, 253, 253, 610], [611, 611, 658, 658, 1062], [1064, 1064, 1114, 1114, 1230], [1357, 1357, 1382, 1382, 2697], [2699, 2699, 2731, 2731, 2763], [2842, 2842, 2906, 2906, 3098], [3102, 3102, 3172, 3172, 5523], [5525, 5525, 5582, 5582, 7222]], "test": "valid"}
{"id": "MltSDf", "name": "Ghost Cells", "author": "ptrgags", "description": "This is my first time trying to randomly generate a Voronoi shader based on techniques from https://thebookofshaders.com/12/. My hash isn't random enough, but I managed to work around it.", "tags": ["2d", "voronoi", "pulse", "waves"], "likes": 9, "viewed": 221, "published": "Public", "date": "1481982691", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//hash a point onto a color from the texture\nvec2 hash2(vec2 point) {\n    return texture(iChannel0, point).rg;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //Convert to UV space\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    \n    uv -= 0.5;\n    \n    //Fix aspect ratio\n    uv.x *= iResolution.x / iResolution.y;\n    \n    \n    //Tile space\n    vec2 scaled = 7.0 * uv;\n    \n    \n    //Coordinates (x, y) of the box\n    vec2 box = floor(scaled);\n    \n    //UV coordinate within current box\n    vec2 box_uv = fract(scaled);\n    \n    //Minimum distance between box_uv and a nearby feature point\n    float min_dist = 1.0;\n    \n    //Iterate over current box + surrounding 8 neighbors\n    for (int i = -1; i <= 1; i++) {\n        for (int j = -1; j <= 1; j++) {\n            //Coodrinates (x, y) of neighbor box\n            vec2 neighbor = vec2(float(i), float(j));\n            \n            //Find the feature point in the neighbor cell.\n            //this is a fractional coordinate like box_uv\n            vec2 feature = hash2((box + neighbor) / 100.0);\n            \n            //Animate the feature points a little bit\n            feature = 0.5 * sin(iTime + 6.0 * feature) + 0.5;\n            \n            //Get the distance between current pixel (box_uv)\n            //and the feature point (neighbor + feature)\n            float dist = distance(box_uv, neighbor + feature);\n            \n            //Update the minimum\n            min_dist = min(dist, min_dist);\n        }\n    }\n\n    vec4 spring_green = vec4(0.0, 1.0, 0.5, 1.0);\n    \n    //Pulse outwards from the center of each feature point over time\n    float pulse_val = 10.0 * min_dist;\n    float animation = -iTime;\n    //shift the frequency as we move away from the center of the screen\n    float variation = 5.0 * length(uv);\n    //This was a happy\n    float distortion = length(hash2(uv));\n    float pulse = cos(pulse_val + animation + variation + distortion);\n    \n    fragColor = pulse * spring_green;\n    \n    \n}", "image_inputs": [{"id": "XdXGzn", "previewfilepath": "/media/ap/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MltSDf.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 45, 69, 69, 112], [114, 114, 171, 197, 1995]], "test": "error"}
{"id": "MltSDs", "name": "Another Julia", "author": "sixstring982", "description": "Quick julia fractal for Reddit daily programmer 20160729. Use the mouse!", "tags": ["julia"], "likes": 2, "viewed": 504, "published": "Public API", "date": "1482290440", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define RES iResolution\n\n//********************************\n//***** Compute Julia Fractal ****\n//********************************\n#define JULIA_ITERS 64\nfloat julia(vec2 z, vec2 c) {\n    int breakout = 0;\n    for (int i = 0; i < JULIA_ITERS; i++) {\n        if (z.x * z.x + z.y * z.y > 4.0) {\n         \tcontinue;  // break   \n        }\n        breakout = i;\n        \n        z = vec2(z.x * z.x - z.y * z.y,\n                 2.0 * z.x * z.y) + c;\n    }\n    \n    return 4.0 * float(breakout) / float(JULIA_ITERS);\n}\n\n//********************************\n//***** Color Scheme          ****\n//********************************\n\n// Convert pixel coordinates to texture coordinates\n// http://www.iquilezles.org/www/articles/palettes/palettes.htm\nmat4 PALETTE_COEFF = \n    mat4(0.5, 0.5, 1.0, 0.3,\n         0.5, 0.5, 1.0, 0.2,\n         0.5, 0.5, 1.0, 0.2,\n         0.0, 0.0, 0.0, 0.0);\n\nfloat paletteComponent(vec4 v, float x) {\n    return v.x + v.y * cos(2.0 * 3.14159 * (v.z * x + v.w));\n}\n\nvec3 palette(float x) {\n \tx += iTime * 0.1;\n\n    return vec3(paletteComponent(PALETTE_COEFF[0], x),\n                paletteComponent(PALETTE_COEFF[1], x),\n                paletteComponent(PALETTE_COEFF[2], x));\n}\n\nvec2 uvFromPx(vec2 pxCoord) {\n    return (2.0 * pxCoord - RES.xy) / RES.y;\n    \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 pxFragCoord ) {\n    vec2 uvMouse = uvFromPx(iMouse.xy);\n    \n    vec3 color = vec3(0.0);\n    for (int x = -1; x <= 1; x++) {\n        for (int y = -1; y <= 1; y++) {\n            if (x == 0 || y == 0) {\n            \tvec2 uvFragCoord = uvFromPx(pxFragCoord + vec2(x, y));\n            \tvec3 component = palette(julia(uvFragCoord, uvMouse));\n                color += component * (x == 0 && y == 0 ? 2.0 : 1.0);\n            }\n        }\n    }\n\tfragColor = vec4(color / 8.0, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MltSDs.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[153, 153, 182, 182, 512], [876, 876, 917, 917, 980], [982, 982, 1005, 1005, 1194], [1196, 1196, 1225, 1225, 1277], [1279, 1279, 1338, 1338, 1797]], "test": "valid"}
{"id": "MltSRf", "name": "Flower test", "author": "TLC123", "description": "ray marching flower\nRay marcher by Inigo Quilez\nI only made flower function\nadded comments", "tags": ["raymarchingflower"], "likes": 20, "viewed": 342, "published": "Public", "date": "1480970947", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Created by inigo quilez - iq/2013\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// A list of usefull distance function to simple primitives, and an example on how to \n// do some interesting boolean operations, repetition and displacement.\n//\n// More info here: http://www.iquilezles.org/www/articles/distfunctions/distfunctions.htm\n\nfloat sdPlane(vec3 p) {\n\treturn p.y;\n}\n\nfloat sdSphere(vec3 p, float s) {\n\treturn length(p) - s;\n}\n\nfloat sdBox(vec3 p, vec3 b) {\n\tvec3 d = abs(p) - b;\n\treturn min(max(d.x, max(d.y, d.z)), 0.0) + length(max(d, 0.0));\n}\n\nfloat sdEllipsoid( in vec3 p, in vec3 r) {\n\treturn (length(p / r) - 1.0) * min(min(r.x, r.y), r.z);\n}\n\nfloat udRoundBox(vec3 p, vec3 b, float r) {\n\treturn length(max(abs(p) - b, 0.0)) - r;\n}\n\nfloat sdTorus(vec3 p, vec2 t) {\n\treturn length(vec2(length(p.xz) - t.x, p.y)) - t.y;\n}\n\n \n\nfloat sdCylinder(vec3 p, vec2 h) {\n\tvec2 d = abs(vec2(length(p.xz), p.y)) - h;\n\treturn min(max(d.x, d.y), 0.0) + length(max(d, 0.0));\n}\n\nfloat sdCone( in vec3 p, in vec3 c) {\n\tvec2 q = vec2(length(p.xz), p.y);\n\tfloat d1 = -q.y - c.z;\n\tfloat d2 = max(dot(q, c.xy), q.y);\n\treturn length(max(vec2(d1, d2), 0.0)) + min(max(d1, d2), 0.);\n}\n\nfloat sdConeSection( in vec3 p, in float h, in float r1, in float r2) {\n\tfloat d1 = -p.y - h;\n\tfloat q = p.y - h;\n\tfloat si = 0.5 * (r1 - r2) / h;\n\tfloat d2 = max(sqrt(dot(p.xz, p.xz) * (1.0 - si * si)) + q * si - r2, q);\n\treturn length(max(vec2(d1, d2), 0.0)) + min(max(d1, d2), 0.);\n}\n\nfloat length2(vec2 p) {\n\treturn sqrt(p.x * p.x + p.y * p.y);\n}\n\nfloat length6(vec2 p) {\n\tp = p * p * p;\n\tp = p * p;\n\treturn pow(p.x + p.y, 1.0 / 6.0);\n}\n\nfloat length8(vec2 p) {\n\tp = p * p;\n\tp = p * p;\n\tp = p * p;\n\treturn pow(p.x + p.y, 1.0 / 8.0);\n}\n\nfloat sdTorus82(vec3 p, vec2 t) {\n\tvec2 q = vec2(length2(p.xz) - t.x, p.y);\n\treturn length8(q) - t.y;\n}\n\nfloat sdTorus88(vec3 p, vec2 t) {\n\tvec2 q = vec2(length8(p.xz) - t.x, p.y);\n\treturn length8(q) - t.y;\n}\n\nfloat sdCylinder6(vec3 p, vec2 h) {\n\treturn max(length6(p.xz) - h.x, abs(p.y) - h.y);\n}\n\nfloat flower(vec3 p, float r) {\n\tfloat q = length(p);\n\tp -= vec3(sin(p.x * 15.1), sin(p.y * 25.1), sin(p.z * 15.0)) * 0.01; //some space warping\n\tvec3 n = normalize(p);\n\tq = length(p); // distance before flowerwarp\n\n\tfloat rho = atan(length(vec2(n.x, n.z)), n.y) * 20.0 + q * 15.01; //vertical part of  cartesian to polar with some q warp\n\tfloat theta = atan(n.x, n.z) * 6.0 + p.y * 3.0 + rho * 1.50; //horizontal part plus some warp by z(bend up) and by rho(twist)\n\treturn length(p) - (r + sin(theta) * 0.3 * (1.3 - abs(dot(n, vec3(0, 1, 0)))) //the 1-abs(dot()) is limiting the warp effect at poles\n\t\t+ sin(rho - iTime * 2.0) * 0.3 * (1.3 - abs(dot(n, vec3(0, 1, 0))))); // 1.3-abs(dot()means putting some back in \n}\n\nfloat TTorus(vec3 p, vec2 t) {\n\tvec2 q = vec2(length(p.xz) - t.x, p.y);\n\treturn length(q) - t.y;\n}\n\nfloat ChamferBox(vec3 p, vec3 b, float ch) {\n\tp = max(abs(p) - b, 0.0); // + vec3(ch, ch, ch);\n\tif ((p.x - ch) > (p.y + p.z)) {\n\t\treturn length(p - vec3(ch, 0, 0));\n\t}\n\telse if ((p.y - ch) > (p.x + p.z)) {\n\t\treturn length(p - vec3(0, ch, 0));\n\t}\n\telse if ((p.z - ch) > (p.y + p.x)) {\n\t\treturn length(p - vec3(0, 0, ch));\n\t}\n\telse {\n\t\treturn\n\t\tmax(dot(vec3(0.57735, 0.57735, 0.57735), p) / 0.7967329 - ch * 0.7967329,\n\t\t\tmax(dot(vec3(0.0, 0.707107, 0.707107), p) - ch * 0.7967329,\n\t\t\t\tmax(dot(vec3(0.707107, 0.0, 0.707107), p) - ch * 0.7967329,\n\t\t\t\t\tdot(vec3(0.707107, 0.707107, 0.0), p) - ch * 0.7967329))) + 0.005;\n\t}\n}\n//----------------------------------------------------------------------\n\nfloat opS(float d1, float d2) {\n\treturn max(-d2, d1);\n}\n\nvec2 opU(vec2 d1, vec2 d2) {\n\treturn (d1.x < d2.x) ? d1 : d2;\n}\n\nvec3 opRep(vec3 p, vec3 c) {\n\treturn mod(p, c) - 0.5 * c;\n}\n\nvec3 opTwist(vec3 p) {\n\tfloat c = cos(10.0 * p.y + 10.0);\n\tfloat s = sin(10.0 * p.y + 10.0);\n\tmat2 m = mat2(c, -s, s, c);\n\treturn vec3(m * p.xz, p.y);\n}\n\n//----------------------------------------------------------------------\n\nvec2 map( in vec3 pos) {\n\n\treturn vec2(flower(pos, 0.750), 15.1);\n\n}\n\nvec2 castRay( in vec3 ro, in vec3 rd) {\n\tfloat tmin = 1.0;\n\tfloat tmax = 20.0;\n\n\t#if 0\n    {\n        float tp1 = (0.0 - ro.y) / rd.y;\n\tif (tp1 > 0.0) tmax = min(tmax, tp1);\n\tfloat tp2 = (1.6 - ro.y) / rd.y;\n\tif (tp2 > 0.0) {\n\t\tif (ro.y > 1.6) tmin = max(tmin, tp2);\n\t\telse tmax = min(tmax, tp2);\n\t}\n    #\tendif\n\n\tfloat precis = 0.1;\n\tfloat t = tmin;\n\tfloat m = -1.0;\n\tfor (int i = 0; i < 400; i++) {\n\t\tvec2 res = map(ro + rd * t);\n\t\tif (res.x < precis || t > tmax) break;\n\t\tt += res.x * 0.05;\n\t\tm = res.y;\n\t}\n\n\tif (t > tmax) m = -1.0;\n\treturn vec2(t, m);\n}\n\nfloat softshadow( in vec3 ro, in vec3 rd, in float mint, in float tmax) {\n\tfloat res = 1.0;\n\tfloat t = mint;\n\tfor (int i = 0; i < 16; i++) {\n\t\tfloat h = map(ro + rd * t).x;\n\t\tres = min(res, 8.0 * h / t);\n\t\tt += clamp(h, 0.02, 0.10);\n\t\tif (h < 0.001 || t > tmax) break;\n\t}\n\treturn clamp(res, 0.0, 1.0);\n\n}\n\nvec3 calcNormal( in vec3 pos) {\n\tvec3 eps = vec3(0.001, 0.0, 0.0);\n\tvec3 nor = vec3(\n\t\tmap(pos + eps.xyy).x - map(pos - eps.xyy).x,\n\t\tmap(pos + eps.yxy).x - map(pos - eps.yxy).x,\n\t\tmap(pos + eps.yyx).x - map(pos - eps.yyx).x);\n\treturn normalize(nor);\n}\n\nfloat calcAO( in vec3 pos, in vec3 nor) {\n\tfloat occ = 0.0;\n\tfloat sca = 1.0;\n\tfor (int i = 0; i < 15; i++) {\n\t\tfloat hr = 0.05 + 0.12 * float(i) / 4.0;\n\t\tvec3 aopos = nor * hr + pos;\n\t\tfloat dd = map(aopos).x;\n\t\tocc += -(dd - hr) * sca;\n\t\tsca *= 0.95;\n\t}\n\treturn clamp(1.0 - 3.0 * occ, 0.0, 1.0);\n}\n\nvec3 render( in vec3 ro, in vec3 rd) {\n\tvec3 col = vec3(0.7, 0.9, 1.0) + rd.y * 0.8;\n\tvec2 res = castRay(ro, rd);\n\tfloat t = res.x;\n\tfloat m = res.y;\n\tif (m > -0.5) {\n\t\tvec3 pos = ro + t * rd;\n\t\tvec3 nor = calcNormal(pos);\n\t\tvec3 ref = reflect(rd, nor);\n\n\t\t// material        \n\t\tcol = 0.50 + 0.3 * sin(vec3(2.3 - pos.y / 2.0, 2.15 - pos.y / 4.0, -1.30) * (m - 1.0));\n\n\t\tif (m < 1.5) {\n\n\t\t\tfloat f = mod(floor(5.0 * pos.z) + floor(5.0 * pos.x), 2.0);\n\t\t\tcol = 0.4 + 0.1 * f * vec3(1.0);\n\t\t}\n\n\t\t// lighitng        \n\t\tfloat occ = calcAO(pos, nor);\n\t\tvec3 lig = normalize(vec3(-0.6, 0.7, -0.5));\n\t\tfloat amb = 0.0; // clamp( 0.5+0.5*nor.y, 0.0, 1.0 );\n\t\tfloat dif = clamp(dot(nor, lig), 0.0, 1.0);\n\t\tfloat bac = 0.0; // clamp( dot( nor, normalize(vec3(-lig.x,0.0,-lig.z))), 0.0, 1.0 )*clamp( 1.0-pos.y,0.0,1.0);\n\t\tfloat dom = smoothstep(-0.1, 0.1, ref.y);\n\t\tfloat fre = 0.750; //pow( clamp(1.0+dot(nor,rd),0.0,1.0), 2.0 );\n\t\tfloat spe = 0.0; //pow(clamp( dot( ref, lig ), 0.0, 1.0 ),16.0);\n\n\t\t//dif *= softshadow( pos, lig, 0.02, 2.5 );\n\t\t//dom *= softshadow( pos, ref, 0.02, 2.5 );\n\n\t\tvec3 lin = vec3(0.0);\n\t\tlin += 1.20 * dif * vec3(1.00, 0.85, 0.55);\n\t\tlin += 1.20 * spe * vec3(1.00, 0.85, 0.55) * dif;\n\t\tlin += 0.20 * amb * vec3(0.50, 0.70, 1.00) * occ;\n\t\tlin += 0.30 * dom * vec3(0.50, 0.70, 1.00) * occ;\n\t\tlin += 0.30 * bac * vec3(0.25, 0.25, 0.25) * occ;\n\t\tlin += 0.40 * fre * vec3(1.00, 1.00, 1.00) * occ;\n\t\tcol = col * lin;\n\n\t\tcol = mix(col, vec3(0.8, 0.9, 1.0), 1.0 - exp(-0.002 * t * t));\n\n\t}\n\n\treturn vec3(clamp(col, 0.0, 1.0));\n}\n\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr) {\n\tvec3 cw = normalize(ta - ro);\n\tvec3 cp = vec3(sin(cr), cos(cr), 0.0);\n\tvec3 cu = normalize(cross(cw, cp));\n\tvec3 cv = normalize(cross(cu, cw));\n\treturn mat3(cu, cv, cw);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n\tvec2 q = fragCoord.xy / iResolution.xy;\n\tvec2 p = -1.0 + 2.0 * q;\n\tp.x *= iResolution.x / iResolution.y;\n\tvec2 mo = iMouse.xy / iResolution.xy;\n\n\tfloat time = 15.0 + iTime * 3.0;\n\n\t// camera\t\n\tvec3 ro = vec3(0.0, 3.5 * cos(0.1 * -time), 4.0);\n\n\t//vec3( -0.5+3.5*cos(0.1*time + 6.0*mo.x),1.0+3.5*sin(6.0* mo.y), 0.0 + 3.5*sin(0.1*time + 6.0*mo.x)-3.5*cos(  6.0*-mo.y) );\n\tvec3 ta = vec3(-0.1, 0, 0.10);\n\n\t// camera-to-world transformation\n\tmat3 ca = setCamera(ro, ta, 0.0);\n\n\t// ray direction\n\tvec3 rd = ca * normalize(vec3(p.xy, 2.0));\n\n\t// render\t\n\tvec3 col = render(ro, rd);\n\n\tcol = pow(col, vec3(0.4545));\n\n\tfragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MltSRf.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[378, 378, 401, 401, 416], [418, 418, 451, 451, 476], [478, 478, 507, 507, 596], [598, 598, 640, 640, 699], [701, 701, 744, 744, 788], [790, 790, 821, 821, 876], [881, 881, 915, 915, 1016], [1018, 1018, 1055, 1055, 1215], [1217, 1217, 1288, 1288, 1503], [1505, 1505, 1528, 1528, 1567], [1569, 1569, 1592, 1592, 1657], [1659, 1659, 1682, 1682, 1755], [1757, 1757, 1790, 1790, 1860], [1862, 1862, 1895, 1895, 1965], [1967, 1967, 2002, 2002, 2054], [2056, 2056, 2087, 2087, 2774], [2776, 2776, 2806, 2806, 2874], [2876, 2876, 2920, 2920, 3496], [3571, 3571, 3602, 3602, 3626], [3628, 3628, 3656, 3656, 3691], [3693, 3693, 3721, 3721, 3752], [3754, 3754, 3776, 3776, 3906], [3982, 3982, 4006, 4006, 4050]], "test": "valid"}
{"id": "MltSW2", "name": "Rectangle AA", "author": "kd_christoph", "description": "playing around with fwidth", "tags": ["2d", "antialiasing"], "likes": 0, "viewed": 111, "published": "Public", "date": "1481712385", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const highp float pi = 3.14159;\n\n#define adaptive\n#define AA\n\n//Rect (2point)   x1  y1   x2   y2\nvec4 rect = vec4(0.1, 0.2, 0.7, 0.6);\n    \n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    uv = uv - vec2(0.5);\n    \n    //rotMatrix\n    float angle = (45.0/360.0 * 2.0 * pi);\n    mat2 rot = mat2( cos(angle), -sin(angle),\n                     sin(angle),  cos(angle) );\n    vec2 uv_rot = uv * rot;\n    \n    rect *=0.5+(sin(iTime*0.05))/2.0;\n    \n    vec2 d = max(rect.xy-uv_rot, uv_rot-rect.zw);\n    float dist = length(max(vec2(0.0), d)) + min(0.0, max(d.x, d.y));\n\n//calculate AA amount based on distance in terms of pixels\n#ifdef adaptive\n    vec2 thresh = vec2(fwidth(dist)*2.0);\n//calculate AA based on fixed value\n#else\n    vec2 thresh = vec2(0.003);\n#endif\n\n//smoothstep --> AA\n#ifdef AA\n    vec2 hv = smoothstep(rect.xy-thresh, rect.xy, uv_rot) * smoothstep(uv_rot-thresh, uv_rot, rect.zw);\n//step --> no AA\n#else\n    vec2 hv = step(rect.xy, uv_rot) * step(uv_rot, rect.zw);\n#endif\n\n    //build the rectangle out of 2 infinite quadrants\n    float onOff = hv.x * hv.y;\n    \n    //draw background\n    vec4 col = vec4(0,0,0,0);\n    //draw rectangle\n    col =  mix(col, vec4(1,0,0,0), onOff);\n    //optionally draw distance field ontop\n    col = mix(col, vec4(1.0,1.0,0,0), -dist*10.0);\n\n    fragColor = col;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MltSW2.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[141, 141, 198, 198, 1371]], "test": "valid"}
{"id": "MltSWj", "name": "", "author": "Ilygos", "description": "", "tags": [], "likes": 0, "viewed": 75, "published": "Public", "date": "1481706734", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float radius = 100.0 + cos(iTime) * 50.0;\n    float centerX = iResolution.x/2.0 + cos(iTime)*250.0;\n    float centerY = iResolution.y/2.0 + sin(iTime)*100.0;\n    float distance = sqrt( pow(centerX - fragCoord.x, 2.0) + pow(centerY - fragCoord.y, 2.0));\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 vu = 8.0 / iResolution.xy;\n    if ( distance < radius){\n\t\tfragColor = vec4(uv,0.5+0.5*sin(iTime),1.0);\n    }else fragColor = vec4(vu, 0.2+0.8*sin(iTime), 0.5);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MltSWj.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 530]], "test": "valid"}
{"id": "MltSWM", "name": "Fun with Rays", "author": "Jrice06", "description": "Some research and careful study was required for this shader. Here I create a simple ray marcher and apply various transformations including rotation and scaling to create an interesting image. To me it looks like I am jumping through hyperspace.", "tags": ["3d"], "likes": 6, "viewed": 243, "published": "Public", "date": "1481062990", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float map(vec3 point)\n{\n    vec3 q = fract(point) * 2.0 - 1.0;\n    return length(q) - .25;\n}\n\nfloat trace(vec3 orgn, vec3 ray)\n{\n    float t = 0.0;\n    for (int ndx = 0; ndx < 32; ndx++) {\n        vec3 point = orgn + ray * t;\n        float d = map(point);\n        t += d * .5;\n    }\n    return t;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    \n    uv = uv * 2.0 - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    float theta = iTime * .25;\n    \n    \n    vec3 ray = normalize(vec3(uv, 1.0));\n    ray.xz *= mat2(cos(theta), -sin(theta), sin(theta), cos(theta));\n    ray *= mat3(.5 + abs(sin(theta)), 0.0, 0.0, 0.0, .5 + abs(cos(theta)), 0.0, 0.0, 0.0, abs(sin(theta)));\n    \n    \n    vec3 orgn = vec3(0.0, 0.0, iTime);\n    float trc = trace(orgn, ray);\n    \n    float fog = 1.0 / (1.0 + trc * trc * .1);\n    \n    vec3 fg = vec3(fog * 2.5 * abs(cos(iTime / 5.0)), fog, fog * 2.5 * abs(sin(iTime / 5.0)));\n\tfragColor = vec4(fg,1.0);\n}", "image_inputs": [{"id": "XdXGzn", "previewfilepath": "/media/ap/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MltSWM.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 23, 23, 92], [94, 94, 128, 128, 298], [300, 300, 357, 357, 999]], "test": "valid"}
{"id": "MltXWf", "name": "Yum yum candy mandelzoom", "author": "Virgill", "description": "Mandelbrot pseudo 3d zoom from the pc-demo \"Calcatraz\"\nhttp://www.pouet.net/prod.php?which=67985\n\nOriginal \"Droste Mandelbrot\" by vgs\nhttps://www.shadertoy.com/view/XssXWr", "tags": ["mandelbrot", "zoom", "pseudo3d"], "likes": 14, "viewed": 933, "published": "Public API", "date": "1481978664", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Original \"Droste Mandelbrot\" vgs/2014\n// https://www.shadertoy.com/view/XssXWr\n\n#define TAU 6.28318530718\n\n\n\nvec2 droste(in vec2 uv) {\n\tfloat alpha = atan(log(2.0/.3)/TAU) - 0.0;\n\tvec2 rot = vec2(cos(alpha), sin(alpha));\n\tuv = vec2(log(length(uv)), atan(uv.y, uv.x));\n\tuv = vec2(uv.x*rot.x - uv.y*rot.y, uv.x*rot.y + uv.y*rot.x)/rot.x;\n\tuv.x = mod(uv.x, log(2.0/.3));\n    return 0.3*exp(uv.x)*vec2(cos(uv.y-0.5*iTime), sin(uv.y-0.5*iTime)); // drehung\n\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tfloat t = exp(-mod(0.90*iTime, +20.825));\n\tvec2 z = vec2(0.0), dz = vec2(0.0);\n\tvec2 uv = droste(t*(-iResolution.xy+2.0*fragCoord.xy)/iResolution.y);\n\tvec2 c = uv - vec2(0.5, -0.2);\n\tfor (int i = 0; i < 256; ++i) \n    {\n\t\tif (dot(z, z) > 40.0) continue;\n\t\tdz = 2.0*vec2(z.x*dz.x - z.y*dz.y, z.x*dz.y + z.y*dz.x) + vec2(1.0, 0.0);\n\t\tz = vec2(z.x*z.x - z.y*z.y, 2.0*z.x*z.y) + c;\t\t\n\t}\n\tfloat d = abs(length(uv) -2.0);\n\td *= dot(z, z) <= 32.0 ? 0.0 : 0.5*sqrt(dot(z,z)/dot(dz,dz))*log(dot(z,z));\n\tfloat t2 = exp(-mod(0.9*iTime, +20.825)); \n\tvec2 z2 = vec2(0.0), dz2 = vec2(0.0);\n\tvec2 uv2 = droste(t2*(-iResolution.xy+2.01*fragCoord.xy)/iResolution.y);\n\tvec2 c2 = uv2 - vec2(0.5, -0.25);\n\tfloat iflo = 1.0;\n\tfor (int i2 = 0; i2 < 256; ++i2) \n    {\n\t\tif (dot(z2, z2) > 15.0) continue;\n        if (iflo >= 0.4) {iflo -= 0.08*(1./iflo);}\n        dz2 = 2.0*vec2(z2.x*dz2.x - z2.y*dz2.y, z2.x*dz2.y + z2.y*dz2.x) + vec2(1.0, 0.0);\n\t\tz2 = vec2(z2.x*z2.x - z2.y*z2.y, 2.0*z2.x*z2.y) + c2;\n\t}\n\tfloat d2 = abs(length(uv2) -2.0);\n\td2 *= dot(z2, z2) <= 32.0 ? 0.0 : 0.5*sqrt(dot(z2,z2)/dot(dz2,dz2))*log(dot(z2,z2));\n\n    vec3 col = vec3(9.*d,10.*d,12.0*d);\n    vec3 col2 = vec3(iflo,iflo,iflo*2.4);\n\tfragColor = mix(vec4(col*vec3(pow(d, 0.5)),1.0),vec4(col2*vec3(pow(d2, .2)),1.0),0.5*col2.z);\n    \n}", "image_inputs": [{"id": "4sS3Ww", "previewfilepath": "https://soundcloud.com/virgill/calcatraz", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "https://soundcloud.com/virgill/calcatraz", "ctype": "musicstream"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MltXWf.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[112, 112, 137, 137, 457], [459, 459, 516, 516, 1805]], "test": "valid"}
{"id": "MltXWl", "name": "glowing leds", "author": "acdimalev", "description": "I've been studying and it's test time.", "tags": ["sdf", "pbr", "ld48"], "likes": 2, "viewed": 152, "published": "Public", "date": "1482345697", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Glowing LEDs\n//\n//\n// Abstract\n//\n// I failed at Ludum Dare recently.  During the competition I asked myself if I could\n// write a game that ran nearly 100% out of GLSL.  To my surprise, the answer is\n// \"quite possibly\".  But one of the hurdles is learning how to render a scene without\n// too much help from an external program.\n//\n// Since there are really nice modern tools like Shadertoy to practice with GLSL,\n// and since GLSL is still the industry standard for writing shaders, I decided to\n// persue studying modern rendering techniques.\n//\n// This demo is a record of my progress.\n//\n// In particular, it is a demonstration, with several references, of the following\n// techniques:\n//\n// - Signed Distance Function\n// - Color Space Conversion\n// - Physically-Based Rendering\n//\n//\n// References\n//\n// Ray Marching and Signed Distance Functions\n// http://jamie-wong.com/2016/07/15/ray-marching-signed-distance-functions/\n//\n// PBR_Test\n// https://www.shadertoy.com/view/MlB3DV\n//\n// PHYSICALLY-BASED RENDERING, AND YOU CAN TOO!\n// https://www.marmoset.co/posts/physically-based-rendering-and-you-can-too/\n//\n// Physically-Based Shading at Disney\n// http://blog.selfshadow.com/publications/s2012-shading-course/burley/s2012_pbs_disney_brdf_slides_v2.pdf\n//\n\nconst float EPSILON = 1.0 / 256.0;\nconst float PI = 3.14159;\n\nfloat op_i(float d1, float d2) { return max(d1, d2); }\nfloat op_u(float d1, float d2) { return min(d1, d2); }\n\nfloat sd_plane(vec3 p, vec4 n) {\n  // n must be normalized\n  return dot(p, n.xyz) + n.w;\n}\n\nfloat sd_segment(vec3 p, float a, float b, float c, float d) {\n    vec3 q1 = abs(p);\n    vec3 q2 = q1 + vec3(0.0, d, 0.0);\n    float n2 = 1.0 / sqrt(2.0);\n    float n3 = 1.0 / sqrt(3.0);\n    float d1 = sd_plane(q2, vec4(n3, n3, n3, -a * n3));\n    float d2 = q1.y - b;\n    float d3 = sd_plane(q1, vec4(n2, n2, 0.0, -c));\n    return op_i(d1, op_i(d2, d3));\n}\n\nfloat scene_sdf(vec3 p) {\n    // FIXME: adding a slant here distorts the distance function\n    vec3 p1 = p; // vec3(p.x + p.z / 4.0, p.y, p.z);\n    vec3 c0 = vec3(2.0, 1024.0, 2.0);\n    vec3 c1 = vec3(0.0, c0.y, 0.0);\n    vec3 q1 = mod(p1 + c1 / 2.0, c0) - c0 / 2.0;\n    vec3 q2 = mod(p1.zyx + c0 / 2.0, c0) - c0 / 2.0;\n    \n    vec4 v = vec4(1.0, 1.0/32.0, 1.0/4.0, 1.0/8.0);\n    float d1 = sd_segment(q1, v.x, v.y, v.z, v.w);\n    float d2 = sd_segment(q2, v.x, v.y, v.z, v.w);\n    return op_u(d1, d2);\n}\n\nvec3 ray_march(vec3 eye, vec3 ray, float max_depth) {\n    const int max_iterations = 64;\n    const float E = EPSILON;\n    \n    float dist = 0.0;\n    float sdf = 0.0;\n    float iter = 0.0;\n    \n    for (int i = 0; i < max_iterations; i++) {\n        iter = float(i);\n        vec3 p = eye + dist * ray;\n        sdf = scene_sdf(p);\n        if (sdf < E * dist) { break; }\n        dist += sdf;\n        if (dist > max_depth) { break; }\n    }\n    \n    return vec3(dist, sdf, iter);\n}\n\nvec3 ray_normal(vec3 eye, vec3 ray, vec3 marched) {\n    const vec2 o = vec2(0.0, EPSILON);\n    \n    float d = marched.y;\n    vec3 p = eye + marched.x * ray;\n    \n    return normalize(vec3(\n        scene_sdf(p + o.yxx) - d,\n        scene_sdf(p + o.xyx) - d,\n        scene_sdf(p + o.xxy) - d ));\n}\n\nvec3 half_vector(vec3 v1, vec3 v2) {\n    return normalize(v1 + v2);\n}\n\n// https://en.wikipedia.org/wiki/Specular_highlight#Cook.E2.80.93Torrance_model\nfloat geometric_attenuation(vec3 n, vec3 v, vec3 l) {\n    vec3 h = half_vector(v, l);\n\n    float c = 2.0 * dot(h, n) / dot(v, h);\n    float g1 = c * dot(v, n);\n    float g2 = c * dot(l, n);\n\n    return min(1.0, min(g1, g2));\n}\n\n// https://en.wikipedia.org/wiki/Specular_highlight#Beckmann_distribution\nfloat beckmann_distribution(vec3 n, vec3 v, vec3 l, float roughness) {\n    vec3 h = half_vector(v, l);\n    float m = roughness;\n\n    float n_dot_h = dot(n, h);\n    float n_dot_h_sq = n_dot_h * n_dot_h;\n    float n_dot_h_qu = n_dot_h_sq * n_dot_h_sq;\n    float m_sq = m * m;\n\n    float expr1 = (n_dot_h_sq - 1.0) / (n_dot_h_sq * m_sq);\n    float expr2 = PI * m_sq * n_dot_h_qu;\n\n    return exp(expr1) / expr2;\n}\n\n// https://en.wikipedia.org/wiki/Schlick's_approximation\nfloat shlick_fresnel(vec3 n, vec3 v, vec3 l, float reflection_coefficient) {\n    vec3 h = half_vector(v, l);\n    float c = reflection_coefficient;\n\n    float hv = dot(h, v);\n    return c + (1.0 - c) * pow(1.0 - hv, 5.0);\n}\n\n// with a separate reflection coefficient for each color channel\nvec3 shlick_fresnel(vec3 n, vec3 v, vec3 l, vec3 reflection_coefficients) {\n    vec3 h = half_vector(v, l);\n    vec3 c = reflection_coefficients;\n\n    float hv = dot(h, v);\n    return c + (1.0 - c) * pow(1.0 - hv, 5.0);\n}\n\n// https://en.wikipedia.org/wiki/Specular_highlight#Cook.E2.80.93Torrance_model\nvec3 specular(vec3 n, vec3 v, vec3 l, vec3 F0, float roughness) {\n    vec3 reflection_coefficients = F0;\n    \n    float d = beckmann_distribution(n, v, l, roughness);\n    vec3 f = shlick_fresnel(n, v, l, reflection_coefficients);\n    float g = geometric_attenuation(n, v, l);\n    \n    vec3 k1 = d * f * g;\n    float k2 = 4.0 * dot(v, n) * dot(n, l);\n    \n    return k1 / k2;\n}\n\n// FIXME: locate source of this \"trivial BRDF\"\nvec3 diffuse(vec3 albedo) {\n    return albedo / PI;\n}\n\nvec3 render(vec3 eye, vec3 ray, vec3 marched, vec3 albedo, vec3 glow, float metalness, float roughness) {\n    vec3 n = ray_normal(eye, ray, marched);\n    vec3 v = -ray;\n    vec3 p = eye + marched.x * ray;\n    \n    vec3 diffuse_albedo = albedo * (1.0 - metalness);\n    vec3 F0 = 0.04 * (1.0 - metalness) + albedo * metalness;\n    \n    vec3 light1p = vec3(0.0, 8.0, 12.0);\n    vec3 light1c = vec3(1.0);\n    vec3 l1 = normalize(light1p - p);\n    vec3 specular1 = specular(n, v, l1, F0, roughness);\n    vec3 diffuse1 = diffuse(diffuse_albedo);\n    vec3 color1 = (diffuse1 + specular1) * light1c * max(0.0, dot(l1, n));\n\n    vec3 light2c = vec3(1.0 / 4.0);\n    vec3 l2 = vec3(0.0, -1.0, 0.0);\n    vec3 diffuse2 = diffuse(diffuse_albedo);\n    vec3 color2 = diffuse2 * light2c * max(0.0, dot(l2, n));\n    \n    return glow + color1 + color2;\n}\n\n// calculate ray vector for a given fragment coordinate\n//\n// this function also determines the handed-ness of the coordinate system\n//   z < 0 : left-handed\n//   z > 0 : right-handed\n//\nvec3 ray_vector(float fov, vec3 iResolution, vec2 fragCoord) {\n\n    // FIXME -- account for pixel aspect ratio\n    // iResolution.z is the pixel aspect ratio\n    // since this is 1.0 on my machine, I can not properly test compensation\n\n    // scale relative to pixel density\n    float size = sqrt(iResolution.x * iResolution.y);\n\n    // calculate vector in screen coordinates\n    vec2 xy = fragCoord - iResolution.xy / 2.0;\n    float z = (size / 2.0) / tan(fov / 2.0);\n\n    // return normalized vector\n    return normalize(vec3(xy, z));\n}\n\n// return a view matrix from `eye` to `center`\n//\n// based on gluLookAt\n// and kindly translated to GLSL by jlfwong\n// https://www.shadertoy.com/user/jlfwong\n//\n// the sign of `f` on the output matrix must be adjusted\n// to match the handed-ness of the coordinate system\n//   left-handed: -f\n//   right-handed: f\n//\nmat3 view_matrix(vec3 eye, vec3 center, vec3 up) {\n    vec3 f = normalize(center - eye);\n    vec3 s = cross(f, up);\n    vec3 u = cross(s, f);\n    return mat3(s, u, f);\n}\n\n// https://twitter.com/jimhejl/status/633777619998130176\nvec3 tonemap(vec3 hdr, float white_point) {\n    vec4 vh = vec4(hdr, white_point);\n    vec4 va = 1.425 * vh + 0.05;\n    vec4 vf = (vh * va + 0.004) / (vh * (va + 0.55) + 0.0491) - 0.0821;\n    return vf.rgb / vf.www;\n}\n\n// https://en.wikipedia.org/wiki/SRGB\nvec3 srgb_to_linear(vec3 srgb) {\n    float a = 0.055;\n    float b = 0.04045;\n    vec3 linear_lo = srgb / 12.92;\n    vec3 linear_hi = pow((srgb + vec3(a)) / (1.0 + a), vec3(2.4));\n    return vec3(\n        srgb.r > b ? linear_hi.r : linear_lo.r,\n        srgb.g > b ? linear_hi.g : linear_lo.g,\n        srgb.b > b ? linear_hi.b : linear_lo.b);\n}\n\n// https://en.wikipedia.org/wiki/SRGB\nvec3 linear_to_srgb(vec3 linear) {\n    float a = 0.055;\n    float b = 0.0031308;\n    vec3 srgb_lo = 12.92 * linear;\n    vec3 srgb_hi = (1.0 + a) * pow(linear, vec3(1.0/2.4)) - vec3(a);\n    return vec3(\n        linear.r > b ? srgb_hi.r : srgb_lo.r,\n        linear.g > b ? srgb_hi.g : srgb_lo.g,\n        linear.b > b ? srgb_hi.b : srgb_lo.b);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float fov = radians(45.0);\n    const float max_depth = 256.0;\n    \n    const vec3 albedo = vec3(0.7, 0.2, 0.2);\n    const vec3 glow = vec3(0.4, 0.0, 0.0);\n    const float metalness = 0.0;\n    const float roughness = 1.0 / 8.0;\n    \n    float t1 = mod(iTime / 2.0, 2.0 * PI);\n    float t2 = mod(iTime / 8.0, 2.0 * PI);\n    \n    vec3 eye = vec3(4.0 * sin(t1), 3.0 + sin(t2), -4.0 * cos(t1));\n    vec3 center = vec3(0.0, 0.0, 0.0);\n    vec3 up = vec3(0.0, 1.0, 0.0);\n    \n    mat3 view = view_matrix(eye, center, up);\n    vec3 ray = view * ray_vector(fov, iResolution, fragCoord);\n    \n    vec3 marched = ray_march(eye, ray, max_depth);\n    \n    // debug\n    // vec3 color = vec3(1.0 / sqrt(marched.z));\n    // fragColor = vec4(linear_to_srgb(tonemap(color, 1.0)), 1.0);\n        \n    // debug\n    // vec3 normal = ray_normal(eye, ray, marched);\n    // vec3 color = normal / 2.0 + 0.5;\n    // fragColor = vec4(linear_to_srgb(tonemap(color / 2.0, 1.0)), 1.0);\n    \n    if (marched.x < max_depth) {\n        vec3 color = render(eye, ray, marched, albedo, glow, metalness, roughness);\n        fragColor = vec4(linear_to_srgb(tonemap(color / 2.0, 1.0)), 1.0);\n    }\n    else {\n        fragColor = vec4(0.0);\n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MltXWl.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1331, 1331, 1363, 1363, 1385], [1386, 1386, 1418, 1418, 1440], [1442, 1442, 1474, 1500, 1532], [1534, 1534, 1596, 1596, 1890], [1892, 1892, 1917, 1982, 2397], [2399, 2399, 2452, 2452, 2874], [2876, 2876, 2927, 2927, 3171], [3173, 3173, 3209, 3209, 3242], [3244, 3324, 3377, 3377, 3550], [3552, 3626, 3696, 3696, 4036], [4038, 4095, 4171, 4171, 4317], [4319, 4384, 4459, 4459, 4605], [4607, 4687, 4752, 4752, 5063], [5065, 5112, 5139, 5139, 5165], [5167, 5167, 5272, 5272, 6002], [6004, 6191, 6253, 6465, 6729], [6731, 7047, 7097, 7097, 7216], [7218, 7275, 7318, 7318, 7491], [7493, 7531, 7563, 7563, 7873], [7875, 7913, 7947, 7947, 8255], [8257, 8257, 8314, 8314, 9525]], "test": "valid"}
{"id": "Mt3SDB", "name": "Fireball Mataball tears", "author": "prime31", "description": "From http://blog.seans.site/post/154285665406/a-hot-shader", "tags": ["2d"], "likes": 1, "viewed": 108, "published": "Public", "date": "1481402198", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    const int numMetaballs = 4;\n\tfloat cosTime = cos( iTime ), sinTime = sin( iTime );\t\n\t\n    // UNIFORMS\n    float tearSharpness = 7.0;\n    float tearWaveLength = 5.0;\n    float tearWaveSpeed = 500.0;\n    float tearWaveAmplitude = 10.0;\n    \n    vec2 ditherAmount = vec2( 20.0, 20.0 );\n    \n    vec2 metaballs[4];\n\tmetaballs[0] = vec2( cosTime * 200. + 300., sinTime * 150. + 200.);\n\tmetaballs[1] = vec2( cosTime * 250. + 350., sin( iTime * 0.25 ) * 100. + 200. );\n\tmetaballs[2] = vec2( cos( iTime * 0.33 ) * 300. + 350., sin( iTime * 1.5 ) * 150. + 200.);\n\tmetaballs[3] = iMouse.xy;\n    \n\tfloat metaball_size[4];\n\tmetaball_size[0] = 100.0;\n\tmetaball_size[1] = 190.0;\n\tmetaball_size[2] = 150.0;\n\tmetaball_size[3] = 100.0;\n    \n    float metaballInfluence[4];\n\tmetaballInfluence[0] = 1.2;\n\tmetaballInfluence[1] = 0.9;\n\tmetaballInfluence[2] = 0.8;\n\tmetaballInfluence[3] = 1.0;\n    \n    \n\tfloat influence = 0.0;\n    \n    float x = gl_FragCoord.x;\n    float y = gl_FragCoord.y;\n    \n    // calculate total influence\n    for( int i = 0; i < numMetaballs; ++i )\n    {\n        // start off with distance between pixel and metaball\n        float d = distance( gl_FragCoord.xy, metaballs[i] );\n        \n\t\t// pick a point above metaball\n\t\tfloat tearOffset = metaballs[i].y + metaball_size[i];\n\n\t\t// animate tear offset\n        tearOffset -= ( sin( gl_FragCoord.x / tearWaveLength + iTime * tearWaveSpeed / metaball_size[i] ) * tearWaveAmplitude );\n        \n        // apply tear shape\n\t\td += pow( distance( gl_FragCoord.x, metaballs[i].x ) * tearSharpness / distance( gl_FragCoord.y, tearOffset ), 2.0 );\n\n        // flame wave\n        x = gl_FragCoord.x;\n        y = gl_FragCoord.y;\n        x += sin( gl_FragCoord.y / ditherAmount.x + cosTime * 4.0 );\n        y += cos( gl_FragCoord.x / ditherAmount.y + sinTime * 4.0 );\n\n        // dither\n        d += sin( y * 3.14 + iTime ) * metaball_size[i] / ditherAmount.y;\n        d += cos( x * 3.14 + iTime ) * metaball_size[i] / ditherAmount.x;\n        \n        // divide by radius and keep within range (0.0, 1.0)\n        d = min( 1.0, d / metaball_size[i] );\n                \n        // smooth falloff\n        d = ( 1.0 - d * d );\n        d *= d;\n                \n        // add to total (with multiplier)\n        influence += d * metaballInfluence[i];\n    }\n\n\t// output\n\tfragColor.r = step( 0.01, influence );\n    fragColor.g = step( 0.3, influence );\n    fragColor.b = step( 0.75, influence );\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Mt3SDB.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 2492]], "test": "valid"}
{"id": "Mt3Szf", "name": "Cauldron", "author": "zackpudil", "description": "fractal bump mapping on a simple cylinder.  Geometry is not so interesting.", "tags": ["raymarching", "kali"], "likes": 11, "viewed": 238, "published": "Public", "date": "1480979199", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float time() { return iTime; }\n\nvec3 material(vec2 p) {\n\tvec3 col = vec3(100);\n\t\n\tfor(int i = 0; i < 15; i++) {\n\t\tp = abs(p)/dot(p, p) - vec2(0.5, 0.3);\n\t\tcol = min(col, vec3(abs(p.x), length(p), abs(2.0*p.y)));\n\t}\n\t\n\treturn col;\n}\n\nvec3 matcube(vec3 p, vec3 n) {\n\tvec3 m = pow(abs(n), vec3(10.0));\n\t\n\tvec3 x = material(p.yz);\n\tvec3 y = material(p.xz);\n\tvec3 z = material(p.xy);\n\t\n\treturn (m.x*x + m.y*y + m.z*z)/(m.x + m.y + m.z);\n}\n\nvec3 matbump(vec3 p, vec3 n) {\n\tvec3 gs = vec3(0.21, 0.72, 0.07);\n\tvec2 h = vec2(0.015, 0.0);\n\t\n\tfloat res = dot(gs, matcube(p, n));\n\tmat3 m = mat3(\n\t\tmatcube(p - h.xyy, n),\n\t\tmatcube(p - h.yxy, n),\n\t\tmatcube(p - h.yyx, n)\n\t);\n\t\n\tvec3 g = (gs*m - res)/h.x;\n\tg -= n*dot(g, n);\n\t\n\treturn g;\n}\n\nfloat de(vec3 p) {\n\treturn min(length(p.xz) - 1.0 + 0.8*sin(p.y), p.y + 1.0);\n}\n\nfloat trace(vec3 ro, vec3 rd, float mx) {\n\tfloat t = 0.0;\n\tfor(int i = 0; i < 100; i++) {\n\t\tfloat d = de(ro + rd*t);\n\t\tif(d < 0.001 || t >= mx) break;\n\t\tt += d*0.5;\n\t}\n\treturn t;\n}\n\nvec3 normal(vec3 p) {\n\tvec2 h = vec2(0.001, 0.0);\n\tvec3 n = normalize(vec3(\n\t\tde(p + h.xyy) - de(p - h.xyy),\n\t\tde(p + h.yxy) - de(p - h.yxy),\n\t\tde(p + h.yyx) - de(p - h.yyx)\n\t));\n\treturn n;\n}\n\nvec3 render(vec3 ro, vec3 rd) {\n\tvec3 col = vec3(0);\n\t\n\tfloat t = trace(ro, rd, 10.0);\n\tif(t < 10.0) {\n\t\tvec3 key = normalize(vec3(0.8, 0.7, -0.6));\n\t\t\n\t\tvec3 pos = ro + rd*t;\n\t\tvec3 nor = normal(pos);\n\t\tvec3 sn = normalize(nor + 0.04*matbump(pos, nor));\n\t\tvec3 sn2 = normalize(nor + 0.4*matbump(pos, nor));\n\t\tvec3 ref = normalize(reflect(rd, sn));\n\t\t\n\t\tcol += pow(clamp(dot(-rd, ref), 0.0, 1.0), 10.0);\n\t\tcol += pow(clamp(1.0 + dot(rd, sn2), 0.0, 1.0), 2.0);\n\t\t\n\t\tcol *= 2.0*matcube(pos, nor);\n\t}\n\t\n\treturn col;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n\tvec2 uv = (-iResolution.xy + 2.0*fragCoord)/iResolution.y;\n\t\n\tfloat at = time()*0.4;\n\tvec3 ro = vec3(1.0*sin(at), 1, -2.0*cos(at));\n\tvec3 ww = normalize(-ro);\n\tvec3 uu = normalize(cross(vec3(0, 1, 0), ww));\n\tvec3 vv = normalize(cross(ww, uu));\n\tvec3 rd = normalize(uv.x*uu + uv.y*vv + 1.97*ww);\n\t\n\tvec3 col = render(ro, rd);\n\t\n\tfragColor = vec4(col, 1);\n\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Mt3Szf.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 14, 14, 30], [32, 32, 55, 55, 231], [233, 233, 263, 263, 433], [435, 435, 465, 465, 725], [727, 727, 745, 745, 806], [808, 808, 849, 849, 988], [990, 990, 1011, 1011, 1181], [1183, 1183, 1214, 1214, 1697], [1699, 1699, 1754, 1754, 2112]], "test": "valid"}
{"id": "Mt3XDB", "name": "Orange Metaballs", "author": "prime31", "description": "playing around", "tags": ["2d"], "likes": 0, "viewed": 85, "published": "Public", "date": "1481559606", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tfloat c = cos( iTime ), s = sin( iTime );\t\n\tvec2 metaballs[4];\n\tmetaballs[0] = vec2( c * 200. + 300., s * 150. + 200.);\n\tmetaballs[1] = vec2( c * 250. + 350., sin( iTime * 0.25 ) * 100. + 200. );\n\tmetaballs[2] = vec2( cos( iTime * 0.33 ) * 300. + 350., sin( iTime * 1.5 ) * 150. + 200.);\n\tmetaballs[3] = iMouse.xy;\t\n\t\n\tfloat metaball_size[4];\n\tmetaball_size[0] = 100.0;\n\tmetaball_size[1] = 300.0;\n\tmetaball_size[2] = 150.0;\n\tmetaball_size[3] = 400.0;\n    \n    float tempy = 0.0;\n    for( int i = 0; i < 4; i++ )\n    {\n        float dx = metaballs[i].x - gl_FragCoord.x;\n        float dy = metaballs[i].y - gl_FragCoord.y;\n    \ttempy += metaball_size[i] / pow( dx * dx + dy * dy, 1.0 );\n    }\n    \n    // this way is a bit fuzzier\n    //fragColor = vec4( tempy * 0.8, tempy * 0.3, tempy * 0.3, 1.0 );\n\n    \n    // this way is more solid\n\tfragColor.r = step( 0.15, tempy );\n    fragColor.g = step( 0.3, tempy );\n    fragColor.b = step( 0.75, tempy );\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Mt3XDB.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 1, 58, 58, 1010]], "test": "valid"}
{"id": "MtcSWs", "name": "Broken Bumpy Mobius Spiral", "author": "voz", "description": "original: https://www.shadertoy.com/view/XlV3zR", "tags": ["spiral", "mobius", "broken", "bumpy"], "likes": 7, "viewed": 531, "published": "Public API", "date": "1482112911", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/**\n * Created by Kamil Kolaczynski (revers) - 2016\n *\n * Licensed under Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n *\n * This shader is based on:\n *\n * - \"Bumped Sinusoidal Warp\" by Shane [ https://www.shadertoy.com/view/4l2XWK ]\n * - \"Mobius Sierpinski\" by Shane [ https://www.shadertoy.com/view/XsGXDV ]\n * - \"Mobius\" by dilla [ https://www.shadertoy.com/view/MsSSRV ]\n *\n * Thanks for sharing the code guys!\n * \n * The shader was created and exported from Synthclipse (http://synthclipse.sourceforge.net/)\n */\n\n/**\n * true - concave bumps, false - convex bumps\n * Thanks, Shane!\n */\n\n//-----------------CONSTANTS MACROS-----------------\n\n#define PI 3.14159265359\n#define E 2.7182818284\n#define GR 1.61803398875\n#define MAX_DIM (max(iResolution.x,iResolution.y))\n\n//-----------------UTILITY MACROS-----------------\n\n#define time ((sin(float(__LINE__))/PI/GR/E/PI+1.0/PI/GR/E/PI)*iTime+1000.0)\n#define sphereN(uv) (clamp(1.0-length(uv*2.0-1.0), 0.0, 1.0))\n#define clip(x) (smoothstep(0.25, .75, x))\n#define TIMES_DETAILED (1.0)\n#define angle(uv) (atan(uv.y, uv.x))\n#define angle_percent(uv) ((angle(uv)/PI+1.0)/2.0)\n#define hash(p) (fract(sin(vec2( dot(p,vec2(127.5,313.7)),dot(p,vec2(239.5,185.3))))*43458.3453))\n\n#define flux(x) (vec3(cos(x),cos(4.0*PI/3.0+x),cos(2.0*PI/3.0+x))*.5+.5)\n#define rormal(x) (normalize(sin(vec3(time, time/GR, time*GR)+seedling)*.25+.5))\n#define rotatePoint(p,n,theta) (p*cos(theta)+cross(n,p)*sin(theta)+n*dot(p,n) *(1.0-cos(theta)))\n\nconst bool InvertNormal = true;\n\nconst float SpiralDensity = 0.2;\nconst float SpiralZoom = 0.5;\nconst int SpiralArms = 5;\nconst float BumpPower = 0.10150138;\nconst float BumpFactor = 0.0066746245;\nconst float LightSize = 2.9176579;\nconst float SampleDistance = 0.7;\nconst bool AntiAlias = true;\n\n#define TWO_PI 6.2831852\n\nvec2 cmul(vec2 a, vec2 b) {\n\treturn a * mat2(b.x, -b.y, b.y, b.x);\n}\n\nvec2 cinv(vec2 z) {\n\treturn vec2(z.x, -z.y) / dot(z, z);\n}\n\nvec2 cdiv(vec2 a, vec2 b) {\n\treturn cmul(a, cinv(b));\n}\n\nvec2 mobius(vec2 uv)\n{\n    \n    //numerator /= (abs(denominator)+1.0);\n    \n    \n    vec2 quotient = vec2(0.0);\n    const int bends = 4;\n    for(int i = 0; i < bends; i++)\n    {\n       \tfloat iteration = float(i)/float(bends);\n        vec2 numerator = uv;\n        vec2 denominator =rotatePoint(vec3(cmul(uv, sin(vec2(time+\n                                                             2.0*PI*sin(-iteration+\n                                                                                 time/GR), \n                                                             time/GR-2.0*PI*sin(iteration+\n                                                                                         time)))), 0.0), vec3(0.0, 0.0, 1.0), \n                                      time*PI).xy\n            +vec2(cos(iteration*16.0*PI-(time*\n                                         PI)*PI*2.0), sin(iteration*16.0*PI-(time*\n                                                                                      PI)*PI*2.0))*(iteration);\n        vec2 final = (cdiv(numerator, denominator));\n        quotient += final/(float(bends))*(GR*PI+sin(time+iteration));\n        \n        \n    }\n    for(int i = 0; i < bends; i++)\n    {\n       \tfloat iteration = float(i)/float(bends);\n        vec2 numerator = uv;\n        vec2 denominator =rotatePoint(vec3(cmul(uv, sin(vec2(time\n                                                             -2.0*PI*sin(-iteration+\n                                                                                 time/GR), \n                                                             time/GR-2.0*PI*sin(iteration+\n                                                                                         time)))), 0.0), vec3(0.0, 0.0, 1.0), \n                                      time*PI).xy\n            +vec2(cos(iteration*16.0*PI-sin(time*\n                                         PI)*PI*2.0), sin(iteration*16.0*PI-sin(time*\n                                                                                      PI)*PI*2.0));\n        vec2 final = (cdiv(numerator, denominator));\n        quotient += final/(float(bends))*(GR*PI+sin(time+iteration));\n        \n        \n    }\n        \n    \n    return quotient;\n}\n\n\nvec3 tex(vec2 uv) {\n\tvec2 t = vec2(sin(time), 0.0);\n\n\tuv = mobius(uv);\n\n\tfloat arm = float(SpiralArms);\n\tfloat den = SpiralDensity;\n\tfloat zoom = SpiralZoom;\n\tvec2 phase = vec2(-1.0, 1.0) * iTime * 0.125;\n\n\tfloat a1 = atan(uv.y, uv.x) / TWO_PI;\n\tfloat a2 = atan(uv.y, abs(uv.x)) / TWO_PI;\n\tfloat d = log(length(uv));\n\n\tvec2 uvL = vec2(a1 * arm + d * den, a1 - d * zoom) + phase;\n\tvec2 uvR = vec2(a2 * arm + d * den, a2 - d * zoom) + phase;\n\n\t// http://iquilezles.org/www/articles/tunnel/tunnel.htm\n\tvec3 col = textureGrad(iChannel0, uvL, dFdx(uvR), dFdy(uvR)).xyz;\n\n\tcol = pow(col, vec3(2.2));\n\treturn col;\n}\n\nfloat intensity(vec3 p) {\n\treturn p.x * 0.299 + p.y * 0.587 + p.z * 0.114;\n}\n\nfloat bump(vec2 p) {\n\treturn pow(intensity(tex(p)), BumpPower);\n}\n\nvec3 color(vec2 p) {\n\tp *= 0.5;\n\n\tvec3 pos = vec3(p, 0.0);\n\tvec3 rd = normalize(vec3(p, 1.0));\n\n\tvec3 lig = vec3(cos(iTime) * 0.5, sin(iTime) * 0.2, -1.0) * LightSize;\n\tvec3 nor = vec3(0.0, 0.0, -1.0);\n\n\tvec2 eps = vec2(0.0002, 0.0);\n\tvec2 grad = vec2(\n        \tbump(pos.xy - eps.xy) - bump(pos.xy + eps.xy),\n\t\t\tbump(pos.xy - eps.yx) - bump(pos.xy + eps.yx)) / (2.0 * eps.xx);\n    \n    if (InvertNormal) {\n        grad = -grad;\n    }\n\n\tfloat r = pow(length(p), 0.1);\n\n\tnor = normalize(nor + vec3((grad), 0.0) * BumpFactor * r);\n\tvec3 ld = normalize(lig - pos);\n\n\tfloat dif = max(dot(nor, ld), 0.0);\n\n\tvec3 ref = reflect(-ld, nor);\n\tfloat spe = pow(max(dot(ref, -rd), 0.0), 32.0);\n\n\tvec3 texCol = tex(pos.xy);\n\n\tvec3 brdf = vec3(0.0);\n\tbrdf += dif * vec3(1, 0.97, 0.92) * texCol * 0.7;\n\tbrdf += spe * vec3(1.0, 0.6, 0.2) * 2.0;\n\n\treturn clamp(brdf, 0.0, 1.0);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n\tvec2 aspect = vec2(iResolution.x / iResolution.y, 1.0);\n\tvec3 col = vec3(0.0);\n\n\tif (AntiAlias) {\n\t\tfloat sdi = SampleDistance;\n\t\tvec2 p0 = ((fragCoord.xy + vec2(0.0, 0.0)) / iResolution.xy * 2.0 - 1.0) * aspect;\n\t\tvec2 p1 = ((fragCoord.xy + vec2(sdi, 0.0)) / iResolution.xy * 2.0 - 1.0) * aspect;\n\t\tvec2 p2 = ((fragCoord.xy + vec2(sdi, sdi)) / iResolution.xy * 2.0 - 1.0) * aspect;\n\t\tvec2 p3 = ((fragCoord.xy + vec2(0.0, sdi)) / iResolution.xy * 2.0 - 1.0) * aspect;\n\n\t\tcol = (color(p0) + color(p1) + color(p2) + color(p3)) / 4.0;\n\t} else {\n\t\tcol = color((fragCoord.xy / iResolution.xy * 2.0 - 1.0) * aspect);\n\t}\n\tcol = pow(col, vec3(0.4545));\n    \n\tfragColor = vec4(col, 1.0);\n}", "image_inputs": [{"id": "XsXGRn", "previewfilepath": "/media/ap/cd4c518bc6ef165c39d4405b347b51ba40f8d7a065ab0e8d2e4f422cbc1e8a43.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/cd4c518bc6ef165c39d4405b347b51ba40f8d7a065ab0e8d2e4f422cbc1e8a43.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MtcSWs.jpg", "access": "shaders20k", "license": "unknown-license-reference", "functions": [[1824, 1824, 1851, 1851, 1892], [1894, 1894, 1913, 1913, 1952], [1954, 1954, 1981, 1981, 2009], [2011, 2011, 2033, 2081, 4216], [4219, 4219, 4238, 4238, 4827], [4829, 4829, 4854, 4854, 4905], [4907, 4907, 4927, 4927, 4972], [4974, 4974, 4994, 4994, 5834], [5836, 5836, 5891, 5891, 6573]], "test": "error"}
{"id": "MtcXRf", "name": "Cylinder - bounding box", "author": "iq", "description": "Analytical computation of the exact bounding box for an arbitrarily oriented disk. See [url]http://iquilezles.org/www/articles/diskbbox/diskbbox.htm[/url] for the derivation.", "tags": ["3d", "aabb", "cylinder", "bounding", "boundingbox"], "likes": 34, "viewed": 3519, "published": "Public API", "date": "1480916619", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// The MIT License\n// Copyright  2016 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n\n\n// See http://iquilezles.org/www/articles/diskbbox/diskbbox.htm\n//\n//\n// Analytical computation of the exact bounding box for an arbitrarily oriented disk. \n// It took me a good two hours to find the symmetries and term cancellations that \n// simplified the original monster equation into something pretty compact in its final form.\n//\n// For a disk of raius r centerd in the origin oriented in the direction n, has extent e:\n//\n// e = rsqrt(1-n)\n//\n// Derivation and more info in the link above\n\n\n// Disk             - 3D BBox : https://www.shadertoy.com/view/ll3Xzf\n// Cylinder         - 3D BBox : https://www.shadertoy.com/view/MtcXRf\n// Ellipse          - 3D BBox : https://www.shadertoy.com/view/Xtjczw\n// Cone boundong    - 3D BBox : https://www.shadertoy.com/view/WdjSRK\n// Cubic     Bezier - 2D BBox : https://www.shadertoy.com/view/XdVBWd \n// Quadratic Bezier - 3D BBox : https://www.shadertoy.com/view/ldj3Wh\n// Quadratic Bezier - 2D BBox : https://www.shadertoy.com/view/lsyfWc\n\n\n// Cylinder intersection: https://www.shadertoy.com/view/4lcSRn\n// Cylinder bounding box: https://www.shadertoy.com/view/MtcXRf\n// Cylinder distance:     https://www.shadertoy.com/view/wdXGDr\n\n\n#define AA 3\n\nstruct bound3\n{\n    vec3 mMin;\n    vec3 mMax;\n};\n    \n//---------------------------------------------------------------------------------------\n// bounding box for a cylinder (http://iquilezles.org/www/articles/diskbbox/diskbbox.htm)\n//---------------------------------------------------------------------------------------\nbound3 CylinderAABB( in vec3 pa, in vec3 pb, in float ra )\n{\n    vec3 a = pb - pa;\n    vec3 e = ra*sqrt( 1.0 - a*a/dot(a,a) );\n    \n    return bound3( min( pa - e, pb - e ),\n                   max( pa + e, pb + e ) );\n}\n\n// ray-cylinder intersetion (returns t and normal)\nvec4 iCylinder( in vec3 ro, in vec3 rd, \n                in vec3 pa, in vec3 pb, in float ra ) // point a, point b, radius\n{\n    // center the cylinder, normalize axis\n    vec3 cc = 0.5*(pa+pb);\n    float ch = length(pb-pa);\n    vec3 ca = (pb-pa)/ch;\n    ch *= 0.5;\n\n    vec3  oc = ro - cc;\n\n    float card = dot(ca,rd);\n    float caoc = dot(ca,oc);\n    \n    float a = 1.0 - card*card;\n    float b = dot( oc, rd) - caoc*card;\n    float c = dot( oc, oc) - caoc*caoc - ra*ra;\n    float h = b*b - a*c;\n    if( h<0.0 ) return vec4(-1.0);\n    h = sqrt(h);\n    float t1 = (-b-h)/a;\n    //float t2 = (-b+h)/a; // exit point\n\n    float y = caoc + t1*card;\n\n    // body\n    if( abs(y)<ch ) return vec4( t1, normalize( oc+t1*rd - ca*y ) );\n    \n    // caps\n    float sy = sign(y);\n    float tp = (sy*ch - caoc)/card;\n    if( abs(b+a*tp)<h )\n    {\n        return vec4( tp, ca*sy );\n    }\n\n    return vec4(-1.0);\n}\n\n\n// ray-box intersection\nvec2 iBox( in vec3 ro, in vec3 rd, in vec3 cen, in vec3 rad ) \n{\n    vec3 m = 1.0/rd;\n    vec3 n = m*(ro-cen);\n    vec3 k = abs(m)*rad;\n\t\n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n\n\tfloat tN = max( max( t1.x, t1.y ), t1.z );\n\tfloat tF = min( min( t2.x, t2.y ), t2.z );\n\t\n\tif( tN > tF || tF < 0.0) return vec2(-1.0);\n\n\treturn vec2( tN, tF );\n}\n\n\nfloat hash1( in vec2 p )\n{\n    return fract(sin(dot(p, vec2(12.9898, 78.233)))*43758.5453);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 tot = vec3(0.0);\n    \n#if AA>1\n    for( int m=0; m<AA; m++ )\n    for( int n=0; n<AA; n++ )\n    {\n        // pixel coordinates\n        vec2 o = vec2(float(m),float(n)) / float(AA) - 0.5;\n        vec2 p = (-iResolution.xy + 2.0*(fragCoord+o))/iResolution.y;\n#else    \n        vec2 p = (-iResolution.xy + 2.0*fragCoord)/iResolution.y;\n#endif\n\n        // camera position\n        vec3 ro = vec3( -0.5, 0.4, 1.5 );\n        vec3 ta = vec3( 0.0, 0.0, 0.0 );\n        // camera matrix\n        vec3 ww = normalize( ta - ro );\n        vec3 uu = normalize( cross(ww,vec3(0.0,1.0,0.0) ) );\n        vec3 vv = normalize( cross(uu,ww));\n        // create view ray\n        vec3 rd = normalize( p.x*uu + p.y*vv + 1.5*ww );\n\n        // cylidner animation\n        vec3  c_a =  0.2 + 0.3*sin(iTime*vec3(1.11,1.27,1.47)+vec3(2.0,5.0,6.0));\n        vec3  c_b = -0.2 + 0.3*sin(iTime*vec3(1.23,1.41,1.07)+vec3(0.0,1.0,3.0));\n        float c_r =  0.3 + 0.2*sin(iTime*1.3+0.5);\n\n\n        // render\n        vec3 col = vec3(0.4)*(1.0-0.3*length(p));\n\n        // raytrace\n        vec4 tnor = iCylinder( ro, rd, c_a, c_b, c_r );\n        float t = tnor.x;\n        float tmin = 1e10;\n        if( t>0.0 )\n        {\n            tmin = t;\n            // shading/lighting\t\n            vec3 pos = ro + t*rd;\n            vec3 nor = tnor.yzw;\n            float dif = clamp( dot(nor,vec3(0.5,0.7,0.2)), 0.0, 1.0 );\n            float amb = 0.5 + 0.5*dot(nor,vec3(0.0,1.0,0.0));\n            col = sqrt( vec3(0.2,0.3,0.4)*amb + vec3(0.8,0.7,0.5)*dif );\n            col *= vec3(1.0,0.75,0.3);\n        }\n\n\n        // compute bounding box of cylinder\n        bound3 bbox = CylinderAABB( c_a, c_b, c_r );\n\n        // raytrace bounding box\n        vec3 bcen = 0.5*(bbox.mMin+bbox.mMax);\n        vec3 brad = 0.5*(bbox.mMax-bbox.mMin);\n        vec2 tbox = iBox( ro, rd, bcen, brad );\n        if( tbox.x>0.0 )\n        {\n            // back face\n            if( tbox.y < tmin )\n            {\n                vec3 pos = ro + rd*tbox.y;\n                vec3 e = smoothstep( brad-0.03, brad-0.02, abs(pos-bcen) );\n                float al = 1.0 - (1.0-e.x*e.y)*(1.0-e.y*e.z)*(1.0-e.z*e.x);\n                col = mix( col, vec3(0.0), 0.25 + 0.75*al );\n            }\n            // front face\n            if( tbox.x < tmin )\n            {\n                vec3 pos = ro + rd*tbox.x;\n                vec3 e = smoothstep( brad-0.03, brad-0.02, abs(pos-bcen) );\n                float al = 1.0 - (1.0-e.x*e.y)*(1.0-e.y*e.z)*(1.0-e.z*e.x);\n                col = mix( col, vec3(0.0), 0.15 + 0.85*al );\n            }\n        }\n\n        // no gamma required here, it's done in line 118\n\n        tot += col;\n#if AA>1\n    }\n    tot /= float(AA*AA);\n#endif\n\n    // dithering\n    tot += ((hash1(fragCoord.xy)+hash1(fragCoord.yx+13.1))/2.0 - 0.5)/256.0;\n\n\n\tfragColor = vec4( tot, 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MtcXRf.jpg", "access": "shaders20k", "license": "mit", "functions": [[2337, 2607, 2667, 2667, 2826], [2828, 2879, 3003, 3046, 3781], [3784, 3808, 3872, 3872, 4152], [4155, 4155, 4181, 4181, 4248]], "test": "valid"}
{"id": "MtcXRs", "name": "glowing triangles", "author": "zproxy", "description": "from https://www.shadertoy.com/view/MldXzf", "tags": ["raymarching"], "likes": 0, "viewed": 100, "published": "Public", "date": "1481142378", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// \"Quake Logo\" by Krzysztof Narkowicz @knarkowicz\n\nconst float MATH_PI = float( 3.14159265359 );\n\nfloat VisibilityTerm( float roughness, float ndotv, float ndotl )\n{\n\tfloat m2\t= roughness * roughness;\n\tfloat visV\t= ndotl * sqrt( ndotv * ( ndotv - ndotv * m2 ) + m2 );\n\tfloat visL\t= ndotv * sqrt( ndotl * ( ndotl - ndotl * m2 ) + m2 );\n\treturn 0.5 / max( visV + visL, 0.00001 );\n}\n\nfloat DistributionTerm( float roughness, float ndoth )\n{\n\tfloat m2\t= roughness * roughness;\n\tfloat d\t\t= ( ndoth * m2 - ndoth ) * ndoth + 1.0;\n\treturn m2 / ( d * d * MATH_PI );\n}\n\nvec3 FresnelTerm( vec3 specularColor, float vdoth )\n{\n\tvec3 fresnel = clamp( 50.0 * specularColor.y, 0.0, 1.0 ) * specularColor + ( 1.0 - specularColor ) * pow( ( 1.0 - vdoth ), 5.0 );\n\treturn fresnel;\n}\n\nvec3 LightSpecular( vec3 normal, vec3 viewDir, vec3 lightDir, vec3 lightColor, float roughness, vec3 specularColor )\n{\n\tvec3 halfVec = normalize( viewDir + lightDir );\n\n\tfloat vdoth = clamp( dot( viewDir,\thalfVec\t ), 0.0, 1.0 );\n\tfloat ndoth\t= clamp( dot( normal,\thalfVec\t ), 0.0, 1.0 );\n\tfloat ndotv = clamp( dot( normal,\tviewDir  ), 0.0, 1.0 );\n\tfloat ndotl = clamp( dot( normal,\tlightDir ), 0.0, 1.0 );\n    \n   \tvec3\tf = FresnelTerm( specularColor, vdoth );\n\tfloat\td = DistributionTerm( roughness, ndoth );\n\tfloat\tv = VisibilityTerm( roughness, ndotv, ndotl );\n    \n    vec3 specular;\n\tspecular = lightColor * f * ( d * v * MATH_PI * ndotl );\n\treturn specular;\n}\n\nfloat Cylinder( vec3 p, float r, float height ) \n{\n\tfloat d = length( p.xz ) - r;\n\td = max( d, abs( p.y ) - height );\n\treturn d;\n}\n\nfloat Sphere( vec3 p, float s )\n{\n\treturn length( p ) - s;\n}\n\n \n\n\nfloat Box( vec3 p, vec3 b )\n{\n \n    \n    \n\tvec3 d = abs( p ) - b;\n\t\n    float filler = min( \n        \n        max( d.x, max( d.y, d.z ) )\n        \n        , 0.0 ) + length( max( d, 0.0 ) );\n    \n    \n    //if (p.y > 0.0)\n    //    return 200.0;\n    \n    return filler;\n   \n}\n\nfloat Substract( float a, float b )\n{\n    return max( a, -b );\n}\n\nfloat SubstractRound( float a, float b, float r ) \n{\n\tvec2 u = max( vec2( r + a, r - b ), vec2( 0.0, 0.0 ) );\n\treturn min( -r, max( a, -b ) ) + length( u );\n}\n\nfloat Union( float a, float b )\n{\n    return min( a, b );\n}\n\nfloat UnionRound( float a, float b, float k )\n{\n    float h = clamp( 0.5 + 0.5 * ( b - a ) / k, 0.0, 1.0 );\n    return mix( b, a, h ) - k * h * ( 1.0 - h );\n}\n\nfloat TriPrism( vec3 p, float rot )\n{        \n    vec3 q = abs( p );\n    \n     return max(\n        // creates some type of symmetry\n        q.y - 0.05, \n     \n        // vertical line\n        p.x * cos(rot) + p.z * sin(rot)   \n     );\n}\n\nvoid AddTriangle(\n    // spatial point\n    inout vec3 p, \n    inout float canvas,\n\tvec2 A,\t\n    vec2 B,\n\tvec2 C\n\t)\n{\n      \tvec2 a1 = A ;\n    \n    // looks like a steam engine\n        vec2 b1 = B;\n    \n        vec2 c1 = C;\n    \n    // A needs be to the right of B\n    \n    // need to check y too?\n    if (B.x > A.x)\n    {\n        a1 = B;\n        b1 = A;\n    }\n            \n    \n      \n        float slice2AC = TriPrism(  p + vec3(\n        \n        // up\n        c1.y,\n              // back\n              -0.0,\n              \n              // right\n              c1.x\n        ), \n                                \n                                // rot1 + MATH_PI + 0.8\n                               \n                                -atan(a1.y-c1.y, a1.x-c1.x) \n                               );\n    \n    \n    \n    // could we have atoolbar so we could move the dots?\n        float slice0BC = TriPrism(  p + vec3(\n        \n        // up\n        b1.y,\n              // back\n              -0.0,\n              \n              // right\n              b1.x\n        ),// rot1 + MATH_PI - 1.1\n                               \n                                -atan(b1.y-c1.y, b1.x-c1.x) + MATH_PI\n                               );\n    \n    \n    \n    // atan2(deltaY, deltaX)\n    float slice1BA = TriPrism(  p + vec3(\n        \n        // up\n        a1.y,\n              // back\n              -0.0,\n              \n              // right\n              a1.x \n        ), -atan(b1.y-a1.y, b1.x-a1.x));\n\n    \n    \n    \n        //float slice = min(slice2AC,min(slice1BA,slice0BC))                    ;\n\t\t//float slice = slice0BC;\n    //float slice = max(slice0BC, slice1BA);\n        float i = max(slice2AC,max(slice1BA,slice0BC))                    ;\n    \n    \n     \n    \n    \n    // need triangle markers?\n    //if (false)\n    // make A twice as big, while B moves\n     i = min(i,  Box(  p + vec3(a1.y,0.0,a1.x), vec3(\n                   \n                   // height\n                   0.2, \n                   \n                   //depth\n                   0.25, \n                   \n                   // width\n                   0.2)   )\n      );\n        \n    i = min(i,  Box(  p + vec3(b1.y,0.0,b1.x), vec3(\n                   \n                   // height\n                   0.1, \n                   \n                   //depth\n                   0.25, \n                   \n                   // width\n                   0.1)   )\n      );\n    \n        i = min(i,  Box(  p + vec3(c1.y,0.0,c1.x), vec3(\n                   \n                   // height\n                   0.1, \n                   \n                   //depth\n                   0.25, \n                   \n                   // width\n                   0.1)   )\n      );\n    \n    \n    // union\n    //canvas = min(canvas, i);\n    \n    canvas = min(i, canvas);\n}\n\nfloat Scene( vec3 p, mat3 localToWorld )\n{\n    // shadertoy should have time slider.\n    \n    p = p * localToWorld;\n    \n    \n    \n     \n    // can we move the objects?\n    \n    p += vec3(\n        \n        // up\n        0.0 ,\n              // back\n              -2.0,\n              \n              // right\n              0.0 );\n\n    vec2 a1 = vec2( 2.0,  0.6  + cos(iTime)) ;\n    // looks like a steam engine\n    vec2 b1 = vec2(1.75 + sin(iTime),  -1. + cos(iTime * 0.1));\n    vec2 c1 = vec2( 1.5, -1);\n\n    \n    // do we need some initial geometry?\n    float canvas1 = 10000.0;\n    AddTriangle(p, canvas1, a1, b1, c1);\n    \n    \n    \n      vec2 a2 = vec2( 0.5,  0.6  + cos(iTime)) ;\n    // looks like a steam engine\n    vec2 b2 = vec2(-1.25 + sin(iTime),  1);\n    vec2 c2 = vec2( -0.5, -1);\n\n    \n    // do we need some initial geometry?\n    //float canvas2 =  10000.0;\n    AddTriangle(p, canvas1, a2, b2, c2);\n    \n    return canvas1;\n    \n}\n\nvec2 CastRay( in vec3 ro, in vec3 rd, mat3 localToWorld )\n{\n    const float maxd = 15.0;\n    \n\tfloat h = 0.5;\n    float t = 0.0;\n    float steps = 0.0;\n   \n    for ( int i = 0; i < 150; ++i )\n    {\n        if ( h < 0.001 || t > maxd ) \n        {\n            break;\n        }\n        \n\t    h = Scene( ro + rd * t, localToWorld );\n        t += h;\n        steps += 0.03;\n    }\n\n    if ( t > maxd )\n    {\n        t = -1.0;\n    }\n\t\n    return vec2(t, steps);\n}\n\nvec3 SceneNormal( in vec3 pos, mat3 localToWorld )\n{\n\tvec3 eps = vec3( 0.001, 0.0, 0.0 );\n\tvec3 nor = vec3(\n\t    Scene( pos + eps.xyy, localToWorld ) - Scene( pos - eps.xyy, localToWorld ),\n\t    Scene( pos + eps.yxy, localToWorld ) - Scene( pos - eps.yxy, localToWorld ),\n\t    Scene( pos + eps.yyx, localToWorld ) - Scene( pos - eps.yyx, localToWorld ) );\n\treturn normalize( -nor );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 q = fragCoord.xy / iResolution.xy;\n    vec2 p = -1.0 + 2.0 * q;\n\tp.x *= iResolution.x / iResolution.y;\n\n    // have comera zoom in and out to reveal boundaries\n\tvec3 rayOrigin \t= vec3( 0.0, -0.0, -3.5 + 0.1 *sin( iTime * 2.0) );\n    vec3 rayDir \t= normalize( vec3( p.x, p.y, 2.0 ) );\n    \n    float theta = -0.5 * MATH_PI;\n    mat3 rotX = mat3(\n        vec3( cos( theta ), sin( theta ), 0.0 ),\n        vec3( -sin( theta ), cos( theta ), 0.0 ),\n\t\tvec3( 0.0, 0.0, 1.0 )\n        );    \n    \n    vec2 mo = iMouse.xy / iResolution.xy;    \n    \n    float phi = 0.25 * MATH_PI + 10.0 * mo.x;    \n    //float phi = 0.25 * MATH_PI; \n    \n    // look straight at it. no mouse\n    //float phi = 0.5 * MATH_PI;    \n\n    mat3 rotY = mat3(\n        vec3( 1.0, 0.0, 0.0 ),\n        vec3( 0.0, cos( phi ), sin( phi ) ),\n        vec3( 0.0, -sin( phi ), cos( phi ) )\n        );\n    \n    //mat3 localToWorld = rotX * rotY;    \n    mat3 localToWorld = rotX * rotY;    \n\n\n\tvec3 color = texture( iChannel0, q ).yyy * 0.3;\n    \n\tvec2 result = CastRay( rayOrigin, rayDir, localToWorld );\n    \n    if ( result.x > 0.0 )\n    {\n      color = vec3(result.y*2.0, result.y*0.3, result.y*0.2);\n    }\n    else\n    {\n      color = vec3(0.0, result.y*abs(sin(iTime*1.8)),0.0);\n    }\n    \n    fragColor = vec4( color, 1.0 );\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MtcXRs.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[99, 99, 166, 166, 380], [382, 382, 438, 438, 559], [561, 561, 614, 614, 764], [766, 766, 884, 884, 1431], [1433, 1433, 1483, 1483, 1563], [1565, 1565, 1598, 1598, 1625], [1631, 1631, 1660, 1660, 1905], [1907, 1907, 1944, 1944, 1971], [1973, 1973, 2025, 2025, 2131], [2133, 2133, 2166, 2166, 2192], [2194, 2194, 2241, 2241, 2352], [2354, 2354, 2391, 2391, 2590], [2592, 2592, 2708, 2708, 5400], [5402, 5402, 5444, 5486, 6344], [6346, 6346, 6405, 6405, 6801], [6803, 6803, 6855, 6855, 7187], [7189, 7189, 7246, 7246, 8542]], "test": "error"}
{"id": "MtdSRX", "name": "ich bin der koch", "author": "bergi", "description": "\"modulo in cartesian and polar coordinates\" created this beautiful belly", "tags": ["fractal", "recursive", "modulo", "snowflake", "symmetry"], "likes": 26, "viewed": 1369, "published": "Public API", "date": "1481017102", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/** Modulo in space (cc) 2016, stefan berke\n\n    The structure is a single tube folded in space.\n\n\trepeat_transform() applies the modulo function to cartesian coordinates\n\tfan_transform_XX() applies the modulo to polar coordinates\n\n\tThe glsl for the distance field is generated by a python program using this script:\n\n    o = Tube(radius=0.1, axis=1)\n    o = Fan(o, axis=2, angle=(0, 30))\n    o = Repeat(o, repeat=(2,2,0))\n    o = Fan(o, axis=2, angle=(0,60))\n    o = Repeat(o, repeat=(5,5,0))\n    o = Fan(o, axis=2, angle=(0, 90))\n    o = Fan(o.set_transform(mat4().translate((0,0,6))), axis=1, angle=(0,60))\n    o = Fan(o, axis=2, angle=(0, 60))\n    o = Repeat(o, repeat=vec3(36,36,0))\n\n\tresulting in this branch-less tree:\n\n    Repeat(repeat=vec3(36, 36, 0))\n    \\-Fan(angle=(0, 60), axis=2)\n      \\-Fan(angle=(0, 60), axis=1)\n        \\-Fan(angle=(0, 90), axis=2, transform=mat4(1,0,0,0, 0,1,0,0, 0,0,1,0, 0,0,6,1))\n          \\-Repeat(repeat=vec3(5, 5, 0))\n            \\-Fan(angle=(0, 60), axis=2)\n              \\-Repeat(repeat=vec3(2, 2, 0))\n                \\-Fan(angle=(0.0, 30.0), axis=2)\n                  \\-Tube(radius=0.1, axis=1)\n\n\n\tsource is here: https://github.com/defgsus/pector/tree/dev-csg/csg\n\n\n\tbe fun :)\n*/\n\n\nvec3 fan_transform_xy(in vec3 pos, in float center, in float range) {\n    center *= 0.017453292519943295;\n    range *= 0.017453292519943295;\n    float start = (center - range/2.),\n          ang = atan(pos.x, pos.y),\n          len = length(pos.xy);\n    ang = mod(ang-start, range) - range/2. + center;\n    pos.xy = len * vec2(sin(ang), cos(ang));\n    return pos;\n}\n\nvec3 fan_transform_xz(in vec3 pos, in float center, in float range) {\n    center *= 0.017453292519943295;\n    range *= 0.017453292519943295;\n    float start = (center - range/2.),\n          ang = atan(pos.x, pos.z),\n          len = length(pos.xz);\n    ang = mod(ang-start, range) - range/2. + center;\n    pos.xz = len * vec2(sin(ang), cos(ang));\n    return pos;\n}\n\nvec3 repeat_transform(in vec3 pos, in vec3 repeat) {\n    if (repeat.x > 0.) pos.x = mod(pos.x + repeat.x/2., repeat.x) - repeat.x/2.;\n    if (repeat.y > 0.) pos.y = mod(pos.y + repeat.y/2., repeat.y) - repeat.y/2.;\n    if (repeat.z > 0.) pos.z = mod(pos.z + repeat.z/2., repeat.z) - repeat.z/2.;\n    return pos;\n}\n\n\nfloat DE(in vec3 pos) {\n    return length(fan_transform_xy(\n        \t\t\trepeat_transform(\n                        fan_transform_xy(\n                            repeat_transform(\n                                fan_transform_xy(\n                                    (fan_transform_xz(\n                                        fan_transform_xy(\n                                            repeat_transform(pos, vec3(36.0, 36.0, 0.0))\n                                         , 0.0, 60.0)\n                                     , 0.0, 60.0) + vec3(0.0, 0.0, -6.0))\n                                 , 0.0, 90.0), vec3(5.0, 5.0, 0.0))\n                            , 0.0, 60.0), vec3(2.0, 2.0, 0.0))\n        \t\t\t\t, 0.0, 30.0).xz) - 0.1;\n}\n\n\nvec3 DE_norm(in vec3 p)\n{\n    vec2 e = vec2(0.001, 0.);\n    return normalize(vec3(\n        DE(p + e.xyy) - DE(p - e.xyy),\n        DE(p + e.yxy) - DE(p - e.yxy),\n        DE(p + e.yyx) - DE(p - e.yyx) ));\n}\n\nfloat sphere_trace(in vec3 ro, in vec3 rd)\n{\n    float t = 0.;\n    for (int i=0; i<70; ++i)\n    {\n        float d = DE(ro + rd * t);\n        if (d < 0.001)\n            return t;\n        t += d;\n        if (t > 100.)\n            break;\n    }\n    return -1.;\n}\n\nvec3 sky_c(in vec3 rd)\n{\n    return mix(vec3(0.0,.1,.0)*.3,\n               vec3(0.0,.5,.8)*.2, rd.y*.5+.5);\n}\n\nvec3 light(in vec3 p, in vec3 n, in vec3 refl, in vec3 lp, in vec3 co)\n{\n    vec3 ln = normalize(lp - p);\n    float ph = max(0., dot(n, ln));\n    float sh = max(0., dot(refl, ln));\n    return co * pow(ph, 5.)\n         + co * pow(sh, 9.) * .5;\n}\n\nmat4 camera = mat4(1);\n\nvoid get_ray(in vec2 uv, out vec3 ro, out vec3 rd)\n{\n    ro = vec3(0,0,0);\n    rd = normalize(vec3(uv, -1.2+.3*length(uv)));\n\n    ro = (camera * vec4(ro, 1.)).xyz;\n    rd = (camera * vec4(rd, 0.)).xyz;\n}\n\nvec3 render(in vec2 uv)\n{\n    vec3 ro, rd, col=vec3(0);\n    get_ray(uv, ro, rd);\n    float t = sphere_trace(ro, rd);\n    if (t < 0.)\n        return sqrt(sky_c(rd));\n\n    vec3 po = ro+t*rd;\n    vec3 n = DE_norm(po);\n    vec3 refl = reflect(rd, n);\n\n    float amp = 4.*max(0., sin(iTime*3.+po.x/3.+po.z));\n    col += sky_c(refl)*.3;\n    col += (sky_c(rd)*amp) * pow(max(0., dot(rd, refl)), 1.);\n    col += light(po, n, refl, camera[3].xyz+vec3(10,10,-3), vec3(.3,.7,1.));\n    col += light(po, n, refl, (camera[3] * vec4(-2,-4,10,1.)).xyz, vec3(1,.8,.5));\n\t\n    col = mix(col, sky_c(rd), min(1., t/60.));\n    return sqrt(col);\n}\n\n// some nifty helper to uniformly set the rotation of a mat2, mat3 or mat4 \nvoid set_rot(in float deg, inout vec2 a, inout vec2 b, in vec4 sig)\n{\n    deg = deg / 180. * 3.14159265; vec2 sc = vec2(sin(deg), cos(deg));\n    a = sc.yx * sig.xy;\n    b = sc.xy * sig.zw;\n}\nmat4 rotate_x(in mat4 m, in float deg) { mat4 r = mat4(1); set_rot(deg, r[1].yz, r[2].yz, vec4(1,1,-1,1)); return m*r; }\nmat4 rotate_y(in mat4 m, in float deg) { mat4 r = mat4(1); set_rot(deg, r[0].xz, r[2].xz, vec4(1,-1,1,1)); return m*r; }\nmat4 rotate_z(in mat4 m, in float deg) { mat4 r = mat4(1); set_rot(deg, r[0].xy, r[1].xy, vec4(1,1,-1,1)); return m*r; }\n\nvoid mainImage(out vec4 fragc, in vec2 fc)\n{\n    float t = iTime;\n\tcamera = rotate_x(camera, 90.+20.*sin(t/3.)); \n\tcamera = rotate_y(camera, -90.+20.*sin(t/4.)); \n    camera = rotate_z(camera, sin(t/7.)*90.); \n\tcamera = rotate_x(camera, 20.*sin(t/1.1)); \n    camera[3].xyz = vec3(t*3., sin(t*3.141593/12.-.1)*6., sin(t/3.-1.))+0.001;\n\t\n    // un-comment to see structure from outside\n    //camera[3].z += 15.; camera = rotate_x(camera, -50.); \n    \n    vec2 uv = (fc - iResolution.xy*.5) / iResolution.y * 2.;\n    \n    vec3 col = vec3(0.);\n\n    col = render(uv);\n\n    fragc = vec4(col,1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MtdSRX.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1228, 1228, 1297, 1297, 1591], [1593, 1593, 1662, 1662, 1956], [1958, 1958, 2010, 2010, 2271], [2274, 2274, 2297, 2297, 2999], [3002, 3002, 3027, 3027, 3206], [3208, 3208, 3252, 3252, 3466], [3468, 3468, 3492, 3492, 3577], [3579, 3579, 3651, 3651, 3823], [3849, 3849, 3901, 3901, 4052], [4054, 4054, 4079, 4079, 4679], [4681, 4757, 4826, 4826, 4947], [4948, 4948, 4988, 4988, 5068], [5069, 5069, 5109, 5109, 5189], [5190, 5190, 5230, 5230, 5310], [5312, 5312, 5356, 5356, 5902]], "test": "error"}
{"id": "MtdXzf", "name": "Line Field", "author": "bytewave", "description": "some lines", "tags": ["line", "rotation"], "likes": 20, "viewed": 321, "published": "Public", "date": "1481005840", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n\nfloat circle(vec2 pos, float radius)\n{\n    return clamp(((1.0-abs(length(pos)-radius))-0.99)*100.0, 0.0, 1.0);\n    \n}\n\nfloat line( in vec2 p, in vec2 a, in vec2 b )\n{\n    vec2 pa = -p - a;\n    vec2 ba = -b - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    float d = length( pa - ba*h );\n    \n    return clamp(((1.0 - d)-0.99)*25.0, 0.0, 1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    uv -= 0.5;\n    uv *= 2.;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    \n    float c = circle(uv,1.);\n    float Tau = 6.2831853071;\n    float unit = Tau / iTime;\n    float r = 0.;\n    float g = 0.;\n    float b = 0.;\n    float t =999.+ iTime *0.5;\n    vec3 col = vec3(0.);\n    for(int i = 0;i < 256;i++)\n    {\n        float Fi = float(i)*1.;\n        \n        float v1 = Tau ;\n        float v2= (t *11.11 );\n        float OffLight = .025;\n        \n        float p = mod( Fi ,v1) * (t+140.) *0.012;\n        float p2 =mod( Fi ,v2) * (t+140.) *0.012;\n        \n        float FiStart = float(p);\n        float FiNext = float(p2);\n        \n        \n        vec2 start = vec2(sin( FiStart ),cos(FiStart));\n        vec2 end = vec2(sin( FiNext ),cos(FiNext  ));\n        \n    \tr += line(uv,start ,end) ;    \n        \n        p = mod( Fi ,v1 ) * (t+140.+ OffLight) *0.012;\n        p2 =mod( Fi ,v2 ) * (t+140.+ OffLight) *0.012;\n        \n        FiStart = float(p);\n        FiNext = float(p2);\n        \n        \n        start = vec2(sin( FiStart ),cos(FiStart));\n        end = vec2(sin( FiNext ),cos(FiNext  ));\n        \n    \tg += line(uv,start ,end) ;    \n        \n        \n        p = mod( Fi ,v1  ) * (t+140.+ OffLight+ OffLight) *0.012;\n        p2 =mod( Fi ,v2 ) * (t+140.+ OffLight+ OffLight) *0.012;\n        \n        FiStart = float(p);\n        FiNext = float(p2);\n        \n        \n        start = vec2(sin( FiStart ),cos(FiStart));\n        end = vec2(sin( FiNext ),cos(FiNext  ));\n        \n    \tb += line(uv,start ,end) ;   \n        \n    }\n    \n    \n\n    fragColor = vec4(r,g,b, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MtdXzf.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[2, 2, 40, 40, 119], [121, 121, 168, 168, 361], [363, 363, 420, 420, 2052]], "test": "valid"}
{"id": "MtGSzh", "name": "MightyMorphingPowerSphere", "author": "Lallis", "description": " A few weeks ago I was playing around with some noise raymarching and this is what I ended up with.", "tags": ["procedural", "3d", "raymarching", "noise"], "likes": 30, "viewed": 1256, "published": "Public API", "date": "1482763890", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define time iTime\nmat3 rot(vec3 ang)\n{\n\tmat3 x = mat3(1.0,0.0,0.0,0.0,cos(ang.x),-sin(ang.x),0.0,sin(ang.x),cos(ang.x));\n\tmat3 y = mat3(cos(ang.y),0.0,sin(ang.y),0.0,1.0,0.0,-sin(ang.y),0.0,cos(ang.y));\n\tmat3 z = mat3(cos(ang.z),-sin(ang.z),0.0,sin(ang.z),cos(ang.z),0.0,0.0,0.0,1.0);\n\treturn z*y*x;\n}\n\nfloat noise3D(vec3 p)\n{\n\treturn fract(sin(dot(p ,vec3(12.9898,78.233,12.7378))) * 43758.5453);\n}\n\nfloat smooth3D(vec3 p)\n{\n    vec3 f = fract(p);\n    p = floor(p);\n    f = f*f*(3.0-2.0*f);\n    \n\tfloat p0 = noise3D(p);\n\tfloat x = noise3D(p+vec3(1.0,0.0,0.0));\n\tfloat y = noise3D(p+vec3(0.0,1.0,0.0));\n\tfloat z = noise3D(p+vec3(0.0,0.0,1.0));\n\tfloat xy = noise3D(p+vec3(1.0,1.0,0.0));\n\tfloat xz = noise3D(p+vec3(1.0,0.0,1.0));\n\tfloat yz = noise3D(p+vec3(0.0,1.0,1.0));\n\tfloat xyz = noise3D(p+1.0);\n\t\n    return mix(\tmix(\tmix(p0, x, \t f.x), \n                    \tmix(y, \txy,  f.x), \tf.y), \n               \tmix(\tmix(z, \txz,\t f.x), \n                    \tmix(yz, xyz, f.x), \tf.y), \tf.z);\n}\n\nfloat fbm(vec3 p)\n{\n \tfloat f = 0.5000*smooth3D(p*1.00);\n    \t  f+= 0.2500*smooth3D(p*2.01);\n    \t  f+= 0.1250*smooth3D(p*4.02);\n    \t  f+= 0.0625*smooth3D(p*8.03);\n    \t  f/= 0.9375;\n    return f;\n}\nfloat sphere( vec3 rp, vec3 c, float r )\n{\n    return distance(rp, c) - r;\n}\n\nfloat map(vec3 rp)\n{\n    rp *= rot(vec3(time*0.25));\n    float d = sphere( rp, vec3(0.0), 1.0+(fbm(rp*8.0+time)*2.0-1.0)*1.0);\n    return d;\n}\n\nvec3 normal(vec3 rp)\n{\n    vec3 eps = vec3( 0.002 ,0.0,0.0);\n\treturn normalize( vec3(\n           map(rp+eps.xyy) - map(rp-eps.xyy),\n           map(rp+eps.yxy) - map(rp-eps.yxy),   //from iq\n           map(rp+eps.yyx) - map(rp-eps.yyx) ) );\n\n}\n\nfloat softShadow(vec3 rp, vec3 ld)\n{\n \tvec3 ro = rp;\n    float ldmax = 20.0;\n    float td = 0.05;\n    float res = 1.0;\n    float d;\n    for(int i = 0; i < 256; i++)\n    {\n     \trp = ro + ld * td;\n        d = map( rp );\n        if( d < 0.001 || td >= ldmax )\n        {\n         \tbreak;   \n        }\n        res = min(res,8.0*d);\n        td += d*0.1;\n    }\n    if( d < 0.001 )\n    {\n     \tres = 0.0;   \n    }\n   \n    return res;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 p = 2.0*uv-1.0;\n    p.x*=iResolution.x/iResolution.y;\n    vec3 col = vec3(0.0);\n    \n    vec2 m = (iMouse.xy/iResolution.xy)*2.0-1.0;\n    \n    \n    vec3 cp = vec3(0.0,0.0,-2.0);\n    vec3 rd = normalize( vec3(p,0.0) - cp );\n    vec3 ro = cp-vec3(0.0,0.0,2.0);\n    vec3 rp;\n    \n    vec3 ang = vec3(-3.14*m.y,3.14*m.x,0.0);\n    //rd*= rot(ang);\n    //ro*= rot(ang);\n    \n    float td = 0.1;\n    float dmax = 8.0;\n    float d;\n    float mind = 1000.0;\n    \n    for( int i = 0; i < 512; i++ )\n    {\n        rp = ro+rd*td;\n        d = map(rp);\n        mind = min(mind,d);\n        if( d < 0.001 )\n            break;\n        td += d*0.1;\n        if( td > dmax ) \n        {\n            td = dmax;\n            break;\n        }\n    }\n    vec3 keepo = texture(iChannel0, uv*(0.001+0.01*abs(sin(time*0.1)))+time*0.001).rgb;\n    if( d < 0.001 )\n    {\n        vec3 n = normal(rp);\n        vec3 l = normalize(vec3(0.0,0.1,-1.0));//*rot(vec3(0.0,0.0,time));\n        float sha = softShadow( rp, l );\n        col = mix(vec3(0.05),keepo,clamp(0.0,1.0,smoothstep(1.0,0.0,2.0-length(rp))));\n        //PHONG\n        /*\t\t\t\n        vec3 v = normalize(ro-rp);\n        vec3 h = normalize(l+v);\n        \n        float a = 128.0;   \n        float kd = 0.33;\n        float ks = 0.33;\n        float ss = 0.33;\n        \n        col*=max(0.0,dot(n,l))*kd+max(0.0,pow(dot(n,h),a))*ks+sha*ss;\n        */\n        col*=max(0.0,dot(n,l))*sha;\n        \n    }\n    else\n    {\n         col += (keepo*pow(dot(rd,vec3(0.0,0.0,1.0)),24.0))*exp(-mind+1.0+sin(time));   \n    }\n    col = mix(col,keepo*(max(0.0,1.0-mind*8.0)),min(1.0,length(rp)*0.025));   \n    \n    col = clamp(col, 0.0, 1.0);\n    col = pow(col, vec3(0.45));\n    \n    float f = 8.0;\n    col = (1.0/(1.0+exp(4.0-f*col))-0.0003)/(0.982-0.018);\n    \n    //col = 1.0-col;\n    \n    p.x/=iResolution.x/iResolution.y;\n    col *= smoothstep( 1.325, 0.825, abs(p.x) );\n    col *= smoothstep( 1.325, 0.825, abs(p.y) );\n    \n    float dither = (noise3D(vec3(p,time))*2.0-1.0)*2.0/256.0;\n    col += dither;\n\tfragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": "Xsf3zn", "previewfilepath": "/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MtGSzh.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[19, 19, 39, 39, 302], [304, 304, 327, 327, 400], [402, 402, 426, 426, 987], [989, 989, 1008, 1008, 1188], [1189, 1189, 1231, 1231, 1265], [1267, 1267, 1287, 1287, 1409], [1411, 1411, 1433, 1433, 1653], [1655, 1655, 1691, 1691, 2083], [2084, 2084, 2141, 2141, 4237]], "test": "error"}
{"id": "MtKSRz", "name": "Wavy Eye", "author": "ptrgags", "description": "It's watching you...", "tags": ["2d", "waves", "eye", "rgb"], "likes": 3, "viewed": 88, "published": "Public", "date": "1482602699", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define center (iResolution.xy / 2.0)\n#define PI 4.0 * atan(1.0)\n\nvec2 rect_to_polar(vec2 rect) {\n    float r = length(rect);\n    float theta = atan(rect.y, rect.x);\n    if (theta < 0.0)\n        theta += 2.0 * PI;\n    return vec2(r, theta);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = (fragCoord.xy - center) / iResolution.y;\n    \n    //switch to polar coordinates\n    vec2 polar = rect_to_polar(uv);\n    \n    for (int i = 0; i < 3; i++) {\n        float index = float(i) + 1.0;\n        \n   \t\t//Make some waves\n    \tfloat wave = 0.05 * sin(20.0 * polar.y + index * 2.0 * iTime);\n   \t\tfloat wave_height = 1.0 - abs(polar.x + wave - 0.15 * index);\n    \tfragColor[i] = smoothstep(0.98, 0.99, wave_height);\n    }\n    fragColor.a = 1.0;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MtKSRz.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[66, 66, 97, 97, 242], [244, 244, 301, 301, 760]], "test": "valid"}
{"id": "MtKXRh", "name": "Kleinian limit set-Maskit slice ", "author": "JosLeys", "description": "2D limit set", "tags": ["fractal", "kleinian"], "likes": 34, "viewed": 33786, "published": "Public API", "date": "1482962711", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//by Jos Leys\nvec3  background1Color=vec3(1.0,1.0,1.0);\nvec3  color3=vec3(0.2,0.0,0.6);\n\nfloat box_size_x=1.;\n\nfloat wrap(float x, float a, float s){\n\tx -= s; \n\treturn (x-a*floor(x/a)) + s;\n}\n\nvoid TransA(inout vec2 z, float a, float b){\n\tfloat iR = 1. / dot(z,z);\n\tz *= -iR;\n\tz.x = -b - z.x; z.y = a + z.y; \n\t\n}\n\nfloat  JosKleinian(vec2 z)\n{\n\tvec2 lz=z+vec2(1.), llz=z+vec2(-1.);\n    float flag=0.;\n float KleinR = 1.8462756+(1.958591-1.8462756)*0.5+0.5*(1.958591-1.8462756)*sin(-iTime*0.2);  \n float KleinI = 0.09627581+(0.0112786-0.09627581)*0.5+0.5*(0.0112786-0.09627581)*sin(-iTime*0.2);\n      \n\tfloat a = KleinR;\n    float b = KleinI;\n\tfloat f = sign(b)*1. ;     \n\tfor (int i = 0; i < 150 ; i++) \n\t{\n                z.x=z.x+f*b/a*z.y;\n\t\tz.x = wrap(z.x, 2. * box_size_x, - box_size_x);\n\t\tz.x=z.x-f*b/a*z.y;\n                       \n\t\t//If above the separation line, rotate by 180 about (-b/2, a/2)\n        if  (z.y >= a * 0.5 + f *(2.*a-1.95)/4. * sign(z.x + b * 0.5)* (1. - exp(-(7.2-(1.95-a)*15.)* abs(z.x + b * 0.5))))\t\n        {z = vec2(-b, a) - z;}\n        \n\t\t//Apply transformation a\n\t\tTransA(z, a, b);\n\t\t\n        //\n\t\t//If the iterated points enters a 2-cycle , bail out.\n        if(dot(z-llz,z-llz) < 1e-6) {break;}\n        //if the iterated point gets outside z.y=0 and z.y=a\n        if(z.y<0. || z.y>a){flag=1.; break;}\n        //Store prvious iterates\n\t\tllz=lz; lz=z;\n\t}\n\n\treturn flag;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n   \tvec2 uv = fragCoord.xy / iResolution.xy;\n     uv = (1.99)*uv-vec2(0.42,.0);\n   \n    uv.x *= iResolution.x/iResolution.y;\n    float hit=JosKleinian(uv);\n      vec3 c =(1.-hit)*background1Color+hit*color3;\n   \n\tfragColor = vec4(c, 1.0);\n    \n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MtKXRh.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[111, 111, 149, 149, 191], [193, 193, 237, 237, 312], [314, 314, 342, 342, 1406], [1409, 1409, 1466, 1466, 1717]], "test": "valid"}
{"id": "MttXRl", "name": "Math_Flags", "author": "PlauM", "description": "Test math flag", "tags": ["math", "flag"], "likes": 0, "viewed": 321, "published": "Public API", "date": "1481281126", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 color, in vec2 pixCoords )\n{\n    /*// DRAPEAU FRANCE\n    float tier = float(iResolution.x)/3.0;\n    \n    if (pixCoords.x < tier)\n    {\n        color = vec4(0.0, 0.0, 1.0, 1.0);\n    }\n    else if (pixCoords.x < tier*2.0)\n    {\n        color = vec4(1.0, 1.0, 1.0, 1.0);\n    }\n    else\n    {\n        color = vec4(1.0, 0.0, 0.0, 1.0);\n    }*/\n    \n    \n    /*// DRAPEAU JAPON\n    float centerX = float(iResolution.x)/2.0;\n    float centerY = float(iResolution.y)/2.0;\n    float rayon = 120.0;\n    float distance = sqrt(pow(pixCoords.x-centerX,2.0)+pow(pixCoords.y-centerY,2.0));\n    \n    color = vec4(1.0, 1.0, 1.0, 1.0);\n    if (distance < rayon)\n    {\n        color = vec4(1.0, 0.0, 0.0, 1.0);\n    }*/\n    \n    \n    /*// DRAPEAU JAPON QUI BOUGE\n    \n    float centerX = float(iResolution.x)/4.0;\n    float centerY = float(iResolution.y)/4.0;\n    \n    float amplitude = 20.0;\n    float frequence = 5.0;\n    float sinusoide = sin(iTime*frequence)*amplitude; // de base sinusoide varie entre -1 et 1\n    float rayon = 100.0 + sinusoide;\n    \n    float distancePix = sqrt(pow(pixCoords.x-centerX,2.0) + pow(pixCoords.y-centerY,2.0));\n    \n    color = vec4(1.0, 1.0, 1.0, 1.0);\n    if (distancePix < rayon)\n    {\n        color = vec4(1.0, 0.0, 0.0, 1.0);\n    }*/\n    \n    \n    // DRAPEAU JAPON QUI BOUGE ET QUI TOURNE\n    vec2 coords = pixCoords/iResolution.xy; // permet d'avoir un repre de notre choix (ici entre 0 et 1)\n    // mais ici perte du ratio, et donc choisir que x ou que y\n    \n    float centerRotatX = float(iResolution.x)/2.0;\n    float centerRotatY = float(iResolution.y)/2.0;\n    float rayonRotat = 200.0;\n    \n    float centerX = centerRotatX + rayonRotat*cos(iTime);\n    float centerY = centerRotatY + rayonRotat*sin(iTime);\n    \n    float amplitude = 20.0;\n    float frequence = 5.0;\n    float sinusoide = sin(iTime*frequence)*amplitude; // de base sinusoide varie entre -1 et 1\n    float rayon = 100.0 + sinusoide;\n    \n    float distanceCenterPix = sqrt(pow(pixCoords.x-centerX,2.0) + pow(pixCoords.y-centerY,2.0));\n    //float distanceCenterPix = length(pixCoords-center); //pour center : point (xy)\n    \n    color = vec4(1.0, 1.0, 1.0, 1.0);\n    if (distanceCenterPix < rayon)\n    {\n        color = vec4(1.0, 0.0, 0.0, 1.0);\n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MttXRl.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 53, 1335, 2276]], "test": "valid"}
{"id": "MttXWl", "name": "CRT from mario World by SI15", "author": "gcstudio", "description": "CRT Effect from mario World by SI15", "tags": ["crteffect"], "likes": 8, "viewed": 445, "published": "Public", "date": "1482244237", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// CRT Effect Pulled from : \"[SIG15] Mario World 1-1\" by Krzysztof Narkowicz @knarkowicz\n// \n// \n#define SPRITE_DEC( x, i ) \tmod( floor( i / pow( 4.0, mod( x, 8.0 ) ) ), 4.0 )\n#define SPRITE_DEC2( x, i ) mod( floor( i / pow( 4.0, mod( x, 11.0 ) ) ), 4.0 )\n#define RGB( r, g, b ) vec3( float( r ) / 255.0, float( g ) / 255.0, float( b ) / 255.0 )\n\nvec2 CRTCurveUV( vec2 uv )\n{\n    uv = uv * 2.0 - 1.0;\n    vec2 offset = abs( uv.yx ) / vec2( 6.0, 4.0 );\n    uv = uv + uv * offset * offset;\n    uv = uv * 0.5 + 0.5;\n    return uv;\n}\n\nvoid DrawVignette( inout vec3 color, vec2 uv )\n{    \n    float vignette = uv.x * uv.y * ( 1.0 - uv.x ) * ( 1.0 - uv.y );\n    vignette = clamp( pow( 16.0 * vignette, 0.3 ), 0.0, 1.0 );\n    color *= vignette;\n}\n\nvoid DrawScanline( inout vec3 color, vec2 uv )\n{\n    float scanline \t= clamp( 0.95 + 0.05 * cos( 3.14 * ( uv.y + 0.008 * iTime ) * 240.0 * 1.0 ), 0.0, 1.0 );\n    float grille \t= 0.85 + 0.15 * clamp( 1.5 * cos( 3.14 * uv.x * 640.0 * 1.0 ), 0.0, 1.0 );    \n    color *= scanline * grille * 1.2;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // we want to see at least 224x192 (overscan) and we want multiples of pixel size\n    float resMultX  = floor( iResolution.x / 224.0 );\n    float resMultY  = floor( iResolution.y / 192.0 );\n    float resRcp\t= 1.0 / max( min( resMultX, resMultY ), 1.0 );\n    \n    float time\t\t\t= iTime;\n    float screenWidth\t= floor( iResolution.x * resRcp );\n    float screenHeight\t= floor( iResolution.y * resRcp );\n    float pixelX \t\t= floor( fragCoord.x * resRcp );\n    float pixelY \t\t= floor( fragCoord.y * resRcp );\n\n    vec3 color = RGB( 92, 148, 252 );\n \t \n     \n\n    \n    // CRT effects (curvature, vignette, scanlines and CRT grille)\n    vec2 uv    = fragCoord.xy / iResolution.xy;\n    vec2 crtUV = CRTCurveUV( uv );\n    if ( crtUV.x < 0.0 || crtUV.x > 1.0 || crtUV.y < 0.0 || crtUV.y > 1.0 )\n    {\n        color = vec3( 0.0, 0.0, 0.0 );\n    }\n    DrawVignette( color, crtUV );\n    DrawScanline( color, uv );\n    \n\tfragColor.xyz \t= color;\n    fragColor.w\t\t= 1.0;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MttXWl.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[347, 347, 375, 375, 529], [531, 531, 579, 579, 739], [741, 741, 789, 789, 1035], [1037, 1037, 1094, 1180, 2055]], "test": "valid"}
{"id": "MttXz2", "name": "Plasma Color", "author": "TrueBoolean", "description": "Plasma effect using sine patterns.", "tags": ["plasma"], "likes": 0, "viewed": 90, "published": "Public", "date": "1480714658", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 OUT, vec2 uv )\n{\n    const float PI = atan(0.,-1.);\n\tuv=(uv/iResolution.y)*PI;\n    float x=uv.x, y=uv.y;\n    float func=sin(x * 2.)+sin( y * 8. )+sin((x+y)*8.) + sin(length( uv )* 20.);\n    vec3 pal= vec3( 2. , 4. , 8.);\n    pal = .5+ sin( PI * (func+iTime) / pal );\n\tOUT = vec4( pal, 1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MttXz2.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 41, 41, 316]], "test": "valid"}
{"id": "MttXzj", "name": "2D Fractal : 1 / z^3", "author": "aiekick", "description": "hwo i can smooth iterations ? i have applied the smooth itertation tech, but maybe im wrong, because i not see the smooth here..:)", "tags": ["2dfractal"], "likes": 0, "viewed": 358, "published": "Public API", "date": "1480681264", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// z * z\nvec2 zmul(vec2 a, vec2 b)\n{\n\treturn vec2(a.x*b.x-a.y*b.y, a.x*b.y+b.x*a.y);\n}\n\n// 1 / z\nvec2 zinv(vec2 a)\n{\n\treturn vec2(a.x, -a.y) / dot(a,a);\n}\n\n// z^n ( n : 1 to 100 )\nvec2 zpow(vec2 a, int n)\n{\n\tvec2 res = a;\n\tfor (int k=1;k<100;k++)\n\t{\tif (k>n-1) break;\n\t\tres = zmul(res, a);\t}\n\treturn res;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 g = fragCoord.xy;\n    \n\tvec2 si = iResolution.xy;\n    \n\tvec2 uv = (g+g-si)/min(si.x,si.y) * 1.5;\n    \n\tvec2 v = vec2(390., 150. + 15. * sin(iTime*0.25));\n\t\n\tvec2 z = uv + vec2(0);\n\t\n\tvec2 c = (v*2.-vec2(900,300))/150.;\n\t\n\tfloat it = 0.;\n\tfloat d = 0.;\n\tfor (int i=0;i<100;i++)\n\t{\n\t\tif (dot(z,z) > 4.) break;\n\t\tz = zinv( zpow(z, 3)) + c;\n\t\tit++;\n\t}\n    \n    // from iq code, but here i have not the smooth ieteration display... but why, and how i can smooth ?\n\tfloat sit = it - log2(log2(dot(z,z)))/log(4.) + 4.;\n    fragColor = 0.5 + 0.5 * cos( 2.88 + sit*0.2 + vec4(.3,1,0,1));\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MttXzj.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 9, 36, 36, 86], [88, 97, 116, 116, 154], [156, 180, 206, 206, 306], [308, 308, 365, 365, 952]], "test": "valid"}
{"id": "MtySz1", "name": "hhhzzzsss Orbit Traps", "author": "hhhzzzsss", "description": "This is a combination of two orbit traps on a mandelbrot set. One is based on a line, and the other is based on a point. The line and the point is constantly changing, resulting in the animation shown.", "tags": ["fractal", "mandelbrot", "orbit", "orbittraps", "trap", "pickover", "stalk", "pickoverstalks"], "likes": 4, "viewed": 247, "published": "Public", "date": "1482803146", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define iterations 200\n\nvec3 hsv2rgb(vec3 c)\n{\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nfloat calctrap(vec2 z) {\n    vec2 center = 0.3*vec2(sin(0.82342*iTime+2.254), sin(0.41423*iTime+331.234));\n    vec2 direction = normalize(vec2(sin(0.794875*iTime+3.2534), sin(1.0985734*iTime+5.253)));\n\tfloat stalk1 = abs(dot( z - center, direction ));\n    float stalk2 = abs(dot( z - center, vec2(direction.y,-direction.x) ));\n    float stalk = min(stalk1, stalk2);\n    \n    center = 0.3*vec2(sin(1.7509*iTime+23.423), sin(2.41423*iTime+623.724));\n    float point = length(z-center)/3.0;\n\t\n    return min(point,stalk);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    uv = 2.0*uv-1.0;\n    uv.x *= iResolution.x/iResolution.y;\n    uv *= 1.3;\n    \n    vec2 z = uv;\n    vec2 c = uv;\n    float trap = calctrap(z);\n    for (int i = 0; i < iterations; ++i) {\n        //if (dot(z,z) > 4.0) break;\n        z = vec2(z.x*z.x - z.y*z.y, 2.0*z.x*z.y) + c;\n        trap = min(trap, calctrap(z));\n    }\n\tfragColor = vec4(hsv2rgb(vec3(1.0/(1.0+trap*50.0) - 0.3,1.0,1.0)),1.0);\n    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MtySz1.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[24, 24, 46, 46, 215], [217, 217, 241, 241, 737], [739, 739, 796, 796, 1243]], "test": "valid"}
{"id": "MtyXRW", "name": "message: sound in #2", "author": "FabriceNeyret2", "description": "Utility for your sound shaders: \nadd a text in the iconic form for people know the shader is about sound (otherwise sometime hard to guess)\n\nnew font-texture based version of : https://www.shadertoy.com/view/ltfSRr", "tags": ["text", "font", "utils"], "likes": 5, "viewed": 1305, "published": "Public API", "date": "1483185532", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// === icon message: \"sound in\". link: https://www.shadertoy.com/view/MtyXRW\n\n// --- access to the image of ascii code c\n//#define C(c) U.x-=.5; T+= U.x<.0||U.x>1.||U.y<0.||U.y>1. ?vec4(0): texture( iChannel3, U/16. + fract( vec2(c, 15-c/16) / 16.))\n//#define C(c) U.x-=.5; T+= U.x<.0||U.x>1.||U.y<0.||U.y>1. ?vec4(0): textureLod( iChannel3, U/16. + fract( vec2(c, 15-c/16) / 16.), \\\n//                                                                               log2(length(fwidth(U/16.*iResolution.xy))) )\n  #define C(c) U.x-=.5; T+= U.x<.0||U.x>1.||U.y<0.||U.y>1. ?vec4(0): textureGrad(iChannel3, U/16. + fract( vec2(c, 15-c/16) / 16.), dFdx(U/16.),dFdy(U/16.) )\n#define initMsg vec4 T = vec4(0)\n#define endMsg  return length(T.yz)==0. ? 0. : T.x\n\nfloat message(vec2 U) { // to alter in the icon with the alter message\n    vec4 T = vec4(0);   // or: initMsg;\n    C(83);C(111);C(117);C(110);C(100);C(32);C(105);C(110); // message \"Sound in\"\n    return length(T.yz)==0. ? -1. : T.x; // or: endMsg;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    //  if (iResolution.y<200.) to display only in the icon \n    if (iResolution.y<2000.) {float c=message((fragCoord/iResolution.y-vec2(.1,.2))*8.);if(c>=0.){fragColor=vec4(c);return;}}\n\n    \n    vec2 uv = fragCoord.xy / iResolution.xy;\n\tfragColor = vec4(uv,0.5+0.5*sin(iTime),1.0);\n\n}", "image_inputs": [{"id": "4dXGzr", "previewfilepath": "/media/ap/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png", "channel": 3, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MtyXRW.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[753, 753, 776, 823, 1002], [1004, 1004, 1061, 1122, 1348]], "test": "error"}
{"id": "Xl3Szj", "name": "Praise the sun!  \\[T]/", "author": "stduhpf", "description": "A famous character from dark souls(i've never played this game, but this character is funny)\nSorry if it's slow.\nYou can disable volumetric light and shadow if you want a better framerate.(or use low resolution image)\n", "tags": ["modeling", "raytraced", "solaireofastora"], "likes": 12, "viewed": 372, "published": "Public", "date": "1481481758", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define FAR 11.\n\n#define shadows\n#define God_Rays\n#define normal_mapping\n#define Sky\n\n#define Volsteps 10. //quality of the godrays 10 is low but ok with the dithering\n\nfloat rand(vec2 co){\n    return fract(sin(dot(co,vec2(12.9898,78.233)))*43758.5453)-.5;}\nfloat noise(vec2 uv)\n{\n    vec2 u = floor(uv);\n    vec2 v =fract(uv);\n    return mix(\n        mix(\n            rand(u),\n            rand(u+vec2(1,0)),\n            smoothstep(0.,1.,v.x))\n        ,mix(rand(u+vec2(0,1)),\n          rand(u+1.),smoothstep(0.,1.,v.x)),\n                    smoothstep(0.,1.,v.y));\n}\n\nfloat fbm(vec2 uv)\n{\n    float n =1.;\n    float r =1.;\n    for (int i =0;i<8;i++)\n    {\n        uv*=1.9;\n        uv+=100.;\n        n=mix(n,noise(uv),r);\n        r*=.25;\n    }\n    return n;\n}\n\nvec3 sol(vec2 uv)\n{\n    vec3 col = vec3(1.);\n    vec2 p= vec2(length(uv),atan(uv.x,uv.y)+.2);\n    col=mix(col,vec3(1,.4,.1),smoothstep(.005,-.005,p.x-.2*pow(.51+.51*cos(8.*p.y+fbm(vec2(10.*p.x,p.y))),5.-.5)-.15));\n    col=mix(col,vec3(.5,.15,.15),smoothstep(.005,-.005,abs(p.x-.2*pow(.51+.51*cos(8.*p.y+fbm(vec2(10.*p.x,p.y))),5.-.5)-.15)-.01));    \n    col=mix(col,vec3(1,1,.25),smoothstep(.005,-.005,p.x-.13));\n    col=mix(col,vec3(.5,.15,.15),smoothstep(.005,-.005,2.*abs(p.x-.13)-.005));\n\treturn col;\n}\n\n\nfloat rand(vec3 co){\n    return fract(sin(dot(co,vec3(12.9898,78.233,45.4159)))*43758.5453)-.5;}\nfloat noise(vec3 uv)\n{\n    vec3 u = floor(uv);\n    vec3 v =fract(uv);\n    return mix(\n        mix(\n        mix(\n            rand(u),\n            rand(u+vec3(1,0,0)),\n            smoothstep(0.,1.,v.x))\n        ,mix(rand(u+vec3(0,1,0)),\n          rand(u+vec3(1,1,0)),smoothstep(0.,1.,v.x)),\n                    smoothstep(0.,1.,v.y)),\n            mix(\n        mix(\n            rand(u+vec3(0,0,1)),\n            rand(u+vec3(1,0,1)),\n            smoothstep(0.,1.,v.x))\n        ,mix(rand(u+vec3(0,1,1)),\n          rand(u+1.),smoothstep(0.,1.,v.x)),\n                    smoothstep(0.,1.,v.y))\n        ,smoothstep(0.,1.,v.z));\n}\nfloat fbm(vec3 uv)\n{\n    float n =1.;\n    float r =1.;\n    for (int i =0;i<8;i++)\n    {\n        uv*=2.;\n        uv+=100.;\n        n=mix(n,noise(uv),r);\n        r*=.25;\n    }\n    return n;\n}\n\n\n\nfloat sdCappedCylinder( vec3 p, vec2 h )\n{\n  vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\nfloat udRoundBox( vec3 p, vec3 b, float r )\n{\n  return length(max(abs(p)-b,0.0))-r;\n}\nfloat sdTorus82( vec3 p, vec2 t )\n{\n  vec2 q = abs(vec2(length(p.xz)-t.x,p.y));\n  return max(q.x,q.y)-t.y;\n}\n\nfloat smin( float a, float b, float k )\n{\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\nfloat udTriangle( vec3 p, vec3 a, vec3 b, vec3 c )\n{\n    vec3 ba = b - a; vec3 pa = p - a;\n    vec3 cb = c - b; vec3 pb = p - b;\n    vec3 ac = a - c; vec3 pc = p - c;\n    vec3 nor = cross( ba, ac );\n\t#define dot2(n) dot(n,n)\n    return sqrt(\n    (sign(dot(cross(ba,nor),pa)) +\n     sign(dot(cross(cb,nor),pb)) +\n     sign(dot(cross(ac,nor),pc))<2.0)\n     ?\n     min( min(\n     dot2(ba*clamp(dot(ba,pa)/dot2(ba),0.0,1.0)-pa),\n     dot2(cb*clamp(dot(cb,pb)/dot2(cb),0.0,1.0)-pb) ),\n     dot2(ac*clamp(dot(ac,pc)/dot2(ac),0.0,1.0)-pc) )\n     :\n     dot(nor,pa)*dot(nor,pa)/dot2(nor) );\n}\n\nfloat feather(vec3 p)\n{\n    p.x+=.02*cos(20.*p.y+smoothstep(.0,.03,p.y)*iTime);\n    return udTriangle(p,vec3(0,0,0),vec3(0,0,.05),vec3(0,.2,.08));\n}\n\nfloat helmet(vec3 p)\n{\n    float d = sdCappedCylinder(p,vec2(.1,.11))-.03;\n    d=min(d,sdCappedCylinder(p+vec3(0,-.03,0),vec2(.101,.02))-.03);\n    d=min(d,sdBox(p+vec3(.13,.03,0),vec3(.005,.08,.02)));\n    d=max(d,-sdCappedCylinder(p+vec3(.25,-.03,0),vec2(.2,.005)));\n    d=min(d,length(p+vec3(.128,0,0))-.01);\n    d=min(d,length(p+vec3(.128,.04,0))-.01);\n    d=min(d,length(p+vec3(.128,.08,0))-.01);\n    d=min(d,length(p+vec3(.128,-.041,0))-.01);\n    d=smin(d,sdTorus(p+vec3(0,.15,0),vec2(.12+.002*sin(20.*atan(p.x,p.z)),.05)),.03);\n    return d;\n}\n\nvec2 smun(vec2 a,vec2 b,float r)\n{\n\treturn vec2(smin(a.x,b.x,r),b.x<a.x?b.y:a.y);\n}\n\nvec2 chest(vec3 p)\n{\n    p.y+=.15;\n    vec2 d = vec2(udRoundBox(p,vec3(.05+.1*sin(p.y),.18,.12+.01*sin(15.*p.y)),.1),2);\n    d.x=smin(d.x,udTriangle(p,vec3(-.1,-.2,.17),vec3(-.2,-.5,.2),vec3(-.12,-.2,-.1)),.05);\n    d.x=smin(d.x,udTriangle(p,vec3(-.1,-.2,-.17),vec3(-.15,-.5,-.2),vec3(-.12,-.2,.1)),.03);\n    d.x=smin(d.x,udTriangle(p,vec3(.1,-.2,.17),vec3(.11,-.5,.2),vec3(.12,-.2,-.1)),.05);\n    d.x=smin(d.x,udTriangle(p,vec3(.1,-.2,-.17),vec3(.1,-.5,-.2),vec3(.12,-.2,.1)),.03);\n    p.z=-abs(p.z);\n   \tp+=vec3(0,-.18,.18);\n    p.yz*=mat2(cos(.5),-sin(.5),sin(.5),cos(.5));\n    float m= sdCappedCylinder(p,vec2(.1,.08))-.02;\n    d=smun(d,vec2(m,4),.05);\n    return d;\n}\n\nfloat arms(vec3 p)\n{\n        p.z=-abs(p.z);\n\n    p.yz*=mat2(cos(.6),-sin(.6),sin(.6),cos(.6));\n float d =sdCappedCylinder(p-vec3(0,.2,-.16),vec2(.075,.2));  \n    p.yz*=mat2(cos(.2),sin(.2),-sin(.2),cos(.2));\n    d=smin( d,sdCappedCylinder(p-vec3(0,.48,-.23),vec2(.06,.15)),.01);\n        p.yz*=mat2(cos(.2),sin(.2),-sin(.2),cos(.2));\n    d=smin(d,udRoundBox(p-vec3(0,.62,-.35),vec3(.04,.08,.01+sin(240.*p.x)*.003*smoothstep(.61,.63,p.y)),.01),.02);\n    return d;\n}\n\nvec2 un(vec2 a,vec2 b)\n{\n    return b.x<a.x?b:a;\n}\n\nvec2 legs(vec3 p)\n{\n     p.z=-abs(p.z);\n\n    p.yz*=mat2(cos(.3),sin(.3),-sin(.3),cos(.3));\n vec2 d =vec2(sdCappedCylinder(p-vec3(0,-.55,.05),vec2(.075,.2)),5.);\n    p.yz*=mat2(cos(.3),-sin(.3),sin(.3),cos(.3));\n    d.x=smin(d.x,sdCappedCylinder(p-vec3(0,-.85,-.17),vec2(.065,.12)),.05);\n    d=un(d,vec2(smin(\n        sdCappedCylinder(p-vec3(0,-1.05,-.17),vec2(.07,.12)),\n        udRoundBox(p-vec3(-.08,-1.2,-.17),vec3(.15,.02,.05),.02),.1)\n        ,1.));\n    return d;\n}\nfloat tower(vec3 p)\n{\n    float d = sdCappedCylinder(p-vec3(0,-10.,0),vec2(2.5,8.8));\n    d=min(d,sdTorus82(p-vec3(0,-1.,0),vec2(2.5,.3)));\n    p.xz=vec2(length(p.xz),atan(p.x,p.z));\n    p.z=mod(p.z+.315,.63)-.315;\n    p.xz=p.x*vec2(cos(p.z),sin(p.z));\n    d=min(d,udRoundBox(p-vec3(2.6,-.6,0),vec3(.2,.4,.4),.01));\n    return d;\n    }\n\nvec2 map(vec3 p)\n{\n    vec2 m = vec2(helmet(p+vec3(0,-.25,0)),1);\n    m=un(m,chest(p));\n    m=un(m,vec2(feather(p-vec3(0,.35,.05)),3));\n    m=un(m,vec2(arms(p),5));\n    m=smun(m,legs(p),.1);\n    m=un(m,vec2(tower(p),6.));\n    return m;\n}\n\n\nvec3 normal(vec3 p)\n{\n    vec2 e = vec2(.0001,0);\n    vec3 n=  vec3 (map(p+e.xyy).x-map(p-e.xyy).x,map(p+e.yxy).x-map(p-e.yxy).x,map(p+e.yyx).x-map(p-e.yyx).x);\n    return normalize(n);\n}\n\n\nvec2 intersect(vec3 ro, vec3 rd)\n{\n    float f=0.;\n    for(int i = 0; i <500; i++)\n    {\n        vec2 h = map(ro+f*rd);\n            if(h.x<.002)\n                return vec2(f,h.y);\n           if(f > FAR)\n           \t\tbreak;\n            f+=.9*h.x;\n    }\n    return vec2(FAR,0);\n}\n\nfloat shad(vec3 rd,vec3 ro)\n{\n    float t=0.01;\n    for(int i=0;i<100;i++)\n    {\n        vec3 pos = ro+t*rd;\n        vec2 h= map(pos);\n        if(h.x<.005)\n                return 0.;\n        t+=.8*h.x;\n        if(t>FAR)\n        break;\n        }\n\n    return 1.;\n}\n#ifdef God_Rays\nfloat scat(vec3 p, vec3 rd, vec3 ld, float d)\n{\n    float Step= d/Volsteps;\n    float scat=0.;\n    p-=Step*rd*rand(sin(rd.xy/rd.z+iTime)*100.);\n    for(float i =0.;i<Volsteps;i++)\n    {\n        p+=Step*rd;\n        scat+=shad(ld,p);\n    }\n    return scat/Volsteps;\n}\n#endif\n\nfloat ao(vec3 p, vec3 n)\n{\n    const float ao_it =4.;\n    float d=0.;\n    float sm =0.;\n    for(float i=1.;i<ao_it;i++)\n    {\n        d+=.3;\n        float h = map(p+d*n).x;\n        sm+=(d-h)/pow(2.8,i);\n    }\n    return max(0.,1.-sm*4.);\n\n}\n\nvec3 gettex(vec3 p , float i)\n{\n    if(i==1.)\n    \treturn .4+.2*texture(iChannel0,vec2(p.y+p.x,atan(p.x,p.z))).rgb;\n    if(i==2.)\n        return abs(p.y+.3)<.01?vec3(.32,.08,.08):(p.x<0.?sol(2.2*p.yz+vec2(.2,0)):vec3(1));\n    if(i==3.)\n        return vec3(.8,.1,.1);\n     if(i==4.)\n        return vec3(.1,.4,.1);\n     if(i==5.)\n    \treturn .2+.2*texture(iChannel0,vec2(p.y+p.x,atan(p.x,p.z))).rgb;\n      if(i==6.)\n    \treturn .4+.2*texture(iChannel2,p.xz).rgb;\n    return vec3(1);\n}\n#ifdef normal_mapping\nvec3 normap(vec3 nor,vec3 pos,float i)\n{\n    if(i==1.)\n        return normalize(nor+.1*vec3(fbm(40.*pos),fbm(40.*pos+10.),fbm(40.*pos+20.)));\n    if(i==2.)\n        return  normalize(nor+.15*texture(iChannel1,vec2(pos.y+pos.x,atan(pos.x,pos.z))).rgb);\n    if(i==3.)\n        return normalize(nor+.25*texture(iChannel1,vec2(pos.y+pos.x,atan(pos.x,pos.z))).rgb);\n    if(i==4.)\n        return normalize(nor+.2*vec3(fbm(20.*pos),fbm(20.*pos+10.),fbm(20.*pos+20.)));\n    if(i==5.)\n        return normalize(nor+.3*cos(200.*pos)*cos(200.*pos)); \n    return nor;\n}\n#endif\nfloat getspec(float i)\n{\n    if(i==1.)\n        return 2.;\n    if(i==2.)\n        return .3;\n    if(i==4.)\n        return .15;\n    if(i==5.)\n        return 1.;\n    return 0.;\n}\n\nvec4 gamma(vec4 x, float p)\n{\n    return vec4(pow(x.x,p),pow(x.y,p),pow(x.z,p),pow(x.w,p));\n}\n#ifdef Sky\nvec3 SkyBg (vec3 rd)\n{\n  const vec3 sbCol1 = vec3 (0.05, 0.05, 0.15), sbCol2 = vec3 (0.2, 0.25, 0.5);\n  vec3 col = sbCol2 + 0.2 * vec3(1,.9,.5) * pow (1. - max (rd.y, 0.), 5.);\n  return col;\n}\nvec3 SkyCol (vec3 ro, vec3 rd,vec3 sunDir)  //adapted from \"train ride\" by dr2\n{\n  const vec3 sCol1 = vec3 (0.06, 0.04, 0.02), sCol2 = vec3 (0.03, 0.03, 0.06),\n     mBrite = vec3 (-0.5, -0.4, 0.77);\n  const float skyHt = 150.;\n  vec3 col;\n  float cloudFac;\n  if (rd.y > 0.) {\n    ro.x += 0.5 ;\n    vec2 p = 0.02 * (rd.xz * (skyHt - ro.y) / rd.y + ro.xz);\n    float w = 0.8;\n    float f = 0.;\n    for (int j = 0; j < 4; j ++) {\n      f += w * fbm (.8+p*.5)*2.+.1;\n      w *= 0.5;\n      p *= 2.;\n    }\n    cloudFac = clamp (5. * (f - 0.4) * rd.y - 0.1, 0., 1.);\n  } else cloudFac = 0.;\n\n    float s = max (dot (rd, sunDir), 0.);\n    col = SkyBg (rd) + vec3(1,.9,.5) * (0.35 * pow (s, 6.) +\n       0.65 * min (pow (s, 256.), 0.3));\n    col = mix (col, vec3 (0.55), cloudFac);\n  \n  return col;\n}\n#endif\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = (2.*fragCoord.xy -iResolution.xy)/iResolution.y;\n    vec2 mse =iMouse.xy/iResolution.x-vec2(.5,.5+(iResolution.y-iResolution.x)/(2.*iResolution.x));\n    mse*=8.*vec2(-1,1)/*part of the fix*/;\n    if(iMouse.xy==vec2(0))\n        mse=vec2(-2.5,.3);\nmat3 rdroty = mat3(1,0,0,0,cos(mse.y),sin(mse.y),0,-sin(mse.y),cos(mse.y));\nmat3 rdrotx = mat3(cos(mse.x),0,sin(mse.x),0,1,0,-sin(mse.x),0,cos(mse.x));\n\n    vec3 ro = vec3(0,0,-2.)*rdroty*rdrotx;\n    vec3 rd = normalize(vec3(uv*vec2(-1,1)/*part of the fix*/,2.))*rdroty*rdrotx;\n    rd=rd.zyx; //i fucked up with the distance fuction so this is just a fix\n    ro=ro.zyx;\n    float m =0.;\n    vec2 i = intersect(ro,rd);\n    \n    vec3 ld = normalize(vec3(-1.,.5,-.5));\n    \n    m+=.1/distance(rd,ld);\n    #ifdef Sky\n    vec3 col = SkyCol(ro,rd,ld);\n    #else\n    vec3 col= mix(vec3(.5,.6,.9),vec3(1,.9,.5),min(1.,.1/distance(rd,ld)));\n     #endif\n    if(i.y>0.)\n    {\n    vec3 pos = ro+i.x*rd;\n    vec3 nor = normal(pos);\n    float amb =ao(pos,nor)*.5;\n        #ifdef normal_mapping\n    nor=normap(nor,pos,i.y);\n\t#endif\n        m=amb;\n        float sh =1.;\n        #ifdef shadows\n       sh=shad(ld,pos+.01*nor);\n        #endif\n        m+=max(0.,dot(nor,ld))*sh;\n       m+=min(1.,pow(.1/distance(reflect(rd,nor),ld),2.))*getspec(i.y)*sh;\n        col= gettex(pos,i.y);\n             col *= (m);\n\n        \n    }\n    #ifdef God_Rays\n   col = mix(col, vec3(1,.9,.6),scat(ro,rd,ld,i.x)/4.);\n    #endif\n    \n\tfragColor = gamma(vec4(col,1.0),.8);\n}", "image_inputs": [{"id": "4sXGRn", "previewfilepath": "/media/ap/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg", "ctype": "texture"}, {"id": "4dX3Rn", "previewfilepath": "/media/ap/bd6464771e47eed832c5eb2cd85cdc0bfc697786b903bfd30f890f9d4fc36657.jpg", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/bd6464771e47eed832c5eb2cd85cdc0bfc697786b903bfd30f890f9d4fc36657.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Xl3Szj.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[169, 169, 189, 189, 257], [258, 258, 280, 280, 566], [568, 568, 588, 588, 758], [760, 760, 779, 779, 1266], [1269, 1269, 1289, 1289, 1365], [1366, 1366, 1388, 1388, 1986], [1987, 1987, 2007, 2007, 2176], [2180, 2180, 2222, 2222, 2321], [2322, 2322, 2353, 2353, 2440], [2441, 2441, 2474, 2474, 2539], [2540, 2540, 2585, 2585, 2625], [2626, 2626, 2661, 2661, 2734], [2736, 2736, 2777, 2777, 2870], [2871, 2871, 2923, 2923, 3455], [3457, 3457, 3480, 3480, 3605], [3607, 3607, 3629, 3629, 4155], [4157, 4157, 4191, 4191, 4240], [4242, 4242, 4262, 4262, 4914], [4916, 4916, 4936, 4936, 5379], [5381, 5381, 5405, 5405, 5431], [5433, 5433, 5452, 5452, 5903], [5904, 5904, 5925, 5925, 6239], [6241, 6241, 6259, 6259, 6478], [6481, 6481, 6502, 6502, 6668], [6671, 6671, 6705, 6705, 6949], [6951, 6951, 6980, 6980, 7213], [7504, 7504, 7530, 7530, 7744], [7746, 7746, 7777, 7777, 8228], [8813, 8813, 8837, 8837, 8987], [8989, 8989, 9018, 9018, 9082], [10088, 10088, 10145, 10145, 11639]], "test": "error"}
{"id": "Xl3XD2", "name": "Without Tracers", "author": "voz", "description": "Without Tracers", "tags": ["withouttracers"], "likes": 2, "viewed": 469, "published": "Public API", "date": "1481565723", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n\n//-----------------CONSTANTS MACROS-----------------\n\n#define PI 3.14159265359\n#define E 2.7182818284\n#define GR 1.61803398875\n#define MAX_DIM (max(iResolution.x,iResolution.y))\n\n//-----------------UTILITY MACROS-----------------\n\n#define time ((sin(float(__LINE__))/PI/GR/E+1.0/PI/GR/E)*iTime+1000.0)\n#define sphereN(uv) (clamp(1.0-length(uv*2.0-1.0), 0.0, 1.0))\n#define clip(x) (smoothstep(0.25, .75, x))\n#define TIMES_DETAILED (1.0)\n#define angle(uv) (atan(uv.y, uv.x))\n#define angle_percent(uv) ((angle(uv)/PI+1.0)/2.0)\n#define hash(p) (fract(sin(vec2( dot(p,vec2(127.5,313.7)),dot(p,vec2(239.5,185.3))))*43458.3453))\n\n#define flux(x) (vec3(cos(x),cos(4.0*PI/3.0+x),cos(2.0*PI/3.0+x))*.5+.5)\n#define rormal(x) (normalize(sin(vec3(time, time/GR, time*GR)+seedling)*.25+.5))\n#define rotatePoint(p,n,theta) (p*cos(theta)+cross(n,p)*sin(theta)+n*dot(p,n) *(1.0-cos(theta)))\n\nfloat saw(float x)\n{\n    x/= PI;\n    float f = mod(floor(abs(x)), 2.0);\n    float m = mod(abs(x), 1.0);\n    return f*(1.0-m)+(1.0-f)*m;\n}\nvec2 saw(vec2 x)\n{\n    return vec2(saw(x.x), saw(x.y));\n}\n\nvec3 saw(vec3 x)\n{\n    return vec3(saw(x.x), saw(x.y), saw(x.z));\n}\nvec4 saw(vec4 x)\n{\n    return vec4(saw(x.x), saw(x.y), saw(x.z), saw(x.w));\n}\n\n//-----------------SEEDLINGS-----------------------\nfloat seedling = 0.0;\nfloat stretch = 1.0;\nvec2 offset = vec2(0.0);\nfloat last_height = 0.0;\nfloat scale = 1.0;\nfloat extraTurns = 0.0;\nfloat aspect = 1.0;\n//-----------------TREES---------------------------\nfloat distTree = 0.0;\nfloat angleTree = 0.0;\n\n//-----------------BASE IMAGE--------------------------\n\nvec4 stars(vec2 uv)\n{\n    float density = 2.0;\n    uv *= density;\n    float s = floor(uv.x)*1234.1234+floor(uv.y)*123.123;\n    vec2 p = floor(uv)+saw(floor(uv)+iTime+s)*.5+.25;\n    \n    float l = length(p-uv);\n    float f = smoothstep(.1*GR, 1.0, exp(-l*8.0));\n    \n    return vec4(clamp(flux(f+s+seedling)*f+f*f*f, 0.0, 1.0), f);\n}\n\nvec4 galaxy(vec2 uv)\n{\n    uv = rotatePoint(vec3(uv, 0.0), vec3(0.0, 0.0, 1.0), time*(saw(seedling)+1.0)*PI*4.0).xy;;\n    vec2 uv0 = uv;\n    float r = length(uv);\n\tuv *= 5.0*(GR);\n    \n    \n    float r1 = log(length(uv)+1.)*2.0;\n    float r2 = pow(log(length(uv)+1.)*3.0, .5);\n    \n    float rotation = iTime;\n    \n    float theta1 = atan(uv.y, uv.x)-r1*PI+rotation*.5+seedling;\n    float theta2 = atan(uv.y, uv.x)-r2*PI+rotation*.5+seedling;\n    \n    float plant = (seedling*GR+1.0/GR)*4.0*PI;\n    \n    \n    float arms = acos(1.0-(cos(theta1)*cos(theta1)+sqrt(cos(theta1+PI)*cos(theta1+PI)))/2.0)\n              + cos(1.0-(cos(theta2)*cos(theta2)+cos(theta2+PI/2.)*cos(theta2+PI/2.))/2.0);\n    \n    vec4 color = vec4(flux(plant*PI+arms+time*PI)*smoothstep(0.0, 1.0/5.0, saw(plant+arms+theta1+theta2)), 1.0)*arms;\n    \n    color += stars(uv)*arms;\n    vec4 final = clamp(color/2.0, 0.0, 1.0);\n         \n    final /= r1;\n    \n\tfinal = (clamp(final, 0.0, 1.0));\n    \n    \n    float weight = clamp(length(clamp(final.rgb, 0.0, 1.0)), 0.0, 1.0);\n    return clamp(final*smoothstep(0.0, 1.0/GR/PI/E, 1.0-r)*length(color.rgb), 0.0, 1.0);\n}\n\n//-----------------IMAGINARY TRANSFORMATIONS-----------------\n\nvec2 cmul(vec2 v1, vec2 v2) {\n\treturn vec2(v1.x * v2.x - v1.y * v2.y, v1.y * v2.x + v1.x * v2.y);\n}\n\nvec2 cdiv(vec2 v1, vec2 v2) {\n\treturn vec2(v1.x * v2.x + v1.y * v2.y, v1.y * v2.x - v1.x * v2.y) / dot(v2, v2);\n}\n\nvec2 mobius(vec2 uv)\n{\n    \n    //numerator /= (abs(denominator)+1.0);\n    \n    vec2 quotient = vec2(0.0);\n    const int bends = 16;\n    for(int i = 0; i < bends; i++)\n    {\n       \tfloat iteration = float(i)/float(bends);\n        vec2 numerator = uv;\n        vec2 denominator =rotatePoint(vec3(cmul(uv, sin(vec2(time+seedling-2.0*PI*sin(-iteration+time/GR), time/GR+seedling-2.0*PI*sin(iteration+time)))), 0.0), vec3(0.0, 0.0, 1.0), time*PI).xy\n            +vec2(cos(iteration*16.0*PI-(time*PI+seedling)*PI*2.0), sin(iteration*16.0*PI-(time*PI+seedling)*PI*2.0))*iteration*2.0;\n        vec2 final = (cdiv(numerator, denominator));\n        quotient += final/(float(bends));\n        \n        \n    }\n        \n    float a = atan(quotient.y, quotient.x);\n    \n    angleTree = a/PI;\n    distTree = length(quotient.xy);\n    \n    //quotient = rotatePoint(vec3(quotient, 0.0), vec3(0.0, 0.0, 1.0), a).xy;\n    vec2 next = quotient;\n\n\n    float denom = length(fwidth(uv));//max(fwidth(uv.x),fwidth(uv.y));\n    denom += 1.0-abs(sign(denom));\n\n    float numer = length(fwidth(next));//min(fwidth(next.x),fwidth(next.y));\n    numer += 1.0-abs(sign(numer));\n\n    \n    \n    stretch = denom/numer;\n    \n    return quotient;\n}\n\n//-----------------ITERATED FUNCTION SYSTEM-----------------\n\nvec2 iterate(vec2 uv)\n{\n    uv += offset;\n    \n    \n    vec2 final = mobius(uv);\n    \n    seedling = (floor(final.x)+floor(final.y));\n    \n    return final;\n}\n    \nvec3 weights[32];\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    float scale = GR*5.0+2.0*sin(time*12.0*PI);\n    uv = uv*scale-scale/2.0;\n    \n    float aspect = iResolution.x/iResolution.y;\n    \n    uv.x *= aspect;\n    \n    vec2 uv0 = uv;\n    \n\tconst int max_iterations = 4;\n    int target = max_iterations;//-int(saw(spounge)*float(max_iterations)/2.0);\n    \n    float antispeckle = 1.0; \n    float magnification = 1.0;\n  \n\tvec4 color = vec4(0.0);\n    float center = 1.0E32;\n    float angle = atan(uv.y, uv.x)/PI;\n    float border = 1.0;\n    \n    seedling = 0.0;\n    \n        \n    offset = sin(vec2(time+seedling,\n                      -time-seedling))*(.5/E);\n    \n    border *= (1.0-color.a);//*antispeckle;\n    \n    for(int i = 0; i < max_iterations; i++)\n        weights[i] = vec3(vec2(0.0), 1.0);\n    \n    for(int i = 0; i < max_iterations; i++)\n    {\n        float iteration = float(i)/float(max_iterations);\n\n        seedling = float(i);\n        extraTurns = float(i*i+1);\n\n        uv = iterate(uv);\n        \n        antispeckle *= clamp(1.0/length(fwidth(uv)), 0.0, 1.0);\n\n        float weight = smoothstep(0.0, 1.0, pow(antispeckle, 1.0/float(i+1)));\n        \n        weights[i] = vec3(uv*2.0-1.0, weight);\n\n        float draw = border*(1.0-color.a);\n\n        float skip = saw(floor(uv.x+uv.y)*PI*123.0);\n\n        vec3 p = vec3(saw(uv*PI), sphereN(saw(uv*PI)));\n        \n        center = min(center, distTree);\n        \n        angle = (angle*angleTree);\n        \n        color += (galaxy((p.xy)*2.0-1.0)+stars(p.xy))*draw*weight;//+stars(p.xy)*draw, 0.0, 1.0);\n        border *= draw;//*antispeckle;\n\n    }\n    float core = (1.0-smoothstep(0.0, 1.0/PI/GR/E, antispeckle));\n    antispeckle = pow(antispeckle, 1.0/float(max_iterations));\n    fragColor = vec4((color))+smoothstep(0.0, 1.0/PI, core*antispeckle)*vec4(flux(seedling), 1.0);\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Xl3XD2.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[877, 877, 897, 897, 1014], [1015, 1015, 1033, 1033, 1072], [1074, 1074, 1092, 1092, 1141], [1142, 1142, 1160, 1160, 1219], [1584, 1584, 1605, 1605, 1916], [1918, 1918, 1940, 1940, 3049], [3114, 3114, 3143, 3143, 3213], [3215, 3215, 3244, 3244, 3328], [4603, 4603, 4626, 4626, 4761], [4787, 4787, 4844, 4844, 6677]], "test": "valid"}
{"id": "Xl3XDX", "name": "White cylinders", "author": "NathanRH", "description": "Modified from https://www.shadertoy.com/view/4dSGW1", "tags": ["raytrace", "cylinder"], "likes": 4, "viewed": 343, "published": "Public", "date": "1481732693", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Created by inigo quilez - iq/2013\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n\n// Try 4, 15, 30 samples if yo have a powerful machine\n\n#define VIS_SAMPLES 6\n\n\nfloat hash1( float n ) { return fract(43758.5453123*sin(n)); }\nfloat hash1( vec2  n ) { return fract(43758.5453123*sin(dot(n,vec2(1.0,113.0)))); }\nvec2  hash2( float n ) { return fract(43758.5453123*sin(vec2(n,n+1.0))); }\n\nfloat gAnimTime;\nfloat map( vec2 p ) \n{\n\tfloat f = texture( iChannel0, p/iChannelResolution[0].xy, -100.0 ).x;\n\t\n\tf *= sqrt( texture( iChannel2, (0.03*p + 2.0*gAnimTime)/256.0 ).x );\n\treturn 22.0*f;\n}\n\nvec3 calcNormal( in vec3 pos, in float ic )\n{\n\treturn mix( normalize(vec3(pos.x,0.0,pos.z)), vec3(0.0,1.0,0.0), ic );\n}\n\nvec4 castRay( in vec3 ro, in vec3 rd )\n{\n\tvec2 pos = floor(ro.xz);\n\tvec2 ri = 1.0/rd.xz;\n\tvec2 rs = sign(rd.xz);\n\tvec2 ris = ri*rs;\n\tvec2 dis = (pos-ro.xz+ 0.5 + rs*0.5) * ri;\n\t\n\tvec4 res = vec4( -1.0, 0.0, 0.0, 0.0 );\n\n    // traverse regular grid (in 2D)\n\tvec2 mm = vec2(0.0);\n\tfor( int i=0; i<200; i++ ) \n\t{\n\n\t\tfloat ma = map(pos);\n\t\t\n        // intersect capped cylinder\t\t\n\t\tvec3  ce = vec3( pos.x+0.5, 0.0, pos.y+0.5 );\n\t\tvec3  rc = ro - ce;\n\t\tfloat a = dot( rd.xz, rd.xz );\n\t\tfloat b = dot( rc.xz, rd.xz );\n\t\tfloat c = dot( rc.xz, rc.xz ) - 0.249;\n\t\tfloat h = b*b - a*c;\n\t\tif( h>=0.0 )\n\t\t{\n            // cylinder\t\t\t\n\t\t\tfloat s = (-b - sqrt( h ))/a;\n\t\t\tif( s>0.0 && (ro.y+s*rd.y)<ma )\n\t\t\t{\n\t\t\t\tres = vec4( s, 0.0, pos );\n    \t\t\tbreak; \n\t\t\t}\n            // cap\t\t\t\n\t\t\ts = (ma - ro.y)/rd.y;\n\t\t\tif( s>0.0 && (s*s*a+2.0*s*b+c)<0.0 )\n\t\t\t{\n\t\t\t\tres = vec4( s, 1.0, pos );\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n        // step to next cell\t\t\n\t\tmm = step( dis.xy, dis.yx ); \n\t\tdis += mm*ris;\n        pos += mm*rs;\n\t}\n\n\n\treturn res;\n}\n\nfloat castShadowRay( in vec3 ro, in vec3 rd )\n{\n\tvec2 pos = floor(ro.xz);\n\tvec2 ri = 1.0/rd.xz;\n\tvec2 rs = sign(rd.xz);\n\tvec2 ris = ri*rs;\n\tvec2 dis = (pos-ro.xz+ 0.5 + rs*0.5) * ri;\n\tfloat t = -1.0;\n\tfloat res = 1.0;\n\t\n    // first step we check noching\t\n\tvec2 mm = step( dis.xy, dis.yx ); \n\tdis += mm * ris;\n    pos += mm * rs;\n\t\n    // traverse regular grid (2D)\t\n\tfor( int i=0; i<16; i++ ) \n\t{\n\t\tfloat ma = map(pos);\n\t\t\n        // test capped cylinder\t\t\n\t\tvec3  ce = vec3( pos.x+0.5, 0.0, pos.y+0.5 );\n\t\tvec3  rc = ro - ce;\n\t\tfloat a = dot( rd.xz, rd.xz );\n\t\tfloat b = dot( rc.xz, rd.xz );\n\t\tfloat c = dot( rc.xz, rc.xz ) - 0.249;\n\t\tfloat h = b*b - a*c;\n\t\tif( h>=0.0 )\n\t\t{\n\t\t\tfloat t = (-b - sqrt( h ))/a;\n\t\t\tif( (ro.y+t*rd.y)<ma )\n\t\t\t{\n\t\t\t\tres = 0.0;\n    \t\t\tbreak; \n\t\t\t}\n\t\t}\n\t\tmm = step( dis.xy, dis.yx ); \n\t\tdis += mm * ris;\n        pos += mm * rs;\n\t}\n\n\treturn res;\n}\n\nvec3 cameraPath( float t )\n{\n    // procedural path\t\n    vec2 p  = 200.0*sin( 0.01*t*vec2(1.2,1.0) + vec2(0.1,0.9) );\n\t     p += 100.0*sin( 0.02*t*vec2(1.1,1.3) + vec2(1.0,4.5) );\n\tfloat y = 15.0 + 4.0*sin(0.05*t);\n\t\n\t// collision\n\tfloat h;\n\th  = map( p+vec2(-1.0, 0.0) );\n\th += map( p+vec2( 1.0, 0.0) );\n\th += map( p+vec2( 0.0, 1.0) );\n\th += map( p+vec2( 0.0,-1.0) );\n\th /= 4.0;\n\th += 5.0;\n\ty = max( y, h );\n\n\treturn vec3( p.x, y, p.y );\n}\n\nvec4 texcyl( sampler2D sam, in vec3 p, in vec3 n )\n{\n\tvec4 x = texture( sam, vec2(p.y,0.5+0.5*atan(n.x,n.z)/3.14) );\n\tvec4 y = texture( sam, p.xz );\n\treturn mix( x, y, abs(n.y) );\n}\n\nvec3 desat( in vec3 col, float a )\n{\n    return mix( col, vec3(dot(col,vec3(0.333))), a );\n}\n\nvec3 lig = normalize(vec3(-0.7,0.25,0.6));\n\nvec3 render( in vec3 ro, in vec3 rd )\n{\n        // background color\t\n\t\tfloat sun = clamp( dot( rd, lig ), 0.0, 1.0 );\n\n\t\tvec3 bgcol = vec3(0.9,0.9,0.9);// + 0.3*pow(sun,4.0)*vec3(1.0,1.0,0.0);\n\n        // raytrace\n        vec3 col = bgcol;\n\t\tvec4 res = castRay( ro, rd );\n        vec2 vos = res.zw;\n        float t = res.x;\n        if( t>0.0 )\n        {\n            vec3  pos = ro + rd*t;\n\t\t\tfloat id  = hash1( vos );\n\t\t\tvec3  nor = calcNormal( fract(pos)-0.5, res.y );\n\t\t\tfloat h = map(vos);\n\n            // material color\t\t\t\n\t\t\tvec3 mate1 = vec3(0.7, 0.7, 0.75); //0.5 + 0.45*sin( 3.14*id + 0.8 + vec3(0.0,0.5,1.0) );\n\t\t\tvec3 mate2 = vec3(0.9, 0.9, 0.9); //0.5 + 0.45*sin( 6.28*id + vec3(0.0,0.5,1.0) );\n\t\t\tvec3 mate = mix( mate1, mate2, smoothstep( 9.0, 11.0, h) );\n\t\t\t\n\t\t\tvec3 uvw = pos - vec3(0.0,h,0.0);\n\t\t\tvec3 tex = texcyl( iChannel3, 0.2*uvw + 13.1*hash1(id), nor ).xyz;\n\t\t\t//mate *= 0.2+4.0*pow( desat(tex,0.3), vec3(2.0) );\n            //mate *= 1.5*sqrt(texture( iChannel0, pos.xz/iChannelResolution[0].xy ).xyz);\n            //mate *= 0.02 + 0.98*smoothstep( 0.1,0.11, hash1(id) );\t\n\t\t\n            \n            // material cheap/wrong bump\t\t\t \n            vec3 bn = -1.0 + 2.0*texcyl( iChannel1, 0.2*uvw*vec3(1.0,0.2,1.0) + 13.1*hash1(id), nor ).xyz;\n            //nor = normalize(nor + 0.45*bn*(1.0-0.5*nor.y) );\n\t\t\t\n\t\t\t// procedural occlusion\n\t\t\tfloat occ = nor.y*0.75;\n\t\t\tocc += 0.5*clamp( nor.x,0.0,1.0)*smoothstep( -0.5, 0.5, pos.y-map(vos+vec2( 1.0, 0.0)) );\n\t\t\tocc += 0.5*clamp(-nor.x,0.0,1.0)*smoothstep( -0.5, 0.5, pos.y-map(vos+vec2(-1.0, 0.0)) );\n\t\t\tocc += 0.5*clamp( nor.z,0.0,1.0)*smoothstep( -0.5, 0.5, pos.y-map(vos+vec2( 0.0, 1.0)) );\n\t\t\tocc += 0.5*clamp(-nor.z,0.0,1.0)*smoothstep( -0.5, 0.5, pos.y-map(vos+vec2( 0.0,-1.0)) );\n\t\t\tocc = 0.2 + 0.8*occ;\n\t\t\tocc *= pow( clamp((0.1+pos.y)/(0.1+map(floor(pos.xz))),0.0,1.0),2.0);\n\t\t\tocc = occ*0.5+0.5*occ*occ;\n\t\t\tfloat rim = pow( clamp( 1.0+dot(rd,nor), 0.0, 1.0 ),5.0 );\n \n            //-------------\n            // lighting\n            //-------------\n\t\t\tfloat amb = 1.0;\n            //-------------\n\t\t\tfloat bac = clamp( dot( nor, normalize(vec3(-lig.x,0.0,-lig.z)) ), 0.0, 1.0 ) * clamp(1.0-pos.y/20.0,0.0,1.0);;\n            //-------------\n\t\t\tfloat sha = 0.0;\n\t\t\tfloat dif = dot( nor, lig );\n\t\t\tif( dif<0.0 ) dif=0.0; else sha = castShadowRay( pos, lig );\n            float spe = pow( clamp( dot(lig,reflect(rd,nor)), 0.0, 1.0 ),3.0 );\n            //-------------\n\t\t\tvec3 lin  = 3.00*vec3(1.0,1.0,1.0)*0.7*sqrt(dif)*sha;\n\t\t\t     lin += 0.60*vec3(0.4,1.0,1.7)*amb*occ;\n\t\t\t     lin += 0.70*vec3(0.8,0.5,0.3)*bac*occ;\n\t\t\t\n\t\t\tcol = mate * lin + tex.x*1.5*vec3(1.0,1.0,1.0)*(0.3+0.7*rim)*spe*dif*sha;\n\n            // tone mapping\t\t\t\n\t\t\tcol *= 1.1 + 0.5*dot( rd, lig );\n\n            // fog\n            float ff = 1.0 - smoothstep( 0.0, 1.0, pow(t/160.0,1.8) );\n\t\t\tcol = mix( col, bgcol, 1.0-ff );\n\t\t}\n\t\tcol += 0.2*pow(sun,8.0)*vec3(1.0,0.7,0.2);\n\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // inputs\t\n\tvec2 q = fragCoord.xy / iResolution.xy;\n\t\n    vec2 mo = iMouse.xy / iResolution.xy;\n    if( iMouse.w<=0.00001 ) mo=vec2(0.0);\n\t\n    gAnimTime = iTime;\n    \n\t// montecarlo\t\n\tvec3 tot = vec3(0.0);\n    #if VIS_SAMPLES<2\n\tint a = 0;\n\t{\n        vec2 p = -1.0 + 2.0*(fragCoord.xy) / iResolution.xy;\n        p.x *= iResolution.x/ iResolution.y;\n        float time = 4.0*iTime + 50.0*mo.x;\n    #else\n\tfor( int a=0; a<VIS_SAMPLES; a++ )\n\t{\n\t\tvec4 rr = texture( iChannel1, (fragCoord.xy+floor(256.0*hash2(float(a))))/iChannelResolution[1].xy );\n        vec2 p = -1.0 + 2.0*(fragCoord.xy+rr.xz) / iResolution.xy;\n        p.x *= iResolution.x/ iResolution.y;\n\t\t#if VIS_SAMPLES>3\n        float time = 4.0*(iTime + 1.0*(0.4/24.0)*rr.w) + 50.0*mo.x;\n\t\t#else\n        float time = 4.0*(iTime) + 50.0*mo.x;\n\t\t#endif\n    #endif\t\n\n\t\t// camera\n        vec3  ro = cameraPath( time );\n        vec3  ta = cameraPath( time+5.0 ); ta.y = ro.y - 5.5;\n        float cr = 0.2*cos(0.1*time*0.5);\n\t\n        // build ray\n        vec3 ww = normalize( ta - ro);\n        vec3 uu = normalize(cross( vec3(sin(cr),cos(cr),0.0), ww ));\n        vec3 vv = normalize(cross(ww,uu));\n        float r2 = p.x*p.x*0.32 + p.y*p.y;\n        p *= (7.0-sqrt(37.5-11.5*r2))/(r2+1.0);\n        vec3 rd = normalize( p.x*uu + p.y*vv + 2.5*ww );\n\n        // dof\n        #if VIS_SAMPLES>2\n        vec3 fp = ro + rd * 17.0;\n        ro += (uu*(-1.0+2.0*rr.y) + vv*(-1.0+2.0*rr.w))*0.035;\n        rd = normalize( fp - ro );\n        #endif\n\n\n        vec3 col = render( ro, rd );\n        \n\t\ttot += col;\n\t}\n\ttot /= float(VIS_SAMPLES);\n\t\n\n\t// gamma\t\n\ttot = pow( clamp(tot,0.0,1.0), vec3(0.44) );\n\n\t// vignetting\t\n\ttot *= 0.5 + 0.5*pow( 16.0*q.x*q.y*(1.0-q.x)*(1.0-q.y), 0.1 );\n\t\n\tfragColor = vec4( tot, 1.0 );\n}\n    \n\nvoid mainVR( out vec4 fragColor, in vec2 fragCoord, in vec3 fragRayOri, in vec3 fragRayDir )\n{\n    vec3 cam = cameraPath( iTime );\n\n    gAnimTime = iTime*0.2;\n\n    vec3 ro = fragRayOri + cam + vec3(0.0,-2.0,0.0);\n    vec3 rd = fragRayDir*vec3(-1.0,1.0,-1.0);\n    vec3 col = render( ro, rd );\n\n    // gamma\t\n\tcol = pow( clamp(col,0.0,1.0), vec3(0.44) );\n\n    fragColor = vec4( col, 1.0 );\n}", "image_inputs": [{"id": "XsXGRn", "previewfilepath": "/media/ap/cd4c518bc6ef165c39d4405b347b51ba40f8d7a065ab0e8d2e4f422cbc1e8a43.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/cd4c518bc6ef165c39d4405b347b51ba40f8d7a065ab0e8d2e4f422cbc1e8a43.jpg", "ctype": "texture"}, {"id": "4sf3Rn", "previewfilepath": "/media/ap/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png", "ctype": "texture"}, {"id": "XdXGzn", "previewfilepath": "/media/ap/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Xl3XDX.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[206, 206, 230, 230, 268], [269, 269, 293, 293, 352], [353, 353, 377, 377, 427], [446, 446, 468, 468, 629], [631, 631, 676, 676, 750], [752, 752, 792, 792, 1764], [1766, 1766, 1813, 1813, 2639], [2641, 2641, 2669, 2693, 3081], [3083, 3083, 3135, 3135, 3264], [3266, 3266, 3302, 3302, 3358], [3404, 3404, 3443, 3472, 6341]], "test": "error"}
{"id": "Xl3XWX", "name": "ChristmasCircle", "author": "McShip", "description": "God Damn frickin right, it's Christmas !", "tags": ["2d"], "likes": 2, "viewed": 1229, "published": "Public", "date": "1481726515", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage(out vec4 color, in vec2 pixCoords){\n    vec2 coords = pixCoords / iResolution.y;\n    coords -= vec2(0.5, 0.5);\n    \n    \n    vec2 center = vec2(cos(iTime), sin(iTime)) * 0.3;\n    \n    vec2 centerToPixel = coords - center;\n    float distance = length(centerToPixel);\n    float angle = atan(centerToPixel.y, centerToPixel.x);\n    float rayon = 0.2 + 0.1 * cos(iTime * 2.0);\n    \n    float speed = (mod(distance, 0.4) < 0.2)? 5.0 : -5.0;\n    if (mod(distance, 0.2) < 0.05 + 0.02 * cos(angle * 20.0 + iTime * speed )){\n        color = vec4(1.0, 0.0, 0.0, 1.0);\n    }\n    \n    else{\n        color = vec4(1.0, 1.0, 1.0, 1.0);\n    }\n}\n            \n        ", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Xl3XWX.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 50, 50, 642]], "test": "valid"}
{"id": "XlcSDf", "name": "Rainbow Pulse", "author": "ptrgags", "description": "Inspired by the color diffraction from https://www.shadertoy.com/view/XsXXDn", "tags": ["2d"], "likes": 4, "viewed": 243, "published": "Public", "date": "1481760455", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Bell-shaped curve with maximum value 1.0\nfloat bell(float x, float center, float stretch) {\n    return exp(-pow((x - center) / stretch, 2.0));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    \n    //Center the origin\n    uv -= 0.5; \n    \n    //Fix aspect ratio\n    float aspect_ratio = iResolution.x / iResolution.y;\n    uv.x *= aspect_ratio;\n    \n    //Distance from center\n    float dist_center = length(uv);\n    \n    // Iterate over the color components\n    for (int i = 0; i < 3; i++) {\n        //Each\n        float phase_shift = float(i) * 0.13;\n        \n    \t//wrap the time value to a range [0.0, 1.5]\n    \t//this is slightly greater than size of the window\n    \t//so it makes the animation smoother. This will be\n    \t//used for the radius of animated pulses\n    \tfloat pulse_radius = mod(iTime + phase_shift, 1.5);\n    \n    \t//how much to stretch the pulse (which takes the form of a bell-shaped\n    \t//curve with respect to distance from center.\n    \tfloat pulse_stretch = 0.2;\n     \n        //Make a bell curve pulsing outwards from the center of the screen.\n        fragColor[i] = bell(dist_center, pulse_radius, pulse_stretch);\n    }\n    fragColor.a = 1.0;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XlcSDf.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 44, 94, 94, 147], [149, 149, 206, 206, 1232]], "test": "valid"}
{"id": "XlcSWS", "name": "Night Cars - Demo", "author": "randomswirls", "description": "cars in the night", "tags": ["sine", "night", "mountains", "cars", "twinkle"], "likes": 14, "viewed": 330, "published": "Public", "date": "1481308876", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define TIMESCALE 1.0\n#define SKYCOLORA vec3(.05,.05,.05)\n#define SKYCOLORB vec3(.15,.15,.15)\n#define STARBRIGHTNESS .5\n#define STARSIZE 1.5\n#define CITYLIGHTSFARSIZE .5\n#define CITYLIGHTSFARBRIGHTNESS .8\n#define CITYLIGHTSCLOSESIZE 2.0\n#define CITYLIGHTSCLOSEBRIGHTNESS 1.0\n#define CARSPACING 2.0\n#define CARLENGTH .2\n\nfloat uTime;\n\n// Function to get a random float\nfloat hash( float n )\n{\n    return fract(sin(n)*43758.5453123);\n}\n\n// Function to get a random vector ( 3 floats)\nvec3 hash3( float n )\n{\n    return fract(sin(vec3(n,n+1.0,n+2.0))*vec3(43758.5453123,22578.1459123,19642.3490423));\n}\n\n// Test if point p is inside or outside a circle centered at c, with radius r\nfloat circle(vec2 p, vec2 c, float r)\n{\n\tif(length(p-c)<r)\n\t{\n\t\treturn 1.0;\n\t}\n\treturn 0.0;\n}\n\n// Helper function to add width to the car lines by finding the closest point, horizonally\n// The line is specified with the point p0 and direction v\nvec2 closestpointHorizontal(vec2 p, vec2 p0, vec2 v)\n{\n\tfloat t1 = (p.x-p0.x)/v.x;\n\treturn p0+v*t1; // closest point \n}\n\n// Alternate function for call lines to find the closest point, but look in a circle\nfloat linedistA(vec2 p, vec2 p0, vec2 v, float len){\n    vec2 r = p-p0;\n\n    float t1 = r.x*v.x+r.y*v.y;\n    t1 = min(len,max(0.0,t1));\n\n    vec2 d = p0+v*t1 - p; // vector to closest point \n    return d.x*d.x+d.y*d.y;\n}\n\n// Draw sparkles, control the scale by scaling the coordinates\nvec3 sparkles(vec2 coord)\n{\n\n\tfloat h = hash(coord.x*.1+coord.y*1.345);\n\tfloat i  = 0.0;\n\n\tif(h>.995)\n\t{\n\t\ti = .5+.5*sin(6.28*hash(coord.x*1.2568+coord.y*.1578)+uTime);\n\t}\n\n\treturn vec3(i,i,i);\n}\n\n// Function to draw the car lines\nvec3 carlines(vec2 coord,vec2 p0, vec2 v0, bool away)\n{\n    // closest point\n\t// distance\n\t// zvalue\n\t// threshold\n\t// base intensity\n\t// segment value\n\t// final intensity\n\n\tvec2 linepoint = closestpointHorizontal(coord,p0,v0);\n\n\tfloat d = length(linepoint-coord);\n\n\tfloat threshold = max(0.0,-linepoint.y)*.02;\n\n\tfloat intensity = 0.0;\n\tif(d<threshold)\n\t\tintensity = 1.0;\n\n    // offset time\n\tfloat z=threshold;\n\tz = 1.0/(-z); // fake perspective\n\tif(away)\n\t\tz+=uTime;\n\telse\n\t\tz-=uTime;\n   \n    // car spacing\n\tfloat interval = mod(z/CARLENGTH,CARSPACING);\n\tif(away) \n\t\tinterval = 1.0-interval;\n\tif(interval < 0.0 || interval > 1.0)\n\t\tinterval = 0.0;\n\t\n\tinterval = clamp(interval,0.0,1.0);\n\t\n\tintensity = intensity*interval;\n    \n    // if the car is moving away from us, return with line color red\n    // if the car is moving towards us, return with line white\n    // towards or away is spedified as a parameter to this carlines function\n\tif(away)\n\t\treturn vec3(intensity,0,0);\n\telse\n\t\treturn vec3(intensity,intensity,intensity);\n\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 ouv = fragCoord.xy / iResolution.xy;\n   \tvec3 uScreen = iResolution;\n    vec3 color;\n    \n    //vec2 ouv = gl_FragCoord.xy/uScreen.xy;\n\tvec2 ocoord = (ouv-vec2(.5,.5))*uScreen.xy;\n\tvec2 uv = ouv;\n\tvec2 coord = ocoord;\n    \n    uTime = iTime*TIMESCALE;\n\t\n\t\n\n\tcolor  = vec3(0,0,0);\n\n    // draw car lines\n    coord.x += .05*uScreen.x*sin(uv.y*20.0); // add a curve to the road\n\tvec2 p1 = vec2(uScreen.x/2.5,0.0);\n\tvec2 p0 = vec2(0,-uScreen.y/2.0);\n\tcolor += carlines(coord, p0, normalize(p1-p0), false);\n\tp0.x+=uScreen.x*.05;\n\tcolor += carlines(coord, p0, normalize(p1-p0), false);\n\tp0.x+=uScreen.x*.1;\n\tcolor += carlines(coord, p0, normalize(p1-p0), true);\n\tp0.x+=uScreen.x*.05;\n\tcolor += carlines(coord, p0, normalize(p1-p0), true);\n    \n    // reset coord value\n    coord.x = ocoord.x;\n    \n    // add a small wobble\n    uv.y += .01*sin(uv.x*20.0);    \n\t// small city lights\n\t{\n        // scale coordinates and generate sparkles\n\t\tvec3 citylights = sparkles(floor(coord/CITYLIGHTSFARSIZE)); \n        citylights*=CITYLIGHTSFARBRIGHTNESS; // Apply brightness\n\t\tcitylights*=clamp(1.0-pow((uv.y-.5)/.03,2.0),0.0,1.0); // Mask y\n\t\tcitylights*=1.0-coord.x/uScreen.x*2.0; // Mask x\n\t\tcolor += citylights;\n\t}\n\t// larger city lights\n\t{\n        // scale coordinates and generate sparkles\n\t\tvec3 citylights = sparkles(floor(coord/CITYLIGHTSCLOSESIZE));\n        citylights*=CITYLIGHTSCLOSEBRIGHTNESS; // Apply brightness\n\t\tcitylights*=clamp(1.0-pow((uv.y-.35)/.08,2.0),0.0,1.0); // mask y\n\t\tcitylights*=(.4-uv.x)*5.0; //mask x\n\t\tcolor += citylights;\n\t}\n    \n    //reset uvs\n    uv.y = ouv.y;\n    \n\t// Mountains and Sky\n    uv.y += -.03*cos(uv.x*6.28); //Curve doordinates\n\tif((uv.y>abs(mod(uv.x,.3)-.15)*.4+.65)\n\t\t&& (uv.y>abs(mod(uv.x,.11)-.055)*.4+.65+.025)){\n                float skymix =  (1.0-uv.y)/.35+hash(uv.x+uv.y)*.05;\n                color  = mix(SKYCOLORA,SKYCOLORB, skymix);\n                color += sparkles(floor(coord/STARSIZE))*mix(STARBRIGHTNESS, .0,skymix);\n\t}\n\n\tfragColor = vec4(color,0.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XlcSWS.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[334, 368, 391, 391, 433], [435, 482, 505, 505, 599], [601, 679, 718, 718, 772], [774, 924, 978, 978, 1043], [1045, 1130, 1182, 1182, 1350], [1352, 1415, 1442, 1442, 1610], [1612, 1646, 1701, 1817, 2680], [2681, 2681, 2738, 2738, 4747]], "test": "valid"}
{"id": "XlcSzM", "name": "Matroshka!", "author": "BigWIngs", "description": "Put fullscreen and see if you can find the easter egg ;) Please see comment block for details. ", "tags": ["raymarching", "russian", "matroshka", "doll"], "likes": 131, "viewed": 7524, "published": "Public", "date": "1481092343", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Matroshka! - 2016 Martijn Steinrucken - BigWings\n// Email:countfrolic@gmail.com Twitter:@The_ArtOfCode\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n// \n// This effect matches the music. In order for it to be in sync, its best to restart\n// the effect as soon as the music loads.\n//\n// Use the mouse to look around. Watch at least 30 seconds to see the whole effect!\n// \n// I tried to create a painted look. To make the flowers and leaves move use the PSYCO define.\n// A video of the effect can be found here:\n// https://www.youtube.com/watch?v=0kbZzVolycw\n\n// Because dolls are different sizes and they are leaning when they walk, \n// it can happen that we overstep into the next cell, causing gaps in the doll.\n// This is why, in the marching loop, I make sure to always start a new cell at the cell boundary.\n// Another way to fix this is to make the step size 0.6 x the doll distance but that obviously \n// makes the ray marching slower. I'm not sure which solution is faster because im at a steady\n// 60fps for both solutions on my machine. \n// Some better performance metrics would really help!\n//\n// I sunk way too much time into this, time to move on to something else! I hope you like it!\n//\n// SONG: Skorge - Tetris Theme\n// https://soundcloud.com/officialskorge/skorge-tetris-theme\n\n// Use these to change the effect\n\n\n//#define PSYCO\n//#define TEXTUREMODE\n#define INVERTMOUSE 1.\n#define MAX_STEPS 150\n#define MIN_DISTANCE 0.1\n#define MAX_DISTANCE 100.\n#define RAY_PRECISION 0.002\n\n#define S(x,y,z) smoothstep(x,y,z)\n#define B(x,y,z,w) S(x-z, x+z, w)*S(y+z, y-z, w)\n#define sat(x) clamp(x,0.,1.)\n#define SIN(x) (sin(x)*.5+.5)\n#define COS(x) (cos(x)*.5+.5)\n\nfloat X2(float x) { return x*x; }\n\nvec3 mainCol = vec3(1.0, .2, .1);\t\t// the main color\nvec3 lastCol = vec3(.1,.3, .1);\t\t\t// the last main color\nvec3 secCol = vec3(.8, .6, .1);\t\t\t// the secondary color\nvec3 lineCol = vec3(1.1);\t\t\t\t// the line color\n\nvec3 grid = vec3(5., 10., 5.);\t\t\t// grid of marching dolls\nvec4 stones = vec4(.2, .3, .5, 2.);\t\t// controls size and shape of stones\n\nfloat SOLO;\t\t\t\t\t\t\t\t// wether we are in solo mode or not\t\n\nconst vec3 light = vec3(1., 1., 1.)*.577; \nconst vec3 lf=vec3(1., 0., 0.);\nconst vec3 up=vec3(0., 1., 0.);\nconst vec3 fw=vec3(0., 0., 1.);\nconst float pi2 = 1.570796326794896619;\nconst float pi = 3.141592653589793238;\nconst float twopi = 6.283185307179586;\n\nvec2 mouse;\nvec3 bg; // global background color\n\nfloat time;\n\nfloat remap01(float a, float b, float t) {return (t-a)/(b-a);}\nfloat L2(vec3 p) {return dot(p, p);}\nfloat L2(vec2 p) {return dot(p, p);}\n\nfloat N1( float x ) { return fract(sin(x)*5346.1764); }\nfloat N2(vec2 p)\n{\t// Dave Hoskins - https://www.shadertoy.com/view/4djSRW\n\tvec3 p3  = fract(vec3(p.xyx) * vec3(443.897, 441.423, 437.195));\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\nfloat N2(float x, float y) { return N2(vec2(x, y)); }\n\nvec3 N31(float p)\t\t\n{\t\n   vec3 p3 = fract(vec3(p) * vec3(443.897, 441.423, 437.195));\n   p3 += dot(p3, p3.yzx+19.19);\n   return fract((p3.xxy+p3.yzz)*p3.zyx); \n}\n\nvec2 N21(float p)\n{\n\tvec2 p2 = fract(vec2(p) * vec2(443.897, 441.423));\n\tp2 += dot(p2, p2.yx + 19.19);\n    return fract((p2.xx+p2.yx)*p2.yy);\n\n}\n\nfloat Noise(vec2 uv) {\n    // noise function I came up with\n    // ... doesn't look exactly the same as what i've seen elswhere\n    // .. seems to work though :)\n    vec2 id = floor(uv);\n    vec2 m = fract(uv);\n    m = 3.*m*m - 2.*m*m*m;\n    \n    float top = mix(N2(id.x, id.y), N2(id.x+1., id.y), m.x);\n    float bot = mix(N2(id.x, id.y+1.), N2(id.x+1., id.y+1.), m.x);\n    \n    return mix(top, bot, m.y);\n}\n\nfloat NoiseTex(vec2 uv, float seed, float octaves) {\n    float v=0.;\n    uv += N21(seed);\n    \n    for(float i=1.; i<=11.; i++) {\n    \tv += Noise(uv)/i;\n        uv *= 2.;\n        \n        if(i>octaves) break;\n    }\n    \n    return v*.5;\n}\n\n\nstruct ray {\n    vec3 o;\n    vec3 d;\n};\n\nstruct camera {\n    vec3 p;\t\t\t// the position of the camera\n    vec3 forward;\t// the camera forward vector\n    vec3 left;\t\t// the camera left vector\n    vec3 up;\t\t// the camera up vector\n\t\n    vec3 center;\t// the center of the screen, in world coords\n    vec3 i;\t\t\t// where the current ray intersects the screen, in world coords\n    ray ray;\t\t// the current ray: from cam pos, through current uv projected on screen\n    vec3 lookAt;\t// the lookat point\n    float zoom;\t\t// the zoom factor\n};\ncamera cam;\n\n\nvoid CameraSetup(vec2 uv, vec3 position, vec3 lookAt, float zoom) {\n    cam.p = position;\n    cam.lookAt = lookAt;\n    cam.forward = normalize(cam.lookAt-cam.p);\n    cam.left = cross(up, cam.forward);\n    cam.up = cross(cam.forward, cam.left);\n    cam.zoom = zoom;\n    cam.center = cam.p+cam.forward*cam.zoom;\n    cam.i = cam.center+cam.left*uv.x+cam.up*uv.y;\n    cam.ray.o = cam.p;\t\t\t\t\t\t// ray origin = camera position\n    cam.ray.d = normalize(cam.i-cam.p);\t// ray direction is the vector from the cam pos through the point on the imaginary screen\n}\n\n\n// DE functions from IQ\n// https://www.shadertoy.com/view/Xds3zN\n\nfloat smin( float a, float b, float k )\n{\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\nfloat smax( float a, float b, float k )\n{\n\tfloat h = clamp( 0.5 + 0.5*(b-a)/k, 0.0, 1.0 );\n\treturn mix( a, b, h ) + k*h*(1.0-h);\n}\n\nfloat sdSphere( vec3 p, vec3 pos, float s ) { return length(p-pos)-s; }\n\nfloat sSph( vec3 p, vec3 scale, float s )\n{\n    return (length(p/scale)-s)*min(scale.x, min(scale.y, scale.z));\n}\n\nfloat sdCappedCylinder( vec3 p, vec2 h )\n{\n  vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nmat3 RotY(float angle) {\n\tfloat s = sin(angle);\n    float c = cos(angle);\n    \n    return mat3(c, 0., s,  0., 1., 0.,  -s, 0., c);\n}\n\n\nmat3 RotZ(float angle) {\n\tfloat s = sin(angle);\n    float c = cos(angle);    \n    \n    return mat3(c, -s, 0.,  s, c, 0.,  0., 0., 1.);\n}\n\nstruct de {\n    // data type used to pass the various bits of information used to shade a de object\n\tfloat d;\t// distance to the object\n   \tvec4 p;\t\t// local coordinate pos (xyz)\n    float m; \t// material\n    vec2 uv;\t// uv coordinates\n    vec3 id;\n    \n    float t; // transition between inside and outside\n    float open; \t// how far open the split matroshkas are\n    float inside;\t// wether its the inside matroshka. This whole struct is a mess... oww well\n    float seed;\t// seed used to generate random values\n    \n    \n    // shading parameters\n    vec3 pos;\t\t// the world-space coordinate of the fragment\n    vec3 nor;\t\t// the world-space normal of the fragment\n    vec3 rd;\t\t// the world-space view dir of the fragment\n    float fresnel;\t\n};\n    \nstruct rc {\n    // data type used to handle a repeated coordinate\n\tvec3 id;\t// holds the floor'ed coordinate of each cell. Used to identify the cell.\n    vec3 h;\t\t// half of the size of the cell\n    vec3 p;\t\t// the repeated coordinate\n};\n    \nrc Repeat(vec3 pos, vec3 size) {\n\trc o;\n    o.h = size*.5;\t\t\t\t\t\n    o.id = floor(pos/size);\t\t\t// used to give a unique id to each cell\n    o.p = mod(pos, size)-o.h;\n    return o;\n}\n\n\nvec2 PolarCoords(vec2 uv) {\n\t// carthesian coords in polar coords out\n    return vec2(atan(uv.x, uv.y), length(uv));\n}\n\nvec2 SpiralCoords(vec2 st, float turns) {\n\t// polar coords in... spiral coords out. Spiral coordinates are neat!\n    st.x = st.x/twopi +.5;\n    st.y *= turns;\n    float s = st.y+st.x;\n    float l = (floor(s)-st.x);\n    float d = fract(s);\n    return vec2(l, d);\n}\n\n\nfloat circ(vec2 uv, float x, float y, float aspect, float radius, float edge) {\n\tvec2 p = uv-vec2(x, y);\n    p.x *= aspect;\n    \n    edge *= .02;\n    radius *= radius;\t\t\t\t\t\t\t\t// comparing to r^2 to avoid sqrt\n    return S(radius+edge, radius-edge, dot(p, p));\t// not sure if thats actually faster\n}\n\nfloat circ(inout vec4 base, vec2 uv, float x, float y, float aspect, float radius, float edge, vec3 col) {\n    float alpha = circ(uv, x, y, aspect, radius, edge);\n    base = mix(base, vec4(col, 1.), alpha);\n    return alpha;\n}\n\nfloat square(vec2 uv, vec4 rect, float blur) {\n\t// returns 1 when uv is inside the square, 0 otherwise\n    return B(rect.x, rect.z, blur, uv.x) * B(rect.y, rect.w, blur, uv.y);\n}\n\nvec2 within(vec2 uv, vec4 rect) {\n\t// converts a uv from a global coordinate to a rect coordinate\n    return (uv.xy-rect.xy)/(rect.zw-rect.xy);\n}\n\nfloat TowerMask(vec2 uv, float blur) {\n    uv.x = abs(uv.x-.5);\n    \n    float y = uv.y * 2.5;\n    \n    float c = exp(-y*y)*pow(sat(y), .6)*.8;\n    c = S(c, c-blur, uv.x);\n    \n    float width = mix(.15, .35, S(-.3, -.6, uv.y));\n    float tower = width+uv.y*uv.y*.05;\n    \n    tower = S(tower+.01+blur, tower, uv.x);\n    tower *= S(0.5, 0.2, uv.y);\n    \n    c = max(c, tower);\n    return c;\n}\n\nfloat Kremlin(vec2 uv) {\n    float c = TowerMask(within(uv, vec4(0.35, 0.7,.63,1.1)), .1);\n    c += TowerMask(within(uv, vec4(0.15, 0.5,.43,.8)), .1);\n    c += TowerMask(within(uv, vec4(0.65, 0.5,.83,.8)), .1);\n    c += TowerMask(within(uv, vec4(0.525, 0.3,.72,.8)), .1);\n    c += TowerMask(within(uv, vec4(0.025, 0.25,.22,.6)), .1);\n    c += TowerMask(within(uv, vec4(0.8, 0.25,.95,.5)), .15);\n    c = sat(c);\n    c *= S(.0, .4, uv.y);\n    return c;\n}\n\nvec3 background(vec3 r, vec2 uv, float starBurst) {\n    float u = dot(r, up)*.5+.5;\n    vec3 upCol = vec3(1., .4, .1);\n    vec3 col;\n    \n    float t = iTime*4.;\t\t\t\n    \n    if(SOLO>.5){\t\t\t\t\t\t\t\t\t\t// splitting shells\t\n        float colFade = S(.0, .1, fract(time));\n        upCol = mix(lastCol, mainCol, colFade)*2.5;\t\t// make the background match the doll color\n    \tcol = mix(upCol*.05, upCol, u);\n        \n    \tvec2 st = PolarCoords(uv);\n        \n        starBurst *= sat(sin(st.x*3.+t)) + sat(sin(st.x*4.+t*.7654));\t// add starburst \n        col += starBurst*.5*B(.3, .7, .2, u);\n        \n        col *= col;\n    } else {\t\t\t\t\t\t\t\t\t\t\t// marching bg\n        float x = atan(r.x, r.z);\t\t\t\t\t\t// from -pi to pi\t\n\t\tfloat y = pi*0.5-acos(r.y);  \t\t\t\t\t// from -1/2pi to 1/2pi\t\t\n        \n        col = upCol*u*2.;\n        float a = sin(r.x);\n    \n        float beam = sat(sin(10.*x+a*y*5.+t));\t\t\t// add light beams\n        beam *= sat(sin(7.*x+a*y*3.5-t));\n        float beam2 = sat(sin(42.*x+a*y*21.-t));\n        beam2 *= sat(sin(34.*x+a*y*17.+t));\n        beam += beam2;\n        col *= 1.+beam*.1;\n        \n        col += dot(r, fw);\t\t\t\t\t\t\t\t// light gradient from front\n        \n        vec4 r = vec4(-.3, .0, .3, .4);\t\t\t\t\t// add kremlin!\n        if(x>r.x && x<r.z && y>r.y && y<r.w) {\n            col *= 1.-Kremlin(within(vec2(x, y), r))*.3;\n        }\n    }\n    return col;\n}\n\nvec4 Eyes(vec2 uv, float seed) {\n    \n    if(uv.x<.5) {\t\t\t\t\t\t\t\t// add seductive wink ;)\n    \tfloat a = pow(SIN(time*2.), 700.)*4.;\n    \tuv.y = (uv.y-.5)*(1.+a) + .5;\n    }\n    \n    vec3 n = N31(seed+675.75864);\n    vec3 green = vec3(.2, .6, .1);\n    vec3 blue = vec3(.3, .3, .9);\n    vec3 eyeCol = mix(green, blue, n.x)*(.7+n.y);\n    vec4 eyes = vec4(0.);\n    float ar = 2.3;\n    float blur = .5;\n    float size = .2;\n    \n    vec2 lp = vec2(.35, .5);\n    vec2 rp = vec2(.65, .5);\n    \n    vec2 glint = vec2(.05);\n    vec2 pupil = SOLO*(mouse-.5)*vec2(-.3, .3); \t\t// make her looking at you (SOLO mode only)\n    \n    float eyeMask = circ( eyes, uv, lp.x, lp.y, ar, size, blur, eyeCol);\n\teyeMask += circ( eyes, uv, rp.x, rp.y, ar, size, blur, eyeCol);\n    \n    circ(eyes, uv, lp.x+pupil.x, lp.y-pupil.y, ar, size*.6, blur, vec3(.1)); //pupil\n    circ(eyes, uv, lp.x-glint.x, lp.y+glint.y, ar, size*.5, blur*.5, vec3(1.)); //glint\n    \n    circ(eyes, uv, rp.x+pupil.x, rp.y-pupil.y, ar, size*.6, blur, vec3(.1)); //pupil\n    circ(eyes, uv, rp.x-glint.x, rp.y+glint.y, ar, size*.5, blur*.5, vec3(1.)); //glint\n    \n    eyes.a = eyeMask;\n    \n    vec2 uv2 = vec2(.5-abs(uv.x-.5), uv.y);\n    \n    float eyeLine = circ(uv2, lp.x-.02, lp.y+.05, ar*.8, size*1.05, blur);\n    eyeLine -= circ(uv2, lp.x-.02, lp.y-.03, ar*.8, size*1.05, blur);\n    eyeLine = sat(eyeLine);\n    eyes = mix(eyes, vec4(0.,0.,0.,1.), eyeLine);\n   \n    vec2 lash = vec2(lp.x-.15, lp.y+.27);\n    float eyeLash = circ(uv2, lash.x, lash.y, ar, size, blur);\n    eyeLash -= circ(uv2, lash.x+.005, lash.y+.05, ar, size, blur);\n    eyeLash = sat(eyeLash);\n    eyes = mix(eyes, vec4(0.,0.,0.,1.), eyeLash);\n    \n    lash += vec2(.1, .1);\n    ar =3.;\n    eyeLash = circ(uv2, lash.x, lash.y, ar, size, blur);\n    eyeLash -= circ(uv2, lash.x+.005, lash.y+.05, ar, size, blur);\n    eyeLash = sat(eyeLash);\n    eyes = mix(eyes, vec4(0.,0.,0.,1.), eyeLash);\n    \n    return eyes;\n}\n\nvec4 Mouth(vec2 uv, float seed) {\n\t\n    float smile = .3;//sin(iTime)*.5;;\n    \n    vec4 lipUpCol = vec4(1., .1, .1, 1.);\n    vec4 insideCol =  vec4(1., 1., 1., 1.);\n    \n    uv.y -= .5;\n    uv.x = abs(uv.x*2.-1.);\t// mirror in the middle\n    \n    uv *= 1.5;\n    \n    float upMid = .5-pow((uv.x-.25)*2., 2.);\n    float upSide = pow(1.-uv.x, .5)*.25;\n    float upper = smax(upMid, upSide, .2);\n    \n    float lowMid = uv.x*uv.x-.5;\n    float lowSide = sqrt(1.-uv.x)/-5.;\n    \n    float lower = smin(lowMid, lowSide, .2);\n    \n    float curve = uv.x*uv.x*smile;\n    \n    vec4 col = lipUpCol*B(lower+curve, upper+curve,.05, uv.y);\n    col = mix(col, insideCol, circ(uv, 0., curve, .2, .1, .1));\n    \n    return col;\n}\n\nvec4 Hair(vec2 uv, float seed) {\n    vec3 n = N31(seed - 845.32);\n    vec3 hair1Col = vec3(.4, .25, .15);\n    vec3 blond = vec3(1.8, 1.7, .2);\n    vec3 brunette = vec3(.8, .5, .3);\n    \n    vec3 hair2Col = mix(blond, brunette, n.x);\n    hair1Col = hair2Col *.5;\n    \n\tvec4 col = vec4(0.);\n    \n    if(n.y>.5) {\t\t\t\t\t\t\t\t\t\t\t// hair style 1\n        circ(col, uv, .8, .55, 3.5, .6, .5, hair1Col);\n        circ(col, uv, .8, .6, 3.5, .54, .5, hair2Col);\n\n        circ(col, uv, .55, .6, 3.5, .6, .5, hair1Col);\n        circ(col, uv, .55, .63, 3.5, .54, .5, hair2Col);\n\n        circ(col, uv, .4, .6, 3.5, .6, .5, hair1Col);\n        circ(col, uv, .41, .63, 3.3, .54, .5, hair2Col);\n\n        circ(col, uv, .25, .5, 3.5, .6, .5, hair1Col);\n        circ(col, uv, .26, .53, 3.3, .54, .5, hair2Col);\n    } else {\t\t\t\t\t\t\t\t\t\t\t\t// hair style 2\n        uv.x = abs(uv.x-.5);\n        float spread = n.y*2.*.09;\n        float d = length((uv-vec2(.2+spread, .9))*vec2(3., 1.));\n\n        col.rgb = hair1Col*(1.+sin(d*20.)*.5*n.z);\n        col.a=S(.9, .85, d);\n    }\n    \n    return col;\n}\n\nvec4 Face(vec2 uv, float seed) {\n    vec3 scarfCol = vec3(1., .9, .5);\n    vec3 faceCol = vec3(1., 1., .8);\n    vec3 lineCol = vec3(.1);\n   \n    vec4 col = vec4(0.);\n    \n    vec2 st = PolarCoords(uv-.5);\n    scarfCol += sin(st.x*5.)*.1;\n    circ(col, uv, .5, .5, 1.4, .5, .5, scarfCol); // scarf\n    float face = circ(col, uv, .5, .45, 1.3, .4, .04, faceCol);\t// face\n\n    vec2 uv2 = uv;\n    uv2.x = abs(uv.x-.5)+.5;\n\n    circ(col, uv2, .65, .27, 1.3, .06, .3, vec3(1., .7, .7)); //rouge\n    circ(col, uv2, .52, .29, 2., .02, .005, vec3(.1));\t\t// nostrils\n\n    vec4 eyeArea = vec4(.2, .31, .8, .55);\n    if(square(uv, eyeArea, .01)>0.) {\n        vec4 eyes = Eyes(within(uv, eyeArea), seed);\n        col = mix(col, eyes, eyes.a);\n    }\n\n    float eyeBrows = circ(uv2, .6, eyeArea.w-.03, .7, .06, .01); \n    eyeBrows -= circ(uv2, .6, eyeArea.w-.05, .7, .06, .01); \n    eyeBrows = sat(eyeBrows);\n    col = mix(col, vec4(lineCol, 1.), eyeBrows);\n\n    vec4 hairArea = vec4(.1, .6, .9, .9);\n    vec4 hair = Hair(within(uv, hairArea), seed); \n    hair.rgb *= .5;\n    col = mix(col, hair, hair.a*face);\n    \n    vec4 mouthArea = vec4(.35, .05, .65, .25);\n    float mouthMask = square(uv, mouthArea, .01);\n    if(mouthMask>0.) {\n    \tvec4 mouth = Mouth(within(uv, mouthArea), seed);\n    \tcol = mix(col, mouth, mouth.a);\n    }\n    \n    return col;\n}\n\nvec4 Scarf(vec2 uv, float seed) {\n    vec4 lCol = vec4(lineCol, 1.);\n    vec4 scarfCol = vec4(secCol, 1.);\n    \n    float lineThickness = .01;    \n    float x = uv.x*twopi;\n\tfloat scarfY = .25+COS(x)*-.15;\n    float scarfMask = S(scarfY, scarfY+.01, uv.y);\n    \n    scarfY -= lineThickness;\n    float lineMask = S(scarfY, scarfY+.01, uv.y);\n    vec4 col = mix(lCol*lineMask, scarfCol, scarfMask);\n    \n    float y;\n    \n    if(uv.y>scarfY && uv.y<scarfY+.2) {\t\t// scarf band\n        y = scarfY+.1;\n    \tcol = mix(col, lCol, B(y, .01+y, .005, uv.y));\n   \t\tx *= 10.;\n        \n        y = scarfY+.05+sin(x)*.04;\n        col = mix(col, lCol, B(y, .01+y, .01, uv.y));\n\n\t\tfloat d = length(vec2(fract(x/pi), (uv.y-scarfY)*10.)-vec2(.5, .6-sin(x)*.1));\n        col = mix(col, vec4(1.), S(.2, .14, d));\n    }\n    \n    vec2 mirrorUV = abs(uv-vec2(.5, -0.03));\n    vec2 st = PolarCoords(mirrorUV*vec2(2.2, 1.) - vec2(.32, .5));\n    vec2 sc;\n    if(st.y<.21) {\t\t\t\t\t\t// add spiral decoration on the side of the head...\n        st.y *= 2.2;\n        st.x += .4;\n    \tsc = SpiralCoords(st, 5.);\n    \tcol = mix(col, lCol, B(.3, .5, .05, sc.y)*S(1.15, 1., sc.x));\n    }\n    \n    st = PolarCoords(mirrorUV*vec2(2.2, 1.) - vec2(.532, .385));\n    if(st.y<.11) {\t\t\t\t\t\t// quite cumbersome.. there must be an easier way...\n        st.y *= 3.;\n        st.x += 3.4;\n        sc = SpiralCoords(st, 5.);\n    \tcol = mix(col, lCol, B(.3, .5, .05, sc.y)*S(1.2, 1.05, sc.x));\n    }\n    uv.x -= .5;\n    \n    vec2 tiePos = vec2(0., .3);\n    vec2 uv2 = uv - tiePos;\n    st = vec2(atan(uv2.x*3., uv2.y-.05), length(uv2));\n    \n    y = COS(st.x*4.+pi);\n    y = min(y, COS(st.x*4.+pi+.5));\n    \n    \n    float creases = mix(SIN(st.x*16.+pi), 1., sat(st.y*7.));\n    creases = S(.9, .1, creases);\n    y*=.2;\n    \n    col = mix(col, lCol, S(.02+y, .01+y, st.y));\n    col = mix(col, vec4(scarfCol.rgb, 1.), S(.005+y, .0+y, st.y));\n    col = mix(col, lCol, creases);\n    \n    circ(col, uv, tiePos.x, tiePos.y, 4., .1, .05, lineCol.rgb);\n    circ(col, uv, tiePos.x, tiePos.y, 4., .085, .05, scarfCol.rgb); \n    \n    return col;\n}\n\nfloat PointFlower(vec2 st, float numPoints, float base, float pointiness) {\n\tst.y *= 4.;\n    float x = st.x*numPoints;\n    float y = pointiness*(abs(cos(x))+(.25-abs(cos(x+pi2)))*2.)/(2.+abs(cos(x*2.+pi2))*8.)-base;\n    return st.y+y;\n}\n\nvec4 Flower(vec2 uv, vec4 pf, vec4 baseCol, vec4 lineCol) {\n    vec2 st = PolarCoords(uv-.5);\n    \n    #ifdef PSYCO\n    st.x += sin(st.y*10.)*sin(iTime);\n    #else\n    st.x += sin(st.y*10.)*.2;\n    #endif\n    \n    float dist = PointFlower(st, pf.x, pf.y, pf.z);//3., .4, .4);\n    float alpha = S(.5, .4, dist);\n    \n    baseCol.rgb *= S(.0, .15, st.y);\n    vec4 col = baseCol*alpha;\n    \n    float edge = S(.2, .5, dist)*alpha;\n    col = mix(col, lineCol, edge);\t\t\t// dark painted edge\n   \n    float highlight = SIN(st.x*pf.w);\n    highlight *= B(.0, .3, .1, dist);\n    highlight *= SIN(st.x);\n    col = mix(col, vec4(1.), highlight);\t\t\t// highlight\n        \n    col = mix(col, vec4(1.), S(.06, .05, st.y));  \n    \n    return col;\n}\n\nvec4 Leaf(vec2 uv, float stemHeight, float sweep ) {\n    // uv is in 0-1 range\n    \n    uv.y += sweep*uv.x*uv.x;\n    vec2 uv2 = (uv-vec2(.22, .5)) * vec2(4., 3.); \n    \n    float side = sign(uv2.y);\n    float ay = abs(uv2.y);\n    \n    float start = sqrt(uv2.x);\n    float end = 1.-pow(uv2.x/3., 2.);\n    float y = smin(start, end, 0.4);\n    \n    float offs = pow(abs(ay-mix(.75, -.0, uv2.x))*4., 2.);\n    float veins = sin(uv2.x*30.-offs+side);\n    \n    y *= 1.+veins*.07;\n    \n    float s = S(y+.04, y, ay);\n    vec4 leafCol = vec4(.2, .5, .1, s);\n    \n    s *= 1.+veins*.2*B(.3, 2.4, .3, uv2.x)*S(.02, .3, ay);\n    s *= mix(.2, 1., ay);\n    \n    leafCol.rgb = (leafCol.rgb+S(-.2, .2, uv2.y)*.35)*s;\n    \n    s = S(.0, .23, uv.x);\n    float h = mix(stemHeight, .5, s);\n    float t = mix(.02, .01, s);\n    t *= S(.5, .15, uv.x);\n    t *= S(.15, .4, uv.x);\n    float stemMask = B(h-t, h+t, .01, uv.y);\n    stemMask *= S(.95, .23, uv.x);\n    leafCol = mix(leafCol, vec4(.2,.5,.1,1.), stemMask);\n    \n    return leafCol;\n}\n\nvec4 RoseTex(vec2 uv, vec3 n) {\n    vec4 flowerCol = vec4(n*n, 1.);\t\t\t\t\t\t// flower col is just a more saturated version of main col\n  \tvec4 lCol = vec4(lineCol, 1.);\n    \n    vec2 uv2 = uv;\n    \n    if(uv.x>.5) {\t\t\t\t\t\t\t\t\t\t// mirror and flip half of the texture\n    \tuv.x = uv.x-.5;\n        uv.y = 1.-uv.y;\n    }\n    \n    float y = sin(uv.x*twopi)*.1;\t\t\t\t\t\t// add a wavy vine down the middle\n    float vine = B(.495+y, .505+y, .01, uv.y);\n    \n    vec2 p1 = uv-vec2(.27, .4);\t\t\t\t\t\t\t// add spiral shaped vines\n    vec2 st = PolarCoords(p1);\n    vec2 sc = SpiralCoords(st, 5.);\n    vine += B(.48, .52, .02, sc.y)*S(.7, .4, sc.x);\n    \n    vec4 col = vec4(.1, .5, .1, 1.)*vine;\t\t\t\t// add vine\n    \n    vec2 lc = uv*4.-vec2(1.5, 1.7);\n    \n    float sweep = .2;\n    #ifdef PSYCO\n    sweep = sin(iTime*.5)*.5;\n    #endif\n    \n    vec4 leaf = Leaf(lc, .5, sweep);\n    \n    col = mix(col, leaf, leaf.a);\n    lc.x +=2.;\n    lc.y = 1.-lc.y-.4;\n    leaf = Leaf(lc, .5, sweep);\n    col = mix(col, leaf, leaf.a);\n    \n    vec2 fc = sc;\n    fc.x = fract(fc.x*10.);\n    fc.x = (fc.x-.5)*.5+.5;\n    vec4 smallFlower = Flower(fc, vec4(2.5, .4, .3, 5.), flowerCol, lCol);\n    smallFlower.a *= B(.1, .4, .01, sc.x);\n    col = mix(col, smallFlower, smallFlower.a);\n    \n    vec4 rect = vec4(0., .3, .5, .9);\n    vec4 flower = Flower(within(uv, rect), vec4(3., .4, .4, 30.), flowerCol, lCol);\n    col = mix(col, flower, flower.a);\n    \n    return col;\n}\n\nvec3 MatroshkaTex(de o) {\n    vec3 n = N31(o.seed);\n    vec3 col = mainCol;\n\t\n    lineCol *= max(.1, S(.8, .9, n.x));\n\n    vec4 faceArea = vec4(.35, .65, .65, .95);\n    \n    if(o.uv.y>faceArea.y-.2) {\n        vec2 scarfUv = within(o.uv, vec4(0., faceArea.y-.2, 1., 1.));\n        vec4 scarf = Scarf(scarfUv, o.seed);\n        col = mix(col, scarf.rgb, scarf.a);\n    }\n    \n    if(o.uv.y<faceArea.y) {\n    \tvec4 body = RoseTex(fract(o.uv+vec2(.4,.2)), n);\n    \tcol = mix(col, body.rgb, body.a);\n    }\n    \n    float faceMask = square(o.uv, faceArea, .001);\n    if(faceMask>0.) {\n\t\tvec4 face = Face(within(o.uv, faceArea), o.seed);\n        col = mix(col, face.rgb, face.a);\n    }\n    \n    return col;\n\n}\n\nfloat MatroshkaDist(vec3 p) {\t    \n    float head = sSph(p-vec3(0., 2.4, 0.), vec3(.9,  .8, .9), .7);\n    float body = sSph(p-vec3(0., 1., 0.), vec3(.95, 1.48, .95), .9);\n\n    float d = smin(head, body, .4);\t\t// merge head and body\n    d = smax(d, -p.y, .05);\t\t\t\t// flatten bottom\n    \n    float y = remap01(0., 2.96, p.y);\n    d += sin(y*100.)*.001;\n    d += B(.3985, .40, .003, y)*.001;\t// groove where the top and bottom half meet\n    \n    return d;\n}\n\nvec2 MatroshkaTop(vec3 p) {\t\t\t\t\t\t\t\t\t\t\t\t\t// returns distance to top half of doll (x) as well as inside or outside (y)\n\tfloat d = MatroshkaDist(p);\t\t\t\t\t\t\t\t\t\t\t\t// get normal (closed) doll dist first\n    float outside = d;\t\t\t\t\t\t\t\t\t\t\t\t\t\t// save outside doll dist\n    d = smax(d, -sdSphere(p, vec3(0., 0.6, 0.), 1.), .05);\t\t\t\t\t// take away bottom half of doll\n    d = smax(d, -sSph(p-vec3(0., 1., 0.), vec3(.7, 1.4, .7), .95), 0.02);\t// hollow out top half\n    float t = S(-.005, -.01, outside-d);\t\t\t\t\t\t\t\t\t// calculate wether outside or inside of doll (used for shading)\n    return vec2(d, t);\n}\n\nvec2 MatroshkaBottom(vec3 p) {\t\t\t\t\t\t\t\t\t\t\t\t// returns distance to bottom half of doll (x) as well as inside or outside (y)\n    float d = MatroshkaDist(p);\t\t\t\t\t\t\t\t\t\t\t\t// get normal (closed) doll dist first\n    float outside = d;\t\t\t\t\t\t\t\t\t\t\t\t\t\t// save outside doll dist\n    d = smax(d, -sdSphere(p, vec3(0., 3.0, 0.), 2.), .03);\t\t\t\t\t// take away top half\n    d = min(d, sdCappedCylinder(p-vec3(0.,1.,0.), vec2(.8, .25)));\t\t\t// add extra ridge\n    d = smax(d, -sSph(p-vec3(0., 1.15, 0.), vec3(.7, 1., .7), 1.1), 0.02);\t// hollow out bottom part\n    float t = S(.005, .01, d-outside);\t\t\t\t\t\t\t\t\t\t// calculate wether outside or inside of doll (used for shading)\n    return vec2(d, t);\n}\n\n\nvec2 GetStoneTiles(vec3 p) {\n    return vec2(p.x+sin(p.z*stones.x), p.z+sin(p.x*stones.y)*stones.z)*stones.w;\n}\n\nfloat Ground(vec3 p) {\n    float d = p.y;\n    vec2 tiles = GetStoneTiles(p);;\n    vec2 id = floor(tiles);\n    float bump = N2(id.x, id.y);\n\n    vec2 tUv = tiles*pi;\n    float tileMask = abs( sin(tUv.x)*sin(tUv.y) );\t// make a mask that fades to 0 on the edges\n    tileMask = 1.-pow(1.-tileMask, 8.);\n    d -= tileMask*.1*bump;\n \n    vec3 n = N31(id.x+id.y*165.32);\t\t\t\t// add surface detail\n    float detail = sin(n.x*p.x*15.)*sin(n.y*p.z*15.)*.05;\n    detail += sin(n.z*p.x*p.z*5.)*.005;\n    d += detail;\t\t\t\t\t\n   \n    return d;\n}\n\nvec3 SplitMatroshkaDist(vec3 p, float open, float size) {\n\t// returns distance and id to splitting matroshkas\n    // x = distance, y = material, z = transition\n    \n    float dBaby = MatroshkaDist(p*size)/size;\n    vec2 bottom = MatroshkaBottom(p+vec3(0., open, 0.));\n    vec2 top = MatroshkaTop(p-vec3(0., open, 0.));\n\n    float dShell = min(bottom.x, top.x);\n    \n    vec3 m = vec3(0.);\n    if(dBaby < dShell)\n        m = vec3(dBaby, 0., 0.);\n    else if(bottom.x<top.x)\n        m = vec3(bottom.x, 1., bottom.y);\n    else\n        m = vec3(top.x, -1., top.y);\n        \n    return m;\n}\n\n\nde castRay( ray r ) {\n    float dO=MIN_DISTANCE;\t\t\t\t\t\t\t// the distance from the camera\n    float dS=MAX_DISTANCE;\t\t\t\t\t\t\t// the distance from the surface\n    float t;\t\t\t\t\t\t\t\t\t\t// used to keep track of time\n    vec3 p=vec3(0.);\t\t\t\t\t\t\t\t// local position (after repeat, resize etc)\n\t\n    de o;\n    o.m = -1.;\n    \n    if(SOLO<.5) {\t\t\t\t\t\t\t\t\t// we are in marching mode (as in marching matroshkas, not ray marching ;))\n        // Dolls ...\n        t = iTime*.96;\t\t\t\t\t\t// try to match to the beat of the music\n        \n        rc q;\t\t\t\t\t\t\t\t\t\t// holds the repeated coordinate\n        float pt = t*pi;\t\t\t\t\t\t\t// 'polar' time\n        float s = sin(pt*5.);\n        float shuffle = s*.1 + t;\t\t\t\t\t// used to move dolls forward\n        float headBounce = s*.05 + 1.05;\t\t\t// used to scale height periodically\n        s = sin(pt*2.5);\n        mat3 leftRight = RotY(s*.2) * RotZ(s*.1);\t// used to make the doll lean left and right\n        \n        for( int i=0; i<MAX_STEPS; i++ )\n        {\n            p = r.o + r.d * dO;\t\t\t\t\t\t// Ray march\n            vec3 P=p;\n            p.z -= shuffle;\t\t\t\t\t\t\t// move forward\n            q = Repeat(p, grid);    \t\t\t\t// make a grid of them\n            p.xz = q.p.xz;\t\t\t\t\t\t\t// keep only ground layer\n            p.y *= headBounce;\t\t\t\t\t\t// make them bounce up and down\n            p *= leftRight; \t\t\t\t\t\t// make them sway left-right\n            float si = fract((q.id.x+q.id.z+5.)/5.);// make them different sizes\n            s = .8 + si;\t\t\t\t\t\t\t// .8 < s < 1.8\n            p*=s;\t\t\t\t\t\t\t\t\t\n            \n            dS = MatroshkaDist(p)/s;\t\t\t\t// calculate distance to doll\n            \n            vec3 rC = ((2.*step(0., r.d)-1.)*q.h-q.p)/r.d;\t// ray to cell boundary\n            float dC = min(min(rC.x, rC.y), rC.z)+.01;\t\t// distance to cell just past boundary\n            dS = min(dS, dC);\t\t\t\t\t\t\t\t// if cell boundary is closer than just set to the beginning of the next cell\n            \n            dO += dS;\t\t\t\t\t\t\t\t// add the distance from the surface to the distance from the camera\n            if( dS<RAY_PRECISION || \t\t\t\t// if we hit, \n               dO>MAX_DISTANCE  ||\t \t\t\t\t// or we are past far clipping..\t\n               (r.d.y>0. && p.y>6.5) ||\t\t\t\t// or if we are looking up and the ray is already above all of them..\n               (p.y<.0 && r.d.y<=0.)) \t\t\t\t// or if we are looking down and the ray is already below the ground\n               break;\t\t\t\t\t\t\t\t// break out of the loop \n        }\n\t\t\n        if(dS<=RAY_PRECISION) {\t\t\t\t\t\t\t// if we got really close to the surface, we count it as a hit\n            o.m=2.;\t\t\t\t\t\t\t\t\t// set material id so we know later on how to shade this\n            o.d=dO;\t\t\t\t\t\t\t\t\t// set distance from the camera\n            o.p.xyz=p;\t\t\t\t\t\t\t\t\t// save local coordinate (coordinate inside of the grid cell)\n            o.p.w = s;\n            o.seed = q.id.z + floor((q.id.x+q.id.z+5.)/10.)*100.;\n        } else if(r.d.y<0. && o.m<0.) {\t\t\t\t// only consider ground if we are looking down and nothing was hit yet\n            // Ground ...\n            dO = -((r.o.y-.08)/r.d.y);\t\t\t\t// fast forward by doing a ray-plane intersection first\n            \n            for( int i=0; i<MAX_STEPS; i++ )\n            {\n                p.xyz = r.o + r.d * dO;\t\t\t\t// ray march\n                dS = Ground( p.xyz );\t\t\t\t// get distance to ground\n                dO += dS;\t\t\t\t\t\t\t// add distance from the surface to the distance from the camera\n                if( dS<RAY_PRECISION || \t\t\t// if we hit \n                   dO>MAX_DISTANCE ) \t\t\t\t// or if we are past far clipping\n                    break;\t\t\t\t\t\t\t// break out of the loop\n            }\n\n            if(dS<=RAY_PRECISION) {\t\t\t\t\t// if we got really close to the surface, we count it as a hit\n                o.m=1.;\n                o.d=dO;\n                \n                p.z -= shuffle;\t\t\t\t\t\t\t// move forward\n                q = Repeat(p, grid);    \t\t\t\t// make a grid of them\n                p.xz = q.p.xz;\t\t\t\t\t\t\t// keep only ground layer\n                p.y *= headBounce;\t\t\t\t\t\t// make them bounce up and down\n                p *= leftRight; \t\t\t\t\t\t// make them sway left-right\n                s = .8+fract((q.id.x+q.id.z+5.)/5.); \t// make them different sizes\n            \tp*=s;\n                o.p.xyz=p;\n            }\n        }\n    } else {\t\t\t\t\t\t\t\t\t\t// we are in solo mode\n    \tt = fract(time);\n        float open = (1.-X2(1.-t))*3.5;\t\t\t\t// how far the two shells are apart as a function of time\n        float size = mix(1.2, 1., t);\t\t\t\t// grow as it matures\n        vec3 m;\n        \n        for( int i=0; i<MAX_STEPS; i++ ) {\n       \t\tp = r.o + r.d * dO;\t\t\t\t\t\t// Ray march\n            m = SplitMatroshkaDist(p, open, size);\n            if( m.x<RAY_PRECISION || dO>MAX_DISTANCE ) break;\n            dO += m.x;\n        }\n        \n         if(m.x<=RAY_PRECISION) {\t\t\t\t\t\t// if we got really close to the surface, we count it as a hit\n             o.d=dO;\n             o.m=2.;\n             o.t = m.z;\n             \n             if(m.y==0.) {   \t\t\t\t\t\t// inside matroshka\t\n            \to.seed = floor(time+1.);\n            \to.p.xyz=p*size;\n                o.p.w = size;\n                o.open = open;\n                o.inside = 1.;\n             } else {\t\t\t\t\t\t\t\t// outside matroshka\n             \to.seed = floor(time);\n                o.p.xyz = p+vec3(0., m.y*open, 0.);\n                o.open = open;\n                o.p.w = 1.;\n                o.inside = 0.;\n             }\n         }      \n    }\n    \n    return o;\n}\n\nfloat SplitMatroshkaAO( de o, float dist ) {\n\tfloat occ = 0.0;\n    float sca = 1.0;\n    for( int i=0; i<5; i++ )\n    {\n        float hr = 0.01 + dist*float(i)/5.0;\n        vec3 aopos =  o.nor * hr + o.pos;\n        float dd = SplitMatroshkaDist( aopos, o.open, o.p.w ).x/o.p.w;\n        occ += -(dd-hr)*sca;\n        sca *= 0.35;\n    }\n    return sat( 1.0 - 3.0*occ );    \n}\n\nvec3 MatroshkaNormal( vec3 p )\n{\n\tvec3 eps = vec3( 0.001, 0.0, 0.0 );\n\tvec3 nor = vec3(\n\t    MatroshkaDist(p+eps.xyy) - MatroshkaDist(p-eps.xyy),\n\t    MatroshkaDist(p+eps.yxy) - MatroshkaDist(p-eps.yxy),\n\t    MatroshkaDist(p+eps.yyx) - MatroshkaDist(p-eps.yyx) );\n\treturn normalize(nor);\n}\n\nfloat GroundAO( de o, float dist ) {\n\tfloat occ = 0.0;\n    float sca = 1.0;\n    for( int i=0; i<5; i++ )\n    {\n        float hr = 0.01 + dist*float(i)/5.0;\n        vec3 aopos =  o.nor * hr + o.pos;\n        float dd = Ground( aopos );\n        occ += -(dd-hr)*sca;\n        sca *= 0.35;\n    }\n    return sat( 1.0 - 3.0*occ );    \n}\n\nvec3 GroundNormal( vec3 p )\n{\n\tvec3 eps = vec3( 0.001, 0.0, 0.0 );\n\tvec3 nor = vec3(\n\t    Ground(p+eps.xyy) - Ground(p-eps.xyy),\n\t    Ground(p+eps.yxy) - Ground(p-eps.yxy),\n\t    Ground(p+eps.yyx) - Ground(p-eps.yyx) );\n\treturn normalize(nor);\n}\n\n\n\nvec3 GroundMat(de o) {\n    vec2 p = o.pos.xz*3.;\n    vec2 noise = vec2( NoiseTex(p, 0., 5.), NoiseTex(p, 12., 5.));\n    vec3 col = vec3(1., .8, .8)*.5;\n\n    o.nor = GroundNormal(o.pos);\t\t\t\t\t// get normal\n\to.nor.xz += (noise-.5)*2.;\t\t\t\t\t\t// cheap, fake, normal perturb\n    o.nor = normalize(o.nor);\t\t\t\t\t\t// renormalize\n    \n    vec2 id = floor(GetStoneTiles(o.pos));\n    \n    col *= 1.+( N2(id) -.5)*.3;\t\t\t\t\t\t// vary color of stones\n    col *= GroundAO( o, 1. );\t\t\t\t\t\t// get ao in the cracks between stones\n    \n    // add fake shadows\n    o.p.z+=.1;\t\t\t\t\t\t\t\t\t\t// offset a little bit to account for the fact that light is coming from the fort\n    float dropShadow = S(.8, .4, length(o.p));\t\t// simple drop shadow right below the doll\n    o.p.z+=.6; o.p.x*=1.5;\t\t\t\t\t\t\t// second shadow is behind the doll and a bit elongated\t\n    float shadow = S(1.7, .5, length(o.p))*.75;\n    shadow = max(shadow, dropShadow);\t\t\t\t\n    col *= mix(1., .2, shadow);\t\t\t\t\t\t// add in both shadows\n    \n    vec3 r = reflect(o.rd, o.nor);\t\t\t\t\t// calculate reflect view vector\n    float spec = sat(dot(r, light));\n    spec = pow(spec, 2.);\n    col += spec*.1*(1.-shadow);\t\t\t\t\t// add specular, make sure its attenuated by the shadow and vary the reflection by stone\n    \n    return col;\n}\n\nvec3 MatroshkaMat(de o, vec2 uv) {\n\n    vec3 col = vec3(1.);\n    \n    o.uv = vec2(.5-atan(o.p.x, o.p.z)/twopi, remap01(0., 2.96, o.p.y));\n        \n    o.nor = MatroshkaNormal(o.p.xyz);\n    o.fresnel = 1.-dot(o.nor, -o.rd);\n    \n    mainCol = N31(o.seed);\t\t\t\t\t\t\t// generate main col\n    secCol = fract(mainCol*23476.76);\n    \n    col *= MatroshkaTex(o);\n\n    float dif = dot(light, o.nor);\n    col *= max(.4, mix(1., dif, .5));\t\t\t\t// ehh.. too much screwing around with things.. \n    col *= 1.+o.fresnel*.2;\n\n    vec3 r = reflect(o.rd, o.nor);\t\t\t\t\t// calculate reflected view ray\n    float spec = sat(dot(r, light));\t\t\t\t// calculate specular reflection\n    \n    float occ = 1.-S(.25, .0, o.pos.y);\t\t\t\t// fake occlusion when we get close to the ground\n    \n    vec3 ref = background(r, uv, 0.);\t\t\t\t// sample background in the direction of the reflection\n    ref *= X2(o.fresnel)*.5;\t\t\t\t\t\t// make sure reflection is strongest at grazing angles\n    ref += pow(spec, 8.)*.6;\t\t\t\t\t\t// add specular highlight\n   \n    float groove =  1.-B(.3985, .40, .003, o.uv.y);\t// groove where the top and bottom half meet\n       \n    if(SOLO>.5) {\n        float fakeAo = B(1.2-o.open, 1.2+o.open, .2, o.pos.y);\t// calc fake letterbox ao\n        \n        if(o.inside>.5) { \t\t\t\t\t\t\t\t\t\t// if this is the inside doll\n        \tcol *= fakeAo;\t\t\t\t\t\t\t\t\t\t// .. doll has a darker head when covered by shell\n        \tref *= X2(fakeAo);\t\t\t\t\t\t\t\t\t// .. also no bg ref when covered\n         \tcol += ref*groove;\t\t\t\t\t\t\t\t\t// add ref, but not where the center groove is\n        } else {\n            if( o.t>0. )  {\n            \tvec3 interior = vec3(1., 1., .8);  \n        \t\tinterior *= SplitMatroshkaAO(o, .5); \n            \tinterior *= mix(fakeAo, 1., o.open/3.5);\n            \tcol = mix(col, interior, o.t);\t\t\t\t\t// the inside has a different color\n            } else\n                col += ref*groove;\n            col = mix(col, bg, S(1.05, 3.15, o.open));\t// then fade it out..\n        }        \t\n    } else {\n        ref *= mix(occ, 1., SOLO);\t\t\t\t\t\t// only occlude close to ground when in marching mode\n        col += ref*groove;\t\t\t\t\t\t\t\t// add reflection to final color, no ref where groove is\n        col *= sat(occ+.7);\t\t\t\t\t\t\t// darken where it contacts the ground\n    }\n    \n   \n    return col;\n}\n\nvec4 render( ray camRay, vec2 uv ) {\n    // outputs a color\n    \n    vec3 col = vec3(0.);\n    de o = castRay(camRay);\n   \n    if(o.m>0.) {        \n        o.pos = camRay.o + o.d*camRay.d;\n    \to.rd = camRay.d;\n        \n        if( o.m==1. )\n            col = GroundMat(o);\n        else\n            col = MatroshkaMat(o, uv);\n    }\n    \n    col = mix(col, background(o.rd, uv, 0.), S(.0, 100., o.d));\n    \n    return vec4( col, o.m );\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 UV = (fragCoord.xy / iResolution.xy)-.5;\n    vec2 uv = UV;\n   \tuv.y *= iResolution.y/iResolution.x;\n    vec2 m = iMouse.xy/iResolution.xy;\n    if(m.x==0. && m.y==0.) m=vec2(.55, .45);\t// hack to get a decent starting cam. Anyone have a better solution for this?\n    mouse = m;\n  \n    vec3 col;\n    \n    float t = iTime;\n    time = iTime*.4;\n    \n    #ifdef TEXTUREMODE\n    \tuv = fragCoord.xy / iResolution.xy;\n    \t//col = RoseTex(uv+.5).rgb;\n    \tcol = vec3(Kremlin(uv));\n    \t//col = vec3(NoiseTex(uv, floor(t), 6.));\n    #else\n    \n    float turn = (.5+m.x)*twopi;\n\n    vec3 camPos;\n    float camDist=8.;\n    \n    float mt = fract(t/269.)*269.;\n    \n    SOLO = B(-1., 28.3, 0.01, mt);\n    SOLO += B(41.5, 54.8, 0.01, mt);\n    SOLO += B(81., 107., 0.01, mt);\n    SOLO += B(134., 161., 0.01, mt);\n    SOLO += B(227., 240., 0.01, mt);\n  \n    if(SOLO>.5) {\n        camPos = vec3(0., 1.5, 0.);\n        mainCol = N31(floor(time+1.));\n        lastCol = N31(floor(time));\n    } else {\n        camPos = vec3(0., 3.5, 0.);\n        turn += t*.1;\n    }\n\n    float camY = INVERTMOUSE*camDist*cos((m.y)*pi);\n    \n    vec3 pos = vec3(0., camY, camDist)*RotY(turn);\n   \t\n    CameraSetup(uv, camPos+pos, camPos, 1.);\n    \n    bg = background(cam.ray.d, uv, 1.);\n\n    vec4 info = render(cam.ray, uv);\n  \n    if(info.w==-1.) {\n        col = bg; \n    } else \n        col = info.rgb;\n    \n    #endif\n    \n    UV *= 1.1;\n    col *= 1.-dot(UV, UV);\t\t// add vignette\n    \n    fragColor = vec4(col, .1);\n}", "image_inputs": [{"id": "Md2GWR", "previewfilepath": "https://soundcloud.com/officialskorge/skorge-tetris-theme", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "https://soundcloud.com/officialskorge/skorge-tetris-theme", "ctype": "musicstream"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XlcSzM.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[1712, 1712, 1731, 1731, 1745], [2474, 2474, 2516, 2516, 2536], [2537, 2537, 2555, 2555, 2573], [2574, 2574, 2592, 2592, 2610], [2612, 2612, 2633, 2633, 2667], [2668, 2668, 2686, 2742, 2885], [2886, 2886, 2914, 2914, 2939], [2941, 2941, 2962, 2962, 3102], [3104, 3104, 3123, 3123, 3248], [3250, 3250, 3272, 3411, 3658], [3660, 3660, 3712, 3712, 3898], [4448, 4448, 4515, 4515, 4999], [5068, 5068, 5109, 5109, 5202], [5204, 5204, 5245, 5245, 5334], [5336, 5336, 5381, 5381, 5407], [5409, 5409, 5452, 5452, 5522], [5524, 5524, 5566, 5566, 5665], [5667, 5667, 5691, 5691, 5799], [5802, 5802, 5826, 5826, 5938], [6938, 6938, 6970, 6970, 7118], [7121, 7121, 7148, 7190, 7239], [7241, 7241, 7282, 7353, 7504], [7507, 7507, 7586, 7586, 7805], [7807, 7807, 7913, 7913, 8033], [8035, 8035, 8081, 8137, 8213], [8215, 8215, 8248, 8312, 8360], [8362, 8362, 8400, 8400, 8754], [8756, 8756, 8780, 8780, 9208], [9210, 9210, 9261, 9261, 10579], [10581, 10581, 10613, 10613, 12514], [12516, 12516, 12549, 12549, 13230], [13232, 13232, 13264, 13264, 14295], [14297, 14297, 14329, 14329, 15637], [15639, 15639, 15672, 15672, 17723], [17725, 17725, 17800, 17800, 17961], [17963, 17963, 18022, 18022, 18695], [18697, 18697, 18749, 18775, 19716], [19718, 19718, 19749, 19749, 21150], [21152, 21152, 21177, 21177, 21851], [21853, 21853, 21882, 21882, 22307], [22309, 22309, 22336, 22425, 22898], [22900, 22900, 22930, 23021, 23577], [23580, 23580, 23608, 23608, 23691], [23693, 23693, 23715, 23715, 24222], [24224, 24224, 24281, 24383, 24809], [24812, 24812, 24833, 24833, 30226], [30228, 30228, 30272, 30272, 30599], [30601, 30601, 30633, 30633, 30890], [30892, 30892, 30928, 30928, 31220], [31222, 31222, 31251, 31251, 31466], [31470, 31470, 31492, 31492, 32729], [32731, 32731, 32765, 32765, 34994], [34996, 34996, 35032, 35055, 35431], [35434, 35434, 35491, 35491, 36981]], "test": "valid"}
{"id": "XldSDf", "name": "Menger Sponge Designs 2", "author": "Yusef28", "description": "Menger Sponge Design 2", "tags": ["fractal", "menger", "sponge", "design"], "likes": 3, "viewed": 116, "published": "Public", "date": "1481905803", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n\nvec2 rot(vec2 uv,float a){\n\treturn vec2(uv.x*cos(a)-uv.y*sin(a),uv.y*cos(a)+uv.x*sin(a));\n}\n\nmat2 rot(float a)\n{\n    \n float si = sin(a);\n    float cs = cos(a);\n    \n    mat2 mat= mat2(cs, -si, si, cs);\n    return mat;\n}\n\nvec2 random2(vec2 st){\n    st = vec2( dot(st,vec2(127.1,311.7)),\n              dot(st,vec2(269.5,183.3)) );\n    return -1.0 + 2.0*fract(sin(st)*43758.5453123);\n}\n\n// Value Noise by Inigo Quilez - iq/2013\n// https://www.shadertoy.com/view/lsf3WH\nfloat oldnoise(vec2 st) {\n    vec2 i = floor(st);\n    vec2 f = fract(st);\n\n    vec2 u = f*f*(3.0-2.0*f);\n\n    return mix( mix( dot( random2(i + vec2(0.0,0.0) ), f - vec2(0.0,0.0) ), \n                     dot( random2(i + vec2(1.0,0.0) ), f - vec2(1.0,0.0) ), u.x),\n                mix( dot( random2(i + vec2(0.0,1.0) ), f - vec2(0.0,1.0) ), \n                     dot( random2(i + vec2(1.0,1.0) ), f - vec2(1.0,1.0) ), u.x), u.y);\n}\n\nfloat noise( in vec2 x )\n{\n    vec2 p = floor(x);\n    vec2 f = fract(x);\n\tvec2 uv = p.xy + f.xy*f.xy*(3.0-2.0*f.xy);\n\treturn texture( iChannel0, (uv+118.4)/200., -100.0 ).y-0.4;\n}\n\n\nmat2 mat = mat2(.944, -.640, 1.124, 1.076);\n\nfloat oldfbm(vec2 st)\n{\n    float f = noise(st)*0.5; st*=2.02*mat;\n    f += noise(st)*0.25; st*=2.04*mat;\n    f += noise(st)*0.125; st*=2.03*mat;\n    f += noise(st)*0.06125; st*=2.03*mat;\n    \n    return f;\n}\n\n\nfloat fbm(vec2 p)\n{\n    \n float f;\n    \n    f = noise(p)*1.; p*=2.01;\n    f += noise(p)*.5; p*=2.04;\n    f += noise(p)*.25; p*=2.03;\n   // f += noise(p)*.125; p*=2.02;\n    //f += noise(p)*.06125; p*=2.012;\n    \n    return f;\n    \n}\n\nvec3 pattern(vec2 p)\n{\n vec2 lp = p;\n    vec2 id = p*5.;//5 because 10 mod 2\n     id = floor(random2(floor(id)+04.));\n    \n   \n    p = mod(p*9., 2.)-1.;\n    //p.xy*=rot( 3.14159/2.*(floor(id.x)+floor(id.y) ) );\n    float rect = fbm(vec2(p.x+floor(lp.x*5.), p.y+floor(lp.y*5.))/3.)*0.5+0.5;\n    \n    \n    \n    //TEXTURE OPTIONS!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n     //upddate: changed the 5's to 4.5s because mod is now of p*9 and that affects this fbm version.\n    \n    rect = fbm(vec2(p.x+floor(lp.x*4.5), p.y+floor(lp.y*4.5))/3. + fbm(p*8.))*0.5+0.5; \n    \n   \n    //rect = fbm(vec2(p.x+floor(lp.x*4.5), p.y+floor(lp.y*4.5))*1. + fbm(lp*12.))*0.5+0.5;\n    //rect = oldfbm(vec2(p.x+floor(lp.x*4.5), p.y+floor(lp.y*4.5))/3.)*0.5+0.5;\n    //////////////////////////////////////////////////////////////\n    \n    \n    \n    ///make lines for tiles whcih double as indents in the bump mapping\n    \n    ///some machines don't like nagative powers!!!\n   /// rect*=1.0-pow(p.x, 20.);\n   // rect*=1.0-pow(p.y, 20.);\n    \n    rect*=1.0-pow(abs(p.x), 20.);\nrect*=1.0-pow(abs(p.y), 20.);\n    \n\n     p.y+=sin(p.x*1.+cos(p.y*2.+sin(p.y*2.)/1. )/30.)/1.;\n     p = fract(p*2.);\n    //rect = pow(rect, 1./1.02)*3.;\n    float c = rect;\n    //rect *= fbm(lp*6.)*0.5+0.5;\n    vec3 color = vec3(rect);\n        \n    \n    \n    ///COLORING OPTIONS, !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n    color = mix( vec3( c*c, c*c*c, c-0.8), vec3(0.1, 0.4, 0.9)/6., rect)*4.+id.x;\n\n  color = mix( vec3( c*c, c*c*c, c-.8), vec3(0.5, 0.4, 0.9)/2., rect)*4.+id.x;\n  // color =  vec3(c, c*c*c*c, c*c*c*c*c*c*c*c*c*c);\n   //color = 0.5+0.5*cos(vec3(0.850,0.323,0.134)*3.+c+vec3(5.304,2.164,4.124)/6.)*4.;\n\n    //color = 0.5+0.6*cos(vec3(0.212,0.337,0.850)*8.9 +c);\n    //color = 0.5+0.5*cos(vec3(0.212,0.337,0.850)*4.2+ pow(c, 1./3.))*8.;\n   // color = (0.5+0.5*cos(vec3(0.212,0.337,0.850)*4.2 +(1.+pow(c, 1./1.)) )-0.4);\n    \n    \n    \n    \n    \n    \n    return clamp(color, 0.0, 1.0);//need to clamp or else darks go to negative and light wont show up on it. which would be a shame...\n}\n\nvec3 pattern2(vec2 p)//for bumps\n{\n    \n    vec3 color;\n    \n    vec2 lp = p;\n    vec2 id = p*5.;//5 because 10 mod 2\n     id = floor(random2(floor(id)+04.));\n    \n   \n    p = mod(p*9., 2.)-1.;\n    p.xy*=rot( 3.14159/2.*(floor(id.x)+floor(id.y) ) );\n    float rect = 1.;;\n    \n   //rect*=1.0-pow(p.x, 40.);\n   //rect*=1.0-pow(p.y, 40.);\n\n            \n    rect*=1.0-pow(abs(p.x), 20.);\nrect*=1.0-pow(abs(p.y), 20.);\n        \n        color = clamp(vec3(rect), 0.85, 1.);\n    \n return color;   \n}\nfloat getGrey(vec3 p)\n{\n    return p.x*0.299 + p.y*0.587 + p.z*0.114;\n       }\n\n\nvec3 triPlanar(sampler2D tex, vec3 p, vec3 n)\n{\n    //this thing gets the normal, abs because we only need positive values, \n    //negative ones are going into the surface so not needed?\n    //we get max I guess because I guess if the normal is 0 or too small it's not helpful lol\n    //we get the sum and use it to get the percentage each component contributes to the whole.\n vec3 norm = max(abs(n), 0.0001);\t//I'll keep it simple with just this\n float sum = norm.x+norm.y+norm.z;\n norm = norm/sum;//so now the normal is a weighting factor, each component is  weight out of 100 percent\n   // p/=10.;\n    //I kinda get this. it's doing the scaling here, but it's still hard to visualize \n    //that adding texures of the yz, xz, and xy planes would result it a crisp image.\n    //for example, if the texture was a chess board pattern...hmmm maybe.\n    return vec3(pattern(p.yz*8.)*norm.x + \n                pattern(p.xz*8.)*norm.y +\n                pattern(p.xy*8.)*norm.z ) ;\n    \n}\n\nvec3 triPlanar2(sampler2D tex, vec3 p, vec3 n)\n{\n    //this thing gets the normal, abs because we only need positive values, \n    //negative ones are going into the surface so not needed?\n    //we get max I guess because I guess if the normal is 0 or too small it's not helpful lol\n    //we get the sum and use it to get the percentage each component contributes to the whole.\n vec3 norm = max(abs(n), 0.0001);\t//I'll keep it simple with just this\n float sum = norm.x+norm.y+norm.z;\n norm = norm/sum;//so now the normal is a weighting factor, each component is  weight out of 100 percent\n   // p/=10.;\n    //I kinda get this. it's doing the scaling here, but it's still hard to visualize \n    //that adding texures of the yz, xz, and xy planes would result it a crisp image.\n    //for example, if the texture was a chess board pattern...hmmm maybe.\n    return vec3(pattern2(p.yz*8.)*norm.x + \n                pattern2(p.xz*8.)*norm.y +\n                pattern2(p.xy*8.)*norm.z ) ;\n    \n}\n\nvec3 bumpMap(sampler2D tex, in vec3 p, in vec3 n, float bumpfactor)\n{\n    //ok so I don't understand this technique yet.\n    //I mean I can visualize getting the greyscale values from the texture \n    //at three points around the ref, based on the point and the normal.\n    \n    //usually if you want a gradient you\n    //want to get the difference between the ref and points around it\n    \n    //we do this when we take the normal although in that cause we are \n    //getting distances. Here we imply distance by getting greyscale values.\n    //the resulting gradient then cna be considered a normal because each of\n    //it's components is a basis vector that is the slope between the \n    //the components of the ref and the point representing the change from that point\n    //to a bit away.\n    \n    \n    \n    const vec3 eps = vec3(0.001, 0., 0.);//I use swizzling here, x is eps\n    float ref = getGrey(triPlanar(tex, p, n));//reference value \n    \n    vec3 grad = vec3(getGrey(triPlanar(tex, p - eps, n)) - ref,\n                     //eps.yxz means 0.,0.001, 0. \"swizzling\n                     getGrey(triPlanar(tex, p - eps.yxz, n)) - ref,\n                     getGrey(triPlanar(tex, p - eps.yzx, n)) - ref)/eps.xxx;\n    \n    //so grad is the normal...then he does:\n    grad -= n*dot(grad, n);//takes the dot of the surface normal \n    //and the texture normal (the gradient), so percentage of how similar they are\n    //multplies by the surface normal again so scaling it by that percentage\n    //and subtracting that from the gradient.\n    //so the result is only the portion of the gradient that is not part of n??\n    \n    // and returning the surface normal + that gradient portion plus a bump factor\n    //why???\n    return normalize(n + grad*bumpfactor);\n}\n\n\nfloat sphere(vec3 p, float r)\n{\n    \n return length(p) - r;   \n}\n\nfloat rect(vec3 p, vec3 b)\n{\n    p = abs(p)-b;\n return max(p.x, max(p.y, p.z));\n}\n\nfloat infRect(vec3 p, vec3 b)\n{\n    p = abs(p)-b;\n    float f = max(p.x, p.y);\n return f;   \n}\nfloat plane(vec3 p, vec4 n)\n{\n   // p.y = 1.0-p.y;\n return p.y + n.w;//dot(p, n.xyz) + n.w;   \n}\n\n\nfloat infCyl(vec3 p, float r)\n{\n    \n return length(p.xy)-r;   \n}\n\nfloat cylCross(vec3 p, float r)\n{\n p = abs(p);\n    vec3 f = vec3(max(p.x, p.y), max(p.y, p.z), max(p.z,p.x));\n    return min(length(p.xy), min(length(p.yz), length(p.xz)))-r;\n}\n\nfloat rCross(vec3 p)\n{\n    p = abs(p);\n    vec3 f = vec3(max(p.x, p.y), max(p.y, p.z), max(p.z,p.x));\n    float k = min(f.x, min(f.y, f.z) ) - 1./3.;\n    \n return k;   \n}\n\nfloat repCross(vec3 p)\n{\n    vec3 q = mod(p+1., 2.)-1.;\n    float f = rCross(q);\n    \n/*\n    q = abs(q)-0.05;\nq = abs(q)-0.7;\n\n    \n    f = min(f, rCross(q) );\n*/\n\n    \n    //cool linething use 1 or 2 loops only\n  \n    \nq = abs(q)-0.5;\n\n   q = abs(q)-0.2;q = abs(q)-0.95;q = abs(q)-0.5;q = abs(q)-0.5;\n    q=abs(q)-0.005;\n    f = min(f, cylCross(q,0.101));\n    \n\n    \n    //2 or three loops\n    \n    /*\nq = abs(q)-0.6;\n    q = abs(q)-0.1;\n    q = abs(q)-0.43;\n    q = abs(q)-0.34;\n    f = min(f, cylCross(q, 0.1) );\n*/\n\n    \n    /*\n   \nq = abs(q)-0.34;\n    //q = abs(q)-0.04;\n    q = abs(q)-0.08;\n    f = min(f, cylCross(q, 0.1) );\n*/\n   /*\n    \n q = abs(q)-0.934;\n    q = abs(q)-0.094;\n    q = abs(q)-0.08;\n    f = min(f, cylCross(q, 0.1) );\n*/\n    \n    \n    // f = cylCross(q, 0.25);\n return f;   \n}\n\nfloat repCylCross(vec3 p)\n{\n    vec3 q = mod(p+1., 2.)-1.;\n    float f =  cylCross(q, 0.05) ;\n return f;   \n}\n\nfloat rcScale(vec3 p, float s)\n{\n    \n return repCross(p*s)/s;\n}\n\n\n\nfloat map(vec3 p)\n   {\n       //p = fract(p);\n     \n      \n    float re = 0.0;\n       float scale = 1.;\n       \n       for(int i=0; i<2 ;i++)\n       {\n        \n        scale*=3.;\n        re = max(re, -rcScale(p, scale)  );\n        p = abs(p)-0.05;\n       }\n       /* re = max(re, -rcScale(p, scale*2.2)  );\n       //there are a ton of possibilities, which I'm glad shane kind of hinted at\n       \tscale*=17.;//17, 8, 3, even 4\n        re = max(re, -rcScale(p.xyy, scale*3.)  );\n       \n       \n       \tscale*=1.;\n        re = max(re, -rcScale(p.xxy, scale/8.1)  );\n         \n       \tscale*=3.;\n        re = max(re, -rcScale(p, scale/20.)  );*/\n       \n       \n       /*\n         p.xz*=rot(1.9);\n\t\tp.xz = mod(p.xz, .24) - 0.12;\n     p.y/=1.5;\n      \n       re = max(re,  rect(p, vec3(0.1) ));*/\n    return re;//rect(p, vec3(2.5));\n    /*\n    vec3 ss = p;\n    for(int i = 0;i<8;i++)\n    {    \n        p = abs(p)-0.037;\n        p.xz=rot(p.xz,1.6+iTime/3.);\n        //p*=(1.02-float(i)/800.);\n        p = abs(p)-0.3*1.4;;\n        p.xy=rot(p.xy,1.6+iTime/3.);\n        p = abs(p)-0.02*1.4;;\n        p*=1.3;\n        \n        \n    }\n    //p = fract(p/4.)-.5;\n    float  s = rect(p, vec3(0.2));\n    s =  max(s, -sphere(ss, .5));\n    //s = sphere(p, 0.5);\n   //s = min(sphere(p+vec3(0., 1.,.2), 0.2), s);\n    return s;*/\n\n\n\n\n    /*\n \t vec2 pos = vec2(p.xz/5.);//vec2(st.x*5.0, 1./st.y*4.0);\n\tfloat c1 = fbm(pos);\n    \n    float ter = smoothstep(.5,1.95, sin(p.z*24.))*smoothstep(0.5,1.9, sin(p.x*24.));//(1.0-pow(c1, 1.)-0.768);\n    //p.y+=ter;\n   // ter += smoothstep(0.5,1.9,sin(p.x/1.)/1.)+smoothstep(1.,2.,abs(sin(p.x*3.)*1.));\n    //ter +=(smoothstep(.5,1.95, sin(p.z*2.))+smoothstep(0.5,1.9, sin(p.x*2.)));;\n    // ter +=smoothstep(.5,1.95, sin(p.z*4.))+smoothstep(0.5,1.9, sin(p.x*4.));   \n       // ter +=smoothstep(.5, 1.95, 0.5+0.5*sin(p.z/2.)+smoothstep(.5, 1.95, sin(p.z/2.))*1.);//+smoothstep(0.5,1.9, sin(p.x*1.));;\n  float x = p.x/4.;\n    ter += smoothstep(0.0,0.5,fract(x/4.))+smoothstep(0.0,0.5,fract(x/2.));\n    float pl = plane(p, vec4(0., 1., 0., pow(ter, 2.)*8.));\n    \n \tp = mod(p, 1.)-0.5;   \n    return pl;//min(pl, sphere(p, 0.02));//sphere(p, 0.2);*/\n}\n\nfloat trace(vec3 ro, vec3 rd)\n{\n    float eps = 0.001;\n    float dist;\n    float t = 0.0;\n    for(int i = 0;i<96;i++)\n    {\n        dist = map(ro+rd*t);\n    if(dist<eps || t > 120.)\n        break;\n    \n    t +=dist*0.95;\n    }\n    \n    return t;\n\t    \n}\n\n\n//based on shanes reflection tutorial\nfloat rtrace(vec3 ro, vec3 rd)\n{\n    float eps = 0.0001;\n    float dist;\n   \tfloat t = 0.0;\n    \n    for(int i=0; i<48; i++)\n    {\n     dist = map(ro + rd*t);\n        if(dist<eps || t > 120.)\n            break;\n        \n      t += dist;\n        \n    }\n    \n    \n return t;   \n}\nvec2 path(vec3 p)\n{\n    \n float a = sin(p.z*1.)/3. ;\n     float b = cos(p.z)/3.;\n    return vec2(a, b);\n}\n\n\n\nvec3 normal(vec3 sp)\n{///had to adjust the normal cause I was getting these weird lines on edges.\n    vec3 eps = vec3(.0014, 0.0, 0.0);\n    \n    vec3 normal = normalize (vec3( map(sp+eps) - map(sp-eps)\n                       ,map(sp+eps.yxz) - map(sp-eps.yxz)\n                       ,map(sp+eps.yzx) - map(sp-eps.yzx) ));\n    \n    \n return normal;   \n}\n\n//guess who this is from...shane\n// \"I keep a collection of occlusion routines... OK, that sounded really nerdy. :)\n// Anyway, I like this one. I'm assuming it's based on IQ's original.\"\nfloat calculateAO(in vec3 pos, in vec3 nor)\n{\n\tfloat sca = 2.0, occ = 0.0;\n    for( int i=0; i<5; i++ ){\n    \n        float hr = 0.01 + float(i)*0.5/4.0;        \n        float dd = map(nor * hr + pos);\n        occ += (hr - dd)*sca;\n        sca *= 0.7;\n    }\n    return clamp( 1.0 - occ, 0.0, 1.0 );    \n}\n\n//based on shanes lighting function but i added reflections using a cubemap\nvec3 lighting(vec3 sp, vec3 sn, vec3 lp, vec3 rd)\n{\nvec3 color;\n    \n    //some other experiemnts\n    //where the id's are based on cells you don't need to pass the id variable around\n    //you can just recreate it where needed.\n    /*float id = rnd(floor(sp.xz));\n    float id1to3 = floor(id*3.0);\n    float one = step(1., id1to3);\n    float two = step(2., id1to3);\n    float three = step(3., id1to3);///hmmm*/\n    \n    //vec3 tex = texture(iChannel0, sp.xz).xyz*one;\n    sn = bumpMap(iChannel0, sp, sn, 0.0015);\n    vec3 lv = lp - sp;\n    float ldist = max(length(lv), 0.01);\n    vec3 ldir = lv/ldist;\n    \n    float atte = 1.0/(1.0 + 0.002*ldist*ldist );\n    \n    float diff = dot(ldir, sn);\n    float spec = pow(max(dot(reflect(-ldir, sn), -rd), 0.0), 10.);\n    float fres = pow(max(dot(rd, sn) + 1., 0.0), 1.);\n\tfloat ao = calculateAO(sp, sn);\n    \n    vec3 refl = reflect(rd, sn);\n    vec3 refr = refract(rd, sn, 0.7);\n    \n   vec3 color2 = vec3(0.2, 0.5, 0.9);\n    vec3 color3 = vec3(0.0);\n    //getting reflected and refracted color froma cubemap, only refl is used\n   // vec4 reflColor = texture(iChannel1, refl);\n   // vec4 refrColor = texture(iChannel2, refr);\n     \n    //blue vs orage specular, orange all the way.\n    vec3 coolSpec = vec3(.3, 0.5, 0.9);\n    vec3 hotSpec = vec3(0.9,0.5, 0.2);\n   color2 = triPlanar(iChannel0, sp, sn);\n    //+reflColor.xyz*0.2\n    //apply color options and add refl/refr options\n    color = (diff*color2*8. +  spec*coolSpec*9.  )*atte;\n\t\n    \n    //apply ambient occlusion and return.\n return color*ao;   \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    uv=uv*2.0-1.0;\n    uv.x*=iResolution.x/iResolution.y;\n    \n    vec3 lk = vec3(0.,0, 0.+iTime/4.);\n    \n    //lk.xy+=vec2(2.34,.34);//path(lk/4.);//lk.xz*=rot(lk.z);//;\n    vec3 ro = lk + vec3(0., 0., -1.0);\n    vec3 lp = ro + vec3(0, 0., 0.);//lp is ro so no area is too dark\n   \tfloat FOV = .57;\n    \n    vec3 fwd = normalize(lk - ro);\n    vec3 up = vec3(0., -1., 0.0);\n    vec3 rr = normalize(cross(up, fwd));\n    vec3 uu = normalize(cross(rr, fwd));\n    \n    vec3 rd = normalize(vec3(rr*FOV*uv.x + uu*FOV*uv.y + fwd));\n    \n   rd.yz*=rot(iTime/5.);\n    //rd.xz*=rot(iTime/10.);\n    rd.xz*=rot((iTime)/10.);\n    float t = trace(ro, rd);\n    \n     vec3 sp = ro + rd*t;\n    vec3 sn = normal(sp);\n   \t\n    float far = smoothstep(0.0, 1.0, t/4.);\n    \n    //get cube color from cubemap again this time to apply to the sky,\n    //really just so that the reflections on the ground make sense\n    \n  //  vec4 cubeColor = texture(iChannel1, rd);\n    vec3 color = lighting(sp, sn, lp, rd);//mix(stripes(ro+rd*t),vec3(t), far);\n     //reflection trace based on shanes reflection tutorial\n    vec3 refRay = reflect(rd, sn);\n    float rt = rtrace(sp+refRay*0.01, refRay);\n    vec3 rsp = sp + refRay*rt;\n    vec3 rsn = normal(rsp);\n     //\n  // color += lighting(rsp, rsn, lp, refRay)*0.1;\n         //color += clamp(lighting(rsp, rsn, lp, refRay)*0.9, 0.0, 1.);\n   \n    color = mix(color, vec3(2., 2.5, 3.) ,far);//\n    ///color = mix(color, vec3(0.9, 0.5, 0.2), t);\n  // color = vec3(t*t*t, t*t, t*t*t*t*t*t*t);\n  // color = vec3(t/100.);\n    \n    \n    \n    \n    \n    \n    \n\tfragColor = vec4(color,1.0);\n    \n    \n    \n    \n}", "image_inputs": [{"id": "XdX3Rn", "previewfilepath": "/media/ap/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XldSDf.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[2, 2, 28, 28, 93], [95, 95, 114, 114, 222], [224, 224, 246, 246, 385], [387, 469, 494, 494, 900], [902, 902, 928, 928, 1081], [1129, 1129, 1152, 1152, 1337], [1340, 1340, 1359, 1359, 1571], [1573, 1573, 1595, 1595, 3639], [3641, 3641, 3675, 3675, 4134], [4135, 4135, 4158, 4158, 4213], [4216, 4216, 4263, 4591, 5199], [5201, 5201, 5249, 5577, 6188], [6190, 6190, 6259, 6984, 7960], [7963, 7963, 7994, 7994, 8027], [8029, 8029, 8057, 8057, 8110], [8112, 8112, 8143, 8143, 8206], [8207, 8207, 8236, 8257, 8303], [8306, 8306, 8337, 8337, 8371], [8373, 8373, 8406, 8406, 8549], [8551, 8551, 8573, 8573, 8721], [8723, 8723, 8747, 8747, 9524], [9526, 9526, 9553, 9553, 9635], [9637, 9637, 9669, 9669, 9701], [9705, 9705, 9727, 9750, 11873], [11875, 11875, 11906, 11906, 12128], [12131, 12169, 12201, 12201, 12446], [12447, 12447, 12466, 12466, 12552], [12556, 12556, 12578, 12653, 12908], [12910, 13097, 13142, 13142, 13401], [13403, 13479, 13530, 13530, 15033], [15035, 15035, 15092, 15092, 16754]], "test": "error"}
{"id": "XldSDS", "name": "Polar and cartesian crystals", "author": "sheepmaster", "description": "Polar and cartesian quasicrystals.\n\nBased on http://glslsandbox.com/e#6839.3 (which is in turn based on http://wealoneonearth.blogspot.co.uk/2011/10/animated-quasicrystals.html).", "tags": ["2d", "quasicrystal", "polar", "cartesian", "crystal"], "likes": 2, "viewed": 881, "published": "Public API", "date": "1482017415", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Degree of symmetry.\nconst int K = 5;\n\n// Wave frequency.\nconst int NUM_STRIPES = 10;\n\n// Period in seconds.\nconst float PERIOD = 3.0;\n\n// Whether to use polar or cartesian coordinates.\nconst bool POLAR = false;\n\n// The slow phase shift results in apparent motion (even though\n// the animation is periodic over time), which can be compensated by shifting\n// the pattern. Because quasicrystals are aperiodic for degrees of symmetry\n// other than 2, 3, 4, and 6 (the ones for which the place can be periodically\n// tiled), motion compensation means the center of rotational symmetry moves\n// over time, so it is only enabled by default for polar coordinates, where\n// the apparent motion is a rotation and zoom.\nconst bool MOTION_COMPENSATION_IN_CARTESIAN = false;\n\n// Zoom effect when using polar coordinates.\n// 1.0 zooms in, -1.0 zooms out, 0.0 stays still.\nconst float POLAR_ZOOM = 0.0;\n\n// Scaling factor for r in polar coordinates.\nconst float POLAR_SCALING = 1.0;\n\n// Scaling factor for cartesian coordinates.\nconst float CARTESIAN_SCALING = 3.0;\n\n// Use sawtooth instead of cosine waves.\nconst bool SAWTOOTH = false;\n\n// Plot contours instead of absolute values.\nconst bool CONTOUR = false;\n\n// Line width when using contours.\nconst float CONTOUR_WIDTH = 16.;\n\n// Color the values with a radial rainbow gradient.\nconst bool RAINBOW_COLOR = false;\n\n// If not using rainbow colors, use this base color.\nconst vec3 BASE_COLOR = vec3(1.0, 0.0, 1.0);\n\nconst float PI = 4.0 * atan(1.0);\n\nfloat smoothe(float x) {\n    return x * x * (3.0 - 2.0 * x);\n}\n\nvec3 smoothe(vec3 x) {\n    return x * x * (3.0 - 2.0 * x);\n}\n\nvec3 hsv2rgbSmooth(float hue, float saturation, float value) {\n\tvec3 rgb = clamp(abs(mod(hue*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0);\n\n\treturn value * mix(vec3(1.0), smoothe(rgb), clamp(saturation, 0.0, 1.0));\n}\n\nfloat roundToFraction(float x, int frac) {\n    return floor(x * float(frac) + 0.5) / float(frac);\n}\n\nfloat arg(vec2 z) {\n    return atan(z.y, z.x);\n}\n\nfloat sawtooth(float x) {\n    return 2. * abs(mod(x / PI, 2.) - 1.) - 1.;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n\tvec2 xy = fragCoord.xy - iResolution.xy / 2.0;\n\tfloat phase = 2.0 * PI * iTime / PERIOD;\n\n    float k = float(K);\n\n    vec2 coords;\n    float scale;\n    if (POLAR) {\n        scale = POLAR_SCALING;\n        float theta = arg(xy);\n        float r = log(dot(xy, xy)) * scale;\n        coords = vec2(theta, r);\n    } else {\n        scale = CARTESIAN_SCALING * 2.0 / iResolution.x;\n    \tcoords = xy * scale;\n    }\n\tcoords *= float(NUM_STRIPES);\n    \n    // Compensate for apparent motion.\n    if (POLAR || MOTION_COMPENSATION_IN_CARTESIAN) {\n        float motionCompensation = phase;\n        coords.x -= motionCompensation / k * 2.;\n\n        if (POLAR) {\n            // Adjust the compensation for the y coordinate to give a\n            // zoom effect if desired. If POLAR_ZOOM is -1, the compensation is\n            // set to zero, which results in the natural apparent motion\n            // (zooming out).\n            motionCompensation *= POLAR_ZOOM + 1.0;\n        }\n        coords.y -= motionCompensation;\n    }\n\n\tfloat c = 0.0;\n    vec2 g;\n    if (SAWTOOTH) {\n        g = vec2(1);\n    } else {\n        g = vec2(0);\n    }\n\tfor (int t = 0; t < K; t++) {\n\t\tfloat tScaled = PI*float(t)/k;\n        vec2 omega = vec2(cos(tScaled), sin(tScaled));\n        if (POLAR) {\n            // When using polar coordinates, round to the nearest fraction of\n            // NUM_STRIPES to ensure the wave has a period of 2 pi.\n            omega.x = roundToFraction(omega.x, NUM_STRIPES);\n        }\n        float p = dot(coords, omega) + phase;\n        if (SAWTOOTH) {\n\t\t\tc += sawtooth(p);\n        } else {\n            c += cos(p);\n            g -= omega * sin(p);\n        }\n\t}\n    \n\tfloat val;\n    if (CONTOUR) {\n        float d = abs(c) / length(g);\n        val = 1. - smoothstep(0., CONTOUR_WIDTH * scale, d);\n    } else {\n        val = smoothe((c+k)/(k*2.0));\n    }\n   \n    vec3 color;\n    if (RAINBOW_COLOR) {\n        color = hsv2rgbSmooth(arg(xy) / (2. * PI), length(xy) / 25., val);\n    } else {\n    \tcolor = BASE_COLOR * val;\n    }\n\tfragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XldSDS.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1490, 1490, 1514, 1514, 1552], [1554, 1554, 1576, 1576, 1614], [1616, 1616, 1678, 1678, 1834], [1836, 1836, 1878, 1878, 1935], [1937, 1937, 1956, 1956, 1985], [1987, 1987, 2012, 2012, 2062], [2064, 2064, 2119, 2119, 4170]], "test": "error"}
{"id": "XldSDX", "name": "Fake Parallax", "author": "zackpudil", "description": "An attempt at faking a 3D scene with some fake parallax hack.", "tags": ["2d", "fractal", "paralax"], "likes": 9, "viewed": 340, "published": "Public", "date": "1482102484", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define FOREGROUND\n#define SHADOWS\n\nvec3 grey = vec3(0.21, 0.72, 0.07);\n\n// standard rotation and hash functions\nmat2 r(float a) { float c = cos(a); float s = sin(a); return mat2(c, s, -s, c); }\nfloat hash(float n) { return fract(sin(n)*43578.5453); }\nvec2 hash(vec2 n) { float x = dot(n, vec2(12.232, 20.34)); return vec2(hash(x + 2.3), hash(x + 93.34)); }\n\n// IQ noise function.\nfloat noise(vec2 g) {\n    vec2 p = floor(g);\n    vec2 f = fract(g);\n    \n    f = f*f*(3.0 - 2.0*f);\n    \n    float n = p.x + 57.0*p.y;\n    \n    return mix(\n        mix(hash(n), hash(n + 1.0), f.x),\n        mix(hash(n + 57.0), hash(n + 58.0), f.x),\n        f.y);\n}\n\n// texture wrapper.\nvec3 tx(sampler2D s, vec2 p) {\n    return texture(s, p).rgb;\n}\n\n// voronoi function.\nvec3 vo(vec2 x) {\n    vec2 p = floor(x);\n    vec2 f = fract(x);\n    \n    vec2 res = vec2(8.0);\n    \n    for(int i = -1; i <= 1; i++)\n   \tfor(int j = -1; j <= 1; j++) {\n        \n        vec2 g = vec2(i, j);\n        vec2 r = g + hash(p + g) - f;\n        \n        float d = length(r);\n        if(res.x > d) {\n            res.y = res.x;\n            res.x = d;\n        } else if(res.y > d) {\n            res.y = d;\n        }\n    }\n    \n    float v = res.y - res.x;\n    v = smoothstep(0.0, 0.17, v);\n    \n    return vec3(v);\n}\n\n// animate the background.\nvoid animatebg(inout vec2 p) {\n    if(p.y < -0.3) p = vec2(p.x, 1.0)/abs(p.y);\n    else p *= 1.0/0.3;\n    \n    p.x += iTime;\n}\n\n// background 2d distance function.\nvec3 bg(vec2 p) {\n    return vo(p) + 0.7*tx(iChannel0, p);\n}\n\n// 2.5d bump function for background.\nvec3 bump(vec2 p, float e, float z) {\n    vec2 h = vec2(e, 0.0);\n    \n    float ce = dot(grey, bg(p));\n    \n    vec3 g = (grey*mat3(bg(p - h.xy), bg(p - h.yx), z/grey) - ce)/e;\n    \n    return normalize(g);\n}\n\n// render background.\nvec3 renderbg(vec2 p) {\n    vec3 col = vec3(0);\n    \n    // 2.5d ray direction.\n    vec3 rd = normalize(vec3(p, 1.97));\n\tanimatebg(p);\n    vec3 sn = bump(p, 0.01, -0.2);\n    \n    // spotlight-like light by pow-ing diffuse.\n    col += pow(clamp(dot(-rd, sn), 0.0, 1.0), 20.0);\n    \n    if(p.y < -2.4)\n        col *= tx(iChannel0, p);\n    \n    return col;\n}\n\n// animate the forground domain.\nvoid animatefg(inout vec2 p) {\n    float time = iTime*1.3;\n    p.x += time;\n\tp *= 2.0;\n    \n    float s = 2.3;\n    p = mod(p + s, s*2.0) - s;     \n}\n\n// 2d signed distance function for the foreground.\nfloat fg(vec2 p) {    \n    vec2 q = p;\n    \n    // kaliset fractal\n    float d = 1.0;\n    for(int i = 0; i < 5; i++) {\n        p = 1.1*abs(p)/clamp(dot(p, p), 0.9, 1.0) - vec2(0.2, 2.0);\n\t\td = min(d, abs((p.y + p.x)));\n    }\n    \n    // add fractal to pillar\n    float e = abs(q.x) - 0.9;\n    d = -1.0 + 2.0*(d + e);\n\n    // texture\n\td -= 0.5*smoothstep(0.2, 1.0, -d)*dot(grey, tx(iChannel2, q));\n    \n    return d;\n}\n\n// 2.5d bump mapping of foreground distance function.\nvec3 norm(vec2 p, float e, float z) {\n    vec2 r = vec2(e, 0.0); vec2 l = r.yx;\n    vec3 n = vec3(fg(p + r) - fg(p - r),\n                  fg(p + l) - fg(p - l),\n\t\t\t\t  z);\n    \n    return normalize(n);\n}\n\n// render foreground\nvec3 renderfg(vec2 p) {\n    vec3 col = vec3(0);\n    \n    // 2.5d ray direction.\n    vec3 rd = normalize(vec3(p, 2.0));\n    animatefg(p);\n    vec3 no = norm(p, 0.01, -0.5);\n    \n    vec3 re = reflect(rd, no);\n    \n    // same spotlight effect as background.\n    col += pow(clamp(dot(-rd, no), 0.0, 1.0), 20.0);\n    col += pow(clamp(1.0 + dot(rd, no), 0.0, 1.0), 4.0);\n   \t\n    col *= tx(iChannel2, p);\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = (-iResolution.xy + 2.0*fragCoord)/iResolution.y;\n    \n    vec2 fuv = uv;\n    \n    // shadow coordinates.\n    vec2 suv = uv + vec2(-0.1*(uv.x - 0.1), 0.0); // domain distortion of x coord of shadow.\n\tsuv.x *= 0.8; // scale a little larger.\n    \n    //scale lower part of the coords, to give the paralax effect.\n\tsuv *= 1.0 + 0.3*smoothstep(0.6, 1.0, -uv.y);\n    \n    animatefg(fuv);\n    animatefg(suv);\n    \n    // render background, with shadows.\n    vec3 bg = renderbg(uv);\n    #ifdef SHADOWS\n    bg = mix(0.2*bg, bg, smoothstep(-0.3, 0.0, fg(suv)));\n    #endif\n    \n    #ifdef FOREGROUND\n    vec3 col = mix(bg, renderfg(uv), 1.0 - smoothstep(-0.1, 0.0, fg(fuv)));\n    #else\n    vec3 col = bg;\n    #endif\n    \n\tfragColor = vec4(col, 1);\n}", "image_inputs": [{"id": "4dXGRn", "previewfilepath": "/media/ap/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg", "ctype": "texture"}, {"id": "4sXGRn", "previewfilepath": "/media/ap/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg", "ctype": "texture"}, {"id": "4sfGRn", "previewfilepath": "/media/ap/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XldSDX.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[73, 113, 130, 130, 194], [195, 195, 216, 216, 251], [252, 252, 271, 271, 357], [359, 381, 402, 402, 644], [646, 666, 696, 696, 728], [730, 751, 768, 768, 1271], [1273, 1300, 1330, 1330, 1426], [1428, 1464, 1481, 1481, 1524], [1526, 1564, 1601, 1601, 1772], [1774, 1796, 1819, 1819, 2151], [2153, 2186, 2216, 2216, 2334], [2336, 2387, 2405, 2405, 2804], [2806, 2860, 2897, 2897, 3063], [3065, 3086, 3109, 3109, 3504], [3506, 3506, 3563, 3563, 4314]], "test": "error"}
{"id": "XldSWj", "name": "Charlie", "author": "h3nr1x", "description": "Our beloved Charlie! ", "tags": ["3d", "raymarching"], "likes": 2, "viewed": 559, "published": "Public API", "date": "1482389137", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define ANTIALIAS\n\n////////////////////////////////////////////////////////////////////////////////\n// Shape configuration\n////////////////////////////////////////////////////////////////////////////////\n\nstruct charlie_body_params {\n    mat3 skew;\n\n    vec3 box_size;\n    float box_roundness;\n\n    float amp_f1;\n    float frec_f1;\n    float ang_offset1;\n    float offset_f1;\n\n    float amp_f2;\n    float frec_f2;\n    float ang_offset2;    \n    float offset_f2;    \n\n    float x_shift;\n};\n    \ncharlie_body_params create_charlie_body_params() {\n\tcharlie_body_params da_body;\n    da_body.skew = mat3( \n        \t\t\t\t 0.88, 0.16, 0.00, \n                    \t 0.04, 1.05, 0.00,\n                     \t 0.00, 0.00, 1.00 \n                       );\n\n    da_body.box_size = vec3(0.05, 0.3, 0.09);\n    da_body.box_roundness = 0.005;\n\n    da_body.amp_f1 = 0.145;\n    da_body.frec_f1 = 5.1;\n    da_body.ang_offset1 = -0.1;\n    da_body.offset_f1 = -0.03;\n\n    da_body.amp_f2 = 0.15;\n    da_body.frec_f2 = 4.8;\n    da_body.ang_offset2 = 0.1;    \n    da_body.offset_f2 = 0.0;    \n\n    da_body.x_shift = 0.055;\n    \n    return da_body;\n}\n    \n    \n////////////////////////////////////////////////////////////////////////////////\n// Distance Field (DF) Primitives\n////////////////////////////////////////////////////////////////////////////////\n\nfloat df_plane(in vec3 ray, vec3 n, vec3 p0) {\n \treturn dot(ray - p0, n);  \n}\n\nfloat df_sphere(in vec3 ray, in float radious) {\n    return length(ray) - radious;\n}\n\n// These two are from: http://iquilezles.org/www/articles/distfunctions/distfunctions.htm\nfloat df_round_box(in vec3 ray, in vec3 size, in float roundness) {\n  \treturn length(max(abs(ray) - size, 0.0)) - roundness;\n}\n\nfloat df_triangular_prism(in vec3 ray, vec2 size) {\n    vec3 q = abs(ray);\n    return max(\n        q.z - size.y, \n        max(q.x * 0.866025 + ray.y * 0.5, -ray.y) - size.x * 0.5\n    );\n}\n\n////////////////////////////////////////////////////////////////////////////////\n// Operations\n////////////////////////////////////////////////////////////////////////////////\n\nfloat op_union(in float d1, in float d2) {\n \treturn min(d1, d2);   \n}\n\nfloat op_interception(in float d1, in float d2) {\n \treturn max(d1, d2);   \n}\n\nfloat op_complement(in float d) {\n \treturn -d;   \n}\n\nfloat op_difference(in float d1, in float d2) {\n \treturn op_interception(d1, op_complement(d2));\n}\n\n////////////////////////////////////////////////////////////////////////////////\n// Individual vector operations\n////////////////////////////////////////////////////////////////////////////////\n\nvec3 rot_z(in vec3 p, in float degs) {\n    float rads = radians(degs);\n    float c = cos(rads);\n    float s = sin(rads);\n    mat3 t = mat3(  c,   s, 0.0,\n                   -s,   c, 0.0,\n                  0.0, 0.0, 1.0);\n    return t * p;\n}\n\nvec3 rotate_vec(in vec3 angle, in vec3 v) {\n    vec3 rads = radians(angle);\n    \n    vec3 s = sin(rads); vec3 c = cos(rads);\n\n    mat3 rot_x = mat3( 1.0,  0.0,  0.0,\n                       0.0,  c.x, -s.x,\n                       0.0,  s.x,  c.x);\n\n    mat3 rot_y = mat3( c.y,  0.0,  s.y,\n                       0.0,  1.0,  0.0,\n                      -s.y,  0.0,  c.y);\n\n    mat3 rot_z = mat3( c.z,  s.z,  0.0,\n                      -s.z,  c.z,  0.0,\n                       0.0,  0.0,  1.0);\n    \n    return rot_x * rot_y * rot_z * v;\n}\n\n////////////////////////////////////////////////////////////////////////////////\n// Modeling (here is where the body of Charlie gets assembled)\n////////////////////////////////////////////////////////////////////////////////\n\nfloat df_left_arm_and_leg(in vec3 ray, in charlie_body_params bp) {\n    vec3 shifted_ray = ray + vec3(bp.x_shift, vec2(0));\n    \n    vec3 l1 = bp.skew * shifted_ray + vec3(\n        bp.amp_f1 * sin(shifted_ray.y * bp.frec_f1 + bp.ang_offset1) + bp.offset_f1, \n        vec2(0.0)\n    );\n    float line1 = df_round_box(l1, bp.box_size, bp.box_roundness);\n    \n    vec3 l2 = bp.skew * shifted_ray + vec3(\n        bp.amp_f2 * sin(shifted_ray.y * bp.frec_f2 + bp.ang_offset2) + bp.offset_f2, \n        vec2(0.0)\n    );\n    float line2 = df_round_box(l2, bp.box_size, bp.box_roundness);\n\t\n    return op_difference(\n        op_union(line1, line2), \n        df_plane(ray, vec3(0, 1, 0), vec3(0.0, -0.31, 0.0))\n    );\n}\n\nfloat df_right_arm(in vec3 ray, in charlie_body_params bp) {\n    vec3 mirror_x_ray = vec3(-ray.x + bp.x_shift, ray.yz);\n    \n    float d = df_left_arm_and_leg(mirror_x_ray, bp);\n\n    return op_difference(\n        d, \n        df_plane(ray, vec3(0, 1, 0), vec3(0.0, -0.076, 0.0))\n    );\n}\n\nfloat df_left_leg(in vec3 ray, charlie_body_params bp) {\n\tvec3 mirror_x_ray = vec3(-ray.x + bp.x_shift, ray.yz);\n\n    float right_arm_and_leg = df_left_arm_and_leg(mirror_x_ray, bp);\n\n    vec3 bent_ray = ray;\n    vec3 normal = normalize(rot_z(vec3(0, 1, 0), 126.0));\n    vec3 pos = vec3(-0.17, 0.0, 0.0);\n\n    float clipping_plane = df_plane(bent_ray, normal, pos);\n    \n    return op_difference(right_arm_and_leg, clipping_plane);\n}\n\nfloat df_head(in vec3 ray) {\n    mat3 m = mat3(\n        0.75,  0.00,  0.00,\n        0.00, -1.00,  0.00,\n        0.00,  0.00,  1.00\n    );\n    vec3 t = vec3(-0.019, 0.229, 0.0);\n    return df_triangular_prism(m * ray + t, vec2(0.08, 0.09));\n}\n\nfloat df_world(in vec3 ray) {\n    vec3 r = ray + vec3(-0.03, 0.89 * cos(ray.x) - 1.31, 0.0);\n    vec3 size = vec3(0.6, 0.001, 0.01);\n    float roundness = 0.03;\n    return df_round_box(r, size, roundness);\n}\n\nfloat df_charlie(in vec3 ray, charlie_body_params bp) {\n    float left_arm_and_leg = df_left_arm_and_leg(ray, bp);\n    \n    float right_arm = df_right_arm(ray, bp);\n\n    float left_leg = df_left_leg(ray, bp);\n    \n    float head = df_head(ray);\n    \n    float world = df_world(ray);\n    \n    return op_union(\n        op_union(left_arm_and_leg, right_arm), \n        op_union(left_leg, op_union(head, world))\n    );\n}\n\nfloat model(in vec3 ray, in charlie_body_params body_params) {\n    return df_charlie(ray, body_params);\n}\n\nfloat scene_floor(in vec3 ray) {\n\tvec3 normal = vec3(0.0, 1.0, 0.0);\n    vec3 pos = vec3(0.0, -0.29, 0.0);\n    return df_plane(ray, normal, pos);\n} \n\n////////////////////////////////////////////////////////////////////////////////\n// Lighting \n////////////////////////////////////////////////////////////////////////////////\n\nvec3 normal(in vec3 p, in charlie_body_params bp) {\n    const float EPS = 0.01;\n\treturn normalize(\t\n\t\tvec3(\n\t\t\tmodel(p + vec3(EPS, 0, 0), bp) - model(p - vec3(EPS, 0, 0), bp),\n\t\t\tmodel(p + vec3(0, EPS, 0), bp) - model(p - vec3(0, EPS, 0), bp),\n\t\t\tmodel(p + vec3(0, 0, EPS), bp) - model(p - vec3(0, 0, EPS), bp)\n\t\t)\n\t);\n}\n\n// Assume all vectors are incident, that is, their points \n// (end of the arrow) are at the shading point (the point \n// on the surface of the model hit by the marched ray)\nvec4 lambertian(in vec3 light_dir, in vec3 view, in vec3 normal, in vec4 surface_color) {\n\tview = -view;\n    light_dir = -light_dir;\n    \n    float spec_factor = 1.0;\n    const vec4 light_col = vec4(1.0);\n    \n    vec4 ambient_color = vec4(surface_color.rgb / 1.5, 1.0); \n       \n\tfloat n_dot_l = max(dot(normal, light_dir), 0.0);\n    vec3 diffuse = surface_color.rgb * light_col.rgb * n_dot_l;\n\n    // vec3 reflection_vector = reflect(-light_dir, normal); \n    // vec3 specular = surface_color.rgb * pow(max(dot(reflection_vector, view), 0.0), spec_factor);\n    vec3 specular = vec3(0);\n        \n\treturn vec4(diffuse + specular, 1.0) + ambient_color;\n}\n\nvec4 lambertian_floor(in vec3 light_dir, in vec3 eye, in vec3 normal, in vec4 surface_color) {\n    const vec4 light_col = vec4(1.0);\n            \n\tfloat n_dot_l = max(dot(normal, light_dir), 0.0);\n\n    vec3 diffuse = surface_color.rgb * light_col.rgb * n_dot_l;\n        \n\treturn vec4(diffuse, 1.0) + surface_color;\n}\n\n// Again, the vector are incident (see comment two funcions above)\nfloat charlie_shadow(in vec3 shading_point, in vec3 light_pos, in charlie_body_params bp) {\n    const int MAX_STEPS = 50;\n    const float EPSILON = 0.01;\n    \n    vec3 ray = light_pos - shading_point;\n    vec3 normalized_ray = normalize(ray);\n    \n    float dist = 0.0;\n    float clarity = 1.0;\n    const float min_umbra = 0.65;\n\n    for (int i = 0; i < MAX_STEPS; i++) {\n        vec3 p = shading_point + normalized_ray * dist;\n\n        float d = model(p, bp);\n        if (d < EPSILON) {\n\t\t\treturn min_umbra;\n        }\n\t\tclarity = min(clarity, 16.0 * d / dist);\n        dist += d;\n    }\n\n    return max(min_umbra, min(1.0, clarity));\n}\n\n////////////////////////////////////////////////////////////////////////////////\n// Ray Marching \n////////////////////////////////////////////////////////////////////////////////\n\nvec4 ray_march(in vec4 default_color, \n               in vec4 hit_color, \n               in vec3 eye, \n               in vec3 ray, \n               in vec3 ray_offset, \n               in vec3 light_pos,\n               in vec3 light_dir,\n               in charlie_body_params body_params) {\n    vec3 normalized_ray = normalize(ray);\n    \n    const int MAX_STEPS = 30;\n    const float EPSILON = 0.01;\n    \n    float dist = 0.0;\n    for (int i = 0; i < MAX_STEPS; i++) {\n        vec3 p = eye + normalized_ray * dist + ray_offset;\n\n        float d = model(p, body_params);\n        if (d < EPSILON) {\n            vec3 norm = normal(p, body_params);\n            return lambertian(norm, p - eye, light_dir, hit_color);\n        }\n\n        dist += d;\n    }\n\n    const int MAX_STEPS_FLOOR = 100;    \n    const float EPSILON_FLOOR = 0.001;\n\t\n    dist = length(ray);\n    for (int i = 0; i < MAX_STEPS_FLOOR; i++) {\n        vec3 p = eye + normalized_ray * dist + ray_offset;\n\n        float d_floor = scene_floor(p);\n        if (d_floor < EPSILON_FLOOR) {\n        \tvec4 floor_color = vec4(vec3(0.8), 1.0);\n\t\t\treturn floor_color * (charlie_shadow(p, light_pos, body_params));\n        }\n        \n        dist += d_floor;\n    }\n    \n    return default_color;\n}\n\n////////////////////////////////////////////////////////////////////////////////\n// Main\n////////////////////////////////////////////////////////////////////////////////\n\nvoid mainImage(out vec4 frag_color, in vec2 frag_coord) {\n\tfloat aspect = iResolution.y / iResolution.x;\n\n    vec2 mouse_xy = ((1.0 - iMouse.xy) / iResolution.xy) - 0.5;\n    float mouse_rot_y = mouse_xy.y * 12.0 + 6.945;\n    float mouse_rot_x = mouse_xy.x * 100.0;\n    \n    vec3 eye = vec3(0.0, 0.1, -1.4);\n    vec3 near_clipping_plane = vec3((frag_coord.xy / iResolution.xy) - 0.5, -1.0);\n\n    vec3 initial_angle = vec3(mouse_rot_y, mouse_rot_x + 10.0 * iTime + 80.0, 0.0);\n    eye = rotate_vec(initial_angle, eye);\n    near_clipping_plane = rotate_vec(initial_angle, near_clipping_plane);\n\n    eye += vec3(0.0, 0.27, 0.0);\n    near_clipping_plane += vec3(0.0, 0.3, 0.0);\n    \n    vec3 ray = near_clipping_plane - eye;\n    ray.y *= aspect;\n\n    const vec4 background_color = vec4(0.9);    \n    \n    const vec4 blue_charlie = vec4(0.34117647058823529411, \n                                   0.68627450980392156862, \n                                   0.89803921568627450980, \n                                   1.0);\n\n    charlie_body_params body_params = create_charlie_body_params();\n    \n    vec3 initial_light_angle = vec3(30.0 * iTime + 120.0, 60.0 * iTime, 0.0);\n    vec3 light_pos = rotate_vec(initial_light_angle, vec3(-2.0, -6.0, 0.0));\n    vec3 light_dir = normalize(vec3(0) - light_pos);\n    \n#ifdef ANTIALIAS\n    const int NUM_SAMPLES = 4;\n    const float SAMPLE_OFFSET = 0.003;\n    float samples = 0.0;\n    vec4 avg_color = vec4(0);\n\n    for (int i = 0; i < NUM_SAMPLES; ++i) {\n        vec4 color = vec4(1.0);\n    \n\t\tvec3 offset = vec3(ray) + vec3(\n            floor(samples / 2.0) * (2.0 * mod(samples, 2.0) - 1.0) * SAMPLE_OFFSET, \n            (1.0 - floor(samples / 2.0)) * (2.0 * mod(samples, 2.0) - 1.0) * SAMPLE_OFFSET, \n            0.0\n        );\n        \n\t    avg_color += ray_march(background_color, blue_charlie, eye, ray, offset, light_pos, light_dir, body_params); \n\n        samples += 1.0;\n    }\n\n    frag_color = avg_color / samples;    \n#else\n\tfrag_color = ray_march(background_color, blue_charlie, eye, ray, vec3(0), light_dir, body_params);\n#endif\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XldSWj.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[494, 494, 544, 544, 1120], [1328, 1328, 1374, 1374, 1405], [1407, 1407, 1455, 1455, 1491], [1493, 1583, 1650, 1650, 1709], [1711, 1711, 1762, 1762, 1898], [2077, 2077, 2119, 2119, 2146], [2148, 2148, 2197, 2197, 2224], [2226, 2226, 2259, 2259, 2277], [2279, 2279, 2326, 2326, 2377], [2574, 2574, 2612, 2612, 2814], [2816, 2816, 2859, 2859, 3351], [3579, 3579, 3646, 3646, 4286], [4288, 4288, 4348, 4348, 4574], [4576, 4576, 4632, 4632, 5009], [5011, 5011, 5039, 5039, 5252], [5254, 5254, 5283, 5283, 5461], [5463, 5463, 5518, 5518, 5878], [5880, 5880, 5942, 5942, 5985], [5987, 5987, 6019, 6019, 6134], [6313, 6313, 6364, 6364, 6633], [6635, 6808, 6897, 6897, 7461], [7463, 7463, 7557, 7557, 7779], [7781, 7848, 7939, 7939, 8483], [8665, 8665, 8953, 8953, 9907], [10080, 10080, 10137, 10137, 12159]], "test": "valid"}
{"id": "XldSzf", "name": "Mirrored", "author": "lherm", "description": "Playing around with displacement and raytracers", "tags": ["raytrace"], "likes": 6, "viewed": 195, "published": "Public", "date": "1480917928", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const int MAX_STEPS = 20;\nconst float INTESERCTION_PRECISION = 0.001;\nconst float MAX_DISt = 1000.;\n\nfloat displace(in vec3 p)\n{\n    return dot(p, p) + length(p * sin(iTime));\n}\n\nfloat sphereSDF(in vec3 p, in float r)\n{\n    return length(p) - r;\n}\n\nfloat map(in vec3 p)\n{\n    float c = 2.;\n    p = mod(p, c)-.5*c;\n    float d1 = sphereSDF(p, .5);\n    float d2 = displace(p);\n    return d1 + d2 ;\n}\n\nfloat trace(in vec3 eye, in vec3 rd)\n{\n    float d = 0.;\n    for(int i = 0; i < MAX_STEPS; i++)\n    {\n        vec3 p = eye + (rd * d);\n        d += map(p);\n    }\n    return d;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy/iResolution.xy;\n    uv *= 2.0;\n    uv -= 1.0;\n    uv.x *= iResolution.x/iResolution.y;\n    vec3 color = vec3(0.);\n\n    vec3 eye = vec3(0., 0., iTime);\n\n    vec3 rd = normalize(vec3(uv, 1.));\n\n    float d = trace(eye, rd);\n\n    color = vec3(1./d * (pow(sin(iTime), 3.0) + 4.5));\n    color *= mix(color, vec3(cos(uv), 1.0), vec3(-uv, 1.0));\n\n    fragColor = vec4(color, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XldSzf.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[101, 101, 128, 128, 177], [179, 179, 219, 219, 247], [249, 249, 271, 271, 397], [399, 399, 437, 437, 576], [578, 578, 635, 635, 1038]], "test": "valid"}
{"id": "XlGSzR", "name": "sphere art 2", "author": "FabriceNeyret2", "description": "tribute to William Latham early computer art  (variant of  https://www.shadertoy.com/view/4tyXRR )\nhttps://www.google.com/search?q=william+latham&tbm=isch\nhttp://www.phoenixbrighton.org/archive/2013-2/william-latham-mutator-1-2/\n", "tags": ["sphere", "mutator", "latham"], "likes": 2, "viewed": 548, "published": "Public API", "date": "1482338394", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// tribute to William Latham early computer art\n//      https://www.google.com/search?q=william+latham&tbm=isch\n//      http://www.phoenixbrighton.org/archive/2013-2/william-latham-mutator-1-2/\n// Sphere engine from https://www.shadertoy.com/view/XtGSzR\n// (variant of  https://www.shadertoy.com/view/4tyXRR )\n \nfloat t, zmin = 1e9;\n\nvoid sphere(inout vec4 O, vec2 U, vec3 P, float r, vec3 C) { // O, U, pos, radius, color\n\t\n\tU -= P.xy;\n    r = length(U)/r; if (r>1.) return;\n\n    U = normalize(U)*r;\n    float z = sqrt(1.-dot(U,U)); \n    if (zmin < P.z-.1*z) return; \n    zmin = P.z-.1*z;\n    vec3 N = vec3(U,z);\n    O.rgb =  clamp(  C*(.2 + max(0.,(-N.x+N.y+N.z)/1.732))    // ambiant, diffus\n                       + pow(max(0.,dot(N,normalize(vec3(-1,1,2.73)))),50.) // spec\n                       ,0.,1.);               // L=(-1,1,1), E=(0,0,1), z toward eye \n}\n\n\nvoid partic3(inout vec4 O, vec2 U, vec3 P, vec2 D, float dl) {\n    float a = sin(t), c = cos(6.28/30.*a), s = sin(6.28/30.*a), k;\n    for (float i=0.; i<20.; i++) {\n        k = exp(-i/8.);\n        sphere(O, U, .5*P+vec3(i,-i,-i)/100.,dl/2.*k, vec3(1,k*vec2(1,.8)));\n        P.xy += dl*k*D; D *= mat2(c,-s,s,c);\n    }\n}\n\nvoid partic2(inout vec4 O, vec2 U, vec3 P, vec2 D, float dl) {\n    float a = sin(.31*t), c = cos(6.28/30.*a), s = sin(6.28/30.*a), k;\n    for (float i=0.; i<10.; i++) {\n         k = exp(-i/15.);\n        partic3(O, U, P+vec3(i,-i,i)/100., -vec2(D.y,-D.x), dl*k);\n        P.xy += dl*k*D; D *= mat2(c,-s,s,c);\n    }\n}\n\nvoid partic1(inout vec4 O, vec2 U, vec3 P, vec2 D, float dl) {\n    float c=cos(6.28/30.), s=sin(6.28/30.);\n\tfor (int i=0; i<30; i++) {\n        partic2(O, U, P, vec2(D.y,-D.x), dl);\n        P.xy += dl*D; D *= mat2(c,-s,s,c);\n    }\n}\n\nvoid mainImage( out vec4 O, vec2 U )\n{\n    vec2 R = iResolution.xy;\n         U = (U+U-R)/R.y;\n    vec3 P;\n    O -= O; t = iTime;\n    \n    partic1(O, U, P=vec3(sin(t),-cos(t),0), vec2(-P.y,P.x), .2);\n    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XlGSzR.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[334, 334, 394, 422, 866], [869, 869, 931, 931, 1187], [1189, 1189, 1251, 1251, 1503], [1505, 1505, 1567, 1567, 1736], [1738, 1738, 1776, 1776, 1943]], "test": "valid"}
{"id": "XlGXRR", "name": "many spheres (false 3D)", "author": "FabriceNeyret2", "description": "False 3D, the amiga superdemo way :-)\n", "tags": ["spheres", "amiga", "sprites"], "likes": 5, "viewed": 691, "published": "Public API", "date": "1482331942", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n// in the Amiga superdemos, this would be a sprite\nvoid sphere(inout vec4 O, vec2 U, vec2 P, float r, vec3 C) { // O, U, pos, radius, color\n\t\n // vec2 R = iResolution.xy, M = (2.*iMouse.xy-R)/R.y;\n // P = P + (P-M)*smoothstep(.9,.0,length(P-M)); // mouse repeal spheres \n // U = U + (U-M)*smoothstep(.9,.0,length(U-M)); // mouse repeal pixels\n    r = length(U-P)/r; if (r>1.) return;\n\n    U = normalize(U-P)*r;\n    float A = (1.-O.a) * smoothstep(1.,.9,r);    // compositing and anti-aliasing\n    vec3 N = vec3( U, sqrt(1.-dot(U,U)));\n    O.rgb += A * clamp(  C*(.2 + max(0., (-N.x+N.y+N.z)/1.732))    // ambiant, diffuse\n                       + pow(max(0., dot( N, normalize(vec3(-1,1,2.73)))), 50.)  // specular\n                       ,0.,1.);                  // L=(-1,1,1), E=(0,0,1), z toward eye \n    O.a += A;\n}\n\nvoid mainImage( out vec4 O, vec2 U )\n{\n    vec2 R = iResolution.xy;\n         U = (U+U-R)/R.y;\n    float t = iTime;\n    O -= O;\n    for (float a=0.; a<100.; a+=.1)\n//      sphere(O, U, .7*vec2(cos(a),sin(1.1*a)),.1, vec3(1,0,0));\n//      sphere(O, U, .7*vec2(cos(a+t),sin(1.1*a)),.1, vec3(1,0,0));\n//      sphere(O, U, .7*vec2(1.5*cos(a+t)+.3*sin(.9*a),sin(1.1*a)+.3*cos(.8*a)),.1, vec3(1,vec2(a/100.)));\n        sphere(O, U, .7*vec2(1.5*cos(a+t)+.3*sin(.9*a),sin(1.13*a)+.3*cos(.81*a+t)),.1, .5+.5*sin(6.28*a/100.+vec3(0,-2.1,2.1)));\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XlGXRR.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 52, 112, 343, 820], [822, 822, 860, 860, 1357]], "test": "valid"}
{"id": "XlKSzh", "name": "Gloop", "author": "lherm", "description": "More space stuff", "tags": ["raymarch"], "likes": 0, "viewed": 421, "published": "Public API", "date": "1482861684", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Based on https://www.shadertoy.com/view/Xt2XDt by Cabbibo\n\n#define PI 3.14159165\n\nconst int S = 100; // steps\nconst float D = 40.; // max distance\nconst float P = 0.0001; // intersection precision\n\n//-------------------\n// Camera\n//-------------------\nmat3 calcLookAtMatrix( in vec3 ro, in vec3 ta, in float roll )\n{\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(sin(roll),cos(roll),0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n    return mat3( uu, vv, ww );\n}\n\n\nvec2 opU( vec2 d1, vec2 d2 )\n{\n    \n\treturn (d1.x<d2.x) ? d1 : d2;\n    \n}\n\nfloat mod1(in float p, float c)\n{\n    return mod(p, c)-(c*.5);\n}\n\n\n//-------------------\n// Modelling\n//-------------------\n\nvec2 map(in vec3 p)\n{\n    p.z = mod1(p.z, 3.);\n    p.x = cos(p.x*p.y + iTime)*sin(p.x*p.x)+cos(p.y*p.y);\n    float s = length(p) - 1.;\n    vec2 res = vec2(s, 1.);\n    return res;\n}\n\nvec2 trace(in vec3 ro, in vec3 rd)\n{\n    float h = P*2.;\n    float t = 0.;\n    float id = -1.;\n    float res = -1.;\n    \n    for (int i = 0; i < S; i++)\n    {\n        if (h<P || t>D) break;\n        vec3 r = ro + rd*t;\n        h = map(r).x;\n        t += h*.5;\n        id = map(r).y;\n    }\n    \n    if (t < D) res = t;\n    if (t > D) id = -1.;\n    \n    return vec2(res, id);\n}\n\nvec3 calcNormal( in vec3 pos ){\n    \n\tvec3 eps = vec3( 0.001, 0.0, 0.0 );\n\tvec3 nor = vec3(\n\t    map(pos+eps.xyy).x - map(pos-eps.xyy).x,\n\t    map(pos+eps.yxy).x - map(pos-eps.yxy).x,\n\t    map(pos+eps.yyx).x - map(pos-eps.yyx).x );\n\treturn normalize(nor);\n}\n\n// From Connor Bell\nfloat softShadow( in vec3 ro, in vec3 rd, in float mint, in float tmax )\n{\n\tfloat res = 1.0;\n    float t = mint;\n    for( int i=0; i<16; i++ )\n    {\n\t\tfloat h = map( ro + rd*t ).x;\n        res = min( res, 8.0*h/t );\n        t += clamp( h, 0.02, 0.10 );\n        if( h<0.001 || t>tmax ) break;\n    }\n    return clamp( res, 0.0, 1.0 );\n\n}\n\nfloat calcAO( in vec3 pos, in vec3 nor )\n{\n\tfloat occ = 0.0;\n    float sca = 1.0;\n    for( int i=0; i<5; i++ )\n    {\n        float hr = 0.01 + 0.12*float(i)/4.0;\n        vec3 aopos =  nor * hr + pos;\n        float dd = map( aopos ).x;\n        occ += -(dd-hr)*sca;\n        sca *= 0.95;\n    }\n    return clamp( 1.0 - 3.0*occ, 0.0, 1.0 );    \n}\n\nvec3 render(in vec2 res, in vec3 ro, in vec3 rd)\n{\n    vec3 color = vec3(0.);\n    vec3 lightPos = vec3( 1. , 4. , 3. );\n    \n    if (res.y > -.5)\n    {\n        vec3 p = ro + rd*res.x;\n        vec3 norm = calcNormal(p);      \n        vec3 lightDir = normalize(lightPos - p);\n        float match = max( 0. , dot( lightDir , norm ));\n        float occ = calcAO(p, norm);\n        \n        if (res.y == 1.)\n        {\n            color = norm * match * occ * (1.0-calcAO(p, rd));\n        }\n    }\n    \n    return color;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = (-iResolution.xy + 2.0*fragCoord.xy)/iResolution.y;\n    vec3 ro = vec3(0., 0., 4.);\n    vec3 ta = vec3(0., 0., 0.);\n    \n    // Camera Matrix\n    mat3 camMat = calcLookAtMatrix( ro, ta, 0. );  // 0.0 is the camera roll\n    \n    // Create view ray\n\tvec3 rd = normalize( camMat * vec3(uv.xy,2.0) ); // 2.0 is the lens length\n    \n    vec2 res = trace(ro, rd);\n    \n    vec3 color = render(res, ro, rd);\n    \n\tfragColor = vec4(color,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XlKSzh.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[201, 255, 319, 319, 497], [500, 500, 530, 530, 573], [575, 575, 608, 608, 639], [700, 700, 721, 721, 880], [882, 882, 918, 918, 1256], [1258, 1258, 1289, 1289, 1515], [1517, 1537, 1611, 1611, 1872], [1874, 1874, 1916, 1916, 2215], [2217, 2217, 2267, 2267, 2731], [2733, 2733, 2790, 2790, 3239]], "test": "valid"}
{"id": "XltXRl", "name": "Mandelbrot + Glitch Ball", "author": "antoineMoPa", "description": "I mixed 2 of my prior shader codes to create this.", "tags": ["fractal", "glitch"], "likes": 3, "viewed": 639, "published": "Public API", "date": "1481169892", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI 3.1416\n#define PI2 (2.0 * PI)\n\n/*\n  Complex square\n */\nhighp vec2 to_the_2(highp vec2 z){\n    highp vec2 old_z;\n    // Keep the current (old) value\n    old_z = z;\n    \n    // Set new values according to math\n    z.x = pow(z.x,2.0) - pow(z.y,2.0);\n    z.y = 2.0 * old_z.x * old_z.y;\n\n    return z;\n}\n\n\nvec4 mandelbrot(vec2 UV){\n    float x = UV.x / (iResolution.y / iResolution.x);\n    float y = UV.y;\n    \n    vec4 col = vec4(0.0);\n    \n    vec2 c = vec2( -y + 0.5, x - 0.5);\n    vec2 z = vec2(0.0, 0.0);\n\tc *= 4.0;\n    c.x -= 0.5;\n    float maxit = 0.0;\n    \n    bool in_set = true;\n    \n   \tfor(int i = 0; i < 50; i++){\n       \tz = to_the_2(z) + c;\n        \n        if(length(z) > 2.0){\n        \tmaxit = float(i);\n            in_set = false;\n        \tbreak;\n        }\n    }\n    \n    if(!in_set){\n    \tcol.g = maxit/50.0;\n    } else {\n        col.g = maxit/50.0;\n        col.r = length(z);\n    }\n    col.b = maxit/50.0;\n\n    col.a = 1.0;\n    \n    return col;\n}\n\nvec4 glitch_ball(vec2 pos){\n    float x = pos.x;\n    float y = pos.y;\n    vec4 col = vec4(0.0);\n    float time = iTime;\n    x = x - floor(x * 260.0) + time/100.0;\n    y = y - floor(y * 30.0) + time/100.0;\n    \n    col.r = sin(13.0 * x + y + PI2 * time + 0.3);\n    col.g = sin((13.0 + 0.006 * cos(time*PI2 + 30.0 * pos.x)) * x + y + PI2 * time + 0.3);\n    col.b = sin((13.0) * x + y + PI2 * time + 0.3);\n    \n    col = abs(col);\n    \n    if(distance(pos, vec2(0.5,0.5)) > 0.4){\n    \tcol *= 0.0;\n    }\n    \n    col.a = 1.0;\n    return col;\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\tfragColor = mandelbrot(uv) * glitch_ball(uv);\n    \n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XltXRl.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[312, 312, 337, 337, 972], [974, 974, 1001, 1001, 1513], [1517, 1517, 1574, 1574, 1670]], "test": "error"}
{"id": "XltXWN", "name": "Collapsing Architecture", "author": "s23b", "description": "a hopefully well-commented raymarched distance field inspired by the windows of my room and the feeling I had with my new glasses on before I got used to them\n\nno actual 3d distance functions were harmed during the making of this scene :octopusballoon:", "tags": ["3d", "raymarch", "distortion", "architecture", "twist"], "likes": 78, "viewed": 1897, "published": "Public API", "date": "1480944719", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define SPEED .5\n#define FOV 1.5\n\n#define MAX_STEPS 100\n#define EPS .00001\n#define RENDER_DIST 10.\n#define AO_SAMPLES 5.\n#define AO_RANGE 10.\n\n#define PI 3.14159265359\n#define saturate(x) clamp(x, 0., 1.)\n\nfloat _twist = 0.;\n\n// simple hash function\nfloat hash(vec3 uv) {\n  float f = fract(sin(dot(uv ,vec3(.009123898,.00231233, .00532234)))* 111111.5452313);\n    return f;\n}\n\n// 3d noise function (linear interpolation between hash of integer bounds)\nfloat noise(vec3 uv) {\n    vec3 fuv = floor(uv);\n    vec4 cell0 = vec4(\n        hash(fuv + vec3(0, 0, 0)),\n        hash(fuv + vec3(0, 1, 0)),\n        hash(fuv + vec3(1, 0, 0)),\n        hash(fuv + vec3(1, 1, 0))\n    );\n    vec2 axis0 = mix(cell0.xz, cell0.yw, fract(uv.y));\n    float val0 = mix(axis0.x, axis0.y, fract(uv.x));\n    vec4 cell1 = vec4(\n        hash(fuv + vec3(0, 0, 1)),\n        hash(fuv + vec3(0, 1, 1)),\n        hash(fuv + vec3(1, 0, 1)),\n        hash(fuv + vec3(1, 1, 1))\n    );\n    vec2 axis1 = mix(cell1.xz, cell1.yw, fract(uv.y));\n    float val1 = mix(axis1.x, axis1.y, fract(uv.x));\n    return mix(val0, val1, fract(uv.z));\n}\n\n// fractional brownian motion\nfloat fbm(vec3 uv) {\n    float f = 0.;\n    float r = 1.;\n    for (int i = 0; i < 5; ++i) {\n        f += noise((uv + 10.) * r) / (r *= 2.);\n    }\n    return f / (1. - 1. / r);\n}\n\n// rotate 2d space with given angle\nvoid tRotate(inout vec2 p, float angel) {\n    float s = sin(angel), c = cos(angel);\n\tp *= mat2(c, -s, s, c);\n}\n\n// dangerous distance-field invalidating space twisting function\nvoid tTwist(inout vec3 p, float a) {\n    tRotate(p.xy, p.z * a);\n}\n\n// repeat space along a single axis\nfloat tRepeat1(inout float p, float r) {\n    float id = floor((p + r * .5) / r);\n    p = mod(p + r * .5, r) - r * .5;\n    return id;\n}\n\n// repeat space along 2 axis\nvec2 tRepeat2(inout vec2 p, vec2 r) {\n    vec2 id = floor((p + r * .5) / r);\n    p = mod(p + r * .5, r) - r * .5;\n    return id;\n}\n\n// rectangle distance\nfloat sdRect(vec2 p, vec2 r) {\n    p = abs(p) - r;\n\treturn min(max(p.x, p.y), 0.) + length(max(p, 0.));\n}\n\n// circle distance\nfloat sdCircle(vec2 p, float r) {\n    return length(p) - r;\n}\n\n// union\nfloat opU(float a, float b) {\n    return min(a, b);\n}\n\n// substraction\nfloat opS(float a, float b) {\n    return max(a, -b);\n}\n\n// distance estimation of the scene\nfloat map(vec3 p)\n{\n    // distort the scene\n    tTwist(p, _twist);\n    \n    // repeat the scene along x and z axis\n    tRepeat2(p.xz, vec2(.7, 1.));\n    \n    // mirror along x\n    p.x = abs(p.x);\n    \n    // lower everything by .5\n    p.y += .5;\n    \n    // add the wall\n    float d = abs(p.z) - .15;\n    \n    // carve out the window\n    float w = opU(sdCircle(p.xy - vec2(0, .75), .25), sdRect(p.xy - vec2(0, .375), vec2(.25, .375)));\n    d = opS(d, w);\n    \n    // make space for the columns\n    d = opS(d, sdRect(p.xy - vec2(0,.35), vec2(.45,.3)));\n    \n    // add the colums\n    d = opU(d, sdCircle(p.xz - vec2(.35, 0), .075));\n    \n    // mirror along z\n    p.z = abs(p.z);\n    \n    // remove extra wall at the column base and top\n    d = opS(d, sdRect(p.yz - vec2(.6, .5), vec2(.6,.4)));\n    \n    // add the ceiling and the floor\n    d = opU(d, -abs(p.y - .5) + .8);\n    return d;\n}\n\n// trace the scene from ro (origin) to rd (direction, normalized)\n// until hit or reached maxDist, outputs distance traveled and the number of steps\nfloat trace(vec3 ro, vec3 rd, float maxDist, out float steps) {\n    float total = 0.;\n    steps = 0.;\n    \n    for (int i = 0; i < MAX_STEPS; ++i) {\n        ++steps;\n        float d = map(ro + rd * total);\n        total += d;\n        if (d < EPS || maxDist < total) break;\n    }\n    \n    return total;\n}\n\n// calculate the normal vector\nvec3 getNormal(vec3 p) {\n    vec2 e = vec2(.0001, 0);\n    return normalize(vec3(\n        map(p + e.xyy) - map(p - e.xyy),\n        map(p + e.yxy) - map(p - e.yxy),\n        map(p + e.yyx) - map(p - e.yyx)\n\t));\n}\n\n// actually there is some mold in the corners of my room that I wanted to show,\n// but for hygenic reasons I'm going to call this effect \"ambient occlusion\"\n// algorithm from Shane\nfloat calculateAO(vec3 p, vec3 n) {\n    \n    float r = 0., w = 1., d;\n    \n    for (float i = 1.; i <= AO_SAMPLES; i++){\n        d = i / AO_SAMPLES / AO_RANGE;\n        r += w * (d - map(p + n * d));\n        w *= .5;\n    }\n    \n    return 1.-saturate(r * AO_RANGE);\n}\n\n// check if the poin in question belongs to a column or the wall\nbool isWall(vec3 p) {\n    p.x += .35;\n    tRepeat2(p.xz, vec2(.7, 1));\n    return .375 < abs(p.y + .15) + length(p.xz);\n}\n\n// texture function\nvec3 _texture(vec3 p) {\n    vec3 t;\n    \n    // apply the twist, so we don't use world coordinates\n    tTwist(p, _twist);\n    bool wall = isWall(p);\n    \n    // if we're in a column, apply distortion to the fbm space\n    t = fbm((p + (wall ? 0. : .1 + .9 * fbm(p * 5.))) * vec3(5., 20., 5.)) * vec3(1., .7, .4) * .75\n        + fbm(p * vec3(2., 10., 2.)) * vec3(1., .8, .5) * .25;\n    \n    // make the walls whiter\n    if (wall) t = mix(t, vec3(1), .5);\n    return saturate(t);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    // transform screen coordinates\n\tvec2 uv = fragCoord.xy / iResolution.xy * 2. - 1.;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    float time = iTime * SPEED;\n    \n    // the degree of distortion\n    _twist = sin(time) * .4;\n    \n    // the camera follow a sinusoid path\n    vec3 ro = vec3(sin(time * PI / 2. + 1.) * 1., 0, time);\n    vec3 rd = normalize(vec3(uv, FOV));\n    \n    // the light source is two steps ahead of the camera\n    time += 2.;\n    vec3 light = vec3(sin(time * PI / 2. + 1.) * 1., 0, time);\n    time -= 2.;\n    \n    // rotate camea and light to compensate for the twist\n    tRotate(rd.xz, -cos(time * PI / 2. + 1.) * .5);\n    tRotate(ro.xy, -ro.z * _twist);\n    tRotate(light.xy, -light.z * _twist);\n    tRotate(rd.xy, -ro.z * _twist);\n    \n    // march\n    float steps, dist = trace(ro, rd, RENDER_DIST, steps); \n    \n    // calculate hit point coordinates\n    vec3 p = ro + rd * dist;\n    \n    // calculate normal\n    vec3 normal = getNormal(p);\n    \n    // light direction\n    vec3 l = normalize(light - p);\n    \n    // calculate shadow\n    vec3 shadowStart = p + normal * EPS * 10.;\n    float shadowDistance = distance(shadowStart,light);\n    float shadowSteps, shadow = float(trace(shadowStart, l, shadowDistance, shadowSteps) > shadowDistance);\n    \n    // the fewer steps to march, the brighter the light\n    // probably no basis in light theory, but I thought it looked good \n    shadow *= 1. - sqrt(shadowSteps / float(MAX_STEPS));\n    \n    // ambient light\n    float ambient = .25;\n    \n    // diffuse light\n    float diffuse = max(0., dot(l, normal));\n    \n    // specular light\n    float specular = pow(max(0., dot(reflect(-l, normal), -rd)), 8.);\n    \n    // \"ambient occlusion\"\n    float ao = calculateAO(p, normal);\n    \n    // add this all up\n\tfragColor.rgb = (ao * _texture(p)) * (ambient + (specular + diffuse) * shadow);\n    \n    // edge glow\n    fragColor *= sqrt(steps / float(MAX_STEPS));\n    \n    // fog\n    fragColor = mix(fragColor, vec4(.9, .8, .7, 1.), saturate(dist * dist * .03));\n    \n    // gamma correction\n    fragColor = pow(fragColor, vec4(1. / 2.2));\n    fragColor.a = 1. - dist / 10.;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XltXWN.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[226, 250, 271, 271, 375], [377, 452, 474, 474, 1097], [1099, 1129, 1149, 1149, 1305], [1307, 1343, 1384, 1384, 1453], [1455, 1520, 1556, 1556, 1586], [1588, 1624, 1664, 1664, 1758], [1760, 1789, 1826, 1826, 1919], [1921, 1943, 1973, 1973, 2048], [2050, 2069, 2102, 2102, 2130], [2132, 2141, 2170, 2170, 2194], [2196, 2212, 2241, 2241, 2266], [2268, 2304, 2323, 2348, 3193], [3195, 3344, 3407, 3407, 3647], [3649, 3680, 3704, 3704, 3889], [3891, 4072, 4107, 4107, 4338], [4340, 4405, 4426, 4426, 4526], [4528, 4548, 4571, 4571, 5026], [5028, 5028, 5083, 5119, 7237]], "test": "valid"}
{"id": "XltXWS", "name": "dots_exp", "author": "markthomas", "description": "dots ya", "tags": ["dots"], "likes": 1, "viewed": 506, "published": "Public API", "date": "1481428561", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float r( vec2 s) {return fract(9993.*sin(s.x*9.+s.y*7.));}\nvoid mainImage(out vec4 o, vec2 i){\n    vec2 j = fract(i*=99./iResolution.x), \n         p = i-j+ vec2(3,floor(iTime*50.*fract(sin(i-j).x)));\n    i = abs(j-.2);\n    o =  vec4(r(ceil(p*9.+5.*j))>.5&&i.x<.3&&i.y<.100 ?   1. - r(p)*(4.-dot(i+1.,i)*12.)  :  2.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XltXWS.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 18, 18, 58], [59, 59, 94, 94, 318]], "test": "valid"}
{"id": "XlVSRR", "name": "New Tree Year Ivan", "author": "zpix", "description": "NEW YEAR", "tags": ["newyear"], "likes": 1, "viewed": 80, "published": "Public", "date": "1482644368", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float nar = 100.;\n\nfloat sdTriangle( in vec2 p1, in vec2 p2, in vec2 p3, in vec2 p )\n{\n    vec2 e0 = p2 - p1;  vec2 e1 = p3 - p2;  vec2 e2 = p1 - p3;\n\tvec2 v0 = p - p1;   vec2 v1 = p - p2;   vec2 v2 = p - p3;\n\n\tvec2 pq0 = v0 - e0*clamp( dot(v0,e0) / dot(e0,e0), 0.0, 1.0 );\n\tvec2 pq1 = v1 - e1*clamp( dot(v1,e1) / dot(e1,e1), 0.0, 1.0 );\n\tvec2 pq2 = v2 - e2*clamp( dot(v2,e2) / dot(e2,e2), 0.0, 1.0 );\n    \n    vec2 d = min( min( vec2( dot(pq0, pq0), v0.x*e0.y-v0.y*e0.x ),\n                       vec2( dot(pq1, pq1), v1.x*e1.y-v1.y*e1.x )),\n                       vec2( dot(pq2, pq2), v2.x*e2.y-v2.y*e2.x ));\n\n\treturn -sqrt(d.x)*sign(d.y);\n}\n\nvec4 triangles(vec2 uv,float level,float xc){\n    float ans = 0.;\n    float x,y,width,offset;\n    if (iTime<nar){\n        x = 0.5;\n        y = 0.9;\n        width = 0.1;\n        offset = 0.05;\n    } else {\n    \tx = 0.5;\n        y = 0.9;\n        width = 0.1*cos(iTime);\n        offset = 0.05;\n    }\n    ans += sdTriangle(vec2(x, y - width*level + offset), vec2(x+width*xc, y-width-width*level), vec2(x-width*xc, y-width-width*level), uv);\t\n    return vec4(0.1,sin(uv.y + width*level + offset),0.,ans);\n}\nfloat stvol(vec2 uv){\n    float ans = 5.;\n   \tfloat x,y,width;\n    if (iTime<nar){\n        x = 0.5;\n        y = 0.3;\n    } else {\n    \tx = 0.5;\n        y = 0.3*cos(iTime);\n    }\n    width = 0.05;\n    if ((uv.x<x+width)&&(uv.x>x-width)&&(uv.y<y)&&(uv.y>0.2))ans=0.;\n    return ans;\n}\n\nfloat round(vec2 uv, vec2 toy){\n    if((uv.x-toy.x)*(uv.x-toy.x)+(uv.y-toy.y)*(uv.y-toy.y) < 0.01*0.01) return 0.;\n    return 5.;\n}\n\nvec4 toys(vec2 uv){\n    const int l = 8;\n    vec2 toys[l];\n    float r = 0.01;\n\ttoys[0] = vec2(0.45,0.6);\n\ttoys[1]  = vec2(0.52,0.7);\n    toys[3]  = vec2(0.5,0.4);\n    toys[4]  = vec2(0.55,0.5);\n    toys[5]  = vec2(0.52,0.7);\n    toys[6]  = vec2(0.45,0.35);\n    toys[7]  = vec2(0.47,0.5);\n    for (int i=0;i<l;i++)\n        if (round(uv,toys[i])==0.){\n            return vec4(2.*uv.y,1.*sin(iTime+float(i)*100.),0.1*float(i),0.);\n        }\n    return vec4(vec3(1.),5.);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    if (iTime < nar){\n        for(float l = 1.;l<=5.;l+=1.){\n            if (toys(uv).a <= 0.01){\n                fragColor = toys(uv);\n            }else if(triangles(uv,l,0.3*l).a <= 0.01) {\n                fragColor = triangles(uv,l,0.3);\n                break;\n            } else if (stvol(uv) <= 0.01){\n                fragColor = vec4(0.6,0.5,0.,1.);\n            } else {\n                fragColor = vec4(vec3(1.), 0.);\n            }\n        }\n    } else {\n    \tfor(float l = 1.;l<=5.;l+=1.){\n            if (toys(uv).a <= 0.01){\n                fragColor = toys(uv);\n            }else if(triangles(uv,l,0.3*l).a <= 0.01*abs(sin(iTime))) {\n                fragColor = vec4(triangles(uv,l,0.3).r*cos(iTime),triangles(uv,l,0.3).gba);\n                break;\n            } else if (stvol(uv) <= 0.01*abs(sin(iTime))){\n                fragColor = vec4(0.6,0.5,0.,1.);\n            } else {\n                fragColor = vec4(0.3*sin(iTime)+0.5,0.,0.5*cos(iTime), 0.);\n            }\n        }\n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XlVSRR.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[19, 19, 86, 86, 642], [644, 644, 689, 689, 1145], [1146, 1146, 1167, 1167, 1428], [1430, 1430, 1461, 1461, 1561], [1563, 1563, 1582, 1582, 2033], [2035, 2035, 2092, 2092, 3134]], "test": "error"}
{"id": "XlVSz1", "name": "golden ratio", "author": "KitVanDeBunt", "description": "This is probably a really un-efficient way to do this because of the for loop but I don't know a better way to do this.", "tags": ["2d", "goldenratio"], "likes": 3, "viewed": 172, "published": "Public", "date": "1483002224", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define TAU 6.2831853071\n#define PI 3.14159265359\n#define GOLD 1.6180339887\n#define N 0.998\t\t\t// particle move distance\n#define S 0.1\t\t\t// Speed\n#define PS 20.0\t\t\t// particle size\n\n#define option 0\t\t// 0 or 1\n\n#if option\nvec4 lerp(float t, vec4 A, vec4 B){\n \treturn (A*(1.0-t))+(B*t);\n}\n#endif\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 r = iResolution.xy;\n\tvec2 uv = 0.5 + (fragCoord -.5*r)/r.y;\n    \n    float particlePower = 0.0;\n    for(float p = 0.0; p < N; p+=0.001){\n        float pAngle = p*1000.0*GOLD;\n        float pDist = mod(iTime*S+p,N);\n        vec2 point = vec2(sin(pAngle),cos(pAngle))*pDist;\n        point = point+0.5;\n        float pd = length(point-uv);\n        #if option\n        \tfragColor = lerp(pd*PS,fragColor,vec4(0,0,1,1));\n        #else\n        \tparticlePower += clamp(((.08*clamp(pDist,0.4,0.65))-pd)*PS,0.0,0.5);\n        #endif\n    }\n    #if !option\n        particlePower = clamp(particlePower*1.3,0.0,1.0);\n        float pp = particlePower;\n        float b = 0.5*(1.0-particlePower);\n        fragColor = vec4(pp,pp+(b*0.5),b*0.6,0.0);\n    #endif\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XlVSz1.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[295, 295, 352, 352, 1103]], "test": "valid"}
{"id": "XlVSzh", "name": "Cyber Space", "author": "Xor", "description": "I'm not good at descriptions.\nEdit: Reduced from around 500 chars to 237 thanks to iq and FabriceNeyret2.", "tags": ["3d", "voxels", "light", "glow"], "likes": 10, "viewed": 411, "published": "Public", "date": "1482867208", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/*\n\t\"Cyber Space\" by Xor\n\n\tIt was shortened thanks to iq and FabriceNeyret2.\n*/\nvoid mainImage(out vec4 O,vec2 I)\n{\n    vec3 R = iResolution;\n    \n    R = vec3(2, (I+I-R.xy)/R.y);\n\n    O -= O;\n\n    for (float i = -8.; i<8.; i+=.1)\n        O += vec4(.3,.6,1,0) *\n        \t (1.-i*i/64.) *\n             smoothstep(.99,1.,\n             fract(3e2*cos(dot(floor(iTime*vec3(4,1,0)+(i+14.)*R), vec3(7,8,86)))));\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XlVSzh.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 80, 115, 115, 405]], "test": "valid"}
{"id": "XlVXzh", "name": "Kleinian group limit set", "author": "JosLeys", "description": "Kleinian group limit set.", "tags": ["fractal"], "likes": 21, "viewed": 1632, "published": "Public API", "date": "1482877206", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//By Jos Leys ( with the help of Knighty)\n\nvec3  background1Color=vec3(1.0,1.0,1.0);\nvec3  background2Color=vec3(1.0,1.0,0.5);\nvec2  ambientColor=vec2(0.5,0.3);\nvec3  color2=vec3(0.2,0.6,0.0);\nfloat specularExponent=4.;\nfloat specularity=0.8;\nvec3 from=vec3(0.0,0.975,-5.0);\n\n\n\nfloat box_size_x=1.;\nfloat box_size_z=1.;\nvec3 light=vec3(50,10,-50);\nfloat slice_start=-1.;\nfloat slice_end=1.;\nfloat fudge_factor=0.5;\n\n//sphere inversion\nbool SI=false;\nvec3 InvCenter=vec3(1,.96,0.);\nfloat rad=0.8;\n\nvec2 wrap(vec2 x, vec2 a, vec2 s){\n\tx -= s; \n\treturn (x-a*floor(x/a)) + s;\n}\n\nvoid TransA(inout vec3 z, inout float DF, float a, float b){\n\tfloat iR = 1. / dot(z,z);\n\tz *= -iR;\n\tz.x = -b - z.x; z.y = a + z.y; \n\tDF *= iR;//max(1.,iR);\n}\n\nfloat  JosKleinian(vec3 z)\n{\n    float KleinR = 1.94+0.05*abs(sin(-iTime*0.5));//1.95859103011179;\n   float KleinI = 0.03*cos(-iTime*0.5);//0.0112785606117658;\n\tvec3 lz=z+vec3(1.), llz=z+vec3(-1.);\n    float d=0.; float d2=0.;\n    \n    if(SI) {\n             z=z-InvCenter;\n\t\td=length(z);\n\t\td2=d*d;\n\t\tz=(rad*rad/d2)*z+InvCenter;\n            }\n\n\tfloat DE=1e10;\n\tfloat DF = 1.0;\n\tfloat a = KleinR;\n    float b = KleinI;\n\tfloat f = sign(b)*1. ;     \n\tfor (int i = 0; i < 20 ; i++) \n\t{\n\t\tz.x=z.x+b/a*z.y;\n\t\tz.xz = wrap(z.xz, vec2(2. * box_size_x, 2. * box_size_z), vec2(- box_size_x, - box_size_z));\n\t\tz.x=z.x-b/a*z.y;\n               \n\t\t//If above the separation line, rotate by 180 about (-b/2, a/2)\n        if  (z.y >= a * 0.5 + f *(2.*a-1.95)/4. * sign(z.x + b * 0.5)* (1. - exp(-(7.2-(1.95-a)*15.)* abs(z.x + b * 0.5))))\t\n        {z = vec3(-b, a, 0.) - z;}\n        \n\t\t//Apply transformation a\n\t\tTransA(z, DF, a, b);\n\t\t\n\t\t//If the iterated points enters a 2-cycle , bail out.\n        if(dot(z-llz,z-llz) < 1e-5) {break;}\n\t\t\n\t\t//Store prvious iterates\n\t\tllz=lz; lz=z;\n\t}\n\t\n\t\n\tfloat y =  min(z.y, a-z.y) ;\n\tDE=min(DE,min(y,0.3)/max(DF,2.));\n      if (SI) {DE=DE*d2/(rad+d*DE);}\n\treturn DE;\n}\n\n\n\nfloat trace(vec3 ro, vec3 rd, float start,inout bool hit) {\n    float dist=100.0;\n    float t =start;\n    for (int i = 0;  i < 200  ;i++) {\n        if (t>(-ro.z+slice_end)/rd.z) {hit=false; break;}\n        dist = JosKleinian(ro+t*rd);\n        if (dist<1./pow(10.,3.5)) {break;}\n        t += fudge_factor*dist;\n    }\n    return t;\n}\n\nvec3 blinnPhong(vec3 color, vec3 p, vec3 n)\n{\n\t// Ambient colour based on background gradient\n      float HALFPI=3.14159/2.;\n\tvec3 ambColor = clamp(mix(background2Color, background1Color, (sin(n.y * HALFPI) + 1.0) * 0.5), 0.0, 1.0);\n\tambColor = mix(vec3(ambientColor.x), ambColor, ambientColor.y);\n\tvec3  halfLV = normalize(light - p);\n\tfloat diffuse = max(dot(n, halfLV), 0.0);\n\tfloat specular = pow(diffuse, specularExponent);\n\t\n\treturn ambColor * color + color * diffuse + specular * specularity;\n}\n\n\nvec3 generateNormal(float afst,vec3 rd, vec3 from)\n{\n\tfloat eps =0.001; bool hit=true;\n   \tvec3 ray=  from+rd*afst;\n\t\n\tfloat start=afst-.1;\n\t\n    vec3 ray1=from+vec3(eps,0,0)+ rd*trace(from+vec3(eps,0,0), rd,start,hit );\n\tvec3 ray2=from+vec3(0,eps,0)+ rd*trace(from+vec3(0,eps,0), rd,start,hit );\n\tvec3 ray3=from+vec3(-eps,0,0)+ rd*trace(from+vec3(-eps,0,0), rd,start,hit );\n\t\n\tvec3 n1=normalize(-cross(ray1-ray,ray2-ray));\n\tvec3 n2=normalize(-cross(ray2-ray,ray3-ray));\n\t\n\tvec3 n=(n1+n2)/2.;\n\treturn n;\n}\n\nvec3  detcol( vec3  ray_direction)   \n{\n\tbool hit=true;\n    float start=(-from.z+slice_start)/ray_direction.z;\n\tfloat afst= trace(from, ray_direction,start,hit);\n\tvec3 ray=from+afst* ray_direction;\n      \n\nif ( !hit) {return background1Color;\t }  \n\nelse {\t\n    vec4  color;\n\tvec3 normal = generateNormal(afst,ray_direction,from);\n\tcolor.rgb = blinnPhong(clamp(color2, 0.0, 1.0), ray, normal);\n\t\n\t// Shadows\n\t\tvec3 light_direction=normalize(ray-light);\n\t\tfloat startlight=(-light.z+slice_start)/light_direction.z;\n\t\tfloat afstlight= trace(light,light_direction,startlight,hit);\n\t\tif (abs(afstlight-length(light-ray))>0.001) {color.rgb *=0.8;}\n\t\n\t\n\treturn color.xyz;}\n\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n   \tvec2 uv = fragCoord.xy / iResolution.xy;\n    uv = (3.0)*uv-vec2(1.5,.5);\n    uv.x *= iResolution.x/iResolution.y;\n    \n   \n    vec3 rd = normalize(vec3(uv,0.)-from);\n\n    float start=(-from.z-1.)/rd.z;\n\n    \n    vec3 c =detcol(rd);\n\tfragColor = vec4(c, 1.0);\n    \n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XlVXzh.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[497, 497, 531, 531, 573], [575, 575, 635, 635, 732], [734, 734, 762, 762, 1925], [1929, 1929, 1988, 1988, 2260], [2262, 2262, 2307, 2355, 2763], [2766, 2766, 2818, 2818, 3271], [3273, 3273, 3312, 3312, 3941], [3943, 3943, 4000, 4000, 4275]], "test": "valid"}
{"id": "XlySz1", "name": "Chains and Gears (tweaked)", "author": "MobileForks01", "description": "Fork to make it run faster on my phone.  So far, just changed the #define constants.\n\nOriginal : https://www.shadertoy.com/view/Msl3Rn", "tags": ["raymarching"], "likes": 1, "viewed": 500, "published": "Public API", "date": "1482732393", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// chains and gears - @P_Malin\n    \n//#define ENABLE_AMBIENT_OCCLUSION\n//#define ENABLE_SPECULAR\n//#define ENABLE_REFLECTIONS\n//#define ENABLE_SHADOWS\n#define ENABLE_FOG\n\n#define ENABLE_DIRECTIONAL_LIGHT\n#define ENABLE_DIRECTIONAL_LIGHT_FLARE\n\n//#define ENABLE_POINT_LIGHT\n//#define ENABLE_POINT_LIGHT_FLARE\n\n#define kRaymarchMaxIter 28\n\nconst float kPI = 3.141592654;\nconst float kTwoPI = kPI * 2.0;\n\nstruct C_Ray\n{\n    vec3 vOrigin;\n    vec3 vDir;\n    float fStartDistance;\n    float fLength;\n};\n\nstruct C_HitInfo\n{\n    vec3 vPos;\n    float fDistance;\n    vec3 vObjectId;\n};\n    \nstruct C_Surface\n{\n    vec3 vNormal;\n    vec3 cReflection;\n    vec3 cTransmission;    \n};\n\nstruct C_Material\n{\n    vec3 cAlbedo;\n    float fR0;\n    float fSmoothness;\n    vec2 vParam;\n};\n\nstruct C_Shading\n{\n    vec3 cDiffuse;\n    vec3 cSpecular;\n};\n\nstruct C_PointLight\n{\n    vec3 vPos;\n    vec3 cColour;\n};\n\nstruct C_DirectionalLight\n{\n    vec3 vDir;\n    vec3 cColour;\n};\n\nvec3 RotateX( const in vec3 vPos, const in float fAngle )\n{\n    float s = sin(fAngle);\n    float c = cos(fAngle);\n    \n    vec3 vResult = vec3( vPos.x, c * vPos.y + s * vPos.z, -s * vPos.y + c * vPos.z);\n    \n    return vResult;\n}\n\nvec3 RotateY( const in vec3 vPos, const in float fAngle )\n{\n    float s = sin(fAngle);\n    float c = cos(fAngle);\n    \n    vec3 vResult = vec3( c * vPos.x + s * vPos.z, vPos.y, -s * vPos.x + c * vPos.z);\n    \n    return vResult;\n}\n\nvec3 RotateZ( const in vec3 vPos, const in float fAngle )\n{\n    float s = sin(fAngle);\n    float c = cos(fAngle);\n    \n    vec3 vResult = vec3( c * vPos.x + s * vPos.y, -s * vPos.x + c * vPos.y, vPos.z);\n    \n    return vResult;\n}\n\n/////////////////////////////////////\n// Distance Field CSG\n// These carry with them the material parameters in yzw\n\nvec4 DistCombineUnion( const in vec4 v1, const in vec4 v2 )\n{\n    //if(v1.x < v2.x) return v1; else return v2;\n    return mix(v1, v2, step(v2.x, v1.x));\n}\n\nvec4 DistCombineUnionConditional( const in vec4 v1, const in vec4 v2, const in float fCondition )\n{    \n\t//if( fCondition < 0.0 )\n\t//            return v1;\n                \n    return mix(v1, v2, step(v2.x, v1.x) * step(0.0, fCondition));\n}\n\nvec4 DistCombineIntersect( const in vec4 v1, const in vec4 v2 )\n{\n    return mix(v2, v1, step(v2.x,v1.x));\n}\n\nvec4 DistCombineSubtract( const in vec4 v1, const in vec4 v2 )\n{\n    return DistCombineIntersect(v1, vec4(-v2.x, v2.yzw));\n}\n\nvec3 DomainRepeatXZGetTile( const in vec3 vPos, const in vec2 vRepeat, out vec2 vTile )\n{\n\tvec3 vResult = vPos;\n\tvec2 vTilePos = (vPos.xz / vRepeat) + 0.5;\n\tvTile = floor(vTilePos + 1000.0);\n\tvResult.xz = (fract(vTilePos) - 0.5) * vRepeat;\n\treturn vResult;\n}\n\nvec3 DomainRepeatXZ( const in vec3 vPos, const in vec2 vRepeat )\n{\n\tvec3 vResult = vPos;\n\tvec2 vTilePos = (vPos.xz / vRepeat) + 0.5;\n\tvResult.xz = (fract(vTilePos) - 0.5) * vRepeat;\n\treturn vResult;\n}\n\nvec3 DomainRepeatY( const in vec3 vPos, const in float fSize )\n{\n\tvec3 vResult = vPos;\n\tvResult.y = (fract(vPos.y / fSize + 0.5) - 0.5) * fSize;\n\treturn vResult;\n}\n\nvec3 DomainRotateSymmetry( const in vec3 vPos, const in float fSteps )\n{\n\tfloat angle = atan( vPos.x, vPos.z );\n\t\n\tfloat fScale = fSteps / (kPI * 2.0);\n\tfloat steppedAngle = (floor(angle * fScale + 0.5)) / fScale;\n\t\n\tfloat s = sin(-steppedAngle);\n\tfloat c = cos(-steppedAngle);\n\t\n\tvec3 vResult = vec3( c * vPos.x + s * vPos.z, \n\t\t\t     vPos.y,\n\t\t\t     -s * vPos.x + c * vPos.z);\n\t\n\treturn vResult;\n}\n\nfloat GetDistanceXYTorus( const in vec3 p, const in float r1, const in float r2 )\n{\n   vec2 q = vec2(length(p.xy)-r1,p.z);\n   return length(q)-r2;\n}\n\nfloat GetDistanceYZTorus( const in vec3 p, const in float r1, const in float r2 )\n{\n   vec2 q = vec2(length(p.yz)-r1,p.x);\n   return length(q)-r2;\n}\n\nfloat GetDistanceCylinderY(const in vec3 vPos, const in float r)\n{\n\treturn length(vPos.xz) - r;\n}\n\nfloat GetDistanceChain( const in vec3 vPos )\n{\n\tfloat fOuterCylinder = length(vPos.xz) - 1.05;\n\tif(fOuterCylinder > 0.5)\n\t{\n\t\treturn fOuterCylinder;\n\t}\n\t\n\tvec3 vChainDomain = vPos;\n\t\n\tvChainDomain.y = fract(vChainDomain.y + 0.5) - 0.5;\t\t\n\tfloat fDistTorus1 = GetDistanceXYTorus(vChainDomain, 0.35, 0.1);\n\t\n\tvChainDomain.y = fract(vChainDomain.y + 1.0) - 0.5;\t\t\n\tfloat fDistTorus2 = GetDistanceYZTorus(vChainDomain, 0.35, 0.1);\n\t\n\tfloat fDist = min(fDistTorus1, fDistTorus2);\n\n\treturn fDist;\n}\n\nfloat GetDistanceGear( const in vec3 vPos )\n{\n\tfloat fOuterCylinder = length(vPos.xz) - 1.05;\n\tif(fOuterCylinder > 0.5)\n\t{\n\t\treturn fOuterCylinder;\n\t}\n\t\n\tvec3 vToothDomain = DomainRotateSymmetry(vPos, 16.0);\n\tvToothDomain.xz = abs(vToothDomain.xz);\n\tfloat fGearDist = dot(vToothDomain.xz,normalize(vec2(1.0, 0.55))) - 0.55;\n\tfloat fSlabDist = abs(vPos.y + 0.1) - 0.15;\n\t\n\tvec3 vHoleDomain = abs(vPos);\n\tvHoleDomain -= 0.35;\n\tfloat fHoleDist = length(vHoleDomain.xz) - 0.2;\n\t\n\tfloat fBarDist =vToothDomain.z - 0.15;\n\tfBarDist = max(vPos.y - 0.1, fBarDist);\n\t\n\tfloat fResult = fGearDist;\n\tfResult = max(fResult, fSlabDist);\n\tfResult = max(fResult, fOuterCylinder);\n\tfResult = max(fResult, -fHoleDist);\n\tfResult = min(fResult, fBarDist);\n\treturn fResult;\n}\n\nvec4 GetDistanceScene( const in vec3 vPos )\n{             \t\n\tvec2 vChainTile;\n\tvec2 vRepeat = vec2(4.0, 8.0);\n\tvec3 vRepeatDomain = DomainRepeatXZGetTile(vPos, vRepeat, vChainTile);\n\t\t\n\tvec4 vDistFloor = vec4(vPos.y + 0.5, 1.0, vec2(0.0));\n\tvec4 vResult = vDistFloor;\n\t{\n\t\tvec3 vGearDomain1 = DomainRepeatXZ(vPos+vec3(0.0, 0.0, 4.0), vRepeat);\n\t\tvGearDomain1 = RotateY( vGearDomain1, iTime);\n\t\tvec4 vDistGear = vec4(GetDistanceGear(vGearDomain1), 3.0, vec2(0.0));\n\t\tvResult = DistCombineUnion( vResult, vDistGear );\n\t\t\n\t\tvec3 vGearDomain2 = DomainRepeatXZ(vPos+vec3(2.0, 0.0, 4.0), vRepeat);\n\t\tvGearDomain2 = RotateY( vGearDomain2, -iTime + (2.0 * kPI / 32.0));\n\t\tvec4 vDistGear2 = vec4(GetDistanceGear(vGearDomain2), 3.0, vec2(0.0));\t\t\n\t\tvResult = DistCombineUnion( vResult, vDistGear2 );\n\t\t\n\t}\n\n\t{\n\t\tvec4 vDistChainHole = vec4( GetDistanceCylinderY(vRepeatDomain, 0.7), 2.0, vec2(0.0));\n\t\tvResult = DistCombineSubtract( vResult, vDistChainHole );\n\n\t\tvec3 vChainDomain = vRepeatDomain;\n\t\tfloat fSpeed = (sin(vChainTile.y + vChainTile.x) + 1.1) * 0.5;\n\t\tvChainDomain.y += sin(iTime * fSpeed);\n\t\tvec4 vDistChain = vec4( GetDistanceChain(vChainDomain), 4.0, vec2(0.0));\n\t\tvResult = DistCombineUnion( vResult, vDistChain );\n\t}\n\treturn vResult;\n}\n\nC_Material GetObjectMaterial( const in C_HitInfo hitInfo )\n{\n\tC_Material mat;\n\n\tif(hitInfo.vObjectId.x < 1.5)\n\t{\n\t\t// floor\n\t\tmat.fR0 = 0.02;\n\t\tmat.fSmoothness = 0.8;\n\t\tmat.cAlbedo = vec3(0.7, 0.8, 0.3);\n\t}\n\telse\n\tif(hitInfo.vObjectId.x < 2.5)\n\t{\n\t\t// hole interior\n\t\tmat.fR0 = 0.0;\n\t\tmat.fSmoothness = 0.0;\n\t\tmat.cAlbedo = vec3(0.7, 0.8, 0.3);\n\t}\n\telse\n\tif(hitInfo.vObjectId.x < 3.5)\n\t{\n\t\t// gear\n\t\tmat.fR0 = 0.4;\n\t\tmat.fSmoothness = 0.7;\n\t\tmat.cAlbedo = vec3(0.5, 0.6, 0.6);\n\t}\n\telse\n\t{\n\t\t// chain\n\t\tmat.fR0 = 0.2;\n\t\tmat.fSmoothness = 0.1;\n\t\tmat.cAlbedo = vec3(0.15, 0.125, 0.1);\n\t}\n\t\n\treturn mat;\n}\n\nfloat GetRayFirstStep( const in C_Ray ray )\n{\n    return ray.fStartDistance;  \n}\n\n\nvec3 GetSkyGradient( const in vec3 vDir )\n{\n    const vec3 cColourTop = vec3(2.0*0.7, 0.5, 1.0);\n    const vec3 cColourHorizon = vec3(2.0*0.2, 0.3, 0.4);\n\n    float fBlend = clamp(vDir.y, 0.0, 1.0);\n    return mix(cColourHorizon, cColourTop, fBlend);\n}\n\nC_PointLight GetPointLight()\n{\n    C_PointLight result;\n\n    result.vPos = vec3(sin(iTime), 2.0 + cos(iTime * 1.231), cos(iTime));\n    result.cColour = vec3(32.0, 6.0, 1.0);\n\n    return result;\n}\n\nC_DirectionalLight GetDirectionalLight()\n{\n    C_DirectionalLight result;\n\n    result.vDir = normalize(vec3(-0.2, -0.3, 0.5));\n    result.cColour = vec3(8.0, 7.5, 7.0);\n\n    return result;\n}\n\nvec3 GetAmbientLight(const in vec3 vNormal)\n{\n    return GetSkyGradient(vNormal);\n}\n\n/////////////////////////////////////\n// Raymarching \n\nvec3 GetSceneNormal( const in vec3 vPos )\n{\n    // tetrahedron normal\n    const float fDelta = 0.01;\n\n    vec3 vOffset1 = vec3( fDelta, -fDelta, -fDelta);\n    vec3 vOffset2 = vec3(-fDelta, -fDelta,  fDelta);\n    vec3 vOffset3 = vec3(-fDelta,  fDelta, -fDelta);\n    vec3 vOffset4 = vec3( fDelta,  fDelta,  fDelta);\n\n    float f1 = GetDistanceScene( vPos + vOffset1 ).x;\n    float f2 = GetDistanceScene( vPos + vOffset2 ).x;\n    float f3 = GetDistanceScene( vPos + vOffset3 ).x;\n    float f4 = GetDistanceScene( vPos + vOffset4 ).x;\n\n    vec3 vNormal = vOffset1 * f1 + vOffset2 * f2 + vOffset3 * f3 + vOffset4 * f4;\n\n    return normalize( vNormal );\n}\n\n#define kRaymarchEpsilon 0.01\n// This is an excellent resource on ray marching -> http://www.iquilezles.org/www/articles/distfunctions/distfunctions.htm\nvoid Raymarch( const in C_Ray ray, out C_HitInfo result, const int maxIter )\n{        \n    result.fDistance = GetRayFirstStep( ray );\n    result.vObjectId.x = 0.0;\n        \n    for(int i=0;i<=kRaymarchMaxIter;i++)              \n    {\n        result.vPos = ray.vOrigin + ray.vDir * result.fDistance;\n        vec4 vSceneDist = GetDistanceScene( result.vPos );\n        result.vObjectId = vSceneDist.yzw;\n        \n        // abs allows backward stepping - should only be necessary for non uniform distance functions\n        if((abs(vSceneDist.x) <= kRaymarchEpsilon) || (result.fDistance >= ray.fLength) || (i > maxIter))\n        {\n            break;\n        }                        \n\n        result.fDistance = result.fDistance + vSceneDist.x; \n    }\n\n\n    if(result.fDistance >= ray.fLength)\n    {\n        result.fDistance = 1000.0;\n        result.vPos = ray.vOrigin + ray.vDir * result.fDistance;\n        result.vObjectId.x = 0.0;\n    }\n}\n\nfloat GetShadow( const in vec3 vPos, const in vec3 vNormal, const in vec3 vLightDir, const in float fLightDistance )\n{\n    #ifdef ENABLE_SHADOWS\n\t\tC_Ray shadowRay;\n\t\tshadowRay.vDir = vLightDir;\n\t\tshadowRay.vOrigin = vPos;\n\t\tconst float fShadowBias = 0.05;\n\t\tshadowRay.fStartDistance = fShadowBias / abs(dot(vLightDir, vNormal));\n\t\tshadowRay.fLength = fLightDistance - shadowRay.fStartDistance;\n\t\n\t\tC_HitInfo shadowIntersect;\n\t\tRaymarch(shadowRay, shadowIntersect, 32);\n\t\t\n\t\tfloat fShadow = step(0.0, shadowIntersect.fDistance) * step(fLightDistance, shadowIntersect.fDistance );\n\t\t\n\t\treturn fShadow;          \n    #else\n    \treturn 1.0;\n    #endif\n}\n\n// use distance field to evaluate ambient occlusion\nfloat GetAmbientOcclusion(const in C_HitInfo intersection, const in C_Surface surface)\n{\n    #ifdef ENABLE_AMBIENT_OCCLUSION    \n\t\tvec3 vPos = intersection.vPos;\n\t\tvec3 vNormal = surface.vNormal;\n\t\n\t\tfloat fAmbientOcclusion = 1.0;\n\t\n\t\tfloat fDist = 0.0;\n\t\tfor(int i=0; i<=5; i++)\n\t\t{\n\t\t\tfDist += 0.1;\n\t\n\t\t\tvec4 vSceneDist = GetDistanceScene(vPos + vNormal * fDist);\n\t\n\t\t\tfAmbientOcclusion *= 1.0 - max(0.0, (fDist - vSceneDist.x) * 0.2 / fDist );                                  \n\t\t}\n\t\n\t\treturn fAmbientOcclusion;\n    #else\n\t    return 1.0;\n    #endif    \n}\n\n/////////////////////////////////////\n// Lighting and Shading\n\n#define kFogDensity 0.5\n\nvoid ApplyAtmosphere(inout vec3 col, const in C_Ray ray, const in C_HitInfo hitInfo)\n{\n    #ifdef ENABLE_FOG\n    // fog\n    float fFogAmount = exp(hitInfo.fDistance * -kFogDensity);\n    vec3 cFog = GetSkyGradient(ray.vDir);\n\n    #ifdef ENABLE_DIRECTIONAL_LIGHT_FLARE\n    C_DirectionalLight directionalLight = GetDirectionalLight();\n    float fDirDot = clamp(dot(-directionalLight.vDir, ray.vDir), 0.0, 1.0);\n    cFog += directionalLight.cColour * pow(fDirDot, 10.0);\n    #endif \n\n    col = mix(cFog, col, fFogAmount);\n    #endif\n\n    // glare from light (a bit hacky - use length of closest approach from ray to light)\n    #ifdef ENABLE_POINT_LIGHT_FLARE\n    C_PointLight pointLight = GetPointLight();\n\n    vec3 vToLight = pointLight.vPos - ray.vOrigin;\n    float fPointDot = dot(vToLight, ray.vDir);\n    fPointDot = clamp(fPointDot, 0.0, hitInfo.fDistance);\n\n    vec3 vClosestPoint = ray.vOrigin + ray.vDir * fPointDot;\n    float fDist = length(vClosestPoint - pointLight.vPos);\n    col += pointLight.cColour * 0.01/ (fDist * fDist);\n    #endif    \n}\n\n// http://en.wikipedia.org/wiki/Schlick's_approximation\nfloat Schlick( const in vec3 vNormal, const in vec3 vView, const in float fR0, const in float fSmoothFactor)\n{\n    float fDot = dot(vNormal, -vView);\n    fDot = clamp((1.0 - fDot), 0.0, 1.0);\n    float fDotPow = pow(fDot, 5.0);\n    return fR0 + (1.0 - fR0) * fDotPow * fSmoothFactor;\n}\n\nvec3 ApplyFresnel(const in vec3 vDiffuse, const in vec3 vSpecular, const in vec3 vNormal, const in vec3 vView, const in C_Material material)\n{\n    float fFresnel = Schlick(vNormal, vView, material.fR0, material.fSmoothness * 0.9 + 0.1);\n    return mix(vDiffuse, vSpecular, fFresnel);    \n}\n\nfloat GetBlinnPhongIntensity(const in vec3 vIncidentDir, const in vec3 vLightDir, const in vec3 vNormal, const in float fSmoothness)\n{          \n    vec3 vHalf = normalize(vLightDir - vIncidentDir);\n    float fNdotH = max(0.0, dot(vHalf, vNormal));\n\n    float fSpecPower = exp2(4.0 + 6.0 * fSmoothness);\n    float fSpecIntensity = (fSpecPower + 2.0) * 0.125;\n\n    return pow(fNdotH, fSpecPower) * fSpecIntensity;\n}\n\nC_Shading ApplyPointLight( const in C_PointLight light, const in vec3 vSurfacePos, const in vec3 vIncidentDir, const in vec3 vNormal, const in C_Material material )\n{\n    C_Shading shading;\n    \n    vec3 vToLight = light.vPos - vSurfacePos;\n    vec3 vLightDir = normalize(vToLight);\n    float fLightDistance = length(vToLight);\n    \n    float fAttenuation = 1.0 / (fLightDistance * fLightDistance);\n    \n    float fShadowFactor = GetShadow( vSurfacePos, vNormal, vLightDir, fLightDistance );\n    vec3 vIncidentLight = light.cColour * fShadowFactor * fAttenuation * max(0.0, dot(vLightDir, vNormal));\n    \n    shading.cDiffuse = vIncidentLight;                                  \n    shading.cSpecular = GetBlinnPhongIntensity( vIncidentDir, vLightDir, vNormal, material.fSmoothness ) * vIncidentLight;\n    \n    return shading;\n}  \n\nC_Shading ApplyDirectionalLight( const in C_DirectionalLight light, const in vec3 vSurfacePos, const in vec3 vIncidentDir, const in vec3 vNormal, const in C_Material material )\n{\n    C_Shading shading;\n\n    const float kShadowRayLength = 10.0;      \n    vec3 vLightDir = -light.vDir;\n    float fShadowFactor = GetShadow( vSurfacePos, vNormal, vLightDir, kShadowRayLength );\n    vec3 vIncidentLight = light.cColour * fShadowFactor * max(0.0, dot(vLightDir, vNormal));\n    \n    shading.cDiffuse = vIncidentLight;                                  \n    shading.cSpecular = GetBlinnPhongIntensity( vIncidentDir, vLightDir, vNormal, material.fSmoothness ) * vIncidentLight;\n    \n    return shading;\n}  \n\n\nvec3 ShadeSurface(const in C_Ray ray, const in C_HitInfo hitInfo, const in C_Surface surface, const in C_Material material)\n{\n    vec3 cScene;\n    \n    C_Shading shading;\n\n    shading.cDiffuse = vec3(0.0);\n    shading.cSpecular = vec3(0.0);\n    \n    float fAmbientOcclusion = GetAmbientOcclusion(hitInfo, surface);\n    vec3 vAmbientLight = GetAmbientLight(surface.vNormal) * fAmbientOcclusion;\n    \n    shading.cDiffuse += vAmbientLight;\n    shading.cSpecular += surface.cReflection;\n              \n    #ifdef ENABLE_POINT_LIGHT\n    C_PointLight pointLight = GetPointLight(); \n    C_Shading pointLighting = ApplyPointLight(pointLight, hitInfo.vPos,ray.vDir, surface.vNormal, material);\n    shading.cDiffuse += pointLighting.cDiffuse;\n    shading.cSpecular += pointLighting.cSpecular;\n    #endif\n\n    #ifdef ENABLE_DIRECTIONAL_LIGHT\n\tC_DirectionalLight directionalLight = GetDirectionalLight();\n    C_Shading directionLighting = ApplyDirectionalLight(directionalLight, hitInfo.vPos, ray.vDir, surface.vNormal, material);\n    shading.cDiffuse += directionLighting.cDiffuse;\n    shading.cSpecular += directionLighting.cSpecular;\n    #endif\n\t\n\t// fire in the hole\n\tshading.cDiffuse += clamp(-hitInfo.vPos.y - 0.5, 0.0, 1.0) * vec3(5.0, 0.25, 0.05);\n\n    vec3 vDiffuseReflection = shading.cDiffuse * material.cAlbedo;              \n\n    #ifdef ENABLE_SPECULAR\n    cScene = ApplyFresnel(vDiffuseReflection , shading.cSpecular, surface.vNormal, ray.vDir, material);\n    #else\n    cScene = vDiffuseReflection;\n    #endif\n    \n    return cScene;\n}\n\nvec3 GetSceneColourSecondary( const in C_Ray ray );\n\nvec3 GetReflection( const in C_Ray ray, const in C_HitInfo hitInfo, const in C_Surface surface )\n{\n    #ifdef ENABLE_REFLECTIONS    \n    {\n        // get colour from reflected ray\n        const float fSeparation    = 0.1;\n\n        C_Ray reflectRay;\n        reflectRay.vDir = reflect(ray.vDir, surface.vNormal);\n        reflectRay.vOrigin = hitInfo.vPos;\n        reflectRay.fLength = 16.0;\n        reflectRay.fStartDistance = fSeparation / abs(dot(reflectRay.vDir, surface.vNormal));\n        \n        return GetSceneColourSecondary(reflectRay);      \n    }\n    #else\n        return GetSkyGradient(reflect(ray.vDir, surface.vNormal));                              \n    #endif\n}\n\n// no reflections, no transparency, used for secondary rays\nvec3 GetSceneColourSecondary( const in C_Ray ray )\n{\n    C_HitInfo hitInfo;\n    Raymarch(ray, hitInfo, 32);\n                        \n    vec3 cScene;\n\n    if(hitInfo.vObjectId.x < 0.5)\n    {\n        cScene = GetSkyGradient(ray.vDir);\n    }\n    else\n    {\n        C_Surface surface;        \n        surface.vNormal = GetSceneNormal(hitInfo.vPos);\n\n        C_Material material = GetObjectMaterial(hitInfo);\n\n        // use sky gradient instead of reflection\n        surface.cReflection = GetSkyGradient(reflect(ray.vDir, surface.vNormal));\n\n        // apply lighting\n        cScene = ShadeSurface(ray, hitInfo, surface, material);\n    }\n\n    ApplyAtmosphere(cScene, ray, hitInfo);\n\n    return cScene;\n}\n\nvec3 GetSceneColourPrimary( const in C_Ray ray )\n{                                                          \n    C_HitInfo intersection;\n    Raymarch(ray, intersection, 256);\n                \n    vec3 cScene;\n\n    if(intersection.vObjectId.x < 0.5)\n    {\n        cScene = GetSkyGradient(ray.vDir);\n    }\n    else\n    {\n        C_Surface surface;\n        \n        surface.vNormal = GetSceneNormal(intersection.vPos);\n\n        C_Material material = GetObjectMaterial(intersection);\n\n        surface.cReflection = GetReflection(ray, intersection, surface);\n\n        // apply lighting\n        cScene = ShadeSurface(ray, intersection, surface, material);\n    }\n\n    ApplyAtmosphere(cScene, ray, intersection);\n\n    return cScene;\n}\n\nfloat kFarClip = 10.0;\n\nvoid GetCameraRay( const in vec3 vPos, const in vec3 vForwards, const in vec3 vWorldUp, const in vec2 fragCoord, out C_Ray ray)\n{\n    vec2 vUV = ( fragCoord.xy / iResolution.xy );\n    vec2 vViewCoord = vUV * 2.0 - 1.0;\n\n    float fRatio = iResolution.x / iResolution.y;\n    vViewCoord.y /= fRatio;                          \n\n    ray.vOrigin = vPos;\n\n    vec3 vRight = normalize(cross(vForwards, vWorldUp));\n    vec3 vUp = cross(vRight, vForwards);\n        \n    ray.vDir = normalize( vRight * vViewCoord.x + vUp * vViewCoord.y + vForwards); \n    ray.fStartDistance = 0.0;\n    ray.fLength = kFarClip;      \n}\n\nvoid GetCameraRayLookat( const in vec3 vPos, const in vec3 vInterest, const in vec2 fragCoord, out C_Ray ray)\n{\n    vec3 vForwards = normalize(vInterest - vPos);\n    vec3 vUp = vec3(0.0, 1.0, 0.0);\n\n    GetCameraRay(vPos, vForwards, vUp, fragCoord, ray);\n}\n\nvec3 OrbitPoint( const in float fHeading, const in float fElevation )\n{\n    return vec3(sin(fHeading) * cos(fElevation), sin(fElevation), cos(fHeading) * cos(fElevation));\n}\n\nvec3 Gamma( const in vec3 cCol )\n{\n    return sqrt(cCol);\n}\n\nvec3 Tonemap( const in vec3 cCol )\n{\n    vec3 vResult = 1.0 - exp2(-cCol);\n\n    return vResult;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    C_Ray ray;\n\n \tGetCameraRayLookat( OrbitPoint(iTime * 0.3, cos(iTime * 0.2) * 0.3 + 0.4) * 7.0, vec3(0.0, 0.0, 0.0), fragCoord, ray);\n\n    vec3 cScene = GetSceneColourPrimary( ray );  \n\n    const float fExposure = 1.5;    \n    fragColor = vec4( Tonemap(cScene * fExposure), 1.0 );\n}\n\nvoid mainVR( out vec4 fragColor, in vec2 fragCoord, in vec3 fragRayOri, in vec3 fragRayDir )\n{\n    C_Ray ray;\n    \n    fragRayOri.y += 1.0;\n    fragRayOri.z += 5.0;\n    \n    ray.vOrigin = fragRayOri;\n    ray.vDir = fragRayDir;\n    ray.fStartDistance = 0.0;\n    ray.fLength = kFarClip;     \n    \n    vec3 cScene = GetSceneColourPrimary( ray );  \n\n    const float fExposure = 1.5;    \n    fragColor = vec4( Tonemap(cScene * fExposure), 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XlySz1.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[7263, 7263, 7293, 7293, 7458], [7460, 7460, 7502, 7502, 7650], [19505, 19505, 19562, 19562, 19848], [19850, 19850, 19944, 19944, 20292]], "test": "error"}
{"id": "XlySzR", "name": "intersections", "author": "mahalis", "description": "playing with a distorted distance fieldI like the way it moves. features a half-assed version of iqs ambient occlusion (see link in the code).", "tags": ["cubes", "space"], "likes": 5, "viewed": 656, "published": "Public API", "date": "1482429686", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// ------\n\nfloat sdCylinder( vec3 p, float r, float h ) {\n\tvec2 d = abs(vec2(length(p.xz),p.y)) - vec2(r, h);\n\treturn min(max(d.x, d.y), 0.0) + length(max(d, 0.0));\n}\n\nfloat sdCube(vec3 p, float b) {\n\tvec3 d = abs(p) - b;\n\treturn min(max(d.x, max(d.y, d.z)), 0.0) + length(max(d, 0.0));\n}\n\nfloat sdSphere(vec3 p, float r) {\n    return length(p) - r;\n}\n\nvec3 opRepeat(vec3 p, vec3 spacing) {\n    return mod(p, spacing) - 0.5 * spacing;\n}\n\nfloat opSub(float d1, float d2) {\n    return max(d1, -d2);\n}\n\nfloat opAdd(float d1, float d2) {\n    return min(d1, d2);\n}\n\nfloat opInt(float d1, float d2) {\n    return max(d1, d2);\n}\n\nvec3 rX(vec3 p, float a) {\n    vec3 q = p;\n    float c = cos(a);\n    float s = sin(a);\n    q.y = c * p.y - s * p.z;\n    q.z = s * p.y + c * p.z;\n    \n    return q;\n}\n\nvec3 rY(vec3 p, float a) {\n    vec3 q = p;\n    float c = cos(a);\n    float s = sin(a);\n    q.x = c * p.x + s * p.z;\n    q.z = -s * p.x + c * p.z;\n    \n    return q;\n}\n\nvec3 rZ(vec3 p, float a) {\n    vec3 q = p;\n    float c = cos(a);\n    float s = sin(a);\n    q.x = c * p.x - s * p.y;\n    q.y = s * p.x + c * p.y;\n    \n    return q;\n}\n\n// -----------------\n\nconst float pi = 3.14159;\n\nfloat d(vec3 position) {\n    float centerDistance = length(position);\n    float shrinkRate = pi * 3.;\n    float newDistance = pow(centerDistance + sin(centerDistance * shrinkRate) / shrinkRate, 1.2);\n    return opInt(sdCube(opRepeat((rX(position, iTime * 0.11) + (sin(iTime * 0.23 + position.y * 5.0) * 0.2 * vec3(0.37,0.,1.19))) * (newDistance / centerDistance) + vec3(0., iTime * 0.05, 0.), vec3(0.1)), 0.03), sdSphere(position, 0.4 + sin(iTime * 0.43) * 0.1));\n}\n\nvec3 gradient(vec3 p, float v) {\n    const vec3 eps = vec3(0.0001, 0.0, 0.0);\n    return (vec3(d(p + eps.xyy), d(p + eps.yxy), d(p + eps.yyx)) - v) / eps.x;\n}\n\nvec4 march(vec3 from, vec3 towards, float prec) {\n    vec3 lastSamplePosition = from;\n    float lastDistance = 0.0;\n    for(int i = 0; i < 130; i++) {\n        vec3 samplePosition = lastSamplePosition + max(lastDistance, prec) * towards;\n        float cDist = d(samplePosition);\n        \n        lastSamplePosition = samplePosition;\n        lastDistance = cDist;\n        \n        if (cDist < 0.0) {\n            return vec4(samplePosition, cDist);\n        }\n    }\n    return vec4(0., 0., 0., 1.);\n}\n\n// ambient occlusion using iqs technique from http://www.iquilezles.org/www/material/nvscene2008/rwwtt.pdf\nfloat occlusion(vec3 position, vec3 normal) {\n    const float aoStep = 0.2;\n    float aoAcc = 0.;\n    const float distanceScale = 0.5; // decrease for less attenuation of shadows\n    for (int i = 0; i < 5; i++) {\n        float fi = float(i);\n        float sampleDistance = aoStep * fi;\n        aoAcc += (sampleDistance - max(0., d(position + normal * sampleDistance))) / exp2(fi * distanceScale);\n    }\n    return aoAcc;\n}\n\nvec3 lightSurface(vec3 position, vec3 normal, vec3 toEye) {\n    vec3 toLight = normalize(vec3(-0.3, 1.0, 0.5)  - position);\n    float ndotL = max(0.0, dot(normal, toLight));\n    float ndotV = max(0.0, dot(normal, toEye));\n    float ndotH = max(0.0, dot(normal, normalize(toEye + toLight)));\n    const float ambience = 0.4;\n    float shadow = smoothstep(0.0, 0.1, march(position + normal * 0.01, toLight, 0.002).w);\n    vec3 color = vec3(ndotL * shadow + (1.0 - occlusion(position, normal)) * ambience + pow(ndotH, 8.) * 0.4 * shadow);\n    return color;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = 2.0 * (fragCoord.xy / iResolution.xy - 0.5);\n    uv.x *= iResolution.x / iResolution.y;\n    const vec3 cameraLookAt = vec3(0.0, 0.0, 0.0);\n    vec3 cameraPosition = rY(vec3(0.0, 0.7, 1.0) * 1.5, iTime * 0.2);\n    vec3 cameraForward = normalize(cameraLookAt - cameraPosition);\n    vec3 cameraRight = cross(cameraForward, vec3(0.0, 1.0, 0.0));\n    vec3 cameraUp = cross(cameraRight, cameraForward);\n\tvec3 rayDirection = normalize(uv.x * cameraRight + uv.y * cameraUp + 3.0 * cameraForward);\n    \n    vec4 marchResult = march(cameraPosition, rayDirection, 0.0001);\n    if (marchResult.w > 0.0) {\n        fragColor = vec4(0.0); // sky color\n    } else {\n        vec3 position = marchResult.xyz;\n        fragColor = vec4(lightSurface(position, gradient(position, marchResult.w), -rayDirection), 1.0);\n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XlySzR.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[11, 11, 57, 57, 166], [168, 168, 199, 199, 288], [290, 290, 323, 323, 351], [353, 353, 390, 390, 436], [438, 438, 471, 471, 498], [500, 500, 533, 533, 559], [561, 561, 594, 594, 620], [622, 622, 648, 648, 787], [789, 789, 815, 815, 955], [957, 957, 983, 983, 1122], [1173, 1173, 1197, 1197, 1638], [1640, 1640, 1672, 1672, 1798], [1800, 1800, 1849, 1849, 2296], [2298, 2408, 2453, 2453, 2830], [2832, 2832, 2891, 2891, 3386], [3388, 3388, 3445, 3445, 4266]], "test": "valid"}
{"id": "Xt3SDf", "name": "#Devember 2016 - day 13", "author": "theGiallo", "description": "Triangular prisms specified in three different ways:\n1- centered on base, depth and side length\n2- centered on barycenter, depth and side length\n3- centered on barycenter, depth and radius", "tags": ["raymarching", "primitives", "prism", "devember"], "likes": 1, "viewed": 100, "published": "Public", "date": "1481745391", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define SQRT2 1.4142135623730950488016887242096980785696\n#define PI    3.1415926535897932384626433832795\n#define HPI   1.57079632679489661923132169\n#define QPI   0.785398163397448309615660845819875721\n#define TAU   6.283185307179586476925286766559\n\n#define INDEXED_MATERIALS 1\n\n#if INDEXED_MATERIALS\n#define MPt vec2\n#define distance x\n#else\n#define MPt Material_Point\n#endif\nstruct\nMaterial\n{\n    vec3 color;\n    float diffuse_reflection;\n    float specular_reflection;\n    float ambient_reflection;\n    float shininess;\n};\nstruct\nMaterial_Point\n{\n    float distance;\n    Material material;\n};\n    \n#define MAT_PLASTIC  0.0\n#define MAT_ORANGE   1.0\n#define MAT_RED      2.0\n#define MAT_GREEN    3.0\n#define MAT_BLUE     4.0\n#define MAT_FLOOR_W  5.0\n#define MAT_FLOOR_B  6.0\n#define MAT_COUNT    7\n\n////////////////////////////////////////////////////////////////////////////////\n\nfloat\nmanhattan( vec2 p )\n{\n    p = abs ( p );\n    float ret = p.x + p.y;\n    return ret;\n}\nfloat\nmanhattan( vec2 p0, vec2 p1 )\n{\n    float ret;\n    \n    vec2 d = abs ( p1 - p0 );\n    ret = d.x + d.y;\n    \n    return ret;\n}\nvec4\ncircle( vec4 color, vec2 pos, float radius, float border_width, vec2 point )\n{\n    vec4 ret = vec4(0);\n    color.rgb *= color.a;\n    \n    float dist = length( point - pos );\n    ret = color * (1.0 - smoothstep( radius, radius + border_width, dist ) );\n    \n    return ret;\n}\nvec4\nsquare( vec4 color, vec2 pos, float side, float border_width, float rot_rad, vec2 point )\n{\n    vec4 ret = vec4(0);\n    color.rgb *= color.a;\n    \n    float max_d = SQRT2 * side;\n    vec2 rd = point - pos;\n    float tot_rad = QPI + rot_rad;\n    vec2 rd_rot;\n    rd_rot.x = rd.x * cos( tot_rad ) + rd.y * sin( tot_rad );\n    rd_rot.y = rd.x * sin( tot_rad ) - rd.y * cos( tot_rad );\n    float dist = manhattan( rd_rot );\n    ret = color * (1.0 - smoothstep( max_d, max_d + border_width, dist ) );\n    \n    return ret;\n}\nvec4\nsquare_tex( vec4 color, vec2 pos, float side, float border_width, float rot_rad, vec2 point, sampler2D tex )\n{\n    vec4 ret = vec4(0);\n    color.rgb *= color.a;\n    \n    float max_d = SQRT2 * side;\n    vec2 rd = point - pos;\n    float tot_rad = QPI + rot_rad;\n    vec2 rd_rot;\n    rd_rot.x = rd.x * cos( tot_rad ) + rd.y * sin( tot_rad );\n    rd_rot.y = rd.x * sin( tot_rad ) - rd.y * cos( tot_rad );\n    float dist = manhattan( rd_rot );\n    ret = color * (1.0 - smoothstep( max_d, max_d + border_width, dist ) );\n    ret *= texture( tex, rd_rot * (0.5 / side ) + 0.5 );\n    \n    return ret;\n}\n\n// NOTE(theGiallo): pre-multiplied alpha\nvoid\nblend_pma( inout vec4 dst, in vec4 src )\n{\n    dst.rgb = src.rgb + dst.rgb * ( 1.0 - src.a );\n    dst.a = min( 1.0, dst.a + src.a );\n}\n\nfloat\nmirror( float x )\n{\n    x *= 0.5;\n    return 1.0 - abs( 2.0 * ( x - floor(x) ) - 1.0 );\n}\n\nfloat\ndecimal( float x )\n{\n    return x - floor(x);\n}\n\n// NOTE(theGiallo): h in [0,1)\nvec4\nrgb_from_hsv( vec4 hsv )\n{\n\tvec4 ret;\n\tret.a = hsv.a;\n\tfloat c = hsv.g * hsv.b;\n\tfloat hh = hsv.r * 6.0;\n\n\tfloat x = c * ( 1.0 - abs( hh - 2.0 * floor( hh / 2.0 ) - 1.0 ) );\n\n\tif ( hh < 1.0 || hh >= 6.0 )\n\t{\n\t\tret.r = c;\n\t\tret.g = x;\n\t\tret.b = 0.0;\n\t} else\n\tif ( hh < 2.0 )\n\t{\n\t\tret.r = x;\n\t\tret.g = c;\n\t\tret.b = 0.0;\n\t} else\n\tif ( hh < 3.0 )\n\t{\n\t\tret.r = 0.0;\n\t\tret.g = c;\n\t\tret.b = x;\n\t} else\n\tif ( hh < 4.0 )\n\t{\n\t\tret.r = 0.0;\n\t\tret.g = x;\n\t\tret.b = c;\n\t} else\n\tif ( hh < 5.0 )\n\t{\n\t\tret.r = x;\n\t\tret.g = 0.0;\n\t\tret.b = c;\n\t} else\n\tif ( hh < 6.0 )\n\t{\n\t\tret.r = c;\n\t\tret.g = 0.0;\n\t\tret.b = x;\n\t}\n\n\tfloat m = hsv.b - c;\n\tret.r += m;\n\tret.g += m;\n\tret.b += m;\n\n\treturn ret;\n}\n\n#define ORANGE_RGB vec3(1.0,0.4,0.0)\n#define T_EPS 0.001\n\nfloat\nminv( in vec3 v )\n{\n    return min( v.x, min( v.y, v.z ) );\n}\n\nfloat\nmaxv( in vec3 v )\n{\n    return max( v.x, max( v.y, v.z ) );\n}\n\nfloat\nminv( in vec2 v )\n{\n    return min( v.x, v.y );\n}\n\nfloat\nmaxv( in vec2 v )\n{\n    return max( v.x, v.y );\n}\n\n\n\nvec3\nat_pos( in vec3 pos, in vec3 p )\n{\n    return p-pos;\n}\n\nmat4\ntr( mat4 m )\n{\n    return mat4(\n       vec4(m[0][0],m[1][0],m[2][0],m[3][0]),\n       vec4(m[0][1],m[1][1],m[2][1],m[3][1]),\n       vec4(m[0][2],m[1][2],m[2][2],m[3][2]),\n       vec4(m[0][3],m[1][3],m[2][3],m[3][3])\n    );\n}\n\nvec3\nrotate( in vec3 r, in vec3 p )\n{\n\tmat4 Rx = mat4(\n\t   vec4( 1.0, 0.0,      0.0,       0.0 ),\n\t   vec4( 0.0, cos(r.x), -sin(r.x), 0.0 ),\n\t   vec4( 0.0, sin(r.x),  cos(r.x), 0.0 ),\n\t   vec4( 0.0, 0.0,      0.0,       0.0 ) );\n\tmat4 Ry = mat4(\n\t   vec4(  cos(r.y), 0.0, sin(r.y), 0.0 ),\n\t   vec4(  0.0,      1.0, 0.0,      0.0 ),\n\t   vec4( -sin(r.y), 0.0, cos(r.y), 0.0 ),\n\t   vec4(  0.0,      0.0, 0.0,      1.0 ) );\n\tmat4 Rz = mat4(\n\t   vec4( cos(r.z), -sin(r.z), 0.0, 0.0 ),\n\t   vec4( sin(r.z),  cos(r.z), 0.0, 0.0 ),\n\t   vec4( 0.0,      0.0,       1.0, 0.0 ),\n\t   vec4( 0.0,      0.0,       0.0, 1.0 ) );\n\tmat4 m = Rz * Ry * Rx;\n\treturn (vec4(p,1.0)*m).xyz;\n}\n\nvec3\nat_angle( in vec3 a, in vec3 p )\n{\n    return rotate( -a, p );\n}\n\n#if INDEXED_MATERIALS\nvec2\nunion_op( vec2 p0, vec2 p1 )\n{\n    if ( p0.x < p1.x )\n    {\n        return p0;\n    }\n    return p1;\n}\n#else\nMaterial_Point\nunion_op( Material_Point p0, Material_Point p1 )\n{\n    if ( p0.distance < p1.distance )\n    {\n        return p0;\n    }\n    return p1;\n}\n#endif\n\n#if INDEXED_MATERIALS\nvec2\nintersect_op( vec2 p0, vec2 p1 )\n{\n    if ( p0.x > p1.x )\n    {\n        return p0;\n    }\n    return p1;\n}\n#else\nMaterial_Point\nintersect_op( Material_Point p0, Material_Point p1 )\n{\n    if ( p0.distance > p1.distance )\n    {\n        return p0;\n    }\n    return p1;\n}\n#endif\n\nMaterial\nchange_color( Material m, vec3 color )\n{\n    Material ret = m;\n    ret.color = color;\n    return ret;\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\nfloat\nsphere_sd( in float sph_r, in vec3 p )\n{\n    return length( p ) - sph_r;\n}\n\nfloat\naab_sd( in vec3 sides, in vec3 p )\n{\n    sides *= 0.5;\n    p = abs( p );\n    vec3 d = p - sides;\n    return min( maxv( d ), 0.0 ) + length( max(d,0.0) );\n}\n\nfloat\nplane_sd( in vec3 p )\n{\n    return abs( p.z );\n}\n\n\nfloat\nhalf_space_sd( in vec3 p )\n{\n    return p.z;\n}\n\nfloat\nround_aab_ud( in vec3 sides, in float r, in vec3 p )\n{\n    sides *= 0.5;\n    p = abs( p );\n    vec3 d = p - sides;\n    return length( max(d, 0.0) ) - r;\n}\n\n// NOTE(theGiallo): torus.x = big radius torus.y = solid radius\nfloat\ntorus_sd( in vec2 torus, in vec3 p )\n{\n    vec2 q = vec2(length(p.xy)-torus.x,p.z);\n    return length(q)-torus.y;\n}\n\nfloat\ncylinder_sd( in float r, in vec3 p )\n{\n    return length( p.xy ) - r;\n}\n\nfloat\ncapped_cylinder_sd( in vec2 rh, in vec3 p )\n{\n    vec2 d = abs( vec2( length( p.xy ), p.z ) ) - rh;\n    return min( maxv(d), 0.0 ) + length( max(d, 0.0) );\n}\n\nfloat\nhalf_cone_pos_sd( in vec2 c, in vec3 p )\n{\n    vec2 c1 = vec2(c.y,-c.x);\n    return dot( c1, vec2(length(p.xy), p.z) );\n}\n\nfloat\ncone_sd( in vec2 c, in vec3 p )\n{\n    p = abs(p);\n    vec2 c1 = vec2(c.y,-c.x);\n    return dot( c1, vec2(length(p.xy), p.z) );\n}\n\nfloat\ncapped_cone_as_intersections_sd( in float h, in float r1, in float r2, in vec3 p )\n{\n    float R1z = (r1*h)/(r2-r1);\n    float R2z = R1z + h;\n    p = at_pos(vec3(0.0,0.0,-R1z),p);\n\tvec2 c = vec2(r2/R2z,1.0);\n\treturn\n\tmax( max( -half_space_sd( at_pos(vec3(0.0,0.0,R1z), p) ), half_space_sd( at_pos( vec3(0.0,0.0,R2z), p ) ) ),\n         half_cone_pos_sd( c, p )\n       );\n}\n\n// NOTE(theGiallo): d.x is the depth of the prism(or height), d.y the radius\n// NOTE(theGiallo): depth on x axis, diameter on y axis\nfloat\nhex_prism_sd( in vec2 dr, in vec3 p )\n{\n    p = abs(p);\n    return max(p.x-dr.x*0.5,max(p.y*0.866025+p.z*0.5,p.z)-0.866025*dr.y);\n}\n\nfloat\ntri_prism_sd( in vec2 ds, in vec3 p )\n{\n  \tp.xy = abs(p.xy);\n    \n    return max( p.x - ds.x*0.5, max( p.y * 0.866025 + 0.5 * p.z - ds.y * 0.433012702, -p.z ) );\n}\n\nfloat\ntri_prism_bary_sd( in vec2 ds, in vec3 p )\n{\n    p.z += ds.y * 0.288675135;\n    \n    return tri_prism_sd( ds, p );\n}\n\nfloat\ntri_prism_bary_r_sd( in vec2 dr, in vec3 p )\n{\n    dr.y = dr.y * 1.732050808;\n    \n    return tri_prism_bary_sd( dr, p );\n}\n    \n//////////\n\nvec3 sky_color;\n\n#if INDEXED_MATERIALS\nvec2\n#else\nMaterial_Point\n#endif\nmap( in vec3 pos )\n{\n    #if 0\n    float r = 1.1;\n    float h = decimal( ( floor( pos.x / r + 0.5 ) + 50.0 ) / 10.0 );\n    float s = mirror( ( floor( pos.s / r + 0.5 ) + 50.0 ) / 30.0 );\n    vec3 color = rgb_from_hsv( vec4( h, s, 1.0, 1.0 ) ).rgb;\n    pos.x = mirror( pos.x / r ) * r;\n    pos.y = mirror( pos.y / r ) * r;\n    #else\n    vec3 color = ORANGE_RGB;\n    #endif\n    \n    MPt res;\n    #if INDEXED_MATERIALS\n    res.x = 1e38;\n    #else\n    res.distance = 1e38;\n    #endif\n    \n    #if !INDEXED_MATERIALS\n    Material plastic_m;\n    plastic_m.color = vec3(1.0);\n    plastic_m.diffuse_reflection  = 1.0;\n    plastic_m.specular_reflection = 1.0;\n    plastic_m.ambient_reflection  = 1.0;\n    plastic_m.shininess           = 15.0;\n\n    Material floor_m;\n    plastic_m.color = vec3(1.0);\n    floor_m.diffuse_reflection  = 1.0;\n    floor_m.specular_reflection = 0.2;\n    floor_m.ambient_reflection  = 0.5;\n    floor_m.shininess           = 1.0;\n\n    Material orange_m = plastic_m;\n    orange_m.color = ORANGE_RGB;\n    \n    Material red_m = plastic_m;\n    red_m.color = vec3(1.0,0.0,0.0);\n    Material green_m = plastic_m;\n    green_m.color = vec3(0.0,1.0,0.0);\n    Material blue_m = plastic_m;\n    blue_m.color = vec3(0.0,0.0,1.0);\n    #endif\n\n    float sr = 0.5;\n    float sd = 0.5;\n    #if 0\n    res =\n       union_op(\n          MPt( sphere_sd( sr, at_pos( sd * vec3(0.0, cos( HPI             ), sin( HPI             ) ), pos ) ),\n                          orange_mat ),\n\t      MPt( sphere_sd( sr, at_pos( sd * vec3(0.0, cos( HPI + TAU / 3.0 ), sin( HPI + TAU / 3.0 ) ), pos ) ),\n                          orange_mat ) );\n    res =\n       union_op(\n          MPt( sphere_sd( sr, at_pos( sd * vec3(0.0, cos( HPI - TAU / 3.0 ), sin( HPI - TAU / 3.0 ) ), pos ) ),\n               orange_mat ),\n          res );\n    #endif\n    \n    res = union_op( MPt( sphere_sd( 0.1, at_pos( vec3(0.0        ), pos ) ),\n                        #if INDEXED_MATERIALS\n                         MAT_PLASTIC\n                        #else\n                        plastic_m\n                        #endif\n                       ), res );\n    res = union_op( MPt( sphere_sd( 0.1, at_pos( vec3(1.0,0.0,0.0), pos ) ),\n                        #if INDEXED_MATERIALS\n                         MAT_RED\n                        #else\n                        red_m\n                        #endif\n                       ),res );\n    res = union_op( MPt( sphere_sd( 0.1, at_pos( vec3(0.0,1.0,0.0), pos ) ),\n                        #if INDEXED_MATERIALS\n                         MAT_GREEN\n                        #else\n                        green_m\n                        #endif\n                       ),res );\n    res = union_op( MPt( sphere_sd( 0.1, at_pos( vec3(0.0,0.0,1.0), pos ) ),\n                        #if INDEXED_MATERIALS\n                         MAT_BLUE\n                        #else\n                        blue_m\n                        #endif\n                       ),res );\n    float m = mod( floor(pos.x * 2.0) + floor(pos.y * 2.0), 2.0 );\n    res = union_op( MPt( plane_sd( pos ),\n                        #if INDEXED_MATERIALS\n                        MAT_FLOOR_B * (1.0 - m) + MAT_FLOOR_W * m\n                        #else\n                         change_color( floor_m, vec3( 0.7 + 0.3 * m ) )\n                        #endif\n                       ),\n                    res );\n\n\n    res =\n       union_op( MPt( aab_sd( vec3(1.0), at_angle( vec3(0.0,0.0,pos.z * HPI * sin(iTime)), at_pos(vec3(2.0,0.0,0.5),pos) ) ),\n                        #if INDEXED_MATERIALS\n                         MAT_ORANGE\n                        #else\n                         orange_m\n                        #endif\n                    ),\n                 res );\n    res = union_op( MPt( aab_sd( vec3(1.0), at_angle( vec3(0.0,0.0,iTime*0.05), at_pos(vec3(2.0,2.0,0.5),pos) ) ),\n                        #if INDEXED_MATERIALS\n                         MAT_ORANGE\n                        #else\n                         orange_m\n                        #endif\n                       ),\n                    res );\n    res = union_op( MPt( aab_sd( vec3(1.0), at_angle( vec3(0.0,pos.y * HPI,0.0), at_pos(vec3(-2.0,pos.y,0.5),pos) ) ),\n                        #if INDEXED_MATERIALS\n                         MAT_ORANGE\n                        #else\n                         orange_m\n                        #endif\n                       ),\n                    res );\n    res = union_op( MPt( round_aab_ud( vec3(0.9), 0.05, at_pos( vec3(2.0,-2.0,0.4), pos ) ),\n                        #if INDEXED_MATERIALS\n                         MAT_PLASTIC\n                        #else\n                         change_color( plastic_m, rgb_from_hsv( vec4(0.083,0.1,1.0,1.0) ).rgb )\n                        #endif\n                       ),\n                    res );\n    \n    res =\n       union_op( MPt( torus_sd( vec2(0.4,0.1), at_angle( vec3(0.0,0.0,0.0), at_pos(vec3(2.0,4.0,0.1),pos) ) ),\n                        #if INDEXED_MATERIALS\n                         MAT_ORANGE\n                        #else\n                         orange_m\n                        #endif\n                    ),\n                 res );\n    \n    res =\n       union_op( MPt( torus_sd( vec2(0.38,0.12), at_angle( vec3(0.0,HPI,iTime), at_pos(vec3(2.0,6.0,0.5),pos) ) ),\n                        #if INDEXED_MATERIALS\n                         MAT_ORANGE\n                        #else\n                         orange_m\n                        #endif\n                    ),\n                 res );\n    \n    res =\n       union_op( MPt( torus_sd( vec2(0.38,0.12), at_angle( vec3(0.0,HPI, iTime + TAU * pos.z), at_pos(vec3(2.0,8.0,0.5),pos) ) ),\n                        #if INDEXED_MATERIALS\n                         MAT_ORANGE\n                        #else\n                         orange_m\n                        #endif\n                    ),\n                 res );\n    \n    res =\n       union_op( MPt( cylinder_sd( 0.5, at_angle( vec3(0.0,/*sin(iTime*TAU/7.0)**/QPI*0.25,iTime*TAU/7.0), at_pos(vec3(2.0,10.0,2.0),pos) ) ),\n                        #if INDEXED_MATERIALS\n                         MAT_ORANGE\n                        #else\n                         orange_m\n                        #endif\n                    ),\n                 res );\n    \n    res =\n       union_op( MPt( capped_cylinder_sd( vec2( 0.5, 1.0 ), at_angle( vec3(0.0,0.25*QPI*iTime,iTime*TAU/7.0), at_pos(vec3(2.0,12.0,1.0),pos) ) ),\n                        #if INDEXED_MATERIALS\n                         MAT_ORANGE\n                        #else\n                         orange_m\n                        #endif\n                    ),\n                 res );\n    \n    res =\n       union_op( MPt( cone_sd( vec2( 0.5, 1.0 ),\n                               at_angle( vec3(0.0,0.125*PI*sin(iTime*TAU/11.0),iTime*TAU/17.0),\n                                         at_pos(vec3(2.0,14.0,1.0),pos) ) ),\n                        #if INDEXED_MATERIALS\n                         MAT_ORANGE\n                        #else\n                         orange_m\n                        #endif\n                    ),\n                 res );\n    \n    res =\n       union_op( MPt( half_cone_pos_sd( vec2( 0.5, 1.0 ),\n                                        at_angle( vec3(0.0,0.125*PI*sin(iTime*TAU/11.0),iTime*TAU/17.0),\n                                                  at_pos(vec3(2.0,16.0,1.0),pos) ) ),\n                        #if INDEXED_MATERIALS\n                         MAT_ORANGE\n                        #else\n                         orange_m\n                        #endif\n                    ),\n                 res );\n    \n    res =\n       union_op( MPt( half_cone_pos_sd( vec2( 0.5, 1.0 ),\n                                        vec3(1.0,1.0,-1.0) *\n                                        at_angle( vec3(0.0,0.125*PI*sin(iTime*TAU/11.0),iTime*TAU/17.0),\n                                                  at_pos(vec3(2.0,18.0,1.0), pos) ) ),\n                        #if INDEXED_MATERIALS\n                         MAT_ORANGE\n                        #else\n                         orange_m\n                        #endif\n                    ),\n                 res );\n    \n    res =\n       union_op(\n          intersect_op(\n             MPt( half_cone_pos_sd( vec2( 0.5, 1.0 ),\n                                    vec3(1.0,1.0,-1.0) * at_pos(vec3(2.0,20.0,2.0), pos) ),\n                        #if INDEXED_MATERIALS\n                         MAT_ORANGE\n                        #else\n                         orange_m\n                        #endif\n                    ),\n             intersect_op(\n                MPt( half_space_sd( at_pos(vec3(2.0,20.0,1.5), pos) ),\n                     #if INDEXED_MATERIALS\n                      MAT_ORANGE\n                     #else\n                      orange_m\n                     #endif\n                ),\n                MPt( -half_space_sd( at_pos(vec3(2.0,20.0,0.5), pos) ),\n                     #if INDEXED_MATERIALS\n                      MAT_ORANGE\n                     #else\n                      orange_m\n                     #endif\n                )\n             )\n          ),\n          res );\n    \n    res =\n       union_op( MPt( capped_cone_as_intersections_sd(\n                         1.0, 0.25, 0.5, at_pos(vec3(2.0,22.0,0.5), pos) ),\n                      #if INDEXED_MATERIALS\n                       MAT_ORANGE\n                      #else\n                       orange_m\n                      #endif\n                    ),\n                 res );  \n    res =\n       union_op( MPt( capped_cone_as_intersections_sd(\n                         1.0, 0.5, 0.25, at_pos(vec3(2.0,24,0.5), pos) ),\n                      #if INDEXED_MATERIALS\n                       MAT_ORANGE\n                      #else\n                       orange_m\n                      #endif\n                    ),\n                 res );  \n    res =\n       union_op( MPt( capped_cone_as_intersections_sd(\n                         1.0, 0.25, 0.5, at_pos(vec3(2.0,24,1.6 + 0.05 * sin(iTime * TAU / 4.0) ), pos) ),\n                      #if INDEXED_MATERIALS\n                       MAT_ORANGE\n                      #else\n                       orange_m\n                      #endif\n                    ),\n                 res );\n    res =\n       union_op( MPt( hex_prism_sd(vec2(0.5,0.5), at_angle( vec3(iTime*TAU/4.0,0.0,0.0), at_pos(vec3(2.0,26,0.5), pos) ) ),\n                      #if INDEXED_MATERIALS\n                       MAT_ORANGE\n                      #else\n                       orange_m\n                      #endif\n                    ),\n                 res );\n    res =\n       union_op( MPt( hex_prism_sd(vec2(0.5,1.0), at_angle( vec3(iTime*TAU/4.0,0.0,0.0), at_pos(vec3(2.0,28,0.866025), pos) ) ),\n                      #if INDEXED_MATERIALS\n                       MAT_ORANGE\n                      #else\n                       orange_m\n                      #endif\n                    ),\n                 res );\n    res =\n       union_op( MPt( tri_prism_sd(vec2(0.5,1.0), at_angle( vec3(iTime*TAU/4.0,0.0,0.0), at_pos(vec3(2.0,30.0,0.0), pos) ) ),\n                      #if INDEXED_MATERIALS\n                       MAT_ORANGE\n                      #else\n                       orange_m\n                      #endif\n                    ),\n                 res );\n    res =\n       union_op( MPt( tri_prism_bary_sd(vec2(0.5,1.0), at_angle( vec3(iTime*TAU/4.0,0.0,0.0), at_pos(vec3(2.0,32.0,0.288675135), pos) ) ),\n                      #if INDEXED_MATERIALS\n                       MAT_ORANGE\n                      #else\n                       orange_m\n                      #endif\n                    ),\n                 res );\n    res = union_op( MPt( sphere_sd( 0.05, at_pos( vec3(2.25,32.0,0.288675135), pos ) ),\n                        #if INDEXED_MATERIALS\n                         MAT_PLASTIC\n                        #else\n                        plastic_m\n                        #endif\n                       ), res );\n    res =\n       union_op( MPt( tri_prism_bary_r_sd(vec2(0.5,0.5), at_angle( vec3(iTime*TAU/4.0,0.0,0.0), at_pos(vec3(2.0,34.0,0.5), pos) ) ),\n                      #if INDEXED_MATERIALS\n                       MAT_ORANGE\n                      #else\n                       orange_m\n                      #endif\n                    ),\n                 res );\n    res = union_op( MPt( sphere_sd( 0.05, at_pos( vec3(2.25,34.0,0.5), pos ) ),\n                        #if INDEXED_MATERIALS\n                         MAT_PLASTIC\n                        #else\n                        plastic_m\n                        #endif\n                       ), res );\n\treturn res;\n}\n\nvec3\ncalc_normal( in vec3 pos, in float t )\n{\n    vec3 eps = vec3( max(0.02,T_EPS*t),0.0,0.0);\n\treturn normalize( vec3(\n           map( pos + eps.xyy ).distance - map( pos - eps.xyy ).distance,\n           map( pos + eps.yxy ).distance - map( pos - eps.yxy ).distance,\n           map( pos + eps.yyx ).distance - map( pos - eps.yyx ).distance ) );\n}\n\n\n#if INDEXED_MATERIALS\nvec2\n#else\nMaterial_Point\n#endif\nraymarch( in vec3 start, in vec3 dir, inout float t, in float t_max )\n{\n    MPt mp;\n    for ( int it=0; it!=120; ++it )\n    {\n        vec3 here = start + dir * t;\n        mp = map( here );\n        if ( mp.distance < ( T_EPS * t ) || t > t_max )\n        {\n        \tbreak;\n        }\n        #if 1\n        // NOTE(theGiallo): this is to sample nicely the twisted things\n        t += mp.distance * 0.4;\n        #else\n        t += mp.distance;\n        #endif\n    }\n    if ( t > t_max )\n    {\n        t = -1.0;\n    }\n    return mp;\n}\n\nfloat\nshadow( in vec3 start, in vec3 dir )\n{\n    float ret = 1.0;\n    float c = step( mod( iTime, 4.0 ), 2.0 );\n    float t = 0.02, t_max = 16.0;\n    MPt mp;\n    \n    for ( int it=0; it!=16; ++it )\n    {\n        vec3 here = start + dir * t;\n        mp = map( here );\n        ret = min( ret, 8.0*mp.distance/t);\n        if ( mp.distance < ( T_EPS * t ) || t > t_max )\n        {\n        \tbreak;\n        }\n        \n        float inc;\n        // NOTE(theGiallo): this is to sample nicely the twisted things\n        inc = c * mp.distance * 0.4;\n\t\tinc += ( 1.0 - c ) * clamp( mp.distance, 0.02, 0.1 );\n        t += inc;\n    }\n    if ( t > t_max )\n    {\n        t = -1.0;\n    }\n    if ( c == 0.0 ) return 1.0 - clamp( ret, 0.0, 1.0 );\n\n    if ( t < 0.0 )\n    {\n        return 0.0;\n    }\n    //return 1.0;\n    ret = 1.0 / pow(1.0 - 1e-30 + max( mp.distance, 1e-30 ), 5.0 );\n    float th = 0.1;\n    return smoothstep( 0.0, 1.0, ( ret*1.1 - th ) / (1.0-th) );\n}\n\n\nfloat\nimg_scale_given_h_fov( float near, float fov )\n{\n    float hw = iResolution.x / min( iResolution.y, iResolution.x );\n    return tan( fov * 0.5 ) * near / hw;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{    \n\tvec2 q = fragCoord.xy / iResolution.xy;\n    vec2 qc = 2.0 * q - 1.0;\n\tvec2 p = ( 2.0 * fragCoord.xy - iResolution.xy ) / min( iResolution.y, iResolution.x );\n    vec4 col = rgb_from_hsv(vec4(0.57,0.5,0.7,1.0));\n    sky_color = col.rgb;\n    vec3 sun_specular_color = vec3(0.8,1.0,1.0);\n        \n    vec3 sun_light_dir = normalize( vec3( 0.0, 1.0, -1.0 ) );\n    \n    float img_plane_dist = 0.05;\n    float img_scale = img_scale_given_h_fov( img_plane_dist, TAU / 3.0 );\n\n    float time = iTime * PI * 0.06125;\n    vec2 d = vec2(0.0,2.0);\n    #if 0\n    vec2 base = vec2(2.54,-2.0);\n    #else\n    vec2 base = vec2(4.0,-2.0);\n    #endif\n    vec3 camera_pos;\n    #if 1\n    const int p_count = 19;\n    float u = mirror( iTime / ( float(p_count) * 4.0 ) );\n    //u = 1.0;\n    float pu = 1.0 / float(p_count-1);\n    float pt = 0.0;\n    vec2 pxy = vec2(0.0);\n    for ( int i = 0; i!=p_count; ++i )\n    {\n        float s = pu * ( -0.5 + float(i) );\n        pxy +=\n           ( base + d * float(i) ) *\n           ( smoothstep( s - 0.1 * pu, s + 0.1 * pu, u ) - smoothstep( s + pu * 0.9, s + pu * 1.1, u ) );\n    }\n    camera_pos.xy = pxy;\n    camera_pos.z = 1.5;\n    vec3 look = normalize( vec3(-0.5,0.0,-0.1) );\n    #else\n    camera_pos = vec3(1.0,8.0,1.0);\n    vec3 look = normalize( vec3(0.5,0.0,-0.25) );\n    #endif\n\n    vec3 up = vec3(0.0,0.0,1.0);\n    vec3 right = cross( look, up );\n    vec3 img_up = cross( right, look );\n    vec3 dir = look * img_plane_dist + right * p.x * img_scale + img_up * p.y * img_scale;\n    vec3 start = camera_pos + dir;\n    dir = normalize( dir );\n    \n    Material materials_table[MAT_COUNT];\n\n    materials_table[int(MAT_PLASTIC)].color = rgb_from_hsv( vec4(0.083,0.1,1.0,1.0) ).rgb;\n    materials_table[int(MAT_PLASTIC)].diffuse_reflection  = 1.0;\n    materials_table[int(MAT_PLASTIC)].specular_reflection = 1.0;\n    materials_table[int(MAT_PLASTIC)].ambient_reflection  = 1.0;\n    materials_table[int(MAT_PLASTIC)].shininess           = 15.0;\n\n    materials_table[int(MAT_FLOOR_B)].color = vec3(0.7);\n    materials_table[int(MAT_FLOOR_B)].diffuse_reflection  = 1.0;\n    materials_table[int(MAT_FLOOR_B)].specular_reflection = 0.2;\n    materials_table[int(MAT_FLOOR_B)].ambient_reflection  = 0.5;\n    materials_table[int(MAT_FLOOR_B)].shininess           = 1.0;\n\n    materials_table[int(MAT_FLOOR_W)].color = vec3(1.0);\n    materials_table[int(MAT_FLOOR_W)].diffuse_reflection  = 1.0;\n    materials_table[int(MAT_FLOOR_W)].specular_reflection = 0.2;\n    materials_table[int(MAT_FLOOR_W)].ambient_reflection  = 0.5;\n    materials_table[int(MAT_FLOOR_W)].shininess           = 1.0;\n\n    materials_table[int(MAT_ORANGE)] = change_color(materials_table[int(MAT_PLASTIC)], ORANGE_RGB );\n    materials_table[int(MAT_RED   )] = change_color(materials_table[int(MAT_PLASTIC)], vec3(1.0,0.0,0.0) );\n    materials_table[int(MAT_GREEN )] = change_color(materials_table[int(MAT_PLASTIC)], vec3(0.0,1.0,0.0) );\n    materials_table[int(MAT_BLUE  )] = change_color(materials_table[int(MAT_PLASTIC)], vec3(0.0,0.0,1.0) );\n    \n    float t = 0.0;\n    MPt mp = raymarch( start, dir, t, 1e2 );\n    Material mat;\n    #if INDEXED_MATERIALS\n    for ( int i = 0; i != MAT_COUNT; ++i )\n    {\n        if ( i == int(mp.y) )\n        {\n            mat = materials_table[i];\n        }\n\t}\n    #else\n    mat = mp.material;\n    #endif\n    if ( t > 0.0 )\n    {\n        vec3 point = start + dir * t;\n        vec3 normal = calc_normal( point, t );\n        // col.rgb = 0.5 + normal * 0.5;\n        float sh = 1.0 - shadow( point, -sun_light_dir );\n        float diffuse = sh * max( 0.0, dot( normal, -sun_light_dir ) );\n        float spec = sh * pow( max( 0.0, dot( reflect( dir, normal ) , -sun_light_dir ) ), mat.shininess  );\n        float ambient = 0.3;\n        col.rgb = ( diffuse * mat.diffuse_reflection +\n                    ambient * mat.ambient_reflection ) * mat.color +\n                    spec    * mat.specular_reflection * sun_specular_color;\n    } else\n    if ( t == 0.0 )\n    {\n        col.rgb = mat.color / ( 1.0 - 20.0 * mp.distance );\n    }\n    \n    // NOTE(theGiallo): gamma correction\n\t// col.rgb = pow( col.rgb, vec3(0.4545) );\n\n    fragColor = vec4(col.rgb,1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Xt3SDf.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[881, 881, 908, 908, 972], [973, 973, 1010, 1010, 1104], [1105, 1105, 1188, 1188, 1384], [1385, 1385, 1481, 1481, 1908], [1909, 1909, 2024, 2024, 2508], [2510, 2551, 2598, 2598, 2690], [2692, 2692, 2717, 2717, 2787], [2789, 2789, 2815, 2815, 2842], [2844, 2875, 2906, 2906, 3554], [3614, 3614, 3639, 3639, 3681], [3683, 3683, 3708, 3708, 3750], [3752, 3752, 3777, 3777, 3807], [3809, 3809, 3834, 3834, 3864], [3868, 3868, 3907, 3907, 3927], [3929, 3929, 3948, 3948, 4157], [4159, 4159, 4196, 4196, 4824], [4826, 4826, 4865, 4865, 4895], [5493, 5493, 5542, 5542, 5605], [5689, 5689, 5735, 5735, 5769], [5771, 5771, 5813, 5813, 5932], [5934, 5934, 5963, 5963, 5988], [5991, 5991, 6025, 6025, 6043], [6045, 6045, 6105, 6105, 6205], [6207, 6271, 6315, 6315, 6392], [6394, 6394, 6438, 6438, 6471], [6473, 6473, 6524, 6524, 6636], [6638, 6638, 6686, 6686, 6765], [6767, 6767, 6806, 6806, 6901], [6903, 6903, 6993, 6993, 7280], [7282, 7415, 7460, 7460, 7552], [7554, 7554, 7599, 7599, 7723], [7725, 7725, 7775, 7775, 7847], [7849, 7849, 7901, 7901, 7978]], "test": "error"}
{"id": "Xt3SWs", "name": "Meltdown", "author": "huwb", "description": "A day of random hacks. I started with a mandelbrot iteration and broke it enough to give an interesting appearance. I separate out the fractal into layers and add parallax to them individually to give the illusion of depth. ", "tags": ["fractal", "fire"], "likes": 25, "viewed": 341, "published": "Public", "date": "1482021301", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define MAX_ITERS 10.0\n\nbool intersectsLayer( vec2 fragCoord, float layer )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\tvec2 c = (cos(.35*iTime)+20.) * (2.0 * uv - 1.0) * vec2(iResolution.x / iResolution.y, 1.0);\n\tvec2 z = vec2( -3.5, -1.5 );\n\tfloat escapeRadius = 44.+4.*sin(iTime*.5);\n    \n\tfor (float i = 0.; i < MAX_ITERS; ++i)\n    {\n\t\tvec2 newz = vec2( z.x*z.x - z.y*z.y, 2.0*z.x*z.y ) + c;\n        z = newz / ( 0.01*dot(newz,z) - 2. ); // added hack, inspired by kaliset\n        \n        // is this the layer we're interested in?\n        if( i + 1. == layer )\n        {\n\t        // check for escape, if so then the pixel has hit this layer.\n            // also, vary escape radius over time to add a little more interest\n            return dot(z,z) > escapeRadius*escapeRadius;\n        }\n \t}\n    \n\treturn false;\n}\n\n// layer colors\nvec3 layerCol( float s )\n{\n    if( s == 10. ) return vec3(1.,.95,.95);\n    if( s == 9. ) return vec3(1.,1.,.2);\n    if( s == 8. ) return vec3(1.,1.,.2);\n    if( s == 7. ) return 1.2*vec3(1.,.75,.2);\n    if( s == 6. ) return vec3(1.,.5,.1);\n    if( s == 5. ) return vec3(1.,.2,0.);\n    if( s == 4. ) return vec3(.7,.0,0.);\n    if( s == 3. ) return vec3(.25,.0,0.);\n    return vec3(.15,.0,0.);\n}\n\nvec3 shade( vec2 fragCoord )\n{\n    // add some depth based on screen position (hack)\n    float zscr = dot(fragCoord/iResolution.xy-.5,fragCoord/iResolution.xy-.5);\n    zscr = .75*(.25-zscr);\n    \n    // process one layer of the fractal at a time so that we can apply different amounts of parallax to each\n    for( float layer = 2.; layer < MAX_ITERS; layer++ )\n    {\n        float parallaxZ = layer-1.; parallaxZ = 4.5*parallaxZ*parallaxZ + zscr;\n        vec2 off = vec2( cos(.33*iTime), sin(.133*iTime)) * 180./parallaxZ;\n        \n        if( intersectsLayer( fragCoord + off, layer ) )\n        {\n            return layerCol(layer);\n        }\n    }\n    // bg\n    return layerCol(10.);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // crude AA using N-Queens pattern, does the job. some kind of analytical version should be possible and could be cheaper.\n    fragColor.xyz  = shade( fragCoord + vec2(-3./8.,-1./8.) );\n    fragColor.xyz += shade( fragCoord + vec2(-1./8., 3./8.) );\n    fragColor.xyz += shade( fragCoord + vec2( 3./8., 1./8.) );\n    fragColor.xyz += shade( fragCoord + vec2( 1./8.,-3./8.) );\n    fragColor /= 4.;\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Xt3SWs.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[24, 24, 77, 77, 820], [822, 838, 864, 864, 1231], [1233, 1233, 1263, 1317, 1920], [1922, 1922, 1979, 2106, 2381]], "test": "valid"}
{"id": "Xt3Szs", "name": "ZoomSquares", "author": "dila", "description": "This is a bit of a mess.", "tags": ["zoomingforever"], "likes": 11, "viewed": 186, "published": "Public", "date": "1481067329", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec3 col1 = vec3(0.118, 0.365, 0.467);\nvec3 col2 = vec3(0.514, 0.851, 0.933);\nvec3 col3 = vec3(0.957, 0.875, 0.29);\nvec3 col4 = vec3(0.973, 0.663, 0.106);\nvec3 col5 = vec3(0.843, 0.431, 0.176);\nvec3 col6 = vec3(0.361, 0.251, 0.145);\n\nmat2 rot(float x)\n{\n    return mat2(cos(x), sin(x), -sin(x), cos(x));\n}\n\nfloat sdBox( vec2 p, vec2 b )\n{\n  vec2 d = abs(p) - b;\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nvec2 box(vec2 p, float r, float k, float t)\n{\n\tvec2 q = vec2(atan(p.y, p.x) / 3.14159 * k, length(p) - r);\n    q.x = (fract(q.x / k) - 0.5) * k;\n    q.y = sdBox(p * rot(t), vec2(1.0));\n    return q;\n}\n\nvec3 cout = vec3(0.0);\n\nvec3 tex(vec2 p, float t, float pt)\n{\n    vec2 of = vec2(cos(t), sin(t)) * 0.5;\n    vec2 pof = vec2(cos(pt), sin(pt)) * 0.5;\n    \n\tvec2 c = box(p + of, 1.0, 3.0, t);\n    vec2 c2 = box(p + of, 1.0, 3.0, t);\n    \n    float ln = 10000.0;\n    \n    float k = 1.0 / (1.0 + c.y * c.y * ln);\n    float u = 1.0 / (1.0 + c2.y * c2.y * ln);\n    \n    vec2 sub = p;\n    \n    cout.xy = sub / 0.25;\n    cout.z = 1.0;\n    \n    float d = 1000.0;\n    vec2 q = c2;\n    for (int i = 0; i < 6; ++i) {\n        for (int j = 0; j < 3; ++j) {\n            q.x = abs(q.x) - 0.125;\n            q *= rot(3.141592 * 0.25);\n        }\n        q.y = abs(q.y) - 0.25;\n        q *= rot(3.141592 * 0.125);\n        d = min(d, sdBox(q, vec2(0.125)));\n    }\n    \n    float r = 1.0 / (1.0 + d * d * ln);\n    \n    vec2 ins = box(cout.xy + pof, 1.0, 1.0, pt);\n    float imask = max(sign(ins.y), 0.0);\n    float omask = max(sign(-c.y), 0.0);\n    float mask = imask * omask;\n    r *= omask * imask;\n    \n    vec2 rp = p + of;\n    \n    vec3 tex1 = texture(iChannel0, rp).xyz;\n\ttex1 = vec3(dot(tex1, vec3(0.299, 0.587, 0.114)));\n    tex1 *= col1;\n    \n    vec3 dest = mix(tex1, vec3(0.0), max(sign(d), 0.0)) * mask;\n    vec3 src = mix(col3, vec3(0.0), max(sign(-d), 0.0)) * mask;\n    \n    vec3 fc = mix(src + dest, vec3(0.0), r);\n    \n    return mix(fc, col3 * 2.0, k);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    uv = uv * 2.0 - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    vec3 r = normalize(vec3(uv, 1.0 - dot(uv,uv) * 0.1));\n    vec3 o = vec3(0.0, 0.0, -2.0);\n    vec3 n = vec3(0.0, 0.0, 1.0);\n    \n    float st = iTime;\n    \n    o.xy += vec2(cos(iTime) * sin(iTime), sin(iTime)) * 2.0;\n    r.xy *= rot(st);\n    n.xz *= rot(sin(iTime) * 0.3);\n    n.xy *= rot(st);\n    \n\tfloat t = -dot(o, n) / dot(r, n);\n    t += max(sign(-t), 0.0) * -1000.0;\n    vec3 w = o + r * t;\n    \n    float end = log(256.0);\n    float zt = mod(st, end);\n    float depth = 64.0 * exp(zt);\n    w.xy /= depth;\n    \n    /* to give the appearence of linear time zooming i use exp(iTime). */\n    /* the scene matches up every 4^n seconds, so i can only mod() when */\n    /* exp(iTime) = some power of 4, and for this modulus i use log(4^4 = 256) */\n    \n    vec3 p = vec3(w.xy, 1.0);\n    vec3 col = vec3(0.0);\n    float pinv = 0.0;\n    \n    for (int i = 0; i < 10; ++i) {\n        float inv = mod(floor(float(i)), 2.0) * 2.0 - 1.0;\n        float t = inv * iTime / end * 3.141592;\n        float pt = pinv * iTime / end * 3.141592;\n    \tcol += tex(p.xy, t, pt) * p.z;\n        p = cout;\n        pinv = inv;\n    }\n    \n    float fog = 1.0 / (1.0 + t * t * 0.01);\n    \n    col = mix(col6, col, fog);\n    \n\tfragColor = vec4(sqrt(col), 1.0);\n}", "image_inputs": [{"id": "XdfGRn", "previewfilepath": "/media/ap/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Xt3Szs.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[234, 234, 253, 253, 305], [307, 307, 338, 338, 416], [418, 418, 463, 463, 618], [644, 644, 681, 681, 1969], [1971, 1971, 2028, 2028, 3381]], "test": "error"}
{"id": "Xt3SzX", "name": "Capsule - intersection", "author": "iq", "description": "Intersection of a ray and a generic (oriented in any direction) capsule. This computes the intersection with a truncated cylinder and a ONE sphere (as opposed to two).", "tags": ["3d", "raycasting", "intersection", "capsule"], "likes": 26, "viewed": 3824, "published": "Public API", "date": "1480726955", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// The MIT License\n// Copyright  2016 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n\n// Intersection of a ray and a capped cylinder oriented in an arbitrary direction. There's\n// only one sphere involved, not two.\n\n\n// Other capsule functions:\n//\n// Capsule intersection: https://www.shadertoy.com/view/Xt3SzX\n// Capsule bounding box: https://www.shadertoy.com/view/3s2SRV\n// Capsule distance:     https://www.shadertoy.com/view/Xds3zN\n// Capsule occlusion:    https://www.shadertoy.com/view/llGyzG\n\n// List of ray-surface intersectors at https://www.shadertoy.com/playlist/l3dXRf\n// and http://iquilezles.org/www/articles/intersectors/intersectors.htm\n\n\n\n// intersect capsule : http://www.iquilezles.org/www/articles/intersectors/intersectors.htm\nfloat capIntersect( in vec3 ro, in vec3 rd, in vec3 pa, in vec3 pb, in float r )\n{\n    vec3  ba = pb - pa;\n    vec3  oa = ro - pa;\n\n    float baba = dot(ba,ba);\n    float bard = dot(ba,rd);\n    float baoa = dot(ba,oa);\n    float rdoa = dot(rd,oa);\n    float oaoa = dot(oa,oa);\n\n    float a = baba      - bard*bard;\n    float b = baba*rdoa - baoa*bard;\n    float c = baba*oaoa - baoa*baoa - r*r*baba;\n    float h = b*b - a*c;\n    if( h>=0.0 )\n    {\n        float t = (-b-sqrt(h))/a;\n        float y = baoa + t*bard;\n        // body\n        if( y>0.0 && y<baba ) return t;\n        // caps\n        vec3 oc = (y<=0.0) ? oa : ro - pb;\n        b = dot(rd,oc);\n        c = dot(oc,oc) - r*r;\n        h = b*b - c;\n        if( h>0.0 ) return -b - sqrt(h);\n    }\n    return -1.0;\n}\n\n// compute normal\nvec3 capNormal( in vec3 pos, in vec3 a, in vec3 b, in float r )\n{\n    vec3  ba = b - a;\n    vec3  pa = pos - a;\n    float h = clamp(dot(pa,ba)/dot(ba,ba),0.0,1.0);\n    return (pa - h*ba)/r;\n}\n\n\n// fake occlusion\nfloat capOcclusion( in vec3 p, in vec3 n, in vec3 a, in vec3 b, in float r )\n{\n    vec3  ba = b - a, pa = p - a;\n    float h = clamp(dot(pa,ba)/dot(ba,ba),0.0,1.0);\n    vec3  d = pa - h*ba;\n    float l = length(d);\n    float o = 1.0 - max(0.0,dot(-d,n))*r*r/(l*l*l);\n    return sqrt(o*o*o);\n}\n\nvec3 pattern( in vec2 uv )\n{\n    vec3 col = vec3(0.6);\n    col += 0.4*smoothstep(-0.01,0.01,cos(uv.x*0.5)*cos(uv.y*0.5)); \n    col *= smoothstep(-1.0,-0.98,cos(uv.x))*smoothstep(-1.0,-0.98,cos(uv.y));\n    return col;\n}\n\n#define AA 3\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // camera movement\t\n\tfloat an = 0.5*iTime;\n\tvec3 ro = vec3( 1.0*cos(an), 0.4, 1.0*sin(an) );\n    vec3 ta = vec3( 0.0, 0.0, 0.0 );\n    // camera matrix\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(0.0,1.0,0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n\n    \n    vec3 tot = vec3(0.0);\n    \n    #if AA>1\n    for( int m=0; m<AA; m++ )\n    for( int n=0; n<AA; n++ )\n    {\n        // pixel coordinates\n        vec2 o = vec2(float(m),float(n)) / float(AA) - 0.5;\n        vec2 p = (-iResolution.xy + 2.0*(fragCoord+o))/iResolution.y;\n        #else    \n        vec2 p = (-iResolution.xy + 2.0*fragCoord)/iResolution.y;\n        #endif\n\n\t    // create view ray\n        vec3 rd = normalize( p.x*uu + p.y*vv + 1.5*ww );\n\n        const vec3  capA = vec3(-0.3,-0.1,-0.1);\n        const vec3  capB = vec3(0.3,0.1,0.4);\n        const float capR = 0.2;\n        \n\t    vec3 col = vec3(0.08)*(1.0-0.3*length(p)) + 0.02*rd.y;\n\n        float t = capIntersect( ro, rd, capA, capB, capR );\n        if( t>0.0 )\n        {\n            vec3  pos = ro + t*rd;\n            vec3  nor = capNormal(pos, capA, capB, capR );\n            vec3  lig = normalize(vec3(0.7,0.6,0.3));\n            vec3  hal = normalize(-rd+lig);\n            float dif = clamp( dot(nor,lig), 0.0, 1.0 );\n            float amb = clamp( 0.5 + 0.5*dot(nor,vec3(0.0,1.0,0.0)), 0.0, 1.0 );\n            float occ = 0.5 + 0.5*nor.y;\n\n            vec3 w = normalize(capB-capA);\n            vec3 u = normalize(cross(w,vec3(0,0,1)));\n            vec3 v = normalize(cross(u,w) );\n            vec3 q = (pos-capA)*mat3(u,v,w);\n            col = pattern( vec2(12.0,64.0)*vec2(atan(q.y,q.x),q.z) );\n\n\n            col *= vec3(0.2,0.3,0.4)*amb*occ + vec3(1.0,0.9,0.7)*dif;\n            col += 0.4*pow(clamp(dot(hal,nor),0.0,1.0),12.0)*dif;\n        }\n\n        col = sqrt( col );\n\t\n\t    tot += col;\n    #if AA>1\n    }\n    tot /= float(AA*AA);\n    #endif\n\n    // dither to remove banding in the background\n    tot += fract(sin(fragCoord.x*vec3(13,1,11)+fragCoord.y*vec3(1,7,5))*158.391832)/255.0;\n\n\n    fragColor = vec4( tot, 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Xt3SzX.jpg", "access": "shaders20k", "license": "mit", "functions": [[1650, 1742, 1824, 1824, 2512], [2514, 2532, 2597, 2597, 2723], [2726, 2744, 2822, 2822, 3036], [3038, 3038, 3066, 3066, 3256]], "test": "valid"}
{"id": "Xt3XDf", "name": "BW_JuliaSet", "author": "DimitryK", "description": "understanding the mandelbrot and the julia set", "tags": ["fractal"], "likes": 1, "viewed": 106, "published": "Public", "date": "1481766722", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const int MAXITER = 1024;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (-iResolution.xy + 2.0*fragCoord.xy)/iResolution.y;\n    float t = iTime;\n    \n    float zoom = cos(0.1*t)*0.4;\n    zoom = pow( zoom,2.) + 0.00001;\n    uv *= zoom;\n    float x = -1.16484;\n    float y = 0.25587;\n    uv += vec2(x,y);\n    \n    vec2 z = uv;\n    vec2 comp = vec2(-1.,0.28101011);\n    vec3 c = vec3(0.0);\n    \n    for(int i=0; i < MAXITER; i++)\n    {\n        c = vec3(1./float(MAXITER) * float(i));\n        if ((z.x*z.x + z.y*z.y) > 4.) break;\n        z = vec2(z.x*z.x - z.y*z.y, 2.*z.y*z.x) + comp;\n    }\n    \n\tfragColor = vec4(c,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Xt3XDf.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[27, 27, 84, 84, 647]], "test": "valid"}
{"id": "Xt3XzX", "name": "Concentric Circles Redo", "author": "twitchingace", "description": "Redoing my first accident of a shader to be much more compact. Could probably use some form of smoothing or minification. Maybe some day when I get time I'll actually implement my original idea.", "tags": ["2d", "circle", "concentric"], "likes": 1, "viewed": 119, "published": "Public", "date": "1480736004", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Move the center of the concentric circles in a small circle\n    vec2 center = vec2(0.5, 0.25);\n    center += vec2(sin(iTime) * .25, cos(iTime) * .25);\n    \n\tvec2 uv = fragCoord / iResolution.x;\n    // Create the rings by running the distance through some simple math\n    // and checking if the result is odd.\n    if (mod(float(int(distance(uv,center) * 25.)), 2.) == 1.){\n        fragColor = vec4(0.);\n    }\n    else {\n\t\tfragColor = vec4(uv,0.5+0.5*sin(iTime),1.0);\n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Xt3XzX.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 124, 538]], "test": "valid"}
{"id": "XtcSzf", "name": "Tearing Test", "author": "yakoudbz", "description": "A simple rotating grid as a tearing test", "tags": ["grid", "60fps"], "likes": 9, "viewed": 3571, "published": "Public", "date": "1480761099", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI 3.141592\n\n// size of a square in pixel\n#define N 20.0\n\n// rotation angle\n#define A iTime\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tfragCoord-=iResolution.xy/2.0;\n    \n    // rotation\n    vec2 Coord = mat2(cos(A),-sin(A),sin(A),cos(A))*fragCoord;\n    \n    // the grid in itself\n    Coord = cos(PI/N*Coord);\n\tfragColor = vec4(1.0)-0.5*smoothstep(0.9,1.0,max(Coord.x,Coord.y));\n}\n\n/* // golfed version from FabriceNeyret2\nvoid mainImage( out vec4 O, vec2 U )\n{\n\tU = cos ( PI/N * mat2(sin(A+PI*vec4(.5,1,0,.5))) * (U-iResolution.xy/2.) );\n\tO += 1.-.5*smoothstep(.9,1.,max(U.x,U.y)) -O;\n}\n*/", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XtcSzf.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[101, 101, 158, 158, 405]], "test": "valid"}
{"id": "XtcSzs", "name": "triangle maker", "author": "zproxy", "description": "from https://www.shadertoy.com/view/MldXzf", "tags": ["raymarching"], "likes": 2, "viewed": 148, "published": "Public", "date": "1481063359", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// \"Quake Logo\" by Krzysztof Narkowicz @knarkowicz\n\nconst float MATH_PI = float( 3.14159265359 );\n\nfloat VisibilityTerm( float roughness, float ndotv, float ndotl )\n{\n\tfloat m2\t= roughness * roughness;\n\tfloat visV\t= ndotl * sqrt( ndotv * ( ndotv - ndotv * m2 ) + m2 );\n\tfloat visL\t= ndotv * sqrt( ndotl * ( ndotl - ndotl * m2 ) + m2 );\n\treturn 0.5 / max( visV + visL, 0.00001 );\n}\n\nfloat DistributionTerm( float roughness, float ndoth )\n{\n\tfloat m2\t= roughness * roughness;\n\tfloat d\t\t= ( ndoth * m2 - ndoth ) * ndoth + 1.0;\n\treturn m2 / ( d * d * MATH_PI );\n}\n\nvec3 FresnelTerm( vec3 specularColor, float vdoth )\n{\n\tvec3 fresnel = clamp( 50.0 * specularColor.y, 0.0, 1.0 ) * specularColor + ( 1.0 - specularColor ) * pow( ( 1.0 - vdoth ), 5.0 );\n\treturn fresnel;\n}\n\nvec3 LightSpecular( vec3 normal, vec3 viewDir, vec3 lightDir, vec3 lightColor, float roughness, vec3 specularColor )\n{\n\tvec3 halfVec = normalize( viewDir + lightDir );\n\n\tfloat vdoth = clamp( dot( viewDir,\thalfVec\t ), 0.0, 1.0 );\n\tfloat ndoth\t= clamp( dot( normal,\thalfVec\t ), 0.0, 1.0 );\n\tfloat ndotv = clamp( dot( normal,\tviewDir  ), 0.0, 1.0 );\n\tfloat ndotl = clamp( dot( normal,\tlightDir ), 0.0, 1.0 );\n    \n   \tvec3\tf = FresnelTerm( specularColor, vdoth );\n\tfloat\td = DistributionTerm( roughness, ndoth );\n\tfloat\tv = VisibilityTerm( roughness, ndotv, ndotl );\n    \n    vec3 specular;\n\tspecular = lightColor * f * ( d * v * MATH_PI * ndotl );\n\treturn specular;\n}\n\nfloat Cylinder( vec3 p, float r, float height ) \n{\n\tfloat d = length( p.xz ) - r;\n\td = max( d, abs( p.y ) - height );\n\treturn d;\n}\n\nfloat Sphere( vec3 p, float s )\n{\n\treturn length( p ) - s;\n}\n\nfloat Box( vec3 p, vec3 b )\n{\n\tvec3 d = abs( p ) - b;\n\treturn min( max( d.x, max( d.y, d.z ) ), 0.0 ) + length( max( d, 0.0 ) );\n}\n\nfloat Substract( float a, float b )\n{\n    return max( a, -b );\n}\n\nfloat SubstractRound( float a, float b, float r ) \n{\n\tvec2 u = max( vec2( r + a, r - b ), vec2( 0.0, 0.0 ) );\n\treturn min( -r, max( a, -b ) ) + length( u );\n}\n\nfloat Union( float a, float b )\n{\n    return min( a, b );\n}\n\nfloat UnionRound( float a, float b, float k )\n{\n    float h = clamp( 0.5 + 0.5 * ( b - a ) / k, 0.0, 1.0 );\n    return mix( b, a, h ) - k * h * ( 1.0 - h );\n}\n\nfloat TriPrism( vec3 p, float rot, float offset1 )\n{   \n    \n    vec3 q = abs( p );\n    \n    // can we get off center?\n     return max(\n        // creates some type of symmetry\n         \n         // need mouse to see if thin enough\n        q.y - 0.05, \n     \n        // vertical line\n        p.x * cos(rot) + (p.z - offset1) * sin(rot) + offset1   \n     );\n}\n\nfloat Scene( vec3 p, mat3 localToWorld )\n{\n    // shadertoy should have time slider.\n    \n    p = p * localToWorld;\n    \n    \n    \n    float rot1deg =   20. * iTime;\n    \n    // align our triangle so we need to move union on x axis only.\n    //float rot1deg =   -25.;\n    \n    //float rot1deg =   -20.;\n    //float rot1deg =   -40.;\n    \n    float rot1 =   2.0 * MATH_PI / 360.0 * ( rot1deg);\n    \n    //float rot2a = mod(0.0 + 20. * iTime, 360.);\n    \n    // lets make our triangle slim. \n    float rot2a = 50.;\n\n    //float rot2a = (0.0 + 20. * iTime) % 360.;\n\n    float rot2 = 2.0 * MATH_PI / 360.0 * (180.0 - rot2a);\n    //float rot22 = 2.0 * MATH_PI / 360.0 * (180.0 - rot2a);\n    \n    \n    // one angle of a triangle cannot exceed 180 ever\n    \n    if (rot2a > 180.0)\n    \treturn 0.0;\n    \n    \n    float offset1 = sin(iTime) * 0.9 - 0.25;\n\n    \n    float slice = max(TriPrism(  p, rot1, 0. ) ,\n                \n                 TriPrism(  p, rot1-rot2, 0.  )\n                \n                );\n    \n    // need a third wall\n    \n     \n    float rot2x90 = 2.0 * MATH_PI / 360.0 * (180.0 - (rot2a - 90. - rot2a /2. ));\n    \n    \n    \n    if (offset1 < 0.0)\n    \t// show all\n        return max( slice,\n               \n               // plus half rot2a\n               TriPrism(  p , rot1  - rot2x90 , offset1  )\n               );\n        \n    return min( slice,\n               \n               // plus half rot2a\n               TriPrism(  p , rot1  - rot2x90 , offset1  )\n               );\n    \n    //return 2.0;\n    \n    // all green\n    return 0.5;\n    \n    // all black\n    return 0.0;\n    \n    \n    // ring\n    float a = Cylinder( p, 0.3, 0.1 );\n    \n    \n    //return Union(ret, a);\n}\n\nvec2 CastRay( in vec3 ro, in vec3 rd, mat3 localToWorld )\n{\n    const float maxd = 9.0;\n    \n\tfloat h = 0.5;\n    float t = 0.0;\n    float steps = 0.0;\n   \n    for ( int i = 0; i < 50; ++i )\n    {\n        if ( h < 0.001 || t > maxd ) \n        {\n            break;\n        }\n        \n\t    h = Scene( ro + rd * t, localToWorld );\n        t += h;\n        steps += 0.03;\n    }\n\n    if ( t > maxd )\n    {\n        t = -1.0;\n    }\n\t\n    return vec2(t, steps);\n}\n\nvec3 SceneNormal( in vec3 pos, mat3 localToWorld )\n{\n\tvec3 eps = vec3( 0.001, 0.0, 0.0 );\n\tvec3 nor = vec3(\n\t    Scene( pos + eps.xyy, localToWorld ) - Scene( pos - eps.xyy, localToWorld ),\n\t    Scene( pos + eps.yxy, localToWorld ) - Scene( pos - eps.yxy, localToWorld ),\n\t    Scene( pos + eps.yyx, localToWorld ) - Scene( pos - eps.yyx, localToWorld ) );\n\treturn normalize( -nor );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 q = fragCoord.xy / iResolution.xy;\n    vec2 p = -1.0 + 2.0 * q;\n\tp.x *= iResolution.x / iResolution.y;\n\n    // have comera zoom in and out to reveal boundaries\n\tvec3 rayOrigin \t= vec3( 0.0, -0.0, -4.25 + sin( iTime * 2.0) * 0.25 );\n    vec3 rayDir \t= normalize( vec3( p.x, p.y, 2.0 ) );\n    \n    float theta = -0.5 * MATH_PI;\n    mat3 rotX = mat3(\n        vec3( cos( theta ), sin( theta ), 0.0 ),\n        vec3( -sin( theta ), cos( theta ), 0.0 ),\n\t\tvec3( 0.0, 0.0, 1.0 )\n        );    \n    \n    vec2 mo = iMouse.xy / iResolution.xy;    \n    float phi = 0.25 * MATH_PI + (10.0 * mo.x)  + 0.01 *sin(0.1 * iTime);    \n    //float phi = 0.25 * MATH_PI; \n    \n    // look straight at it. no mouse\n   // float phi = 0.5 * MATH_PI;    \n\n    mat3 rotY = mat3(\n        vec3( 1.0, 0.0, 0.0 ),\n        vec3( 0.0, cos( phi ), sin( phi ) ),\n        vec3( 0.0, -sin( phi ), cos( phi ) )\n        );\n    \n    //mat3 localToWorld = rotX * rotY;    \n    mat3 localToWorld = rotX * rotY;    \n\n\n\tvec3 color =vec3(0.0);\n    \n\tvec2 result = CastRay( rayOrigin, rayDir, localToWorld );\n    \n    if ( result.x > 0.0 )\n    {\n      color = vec3(result.y*2.0, result.y*0.3, result.y*0.2);\n    }\n    else\n    {\n        // glow color\n        \n        float offset1 = sin(iTime) * 0.9 - 0.25;\n\n        \n        if (offset1 < 0.0)\n            \n      color = vec3(0.0, result.y*abs(sin(iTime*1.8)),0.0);\n      else\n        color = vec3(result.y*abs(sin(iTime*1.8)), result.y*abs(sin(iTime*1.8)),0.0);\n\n    }\n    \n    fragColor = vec4( color, 1.0 );\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XtcSzs.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[99, 99, 166, 166, 380], [382, 382, 438, 438, 559], [561, 561, 614, 614, 764], [766, 766, 884, 884, 1431], [1433, 1433, 1483, 1483, 1563], [1565, 1565, 1598, 1598, 1625], [1627, 1627, 1656, 1656, 1757], [1759, 1759, 1796, 1796, 1823], [1825, 1825, 1877, 1877, 1983], [1985, 1985, 2018, 2018, 2044], [2046, 2046, 2093, 2093, 2204], [2206, 2206, 2258, 2258, 2564], [2566, 2566, 2608, 2650, 4258], [4260, 4260, 4319, 4319, 4713], [4715, 4715, 4767, 4767, 5099], [5101, 5101, 5158, 5158, 6683]], "test": "valid"}
{"id": "XtcXRs", "name": "[ #01 ] - SF 3D", "author": "Yrai", "description": "Three different fractal materials bumped on 3D superformula generated shapes.", "tags": ["2d", "3d", "fractal", "superformula"], "likes": 9, "viewed": 701, "published": "Public API", "date": "1481149777", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define TIME iTime\n#define RES  iResolution\n#define PI 3.141592653589793\n\n#define MARCH_STEPS 128\n#define MARCH_RANGE 100.\n#define MARCH_PERC  .00001\n\n\n#define SUPERFORMULA_2D(m,a,b,n1,n2,n3,phi) pow(pow(abs(cos(m*phi/4.)/a), n2) + pow(abs(sin(m*phi/4.)/b), n3), -n1)\n\n\n#define X_ROT(a) mat3(1.,0.,0.,0.,cos(a),-sin(a),0.,sin(a),cos(a))\n#define Y_ROT(a) mat3(cos(a),0.,-sin(a),0.,1.,0.,sin(a),0.,cos(a))\n#define Z_ROT(a) mat3(cos(a),-sin(a),0.,sin(a),cos(a),0.,0.,0.,1.)\n\n\n#define DOMAIN(uv,s) (2.*uv-RES.xy)/RES.y*s\n\n\nfloat modelGeometry(vec3 pos);\nvec3 calcNormal(vec3 pos);\nfloat superformula3D(\n    vec3 p,\n    float m1, float a1, float b1, float n11, float n21, float n31,\n    float m2, float a2, float b2, float n12, float n22, float n32\n);\n\nvec3 shadeFractalBump(vec3 pos, vec3 rayDirection);\n\nvec3 rayDirection;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\tvec2 uv = DOMAIN(fragCoord, 2.);\n\tvec3 fpc = vec3(0.);\n    \n    /* Camera */\n   \tvec3 rayOrigin = vec3(3.0*sin(TIME), 3.*cos(TIME), -3.0*cos(TIME));\n\tvec3 ww = normalize(-rayOrigin);\n\tvec3 uu = normalize(cross(vec3(0, 1, 0), ww));\n\tvec3 vv = normalize(cross(ww, uu));\n\tvec3 rayDirection = normalize(uv.x*uu + uv.y*vv + 1.97*ww);\n    \n    /* Raymarching */\n    float currDistance = 1.;\n    float distanceMarched = 0.;\n    for(int i=0; i<MARCH_STEPS; i++) {\n    \tif(currDistance < MARCH_PERC || distanceMarched > MARCH_RANGE)\n            break;\n        \n        currDistance = modelGeometry(rayOrigin + distanceMarched * rayDirection);\n        distanceMarched += currDistance;\n    }\n    \n    /* Shading */\n    if(distanceMarched < MARCH_RANGE) {\n    \tvec3 pos = vec3(rayOrigin + distanceMarched * rayDirection);\n        fpc = shadeFractalBump(pos,rayDirection);\n    }\n    \n    fragColor = vec4(fpc,1.);\n}\n\nfloat modelGeometry(vec3 pos) {\n    float m1 = floor(mod(TIME,20.)+1.);\n    float m2 = floor(mod(TIME,20.)+1.);\n    float n11 = floor(abs(1.3*sin(TIME)))+1.;\n    float n12 = floor(abs(1.3*cos(TIME)))+1.;\n    \n    float d = superformula3D(pos,\n        m1,n11,1.,-1.,1.,10.,\n        m2,n12,1.,1.,1.,1.\n    );\n    float s = d*.5;\n    float dEps = superformula3D(pos + rayDirection*s,\n        m1,n11,1.,-1.,1.,10.,\n        m2,n12,1.,1.,1.,1.\n    );\n    float dr = (d-dEps)/s;\n    \n    return (d / (4.5+max(dr, 0.)));\n\n}\n\nfloat superformula3D(\n    vec3 p,\n    float m1, float a1, float b1, float n11, float n21, float n31,\n    float m2, float a2, float b2, float n12, float n22, float n32\n) {\n    float d = length(p); \n    float theta = atan(p.z/p.x); \n    float phi = asin(p.y/d); \n   \n    float r1 = SUPERFORMULA_2D(m1, a1, b1, n11, n21, n31, theta);\n    float r2 = SUPERFORMULA_2D(m2, a2, b2, n12, n22, n32, phi);\n    \n    vec3 q = r2 * vec3(r1*cos(theta)*cos(phi), r1*sin(theta)*cos(phi), sin(phi));\n\treturn (d - length(q));\n}\n\nvec3 calcNormal(vec3 pos) {\n    vec2 e = vec2(MARCH_PERC, 0.0);\n    return normalize(vec3(\n        modelGeometry(pos + e.xyy) - modelGeometry(pos - e.xyy),\n        modelGeometry(pos + e.yxy) - modelGeometry(pos - e.yxy),\n        modelGeometry(pos + e.yyx) - modelGeometry(pos - e.yyx)\n    ));\n}\n\nvec3 fractalMaterial1(vec2 p) {\n\tfloat x = 0.;\n    float y = 0.;\n    float v = 100000.;\n    float j = 100000.;\n    vec3 col = vec3(0.);\n    for(int i=0; i<100;i++) {\n    \tfloat xt = x*x-y*y+p.x;\n        y = 2.*x*y+p.y;\n        x = xt;\n        v = min(v, abs(x*x+y*y));\n        j = min(j, abs(x*y));\n        if(x*x+y*y >= 8.) {\n        \tfloat d = (float(i) - (log(log(sqrt(x*x+y*y))) / log(2.))) / 50.;\n            v = (1. - v) / 2.;\n            j = (1. - j) / 2.;\n            col = vec3(d+j,d,d+v);\n            return col;\n        }\n    }\n}\n\nvec3 fractalMaterial2(vec2 p) {\n\tvec3 col = vec3(100);\n\t\n\tfor(int i = 0; i < 15; i++) {\n\t\tp = abs(p)/dot(p, p) - vec2(0.5, 0.3);\n\t\tcol = min(col, vec3(abs(p.x), length(p), abs(3.0*p.y)));\n\t}\n\t\n\treturn col;\n}\n\nvec3 fractalMaterial3(vec2 uv) {\n    const int MAGIC_BOX_ITERS = 15;\n\tconst float MAGIC_BOX_MAGIC = .55;\n    const mat3 M = mat3(0.28862355854826727, 0.6997227302779844, 0.6535170557707412,\n                    0.06997493955670424, 0.6653237235314099, -0.7432683571499161,\n                    -0.9548821651308448, 0.26025457467376617, 0.14306504491456504);\n    uv.x += 0.4;\n    vec3 p = 0.5*M*vec3(uv, 1.0);\n        p = 1.0 - abs(1.0 - mod(p, 2.0));\n    \n    float lastLength = length(p);\n    float tot = 0.0;\n    for (int i=0; i < MAGIC_BOX_ITERS; i++) {\n      p = abs(p)/(lastLength*lastLength) - MAGIC_BOX_MAGIC;\n      float newLength = length(p);\n      tot += abs(newLength-lastLength);\n      lastLength = newLength;\n    }\n\n    tot *= 0.03;\n    return vec3(tot*uv.x, tot*tot, 4.*tot*uv.y*uv.y);\n}\n\nvec3 matcube(vec3 p, vec3 n) {\n\tvec3 m = pow(abs(n), vec3(10.0));\n\t\n    float timeSwitch = floor(mod(TIME,15.));\n    \n    vec3 x,y,z;\n    if(timeSwitch >=0. && timeSwitch <= 5.) {\n        x = fractalMaterial2(p.yz);\n        y = fractalMaterial2(p.xz);\n        z = fractalMaterial2(p.xy);\n    }\n    else if(timeSwitch >=5. && timeSwitch <= 10.){\n        x = fractalMaterial1(p.yz);\n        y = fractalMaterial1(p.xz);\n        z = fractalMaterial1(p.xy);\n    }\n    else {\n        x = fractalMaterial3(p.yz);\n        y = fractalMaterial3(p.xz);\n        z = fractalMaterial3(p.xy);\n    }\n    \n\treturn (m.x*x + m.y*y + m.z*z)/(m.x + m.y + m.z);\n}\n\nvec3 matbump(vec3 p, vec3 n) {\n\tvec3 gs = vec3(0.21, 0.72, 0.07);\n\tvec2 h = vec2(0.015, 0.0);\n\t\n\tfloat res = dot(gs, matcube(p, n));\n\tmat3 m = mat3(\n\t\tmatcube(p - h.xyy, n),\n\t\tmatcube(p - h.yxy, n),\n\t\tmatcube(p - h.yyx, n)\n\t);\n\t\n\tvec3 g = (gs*m - res)/h.x;\n\tg -= n*dot(g, n);\n\t\n\treturn g;\n}\n\nvec3 shadeFractalBump(vec3 pos, vec3 rayDirection) {\n    vec3 nor = calcNormal(pos);\n    vec3 sn = normalize(nor + 0.04*matbump(pos, nor));\n    vec3 sn2 = normalize(nor + 0.4*matbump(pos, nor));\n    vec3 ref = normalize(reflect(rayDirection, sn));\n    \n    vec3 col = vec3(0.);\n    col += pow(clamp(dot(-rayDirection, ref), 0.0, 1.0), 10.0);\n    col += pow(clamp(1.0 + dot(rayDirection, sn2), 0.0, 1.0), 2.0);\n    col *=3.0*matcube(pos, nor);\n    return col;\n}\n\n\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XtcXRs.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[821, 821, 878, 878, 1782], [1784, 1784, 1815, 1815, 2299], [2301, 2301, 2471, 2471, 2809], [2811, 2811, 2838, 2838, 3105], [3649, 3649, 3680, 3680, 3856], [3858, 3858, 3890, 3890, 4657], [4659, 4659, 4689, 4689, 5300], [5302, 5302, 5332, 5332, 5592], [5594, 5594, 5646, 5646, 6054]], "test": "error"}
{"id": "XtdSDX", "name": "Shader night - Pixelize", "author": "inantop", "description": "Shader night", "tags": ["tutorial"], "likes": 0, "viewed": 83, "published": "Public", "date": "1481852545", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float repeatingValue = fract(iTime);\n    fragColor = vec4(repeatingValue);\n}", "image_inputs": [{"id": "XdXGzr", "previewfilepath": "/media/ap/8979352a182bde7c3c651ba2b2f4e0615de819585cc37b7175bcefbca15a6683.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/8979352a182bde7c3c651ba2b2f4e0615de819585cc37b7175bcefbca15a6683.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XtdSDX.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 138]], "test": "valid"}
{"id": "XtGSR1", "name": "Art : Apollonian Slices", "author": "Gijs", "description": "Just messing around. 3D Version : https://www.shadertoy.com/view/llG3Dt", "tags": ["2d", "fractal", "distance", "apollonian"], "likes": 24, "viewed": 540, "published": "Public", "date": "1482704093", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    float MinRes = min(iResolution.x,iResolution.y);\n    float MaxRes = max(iResolution.x,iResolution.y);\n    \n    float h = sin(-iTime*.1)*.495+.5;//Slice Height\n    \n    float Scale = (1.-h);//Slice width is basically proportional to slice height\n    //Set this is 1 to remove the zoom in\n    \n\tvec2 sp = (fragCoord.xy*2.-iResolution.xy)/MinRes*Scale;//Scaled view space\n    \n    vec3  p = vec3(sp.x,h,sp.y);//get the point in the 3D Slice\n   \n    //Apply Apollonian fractal formula on p\n\tfloat s = 1.;\n\tfor( int i=0; i<16;i++ ){\n\t\tp = mod(p+1.,2.)-1.;\n\t\tfloat k = 1.03/dot(p,p);\n\t\tp *= k;\n\t\ts *= k;\n\t}\n\t//aquire distance\n\tfloat d = .25*abs(p.y)/s;\n    \n    //color distance with an appropriate smoothstep scaled in view resolution and view space\n\tfragColor = vec4(smoothstep(MinRes*10./Scale,0.,1./d));\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XtGSR1.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 56, 56, 864]], "test": "valid"}
{"id": "XtGSRz", "name": "4D Raymarching", "author": "Neph", "description": "Orthographic projection 4D volume onto a 3D cube onto the 2D viewport. Lit by two 4D lights. I made the projection function up so it may not be the best way of doing this... Mouse to move w position, click to see normals.", "tags": ["3d", "raymarching", "4d", "tesseract"], "likes": 4, "viewed": 243, "published": "Public", "date": "1482349839", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define ITER 40 \n//marching iterations (per z step)\n\n#define ZRES 100\n//projection cube resolution down z axis\n\nfloat sdTesseract( vec4 p, vec4 b ) {\n    float tt = iTime*0.2;\n    p.xy *= mat2(cos(tt), -sin(tt), sin(tt), cos(tt));\n    p.xw *= mat2(cos(tt), -sin(tt), sin(tt), cos(tt));\n    p.yz *= mat2(cos(tt), -sin(tt), sin(tt), cos(tt));\n    p.yw *= mat2(cos(tt), -sin(tt), sin(tt), cos(tt));\n  vec4 d = abs(p) - b;\n  return min(max(d.x,max(d.y,max(d.z,d.w))),0.0) + length(max(d,0.0));\n}\n\nfloat map(vec4 p)\n{\n    float box = sdTesseract(p, vec4(0.5));\n    return box;\n}\n\nvec4 gradient (vec4 p){\n    const vec4 dx = vec4(0.1, 0.0, 0.0, 0.0);\n    const vec4 dy = vec4(0.0, 0.1, 0.0, 0.0);\n    const vec4 dz = vec4(0.0, 0.0, 0.1, 0.0);\n    const vec4 dw = vec4(0.0, 0.0, 0.0, 0.1);\n    \n    return normalize(vec4(\n        \t\tmap(p+dx) - map(p-dx),\n                map(p+dy) - map(p-dy),\n                map(p+dz) - map(p-dz),\n                map(p+dw) - map(p-dw)\n    \t\t\t));\n}\nvec3 shade(vec4 n, vec4 pos){\n    vec3 iFin = vec3(0.0);\n    float amb = 0.5;\n    {\n        vec3 col = vec3(0.7, 0.3, 0.0);\n        vec4 lpos = vec4(1.0);\n     \tvec4 lidir = normalize(lpos - pos);\n     \tfloat libdir = dot(n, lidir);\n     \tiFin += col * (libdir + amb);\n    }\n    {\n        vec3 col = vec3(0.0, 0.2, 0.7);\n        vec4 lpos = vec4(-1.0);\n     \tvec4 lidir = normalize(lpos - pos);\n     \tfloat libdir = dot(n, lidir);\n     \tiFin += col * (libdir + amb);\n    }\n    return iFin;\n}\n\nvec2 project(vec4 ro)\n{\n    float wdist = 0.0;\n    float zdist = 0.0;\n    \n    const float amt = 1.0 / float(ZRES);\n    for(float z = 0.0; z < 1.01; z += amt)\n    {\n        if(wdist > 0.5)\n            break;\n        zdist = z;\n        \n        vec3 xyz = vec3(ro.xy, z + ro.z);\n        float w = 0.0;\n        for(int i = 0; i < ITER; i++)\n        {\n            vec4 p = vec4(xyz, ro.w) + vec4(0.0, 0.0, 0.0, 1.0) * w;\n            float d = map(p);\n            w += d * 0.5;\n        }\n        wdist = w;\n    }\n    return vec2(wdist, zdist);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    uv = uv * 2.0 - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    vec2 zw = vec2(0.0, iMouse.x / iResolution.x);\n    \n    vec2 res = project(vec4(uv.x, uv.y, zw));\n    vec3 voxel = vec3(uv, res.y);\n    vec4 fdpos = vec4(voxel, 0.0) * res.y;\n    vec4 grad = gradient(fdpos);\n\t\n    vec3 col = vec3(0.0);\n    \n    if(iMouse.z < 0.0)\n    \tcol = shade(grad, fdpos);\n    else\n    \tcol = grad.xyz;\n    \n\tfragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XtGSRz.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[112, 112, 149, 149, 491], [493, 493, 512, 512, 573], [575, 575, 598, 598, 976], [977, 977, 1006, 1006, 1468], [1470, 1470, 1493, 1493, 2011], [2013, 2013, 2070, 2070, 2549]], "test": "valid"}
{"id": "XtGXz1", "name": "VR test scene (tweaked)", "author": "MobileForks01", "description": "fork to run faster on my phone.  so far reduced draw distance, dropped ceiling, added fog\noriginal at : https://www.shadertoy.com/view/MdBSz3", "tags": ["vr"], "likes": 3, "viewed": 603, "published": "Public API", "date": "1482733813", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n\nconst float PI =3.14159265;\nconst float PI2=6.28318531;\n\nfloat obj_ball(vec3 p, vec3 center, float radius){\n    return length(p-center)-radius;\n}\nfloat obj_box(vec3 p, vec3 center, vec3 size, float roundness){\n    vec3 d = abs(p-center)-size;\n    return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0)) - roundness;\n}\nfloat obj_cylinder(vec3 p, vec3 center, vec2 size, float roundness){\n    vec3 tp = p-center;\n    vec2 d = abs(vec2(length(tp.xz),tp.y)) - size;\n    return min(max(d.x,d.y)+roundness,0.0) + length(max(d,0.0))-roundness;\n}\nfloat obj_planeX(vec3 p, float planeX){\n    return p.x-planeX;\n}\nfloat obj_planeY(vec3 p, float planeY){\n    return p.y-planeY;\n}\nfloat obj_planeZ(vec3 p, float planeZ){\n    return p.z-planeZ;\n}\n\nfloat obj_cylForeverZ(vec2 p, float middleY, float radius){\n    return abs(length(vec2(p.x,p.y-middleY))) - radius;\n}\n\nfloat smooth_f( float a, float b, float k ){\n    float h = clamp(0.5+0.5*(b-a)/k,0.0,1.0);\n    return mix(b,a,h) - k*h*(1.0-h);\n}\n\nvoid hardAdd(inout float curD, inout int curMaterial, float newD, int newMaterial){\n    if (newD < curD) {\n        curD = newD;\n        curMaterial = newMaterial;\n    }\n}\nvoid hardSubtract(inout float curD, float newD) {\n    curD = max( -newD, curD );\n}\nvoid smoothAdd(inout float curD, float newD, float blendPower){//blend colors too?\n    curD = smooth_f( newD, curD, blendPower );\n}\nvoid smoothSubtract(inout float curD, float newD, float blendPower){\n    curD = -smooth_f( newD , -curD , blendPower );\n}\n\nconst float cylMidZ = -1.5;\n\nvec3 rotMod(vec3 p, vec2 middle, float modFrac){\n    vec2 cylRel = vec2(p.x-middle.x,p.z-middle.y);\n    float cylAng = atan(cylRel.y,cylRel.x);\n    float cylDist = length(cylRel);\n    float modSlice = PI2/modFrac;\n    float newAng = (mod((cylAng+modSlice*0.5),(modSlice)))-(modSlice*0.5);\n    return vec3(cos(newAng)*cylDist,p.y,sin(newAng)*cylDist);\n\n}\n\nfloat middleMod(float val,float modDist){\n    return mod(val+modDist*0.5,modDist)-modDist*0.5;\n}\n\nfloat room(vec3 p, out int material){\n\n\n    float distance = 9999.9;\n    material = 0;\n\n    const float pillarGapX = 2.5;\n    const float pillarGapZ = 0.5;\n\n    const float floorTileGap = 0.5;\n    const float floorTileGrout = 0.07;\n\n    const float ceilY = 9.0;\n\n    const float mirrorY = 0.5;\n\n    vec3 pillarP = vec3(mod(p.x,pillarGapX*2.0),-abs(p.y-mirrorY)+mirrorY,mod(p.z,pillarGapZ*2.0));\n/***\n    // ceiling flat\n    hardAdd(distance,material,\n            -obj_planeY(p ,ceilY),\n            3);\n\n    // ceiling groove\n    hardSubtract(distance,\n                 obj_cylForeverZ(vec2(middleMod(p.x,5.0),p.y),ceilY,2.3));\n***/\n    // base\n    hardAdd(distance,material,\n            obj_box(pillarP,vec3(pillarGapX,-1.4,pillarGapZ),vec3(0.4,0.15,0.4),0.0),\n            1);\n\n    // base blend\n    smoothAdd(distance,\n              obj_cylinder(pillarP,vec3(pillarGapX,-1.15,pillarGapZ),vec2(0.3,0.1),0.0),\n              0.11);\n\n    // floor\n    hardAdd(distance,material,\n            obj_box(vec3(mod(p.x,floorTileGap*2.0),p.y,mod(p.z,floorTileGap*2.0)),vec3(floorTileGap,-1.5-floorTileGap,floorTileGap),vec3(floorTileGap-floorTileGrout),floorTileGrout),\n            2);\n\n    //column\n    hardAdd(distance,material,\n            obj_cylinder(pillarP,vec3(pillarGapX,mirrorY,pillarGapZ),vec2(0.25,2.0),0.0),\n            1);\n\n\n\n\n\n\n\n    return distance;\n\n}\n\n\n\n\n\n\n\nvoid mainVR( out vec4 fragColor, in vec2 fragCoord, in vec3 fragRayOri, in vec3 fragRayDir ) {\n    \n    \n    vec3 cameraPos = fragRayOri;\n    vec3 curCameraRayUnit = fragRayDir;\n    \n    \n    \n    //scene movement\n    float fwdDist = iTime*0.2;\n    cameraPos.z -= fwdDist;\n    \n    \n    \n    // Raymarching.\n    const vec3 e=vec3(0.00007,0,0);\n    const float maxd=10.0; //Max depth\n    vec3 p;\n\n    float f=0.0;\n    float d=0.01;\n    int surfaceMaterial = 0;\n    for(int i=0;i<96;i++){\n        if ((abs(d) < .001) || (f > maxd)) break;\n        f+=d;\n        p=cameraPos+curCameraRayUnit*f;\n        d = room(p,surfaceMaterial);\n    }\n\n\n    vec3 color;\n    int dummyMaterial;\n\n    if (f < maxd){\n\n        vec3 surfaceColor;\n        float specA, specP;\n        float difP = 1.0;\n        vec3 normalCheat = vec3(0.0,0.0,0.0);//generally not advisable in stereo, but it's used very shallowly here\n\n        if (surfaceMaterial == 1){\n\n            vec3 marbleP = p;\n\n            marbleP.x += sin(p.y*20.0)*0.12;\n            marbleP.z += sin(p.y*22.0)*0.1;\n            marbleP.y += sin(p.x*25.0)*0.13;\n            marbleP.y += sin(p.z*23.0)*0.14;\n\n            marbleP.y += sin(p.x*1.3)*0.5;\n            marbleP.y += sin(p.z*1.5)*0.6;\n\n            marbleP.x += sin(p.y*150.0)*0.011;\n            marbleP.z += sin(p.y*162.0)*0.013;\n            marbleP.y += sin(p.x*145.0)*0.012;\n            marbleP.y += sin(p.z*153.0)*0.015;\n\n            marbleP.x *= 20.0;\n            marbleP.z *= 20.0;\n            marbleP.y *= 10.0;\n\n            float marbleAmtA = abs(sin(marbleP.x)+sin(marbleP.y)+sin(marbleP.z))/3.0;\n            marbleAmtA = pow(1.0-marbleAmtA,5.0);\n\n            marbleP = p;\n\n            marbleP.x += sin(p.y*21.0)*0.12;\n            marbleP.z += sin(p.y*23.0)*0.1;\n            marbleP.y += sin(p.x*22.0)*0.13;\n            marbleP.y += sin(p.z*24.0)*0.14;\n\n            marbleP.y += sin(p.x*1.2)*0.5;\n            marbleP.y += sin(p.z*1.4)*0.6;\n\n            marbleP.x += sin(p.y*150.0)*0.011;\n            marbleP.z += sin(p.y*162.0)*0.013;\n            marbleP.y += sin(p.x*145.0)*0.012;\n            marbleP.y += sin(p.z*153.0)*0.015;\n\n            marbleP.x *= 22.0;\n            marbleP.z *= 23.0;\n            marbleP.y *= 11.0;\n\n            float marbleAmtB = abs(sin(marbleP.x)+sin(marbleP.y)+sin(marbleP.z))/3.0;\n            marbleAmtB = pow(1.0-marbleAmtB,9.0);\n            marbleAmtB = 1.0-(1.0-marbleAmtB*0.3);\n\n            float marbleAmt = marbleAmtA + marbleAmtB;\n            marbleAmt = clamp(marbleAmt,0.0,1.0);\n\n            surfaceColor = mix(vec3(0.0,0.8,0.5),vec3(0.70),marbleAmt);\n            specA = mix(1.0,0.8,marbleAmt);\n            specP = mix(16.0,28.0,marbleAmt);\n\n        }\n        if (surfaceMaterial == 2) {\n\n            vec3 marbleP = p;\n            vec3 intensityP = p;\n\n            float tileSize = 1.0;\n            if ( ceil(mod(p.x,tileSize*2.0)/tileSize) == ceil(mod(p.z,tileSize*2.0)/tileSize) ) {\n                surfaceColor = vec3(0.45,0.0,0.0);\n                marbleP.x *= -1.0;\n                intensityP.x *= -1.0;\n                marbleP.z += 1.0;\n                intensityP.z += 1.0;\n            } else {\n                surfaceColor = vec3(0.75,0.75,0.6);\n            }\n            specA = 1.0;\n            specP = 16.0;\n\n\n\n\n            marbleP.x += marbleP.z*0.5;\n            marbleP.z += marbleP.x*0.4;\n\n            marbleP.x += sin(marbleP.x*  3.8)*0.125;\n            marbleP.z += sin(marbleP.z*  3.6)*0.135;\n\n            marbleP.x += sin(marbleP.z* 20.0)*0.025;\n            marbleP.z += sin(marbleP.x* 25.0)*0.025;\n\n            marbleP.x += sin(marbleP.z* 40.0)*0.025;\n            marbleP.z += sin(marbleP.x* 45.0)*0.025;\n\n            marbleP.x += sin(marbleP.z*150.0)*0.01;\n            marbleP.z += sin(marbleP.x*160.0)*0.011;\n\n            marbleP *= 36.0;\n\n\n\n\n            intensityP.z -= 10000.0;\n\n            intensityP.x += intensityP.z*0.3;\n            intensityP.z += intensityP.x*0.1;\n\n            intensityP.x += sin(intensityP.x*1.2)*0.36;\n            intensityP.z += sin(intensityP.z*1.3)*0.21;\n\n            intensityP.x += sin(intensityP.z*2.2)*0.8;\n            intensityP.z += sin(intensityP.x*2.3)*0.9;\n\n            intensityP *= 6.0;\n\n\n            float intensityAmt = (sin(intensityP.x)*sin(intensityP.z))*0.5+0.5;\n            intensityAmt = 1.0-pow(1.0-intensityAmt,0.5);\n\n            float marbleAmt = (sin(marbleP.x)*sin(marbleP.z))*0.5+0.5;\n\n\n            float marbleGrainAmt = marbleAmt;\n            marbleGrainAmt = 1.0-((1.0-pow(marbleGrainAmt,1.5))*(1.0-intensityAmt)*1.125);\n            marbleGrainAmt = 1.0-pow(1.0-marbleGrainAmt,5.0);\n\n            surfaceColor *= marbleGrainAmt;\n            specA *= marbleGrainAmt;\n\n\n\n            float marbleGashAmt = marbleAmt;\n            marbleGashAmt *= 0.5 + 18.0*intensityAmt;\n            marbleGashAmt += pow(intensityAmt,2.5)*18.0;\n            marbleGashAmt = clamp(marbleGashAmt,0.0,1.0);\n\n            float marbleGoldAmt = pow(marbleGashAmt,1.0);\n            float marbleShadeAmt = pow(marbleGashAmt,16.0);\n\n            surfaceColor *= marbleShadeAmt;\n            specA *= marbleShadeAmt;\n\n            vec3 myNormalCheat = vec3(\n                sin( p.x*200.0 + sin(p.z*100.0)*0.5 + sin(p.z*17.0)*(5.0+sin(p.x*20.0)*4.0) )*0.000015,\n                0.0,\n                0.0\n            );\n\n            surfaceColor = mix(vec3(1.0,0.9,0.0),surfaceColor,marbleGoldAmt);\n            specP = mix(256.0,specP,marbleGoldAmt);\n            specA = mix(1.0,specA,marbleGoldAmt);\n            difP = mix(6.0,difP,marbleGoldAmt);\n            normalCheat = mix(myNormalCheat,normalCheat,marbleGoldAmt);\n\n        }\n        /***if (surfaceMaterial == 3){\n\n            float splinters =\n                pow(abs( ( sin(p.x*100.0)*0.5 + sin(p.y*100.0)*0.5 ) ), 0.1)\n                *\n                (sin(p.z*2.0+sin(p.x*10.0)*4.0+sin(p.x*27.0)*3.0)*0.5+0.5);\n\n            float waves = sin(\n                p.z*10.0 +\n                sin(p.z*3.0 + sin(p.x*11.0)*0.5 )*1.0 +\n                sin((p.z + sin(p.z*0.5)*5.5)*0.15 + sin(p.x*0.8)*2.0) * 14.0 +\n                pow(abs(sin((p.x*1.0 + sin(p.x*3.0)*0.5)*25.0)),0.5) * 0.5\n            );\n\n            float grain = splinters * 0.3 + waves * 0.7;\n            grain = pow(grain*0.5+0.5,0.25);\n\n            surfaceColor = mix(vec3(0.2,0.1,0.1),vec3(0.4,0.2,0.05),grain);\n            specP = mix(30.0,20.0,grain);\n            specA = grain;\n\n        }***/\n\n        vec3 n = vec3(d-room(p-e.xyy,dummyMaterial),\n                      d-room(p-e.yxy,dummyMaterial),\n                      d-room(p-e.yyx,dummyMaterial));\n        n += normalCheat;\n        vec3 N = normalize(n);\n\n        vec3 pointLightPos = vec3(0.0,2.0,-4.5-fwdDist);\n        vec3 L = normalize(pointLightPos-p);\n\n        float diffuse=max(dot(N,L),0.0);\n        vec3 H = normalize(L-curCameraRayUnit);\n        float specular = max(dot(H,N),0.0);\n        color = pow(diffuse,difP)*surfaceColor + pow(specular,specP)*specA;\n\n        float lightDist = (length(pointLightPos-p)) * 0.04;\n        lightDist = max(0.0,min(1.0,lightDist));\n        color *= pow(1.0-lightDist, 2.0);\n\n\t\t///const float fogBegin = 1.0;\n        ///const float fogEnd = 10.0;\n        const float fogDensity = .25;\n        \n        float fogCoord  = exp(-fogDensity*fogDensity * f * f);\n        ///float fogCoord = (fogEnd - f) / (fogEnd - fogBegin);\n        color = mix (vec3(1.0, 1.0, 1.0), color, fogCoord);\n        \n        \n    } else {\n\n        color = vec3(1.0);\n\n    }\n\n\n\n    fragColor = vec4(color,1.0);\n    \n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n\t\n    \n    float vertFov = 50.0;\n    float horizFov = 2.0*atan(tan((vertFov/180.0*PI)/2.0)*(iResolution.x/iResolution.y))*180.0/PI;\n    vec4 fovAngsMono = vec4(horizFov/2.0, horizFov/2.0, vertFov/2.0, vertFov/2.0);\n    \n\n\n    \n\n\n\n    vec2 fragFrac = fragCoord.xy/iResolution.xy;\n\n    vec2 eyeRes = iResolution.xy;\n    vec4 fovAngs = fovAngsMono;\n\n\n/*\n    vec3 cameraRight,cameraUp,cameraFwd;\n    quatToAxes(headOrientation,cameraRight,cameraUp,cameraFwd);\n\tcameraFwd *= -1.0;\n*/\n    float camLookY = sin(PI*0.5+iTime*-0.2)*0.5 - 0.25;\n    vec3 cameraRight = vec3(1.0,0.0,0.0);\n    vec3 cameraFwd = -vec3(0.0,sin(camLookY),cos(camLookY));\n    vec3 cameraUp = cross(cameraRight,cameraFwd);\n\n   \n\n    // position\n\n    vec3 cameraPos = vec3(0.0);\n\n\n    float fovL = -fovAngs.x/180.0*PI;\n    float fovR =  fovAngs.y/180.0*PI;\n    float fovU = -fovAngs.z/180.0*PI;\n    float fovD =  fovAngs.w/180.0*PI;\n\n    float fovMiddleX = (fovR + fovL) * 0.5;\n    float fovMiddleY = (fovU + fovD) * 0.5;\n    float fovHalfX = (fovR - fovL) * 0.5;\n    float fovHalfY = (fovD - fovU) * 0.5;\n\n\n\n    float scrWorldHalfX = sin(fovHalfX)/sin(PI*0.5 - fovHalfX);\n    float scrWorldHalfY = sin(fovHalfY)/sin(PI*0.5 - fovHalfY);\n\n\n    // determine screen plane size from FOV values, then interpolate to find current pixel's world coord\n\n    vec2 vPos = fragFrac;//0 to 1\n    vPos.x -= (-fovL/(fovHalfX*2.0));\n    vPos.y -= (-fovU/(fovHalfY*2.0));\n\n    vec3 screenPlaneCenter = cameraPos+cameraFwd;\n    vec3 scrCoord = screenPlaneCenter + vPos.x*cameraRight*scrWorldHalfX*2.0 + vPos.y*cameraUp*scrWorldHalfY*2.0;\n    vec3 curCameraRayUnit = normalize(scrCoord-cameraPos);\n\n\n    mainVR(fragColor,fragCoord,cameraPos,curCameraRayUnit);\n\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XtGXz1.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[59, 59, 109, 109, 147], [148, 148, 211, 211, 322], [323, 323, 391, 391, 543], [544, 544, 583, 583, 608], [609, 609, 648, 648, 673], [674, 674, 713, 713, 738], [740, 740, 799, 799, 857], [859, 859, 903, 903, 988], [990, 990, 1073, 1073, 1160], [1161, 1161, 1210, 1210, 1243], [1244, 1244, 1307, 1326, 1375], [1376, 1376, 1444, 1444, 1497], [1528, 1528, 1576, 1576, 1881], [1883, 1883, 1924, 1924, 1979], [1981, 1981, 2018, 2018, 3336], [3344, 3344, 3438, 3438, 10843], [10847, 10847, 10903, 10903, 12611]], "test": "valid"}
{"id": "XttSDl", "name": "BouncyBall", "author": "andrewc", "description": "spotlight...", "tags": ["light"], "likes": 2, "viewed": 99, "published": "Public", "date": "1482186220", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\t\n    fragColor = texture(iChannel0, uv) * 0.7; // darken\n  \n    // Moving point\n    vec2 light = vec2(0.5 * iTime, 0.5 * iTime);\n    light.x = abs(sin(light.x));\n    light.y = abs(sin(light.y));\n    \n    // Scale to a smaller size\n    float dist = length(uv - light);\n    float maxDist = 0.15;\n    dist /= maxDist;\n    \n    // Invert\n\tdist = 1.0 - dist;\n       \n    float lightScale = 0.9;\n    fragColor.xyz += dist * lightScale; \n}", "image_inputs": [{"id": "4sfGRn", "previewfilepath": "/media/ap/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XttSDl.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 533]], "test": "error"}
{"id": "XttSR2", "name": "#Devember 2016 - day 00", "author": "theGiallo", "description": "Moving the first steps into Shadertoy.", "tags": ["learning", "devember"], "likes": 0, "viewed": 134, "published": "Public", "date": "1480619940", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define SQRT2 1.4142135623730950488016887242096980785696\n#define PI    3.1415926535897932384626433832795\n#define HPI   1.57079632679489661923132169\n#define QPI   0.785398163397448309615660845819875721\n#define TAU   6.283185307179586476925286766559\n\nfloat\nmanhattan( vec2 p )\n{\n    p = abs ( p );\n    float ret = p.x + p.y;\n    return ret;\n}\nfloat\nmanhattan( vec2 p0, vec2 p1 )\n{\n    float ret;\n    \n    vec2 d = abs ( p1 - p0 );\n    ret = d.x + d.y;\n    \n    return ret;\n}\nvec4\ncircle( vec4 color, vec2 pos, float radius, float border_width, vec2 point )\n{\n    vec4 ret = vec4(0);\n    color.rgb *= color.a;\n    \n    float dist = length( point - pos );\n    ret = color * (1.0 - smoothstep( radius, radius + border_width, dist ) );\n    \n    return ret;\n}\nvec4\nsquare( vec4 color, vec2 pos, float side, float border_width, float rot_rad, vec2 point )\n{\n    vec4 ret = vec4(0);\n    color.rgb *= color.a;\n    \n    float max_d = SQRT2 * side;\n    vec2 rd = point - pos;\n    float tot_rad = QPI + rot_rad;\n    vec2 rd_rot;\n    rd_rot.x = rd.x * cos( tot_rad ) + rd.y * sin( tot_rad );\n    rd_rot.y = rd.x * sin( tot_rad ) - rd.y * cos( tot_rad );\n    float dist = manhattan( rd_rot );\n    ret = color * (1.0 - smoothstep( max_d, max_d + border_width, dist ) );\n    \n    return ret;\n}\n\n// NOTE(theGiallo): pre-multiplied alpha\nvoid\nblend_pma( inout vec4 dst, in vec4 src )\n{\n    dst.rgb = src.rgb + dst.rgb * ( 1.0 - src.a );\n    dst.a = min( 1.0, dst.a + src.a );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 q = fragCoord.xy / iResolution.xy;\n\tvec2 p = ( 2.0 * fragCoord.xy - iResolution.xy ) / min( iResolution.y, iResolution.x );\n    vec4 col = vec4(0);\n    \n    vec4 c;\n    c = square( vec4(0.1,0.4,0.7,1.0), vec2(-0.75,0.5), 0.15, 0.01, iTime * 0.1, p );\n    blend_pma( col, c );\n    \n    c = square( vec4(0.1,0.4,0.7,1.0), vec2(0.75 + 0.3 * SQRT2 * sin( iTime ),0.5), 0.15, 0.01, 0.0, p );\n    blend_pma( col, c );\n    \n    c = circle( vec4(0.1,0.6,0.0,0.5 + 0.5 * sin( 3.0 * iTime )), vec2(0.75,0.5), 0.15, 0.1, p );\n    blend_pma( col, c );\n    \n    \n    vec2 distorted_p = p;\n    float sx = 0.5 + 0.5 * sin( 4.0 * TAU * p.x );\n    distorted_p.x *= 1.0 + sx * 0.2;\n    float sy = 0.5 + 0.5 * sin( 4.0 * TAU * p.y );\n    distorted_p.y *= 1.0 + sy * 0.2;\n    float s = length( vec2(sx, sy) ) / SQRT2;\n    c = square( vec4(0.1,0.4,0.7, s), vec2(0.0 + 0.5 * sin( iTime * 0.5 * QPI ),-0.2), 0.4, 0.01, iTime * QPI, distorted_p );\n    blend_pma( col, c );\n    \n    fragColor = vec4(col.rgb,1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XttSR2.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[249, 249, 276, 276, 340], [341, 341, 378, 378, 472], [473, 473, 556, 556, 752], [753, 753, 849, 849, 1276], [1278, 1319, 1366, 1366, 1458], [1460, 1460, 1517, 1517, 2512]], "test": "valid"}
{"id": "XttSz2", "name": "Analytic Normals 3D", "author": "iq", "description": "Left, analytical normals of Value Noise, without taking little differences. See [url]http://iquilezles.org/www/articles/morenoise/morenoise.htm[/url] for more info. See [url]https://www.shadertoy.com/view/MdsSRs[/url] for the 2D case.", "tags": ["3d", "noise", "normals", "analytical", "numerical"], "likes": 165, "viewed": 14684, "published": "Public API", "date": "1480664907", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// The MIT License\n// Copyright  2016 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n\n// Computing normals analytically has the benefit of being faster if you need them often, \n// while numerical normals are easier to filter for antialiasing. See line 200.\n//\n// More info: http://iquilezles.org/www/articles/morenoise/morenoise.htm\n//\n// See this too: https://www.shadertoy.com/view/XsXfRH\n//\n// Proper noise code isolated here: https://www.shadertoy.com/view/XsXfRH\n//\n//#define SHOW_NUMERICAL_NORMALS  // for comparison purposes\n\nfloat hash( float n ) { return fract(sin(n)*753.5453123); }\n\n\n//---------------------------------------------------------------\n// value noise, and its analytical derivatives\n//---------------------------------------------------------------\n\nvec4 noised( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 w = fract(x);\n\tvec3 u = w*w*(3.0-2.0*w);\n    vec3 du = 6.0*w*(1.0-w);\n    \n    float n = p.x + p.y*157.0 + 113.0*p.z;\n    \n    float a = hash(n+  0.0);\n    float b = hash(n+  1.0);\n    float c = hash(n+157.0);\n    float d = hash(n+158.0);\n    float e = hash(n+113.0);\n\tfloat f = hash(n+114.0);\n    float g = hash(n+270.0);\n    float h = hash(n+271.0);\n\t\n    float k0 =   a;\n    float k1 =   b - a;\n    float k2 =   c - a;\n    float k3 =   e - a;\n    float k4 =   a - b - c + d;\n    float k5 =   a - c - e + g;\n    float k6 =   a - b - e + f;\n    float k7 = - a + b + c - d + e - f - g + h;\n\n    return vec4( k0 + k1*u.x + k2*u.y + k3*u.z + k4*u.x*u.y + k5*u.y*u.z + k6*u.z*u.x + k7*u.x*u.y*u.z, \n                 du * (vec3(k1,k2,k3) + u.yzx*vec3(k4,k5,k6) + u.zxy*vec3(k6,k4,k5) + k7*u.yzx*u.zxy ));\n}\n\n//---------------------------------------------------------------\n\nvec4 sdBox( vec3 p, vec3 b ) // distance and normal\n{\n    vec3 d = abs(p) - b;\n    float x = min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n    vec3  n = step(d.yzx,d.xyz)*step(d.zxy,d.xyz)*sign(p);\n    return vec4( x, n );\n}\n\nvec4 fbmd( in vec3 x )\n{\n    const float scale  = 1.5;\n\n    float a = 0.0;\n    float b = 0.5;\n\tfloat f = 1.0;\n    vec3  d = vec3(0.0);\n    for( int i=0; i<8; i++ )\n    {\n        vec4 n = noised(f*x*scale);\n        a += b*n.x;           // accumulate values\t\t\n        d += b*n.yzw*f*scale; // accumulate derivatives\n        b *= 0.5;             // amplitude decrease\n        f *= 1.8;             // frequency increase\n    }\n\n\treturn vec4( a, d );\n}\n\nvec4 map( in vec3 p )\n{\n\tvec4 d1 = fbmd( p );\n    d1.x -= 0.37;\n\td1.x *= 0.7;\n    d1.yzw = normalize(d1.yzw);\n\n    // clip to box\n    vec4 d2 = sdBox( p, vec3(1.5) );\n    return (d1.x>d2.x) ? d1 : d2;\n}\n\n// ray-box intersection in box space\nvec2 iBox( in vec3 ro, in vec3 rd, in vec3 rad ) \n{\n    vec3 m = 1.0/rd;\n    vec3 n = m*ro;\n    vec3 k = abs(m)*rad;\n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n\tfloat tN = max( max( t1.x, t1.y ), t1.z );\n\tfloat tF = min( min( t2.x, t2.y ), t2.z );\n\tif( tN > tF || tF < 0.0) return vec2(-1.0);\n\treturn vec2( tN, tF );\n}\n\n// raymarch\nvec4 interesect( in vec3 ro, in vec3 rd )\n{\n\tvec4 res = vec4(-1.0);\n\n    // bounding volume    \n    vec2 dis = iBox( ro, rd, vec3(1.5) ) ;\n    if( dis.y<0.0 ) return res;\n\n    // raymarch\n    float tmax = dis.y;\n    float t = dis.x;\n\tfor( int i=0; i<128; i++ )\n\t{\n        vec3 pos = ro + t*rd;\n\t\tvec4 hnor = map( pos );\n        res = vec4(t,hnor.yzw);\n        \n\t\tif( hnor.x<0.001 ) break;\n\t\tt += hnor.x;\n        if( t>tmax ) break;\n\t}\n\n\tif( t>tmax ) res = vec4(-1.0);\n\treturn res;\n}\n\n// compute normal numerically\n#ifdef SHOW_NUMERICAL_NORMALS\nvec3 calcNormal( in vec3 pos )\n{\n\tvec2 eps = vec2( 0.0001, 0.0 );\n\tvec3 nor = vec3( map(pos+eps.xyy).x - map(pos-eps.xyy).x,\n\t                 map(pos+eps.yxy).x - map(pos-eps.yxy).x,\n\t                 map(pos+eps.yyx).x - map(pos-eps.yyx).x );\n\treturn normalize(nor);\n}\n#endif\n\n// fibonazzi points in s aphsre, more info:\n// http://lgdv.cs.fau.de/uploads/publications/spherical_fibonacci_mapping_opt.pdf\nvec3 forwardSF( float i, float n) \n{\n    const float PI  = 3.141592653589793238;\n    const float PHI = 1.618033988749894848;\n    float phi = 2.0*PI*fract(i/PHI);\n    float zi = 1.0 - (2.0*i+1.0)/n;\n    float sinTheta = sqrt( 1.0 - zi*zi);\n    return vec3( cos(phi)*sinTheta, sin(phi)*sinTheta, zi);\n}\n\nfloat calcAO( in vec3 pos, in vec3 nor )\n{\n\tfloat ao = 0.0;\n    for( int i=0; i<32; i++ )\n    {\n        vec3 ap = forwardSF( float(i), 32.0 );\n        float h = hash(float(i));\n\t\tap *= sign( dot(ap,nor) ) * h*0.25;\n        ao += clamp( map( pos + nor*0.001 + ap ).x*3.0, 0.0, 1.0 );\n    }\n\tao /= 32.0;\n\t\n    return clamp( ao*5.0, 0.0, 1.0 );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = (2.0*fragCoord-iResolution.xy) / iResolution.y;\n   \n\t// camera anim\n    float an = 0.1*iTime;\n\tvec3 ro = 3.0*vec3( cos(an), 0.8, sin(an) );\n\tvec3 ta = vec3( 0.0 );\n\t\n    // camera matrix\t\n\tvec3  cw = normalize( ta-ro );\n\tvec3  cu = normalize( cross(cw,vec3(0.0,1.0,0.0)) );\n\tvec3  cv = normalize( cross(cu,cw) );\n\tvec3  rd = normalize( p.x*cu + p.y*cv + 1.7*cw );\n\n\t// render\n\tvec3 col = vec3(0.0);\n    vec4 tnor = interesect( ro, rd );\n\tfloat t = tnor.x;\n\n    if( t>0.0 )\n\t{\n\t\tvec3 pos = ro + t*rd;\n        #ifndef SHOW_NUMERICAL_NORMALS\n        vec3 nor = tnor.yzw; // no need to call calcNormal( pos );\n        #else\n        vec3 nor = calcNormal( pos );\n        #endif\n        float occ = calcAO( pos, nor );\n        float fre = clamp( 1.0+dot(rd,nor), 0.0, 1.0 );\n        float fro = clamp( dot(nor,-rd), 0.0, 1.0 );\n        col = mix( vec3(0.05,0.2,0.3), vec3(1.0,0.95,0.85), 0.5+0.5*nor.y );\n        //col = 0.5+0.5*nor;\n        col += 10.0*pow(fro,12.0)*(0.04+0.96*pow(fre,5.0));\n        col *= pow(vec3(occ),vec3(1.0,1.1,1.1) );\n\t}\n\n    col = sqrt(col);\n\t\n    fragColor=vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XttSz2.jpg", "access": "shaders20k", "license": "mit", "functions": [[1526, 1526, 1549, 1549, 1585], [1768, 1768, 1794, 1794, 2629], [2698, 2698, 2751, 2751, 2929], [2931, 2931, 2955, 2955, 3380], [3382, 3382, 3405, 3405, 3584], [3586, 3623, 3674, 3674, 3942], [3944, 3956, 3999, 3999, 4438], [4779, 4905, 4941, 4941, 5205], [5207, 5207, 5249, 5249, 5550], [5552, 5552, 5609, 5609, 6718]], "test": "valid"}
{"id": "XttXRs", "name": "Diablo Angel Wing", "author": "twitchingace", "description": "An attempt at mimicking the wispy wings Tyreal and other angels display in Diablo 3.\n\nThanks to https://simonschreibt.de/gat/diablo-3-wings-of-angels/ for providing the rough idea of the technique.", "tags": ["2d", "sine", "trig", "wing", "diablo", "angel"], "likes": 41, "viewed": 931, "published": "Public", "date": "1481225799", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec2 rotate(in vec2 toRotate, in float rad){\n    return vec2(toRotate.x * cos(rad) - toRotate.y * sin(rad),\n                toRotate.y * cos(rad) + toRotate.x * sin(rad));\n}\n\nfloat drawSin(vec2 uv){    \n\treturn pow(1.1 - sqrt(distance(uv, vec2(uv.x,\n                                           .3 * sin(uv.x*10. - iTime)*uv.x + .25)\n                                 )), \n               6.);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.x;\n    vec2 strand1uv = uv;\n    vec2 strand2uv = rotate(uv, .5) + vec2(0.12, 0.05);\n    vec2 strand3uv = rotate(uv, -.5) * .8 + vec2(0.0, 0.01);\n    vec2 strand4uv = rotate(uv, .3) * 0.5 + vec2(0.0, 0.1);\n    vec2 strand5uv = rotate(uv, -.2) * 1.1 - vec2(0.0, 0.1);\n    \n    fragColor = vec4(0.,0.,0.,1.);\n    vec3 blue = vec3(.5, .85, .99);\n    \n    float val = drawSin(strand1uv);\n    fragColor += .65 * vec4(vec3(val), 1.);\n    \n    val = drawSin(strand2uv);\n    fragColor += .65 * vec4(vec3(val), 1.);\n    \n    val = drawSin(strand3uv);\n    fragColor += .65 * vec4(vec3(val), 1.);\n    \n    val = drawSin(strand4uv);\n    fragColor += .65 * vec4(vec3(val), 1.);\n    \n    val = drawSin(strand5uv);\n    fragColor += .65 * vec4(vec3(val), 1.);\n\n    fragColor *= 1. - exp(uv.x) / exp(1.);\n    fragColor .xyz *= blue;\n    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XttXRs.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 44, 44, 173], [175, 175, 198, 198, 391], [393, 393, 450, 450, 1310]], "test": "valid"}
{"id": "XttXRX", "name": "Peanut Butter Jelly Time", "author": "balkhan", "description": "My first skeleton animated body.\nWanted to add an fbm to the color of the banana to make it more like a real one but I got lazy :)", "tags": ["raymarch", "time", "jelly", "banana", "peanut", "butter"], "likes": 13, "viewed": 315, "published": "Public", "date": "1481039382", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define I_MAX\t100\n#define E\t\t0.002\n\n/*\n* License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n*/\n\nvoid\tinit_vars();\nfloat\tletters(vec3 p);\nvec3\tgive_color(float inter);\nfloat\tde(vec3 pos);\nfloat\tde(vec3 pos, vec4 rad);\nfloat\tsdTorus( vec3 p, vec2 t );\nvec4\tmarch(vec3 pos, vec3 dir);\nvec3\tcamera(vec2 uv);\nvec3\tcalcNormal(in vec3 pos, float e, vec3 dir);\nfloat\tsmin(float a, float b, float k);\nvec2\trot(vec2 p, vec2 ang);\nvec2\tuv;\nvec4\tpeanut_butter_jelly_time(vec3 pos, vec3 dir);\n\n/*\n* Distances\n*/\n\n\tfloat\trigt_eye;\n\tfloat\tleft_eye;\n    float\trigt_pup;\n    float\tleft_pup;\n    float\triga_leg;\n    float\tlefa_leg;\n    float\trigb_leg;\n    float\tlefb_leg;\n\tfloat\trigt_arm;\n    float\trigt_brm;\n\tfloat\tleft_arm;\n    float\tleft_brm;\n\tfloat\tleft_fot;\n\tfloat\trigt_fot;\n\tfloat\tleft_had;\n\tfloat\trigt_had;\n\tfloat\tup_cap;\n\tfloat\tbt_cap;\n\tfloat\tmouth;\n\n/*\n* Skeleton\n*/\n\n\tvec3\ta_arm_rigt;\n\tvec3\ta_arm_left;\n\tvec3\tb_arm_rigt;\n\tvec3\tb_arm_left;\n\n\tvec3\ta_leg_rigt;\n\tvec3\ta_leg_left;\n\tvec3\tb_leg_left;\n\tvec3\tb_leg_rigt;\n\n/*\n* Distance functions taken from iq\n*/\n\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r )\n{\n\tvec3 pa = p-a, ba = b-a;\n\tfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n\treturn length( pa - ba*h ) - r;\n}\n\nfloat sdTorus( vec3 p, vec2 t )\n{\n\tvec2 q = vec2(length(p.xy)-t.x,p.z);\n\n    return length(q)-t.y;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord )\n{\n\tinit_vars(); // init skeleton and distances\n    uv  = fragCoord.xy / iResolution.xy;\n    uv.x *= iResolution.x / iResolution.y;\n\tvec3\tdir = camera(uv);\n    vec4\tcol = vec4(0.0);\n    vec3\tpos = vec3(.0, .0, -10.0);\n\n    vec4\tinter = (march(pos, dir));\n\n    vec3\tv = pos+inter.w*dir;\n\tvec3\tobj_color;\n    if (inter.w <= 17.)\n\t{\n        obj_color = give_color(inter.y);\n        /*\n\t\t* taken from here : https://www.shadertoy.com/view/XsB3Rm\n\t\t*/\n        vec3\tn = calcNormal(pos, E, dir);\n        vec3\tev = normalize(v - pos);\n\t\tvec3\tref_ev = reflect(ev, n);\n        vec3\tlight_pos   = vec3(-20.0, 10.0, -25.0);\n\n        vec3\tvl = normalize(light_pos - v);\n\t\tfloat\tdiffuse  = max(0.0, dot(vl, n));\n\t\tfloat\tspecular = pow(max(0.0, dot(vl, ref_ev)), 42.);\n        col.xyz = obj_color * (diffuse + specular);\n    }\n    // letters\n    else\n    {\n        col = peanut_butter_jelly_time(pos, dir);\n    }\n   \tfragColor = col;\n}\n\nfloat\tscene(vec3 p)\n{\n    float\tt = sin(iTime);\n    float\tct = cos(1.3+ .75*t);\n    float\tst = sin(1.3+ .75*t);\n    float\tmind = 1e5;\n\n    mat2\trotmat = mat2(ct, st, -st, ct);\n    p.xz *= rotmat;\n    p.x += .5*sin(15.*iTime);\n    p.y += .75*sin(.7+20.*iTime);\n\n    rigt_eye = length(p+vec3(-1.5, -0.4, .4))-.3;\n    left_eye = length(p+vec3(-1.5, -0.4, -.4))-.3;\n    rigt_pup = length(p+vec3(-1.25,-0.4,0.4))-.1;\n    left_pup = length(p+vec3(-1.25,-0.4,-0.4))-.1;\n\n    mouth = sdTorus(vec3((p.y+.3),p.z-.05,(p.x-1.2)-cos(0.4-p.y))+vec3(0.), vec2(.5,.35));\n\n    riga_leg = sdCapsule(vec3(p.x-1.,p.y+1.,p.z+1.), a_leg_rigt, vec3(.8,-.25,.6) , .15);\n    lefa_leg = sdCapsule(vec3(p.x-1.,p.y+1.,p.z-1.), a_leg_left, vec3(.8,-.25,-.6) , .15);\n    rigb_leg = sdCapsule(vec3(p.x-1.,p.y+1.,p.z+1.), a_leg_rigt, b_leg_rigt , .15);\n    lefb_leg = sdCapsule(vec3(p.x-1.,p.y+1.,p.z-1.), a_leg_left, b_leg_left , .15);\n\n    rigt_arm = sdCapsule(vec3(p.x-1.,p.y+1.,p.z+1.), a_arm_rigt, vec3(1.5,.8,.46) , .15);\n    rigt_brm = sdCapsule(vec3(p.x-1.,p.y+1.,p.z+1.), a_arm_rigt, b_arm_rigt , .15);\n    left_arm = sdCapsule(vec3(p.x-1.,p.y+1.,p.z-1.), a_arm_left, vec3(1.5,.8,-.46) , .15);\n    left_brm = sdCapsule(vec3(p.x-1.,p.y+1.,p.z-1.), a_arm_left, b_arm_left , .15);\n\n\tleft_had = length(vec3(p.x-1.,p.y+1.,p.z-1.)-b_arm_left) - 0.4;\n\trigt_had = length(vec3(p.x-1.,p.y+1.,p.z+1.)-b_arm_rigt) - 0.4;\n    left_fot = length(vec3(p.x-1.,p.y*1.5+2.5,p.z-1.)-b_leg_left) - 0.7;\n\trigt_fot = length(vec3(p.x-1.,p.y*1.5+2.5,p.z+1.)-b_leg_rigt) - 0.7;\n\n    up_cap = sdCapsule(vec3(p.y-2.4, p.z, p.x-.6), vec3(-.3, -.0, .33), vec3(.1, .0, -.31), .15);\n    bt_cap = sdCapsule(vec3(p.y+2.4, p.z, p.x-.6), vec3(.3, -.0, .33), vec3(.1, .0, .0), .15);\n\n    // 3 lanes above are the banana corpse, comment the if to reveal the cheat\n    mind = sdTorus(p, vec2(2.4, cos(-(p.y)/1.50)));\n    if (p.x < -.45)\n        mind = 2.;\n    // assembling shapes together\n    mind = min(mind, rigt_eye);\n    mind = min(mind, left_eye);\n    mind = min(mind, rigt_pup);\n    mind = min(mind, left_pup);\n\n    mind = min(mind, riga_leg);\n    mind = min(mind, lefa_leg);\n\tmind = min(mind, rigb_leg);\n\tmind = min(mind, lefb_leg);\n\n    mind = min(mind, rigt_arm);\n    mind = min(mind, rigt_brm);\n    mind = min(mind, left_arm);\n    mind = min(mind, left_brm);\n    mind = min(mind, left_fot);\n\tmind = min(mind, rigt_fot);\n\tmind = min(mind, left_had);\n    mind = min(mind, rigt_had);\n    mind = min(mind, up_cap);\n    mind = min(mind, bt_cap);\n\n\t//carving comes last\n    mind = max(mind, -mouth);\n\n    return(mind);\n}\n\nvec4\tmarch(vec3 pos, vec3 dir)\n{\n    vec2\tdist = vec2(0.0);\n    vec3\tp = vec3(0.0);\n    vec4\tstep = vec4(0.0);\n\n    for (int i = -1; i < I_MAX; ++i)\n    {\n    \tp = pos + dir * dist.y;\n        dist.x = scene(p);\n        dist.y += dist.x;\n        if (dist.x < E || dist.y > 20.)\n           break;\n        step.x++;\n    }\n    step.y = dist.x;\n    step.w = dist.y;\n    return (step);\n}\n\nvec3\tgive_color(float inter)\n{\n\tvec3\tret = vec3(1.,1.,0.3);\n    \n\t// magic\n    if (mouth / inter < E)\n        ret = vec3(1.,0.,0.);\n  \tif (rigt_eye < 2.*E || left_eye < 2.*E)\n        ret = vec3(1.,1.,1.);\n    if (rigt_pup < 2.*E || left_pup < 2.*E)\n        ret = vec3(0.,0.,0.);\n\tif (left_arm < 2.*E || left_brm < 2.*E || rigt_arm < 2.*E || rigt_brm < 2.*E \n        || lefb_leg < 2.*E || rigb_leg < 2.*E || lefa_leg < 2.*E || riga_leg < 2.*E)\n        ret = vec3(0.2,0.2,0.2);\n\tif (left_fot < 2.*E || rigt_fot < 2.*E || left_had < 2.*E || rigt_had < 2.*E)\n        ret = vec3(1.,1.,1.);\n    \n    return (ret);\n}\n\nvec4\tpeanut_butter_jelly_time(vec3 pos, vec3 dir) // march letters\n{\n\tvec4\tret = vec4(0.,0.,0.,1.);\n\n\tvec2\tdist = vec2(0.0);\n    vec3\tp = vec3(0.0);\n    vec4\tstep = vec4(0.0);\n\n    dir.x += 0.054*cos(2.8+iTime/5.); // makes text moove\n    for (int i = -1; i < 2; ++i) // low iteration give nice blurr\n    {\n    \tp = pos + dir * dist.y;\n        p.x -=.7;\n        dist.x = letters(p);\n        dist.y += dist.x;\n        if (dist.x < E || dist.y > 17.)\n           break;\n        step.x++;\n    }\n    step.y = dist.x;\n    step.w = dist.y;\n    \n    ret.x = 1.-step.y;\n    ret.y = 1.-step.y;\n    ret.z = 1. -step.w/float(15.);\n    return (ret);\n}\n\n//taken from an iq shader\nvec3 calcNormal( in vec3 pos, float e, vec3 dir)\n{\n    vec3 eps = vec3(e,0.0,0.0);\n\n\treturn normalize(vec3(\n           march(pos+eps.xyy, dir).w - march(pos-eps.xyy, dir).w,\n           march(pos+eps.yxy, dir).w - march(pos-eps.yxy, dir).w,\n           march(pos+eps.yyx, dir).w - march(pos-eps.yyx, dir).w ));\n}\n\nvec3\tcamera(vec2 uv)\n{\n    float   fov = 1.;\n\tvec3    forw  = vec3(0.0, 0.0, 1.0);\n\tvec3    right = vec3(1.0, 0.0, 0.0);\n\tvec3    up    = vec3(0.0, 1.0, 0.0);\n\n    return (normalize((uv.x-1.) * right + (uv.y-0.5) * up + fov * forw));\n}\n\nvoid\tinit_vars()\n{\n\trigt_eye = 1e5;\n\tleft_eye = 1e5;\n\tmouth = 1e5;\n\trigt_pup = 1e5;\n\tleft_pup = 1e5;\n\triga_leg = 1e5;\n\tlefa_leg = 1e5;\n\trigb_leg = 1e5;\n\tlefb_leg = 1e5;\n\trigt_arm = 1e5;\n\trigt_brm = 1e5;\n\tleft_arm = 1e5;\n\tleft_brm = 1e5;\n\tleft_fot = 1e5;\n\trigt_fot = 1e5;\n\tleft_had = 1e5;\n\trigt_had = 1e5;\n\tup_cap = 1e5;\n\tbt_cap = 1e5;\n\ta_arm_rigt = vec3(1.+.25*sin(2.*iTime), -.25+.125*sin(3.*iTime), -.9+.5*sin(2.*iTime));\n\ta_arm_left = vec3(1.+.25*sin(2.*iTime), -.25+.125*sin(3.*iTime), .9-.5*sin(2.*iTime));\n\tb_arm_rigt = vec3(.2,.3+.5+.5*sin(17.*iTime),-1.5+.5*sin(5.*iTime));\n\tb_arm_left = vec3(.2,.3+.5+.5*sin(17.*iTime),1.5-.5*sin(5.*iTime));\n\ta_leg_rigt = vec3(.5+0.25*sin(0.3+4.*iTime), -.70, -.1275+.25*cos(20.*iTime));\n\ta_leg_left = vec3(.5-0.25*sin(0.3+4.*iTime), -.70, .1275-.25*cos(20.*iTime));\n\tb_leg_left = vec3(.4,-2.25,.6+0.35*sin(0.3+40.*iTime));\n\tb_leg_rigt = vec3(.4,-2.25,-.6+0.35*sin(0.3+40.*iTime));\n}\n\n//http://iquilezles.org/www/articles/smin/smin.htm\nfloat smin( float a, float b, float k )\n{\n\tfloat res = exp( -k*a ) + exp( -k*b );\n    return -log( res )/k;\n}\n\n/*\n* trying to hide this at the end\n*/\n\nfloat\tletters(vec3 p) // this was painfull (and ugly)\n{\n\tfloat\tmind = 1e5;\n\n\tmind = min(mind, sdCapsule(p, vec3(-9.2, 4., 0.), vec3(-9.2, 3., 0.), .15));\n    mind = smin(mind, sdTorus(p-vec3(-8.8, 3.7, 0.), vec2(0.25, 0.15)), 40.3);         // p\n\n    mind = min(mind, sdCapsule(p, vec3(-8., 4., 0.), vec3(-8., 3., 0.), .1));\n    mind = min(mind, sdCapsule(p, vec3(-8., 3.5, 0.), vec3(-7.2, 3.5, 0.), .1));\n    mind = min(mind, sdCapsule(p, vec3(-8., 4., 0.), vec3(-7.2, 4., 0.), .1));\n    mind = min(mind, sdCapsule(p, vec3(-8., 3., 0.), vec3(-7.2, 3., 0.), .1)); // E\n    \n    mind = min(mind, sdCapsule(p, vec3(-6.4, 4., 0.), vec3(-6.8, 3., 0.), .1));\n    mind = min(mind, sdCapsule(p, vec3(-6.4, 4., 0.), vec3(-6., 3., 0.), .1));\n    mind = min(mind, sdCapsule(p, vec3(-6.3, 3.3, 0.), vec3(-6.5, 3.3, 0.), .1)); // A\n    \n    mind = min(mind, sdCapsule(p, vec3(-5.6, 4., 0.), vec3(-5.6, 3., 0.), .1));\n    mind = min(mind, sdCapsule(p, vec3(-5.6, 4., 0.), vec3(-5., 3., 0.), .1));\n\tmind = min(mind, sdCapsule(p, vec3(-5., 4., 0.), vec3(-5., 3., 0.), .1)); // N\n    \n    mind = min(mind, sdCapsule(p, vec3(-4.4, 4., 0.), vec3(-4.4, 3., 0.), .1));\n    mind = min(mind, sdCapsule(p, vec3(-4.4, 3., 0.), vec3(-3.8, 3., 0.), .1));\n    mind = min(mind, sdCapsule(p, vec3(-3.8, 4., 0.), vec3(-3.8, 3., 0.), .1)); // U\n    \n    mind = min(mind, sdCapsule(p, vec3(-3., 4., 0.), vec3(-3., 3., 0.), .1));\n    mind = min(mind, sdCapsule(p, vec3(-3.4, 4., 0.), vec3(-2.6, 4., 0.), .1)); // T\n\n    mind = min(mind, sdCapsule(p, vec3(-9.4, 1., 0.), vec3(-9.4, 2., 0.), .1));\n    mind = min(mind, sdTorus(p - vec3(-9.2, 1.8, 0.), vec2(0.25, 0.051)));\n    mind = min(mind, sdTorus(p - vec3(-9.2, 1.2, 0.), vec2(0.25, 0.061)));  // B\n    \n    mind = min(mind, sdCapsule(p, vec3(-8.4, 2., 0.), vec3(-8.4, 1., 0.), .05));\n    mind = min(mind, sdCapsule(p, vec3(-8.4, 1., 0.), vec3(-7.8, 1., 0.), .05));\n    mind = min(mind, sdCapsule(p, vec3(-7.8, 2., 0.), vec3(-7.8, 1., 0.), .05)); // U\n    \n    mind = min(mind, sdCapsule(p, vec3(-7., 2., 0.), vec3(-7., 1., 0.), .1));\n    mind = min(mind, sdCapsule(p, vec3(-7.4, 2., 0.), vec3(-6.6, 2., 0.), .1)); // T\n    \n    mind = min(mind, sdCapsule(p, vec3(-6., 2., 0.), vec3(-6., 1., 0.), .1));\n    mind = min(mind, sdCapsule(p, vec3(-6.4, 2., 0.), vec3(-5.6, 2., 0.), .1)); // T\n    \n    mind = min(mind, sdCapsule(p, vec3(-5., 2., 0.), vec3(-5., 1., 0.), .1));\n    mind = min(mind, sdCapsule(p, vec3(-5., 1.5, 0.), vec3(-4.2, 1.5, 0.), .1));\n    mind = min(mind, sdCapsule(p, vec3(-5., 2., 0.), vec3(-4.2, 2., 0.), .1));\n    mind = min(mind, sdCapsule(p, vec3(-5., 1., 0.), vec3(-4.2, 1., 0.), .1)); // E\n    \n    mind = min(mind, sdCapsule(p, vec3(-3.8, 1., 0.), vec3(-3.8, 2., 0.), .1));\n    mind = min(mind, sdTorus(p - vec3(-3.5, 1.8, 0.), vec2(0.3, 0.1)));\n    mind = min(mind, sdCapsule(p, vec3(-3.8, 1.6, 0.), vec3(-3.2, 1., 0.), .1)); // R\n\n    mind = min(mind, sdCapsule(p, vec3(-7.8, 0.5, 0.), vec3(-7.2, 0.5, 0.), .1));\n    mind = min(mind, sdCapsule(p, vec3(-7.5, 0.5, 0.), vec3(-7.5, -0.5, 0.), .1));\n    mind = min(mind, sdCapsule(p, vec3(-7.9, -0.5, 0.), vec3(-7.5, -0.5, 0.), .1));\n    mind = min(mind, sdCapsule(p, vec3(-7.9, -0.5, 0.), vec3(-7.9, -0.3, 0.), .1)); // J\n    \n    mind = min(mind, sdCapsule(p, vec3(-7., -0.5, 0.), vec3(-7., 0.5, 0.), .1));\n    mind = min(mind, sdCapsule(p, vec3(-7., 0.5, 0.), vec3(-6.2, 0.5, 0.), .1));\n    mind = min(mind, sdCapsule(p, vec3(-7., -0.5, 0.), vec3(-6.2, -0.5, 0.), .1));\n    mind = min(mind, sdCapsule(p, vec3(-7., 0., 0.), vec3(-6.2, 0., 0.), .1)); // E\n    \n\tmind = min(mind, sdCapsule(p, vec3(-5.8, 0.5, 0.), vec3(-5.8, -.5, 0.), .1));\n    mind = min(mind, sdCapsule(p, vec3(-5.8, -0.5, 0.), vec3(-5.4, -.5, 0.), .1)); // L\n\n  \tmind = min(mind, sdCapsule(p, vec3(-5., 0.5, 0.), vec3(-5., -.5, 0.), .1));\n    mind = min(mind, sdCapsule(p, vec3(-5., -0.5, 0.), vec3(-4.6, -.5, 0.), .1)); // L\n    \n    mind = min(mind, sdCapsule(p, vec3(-3.4, 0.5, 0.), vec3(-3.8, -.0, 0.), .1));\n    mind = min(mind, sdCapsule(p, vec3(-4.2, 0.5, 0.), vec3(-3.8, -.0, 0.), .1));\n    mind = min(mind, sdCapsule(p, vec3(-3.8, 0.0, 0.), vec3(-3.8, -.5, 0.), .1)); // Y\n    \n    mind = min(mind, sdCapsule(p, vec3(2., 3.5, 0.), vec3(2., 2.0, 0.), .1));\n    mind = min(mind, sdCapsule(p, vec3(1.3, 3.5, 0.), vec3(2.6, 3.5, 0.), .1)); // T\n    \n    mind = min(mind, sdCapsule(p, vec3(2.6, 2.5, 0.), vec3(2.6, 2.0, 0.), .1));\n    mind = min(mind, length(p-vec3(2.6, 2.9, 0.)) - .1); // I\n    \n\tmind = min(mind, sdCapsule(p, vec3(3., 3.1, 0.), vec3(3., 2.3, 0.), .1));\n\tmind = min(mind, sdCapsule(p, vec3(3., 3.1, 0.), vec3(3.4, 2.7, 0.), .1));\n    mind = min(mind, sdCapsule(p, vec3(3.8, 3.1, 0.), vec3(3.4, 2.7, 0.), .1));\n    mind = min(mind, sdCapsule(p, vec3(3.8, 3.1, 0.), vec3(3.8, 2.3, 0.), .1)); // M\n\n    mind = min(mind, sdCapsule(p, vec3(4.2, 2., 0.), vec3(4.2, 3.5, 0.), .1));\n    mind = min(mind, sdCapsule(p, vec3(4.2, 2., 0.), vec3(5.2, 2., 0.), .1));\n    mind = min(mind, sdCapsule(p, vec3(4.2, 2.7, 0.), vec3(5.2, 2.7, 0.), .1));\n    mind = min(mind, sdCapsule(p, vec3(4.2, 3.5, 0.), vec3(5.2, 3.5, 0.), .1)); // E\n\n    return (mind);\n}\n", "image_inputs": [{"id": "XsB3WD", "previewfilepath": "https://soundcloud.com/lori-15/peanut-butter-jelly-time", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "https://soundcloud.com/lori-15/peanut-butter-jelly-time", "ctype": "musicstream"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XttXRX.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1080, 1080, 1132, 1132, 1246], [1248, 1248, 1281, 1281, 1348], [1350, 1350, 1406, 1406, 2324], [2326, 2326, 2347, 2347, 4889], [4891, 4891, 4923, 4923, 5272], [5274, 5274, 5304, 5304, 5883], [5885, 5885, 5953, 5953, 6523], [6525, 6551, 6601, 6601, 6861], [6863, 6863, 6885, 6885, 7098], [7100, 7100, 7118, 7118, 8026], [8028, 8079, 8120, 8120, 8188], [8230, 8230, 8285, 8285, 13356]], "test": "error"}
{"id": "XttXWl", "name": "#Devember 2016 - day 18", "author": "theGiallo", "description": "Linear camera shows the prototypes.\nDefines at the beginning of the shader control the cameras and the debug visualization.", "tags": ["firstperson", "devember"], "likes": 1, "viewed": 120, "published": "Public", "date": "1482177510", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define SQRT2 1.4142135623730950488016887242096980785696\n#define PI    3.1415926535897932384626433832795\n#define HPI   1.57079632679489661923132169\n#define QPI   0.785398163397448309615660845819875721\n#define TAU   6.283185307179586476925286766559\n\n#define RENDER_REFLECTIONS 1\n#define DRAW_ITERATIONS_GRADIENT 0\n#define RAYM_MAX_ITERS 500\n\n#define CAMERA_LINEAR 0\n#define INVERTED_Y_AXIS 0\n\n#define MPt vec2\n#define distance x\n\nstruct\nMaterial\n{\n    vec3 color;\n    float diffuse_reflection;\n    float specular_reflection;\n    float ambient_reflection;\n    float shininess;\n};\nstruct\nMaterial_Point\n{\n    float distance;\n    Material material;\n};\n    \n#define MAT_PLASTIC  0.0\n#define MAT_ORANGE   1.0\n#define MAT_RED      2.0\n#define MAT_GREEN    3.0\n#define MAT_BLUE     4.0\n#define MAT_FLOOR_W  5.0\n#define MAT_FLOOR_B  6.0\n#define MAT_METAL_GRID 7.0\n#define MAT_COUNT    8\n\n////////////////////////////////////////////////////////////////////////////////\n\nfloat\nmanhattan( vec2 p )\n{\n    p = abs ( p );\n    float ret = p.x + p.y;\n    return ret;\n}\nfloat\nmanhattan( vec2 p0, vec2 p1 )\n{\n    float ret;\n    \n    vec2 d = abs ( p1 - p0 );\n    ret = d.x + d.y;\n    \n    return ret;\n}\nfloat\nmanhattan( in vec3 p )\n{\n    p = abs ( p );\n    float ret = p.x + p.y + p.z;\n    return ret;\n}\nfloat\nsum( in vec2 p )\n{\n    float ret = p.x + p.y;\n    return ret;\n}\nfloat\nsum( in vec3 p )\n{\n    float ret = p.x + p.y + p.z;\n    return ret;\n}\n\nfloat\npow2( in float v )\n{\n    v = v*v;\n    return v;\n}\nvec2\npow2( in vec2 v )\n{\n    v = v*v;\n    return v;\n}\nvec3\npow2( in vec3 v )\n{\n    v = v*v;\n    return v;\n}\nfloat\npow3( in float v )\n{\n    v = v*v*v;\n    return v;\n}\nvec2\npow3( in vec2 v )\n{\n    v = v*v*v;\n    return v;\n}\nvec3\npow3( in vec3 v )\n{\n    v = v*v*v;\n    return v;\n}\nfloat\npow4( in float v )\n{\n    v = v*v;\n    v = v*v;\n    return v;\n}\nvec2\npow4( in vec2 v )\n{\n    v = v*v;\n    v = v*v;\n    return v;\n}\nvec3\npow4( in vec3 v )\n{\n    v = v*v;\n    v = v*v;\n    return v;\n}\nfloat\npow6( in float v )\n{\n    float ret = v*v;\n    ret = ret*ret;\n    ret = ret * v;\n    return ret;\n}\nvec2\npow6( in vec2 v )\n{\n    vec2 ret = v*v;\n    ret = ret*ret;\n    ret = ret * v;\n    return ret;\n}\nvec3\npow6( in vec3 v )\n{\n    vec3 ret = v*v;\n    ret = ret*ret;\n    ret = ret * v;\n    return ret;\n}\nvec2\npow8( in vec2 v )\n{\n    v = v*v;\n    v = v*v;\n    v = v*v;\n    return v;\n}\nvec3\npow8( in vec3 v )\n{\n    v = v*v;\n    v = v*v;\n    v = v*v;\n    return v;\n}\nvec2\npowv( in vec2 v, in float exp )\n{\n    return pow( v, vec2(exp,exp) );\n}\nvec3\npowv( in vec3 v, in float exp )\n{\n    return pow( v, vec3(exp,exp,exp) );\n}\n\nvec4\ncircle( vec4 color, vec2 pos, float radius, float border_width, vec2 point )\n{\n    vec4 ret = vec4(0);\n    color.rgb *= color.a;\n    \n    float dist = length( point - pos );\n    ret = color * (1.0 - smoothstep( radius, radius + border_width, dist ) );\n    \n    return ret;\n}\nvec4\nsquare( vec4 color, vec2 pos, float side, float border_width, float rot_rad, vec2 point )\n{\n    vec4 ret = vec4(0);\n    color.rgb *= color.a;\n    \n    float max_d = SQRT2 * side;\n    vec2 rd = point - pos;\n    float tot_rad = QPI + rot_rad;\n    vec2 rd_rot;\n    rd_rot.x = rd.x * cos( tot_rad ) + rd.y * sin( tot_rad );\n    rd_rot.y = rd.x * sin( tot_rad ) - rd.y * cos( tot_rad );\n    float dist = manhattan( rd_rot );\n    ret = color * (1.0 - smoothstep( max_d, max_d + border_width, dist ) );\n    \n    return ret;\n}\nvec4\nsquare_tex( vec4 color, vec2 pos, float side, float border_width, float rot_rad, vec2 point, sampler2D tex )\n{\n    vec4 ret = vec4(0);\n    color.rgb *= color.a;\n    \n    float max_d = SQRT2 * side;\n    vec2 rd = point - pos;\n    float tot_rad = QPI + rot_rad;\n    vec2 rd_rot;\n    rd_rot.x = rd.x * cos( tot_rad ) + rd.y * sin( tot_rad );\n    rd_rot.y = rd.x * sin( tot_rad ) - rd.y * cos( tot_rad );\n    float dist = manhattan( rd_rot );\n    ret = color * (1.0 - smoothstep( max_d, max_d + border_width, dist ) );\n    ret *= texture( tex, rd_rot * (0.5 / side ) + 0.5 );\n    \n    return ret;\n}\n\n// NOTE(theGiallo): pre-multiplied alpha\nvoid\nblend_pma( inout vec4 dst, in vec4 src )\n{\n    dst.rgb = src.rgb + dst.rgb * ( 1.0 - src.a );\n    dst.a = min( 1.0, dst.a + src.a );\n}\n\nfloat\nmirror( float x )\n{\n    x *= 0.5;\n    return 1.0 - abs( 2.0 * ( x - floor(x) ) - 1.0 );\n}\n\nfloat\ndecimal( float x )\n{\n    return x - floor(x);\n}\n\n// NOTE(theGiallo): h in [0,1)\nvec3\nrgb_from_hsv( vec3 hsv )\n{\n\tvec3 ret;\n\tfloat c = hsv.g * hsv.b;\n\tfloat hh = hsv.r * 6.0;\n\n\tfloat x = c * ( 1.0 - abs( hh - 2.0 * floor( hh / 2.0 ) - 1.0 ) );\n\n\tif ( hh < 1.0 || hh >= 6.0 )\n\t{\n\t\tret.r = c;\n\t\tret.g = x;\n\t\tret.b = 0.0;\n\t} else\n\tif ( hh < 2.0 )\n\t{\n\t\tret.r = x;\n\t\tret.g = c;\n\t\tret.b = 0.0;\n\t} else\n\tif ( hh < 3.0 )\n\t{\n\t\tret.r = 0.0;\n\t\tret.g = c;\n\t\tret.b = x;\n\t} else\n\tif ( hh < 4.0 )\n\t{\n\t\tret.r = 0.0;\n\t\tret.g = x;\n\t\tret.b = c;\n\t} else\n\tif ( hh < 5.0 )\n\t{\n\t\tret.r = x;\n\t\tret.g = 0.0;\n\t\tret.b = c;\n\t} else\n\tif ( hh < 6.0 )\n\t{\n\t\tret.r = c;\n\t\tret.g = 0.0;\n\t\tret.b = x;\n\t}\n\n\tfloat m = hsv.b - c;\n\tret.r += m;\n\tret.g += m;\n\tret.b += m;\n\n\treturn ret;\n}\n\n#define ORANGE_RGB vec3(1.0,0.4,0.0)\n#define T_EPS 0.001\n\nfloat\nminv( in vec3 v )\n{\n    return min( v.x, min( v.y, v.z ) );\n}\n\nfloat\nmaxv( in vec3 v )\n{\n    return max( v.x, max( v.y, v.z ) );\n}\n\nfloat\nminv( in vec2 v )\n{\n    return min( v.x, v.y );\n}\n\nfloat\nmaxv( in vec2 v )\n{\n    return max( v.x, v.y );\n}\n\n\nfloat\nlength3( in vec2 v )\n{\n    v = pow3(v);\n    return pow(sum(v),1.0/3.0);\n}\nfloat\nlength3( in vec3 v )\n{\n    v = pow3(v);\n    return pow(sum(v),1.0/3.0);\n}\n\nfloat\nlength4( in vec2 v )\n{\n    v = pow4(v);\n    return pow(sum(v),1.0/4.0);\n}\nfloat\nlength4( in vec3 v )\n{\n    v = pow4(v);\n    return pow(sum(v),1.0/4.0);\n}\nfloat\nlength6( in vec2 v )\n{\n    v = pow6(v);\n    return pow(sum(v),1.0/6.0);\n}\nfloat\nlength6( in vec3 v )\n{\n    v = pow6(v);\n    return pow(sum(v),1.0/6.0);\n}\nfloat\nlength8( in vec2 v )\n{\n    v = pow8(v);\n    return pow(sum(v),1.0/8.0);\n}\nfloat\nlength8( in vec3 v )\n{\n    v = pow8(v);\n    return pow(sum(v),1.0/8.0);\n}\n\n\n\nvec3\nat_pos( in vec3 pos, in vec3 p )\n{\n    return p-pos;\n}\n\nmat4\ntr( mat4 m )\n{\n    return mat4(\n       vec4(m[0][0],m[1][0],m[2][0],m[3][0]),\n       vec4(m[0][1],m[1][1],m[2][1],m[3][1]),\n       vec4(m[0][2],m[1][2],m[2][2],m[3][2]),\n       vec4(m[0][3],m[1][3],m[2][3],m[3][3])\n    );\n}\n\nvec3\nrotate( in vec3 r, in vec3 p )\n{\n\tmat4 Rx = mat4(\n\t   vec4( 1.0, 0.0,      0.0,       0.0 ),\n\t   vec4( 0.0, cos(r.x), -sin(r.x), 0.0 ),\n\t   vec4( 0.0, sin(r.x),  cos(r.x), 0.0 ),\n\t   vec4( 0.0, 0.0,      0.0,       0.0 ) );\n\tmat4 Ry = mat4(\n\t   vec4(  cos(r.y), 0.0, sin(r.y), 0.0 ),\n\t   vec4(  0.0,      1.0, 0.0,      0.0 ),\n\t   vec4( -sin(r.y), 0.0, cos(r.y), 0.0 ),\n\t   vec4(  0.0,      0.0, 0.0,      1.0 ) );\n\tmat4 Rz = mat4(\n\t   vec4( cos(r.z), -sin(r.z), 0.0, 0.0 ),\n\t   vec4( sin(r.z),  cos(r.z), 0.0, 0.0 ),\n\t   vec4( 0.0,      0.0,       1.0, 0.0 ),\n\t   vec4( 0.0,      0.0,       0.0, 1.0 ) );\n\tmat4 m = Rx * Ry * Rz;\n\treturn (vec4(p,1.0)*m).xyz;\n}\nvec3\nrotate_inv( in vec3 r, in vec3 p )\n{\n    r = -r;\n\tmat4 Rx = mat4(\n\t   vec4( 1.0, 0.0,      0.0,       0.0 ),\n\t   vec4( 0.0, cos(r.x), -sin(r.x), 0.0 ),\n\t   vec4( 0.0, sin(r.x),  cos(r.x), 0.0 ),\n\t   vec4( 0.0, 0.0,      0.0,       0.0 ) );\n\tmat4 Ry = mat4(\n\t   vec4(  cos(r.y), 0.0, sin(r.y), 0.0 ),\n\t   vec4(  0.0,      1.0, 0.0,      0.0 ),\n\t   vec4( -sin(r.y), 0.0, cos(r.y), 0.0 ),\n\t   vec4(  0.0,      0.0, 0.0,      1.0 ) );\n\tmat4 Rz = mat4(\n\t   vec4( cos(r.z), -sin(r.z), 0.0, 0.0 ),\n\t   vec4( sin(r.z),  cos(r.z), 0.0, 0.0 ),\n\t   vec4( 0.0,      0.0,       1.0, 0.0 ),\n\t   vec4( 0.0,      0.0,       0.0, 1.0 ) );\n\tmat4 m = Rz * Ry * Rx;\n\treturn (vec4(p,1.0)*m).xyz;\n}\n// NOTE(theGiallo): s.x radius, s.y Y axis rotation, s.z Z axis rotation\nvec3\ncartesian_from_spherical( in vec3 s )\n{\n\tmat4 Ry = mat4(\n\t   vec4(  cos(s.y), 0.0, sin(s.y), 0.0 ),\n\t   vec4(  0.0,      1.0, 0.0,      0.0 ),\n\t   vec4( -sin(s.y), 0.0, cos(s.y), 0.0 ),\n\t   vec4(  0.0,      0.0, 0.0,      1.0 ) );\n\tmat4 Rz = mat4(\n\t   vec4( cos(s.z), -sin(s.z), 0.0, 0.0 ),\n\t   vec4( sin(s.z),  cos(s.z), 0.0, 0.0 ),\n\t   vec4( 0.0,      0.0,       1.0, 0.0 ),\n\t   vec4( 0.0,      0.0,       0.0, 1.0 ) );\n\tmat4 m = Ry * Rz;\n\treturn (vec4(0.0,0.0,s.x,1.0)*m).xyz;\n}\n\nvec3\nat_angle( in vec3 a, in vec3 p )\n{\n    return rotate_inv( a, p );\n}\n\n#if 0\nvec3\nrepeat( in vec3 rep, in vec3 p )\n{\n    return mod(p,rep) + 0.5*rep;\n}\n#endif\n\nvec3\nrepeated( in vec3 rep, in vec3 p )\n{\n    return mod( p, rep ) - 0.5 * rep;\n}\n\nvec2\nunion_op( in vec2 p0, in vec2 p1 )\n{\n    if ( p0.x < p1.x )\n    {\n        return p0;\n    }\n    return p1;\n}\n\nvec2\nintersect_op( in vec2 p0, in vec2 p1 )\n{\n    if ( p0.x > p1.x )\n    {\n        return p0;\n    }\n    return p1;\n}\n\nvec2\nsubtract_op( in vec2 p0, in vec2 p1 )\n{\n    p0.x = -p0.x;\n    if ( p0.x > p1.x )\n    {\n        return p0;\n    }\n    return p1;\n}\n\nvec2\nmix_op_( in vec2 p0, in vec2 p1, float max_dist )\n{\n    bool do_mix = p0.x > 0.0 && p0.x < max_dist &&\n                  p1.x > 0.0 && p1.x < max_dist;\n    if ( !do_mix && p0.x < p1.x )\n    {\n        return p0;\n    }\n    if ( !do_mix && p1.x < p0.x )\n    {\n        return p1;\n    }\n    float h_max_dist = max_dist * 0.5;\n    p0.x = (p0.x-h_max_dist)/h_max_dist;\n    p1.x = (p1.x-h_max_dist)/h_max_dist;\n    float p02 = p0.x*p0.x;\n    float p12 = p1.x*p1.x;\n    float v = ( p0.x + p1.x )*0.5;\n    vec2 ret = vec2(max_dist * v, p0.y );\n\n    return ret;\n}\nvec2\nmix_op_( in vec2 p0, in vec2 p1, float max_dist, float m0 )\n{\n    bool do_mix = p0.x > 0.0 && p0.x < max_dist &&\n                  p1.x > 0.0 && p1.x < max_dist;\n    if ( !do_mix && p0.x < p1.x )\n    {\n        return p0;\n    }\n    if ( !do_mix && p1.x < p0.x )\n    {\n        return p1;\n    }\n    float h_max_dist = max_dist * 0.5;\n    p0.x = (p0.x-h_max_dist)/h_max_dist;\n    p1.x = (p1.x-h_max_dist)/h_max_dist;\n    float v = mix( p0.x, p1.x, m0 );\n    vec2 ret = vec2(max_dist * v, p0.y );\n\n    return ret;\n}\nvec2\nmix_op_( in vec2 p0, in vec2 p1, vec2 max_dist )\n{\n    bool do_mix = p0.x > 0.0 && p0.x < max_dist.x &&\n                  p1.x > 0.0 && p1.x < max_dist.y;\n    if ( !do_mix && p0.x < p1.x )\n    {\n        return p0;\n    }\n    if ( !do_mix && p1.x < p0.x )\n    {\n        return p1;\n    }\n    vec2 h_max_dist = max_dist * 0.5;\n    p0.x = (p0.x-h_max_dist.x)/h_max_dist.x;\n    p1.x = (p1.x-h_max_dist.y)/h_max_dist.y;\n    float v = mix( p0.x, p1.x, 0.5 );\n    vec2 ret = vec2(minv(max_dist) * v, p0.y );\n\n    return ret;\n}\n\nvec2\nmix_op_9avg( in vec2 p0, in vec2 p1, float max_dist )\n{\n    bool do_mix = p0.x > 0.0 && p0.x < max_dist &&\n                  p1.x > 0.0 && p1.x < max_dist;\n    if ( !do_mix && p0.x < p1.x )\n    {\n        return p0;\n    }\n    if ( !do_mix && p1.x < p0.x )\n    {\n        return p1;\n    }\n    vec2 m1 = mix_op_(p0,p1,vec2(max_dist*0.9, max_dist*0.1));\n    vec2 m2 = mix_op_(p0,p1,vec2(max_dist*0.8, max_dist*0.2));\n    vec2 m3 = mix_op_(p0,p1,vec2(max_dist*0.7, max_dist*0.3));\n    vec2 m4 = mix_op_(p0,p1,vec2(max_dist*0.6, max_dist*0.4));\n    vec2 m5 = mix_op_(p0,p1,vec2(max_dist*0.5, max_dist*0.5));\n    vec2 m6 = mix_op_(p0,p1,vec2(max_dist*0.4, max_dist*0.6));\n    vec2 m7 = mix_op_(p0,p1,vec2(max_dist*0.3, max_dist*0.7));\n    vec2 m8 = mix_op_(p0,p1,vec2(max_dist*0.2, max_dist*0.8));\n    vec2 m9 = mix_op_(p0,p1,vec2(max_dist*0.1, max_dist*0.9));\n    #if 0\n    return vec2((m1.x+m2.x+m3.x+m4.x+m5.x+m6.x+m7.x+m8.x+m9.x)/9.0,m9.y);\n    #else\n    return\n    vec2( minv(\n       vec3( minv(vec3(m1.x,m2.x,m3.x)),\n             minv(vec3(m4.x,m5.x,m6.x)),\n             minv(vec3(m7.x,m8.x,m9.x)) ) ), m9.y );\n    #endif\n}\n\nvec2\nmix_op_p2( in vec2 p0, in vec2 p1, float max_dist )\n{\n    bool do_mix = p0.x > 0.0 && p0.x < max_dist &&\n                  p1.x > 0.0 && p1.x < max_dist;\n    if ( !do_mix && p0.x < p1.x )\n    {\n        return p0;\n    }\n    if ( !do_mix && p1.x < p0.x )\n    {\n        return p1;\n    }\n    vec2 d;\n    d.x = p1.x - pow2( ( max_dist - p0.x ) / max_dist ) * max_dist;\n    d.y = p0.x - pow2( ( max_dist - p1.x ) / max_dist ) * max_dist;\n    return vec2((d.x+d.y)*0.5,p0.y);\n    //return vec2(min(d.x,d.y),p0.y);\n}\n\n// IQ's polynomial smooth min (k = 0.1);\nfloat\nsmin( float a, float b, float k )\n{\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\nvec2\nsmin_op( in vec2 p0, in vec2 p1, float max_dist )\n{\n    float m = smin(p0.x,p1.x,max_dist);\n    return vec2(m,m-p0.x>=m-p1.x?p0.y:p1.y);\n}\n\nvec2\nmix_op( in vec2 p0, in vec2 p1, float max_dist )\n{\n    if ( mod( iTime, 2.0 ) < 1.0 )\n    {\n        return smin_op(p0,p1,max_dist);\n    } else\n    {\n    \treturn mix_op_9avg(p0,p1,max_dist);\n    }\n#if 0\n\treturn mix_op_p2(p0,p1,max_dist);\n#endif\n}\n\nMaterial\nchange_color( Material m, vec3 color )\n{\n    Material ret = m;\n    ret.color = color;\n    return ret;\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\nfloat\nsphere_sd( in float sph_r, in vec3 p )\n{\n    return length( p ) - sph_r;\n}\n\nfloat\naab_sd( in vec3 sides, in vec3 p )\n{\n    sides *= 0.5;\n    p = abs( p );\n    vec3 d = p - sides;\n    return min( maxv( d ), 0.0 ) + length( max(d,0.0) );\n}\n\nfloat\nplane_sd( in vec3 p )\n{\n    return abs( p.z );\n}\n\n\nfloat\nhalf_space_sd( in vec3 p )\n{\n    return p.z;\n}\n\nfloat\nround_aab_ud( in vec3 sides, in float r, in vec3 p )\n{\n    sides *= 0.5;\n    p = abs( p );\n    vec3 d = p - sides;\n    return length( max(d, 0.0) ) - r;\n}\n\n// NOTE(theGiallo): torus.x = big radius torus.y = solid radius\nfloat\ntorus_sd( in vec2 torus, in vec3 p )\n{\n    vec2 q = vec2(length(p.xy)-torus.x,p.z);\n    return length(q)-torus.y;\n}\n\nfloat\ncylinder_sd( in float r, in vec3 p )\n{\n    return length( p.xy ) - r;\n}\n\nfloat\ncapped_cylinder_sd( in vec2 rh, in vec3 p )\n{\n    vec2 d = abs( vec2( length( p.xy ), p.z ) ) - rh;\n    return min( maxv(d), 0.0 ) + length( max(d, 0.0) );\n}\n\nfloat\nhalf_cone_pos_sd( in vec2 c, in vec3 p )\n{\n    vec2 c1 = vec2(c.y,-c.x);\n    return dot( c1, vec2(length(p.xy), p.z) );\n}\n\nfloat\ncone_sd( in vec2 c, in vec3 p )\n{\n    p = abs(p);\n    vec2 c1 = vec2(c.y,-c.x);\n    return dot( c1, vec2(length(p.xy), p.z) );\n}\n\nfloat\ncapped_cone_as_intersections_sd( in float h, in float r1, in float r2, in vec3 p )\n{\n    float R1z = (r1*h)/(r2-r1);\n    float R2z = R1z + h;\n    p = at_pos(vec3(0.0,0.0,-R1z),p);\n\tvec2 c = vec2(r2/R2z,1.0);\n\treturn\n\tmax( max( -half_space_sd( at_pos(vec3(0.0,0.0,R1z), p) ), half_space_sd( at_pos( vec3(0.0,0.0,R2z), p ) ) ),\n         half_cone_pos_sd( c, p )\n       );\n}\n\n// NOTE(theGiallo): d.x is the depth of the prism(or height), d.y the radius\n// NOTE(theGiallo): depth on x axis, diameter on y axis\nfloat\nhex_prism_sd( in vec2 dr, in vec3 p )\n{\n    p = abs(p);\n    return max(p.x-dr.x*0.5,max(p.y*0.866025+p.z*0.5,p.z)-0.866025*dr.y);\n}\n\nfloat\ntri_prism_sd( in vec2 ds, in vec3 p )\n{\n  \tp.xy = abs(p.xy);\n    \n    return max( p.x - ds.x*0.5, max( p.y * 0.866025 + 0.5 * p.z - ds.y * 0.433012702, -p.z ) );\n}\n\nfloat\ntri_prism_bary_sd( in vec2 ds, in vec3 p )\n{\n    p.z += ds.y * 0.288675135;\n    \n    return tri_prism_sd( ds, p );\n}\n\nfloat\ntri_prism_bary_r_sd( in vec2 dr, in vec3 p )\n{\n    dr.y = dr.y * 1.732050808;\n    \n    return tri_prism_bary_sd( dr, p );\n}\n\nfloat\ncline_sd( in vec3 a, in vec3 b, in float r, in vec3 p )\n{\n    vec3 ap = p - a, ab = b - a;\n    float t = clamp( dot(ap,ab)/dot(ab,ab), 0.0, 1.0 );\n    return length( ap - ab * t ) - r;\n}\n\nfloat\nellipsoid_sd( in vec3 r3, in vec3 p )\n{\n    return ( length( p/r3 ) - 1.0 ) * minv(r3);\n}\n\nfloat\nsphere8_sd( in float sph_r, in vec3 p )\n{\n    return length8( p ) - sph_r;\n}\n\n// NOTE(theGiallo): torus.x = big radius torus.y = solid radius\nfloat\ntorus82_sd( in vec2 torus, in vec3 p )\n{\n    vec2 q = vec2(length(p.xy)-torus.x,p.z);\n    return length8(q)-torus.y;\n}\n\n// NOTE(theGiallo): torus.x = big radius torus.y = solid radius\nfloat\ntorus88_sd( in vec2 torus, in vec3 p )\n{\n    vec2 q = vec2(length8(p.xy)-torus.x,p.z);\n    return length8(q)-torus.y;\n}\n\n\nfloat\nsphere4_sd( in float sph_r, in vec3 p )\n{\n    return length4( p ) - sph_r;\n}\n\n// NOTE(theGiallo): torus.x = big radius torus.y = solid radius\nfloat\ntorus42_sd( in vec2 torus, in vec3 p )\n{\n    vec2 q = vec2(length(p.xy)-torus.x,p.z);\n    return length4(q)-torus.y;\n}\n\n// NOTE(theGiallo): torus.x = big radius torus.y = solid radius\nfloat\ntorus44_sd( in vec2 torus, in vec3 p )\n{\n    vec2 q = vec2(length4(p.xy)-torus.x,p.z);\n    return length4(q)-torus.y;\n}\n\nfloat\nsphere3_sd( in float sph_r, in vec3 p )\n{\n    return length3(abs(p)) - sph_r;\n}\n\n// NOTE(theGiallo): torus.x = big radius torus.y = solid radius\nfloat\ntorus32_sd( in vec2 torus, in vec3 p )\n{\n    vec2 q = vec2(length(p.xy)-torus.x,p.z);\n    return length3(abs(q))-torus.y;\n}\n\n// NOTE(theGiallo): torus.x = big radius torus.y = solid radius\nfloat\ntorus33_sd( in vec2 torus, in vec3 p )\n{\n    vec2 q = vec2(length3(abs(p.xy))-torus.x,p.z);\n    return length3(abs(q))-torus.y;\n}\n\nfloat\nspheremh_sd( in float sph_r, in vec3 p )\n{\n    return manhattan(p) - sph_r;\n}\n\n// NOTE(theGiallo): torus.x = big radius torus.y = solid radius\nfloat\ntorus2mh_sd( in vec2 torus, in vec3 p )\n{\n    vec2 q = vec2(manhattan(p.xy)-torus.x,p.z);\n    return length(q)-torus.y;\n}\n\n// NOTE(theGiallo): torus.x = big radius torus.y = solid radius\nfloat\ntorusmh2_sd( in vec2 torus, in vec3 p )\n{\n    vec2 q = vec2(length(p.xy)-torus.x,p.z);\n    return manhattan(q)-torus.y;\n}\n\n// NOTE(theGiallo): torus.x = big radius torus.y = solid radius\nfloat\ntorusmhmh_sd( in vec2 torus, in vec3 p )\n{\n    vec2 q = vec2(manhattan(p.xy)-torus.x,p.z);\n        return manhattan(q)-torus.y;\n}\n\n\nfloat\ncapped_cylinder8_sd( in vec2 rh, in vec3 p )\n{\n    vec2 d = abs( vec2( length8( p.xy ), p.z ) ) - rh;\n    return min( maxv(d), 0.0 ) + length8( max(d, 0.0) );\n}\n\nfloat\ncapped_cylindermh_sd( in vec2 rh, in vec3 p )\n{\n    vec2 d = abs( vec2( manhattan( p.xy ), p.z ) ) - rh;\n    return min( maxv(d), 0.0 ) + manhattan( max(d, 0.0) );\n}\n    \n//////////\n\nvec2\nmap( in vec3 pos )\n{    \n    float angle4 = iTime*TAU*0.25;\n    \n    MPt res;\n    res.distance = 1e38;\n\n    float m = mod( floor(pos.x * 2.0) + floor(pos.y * 2.0), 2.0 );\n    res = union_op( MPt( plane_sd( pos ),\n                         MAT_FLOOR_B * (1.0 - m) + MAT_FLOOR_W * m ),\n                    res );\n    \n    const float axis_r = 0.05;\n    res = union_op( MPt( sphere_sd( axis_r*2.0, at_pos( vec3(0.0), pos ) ),\n                         MAT_PLASTIC ), res );\n    res = union_op( MPt( cline_sd( vec3(0.0), vec3(1.0,0.0,0.0), axis_r, pos ),\n                         MAT_RED ),res );\n    res = union_op( MPt( cline_sd( vec3(0.0), vec3(0.0,1.0,0.0), axis_r, pos ),\n                         MAT_GREEN ),res );\n    res = union_op( MPt( cline_sd( vec3(0.0), vec3(0.0,0.0,1.0), axis_r, pos ),\n                         MAT_BLUE ),res );\n\n\n\n    res =\n       union_op(\n          MPt( aab_sd(vec3(0.15,4.0,3.0),at_pos(vec3(-2.575,0.0,1.65),pos) ), MAT_PLASTIC ),\n          res );\n    res =\n       union_op(\n          MPt( aab_sd(vec3(0.15,4.0,3.0),at_pos(vec3(2.575,0.0,1.65),pos) ), MAT_PLASTIC ),\n          res );\n    res =\n       union_op(\n          MPt( aab_sd(vec3(5.3,4.0,0.15),at_pos(vec3(0.0,0.0,3.225),pos) ), MAT_PLASTIC ),\n          res );\n    res =\n       union_op(\n          MPt( aab_sd(vec3(5.3,4.0,0.15),at_pos(vec3(0.0,0.0,0.075),pos) ), MAT_PLASTIC ),\n          res );\n    \n    \n    res =\n       union_op(\n          subtract_op(\n             intersect_op(\n             \tMPt( capped_cylinder_sd(vec2(2.0,5.0),at_angle( vec3(HPI,0.0,0.0), at_pos(vec3(6.0,0.0,1.5),pos) ) ), MAT_PLASTIC ),\n                MPt( aab_sd(vec3(4.0,5.0,4.0),at_pos(vec3(6.0,0.0,2.15),pos) ), MAT_PLASTIC ) ),\n             MPt( aab_sd(vec3(5.0,4.0,3.6),at_pos(vec3(6.0,0.0,1.8),pos) ), MAT_PLASTIC )\n          ),\n          res );\n    \n    \n    \n    \n    vec3 op = pos;\n    pos = repeated( vec3(0.0,4.0,0.0), pos );\n    \n    // NOTE(theGiallo): tunnel section\n    float X = 12.0;\n    vec3 P = at_pos(vec3(X,0.0,2.5), pos );\n    res =\n       union_op(\n          subtract_op(\n             union_op(\n                MPt( capped_cylinder_sd (vec2(2.0,5.0),\n                                         at_angle( vec3(HPI,0.0,0.0),\n                                                   P ) ), MAT_PLASTIC ),\n                intersect_op(\n                   MPt( capped_cylinder_sd (vec2(2.05,0.25),\n                                            at_angle( vec3(HPI,0.0,0.0),\n                                                      repeated( vec3(0.0,1.0,0.0),\n                                                                P ) ) ), MAT_ORANGE ),\n                   MPt( aab_sd(vec3(5.0,4.0,3.0),at_pos(vec3(0.0,0.0,1.0),P) ), MAT_PLASTIC ) )\n                ),\n             MPt( aab_sd(vec3(5.0,4.05,5.0),P ), MAT_PLASTIC )\n          ),\n          res );\n\n    // NOTE(theGiallo): grid\n    res =\n       union_op(\n          subtract_op(\n             MPt( aab_sd( vec3(0.02,0.02,0.1),\n                          repeated( vec3(0.02,0.02,0.0), at_angle( vec3(0.0,0.0,QPI),\n                                    at_pos( vec3(X,0.0,1.0),\n                                            pos) ) ) ), MAT_METAL_GRID ),\n             MPt( aab_sd(vec3(2.5,4.0,0.02),at_pos(vec3(X,0.0,1.0),pos) ), MAT_METAL_GRID )\n          ),\n          res );\n\n    \n    pos = op;\n    \n    \n\n\treturn res;\n}\n\nvec3\ncalc_normal( in vec3 pos, in float t )\n{\n    vec3 eps = vec3( max(0.02,T_EPS*t),0.0,0.0);\n\treturn normalize( vec3(\n           map( pos + eps.xyy ).distance - map( pos - eps.xyy ).distance,\n           map( pos + eps.yxy ).distance - map( pos - eps.yxy ).distance,\n           map( pos + eps.yyx ).distance - map( pos - eps.yyx ).distance ) );\n}\n\nvec2\nraymarch( in vec3 start, in vec3 dir, inout float t, in float t_max )\n{\n    MPt mp;\n    for ( int it=0; it!=RAYM_MAX_ITERS; ++it )\n    {\n        vec3 here = start + dir * t;\n        mp = map( here );\n        #if DRAW_ITERATIONS_GRADIENT\n        mp.y = mp.y * 10000.0 + float(it);\n        #endif\n        if ( mp.distance < ( T_EPS * t ) || t > t_max )\n        {\n        \tbreak;\n        }\n        #if 1\n        // NOTE(theGiallo): this is to sample nicely the twisted things\n        t += mp.distance * 0.4;\n        #else\n        t += mp.distance;\n        #endif\n    }\n    if ( t > t_max )\n    {\n        t = -1.0;\n    }\n    return mp;\n}\n\nfloat\nshadow( in vec3 start, in vec3 dir )\n{\n    float ret = 1.0;\n    float c = step( mod( iTime, 4.0 ), 2.0 );\n    float t = 0.02, t_max = 16.0;\n    MPt mp;\n    \n    #if DRAW_ITERATIONS_GRADIENT\n    int it_;\n    #endif\n    for ( int it=0; it!=16; ++it )\n    {\n\t    #if DRAW_ITERATIONS_GRADIENT\n\t    it_ = it;\n    \t#endif\n        vec3 here = start + dir * t;\n        mp = map( here );\n        ret = min( ret, 8.0*mp.distance/t);\n        if ( mp.distance < ( T_EPS * t ) || t > t_max )\n        {\n        \tbreak;\n        }\n        \n        float inc;\n        // NOTE(theGiallo): this is to sample nicely the twisted things\n        inc = c * mp.distance * 0.4;\n\t\tinc += ( 1.0 - c ) * clamp( mp.distance, 0.02, 0.1 );\n        t += inc;\n    }\n    #if DRAW_ITERATIONS_GRADIENT\n    return float(it_);\n    #endif\n    if ( t > t_max )\n    {\n        t = -1.0;\n    }\n    if ( c == 0.0 ) return 1.0 - clamp( ret, 0.0, 1.0 );\n\n    if ( t < 0.0 )\n    {\n        return 0.0;\n    }\n    //return 1.0;\n    ret = 1.0 / pow(1.0 - 1e-30 + max( mp.distance, 1e-30 ), 5.0 );\n    float th = 0.1;\n    return smoothstep( 0.0, 1.0, ( ret*1.1 - th ) / (1.0-th) );\n}\n\n\nfloat\nimg_scale_given_h_fov( float near, float fov )\n{\n    float hw = iResolution.x / min( iResolution.y, iResolution.x );\n    return tan( fov * 0.5 ) * near / hw;\n}\n\nvec3\nrender_no_reflections( in Material materials_table[MAT_COUNT],\n                       in vec3 start, in vec3 dir, in float max_dist,\n                       inout float t, out vec3 normal, out int material_index )\n{\n    vec3 ret = rgb_from_hsv(vec3(0.57,0.5,0.7));\n    vec3 sun_specular_color = vec3(0.8,1.0,1.0);\n    vec3 sun_light_dir = normalize( rotate( vec3(0.0,0.0,iTime*TAU/16.0), vec3( -0.5, 1.0, -1.0 ) ) );\n    \n    vec3 point_light_pos = vec3(12.0,-4.0,3.8);\n    float point_light_int = 1.0;\n    float point_light_radius = 6.0;\n\n    MPt mp = raymarch( start, dir, t, 1e2 );\n    material_index = int(mp.y);\n    Material mat;\n    for ( int i = 0; i != MAT_COUNT; ++i )\n    {\n        if ( i == material_index )\n        {\n            mat = materials_table[i];\n        }\n\t}\n\n    if ( t > 0.0 )\n    {\n        vec3 point = start + dir * t;\n        normal = calc_normal( point, t );\n        // ret = 0.5 + normal * 0.5;return ret;\n                \n        vec3 pld = point_light_pos - point;\n        float ld = length( pld );\n        pld /= ld;\n        float ld2 = ld*ld;\n\n        #if DRAW_ITERATIONS_GRADIENT\n        mp.y += shadow( point, -sun_light_dir );\n        #else\n        float sh = 1.0 - shadow( point, -sun_light_dir );\n        float diffuse = sh * max( 0.0, dot( normal, -sun_light_dir ) );\n        float spec = sh * pow( max( 0.0, dot( reflect( dir, normal ) , -sun_light_dir ) ), mat.shininess  );\n        #endif\n\n        #if DRAW_ITERATIONS_GRADIENT\n        mp.y += shadow( point, pld );\n        #else\n        float sh_pl = 0.0, diffuse_pl = 0.0, spec_pl = 0.0;\n        if ( ld <= point_light_radius )\n        {\n            sh_pl = 1.0 - shadow( point, pld );\n        \tdiffuse_pl = sh_pl * max( 0.0, dot( normal, pld ) );\n        \tspec_pl = sh_pl * pow( max( 0.0, dot( reflect( dir, normal ) , pld ) ), mat.shininess  );\n    \t}\n        \n        float ambient = 0.3;\n        ret = ( ( diffuse + diffuse_pl * point_light_int / ld2 ) * mat.diffuse_reflection +\n                  ambient   * mat.ambient_reflection ) * mat.color +\n                ( spec + spec_pl * point_light_int / ld2  ) * mat.specular_reflection * sun_specular_color;\n        #endif\n    } else\n    if ( t == 0.0 )\n    {\n        ret = mat.color / ( 1.0 - 20.0 * mp.distance );\n    }\n    #if DRAW_ITERATIONS_GRADIENT\n    material_index = int(mp.y);\n    #endif\n    return ret;\n}\n\nvoid\ncamera_linear_gallery( in vec3 start, in vec3 obj_dist, in float sec_per_obj,\n                       out vec3 camera_pos )\n{\n    const int obj_count = 3;\n\n    float u = mirror( iTime / ( float(obj_count) * sec_per_obj ) );\n\n    //u = 1.0;\n\n    float pu = 1.0 / float(obj_count-1);\n    float pt = 0.0;\n    vec3 p = vec3(0.0);\n    for ( int i = 0; i!=obj_count; ++i )\n    {\n        float s = pu * ( -0.5 + float(i) );\n        p +=\n           ( start + obj_dist * float(i) ) *\n           ( smoothstep( s - 0.1 * pu, s + 0.1 * pu, u ) - smoothstep( s + pu * 0.9, s + pu * 1.1, u ) );\n    }\n    camera_pos.xyz = p;\n}\n\nvoid\ncamera_radial_gallery_mirror( in vec3 center, in vec2 radial_start, in vec2 obj_radial_dist, in float radius, in float sec_per_obj,\n                       out vec3 camera_pos )\n{\n    const int obj_count = 6;\n\n    float u = mirror( iTime / ( float(obj_count) * sec_per_obj ) );\n\n    //u = 1.0;\n\n    float pu = 1.0 / float(obj_count-1);\n    float pt = 0.0;\n    vec2 a = vec2(0.0);\n    for ( int i = 0; i!=obj_count; ++i )\n    {\n        float s = pu * ( -0.5 + float(i) );\n        a +=\n           ( obj_radial_dist * float(i) ) *\n           ( smoothstep( s - 0.1 * pu, s + 0.1 * pu, u ) - smoothstep( s + pu * 0.9, s + pu * 1.1, u ) );\n        \n    }\n    camera_pos.xyz = center + cartesian_from_spherical( vec3(radius,radial_start+a) );\n}\nvoid\ncamera_radial_gallery_loop( in vec3 center, in vec2 radial_start, in vec2 obj_radial_dist, in float radius, in float sec_per_obj,\n                       out vec3 camera_pos, out vec3 look )\n{\n    // NOT)theGiallo): set 1+ if you want a complete circle\n    const int obj_count = 9;\n\n    float u = decimal( iTime / ( float(obj_count) * sec_per_obj ) );\n    \n    \n    if ( iMouse.z > 0.0 )\n    {\n    \tvec2 mouse_u = iMouse.xy / iResolution.xy;\n        u = mouse_u.x;\n    }\n\n    //u = 1.0;\n\n    float pu = 1.0 / float(obj_count-1);\n    float pt = 0.0;\n    vec2 a = vec2(0.0);\n    for ( int i = 0; i!=obj_count; ++i )\n    {\n        float s = pu * ( -0.5 + float(i) );\n        a +=\n           ( obj_radial_dist * float(i) ) *\n           ( smoothstep( s - 0.1 * pu, s + 0.1 * pu, u ) - smoothstep( s + pu * 0.9, s + pu * 1.1, u ) );\n        \n    }\n    camera_pos.xyz = cartesian_from_spherical( vec3(radius,radial_start+a) );\n    look = normalize(-camera_pos);\n    camera_pos.xyz += center;\n}\n\nvoid\nfirst_person_camera( in vec3 pos, in vec2 angles0, in vec2 angles, out vec3 camera_pos, out vec3 look )\n{\n    vec2 a = angles*( iMouse.yx/iResolution.yx * 2.0 - 1.0 );\n\t//a = vec2(0.0);\n    a.y = -a.y;\n    #if INVERTED_Y_AXIS\n    a.x = -a.x;\n    #endif\n    a += angles0;\n    \n    camera_pos.xyz = cartesian_from_spherical( vec3(0.075,a) );\n    look = normalize(-camera_pos);\n    camera_pos.xyz = pos;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{    \n\tvec2 q = fragCoord.xy / iResolution.xy;\n    vec2 qc = 2.0 * q - 1.0;\n\tvec2 p = ( 2.0 * fragCoord.xy - iResolution.xy ) / min( iResolution.y, iResolution.x );\n    vec4 col;\n    \n    float img_plane_dist = 0.05;\n    float img_scale = img_scale_given_h_fov( img_plane_dist, TAU / 3.0 );\n\n    float time = iTime * PI * 0.06125;\n\n    vec3 d = vec3(6.0,0.0,0.0);\n    vec3 base = vec3(0.0,4.0,1.3);\n    \n    vec3 camera_pos;\n    vec3 look;\n    #if CAMERA_LINEAR\n    camera_linear_gallery( base, d, 4.0, camera_pos );\n    look = normalize( vec3(0.0,-0.5,-0.1) );\n    #else\n    //camera_radial_gallery_loop( vec3(12.0,0.0,2.0), vec2(HPI*0.8,-QPI), vec2(0.0,TAU/8.0), 4.0, 4.0, camera_pos, look );\n    \n    vec3 cp = vec3(12.0,0.0,2.8);\n    vec2 angles = vec2(PI*0.4,TAU*1.5);\n    vec2 angles0 = vec2(HPI,HPI);\n    first_person_camera( cp, angles0, angles, camera_pos, look );\n    #endif\n\n    vec3 up = vec3(0.0,0.0,1.0);\n    vec3 right = normalize(cross( look, up ));\n    vec3 img_up = cross( right, look );\n\n    vec3 dir = look * img_plane_dist + right * p.x * img_scale + img_up * p.y * img_scale;\n    vec3 start = camera_pos + dir;\n    dir = normalize( dir );\n\n    float max_dist = 1e2;\n    float max_dist_reflection = 1e1;\n    float t = 0.0, t1 = 0.0;\n    vec3 normal, normal1;\n    vec3 pos, pos1, dir1;\n\n    Material materials_table[MAT_COUNT];\n\n    materials_table[int(MAT_PLASTIC)].color = rgb_from_hsv( vec3(0.083,0.1,1.0) );\n    materials_table[int(MAT_PLASTIC)].diffuse_reflection  = 1.0;\n    materials_table[int(MAT_PLASTIC)].specular_reflection = 1.0;\n    materials_table[int(MAT_PLASTIC)].ambient_reflection  = 1.0;\n    materials_table[int(MAT_PLASTIC)].shininess           = 15.0;\n\n    materials_table[int(MAT_FLOOR_B)].color = vec3(0.7);\n    materials_table[int(MAT_FLOOR_B)].diffuse_reflection  = 1.0;\n    materials_table[int(MAT_FLOOR_B)].specular_reflection = 0.2;\n    materials_table[int(MAT_FLOOR_B)].ambient_reflection  = 0.5;\n    materials_table[int(MAT_FLOOR_B)].shininess           = 1.0;\n\n    materials_table[int(MAT_FLOOR_W)].color = vec3(1.0);\n    materials_table[int(MAT_FLOOR_W)].diffuse_reflection  = 1.0;\n    materials_table[int(MAT_FLOOR_W)].specular_reflection = 0.2;\n    materials_table[int(MAT_FLOOR_W)].ambient_reflection  = 0.5;\n    materials_table[int(MAT_FLOOR_W)].shininess           = 1.0;\n\n    materials_table[int(MAT_ORANGE)] = change_color(materials_table[int(MAT_PLASTIC)], ORANGE_RGB );\n    materials_table[int(MAT_RED   )] = change_color(materials_table[int(MAT_PLASTIC)], vec3(1.0,0.0,0.0) );\n    materials_table[int(MAT_GREEN )] = change_color(materials_table[int(MAT_PLASTIC)], vec3(0.0,1.0,0.0) );\n    materials_table[int(MAT_BLUE  )] = change_color(materials_table[int(MAT_PLASTIC)], vec3(0.0,0.0,1.0) );\n\n    materials_table[int(MAT_METAL_GRID)].color = rgb_from_hsv( vec3(225.0/360.0,0.06,0.65) );\n    materials_table[int(MAT_METAL_GRID)].diffuse_reflection  = 0.8;\n    materials_table[int(MAT_METAL_GRID)].specular_reflection = 1.1;\n    materials_table[int(MAT_METAL_GRID)].ambient_reflection  = 0.9;\n    materials_table[int(MAT_METAL_GRID)].shininess           = 16.0;\n    \n    int material_index;\n    col.rgb = render_no_reflections( materials_table, start, dir, max_dist, t, normal, material_index );\n    #if DRAW_ITERATIONS_GRADIENT\n    float it = mod( float(material_index), 10000.0 ),\n          it1 = 0.0;\n    material_index /= 10000;\n    #endif\n    \n    float max_iters = float(RAYM_MAX_ITERS) + 32.0 + 1.0;\n#if RENDER_REFLECTIONS\n    max_iters += float(RAYM_MAX_ITERS) + 32.0;\n    pos = start + dir * t;\n    float fe = 0.01;\n    float cn = dot(normal,-dir);\n    float sn = 1.0 - cn*cn;\n    if ( t > 0.0 && ( material_index == int(MAT_FLOOR_W) || material_index == int(MAT_FLOOR_B) ) )\n    {\n        int material_index1;\n        dir1 = reflect(dir,normal);\n        t1 = 0.01;\n        vec3 reflection;\n    \treflection = render_no_reflections( materials_table, pos, dir1, max_dist_reflection, t1, normal1, material_index1 );\n        \n\t    #if DRAW_ITERATIONS_GRADIENT\n    \tit1 = mod( float(material_index1), 10000.0 );\n    \t#else\n        if ( t1 > 0.0 )\n        {\n            t1 += 1.0;\n        \tfloat a = ( sn*sn * 0.9 / t1 );\n        \tcol.rgb = col.rgb * ( 1.0 - a ) + a * reflection;\n        }\n        #endif\n    }\n#endif\n    #if DRAW_ITERATIONS_GRADIENT\n\t   col.rgb = rgb_from_hsv(vec3(float(it+it1)/(1.0*max_iters),1.0,1.0));\n    #endif\n    \n    // NOTE(theGiallo): gamma correction\n\t// col.rgb = pow( col.rgb, vec3(0.4545) );\n\n    fragColor = vec4(col.rgb,1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XttXWl.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[961, 961, 988, 988, 1052], [1053, 1053, 1090, 1090, 1184], [1185, 1185, 1215, 1215, 1285], [1286, 1286, 1310, 1310, 1355], [1356, 1356, 1380, 1380, 1431], [1433, 1433, 1459, 1459, 1488], [1489, 1489, 1513, 1513, 1542], [1543, 1543, 1567, 1567, 1596], [1597, 1597, 1623, 1623, 1654], [1655, 1655, 1679, 1679, 1710], [1711, 1711, 1735, 1735, 1766], [1767, 1767, 1793, 1793, 1835], [1836, 1836, 1860, 1860, 1902], [1903, 1903, 1927, 1927, 1969], [1970, 1970, 1996, 1996, 2073], [2074, 2074, 2098, 2098, 2174], [2175, 2175, 2199, 2199, 2275], [2276, 2276, 2300, 2300, 2355], [2356, 2356, 2380, 2380, 2435], [2436, 2436, 2474, 2474, 2512], [2513, 2513, 2551, 2551, 2593], [2595, 2595, 2678, 2678, 2874], [2875, 2875, 2971, 2971, 3398], [3399, 3399, 3514, 3514, 3998], [4000, 4041, 4088, 4088, 4180], [4182, 4182, 4207, 4207, 4277], [4279, 4279, 4305, 4305, 4332], [4334, 4365, 4396, 4396, 5028], [5088, 5088, 5113, 5113, 5155], [5157, 5157, 5182, 5182, 5224], [5226, 5226, 5251, 5251, 5281], [5283, 5283, 5308, 5308, 5338], [5341, 5341, 5369, 5369, 5420], [5421, 5421, 5449, 5449, 5500], [5502, 5502, 5530, 5530, 5581], [5582, 5582, 5610, 5610, 5661], [5662, 5662, 5690, 5690, 5741], [5742, 5742, 5770, 5770, 5821], [5822, 5822, 5850, 5850, 5901], [5902, 5902, 5930, 5930, 5981], [5985, 5985, 6024, 6024, 6044], [6046, 6046, 6065, 6065, 6274], [6276, 6276, 6313, 6313, 6941], [6942, 6942, 6983, 6983, 7623], [7624, 7697, 7741, 7741, 8183], [8185, 8185, 8224, 8224, 8257], [8348, 8348, 8389, 8389, 8429], [8431, 8431, 8472, 8472, 8543], [8545, 8545, 8590, 8590, 8661], [8663, 8663, 8707, 8707, 8796], [8798, 8798, 8854, 8854, 9355], [9356, 9356, 9422, 9422, 9871], [9872, 9872, 9927, 9927, 10394], [10396, 10396, 10456, 10456, 11522], [11524, 11524, 11582, 11582, 12037], [12039, 12080, 12121, 12121, 12214], [12216, 12216, 12272, 12272, 12359], [12361, 12361, 12416, 12416, 12611], [12613, 12613, 12662, 12662, 12725], [12809, 12809, 12855, 12855, 12889], [12891, 12891, 12933, 12933, 13052], [13054, 13054, 13083, 13083, 13108], [13111, 13111, 13145, 13145, 13163], [13165, 13165, 13225, 13225, 13325], [13327, 13391, 13435, 13435, 13512], [13514, 13514, 13558, 13558, 13591], [13593, 13593, 13644, 13644, 13756], [13758, 13758, 13806, 13806, 13885], [13887, 13887, 13926, 13926, 14021], [14023, 14023, 14113, 14113, 14400], [14402, 14535, 14580, 14580, 14672], [14674, 14674, 14719, 14719, 14843], [14845, 14845, 14895, 14895, 14967], [14969, 14969, 15021, 15021, 15098], [15100, 15100, 15163, 15163, 15292], [15294, 15294, 15339, 15339, 15389], [15391, 15391, 15438, 15438, 15473], [15475, 15539, 15585, 15585, 15663], [15665, 15729, 15775, 15775, 15854], [15857, 15857, 15904, 15904, 15939], [15941, 16005, 16051, 16051, 16129], [16131, 16195, 16241, 16241, 16320], [16322, 16322, 16369, 16369, 16407], [16409, 16473, 16519, 16519, 16602], [16604, 16668, 16714, 16714, 16803], [16805, 16805, 16853, 16853, 16888], [16890, 16954, 17001, 17001, 17081], [17083, 17147, 17194, 17194, 17274], [17276, 17340, 17388, 17388, 17475], [17478, 17478, 17530, 17530, 17644], [17646, 17646, 17699, 17699, 17817], [17835, 17835, 17860, 17860, 21181], [21183, 21183, 21228, 21228, 21530], [21532, 21532, 21608, 21608, 22170], [22172, 22172, 22216, 22216, 23308], [23311, 23311, 23365, 23365, 23476], [23478, 23478, 23697, 23697, 25842], [28196, 28196, 28306, 28306, 28603], [28605, 28605, 28662, 28662, 33186]], "test": "error"}
{"id": "XtVSz1", "name": "Simple Flower", "author": "cacheflowe", "description": "A simple distance-based flower made from overlapping circles", "tags": ["flower", "circle"], "likes": 9, "viewed": 859, "published": "Public API", "date": "1482941224", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const float TWO_PI = 6.28318530718;\nconst float distThresh = 0.4;\nconst float baseRadius = 0.1;\nconst float brightAdjust = 4.;\nconst int numControlPoints = 12;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2  uv = (2. * fragCoord.xy - iResolution.xy) / iResolution.y,\n          center = vec2(0);\n    float speed = 1.0,\n          time = iTime * speed,\n          radius = baseRadius + baseRadius * 0.98 * sin(time), // 0.98 to reduce aliasing when all circles overlap\n          dist = 0.,\n          segmentRads = TWO_PI / float(numControlPoints);\n    \n\t// create control points in a circle and check distance sum\n    for(int i=0; i < numControlPoints; i++) {\n        float curRads = segmentRads * float(i);\n        float curRadius = radius * 2.;\n        vec2 ctrlPoint = vec2(sin(curRads) * curRadius, cos(curRads) * curRadius);\n        if(distance(uv, ctrlPoint) < distThresh) dist += distance(uv, ctrlPoint);\n    }\n    \n    // adjust distance to compensate for numControlPoints addition\n    dist /= float(numControlPoints);\n    fragColor = vec4(vec3(dist * brightAdjust), 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XtVSz1.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[161, 161, 218, 218, 1099]], "test": "valid"}
{"id": "XtySzD", "name": "Color Separation by UV", "author": "cacheflowe", "description": "Wavy oscillations. Using saw() for a bit of a different look than sin()", "tags": ["wavy", "sprites", "colorseparation"], "likes": 2, "viewed": 562, "published": "Public API", "date": "1483129558", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI     3.14159265358\n#define TWO_PI 6.28318530718\n\n// saw method ported from my Processing code to be a drop-in replacement for sin()\n// there's probably a way better way to do this..\nfloat saw(float rads) {\n    rads += PI * 0.5; // sync oscillation up with sin()\n    float percent = mod(rads, PI) / PI;\t\t\t\t\n    float dir = sign(sin(rads));\n    percent *= 2. * dir;\n    percent -= dir;\n    return percent;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float time = iTime * 1.5;\n    // center coordinates\n    vec2 uv = (2. * fragCoord.xy - iResolution.xy) / iResolution.y,\n         center = vec2(0);\n    // wavy vertical - oscillate x position by sin(y)\n    uv += vec2(0.15 * sin(uv.y * 6. * (1. + sin(time))), 0);\n\t// rotation of uv from: http://stackoverflow.com/questions/28074977/rotating-a-texture-on-a-fragment-shader-in-glsl-es\n    float rotRads = 0.3 + 0.3 * sin(time);\n    uv *= mat2(cos(rotRads), sin(rotRads), -sin(rotRads), cos(rotRads));\n    // stripes\n    float thickness = 35. + 10. * sin(time);\n    // separate color by moving green component by an x offset. use saw() for stripes \n    vec3 color = 0.5 + 0.5 * vec3(\n        saw(uv.x * thickness),\n        saw((uv.x - (0.025 + 0.025 * sin(time))) * thickness),\n        saw(uv.x * thickness)\n    ); \n\tfragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XtySzD.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[59, 192, 215, 215, 415], [418, 418, 475, 475, 1324]], "test": "valid"}
{"id": "XtySzR", "name": "Mandelbrot with shifted \"origin\"", "author": "mv", "description": "Instead of starting z at (0,0), shift the starting point slightly. Uses smooth coloring (http://www.iquilezles.org/www/articles/mset_smooth/mset_smooth.htm)", "tags": ["fractal", "julia", "mandelbrot"], "likes": 11, "viewed": 931, "published": "Public API", "date": "1482339273", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float iter(vec2 z, vec2 c) {\n    float n = 0.0;\n    float B = 256.0;\n    \n    for (int i = 0; i < 200; i++) {\n     \tz = vec2(z.x*z.x - z.y*z.y, 2.0*z.x*z.y) + c;\n        if (dot(z,z) > B*B)\n            break;\n        n += 1.0;\n    }\n           \n    // http://www.iquilezles.org/www/articles/mset_smooth/mset_smooth.htm\n\treturn n - log2(log2(dot(z,z))) + 4.0;\n}\n\nfloat mandel(vec2 p, vec2 o) {\n    vec2 c = vec2(-2.5, -1.0) + 2.0*p;\n    vec2 z = 0.5*o;\n\t\n\treturn iter(z, c);\n}\n\nfloat julia(vec2 p, vec2 o) {\n    float ratio = iResolution.x/iResolution.y;\n    vec2 z = (vec2(-1.0*ratio, -1.0) + 2.0*p)*1.5;\n    vec2 c = 0.5*o; \n\t\n    return iter(z, c);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{    \n    // https://mathcoloring.wordpress.com/2016/01/14/math-mistakes-driving-me-crazy/\n    float Ax = 4.0;\n    float Bx = 16.0;\n    float Ay = 6.0;\n    float By = 14.0;\n    float t = iTime*0.3;\n    float x = cos(t) - 0.5*cos(Ax*t) + 1.0/3.0 * cos(-Bx*t);\n    float y = sin(t) - 0.5*sin(Ay*t) + 1.0/3.0 * sin(-By*t);\n    \n\tfloat sn = mandel(fragCoord.xy/iResolution.y, vec2(x,y));\n\t//float sn = julia(fragCoord.xy/iResolution.y, vec2(x,y));\n    fragColor = vec4(0.03*sn, 0.0, 0.0, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XtySzR.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 28, 28, 360], [362, 362, 392, 392, 475], [477, 477, 506, 506, 652], [654, 654, 711, 800, 1201]], "test": "valid"}
{"id": "XtyXRR", "name": "Particle transparency demo", "author": "BiiG", "description": "Particle transparency demo", "tags": ["particletransparencydemo"], "likes": 0, "viewed": 463, "published": "Public API", "date": "1482487024", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//\n// Lit transluent particle system using ray marching and signed distance sphere\n// \n\nconst float kMinStep = 0.05;\n\nfloat SDToPlane ( in vec4 plane, in vec3 point )\n{    \n    \n    return dot (plane.xyz, point ) + plane.w;      \n}\n\nfloat SDToSphere( in vec4 sphere, in vec3 point )\n{    \n    vec3 vDelta = point - sphere.xyz;\n    return length ( vDelta ) - sphere.w;      \n}\n\nfloat smin( float a, float b )\n{\n    float k = 0.5;\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\nfloat sceneOpaque ( vec3 pos )\n{\n    float r;\n    \n    r = SDToPlane( vec4(0.0,1.0,-1.0,5.0), pos );\n        \n    const int nSphere = 11;\n    for ( int i = 0; i<nSphere; i++)\n    {\n        float angle = float( i ) / float(nSphere) * 3.14 * 2.0;\n        r = smin ( r, SDToSphere(vec4(cos(iTime*2.0 + angle)*2.0,sin(iTime*2.0 + angle) * 2.0,4.5,1.0+angle*float(i)*0.01), pos ) );\n    }\n    \n    r = smin ( r, SDToSphere(vec4(-cos(iTime*5.0)*0.5,-sin(iTime*7.0)*0.5,5.0,1.0), pos ) );\n    return smin ( r, SDToSphere(vec4(cos(iTime*3.0)*0.25,sin(iTime*3.0)*0.25,4.5,1.0), pos ) ); \n    \n}\n\nfloat sceneTransparent ( vec3 pos )\n{\n    float r;\n    \n    r = SDToSphere(vec4(0.5,1.0+cos(iTime),3.0,1.0), pos );        \n    r = r + smin ( SDToSphere(vec4(-0.5,0.0+cos(iTime*2.0),3.0,3.0), pos), 0.0);\n    r = r + smin ( SDToSphere(vec4(-0.0+sin(iTime*2.5),1.0+sin(iTime*3.0),2.0,1.0), pos), 0.0);    \n    r = r + smin ( SDToSphere(vec4(-0.5+cos(iTime*1.7),-1.0+cos(iTime*7.0),3.3,2.0), pos), 0.0);\n    r = r + smin ( SDToSphere(vec4(-0.25+sin(iTime*1.1),0.5+sin(iTime*8.0),2.7,1.0), pos), 0.0);    \n    r = r + smin ( SDToSphere(vec4(-1.0+sin(iTime*1.5),0.2+cos(iTime*1.5),3.2,2.0), pos), 0.0);\n    r = r + smin ( SDToSphere(vec4(-0.5+sin(iTime*0.23),0.0+cos(iTime*0.23),3.3,1.0), pos), 0.0);\n    r = r + smin ( SDToSphere(vec4(-0.25+sin(iTime*1.7),0.3+cos(iTime*1.7),3.4,1.0), pos), 0.0);\n    r = r + smin ( SDToSphere(vec4(0.25+sin(iTime*2.1),0.0+cos(iTime*2.1),3.5,9.0), pos), 0.0);\n       \n    return r;\n}\n\nvec3 SDToNormalTransparent( in vec3 pos )\n{    \n\tvec3 delta = vec3( 0.0001, 0.0, 0.0 );\n    vec3 normal;\n\t\n\tnormal.x = sceneTransparent(pos+delta.xyy) - sceneTransparent(pos-delta.xyy);\n\tnormal.y = sceneTransparent(pos+delta.yxy) - sceneTransparent(pos-delta.yxy);\n\tnormal.z = sceneTransparent(pos+delta.yyx) - sceneTransparent(pos-delta.yyx);\n    \n\treturn normalize(normal);\n}\n\nvec3 SDToNormal( in vec3 pos )\n{    \n\tvec3 delta = vec3( 0.0001, 0.0, 0.0 );\n    vec3 normal;\n\t\n\tnormal.x = sceneOpaque(pos+delta.xyy) - sceneOpaque(pos-delta.xyy);\n\tnormal.y = sceneOpaque(pos+delta.yxy) - sceneOpaque(pos-delta.yxy);\n\tnormal.z = sceneOpaque(pos+delta.yyx) - sceneOpaque(pos-delta.yyx);\n    \n\treturn normalize(normal);\n}\n\nvoid mainImage( out vec4 outColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    \n    vec4 plane = vec4(0.0,1.0,-0.5,4.0);\n    plane.xyz = normalize(plane.xyz);\n    \n    vec4 pBackground = vec4(0.0,0.0,-1.0,20.0);\n    pBackground.xyz = normalize(pBackground.xyz);\n    \n    vec3 lightPos = vec3 ( 1.0, 3.0, 2.0 );    \n    \n    vec3 ViewPos = vec3 (sin(iTime)*1.0,1.0,cos(iTime)*2.0);\n    vec3 ray = vec3(uv*2.0-1.0,9.0);\n    ray.y += sin(iTime)*0.5;\n    ray = ray * vec3(16.0,9.0,1.0); // Aspect ratio\n    ray = normalize(ray);\n    \n    vec4 sum = vec4(0.0,0.0,0.0,0.0);    \n    const float nearPlane = 2.0;\n    const float farPlane  = 20.0;\n    vec3  orgRay = ray;\n    vec3  orgRayA = orgRay;\n    vec4  LightColor = vec4(1.0,0.7,0.5,1.0);\n    \n    \n    float rayStep = farPlane;\n    \n    const int kSteps = 16;\n    const float kfSteps = float(kSteps);\n    const float lightOneOverRange = 1.0 / 10.0; \n        \n    float signedDistance;\n    // Ray march opaque scene\n    for (int i=1; i<kSteps; i++ )\n    {\n        vec3 pos = ray + ViewPos;                     \n\n        signedDistance = sceneOpaque ( pos );               \n\n        pos = pos + orgRay * min(signedDistance,0.0);\n\n        // Compute lighting\n        vec3 normal = SDToNormal ( pos );\n        vec3 lightDir = normalize( lightPos - pos);\n        float attenuation = min ( length ( pos - lightPos ) * lightOneOverRange, 1.0 );\n        attenuation = 1.0 - attenuation * attenuation;\n        float diffuse = max ( dot ( normal, lightDir ) * attenuation, 0.1 ) ; \n\n        sum.rgba += (signedDistance<=0.0?1.0:0.0)*vec4(diffuse,diffuse,diffuse, 1.0)*LightColor;     \n\n        signedDistance = (signedDistance<=0.0)?1.0:signedDistance;\n        \n        float greyLevel = ( sin(pos.x*cos(pos.y)*5.0) + 1.0 );\n        \n        sum.rgb *= vec3 ( greyLevel,greyLevel,greyLevel );\n        \n        if ( sum.a>=1.0 ) break;       \n        \n        ray = ray + orgRay * max ( signedDistance*1.33, kMinStep );       \n    }\n        \n    vec3 pos = vec3(0.0,0.0,0.0);   \n    float start = sceneTransparent ( orgRay + ViewPos );    \n    float rayLen = length(ray)-start;       \n    vec4 sumA = vec4(0.0,0.0,0.0,0.0);\n    float lastd = 0.0;\n    \n    // Tansparent scene\n    for (int i=1; i<kSteps; i++ )\n    {\n        vec3 lightDir;\n        float ni = float(i)/kfSteps;\n        pos = normalize(ray) * ( start + ni * ni * rayLen ) + ViewPos;\n                \n        float d;\n        vec3 normal;\n        float lRange = 50.0;                \n        \n        d = sceneTransparent ( pos );\n         \n        normal = SDToNormalTransparent ( pos );\n        lightDir = normalize( lightPos - pos); \n\n        float att = min ( length ( pos - lightPos ) / lRange, 1.0 );\n        att = 1.0 - att * att;\n        \n        // Front lighting\n        float diffuse = max ( (dot ( normal, lightDir ) ) * att, 0.0 ) ;  \n        \n        // back lighting for fake transluency\n        diffuse += max ( -(dot ( normal, lightDir ) ) * att * 0.33, 0.0 ) ;  \n\n        float dd = abs ( min(d,0.0) - min(lastd,0.0)  );        \n        lastd = d;\n        \n        float density = 0.15;\n                \n        dd -= min((sumA.a-dd*density)*density,0.0);\n        \n        vec4 color = vec4(1.0,0.5,0.5,1.0);\n        sumA.rgba += vec4(dd*diffuse,dd*diffuse,dd*diffuse*uv.x, dd*density*uv.y) * color * LightColor; \n\n        if ( sumA.a >= 1.0 ) break;\n        \n        ray = ray + orgRay;         \n    }\n    \n    // Blend alpha colors\n    sum = sum*(1.0-sumA.a) + sumA*sumA.a;\n    \n\toutColor = vec4(sum);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XtyXRR.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[118, 118, 168, 168, 231], [233, 233, 284, 284, 375], [377, 377, 409, 409, 521], [523, 523, 555, 555, 1108], [1110, 1110, 1147, 1147, 2023], [2025, 2025, 2068, 2068, 2402], [2404, 2404, 2436, 2436, 2740], [2742, 2742, 2798, 2798, 6290]], "test": "valid"}
{"id": "XtyXz1", "name": "Thing spawner (tweaked)", "author": "MobileForks01", "description": "forking to tweak and optimize on mobile\noriginal : https://www.shadertoy.com/view/XdyGRw", "tags": ["raymarching"], "likes": 5, "viewed": 530, "published": "Public API", "date": "1482742313", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float sdSphere( vec3 p, float s )\n{\n  return length(p)-s;\n}\n\nfloat lengthRound(vec3 p)\n{\n\tfloat n = 1.7;\n\treturn pow(pow(p.x,n) + pow(p.y,n) + pow(p.z,n), 1.0/n);\n}\n\nfloat smin( float a, float b, float k )\n{\n    float res = exp( -k*a ) + exp( -k*b );\n    return -log( res )/k;\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  \n  //float lengthRounded = lengthRound(max(d,0.0));\n  //return min(max(d.x,max(d.y,d.z)),0.0) + lengthRounded;\n  return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\nvec3 repeatPos(vec3 p, vec3 c)\n{\n\treturn mod(p,c)-.5 * c;\n}\n\nfloat getDistance(vec3 position)\n{\t\n    vec3 pos = vec3\n        (\n            (position.x + 5.0 * sin(iTime)) - 2.0,\n            position.y + 5.0 * cos(iTime),\n            position.z - 1.5\n        );\n    \n    vec3 pos2 = vec3\n        (\n            (position.x + 5.0 * sin(iTime)) - 2.0,\n            position.y + 5.0 * cos(iTime),\n            position.z - 1.5\n        );\n    vec3 pos3 = vec3\n        (\n            position.x + 45.,\n            position.y - 52. - iTime * 5.,\n            position.z + 55.0\n        );\n    //vec3 pos3 = vec3(position.x + 1.8 * sin(iTime - 3.3) + 0.2, position.y + 1.8 * cos(iTime - 3.3), position.z - 0.5);\n  \n    vec3 floorPos = vec3\n        (\n            position.x,\n            position.y + 5.0,\n            position.z\n        );\n    \n    vec3 wallPos = vec3\n        (\n            position.x,\n            position.y + 5.0,\n            position.z - 25.\n        );\n    \n    pos3 = repeatPos(pos3, vec3(15.,25.,15.));\n    \n    //float dis1 = sdSphere(pos, 2.0);\n    \n    //float dis2 = sdSphere(pos2, 1.33);\n    //float dis2 = sdBox(pos2, vec3(1.5, 1.5, 1.5));\n    float floorDis = sdBox(floorPos, vec3(300, 1, 300));\n    float wallDis = sdBox(wallPos, vec3(300, 100, 1));\n    \n    \n    \n    float sphereDis = sdSphere(pos3, 1.);\n    //float sphereDis = sdBox(pos3, vec3(1., 1., 1.));\n  \n    \n    // distance = smin(dis1, dis2, 1.0);\n    float distance = smin(floorDis, sphereDis, 1.0);\n    \n    distance = smin(distance, floorDis, 0.5);\n    distance = min(distance, wallDis);\n   \n  \n    \n    //return dis1;\n    return distance;\n    //return dis3;\n    \n    \n    //return sdSphere(pos, 2.0);\n    //Repeat shape\n\t//vec3 repPos = repeatPos(position, vec3(5.0,20.0,4.5));\n    \n    //Draw cubes\n\t//return sdBox(repPos, vec3(1.,1.,1.));\n\t\n    //Draw spheres\n\t//return sdSphere(repPos, 1.0);\n}\n\nvec4 getColor(vec3 position)\n{\n\tfloat e = 0.001;\n\tfloat f0 = getDistance(position);\n\t\n    //Approximate the normal by stepping a minimal amount in each of the axes' direction\n\tfloat fx = getDistance(vec3(position.x + e, position.y, position.z));\n\tfloat fy = getDistance(vec3(position.x, position.y + e, position.z));\n\tfloat fz = getDistance(vec3(position.x, position.y, position.z + e));\n\t\n\t\n\t\n\tvec3 normal = normalize(vec3(fx - f0, fy - f0, fz - f0));\n\tvec3 lightPosition = vec3\n\t\t(\n\t\t\t0.0, //+ 12.0*sin(iTime*1.0),\n\t\t\t20.0, //+ 12.0*sin(iTime*2.0),\n            -5.0\n            //iTime * 20.0\n            \n            //-1.0 - sin(iTime) * 2.0\n\t\t\t//280.0 + 300.0*sin(iTime*1.0) //Make the light move on the z axis\n\t\t\t//iTime * 5.0 + 100.0\n\t\t);\n\tvec3 lightDir = normalize(lightPosition - position);\n    /*\n\tvec4 lightColor = vec4\n        (\n            (sin(iTime * 0.1) + 0.5)/ 25.0 + 0.1,\n            (sin(iTime / 1.1) + 1.5)/ 25.0 + 0.1,\n            (cos(iTime * 0.1) + 0.5)/ 25.0 + 0.1,\n            //0.5 * tan(iTime),\n            //0.5 - 0.5 * sin(iTime),\n            //0.5 - 0.5 * cos(iTime),\n            0.2);\n    */\n    vec4 lightColor = vec4\n        (\n            0.15,\n            0.2,\n            0.3,\n            //0.5 * tan(iTime),\n            //0.5 - 0.5 * sin(iTime),\n            //0.5 - 0.5 * cos(iTime),\n            0.2);\n\tvec4 lightIntensity = lightColor * dot(normal, lightDir);\n\tfloat reflectance = 0.5;\n\t\n\tfloat lightDistance = length(position-lightPosition);\n    \n    //Hacky but pretty good looking light intensity diminishing over distance\n\t//float distanceIntensity = (1.0 / (pow(lightDistance / 100.0, 1.1))); \n    float distanceIntensity = (5.0 / (pow(lightDistance / 25.0, 1.0001))); \n\t\n\treturn reflectance * lightIntensity * (distanceIntensity);\n\t\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //Moving eye position, bugs on some weaker hardware and just shows grey as mentioned in the omments\n    //vec3 eye = vec3(0, 3, iTime * 20.0 - 50.0);\n    \n    //Still eye\n\tvec3 eye = vec3(0, 0, -45);\n\t//eye.z = -1.0*sin(iTime);\n    vec3 up = vec3(0, 1, 0);\n    vec3 right = vec3(1, 0, 0);\n    \n    //Epsilon for when we are close enough to a surface to decide the surface is right here\n    float epsilon = 0.1;\n    float maxDistance = 10000.0;\n\n\t//Normalized device coordinates\n\tvec2 ndcXY = -1.0 + 2.0 * fragCoord.xy / iResolution.xy;\n\t\n\t// aspect ratio\n\tfloat aspectRatio = iResolution.x / iResolution.y;\n\t\n\t// scaled XY which fits the aspect ratio\n\tvec2 uv = ndcXY * vec2( aspectRatio, 1.0 );\n\t//uv.y += (0.07 * sin(uv.x + iTime*4.0));\n\n\t\n    \n    //Variables needed for ray marching this pixel\n    float focalLength = 1.0;\n    vec3 forward = normalize(cross(right, up));\n    \n    vec3 planePos = right * uv.x + up * uv.y;\n\t\n    vec3 pImagePlane = eye + forward * focalLength + planePos;\n    vec3 rayDirection = normalize(pImagePlane - eye);\n\n\t// Sky color\n    vec4 color = vec4\n\t\t(\n\t\t\t0.30,\n\t\t\t0.30,\n\t\t\t0.30,\n\t\t\t1\n\t\t); \n\n    float t = 0.0;\n    const float maxSteps = 512.0;\n    for(float i = 0.0; i < maxSteps; ++i)\n    {\n        vec3 p = pImagePlane + rayDirection * t;\n\t\tfloat d = getDistance(p);\n\t\tif(d > maxDistance) {break;}\n        if(d < epsilon)\n        {\n\t\t\n            //Fixed color, no shading\n\t\t\t//color = vec4(i*0.1+0.1,0.5,0,1);\n            \n            //Shade this surface\n\t\t\tcolor = getColor(p);\n            break;\n        }\n\t\t//March forward by the distance to the closest surface to current point in space\n        t += d;\n    }\n\n    fragColor = color;\n}\n\nvoid mainVR( out vec4 fragColor, in vec2 fragCoord, in vec3 fragRayOri, in vec3 fragRayDir)\n{    \n    //Still eye\n    vec3 eye = vec3(0, 0.0, -45);\n\t//vec3 eye = vec3(0, 0, -15);\n\t//eye.z = -1.0*sin(iTime);\n    vec3 up = vec3(0, 1, 0);\n    vec3 right = vec3(1, 0, 0);\n    //Epsilon for when we are close enough to a surface to decide the surface is right here\n    float epsilon = 0.1;\n    float maxDistance = 100000.0;\n\n\t//Normalized device coordinates\n\tvec2 ndcXY = -1.0 + 2.0 * fragCoord.xy / iResolution.xy;\n\t\n\t// aspect ratio\n\tfloat aspectRatio = iResolution.x / iResolution.y;\n\t\n\t// scaled XY which fits the aspect ratio\n\tvec2 uv = ndcXY * vec2( aspectRatio, 1.0 );\n\t//uv.y += (0.07 * sin(uv.x + iTime*4.0));\n\n\t\n    \n    //Variables needed for ray marching this pixel\n    float focalLength = 1.0;\n    vec3 forward = normalize(cross(right, up));\n    \n    vec3 planePos = right * uv.x + up * uv.y;\n\t\n    vec3 pImagePlane = eye + forward * focalLength + planePos;\n    //vec3 rayDirection = normalize(pImagePlane - eye);\n    vec3 rayDirection = fragRayDir;\n\n\t// Sky color\n    vec4 color = vec4\n\t\t(\n\t\t\t0.30,\n\t\t\t0.30,\n\t\t\t0.30,\n\t\t\t1\n\t\t); \n\n    float t = 0.0;\n    const float maxSteps = 512.0;\n    for(float i = 0.0; i < maxSteps; ++i)\n    {\n        vec3 p = pImagePlane + rayDirection * t;\n\t\tfloat d = getDistance(p);\n\t\tif(d > maxDistance) {break;}\n        if(d < epsilon)\n        {\n\t\t\n            //Fixed color, no shading\n\t\t\t//color = vec4(i*0.1+0.1,0.5,0,1);\n            \n            //Shade this surface\n\t\t\tcolor = getColor(p);\n            break;\n        }\n\t\t//March forward by the distance to the closest surface to current point in space\n        t += d;\n    }\n\n    fragColor = color;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XtyXz1.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 35, 35, 59], [61, 61, 88, 88, 164], [166, 166, 207, 207, 278], [280, 280, 311, 311, 511], [513, 513, 545, 545, 572], [574, 574, 608, 608, 2390], [2392, 2392, 2422, 2422, 4170], [4172, 4172, 4229, 4404, 5910], [5912, 5912, 6005, 6025, 7601]], "test": "valid"}
