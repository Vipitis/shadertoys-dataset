{"id": "4dGBDV", "name": "Ray marching practice 3", "author": "lnae", "description": "Blobby things to try some simple shading and colors", "tags": ["3d", "raymarching"], "likes": 9, "viewed": 188, "published": "Public", "date": "1530448420", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define STEPS 64.\n#define PI 3.14159\n#define EPS 0.0001\n#define EPSN 0.001\n\nmat2 rot(float a){\n\treturn mat2(cos(a), -sin(a), sin(a), cos(a));\n}\n\nfloat distSphere(vec3 pos, float radius){\n\treturn length(pos) - radius;\n}\n\nfloat distScene(in vec3 pos, out int material){\n\t\n    material = 0;\n    float minDist, dist;\n    \n    pos.xz = rot(0.5 * iTime + sin(0.5 * iTime)) * pos.xz;\n    pos.yz = rot(0.5 * iTime) * pos.yz;\n    pos.xy = rot(0.5 * iTime) * pos.xy;\n    \n    //blobby shapes\n    float deform = 0.0075 * (sin(50. * pos.y) + sin(50. * pos.x) + sin(50. * pos.z));\n    minDist = distSphere(pos, 0.02 + 0.07 * (1. + sin(iTime))) + deform;\n    dist = distSphere(pos - vec3(0.4, 0., 0.), 0.02 + 0.07 * (1. + sin(iTime + 2. * PI / 3.))) + deform;\n    if(dist < minDist){\n    \tminDist = dist;\n        material = 1;\n    }\n    dist = distSphere(pos - vec3( -0.4, 0., 0.), 0.02 + 0.07 * (1. + sin(iTime + 4. * PI / 3.))) + deform;\n    if(dist < minDist){\n    \tminDist = dist;\n        material = 2;\n    }\n    \n    return minDist;\n}\n\nvec3 getNormal(vec3 pos){\n\tint m;\n    return normalize(vec3(distScene(pos + vec3(EPSN, 0., 0.), m) - distScene(pos - vec3(EPSN, 0., 0.), m),\n                           \tdistScene(pos + vec3(0., EPSN, 0.), m) - distScene(pos - vec3(0., EPSN,0.), m),\n                           \tdistScene(pos + vec3(0., 0.,EPSN), m) - distScene(pos - vec3(0., 0., EPSN), m)\n                       \t)\n                    );\n}\n\nvec3 render(vec2 uv){\n    \n    vec3 eye = vec3(0., 0., 4.);\n    vec3 ray = normalize(vec3(uv, 1.) - eye);\n    \n    //background\n    vec3 col = vec3(0.2, 0.2, 0.25);\n    \n    //raymarch\n    float step, dist;\n    int material;\n    vec3 pos = eye;\n    bool hit = false;\n    for(step = 0.; step < STEPS; step++){\n    \tdist = distScene(pos, material);\n        if(abs(dist) < EPS){\n            hit = true;\n        \tbreak;\n        }\n        pos += ray * dist;\n    }\n    \n    //normal\n    vec3 normal = getNormal(pos);\n    \n    //surface color\n    vec3 baseColor;\n    float colorVariation = 0.5 + 0.5 * sin(3. * sin(3. * (sin(30. * pos.y) + sin(30. * pos.x) + sin(30. * pos.z))));\n    float shine = 5. + 100. * (1. - colorVariation);\n\n    colorVariation = 0.3 + 0.5 * colorVariation;\n   \tcolorVariation += step / STEPS;\n\n    if(material == 0){\n\t\tbaseColor = vec3(colorVariation, 0.33, 0.66);\n    }else if(material == 1){\n    \tbaseColor = vec3(colorVariation, 0.66, 0.33);\n    }else if(material == 2){\n    \tbaseColor = vec3(0.33, colorVariation, 0.66);\n    }\n    \n    //shading\n    vec3 light0 = vec3(2., 2., 0.);\n    float lintensity0 = 0.8;\n    vec3 lcolor0 = vec3(1., 1., 0.6);\n    vec3 light1 = vec3(2., -2., 0.);\n    float lintensity1 = 0.7;\n    vec3 lcolor1 = vec3(0.9, 1., 1.);\n    vec3 light2 = vec3(2., 0., 0.);\n    float lintensity2 = 0.5;\n    vec3 lcolor2 = vec3(1., 0.6, 1.);\n    \n    light0.xz = rot( 2. * iTime) * light0.xz;\n    light1.xz = rot( 2. * iTime + 2. * PI / 3.) * light1.xz;\n    light2.xz = rot( 2. * iTime + 4. * PI / 3.) * light2.xz;\n    \n    if(hit){\n    \tvec3 l = normalize(light0 - pos);\n    \tvec3 e = normalize(eye - pos);\n    \tvec3 r = reflect(-l, normal);\n    \n    \tcol = lintensity0 * vec3(max(dot(normal, l), 0.)) * baseColor * lcolor0; //diffuse\n    \tcol += lintensity0 * vec3(pow(max(dot(r, e), 0.), shine)) * lcolor0; //specular\n        \n        l = normalize(light1 - pos);\n        r = reflect(-l, normal);\n        col += lintensity1 * vec3(max(dot(normal, l), 0.)) * baseColor * lcolor1; //diffuse\n    \tcol += lintensity1 * vec3(pow(max(dot(r, e), 0.), shine)) * lcolor1; //specular\n        \n        l = normalize(light2 - pos);\n        r = reflect(-l, normal);\n        col += lintensity2 * vec3(max(dot(normal, l), 0.)) * baseColor * lcolor2; //diffuse\n    \tcol += lintensity2 * vec3(pow(max(dot(r, e), 0.), shine)) * lcolor2; //specular\n        \n        col += 0.2 * baseColor; //ambient\n    }\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy)/iResolution.x;\n    uv = rot(0.1 * iTime) * uv;\n    vec3 col = render(uv);\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4dGBDV.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[76, 76, 94, 94, 143], [145, 145, 186, 186, 218], [220, 220, 267, 267, 1025], [1027, 1027, 1052, 1052, 1433], [1435, 1435, 1456, 1456, 3879], [3881, 3881, 3938, 3938, 4094]], "test": "untested"}
{"id": "4dGfDK", "name": "Meta Matter", "author": "leon", "description": "One selected sketch from days of improvisation ", "tags": ["sdf"], "likes": 25, "viewed": 434, "published": "Public", "date": "1530405330", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n// leon/ponk 01/07/2018\n// a lot of lines are from the community\n\nconst float steps = 100.;\nconst float far = 20.;\nconst float count = 8.;\n\nvec3 cameraPos = vec3(4);\nvec3 cameraTarget = vec3(0);\nconst float fov = 3.;\n\nvec3 lightPos = vec3(1, 1, 1);\nvec3 ambient = vec3(.5);\nvec3 light = vec3(.5);\nvec3 specular = vec3(0);\nfloat specularSharpness = 10.;\nvec3 glow = vec3(0);\nfloat glowSharpness = .5;\n\n#define PI 3.14159\n#define repeat(p,r) (mod(p,r)-r/2.)\n#define sdist(p,r) (length(p)-r)\n#define saturate(p) clamp(p,0.,1.)\nmat2 rot (float a) { float c = cos(a), s = sin(a); return mat2(c,-s,s,c); }\nfloat smin (float a, float b, float r) { float h = clamp(.5+.5*(b-a)/r, 0., 1.); return mix(b, a, h)-r*h*(1.-h); }\nvec3 look (vec3 eye, vec3 target, vec2 uv) {\n\tvec3 forward = normalize(target-eye);\n\tvec3 right = normalize(cross(forward, vec3(0,1,0)));\n\tvec3 up = normalize(cross(right, forward));\n\treturn normalize(forward * fov + right * uv.x + up * uv.y);\n}\n\nfloat sdf (vec3 p) {\n\tfloat scene = 10.;\n    float shape = 10.;\n\tfloat breath = sin(iTime - length(p)*4. + atan(p.y, p.z));\n\tfloat thin = .05;\n\tfloat range = .4 + .1 * breath;\n\tfloat height = .5 - .5 * breath;\n\tfloat smoo = .2 + .1 * breath;\n\tfor (float i = count; i > 0.; --i) {\n\t\tfloat r = i / count;\n\t\tr *= r;\n\t\tp.xz = abs(p.xz) - range * r;\n\t\tp.xz *= rot(+.5);\n\t\tp.yz *= rot(-.5);\n\t\tp.yx *= rot(+r*breath*.1+2.);\n\t\tshape = sdist(p.yz, thin*r);\n\t\tshape = max(abs(p.x)-height*r, shape);\n\t\tscene = smin(scene, shape, smoo * r);\n\t}\n\treturn scene;\n}\n\nvec3 getNormal (vec3 p) {\n    vec2 e = vec2(.001,0);\n    return normalize(vec3(sdf(p+e.xyy)-sdf(p-e.xyy),\n                          sdf(p+e.yxy)-sdf(p-e.yxy),\n                          sdf(p+e.yyx)-sdf(p-e.yyx)));\n}\n\nvec3 raymarching (vec3 eye, vec3 ray)\n{\n    vec4 hit = vec4(0);\n\tfloat total = .001;\n\tfor (float i = steps; i >= 0.; --i) {\n\t\tfloat dist = sdf(eye + ray * total);\n\t\tif (dist < .001 * total || total > far) {\n\t\t\thit.xyz = eye + ray * total;\n\t\t\thit.w = i/steps;\n\t\t\tbreak;\n\t\t}\n\t\tdist *= .5;\n\t\ttotal += dist;\n\t}\n\n\tvec3 pos = hit.xyz;\n\tvec3 normal = getNormal(pos);\n\tvec3 view = normalize(cameraPos-pos);\n\tvec3 lightDir = normalize(lightPos);\n\tfloat lightIntensity = clamp(dot(lightDir, normal),0.,1.);\n\tfloat specularIntensity = saturate(pow(max(0., dot(reflect(-lightDir, normal), view)), specularSharpness));\n\tfloat glowIntensity = pow(abs(1.-abs(dot(normal, view))), glowSharpness);\n\n\tvec3 color = ambient + light * lightIntensity + specular * specularIntensity + glow * glowIntensity;\n\tcolor *= hit.w;\n\tcolor *= step(length(cameraPos-pos), far);\n\n\treturn saturate(color);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    vec2 mouse = iMouse.xy / iResolution.xy;\n    cameraPos.yz *= rot((mouse.y*2.-1.)*step(.1, iMouse.z));\n    cameraPos.xz *= rot((mouse.x*2.-1.)*step(.1, iMouse.z));\n\tvec3 ray = look(cameraPos, cameraTarget, uv);\n    fragColor = vec4(raymarching(cameraPos, ray), 1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4dGfDK.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 525, 545, 545, 600], [601, 601, 641, 641, 715], [716, 716, 760, 760, 961], [963, 963, 983, 983, 1511], [1513, 1513, 1538, 1538, 1728], [1730, 1730, 1769, 1769, 2602], [2604, 2604, 2661, 2661, 2990]], "test": "untested"}
{"id": "4dKBWc", "name": "Merging Particles", "author": "tlambert", "description": "My first raymarching shader.", "tags": ["3d", "raymarching"], "likes": 8, "viewed": 157, "published": "Public", "date": "1530830947", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const int STEP_NB = 128;\nconst float DIST_ESPILON = 1e-4;\nconst float MAX_DIST = 100.;\n\nconst float DERIV_EPSI = 1e-4;\n\nconst float FIELD_OF_VIEW = 120.;\n\nconst float M_PI = 3.1415;\n\nfloat rand(float n){return fract(sin(n) * 43758.5453123);}\nfloat rand(vec2 n) { \n\treturn fract(sin(dot(n, vec2(12.9898, 4.1414))) * 43758.5453);\n}\nfloat noise(vec2 n) {\n\tconst vec2 d = vec2(0.0, 1.0);\n  vec2 b = floor(n), f = smoothstep(vec2(0.0), vec2(1.0), fract(n));\n\treturn mix(mix(rand(b), rand(b + d.yx), f.x), mix(rand(b + d.xy), rand(b + d.yy), f.x), f.y);\n}\n\nfloat sphereDist(vec3 center, float radius, vec3 pos) {\n \treturn length(center-pos) - radius;\n}\n\n//Benjamin Keinert, Matthias Innmann, Michael Sänger, and Marc Stamminger. 2015. Spherical fibonacci mapping. ACM Trans. Graph. 34, 6, Article 193 (October 2015), 7 pages.\nvec3 sphericalFibonacciMapping(float i, float n) {\n    const float PHI = sqrt(5.)*0.5 + 0.5;\n    float phi = 2.*M_PI*(i*(PHI-1.)- floor(i*(PHI-1.)));\n    float cosTheta = 1. - (2.*i + 1.)*1./n;\n\n    float sinTheta = sqrt(clamp(1. - cosTheta*cosTheta,0.,1.));\n    return vec3(\n        cos(phi)*sinTheta,\n        sin(phi)*sinTheta,\n        cosTheta);\n}\n\n\nfloat smoothMin(float a, float b, float k) {\n        float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\nfloat evalSceneDist(vec3 pos) {\n    float min_dist = MAX_DIST;\n    \n    // Main Particle\n    const int s_nb = 16;\n    for(int i=0; i<s_nb; i++){\n        vec3 c = sphericalFibonacciMapping(float(i),float(s_nb));\n        const float fc = 1.7;\n        const float fr = 1.3;\n        float tc = mod((iTime+fc*rand(float(i))),fc) / fc;\n        float tr = mod((iTime+fr*rand(float(i*i))),fr) / fr;\n    \tmin_dist = smoothMin(min_dist,sphereDist(abs(sin(tc*M_PI))*c,  abs(sin(tr*M_PI))*.5+.5, pos),.2);\n    }\n    \n    // Small Particles\n    const int ss_nb = 64;\n    for(int i=0; i<ss_nb; i++){\n        float d = rand(float(i))*5.+5.;\n    \tconst float f = 3.;\n        float t0 = mod((iTime+f*rand(float(i))),f) / f;\n        float t = 1.-t0;\n        vec3 c = sphericalFibonacciMapping(float(i),float(ss_nb));\n    \tmin_dist = smoothMin(min_dist,sphereDist(c*d*t,  (1.-t)*0.1, pos),0.4);\n    }\n    \n    \n    return min_dist;\n}\n\nvec3 evalSceneNormal(vec3 pos) {\n    return normalize(vec3(\n        evalSceneDist(vec3(pos.x+DERIV_EPSI,pos.yz))-evalSceneDist(vec3(pos.x-DERIV_EPSI,pos.yz)),\n        evalSceneDist(vec3(pos.x,pos.y+DERIV_EPSI,pos.z))-evalSceneDist(vec3(pos.x,pos.y-DERIV_EPSI,pos.z)),\n        evalSceneDist(vec3(pos.xy,pos.z+DERIV_EPSI))-evalSceneDist(vec3(pos.xy,pos.z-DERIV_EPSI))\n    ));\n}\n\nvec3 rayDirection( vec2 frag_coord) {\n    vec2 xy = frag_coord - iResolution.xy/2.;\n    float z = iResolution.y /tan(radians(FIELD_OF_VIEW)/ 2.0);\n    return normalize(vec3(xy,-z));\n}\n\nfloat rayMarching(vec3 start, vec3 ray) {    \n    float depth = 0.f;\n    for(int s=0;s<STEP_NB; s++) {\n        float dist = evalSceneDist(start+depth*ray);\n        if(dist < DIST_ESPILON)\n            return depth;\n        depth += dist;\n        if(depth > MAX_DIST)\n            return -1.;\n    }\n    return -1.;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 cam = vec3(0.,0.,4.);\n    vec3 ray = rayDirection(fragCoord);\n    \n    float dist = rayMarching(cam,ray);\n    \n    if (dist < 0.f) {\n        float d = length(ray.xy);\n        const float f = 2.;\n        float noise = noise(ray.xy+iTime*f)*0.2;\n        fragColor = vec4(0.5*(1.- d)+noise,0.,0.,1.);\n    } else {  \n        vec3 pos = cam+ray*dist;\n        vec3 nor = evalSceneNormal(pos);\n        float f = abs(dot(nor,ray));\n        \n            \n        fragColor = vec4(max(f,(0.3-f)*10.),\n                         max(0.,max((0.3-f)*10.,10.*(f-0.9))),\n                         max(0.,max((0.3-f)*10.,10.*(f-0.9))),\n                             1.0);\n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4dKBWc.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[183, 183, 203, 203, 241], [242, 242, 262, 262, 329], [330, 330, 351, 351, 549], [551, 551, 606, 606, 646], [648, 821, 871, 871, 1171], [1174, 1174, 1218, 1218, 1315], [1317, 1317, 1348, 1348, 2231], [2233, 2233, 2265, 2265, 2608], [2610, 2610, 2647, 2647, 2793], [2795, 2795, 2836, 2836, 3108], [3110, 3110, 3167, 3167, 3836]], "test": "untested"}
{"id": "4dKfDV", "name": "FootTorus", "author": "iq", "description": "Torus and hexagons", "tags": ["3d", "torus", "hexagon"], "likes": 25, "viewed": 1060, "published": "Public API", "date": "1530592670", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// The MIT License\n// Copyright © 2018 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n\n#define AA 4   // make this 1 is your machine is too slow\n\n\n//------------------------------------------------------------------\n\nconst vec2 torus = vec2(0.5,0.2);\n\nfloat map( in vec3 p )\n{\n    return length( vec2(length(p.xz)-torus.x,p.y) )-torus.y;\n}\n\n// gradient/derivative of map (common factors removed)\nvec3 dmap( in vec3 p )\n{\n    return p*(1.0 - vec3(1,0,1)*torus.x/length(p.xz));\n  //return p*(dot(p,p)-torus.y*torus.y-torus.x*torus.x*vec3(1.0,-1.0,1.0));\n}\n\nvec2 castRay( in vec3 ro, in vec3 rd )\n{\n    // plane\n    float tmax = (-torus.y-ro.y)/rd.y;\n   \n    // torus\n    float t = 1.0;\n    float m = 2.0;\n    for( int i=0; i<100; i++ )\n    {\n\t    float precis = 0.0004*t;\n\t    float res = map( ro+rd*t );\n        if( res<precis || t>tmax ) break;\n        t += res;\n    }\n\n    if( t>tmax ) { t=tmax; m=1.0; }\n    return vec2( t, m );\n}\n\n\nfloat calcSoftshadow( in vec3 ro, in vec3 rd )\n{\n\tfloat res = 1.0;\n    float t = 0.02;\n    for( int i=0; i<12; i++ )\n    {\n\t\tfloat h = map( ro + rd*t );\n        res = min( res,18.0*h/t );\n        t += clamp( h, 0.05, 0.10 );\n        if( res<0.005 || t>1.0 ) break;\n    }\n    return clamp( res, 0.0, 1.0 );\n}\n\nvec3 hexagon_pattern( vec2 p ) \n{\n\tvec2 q = vec2( p.x*2.0*0.5773503, p.y + p.x*0.5773503 );\n\t\n\tvec2 pi = floor(q);\n\tvec2 pf = fract(q);\n\n\tfloat v = mod(pi.x + pi.y, 3.0);\n\n\tfloat ca = step(1.0,v);\n\tfloat cb = step(2.0,v);\n\tvec2  ma = step(pf.xy,pf.yx);\n\t\n\treturn vec3( pi + ca - cb*ma, dot( ma, 1.0-pf.yx + ca*(pf.x+pf.y-1.0) + cb*(pf.yx-2.0*pf.xy) ) );\n}\n\nvec3 render( in vec3 ro, in vec3 rd )\n{ \n    vec3  col = vec3(0.0);\n    vec2  res = castRay(ro,rd);\n    vec3  pos = ro + rd*res.x;\n    vec3  nor = vec3(0.0,1.0,0.0);\n    float occ = 1.0;\n\n    // plane\n    if( res.y<1.5 )\n    {\n        // fake occlusion\n        occ = smoothstep(0.0,0.42, abs(length(pos.xz)-torus.x) );\n        // texture\n        #if 0\n        vec3  h = hexagon_pattern(pos.xz*4.);\n        float f = mod(h.x+2.0*h.y,3.0)/2.0 ;\n        #else\n        float f = float( (int(floor(2.0*pos.x))+int(floor(2.0*pos.z)))&1);\n        #endif\n        col = vec3(0.3 + f*0.1);\n    }\n    // torus\n    else\n    {\n        // analytic torus normal\n        nor = normalize( dmap(pos) );\n        // fake occlusion\n        occ = 0.5 + 0.5*nor.y;\n        // texture\n        vec2 uv = vec2(atan(pos.z,pos.x),atan(length(pos.xz)-torus.x,pos.y) )*\n                  vec2(12.0*sqrt(3.0), 8.0)/3.14159;\n        uv.y += iTime;\n        vec3 h = hexagon_pattern( uv );\n        col = vec3( mod(h.x+2.0*h.y,3.0)/2.0 );\n        //col = mix(col,vec3(0.0), 1.0-smoothstep(0.02,0.05,h.z)); // aliased\n        col = mix(col,vec3(0.0),clamp(1.3*(1.0-smoothstep(0.01*res.x,0.05*res.x,h.z))/res.x,0.0,1.0)); // somehow filtered\n    }\n    // lighting        \n    vec3  lig = normalize( vec3(0.4, 0.5, -0.6) );\n    vec3  hal = normalize( lig-rd );\n    float amb = clamp( 0.65+0.35*nor.y, 0.0, 1.0 );\n    float dif = clamp( dot( nor, lig ), 0.0, 1.0 );\n    float bac = clamp( dot( nor, normalize(vec3(-lig.x,0.0,-lig.z))), 0.0, 1.0 );\n\n    dif *= calcSoftshadow( pos, lig );\n\n    float spe = pow( clamp( dot( nor, hal ), 0.0, 1.0 ),32.0) *\n                dif *\n                (0.04 + 0.96*pow( clamp(1.0+dot(hal,rd),0.0,1.0), 5.0 ));\n\n    vec3 lin = vec3(0.0);\n    lin += 1.63*dif*vec3(1.15,0.90,0.55);\n    lin += 0.50*amb*vec3(0.30,0.60,1.50)*occ;\n    lin += 0.30*bac*vec3(0.40,0.30,0.25)*occ;\n    col = col*lin;\n    col += 6.00*spe*vec3(1.15,0.90,0.55);\n\n\treturn col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 mo = iMouse.xy/iResolution.xy;\n\n    // camera\t\n    vec3 ro = vec3( 1.3*cos(0.05*iTime + 6.0*mo.x), 1.1, 1.3*sin(0.05*iTime + 6.0*mo.x) );\n    vec3 ta = vec3( 0.0, -0.2, 0.0 );\n    // camera-to-world transformation\n    vec3 cw = normalize(ta-ro);\n    vec3 cu = normalize(vec3(-cw.z,0.0,cw.x));\n    vec3 cv =          (cross(cu,cw) );\n    \n    vec4 tot = vec4(0.0);\n\t#if AA>1\n    for( int m=0; m<AA; m++ )\n    for( int n=0; n<AA; n++ )\n    {\n        // pixel coordinates\n        vec2 o = (vec2(float(m),float(n)) / float(AA-1) - 0.5)*1.7; // 1.7 pixels wide\n        vec2 p = (-iResolution.xy + 2.0*(fragCoord+o))/iResolution.y;\n\t\t#else    \n        vec2 p = (-iResolution.xy + 2.0*fragCoord)/iResolution.y;\n\t\t#endif\n\n        // ray direction\n        vec3 rd = normalize( p.x*cu + p.y*cv + 2.0*cw );\n\n        // render\t\n        vec3 col = render( ro, rd );\n\n\t\t// gamma (before reconstruction/filtering)\n        col = pow( col, vec3(0.4545) );\n\n \t\t#if AA>1\n        // triangular reconstruction filter, kernel 2.0 pixels wide\n        float w = clamp(1.0 - length(o)/1.0,0.0,1.0);\n        tot.xyz += w*col;\n        tot.w += w;\n        #else\n        tot.xyz = col;\n        #endif\n\t#if AA>1\n    }\n    tot /= tot.w;\n\t#endif\n\n    // grading\n    tot.xyz = pow(tot.xyz,vec3(0.8,0.9,1.0) );\n    \n    // vignetting\n    vec2 q = fragCoord/iResolution.xy;\n    tot.xyz *= 0.3 + 0.7*pow(16.0*q.x*q.y*(1.0-q.x)*(1.0-q.y),0.25);\n    \n    fragColor = vec4( tot.xyz, 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4dKfDV.jpg", "access": "shaders20k", "license": "mit", "functions": [[1139, 1244, 1268, 1268, 1331], [1333, 1388, 1412, 1412, 1545], [1547, 1547, 1587, 1600, 1924], [1927, 1927, 1975, 1975, 2234], [2236, 2236, 2269, 2269, 2591], [2593, 2593, 2632, 2632, 4540], [4542, 4542, 4599, 4599, 6061]], "test": "untested"}
{"id": "4dKfWV", "name": "Ray marching practice 4", "author": "lnae", "description": "doodle", "tags": ["3d", "raymarching"], "likes": 20, "viewed": 375, "published": "Public", "date": "1530573995", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define STEPS 64.\n#define PI 3.14159\n#define EPS 0.0001\n#define EPSN 0.001\n\nmat2 rot(float a){\n\treturn mat2(cos(a), -sin(a), sin(a), cos(a));\n}\n\nfloat distSphere(vec3 pos, float radius){\n\treturn length(pos) - radius;\n}\n\nfloat distScene(vec3 pos){\n    //tilt the scene\n    pos.yz = rot(0.55) * pos.yz;\n    \n    //rotate around y\n    pos.xz = rot(0.5 * iTime + sin(0.5 * iTime)) * pos.xz;\n    \n    float div = 8.;\n    //sphere\n    float angle = atan(pos.z, pos.x);\n    float deform = 0.005 * sin(div * angle);\n\tfloat dist = distSphere(pos - vec3(0., 0.04, 0.), 0.05) + deform;\n    \n    //carved and deformed plane\n    float r = length(pos.xz);\n    r += 0.1 * r * cos(div * angle);\n    pos.y -= 0.5 * r * (1. - r) + 0.05 * r *sin(2. * iTime);   \n    r = sin(0.25 * iTime) + smoothstep(0., 1., abs( (1. - 2. * fract(2. * r)) ));\n    \n    float k = div / 3.;\n    float offset = 0.5 * sin(iTime);\n    deform = abs(r - cos(k * angle) + offset);\n    deform = min(deform, abs(r - cos(k * (angle + 2. * PI)) + offset));\n    deform = min(deform, abs(r - cos(k * (angle + 4. * PI)) + offset));\n    deform = min(deform, abs(-r - cos(k * (angle + PI)) + offset));\n    deform = min(deform, abs(-r - cos(k * (angle + 3. * PI)) + offset));\n    deform = min(deform, abs(-r - cos(k * (angle + 5. * PI)) + offset));\n    float d = 0.01 * smoothstep(0., 0.15, deform);\n    //d += 0.01 * smoothstep(0.25, 0.5, deform);\n\n    dist = min(dist, pos.y + d);\n    \n    return dist;\n}\n\nvec3 getNormal(vec3 pos){\n\treturn normalize(vec3(distScene(pos + vec3(EPSN, 0., 0.)) - distScene(pos - vec3(EPSN, 0., 0.)),\n                          distScene(pos + vec3(0., EPSN, 0.)) - distScene(pos - vec3(0., EPSN, 0.)),\n                          distScene(pos + vec3(0., 0., EPSN)) - distScene(pos - vec3(0., 0., EPSN))));\n}\n\nvec3 render(vec2 uv){\n\t\n    vec3 eye = vec3(0., 0., 4.);\n    vec3 ray = normalize(vec3(uv, 1.) - eye);\n    \n    //background\n    vec3 col = vec3(0.2);\n    \n    //raymarch\n    float step, dist;\n    vec3 pos = eye;\n    bool hit = false;\n    for(step = 0.; step < STEPS; step++){\n    \tdist = distScene(pos);\n        if(abs(dist) < EPS){\n            hit = true;\n        \tbreak;\n        }\n        pos += ray * dist;\n    }\n    \n    //normal\n    vec3 normal = getNormal(pos);\n    \n    vec3 light = vec3(3., 3., 1.5); \n   \n    //shade\n    if(hit){\n        col = vec3(step / STEPS, 0.2, 0.2);\n        \n        //specular only\n        float shine = 10.;\n        vec3 l = normalize(light - pos);\n        vec3 e = normalize(eye - pos);\n        vec3 r = reflect(-l, normal);\n        col += 0.8 * pow(max(dot(r, e), 0.), shine);\n    }    \n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.x;\n    vec3 col = render(uv);\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4dKfWV.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[76, 76, 94, 94, 143], [145, 145, 186, 186, 218], [220, 220, 246, 267, 1453], [1455, 1455, 1480, 1480, 1784], [1786, 1786, 1807, 1807, 2628], [2630, 2630, 2687, 2687, 2813]], "test": "untested"}
{"id": "4dyBDt", "name": "Mountain Road", "author": "ThanksSkeleton", "description": "Playing around with some basic trig and masking", "tags": ["newbie"], "likes": 1, "viewed": 61, "published": "Public", "date": "1530939441", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float plot(vec2 st, float pct){\n  return  smoothstep( pct-0.02, pct, st.y) -\n          smoothstep( pct, pct+0.02, st.y);\n}\n\nfloat plot_inv(vec2 st, float pct){\n  return  smoothstep( pct-0.02, pct, st.x) -\n          smoothstep( pct, pct+0.02, st.x);\n}\n\nfloat invert(float f){\n    return -f + 1.0;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 st = (2.* (fragCoord.xy) / iResolution.xy) - vec2(1., 1.);\n\n    float negx_mask = step(st.x, 0.);\n    float negy_mask = step(st.y, 0.);\n\n    float centerCircle = step(sqrt(st.x*st.x + st.y * st.y), .2);\n\n    float gridmask = step(cos(st.x*50.), .5) * step(cos(st.y*50.), .5)  ;\n\n    float fenceMask = step(cos(st.x*200. + iTime *-70.), .9) * step(cos(st.y*50.), .9);\n    float fenceMask2 = fenceMask * step(st.y, -.4) * step(-.5, st.y);\n\n\n    float mtGreen = step(st.y, .2 *sin(st.x* 20. + iTime * -3.) + .1* cos(st.x* 10. + iTime * -3.) + .1);\n    float mtWhite = step(st.y, .01 *sin(st.x* 90. + iTime * -3.) + .1);\n    float mtRiver = \n    step(st.y, .04 *sin(st.x* 90. + iTime * -3.)* .4 *sin(st.x* 20. + iTime * -3.)  - .6)\n    * step(.04 *sin(st.x* 90. + iTime * -3.) * .4 *sin(st.x* 20. + iTime * -3.) - .8, st.y);\n\n    vec3 riverColor = vec3(0,0,1) + .2* sin(st.x*1.+iTime*3.) * cos(st.y*4.+iTime*4.) * vec3(1,1,0);\n\n    // Time varying pixel color\n    //vec3 col = 0.5 + 0.5*cos(u_time+st.xyx+vec3(0,2,4)+ negx_mask *vec3(0,3,4)+ negy_mask * vec3(0,1,1) + gridmask);\n    vec3 col = \n             //plot(st, 2.*st.x*st.x) * vec3(.0, 1., 1.) \n             //+ plot(st, 2.*st.x*st.x*st.x) * vec3(.0, 1., 0)\n             //+ plot(st, 0.) * vec3(1, 1., 1)\n             + mtGreen * vec3(0,.4,0) * invert(fenceMask2)\n             + invert(mtWhite) * mtGreen * vec3(1,1,1) \n             + mtRiver * riverColor\n             + fenceMask2 * vec3(.3, .3, .3)\n             //+ plot_inv(st, 0.) * vec3(1, 1., 1)\n             // + centerCircle * invert(gridmask) * vec3(.2, .2, .9)\n             + gridmask * vec3(.3, .4, .7) * invert(mtGreen);\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4dyBDt.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 31, 31, 122], [124, 124, 159, 159, 250], [252, 252, 274, 274, 297], [299, 299, 355, 355, 2059]], "test": "untested"}
{"id": "4dyfDt", "name": "hypnotic parallelograms", "author": "laserdog", "description": "trippy effect. thanks @nimitz for the cool parallax technique (https://www.shadertoy.com/view/XssXz4)", "tags": ["parallax", "trippy"], "likes": 5, "viewed": 249, "published": "Public", "date": "1531027345", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const float size = .3;\nconst float thickness = .05;\nconst float iterations = 15.;\n\nmat2 rotate(float rads)\n{\n    return mat2(cos(rads), sin(rads), -sin(rads), cos(rads));\n}\n\nfloat getDist(vec2 uv)\n{\n    vec2 coord = rotate(sin(iTime * .65) * 2.35) * abs(fract(uv) - .5);\n    return max(coord.x, coord.y);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = 1.75 * (2. * fragCoord.xy - iResolution.xy) / iResolution.y;\n    vec2 stepAmt = uv * .005;\n    float colAmt = 0.;\n        \n    for (float i = 0.; i < iterations; i++)\n    {\n        uv += stepAmt * i;\n        float maxDist = getDist(uv);\n        colAmt += (smoothstep(size, size - .05, maxDist)\n        * smoothstep(size - thickness, size - (thickness - .05), maxDist));\n    }\n        \n    fragColor = vec4(colAmt + (1. - step(0.2, colAmt)) * .1, 0., 0., 1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4dyfDt.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[83, 83, 108, 108, 172], [174, 174, 198, 198, 306], [308, 308, 365, 365, 840]], "test": "untested"}
{"id": "4l3yD7", "name": "Trippy interactive spiral", "author": "matfas", "description": "Controls: see source code comments\n\nMusic by Ott: https://soundcloud.com/ottsonic\nand Caravan Palace: https://soundcloud.com/caravan-palace-official", "tags": ["tunnel", "interactive", "music", "spiral", "colorful", "psychedelic", "rainbow", "trippy", "hypnotic"], "likes": 22, "viewed": 2265, "published": "Public API", "date": "1532799257", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/*\nControls\nMouse click: manipulate spiral parameters\nKeyboard shortcuts\n- 1: toggle invert spiral: 1.0 - spiral\n- 2: toggle invert spiral: 1.0 / spiral\n\nMusic by Ott and Caravan Palace\nOther songs that work well with this shader:\n- https://soundcloud.com/ottsonic/3-ott-owl-stretching-time\n- https://soundcloud.com/ottsonic/4-ott-squirrel-and-biscuits\n- https://soundcloud.com/ottsonic/6-ott-mouse-eating-cheese\n- https://soundcloud.com/ottsonic/ott-baby-robot-02-mr-balloon-hands\n- https://soundcloud.com/caravan-palace-official/lone-digger\n- https://soundcloud.com/caravan-palace-official/aftermath\n\nTODO\nFigure out how to apply distortion along the tangent of the spiral.\n*/\n\n#define DISTORTION 1.0\n\n#define PI   3.14159265359\n#define TAU  6.28318530718\n#define PI_2 1.57079632679\n\nconst int KEY_SPACE = 32;\nconst int KEY_1 = 49;\nconst int KEY_2 = 50;\nconst int KEY_3 = 51;\n\nvec3 linColor(float value)\n{\n    value = mod(value * 6.0, 6.0);\n    vec3 color;\n    \n    color.r = 1.0 - clamp(value - 1.0, 0.0, 1.0) + clamp(value - 4.0, 0.0, 1.0);\n    color.g = clamp(value, 0.0, 1.0) - clamp(value - 3.0, 0.0, 1.0);\n    color.b = clamp(value - 2.0, 0.0, 1.0) - clamp(value - 5.0, 0.0, 1.0);\n    \n    return color;\n}\n\nvec3 sinColor(float value)\n{\n    value *= TAU;\n    vec3 color;\n    \n    color.r = (1.0 + cos(value)) / 2.0;\n    color.g = (1.0 + cos(value - TAU / 3.0)) / 2.0;\n    color.b = (1.0 + cos(value + TAU / 3.0)) / 2.0;\n    \n    return color;\n}\n\nbool toggled(int key)\n{\n    return texelFetch(iChannel1, ivec2(key, 2), 0).x != 0.0;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 halfRes = iResolution.xy / 2.0;\n    vec2 pos = (fragCoord - halfRes) / halfRes.y;\n    \n    float mouseX = iMouse.x / iResolution.x;\n    float mouseY = (iMouse.y - halfRes.y) / halfRes.y;\n    float clicked = iMouse.z > 0.0 || iMouse.w > 0.0 ? 1.0 : 0.0;\n    // Increase accuracy per pixel with small values.\n    mouseX *= abs(mouseX * mouseX * mouseX * mouseX);\n    mouseY *= abs(mouseY * mouseY * mouseY * mouseY);\n    \n    // Reduce rounding issues (banding) caused by big iTime values.\n    float fractTime = fract(iTime);\n    float tauTime = mod(iTime, TAU);\n    \n    float len = length(pos);\n    float angle = atan(pos.y, pos.x);\n    \n    float sinAngle = (sin(angle + tauTime) + 1.0) / 2.0;\n    float sound = texture(iChannel0, vec2(sinAngle, 1.0)).x * DISTORTION;\n    float distortion = 1.0 + sound * 0.1;\n    \n    float powLen, sine, arms;\n    if (clicked > 0.0)\n    {\n        powLen = pow(len, mouseY * 256.0);\n        distortion = pow(distortion, mouseY * 256.0);\n        arms = (round(mouseX * 65536.0) / 2.0);\n    }\n    else\n    {\n        //float e = -0.1;\n        //powLen = pow(len, e);\n        //distortion = pow(distortion, e);\n        \n        distortion = 1.0 / sqrt(distortion);\n        powLen = 1.0 / sqrt(len);\n        arms = 4.0;\n    }\n    \n    sine = sin(powLen * 16.0 * distortion + angle * arms - tauTime * 8.0);\n    sine = abs(sine);\n    sine = sqrt(sine);\n    \n    if (toggled(KEY_1)) sine = 1.0 - sine;\n    if (toggled(KEY_2)) sine = 1.0 / sine;\n    \n    fragColor = vec4(linColor(powLen * distortion * distortion - fractTime), 1.0) * sine;\n    //fragColor = vec4(sound, sound, sound, 1.0);\n}\n", "image_inputs": [{"id": "4dXGRr", "previewfilepath": "/presets/tex00.jpg", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/presets/tex00.jpg", "ctype": "keyboard"}, {"id": "4djSWt", "previewfilepath": "https://soundcloud.com/ottsonic/3-ott-owl-stretching-time", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0, "src": "https://soundcloud.com/ottsonic/3-ott-owl-stretching-time", "ctype": "musicstream"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4l3yD7.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 879, 907, 907, 1213], [1215, 1215, 1243, 1243, 1451], [1453, 1453, 1476, 1476, 1539], [1541, 1541, 1596, 1596, 3224]], "test": "untested"}
{"id": "4l3yz8", "name": "syltefar-black hole sun", "author": "syltefar", "description": "A ray marched sphere with spherical coordinate-based gradient noise applied to its radius, color intensity is ray march iteration count.", "tags": ["sdf"], "likes": 5, "viewed": 138, "published": "Public", "date": "1531410827", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Gradient noise by iq\n// - See https://www.shadertoy.com/view/XdXGW8\nvec2 hash( vec2 x )  // replace this by something better\n{\n    const vec2 k = vec2( 0.3183099, 0.3678794 );\n    x = x*k + k.yx;\n    return -1.0 + 2.0*fract( 16.0 * k*fract( x.x*x.y*(x.x+x.y)) );\n}\nfloat noise( in vec2 p )\n{\n    vec2 i = floor( p );\n    vec2 f = fract( p );\n\t\n\tvec2 u = f*f*(3.0-2.0*f);\n\n    return mix( mix( dot( hash( i + vec2(0.0,0.0) ), f - vec2(0.0,0.0) ), \n                     dot( hash( i + vec2(1.0,0.0) ), f - vec2(1.0,0.0) ), u.x),\n                mix( dot( hash( i + vec2(0.0,1.0) ), f - vec2(0.0,1.0) ), \n                     dot( hash( i + vec2(1.0,1.0) ), f - vec2(1.0,1.0) ), u.x), u.y);\n}\n\nfloat sdf(vec3 pos, float time)\n{\n    vec2 polar;\n    vec3 local_sp = pos;\n    polar.y = atan(local_sp.z, local_sp.x);\n    float xzLen = sqrt(local_sp.x * local_sp.x + local_sp.z * local_sp.z);\n    polar.x = atan(xzLen, -local_sp.y);\n    \n    float time_scaled = time * 0.2;\n    \n    // Circular motion ensures that surface motion is constant\n    vec2 offset = vec2( cos(time_scaled), sin(time_scaled)) * 10.0;\n    \n    // avoid wobble at the poles, it generates artifacts\n    float wobble_scale = sin(polar.x + 3.14127);\n    \n    return length(pos) - 0.9\n        - noise(polar*3.0+offset) * 0.2 * wobble_scale\n        - noise(polar*2.7-offset) * 0.2 * wobble_scale\n        ;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    const float gradient_offset = 0.001;\n    const float MIN_DIST = 0.01;\n    const float MAX_DIST = 60.0;\n    const int ITERATIONS = 32;\n    // http://www.iquilezles.org/www/articles/distfunctions/distfunctions.htm\n    // \"You must be carefull when using distance transformation functions, as\n    //  the field created might not be a real distance function anymore. You\n    //  will probably need to decrease your step size, if you are using a\n    // raymarcher to sample this.\"\n    const float STEP_SIZE = 0.4;\n    \n    vec2 uv = fragCoord.xy / iResolution.yy * 2.0;\n    vec3 start_pos = vec3(uv.x-1.0, uv.y-1.0, 0.0);\n    vec3 camera = vec3(0.0, 0.0,-100.0);\n    vec3 direction = normalize(start_pos - camera);\n\n    vec3 pos = start_pos + vec3(-1.0, 0.0, -40.0);\n    \n    // ray marching\n    float d = 10.0;\n    int i = 0;\n    for(i = 0; i < ITERATIONS; i++) {\n\t  d = sdf(pos, iTime );\n\t  pos += direction * d * STEP_SIZE;\n\t  if(d < MIN_DIST || d > MAX_DIST) break;\n    }\n\n    float r = 0.0, g = 0.0, b = 0.0;\n    \n    if(d<=MIN_DIST) {\n\n\t  // estimate normal based on finite difference approx of gradient\n\t  vec3 gradient = sdf(pos, iTime) - vec3(\n\t      sdf(pos + vec3(gradient_offset,.000,.000), iTime),\n\t      sdf(pos + vec3(.000,gradient_offset,.000), iTime),\n\t      sdf(pos + vec3(.000,.000,gradient_offset), iTime)\n\t      );\n      \t  vec3 normal = normalize( gradient );\n\n\t  // red diffuse light\n\t  //r = dot( normal, normalize(vec3(2.0,-4.0,+0.5))) * 0.9;\n\t  // green diffuse light\n\t  //g = dot( normal, normalize(vec3(-0.4,0.4,+0.4))) * 0.2;\n\t  // blue diffuse light\n\t  //b = dot( normal, normalize(vec3(0.9,-0.3,+0.4))) * 0.5;\n    }\n    // show iteration count\n    float col = pow(float(i)/float(ITERATIONS), 3.0);\n    fragColor = vec4(col, 0.0, 0.0, 1.0);\n    \n    //fragColor = vec4(r, g, b, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4l3yz8.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 71, 129, 129, 267], [268, 268, 294, 294, 692], [694, 694, 727, 727, 1371], [1373, 1373, 1430, 1430, 3245]], "test": "untested"}
{"id": "4lccD8", "name": "syltefar-noise-gradient-2d", "author": "syltefar", "description": "Left: 2D gradient noise\nRight: An attempt at creating a 3D gradient noise by moving layers of noise with different frequencies around in circles.", "tags": ["noise", "gradientnoise"], "likes": 4, "viewed": 135, "published": "Public", "date": "1532347697", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// 2D gradient noise\n// - Based on shader by iq\n// - See https://www.shadertoy.com/view/XdXGW8\n\nvec2 hash( vec2 x )  // replace this by something better\n{\n    const vec2 k = vec2( 0.3183099, 0.3678794 );\n    x = x*k + k.yx;\n    return -1.0 + 2.0*fract( 16.0 * k*fract( x.x*x.y*(x.x+x.y)) );\n}\n\nfloat noise( in vec2 p )\n{\n    vec2 i = floor( p );\n    vec2 f = fract( p );\n\t\n\tvec2 u = f*f*(3.0-2.0*f);\n\n    return mix( mix( dot( hash( i + vec2(0.0,0.0) ), f - vec2(0.0,0.0) ), \n                     dot( hash( i + vec2(1.0,0.0) ), f - vec2(1.0,0.0) ), u.x),\n                mix( dot( hash( i + vec2(0.0,1.0) ), f - vec2(0.0,1.0) ), \n                     dot( hash( i + vec2(1.0,1.0) ), f - vec2(1.0,1.0) ), u.x), u.y);\n}\n\n// Attempt at creating a 3D gradient noise by moving layers of noise with different\n// frequencies around in circles\nfloat noise3d(vec3 st)\n{\n    return noise(st.xy*20.0 + vec2(cos(st.z*0.07), sin(st.z*0.07)) * 20.0)\n         * noise(st.xy*11.0 + vec2(cos(st.z*-0.05), sin(st.z*-0.05)) * 10.0)\n         * noise(st.xy*7.0  + vec2(cos(st.z*0.1), sin(st.z*0.1)) * 9.0)\n        ;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.yy;\n\n    float col;\n    vec2 pos = vec2(uv.x*32.0, uv.y*32.0);\n    if(fragCoord.x < iResolution.x * 0.499)\n    {\n        col = noise(pos) * 2.0;\n    }\n        if(fragCoord.x > iResolution.x * 0.501)\n    {\n        col = noise3d(vec3(uv.x, uv.y, iTime)) * 50.0;\n    }\n   \n     fragColor = vec4(col, col, col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4lccD8.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 96, 154, 154, 292], [294, 294, 320, 320, 718], [720, 837, 861, 861, 1097], [1099, 1099, 1156, 1156, 1507]], "test": "untested"}
{"id": "4lccW8", "name": "Distance function & tessellation", "author": "barakchamo", "description": "Distance function & tessellation", "tags": ["voronoi", "distance", "function", "manhattan", "minkowski", "tessellation", "euclidean", "chebyshev", "weight"], "likes": 3, "viewed": 271, "published": "Public", "date": "1532328709", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/* Euclidean distance */\n/* https://en.wikipedia.org/wiki/Euclidean_distance */ \nfloat euclideanDistance(float p1, float p2) {\n\tfloat d1 = (p1 - p2);\n\treturn sqrt(pow(d1, 2.0));\n}\n\nfloat euclideanDistance(vec2 p1, vec2 p2) {\n\tfloat d1 = (p1.x - p2.x);\n\tfloat d2 = (p1.y - p2.y);\n\treturn sqrt(pow(d1, 2.0) + pow(d2, 2.0));\n}\n\nfloat euclideanDistance(vec3 p1, vec3 p2) {\n\tfloat d1 = (p1.x - p2.x);\n\tfloat d2 = (p1.y - p2.y);\n\tfloat d3 = (p1.z - p2.z);\n\treturn sqrt(pow(d1, 2.0) + pow(d2, 2.0) + pow(d3, 2.0));\n}\n\n/* Manhattan distance */\n/* https://en.wikipedia.org/wiki/Taxicab_geometry */ \nfloat manhattanDistance(float p1, float p2) {\n\tfloat d1 = abs(p1 - p2);\n\treturn d1;\n}\n\nfloat manhattanDistance(vec2 p1, vec2 p2) {\n\tfloat d1 = abs(p1.x - p2.x);\n\tfloat d2 = abs(p1.y - p2.y);\n\treturn d1 + d2;\n}\n\nfloat manhattanDistance(vec3 p1, vec3 p2) {\n\tfloat d1 = abs(p1.x - p2.x);\n\tfloat d2 = abs(p1.y - p2.y);\n\tfloat d3 = abs(p1.z - p2.z);\n\treturn d1 + d2 + d3;\n}\n\n/* Minkowski distance */\n/* https://en.wikipedia.org/wiki/Minkowski_distance */ \nfloat minkowskiDistance(float p1, float p2, float power) {\n\tfloat d1 = pow(abs(p1 - p2), power);\n\treturn pow(d1, 1.0 / power);\n}\n\nfloat minkowskiDistance(vec2 p1, vec2 p2, float power) {\n\tfloat d1 = pow(abs(p1.x - p2.x), power);\n\tfloat d2 = pow(abs(p1.y - p2.y), power);\n\treturn pow(d1 + d2, 1.0 / power);\n}\n\nfloat minkowskiDistance(vec3 p1, vec3 p2, float power) {\n\tfloat d1 = pow(abs(p1.x - p2.x), power);\n\tfloat d2 = pow(abs(p1.y - p2.y), power);\n\tfloat d3 = pow(abs(p1.z - p2.z), power);\n\treturn pow(d1 + d2 + d3, 1.0 / power);\n}\n\n/* Chebyshev distance */\n/* https://en.wikipedia.org/wiki/Chebyshev_distance */ \nfloat chebyshevDistance(float p1, float p2) {\n\tfloat d1 = abs(p1 - p2);\n\treturn d1;\n}\n\nfloat chebyshevDistance(vec2 p1, vec2 p2) {\n\tfloat d1 = abs(p1.x - p2.x);\n\tfloat d2 = abs(p1.y - p2.y);\n\treturn max(d1, d2);\n}\n\nfloat chebyshevDistance(vec3 p1, vec3 p2) {\n\tfloat d1 = abs(p1.x - p2.x);\n\tfloat d2 = abs(p1.y - p2.y);\n\tfloat d3 = abs(p1.z - p2.z);\n\treturn max(d1, max(d2, d3));\n}\n\n\n\n\n/* Tesselation Demo Fragment Shader */\n/* Try this at: shadertoy link */\nuniform float uTime;\n\nvec2 hash( vec2 p ) {\n\tp = vec2(dot(p,vec2(127.1,311.7)),dot(p,vec2(269.5,183.3))); \n\treturn fract(sin(p)*18.5453);\n}\n\nfloat random (vec2 st) {\n    return fract(sin(dot(st.xy, vec2(12.9898, 78.233))) * 43758.5453123);\n}\n\n/* distance tesselation */\nvec2 tessellate( in vec2 x, in float wf ) {\n    vec2 n = floor( x );\n    vec2 f = fract( x );\n\n\t// weight factor\n\tfloat w = random(n) * wf;\n\n\t// MODIFY THIS:\n\t// Maximum distance for distance function\n\t// 2.0 and up should cover the whole distance\n\t// Less will form distance bubbles\n\tvec2 m; \n\tm = vec2( 2.0 );\n\t// m = vec2( 0.5 );\n\n\t// Cover a unit range around the point\n    for( int j=-1; j<=1; j++ )\n    for( int i=-1; i<=1; i++ )\n    {\n\t\t// distance point (edges of the unit square around the point)\n        vec2  g = vec2( float(i), float(j) );\n\n\t\t// random point inside the unit square\n\t\t// Basically, random point inside the tile\n        vec2  o = hash( n + g );\n\n\t\t// move the point around the tile based on sin(time);\n\t    vec2  r = g - f + (0.5+0.5*sin(iTime+6.2831*o));\n\t\tfloat w = random(o) * wf;\n\n\t\t// Get the vector's distance from origin\n\t\t// This is similar to the self dot product operation dot(r,r);\n\t\tfloat d;\n\n\t\t// MODIFY THIS: try using different functions\n\t\t//d = euclideanDistance(vec2(0), r);\n\t\t// d = manhattanDistance(vec2(0), r);\n\t\td = minkowskiDistance(vec2(0), r, 2.0 + sin(iTime * 1.0));\n\t\t// d = chebyshevDistance(vec2(0), r);\n\n\t\t// Additively weight the distance\n\t\td += w;\n\n        if( d<m.x )\n            m = vec2( d, o );\n    }\n \n\t// Return point distance\n    return m;\n}\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 st = fragCoord/iResolution.y;\n\n\t// MODIFY THIS:\n\t// Tile the coordinate space\n\tst *= 5.0;\n\t\n\t// MODIFY THIS:\n\t// Weight factor applied to a random weight coefficient in the tesselation function\n\t// https://en.wikipedia.org/wiki/Weighted_Voronoi_diagram\n\tfloat weightFactor = (1.0 + sin(iTime / 2.0)) / 2.0;\n\n\t// Generate tessellate pattern\n\tvec2 c = tessellate( st, weightFactor );\n\t\n\t// Colorize\n    vec3 col = 0.5 + 0.5 * cos( 3.0 + c.y * 3.0 + c.x + vec3(1.5,1.0,0.5) );\t\n    \n\t// Add distance-based gradient\n\tcol *= clamp(1.0 - 0.2 * pow(c.x, 2.0), 0.0,1.0);\n    \n\t// Draw points\n\tcol -= (1.0-smoothstep( 0.01, 0.05, c.x));\n\t\n    fragColor = vec4( col, 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4lccW8.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 81, 126, 126, 179], [181, 181, 224, 224, 323], [325, 325, 368, 368, 509], [511, 590, 635, 635, 675], [677, 677, 720, 720, 799], [801, 801, 844, 844, 958], [960, 1041, 1099, 1099, 1169], [1171, 1171, 1227, 1227, 1348], [1350, 1350, 1406, 1406, 1574], [1576, 1657, 1702, 1702, 1742], [1744, 1744, 1787, 1787, 1870], [1872, 1872, 1915, 1915, 2037], [2042, 2137, 2158, 2158, 2254], [2256, 2256, 2280, 2280, 2356], [2358, 2385, 2428, 2428, 3692], [3695, 3695, 3750, 3750, 4425]], "test": "untested"}
{"id": "4lcczr", "name": "mariusBallot's first shader", "author": "mariusBallot", "description": "my very first shader", "tags": ["2d", "first"], "likes": 0, "viewed": 88, "published": "Public", "date": "1531212458", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    vec2 uv = fragCoord/iResolution.xy;\n    uv = ( fragCoord - .5* iResolution.xy ) / iResolution.y;\n\n    vec3 col =cos(iTime*7.+uv.y/(cos(iTime)+1.)*5.*uv.x*(cos(iTime*2.)*10.)+vec3(0,(cos(iTime*3.)-1.)*.2,4))*1.3;\n\n    fragColor = vec4((cos(iTime*2.)+1.)*col, 1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4lcczr.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 330]], "test": "untested"}
{"id": "4lcyW8", "name": "Yet Another Mandelbrot", "author": "mike_tobia", "description": "palpating mandelbrot - intro to shadertoy", "tags": ["mandelbrot"], "likes": 1, "viewed": 296, "published": "Public API", "date": "1532321331", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 m = iMouse.xy / iResolution.xy;\n    float zoom = pow(10., -m.x*3.);\n    \n    vec2 uv = (fragCoord.xy-.5*iResolution.xy) /iResolution.y;\n\n    vec2 c = uv*zoom*3.;\n    c += vec2(-.69955, .37999);\n    \n    vec2 z = vec2(0.);\n    float iter = 0.;\n    \n    float steps = 100.;\n    float n = 2. + (cos(iTime) + 1.);\n    \n    for (float i = 0.; i < steps; i++) {\n        // z = z^2 + c\n\t\tz = vec2(z.x*z.x - z.y*z.y, n*z.x*z.y) + c;\n        \n        if (length(z)>2.) break;\n        \n        iter++;\n    }\n    \n    float f = iter/steps;\n    \n    vec3 col = vec3(f);\n\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4lcyW8.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 658]], "test": "untested"}
{"id": "4lcyzH", "name": "AttemptAtReflections", "author": "agordeevw", "description": "Raymarching with simple shadows and reflections.", "tags": ["reflections"], "likes": 8, "viewed": 149, "published": "Public", "date": "1531440395", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// ----------------------------------------\n//  Camera\n// ----------------------------------------\n\nstruct Camera\n{\n  float fov;\n  vec3 position;\n  vec3 forward;\n  vec3 up;\n};\n\nconst Camera initialCamera = Camera(\n  90.0f / 180.0f * 3.141526f,\n  vec3(0.6f, 1.0f, 0.6f),\n  normalize(vec3(-1.0f, -1.0f, -1.0f)),\n  normalize(vec3(0.0f, 1.0f, 0.0f)));\n\nCamera camera = Camera(\n  initialCamera.fov,\n  initialCamera.position,\n  initialCamera.forward,\n  initialCamera.up);\n\nvoid updateCamera()\n{\n  float cameraY = 0.5f + 0.4f * sin(0.5f * iTime);\n  const float cameraDistance = 0.70f;\n  camera.position = vec3(cameraDistance * cos(iTime), cameraY, cameraDistance * sin(iTime));\n  camera.forward = normalize(vec3(0.0f, 0.2f, 0.0f) - camera.position);\n}\n\n// ----------------------------------------\n//  Materials\n// ----------------------------------------\n\nstruct Material\n{\n  vec3  diffuse;\n  vec3  specular;\n  float specPower;\n  float reflectance;\n};\n\nconst Material materials[] = Material[](\n  Material(vec3(0.0f, 0.0f, 0.0f), vec3(1.0f, 1.0f, 1.0f), 64.0f, 0.75f),\n  Material(vec3(0.8f, 0.0f, 0.15f), vec3(1.0f, 1.0f, 1.0f), 16.0f, 0.0f),\n  Material(vec3(0.1f, 0.1f, 0.1f), vec3(1.0f, 1.0f, 1.0f), 64.0f, 0.85f)\n);\n\n// ----------------------------------------\n//  Lighting\n// ----------------------------------------\nconst vec3 ambient        = vec3(0.05f, 0.05f, 0.05f);\nconst vec3 lightDirection = normalize(vec3(0.0f, -1.0f, -1.0f));\nconst vec3 lightDiffuse   = vec3(1.0f, 1.0f, 1.0f);\nconst vec3 lightSpecular  = vec3(1.0f, 1.0f, 1.0f);\n\nvec3 skyColor(vec3 direction)\n{\n  const vec3 top = vec3(0.2f, 0.4f, 0.8f);\n  const vec3 mid = vec3(1.0f, 1.0f, 1.0f);\n  const vec3 bot = vec3(0.1f, 0.1f, 0.1f);\n  const float topMidLevel = 1.0f;\n  const float midBotLevel = 0.0f;\n  const float botLevel    = -0.2f;\n  \n  if (direction.y > topMidLevel)\n    return top;\n  if (direction.y <= topMidLevel && direction.y > midBotLevel)\n    return mix(mid, top, (direction.y - midBotLevel) / (topMidLevel - midBotLevel));\n  if (direction.y <= midBotLevel && direction.y > botLevel)\n    return mix(bot, mid, (direction.y - botLevel) / (midBotLevel - botLevel));\n  return bot;\n}\n\nvec3 phongDiffuse(vec3 matDiffuse, vec3 lightDir, vec3 normal)\n{\n  return lightDiffuse * matDiffuse * max(dot(-lightDir, normal), 0.0f);\n}\n\nvec3 phongSpecular(vec3 matSpecular, vec3 lightDir, vec3 normal, \n  vec3 cameraDir, float power)\n{\n  return lightSpecular * matSpecular * pow(max(dot(reflect(lightDir, normal), \n    normalize(cameraDir)), 0.0f), power);\n}\n\nvec3 phong(uint matId, vec3 p, vec3 n, vec3 c)\n{\n  return phongDiffuse(materials[matId].diffuse, lightDirection, n)\n    + phongSpecular(materials[matId].specular, lightDirection, n, c - p, materials[matId].specPower);\n}\n\n// ----------------------------------------\n//  SDFs\n// ----------------------------------------\nstruct SDFOut\n{\n  float value;\n  uint  id;\n};\n\nSDFOut opU(SDFOut sdf1, SDFOut sdf2)\n{\n  float res = min(sdf1.value, sdf2.value);\n  if (res == sdf1.value)\n    return SDFOut(res, sdf1.id);\n  else\n    return SDFOut(res, sdf2.id);\n}\n\nSDFOut sphereSdf(uint id, vec3 point, vec3 center, float radius)\n{\n  return SDFOut(length(point - center) - radius, id);\n}\n\nSDFOut boxSdf(uint id, vec3 point, vec3 center, vec3 size)\n{\n  return SDFOut(length(max(abs(point - center) - size, 0.0f)), id);\n}\n\nSDFOut sceneSdf(vec3 point)\n{\n  float sphereShift1 = 0.3f + 0.05f * (1.0f + sin(3.0f * iTime));\n  float sphereShift2 = 0.3f + 0.05f * (1.0f + sin(3.0f * iTime + 0.4f));\n  float sphereShift3 = 0.3f + 0.05f * (1.0f + sin(3.0f * iTime + 0.8f));\n  float sphereShift4 = 0.3f + 0.05f * (1.0f + sin(3.0f * iTime + 1.2f));\n  SDFOut sphere = sphereSdf(0u, point, vec3(0.5f, sphereShift1, 0.0f), 0.15f);\n  SDFOut sphere2 = sphereSdf(0u, point, vec3(-0.5f, sphereShift2, 0.0f), 0.15f);\n  SDFOut sphere3 = sphereSdf(0u, point, vec3(0.0f, sphereShift3, 0.5f), 0.15f);\n  SDFOut sphere4 = sphereSdf(0u, point, vec3(0.0f, sphereShift4, -0.5f), 0.15f);\n  SDFOut platform = boxSdf(1u, point, vec3(0.0f, 0.0f, 0.0f), vec3(1.0f, 0.05f, 1.0f));\n  SDFOut pillar = boxSdf(2u, point, vec3(0.0f, 0.0f, 0.0f), vec3(0.25f, 0.1f, 0.25f));\n  SDFOut res = \n    opU(pillar, \n    opU(sphere4, \n    opU(sphere3, \n    opU(sphere2, \n    opU(sphere, platform)))));\n  \n  return res;\n}\n\n// ----------------------------------------\n//  Utility\n// ----------------------------------------\n\nconst float gradientPrecision = 1.e-2f;\n\nvec3 gradient(vec3 p)\n{\n  const float pr = gradientPrecision;\n  const vec3 dx = vec3(pr, 0.0f, 0.0f);\n  const vec3 dy = vec3(0.0f, pr, 0.0f);\n  const vec3 dz = vec3(0.0f, 0.0f, pr);\n  return normalize(vec3(\n    sceneSdf(p + dx).value - sceneSdf(p - dx).value ,\n    sceneSdf(p + dy).value  - sceneSdf(p - dy).value ,\n    sceneSdf(p + dz).value  - sceneSdf(p - dz).value ));\n}\n\n// ----------------------------------------\n//  Raymarching settings\n// ----------------------------------------\n// Uncomment to enable shading:\n#define SHADOWS\n\n// Uncomment to enable reflections:\n#define REFLECTIONS\n\nconst float minRayLength      = 0.01f;\nconst float maxRayLength      = 100.0f;\nconst uint  maxStep           = 128u;\nconst float raycastPrecision  = 0.5f * 1.e-3f;\nconst uint  reflectionCount   = 4u;\n\n// ----------------------------------------\n//  Raycasting\n// ----------------------------------------\nstruct RaycastInfo\n{\n  bool hit;\n  vec3 point;\n  uint id;\n};\n\nvec3 screenRayDirection(Camera camera, vec2 fragPos)\n{\n  float aspectRatio = iResolution.x / iResolution.y;\n  float halfFov = camera.fov * 0.5f;\n  vec3 cameraRight = normalize(cross(camera.forward, camera.up));\n  vec3 direction = camera.forward \n    + (fragPos.y - 0.5f) * 2.0f * normalize(cross(cameraRight, camera.forward)) * tan(halfFov)\n    + (fragPos.x - 0.5f) * 2.0f * cameraRight * tan(halfFov) * aspectRatio;\n\n  return normalize(direction);\n}\n\nRaycastInfo raycast(vec3 origin, vec3 direction)\n{\n  float rayLength = minRayLength;\n  vec3 p = origin + direction * rayLength;\n\n  for (uint i = 0u; i < maxStep; ++i)\n  {\n    SDFOut sdfOut = sceneSdf(p);\n\n    if (sdfOut.value <= raycastPrecision)\n      return RaycastInfo(true, p, sdfOut.id);\n\n    p += sdfOut.value * direction;\n    rayLength += sdfOut.value;\n\n    if (rayLength > maxRayLength)\n      return RaycastInfo(false, p, sdfOut.id);\n  }\n}\n\n// ----------------------------------------\n//  Coloring\n// ----------------------------------------\n\n// Calculate phong and shadows, not considering reflections\nvec3 CalcDirectLighting(RaycastInfo raycastInfo, vec3 from)\n{\n  vec3 ph = phong(raycastInfo.id, raycastInfo.point, gradient(raycastInfo.point), from);\n#ifdef SHADOWS\n  float shadow = 0.0f;\n  RaycastInfo shadowRaycast = raycast(raycastInfo.point, -lightDirection);\n  if (shadowRaycast.hit) shadow = 0.5f;\n    \n  return (1.0f - shadow) * ph;\n#else\n  return ph;\n#endif\n}\n\nvoid mainImage(out vec4 color, in vec2 fragCoord)\n{\n  updateCamera();\n\n  vec2 fragPos = fragCoord / iResolution.xy;\n  vec3 direction = screenRayDirection(camera, fragPos);\n\n  RaycastInfo pointRaycast = raycast(camera.position, direction);\n  if (pointRaycast.hit)\n  {\n    color = vec4(0.0f, 0.0f, 0.0f, 1.0f);\n    \n    color.rgb += CalcDirectLighting(pointRaycast, camera.position);\n\n#ifdef REFLECTIONS\n    vec3 reflectionSourcePoint = pointRaycast.point;\n    vec3 reflectionDir = direction;\n    float reflectance = materials[pointRaycast.id].reflectance;\n    for (uint i = 0u; i < reflectionCount; ++i)\n    {\n      reflectionDir = reflect(reflectionDir, gradient(reflectionSourcePoint));\n      RaycastInfo reflectionRaycast = raycast(reflectionSourcePoint, reflectionDir);\n      if (reflectionRaycast.hit)\n      {\n        color.rgb += reflectance * \n          CalcDirectLighting(reflectionRaycast, reflectionSourcePoint);\n        reflectance *= materials[reflectionRaycast.id].reflectance;\n        reflectionSourcePoint = reflectionRaycast.point;\n      }\n      else\n      {\n        color.rgb += reflectance * skyColor(reflectionDir);\n        break; // out of scene\n      }\n    }\n#endif\n  }\n  else \n  {\n  \tcolor = vec4(skyColor(direction), 1.0f);\n  }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4lcyzH.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 467, 488, 488, 744], [1212, 1538, 1569, 1569, 2156], [2158, 2158, 2222, 2222, 2296], [2298, 2298, 2396, 2396, 2519], [2521, 2521, 2569, 2569, 2740], [2742, 2886, 2924, 2924, 3067], [3069, 3069, 3135, 3135, 3191], [3193, 3193, 3253, 3253, 3323], [3325, 3325, 3354, 3354, 4272], [4274, 4416, 4439, 4439, 4790], [5212, 5377, 5431, 5431, 5827], [5829, 5829, 5879, 5879, 6276], [6380, 6440, 6501, 6501, 6807], [6809, 6809, 6860, 6860, 8060]], "test": "untested"}
{"id": "4ldcRn", "name": "李明杰V17", "author": "leneer", "description": "c", "tags": ["c"], "likes": 2, "viewed": 208, "published": "Public", "date": "1531293924", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// based off https://www.shadertoy.com/view/MdVyRK\n\n#define SEED 0.12345679\n\n#define TRI 64.0\n#define SP 0.5\n#define COLOR vec3(0.9411764705882353,0.4274509803921569,0.6549019607843137)\n\n#define PI 3.14159265359\n#define TWO_PI 6.28318530718\n#define HALFPI 1.5707963268\n\nfloat rand (vec2 p) {\n    return fract(sin(dot(p.xy,\n                         vec2(6.8245,7.1248)))*\n        9.1283);\n}\n\nfloat tri(vec2 uv, vec2 p, float s){\n    vec2 v = uv;\n    v -= p;\n    v /= max(s, 0.01);\n    \n\tfloat a = atan(v.x, v.y) + PI;\n    float r = TWO_PI / 3.0;\n    \n    float t = cos(floor(0.5 + a / r) * r - a) * length(v);\n    \n    return smoothstep(0.4, 0.41, t);\n}\n\nfloat yPos(float i){\n    vec2 p = vec2(SEED, i);\n    \n    float r = rand(p);\n    return fract(iTime * SP + r);\n}\n\nfloat xPos(float i, float t){\n    vec2 p = vec2(i, t - iTime * SP);\n    return rand(p) + .375;\n}\n\nvec3 triCol(float i, float t){\n    vec3 col = COLOR;\n    float r = xPos(i + 1.0, t);\n    col *= mix(0.9, 1.1, r);\n    return col;\n}\n\nfloat atan2(float y, float x) {\n \tif(x>0.)return atan(y/x);\n    if(x==0.)if(y>0.)return HALFPI;else return -HALFPI;\n    if(y<0.)return atan(y/x)-PI;return atan(y/x)+PI;\n}\nfloat atan2(vec2 v){return atan2(v.y,v.x);}\nfloat steq(float x,float a,float b){return step(a,x)*step(x,b);}\nvec2 cub_(float t,vec2 a,vec2 b){\n    float ct=1.-t;\n    return 3.*ct*ct*t*a+3.*ct*t*t*b+t*t*t;\n}\nfloat cub(float x,vec2 a,vec2 b){\n    vec2 it=vec2(0.,1.);\n    for (int i=0;i<7;i++) {\n        float pos=(it.x+it.y)/2.;\n        vec2 r=cub_(pos,a,b);\n        if (r.x>x){\n            it.y=pos;\n        }else{\n            it.x=pos;\n        }\n    }\n    return cub_((it.x+it.y)/2.,a,b).y;\n}\nfloat isine(float t){return -1.*cos(t*HALFPI)+1.;}\nfloat osine(float t){return sin(t*HALFPI);}\nfloat iquad(float t){return t*t;}\nfloat oc(float t){t=t-1.;return t*t*t+1.;}\nvec2 oc(vec2 v){return vec2(oc(v.x),oc(v.y));}\nfloat icirc(float t){return -1.*(sqrt(1.-t*t)-1.);}\nvec3 spin(vec3 col_,vec2 fc) {\n    vec3 col=col_;\n    float a=mod(degrees(atan2(fc-iResolution.xy/2.-.5)),360.);\n    float b=mod(iTime*100.,360.);\n    float s=25.;\n    float mi=mod(b-s,360.);\n    float ma=mod(b+s,360.);\n    float d=abs(b-a);\n    if(d>180.)d=a<b?a-b+360.:b+360.-a;\n    if((a>mi||(mi>ma&&a<ma))&&(a<ma||mi>ma))col+=1.-iquad(d/s);\n    return col;\n}\nfloat mb(){\n    return clamp(texture(iChannel0,vec2(0.02,0.2)),0.,1.).x;\n}\nvec3 barz(float d,vec2 fc,float off,float sp) {\n    float a=degrees(atan2(fc-iResolution.xy/2.-.5))/180.+1.;\n    a=mod(a+iTime/sp+off+mb()/3.,2.);\n    a-=1.;\n    if(a<0.)a=-a+0.01;\n    float m=mod(a,.025);\n    if(m<0.01*(1.+d*.6))return vec3(0.);\n    a-=m;\n    float v=clamp(texture(iChannel0,vec2(a,0.1)).x,0.,1.);\n    if (v>d) return vec3(1.);\n    return vec3(0.);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n    float s = 1.2-texture(iChannel0, vec2(0.52,0.2)).x*.4;\n    vec2 uv = fragCoord/iResolution.xy * s-(s-1.)*.5;\n    uv.x *= iResolution.x/iResolution.y;\n    \n    vec3 col = COLOR;\n    \n    // Generate all dem triangles\n    for (float i = TRI; i > 0.1; i--){\n        float id = i / TRI;\n        float y = yPos(id);\n        float x = xPos(id, y);\n        float s = min(0.89, max(0.071, id * 0.5));\n        float shad = tri(\n            uv,\n            vec2(x, mix(-s, 3.0 + s / 2.0, y)),\n            s\n        );\n        \n        if (shad < 0.1)\n        \tcol = triCol(id, y) * (1.0 - shad);\n    }\n    \n    // Set background mask\n    vec2 mid=vec2(.5*iResolution.x/iResolution.y,.5);\n    float dist = distance(uv,mid);\n    if (dist > 0.4) {\n        col = vec3(0.0);\n        if (dist<0.65){\n            float sp=3.;\n            float el=.1+.2*mb();\n            float d=(dist-.4)/.25;\n          \tcol+=barz(d,fragCoord,0.,sp);\n          \tcol+=barz(d,fragCoord,.5,sp);\n          \tcol+=barz(d,fragCoord,1.,sp);\n          \tcol+=barz(d,fragCoord,1.5,sp);\n            col*=el;\n            col.x*=.75;\n            col.y*=.75;\n        }\n    } else\n        if(dist>0.32&&dist<0.37)col=spin(col,fragCoord);\n    \n    // Make circle logo shadow\n    float dist_shad = distance(uv, vec2(0.5 * iResolution.x / iResolution.y, 0.49));\n    float l_shad = abs(dist_shad - 0.4);\n    col *= mix(0.3, 1.0, min(1.0, l_shad * 30.0));\n    \n    // Make circle logo\n    float l = abs(dist - 0.5);\n    col += vec3(smoothstep(0.96, 0.97, 1.0 - l));\n\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": "XdXGRr", "previewfilepath": "/presets/mic.png", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/presets/mic.png", "ctype": "mic"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4ldcRn.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 270, 291, 291, 389], [391, 391, 427, 427, 652], [654, 654, 674, 674, 766], [768, 768, 797, 797, 864], [866, 866, 896, 896, 997], [999, 999, 1030, 1030, 1169], [1170, 1170, 1190, 1190, 1213], [1214, 1214, 1250, 1250, 1278], [1279, 1279, 1312, 1312, 1376], [1377, 1377, 1410, 1410, 1663], [1664, 1664, 1685, 1685, 1714], [1715, 1715, 1736, 1736, 1758], [1759, 1759, 1780, 1780, 1792], [1793, 1793, 1811, 1811, 1835], [1836, 1836, 1852, 1852, 1882], [1883, 1883, 1904, 1904, 1934], [1935, 1935, 1965, 1965, 2297], [2298, 2298, 2309, 2309, 2372], [2373, 2373, 2420, 2420, 2741], [2743, 2743, 2797, 2797, 4347]], "test": "untested"}
{"id": "4ldcW8", "name": "Dynamic bitflipping", "author": "dust", "description": "A bitflip shader forked from https://www.shadertoy.com/view/4ldyW8", "tags": ["hsv", "fork", "xor", "or", "bitflip"], "likes": 2, "viewed": 98, "published": "Public", "date": "1532429035", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Shamelessly adapted from \n// https://www.shadertoy.com/view/4ldyW8\n// by python273\n\n// HSV/RGB conversion function from python273\nvec3 hsv2rgb(vec3 c) {\n  vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n  vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n  return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    int xor = int(fragCoord.x + iTime * 80.0 + iMouse.x * 10.0)\n        \t  ^  // try & |\n        \t  int(fragCoord.y + iTime * 80.0 + iMouse.y * 10.0);\n    \n    int or = int(fragCoord.x + iTime * 80.0 + iMouse.x * 10.0)\n        \t |  // try & |\n        \t int(fragCoord.y + iTime * 80.0 + iMouse.y * 10.0);\n    float temp = float(xor) + cos(cos(float(or) * 10.0f) * cos(iTime));\n    vec3 rgb = hsv2rgb(vec3(sin(temp), 1.0, cos(temp)));\n    vec3 procRGB = vec3(fragCoord.x / iResolution.x, cos(iTime), sin(iTime));\n    fragColor = vec4(cross(rgb, vec3(rgb.g, dot(rgb, procRGB), length(procRGB))).rg * vec2(0.8, 1.0), rgb.b, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4ldcW8.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[87, 133, 155, 155, 318], [320, 320, 377, 377, 1005]], "test": "untested"}
{"id": "4ldyR7", "name": "squircle silly throwaway test", "author": "mds2", "description": "trying to find alternate fast soft min and soft max approaches, just an experiment", "tags": ["squircle", "piet", "hein"], "likes": 0, "viewed": 62, "published": "Public", "date": "1532040350", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float squircle_max(in float x, in float y, float off) {\n    float x2 = (x + off) * (x + off);\n    float x4 = x2 * x2;\n    float y2 = (y + off) * (y + off);\n    float y4 = y2 * y2;\n    return sqrt(sqrt(x4 + y4)) - off;\n}\n\nfloat squircle_min(in float x, in float y) {\n    return 0.0;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (2.0 * fragCoord - iResolution.xy) / iResolution.y;\n    \n    float d1 = length(uv - vec2(-0.45 - 0.45 * sin(iTime), 0.0));\n    float d2 = length(uv - vec2(0.25, 0.0));\n\n    float squircle_norm_out =\n        squircle_max(max(0.0, 1.0 - d1), max(0.0, 1.0 - d2), 0.0);\n    \n    float dist_out = squircle_norm_out - 0.5;\n    float pix_per_unit = 0.5 * iResolution.y;\n    \n    float outsideness = clamp(dist_out * pix_per_unit, 0.0, 1.0);\n    \n    float c1_inside = clamp((d1 - 0.5) * pix_per_unit, 0.0, 1.0);\n    float c2_inside = clamp((d2 - 0.5) * pix_per_unit, 0.0, 1.0);\n\n    // Output to screen\n    fragColor = vec4(1.0 - c1_inside, 1.0 - c2_inside, outsideness,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4ldyR7.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 55, 55, 219], [221, 221, 265, 265, 283], [285, 285, 342, 392, 1077]], "test": "untested"}
{"id": "4ldyR8", "name": "My take on BigWings' voronoi-tut", "author": "MacSlow", "description": "My take on BigWings' voronoi-pattern tutorial available here https://www.youtube.com/watch?v=l-07BXzNdPw\n\nDoing it in the fragment-shader is so much easier than the \"traditional\" way with polygonal data! Next step 3D and more colors.", "tags": ["2d", "voronoi"], "likes": 9, "viewed": 573, "published": "Public API", "date": "1531575221", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec2 noise2d (in vec2 p)\n{\n\tvec3 v = fract (p.xyx*vec3(123.34, 234.34, 345.65));\n\tv += dot (v, v + 34.45);\n\treturn fract (vec2 (v.x*v.y, v.y*v.z));\n}\n\nmat2 r2d (in float degree)\n{\n\tfloat rad = radians (degree);\n    float c = cos (rad);\n    float s = sin (rad);\n    return mat2 (c, s, -s, c);\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n\tfloat time = iTime + 3.;\n\n    // normalize and aspect-correct UVs\n    vec2 uv = fragCoord/iResolution.xy*2. - 1.;\n\tfloat aspect = iResolution.x/iResolution.y;\n    uv.x *= aspect;\n\n    // rotate and move the canvas\n    uv *= r2d (24.*time);\n    uv += vec2 (.2*cos (time), .3*sin(time));\n\n    // cause the canvas to 'zoom'\n    float scale = 3. + 3.*(.5 + .5*cos(time));\n    uv *= scale;\n    float rowSize = scale *.5;\n\n    // split canvas up\n    vec2 gv = fract (uv) - .5;\n    vec2 id = floor (uv);\n\n    float cellIndex = .0; \n    float minDist = 2.;\n\n    // check only the adjacent grid-cells\n    for (float y = -1.; y <= 1.; ++y) {\n        for (float x = -1.; x <= 1.; ++x) {\n            vec2 offset = vec2 (x, y); \n            vec2 n = noise2d (id + offset);\n            vec2 p = offset + .5*sin (n*(time + 22.75));\n            float d = dot (gv - p, gv - p);\n            if (d < minDist) {\n                minDist = d;\n                cellIndex = (id.y + y) * rowSize + (id.x + x); \n            }\n        }\n    }   \n\n    // 'color' cells in different styles\n    float brightColor = (1. - minDist)*(1. - minDist);\n    float darkColor = minDist*minDist;\n    float flatColor = abs (cellIndex) / (scale*scale);\n    float invertedFlatColor = 1. - flatColor;\n\n    // blend between the four different style-variations\n    float colorOne = mix (brightColor, darkColor, (.5 + .5*cos(1.75*time)));\n    float colorTwo = mix (flatColor, invertedFlatColor, (.5 + .5*cos(1.75*time)));\n    vec3 colorFinal = vec3 (mix (colorOne, colorTwo, .5 + .5*cos(.35*time)));\n\n    // tone-map, gamma-correct\n    //colorFinal = colorFinal / (1. + colorFinal);\n    colorFinal = pow (colorFinal, vec3 (1./2.2));\n\n    fragColor = vec4 (colorFinal, 1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4ldyR8.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 26, 26, 149], [151, 151, 179, 179, 293], [295, 295, 351, 351, 2078]], "test": "untested"}
{"id": "4ldyW8", "name": "XOR what are you doing?", "author": "python273", "description": "~", "tags": ["xorpattern"], "likes": 11, "viewed": 700, "published": "Public API", "date": "1532420518", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec3 hsv2rgb(vec3 c) {\n  vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n  vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n  return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float temp = float(\n        int(fragCoord.x + iTime * 80.0 + iMouse.x * 10.0)\n        ^  // try & |\n        int(fragCoord.y + iTime * 80.0 + iMouse.y * 10.0)\n    );\n\n    fragColor = vec4(hsv2rgb(vec3(sin(temp), 1.0, cos(temp))), 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4ldyW8.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 22, 22, 185], [187, 187, 244, 244, 485]], "test": "untested"}
{"id": "4ldyzH", "name": "Chromodynamics", "author": "marsipan", "description": "Experimenting with 2D animations. :-) ", "tags": ["experiments", "ellipsis"], "likes": 2, "viewed": 130, "published": "Public", "date": "1531687987", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI 3.141593\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n    float px = 2.0/iResolution.y;\n    float ar = iResolution.x / iResolution.y ;\n    //uv = uv - vec2(0.5*ar,0.5) ;\n    // Time varying pixel color\n    //vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n    vec2 mm = vec2(iMouse.xy/iResolution.xy);\n    //mm.x *= ar ;\n    //mm = vec2(0.0,-0.0) ;\n    float fact = 1.0+0.5*sin(iTime*2.0*PI/3.0) ;\n    //uv *= fact ;\n    \n    //Backgound\n    float sd = 0.1 ;\n    float t = iTime ;\n    vec3 col = vec3(0.2,0,0) ;\n    col.r = 0.5*sign((mod(uv.x+0.3*sin(0.4*t),sd)-0.5*sd)*(mod(uv.y+0.3*sin(0.4*t),sd)-0.5*sd)) ;\n    \n    \n    \n    // Balls\n    vec2 b1 = vec2(0.5,0.0)+(0.6,0.6)*sin(0.3*iTime+iTime) ;\n    vec2 b2 = vec2(-0.5,0.0)+(-0.3,0.6)*sin(0.6*iTime) ;\n    vec2 b3 = vec2(0.5,0.2)+(-0.6,-0.8)*sin(0.6*iTime+0.2) ;\n    float d1 = length(b1-uv) ; \n    col = mix(col, vec3(1.0,0.0,0.0), 1.0-smoothstep(0.10,0.10+px,d1)) ;\n    float d2 = length(b2-uv) ; \n    col = mix(col, vec3(0.0,1.0,0.0), 1.0-smoothstep(0.10,0.10+px,d2)) ;\n    float d3 = length(b3-uv) ; \n    col = mix(col, vec3(0.0,0.0,1.0), 1.0-smoothstep(0.10,0.10+px,d3)) ;\n    col = mix(col, vec3(1.0,1.0,0.0),1.0-smoothstep(0.01,0.01+3.0*px,abs((d1+d2)-1.6)));\n    col = mix(col, vec3(0.0,1.0,1.0),1.0-smoothstep(0.01,0.01+3.0*px,abs((d2+d3)-1.6)));\n    col = mix(col, vec3(1.0,0.0,1.0),1.0-smoothstep(0.01,0.01+3.0*px,abs((d1+d3)-1.6)));\n   \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4ldyzH.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[21, 21, 78, 128, 1598]], "test": "untested"}
{"id": "4ldyzN", "name": "Varying color circle", "author": "dimeji", "description": "Just getting the hang of shadertoy", "tags": ["simple", "tutorial", "beginner", "circle", "shape", "novice"], "likes": 0, "viewed": 116, "published": "Public", "date": "1531841019", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float radius = 0.25;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Center the circle\n    uv -= 0.5;\n\n    uv.x *= iResolution.x/iResolution.y;\n\n    // Time varying pixel color\n    vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n\n    // Black\n    vec3 black = vec3(0.0, 0.0, 0.0);\n\n    float x_squared = pow(uv.x, 2.0);\n    float y_squared = pow(uv.y, 2.0);\n\n    if(x_squared + y_squared > pow(radius, 2.0)) {\n        fragColor = vec4(black,1.0);\n    }\n    else {\n        fragColor = vec4(col,1.0);\n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4ldyzN.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[22, 22, 79, 129, 619]], "test": "untested"}
{"id": "4ltcDM", "name": "G9", "author": "t0916004", "description": "Graphics rendering.", "tags": ["3d"], "likes": 1, "viewed": 78, "published": "Public", "date": "1532881450", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//============================================================================\n// PROJECT ID: <your Project ID is an integer equal to 62 + group_no.>\n//\n// GROUP NUMBER:\n//\n// STUDENT NAME: \n// NUS User ID.: \n//\n// STUDENT NAME: \n// NUS User ID.: \n//\n// STUDENT NAME: \n// NUS User ID.: \n//\n// COMMENTS TO GRADER: \n//\n//============================================================================\n\n\n// FRAGMENT SHADER FOR SHADERTOY\n// Run this at https://www.shadertoy.com/new\n// See documentation at https://www.shadertoy.com/howto\n\n// Your browser must support WebGL 2.0.\n// Check your browser at http://webglreport.com/?v=2\n\n\n//============================================================================\n// Constants.\n//============================================================================\nconst int NUM_LIGHTS = 2;\nconst int NUM_MATERIALS = 10;\nconst int NUM_PLANES = 5;\nconst int NUM_SPHERES = 6;\n\nconst vec3 BACKGROUND_COLOR = vec3(0.0, 0.0, 0.0);\n\n // Vertical field-of-view angle of camera. In radians.\nconst float FOVY = 50.0 * 3.1415926535 / 180.0; \n\n// Use this for avoiding the \"epsilon problem\" or the shadow acne problem.\nconst float DEFAULT_TMIN = 10.0e-4;\n\n// Use this for tmax for non-shadow ray intersection test.\nconst float DEFAULT_TMAX = 10.0e6;\n\n// Equivalent to number of recursion levels (0 means ray-casting only).\n// We are using iterations to replace recursions.\nconst int NUM_ITERATIONS = 2;\n\n\n//============================================================================\n// Define new struct types.\n//============================================================================\nstruct Ray_t {\n    vec3 o;  // Ray Origin.\n    vec3 d;  // Ray Direction. A unit vector.\n};\n\nstruct Plane_t {\n    // The plane equation is Ax + By + Cz + D = 0.\n    float A, B, C, D;\n    int materialID;\n};\n\nstruct Sphere_t {\n    vec3 center;\n    float radius;\n    int materialID;\n};\n\nstruct Light_t {\n    vec3 position;  // Point light 3D position.\n    vec3 I_a;       // For Ambient.\n    vec3 I_source;  // For Diffuse and Specular.\n};\n\nstruct Material_t {\n    vec3 k_a;   // Ambient coefficient.\n    vec3 k_d;   // Diffuse coefficient.\n    vec3 k_r;   // Reflected specular coefficient.\n    vec3 k_rg;  // Global reflection coefficient.\n    vec3 k_rag;\n    float n;    // The specular reflection exponent. Ranges from 0.0 to 128.0. \n    float Eta;\n};\n\n//----------------------------------------------------------------------------\n// The lighting model used here is similar to that on Slides 8 and 12 of \n// Lecture 11 (Ray Tracing). Here it is computed as\n//\n//     I_local = SUM_OVER_ALL_LIGHTS { \n//                   I_a * k_a + \n//                   k_shadow * I_source * [ k_d * (N.L) + k_r * (R.V)^n ]\n//               }\n// and\n//     I = I_local  +  k_rg * I_reflected\n//----------------------------------------------------------------------------\n\n\n//============================================================================\n// Global scene data.\n//============================================================================\nPlane_t Plane[NUM_PLANES];\nSphere_t Sphere[NUM_SPHERES];\nLight_t Light[NUM_LIGHTS];\nMaterial_t Material[NUM_MATERIALS];\nbool isInside;\n\n\n\n/////////////////////////////////////////////////////////////////////////////\n// Initializes the scene.\n/////////////////////////////////////////////////////////////////////////////\nvoid InitScene()\n{\n    // Horizontal plane.\n    Plane[0].A = 0.0;\n    Plane[0].B = 1.0;\n    Plane[0].C = 0.0;\n    Plane[0].D = 0.0;\n    Plane[0].materialID = 9;\n\n    // Vertical plane.\n    Plane[1].A = 0.0;\n    Plane[1].B = 0.0;\n    Plane[1].C = 1.0;\n    Plane[1].D = 4.0;\n    Plane[1].materialID = 0;\n\n    Plane[2].A = 1.0;\n    Plane[2].B = 0.0;\n    Plane[2].C = 0.0;\n    Plane[2].D = 4.0;\n    Plane[2].materialID = 0;\n\n     Plane[3].A = 0.0;\n    Plane[3].B = 0.0;\n    Plane[3].C = 1.0;\n    Plane[3].D = -4.0;\n    Plane[3].materialID = 0;\n\n     Plane[4].A = 1.0;\n    Plane[4].B = 0.0;\n    Plane[4].C = 0.0;\n    Plane[4].D = -4.0;\n    Plane[4].materialID = 0;\n\n   // Center bouncing sphere.\n\tSphere[0].center = vec3(0.0, abs(sin(6.0 * iTime)) + 0.7, 0.0);\n\tSphere[0].radius = 0.7;\n\tSphere[0].materialID = 3;\n\n\t// Circling sphere.\n\tSphere[1].center = vec3(2.0 * cos(iTime), 1.0 + 0.5 * cos(iTime), 2.0 * sin(iTime));\n\tSphere[1].radius = 0.5;\n\tSphere[1].materialID = 2;\n\n\t//\n\tSphere[2].center = vec3(0.5*abs(sin(2.0*iTime)) + 1.0, 0.3, 0.0);\n\tSphere[2].radius = 0.3;\n\tSphere[2].materialID = 1;\n\n\t//\n\tSphere[3].center = vec3(1.0, 1.5, 0.5);\n\tSphere[3].radius = 0.1;\n\tSphere[3].materialID = 5;\n\n\t//\n\tSphere[4].center = vec3(-2.0 * cos(iTime), 1.0 - 0.5 * cos(iTime), -2.0 * sin(iTime));\n\tSphere[4].radius = 0.3;\n\tSphere[4].materialID = 4;\n\n\t//\n\tSphere[5].center = vec3(-2.6 * cos(1.5 * iTime), abs(2.2 - 1.0 * sin(iTime)), -2.6 * sin(1.5 * iTime));\n\tSphere[5].radius = 0.25;\n\tSphere[5].materialID = 6;\n    \n    \n    // Silver material.\n    Material[0].k_d = vec3( 0.5, 0.5, 0.5 );\n   Material[0].k_a = 0.2 * Material[0].k_d;\n\tMaterial[0].k_r = 2.0 * Material[0].k_d;\n\tMaterial[0].k_rg = 0.2 * Material[0].k_r;\n    Material[0].k_rag = vec3(0.0);\n\tMaterial[0].n = 64.0;\n    Material[0].Eta = 1.0;\n\n    // Gold material.\n    Material[1].k_d = vec3( 0.8, 0.7, 0.1 );\n    Material[1].k_a = 0.2 * Material[1].k_d;\n    Material[1].k_r = 2.0 * Material[1].k_d;\n    Material[1].k_rg = 0.1 * Material[1].k_r;\n    Material[1].k_rag = vec3(1.0);\n    Material[1].n = 64.0;\n    Material[1].Eta = 1.5;\n\n    // Green plastic material.\n    Material[2].k_d = vec3( abs(sin(0.2*iTime)), abs(sin(0.2*iTime + 1.0)), abs(sin(0.2*iTime + 2.0)) );\n    Material[2].k_a = 0.0 * Material[2].k_d;\n    Material[2].k_r = vec3( 0.2);\n    Material[2].k_rg =vec3(0.1);\n    Material[2].k_rag = vec3(1.0);\n    Material[2].n = 16.0;\n    Material[2].Eta = 1.5;\n\n    \n    //Glass material\n    Material[3].k_d = vec3( 0.5, 0.5, 0.5 );\n    Material[3].k_a = 0.1 * Material[3].k_d;\n    Material[3].k_r = vec3( 1.0, 1.0, 1.0 );\n    Material[3].k_rg = 0.1 * Material[2].k_r;\n    Material[3].k_rag = vec3(1.0);\n    Material[3].n = 20.0;\n    Material[3].Eta = 1.5;\n\n\n    // Red    \n    Material[4].k_d = vec3( 0.8, 0.0, 0.0 );\n    Material[4].k_a = 0.2 * Material[4].k_d;\n    Material[4].k_r = 2.0 * Material[4].k_d;\n    Material[4].k_rg = 0.2 * Material[4].k_r;\n    Material[4].k_rag = vec3(0.0);\n    Material[4].n = 64.0;\n    Material[4].Eta = 1.5;\n\n    // Blue\n    Material[5].k_d = vec3(0.0, 0.0, 0.8);\n\tMaterial[5].k_a = 0.2 * Material[5].k_d;\n\tMaterial[5].k_r = 2.0 * Material[5].k_d;\n\tMaterial[5].k_rg = 0.2 * Material[5].k_r;\n    Material[5].k_rag = vec3(0.0);\n\tMaterial[5].n = 64.0;\n    Material[5].Eta = 1.0;\n\n\n\t//Blue2\n\tMaterial[6].k_d = vec3(0.0, 0.7, 0.8);\n\tMaterial[6].k_a = 0.2 * Material[6].k_d;\n\tMaterial[6].k_r = 2.0 * Material[6].k_d;\n\tMaterial[6].k_rg = 0.5 * Material[6].k_r;\n    Material[6].k_rag = vec3(0.0);\n\tMaterial[6].n = 128.0;\n    Material[6].Eta = 1.2;\n\n     // Black.\n    Material[7].k_d = vec3( 0.1, 0.1, 0.1 );\n    Material[7].k_a = vec3(0.0);\n\tMaterial[7].k_r = 2.0 * Material[7].k_d;\n\tMaterial[7].k_rg = 0.2 * Material[7].k_r;\n    Material[7].k_rag = vec3(0.0);\n\tMaterial[7].n = 64.0;\n    Material[7].Eta = 1.0;\n\n     //wRITE.\n    Material[8].k_d = vec3( 1.0, 1.0, 1.0 );\n    Material[8].k_a = vec3(0.0);\n    Material[8].k_r = vec3(0.1);\n    Material[8].k_rg = vec3(1.0);\n    Material[8].k_rag = vec3(0.0);\n    Material[8].n = 1.0;\n    Material[8].Eta = 1.0;\n\n\n      Material[9].k_d = vec3( 0.2, 0.2, 0.2 );\n   Material[9].k_a = 0.0 * Material[9].k_d;\n\tMaterial[9].k_r = 5.0 * Material[9].k_d;\n\tMaterial[9].k_rg = 1.0 * Material[9].k_r;\n    Material[9].k_rag = vec3(0.0);\n\tMaterial[9].n = 40.0;\n    Material[9].Eta = 1.0;\n    // Light 0.\n//    Light[0].position = vec3( 4.0, 8.0, -3.0 );\n    Light[0].position = vec3( 4.0, 8.0+sin(iTime), -3.0);\n    Light[0].I_a = vec3( 0.1, 0.1, 0.1 );\n    Light[0].I_source = 0.1 * vec3( 1.0, 1.0, 1.0 );\n\n    // Light 1.\n    Light[1].position = vec3( -3.0, 8.0, 0.0 );\n    Light[1].I_a = vec3( 0.1, 0.1, 0.1 );\n    Light[1].I_source = (abs(sin(0.2 *iTime))+0.5) * vec3( 1.0, 1.0, 1.0 );\n}\n\n\n\n/////////////////////////////////////////////////////////////////////////////\n// Computes intersection between a plane and a ray.\n// Returns true if there is an intersection where the ray parameter t is\n// between tmin and tmax, otherwise returns false.\n// If there is such an intersection, outputs the value of t, the position\n// of the intersection (hitPos) and the normal vector at the intersection \n// (hitNormal).\n/////////////////////////////////////////////////////////////////////////////\nbool IntersectPlane( in Plane_t pln, in Ray_t ray, in float tmin, in float tmax,\n                     out float t, out vec3 hitPos, out vec3 hitNormal ) \n{\n    vec3 N = vec3( pln.A, pln.B, pln.C );\n    float NRd = dot( N, ray.d );\n    float NRo = dot( N, ray.o );\n    float t0 = (-pln.D - NRo) / NRd;\n    if ( t0 < tmin || t0 > tmax ) return false;\n\n    // We have a hit -- output results.\n    t = t0;\n    hitPos = ray.o + t0 * ray.d;\n    hitNormal = normalize( N );\n    return true;\n}\n\n\n\n/////////////////////////////////////////////////////////////////////////////\n// Computes intersection between a plane and a ray.\n// Returns true if there is an intersection where the ray parameter t is\n// between tmin and tmax, otherwise returns false.\n/////////////////////////////////////////////////////////////////////////////\nbool IntersectPlane( in Plane_t pln, in Ray_t ray, in float tmin, in float tmax )\n{\n    vec3 N = vec3( pln.A, pln.B, pln.C );\n    float NRd = dot( N, ray.d );\n    float NRo = dot( N, ray.o );\n    float t0 = (-pln.D - NRo) / NRd;\n    if ( t0 < tmin || t0 > tmax ) return false;\n    return true;\n}\n\n\n\n/////////////////////////////////////////////////////////////////////////////\n// Computes intersection between a sphere and a ray.\n// Returns true if there is an intersection where the ray parameter t is\n// between tmin and tmax, otherwise returns false.\n// If there is one or two such intersections, outputs the value of the \n// smaller t, the position of the intersection (hitPos) and the normal \n// vector at the intersection (hitNormal).\n/////////////////////////////////////////////////////////////////////////////\nbool IntersectSphere( in Sphere_t sph, in Ray_t ray, in float tmin, in float tmax,\n                      out float t, out vec3 hitPos, out vec3 hitNormal ) \n{\n    /////////////////////////////////\n    // TASK: WRITE YOUR CODE HERE. //\n\n    ray.o -= sph.center;\n    float b = 2.0 * dot(ray.d, ray.o); // b \n    float c = dot(ray.o, ray.o) - sph.radius * sph.radius; // c\n    float d = b * b - 4.0 * c; \n    isInside = false;\n    if(d > 0.0)\n    {\n        float t_positive = (-b + sqrt(max(0.0, d))) / 2.0;\n        float t_negative = (-b - sqrt(max(0.0, d))) / 2.0; \n        if(min(t_negative, t_positive) <= DEFAULT_TMIN && max(t_negative, t_positive) > DEFAULT_TMIN){\n            isInside = true;\n            t = max(t_negative, t_positive);\n            hitPos = ray.o + sph.center + t * ray.d;\n            hitNormal = normalize(ray.o + t * ray.d);\n            return true;          \n        }\n\n        if(t_negative > tmin && t_negative < tmax)\n        {\n            t = t_negative;\n            hitPos = ray.o + sph.center + t * ray.d;\n            hitNormal = normalize(ray.o + t * ray.d);\n            return true;\n        }\n        else if(t_positive > tmin && t_positive < tmax)\n        {\n            t = t_positive;\n            hitPos = ray.o + sph.center + t * ray.d;\n            hitNormal = normalize(ray.o + t * ray.d);\n            return true;\n        }\n        \n    }\n    /////////////////////////////////\n    return false;  // Replace this with your code.\n}\n\n\n\n/////////////////////////////////////////////////////////////////////////////\n// Computes intersection between a sphere and a ray.\n// Returns true if there is an intersection where the ray parameter t is\n// between tmin and tmax, otherwise returns false.\n/////////////////////////////////////////////////////////////////////////////\nbool IntersectSphere( in Sphere_t sph, in Ray_t ray, in float tmin, in float tmax )\n{\n    /////////////////////////////////\n    // TASK: WRITE YOUR CODE HERE. //\n   \n    // Transform the ray to the sphere's local coordinate frame\n    ray.o -= sph.center;\n    float b = 2.0 * dot(ray.d, ray.o); // b \n    float c = dot(ray.o, ray.o) - sph.radius * sph.radius; // c\n    float d = b * b - 4.0 * c; \n    if(d > 0.0)\n    {\n        float t_positive = (-b + sqrt(max(0.0, d))) / 2.0;\n        float t_negative = (-b - sqrt(max(0.0, d))) / 2.0; \n        if((t_negative > tmin && t_negative < tmax) || (t_positive > tmin && t_positive < tmax))\n            return true;\n    }\n    /////////////////////////////////\n    return false;  // Replace this with your code.\n\n}\n\n\n/////////////////////////////////////////////////////////////////////////////\n// Computes (I_a * k_a) + k_shadow * I_source * [ k_d * (N.L) + k_r * (R.V)^n ].\n// Input vectors L, N and V are pointing AWAY from surface point.\n// Assume all vectors L, N and V are unit vectors.\n/////////////////////////////////////////////////////////////////////////////\nvec3 PhongLighting( in vec3 L, in vec3 N, in vec3 V, in bool inShadow, \n                    in Material_t mat, in Light_t light )\n{\n    if ( inShadow ) {\n        return light.I_a * mat.k_a;\n    }\n    else {\n        vec3 R = reflect( -L, N );\n        float N_dot_L = max( 0.0, dot( N, L ) );\n        float R_dot_V = max( 0.0, dot( R, V ) );\n        float R_dot_V_pow_n = ( R_dot_V == 0.0 )? 0.0 : pow( R_dot_V, mat.n );\n\n        return light.I_a * mat.k_a + \n               light.I_source * (mat.k_d * N_dot_L + mat.k_r * R_dot_V_pow_n);\n    }\n}\n\n\n/////////////////////////////////////////////////////////////////////////////\n// Casts a ray into the scene and returns color computed at the nearest\n// intersection point. The color is the sum of light from all light sources,\n// each computed using Phong Lighting Model, with consideration of\n// whether the interesection point is being shadowed from the light.\n// If there is no interesection, returns the background color, and outputs\n// hasHit as false.\n// If there is intersection, returns the computed color, and outputs\n// hasHit as true, the 3D position of the intersection (hitPos), the\n// normal vector at the intersection (hitNormal), and the k_rg value\n// of the material of the intersected object.\n/////////////////////////////////////////////////////////////////////////////\nvec3 CastRay( in Ray_t ray, \n              out bool hasHit, out vec3 hitPos, out vec3 hitNormal, out vec3 k_rg, out vec3 k_rag, out float Eta ) \n{\n    // Find whether and where the ray hits some object. \n    // Take the nearest hit point.\n\n    bool hasHitSomething = false;\n    float nearest_t = DEFAULT_TMAX;   // The ray parameter t at the nearest hit point.\n    vec3 nearest_hitPos;              // 3D position of the nearest hit point.\n    vec3 nearest_hitNormal;           // Normal vector at the nearest hit point.\n    int nearest_hitMatID;             // MaterialID of the object at the nearest hit point.\n\n    float temp_t;\n    vec3 temp_hitPos;\n    vec3 temp_hitNormal;\n    bool temp_hasHit;\n\n    /////////////////////////////////////////////////////////////////////////////\n    // TASK:\n    // * Try interesecting input ray with all the planes and spheres,\n    //   and record the front-most (nearest) interesection.\n    // * If there is interesection, need to record hasHitSomething,\n    //   nearest_t, nearest_hitPos, nearest_hitNormal, nearest_hitMatID.\n    /////////////////////////////////////////////////////////////////////////////\n\n    /////////////////////////////////\n    // TASK: WRITE YOUR CODE HERE. //\n\n    for(int i = 0; i < NUM_PLANES; i++)\n    {\n        if(IntersectPlane(Plane[i], ray, DEFAULT_TMIN, nearest_t, temp_t, temp_hitPos, temp_hitNormal)) // Hit \n        {\n            nearest_t = temp_t;\n            nearest_hitPos = temp_hitPos;\n            nearest_hitNormal = temp_hitNormal;\n            nearest_hitMatID = Plane[i].materialID;            \n        }\n    }\n    for(int i = 0; i < NUM_SPHERES; i++)\n    {\n        if(IntersectSphere(Sphere[i], ray, DEFAULT_TMIN, nearest_t, temp_t, temp_hitPos, temp_hitNormal)) // Hit \n        {\n            nearest_t = temp_t;\n            nearest_hitPos = temp_hitPos;\n            nearest_hitNormal = temp_hitNormal;\n            nearest_hitMatID = Sphere[i].materialID;\n            if(isInside)\n            {\n                hasHitSomething = true;\n                break;\n            }        \n        }\n    }\n    if(nearest_t < DEFAULT_TMAX)\n        hasHitSomething = true;\n    /////////////////////////////////\n\n\n\n    // One of the output results.\n    hasHit = hasHitSomething;\n    if ( !hasHitSomething ) return BACKGROUND_COLOR;\n\n    if(nearest_hitPos.z == -4.0 && nearest_hitPos.x >= -4.0 && nearest_hitPos.x <= 4.0){\n        vec2 p = mod (nearest_hitPos.xy - vec2(-4.0, 0.0), 1.0);\n        if((p.x < 0.5 && p.y < 0.5) || (p.x > 0.5 && p.y > 0.5))\n            nearest_hitMatID = 0;\n        else\n            nearest_hitMatID = 1;\n    }\n    else if(nearest_hitPos.z == 4.0 && nearest_hitPos.x >= -4.0 && nearest_hitPos.x <= 4.0){\n        vec2 p = mod (nearest_hitPos.xy - vec2(-4.0, 0.0), 1.0);\n        if((p.x < 0.5 && p.y < 0.5) || (p.x > 0.5 && p.y > 0.5))\n            nearest_hitMatID = 0;\n        else\n            nearest_hitMatID = 7;\n    }\n    else if(nearest_hitPos.x == -4.0 && nearest_hitPos.z >= -4.0 && nearest_hitPos.z <= 4.0){\n        vec2 p = mod (nearest_hitPos.yz - vec2(0.0, -4.0), 1.0);\n        if((p.x < 0.5 && p.y < 0.5) || (p.x > 0.5 && p.y > 0.5))\n            nearest_hitMatID = 0;\n        else\n            nearest_hitMatID = 4;\n    }\n    else if(nearest_hitPos.x == 4.0 && nearest_hitPos.z >= -4.0 && nearest_hitPos.z <= 4.0){\n         vec2 p = mod (nearest_hitPos.yz - vec2(0.0, -4.0), 1.0);\n        if((p.x < 0.5 && p.y < 0.5) || (p.x > 0.5 && p.y > 0.5))\n            nearest_hitMatID = 0;\n        else\n            nearest_hitMatID = 5;\n    }\n\n    vec3 I_local = vec3( 0.0 );  // Result color will be accumulated here.\n\n    /////////////////////////////////////////////////////////////////////////////\n    // TASK:\n    // * Accumulate lighting from each light source on the nearest hit point. \n    //   They are all accumulated into I_local.\n    // * For each light source, make a shadow ray, and check if the shadow ray\n    //   intersects any of the objects (the planes and spheres) between the \n    //   nearest hit point and the light source.\n    // * Then, call PhongLighting() to compute lighting for this light source.\n    /////////////////////////////////////////////////////////////////////////////\n\n    /////////////////////////////////\n    // TASK: WRITE YOUR CODE HERE. //\n\n    Ray_t shadowRay;\n    for(int i = 0; i < NUM_LIGHTS; i++)\n    {\n        temp_hasHit = false;\n        shadowRay.o = nearest_hitPos;\n        shadowRay.d = normalize(Light[i].position - nearest_hitPos);\n        float maxt = (Light[i].position - shadowRay.o).x / shadowRay.d.x;\n        for(int i = 0; i < NUM_PLANES; i++)\n        {\n            if(IntersectPlane(Plane[i], shadowRay, DEFAULT_TMIN, maxt)) // Hit \n            {\n                temp_hasHit = true;\n                break;\n            }\n        }\n        if(!temp_hasHit)\n        {\n            for(int i = 0; i < NUM_SPHERES; i++)\n            {\n                if(IntersectSphere(Sphere[i], shadowRay, DEFAULT_TMIN, maxt)) // Hit \n                {\n                    temp_hasHit = true;\n                    break;\n                }\n            }\n        }\n        I_local += PhongLighting(shadowRay.d, nearest_hitNormal, -ray.d, temp_hasHit, \n                    Material[nearest_hitMatID], Light[i]);\n\n    }\n    \n    /////////////////////////////////\n\n\n\n    // Populate output results.\n    hitPos = nearest_hitPos;\n    hitNormal = nearest_hitNormal;\n    k_rg = Material[nearest_hitMatID].k_rg;\n    k_rag = Material[nearest_hitMatID].k_rag;\n    Eta = Material[nearest_hitMatID].Eta;\n\n    return I_local;\n}\n\nvec3 myRefract(vec3 ray, vec3 normal, float Eta) {\n    if (isInside ) {\n        normal = - normal;\n\n\t}\n\telse {\n        Eta = 1.0 / Eta;\n\t}\n    return refract(ray, normal, Eta);\n}\n\n/////////////////////////////////////////////////////////////////////////////\n// Execution of fragment shader starts here.\n// 1. Initializes the scene.\n// 2. Compute a primary ray for the current pixel (fragment).\n// 3. Trace ray into the scene with NUM_ITERATIONS recursion levels.\n/////////////////////////////////////////////////////////////////////////////\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    InitScene();\n\n    // Scale pixel 2D position such that its y coordinate is in [-1.0, 1.0].\n    vec2 pixel_pos = (2.0 * fragCoord.xy - iResolution.xy) / iResolution.y;\n\n    // Position the camera.\n    vec3 cam_pos = vec3( (3.5*sin(0.5 * iTime)), 1.0, 3.5*(cos(0.5 * iTime)) );\n   // vec3 cam_pos = vec3( 2.5+(sin(2.0 * iTime)), 1.0, 2.5+(cos(2.0 * iTime)) );\n    vec3 cam_lookat = vec3( 0.25, 1.0, 0.0 );\n    vec3 cam_up_vec = vec3( 0.0, 1.0, 0.0 );\n\n    // Set up camera coordinate frame in world space.\n    vec3 cam_z_axis = normalize( cam_pos - cam_lookat );\n    vec3 cam_x_axis = normalize( cross(cam_up_vec, cam_z_axis) );\n    vec3 cam_y_axis = normalize( cross(cam_z_axis, cam_x_axis));\n\n    // Create primary ray.\n    float pixel_pos_z = -1.0 / tan(FOVY / 2.0);\n    Ray_t pRay;\n    pRay.o = cam_pos;\n    pRay.d = normalize( pixel_pos.x * cam_x_axis  +  pixel_pos.y * cam_y_axis  +  pixel_pos_z * cam_z_axis );\n\n\n    // Start Ray Tracing.\n    // Use iterations to emulate the recursion.\n\n    vec3 I_result = vec3( 0.0 );\n    vec3 compounded_k_rg = vec3( 1.0 );\n    Ray_t nextRay = pRay;\n    \n\n    for ( int level = 0; level <= NUM_ITERATIONS; level++ ) \n    {\n        bool hasHit;\n        vec3 hitPos, hitNormal, k_rg, k_rag;\n        float Eta;\n\n        vec3 I_local = CastRay( nextRay, hasHit, hitPos, hitNormal, k_rg, k_rag, Eta );\n\n        I_result += compounded_k_rg * I_local;\n\n        if ( !hasHit ) break;\n\n        compounded_k_rg *= k_rg;\n\n        nextRay = Ray_t( hitPos, normalize( reflect(nextRay.d, hitNormal) ) );\n        if(level == 0)\n            pRay = Ray_t( hitPos, normalize(myRefract(pRay.d, hitNormal, Eta)) );\n    }\n\n      // Refract\n    compounded_k_rg = vec3(1.0);\n    nextRay = pRay;\n    for ( int level = 0; level <= NUM_ITERATIONS; level++ ) \n    {\n        bool hasHit;\n        vec3 hitPos, hitNormal, k_rg, k_rag;\n        float Eta;\n\n        vec3 I_local = CastRay( nextRay, hasHit, hitPos, hitNormal, k_rg, k_rag, Eta );\n        I_result += compounded_k_rg * I_local;\n        \n        if ( !hasHit ) break;\n        compounded_k_rg *= k_rag;\n        \n    \n        nextRay = Ray_t( hitPos, normalize(myRefract(nextRay.d, hitNormal, Eta)) );\n    }\n\n    fragColor = vec4( I_result, 1.0 );\n}\n\n", "image_inputs": [{"id": "4sXGRr", "previewfilepath": "/media/ap/48e2d9ef22ca6673330b8c38a260c87694d2bbc94c19fec9dfa4a1222c364a99.mp3", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/48e2d9ef22ca6673330b8c38a260c87694d2bbc94c19fec9dfa4a1222c364a99.mp3", "ctype": "music"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4ltcDM.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[3193, 3375, 3393, 3418, 8086], [8090, 8587, 8742, 8742, 9072], [9076, 9408, 9491, 9491, 9703], [9707, 10227, 10385, 10461, 11694], [11698, 12031, 12116, 12260, 12787], [12790, 13144, 13275, 13275, 13688], [13691, 14480, 14626, 14718, 20037], [20039, 20039, 20089, 20089, 20217], [20219, 20580, 20637, 20637, 22862]], "test": "untested"}
{"id": "4ltcRN", "name": "Funky road", "author": "Firzen_", "description": "Just playing around with color compositions.", "tags": ["visualization"], "likes": 4, "viewed": 137, "published": "Public", "date": "1531828903", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define pi (acos(-1.))\n\nvec3 color (float t)\n{\n    vec3 a,b,c,d;\n    a = vec3(0.5);\n    b = vec3(0.5);\n    c = vec3(1.);\n    d = vec3(0., 0.33, 0.66);\n    return a+b*cos(2.*pi*(t*c+d));\n}\n\nvec3 roadCol (float t)\n{\n    vec3 a,b,c,d;\n    a = vec3(0.5);\n    b = vec3(0.5);\n    c = vec3(6.,6.03,6.);\n    d = vec3(0.0, 0.1, 0.);\n    return a+b*cos(2.*pi*(t*c+d));\n}\n\nvec3 offroadCol (vec2 uv, float t)\n{\n    t += cos(uv.x*7.) + sin(0.2+7.*(uv.y+t));\n    vec3 a,b,c,d;\n    a = vec3(0.5, 0.7, 0.5);\n    b = vec3(0.5, 0.8, 0.5);\n    c = vec3(3.,5.,2.);\n    d = vec3(0.25, 0., 0.5);\n    return a+b*cos(2.*pi*(t*c+d));\n}\n\nvec4 rainbow(vec2 uv, float t)\n{\n    uv.x -= 0.8;\n    float dist = pow(uv.x, 2.)+pow(uv.y,2.) + 0.1*t;\n    float brightness = smoothstep(0.3,0.5, dist) * smoothstep(1.3,1.1, dist);\n    return vec4(color(dist), (0.3+t)*brightness);\n}\n\nfloat roadPos(float t)\n{\n    return 0.8 + 0.2*cos(2.1*t) + 0.1*sin(0.2+t);\n}\n\nvec3 road(vec2 uv, float t)\n{\n    float medDist = uv.x - roadPos(t+uv.y);\n    medDist *= (uv.y+0.2);\n    float onRoad = smoothstep(-0.1,-0.09, medDist) * smoothstep(0.1,0.09, medDist);\n    return  mix(offroadCol(vec2(medDist, uv.y), t), roadCol(t+uv.y), onRoad);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.y;\n    \n    float f = texture(iChannel0, vec2(0.001, 0.)).r;\n    float dx = 0.1*f*texture(iChannel0, vec2(uv.y, 0.)).r;\n    \n    float t = iTime + 0.2*f;\n    //periodic acceleration term\n    t = t+cos(0.3*t);\n\n    vec4 rb = rainbow(uv, f);\n    vec3 rd = road(uv + vec2(dx, 0.), t);\n    vec3 col = rb.rgb*rb.a + rd*(1.-rb.a);\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": "4sjXRd", "previewfilepath": "https://soundcloud.com/renelavice/dont-look-down-feat-bullysongs", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0, "src": "https://soundcloud.com/renelavice/dont-look-down-feat-bullysongs", "ctype": "musicstream"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4ltcRN.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[24, 24, 46, 46, 187], [189, 189, 213, 213, 360], [362, 362, 398, 398, 610], [612, 612, 644, 644, 844], [846, 846, 870, 870, 922], [924, 924, 953, 953, 1188], [1190, 1190, 1247, 1247, 1666]], "test": "untested"}
{"id": "4ltcz7", "name": "Gooey Transformations", "author": "momoro", "description": "Friday practice. Getting the hang of using a transformation matrix. Also figuring out how to rotate things around an arbitrary pivot (move st before rotating).", "tags": ["bookofshaders"], "likes": 2, "viewed": 306, "published": "Public API", "date": "1532059565", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec3 rect(vec2 st) {\n    vec2 f = max(abs(st) - .1, 0.);\n\tfloat c = length(f);\n\tc = smoothstep(.1, .101, c);\n    \n    return vec3(1.0 - c);\n}\n\n\nmat2 rotate2d(float _angle) {\n    return mat2(cos(_angle), -sin(_angle),\n                sin(_angle), cos(_angle));\n}\n\nmat2 scale(vec2 _scale) {\n    return mat2(_scale.x, 0.0,\n                0.0, _scale.y);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 st = fragCoord/iResolution.y;\n\tst -= .5;\n    st.x -= .3;\n\n   \n    vec3 color = vec3(0.);\n    float u_time = iTime;\n    \n    float incr = .38 + sin(u_time/5.) / 5. + .2;\n    float offset = cos(u_time/2.)/10. + .2 ;\n    float time = u_time;\n    float s = 1.2;\n    st *= 3.;\n    st *= tan(atan(st.x * st.y + st.x/2.) + sin(u_time * 1.) / 2. + .2);\n    \n    for(float i=0.; i<20.; i++) {\n\t\t//Black square\n        color = clamp(color, vec3(0.,0.,0.), vec3(1.,1.,1.));\n\n    \tcolor = color - rect(scale(vec2(1. * s)) * (rotate2d(i/incr + time) *  (st) + offset));\n\n\t    // White outline \n        color = color + (rect(scale(vec2(.9 * s)) * (rotate2d(i/incr + time) *  (st) + offset)) -\n            \t \t\trect(scale(vec2(1. * s)) * (rotate2d(i/incr + time) *  (st) + offset)));\n    \t\n    }\n    \n    fragColor = vec4(color,1.0);\n\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4ltcz7.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 20, 20, 141], [144, 144, 173, 173, 261], [263, 263, 288, 288, 353], [355, 355, 412, 462, 1292]], "test": "untested"}
{"id": "4ltcz8", "name": "donuts all the way down", "author": "flimshaw", "description": "just messing around", "tags": ["sin"], "likes": 2, "viewed": 64, "published": "Public", "date": "1531534922", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    float mid = (iResolution.x / iResolution.y) * .5;\n//\tuv.x *= iResolution.x / iResolution.y;\n\tuv = uv * 2. - 1.;\n    uv*=.5;\n    uv = abs(uv*.05);\n    uv.x *= iResolution.x / iResolution.y;\n//    uv.x -= .3;\n    \n    // Time varying pixel color\n    vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx*2.+vec3(0,2,4));\n\tfloat d = distance(uv, vec2(mid, .5));\n    \n\tfloat b = smoothstep(0.5, .6, d);\n    float s = 1. - max(d, b);\n    float sm = pow(abs(fract(1.*d+iTime*.1))+.9, 10.);\n    float f = smoothstep(.6, .99, s);\n    // Output to screen\n    fragColor = vec4(vec3(max(1., fract(sm)*5.) * .1 * col),1.0);\n}", "image_inputs": [{"id": "Xsf3zn", "previewfilepath": "/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4ltcz8.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 107, 749]], "test": "untested"}
{"id": "4ltczN", "name": "Spinny Flower", "author": "clintolibre", "description": "A spinning Flower, based on polar coordinates exercise from Book of Shaders", "tags": ["polar", "spin"], "likes": 1, "viewed": 69, "published": "Public", "date": "1531842808", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//inspiried by book of shaders and patriciogv\n\nfloat plot(vec2 st, float pct){\n  return  smoothstep( pct-0.1, pct, st.y) -\n          smoothstep( pct, pct+0.1, st.y);\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 st = fragCoord.xy/iResolution.yy;\n    //st.x = st.x * iResolution.x/iResolution.y;\n    st = st*.5;\n    st.y = st.y + .25;\n    //st.x = st.x - .25*(iResolution.x/iResolution.y);\n    vec3 color = vec3(0.0);\n\n    vec2 pos = vec2(0.5)-st;\n\tvec2 pos2 = vec2(0.5)-st;\n    float r = length(pos)*2.0;\n    float a = atan(pos.y,pos.x);\n    float b = atan(pos2.y,pos2.x);\n\n    float f = cos(a*3.);\n     f = abs(cos(a*3.));\n     f = abs(cos(a*2.5+sin(iTime/2.0)*8.0))*.5+.3;\n\n\tf = plot(st,f);\n    color = vec3( 1.-smoothstep(f,f+0.02,r) );\n\tvec3 col = 0.5 + 0.5*cos(iTime+st.xyx+vec3(0,2,4));\n    fragColor = vec4(col*color, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4ltczN.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 47, 78, 78, 167], [168, 168, 225, 225, 855]], "test": "untested"}
{"id": "4ltyD4", "name": "Happy Plant", "author": "lnae", "description": "Experimenting with a hand-drawn / watercolor effect", "tags": ["raymarching", "watercolor", "npr", "plant"], "likes": 41, "viewed": 731, "published": "Public", "date": "1532681069", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI 3.14159\n#define PHI 1.618\n#define STEPS 50.\n#define EPS 0.00001\n#define EPSN 0.001\n#define EPSOUT 0.008\n#define NB_LEAVES 16.\n\n\nfloat hash(vec3 p){\n\treturn fract(123456.789 * sin(dot(p, vec3(12.34, 56.78, 91.01))));\n}\n\nmat2 rot(float a){\n    float c = cos(a);\n    float s = sin(a);\n\treturn mat2(c, -s, s, c);\n}\n\nfloat smoothmin(float a, float b, float k){\n\tfloat f = clamp(0.5 + 0.5 * (a - b) / k, 0., 1.);\n    return mix(a, b, f) - k * f * (1. - f);\n}\n\nfloat smoothmax(float a, float b, float k){\n\treturn -smoothmin(-a, -b, k);\n}\n\nfloat smoothabs(float p, float k){\n\treturn sqrt(p * p + k * k) - k;\n}\n\nfloat noise(vec3 p){\n\tvec3 f = fract(p);\n    f = f * f * (3. - 2. * f);\n    vec3 c = floor(p);\n  \n    return mix(mix(mix(hash(c), hash(c + vec3(1., 0., 0.)), f.x),\n               \t   mix(hash(c + vec3(0., 1., 0.)), hash(c + vec3(1., 1., 0.)), f.x),\n               \t   f.y),\n               mix(mix(hash(c + vec3(0., 0., 1.)), hash(c + vec3(1., 0., 1.)), f.x),\n               \t   mix(hash(c + vec3(0., 1., 1.)), hash(c + vec3(1., 1., 1.)), f.x),\n               \t   f.y),\n               f.z);  \n}\n\nfloat fbm(vec3 p){\n\tvec3 pos = 10. * p;\n    float c = 0.5;\n    float res = 0.;\n    for(int i = 0; i < 4; i++){\n        pos.xy = rot(2.) * pos.xy;\n        pos = pos * 2. + 2.;\n    \tres += c * noise(pos);\n        c /= 2.;\n    }\n    return res;\n}\n\nfloat distLeaf(vec3 pos, float angle, float size, out float color){\n    float radius = size;\n    float c = 0.95 * radius;\n    pos.xy = rot(angle) * pos.xy;\n\n    //main part\n    pos.y -= 0.02;\n    pos.x -= 0.25 * radius;\n    pos.z = smoothabs(pos.z, 0.0075);\n\tpos.y = -abs(pos.y);\n    float dist = length(pos - vec3(0., c, -0.05)) - radius;\n    \n    //color\n    float r = length(pos.xz) / radius;\n    color = 0.5 + 0.5 * cos(12. * r);\n    \n    //tip\n    pos.x -= 0.175 * radius;\n    pos.z += 0.45 * c;\n   \treturn smoothmin(dist, length(pos - vec3(0., c, 0.)) - (radius * 1.05), 0.005);\n}\n\nfloat distScene(in vec3 pos, out int object, out float colorVariation){\n    \n    pos.yz = rot(0.5 + 0.25 * (0.5 + 0.5 * sin(0.25 * iTime - 0.5 * PI))) * pos.yz;\n    pos.xz = rot(0.25 * iTime) * pos.xz;\n    pos.y += 0.2;\n    \n    float f = noise(100. * pos);\n    float sf = smoothstep(0.4, 0.5, f);\n    \n    //floor\n    float dist = pos.y;\n    object = 0;\n    colorVariation = 0.;\n    \n    //pot\n    vec3 p = pos;\n    p.y -= 0.155;\n    float distPot = length(p) - 0.2;\n    distPot = smoothmax(distPot, p.y - 0.097, 0.01);\n    distPot = smoothmax(distPot, -(length(p) - 0.18), 0.01);\n    distPot = max(distPot, -(p.y + 0.15));\n    dist = min(dist, distPot);\n    \n    if(dist == distPot){\n        object = 1;\n        float angle = atan(p.z, p.x);\n        colorVariation = 0.9 * smoothstep(0.2, 0.35, 0.5 * sin(3. * sin(20. * angle)) + 0.4 * (f - 0.5)) + 0.1 * sf;\n    }\n    \n    //ground\n    float distGround = max(p.y - 0.06 + 0.01 * (noise(150. * p) - 0.5), length(p) - 0.18);\n    dist = min(dist, distGround);\n    \n    if(dist == distGround){\n        object = 2;\n        colorVariation = 0.;\n    }\n    \n\t//plant\n    p = pos;\n    p.y -= 0.2;\n    float distPlant = 100.;\n    float anim = 0.05 * (0.5 + 0.5 * sin(5. * iTime));\n    float leafAngle = 1.2;\n    float offset = 0.01;\n    float size = 0.2;\n    float leafRot = 2. * PI / PHI;\n    float leafColor, lc, d;\n    \n    for(float i = 0.; i < NB_LEAVES; i++){\n        p.xz = rot(leafRot) * p.xz;\n        leafAngle *= 0.92;\n        size *= 1.04;\n        offset += 0.002;\n        d = distLeaf(p - vec3(offset, 0., 0.), leafAngle + anim, size, lc);\n        distPlant = min(distPlant, d); \n        if(d == distPlant) leafColor = lc;\n    }\n    dist = min(dist, distPlant);\n    \n    if(dist == distPlant){\n        object = 3;\n        colorVariation = 0.8 * smoothstep(0.75, 0., leafColor + 0.4 * f) + 0.2 * sf;\n    }\n               \n    return dist;\n}\n\nvec3 getNormal(vec3 p){\n    float c;\n    int o;\n\treturn normalize(vec3(distScene(p + vec3(EPSN, 0., 0.), o, c) - distScene(p - vec3(EPSN, 0., 0.), o, c),\n    \t\t\t\t\t  distScene(p + vec3(0., EPSN, 0.), o, c) - distScene(p - vec3(0., EPSN, 0.), o, c),\n                          distScene(p + vec3(0., 0., EPSN), o, c) - distScene(p - vec3(0., 0., EPSN), o, c)));\n}\n\nvec3 render(vec2 uv){\n    \n    vec3 inkColor = vec3(0.15, 0.25, 0.4);\n    vec3 col = inkColor;\n    \n    //raymarch\n    vec3 eye = vec3(0., 0., 5);\n    vec3 ray = normalize(vec3(uv, 1.) - eye);\n    int o;\n    float dist, step, c, prevDist;\n    bool hit = false;\n    vec3 pos = eye;\n    dist = distScene(pos, o, c);\n    float outline = 1.;\n    \n    for(step = 0.; step < STEPS; step++){\n        prevDist = dist;\n    \tdist = distScene(pos, o, c);\n        if(dist > prevDist + EPS && dist < EPSOUT ){\n        \toutline = min(outline, dist);\n        }\n        if(abs(dist) < EPS){\n        \thit = true;\n            break;\n        }\n    \tpos += dist * ray;\n    }\n    outline /= EPSOUT;\n    \n    vec3 normal = getNormal(pos);\n    float f = fbm(pos);\n    \n    //shading\n    if(hit){\n    \tvec3 light = vec3(5., 5., 5.);\n        light.yz = rot(0.5) * light.yz;\n        float shine = 30.;\n        \n        //paper\n        if(o == 0){\n        \tcol = 1. - 0.025 * vec3(smoothstep(0.6, 0.2, fbm(vec3(uv * 6.,1.))));\n        }\n        //pot\n        if(o == 1) col = mix(vec3(0.6, 0.6, 0.85), vec3(1.), 0.8 * c);\n        if(o == 2) col = vec3(0.6, 0.6, 0.6);\n        //plant\n        if(o == 3) {\n            col = mix(vec3(0.55, 0.86, 0.75), vec3(0.96, 0.6, 0.85), c);\n\t\t\tshine = 5.;\n        }\n        \n        //diffuse\n        vec3 l = normalize(light - pos);\n        float diff = dot(normalize(normal + 0.2 * vec3(f - 0.5)), l);\n        diff = smoothstep(0.4, 0.5, diff + 0.3 * f);\n        if(o != 0) col = mix(col, vec3(0.1, 0.3, 0.75), 0.3 * (1. - diff));\n        \n        //specular\n        vec3 refl = reflect(-l, normal);\n        float spec = pow(dot(normalize(eye - pos), refl), shine);\n        spec = smoothstep(0.5, 0.6, spec + 0.5 * f);\n        col += 0.01 * shine * spec;\n        \n        //outline\n        outline = smoothstep(0.75, 0.95, outline + 0.9 * f);\n        col = mix(inkColor, col, outline);\n    }  \n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.x;\n    uv *= 0.8;\n    vec3 col = render(uv);\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4ltyD4.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[139, 139, 158, 158, 228], [230, 230, 248, 248, 321], [323, 323, 366, 366, 463], [465, 465, 508, 508, 541], [543, 543, 577, 577, 612], [614, 614, 634, 634, 1107], [1109, 1109, 1127, 1127, 1352], [1354, 1354, 1421, 1421, 1940], [1942, 1942, 2013, 2013, 3836], [3838, 3838, 3861, 3861, 4198], [4200, 4200, 4221, 4221, 6123], [6125, 6125, 6182, 6182, 6323]], "test": "untested"}
{"id": "4ltyDM", "name": "runes (simplified version)", "author": "FabriceNeyret2", "description": "simplified glypths from \"runes\" by otaviogood. [url]https://shadertoy.com/view/MsXSRn[/url]", "tags": ["procedural", "font", "letters", "runes"], "likes": 23, "viewed": 706, "published": "Public API", "date": "1532875612", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define S(d,r) smoothstep( r, 0., d)   // antialiased draw. r >= 1.5\n\nfloat line(vec2 p, vec2 a,vec2 b) { // from https://www.shadertoy.com/view/4dcfW8\n    p -= a, b -= a;\n\tfloat h = clamp(dot(p, b) / dot(b, b), 0., 1.);   // proj coord on line\n\treturn length(p - b * h);                         // dist to segment\n}\n\n// --- glyphs simplified from \"runes\" by otaviogood. https://shadertoy.com/view/MsXSRn\n\n// makes a rune in the 0..1 uv space. Seed is which rune to draw.\nfloat Rune(vec2 U, vec2 seed)\n{\n\tfloat d = 1e5;\n\tfor (int i = 0; i < 4; i++)\t// number of strokes\n\t{\n        vec4 pos = vec4( texture(iChannel1, (seed)    / iChannelResolution[1].xy).xy,\n\t\t                 texture(iChannel1, (seed+1.) / iChannelResolution[1].xy).xy \n                        );\n\t\tseed += 2.;\n\t\t// expand the range and mod it to get a nicely distributed random number - hopefully. :)\n\t\tpos = fract(pos * 128.);\n\n\t\t// each rune touches the edge of its box on all 4 sides\n\t\tif (i == 0) pos.y = .0;\n\t\tif (i == 1) pos.x = .999;\n\t\tif (i == 2) pos.x = .0;\n\t\tif (i == 3) pos.y = .999;\n\t\t// snap the random line endpoints to a grid 2x3\n\t\tvec4 snaps = vec4(2, 3, 2, 3);\n\t\tpos = ( floor(pos * snaps) + .5) / snaps;\t\n\n\t\td = min(d, line(U, pos.xy, pos.zw + .001) ); // closest line\n\t}\n\treturn S(d,40./360.); // 20./iResolution.y);\n}\n\nvoid mainImage( out vec4 O,  vec2 U )\n{\n\tU /= iResolution.y;\n\tU.x += iTime * .03;\n   \n\tU += .003 * texture(iChannel0, U*3.).xy; // (optional) distortion\n\tU *= 16.; U.y *= .8;\n\n\tO -= O;\n\tif ( mod(U.y,2.) > 1. ) O += Rune( fract(U), floor(U) );\n}\n\n", "image_inputs": [{"id": "4sXGRn", "previewfilepath": "/media/ap/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg", "ctype": "texture"}, {"id": "XdXGzn", "previewfilepath": "/media/ap/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4ltyDM.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[70, 70, 105, 151, 316], [406, 472, 503, 503, 1307], [1309, 1309, 1348, 1348, 1553]], "test": "untested"}
{"id": "4ltyRn", "name": "Simplex Truchet Weave", "author": "Shane", "description": "Rendering toroidal segments in random order at the vertex positions of triangular grid cells to create a simplex Truchet weave pattern.", "tags": ["triangle", "truchet", "pattern", "weave"], "likes": 27, "viewed": 912, "published": "Public API", "date": "1531403853", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/*\n\n\tSimplex Truchet Weave\n\t---------------------\n\n\tMattz made a pretty cool 2D simplex grid-based Truchet pattern a while back,\n    which sent me on a tangent to make a 3D simplex grid version. At the time, I \n\talso considered making a 2D simplex weave, but got sidetracked -- probably \n\tby another of Mattz's interesting examples. :) Anyway, I finally got around\n\tto it. \n\n\tA hexagonal weave arrangement has more variation, but I think the triangular \n\tversion has a certain tightly wound appeal. I tried to track down an example \n\timage on the internet to reference, but couldn't find one, so didn't know\n\twhat the pattern would look like until I'd coded it. \n\n\tThankfully, the construction process was pretty simple: First, set up a 2D \n\tsimplex grid -- the equilateral triangle one. For each grid (triangle) cell, \n\trender a torus at each of the vertices. Make sure the center of the ring of \n\teach toroidal segment cuts the midpoint of each of the triangle edge lines. \n\tThe magic happens when you render the three tori in random order, which\n\tresults in the spaghetti-like pattern you see.\n\n\tHow one sets about randomizing the rendering order depends upon the preferred \n\ttechnique of the individual, but I've explained how I went about it in the \n\tcode. On a side note, most of the code in this example is window dressing. \n\tThe pattern portion isn't long at all. I might put together a minimal version\n\tto illustrate that... or wait for Fabrice or Greg Rostami o do it. :)\n\n\tI coded this for a bit of fun, but it's possible to apply the pattern to far \n\tmore interesting things. For instance, it can be applied to anthing that's\n\tconstructed with equilateral triangles -- like an icosahedral surface, etc. \n\n\tOn the 3D side, I've already rendered some prisms in a simplex arrangement, \n\tbut I'd like to put together an extruded version of this particular random \n\tpattern at some stage... I'm not looking forward to it, so I hope it looks \n\tinteresting when completed. :)\n\n\tBy the way, there's a \"NO_WEAVE\" option below that is mildy interesting. \n\tPlus, a \"SHOW_SIMPLEX_GRID\" option for anyone who requires a rough visual \n\tcell tile construction aid.\n\n\n\n\tSimilar examples:\n\n\t// A triangular Truchet pattern. This one is rendered in a non-overlapping\n\t// fashion.\n\tslimy triangular truchet - mattz\n\thttps://www.shadertoy.com/view/lsffzX\n\n\t// I was pretty enamored with this example, so posted a 2D and 3D example not \n\t// long afterward.    \n\tHexagonal Truchet Weaving - BigWIngs\n\thttps://www.shadertoy.com/view/llByzz\n\n\n*/\n\n\n// You can order the random object heights from lowest to heighest to render what\n// look like tori randomly stacked on top of one another... I'm probably not \n// describing that very well. Uncommenting will make it clearer, but in essence,\n// the weave involves random render ordering, so to take out the weaving effect,\n// you need to use specific front-to-back ordering.\n//#define NO_WEAVE\n\n// Curve shape - Circle: 0, Hexagon: 1, Dodecahedron: 2.\n#define SHAPE 0 \n\n// A visual aid to enable you to see the simplex cell (triangle) borders.\n//#define SHOW_SIMPLEX_GRID\n\n\n// Standard 2D rotation formula.\nmat2 rot2(in float a){ float c = cos(a), s = sin(a); return mat2(c, -s, s, c); }\n\n\n// Standard 2x2 hash algorithm.\nvec2 hash22(vec2 p) { \n    \n    \n    // Faster, but probaly doesn't disperse things as nicely as other methods.\n    float n = sin(dot(p, vec2(1, 113)));\n    p = fract(vec2(2097152, 262144)*n);\n    \n    //return p*2. - 1.;\n    \n    return sin(p*6.283 + iTime*2.);\n    //return abs(fract(p+ iTime*.5)-.5)*4.-1.; // Snooker.\n    //return abs(cos(p*6.283 + iTime*2.))*2.-1.; // Bounce.\n\n}\n\n\nfloat hash21(vec2 p){\n \n    float n = dot(p, vec2(127.183, 157.927));\n    n = fract(sin(n)*43758.5453);\n    \n    return n;\n    \n    //return sin(n*6.2831853 + iTime*.125)*.5 + .5;\n    //return abs(fract(n + iTime*.125) - .5)*2.;\n    \n}\n \n\n#ifdef SHOW_SIMPLEX_GRID\n// Unsigned distance to the segment joining \"a\" and \"b.\"\nfloat distLine(vec2 a, vec2 b){\n    \n\tb = a - b;\n\tfloat h = clamp(dot(a, b) / dot(b, b), 0., 1.);\n    return length(a - b*h);\n}\n#endif\n\n// Distance metric.\nfloat dist(vec2 p){\n    \n    #if SHAPE == 0\n    return length(p); // Circle.\n    #elif SHAPE == 1\n    p *= rot2(3.14159/12.);\n    p = abs(p);\n    return max(p.y*.8660254 + p.x*.5, p.x); // Hexagon.\n    #else\n    p *= rot2(3.14159/12.);\n    p = abs(p);\n    vec2 p2 = p*.8660254 + p.yx*.5;\n    return max(max(p2.x, p2.y), max(p.x, p.y)); // Dodecahedron.\n    #endif\n    \n}\n\n\n// Simplex Truchet weave function.\n\nvec3 simplexWeave(vec2 p){\n    \n    // Keeping a copy of the orginal position.\n    vec2 oP = p;\n    \n    // Scaling constant.\n    const float gSc = 5.;\n    p *= gSc;\n    \n    \n    // SIMPLEX GRID SETUP\n    \n    vec2 s = floor(p + (p.x + p.y)*.36602540378); // Skew the current point.\n    \n    p -= s - (s.x + s.y)*.211324865; // Use it to attain the vector to the base vertex (from p).\n    \n    // Determine which triangle we're in. Much easier to visualize than the 3D version.\n    float i = p.x < p.y? 1. : 0.; // Apparently, faster than: i = step(p.y, p.x);\n    vec2 ioffs = vec2(1. - i, i);\n    \n    // Vectors to the other two triangle vertices.\n    vec2 p1 = p - ioffs + .2113248654, p2 = p - .577350269; \n \n    \n    \n    ////////////\n    // SIMPLEX NOISE... or close enough.\n    //\n    // We already have the triangle points, so we may as well take the last few steps to\n    // produce some simplex noise.\n    //\n    // Vector to hold the falloff value of the current pixel with respect to each vertice.\n    vec3 d = max(.5 - vec3(dot(p, p), dot(p1, p1), dot(p2, p2)), 0.); // Range [0, 0.5]\n    //\n    // Determining the weighted contribution of each random gradient vector for each point...\n    // Something to that effect, anyway. I could save three hash calculations below by using \n    // the following line, but it's a relatively cheap example, and I wanted to keep the noise \n    // seperate. By the way, if you're after a cheap simplex noise value, the calculations \n    // don't have to be particularly long. From here to the top, there's only a few lines, and \n    // the quality is good enough.\n    vec3 w = vec3(dot(hash22(s), p), dot(hash22((s + ioffs)), p1), dot(hash22(s + 1.), p2));\n    //\n    // Combining the above to achieve a rough simplex noise value.\n    float noise = clamp(0.5 + dot(w, d*d*d)*12., 0., 1.);    \n    ////////////\n    \n    \n    // THE WEAVE PATTERN\n    \n    // Three random values -- taken at each of the triangle vertices, and ranging between zero \n    // and one. Since neighboring triangles share vertices, the segments are guaranteed to meet\n    // at edge boundaries, provided the right shape is chosen, etc.\n    vec3 h = vec3(hash21(s), hash21((s + ioffs)), hash21(s + 1.));\n    //vec3 h = vec3(length(hash22(s)), length(hash22(s - vec2(i, sc - vec2(i, 1. + i)))), length(hash22(s + 1.)))*.35;\n\n    \n    #ifdef NO_WEAVE\n    // To draw the stacked circle version, the layers need to be have a lighting range from zero to one,\n    // but have to be distinct (not equal) for ordering purposes. To ensure that, I've spaced the layers\n    // out by a set amount, then with a little hack, seperated X from Y and Z, then Y from Z... I think\n    // the logic is sound? Either way, I'm not noticing any random flipping, so it'll do.\n    h = floor(h*15.999)/15.;\n    if(h.x == h.y) h.y += .0001;\n    if(h.x == h.z) h.z += .0001;\n    if(h.y == h.z) h.z += .0001;\n    #endif\n    \n     \n    \n    // Angles subtended from the current position to each of the three vertices... There's probably a \n    // symmetrical way to make just one \"atan\" call. Anyway, you can use these angular values to create \n    // patterns that follow the contours. In this case, I'm using them to create some cheap repetitious lines.\n    vec3 a = vec3(atan(p.y, p.x), atan(p1.y, p1.x), atan(p2.y, p2.x));\n \n    // The torus rings. \n    // Toroidal axis width. Basically, the weave pattern width.\n    float tw = .25;\n    // With the hexagon shape, the pattern width needs to be decreased.\n    #if SHAPE == 1 \n    tw = .19;\n    #endif\n    // For symmetry, we want the middle of the torus ring to cut dirrectly down the center\n    // of one of the equilateral triangle sides, which is half the distance from one of the\n    // vertices to the other. Add \".1\" to it to see that it's necessary.\n    float mid = dist((p2 - p))*.5;\n    // The three distance field functions: Stored in cir.x, cir.y and cir.z.\n    vec3 cir = vec3(dist(p), dist(p1), dist(p2));\n    // Equivalent to: vec3 tor =  cir - mid - tw; tor = max(tor, -(cir - mid + tw));\n    vec3 tor =  abs(cir - mid) - tw;\n\n    \n    // It's not absolutely necessary to scale the distance values by the scaling factor, but I find\n    // it helps, since it allows me scale up and down without having to change edge widths, smoothing\n    // factor variables, and so forth.\n    tor /= gSc;\n    cir /= gSc;\n\n    \n    \n    \n\n    #ifdef NO_WEAVE\n    // Front to back ordering:\n    //\n    // Specifically ordering the torus rings based on their individual heights -- as\n    // opposed to randomly ordering them -- will create randomly stacked rings, which\n    // I thought was interesting enough to include... But at the end of the day, it's\n    // probably not all that interesting. :D\n    \n    // I'm not sure how fond I am of the following hacky logic block, but it's easy \n    // enough to follow, plus it gets the job done:\n    //\n    // If the torus assoicated with the X vertex is lowest, render it first, then\n    // check to see whether Y or Z should be rendered next. Swap the rendering order --\n    // via swizzling -- accordingly. Repeat the process for the other vertices.\n    //\n    if(h.x<h.y && h.x<h.z){ // X vertex is lowest.\n        \n        // If you reorder one thing, you usually have to reorder everything else.\n        // Forgetting to do this, which I often do, sets me up for a lot of debugging. :)\n        if(h.z<h.y) { tor = tor.xzy; h = h.xzy; a = a.xzy; }\n        else {  tor = tor.xyz; h = h.xyz; a = a.xyz; }\n    }\n    else if(h.y<h.z && h.y<h.x) {  // Y vertex is lowest.\n        \n         if(h.z<h.x) { tor = tor.yzx; h = h.yzx; a = a.yzx; }\n         else { tor = tor.yxz; h = h.yxz; a = a.yxz; }\n    }\n    else { // Z vertex is lowest.\n        \n        if(h.y<h.x) { tor = tor.zyx; h = h.zyx; a = a.zyx; }\n        else { tor = tor.zxy; h = h.zxy; a = a.zxy;}\n    }\n    \n    #else\n    // Random order logic to create the weave pattern: Use the unique\n    // ID for this particular simplex grid cell to generate a random\n    // number, then use it to randomly mix the order via swizzling\n    // combinations. For instance, \"c.xyz\" will render layer X, Y then\n    // Z, whereas the swizzled combination \"c.zyx\" will render them\n    // in reverse order. There are six possible order combinations.\n    // The order in which you render the tori surrounding the three\n    // vertices will result in the spaghetti-like pattern you see.\n    //\n    // On a side note, including all six ordering possibilities \n    // guarantees that the pattern randomization is maximized, but\n    // there's probably a simpler way to achieve the same result.\n    \n    // Random value -- unique to each grid cell.\n    float dh = hash21((s + s + ioffs + s + 1.));\n    if(dh<1./6.){ tor = tor.xzy; a = a.xzy; }\n    else if(dh<2./6.){ tor = tor.yxz; a = a.yxz; }\n    else if(dh<3./6.){ tor = tor.yzx; a = a.yzx; }\n    else if(dh<4./6.){ tor = tor.zxy; a = a.zxy; }\n    else if(dh<5./6.){ tor = tor.zyx; a = a.zyx; } \n   \n    #endif\n\n    \n    // RENDERING\n    // Applying the layered distance field objects.\n    \n    // The background. This one barely shows, so is very simple.\n    vec3 bg = vec3(.075, .125, .2)*noise;\n    bg *= clamp(cos((oP.x - oP.y)*6.2831*128.)*1., 0., 1.)*.15 + .925;\n   \n    // The scene color. Initialized to the background.\n    vec3 col = bg;\n    \n    // Outer torus ring color. Just a bit of bronze.\n    vec3 rimCol = vec3(1, .7, .5);\n    // Applying some contrasty noise for a fake shadowy lighting effect. Since the \n    // noise is simplex based, the shadows tend to move in a triangular motion that\n    // matches the underlying grid the pattern was constucted with.\n    rimCol *= (smoothstep(0., .75, noise - .1) + .5);\n    \n    // Toroidal segment color. The angle is being used to create lines run perpendicular \n    // to the curves.\n    vec3 torCol = vec3(.2, .4, 1);\n    a = clamp(cos(a*48. + iTime*0.)*1. + .5, 0., 1.)*.25 + .75;\n    \n    // Using the tori's distance field to produce a bit of faux poloidal curvature.\n    // The value has also been repeated to create the line pattern that follows the\n    // pattern curves... Set it to \"vec3(1)\" to see what it does. :)\n    vec3 cc = max(.05 - tor*32., 0.);\n    cc *= clamp(cos(tor*6.2831*80.)*1. + .5, 0., 1.)*.25 + .75;\n    #ifdef NO_WEAVE\n    // If not using a weave pattern, you end up with some distinct, stacked tori,\n    // which means you can use the random height values to shade them and introduce \n    // some depth information.\n    cc *= (h*.9 + .1);\n    #endif\n        \n    // Smoothing factor and line width.\n    const float sf = .005, lw = .005;\n   \n    // Rendering the the three ordered (random or otherwise) objects:\n    //\n    // This is all pretty standard stuff. If you're not familiar with using a 2D\n    // distance field value to mix a layer on top of another, it's worth learning.\n    // On a side note, \"1. - smoothstep(a, b, c)\" can be written in a more concise\n    // form (smoothstep(b, a, c), I think), but I've left it that particular way\n    // for readability. You could also reverse the first two \"mix\" values, etc.\n    // By readability, I mean the word \"col\" is always written on the left, the\n    // \"0.\" figure is always on the left, etc. If this were a more GPU intensive\n    // exercise, then I'd rewrite things.\n    \n    // Bottom toroidal segment.\n    //\n    // Drop shadow with 50% transparency.\n    col = mix(col, vec3(0), (1. - smoothstep(0., sf*4., tor.x - .00))*.5);\n    // Outer dark edges.\n    col = mix(col, vec3(0), 1. - smoothstep(0., sf, tor.x));\n    // The bronze toroidal outer rim color.\n    col = mix(col, rimCol*cc.x, 1. - smoothstep(0., sf, tor.x + lw));\n    // The main blueish toroidal face with faux round shading and pattern.\n    col = mix(col, torCol*col.x*a.x, 1. - smoothstep(0., sf, tor.x + .015));\n    // Some inner dark edges. Note the \"abs.\" This could be rendered before\n    // the later above as a thick dark strip...\n    col = mix(col, vec3(0), 1. - smoothstep(0., sf, abs(tor.x + .015)));\n    \n    // Same layring routine for the middle toroidal segment.\n    col = mix(col, vec3(0), (1. - smoothstep(0., sf*4., tor.y - .00))*.5);\n    col = mix(col, vec3(0), 1. - smoothstep(0., sf, tor.y));\n    col = mix(col, rimCol*cc.y, 1. - smoothstep(0., sf, tor.y + lw)); \n    col = mix(col, torCol*col.x*a.y, 1. - smoothstep(0., sf, tor.y + .015));\n    col = mix(col, vec3(0), 1. - smoothstep(0., sf, abs(tor.y + .015)));\n\n    // Render the top toroidal segment last.\n    col = mix(col, vec3(0), (1. - smoothstep(0., sf*4., tor.z - .00))*.5);\n\tcol = mix(col, vec3(0), 1. - smoothstep(0., sf, tor.z));\n    col = mix(col, rimCol*cc.z, 1. - smoothstep(0., sf, tor.z + lw));\n    col = mix(col, torCol*col.x*a.z, 1. - smoothstep(0., sf, tor.z + .015));\n    col = mix(col, vec3(0), 1. - smoothstep(0., sf, abs(tor.z + .015)));\n    \n\n    \n    #ifdef SHOW_SIMPLEX_GRID\n    // Displaying the 2D simplex grid. Basically, we're rendering lines between\n    // each of the three triangular cell vertices to show the outline of the \n    // cell edges.\n    vec3 c = vec3(distLine(p, p1), distLine(p1, p2), distLine(p2, p));\n    c /= gSc;\n    c.x = min(min(c.x, c.y), c.z);\n    torCol = col;\n    col = mix(col, vec3(0), (1. - smoothstep(0., sf*2., c.x - .005))*.65);\n    col = mix(col, torCol*3., (1. - smoothstep(0., sf/2., c.x - .0015))*.75);\n    #endif\n    \n   \n    // Just the simplex noise, for anyone curious.\n    //return vec3(noise);\n    \n    // Return the simplex weave value.\n    return col;\n \n\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n\n    // Screen coordinates. I've put a cap on the fullscreen resolution to stop\n    // the pattern looking too blurred out.\n\tvec2 uv = fragCoord/min(750., iResolution.y);\n   \n    // Position with some scrolling.\n    vec2 p = uv + vec2(.8660254, .5)*iTime/16.; \n    \n    // Screen rotation to level the pattern, but I liked the current angle.\n    //p *= rot2(-3.14159/12.); \n    \n    // The simplex Truchet weave routine.\n    vec3 col = simplexWeave(p);\n    \n    // Using the Y screen coordinate to produce a subtle change in color.\n    col = mix(col, col.yxz, -uv.y*.5 + .5);\n    \n    // A subtle grid line overlay.\n    //col *= clamp(cos((p.x - p.y)*6.2831*96.)*1., 0., 1.)*.2 + .9;\n    \n     \n    // Subtle vignette.\n    uv = fragCoord/iResolution.xy;\n    //col *= pow(16.*uv.x*uv.y*(1. - uv.x)*(1. - uv.y) , .0625) + .1;\n    // Colored variation.\n    col = mix(col.zyx/2., col, pow(16.*uv.x*uv.y*(1. - uv.x)*(1. - uv.y) , .125));\n\n \t\n    // Rough gamma correction.\n    fragColor = vec4(sqrt(clamp(col, 0., 1.)), 1);\n    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4ltyRn.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[3109, 3142, 3164, 3164, 3222], [3225, 3257, 3278, 3368, 3641], [3644, 3644, 3665, 3665, 3879], [4101, 4121, 4140, 4140, 4491], [4494, 4530, 4556, 4608, 16035], [16039, 16039, 16095, 16219, 17121]], "test": "untested"}
{"id": "4ltyWr", "name": "QBezier + inv-K body 2", "author": "FabriceNeyret2", "description": "Body members: joints  by  inverse kinematics\n+ quadratic Bezier ( cleanup of  [url]https://shadertoy.com/view/XdB3Ww[/url] )\n\ntry STYLE = 0, 1, 2", "tags": ["quadraticbezier", "inversekinematics"], "likes": 8, "viewed": 484, "published": "Public API", "date": "1532256179", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define STYLE 0  // 0 1 2\n    \n// variant of https://shadertoy.com/view/4ttcDn\n// keep on floor.\n\n// -----------------------------------------------------------------\n// QBezier from https://shadertoy.com/view/XtdyDn\n//         cleanup of https://shadertoy.com/view/XdB3Ww\n\n//Find roots using Cardano's method. http://en.wikipedia.org/wiki/Cubic_function#Cardano.27s_method\nvec2 solveCubic2(vec3 a)\n{\n\tfloat p  = a.y - a.x*a.x/3.,\n\t      p3 = p*p*p,\n\t      q  = a.x* ( 2.*a.x*a.x - 9.*a.y ) /27. + a.z,\n\t      d  = q*q + 4.*p3/27.;\n    \n\tif(d>0.) {\n\t\tvec2 x = ( vec2(1,-1)*sqrt(d) -q ) *.5;\n        x = sign(x) * pow( abs(x) , vec2(1./3.) );\n  \t\treturn vec2( x.x+x.y -a.x/3. );\n  \t}\n    \n \tfloat v = acos( -sqrt(-27./p3)*q*.5 ) / 3.,\n \t      m = cos(v),\n \t      n = sin(v)*sqrt(3.);\n\n\treturn vec2(m+m,-n-m) * sqrt(-p/3.) - a.x/3.;\n}\n\n// How to solve the equation below can be seen on this image.\n// http://www.perbloksgaard.dk/research/DistanceToQuadraticBezier.jpg\n#define dd(a) dot(a,a)\n\nfloat dQBezier(vec2 p, vec2 a, vec2 b, vec2 c)\n{\n\tb = mix( b+vec2(1e-4), b, abs(sign(b*2.-a-c)) );\n\tvec2 A = b-a,\n\t     B = c-b-A,\n\t     C = p-a,\n\t     D = A*2.,\n\tP = solveCubic2( vec3(-3.*dot(A,B), dot(C,B)-2.*dd(A), dot(C,A))/-dd(B) );\n    P = clamp( P,0.,1.); // curve parameterization\n\n\treturn sqrt( min( dd( (D+B*P.x)*P.x -C ),\n                      dd( (D+B*P.y)*P.y -C )));\n}\n\n// ---------------------------------------------------------------\n\n// Does the inverse kinematics by finding the joint position between p0 and p2\n// ensuring fix member length |L|.  Sign(L) choose side. \n#define knee(p0,p2,L) ( l = p2-p0,                                  \\\n                        h = sqrt(max(0.,L*L-dot(l,l)))/2. *sign(L), \\\n                        (p0+p2)/2. +  h * normalize( vec2(-l.y,l.x) ) )\n\n\nvoid mainImage( out vec4 O, vec2 u )\n{\n    float t = iTime, h, d, s;\n    vec2 R =   iResolution.xy,\n         U = ( u+u - R ) / R.y;\n    \n    // --- QBezier curves storage\n#define N 6\n    vec2 P0[N],P1[N],P2[N];                             // QBezier nodes\n    float W[N];                                         // width\n    int k=-1;\n    vec2 m = vec2(1e5), M = vec2(-1e5);                 // drawing Bbox\n         \n#define push(p0,p1,p2,w)  k++; P0[k]=p0; P1[k]=p1; P2[k]=p2; W[k]=w; \\\n                          m = min(min(m+.1*w,p0),min(p1,p2)) -.1*w;  \\\n                          M = max(max(M-.1*w,p0),max(p1,p2)) +.1*w; // BBbox\n    \n    // --- define animated members\n    \n\tvec2 p0 = vec2(0,.1), l,                            // body end or neck\n\t     p2 = p0 + vec2(0,.75);                         // distant end\n\n    push(p2,p2,p2, 2.);                                 // head\n\n    p2 = p0 + vec2(0,.4);\n    push(p0,(p0+p2)/2.,p2, 1.2 );                       // body\n    \n    p0.x += .125; p0.y -= .1;\n    p2 = p0 + vec2(cos(t*1.3)*.4, -.5 +sin(t*.3)*.48 ); \n    push(p0,knee(p0,p2,1.),p2, 1. );                    // right leg\n\n    t += .5;\n    p0.x -= .25;\n    p2 = p0 + vec2(cos(t*1.3)*.4, -.5 +sin(t*.3)*.48 ),\n    push(p0,knee(p0,p2,1.),p2, 1. );                    // left leg\n    \n    t += .5; p0.y += .6;\n    p2 = p0 + vec2(-.4 +cos(t*1.3)*.38, sin(t*.3)*.5 );\n    push(p0,knee(p0,p2,1.),p2, .6 );                    // left hand\n  \n    t += .5; p0.x += .25;\n    p2 = p0 + vec2(.4 +cos(t*1.3)*.38, sin(t*.3)*.5 );\n    push(p0,knee(p0,p2,1.),p2, .6 );                    // right hand\n    \n    // --- draw\n    m.x = 0.; m.y+=1.;                                  // offset to y_min\n\n#if STYLE == 0       // draw blended members\n    O -= O;\n    for (int i=k; i>=0; i--) {\n        d = dQBezier(U,P0[i]-m,P1[i]-m,P2[i]-m) / W[i]; // blend members\n        s = smoothstep(5./R.y,0., d-.1 );               // shape mask\n        vec4 C = vec4( (1.-d*d/.01) * vec3(i!=1,1,1),1);// color & shading\n        O += (1.-O.a)* C * s;                           // blend front to back\n      //O = mix(O, C , s);                              // blend back to front\n      //O.gb += max(0.,1.-50.*length(U-P1[i]+m));       // show ctrl points\n    }\n    O *= vec4(1,.8,.8,1);\n\n#elif  STYLE == 1    // draw skeleton of members\n    \n    d = 1.;\n    for (int i=k; i>=0; i--)                            // nearest member\n        d = min( d, dQBezier(U,P0[i]-m,P1[i]-m,P2[i]-m) / W[i] );     \n  //O = vec4(smoothstep(5./R.y,0., d-.1 ) );\n    d/=.1; O = vec4(1.-d*d);\n  //O.x = max(O.x, cos(10.*d) );                        // echos\n\n#else                // draw silouhette\n    \n#define K 40.    \n#define min(a,b) -log( exp( -K*a ) + exp( -K*b ) ) / K  // smoothMin\n    d = 1.;\n    for (int i=k; i>=0; i--)                            // nearest member\n        d = min( d, dQBezier(U,P0[i]-m,P1[i]-m,P2[i]-m) / W[i] );     \n     O = vec4(smoothstep(5./R.y,0., d-.1 ) );\n   //d/=.1; O = vec4(1.-d*d);\n   //O.x = max(O.x, cos(100.*d) );                      // echos   \n    \n#endif\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4ltyWr.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[274, 374, 400, 400, 832], [834, 990, 1038, 1038, 1372], [1442, 1793, 1831, 1831, 4863]], "test": "untested"}
{"id": "4ltyzr", "name": "Beautiful Math", "author": "flerovium", "description": "Little experiment made when I was bored and had nothing to do.", "tags": ["circle", "rgb"], "likes": 6, "viewed": 168, "published": "Public", "date": "1531324775", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord ) { \n    vec2 uv = fragCoord/iResolution.xy;\n    \n    vec2  vector = uv * 2.0 - 1.0;\n    \n    vector.x *= (iResolution.x/iResolution.y);\n    \n\tfloat radius = length(vector);\n    \n    float angle = atan(vector.y/vector.x);\n    \n    float radius1 = sin(iTime * 2.0) + sin(40.0*angle+iTime)*0.01;\n    float radius2 = cos(iTime * 3.0);\n    \n    vec3 color1 = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n\n    float inten1 = 1.0 - sqrt(abs(radius1 - radius));\n    float inten2 = 1.0 - sqrt(abs(radius2 - radius));\n    \n    fragColor = vec4(color1 * (inten1 + inten2), 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4ltyzr.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 620]], "test": "untested"}
{"id": "4sGBDt", "name": "hypnotic snake", "author": "JohanFlod", "description": "Some practice on creating patterns in shader code. \n\n", "tags": ["2d", "stylee"], "likes": 4, "viewed": 73, "published": "Public", "date": "1530967347", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/*\n\nVariation of another shader I made\n\nNot optimised code in any way. \n\n*/\n\n#define TWO_PI 6.28318530718\n\nvec2 uv; //2D plane\nvec3 col; //Color palette\nfloat radius;\nfloat amplitude = 0.3; \nconst int NUM_BALLS = 16;\nvec2 ball_positions[NUM_BALLS];\n\n\n// unescessary with elipse when only drawing circles :P\n\nbool isellipse(float x_center, float y_center, float radius1)\n{\n    bool result = false;\n    \n    \n    if (sqrt( radius1*pow(uv.x - x_center,2.0) \n             + radius1*pow(uv.y - y_center,2.0)\n            ) < radius1 * radius1\n        )result = true;\n        \n    return result;\n}\n    \nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    uv = (2.*fragCoord.xy - iResolution.xy) / iResolution.y;\n\n    float high_Limit = 1.2;\n    float low_Limit = -1.2;\n    float color;\n        \n    // draw background gradient\n    \n    if (uv.y < high_Limit && uv.y > low_Limit){\n        color = distance(uv.y,high_Limit)/abs(high_Limit-low_Limit);\n        color = fract ( 5.*color*3.);\n        col = vec3(0.0,0.0,.5*fract(color-iTime));      \n    }\n    \n    float lowerLimit = 0.5*sin(iTime);\n    float upperLimit = 0.5*sin(iTime+1.);\n    \n   \t\n  \n    vec2 position1,position2,position3;\n    for(int j = 0; j < NUM_BALLS; j++)\n    {\n    \tfloat t = 1.0f * iTime  + ( float(j)/ float(NUM_BALLS)) * (2.0f * 3.14159f);\n        ball_positions[j].x = cos(t)+0.4*cos(t*1.4);\n        ball_positions[j].y = 0.2*sin(2.4*t-.3)+0.3*sin(t-.5);\n        \n    }\n  \n    float radius = 0.3+.2*cos(uv.y);\n    \n\t// loop through balls and draw them \n    \n    for(int j = 0; j < NUM_BALLS; j++)\n    {\n        \n        if(isellipse(ball_positions[j].x, ball_positions[j].y , radius))    \n        {\n            float colour3 = (distance(uv,ball_positions[j]))/radius;\n            float colour2 = 1.0-colour3;\n           \n           \tfloat colour = (float(j)/ float(NUM_BALLS))*colour2;\n            col = vec3(fract(colour), 0.f , fract(colour3*10.f-.5*iTime));\n        }\n    }\n\tfragColor = vec4(col,0.1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4sGBDt.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[251, 308, 371, 371, 590], [596, 596, 653, 653, 1986]], "test": "untested"}
{"id": "4sGfW3", "name": "static motion v2", "author": "kylegrover", "description": "shader", "tags": ["shader"], "likes": 2, "viewed": 352, "published": "Public API", "date": "1531107785", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 xy = fragCoord/iResolution.xy;\n    vec3 col;\n\n    xy.y += sin((xy.x + 0.125) * 5.0) * 0.1;\n    xy.y += (iTime / 60.0);\n //   xy.x = step(sin(xy.x * 9.0),0.5) / 9.0;\n    \n    float precolr1 = step(sin(xy.y * 90.0),sin(iTime + xy.y + xy.x) * 0.9);\n    float precolr2 = step(cos(xy.x * 160.0),sin(-iTime + xy.x * 2.0 - xy.y) * 0.9);\n    col.r = abs(precolr1 - precolr2);\n    \n    \n\txy.x += sin(iTime / 10.0) * 0.2;\n    \n    float precolg1 = step(cos(xy.y * 90.0),cos(iTime + xy.y + xy.x) * 0.9);\n    float precolg2 = step(tan(xy.x * 160.0),cos(-iTime + xy.x * 2.0 - xy.y) * 0.9);\n    col.g = abs(precolg1 - precolg2);\n    \n\txy.x += sin(iTime / 10.0) * 0.2;\n    xy.y *= (iTime / 100.0);\n\n    float precolb1 = step(sin(xy.y * 90.0),tan(iTime + xy.y + xy.x) * 0.9);\n    float precolb2 = step(sin(xy.x * 160.0),tan(-iTime + xy.x * 2.0 - xy.y) * 0.9);\n    col.b = abs(precolb1 - precolb2);\n    \n    if (col.rgb == vec3(0,0,0)) {\n      col = vec3(1,1,1);    \n    }\n    \n    if (0 == 1) {\n\t\tcol.rgb = col.rbg;\n    }\n    \n    // Output to screen\n   fragColor = vec4(col,1.0);\n    \n //  fragColor = vec4(vec3(col.b),1.0); // for peepin channels\n    \n    fragColor = vec4(vec3((col.r+col.g+col.b)/3.0),1.0); // grayscaler\n    fragColor = vec4(\n        vec3(step((col.r + col.g + col.b) / 3.0, 0.5)),\n        1.0); // black and white\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4sGfW3.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 107, 1438]], "test": "untested"}
{"id": "4sKBWV", "name": "Hexagons on Torus", "author": "iq", "description": "I feel this is the kind of thing [url=https://www.shadertoy.com/user/Shane]Shane[/url] would do. Chances are he already made one like this. If so, oh well...", "tags": ["3d", "raymarching", "torus", "hexagon"], "likes": 63, "viewed": 2786, "published": "Public API", "date": "1530595236", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Created by inigo quilez - iq/2018\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n#if HW_PERFORMANCE==0\n#define AA 1\n#else\n#define AA 2   // make this 2 is you have a fast computer\n#endif\n\n//------------------------------------------------------------------\n\nvec3 hexagon_pattern( vec2 p ) \n{\n\tvec2 q = vec2( p.x*2.0*0.5773503, p.y + p.x*0.5773503 );\n\t\n\tvec2 pi = floor(q);\n\tvec2 pf = fract(q);\n\n\tfloat v = mod(pi.x + pi.y, 3.0);\n\n\tfloat ca = step(1.0,v);\n\tfloat cb = step(2.0,v);\n\tvec2  ma = step(pf.xy,pf.yx);\n\t\n\treturn vec3( pi + ca - cb*ma, dot( ma, 1.0-pf.yx + ca*(pf.x+pf.y-1.0) + cb*(pf.yx-2.0*pf.xy) ) );\n}\n\n//------------------------------------------------------------------\n\nconst vec2 torus = vec2(0.5,0.2);\n\n#define NumTiles 3\n\n//------------------------------------------------------------------\n\nfloat map( in vec3 p )\n{\n    // torus\n    float d = length( vec2(length(p.xz)-torus.x,p.y) )-torus.y;\n    \n    // displace torus\n    vec2 uv = vec2(atan(p.z,p.x),atan(length(p.xz)-torus.x,p.y) )*vec2(3.0*sqrt(3.0),2.0)/3.14159;\n    uv = uv*float(NumTiles) + vec2(0.0,0.5*iTime);\n    vec3 h = hexagon_pattern( uv );\n    float f = mod(h.x+2.0*h.y,3.0)/2.0;\n    d += f*0.04;\n\n    return d;\n}\n\nvec2 castRay( in vec3 ro, in vec3 rd )\n{\n    // plane\n    float tmax = (-torus.y-ro.y)/rd.y;\n   \n    // torus\n    float t = 0.7;\n    float m = 2.0;\n    for( int i=0; i<256; i++ )\n    {\n\t    float precis = 0.0004*t;\n\t    float res = map( ro+rd*t );\n        if( res<precis || t>tmax ) break;\n        t += res*0.25;\n    }\n\n    if( t>tmax ) { t=tmax; m=1.0; }\n    return vec2( t, m );\n}\n\nfloat calcSoftshadow( in vec3 ro, in vec3 rd )\n{\n\tfloat res = 1.0;\n    float t = 0.02;\n    for( int i=0; i<128; i++ )\n    {\n\t\tfloat h = map( ro + rd*t )*0.2;\n        res = min( res,24.0*h/t );\n        t += clamp( h, 0.005, 0.02 );\n        if( res<0.001 || t>0.8 ) break;\n    }\n    return clamp( res, 0.0, 1.0 );\n}\n\nvec3 calcNormal( in vec3 pos )\n{\n    vec2 e = vec2(1.0,-1.0)*0.5773*0.0005;\n    return normalize( e.xyy*map( pos + e.xyy ) + \n\t\t\t\t\t  e.yyx*map( pos + e.yyx ) + \n\t\t\t\t\t  e.yxy*map( pos + e.yxy ) + \n\t\t\t\t\t  e.xxx*map( pos + e.xxx ) );\n}\n\nvec3 render( in vec3 ro, in vec3 rd )\n{ \n    vec2  res = castRay(ro,rd);\n    float t   = res.x;\n    vec3  pos = ro + t*rd;\n    vec3  nor = vec3(0.0,1.0,0.0);\n    float occ = 1.0;\n    float ks  = 0.0;\n    vec3  col = vec3(0.0,0.0,0.0);\n\n    // material        \n    if( res.y<1.5 )\n    {\n        // texture\n        vec3 te = texture(iChannel0,pos.xz*0.5).xyz;\n        col = 0.02 + te*0.2;\n        ks = te.x;\n        // fake occlusion\n        occ = smoothstep(0.06,0.4, abs(length(pos.xz)-torus.x) );\n    }\n    else\n    {\n        nor = calcNormal( pos );\n        occ = 0.5+0.5*nor.y;\n\n        vec2 uv = vec2( atan(pos.z,pos.x), atan(length(pos.xz)-torus.x,pos.y) )*\n                  vec2(3.0*sqrt(3.0), 2.0)/3.14159;\n        uv = uv*float(NumTiles) + vec2(0.0,0.5*iTime);\n        vec3 h = hexagon_pattern( uv );\n        float f = mod(h.x+2.0*h.y,3.0)/2.0;\n\n        // cell color\n        col = vec3(1.0-f);\n        float hh = abs(sin(10.0*mod(h.x+h.y*2.0,24.0)));\n        if( f<0.1 ) col = 0.12+0.12*cos(hh+vec3(0.0,2.0,2.0));\n\n        // cell borders\n        col *= 0.7+h.z;\n\n        // texture\n        vec3 te = texture( iChannel0, 0.2*uv ).xyz;\n        col *= 0.08+0.72*te;\n        ks = te.x;\n    }\n\n    // lighting\n    vec3  lig = normalize( vec3(0.4, 0.5, -0.6) );\n    vec3  hal = normalize( lig-rd );\n    float amb = clamp( 0.5+0.5*nor.y, 0.0, 1.0 );\n    float dif = clamp( dot( nor, lig ), 0.0, 1.0 );\n    float bac = clamp( dot( nor, normalize(vec3(-lig.x,0.0,-lig.z))), 0.0, 1.0 )*clamp( 1.0-pos.y,0.0,1.0);\n\n    //if( dif>0.0001 )\n    dif *= calcSoftshadow( pos, lig );\n\n    float spe = pow( clamp( dot( nor, hal ), 0.0, 1.0 ),32.0)*\n                dif *\n                (0.04 + 0.96*pow( clamp(1.0+dot(hal,rd),0.0,1.0), 5.0 ));\n\n    vec3 lin = vec3(0.0);\n    lin += 3.00*dif*vec3(1.10,0.90,0.60);\n    lin += 0.40*amb*vec3(0.30,0.60,1.50)*occ;\n    lin += 0.30*bac*vec3(0.40,0.30,0.25)*occ;\n    col = col*lin;\n    col += 5.00*spe*vec3(1.15,0.90,0.70)*ks*ks*4.0;\n\n\treturn col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 mo = iMouse.xy/iResolution.xy;\n\n    \n    // camera\t\n    vec3 ro = vec3( 1.1*cos(0.05*iTime + 6.0*mo.x), 0.9, 1.1*sin(0.05*iTime + 6.0*mo.x) );\n    vec3 ta = vec3( 0.0, -0.2, 0.0 );\n    // camera-to-world transformation\n    vec3 cw = normalize(ta-ro);\n    vec3 cu = normalize( cross(cw,vec3(0.0, 1.0,0.0)) );\n    vec3 cv = normalize( cross(cu,cw) );\n\n    vec3 tot = vec3(0.0);\n\t#if AA>1\n    for( int m=0; m<AA; m++ )\n    for( int n=0; n<AA; n++ )\n    {\n        // pixel coordinates\n        vec2 o = vec2(float(m),float(n)) / float(AA) - 0.5;\n        vec2 p = (-iResolution.xy + 2.0*(fragCoord+o))/iResolution.y;\n\t\t#else    \n        vec2 p = (-iResolution.xy + 2.0*fragCoord)/iResolution.y;\n\t\t#endif\n\n        // ray direction\n        vec3 rd = normalize( p.x*cu + p.y*cv + 2.0*cw );\n\n        // render\t\n        vec3 col = render( ro, rd );\n\n\t\t// gamma\n        col = pow( col, vec3(0.4545) );\n\n        tot += col;\n\t#if AA>1\n    }\n    tot /= float(AA*AA);\n\t#endif\n\n    // color grading\n    tot = 1.25*pow(tot,vec3(0.65,0.9,1.0) );\n\n    // vignetting    \n    vec2 q = fragCoord/iResolution.xy;\n    tot *= 0.3 + 0.7*pow(16.0*q.x*q.y*(1.0-q.x)*(1.0-q.y),0.25);\n\n    fragColor = vec4( tot, 1.0 );\n}", "image_inputs": [{"id": "XsfGRn", "previewfilepath": "/media/ap/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4sKBWV.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[232, 302, 335, 335, 657], [784, 854, 878, 891, 1242], [1244, 1244, 1284, 1297, 1626], [1628, 1628, 1676, 1676, 1941], [1943, 1943, 1975, 1975, 2175], [2177, 2177, 2216, 2216, 4161], [4163, 4163, 4220, 4220, 5420]], "test": "untested"}
{"id": "4sVBWd", "name": "Electric Fence", "author": "MadEqua", "description": "Winner of the July 2018 ShaderToy compo from Graphics Programming Discord. Hexagons never disappoint.", "tags": ["hexagon"], "likes": 27, "viewed": 1093, "published": "Public API", "date": "1531082211", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const float PI = 3.141593;\nconst float TWO_PI = PI * 2.0;\n\nfloat rand(float v) {\n    return fract(sin(v) * 5364.54367);\n}\n\nfloat noise(float v){\n    float i = floor(v);\n    float f = fract(v);   \n    float a = rand(i);\n    float b = rand(i + 1.0);                   \n    return mix(a, b, smoothstep(0.0, 1.0, f));\n}\n\nvec2 rotate2D(float angle, vec2 uv) {\n    return mat2(cos(angle), -sin(angle), sin(angle), cos(angle)) * uv;\n}\n\nfloat hex(vec2 p, float thickness) {\n    p.x *= 0.57735 * 2.0;\n\tp.y += mod(floor(p.x), 2.0) * 0.5;\n\tp = abs((mod(p, 1.0) - 0.5));\n    float sm = thickness * 0.5;\n\treturn smoothstep(thickness + sm, thickness - sm, abs(max(p.x * 1.5 + p.y, p.y * 2.0) - 1.0));\n}\n\nvec3 pallete() {\n    vec3 ORANGE = vec3(0.7, 0.3, 0.1);\n\tvec3 BROWN = vec3(0.5, 0.35, 0.2);\n    vec3 PURPLE = vec3(0.6, 0.2, 0.5);\n    vec3 RED = vec3(0.7, 0.1, 0.2);\n    vec3 c1 = mix(ORANGE, PURPLE, noise(iTime * 0.55 + 185.43));\n    vec3 c2 = mix(BROWN, RED, noise(iTime * 0.45 + 1485.34));\n    return mix(c1, c2, noise(iTime * 0.5 + 432.63));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    vec2 uv = (fragCoord - iResolution.xy * 0.5) / iResolution.y;\n    uv = rotate2D((noise(iTime * 0.05 + 534.453) - 0.5) * TWO_PI, uv);\n    \n    float tiles = sin(iTime * 0.5 + 12.5) * 6.0 + 9.0;\n    int LAYERS = 6;\n    \n    vec3 pal = pallete();\n    vec3 col = pal * 0.6;\n    \n    float scaleAnim = 0.15 * sin(iTime * 1.3 + 4324.0) + 0.2;\n    vec2 cameraAnim = (vec2(noise(iTime * 0.15 + 123.25), noise(iTime * 0.2 + 1544.123)) - 0.5) * 10.0;\n\n    float scale = 1.0;\n    for(int i = 1; i <= LAYERS; ++i) {\n        float thicknessAnim = 0.08 * sin(0.9 * iTime + float(i) * 0.6) + 0.1;\n        \n        float h = hex((scale * uv * tiles) + cameraAnim, thicknessAnim);\n        vec3 c = float(i) * pal * h;\n        \n        c *= mix(0.9, -noise(iTime * 0.5 + 1515.11) * 0.6, step(0.5, float(i % 2)));\n        c += mix(0.2, -0.2, hex(5.0 * uv, 0.6)) * h;\n   \n      \tcol += (1.0 - length(uv)) * c;\n        scale -= scaleAnim / float(LAYERS);\n    }\n           \n    fragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4sVBWd.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[59, 59, 80, 80, 121], [123, 123, 144, 144, 315], [317, 317, 354, 354, 427], [429, 429, 465, 465, 688], [690, 690, 706, 706, 1038], [1040, 1040, 1096, 1096, 2086]], "test": "untested"}
{"id": "4sVfWK", "name": "magnets", "author": "lennyjpg", "description": "asdfasdfasdfasdf", "tags": ["asdfasdfa"], "likes": 10, "viewed": 460, "published": "Public API", "date": "1530552478", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const float PI = 3.1415926535897932384626433832795;\nvoid mainImage( out vec4 O, in vec2 f ){\n    vec2 uv = f/iResolution.y - 0.5;  \n    float t = 999.999 + iTime * 10.0;\n    float d = length(uv*1.5);\n     uv = tan(10.5+uv*5.0);\n    float  angle = atan(uv.y,uv.x);\n    float k = cos(PI+(t+t*d/10.0)+angle*10.0)*1.7;\n    O = vec4(k);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4sVfWK.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[52, 52, 92, 92, 333]], "test": "untested"}
{"id": "4sXyzf", "name": "Waterworld edit", "author": "xef6", "description": "edit of parameters from this shadertoy sketch by user frankenburgh:\nhttps://www.shadertoy.com/view/lsBSWm\n\ni wanted it to be more like at the pole of the planet, with the sun staying above the horizon but still oscillating", "tags": ["waves"], "likes": 19, "viewed": 440, "published": "Public", "date": "1531605250", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Water + Terrain shader   \n// 10/2014 Created by Frank Hugenroth /frankenburgh/\n// 'hash' and 'noise' function by iq\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n//\n// V1.1  - added 'real' water height (hits terrain) and waterheight is visible on shadow\n//\n// CLICK and MOVE the MOUSE to:\n// X -> Change water height  /  Y -> Change water clarity.\n\n// some parameters....\n\nfloat coast2water_fadedepth = 0.1;\nfloat large_waveheight      = 0.2; // change to adjust the \"heavy\" waves\nfloat large_wavesize        = 2.0;  // factor to adjust the large wave size\nfloat small_waveheight      = 0.6;  // change to adjust the small random waves\nfloat small_wavesize        = 0.5;   // factor to ajust the small wave size\nfloat water_softlight_fact  = 15.;  // range [1..200] (should be << smaller than glossy-fact)\nfloat water_glossylight_fact= 120.; // range [1..200]\nfloat particle_amount       = 60.;\nvec3 watercolor             = vec3(0.43, 0.52, 0.65); // 'transparent' low-water color (RGB)\nvec3 watercolor2            = vec3(0.05, 0.05, 0.1); // deep-water color (RGB, should be darker than the low-water color)\nvec3 water_specularcolor    = vec3(1.4, 1.4, 1.1);    // specular Color (RGB) of the water-highlights\n//vec3 watercolor             = vec3(0.43, 0.60, 0.66); // 'transparent' low-water color (RGB)\n//vec3 watercolor2            = vec3(0.05, 0.05, 0.1); // deep-water color (RGB, should be darker than the low-water color)\n//vec3 water_specularcolor    = vec3(1.3, 1.3, 0.9);    // specular Color (RGB) of the water-highlights\nvec3 light;\n\n// calculate random value\nfloat hash( float n )\n{\n    return fract(sin(n)*43758.5453123);\n}\n\n// 2d noise function\nfloat noise1( in vec2 x )\n{\n  vec2 p  = floor(x);\n  vec2 f  = smoothstep(0.0, 1.0, fract(x));\n  float n = p.x + p.y*57.0;\n  return mix(mix( hash(n+  0.0), hash(n+  1.0),f.x),\n    mix( hash(n+ 57.0), hash(n+ 58.0),f.x),f.y);\n}\n\nfloat noise(vec2 p)\n{\n  return textureLod(iChannel0,p*vec2(1./256.),0.0).x;\n}\n\nfloat height_map( vec2 p )\n{\n  mat2 m = mat2( 0.9563*1.4,  -0.2924*1.4,  0.2924*1.4,  0.9563*1.4 );\n  p = p*6.;\n  float f = 0.6000*noise1( p ); p = m*p*1.1;\n  f += 0.2500*noise1( p ); p = m*p*1.32;\n  f += 0.1666*noise1( p ); p = m*p*1.11;\n  f += 0.0834*noise( p ); p = m*p*1.12;\n  f += 0.0634*noise( p ); p = m*p*1.13;\n  f += 0.0444*noise( p ); p = m*p*1.14;\n  f += 0.0274*noise( p ); p = m*p*1.15;\n  f += 0.0134*noise( p ); p = m*p*1.16;\n  f += 0.0104*noise( p ); p = m*p*1.17;\n  f += 0.0084*noise( p );\n  const float FLAT_LEVEL = 0.525;\n  if (f<FLAT_LEVEL)\n      f = f;\n  else\n      f = pow((f-FLAT_LEVEL)/(1.-FLAT_LEVEL), 2.)*(1.-FLAT_LEVEL)*2.0+FLAT_LEVEL; // makes a smooth coast-increase\n  return clamp(f, 0., 10.);\n}\n\nvec3 terrain_map( vec2 p )\n{\n  return vec3(0.55, .45, .4)+texture(iChannel1, p*2.).rgb*.5; // test-terrain is simply 'sandstone'\n//  return vec3(0.7, .55, .4)+texture(iChannel1, p*2.).rgb*.5; // test-terrain is simply 'sandstone'\n}\n\nconst mat2 m = mat2( 0.72, -1.60,  1.60,  0.72 );\n\nfloat water_map( vec2 p, float height )\n{\n  vec2 p2 = p*large_wavesize;\n  vec2 shift1 = 0.001*vec2( iTime*160.0*2.0, iTime*120.0*2.0 );\n  vec2 shift2 = 0.001*vec2( iTime*190.0*2.0, -iTime*130.0*2.0 );\n\n  // coarse crossing 'ocean' waves...\n  float f = 0.6000*noise( p );\n  f += 0.2500*noise( p*m );\n  f += 0.1666*noise( p*m*m );\n  float speed = 0.001;\n  float rx = sin(iTime*speed)*0.5+0.5;\n  float ry = cos(iTime*speed)*0.5+0.5;\n  \n  float freq = ry*0.25 + 0.05;\n  //float wave_b = = sin(p2.x*0.1+p2.y*0.3+shift2.x*0.269)*large_waveheight*f*height*height ;\n  float wave = sin(p2.x*-0.3+p2.y*freq+shift2.x*0.269)*large_waveheight*f*height*height ;\n\n  p *= small_wavesize;\n  f = 0.;\n  float amp = 1.0, s = .5;\n  for (int i=0; i<9; i++)\n  { p = m*p*.947; f -= amp*abs(sin((noise( p+shift1*s )-.5)*2.)); amp = amp*.59; s*=-1.329; }\n \n  return wave+f*small_waveheight;\n}\n\nfloat nautic(vec2 p)\n{\n  p *= 18.;\n  float f = 0.;\n  float amp = 1.0, s = .5;\n  for (int i=0; i<3; i++)\n  { p = m*p*1.2; f += amp*abs(smoothstep(0., 1., noise( p+iTime*s ))-.5); amp = amp*.5; s*=-1.227; }\n  return pow(1.-f, 5.);\n}\n\nfloat particles(vec2 p)\n{\n  p *= 200.;\n  float f = 0.;\n  float amp = 1.0, s = 1.5;\n  for (int i=0; i<3; i++)\n  { p = m*p*1.2; f += amp*noise( p+iTime*s ); amp = amp*.5; s*=-1.227; }\n  return pow(f*.35, 7.)*particle_amount;\n}\n\n\nfloat test_shadow( vec2 xy, float height)\n{\n    vec3 r0 = vec3(xy, height);\n    vec3 rd = normalize( light - r0 );\n    \n    float hit = 1.0;\n    float t   = 0.001;\n    for (int j=1; j<25; j++)\n    {\n        vec3 p = r0 + t*rd;\n        float h = height_map( p.xy );\n        float height_diff = p.z - h;\n        if (height_diff<0.0)\n        {\n            return 0.0;\n        }\n        t += 0.01+height_diff*.02;\n        hit = min(hit, 2.*height_diff/t); // soft shaddow   \n    }\n    return hit;\n}\n\nvec3 CalcTerrain(vec2 uv, float height)\n{\n  vec3 col = terrain_map( uv );\n  float h1 = height_map(uv-vec2(0., 0.01));\n  float h2 = height_map(uv+vec2(0., 0.01));\n  float h3 = height_map(uv-vec2(0.01, 0.));\n  float h4 = height_map(uv+vec2(0.01, 0.));\n  vec3 norm = normalize(vec3(h3-h4, h1-h2, 1.));\n  vec3 r0 = vec3(uv, height);\n  vec3 rd = normalize( light - r0 );\n  float grad = dot(norm, rd);\n  col *= grad+pow(grad, 8.);\n  float terrainshade = test_shadow( uv, height );\n  col = mix(col*.25, col, terrainshade);\n  return col;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\t    \n    float speed = 0.01575;\n    float scl = 1.66;\n    float sv_mod_slow = (sin(iTime*speed*0.0132))*0.2+1.1;\n    scl = scl * sv_mod_slow;\n \tfloat sv_slow = (sin(iTime*speed*0.33)*.5+0.5);\n \tfloat sv =      (sin(iTime*speed*1.   ))*scl;\n \tfloat sc =      (cos(iTime*speed*1.   ))*scl;\n    \n    coast2water_fadedepth = 0.1 + 0.15*(cos(iTime*speed*0.05)*.5+0.5);\n\tlarge_waveheight = 0.1 + 1.5*(cos(iTime*speed*0.002)*.5+0.5);\n    \n    light = vec3(sc, sv, sv_slow* 3. + 1.65 ); // position of the sun\n\tvec2 uv = (fragCoord.xy / iResolution.xy - vec2(+0.500, +0.500));\n//ec2 uv = (fragCoord.xy / iResolution.xy - vec2(-0.12, +0.25));\n    \n    float WATER_LEVEL = 0.94; // Water level (range: 0.0 - 2.0)\n    if (iMouse.z>0.)\n\t\tWATER_LEVEL = iMouse.x*.003; \n    float deepwater_fadedepth   = 0.5 + coast2water_fadedepth;\n    if (iMouse.z>0.)\n\t  deepwater_fadedepth = iMouse.y*0.003 + coast2water_fadedepth;\n    \n    float height = height_map( uv );\n    vec3 col;\n    \n    float waveheight = clamp(WATER_LEVEL*3.-1.5, 0., 1.);\n    float level = WATER_LEVEL + .2*water_map(uv*15. + vec2(iTime*.1), waveheight);\n    if (height > level)\n    {\n        col = CalcTerrain(uv, height);\n    }\n    if (height <= level)\n    {\n        vec2 dif = vec2(.0, .01);\n        vec2 pos = uv*15. + vec2(iTime*.01);\n        float h1 = water_map(pos-dif,waveheight);\n        float h2 = water_map(pos+dif,waveheight);\n        float h3 = water_map(pos-dif.yx,waveheight);\n        float h4 = water_map(pos+dif.yx,waveheight);\n        vec3 normwater = normalize(vec3(h3-h4, h1-h2, .125)); // norm-vector of the 'bumpy' water-plane\n        uv += normwater.xy*.002*(level-height);\n        \n        col = CalcTerrain(uv, height);\n\n        float coastfade = clamp((level-height)/coast2water_fadedepth, 0., 1.);\n        float coastfade2= clamp((level-height)/deepwater_fadedepth, 0., 1.);\n        float intensity = col.r*.2126+col.g*.7152+col.b*.0722;\n        watercolor = mix(watercolor*intensity, watercolor2, smoothstep(0., 1., coastfade2));\n\n        vec3 r0 = vec3(uv, WATER_LEVEL);\n        vec3 rd = normalize( light - r0 ); // ray-direction to the light from water-position\n        float grad     = dot(normwater, rd); // dot-product of norm-vector and light-direction\n        float specular = pow(grad, water_softlight_fact);  // used for soft highlights                          \n        float specular2= pow(grad, water_glossylight_fact); // used for glossy highlights\n        float gradpos  = dot(vec3(0., 0., 1.), rd);\n        float specular1= smoothstep(0., 1., pow(gradpos, 5.));  // used for diffusity (some darker corona around light's specular reflections...)                          \n        float watershade  = test_shadow( uv, level );\n        watercolor *= 2.2+watershade;\n   \t\twatercolor += (.2+.8*watershade) * ((grad-1.0)*.5+specular) * .25;\n   \t\twatercolor /= (1.+specular1*1.2);\n   \t\twatercolor += watershade*specular2*water_specularcolor;\n        watercolor += watershade*coastfade*(1.-coastfade2)*(vec3(.5, .6, .7)*nautic(uv)+vec3(1., 1., 1.)*particles(uv));\n        \n        col = mix(col, watercolor, coastfade);\n    }\n    \n\tfragColor = vec4(col , 1.0);\n}\n", "image_inputs": [{"id": "XsX3Rn", "previewfilepath": "/media/ap/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg", "ctype": "texture"}, {"id": "4dXGzn", "previewfilepath": "/media/ap/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4sXyzf.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[1593, 1619, 1642, 1642, 1684], [1686, 1707, 1734, 1734, 1932], [1934, 1934, 1955, 1955, 2011], [2013, 2013, 2041, 2041, 2736], [2738, 2738, 2766, 2766, 2969], [3022, 3022, 3063, 3063, 3888], [3890, 3890, 3912, 3912, 4120], [4122, 4122, 4147, 4147, 4346], [4349, 4349, 4392, 4392, 4843], [4845, 4845, 4886, 4886, 5376], [5379, 5379, 5436, 5436, 8588]], "test": "untested"}
{"id": "4syBW3", "name": "static motion", "author": "kylegrover", "description": "motion static", "tags": ["chkrs"], "likes": 2, "viewed": 341, "published": "Public API", "date": "1530678657", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n#define smoothify(edge,invalue,smoothrange) smoothstep(edge - smoothrange, edge + smoothrange, invalue)\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   // Normalized pixel coordinates (from 0 to 1)\n   vec2 xy = fragCoord/iResolution.xy;\n   vec3 col;\n   float smoothrange = 0.09;\n    \n   float stepfxn_y = smoothify(\n       sin(xy.y * 90.0),\n       sin(iTime + xy.y + xy.x) * 0.9,\n       smoothrange\n   );\n   float stepfxn_x = smoothify(\n       cos(xy.x * 160.0),\n       sin(-iTime + xy.x * 2.0 - xy.y) * 0.9,\n       smoothrange\n   );\n   col = vec3(abs(stepfxn_y - stepfxn_x));    \n    \n\n   // Output to screen\n   fragColor = vec4(col,1.0); \t  // full color\n   // fragColor = vec4(vec3(col.r),1.0); // for peepin channels\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4syBW3.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[105, 105, 162, 211, 736]], "test": "untested"}
{"id": "4syBWd", "name": "columns 10: column crown", "author": "FabriceNeyret2", "description": "Note that the SDF cost  does not depends to the number of sub-columns.\n\nmouse click to see sub-columns id", "tags": ["raymarching", "sdf", "short"], "likes": 2, "viewed": 327, "published": "Public API", "date": "1530960260", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// variant of https://shadertoy.com/view/4dGBWd\n// inspired from sub-holes in https://www.shadertoy.com/view/XstfW8\n\nvoid mainImage(out vec4 O, vec2 U) {\n    \n    float t = iTime, l,a,z,i, r=1., h=6.;        // r: radius h: height/2.\n    mat2  R = mat2( sin(t+vec4(0,33,11,0)) );\n    vec3  q = iResolution,\n          D = normalize(vec3(.3*(U+U-q.xy)/q.y, -1)),  // ray direction\n          p = 30./q, q0;                         // marching point along ray\n\n    O-=O;\n    for ( O++; O.x > 0. && t > .01 ; O-=.015 ) {\n        q = p,\n        q.xz *= R, q.yz *= R,                    // rotation\n        i = 2. + floor(abs(q.x/6.))*2. + float(q.y>0.); // column id\n        q0 = q; z = q.z;\n        q.x = mod(q.x,6.)-3.,                    // repeat in x\n        q.y = abs(q.y)-5.;                       // 2 rows\n        q.z = mod(q.z,3.) - 1.5,                 // vertical blocks\n            \n        a = atan(q.y,q.x), l = length(q.xy);\n        t = length(vec2(l-r,(mod(i*a,6.28)-3.14)*1./i))-r*.3, // crown of columns\n        t = max(t,abs(z) -h),                    // inter range of Z\n        t = min(t, max(l-r*1.3,abs(abs(z)-h)-.2));\n            \n        p += t*D;                                // step forward = dist to obj\n    }\n    if (iMouse.z>0.) O *= .6 + .6 * cos( floor(mod(a,6.3)*i/6.3)  + vec4(0,23,21,0));\n}                                                // hue from https://www.shadertoy.com/view/ll2cDc\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4syBWd.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 117, 153, 153, 1322]], "test": "untested"}
{"id": "4syfDc", "name": "RK Raymarch 1", "author": "rkibria", "description": "Got around to trying raymarching finally!", "tags": ["raymarch"], "likes": 4, "viewed": 140, "published": "Public", "date": "1530746382", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/*\nThanks to\n\nhttp://jamie-wong.com/2016/07/15/ray-marching-signed-distance-functions/\nhttp://iquilezles.org/www/articles/distfunctions/distfunctions.htm\n\n*/\n\n#define MAX_MARCHING_STEPS 50\n#define EPSILON 0.05\n#define MAX_DIST 100.0\n\nfloat sdSphere( vec3 p, float s )\n{\n  return length(p)-s;\n}\n\nfloat udBox( vec3 p, vec3 b )\n{\n  return length(max(abs(p)-b,0.0));\n}\n\nfloat opU( float d1, float d2 )\n{\n    return min(d1,d2);\n}\n\nfloat opS( float d1, float d2 )\n{\n    return max(-d1,d2);\n}\n\nfloat sdf( vec3 p )\n{\n\tfloat d = udBox( p, vec3(4, 0.15, 4) ) ;\n    for( int j = 0; j < 5; j++ )\n    {\n        for( int i = 0; i < 5; i++ )\n        {\n            vec3 sp = vec3(\n                -3.5 + float(i) * 1.75 + sin(2. * iTime),\n                0.5 * -(sin(2. * iTime + float(i) + float(j) )),\n                -3.5 + float(j) * 1.75 + 0.25 * sin(2. * iTime)\n            );\n            float sv = sdSphere( p + sp, 0.75 + 0.125 * sin(iTime));\n            if((i+j) % 2 == 0)\n\t            d = opU( d, sv );\n            else\n\t            d = opS( sv, d );\n        }\n    }\n\treturn d;\n}\n\nvec3 estimateNormal(vec3 p) {\n    return normalize(vec3(\n        sdf(vec3(p.x + EPSILON, p.y, p.z)) - sdf(vec3(p.x - EPSILON, p.y, p.z)),\n        sdf(vec3(p.x, p.y + EPSILON, p.z)) - sdf(vec3(p.x, p.y - EPSILON, p.z)),\n        sdf(vec3(p.x, p.y, p.z  + EPSILON)) - sdf(vec3(p.x, p.y, p.z - EPSILON))\n    ));\n}\n\nvec3 lighting(in vec3 pos, in vec3 n)\n{\n    vec3 c = (n + 1.) / 2.;\n    vec3 a = vec3( 0.05 + max(0., dot(n, vec3(1., 0.5, 0.5)) ) );\n    a = a / ( 5. + pos.z );\n    return mix(a, c, 0.1);\n}\n\nvec3 march(in vec3 eye, in vec3 ray)\n{\n    float depth = 0.0;\n    for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n        vec3 pos = eye + depth * ray;\n        float dist = sdf( pos );\n        if( dist < EPSILON ) {\n            return lighting( pos, estimateNormal( pos ) );\n        }\n\n        depth += dist;\n\n        if ( depth >= MAX_DIST ) {\n            return vec3( 0. );\n        }\n    }\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = ( fragCoord - .5 * iResolution.xy ) / iResolution.x;\n    vec3 col = vec3( 0 );\n    \n    vec3 eye = vec3(0., 1.0, -10.);\n    vec3 ray = normalize( vec3( uv, 1. ) );\n\n    col = march( eye, ray );\n    \n    fragColor = vec4(sqrt(col),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4syfDc.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 234, 269, 269, 293], [295, 295, 326, 326, 364], [366, 366, 399, 399, 424], [426, 426, 459, 459, 485], [487, 487, 508, 508, 1074], [1076, 1076, 1105, 1105, 1385], [1387, 1387, 1426, 1426, 1577], [1579, 1579, 1617, 1617, 1971], [1973, 1973, 2030, 2030, 2279]], "test": "untested"}
{"id": "4syfDt", "name": "1995 tribute", "author": "Flopine", "description": "One of my fav demo of all time. I can listen its music everyday and anytime <3\nhttps://www.youtube.com/watch?v=weGYilwd1YI ", "tags": ["raymarching", "1995", "demo", "mfx", "kewlers"], "likes": 6, "viewed": 187, "published": "Public", "date": "1530952126", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Code by Flopine\n// Thanks to wsmind, leon, lsdlive, XT95, lamogui and Coyhot for teaching me :) <3\n// Cookie Collective rulz... also Kewlers and mfx <3\n\n#define ITER 100.\n#define PI 3.141592\n\nfloat smin(float a, float b, float k) {\n\tfloat h = clamp(.5 + .5*(b - a) / k, 0., 1.);\n\treturn mix(b, a, h) - k * h * (1. - h);\n}\n\nmat2 rot (float a)\n{float c= cos(a); float s = sin(a); return mat2(c,-s,s,c);}\n\nvec2 moda (vec2 p)\n{\n    float per = (2.*PI)/6.;\n float a = atan(p.y,p.x);\n    float l = length(p);\n    a = mod(a-per/2.,per)-per/2.;\n    return vec2 (cos(a),sin(a))*l;\n}\n\n\nfloat sphe (vec3 p, float r)\n{return length(p)-r;}\n\nfloat cyl(vec3 p, float r, float h)\n{return max(length(p.xz)-r, abs(p.y)-h);}\n\nfloat box (vec3 p, vec3 c)\n{return length(max(abs(p)-c,0.));}\n\nfloat branch (vec3 p)\n{\n    p.yz = moda(p.yz);\n    p.y -= 6.;\n    return smin(cyl(p,(p.y+12.)*0.05,5.), sphe(vec3(p.x,p.y-5.,p.z),0.9),0.05);\n}\n\nfloat branches (vec3 p)\n{\n    vec3 q = p;\n    float b = branch(p);\n    p.xz *= rot (PI/2.);\n    float b1 = branch(p);\n    p = q;\n    p.xy *= rot(PI/2.);\n    float b2 = branch(p);\n    return smin(b2,smin(b,b1,0.5),0.5);\n}\n\nfloat prim1 (vec3 p, float detail)\n{\n    p = floor(p*detail)/detail;\n    p.xy -= vec2(5.,-1.);\n    p.xz *= rot(iTime);\n    p.xy *= rot(iTime+2.);\n\treturn smin(sphe(p,2.),branches(p),0.9);\n}\n\nfloat prim2 (vec3 p)\n{\n    p *= 2.;\n    p.xy += vec2(18.,10.);\n    p.xz *= rot(iTime);\n    float b1 = box(p, vec3(3.5,.5,.5));\n    \n    p.xy *= rot(PI/2.);\n    float b2 = box(p+vec3(2.,1.,0.), vec3(2.5,.5,.5));\n    float b3 = box(p+vec3(1.5,3.,0.), vec3(1.5,.5,.5));\n    float b4 = box(p+vec3(1.5,-3.,0.), vec3(1.5,.5,.5));\n    float b5 = box(p+vec3(1.5,-1.,0.), vec3(1.5,.5,.5));\n    return min(b5,min(b4,min(b3,min(b1,b2))));\n}\n\nfloat g = 0.;\nfloat SDF(vec3 p)\n{\n\tfloat d = min(prim1(p,4.),prim2(p));\n    g += 0.01/(0.01+d*d);\n    return d;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = 2.*(fragCoord/iResolution.xy)-1.;\n\tuv.x *= iResolution.x/iResolution.y;\n    \n    vec3 ro = vec3(0.001,0.001,-8.); vec3 p = ro;\n    vec3 dir = normalize(vec3(uv,1));\n    \n    float shad = 0.;\n        for (float i=0.; i<ITER; i++)\n        {\n            float d = SDF(p);\n            if (d<0.001)\n            {\n                shad = i/ITER;\n                break;\n            }\n            p += d*dir*0.5;\n        }\n    \n    float t = length(ro-p);\n\n    vec3 col = vec3(1.-shad)\n        *vec3(0.,0.1,0.5)\n        +g*0.3;\n    col = mix(col, vec3(0.3,0.,0.4)*(1.-length(uv*0.2)),1.-exp(-0.007*t*t));\n\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4syfDt.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 195, 234, 234, 324], [326, 326, 346, 346, 404], [406, 406, 426, 426, 576], [579, 579, 609, 609, 629], [631, 631, 668, 668, 708], [710, 710, 738, 738, 771], [773, 773, 796, 796, 916], [918, 918, 943, 943, 1138], [1140, 1140, 1176, 1176, 1329], [1331, 1331, 1353, 1353, 1760], [1776, 1776, 1795, 1795, 1875], [1877, 1877, 1934, 1984, 2628]], "test": "untested"}
{"id": "4syfDV", "name": "sigint", "author": "lennyjpg", "description": "sfsfgsgfsdfg", "tags": ["dfsgdfgsdfg"], "likes": 6, "viewed": 369, "published": "Public API", "date": "1530465724", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/*\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    float t = iTime*0.02, scroll = t*0.123;\n    uv.y-=.5;\n    float y = uv.y;\n    float x = uv.x + t;\n    vec4 a = sin(x * vec4(0.3,10.0,2.5,350.13));\n    float k =  a.r + a.g - a.b + a.a;\n    if(y<0.4) k = a.r;\n    if(y<0.3) k = a.g;\n    if(y<0.2) k = a.b;\n    if(y<0.1) k = a.a;\n    y+=0.4;\n    x = uv.x - t;\n    vec4 b = sin(x * vec4(11.3,20.0,0.5,150.3));\n    float j =  b.r + b.g - b.b * b.a;\n    if(y<0.4) j = b.r;\n    if(y<0.3) j = b.g;\n    if(y<0.2) j = b.b;\n    if(y<0.1) j = b.a;\n    fragColor = vec4(abs(k*j));\n}\n\n*/\n\nvoid mainImage( out vec4 O, vec2 u )\n{\n    vec2 uv = u / iResolution.xy;\n    float t = iTime*.02;\n \n    vec4  a = sin( (uv.x + t) * vec4( 350.13, 2.5, 10, .3 ) ),\n          b = sin( (uv.x - t) * vec4( 150.3, .5, 20, 11.3 ) );\n    int   y = int(10.*uv.y)-5;\n    float k = y<4 ?  a[y]   : a.a + a.b - a.g + a.r,\n          j = y<0 ?  b[y+4] : b.a + b.b - b.g * b.r;\n\n    O += abs(k*j) -O;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4syfDV.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 630, 668, 668, 1017]], "test": "untested"}
{"id": "4syfWd", "name": "GP - Memories of Nagrand", "author": "Quinchilion", "description": "SDF raymarched terrains forming a layer of floating islands, with water reflections, soft shadows, ambient occlusion, atmospheric scattering and clouds.", "tags": ["raymarching", "terrain", "sdf"], "likes": 7, "viewed": 336, "published": "Public", "date": "1531080956", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Made by Quinchilion (aka Dolkar) for the purposes of the Graphics Programming first shader contest\n// on 8.7.2018\n// MIT License, do whatever with it\n\n// Featuring a terrain built solely with SDF blobs. Not the best thing for making terrains with,\n// as can be seen from the sphere grid artifacts. A larger radius of influence would help\n// at the cost of performance.\n// Floating islands made as a difference of two terrain objects.\n// With the entire scene built with SDF, soft shadows and AO approximations\n// are fast to calculate.\n\n// Uncomment this line if shader compilation crashes your driver or if it's too slow\n//#define NO_WATER_SHADING\n\nconst float CAMERA_TRAVEL_SPEED = 1.0;\nconst int RAYMARCH_MAX_ITER = 200;\nconst int SHADOW_MAX_ITER = 50;\nconst int REFLECTION_MAX_ITER = 100;\nconst int AMBIENT_MAX_ITER = 10;\nconst float RAYMARCH_PRECISION = 0.001;\nconst float RAYMARCH_STEP_FACTOR = 1.0;\nconst vec3 SUN_DIRECTION = normalize(vec3(0.5, 1.0, 2.0));\nconst vec3 SUNLIGHT_COLOR = vec3(1.0, 0.9, 0.8) * 1.5;\nconst float AMBIENT_LIGHT_INTENSITY = 1.0;\n\n// Ray sphere intersection assuming ray origin lies within the sphere\nfloat innerRaySphere(vec3 rayOrig, vec3 rayDir, vec3 spherePos, float radius) {\n    rayOrig -= spherePos;\n    float b = 2.0 * dot(rayOrig, rayDir);\n    float c = dot(rayOrig, rayOrig) - radius * radius;\n    float dsc2 = b * b - 4.0 * c;\n\n    float dsc = sqrt(abs(dsc2));\n    return dsc - b;\n}\n\n// Hash function from https://www.shadertoy.com/view/4djSRW\nfloat hash13(vec3 p3) {\n\tp3  = fract(p3 * .1031);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n// Simple fractal noise used for terrain texturing and clouds\nfloat fbm(vec2 pos) {\n\tfloat noise = 0.5;\n    noise += (texture(iChannel0, pos * 1.0).x - 0.5) * 0.75;\n    noise += (texture(iChannel0, pos * 2.0).x - 0.5) * 0.75 * 0.5;\n    noise += (texture(iChannel0, pos * 4.0).x - 0.5) * 0.75 * 0.25;\n    noise += (texture(iChannel0, pos * 8.0).x - 0.5) * 0.75 * 0.125;\n    return noise;\n}\n\nfloat sdfSphere(vec3 pos, float radius) {\n\treturn length(pos) - radius;\n}\n\n// from that MediaMolecule talk\nfloat sdfSoftUnion(float a, float b, float r) {\n\tfloat e = max(r - abs(a - b), 0.0);\n\treturn min(a, b) - e*e*0.25/r;\n}\n\nstruct SdfObj {\n\tfloat dist;\n    int material; // -1: sky, 0: ground, 1: water\n};\n    \n// Value from noise controls height of the sdf sphere.\n// Shape is a tradeoff between sphere radius and soft union radius\nfloat sdfTerrainCell(vec3 pos, float height, float shape) {\n    pos.y -= (height - 1.0) * (1.0 - shape);\n\treturn sdfSphere(pos, (1.0 - shape));\n}\n    \n// Returns the signed distance to a terrain object\nfloat sdfTerrain(vec3 globalPos, float scale, float lacunarity,\n                 float shape, int levels, float seed) {\n    float dist = globalPos.y; // Initialize to ground plane\n    \n    float heightMult = 1.0;\n    vec4 cellDisp = vec4(0.0);\n    \n    // Iteratively refine the distance field at increasing levels of detail\n    for (int level = 0; level < levels; level++) {\n        if (abs(dist) > scale) break; // Early-out, no need to refine further\n    \tvec3 pos = globalPos / scale;\n\n        vec3 baseCellPos = vec3(fract(pos.x), pos.y, fract(pos.z));\n        vec3 baseCellIndex = vec3(floor(pos.x), seed + float(level), floor(pos.z));\n\t\t\n        // Considers only 4 nearest grid aligned blobs at each level of detail\n        float h00 = hash13(baseCellIndex + vec3(0, 0, 0)) * heightMult;\n        float h01 = hash13(baseCellIndex + vec3(0, 0, 1)) * heightMult;\n        float h10 = hash13(baseCellIndex + vec3(1, 0, 0)) * heightMult;\n        float h11 = hash13(baseCellIndex + vec3(1, 0, 1)) * heightMult;\n        \n        float cell00 = sdfTerrainCell(baseCellPos - vec3(0, cellDisp.x, 0), h00, shape);\n        float cell01 = sdfTerrainCell(baseCellPos - vec3(0, cellDisp.y, 1), h01, shape);\n        float cell10 = sdfTerrainCell(baseCellPos - vec3(1, cellDisp.z, 0), h10, shape);\n        float cell11 = sdfTerrainCell(baseCellPos - vec3(1, cellDisp.w, 1), h11, shape);\n         \n        dist = sdfSoftUnion(dist, cell00 * scale, shape * scale);\n        dist = sdfSoftUnion(dist, cell10 * scale, shape * scale);\n        dist = sdfSoftUnion(dist, cell01 * scale, shape * scale);\n        dist = sdfSoftUnion(dist, cell11 * scale, shape * scale);\n        \n        scale *= 0.5;\n        heightMult *= lacunarity;\n        \n        // Interpolate cell displacement on downscale\n        // Not an exact solution, but makes interesting patterns regardless\n        cellDisp = (cellDisp + vec4(h00, h01, h10, h11) * 0.5) * 2.0;\n        if (baseCellPos.x <= 0.5) {\n        \tcellDisp.zw = (cellDisp.xy + cellDisp.zw) * 0.5;\n        } else {\n        \tcellDisp.xy = (cellDisp.xy + cellDisp.zw) * 0.5;\n        }\n        \n        if (baseCellPos.z <= 0.5) {\n        \tcellDisp.yw = (cellDisp.xz + cellDisp.yw) * 0.5;\n        } else {\n        \tcellDisp.xz = (cellDisp.xz + cellDisp.yw) * 0.5;\n        }\n    }\n    \n    return dist;\n}\n\n// Returns the signed distance to the entire scene\nSdfObj sdf(vec3 pos, int levelOfDetail, vec3 cameraPos) {\n\t// Add curvature\n    vec2 relPos = pos.xz - cameraPos.xz;\n    pos.y += dot(relPos, relPos) * 0.002;\n    \n    // Base ground terrain\n    float groundDist = sdfTerrain(pos, 20.0, 0.8, 0.4, 6 - levelOfDetail, 0.0);\n    \n    // Upside down terrain for the bottom of the islands\n    vec3 islandPos = vec3(pos.x, 24.0 - pos.y, pos.z);\n    float islandDist = sdfTerrain(islandPos, 15.0, 0.95, 0.4, 6 - levelOfDetail, 4625.9);\n    \n    // Cutoff terrain forming the top of the islands\n    vec3 cutoffPos = vec3(pos.x, 25.0 - pos.y, pos.z);\n    float cutoffDist = sdfTerrain(cutoffPos, 30.0, 1.0, 0.3, 2, 1967.3);\n    \n    // Combine terrains\n    islandDist = -sdfSoftUnion(-islandDist, cutoffDist, 1.0);\n    float terrainDist = sdfSoftUnion(groundDist, islandDist, 1.0);\n    \n    SdfObj terrain;\n    terrain.dist = terrainDist;\n    \n    // Wavey water\n    SdfObj water;\n    float wavex = sin(pos.x);\n    float wavey = sin(pos.z + wavex * 1.0 + iTime);\n    float waves = wavex * wavey * 0.05;\n    water.dist = pos.y - 7.5 + waves;\n    water.material = 1;\n    \n    SdfObj result;\n    result.dist = min(terrain.dist, water.dist);\n    result.material = result.dist == terrain.dist ? terrain.material : water.material;\n    return result;\n}\n\nstruct SurfaceHit {\n\tfloat depth;\n    float minSurfDistance;\n    float iterCount;\n    int material;\n};\n\nSurfaceHit raymarch(vec3 rayOrig, vec3 rayDir, int maxIterations,\n                    int levelOfDetail, float maxDepth, vec3 cameraPos) {\n\tSurfaceHit sHit;\n    sHit.depth = 0.01;\n    sHit.minSurfDistance = 1000.0;\n    sHit.iterCount = 0.0;\n    sHit.material = 0;\n    \n    for (int iter = 0; iter < maxIterations; iter++) {\n    \tSdfObj obj = sdf(rayOrig + rayDir * sHit.depth, levelOfDetail, cameraPos);\n        \n        sHit.minSurfDistance = min(sHit.minSurfDistance, obj.dist);\n        if (abs(obj.dist) < sHit.depth * RAYMARCH_PRECISION) {\n            sHit.material = obj.material;\n            break;\n        } else if (sHit.depth > maxDepth) {\n            sHit.material = -1;\n        \tbreak;\n        }\n        \n        sHit.depth += obj.dist * RAYMARCH_STEP_FACTOR;\n        sHit.iterCount += 1.0;\n    }\n    \n    return sHit;\n}\n\nvec3 sdfGradient(vec3 point, vec3 cameraPos) {\n    float dx = sdf(point + vec3(0.001, 0.0, 0.0), 0, cameraPos).dist -\n        \t   sdf(point - vec3(0.001, 0.0, 0.0), 0, cameraPos).dist;\n    \n    float dy = sdf(point + vec3(0.0, 0.001, 0.0), 0, cameraPos).dist -\n        \t   sdf(point - vec3(0.0, 0.001, 0.0), 0, cameraPos).dist;\n \n    float dz = sdf(point + vec3(0.0, 0.0, 0.001), 0, cameraPos).dist -\n        \t   sdf(point - vec3(0.0, 0.0, 0.001), 0, cameraPos).dist;\n\n    return normalize(vec3(dx, dy, dz));\n}\n\nvec3 skyColor(float theta) {\n    float f = min((1.0 - theta) * 0.7, 1.0);\n\treturn (vec3(0.3, 0.5, 2.0) + vec3(1.5, 1.4, 1.1)*f*f*f) * 1.5;\n}\n\n// Ambient lighting defined as a function of the vertical angle and upwards occlusion\nvec3 ambientColor(float theta, float shadow) {\n\tfloat f1 = max(theta, 0.0);\n    f1 = f1 * f1 * min(shadow * 1.5, 1.0);\n    float f2 = min(1.0 + theta, 1.0);\n    \n    vec3 sky = mix(vec3(0.25) * 0.5, vec3(0.45, 0.55, 1.5), f1);\n    return mix(vec3(0.15, 0.15, 0.1) * 0.5, sky, f2);\n}\n\n// Ground texture\nvec3 groundColor(vec3 position, vec3 normal) {\n    float slope = normal.y * 0.5 + 0.5;\n    slope -= fbm(position.xz * 0.01) * 0.5;\n    slope = smoothstep(0.0, 1.0, max(slope, 0.0));\n    \n    return mix(vec3(0.5, 0.4, 0.2), vec3(0.5, 0.8, 0.1), slope);\n}\n\n// Exponential fog\nvec3 fog(vec3 color, float theta, float depth) {\n\tvec3 sky = skyColor(theta);\n    float d = exp2(-depth * 0.004);\n    return mix(sky, color, d);\n}\n\n// Adds a cloud sphere\nvec3 skyWithClouds(vec3 rayOrig, vec3 rayDir, vec3 cameraPos) {\n    const float CS_RADIUS = 300.0;\n    const float CS_HEIGHT = 20.0;\n    \n    vec3 spherePos = vec3(cameraPos.x, CS_HEIGHT - CS_RADIUS, cameraPos.z);\n\tfloat t = innerRaySphere(rayOrig, rayDir, spherePos, CS_RADIUS);\n    vec3 cloudPos = rayOrig + rayDir * t;\n    \n    float cloudDensity = max(fbm(cloudPos.xz / 10000.0) - 0.25, 0.0) / 0.75;\n    cloudDensity = smoothstep(0.0, 1.0, cloudDensity * cloudDensity);\n    \n    vec3 sky = skyColor(rayDir.y);\n    float d = exp2(-t * 0.004);\n    return mix(sky, vec3(1.6, 1.8, 2.0), d * cloudDensity);\n}\n\nvec3 shadeSurface(SurfaceHit sHit, vec3 rayOrig, vec3 rayDir, vec3 cameraPos) {\n    if (sHit.material < 0) {\n        return skyWithClouds(rayOrig, rayDir, cameraPos);\n    }\n    \n    vec3 position = rayOrig + rayDir * sHit.depth;\n    vec3 normal = sdfGradient(position, cameraPos);\n    \n    // Shade sunlight with soft shadows\n    float sun = max(dot(normal, SUN_DIRECTION), 0.0);\n    \n    SurfaceHit shadowHit = raymarch(\n        position + SUN_DIRECTION * 1.5, SUN_DIRECTION, SHADOW_MAX_ITER, 2,\n        50.0, cameraPos);\n    float minSurfDistance = max(shadowHit.minSurfDistance + 0.1, 0.0);\n    float shadow = min(minSurfDistance * 1.5, 1.0);\n    shadow = smoothstep(0.0, 1.0, shadow);\n    sun *= shadow;\n    \n    vec3 light = SUNLIGHT_COLOR * sun;\n    \n    // Add ambient lighting\n    SurfaceHit aoHit = raymarch( // Cast a very soft shadow query upwards\n        position + vec3(0.0, 1.0, 0.0), vec3(0.0, 1.0, 0.0), AMBIENT_MAX_ITER, 4,\n        10.0, cameraPos);\n    minSurfDistance = max(aoHit.minSurfDistance, 0.0);\n    float aoShadow = min(minSurfDistance * 0.25, 1.0);\n    light += ambientColor(normal.y, aoShadow) * AMBIENT_LIGHT_INTENSITY; \n    \n    // Combine and apply fog\n    vec3 diffuse = groundColor(position, normal);\n    return fog(diffuse * light, rayDir.y, sHit.depth);\n}\n\nvec3 shade(SurfaceHit sHit, vec3 rayOrig, vec3 rayDir) {\n    // Choose surface to shade\n    SurfaceHit shadedHit = sHit;\n    vec3 shadeRayOrig = rayOrig;\n    vec3 shadeRayDir = rayDir;\n    \n#ifndef NO_WATER_SHADING\n    if (sHit.material == 1) {\n        // Water reflection, shade the reflected surface instead\n        vec3 position = rayOrig + rayDir * sHit.depth;\n    \tvec3 normal = sdfGradient(position, rayOrig);\n        \n    \tvec3 reflDir = reflect(rayDir, normal);\n        vec3 reflOrig = position + reflDir * 0.5;\n        \n        shadedHit = raymarch(\n            reflOrig, reflDir, REFLECTION_MAX_ITER, 1, 100.0, rayOrig);\n        shadeRayOrig = reflOrig;\n        shadeRayDir = reflDir;\n    }\n#endif\n    \n    vec3 color = shadeSurface(shadedHit, shadeRayOrig, shadeRayDir, rayOrig);\n    \n    if (sHit.material == 1) {\n        // Apply water color and camera -> water surface fog\n        color = fog(color * vec3(0.8, 0.9, 1.0), rayDir.y, sHit.depth);\n    }\n    \n    return color;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (fragCoord.xy - iResolution.xy*0.5) / iResolution.y;\n    \n    // Shamelessly stole camera setup from https://www.shadertoy.com/view/Xs3GRB\n    float ang, si, co;\n    ang = -(iMouse.x / iResolution.x - 0.5) * 6.0 - 1.0;\n    si = sin(ang); co = cos(ang);\n    mat4 cam_mat = mat4(\n        co, 0., si, 0.,\n        0., 1., 0., 0.,\n        -si, 0., co, 0.,\n        0., 0., 0., 1.);\n    ang = -(iMouse.y / iResolution.y - 0.5) * 1.5;\n    si = sin(ang); co = cos(ang);\n    cam_mat = cam_mat * mat4(\n        1., 0., 0., 0.,\n        0., co, si, 0.,\n        0.,-si, co, 0.,\n        0., 0., 0., 1.);\n    \n    vec3 rayOrig = vec3(0.0, 12.0, 0.0) + vec3(3.0, 0.0, 2.0) * iTime * CAMERA_TRAVEL_SPEED;\n    vec3 rayDir = normalize(vec3(cam_mat*vec4(uv, 1., 0.)));\n    \n    // Attempt to move camera out of the way of terrain\n    SdfObj scene = sdf(rayOrig, 4, rayOrig);\n    float displ = min(2.0 - scene.dist, 5.0);\n    displ = (sqrt(displ * displ + 1.0) + displ) * 0.5;\n    rayOrig.y += displ;\n\t\n    // This is where your GPU starts weeping\n    SurfaceHit sHit = raymarch(rayOrig, rayDir, RAYMARCH_MAX_ITER, 0, 200.0, rayOrig);\n    vec3 color = shade(sHit, rayOrig, rayDir);\n    \n\t// Tonemapping, vignette and gamma correction\n    color *= 2.0;\n    color = color / (color + 1.0);\n    color *= 1.0 - smoothstep(0.0, 1.0, max(length(uv) * 1.3 - 0.75, 0.0)) * 0.5;\n    color = pow(color, vec3(1.0/2.2));\n    \n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [{"id": "4dXGzn", "previewfilepath": "/media/ap/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "channel": 0, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4syfWd.jpg", "access": "shaders20k", "license": "mit", "functions": [[1067, 1137, 1216, 1216, 1429], [1431, 1491, 1514, 1514, 1617], [1619, 1681, 1702, 1702, 2007], [2009, 2009, 2050, 2050, 2082], [2084, 2116, 2163, 2163, 2234], [2323, 2445, 2504, 2504, 2590], [2596, 2647, 2766, 2766, 4968], [4970, 5021, 5078, 5096, 6306], [6412, 6412, 6550, 6550, 7243], [7245, 7245, 7291, 7291, 7755], [7757, 7757, 7785, 7785, 7897], [7899, 7985, 8031, 8031, 8267], [8269, 8287, 8333, 8333, 8540], [8542, 8561, 8609, 8609, 8707], [8709, 8732, 8795, 8795, 9339], [9341, 9341, 9420, 9420, 10632], [10634, 10634, 10690, 10721, 11623], [11625, 11625, 11680, 11680, 13120]], "test": "untested"}
{"id": "4syfWK", "name": "scroller", "author": "lennyjpg", "description": "dsfgsdf", "tags": ["sdgfsdgf"], "likes": 4, "viewed": 327, "published": "Public API", "date": "1530404990", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    float y = uv.y*20.0, x = uv.x;\n    float t = iTime, scroll = t*0.123;\n    scroll += (sin(t+scroll*7.3)+1.0)*0.5;\n    scroll += .1*(tan(t*1.1) + sin( t*0.7 ));\n    scroll += .2*cos( scroll *0.36);\n    float e = floor(x*7.0+2.0);\n    y -= scroll*e;\n    y *= e;\n    fragColor = vec4(sin(y)*10.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4syfWK.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 397]], "test": "untested"}
{"id": "4t3cDM", "name": "Happy Plant 2", "author": "lnae", "description": "A variation of https://www.shadertoy.com/view/4ltyD4.\nThis one is a bit slow", "tags": ["raymarching", "watercolor", "npr", "plant"], "likes": 26, "viewed": 444, "published": "Public", "date": "1532795852", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI 3.14159\n#define PHI 1.618\n#define STEPS 64.\n#define EPS 0.00001\n#define EPSN 0.001\n#define EPSOUT 0.008\n#define NB_LEAVES 14.\n\n\nfloat hash(vec3 p){\n\treturn fract(123456.789 * sin(dot(p, vec3(12.34, 56.78, 91.01))));\n}\n\nmat2 rot(float a){\n    float c = cos(a);\n    float s = sin(a);\n\treturn mat2(c, -s, s, c);\n}\n\nfloat smoothmin(float a, float b, float k){\n\tfloat f = clamp(0.5 + 0.5 * (a - b) / k, 0., 1.);\n    return mix(a, b, f) - k * f * (1. - f);\n}\n\nfloat smoothmax(float a, float b, float k){\n\treturn -smoothmin(-a, -b, k);\n}\n\nfloat smoothabs(float p, float k){\n\treturn sqrt(p * p + k * k) - k;\n}\n\nfloat noise(vec3 p){\n\tvec3 f = fract(p);\n    f = f * f * (3. - 2. * f);\n    vec3 c = floor(p);\n  \n    return mix(mix(mix(hash(c), hash(c + vec3(1., 0., 0.)), f.x),\n               \t   mix(hash(c + vec3(0., 1., 0.)), hash(c + vec3(1., 1., 0.)), f.x),\n               \t   f.y),\n               mix(mix(hash(c + vec3(0., 0., 1.)), hash(c + vec3(1., 0., 1.)), f.x),\n               \t   mix(hash(c + vec3(0., 1., 1.)), hash(c + vec3(1., 1., 1.)), f.x),\n               \t   f.y),\n               f.z);  \n}\n\nfloat fbm(vec3 p){\n\tvec3 pos = 10. * p;\n    float c = 0.5;\n    float res = 0.;\n    for(int i = 0; i < 4; i++){\n        pos.xy = rot(2.) * pos.xy;\n        pos = pos * 2. + 2.;\n    \tres += c * noise(pos);\n        c /= 2.;\n    }\n    return res;\n}\n\nfloat distLeaf(vec3 pos, float angle, float size, out float color, float f){\n    float radius = size;\n    float c = 0.95 * radius;\n    float r = length(pos.xz) / radius;\n    pos.xy = rot(angle + 0.2 * r) * pos.xy;\n    \n    color = smoothstep(0.3, 0.6, r * r * cos(200. * pos.z) + 0.99 * f);\n\n    pos.y -= 0.02;\n    pos.x -= 0.25 * radius;\n    pos.z = smoothabs(pos.z, 0.0075);\n    \n    float dist = length(pos - vec3(0., c, -0.05)) - radius;\n  \n    dist = smoothmin(dist, length(pos.yz), 0.1);\n    dist = smoothmax(dist, length(pos) - (radius + 0.1), 0.1);\n    dist = smoothmax(dist, pos.y - 0.01, 0.01);\n    \n    return dist;\n\n}\n\nfloat distScene(in vec3 pos, out int object, out float colorVariation){\n    \n    pos.yz = rot(0.5 + 0.25 * (0.5 + 0.5 * sin(0.25 * iTime - 0.5 * PI))) * pos.yz;\n    pos.xz = rot(0.25 * iTime) * pos.xz;\n    pos.y += 0.22;\n    \n    float f = noise(100. * pos);\n    float sf = smoothstep(0.4, 0.5, f);\n    \n    //floor\n    float dist = pos.y;\n    object = 0;\n    colorVariation = 0.;\n    \n    //pot\n    vec3 p = pos;\n    p.y -= 0.155;\n    float distPot = length(p) - 0.2;\n    distPot = smoothmax(distPot, p.y - 0.097, 0.01);\n    distPot = smoothmax(distPot, -(length(p) - 0.18), 0.01);\n    distPot = max(distPot, -(p.y + 0.15));\n    dist = min(dist, distPot);\n    \n    if(dist == distPot){\n        object = 1;\n        float angleh = atan(p.z, p.x);\n        float anglev = acos(p.y / 0.2);\n        colorVariation = 0.9 * smoothstep(0.1, 0.2, 0.5 * sin(5. * sin(10. * anglev)) * sin(5. * sin(10. * angleh)) + 0.3 * (f - 0.5)) + 0.1 * sf;\n    }\n    \n    //ground\n    float distGround = max(p.y - 0.06 + 0.01 * (noise(150. * p) - 0.5), length(p) - 0.18);\n    dist = min(dist, distGround);\n    \n    if(dist == distGround){\n        object = 2;\n        colorVariation = 0.;\n    }\n    \n\t//plant\n    p = pos;\n    p.y -= 0.2;\n    float distPlant = 100.;\n    float anim = 0.05 * (0.5 + 0.5 * sin(5. * iTime));\n    float leafAngle = 1.2;\n    float offset = 0.01;\n    float size = 0.11;\n    float leafRot = 2. * PI / PHI;\n    float leafColor, lc, d;\n    \n    for(float i = 0.; i < NB_LEAVES; i++){\n        p.xz = rot(leafRot) * p.xz;\n        leafAngle *= 0.92;\n        size *= 1.04;\n        offset += 0.002;\n        d = distLeaf(p - vec3(offset, 0., 0.), leafAngle + anim, size, lc, f);\n        distPlant = min(distPlant, d); \n        if(d == distPlant) leafColor = lc;\n    }\n    dist = min(dist, distPlant);\n    \n    if(dist == distPlant){\n        object = 3;\n        colorVariation = 0.7 * smoothstep(0.8, 0., leafColor) + 0.3 * sf;\n    }\n               \n    return 0.8 * dist;\n}\n\nvec3 getNormal(vec3 p){\n    float c;\n    int o;\n\treturn normalize(vec3(distScene(p + vec3(EPSN, 0., 0.), o, c) - distScene(p - vec3(EPSN, 0., 0.), o, c),\n    \t\t\t\t\t  distScene(p + vec3(0., EPSN, 0.), o, c) - distScene(p - vec3(0., EPSN, 0.), o, c),\n                          distScene(p + vec3(0., 0., EPSN), o, c) - distScene(p - vec3(0., 0., EPSN), o, c)));\n}\n\nvec3 render(vec2 uv){\n    \n    vec3 inkColor = vec3(0.15, 0.25, 0.4);\n    vec3 col = inkColor;\n    \n    //raymarch\n    vec3 eye = vec3(0., 0., 5);\n    vec3 ray = normalize(vec3(uv, 1.) - eye);\n    int o;\n    float dist, step, c, prevDist;\n    bool hit = false;\n    vec3 pos = eye;\n    dist = distScene(pos, o, c);\n    float outline = 1.;\n    \n    for(step = 0.; step < STEPS; step++){\n        prevDist = dist;\n    \tdist = distScene(pos, o, c);\n        if(dist > prevDist + EPS && dist < EPSOUT ){\n        \toutline = min(outline, dist);\n        }\n        if(abs(dist) < EPS){\n        \thit = true;\n            break;\n        }\n    \tpos += dist * ray;\n    }\n    outline /= EPSOUT;\n    \n    vec3 normal = getNormal(pos);\n    float f = fbm(pos);\n    \n    //shading\n    if(hit){\n    \tvec3 light = vec3(10., 5., 5.);\n        light.yz = rot(0.5) * light.yz;\n        float shine = 30.;\n        \n        //paper\n        if(o == 0){\n        \tcol = 1. - 0.025 * vec3(smoothstep(0.6, 0.2, fbm(vec3(uv * 6.,1.))));\n        }\n        //pot\n        if(o == 1) col = mix(vec3(0.8, 0.7, 0.65), vec3(1.), 0.8 * c);\n        if(o == 2) col = vec3(0.6, 0.6, 0.6);\n        //plant\n        if(o == 3) {\n            col = mix(vec3(0.3, 0.7, 0.6), vec3(0.85, 0.95, 0.7), c);\n\t\t\tshine = 5.;\n        }\n        \n        //diffuse\n        vec3 l = normalize(light - pos);\n        float diff = dot(normalize(normal + 0.2 * vec3(f - 0.5)), l);\n        diff = smoothstep(0.4, 0.5, diff + 0.3 * f);\n        if(o != 0) col = mix(col, vec3(0.1, 0.3, 0.75), 0.3 * (1. - diff));\n        \n        //specular\n        vec3 refl = reflect(-l, normal);\n        float spec = pow(dot(normalize(eye - pos), refl), shine);\n        spec = smoothstep(0.5, 0.6, spec + 0.5 * f);\n        col += 0.01 * shine * spec;\n        \n        //outline\n        outline = smoothstep(0.75, 0.95, outline + 0.9 * f);\n        col = mix(inkColor, col, outline);\n    }  \n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.x;\n    uv *= 0.8;\n    vec3 col = render(uv);\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4t3cDM.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[139, 139, 158, 158, 228], [230, 230, 248, 248, 321], [323, 323, 366, 366, 463], [465, 465, 508, 508, 541], [543, 543, 577, 577, 612], [614, 614, 634, 634, 1107], [1109, 1109, 1127, 1127, 1352], [1354, 1354, 1430, 1430, 1983], [1985, 1985, 2056, 2056, 3950], [3952, 3952, 3975, 3975, 4312], [4314, 4314, 4335, 4335, 6235], [6237, 6237, 6294, 6294, 6435]], "test": "untested"}
{"id": "4t3cDn", "name": "Snowy Moutains", "author": "CALI", "description": "Work in progress", "tags": ["mountains", "snowy"], "likes": 2, "viewed": 93, "published": "Public", "date": "1532124000", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const int NUM_STEPS = 300; //how many spheres are shown\nconst float EPSILON\t= 1e-4;\nconst float hesitate =.7;\nconst float pearl = 2.;\nconst float COMPACT =0.0; //change this for fun effect.\n\nfloat rand(float n){\n\treturn fract(sin(n)*43758.5453123);\n}\n\nfloat rand2(vec2 v){\n    return rand(v.x+rand(v.y));\n}\nfloat noise1(float p){\n\n    float f1 = floor(p/pearl)*pearl;\n    float fc = fract(p/pearl);\n    \n    return 5.5*mix(rand(f1),rand(f1+pearl),fc);\n\n}\n\n\nfloat cubeRoot(float x){\n\treturn pow(abs(x),1.0/1.5)*sign(x);\n}\n\nfloat smoothy(float x, float y, float f){\n\treturn mix(x,y,sin((f-.5)*3.14159)/2.0+.5);\n}\n\n\nfloat noise2(vec2 uv){\n\tfloat ix = floor(uv.x);\n    float iy = floor(uv.y);\n    float fx = fract(uv.x);\n    float fy = fract(uv.y);\n    return smoothy(smoothy(rand2(vec2(ix,iy)),rand2(vec2(ix+1.,iy)),fx),\n                      smoothy(rand2(vec2(ix,iy+1.)),rand2(vec2(ix+1.,iy+1.)),fx),fy);\n    return rand2(vec2(ix,iy))*(1.-fx)*(1.-fy)+rand2(vec2(ix+1.,iy))*(fx)*(1.-fy)\n        +rand2(vec2(ix,iy+1.))*(1.-fx)*(fy)+rand2(vec2(ix+1.,iy+1.))*(fx)*(fy);\n\t\n}\n\nfloat dist(vec3 p){ //distance funtion goes here - this generates the spheres\n   return (noise2(p.xz*.015)*11.+noise2(p.xz*.08)*1.8+noise2(p.xz*0.4)*.19+noise2(p.xz*1.0)*.11+noise2(p.xz*3.0)*.03)*5.+p.y;\n\n}\n\n\n\nvec3 getNormal(vec3 p, float eps) { //this function generates the normal vec for the object\n    vec3 n;\n   \n    n.x = dist(vec3(p.x+eps,p.y,p.z));\n\tn.y = dist(vec3(p.x,p.y+eps,p.z));\n    n.z = dist(vec3(p.x,p.y,p.z+eps));\n\n    return normalize(n-vec3(1,1,1)*dist(p));\n}\n\nvec3 march(vec3 ori, vec3 dir, out vec3 p) {  //this is the main raymarching function, give a ray to get a color\n    vec3 center = vec3(0,0,0);\n    vec3 light = 200.*normalize(vec3(cos(1.*iTime),1.1,sin(1.0*iTime)));\n\n    \n    for(int i = 0; i < NUM_STEPS; i++) {   \n        float tmid = dist(ori);\n        ori = ori + dir * tmid * hesitate;                   \n        \n\t\tif(abs(tmid)< EPSILON) {\n            p = getNormal(ori,1e-1);\n            vec3 pl = normalize(light-p);\n            vec3 gCol = mix(vec3(.39,.26,.13),vec3(1,1,1),smoothstep(-.0,1.0,normalize(p).y*3.-1.5-.3));\n            return gCol*.1+gCol*max(0.0,(dot(p,pl)*.7))+vec3(1,1,.3)*pow(max(0.,dot(p,pl)),30.)*.2;\n            \n            \n\t\t\tp.x = p.x/2.0 +.5;\n            p.y = p.y/2.0 +.5;\n            p.z = p.z/2.0 +.5;\n            //return 1.0;\n        }\n    }\n    return vec3(.6,.6,1)*.8;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 mouse = iMouse.xy/iResolution.xy - vec2(0.5, 0.);\n    if(iMouse.xy == vec2(0.))mouse = vec2(0.5, 0.);\n    mouse.x*=5.;\n    mouse.x += iTime*0.051;\n    mouse.y*=2.;\n    vec2 uv = fragCoord/iResolution.xy;\n\tuv-=0.5;\n    uv.x*=iResolution.x/iResolution.y;\n    float groundHeight = 0.;\n    float angle = mouse.x;\n    float fov = 0.5;\n    float bigness = 2.;\n    float camDist = mouse.y+bigness*2.;\n    vec3 ori = vec3(cos(mouse.x)*camDist, 25.+sin(mouse.x/2.)*cos(mouse.x / 3.3)*3.4, sin(mouse.x)*camDist);\n    vec3 dir = vec3(-cos(mouse.x+uv.x*fov)*2., -0.4+sin(mouse.x)*cos(mouse.x)*.4+uv.y, -sin(mouse.x+uv.x*fov)*2.);\n    dir = normalize(dir);\n\t\n    vec3 p;\n\t//all above code is just to decide camera pos, then color is decided below\n    vec3 color = march(ori,dir,p);\n    \n    \n    // Output to screen\n    fragColor = vec4(color,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4t3cDn.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[160, 191, 211, 211, 250], [252, 252, 272, 272, 306], [307, 307, 329, 329, 454], [457, 457, 481, 481, 520], [522, 522, 563, 563, 610], [613, 613, 635, 635, 1068], [1070, 1070, 1089, 1147, 1276], [1280, 1280, 1315, 1371, 1549], [1551, 1551, 1595, 1663, 2414], [2416, 2416, 2473, 2473, 3320]], "test": "untested"}
{"id": "4t3cRH", "name": "Another Piet Mondrian - Tableau", "author": "darkeclipz", "description": "Piet Mondrian - Tableau;\nhttps://thebookofshaders.com/07/\n", "tags": ["mondrian"], "likes": 6, "viewed": 146, "published": "Public", "date": "1531431289", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float random (in vec2 st) {\n    return fract(sin(dot(st.xy,\n                         vec2(12.9898,78.233)))*\n        43758.5453123);\n}\n\n// Based on Morgan McGuire @morgan3d\n// https://www.shadertoy.com/view/4dS3Wd\nfloat noise (in vec2 st) {\n    vec2 i = floor(st);\n    vec2 f = fract(st);\n\n    // Four corners in 2D of a tile\n    float a = random(i);\n    float b = random(i + vec2(1.0, 0.0));\n    float c = random(i + vec2(0.0, 1.0));\n    float d = random(i + vec2(1.0, 1.0));\n\n    vec2 u = f * f * (3.0 - 2.0 * f);\n\n    return mix(a, b, u.x) +\n            (c - a)* u.y * (1.0 - u.x) +\n            (d - b) * u.x * u.y;\n}\n\n#define OCTAVES 4\nfloat fbm (in vec2 st) {\n    // Initial values\n    float value = 0.0;\n    float amplitude = .5;\n    float frequency = 0.;\n    //\n    // Loop of octaves\n    for (int i = 0; i < OCTAVES; i++) {\n        value += amplitude * noise(st);\n        st *= 1.5;\n        amplitude *= .5;\n    }\n    return value;\n}\n// From FabriceNeyret2\n#define step(a,x) smoothstep(0.,1.5/iResolution.y,x-a)\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 R = iResolution.xy;\n    vec2 uv = fragCoord/iResolution.y;\n\n    vec3 col = vec3(0.9);\n    float t = iTime/4.;\n    \n    float p = 0.1*fbm(uv+t);\n    float q = fbm(uv+5.*p+t);\n    float r = fbm(uv+10.*q+t);\n    \n    r = r*.5-.5;\n    \n    uv = uv - (0.1+0.2*t)*r;\n    \n    col = mix(col, vec3(.7,.1,.1), step(0.6, uv.y) * (1. - step(0.4, uv.x)) );\n    col = mix(col, vec3(.95,.75,0), step(0.6, uv.y) * step(1.6, uv.x) );\n    col = mix(col, vec3(.2,.4,.9), (1.-step(0.2, uv.y)) * step(1.4, uv.x) );\n    \n    col = mix(col, vec3(.15), step(0.78, uv.y) - step(0.82, uv.y));\n    col = mix(col, vec3(.15), step(0.58, uv.y) - step(0.62, uv.y));\n    col = mix(col, vec3(.15), step(0.38, uv.x) - step(0.42, uv.x));\n    col = mix(col, vec3(.15), (step(0.18, uv.x) - step(0.22, uv.x))*step(0.58, uv.y));\n    col = mix(col, vec3(.15), step(1.58, uv.x) - step(1.62, uv.x));\n    col = mix(col, vec3(.15), step(1.38, uv.x) - step(1.42, uv.x));\n    col = mix(col, vec3(.15), (step(0.18, uv.y) - step(0.22, uv.y)) * step(0.38, uv.x) );\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4t3cRH.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 27, 27, 134], [136, 214, 240, 240, 620], [640, 640, 664, 686, 941], [942, 1020, 1077, 1127, 2211]], "test": "untested"}
{"id": "4t3cRS", "name": "thickness", "author": "Torumu106", "description": "thickness test", "tags": ["thickness"], "likes": 3, "viewed": 97, "published": "Public", "date": "1532949276", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\nfloat map(vec3 p){\n    //float d = length(p-vec3(0.0,0.0,1.0)) - 0.25;\n    float d = sdBox(p - vec3(0.0,0.0,0.2), vec3(0.4,0.4,0.4));\n\treturn d;\n}\nfloat trace(vec3 o, vec3 r){\n\tfloat t = 0.0;\n    for(int i = 0; i < 32; ++i){\n    \tvec3 p = o + r * t;\n        float d = map(p);\n        t += d * 0.5;\n    }\n    return t;\n}\nvec4 bgcolor(vec2 uv){\n    vec2 r = 2.0 * vec2(uv.x - 0.5, uv.y - 0.5);\n    r.x *= iResolution.x / iResolution.y;\n    vec3 ret = vec3(1.0, 1.0, 1.0);\n    float sqrt3 = 1.73205;\n    r *= 2.5;\n    \n    float the = 0.0 + iTime * 0.3;\n    r.xy *= mat2(cos(the), -sin(the), sin(the), cos(the));\n    \n    vec2 r1 = abs(r);\n    r1.y += 1.0 * r1.x / sqrt3;\n    if(r1.x <= 0.5 *  sqrt3 && r1.y  <= 1.0){\n    \tret = vec3(1.0);\n    }\n    vec2 r2 = abs(r - vec2(sqrt3 * 0.5, -1.5));\n    r2.y += 1.0 * r2.x / sqrt3;\n    if(r2.x <= 0.5 *  sqrt3 && r2.y  <= 1.0){\n    \tret = vec3(1.0, 0.0, 0.0);\n    }\n    vec2 r3 = abs(r - vec2(sqrt3 * 0.5, 1.5));\n    r3.y += 1.0 * r3.x / sqrt3;\n    if(r3.x <= 0.5 *  sqrt3 && r3.y  <= 1.0){\n    \tret = vec3(0.0, 1.0, 0.0);\n    }\n    vec2 r4 = abs(r - vec2(sqrt3, 0.0));\n    r4.y += 1.0 * r4.x / sqrt3;\n    if(r4.x <= 0.5 *  sqrt3 && r4.y  <= 1.0){\n    \tret = vec3(1.0, 1.0, 0.0);\n    }\n    vec2 r5 = abs(r - vec2(-sqrt3, 0.0));\n    r5.y += 1.0 * r5.x / sqrt3;\n    if(r5.x <= 0.5 *  sqrt3 && r5.y  <= 1.0){\n    \tret = vec3(0.0, 0.0, 1.0);\n    }\n    vec2 r6 = abs(r - vec2(-sqrt3 * 0.5, 1.5));\n    r6.y += 1.0 * r6.x / sqrt3;\n    if(r6.x <= 0.5 *  sqrt3 && r6.y  <= 1.0){\n    \tret = vec3(0.0, 1.0, 1.0);\n    }\n    vec2 r7 = abs(r - vec2(-sqrt3 * 0.5, -1.5));\n    r7.y += 1.0 * r7.x / sqrt3;\n    if(r7.x <= 0.5 *  sqrt3 && r7.y  <= 1.0){\n    \tret = vec3(1.0, 0.0, 1.0);\n    }\n    \n\treturn vec4(ret,1.0);\n}\nvec4 col = vec4(1.0,1.0,1.0,1.0);\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\tvec2 uv1 = fragCoord.xy / iResolution.xy;\n    uv = uv * 2.0 - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n    vec3 r = normalize(vec3(uv, 1.0));\n    \n    float the = iTime * 0.25;\n    r.xz *= mat2(cos(the), -sin(the), sin(the), cos(the));\n    \n    vec3 o = vec3(-1.0* sin(-the), 0.0, -1.0 * cos(-the));\n    float t = trace(o, r);\n    float thick = trace(o+r*10.0, -r);\n    thick = 10.0 - t - thick;\n    thick=max(thick,0.0);\n    if(thick==0.0) thick = -0.5;\n    thick += 0.5;\n    float fog = pow(0.3,thick);\n    col = bgcolor(uv1);\n    col = vec4(1.0,1.0,1.0,1.0);\n    vec4 fc = col * fog;\n\tfragColor = vec4(fc);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4t3cRS.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 31, 31, 118], [119, 119, 137, 189, 265], [266, 266, 294, 294, 438], [439, 439, 461, 461, 1862], [1897, 1897, 1954, 1954, 2616]], "test": "untested"}
{"id": "4t3czN", "name": "Point In Triangle Test", "author": "Wunkolo", "description": "\"Point In Triangle\" tests using several methods.", "tags": ["math", "rasterization"], "likes": 1, "viewed": 284, "published": "Public", "date": "1531710465", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const float Pi = 3.1415926535897932384626433832795;\n\n// Barycentric Method\nbool PointInTriangleBarycentric(\n    in vec2 Triangle[3],\n    in vec2 Point\n)\n{\n    mat3 Barycentric = inverse(\n        mat3(\n    \t\tTriangle[0], 1.0f,\n        \tTriangle[1], 1.0f,\n        \tTriangle[2], 1.0f\n    \t)\n    );\n\n    vec3 Weights = Barycentric * vec3( Point, 1.0f);\n\n    if(\n        // Weights.x >= 0.0f &&\n        // Weights.y >= 0.0f &&\n        // Weights.z >= 0.0f\n        all( greaterThanEqual( Weights, vec3(0.0f) ) )\n    )\n    {\n        return true;\n    }\n    \n    return false;\n}\n\n// Paremetric Method\nbool PointInTriangleParametric(\n    in vec2 Triangle[3],\n    in vec2 Point\n)\n{\n\tvec2 V0 = Triangle[2] - Triangle[0]; // Vert 0 to Vert 2\n\tvec2 V1 = Triangle[1] - Triangle[0]; // Vert 0 to Vert 1\n\tvec2 V2 = Point       - Triangle[0]; // Vert 0 to Point\n\n\tfloat Dot00 = dot(V0, V0);\n\tfloat Dot01 = dot(V0, V1);\n\tfloat Dot11 = dot(V1, V1);\n    float Dot02 = dot(V0, V2);\n\tfloat Dot12 = dot(V1, V2);\n\n\tfloat Area = (Dot00 * Dot11 - Dot01 * Dot01);\n\tfloat U = (Dot11 * Dot02 - Dot01 * Dot12);\n\tfloat V = (Dot00 * Dot12 - Dot01 * Dot02);\n\n\t// Convert to local plane's Barycentric coordiante system\n\treturn\n\t\t(U >= 0.0f) &&\n\t\t(V >= 0.0f) &&\n\t\t(U + V < Area);\n}\n\n// Cross Product Method\nbool PointInTriangleCross(\n    in vec2 Triangle[3],\n    in vec2 Point\n)\n{\n    vec2 EdgeDir[3] = vec2[](\n    \tTriangle[1] - Triangle[0],\n        Triangle[2] - Triangle[1],\n        Triangle[0] - Triangle[2]\n\t);\n    \n    vec2 PointDir[3] = vec2[](\n    \tPoint - Triangle[0],\n        Point - Triangle[1],\n        Point - Triangle[2]\n\t);\n\n    vec3 Crosses = vec3(\n    \tcross( vec3( EdgeDir[0], 0.0f ), vec3( PointDir[0], 0.0f ) ).z,\n        cross( vec3( EdgeDir[1], 0.0f ), vec3( PointDir[1], 0.0f ) ).z,\n        cross( vec3( EdgeDir[2], 0.0f ), vec3( PointDir[2], 0.0f ) ).z\n\t);\n\n    if(\n        // Area1 >= 0.0f &&\n        // Area1 >= 0.0f &&\n        // Area2 >= 0.0f\n        all( greaterThanEqual( Crosses, vec3(0.0f) ) )\n    )\n    {\n        return true;\n    }\n\n    return false;\n}\n\n// Cross Product Method (Optimized)\nbool PointInTriangleCrossOpt(\n    in vec2 Triangle[3],\n    in vec2 Point\n)\n{\n    vec2 EdgeDir[3] = vec2[](\n    \tTriangle[1] - Triangle[0],\n        Triangle[2] - Triangle[1],\n        Triangle[0] - Triangle[2]\n\t);\n    \n    vec2 PointDir[3] = vec2[](\n    \tPoint - Triangle[0],\n        Point - Triangle[1],\n        Point - Triangle[2]\n\t);\n    \n    vec3 Crosses = vec3(\n        // EdgeDir[0].x * PointDir[0].y - EdgeDir[0].y * PointDir[0].x,\n        // EdgeDir[1].x * PointDir[1].y - EdgeDir[1].y * PointDir[1].x,\n        // EdgeDir[2].x * PointDir[2].y - EdgeDir[2].y * PointDir[2].x,\n        // GLSL declares matrices by columns\n        // The determinant of a square matrix is the same as the determinant of its transpose.\n        // So this works too!\n        determinant( mat2( EdgeDir[0], PointDir[0] ) ),\n\t\tdeterminant( mat2( EdgeDir[1], PointDir[1] ) ),\n\t\tdeterminant( mat2( EdgeDir[2], PointDir[2] ) )\n    );\n    \n    if(\n        // Area0 >= 0.0f &&\n        // Area1 >= 0.0f &&\n        // Area2 >= 0.0f\n        all( greaterThanEqual( Crosses, vec3(0.0f) ) )\n    )\n    {\n        return true;\n    }\n    \n    return false;\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\nvec2 Rotate(in vec2 Point, float Angle)\n{\n\tfloat RotSine = sin(Angle);\n\tfloat RotCosine = cos(Angle);\n    \n\treturn mat2(\n        RotCosine, -RotSine,\n        RotSine  ,  RotCosine\n    ) * Point;\n}\n\nvoid mainImage( out vec4 FragColor, in vec2 FragCoord )\n{\n    vec2 UV = -1.0 + 2.0 * (FragCoord/iResolution.xy);\n    UV.x *= iResolution.x/iResolution.y;\n    \n    vec2 Tri[3] = vec2[](\n    \tvec2( -1.5f, -0.5f ),\n    \tvec2(  1.5f, -0.5f ),\n    \tvec2(  1.5f,  0.5f )\n\t);\n    \n    for( int i = 0; i < 3; ++i )\n    {\n        Tri[i] = Rotate( Tri[i], iTime * Pi * 1.0f/25.0f );\n    }\n    \n    const vec4 ColorLut = vec4( 1.0f, 0.5f, 0.25f, 0.0f );\n    vec3 CurColor = vec3( 0.25f );\n    switch( int(FragCoord) / (int(iResolution.x)/4) )\n    {\n        case 0:\n        {\n            CurColor = PointInTriangleBarycentric( Tri, UV ) ? ColorLut.rbr : CurColor;\n            break;\n        }\n        case 1:\n        {\n            CurColor = PointInTriangleParametric( Tri, UV ) ? ColorLut.rgr : CurColor;\n            break;\n        }\n        case 2:\n        {\n            CurColor = PointInTriangleCross( Tri, UV )       ? ColorLut.gra : CurColor;\n            break;\n        }\n        case 3:\n        {\n            CurColor = PointInTriangleCrossOpt( Tri, UV )    ? ColorLut.bgr : CurColor;\n            break;\n        }\n    }\n    \n    FragColor = vec4(\n        CurColor,\n        1.0\n    );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4t3czN.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[53, 75, 154, 154, 569], [571, 592, 670, 670, 1245], [1247, 1271, 1344, 1344, 2049], [2051, 2087, 2163, 2163, 3212], [3214, 3296, 3337, 3337, 3492], [3494, 3494, 3551, 3551, 4674]], "test": "untested"}
{"id": "4t3yR4", "name": "void", "author": "Abvadabra", "description": "Was a bit depressed", "tags": ["sound", "radial"], "likes": 1, "viewed": 164, "published": "Public", "date": "1531649717", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n#define PI atan(1.) * 4.\n\n//taken from https://github.com/wsmind/js-pride/blob/master/shaders/rainbow.glsl\nvec3 rainbow(float x)\n{\n\t/*\n\t\tTarget colors\n\t\t=============\n\t\t\n\t\tL  x   color\n\t\t0  0.0 vec4(1.0, 0.0, 0.0, 1.0);\n\t\t1  0.2 vec4(1.0, 0.5, 0.0, 1.0);\n\t\t2  0.4 vec4(1.0, 1.0, 0.0, 1.0);\n\t\t3  0.6 vec4(0.0, 0.5, 0.0, 1.0);\n\t\t4  0.8 vec4(0.0, 0.0, 1.0, 1.0);\n\t\t5  1.0 vec4(0.5, 0.0, 0.5, 1.0);\n\t*/\n\t\n\tfloat level = floor(x * 6.0);\n\tfloat r = float(level <= 2.0) + float(level > 4.0) * 0.5;\n\tfloat g = max(1.0 - abs(level - 2.0) * 0.5, 0.0);\n\tfloat b = (1.0 - (level - 4.0) * 0.5) * float(level >= 4.0);\n\treturn vec3(r, g, b);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = ( fragCoord.xy / iResolution.xy ) * 2. - 1.;\n\tp.x *= iResolution.x / iResolution.y;\n   \n\t\n\tfloat angle = atan(p.y, p.x) + iTime;\n\tif(angle < 0.) angle += PI * 2.;\n\t\n    float wave = texelFetch( iChannel0, ivec2(1,1), 0 ).x;\n    wave = pow(wave, 3.);\n    \n   \n\tangle -= PI * sin(length(p) * 20. * (wave / 3. + 1.));\n\n\tvec3 color = 1. - rainbow(mod(angle, PI * 2.) / (PI * 2.));\n\tcolor *= (length(p) - .3);\n\tfloat gray = dot(color, vec3(0.299, 0.587, 0.114));\n\tcolor = mix(color, vec3(gray), 1.);\n\t\n\tfragColor = vec4(color, 1.);\n}", "image_inputs": [{"id": "4sjXRt", "previewfilepath": "https://soundcloud.com/ghostemane/ghostemane-venom?in=hzl1vevuyd80/sets/ghostname", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0, "src": "https://soundcloud.com/ghostemane/ghostemane-venom?in=hzl1vevuyd80/sets/ghostname", "ctype": "musicstream"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4t3yR4.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[27, 108, 131, 399, 629], [632, 632, 689, 689, 1231]], "test": "untested"}
{"id": "4t3yRr", "name": "SickBow's Eye", "author": "sickbow", "description": "Eye", "tags": ["eye"], "likes": 4, "viewed": 99, "published": "Public", "date": "1531536601", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define pi 3.1419526535\n\nfloat noise(vec2 uv){\n \n    return fract(sin(uv.x*100. + uv.y*100.));\n    \n}\n\nvec3 eyeBall (vec2 uv, vec3 col, float sizeR, vec2 focus){\n \n    vec2 uvFocus = uv-focus;\n    vec2 glareCenter = vec2(.2,.2);\n    vec3 iris = vec3(57./255., 113./255., 204./255.);\n    float pupSize = sizeR/4.25 + (sin(iTime))/2. * .05;\n    \n    //polar coordinates\n    float r = length(uvFocus);\n    float a = atan(uvFocus.y/uvFocus.x);\n    float rOfTheta = length(vec2(sizeR/2.*cos(45.*a) * cos(a), sizeR/2.*cos(45.*a) * sin(a))); //vector valued function of polar function inside of iris\n    float d = 100.; //distance of uv vector from rOfTheta\n    \n     //iris\n     col = mix(iris, col, smoothstep(sizeR/2.3, sizeR/2., r ));\n \n    //pupil   \n     col = mix(vec3(0.), col, smoothstep( pupSize * 4.25/5.5, pupSize, r ) );\n        \n    //shadows \n     col = mix(col, vec3(0.), smoothstep( 0.5, sizeR, length(uv-focus/2.5)) ); //divide focus to change the speed of outer eye proportional to iris/pupil\n\t col = mix(col, vec3(255./255., 16./255., 2./255.), smoothstep( 0.5, sizeR+.55, length(uv-focus/2.5) ) ); //divide focus to change the speed of inner eye proportional to iris/pupil\n    \n    //lines\n    if (r < rOfTheta)\n    {\n        for(float i = 0.; i < 2.*pi; i+= 2.*pi/10.)\n        {    \n           d = min(d, length(uvFocus - rOfTheta * vec2( cos(a+i), sin(a+i)) ) ); \n        }\n        \n     col = mix(vec3(0.), col, smoothstep(pupSize, pupSize*1.5, r)*smoothstep(.95, 0., d)*smoothstep(0., sizeR/2., r ));   \n    }\n    \n    //glare\n    col += 1.-smoothstep(0., .3, length(uv-glareCenter));\n    \n    //eyelids\n    float cosWave = .35*cos(2.*pi/3.*uv.x);\n    \n    if(uv.y > cosWave){\n     col = mix(vec3(0.), col, 1.-smoothstep(0.,.1, uv.y-(cosWave) ) );     \n    }\n    if(uv.y < -cosWave){\n     col = mix(vec3(0.), col,1.- smoothstep(0.,.1, (-cosWave)-uv.y) );   \n    }\n    \n    \n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    vec2 uv = (2.*fragCoord-iResolution.xy)/iResolution.y;\n\tvec2 mouse = (2.*iMouse.xy-iResolution.xy)/iResolution.y;\n    \n    vec3 col = vec3(1.);\n\t\n    float d = .1*(2.*(floor(sin(iTime/(3.*pi/5.)))+.5)) * (1.+sin(iTime/(3.*pi/5.)))/3.;\n    float theta = 0.;\n    theta += noise( vec2(floor(iTime/(3.*pi/5.)) ));\n    \n    vec2 focusVec = vec2(cos(theta),sin(theta)) * d;\n    \n    //focusVec = mouse; //uncomment to focus eye on mouse\n    \n    col = eyeBall (uv, col, .75, focusVec);\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4t3yRr.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[25, 25, 46, 46, 101], [103, 103, 161, 161, 1909], [1911, 1911, 1968, 1968, 2519]], "test": "untested"}
{"id": "4tccRS", "name": "Arbitrary Regular Polygons ", "author": "nr4", "description": "Regular polygons with loop removed.", "tags": ["2d", "sdf", "polygons", "regular"], "likes": 5, "viewed": 255, "published": "Public", "date": "1532958549", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/*\n * Arbitrary Regular Polygons\n * \n * Copyright (C) 2018  Alexander Kraus <nr4@z10.info>\n * \n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n * \n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n * \n * You should have received a copy of the GNU General Public License\n * along with this program.  If not, see <http://www.gnu.org/licenses/>.\n */\n\n// Update 1: Changed antialiasing like FabriceNeyret2 suggested\n// Update 2: Removed loop from dpoly_min (compare comment from FabriceNeyret2).\n// Update 3: Fabrice's second comment.\n// Update 4: Added borders again\n\nconst float pi = acos(-1.);\nconst vec3 c = vec3(1.,0.,-1.);\n\n// hash function\nfloat r(vec2 a0)\n{\n    return fract(sin(dot(a0.xy ,vec2(12.9898,78.233)))*43758.5453);\n}\n\n// compute distance to regular polygon\nfloat dpoly_min(vec2 x, float N, float R)\n{\n    float d = 2.*pi/N,\n        t = mod(acos(x.x/length(x)), d)-.5*d;\n    return R-length(x)*cos(t)/cos(.5*d);\n}\n\n#define A iResolution.y\n#define B 3./Y\n#define S(v) smoothstep(-1.5/A,1.5/A,v)\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float a = .1; // tile size\n     vec2 uv = fragCoord/A+.5,\n        x = mod(uv, a)-.5*a, y = uv-x; // we want many polygons\n    \n    //random number of edges and random rotation\n    float p = 5.*r(y)*iTime,\n        k = cos(p), s = sin(p),\n        d = dpoly_min(mat2(k,s,-s,k)*x, 3.+floor(5.*r(y)), .45*a); \n    \n    //set random colors\n    vec3 col = .5 + .5*cos(p+uv.xyx+vec3(0.,2.,4.));\n    fragColor = vec4(col*mix(S(d),1.,.5)+S(-abs(.5*d)),1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4tccRS.jpg", "access": "shaders20k", "license": "gpl-3.0-plus", "functions": [[1026, 1043, 1061, 1061, 1131], [1133, 1172, 1215, 1215, 1327], [1408, 1408, 1465, 1465, 1918]], "test": "untested"}
{"id": "4tdcD4", "name": "complex transform rainbow", "author": "ollj", "description": "this shader is identical to its parent, BUT its polar-complex-function subroutines are in a different form. some of these might have better performance.\n", "tags": ["rainbow", "complex", "polar"], "likes": 11, "viewed": 413, "published": "Public API", "date": "1532689276", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n//parent=https://www.shadertoy.com/view/Mt2GDV\n\n//lots of code from a shader,made by Tapio Saarinen aka twitter user @_ardeej\n//just slightly crunched with minot optimizations\n//some os this is \n//by David Bargo-davidbargo/2015\n//License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n// constants\nfloat pi =acos(-1.);\nfloat tau=6.2831853071795864769252867665590057683943387987502116419;\nfloat e  =2.7182818284590452353602874713526624977572470936999595749;//exists as y=exp(1.)???\n#define dd(a)dot(a,a)\nfloat mav(vec2 a){return max(a.x,a.y);}\n\n\n#define dd(a)dot(a,a)\nfloat suv(vec2 a){return a.x+a.y;}\nfloat sub(vec2 a){return a.x-a.y;}\nvec2 sub2(vec4 a){return a.xy-a.zw;}//substract in modulo 2\nvec2 cs(float a){return vec2(cos(a),sin(a));}\nvec2 c2p(vec2 a){return vec2(length(a),atan(a.y,a.x));}\nvec2 p2c(vec2 z){return cs(z.x)*z.y;}//polar to cartesian\nmat2 r2(float a){return mat2(cs(a).xyyx*vec4(1,-1,1,1));}\nfloat arg(vec2 z){return atan(z.y,z.x);}//atan2()is aka \"arg,phase\" //length()is aka \"rad,amplitude\"\n\n//one idea is to define all functions as vec4,and then expand to vec4,and then just ignore most domains later on.\n//this should work in some contexts,but may not work in all contexts,this frame can make a library much smaller,but it also is an overhead.\n//return vec4()and explicitly fill all unused domains with n\nvec4 an(vec4 a,float n){return a;}\nvec4 an(vec3 a,float n){return vec4(a,n);}\nvec4 an(vec2 a,float n){return an(vec3(a,n),n);}\nvec4 an(vec2 a,vec2 n){return vec4(a,a);}//for c2()and c4()this is mod2\nvec4 an(float a,float n){return an(vec2(a,n),n);}\n#define ana1(a)an(a,1.)\n#define anaa(a)an(a,a)\n//#define ana0(a)an(a,0)//leat worksafe\n//#define anaa(a)an(a,a)//unpredictable worksafety\n//exmaple below defines c2()as framed c4;\n#define c4(a)((a)*vec4(1,-1,1,-1))\n//c2(c)=(c.a-c.b*i)\n#define c2(a)c4(anaa(a)).xy\n//#define c2(a)c4(anaa(a)).yx\n//c4(ana1(a)).yx //flawed but cute does vec2(a,1),wich is wrong,should do vec2(a,a)\n//c4(anaa(a)).yx //should do vec2(a,a)\n//#define c2(a)((a)*vec2(1,-1))\n//conjugate(z)is generalized into c2(),to also expand on vec1,must be in [()] for explicit order of operation in complex transforms\n//c2(a)flips horizontally by multiplying with *vec2(1,-1)\n//c2(a.yx).yx ==//a*vec2(-1,1)//sqivel,flip,swivel==flip vertically\n//c4()is 2 complex conjugates in parallel on a vec4.\n\n\n\n\n//real and imaginary parts for polar z\nfloat real(vec2 z){return p2c(z).x;return z.s*cos(z.t);}\nfloat imag(vec2 z){return p2c(z).y;return z.s*sin(z.t);}\n\nvec2 crCo(vec2 a){return sqrt(length(a)+c2(a.x));}//core of complex root function,lacks sign adjustment and scaling!\nvec2 ciCo(vec2 u,vec2 z,float r){return vec2(u.y-u.x+r*r,2.*z.x*z.y);}//core of complex root function,for 3 inverse trigs\nvec2 perp(vec2 a){return vec2(-a.y,a.x);}\n//http://mathworld.wolfram.com/PerpDotProduct.html\n//http://wiki.secondlife.com/wiki/Geometric#Line_and_Line.2C_intersection_point\nfloat perpdot(vec2 a,vec2 b){return dot(perp(a),b);}//==determinant(mat2(a,b)),aka cross2(),for also being the crossproduct()of a mat2.\n\n//complex number polar transforms;[Principal branch==0th branch] is implied unless Cth branch can be set explicity.\nvec2 addc(vec2 a,vec2 b){return a+b;}vec2 subc(vec2 a,vec2 b){return a-b;}///complex addition is trivial\nvec2 mulc(vec2 a,vec2 b){return a*b.x+perp(a)*b.y;}//return a*mat2(b.x,-b.y,b.yx);}//complex multoplication\nvec2 mulc(vec2 a,vec2 b,vec2 c){return mulc(mulc(a,b),c);}//z*w*x=ace-bde-adf-bcf+(acf-bdf+ade+bce)*i//complex mult\nvec2 mulc(vec4 a){return mulc(a.xy,a.zw);}//parallel mult\nvec2 divc(vec2 a,vec2 b){if(a.x==0.)return vec2(65535.);return a*mat2(b,-b.y,b.x)/dd(b);}//return(a*b.x-perp(a)*b.y)/dd(b);}//complex division\n//vec2 po2c(vec2 a){return mulc(a,a);return vec2(sub(a*a),2.*a.x*a.y);}//complex square\nvec2 po2c(vec2 c){vec2 d=c*c;return vec2(d.x-d.y,2.*c.x*c.y);}\nvec2 po3c(vec2 z){float p=z.x*z.x,q=z.y*z.y;return z*vec2(p-3.*q,3.*p-q);}//z*z*z=a*(a*a-3*b*b)+b*(3*a*a-b*b)*i,complex cube\nvec2 recc(vec2 a){if(a.x==0.)return vec2(1e10);return c2(a)/dd(a);}//reciprocal/inverse of z;1/z=(a-b*i)/(a*a+b*b),inverse of z;\n\nvec2 logc(vec2 a){a=c2p(a);a.x=log(a.x);return a;}//return vec2(log(dd(a))*.5,arg(a));}\nvec4 logc(vec4 a){return vec4(logc(a.xy),logc(a.zw));}//parallel logc()\nvec2 logb(vec2 a,vec2 b){return divc(logc(b),logc(a));}//principal branch of the logarithm base b of z,b is complex;\nvec2 logn(vec2 a,float c){return vec2(log(dd(a))*.5,arg(a)+c*tau);}//Cth logarithm-base-e-branch of z,0th==principal,log   z=log(a^2+b^2)/2+(arg(z)+n2p)i\n//vec2 logn(vec2 a,float c){a=c2p(a);return vec2(log(a.x),a.y+c*tau);}//should be the same!\nvec2 lgbn(vec2 a,vec2 b,float c){return divc(logn(b,c),logc(a));}//Cth logarithm-base-a-branch of b,0th==principal,log_b z=log(b)/log(a)\n\nvec2 expc(vec2 a){return cs(a.y)*exp(a.x);}//pow(exp,a)=pow(eul,a)=pow(eul,a(cos(b)+sin(b)*i))\nvec2 powc(vec2 a,vec2 b){return expc(mulc(b,logc(a)));}//pow(b,z)=exp(b*log(a))//0th==principal   branch of pow(z,W)\nvec2 pown(vec2 w,vec2 z,float c){return expc(mulc(w,logn(z,c)));} //Cth branch of pow(z,w)\nvec2 wrtc(vec2 a,vec2 b){return expc(divc(logc(b),a));}//0th==principal   branch of pow(z,(1/w))\nvec2 wrtn(vec2 a,vec2 b,float c){return expc(divc(logn(b,c),a));}//Cth branch of pow(z,(1/w))\n\nvec2 sqrc(vec2 a){float n=a.x+length(a);return vec2(n,a.y)/sqrt(2.*n);}//sqrt(z)= sqrt((sqrt(a^2+b^2)+a)/2)+sgn(b)sqrt((sqrt(a^2+b^2)-a)/2)i,complex root\nvec4 sqrc(vec4 a){vec4 c=vec4(crCo(a.xy),crCo(a.zw));c.yw*=sign(a.yw);return c*.5;}//parallel sqrt(z)\n//vec2 sqrc(vec2 z){vec2 c=sqrt((length(z)+c2(z.x))*.5);c.y*=sign(z.y);return c;}//significantly worse near [.y=0.&&x>0]\n\nvec2 sinc(vec2 z){return .5*cs(z.x).yx*(exp(z.y)+c2(exp(-z.y)));}//vec2 sinc(vec2 z){return vec2(0.5*sin(z.x)*(exp(z.y)+exp(-z.y)),.5*cos(z.x)*(exp(z.y)-exp(-z.y)));}\n//obsoleted  vec2 sinc(vec2 c){vec2 d=exp(c2(c.y));return vec2(sin(c.x)*(d.x+d.y)*.5,cos(c.x)*(d.x-d.y)*.5);}\nvec2 si2c(vec2 c){vec2 d=vec2(exp(c.y),1);return vec2(sin(c.x)*(d.x+d.y)*.5,cos(c.x)*(d.x-d.y)*.5);}\nvec2 cosc(vec2 z){return .5*c2(cs(z.x))*(exp(z.y)+c2(exp(-z.y)));}\n//obsoleted vec2 cosc(vec2 z){ return vec2(0.5*cos(z.x)*(exp(z.y)+exp(-z.y)),-0.5*sin(z.x)*(exp(z.y)-exp(-z.y)));}\n//obsoleted vec2 cosc(vec2 c){vec2 d=exp(c2(c.y));return vec2(cos(c.x)*(d.x+d.y)*.5,-sin(c.x)*(d.x-d.y)*.5);}\nvec2 ta2c(vec2 c){vec2 d=exp(c2(c.y));float e=cos(c.x),s=(d.x-d.y)*.5;return vec2(sin(c.x)*e,s*(d.x+d.y)*.5)/(e*e+s*s);}\nvec2 tanc(vec2 z){return divc(sinc(z),cosc(z));}//tan(z)=sin(z)/cos(z),complex tangent ==ta2c()\nvec2 cotc(vec2 z){return divc(cosc(z),sinc(z));}//cot(z)=cos(z)/sin(z),complex cotangent\n\n////hyperbolics\n// sinh z=sinh(a)cos(b)+cosh(a)sin(b)i,hyperbolic sine\nvec2 sinhc(vec2 z){return .5*cs(z.y)*(exp(z.x)+c2(exp(-z.x)).yx);}//vec2 sinh(vec2 z){ return 0.5*vec2((exp(z.x)-exp(-z.x))*cos(z.y),(exp(z.x)+exp(-z.x))*sin(z.y));}\n//vec2 sinh2c(vec2 z){z=c2(z).yx;return sinc(z);}//close to sinhc but not the same,phase is off nicely\n//cosh(z)= cosh(a)cos(b)+sinh(a)sin(b)i,hyperbolic cosine(swivel-rotate works fine here)\nvec2 coshc(vec2 z){return cosc(c2(z.yx));}//vec2 cosh(vec2 z){ return vec2(0.5*(exp(z.x)+exp(-z.x))*cos(z.y),0.5*(exp(z.x)-exp(-z.x))*sin(z.y));}\nvec2 tanhc(vec2 z){return divc(sinh(z),cosh(z));}//tanh(z)=sinh(z)/cosh(z),hyperbolic tangent\nvec2 cothc(vec2 z){return divc(cosh(z),sinh(z));}//coth(z)=cosh(z)/sinh(z),hyperbolic cotangent\nvec2 sechc(vec2 z){return recc(cosh(z));}//sech(z)=1/cosh(z),hyperbolic secant\nvec2 cschc(vec2 z){return recc(sinh(z));}//csch(z)=1/sinh(z),hyperbolic cosecant\n\n//these look stranger than they likely shozld,possibly buggy\nvec2 arsinc(vec2 z){return c2(logc(perp(z)+sqrc(c2(po2c(z.yx)))+vec2(1,0)).yx);}// arsinc(z)=-log(a*i-b+sqrt(1+b*b-a*a-2abi))*i,inverse sine\n//vec2 arsinc(vec2 z){vec2 a=sqrc(vec2(1.0+z.y*z.y-z.x*z.x,-2.0*z.x*z.y));a=logc(vec2(-z.y+a.x,z.x+a.y));return vec2(a.y,-a.x);}\nvec2 arcosc(vec2 z){return -c2(logc(z+c2(sqrc(po2c(z.yx)+vec2(1,0)).yx)).yx);}//arcosc(z)= log(a+bi-sqrt(1+b^2-a^2-2abi)i)i,inverse cosine\n//vec2 arcosc(vec2 z){ vec2 a=sqrc(vec2(1.0+z.y*z.y-z.x*z.x,-2.0*z.x*z.y));a=logc(vec2(z.x+a.y,z.y-a.x));return vec2(-a.y,a.x);}\nvec2 csec(vec2 z){return recc(cosc(z));}//sec(z)=1/cos(z),complex __secant==complex inverse of complex cosine\nvec2 ccsc(vec2 z){return recc(sinc(z));}//csc(z)=1/sin(z),complex cosecant==complex inverse of complex __sine\n\n\n\n//i am not too sure about the next 5 inverses;likely made some silly error,needs debugging\n//\n//arcotc(z)=i*(log((a^2+b^2-b-ai)/(a^2+b^2))-log((a^2+b^2+b+ai)/(a^2+b^2)))*.5,inverse cotangent\n//arcotc/(seems to be bad code\nvec2 arcotc(vec2 z){float r=z.x*z.x+z.y*z.y;return sub2(c4(logc((vec4(z.yx,-z.yx)+vec4(r,0,r,0)).yxzw/r)))*.5;}//vec2 arcotc(vec2 z){ float p=z.x*z.x;float q=z.y*z.y;float r=p+q;vec2 a=logc(vec2(p+q-z.y,-z.x)/r);vec2 b=logc(vec2(p+q+z.y,z.x)/r);return vec2(b.y-a.y,a.x-b.x)/2.0;}\n//artanc(z)=i*(log(1+b-ai)-log(1-b+ai))*.5 ,inverse tangent\n//tanhc(artanh(c))has some symmetry,but may still be broken\nvec2 artanc(vec2 z){return sub2(c4(logc(vec4(1,0,1,0)-c2(z.yx).xyxy).yxwz))*.5;}//vec2 artanc(vec2 z){ vec2 a=logc(vec2(1.0+z.y,-z.x));vec2 b=logc(vec2(1.0-z.y,z.x));return vec2(b.y-a.y,a.x-b.x)/2.0;}\n//arcsec(csec(c))arcsec(ccsc(c))looks almost good\n//arcsec(z)=-log((a+sqrt((a^2+b^2)^2-a^2+b^2+2abi)i-bi)/(a^2+b^2))i,inverse secant\nvec2 arcsec(vec2 z){vec2 u=vec2(z.x*z.x,z.y*z.y);float r=suv(u);return c2(logc(sub2(c4(vec4(z,sqrc(ciCo(u,z,r)).yx)))).yx)+vec2(0.,log(r));}//vec2 arcsec(vec2 z){ float p=z.x*z.x;float q=z.y*z.y;float r=p+q;vec2 a=sqrc(vec2(r*r-p+q,2.0*z.x*z.y));a=logc(vec2(z.x-a.y,a.x-z.y));return vec2(a.y,log(r)-a.x);}\n//arccsc(csec(c))arccsc(ccsc(c))looks good\n//arccsc(z)=-log((sqrt((a^2+b^2)^2-a^2+b^2+2abi)+b+ai)/(a^2+b^2))i,inverse cosecant\nvec2 arccsc(vec2 z){vec2 u=vec2(z.x*z.x,z.y*z.y);float r=suv(u);return c2(logc(z.yx+sqrc(ciCo(u,z,r))).yx)+vec2(0.,log(r));}//vec2 arccsc(vec2 z){ float p=z.x*z.x;float q=z.y*z.y;float r=p+q;vec2 a=sqrc(vec2(r*r-p+q,2.0*z.x*z.y));a=logc(vec2(a.x+z.y,a.y+z.x));return vec2(a.y,log(r)-a.x);}\n\n//arcsch(z)=log((sqrt((a^2+b^2)^2+a^2-b^2-2abi)+a-bi)/(a^2+b^2)),// inverse hyperbolic cosecant\nvec2 arcsch(vec2 z){vec2 u=z*z;float r=suv(u);return logc(c2(z)+sqrc(ciCo(u.yx,z,r)))-vec2(0,log(r));}//vec2 arcsch(vec2 z){ float p=z.x*z.x;float q=z.y*z.y;float r=p+q;vec2 a=sqrc(vec2(r*r+p-q,-2.0*z.x*z.y));a=logc(vec2(a.x+z.x,a.y-z.y));return vec2(a.x-log(r),a.y);}\n\n////inverse hyperbolics\n//arsinh looks messy,likely broken\nvec2 arsinh(vec2 z){return logc(z+sqrc(po2c(z)+vec2(1,0)));}//arsinh(z)=log(a+bi+sqrt(a^2-b^2+1+2abi)),inverse hyperbolic sine\n//arsinh looks almost okay,likely broken\nvec2 arcosh(vec2 z){return logc(z+mulc(sqrc(z.xyxy+vec4(1,0,-1,0))));}//arcosh(z)=log(a+bi+sqrt(a+1+bi)sqrt(a-1+bi)),inverse hyperbolic cosine\n//artanh(z)= log((1-a^2-b^2+2bi)/(1+a^2+b^2-2a))/2,inverse hyperbolic tangent\n//artanh(artanc(c))is uniform ,artanc(artanh(c))is white\nvec2 artanh(vec2 z){float r=1.-suv(z*z);z*=2.;return .5*logc(-vec2(r,z.y)/(r+z.x));}//vec2 artanh(vec2 z){float r=z.x*z.x+z.y*z.y;return logc(vec2(1.0-r,2.0*z.y)/(1.0+r-2.0*z.x))/2.0;}\n//cothc(arcoth(c))looks somehwat passable\n//arcoth(z)=log((a^2+b^2-1-2bi)/(a^2+b^2-2a+1))/2,inverse hyperbolic cotangent\nvec2 arcoth(vec2 z){;float r=z.x*z.x+z.y*z.y-1.;z*=-2.;return .5*logc(vec2(r,z.y)/(r+2.+z.x));}//vec2 arcoth(vec2 z){ float r=z.x*z.x+z.y*z.y;return logc(vec2(r-1.0,-2.0*z.y)/(r-2.0*z.x+1.0))/2.0;}\n\n//arsech(z)=log((sqrt(a^2-b^2-(a^2+b^2)^2-2abi)+a-bi)/(a^2+b^2)),inverse hyperbolic secant\nvec2 arsech(vec2 z){float r=suv(z*z);return logc(c2(z)+mulc(sqrc(vec4(-r,0,r,0)+c2(z).xyxy)))-vec2(log(r),0);}//ok-ollj\n\n\n\n\nvec2 func(float i,vec2 c){vec2 r\n ///;i=1.\n ;vec2 m=iMouse.xy/iResolution.xy\n //;float t=cos(iTime*2.)*.5+.5\n //;c=vec2(.1);if(mav(abs(sinh2c(c)-sinhc(c)))<.001)c=vec2(0.4)\n //;c=vec2(.1);if(mav(abs(ta2c(c)-tanc(c)))<.001)c=vec2(0.)\n //;if(i==1.)c=mix(sqrc(c),sqrc(c),1.)\n //;if(i==1.)c=mix(sinhc(c),sinh2c(c),t)\n //;if(i==1.)c=arsechO(sinh(c))\n ;if(i==1.)c=cosc((c))\n //;if(i==1.)c=mix(mulc(c,m),mulc(c,m),t)\n //;if(i==1.)c=mix(mulc(c,c),sinc(c),t)\n// ;if(i==1.)c=mix(mulc(c,c),po2c(c),t)\n\n ;else if(i==2.)c=sqrc(divc(logc(vec2(-c.y-6.,c.x)),logc(vec2(-c.y+2.,c.x))));\n else if(i==3.)c=expc(c);\n else if(i==4.)c=tanc(tanc(c));\n else if(i==5.)c=tanc(sinc(c));\n else if(i==6.)c=sqrc(vec2(1.+c.x,c.y))+sqrc(vec2(1.-c.x,-c.y));\n else if(i==7.)c=divc(tanc(po2c(c)),c);\n else if(i==8.)c=sinc(cosc(sinc(c)));\n else if(i==9.)c=recc(vec2(1,0)+expc(vec2(c.y,c.x)));\n else if(i==10.)c=expc(recc(sqrc(-c)));\n else if(i==11.)c=po2c(recc(c));\n else if(i==12.)c=expc(sinc(expc(cosc(c))));\n else if(i==13.)c=divc(sinc(c),c);\n else if(i==14.)c=po2c(c);\n else if(i==15.)c=divc(sinc(c),cosc(po2c(c)));\n else if(i==16.)c=recc(c+vec2(1,0))+recc(c-vec2(1,0));\n else if(i==17.)c=logc(c-recc(c));\n else if(i==18.)c=divc(sqrc(vec2(c.x+1.,c.y)),sqrc(vec2(c.x-1.,c.y)));\n else if(i==19.)c=recc(vec2(1,0)+mulc(c,po2c(po2c(c))));\n /**/\n ;return c;}\n\n//2d rotation by iTime\nvec2 animate(vec2 v){\n float s=sin(iTime),c=cos(iTime);return v*mat2(c,-s,s,c);}\n\n//color space\nvec3 hsv2rgb(in vec3 c){//iq's smooth hsv to rgb\n vec3 rgb=clamp(abs(mod(c.x*6.+vec3(0,4,2),6.)-3.)-1.,0.,1.);\n rgb=rgb*rgb*(3.0-2.0*rgb);return c.z*mix(vec3(1),rgb,c.y);}\n\n//for tiling grid,by aiekick https://www.shadertoy.com/view/4lj3Ww\nvec2 gridSize=vec2(5,4);\nvec3 getCell(vec2 s,vec2 h){vec2 c=floor(h*gridSize/s);\n return vec3(c.x,c.y,(gridSize.y-1.-c.y)*gridSize.x+c.x);}\nvec3 getSmallCells(vec2 s,vec2 h){\n vec3 c=getCell(s,h);vec2 g=s/gridSize;float r=g.x/g.y;\n vec2 u=pi*((2.*h-g)/g.y-2.*vec2(c.x*r,c.y));return vec3(c.z,u);}\n\nvoid mainImage(out vec4 O,vec2 In\n){vec2 e=iResolution.xy\n ;vec3 c=iMouse.z>0.\n  ?vec3(getCell(e,iMouse.xy).z,pi*(2.*In-e)/(e.y))//fullscreen cell \n  :getSmallCells(e,In)//tiled cells\n ;vec2 z=animate(func(c.x,c.yz))*2.\n ;float h=atan(z.y,z.x)/(2.*pi)\n ;float l=length(z)\n ;float s=abs(fract(l)-.5)-.25;s=step(0.,s)*s*4.;s=1.-s*s\n ;vec2  r=abs(fract(z)-.5)-.25;r=step(0.,r)*r*4.;r=1.-r*r*r*r\n ;float v=mix(1.,r.x*r.y,s*.5)\n ;O=vec4(hsv2rgb(vec3(h,s,v)),1.);}\n \n\n\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4tdcD4.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[485, 532, 550, 550, 571], [596, 596, 614, 614, 630], [631, 631, 649, 649, 665], [666, 666, 684, 684, 702], [702, 726, 743, 743, 771], [772, 772, 789, 789, 827], [828, 828, 845, 845, 865], [865, 886, 903, 903, 943], [944, 944, 962, 962, 984], [1046, 1361, 1385, 1385, 1395], [1396, 1396, 1420, 1420, 1438], [1439, 1439, 1463, 1463, 1487], [1488, 1488, 1511, 1511, 1529], [1529, 1560, 1585, 1585, 1609], [2373, 2412, 2431, 2431, 2468], [2469, 2469, 2488, 2488, 2525], [2527, 2527, 2545, 2545, 2577], [2577, 2644, 2677, 2677, 2714], [2714, 2766, 2784, 2784, 2807], [2808, 2939, 2968, 2968, 2991], [3076, 3192, 3217, 3217, 3229], [3229, 3229, 3254, 3254, 3266], [3266, 3297, 3322, 3322, 3348], [3348, 3405, 3437, 3437, 3463], [3463, 3521, 3539, 3539, 3563], [3563, 3579, 3604, 3604, 3668], [3668, 3810, 3828, 3828, 3872], [3873, 3873, 3891, 3891, 3947], [3947, 3998, 4016, 4016, 4065], [4065, 4128, 4146, 4146, 4178], [4178, 4216, 4234, 4234, 4270], [4270, 4288, 4313, 4313, 4343], [4343, 4405, 4431, 4431, 4472], [4472, 4651, 4684, 4684, 4716], [4716, 4789, 4807, 4807, 4832], [4832, 4884, 4909, 4909, 4939], [4939, 5001, 5034, 5034, 5066], [5067, 5092, 5117, 5117, 5147], [5147, 5189, 5222, 5222, 5254], [5254, 5284, 5302, 5302, 5355], [5355, 5438, 5456, 5456, 5521], [5521, 5662, 5680, 5680, 5727], [5727, 5939, 5957, 5957, 6039], [6040, 6040, 6058, 6058, 6106], [6107, 6332, 6350, 6350, 6452], [6453, 6453, 6471, 6471, 6501], [6501, 6549, 6567, 6567, 6597], [6639, 6710, 6729, 6729, 6776], [6776, 7068, 7087, 7087, 7110], [7110, 7214, 7233, 7233, 7263], [7263, 7308, 7327, 7327, 7357], [7357, 7404, 7423, 7423, 7445], [7445, 7483, 7502, 7502, 7524], [7565, 7626, 7646, 7646, 7706], [7706, 7896, 7916, 7916, 7974], [7974, 8164, 8182, 8182, 8204], [8204, 8274, 8292, 8292, 8314], [8387, 8609, 8629, 8629, 8720], [8720, 9009, 9029, 9029, 9089], [9089, 9343, 9363, 9363, 9483], [9483, 9776, 9796, 9796, 9900], [10067, 10163, 10183, 10183, 10265], [10433, 10492, 10512, 10512, 10552], [10552, 10660, 10680, 10680, 10730], [10730, 10938, 10958, 10958, 11022], [11022, 11244, 11264, 11264, 11339], [11443, 11534, 11554, 11554, 11644], [11644, 11658, 11684, 11684, 12978], [12980, 13003, 13024, 13024, 13083], [13085, 13099, 13123, 13147, 13270], [13272, 13364, 13392, 13392, 13478], [13479, 13479, 13513, 13513, 13635], [13637, 13637, 13673, 13673, 14095]], "test": "untested"}
{"id": "4tdcD7", "name": "Checker Coils", "author": "momoro", "description": "Tinkering", "tags": ["bookofshaders"], "likes": 4, "viewed": 414, "published": "Public API", "date": "1532908709", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float PI = 3.141592654;\n\nmat2 rotate(float angle) {\n    return mat2(cos(angle), -sin(angle),\n               \tsin(angle), cos(angle));\n}\n\n// Thanks FabriceNeyret2\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 st = (fragCoord - .5 * iResolution.xy) / iResolution.y;\n\n\n    float size =10.;\n    float f;\n\n    \n        st *= size;\n\n \n    st *= cos(iTime) / 2. + .5 + 1.;\n    \n   float t1 = sin(iTime) * ceil(10.*sin(length(st)) / 2. + .5);\n    \n    st = rotate(t1/5.) * st;\n    float p = sin(size*fract(atan(st.x, st.y)))/2. + .5;\n\n    \n    float l = length(st);\n    float t = sin(iTime);\n    \n    \n    l += smoothstep(.45, 0.5, p)*PI * t;\n    f = smoothstep(0.476, -0.096, sin(l)/2. + .5);\n        \n\n    fragColor = vec4(vec3(f),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4tdcD7.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[25, 25, 51, 51, 135], [137, 163, 220, 220, 754]], "test": "untested"}
{"id": "4tdcRH", "name": "Vec2d to scalar/spiral encoding", "author": "msomeone", "description": "experimenting with 2d vector (of known max mag) encoding into closest point(theta-param) on Archimedes spiral, stored in 8-bits. \nInterpolates OK when filter-sampled from texture.\n\n", "tags": ["packing"], "likes": 2, "viewed": 375, "published": "Public API", "date": "1531565244", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// MODE 0 - original 2d vector field\n// MODE 1 - spiral encoded vector field\n// MODE 2 - spiral encoded & quantized to 8 bit\n// MODE 3,4 - errors\n// MODE 5 - MODE0 VS MODE2\n#define MODE 5\n\n\n#define M_PI (3.14159)\n\n// better have more spiral turns and \n// scale your vector before encode/decode\nconst float MAX_VECTOR_MAGNITUDE = 1.;\n\n// spiral params\nconst int number_of_turns = 8;\nconst float n = float(number_of_turns);\n\nconst float a_initial_radius = .0001; // assuming that vectors mag < 0.1 mean zero vector.\nconst float a_final_radius = MAX_VECTOR_MAGNITUDE;\nconst float dR = (a_final_radius - a_initial_radius);\n\nconst float start_angle = 0.;\nconst float final_angle = 2. * M_PI * n;\n\nconst float b_growth_rate = dR / (final_angle - start_angle);\n\nfloat field(vec2 uv) {\n    vec2 c0 = vec2(0.7);  \n    vec2 c1 = vec2(0.3);\n    return min(\n        \t(length(uv - c0) * length(uv - c1)) * \n        \t\tMAX_VECTOR_MAGNITUDE,\n        \t\tMAX_VECTOR_MAGNITUDE\n    \t\t);\n}\n\nvec2 field_grad(vec2 uv) {\n    float c = field(uv);\n    vec2 dxy = 1./iResolution.xy;\n    float x = field(uv + vec2(dxy.x, 0.));\n    float y = field(uv + vec2(0., dxy.y));\n    return (vec2(x,y) - c ) / dxy;\n}\n\n\nfloat encode_into_archimedes_spiral_parameter(vec2 v)\n{    \n    float vl = length(v);\n    vec2 vn = v / vl;\n    float theta = atan(vn.y,vn.x) + M_PI; theta = max(0., theta);\n    \n    float f = a_initial_radius + b_growth_rate*theta;\n    float K = b_growth_rate*2.*M_PI;\n    \n    float th = theta;\n    for (int i = 0; i < number_of_turns; i++ ) { // T_T\n        f += K;\n        th += 2.*M_PI;\n    }\n        \n    return max(theta,th - 2.*M_PI) - M_PI;\n}\n\nvec2 decode_from_archimedes_spiral_parameter(float theta)\n{\n   \tvec2 v; v.x = cos(theta); v.y = sin(theta);\n    return (theta*b_growth_rate + a_initial_radius) * v;    \n}\n\nfloat quantize_unit_input_to_8bit(float x) {\n    return floor(x * 255.);\n}\n\nfloat _8bit_unit_input_to_float(float x) {\n    return fract(x / 255.);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 vector_to_encode = -field_grad(uv) * MAX_VECTOR_MAGNITUDE;\n    float encoded_vector = encode_into_archimedes_spiral_parameter(vector_to_encode);\n    vec2 decoded_vector = decode_from_archimedes_spiral_parameter(encoded_vector);\n    \n    float quantized_spiral_parameter_8bit = \n        \tquantize_unit_input_to_8bit(encoded_vector/final_angle);\n    \n    float encoded_vector_unpacked_from_8bit = \n        \tfinal_angle * _8bit_unit_input_to_float(quantized_spiral_parameter_8bit);\n    \n    vec2 decoded_vector_from_8bit = decode_from_archimedes_spiral_parameter(encoded_vector_unpacked_from_8bit);\n    \n    vec3 col = vec3(0.);\n        \n    #if MODE == 0\n    col.xy = (vector_to_encode * .5 + .5) / MAX_VECTOR_MAGNITUDE;\n    #elif MODE == 1\n    col.xy = (decoded_vector * .5 + .5) / MAX_VECTOR_MAGNITUDE;\n    #elif MODE == 2\n    col.xy = (decoded_vector_from_8bit * .5 + .5) / MAX_VECTOR_MAGNITUDE;\n    #elif MODE == 3\n    vec2 e1 = abs(vector_to_encode - decoded_vector);\n    col.xyz = vec3(sqrt(dot(e1,e1))/length(vector_to_encode)); // error vis\n    #elif MODE == 4\n    vec2 e2 = abs(vector_to_encode - decoded_vector_from_8bit);\n    col.xyz = vec3(sqrt(dot(e2,e2))/length(vector_to_encode)); // error vis\n    #elif MODE == 5\n    vec2 col_m0 = (vector_to_encode * .5 + .5) / MAX_VECTOR_MAGNITUDE;\n    vec2 col_m1  = (decoded_vector_from_8bit * .5 + .5) / MAX_VECTOR_MAGNITUDE;\n    \n    float ta = -iTime * 0.1;\n    vec2 animv1 = vec2(cos(ta), sin(ta));\n    vec2 line_normal = vec2(-animv1.y,animv1.x);\n    float line_d = dot(line_normal, vec2(0.5));\n    \n    if ( dot(uv,line_normal) < line_d ) {\n        col.xy = col_m0;\n    } else {\n        col.xy = col_m1;\n    }\n    #endif\n    \n\tfragColor = vec4(pow(col, vec3(1./2.4)),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4tdcRH.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[461, 755, 777, 777, 967], [969, 969, 995, 995, 1177], [1180, 1180, 1235, 1235, 1631], [1633, 1633, 1692, 1692, 1803], [1805, 1805, 1849, 1849, 1879], [1881, 1881, 1923, 1923, 1953], [1955, 1955, 2012, 2012, 3793]], "test": "untested"}
{"id": "4tdcW8", "name": "Plenty O'Dux", "author": "dr2", "description": "Lots more ducks...  (mouseable)", "tags": ["wheel", "icosahedron", "gear", "symmetry", "polyhedron", "duck"], "likes": 13, "viewed": 488, "published": "Public API", "date": "1532425995", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// \"Plenty O'Dux\" by dr2 - 2018\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\n/*\n  Lots more ducks than in my earlier \"Dodecahedral Duckohedron\" (mouseable).\n  Starting from Shane's \"Polyhedral Gears\" -- see his comments for background, including\n  work by DjinnKahn and Knighty, as well as Goldberg polyhedra.\n*/\n\n#define AA    0\n\nfloat PrCylDf (vec3 p, float r, float h);\nfloat PrRoundBox2Df (vec2 p, vec2 b, float r);\nfloat PrEllipsDf (vec3 p, vec3 r);\nfloat PrEllCylDf (vec3 p, vec2 r, float h);\nfloat SmoothMin (float a, float b, float r);\nfloat SmoothBump (float lo, float hi, float w, float x);\nvec2 Rot2D (vec2 q, float a);\nvec2 Rot2Cs (vec2 q, vec2 cs);\nmat3 OrthMat (vec3 n);\n\nmat3 icMat[4], hxMat[3];\nvec3 vf[3], qWhl, ltDir;\nfloat dstFar, tCur, dSpoke, dAxl, dTooth, dWhl, dDuk;\nint idObj;\nconst float pi = 3.14159, phi = 1.618034;\n\nvec3 IcosSymP (vec3 p)\n{\n  vec3 s;\n  s = sign (p);\n  for (int k = 0; k < 3; k ++) {\n    p = icMat[k] * abs (p);\n    s *= sign (p);\n  }\n  return abs (p) * vec3 (s.x * s.y * s.z, 1, 1);\n}\n\nfloat DukDist (vec3 p, float szFac, float a)\n{\n  vec3 q;\n  vec2 r, cs;\n  float d, h, s;\n  d = dstFar / szFac;\n  p /= szFac;\n  p.xz = Rot2D (p.xz, a);\n  q = p;\n  r = vec2 (0.04, 0.06 + 0.01 * clamp (q.z, -0.4, 0.4));\n  h = 0.1;\n  s = (length (q.xz / r) - 1.) * min (r.x, r.y);\n  d = min (d, min (max (s, abs (q.y) - h), length (vec2 (s, q.y)) - h));\n  q = p;  q.x = abs (q.x);  q -= vec3 (0.1, 0.06, 0.12);\n  cs = vec2 (cos (0.3), sin (0.3));\n  q.yz = Rot2Cs (q.yz, cs);\n  cs.y = - cs.y;\n  q.xy = Rot2Cs (q.xy, cs);\n  q.xz = Rot2Cs (q.xz, cs);\n  q = q.yxz;\n  r = vec2 (0.06, 0.1 + 0.016 * clamp (q.z, -0.4, 0.4));\n  h = 0.014;\n  s = (length (q.xz / r) - 1.) * min (r.x, r.y);\n  d = min (d, SmoothMin (min (max (s, abs (q.y) - h), length (vec2 (s, q.y)) - h), d, 0.01));\n  q = p;  q.yz -= vec2 (0.15, -0.08);\n  d = min (d, SmoothMin (PrEllipsDf (q, vec3 (0.08, 0.07, 0.1)), d, 0.02));\n  q = p;  q.yz -= vec2 (0.14, -0.19);\n  r = vec2 (0.03, 0.008);\n  h = 0.02;\n  d = min (d, max (PrEllCylDf (q, r, h), - PrEllCylDf (q - vec3 (0., 0., h), r - 0.004, 2. * h)));\n  return d * szFac;\n}\n\nfloat ToothDist (vec3 p, float nt, float a, float rad, float thk)\n{\n  vec3 q;\n  q = p;\n  q.xy = Rot2D (q.xy, (floor (a * nt) + 0.5) * 2. * pi / nt);\n  q.x += rad;\n  thk *= 0.7 + 2. * q.x;\n  q = abs (q);\n  return max (0.5 * (max (q.x - 0.05, q.y - 0.02) + length (q.xy * vec2 (0.71, 1.)) - 0.025), q.z - thk);\n}\n\nvoid PentDist (vec3 p, float rad, float thk)\n{\n  vec3 q;\n  float a, tRad;\n  tRad = (0.9 + p.z) * rad;\n  p.xy = Rot2D (p.xy, - mod (tCur / 1.5, 2. * pi / 5.) - pi);\n  a = atan (p.y, abs (p.x)) / (2. * pi);\n  q = p;\n  q.xy = Rot2D (q.xy, (floor (a * 5.) + 0.5) * 2. * pi / 5.);\n  dAxl = max (max (abs (q.x), abs (q.y)) - 0.15 * rad, abs (q.z - 0.5 * thk) - 0.5 * thk);\n  q += vec3 (0.5 * rad, 0., -0.5 * thk);\n  dSpoke = PrCylDf (q.zyx, 0.1 * rad, 0.4 * rad);\n  q += vec3 (0.3 * rad, 0., -0.6 * thk);\n  dDuk = DukDist (q.yzx, 0.8 * rad, tCur / 1.5);\n  dWhl = PrRoundBox2Df (vec2 (length (p.xy) - 0.8 * tRad, p.z), vec2 (0.2 * tRad, thk), 0.05 * thk);\n  qWhl = q;\n  dTooth = ToothDist (p, 15., a, tRad, thk);\n}\n\nvoid HexLDIst (vec3 p, float rad, float thk)\n{\n  vec3 q;\n  float a, tRad;\n  p.z = - p.z;\n  tRad = (0.9 + p.z) * rad;\n  p.xy = Rot2D (p.xy, - mod (tCur / 1.8, pi / 3.) - pi / 3.);\n  a = atan (p.y, abs (p.x)) / (2. * pi);\n  q = p;\n  q.xy = Rot2D (q.xy, (floor (a * 6.) + 0.5) * 2. * pi / 6.);\n  dAxl = max (max (abs (q.x), abs (q.y)) - 0.15 * rad, abs (q.z - 0.5 * thk) - 0.5 * thk);\n  q += vec3 (0.5 * rad, 0., -0.5 * thk);\n  dSpoke = PrCylDf (q.zyx, 0.1 * rad, 0.4 * rad);\n  q += vec3 (0.3 * rad, 0., -0.6 * thk);\n  dDuk = DukDist (q.yzx, 0.8 * rad, - 2. * tCur / 1.8);\n  dWhl = PrRoundBox2Df (vec2 (length (p.xy) - 0.8 * tRad, p.z), vec2 (0.2 * tRad, thk), 0.05 * thk);\n  qWhl = q;\n  dTooth = ToothDist (p, 18., a, tRad, thk);\n}\n\nvoid HexSDist (vec3 p, float rad, float thk)\n{\n  vec3 q;\n  float a, tRad, t;\n  tRad = (0.9 + p.z) * rad;\n  t = sign (p.x) * tCur / 1.2;\n  p.x = abs (p.x);\n  q = p;\n  q.xy = Rot2D (q.xy, - mod (t, pi / 3.) - 2. * pi / 3.);\n  q.xy = Rot2D (q.xy, (floor (atan (q.y, abs (q.x)) / (2. * pi) * 6.) + 0.5) * pi / 3.);\n  dAxl = max (max (abs (q.x), abs (q.y)) - 0.15 * rad, abs (q.z - 0.5 * thk) - 0.5 * thk);\n  q += vec3 (0.5 * rad, 0., -0.5 * thk);\n  dSpoke = PrCylDf (q.zyx, 0.1 * rad, 0.4 * rad);\n  q += vec3 (0.3 * rad, 0., -0.6 * thk);\n  dDuk = DukDist (q.yzx, 0.8 * rad, 2. * t);\n  dWhl = PrRoundBox2Df (vec2 (length (p.xy) - 0.8 * tRad, p.z), vec2 (0.2 * tRad, thk), 0.05 * thk);\n  qWhl = q;\n  q = p;\n  q.xy = Rot2D (q.xy, - mod (t + pi / 12., pi / 6.) - 5. * pi / 6.);\n  dTooth = ToothDist (q, 12., atan (q.y, abs (q.x)) / (2. * pi), tRad, thk);\n}\n\nfloat ObjDf (vec3 p)\n{\n  vec3 hxv, qqw1, qqw2;\n  float dMin, d, thk;\n  dMin = dstFar;\n  d = length (p) - 1.2;\n  if (d < 0.02) {\n    thk = 0.1;\n    hxv = IcosSymP (p);\n    for (int k = 0; k < 4; k ++) {\n      if (k == 0) PentDist (icMat[3] * hxv - vec3 (0., 0., 1.), 0.185, thk);\n      else if (k == 1) HexLDIst (hxMat[0] * (hxv - vf[2]), 0.25, thk);\n      else HexSDist (hxMat[k - 1] * (hxv - vf[k - 2]), 0.16, thk);\n      if (dSpoke < dMin) { dMin = dSpoke;  idObj = 1; }\n      if (dWhl < dMin) {\n        dMin = dWhl;\n        if (k < 2) { idObj = 2;  qqw1 = qWhl; }\n        else { idObj = 3;  qqw2 = qWhl; }\n      }\n      if (dTooth < dMin) { dMin = dTooth;  idObj = 4; }\n      if (dAxl < dMin) { dMin = dAxl;  idObj = 5; }\n      if (dDuk < dMin) { dMin = dDuk;  idObj = 6; }\n    }\n    if (idObj == 2) qWhl = qqw1;\n    if (idObj == 3) qWhl = qqw2;\n    dMin *= 0.9;\n  } else dMin = d;\n  return dMin;\n}\n\nfloat ObjRay (vec3 ro, vec3 rd)\n{\n  float dHit, d;\n  dHit = 0.;\n  for (int j = 0; j < 100; j ++) {\n    d = ObjDf (ro + rd * dHit);\n    if (d < 0.0002 || dHit > dstFar) break;\n    dHit += d;\n  }\n  return dHit;\n}\n\nvec3 ObjNf (vec3 p)\n{\n  vec4 v;\n  vec2 e = vec2 (0.0001, -0.0001);\n  v = vec4 (ObjDf (p + e.xxx), ObjDf (p + e.xyy), ObjDf (p + e.yxy), ObjDf (p + e.yyx));\n  return normalize (vec3 (v.x - v.y - v.z - v.w) + 2. * v.yzw);\n}\n\nfloat ObjAO (vec3 ro, vec3 rd)\n{\n  float ao, d;\n  ao = 0.;\n  for (float j = 1.; j <= 4.; j ++) {\n    d = 0.02 * j;\n    ao += max (0., d - 5. * ObjDf (ro + d * rd));\n  }\n  return 0.5 + 0.5 * clamp (1. - ao, 0., 1.);\n}\n\nvoid InitBasis ()\n{\n  vec3 v0, v1, v2, u;\n  vec2 e = vec2 (1., -1.);\n  float c;\n  v0 = vec3 (0, 1., phi - 1.);\n  v1 = v0.zxy;\n  v2 = v1 * e.yxx;\n  vf[0] = (2. * v0 + v2) / 3.;\n  vf[1] = (2. * v0 + v1) / 3.;\n  vf[2] = (v0 + vec3 (0., 0., 2.)) / 3.;\n  hxMat[0] = OrthMat (cross (vf[2] - v0, vf[2] - v1));\n  hxMat[1] = OrthMat (vf[0]);\n  hxMat[2] = OrthMat (vf[1]);\n  c = 1. / sqrt (phi + 2.);\n  vf[0] *= 1.1547 * c * phi;\n  vf[1] *= 1.1547 * c * phi;\n  vf[2] *= 1.2425 * c * phi;\n  u = 0.5 * vec3 (1., phi - 1., phi);\n  icMat[0] = mat3 (u.xzy * e.xyx, u.zyx * e.xxy, u.yxz);\n  icMat[1] = mat3 (u.zyx * e.xxy, u.yxz, u.xzy * e.xyx);\n  icMat[2] = mat3 (u.yxz * e.yyx, u.xzy * e.xyy, u.zyx);\n  icMat[3] = 0.5 * mat3 (sqrt (3. - phi), - phi, 0., - c * phi, 1. - phi, 2. * c * phi,\n     c * sqrt (2. + 3. * phi), 1., 2. * c);\n}\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  vec3 col, vn;\n  float dstObj;\n  InitBasis ();\n  dstObj = ObjRay (ro, rd);\n  if (dstObj < dstFar) {\n    ro += dstObj * rd;\n    vn = ObjNf (ro);\n    if (idObj == 1) col = vec3 (0.6, 0.6, 0.65);\n    else if (idObj == 2) col = vec3 (0.7, 0.7, 0.3);\n    else if (idObj == 3) col = vec3 (0.7, 0.7, 0.3);\n    else if (idObj == 4) col = vec3 (0.7, 0.7, 0.3);\n    else if (idObj == 5) col = vec3 (0., 0.4, 0.1);\n    else if (idObj == 6) col = vec3 (1., 0.2, 0.1);\n    if (idObj == 2 || idObj == 3) col *= 0.6 + 0.4 * step (0.003, abs (qWhl.y));\n    col = col * (0.2 + 0.8 * max (dot (ltDir, vn), 0.)) +\n       0.3 * pow (max (dot (reflect (ltDir, vn), rd), 0.), 32.);\n    col *= ObjAO (ro, vn) * (1. - smoothstep (3., 5., dstObj));\n  } else col = vec3 (0.1);\n  return col;\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  mat3 vuMat;\n  vec4 mPtr;\n  vec3 ro, rd, col;\n  vec2 canvas, uv, ori, ca, sa;\n  float el, az, zmFac;\n  canvas = iResolution.xy;\n  uv = 2. * fragCoord.xy / canvas - 1.;\n  uv.x *= canvas.x / canvas.y;\n  tCur = iTime;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / canvas - 0.5;\n  az = 0.;\n  el = 0.;\n  zmFac = 2.2;\n  if (mPtr.z > 0.) {\n    az += 2. * pi * mPtr.x;\n    el += pi * mPtr.y;\n    zmFac += 3. * SmoothBump (0.25 * pi, 0.75 * pi, 0.2 * pi, mod (az, pi));\n  } else {\n    az += 0.05 * pi * tCur;\n    el -= 0.2 * pi * sin (0.06 * pi * tCur);\n  }\n  ori = vec2 (el, az);\n  ca = cos (ori);\n  sa = sin (ori);\n  vuMat = mat3 (ca.y, 0., - sa.y, 0., 1., 0., sa.y, 0., ca.y) *\n          mat3 (1., 0., 0., 0., ca.x, - sa.x, 0., sa.x, ca.x);\n  ro = vuMat * vec3 (0., 0., -3.);\n  rd = vuMat * normalize (vec3 (uv, zmFac));\n  ltDir = vuMat * normalize (vec3 (1., 1., -1));\n  dstFar = 10.;\n#if ! AA\n  const float naa = 1.;\n#else\n  const float naa = 4.;\n#endif  \n  col = vec3 (0.);\n  for (float a = 0.; a < naa; a ++) {\n    rd = vuMat * normalize (vec3 (uv + step (1.5, naa) * Rot2D (vec2 (0.71 / canvas.y, 0.),\n       0.5 * pi * (a + 0.5)), zmFac));\n    col += (1. / naa) * ShowScene (ro, rd);\n  }\n  fragColor = vec4 (clamp (col, 0., 1.), 1.);\n}\n\nfloat PrCylDf (vec3 p, float r, float h)\n{\n  return max (length (p.xy) - r, abs (p.z) - h);\n}\n\nfloat PrRoundBox2Df (vec2 p, vec2 b, float r)\n{\n  return length (max (abs (p) - b, 0.)) - r;\n}\n\nfloat PrEllipsDf (vec3 p, vec3 r)\n{\n  return (length (p / r) - 1.) * min (r.x, min (r.y, r.z));\n}\n\nfloat PrEllCylDf (vec3 p, vec2 r, float h)\n{\n  return max ((length (p.xy / r) - 1.) * min (r.x, r.y), abs (p.z) - h);\n}\n\nfloat SmoothMin (float a, float b, float r)\n{\n  float h;\n  h = clamp (0.5 + 0.5 * (b - a) / r, 0., 1.);\n  return mix (b, a, h) - r * h * (1. - h);\n}\n\nfloat SmoothBump (float lo, float hi, float w, float x)\n{\n  return (1. - smoothstep (hi - w, hi + w, x)) * smoothstep (lo - w, lo + w, x);\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  vec2 cs;\n  cs = sin (a + vec2 (0.5 * pi, 0.));\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nvec2 Rot2Cs (vec2 q, vec2 cs)\n{\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nmat3 OrthMat (vec3 n)\n{\n  mat3 mm;\n  float a;\n  n = normalize (n);\n  if (n.z > -1.) {\n    a = 1. / (1. + n.z);\n    mm = mat3 (1. - n.x * n.x * a, - n.x * n.y * a, n.x,\n       - n.x * n.y * a, 1. - n.y * n.y * a, n.y, - n.x, - n.y, n.z);\n  } else mm = mat3 (1., 0., 0., 0., 1., 0., 0., 0., -1.);\n  return mm;\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4tdcW8.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[120, 887, 911, 911, 1072], [1074, 1074, 1120, 1120, 2153], [2155, 2155, 2222, 2222, 2465], [2467, 2467, 2513, 2513, 3174], [3176, 3176, 3222, 3222, 3905], [3907, 3907, 3953, 3953, 4755], [4757, 4757, 4779, 4779, 5658], [5660, 5660, 5693, 5693, 5870], [5872, 5872, 5893, 5893, 6093], [6095, 6095, 6127, 6127, 6311], [6313, 6313, 6332, 6332, 7133], [7134, 7134, 7169, 7169, 7937], [7939, 7939, 7995, 7995, 9225], [9227, 9227, 9269, 9269, 9320], [9322, 9322, 9369, 9369, 9416], [9418, 9418, 9453, 9453, 9515], [9517, 9517, 9561, 9561, 9636], [9638, 9638, 9683, 9683, 9786], [9788, 9788, 9845, 9845, 9928], [9930, 9930, 9960, 9960, 10073], [10075, 10075, 10106, 10106, 10170], [10172, 10172, 10195, 10195, 10481]], "test": "untested"}
{"id": "4tdczN", "name": "Colorful Braids", "author": "bitman", "description": "Trying a way to render braids. Allows for some neat-looking distortions.", "tags": ["color"], "likes": 6, "viewed": 411, "published": "Public API", "date": "1531844829", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const float pi = 3.1415926535;\nconst float tau = 2.*pi;\nconst float halfpi = pi/2.;\nconst float pi23 = pi*2./3.;\n\nvec3 hue(float theta){\n    return clamp(0.5+sin(vec3(theta+pi23, theta, theta-pi23)), 0., 1.);\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float pixel = 6./min(iResolution.x, iResolution.y);\n    vec2 uv = pixel * (fragCoord - 0.5*iResolution.xy)-vec2(0.,1.);\n    vec2 pol = vec2(length(uv), atan(uv.x*9., uv.y));\n    vec3 col = vec3(0.);\n    float aa = pixel;\n    float t = iTime*tau/3.;\n    float pcos = cos(pol.y);\n    float w = 0.01/(1.1+pcos);\n    float s = 0.01/(1.+pcos);\n    float bc = 40.;\n    float th = pol.y*bc;\n    vec3 bsin = sin(vec3(th, th+pi23, th-pi23)-t);\n    vec3 sins = 3.4/(2.+pcos)+bsin/6.;\n    vec3 coss = 12.-bsin*bsin*2.; // -sin(x)*sin(x)*2. == -1. + cos(2.*x)\n    vec3 dists = vec3(\n        distance(pol, vec2(sins.x, pol.y)),\n        distance(pol, vec2(sins.y, pol.y)),\n        distance(pol, vec2(sins.z, pol.y))\n    );\n    vec3 braid = smoothstep(w*coss+aa, w*coss-aa, dists)*smoothstep(mix(w,s,smoothstep(-2.5, -1.5, uv.y))*coss-aa, s*coss+aa, dists).yzx;\n    vec3 c = hue((pol.y-t/bc)/3.);\n    col += mat3(c, c.gbr, c.brg)*braid;\n    if (all(equal(col, col.brg))) // mostly gets rid of an artifact at pol.y == pi\n        col = vec3(0.);\n\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4tdczN.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[114, 114, 136, 136, 210], [211, 211, 268, 268, 1335]], "test": "untested"}
{"id": "4tdyD8", "name": "Tien's first shader", "author": "Ashitaka", "description": "time varying sin function", "tags": ["sinfunction"], "likes": 0, "viewed": 85, "published": "Public", "date": "1532436645", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Plot a line on Y using a value between 0.0-1.0\nfloat plot(vec2 st, float pct){\n  return  smoothstep( pct-0.02, pct, st.y) - smoothstep( pct, pct+0.02, st.y);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{    \n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 st = fragCoord/iResolution.xy;\n    \n    float y = 0.2*sin(st.x*iTime*100.0)+0.5;\n    \n    vec3 col = vec3(y);\n    \n    // Plot a line\n    float pct = plot(st, y);\n    col = pct*vec3(0.0,1.0,0.0);\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4tdyD8.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 50, 81, 81, 162], [164, 164, 221, 275, 538]], "test": "untested"}
{"id": "4ttcDn", "name": "QBezier + inv-K body", "author": "FabriceNeyret2", "description": "Body members: joints  by  inverse kinematics\n+ quadratic Bezier ( cleanup of  [url]https://shadertoy.com/view/XdB3Ww[/url] )", "tags": ["quadraticbezier", "inversekinematics"], "likes": 1, "viewed": 377, "published": "Public API", "date": "1532256143", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// QBezier from https://shadertoy.com/view/XtdyDn\n//         cleanup of https://shadertoy.com/view/XdB3Ww\n\n// -----------------------------------------------------------------\n//Find roots using Cardano's method. http://en.wikipedia.org/wiki/Cubic_function#Cardano.27s_method\nvec2 solveCubic2(vec3 a)\n{\n\tfloat p  = a.y - a.x*a.x/3.,\n\t      p3 = p*p*p,\n\t      q  = a.x* ( 2.*a.x*a.x - 9.*a.y ) /27. + a.z,\n\t      d  = q*q + 4.*p3/27.;\n    \n\tif(d>0.) {\n\t\tvec2 x = ( vec2(1,-1)*sqrt(d) -q ) *.5;\n        x = sign(x) * pow( abs(x) , vec2(1./3.) );\n  \t\treturn vec2( x.x+x.y -a.x/3. );\n  \t}\n    \n \tfloat v = acos( -sqrt(-27./p3)*q*.5 ) / 3.,\n \t      m = cos(v),\n \t      n = sin(v)*sqrt(3.);\n\n\treturn vec2(m+m,-n-m) * sqrt(-p/3.) - a.x/3.;\n}\n\n// How to solve the equation below can be seen on this image.\n// http://www.perbloksgaard.dk/research/DistanceToQuadraticBezier.jpg\n#define dd(a) dot(a,a)\n\nfloat dQBezier(vec2 p, vec2 a, vec2 b, vec2 c)\n{\n\tb = mix( b+vec2(1e-4), b, abs(sign(b*2.-a-c)) );\n\tvec2 A = b-a,\n\t     B = c-b-A,\n\t     C = p-a,\n\t     D = A*2.,\n\tP = solveCubic2( vec3(-3.*dot(A,B), dot(C,B)-2.*dd(A), dot(C,A))/-dd(B) );\n    P = clamp( P,0.,1.); // curve parameterization\n\n\treturn sqrt( min( dd( (D+B*P.x)*P.x -C ),\n                      dd( (D+B*P.y)*P.y -C )));\n}\n\n// ---------------------------------------------------------------\n\n\n#define knee(p0,p2,L) ( l = p2-p0,                             \\\n                        h = sqrt(max(0.,L*L-dot(l,l)))/2.,     \\\n                        (p0+p2)/2. +  h * normalize( vec2(-l.y,l.x) ) )\nvoid mainImage( out vec4 O, vec2 u )\n{\n    float t = iTime, h;\n    vec2 R =   iResolution.xy,\n         U = ( u+u - R ) / R.y;\n    \n\tvec2 p0 = vec2(0,.1), l,                            // body end\n\t     p2 = p0 + vec2(0,.4);                          // distant end\n\n\tfloat d = length(p0+vec2(0,.75)-U)/2.;              // head\n    d = min( d, dQBezier(U,p0,(p0+p2)/2.,p2) / 1.2 );   // body\n    \n    p0.x += .125; p0.y -= .1;\n    p2 = p0 + vec2(cos(t*1.3)*.4, -.5 +sin(t*.3)*.48 ); \n    d = min( d, dQBezier(U,p0,knee(p0,p2,1.),p2) );     // right leg\n\n    t += .5;\n    p0.x -= .25;\n    p2 = p0 + vec2(cos(t*1.3)*.4, -.5 +sin(t*.3)*.48 ),\n    d = min( d, dQBezier(U,p0,knee(p0,p2,1.),p2) );     // left leg\n    \n    t += .5; p0.y += .6;\n    p2 = p0 + vec2(-.4+cos(t*1.3)*.38, sin(t*.3)*.4 );\n    d = min( d, dQBezier(U,p0,knee(p0,p2,1.),p2) );     // left hand\n  \n    t += .5; p0.x += .25;\n    p2 = p0 + vec2(.4+cos(t*1.3)*.38, sin(t*.3)*.4 );\n    d = min( d, dQBezier(U,p0,knee(p0,p2,1.),p2) );     // right hand\n  \n\t//O = vec4(smoothstep(5./R.y,0., d-.1 ) );\n    d/=.1; O = vec4(1.-d*d);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4ttcDn.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[107, 276, 302, 302, 734], [736, 892, 940, 940, 1274], [1276, 1547, 1585, 1585, 2637]], "test": "untested"}
{"id": "4ttyRH", "name": "Binary Zone Plate Aliasing", "author": "Xerophyte", "description": "Zooming in and out on a binary zone plate (a concentric square wave of increasing frequency). Move the center point by click and drag.\n\nIntended to be a simple demo showing aliasing.", "tags": ["aliasing"], "likes": 0, "viewed": 64, "published": "Public", "date": "1531541381", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/////////////\n// Controls\n\n// Maximum zoom out.\nconst float MAX_SCALE = 100.0;\n\n// Maximum zoom in.\nconst float MIN_SCALE = 5.0;\n\n// Speed of the animation.\nconst float SPEED = 1.0;\n\n\n///////////////////\n// Implementation\n\n// A binary zone plate function\nfloat zonePlate(vec2 p) {\n    // Doesn't have the same period as the traditional Fresnel, since I'm ignoring\n    // the sine. This is just a scale difference and doesn't impact the overall shape.\n    float psq = dot(p, p);\n    return floor(mod(psq, 2.0));\n}\n\n\n// Scale the input by a somewhat arbitrary time-varying sine function that oscillates\n// from MIN_SCALE to MAX_SCALE.\nvec2 scaleByTime(vec2 p) {    \n    const float AMP = MAX_SCALE - MIN_SCALE;    \n    return AMP * (0.5 * -cos(SPEED * iTime / 10.0) + 0.5) * p + MIN_SCALE  * p;\n}\n\n\n// Compute a normalized pixel position relative to the last mouse event.\nvec2 mouseRelativePosition(vec2 pos) {\n    float minRes = min(iResolution.x, iResolution.y);\n    return (pos - iMouse.xy) / minRes;    \n}\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    // Get the normalized image space position relative to the mouse\n    vec2 pos = mouseRelativePosition(fragCoord);\n    \n    // Scale the with something time-varying\n    pos = scaleByTime(pos);    \n\n    // Compute the black/white binary zone plate at the scaled position\n    vec3 col = vec3(zonePlate(pos));    \n\n    // Output to screen\n    fragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4ttyRH.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[223, 255, 280, 450, 512], [515, 633, 659, 659, 794], [797, 870, 908, 908, 1007], [1010, 1010, 1065, 1134, 1438]], "test": "untested"}
{"id": "ldKfDK", "name": "Gameboy SDF", "author": "Daedelus", "description": "I made a quick and dirty game boy SDF because I couldn't find one :)\n\nI know it's a bit incomplete, mostly no back / sides, but it's something!\nAlso missing: Headphones & off/on engravings; Ribs on the D-pad; D-pad arrows embossing", "tags": ["raymarching", "game", "sdf", "gameboy", "distance", "field", "signed", "boy"], "likes": 14, "viewed": 217, "published": "Public", "date": "1530631690", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/**\nGameboy SDF for raymarching, hopefully not too broken.\n\nAnyone please feel free to use it for anything!\nNotice I'm using parts of http://mercury.sexy/hg_sdf/ library + my own minified versions and other inventions.\n\nUsed this blueprint for positioning:\nhttps://www.the-blueprints.com/modules/vectordrawings/preview-wm/nintendo_gameboy_classic.jpg\nAlso used a wikipedia graphic for colors and official specs for body and screen dimensions.\n\nI am aware there is a lot of code, I went for readable / tweakable dimension constants.\nIf there are serious performance optimizations please comment and I'd love to fix it for future reuse!\n**/\n/* Language extensions */\n#define sat(x) clamp(x, 0.0, 1.0)\n\nfloat vmin(vec2 v){return min(v.x, v.y);}\nfloat vmin(vec3 v){return min(v.x, max(v.y, v.z));}\nfloat vmax(vec2 v){return max(v.x, v.y);}\nfloat vmax(vec3 v){return max(v.x, max(v.y, v.z));}\n\n/* Spatial modifiers*/\nvoid pR(inout vec2 p, float a){p=cos(a)*p+sin(a)*vec2(p.y,-p.x);}\n\n// Modulo over a single axis, but limit the maximum number of steps, stopping tiling at the given start (s) and end (e) distance. Notice they should be mutliples of the size (z).\nfloat pModInterval(inout float p,float z,float s,float e){float c=floor(p/z+.5);p=(fract(p/z+.5)-.5)*z;if(c>e){p+=z*(c-e);return e;}if(c<s){p+=z*(c-s);return s;}return c;}\n\n/* SDF primitives(many from http://mercury.sexy/hg_sdf/)*/\n// Sphere\nfloat fSphere(vec3 p,float r){return length(p)-r;}\n\n// Infinite box\nfloat fBox(vec2 p,vec2 s){return vmax(abs(p)-s);}\n\n// Box\nfloat fBox(vec3 p,vec3 s){return vmax(abs(p)-s);}\n\n// Cylinder with rounded caps\nfloat fCapsule(vec3 p,float r,float h){p.y=max(0.,abs(p.y)-h);return length(p)-r;}\n\n// first object gets a capenter-style groove cut out\nfloat fOpGroove(float a, float b, float ra, float rb) {\n\treturn max(a, min(a + ra, rb - abs(b)));\n}\n\n// Distance to line segment between <a> and <b>, used for fCapsule() version 2below\nfloat fLineSegment(vec2 p, vec2 a, vec2 b) {\n\tvec2 ab = b - a;\n\tfloat t = sat(dot(p - a, ab) / dot(ab, ab));\n\treturn length((ab * t + a) - p);\n}\n\n// Capsule version 2: between two end points <a> and <b> with radius r\nfloat fCapsule(vec2 p, vec2 a, vec2 b, float r) {\n\treturn fLineSegment(p, a, b) - r;\n}\n\n// Distance to line segment between <a> and <b>, used for fCapsule() version 2below\nfloat fLineSegment(vec3 p, vec3 a, vec3 b) {\n\tvec3 ab = b - a;\n\tfloat t = sat(dot(p - a, ab) / dot(ab, ab));\n\treturn length((ab * t + a) - p);\n}\n\n// Capsule version 2: between two end points <a> and <b> with radius r\nfloat fCapsule(vec3 p, vec3 a, vec3 b, float r) {\n\treturn fLineSegment(p, a, b) - r;\n}\n\n// Subtract from the result to get a round edge\nfloat fBoxRound(vec3 p,vec3 s)\n{\n\tvec3 q=abs(p)-s;\n\treturn length(max(q,vec3(0)))+vmax(min(q,vec3(0)));\n}\nfloat fBoxRound(vec2 p,vec2 s)\n{\n\tvec2 q=abs(p)-s;\n\treturn length(max(q,vec2(0)))+vmax(min(q,vec2(0)));\n}\n\n/* SDF boolean operators */\nvoid fOpUnion(inout float a,float b,inout vec4 m,vec4 n){if(b<a){a=b;m=n;}}\nvoid fOpIntersection(inout float a,float b,inout vec4 m,vec4 n){if(b>a){a=b;m=n;}}\nfloat fOpIntersectionRound(float a,float b,float r){return min(-r,max(a,b))+length(max(r+vec2(a,b),0.));}\nfloat fOpIntersectionChamfer(float a,float b,float r){return max(a,max(b,(a+b+r)*sqrt(.5)));}\n\n/* Main code */\nconst float gameBoyButtonPopOut = 0.15;\nconst vec3 gameBoySizeInCm = vec3(9.0, 14.8, 3.2);\nconst float gameBoyHalfThickness = gameBoySizeInCm.z / 2.0;\n\nvoid fABButton(inout float r, inout vec4 m, vec3 p)\n{\n    const float gameBoyButtonBevel = 0.02;\n    const float gameBoyButtonSize = 0.55;\n\n    // cylinder for the button\n    float a = length(p.xy) - gameBoyButtonSize;\n    // sphere for the cap\n    float b = length(p + vec3(0.0, 0.0, 0.25)) - 0.25 - gameBoyHalfThickness - gameBoyButtonPopOut;\n    // cut off at the back\n    float ir = max(-p.z, fOpIntersectionRound(a, b, gameBoyButtonBevel));\n    // create inset\n    r = fOpIntersectionRound(r, -ir + 0.03, 0.03);\n    // intersect round for the final shape\n    fOpUnion(r, ir, m, vec4(p, 3));\n}\n\nfloat fGameboy(vec3 p, out vec4 m)\n{\n    // I made it mirrored, oops\n    p.xz = -p.xz;\n    // animate it a bit\n    pR(p.xz, sin(iTime) * 0.4 + -0.2);\n    \n    vec2 quadrant = sign(p.xy);\n    const float cornerRadius = 0.2;\n    // one corner is rounder\n    float offset = cornerRadius;\n    if(quadrant.x == -1.0 && quadrant.y == -1.0)\n        offset = 1.7;\n\n    // body\n    float r = fOpIntersectionRound(abs(p.z) - gameBoyHalfThickness, fBoxRound(p.xy, gameBoySizeInCm.xy / 2.0 - offset) - offset, cornerRadius);\n    m = vec4(p, 0);\n\n    // top groove\n    const vec2 grooveInCm = vec2(0.03, 0.06);\n    const float topGrooveOffset = 6.65;\n    r = fOpGroove(r, min(p.y - topGrooveOffset, max(-p.y + topGrooveOffset, abs(p.x) - 3.8)), grooveInCm.x, grooveInCm.y);\n\n    // speaker grooves\n    vec3 cpy = p;\n    cpy.z -= gameBoyHalfThickness;\n    cpy.y += 5.8;\n    cpy.x += 2.85;\n    pR(cpy.xy, radians(-29.));\n    pModInterval(cpy.x, 0.5, -2., 3.);\n    float insetDepth = 0.08;\n    r = max(r, -max(gameBoyHalfThickness - p.z - insetDepth, fBoxRound(cpy.xy, vec3(0.0, 0.7, 0.0).xy) - 0.15));\n\n    // window inset\n    const vec2 insetSize = vec2(7.7, 5.7);\n    const vec2 screenSize = vec2(4.7, 4.3);\n    p.y -= 3.3;\n    quadrant = sign(p.xy);\n    offset = 0.3;\n    if(quadrant.x == -1.0 && quadrant.y == -1.0)\n        offset = 1.0;\n    insetDepth = 0.02;\n    float ir = max(-p.z + gameBoyHalfThickness - insetDepth, fBoxRound(p.xy, insetSize / 2.0 - offset) - offset);\n    fOpIntersection(r, -ir, m, vec4(p, 1));\n\n    // screen inset\n    insetDepth = 0.05;\n    ir = max(-p.z + gameBoyHalfThickness - insetDepth, fBox(p.xy, screenSize / 2.0));\n    if(r <= -ir)\n        m = vec4(p, 2);\n    r = fOpIntersectionRound(r,-ir,insetDepth);\n\n    // battery\n    ir = fSphere(p - vec3(3.3, 0.7, gameBoyHalfThickness), 0.1);\n    fOpUnion(r, ir, m, vec4(2.0, 0.1, 0.1, -1));\n\n    // indent AB\n    p.xy += vec2(3.3, 5.5);\n    float radius = 3.5;\n    ir = fCapsule(p, vec3(0.0, 0.0, gameBoyHalfThickness + radius),\n                     vec3(1.55, -0.7, gameBoyHalfThickness + radius),\n                      radius + 0.1);\n    r = max(r, -ir);\n    // A & B buttons\n    fABButton(r, m, p);\n    p.xy += vec2(-1.55, 0.7);\n    fABButton(r, m, p);\n\n    // indent D-Pad\n    p.xy -= vec2(4.43, 0.25);\n    radius = 8.0;\n    ir = fSphere(p - vec3(0.0, 0.0, gameBoyHalfThickness + radius), radius + 0.1);\n    r = max(r, -ir);\n\n    // D-pad\n    const float buttonBevel = 0.06;\n    const float crossThickness = 0.28;\n    const float crossSize = 1.0;\n    const float curveRadius = 18.0;\n    const float dimpleCurveRadius = 0.2;\n\n    // create an infinite cross\n    vec2 q = abs(p.xy);\n    ir = max(-p.z, max(vmax(q) - crossSize, vmin(q) - crossThickness));\n    // dimple\n    ir = max(ir, 0.04 + dimpleCurveRadius - length(p - vec3(0.0, 0.0, gameBoyHalfThickness + gameBoyButtonPopOut + dimpleCurveRadius)));\n    // cut off the front with a curve\n    cpy = p;\n    cpy.z -= curveRadius + gameBoyHalfThickness + gameBoyButtonPopOut;\n    cpy.z = min(cpy.z, 0.0);\n    ir = fOpIntersectionRound(curveRadius - length(cpy), ir, buttonBevel);\n\n    fOpUnion(r, ir, m, vec4(p, 4));\n\n    // indent start and select\n    ir = fCapsule(p.xy, vec3(-1.05, -2.4, gameBoyHalfThickness).xy, vec3(-1.75, -2.05, gameBoyHalfThickness).xy, -0.05);\n    ir = min(ir, fCapsule(p.xy + vec2(1.55, 0.0), vec3(-1.05, -2.4, gameBoyHalfThickness).xy, vec3(-1.75, -2.05, gameBoyHalfThickness).xy, -0.05));\n    float squishy = 3.0;\n    r = fOpIntersectionChamfer(r * squishy, -ir, 0.37) / squishy;\n\n    // select\n    ir = fCapsule(p, vec3(-1.05, -2.4, gameBoyHalfThickness), vec3(-1.75, -2.05, gameBoyHalfThickness), 0.15);\n    fOpUnion(r, ir, m, vec4(p, 5));\n    // start\n    p.x += 1.55;\n    ir = fCapsule(p, vec3(-1.05, -2.4, gameBoyHalfThickness), vec3(-1.75, -2.05, gameBoyHalfThickness), 0.15);\n    fOpUnion(r, ir, m, vec4(p, 5));\n\n\n    return r;\n}\nfloat fGameboy(vec3 p){vec4 m;return fGameboy(p,m);}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 rayDir = normalize(vec3((fragCoord * 2.0 - iResolution.xy) / iResolution.y, 4.0));\n    vec3 rayOrigin = vec3(0.0, 0.0, -40.0);\n    float s,t=0.1;\n    vec4 m;\n    vec3 p;\n    for(int i = 0 ; i < 100 ; ++i)\n    {\n        p=rayOrigin+rayDir*t;\n        s=fGameboy(p,m);\n        if(s<0.0001)break;\n        t+=s;\n        if(t>100.)break;\n    }\n    vec2 e = vec2(0.001, 0.0);\n    vec3 n = normalize(vec3(fGameboy(p+e.xyy),fGameboy(p+e.yxy),fGameboy(p+e.yyx))-s);\n    \n    vec3 albedo = vec3(0.0);\n    float cosinePower = 100.0;\n    float specularity = 0.1;\n    vec3 additive = vec3(0.0);\n    \n    int objectId = int(m.w);\n    if(objectId==-1) // emissive\n    {additive = vec3(1.0, 0.05, 0.1);}\n    if(objectId==0) // body\n    {albedo = vec3(0.6, 0.55, 0.5); cosinePower = 20.0;}\n    if(objectId==1) // gray plate\n    {albedo = vec3(0.2); specularity = 0.3; cosinePower = 2000.0;}\n    if(objectId==2) // screen\n    {albedo = vec3(0.3, 0.5, 0.1);}\n    if(objectId==3) // AB\n    {albedo = vec3(0.5, 0.02, 0.15); specularity = 0.4;}\n    if(objectId==4) // D-pad\n    {albedo = vec3(0.1); specularity = 0.4;}\n    if(objectId==5) // start & select\n    {albedo = vec3(0.2); cosinePower = 1.0;}\n    \n    \n    vec3 L = normalize(vec3(-0.5, 0.3, -1.8));\n    vec3 col = dot(n,L) * albedo; // basic lambert\n    col *= (1.0 - specularity);\n    col += specularity * pow(max(0.0,dot(reflect(rayDir,n),L)), cosinePower); // basic phong\n    col += additive;\n    vec3 background = vec3(0.05, 0.1, 0.3);\n    col = mix(col * 1.5, background, pow(sat(t/100.),8.));\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ldKfDK.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 700, 719, 719, 741], [742, 742, 761, 761, 793], [794, 794, 813, 813, 835], [836, 836, 855, 855, 887], [889, 912, 943, 943, 977], [979, 1158, 1216, 1216, 1329], [1331, 1400, 1430, 1430, 1450], [1452, 1468, 1494, 1494, 1517], [1519, 1526, 1552, 1552, 1575], [1577, 1607, 1646, 1646, 1689], [1691, 1744, 1799, 1799, 1843], [1845, 1929, 1973, 1973, 2073], [2075, 2146, 2195, 2195, 2232], [2234, 2318, 2362, 2362, 2462], [2464, 2535, 2584, 2584, 2621], [2623, 2671, 2703, 2703, 2776], [2777, 2777, 2809, 2809, 2882], [2884, 2912, 2969, 2969, 2987], [2988, 2988, 3052, 3052, 3070], [3071, 3071, 3123, 3123, 3176], [3177, 3177, 3231, 3231, 3270], [3272, 3440, 3493, 3493, 4037], [4039, 4039, 4075, 4107, 7924], [7925, 7925, 7948, 7948, 7977], [7979, 7979, 8036, 8036, 9614]], "test": "untested"}
{"id": "ldKfWV", "name": "swirly helix", "author": "Balint", "description": "Just a swirly ball", "tags": ["raymarch"], "likes": 6, "viewed": 127, "published": "Public", "date": "1530645252", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const float EPSILON = 0.0001;\nconst float STEPS = 25.0;\nconst float PI = 3.141592653;\n\nfloat cyl(vec2 p, float r) {\n    return length(p) - r;\n}\n\nmat2 rot(float angle) {\n    float c = cos(angle);\n    float s = sin(angle);\n    return mat2(c, s, -s, c);\n}\n\nvec2 moda(vec2 p, float angle) {\n    float a = atan(p.y, p.x);\n    float l = length(p);\n    a = mod(a - angle / 2.0, angle) - angle / 2.0;\n    return vec2(cos(a), sin(a)) * l;\n}\n\nfloat smin( float a, float b, float k )\n{\n    float res = exp( -k*a ) + exp( -k*b );\n    return -log( res )/k;\n}\n\nfloat sph(vec3 p, float r) {\n    return length(p) - r;\n}\n\nfloat map(vec3 p) {\n    \n    \n    vec3 q = p;\n    q.y = abs(q.y);\n    q.xz *= rot(q.y * q.y / 2.0 + iTime);\n    q.xz = moda(q.xz, 2.0 * PI / 6.0);\n    q.x -= 0.5;\n    \n    vec3 r = p.yxz;\n    r.y = abs(r.y);\n    r.xz *= rot(r.y * r.y / 2.0 + iTime);\n    r.xz = moda(r.xz, 2.0 * PI / 6.0);\n    r.x -= 0.5;\n    \n    return smin(min(cyl(q.xz, 0.1), cyl(r.xz, 0.1)), sph(p, 1.0), 5.0);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec3 ro = vec3(0, 0, -6);\n    vec2 uv = fragCoord / iResolution.xx - iResolution.xy / iResolution.xx / 2.0;\n    vec3 rd = normalize(vec3(uv, 1.0));\n    \n    vec3 p = ro;\n    vec3 col = vec3(1);\n    \n    for (float i = 0.0; i < STEPS; i++) {\n        float dist = map(p);\n        if (dist < EPSILON) {\n            col = vec3(1.0 - i / STEPS);\n            break;\n        }\n        p += rd * dist;\n    }\n    fragColor.rgb = col;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ldKfWV.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[87, 87, 115, 115, 143], [145, 145, 168, 168, 252], [254, 254, 286, 286, 431], [433, 433, 474, 474, 545], [547, 547, 575, 575, 603], [605, 605, 624, 624, 988], [990, 990, 1045, 1045, 1476]], "test": "untested"}
{"id": "ldVfWV", "name": "Fireworks night", "author": "olympus223", "description": "A simple fireworks effect. This can probably be improved a lot, as i'm new to this. Any tips would be welcome!", "tags": ["particles", "sky", "night", "fireworks"], "likes": 19, "viewed": 1312, "published": "Public", "date": "1530982736", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define s(a, b, t) smoothstep(a, b, t)\n#define g -9.81\n\nfloat distLine(vec2 p, vec2 a, vec2 b) {\n\tvec2 pa = p - a;\n    vec2 ba = b - a;\n    float t = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\n    return length(pa - ba * t);\n}\n\nfloat line(vec2 uv, vec2 a, vec2 b, float w) {\n    //return s(w, w - 0.01, distLine(uv, a, b));\n    return w / distLine(uv, a, b);\n}\n\n\nfloat N21(vec2 p) {\n\tp = fract(p * vec2(233.34, 851.73));\n    p += dot(p, p + 23.45);\n    return fract(p.x * p.y);\n}\n\nvec2 N22(vec2 p) {\n\tfloat n = N21(p);\n    return vec2(n, N21(p + n));\n}\n\nfloat N11(float n) {\n    return fract(sin(dot(vec2(cos(n), sin(n)) ,vec2(27.9898, 38.233))) * 88.5453);\n}\n\n\nfloat particle(vec2 uv, vec2 p, vec2 v, float r, float t) {\n    float x = p.x + v.x * t;\n    float y = p.y + v.y * t + g / 2.0 * t * t;\n    vec2 j = (vec2(x, y) - uv) * 20.0;\n    float sparkle = 1.0 / dot(j, j);\n    return sparkle;\n}\n\nvec2 p1(vec2 p, float h, float t) {\n    return vec2(p.x, p.y + clamp(pow(t, 5.0), 0.0, h));\n}\n\nvec2 p2(vec2 p, float h, float t) {\n    return vec2(p.x, p.y + clamp(pow(0.95 * t, 5.0), 0.0, h));\n}\n\nfloat endTime(float h) {\n    return pow(h, 1.0 / 5.0) * 1.1;\n}\n\nfloat seed = 0.32;\n\nfloat explosion(vec2 uv, vec2 p, float s, float n, float f, float t) {\n    float m = 0.0;\n    float dt = 0.5;\n\tfor(float i = 0.0; i < n; i++) {\n    \tseed += i;\n        vec2 rand = vec2(1.0, 2.0) * (vec2(-1.0, 1.0) + 2.0 * N22(vec2(seed, i)));\n    \tvec2 v = vec2(cos(seed), sin(seed)) + rand;\n        m += particle(uv, p, v, s, t)\n            * s(2.0, 2.0 - dt, t)\n            * s(0.0, dt, t);\n    }   \n    return m;\n}\n\nfloat fireworks(vec2 uv, vec2 p, float h, float n, float s, float f, float t) {\n    vec2 p1 = p1(p, h, t);\n    float e = endTime(h);\n    return explosion(uv, p1, s, n, f, t - e * 0.9);\n}\n\nfloat shaft(vec2 uv, vec2 p, float w, float h, float t) {\n    vec2 p1 = p1(p, h, t) + vec2(0.0, 0.3);\n    vec2 p2 = p2(p, h, t);\n    float e = 1.0 / 0.95 * endTime(h);\n    vec2 j = (p1 - uv) * 15.0;\n    float sparkle = 1.0 / dot(j, j);\n    return (line(uv, p1, p2, w) + sparkle) * s(e, e - 0.5, t) * 0.5;\n}\n\nvec3 base(vec2 uv) {\n\treturn 0.5 + 0.5 * cos(iTime + uv.xyx + vec3(0, 2, 4));   \n}\n\nfloat back(vec2 uv, vec2 p, float t) {\n    float dt = 0.3;\n    float j = length(p - uv);\n    float m = exp(-0.005 * j * j);\n    return 0.2 * m * s(-dt / 4.0, 0.0, t) * s(dt, 0.0, t);\n}\n\nfloat stars(vec2 uv) {\n    float r = N21(uv);\n    return s(0.001, 0.0, r);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n    float t = iTime / 10.0;\n    float scale = 10.0;\n    uv *= scale;\n    vec3 col = vec3(0.05 + stars(uv));\n    \n    float a = -0.035 * sin(t * 15.0);\n    float co = cos(a);\n    float si = sin(a);\n    mat2 trans1 = mat2(co, si, -si, co);\n    vec2 trans2 = vec2(-15.0 * a, 0.0);\n    uv *= trans1;\n    uv += trans2;\n    \n    for(float i = 0.0; i < 1.0; i += 1.0 / 8.0) {\n        float ti = mod(t * 9.0 - i * 5.0, 4.0);\n        float scale = mix(2.0, 0.3, ti / 4.0);\n        vec2 uvs = uv * scale;\n        float rand = N11(i);\n        float h = 10.0 + rand * 4.0;\n        float w = 0.02;\n        float n = 80.0;\n        float s = 0.9;\n        float f = 1.5;\n        vec2 p = vec2(mix(-8.0, 8.0, rand), -10.0);\n          \n        col += back(uvs, vec2(p.x, p.y + h), ti - 1.8) \n            + fireworks(uvs, p, h, n, s, f, ti) * base(uv)\n            + shaft(uvs, p, w, h, ti);\n    }\n    \n    fragColor = vec4(col, 0.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ldVfWV.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[56, 56, 96, 96, 227], [229, 229, 275, 324, 361], [364, 364, 383, 383, 480], [482, 482, 500, 500, 553], [555, 555, 575, 575, 660], [663, 663, 722, 722, 896], [898, 898, 933, 933, 991], [993, 993, 1028, 1028, 1093], [1095, 1095, 1119, 1119, 1157], [1179, 1179, 1249, 1249, 1596], [1598, 1598, 1677, 1677, 1784], [1786, 1786, 1843, 1843, 2092], [2094, 2094, 2114, 2114, 2176], [2178, 2178, 2216, 2216, 2362], [2364, 2364, 2386, 2386, 2440], [2442, 2442, 2497, 2497, 3480]], "test": "untested"}
{"id": "ldyfDK", "name": " 4-Rook Anti Aliasing", "author": "Carandiru", "description": "Anti Aliasing on left, no antialiasing on right.\ncopy of https://www.shadertoy.com/view/llj3Dw by demofox , now of which compiles", "tags": ["antialiasing", "nrook"], "likes": 2, "viewed": 220, "published": "Public", "date": "1530504408", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/*\n  Written by Alan Wolfe\n  http://demofox.org/\n  http://blog.demofox.org/\n\n\n4-Rook anti aliasing works by using 4 samples per pixel in the following configuration:\n\n\n  +-----------+\n  |  |  |A |  |\n  |--|--|--|--|\n  |D |  |  |  |\n  |--|--|--|--|\n  |  |  |  |B |\n  |--|--|--|--|\n  |  |C |  |  |\n  +-----------+\n\n\nA,B,C,D have a weight of 0.25.\n\nThis makes for AA that is not quite as blurry looking as quincunx, but unlike\nquincunx you can't share samples between pixels.  This is straight up 4x SSAA!\n\nMore info here:\nhttp://blog.demofox.org/2015/04/23/4-rook-antialiasing-rgss/\n*/\n\n\n#define MINSCALE 0.4\n#define MAXSCALE 4.0\n#define TIMEMULTIPLIER 0.1\n\n\n\n#define DRAW_CIRCLE(_x,_y,_radius,_color) if (length(pos-vec2(_x,_y)) < _radius) return _color;\n\n#define DRAW_RECT(_x,_y,_w,_h,_color) if ((abs(pos.x-(_x)) < _w/2.0)&&(abs(pos.y-(_y)) < _h/2.0)) return _color;\n\n#define DRAW_OBB(_x,_y,_w,_h,_r,_color) {vec2 rel = vec2(pos.x-(_x), pos.y-(_y)); rel = vec2(cos(_r)*rel.x-sin(_r)*rel.y,sin(_r)*rel.x+cos(_r)*rel.y); if ((abs(rel.x) < _w/2.0)&&(abs(rel.y-_y) < _h/2.0)) return _color;}\n\nvec3 GetPixelColor(vec2 pos)\n{\n    // thin white grill\n    DRAW_RECT(-0.0,0.50,1.0,0.005,vec3(1,1,1));\n    DRAW_RECT(-0.0,0.52,1.0,0.005,vec3(1,1,1));\n    DRAW_RECT(-0.0,0.54,1.0,0.005,vec3(1,1,1));\n    DRAW_RECT(-0.0,0.56,1.0,0.005,vec3(1,1,1));\n    DRAW_RECT(-0.0,0.58,1.0,0.005,vec3(1,1,1));\n    DRAW_RECT(-0.0,0.60,1.0,0.005,vec3(1,1,1));\n    \n    // textured circles\n    DRAW_CIRCLE(-0.7, 0.7,0.25,texture(iChannel0, pos).xyz);\n    DRAW_CIRCLE(-0.7,-0.7,0.25,texture(iChannel1, pos).xyz);\n    DRAW_CIRCLE( 0.7,-0.7,0.25,texture(iChannel2, pos).xyz);\n    DRAW_CIRCLE( 0.7, 0.7,0.25,texture(iChannel3, pos).xyz);\n    \n    // spinning red and blue box\n    DRAW_OBB(-0.5, 0.0, 0.3, 0.1,  iTime, vec3(1.0, 0.0, 0.0));\n    DRAW_OBB(-0.5, 0.0, 0.1, 0.3, -iTime, vec3(0.0, 0.0, 1.0));\n    \n    // concentric spiral boxes\n    DRAW_OBB( 0.5, 0.0, 0.1, 0.1, 0.4, vec3(0.0));\n    DRAW_OBB( 0.5, 0.0, 0.2, 0.2, 0.3, vec3(1.0));\n    DRAW_OBB( 0.5, 0.0, 0.3, 0.3, 0.2, vec3(0.0));\n    DRAW_OBB( 0.5, 0.0, 0.4, 0.4, 0.1, vec3(1.0));\n    DRAW_OBB( 0.5, 0.0, 0.5, 0.5, 0.0, vec3(0.0));\n       \n    // untextured circles\n    DRAW_CIRCLE(0.0,0.0,0.1,vec3(0.9,0.1,0.9));\n    DRAW_CIRCLE(0.0,0.0,1.0,vec3(0.1,0.9,0.1));\n    \n    // grid background\n    float gridColor = mod(floor(pos.x*20.0),2.0) == mod(floor(pos.y*20.0),2.0) ? 0.8 : 0.0;  \n    return vec3(gridColor);\n}\n\n\nvec2 PixelToWorld (in vec2 coord)\n{\n// aspect ratio correction\n \tvec2 resolution = vec2 (iResolution.x / 2.0, iResolution.x);\n \tfloat g_arcorrection = resolution.x / resolution.y;\n\n// image zoom, defined by time\n \tfloat g_scale = (sin(iTime * TIMEMULTIPLIER + 1.57) * 0.5 + 0.5) * (MAXSCALE - MINSCALE) + MINSCALE;\n\t\n    vec2 ret = ((coord / resolution) - vec2(0.5,0.5*g_arcorrection)) * g_scale;\n    ret *= vec2(g_arcorrection, -1.0);\n    return ret;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\t   \n    vec3 pixelColor;\n   \n    vec2 resolution = vec2 (iResolution.x / 2.0, iResolution.x);\n    \n    // draw middle line\n    if (abs(fragCoord.x - resolution.x) < 2.0)\n    {\n        pixelColor = vec3(1.0,1.0,1.0);\n    }\n    // right side = no AA\n\telse if( fragCoord.x > resolution.x)\n\t{\n        fragCoord.x -= resolution.x;\n        pixelColor = GetPixelColor(PixelToWorld(fragCoord.xy));\n\t}\n\t// left side = AA\n\telse\n    {\n        const float S = 1.0/8.0;\n        const float L  = 3.0/8.0;\n        pixelColor  = GetPixelColor(PixelToWorld(fragCoord.xy + vec2( S, -L ))) / 4.0;\n        pixelColor += GetPixelColor(PixelToWorld(fragCoord.xy + vec2( L , S))) / 4.0;\n        pixelColor += GetPixelColor(PixelToWorld(fragCoord.xy + vec2(-S, -L ))) / 4.0;\n        pixelColor += GetPixelColor(PixelToWorld(fragCoord.xy + vec2(-L ,-S))) / 4.0;\n\t}\t\t\n\t\n    // write pixel\n\tfragColor = vec4(pixelColor, 1.0);\n}", "image_inputs": [{"id": "4dXGRn", "previewfilepath": "/media/ap/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg", "channel": 3, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg", "ctype": "texture"}, {"id": "4sXGRn", "previewfilepath": "/media/ap/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg", "ctype": "texture"}, {"id": "XdfGRn", "previewfilepath": "/media/ap/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg", "ctype": "texture"}, {"id": "XsfGRn", "previewfilepath": "/media/ap/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ldyfDK.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 1090, 1120, 1144, 2444], [2447, 2447, 2482, 2509, 2900], [2902, 2902, 2959, 2959, 3860]], "test": "untested"}
{"id": "ldyfWK", "name": "unfold", "author": "lennyjpg", "description": "asdfasdfasdfasdf", "tags": ["asdfasfasdf"], "likes": 1, "viewed": 321, "published": "Public API", "date": "1530482184", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 O, in vec2 f ){\n    vec2 uv = f/iResolution.xy -.5 + vec2(-.07,.27);\n    float a = atan(uv.y, uv.x)*.37,  e = mod(2.0 * a + iTime * .7, 2.);\n    O = vec4(sin(a * e));\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ldyfWK.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 40, 40, 193]], "test": "untested"}
{"id": "ll3cRB", "name": "seed dance", "author": "lasiafly", "description": "ray trace - seed dance performed by sexy balls", "tags": ["raytracedance"], "likes": 9, "viewed": 579, "published": "Public API", "date": "1533002989", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const int NUM_LIGHTS = 2;\nconst int NUM_MATERIALS = 4;\nconst int NUM_PLANES = 2;\nconst int NUM_SPHERES = 26;\n\nconst vec3 BACKGROUND_COLOR = vec3( 0.1, 0.2, 0.6 );\n\n// Vertical field-of-view angle of camera. In radians.\nconst float FOVY = 50.0 * 3.1415926535 / 180.0;\n\n// Use this for avoiding the \"epsilon problem\" or the shadow acne problem.\nconst float DEFAULT_TMIN = 10.0e-4;\n\n// Use this for tmax for non-shadow ray intersection test.\nconst float DEFAULT_TMAX = 10.0e6;\n\n// Equivalent to number of recursion levels (0 means ray-casting only).\n// We are using iterations to replace recursions.\nconst int NUM_ITERATIONS = 2;\n\n\n//============================================================================\n// Define new struct types.\n//============================================================================\nstruct Ray_t {\n    vec3 o;  // Ray Origin.\n    vec3 d;  // Ray Direction. A unit vector.\n};\n\nstruct Plane_t {\n    // The plane equation is Ax + By + Cz + D = 0.\n    float A, B, C, D;\n    int materialID;\n};\n\nstruct Sphere_t {\n    vec3 center;\n    float radius;\n    int materialID;\n};\n\nstruct Light_t {\n    vec3 position;  // Point light 3D position.\n    vec3 I_a;       // For Ambient.\n    vec3 I_source;  // For Diffuse and Specular.\n};\n\nstruct Material_t {\n    vec3 k_a;   // Ambient coefficient.\n    vec3 k_d;   // Diffuse coefficient.\n    vec3 k_r;   // Reflected specular coefficient.\n    vec3 k_rg;  // Global reflection coefficient.\n    float n;    // The specular reflection exponent. Ranges from 0.0 to 128.0.\n};\n\n//----------------------------------------------------------------------------\n// The lighting model used here is similar to that on Slides 8 and 12 of\n// Lecture 11 (Ray Tracing). Here it is computed as\n//\n//     I_local = SUM_OVER_ALL_LIGHTS {\n//                   I_a * k_a +\n//                   k_shadow * I_source * [ k_d * (N.L) + k_r * (R.V)^n ]\n//               }\n// and\n//     I = I_local  +  k_rg * I_reflected\n//----------------------------------------------------------------------------\n\n\n//============================================================================\n// Global scene data.\n//============================================================================\nPlane_t Plane[NUM_PLANES];\nSphere_t Sphere[NUM_SPHERES];\nLight_t Light[NUM_LIGHTS];\nMaterial_t Material[NUM_MATERIALS];\nfloat centerx=0.6;\nfloat centery = 1.315;\nfloat centerz=0.8;\nfloat headr=0.15;\nfloat bodyr=0.08;\nfloat legr=0.05;\nfloat armr=0.05;\nfloat armcenterx;\nfloat armcentery;\nfloat zout = 0.08;\nvec3 lighta0;\nvec3 lighta1;\n\nvoid lightchange(out vec3 attr0, out vec3 attr1){\n    if(iTime < 6.5){\n        attr0 = vec3(0.0);\n        attr1 = vec3(0.0);\n    }\n    else if(iTime == 6.5){\n        attr0 = vec3(1.0);\n        attr1 = vec3(1.0);\n    }\n    else if(iTime > 6.5 && iTime < 13.0){\n        attr0 = vec3(abs(sin(0.2 * iTime)), 0.5, 0.5);\n        attr1 = vec3(0.0);\n    }\n    \n    else if(iTime >= 13.0 && iTime < 19.0){\n        attr0 = vec3(0.0);\n        attr1 = vec3(0.5, 0.5, abs(sin(0.4 * iTime)));\n    }\n    \n    else if(iTime>77.5&&iTime<104.87){\n        attr0 = vec3(0.8 * abs(sin(1.0 * iTime)), 0.8 * abs(sin(1.3 * iTime)), 0.8 * abs(sin(1.5 * iTime)));\n        attr1 = vec3(0.8 * abs(sin(1.5*iTime)), 0.8 * abs(sin( 1.3* iTime)), 0.8 * abs(sin(1.0 * iTime)));\n    }\n    else\n        \n    {\n        attr0 = vec3(0.8 * abs(sin(0.2 * iTime)), 0.8 * abs(sin(0.5 * iTime)), 0.8 * abs(sin(0.8 * iTime)));\n        attr1 = vec3(0.8 * abs(sin(iTime)), 0.8 * abs(sin(0.7 * iTime)), 0.8 * abs(sin(0.4 * iTime)));\n        \n    }\n}\nvoid Update()\n{\n    Sphere[0].center = vec3(centerx ,centery, centerz);\n    Sphere[1].center = vec3( centerx  , centery-headr-bodyr, centerz);\n    Sphere[2].center = vec3( centerx  , centery-(headr+bodyr*3.0), centerz);\n    Sphere[3].center = vec3( centerx , centery-(headr+bodyr*5.0), centerz);\n    Sphere[4].center = vec3(centerx ,centery-(headr+bodyr*7.0) , centerz);\n    Sphere[5].center = vec3(centerx ,centery-(headr+bodyr*9.0) , centerz);\n    Sphere[6].center = vec3( centerx+bodyr+armr ,armcentery , centerz);\n    Sphere[8].center = vec3( centerx+bodyr+armr*5.0 ,armcentery, centerz);\n    Sphere[10].center = vec3( centerx+bodyr+armr*9.0,armcentery, centerz);\n    Sphere[11].center = vec3( centerx-(bodyr+armr),armcentery, centerz);\n    Sphere[13].center = vec3( centerx-(bodyr+armr*5.0),armcentery, centerz);\n    Sphere[15].center = vec3( centerx-(bodyr+armr*9.0),armcentery, centerz);\n    Sphere[16].center = vec3( centerx-0.5*(bodyr+legr),centery-(headr+bodyr*10.0+legr*0.5), centerz);\n    Sphere[18].center = vec3( centerx-0.5*(bodyr+legr*5.0),centery-(headr+bodyr*10.0+legr*3.0),centerz);\n    Sphere[20].center = vec3( centerx-0.5*(bodyr+legr*9.0),centery-(headr+bodyr*10.0+legr*6.0), centerz);\n    Sphere[21].center = vec3( centerx+0.5*(bodyr+legr),centery-(headr+bodyr*10.0+legr*0.5), centerz);\n    Sphere[23].center = vec3( centerx+0.5*(bodyr+legr*5.0),centery-(headr+bodyr*10.0+legr*3.0),centerz);\n    Sphere[25].center =  vec3( centerx+0.5*(bodyr+legr*9.0),centery-(headr+bodyr*10.0+legr*6.0), centerz);\n    Sphere[24].center =(Sphere[23].center +Sphere[25].center )/2.0;;\n    Sphere[12].center =  (Sphere[11].center+Sphere[13].center)/2.0;\n    Sphere[14].center =  (Sphere[13].center+Sphere[15].center)/2.0;\n    Sphere[17].center = (Sphere[16].center+Sphere[18].center)/2.0;\n    Sphere[7].center = (Sphere[6].center+Sphere[8].center)/2.0;\n    Sphere[9].center = (Sphere[8].center+Sphere[10].center)/2.0;\n    Sphere[19].center = (Sphere[18].center +Sphere[20].center )/2.0;\n    Sphere[22].center = (Sphere[21].center +Sphere[23].center )/2.0;\n    \n    \n}\n\n//basic action\n/*right arm right wave*/\nvoid rightarm_rwave(float freq, float amp){\n    Sphere[6].center.y += 0.3 * amp * sin(freq * iTime);\n    Sphere[8].center.y -= 2.0*amp * sin(freq * iTime);\n    Sphere[10].center.y += 0.7 * amp * sin(freq * iTime);\n    Sphere[10].center.x += abs(amp * cos(0.15*freq * iTime));\n    \n}\nvoid rightarm_lwave(float freq, float amp){\n    Sphere[10].center.xy = Sphere[2].center.xy;\n    Sphere[10].center.z += zout;\n    Sphere[10].center.x -= 3.*armr;\n    Sphere[10].center.y -= 0.15;\n    Sphere[8].center.z += zout;\n    Sphere[8].center.y -= 0.15;\n    Sphere[6].center.y += 0.3 * amp * sin(freq * iTime);\n    Sphere[8].center.y -= 2.0*amp * sin(freq * iTime);\n    Sphere[10].center.y += 0.7 * amp * sin(freq * iTime);\n    Sphere[10].center.x += abs(amp * cos(0.15*freq * iTime));\n    \n}\n/*right arm up wave*/\nvoid rightarm_ulwave(float freq, float amp){\n    Sphere[6].center.y += 0.5*armr;\n    Sphere[6].center.x += 0.8 * amp * sin(freq * iTime);\n    Sphere[8].center.x = 0.9*armcenterx;\n    Sphere[8].center.y += 3.*armr;\n    Sphere[10].center.x = 1.2*0.9*armcenterx;\n    Sphere[10].center.y += 9.*armr;\n    Sphere[8].center.x -= amp * sin(freq * iTime);\n    Sphere[10].center.x -= 0.7 * amp *abs(sin(iTime));\n    Sphere[8].center.y -= 2.*amp * abs(sin(iTime));\n    Sphere[10].center.y -= 2.*amp * abs(sin(iTime));\n}\nvoid rightarm_urwave(float freq, float amp){\n    Sphere[6].center.y += 0.5*armr;\n    Sphere[6].center.x += 0.8 * amp * sin(freq * iTime);\n    Sphere[8].center.x = 0.9*armcenterx;\n    Sphere[8].center.y += 3.*armr;\n    Sphere[10].center.x = 1.2*0.9*armcenterx;\n    Sphere[10].center.y += 9.*armr;\n    Sphere[8].center.x += amp * sin(freq * iTime);\n    Sphere[10].center.x -= 0.7 * amp *abs(sin(iTime));\n    Sphere[8].center.y -= 2.*amp * abs(sin(iTime));\n    Sphere[10].center.y -= 2.*amp * abs(sin(iTime));\n}\n/*right arm front wave*/\nvoid rightarm_fwave(float freq, float amp){\n    Sphere[6].center.y += 0.5 * amp * sin(freq * iTime);\n    Sphere[8].center.x = Sphere[6].center.x;\n    Sphere[8].center.z = Sphere[6].center.z+3.*armr;\n    Sphere[8].center.y -= 0.5 * amp * sin(freq * iTime);\n    Sphere[10].center.x = Sphere[6].center.x;\n    Sphere[10].center.z = Sphere[6].center.z+9.*armr;\n    Sphere[10].center.y += 0.8 * amp * sin(freq * iTime);\n}\n/*right arm down wave*/\nvoid rightarm_dlwave(float freq, float amp){\n    Sphere[6].center.y -= 0.5*armr;\n    Sphere[6].center.x += 0.8 * amp * sin(freq * iTime);\n    Sphere[8].center.x = 0.9*armcenterx;\n    Sphere[8].center.y -= 3.*armr;\n    Sphere[10].center.x = 1.2*0.9*armcenterx;\n    Sphere[10].center.y -= 8.*armr;\n    Sphere[8].center.x -= 2.*amp * sin(freq * iTime);\n    Sphere[10].center.x -= 0.7 * amp *abs(sin(iTime));\n    \n}\nvoid rightarm_drwave(float freq, float amp){\n    \n    Sphere[6].center.x += 0.8 * amp * sin(freq * iTime);\n    Sphere[8].center.x = 0.9*armcenterx;\n    Sphere[8].center.y -= 3.*armr;\n    Sphere[10].center.x = 1.2*0.9*armcenterx;\n    Sphere[10].center.y -= 8.*armr;\n    Sphere[8].center.x += 2.*amp * sin(freq * iTime);\n    Sphere[10].center.x -= 0.7 * amp *abs(sin(iTime));\n    \n}\n\n/*left arm right wave*/\nvoid leftarm_rwave(float freq, float amp){\n    Sphere[15].center.xy = Sphere[2].center.xy;\n    Sphere[15].center.z += zout;\n    Sphere[15].center.x += 3.*armr;\n    Sphere[15].center.y -= 0.15;\n    Sphere[13].center.z += zout;\n    Sphere[13].center.y -= 0.15;\n    Sphere[11].center.y += 0.3 * amp * sin(freq * iTime);\n    Sphere[13].center.y -= 2.0*amp * sin(freq * iTime);\n    Sphere[15].center.y += 0.7 * amp * sin(freq * iTime);\n    Sphere[15].center.x -= abs(amp * cos(0.15*freq * iTime));\n}\n/*left arm left wave*/\nvoid leftarm_lwave(float freq, float amp){\n    Sphere[11].center.y += 0.3 * amp * sin(freq * iTime);\n    Sphere[13].center.y -= 2.0*amp * sin(freq * iTime);\n    Sphere[15].center.y += 0.7 * amp * sin(freq * iTime);\n    Sphere[15].center.x -= abs(amp * cos(0.15*freq * iTime));\n}\n/*left arm up wave*/\nvoid leftarm_ulwave(float freq, float amp){\n    Sphere[11].center.y += 0.5*armr;\n    Sphere[11].center.x -= 0.8 * amp * sin(freq * iTime);\n    Sphere[13].center.x = 2.*centerx - 0.9*armcenterx;\n    Sphere[13].center.y += 3.*armr;\n    Sphere[15].center.x = 2.*centerx - 1.2*0.9*armcenterx;\n    Sphere[15].center.y += 9.*armr;\n    Sphere[13].center.x += amp * sin(freq * iTime);\n    Sphere[15].center.x += 0.7 * amp *abs(sin(iTime));\n    Sphere[13].center.y -= 2.*amp * abs(sin(iTime));\n    Sphere[15].center.y -= 2.*amp * abs(sin(iTime));\n    \n}\nvoid leftarm_urwave(float freq, float amp){\n    Sphere[11].center.y += 0.5*armr;\n    Sphere[11].center.x -= 0.8 * amp * sin(freq * iTime);\n    Sphere[13].center.x = 2.*centerx - 0.9*armcenterx;\n    Sphere[13].center.y += 3.*armr;\n    Sphere[15].center.x = 2.*centerx - 1.2*0.9*armcenterx;\n    Sphere[15].center.y += 9.*armr;\n    Sphere[13].center.x -= amp * sin(freq * iTime);\n    Sphere[15].center.x += 0.7 * amp *abs(sin(iTime));\n    Sphere[13].center.y -= 2.*amp * abs(sin(iTime));\n    Sphere[15].center.y -= 2.*amp * abs(sin(iTime));\n}\n/*left arm down wave*/\n\nvoid leftarm_dlwave(float freq, float amp){\n    Sphere[11].center.y -= 0.5*armr;\n    Sphere[13].center.x = 2.*centerx - 0.9*armcenterx;\n    Sphere[13].center.y -= 3.*armr;\n    Sphere[15].center.x = 2.*centerx - 1.2*0.9*armcenterx;\n    Sphere[15].center.y -= 8.*armr;\n    Sphere[13].center.x += 2.*amp * sin(freq * iTime);\n    Sphere[15].center.x += 0.7 * amp *abs(sin(iTime));\n    \n}\nvoid leftarm_drwave(float freq, float amp){\n    Sphere[11].center.y -= 0.5*armr;\n    Sphere[13].center.x = 2.*centerx - 0.9*armcenterx;\n    Sphere[13].center.y -= 3.*armr;\n    Sphere[15].center.x = 2.*centerx - 1.2*0.9*armcenterx;\n    Sphere[15].center.y -= 8.*armr;\n    Sphere[13].center.x -= 2.*amp * sin(freq * iTime);\n    Sphere[15].center.x += 0.7 * amp *abs(sin(iTime));\n}\n\n/*left arm front wave*/\nvoid leftarm_fwave(float freq, float amp){\n    Sphere[11].center.y += 0.3 * amp * sin(freq * iTime);\n    Sphere[13].center.x = Sphere[11].center.x;\n    Sphere[13].center.z = Sphere[11].center.z+3.*armr;\n    Sphere[13].center.y -= 0.5 * amp * sin(freq * iTime);\n    Sphere[15].center.x = Sphere[11].center.x;\n    Sphere[15].center.z = Sphere[11].center.z+9.*armr;\n    Sphere[15].center.y += 0.8 * amp * sin(freq * iTime);\n}\n\n\nvoid llegwave(float freq,float amp)\n{\n    Sphere[16].center.x += 0.01 * cos(freq * iTime);\n    Sphere[16].center.z += 0.01 * sin(freq * iTime);\n    Sphere[17].center.x += 0.03 * sin(freq * iTime);\n    Sphere[17].center.z += 0.03 * cos(freq * iTime);\n    Sphere[18].center.x += 0.05 * sin(freq * iTime);\n    Sphere[18].center.z += 0.05 * cos(freq * iTime);\n    Sphere[19].center.x += 0.03 * sin(freq * iTime);\n    Sphere[19].center.z += 0.03 * cos(freq * iTime);\n    Sphere[20].center.x += 0.01 * sin(freq * iTime);\n    Sphere[20].center.z += 0.01 * cos(freq * iTime);\n}\n\n\n\nvoid rlegwave(float freq,float amp)\n{\n    Sphere[21].center.x += 0.01 * cos(freq * iTime);\n    Sphere[21].center.z += 0.01 * sin(freq * iTime);\n    Sphere[22].center.x += 0.03 * sin(freq * iTime);\n    Sphere[22].center.z += 0.03 * cos(freq * iTime);\n    Sphere[23].center.x += 0.05 * sin(freq * iTime);\n    Sphere[23].center.z += 0.05 * cos(freq * iTime);\n    Sphere[24].center.x += 0.03 * sin(freq * iTime);\n    Sphere[24].center.z += 0.03 * cos(freq * iTime);\n    Sphere[25].center.x += 0.01 * sin(freq * iTime);\n    Sphere[25].center.z += 0.01 * cos(freq * iTime);\n}\n\nvoid rllegwave(float freq,float amp)\n{\n    Sphere[21].center.x -= 0.01 * sin(freq * iTime);\n    Sphere[21].center.z -= 0.01 * cos(freq * iTime);\n    Sphere[22].center.x -= 0.03 * sin(freq * iTime);\n    Sphere[22].center.z -= 0.03 * cos(freq * iTime);\n    Sphere[23].center.x -= 0.05 * sin(freq * iTime);\n    Sphere[23].center.z -= 0.05 * cos(freq * iTime);\n    Sphere[24].center.x -= 0.03 * sin(freq * iTime);\n    Sphere[24].center.z -= 0.03 * cos(freq * iTime);\n    Sphere[25].center.x -= 0.01 * sin(freq * iTime);\n    Sphere[25].center.z -= 0.01 * cos(freq * iTime);\n}\n\nvoid body_movex(float amp)\n{\n    centerx +=amp*sin(1.0*iTime);\n    \n}\n\nvoid body_movez(float amp)\n{\n    centerz +=amp*sin(1.0*iTime);\n}\n\n\n/*waist left*/\n\nvoid waist_lwave(float freq, float amp){\n    Sphere[0].center.x += 0.01 * cos(freq * iTime);\n    Sphere[0].center.z += 0.01 * sin(freq * iTime);\n    Sphere[1].center.x += 0.01 * sin(freq * iTime);\n    Sphere[1].center.z += 0.01 * cos(freq * iTime);\n    Sphere[2].center.x += 0.03 * sin(freq * iTime);\n    Sphere[2].center.z += 0.03 * cos(freq * iTime);\n    Sphere[3].center.x += 0.05 * sin(freq * iTime);\n    Sphere[3].center.z += 0.05 * cos(freq * iTime);\n    Sphere[4].center.x += 0.03 * sin(freq * iTime);\n    Sphere[4].center.z += 0.03 * cos(freq * iTime);\n    Sphere[5].center.x += 0.01 * sin(freq * iTime);\n    Sphere[5].center.z += 0.01 * cos(freq * iTime);\n}\n\nvoid noodle_arm(float freq, float amp){\n    Sphere[0].center.x += 0.01 * cos(freq * iTime);\n    Sphere[0].center.z += 0.01 * sin(freq * iTime);\n    Sphere[1].center.x += 0.01 * sin(freq * iTime);\n    Sphere[1].center.z += 0.01 * cos(freq * iTime);\n    Sphere[2].center.x += 0.03 * sin(freq * iTime);\n    Sphere[2].center.z += 0.03 * cos(freq * iTime);\n    Sphere[3].center.x += 0.05 * sin(freq * iTime);\n    Sphere[3].center.z += 0.05 * cos(freq * iTime);\n    Sphere[4].center.x += 0.03 * sin(freq * iTime);\n    Sphere[4].center.z += 0.03 * cos(freq * iTime);\n    Sphere[5].center.x += 0.01 * sin(freq * iTime);\n    Sphere[5].center.z += 0.01 * cos(freq * iTime);\n    Sphere[6].center.y += 0.01 * sin(freq * iTime);\n    Sphere[6].center.z += 0.01 * cos(freq * iTime);\n    Sphere[7].center.y += 0.03 * sin(freq * iTime);\n    Sphere[7].center.z += 0.03 * cos(freq * iTime);\n    Sphere[8].center.y += 0.05 * sin(freq * iTime);\n    Sphere[8].center.z += 0.05 * cos(freq * iTime);\n    Sphere[9].center.y += 0.03 * sin(freq * iTime);\n    Sphere[9].center.z += 0.03 * cos(freq * iTime);\n    Sphere[10].center.y -= 0.01 * sin(freq * iTime);\n    Sphere[10].center.z -= 0.01 * cos(freq * iTime);\n    Sphere[11].center.y -= 0.01 * sin(freq * iTime);\n    Sphere[11].center.z -= 0.01 * cos(freq * iTime);\n    Sphere[12].center.y -= 0.03 * sin(freq * iTime);\n    Sphere[12].center.z -= 0.03 * cos(freq * iTime);\n    Sphere[13].center.y -= 0.05 * sin(freq * iTime);\n    Sphere[13].center.z -= 0.05 * cos(freq * iTime);\n    Sphere[14].center.y -= 0.03 * sin(freq * iTime);\n    Sphere[14].center.z -= 0.03 * cos(freq * iTime);\n    Sphere[15].center.y -= 0.01 * sin(freq * iTime);\n    Sphere[15].center.z -= 0.01 * cos(freq * iTime);\n    Sphere[16].center.x += 0.01 * sin(freq * iTime);\n    Sphere[16].center.z += 0.01 * cos(freq * iTime);\n    Sphere[17].center.x += 0.03 * sin(freq * iTime);\n    Sphere[17].center.z += 0.03 * cos(freq * iTime);\n    Sphere[18].center.x += 0.05 * sin(freq * iTime);\n    Sphere[18].center.z += 0.05 * cos(freq * iTime);\n    Sphere[19].center.x += 0.03 * sin(freq * iTime);\n    Sphere[19].center.z += 0.03 * cos(freq * iTime);\n    Sphere[20].center.x += 0.01 * sin(freq * iTime);\n    Sphere[20].center.z += 0.01 * cos(freq * iTime);\n    Sphere[21].center.x -= 0.01 * sin(freq * iTime);\n    Sphere[21].center.z -= 0.01 * cos(freq * iTime);\n    Sphere[22].center.x -= 0.03 * sin(freq * iTime);\n    Sphere[22].center.z -= 0.03 * cos(freq * iTime);\n    Sphere[23].center.x -= 0.05 * sin(freq * iTime);\n    Sphere[23].center.z -= 0.05 * cos(freq * iTime);\n    Sphere[24].center.x -= 0.03 * sin(freq * iTime);\n    Sphere[24].center.z -= 0.03 * cos(freq * iTime);\n    Sphere[25].center.x -= 0.01 * sin(freq * iTime);\n    Sphere[25].center.z -= 0.01 * cos(freq * iTime);\n    \n}\n\n/*head node*/\nvoid head_node(float freq, float amp){\n    float theta = amp * abs(sin(freq * iTime));\n    Sphere[0].center.x =  Sphere[1].center.x + headr * sin(theta);\n    Sphere[0].center.y = Sphere[1].center.y + headr * cos(theta);\n    \n}\n\nvoid assmove(float freq, float amp){\n    Sphere[5].center.x += amp * sin(freq * iTime);\n    Sphere[5].center.y += amp * sin(freq * iTime);\n    Sphere[4].center.x += 0.8 * amp * sin(freq * iTime);\n    Sphere[4].center.y += 0.8 * amp * sin(freq * iTime);\n    Sphere[16].center.x += 0.5 * amp * sin(freq * iTime);\n    Sphere[16].center.y += 0.5 * amp * sin(freq * iTime);\n    Sphere[21].center.x += 0.5 * amp * sin(freq * iTime);\n    Sphere[21].center.y += 0.5 * amp * sin(freq * iTime);\n}\n\n/////////////////////////////////////////////////////////////////////////////\n// Initializes the scene.\n/////////////////////////////////////////////////////////////////////////////\nvoid InitScene()\n\n{\n    lightchange(lighta0,lighta1);\n    armcenterx= centerx+bodyr+armr*5.0;\n    armcentery=centery-(headr+bodyr*3.0);\n    int flag = 0;\n    \n    // Horizontal plane.\n    Plane[0].A = 0.0;\n    Plane[0].B = 1.0;\n    Plane[0].C = 0.0;\n    Plane[0].D = 0.0;\n    Plane[0].materialID = 0;\n    \n    // Vertical plane.\n    Plane[1].A = 0.0;\n    Plane[1].B = 0.0;\n    Plane[1].C = 1.0;\n    Plane[1].D = 3.5;\n    Plane[1].materialID = 0;\n    \n    // Center bouncing sphere.\n    \n    Sphere[0].center = vec3(centerx ,centery, centerz);\n    Sphere[0].radius = headr;\n    Sphere[0].materialID = 1;\n    \n    \n    // Circling sphere.\n    \n    Sphere[1].center = vec3( centerx  , centery-headr-bodyr, centerz);\n    Sphere[1].radius = bodyr;\n    Sphere[1].materialID = 3;\n    \n    \n    Sphere[2].center = vec3( centerx  , centery-(headr+bodyr*3.0), centerz);\n    Sphere[2].radius = bodyr;\n    Sphere[2].materialID = 3;\n    \n    \n    Sphere[3].center = vec3( centerx , centery-(headr+bodyr*5.0), centerz);\n    Sphere[3].radius = bodyr;\n    Sphere[3].materialID = 3;\n    \n    \n    Sphere[4].center = vec3(centerx ,centery-(headr+bodyr*7.0) , centerz);\n    Sphere[4].radius = 1.1*bodyr;\n    Sphere[4].materialID = 3;\n    \n    \n    Sphere[5].center = vec3(centerx ,centery-(headr+bodyr*9.0) , centerz);\n    Sphere[5].radius = 1.4*legr;\n    Sphere[5].materialID = 3;\n    \n    Sphere[6].center = vec3( centerx+bodyr+armr ,armcentery , centerz);\n    Sphere[6].radius = armr;\n    Sphere[6].materialID = 2;\n    \n    Sphere[8].center = vec3( centerx+bodyr+armr*5.0 ,armcentery, centerz);\n    Sphere[8].radius = armr;\n    Sphere[8].materialID = 2;\n    \n    \n    Sphere[10].center = vec3( centerx+bodyr+armr*9.0,armcentery, centerz);\n    Sphere[10].radius = armr;\n    Sphere[10].materialID = 2;\n    \n    \n    Sphere[11].center = vec3( centerx-(bodyr+armr),armcentery, centerz);\n    Sphere[11].radius = armr;\n    Sphere[11].materialID = 2;\n    \n    \n    \n    Sphere[13].center = vec3( centerx-(bodyr+armr*5.0),armcentery, centerz);\n    Sphere[13].radius = armr;\n    Sphere[13].materialID = 2;\n    \n    \n    Sphere[15].center = vec3( centerx-(bodyr+armr*9.0),armcentery, centerz);\n    Sphere[15].radius = armr;\n    Sphere[15].materialID = 2;\n    \n    Sphere[16].center = vec3( centerx-0.5*(bodyr+legr),centery-(headr+bodyr*10.0+legr*0.5), centerz);\n    Sphere[16].radius = legr;\n    Sphere[16].materialID = 2;\n    \n    Sphere[18].center = vec3( centerx-0.5*(bodyr+legr*5.0),centery-(headr+bodyr*10.0+legr*3.0),centerz);\n    Sphere[18].radius = legr;\n    Sphere[18].materialID = 2;\n    \n    Sphere[20].center = vec3( centerx-0.5*(bodyr+legr*9.0),centery-(headr+bodyr*10.0+legr*6.0), centerz);\n    Sphere[20].radius = legr;\n    Sphere[20].materialID = 2;\n    \n    Sphere[21].center = vec3( centerx+0.5*(bodyr+legr),centery-(headr+bodyr*10.0+legr*0.5), centerz);\n    Sphere[21].radius = legr;\n    Sphere[21].materialID = 2;\n    \n    Sphere[23].center = vec3( centerx+0.5*(bodyr+legr*5.0),centery-(headr+bodyr*10.0+legr*3.0),centerz);\n    Sphere[23].radius = legr;\n    Sphere[23].materialID = 2;\n    \n    Sphere[25].center =  vec3( centerx+0.5*(bodyr+legr*9.0),centery-(headr+bodyr*10.0+legr*6.0), centerz);\n    Sphere[25].radius = legr;\n    Sphere[25].materialID = 2;\n    \n    \n    if(iTime <6.5){\n        rightarm_dlwave(6.0,0.05);\n        leftarm_drwave(6.0,0.05);\n        waist_lwave(6.0,0.05);\n        flag = 1;\n    }\n    \n    if(iTime >6.5 && iTime<8.7){\n        rightarm_fwave(6.0,0.05);\n        leftarm_drwave(6.0,0.05);\n        head_node(6.0, 0.3);\n        flag = 1;\n\n    }\n    if(iTime >8.7&& iTime<9.5){\n        rightarm_ulwave(6.0,0.05);\n        rightarm_dlwave(6.0,0.05);\n        flag = 1;\n\n    }\n    if(iTime >10.0&& iTime<11.9){\n        leftarm_lwave(6.0,0.05);\n        rightarm_lwave(6.0,0.05);\n        head_node(6.0, 0.3);\n        flag = 1;\n\n    }\n    if(iTime >11.9&& iTime<13.3){\n        llegwave(6.0,0.05);\n        rlegwave(6.0,0.05);\n        rightarm_rwave(6.0,0.05);\n        leftarm_rwave(6.0,0.05);\n        head_node(6.0, 0.3);\n        flag = 1;\n\n    }\n    if(iTime >13.5&& iTime<14.3){\n        body_movez(0.3);\n        Update();\n        llegwave(6.0,0.05);\n        rlegwave(6.0,0.05);\n        waist_lwave(7.0,0.05);\n        rightarm_urwave(6.0,0.05);\n        leftarm_lwave(6.0,0.05);\n        flag = 1;\n\n    }\n    if(iTime >14.5&& iTime<15.3){\n        body_movex(0.3);\n        Update();\n        llegwave(6.0,0.05);\n        rlegwave(6.0,0.05);\n        waist_lwave(7.0,0.05);\n        rightarm_lwave(6.0,0.05);\n        leftarm_rwave(6.0,0.05);\n        flag = 1;\n\n    }\n    if(iTime >15.5&& iTime<16.5){\n        body_movex(0.3);\n        Update();\n        llegwave(6.0,0.05);\n        rlegwave(6.0,0.05);\n        waist_lwave(7.0,0.05);\n        rightarm_rwave(6.0,0.05);\n        leftarm_lwave(6.0,0.05);\n        flag = 1;\n\n    }\n    if(iTime >16.5&& iTime<18.3){\n        rightarm_drwave(6.0,0.05);\n        leftarm_dlwave(6.0,0.05);\n        flag = 1;\n\n    }\n    if(iTime >18.7&& iTime<20.0){\n        rightarm_ulwave(6.0,0.05);\n        leftarm_dlwave(6.0,0.05);\n        flag = 1;\n\n    }\n    \n    if(iTime >20.8&& iTime<21.9|| iTime>77.5&&iTime<80.8){//noodle\n        body_movez(0.3);\n        Update();\n        llegwave(6.0,0.05);\n        rllegwave(6.0,0.05);\n        waist_lwave(7.0,0.05);\n        noodle_arm(6.0,0.05);\n        flag = 1;\n\n    }\n    if(iTime >21.9&& iTime<23.4 || iTime>80.8&&iTime<84.2|| iTime>94.5&&iTime<98.0|| iTime>88.0&&iTime<91.2 ){\n        body_movex(0.3);\n        Update();\n        llegwave(6.0,0.05);\n        rllegwave(6.0,0.05);\n        waist_lwave(7.0,0.05);\n        rightarm_urwave(6.0,0.05);\n        leftarm_lwave(6.0,0.05);\n        flag = 1;\n\n    }\n    if(iTime >23.4&& iTime<25.9 || iTime>84.2&&iTime<88.0){\n        body_movez(0.3);\n        Update();\n        llegwave(6.0,0.05);\n        rllegwave(6.0,0.05);\n        waist_lwave(7.0,0.05);\n        leftarm_ulwave(6.0,0.05);\n        rightarm_rwave(6.0,0.05);\n        flag = 1;\n\n    }\n    if(iTime >25.9&& iTime<28.9|| iTime>88.0&&iTime<91.2){\n        body_movex(0.3);\n        Update();\n        llegwave(6.0,0.05);\n        rlegwave(6.0,0.05);\n        waist_lwave(7.0,0.05);\n        leftarm_fwave(6.0,0.05);\n        rightarm_fwave(6.0,0.05);\n        flag = 1;\n\n    }\n    if(iTime >28.9&& iTime<32.9|| iTime>91.2&&iTime<94.5){\n        body_movez(0.3);\n        Update();\n        llegwave(6.0,0.05);\n        rllegwave(6.0,0.05);\n        waist_lwave(7.0,0.05);\n        noodle_arm(6.0,0.05);\n        flag = 1;\n\n    }\n    if(iTime >33.0&& iTime<34.4|| iTime>98.0&&iTime<101.5){\n        body_movex(0.3);\n        Update();\n        llegwave(6.0,0.05);\n        rlegwave(6.0,0.05);\n        waist_lwave(7.0,0.05);\n        leftarm_ulwave(6.0,0.05);\n        rightarm_urwave(6.0,0.05);\n        flag = 1;\n\n    }\n    if(iTime >34.5 && iTime<36.2){\n        rightarm_fwave(6.0,0.05);\n        leftarm_drwave(6.0,0.05);\n        head_node(6.0, 0.3);\n        flag = 1;\n\n    }\n    if(iTime >36.3&& iTime<37.3){\n        rightarm_ulwave(6.0,0.05);\n        rightarm_dlwave(6.0,0.05);\n        flag = 1;\n\n    }\n   \tif(iTime >37.4&& iTime<39.6|| iTime>94.5&&iTime<98.0 ){\n        leftarm_lwave(6.0,0.05);\n        rightarm_lwave(6.0,0.05);\n        head_node(6.0, 0.3);\n        flag = 1;\n\n    }\n    if(iTime >39.6&& iTime<40.5){\n        body_movex(0.3);\n        Update();\n        llegwave(6.0,0.05);\n        rlegwave(6.0,0.05);\n        waist_lwave(7.0,0.05);\n        rightarm_lwave(6.0,0.05);\n        leftarm_rwave(6.0,0.05);\n        flag = 1;\n\n    }\n    if(iTime >41.2&& iTime<42.3){\n        body_movex(0.3);\n        Update();\n        llegwave(6.0,0.05);\n        rlegwave(6.0,0.05);\n        waist_lwave(7.0,0.05);\n        rightarm_rwave(6.0,0.05);\n        leftarm_lwave(6.0,0.05);\n        flag = 1;\n\n    }\n    if(iTime >42.3&& iTime<45.5){\n        rightarm_drwave(6.0,0.05);\n        leftarm_dlwave(6.0,0.05);\n        flag = 1;\n\n    }\n    if(iTime >46.8&& iTime<46.6){\n        rightarm_ulwave(6.0,0.05);\n        leftarm_dlwave(6.0,0.05);\n        flag = 1;\n\n    }\n    if(iTime >46.6&& iTime<47.2){\n        rightarm_fwave(6.0,0.05);\n        leftarm_dlwave(6.0,0.05);\n        flag = 1;\n\n    }\n    if(flag==0){\n        body_movez(0.3);\n        Update();\n        llegwave(6.0,0.05);\n        rllegwave(6.0,0.05);\n        waist_lwave(7.0,0.05);\n        noodle_arm(6.0,0.05);\n        head_node(6.0, 0.4);\n    }\n    \n    \n    Sphere[12].center =  (Sphere[11].center+Sphere[13].center)/2.0;\n    Sphere[12].radius = armr;\n    Sphere[12].materialID = 2;\n    \n    \n    Sphere[14].center =  (Sphere[13].center+Sphere[15].center)/2.0;\n    Sphere[14].radius = armr;\n    Sphere[14].materialID = 2;\n    \n    \n    Sphere[17].center = (Sphere[16].center+Sphere[18].center)/2.0;\n    Sphere[17].radius = legr;\n    Sphere[17].materialID = 2;\n    \n    \n    \n    Sphere[7].center = (Sphere[6].center+Sphere[8].center)/2.0;\n    Sphere[7].radius = armr;\n    Sphere[7].materialID = 2;\n    \n    Sphere[9].center = (Sphere[8].center+Sphere[10].center)/2.0;\n    Sphere[9].radius = armr;\n    Sphere[9].materialID = 2;\n    \n    \n    Sphere[19].center = (Sphere[18].center +Sphere[20].center )/2.0;\n    Sphere[19].radius = legr;\n    Sphere[19].materialID = 2;\n    \n    \n    Sphere[22].center = (Sphere[21].center +Sphere[23].center )/2.0;\n    Sphere[22].radius = legr;\n    Sphere[22].materialID = 2;\n    \n    \n    \n    Sphere[24].center =(Sphere[23].center +Sphere[25].center )/2.0;;\n    Sphere[24].radius = legr;\n    Sphere[24].materialID = 2;\n    \n    // Silver material.\n    Material[0].k_d = vec3( 0.5, 0.5, 0.5 );\n    Material[0].k_a = 0.2 * Material[0].k_d;\n    Material[0].k_r = 2.0 * Material[0].k_d;\n    Material[0].k_rg = 0.5 * Material[0].k_r;\n    Material[0].n = 64.0;\n    \n    // Pink material.\n    Material[1].k_d = vec3(0.5, 1.0, 1.0);\n    Material[1].k_a = 0.2 * Material[1].k_d;\n    Material[1].k_r = 2.0 * Material[1].k_d;\n    Material[1].k_rg = 0.5 * Material[1].k_r;\n    Material[1].n = 64.0;\n    \n    // Green plastic material.\n    Material[2].k_d = vec3(0.0, 0.8, 0.0);\n    Material[2].k_a = 0.2 * Material[2].k_d;\n    Material[2].k_r = vec3( 1.0, 1.0, 1.0 );\n    Material[2].k_rg = 0.5 * Material[2].k_r;\n    Material[2].n = 128.0;\n    \n    // Blue material.\n    Material[3].k_d = vec3(1.0, 1.0, 0.5);\n    Material[3].k_a = 0.2 * Material[3].k_d;\n    Material[3].k_r = 2.0 * Material[3].k_d;\n    Material[3].k_rg = 0.5 * Material[3].k_r;\n    Material[3].n = 64.0;\n    \n    // Light 0.\n    Light[0].position = vec3(centerx + 3.0 * sin(iTime), centery + 20.0, 10.0 + centerz + 3.0 * cos(iTime));\n    Light[0].I_a = vec3(0.1, 0.1, 0.1);\n    Light[0].I_source = vec3(0.0 + lighta0.r, 0.0 + lighta0.g, 0.0 + lighta0.b);\n    \n    \n    // Light 1.\n    Light[1].position = vec3(centerx + 3.0 * sin(iTime), centery + 20.0, 10.0 + centerz - 3.0 * cos(iTime));\n    Light[1].I_a = vec3(0.1, 0.1, 0.1);\n    Light[1].I_source = vec3(0.0 + lighta1.r, 0.0 + lighta1.g, 0.0 + lighta1.b);\n}\n\n\n\n/////////////////////////////////////////////////////////////////////////////\n// Computes intersection between a plane and a ray.\n// Returns true if there is an intersection where the ray parameter t is\n// between tmin and tmax, otherwise returns false.\n// If there is such an intersection, outputs the value of t, the position\n// of the intersection (hitPos) and the normal vector at the intersection\n// (hitNormal).\n/////////////////////////////////////////////////////////////////////////////\nbool IntersectPlane( in Plane_t pln, in Ray_t ray, in float tmin, in float tmax,\n                    out float t, out vec3 hitPos, out vec3 hitNormal )\n{\n    vec3 N = vec3( pln.A, pln.B, pln.C );\n    float NRd = dot( N, ray.d );\n    float NRo = dot( N, ray.o );\n    float t0 = (-pln.D - NRo) / NRd;\n    if ( t0 < tmin || t0 > tmax ) return false;\n    \n    // We have a hit -- output results.\n    t = t0;\n    hitPos = ray.o + t0 * ray.d;\n    hitNormal = normalize( N );\n    return true;\n}\n\n\n\n/////////////////////////////////////////////////////////////////////////////\n// Computes intersection between a plane and a ray.\n// Returns true if there is an intersection where the ray parameter t is\n// between tmin and tmax, otherwise returns false.\n/////////////////////////////////////////////////////////////////////////////\nbool IntersectPlane( in Plane_t pln, in Ray_t ray, in float tmin, in float tmax )\n{\n    vec3 N = vec3( pln.A, pln.B, pln.C );\n    float NRd = dot( N, ray.d );\n    float NRo = dot( N, ray.o );\n    float t0 = (-pln.D - NRo) / NRd;\n    if ( t0 < tmin || t0 > tmax ) return false;\n    return true;\n}\n\n\n\n/////////////////////////////////////////////////////////////////////////////\n// Computes intersection between a sphere and a ray.\n// Returns true if there is an intersection where the ray parameter t is\n// between tmin and tmax, otherwise returns false.\n// If there is one or two such intersections, outputs the value of the\n// smaller t, the position of the intersection (hitPos) and the normal\n// vector at the intersection (hitNormal).\n/////////////////////////////////////////////////////////////////////////////\nbool IntersectSphere( in Sphere_t sph, in Ray_t ray, in float tmin, in float tmax,\n                     out float t, out vec3 hitPos, out vec3 hitNormal )\n{\n    /////////////////////////////////\n    // TASK: WRITE YOUR CODE HERE. //\n    /////////////////////////////////\n    float a = 1.0;\n    float b = 2.0 * dot(ray.d, (ray.o - sph.center));\n    float c = dot((ray.o - sph.center), (ray.o - sph.center)) - sph.radius * sph.radius;\n    float d = b * b - 4.0 * a * c;\n    float t0;\n    if(d < 0.0) return false;\n    else\n    {\n        float t1 = (-b + sqrt(d)) / (2.0 * a);\n        float t2 = (-b - sqrt(d)) / (2.0 * a);\n        if (t1 < tmin || t1 > tmax)           //t1 false\n        {\n            if (t2 < tmin || t2 > tmax)    //t1&t2 false\n                return false;\n            else                           //t2 ok t1 false\n                t0 = t2;\n        }\n        else                               //t1 ok\n        {\n            if (t2 < tmin || t2 > tmax)    //t2 false t1 ok\n                t0 = t1;\n            else                           //t2 ok t1 ok\n                t0 = min(t1,t2);\n        }\n    }\n    // We have a hit -- output results.\n    t = t0;\n    hitPos = ray.o + t0 * ray.d;\n    hitNormal = normalize(vec3(ray.o + t0 * ray.d - sph.center));\n    return true;\n}\n\n\n\n/////////////////////////////////////////////////////////////////////////////\n// Computes intersection between a sphere and a ray.\n// Returns true if there is an intersection where the ray parameter t is\n// between tmin and tmax, otherwise returns false.\n/////////////////////////////////////////////////////////////////////////////\nbool IntersectSphere( in Sphere_t sph, in Ray_t ray, in float tmin, in float tmax )\n{\n    /////////////////////////////////\n    // TASK: WRITE YOUR CODE HERE. //\n    /////////////////////////////////\n    float a = 1.0;\n    float b = 2.0 * dot(ray.d, (ray.o - sph.center));\n    float c = dot((ray.o - sph.center), (ray.o - sph.center)) - sph.radius * sph.radius;\n    float d = b * b - 4.0 * a * c;\n    float t0;\n    if(d < 0.0) return false;\n    else\n    {\n        float t1 = (-b + sqrt(d)) / (2.0 * a);\n        float t2 = (-b - sqrt(d)) / (2.0 * a);\n        if (t1 < tmin || t1 > tmax)           //t1 false\n        {\n            if (t2 < tmin || t2 > tmax)    //t1&t2 false\n                return false;\n            else                           //t2 ok t1 false\n                return true;\n        }\n        else\n            return true;\n    }\n}\n\n\n\n\n/////////////////////////////////////////////////////////////////////////////\n// Computes (I_a * k_a) + k_shadow * I_source * [ k_d * (N.L) + k_r * (R.V)^n ].\n// Input vectors L, N and V are pointing AWAY from surface point.\n// Assume all vectors L, N and V are unit vectors.\n/////////////////////////////////////////////////////////////////////////////\nvec3 PhongLighting( in vec3 L, in vec3 N, in vec3 V, in bool inShadow,\n                   in Material_t mat, in Light_t light )\n{\n    if ( inShadow ) {\n        return light.I_a * mat.k_a;\n    }\n    else {\n        vec3 R = reflect( -L, N );\n        float N_dot_L = max( 0.0, dot( N, L ) );\n        float R_dot_V = max( 0.0, dot( R, V ) );\n        float R_dot_V_pow_n = ( R_dot_V == 0.0 )? 0.0 : pow( R_dot_V, mat.n );\n        \n        return light.I_a * mat.k_a +\n        light.I_source * (mat.k_d * N_dot_L + mat.k_r * R_dot_V_pow_n);\n    }\n}\n\n\n/////////////////////////////////////////////////////////////////////////////\n// Casts a ray into the scene and returns color computed at the nearest\n// intersection point. The color is the sum of light from all light sources,\n// each computed using Phong Lighting Model, with consideration of\n// whether the interesection point is being shadowed from the light.\n// If there is no interesection, returns the background color, and outputs\n// hasHit as false.\n// If there is intersection, returns the computed color, and outputs\n// hasHit as true, the 3D position of the intersection (hitPos), the\n// normal vector at the intersection (hitNormal), and the k_rg value\n// of the material of the intersected object.\n/////////////////////////////////////////////////////////////////////////////\nvec3 CastRay( in Ray_t ray,\n             out bool hasHit, out vec3 hitPos, out vec3 hitNormal, out vec3 k_rg )\n{\n    // Find whether and where the ray hits some object.\n    // Take the nearest hit point.\n    \n    bool hasHitSomething = false;\n    float nearest_t = DEFAULT_TMAX;   // The ray parameter t at the nearest hit point.\n    vec3 nearest_hitPos;              // 3D position of the nearest hit point.\n    vec3 nearest_hitNormal;           // Normal vector at the nearest hit point.\n    int nearest_hitMatID;             // MaterialID of the object at the nearest hit point.\n    \n    float temp_t;\n    vec3 temp_hitPos;\n    vec3 temp_hitNormal;\n    bool temp_hasHit;\n    \n    /////////////////////////////////////////////////////////////////////////////\n    // TASK:\n    // * Try interesecting input ray with all the planes and spheres,\n    //   and record the front-most (nearest) interesection.\n    // * If there is interesection, need to record hasHitSomething,\n    //   nearest_t, nearest_hitPos, nearest_hitNormal, nearest_hitMatID.\n    /////////////////////////////////////////////////////////////////////////////\n    /////////////////////////////////\n    // TASK: WRITE YOUR CODE HERE. //\n    for( int j = 0; j < NUM_SPHERES; ++j )//sphere intersect\n    {\n        temp_hasHit =  IntersectSphere(Sphere[j],ray,DEFAULT_TMIN,DEFAULT_TMAX);\n        if(temp_hasHit == false)\n            continue;\n        else{\n            IntersectSphere(Sphere[j],ray,DEFAULT_TMIN,DEFAULT_TMAX,temp_t,temp_hitPos,temp_hitNormal);\n            if(hasHitSomething == false && temp_hasHit == true)\n                hasHitSomething = true;\n            if(temp_t < nearest_t){\n                nearest_t = temp_t;\n                nearest_hitPos = temp_hitPos;\n                nearest_hitNormal = temp_hitNormal;\n                nearest_hitMatID = Sphere[j].materialID;\n            }\n        }\n    }\n    \n    for( int j = 0; j < NUM_PLANES; ++j )//sphere intersect\n    {\n        temp_hasHit =  IntersectPlane(Plane[j],ray,DEFAULT_TMIN,DEFAULT_TMAX);\n        if(temp_hasHit == false)\n            continue;\n        else{\n            IntersectPlane(Plane[j],ray,DEFAULT_TMIN,DEFAULT_TMAX,temp_t,temp_hitPos,temp_hitNormal);\n            if(hasHitSomething == false && temp_hasHit == true)\n                hasHitSomething = true;\n            if(temp_t < nearest_t){\n                nearest_t = temp_t;\n                nearest_hitPos = temp_hitPos;\n                nearest_hitNormal = temp_hitNormal;\n                nearest_hitMatID = Plane[j].materialID;\n            }\n        }\n    }\n    /////////////////////////////////\n    \n    \n    \n    // One of the output results.\n    hasHit = hasHitSomething;\n    if ( !hasHitSomething ) return BACKGROUND_COLOR;\n    \n    vec3 I_local = vec3( 0.0 );// Result color will be accumulated here.\n    /////////////////////////////////////////////////////////////////////////////\n    // TASK:\n    // * Accumulate lighting from each light source on the nearest hit point.\n    //   They are all accumulated into I_local.\n    // * For each light source, make a shadow ray, and check if the shadow ray\n    //   intersects any of the objects (the planes and spheres) between the\n    //   nearest hit point and the light source.\n    // * Then, call PhongLighting() to compute lighting for this light source.\n    /////////////////////////////////////////////////////////////////////////////\n    \n    /////////////////////////////////\n    // TASK: WRITE YOUR CODE HERE. //\n    Ray_t shadowray;\n    shadowray.o = nearest_hitPos;\n    bool inShadow;\n    bool inshadowtemp;\n    vec3 lightvec;\n    //make shadowray and calculate I_local\n    for( int i = 0; i < NUM_LIGHTS; ++i)//sphere intersect\n    {\n        inShadow = false;\n        shadowray.d = normalize(Light[i].position - shadowray.o);\n        lightvec = shadowray.d;\n        \n        for( int j = 0; j < NUM_SPHERES; ++j )//sphere intersect\n        {\n            inshadowtemp = IntersectSphere(Sphere[j],shadowray,DEFAULT_TMIN,DEFAULT_TMAX);\n            if(inShadow == false && inshadowtemp == true)\n                inShadow = true;\n            \n        }\n        //get I_local\n        I_local += PhongLighting(lightvec, nearest_hitNormal, -ray.d, inShadow,\n                                 Material[nearest_hitMatID], Light[i]);\n    }\n    \n    /////////////////////////////////\n    \n    // Populate output results.\n    hitPos = nearest_hitPos;\n    hitNormal = nearest_hitNormal;\n    k_rg = Material[nearest_hitMatID].k_rg;\n    \n    return I_local;\n}\n\n\n\n/////////////////////////////////////////////////////////////////////////////\n// Execution of fragment shader starts here.\n// 1. Initializes the scene.\n// 2. Compute a primary ray for the current pixel (fragment).\n// 3. Trace ray into the scene with NUM_ITERATIONS recursion levels.\n/////////////////////////////////////////////////////////////////////////////\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    InitScene();\n    \n    \n    \n    \n    // Scale pixel 2D position such that its y coordinate is in [-1.0, 1.0].\n    vec2 pixel_pos = (2.0 * fragCoord.xy - iResolution.xy) / iResolution.y;\n    \n    // Position the camera.\n    vec3 cam_pos;\n    vec3 cam_lookat;\n    vec3 cam_up_vec = vec3( 0.0, 1.0, 0.0 );\n    cam_pos = vec3( -1.5, 0.8, 3. );\n    cam_lookat = vec3( 1.5, 1.0, -0.3 );\n    if(iTime>7.5&&iTime<19.2){\n        cam_pos = vec3(1.5-0.058*(iTime-7.5), 1.0-0.014*(iTime-7.5), 3. );\n        cam_lookat = vec3( 1.5*sin(0.08*iTime), 1.0, -0.3*cos(0.08*iTime) );\n    }\n    else if(iTime>36.3 && iTime<47.5){\n        cam_pos = vec3(1.5-sin(0.1*iTime), 1.0, 3.-cos(0.1*iTime) );\n        cam_lookat = vec3( 1.5*sin(0.08*iTime), 1.0, -0.3*cos(0.08*iTime) );\n    }\n    else if((iTime>47.5&&iTime<77.5)||iTime>104.87){\n        cam_pos = vec3(centerx + 2.0 * sin(iTime), centery, centerz + 2.0 * cos(iTime));\n        cam_lookat = vec3(centerx, centery / 2.0, centerz);\n    }\n    \n    \n    // Set up camera coordinate frame in world space.\n    vec3 cam_z_axis = normalize( cam_pos - cam_lookat );\n    vec3 cam_x_axis = normalize( cross(cam_up_vec, cam_z_axis) );\n    vec3 cam_y_axis = normalize( cross(cam_z_axis, cam_x_axis));\n    \n    // Create primary ray.\n    float pixel_pos_z = -1.0 / tan(FOVY / 2.0);\n    Ray_t pRay;\n    pRay.o = cam_pos;\n    pRay.d = normalize( pixel_pos.x * cam_x_axis  +  pixel_pos.y * cam_y_axis  +  pixel_pos_z * cam_z_axis );\n    \n    \n    // Start Ray Tracing.\n    // Use iterations to emulate the recursion.\n    \n    vec3 I_result = vec3( 0.0 );\n    vec3 compounded_k_rg = vec3( 1.0 );\n    Ray_t nextRay = pRay;\n    \n    for ( int level = 0; level <= NUM_ITERATIONS; level++ )\n    {\n        bool hasHit;\n        vec3 hitPos, hitNormal, k_rg;\n        \n        vec3 I_local = CastRay( nextRay, hasHit, hitPos, hitNormal, k_rg );\n        \n        I_result += compounded_k_rg * I_local;\n        \n        if ( !hasHit ) break;\n        \n        compounded_k_rg *= k_rg;\n        \n        nextRay = Ray_t( hitPos, normalize( reflect(nextRay.d, hitNormal) ) );\n    }\n    \n    fragColor = vec4( I_result, 1.0 );\n}\n\n", "image_inputs": [{"id": "4s2SWy", "previewfilepath": "https://soundcloud.com/allanteng/dy-mix", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0, "src": "https://soundcloud.com/allanteng/dy-mix", "ctype": "musicstream"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ll3cRB.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[2040, 2555, 2604, 2604, 3558], [3559, 3559, 3574, 3574, 5631], [5633, 5673, 5716, 5716, 5955], [5956, 5956, 5999, 5999, 6452], [6453, 6475, 6519, 6519, 6983], [6984, 6984, 7028, 7028, 7492], [7493, 7518, 7561, 7561, 7933], [7934, 7958, 8002, 8002, 8369], [8370, 8370, 8414, 8414, 8750], [8752, 8776, 8818, 8818, 9270], [9271, 9294, 9336, 9336, 9572], [9573, 9594, 9637, 9637, 10138], [10139, 10139, 10182, 10182, 10678], [10679, 10703, 10746, 10746, 11086], [11087, 11087, 11130, 11130, 11465], [11467, 11491, 11533, 11533, 11913], [11916, 11916, 11953, 11953, 12485], [12489, 12489, 12526, 12526, 13058], [13060, 13060, 13098, 13098, 13630], [13632, 13632, 13660, 13660, 13701], [13703, 13703, 13731, 13731, 13767], [13770, 13786, 13826, 13826, 14452], [14454, 14454, 14493, 14493, 17236], [17238, 17252, 17290, 17290, 17478], [17480, 17480, 17516, 17516, 17966], [17968, 18150, 18169, 18169, 29054], [29058, 29554, 29707, 29707, 30041], [30045, 30377, 30460, 30460, 30672], [30676, 31194, 31350, 31464, 32485], [32489, 32822, 32907, 33021, 33670], [33675, 34029, 34158, 34158, 34571], [34574, 35363, 35475, 35566, 39875], [39879, 40240, 40297, 40297, 42430]], "test": "untested"}
{"id": "ll3cRM", "name": "MARLON INFINITE SHADER", "author": "CALI", "description": "MARLON INFINITE SHADER", "tags": ["marloninfiniteshader"], "likes": 1, "viewed": 98, "published": "Public", "date": "1531961623", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const int NUM_STEPS =40; //how many spheres are shown\nconst float EPSILON\t= 5e-2;\nconst float hesitate = .95;\n\n\n\nfloat dist(vec3 p){ //distance funtion goes here - this generates the spheres\n    vec3 c = 1.2*vec3(1,1,1); //CHANGE THIS FLOAT TO CHANGE SPHERE PACKING\n   \tfloat osc = 1.*dot(p,vec3(1,1,1));\n    return length(mod(p,c)-c*.5)-.2+ .03*sin((20.12+osc)*p.x +iTime);//*sin((17.1+osc)*p.y)*sin((13.+osc)*p.z);\n\n}\n\nvec3 getNormal(vec3 p, float eps) { //this function generates the normal vec for the object\n    vec3 n;\n   \n    n.x = dist(vec3(p.x+eps,p.y,p.z));\n\tn.y = dist(vec3(p.x,p.y+eps,p.z));\n    n.z = dist(vec3(p.x,p.y,p.z+eps));\n\n    return normalize(n-vec3(1,1,1)*dist(p));\n}\n\nvec3 march(vec3 ori, vec3 dir, out vec3 p) {  //this is the main raymarching function, give a ray to get a color\n    vec3 center = vec3(0,0,0);\n    vec3 light = 200.*normalize(vec3(cos(1.*iTime),1.1,sin(1.0*iTime)));\n\n    \n    for(int i = 0; i < NUM_STEPS; i++) {   \n        float tmid = dist(ori);\n        ori = ori + dir * tmid * hesitate;                   \n        \n\t\tif(tmid < EPSILON) {\n            p = getNormal(ori,0.0001);\n            vec3 pl = normalize(light-p);\n            return vec3(1,1,1)*.2+vec3(1,.6,1)*max(0.0,(dot(p,pl)*.7))+vec3(0,0,1)*pow(max(0.,dot(p,pl)),30.)*2.0;\n            \n            \n\t\t\tp.x = p.x/2.0 +.5;\n            p.y = p.y/2.0 +.5;\n            p.z = p.z/2.0 +.5;\n            //return 1.0;\n        }\n    }\n    return vec3(1,1,1)*.17;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 mouse = iMouse.xy/iResolution.xy - vec2(0.5, 0.);\n    if(iMouse.xy == vec2(0.))mouse = vec2(0.5, 0.);\n    mouse.x*=5.;\n    mouse.x += iTime*0.11;\n    mouse.y*=2.;\n    vec2 uv = fragCoord/iResolution.xy;\n\tuv-=0.5;\n    uv.x*=iResolution.x/iResolution.y;\n    float groundHeight = 0.;\n    float angle = mouse.x;\n    float fov = 0.5;\n    float bigness = 2.;\n    float camDist = mouse.y+bigness*2.;\n    vec3 ori = vec3(cos(mouse.x)*camDist, sin(mouse.x/2.)*cos(mouse.x / 3.3)*3.4, sin(mouse.x)*camDist);\n    vec3 dir = vec3(-cos(mouse.x+uv.x*fov)*2., sin(mouse.x)*cos(mouse.x)*3.4+uv.y, -sin(mouse.x+uv.x*fov)*2.);\n    dir = normalize(dir);\n\t\n    vec3 p;\n\t//all above code is just to decide camera pos, then color is decided below\n    vec3 color = march(ori,dir,p);\n    \n    \n    // Output to screen\n    fragColor = vec4(color,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ll3cRM.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[25, 113, 132, 190, 419], [421, 421, 456, 512, 690], [692, 692, 736, 804, 1462], [1464, 1464, 1521, 1521, 2359]], "test": "untested"}
{"id": "ll3cRN", "name": "Atan Tan ", "author": "momoro", "description": "Math fun", "tags": ["blackandwhite"], "likes": 1, "viewed": 380, "published": "Public API", "date": "1531756593", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   vec2 st = fragCoord.xy/iResolution.xy;\n    st.x *= iResolution.x/iResolution.y;\n\n    st.x -= 0.4;\n    \n    vec3 color = vec3(0.);\n\n    float f;\n    \n    st -=0.5;\n    float r = length(st)*1.;\n\n    \n    f = distance(vec2(0.), st.xy);\n    float d = f;\n    \n    \n    float a = atan(st.x, st.y)*3. + tan((d*5.+iTime));\n    f = sin(a) + f;\n    f = sin(a*2.) * cos(a*1.);\n    \n    \n    vec3 colA = vec3(st.x,st.y, st.x);\n\tvec3 colB = vec3(st.y,f,0.034);\n    \n    colA = vec3(0.);\n    //colB = vec3(1.);\n    vec3 gradient = mix(colA, colB, distance(vec2(0.), st.xy) * 3.);\n\n    color = vec3(1.-f * gradient);\n    if(color.r > 0.99){\n        color = 1. - gradient + .6;\n    }\n    \n    color.r = color.g = color.b;\n    color.rgb -= .5;\n    color.rgb = 1. - color;\n    \n    color /= .5;\n    \n    fragColor = vec4(color,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ll3cRN.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 877]], "test": "untested"}
{"id": "ll3cz4", "name": "pattern14072018", "author": "edapx", "description": "orchids, flowers, patterns", "tags": ["patterns", "flowers", "orchids"], "likes": 2, "viewed": 79, "published": "Public", "date": "1531749881", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#ifdef GL_ES\nprecision mediump float;\n#endif\n\n#define PI 3.14159265358979323846\n#define TWO_PI 6.28318530718\n\n// bool ops\nfloat merge(float d1, float d2){\n\treturn min(d1, d2);\n}\n\nfloat smoothMerge(float d1, float d2, float k){\n    float h = clamp(0.5 + 0.5*(d2 - d1)/k, 0.0, 1.0);\n    return mix(d2, d1, h) - k * h * (1.0-h);\n}\n\nfloat substract(float d1, float d2){\n\treturn max(-d1, d2);\n}\n\nfloat intersect(float d1, float d2){\n\treturn max(d1, d2);\n}\n\n\nfloat ellipseDist(vec2 p, float radius, vec2 dim){\n  vec2 pos = p;\n  pos.x = p.x / dim.x;\n  pos.y = p.y / dim.y;\n  return length(pos) - radius;\n}\n\nfloat circleDist(vec2 p, float radius){\n  return length(p) - radius;\n}\n\nmat2 rotate2dm(float _angle){\n    return mat2(cos(_angle),-sin(_angle),\n                sin(_angle),cos(_angle));\n}\n\n\nvec2 rotate2D (vec2 _st, float _angle) {\n    _st -= 0.5;\n    _st =  rotate2dm(_angle) * _st;\n    _st += 0.5;\n    return _st;\n}\n\nfloat when_eq(float x, float y) {\n  return 1.0 - abs(sign(x - y));\n}\n\nvec2 tile (vec2 _st, float _zoom) {\n    _st *= _zoom;\n    return fract(_st);\n}\n\nfloat orcSepals(vec2 toCenter, float resize, float defX, float defY,\nfloat grow, float nPetals, float smoothness){\n    float angle = atan(toCenter.y,toCenter.x) + 0.5;\n    float deformOnY = toCenter.y * defY;\n    float deformOnX = abs(toCenter.x) * defX;\n    float radius = length(toCenter)*resize * (grow+deformOnY+deformOnX);\n\n    float f = cos(angle*nPetals);\n    return smoothstep(f, f+smoothness,radius);\n}\n\nfloat lip(vec2 pos, vec2 oval, vec2 ovalSub,float radius, float offset){\n  float A = ellipseDist(pos, radius, oval);\n  vec2 posB = pos;\n  posB.y += offset;\n  float B = ellipseDist(posB, radius, ovalSub);\n  float p = smoothMerge(B, A, 0.5);\n  return p;\n}\n\nfloat orcColumn(vec2 pos, vec2 oval, vec2 ovalSub,float radius, float offset){\n  float A = ellipseDist(pos, radius, ovalSub);\n  vec2 posB = pos;\n  posB.y -= offset;\n  float B = ellipseDist(posB, radius, oval);\n  float p = substract(B,A);\n  posB.y += 0.035;\n  float cone = ellipseDist(posB, radius, vec2(0.055, 0.30));\n  p = smoothMerge(cone,p, 0.4);\n  float s = ellipseDist(posB, radius, vec2(0.2, 0.20));\n  return p;\n}\n\nvec2 rotateTilePattern(vec2 _st){\n    _st *= 2.0;\n    float index = 0.0;\n    index += step(1., mod(_st.x,2.0));\n    index += step(1., mod(_st.y,2.0))*2.0;\n    _st = fract(_st);\n    //  Rotate cell 1 by 90 degrees\n    float rad = PI*0.5 * when_eq(index, 1.);\n    _st = rotate2D(_st,rad);\n    //  Rotate cell 2 by -90 degrees\n    rad = PI*-0.5 * when_eq(index, 2.);\n    _st = rotate2D(_st,rad);\n    //  Rotate cell 3 by 180 degrees\n    rad = PI * when_eq(index, 3.);\n    _st = rotate2D(_st,rad);\n    return _st;\n}\n\nfloat flip(float v, float pct){\n  return mix(v, 1. - v, pct);\n}\n\nfloat rectSDF(vec2 pos, vec2 dim){\n  vec2 _st = pos*2. - 1.;\n  return max(abs(_st.x/dim.x),\n             abs(_st.y/dim.y));\n\n}\n\nfloat fillSmooth(float sdfVal, float size, float smoothness){\n  return smoothstep(size, size+smoothness,sdfVal);\n}\n\nfloat strokeSmoot(float x, float pos, float width, float smtness){\n  return smoothstep(pos, pos+smtness,x+ width*0.5) -\n         smoothstep(pos, pos+smtness,x- width*0.5);\n\n}\n\nfloat rand(vec2 uv){\n    return fract(sin(dot(uv, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n  // General parameters\n  float smoothness = 0.03;\n  vec3 olive = vec3(0.482, 0.5, 0.29);//1\n  vec3 green = vec3(0, 0.498, 0.352);\n  vec3 red = vec3(0.952, 0.227, 0.152);//5\n  vec3 orange = vec3(0.843, 0.615, 0.184);//3\n  vec3 yellow = vec3(0.956, 0.898, 0.247); //\n\n  // Tiling\n  vec2 st = fragCoord/iResolution.xy;\n  st.x *= iResolution.x / iResolution.y;\n  vec2 stBg = tile(st,3.0);\n  stBg = rotateTilePattern(stBg);\n  vec2 orcSt = tile(st,2.0);\n\n  stBg = rotate2D(stBg,-PI*iTime*0.15);\n\n  // Background\n  float sdf = rectSDF(stBg, vec2(.3,1.));\n  float rect = fillSmooth(sdf, 0.7, smoothness);\n  float diag = (stBg.x+stBg.y) * 0.5;\n  float diagLine = strokeSmoot(diag, 0.5, 0.02,smoothness);\n  float rectAndLine = flip(rect, diagLine);\n  vec3 bgCol = mix(green, olive, rectAndLine);\n\n  // Orchid parameters. The orchid is composed by sepals, petals, lip and column\n  orcSt+=vec2(-0.5, -0.5);\n  //column parameters\n  float colResize = 0.45;\n  vec2 posCol = orcSt;\n  posCol.y += 0.035;\n  float colYoffset = -0.051;\n  float powerCol = 2.;\n  vec2 colRatio = vec2(0.7*colResize, 0.7*colResize);\n  vec2 colSubRatio = vec2(0.9*colResize, 0.9*colResize);\n  float colRadius = 0.52*colResize;\n  // sepals parameters\n  float addSmoothnessToSetals = 2.9;\n  float deformX = 0.;\n  float deformY = 0.;\n  float resizePetals = 11.9;\n  float powerSepals = 2.0;\n  float nPetals = 3.;\n  float growSepals = exp2(length(orcSt)) * 0.19;\n  float nPetalsLat = 2.;\n  float deformXLat = 0.0;\n  float deformYLat = -0.0;\n  float resizePetalsLat = 21.9;\n  float powerLat = 2.3;\n  vec2 latPos = orcSt*rotate2dm(TWO_PI/2.4);\n  float growLaterals = pow(length(orcSt), powerLat);\n  // lip parameter\n  vec2 posLip = orcSt;\n  posLip.y += 0.18;\n  float lipResize = 0.6;\n  float lipYoffset = 0.05;\n  vec2 lipRatio = vec2(0.19*lipResize, 0.45*lipResize);\n  vec2 smallLipRatio = vec2(0.3*lipResize, 0.15*lipResize);\n  float lipRadius = 1.*lipResize;\n\n  float column = orcColumn(posCol*rotate2dm(TWO_PI/2.),\n                        colRatio,\n                        colSubRatio,\n                        colRadius, colYoffset);\n  float sepals = orcSepals(orcSt,\n                        resizePetals,\n                        deformX,\n                        deformY, growSepals, nPetals,\n                        smoothness+addSmoothnessToSetals);\n  float latPetals = orcSepals(latPos,\n                        resizePetalsLat,\n                        deformXLat,\n                        deformYLat, growLaterals, nPetalsLat,\n                        smoothness+addSmoothnessToSetals);\n  float lip = lip(posLip,\n                      lipRatio,\n                      smallLipRatio,\n                      lipRadius, lipYoffset);\n\n  float orchids = merge(latPetals, sepals);\n  orchids = merge(orchids, lip);\n  orchids = substract(column, orchids);\n  // this angle is using while creating the colors\n  float angle = atan(orcSt.y,orcSt.x) + 0.5;\n\n  // Sepals color:\n  sepals = fillSmooth(sepals,0.09,smoothness+0.005);\n  vec3 sepalsColor = mix(yellow, olive,rand(orcSt));\n  vec3 orcColor = mix(sepalsColor, bgCol, sepals);\n\n  // Lip color:\n  // 1) create the space coord for the points\n  vec2 lipSt = orcSt;\n  lipSt = fract(lipSt *= 20.);\n  lipSt -=vec2(0.5,0.5);\n  // 2 create the color pois\n  float points = circleDist(lipSt, 0.1);\n  points = smoothstep(points, points+0.05, 0.2);\n  vec3 colorPoints = mix(orange, olive, points);\n  // 3 mix the color with the orchid\n  lip = fillSmooth(lip,0.09,smoothness+0.005);\n  orcColor = mix(colorPoints, orcColor, lip);\n\n  // Petals color\n  latPetals = fillSmooth(latPetals,0.09,smoothness+0.005);\n  vec3 latPetalsColor = mix(yellow,red, sin(angle * 40.0));\n  latPetalsColor = mix(latPetalsColor, red, abs(orcSt.x)*2.7);\n  orcColor = mix(latPetalsColor,orcColor,latPetals);\n\n  //column color\n  column = fillSmooth(column,0.01,0.02);\n  vec3 columnColor = orange - red * (orcSt.y *2.);\n  orcColor = mix(columnColor, orcColor, column);\n\n  fragColor = vec4(vec3(orcColor),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ll3cz4.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[110, 122, 154, 154, 177], [179, 179, 226, 226, 327], [329, 329, 365, 365, 389], [391, 391, 427, 427, 450], [453, 453, 503, 503, 598], [600, 600, 639, 639, 670], [672, 672, 701, 701, 787], [790, 790, 830, 830, 916], [918, 918, 951, 951, 986], [988, 988, 1023, 1023, 1066], [1068, 1068, 1182, 1182, 1479], [1481, 1481, 1553, 1553, 1734], [1736, 1736, 1814, 1814, 2155], [2157, 2157, 2190, 2190, 2668], [2670, 2670, 2701, 2701, 2733], [2735, 2735, 2769, 2769, 2861], [2863, 2863, 2924, 2924, 2977], [2979, 2979, 3045, 3045, 3153], [3155, 3155, 3175, 3175, 3245], [3248, 3248, 3304, 3328, 7275]], "test": "untested"}
{"id": "ll3yRr", "name": "Palindrome startrails", "author": "zproxy", "description": "https://www.shadertoy.com/view/XsX3Dr\n", "tags": ["pyramid", "startrails"], "likes": 25, "viewed": 932, "published": "Public", "date": "1531246863", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// https://www.shadertoy.com/view/XsX3Dr\n\n#define kRaymarchMaxIter 226\n\n//#define LOW_QUALITY\n\n//#define OVERRIDE_TIME\n\nconst vec3 cSkyColourTop = vec3(0.2, 0.05, 0.15) * 0.5;\nconst vec3 cSkyColourHorizon = vec3(0.4, 0.1, 0.01) * 2.0;\nconst vec3 cSunScatteringColour = vec3(1.0, 0.01, 0.005) * 1.0;\n\nconst vec3 cFogColour = vec3(0.4, 0.05, 0.01) * 2.0;\n\nconst vec3 cSunColour = vec3(1.0, 0.01, 0.005) * 5.0;\nvec3 vSunDirection = normalize(vec3(-0.3, 0.2, -0.7));\n\nconst vec3 cSunLightColour = vec3(1.0, 0.15, 0.025) * 1.0;\nconst vec3 cAmbientLight = vec3(0.4, 0.1, 0.01) * 0.2;\n\nconst vec3 vPortalPos = vec3(0.0, 2.7, 20.0);\n\nconst float fSequenceLength = 18.0;\n\nmat3 g_mPortalRotation;\nfloat g_fTime = 0.0;\nfloat g_fSceneTime = 0.0;\nfloat g_ReverseEffectEnabled= 0.0;\n\nstruct C_Ray\n{\n    vec3 vOrigin;\n    vec3 vDir;\n    float fStartDistance;\n    float fLength;\n};\n\nstruct C_HitInfo\n{\n    vec3 vPos;\n    float fDistance;\n    float fObjectId;\n};\n    \nstruct C_Surface\n{\n    vec3 vNormal; \n};\n\nstruct C_Material\n{\n    vec3 cAlbedo;\n};\n\t\n/////////////////////////////////////\n// Distance Field CSG\n// These carry with them the material parameters in y\n\nvec2 DistCombineUnion( const in vec2 v1, const in vec2 v2 )\n{\n    //if(v1.x < v2.x) return v1; else return v2;\n    return mix(v1, v2, step(v2.x, v1.x));\n}\n\n/////////////////////////////////////\n// Scene Description \n\nfloat GetRayFirstStep( const in C_Ray ray )\n{\n\treturn ray.fStartDistance;\n}\n\nfloat hash( const in float n ) {\n\treturn fract(sin(n)*43758.5453);\n}\n\nfloat smoothnoise(const in float o) \n{\n\tfloat p = floor(o);\n\tfloat f = fract(o);\n\t\t\n\tfloat n = p;\n\n\tfloat a = hash(n+  0.0);\n\tfloat b = hash(n+  1.0);\n\t\n\tfloat f2 = f * f;\n\tfloat f3 = f2 * f;\n\t\n\tfloat t = 3.0 * f2 - 2.0 * f3;\n\t\n\treturn mix(a, b, t);\n}\n\nfloat smoothnoise(in vec2 o) \n{\n\tvec2 p = floor(o);\n\tvec2 f = fract(o);\n\t\t\n\tfloat n = p.x + p.y*57.0;\n\n\tfloat a = hash(n+  0.0);\n\tfloat b = hash(n+  1.0);\n\tfloat c = hash(n+ 57.0);\n\tfloat d = hash(n+ 58.0);\n\t\n\tvec2 f2 = f * f;\n\tvec2 f3 = f2 * f;\n\t\n\tvec2 t = 3.0 * f2 - 2.0 * f3;\n\tvec2 dt = 6.0 * f - 6.0 * f2;\n\t\n\tfloat u = t.x;\n\tfloat du = dt.x;\t\n\tfloat v = t.y;\n\tfloat dv = dt.y;\t\n\n\tfloat res = a + (b-a)*u +(c-a)*v + (a-b+d-c)*u*v;\n\t\n\t//float dx = (b-a)*du + (a-b+d-c)*du*v;\n\t//float dy = (c-a)*dv + (a-b+d-c)*u*dv;\n\t\n\treturn res;\n}\n\nfloat smoothnoise(const in vec3 o) \n{\n\tvec3 p = floor(o);\n\tvec3 fr = fract(o);\n\t\t\n\tfloat n = p.x + p.y*101.0 + p.z * 4001.0;\n\n\tfloat a = hash(n+   0.0);\n\tfloat b = hash(n+   1.0);\n\tfloat c = hash(n+ 101.0);\n\tfloat d = hash(n+ 102.0);\n\tfloat e = hash(n+4001.0);\n\tfloat f = hash(n+4002.0);\n\tfloat g = hash(n+4102.0);\n\tfloat h = hash(n+4103.0);\n\t\n\tvec3 fr2 = fr * fr;\n\tvec3 fr3 = fr2 * fr;\n\t\n\tvec3 t = 3.0 * fr2 - 2.0 * fr3;\n\t\t\n\treturn mix(\n\t\t\t    mix( mix(a,b, t.x),\n\t\t             mix(c,d, t.x), t.y),\n\t\t\t    mix( mix(e,f, t.x),\n\t\t             mix(g,h, t.x), t.y),\n\t\t\tt.z);\n}\n\nfloat GetDistanceGround( const in vec3 vPos )\n{\n\tfloat fResult = vPos.y;\n\t\n\tfloat h = smoothnoise(vPos.xz * 0.1);\t\t\n\tfloat fRidgePos = vPos.x + h * 10.0;\n\t\n\tfloat s = sin(fRidgePos);\n\ts *= sin(vPos.z * 0.1 + vPos.x * 0.2);\n\ts = s * 0.5 + 0.5;\t\n\ts = sqrt(s);\n\t\n\tvec2 vFlattenPos = abs(vPos.xz);\n\tfloat fFlattenDist = max(vFlattenPos.x, vFlattenPos.y);\n\tfloat fFlatten = smoothstep(50.0, 65.0, fFlattenDist);\n\tfResult += mix(0.0, s, fFlatten);\n\n\t#ifndef LOW_QUALITY\n\tfloat s2= sin(fRidgePos * 40.0);\n\ts2 = s2 * 0.5 + 0.5;\t\n\tfResult += s2 * s * 0.01;\n\t#endif\n\n\treturn fResult;\n}\n\nvec2 GetDistancePyramid(const in vec3 vPos, const in float fWorldNoise)\n{\n\tvec2 vResult;\n\tvResult.y = 2.0; // object id\n\n\tfloat fPyramidSize = 50.0;\n\t\n\tvec3 vStepPos = vPos;\n\tvStepPos.y -= fPyramidSize;\n\tvStepPos.xz = abs(vStepPos.xz) - 0.5;\n\tvec2 vStepOffset = floor((vStepPos.y - vStepPos.xz) * 0.5 + 0.5);\n\tfloat fStepOffset = min(vStepOffset.x, vStepOffset.y);\n\t\n\tvStepPos.x += fStepOffset;\t\n\tvStepPos.y -= fStepOffset;\n\tvStepPos.z += fStepOffset;\n\n\tvec3 vClosest = min(vStepPos.xyz, vec3(0.0));\t\n\t\n\tvResult.x = length(vStepPos - vClosest);\t\n\t\n\tfloat fFlatSide = (vPos.y + max(abs(vPos.x), abs(vPos.z))) - 50.0;\n\tvResult.x = mix(vResult.x, fFlatSide, 0.3);\n\t\t\n\tconst float fTunnelHeight = 4.0;\n\tconst float fTunnelWidth = 1.0;\n\tfloat fTunnelInner = min(min(fTunnelWidth - abs(vPos.x), fTunnelHeight - vPos.y), 35.0-vPos.z);\n\n\tconst float fTunnelThickness = 1.5;\n\tconst float fTunnelExtent = 2.0;\n\tfloat fTunnelOuter = max(abs(vPos.x) - (fTunnelWidth + fTunnelThickness), vPos.y - (fTunnelHeight + fTunnelThickness));\n\tfTunnelOuter = max(fTunnelOuter, vPos.y + abs(vPos.z + fTunnelExtent) - (fPyramidSize));\n\t\n\tvResult.x = min(vResult.x, fTunnelOuter);\n\tvResult.x = max(vResult.x, fTunnelInner);\n\t\n\tfloat fRoomWallDist = (vPos.y + max(abs(vPos.x), abs(vPos.z - 20.0)));\n\tfloat fInnerRoom = 20.0 - fRoomWallDist;\n\tvResult.x = max(vResult.x, fInnerRoom);\n\t\n\tvResult.x -= 0.1 - clamp(fWorldNoise, 0.0, 1.0) * 0.1;\t\n\t\n\treturn vResult;\n}\n\nvec2 GetDistancePyramids( const in vec3 vPos )\n{\n\t#ifdef LOW_QUALITY\n\tfloat fWorldNoise = 0.0;\n\t#else\n\tfloat fWorldNoise = smoothnoise(vPos * 2.0);\n\t#endif\n\t\t\n\tfloat fHeight = 0.0;\n\tvec3 vPyramidPos = vPos;\n\tif(vPyramidPos.x > 50.0)\n\t{\n\t\tvPyramidPos.x -= 100.0;\n\t\tvPyramidPos.z += 100.0;\n\t\tfHeight = 10.0;\n\t}\n\n\tif(vPyramidPos.x < -70.0)\n\t{\n\t\tvPyramidPos.x += 100.0;\n\t\tvPyramidPos.z += 200.0;\n\t\tfHeight = 20.0;\n\t}\n\t\n\tvPyramidPos.y = max(vPyramidPos.y + fHeight, fHeight);\n\t\n\tvec2 vPyramidDistance = GetDistancePyramid( vPyramidPos, fWorldNoise );\t\n\t\n\treturn vPyramidDistance;\n}\n\n// result is x=scene distance y=material or object id; zw are material specific parameters (maybe uv co-ordinates)\nvec2 GetDistanceScene( const in vec3 vPos, const in float fShadow )\n{          \n    vec2 vResult = vec2(10000.0, -1.0);\n    \n\tfloat fScale = 1.0;\n\tvec3 vPyramidPos = vPos;\n\tvec3 vSmallPyramidPos = vPyramidPos - vec3(0.0, 0.0, 20.0);\n\tvec3 vAbsPos = abs(vSmallPyramidPos);\t\n\tif( max(vAbsPos.x, vAbsPos.z) + vSmallPyramidPos.y < 15.0 )\n\t{\n\t\tvSmallPyramidPos.y -= 0.5;\n\t\tfScale = 30.0;\n\t\tvPyramidPos = vSmallPyramidPos * fScale;\n\t}\t\n\t\n\tvec2 vPyramidDistance = GetDistancePyramids( vPyramidPos );\t\n\tvPyramidDistance.x /= fScale;\n\t\n\tfloat fRoomWallDist = (vPos.y + max(abs(vPos.x), abs(vPos.z - 17.0)));\n\tfloat fPedistalDist = max(fRoomWallDist - 7.0, vPos.y - 0.5);\n\tvPyramidDistance.x = min(vPyramidDistance.x, fPedistalDist);\n\t\n\tvec2 vFloorDistance = vec2(GetDistanceGround( vPos ), 1.0);\n\tvResult = vFloorDistance;\n\n\tvResult = DistCombineUnion(vResult, vPyramidDistance);\n\t\n\tif(fShadow > 0.5)\n\t{\n\t\tvec2 vPortalDistance = vec2( (length(vPos - vPortalPos) - 0.1), 3.0);\n\t\tvResult = DistCombineUnion(vResult, vPortalDistance);\n\t}\n\t\n    return vResult;\n}\n\nC_Material GetObjectMaterial( const in C_HitInfo hitInfo )\n{\n    C_Material mat;  \n        \n\tmat.cAlbedo = vec3(0.8, 0.5, 0.3);\n\t\n\tif(hitInfo.fObjectId > 1.0)\n\t{\n    \tmat.cAlbedo = vec3(1.0, 0.8, 0.5);\n\t}\n\telse if(hitInfo.fObjectId > 2.0)\n\t{\n\t\tmat.cAlbedo = vec3(1.0, 1.0, 1.0);\n\t}\n\n    return mat;\n}\n\nvec3 GetSkyColour( const in vec3 vDir )\n{\n\n    float fBlend = clamp(vDir.y, 0.0, 1.0);\n\tfBlend = 1.0 - fBlend;\n\t\n\t\n    vec3 vResult =  mix(cSkyColourHorizon, cSkyColourTop, 1.0 - fBlend * fBlend * fBlend);\n\t\t\n\tfloat fSunDot = max(dot(vDir, vSunDirection), 0.0);\n\tvResult += (pow(fSunDot, 500.0) + fSunDot * fSunDot) * cSunScatteringColour;\n\t\n\tfloat fSun = clamp(5000.0 * (fSunDot - 0.999), 0.0, 1.0);\t\n\tvResult = vResult + cSunColour * fSun;\n\t\n\treturn vResult;\n}\n\n////////////////////////////////\n// Raymarching \n\nvec3 GetSceneNormal( const in vec3 vPos )\n{\n    // tetrahedron normal\n    const float fDelta = 0.025;\n\n    vec3 vOffset1 = vec3( fDelta, -fDelta, -fDelta);\n    vec3 vOffset2 = vec3(-fDelta, -fDelta,  fDelta);\n    vec3 vOffset3 = vec3(-fDelta,  fDelta, -fDelta);\n    vec3 vOffset4 = vec3( fDelta,  fDelta,  fDelta);\n\n    float f1 = GetDistanceScene( vPos + vOffset1, 1.0 ).x;\n    float f2 = GetDistanceScene( vPos + vOffset2, 1.0 ).x;\n    float f3 = GetDistanceScene( vPos + vOffset3, 1.0 ).x;\n    float f4 = GetDistanceScene( vPos + vOffset4, 1.0 ).x;\n\n    vec3 vNormal = vOffset1 * f1 + vOffset2 * f2 + vOffset3 * f3 + vOffset4 * f4;\n\n    return normalize( vNormal );\n}\n\n#define kRaymarchEpsilon 0.001\n\n// This is an excellent resource on ray marching -> http://www.iquilezles.org/www/articles/distfunctions/distfunctions.htm\nvoid Raymarch( const in C_Ray ray, out C_HitInfo result, const int maxIter, const in float fShadow )\n{        \n    result.fDistance = GetRayFirstStep( ray );\n    result.fObjectId = 0.0;\n        \n    for(int i=0;i<=kRaymarchMaxIter;i++)              \n    {\n        result.vPos = ray.vOrigin + ray.vDir * result.fDistance;\n        vec2 vSceneDist = GetDistanceScene( result.vPos, fShadow );\n        result.fObjectId = vSceneDist.y;\n        \n        // abs allows backward stepping - should only be necessary for non uniform distance functions\n        if((abs(vSceneDist.x) <= kRaymarchEpsilon) || (result.fDistance >= ray.fLength) || (i > maxIter))\n        {\n            break;\n        }                        \n\n        result.fDistance = result.fDistance + vSceneDist.x; \n    }\n\n\n    if(result.fDistance >= ray.fLength)\n    {\n        result.fDistance = 1000.0;\n        result.vPos = ray.vOrigin + ray.vDir * result.fDistance;\n        result.fObjectId = 0.0;\n    }\n}\n\nfloat calcAO( in vec3 pos, in vec3 nor )\n{\n\tfloat totao = 0.0;\n    float sca = 1.0;\n    for( int aoi=0; aoi<8; aoi++ )\n    {\n        float hr = 0.01 + 1.2*pow(float(aoi)/8.0,1.5);\n        vec3 aopos =  nor * hr + pos;\n        float dd = GetDistanceScene( aopos, 0.0 ).x;\n        totao += -(dd-hr)*sca;\n        sca *= 0.85;\n    }\n    return clamp( 1.0 - 1.0*totao, 0.0, 1.0 );\n}\n\n\n\nvec3 rotx(vec3 p, float a){\n    float s = sin(a), c = cos(a);\n    return vec3(p.x, c*p.y - s*p.z, s*p.y + c*p.z);\n}\n \n \n//From Dave_Hoskins (https://www.shadertoy.com/view/4djSRW)\nvec3 hash33(vec3 p)\n{\n    p = fract(p * vec3(443.8975,397.2973, 491.1871));\n    p += dot(p.zxy, p.yxz+19.27);\n    return fract(vec3(p.x * p.y, p.z*p.x, p.y*p.z));\n}\n\n//Very happy with this star function, cheap and smooth\nvec3 stars(in vec3 p)\n{\n    // 47fps\n    \n    vec3 c = vec3(0.);\n    float res = iResolution.x*0.25; // too small  and they will flicker\n    \n    // more stars?\n\tfor (float i=0.;i<4.;i++)\n    {\n        vec3 q = fract(p*(.15*res))-0.5;\n        vec3 id = floor(p*(.15*res));\n        vec2 rn = hash33(id).xy;\n        float c2 = 1.-smoothstep(0.,.6,length(q));\n        c2 *= step(rn.x,.0005+i*i*0.001);\n        c += c2*(mix(vec3(1.0,0.49,0.1),vec3(0.75,0.9,1.),rn.y)*0.25+0.75);\n        p *= 1.4;\n    }\n    return c*c*.7;\n}\n\nvec3 startrails(in vec3 rd)\n{\n    vec3 col0 = stars( normalize(rotx(rd, iTime * 0.5)));\n\n    vec3 col = col0;\n\n    for (int i = -120; i < 0; i++)\n    {\n    \tvec3 col1 = stars( normalize(rotx(rd, iTime * 0.5 + (float(i) * (1./600.) ))));\n        \n    \tcol += col1;    \n    }\n    \n    return col;\n}\n\n\nvec3 ShadeSurface(const in C_Ray ray, const in C_HitInfo hitInfo, const in C_Surface surface, const in C_Material material, float fInsideDist)\n{\n    vec3 cScene;\n    \n    vec3 vAmbientLight;\n\t\t\t\n\tvec3 vDiffuseLight = vec3(0.0);\n\n\tvec3 vToLight;\n\tvec3 cLightColour;\n\t\n\tfloat fPortalOn = smoothstep(9.0, 9.5, g_fTime);\n\t\n\tif(fInsideDist > 0.0)\n\t{\n\t\tvToLight = vSunDirection * 100.0;\n\t\tcLightColour = cSunLightColour;\n\t\tvAmbientLight = cAmbientLight;\n\t}\n\telse\n\t{\n\t\tvec3 vLightPos;\t\t\n\t\t\n\t\t// apply point light\n\t\t{\n\t\t\t\n\t\t\tif((hitInfo.vPos.z - hitInfo.vPos.y) < 0.01)\n\t\t\t{\n\t\t\t\tfloat fLightId = floor(min(max(hitInfo.vPos.z, -50.0), 0.0) * 0.1 + 0.5);\n\t\t\t\tvLightPos = vec3(0.5 * sign(hitInfo.vPos.x), 2.5, 10.0 * fLightId - 0.5);\t\t\n\t\t\t\t\n\t\t\t\tfloat fFlicker = (smoothnoise(fLightId + iTime * 500.0) * 0.5 + 0.5);\n\t\t\t\tcLightColour = vec3(1.0, 0.5, 0.1) * fFlicker * 0.01;\n\t\t\t\tvAmbientLight = cAmbientLight * 0.01;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tvLightPos = vPortalPos;\n\t\t\t\tvec3 vToLight = vLightPos - hitInfo.vPos;\n\t\t\t\t\n\t\t\t\t//cLightColour = textureLod(iChannel0, vToLight * g_mPortalRotation, 0.0).rgb;\n                //cLightColour = startrails(  vToLight * g_mPortalRotation ).rgb;\n                cLightColour = startrails(  vToLight  ).rgb;\n                \n\t\t\t\t//cLightColour = (1.0 - cLightColour*cLightColour)*  10.0 * vec3(0.0, 1.0, 0.0);\n                cLightColour = (  cLightColour*cLightColour)*  10.0 * vec3(0.0, 1.0, 0.0);\n                //cLightColour = 10.0 * vec3(0.0, 1.0, 0.0);\n\n\n\t\t\t\t//float fFft = smoothstep(0.7, 0.9, textureLod(iChannel3, vec2(0.018, 0.0), 0.0).r);\n\t\t\t\t//fFft = fFft * fFft;\n\t\t\t\t//cLightColour = vec3(1.0, 0.2, 0.1) * fFft + cLightColour * fPortalOn;\n                //cLightColour =  0.1*vec3(1.0, 0.2, 0.1) + cLightColour  ;\n                cLightColour =  0.1*vec3(0.0, 10.2, 0.0) + cLightColour  ;\n\t\t\t\t\n\t\t\t\tvAmbientLight = vec3(1.0, 0.2, 0.1) * 0.0001;\t\t\t\t\t\t\t\t\n\t\t\t}\t\t\t\t\t\n\t\t}\n\t\t\n\t\tvToLight = vLightPos - hitInfo.vPos;\n\t\tfloat fDist2 = dot(vToLight, vToLight);\n\t\tcLightColour /= fDist2;\n\t}\n\n\tC_Ray shadowRay;\n\tshadowRay.vOrigin = hitInfo.vPos;\n\tshadowRay.fLength = length(vToLight);\n\tshadowRay.vDir = normalize(vToLight);\n\tshadowRay.fStartDistance = dot(shadowRay.vDir, surface.vNormal);\n\tC_HitInfo shadowHitInfo;\n\tRaymarch(shadowRay, shadowHitInfo, 64, 0.0);\n\t\n\tfloat fShadow = 1.0;\n\tif(shadowHitInfo.fDistance < 90.0)\n\t{\n\t\tfShadow = 0.0;\n\t}\n\t\n\tvec3 vLightDir = normalize(vToLight);\n\tfloat fDiffuseLight = clamp(dot(surface.vNormal, vLightDir), 0.0, 1.0) * fShadow;\n\t\n\tvDiffuseLight += fDiffuseLight * cLightColour;\n\t\n\tfloat fAmbientOcclusion = calcAO(hitInfo.vPos, surface.vNormal);\n\t\n    vDiffuseLight += vAmbientLight * fAmbientOcclusion;\n              \n    vec3 vDiffuseReflection = vDiffuseLight * material.cAlbedo;              \n\n    cScene = vDiffuseReflection;\n    \n    return cScene;\n}\n\nvec3 GetSceneColour( const in C_Ray ray )\n{                                                          \n    C_HitInfo intersection;\n    Raymarch(ray, intersection, 256, 1.0);\n                \n    vec3 cScene;\n\n    if(intersection.fObjectId < 0.5)\n    {\n\t\tcScene = GetSkyColour(ray.vDir);\n    }\n    else\n    {\n        C_Surface surface;\n        \n        surface.vNormal = GetSceneNormal(intersection.vPos);\n\n\t\tif(intersection.fObjectId > 2.5)\n\t\t{\n\t\t\t// flip portal light source surface\n\t\t\tsurface.vNormal = -surface.vNormal;\n\t\t}\n\n        C_Material material = GetObjectMaterial(intersection);\n\n\t\tvec3 vAbsPos = abs(intersection.vPos);\n\t\tfloat fInsideDist = (max(vAbsPos.x, vAbsPos.z) + vAbsPos.y) - 46.0;\n\n        // apply lighting\n        cScene = ShadeSurface(ray, intersection, surface, material, fInsideDist);\t\t\t\t\t\n\t\t\n\t\tif( fInsideDist > 0.0 )\n\t\t{\n\t\t\t// apply fog\t\n\t\t\tfloat fNoise = smoothnoise((intersection.vPos.xz) * 0.1 + g_fSceneTime * 10.0);\n\t\t\tfloat fDensity= 0.04;\n\t\t\tfloat fHeightFalloff = 0.5;\n\t\t\t\n\t\t\tfloat fogAmount = fDensity * exp(-ray.vOrigin.y*fHeightFalloff) * (1.0-exp(-intersection.fDistance*ray.vDir.y*fHeightFalloff ))/ray.vDir.y;\n\t\t\tfogAmount *= (0.5 + fNoise * 0.5);\n\t\t\tcScene = mix(cScene, cFogColour, fogAmount);\n\t\t}\n    }\n\t\n    return cScene;\n}\n\nfloat kFarClip = 1000.0;\n\nvoid GetCameraRay( const in vec3 vPos, const in vec3 vForwards, const in vec3 vWorldUp, in vec2 fragCoord, out C_Ray ray)\n{\n    vec2 vUV = ( fragCoord.xy / iResolution.xy );\n    vec2 vViewCoord = vUV * 2.0 - 1.0;\n\t\n    float fRatio = iResolution.x / iResolution.y;\n    vViewCoord.y /= fRatio;                          \n\n\tvViewCoord *= 0.75;\n\t\n    ray.vOrigin = vPos;\n\t\n    vec3 vRight = normalize(cross(vForwards, vWorldUp));\n    vec3 vUp = cross(vRight, vForwards);\n        \n    ray.vDir = normalize( vRight * vViewCoord.x + vUp * vViewCoord.y + vForwards); \n    ray.fStartDistance = 0.0;\n    ray.fLength = kFarClip;      \n}\n\nvoid GetCameraRayLookat( const in vec3 vPos, const in vec3 vInterest, in vec2 fragCoord, out C_Ray ray)\n{\n    vec3 vForwards = normalize(vInterest - vPos);\n    vec3 vUp = vec3(0.0, 1.0, 0.0);\n\n    GetCameraRay(vPos, vForwards, vUp, fragCoord, ray);\t\n}\n\n\nvoid GetCameraPosAndTarget( float fCameraIndex, out vec3 vCameraPos, out vec3 vCameraTarget )\n{\n\tfloat fCameraCount = 14.0;\n\tfloat fCameraIndexModCount = max(min(fCameraIndex, fCameraCount), 0.0);\n\n    \t\tvCameraPos = vec3(10.0 + cos(iTime*0.1) * 2.0, 6.0, sin(iTime*0.1)*2.0 + 30.0);\n\t\tvCameraTarget = vec3(0.0, 1.0, 20.0);\n    return;\n    \n\tif(fCameraIndexModCount < 0.5)\n\t{\n\t\tvCameraPos = vec3(2000.0, 3.0, 500.0);\n\t\tvCameraTarget = vCameraPos + vec3(-10.0, -3.0, -10.0);\n\t}\n\telse if(fCameraIndexModCount < 1.5)\n\t{\n\t\tvCameraPos = vec3(2000.0, 4.0, 500.0);\n\t\tvCameraTarget = vCameraPos + vec3(-10.0, -3.0, -10.0);\n\t}\n\telse if(fCameraIndexModCount < 2.5)\n\t{\n\t\tvCameraPos = vec3(2000.0, 3.0, 500.0);\n\t\tvCameraTarget = vCameraPos + vec3(15.0, -4.0, -10.0);\n\t}\n\telse if(fCameraIndexModCount < 3.5)\n\t{\n\t\tvCameraPos = vec3(2000.0, 20.0, 500.0);\n\t\tvCameraTarget = vCameraPos + vec3(15.0, -8.0, -10.0);\n\t}\n\telse if(fCameraIndexModCount < 4.5)\n\t{\n\t\tvCameraPos = vec3(500.0, 20.0, 500.0);\n\t\tvCameraTarget = vCameraPos + vec3(15.0, -3.0, -10.0);\n\t}\n\telse if(fCameraIndexModCount < 5.5)\n\t{\n\t\tvCameraPos = vec3(500.0, 3.0, 500.0) + vec3(100.0, 0.0, 0.0);\n\t\tvCameraTarget = vCameraPos + vec3(10.0, -3.0, -10.0);\n\t}\n\telse if(fCameraIndexModCount < 6.5)\n\t{\n\t\tvCameraPos = vec3(500.0, 5.0, 500.0) + vec3(100.0, 0.0, 0.0);\n\t\tvCameraTarget = vec3(0.0, 10.0, 0.0);\n\t}\n\telse if(fCameraIndexModCount < 7.5)\n\t{\n\t\tvCameraPos = vec3(-30.0, 20.0, -200.0);\n\t\tvCameraTarget = vec3(0.0, 10.0, 0.0);\n\t}\n\telse if(fCameraIndexModCount < 8.5)\n\t{\n\t\tvCameraPos = vec3(0.0, 5.0, -100.0);\n\t\tvCameraTarget = vec3(0.0, 0.0, 0.0);\n\t}\n\telse if(fCameraIndexModCount < 9.5)\n\t{\n\t\tvCameraPos = vec3(0.0, 1.0, 5.0);\n\t\tvCameraTarget = vec3(0.0, 1.0, 20.0);\n\t}\n\telse if(fCameraIndexModCount < 10.5)\n\t{\n\t\tvCameraPos = vec3(0.0, 2.0, 5.0);\n\t\tvCameraTarget = vec3(0.0, 1.0, 20.0);\n\t}\n\telse if(fCameraIndexModCount < 11.5)\n\t{\n\t\tvCameraPos = vec3(10.0, 5.0, 30.0);\n\t\tvCameraTarget = vec3(0.0, 1.0, 20.0);\n\t}\n\telse if(fCameraIndexModCount < 12.5)\n\t{\n\t\tvCameraPos = vec3(10.0, 6.0, 30.0);\n\t\tvCameraTarget = vec3(0.0, 1.0, 20.0);\n\t}\n\telse if(fCameraIndexModCount < 13.5)\n\t{\n\t\tvCameraPos = vec3(0.0, 6.0, 20.0);\n\t\tvCameraTarget = vec3(0.0, -1.0, 19.0);\n\t}\n\telse\n\t{\n\t\tvCameraPos = vec3(0.0, 2.0, 20.0);\n\t\tvCameraTarget = vec3(0.0, -10.0, 19.0);\n\t}\n}\n\nvec3 BSpline( const in vec3 a, const in vec3 b, const in vec3 c, const in vec3 d, const in float t)\n{\n\tconst mat4 mSplineBasis = mat4( -1.0,  3.0, -3.0, 1.0,\n\t\t\t\t\t\t\t         3.0, -6.0,  0.0, 4.0,\n\t\t\t\t\t\t\t        -3.0,  3.0,  3.0, 1.0,\n\t\t\t\t\t\t\t         1.0,  0.0,  0.0, 0.0) / 6.0;\t\n\t\n\tfloat t2 = t * t;\n\tvec4 T = vec4(t2 * t, t2, t, 1.0);\n\t\t\n\tvec4 vWeights = T * mSplineBasis;\n\t\n\tvec3 vResult;\n\n\tvec4 vCoeffsX = vec4(a.x, b.x, c.x, d.x);\n\tvec4 vCoeffsY = vec4(a.y, b.y, c.y, d.y);\n\tvec4 vCoeffsZ = vec4(a.z, b.z, c.z, d.z);\n\t\n\tvResult.x = dot(vWeights, vCoeffsX);\n\tvResult.y = dot(vWeights, vCoeffsY);\n\tvResult.z = dot(vWeights, vCoeffsZ);\n\t\n\treturn vResult;\n}\n\nvoid GetCamera(out vec3 vCameraPos, out vec3 vCameraTarget)\n{\n\tfloat fCameraGlobalTime = g_fSceneTime;\t\t\n\t\n\tfloat fCameraTime = fract(fCameraGlobalTime);\n\tfloat fCameraIndex = floor(fCameraGlobalTime);\n\t\n\tvec3 vCameraPosA;\n\tvec3 vCameraTargetA;\n\tGetCameraPosAndTarget(fCameraIndex, vCameraPosA, vCameraTargetA);\n\t\n\tvec3 vCameraPosB;\n\tvec3 vCameraTargetB;\n\tGetCameraPosAndTarget(fCameraIndex + 1.0, vCameraPosB, vCameraTargetB);\n\t\n\tvec3 vCameraPosC;\n\tvec3 vCameraTargetC;\n\tGetCameraPosAndTarget(fCameraIndex + 2.0, vCameraPosC, vCameraTargetC);\n\t\n\tvec3 vCameraPosD;\n\tvec3 vCameraTargetD;\n\tGetCameraPosAndTarget(fCameraIndex + 3.0, vCameraPosD, vCameraTargetD);\n\t\n\tvCameraPos = BSpline(vCameraPosA, vCameraPosB, vCameraPosC, vCameraPosD, fCameraTime);\n\tvCameraTarget = BSpline(vCameraTargetA, vCameraTargetB, vCameraTargetC, vCameraTargetD, fCameraTime);\n}\n\n\nvec3 Tonemap( const in vec3 cCol )\n{\n    return sqrt(1.0 - exp(-cCol));\n}\n\nfloat GetTime()\n{\n//\tfloat fTime = iChannelTime[3] / 8.0;\n\tfloat fTime = iTime / 8.0;\n\n    #ifdef OVERRIDE_TIME\n\tfTime = iMouse.x * fSequenceLength / iResolution.x;\n\t#endif\n\t\n\t// hack the preview image\n\tif(iTime == 10.0)\n\t{\n\t\tfTime = 30.0 / 8.0;\n\t}\n\t\n\treturn mod(fTime, fSequenceLength);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 vUV = (fragCoord.xy / iResolution.xy) * 2.0 - 1.0;\n\n\tg_fTime = GetTime();\n\n\t// (noisy) motion blur by dithering time per pixel!\n\t//g_fTime += (texture(iChannel1, (fragCoord.xy / 64.0) + 0.5).r - 0.5) * 0.005;\t\n\t\n\tfloat fTimeWarp = 0.0;\n\t\n\tg_ReverseEffectEnabled = smoothstep(13.0, 14.0, g_fTime);\n\t\n\t// During the reverse sequence time is further backward at the edge of the screen\n\tg_fSceneTime = g_fTime;\n\tif(g_fSceneTime > 13.0)\n\t{\n\t\tfloat t = (g_fSceneTime - 13.0);\n\t\t\n\t\tfloat l = length(vUV);\n\t\tfTimeWarp = l * l * g_ReverseEffectEnabled;\n\t\tt += fTimeWarp * 0.2;\n\t\t\n\t\tg_fSceneTime = 13.0 - t * t;\n\n\t}\t\n\n\tg_fSceneTime = max(g_fSceneTime, 0.0);\n\t\n\tfloat a = (g_fSceneTime - 8.0);\n\ta = a * a * a;\n\tg_mPortalRotation = mat3(sin(a), 0.0, cos(a), \n\t\t\t\t\t  0.0, 1.0, 0.0,\n\t\t\t\t\t  cos(a), 0.0, -sin(a));\n \n    vec3 vCameraPos;\n    vec3 vCameraInterest;\n\tGetCamera(vCameraPos, vCameraInterest);\n\t\n\tC_Ray ray;\n    GetCameraRayLookat( vCameraPos, vCameraInterest, fragCoord, ray);\n\n    vec3 cScene = GetSceneColour( ray );  \n    \n\tfloat fExposure = 1.5;    \n\t\n\tfExposure = mix(fExposure, 0.3, smoothstep(3.45, 3.6, g_fTime));\n\tfExposure = mix(fExposure, 1.0, smoothstep(5.35, 5.5, g_fTime));\n\tfExposure = mix(fExposure, 20.0, smoothstep(7.6, 7.8, g_fTime));\n\n\tfExposure = mix(fExposure, 1.5, smoothstep(15.0, 17.0, g_fTime));\n\t\n\t// vignette\n\tfloat fDist = dot(vUV, vUV);\n\tfDist = fDist * fDist;\n\tfloat fAmount = 1.0 / (fDist + 1.0);\n\t//cScene = cScene * fAmount;\t\n\t\n\tvec3 cColour = Tonemap(cScene * fExposure);\n\n    fragColor = vec4(cColour, 1.0 );\n}\n\nvoid mainVR( out vec4 fragColor, in vec2 fragCoord, in vec3 fragRayOri, in vec3 fragRayDir )\n{\n\tvec2 vUV = (fragCoord.xy / iResolution.xy) * 2.0 - 1.0;\n\n\tg_fTime = GetTime();\n\n\t// (noisy) motion blur by dithering time per pixel!\n\t\n    //g_fTime += (texture(iChannel1, (fragCoord.xy / 64.0) + 0.5).r - 0.5) * 0.005;\t\n\t\n\tfloat fTimeWarp = 0.0;\n\t\n\tg_ReverseEffectEnabled = smoothstep(13.0, 14.0, g_fTime);\n\t\n\t// During the reverse sequence time is further backward at the edge of the screen\n\tg_fSceneTime = g_fTime;\n\tif(g_fSceneTime > 13.0)\n\t{\n\t\tfloat t = (g_fSceneTime - 13.0);\n\t\t\n\t\tfloat l = length(vUV);\n\t\tfTimeWarp = l * l * g_ReverseEffectEnabled;\n\t\tt += fTimeWarp * 0.2;\n\t\t\n\t\tg_fSceneTime = 13.0 - t * t;\n\n\t}\t\n\n\tg_fSceneTime = max(g_fSceneTime, 0.0);\n\t\n\tfloat a = (g_fSceneTime - 8.0);\n\ta = a * a * a;\n\tg_mPortalRotation = mat3(sin(a), 0.0, cos(a), \n\t\t\t\t\t  0.0, 1.0, 0.0,\n\t\t\t\t\t  cos(a), 0.0, -sin(a));\n \n    vec3 vCameraPos;\n    vec3 vCameraInterest;\n\tGetCamera(vCameraPos, vCameraInterest);\n\t\n    fragRayOri += vCameraPos;\n    \n\tC_Ray ray;\n    ray.vOrigin = fragRayOri;\n    ray.vDir = fragRayDir;\n    ray.fStartDistance = 0.0;\n    ray.fLength = kFarClip;\n    //GetCameraRayLookat( vCameraPos, vCameraInterest, fragCoord, ray);\n\n    vec3 cScene = GetSceneColour( ray );  \n    \n\tfloat fExposure = 1.5;    \n\t\n\tvec3 cColour = Tonemap(cScene * fExposure);\n\n    fragColor = vec4(cColour, 1.0 );    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ll3yRr.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1036, 1151, 1212, 1261, 1305], [1307, 1368, 1413, 1413, 1443], [1445, 1445, 1477, 1477, 1513], [1515, 1515, 1553, 1553, 1766], [1768, 1768, 1799, 1799, 2302], [2304, 2304, 2341, 2341, 2878], [2880, 2880, 2927, 2927, 3455], [3457, 3457, 3530, 3530, 4892], [4894, 4894, 4942, 4942, 5470], [5472, 5587, 5656, 5656, 6636], [6638, 6638, 6698, 6698, 6938], [6940, 6940, 6981, 6981, 7402], [7404, 7454, 7497, 7523, 8124], [8158, 8281, 8383, 8383, 9246], [9248, 9248, 9290, 9290, 9625], [9629, 9629, 9656, 9656, 9744], [9749, 9809, 9830, 9830, 9973], [9975, 10030, 10053, 10066, 10549], [10551, 10551, 10580, 10580, 10847], [10850, 10850, 10994, 10994, 13670], [13672, 13672, 13715, 13715, 14942], [14970, 14970, 15093, 15093, 15595], [15597, 15597, 15702, 15702, 15848], [15851, 15851, 15946, 15946, 18143], [18145, 18145, 18246, 18246, 18803], [18805, 18805, 18866, 18866, 19659], [19662, 19662, 19698, 19698, 19735], [19737, 19737, 19754, 19794, 20026], [20028, 20028, 20085, 20085, 21634], [21636, 21636, 21730, 21730, 23034]], "test": "untested"}
{"id": "ll3yz7", "name": "syltefar-noise-simplex-3d", "author": "syltefar", "description": "Left: 3D Simplex noise\nRight: Same noise, sampled in 2 octaves", "tags": ["noise", "simplexnoise"], "likes": 4, "viewed": 191, "published": "Public", "date": "1532347694", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// 3D Simplex noise\n// - Based on https://github.com/ashima/webgl-noise/blob/master/src/noise3D.glsl\n// - See also https://www.shadertoy.com/view/4dBcWy\n\n#ifdef GL_ES\nprecision mediump float;\n#endif\n\nuniform vec2 u_resolution;\nuniform vec2 u_mouse;\nuniform float u_time;\n\nvec3 mod289(vec3 x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 mod289(vec4 x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 permute(vec4 x) {\n     return mod289(((x*34.0)+1.0)*x);\n}\n\n// Obsolete, replaced by inversesqrt\n// vec4 taylorInvSqrt(vec4 r)\n// {\n//   return 1.79284291400159 - 0.85373472095314 * r;\n// }\n\nfloat snoise(vec3 v)\n  { \n  const vec2  C = vec2(0.1666666666666667, 0.3333333333333333) ; // 1.0/6.0, 1.0/3.0\n  const vec4  D = vec4(0.0, 0.5, 1.0, 2.0);\n\n// First corner\n  vec3 i  = floor(v + dot(v, C.yyy) );\n  vec3 x0 =   v - i + dot(i, C.xxx) ;\n\n// Other corners\n  vec3 g = step(x0.yzx, x0.xyz);\n  vec3 l = 1.0 - g;\n  vec3 i1 = min( g.xyz, l.zxy );\n  vec3 i2 = max( g.xyz, l.zxy );\n\n  vec3 x1 = x0 - i1 + C.xxx;\n  vec3 x2 = x0 - i2 + C.yyy; // 2.0*C.x = 1/3 = C.y\n  vec3 x3 = x0 - D.yyy;      // -1.0+3.0*C.x = -0.5 = -D.y\n\n// Permutations\n  i = mod289(i); \n  vec4 p = permute( permute( permute( \n             i.z + vec4(0.0, i1.z, i2.z, 1.0 ))\n           + i.y + vec4(0.0, i1.y, i2.y, 1.0 )) \n           + i.x + vec4(0.0, i1.x, i2.x, 1.0 ));\n\n// Gradients: 7x7 points over a square, mapped onto an octahedron.\n// The ring size 17*17 = 289 is close to a multiple of 49 (49*6 = 294)\n  float n_ = 0.142857142857; // 1.0/7.0\n  vec3  ns = n_ * D.wyz - D.xzx;\n\n  vec4 j = p - 49.0 * floor(p * ns.z * ns.z);  //  mod(p,7*7)\n\n  vec4 x_ = floor(j * ns.z);\n  vec4 y_ = floor(j - 7.0 * x_ );    // mod(j,N)\n\n  vec4 x = x_ *ns.x + ns.yyyy;\n  vec4 y = y_ *ns.x + ns.yyyy;\n  vec4 h = 1.0 - abs(x) - abs(y);\n\n  vec4 b0 = vec4( x.xy, y.xy );\n  vec4 b1 = vec4( x.zw, y.zw );\n\n  //vec4 s0 = vec4(lessThan(b0,0.0))*2.0 - 1.0;\n  //vec4 s1 = vec4(lessThan(b1,0.0))*2.0 - 1.0;\n  vec4 s0 = floor(b0)*2.0 + 1.0;\n  vec4 s1 = floor(b1)*2.0 + 1.0;\n  vec4 sh = -step(h, vec4(0.0));\n\n  vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy ;\n  vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww ;\n\n  vec3 p0 = vec3(a0.xy,h.x);\n  vec3 p1 = vec3(a0.zw,h.y);\n  vec3 p2 = vec3(a1.xy,h.z);\n  vec3 p3 = vec3(a1.zw,h.w);\n\n//Normalise gradients\n  //vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));\n  vec4 norm = inversesqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));\n  p0 *= norm.x;\n  p1 *= norm.y;\n  p2 *= norm.z;\n  p3 *= norm.w;\n\n// Mix final noise value\n  vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n  m = m * m;\n  return 42.0 * dot( m*m, vec4( dot(p0,x0), dot(p1,x1), \n                                dot(p2,x2), dot(p3,x3) ) );\n  }\n\n// Original code ends here.\n\n\nfloat getnoise(int octaves, float persistence, float freq, vec3 coords) {\n\n    float amp= 1.; \n    float maxamp = 0.;\n    float sum = 0.;\n\n    for (int i=0; i < octaves; ++i) {\n\n        sum += amp * snoise(coords*freq); \n        freq *= 2.;\n        maxamp += amp;\n        amp *= persistence;\n    }\n    \n    return (sum / maxamp) * .5 + .5;\n}\n\n\n// Salt is added to limit the x,y values. No matter what you input,\n// it returns a float around ~ 0-6000.\n// I don't claim it to be undredictable, fast and uniform. \n// Feel free to adjust.\nfloat salt(float seed) {\n    float a = mod(seed, 5901.);\n    float b = mod(a,2.)==0. ? -0.01 : 0.11; \n\treturn a+4179./sqrt(a*5.)*b+1001.*a/seed;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    const float speed = 0.003;\n    \n    float seed = salt(11111.); // type any float here as a seed.\n    vec2 uv = fragCoord/iResolution.yy;\n\n    vec2 p = uv;\n    vec3 p3 = vec3(p, float(iFrame)*speed);\n\n    float col;\n    vec3 pos = vec3(uv.x*8.0, uv.y*8.0, iTime);\n    if(fragCoord.x < iResolution.x * 0.499)\n    {\n        col = snoise(pos);\n    }\n    if(fragCoord.x > iResolution.x * 0.501)\n    {\n        col = getnoise(2, 1.0f, 1.0f, pos);\n    }\n   \n\n    fragColor = vec4(col, col, col, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ll3yz7.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 272, 293, 293, 342], [344, 344, 365, 365, 414], [416, 416, 438, 438, 478], [480, 611, 635, 635, 2763], [2765, 2795, 2868, 2868, 3136], [3139, 3330, 3354, 3354, 3476], [3479, 3479, 3536, 3536, 4035]], "test": "untested"}
{"id": "llccW4", "name": "Voronoise - Better", "author": "Auburn", "description": "Modied from this, https://www.shadertoy.com/view/Xd23Dh", "tags": ["noise"], "likes": 6, "viewed": 419, "published": "Public API", "date": "1532608557", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Created by inigo quilez - iq/2014\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n// Made more readable and understandable by Manuel Riecke/API_Beast\n\nvec2 rand2(vec2 p)\n{\n\tvec2 q = vec2(dot(p,vec2(127.1,311.7)), \n\t\tdot(p,vec2(269.5,183.3)));\n\treturn fract(sin(q)*43758.5453);\n}\n\nfloat rand(vec2 p)\n{\n\treturn fract(sin(dot(p,vec2(419.2,371.9))) * 833458.57832);\n}\n\nfloat iqnoise(in vec2 pos, float irregular, float smoothness)\n{\n\tvec2 cell = floor(pos);\n\tvec2 cellOffset = fract(pos);\n\n\tfloat sharpness = 1.0 + 63.0 * pow(1.0-smoothness, 4.0);\n\t\n\tfloat value = 0.0;\n\tfloat accum = 0.0;\n\t// Sample the surrounding cells, from -2 to +2\n\t// This is necessary for the smoothing as well as the irregular grid.\n\tfor(int x=-3; x<=3; x++ )\n\tfor(int y=-3; y<=3; y++ )\n\t{\n\t\tvec2 samplePos = vec2(float(y), float(x));\n\n  \t\t// Center of the cell is not at the center of the block for irregular noise.\n  \t\t// Note that all the coordinates are in \"block\"-space, 0 is the current block, 1 is one block further, etc\n\t\tvec2 center = (rand2(cell + samplePos) - vec2(0.5,0.5)) * irregular * 2.0;\n\t\tfloat centerDistance = length(samplePos - cellOffset + center);\n\n\t\t// High sharpness = Only extreme values = Hard borders = 64\n\t\t// Low sharpness = No extreme values = Soft borders = 1\n\t\tfloat samp = pow(1.0 - smoothstep(0.0, 1.414, centerDistance), sharpness);\n\n\t\t// A different \"color\" (shade of gray) for each cell\n\t\tfloat color = rand(cell + samplePos);\n\t\tvalue += color * samp;\n\t\taccum += samp;\n\t}\n\n\treturn value/accum;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xx;\n\n\tvec2 p = 0.5 - 0.5*sin( iTime*vec2(1.01,1.71) );\n\n\tif(iMouse.w > 0.001)\n        p = vec2(0.0,1.0) + vec2(1.0,-1.0)*iMouse.xy/iResolution.xy;\n\n\tp = p*p*(3.0-2.0*p);\n\tp = p*p*(3.0-2.0*p);\n    p = p*p*(3.0-2.0*p);\n\n\tfloat f = iqnoise( 24.0*uv, p.x, p.y );\n\n\tfragColor = vec4( f, f, f, 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/llccW4.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[0, 193, 213, 213, 320], [322, 322, 342, 342, 405], [407, 407, 470, 470, 1547], [1549, 1549, 1606, 1606, 1941]], "test": "untested"}
{"id": "llcyDH", "name": "hexagon energy", "author": "laserdog", "description": "trippy energy effect", "tags": ["hexagons"], "likes": 22, "viewed": 778, "published": "Public", "date": "1532404293", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define S(r,v,a) smoothstep(a/iResolution.y,0.,abs(v-(r)))\n\nconst vec2 s = vec2(1, 1.7320508); // 1.7320508 = sqrt(3)\n\nfloat calcHexDistance(vec2 p)\n{\n    p = abs(p);\n    return max(dot(p, s * .5), p.x);\n}\n\nvec2 calcHexOffset(vec2 uv)\n{\n    vec4 hexCenter = round(vec4(uv, uv - vec2(.5, 1.)) / s.xyxy);\n    vec4 offset = vec4(uv - hexCenter.xy * s, uv - (hexCenter.zw + .5) * s);\n    return dot(offset.xy, offset.xy) < dot(offset.zw, offset.zw) ? offset.xy : offset.zw;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (2. * fragCoord - iResolution.xy) / iResolution.y;\n\tvec2 hexInfo = calcHexOffset(uv * 3.);\n    \n    float a = cos(2. * (2. * length(uv) - iTime));\n\tfloat h = calcHexDistance(hexInfo);\n\n\tfragColor.g = S(abs(sin(h * a * 10.)), 1., 12.) + .3 * S(h, .45, 20.) + .15\n        + .3 * smoothstep(.25 + 12./iResolution.y, .25, h);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/llcyDH.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[95, 119, 150, 150, 205], [207, 207, 236, 236, 471], [473, 473, 530, 530, 868]], "test": "untested"}
{"id": "llcyDM", "name": "Background example", "author": "Txoka", "description": ":)", "tags": ["background"], "likes": 21, "viewed": 604, "published": "Public API", "date": "1532841691", "time_retrieved": "2021-10-01T00:00:00", "image_code": "highp float rand(vec2 co) {\n    return fract(sin(mod(dot(co.xy ,vec2(12.9898,78.233)),3.14))*43758.5453);\n}\nfloat tnoise(vec2 co){\n    vec2 w=co;\n    co.y+=co.x/2.;\n    const vec2 s=vec2(1.,0.);\n\tvec2 p=floor(co);\n    if(fract(co.x)<fract(co.y))p+=0.5;    \n  \treturn rand(p);\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    vec2 uv = (fragCoord*2.-iResolution.xy)/40.;\n    float n=tnoise(uv);\n    fragColor = vec4(sin(iTime*n*7.+n*3.141592653589793*2.)*0.5+0.5)*0.3+0.5;\n    fragColor+=sin((uv.x-uv.y)*30.)/2.;\n    fragColor+=rand(uv)/2.;\n    fragColor/=4.;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/llcyDM.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[108, 108, 130, 130, 277], [278, 278, 334, 334, 574]], "test": "untested"}
{"id": "llcyRH", "name": "moutain car  v2 ", "author": "asis5528", "description": "change the music :)...amplitude based on music pitch....", "tags": ["2d", "shapes", "car", "pitch"], "likes": 4, "viewed": 165, "published": "Public", "date": "1531489293", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define time iTime\nmat2 rotate2d(float _angle){\n    return mat2(cos(_angle),-sin(_angle),\n                sin(_angle),cos(_angle));\n}\n\nfloat circle(vec2 uv){\n    return smoothstep(0.1,0.09,length(uv))-smoothstep(0.09,0.08,length(uv));\n}\n\nfloat body(vec2 st,float pos){\n    float k;\n    vec2 uv = st;\n    st = vec2(st.x*1.7,st.y)-vec2(pos*1.7,0.6-sin(time*3.+(pos*3.)+0.5)*(0.1+texture(iChannel0,st).r/10.));\n    \n     if (st.x>0.25 && st.x <0.7){\n    k= smoothstep(0.5,0.48,st.y)-smoothstep(0.7,0.6,st.y); \n    }\n    \n    if (st.x>0.2 && st.x <0.8){\n  \n    k += smoothstep(0.4,0.38,st.y)-smoothstep(0.6,0.5,st.y);\n     \n    }\n   \n    return k;\n}\n\nvec4 tire(vec2 st,float pos){\n    vec2 lst = vec2(st.x*1.7,st.y)-vec2(pos*1.7,0.6-sin(time*3.+pos*3.)*(0.1+texture(iChannel0,st).r/10.));\n    float c = circle(lst);\n      \n   \n    float r = 0.08+0.03*cos(atan(lst.y,lst.x)*10.+time*43.);\n    float circle = smoothstep(r,r-0.05,length(lst));\n   \n    r = 0.05;\n    st.y+= -0.3;\n    float cl=circle;\n    return vec4(c)+vec4(cl)*vec4(1.,0.,0.,0.);\n\n    }\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 st = uv;\n    \n \n    uv.y+= sin(uv.x*3.+time*3.)*(0.1+texture(iChannel0,st).r/10.);\n       \n       \n    float col = 1.-smoothstep(0.5,0.52,uv.y);\n    vec3 terrain = vec3(0.1,col*0.7,0.1);\n    vec4 tir = tire(st,0.3);\n    tir += tire(st,0.5);\n    //tir += vec4(body(st+vec2(0.0,0.5),0.0))*vec4(0.2,1.3,0.3,1.);\n    vec3 back = vec3(0.0,0.0,1.)*texture(iChannel0,st).r;\n    fragColor = mix(vec4(terrain,1.)+tir,vec4(back,1.),1.-uv.y);\n     st -= vec2(0.3,0.6-0.29-sin(time*3.+(0.3*3.)+0.5)*0.1);\n   \n    st = rotate2d( (sin(time*3.+(0.3*3.)+0.5)*0.1)/3. ) * st;\n\n    st += vec2(0.3,0.60-.29-sin(time*3.+(0.3*3.)+0.5)*0.1);\n    \n    fragColor += vec4(body(st+vec2(0.0,0.29),0.1));\n    \n    }", "image_inputs": [{"id": "4df3Rn", "previewfilepath": "/media/ap/3c33c415862bb7964d256f4749408247da6596f2167dca2c86cc38f83c244aa6.mp3", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/3c33c415862bb7964d256f4749408247da6596f2167dca2c86cc38f83c244aa6.mp3", "ctype": "music"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/llcyRH.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[19, 19, 47, 47, 133], [135, 135, 157, 157, 236], [238, 238, 268, 268, 645], [647, 647, 676, 676, 1046], [1047, 1047, 1103, 1103, 1840]], "test": "untested"}
{"id": "lldcRn", "name": "flappy spaceship", "author": "mds2", "description": "Took a simple sdf raymarching experiment and bent the rays a little bit to make the shape melt and move", "tags": ["sdf", "warp", "twist"], "likes": 8, "viewed": 484, "published": "Public API", "date": "1531342803", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define MAX_DIST 40.0\n\n\nfloat s_min(in float x, in float y, in float s) {\n\n    float bridge =\n        clamp(abs(x-y)/s, 0.0, 1.0);\n    return min(x,y) - 0.25 * s * (bridge - 1.0) * (bridge - 1.0);\n}\n\nfloat s_max(in float x, in float y, in float s) {\n    float bridge =\n        clamp(abs(x-y)/s, 0.0, 1.0);\n    return max(x,y) + 0.25 * s * (bridge - 1.0) * (bridge - 1.0);\n}\n\nfloat cone_sdf(in vec3 loc) {\n    float cone_length = \n        abs(loc.x) + length(loc.yz);\n\tcone_length = 0.7 * (cone_length - 1.5);\n\n\treturn cone_length;\n}\n\nfloat cyl_sdf(in vec3 loc) {\n    float r = length(loc.yz) - 0.5;\n    float cap1 = loc.x - 0.5;\n    float cap2 = -0.75 - loc.x;\n    return s_max(cap1, s_max(cap2, r, 0.2), 0.2);\n}\n\nfloat inv_sphere(in vec3 loc, in vec3 cent, in float rad) {\n  return max(-rad, rad - length(cent - loc));\n}\n\nfloat vehicle_sdf(in vec3 loc) {\n    float c = cone_sdf(loc);\n    float p = -loc.y;\n    float b = -loc.x + 0.2;\n    float shell = s_max(c, b, 0.6);\n    float back = s_max(cyl_sdf(loc), p, 0.1);\n    shell = s_min(shell, back, 0.4);\n    shell = s_max(shell,  p, 0.2);\n    \n    vec3 eye1 = vec3(0.7, 0.3, 0.3);\n    vec3 eye2 = vec3(0.7, 0.3, -0.3);\n    \n    return shell \n        + 0.1 * smoothstep(0.2, 0.0, length(loc.zy - vec2(0.42, 0.0)))\n        + 0.1 * smoothstep(0.2, 0.0, length(loc.zy + vec2(0.42, 0.0)))\n        - 0.25 * smoothstep(0.41, 0.0, length(loc - eye1))\n        - 0.25 * smoothstep(0.41, 0.0, length(loc - eye2))\n        - 0.1 * smoothstep(0.2, -0.0, loc.y) * (1.0 + 0.2 * smoothstep(0.4, 0.6, abs(loc.z)));\n}\n\nvec3 perturb(in vec3 pt) {\n    return pt + 0.1 * sin(4.0 * pt.x + 8.0 * iTime) * vec3(0.0, 1.0, 0.0);\n}\n\n\nvec3 vehicle_sdf_grad(in vec3 loc) {\n    float dist = vehicle_sdf(perturb(loc));\n    const float del = 0.01;\n    return vec3(vehicle_sdf(perturb(loc + vec3(del, 0.0, 0.0))) - dist,\n                vehicle_sdf(perturb(loc + vec3(0.0, del, 0.0))) - dist,\n                vehicle_sdf(perturb(loc + vec3(0.0, 0.0, del))) - dist) / del;\n}\n\n\nfloat cast_to_vehicle(in vec3 orig, in vec3 dir) {\n    vec3 p = orig;\n    float accum = 0.0;\n    for (int i = 0; i < 256; ++i) {\n    \tfloat remaining = 0.7 * vehicle_sdf(p);\n        accum += remaining;\n        p = orig + accum * dir;\n        p = perturb(p);\n        if (remaining < 1.0e-3) {\n            return accum;\n        }\n    }\n\treturn max(accum, MAX_DIST + 1.0);\n}\n\nvec3 get_bounce(in vec3 pt, in vec3 dir) {\n    vec3 norm = normalize(vehicle_sdf_grad(pt));\n    return normalize(reflect(dir, norm));\n}\n\nvec4 castRay(in vec2 fragCoord) {\n\tvec2 uv = (2.0 * fragCoord.xy - iResolution.xy) / iResolution.y;\n    vec3 ray_orig = vec3(0.0, 0.5, -5.0);\n\tvec3 ray_dir = normalize(vec3(uv, 5.0));\n    \n    float wiggle = abs(mod(0.2 * iTime, 4.0) - 2.0) - 1.0;\n    wiggle = sign(wiggle) * smoothstep(0.0, 1.0, abs(wiggle));\n    float ct = sin(wiggle);\n    float st = cos(wiggle);\n    mat3 twist = mat3(ct, 0.0, st,\n                      0.0, 1.0, 0.0,\n                      -st, 0.0, ct);\n    ray_dir = twist * ray_dir;\n    ray_orig = twist * ray_orig;\n    \n    float d = cast_to_vehicle(ray_orig, ray_dir);\n    \n    if (d < MAX_DIST) {\n        vec3 pt = ray_orig + d * ray_dir;\n        ray_dir = get_bounce(pt, ray_dir);\n    }\n\n    return vec4(abs(0.5 + 0.5 * ray_dir), 1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n\tfragColor = castRay(fragCoord);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/lldcRn.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[24, 24, 73, 73, 198], [200, 200, 249, 249, 373], [375, 375, 404, 404, 532], [534, 534, 562, 562, 712], [714, 714, 773, 773, 821], [823, 823, 855, 855, 1548], [1550, 1550, 1576, 1576, 1653], [1656, 1656, 1692, 1692, 1989], [1992, 1992, 2042, 2042, 2363], [2365, 2365, 2407, 2407, 2500], [2502, 2502, 2535, 2535, 3267], [3269, 3269, 3326, 3326, 3366]], "test": "untested"}
{"id": "lldcRr", "name": "light shafts", "author": "greenbird10", "description": "simulate sun shafts in sea", "tags": ["light"], "likes": 3, "viewed": 356, "published": "Public", "date": "1531382408", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//by greenbird\n#define S(a, b, c) smoothstep(a,b,c)\n\nfloat random (in vec2 st) {\n    return fract(sin(dot(st.xy,\n                         vec2(12.9898,78.233)))*\n        43758.5453123);\n}\nvec2 random2(vec2 st){\n    st = vec2( dot(st,vec2(127.1,311.7)),\n              dot(st,vec2(269.5,183.3)) );\n    return -1.0 + 2.0*fract(sin(st)*43758.5453123);\n}\n\n// Value Noise by Inigo Quilez - iq/2013\n// https://www.shadertoy.com/view/lsf3WH\nfloat noise(vec2 st) {\n\tvec2 i = floor(st);\n\tvec2 f = fract(st);\n\tvec2 u = f*f*(3.0-2.0*f);\n\treturn mix( \n        mix( dot( random2(i + vec2(0.0,0.0) ), f - vec2(0.0,0.0) ),\n             dot( random2(i + vec2(1.0,0.0) ), f - vec2(1.0,0.0) ), u.x),\n        mix( dot( random2(i + vec2(0.0,1.0) ), f - vec2(0.0,1.0) ),\n             dot( random2(i + vec2(1.0,1.0) ), f - vec2(1.0,1.0) ), u.x), u.y);\n}\n\nfloat fbm(vec2 n) {\n\tfloat total = 0.0, amplitude = 1.0;\n\tfor (int i = 0; i < 5; i++) \n\t{\n\t\ttotal += noise(n) * amplitude; \n\t\tn += n;\n\t\tamplitude *= 0.5; \n\t}\n\treturn total;\n} \n\nfloat dis(vec2 a){\n\treturn sqrt(a.x * a.x + a.y * a.y);\n}\n\n#define AA 5.0\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 st = fragCoord.xy/iResolution.xy;\n\tst -= 0.5;\n\tst.x *= iResolution.x/iResolution.y;\n    vec2 _st = st;\n    float angle = 0.18;\n    st = vec2(st.x * cos(angle) - st.y * sin(angle), \n              st.x * sin(angle) + st.y * cos(angle));\n\n\t\n    float u_time = iTime;    \n\t\n\tvec3 shaft;\n    float mask = 0.;\n    for(float i = 0.; i < AA; ++i) {\n    \tmask += 1./AA * fbm(vec2(st.x*2. + i/AA + u_time/40., st.y/8.));\n        mask += 1./AA * fbm(vec2(st.x*2. - 1000. - i/AA - u_time/40., st.y/4.));\n    }\n    mask *= _st.y + 0.5;\n    mask = pow(clamp(2.5*mask, 0., 1.), 0.8);\n    mask = pow(mask, 1.5);\n    \n    vec3 water = vec3(12., 82., 142.)/255.;\n    vec3 light = vec3(0.93, 0.98, 0.9);\n    shaft = mix(water, light, mask);\n\t\n\tfragColor = vec4( shaft, 1.0 ); \n\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/lldcRr.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 53, 80, 80, 187], [188, 188, 210, 210, 349], [351, 433, 455, 455, 830], [832, 832, 851, 851, 1006], [1009, 1009, 1027, 1027, 1066], [1083, 1083, 1140, 1140, 1910]], "test": "untested"}
{"id": "lldyRr", "name": "李明杰V19", "author": "leneer", "description": "i", "tags": ["i"], "likes": 1, "viewed": 260, "published": "Public", "date": "1531370373", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define path(t) sin(t * 0.5) * 1.5\n\nvec4 df(vec3 p)\n{\n    vec3 tex = texture(iChannel0, p.xz * 0.5).rgb;\n    float disp = dot(tex, vec3(0.01));\n    \n    p.xy += path(p.z);\n    \n    float a = cos(p.z * 2.);\n    p.xy *= mat2(cos(a),-sin(a),sin(a),cos(a));\n    float sp = fract(-atan(p.x,p.y)/3.14159*8.+(mod(p.z,1.)-0.5));\n    \n    float tutu = (0.8 - length(p.xy)) * sp + disp;\n\n    return vec4(max(-length(p.xy) + .78, tutu), vec3(0));\n}\n\nvec3 nor( vec3 pos, float prec )\n{\n\tvec3 eps = vec3( prec, 0., 0. );\n\tvec3 nor = vec3(\n\t    df(pos+eps.xyy).x - df(pos-eps.xyy).x,\n\t    df(pos+eps.yxy).x - df(pos-eps.yxy).x,\n\t    df(pos+eps.yyx).x - df(pos-eps.yyx).x );\n\treturn normalize(nor);\n}\n\n// return color from temperature \n//http://www.physics.sfasu.edu/astro/color/blackbody.html\n//http://www.vendian.org/mncharity/dir3/blackbody/\n//http://www.vendian.org/mncharity/dir3/blackbody/UnstableURLs/bbr_color.html\nvec3 blackbody(float Temp)\n{\n\tvec3 col = vec3(255.);\n    col.x = 56100000. * pow(Temp,(-3. / 2.)) + 148.;\n   \tcol.y = 100.04 * log(Temp) - 623.6;\n   \tif (Temp > 6500.) col.y = 35200000. * pow(Temp,(-3. / 2.)) + 184.;\n   \tcol.z = 194.18 * log(Temp) - 1448.6;\n   \tcol = clamp(col, 0., 255.)/255.;\n    if (Temp < 1000.) col *= Temp/1000.;\n   \treturn col;\n}\n\n// get density of the df at surfPoint\n// ratio between constant step and df value\nfloat SubDensity(vec3 surfPoint, float ms) \n{\n\tvec3 n = nor(surfPoint,0.0001); \n\treturn df(surfPoint - n * ms).x/ms;\n}\n\n// from shane shaders\n// Tri-Planar blending function. Based on an old Nvidia writeup:\n// GPU Gems 3 - Ryan Geiss: http://http.developer.nvidia.com/GPUGems3/gpugems3_ch01.html\nvec3 tex3D( sampler2D tex, in vec3 p, in vec3 n )\n{\n    n = max((abs(n) - .2)*7., .001);\n    n /= (n.x + n.y + n.z );  \n    p = (texture(tex, p.yz)*n.x + texture(tex, p.zx)*n.y + texture(tex, p.xy)*n.z).xyz;\n    return p*p;\n}\n\n// from shane shaders\n// Texture bump mapping. Four tri-planar lookups, or 12 texture lookups in total. I tried to \n// make it as concise as possible. Whether that translates to speed, or not, I couldn't say.\nvec3 doBumpMap( sampler2D tx, in vec3 p, in vec3 n, float bf)\n{\n    const vec2 e = vec2(0.001, 0);\n    mat3 m = mat3( tex3D(tx, p - e.xyy, n), tex3D(tx, p - e.yxy, n), tex3D(tx, p - e.yyx, n));\n    vec3 g = vec3(0.299, 0.587, 0.114)*m; // Converting to greyscale.\n    g = (g - dot(tex3D(tx,  p , n), vec3(0.299, 0.587, 0.114)) )/e.x; g -= n*dot(n, g);\n    return normalize( n + g*bf ); // Bumped normal. \"bf\" - bump factor.\n}\n\n// shading func\nvec3 shade(vec3 ro, vec3 rd, float d, vec3 ld, float li)\n{\n\tvec3 p = ro + rd * d;\t\t\n\tvec3 n = nor(p, 0.1);\t\t\n    \n    n = doBumpMap(iChannel0, p*.5, n, 0.005);\n\t\n\tvec3 refl = reflect(rd,n);\t\n\t\n\tfloat amb = 0.6; \t\t\t\t\t\t\t\t\t\t\t\n\tfloat diff = clamp( dot( n, ld ), 0.0, 1.0 ); \t\t\t\t\n\tfloat fre = pow( clamp( 1. + dot(n,rd),0.0,1.0), 4. ); \t\t\n\tfloat spe = pow(clamp( dot( refl, ld ), 0.0, 1.0 ),16.); \t\n\tfloat sss = 1. - SubDensity(p, 1.); \t\t\t\t\t\t\n\t\n    return vec3(\n        (diff + fre + spe * 3.) * amb * li,\n        (diff + fre + sss) * amb * li + spe * 1.2,\n        (diff + fre - spe * 0.2 + sss * .8) * amb * li\n    );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // vars\n\tvec2 g = fragCoord;\n\tvec2 si = iResolution.xy;\n\tvec2 mo = iMouse.xy;\n\tfloat time = iTime * 1.2;\n\t\n\tvec3 col = vec3(0);\n            \n\tvec3 ro = vec3(0,0,time);\n\tro.xy -= path(ro.z);\n    \n\tvec3 lp = ro + vec3(0,2,5);\n\t\n    vec3 cv = vec3(0,0,ro.z+1.);\n    cv.xy -= path(cv.z);\n    \n\tvec3 cu = normalize(vec3(0,1,0));\n  \tvec3 z = normalize(cv-ro);\n    vec3 x = normalize(cross(cu,z));\n  \tvec3 y = cross(z,x);\n    \n  \tvec2 uv = (g+g-si)/si.y;\n   \tvec3 rd = normalize(z + uv.x*x + uv.y*y);\n\n\tfloat md = 100.;\n\n\tfloat s = 1., d = 0.;\n\tfor (float i=0.; i<80.; i++)\n\t{\n\t\tif (d*d/s > 1e6 || d > md) break;\n\t\ts = df(ro+rd*d).x;\n\t\td += s * 0.8;\n\t}\n\t\n    vec3 ld = normalize(lp - ro-rd*d);\n\t\n    vec3 mat = vec3(0.3,0.5,0.8);\n    \n    if (d < md)\n    {\n        vec3 p = ro+rd*d; // surf point\n        \n        // sub surface\n        for (float i = 0.; i < 1.; i+=0.1)\n        {\n            float y = shade(p, rd, i, ld, i).y;\n            mat = blackbody(1000. + y * 900.).bgr * 0.8;\n            col = mix(col, y * mat, i);\n        }\n        \n        // surface\n        float x = shade(ro, rd, d, ld, 3.).x;\n        mat = blackbody(1000. + x * 900.).bgr * 0.2;\n        col = mix(col, x * mat, 0.7);\n    }\n    \n\tcol = mix(col, mat, 1.0-exp(-0.01*d*d));\n\n    col = sqrt(col * col * .8);\n\n\tvec2 v = g/si;\n    col *= 0.5 + 0.5*pow( 16.0*v.x*v.y*(1.0-v.x)*(1.0-v.y), 0.25 ); // iq vignette\n    fragColor = vec4(col, 1.0);\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/lldyRr.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[36, 36, 53, 53, 437], [439, 439, 473, 473, 685], [687, 908, 936, 936, 1261], [1263, 1345, 1390, 1390, 1463], [1465, 1641, 1692, 1692, 1866], [1868, 2077, 2140, 2140, 2502], [2504, 2520, 2578, 2578, 3135], [3137, 3137, 3194, 3206, 4613]], "test": "untested"}
{"id": "lldyW7", "name": "dalao2", "author": "tilendlesa", "description": "d", "tags": ["d"], "likes": 1, "viewed": 323, "published": "Public API", "date": "1532934216", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//============================================================================\n// PROJECT ID: <your Project ID is an integer equal to 62 + group_no.>\n//\n// GROUP NUMBER:\n//\n// STUDENT NAME: \n// NUS User ID.: \n//\n// STUDENT NAME: \n// NUS User ID.: \n//\n// STUDENT NAME: \n// NUS User ID.: \n//\n// COMMENTS TO GRADER: \n//\n//============================================================================\n\n\n// FRAGMENT SHADER FOR SHADERTOY\n// Run this at https://www.shadertoy.com/new\n// See documentation at https://www.shadertoy.com/howto\n\n// Your browser must support WebGL 2.0.\n// Check your browser at http://webglreport.com/?v=2\n\n\n//============================================================================\n// Constants.\n//============================================================================\nconst int NUM_LIGHTS = 2;\nconst int NUM_MATERIALS = 5;\nconst int NUM_PLANES = 5;\nconst int NUM_SPHERES = 10;\n\nconst vec3 BACKGROUND_COLOR = vec3( 0.1, 0.2, 0.6 );\n\n // Vertical field-of-view angle of camera. In radians.\nconst float FOVY = 50.0 * 3.1415926535 / 180.0; \n\n// Use this for avoiding the \"epsilon problem\" or the shadow acne problem.\nconst float DEFAULT_TMIN = 10.0e-4;\n\n// Use this for tmax for non-shadow ray intersection test.\nconst float DEFAULT_TMAX = 10.0e6;\n\n// Equivalent to number of recursion levels (0 means ray-casting only).\n// We are using iterations to replace recursions.\nconst int NUM_ITERATIONS = 3;\n\n\n//============================================================================\n// Define new struct types.\n//============================================================================\nstruct Ray_t {\n    vec3 o;  // Ray Origin.\n    vec3 d;  // Ray Direction. A unit vector.\n};\n\nstruct Plane_t {\n    // The plane equation is Ax + By + Cz + D = 0.\n    float A, B, C, D;\n    int materialID;\n};\n\nstruct Sphere_t {\n    vec3 center;\n    float radius;\n    int materialID;\n};\n\nstruct Light_t {\n    vec3 position;  // Point light 3D position.\n    vec3 I_a;       // For Ambient.\n    vec3 I_source;  // For Diffuse and Specular.\n};\n\nstruct Material_t {\n    vec3 k_a;   // Ambient coefficient.\n    vec3 k_d;   // Diffuse coefficient.\n    vec3 k_r;   // Reflected specular coefficient.\n    vec3 k_rg;  // Global reflection coefficient.\n    float n;    // The specular reflection exponent. Ranges from 0.0 to 128.0. \n};\n\n//----------------------------------------------------------------------------\n// The lighting model used here is similar to that on Slides 8 and 12 of \n// Lecture 11 (Ray Tracing). Here it is computed as\n//\n//     I_local = SUM_OVER_ALL_LIGHTS { \n//                   I_a * k_a + \n//                   k_shadow * I_source * [ k_d * (N.L) + k_r * (R.V)^n ]\n//               }\n// and\n//     I = I_local  +  k_rg * I_reflected\n//----------------------------------------------------------------------------\n\n\n//============================================================================\n// Global scene data.\n//============================================================================\nPlane_t Plane[NUM_PLANES];\nSphere_t Sphere[NUM_SPHERES];\nLight_t Light[NUM_LIGHTS];\nMaterial_t Material[NUM_MATERIALS];\nfloat pi=180.0*FOVY/50.0;\n\nvoid  period(float T,out float time)\n{\n\tif(mod(iTime,T)<T/2.0)\ttime = mod(iTime,T);\n\telse\ttime = T-mod(iTime,T);\n}\n/////////////////////////////////////////////////////////////////////////////\n// Initializes the scene.\n/////////////////////////////////////////////////////////////////////////////\nvoid InitScene()\n{\n\tfloat T = 14.0;\n\tfloat time;\n\tperiod(T,time);\n\n    // Horizontal plane.\n    Plane[0].A = 0.0;\n    Plane[0].B = 1.0;\n    Plane[0].C = 0.0;\n    Plane[0].D = 0.0;\n    Plane[0].materialID = 4;\n\n     //Vertical plane.\n    Plane[1].A = 0.0;\n    Plane[1].B = 0.0;\n    Plane[1].C = 1.0;\n    Plane[1].D = 3.5-time/2.0;\n    Plane[1].materialID = 0;\n\n\tPlane[2].A = 0.0;\n    Plane[2].B = 0.0;\n    Plane[2].C = -1.0;\n    Plane[2].D = 3.5-time/2.0;\n\tPlane[3].materialID = 0;\n    \n\tPlane[3].A = 1.0;\n    Plane[3].B = 0.0;\n    Plane[3].C = 0.0;\n\tPlane[3].D = 3.0+3.0*iTime/7.0;\n\tPlane[4].materialID = 0;\n\t\n\tPlane[4].A = -1.0;\n    Plane[4].B = 0.0;\n\tPlane[4].C = 0.0;\n\tPlane[4].materialID = 0;\n    Plane[4].D = 3.5;\n \n\n\t\n\n\t\n    Sphere[0].center = vec3(-time, 0.5+abs(sin(iTime-5.0)), 0.0);//Z上下 X左右\n    Sphere[0].radius = 0.5;\n    Sphere[0].materialID = 1;\n//\n//\tSphere[7].center = vec3(-1.75-1.55*sin(1.5*iTime) , 2.5,  0 );\n//    Sphere[7].radius = 0.2;\n//    Sphere[7].materialID = 2;\n//\n//\tSphere[8].center = vec3(1.75-1.55*sin(1.5*iTime) , 1.5,  0 );\n//    Sphere[8].radius = 0.2;\n//    Sphere[8].materialID = 3;\n//\n//\tSphere[9].center = vec3(-1.75+1.55*sin(1.5*iTime) , 1.5,  0 );\n//    Sphere[9].radius = 0.2;\n//    Sphere[9].materialID = 3;\n//\n\n\n    // Silver material.\n\t\n    Material[0].k_d = vec3(0.5,0.5,0.5);\n    Material[0].k_a = 0.2 * Material[0].k_d;\n    Material[0].k_r = 2.0 * Material[0].k_d;\n    Material[0].k_rg = 0.5 * Material[0].k_r;\n    Material[0].n = 64.0;\n\n    // Gold material.\n    Material[1].k_d = vec3( 1.0, 1.0, 1.0);\n    Material[1].k_a = 0.2 * Material[1].k_d;\n    Material[1].k_r = 2.0 * Material[1].k_d;\n    Material[1].k_rg = 0.5 * Material[1].k_r;\n    Material[1].n = 64.0;\n\n\n    // Green plastic material.\n    Material[2].k_d = vec3( 0.2, sin(3.0*iTime), 0.2 );\n    Material[2].k_a = 0.2 * Material[2].k_d;\n    Material[2].k_r = vec3( 1.0, 1.0, 1.0 );\n    Material[2].k_rg = 0.5 * Material[2].k_r;\n    Material[2].n = 128.0;\n\n\tMaterial[3].k_d = vec3( sin(3.0*iTime), 0.2, 0.2 );\n    Material[3].k_a = 0.2 * Material[3].k_d;\n    Material[3].k_r = vec3( 1.0, 1.0, 1.0 );\n    Material[3].k_rg = 0.5 * Material[3].k_r;\n    Material[3].n = 128.0;\n\n\tvec2 uv = vec2(0.0,0.0);\n\tMaterial[4].k_d = 0.2*(0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4)));\n    Material[4].k_a = 0.2 * Material[4].k_d;\n    Material[4].k_r = 2.0 * Material[4].k_d;\n    Material[4].k_rg = 0.5 * Material[4].k_r;\n    Material[4].n = 64.0;\n\n    // Light 0.\n    //Light[0].position = vec3( 3.0, 8.0, -3.0);\n\tLight[0].position = vec3( 0.0, 8.0, 0.0);\n    Light[0].I_a = vec3( 0.1, 0.1, 0.1 );\n    Light[0].I_source = vec3( 1.0, 1.0, 1.0 );\n\n    // Light 1.\n    //Light[1].position = vec3( -3.0, 8.0, 3.0);\n\tLight[1].position = vec3( 0.0, 9.0, 0.0);\n    Light[1].I_a = vec3( 0.1, 0.1, 0.1 );\n    Light[1].I_source = vec3( 1.0, 1.0, 1.0 );\n}\n\n\n\n/////////////////////////////////////////////////////////////////////////////\n// Computes intersection between a plane and a ray.\n// Returns true if there is an intersection where the ray parameter t is\n// between tmin and tmax, otherwise returns false.\n// If there is such an intersection, outputs the value of t, the position\n// of the intersection (hitPos) and the normal vector at the intersection \n// (hitNormal).\n//计算平面和光线之间的交叉点。\n//如果有一个交点，其中光线参数t介于tmin和tmax之间，则返回true，否则返回false。\n//如果有这样的交集，则输出交叉点（hitPos）的交叉点（hitPos）和交叉点的正常向量（hitNormal）的值。\n/////////////////////////////////////////////////////////////////////////////\nbool IntersectPlane( in Plane_t pln, in Ray_t ray, in float tmin, in float tmax,\n                     out float t, out vec3 hitPos, out vec3 hitNormal ) \n{\n    vec3 N = vec3( pln.A, pln.B, pln.C );\n    float NRd = dot( N, ray.d );\n    float NRo = dot( N, ray.o );\n    float t0 = (-pln.D - NRo) / NRd;\n    if ( t0 < tmin || t0 > tmax ) return false;\n\n    // We have a hit -- output results.\n    t = t0;\n    hitPos = ray.o + t0 * ray.d;\n    hitNormal = normalize( N );\n    return true;\n}\n\n\n\n/////////////////////////////////////////////////////////////////////////////\n// Computes intersection between a plane and a ray.\n// Returns true if there is an intersection where the ray parameter t is\n// between tmin and tmax, otherwise returns false.\n//计算平面和光线之间的交叉点。\n//如果有一个交叉点，其中ray参数t介于tmin和tmax之间，则返回true，否则返回false。\n/////////////////////////////////////////////////////////////////////////////\nbool IntersectPlane( in Plane_t pln, in Ray_t ray, in float tmin, in float tmax )\n{\n    vec3 N = vec3( pln.A, pln.B, pln.C );\n    float NRd = dot( N, ray.d );\n    float NRo = dot( N, ray.o );\n    float t0 = (-pln.D - NRo) / NRd;\n    if ( t0 < tmin || t0 > tmax ) return false;\n    return true;\n}\n\n\n\n/////////////////////////////////////////////////////////////////////////////\n// Computes intersection between a sphere and a ray.\n// Returns true if there is an intersection where the ray parameter t is\n// between tmin and tmax, otherwise returns false.\n// If there is one or two such intersections, outputs the value of the \n// smaller t, the position of the intersection (hitPos) and the normal \n// vector at the intersection (hitNormal).\n//计算球体和射线之间的交集。\n//如果有一个交叉点，其中ray参数t介于tmin和tmax之间，则返回true，否则返回false。\n//如果有一个或两个这样的交点，则输出较小的t的值，交点的位置（hitPos）和交点处的法线向量（hitNormal）。\n/////////////////////////////////////////////////////////////////////////////\nbool IntersectSphere( in Sphere_t sph, in Ray_t ray, in float tmin, in float tmax,\n                      out float t, out vec3 hitPos, out vec3 hitNormal ) \n{\n    /////////////////////////////////\n    // TASK: WRITE YOUR CODE HERE. //\n\tray.o -= sph.center;\n\tfloat t0;\n\tfloat a = dot(ray.d,ray.d);\n\tfloat b = 2.0 * dot(ray.d,ray.o);\n\tfloat c = dot(ray.o,ray.o)-sph.radius*sph.radius;\n\tfloat d = b*b - 4.0*a*c;\n\tif(d<0.0)\treturn false;\n\telse if (d == 0.0)\tt0 =(-b)/(2.0*a);\n\telse \n\t{\n\t\tfloat t1 = (-b+sqrt(d))/(2.0*a);\n\t\tfloat t2 = (-b-sqrt(d))/(2.0*a);\n\t\tif(t2>0.0) t0 =t2;\n\t\telse t0 = t1;\n\t}\n\tif ( t0 < tmin || t0 > tmax ) return false;\n\tt = t0;\n    hitPos = ray.o + t0 * ray.d+ sph.center;\n    hitNormal = normalize(hitPos-sph.center);\n    /////////////////////////////////\n    return true;  // Replace this with your code.\n\n}\n\n\n\n/////////////////////////////////////////////////////////////////////////////\n// Computes intersection between a sphere and a ray.\n// Returns true if there is an intersection where the ray parameter t is\n// between tmin and tmax, otherwise returns false.\n/////////////////////////////////////////////////////////////////////////////\nbool IntersectSphere( in Sphere_t sph, in Ray_t ray, in float tmin, in float tmax )\n{\n    /////////////////////////////////\n    // TASK: WRITE YOUR CODE HERE. //\n\tray.o -= sph.center;\n\tfloat t0;\n\tfloat a = dot(ray.d,ray.d);\n\tfloat b = 2.0 * dot(ray.d,ray.o);\n\tfloat c = dot(ray.o,ray.o)-sph.radius*sph.radius;\n\tfloat d = b*b - 4.0*a*c;\n\tif(d<0.0)\treturn false;\n\telse if (d == 0.0)\tt0 =(-b)/(2.0*a);\n\telse \n\t{\n\t\tfloat t1 = (-b+sqrt(d))/(2.0*a);\n\t\tfloat t2 = (-b-sqrt(d))/(2.0*a);\n\t\tif(t2>0.0) t0 =t2;\n\t\telse t0 = t1;\n\t}\n\tif ( t0 < tmin || t0 > tmax ) return false;\n    /////////////////////////////////\n    return true;  // Replace this with your code.\n\n}\n\n\n/////////////////////////////////////////////////////////////////////////////\n// Computes (I_a * k_a) + k_shadow * I_source * [ k_d * (N.L) + k_r * (R.V)^n ].\n// Input vectors L, N and V are pointing AWAY from surface point.\n// Assume all vectors L, N and V are unit vectors.\n//输入矢量L，N和V从表面指向AWAY。\n//假设所有向量L，N和V都是单位向量。\n/////////////////////////////////////////////////////////////////////////////\nvec3 PhongLighting( in vec3 L, in vec3 N, in vec3 V, in bool inShadow, \n                    in Material_t mat, in Light_t light )\n{\n    if ( inShadow ) {\n        return light.I_a * mat.k_a;\n    }\n    else {\n        vec3 R = reflect( -L, N );\n        float N_dot_L = max( 0.0, dot( N, L ) );\n        float R_dot_V = max( 0.0, dot( R, V ) );\n        float R_dot_V_pow_n = ( R_dot_V == 0.0 )? 0.0 : pow( R_dot_V, mat.n );\n\n        return light.I_a * mat.k_a + \n               light.I_source * (mat.k_d * N_dot_L + mat.k_r * R_dot_V_pow_n);\n    }\n}\n\n\n/////////////////////////////////////////////////////////////////////////////\n// Casts a ray into the scene and returns color computed at the nearest\n// intersection point. The color is the sum of light from all light sources,\n// each computed using Phong Lighting Model, with consideration of\n// whether the interesection point is being shadowed from the light.\n// If there is no interesection, returns the background color, and outputs\n// hasHit as false.\n// If there is intersection, returns the computed color, and outputs\n// hasHit as true, the 3D position of the intersection (hitPos), the\n// normal vector at the intersection (hitNormal), and the k_rg value\n// of the material of the intersected object.\n//将光线投射到场景中并返回在最近交点处计算的颜色。\n//颜色是来自所有光源的光的总和，每个光源使用Phong照明模型计算，并考虑是否从光线遮蔽了截面点。\n//如果没有interesection，则返回背景颜色，并输出hasHit为false。\n//如果有交点，则返回计算的颜色，并输出hasHit为true，交点的3D位置（hitPos），\n//交点处的法线向量（hitNormal）以及相交对象的材质的k_rg值。\n/////////////////////////////////////////////////////////////////////////////\nvec3 CastRay( in Ray_t ray, \n              out bool hasHit, out vec3 hitPos, out vec3 hitNormal, out vec3 k_rg ) \n{\n    // Find whether and where the ray hits some object. \n    // Take the nearest hit point.\n\n    bool hasHitSomething = false;\n    float nearest_t = DEFAULT_TMAX;   // The ray parameter t at the nearest hit point.\n    vec3 nearest_hitPos;              // 3D position of the nearest hit point.\n    vec3 nearest_hitNormal;           // Normal vector at the nearest hit point.\n    int nearest_hitMatID;             // MaterialID of the object at the nearest hit point.\n\n    float temp_t;\n    vec3 temp_hitPos;\n    vec3 temp_hitNormal;\n    bool temp_hasHit;\n\n    /////////////////////////////////////////////////////////////////////////////\n    // TASK:\n    // * Try interesecting input ray with all the planes and spheres,\n    //   and record the front-most (nearest) interesection.\n    // * If there is interesection, need to record hasHitSomething,\n    //   nearest_t, nearest_hitPos, nearest_hitNormal, nearest_hitMatID.\n\t//尝试将输入光线与所有平面和球体相互交叉，并记录最前面（最近）的截面。\n\t//如果有intersection，需要记录hasHitSomething，nearest_t，nearest_hitPos，nearest_hitNormal，nearest_hitMatID。\n    /////////////////////////////////////////////////////////////////////////////\n\n    /////////////////////////////////\n    // TASK: WRITE YOUR CODE HERE. //\n\t//hasHitSomething = IntersectPlane(Plane[NUM_PLANES],ray,DEFAULT_TMIN,DEFAULT_TMAX) && IntersectSphere( Sphere[NUM_SPHERES],ray, DEFAULT_TMIN,DEFAULT_TMAX);\n\tfor(int i=0;i<NUM_PLANES;i++)\n\t{\n\t\tif( IntersectPlane( Plane[i],ray,DEFAULT_TMIN,DEFAULT_TMAX, temp_t, temp_hitPos, temp_hitNormal ))\n\t\t{\n\t\t\tif(nearest_t>temp_t)\n\t\t\t{\n\t\t\t\tnearest_t = temp_t;\n\t\t\t\tnearest_hitPos = temp_hitPos;\n\t\t\t\tnearest_hitNormal = temp_hitNormal;\n\t\t\t\tnearest_hitMatID = Plane[i].materialID;\n\t\t\t}\n\t\t\thasHitSomething = true;\n\t\t}\n\t}\n\tfor(int i=0;i<NUM_SPHERES;i++)\n\t{\n\t\tif(IntersectSphere( Sphere[i],ray, DEFAULT_TMIN,DEFAULT_TMAX,  temp_t,temp_hitPos,temp_hitNormal))\n\t\t{\n\t\t\tif(nearest_t>temp_t)\n\t\t\t{\n\t\t\t\tnearest_t = temp_t;\n\t\t\t\tnearest_hitPos = temp_hitPos;\n\t\t\t\tnearest_hitNormal = temp_hitNormal;\n\t\t\t\tnearest_hitMatID = Sphere[i].materialID;\n\t\t\t}\n\t\t\thasHitSomething = true;\n\t\t}\n\t}\n    /////////////////////////////////\n\n\n\n    // One of the output results.\n    hasHit = hasHitSomething;\n    if ( !hasHitSomething ) return BACKGROUND_COLOR;\n\n    vec3 I_local = vec3( 0.0 );  // Result color will be accumulated here.\n\n    /////////////////////////////////////////////////////////////////////////////\n    // TASK:\n    // * Accumulate lighting from each light source on the nearest hit point. \n    //   They are all accumulated into I_local.\n    // * For each light source, make a shadow ray, and check if the shadow ray\n    //   intersects any of the objects (the planes and spheres) between the \n    //   nearest hit point and the light source.\n    // * Then, call PhongLighting() to compute lighting for this light source.\n\t//在最近的生命点上累积每个光源的光照。\n\t//它们都积累在I_local中。\n\t//对于每个光源，制作阴影射线，并检查阴影射线是否会影响最近的生命点和\n\t//光源之间的任何物体（平面和球体）。然后，调用PhongLighting（）来计算此光源的光照。\n    /////////////////////////////////////////////////////////////////////////////\n\n    /////////////////////////////////\n    // TASK: WRITE YOUR CODE HERE. //\n\tbool inShadow[NUM_LIGHTS];\n\tRay_t ShadowRay[NUM_LIGHTS];\n\tfor(int i=0;i<NUM_LIGHTS;i++)\n\t{\n\t\t\tinShadow[i] = false;\n\t\t\tShadowRay[i].o = nearest_hitPos; \n\t\t\tShadowRay[i].d = normalize(Light[i].position-nearest_hitPos);\n\t\tfor(int j=0;j<NUM_PLANES;j++)\n\t\t{\n\t\t\tif( IntersectPlane( Plane[j],ShadowRay[i],DEFAULT_TMIN,length(Light[i].position - nearest_hitPos)))\n\t\t\t\tinShadow[i] = true;\n\t\t}\n\t\tfor(int j=0;j<NUM_SPHERES;j++)\n\t\t{\n\t\t\tif(IntersectSphere( Sphere[j],ShadowRay[i], DEFAULT_TMIN,length(Light[i].position - nearest_hitPos)))\n\t\t\t{\n\t\t\t\tinShadow[i] = true;\n\t\t\t}\n\t\t}\n\t}\n\tvec3 N =  nearest_hitNormal;\n\tvec3 V =  normalize(-ray.d);\n\tfor(int i=0;i<NUM_LIGHTS;i++)\n\t{\n\tvec3 L=\tShadowRay[i].d;\n\tI_local += PhongLighting(L,N,V, inShadow[i], Material[nearest_hitMatID], Light[i]);\n\t}\n    /////////////////////////////////\n    // Populate output results.\n    hitPos = nearest_hitPos;\n    hitNormal = nearest_hitNormal;\n    k_rg = Material[nearest_hitMatID].k_rg;\n\n    return I_local;\n}\n\n\n\n/////////////////////////////////////////////////////////////////////////////\n// Execution of fragment shader starts here.\n// 1. Initializes the scene.\n// 2. Compute a primary ray for the current pixel (fragment).\n// 3. Trace ray into the scene with NUM_ITERATIONS recursion levels.\n/////////////////////////////////////////////////////////////////////////////\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    InitScene();\n\n    // Scale pixel 2D position such that its y coordinate is in [-1.0, 1.0].\n    vec2 pixel_pos = (2.0 * fragCoord.xy - iResolution.xy) / iResolution.y;\n\n    // Position the camera.\n    //vec3 cam_pos = vec3( 2.0* cos(iTime), 2.5,2.0*sin(iTime));//相机位置\n\t//vec3 cam_pos = vec3( 2.0, 2.5,2.0);\n\tvec3 cam_pos;\n    cam_pos = vec3( 3.4, 3.0,0.0);\n\t\n    //vec3 cam_lookat = vec3(0.0, 2.0, 0.0 ); //镜头摇晃\n\tvec3 cam_lookat = vec3(0.0, 1.0, 0.0 );\n    vec3 cam_up_vec = vec3( 0.0, 1.0, 0.0 );\n\n    // Set up camera coordinate frame in world space.\n    vec3 cam_z_axis = normalize( cam_pos - cam_lookat );\n    vec3 cam_x_axis = normalize( cross(cam_up_vec, cam_z_axis) );\n    vec3 cam_y_axis = normalize( cross(cam_z_axis, cam_x_axis));\n\n    // Create primary ray.\n    float pixel_pos_z = -1.0 / tan(FOVY / 2.0);\n    Ray_t pRay;\n    pRay.o = cam_pos;\n    pRay.d = normalize( pixel_pos.x * cam_x_axis  +  pixel_pos.y * cam_y_axis  +  pixel_pos_z * cam_z_axis );\n\n\n    // Start Ray Tracing.\n    // Use iterations to emulate the recursion.\n\n    vec3 I_result = vec3( 0.0 );\n    vec3 compounded_k_rg = vec3( 1.0 );\n    Ray_t nextRay = pRay;\n\n    for ( int level = 0; level <= NUM_ITERATIONS; level++ ) \n    {\n        bool hasHit;\n        vec3 hitPos, hitNormal, k_rg;\n\n        vec3 I_local = CastRay( nextRay, hasHit, hitPos, hitNormal, k_rg );\n\n        I_result += compounded_k_rg * I_local;\n\n        if ( !hasHit ) break;\n\n        compounded_k_rg *= k_rg;\n\n        nextRay = Ray_t( hitPos, normalize( reflect(nextRay.d, hitNormal) ) );\n    }\n\n    fragColor = vec4( I_result, 1.0 );\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/lldyW7.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[2846, 3173, 3211, 3211, 3287], [3288, 3470, 3488, 3488, 6314], [6318, 7103, 7258, 7258, 7588], [7592, 8077, 8160, 8160, 8372], [8376, 9191, 9349, 9425, 10018], [10022, 10355, 10440, 10516, 11009], [11012, 11463, 11594, 11594, 12007], [12010, 13279, 13394, 13486, 17755], [17759, 18120, 18177, 18177, 19782]], "test": "untested"}
{"id": "lldyzM", "name": "analytical filter kernel BoxTri", "author": "ollj", "description": "original shader by iq, slightly extended by ollj\n\nmouse.y blurs and iMouse.y==0 is nonsensical in a differential context here.", "tags": ["filter", "analytic", "kernel", "automaticdifferentiation"], "likes": 3, "viewed": 419, "published": "Public API", "date": "1532083589", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//self https://www.shadertoy.com/view/lldyzM\n\n//analytical filter kernel,triangular \n//https://www.shadertoy.com/view/llffWs\n// Similar to https://www.shadertoy.com/view/XlXBWs,but with a triangular filter kernel,\n// which produces less flickering animations that a box filter. Luckily,it's still easily\n// http://iquilezles.org/www/articles/morecheckerfiltering/morecheckerfiltering.htm\n// checker,2D,box filter: https://www.shadertoy.com/view/XlcSz2\n// checker,3D,box filter: https://www.shadertoy.com/view/XlXBWs\n// checker,3D,tri filter: https://www.shadertoy.com/view/llffWs\n// grid,2D,box filter: https://www.shadertoy.com/view/XtBfzz\n// The MIT License\n//https://www.shadertoy.com/view/llffWs\n// Copyright © 2017 Inigo Quilez\n// Permission is hereby granted,free of charge,to any person obtaining a copy of this software and associated documentation files(the \"Software\"),to dealthe Software without restriction,including without limitation the rights to use,copy,modify,merge,publish,distribute,sublicense,and/or sell copies of the Software,and to permit persons to whom the Software is furnished to do so,subject to the following conditions: The above copyright notice and this permission notice shall be includedall copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\",WITHOUT WARRANTY OF ANY KIND,EXPRESS OR IMPLIED,INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,DAMAGES OR OTHER LIABILITY,WHETHERAN ACTION OF CONTRACT,TORT OR OTHERWISE,ARISING FROM,OUT OF ORCONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGSTHE SOFTWARE.\n\n\n/* ---snippety blog summary esplanation\n//fwidth(a,b)=abs(dfdx(p))+abs(dfdy(p))\n#define maab(a,b)max(abs(a),abs(b))\nthe m-parameter is a value,returned from maab(),which may be calculated for multiple textures to be mixed,so it is moved out of the function.\n\n//llffWs is tri-filtering AND box filtering,but it does not need the double integral,but other shaders calculate a double integral.\n//there is this double-integral blog post this snioppet is all about:\nthe basic idea is to smoothen a discontinuity with an antiderivative\n\"cubic filters\" are most common in CG,but this isr \"tiangle-filter\"ed weights,worse than cubic,better than the box filtering above\n\nf(x)is the square-wave base signal that begs to be filtered.\nbox-filter formula is integralfromToOf(-w/2,w/2,f(x)dx)\ntri-filter formula is integralfromToOf(-w,0,f(x)dx*(w+x)/w)+integralfromtoOf(0,w,f(x)dx*(w-x)/w)\n\nthese integrals are integralfromToOf(uv-w/2,uv+w/2,...),but shifting the center simplifies this function.\nthese integrals are done by [integration by parts],which has lots of symmetries that cancel each other out to:\ntri-filter formula is(p(-w*.5)-2.*p(0.)+p(w*.5))/w/w\nwhere p(x)is the antidetivative to f(x)(the striangle wave to the square wave.)\nwhere s(x)is the double-integral of f(x)== the antidefivative of p(x)=an infinite smoothstep function.\n\n//still no double-integrals needed!\nvec3 sqrAndIntegrals(float x\n){x*=.5;float h=fract(x)-.5,s=-sign(h),t=abs(h)*2.-1.)\n ;return(s,t,x+h*t);}//return vec3(square,tri(integral),smoothsteps(doubleIntegral))\nvec2 fTri(vec2 x){vec2 h=fract(x*.5)-.5);return x*.5-h*(abs(h)*2.-1.);}//;return x*.5+h*(1.-2.*abs(h))\nfloat TriFilteredCheckers(vec2 uv,vec2 w//w=maab(dpdx,dpdy)filter kernel\n){w+.001\n ;vec2 i=(fTri(uw+w)-2.*fTri(uw)+ftri(uv-w))/(w*w)//analytic integral,3TapFilter function\n ;return .5-.5*i.x-i.y//xor-pattern\n ;}\n//still no double-integrals needed!\n//anyways,that would be curvature,what use is curvature for surface filtering?\n*/\n\n\n#define scale 5.\n\n// spheres\nconst vec4 sc0=vec4(2,.5,.8,.5);\nconst vec4 sc1=vec4(-6,1,-4.,3);\nconst vec4 sc2=vec4(-16,1,7,4);\nconst vec4 sc3=vec4(-25,8,0,9);\n\nstruct v33{vec3 a;vec3 b;};\n//and this ray-transpose function is the strangest of em all to be useful here:\nvoid rayTransp(inout v33 a,inout v33 b){vec3 s=a.b;a.b=b.a;b.a=s;}//swap direction(.b)of [a] with origin(.a)of [b]\nv33 sub(v33 a,vec3 b){return v33(a.a-b,a.b-b);}//substract b from all ray components\n//component wise ray substraction(this one is a bit odd,differential wise,is basically scaling a rays points)\nv33 subc(v33  a,v33 b){return v33(a.a-b.a,a.b-b.b);}//it makes sense in\nv33 subc(vec2 a,v33 b){return v33(a.x-b.a,a.x-b.b);}//the context of\nv33 subc(v33 a,vec2 b){return v33(a.a-b.x,a.b-b.y);}//v33-differentials for AA\nvec2 dt(v33 a,v33 b){return vec2(dot(a.a,b.a),dot(a.b,b.b));}//dual dotprodiuct on v33s\nvec2 dt(v33 a,vec3 b){return dt(a,v33(b,b));}\nv33 div(v33 a,vec2 b){return v33(a.a/b.x,a.b/b.y);}\nv33 mul(v33 a,v33 b){return v33(a.a*b.a,a.b*b.b);}//dual mult\nv33 mul(v33 a,vec2 b){return v33(a.a*b.x,a.b*b.y);}\nv33 mul(v33 a,float b){return v33(a.a*b,a.b*b);}\n\n\nfloat sat(float a){return clamp(a,0.,1.);}\n#define dd(a)dot(a,a)\n//half-identity-scaling,labeled uN because it scales uv space,usually within a modulo context.\n#define u2(a)((a)*2.-1.)\n#define u5(a)((a)*.5+.5)\n//u3(a)=1.-u2(a)!\n//u6(a)=1.-u2(a)!\n#define u3(a)(1.-(a)*2.)\n#define u6(a)(.5-(a)*.5)\n#define maab(a,b)max(abs(a),abs(b))\nvec3 maab2(v33 a){return maab(a.a,a.b);}\nfloat suv(vec3 a){return a.x+a.y+a.z;}\nfloat prv(vec3 a){return a.x*a.y*a.z;}\nfloat miv(vec2 a){return min(a.x,a.y);}\nfloat miv(vec4 a){return min(miv(a.xy),miv(a.zw));}\nfloat ss01(float a){return smoothstep(0.,1.,a);}\n\n// ---unfiltered checkerboard ---\n#define checker(a)mod(suv(floor(a)),2.)\n//analytically triangle-filtered checkerboard:  https://www.shadertoy.com/view/MtffWs\n#define Fa(a,b)u2(abs(b-.5))\n#define Fb(a,b)((a)*.5-((b)-.5)*Fa(a,b))\n#define tri(a,b)b(a,fract((a)*.5))\n//noe to self,maybe replace iMouse.y by abs(angleBetween(rayDirection,Normal))/quaterRotation\n//tri(a,Fa)2xTap for box-filtering,used a lot in CG\nfloat checkerF2(vec3 p,vec3 w){w+=iMouse.y/iResolution.y//filter kernel increase this value over inverse squared distance?\n ;return u6(prv((tri(p-.5*w,Fa)-tri(p+.5*w,Fa))/w));}//analytical integral(box filter),xor pattern\n//tri(a,Fb)3xTap for tri-filtering,is slightly better than checkerF2()\nfloat checkerF3(vec3 p,vec3 w){w+=iMouse.y/iResolution.y//filter kernel increase this value over inverse squared distance?\n ;return u6(prv((tri(p+w,Fb)-2.*tri(p,Fb)+tri(p-w,Fb))/(w*w)));}// analytical integral(tri filter),xor pattern\n\n//sphere softShadow of(ray,sphere)\nfloat sssp(v33 r,vec4 s){vec3 oc=s.xyz-r.a;float b=dot(oc,r.b),z=1.;if(b>0.){float h=dd(oc)-b*b-s.w*s.w;z=ss01(2.*h/b);}return z;}\n//sphere occlusion\nfloat occSphere(vec3 u,vec3 n,vec4 s){vec3 i=s.xyz-u;return 1.-dot(n,normalize(i))*s.w*s.w/dd(i);}\n\nfloat iSphere(v33 r,vec4 s){vec3 e=r.a-s.xyz;float b=dot(r.b,e),h=b*b-dd(e)+s.w*s.w,t=-1.;if(h>0.)t=-b-sqrt(h);return t;}\n\nfloat intersect(vec3 ro,vec3 rd,out vec3 pos,out vec3 n,out float occ,out float matid\n){\n ;mat4 sc=mat4(sc0,sc1,sc2,sc3)\n ;float tmin=10000.\n ;n=vec3(0)\n ;occ=1.\n ;pos=vec3(0)\n ;float h=(.01-ro.y)/rd.y//plane\n ;if(h>0.\n){tmin=h\n  ;n=vec3(0,1,0)\n  ;pos=ro+h*rd\n  ;matid=0.\n  ;occ=occSphere(pos,n,sc[0])*occSphere(pos,n,sc[1])*occSphere(pos,n,sc[2])*occSphere(pos,n,sc[3])\n  ;}\n ;for(int i=0;i<4;i++){\n  ;float h=iSphere(v33(ro,rd),sc[i])\n  ;bool b=abs(h-.5*tmin)<tmin*.5//==h>0.&&h<tmin\n  ;if(b){tmin=h;pos=ro+tmin*rd;n=normalize(ro+h*rd-sc[i].xyz);matid=1.;occ=u5(n.y);}}\n ;return tmin;}\n\nvoid calcCamera(out vec3 ro,out vec3 ta){float an=.3*sin(.04*iTime);ro=vec3(5.5*cos(an),1.,5.5*sin(an));ta=vec3(0,1,0);}\n\nvec3 doLighting(vec3 pos,vec3 rd,vec3 n,float occ\n){ ;v33 rrr=v33(pos,rd)//seems to be a shared light source position\n ;float sh=miv(vec4(sssp(rrr,sc0),sssp(rrr,sc1),sssp(rrr,sc2),sssp(rrr,sc3)))\n ,dif=sat(dot(n,vec3(.57703)));float bac=sat(dot(n,vec3(-.707,.0,-.707)))\n ;vec3 lin=dif*sh*vec3(1.5,1.4,1.3)\n ;lin+=occ*vec3(.15,.2,.3);lin+=bac*vec3(.1);return lin;}\n\nv33 calcRayForPixel(vec2 pix,vec2 res\n){vec2 p=(-res.xy+2.0*pix)/res.y\n ;vec3 ro,ta\n ;calcCamera(ro,ta)\n ;vec3 w=normalize(ta-ro)\n ;vec3 u=normalize(cross(w,vec3(0,1,0)))\n ;vec3 rd=normalize(p.x*u+p.y*normalize(cross(u,w))+1.5*w)\n ;return v33(ro,rd);}\n\nvoid mainImage(out vec4 fragColor,vec2 fragCoord\n){vec2 res=vec2(iResolution.x/3.0,iResolution.y)\n ;int id=int(floor(fragCoord.x/res.x))\n ;vec2 px=vec2(fragCoord.x-float(id)*res.x,fragCoord.y)\n ;v33 r0=calcRayForPixel(px+vec2(0,0),res)\n ;vec3 pos,nor\n ;float occ,mid;float t=intersect(r0.a,r0.b,pos,nor,occ,mid)\n ;vec3 col=vec3(.9)\n ;if(t<100.\n //todo,measure angle between normal and rayDirection,and only do  #if 1 for anggles>45deg;\n //todo,there is a precision fix for near-orthogonal normals to camera that may be good here.\n  #if 1\n ){vec3 uvw=pos*scale//analytic ray-differential is in object-space\n   ;v33 rx=calcRayForPixel(px+vec2(1,0),res);\n   ;v33 ry=calcRayForPixel(px+vec2(0,1),res);\n   ;rayTransp(rx,ry)//swap rx.b with ry.a and the lines below become more symmetric: yes,this swaps the origin of one ray with the direction of another.\n   ;v33 w=mul(ry,dt(sub(rx,pos),nor)/dt(ry,nor))\n   ;w=subc(rx,w)\n   ;w=mul(sub(w,pos),scale)\n #else\n ){vec3 uvw=pos*scale;v33 w=v33(dFdx(uvw),dFdy(uvw))//semi-analogously use dFdx()dFdy()in screenspace has bad borders\n #endif\n  ;vec3 m=vec3(0)\n  ;w.a=maab2(w)\n  ;if(id==0)m=vec3(1)*checker(uvw)\n  ;else if(id==1)m=vec3(1)*checkerF2(uvw,w.a)\n  ;else if(id==2)m=vec3(1)*checkerF3(uvw,w.a)\n  ;col=m*doLighting(pos,vec3(.57703),nor,occ)\n  //;col=mix(col,vec3(.9),1.-exp(-.0001*t*t))// fog  \n ;}\n ;col=pow(col,vec3(.4545))//gamma\n ;col*=smoothstep(2.,3.,abs(px.x))//frame border lines\n ;fragColor=vec4(col,1);}\n ", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/lldyzM.jpg", "access": "shaders20k", "license": "mit", "functions": [[3872, 3952, 3992, 3992, 4018], [4018, 4067, 4089, 4089, 4114], [4114, 4262, 4285, 4285, 4314], [4314, 4334, 4357, 4357, 4386], [4386, 4403, 4426, 4426, 4455], [4455, 4482, 4503, 4503, 4543], [4543, 4570, 4592, 4592, 4615], [4616, 4616, 4638, 4638, 4667], [4668, 4668, 4689, 4689, 4718], [4718, 4730, 4752, 4752, 4781], [4782, 4782, 4805, 4805, 4830], [4833, 4833, 4852, 4852, 4875], [5043, 5165, 5183, 5183, 5205], [5206, 5206, 5224, 5224, 5244], [5245, 5245, 5263, 5263, 5283], [5284, 5284, 5302, 5302, 5323], [5324, 5324, 5342, 5342, 5375], [5376, 5376, 5396, 5396, 5424], [5691, 5837, 5868, 5868, 6013], [6013, 6130, 6161, 6161, 6317], [6365, 6400, 6425, 6425, 6530], [6531, 6550, 6588, 6588, 6648], [6650, 6650, 6678, 6678, 6771], [6773, 6773, 6861, 6861, 7360], [7362, 7362, 7403, 7403, 7482], [7484, 7484, 7536, 7536, 7847], [7849, 7849, 7889, 7889, 8100], [8102, 8102, 8153, 8153, 9559]], "test": "untested"}
{"id": "lltcR7", "name": "hex wallpaper tiling skew", "author": "ollj", "description": "square to hex skewing, with rotation, with voronoi for a seamless mouse.\n//with a very symmetrical \"wiggly j shape\"\n\n//this is an attempt to generalize some wallpapewr tilings.", "tags": ["square", "barycentric", "hex", "symmetry", "skew", "wallpaper", "wallpapergroup", "skewconstant"], "likes": 1, "viewed": 417, "published": "Public API", "date": "1532087798", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n\n//attempt at wallpaper-tiling generalization\n//the simplest one already exists in 3 shapes, which generalizes in a skew AND a rotation.\n//and this does not even cover rectangles.\n\n//need to learn more about barycentric ,  homogeneous2d stuff.\n\n//https://www.shadertoy.com/view/Xs2fRd\n//originally a 2d simplex illustration, but mostly liked for its skew() function\n\n//MirrorTest i a bit buggy attempt to extend into more symmetry, but the mirror gets skewed badly.\n//#define MirrorTest\n\nfloat F=0.36602540378;// sqrt(3.)*.5-.5\nfloat G=0.21132486540;//(sqrt(3.)*.5-.5)/sqrt(3.)= .5-(.5/sqrt(3.))\nfloat TAU=6.28318530718;\nfloat L=10.0;\n\n#define pi acos(-1.)\n#define sat(x)clamp(x,0.,1.)\n#define dd(a)dot(a,a)\n#define u5(a) ((a)*.5+.5)\n#define u2(a) ((a)*2.-1.)\n#define ss(a,u)smoothstep(a,-a,u)\n#define v0 float\n#define v1 vec2\n#define v2 vec3\n#define v3 vec4\nv0 suv(v3 a){return dot(v3(1),a);}v0 suv(v2 a){return dot(v2(1),a);}\nv0 suv(v1 a){return a.x+a.y;}//sum of vector\nv0 mav(v1 a){return max(a.y,a.x);}v0 mav(v2 a){return max(a.z,mav(a.xy));}v0 mav(v3 a){return max(mav(a.zw),mav(a.xy));}\n#define miv(a)-mav(-a)\n\n#define mStretch(u,m).5*(sign(u)*m-u)*((sign(abs(u)-m))+1.)\n\nvec2 cs(float a){return vec2(cos(a),sin(a));}\nmat2 r2(float a){vec2 s=cs(a);return mat2(s,-s.y,s.x);}\n\n#define mad(a,b,c) ((a)*(b)+(c))\n#define ab012(a,b) mad(vec3(0,1,2),b,a)\n#define c11(a,b) clamp(a/b,-1.,1.)*b\n\n//https://www.shadertoy.com/view/Xs2fRd\nvec2 skew(vec2 p){float f=(p.x+p.y)* F;return p+vec2(f,f);}\nvec2 unskew(vec2 q){float g=(q.x+q.y)* G;return q-vec2(g,g);}\n\n\n//generalized \"rainbow\" by ollj\n//return y of f(u.x)which is a triangle wave,slanted sideways by u.x that is also sinusoidial continuity,but not for: 0.!=u.y!=1.\n//looks best if u.y=clamp(m.x,0.,1.)-15./iResolution.y;, for a \"smoothstepSine()wihin 1/15 subpixel.\nfloat sawCos(vec2 u){u.x=fract(u.x);u+=(1.-2.*u)*step(u.y,u.x);\n return cos(clamp(1.-u.x/u.y,0.,1.)*pi)*.5+.5;}\nfloat sawCos(float a,float b){return sawCos(vec2(a,b));}\n//this basically replaces c.g=smoothstep(aa,-aa,c.g);\nfloat sawCos(float a){return sawCos(a,1.-15./iResolution.y);}\n\nvec3 sawCos(vec3 a,vec3 b){a=fract(a);vec3 s=step(b,a);return u5(cos(sat(1.-(a-u2(a)*s)/(b-u2(b)*s))*pi));}//b range [0..1]\n//c=sawCos(vec3(u.x*10.),vec3(.25,.5,.75))\n\nvec3 rainbow(float a,float b){return abs(u2(fract(ab012(a,b))));}//tri rainbow with offsets\nvec3 rainbow2(float a,float b){return u5(cos(2.*pi*ab012(a,b)));}//cos rainbow with offsets\n//getting sawcos to generallygo from purple to purple is a challenge that i refuse for now.\nvec3 rainbow3(float a,float b){return (sawCos(ab012(a+.5,b),vec3(.75)));}//sawCos rainbow with offsets\n\n\n//good rainbow-gradients ALWAYS center green|white and border purple|black\n//m.x sets saturation==transition by shifting blue|red rang[-.1,.5]\n//m.y sets \"flimmer\", range [-.159 ... 159]\n//p is a flimmer-phase that modulates the shorter subwave of red (green) blue;try; p=1.+vec3(-1,0,1)*cos(iGlobalTime*.001)\nvec3 rainbowN(vec2 u,vec2 m,vec3 p\n){vec3 c=vec3(1)//;m=vec2(0)//simple case\n //;c=sawCos(vec3(u.x*10.),vec3(.25,.5,.75))\n ;m.x=c11(-m.x,.5)//good optional bounds, sign negation for utility.\n ;m.y=c11(m.y,.159)//decent optional bounds to stay in visible range\n ;m.y=m.y*pi+.5\n ;m.y=u5(m.y)\n ;c=rainbow3(u.x-m.x*.5,fract(m.x*.6))//the .mx/2 ensures that white/green stays centred and purple stys bordered;\n //;c=mix(c*m.y,c,cos(u.x*p*iResolution.x/4.))\n ;c=mix(c*m.y,c,sawCos(u.x*p*iResolution.x/4.,vec3(.8)))\n ;vec2 v=u\n ;u.x*=m.y\n ;float g=cos(iTime)//;g=.1//a 3rd domain as time for demoing, whould actually be constant\n //;c=gradVis(c,u,v)//a graph plotter, not included here.\n ;return c;}\n\nvec3 rainbowN11(vec2 u){return rainbowN(u,vec2(1),vec3(1));}\n\n#define doublestretch\nfloat jj(vec2 u,vec2 m){u+=m*.5\n ;if(u.y<1.&&u.x>-1.)return abs(length(u-vec2(-1,1))-2.)//<-bottom right curve;\n //i do not like double &&,but at least its not ||\n //straight is more complex than curved part above:\n ;m=abs(m)\n ;vec2 b=vec2(u.x-1.,mStretch((u.y-1.),m.y))//<-top right straight has priority\n ;u.y+=1.\n #ifdef doublestretch\n  ;u.x=mStretch(u.x,(m.x+1.));//bottom left straight STRETCH is optional here\n #else\n  ;u.x+=1.\n #endif \n ;vec2 c=u*sign(u.x+u.y+2.001)//<-bottom left straight,includes uncanny reflection\n ;u.y=sign(u.y-1.)+1.\n ;vec2 p=.5*u.y*(b+c)-c\n //;p=mix(c,b,sign(u.y-1.)*.5+.5)\n ;return length(p);}//delaying the length()nicely.\n\n\nfloat TinyDith(vec2 a){;if(fract(a.x*a.y)>.5)return 1.;return 0.;}\n\n\nvoid mainImage(out vec4 o,vec2 u\n){float td=TinyDith(u)//basic dithering of 2 complemenraty, usually alternating complemenraty colors, avoids a mixing to grey.\n ;u=u-.5*iResolution.xy; \n ;vec2 U=u\n ;vec2 m=iMouse.xy-.5*iResolution.xy; \n ;mat2 r=mat2(1)\n ;if(u.x>0.)r=r2(iTime*.1)\n ;u*=r\n ;m*=r\n ;float t=cos(iTime+pi)*.5+.5\n ;o=vec4(1)\n ;u/=164.;m/=164.\n ;if(U.y<0.\n ){u=mix(u,skew(u),t)//t*skew(u)+(1.-t)*u\n  ;m=mix(m,skew(m),t)\n ;}\n ;vec2 a=u-fract(u+.5)//fract,with offset\n ;     u=u-floor(u+.5)//floor,with offset\n ;     m=m-floor(m+.5)//floor,with offset \n #ifdef MirrorTest\n ;if(td>.5){ //additional symmetry is ghosted\n  ;if(u.x<.0)u.x=-u.x//works but is not super pretty (the mirror is skewed badly)\n  //;if(u.x<u.y)u=-u//works but is not pretty (more issues)\n  //;if(u.y<.0)u.y=-u.y//works but is is dumb and doesnt fo gell with a j-shape (more issues)\n ;}\n #endif\n \n ;vec2 k=vec2(1,4)+vec2(.5,2)*cs(iTime*8.+a.x*4.-a.y*sqrt(5.))*.5+.5//wiggly j-shape proportions tile dependent\n ;vec2 K=vec2(1,4)+vec2(.5,2)*cs(iTime*8.                    )*.5+.5//wiggly j-shape proportions\n //uniting both would require to calculate the above wiggle 9times, witzhin the O(n*n) loop below, not doing that\n \n ;float phi=sqrt(5.)*.5+.5\n ;o.xyz=rainbowN11((a+a.yx)*phi)//base tile color\n ;o.xyz-=smoothstep(.1,-.1,u.x-u.y)*u2(o.xyz)\n //if(u.x>u.y)\n //;if(u.x>u.y)o.xyz=1.-o.xyz\n //optionally complementary color over diagonal\n ;float d=0.\n ;for (float i=-1.;i<2.;i++){for (float j=-1.;j<2.;j++){//3x3 taps to be continuous over borders is only needed to read mouse over tile borders.\n ;vec2 a=u-m+vec2(i,j)\n ;if(U.y<0.)a=mix(a,unskew(a),t)\n ;a=r*a\n ;d+=smoothstep(.01,-.01,jj(a*19.,K)-.3)\n ;}}\n ;o.xyz+=d//white dot\n ;if(U.y<0.)u=mix(u,unskew(u),t)\n ;u=r*u\n ;if(jj((u-r*vec2(.3,0))*19.,k)<.3)o=vec4(0,0,0,1)//black dots\n ;U=abs(U)\n ;o=smoothstep(.5,-.5,min(U.x,U.y)-1.)*(vec4(.5,.5,.5,1.)-o)+o\n  ;}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/lltcR7.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[511, 860, 873, 873, 894], [894, 894, 907, 907, 928], [929, 929, 942, 942, 958], [958, 974, 987, 987, 1008], [1008, 1008, 1021, 1021, 1048], [1048, 1048, 1061, 1061, 1094], [1180, 1180, 1197, 1197, 1225], [1226, 1226, 1243, 1243, 1281], [1394, 1434, 1452, 1452, 1493], [1494, 1494, 1514, 1514, 1555], [1558, 1821, 1842, 1842, 1932], [1933, 1933, 1963, 1963, 1989], [1990, 2044, 2066, 2066, 2105], [2107, 2107, 2134, 2134, 2214], [2214, 2275, 2305, 2305, 2340], [2340, 2367, 2398, 2398, 2432], [2432, 2551, 2582, 2582, 2624], [2656, 2966, 3003, 3003, 3658], [3660, 3660, 3684, 3684, 3720], [3744, 3744, 3768, 3768, 4370], [4370, 4403, 4426, 4426, 4469], [4472, 4472, 4507, 4507, 6361]], "test": "untested"}
{"id": "lltyR7", "name": "optical circuit deconstruction D", "author": "ollj", "description": "the optical circuit shader, deconsonstructed a lot, wiiiththt a l ot oannotations\nosource shader was very crypptic, short labeels eveverywhere.", "tags": ["optical", "circuit", "deconstruction"], "likes": 14, "viewed": 594, "published": "Public API", "date": "1532086982", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n//parent: https://www.shadertoy.com/view/MlfczH\n//Optical-Circuit optical circuit scene 1 deconstruction a\n\n/*\nthe [optical circuit demo] video source code once appeared on glslsandbox.com\n\nwww.pouet.net/prod.php?which=65125\nhttps://www.youtube.com/watch?v=ISkIB4w6v6I\n\nIt is fractal code golf overkill in [0..6] scenes.\nThis is a deconstruction of scene 1. ,not the whole demo.\nUn-used functions(only used in other scenes)are removed;\nscene-specific branches are set to 1,or removed \n...(multiplying by *0. or adding -0 iterations)\n... all changes are annotated.\n\nThis may run slightly faster due to removing all schene-specific branching\nMost of that modifies iteration count(between scenes,which are static per shader)\nThe [smart re-use of schene specific branches and modifiers] is what makes this a 4k demo.\n... at a cost of running slightly slower,by summing up scene-modifiers.\n\nmost recent approach in summer 2018,removed globals and idenfified a lot of functions into subroutines.\nthe \"hashes\" are a bit unusual,overly specific but fine.\n//this is now very sorted and demystified.\n//it sure has an awesomely extended volume marcher for glow and accumulators for it\nand thats glow-marching\n*/\n\n#define tim (iTime+timeOffset)\n\n#define iterO 4\n#define iterVolume 32\n\n//#define scene 1\n#define timeOffset 115.984024\n\n#define dd(a)dot(a,a)\n#define v0 float\n#define v1 vec2\n#define v2 vec3\n#define v3 vec4\n#define fra(u)(u-.5*iResolution.xy)*ViewZoom/iResolution.y\nv0 mav(v1 a){return max(a.y,a.x);}\nv0 mav(v2 a){return max(a.z,mav(a.xy));}\nv0 mav(v3 a){return max(mav(a.zw),mav(a.xy));}\n#define miv(a)-mav(-a)\nfloat vsum(vec3 a){return dot(a,vec3(1));}//dot()is generally faster on a gpu than 2add()\n //return a.x+a.y+a.z;}\n\nconst float pi=acos(-1.);//3.14\nconst float t0=sqrt(.5);//0.707\n\n#define tswap h=j;j=k;k=l\n\n//return a,rotated by b,originally called F()\nvec3 rot(vec3 a,float b){float c=sin(b),d=cos(b);return mat3(d,-c,0,c,d,0,0,0,1)*a;}\n\n//fractal glowing planes\nvec3 G(vec3 a,float b\n){a=fract(a*.2)*2.-1.\n ;a.z=b\n ;float c=50.//brightness modifier\n ;for(int i=0;i<6;++i//iteration count is scene specific\n){float d=clamp(dd(a),.05,.65);\n  ;c*=d;\n  ;a=abs(a)/d-1.31;\n  ;a.xy=a.xy*mat2(1,1,-1,1)*t0\n ;}return a*c;}\n \n //i thought this id some 4d magic,but it is barely 3d. \n //its core hash is 2d,used to move planes endlessly\n //and one extension in 3d of it exists,so its barely 3d.\n\n//sub of W and I(both aren ot in scene1)\nvec3 vV(float a,vec3 b,float c,float V){a*=c;return 1./((1.+2.*b/a+b*b/(a*a))*c+.0001);}\n//only used twice in mainImage,a and b and c are the same both times.\nvec3 wW(vec3 a,float b,float c,float d,float V\n){vec3 e=(vV(.01,abs(a),d,V)*2.+vV(.05,vec3(length(a.yz),length(a.zx),length(a.xy)),d,V)*5.)\n  *(sin(tim*vec3(2.1,1.3,1.7)+b*10.)+1.)\n ;return(e*7.+e.yzx*1.5+e.zxy*1.5)*max(1.-c*200./d,0.)/d*float(100-30);}//is scene specific\n\n//L M N O define the dark fractal shape,O is a fractal,L M N are a \"strange hash\"\n//L is sub of M and N\n//faL generates \"continuously moving planes\"\nfloat faL(vec2 a){vec2 b=abs(fract(a.xy+vec2(0,.5))-.5),c=abs(fract(a.xy+.5)-.5);b.x-=.46;return .033-min(mav(b),.08-mav(c));}\n//M is sub of N\n//\nfloat faM(vec3 a){vec3 b=abs(fract(a*4.+.5)-.5)*.25;return max(mav(b)-.08,max(faL(a.xy)-.01,.012-length(fract(a*25.)-.5)*.04));}\n//M is sub of O\nfloat fa6n(vec3 a){\n ;return min(miv(vec4(faM(a),faM(a.zyx),faM(a.zxy),faL(a.xy))),miv(vec2(faL(a.zy),faL(a.zx))));}\n \n\n//o is used once by T(),o defines a black fractal as base geometry\nfloat blackFractalO(vec3 a\n){vec4 b=vec4((fract(a*.2+.5)-.5)*4.,1.)\n ;for(int i=0;i<iterO;++i\n){b.xyz=clamp(b.xyz,-1.,1.)*2.-b.xyz\n  ;b*=clamp(max(.21/dd(b.xyz),.21),.0,1.)*-15.7\n  ;}a=b.xyz/b.w*5.;return max(length(a)-1.,fa6n(a))*.25;}\n//used 5* in mainImage T is a very schene specific function;\n\nfloat spereRows(vec3 c,vec3 e){//rows of spheres to look like hovercar highways\n ;float r=max(length(c)-.006,faL(c.xy*10.)*.1-.0002)\n ;r=min(r,.04)\n ;r=max(r,mav(e.xz)-.05)\n ;return r;}\n\nfloat fractalFloor(vec3 a//a is position relative to camera,assume staric camera.\n){float r\n ;float d=mav(abs(fract(a*2.0)-.5)*.5);//for scene1,K()is 100% absorbed into T.fractalFloor into this line\n ;r=max(d-.201,blackFractalO(a))//this line is the only line that includes \"blackFractalO()\"\n ;r=min(r,.299-d)//i see no difference woithout this line\n ;r=max(r,length(a)-20.)//car´rve hole aroudn camera\n ;return r;}\n\n\nfloat BlackObjectT(vec3 a//black solid object,mostly defined by endlessly moving planes(removed from something)\n){vec3 b=a*20.\n ;b.y+=tim*5.*(fract(dot(floor(b),vec3(1,0,1))*pi)-.5)\n ;vec3 c=rot((fract(b.zxy)-.5)*.05,tim*8.*(fract(dot(floor(b),vec3(pi)))-.5))\n ,e=abs(fract(a+vec3(.5,.5,0))-.5)\n ;a=rot(a,tim*.025*(fract((a.z*2.-fract(a.z*2.))*.437)-.5))\n ;float r=fractalFloor(a)\n ;r=min(r,spereRows(c,e))\n ;return r;}\n\n\nvoid shuffle(inout vec4 h,inout vec4 j,inout vec4 k,inout vec4 l,int m){\n int a=m;for(int i=0;i<4;++i)if(a<4){tswap;++a;};}\n//h,j,j,l are accumulators witthing raymarching,used for \"noisy fog\"\n\nvec3 IterVol(vec4 h,vec4 j,vec4 k,vec4 l,vec3 g,float D,int m\n){shuffle(h,j,k,l,m);\n ;float o=1.,p=.0,t=.0,q=D*.1+.9,W,V\n ,n=length(j.xyz-h.xyz)\n ;vec3 f=normalize(j.xyz-h.xyz),e=h.xyz,c=vec3(1),b=vec3(0)\n ;for(int i=0;i<iterVolume;++i\n){if(t>n\n ){if(m<3)break\n   ;tswap\n   ;e=h.xyz;f=normalize(j.xyz-h.xyz);n=length(j.xyz-h.xyz)//j and h can have changed due to tswap()\n   ;--m\n   ;t=0.\n   ;if(n<.0001)break\n   ;float r=fract(h.w)\n   ;o=h.w-r\n   ;p=(floor(j.w)-o)/n\n   ;c*=mix(vec3(.17,.15,.12),vec3(1),r);}\n  ;g=e+f*t\n  ;//next 5 lines are scene specific\n  ;float u=abs(fract(g.z)-.5)//this line 100% absorbs U(),for scene1\n  ;g-=vec3(0,0,vec2(sign(fract(g.z)-.5)))*u\n  ;float v=sin(tim*.05+g.z)*.5,w=u*q+.001\n  ;vec3 x=G(g,v)\n  ;b+=(wW(x,v,u,o+p*t,V)+wW(x,v,u,o+p*t+50.,V))*c*w\n  ;c*=pow(.7,w)\n  ;t+=w;}\n ;return b;}\n\n\nvoid rm(inout vec4 h,inout vec4 j,inout vec4 k,inout vec4 l,inout vec3 g,vec3 f,inout int m,float D){\n ;f=normalize(f)//for reflection\n ;vec3 e=g\n ;vec3 s=vec3(1,-1,-1)*.0005 //epsilon\n ;float t=0.,o=1.,p=1.,q=D*.01+.99,n\n ;//raymarching loop:\n ;for(int i=0;i<64;++i\n){g=e+f*t\n  ;float d=BlackObjectT(g)\n  ;if(d<(t*5.+1.)*.0001\n ){vec3 u=normalize(BlackObjectT(g+s)*s+BlackObjectT(g+s.yyx)*s.yyx+BlackObjectT(g+s.yxy)*s.yxy+BlackObjectT(g+s.xxx)*s.xxx)\n   ;float r=pow(abs(1.-abs(dot(u,f))),5.)*.9+.1\n   ;o+=t*p\n   ;p=p*5./r\n   ;e=g+u*.0001\n   ;f=reflect(f,u)\n   ;t=.0\n   ;float v=dd(u)\n   ;if(v<.9||1.1<v||v!=v)u=vec3(0)\n   ;if(m<4){tswap;l=vec4(g,max(floor(o),1.)+clamp(r,.001,.999))\n   ;++m\n ;}}else t=min(t+d*q,100.)\n ;}\n ;if(m<4){tswap;l=vec4(g,o+t*p);++m;}\n ;}\n\nvec3 cam(vec3 c,vec3 b,vec2 glVertex){\n ;vec3 ee=normalize(vec3(sin(vec2(.53,.47)*tim)*4.+sin(vec2(.91,1.1)*tim)*2.+sin(vec2(2.3,1.7)* tim),200))\n ;vec3 ff=normalize(cross(ee,vec3(sin(tim),50,0)))\n ;return mat3(c,cross(c,b),b)*(ff*glVertex.x*1.78+cross(ff,ee)*glVertex.y+ee*1.4);}\n\n//#define resolution iResolution\nvoid mainImage(out vec4 O,in vec2 Uuu\n){//this  seems to have been an Initiation procedure,as it sets global vars.\n ;vec3 a=normalize(sin(tim*.001*vec3(21,11,17)))*20.1//basic orbit feeds into many things\n ;vec3 b=normalize(sin(tim*.001*vec3(26,106,62))-a*.05)//feeds into looking direction\n ;vec3 c=normalize(cross(b,sin(tim*.001*vec3(31,17,29))))//feeds into looking direction\n ;c=cam(c,b,Uuu.xy/iResolution.xy*2.-1.)//looking direction\n ;float D=fract(sin(vsum(c)*99.317*pi)*85.081*pi)//camera path\n ;vec4 l=vec4(a,1),k=l*.0,j=k,h=j;int m=1//inout to shuffle to scatter glowing fog\n ;rm(h,j,k,l,a,c,m,D)//a very extended raymarching function\n ;O=vec4(pow(IterVol(h,j,k,l,a,D,m),vec3(.45)),1);}\n\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/lltyR7.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1274, 1469, 1482, 1482, 1503], [1504, 1504, 1517, 1517, 1544], [1545, 1545, 1558, 1558, 1591], [1615, 1615, 1634, 1634, 1657], [1822, 1868, 1893, 1893, 1952], [1954, 1979, 2003, 2003, 2230], [2402, 2443, 2483, 2483, 2531], [2532, 2602, 2651, 2651, 2855], [2876, 3025, 3043, 3043, 3151], [3152, 3171, 3189, 3189, 3299], [3300, 3316, 3335, 3335, 3432], [3436, 3503, 3532, 3532, 3739], [3740, 3802, 3833, 3881, 3987], [3989, 3989, 4073, 4073, 4405], [4408, 4408, 4522, 4522, 4827], [4830, 4830, 4902, 4902, 4953], [4954, 5024, 5088, 5088, 5843], [5846, 5846, 5947, 5947, 6612], [6614, 6614, 6652, 6652, 6894], [6896, 6929, 6969, 7043, 7625]], "test": "untested"}
{"id": "lltyzr", "name": "stest", "author": "ide", "description": "learning shadertoy and test it!", "tags": ["test"], "likes": 0, "viewed": 68, "published": "Public", "date": "1531383855", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float Circle(vec2 uv,vec2 pos,float r,float blur){\n    float d= length(uv -pos);\n\n    float c=smoothstep(r,r-blur,d);\n    return c;\n}\n\nfloat Band(float t,float start,float end,float blur){\n\tfloat step1=smoothstep(start-blur,start+blur,t);\n   \tfloat step2=smoothstep(end+blur,end-blur,t);\n    return step2*step1;\n\n}\nfloat Rect(vec2 uv,float left,float right,float bottom,float top,float blur){\n\tfloat band1=Band(uv.x,left,right,blur);\n    float band2=Band(uv.y,bottom,top,blur);\n    return band1*band2;\n}\n\nfloat smile(vec2 uv,vec2 pos,float size){\n\n    uv-=pos;\n    uv/=size;\t\n    float mask=Circle(uv,vec2(0.0,0.0),0.3,0.01);\n    mask-=Circle(uv,vec2(0.13,0.1),0.07,0.01);\n    mask-=Circle(uv,vec2(-0.13,0.1),0.07,0.01);\n    \n    float mouse=Circle(uv,vec2(0.0,-.02),0.2,0.01);\n    mouse-=Circle(uv,vec2(0.0,.02),0.2,0.01);\n    \n    mouse=max(0.,mouse);\n    mask-=mouse;\n    return mask;\n}\n\nfloat remap01(float a,float b,float t){\n\treturn (t-a)/(b-a);\n}\nfloat remap(float a ,float b,float c,float d,float t){\n\treturn remap01(a,b,t)*(d-c) +c; \n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n   \n\tuv -=0.5;\n    uv.x*=iResolution.x/iResolution.y;\n\t\n    \n\t\n    //float mask=smile(uv,vec2(0.3,0.),0.5);\n    //float mask=Band(uv.x,-.3,.4,.01);\n    \n    float x= uv.x;\n    float y=uv.y;\n    x+=y*.0; //倾斜\n    \n    float m= -(x-.5)*(x+.5);\n    m=m*m*4.;\n    m=sin(x*10.5+iTime*5.)*.1;\n    y-=m;\n    //float mask= Rect(vec2(x,y),-.3+y,.3,-.2,.4,.01);// 梯形 三角形\n    float blur=remap(-.5,.5,0.01,.2,x);\n    float mask= Rect(vec2(x,y),-.5,.5,-.1,.1,blur);\n    vec3 col= vec3(.9,.91,0.);\n    fragColor = vec4(col*mask,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/lltyzr.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 50, 50, 133], [135, 135, 188, 188, 314], [315, 315, 392, 392, 503], [505, 505, 546, 546, 889], [891, 891, 930, 930, 953], [954, 954, 1008, 1008, 1044], [1045, 1045, 1102, 1158, 1734]], "test": "untested"}
{"id": "lsVBD3", "name": "Nice Shades", "author": "MadcoreTom", "description": "Test maintaining bright colours on a sphere, with a clear edge between lit and shaded sides", "tags": ["sphere", "shading"], "likes": 7, "viewed": 115, "published": "Public", "date": "1530871561", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Based on shader by zavie https://www.shadertoy.com/view/XsfXDr\n\tfloat ratio = iResolution.x / iResolution.y;\n\tvec2 uv = vec2(ratio, 1.) * (2. * fragCoord.xy / iResolution.xy - 1.);\n\t\n    vec3 n = vec3(uv, sqrt(1. - clamp(dot(uv, uv), 0., 1.)));\n\n    vec3 norm =n;// 0.5 + 0.5 * n;\n\n    \n    // the rest is my code\n    \n    // pick A colour\n    vec4 col = vec4(0.9,0.2,0.5,1.0);\n    if(iMouse.x > 0.5 * iResolution.x){\n        col = vec4(0.5,0.9,0.2,1.0);\n    } else if(iMouse.x > 0.4 * iResolution.x){\n        col = vec4(0.2,0.5,0.9,1.0);\n    } else if(iMouse.x > 0.3 * iResolution.x){\n        col = vec4(0.9,0.5,0.2,1.0);\n    } else if(iMouse.x > 0.2 * iResolution.x){\n        col = vec4(0.7,0.6,0.5,1.0);\n    }\n    \n    // light it\n    vec3 light = vec3(sin(iTime),0.6,1.0);\n    if(norm.b != 0.0) {\n        float d = dot(light,norm);\n        col *= pow((d*0.5+0.5),0.5);\n        \n    \tif(d< 0.25 ){\n            // in shade, make a bit bluer, and make darker\n            col = (col*1.9 - vec4(0.15,0.15,0.0,0.0)) / 2.0;\n    \t}\n    } else {\n        // Background is dark grey\n        col = vec4(0.1,0.1,0.1,1.0);\n    }\n    \n    \n\tfragColor = col;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/lsVBD3.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 1, 58, 128, 1214]], "test": "untested"}
{"id": "lsVBDV", "name": "Distortion - cat like thingy", "author": "luka712", "description": "Simple distortion shader with meta balls", "tags": ["distortion"], "likes": 5, "viewed": 168, "published": "Public", "date": "1530663505", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\nfloat Circle(vec2 uv, vec2 pos, float r){\n \t\n    float d = length(uv - pos);\n    return r / d;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    uv -= .5;\n    \n    float r = .25;\n    \n    uv.x *= iResolution.x / iResolution.y;\n    \n    float X = uv.x * 6. + iTime;\n    float Y = uv.y * 6. + iTime;\n    \n    uv.x += cos(X + Y) * 0.01 * cos(Y);\n    uv.y += sin(X + Y) * 0.01 * sin(Y);\n\n    // eyes\n    float c = Circle(uv, vec2(-.25, 0.1), r);\n    c += Circle(uv, vec2(.25, 0.1), r);\n    \n    \n    uv.x *= .6;\n    uv.y *= 3.;\n    float n = Circle(uv, vec2(.0, -0.3), r * .25);\n    \n    c += n;\n\n    \n\n    // Output to screen\n    fragColor = vec4(vec3(0.), 1.) + vec4(0.1 * c, .1 * c, .8 * c, 1.) * c;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/lsVBDV.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 1, 42, 42, 97], [99, 99, 156, 206, 806]], "test": "untested"}
{"id": "lsVBWV", "name": "Simplex Noise", "author": "pixelfiend", "description": "Drag your mouse around to control size and speed of simplex noise.\nSpeed: drag up / down\nSize: drag left / right\n", "tags": ["noise", "interactive", "simplex"], "likes": 3, "viewed": 99, "published": "Public", "date": "1530643452", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//\n// Description : Array and textureless GLSL 2D/3D/4D simplex \n//               noise functions.\n//      Author : Ian McEwan, Ashima Arts.\n//  Maintainer : stegu\n//     Lastmod : 20110822 (ijm)\n//     License : Copyright (C) 2011 Ashima Arts. All rights reserved.\n//               Distributed under the MIT License. See LICENSE file.\n//               https://github.com/ashima/webgl-noise\n//               https://github.com/stegu/webgl-noise\n// \n\nvec3 mod289(vec3 x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 mod289(vec4 x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 permute(vec4 x) {\n     return mod289(((x*34.0)+1.0)*x);\n}\n\nvec4 taylorInvSqrt(vec4 r){\n  return 1.79284291400159 - 0.85373472095314 * r;\n}\n\nfloat snoise(vec3 v){ \n  const vec2  C = vec2(1.0/6.0, 1.0/3.0) ;\n  const vec4  D = vec4(0.0, 0.5, 1.0, 2.0);\n\n  // First corner\n  vec3 i  = floor(v + dot(v, C.yyy) );\n  vec3 x0 =   v - i + dot(i, C.xxx) ;\n\n  // Other corners\n  vec3 g = step(x0.yzx, x0.xyz);\n  vec3 l = 1.0 - g;\n  vec3 i1 = min( g.xyz, l.zxy );\n  vec3 i2 = max( g.xyz, l.zxy );\n\n  //   x0 = x0 - 0.0 + 0.0 * C.xxx;\n  //   x1 = x0 - i1  + 1.0 * C.xxx;\n  //   x2 = x0 - i2  + 2.0 * C.xxx;\n  //   x3 = x0 - 1.0 + 3.0 * C.xxx;\n  vec3 x1 = x0 - i1 + C.xxx;\n  vec3 x2 = x0 - i2 + C.yyy; // 2.0*C.x = 1/3 = C.y\n  vec3 x3 = x0 - D.yyy;      // -1.0+3.0*C.x = -0.5 = -D.y\n\n  // Permutations\n  i = mod289(i); \n  vec4 p = permute( permute( permute( \n             i.z + vec4(0.0, i1.z, i2.z, 1.0 ))\n           + i.y + vec4(0.0, i1.y, i2.y, 1.0 )) \n           + i.x + vec4(0.0, i1.x, i2.x, 1.0 ));\n\n  // Gradients: 7x7 points over a square, mapped onto an octahedron.\n  // The ring size 17*17 = 289 is close to a multiple of 49 (49*6 = 294)\n  float n_ = 0.142857142857; // 1.0/7.0\n  vec3  ns = n_ * D.wyz - D.xzx;\n\n  vec4 j = p - 49.0 * floor(p * ns.z * ns.z);  //  mod(p,7*7)\n\n  vec4 x_ = floor(j * ns.z);\n  vec4 y_ = floor(j - 7.0 * x_ );    // mod(j,N)\n\n  vec4 x = x_ *ns.x + ns.yyyy;\n  vec4 y = y_ *ns.x + ns.yyyy;\n  vec4 h = 1.0 - abs(x) - abs(y);\n\n  vec4 b0 = vec4( x.xy, y.xy );\n  vec4 b1 = vec4( x.zw, y.zw );\n\n  //vec4 s0 = vec4(lessThan(b0,0.0))*2.0 - 1.0;\n  //vec4 s1 = vec4(lessThan(b1,0.0))*2.0 - 1.0;\n  vec4 s0 = floor(b0)*2.0 + 1.0;\n  vec4 s1 = floor(b1)*2.0 + 1.0;\n  vec4 sh = -step(h, vec4(0.0));\n\n  vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy ;\n  vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww ;\n\n  vec3 p0 = vec3(a0.xy,h.x);\n  vec3 p1 = vec3(a0.zw,h.y);\n  vec3 p2 = vec3(a1.xy,h.z);\n  vec3 p3 = vec3(a1.zw,h.w);\n\n  //Normalise gradients\n  vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));\n  p0 *= norm.x;\n  p1 *= norm.y;\n  p2 *= norm.z;\n  p3 *= norm.w;\n\n  // Mix final noise value\n  vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n  m = m * m;\n  return 42.0 * dot( m*m, vec4( dot(p0,x0), dot(p1,x1), \n                                dot(p2,x2), dot(p3,x3) ) );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 uvMouse = iMouse.xy / iResolution.xy;\n    float size = uvMouse.x * 100. + 1.;\n    float speed = uvMouse.y * 3. + .1;\n    float val = snoise(vec3(uv.x * size, uv.y * size, iTime * speed));\n\tfragColor = vec4(val);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/lsVBWV.jpg", "access": "shaders20k", "license": "mit", "functions": [[0, 450, 471, 471, 520], [522, 522, 543, 543, 592], [594, 594, 616, 616, 656], [658, 658, 685, 685, 737], [739, 739, 760, 760, 2918], [2920, 2920, 2976, 2976, 3239]], "test": "untested"}
{"id": "lsyfDt", "name": "Civilization Planet", "author": "AsahiYao", "description": "a random planet generator", "tags": ["noise", "earth", "planet", "world"], "likes": 20, "viewed": 672, "published": "Public API", "date": "1531010576", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define mod3_           vec3(.1031, .22369, .13787)\n#define PI 3.1415926359\n\nvec3 hash3_3(vec3 p3) {\n\tp3 = fract(p3 * mod3_);\n    p3 += dot(p3, p3.yxz + 120.0);\n    // random3 has range 0 to 1\n    vec3 random3 = fract(vec3((p3.x + p3.y) * p3.z, (p3.x+p3.z) * p3.y, (p3.y+p3.z) * p3.x));\n    return normalize(-1. + 2. * random3);\n}\n\nfloat perlin_noise3(vec3 p) {\n    vec3 pi = floor(p);\n    vec3 pf = p - pi;\n    \n    // 5th order interpolant from Improved Perlin Noise\n    vec3 pf3 = pf * pf * pf;\n    vec3 pf4 = pf3 * pf;\n    vec3 pf5 = pf4 * pf;\n    vec3 w = 6. * pf5 - 15. * pf4 + 10. * pf3;\n    \n    return mix(\n    \tmix(\n            mix(\n                dot(pf - vec3(0, 0, 0), hash3_3(pi + vec3(0, 0, 0))), \n                dot(pf - vec3(1, 0, 0), hash3_3(pi + vec3(1, 0, 0))),\n                w.x),\n            mix(\n                dot(pf - vec3(0, 0, 1), hash3_3(pi + vec3(0, 0, 1))), \n                dot(pf - vec3(1, 0, 1), hash3_3(pi + vec3(1, 0, 1))),\n                w.x),\n    \tw.z),\n        mix(\n            mix(\n                dot(pf - vec3(0, 1, 0), hash3_3(pi + vec3(0, 1, 0))), \n                dot(pf - vec3(1, 1, 0), hash3_3(pi + vec3(1, 1, 0))),\n                w.x),\n            mix(\n                dot(pf - vec3(0, 1, 1), hash3_3(pi + vec3(0, 1, 1))), \n                dot(pf - vec3(1, 1, 1), hash3_3(pi + vec3(1, 1, 1))),\n                w.x),\n     \tw.z),\n\tw.y);\n}\n\nfloat restricted_perlin(vec3 pos) {\n    float perlin = perlin_noise3(pos);\n    float x = abs(perlin);\n    \n    float p = 0.5;\n    float q = 0.95;\n    float x1 = 0.5;\n    float x2 = 0.867;\n    float new = 0.0;\n    \n    float a = (q*p - x1) / x1 / x1;\n    float b = 1.;\n    float c = 0.;\n    if (x < x1) {\n        new = a * x * x + b * x + c;\n    } else {\n        float n = - (x2 - x1) * (2. * a * x1 + b) / (q*p - p);\n        float d = (q*p - p) / pow(x2 - x1, n);\n        new = d * pow(x2 - x, n) + p;\n    }\n    \n    return new * sign(perlin);\n}\n\n// -----------------------------------------------------------\n\n// Distance to a sphere centered at the origin\nfloat sdSphere(vec3 pos, float radius)\n{\n    return length(pos) - radius;\n}\n\n\n// Distance to a sphere with perlin noise perturbations\n// centered at the origin.\nfloat sdWeirdSphere(vec3 pos,float frequency) {\n    float noise = perlin_noise3(pos * frequency) / (1. * frequency * 1.32);\n\treturn mix(sdSphere(pos, 0.2) / 1.0,\n               noise,\n               0.85);\n}\n\nvec2 pos3t2(vec3 pos){\n\tfloat r = length(pos);\n\tfloat Y = acos(pos.y / r) / PI; \n\tfloat X = atan(-pos.z/r, pos.x/r) / PI / 2.0;\n    \n\treturn vec2(X,Y);\n}\nvec3 pos2t3(vec2 pos){\n\tfloat X = sin(pos.y*PI) * cos(pos.x* PI*2.0);\n\tfloat Y = cos(pos.y*PI);\n\tfloat Z = -sin(pos.y*PI) * sin(pos.x* PI*2.0);\n\treturn vec3(X,Y,Z);\n}\nfloat height(vec3 p){\n    float ret = sdWeirdSphere(p, 128.0);\n    ret += sdWeirdSphere(p, 64.0);\n    ret += sdWeirdSphere(p, 4.0);\n    ret += sdWeirdSphere(p, 2.0);\n    ret += sdWeirdSphere(p, 1.0);\n    ret += sdWeirdSphere(p, 8.0);\n    ret += sdWeirdSphere(p, 16.0);\n    ret += sdWeirdSphere(p, 32.0);\n    ret /= 2.0;\n    ret -= 0.5;\n    \n    return ret;\n}\n\nvec2 terrain(vec3 p, float h){\n\tfloat col = sdWeirdSphere(p, 32.0);\n    col += sdWeirdSphere(p, 16.0);\n    col += sdWeirdSphere(p, 4.0);\n    \n    float t = 1.0 - (abs(p.y*1.2) - max(h, 0.0)*0.05);\n    t = min((t+ col)/2.0, 1.0);\n    t = pow(t, 0.5) - 0.15;\n    \n    float s = abs((abs(p.y) - 0.5)*2.0);\n    s = min((s+ col)/2.0,1.0) + 0.25;\n    \n    return vec2(t , s);\n}\n\nvec3 color(vec3 p, vec2 th,float h){      \n    if(th.x<0.2)\n        return vec3(1,1,1) * pow(1.0 - min(th.x/0.2,1.0), 0.125)*2.0;\n    \n    vec3 sea = vec3(0,0.18,0.45);\n    if(h < 0.0)\n    \treturn sea * (1.0 + h * 2.0);\n    \n\tvec3 sand = vec3(0.9,0.66,0.3);\n    vec3 grass = vec3(0.05,0.4,0.05);\n    \n    float lp = (th.x + th.y*3.0)/3.0;\n    lp = clamp(lp, 0.0, 1.0);\n    \n    return mix(sand, grass, pow(lp, 8.0)) * (pow(h, 0.25)+ 0.5);\n}\n\nvec2 Spiral(vec2 uv)\n{\n\tfloat reps = 2.0;\n\tvec2 uv2 = fract(uv*reps);\n\tvec2 center = floor(fract(uv*reps)) + 0.5;\n\tvec2 delta = uv2 - center;\n\tfloat dist = length(delta);\n\tfloat angle = atan(delta.y, delta.x);\n\t//if (distance(center, uv2) < 0.02) return vec2(10,10);\n\tfloat nudge = dist * 4.0;\n\tvec2 offset = vec2(delta.y, -delta.x);// * 0.2 / dist ;// vec2(sin(angle+nudge), cos(angle+nudge));\n\tfloat blend = max(abs(delta.x), abs(delta.y))* 2.0;\n\tblend = clamp((0.5 - dist) * 2.0, 0.0, 1.0);\n\tblend = pow(blend, 1.5);\n\t//offset *= clamp(1.0 - blend, 0.0, 1.0);\n\toffset *= clamp(blend, 0.0, 1.0);\n\t//if (dist > 0.5) offset = vec2(0,0);\n\t//offset *= dist;\n\treturn uv + offset*vec2(1.0,1.0)*1.1+ vec2(iTime*-0.03, 0.0);\n}\nfloat cloud(vec3 p){\n    vec3 t = p;\n    p.x=t.x * cos(iTime*0.01) - t.z*sin(iTime*0.01);\n    p.z=t.x * sin(iTime*0.01) + t.z* cos(iTime*0.01);\n    vec2 uv = pos3t2(p);\n\n \t//float c = texture(iChannel0,(Spiral(uv* 3.0) + Spiral(uv* 2.0))).r;\n    vec3 cp = pos2t3(Spiral(uv* 2.0) + Spiral(uv* 3.0));\n    \n    float c =  perlin_noise3(cp*vec3(8.0,16.0,8.0));\n    c += perlin_noise3(cp*vec3(4.0,8.0,4.0))*2.0;\n    c += perlin_noise3(cp*vec3(1.0,2.0,1.0))*3.0;\n    c += perlin_noise3(cp*vec3(32.0,64.0,32.0));   \n    c -= perlin_noise3(p*1.5);\n    c -= perlin_noise3(p*5.0);\n    \n    float s = abs((abs(p.y) - 0.5)*2.0);\n\tc += s;\n    \n    return max(c ,0.0);\n}\n\nvec3 camera(vec2 uv,vec3 camPos, vec3 camLookat, vec3 camUp){\n\t// Camera setup.\n\tvec3 camVec=normalize(camLookat - camPos);//vpn\n\tvec3 sideNorm=normalize(cross(camUp, camVec));\t// u\n\tvec3 upNorm=cross(camVec, sideNorm);//v\n\tvec3 worldFacing=(camPos + camVec);//vcv\n\tvec3 worldPix = worldFacing + uv.x * sideNorm * (iResolution.x/iResolution.y) + uv.y * upNorm;//scrCoord\n\tvec3 relVec = normalize(worldPix - camPos);//scp\n   \n    return relVec;\n}\n\nfloat IntersectSphereAndRay(vec3 pos, float radius, vec3 posA, vec3 posB, out float distFromSphere, out vec3 intersectA2, out vec3 intersectB2)\n{\n\t// Use dot product along line to find closest point on line\n\tvec3 eyeVec2 = normalize(posB-posA);\n\tfloat dp = dot(eyeVec2, pos - posA);\n\tvec3 pointOnLine = eyeVec2 * dp + posA;\n\t// Clamp that point to line end points if outside\n\t//if ((dp - radius) < 0) pointOnLine = posA;\n\t//if ((dp + radius) > (posB-posA).Length()) pointOnLine = posB;\n\t// Distance formula from that point to sphere center, compare with radius.\n\tfloat distance = length(pointOnLine - pos);\n\tfloat ac = radius*radius - distance*distance;\n\tfloat rightLen = 0.0;\n\tif (ac >= 0.0) rightLen = sqrt(ac);\n\tintersectA2 = pointOnLine - eyeVec2 * rightLen;\n\tintersectB2 = pointOnLine + eyeVec2 * rightLen;\n\tdistFromSphere = distance - radius;\n\tif (distance <= radius) return 1.0;\n\treturn 0.0;\n}\n\nvec3 rotate(vec3 pos, vec2 xy)\n{\n    vec3 camerapos = pos;\n    camerapos.z=pos.z * cos(-xy.y) - pos.y* sin(-xy.y);\n    camerapos.y=pos.z * sin(-xy.y) + pos.y* cos(-xy.y);\n    pos = camerapos;\n   \tcamerapos.x=pos.x * cos(xy.x) - pos.z* sin(xy.x);\n    camerapos.z=pos.x * sin(xy.x) + pos.z* cos(xy.x);\n    \n    return camerapos;\n}\n\nfloat nightLight(vec3 pos, float h, vec2 th){\n    float l= perlin_noise3(pos*vec3(128.0,128.0,128.0))*3.0;\n    \n    float p = perlin_noise3(pos*vec3(32.0,32.0,32.0))*2.0;\n    p += perlin_noise3(pos*vec3(8.0,8.0,8.0));\n    p += perlin_noise3(pos*vec3(16.0,16.0,16.0));\n    p -= perlin_noise3(pos*vec3(4.0,4.0,4.0))*4.0;\n    \n    l*=clamp(p,0.0,1.0)*max(th.x - 0.2, 0.0) * th.y * 2.0;\n    \n    return l*(h>0.0?1.0:0.0);\n}\n\nvec3 earth(vec2 uv){\n    vec3 camerapos = vec3(0,0,1)*2500.0;\n    vec3 up = vec3(0,1,0);\n    \n    vec3 pos = rotate(camerapos,iMouse.xy/iResolution.xy*10.0);\n    up = rotate(up,iMouse.xy/iResolution.xy*10.0);\n    \n    vec3 earthPos = vec3(0,0,0);\n    vec3 dir = camera(uv-0.5, pos, earthPos, up);   \n\n    \n    vec3 ld = vec3(1,0,1);\n   \n    float dis = 0.0;\n    vec3 n;\n    vec3 f;\n\n    vec3 col = vec3(0,0,0);\n    \n    float r = IntersectSphereAndRay(earthPos, 1040.0,pos,pos + dir*2000.0, dis,n,f );\n    \n    float lt = 0.0;\n    if(r > 0.5){\n\t\tvec3 p = normalize(n - earthPos);\n   \t\tp = rotate(p, vec2(iTime*-0.2,0));\n        \n        vec3 v = reflect(-ld, p);\n        \n        lt = max(dot(p, ld), 0.0);\n        float sp = pow(max(dot(-normalize(v), normalize(n - pos)), 0.0), 3.0) * 2.3;\n\n        col = min(vec3(1.0,0.8,0.3)*sp,1.0) + vec3(0.05,0.8,1.0)*lt;\n            \n        float sr = pow(length(f - n)/1200.0, 2.0) * 2.0;\n            \n        col *=sr;\n    }\n    \n    r = IntersectSphereAndRay(earthPos, 1000.0,pos,pos + dir*2000.0, dis,n,f );\n    if(r > 0.5){\n\t\tvec3 p = normalize(n - earthPos);\n   \t\tp = rotate(p, vec2(iTime*-0.2,0));\n        \n        float ht = height(p);\n\n        vec2 t = terrain(p, ht);\n\n        col = color(p, t, ht);\n\n        col *= lt;\n\n        vec3 v = reflect(-ld, p);\n        float sp = pow(max(dot(-normalize(v), normalize(n - pos)), 0.0), 5.0) * lt;\n\n        float ss = sdWeirdSphere(p, 16.0)*2.0* lt;\n\n        col += vec3(1.0,0.8,0.3)*sp * (ht < 0.0?pow(ss,0.5)*2.0:1.0);\n                      \n        float nl = nightLight(p, ht, t);\n        col += vec3(1.0,0.8,0.3)* clamp(nl * (1.2 - lt),0.0,1.0);\n               \n        float c = cloud(p)/2.0;\n        col = mix(col, vec3(c)*lt, c);\n    }\n    \n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    vec3 col = earth(uv);\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/lsyfDt.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[77, 77, 100, 100, 330], [332, 332, 361, 361, 1390], [1392, 1392, 1427, 1427, 1937], [2003, 2050, 2090, 2090, 2125], [2128, 2211, 2258, 2258, 2418], [2420, 2420, 2442, 2442, 2573], [2574, 2574, 2596, 2596, 2740], [2741, 2741, 2762, 2762, 3099], [3101, 3101, 3131, 3131, 3472], [3474, 3474, 3510, 3510, 3914], [3916, 3916, 3938, 3938, 4636], [4637, 4637, 4657, 4657, 5293], [5295, 5295, 5356, 5374, 5740], [5742, 5742, 5887, 5948, 6642], [6644, 6644, 6676, 6676, 6972], [6974, 6974, 7019, 7019, 7393], [7395, 7395, 7415, 7415, 9154], [9156, 9156, 9213, 9263, 9392]], "test": "untested"}
{"id": "lsyfWc", "name": "Quadratic Bezier - 2D BBox", "author": "iq", "description": "Computing the exact bounding box to a quadratic Bezier curve. Yellow: naive bbox of the 3 control points. Blue: exact/analytic bbox. Since the bezier is quadratic, the bbox can be compute with a linear equation.", "tags": ["2d", "bezier", "bbox"], "likes": 35, "viewed": 2344, "published": "Public API", "date": "1530786072", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// The MIT License\n// Copyright © 2018 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n\n// Computes the exact bounding box to a quadratic Bezier curve. Since the bezier is quadratic,\n// the bbox can be compute with a linear equation:\n//\n//   Yellow: naive bbox of the 3 control points\n//   Blue: exact bbox\n//\n// More info here: http://iquilezles.org/www/articles/bezierbbox/bezierbbox.htm\n//    \n// Related Shaders:\n//     Quadratic Bezier - 3D      : https://www.shadertoy.com/view/ldj3Wh\n//     Cubic     Bezier - 2D BBox : https://www.shadertoy.com/view/XdVBWd \n//     Cubic     Bezier - 3D BBox : https://www.shadertoy.com/view/MdKBWt\n//     Quadratic Bezier - 2D BBox : https://www.shadertoy.com/view/lsyfWc\n//     Quadratic Bezier - 3D BBox : https://www.shadertoy.com/view/tsBfRD\n\n\n// Exact BBox to a quadratic bezier\nvec4 bboxBezier(in vec2 p0, in vec2 p1, in vec2 p2 )\n{\n    // extremes\n    vec2 mi = min(p0,p2);\n    vec2 ma = max(p0,p2);\n\n    // maxima/minima point, if p1 is outside the current bbox/hull\n    if( p1.x<mi.x || p1.x>ma.x || p1.y<mi.y || p1.y>ma.y )\n    {\n        // p = (1-t)^2*p0 + 2(1-t)t*p1 + t^2*p2\n        // dp/dt = 2(t-1)*p0 + 2(1-2t)*p1 + 2t*p2 = t*(2*p0-4*p1+2*p2) + 2*(p1-p0)\n        // dp/dt = 0 -> t*(p0-2*p1+p2) = (p0-p1);\n\n        vec2 t = clamp((p0-p1)/(p0-2.0*p1+p2),0.0,1.0);\n        vec2 s = 1.0 - t;\n        vec2 q = s*s*p0 + 2.0*s*t*p1 + t*t*p2;\n        \n        mi = min(mi,q);\n        ma = max(ma,q);\n    }\n    \n    return vec4( mi, ma );\n}\n\n\n// Approximated BBox to a quadratic bezier\nvec4 bboxBezierSimple(in vec2 p0, in vec2 p1, in vec2 p2 )\n{\n    vec2 mi = min(p0,min(p1,p2));\n    vec2 ma = max(p0,max(p1,p2));\n    \n    return vec4( mi, ma );\n}\n\n//---------------------------------------------------------------------------------------\n\nfloat sdBox( in vec2 p, in vec2 b ) \n{\n    vec2 q = abs(p) - b;\n    vec2 m = vec2( min(q.x,q.y), max(q.x,q.y) );\n    return (m.x > 0.0) ? length(q) : m.y; \n}\n\nfloat sdSegment( in vec2 p, in vec2 a, in vec2 b )\n{\n\tvec2 pa = p-a, ba = b-a;\n\tfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n\treturn length( pa - ba*h );\n}\n\nvec2 udBezier(in vec2 p0, in vec2 p1, in vec2 p2, in vec2 pos)\n{    \n    // p(t)    = (1-t)^2*p0 + 2(1-t)t*p1 + t^2*p2\n    // p'(t)   = 2*t*(p0-2*p1+p2) + 2*(p1-p0)\n    // p'(0)   = 2(p1-p0)\n    // p'(1)   = 2(p2-p1)\n    // p'(1/2) = 2(p2-p0)\n    vec2 a = p1 - p0;\n    vec2 b = p0 - 2.0*p1 + p2;\n    vec2 c = p0 - pos;\n\n    float kk = 1.0 / dot(b,b);\n    float kx = kk * dot(a,b);\n    float ky = kk * (2.0*dot(a,a)+dot(c,b)) / 3.0;\n    float kz = kk * dot(c,a);      \n\n    vec2 res;\n\n    float p = ky - kx*kx;\n    float p3 = p*p*p;\n    float q = kx*(2.0*kx*kx - 3.0*ky) + kz;\n    float h = q*q + 4.0*p3;\n\n    if(h >= 0.0) \n    { \n        h = sqrt(h);\n        vec2 x = (vec2(h, -h) - q) / 2.0;\n        vec2 uv = sign(x)*pow(abs(x), vec2(1.0/3.0));\n        float t = uv.x + uv.y - kx;\n        t = clamp( t, 0.0, 1.0 );\n\n        // 1 root\n        vec2 qos = c + (2.0*a + b*t)*t;\n        res = vec2( length(qos),t);\n    }\n    else\n    {\n        float z = sqrt(-p);\n        float v = acos( q/(p*z*2.0) ) / 3.0;\n        float m = cos(v);\n        float n = sin(v)*1.732050808;\n        vec3 t = vec3(m + m, -n - m, n - m) * z - kx;\n        t = clamp( t, 0.0, 1.0 );\n\n        // 3 roots\n        vec2 qos = c + (2.0*a + b*t.x)*t.x;\n        float dis = dot(qos,qos);\n        \n        res = vec2(dis,t.x);\n\n        qos = c + (2.0*a + b*t.y)*t.y;\n        dis = dot(qos,qos);\n        if( dis<res.x ) res = vec2(dis,t.y );\n\n        qos = c + (2.0*a + b*t.z)*t.z;\n        dis = dot(qos,qos);\n        if( dis<res.x ) res = vec2(dis,t.z );\n\n        res.x = sqrt( res.x );\n    }\n    \n    return res;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //--------\n    // animate\n    //--------\n    float time = iTime*0.5 + 20.0;\n    vec2 p0 = 0.8*sin( time*0.7 + vec2(3.0,1.0) );\n    vec2 p1 = 0.8*sin( time*1.1 + vec2(0.0,6.0) );\n    vec2 p2 = 0.8*sin( time*1.3 + vec2(4.0,2.0) );\n    \n\t//-------------\n    // compute bbox\n\t//-------------\n    vec4 b1 = bboxBezierSimple(p0,p1,p2);\n    vec4 b2 = bboxBezier(p0,p1,p2);\n    \n    //--------\n    // render\n    //--------\n    \n    vec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n    float px = 2.0/iResolution.y;\n\n    // background\n    vec3 col = vec3(0.15);\n    float be = udBezier( p0, p1, p2, p ).x;\n\tcol += 0.03*sin(be*150.0);\n    col *= 1.0 - 0.3*length(p);\n    \n    // naive bbox\n    float d = sdBox( p-(b1.xy+b1.zw)*0.5, (b1.zw-b1.xy)*0.5 );\n    col = mix( col, vec3(1.0,0.6,0.0), 1.0-smoothstep(0.003,0.003+px,abs(d)) );\n    \n    // exact bbox\n    d = sdBox( p-(b2.xy+b2.zw)*0.5, (b2.zw-b2.xy)*0.5 );\n    col = mix( col, vec3(0.2,0.5,1.0), 1.0-smoothstep(0.003,0.003+px,abs(d)) );\n    \n    // control cage\n    d = sdSegment( p, p0, p1 );\n    col = mix( col, vec3(0.3), 1.0-smoothstep(0.003,0.003+px,d) );\n    d = sdSegment( p, p1, p2 );\n    col = mix( col, vec3(0.3), 1.0-smoothstep(0.003,0.003+px,d) );\n\n    // bezier\n    d = be;\n    col = mix( col, vec3(1.0), 1.0-smoothstep(0.003,0.003+px*1.5,d) );\n         \n    // control points\n    d = length(p0-p); col = mix( col, vec3(1.0), 1.0-smoothstep(0.04,0.04+px,d) );\n    d = length(p1-p); col = mix( col, vec3(1.0), 1.0-smoothstep(0.04,0.04+px,d) );\n    d = length(p2-p); col = mix( col, vec3(1.0), 1.0-smoothstep(0.04,0.04+px,d) );\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/lsyfWc.jpg", "access": "shaders20k", "license": "mit", "functions": [[1781, 1817, 1871, 1887, 2480], [2483, 2526, 2586, 2586, 2688], [2690, 2781, 2819, 2819, 2938], [2940, 2940, 2992, 2992, 3102], [3104, 3104, 3168, 3346, 4686], [4688, 4688, 4745, 4790, 6378]], "test": "untested"}
{"id": "lsyfWK", "name": "shadertoy 1", "author": "kylegrover", "description": "trippy", "tags": ["trippy"], "likes": 0, "viewed": 320, "published": "Public API", "date": "1530481934", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord)\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 xy = fragCoord/iResolution.xy;\n    \n    xy.x = abs(xy.x * 1.1 - 0.55);\n    xy.y = abs(xy.y - 0.5);\n    xy.x = xy.x * xy.x;\n\n\tfloat a = fract(sin(iTime * 11.9));\n    float b = fract(cos(iTime * 9.1));\n\n    // Time varying pixel color\n    float colr = 0.5 + 0.5*cos(iTime+xy.y + sin(abs(log(xy.x * xy.y) * iTime / sin(iTime)) * 5.0));\n    float colg = 0.5 + 0.5*cos(iTime+xy.y + sin(abs(log(xy.x * xy.y) * iTime / 3.0) * 30.0 * (iTime / (1000.0 + iTime))));\n    float colb = sin(colg * (colg + 0.5));\n\n    colr = sin(colg * 4.0 + (colb / 200.0));\n    colg = sin(colg + (xy.y / (iTime * 2000.0)));\n    colb = 1.0 - sin(colg * 4.0 + (colb / 200.0)) - sin(colg + (xy.y / (iTime * 2000.0)));\n    \n    // Output to screen\n    fragColor = vec4(\n        colr,\n        colg,\n        colb, \n        1.0\n    );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/lsyfWK.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 56, 106, 916]], "test": "untested"}
{"id": "lt3cz7", "name": "Polyhedral Gears", "author": "Shane", "description": "Interlocked animated gears mapped onto the surface of a sphere via a polyhedral Goldberg arrangement.", "tags": ["sphere", "animation", "gear", "cog", "polyhedron", "goldberg"], "likes": 114, "viewed": 2563, "published": "Public API", "date": "1532096995", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/*\n\n\tPolyhedral Gears\n\t----------------\n\n\tInterlocked animated gears mapped onto the surface of a sphere via a polyhedral \n\tGoldberg arrangement. I've seen a few of these in static and gif form, and have\n\talways wanted to produce one in a pixel shader.\n\n    The GPU compiler genie would disagree, but I was pleasantly surprized by how easily \n\tthis came together. I was expecting it to be difficult, considering that everything \n\twould have to be tiled in a kind of geodesic-related fashion using cheap -- but more \n\tthan likely, confusing -- folded coordinates.\n\n    I had a couple of images with no code nor explanation, so had to wing it. It was\n\tonly after producing a working example that I combed through the polyhedral \n    classifications on Wikipedia and found that the cogs are rendered in an icosahedral \n\t(Goldberg) arrangement. A Goldberg polyhedron is a dual of a geodesic sphere, which \n\tis why the pattern looks similar. In particular, this Goldberg polyhedron has a \n\tGP(3, 0) classification, which means there are 92 faces, 180 vertices and 270 edges. \n\tThat seems about right, considering there are 12 pentagons, 20 large hexagons and 60 \n\tsmaller hexagons spread over the surface.\n\n    Not being aware of the specifics meant that I simply rendered some cogs at the \n\tappropriate positions on an icosahedron and dodecahedron, interspersed a couple of \n\tsmaller cogs within the confines of the icosahedral triangle face, then crossed my \n\tfingers and hoped things magically lined up, which they did... I guess it was my \n\tlucky day. :D\n\n\tI also noticed after combing the net for a while that a lot of the imagery originates \n\tfrom Paul Nylander's site, \"Bugman123.com.\" For anyone not familiar with it, it's \n\twell worth the visit. When I get time, I'd like to produce a few other things from \n\tthere.\n\n\tApologies in advance for the lower frame rate on slower machines in general, and \n\tprobably in fullscreen on a lot of machines, but the detail was fiddly to code.\tI \n\twon't bore you with the details, suffice to say that folded polyhedral cells and \n    detailed moving cogs don't enjoy one another's company. Apologies for the compile \n\ttime too... Having said that, even though the distance function could do with some \n\tstreamlining, I don't feel that it's complicated enough to warrant a ten year compile \n\ttime, so I feel whoever updated WebGL should be doing most of the apologizing. :)\n\n\tBy the way, I'll put together a cleaner, more simplistic example later for anyone \n\twho'd like to make one of these, but doesn't wish to comb through a bunch of \n\tesoteric code.\n\n\t\n\t// Based on:\n\t\n    // Not the easiest of geometry to wrap one's head around at the best of times, and \n\t// from what I understand, DjinnKahn (Tom Sirgedas) was learning about shaders and \n\t// SDF at the same time. Quite amazing.\n    Icosahedron Weave - DjinnKahn\n\thttps://www.shadertoy.com/view/Xty3Dy\n\n\tOther examples:\n\n\t// Knighty is more comfortable folding space than most. I fold space about \n    // as well as I fold laundry. :)\n\tPolyhedron again - knighty\n\thttps://www.shadertoy.com/view/XlX3zB\n\n    // Tdhooper has some awesome icosahedral examples.\n    Icosahedron twist - tdhooper\n\thttps://www.shadertoy.com/view/Mtc3RX\n\n*/\n\n#define FAR 20.\n\n// Color scheme: 0, 1 or 2 -> Gold and aluminium, black and chrome, pink and chrome.\n#define COLOR_SCHEME 0\n\n// 2D rotation formula.\nmat2 rot2(float a){ float c = cos(a), s = sin(a); return mat2(c, s, -s, c); }\n\n// I paid hommage to the original and kept the same rotation... OK, I'm lazy. :D\nvec3 rotObj(vec3 p){\n    \n    p.yz *= rot2(iTime*.2/2.);\n    p.xz *= rot2(iTime*.5/2.);\n    return p;  \n    \n}\n\n\n// More concise, self contained version of IQ's original 3D noise function.\nfloat noise3D(in vec3 p){\n    \n    // Just some random figures, analogous to stride. You can change this, if you want.\n\tconst vec3 s = vec3(113, 157, 1);\n\t\n\tvec3 ip = floor(p); // Unique unit cell ID.\n    \n    // Setting up the stride vector for randomization and interpolation, kind of. \n    // All kinds of shortcuts are taken here. Refer to IQ's original formula.\n    vec4 h = vec4(0., s.yz, s.y + s.z) + dot(ip, s);\n    \n\tp -= ip; // Cell's fractional component.\n\t\n    // A bit of cubic smoothing, to give the noise that rounded look.\n    p = p*p*(3. - 2.*p);\n    \n    // Standard 3D noise stuff. Retrieving 8 random scalar values for each cube corner,\n    // then interpolating along X. There are countless ways to randomize, but this is\n    // the way most are familar with: fract(sin(x)*largeNumber).\n    h = mix(fract(sin(h)*43758.5453), fract(sin(h + s.x)*43758.5453), p.x);\n\t\n    // Interpolating along Y.\n    h.xy = mix(h.xz, h.yw, p.y);\n    \n    // Interpolating along Z, and returning the 3D noise value.\n    float n = mix(h.x, h.y, p.z); // Range: [0, 1].\n\t\n    return n;//abs(n - .5)*2.;\n}\n\n// Simple fBm to produce some clouds.\nfloat fbm(in vec3 p){\n    \n    // Four layers of 3D noise.\n    return 0.5333*noise3D( p ) + 0.2667*noise3D( p*2.02 ) + 0.1333*noise3D( p*4.03 ) + 0.0667*noise3D( p*8.03 );\n\n}\n\n// There's a neat way to construct an icosohedron using three mutually perpendicular rectangular \n// planes. If you reference something along the lines of icosahedron golden rectangle, you'll \n// get a pretty good idea. There's a standard image here:\n// https://math.stackexchange.com/questions/2538184/proof-of-golden-rectangle-inside-an-icosahedron\n//\n// Anyway, even a cursory glance will give you a fair idea where the figures below originate. In \n// a vertex\\indice list environment, you could produce an icosahedron without too much trouble at \n// all. However, in a realtime raymarching situation, you need to get to the triangle face \n// information in as few operations as possible. That's achieved via a bit of space folding using \n// the same information in a different way.\n//\n// If weaving wasn't necessary, you could use the concise \"opIcosahedron\" function and be done\n// with it. Unfortunately, the \"abs\" calls throw out the triangular polarity information, which\n// you need to distinguish one side of the triangle from the other -- I wasted a lot of time not\n// realizing this until Djinn Kahn posted his example. He rewrote the folding function with an\n// additional variable to track polarity (signs) during each iteration.\n//\n// With this function, you can obtain the triangle face information and use it to render in the\n// three regions of symmetry -- each with a left and right X axis. From there, you can do whatever \n// you wish. \n\n// Vertices: vec3(0, A, B), vec3(B, 0, A), vec3(-B, 0, A).\n// Face center: (vec3(0, A, B) + vec3(0, 0, A)*2.)/3..\n// Edges: (vec3(0, A, B) + vec3(B, 0, A))/2.,  etc.\n\n\n// The following have come from DjinnKahn's \"Icosahedron Weave\" example, here:\n// https://www.shadertoy.com/view/Xty3Dy\n//\n// It works fine, just the way it is, so I only made trivial changes. I'd like to cut down the\n// number of operations in the \"opIcosahedronWithPolarity\" function, but so far, I can't see\n// a way to do that.\n\nconst float PHI = (1. + sqrt(5.))/2.;\nconst float A = PHI/sqrt(1. + PHI*PHI);\nconst float B = 1./sqrt( 1. + PHI*PHI);\nconst float J = (PHI - 1.)/2.; // .309016994375;\nconst float K = PHI/2.;        //J + .5;\nconst mat3 R0 = mat3(.5,  -K,   J   ,K ,  J, -.5   ,J , .5,  K);\nconst mat3 R1 = mat3( K,   J, -.5   ,J , .5,   K   ,.5 ,-K,  J);\nconst mat3 R2 = mat3(-J, -.5,   K  ,.5 , -K,  -J   ,K ,  J, .5);\n// A handy matrix that rotates icosahedral vertices into the dual dodecahedron postions. \nconst mat3 R4 = mat3(.587785252292, -K, 0, -.425325404176, -J, .850650808352, .688190960236, .5, .525731112119);\n\n\n// I wanted all vertices hardcoded.\nconst vec3 v0 = vec3(0, A, B);\nconst vec3 v1 = vec3(B, 0, A);\nconst vec3 v2 = vec3(-B, 0, A);\nconst vec3 mid = (vec3(0,A,B) + vec3(0,0,A)*2.)/3.; // (v0 + v1 + v2)/3.*size.\n\n\n/*\n// I could make these constant and hardcode them, but it's so messy... I guess I could get my calculator\n// out, but life's too short and this is just a shader. :)\nmat3 basisHex, basisHexSm1, basisHexSm2;\n\n// A cheap orthonormal basis vector function - Taken from Nimitz's \"Cheap Orthonormal Basis\" example, then \n// modified slightly.\n//\n//Cheap orthonormal basis by nimitz\n//http://orbit.dtu.dk/fedora/objects/orbit:113874/datastreams/file_75b66578-222e-4c7d-abdf-f7e255100209/content\n//via: http://psgraphics.blogspot.pt/2014/11/making-orthonormal-basis-from-unit.html\nmat3 basis(in vec3 n){\n    \n    float a = 1./(1. + n.z);\n    float b = -n.x*n.y*a;\n    return mat3(1. - n.x*n.x*a, b, n.x, b, 1. - n.y*n.y*a, n.y, -n.x, -n.y, n.z);\n                \n}\n\n// Precalculating some face normals for various vertex positions, then producing the basis\n// matrix. Precalculation saves performing several loop calculations over and over. However,\n// this is at the expense of inline readability and variables. GPUs don't like globals... \n// Damned if you do, damned if you don't. :) This example needs more speed, so I might \n// hardcode the following into constants -- or something -- at a later stage.\nvoid initBases(){\n    \n\tconst vec3 hexN = normalize(cross((mid - v0), (mid - v1)));\n\n    basisHex = basis(hexN);\n    basisHexSm1 = basis(normalize(mix(v0, v2, .333)));\n    basisHexSm2 = basis(normalize(mix(v0, v1, .333)));\n    \n}\n*/\n\n// Cyberjax suggested the following to replace the above with constants, which, \n// in theory, should run faster:\n#define a(n) (1./(1. + n.z))\n#define b(n) (-n.x*n.y*a(n))\n#define basis(n) mat3(1. - n.x*n.x*a(n), b(n), n.x, b(n), 1. - n.y*n.y*a(n), n.y, -n.x,-n.y,n.z)           \n\nconst vec3 hexN = normalize(cross((mid - v0), (mid - v1)));\nconst vec3 n1 = normalize(mix(v0, v2, .333));\nconst vec3 n2 = normalize(mix(v0, v1, .333));\n\nconst mat3 basisHex = basis(hexN);\nconst mat3 basisHexSm1 = basis(n1);\nconst mat3 basisHexSm2 = basis(n2);\n\n// Same as opIcosahedron, except without mirroring symmetry, so X-coordinate may be negative.\n// (note: when this is used as a distance function, it's possible that the nearest object is\n// on the opposite polarity, potentially causing a glitch).\nvec3 opIcosahedronWithPolarity(in vec3 p){\n   \n\tvec3 pol = sign(p);\n    p = R0*abs(p);\n\tpol *= sign(p);\n    p = R1*abs(p);\n\tpol *= sign(p);\n    p = R2*abs(p);\n\tpol *= sign(p);\n    vec3 ret = abs(p);\n    return ret * vec3(pol.x*pol.y*pol.z, 1, 1);\n}   \n\n/*\n// The original function -- sans polarity information -- is neat and concise.\nvec3 opIcosahedron(vec3 p){ \n  \n    p = R0*abs(p);\n    p = R1*abs(p);\n    p = R2*abs(p);\n    return abs(p);  \n} \n*/\n\n\n// An object ID container.    \nvec4 objID;\n// Other global IDs. These are slower as globals, but easier to pass around.\nfloat spokes, sph;\n\n\n// Three distance fields for each of the three different kinds of gears. I could role them into\n// one larger, and much messier function, but I prefer it this way. I'll comment them more \n// thoroughly later, but in short, it's just a bunch of fiddly calls to create the gear's objects. \n// There's some cyclinder-like calls, and some repeat radial boxish calls for the spokes, etc. \n// Standard stuff. As always, a lot of these functions are hacky bounds to save some operations, \n// but they produce very similar results.\n//\n// The math and physics of the situation is less complicated than you'd think. The radii of the \n// gears have a ratio of 18:15:12. Since the radius and circumference is directly proportional, \n// this means the cog teeth ratio would be the same. The scalar rotational speed would be inversely \n// proportional -- Smaller wheels need to move faster to keep up with the larger wheel arcs. This\n// means time needs to be in a ratio of: 1./18: 1./15. : 1./12. You can see that implemented\n// below.\n//\n// The only annoyance would be that when animating across the boundaries of the underlying \n// icosahedral structure -- used to position the gears, it's triangle based structure needs to be \n// considered. This means working with the number 3 and wrapping things... I hacked the wrapping \n// (the \"mod(iTime/1.5\" lines) in a hurry to get things working, but I'll take a closer look later \n// to see if there's a more elegant solution.\n\n// The pentagonal gear\\cog..\nfloat dist(vec3 p, float r1, float r2){\n    \n    // Using inverse time values, and wrapping the polar angles to cooincide with\n    // the underlying icosaheral segments.\n    //p.xy *= rot2(mod(iTime/1.5, 3.*6.2831/15.) + 6.2831/2.);\n    p.xy *= rot2(mod(iTime/1.5, 6.2831/5.) + 3.14159265);\n    \n    float a = atan(p.y, abs(p.x)); // Note the \"abs\" call.\n    \n    // The outer gear radius needs to taper as it approaches the center to avoid\n    // overlap.\n    r1 *= (.9 + p.z);\n    \n    // The outer cog teeth. Basically, we're applying the repeat polar space thing.\n    vec3 q = p; \n    float ia = floor(a/6.2831*15.) + .5;\n    q.xy = rot2(ia*6.2831/15.)*q.xy; // Convert to polar coordinates. X -> radius, Y -> angle.\n    q.x += r1;// - .03/3.; // Move the radial coordinate out to the edge of the rim.\n    q = abs(q);\n    float spike = mix(max(q.x - .05, q.y - .02), length(q.xy*vec2(.7, 1)) - .025, .5);\n    float d2 = max(spike, q.z - r2);\n   \n    // The inner spokes.\n    q = p; \n    ia = floor(a/6.2831*5.) + .5;\n    q.xy = rot2(ia*6.2831/5.)*q.xy;\n    sph = max(max(abs(q.x), abs(q.y)) - .0225, abs(q.z - .07) - .06);\n    //sph = max(length(q.xy) - .0225, abs(q.z - .07) - .06);\n    q = abs(q + vec3(r1/2., 0, -.07));\n    //spokes = max(max(q.x - r1/2. + .02, q.y - .03), q.z - .01);\n    spokes = max(q.x - r1/2. + .02, max(max(q.y - .05, q.z - .015), (q.y + q.z)*.7071 - .025));\n    \n    // The inner cylindrical cog bit.\n    p = abs(p);\n    float d = length(p.xy);\n    float di = abs(d  -  r1 + .1/2.) - .05/2.;\n    d = abs(d  -  r1 + .075/2.) - .075/2.;\n    d = min(max(d , p.z - r2), max(di , p.z - r2 - .01));\n    \n    // Return the minimum of the inner cog and teeth. The inner spokes have been kept global\n    // for ID purposes and isn't include here... Yeah, messy, but this is a fiddly example\n    // to work with. :)\n    return min(d, d2);\n    \n}\n\n// The larger hexagonal gear\\cog.\nfloat dist2(vec3 p, float r1, float r2){\n    \n    \n    // See the comments in the \"dist\" function.\n    \n    ///p.xy *= rot2(mod(iTime/1.8, 3.*6.2831/18.) + 3.*6.2831/18.);\n    p.xy *= rot2(mod(iTime/1.8, 6.2831/6.) + 6.2831/6.);\n    \n    float a = atan(p.y, abs(p.x)); // Note the \"abs\" call.\n    \n    p.z = -p.z;\n    \n    r1 *= (.9 + p.z);\n    \n    vec3 q = p; \n    \n    float ia = floor(a/6.2831*18.) + .5;\n    q.xy = rot2(ia*6.2831/18.)*q.xy; // Convert to polar coordinates. X -> radius, Y -> angle.\n    q.x += r1;// - .03/3.; // Move the radial coordinate out to the edge of the rim.\n    q = abs(q);\n    float spike = mix(max(q.x - .05, q.y - .02), length(q.xy*vec2(.7, 1)) - .025, .5);\n    float d2 = max(spike, q.z - r2);\n    \n    q = p; \n    ia = floor(a/6.2831*6.) + .5;\n    q.xy = rot2(ia*6.2831/6.)*q.xy;\n    sph = max(max(abs(q.x), abs(q.y)) - .0275, abs(q.z - .07) - .06);\n    //sph = max(length(q.xy) - .0275, abs(q.z - .07) - .06);\n    q = abs(q + vec3(r1/2., 0, -.07));\n    //spokes = max(max(q.x - r1/2. + .02, q.y - .03), q.z - .01);\n    spokes = max(q.x - r1/2. + .02, max(max(q.y - .05, q.z - .015), (q.y + q.z)*.7071 - .03));\n    \n    p = abs(p);\n    float d = length(p.xy);\n    float di = abs(d  -  r1 + .1/2.) - .05/2.;\n    d = abs(d  -  r1 + .075/2.) - .075/2.;\n    d = min(max(d , p.z - r2), max(di , p.z - r2 - .0115));\n    \n    return min(d, d2);\n    \n}\n\n// The smaller hexagonal gear\\cog.\nfloat dist3(vec3 p, float r1, float r2){\n    \n    // See the comments in the \"dist\" function.\n    \n    // This is the same as the two functions above, but the smaller cogs cross a boundary line\n    // and directional polarity has to be considered.\n    float dir = p.x < 0.? -1. : 1.;\n    \n    p.x = abs(p.x);\n    vec3 q2 = p;\n    p.xy *= rot2(mod(iTime/1.2*dir + 3.14159/12., 6.2831/12.) + 5.*6.2831/12.); // + 5.*3.14159/12.\n    \n    \n    float a = atan(p.y, abs(p.x)); // Note the \"abs\" call.\n    \n    r1 *= (.9 + p.z);\n    \n    vec3 q = p;\n   \n    float ia = floor(a/6.2831*12.) + .5;\n    q.xy = rot2(ia*6.2831/12.)*q.xy; // Convert to polar coordinates. X -> radius, Y -> angle.\n    q.x += r1;// - .03/3.; // Move the radial coordinate out to the edge of the rim.\n    q.xy = abs(q.xy);\n    float spike = mix(max(q.x - .05, q.y - .02), length(q.xy*vec2(.7, 1)) - .025, .5);\n    float d2 = max(spike, abs(q.z) - r2);\n\n    \n    q = q2; \n    q.xy *= rot2(mod(iTime/1.2*dir, 6.2831/6.) + 2.*6.2831/6.);\n    a = atan(q.y, abs(q.x));\n    ia = floor(a/6.2831*6.) + .5;\n    q.xy = rot2(ia*6.2831/6.)*q.xy;\n    sph = max(max(abs(q.x), abs(q.y)) - .02, abs(q.z - .07) - .06);\n    //sph = max(length(q.xy) - .02, abs(q.z - .07) - .06);\n    q = abs(q + vec3(r1/2., 0, -.07));\n    spokes = max(q.x - r1/2. + .02, max(max(q.y - .04, q.z - .015), (q.y + q.z)*.7071 - .02));\n    \n    \n    p = abs(p);\n    float d = length(p.xy);\n    float di = abs(d  -  r1 + .1/2.) - .05/2.;\n    d = abs(d  -  r1 + .075/2.) - .075/2.;\n    d = min(max(d , p.z - r2), max(di , p.z - r2 - .007));\n    \n    return min(d, d2);\n    \n}\n\n//Raytraced sphere hit variable. \n//float balHit; \n\nfloat map(in vec3 p){\n   \n    \n    // Back plane. Six units behind the center of the weaved object.\n    float pln = -p.z + 6.;\n    \n/*  \n    // Raytraced sphere hit variable. It saves extra calculation, but\n    // complicates things. Plus, it can interfere with shadows, add to \n    // the compile time... It saves a lot of pixel calculations though, \n    // especially in fullscreen... I'll have a think about it. :)\n    if(balHit < 0.){\n        \n        objID = vec4(1e5, 1e5, 1e5, pln);\n        return pln;\n        \n    }\n*/   \n    \n    // Rotate the object.\n    p = rotObj(p);\n    //p.yz *= rot2(-3.14159/6.);\n    \n    vec3 oP = p;\n    \n    \n    float d = 1e5, d2 = 1e5, d3 = 1e5;\n    \n   \n    // DjinnKahn's icosahedral distance function that produces a triangular face\n    // and allows you to determine between the negative and positive X axis.\n    \n    // Large hexagonal face positions.\n    vec3 hexFace = opIcosahedronWithPolarity(p); \n    \n    // Rotating the points above to the dual pentagonal face positions. This saves\n    // a lot of extra operations. We're able to do this because of the icosahedron\n    // and dodecahedron duality.\n    vec3 pentFace = R4*hexFace; \n    \n    // Pentagon.\n    vec3 p1 = (pentFace - vec3(0, 0, 1));\n    d3 = min(d3, dist( p1, .185, .1) );\n    d = min(d, spokes);\n    d3 = min(d3, sph);\n    \n    // Hexagon. \n    p1 = basisHex*(hexFace - mid*1.2425);\n    d3 = min( d3, dist2( p1, .25, .1) );\n    d = min(d, spokes);\n    d3 = min(d3, sph);\n    \n    // Small cogs.\n    p1 = basisHexSm1*(hexFace - mix(v0, v2, .333)*1.1547);\n    d2 = min( d2, dist3( p1, .16, .1) );\n    d = min(d, spokes);\n    d3 = min(d3, sph);\n    p1 = basisHexSm2*(hexFace - mix(v0, v1, .333)*1.1547);\n    d2 = min( d2, dist3( p1, .16, .1) );\n    d = min(d, spokes);\n    d3 = min(d3, sph);\n    \n   \n    // Capping off the edges of the gears with the outer sphere itself.\n    float mainSph = length(oP);\n    d = max(d, mainSph - 1.0825);\n    d2 = max(d2, mainSph - 1.116);\n    d3 = max(d3, mainSph - 1.118);\n \n    \n\n    \n    // Store the individual object values for sorting later. Sorting multiple objects\n    // inside a raymarching loop probably isn't the best idea. :)\n    objID = vec4(d, d2, d3, pln);\n    \n    return min(min(d, d2), min(d3, pln));\n}\n\n/*\n// Tetrahedral normal, to save a couple of \"map\" calls. Courtesy of IQ. In instances where there's no descernible \n// aesthetic difference between it and the six tap version, it's worth using.\nvec3 calcNormal(in vec3 p){\n\n    // Note the slightly increased sampling distance, to alleviate artifacts due to hit point inaccuracies.\n    vec2 e = vec2(0.0025, -0.0025); \n    return normalize(e.xyy * map(p + e.xyy) + e.yyx * map(p + e.yyx) + e.yxy * map(p + e.yxy) + e.xxx * map(p + e.xxx));\n}\n*/\n\n/*\n// Standard normal function. 6 taps.\nvec3 calcNormal(in vec3 p) {\n\tconst vec2 e = vec2(0.002, 0);\n\treturn normalize(vec3(map(p + e.xyy) - map(p - e.xyy), map(p + e.yxy) - map(p - e.yxy),\tmap(p + e.yyx) - map(p - e.yyx)));\n}\n*/\n\n/*\n// Normal calculation, with some edging and curvature bundled in.\nvec3 calcNormal(vec3 p, inout float edge, inout float crv, float t) { \n\t\n    // It's worth looking into using a fixed epsilon versus using an epsilon value that\n    // varies with resolution. Each affects the look in different ways. Here, I'm using\n    // a mixture. I want the lines to be thicker at larger resolutions, but not too thick.\n    // As for accounting for PPI; There's not a lot I can do about that.\n    vec2 e = vec2(3./mix(450., min(850., iResolution.y), .35), 0);//*(1. + t*t*.7);\n\n\tfloat d1 = map(p + e.xyy), d2 = map(p - e.xyy);\n\tfloat d3 = map(p + e.yxy), d4 = map(p - e.yxy);\n\tfloat d5 = map(p + e.yyx), d6 = map(p - e.yyx);\n\tfloat d = map(p)*2.;\n\n    edge = abs(d1 + d2 - d) + abs(d3 + d4 - d) + abs(d5 + d6 - d);\n    //edge = abs(d1 + d2 + d3 + d4 + d5 + d6 - d*3.);\n    edge = smoothstep(0., 1., sqrt(edge/e.x*2.));\n     \n    // Wider sample spread for the curvature.\n    //e = vec2(12./450., 0);\n\t//d1 = map(p + e.xyy), d2 = map(p - e.xyy);\n\t//d3 = map(p + e.yxy), d4 = map(p - e.yxy);\n\t//d5 = map(p + e.yyx), d6 = map(p - e.yyx);\n    //crv = clamp((d1 + d2 + d3 + d4 + d5 + d6 - d*3.)*32. + .5, 0., 1.);\n \n    \n    e = vec2(.001, 0); //iResolution.y - Depending how you want different resolutions to look.\n\td1 = map(p + e.xyy), d2 = map(p - e.xyy);\n\td3 = map(p + e.yxy), d4 = map(p - e.yxy);\n\td5 = map(p + e.yyx), d6 = map(p - e.yyx);\n\t\n    return normalize(vec3(d1 - d2, d3 - d4, d5 - d6));\n}\n*/\n\n// IQ rewrote the function above, and for reasons that defy my own sense \n// of logic, has cut the compile time down by at least half. For whatever\n// reason, restricting an unroll in the larger iteration \"trace\" function\n// has virtually no effect on compile time, yet doing the same with the\n// fewer \"map\" calls in the following function does... I'll leave the\n// explanation for that conundrum to the GPU instruction experts. :)\n//\nvec3 calcNormal(vec3 p, inout float edge, inout float crv, float t) { \n    \n    float eps = 3./mix(450., min(850., iResolution.y), .35);\n\n    float d = map(p);\n    \n    vec3 e = vec3(eps, 0, 0);\n    \n    vec3 da = vec3(-2.*d);\n    for( int i = min(iFrame,0); i<3; i++ )\n    {\n        for( int j=min(iFrame,0); j<2; j++ )\n            da[i] += map(p + e*float(1-2*j));\n        e = e.zxy;\n    }\n    da = abs(da);\n    \n    edge = da.x + da.y + da.z;\n    edge = smoothstep(0., 1., sqrt(edge/e.x*2.));\n    \n    vec3 n = vec3(0.0);\n    for( int i=min(iFrame, 0); i<4; i++ )\n    {\n        vec3 e = .57735*(2.*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1)) - 1.);\n        n += e*map(p + .001*e);\n    }\n    \n    return normalize(n);\n}\n\n// Raymarching: The distance function is a little on the intensive side, so I'm \n// using as fewer iterations as necessary. Even though there's a breat, the compiler\n// still has to unroll everything, and larger numbers make a difference.\nfloat trace(in vec3 ro, in vec3 rd){\n    \n    float t = 0., d;\n    \n    for(int i = 0; i<64; i++){\n    \n        d = map(ro + rd*t);\n        if(abs(d)<.001*(1. + t*.05) || t > FAR) break;\n        t += d;\n    }\n    \n    return min(t, FAR);\n}\n\n/*\nfloat hash( float n ){ return fract(cos(n)*45758.5453); }\n\n// Ambient occlusion, for that self shadowed look. Based on the original by XT95. I love this \n// function and have been looking for an excuse to use it. For a better version, and usage, \n// refer to XT95's examples below:\n//\n// Hemispherical SDF AO - https://www.shadertoy.com/view/4sdGWN\n// Alien Cocoons - https://www.shadertoy.com/view/MsdGz2\nfloat calculateAO( in vec3 p, in vec3 n, float maxDist )\n{\n\tfloat ao = 0.0, l;\n\tconst float nbIte = 6.0;\n\t//const float falloff = 0.9;\n    for( float i=1.; i< nbIte + .5; i++ ){\n    \n        l = (i + hash(i))*.5/nbIte*maxDist;\n        ao += (l - map( p + n*l ))/(1.+ l);// / pow(1.+l, falloff);\n    }\n\t\n    return clamp( 1.-ao/nbIte, 0., 1.);\n}\n*/\n\n// Ambient occlusion, for that self shadowed look.\n// Based on the original by IQ.\nfloat calcAO(in vec3 p, in vec3 n)\n{\n\tfloat sca = 4., occ = 0.0;\n    for( int i=1; i<6; i++ ){\n    \n        float hr = float(i)*.125/5.;        \n        float dd = map(p + hr*n);\n        occ += (hr - dd)*sca;\n        sca *= .75;\n    }\n    return clamp(1. - occ, 0., 1.);   \n    \n}\n\n// The iterations should be higher for proper accuracy.\nfloat softShadow(in vec3 ro, in vec3 rd, float t, in float end, in float k){\n\n    float shade = 1.0;\n    // Increase this and the shadows will be more accurate, but more iterations slow things down.\n    const int maxIterationsShad = 24; \n\n    // The \"start\" value, or minimum, should be set to something more than the stop-threshold, so as to avoid a collision with \n    // the surface the ray is setting out from. It doesn't matter how many times I write shadow code, I always seem to forget this.\n    // If adding shadows seems to make everything look dark, that tends to be the problem.\n    float dist = .001*(1. + t*.05);\n    float stepDist = end/float(maxIterationsShad);\n\n    // Max shadow iterations - More iterations make nicer shadows, but slow things down. Obviously, the lowest \n    // number to give a decent shadow is the best one to choose. \n    for (int i = 0; i<maxIterationsShad; i++){\n        // End, or maximum, should be set to the distance from the light to surface point. If you go beyond that\n        // you may hit a surface not between the surface and the light.\n        float h = map(ro + rd*dist);\n        shade = min(shade, k*h/dist);\n        //shade = min(shade, smoothstep(0.0, 1.0, k*h/dist));\n        \n        // What h combination you add to the distance depends on speed, accuracy, etc. To be honest, I find it impossible to find \n        // the perfect balance. Faster GPUs give you more options, because more shadow iterations always produce better results.\n        // Anyway, here's some posibilities. Which one you use, depends on the situation:\n        // +=max(h, 0.001), +=clamp( h, 0.01, 0.25 ), +=min( h, 0.1 ), +=stepDist, +=min(h, stepDist*2.), etc.\n        \n        dist += clamp(h, 0.01, 0.25);\n        \n        // There's some accuracy loss involved, but early exits from accumulative distance functions can help.\n        if (h<0.0001 || dist > end) break; \n    }\n\n    // Return the shadow value. Note that I'm not using clamp. The shadow value should be capped to zero\n    // prior to adding a constant... Unless you're not adding a constant. :)\n    return min(max(shade, 0.) + .1, 1.); \n}\n\n\n// Very basic pseudo environment mapping... and by that, I mean it's fake. :) However, it \n// does give the impression that the surface is reflecting the surrounds in some way.\n//\n// More sophisticated environment mapping:\n// UI easy to integrate - XT95    \n// https://www.shadertoy.com/view/ldKSDm\nvec3 envMap(vec3 p){\n    \n    p *= 3.;\n    \n    float n3D2 = noise3D(p*3.);\n   \n    // A bit of fBm.\n    float c = noise3D(p)*.57 + noise3D(p*2.)*.28 + noise3D(p*4.)*.15;\n    c = smoothstep(.25, 1., c); // Putting in some dark space.\n    \n    p = vec3(c, c*c, c*c*c); // Bluish tinge.\n    \n    return mix(p, p.zyx, n3D2*.5 + .5); // Mixing in a bit of purple.\n\n}\n\n/*\n// Intersection of a sphere. IQ's formula - trimmed down a little.\nfloat traceSphere( in vec3 ro, in vec3 rd, in vec4 sph ){\n\n\tro -= sph.xyz;\n\tfloat b = dot(ro, rd);\n\tfloat h = b*b - dot(ro, ro) + sph.w*sph.w;\n    return h<0. ? -1. : -b - sqrt( h );\n}\n*/\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Aspect correct screen coordinates. Restricting the size of the\n    // fullscreen object to maintain a little detail on larger screens.\n    // A consequence is a larger background. By the way, this was coded\n    // for the 800 by 450 canvas or smaller, rather than fullscreen.\n    vec2 p = (fragCoord - iResolution.xy*.5)/min(850., iResolution.y);\n    \n    // Unit direction ray.\n    vec3 rd = normalize(vec3(p, 1));\n    \n    // Ray origin, doubling as the camera postion.\n    vec3 ro = vec3(0, 0, -2.75);\n    \n    // Light position. Near the camera.\n    vec3 lp = ro + vec3(.25, 2, -.1);\n    \n    // Basic camera rotation.\n    rd.xy *= rot2(sin(iTime/8.)*.2);\n    rd.xz *= rot2(sin(iTime/4.)*.1);\n    \n    // Precalculating some basis matrix values.\n    // Replaced with Cyberjax's suggestion.\n    //initBases();\n    \n    //balHit = traceSphere(ro, rd, vec4(vec3(0), 1.2)); // Main object pixel flag.\n    \n    // Ray march.\n    float t = trace(ro, rd);\n    \n    // Object identification: Back plane: 3, Golden joins: 2., \n    // Ball joins: 1., Silver pipes:  0.\n    float svObjID = objID.x<objID.y && objID.x<objID.z && objID.x<objID.w? 0.: \n    objID.y<objID.z && objID.y<objID.w ? 1. : objID.z<objID.w? 2. : 3.;\n\n    \n    // Initiate the scene color zero.\n    vec3 sceneCol = vec3(0);\n    \n    // Surface hit. Color it up.\n    if(t < FAR){\n    \n        // Position.\n        vec3 pos = ro + rd*t;\n        // Normal.\n        //vec3 nor = calcNormal(pos);\n        // Normal, plus edges and curvature. The latter isn't used.\n        float edge = 0., crv = 1.;\n        vec3 nor = calcNormal(pos, edge, crv, t);\n        \n        //vec3 rp = rotObj(pos);\n        \n        // Light direction vector.\n        vec3 li = lp - pos;\n        float lDist = max(length(li), .001);\n        li /= lDist;\n        \n        // Light falloff - attenuation.\n        float atten = 1./(1. + lDist*.05 + lDist*lDist*0.025);\n        \n        // Soft shadow and occlusion.\n        float shd = softShadow(pos + nor*.0015, li, t, lDist, 8.); // Shadows.\n        float ao = calcAO(pos, nor);\n        \n        \n        float diff = max(dot(li, nor), .0); // Diffuse.\n        float spec = pow(max(dot(reflect(-li, nor), -rd), 0.), 16.); // Specular.\n        // Ramping up the diffuse. Sometimes, it can make things look more metallic.\n        float od = diff;\n        diff = pow(diff, 4.)*2.; \n        \n        \n        float Schlick = pow( 1. - max(dot(rd, normalize(rd + li)), 0.), 5.0);\n\t\tfloat fre2 = mix(.5, 1., Schlick);  //F0 = .5.\n\t\t\n        // Spokes: ObjID == 0.;\n        #if COLOR_SCHEME == 0\n        vec3 col = vec3(.6); // Silver.\n        #elif COLOR_SCHEME == 1\n        vec3 col = vec3(.1); // Black.\n        #else\n        vec3 col = vec3(.9, .2, .4); // Pink.\n        #endif\n\n        \n        if(svObjID == 1.) { // Smaller hexagon cogs.\n            #if COLOR_SCHEME == 0\n            col = vec3(1, .5, .2)*.7; // Gold.\n            #else \n            col = vec3(.6); // Chrome.\n            #endif\n         }\n        if(svObjID == 2.){ // Larger hexagon and pentagon cogs.\n            \n            #if COLOR_SCHEME == 0\n            col = vec3(1, .65, .3)*.7; // Gold-Copper\n            #else \n            col = vec3(.6); // Chrome.\n            #endif\n        }\n        if(svObjID == 3.) { // Back plane.\n            \n            // Dark background color. Noise is applied afterward (See below).\n            #if COLOR_SCHEME == 0\n            col = vec3(1, .7, .4)*.045; // Brown.\n            #elif COLOR_SCHEME == 1\n            col = vec3(.7)*.045; // Charcoal.\n            #else\n            col = vec3(.6, .7, 1)*.045; // Blue.\n            #endif\n        }\n        \n        \n        // Applying some subtle 3D fBm noise to the gear object and back plane to grunge\n        // it up slightly. Technically, I should be keeping a copy of the individual gear\n        // rotations and applying those, but the compiler is hating on this example enough\n        // already, so I've lowered these noise intensity and added noisy environmental \n        // reflection so that the sliding UV effect is negigible.       \n        float txSz = 1.;\n        vec3 txPos = pos; \n        if(svObjID == 3.) txSz /= 4.;\n        else txPos = rotObj(txPos);\n        col *= fbm(txPos*64.*txSz)*.75 + .5;\n        \n    \n        \n        // Diffuse plus ambient term.\n        sceneCol = col*(diff + .25); \n        \n        // Specular term.\n        if(svObjID == 3.) sceneCol += col*vec3(1, .6, .2).zyx*spec*.25; // Less specular on the back plane.\n        else sceneCol += col*vec3(.5, .75, 1.)*spec*2.;\n        \n        // Fake environment mapping.\n        float envF = 4.;\n        if(svObjID == 0.) envF = 8.;\n        sceneCol += sceneCol*envMap(reflect(rd, nor))*envF;\n        \n        // Edges.\n        sceneCol *= 1. - edge*.8;\n        //col = col*.7 + edge*.3;\n        \n        sceneCol *= atten*shd*ao; // Applying the light falloff, shadows and AO.\n        \n        \n        \n         \n    }\n    \n    // Screen color. Rough gamma correction. No fog or postprocessing.\n    fragColor = vec4(sqrt(clamp(sceneCol, 0., 1.)), 1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/lt3cz7.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[3359, 3383, 3402, 3402, 3460], [3462, 3543, 3563, 3563, 3653], [3656, 3732, 3757, 3850, 4836], [4838, 4876, 4897, 4934, 5050], [9807, 10054, 10096, 10096, 10302], [12109, 12138, 12177, 12370, 14004], [14006, 14040, 14080, 14211, 15420], [15422, 15457, 15497, 15704, 17056], [17058, 17110, 17131, 17209, 19378], [21600, 22036, 22105, 22105, 22751], [22753, 22992, 23028, 23028, 23231], [23991, 24074, 24110, 24110, 24354], [24356, 24412, 24488, 24488, 26550], [26553, 26852, 26872, 26872, 27214], [27216, 27475, 27532, 27815, 32628]], "test": "untested"}
{"id": "lt3yRS", "name": "Inner space", "author": "liamegan", "description": "Just an exercise in volumetric raymarching.", "tags": ["raymarching", "spheres", "cylinders"], "likes": 4, "viewed": 224, "published": "Public API", "date": "1532970777", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// A lot of this setup is borrowed from Shane - https://www.shadertoy.com/user/Shane\n// Many of the learnings come curtesy of Big Wings - https://www.shadertoy.com/user/BigWings\n// And of course the literally thousands of other people who have been developing these concepts over the years.\n// But this is an effort to more detailed understanding of the underlying principles.\n\n// movement variables\nvec3 movement = vec3(.0);\n\n// Gloable variables for the raymarching algorithm.\nconst int maxIterations = 256;\n\n// The world!\nfloat world_df(in vec3 p) {\n    float world = 10.;\n\n    p.x += cos(p.z * .3) * 3.;\n    p.y += sin(p.z * .3) * 3.;\n\n    vec3 _p = mod(p, 1.2) - .5;\n    vec3 _2p = p;\n    _2p.x += sin(_2p.z);\n    _2p.y += cos(_2p.z);\n    _2p = mod(_2p, 3.0) - 1.5;\n\n    world = min(length(_p)-.1, length(_2p.xy) - .01); // spheres and bendy cylinders\n\n    p = mod(p, 2.) - 1.;\n    world = min(world, length(p.xz) - .03); // larger, less bendy cylinders.\n\n    return world;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / min(iResolution.y, iResolution.x);\n\n    // movement\n    movement = vec3(iTime, 0., iTime * -4.);\n\n    vec3 lookAt = vec3(-.5, sin(iTime * .5) * 2., cos(iTime * .5) * 2.);\n    vec3 camera_position = vec3(0.2, 0.2, -1.0);\n\n    lookAt += movement;\n    camera_position += movement;\n\n    vec3 forward = normalize(lookAt-camera_position);\n    vec3 right = normalize(vec3(forward.z, 0., -forward.x ));\n    vec3 up = normalize(cross(forward,right));\n\n    // FOV - Field of view.\n    float FOV = 3.;\n\n    vec3 ro = camera_position; \n    vec3 rd = normalize(forward + FOV*uv.x*right + FOV*uv.y*up);\n\n    float dist = 100.;\n    float field = 0.;\n    for ( int i = 0; i < maxIterations; i++ ) {\n      dist = world_df( ro + rd * field );\n      field += dist * .03;\n      if(field > 5.) break;\n    }\n\n    vec3 colour = vec3(field*field*.18, field*.28, sin(field)*.15 * length(uv) + sin(iTime) * .5);\n    colour *= colour;\n\n    fragColor = vec4(clamp(colour, 0.0, 1.0), smoothstep(7., 0., colour.r)*.3);\n    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/lt3yRS.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[511, 525, 552, 552, 980], [982, 982, 1039, 1039, 2086]], "test": "untested"}
{"id": "lt3yW7", "name": "Fractal Face", "author": "belfry", "description": "A face?", "tags": ["fractal"], "likes": 10, "viewed": 194, "published": "Public", "date": "1532844535", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (2. * fragCoord - vec2(iResolution.x, 0.)) / iResolution.y * vec2(1.3, 1.);\n    uv = abs(uv);\n    for (float i = 0.; i < 4.; i++) {\n        float a = i * 0.05;\n        uv = mat2(cos(a), sin(a), -sin(a), cos(a)) * uv;\n        uv = 1.5 * uv - smoothstep(0., 1., fract(iTime * 0.05) + 0.2) * 1.8 + 0.6;\n        uv = vec2(atan(uv.y, uv.x), length(uv));\n        uv.x -= 1. / uv.y * 1.5;\n        uv.y = 1. / pow(abs(uv.y), 1.2);\n        uv = vec2(cos(uv.x), sin(uv.x)) * uv.y;\n        uv = abs(uv);\n    }\n    float d = length(uv - vec2(0.5, 0.4)) - 0.4;\n    fragColor = vec4(d);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/lt3yW7.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 646]], "test": "untested"}
{"id": "ltccRS", "name": "Waving Pearls", "author": "LUplusplus", "description": "A real-time ray tracer of a string of pearls.", "tags": ["raytracing"], "likes": 1, "viewed": 120, "published": "Public", "date": "1532982267", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//============================================================================\n// PROJECT ID: <your Project ID is an integer equal to 62 + group_no.>\n//\n// GROUP NUMBER:\n//\n// STUDENT NAME: \n// NUS User ID.: \n//\n// STUDENT NAME: \n// NUS User ID.: \n//\n// STUDENT NAME: \n// NUS User ID.: \n//\n// COMMENTS TO GRADER: \n//\n//============================================================================\n\n\n// FRAGMENT SHADER FOR SHADERTOY\n// Run this at https://www.shadertoy.com/new\n// See documentation at https://www.shadertoy.com/howto\n\n// Your browser must support WebGL 2.0.\n// Check your browser at http://webglreport.com/?v=2\n\n\n//============================================================================\n// Constants.\n//============================================================================\nconst int NUM_LIGHTS = 1;\nconst int NUM_MATERIALS = 4;\nconst int NUM_PLANES = 6;\nconst int NUM_SPHERES = 7;\nconst int NUM_BOXES = 1;\nconst float PI = 3.1415926535;\nconst vec3 BACKGROUND_COLOR = vec3( 0.1, 0.2, 0.6 );\n\n // Vertical field-of-view angle of camera. In radians.\nconst float FOVY = 50.0 * 3.1415926535 / 180.0; \n\n// Use this for avoiding the \"epsilon problem\" or the shadow acne problem.\nconst float DEFAULT_TMIN = 10.0e-4;\n\n// Use this for tmax for non-shadow ray intersection test.\nconst float DEFAULT_TMAX = 10.0e6;\n\n// Equivalent to number of recursion levels (0 means ray-casting only).\n// We are using iterations to replace recursions.\nconst int NUM_ITERATIONS = 3;\n\n\n//============================================================================\n// Define new struct types.\n//============================================================================\n\nstruct Triangle_t {\n    vec3 A,B,C;     // Barycentric Coordinates\n    \n    // Arbitrary point P in triangle\n    // P = (1-beta-gamma)A + betaB + gammaC\n};\n\nstruct Box_t {\n    float xLen, yLen, zLen;     // Length, width and height\n    vec3 center;                // Center coordinates in world space\n    float xAngle, yAngle, zAngle;       // Rotation angles about 3 axes\n    vec3 vertices[8];           // Pre-compute 8 vertices to reduce cost\n    int materialID;\n};\n\nstruct Ray_t {\n    vec3 o;  // Ray Origin.\n    vec3 d;  // Ray Direction. A unit vector.\n};\n\nstruct Plane_t {\n    // The plane equation is Ax + By + Cz + D = 0.\n    float A, B, C, D;\n    int materialID;\n};\n\nstruct Sphere_t {\n    vec3 center;\n    float radius;\n    int materialID;\n};\n\nstruct Light_t {\n    vec3 position;  // Point light 3D position.\n    vec3 I_a;       // For Ambient.\n    vec3 I_source;  // For Diffuse and Specular.\n};\n\nstruct Material_t {\n    vec3 k_a;   // Ambient coefficient.\n    vec3 k_d;   // Diffuse coefficient.\n    vec3 k_r;   // Reflected specular coefficient.\n    vec3 k_rg;  // Global reflection coefficient.\n    vec3 k_t;\n    float n;    // The specular reflection exponent. Ranges from 0.0 to 128.0. \n    float m; \n};\n\n//----------------------------------------------------------------------------\n// The lighting model used here is similar to that on Slides 8 and 12 of \n// Lecture 11 (Ray Tracing). Here it is computed as\n//\n//     I_local = SUM_OVER_ALL_LIGHTS { \n//                   I_a * k_a + \n//                   k_shadow * I_source * [ k_d * (N.L) + k_r * (R.V)^n ]\n//               }\n// and\n//     I = I_local  +  k_rg * I_reflected\n//----------------------------------------------------------------------------\n\n\n//============================================================================\n// Global scene data.\n//============================================================================\nPlane_t Plane[NUM_PLANES];\nSphere_t Sphere[NUM_SPHERES];\nLight_t Light[NUM_LIGHTS];\nMaterial_t Material[NUM_MATERIALS];\nBox_t Box[NUM_BOXES];\n\n// In total, 12 vertex combinations of triangle\nivec3 TriIndices[12];\n\n/////////////////////////////////////////////////////////////////////////////\n// Initializes the scene.\n/////////////////////////////////////////////////////////////////////////////\nvoid InitBoxVertices(int i)\n{\n    Box[i].vertices[0] = vec3(-0.5*Box[i].xLen, -0.5*Box[i].yLen, -0.5*Box[i].zLen);\n    Box[i].vertices[1] = vec3(0.5*Box[i].xLen, -0.5*Box[i].yLen, -0.5*Box[i].zLen);\n    Box[i].vertices[2] = vec3(0.5*Box[i].xLen, 0.5*Box[i].yLen, -0.5*Box[i].zLen);\n    Box[i].vertices[3] = vec3(-0.5*Box[i].xLen, 0.5*Box[i].yLen, -0.5*Box[i].zLen);\n    Box[i].vertices[4] = vec3(-0.5*Box[i].xLen, -0.5*Box[i].yLen, 0.5*Box[i].zLen);\n    Box[i].vertices[5] = vec3(0.5*Box[i].xLen, -0.5*Box[i].yLen, 0.5*Box[i].zLen);\n    Box[i].vertices[6] = vec3(0.5*Box[i].xLen, 0.5*Box[i].yLen, 0.5*Box[i].zLen);\n    Box[i].vertices[7] = vec3(-0.5*Box[i].xLen, 0.5*Box[i].yLen, 0.5*Box[i].zLen);  \n}\nvoid InitScene()\n{\n\n    TriIndices[0] = ivec3(1, 0, 2);\n    TriIndices[1] = ivec3(0, 3, 2);\n    TriIndices[2] = ivec3(4, 5, 7);\n    TriIndices[3] = ivec3(5, 6, 7);\n    TriIndices[4] = ivec3(0, 7, 3);\n    TriIndices[5] = ivec3(0, 4, 7);\n    TriIndices[6] = ivec3(1, 2, 6);\n    TriIndices[7] = ivec3(1, 6, 5);\n    TriIndices[8] = ivec3(0, 1, 4);\n    TriIndices[9] = ivec3(1, 5, 4);\n    TriIndices[10] = ivec3(2, 3, 7);\n    TriIndices[11] = ivec3(2, 7, 6);\n\n    // Horizontal plane.\n    Plane[0].A = -1.0;\n    Plane[0].B = 0.0;\n    Plane[0].C = 0.0;\n    Plane[0].D = 8.0;\n    Plane[0].materialID = 0;\n\n    // Vertical plane.\n    Plane[1].A = 1.0;\n    Plane[1].B = 0.0;\n    Plane[1].C = 0.0;\n    Plane[1].D = 8.0;\n    Plane[1].materialID = 0;\n    \n    // Vertical plane.\n    Plane[2].A = 0.0;\n    Plane[2].B = 0.0;\n    Plane[2].C = 1.0;\n    Plane[2].D = 8.0;\n    Plane[2].materialID = 0;\n    \n    // Vertical plane.\n    Plane[3].A = 0.0;\n    Plane[3].B = 1.0;\n    Plane[3].C = 0.0;\n    Plane[3].D = 0.0;\n    Plane[3].materialID = 1;\n    \n    Plane[4].A = 0.0;\n    Plane[4].B = -1.0;\n    Plane[4].C = 0.0;\n    Plane[4].D = 16.0;\n    Plane[4].materialID = 0;\n    \n    Plane[5].A = 0.0;\n    Plane[5].B = 0.0;\n    Plane[5].C = -1.0;\n    Plane[5].D = 8.0;\n    Plane[5].materialID = 0;\n    // Center bouncing sphere.\n    Sphere[0].center = vec3( 0.0, sin(4.0 * (iTime - (3.0 * PI / 12.0))) + 5.0, 0.0 );\n    Sphere[0].radius = 0.8;\n    Sphere[0].materialID = 2;\n\n    // Circling sphere.\n    Sphere[1].center = vec3( 1.8, sin(4.0 * (iTime - (4.0 * PI / 12.0))) + 5.0, 0.0 );\n    Sphere[1].radius = 0.5;\n    Sphere[1].materialID = 3;\n\n    Sphere[2].center = vec3( 3.2, sin(4.0 * (iTime - (5.0 * PI / 12.0))) + 5.0, 0.0 );\n    Sphere[2].radius = 0.4;\n    Sphere[2].materialID = 3;\n\n    Sphere[3].center = vec3( 4.4, sin(4.0 * (iTime - (6.0 * PI / 12.0))) + 5.0, 0.0 );\n    Sphere[3].radius = 0.3;\n    Sphere[3].materialID = 3;\n\n    Sphere[4].center = vec3( -1.8, sin(4.0 * (iTime - (2.0 * PI / 12.0))) + 5.0, 0.0 );\n    Sphere[4].radius = 0.5;\n    Sphere[4].materialID = 3;\n\n    Sphere[5].center = vec3( -3.2, sin(4.0 * (iTime - (PI / 12.0))) + 5.0, 0.0 );\n    Sphere[5].radius = 0.4;\n    Sphere[5].materialID = 3;\n\n    Sphere[6].center = vec3( -4.4, sin(4.0 * iTime) + 5.0, 0.0 );\n    Sphere[6].radius = 0.3;\n    Sphere[6].materialID = 3;\n\n    // Wall material.\n    Material[0].k_d = vec3( 0.59, 0.52, 0.3685 );\n    Material[0].k_a = 0.2 * Material[0].k_d;\n    Material[0].k_r = 1.0 * Material[0].k_d;\n    Material[0].k_rg = 0.5 * Material[0].k_r;\n    Material[0].k_t = 0.5 * Material[0].k_d;\n    Material[0].n = 64.0;\n    Material[0].m = 64.0;\n    \n    // Floor material.\n    Material[1].k_d = vec3( 0.533, 0.484, 0.424 );\n    Material[1].k_a = 0.2 * Material[1].k_d;\n    Material[1].k_r = 2.0 * Material[1].k_d;\n    Material[1].k_rg = 0.5 * Material[1].k_r;\n    Material[1].k_t = 2.0 * Material[1].k_d;\n    Material[1].n = 64.0;\n    Material[1].m = 64.0;\n\n    // Middle sphere material.\n    Material[2].k_d = vec3( 0.5, 0.8, 0.9 );\n    Material[2].k_a = 0.2 * Material[2].k_d;\n    Material[2].k_r = 1.0 * Material[2].k_d;\n    Material[2].k_rg = 0.5 * Material[2].k_r;\n    Material[2].k_t = 2.0 * Material[2].k_d;\n    Material[2].n = 64.0;\n    Material[2].m = 128.0;\n\n    // Little sphere material.\n    Material[3].k_d = vec3( 0.6, 0.8, 0.6 );\n    Material[3].k_a = 0.2 * Material[3].k_d;\n    Material[3].k_r = vec3( 1.0, 1.0, 1.0 );\n    Material[3].k_rg = 0.5 * Material[3].k_r;\n    Material[3].k_t = 2.0 * Material[3].k_d;\n    Material[3].n = 128.0;\n    Material[3].m = 32.0;\n\n    // Light 1.\n    Light[0].position = vec3( -4.0, 8.0, 0.0 );\n    //Light[0].I_a = vec3( 0.5, abs(sin(iTime) * cos(iTime)) , abs(cos(iTime)) );\n    Light[0].I_a = vec3( 0.1, 0.1 , 0.1 );\n    Light[0].I_source = vec3( 1.0, 1.0, 1.0 );\n\n    Box[0].center = vec3(0.0, (cos(4.0 * (iTime - (3.0 * PI / 12.0))) + 2.74)/2.0, 0.0);\n    Box[0].xLen = 1.6;\n    Box[0].yLen = cos(4.0 * (iTime - (3.0 * PI / 12.0))) + 2.74;\n    Box[0].zLen = 1.6;\n    Box[0].xAngle = 0.0;\n    Box[0].yAngle = 2.0 * PI * sin(0.15 * iTime);\n    Box[0].zAngle = 0.0;\n    InitBoxVertices(0);\n    Box[0].materialID = 2;\n     \n}\n\n\n\n/////////////////////////////////////////////////////////////////////////////\n// Computes intersection between a plane and a ray.\n// Returns true if there is an intersection where the ray parameter t is\n// between tmin and tmax, otherwise returns false.\n// If there is such an intersection, outputs the value of t, the position\n// of the intersection (hitPos) and the normal vector at the intersection \n// (hitNormal).\n/////////////////////////////////////////////////////////////////////////////\nbool IntersectPlane( in Plane_t pln, in Ray_t ray, in float tmin, in float tmax,\n                     out float t, out vec3 hitPos, out vec3 hitNormal ) \n{\n    vec3 N = vec3( pln.A, pln.B, pln.C );\n    float NRd = dot( N, ray.d );\n    float NRo = dot( N, ray.o );\n    float t0 = (-pln.D - NRo) / NRd;\n    if ( t0 < tmin || t0 > tmax ) return false;\n\n    // We have a hit -- output results.\n    t = t0;\n    hitPos = ray.o + t0 * ray.d;\n    hitNormal = normalize( N );\n    return true;\n}\n\n\n\n/////////////////////////////////////////////////////////////////////////////\n// Computes intersection between a plane and a ray.\n// Returns true if there is an intersection where the ray parameter t is\n// between tmin and tmax, otherwise returns false.\n/////////////////////////////////////////////////////////////////////////////\nbool IntersectPlane( in Plane_t pln, in Ray_t ray, in float tmin, in float tmax )\n{\n    vec3 N = vec3( pln.A, pln.B, pln.C );\n    float NRd = dot( N, ray.d );\n    float NRo = dot( N, ray.o );\n    float t0 = (-pln.D - NRo) / NRd;\n    if ( t0 < tmin || t0 > tmax ) return false;\n    return true;\n}\n\n\n\n/////////////////////////////////////////////////////////////////////////////\n// Computes intersection between a sphere and a ray.\n// Returns true if there is an intersection where the ray parameter t is\n// between tmin and tmax, otherwise returns false.\n// If there is one or two such intersections, outputs the value of the \n// smaller t, the position of the intersection (hitPos) and the normal \n// vector at the intersection (hitNormal).\n/////////////////////////////////////////////////////////////////////////////\nbool IntersectSphere( in Sphere_t sph, in Ray_t ray, in float tmin, in float tmax,\n                      out float t, out vec3 hitPos, out vec3 hitNormal ) \n{\n    /////////////////////////////////\n    // TASK: WRITE YOUR CODE HERE. //\n    /////////////////////////////////\n\n    // Generate temporary objects with 'test' prefix\n    Sphere_t testSphere = sph;\n    Ray_t testRay = ray;\n    \n    // Translate the temporary objects to sphere's local space\n    testRay.o = testRay.o - testSphere.center;\n    testSphere.center = vec3(0.0, 0.0, 0.0);\n    \n    // Components of the test quadratic equation\n    float a = 1.0;\n    float b = 2.0 * dot(testRay.d, testRay.o);\n    float c = dot(testRay.o, testRay.o) - dot(testSphere.radius, testSphere.radius);\n    \n    // Discriminant\n    float d = b * b - 4.0 * a * c;\n    \n    // No intersection\n    // Includes the case of tangency, when d = 0.0\n    if (d <= 0.0)\n        return false;\n    \n    // They have a intersection\n    float tMinor = (-b - sqrt(d)) / (2.0 * a);\n    float tMajor = (-b + sqrt(d)) / (2.0 * a);\n    \n    // Choose the minimal positive solution\n    float t0;\n    if (tMinor > tmin) {\n    \tt0 = tMinor;\n    /*} else if (tMajor > tmin) {\n        // tMinor <= 0 but tMajor > 0\n        t0 = tMajor;*/\n    } else {\n        // tMinor, tMajor <= 0\n     \treturn false;\n    }\n\n    // Hit position and normal vector\n    if ( tmin < t0 && t0 < tmax ) {\n        t = t0;\n        hitPos = ray.o + t * ray.d;\n        hitNormal = normalize(hitPos - sph.center);\n        return true;\n    } else {\n    \t// the \"epsilon\" problem\n        return false;\n    }\n}\n\n\n\n/////////////////////////////////////////////////////////////////////////////\n// Computes intersection between a sphere and a ray.\n// Returns true if there is an intersection where the ray parameter t is\n// between tmin and tmax, otherwise returns false.\n/////////////////////////////////////////////////////////////////////////////\nbool IntersectSphere( in Sphere_t sph, in Ray_t ray, in float tmin, in float tmax )\n{\n    /////////////////////////////////\n    // TASK: WRITE YOUR CODE HERE. //\n    /////////////////////////////////\n\n    // Just used to cater for parameter list\n    float t;\n    vec3 hitPos, hitNormal;\n    \n    // Some redundant calculations of the precise hit position\n    // for keeping the consistency of the same code\n    return IntersectSphere(sph, ray, tmin, tmax, t, hitPos, hitNormal);\n}\n\n\n/////////////////////////////////////////////////////////////////////////////\n// Computes (I_a * k_a) + k_shadow * I_source * [ k_d * (N.L) + k_r * (R.V)^n ].\n// Input vectors L, N and V are pointing AWAY from surface point.\n// Assume all vectors L, N and V are unit vectors.\n/////////////////////////////////////////////////////////////////////////////\nvec3 PhongLighting( in vec3 L, in vec3 N, in vec3 V, in bool inShadow, \n                    in Material_t mat, in Light_t light )\n{\n    if ( inShadow ) {\n        return light.I_a * mat.k_a;\n    }\n    else {\n        vec3 R = reflect( -L, N );\n        float N_dot_L = max( 0.0, dot( N, L ) );\n        float R_dot_V = max( 0.0, dot( R, V ) );\n        float R_dot_V_pow_n = ( R_dot_V == 0.0 )? 0.0 : pow( R_dot_V, mat.n );\n\n        return light.I_a * mat.k_a + \n               light.I_source * (mat.k_d * N_dot_L + mat.k_r * R_dot_V_pow_n);\n    }\n}\nmat3 RotateXMat(float a)\n{\n    return mat3(1.0, 0.0, 0.0, 0.0, cos(a), sin(a), 0.0, -sin(a), cos(a));\n}\nmat3 RotateYMat(float a)\n{\n    return mat3(cos(a), 0.0, -sin(a), 0.0, 1.0, 0.0, sin(a), 0.0, cos(a));\n}\nmat3 RotateZMat(float a)\n{\n    return mat3(cos(a), sin(a), 0.0,\n                -sin(a), cos(a), 0.0,\n                0.0, 0.0, 1.0);\n}\n\n/////////////////////////////////////////////////////////////////////////////\n// Computes intersection between a box and a ray.\n// Returns true if there is an intersection where the ray parameter t is\n// between tmin and tmax, otherwise returns false.\n/////////////////////////////////////////////////////////////////////////////\nbool IntersectTriangle(in Triangle_t triangle, in Ray_t ray, in float tmin, in float tmax,\n    out float t, out vec3 hitPos, out vec3 hitNormal)\n{\n    // Equation w.r.t. beta, gamma and t\n    mat3 LeftMat = mat3(triangle.A - triangle.B, triangle.A - triangle.C, ray.d);\n    vec3 rightVec = vec3(triangle.A - ray.o);\n\n    vec3 solution = inverse(LeftMat) * rightVec;\n    float beta = solution.x;\n    float gamma = solution.y;\n    t = solution.z;\n\n    bool isHit = (beta + gamma < 1.0)\n        && (beta > 0.0) && (gamma > 0.0)\n        && (tmin < t && t < tmax);\n    \n    // No intersection\n    if ( !isHit )\n        return false;\n    \n    // t has been already updated\n    // ......\n    \n    // Hit Position\n    hitPos = ray.o + t * ray.d;\n    \n    // Hit Normal Vector\n    vec3 AB = triangle.B - triangle.A;\n    vec3 AC = triangle.C - triangle.A;\n    vec3 BC = triangle.C - triangle.B;\n    vec3 NormalA = cross(AB, AC);\n    vec3 NormalB = cross(AB, BC);\n    vec3 NormalC = cross(AC, BC);\n    hitNormal = normalize( (1.0-beta-gamma)*NormalA + beta*NormalB + gamma*NormalC );\n    \n    return true;\n}\n\nbool IntersectTriangle(in Triangle_t triangle, in Ray_t ray, in float tmin, in float tmax)\n{\n    float t;\n    vec3 hitPos, hitNormal;\n    \n    return IntersectTriangle(triangle, ray, tmin, tmax,\n        t, hitPos, hitNormal);\n}\n\nbool IntersectBox(in Box_t box, in Ray_t ray, in float tmin, in float tmax,\n                     out float t, out vec3 hitPos, out vec3 hitNormal)\n{\n    // Generate temporary objects\n    Ray_t testRay = ray;\n    \n    // Rotation Matrix\n    mat3 rotationMat = RotateXMat(box.xAngle) * RotateYMat(box.yAngle) * RotateZMat(box.zAngle);\n    // Translation and rotation of points\n    testRay.o = inverse(rotationMat) * (ray.o - box.center);\n    // Rotation of vectors\n    testRay.d = normalize(inverse(rotationMat) * ray.d);\n    \n    bool hasHitSth = false;\n    float nearest_t = DEFAULT_TMAX;   // The ray parameter t at the nearest hit point.\n    vec3 nearest_hitPos;              // 3D position of the nearest hit point.\n    vec3 nearest_hitNormal;           // Normal vector at the nearest hit point.\n    // int nearest_hitMatID;             // MaterialID of the object at the nearest hit point.\n\n    float temp_t;\n    vec3 temp_hitPos;\n    vec3 temp_hitNormal;\n    bool temp_hasHit;\n\n    // Intersection detection for each triangle\n    for (int i = 0; i < 12; i++)\n    {\n        Triangle_t tempTriangle;\n        tempTriangle.A = box.vertices[TriIndices[i].x];\n        tempTriangle.B = box.vertices[TriIndices[i].y];\n        tempTriangle.C = box.vertices[TriIndices[i].z];\n        \n        // Actual intersection detection\n        temp_hasHit = IntersectTriangle(tempTriangle, testRay, tmin, tmax,\n            temp_t, temp_hitPos, temp_hitNormal);\n        \n        if (temp_hasHit)\n        {\n            hasHitSth = true;\n            \n            if (temp_t < nearest_t)\n            {\n                nearest_t = temp_t;\n                nearest_hitPos = temp_hitPos;\n                nearest_hitNormal = temp_hitNormal;\n            }\n        }\n    }\n    \n    if (hasHitSth) {\n        t = nearest_t;\n        \n        // Transform points to the world space\n        hitPos = box.center + rotationMat * nearest_hitPos;\n        \n        hitNormal = rotationMat * nearest_hitNormal;\n        \n        return true;\n    } else\n        return false;\n}\n\nbool IntersectBox(in Box_t box, in Ray_t ray, in float tmin, in float tmax)\n{\n    float t;\n    vec3 hitPos, hitNormal;\n    \n    return IntersectBox(box, ray, tmin, tmax,\n        t, hitPos, hitNormal);\n}\n\n/////////////////////////////////////////////////////////////////////////////\n// Casts a ray into the scene and returns color computed at the nearest\n// intersection point. The color is the sum of light from all light sources,\n// each computed using Phong Lighting Model, with consideration of\n// whether the interesection point is being shadowed from the light.\n// If there is no interesection, returns the background color, and outputs\n// hasHit as false.\n// If there is intersection, returns the computed color, and outputs\n// hasHit as true, the 3D position of the intersection (hitPos), the\n// normal vector at the intersection (hitNormal), and the k_rg value\n// of the material of the intersected object.\n/////////////////////////////////////////////////////////////////////////////\nvec3 CastRay( in Ray_t ray, \n              out bool hasHit, out vec3 hitPos, out vec3 hitNormal, out vec3 k_rg,out vec3 k_t ) \n{\n    // Find whether and where the ray hits some object. \n    // Take the nearest hit point.\n\n    bool hasHitSomething = false;\n    float nearest_t = DEFAULT_TMAX;   // The ray parameter t at the nearest hit point.\n    vec3 nearest_hitPos;              // 3D position of the nearest hit point.\n    vec3 nearest_hitNormal;           // Normal vector at the nearest hit point.\n    int nearest_hitMatID;             // MaterialID of the object at the nearest hit point.\n\n    float temp_t;\n    vec3 temp_hitPos;\n    vec3 temp_hitNormal;\n    bool temp_hasHit;\n\n    /////////////////////////////////////////////////////////////////////////////\n    // TASK:\n    // * Try interesecting input ray with all the planes and spheres,\n    //   and record the front-most (nearest) interesection.\n    // * If there is interesection, need to record hasHitSomething,\n    //   nearest_t, nearest_hitPos, nearest_hitNormal, nearest_hitMatID.\n    /////////////////////////////////////////////////////////////////////////////\n\n    /////////////////////////////////\n    // TASK: WRITE YOUR CODE HERE. //\n    /////////////////////////////////\n\n    for (int i = 0; i < NUM_PLANES; i++)\n    {\n        temp_hasHit = IntersectPlane(Plane[i], ray, DEFAULT_TMIN, DEFAULT_TMAX,\n                                     temp_t, temp_hitPos, temp_hitNormal);\n        if (temp_hasHit)\n        {\n            hasHitSomething = true;\n            \n            if (temp_t < nearest_t)\n            {\n                nearest_t = temp_t;\n                nearest_hitPos = temp_hitPos;\n                nearest_hitNormal = temp_hitNormal;\n                nearest_hitMatID = Plane[i].materialID;\n            }\n        }   \n    }\n    \n    for (int i = 0; i < NUM_SPHERES; i++)\n    {\n        temp_hasHit = IntersectSphere(Sphere[i], ray, DEFAULT_TMIN, DEFAULT_TMAX,\n                                     temp_t, temp_hitPos, temp_hitNormal);\n        if (temp_hasHit)\n        {\n            hasHitSomething = true;\n            \n            if (temp_t < nearest_t)\n            {\n                nearest_t = temp_t;\n                nearest_hitPos = temp_hitPos;\n                nearest_hitNormal = temp_hitNormal;\n                nearest_hitMatID = Sphere[i].materialID;\n            }\n        }\n    }\n    for (int i = 0; i < NUM_BOXES; i++)\n    {\n        temp_hasHit = IntersectBox(Box[i], ray, DEFAULT_TMIN, DEFAULT_TMAX,\n            temp_t, temp_hitPos, temp_hitNormal);\n\n        if (temp_hasHit)\n        {\n            hasHitSomething = true;\n\n            if (temp_t < nearest_t)\n            {\n                nearest_t = temp_t;\n                nearest_hitPos = temp_hitPos;\n                nearest_hitNormal = temp_hitNormal;\n                nearest_hitMatID = Box[i].materialID;\n            }\n        }\n    }\n    // One of the output results.\n    hasHit = hasHitSomething;\n    if ( !hasHitSomething ) return BACKGROUND_COLOR;\n\n    vec3 I_local = vec3( 0.0 );  // Result color will be accumulated here.\n\n    /////////////////////////////////////////////////////////////////////////////\n    // TASK:\n    // * Accumulate lighting from each light source on the nearest hit point. \n    //   They are all accumulated into I_local.\n    // * For each light source, make a shadow ray, and check if the shadow ray\n    //   intersects any of the objects (the planes and spheres) between the \n    //   nearest hit point and the light source.\n    // * Then, call PhongLighting() to compute lighting for this light source.\n    /////////////////////////////////////////////////////////////////////////////\n\n    /////////////////////////////////\n    // TASK: WRITE YOUR CODE HERE. //\n    /////////////////////////////////\n    for (int i = 0; i < NUM_LIGHTS; i++)\n    {\n        Ray_t shadowRay;\n        // ShadowRay points to the light source\n        // from the hit position of ray\n        shadowRay.o = nearest_hitPos;\n        shadowRay.d = normalize(Light[i].position - nearest_hitPos);\n        \n        for (int j = 0; j < NUM_PLANES; j++)\n        {\n            temp_hasHit = IntersectPlane(Plane[j], shadowRay,\n                DEFAULT_TMIN, distance(Light[i].position, nearest_hitPos));\n            if (temp_hasHit)\n                break;\n        }\n        if ( ! temp_hasHit )\n        {\n            for (int j = 0; j < NUM_SPHERES; j++)\n            {\n                temp_hasHit = IntersectSphere(Sphere[j], shadowRay,\n                    DEFAULT_TMIN, distance(Light[i].position, nearest_hitPos));\n                if (temp_hasHit)\n                    break;\n            }\n        }\n        if ( ! temp_hasHit )\n        {\n            // Check the boxes\n            for (int j = 0; j < NUM_BOXES; j++)\n            {\n                temp_hasHit = IntersectBox(Box[j], shadowRay,\n                    DEFAULT_TMIN, distance(Light[i].position, nearest_hitPos));\n                if (temp_hasHit)\n                    break;\n            }\n\n        }\n        // Light vector is a unit vector from hit point to the light source\n        vec3 L = shadowRay.d;\n        // Normal vector\n        vec3 N = nearest_hitNormal;\n        // View vector\n        vec3 V = -normalize(ray.d);\n        // shadowRay hits something\n        bool inShadow = temp_hasHit;\n        \n        I_local += PhongLighting(L, N, V, inShadow,\n            Material[nearest_hitMatID], Light[i]);\n    }\n\n    // Populate output results.\n    hitPos = nearest_hitPos;\n    hitNormal = nearest_hitNormal;\n    k_rg = Material[nearest_hitMatID].k_rg;\n    k_t = Material[nearest_hitMatID].k_t;\n    return I_local;\n}\n\n\n\n/////////////////////////////////////////////////////////////////////////////\n// Execution of fragment shader starts here.\n// 1. Initializes the scene.\n// 2. Compute a primary ray for the current pixel (fragment).\n// 3. Trace ray into the scene with NUM_ITERATIONS recursion levels.\n/////////////////////////////////////////////////////////////////////////////\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    InitScene();\n\n    // Scale pixel 2D position such that its y coordinate is in [-1.0, 1.0].\n    vec2 pixel_pos = (2.0 * fragCoord.xy - iResolution.xy) / iResolution.y;\n\n    // Position the camera.\n    // vec3 cam_pos = vec3( 8.0 * sin(0.3 * iTime), 4.0, 8.0 * cos(0.3 * iTime) );\n    float cam_theta = 4.0 * PI * sin(0.1 * iTime);\n    float cam_radius = 2.0 + 3.0 / (2.0 * PI) * abs(cam_theta);\n    vec3 cam_pos = vec3( cam_radius*cos(cam_theta), 4.0, cam_radius*sin(cam_theta) );\n    vec3 cam_lookat = vec3( 0.0, 4.0, 0.0 );\n    vec3 cam_up_vec = vec3( 0.0, 1.0, 0.0 );\n\n    // Set up camera coordinate frame in world space.\n    vec3 cam_z_axis = normalize( cam_pos - cam_lookat );\n    vec3 cam_x_axis = normalize( cross(cam_up_vec, cam_z_axis) );\n    vec3 cam_y_axis = normalize( cross(cam_z_axis, cam_x_axis));\n\n    // Create primary ray.\n    float pixel_pos_z = -1.0 / tan(FOVY / 2.0);\n    Ray_t pRay;\n    pRay.o = cam_pos;\n    pRay.d = normalize( pixel_pos.x * cam_x_axis  +  pixel_pos.y * cam_y_axis  +  pixel_pos_z * cam_z_axis );\n\n\n    // Start Ray Tracing.\n    // Use iterations to emulate the recursion.\n\n\n    vec3 I_result = vec3( 0.0 );\n    vec3 compounded_k_rg = vec3( 0.5 );\n    vec3 compounded_k_t = vec3( 0.5 );\n    Ray_t nextRay_r = pRay;\n    Ray_t nextRay_t = pRay;\n\n    for ( int level = 0; level <= NUM_ITERATIONS; level++ ) \n    {\n        bool hasHit_r, hasHit_t;\n        vec3 hitPos_r, hitPos_t, hitNormal_r, hitNormal_t, k_rg1, k_t1, k_rg2, k_t2;\n        vec3 I_local_r = CastRay( nextRay_r, hasHit_r, hitPos_r, hitNormal_r, k_rg1, k_t1 );\n        vec3 I_local_t = CastRay( nextRay_t, hasHit_t, hitPos_t, hitNormal_t, k_rg2, k_t2 );\n        I_result += compounded_k_rg * I_local_r + compounded_k_t * I_local_t;\n\n        if ( !hasHit_r && !hasHit_t) break;\n\n        compounded_k_rg *= k_rg1;\n        compounded_k_t *= k_t2;\n        nextRay_r = Ray_t( hitPos_r, normalize( reflect(nextRay_r.d, hitNormal_r) ) );\n        nextRay_t = Ray_t( hitPos_t, normalize( refract(nextRay_t.d, hitNormal_t, 0.8) ) );\n    }\n    \n    fragColor = vec4( I_result, 1.0 );\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ltccRS.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[3793, 3975, 4004, 4004, 4676], [4677, 4677, 4695, 4695, 8840], [8844, 9341, 9496, 9496, 9826], [9830, 10162, 10245, 10245, 10457], [10461, 10981, 11139, 11307, 12582], [12586, 12919, 13004, 13164, 13399], [13402, 13756, 13887, 13887, 14300], [14301, 14301, 14327, 14327, 14404], [14405, 14405, 14431, 14431, 14508], [14509, 14509, 14535, 14535, 14644], [14646, 14976, 15122, 15163, 16072], [16074, 16074, 16166, 16166, 16301], [16303, 16303, 16451, 16485, 18342], [18344, 18344, 18421, 18421, 18546], [18548, 19337, 19465, 19557, 24965], [24969, 25330, 25387, 25387, 27467]], "test": "untested"}
{"id": "ltccWN", "name": "Perforations 3", "author": "ahihi", "description": "we are consumed", "tags": ["2d"], "likes": 3, "viewed": 416, "published": "Public API", "date": "1532703176", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define TAU 6.283185307179586\n\nfloat mod289(float x){return x - floor(x * (1.0 / 289.0)) * 289.0;}\nvec3 mod289(vec3 x) {return x - floor(x * (1.0 / 289.0)) * 289.0;}\nvec4 mod289(vec4 x){return x - floor(x * (1.0 / 289.0)) * 289.0;}\nvec4 permute(vec4 x){return mod289(((x * 34.0) + 1.0) * x);}\n\nfloat noise(vec3 p){\n    vec3 a = floor(p);\n    vec3 d = p - a;\n    d = d * d * (3.0 - 2.0 * d);\n\n    vec4 b = a.xxyy + vec4(0.0, 1.0, 0.0, 1.0);\n    vec4 k1 = permute(b.xyxy);\n    vec4 k2 = permute(k1.xyxy + b.zzww);\n\n    vec4 c = k2 + a.zzzz;\n    vec4 k3 = permute(c);\n    vec4 k4 = permute(c + 1.0);\n\n    vec4 o1 = fract(k3 * (1.0 / 41.0));\n    vec4 o2 = fract(k4 * (1.0 / 41.0));\n\n    vec4 o3 = o2 * d.z + o1 * (1.0 - d.z);\n    vec2 o4 = o3.yw * d.x + o3.xz * (1.0 - d.x);\n\n    return o4.y * d.y + o4.x * (1.0 - d.y);\n}\n\n//\n// GLSL textureless classic 3D noise \"cnoise\",\n// with an RSL-style periodic variant \"pnoise\".\n// Author:  Stefan Gustavson (stefan.gustavson@liu.se)\n// Version: 2011-10-11\n//\n// Many thanks to Ian McEwan of Ashima Arts for the\n// ideas for permutation and gradient selection.\n//\n// Copyright (c) 2011 Stefan Gustavson. All rights reserved.\n// Distributed under the MIT license. See LICENSE file.\n// https://github.com/stegu/webgl-noise\n//\n\nvec4 taylorInvSqrt(vec4 r)\n{\n  return 1.79284291400159 - 0.85373472095314 * r;\n}\n\nvec3 fade(vec3 t) {\n  return t*t*t*(t*(t*6.0-15.0)+10.0);\n}\n\n// Classic Perlin noise\nfloat cnoise(vec3 P)\n{\n  vec3 Pi0 = floor(P); // Integer part for indexing\n  vec3 Pi1 = Pi0 + vec3(1.0); // Integer part + 1\n  Pi0 = mod289(Pi0);\n  Pi1 = mod289(Pi1);\n  vec3 Pf0 = fract(P); // Fractional part for interpolation\n  vec3 Pf1 = Pf0 - vec3(1.0); // Fractional part - 1.0\n  vec4 ix = vec4(Pi0.x, Pi1.x, Pi0.x, Pi1.x);\n  vec4 iy = vec4(Pi0.yy, Pi1.yy);\n  vec4 iz0 = Pi0.zzzz;\n  vec4 iz1 = Pi1.zzzz;\n\n  vec4 ixy = permute(permute(ix) + iy);\n  vec4 ixy0 = permute(ixy + iz0);\n  vec4 ixy1 = permute(ixy + iz1);\n\n  vec4 gx0 = ixy0 * (1.0 / 7.0);\n  vec4 gy0 = fract(floor(gx0) * (1.0 / 7.0)) - 0.5;\n  gx0 = fract(gx0);\n  vec4 gz0 = vec4(0.5) - abs(gx0) - abs(gy0);\n  vec4 sz0 = step(gz0, vec4(0.0));\n  gx0 -= sz0 * (step(0.0, gx0) - 0.5);\n  gy0 -= sz0 * (step(0.0, gy0) - 0.5);\n\n  vec4 gx1 = ixy1 * (1.0 / 7.0);\n  vec4 gy1 = fract(floor(gx1) * (1.0 / 7.0)) - 0.5;\n  gx1 = fract(gx1);\n  vec4 gz1 = vec4(0.5) - abs(gx1) - abs(gy1);\n  vec4 sz1 = step(gz1, vec4(0.0));\n  gx1 -= sz1 * (step(0.0, gx1) - 0.5);\n  gy1 -= sz1 * (step(0.0, gy1) - 0.5);\n\n  vec3 g000 = vec3(gx0.x,gy0.x,gz0.x);\n  vec3 g100 = vec3(gx0.y,gy0.y,gz0.y);\n  vec3 g010 = vec3(gx0.z,gy0.z,gz0.z);\n  vec3 g110 = vec3(gx0.w,gy0.w,gz0.w);\n  vec3 g001 = vec3(gx1.x,gy1.x,gz1.x);\n  vec3 g101 = vec3(gx1.y,gy1.y,gz1.y);\n  vec3 g011 = vec3(gx1.z,gy1.z,gz1.z);\n  vec3 g111 = vec3(gx1.w,gy1.w,gz1.w);\n\n  vec4 norm0 = taylorInvSqrt(vec4(dot(g000, g000), dot(g010, g010), dot(g100, g100), dot(g110, g110)));\n  g000 *= norm0.x;\n  g010 *= norm0.y;\n  g100 *= norm0.z;\n  g110 *= norm0.w;\n  vec4 norm1 = taylorInvSqrt(vec4(dot(g001, g001), dot(g011, g011), dot(g101, g101), dot(g111, g111)));\n  g001 *= norm1.x;\n  g011 *= norm1.y;\n  g101 *= norm1.z;\n  g111 *= norm1.w;\n\n  float n000 = dot(g000, Pf0);\n  float n100 = dot(g100, vec3(Pf1.x, Pf0.yz));\n  float n010 = dot(g010, vec3(Pf0.x, Pf1.y, Pf0.z));\n  float n110 = dot(g110, vec3(Pf1.xy, Pf0.z));\n  float n001 = dot(g001, vec3(Pf0.xy, Pf1.z));\n  float n101 = dot(g101, vec3(Pf1.x, Pf0.y, Pf1.z));\n  float n011 = dot(g011, vec3(Pf0.x, Pf1.yz));\n  float n111 = dot(g111, Pf1);\n\n  vec3 fade_xyz = fade(Pf0);\n  vec4 n_z = mix(vec4(n000, n100, n010, n110), vec4(n001, n101, n011, n111), fade_xyz.z);\n  vec2 n_yz = mix(n_z.xy, n_z.zw, fade_xyz.y);\n  float n_xyz = mix(n_yz.x, n_yz.y, fade_xyz.x); \n  return 2.2 * n_xyz;\n}\n\n// Classic Perlin noise, periodic variant\nfloat pnoise(vec3 P, vec3 rep)\n{\n  vec3 Pi0 = mod(floor(P), rep); // Integer part, modulo period\n  vec3 Pi1 = mod(Pi0 + vec3(1.0), rep); // Integer part + 1, mod period\n  Pi0 = mod289(Pi0);\n  Pi1 = mod289(Pi1);\n  vec3 Pf0 = fract(P); // Fractional part for interpolation\n  vec3 Pf1 = Pf0 - vec3(1.0); // Fractional part - 1.0\n  vec4 ix = vec4(Pi0.x, Pi1.x, Pi0.x, Pi1.x);\n  vec4 iy = vec4(Pi0.yy, Pi1.yy);\n  vec4 iz0 = Pi0.zzzz;\n  vec4 iz1 = Pi1.zzzz;\n\n  vec4 ixy = permute(permute(ix) + iy);\n  vec4 ixy0 = permute(ixy + iz0);\n  vec4 ixy1 = permute(ixy + iz1);\n\n  vec4 gx0 = ixy0 * (1.0 / 7.0);\n  vec4 gy0 = fract(floor(gx0) * (1.0 / 7.0)) - 0.5;\n  gx0 = fract(gx0);\n  vec4 gz0 = vec4(0.5) - abs(gx0) - abs(gy0);\n  vec4 sz0 = step(gz0, vec4(0.0));\n  gx0 -= sz0 * (step(0.0, gx0) - 0.5);\n  gy0 -= sz0 * (step(0.0, gy0) - 0.5);\n\n  vec4 gx1 = ixy1 * (1.0 / 7.0);\n  vec4 gy1 = fract(floor(gx1) * (1.0 / 7.0)) - 0.5;\n  gx1 = fract(gx1);\n  vec4 gz1 = vec4(0.5) - abs(gx1) - abs(gy1);\n  vec4 sz1 = step(gz1, vec4(0.0));\n  gx1 -= sz1 * (step(0.0, gx1) - 0.5);\n  gy1 -= sz1 * (step(0.0, gy1) - 0.5);\n\n  vec3 g000 = vec3(gx0.x,gy0.x,gz0.x);\n  vec3 g100 = vec3(gx0.y,gy0.y,gz0.y);\n  vec3 g010 = vec3(gx0.z,gy0.z,gz0.z);\n  vec3 g110 = vec3(gx0.w,gy0.w,gz0.w);\n  vec3 g001 = vec3(gx1.x,gy1.x,gz1.x);\n  vec3 g101 = vec3(gx1.y,gy1.y,gz1.y);\n  vec3 g011 = vec3(gx1.z,gy1.z,gz1.z);\n  vec3 g111 = vec3(gx1.w,gy1.w,gz1.w);\n\n  vec4 norm0 = taylorInvSqrt(vec4(dot(g000, g000), dot(g010, g010), dot(g100, g100), dot(g110, g110)));\n  g000 *= norm0.x;\n  g010 *= norm0.y;\n  g100 *= norm0.z;\n  g110 *= norm0.w;\n  vec4 norm1 = taylorInvSqrt(vec4(dot(g001, g001), dot(g011, g011), dot(g101, g101), dot(g111, g111)));\n  g001 *= norm1.x;\n  g011 *= norm1.y;\n  g101 *= norm1.z;\n  g111 *= norm1.w;\n\n  float n000 = dot(g000, Pf0);\n  float n100 = dot(g100, vec3(Pf1.x, Pf0.yz));\n  float n010 = dot(g010, vec3(Pf0.x, Pf1.y, Pf0.z));\n  float n110 = dot(g110, vec3(Pf1.xy, Pf0.z));\n  float n001 = dot(g001, vec3(Pf0.xy, Pf1.z));\n  float n101 = dot(g101, vec3(Pf1.x, Pf0.y, Pf1.z));\n  float n011 = dot(g011, vec3(Pf0.x, Pf1.yz));\n  float n111 = dot(g111, Pf1);\n\n  vec3 fade_xyz = fade(Pf0);\n  vec4 n_z = mix(vec4(n000, n100, n010, n110), vec4(n001, n101, n011, n111), fade_xyz.z);\n  vec2 n_yz = mix(n_z.xy, n_z.zw, fade_xyz.y);\n  float n_xyz = mix(n_yz.x, n_yz.y, fade_xyz.x); \n  return 2.2 * n_xyz;\n}\n\nfloat scale(float l0, float r0, float l1, float r1, float x) {\n\treturn (x - l0) / (r0 - l0) * (r1 - l1) + l1;\n}\n\nvec2 polar(vec2 p) {\n\treturn vec2(atan(p.y, p.x), length(p));\n}\n\nvec2 cartesian(vec2 p) {\n\treturn vec2(p.y * cos(p.x), p.y * sin(p.x))\t;\n}\n\nvec2 rotate(float theta, vec2 p) {\n\tvec2 p_polar = polar(p);\n\tp_polar.x += theta;\n\treturn cartesian(p_polar);\n}\n\nvec2 shear(float theta, vec2 p) {\n\treturn vec2(p.x - p.y / tan(theta), p.y / sin(theta));\n}\n\nvec2 unshear(float theta, vec2 p) {\n\tfloat y = p.y * sin(theta);\n\tfloat x = p.x + y / tan(theta);\n\treturn vec2(x, y);\t\n}\n\nvec2 target(float theta, float delta, vec2 p) {\n\treturn unshear(theta, floor(shear(theta, p) + delta) - delta + 0.5);\n}\n\nfloat perforations(float theta, float rot, float scale, float r, vec2 p0) {\n\tvec2 p1 = scale * rotate(rot, p0);\n\treturn distance(p1, target(theta, 0.5, p1)) - r;\n}\n\nvec3 blend(float k, vec3 c0, vec3 c1) {\n\tfloat k_clamp = clamp(k, 0.0, 1.0);\n\treturn (1.0 - k) * c0 + k * c1;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\tvec2 p0 = 2.0*(fragCoord.xy - 0.5 * iResolution.xy) / iResolution.xx;\n\tvec2 p0_1 = vec2(p0.x, p0.y);\n\tvec2 p0_2 = vec2(p0.x, p0.y);\n\t\n\tvec2 p1_polar = polar(p0);\n    float wave_cos =\n        (0.05 * sin(0.102*iTime)) *\n        cos(-0.7722*iTime + (0.0 + 10.0 * sin(0.114112*iTime)) * length(p0));\n\tp1_polar.y = p1_polar.y * pow(1.0 + wave_cos, 1.5);\n\tvec2 p1 = cartesian(p1_polar);\n\t\n\t//float theta = TAU / 2.1;\n    float theta = TAU / 3.0;\n\t\n\tfloat rot1 = 0.0011 * TAU * iTime;\n\tfloat rot2 = rot1 + TAU / 12.0 + TAU / 4.0 * sin(0.05213 * iTime);\n\t\n\tfloat scale1 = 12.0 + 0.0 * sin(0.3212*iTime);\n\tfloat scale2 = 12.0;\n\t\n\tfloat r1 = 0.24;\n\tfloat r2 = 0.24;\n\t\n    vec2 p2 = p1 + vec2(0.02 * sin(0.212 * iTime), 0.01 * cos(0.12 * iTime));\n    \n\tfloat i1 = perforations(theta, rot1, scale1, r1, p2);\n\tfloat i2 = perforations(theta, rot2, scale2, r2, p1);\n\t\n    vec2 bg_p1 = 10.2 * rotate(-0.03 * iTime, p2);\n    float bg_noise1 = scale(-1.0, 1.0, 0.0, 1.0, cnoise(vec3(bg_p1.x, 0.5*iTime, bg_p1.y)));\n    \n    vec2 bg_p2 = 77.11 * rotate(0.024 * iTime, p2);\n    float bg_noise2 = scale(-1.0, 1.0, 0.0, 1.0, cnoise(vec3(bg_p2.x, 1.33*iTime, bg_p2.y)));\n    \n    float bg_noise = bg_noise1 * pow(bg_noise2, 1.0);\n    \n    float fg_noise = 1.0 - 0.9 * noise(vec3(231.0*p1, 7.2*iTime));\n    \n\tvec3 bg = blend(length(p0), vec3(0.2), vec3(0.1)) * bg_noise;\n\tvec3 fg = blend(length(p0), vec3(0.4), vec3(0.2)) * fg_noise;\n\t\n\tfloat satan = 0.06;\n\tfloat k = scale(-satan, satan, 0.0, 1.0, max(i1, i2));\n\t\n\tvec3 color;\n\tif(k < 0.0) {\n\t\tcolor = fg;\n\t} else if(k < 1.0) {\n\t\tcolor = blend(k, bg/0.2, fg);\n        //color = blend(k, fg, bg/0.3);\n    } else {\n     \tcolor = blend(k-1.0, 0.9*bg, bg);   \n    }\n\t    \n\tfragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ltccWN.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[31, 31, 53, 53, 98], [99, 99, 120, 120, 165], [166, 166, 186, 186, 231], [232, 232, 253, 253, 292], [294, 294, 314, 314, 817], [819, 1263, 1291, 1291, 1343], [1345, 1345, 1364, 1364, 1404], [1406, 1430, 1452, 1452, 3748], [3750, 3792, 3824, 3824, 6154], [6156, 6156, 6218, 6218, 6267], [6269, 6269, 6289, 6289, 6332], [6334, 6334, 6358, 6358, 6407], [6409, 6409, 6443, 6443, 6520], [6522, 6522, 6555, 6555, 6613], [6615, 6615, 6650, 6650, 6735], [6737, 6737, 6784, 6784, 6856], [6858, 6858, 6933, 6933, 7021], [7023, 7023, 7062, 7062, 7134], [7136, 7136, 7193, 7193, 8923]], "test": "untested"}
{"id": "ltcczB", "name": "Negative Mandelbrot & Julia", "author": "FutureFractal", "description": "The negative Mandelbrot set, also known as the Negabrot set. The negative Mandelbrot set is obtained by raising z to the power of -2 instead of 2 on every iteration. Click and drag the mouse to explore its Julia sets.", "tags": ["fractal", "julia", "mandelbrot", "negabrot"], "likes": 4, "viewed": 173, "published": "Public API", "date": "1533020568", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Negabrot viewer\n// by FutureFractal\n\n\nconst float M_PI = 3.14159265358979323846264338327950288;\n\nconst int MAX_ITER = 506;\n\n\n#if __VERSION__ < 300\nbool isnan(float x)\n{\n    // The builtin isnan() function is only supported in WebGL 2.0 or higher.\n    // If it's unavailable, use this as a fallback.\n    // source: https://stackoverflow.com/questions/11810158\n    return (x < 0.0 || 0.0 < x || x == 0.0) ? false : true;\n}\n#endif\n\n\nvec2 cmplx_mul(vec2 a, vec2 b)\n{\n    return vec2(a.x*b.x - a.y*b.y,\n                a.y*b.x + a.x*b.y);\n}\n\nvec2 cmplx_pow(vec2 z, float p)\n{\n    // Adapted from Microsoft's reference source for .NET's Complex type\n    // https://referencesource.microsoft.com/#System.Numerics/System/Numerics/Complex.cs\n    \n    if (p == 0.0) {\n        return vec2(1.0, 0.0);\n    }\n    if (z == vec2(0.0, 0.0)) {\n        return z;\n    }\n    \n    float rho = length(z);\n    float theta = atan(z.y, z.x);\n    float newRho = p * theta;\n    \n    float t = pow(rho, p);\n    \n    return vec2(t * cos(newRho), t * sin(newRho));\n}\n\nvec2 cmplx_pow2(vec2 z)\n{\n    return vec2((z.x*z.x) - (z.y*z.y), \n                2.0 * z.x * z.y);\n}\n\nvec2 cmplx_recipr(vec2 z)\n{\n    // Also adapted from Microsoft's reference source\n    \n    // Smith's formula\n    float c = z.x;\n    float d = z.y;\n  \tif (c - d > 0.0) {\n        float doc = d / c;\n        return vec2(1.0 / (c + d*doc), -doc / (c + d*doc));\n    } else {\n        float cod = c / d;\n        return vec2(cod / (d + c*cod), -1.0 / (d + c*cod));\n    }\n}\n\nvec2 cmplx_pow2_recipr(vec2 z)\n{\n    // Compute 1/(z^2).\n    // First, try this with the optimized cmplx_pow2 and cmplx_recipr functions.\n    // Unfortunately, for some values these functions over/underflow and generate NaNs.\n    // When that happens, fall back on cmplx_pow, which is more accurate but much slower.\n \tvec2 zz = cmplx_recipr(cmplx_pow2(z));\n    return (!isnan(zz.x) && !isnan(zz.y)) ? zz : cmplx_pow(z, -2.0);\n}\n\n\nvec2 scaleFragCoord(vec2 fragCoord, vec2 resolution, float scale)\n{\n    if (resolution.x > resolution.y) {\n        return vec2(\n            scale * ((4.0 * fragCoord.x / resolution.x) - 2.0),\n            scale * (4.0 * (fragCoord.y - (resolution.y / 2.0)) / resolution.x)\n        );\n    } else {\n        return vec2(\n            scale * (4.0 * (fragCoord.x - (resolution.x / 2.0)) / resolution.y),\n            scale * ((4.0 * fragCoord.y / resolution.y) - 2.0)\n        );\n    }\n}\n\n\nvec3 hsv2rgb(vec3 c)\n{\n    // source: https://lolengine.net/blog/2013/07/27/rgb-to-hsv-in-glsl\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvec4 hsv2rgb(float h, float s, float v)\n{\n \treturn vec4(hsv2rgb(vec3(h, s, v)), 1.0);\n}\n\nvec4 reimannColor(vec2 z)\n{\n    // Compute a color based on the point's last value's distance from the origin.\n    // Specifically, its position between 0 and infinity on the Reimann sphere.\n\t// Maps [0, 1, inf] on the Reimann sphere to real numbers [0, 0.5, 1].\n    float R = atan(length(z)) * (2.0 / M_PI);\n    \n    // slowly cycle the colors:\n    float anim = iTime * (1.0 / 50.0);\n    \n    float h = (1.0 - R) + anim;\n    float s = 1.0;\n    float v = 1.0;\n    return hsv2rgb(h, s, v);\n}\n\n\nvec4 drawNegaJulia(vec2 c, vec2 j)\n{\n    vec2 z = c;\n    for (int i = 0; i < MAX_ITER; ++i)\n    {\n//\t\tz = cmplx_pow(z, -2.0) + j;\n\t    z = cmplx_pow2_recipr(z) + j;\n    }\n    return reimannColor(z);\n}\n\nvec4 drawNegabrot(vec2 c)\n{\n    vec2 z = c;\n    for (int i = 0; i < MAX_ITER; ++i)\n    {\n//\t\tz = cmplx_pow(z, -2.0) + c;\n        z = cmplx_pow2_recipr(z) + c;\n    }\n    return reimannColor(z);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    const float scale = 1.2;\n    \n    vec2 c = scaleFragCoord(fragCoord.xy, iResolution.xy, scale);\n    \n    if (iMouse.z > 0.0) {\n        vec2 j = scaleFragCoord(iMouse.xy, iResolution.xy, scale);\n    \tfragColor = drawNegaJulia(c, j);\n    } else {\n        fragColor = drawNegabrot(c);\n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ltcczB.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 433, 465, 465, 538], [540, 540, 573, 735, 1038], [1040, 1040, 1065, 1065, 1141], [1143, 1143, 1170, 1252, 1507], [1509, 1509, 1541, 1824, 1936], [1939, 1939, 2006, 2006, 2418], [2421, 2421, 2443, 2515, 2684], [2686, 2686, 2727, 2727, 2773], [2775, 2775, 2802, 3037, 3265], [3268, 3268, 3304, 3304, 3468], [3470, 3470, 3497, 3497, 3664], [3666, 3666, 3721, 3721, 4015]], "test": "untested"}
{"id": "ltdcD7", "name": "marblelike", "author": "rformato", "description": "marble like animation", "tags": ["fbm"], "likes": 1, "viewed": 162, "published": "Public API", "date": "1532940429", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define NUM_OCTAVES 6\n\n// Simplex 2D noise\n//\nvec3 permute(vec3 x) { return mod(((x*34.0)+1.0)*x, 289.0); }\n\nfloat noise(vec2 v){\n  const vec4 C = vec4(0.211324865405187, 0.366025403784439,\n           -0.577350269189626, 0.024390243902439);\n  vec2 i  = floor(v + dot(v, C.yy) );\n  vec2 x0 = v -   i + dot(i, C.xx);\n  vec2 i1;\n  i1 = (x0.x > x0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);\n  vec4 x12 = x0.xyxy + C.xxzz;\n  x12.xy -= i1;\n  i = mod(i, 289.0);\n  vec3 p = permute( permute( i.y + vec3(0.0, i1.y, 1.0 ))\n  + i.x + vec3(0.0, i1.x, 1.0 ));\n  vec3 m = max(0.5 - vec3(dot(x0,x0), dot(x12.xy,x12.xy),\n    dot(x12.zw,x12.zw)), 0.0);\n  m = m*m ;\n  m = m*m ;\n  vec3 x = 2.0 * fract(p * C.www) - 1.0;\n  vec3 h = abs(x) - 0.5;\n  vec3 ox = floor(x + 0.5);\n  vec3 a0 = x - ox;\n  m *= 1.79284291400159 - 0.85373472095314 * ( a0*a0 + h*h );\n  vec3 g;\n  g.x  = a0.x  * x0.x  + h.x  * x0.y;\n  g.yz = a0.yz * x12.xz + h.yz * x12.yw;\n  return 130.0 * dot(m, g);\n}\n\nconst mat2 rot = mat2(cos(0.5), sin(0.5), -sin(0.5), cos(0.50));\nfloat fbm(vec2 x) {\n\tfloat v = 0.0;\n\tfloat a = 0.5;\n\tvec2 shift = vec2(100);\n\t// Rotate to reduce axial bias\n\tfor (int i = 0; i < NUM_OCTAVES; ++i) {\n\t\tv += a * noise(x);\n\t\tx = rot * x * 2.0 + shift;\n\t\ta *= 0.5;\n\t}\n\treturn v;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Time varying pixel color\n    float time = iTime / 100.;\n    float f = fbm(vec2(time)+uv + fbm(vec2(time)-uv));\n\n    float r = smoothstep(.0, 0.4, f);\n    float g = smoothstep(.3, 0.7, f);\n    float b = smoothstep(.6, 1., f);\n    \n    vec3 col = vec3(r, g, b);\n    float f2 = .5 - f;\n    \n\tr = smoothstep(.0, .6, f2);\n    g = smoothstep(.3, .9, f2);\n    b = smoothstep(.4, 1., f2);\n    \n    vec3 col2 = vec3(r, g, b);    \n    col = mix(col, col2, f2);\n    //col += col2;\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ltdcD7.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[23, 46, 68, 68, 107], [109, 109, 129, 129, 949], [1016, 1016, 1035, 1035, 1243], [1245, 1245, 1302, 1352, 1932]], "test": "untested"}
{"id": "ltdcRn", "name": "columns 12: pile of pipes", "author": "FabriceNeyret2", "description": "See reference image below\n", "tags": ["raymarching", "sdf", "short", "reproduction"], "likes": 6, "viewed": 424, "published": "Public API", "date": "1531343173", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// variant of  https://shadertoy.com/view/4sKfD3\n\n/**/\nvoid mainImage(out vec4 O, vec2 U) {\n    \n    float t = iTime, l, r=.5,s=1.73*r, h=2.;      // r: radius s: offset h: height/2.\n    mat2  R = mat2( cos(.1*sin(t)+vec4(0,33,11,0)) );\n    vec3  q = iResolution,\n          D = normalize(vec3((U+U-q.xy)/q.y, -8)),// ray direction\n          p = 30./q;                             // marching point along ray \n    O-=O; t++;\n    for ( O++; O.x > 0. && t > .01 ; O-=.015 )\n  //for ( O++; O.x > .001 && t > .01 ; O*=.95 )\n        q = p,\n        q.xz *= R, q.yz *= R,                    // rotation\n        t = 1e5,\n#define C q.x = mod( q.x+r, r+r) -r,    \\\n          q.y = mod( q.y+s, s+s) -s,    \\\n          l   = length(q.xy),           \\\n        t = min(t, max(l -r/1.05, -(l-.8*r/1.05))) // hollow cylinder \n        \n        C,                                       // even row\n        q.xy -= r*vec2(1,1.73), C,               // odd row\n        \n        t = max(t,abs(q.z) -h),                       // column length in Z\n\n        p += t*D;                                // step forward = dist to obj\n  //O = vec4(.8,.9,1,1) - O;\n    O *= .4; if (O.x<0.) O = vec4(.8,.9,1,1);\n  //O *= .5; if (t>.01) O = vec4(.8,.9,1,1);\n\n}\n\n/**/\n\n\n\n\n\n/**  // -23 chars\n\nvoid mainImage(out vec4 O, vec2 U) {\n    \n    float t = iTime, l, h=2.;                    // r: radius h: height/2.\n    vec2 r  = .5*vec2(1,1.73);\n    mat2  R = mat2( cos(.1*sin(t)+vec4(0,33,11,0)) );\n    vec3  q = iResolution,\n          D = normalize(vec3((U+U-q.xy)/q.y, -8)),// ray direction\n          p = 30./q;                             // marching point along ray \n    O-=O; t++;\n    for ( O++; O.x > 0. && t > .01 ; O-=.015 )\n        q = p,\n        q.xz *= R, q.yz *= R,                    // rotation\n        t = 1e5,\n#define C l = length(q.xy = mod( q.xy+r, r+r) -r),      \\\n          t = min(t, max(l -r.x/1.05, -(l-.8*r.x/1.05)))  // hollow cylinder \n        \n        C,                                       // even row\n        q.xy -= r, C,                            // odd row\n        \n        t = max(t,abs(q.z) -h),                  // column length in Z\n\n        p += t*D;                                // step forward = dist to obj\n}\n/**/", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ltdcRn.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[50, 55, 91, 91, 1226]], "test": "untested"}
{"id": "ltdczM", "name": "gamepad mildly optimized", "author": "ollj", "description": "gamepad with slightly optimized symmetry for better .\nEach color/pieve also got its own subroutine to more easily take this thing apart.", "tags": ["symmetry", "gamepad"], "likes": 6, "viewed": 369, "published": "Public API", "date": "1532085232", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n//self: https://www.shadertoy.com/view/ltdczM\n//parent: https://www.shadertoy.com/view/ltXcDr\n//3d shape gamepad(symmetry code looks suboptimal)\n\n// CREATED BY KIM BERKEBY,SEP 2017\n\n#define rotate(a)mat2(cos(a),-sin(a),sin(a),cos(a))\n\n // pad top,buttons,cross,cable,sticks,shoulder buttons\n const vec4[10] partColor=vec4[](vec4(.65,0.14,0.14,0.6),// pad top\n vec4(0.5,0.14,.14,0.6),//buttons\n vec4(.3,0.3,0.3,0.5),//cross\n vec4(0.2,0.2,0.2,0.35),//cable\n vec4(.3,0.3,0.3,0.4),//sticks\n vec4(0.5,0.5,.5,0.6),// shoulder buttons\n vec4(.3,0.3,0.3,0.5),// start/select\n vec4(.3,0.3,0.3,0.4),// pad bottom\n vec4(0.5,0.5,.5,0.6),//buttons left\n vec4(.35,.35,.34,0.3));// ground\n\nconst vec3 eps=vec3(0.02,0.0,0.0);\nconst int maxRaySteps=512;\n\n\nstruct RayHit{bool hit;vec3 hitPos;vec3 normal;float dist;float depth;float steps;int hitID;};\n\nRayHit marchResult;\n\n\nfloat sdBox(vec3 p,vec3 b){vec3 d=abs(p)-b;return min(max(d.x,max(d.y,d.z)),0.0)+length(max(d,0.0));}\n\nfloat sdTriPrism(vec3 p,vec2 h){vec3 q=abs(p);return max(q.z-h.y,max(q.x*0.866025+p.y*0.5,-p.y)-h.x*0.5);}\n\nfloat sdCapsule(vec3 p,vec3 a,vec3 b,float r\n){vec3 pa=p-a,ba=b-a;float h=clamp(dot(pa,ba)/dot(ba,ba),0.0,1.0);return length(pa-ba*h)-r;}\n\nfloat sdCapsule(vec3 p,vec3 a,vec3 b\n){vec3 pa=p-a,ba=b-a;float h=clamp(dot(pa,ba)/dot(ba,ba),0.0,1.0);return length(pa-ba*h);}\n\n\nfloat Cable(vec3 p,vec3 a,vec3 b,float r\n){vec3 pa=p-a;b.xz=mix(b.xz,b.xz*rotate(1.1),smoothstep(1.0,6.0,pa.z))\n ;b.xz=mix(b.xz,b.xz*rotate(-1.20),smoothstep(1.0,14.0,pa.z))\n ;b.y=mix(b.y,-1.55,smoothstep(.0,1.0,pa.z))\n ;vec3 ba=b-a\n ;float h=clamp(dot(pa,ba)/dot(ba,ba),0.0,1.0)\n ;return length(pa-ba*h)-r;}\n\n\nfloat sdCappedCylinder(vec3 p,vec2 h){vec2 d=abs(vec2(length(p.xz),p.y))-h;return min(max(d.x,d.y),0.0)+length(max(d,0.0));}\n\nfloat sdEllipsoid(in vec3 p,in vec3 r){return(length(p/r)-1.0)*min(min(r.x,r.y),r.z);}\n\n\nvec3 opRotXY(vec3 pos,vec3 rayPos,float rad){vec3 sPos=rayPos-pos;sPos.xy*=rotate(rad);return sPos+rayPos;}\nvec3 opRotXZ(vec3 pos,vec3 rayPos,float rad){vec3 sPos=rayPos-pos;sPos.xz*=rotate(rad);return sPos+rayPos;}\nvec3 opRotYZ(vec3 pos,vec3 rayPos,float rad){vec3 sPos=rayPos-pos;sPos.yz*=rotate(rad);return sPos+rayPos;}\n\n\n\nfloat ControllerBase(vec3 q,float oScale\n){q.x=abs(q.x)\n ;float d=sdCappedCylinder(q-vec3(1.4,-.04,0),vec2(1,.12)*oScale)\n ;d=min(d,sdCappedCylinder(q-vec3(.35,0,-.4),vec2(.5,.08)*oScale))\n ;d=min(d,sdBox(q-vec3(0,0,.2),vec3(1,.08,.7)*oScale))\n ;d=min(d,sdBox(q-vec3(0,0,.2),vec3(.5,.07,.79)*oScale))\n ;d=max(d,-sdBox(q-vec3(0,0,1.1),vec3(.2,1.08,.15)*oScale))\n ;return d;}\n\nfloat ShoulderButtons(in vec3 p,float controllBase,float oScale\n){\n ;vec3 q=p;q.x=abs(q.x)\n ;float d=sdCappedCylinder(q-vec3(1.45,-.1,.10),vec2(1,.12)*oScale)\n ;d=max(d,-sdBox(q-vec3(2.5,0,.42),vec3(.4,1.08,2.9)*oScale))\n ;d=-max(-d,-sdBox(p-vec3(0,-.1,.2),vec3(1.6,.08,.8)*oScale))\n ;d=max(d,-sdBox(p-vec3(0,0,.42),vec3(1.2,1.08,2.9)*oScale))\n ;d=max(d,-sdBox(p-vec3(0,0,-.42),vec3(3.,.68,1.)*oScale))\n ;return d;}\n\n\nint objectID =0;\n\nfloat dd5(vec3 q){//2 analog sticks\n ;q.x=abs(q.x);\n ;float d5=sdEllipsoid(q-vec3(.35,-.35,.50),vec3(.3,.18,.3))\n ;d5=min(d5,sdCappedCylinder(q-vec3(.35,-.35,.5),vec2(.15,.3)))\n ;d5=min(d5,sdEllipsoid(q-vec3(.35,-.05,.5),vec3(.22,.03,.22)))\n ;return d5;}\n\nfloat dd2(vec3 p){// buttons\n ;float d2=sdCappedCylinder(p-vec3(-1.45,-.3,1.40),vec2(.18,.12)) \n ;d2=max(d2,-sdEllipsoid(p-vec3(-1.45,-.16,1.40),vec3(.25,.04,.25)))\n ;d2=max(d2,-sdEllipsoid(p-vec3(-1.90,-.16,1),vec3(.25,.04,.25)))\n ;d2=min(d2,sdCappedCylinder(p-vec3(-1.90,-.3,1.0),vec2(.18,.12)))\n ;return d2;}\n  \nfloat dd3(vec3 p){// cross\n ;float d3=sdEllipsoid(p-vec3(1.55,-.265,1),vec3(.46,.06,.46))\n ;d3=min(d3,sdBox(p-vec3(1.55,-.22,1.0),vec3(.4,.06,.13)))\n ;d3=min(d3,sdBox(p-vec3(1.55,-.22,1.0),vec3(.13,.06,.4)))\n ;d3=max(d3,-sdEllipsoid(p-vec3(1.55,-.2,1.0),vec3(.16,.04,.16)))\n ;vec3 pPos=p-vec3(1.55,-.13,1.25)// calculate button arrows and perform boolean\n ;pPos.xz*=rotate(radians(120.))\n ;pPos.zy*=rotate(radians(90.))\n ;d3=max(d3,-sdTriPrism(pPos,vec2(.15,.05)));pPos=p-vec3(1.55,-.13,.75);pPos.xz*=rotate(radians(300.));pPos.zy*=rotate(radians(90.))\n ;d3=max(d3,-sdTriPrism(pPos,vec2(.15,.05)));pPos=p-vec3(1.8,-.13,1.);pPos.xz*=rotate(radians(210.));pPos.zy*=rotate(radians(90.))\n ;d3=max(d3,-sdTriPrism(pPos,vec2(.15,.05)));pPos=p-vec3(1.3,-.13,1.);pPos.xz*=rotate(radians(30.));pPos.zy*=rotate(radians(90.))\n ;d3=max(d3,-sdTriPrism(pPos,vec2(.15,.05)))\n ;return d3;}\n\nfloat dd7(vec3 p){// start select buttons\n ;float d7=sdCapsule(p-vec3(-.1,-.25,1.4),vec3(0,0,-.15),vec3(-.22,0,.05))\n ;d7=min(d7,sdCapsule(p-vec3(.45,-.25,1.4),vec3(0,0,-.15),vec3(-.22,0,.05)))\n ;return d7-.095;}\n \nfloat dd8(vec3 p){\n ;float d8=ControllerBase(p-vec3(0,-.51,1),1.05)\n ;d8=min(d8,sdCappedCylinder(p-vec3(-1.45,-.25,1),vec2(.765,.03)))\n ;d8=min(d8,sdEllipsoid(p-vec3(-1.45,-.25,1),vec3(.7,.1,.7)))\n ;// button holes\n ;d8=max(d8,-sdEllipsoid(p-vec3(-1.45,-.18,1.4),vec3(.32,.06,.32)))\n ;d8=max(d8,-sdEllipsoid(p-vec3(-1.45,-.18,.60),vec3(.32,.06,.32)))\n ;d8=max(d8,-sdEllipsoid(p-vec3(-1.9,-.18,1),vec3(.32,.06,.32)))\n ;d8=max(d8,-sdEllipsoid(p-vec3(-1,-.18,1),vec3(.32,.06,.32)))\n ;return d8;}\n \nfloat dd9(vec3 p){\n ;float d9=sdCappedCylinder(p-vec3(-1.45,-.3,.6),vec2(0.18,.12))\n ;d9=max(d9,-sdEllipsoid(p-vec3(-1,-.16,1),vec3(.25,.04,.25)))\n ;d9=min(d9,sdCappedCylinder(p-vec3(-1,-.3,1),vec2(.18,.12)))\n ;d9=max(d9,-sdEllipsoid(p-vec3(-1.45,-.16,.6),vec3(.25,.04,.25)))//2 red buttons,diagonal mirror \n ;return d9;}\n \nfloat dd1(vec3 p){\n ;vec3 q=p;q.x=abs(q.x)\n ;float d=ControllerBase(p-vec3(0,-0.3,1),1.)\n ;d=max(d,-sdCappedCylinder(p-vec3(-1.45,-0.22,1.0),vec2(0.8,0.02)));// button ring\n ;d=max(d,-sdEllipsoid(p-vec3(1.55,-.22,1),vec3(.7,.1,.7)))// cross cutout\n ;d=max(d,-sdEllipsoid(p-vec3(1.55,-.22,1),vec3(1,.03,1)))// cross cutout\n ;d=max(d,-sdCapsule(p-vec3(0,-.4,2.1),vec3(0,0,-.5),vec3(0,0,3.))-.13)// cable input\n ;d=min(d,sdCapsule(p-vec3(0,-.39,2.07),vec3(0,0,-.1),vec3(0,0,-.1))-.11)// cable input\n ;d=max(d,-sdEllipsoid(q-vec3(.35,-.15,.5),vec3(.4,.2,.4)))// analog buttons\n ;d=max(d,-sdCapsule(p-vec3(-.1,-.06,1.4),vec3(0,0,-.15),vec3(-22,0,.05))-.2)// start select cutouts\n ;d=max(d,-sdCapsule(p-vec3(.45,-.06,1.4),vec3(0,0,-.15),vec3(-22,0,.05))-.2)// start select cutouts\n ;return d;}\n\nfloat Map(in vec3 p\n){\n ;float d =dd1(p)\n ;float d2=dd2(p)\n ;float d3=dd3(p)\n ;float d5=dd5(p)\n ;float d6=ShoulderButtons(p-vec3(0,-0.3,1),d,1.)\n ;float d7=dd7(p)\n ;float d8=dd8(p)\n ;float d9=dd9(p) \n ;float d4=sdCapsule(p-vec3(0,-.39,2.07),vec3(0),vec3(0))-.11// cable\n ;d4=min(d4,Cable(p-vec3(0,-.4,2.1),vec3(0,0,-1),vec3(0,0,70),.072))\n \n ;objectID =1 \n ;if(d2<d){objectID =2;d=d2;}\n ;if(d3<d){objectID =3;d=d3;}\n ;if(d4<d){objectID =4;d=d4;}\n ;if(d5<d){objectID =5;d=d5;}\n ;if(d6<d){objectID =6;d=d6;}\n ;if(d7<d){objectID =7;d=d7;}\n ;if(d8<d){objectID =8;d=d8;}\n ;if(d9<d){objectID =9;d=d9;}\n\n\n ;if(p.y+0.75<d){ d=p.y+0.75;objectID =10;}return d;}\n\nvec3 calcNormal(in vec3 pos\n){return normalize(vec3(Map(pos+eps.xyy)-Map(pos-eps.xyy),0.5*2.0*eps.x,Map(pos+eps.yyx)-Map(pos-eps.yyx)));}\n\nfloat SoftShadow(in vec3 origin,in vec3 direction\n){float res=2.0\n ;float t=0.0\n ;float hardness=6.0\n ;for(int i=0;i<64;i++\n){float h=Map(origin+direction*t)\n  ;res=min(res,hardness*h/t)\n  ;t +=clamp(h,0.02,0.10)\n  ;if(h<0.001)break;}return clamp(res,0.0,1.0);}\n\nRayHit March(in vec3 origin,in vec3 direction\n){RayHit result\n ;objectID =0\n ;float maxDist=100.0,precis=0.001\n ;float t=0.0,dist=0.0,distStep=1.0\n ;vec3 rayPos=vec3(0)\n ;for(int i=0;i<maxRaySteps;i++\n){rayPos =origin+direction*t\n  ;dist=Map(rayPos)\n  ;if(abs(dist)<precis||t>maxDist\n ){result.hit=true\n   ;result.depth=t\n   ;result.dist=dist\n   ;result.hitPos=origin+((direction*t)*0.99)\n   ;result.steps=float(i)\n   ;result.hitID=objectID\n   ;break;}\n  ;t+=dist*distStep;}\n if(t>maxDist){result.hit=false;}\n ;return result;}\n\n// Thanks to Inigo Quilez\nmat3 setCamera(in vec3 ro,in vec3 ta,float cr\n){vec3 cw=normalize(ta-ro)\n ;vec3 cp=vec3(sin(cr),cos(cr),0.0)\n ;vec3 cu=normalize(cross(cw,cp))\n ;vec3 cv=normalize(cross(cu,cw))\n ;return mat3(cu,cv,cw);}\n\nvoid mainImage(out vec4 fragColor,in vec2 fragCoord\n){vec2 mo=iMouse.xy/iResolution.xy\n ;vec2 uv=fragCoord.xy/iResolution.xy\n ;vec2 screenSpace=(-iResolution.xy+2.0*(fragCoord))/iResolution.y\n ;float camrot=0.5*iTime\n ;if(iMouse.w>0.1)camrot=0.0\n ;vec3 rayOrigin=vec3(-0.5+3.5*cos(camrot+6.0*mo.x),1.0+2.0,0.5+4.0*sin(camrot+6.0*mo.x))\n ;mat3 ca=setCamera(rayOrigin,vec3(0.0,-0.9,0.5),0.0)\n ;vec3 rayDir=ca*normalize(vec3(screenSpace.xy,2.0))\n ;vec4 color =vec4(0)\n ;marchResult=March(rayOrigin,rayDir)\n ;if(marchResult.hit\n){marchResult.normal=calcNormal(marchResult.hitPos)\n  ;// calculate light and shadows\n  ;vec3 light1=vec3(1.3,3.8,1.0)\n  ;vec3 light2=vec3(-1.,1.,.0)\n  ;vec4 light1Color=vec4(1.0)\n  ;vec4 light2Color=vec4(1.0)\n  ;float diff=clamp(dot(marchResult.normal,normalize(light1)),0.0,1.0)\n  ;float diff2=clamp(dot(marchResult.normal,normalize(light2)),0.0,0.50)\n  ;float shadow=SoftShadow(marchResult.hitPos,normalize(light1))\n  ;float amb=clamp(0.5+0.5*marchResult.normal.r,0.0,1.0)*1.0\n  ;vec3 lin=vec3(0.0)\n  ;lin+=diff*light1Color.rgb*shadow\n  ;lin+=diff2*light2Color.rgb\n  ;lin+=amb*vec3(0.40)\n  ;vec4 col =partColor[marchResult.hitID-1]\n  ;// reflections in floor\n  ;if(marchResult.hitID==10\n ){vec3 refDir=normalize(reflect(rayDir,marchResult.normal))\n   ;RayHit reflectResult=March(marchResult.hitPos+(refDir*0.001),refDir)\n   ;if(reflectResult.hit==true){col=mix(col,col+(col* partColor[reflectResult.hitID-1]),.35);}}\n  ;float rim=clamp(1.0+dot(marchResult.normal,rayDir),0.0,1.0)\n  ;vec4 ref=vec4(.5);//vec4(texture(iChannel0,marchResult.normal+rayDir).rgb,1.0)\n  ;ref +=rim*pow(0.5,2.0)\n  ;ref /=pow(2.0,col.a)\n  ;color=col*vec4(lin,1.0)// apply lightning\n  ;color.rgb=mix((color.rgb+(color.rgb*ref.rgb))*col.a,(color.rgb+vec3(1.4))*col.a,pow(marchResult.normal.r,2.0));}\n ;fragColor=vec4(pow(color.rgb,vec3(1.0/0.9)),1.0)*(0.5+0.5*pow(16.0*uv.x*uv.y*(1.0-uv.x)*(1.0-uv.y),0.2))\n ;// fragColor=vec4(marchResult.normal,1.0)\n ;}\n\n\n\n/*\nvoid mainImage(out vec4 o,vec2 i \n){o=vec4(fract(iDate.w))\n;}\n/**/", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ltdczM.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[664, 857, 884, 884, 958], [960, 960, 992, 992, 1066], [1068, 1068, 1115, 1115, 1205], [1207, 1207, 1246, 1246, 1334], [1337, 1337, 1380, 1380, 1645], [1648, 1648, 1686, 1686, 1772], [1774, 1774, 1813, 1813, 1860], [1863, 1863, 1908, 1908, 1970], [1971, 1971, 2016, 2016, 2078], [2079, 2079, 2124, 2124, 2186], [2190, 2190, 2233, 2233, 2563], [2565, 2565, 2631, 2631, 2980], [3001, 3001, 3019, 3036, 3255], [3257, 3257, 3275, 3285, 3568], [3572, 3572, 3590, 3598, 4444], [4446, 4446, 4464, 4487, 4658], [4661, 4661, 4679, 4679, 5153], [5156, 5156, 5174, 5174, 5477], [5480, 5480, 5498, 5498, 6267], [6269, 6269, 6291, 6291, 6920], [6922, 6922, 6952, 6952, 7059], [7061, 7061, 7113, 7113, 7322], [7324, 7324, 7372, 7372, 7850], [7852, 7878, 7926, 7926, 8080], [8082, 8082, 8136, 8136, 10036]], "test": "untested"}
{"id": "ltdyR4", "name": "random sdf rings", "author": "aardappel", "description": "somehow inspired by http://www.thisiscolossal.com/2018/06/unique-weathering-chain-link-fence/", "tags": ["sdf"], "likes": 5, "viewed": 158, "published": "Public", "date": "1531850728", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Tweakables, in this order:\nconst int num_circles = 200;\nconst float ring_amount = 80.0;\nconst float color_scale = 3.0;\nconst float smin_sharpness = 0.005;\nconst float rad_scale = 0.08;\nconst float rad_anim_scale = 50.0;\nconst float rad_anim_speed = 3.0;\nconst float ring_border_width = 2.0;\nconst float random_seed = 0.7;\nconst vec3 color1 = vec3(0.3, 1.0, 0.6);\nconst vec3 color2 = vec3(0.3, 0.6, 1.0);\n\nfloat smin(float a, float b, float k) {\n  \tfloat h = clamp(0.5 + 0.5 * (b - a) / k, 0.0, 1.0);\n  \treturn mix(b, a, h) - k * h * (1.0 - h);\n}\n\nfloat rand(vec2 co){\n    return fract(sin(dot(co.xy, vec2(12.9898,78.233))) * 43758.5453);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = fragCoord / iResolution.y;\n    vec2 aspect = vec2(iResolution.x / iResolution.y, 1.0);\n    float d = 10000.0;\n    vec2 pos = vec2(0.5, 0.5);\n    for (int i = 0; i < num_circles; i++) {\n        pos = vec2(rand(pos), rand(pos + random_seed)) * aspect;\n        float rad = rand(pos) * rad_scale + sin(iTime / rad_anim_speed) / rad_anim_scale;\n    \td = smin(d, distance(uv, pos) - rad, smin_sharpness);\n    }\n    float sd = d * ring_amount;\n    vec3 pc = mix(color1, color2, float(int(sd)) / color_scale);\n    vec3 col = vec3(1.0 - pow(abs(fract(sd) * 2.0 - 1.0), ring_border_width)) * pc;\n    fragColor = vec4(col, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ltdyR4.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 408, 447, 447, 548], [550, 550, 570, 570, 642], [644, 644, 699, 699, 1333]], "test": "untested"}
{"id": "ltdyW4", "name": "[SH18] Post-Human Production", "author": "dr2", "description": "Here's where we're headed folks... (mouseable)", "tags": ["robot", "android", "human", "factory", "sh18"], "likes": 13, "viewed": 528, "published": "Public API", "date": "1532707328", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// \"[SH18] Post-Human Production\" by dr2 - 2018\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\n#define AA   0\n\nfloat PrBoxDf (vec3 p, vec3 b);\nfloat PrRoundBoxDf (vec3 p, vec3 b, float r);\nfloat PrBox2Df (vec2 p, vec2 b);\nfloat PrSphDf (vec3 p, float s);\nfloat PrRoundCylDf (vec3 p, float r, float rt, float h);\nvec3 HexGrid (vec2 p);\nfloat SmoothBump (float lo, float hi, float w, float x);\nvec2 Rot2D (vec2 q, float a);\nvec3 HsvToRgb (vec3 c);\nfloat Hashff (float p);\nfloat Noisefv2 (vec2 p);\nvec3 VaryNf (vec3 p, vec3 n, float f);\n\nvec3 ltDir, vnCylOut;\nfloat dstFar, tCur, bCylRad, bCylHt, dCylOut, tPhs, rAngH, rAngL, rAngA, wDisp, gGap, zColr,\n   zHead, zBod, zBgn, zEnd;\nint idObj, wkState;\nbool onHead, onBod;\nconst float pi = 3.14159, sqrt3 = 1.73205;\n\n#define DMIN(id) if (d < dMin) { dMin = d;  idObj = id; }\n\nfloat RobDf (vec3 p, float dMin)\n{\n  vec3 q;\n  float d, ah;\n  d = dstFar;\n  p.y -= 0.25;\n  if (onHead) {\n    q = p;  q.y -= 2.3;\n    d = min (d, max (PrSphDf (q, 0.85), - q.y - 0.2));\n  }\n  if (onBod) {\n    q = p;  q.y -= 1.5;\n    d = min (d, PrRoundCylDf (q.xzy, 0.9, 0.28, 0.75));\n    q = p;  q.x = abs (q.x) - 1.05;  q.y -= 2.;\n    q.yz = Rot2D (q.yz, rAngA * ((wkState == 1) ? sign (p.x) : 1.));\n    q.y -= -0.5;\n    d = min (d, PrRoundCylDf (q.xzy, 0.2, 0.15, 0.6));\n  }\n  if (onHead) {\n    q = p;\n    ah = rAngH * ((wkState == 1) ? 1. : 0.);\n    q.xz = Rot2D (q.xz, ah);\n    q.x = abs (q.x) - 0.3;  q.y -= 3.1;\n    q.xy = Rot2D (q.xy, 0.2 * pi);\n    q.y -= 0.25;\n    d = min (d, PrRoundCylDf (q.xzy, 0.06, 0.04, 0.3));\n  }\n  q = p;  q.x = q.x - 0.4;  q.y -= 0.95;\n  q.yz = Rot2D (q.yz, - rAngL);\n  q.y -= -0.65;\n  d = min (d, PrRoundCylDf (q.xzy, 0.25, 0.15, 0.65));\n  q = p;\n  q.x = - q.x - 0.4;  q.y -= 0.95;\n  q.yz = Rot2D (q.yz, rAngL);\n  q.y -= -0.65;\n  d = min (d, PrRoundCylDf (q.xzy, 0.25, 0.15, 0.65));\n  DMIN (1);\n  if (onHead) {\n    q = p;\n    q.xz = Rot2D (q.xz, ah);\n    q.x = abs (q.x) - 0.4;  q.yz -= vec2 (2.7, 0.7);  d = PrSphDf (q, 0.15);\n    DMIN (2);\n  }\n  return dMin;\n}\n\nvoid SetAng (int wkState)\n{\n  float tc;\n  tc = 2. * pi * mod (0.5 * tPhs, 1.);\n  if (wkState == 1) {\n    rAngH = -0.7 * sin (tc);\n    rAngA = 1.1 * sin (tc);\n    rAngL = 0.5 * sin (tc);\n  } else if (wkState == 0) {\n    rAngH = 0.4 * sin (tc);\n    rAngA = pi - abs (tc - pi); \n    rAngL = 0.;\n  } else if (wkState == -1) {\n    rAngH = 0.;\n    rAngA = 0.; \n    rAngL = 0.;\n  }\n}\n\nfloat ObjDf (vec3 p)\n{\n  vec3 q;\n  float dMin, d;\n  dMin = dstFar;\n  p.x = abs (p.x) - 6.;\n  q = p;\n  q.x = abs (q.x) - 2.;\n  q.z = mod (q.z - wDisp + 0.5 * gGap, gGap) - 0.5 * gGap;\n  SetAng ((p.z > zColr) ? wkState : -1);\n  onHead = (p.z > zHead);\n  onBod = (p.z > zBod);\n  dMin = max (RobDf (q, dMin), max (p.z - zEnd, zBgn - p.z));\n  q = p;  q.yz -= vec2 (2.4, zColr);\n  d = PrRoundBoxDf (q, vec3 (4., 2.4, 0.25), 0.05);\n  d = min (max (d, - PrBox2Df (q.xy - vec2 (0., -0.2), vec2 (3.6, 2.4))), PrBoxDf (q, vec3 (3.6, 2.4, 0.15)));\n  DMIN (3);\n  q = p;\n  q.z = abs (q.z - 0.5 * (zBgn + zEnd)) - 0.5 * abs (zBgn - zEnd);\n  q.y -= 2.4;\n  d = PrRoundBoxDf (q, vec3 (4., 2.4, 1.), 0.05);\n  DMIN (4);\n  q = p;\n  q.z = abs (q.z - 0.5 * (zHead + zBod)) - 0.5 * abs (zHead - zBod);\n  q.y -= 2.4;\n  d = PrRoundBoxDf (q, vec3 (4., 2.4, 1.1), 0.05);\n  q.x = abs (q.x) - 2.;\n  d = min (max (d, - PrBox2Df (q.xy - vec2 (0., -0.2), vec2 (1.3, 2.4))), PrBoxDf (q, vec3 (1.3, 2.4, 1.)));\n  DMIN (4);\n  q.y -= 2.6;\n  d = PrRoundCylDf (q.xzy, 0.2, 0.05, 0.15);\n  DMIN (5);\n  return dMin;\n}\n\nfloat ObjRay (vec3 ro, vec3 rd)\n{\n  float dHit, d;\n  dHit = 0.;\n  for (int j = 0; j < 120; j ++) {\n    d = ObjDf (ro + dHit * rd);\n    dHit += d;\n    if (d < 0.0005 || dHit > dstFar) break;\n  }\n  return dHit;\n}\n\nvec3 ObjNf (vec3 p)\n{\n  const vec3 e = vec3 (0.0001, -0.0001, 0.);\n  vec4 v = vec4 (ObjDf (p + e.xxx), ObjDf (p + e.xyy),\n     ObjDf (p + e.yxy), ObjDf (p + e.yyx));\n  return normalize (vec3 (v.x - v.y - v.z - v.w) + 2. * v.yzw);\n}\n\nfloat ObjSShadow (vec3 ro, vec3 rd)\n{\n  float sh, d, h;\n  sh = 1.;\n  d = 0.1;\n  for (int j = 0; j < 20; j ++) {\n    h = ObjDf (ro + rd * d);\n    sh = min (sh, smoothstep (0., 0.05 * d, h));\n    d += h;\n    if (sh < 0.05) break;\n  }\n  return 0.7 + 0.3 * sh;\n}\n\nvoid InCylHit (vec3 ro, vec3 rd)\n{\n  vec3 s;\n  float a, b, w, ws, srdy;\n  dCylOut = dstFar;\n  vnCylOut = vec3 (0.);\n  a = dot (rd.xz, rd.xz);\n  b = dot (rd.xz, ro.xz);\n  w = b * b - a * (dot (ro.xz, ro.xz) - bCylRad * bCylRad);\n  if (w > 0.) {\n    ws = sqrt (w);\n    srdy = sign (rd.y);\n    if (a > 0.) {\n      dCylOut = (- b + ws) / a;\n      s = ro + dCylOut * rd;\n    } else s.y = bCylHt;\n    if (abs (s.y) < bCylHt) vnCylOut.xz = - s.xz / bCylRad;\n    else {\n      dCylOut = (- srdy * ro.y + bCylHt) / abs (rd.y);\n      vnCylOut.y = - srdy;\n    }\n  }\n}\n\nvec3 ShStagGrid (vec2 p)\n{\n  vec2 q, sq, ss;\n  q = p;\n  if (2. * floor (0.5 * floor (q.y)) != floor (q.y)) q.x += 0.5;\n  sq = smoothstep (0.05, 0.1, abs (fract (q + 0.5) - 0.5));\n  q = fract (q) - 0.5;\n  ss = 0.25 * smoothstep (0.3, 0.5, abs (q.xy)) * sign (q.xy);\n  if (abs (q.x) < abs (q.y)) ss.x = 0.;\n  else ss.y = 0.;\n  return vec3 (ss.x, 0.8 + 0.2 * sq.x * sq.y, ss.y);\n}\n\nvec3 BgCol (vec3 ro, vec3 rd)\n{\n  vec3 vn, col, qh, rg;\n  vec2 qw;\n  float hy, hhy, hw, ww, f, b, aa, sRotH, sRotV, sh;\n  float ga = 2.39996; // = pi * (3 - sqrt(5))\n  InCylHit (ro + vec3 (0., - bCylHt, 0.), rd);\n  if (vnCylOut.y == 0.) {\n    ro += dCylOut * rd;\n    vn = vnCylOut;\n    hy = ro.y / bCylHt - 1.;\n    hhy = abs (hy) - 0.4;\n    aa = atan (vn.x, - vn.z) / pi;\n    sRotH = mod (64. * 0.5 * (1. + aa) + 0.5, 1.) - 0.5;\n    hw = 0.29;\n    ww = 0.28;\n    qw = abs (vec2 (sRotH, hhy));\n    if (qw.x < ww && qw.y < hw) {\n      qw = abs (qw - 0.5 * vec2 (ww, hw)) - vec2 (0.44 * ww, 0.47 * hw);\n      if (max (qw.x, qw.y) < 0.) col = vec3 (0.6, 0.4, 0.2) * (0.8 + 0.2 * cos (0.1 * 2. * pi * tCur));\n      else col = vec3 (0.4, 0.5, 0.3) * (0.5 + 0.5 * max (dot (vn, ltDir), 0.)) +\n         0.5 * pow (max (dot (normalize (ltDir - rd), vn), 0.), 128.);\n    } else {\n      col = vec3 (0.6, 0.8, 0.7);\n      qw -= vec2 (ww, hw);\n      if (abs (hy) > (1. - 0.85/16.) || max (qw.x, qw.y) < 0.02) {\n        col *= 0.9;\n        vn.xz = Rot2D (vn.xz, - pi * aa);\n        if (abs (hy) > (1. - 0.85/16.)) {\n          sRotV = (1. - abs (2. * SmoothBump (1. - 0.9/16., 0.97, 0.03, abs (hy)) - 1.));\n        } else {\n          sRotV = (1. - abs (2. * SmoothBump (hw, hw + 0.02, 0.02, abs (hhy)) - 1.)) * sign (hhy);\n          vn.xz = Rot2D (vn.xz, 0.4 * pi * sign (sRotH) *\n             (1. - abs (2. * SmoothBump (- (ww + 0.02), ww + 0.02, 0.04, sRotH) - 1.)));\n        }\n        vn.yz = Rot2D (vn.yz, -0.2 * pi * sRotV * sign (hy));\n        vn.xz = Rot2D (vn.xz, pi * aa);\n      } else {\n        rg = ShStagGrid (16. * vec2 (12. * aa, hy));\n        col *= rg.y;\n        rg.xz *= sign ((abs (vn.x) > 0.5) ? vn.x : vn.z);\n        if (abs (vn.x) > 0.5) {\n          if (rg.x == 0.) vn.xy = Rot2D (vn.xy, rg.z);\n          else vn.xz = Rot2D (vn.xz, rg.x);\n        } else {\n          if (rg.x == 0.) vn.zy = Rot2D (vn.zy, rg.z);\n          else vn.zx = Rot2D (vn.zx, rg.x);\n        }\n      }\n      col = col * (0.4 + 0.6 * max (dot (vn, ltDir), 0.)) +\n         0.1 * pow (max (dot (normalize (ltDir - rd), vn), 0.), 64.);\n    }\n  } else if (vnCylOut.y > 0.) {\n    ro += dCylOut * rd;\n    b = 1. - smoothstep (-0.1, -0.01, rd.y) * smoothstep (0.4, 0.8, dCylOut / (1.6 * bCylRad));\n    if (abs (abs (ro.x) - 6.) > 4.) {\n      qh = HexGrid (ro.zx);\n      f = max (length (qh.xy) - 0.5, 0.) * b;\n      vn = vec3 (0., Rot2D (vec2 (1., 0.), 4. * f * f));\n      vn.zx = vn.z * vec2 (qh.x, - qh.y) / length (qh.xy);\n      vn = VaryNf (64. * ro, vn, 0.2 * b);\n      col = vec3 (0.72, 0.75, 0.72) * (1. - 0.1 * b * Noisefv2 (128. * ro.xz)) *\n         (1. - min (0.2 * b * (1. - smoothstep (0.03, 0.06, qh.z)), 0.1));\n    } else {\n      vn = vec3 (0., 1., 0.);\n      col = vec3 (0.4, 0.4, 0.45) * (1. - 0.3 * SmoothBump (0.4, 0.6, 0.05, mod (abs (ro.x), 1.)));\n    }\n    sh = ObjSShadow (ro, ltDir);\n    col = col * (0.2 + 0.8 * sh * max (dot (vn, ltDir), 0.)) +\n       0.1 * sh * pow (max (dot (normalize (ltDir - rd), vn), 0.), 64.);\n  } else {\n    ro += dCylOut * rd;\n    f = 0.;\n    qw = ro.xz / bCylRad;\n    for (float n = 0.; n < 256.; n ++) f += 1. - smoothstep (0.02, 0.025,\n       length (qw - sqrt (n / 256.) * sin (n * ga + vec2 (0.5 * pi, 0.))));\n    col = mix (vec3 (0., 0., 0.2), vec3 (1., 1., 0.5), f);\n  }\n  return col;\n}\n\nvoid SetState ()\n{\n  float tWalk, tCyc, wkSpd, nCyc;\n  gGap = 6.;\n  tWalk = 6.;\n  tCyc = tWalk + 4.;\n  wkSpd = gGap / tWalk;\n  nCyc = floor (tCur / tCyc);\n  tPhs = tCur - tCyc * nCyc;\n  wDisp = nCyc * tWalk * wkSpd;\n  if (tPhs < tWalk) {\n    wkState = 1;\n    wDisp += tPhs * wkSpd;\n  } else {\n    wkState = 0;\n    wDisp += tWalk * wkSpd;\n  }\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  vec4 col4;\n  vec3 vn, col;\n  float dstObj, cId;\n  SetState ();\n  zColr = -6.;\n  zHead = -24.;\n  zBod = -36.;\n  zBgn = - bCylRad;\n  zEnd = bCylRad;\n  dstObj = ObjRay (ro, rd);\n  if (dstObj < dstFar) {\n    ro += rd * dstObj;\n    cId = Hashff (11. * sign (ro.x) + 17. * floor ((ro.z - wDisp) / gGap + 0.5));\n    vn = ObjNf (ro);\n    if (idObj == 1) col4 = (ro.z > zColr) ? vec4 (HsvToRgb (vec3 (cId, 1., 0.8)), 0.2) :\n       vec4 (0.9, 0.8, 0.8, 0.);\n    else if (idObj == 2) col4 = (ro.z > zColr) ? vec4 (0.1, 0.5, 0.2, 0.5) : vec4 (0.3, 0.3, 0.3, 0.);\n    else if (idObj == 3) {\n      col4 = vec4 (0.3, 0.4, 0.3, 0.1);\n      if (abs (abs (ro.x) - 6.) < 3.59 && ro.y < 4.39) col4 = vec4 (HsvToRgb (vec3 (cId, 1., 1.)), -1.);\n    } else if (idObj == 4) {\n      col4 = vec4 (0.3, 0.4, 0.3, 0.1);\n      if (abs (abs (abs (ro.x) - 6.) - 2.) < 1.29 && ro.y < 4.59) {\n        if (length (ro.xz) < 0.8 * bCylRad && abs (tPhs - 7.5) < 1.)\n           col4.rgb = vec3 (1., 1., 0.7) * (0.5 + 0.5 * cos (8. * 2. * pi * tCur));\n        else col4.rgb = vec3 (0.1, 0.2, 0.1);\n      }\n    } else if (idObj == 5) {\n      col4 = (abs (tPhs - 7.5) < 1.5 ) ? vec4 (1., 0., 0., -1.) : vec4 (0., 1., 0., -1.);\n      col4.rgb *= 0.3 + 0.7 * smoothstep (0., 0.2, dot (vn, - rd));\n    }\n    col = (col4.a >= 0.) ? col4.rgb * (0.2 + 0.8 * max (dot (vn, ltDir), 0.)) +\n       col4.a * pow (max (dot (normalize (ltDir - rd), vn), 0.), 64.) : 0.8 * col4.rgb;\n    if (idObj == 1 && ro.z > zColr) {\n      rd = reflect (rd, vn);\n      if (rd.y > 0.) col += 0.2 * BgCol (ro, rd);\n    }\n  } else col = BgCol (ro, rd);\n  return col;\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  mat3 vuMat;\n  vec4 mPtr;\n  vec3 ro, rd, col;\n  vec2 canvas, uv, ori, ca, sa;\n  float el, az, zmFac;\n  canvas = iResolution.xy;\n  uv = 2. * fragCoord.xy / canvas - 1.;\n  uv.x *= canvas.x / canvas.y;\n  tCur = iTime;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / canvas - 0.5;\n  bCylRad = 48.;\n  bCylHt = 12.;\n  az = 0.67 * pi + (1.2/16.) * pi * (floor (0.2 * tCur) +\n     smoothstep (0.9, 1., mod (0.2 * tCur, 1.)));\n  el = -0.03 * pi;\n  if (mPtr.z > 0.) {\n    az += 3. * pi * mPtr.x;\n    el += 0.7 * pi * mPtr.y;\n  }\n  el = clamp (el, -0.4 * pi, -0.02 * pi);\n  ori = vec2 (el, az);\n  ca = cos (ori);\n  sa = sin (ori);\n  vuMat = mat3 (ca.y, 0., - sa.y, 0., 1., 0., sa.y, 0., ca.y) *\n          mat3 (1., 0., 0., 0., ca.x, - sa.x, 0., sa.x, ca.x);\n  ro = vuMat * vec3 (0., 2., -0.95 * bCylRad);\n  zmFac = 2.7;\n  dstFar = 2. * bCylRad;\n  ltDir = vuMat * normalize (vec3 (1., 2., -1.));\n#if ! AA\n  const float naa = 1.;\n#else\n  const float naa = 4.;\n#endif  \n  col = vec3 (0.);\n  for (float a = 0.; a < naa; a ++) {\n    rd = vuMat * normalize (vec3 (uv + step (1.5, naa) * Rot2D (vec2 (0.71 / canvas.y, 0.),\n       0.5 * pi * (a + 0.5)), zmFac));\n    col += (1. / naa) * ShowScene (ro, rd);\n  }\n  fragColor = vec4 (pow (clamp (col, 0., 1.), vec3 (0.8)), 1.);\n}\n\nfloat PrBoxDf (vec3 p, vec3 b)\n{\n  vec3 d;\n  d = abs (p) - b;\n  return min (max (d.x, max (d.y, d.z)), 0.) + length (max (d, 0.));\n}\n\nfloat PrRoundBoxDf (vec3 p, vec3 b, float r)\n{\n  return length (max (abs (p) - b, 0.)) - r;\n}\n\nfloat PrBox2Df (vec2 p, vec2 b)\n{\n  vec2 d;\n  d = abs (p) - b;\n  return min (max (d.x, d.y), 0.) + length (max (d, 0.));\n}\n\nfloat PrSphDf (vec3 p, float s)\n{\n  return length (p) - s;\n}\n\nfloat PrRoundCylDf (vec3 p, float r, float rt, float h)\n{\n  float dxy, dz;\n  dxy = length (p.xy) - r;\n  dz = abs (p.z) - h;\n  return min (min (max (dxy + rt, dz), max (dxy, dz + rt)), length (vec2 (dxy, dz) + rt) - rt);\n}\n\nvec2 PixToHex (vec2 p)\n{\n  vec3 c, r, dr;\n  c.xz = vec2 ((1./sqrt3) * p.x - (1./3.) * p.y, (2./3.) * p.y);\n  c.y = - c.x - c.z;\n  r = floor (c + 0.5);\n  dr = abs (r - c);\n  r -= step (dr.yzx, dr) * step (dr.zxy, dr) * dot (r, vec3 (1.));\n  return r.xz;\n}\n\nvec2 HexToPix (vec2 h)\n{\n  return vec2 (sqrt3 * (h.x + 0.5 * h.y), (3./2.) * h.y);\n}\n\nvec3 HexGrid (vec2 p)\n{\n  vec2 q;\n  p -= HexToPix (PixToHex (p));\n  q = abs (p);\n  return vec3 (p, 0.5 * sqrt3 - q.x + 0.5 * min (q.x - sqrt3 * q.y, 0.));\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  vec2 cs;\n  cs = sin (a + vec2 (0.5 * pi, 0.));\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nfloat SmoothBump (float lo, float hi, float w, float x)\n{\n  return (1. - smoothstep (hi - w, hi + w, x)) * smoothstep (lo - w, lo + w, x);\n}\n\nvec3 HsvToRgb (vec3 c)\n{\n  return c.z * mix (vec3 (1.), clamp (abs (fract (c.xxx + vec3 (1., 2./3., 1./3.)) * 6. - 3.) - 1., 0., 1.), c.y);\n}\n\nconst float cHashM = 43758.54;\n\nfloat Hashff (float p)\n{\n  return fract (sin (p) * cHashM);\n}\nvec2 Hashv2v2 (vec2 p)\n{\n  vec2 cHashVA2 = vec2 (37., 39.);\n  return fract (sin (vec2 (dot (p, cHashVA2), dot (p + vec2 (1., 0.), cHashVA2))) * cHashM);\n}\n\nfloat Noisefv2 (vec2 p)\n{\n  vec2 t, ip, fp;\n  ip = floor (p);  \n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = mix (Hashv2v2 (ip), Hashv2v2 (ip + vec2 (0., 1.)), fp.y);\n  return mix (t.x, t.y, fp.x);\n}\n\nfloat Fbmn (vec3 p, vec3 n)\n{\n  vec3 s;\n  float a;\n  s = vec3 (0.);\n  a = 1.;\n  for (int j = 0; j < 5; j ++) {\n    s += a * vec3 (Noisefv2 (p.yz), Noisefv2 (p.zx), Noisefv2 (p.xy));\n    a *= 0.5;\n    p *= 2.;\n  }\n  return dot (s, abs (n));\n}\n\nvec3 VaryNf (vec3 p, vec3 n, float f)\n{\n  vec3 g;\n  vec2 e = vec2 (0.1, 0.);\n  g = vec3 (Fbmn (p + e.xyy, n), Fbmn (p + e.yxy, n), Fbmn (p + e.yyx, n)) - Fbmn (p, n);\n  return normalize (n + f * (g - n * dot (n, g)));\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ltdyW4.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[0, 862, 896, 896, 2059], [2061, 2061, 2088, 2088, 2437], [2439, 2439, 2461, 2461, 3514], [3516, 3516, 3549, 3549, 3726], [3728, 3728, 3749, 3749, 3959], [3961, 3961, 3998, 3998, 4219], [4221, 4221, 4255, 4255, 4776], [4778, 4778, 4804, 4804, 5155], [5157, 5157, 5188, 5188, 8470], [8472, 8472, 8490, 8490, 8815], [8817, 8817, 8852, 8852, 10452], [10454, 10454, 10510, 10510, 11760], [11762, 11762, 11794, 11794, 11894], [11896, 11896, 11942, 11942, 11989], [11991, 11991, 12024, 12024, 12113], [12115, 12115, 12148, 12148, 12175], [12177, 12177, 12234, 12234, 12398], [12400, 12400, 12424, 12424, 12654], [12656, 12656, 12680, 12680, 12740], [12742, 12742, 12765, 12765, 12898], [12900, 12900, 12930, 12930, 13043], [13045, 13045, 13102, 13102, 13185], [13187, 13187, 13211, 13211, 13328], [13362, 13362, 13386, 13386, 13423], [13424, 13424, 13448, 13448, 13578], [13580, 13580, 13605, 13605, 13791], [13793, 13793, 13822, 13822, 14034], [14036, 14036, 14075, 14075, 14255]], "test": "untested"}
{"id": "lttyR7", "name": "twist continuity", "author": "ollj", "description": "upper half has \"thickness\" set by cylinder height\"\nlower half has \"thickness\" set by iMouse.x (matters more if iMouse.x is close to the red dot)\niMouse.x sets \"chirality, spin count, negative chirality is poorly defined, use mirror symmetry instead.", "tags": ["twistcontinuity"], "likes": 1, "viewed": 467, "published": "Public API", "date": "1532086579", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//damnit why was this mostly black, and i needed to log in again to see the whole thing?\n//it works great for my own canvas but in shadertoy i see only black.\n//may be a gpu thing?\n//i cant figure this out right now, help please...\n\n\n\n\n\n\n//note to self. it seems that iFrame fails to count up. not sure.\n//note to self,default background is black,otherwise tiny shadertoy shaders will be white image on white background.\n//-this shader has default background white\n\n\n//this experimental shader deforms a hyperslice for better lipschitz continuity within a twist-deformation.\n//the red dot splits mouse input parameters into 4 quadrants,where varying signs result in varying utility.\n\n//iMouse.x sets chirality,number of twists,this shader has good continuity for [positive chirality],to the right of the red dot\n//iMouse.x left of the red dot is \"poorly defined and only for bebugging\"\n\n//iMouse.y sets helix-thickness(and gamma correction for visibility),it is only discontinuous close to 0. for [ReciprocalThickMode]\n//#define ThickModeMouse\n//attempt to optimize for thinness,set by an epsilon/iMouse.y(not just bad near 0,but dividing by 0 near 0)\n//#define ThickModeReciprocalEps\n\n//thickness depends on height of cylinder\n//#define ThickModeByHeight\n//splitscreen shickmode\n#define ThickModeBySsy\n\n//add holes of a later version of XsdBW8,inner holes changed into rods of dynamick \"thickness\" to indicate a parameter\n//#define doHoles\n\n//this turned out better than expected,yay\n//could really need some bayer-dithering\n//i like this for its uncommon raymarching loop,that has escape orbits in its header.\n\n//based on     https://www.shadertoy.com/view/XsdBW8 \n//which is a variant of https://www.shadertoy.com/view/4dtfWr\n\n\n\n//eps and recEps sets [thickness] epsilon precision directly affects performance,and [object chubbyness]\nconst float recEps=128.;//reciprocal epsilon,powers od 2 likely increase precision,therefore we define epsilon reciprocally.\nconst float rmEps=1./recEps;\n//and in this shader \"brightness/contrast\"\nfloat rmIter=1./1064.;//raymarching iterations could also scale relative to epsilon!\nmat2 rt(float a){return mat2(sin(a+vec4(0,33,11,0)));}//tiny estimation of a rotation matrix.\n\n//rmOrbit()is the exit-condition of a raymarching-loop\n//this is commonly done via \"if(a)break\",except for tiny-code-crucnhing 1-tweet-shader challenges.\n//if a<=0,we marched too deep into the [darkening fog],that darkens with each step.\n//if b<=rmEps,we are close enough to a surface/root,within an arbitiary Epsilon-precision\nbool rmOrbit(float a,float b){\n //;return min(a,b-rmEps)>0.//clean black horizon\n ;return b>b-a&&b>rmEps//clean bright horizon is often better for [glow-contrast] of [step-intensive outlines],aka [glow]\n //;return a>0.&&b-rmEps>0.//messy toggling quadrant(original version)\n ;}\n//ollj fixed ther lipschitz continuity of this helix,by modifying its shape\n\nfloat df(vec3 q,vec2 m,vec2 U//distance field of a helix\n){float l=length(q.xy)\n ;float a=atan(q.y,q.x)\n ;float t=max(abs(q.z)-6.,l-4.)//cylinder\n //note that the 2 flat ends(and the cylinder for small \"recEps\")are still discontinuous,due to union with cylinder-capping-planes.\n //;float scale=length(q.xy)//lipschitz oblivious\n ;float twists=m.x*20.\n //the following is a sloppy but advanced bound for better lipschitz continuity\n //...within a twist-deform(which is inherently discontinuous)\n //the trick is to deform the object procedurally for better continuiity,without being too noticable;\n //is lazy,because we avoid lipschitz-discontinuity by shaping the helix 2d hyperslice into a bowtie-shape.\n //the more turns the spiral gets,the thicker it gets\n //we interpolate between 2 cases of(minimum and maximum twitst)\n //and scale that a bit for better continuity between the(sloppy linear)interpolation\n ;float scale2=min(1.,length(q.xy))//ideal for few twists\n ;float scale=min(1./twists,length(q.xy)/twists)//ideal for many twists\n ;scale=min(scale,scale2)*.75//scaling the lerp *.8 is barel noticable,but definitely Lippschitz>1. for scaling *.8\n //i assert zthe limit to be *.75 or *.5,hard to measure tiny epsilon.\n //;float scale=min(1.,length(q.xy))//wrognly asserts lipschitz continuity of a twist-deform\n ;float thick=.5;//set thickness of helix(percentage of being solid(near the cylinder border))\n //;thick=min(rmEps,m.y)//work safe.\n //;if(m.y>.5)thick=0.;else \n #ifdef ThickModeMouse\n  ;thick=m.y\n #endif\n #ifdef ThickModeReciprocalEps\n  ;thick=-rmEps*(1.+1./2096.)/m.y//optional,surprisingly superior result for negative thicknesses,but bad for m.y==0.\n #endif\n //;thick=atan(q.z*.15)*1.1//cute,thickness decreases over cylinder height!\n //;if(U.y<iResolution.y*.5)thick=atan(q.z*.15)*1.1//simple variant of below\n ;thick=mix(thick,atan(q.z*.15)*1.1,smoothstep(0.,9.,U.y-iResolution.y*.5))//smooth transition over screenspace, nicer than below\n //;thick=mix(thick,atan(q.z*.15)*1.1,U.y*2./iResolution.y)//this is fine, just weirdly unfamilliar to do in screenspace\n ;t=max(t,abs(sin(atan(q.y,q.x)-q.z*twists)*scale)-thick/twists)//union with helix \n #ifdef doHoles\n  //;if(U.y<iResolution.y*.5){\n  //;t=max(t,.5-length(vec2(l-1.5,(mod(6.*a,6.28)-3.14)/4.)))//inner crown of holes\n  ;t=max(t,.5-length(vec2(l-3. ,(mod(12.*a,6.28)-3.14)/4.)))//outer crown of holes\n  ;float r=max(abs(q.z)-6.,length(vec2(l-2.,(mod(6.*a,6.28)-3.14)/4.))-thick)//inner crown of rods(also shic\n  ;t=min(r,t)\n  //;}\n #endif\n ;return t;}\n\nvoid mainImage(out vec4 O,vec2 U\n){\n ;O=vec4(0,0,0,1)\n ;float t=iTime;mat2 R=rt(t);vec3 q=vec3(iResolution.xy,1),p=32./q//cam ray origin,moves camera away from center\n ;vec3 D=vec3(.3*(U+U-q.xy)/q.y,-1)//cam ray direction\n ;O-=O//tiny [set to 0]\n ;vec2 m=iMouse.xy/iResolution.xy //;m.x=1.-m.x//m deform for better preview(and UI)\n ;U.x=1.-U.x;m.x=1.-m.x//flipped for a better demo\n ;vec2 n=m\n ;n.y=n.y*2.-1.\n ;n.y*=4.25\n ;n.x-=.1//offset to show bad negative x space\n //this raymarching loop directly modifies O as a whole,thus it represents [NumberOfSteps],easily scaled into visible range\n //it has zFar and <epsilon orbitals in the loop header!\n //note that this keeps rotating a modified position for each iteration,which is bad pperformance,done for smaller code\n ;for(O++;rmOrbit(O.x,t);O-=rmIter//raymarching directly modifies the output,also does the increment first,then orbit_escape,then decrement.\n){\n  ;q=p//set q to camera position\n  ;q.xz*=rt(iTime)\n  ;q.yz*=rt(iTime*1.61)//2*2d rotation of camera position\n  //note,a rotation inside the rm loop is bad performance,it is done for smaller code,so you do not need to do the camera_dotproducts)\n  ;t=df(q,n,U)//get distance to surface\n  ;p+=t*D;}\n ;O=1.-O;\n ;O=pow(O,(vec4(m.y*.1+.5)))//optional gamma for better visibility,pow set to m\n //;O=1.-O;\n ;U/=iResolution.xy\n ;U.x+=.9//offset to show bad negative x space //unflipped would be U.x-=.1\n ;U.y-=.5\n \n ;U.x*=iResolution.x/iResolution.y\n ;O.x=mix(O.x,1.,step(length(U),.01))\n ;O.w=1.;}\n\n\n\n//---above is ollj-fied,below is original source\n\n//https://www.shadertoy.com/view/XsdBW8\n// variant of https://www.shadertoy.com/view/4dtfWr\n/*\nvoid mainImage(out vec4 O,vec2 U){\n float t=iTime;\n mat2  R=mat2(sin(t+vec4(0,33,11,0)));\n vec3  q=vec3(iResolution.xy,1),\n    D=vec3(.3*(U+U-q.xy)/q.y,-1),// ray direction\n    p=30./q;    // marching point along ray \n O-=O;\n for(O++;O.x>0.&&t>.01 ;O-=.015)\n  q=p,\n  q.xz*=R,q.yz*=R,   // rotation\n  t=max(abs(q.z)-6.,length(q.xy)-4.),// cylinder\n  float lipschitzScale=min(1.,length(q.xy));\n  t=max(t,abs(sin(atan(q.y,q.x)-q.z)*lipschitzScale)-iMouse.y/iResolution.y),//union with helix\n  p+=t*D;       // step forward=dist to obj\n}*/\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/lttyR7.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1991, 2119, 2136, 2136, 2173], [2214, 2542, 2572, 2622, 2819], [2820, 2897, 2956, 2956, 5430], [5432, 5432, 5467, 5467, 6935]], "test": "untested"}
{"id": "MdKBD3", "name": "columns 3: smooth + profile", "author": "FabriceNeyret2", "description": "smooth-squared blocky columns of varying radius.", "tags": ["raymarching", "sdf", "short"], "likes": 4, "viewed": 317, "published": "Public API", "date": "1530869070", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// variant of https://shadertoy.com/view/4sKfD3\n// smooth op from http://iquilezles.org/www/articles/smin/smin.htm\n\n#define K 4.\n#define exp(x) exp(min(30.,x))\n#define smin(a,b) -log( exp( -K*(a) ) + exp( -K*(b) ) ) / K\n#define smax(a,b) -(smin(-(a),-(b))) \n\nvoid mainImage(out vec4 O, vec2 U) {\n    \n    float t = iTime, z, r, h=6.;                 // r: radius h: height/2.\n    mat2  R = mat2( sin(t+vec4(0,33,11,0)) );\n    vec3  q = iResolution,\n          D = normalize(vec3(.3*(U+U-q.xy)/q.y, -1)),// ray direction\n          p = 30./q, a;                          // marching point along ray\n\n    O-=O;\n    for ( O++; O.x > 0. && t > .01 ; O-=.015 ) {\n        q = p,\n        q.xz *= R, q.yz *= R,                    // rotation\n        q.x = mod(q.x+3.,6.)-3.,                 // repeat in x\n        z = q.z; \n        r = 1. - ( q.y > 0. ? z : sin(3.*z) ) / 15.; // radius\n        q.y = abs(q.y)-5.;                       // 2 rows\n        q.z = mod(q.z,3.) - 1.5,                 // vertical blocks\n            \n        a = abs(q), \n        t = smax(a.x,a.y) -r,             // smooth square column radius decreasing with z\n        t = smax(t,a.z-1.5);                     // sblocks top\n        t = max(t,abs(z) -h),                    // inter range of Z\n\n        p += t*D;                                // step forward = dist to obj\n    }\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MdKBD3.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 259, 295, 295, 1349]], "test": "untested"}
{"id": "MdKBWt", "name": "Cubic Bezier - 3D BBox", "author": "iq", "description": "Analytical computation of the exact bounding box for an 3D Cubic Bezier curve.  See  [url]http://iquilezles.org/www/articles/bezierbbox/bezierbbox.htm[/url] for the derivation.", "tags": ["3d", "bezier", "boundingbox", "bbox"], "likes": 33, "viewed": 3301, "published": "Public API", "date": "1531111887", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// The MIT License\n// Copyright © 2017 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n\n\n// Analytical computation of the exact bounding box for a cubic bezier segment\n//\n// See http://iquilezles.org/www/articles/bezierbbox/bezierbbox.htm\n\n\n// Other bounding box functions:\n//\n// Disk             - 3D BBox : https://www.shadertoy.com/view/ll3Xzf\n// Cylinder         - 3D BBox : https://www.shadertoy.com/view/MtcXRf\n// Ellipse          - 3D BBox : https://www.shadertoy.com/view/Xtjczw\n// Cone boundong    - 3D BBox : https://www.shadertoy.com/view/WdjSRK\n// Cubic     Bezier - 2D BBox : https://www.shadertoy.com/view/XdVBWd \n// Cubic     Bezier - 3D BBox : https://www.shadertoy.com/view/MdKBWt\n// Quadratic Bezier - 2D BBox : https://www.shadertoy.com/view/lsyfWc\n// Quadratic Bezier - 3D BBox : https://www.shadertoy.com/view/tsBfRD\n\n\n#define AA 3\n\nstruct bound3\n{\n    vec3 mMin;\n    vec3 mMax;\n};\n\n//---------------------------------------------------------------------------------------\n// bounding box for a bezier (http://iquilezles.org/www/articles/bezierbbox/bezierbbox.htm)\n//---------------------------------------------------------------------------------------\nbound3 BezierAABB( in vec3 p0, in vec3 p1, in vec3 p2, in vec3 p3 )\n{\n    // extremes\n    vec3 mi = min(p0,p3);\n    vec3 ma = max(p0,p3);\n\n    // note pascal triangle coefficnets\n    vec3 c = -1.0*p0 + 1.0*p1;\n    vec3 b =  1.0*p0 - 2.0*p1 + 1.0*p2;\n    vec3 a = -1.0*p0 + 3.0*p1 - 3.0*p2 + 1.0*p3;\n\n    vec3 h = b*b - a*c;\n\n    // real solutions\n    if( any(greaterThan(h,vec3(0.0))))\n    {\n        vec3 g = sqrt(abs(h));\n        vec3 t1 = clamp((-b - g)/a,0.0,1.0); vec3 s1 = 1.0-t1;\n        vec3 t2 = clamp((-b + g)/a,0.0,1.0); vec3 s2 = 1.0-t2;\n        vec3 q1 = s1*s1*s1*p0 + 3.0*s1*s1*t1*p1 + 3.0*s1*t1*t1*p2 + t1*t1*t1*p3;\n        vec3 q2 = s2*s2*s2*p0 + 3.0*s2*s2*t2*p1 + 3.0*s2*t2*t2*p2 + t2*t2*t2*p3;\n\n        if( h.x > 0.0 )\n        {\n            mi.x = min(mi.x,min(q1.x,q2.x));\n            ma.x = max(ma.x,max(q1.x,q2.x));\n        }\n        if( h.y > 0.0  )\n        {\n            mi.y = min(mi.y,min(q1.y,q2.y));\n            ma.y = max(ma.y,max(q1.y,q2.y));\n        }\n        if( h.z > 0.0  )\n        {\n            mi.z = min(mi.z,min(q1.z,q2.z));\n            ma.z = max(ma.z,max(q1.z,q2.z));\n        }\n    }\n    \n    return bound3( mi, ma );\n}\n\n\n// ray-ellipse intersection\nfloat iEllipse( in vec3 ro, in vec3 rd,         // ray: origin, direction\n             in vec3 c, in vec3 u, in vec3 v )  // disk: center, 1st axis, 2nd axis\n{\n\tvec3 q = ro - c;\n\tvec3 r = vec3(\n        dot( cross(u,v), q ),\n\t\tdot( cross(q,u), rd ),\n\t\tdot( cross(v,q), rd ) ) / \n        dot( cross(v,u), rd );\n    \n    return (dot(r.yz,r.yz)<1.0) ? r.x : -1.0;\n}\n\n\n// ray-box intersection (simplified)\nvec2 iBox( in vec3 ro, in vec3 rd, in vec3 cen, in vec3 rad ) \n{\n\t// ray-box intersection in box space\n    vec3 m = 1.0/rd;\n    vec3 n = m*(ro-cen);\n    vec3 k = abs(m)*rad;\n\t\n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n\n\tfloat tN = max( max( t1.x, t1.y ), t1.z );\n\tfloat tF = min( min( t2.x, t2.y ), t2.z );\n\t\n\tif( tN > tF || tF < 0.0) return vec2(-1.0);\n\n\treturn vec2( tN, tF );\n}\n\nfloat length2( in vec3 v ) { return dot(v,v); }\n\nvec3 iSegment( in vec3 ro, in vec3 rd, in vec3 a, in vec3 b )\n{\n\tvec3 ba = b - a;\n\tvec3 oa = ro - a;\n\t\n\tfloat oad  = dot( oa, rd );\n\tfloat dba  = dot( rd, ba );\n\tfloat baba = dot( ba, ba );\n\tfloat oaba = dot( oa, ba );\n\t\n\tvec2 th = vec2( -oad*baba + dba*oaba, oaba - oad*dba ) / (baba - dba*dba);\n\t\n\tth.x = max(   th.x, 0.0 );\n\tth.y = clamp( th.y, 0.0, 1.0 );\n\t\n\tvec3 p =  a + ba*th.y;\n\tvec3 q = ro + rd*th.x;\n\t\n\treturn vec3( th, length2( p-q ) );\n    \n}\n\n\nfloat iBezier( in vec3 ro, in vec3 rd, in vec3 p0, in vec3 p1, in vec3 p2, in vec3 p3, in float width)\n{\n    const int kNum = 50;\n    \n    float hit = -1.0;\n    float res = 1e10;\n    vec3 a = p0;\n    for( int i=1; i<kNum; i++ )\n    {\n        float t = float(i)/float(kNum-1);\n        float s = 1.0-t;\n        vec3 b = p0*s*s*s + p1*3.0*s*s*t + p2*3.0*s*t*t + p3*t*t*t;\n        vec3 r = iSegment( ro, rd, a, b );\n        if( r.z<width*width )\n        {\n            res = min( res, r.x );\n            hit = 1.0;\n        }\n        a = b;\n    }\n    \n    return res*hit;\n    \n    \n}\n\nfloat hash1( in vec2 p )\n{\n    return fract(sin(dot(p, vec2(12.9898, 78.233)))*43758.5453);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 tot = vec3(0.0);\n    \n#if AA>1\n    for( int m=0; m<AA; m++ )\n    for( int n=0; n<AA; n++ )\n    {\n        // pixel coordinates\n        vec2 o = vec2(float(m),float(n)) / float(AA) - 0.5;\n        vec2 p = (-iResolution.xy + 2.0*(fragCoord+o))/iResolution.y;\n#else    \n        vec2 p = (-iResolution.xy + 2.0*fragCoord)/iResolution.y;\n#endif\n\n    // camera position\n\tvec3 ro = vec3( -0.5, 0.4, 1.5 );\n    vec3 ta = vec3( 0.0, 0.0, 0.0 );\n    // camera matrix\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(0.0,1.0,0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n\t// create view ray\n\tvec3 rd = normalize( p.x*uu + p.y*vv + 1.5*ww );\n\n    // bezier animation\n    float time = iTime*0.5;\n    vec3 p0 = vec3(0.8,0.6,0.8)*sin( time*0.7 + vec3(3.0,1.0,2.0) );\n    vec3 p1 = vec3(0.8,0.6,0.8)*sin( time*1.1 + vec3(0.0,6.0,1.0) );\n    vec3 p2 = vec3(0.8,0.6,0.8)*sin( time*1.3 + vec3(4.0,2.0,3.0) );\n    vec3 p3 = vec3(0.8,0.6,0.8)*sin( time*1.5 + vec3(1.0,5.0,4.0) );\n\tfloat thickness = 0.01;\n        \n    // render\n   \tvec3 col = vec3(0.4)*(1.0-0.3*length(p));\n\n    // raytrace bezier\n    float t = iBezier( ro, rd, p0, p1, p2, p3, thickness);\n\tfloat tmin = 1e10;\n    if( t>0.0 )\n\t{\n    \ttmin = t;\n\t\tcol = vec3(1.0,0.75,0.3);\n\t}\n\n    // compute bounding box for bezier\n    bound3 bbox = BezierAABB( p0, p1, p2, p3 );\n    bbox.mMin -= thickness;\n    bbox.mMax += thickness;\n\n    \n    // raytrace bounding box\n    vec3 bcen = 0.5*(bbox.mMin+bbox.mMax);\n    vec3 brad = 0.5*(bbox.mMax-bbox.mMin);\n\tvec2 tbox = iBox( ro, rd, bcen, brad );\n\tif( tbox.x>0.0 )\n\t{\n        // back face\n        if( tbox.y < tmin )\n        {\n            vec3 pos = ro + rd*tbox.y;\n            vec3 e = smoothstep( brad-0.03, brad-0.02, abs(pos-bcen) );\n            float al = 1.0 - (1.0-e.x*e.y)*(1.0-e.y*e.z)*(1.0-e.z*e.x);\n            col = mix( col, vec3(0.0), 0.25 + 0.75*al );\n        }\n        // front face\n        if( tbox.x < tmin )\n        {\n            vec3 pos = ro + rd*tbox.x;\n            vec3 e = smoothstep( brad-0.03, brad-0.02, abs(pos-bcen) );\n            float al = 1.0 - (1.0-e.x*e.y)*(1.0-e.y*e.z)*(1.0-e.z*e.x);\n            col = mix( col, vec3(0.0), 0.15 + 0.85*al );\n        }\n\t}\n\t\n        tot += col;\n#if AA>1\n    }\n    tot /= float(AA*AA);\n#endif\n\n    // dithering\n    tot += ((hash1(fragCoord.xy)+hash1(fragCoord.yx+13.1))/2.0-0.5)/256.0;\n\n\tfragColor = vec4( tot, 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MdKBWt.jpg", "access": "shaders20k", "license": "mit", "functions": [[1895, 2167, 2236, 2252, 3324], [3327, 3355, 3514, 3514, 3716], [3719, 3756, 3820, 3858, 4138], [4140, 4140, 4168, 4168, 4187], [4189, 4189, 4252, 4252, 4643], [4646, 4646, 4750, 4750, 5223], [5225, 5225, 5251, 5251, 5318], [5320, 5320, 5377, 5377, 7781]], "test": "untested"}
{"id": "MdKfDc", "name": "PICO-8 Palette", "author": "1j01", "description": "Click and drag to \"dither\" - just neighboring colors *in the palette*, not in color space, and just by applying sine waves.", "tags": ["colors", "color", "palette", "pico8", "pico8"], "likes": 2, "viewed": 420, "published": "Public API", "date": "1530905389", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const vec4[] pico8Palette = vec4[] (\n    vec4(0.00, 0.00, 0.00, 1.00), // #000000 (0,   0,   0  ) black\n    vec4(0.11, 0.17, 0.33, 1.00), // #1D2B53 (29,  43,  83 ) dark-blue\n    vec4(0.49, 0.15, 0.33, 1.00), // #7E2553 (126, 37,  83 ) dark-purple\n    vec4(0.00, 0.53, 0.32, 1.00), // #008751 (0,   135, 81 ) dark-green\n    vec4(0.67, 0.32, 0.21, 1.00), // #AB5236 (171, 82,  54 ) brown\n    vec4(0.37, 0.34, 0.31, 1.00), // #5F574F (95,  87,  79 ) dark-gray\n    vec4(0.76, 0.76, 0.78, 1.00), // #C2C3C7 (194, 195, 199) light-gray\n    vec4(1.00, 0.95, 0.91, 1.00), // #FFF1E8 (255, 241, 232) white\n    vec4(1.00, 0.00, 0.30, 1.00), // #FF004D (255, 0,   77 ) red\n    vec4(1.00, 0.64, 0.00, 1.00), // #FFA300 (255, 163, 0  ) orange\n    vec4(1.00, 0.93, 0.15, 1.00), // #FFEC27 (255, 236, 39 ) yellow\n    vec4(0.00, 0.89, 0.21, 1.00), // #00E436 (0,   228, 54 ) green\n    vec4(0.16, 0.68, 1.00, 1.00), // #29ADFF (41,  173, 255) blue\n    vec4(0.51, 0.46, 0.61, 1.00), // #83769C (131, 118, 156) indigo\n    vec4(1.00, 0.47, 0.66, 1.00), // #FF77A8 (255, 119, 168) pink\n    vec4(1.00, 0.80, 0.67, 1.00)  // #FFCCAA (255, 204, 170) peach\n);\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Mess with the coordinates\n    uv = floor(uv * 5.0) * uv;\n    //uv = sin(uv * 1.0) * uv;\n    \n    int paletteIndex = int(\n        uv.x * 5.0 +\n        sin(uv.y / 15.0 * iTime) * 5.0 * sin(iTime / 5.0) +\n        cos(iTime) * 10.0 + 2.5 +\n        ((sin(iTime + uv.x + uv.y) < 0.0) ? (sin(uv.x + uv.y * 50.0) * 2.0) : 0.0) +\n        ((iMouse.z > 0.0) ? sin(uv.x * 500.0 * iMouse.x + uv.y * 500.0 * iMouse.y) / 2.0 : 0.0)\n    );\n    \n    fragColor = pico8Palette[paletteIndex];\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MdKfDc.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1137, 1137, 1194, 1244, 1767]], "test": "untested"}
{"id": "MdKfWV", "name": "Impossible doughnut", "author": "tdhooper", "description": "Extracting the 'impossible channel' trick from [url=https://www.shadertoy.com/view/ldKBRt]Eternal Commute[/url]", "tags": ["torus", "mobius", "escher"], "likes": 40, "viewed": 942, "published": "Public API", "date": "1530646893", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\nconst float EDGE_THICKNESS = .2;\nconst float WIDTH = 1.;\nconst float RADIUS = 3.;\nconst float CHANNEL_DEPTH_RATIO = 1.;\nconst float BALL_COUNT = 19.;\nconst float BALL_SIZE_RATIO = 1.;\nconst float BALL_SPEED = -5.;\nconst float TWISTS = .5;\nconst float TWIST_SPEED = 1.;\n\n\n// --------------------------------------------------------\n// IQ\n// https://www.shadertoy.com/view/ll2GD3\n// --------------------------------------------------------\n\nvec3 pal( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d ) {\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\nvec3 spectrum(float n) {\n    return pal( n, vec3(0.5,0.5,0.5),vec3(0.5,0.5,0.5),vec3(1.0,1.0,1.0),vec3(0.0,0.33,0.67) );\n}\n\n\n// --------------------------------------------------------\n// Modelling utilities\n// hg_sdf https://www.shadertoy.com/view/Xs3GRB\n// --------------------------------------------------------\n\n#define PI 3.14159265359\n\nvoid pR(inout vec2 p, float a) {\n    p = cos(a)*p + sin(a)*vec2(p.y, -p.x);\n}\n\nfloat vmax(vec2 v) {\n    return max(v.x, v.y);\n}\n\nfloat fBox2(vec2 p, vec2 b) {\n    vec2 d = abs(p) - b;\n    return length(max(d, vec2(0))) + vmax(min(d, vec2(0)));\n}\n\nfloat smax(float a, float b, float r) {\n    vec2 u = max(vec2(r + a,r + b), vec2(0));\n    return min(-r, max (a, b)) + length(u);\n}\n\nvec3 cartToPolar(vec3 p) {\n    float x = p.x; // distance from the plane it lies on\n    float r = length(p.zy); // distance from center\n    float a = atan(p.y, p.z); // angle around center\n    return vec3(x, r, a);\n}\n\nvec3 polarToCart(vec3 p) {\n    return vec3(\n        p.x,\n        sin(p.z) * p.y,\n        cos(p.z) * p.y\n    );\n}\n\n\n// --------------------------------------------------------\n// Model\n// --------------------------------------------------------\n\nstruct Model {\n    float dist;\n    vec3 material;\n    vec2 uv;\n    float underStep;\n    int id;\n};\n\n// Imagine a plane with a channel cut in each side, if the plane were\n// thin, the channels would cut through to the other side, forming\n// a hole:\n// ___     ___\n// ___|   |___\n//\n// If the plane were thick, the channels would have depth, and\n// if it were thick enough, they'd never intersect:\n// ___     ___\n//    \\___/\n//     ___\n// ___/   \\___\n//\n// We want to create a thin plane, but with channels that have depth,\n// don't intersect, and don't create a hole. I've achieved this by\n// only cutting the channel when we get close to where it would be.\n\n// The threshold is the surface covering the channel:\n// ___ ___ ___\n//    \\___/\n//\n// This gets set to true when the ray passes through that surface,\n// into the channel\nbool pastThreshold = false;\n\n// This is the side of the plane we were on when we crossed\n// the threshold\nfloat thresholdSide = 0.;\n\nfloat lastZ = 0.; // Last torus 'z' position or the ray\nbool AO_PASS = false;\nfloat time;\n\nModel fModel(vec3 p) {\n\n    vec3 pp = p;\n    float twist = time * TWIST_SPEED;\n\n    // Transform space into a torus knot\n    p = cartToPolar(p);\n    p.y -= RADIUS;\n    p.z /= PI * 2.;\n    pR(p.xy, (TWISTS * p.z + twist) * PI * 2.);\n\n    // When the ray shoots past the 'join' in the torus,\n    // flip the side so it matches up\n    if (length(lastZ - p.z) > .5) {\n        thresholdSide *= -1.;\n    }\n    lastZ = p.z;\n\n    float round = EDGE_THICKNESS;\n\n    // The base plane that we carve into\n    float d = fBox2(\n        p.xy,\n        vec2(WIDTH, EDGE_THICKNESS - round)\n    ) - round;\n\n    float channelWidth = WIDTH - EDGE_THICKNESS / 2.;\n    float channelDepth = channelWidth * CHANNEL_DEPTH_RATIO;\n    float channelOffset = channelWidth - channelDepth;\n\n    // Surface covering the channel, when the ray passes into this,\n    // we know we're inside the channel\n    float threshold = fBox2(\n        p.xy,\n        vec2(channelWidth + round, EDGE_THICKNESS + .002)\n    );\n\n    // When the ray passes into the channel for the first time,\n    // record which side of the plane we were on.\n    // Always assume we're past the threshold when calculating ambient\n    // occlusion, as the channel never actually gets cut when\n    // we're not inside it.\n    if ((AO_PASS || threshold <= 0.) && ! pastThreshold) {\n        pastThreshold = true;\n        thresholdSide = sign(p.y);\n    }\n\n    float side = mix(sign(p.y), thresholdSide, abs(thresholdSide));\n\n    // Cut the channel when we're past the threshold. This actually\n    // constructs entirely new geometry, so we don't cut through to\n    // the other side.\n    if (pastThreshold) {\n        float cut = length(\n            p.xy - vec2(0, channelOffset) * side\n        ) - channelWidth;\n        d = fBox2(\n            p.xy + vec2(0, thresholdSide * (channelDepth * 2. - EDGE_THICKNESS)),\n            vec2(WIDTH, channelDepth * 2. - round)\n        ) - round;\n        d = smax(-cut, d, round);\n    }\n\n    // Rough uv mapping, used to correct the ambient occlusion\n    vec2 uv = side * p.xy / (channelDepth * 2.) + vec2(0, .5);\n    \n    // A Möbius strip has a surface length of 2x it's diamater,\n    // so increment our position when corssing over to the other\n    // side of the plane\n    if (side > 0.) {\n        p.z += 1.;\n    }\n    p.z /= 2.;\n\n    float repeat = BALL_COUNT;\n\n    float ballOffset = (time / repeat) * BALL_SPEED;\n    p.z += ballOffset;\n\n    // Divide the strip up into cells\n    float cell = floor((p.z + .5 / repeat) * repeat);\n\n    // Ball position\n    vec3 bp = vec3(0);\n    bp.y = -channelOffset;\n    bp.z = 2. * (cell / repeat - ballOffset);\n\n    vec3 col = spectrum(bp.z / 2.);\n\n    // Transform ball's torus position into cartesian space\n    pR(bp.xy, -(TWISTS * p.z + twist) * PI * 2.);\n    bp.y += RADIUS;\n    bp.z *= PI * 2.;\n    bp = polarToCart(bp);\n\n    // Add the ball sdf, and colour it\n    p = pp;\n    float ballSize = channelWidth * BALL_SIZE_RATIO;\n    float balls = length(p - bp) - ballSize;\n    col = d < balls ? vec3(1) : col;\n    d = min(d, balls);\n    \n    Model model = Model(d, col, uv, 0., 10);\n    return model;\n}\n\nfloat focalLength;\n\nModel map(vec3 p) {\n    float scale = focalLength;\n    p *= scale;\n    pR(p.yz, 1.25);\n    Model model = fModel(p);\n    model.dist /= scale;\n    return model;\n}\n\n\n// --------------------------------------------------------\n// Rendering\n// --------------------------------------------------------\n\nstruct Hit {\n    Model model;\n    vec3 pos;\n    bool isBackground;\n    vec3 normal;\n    vec3 rayOrigin;\n    float rayLength;\n    vec3 rayDirection;\n};\n\nfloat calcAO( in vec3 pos, in vec3 nor )\n{\n    float occ = 0.0;\n    float sca = 1.0;\n    for( int i=0; i<5; i++ )\n    {\n        float hr = 0.01 + 0.12*float(i)/4.0;\n        vec3 aopos =  nor * hr + pos;\n        float dd = map( aopos ).dist;\n        occ += -(dd-hr)*sca;\n        sca *= 0.95;\n    }\n    return clamp( 1.0 - 3.0*occ, 0.0, 1.0 );\n}\n\nvec3 render(Hit hit, vec3 col) {\n    AO_PASS = true;\n    if ( ! hit.isBackground) {\n        // The simple ambient occlusion method results in hot spots\n    \t// at the base and sides of the balls. This is a result of\n        // the limited samples we do across the normal. In reality\n        // there would be a more evenly distributed darkness along\n        // the base of the channell; so here it's faked with the uv\n        // coordinates and blended in.\n        float ao = calcAO(hit.pos, hit.normal);\n        float fakeAo = min(hit.model.uv.y * 3., 1.);\n        ao = mix(ao, fakeAo, .7);\n        float light = dot(normalize(vec3(1,1,0)), hit.normal) * .5 + .5;\n       \tfloat diff = light * ao;\n        vec3 diffuse = mix(vec3(.5,.5,.6) * .7, vec3(1), diff);\n        col = hit.model.material * diffuse;\n    }\n    return col;\n}\n\n\n// --------------------------------------------------------\n// Ray Marching\n// Adapted from: https://www.shadertoy.com/view/Xl2XWt\n// --------------------------------------------------------\n\nconst float MAX_TRACE_DISTANCE = 10.;\nconst float INTERSECTION_PRECISION = .0001;\nconst int NUM_OF_TRACE_STEPS = 1500;\n\nconst int NORMAL_STEPS = 6;\nvec3 calcNormal(vec3 pos){\n    vec3 eps = vec3(.0001,0,0);\n    vec3 nor = vec3(0);\n    float invert = 1.;\n    for (int i = 0; i < NORMAL_STEPS; i++){\n        nor += map(pos + eps * invert).dist * eps * invert;\n        eps = eps.zxy;\n        invert *= -1.;\n    }\n    return normalize(nor);\n}\n\nHit raymarch(vec3 rayOrigin, vec3 rayDirection){\n\n    float currentDist = INTERSECTION_PRECISION * 2.0;\n    float rayLength = 0.;\n    Model model;\n\n    for(int i = 0; i < NUM_OF_TRACE_STEPS; i++){\n        if (currentDist < INTERSECTION_PRECISION || rayLength > MAX_TRACE_DISTANCE) {\n            break;\n        }\n        model = map(rayOrigin + rayDirection * rayLength);\n        currentDist = model.dist;\n        rayLength += currentDist * (1. - .5);\n    }\n\n    bool isBackground = false;\n    vec3 pos = vec3(0);\n    vec3 normal = vec3(0);\n\n    if (rayLength > MAX_TRACE_DISTANCE) {\n        isBackground = true;\n    } else {\n        pos = rayOrigin + rayDirection * rayLength;\n        normal = calcNormal(pos);\n    }\n\n    return Hit(\n        model,\n        pos,\n        isBackground,\n        normal,\n        rayOrigin,\n        rayLength,\n        rayDirection\n    );\n}\n\nmat3 calcLookAtMatrix(vec3 ro, vec3 ta, vec3 up) {\n    vec3 ww = normalize(ta - ro);\n    vec3 uu = normalize(cross(ww,up));\n    vec3 vv = normalize(cross(uu,ww));\n    return mat3(uu, vv, ww);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n\n    time = iTime;\n    time *= .333;\n    time = mod(time, 1.);\n\n    vec2 p = (-iResolution.xy + 2.0*fragCoord.xy)/iResolution.y;\n\n    vec3 camPos = vec3(2.5,0,3.5);\n    vec3 camTar = vec3(-.5,0,0);\n    vec3 camUp = vec3(1,0,0);\n    mat3 camMat = calcLookAtMatrix(camPos, camTar, camUp);\n    focalLength = 2.;\n    vec3 rayDirection = normalize(camMat * vec3(p, focalLength));\n\n    vec3 bg = vec3(.7,.8,.9) * 1.1;\n\n    Hit hit = raymarch(camPos, rayDirection);\n    vec3 color = render(hit, bg);\n\n    color = pow(color, vec3(1. / 2.2)); // Gamma\n\n    fragColor = vec4(color,1);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MdKfWV.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[272, 440, 508, 508, 551], [553, 553, 577, 577, 675], [678, 896, 928, 928, 973], [975, 975, 995, 995, 1023], [1025, 1025, 1054, 1054, 1141], [1143, 1143, 1182, 1182, 1274], [1276, 1276, 1302, 1302, 1492], [1494, 1494, 1520, 1520, 1606], [2719, 2792, 2814, 2814, 5904], [5926, 5926, 5945, 5945, 6086], [6089, 6375, 6417, 6417, 6718], [6720, 6720, 6752, 6752, 7549], [7552, 7892, 7918, 7918, 8182], [8184, 8184, 8232, 8232, 9051], [9053, 9053, 9103, 9103, 9246], [9248, 9248, 9303, 9303, 9880]], "test": "untested"}
{"id": "MdtfDB", "name": "Deoxyribonucleic Acid", "author": "CLPB", "description": "Hello world! DNA helix inspired by the one depicted in the Metal Gear Solid 2 intro sequence.", "tags": ["3d", "raymarching", "dna"], "likes": 5, "viewed": 470, "published": "Public API", "date": "1530885325", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// From https://www.youtube.com/watch?v=yxNnRSefK94 with some modifications\n// with parts from http://jamie-wong.com/2016/07/15/ray-marching-signed-distance-functions/#surface-normals-and-lighting\n\nfloat EPSILON = 0.00001;\n\n// From http://iquilezles.org/www/articles/distfunctions/distfunctions.htm\nfloat sphSDF(vec3 p, float r){\n    return length(p) - r;\n}\n\nfloat sdPlane( vec3 p, vec4 n )\n{\n  // n must be normalized\n  return dot(p,n.xyz) + n.w;\n}\nfloat sdCylinder( vec3 p, vec3 c )\n{\n  return length(p.xz-c.xy)-c.z;\n}\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r )\n{\n    vec3 pa = p - a, ba = b - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h ) - r;\n}\nfloat sdCapCyl(vec3 p, vec2 h )\n{\n  vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat map(vec3 p){\n    float res = 0.0;\n    \n    float c = cos(0.07*p.y);\n    float s = sin(0.07*p.y);\n    \n    float rep = 5.0;\n    \n    vec3 q = vec3(p.x, mod(p.y, rep)-rep*0.5, p.z);\n    q = vec3(q.x * c + q.z *(s), q.y, q.x * (-s) + q.z*c);\n    \n    res += sdCapsule(q, vec3(8.0,-rep*0.4,0.0), vec3(8.0,rep*0.4,0.0), 1.3);\n    res = min(sdCapsule(q, vec3(-8.0,-rep*0.4,0.0), vec3(-8.0,rep*0.4,0.0), 1.3), res);\n    //res = min(sdCylinder(q-vec3(-8.0,0.0,0.0), vec3(1.0,1.1,1.0)), res);\n    \n    res = min(sdCapsule(q, vec3(8.1,0.0,0.0),vec3(-8.1,0.0,0.4),0.6), res);\n    \n    return res;\n}\n\nvec3 gradient(vec3 p){\n    return normalize(vec3(\n        map(vec3(p.x + EPSILON, p.y, p.z)) - map(vec3(p.x - EPSILON, p.y, p.z)),\n        map(vec3(p.x, p.y + EPSILON, p.z)) - map(vec3(p.x, p.y - EPSILON, p.z)),\n        map(vec3(p.x, p.y, p.z  + EPSILON)) - map(vec3(p.x, p.y, p.z - EPSILON))\n        ));\n}\n\nfloat trace(vec3 ro, vec3 rd){\n    float t = 0.0;\n    for (int i=0;i<128;++i){\n        vec3 p = ro + rd * t;\n        float d = map(p);\n        t += d * 0.5;\n    }\n    return t;\n}\n\nvec3 cameraLookAt(vec3 target, vec3 camPos, vec3 up, vec2 uv, float camNear)\n{\n    vec3 axisZ = normalize(target - camPos);\n    vec3 axisX = cross(axisZ, up);\n    vec3 axisY = cross(axisX, axisZ);\n    return normalize(axisX * uv.x + axisY * uv.y + camNear * axisZ); \n}\n\n// adapted from https://www.shadertoy.com/view/lt33z7\nvec3 phongContribForLight(vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye,\n                          vec3 lightPos, vec3 lightIntensity, vec3 N) {\n    vec3 L = normalize(lightPos - p);\n    vec3 V = normalize(eye - p);\n    vec3 R = normalize(reflect(-L, N));\n    \n    float dotLN = dot(L, N);\n    float dotRV = dot(R, V);\n    \n    if (dotLN < 0.0) {\n        // Light not visible from this point on the surface\n        return vec3(0.0, 0.0, 0.0);\n    } \n    \n    if (dotRV < 0.0) {\n        // Light reflection in opposite direction as viewer, apply only diffuse\n        // component\n        return lightIntensity * (k_d * dotLN);\n    }\n    return lightIntensity * (k_d * dotLN + k_s * pow(dotRV, alpha));\n}\n\nvec3 phongIllumination(vec3 k_a, vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye, vec3 N) {\n    const vec3 ambientLight = 0.5 * vec3(1.0, 1.0, 1.0);\n    vec3 color = ambientLight * k_a;\n    \n    vec3 light1Pos = vec3(4.0,\n                          2.0,\n                          4.0);\n    vec3 light1Intensity = vec3(0.4, 0.4, 0.4);\n    \n    color += phongContribForLight(k_d, k_s, alpha, p, eye,\n                                  light1Pos,\n                                  light1Intensity,\n                                 N);\n    \n    vec3 light2Pos = vec3(0.0,6.0,-5.0);\n    vec3 light2Intensity = vec3(0.4, 0.4, 0.4);\n    \n    color += phongContribForLight(k_d, k_s, alpha, p, eye,\n                                  light2Pos,\n                                  light2Intensity,\n                                 N);    \n    return color;\n}\n\n// Adapted from https://www.shadertoy.com/view/Xd2GR3\nfloat hexagon( vec2 p ) \n{\n\tvec2 q = vec2( p.x*2.0*0.5773503, p.y + p.x*0.5773503 );\n\t\n\tvec2 pi = floor(q);\n\tvec2 pf = fract(q);\n\n\tfloat v = mod(pi.x + pi.y, 3.0);\n\n\tfloat ca = step(1.0,v);\n\tfloat cb = step(2.0,v);\n\tvec2  ma = step(pf.xy,pf.yx);\n\t\n    // distance to borders\n\tfloat e = dot( ma, 1.0-pf.yx + ca*(pf.x+pf.y-1.0) + cb*(pf.yx-2.0*pf.xy) );\n\t\n\treturn e;\n}\n\n// Adapted from https://www.shadertoy.com/view/Xd3XDS\nfloat t3(vec3 p, vec3 n)\n{\n    \n    float P = 32.0;\n    mat3 R = mat3(vec3(cos(8.0),sin(8.0),0),vec3(-sin(8.0),cos(8.0),0),vec3(0,0,-1));\n    p *= R/8.0;\n    n *= R;\n \treturn  (smoothstep(hexagon(p.xy*P), 1.0, 0.35)*n.z*n.z\n            +smoothstep(hexagon(p.zy*P), 1.0, 0.35)*n.x*n.x\n            +smoothstep(hexagon(p.xz*P), 1.0, 0.35)*n.y*n.y);\n}\n\nvec3 hexGradient( vec2 uv ){\n    float h = smoothstep(hexagon(uv*32.0), 1.0, 0.25);\n    float w = 24.0;\n    vec3 n = normalize(vec3(dFdx(h) * w, dFdy(h) * w, 1.0));\n    \n    return n*0.5 + 0.5;\n}\n\nvec3 t3norm(vec3 p, vec3 n)\n{\n    \n    float P = 1.0;\n    mat3 R = mat3(vec3(cos(8.0),sin(8.0),0),vec3(-sin(8.0),cos(8.0),0),vec3(0,0,-1));\n    p *= R/8.0;\n    n *= R;\n \treturn  (hexGradient(p.xy)*n.z*n.z\n            +hexGradient(p.zy)*n.x*n.x\n            +hexGradient(p.xz)*n.y*n.y);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    // adjusted to -1, 1 range\n    uv = uv * 2.0 - 1.0;\n    // corrected for aspect ratio\n    uv.x *= iResolution.x / iResolution.y;\n    \n    //origin\n    vec3 ro = vec3(sin(iTime*0.1)*23.0 + 10.0, 0.0, cos(iTime*0.1)*23.0 + 10.0);\n    \n    //direction\n    // vec3 rd = normalize(vec3(uv, -1.0));\n    vec3 rd = cameraLookAt(vec3(14.0,sin(iTime*0.1)*20.0,0.0), ro, normalize( vec3(0.0,1.0,0.0) ), uv, 1.0);\n    \n    float t = trace(ro,rd);\n    \n    float fog = 100.0 / (100.0 + t * t * 0.1);\n    \n    vec3 spos = ro+rd*t;\n    \n    vec3 norm_ws = gradient(spos);\n    \n    // Texture mapping\n    float hexPattern = t3(spos, norm_ws);\n    \n    vec3 nmap = t3norm(spos, norm_ws);\n    \n    norm_ws = normalize(norm_ws + norm_ws*nmap*0.7);\n    \n    vec3 col = phongIllumination(vec3(0.1,0.4,0.5), \n                                 vec3(0.2), \n                                 vec3(2.0 - hexPattern*1.5), \n                                 1.45, \n                                 spos,\n                                 ro,\n                                 norm_ws);\n    col = mix(vec3(0.152, 0.419, 0.439), col, fog);\n\n    col = (t < 3000.0)? col: vec3(0.152, 0.419, 0.439);\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MdtfDB.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[224, 299, 329, 329, 357], [359, 359, 392, 418, 449], [450, 450, 486, 486, 520], [521, 521, 573, 573, 700], [701, 701, 734, 734, 833], [835, 835, 853, 853, 1428], [1430, 1430, 1452, 1452, 1736], [1738, 1738, 1768, 1768, 1916], [1918, 1918, 1996, 1996, 2186], [2188, 2242, 2390, 2390, 2948], [2950, 2950, 3043, 3043, 3796], [3798, 3852, 3878, 3878, 4218], [4220, 4274, 4300, 4300, 4621], [4623, 4623, 4651, 4651, 4818], [4820, 4820, 4849, 4849, 5106], [5108, 5108, 5165, 5215, 6479]], "test": "untested"}
{"id": "MdVBDK", "name": "Time Released", "author": "dr2", "description": "The converse of Magritte's \"Time Transfixed\" painting (mouseable)", "tags": ["time", "clock", "train", "surreal", "magritte"], "likes": 8, "viewed": 480, "published": "Public API", "date": "1530627719", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// \"Time Released\" by dr2 - 2018\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\n// The converse of Magritte's \"Time Transfixed\" painting (mouseable)\n\nfloat PrBoxDf (vec3 p, vec3 b);\nfloat PrRoundBoxDf (vec3 p, vec3 b, float r);\nfloat PrBox2Df (vec2 p, vec2 b);\nfloat PrRoundBox2Df (vec2 p, vec2 b, float r);\nfloat PrCylDf (vec3 p, float r, float h);\nfloat PrCapsDf (vec3 p, float r, float h);\nfloat PrTorusDf (vec3 p, float ri, float rc);\nfloat SmoothBump (float lo, float hi, float w, float x);\nvec2 Rot2D (vec2 q, float a);\nvec3 HsvToRgb (vec3 c);\nvec3 RgbToHsv (vec3 c);\nfloat Noisefv2 (vec2 p);\nfloat Fbm2 (vec2 p);\nvec3 VaryNf (vec3 p, vec3 n, float f);\n\n#define GEARS  1   // set = 0 to reduce work\n#define AA     0   // set = 1 for antialiasing\n\nvec3 carPos[3], qHit, qSmk, vnSmk, ltPos, ltDir, szClkCase;\nfloat dstFar, tCur, todCur, trnSzFac, trkWid, rlWid, rlHt, clkSzFac, ntt[12], gRot[6],\n   aVelFac, axDist, axRad, wlGap, ttWid, hFac1, hFac2, fadeCase;\nint idObj;\nbool visCase;\nconst int idEng = 11, idAxle = 12, idCar = 13, idWheel = 14, idCrod = 15, idFun = 16,\n   idCpl = 17, idLamp = 18, idRail = 19, idSlp = 20, idCase = 30, idGearS = 31, idGearB = 32,\n   idAxH = 33, idAxM = 34, idAxS = 35, idAxF = 36, idAxB = 37, idBar = 38, idRing = 39,\n   idFoot = 40, idBWal = 51, idWFrm = 52, idShlf = 53, idPil = 54, idFlr = 55;\nconst float pi = 3.14159;\n\n#define DMIN(id) if (d < dMin) { dMin = d;  idObj = id; }\n#define DMINQ(id) if (d < dMin) { dMin = d;  idObj = id;  qHit = q; }\n\nfloat TrnEngDf (vec3 p, float dMin)\n{\n  vec3 q;\n  float wRad, d, aw, sx, tw;\n  tw = trkWid + 0.02;\n  wRad = 0.8;\n  q = p;\n  d = min (max (max (PrBoxDf (q - vec3 (0., 0., -1.75), vec3 (1., 1.4, 0.6)),\n     - PrBoxDf (q - vec3 (0., 0., -1.95), vec3 (0.95, 1.3, 0.65))),\n     - PrBox2Df (q.yz - vec2 (0.7, -1.75), vec2 (0.5, 0.4))),\n     max (PrCylDf (q - vec3 (0., -2.4, -1.75), 4., 0.65), - (q.y - 1.35)));\n  d = min (d, max (PrCapsDf (q - vec3 (0., -0.2, 0.5), 1., 2.), - (q.z + 1.2)));\n  d = min (min (min (min (d, PrBoxDf (q - vec3 (0., -0.5, -3.15), vec3 (1., 0.7, 0.3))),\n     PrBoxDf (q - vec3 (0., -1.3, -0.25), vec3 (1., 0.1, 3.2))),\n     PrBoxDf (q - vec3 (0., -1.4, 3.), vec3 (1.1, 0.2, 0.07))),\n     PrCylDf (vec3 (abs (q.x) - 0.6, q.y + 1.4, q.z - 3.1), 0.2, 0.1));\n  DMINQ (idEng);\n  q.yz -= vec2 (-1.4, -3.5);\n  d = PrCylDf (q.xzy, 0.4, 0.03);\n  DMINQ (idCpl);\n  q = p;\n  d = min (PrCylDf ((q - vec3 (0., 1.1, 2.1)).xzy, 0.3, 0.5),\n     PrCylDf ((q - vec3 (0., 1.5, 2.1)).xzy, 0.4, 0.15));\n  d = min (d, PrCapsDf ((q - vec3 (0., 0.8, 0.5)).xzy, 0.3, 0.2));\n  DMINQ (idFun);\n  q = p;  q.yz -= vec2 (-0.2, 3.3);\n  d = PrCylDf (q, 0.2, 0.2);\n  DMINQ (idLamp);\n  q = p;  q.xz = abs (q.xz);  q -= vec3 (tw - 0.12, -1.4, 1.1);\n  d = min (max (min (PrCylDf (q.zyx, wRad, 0.1),\n     PrCylDf (q.zyx - vec3 (0.,0., -0.07), wRad + 0.05, 0.03)),\n     - PrCylDf (q.zyx, wRad - 0.1, 0.12)), PrCylDf (q.zyx, 0.15, 0.10));\n  q = p;  q.x = abs (q.x);  q -= vec3 (tw - 0.17, -1.4, 1.1 * sign (q.z));\n  aw = -1. * tCur / wRad;\n  q.yz = Rot2D (q.yz, aw);\n  q.yz = Rot2D (q.yz, 2. * pi * floor ((atan (q.y, q.z) + pi) * 8. / (2. * pi) + 0.5) / 8.);\n  q.z += 0.5 * wRad;\n  d = min (d, PrCylDf (q, 0.05, 0.5 * wRad));\n  DMINQ (idWheel);\n  q = p;  sx = sign (q.x);  q.x = abs (q.x);  q -= vec3 (tw + 0.08, -1.4, 0.);\n  aw -= 0.5 * pi * sx; \n  q.yz -= 0.3 * vec2 (cos (aw), - sin (aw));\n  d = PrCylDf (q, 0.04, 1.2);\n  q.z = abs (q.z);  q -= vec3 (-0.1, 0., 1.1);\n  d = min (d, PrCylDf (q.zyx, 0.06, 0.15));\n  DMINQ (idCrod);\n  q = p;  q.z = abs (q.z);  q -= vec3 (0., -1.4, 1.1);\n  d = PrCylDf (q.zyx, 0.1, tw - 0.1);\n  DMINQ (idAxle);\n  return dMin;\n}\n\nfloat TrnCarDf (vec3 p, float dMin)\n{\n  vec3 q;\n  float wRad, d, tw;\n  wRad = 0.35;\n  tw = trkWid + 0.02;\n  q = p;\n  d = min (min (PrBoxDf (q, vec3 (1.3, 1.4, 2.8)),\n     max (PrCylDf (q - vec3 (0., -2.35, 0.), 4., 2.8), - (q.y - 1.4))),\n     PrBoxDf (q - vec3 (0., -1.6, 0.), vec3 (0.8, 0.3, 2.)));\n  DMINQ (idCar);\n  q = p;  q.z = abs (q.z);  q -= vec3 (0., -1.4, 2.9);\n  d = PrCylDf (q.xzy, 0.4, 0.03);\n  DMINQ (idCpl);\n  q = p;  q.xz = abs (q.xz);  q -= vec3 (tw - 0.1, -1.85, 1.1);\n  d = min (min (PrCylDf (q.zyx, wRad, 0.1),\n     PrCylDf (q.zyx - vec3 (0.,0., -0.07), wRad + 0.05, 0.03)),\n     PrCylDf (q.zyx, 0.15, 0.10));\n  q.x -= 0.1;\n  d = max (d, - PrCylDf (q.zyx, 0.2, 0.05));\n  DMINQ (idWheel);\n  q = p;  q.z = abs (q.z);  q -= vec3 (0., -1.85, 1.1);\n  d = PrCylDf (q.zyx, 0.1, tw - 0.15);\n  DMINQ (idAxle);\n  return dMin;\n}\n\nfloat TrnTrackDf (vec3 p, float r, float dMin)\n{\n  vec3 q;\n  float d;\n  p.yz -= vec2 (6., 9.5);\n  q = p;  q.y -= -0.4 * rlHt;  q.z = mod (q.z + 1., 2.) - 1.;\n  d = max (PrBoxDf (q.zyx, vec3 (0.2 * trkWid, 0.6 * rlHt, 1.3 * trkWid)), abs (p.z) - 9.5);\n  DMINQ (idSlp);\n  q = p;  q.y -= 0.7 * rlHt;  q.x = abs (q.x) - trkWid;\n  d = max (PrRoundBox2Df (q.yx, vec2 (rlHt, rlWid), 0.8 * rlWid), abs (p.z) - 9.5);\n  DMINQ (idRail);\n  return dMin;\n}\n\nfloat TrainDf (vec3 p)\n{\n  vec3 q;\n  float dMin, r, d;\n  dMin = dstFar / trnSzFac;\n  p /= trnSzFac;\n  r = length (p.xz);\n  dMin = TrnTrackDf (p, r, dMin);\n  q = p - carPos[0].xyz;\n  dMin = TrnEngDf (q, dMin);\n  for (int k = 1; k < 3; k ++) {\n    q = p - carPos[k].xyz;\n    dMin = TrnCarDf (q, dMin);\n  }\n  return trnSzFac * dMin;\n}\n\nfloat TrainRay (vec3 ro, vec3 rd)\n{\n  float dHit, d;\n  dHit = 0.;\n  for (int j = 0; j < 120; j ++) {\n    d = TrainDf (ro + dHit * rd);\n    dHit += d;\n    if (d < 0.0002 || dHit > dstFar) break;\n  }\n  return dHit;\n}\n\nvec3 TrainNf (vec3 p)\n{\n  vec4 v;\n  vec2 e = vec2 (0.0001, -0.0001);\n  v = vec4 (TrainDf (p + e.xxx), TrainDf (p + e.xyy), TrainDf (p + e.yxy), TrainDf (p + e.yyx));\n  return normalize (vec3 (v.x - v.y - v.z - v.w) + 2. * v.yzw);\n}\n\nvec4 TrainCol ()\n{\n  vec4 col4, carCol, carCol2;\n  if (idObj == idEng || idObj == idCar || idObj == idFun) {\n    carCol = vec4 (0.1, 0.1, 0.9, 0.2);\n    carCol2 = vec4 (0.9, 0.9, 0.2, 0.3);\n    if (idObj == idEng) {\n      col4 = (abs (qHit.y + 0.2) < 0.05 || qHit.y > 1.35) ? carCol2 : carCol;\n      if (qHit.y < -1.15) col4 *= 0.5;\n      if (abs (abs (qHit.x) - 0.5) < 0.4 && abs (qHit.y - 1.1) < 0.2) col4.a = -2.;\n      else if (abs (abs (qHit.z - 1.) - 1.5) < 0.1 && qHit.y > -1.1) col4 *= 0.7;\n      if (qHit.z > 3.1 && qHit.y < -1.) col4 = carCol;\n      if (qHit.z < - 2.8 && qHit.y > 0.1) col4 = vec4 (vec3 (0.01), 0.);\n    } else if (idObj == idCar) {\n      col4 = (abs (qHit.y + 0.2) < 0.05 || qHit.y > 1.4) ? carCol2 : carCol;\n      if (qHit.y < -1.15) col4 *= 0.5;\n      if (abs (qHit.y - 0.6) < 0.6 && (abs (qHit.x) < 0.5 || abs (abs (qHit.z) - 1.2) < 1.1))\n         col4.a = -2.;\n    } else if (idObj == idFun) {\n      col4 = (length (qHit.xz - vec2 (0., 2.1)) < 0.3) ? vec4 (vec3 (0.05), 0.) :\n         ((qHit.y > 1.35) ? carCol : carCol2);\n    }\n  } else if (idObj == idRail) col4 = vec4 (0.7, 0.7, 0.75, 0.5);\n  else if (idObj == idSlp) col4 = vec4 (0.5, 0.3, 0.1, 0.);\n  else if (idObj == idAxle) col4 = vec4 (0.4, 0.4, 0.5, 0.3);\n  else if (idObj == idWheel) col4 = vec4 (0.5, 0.5, 0.6, 0.3);\n  else if (idObj == idCrod) col4 = vec4 (0.7, 0.7, 0.1, 0.3);\n  else if (idObj == idLamp) col4 = (mod (0.5 * tCur, 2.) < 1.) ? vec4 (1., 0., 0., -1.) :\n     vec4 (0., 1., 0., -1.);\n  return col4;\n}\n\nfloat SmkBallHit (vec3 ro, vec3 rd)\n{\n  vec3 u;\n  float b, d, w, dMin, rad;\n  dMin = dstFar;\n  const float nsShow = 20.;\n  for (float n = 0.; n < nsShow; n ++) {\n    u = ro - trnSzFac * vec3 (0., 10.7, 18.2 - 18. * (mod (3. * tCur, 1.) + n) / nsShow);\n    rad = trnSzFac * (0.4 - 0.3 * n / nsShow);\n    b = dot (rd, u);\n    w = b * b - dot (u, u) + rad * rad;\n    if (w > 0.) {\n      d = - b - sqrt (w);\n      if (d > 0. && d < dMin) {\n        dMin = d;\n        qSmk = u + d * rd;\n        vnSmk = qSmk / rad;\n      }\n    }\n  }\n  return dMin;\n}\n\nvoid SetTrainConfig ()\n{\n  trkWid = 1.55;\n  rlWid = 0.05;\n  rlHt = 0.125;\n  for (int k = 0; k < 3; k ++)\n     carPos[k] = vec3 (0., 2.7 * rlHt + 8.15, 16. - (float (k) * 6.4 + ((k > 0) ? 0.3 : 0.)));\n}\n\n#if GEARS\n\nfloat GearWlDf (vec3 p, float rtFac, float nth, float aRot, float tWid, float wlThk,\n   float dMin, int idGear)\n{\n  vec3 q, qq;\n  float nspi, rad, d, a, g, r;\n  q = p;\n  nspi = 1./8.;\n  rad = rtFac * nth;\n  r = rad - 1.5 * tWid;\n  d = PrBox2Df (vec2 (length (q.xz) - r, q.y), vec2 (2. * tWid, wlThk));\n  q.zx = Rot2D (q.zx, aRot);\n  g = atan (q.z, - q.x);\n  if (d < dMin) {\n    qq = q;\n    a = 2. * pi / nth;\n    qq.xz = Rot2D (qq.xz, a * floor (g / a + 0.5));\n    d = 0.4 * max (d, - (r + clamp (2. * (abs (qq.z) - tWid) - abs (qq.x),\n       qq.x - tWid, qq.x + tWid)));\n  }\n  d = min (d, PrCylDf (q.xzy, 5.2 * wlThk, 2. * wlThk));\n  a = 2. * pi * nspi;\n  q.xz = Rot2D (q.xz, a * floor (g / a + 0.5));\n  q.x += 0.5 * (rad - tWid);\n  d = min (d, PrBoxDf (q, vec3 (0.5 * rad - 2. * tWid, wlThk, 0.03 * rad)));\n  DMIN (idGear);\n  return dMin;\n}\n\nfloat ClkGearsDf (vec3 p, float dMin)\n{\n  vec3 q;\n  float d, angRot, rtFac, sx, tw, rtFacB, wlThk, f1, f2;\n  int kk;\n  wlThk = 0.16;\n  rtFacB = (7./32.);\n  kk = int (floor (3. - p.y / wlGap));\n  if (kk >= 0 && kk < 6) {\n    sx = -1.;\n    for (int k = 0; k < 6; k ++) {\n      sx = - sx;\n      wlThk *= 0.92;\n      f1 = ntt[2 * k];\n      f2 = ntt[2 * k + 1];\n      angRot = gRot[k];\n      if (k == kk) break;\n    }\n    rtFac = rtFacB;\n    tw = ttWid;\n    if (kk == 1) rtFac *= 0.8;\n    else if (kk == 4) {\n      rtFac *= 0.66667;\n      tw *= 0.65;\n    }\n    q = p;\n    q.y = mod (q.y, wlGap) - 0.5 * wlGap;\n    q.x -= sx * axDist;\n    dMin = GearWlDf (q, rtFac, f1, angRot, ttWid, wlThk, dMin, idGearB);\n    angRot = - (f1 / f2) * angRot + pi / f2;\n    q.x -= -2. * sx * axDist;\n    dMin = GearWlDf (q, rtFac, f2, angRot, tw, wlThk, dMin, idGearS);\n  }\n  return dMin;\n}\n\nfloat ClkGearsRay (vec3 ro, vec3 rd)\n{\n  vec3 p;\n  float dHit, d, srd, rdi;\n  if (rd.y == 0.) rd.y = 0.0001;\n  srd = - sign (rd.y) / (clkSzFac * wlGap);\n  rdi = 1. / abs (rd.y);\n  dHit = PrBoxDf (ro, clkSzFac * vec3 (szClkCase.x, 3. * wlGap, szClkCase.z));\n  for (int j = 0; j < 60; j ++) {\n    p = ro + dHit * rd;\n    d = ClkGearsDf (p / clkSzFac, dstFar / clkSzFac);\n    dHit += clkSzFac * min (d, wlGap * (0.3 + max (0., fract (rdi * fract (srd * p.y)))));\n    if (d < 0.0002 || dHit > dstFar) break;\n  }\n  if (d >= 0.0002) dHit = dstFar;\n  return dHit;\n}\n\nfloat ClkAxlesDf (vec3 p, float dMin)\n{\n  vec3 q;\n  float d;\n  q = p;  q.xy -= vec2 (- axDist, 2. * wlGap);\n  d = PrCylDf (q.xzy, axRad, 0.9 * wlGap);\n  q = p;  q.xy -= vec2 (- axDist, 1.5 * wlGap);\n  d = min (d, PrCylDf (q.xzy, axRad, 0.3 * wlGap));\n  q = p;  q.xy -= vec2 (- axDist, 0.);\n  d = min (d, PrCylDf (q.xzy, axRad, 0.9 * wlGap));\n  q = p;  q.xy -= vec2 (axDist, -0.5 * wlGap);\n  d = min (d, PrCylDf (q.xzy, axRad, 0.4 * wlGap));\n  q = p;  q.xy -= vec2 (axDist, - wlGap);\n  d = min (d, PrCylDf (q.xzy, axRad, 0.9 * wlGap));\n  q = p;  q.xy -= vec2 (axDist, -1.5 * wlGap);\n  d = min (d, PrCylDf (q.xzy, axRad, 0.4 * wlGap));\n  q = p;  q.xy -= vec2 (- axDist, -2. * wlGap);\n  d = min (d, PrCylDf (q.xzy, axRad, 0.9 * wlGap));\n  DMIN (idAxB);  \n  q = p;  q.y = abs (q.y) - 2.75 * wlGap;\n  d = PrBoxDf (q, vec3 (axDist - 1.8 * axRad, 0.3 * axRad, 0.7 * axRad));\n  q.x = abs (q.x) - axDist;\n  d = min (d, PrCylDf (q.xzy, 2. * axRad, 0.3 * axRad));\n  DMIN (idBar);\n  q = p;  q.xy -= vec2 (- axDist, 0.);\n  d = PrCylDf (q.xzy, 0.5 * axRad, 3.05 * wlGap);\n  DMIN (idAxF); \n  return dMin;\n}\n\n#endif\n\nfloat ClkHandsDf (vec3 p, float dMin)\n{\n  vec3 q, pp;\n  float d, angRot;\n  pp = p;\n  p.y -= 2.5 * wlGap;\n  q = p;  q.xy -= vec2 (axDist, 0.25 * wlGap);\n  d = PrCylDf (q.xzy, 1.5 * axRad, 0.7 * wlGap);\n  DMIN (idAxH);\n  p.y += 2. * wlGap;\n  q = p;  q.xy -= vec2 (axDist, 1.5 * wlGap);\n  d = PrCylDf (q.xzy, axRad, 2. * wlGap);\n  DMIN (idAxM);\n  p.y += 3. * wlGap;\n  q = p;  q.xy -= vec2 (axDist, 3.2 * wlGap);\n  d = PrCylDf (q.xzy, 0.5 * axRad, 3.6 * wlGap);\n  DMIN (idAxS); \n  p = pp;\n  p.xy -= vec2 (axDist, 0.5 * wlGap);\n  angRot = - gRot[0];\n  q = p;\n  q.xz = Rot2D (q.xz, angRot - 0.5 * pi);\n  q.xy -= vec2 (-2., 2.85 * wlGap);\n  d = PrCapsDf (q.zyx, 0.5 * ttWid, 2.);\n  DMIN (idAxH);\n  angRot *= hFac1;\n  q = p;\n  q.xz = Rot2D (q.xz, angRot - 0.5 * pi);\n  q.xy -= vec2 (-2.5, 3.25 * wlGap);\n  d = PrCapsDf (q.zyx, 0.5 * ttWid, 2.5);\n  DMIN (idAxM);\n  angRot *= hFac2;\n  q = p;\n  q.xz = Rot2D (q.xz, angRot - 0.5 * pi);\n  q.xy -= vec2 (-2.7, 3.65 * wlGap);\n  d = PrCapsDf (q.zyx, 0.3 * ttWid, 3.2);\n  DMIN (idAxS);\n  return dMin;\n}\n\nfloat ClkCaseDf (vec3 p, float dMin)\n{\n  vec3 q;\n  float d;\n  p.y -= -0.8 + 0.5 * wlGap;\n  q = p;\n  d = PrRoundBoxDf (q, szClkCase - 0.5, 0.5);\n  DMINQ (idCase);\n  q.xy -= vec2 (-8., 4.3);\n  d = PrTorusDf (q.xzy, 0.25, 3.2);\n  q = p;\n  q.xy -= vec2 (axDist, 4.3);\n  d = min (d, PrTorusDf (q.xzy, 0.25, 7.2));\n  DMINQ (idRing);\n  q = p;  q.xy = abs (q.xy) - vec2 (10., 2.4);  q.z -= 8.7;\n  d = PrCylDf (q, 1., 0.5);\n  DMINQ (idFoot);\n  return dMin;\n}\n\nfloat ClockDf (vec3 p)\n{\n  float dMin;\n  dMin = dstFar / clkSzFac;\n  p /= clkSzFac;\n  if (visCase) dMin = ClkCaseDf (p, dMin);\n#if GEARS\n  else dMin = ClkAxlesDf (p, dMin);\n#endif\n  dMin = ClkHandsDf (p, dMin);\n  return clkSzFac * dMin;\n}\n\nfloat ClockRay (vec3 ro, vec3 rd)\n{\n  float dHit, d;\n  dHit = 0.;\n  for (int j = 0; j < 60; j ++) {\n    d = ClockDf (ro + dHit * rd);\n    dHit += d;\n    if (d < 0.0005 || dHit > dstFar) break;\n  }\n  return dHit;\n}\n\nfloat ClockNDf (vec3 p)\n{\n  float dMin;\n  dMin = ClockDf (p);\n#if GEARS\n  if (! visCase) dMin = clkSzFac * ClkGearsDf (p / clkSzFac, dMin / clkSzFac);\n#endif\n  return dMin;\n}\n\nvec3 ClockNf (vec3 p)\n{\n  const vec2 e = vec2 (0.0001, -0.0001);\n  vec4 v = vec4 (ClockNDf (p + e.xxx), ClockNDf (p + e.xyy), ClockNDf (p + e.yxy), ClockNDf (p + e.yyx));\n  return normalize (vec3 (v.x - v.y - v.z - v.w) + 2. * v.yzw);\n}\n\nvec4 ClockCol ()\n{\n  vec4 col4;\n  vec2 s;\n  float a;\n  if (idObj == idCase) {\n    col4 = vec4 (0.7, 0.7, 0.7, 0.1);\n    if (qHit.y > 0.) {\n      s = qHit.xz - vec2 (axDist, 0.);\n      if (length (s) < 7.) {\n        col4 = vec4 (0.8, 0.8, 0.6, 0.5);\n        a = 6. * (atan (s.y, - s.x) / pi + 1.);\n        if (abs (mod (a + 0.5, 1.) - 0.5) < 0.05 &&\n           abs (length (s.xy) - 5.9) < 0.9) col4 *= 0.5;\n      } else if (length (qHit.xz - vec2 (-8., 0.)) < 3.)\n         col4 = vec4 (0.8, 0.75, 0.8, 0.) * (1. - 0.3 * Noisefv2 (32. * qHit.xz));\n    }\n  } else if (idObj == idRing) col4 = vec4 (0.7, 0.7, 0.1, 0.3);\n#if GEARS\n  else if (idObj == idGearB) col4 = vec4 (1., 1., 0.5, 0.3);\n  else if (idObj == idGearS) col4 = vec4 (0.8, 0.8, 0.2, 0.3);\n#endif\n  else if (idObj == idAxB) col4 = vec4 (0.6, 0.6, 0.3, 0.1);\n  else if (idObj == idAxH) col4 = vec4 (1., 0.3, 0.2, 0.1);\n  else if (idObj == idAxM) col4 = vec4 (0.3, 0.2, 1., 0.1);\n  else if (idObj == idAxS) col4 = vec4 (0.3, 1., 0.2, 0.1);\n  else if (idObj == idAxF || idObj == idBar) col4 = vec4 (0.5, 0.5, 0.6, 0.1);\n  else if (idObj == idFoot) col4 = vec4 (0.4, 0.4, 0.4, 0.05);\n  return col4;\n}\n\nvoid SetClockConfig ()\n{\n  float tCyc, tSeq;\n  fadeCase = 1.;\n  aVelFac = 2. * pi / (12. * 3600.);\n#if GEARS\n  tCyc = 30.;\n  tSeq = mod (tCur, tCyc);\n  fadeCase -= 0.8 * SmoothBump (0.25, 0.75, 0.05, tSeq / tCyc);\n  aVelFac *= 1. + 69. * SmoothBump (0.4, 0.6, 0.002, tSeq / tCyc);\n#endif\n  wlGap = 1.4;\n  szClkCase = vec3 (13.5, 4.4, 8.5);\n  axDist = 4.83;\n  axRad = 0.3;\n  ttWid = 0.35;\n  ntt[0] = 36.; ntt[1] = 12.; ntt[2] = 48.;  ntt[3] = 12.;\n  ntt[4] = 32.; ntt[5] = 16.; ntt[6] = 36.;  ntt[7] = 12.;\n  ntt[8] = 60.; ntt[9] = 12.; ntt[10] = 32.; ntt[11] = 16.;\n  hFac1 = (ntt[0] / ntt[1]) * (ntt[2] / ntt[3]);\n  hFac2 = (ntt[4] / ntt[5]) * (ntt[6] / ntt[7]) * (ntt[8] / ntt[9]) *\n     (ntt[10] / ntt[11]);\n  gRot[0] = - todCur * aVelFac;\n  for (int k = 0; k < 5; k ++) gRot[k + 1] = - gRot[k] * ntt[2 * k] / ntt[2 * k + 1];\n}\n\nfloat RoomDf (vec3 p)\n{\n  vec3 q;\n  float dMin, d;\n  dMin = dstFar;\n  q = p;\n  d = q.z;\n  DMINQ (idBWal);\n  q = p;  q.y -= 11.7;\n  d = max (PrRoundBoxDf (q, vec3 (5., 3., 0.1), 0.1), - q.z);\n  DMINQ (idWFrm);\n  q = p;  q.yz -= vec2 (8., 1.5);\n  d = PrBoxDf (q, vec3 (7., 0.12, 1.5));\n  DMINQ (idShlf);\n  q = p;  q.x = abs (q.x);  q -= vec3 (5., 4., 2.);\n  d = PrCylDf (q.xzy, 0.4, 4.);\n  DMINQ (idPil);\n  q = p;\n  d = q.y;\n  DMINQ (idFlr);\n  return dMin;\n}\n\nfloat RoomRay (vec3 ro, vec3 rd)\n{\n  float dHit, d;\n  dHit = 0.;\n  for (int j = 0; j < 60; j ++) {\n    d = RoomDf (ro + dHit * rd);\n    if (d < 0.0005 || dHit > dstFar) break;\n    dHit += d;\n  }\n  return dHit;\n}\n\nvec3 RoomNf (vec3 p)\n{\n  vec4 v;\n  vec2 e = vec2 (0.0001, -0.0001);\n  v = vec4 (RoomDf (p + e.xxx), RoomDf (p + e.xyy), RoomDf (p + e.yxy), RoomDf (p + e.yyx));\n  return normalize (vec3 (v.x - v.y - v.z - v.w) + 2. * v.yzw);\n}\n\nfloat RoomSShadow (vec3 ro, vec3 rd)\n{\n  vec3 p;\n  float sh, d, h;\n  sh = 1.;\n  d = 0.1;\n  for (int j = 0; j < 30; j ++) {\n    p = ro + rd * d;\n    h = min (TrainDf (p), RoomDf (p));\n    sh = min (sh, smoothstep (0., 0.05 * d, h));\n    d += clamp (h, 0.1, 0.5);\n    if (sh < 0.05) break;\n  }\n  return sh;\n}\n\nvec3 BgCol (vec3 ro, vec3 rd)\n{\n  vec2 u;\n  float a;\n  rd.z *= -1.;\n  ro.z *= -1.;\n  a = 0.5 * atan (length (rd.xy), rd.z);\n  rd = normalize (vec3 (rd.xy * tan (a), 1.));\n  u = vec2 (ro.xy + 2. * tCur + rd.xy * (100. - ro.z) /rd.z);\n  return mix (mix (vec3 (0.2, 0.2, 0.6), vec3 (1.), 1.5 * Fbm2 (0.1 * u)),\n     vec3 (0.3, 0.3, 0.6), smoothstep (0.35 * pi, 0.4 * pi, a));\n}\n\nvec4 ShowTrain (vec3 ro, vec3 rd, vec3 col, float dstMin)\n{\n  vec4 col4;\n  vec3 vn;\n  float dstTrain, dstSmk;\n  dstSmk = SmkBallHit (ro, rd);\n  if (dstSmk < dstFar) vnSmk = VaryNf (32. * qSmk, vnSmk, 2.);\n  dstTrain = TrainRay (ro, rd);\n  if (dstTrain < min (dstMin, dstFar)) {\n    ro += rd * dstTrain;\n    vn = TrainNf (ro);\n    col4 = TrainCol ();\n    col = col4.rgb;\n    if (col4.a >= 0.) col = col * (0.3 + 0.7 * max (dot (vn, ltDir), 0.)) +\n        col4.a * pow (max (dot (normalize (ltDir - rd), vn), 0.), 64.);\n    else if (col4.a == -2.) col = mix (col, 0.5 * BgCol (8. * qHit.yxz, vec3 (0., 1., 0.)), 0.5);\n  }\n  if (dstSmk < min (dstTrain, dstMin)) col = mix (col, vec3 (0.8, 0.8, 0.75) *\n     (0.5 + 0.5 * max (dot (vnSmk, ltDir), 0.)), 0.7);\n  return vec4 (col, dstTrain);\n}\n\nvec3 ShowClock (vec3 ro, vec3 rd, vec3 col, float dstMin)\n{\n  vec4 col4;\n  vec3 vn, roo, colC, colNC;\n  float dstClk, d;\n  int idObjC;\n  ro = ro.xzy;  ro.z *= -1.;\n  rd = rd.xzy;  rd.z *= -1.;\n  colC = col;\n  colNC = col;\n  roo = ro;\n  visCase = true;\n  dstClk = ClockRay (ro, rd);\n  if (dstClk < min (dstMin, dstFar)) {\n    ro += rd * dstClk;\n    vn = ClockNf (ro).xzy;  vn.y *= -1.;\n    col4 = ClockCol ();\n    colC = col4.rgb * (0.3 + 0.7 * max (dot (vn, ltDir), 0.)) +\n       col4.a * pow (max (dot (normalize (ltDir - rd), vn), 0.), 32.);\n  }\n#if GEARS\n  ro = roo;\n  visCase = false;\n  dstClk = ClkGearsRay (ro, rd);\n  idObjC = idObj;\n  d = ClockRay (ro, rd);\n  if (d < dstClk) dstClk = d;\n  else idObj = idObjC;\n  if (dstClk < min (dstMin, dstFar)) {\n    ro += rd * dstClk;\n    vn = ClockNf (ro).xzy;  vn.y *= -1.;\n    col4 = ClockCol ();\n    colNC = col4.rgb * (0.3 + 0.7 * max (dot (vn, ltDir), 0.)) +\n       col4.a * pow (max (dot (normalize (ltDir - rd), vn), 0.), 32.);\n  }\n  col = mix (colNC, colC, fadeCase);\n#else\n  col = colC;\n#endif\n  return col;\n}\n\nvec3 ShStagGrid (vec2 p, vec2 g)\n{\n  vec2 q, sq, ss;\n  q = p * g;\n  if (2. * floor (0.5 * floor (q.y)) == floor (q.y)) q.x += 0.5;\n  sq = smoothstep (0.05, 0.1, abs (fract (q + 0.5) - 0.5));\n  q = fract (q) - 0.5;\n  ss = 0.3 * smoothstep (0.3, 0.5, abs (q.xy)) * sign (q.xy);\n  if (abs (q.x) < abs (q.y)) ss.x = 0.;\n  else ss.y = 0.;\n  return vec3 (ss.x, 0.8 + 0.2 * sq.x * sq.y, ss.y);\n}\n\nvec4 ShowRoom (vec3 ro, vec3 rd, vec3 col, float dstMin)\n{\n  vec4 col4;\n  vec3 vn, rg;\n  float dstRoom, a, s;\n  bool fxz;\n  dstRoom = RoomRay (ro, rd);\n  if (dstRoom < min (dstMin, dstFar)) {\n    ro += dstRoom * rd;\n    vn = RoomNf (ro);\n    if (idObj == idBWal) {\n      col4 = vec4 (0.9, 0.7, 0.4, 0.1);\n      rg = ro;\n      fxz = (abs (vn.x) > 0.99);\n      rg = ShStagGrid ((fxz ? rg.zy : rg.xy), vec2 (0.6, 1.2));\n      col4 *= rg.y;\n      rg.xz *= sign (fxz ? vn.x : vn.z);\n      if (fxz) {\n        if (rg.x == 0.) vn.xy = Rot2D (vn.xy, rg.z);\n        else vn.xz = Rot2D (vn.xz, rg.x);\n      } else {\n        if (rg.x == 0.) vn.zy = Rot2D (vn.zy, rg.z);\n        else vn.zx = Rot2D (vn.zx, rg.x);\n      }\n    } else if (idObj == idWFrm) {\n      col4 = (vn.z > 0.99 && abs (qHit.x) < 4.9 && abs (qHit.y) < 2.9) ? \n         vec4 (0.5 * BgCol (4. * qHit, vec3 (0., 1., 0.)), -1.) : vec4 (0.7, 0.7, 0.1, 0.3);\n    } else if (idObj == idPil) {\n      col4 = vec4 (0.9, 0.7, 0.7, 0.2);\n      if (abs (vn.y) < 0.01) {\n        a = (length (qHit.xz) > 0.) ? atan (qHit.z, - qHit.x) / pi : 0.;\n        s = mod (2. * qHit.y + a, 1.);\n        vn.y = 0.3 * (1. - SmoothBump (0.2, 0.8, 0.1, s)) * sign (s - 0.5);\n        vn.xz *= sqrt (1. - vn.y * vn.y);\n      }\n    } else if (idObj == idShlf) {\n      col4 = vec4 (0.5, 0.3, 0.1, 0.1);\n      if (vn.y > 0.99) {\n        col4.rgb = mix (col4.rgb, vec3 (0.7, 0.4, 0.2), Fbm2 (vec2 (2., 16.) * qHit.xz));\n        if (abs (qHit.x - 0.1) < clkSzFac * szClkCase.x &&\n           abs (qHit.z - 0.4) < clkSzFac * szClkCase.y) col4 *= mix (1., 0.7, fadeCase);\n      }\n    } else if (idObj == idFlr) {\n      col4 = mix (vec4 (0.8, 0.4, 0.2, 0.2), vec4 (0.5, 0.25, 0.1, 0.1),\n         Fbm2 (vec2 (8., 1.) * qHit.xz)) *\n         (0.6 + 0.4 * smoothstep (0.03, 0.08, mod (qHit.x + 0.5, 1.)));\n      col4 *= 0.7 + 0.3 * smoothstep (0.4, 0.6, length (vec2 (abs (qHit.x), qHit.z) - vec2 (5., 2.)));\n    }\n    col = col4.rgb;\n    if (col4.a >= 0.) col = col * (0.2 + 0.8 * max (dot (vn, ltDir), 0.)) +\n       col4.a * pow (max (dot (normalize (ltDir - rd), vn), 0.), 32.);\n    if (idObj == idBWal || idObj == idFlr) col *= 1. - smoothstep (0.08, 0.2,\n       acos (dot (normalize (ltPos - ro), ltDir)) / pi);\n  }\n  return vec4 (col, dstRoom);\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  vec4 col4;\n  float dMin, sh;\n  dMin = dstFar;\n  col4 = vec4 (vec3 (0.), dMin);\n  dMin = min (dMin, col4.a);\n  col4 = ShowRoom (ro, rd, col4.rgb, dMin);\n  if (col4.a < dMin) {\n    dMin = col4.a;\n    if (idObj == idFlr || idObj == idBWal) col4.rgb *= 0.7 + 0.4 * RoomSShadow (ro + dMin * rd, ltDir);\n  }\n  col4 = ShowTrain (ro, rd, col4.rgb, dMin);\n  dMin = min (dMin, col4.a);\n  ro.yz -= vec2 (9.9, 2.);\n  col4.rgb = ShowClock (ro, rd, col4.rgb, dMin);\n  return clamp (col4.rgb, 0., 1.);\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  vec4 mPtr;\n  vec3 ro, rd, col;\n  vec2 canvas, uv;\n  float el, az, zmFac, t, ltEl, ltAz;\n  canvas = iResolution.xy;\n  uv = 2. * fragCoord.xy / canvas - 1.;\n  uv.x *= canvas.x / canvas.y;\n  tCur = iTime;\n  todCur = iDate.w;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / canvas - 0.5;\n  dstFar = 100.;\n  az = pi;\n  el = 0.03 * pi;\n  if (mPtr.z > 0.) {\n    az -= 0.6 * pi * mPtr.x;\n    el -= 0.2 * pi * mPtr.y;\n  } else {\n    t = 16. * (mod (0.02 * tCur, 2.) - 0.5);\n    t = (floor (t) + smoothstep (0.9, 1., mod (t, 1.))) / 16.;\n    az += 0.4 * pi * min (1. - t, t);\n  }\n  az = clamp (az, 0.75 * pi, 1.25 * pi);\n  el = clamp (el, -0.01 * pi, 0.1 * pi);\n  clkSzFac = 0.2;\n  trnSzFac = 0.6;\n  SetClockConfig ();\n  SetTrainConfig ();\n  ro = vec3 (0., 0., -50.);\n  ro.yz = Rot2D (ro.yz, el);  ro.xz = Rot2D (ro.xz, az);\n  ro.y += 7.;\n  zmFac = 5.4;\n  ltEl = -0.3 * pi;\n  ltAz = 0.2 * pi;\n  ltDir = vec3 (0., 0., 1.);\n  ltDir.yz = Rot2D (ltDir.yz, ltEl);  ltDir.xz = Rot2D (ltDir.xz, ltAz);\n  ltPos = 50. * ltDir;\n#if ! AA\n  const float naa = 1.;\n#else\n  const float naa = 4.;\n#endif  \n  col = vec3 (0.);\n  for (float a = 0.; a < naa; a ++) {\n    rd = normalize (vec3 (uv + step (1.5, naa) * Rot2D (vec2 (0.71 / canvas.y, 0.),\n       0.5 * pi * (a + 0.5)), zmFac));\n    rd.yz = Rot2D (rd.yz, el);  rd.xz = Rot2D (rd.xz, az);\n    col += (1. / naa) * ShowScene (ro, rd);\n  }\n  col = RgbToHsv (col);\n  col = HsvToRgb (vec3 (col.r, 0.7 * col.g, pow (0.5 * col.b + 0.5 * smoothstep (0., 1., col.b), 0.8)));\n  fragColor = vec4 (col, 1.);\n}\n\nfloat PrBoxDf (vec3 p, vec3 b)\n{\n  vec3 d;\n  d = abs (p) - b;\n  return min (max (d.x, max (d.y, d.z)), 0.) + length (max (d, 0.));\n}\n\nfloat PrRoundBoxDf (vec3 p, vec3 b, float r)\n{\n  return length (max (abs (p) - b, 0.)) - r;\n}\n\nfloat PrBox2Df (vec2 p, vec2 b)\n{\n  vec2 d;\n  d = abs (p) - b;\n  return min (max (d.x, d.y), 0.) + length (max (d, 0.));\n}\n\nfloat PrRoundBox2Df (vec2 p, vec2 b, float r)\n{\n  return length (max (abs (p) - b, 0.)) - r;\n}\n\nfloat PrCylDf (vec3 p, float r, float h)\n{\n  return max (length (p.xy) - r, abs (p.z) - h);\n}\n\nfloat PrCapsDf (vec3 p, float r, float h)\n{\n  return length (p - vec3 (0., 0., clamp (p.z, - h, h))) - r;\n}\n\nfloat PrTorusDf (vec3 p, float ri, float rc)\n{\n  return length (vec2 (length (p.xy) - rc, p.z)) - ri;\n}\n\nfloat SmoothBump (float lo, float hi, float w, float x)\n{\n  return (1. - smoothstep (hi - w, hi + w, x)) * smoothstep (lo - w, lo + w, x);\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  vec2 cs;\n  cs = sin (a + vec2 (0.5 * pi, 0.));\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nvec3 HsvToRgb (vec3 c)\n{\n  return c.z * mix (vec3 (1.), clamp (abs (fract (c.xxx + vec3 (1., 2./3., 1./3.)) * 6. - 3.) - 1., 0., 1.), c.y);\n}\n\nvec3 RgbToHsv (vec3 c)\n{\n  vec4 p, q;\n  float d;\n  const float e = 1.e-10;\n  p = mix (vec4 (c.bg, vec2 (-1., 2./3.)), vec4 (c.gb, vec2 (0., -1./3.)), step (c.b, c.g));\n  q = mix (vec4 (p.xyw, c.r), vec4 (c.r, p.yzx), step (p.x, c.r));\n  d = q.x - min (q.w, q.y);\n  return vec3 (abs (q.z + (q.w - q.y) / (6. * d + e)), d / (q.x + e), q.x);\n}\n\nconst float cHashM = 43758.54;\n\nvec2 Hashv2v2 (vec2 p)\n{\n  vec2 cHashVA2 = vec2 (37., 39.);\n  return fract (sin (vec2 (dot (p, cHashVA2), dot (p + vec2 (1., 0.), cHashVA2))) * cHashM);\n}\n\nfloat Noisefv2 (vec2 p)\n{\n  vec2 t, ip, fp;\n  ip = floor (p);  \n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = mix (Hashv2v2 (ip), Hashv2v2 (ip + vec2 (0., 1.)), fp.y);\n  return mix (t.x, t.y, fp.x);\n}\n\nfloat Fbm2 (vec2 p)\n{\n  float f, a;\n  f = 0.;\n  a = 1.;\n  for (int j = 0; j < 5; j ++) {\n    f += a * Noisefv2 (p);\n    a *= 0.5;\n    p *= 2.;\n  }\n  return f * (1. / 1.9375);\n}\n\nfloat Fbmn (vec3 p, vec3 n)\n{\n  vec3 s;\n  float a;\n  s = vec3 (0.);\n  a = 1.;\n  for (int i = 0; i < 3; i ++) {\n    s += a * vec3 (Noisefv2 (p.yz), Noisefv2 (p.zx), Noisefv2 (p.xy));\n    a *= 0.5;\n    p *= 2.;\n  }\n  return dot (s, abs (n));\n}\n\nvec3 VaryNf (vec3 p, vec3 n, float f)\n{\n  vec3 g;\n  vec3 e = vec3 (0.1, 0., 0.);\n  g = vec3 (Fbmn (p + e.xyy, n), Fbmn (p + e.yxy, n), Fbmn (p + e.yyx, n)) - Fbmn (p, n);\n  return normalize (n + f * (g - n * dot (n, g)));\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MdVBDK.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[121, 1534, 1571, 1571, 3675], [3677, 3677, 3714, 3714, 4514], [4516, 4516, 4564, 4564, 4958], [4960, 4960, 4984, 4984, 5291], [5293, 5293, 5328, 5328, 5507], [5509, 5509, 5532, 5532, 5740], [5742, 5742, 5760, 5760, 7250], [7252, 7252, 7289, 7289, 7795], [7797, 7797, 7821, 7821, 7998], [11385, 11385, 11424, 11424, 12420], [12422, 12422, 12460, 12460, 12871], [12873, 12873, 12897, 12897, 13111], [13113, 13113, 13148, 13148, 13326], [13328, 13328, 13353, 13353, 13502], [13504, 13504, 13527, 13527, 13740], [13742, 13742, 13760, 13760, 14898], [14900, 14900, 14924, 14924, 15730], [15732, 15732, 15755, 15755, 16188], [16190, 16190, 16224, 16224, 16401], [16403, 16403, 16425, 16425, 16629], [16631, 16631, 16669, 16669, 16937], [16939, 16939, 16970, 16970, 17313], [17315, 17315, 17374, 17374, 18101], [18103, 18103, 18162, 18162, 19167], [19169, 19169, 19203, 19203, 19557], [19559, 19559, 19617, 19617, 21822], [21824, 21824, 21859, 21859, 22350], [22352, 22352, 22408, 22408, 23929], [23931, 23931, 23963, 23963, 24063], [24065, 24065, 24111, 24111, 24158], [24160, 24160, 24193, 24193, 24282], [24284, 24284, 24331, 24331, 24378], [24380, 24380, 24422, 24422, 24473], [24475, 24475, 24518, 24518, 24582], [24584, 24584, 24630, 24630, 24687], [24689, 24689, 24746, 24746, 24829], [24831, 24831, 24861, 24861, 24974], [24976, 24976, 25000, 25000, 25117], [25119, 25119, 25143, 25143, 25459], [25493, 25493, 25517, 25517, 25647], [25649, 25649, 25674, 25674, 25860], [25862, 25862, 25883, 25883, 26038], [26040, 26040, 26069, 26069, 26281], [26283, 26283, 26322, 26322, 26506]], "test": "untested"}
{"id": "Ml3cRB", "name": "Octonionic Julia Sets, 2D slices", "author": "dust", "description": "A standard julia DE extended for the octonions; elements are multiplied with the Cayley-Dickson process.\nhttps://en.wikipedia.org/wiki/Cayley–Dickson_construction\n", "tags": ["procedural", "2d", "julia", "distanceestimation", "audio", "fractals", "octonions"], "likes": 4, "viewed": 100, "published": "Public", "date": "1533012618", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n// Ordinary complex multiplication\nvec2 CplxMul(vec2 a, vec2 b)\n{\n    return vec2((a.x * b.x) - (a.y * b.y), \n                (a.x * b.y) + (a.y * b.x));\n}\n\n// Complex conjugate defined here because I ceebs copying it all over the place\nvec2 CplxConj(vec2 c)\n{\n    return c * vec2(1.0f, -1.0f);\n}\n\n// Octonionic products require a quaternionic product under the Cayley-Dickson\n// process, define that here\nvec4 QtnProd(vec4 q, vec4 p)\n{\n    // Quaternion multiplication may be reduced to complex multiplication\n\t// First decline quaternions into ordered pairs of complex numbers\n\t// q(i0,i1,j0,j1)p(k0,k1,l0,l1) >> (i,j)(k,l) \n    // multiplication is defined by (i,j)(k,l) >> (ik - l*j, li + jk*)\n    return vec4(CplxMul(q.xy, p.xy) - CplxMul(CplxConj(p.zw), q.zw),\n                CplxMul(p.zw, q.xy) + CplxMul(q.zw, CplxConj(p.zw)));\n}\n\n// Octonionic products require a quaternionic conjugate under the Cayley-Dickson\n// process; define that here\nvec4 QtnConj(vec4 q)\n{\n    return vec4(CplxConj(q.xy), \n                q.zw * -1.0f);\n}\n\n// Octonionic Cayley-Dickson product from\n// https://en.wikipedia.org/wiki/Cayley–Dickson_construction\nmat2x4 OctoMul(mat2x4 o, mat2x4 w)\n{\n    // Octonion multiplication extends directly from quaternion multiplication, thus:\n\t// o(p,q)w(r,s) >> (pr - s*q, sp + qr*)\n    return mat2x4(vec4(QtnProd(o[0], w[0]) - QtnProd(QtnConj(w[1]), o[1])),\n                  vec4(QtnProd(w[1], o[0]) + QtnProd(o[1], QtnConj(w[0]))));\n}\n\n// No 8D vectors in GLSL, so manually define octonion length\n// here\nfloat octoLen(mat2x4 o)\n{\n    // Euclidean norm (|v| = sqrt(sum(v.x...)))\n    return sqrt(dot(o[0], o[0]) + dot(o[1], o[1]));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{    \n    // Populate 8D starting coordinate\n    float scale = 0.8f;\n    vec2 baseCoord = vec2(-1.0, -1.0) + 2.0 * (fragCoord.xy / iResolution.xy);\n\tmat2x4 j = mat2x4(vec4(baseCoord, baseCoord),\n                      vec4(baseCoord, baseCoord)) * scale;\n   \tj[0].x *= iResolution.x / iResolution.y;\n    \n    // Fractal pan time interval\n    float sTime = max((sin(iTime) * 0.3f) - 0.2f, 0.3f);\n    \n    // Fractal seed value\n    mat2x4 c = mat2x4(sTime * 5.0f, cos(iTime), sin(iTime), sTime, // First subquaternion defined from time, audio FFT\n                      max(sin(cos(iTime)) - 0.5f, 1.0f), 0.5f, 0.0f, 0.8f) // Second subquaternion defined from audio waveform\n        \t\t\t* sTime; // Per-frame constant scaled by sin(t) for panning\n        \n    // Iterations\n    float maxDist = 2000.0;\n    mat2x4 dj = mat2x4(vec4(1,0,0,0), vec4(0));\n    float iter = 0.0;\n    float maxIter = 1024.0;\n    while (iter < maxIter &&\n           octoLen(j) < maxDist)\n    {\n        dj = 2.0 * OctoMul(j, dj);\n    \tj = OctoMul(j, j) + c;\n        iter += 1.0;\n    }\n    \n    // Final distance\n    float r = octoLen(j);\n    float dr = octoLen(dj);\n    float dist = 0.5 * r * log(r) / dr;\n    \n    // Color treatment from iq's Mandelbrot DE\n    // https://www.shadertoy.com/view/lsX3W4\n    dist = clamp(pow(4.0 * dist/scale, 0.2), 0.0, 1.0);\n  \tfragColor = vec4(dist,\n                     dist, \n                     dist,\n                     1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Ml3cRB.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 36, 66, 66, 156], [158, 238, 261, 261, 297], [299, 407, 437, 698, 839], [841, 951, 973, 973, 1039], [1041, 1146, 1182, 1309, 1464], [1466, 1535, 1560, 1608, 1662], [1664, 1664, 1719, 1762, 3154]], "test": "untested"}
{"id": "Ml3cRH", "name": "Bad terrain render", "author": "WingStone", "description": "learn terrain render~\nreference:\nartical http://www.iquilezles.org/www/articles/terrainmarching/terrainmarching.htm;\nnoise: https://www.shadertoy.com/view/4sfGzS", "tags": ["terrainraymatchingvaluenoise"], "likes": 0, "viewed": 384, "published": "Public API", "date": "1531800847", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define EPS 0.001\n#define lightCol vec3(1.0,1.0,1.0)\nvec3 lightDir = normalize(vec3(1.0, 0.3, 0.0));\n\n//value noise\n//reference: https://www.shadertoy.com/view/4sfGzS\nfloat Noise(vec3 pos)\n{\n    pos *=2.0;\n    vec3 p = floor(pos);\n    vec3 f = fract(pos);\n    vec2 uv = p.xy + vec2(37.0, 17.0)*p.z + f.xy;\n    \n    vec2 rg = texture(iChannel0, (uv+0.5)/256.0).yx;\n    return mix(rg.x, rg.y, f.z)*2.0-1.0;\n}\n\nfloat FractalNoise(vec3 pos)\n{\n    return Noise(pos)+Noise(pos*2.0)*0.5+Noise(pos*4.0)*0.25+Noise(pos*8.0)*0.125;\n}\n\nfloat HightFunction(vec3 pos)\n{\n    float hight = Noise(pos*0.05)*5.5;\n    float dthight = Noise(pos*0.4)*0.5;\n    hight += mix(0.0, dthight, clamp(hight+0.1, 0.1, 1.0));\n    dthight = Noise(pos*10.0)*0.01;\n    hight += mix(0.0, dthight, clamp(hight-1.5, 0.5, 1.0));\n\n    return hight;\n}\n\nvec3 GetNormal(vec3 pos)\n{\n    vec3 dx = vec3(EPS, HightFunction(pos+vec3(EPS, 0.0, 0.0))-HightFunction(pos), 0.0);\n    vec3 dz = vec3(0, HightFunction(pos+vec3(0.0, 0.0, EPS))-HightFunction(pos), EPS);\n    return normalize(cross(dz, dx));\n}\n\nfloat RayMatching(vec3 rayOri, vec3 rayDir)\n{\n\tfloat nearDist = 0.1f;\n    float farDist = 80.0f;\n    float stp = 0.05f;\n    \n    float d = nearDist;\n    float lastHeight;\n    float lastPosy;\n    while(d < farDist)\n    {\n        vec3 pos = rayOri + rayDir*d;\n        float hight = HightFunction(pos);    \n        if(hight > pos.y)\n        {\n            //intersection\n            float delt = hight - pos.y;\n            return d - stp*delt/(lastPosy -lastHeight + delt);\n        }\n        lastHeight = hight;\n        lastPosy = pos.y;\n        stp += 0.01;\n        d += stp;\n    }\n\n    return -1.0;\n}\n\nvec3 CalculateCol(vec3 pos, vec3 nor)\n{\n    vec3 mtrlCol = mix(vec3(0.3,0.6,0.1), vec3(0.7,0.7,0.6), pos.y/1.5+1.0);\n    \n    //snow color\n    float noise = FractalNoise(pos*0.7)+0.5;\n    mtrlCol += step(0.0, noise)*step(0.5, pos.y+noise*1.0)*vec3(1.0,1.0,1.0);\n    vec3 col = clamp(dot(lightDir, nor), 0.1, 1.0) * lightCol*mtrlCol;\n\n    //calculate shadow\n    float shadow = 1.2;\n    float stp = 0.01;\n    for(float d = 0.05; d < 20.0;)\n    {\n        vec3 dpos = pos + lightDir*d;\n        float hight = HightFunction(dpos);\n        if(hight > dpos.y)\n        {\n            shadow = 0.1;\n            break;\n        }\n        stp += 0.01;\n        d+= stp;\n    }\n    return col*shadow;\n}\n\nvec3 GetSkyCol(vec3 dir)\n{\n    float factor = dot(dir, lightDir);\n    return mix(vec3(0.5,0.6,1.0), lightCol, clamp(0.0, 1.0, pow(factor,7.0)) + smoothstep(0.985,1.0, factor));\n}\n        \nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = (fragCoord.xy * 2.0 - iResolution.xy)/iResolution.y;\n    vec3 camera = vec3(-4.5 + 0.5*sin(iTime*0.1),8.0, 1.5);\n    vec3 target = vec3(0.0, 6.0, 0.0);\n    \n    vec3 front = normalize(target - camera);\n    vec3 right = cross(vec3(0.0, 1.0, 0.0), front);\n    vec3 up = cross(front,right);\n    vec3 rayDir = normalize(front*1.732 + uv.x*right + uv.y*up);\n\n    float dist = RayMatching(camera, rayDir);\n    \n    vec3 pos = camera + rayDir*dist;\n    vec3 nor = GetNormal(pos);\n    \n    vec3 col;\n    if(dist < 0.0)\n    {\n        col = GetSkyCol(rayDir);\n    }\n    else\n    {\n    \tcol = CalculateCol(pos, nor);\n        //fog color\n        col = mix(col, vec3(0.7,0.7,0.7), dist/300.0 + (5.0 - pos.y)/60.0);\n    }\n    \n    col = pow(col, vec3(1.0f/2.2f));\n    \n    //vignette\n    col *= clamp(0.0, 1.0, 2.0 - length(2.0*abs(fragCoord.xy / iResolution.xy - 0.5)));\n    \n    fragColor = vec4(col, 1.0);\n}", "image_inputs": [{"id": "Xsf3zn", "previewfilepath": "/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "channel": 0, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Ml3cRH.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[102, 167, 190, 190, 406], [408, 408, 438, 438, 523], [525, 525, 556, 556, 812], [814, 814, 840, 840, 1055], [1057, 1057, 1102, 1102, 1655], [1657, 1657, 1696, 1696, 2342], [2344, 2344, 2370, 2370, 2522], [2532, 2532, 2589, 2589, 3497]], "test": "untested"}
{"id": "Ml3yRr", "name": "Rectangles", "author": "dazuma", "description": "Mondrian exercise ", "tags": ["rectangles", "mondrian", "bookofshaders"], "likes": 7, "viewed": 406, "published": "Public API", "date": "1531776915", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec3 vLine(vec2 uv, vec2 pos, float border, float width)\n{\n    float vl = smoothstep(pos.x-border/2., pos.x, uv.x) - smoothstep(pos.x, pos.x+border/2., uv.x);\n    float hl = step(pos.y-width/2.,uv.y) - step(pos.y+width/2., uv.y);\n    return vec3(1.-vl*hl);\n}\n\nvec3 hLine(vec2 uv, vec2 pos, float border, float width)\n{\n    float vl = smoothstep(pos.y-border/2., pos.y, uv.y) - smoothstep(pos.y, pos.y+border/2., uv.y);\n    float hl = step(pos.x-width/2.,uv.x) - step(pos.x+width/2., uv.x);\n    return vec3(1.-vl*hl);\n}\n\nvec3 square(vec2 uv, vec2 pos, vec2 width, float border, vec3 color)\n{\n    float val = vLine(uv, vec2(pos.x-width.x/2.,pos.y), border, width.y).x;\n    val *= vLine(uv, vec2(pos.x+width.x/2.,pos.y), border, width.y).x;\n    val *= hLine(uv, vec2(pos.x,pos.y+width.y/2.), border, width.x).x;\n    val *= hLine(uv, vec2(pos.x,pos.y-width.y/2.), border, width.x).x;\n    float cval = step(pos.x-width.x/2., uv.x) - step(pos.x+width.x/2., uv.x);\n    cval *= step(pos.y-width.y/2., uv.y) - step(pos.y+width.y/2., uv.y);\n    vec3 c = 1. - vec3(cval)*vec3(1.-color.x,1.-color.y,1.-color.z);\n    return vec3(val)*c;\n}\n\nvec3 crossHair(vec2 uv, vec2 pos, float border){\n    float val = vLine(uv, pos, border, 1.).x;\n    val *= hLine(uv, pos, border, 1.).x;\n    return vec3(val);\n}\n\nvec3 crossSquare(vec2 uv, vec2 pos, vec2 width, float border, vec3 color)\n{\n    vec3 val = square(uv,pos,width,border, color);\n    val *= crossHair(uv, pos+width/2., border);\n    val *= crossHair(uv, pos-width/2., border);\n    return val;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy/iResolution.x;\n    vec3 col = vec3(0.);\n    float ar = iResolution.y/iResolution.x;\n    vec2 point[5];\n    point[0] = vec2(0.5*sin(iTime*0.05)+0.5,0.5);\n    point[1] = vec2(0.60,0.5*sin(iTime*0.02)+0.5);\n    point[2] = vec2(0.78,0.5*sin(iTime*0.03)+0.5);\n    point[3] = vec2(0.5*sin(iTime*0.04)+0.5,0.5*sin(iTime*0.01)+0.5);\n    point[4] = iMouse.xy/iResolution.xy;\n    \n    float m_dist = 1.;  // minimun distance\n    vec2 m_point;        // minimum position\n    \n    for (int j=0; j<5; j++){\n        for (int i = 0; i < 5; i++) {\n            float dist = distance(point[j], point[i]);\n            if ( dist < m_dist && j != i) {\n                // Keep the closer distance\n                m_dist = dist;\n\n                // Kepp the position of the closer point\n                m_point = point[i];\n            }\n        }\n\t\t\n        if (j == 0){\n        \tcol = crossSquare(uv, vec2(point[j].x,point[j].y*ar), vec2(m_dist/2.), 0.01, vec3(1.,0.,0.));\n        } else if (j == 1 || j == 2){\n            col *= crossSquare(uv, vec2(point[j].x,point[j].y*ar), vec2(m_dist/2.), 0.01, vec3(0.13333,0.3137,0.5843));\n        } else if (j==3){\n            col *= crossSquare(uv, vec2(point[j].x,point[j].y*ar), vec2(m_dist/2.), 0.01, vec3(0.98039,0.78823,0.003921));\n        }  else if (j==4){\n            col *= crossSquare(uv, vec2(point[j].x,point[j].y*ar), vec2(m_dist/2.), 0.01,  vec3(1.,0.,0.));\n        }\n            \n    }\n    \n    \n    //if (iMouse.z > 0.){\n       \t//col = square(uv, iMouse.xy/iResolution.x, vec2(0.1,0.2), 0.01);\n    //}\n    //else{\n    \t//col = square(uv, vec2(0.5,0.5*ar), vec2(0.5, 0.2), 0.01);\n    //}\n\n    fragColor = vec4(col,1.0);\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Ml3yRr.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 58, 58, 258], [260, 260, 318, 318, 518], [520, 520, 590, 590, 1125], [1127, 1127, 1175, 1175, 1286], [1288, 1288, 1363, 1363, 1528], [1530, 1530, 1587, 1587, 3273]], "test": "untested"}
{"id": "MlccDN", "name": "xmb essence", "author": "fenwick67", "description": "Tried to capture the essence of the PSP XMB background. Good times.", "tags": ["2d", "gradient", "xmb"], "likes": 6, "viewed": 893, "published": "Public API", "date": "1532745073", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define AQUA vec4(8.0/255.0,220.0/255.0,220.0/255.0,1.0)\n#define BLUE vec4(1.0/255.0,129.0/255.0,127.0/255.0,1.0)\n\n//#define AQUA vec4(0.7,0.7,0.7,1.0)\n//#define BLUE vec4(0.0,0.0,0.0,1.0)\n\n\n#define RIBBONCOLOR vec4(1.0,1.0,1.0,0.5)\n#define TRANSP vec4(0.0,0.0,0.0,0.0)\n#define RIBWIDTH 0.03\n\n#define AA 1.0/iResolution.y\n\n#define time (100.0 + iTime / 15.0)\n#define COLORTIME iTime / 22.0 + 0.3\n\n#define HILLS\n\n\n// 0..1 returns 0..1\nfloat sin01(float x){\n    float x2 = fract(x);\n\treturn 0.5 + 0.5 * sin(x2 * 6.28318530718);   \n}\n\n// outer color\nvec4 color1(){\n    float x = COLORTIME;\n    float darken = 0.8;\n\treturn vec4(darken*sin01(x),darken*sin01(x+1.0/3.0),darken*sin01(x+2.0/3.0),1.0);\n}\n\n// inner color\nvec4 color2(){\n    float x = COLORTIME;\n    float offset = 0.05;\n\treturn vec4(sin01(x + offset),sin01(x+1.0/2.0+offset),sin01(x+2.0/3.0+offset),1.0);\n}\n\nvec4 background(vec2 uv){\n    float dist = 1.4142*length(uv - vec2(0.5,0.5));\n    return mix(color1(),color2(),1.0-dist);\n}\n\nvec4 foreground(vec2 uv){\n    return vec4(color2().rgb,0.3 );\n}\n\nvec4 saturateColors(vec4 c1, vec4 c2){\n    // return c1 ++ c2\n    vec3 newColor = c1.rgb * c2.rgb;\n    float newAlpha = 1.0;\n    \n    return mix(c2,vec4(newColor,newAlpha),c1.a);\n}\n\n// source-over alpha composite\nvec4 addColors(vec4 c1, vec4 c2){\n\tvec4 color =  mix(c2,c1,c1.a);   \n    color.a = 1.0;\n    return color;\n}\n\nfloat rand(float n){\n    return fract(sin(n) * 43758.5453123);\n}\nfloat wave(float x){\n    return sin(x) * cos(x*3.0) * sin(0.7*x);\n}\n\nvec4 ribbon(float seed, vec2 uv){\n    \n    float phase = rand(seed+0.2)*10.0;\n    float speedMod = 1.0 + rand(seed+0.123);\n    float width = RIBWIDTH*(seed-1.0+0.1);\n    \n    float warpY = uv.y + wave(uv.x*1.0 + time*speedMod + phase)*0.15;\n    \n    #ifdef HILLS\n    float alpha = seed*0.22 + 0.25;\n    float inRibbon = warpY + RIBWIDTH*3.0 + width;\n    #endif        \n    #ifndef HILLS\n    float alpha = 1.0 - seed*0.22 + 0.25;\n    float inRibbon = max(warpY-width, 1.0 - width - warpY);\n    #endif\n    \n    inRibbon = smoothstep(0.5 - AA,0.5 + AA,1.0-inRibbon);\n    return vec4(RIBBONCOLOR.rgb,mix(alpha,0.0,1.0-inRibbon));\n}\nvec4 ribbon(vec2 uv){\n\treturn ribbon(1.0,uv);\n}\n\nvec4 circle(vec2 uv){\n\tfloat inCircle = length(uv - vec2(0.333,0.666))+0.4; \n    inCircle = smoothstep(0.5 - AA,0.5 + AA,1.0-inCircle);\n    return vec4(RIBBONCOLOR.rgb,inCircle*0.9);\n}\nfloat clamp01(float x){\n    return clamp(x,0.0,1.0);\n}\nvec4 plus(vec2 uv){\n\tfloat r1 = max(clamp01(max(1.1 - uv.x, uv.x-0.15)),clamp01(max(1.15 - uv.y, uv.y-0.35)));\n    float r2 = max(clamp01(max(1.025 - uv.x, uv.x-0.225)),clamp01(max(1.225 - uv.y, uv.y-0.275)));\n    \n    float inPlus = min(r1,r2);\n    inPlus = smoothstep(0.5 - AA,0.5 + AA,1.0-inPlus);\n    return vec4(RIBBONCOLOR.rgb,inPlus*0.9);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 uvc = fragCoord/min(iResolution.x,iResolution.y);\n\n    vec4 bgColor = background(uv);\n\n    fragColor = bgColor;\n    \n    fragColor = addColors(ribbon(1.0,uv),fragColor);\n    fragColor = addColors(ribbon(2.0,uv),fragColor);\n    fragColor = addColors(ribbon(3.0,uv),fragColor);\n    fragColor = addColors(circle(uvc),fragColor);\n    //fragColor = addColors(plus(uvc),fragColor);\n    \n    \n    fragColor = saturateColors(foreground(uv),fragColor);\n        \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MlccDN.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[413, 434, 455, 455, 530], [532, 547, 561, 561, 695], [697, 712, 726, 726, 863], [865, 865, 890, 890, 988], [990, 990, 1015, 1015, 1053], [1055, 1055, 1093, 1116, 1235], [1237, 1268, 1301, 1301, 1375], [1377, 1377, 1397, 1397, 1441], [1442, 1442, 1462, 1462, 1509], [1511, 1511, 1544, 1544, 2138], [2139, 2139, 2160, 2160, 2186], [2188, 2188, 2209, 2209, 2372], [2373, 2373, 2396, 2396, 2427], [2428, 2428, 2447, 2447, 2775], [2777, 2777, 2834, 2884, 3388]], "test": "untested"}
{"id": "MlccRB", "name": "AtjzfdvE2zw2PZ4uwQaf", "author": "liurui39660", "description": "Texture \"Abstract 1\" or \"Lichen\" are both okay, I prefer the latter one.\nIt is only one sphere and five planes, and some lighting process, nothing more.\n", "tags": ["none"], "likes": 6, "viewed": 221, "published": "Public", "date": "1533005546", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const float PI = atan(1., 1.)*4.;\n\nconst vec3 BACKGROUND_COLOR = vec3(0.1, 0.2, 0.6);\nconst float FOVY = 50.0 * PI / 180.0;\nconst float DEFAULT_TMIN = 10.0e-4;\nconst float DEFAULT_TMAX = 10.0e6;\nconst int NUM_ITERATIONS = 2;\n\nstruct Ray_t {\n\tvec3 o;  // Ray Origin.\n\tvec3 d;  // Ray Direction. A unit vector.\n};\nstruct Plane_t {\n\t// The plane equation is Ax + By + Cz + D = 0.\n\tfloat A, B, C, D;\n\tint materialID;\n};\nstruct Sphere_t {\n\tvec3 center;\n\tfloat radius;\n\tint materialID;\n};\nstruct Light_t {\n\tvec3 position;  // Point light 3D position.\n\tvec3 I_a;       // For Ambient.\n\tvec3 I_source;  // For Diffuse and Specular.\n};\nstruct Material_t {\n\tvec3 k_a;   // Ambient coefficient.\n\tvec3 k_d;   // Diffuse coefficient.\n\tvec3 k_r;   // Reflected specular coefficient.\n\tvec3 k_rg;  // Global reflection coefficient.\n\tfloat n;    // The specular reflection exponent. Ranges from 0.0 to 128.0. \n};\n\n#define HitType_t int\n#define NOTHING 0\n#define PLANE 1\n#define SPHERE 2\n\nconst int NUM_PER_DIR = 7;\n\nconst int NUM_SPHERES = 1;\nconst float RADIUS = 1.0 / 4.0;\nSphere_t Sphere[NUM_SPHERES];\nint index(int x, int y) {\n\treturn x * NUM_PER_DIR + y;\n}\nvoid InitSphere() {\n\tSphere[0].radius = 1.0;\n\tSphere[0].center = vec3(1, 1, 1);\n\tSphere[0].materialID = 0;\n}\n\nconst int NUM_PLANES = 5;\nPlane_t Plane[NUM_PLANES];\nvoid InitPlane() {\n\tPlane[0].A = 0.0;\n\tPlane[0].B = 1.0;\n\tPlane[0].C = 0.0;\n\tPlane[0].D = 0.0;\n\tPlane[0].materialID = -1;\n\n\tPlane[1].A = 0.0;\n\tPlane[1].B = 0.0;\n\tPlane[1].C = 1.0;\n\tPlane[1].D = 5.0;\n\tPlane[1].materialID = -1;\n\n\tPlane[2].A = 1.0;\n\tPlane[2].B = 0.0;\n\tPlane[2].C = 0.0;\n\tPlane[2].D = 5.0;\n\tPlane[2].materialID = -1;\n\n\tPlane[3].A = 0.0;\n\tPlane[3].B = 0.0;\n\tPlane[3].C = -1.0;\n\tPlane[3].D = 5.0;\n\tPlane[3].materialID = -1;\n\n\tPlane[4].A = -1.0;\n\tPlane[4].B = 0.0;\n\tPlane[4].C = 0.0;\n\tPlane[4].D = 5.0;\n\tPlane[4].materialID = -1;\n}\n\nconst int NUM_LIGHTS = 2;\nLight_t Light[NUM_LIGHTS];\nvoid InitLight() {\n\tLight[0].position = vec3(0, 0.5*sin(0.25*iTime) + 3.0 + RADIUS, 0);\n\tLight[0].I_a = vec3(0.1, 0.1, 0.1);\n\tLight[0].I_source = vec3(1.0, 1.0, 1.0);\n}\n\nconst int NUM_MATERIALS = 1;\nMaterial_t Material[NUM_MATERIALS];\nvoid InitMaterial() {\n\tMaterial[0].k_d = vec3(0.1, 0.6, 0.8);\n\tMaterial[0].k_a = 0.2 * Material[0].k_d;\n\tMaterial[0].k_r = 2.0 * Material[0].k_d;\n\tMaterial[0].k_rg = 0.5 * Material[0].k_r;\n\tMaterial[0].n = 64.0;\n}\n\nvoid InitScene() {\n\tInitSphere();\n\tInitPlane();\n\tInitLight();\n\tInitMaterial();\n}\nbool IntersectPlane(in Plane_t pln, in Ray_t ray, in float tmin, in float tmax, out float t, out vec3 hitPos, out vec3 hitNormal, out HitType_t hitType) {\n\tvec3 N = vec3(pln.A, pln.B, pln.C);\n\tfloat NRd = dot(N, ray.d);\n\tfloat NRo = dot(N, ray.o);\n\tfloat t0 = (-pln.D - NRo) / NRd;\n\tif (t0 < tmin || t0 > tmax) return false;\n\n\tt = t0;\n\thitPos = ray.o + t0 * ray.d;\n\thitNormal = normalize(N);\n\thitType = PLANE;\n\treturn true;\n}\nbool IntersectPlane(in Plane_t pln, in Ray_t ray, in float tmin, in float tmax) {\n\tfloat _;\n\tvec3 _1;\n\tHitType_t _2;\n\treturn IntersectPlane(pln, ray, tmin, tmax, _, _1, _1, _2);\n}\nbool IntersectSphere(in Sphere_t sph, in Ray_t ray, in float tmin, in float tmax, out float t, out vec3 hitPos, out vec3 hitNormal, out HitType_t hitType) {\n\tray.o -= sph.center;\n\tfloat a = dot(ray.d, ray.d);\n\tfloat b = 2.0 * dot(ray.d, ray.o);\n\tfloat c = dot(ray.o, ray.o) - sph.radius*sph.radius;\n\tfloat d = b * b - 4.0 * a*c;\n\tif (d > 0.0) {\n\t\tfloat solutionA = (-b + sqrt(d)) / (2.0 * a);\n\t\tfloat solutionB = (-b - sqrt(d)) / (2.0 * a);\n\t\tif (solutionB > 0.0)\n\t\t\tt = solutionB;\n\t\telse if (solutionA > 0.0)\n\t\t\tt = solutionA;\n\t\telse\n\t\t\treturn false;\n\t}\n\telse if (d == 0.0)\n\t\tt = -b / (2.0*a);\n\telse\n\t\treturn false;\n\thitPos = ray.o + t * ray.d + sph.center;\n\thitNormal = normalize(hitPos - sph.center);\n\thitType = SPHERE;\n\treturn tmin < t&&t < tmax;\n}\nbool IntersectSphere(in Sphere_t sph, in Ray_t ray, in float tmin, in float tmax) {\n\tfloat _;\n\tvec3 _1;\n\tHitType_t _2;\n\treturn IntersectSphere(sph, ray, tmin, tmax, _, _1, _1, _2);\n}\nvec3 PhongLighting(in vec3 L, in vec3 N, in vec3 V, in bool inShadow,\n\tin Material_t mat, in Light_t light) {\n\tif (inShadow) {\n\t\treturn light.I_a * mat.k_a;\n\t}\n\telse {\n\t\tvec3 R = reflect(-L, N);\n\t\tfloat N_dot_L = max(0.0, dot(N, L));\n\t\tfloat R_dot_V = max(0.0, dot(R, V));\n\t\tfloat R_dot_V_pow_n = (R_dot_V == 0.0) ? 0.0 : pow(R_dot_V, mat.n);\n\t\treturn light.I_a * mat.k_a + light.I_source * (mat.k_d * N_dot_L + mat.k_r * R_dot_V_pow_n);\n\t}\n}\nMaterial_t TextureColor(HitType_t hitType, int hitIndex, vec3 hitPos) {\n\tswitch (hitType) {\n\tcase SPHERE:\n\t\treturn Material[0];\n\t\tbreak;\n\tcase PLANE:\n\t\tif (hitIndex == 0) {\n\t\t\tvec3 color = texture(iChannel0, hitPos.xz / 10.).xyz;\n\t\t\treturn Material_t(0.0*color, 1.0*color, 1.0*color, 0.0*color, 64.0);\n\t\t}\n\t\telse if (hitIndex == 1 || hitIndex == 3) {\n\t\t\tvec3 color = texture(iChannel0, hitPos.xy / 10.).xyz;\n\t\t\treturn Material_t(0.0*color, 1.0*color, 1.0*color, 0.0*color, 64.0);\n\t\t}\n\t\telse if (hitIndex == 2 || hitIndex == 4) {\n\t\t\tvec3 color = texture(iChannel0, hitPos.zy / 10.).xyz;\n\t\t\treturn Material_t(0.0*color, 1.0*color, 1.0*color, 0.0*color, 64.0);\n\t\t}\n\t\tbreak;\n\t}\n}\nvec3 CastRay(in Ray_t ray,\n\tout bool hasHit, out vec3 hitPos, out vec3 hitNormal, out vec3 k_rg) {\n\tbool hasHitSomething = false;\n\tfloat nearest_t = DEFAULT_TMAX;   // The ray parameter t at the nearest hit point.\n\tvec3 nearest_hitPos;              // 3D position of the nearest hit point.\n\tvec3 nearest_hitNormal;           // Normal vector at the nearest hit point.\n\tint nearest_hitMatID;             // MaterialID of the object at the nearest hit point.\n\tHitType_t nearest_hitType = NOTHING;\n\tint nearest_hitIndex;\n\tfloat temp_t;\n\tvec3 temp_hitPos;\n\tvec3 temp_hitNormal;\n\tbool temp_hasHit;\n\tHitType_t temp_hitType;\n\tMaterial_t mat;\n\tfor (int i = 0; i < NUM_PLANES; i++) {\n\t\ttemp_hasHit = IntersectPlane(Plane[i], ray, DEFAULT_TMIN, DEFAULT_TMAX, temp_t, temp_hitPos, temp_hitNormal, temp_hitType);\n\t\tif (temp_hasHit&&temp_t < nearest_t) {\n\t\t\thasHitSomething = true;\n\t\t\tnearest_t = temp_t;\n\t\t\tnearest_hitPos = temp_hitPos;\n\t\t\tnearest_hitNormal = temp_hitNormal;\n\t\t\tnearest_hitMatID = Plane[i].materialID;\n\t\t\tnearest_hitType = temp_hitType;\n\t\t\tnearest_hitIndex = i;\n\t\t}\n\t}\n\tfor (int i = 0; i < NUM_SPHERES; i++) {\n\t\ttemp_hasHit = IntersectSphere(Sphere[i], ray, DEFAULT_TMIN, DEFAULT_TMAX, temp_t, temp_hitPos, temp_hitNormal, temp_hitType);\n\t\tif (temp_hasHit&&temp_t < nearest_t) {\n\t\t\thasHitSomething = true;\n\t\t\tnearest_t = temp_t;\n\t\t\tnearest_hitPos = temp_hitPos;\n\t\t\tnearest_hitNormal = temp_hitNormal;\n\t\t\tnearest_hitMatID = Sphere[i].materialID;\n\t\t\tnearest_hitType = temp_hitType;\n\t\t\tnearest_hitIndex = i;\n\t\t}\n\t}\n\thasHit = hasHitSomething;\n\tif (!hasHitSomething) return BACKGROUND_COLOR;\n\tvec3 I_local = vec3(0.0);\n\tbool inShadow[NUM_LIGHTS];\n\tRay_t rayHitPosToLight[NUM_LIGHTS];\n\tfor (int i = 0; i < NUM_LIGHTS; i++) {\n\t\tinShadow[i] = false;\n\t\trayHitPosToLight[i] = Ray_t(nearest_hitPos, normalize(Light[i].position - nearest_hitPos));\n\t\tfor (int j = 0; j < NUM_PLANES; j++)\n\t\t\tif (IntersectPlane(Plane[j], rayHitPosToLight[i], DEFAULT_TMIN, length(Light[i].position - nearest_hitPos)))\n\t\t\t\tinShadow[i] = true;\n\t\tfor (int j = 0; j < NUM_SPHERES; j++)\n\t\t\tif (IntersectSphere(Sphere[j], rayHitPosToLight[i], DEFAULT_TMIN, length(Light[i].position - nearest_hitPos)))\n\t\t\t\tinShadow[i] = true;\n\t}\n\tfor (int i = 0; i < NUM_LIGHTS; i++) {\n\t\tif (nearest_hitMatID >= 0)\n\t\t\tmat = Material[nearest_hitMatID];\n\t\telse\n\t\t\tmat = TextureColor(nearest_hitType, nearest_hitIndex, nearest_hitPos);\n\t\tI_local += PhongLighting(rayHitPosToLight[i].d, nearest_hitNormal, normalize(-ray.d), inShadow[i], mat, Light[i]);\n\t}\n\thitPos = nearest_hitPos;\n\thitNormal = nearest_hitNormal;\n\tk_rg = Material[nearest_hitMatID].k_rg;\n\treturn I_local;\n}\nRay_t Camera(vec3 position, vec3 lookAt, vec3 upVector) {\n\tvec3 positionPixel = vec3((2.0 * gl_FragCoord.xy - iResolution.xy) / iResolution.y, -1.0 / tan(FOVY / 2.0));\n\tvec3 z = normalize(position - lookAt);\n\tvec3 x = normalize(cross(upVector, z));\n\tvec3 y = normalize(cross(z, x));\n\treturn Ray_t(position, normalize(positionPixel.x*x + positionPixel.y*y + positionPixel.z*z));\n}\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n\tInitScene();\n\tRay_t nextRay = Camera(vec3(5.0*sin(0.1*iTime), 5.0, 5.0*cos(0.1*iTime)), vec3(-5.0*sin(0.1*iTime), 0.0, -5.0*cos(0.1*iTime)), vec3(0., 1, 0));\n\tfragColor = vec4(0, 0, 0, 1);\n\tvec3 compounded_k_rg = vec3(1.0);\n\tfor (int level = 0; level <= NUM_ITERATIONS; level++) {\n\t\tbool hasHit;\n\t\tvec3 hitPos, hitNormal, k_rg;\n\t\tvec3 I_local = CastRay(nextRay, hasHit, hitPos, hitNormal, k_rg);\n\t\tfragColor.xyz += compounded_k_rg * I_local;\n\t\tif (!hasHit)\n\t\t\tbreak;\n\t\tcompounded_k_rg *= k_rg;\n\t\tnextRay = Ray_t(hitPos, normalize(reflect(nextRay.d, hitNormal)));\n\t}\n}\n", "image_inputs": [{"id": "4sfGRn", "previewfilepath": "/media/ap/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MlccRB.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1088, 1088, 1113, 1113, 1144], [1145, 1145, 1164, 1164, 1253], [1308, 1308, 1326, 1326, 1849], [1904, 1904, 1922, 1922, 2072], [2139, 2139, 2160, 2160, 2352], [2354, 2354, 2372, 2372, 2434], [2435, 2435, 2589, 2589, 2860], [2861, 2861, 2942, 2942, 3040], [3041, 3041, 3197, 3197, 3793], [3794, 3794, 3877, 3877, 3976], [3977, 3977, 4086, 4086, 4419], [4420, 4420, 4491, 4491, 5095], [5096, 5096, 5194, 5194, 7717], [7718, 7718, 7775, 7775, 8097], [8098, 8098, 8153, 8153, 8722]], "test": "untested"}
{"id": "Mlcczr", "name": "sci-fi hexagons", "author": "laserdog", "description": "some cool sci-fi hexagons. credit to Shane for hexagon tiling algorithm (https://www.shadertoy.com/view/Xljczw)", "tags": ["tech", "scifi", "hexagons"], "likes": 36, "viewed": 1186, "published": "Public", "date": "1531377058", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define S(r,v) smoothstep(9./iResolution.y,0.,abs(v-(r)))\n\nconst vec2 s = vec2(1, 1.7320508); // 1.7320508 = sqrt(3)\nconst vec3 baseCol = vec3(.05098, .25098, .2784);\nconst float borderThickness = .02;\nconst float isolineOffset = .4;\nconst float isolineOffset2 = .325;\n\nfloat calcHexDistance(vec2 p)\n{\n    p = abs(p);\n    return max(dot(p, s * .5), p.x);\n}\n\nfloat random(vec2 co)\n{\n    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nvec4 calcHexInfo(vec2 uv)\n{\n    vec4 hexCenter = round(vec4(uv, uv - vec2(.5, 1.)) / s.xyxy);\n    vec4 offset = vec4(uv - hexCenter.xy * s, uv - (hexCenter.zw + .5) * s);\n    return dot(offset.xy, offset.xy) < dot(offset.zw, offset.zw) ? vec4(offset.xy, hexCenter.xy) : vec4(offset.zw, hexCenter.zw);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = 3. * (2. * fragCoord - iResolution.xy) / iResolution.y;\n    uv.x += iTime * .25;\n    \n    vec4 hexInfo = calcHexInfo(uv);\n    float totalDist = calcHexDistance(hexInfo.xy) + borderThickness;\n    float rand = random(hexInfo.zw);\n    \n    float angle = atan(hexInfo.y, hexInfo.x) + rand * 5. + iTime;\n    vec3 isoline = S(isolineOffset, totalDist) * baseCol * step(3. + rand * .5, mod(angle, 6.28))\n        + S(isolineOffset2, totalDist)\n                    * baseCol * step(4. + rand * 1.5, mod(angle + rand * 2., 6.28));\n    \n    float sinOffset = sin(iTime + rand * 8.);\n    float aa = 5. / iResolution.y;\n    \n    fragColor.rgb = (smoothstep(.51, .51 - aa, totalDist) + pow(1. - max(0., .5 - totalDist), 20.) * 1.5)\n        * (baseCol + rand * vec3(0., .1, .09)) + isoline + baseCol * smoothstep(.2 + sinOffset, .2 + sinOffset - aa, totalDist);    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Mlcczr.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[94, 270, 301, 301, 356], [358, 358, 381, 381, 453], [455, 455, 482, 482, 757], [759, 759, 816, 816, 1683]], "test": "untested"}
{"id": "MlcyzN", "name": "Capsule waves", "author": "toocanzs", "description": "One of my first raymarching shaders I had unlisted for a while. ", "tags": ["raymarch"], "likes": 0, "viewed": 58, "published": "Public", "date": "1531771546", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define EPSILON 0.0001\nconst float radius = 0.25;\nconst float height = 2.;\nconst float scale = 0.5;\n\nvec3 noiseRGB( in vec2 p) {\n    vec2 i = floor( p );\n    vec2 f = fract( p );\t\n\tf = f*f*(3.0-2.0*f);\n    vec4 col = textureLod(iChannel0, (i+f+vec2(0.5))/64.0, 0.0);\n    return col.rgb;\n}\n\nfloat noise( in vec2 p) {\n    vec2 i = floor( p );\n    vec2 f = fract( p );\t\n\tf = f*f*(3.0-2.0*f);\n    vec4 col = textureLod(iChannel0, (i+f+vec2(0.5))/64.0, 0.0);\n    return col.x*2.0 -1.0;\n}\n\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r )\n{\n    vec3 pa = p - a, ba = b - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h ) - r;\n}\nfloat getHeight(vec2 id)\n{\n    return noise(id*0.2 + vec2(iTime,iTime)*0.6);\n}\nfloat map(vec3 point)\n{\n    \n    point = point*2.0 - 1.0;\n    vec2 id = floor(point.xz/scale)-(scale/2.);\n    float nHeight = height + getHeight(id);\n    point.xz = mod(point.xz,scale)-(scale/2.);\n    \n    \n    float capsule = sdCapsule(point, vec3(0,nHeight,0), vec3(0,-nHeight,0), radius);\n    return capsule;\n}\n\nbool trace(vec3 origin, vec3 ray, out float d)\n{\n    float t = 0.0;\n    \n    for(int i = 0; i < 256; i++)\n    {\n        vec3 samplePoint = origin + ray*t;\n        float dist = map(samplePoint);\n        t += dist*0.1;\n        d = t;\n        if(dist < EPSILON)\n        {\n            return true;\n        }\n    }\n    return false;\n}\n\nvec3 getNormal(vec3 pos)\n{\n    vec2 e = vec2(1.0,-1.0)*0.5773*0.0005;\n    return normalize( e.xyy*map( pos + e.xyy ) + \n\t\t\t\t\t  e.yyx*map( pos + e.yyx ) + \n\t\t\t\t\t  e.yxy*map( pos + e.yxy ) + \n\t\t\t\t\t  e.xxx*map( pos + e.xxx ) );\n}\n\nconst vec3 lightDir = normalize(vec3(2,2,-2));\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    uv = uv * 2.0 - 1.0;\n    \n    uv.x *= iResolution.x/iResolution.y;\n    \n    float ang = cos(iTime*0.4) + sin(sin(iTime*1.2));\n    mat3 rotation = mat3(cos(ang),0,sin(ang),\n                        0,1,0,\n                        -sin(ang),0,cos(ang));\n    \n    vec3 ray = normalize(vec3(uv, 1.0)) * rotation;\n        \n        \n    vec3 origin = vec3(0,2.0,iTime);\n    \n    float dist;\n    float mapDist;\n    bool traced = trace(origin, ray, dist);\n    vec3 hitPos = origin + ray*dist;\n    vec3 normal = getNormal(hitPos);\n    \n    float shadowDist;\n    vec3 shadowRay = lightDir;\n    bool shadow = trace(hitPos+ normal*0.1, shadowRay, shadowDist);\n    \n    float fog = 1.0 / (1.0 + dist*dist * 0.1);\n    vec3 fogColor = vec3(0.7,0.6,0.4);\n    vec3 point = (origin + ray*dist)*2.0 - 1.0;\n    vec2 id = floor(point.xz/scale)-(scale/2.);\n    vec3 diffuseColor = noiseRGB(id);\n    \n    \n    float nDotL = clamp(dot(normal, lightDir),0.,1.);\n    vec3 ambientCol = vec3(0.1);\n    vec3 diffuse = mix(ambientCol, diffuseColor, nDotL* float(!shadow));\n    fogColor = mix(fogColor, vec3(1), pow(clamp(dot(ray, lightDir),0.,1.),10.));\n    vec3 col = mix(fogColor, diffuse,fog);\n   \n    \n    //col = vec3(shadow);\n\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": "XdXGzn", "previewfilepath": "/media/ap/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MlcyzN.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[101, 101, 128, 128, 288], [290, 290, 315, 315, 482], [484, 484, 536, 536, 663], [664, 664, 690, 690, 742], [743, 743, 766, 766, 1056], [1058, 1058, 1106, 1106, 1387], [1389, 1389, 1415, 1415, 1615], [1665, 1665, 1722, 1722, 3005]], "test": "untested"}
{"id": "MldcR4", "name": "01_Oscilloscope", "author": "CptSloth199", "description": "Oscilloscope with an interactive Cursor that follows the Curve. This is my first shader in glsl, feel free to play with the settings on the right and leave feedback. :D", "tags": ["oscilloscope", "interactive", "green", "curve"], "likes": 2, "viewed": 121, "published": "Public", "date": "1531859431", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    //Anti Stretch, thanks to Abvadabra\n    float ScreenScaleAdj = iResolution.x / iResolution.y;\n    uv.x *= ScreenScaleAdj;\n    \n    //This will look really dumb if it turns out there is a predefined constant in GLSL....\n    float Pi = 3.14;\n    \n    \n    //////////////////////////////////////////////////////\n    //                  ---SETTINGS---                  //\n    //////////////////////////////////////////////////////\n    \n    \n\n    //Set what Version to use!\n    bool UseSmoothVersion = true;\n    \n    //Automatic Version Switching\n    bool AlternateVersions = false;\n    \n    //Switching Version Interval\n    float IntervalV = 5.0;\n    \n    \n    \n    //Distortion Mode (0-5)\n    int DistortionMode = 5;\n    \n    //Automatic Mode Switching\n    bool AlternateModes = true;\n    \n    //Distortion\n    float Distortion = 15.2;\n    \n    //Switching Mode Interval\n    float IntervalM = .15;\n    \n    \n    \n    //Set Line Color\n    vec3 LineColBase = vec3(0.0,0.6,0.0);\n    \n    //Set Line Color2\n    vec3 LineColCurve = vec3(0.0,1.0,0.0);\n    \n    \n    \n    //Set Curve Speed\n    float CurveSpeed = 2.0;\n    \n\n    //Scale X Axis\n    float CurveXScale = Pi * 4.0;\n    \n    \n    //Scale Y Axis\n    float CurveYScale = 0.6;\n    \n    \n    //Set Line Width\n    float LineWidth = 4.0/iResolution.y;\n    \n    \n    //Set Sharpness (Only Smooth Version)\n    float LineSharpness = 65.0;\n    \n    \n    //////////////////////////////////////////////////////\n    //////////////////////////////////////////////////////\n    //////////////////////////////////////////////////////\n    \n    \n    \n    //ReaderHead Effect\n    float ReaderHeadLocation = iMouse.x/iResolution.x * (ScreenScaleAdj);\n    \n    \n    //Timed Switches\n    if(AlternateVersions){\n        if (mod (iTime, IntervalV)< IntervalV * 0.5)\n            UseSmoothVersion = true;\n        else\n            UseSmoothVersion = false;\n    }\n    \n    if(AlternateModes){\n        DistortionMode = int(mod((iTime * IntervalM),6.0));\n        \n    }\n    \n    \n    vec3 LineCol = vec3(1.0,1.0,0.0);\n    \n    //Background Color\n    float BackGrndCol = 0.5;\n    vec3 BackGrnd = abs(uv.y-0.5)*vec3(BackGrndCol,BackGrndCol,BackGrndCol);\n    \n    \n    //Grid\n    vec3 GridPatternX = pow(clamp(sin(uv.x*100.0),0.0,1.0),55.0)* abs(pow(clamp(sin(uv.y*100.0),0.0,1.0),1.0)-1.0)*vec3(1.0,1.0,1.0);\n    vec3 GridPatternY = pow(clamp(sin(uv.y*100.0),0.0,1.0),55.0)* abs(pow(clamp(sin(uv.x*100.0),0.0,1.0),1.0)-1.0)*vec3(1.0,1.0,1.0);\n    vec3 GridPattern =  max(vec3(GridPatternX),vec3(GridPatternY))*LineColBase*0.1;   \n        \n      \n\n    \n    //Generate Curve\n        \n    float CurveVal = 0.0;\n    \n    //MODE 0\n    if (DistortionMode == 0)\n    CurveVal = sin(iTime * CurveSpeed + (uv.x * CurveXScale)) * CurveYScale;     \n    //MODE 1\n    if (DistortionMode == 1)\n    CurveVal = sin(iTime * CurveSpeed * (mod (uv.x*Distortion,1.0))  + (uv.x * CurveXScale)) * CurveYScale; \n    //MODE 2\n    if (DistortionMode == 2)    \n    CurveVal = sin(iTime * CurveSpeed  + (uv.x * CurveXScale) * CurveYScale) * (mod (uv.x*Distortion,1.0));\n    //MODE 3\n    if (DistortionMode == 3)\n    CurveVal = sin(iTime * CurveSpeed + (uv.x * CurveXScale)) * CurveYScale + (sin(iTime + (uv.x * CurveXScale*Distortion)) * CurveYScale) * 0.2;\n    //MODE 4\n    if (DistortionMode == 4)\n    CurveVal = sin(iTime * CurveSpeed + ((uv.x+(sin(iTime))*0.3) * CurveXScale)) * CurveYScale + (sin(iTime + (uv.x * CurveXScale*Distortion)) * CurveYScale) * 0.2;\n    //MODE 5\n    if (DistortionMode == 5)\n    CurveVal = sin(iTime * CurveSpeed + (uv.x * CurveXScale * min(uv.x * CurveXScale,abs( uv.x - ScreenScaleAdj))*1.2)) * CurveYScale;  \n    \n    \n    \n     //ScanLineTool\n    float ScanLineXPos = 0.0;\n    float ScanLineYPos = ReaderHeadLocation;\n    if (DistortionMode == 0)\n    ScanLineXPos = (sin(iTime * CurveSpeed + (ScanLineYPos * CurveXScale)) * CurveYScale + 1.0) * 0.5; \n    if (DistortionMode == 1)\n    ScanLineXPos = (sin(iTime * CurveSpeed * (mod (ScanLineYPos*Distortion,1.0))  + (ScanLineYPos * CurveXScale)) * CurveYScale + 1.0) * 0.5;   \n    if (DistortionMode == 2)  \n    ScanLineXPos = (sin(iTime * CurveSpeed  + (ScanLineYPos * CurveXScale) * CurveYScale) * (mod (ScanLineYPos*Distortion,1.0)) + 1.0) * 0.5; \n    if (DistortionMode == 3)\n    ScanLineXPos = (sin(iTime * CurveSpeed + (ScanLineYPos * CurveXScale)) * CurveYScale + (sin(iTime + (ScanLineYPos * CurveXScale*Distortion)) * CurveYScale) * 0.2 + 1.0) * 0.5;\n    if (DistortionMode == 4)\n    ScanLineXPos = (sin(iTime * CurveSpeed + ((ScanLineYPos+(sin(iTime))*0.3) * CurveXScale)) * CurveYScale + (sin(iTime + (ScanLineYPos * CurveXScale*Distortion)) * CurveYScale) * 0.2 + 1.0 ) * 0.5;\n    if (DistortionMode == 5)\n    ScanLineXPos = (sin(iTime * CurveSpeed + (ScanLineYPos * CurveXScale * min(ScanLineYPos * CurveXScale,abs( ScanLineYPos - ScreenScaleAdj))*1.2)) * CurveYScale + 1.0) * 0.5;\n    vec3 ScanLineTool = max(pow(abs(distance(uv.y,ScanLineXPos)-1.0),255.0) , pow(abs(distance(uv.x,ScanLineYPos)-1.0),255.0))*LineColBase;\n    \n    \n    //Circle\n    vec2 CircleOutLocation = vec2(ScanLineYPos,ScanLineXPos);\n    float CircleOut = abs(clamp(pow(distance(vec2(uv.xy) , CircleOutLocation)*28.0,32.0),0.0,1.0)-1.0);\n    float CircleIn = abs(clamp(pow(distance(vec2(uv.xy) , CircleOutLocation)*32.0,32.0),0.0,1.0)-1.0);\n    vec3 ScanCircle = (CircleOut-CircleIn) * LineColBase ;\n    \n    \n    //Move Curve from 1<->-1 to 1<->0\n    float NormCurveVal = (CurveVal + 1.0) * 0.5;\n    \n    \n    \n    if (!UseSmoothVersion){\n    \n   \n    //Color it with LineWidth margin\n    if (NormCurveVal+LineWidth*0.5 > uv.y && NormCurveVal - LineWidth*0.5 < uv.y)\n        LineCol = LineColCurve;   \n    else         \n   \t\tLineCol = vec3(0.0,0.0,0.0);\n        \n        \n    // Output Simple Version to Screen\n\tfragColor = vec4(max(LineCol,(BackGrnd+GridPattern) + ScanLineTool + ScanCircle),1.0);\n    }\n    \n    else\n        \n    {\n    \n    \n    //Move Curve from 1<->-1 to 1<->0\n    float NormCurveVal = (CurveVal + 1.0) * 0.5;\n    \n    vec2 CheckLoc = vec2((uv.x),NormCurveVal);\n    vec2 AntiCurveSmooth = vec2(max(uv-CheckLoc,CheckLoc-uv));\n    AntiCurveSmooth = abs(vec2 (AntiCurveSmooth)-1.0);\n    float AntiCurveSharp =  pow(AntiCurveSmooth.y, LineSharpness);\n    \n    // Output Smooth Version to Screen\n    fragColor = vec4(max(vec3(AntiCurveSharp * LineColCurve),(BackGrnd+GridPattern)),1.0)+vec4(ScanLineTool + ScanCircle,1.0);\n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MldcR4.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 107, 6559]], "test": "untested"}
{"id": "MldcR8", "name": "Voronoi height-map & color-test", "author": "MacSlow", "description": "Variation of https://www.shadertoy.com/view/4ldyR8 with some coloring and a first go at a height-map.", "tags": ["2d", "voronoi"], "likes": 7, "viewed": 446, "published": "Public API", "date": "1531592526", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const vec3 col1 = vec3 (6./255., 23./255., 102./255.);\nconst vec3 col3 = vec3 (76./255., 12./255., 130./255.);\nconst vec3 col5 = vec3 (194./255., 1./255., 101./255.);\nconst vec3 col7 = vec3 (217./255., 59./255., 10./255.);\nconst vec3 col9 = vec3 (255./255., 156./255., .0/255.);\nconst vec3 col2 = mix (col1, col3, .5);\nconst vec3 col4 = mix (col3, col5, .5);\nconst vec3 col6 = mix (col5, col7, .5);\nconst vec3 col8 = mix (col7, col9, .5);\nconst vec3 colA = mix (col9, col1, .5);\n\nvec3 gradient (float v) {\n    float steps = 10.;\n    float step = 1. / steps;\n    vec3 col = vec3 (.4);\n\n    if (v >= .0 && v < step) {\n        col = mix (col1, col2, v * steps);\n    } else if (v >= step && v < 2.0 * step) {\n        col = mix (col2, col3, (v - step) * steps);\n    } else if (v >= 2.0 * step && v < 3.0 * step) {\n        col = mix (col3, col4, (v - 2.0 * step) * steps);\n    } else if (v >= 3.0 * step && v < 4.0 * step) {\n        col = mix (col4, col5, (v - 3.0 * step) * steps);\n    } else if (v >= 4.0 * step && v < 5.0 * step) {\n        col = mix (col5, col6, (v - 4.0 * step) * steps);\n    } else if (v >= 5.0 * step && v < 6.0 * step) {\n        col = mix (col6, col7, (v - 5.0 * step) * steps);\n    } else if (v >= 6.0 * step && v < 7.0 * step) {\n        col = mix (col7, col8, (v - 6.0 * step) * steps);\n    } else if (v >= 7.0 * step && v < 8.0 * step) {\n        col = mix (col8, col9, (v - 7.0 * step) * steps);\n    } else if (v >= 8.0 * step && v < 9.0 * step) {\n        col = mix (col9, colA, (v - 8.0 * step) * steps);\n    }\n\n    return col;\n}\n\nvec2 noise2d (in vec2 p)\n{\n\tvec3 v = fract (p.xyx*vec3(123.34, 234.34, 345.65));\n\tv += dot (v, v + 34.45);\n\treturn fract (vec2 (v.x*v.y, v.y*v.z));\n}\n\nmat2 r2d (in float degree)\n{\n\tfloat rad = radians (degree);\n    float c = cos (rad);\n    float s = sin (rad);\n    return mat2 (c, s, -s, c);\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n\tfloat time = iTime + 5.;\n\n    // normalize and aspect-correct UVs\n    vec2 uv = fragCoord/iResolution.xy*2. - 1.;\n    vec2 uvRaw = uv;\n\tfloat aspect = iResolution.x/iResolution.y;\n    uv.x *= aspect;\n\n    // rotate and move the canvas\n    uv *= r2d (24.*time);\n    uv += vec2 (.2*cos (time), .3*sin(time));\n\n    // cause the canvas to 'zoom'\n    float scale = 6. + 3.*(.5 + .5*cos(time));\n    uv *= scale;\n    float rowSize = scale *.5;\n\n    // split canvas up\n    vec2 gv = fract (uv) - .5;\n    vec2 id = floor (uv);\n\n    float cellIndex = .0; \n    float minDist = 2.;\n\n    // check only the adjacent grid-cells\n    for (float y = -1.; y <= 1.; ++y) {\n        for (float x = -1.; x <= 1.; ++x) {\n            vec2 offset = vec2 (x, y); \n            vec2 n = noise2d (id + offset);\n            vec2 p = offset + .5*vec2 (cos (3.*sin(.005*time)*n.x*(time + 22.75)), sin (2.*cos(.007*time)*n.y*(time + 22.75)));\n            float d = dot (gv - p, gv - p);\n            if (d < minDist) {\n                minDist = d;\n                cellIndex = (id.y + y) * rowSize + (id.x + x); \n            }\n        }\n    }   \n\n    // 'color' cells in different styles\n    float brightColor = (1. - minDist)*(1. - minDist);\n    float darkColor = minDist*minDist;\n    float flatColor = abs (cellIndex) / (scale*scale);\n    float invertedFlatColor = 1. - flatColor;\n\n    // blend between the four different style-variations\n    float colorOne = mix (brightColor, darkColor, .25);\n    vec3 colorTwo;\n\n    if (uvRaw.x < sin (iTime + 6.25)) {\n        colorTwo = mix (gradient (flatColor), vec3 (invertedFlatColor), .035);\n    } else {\n        colorTwo = mix (vec3 (flatColor), vec3 (invertedFlatColor), .035);\n    }\n\n    vec3 colorFinal = mix (vec3 (colorOne), vec3 (colorTwo), .9);\n\n    // gamma-correct\n    colorFinal = pow (colorFinal, vec3 (1./2.2));\n\n    fragColor = vec4 (colorFinal, 1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MldcR8.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[480, 480, 505, 505, 1551], [1553, 1553, 1579, 1579, 1702], [1704, 1704, 1732, 1732, 1846], [1848, 1848, 1904, 1904, 3780]], "test": "untested"}
{"id": "MldczM", "name": "Bi-Triangular B-Spline patch", "author": "ollj", "description": "my offline version has a working iMouse inoput, but it did not translate at all into the shadertoy.com canvas.\nhere the camera is a bad port, needs a better camera matrix with mouse input.\n\nstill works as demo.", "tags": ["triangle", "bezier", "quadratic", "surface", "analytic", "patch"], "likes": 4, "viewed": 665, "published": "Public API", "date": "1532085866", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//#define iGlobalTime iTime\n\n#define ViewZoom 2.\n#define fra(u)(u-.5*iResolution.xy)*ViewZoom/iResolution.y\n\n\n//self  : https://www.shadertoy.com/view/MldczM\n//parent: https://www.shadertoy.com/view/XsjSDt\n\n//original shader not by ollj\n//this is just a slightly improved variant, with more bounding volume visualization.\n//ollj tried to improve precision\n//, but this root solver case is trickier in its barycentric symmetry than mirror axes of an ellipse\n\n//there is a great trick to this one, uvw projection of space, to wrap this around a sphere:\n//this also works with tracing, right? you can trace an orbit in piecewise segments, right?\n//this would scale by a frustrum, should be doable.\n//and it vould work on the ficonacciSphereinverse() function, right?\n\n//oh the potential of this shader...\n\n//you need to start with 3 rotations,that set the surface notmals at 3 points\n//from that you calculate the intersection point heights and interpolate with a bezier patch.\n//i am not sure if this makes 2 adjacent patches continuoous or haaave a corner.\n//pretty suure it will have a corner.\n//i should be able to force a corner,to show that i can make a corner.\n//but i cant think of a way now.\n//yeah i need to double this one up!\n\n//okay i get it now,\n//to make it seamless,for every coener,all 3-pairs of nearby coplanar CVS must also be colinear.\n//otherwise you have a corner.\n//this reduces my math to a simple \"mirror a midpoints height on the corner-points height\" solution for seamless patching.\n//oh wait,this seems to be a cascading problem.\n//yeah,and the solution against that is 3 2d rotations,which means,there may not be a solution.\n\n\n//curve 3d bezier quadratic triangle patch\n//this does not return the distance to the shape,\n//  It traces a ray intersection!\n//\n// [Ray-intersection for uni-variate quadratic Bezier triangle]\n// 3 one-dimensional(quadratic)-bezier-splines make a triangular patch\n// ,from 6 CVs(3 on corners,3 on midpoints.)\n//\n// [Uni-variate] because the spline is interpolating(6 CV)scalar values\n// ,interpreted as the [height] of the spline at that location.  \n//\n// [Quadratic] because the basis functions are quadratic Bernstein-polynomials\n// basis functions are intrinsically 2D and quadratic,unlike rectangular Bezier forms.\n// This is then root-solved analytically\n// ,but it uses branching to get the smallest positive root(simpler slower gpou code)\n//\n// [Bezier triangle] because simplex(triangle,tetrahedra,etc)lend \n// themselves to ray-intersection more easily than rectangular Bezier forms. \n// Because(when trying to solve non-axis-aligned ray-intersection)\n// the basis functions in the rectangular case are combinations of \n// 1D basis functions that multiply out into higher powers.\n// Simplex-forms avoided by using intrinsically 2D basis functions.\n//\n//  -John Kloetzli,Jr\n//  @JJcoolkl\n// crunched by @Ollj\n\n#define H_FOV_RADIANS 0.785\n\n#define v0 float\n#define v1 vec2\n#define v2 vec3\n#define v3 vec4\n#define u2(a)(a*2.-1.)\n#define u5(a)(a*.5+.5)\n#define dd(a)dot(a,a)\n//perpendicular dot()used for line intersections.\n#define dotp(a,b)dot(vec2(-a.y,a.x),b)\nv0 suv(vec2 a){return a.x+a.y;}\nv0 miv(v1 a){return min(a.y,a.x);}\nv0 miv(v2 a){return min(a.z,miv(a.xy));}\nv0 miv(v3 a){return min(miv(a.zw),miv(a.xy));}//return min domain of vector.\n#define mav(a)-miv(-a)\n#define sat(a)clamp(a,0.,1.)\nvec4 minx(vec4 a,vec4 b){return mix(b,a,step(a.x,b.x));}//return the vec4 with the smaller .x\n\nconst vec2 p1=vec2(0,4),p2=vec2(-4,-4),p3=vec2(4,-4);//corners.xy of a triangle\nconst float f200=2.,f020=2.,f002=2.,f011=-2.,f101=-2.,f110=-2.;//6 Control points,named by index\nfloat suv(vec3 a){return a.x+a.y+a.z;}\nvec3 BezierTriangle_Quadratic_Normal(const vec3 u,const vec3 a,const vec3 b//get normal(2nd derivative)of quadradicBezier triangularPatch\n){return normalize(cross(vec3(p1-p2,suv(u*vec3(a.x-b.z,b.z-a.y,b.y-b.x))),vec3(p1-p3,suv(u*vec3(a.x-b.y,b.z-b.x,b.y-a.z)))));}\nfloat det2d(vec2 a,vec2 b){return a.x*b.y-a.y*b.x;}//2d determinant(mat2(a,b))==perpendicular dotproduct\n//Cartesian to barycentric(relative to spline verts)\nvec3 CartToBary(vec2 c){c-=p1;vec2 a=p2-p1,b=p3-p1,d=vec2(dot(c,b),dot(c,a));\n ;vec3 r=vec3(dd(a),dd(b),dot(a,b));r=vec3(0.,det2d(r.yz,d),det2d(r.xz,d.yx))/det2d(r.yz,r.zx);return vec3(1.-r.y-r.z,r.yz);}\n//Intersect 2d line segment with 2d bezier,set by 2 first derivatives,placed at vec2(0)and vvec2(1,0)\nvec2 LineISect(vec2 a,vec2 b,vec2 u,vec2 d  //rayOrigin,RayTarget\n){b=vec2(b.y-a.y,a.x-b.x);a.x=dot(b,a);d=vec2(d.y-u.y,u.x-d.x);u=vec2(dot(d,u),det2d(b,d))\n ;if(u.y==0.)return vec2(0);b*=u.x;d*=a.x;return vec2(d.y-b.y,b.x-d.x)/u.y;}\n\n//by @JJcoolkl ,crunched by ollj\n//analytical intersection of ray [u,d]=[origin,direction] and quadratic-bezier triangular-patch(6 CV-heights [a,b]=[cornerHeights,MidpointHeights])\nvec3 cd=vec3(0);//debug color vector is very optional\nvec4 BezierTriISect(const vec3 u,const vec3 d,vec3 c1,vec3 c0\n){float mi=min(miv(c1),miv(c0))\n ;vec2 L=u.xy+d.xy,a=LineISect(p1,p2,u.xy,L),b=LineISect(p2,p3,u.xy,L),c=LineISect(p3,p1,u.xy,L)\n ;vec4 q=vec4(-1,-1,1,1)*1./(iResolution.x+2.)//a tiny epsilon is necessary to account for precision loss.\n ,g=vec4(min(p1.x,p2.x),min(p1.y,p2.y),max(p1.x,p2.x),max(p1.y,p2.y))+q\n ,h=vec4(min(p2.x,p3.x),min(p2.y,p3.y),max(p2.x,p3.x),max(p2.y,p3.y))+q\n ,o=vec4(min(p3.x,p1.x),min(p3.y,p1.y),max(p3.x,p1.x),max(p3.y,p1.y))+q\n #define altm(a,b)any(lessThan(vec4(a,b.zw),vec4(b.xy,a)))\n ;bool bA=altm(a.xy,g),bB=altm(b.xy,h);vec3 f,e=(vec3(a.x,b.x,c.x)-u.x)/d.x\n ;if(!(bA||bB)){cd+=vec3(.7,0,0)\n  ;f=u+d*miv(e.xy);e=u-d*miv(-e.xy);//intersection with 1/3 sides of a \"triangle prism\"(we hit it only from the inside)\n ;}else{bool bC=altm(c.xy,o)//restructured,1/4 cases skips the calculation of cB\n  ;if(!(bB||bC)){f=u+d*miv(e.yz);e=u-d*miv(-e.yz);cd+=vec3(0,.7,0)//intersection with 1/3 sides of a \"triangle prism\"\n  ;}else if(!(bA||bC)){f=u+d*miv(e.zx);e=u-d*miv(-e.zx);cd+=vec3(0,0,.7)//intersection with 1/3 sides of a \"triangle prism\"\n  ;}else return vec4(0,0,0,2);}//no intersection with the tirngle prism!\n ;vec3 S=CartToBary(f.xy)\n ;vec3 E=CartToBary(e.xy)-S//Plug in eye ray and solve variables for root finding.\n ;o.xyz=vec3(2.*(dot(E*E,c1)+2.*dot(vec3(E.y*E.z,E.x*E.z,E.x*E.y),c0))\n    ,f.z-e.z+2.*(dot(E*S,c1)+dot(vec3(dot(E.yz,S.zy),dot(E.xz,S.zx),(E.x*S.y+E.y*S.x)),c0))//i smell a cross()\n    ,dot(S*S,c1)+2.*dot(vec3(S.y*S.z,S.x*S.z,S.x*S.y),c0)-f.z)\n ;o.z=o.y*o.y-2.*o.x*o.z;\n ;if(o.z>=0.){a=(vec2(1.,-1.)*sqrt(o.z)-o.y)/o.x;\n  ;if(abs(a.x-.5)<=.5//;if(a.x>=0.&&a.x<=1.\n ){if(a.y>=0.)a.x=miv(a);cd+=vec3(.3,.3,0);return vec4(S+a.x*E,a.x);}\n  ;if(abs(a.y-.5)<=.5){cd+=vec3(0,.3,.3);return vec4(S+a.y*E,a.y)//;if(a.y>=0.&&a.y<=1.)\n ;}};cd+=vec3(.3,0,.3);return vec4(0,0,0,2);}//all intersections are behind the camera\nvec4 ComputeBezierColor(vec3 u,vec3 d,vec3 a,vec3 b//get color based on bezier tri intersection + lighting\n){vec4 v4ISect=BezierTriISect(u,d,a,b)//analytical intersection of ray [u,d] and triangular quadratic-bezier patch(6 CV-heights [a,b])\n ;vec3 hotPos=normalize(vec3(.7)),hot=vec3(1.,.5,.3),cold=vec3(.3,.4,.8),c=vec3(0);float A=0.\n ;if(v4ISect.w<=1.\n){vec3 n=BezierTriangle_Quadratic_Normal(v4ISect.xyz,a,b)//analytical first derivative\n  ;c=hot *max(0.,dot(n,hotPos))+cold*max(0.,dot(n,-hotPos))+.2*vec3(.5)\n  ;A=1.;}return vec4(c,A);}\nfloat sp(vec3 u,vec3 d,vec4 s//draw CV as transparent spheres,with simple projection;radius scaled by distance to camera. //cameraPos,Sphere\n){u-=s.xyz;float a=dot(d,u);u.x=length(u);s.w+=.0001;u.y=s.w*s.w;return sat(mix(0.,1.,(a*a-(u.x*u.x)+u.y)/(u.y-s.w*s.w)));}\nfloat ComputeOverlay(vec3 u,vec3 d,vec3 a,vec3 b){return sp(u,d,vec4(p1,a.x,.2))+sp(u,d,vec4((p1+p2)*.5,b.z,.2))\n +sp(u,d,vec4(p2,a.y,.2))+sp(u,d,vec4((p3+p1)*.5,b.y,.2))+sp(u,d,vec4(p3,a.z,.2))+sp(u,d,vec4((p2+p3)*.5,b.x,.2));}\nvec3 GetCameraPos(//mouse.xy moves camera\n){vec2 v2Mouse=vec2(0);return normalize(vec3(sin(iTime*.1),cos(iTime*.1),-1.))*10.;}\nvec3 GetLookDir(vec3 u,vec2 fragCoord \n){float fScale=tan(H_FOV_RADIANS),r=iResolution.x/iResolution.y\n ;vec2 v2Screen=(2.*(fragCoord.xy/iResolution.xy)-1.)*vec2(r,1.)*fScale\n ;vec3 l=normalize(-u),e=cross(vec3(0,0,1),l)\n ;return normalize(l+e*v2Screen.x+cross(l,e)*v2Screen.y);}\n \nvoid mainImage(out vec4 o,vec2 u \n){vec3 v=GetCameraPos()\n ;vec3 d=GetLookDir(v,u)//next 2 vec3 set the heoights of 6 cv.\n ;vec3 a=vec3(f200*sin(iTime),f020*sin(iTime*1.2),f002*sin(iTime)*.9)//set 3 corrner CV-heights\n ;vec3 b=vec3(f011*sin(iTime*2.0),f101*sin(iTime*1.1),f110*sin(iTime))//set 3 midpoint CV-heights\n ;vec4 c=ComputeBezierColor(v,d,a,b)\n ;c=mix(vec4(.5,.5,.5,1.),c,c.a)//lazy alpha compositioning\n ;c.xyz=mix(c.xyz,cd,.2)//debug color coding\n ;o=mix(c,vec4(.7,.7,.7,1),ComputeOverlay(v,d,a,b));}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MldczM.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[3035, 3124, 3139, 3139, 3155], [3156, 3156, 3169, 3169, 3190], [3191, 3191, 3204, 3204, 3231], [3232, 3232, 3245, 3245, 3278], [3278, 3361, 3386, 3386, 3417], [3509, 3633, 3651, 3651, 3671], [3672, 3672, 3812, 3812, 3936], [3937, 3937, 3964, 3964, 3988], [3988, 4095, 4119, 4119, 4298], [4299, 4401, 4469, 4469, 4634], [4636, 4871, 4935, 4935, 6747], [6747, 6789, 6898, 6898, 7330], [7331, 7331, 7474, 7474, 7595], [7596, 7596, 7646, 7646, 7824], [7825, 7825, 7869, 7869, 7951], [7952, 7952, 7993, 7993, 8231], [8234, 8234, 8270, 8270, 8745]], "test": "untested"}
{"id": "MldyDN", "name": "Grid Lines Recreation", "author": "lherm", "description": "Wanted to see if I could recreate something like https://twitter.com/mattdesl/status/1022870984905424899 but with GLSL. It's not perfect, but was fun messing around with the code.", "tags": ["2d", "2tweets", "reproduction"], "likes": 4, "viewed": 444, "published": "Public API", "date": "1532753666", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Thanks Fabrice :)\nvoid mainImage(out vec4 o,vec2 g){\n    vec2 R = iResolution.xy,\n         p = (g+g-R)/R.y,\n         u = fract(p*4.)- .5;\n    u = abs( u * mat2(cos( ceil(p.x*4.)/4. + iTime/2. + vec4(0,33,11,0))) );\n    p = abs(p);\n    o += p.x < 1.2 && p.y < .7 ? smoothstep(16./R.y,0.,.1-max(u.x-.001, u.y-.2)) : 1.;}\n\n/*\n#define mainImage(o, g) \\\n\tvec2 p = (2.*g-(o.xy=iResolution.xy))/o.y, q = floor(p*4.), u = fract(p*4.)- .5; \\\n        o.z = q.x*.25 + iTime*.5; \\\n        u = abs(u * cos(o.z) + sin(o.z) * vec2(-u.y, u.x)) - vec2(.001, .2);\\\n        p = abs(p); \\\n\t\to = p.x < 1.2 && p.y < .7 ? 1.-vec4(step(max(u.x, u.y), .1)) : vec4(1.) \\\n*/\n\n/*\n\n#define mainImage(o, g) \\\n\tvec2 p = (2.*g-(o.xy=iResolution.xy))/o.y, q = floor(p*4.), u = fract(p*4.)- .5; \\\n        o.z = q.x*.25 + iTime*.5; \\\n        u = u * cos(o.z) + sin(o.z) * vec2(-u.y, u.x);\\\n\t\tu = abs(u) - vec2(.001, .2); \\\n        p = abs(p); \\\n\t\to = p.x < 1.2 && p.y < .7 ? 1.-vec4(step(max(u.x, u.y), .1)) : vec4(1.); \\\n*/\n  \n/*\n#define r(p, a) {p = p * cos(a) + sin(a) * vec2(-p.y, p.x);}\n#define mainImage(o, g) \\\n\tvec2 p = (2.*g-(o.xy=iResolution.xy))/o.y, q = floor(p*4.), u = fract(p*4.)- .5; \\\n        r(u, q.x*.25 + iTime*.5); \\\n\t\tu = abs(u) - vec2(.001, .2); \\\n        p = abs(p); \\\n\t\to = p.x < 1.2 && p.y < .7 ? 1.-vec4(step(max(u.x, u.y), .1)) : vec4(1.); \\\n\n*/\n            \n/*\nvoid mainImage( out vec4 o, in vec2 g )\n{\n    vec2 p = (2.*g-(g=iResolution.xy))/g.y, q = floor(p*4.), u = fract(p*4.)- .5;\n    u *= r(q.x*.25 + iTime*.5); // rotate by cell Id\n    \n    // rect\n    u = abs(u) - vec2(.001, .2);\n    o = vec4(step(max(u.x, u.y), .1));\n    \n    // border\n    p = abs(p) - vec2(1.1, .6);\n    o *= step(max(p.x, p.y), .1);\n    o = 1.-o;\n}*/", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MldyDN.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 21, 55, 55, 321]], "test": "untested"}
{"id": "MltcDM", "name": "give it to dalao", "author": "tilendlesa", "description": "hh", "tags": ["no"], "likes": 1, "viewed": 288, "published": "Public API", "date": "1532930982", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//============================================================================\n// PROJECT ID: <your Project ID is an integer equal to 62 + group_no.>\n//\n// GROUP NUMBER:\n//\n// STUDENT NAME: \n// NUS User ID.: \n//\n// STUDENT NAME: \n// NUS User ID.: \n//\n// STUDENT NAME: \n// NUS User ID.: \n//\n// COMMENTS TO GRADER: \n//\n//============================================================================\n\n\n// FRAGMENT SHADER FOR SHADERTOY\n// Run this at https://www.shadertoy.com/new\n// See documentation at https://www.shadertoy.com/howto\n\n// Your browser must support WebGL 2.0.\n// Check your browser at http://webglreport.com/?v=2\n\n\n//============================================================================\n// Constants.\n//============================================================================\nconst int NUM_LIGHTS = 2;\nconst int NUM_MATERIALS = 5;\nconst int NUM_PLANES = 5;\nconst int NUM_SPHERES = 10;\n\nconst vec3 BACKGROUND_COLOR = vec3( 0.1, 0.2, 0.6 );\n\n // Vertical field-of-view angle of camera. In radians.\nconst float FOVY = 50.0 * 3.1415926535 / 180.0; \n\n// Use this for avoiding the \"epsilon problem\" or the shadow acne problem.\nconst float DEFAULT_TMIN = 10.0e-4;\n\n// Use this for tmax for non-shadow ray intersection test.\nconst float DEFAULT_TMAX = 10.0e6;\n\n// Equivalent to number of recursion levels (0 means ray-casting only).\n// We are using iterations to replace recursions.\nconst int NUM_ITERATIONS = 3;\n\n\n//============================================================================\n// Define new struct types.\n//============================================================================\nstruct Ray_t {\n    vec3 o;  // Ray Origin.\n    vec3 d;  // Ray Direction. A unit vector.\n};\n\nstruct Plane_t {\n    // The plane equation is Ax + By + Cz + D = 0.\n    float A, B, C, D;\n    int materialID;\n};\n\nstruct Sphere_t {\n    vec3 center;\n    float radius;\n    int materialID;\n};\n\nstruct Light_t {\n    vec3 position;  // Point light 3D position.\n    vec3 I_a;       // For Ambient.\n    vec3 I_source;  // For Diffuse and Specular.\n};\n\nstruct Material_t {\n    vec3 k_a;   // Ambient coefficient.\n    vec3 k_d;   // Diffuse coefficient.\n    vec3 k_r;   // Reflected specular coefficient.\n    vec3 k_rg;  // Global reflection coefficient.\n    float n;    // The specular reflection exponent. Ranges from 0.0 to 128.0. \n};\n\n//----------------------------------------------------------------------------\n// The lighting model used here is similar to that on Slides 8 and 12 of \n// Lecture 11 (Ray Tracing). Here it is computed as\n//\n//     I_local = SUM_OVER_ALL_LIGHTS { \n//                   I_a * k_a + \n//                   k_shadow * I_source * [ k_d * (N.L) + k_r * (R.V)^n ]\n//               }\n// and\n//     I = I_local  +  k_rg * I_reflected\n//----------------------------------------------------------------------------\n\n\n//============================================================================\n// Global scene data.\n//============================================================================\nPlane_t Plane[NUM_PLANES];\nSphere_t Sphere[NUM_SPHERES];\nLight_t Light[NUM_LIGHTS];\nMaterial_t Material[NUM_MATERIALS];\nfloat pi=180.0*FOVY/50.0;\n\n\n/////////////////////////////////////////////////////////////////////////////\n// Initializes the scene.\n/////////////////////////////////////////////////////////////////////////////\n\nvoid  period(float T,out float time)\n{\n\tif(mod(iTime,T)<T/2.0)\ttime = mod(iTime,T);\n\telse\ttime = T-mod(iTime,T);\n}\nvoid InitScene()\n{\n\t\n\n    // Horizontal plane.\n    Plane[0].A = 0.0;\n    Plane[0].B = 1.0;\n    Plane[0].C = 0.0;\n    Plane[0].D = 0.0;\n    Plane[0].materialID = 4;\n\n     //Vertical plane.\n    Plane[1].A = 0.0;\n    Plane[1].B = 0.0;\n    Plane[1].C = 1.0;\n    Plane[1].D = 3.5;\n    Plane[1].materialID = 0;\n\n\tPlane[2].A = 0.0;\n    Plane[2].B = 0.0;\n    Plane[2].C = -1.0;\n    Plane[2].D = 3.5;\n\tPlane[3].materialID = 0;\n    \n\tPlane[3].A = 1.0;\n    Plane[3].B = 0.0;\n    Plane[3].C = 0.0;\n    Plane[3].D = 3.5;\n\tPlane[4].materialID = 0;\n  \n\tPlane[4].A = -1.0;\n    Plane[4].B = 0.0;\n\tPlane[4].C = 0.0;\n    Plane[4].D = 3.5;\n    Plane[4].materialID = 0;\n\n\tfloat time;\n\tfloat T = 1.5;\n\tperiod(T,time);\n\ttime = time +0.26;\n    // Center bouncing sphere.\n    Sphere[0].center = vec3( 0.0,2.0+time*1.5*cos(iTime),time*1.5*sin(iTime)); //运动轨迹\n    Sphere[0].radius = 0.2;   //球大小\n    Sphere[0].materialID = 1;\n\n\tSphere[1].center = vec3( 0.0,2.0+time*1.5*cos(iTime+1.0*60.0*3.14/180.0),time*1.5*sin(iTime+1.0*60.0*3.14/180.0)); //运动轨迹\n    Sphere[1].radius = 0.2;   //球大小\n    Sphere[1].materialID = 1;\n\n\tSphere[2].center = vec3( 0.0,2.0+time*1.5*cos(iTime+2.0*60.0*3.14/180.0),time*1.5*sin(iTime+2.0*60.0*3.14/180.0)); //运动轨迹\n    Sphere[2].radius = 0.2;   //球大小\n    Sphere[2].materialID = 1;\n\n\tSphere[3].center = vec3( 0.0,2.0+time*1.5*cos(iTime+3.0*60.0*3.14/180.0),time*1.5*sin(iTime+3.0*60.0*3.14/180.0)); //运动轨迹\n    Sphere[3].radius = 0.2;   //球大小\n    Sphere[3].materialID = 1;\n\n\tSphere[4].center = vec3( 0.0,2.0+time*1.5*cos(iTime+4.0*60.0*3.14/180.0),time*1.5*sin(iTime+4.0*60.0*3.14/180.0)); //运动轨迹\n    Sphere[4].radius = 0.2;   //球大小\n    Sphere[4].materialID = 1;\n\n\tSphere[5].center = vec3( 0.0,2.0+time*1.5*cos(iTime+5.0*60.0*3.14/180.0),time*1.5*sin(iTime+5.0*60.0*3.14/180.0)); //运动轨迹\n    Sphere[5].radius = 0.2;   //球大小\n    Sphere[5].materialID = 1;\n\t\n\n    // Circling sphere.\n//    Sphere[6].center = vec3(1.75+1.55*sin(1.5*iTime), 2.5,  0);//Z上下 X左右\n//    Sphere[6].radius = 0.2;\n//    Sphere[6].materialID = 2;\n//\n//\tSphere[7].center = vec3(-1.75-1.55*sin(1.5*iTime) , 2.5,  0 );\n//    Sphere[7].radius = 0.2;\n//    Sphere[7].materialID = 2;\n//\n//\tSphere[8].center = vec3(1.75-1.55*sin(1.5*iTime) , 1.5,  0 );\n//    Sphere[8].radius = 0.2;\n//    Sphere[8].materialID = 3;\n//\n//\tSphere[9].center = vec3(-1.75+1.55*sin(1.5*iTime) , 1.5,  0 );\n//    Sphere[9].radius = 0.2;\n//    Sphere[9].materialID = 3;\n//\n\n\n    // Silver material.\n\t\n    Material[0].k_d = vec3(0.5,0.5,0.5);\n    Material[0].k_a = 0.2 * Material[0].k_d;\n    Material[0].k_r = 2.0 * Material[0].k_d;\n    Material[0].k_rg = 0.5 * Material[0].k_r;\n    Material[0].n = 64.0;\n\n    // Gold material.\n    Material[1].k_d = vec3( 1.0, 1.0, 1.0);\n    Material[1].k_a = 0.2 * Material[1].k_d;\n    Material[1].k_r = 2.0 * Material[1].k_d;\n    Material[1].k_rg = 0.5 * Material[1].k_r;\n    Material[1].n = 64.0;\n\n\n    // Green plastic material.\n    Material[2].k_d = vec3( 0.2, sin(3.0*iTime), 0.2 );\n    Material[2].k_a = 0.2 * Material[2].k_d;\n    Material[2].k_r = vec3( 1.0, 1.0, 1.0 );\n    Material[2].k_rg = 0.5 * Material[2].k_r;\n    Material[2].n = 128.0;\n\n\tMaterial[3].k_d = vec3( sin(3.0*iTime), 0.2, 0.2 );\n    Material[3].k_a = 0.2 * Material[3].k_d;\n    Material[3].k_r = vec3( 1.0, 1.0, 1.0 );\n    Material[3].k_rg = 0.5 * Material[3].k_r;\n    Material[3].n = 128.0;\n\n\tvec2 uv = vec2(0.0,0.0);\n\tMaterial[4].k_d = 0.2*(0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4)));\n    Material[4].k_a = 0.2 * Material[4].k_d;\n    Material[4].k_r = 2.0 * Material[4].k_d;\n    Material[4].k_rg = 0.5 * Material[4].k_r;\n    Material[4].n = 64.0;\n\n    // Light 0.\n    Light[0].position = vec3( 3.0, 8.0, -3.0);\n    Light[0].I_a = vec3( 0.1, 0.1, 0.1 );\n    Light[0].I_source = vec3( 1.0, 1.0, 1.0 );\n\n    // Light 1.\n    Light[1].position = vec3( -3.0, 8.0, 3.0);\n    Light[1].I_a = vec3( 0.1, 0.1, 0.1 );\n    Light[1].I_source = vec3( 1.0, 1.0, 1.0 );\n}\n\n\n\n/////////////////////////////////////////////////////////////////////////////\n// Computes intersection between a plane and a ray.\n// Returns true if there is an intersection where the ray parameter t is\n// between tmin and tmax, otherwise returns false.\n// If there is such an intersection, outputs the value of t, the position\n// of the intersection (hitPos) and the normal vector at the intersection \n// (hitNormal).\n//计算平面和光线之间的交叉点。\n//如果有一个交点，其中光线参数t介于tmin和tmax之间，则返回true，否则返回false。\n//如果有这样的交集，则输出交叉点（hitPos）的交叉点（hitPos）和交叉点的正常向量（hitNormal）的值。\n/////////////////////////////////////////////////////////////////////////////\nbool IntersectPlane( in Plane_t pln, in Ray_t ray, in float tmin, in float tmax,\n                     out float t, out vec3 hitPos, out vec3 hitNormal ) \n{\n    vec3 N = vec3( pln.A, pln.B, pln.C );\n    float NRd = dot( N, ray.d );\n    float NRo = dot( N, ray.o );\n    float t0 = (-pln.D - NRo) / NRd;\n    if ( t0 < tmin || t0 > tmax ) return false;\n\n    // We have a hit -- output results.\n    t = t0;\n    hitPos = ray.o + t0 * ray.d;\n    hitNormal = normalize( N );\n    return true;\n}\n\n\n\n/////////////////////////////////////////////////////////////////////////////\n// Computes intersection between a plane and a ray.\n// Returns true if there is an intersection where the ray parameter t is\n// between tmin and tmax, otherwise returns false.\n//计算平面和光线之间的交叉点。\n//如果有一个交叉点，其中ray参数t介于tmin和tmax之间，则返回true，否则返回false。\n/////////////////////////////////////////////////////////////////////////////\nbool IntersectPlane( in Plane_t pln, in Ray_t ray, in float tmin, in float tmax )\n{\n    vec3 N = vec3( pln.A, pln.B, pln.C );\n    float NRd = dot( N, ray.d );\n    float NRo = dot( N, ray.o );\n    float t0 = (-pln.D - NRo) / NRd;\n    if ( t0 < tmin || t0 > tmax ) return false;\n    return true;\n}\n\n\n\n/////////////////////////////////////////////////////////////////////////////\n// Computes intersection between a sphere and a ray.\n// Returns true if there is an intersection where the ray parameter t is\n// between tmin and tmax, otherwise returns false.\n// If there is one or two such intersections, outputs the value of the \n// smaller t, the position of the intersection (hitPos) and the normal \n// vector at the intersection (hitNormal).\n//计算球体和射线之间的交集。\n//如果有一个交叉点，其中ray参数t介于tmin和tmax之间，则返回true，否则返回false。\n//如果有一个或两个这样的交点，则输出较小的t的值，交点的位置（hitPos）和交点处的法线向量（hitNormal）。\n/////////////////////////////////////////////////////////////////////////////\nbool IntersectSphere( in Sphere_t sph, in Ray_t ray, in float tmin, in float tmax,\n                      out float t, out vec3 hitPos, out vec3 hitNormal ) \n{\n    /////////////////////////////////\n    // TASK: WRITE YOUR CODE HERE. //\n\tray.o -= sph.center;\n\tfloat t0;\n\tfloat a = dot(ray.d,ray.d);\n\tfloat b = 2.0 * dot(ray.d,ray.o);\n\tfloat c = dot(ray.o,ray.o)-sph.radius*sph.radius;\n\tfloat d = b*b - 4.0*a*c;\n\tif(d<0.0)\treturn false;\n\telse if (d == 0.0)\tt0 =(-b)/(2.0*a);\n\telse \n\t{\n\t\tfloat t1 = (-b+sqrt(d))/(2.0*a);\n\t\tfloat t2 = (-b-sqrt(d))/(2.0*a);\n\t\tif(t2>0.0) t0 =t2;\n\t\telse t0 = t1;\n\t}\n\tif ( t0 < tmin || t0 > tmax ) return false;\n\tt = t0;\n    hitPos = ray.o + t0 * ray.d+ sph.center;\n    hitNormal = normalize(hitPos-sph.center);\n    /////////////////////////////////\n    return true;  // Replace this with your code.\n\n}\n\n\n\n/////////////////////////////////////////////////////////////////////////////\n// Computes intersection between a sphere and a ray.\n// Returns true if there is an intersection where the ray parameter t is\n// between tmin and tmax, otherwise returns false.\n/////////////////////////////////////////////////////////////////////////////\nbool IntersectSphere( in Sphere_t sph, in Ray_t ray, in float tmin, in float tmax )\n{\n    /////////////////////////////////\n    // TASK: WRITE YOUR CODE HERE. //\n\tray.o -= sph.center;\n\tfloat t0;\n\tfloat a = dot(ray.d,ray.d);\n\tfloat b = 2.0 * dot(ray.d,ray.o);\n\tfloat c = dot(ray.o,ray.o)-sph.radius*sph.radius;\n\tfloat d = b*b - 4.0*a*c;\n\tif(d<0.0)\treturn false;\n\telse if (d == 0.0)\tt0 =(-b)/(2.0*a);\n\telse \n\t{\n\t\tfloat t1 = (-b+sqrt(d))/(2.0*a);\n\t\tfloat t2 = (-b-sqrt(d))/(2.0*a);\n\t\tif(t2>0.0) t0 =t2;\n\t\telse t0 = t1;\n\t}\n\tif ( t0 < tmin || t0 > tmax ) return false;\n    /////////////////////////////////\n    return true;  // Replace this with your code.\n\n}\n\n\n/////////////////////////////////////////////////////////////////////////////\n// Computes (I_a * k_a) + k_shadow * I_source * [ k_d * (N.L) + k_r * (R.V)^n ].\n// Input vectors L, N and V are pointing AWAY from surface point.\n// Assume all vectors L, N and V are unit vectors.\n//输入矢量L，N和V从表面指向AWAY。\n//假设所有向量L，N和V都是单位向量。\n/////////////////////////////////////////////////////////////////////////////\nvec3 PhongLighting( in vec3 L, in vec3 N, in vec3 V, in bool inShadow, \n                    in Material_t mat, in Light_t light )\n{\n    if ( inShadow ) {\n        return light.I_a * mat.k_a;\n    }\n    else {\n        vec3 R = reflect( -L, N );\n        float N_dot_L = max( 0.0, dot( N, L ) );\n        float R_dot_V = max( 0.0, dot( R, V ) );\n        float R_dot_V_pow_n = ( R_dot_V == 0.0 )? 0.0 : pow( R_dot_V, mat.n );\n\n        return light.I_a * mat.k_a + \n               light.I_source * (mat.k_d * N_dot_L + mat.k_r * R_dot_V_pow_n);\n    }\n}\n\n\n/////////////////////////////////////////////////////////////////////////////\n// Casts a ray into the scene and returns color computed at the nearest\n// intersection point. The color is the sum of light from all light sources,\n// each computed using Phong Lighting Model, with consideration of\n// whether the interesection point is being shadowed from the light.\n// If there is no interesection, returns the background color, and outputs\n// hasHit as false.\n// If there is intersection, returns the computed color, and outputs\n// hasHit as true, the 3D position of the intersection (hitPos), the\n// normal vector at the intersection (hitNormal), and the k_rg value\n// of the material of the intersected object.\n//将光线投射到场景中并返回在最近交点处计算的颜色。\n//颜色是来自所有光源的光的总和，每个光源使用Phong照明模型计算，并考虑是否从光线遮蔽了截面点。\n//如果没有interesection，则返回背景颜色，并输出hasHit为false。\n//如果有交点，则返回计算的颜色，并输出hasHit为true，交点的3D位置（hitPos），\n//交点处的法线向量（hitNormal）以及相交对象的材质的k_rg值。\n/////////////////////////////////////////////////////////////////////////////\nvec3 CastRay( in Ray_t ray, \n              out bool hasHit, out vec3 hitPos, out vec3 hitNormal, out vec3 k_rg ) \n{\n    // Find whether and where the ray hits some object. \n    // Take the nearest hit point.\n\n    bool hasHitSomething = false;\n    float nearest_t = DEFAULT_TMAX;   // The ray parameter t at the nearest hit point.\n    vec3 nearest_hitPos;              // 3D position of the nearest hit point.\n    vec3 nearest_hitNormal;           // Normal vector at the nearest hit point.\n    int nearest_hitMatID;             // MaterialID of the object at the nearest hit point.\n\n    float temp_t;\n    vec3 temp_hitPos;\n    vec3 temp_hitNormal;\n    bool temp_hasHit;\n\n    /////////////////////////////////////////////////////////////////////////////\n    // TASK:\n    // * Try interesecting input ray with all the planes and spheres,\n    //   and record the front-most (nearest) interesection.\n    // * If there is interesection, need to record hasHitSomething,\n    //   nearest_t, nearest_hitPos, nearest_hitNormal, nearest_hitMatID.\n\t//尝试将输入光线与所有平面和球体相互交叉，并记录最前面（最近）的截面。\n\t//如果有intersection，需要记录hasHitSomething，nearest_t，nearest_hitPos，nearest_hitNormal，nearest_hitMatID。\n    /////////////////////////////////////////////////////////////////////////////\n\n    /////////////////////////////////\n    // TASK: WRITE YOUR CODE HERE. //\n\t//hasHitSomething = IntersectPlane(Plane[NUM_PLANES],ray,DEFAULT_TMIN,DEFAULT_TMAX) && IntersectSphere( Sphere[NUM_SPHERES],ray, DEFAULT_TMIN,DEFAULT_TMAX);\n\tfor(int i=0;i<NUM_PLANES;i++)\n\t{\n\t\tif( IntersectPlane( Plane[i],ray,DEFAULT_TMIN,DEFAULT_TMAX, temp_t, temp_hitPos, temp_hitNormal ))\n\t\t{\n\t\t\tif(nearest_t>temp_t)\n\t\t\t{\n\t\t\t\tnearest_t = temp_t;\n\t\t\t\tnearest_hitPos = temp_hitPos;\n\t\t\t\tnearest_hitNormal = temp_hitNormal;\n\t\t\t\tnearest_hitMatID = Plane[i].materialID;\n\t\t\t}\n\t\t\thasHitSomething = true;\n\t\t}\n\t}\n\tfor(int i=0;i<NUM_SPHERES;i++)\n\t{\n\t\tif(IntersectSphere( Sphere[i],ray, DEFAULT_TMIN,DEFAULT_TMAX,  temp_t,temp_hitPos,temp_hitNormal))\n\t\t{\n\t\t\tif(nearest_t>temp_t)\n\t\t\t{\n\t\t\t\tnearest_t = temp_t;\n\t\t\t\tnearest_hitPos = temp_hitPos;\n\t\t\t\tnearest_hitNormal = temp_hitNormal;\n\t\t\t\tnearest_hitMatID = Sphere[i].materialID;\n\t\t\t}\n\t\t\thasHitSomething = true;\n\t\t}\n\t}\n    /////////////////////////////////\n\n\n\n    // One of the output results.\n    hasHit = hasHitSomething;\n    if ( !hasHitSomething ) return BACKGROUND_COLOR;\n\n    vec3 I_local = vec3( 0.0 );  // Result color will be accumulated here.\n\n    /////////////////////////////////////////////////////////////////////////////\n    // TASK:\n    // * Accumulate lighting from each light source on the nearest hit point. \n    //   They are all accumulated into I_local.\n    // * For each light source, make a shadow ray, and check if the shadow ray\n    //   intersects any of the objects (the planes and spheres) between the \n    //   nearest hit point and the light source.\n    // * Then, call PhongLighting() to compute lighting for this light source.\n\t//在最近的生命点上累积每个光源的光照。\n\t//它们都积累在I_local中。\n\t//对于每个光源，制作阴影射线，并检查阴影射线是否会影响最近的生命点和\n\t//光源之间的任何物体（平面和球体）。然后，调用PhongLighting（）来计算此光源的光照。\n    /////////////////////////////////////////////////////////////////////////////\n\n    /////////////////////////////////\n    // TASK: WRITE YOUR CODE HERE. //\n\tbool inShadow[NUM_LIGHTS];\n\tRay_t ShadowRay[NUM_LIGHTS];\n\tfor(int i=0;i<NUM_LIGHTS;i++)\n\t{\n\t\t\tinShadow[i] = false;\n\t\t\tShadowRay[i].o = nearest_hitPos; \n\t\t\tShadowRay[i].d = normalize(Light[i].position-nearest_hitPos);\n\t\tfor(int j=0;j<NUM_PLANES;j++)\n\t\t{\n\t\t\tif( IntersectPlane( Plane[j],ShadowRay[i],DEFAULT_TMIN,length(Light[i].position - nearest_hitPos)))\n\t\t\t\tinShadow[i] = true;\n\t\t}\n\t\tfor(int j=0;j<NUM_SPHERES;j++)\n\t\t{\n\t\t\tif(IntersectSphere( Sphere[j],ShadowRay[i], DEFAULT_TMIN,length(Light[i].position - nearest_hitPos)))\n\t\t\t{\n\t\t\t\tinShadow[i] = true;\n\t\t\t}\n\t\t}\n\t}\n\tvec3 N =  nearest_hitNormal;\n\tvec3 V =  normalize(-ray.d);\n\tfor(int i=0;i<NUM_LIGHTS;i++)\n\t{\n\tvec3 L=\tShadowRay[i].d;\n\tI_local += PhongLighting(L,N,V, inShadow[i], Material[nearest_hitMatID], Light[i]);\n\t}\n    /////////////////////////////////\n    // Populate output results.\n    hitPos = nearest_hitPos;\n    hitNormal = nearest_hitNormal;\n    k_rg = Material[nearest_hitMatID].k_rg;\n\n    return I_local;\n}\n\n\n\n/////////////////////////////////////////////////////////////////////////////\n// Execution of fragment shader starts here.\n// 1. Initializes the scene.\n// 2. Compute a primary ray for the current pixel (fragment).\n// 3. Trace ray into the scene with NUM_ITERATIONS recursion levels.\n/////////////////////////////////////////////////////////////////////////////\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    InitScene();\n\n    // Scale pixel 2D position such that its y coordinate is in [-1.0, 1.0].\n    vec2 pixel_pos = (2.0 * fragCoord.xy - iResolution.xy) / iResolution.y;\n\n    // Position the camera.\n    vec3 cam_pos = vec3( 2.0* cos(iTime), 2.5,2.0*sin(iTime));//相机位置\n    vec3 cam_lookat = vec3(0.0, 2.0, 0.0 ); //镜头摇晃\n    vec3 cam_up_vec = vec3( 0.0, 1.0, 0.0 );\n\n    // Set up camera coordinate frame in world space.\n    vec3 cam_z_axis = normalize( cam_pos - cam_lookat );\n    vec3 cam_x_axis = normalize( cross(cam_up_vec, cam_z_axis) );\n    vec3 cam_y_axis = normalize( cross(cam_z_axis, cam_x_axis));\n\n    // Create primary ray.\n    float pixel_pos_z = -1.0 / tan(FOVY / 2.0);\n    Ray_t pRay;\n    pRay.o = cam_pos;\n    pRay.d = normalize( pixel_pos.x * cam_x_axis  +  pixel_pos.y * cam_y_axis  +  pixel_pos_z * cam_z_axis );\n\n\n    // Start Ray Tracing.\n    // Use iterations to emulate the recursion.\n\n    vec3 I_result = vec3( 0.0 );\n    vec3 compounded_k_rg = vec3( 1.0 );\n    Ray_t nextRay = pRay;\n\n    for ( int level = 0; level <= NUM_ITERATIONS; level++ ) \n    {\n        bool hasHit;\n        vec3 hitPos, hitNormal, k_rg;\n\n        vec3 I_local = CastRay( nextRay, hasHit, hitPos, hitNormal, k_rg );\n\n        I_result += compounded_k_rg * I_local;\n\n        if ( !hasHit ) break;\n\n        compounded_k_rg *= k_rg;\n\n        nextRay = Ray_t( hitPos, normalize( reflect(nextRay.d, hitNormal) ) );\n    }\n\n    fragColor = vec4( I_result, 1.0 );\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MltcDM.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[3174, 3357, 3395, 3395, 3471], [3472, 3472, 3490, 3518, 7463], [7467, 8252, 8407, 8407, 8737], [8741, 9226, 9309, 9309, 9521], [9525, 10340, 10498, 10574, 11167], [11171, 11504, 11589, 11665, 12158], [12161, 12612, 12743, 12743, 13156], [13159, 14428, 14543, 14635, 18904], [18908, 19269, 19326, 19326, 20795]], "test": "untested"}
{"id": "MltcDn", "name": "Tiled Eye", "author": "momoro", "description": "Messing around with tiling patterns from book of shaders", "tags": ["blackandwhite"], "likes": 4, "viewed": 365, "published": "Public API", "date": "1532290053", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float box(vec2 st, float size, float s) {\n    float c;\n    //st = st * 2. - 1.;\n    c = length(max(abs(st)-size, 0.));\n    c = smoothstep(.01+s, .01, c);\n    return c;\n}\n\nmat2 rotate2d(float angle) {\n\treturn mat2(cos(angle), -sin(angle),\n               \tsin(angle), cos(angle));\n}\n\nmat2 scale(float amount) {\n    return mat2(amount, 0.,\n               0., amount);\n}\n\nvec2 tile(vec2 st, float count) {\n\tst *= count;\n    \n    float oddOrEven = floor(mod(st.y, 2.));\n    st.x += count/2.*step(oddOrEven, 0.5);;\n    // I want it to be odd / even\n    // So I want to look at whether mod mod(2 == 0\n    st = fract(st);\n\n    return st;\n}\n\nfloat ring(vec2 st, float r, float w, float s) {\n    float f = 0.;\n\n    float l = length(st);\n    float inner = smoothstep(r, r+s, l);\n    float outer = smoothstep(r+w, r+w+s, l);\n    \n\tf = outer - inner;\n    \n    return f;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 st = fragCoord.xy/iResolution.y;\n\n    float u_time = iTime;\n    vec3 color = vec3(0.);\n   \n    st -= vec2(.5);\n    st.x -= .4;\n    vec2 uv = st;\n    \n    st*= 2.;\n   \n    float radius = 0.340 * sin(u_time)/2.+(sin(u_time)/3. + 0.212);\n    float width = 0.104 * cos(u_time)/2.+-0.148;\n    float softness = -0.228 * cos(u_time)/2.+.6;\n    st *= vec2(scale(1.368) * ring(st, radius, width, softness)+sin(u_time/3.)/3.).x;\n\t\n    st *= rotate2d(sin(u_time/10.) + length(st) * .5);\n\n    st *= 5. * sin(u_time/6.) + 10.;\n    st = tile(st, 3.);\n    \n\tvec2 boxTransform;\n    \n\n    \n    \n     boxTransform = scale(0.87) * rotate2d(.25 * 3.14) *  (st*2.-1.) ;\n    color += box(boxTransform,0.296, 0.042);\n    \n\n\n\n    \n    fragColor = vec4(color,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MltcDn.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 41, 41, 169], [171, 171, 199, 199, 280], [282, 282, 308, 308, 366], [368, 368, 401, 401, 631], [633, 633, 681, 681, 858], [861, 861, 918, 918, 1669]], "test": "untested"}
{"id": "MltcR7", "name": "voronoi metric mixing", "author": "ollj", "description": "a voronoi of 3 different distances,, within tiled voronoi.\nit always mixes 2 of 3 different distances, the mix parameter loops and changes over screenspace.x\n//there is a disabled line that adds iMouse.xy control to the screenspace mixing parameter.", "tags": ["voronoi", "mix", "triangle", "water", "taxicap"], "likes": 4, "viewed": 663, "published": "Public API", "date": "1532088281", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n//self: https://www.shadertoy.com/view/MltcR7\n\n//sign 2d voronoi different distance metrics\n//parent https://www.shadertoy.com/view/MdSGRc\n\n// Created by inigo quilez-iq/2014\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\nfloat hash1(float n){ return fract(sin(n)*43758.5453);}\nvec2  hash2(vec2  p){ p=vec2(dot(p,vec2(127.1,311.7)),dot(p,vec2(269.5,183.3)));return fract(sin(p)*43758.5453);}\n\n\n\nvec4 voronoi(vec2 x,float mode\n){vec2 n=floor(x)\n ;vec2 f=fract(x)\n ;vec3 m=vec3(8.)\n ;float m2=8.\n ;for(int j=-2;j<=2;j++)for(int i=-2;i<=2;i++\n ){vec2 g=vec2(float(i),float(j))\n  ;vec2 o=hash2(n+g)\n  ;// animate\n  //;o=0.5 + 0.5*sin(iTime + 6.2831*o);\n  ;o=.5+.5*sin(iTime+x.x*2.+x.y*1.61+6.2831*o)\n  ;vec2 r=g-f+o\n  ;vec2 d0=vec2(sqrt(dot(r,r)),1.0)//euclidean (sqrt() is theoretically most complex here, but can be approximated very quickly)\n  ;vec2 d1=vec2(0.71*(abs(r.x)+ abs(r.y)),1.0)// manhattam \n  ;//vec2 d1=vec2(0.71*abs(r.x-r.y),1.0)//manhattan no diagonals\n  ;vec2 d2=vec2(0)// triangular (placeholder)\n  ;vec2 d=d0\n  //below code ALWAYS mixes 2 of 3:\n  ;if(mode<3.0)d=mix(d1,d0,fract(mode))\n  ;if(mode<2.0\n  ){d2=vec2(max(abs(r.x)*0.866025+r.y*0.5,-r.y),step(0.0,0.5*abs(r.x)+0.866025*r.y)*(1.0+step(0.0,r.x)))// triangular\n   ;d=mix(d2,d1,fract(mode))\n   ;if(mode<1.0)d=mix(d0,d2,fract(mode));}//loop around\n  ;if(d.x<m.x){m2=m.x;m.x=d.x;m.y=hash1(dot(n+g,vec2(7,113)));m.z=d.y\n ;}else if(d.x<m2)m2=d.x;}return vec4(m,m2-m.x);}\n\nvoid mainImage(out vec4 fragColor,vec2 u\n){\n ;float d=length(u-iMouse.xy)*3.\n ;d=u.x*3.\n //;d=0.\n ;d/=iResolution.x\n ;float mode=mod(d-iTime*.1,3.)\n ;mode=floor(mode)+smoothstep(0.8,1.0,fract(mode))\n ;vec2 p=u.xy/iResolution.xx\n ;vec4 c=voronoi(8.0*p,mode)\n ;vec3 col=0.5 + 0.5*sin(c.y*2.5 + vec3(1.0,1.0,1.9))\n ;col*=sqrt(clamp(1.0-c.x,0.0,1.0))\n ;col*=clamp(0.5 +(1.0-c.z/2.0)*0.5,0.0,1.0)\n ;col*=0.4 + 0.6*sqrt(clamp(4.0*c.w,0.0,1.0))\n ;fragColor=vec4(col,1.0);}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MltcR7.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[141, 264, 285, 285, 319], [320, 320, 341, 341, 433], [437, 437, 470, 470, 1480], [1482, 1482, 1525, 1525, 1947]], "test": "untested"}
{"id": "MltcRN", "name": "Flower RAVE", "author": "rohtie", "description": "It's a fun party!", "tags": ["rave"], "likes": 4, "viewed": 133, "published": "Public", "date": "1531875277", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define time iTime\n#define resolution iResolution\n#define channel0 iChannel0\n\nfloat caps(vec2 p, vec2 a, vec2 b, float r) {\n    vec2 pa = p-a;\n    vec2 ba = b-a;\n    float h = clamp(dot(pa,ba)/dot(ba,ba), 0., 1.);\n    return length(pa - ba*h) - r;\n}\n\nfloat rmin(float a, float b, float r) {\n    vec2 rarb = vec2(r-a,r-b);\n    vec2 u = max(rarb, vec2(0.));\n    return max(r, min(a,b)) - length(u);\n}\n\nvec4 pixel(vec2 p) {\n    p /= resolution.xy;\n    p -= .5;\n    p.x *= resolution.x / resolution.y;\n\n    vec2 q = p;\n    \n    float a = atan(p.x, p.y);\n    float r = sqrt(dot(p, p));\n    \n    p.x += time * 0.2;\n\t\n    float rep = 0.8;\n    float px = floor(p.x / rep);\n    p.y -= mod(px, 1.5) * 0.15;\n    p.x = mod(p.x, rep);\n    p.x -= rep * 0.5;\n    \n    p.y += sin(time * 6. + acos(-1.) * 0.5) * 0.055;\n\n    float zoid_radius = 0.01;\n\n    float radius = 0.15 + mod(px, 3.) * 0.015;\n    radius += cos(atan(p.x, p.y) * (5. + mod(px, 5.)) + time * mod(px, 5.) + px) * 0.05;\n    radius += sin(atan(p.x, p.y) * 10. + time * 8. - px) * 0.01;\n\n    radius = mix(radius, texture(channel0, vec2(radius, 0.0)).r, 0.1);\n    \n    \n    float circle = length(p) - radius;\n    circle = max(circle, -max(p.y + sin(time) * 0.005, length(p) - 0.075 - sin(time * 4. + px) * 0.005));\n    circle = max(circle, -(length(vec2(abs(p.x), p.y) - vec2(0.05, 0.01)) - 0.025 - sin(time * 4. + px + 0.15) * 0.005));\n    circle = 1. - smoothstep(0., 0.03, circle);\n\n    float circle_shadow = length(p * 2.) - radius;\n    circle_shadow = 1. - smoothstep(0., 0.6, circle_shadow);\n\n    vec2 offset = vec2(sin(time + px), cos(time + px)) * (zoid_radius * 10. + radius);\n\n    float zoid = length(p - offset) - zoid_radius;\n    zoid = 1. - smoothstep(0., 0.01, zoid);\n\n    vec2 center = vec2(0., -0.1);\n    float body = caps(p, center, vec2(0., -2.), 0.025);\n\n\n    center.y -= 0.1;\n\n    vec2 elbow = center + vec2(sin(1.5 + sin(time * 2. + px)), cos(1.5 + sin(time * 2. + px))) * 0.2;\n    body = rmin(body, caps(vec2(abs(p.x), p.y), center, elbow, 0.015), 0.055);\n\n    vec2 hand = elbow + vec2(sin(0.5 + sin(time * 3.5) * 0.15), cos(0.5 + sin(time * 3.5) * 0.15)) * 0.15;\n    body = rmin(body, caps(vec2(abs(p.x), p.y), elbow, hand, 0.015), 0.02);\n    body = rmin(body, caps(vec2(abs(p.x), p.y), vec2(0., -0.7), vec2(0., -1.5), 0.25), 0.05);\n\n    body = min(body, length(p) - 0.1);\n    \n    body = smoothstep(0., 0.005, body);\n\n    p = q;\n    \n    return (\n        vec4(circle * circle_shadow + zoid) +\n        vec4(circle_shadow * 0.5, circle_shadow * 0.5, 0., 0.) +\n        vec4(p.y + length(p * 0.9) + sin(time * 2.) * 0.25 + tan(time * 8. + 0.25), 0.15 + length(p * 0.4), 0.1 + length(p * 2.5) * 0.4 + sin(time * 0.2 + 2.) + tan(time * 8.), 0.) * (1. - circle) * body * p.y * 20.\n    );\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    fragColor = pixel(fragCoord);\n}", "image_inputs": [{"id": "Xd2XRd", "previewfilepath": "https://soundcloud.com/capsadmin/bill", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0, "src": "https://soundcloud.com/capsadmin/bill", "ctype": "musicstream"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MltcRN.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[78, 78, 123, 123, 249], [251, 251, 290, 290, 398], [400, 400, 420, 420, 2753], [2756, 2756, 2813, 2813, 2849]], "test": "untested"}
{"id": "MltczM", "name": "skewing intersecting portals", "author": "ollj", "description": "barely improved variant of its parent", "tags": ["portals", "skew"], "likes": 2, "viewed": 347, "published": "Public API", "date": "1532084905", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//self : https://www.shadertoy.com/view/MltczM\n\n\n//sign 3d portals rotating doubly linked shadows B\n//parent self  : https://www.shadertoy.com/view/Mt2czK\n//parent: https://www.shadertoy.com/view/XtjcRV\n\n//use buffers,here only for \"space\" keyboard input.\n#define doBuffer\n#define KEY_SPACE (vec2(32.5,.5)/256.)\n\n//ichannel0 is for keyboard input\n//,while space,move camera to center fror hall of pirrots position.\n\n//max view distance.(loses its meaning where portals make space noneuclidean)\n#define maxdist 100.\n//iterations trough space between portals\n#define iterRm 200.\n//iterations trough portals(max number of portals trough portals)\n#define iterTp 20\n\n//ollj made all 3 epsilons smaller by *=.1\n//this,fits the small scale of the set better.\n//this also required more [iterRm]\n//epsilon raymarch\n#define epsRm .001\n//epsilon for normal,derivative\n#define epsDx .001\n//epsilon shadows\n#define epsShad .01\n\n//simple lazy fov;1=parallel projection ;0=180deg;\n#define fov .5\n\n//Do intro where the camera drops down,+1exp()to camera movement.\n//#define doCameraDrop\n\n#define portalThickness (cos(iTime)*.1+.1)\n\n//glossyness\n#define scalePhong .2\n\n//background color,sky color or microwave background(scatter max)\n#define cCMB vec4(.3,.5,1,1)\n\n#define lightdir normalize(vec3(-1,1,.5))\n#define lightintensity 1.5\n#define dark vec3(.2,.4,.4)\n#define floorheight -1.5\n\n/*\ni stretched portal scale to test the coonstrains of:\n-more obvious portal scaling distortion \n--portals are still lipschitz continuous,just not classically euclidean.\n-portals intersecting each other\n-one portal intersecting a solid(the floor)\n-hit space and have the camera be inside the object with the portal on it.\n--camera close to portal should tepeport the camera RAYS instantly.\n--even though the camera is static,only its rays are not.\n\ntodo\n,needs quaternion rotation\n,and all the stuff you can extend portals with\n,including a movable camera that gets teleported.\n*/\n\n//material g-buffer enum\n#define background 0.\n#define mPortal1 1.\n#define mPortal2 2.\n#define mFrame 3.\n#define mFloor 4.\n#define mGeometry 5.\n\n#define pi0 6.28318530718\n#define pi  acos(-1.)\n#define pi2 acos(0.)\n\n\nfloat suv(vec2 a){return a.x+a.y;}\nfloat suv(vec3 a){return dot(a,vec3(1));}//dot()can be faster than 2add.\nfloat mav(vec2 a){return max(a.x,a.y);}\nfloat mav(vec3 a){return max(max(a.x,a.y),a.z);}\n\n//dir and up should be a vec4 quaternion instead!\n//not just for performance,but aslso to avoid gimbal locking\nstruct PortalFrame{\n vec3 c;\n vec3 dir;\n vec3 up;\n vec2 dims;\n}p1,p2;//i am not a fan of global structs here.\n//but portals\n//,that make space noneuclidean are a reasonable exception for nor\n\nfloat boxsdf(vec3 u,vec3 e,out vec3 o){\n e*=.5;o=u/mav(e);return mav(vec3(abs(u)-e));}\n\nfloat cylindersdf(vec3 u,float r,float h,out vec3 o){\n o=u/max(r,h);return max(length(u.xz)-r,max(-u.y,u.y-h));}\n\nvec2 portalsdf(vec3 u,PortalFrame p,out vec3 a){\n vec3 r=u-p.c;\n vec3 w=normalize(cross(p.dir,p.up));\n vec3 v=cross(w,p.dir);\n //above dual crossproduct rotation is slower than quaternion rotation.\n //but for small angles,this is the fallback of quaternion rotation anyways.\n a=vec3(dot(r,w),dot(r,v),dot(r,p.dir));\n p.dims=p.dims/2.;\n float d=mav(vec3(abs(a.z)-portalThickness*.5,abs(a.xy)-p.dims.xy-portalThickness));\n // float y=all(lessThan(abs(a.xy),p.dims.xy))?portalmat1:mFrame;\n return vec2(d,all(lessThan(abs(a.xy),p.dims.xy))?mPortal1:mFrame);}\n\n//if(distance is smaller than previous)also write textureID\nvoid bgw(inout vec2 d,inout vec3 p,vec3 q,float h,float m){\n if(h<d.x){d=vec2(h,m);p=q;}}\nvoid bgw(inout vec2 d,inout vec3 p,vec3 q,float h){\n bgw(d,p,q,h,mGeometry);}//bgw==buffer-g-write ==write objectID.\n\n//p* and q* are \"portal target bijectuive-switcheroo coordinates.\n//distance field gradient\nvec2 dg(vec3 u,out vec3 p){\n vec3 q1,q2;//potals are structs that will tell you their \"exit coordinates\"\n vec2 d,d1=portalsdf(u,p1,q1),d2=portalsdf(u,p2,q2);\n if(d1.x<d2.x){d=d1;p=q1;\n }else    {p=q2;d=vec2(d2.x,d2.y<2.5?mPortal2:mFrame);}\n bgw(d,p,u,max(u.y-floorheight,length(u.xz)-10.),mFloor);//floor\n bgw(d,p,u,length(u-vec3(2,0,0))-.8);//sphere,radius of 8\n bgw(d,p,u,cylindersdf(u-vec3(-0.3,-1.5,0.),0.1,1.5,q1));//cylinder\n bgw(d,p,u,boxsdf(u-vec3(0,-.5,-3),vec3(.4,1.7,.4),q1));//box\n bgw(d,p,u,boxsdf(u-vec3(0,-1,3),vec3(5.,.5,.9),q1));//box\n return d;}//.y is a materialID g-buffer\n\n//sphere tracking,raymarching,linear gradient descent\n//i guess for portals you need it to be this explicit\nvec2 gd(vec3 u,vec3 t,out vec3 o){\n float a=0.;//accumulated distance traveled\n vec2 g=dg(u,o);//gradient at u,save travel sphere.\n for(float i=.0;i<iterRm;i++){\n  a+=g.x;\n  g=dg(u+a*t,o);\n  if(abs(g.x)<epsRm){return vec2(a,g.y);//hit a surface\n  }else if(g.x>maxdist)break;//too far from camera\n }return vec2(maxdist,background);}//not hit anything\n//having o store the position along the ray is infficient.\n//it accumulates more precision loss than it gains.\n\nvec3 normal(vec3 u){vec3 c;vec2 e=vec2(epsDx,0);return normalize(vec3\n(dg(u+e.xyy,c).x-dg(u-e.xyy,c).x\n,dg(u+e.yxy,c).x-dg(u-e.yxy,c).x\n,dg(u+e.yyx,c).x-dg(u-e.yyx,c).x));}\n\nvec2 shaderay(vec3 u,vec3 t,float h){//origin,dirction,hardness\n vec3 c,n=normal(u);\n vec2 ds=gd(u+epsShad*lightdir,lightdir,c);\n float l=max(0.,dot(n,lightdir))*lightintensity;//lambert\n l*=sign(.5-ds.y)*.5+.5;//l=ds.y<.5?l:0.;\n float p=pow(max(0.,dot(normalize(lightdir-t),n)),h);//phong\n return vec2(l,p*scalePhong);}\n\n\n//for abstraction and development\n//,texturing patterns are their own functions\nvec3 portalBorderColor(vec3 c){c=step(mod(c,.5),vec3(.25));\n return mix(vec3(.2),vec3(.2,.7,.6),abs(abs(\n #if 0\n  c.x+c.y)+c.z));}//pattern ollj\n #else\n  c.x-c.y)-c.z));}//pattern original\n #endif\n//return checkerboard pattern of point c\nvec3 yellowObjects(vec3 c){c=step(mod(c,.5),vec3(.25));return mix//pattern scaling\n(vec3(1.,.7,.2)//sun-yellow(scatter low)\n,vec3(.4,.8,.4)//leaf-green(scatter medium)\n,abs(abs(c.x-c.z)-c.y));}//3d checkerboard pattern\nvec3 ground(vec3 c){c=step(mod(c,1.),vec3(.25));return mix\n(vec3(.6)\n,vec3(.7)\n//,abs(c.x-c.z));}//2d ground pattern original\n,abs(c.x)-c.z);}//2d ground pattern ollj\n\n//teleport th point trough a portal\nvec4 tp(inout vec3 e,inout vec3 t,inout vec3 c,vec4 o,inout PortalFrame p1,inout PortalFrame p2){\n   vec3 u=normalize(cross(p1.dir,p1.up));\n   vec3 v=cross(u,p1.dir);\n   float x=dot(t,u),y=dot(t,v),z=dot(t,p1.dir);\n   u=normalize(cross(p2.dir,p2.up));\n   v=cross(u,p2.dir);\n   vec2 s=p2.dims/p1.dims;//portal scaling\n   t=normalize(x*u*s.x \n     +y*v*s.y\n     +z*p2.dir);//teleport ray direction\n //above and below doesnt simplify,because u and v are vec3,.\n   e=p2.c\n +c.x*u*s.x \n +c.y*v*s.y \n -c.z*p2.dir \n +2.*epsRm*t;//teleport camera position\n return o;}//debug error output color\n//for [max portal levels] or for [disabled portal entrance]\n//given that this calculates the differential between 2 rotations\n//,tp() begs for quaternions.\n\n#define sc(a)vec2(sin(a),cos(a))\n\nvoid mainImage(out vec4 o,in vec2 fragCoord){o=vec4(1);\n #ifdef doBuffer\n  float s=.5;//texture(iChannel0,KEY_SPACE).r;\n #else\n  float s=0.;\n #endif\n          \n vec2 aa=sc(clamp(iMouse.y/iResolution.y-.5,-.15,1.)*pi2);\n vec2 cph=sc((iMouse.x/iResolution.x-.35)*pi0)*aa.y;\n vec3 e=(.01+5.*(1.-s))*vec3(cph.x,aa.x\n    #ifdef doCameraDrop\n  +2.*exp(-iTime)\n    #endif\n    ,cph.y);//camera rotation\n vec3 w=normalize(-e);\n e+=vec3(-.3,.05,0);//eye position,relevant for \"distance to eye\"\n vec3 u=normalize(cross(w,vec3(0,1,0)));\n vec3 v=cross(u,w);\n vec3 t=normalize(fov*w\n     +(fragCoord.x/iResolution.x-.5)*u\n      +(fragCoord.y/iResolution.x-.5*iResolution.y/iResolution.x)*v);\n //I have seen worse [camera to ray] functions.\n       \n float ts=(sin(iTime*.2)+1.)*pi;\n p1=PortalFrame(vec3(0)//center\n      ,normalize(vec3(1,.1*cos(iTime*2.)*sin(ts),.0))//forward\n      ,vec3(0,1,.2*sin(iTime*2.)*cos(ts))//up\n      ,vec2(2,3.+cos(ts*.5)));//scale\n p2=PortalFrame(vec3(-1.5,0,0)//center\n      ,vec3(sc(ts),0).yzx//forward\n      ,vec3(0,1,0)//up\n      ,vec2(3,2));//scale\n //above swivels the parameters of 2 \"portals\"\n // That would mbe much simpler with a quaternion. \n            \n for(int i=0;i<iterTp;i++){\n  vec3 c;//stores position along ray\n  vec2 d=gd(e,t,c);\n  if(d.y<.5){o=cCMB;break;//cBackground\n  }else if(d.y<1.5){o=tp(e,t,c,vec4(.2,.8,1,1),p1,p2);//cPortal1\n  //break;//disable cyan-blue portal entrance\n }else if(d.y<2.5){o=tp(e,t,c,vec4(.8,.2,1,1),p2,p1);//cPortal2   \n  //break;//disable magenta-pink portal entrance \n }else if(d.y<3.5){//cPortalBorder\n  float s=shaderay(e+d.x*t,t,1.).x;\n  o.xyz=max(dark.b,s)*portalBorderColor(c);\n  break;//hit surface\n }else if(d.y<4.5){//floor\n   vec2 s=shaderay(e+d.x*t,t,10.);\n   o=vec4(max(dark.b,s.x)*ground(c)+s.y,1);\n   break;//hit surface\n  }else{//yellow checkered objects    \n  vec2 s=shaderay(e+d.x*t,t,5.4);\n   o.xyz=max(dark.b,s.x)*yellowObjects(c)+s.y;\n  }\n }}\n ", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MltczM.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1953, 2169, 2187, 2187, 2203], [2204, 2204, 2222, 2222, 2245], [2245, 2277, 2295, 2295, 2316], [2317, 2317, 2335, 2335, 2365], [2547, 2670, 2709, 2709, 2756], [2758, 2758, 2811, 2811, 2870], [2872, 2872, 2920, 2920, 3426], [3428, 3488, 3547, 3547, 3577], [3578, 3578, 3629, 3629, 3655], [3696, 3788, 3815, 3815, 4351], [4382, 4490, 4524, 4524, 4821], [4821, 4952, 4972, 4972, 5124], [5126, 5126, 5163, 5189, 5446], [5449, 5529, 5560, 5560, 5659], [5726, 5767, 5794, 5794, 5960], [5960, 5986, 6006, 6006, 6128], [6154, 6190, 6287, 6287, 6749], [6749, 6967, 7012, 7012, 8894]], "test": "untested"}
{"id": "MltyR8", "name": "Smooth iteration count", "author": "darkeclipz", "description": "Currently trying to implement a smooth iteration count (http://iquilezles.org/www/articles/mset_smooth/mset_smooth.htm).", "tags": ["fractal"], "likes": 5, "viewed": 635, "published": "Public", "date": "1531577535", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// resources:\n// - http://iquilezles.org/www/articles/mset_smooth/mset_smooth.htm\n// - http://colorpalettes.net/color-palette-3885/\n\n// Color palettes\nstruct palette {\n    vec3 c0, c1, c2, c3, c4;\n};\n\npalette palette1() {\n    palette p;\n    p.c0 = vec3(0);\n    p.c1 = vec3(190,220,227)/255.;\n    p.c2 = vec3(243,243,246)/255.;\n    p.c3 = vec3(227,220,213)/255.;\n    p.c4 = vec3(218,112, 21)/255.;\n    return p;\n}\n\npalette palette2() {\n    palette p; p.c0 = vec3(0,2,5)/255.;\n    p.c1 = vec3(8,45,58)/255.;\n    p.c2 = vec3(38,116,145)/255.;\n    p.c3 = vec3(167,184,181)/255.;\n    p.c4 = vec3(207,197,188)/255.;\n    return p;    \n}\n\n// Complex math\n\nvec2 cpow ( vec2 z ) { return mat2(z, -z.y, z.x) * z; }\n//vec2 cmul( vec2 z1, vec2 z2 ) { return vec2( z1.x*z2.x -z1.y*z2.y, 2.*z1.x*z1.y ); } + z2.x*z2.y :/\n//vec2 cmul( vec2 z1, vec2 z2 ) { return mat2(z2, -z2.y, z2.x) * z1; }\nvec2 cmul( vec2 z1, vec2 z2 ) { return mat2(z1, -z1.y, z1.x) * z2; }\n\n/* missed one iter\nvec2 cpown (vec2 z, int n) {\n    mat2 m = mat2(z, -z.y, z.x);\n    for(int i=0; i<n;++i) \n    \tz *= m;\n   \treturn z;\n}*/\nvec2 cpown (vec2 z, int n) {\n    mat2 m = mat2(z, -z.y, z.x);\n    for(;--n>0;) z *= m;\n   \treturn z;\n}\n\nfloat cmod( vec2 z ) {\n\t//return ri.x * ri.x + ri.y * ri.y;    \n    return dot(z,z);\n}\n\n// Mapping\n\n#define ZOOM\nvec2 map ( vec2 uv ) {\n    #ifdef ZOOM\n    return 1./exp(mod(iTime/2.,80.))*uv;\n    #else\n\treturn 2.*uv;\n    #endif\n}\n\nvec3 cmap( float t, palette p ) {\n    //t=fract(t);\n    vec3 col = vec3(0);\n    col = mix( p.c0,  p.c1, smoothstep(0. , .2, t));\n    col = mix( col, p.c2, smoothstep(.2, .4 , t));\n    col = mix( col, p.c3, smoothstep(.4 , .6, t));\n    col = mix( col, p.c4, smoothstep(.6,  .8, t));\n    col = mix( col, vec3(0), smoothstep(.8, 1.,  t));\n    return col;\n}\n\n\n// Polynomials\n\nvec2 fMandelbrot( vec2 z, vec2 c) { return cpow(z) + c; }\nvec2 fCPoly1 ( vec2 z, vec2 c ) { return cpown(z,11) + cmul((vec2(1.,0.)-c),cpown(z,5)) + cmul((c+1.+vec2(0,1)),z) + c; }\nvec2 fCPoly2 ( vec2 z, vec2 c ) { return cpown(z,5) + cmul((vec2(1.,0.)-c),cpown(z,3)) + cmul((c+1.+vec2(0,1)),z) + c; }\n\n//Display the color map.\n//#define CMAP\n#define ROTATE\n\n// Main\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    palette p = palette2(); // palette1\n    #ifdef CMAP\n    fragColor = vec4(cmap(fragCoord.x/iResolution.x, p), 1.); return; \n    #endif\n    \n    float t = iTime/4.;\n    vec2 R = iResolution.xy;\n    vec2 uv = (2.*fragCoord-R)/iResolution.y;\n    \n    #ifdef ROTATE\n    float angle = -2.*t;\n    mat2 rot = mat2(cos(angle),sin(angle),-sin(angle),cos(angle));\n    uv*=rot;\n    #endif\n    \n\tvec3 col = vec3(0);\n    vec2 z = vec2(0);\n    vec2 c = map(uv);\n    float n = 0.;\n    float threshold = 4.;\n    float maxIter = 200.;\n    \n    for(; n++ < maxIter ;) {\n        z = fCPoly1(z,c);\n        if(cmod(z) > threshold) break;\n    }\n    \n    fragColor = vec4(cmap( fract(-log(log(dot(z,z))/log(11.))/log(11.) + t), p ),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MltyR8.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[133, 201, 221, 221, 412], [414, 414, 434, 434, 629], [631, 648, 670, 670, 703], [704, 877, 908, 908, 945], [947, 1086, 1114, 1114, 1188], [1190, 1190, 1212, 1253, 1276], [1278, 1303, 1325, 1325, 1420], [1422, 1422, 1455, 1473, 1775], [1778, 1794, 1829, 1829, 1851], [1852, 1852, 1885, 1885, 1973], [1974, 1974, 2007, 2007, 2094], [2152, 2161, 2218, 2218, 2938]], "test": "untested"}
{"id": "MltyRr", "name": "Doki-doki", "author": "eqs", "description": ":-o", "tags": ["heart"], "likes": 9, "viewed": 193, "published": "Public", "date": "1531491364", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI 3.14159265359\n\nvec3 rgb2hsb( in vec3 c ){\n    vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);\n    vec4 p = mix(vec4(c.bg, K.wz), vec4(c.gb, K.xy), step(c.b, c.g));\n    vec4 q = mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));\n    float d = q.x - min(q.w, q.y);\n    float e = 1.0e-10;\n    return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);\n}\n\n//  Function from Iñigo Quiles\n//  https://www.shadertoy.com/view/MsS3Wc\nvec3 hsb2rgb( in vec3 c ){\n    vec3 rgb = clamp(abs(mod(c.x*6.0+vec3(0.0, 4.0, 2.0), 6.0)-3.0)-1.0, 0.0, 1.0 );\n    rgb = rgb*rgb*(3.0-2.0*rgb);\n    return c.z * mix(vec3(1.0), rgb, c.y);\n}\n\nfloat heart(in vec2 pt, in float radius) {\n    float x = pt.x / radius * 0.75;\n    float y = pt.y / radius;\n    float r = pow(x, 2.0) + pow(y+0.5 - sqrt(abs(x)), 2.0);\n    return smoothstep(r-0.4, r+0.4, 2.0);\n}\n\nfloat heart2(in vec2 pt, in float radius) {\n    float x = pt.x / radius * 0.75;\n    float y = pt.y / radius;\n    float r = pow(x, 2.0) + pow(y+0.5 - sqrt(abs(x)), 2.0);\n    return smoothstep(r-0.4, r, 2.0) - smoothstep(r, r+0.4, 2.0);\n}\n\nmat2 rotate(in float angle) {\n    return mat2(cos(angle), -sin(angle),\n                sin(angle),  cos(angle));\n}\n\nmat2 scale(in float sx, in float sy) {\n    return mat2(1.0 / sx, 0.0,\n                0.0,      1.0 / sy);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    \n    vec2 pt = ( fragCoord - .5* iResolution.xy) / iResolution.y;\n    \n    float t = mod(iTime, 2.0);\n    float sx = 1.0 + 0.4 * exp(-t*3.0) * cos(20.0*t);\n    float sy = 1.0 + 0.4 * exp(-t*3.0) * sin(20.0*t);\n    float hue = floor(iTime / 2.0) / 6.0;\n    \n    vec2 ptf = scale(sx, sy) * pt;\n    \n\tfloat f = heart(ptf, 0.2);\n    float g = heart2(pt, 0.18 + t);\n    \n    vec3 col = hsb2rgb(vec3(hue, 1.0, f))\n        + hsb2rgb(vec3(hue, 0.5, g));\n\n    // Output to screen\n    fragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MltyRr.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[26, 26, 52, 52, 382], [384, 458, 484, 484, 647], [649, 649, 691, 691, 860], [862, 862, 905, 905, 1098], [1100, 1100, 1129, 1129, 1214], [1216, 1216, 1254, 1254, 1324], [1326, 1326, 1383, 1383, 1892]], "test": "untested"}
{"id": "MltyW7", "name": "海草舞", "author": "lasiafly", "description": "3D海草舞", "tags": ["raytrace"], "likes": 0, "viewed": 156, "published": "Public", "date": "1532932714", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const int NUM_LIGHTS = 2;\nconst int NUM_MATERIALS = 4;\nconst int NUM_PLANES = 2;\nconst int NUM_SPHERES = 26;\n\nconst vec3 BACKGROUND_COLOR = vec3( 0.1, 0.2, 0.6 );\n\n// Vertical field-of-view angle of camera. In radians.\nconst float FOVY = 50.0 * 3.1415926535 / 180.0;\n\n// Use this for avoiding the \"epsilon problem\" or the shadow acne problem.\nconst float DEFAULT_TMIN = 10.0e-4;\n\n// Use this for tmax for non-shadow ray intersection test.\nconst float DEFAULT_TMAX = 10.0e6;\n\n// Equivalent to number of recursion levels (0 means ray-casting only).\n// We are using iterations to replace recursions.\nconst int NUM_ITERATIONS = 2;\n\n\n//============================================================================\n// Define new struct types.\n//============================================================================\nstruct Ray_t {\n    vec3 o;  // Ray Origin.\n    vec3 d;  // Ray Direction. A unit vector.\n};\n\nstruct Plane_t {\n    // The plane equation is Ax + By + Cz + D = 0.\n    float A, B, C, D;\n    int materialID;\n};\n\nstruct Sphere_t {\n    vec3 center;\n    float radius;\n    int materialID;\n};\n\nstruct Light_t {\n    vec3 position;  // Point light 3D position.\n    vec3 I_a;       // For Ambient.\n    vec3 I_source;  // For Diffuse and Specular.\n};\n\nstruct Material_t {\n    vec3 k_a;   // Ambient coefficient.\n    vec3 k_d;   // Diffuse coefficient.\n    vec3 k_r;   // Reflected specular coefficient.\n    vec3 k_rg;  // Global reflection coefficient.\n    float n;    // The specular reflection exponent. Ranges from 0.0 to 128.0.\n};\n\n//----------------------------------------------------------------------------\n// The lighting model used here is similar to that on Slides 8 and 12 of\n// Lecture 11 (Ray Tracing). Here it is computed as\n//\n//     I_local = SUM_OVER_ALL_LIGHTS {\n//                   I_a * k_a +\n//                   k_shadow * I_source * [ k_d * (N.L) + k_r * (R.V)^n ]\n//               }\n// and\n//     I = I_local  +  k_rg * I_reflected\n//----------------------------------------------------------------------------\n\n\n//============================================================================\n// Global scene data.\n//============================================================================\nPlane_t Plane[NUM_PLANES];\nSphere_t Sphere[NUM_SPHERES];\nLight_t Light[NUM_LIGHTS];\nMaterial_t Material[NUM_MATERIALS];\nfloat centerx=0.6;\nfloat centery = 1.315;\nfloat centerz=0.8;\nfloat headr=0.15;\nfloat bodyr=0.08;\nfloat legr=0.05;\nfloat armr=0.05;\nfloat armcenterx;\nfloat armcentery;\nfloat zout = 0.08;\nvec3 lighta0;\nvec3 lighta1;\n\nvoid lightchange(out vec3 attr0, out vec3 attr1){\n    if(iTime < 6.5){\n        attr0 = vec3(0.0);\n        attr1 = vec3(0.0);\n    }\n    else if(iTime == 6.5){\n        attr0 = vec3(1.0);\n        attr1 = vec3(1.0);\n    }\n    else if(iTime > 6.5 && iTime < 13.0){\n        attr0 = vec3(abs(sin(0.2 * iTime)), 0.5, 0.5);\n        attr1 = vec3(0.0);\n    }\n    \n    else if(iTime >= 13.0 && iTime < 19.0){\n        attr0 = vec3(0.0);\n        attr1 = vec3(0.5, 0.5, abs(sin(0.4 * iTime)));\n    }\n    \n    else if(iTime>77.5&&iTime<104.87){\n        attr0 = vec3(0.8 * abs(sin(1.0 * iTime)), 0.8 * abs(sin(1.3 * iTime)), 0.8 * abs(sin(1.5 * iTime)));\n        attr1 = vec3(0.8 * abs(sin(1.5*iTime)), 0.8 * abs(sin( 1.3* iTime)), 0.8 * abs(sin(1.0 * iTime)));\n    }\n    else\n        \n    {\n        attr0 = vec3(0.8 * abs(sin(0.2 * iTime)), 0.8 * abs(sin(0.5 * iTime)), 0.8 * abs(sin(0.8 * iTime)));\n        attr1 = vec3(0.8 * abs(sin(iTime)), 0.8 * abs(sin(0.7 * iTime)), 0.8 * abs(sin(0.4 * iTime)));\n        \n    }\n}\nvoid Update()\n{\n    Sphere[0].center = vec3(centerx ,centery, centerz);\n    Sphere[1].center = vec3( centerx  , centery-headr-bodyr, centerz);\n    Sphere[2].center = vec3( centerx  , centery-(headr+bodyr*3.0), centerz);\n    Sphere[3].center = vec3( centerx , centery-(headr+bodyr*5.0), centerz);\n    Sphere[4].center = vec3(centerx ,centery-(headr+bodyr*7.0) , centerz);\n    Sphere[5].center = vec3(centerx ,centery-(headr+bodyr*9.0) , centerz);\n    Sphere[6].center = vec3( centerx+bodyr+armr ,armcentery , centerz);\n    Sphere[8].center = vec3( centerx+bodyr+armr*5.0 ,armcentery, centerz);\n    Sphere[10].center = vec3( centerx+bodyr+armr*9.0,armcentery, centerz);\n    Sphere[11].center = vec3( centerx-(bodyr+armr),armcentery, centerz);\n    Sphere[13].center = vec3( centerx-(bodyr+armr*5.0),armcentery, centerz);\n    Sphere[15].center = vec3( centerx-(bodyr+armr*9.0),armcentery, centerz);\n    Sphere[16].center = vec3( centerx-0.5*(bodyr+legr),centery-(headr+bodyr*10.0+legr*0.5), centerz);\n    Sphere[18].center = vec3( centerx-0.5*(bodyr+legr*5.0),centery-(headr+bodyr*10.0+legr*3.0),centerz);\n    Sphere[20].center = vec3( centerx-0.5*(bodyr+legr*9.0),centery-(headr+bodyr*10.0+legr*6.0), centerz);\n    Sphere[21].center = vec3( centerx+0.5*(bodyr+legr),centery-(headr+bodyr*10.0+legr*0.5), centerz);\n    Sphere[23].center = vec3( centerx+0.5*(bodyr+legr*5.0),centery-(headr+bodyr*10.0+legr*3.0),centerz);\n    Sphere[25].center =  vec3( centerx+0.5*(bodyr+legr*9.0),centery-(headr+bodyr*10.0+legr*6.0), centerz);\n    Sphere[24].center =(Sphere[23].center +Sphere[25].center )/2.0;;\n    Sphere[12].center =  (Sphere[11].center+Sphere[13].center)/2.0;\n    Sphere[14].center =  (Sphere[13].center+Sphere[15].center)/2.0;\n    Sphere[17].center = (Sphere[16].center+Sphere[18].center)/2.0;\n    Sphere[7].center = (Sphere[6].center+Sphere[8].center)/2.0;\n    Sphere[9].center = (Sphere[8].center+Sphere[10].center)/2.0;\n    Sphere[19].center = (Sphere[18].center +Sphere[20].center )/2.0;\n    Sphere[22].center = (Sphere[21].center +Sphere[23].center )/2.0;\n    \n    \n}\n\n//basic action\n/*right arm right wave*/\nvoid rightarm_rwave(float freq, float amp){\n    Sphere[6].center.y += 0.3 * amp * sin(freq * iTime);\n    Sphere[8].center.y -= 2.0*amp * sin(freq * iTime);\n    Sphere[10].center.y += 0.7 * amp * sin(freq * iTime);\n    Sphere[10].center.x += abs(amp * cos(0.15*freq * iTime));\n    \n}\nvoid rightarm_lwave(float freq, float amp){\n    Sphere[10].center.xy = Sphere[2].center.xy;\n    Sphere[10].center.z += zout;\n    Sphere[10].center.x -= 3.*armr;\n    Sphere[10].center.y -= 0.15;\n    Sphere[8].center.z += zout;\n    Sphere[8].center.y -= 0.15;\n    Sphere[6].center.y += 0.3 * amp * sin(freq * iTime);\n    Sphere[8].center.y -= 2.0*amp * sin(freq * iTime);\n    Sphere[10].center.y += 0.7 * amp * sin(freq * iTime);\n    Sphere[10].center.x += abs(amp * cos(0.15*freq * iTime));\n    \n}\n/*right arm up wave*/\nvoid rightarm_ulwave(float freq, float amp){\n    Sphere[6].center.y += 0.5*armr;\n    Sphere[6].center.x += 0.8 * amp * sin(freq * iTime);\n    Sphere[8].center.x = 0.9*armcenterx;\n    Sphere[8].center.y += 3.*armr;\n    Sphere[10].center.x = 1.2*0.9*armcenterx;\n    Sphere[10].center.y += 9.*armr;\n    Sphere[8].center.x -= amp * sin(freq * iTime);\n    Sphere[10].center.x -= 0.7 * amp *abs(sin(iTime));\n    Sphere[8].center.y -= 2.*amp * abs(sin(iTime));\n    Sphere[10].center.y -= 2.*amp * abs(sin(iTime));\n}\nvoid rightarm_urwave(float freq, float amp){\n    Sphere[6].center.y += 0.5*armr;\n    Sphere[6].center.x += 0.8 * amp * sin(freq * iTime);\n    Sphere[8].center.x = 0.9*armcenterx;\n    Sphere[8].center.y += 3.*armr;\n    Sphere[10].center.x = 1.2*0.9*armcenterx;\n    Sphere[10].center.y += 9.*armr;\n    Sphere[8].center.x += amp * sin(freq * iTime);\n    Sphere[10].center.x -= 0.7 * amp *abs(sin(iTime));\n    Sphere[8].center.y -= 2.*amp * abs(sin(iTime));\n    Sphere[10].center.y -= 2.*amp * abs(sin(iTime));\n}\n/*right arm front wave*/\nvoid rightarm_fwave(float freq, float amp){\n    Sphere[6].center.y += 0.5 * amp * sin(freq * iTime);\n    Sphere[8].center.x = Sphere[6].center.x;\n    Sphere[8].center.z = Sphere[6].center.z+3.*armr;\n    Sphere[8].center.y -= 0.5 * amp * sin(freq * iTime);\n    Sphere[10].center.x = Sphere[6].center.x;\n    Sphere[10].center.z = Sphere[6].center.z+9.*armr;\n    Sphere[10].center.y += 0.8 * amp * sin(freq * iTime);\n}\n/*right arm down wave*/\nvoid rightarm_dlwave(float freq, float amp){\n    Sphere[6].center.y -= 0.5*armr;\n    Sphere[6].center.x += 0.8 * amp * sin(freq * iTime);\n    Sphere[8].center.x = 0.9*armcenterx;\n    Sphere[8].center.y -= 3.*armr;\n    Sphere[10].center.x = 1.2*0.9*armcenterx;\n    Sphere[10].center.y -= 8.*armr;\n    Sphere[8].center.x -= 2.*amp * sin(freq * iTime);\n    Sphere[10].center.x -= 0.7 * amp *abs(sin(iTime));\n    \n}\nvoid rightarm_drwave(float freq, float amp){\n    \n    Sphere[6].center.x += 0.8 * amp * sin(freq * iTime);\n    Sphere[8].center.x = 0.9*armcenterx;\n    Sphere[8].center.y -= 3.*armr;\n    Sphere[10].center.x = 1.2*0.9*armcenterx;\n    Sphere[10].center.y -= 8.*armr;\n    Sphere[8].center.x += 2.*amp * sin(freq * iTime);\n    Sphere[10].center.x -= 0.7 * amp *abs(sin(iTime));\n    \n}\n\n/*left arm right wave*/\nvoid leftarm_rwave(float freq, float amp){\n    Sphere[15].center.xy = Sphere[2].center.xy;\n    Sphere[15].center.z += zout;\n    Sphere[15].center.x += 3.*armr;\n    Sphere[15].center.y -= 0.15;\n    Sphere[13].center.z += zout;\n    Sphere[13].center.y -= 0.15;\n    Sphere[11].center.y += 0.3 * amp * sin(freq * iTime);\n    Sphere[13].center.y -= 2.0*amp * sin(freq * iTime);\n    Sphere[15].center.y += 0.7 * amp * sin(freq * iTime);\n    Sphere[15].center.x -= abs(amp * cos(0.15*freq * iTime));\n}\n/*left arm left wave*/\nvoid leftarm_lwave(float freq, float amp){\n    Sphere[11].center.y += 0.3 * amp * sin(freq * iTime);\n    Sphere[13].center.y -= 2.0*amp * sin(freq * iTime);\n    Sphere[15].center.y += 0.7 * amp * sin(freq * iTime);\n    Sphere[15].center.x -= abs(amp * cos(0.15*freq * iTime));\n}\n/*left arm up wave*/\nvoid leftarm_ulwave(float freq, float amp){\n    Sphere[11].center.y += 0.5*armr;\n    Sphere[11].center.x -= 0.8 * amp * sin(freq * iTime);\n    Sphere[13].center.x = 2.*centerx - 0.9*armcenterx;\n    Sphere[13].center.y += 3.*armr;\n    Sphere[15].center.x = 2.*centerx - 1.2*0.9*armcenterx;\n    Sphere[15].center.y += 9.*armr;\n    Sphere[13].center.x += amp * sin(freq * iTime);\n    Sphere[15].center.x += 0.7 * amp *abs(sin(iTime));\n    Sphere[13].center.y -= 2.*amp * abs(sin(iTime));\n    Sphere[15].center.y -= 2.*amp * abs(sin(iTime));\n    \n}\nvoid leftarm_urwave(float freq, float amp){\n    Sphere[11].center.y += 0.5*armr;\n    Sphere[11].center.x -= 0.8 * amp * sin(freq * iTime);\n    Sphere[13].center.x = 2.*centerx - 0.9*armcenterx;\n    Sphere[13].center.y += 3.*armr;\n    Sphere[15].center.x = 2.*centerx - 1.2*0.9*armcenterx;\n    Sphere[15].center.y += 9.*armr;\n    Sphere[13].center.x -= amp * sin(freq * iTime);\n    Sphere[15].center.x += 0.7 * amp *abs(sin(iTime));\n    Sphere[13].center.y -= 2.*amp * abs(sin(iTime));\n    Sphere[15].center.y -= 2.*amp * abs(sin(iTime));\n}\n/*left arm down wave*/\n\nvoid leftarm_dlwave(float freq, float amp){\n    Sphere[11].center.y -= 0.5*armr;\n    Sphere[13].center.x = 2.*centerx - 0.9*armcenterx;\n    Sphere[13].center.y -= 3.*armr;\n    Sphere[15].center.x = 2.*centerx - 1.2*0.9*armcenterx;\n    Sphere[15].center.y -= 8.*armr;\n    Sphere[13].center.x += 2.*amp * sin(freq * iTime);\n    Sphere[15].center.x += 0.7 * amp *abs(sin(iTime));\n    \n}\nvoid leftarm_drwave(float freq, float amp){\n    Sphere[11].center.y -= 0.5*armr;\n    Sphere[13].center.x = 2.*centerx - 0.9*armcenterx;\n    Sphere[13].center.y -= 3.*armr;\n    Sphere[15].center.x = 2.*centerx - 1.2*0.9*armcenterx;\n    Sphere[15].center.y -= 8.*armr;\n    Sphere[13].center.x -= 2.*amp * sin(freq * iTime);\n    Sphere[15].center.x += 0.7 * amp *abs(sin(iTime));\n}\n\n/*left arm front wave*/\nvoid leftarm_fwave(float freq, float amp){\n    Sphere[11].center.y += 0.3 * amp * sin(freq * iTime);\n    Sphere[13].center.x = Sphere[11].center.x;\n    Sphere[13].center.z = Sphere[11].center.z+3.*armr;\n    Sphere[13].center.y -= 0.5 * amp * sin(freq * iTime);\n    Sphere[15].center.x = Sphere[11].center.x;\n    Sphere[15].center.z = Sphere[11].center.z+9.*armr;\n    Sphere[15].center.y += 0.8 * amp * sin(freq * iTime);\n}\n\n\nvoid llegwave(float freq,float amp)\n{\n    Sphere[16].center.x += 0.01 * cos(freq * iTime);\n    Sphere[16].center.z += 0.01 * sin(freq * iTime);\n    Sphere[17].center.x += 0.03 * sin(freq * iTime);\n    Sphere[17].center.z += 0.03 * cos(freq * iTime);\n    Sphere[18].center.x += 0.05 * sin(freq * iTime);\n    Sphere[18].center.z += 0.05 * cos(freq * iTime);\n    Sphere[19].center.x += 0.03 * sin(freq * iTime);\n    Sphere[19].center.z += 0.03 * cos(freq * iTime);\n    Sphere[20].center.x += 0.01 * sin(freq * iTime);\n    Sphere[20].center.z += 0.01 * cos(freq * iTime);\n}\n\n\n\nvoid rlegwave(float freq,float amp)\n{\n    Sphere[21].center.x += 0.01 * cos(freq * iTime);\n    Sphere[21].center.z += 0.01 * sin(freq * iTime);\n    Sphere[22].center.x += 0.03 * sin(freq * iTime);\n    Sphere[22].center.z += 0.03 * cos(freq * iTime);\n    Sphere[23].center.x += 0.05 * sin(freq * iTime);\n    Sphere[23].center.z += 0.05 * cos(freq * iTime);\n    Sphere[24].center.x += 0.03 * sin(freq * iTime);\n    Sphere[24].center.z += 0.03 * cos(freq * iTime);\n    Sphere[25].center.x += 0.01 * sin(freq * iTime);\n    Sphere[25].center.z += 0.01 * cos(freq * iTime);\n}\n\nvoid rllegwave(float freq,float amp)\n{\n    Sphere[21].center.x -= 0.01 * sin(freq * iTime);\n    Sphere[21].center.z -= 0.01 * cos(freq * iTime);\n    Sphere[22].center.x -= 0.03 * sin(freq * iTime);\n    Sphere[22].center.z -= 0.03 * cos(freq * iTime);\n    Sphere[23].center.x -= 0.05 * sin(freq * iTime);\n    Sphere[23].center.z -= 0.05 * cos(freq * iTime);\n    Sphere[24].center.x -= 0.03 * sin(freq * iTime);\n    Sphere[24].center.z -= 0.03 * cos(freq * iTime);\n    Sphere[25].center.x -= 0.01 * sin(freq * iTime);\n    Sphere[25].center.z -= 0.01 * cos(freq * iTime);\n}\n\nvoid body_movex(float amp)\n{\n    centerx +=amp*sin(1.0*iTime);\n    \n}\n\nvoid body_movez(float amp)\n{\n    centerz +=amp*sin(1.0*iTime);\n}\n\n\n/*waist left*/\n\nvoid waist_lwave(float freq, float amp){\n    Sphere[0].center.x += 0.01 * cos(freq * iTime);\n    Sphere[0].center.z += 0.01 * sin(freq * iTime);\n    Sphere[1].center.x += 0.01 * sin(freq * iTime);\n    Sphere[1].center.z += 0.01 * cos(freq * iTime);\n    Sphere[2].center.x += 0.03 * sin(freq * iTime);\n    Sphere[2].center.z += 0.03 * cos(freq * iTime);\n    Sphere[3].center.x += 0.05 * sin(freq * iTime);\n    Sphere[3].center.z += 0.05 * cos(freq * iTime);\n    Sphere[4].center.x += 0.03 * sin(freq * iTime);\n    Sphere[4].center.z += 0.03 * cos(freq * iTime);\n    Sphere[5].center.x += 0.01 * sin(freq * iTime);\n    Sphere[5].center.z += 0.01 * cos(freq * iTime);\n}\n\nvoid noodle_arm(float freq, float amp){\n    Sphere[0].center.x += 0.01 * cos(freq * iTime);\n    Sphere[0].center.z += 0.01 * sin(freq * iTime);\n    Sphere[1].center.x += 0.01 * sin(freq * iTime);\n    Sphere[1].center.z += 0.01 * cos(freq * iTime);\n    Sphere[2].center.x += 0.03 * sin(freq * iTime);\n    Sphere[2].center.z += 0.03 * cos(freq * iTime);\n    Sphere[3].center.x += 0.05 * sin(freq * iTime);\n    Sphere[3].center.z += 0.05 * cos(freq * iTime);\n    Sphere[4].center.x += 0.03 * sin(freq * iTime);\n    Sphere[4].center.z += 0.03 * cos(freq * iTime);\n    Sphere[5].center.x += 0.01 * sin(freq * iTime);\n    Sphere[5].center.z += 0.01 * cos(freq * iTime);\n    Sphere[6].center.y += 0.01 * sin(freq * iTime);\n    Sphere[6].center.z += 0.01 * cos(freq * iTime);\n    Sphere[7].center.y += 0.03 * sin(freq * iTime);\n    Sphere[7].center.z += 0.03 * cos(freq * iTime);\n    Sphere[8].center.y += 0.05 * sin(freq * iTime);\n    Sphere[8].center.z += 0.05 * cos(freq * iTime);\n    Sphere[9].center.y += 0.03 * sin(freq * iTime);\n    Sphere[9].center.z += 0.03 * cos(freq * iTime);\n    Sphere[10].center.y -= 0.01 * sin(freq * iTime);\n    Sphere[10].center.z -= 0.01 * cos(freq * iTime);\n    Sphere[11].center.y -= 0.01 * sin(freq * iTime);\n    Sphere[11].center.z -= 0.01 * cos(freq * iTime);\n    Sphere[12].center.y -= 0.03 * sin(freq * iTime);\n    Sphere[12].center.z -= 0.03 * cos(freq * iTime);\n    Sphere[13].center.y -= 0.05 * sin(freq * iTime);\n    Sphere[13].center.z -= 0.05 * cos(freq * iTime);\n    Sphere[14].center.y -= 0.03 * sin(freq * iTime);\n    Sphere[14].center.z -= 0.03 * cos(freq * iTime);\n    Sphere[15].center.y -= 0.01 * sin(freq * iTime);\n    Sphere[15].center.z -= 0.01 * cos(freq * iTime);\n    Sphere[16].center.x += 0.01 * sin(freq * iTime);\n    Sphere[16].center.z += 0.01 * cos(freq * iTime);\n    Sphere[17].center.x += 0.03 * sin(freq * iTime);\n    Sphere[17].center.z += 0.03 * cos(freq * iTime);\n    Sphere[18].center.x += 0.05 * sin(freq * iTime);\n    Sphere[18].center.z += 0.05 * cos(freq * iTime);\n    Sphere[19].center.x += 0.03 * sin(freq * iTime);\n    Sphere[19].center.z += 0.03 * cos(freq * iTime);\n    Sphere[20].center.x += 0.01 * sin(freq * iTime);\n    Sphere[20].center.z += 0.01 * cos(freq * iTime);\n    Sphere[21].center.x -= 0.01 * sin(freq * iTime);\n    Sphere[21].center.z -= 0.01 * cos(freq * iTime);\n    Sphere[22].center.x -= 0.03 * sin(freq * iTime);\n    Sphere[22].center.z -= 0.03 * cos(freq * iTime);\n    Sphere[23].center.x -= 0.05 * sin(freq * iTime);\n    Sphere[23].center.z -= 0.05 * cos(freq * iTime);\n    Sphere[24].center.x -= 0.03 * sin(freq * iTime);\n    Sphere[24].center.z -= 0.03 * cos(freq * iTime);\n    Sphere[25].center.x -= 0.01 * sin(freq * iTime);\n    Sphere[25].center.z -= 0.01 * cos(freq * iTime);\n    \n}\n\n/*head node*/\nvoid head_node(float freq, float amp){\n    float theta = amp * abs(sin(freq * iTime));\n    Sphere[0].center.x =  Sphere[1].center.x + headr * sin(theta);\n    Sphere[0].center.y = Sphere[1].center.y + headr * cos(theta);\n    \n}\n\nvoid assmove(float freq, float amp){\n    Sphere[5].center.x += amp * sin(freq * iTime);\n    Sphere[5].center.y += amp * sin(freq * iTime);\n    Sphere[4].center.x += 0.8 * amp * sin(freq * iTime);\n    Sphere[4].center.y += 0.8 * amp * sin(freq * iTime);\n    Sphere[16].center.x += 0.5 * amp * sin(freq * iTime);\n    Sphere[16].center.y += 0.5 * amp * sin(freq * iTime);\n    Sphere[21].center.x += 0.5 * amp * sin(freq * iTime);\n    Sphere[21].center.y += 0.5 * amp * sin(freq * iTime);\n}\n\n/////////////////////////////////////////////////////////////////////////////\n// Initializes the scene.\n/////////////////////////////////////////////////////////////////////////////\nvoid InitScene()\n\n{\n    lightchange(lighta0,lighta1);\n    armcenterx= centerx+bodyr+armr*5.0;\n    armcentery=centery-(headr+bodyr*3.0);\n    int flag = 0;\n    \n    // Horizontal plane.\n    Plane[0].A = 0.0;\n    Plane[0].B = 1.0;\n    Plane[0].C = 0.0;\n    Plane[0].D = 0.0;\n    Plane[0].materialID = 0;\n    \n    // Vertical plane.\n    Plane[1].A = 0.0;\n    Plane[1].B = 0.0;\n    Plane[1].C = 1.0;\n    Plane[1].D = 3.5;\n    Plane[1].materialID = 0;\n    \n    // Center bouncing sphere.\n    \n    Sphere[0].center = vec3(centerx ,centery, centerz);\n    Sphere[0].radius = headr;\n    Sphere[0].materialID = 1;\n    \n    \n    // Circling sphere.\n    \n    Sphere[1].center = vec3( centerx  , centery-headr-bodyr, centerz);\n    Sphere[1].radius = bodyr;\n    Sphere[1].materialID = 3;\n    \n    \n    Sphere[2].center = vec3( centerx  , centery-(headr+bodyr*3.0), centerz);\n    Sphere[2].radius = bodyr;\n    Sphere[2].materialID = 3;\n    \n    \n    Sphere[3].center = vec3( centerx , centery-(headr+bodyr*5.0), centerz);\n    Sphere[3].radius = bodyr;\n    Sphere[3].materialID = 3;\n    \n    \n    Sphere[4].center = vec3(centerx ,centery-(headr+bodyr*7.0) , centerz);\n    Sphere[4].radius = 1.1*bodyr;\n    Sphere[4].materialID = 3;\n    \n    \n    Sphere[5].center = vec3(centerx ,centery-(headr+bodyr*9.0) , centerz);\n    Sphere[5].radius = 1.4*legr;\n    Sphere[5].materialID = 3;\n    \n    Sphere[6].center = vec3( centerx+bodyr+armr ,armcentery , centerz);\n    Sphere[6].radius = armr;\n    Sphere[6].materialID = 2;\n    \n    Sphere[8].center = vec3( centerx+bodyr+armr*5.0 ,armcentery, centerz);\n    Sphere[8].radius = armr;\n    Sphere[8].materialID = 2;\n    \n    \n    Sphere[10].center = vec3( centerx+bodyr+armr*9.0,armcentery, centerz);\n    Sphere[10].radius = armr;\n    Sphere[10].materialID = 2;\n    \n    \n    Sphere[11].center = vec3( centerx-(bodyr+armr),armcentery, centerz);\n    Sphere[11].radius = armr;\n    Sphere[11].materialID = 2;\n    \n    \n    \n    Sphere[13].center = vec3( centerx-(bodyr+armr*5.0),armcentery, centerz);\n    Sphere[13].radius = armr;\n    Sphere[13].materialID = 2;\n    \n    \n    Sphere[15].center = vec3( centerx-(bodyr+armr*9.0),armcentery, centerz);\n    Sphere[15].radius = armr;\n    Sphere[15].materialID = 2;\n    \n    Sphere[16].center = vec3( centerx-0.5*(bodyr+legr),centery-(headr+bodyr*10.0+legr*0.5), centerz);\n    Sphere[16].radius = legr;\n    Sphere[16].materialID = 2;\n    \n    Sphere[18].center = vec3( centerx-0.5*(bodyr+legr*5.0),centery-(headr+bodyr*10.0+legr*3.0),centerz);\n    Sphere[18].radius = legr;\n    Sphere[18].materialID = 2;\n    \n    Sphere[20].center = vec3( centerx-0.5*(bodyr+legr*9.0),centery-(headr+bodyr*10.0+legr*6.0), centerz);\n    Sphere[20].radius = legr;\n    Sphere[20].materialID = 2;\n    \n    Sphere[21].center = vec3( centerx+0.5*(bodyr+legr),centery-(headr+bodyr*10.0+legr*0.5), centerz);\n    Sphere[21].radius = legr;\n    Sphere[21].materialID = 2;\n    \n    Sphere[23].center = vec3( centerx+0.5*(bodyr+legr*5.0),centery-(headr+bodyr*10.0+legr*3.0),centerz);\n    Sphere[23].radius = legr;\n    Sphere[23].materialID = 2;\n    \n    Sphere[25].center =  vec3( centerx+0.5*(bodyr+legr*9.0),centery-(headr+bodyr*10.0+legr*6.0), centerz);\n    Sphere[25].radius = legr;\n    Sphere[25].materialID = 2;\n    \n    \n    if(iTime <6.5){\n        rightarm_dlwave(6.0,0.05);\n        leftarm_drwave(6.0,0.05);\n        waist_lwave(6.0,0.05);\n        flag = 1;\n    }\n    \n    if(iTime >6.5 && iTime<8.7){\n        rightarm_fwave(6.0,0.05);\n        leftarm_drwave(6.0,0.05);\n        head_node(6.0, 0.3);\n        flag = 1;\n\n    }\n    if(iTime >8.7&& iTime<9.5){\n        rightarm_ulwave(6.0,0.05);\n        rightarm_dlwave(6.0,0.05);\n        flag = 1;\n\n    }\n    if(iTime >10.0&& iTime<11.9){\n        leftarm_lwave(6.0,0.05);\n        rightarm_lwave(6.0,0.05);\n        head_node(6.0, 0.3);\n        flag = 1;\n\n    }\n    if(iTime >11.9&& iTime<13.3){\n        llegwave(6.0,0.05);\n        rlegwave(6.0,0.05);\n        rightarm_rwave(6.0,0.05);\n        leftarm_rwave(6.0,0.05);\n        head_node(6.0, 0.3);\n        flag = 1;\n\n    }\n    if(iTime >13.5&& iTime<14.3){\n        body_movez(0.3);\n        Update();\n        llegwave(6.0,0.05);\n        rlegwave(6.0,0.05);\n        waist_lwave(7.0,0.05);\n        rightarm_urwave(6.0,0.05);\n        leftarm_lwave(6.0,0.05);\n        flag = 1;\n\n    }\n    if(iTime >14.5&& iTime<15.3){\n        body_movex(0.3);\n        Update();\n        llegwave(6.0,0.05);\n        rlegwave(6.0,0.05);\n        waist_lwave(7.0,0.05);\n        rightarm_lwave(6.0,0.05);\n        leftarm_rwave(6.0,0.05);\n        flag = 1;\n\n    }\n    if(iTime >15.5&& iTime<16.5){\n        body_movex(0.3);\n        Update();\n        llegwave(6.0,0.05);\n        rlegwave(6.0,0.05);\n        waist_lwave(7.0,0.05);\n        rightarm_rwave(6.0,0.05);\n        leftarm_lwave(6.0,0.05);\n        flag = 1;\n\n    }\n    if(iTime >16.5&& iTime<18.3){\n        rightarm_drwave(6.0,0.05);\n        leftarm_dlwave(6.0,0.05);\n        flag = 1;\n\n    }\n    if(iTime >18.7&& iTime<20.0){\n        rightarm_ulwave(6.0,0.05);\n        leftarm_dlwave(6.0,0.05);\n        flag = 1;\n\n    }\n    \n    if(iTime >20.8&& iTime<21.9|| iTime>77.5&&iTime<80.8){//noodle\n        body_movez(0.3);\n        Update();\n        llegwave(6.0,0.05);\n        rllegwave(6.0,0.05);\n        waist_lwave(7.0,0.05);\n        noodle_arm(6.0,0.05);\n        flag = 1;\n\n    }\n    if(iTime >21.9&& iTime<23.4 || iTime>80.8&&iTime<84.2|| iTime>94.5&&iTime<98.0|| iTime>88.0&&iTime<91.2 ){\n        body_movex(0.3);\n        Update();\n        llegwave(6.0,0.05);\n        rllegwave(6.0,0.05);\n        waist_lwave(7.0,0.05);\n        rightarm_urwave(6.0,0.05);\n        leftarm_lwave(6.0,0.05);\n        flag = 1;\n\n    }\n    if(iTime >23.4&& iTime<25.9 || iTime>84.2&&iTime<88.0){\n        body_movez(0.3);\n        Update();\n        llegwave(6.0,0.05);\n        rllegwave(6.0,0.05);\n        waist_lwave(7.0,0.05);\n        leftarm_ulwave(6.0,0.05);\n        rightarm_rwave(6.0,0.05);\n        flag = 1;\n\n    }\n    if(iTime >25.9&& iTime<28.9|| iTime>88.0&&iTime<91.2){\n        body_movex(0.3);\n        Update();\n        llegwave(6.0,0.05);\n        rlegwave(6.0,0.05);\n        waist_lwave(7.0,0.05);\n        leftarm_fwave(6.0,0.05);\n        rightarm_fwave(6.0,0.05);\n        flag = 1;\n\n    }\n    if(iTime >28.9&& iTime<32.9|| iTime>91.2&&iTime<94.5){\n        body_movez(0.3);\n        Update();\n        llegwave(6.0,0.05);\n        rllegwave(6.0,0.05);\n        waist_lwave(7.0,0.05);\n        noodle_arm(6.0,0.05);\n        flag = 1;\n\n    }\n    if(iTime >33.0&& iTime<34.4|| iTime>98.0&&iTime<101.5){\n        body_movex(0.3);\n        Update();\n        llegwave(6.0,0.05);\n        rlegwave(6.0,0.05);\n        waist_lwave(7.0,0.05);\n        leftarm_ulwave(6.0,0.05);\n        rightarm_urwave(6.0,0.05);\n        flag = 1;\n\n    }\n    if(iTime >34.5 && iTime<36.2){\n        rightarm_fwave(6.0,0.05);\n        leftarm_drwave(6.0,0.05);\n        head_node(6.0, 0.3);\n        flag = 1;\n\n    }\n    if(iTime >36.3&& iTime<37.3){\n        rightarm_ulwave(6.0,0.05);\n        rightarm_dlwave(6.0,0.05);\n        flag = 1;\n\n    }\n   \tif(iTime >37.4&& iTime<39.6|| iTime>94.5&&iTime<98.0 ){\n        leftarm_lwave(6.0,0.05);\n        rightarm_lwave(6.0,0.05);\n        head_node(6.0, 0.3);\n        flag = 1;\n\n    }\n    if(iTime >39.6&& iTime<40.5){\n        body_movex(0.3);\n        Update();\n        llegwave(6.0,0.05);\n        rlegwave(6.0,0.05);\n        waist_lwave(7.0,0.05);\n        rightarm_lwave(6.0,0.05);\n        leftarm_rwave(6.0,0.05);\n        flag = 1;\n\n    }\n    if(iTime >41.2&& iTime<42.3){\n        body_movex(0.3);\n        Update();\n        llegwave(6.0,0.05);\n        rlegwave(6.0,0.05);\n        waist_lwave(7.0,0.05);\n        rightarm_rwave(6.0,0.05);\n        leftarm_lwave(6.0,0.05);\n        flag = 1;\n\n    }\n    if(iTime >42.3&& iTime<45.5){\n        rightarm_drwave(6.0,0.05);\n        leftarm_dlwave(6.0,0.05);\n        flag = 1;\n\n    }\n    if(iTime >46.8&& iTime<46.6){\n        rightarm_ulwave(6.0,0.05);\n        leftarm_dlwave(6.0,0.05);\n        flag = 1;\n\n    }\n    if(iTime >46.6&& iTime<47.2){\n        rightarm_fwave(6.0,0.05);\n        leftarm_dlwave(6.0,0.05);\n        flag = 1;\n\n    }\n    if(flag==0){\n        body_movez(0.3);\n        Update();\n        llegwave(6.0,0.05);\n        rllegwave(6.0,0.05);\n        waist_lwave(7.0,0.05);\n        noodle_arm(6.0,0.05);\n        head_node(6.0, 0.4);\n    }\n    \n    \n    Sphere[12].center =  (Sphere[11].center+Sphere[13].center)/2.0;\n    Sphere[12].radius = armr;\n    Sphere[12].materialID = 2;\n    \n    \n    Sphere[14].center =  (Sphere[13].center+Sphere[15].center)/2.0;\n    Sphere[14].radius = armr;\n    Sphere[14].materialID = 2;\n    \n    \n    Sphere[17].center = (Sphere[16].center+Sphere[18].center)/2.0;\n    Sphere[17].radius = legr;\n    Sphere[17].materialID = 2;\n    \n    \n    \n    Sphere[7].center = (Sphere[6].center+Sphere[8].center)/2.0;\n    Sphere[7].radius = armr;\n    Sphere[7].materialID = 2;\n    \n    Sphere[9].center = (Sphere[8].center+Sphere[10].center)/2.0;\n    Sphere[9].radius = armr;\n    Sphere[9].materialID = 2;\n    \n    \n    Sphere[19].center = (Sphere[18].center +Sphere[20].center )/2.0;\n    Sphere[19].radius = legr;\n    Sphere[19].materialID = 2;\n    \n    \n    Sphere[22].center = (Sphere[21].center +Sphere[23].center )/2.0;\n    Sphere[22].radius = legr;\n    Sphere[22].materialID = 2;\n    \n    \n    \n    Sphere[24].center =(Sphere[23].center +Sphere[25].center )/2.0;;\n    Sphere[24].radius = legr;\n    Sphere[24].materialID = 2;\n    \n    // Silver material.\n    Material[0].k_d = vec3( 0.5, 0.5, 0.5 );\n    Material[0].k_a = 0.2 * Material[0].k_d;\n    Material[0].k_r = 2.0 * Material[0].k_d;\n    Material[0].k_rg = 0.5 * Material[0].k_r;\n    Material[0].n = 64.0;\n    \n    // Pink material.\n    Material[1].k_d = vec3(0.5, 1.0, 1.0);\n    Material[1].k_a = 0.2 * Material[1].k_d;\n    Material[1].k_r = 2.0 * Material[1].k_d;\n    Material[1].k_rg = 0.5 * Material[1].k_r;\n    Material[1].n = 64.0;\n    \n    // Green plastic material.\n    Material[2].k_d = vec3(0.0, 0.8, 0.0);\n    Material[2].k_a = 0.2 * Material[2].k_d;\n    Material[2].k_r = vec3( 1.0, 1.0, 1.0 );\n    Material[2].k_rg = 0.5 * Material[2].k_r;\n    Material[2].n = 128.0;\n    \n    // Blue material.\n    Material[3].k_d = vec3(1.0, 1.0, 0.5);\n    Material[3].k_a = 0.2 * Material[3].k_d;\n    Material[3].k_r = 2.0 * Material[3].k_d;\n    Material[3].k_rg = 0.5 * Material[3].k_r;\n    Material[3].n = 64.0;\n    \n    // Light 0.\n    Light[0].position = vec3(centerx + 3.0 * sin(iTime), centery + 20.0, 10.0 + centerz + 3.0 * cos(iTime));\n    Light[0].I_a = vec3(0.1, 0.1, 0.1);\n    Light[0].I_source = vec3(0.0 + lighta0.r, 0.0 + lighta0.g, 0.0 + lighta0.b);\n    \n    \n    // Light 1.\n    Light[1].position = vec3(centerx + 3.0 * sin(iTime), centery + 20.0, 10.0 + centerz - 3.0 * cos(iTime));\n    Light[1].I_a = vec3(0.1, 0.1, 0.1);\n    Light[1].I_source = vec3(0.0 + lighta1.r, 0.0 + lighta1.g, 0.0 + lighta1.b);\n}\n\n\n\n/////////////////////////////////////////////////////////////////////////////\n// Computes intersection between a plane and a ray.\n// Returns true if there is an intersection where the ray parameter t is\n// between tmin and tmax, otherwise returns false.\n// If there is such an intersection, outputs the value of t, the position\n// of the intersection (hitPos) and the normal vector at the intersection\n// (hitNormal).\n/////////////////////////////////////////////////////////////////////////////\nbool IntersectPlane( in Plane_t pln, in Ray_t ray, in float tmin, in float tmax,\n                    out float t, out vec3 hitPos, out vec3 hitNormal )\n{\n    vec3 N = vec3( pln.A, pln.B, pln.C );\n    float NRd = dot( N, ray.d );\n    float NRo = dot( N, ray.o );\n    float t0 = (-pln.D - NRo) / NRd;\n    if ( t0 < tmin || t0 > tmax ) return false;\n    \n    // We have a hit -- output results.\n    t = t0;\n    hitPos = ray.o + t0 * ray.d;\n    hitNormal = normalize( N );\n    return true;\n}\n\n\n\n/////////////////////////////////////////////////////////////////////////////\n// Computes intersection between a plane and a ray.\n// Returns true if there is an intersection where the ray parameter t is\n// between tmin and tmax, otherwise returns false.\n/////////////////////////////////////////////////////////////////////////////\nbool IntersectPlane( in Plane_t pln, in Ray_t ray, in float tmin, in float tmax )\n{\n    vec3 N = vec3( pln.A, pln.B, pln.C );\n    float NRd = dot( N, ray.d );\n    float NRo = dot( N, ray.o );\n    float t0 = (-pln.D - NRo) / NRd;\n    if ( t0 < tmin || t0 > tmax ) return false;\n    return true;\n}\n\n\n\n/////////////////////////////////////////////////////////////////////////////\n// Computes intersection between a sphere and a ray.\n// Returns true if there is an intersection where the ray parameter t is\n// between tmin and tmax, otherwise returns false.\n// If there is one or two such intersections, outputs the value of the\n// smaller t, the position of the intersection (hitPos) and the normal\n// vector at the intersection (hitNormal).\n/////////////////////////////////////////////////////////////////////////////\nbool IntersectSphere( in Sphere_t sph, in Ray_t ray, in float tmin, in float tmax,\n                     out float t, out vec3 hitPos, out vec3 hitNormal )\n{\n    /////////////////////////////////\n    // TASK: WRITE YOUR CODE HERE. //\n    /////////////////////////////////\n    float a = 1.0;\n    float b = 2.0 * dot(ray.d, (ray.o - sph.center));\n    float c = dot((ray.o - sph.center), (ray.o - sph.center)) - sph.radius * sph.radius;\n    float d = b * b - 4.0 * a * c;\n    float t0;\n    if(d < 0.0) return false;\n    else\n    {\n        float t1 = (-b + sqrt(d)) / (2.0 * a);\n        float t2 = (-b - sqrt(d)) / (2.0 * a);\n        if (t1 < tmin || t1 > tmax)           //t1 false\n        {\n            if (t2 < tmin || t2 > tmax)    //t1&t2 false\n                return false;\n            else                           //t2 ok t1 false\n                t0 = t2;\n        }\n        else                               //t1 ok\n        {\n            if (t2 < tmin || t2 > tmax)    //t2 false t1 ok\n                t0 = t1;\n            else                           //t2 ok t1 ok\n                t0 = min(t1,t2);\n        }\n    }\n    // We have a hit -- output results.\n    t = t0;\n    hitPos = ray.o + t0 * ray.d;\n    hitNormal = normalize(vec3(ray.o + t0 * ray.d - sph.center));\n    return true;\n}\n\n\n\n/////////////////////////////////////////////////////////////////////////////\n// Computes intersection between a sphere and a ray.\n// Returns true if there is an intersection where the ray parameter t is\n// between tmin and tmax, otherwise returns false.\n/////////////////////////////////////////////////////////////////////////////\nbool IntersectSphere( in Sphere_t sph, in Ray_t ray, in float tmin, in float tmax )\n{\n    /////////////////////////////////\n    // TASK: WRITE YOUR CODE HERE. //\n    /////////////////////////////////\n    float a = 1.0;\n    float b = 2.0 * dot(ray.d, (ray.o - sph.center));\n    float c = dot((ray.o - sph.center), (ray.o - sph.center)) - sph.radius * sph.radius;\n    float d = b * b - 4.0 * a * c;\n    float t0;\n    if(d < 0.0) return false;\n    else\n    {\n        float t1 = (-b + sqrt(d)) / (2.0 * a);\n        float t2 = (-b - sqrt(d)) / (2.0 * a);\n        if (t1 < tmin || t1 > tmax)           //t1 false\n        {\n            if (t2 < tmin || t2 > tmax)    //t1&t2 false\n                return false;\n            else                           //t2 ok t1 false\n                return true;\n        }\n        else\n            return true;\n    }\n}\n\n\n\n\n/////////////////////////////////////////////////////////////////////////////\n// Computes (I_a * k_a) + k_shadow * I_source * [ k_d * (N.L) + k_r * (R.V)^n ].\n// Input vectors L, N and V are pointing AWAY from surface point.\n// Assume all vectors L, N and V are unit vectors.\n/////////////////////////////////////////////////////////////////////////////\nvec3 PhongLighting( in vec3 L, in vec3 N, in vec3 V, in bool inShadow,\n                   in Material_t mat, in Light_t light )\n{\n    if ( inShadow ) {\n        return light.I_a * mat.k_a;\n    }\n    else {\n        vec3 R = reflect( -L, N );\n        float N_dot_L = max( 0.0, dot( N, L ) );\n        float R_dot_V = max( 0.0, dot( R, V ) );\n        float R_dot_V_pow_n = ( R_dot_V == 0.0 )? 0.0 : pow( R_dot_V, mat.n );\n        \n        return light.I_a * mat.k_a +\n        light.I_source * (mat.k_d * N_dot_L + mat.k_r * R_dot_V_pow_n);\n    }\n}\n\n\n/////////////////////////////////////////////////////////////////////////////\n// Casts a ray into the scene and returns color computed at the nearest\n// intersection point. The color is the sum of light from all light sources,\n// each computed using Phong Lighting Model, with consideration of\n// whether the interesection point is being shadowed from the light.\n// If there is no interesection, returns the background color, and outputs\n// hasHit as false.\n// If there is intersection, returns the computed color, and outputs\n// hasHit as true, the 3D position of the intersection (hitPos), the\n// normal vector at the intersection (hitNormal), and the k_rg value\n// of the material of the intersected object.\n/////////////////////////////////////////////////////////////////////////////\nvec3 CastRay( in Ray_t ray,\n             out bool hasHit, out vec3 hitPos, out vec3 hitNormal, out vec3 k_rg )\n{\n    // Find whether and where the ray hits some object.\n    // Take the nearest hit point.\n    \n    bool hasHitSomething = false;\n    float nearest_t = DEFAULT_TMAX;   // The ray parameter t at the nearest hit point.\n    vec3 nearest_hitPos;              // 3D position of the nearest hit point.\n    vec3 nearest_hitNormal;           // Normal vector at the nearest hit point.\n    int nearest_hitMatID;             // MaterialID of the object at the nearest hit point.\n    \n    float temp_t;\n    vec3 temp_hitPos;\n    vec3 temp_hitNormal;\n    bool temp_hasHit;\n    \n    /////////////////////////////////////////////////////////////////////////////\n    // TASK:\n    // * Try interesecting input ray with all the planes and spheres,\n    //   and record the front-most (nearest) interesection.\n    // * If there is interesection, need to record hasHitSomething,\n    //   nearest_t, nearest_hitPos, nearest_hitNormal, nearest_hitMatID.\n    /////////////////////////////////////////////////////////////////////////////\n    /////////////////////////////////\n    // TASK: WRITE YOUR CODE HERE. //\n    for( int j = 0; j < NUM_SPHERES; ++j )//sphere intersect\n    {\n        temp_hasHit =  IntersectSphere(Sphere[j],ray,DEFAULT_TMIN,DEFAULT_TMAX);\n        if(temp_hasHit == false)\n            continue;\n        else{\n            IntersectSphere(Sphere[j],ray,DEFAULT_TMIN,DEFAULT_TMAX,temp_t,temp_hitPos,temp_hitNormal);\n            if(hasHitSomething == false && temp_hasHit == true)\n                hasHitSomething = true;\n            if(temp_t < nearest_t){\n                nearest_t = temp_t;\n                nearest_hitPos = temp_hitPos;\n                nearest_hitNormal = temp_hitNormal;\n                nearest_hitMatID = Sphere[j].materialID;\n            }\n        }\n    }\n    \n    for( int j = 0; j < NUM_PLANES; ++j )//sphere intersect\n    {\n        temp_hasHit =  IntersectPlane(Plane[j],ray,DEFAULT_TMIN,DEFAULT_TMAX);\n        if(temp_hasHit == false)\n            continue;\n        else{\n            IntersectPlane(Plane[j],ray,DEFAULT_TMIN,DEFAULT_TMAX,temp_t,temp_hitPos,temp_hitNormal);\n            if(hasHitSomething == false && temp_hasHit == true)\n                hasHitSomething = true;\n            if(temp_t < nearest_t){\n                nearest_t = temp_t;\n                nearest_hitPos = temp_hitPos;\n                nearest_hitNormal = temp_hitNormal;\n                nearest_hitMatID = Plane[j].materialID;\n            }\n        }\n    }\n    /////////////////////////////////\n    \n    \n    \n    // One of the output results.\n    hasHit = hasHitSomething;\n    if ( !hasHitSomething ) return BACKGROUND_COLOR;\n    \n    vec3 I_local = vec3( 0.0 );// Result color will be accumulated here.\n    /////////////////////////////////////////////////////////////////////////////\n    // TASK:\n    // * Accumulate lighting from each light source on the nearest hit point.\n    //   They are all accumulated into I_local.\n    // * For each light source, make a shadow ray, and check if the shadow ray\n    //   intersects any of the objects (the planes and spheres) between the\n    //   nearest hit point and the light source.\n    // * Then, call PhongLighting() to compute lighting for this light source.\n    /////////////////////////////////////////////////////////////////////////////\n    \n    /////////////////////////////////\n    // TASK: WRITE YOUR CODE HERE. //\n    Ray_t shadowray;\n    shadowray.o = nearest_hitPos;\n    bool inShadow;\n    bool inshadowtemp;\n    vec3 lightvec;\n    //make shadowray and calculate I_local\n    for( int i = 0; i < NUM_LIGHTS; ++i)//sphere intersect\n    {\n        inShadow = false;\n        shadowray.d = normalize(Light[i].position - shadowray.o);\n        lightvec = shadowray.d;\n        \n        for( int j = 0; j < NUM_SPHERES; ++j )//sphere intersect\n        {\n            inshadowtemp = IntersectSphere(Sphere[j],shadowray,DEFAULT_TMIN,DEFAULT_TMAX);\n            if(inShadow == false && inshadowtemp == true)\n                inShadow = true;\n            \n        }\n        //get I_local\n        I_local += PhongLighting(lightvec, nearest_hitNormal, -ray.d, inShadow,\n                                 Material[nearest_hitMatID], Light[i]);\n    }\n    \n    /////////////////////////////////\n    \n    // Populate output results.\n    hitPos = nearest_hitPos;\n    hitNormal = nearest_hitNormal;\n    k_rg = Material[nearest_hitMatID].k_rg;\n    \n    return I_local;\n}\n\n\n\n/////////////////////////////////////////////////////////////////////////////\n// Execution of fragment shader starts here.\n// 1. Initializes the scene.\n// 2. Compute a primary ray for the current pixel (fragment).\n// 3. Trace ray into the scene with NUM_ITERATIONS recursion levels.\n/////////////////////////////////////////////////////////////////////////////\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    InitScene();\n    \n    \n    \n    \n    // Scale pixel 2D position such that its y coordinate is in [-1.0, 1.0].\n    vec2 pixel_pos = (2.0 * fragCoord.xy - iResolution.xy) / iResolution.y;\n    \n    // Position the camera.\n    vec3 cam_pos;\n    vec3 cam_lookat;\n    vec3 cam_up_vec = vec3( 0.0, 1.0, 0.0 );\n    cam_pos = vec3( -1.5, 0.8, 3. );\n    cam_lookat = vec3( 1.5, 1.0, -0.3 );\n    if(iTime>7.5&&iTime<19.2){\n        cam_pos = vec3(1.5-0.058*(iTime-7.5), 1.0-0.014*(iTime-7.5), 3. );\n        cam_lookat = vec3( 1.5*sin(0.08*iTime), 1.0, -0.3*cos(0.08*iTime) );\n    }\n    else if(iTime>36.3 && iTime<47.5){\n        cam_pos = vec3(1.5-sin(0.1*iTime), 1.0, 3.-cos(0.1*iTime) );\n        cam_lookat = vec3( 1.5*sin(0.08*iTime), 1.0, -0.3*cos(0.08*iTime) );\n    }\n    else if((iTime>47.5&&iTime<77.5)||iTime>104.87){\n        cam_pos = vec3(centerx + 2.0 * sin(iTime), centery, centerz + 2.0 * cos(iTime));\n        cam_lookat = vec3(centerx, centery / 2.0, centerz);\n    }\n    \n    \n    // Set up camera coordinate frame in world space.\n    vec3 cam_z_axis = normalize( cam_pos - cam_lookat );\n    vec3 cam_x_axis = normalize( cross(cam_up_vec, cam_z_axis) );\n    vec3 cam_y_axis = normalize( cross(cam_z_axis, cam_x_axis));\n    \n    // Create primary ray.\n    float pixel_pos_z = -1.0 / tan(FOVY / 2.0);\n    Ray_t pRay;\n    pRay.o = cam_pos;\n    pRay.d = normalize( pixel_pos.x * cam_x_axis  +  pixel_pos.y * cam_y_axis  +  pixel_pos_z * cam_z_axis );\n    \n    \n    // Start Ray Tracing.\n    // Use iterations to emulate the recursion.\n    \n    vec3 I_result = vec3( 0.0 );\n    vec3 compounded_k_rg = vec3( 1.0 );\n    Ray_t nextRay = pRay;\n    \n    for ( int level = 0; level <= NUM_ITERATIONS; level++ )\n    {\n        bool hasHit;\n        vec3 hitPos, hitNormal, k_rg;\n        \n        vec3 I_local = CastRay( nextRay, hasHit, hitPos, hitNormal, k_rg );\n        \n        I_result += compounded_k_rg * I_local;\n        \n        if ( !hasHit ) break;\n        \n        compounded_k_rg *= k_rg;\n        \n        nextRay = Ray_t( hitPos, normalize( reflect(nextRay.d, hitNormal) ) );\n    }\n    \n    fragColor = vec4( I_result, 1.0 );\n}\n\n", "image_inputs": [{"id": "XsBXDG", "previewfilepath": "https://soundcloud.com/allanteng/dy-mix", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0, "src": "https://soundcloud.com/allanteng/dy-mix", "ctype": "musicstream"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MltyW7.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[2040, 2555, 2604, 2604, 3558], [3559, 3559, 3574, 3574, 5631], [5633, 5673, 5716, 5716, 5955], [5956, 5956, 5999, 5999, 6452], [6453, 6475, 6519, 6519, 6983], [6984, 6984, 7028, 7028, 7492], [7493, 7518, 7561, 7561, 7933], [7934, 7958, 8002, 8002, 8369], [8370, 8370, 8414, 8414, 8750], [8752, 8776, 8818, 8818, 9270], [9271, 9294, 9336, 9336, 9572], [9573, 9594, 9637, 9637, 10138], [10139, 10139, 10182, 10182, 10678], [10679, 10703, 10746, 10746, 11086], [11087, 11087, 11130, 11130, 11465], [11467, 11491, 11533, 11533, 11913], [11916, 11916, 11953, 11953, 12485], [12489, 12489, 12526, 12526, 13058], [13060, 13060, 13098, 13098, 13630], [13632, 13632, 13660, 13660, 13701], [13703, 13703, 13731, 13731, 13767], [13770, 13786, 13826, 13826, 14452], [14454, 14454, 14493, 14493, 17236], [17238, 17252, 17290, 17290, 17478], [17480, 17480, 17516, 17516, 17966], [17968, 18150, 18169, 18169, 29054], [29058, 29554, 29707, 29707, 30041], [30045, 30377, 30460, 30460, 30672], [30676, 31194, 31350, 31464, 32485], [32489, 32822, 32907, 33021, 33670], [33675, 34029, 34158, 34158, 34571], [34574, 35363, 35475, 35566, 39875], [39879, 40240, 40297, 40297, 42430]], "test": "untested"}
{"id": "MltyWN", "name": "What the hell is this even", "author": "WAHa_06x36", "description": "Please don't ask me.", "tags": ["idontknow", "primarycolours", "notactuallyaball"], "likes": 7, "viewed": 1362, "published": "Public API", "date": "1532727769", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 position = (2.0 * fragCoord.xy - iResolution.xy) / min(iResolution.x, iResolution.y) * 1.6;\n\tfloat fade = 1.0;\n\tfloat r = length(position);\n\tif(r < 1.0) {\n\t\tfloat r2 = asin(r);\n\t\tposition = position * r2 / r / 3.14 * 2.0;\n\t\tfade = 1.0 - pow(r, 4.0);\n\t} else {\n\t\tposition /= (r - 0.1);\n\t\tfade = exp(4.0 * (-r + 1.0));\n\t}\n\n\tfloat t1 = 0.35 * iTime;\n\tfloat t2 = 0.2 * iTime;\n\tposition += vec2(cos(t2), sin(t2));\n\tposition = mat2(cos(t1), sin(t1), -sin(t1), cos(t1)) * position;\n\tfloat t3 = 0.21 * iTime;\n\tfloat t4 = 0.16 * iTime;\n\tposition += vec2(cos(t3), sin(t3));\n\tposition = mat2(cos(t4), sin(t4), -sin(t4), cos(t4)) * position;\n\n\tposition *= 15.0;\n\tfloat t = sin(position.x) * 3.0 + sin(position.y);\n\t\n\tvec3 A = vec3(0.5);\n\tvec3 B = vec3(0.5);\n\tvec3 C = vec3(1.0, 0.7, 0.4) * 0.2;\n\tvec3 D = vec3(0.1, 0.15, 0.40);\n\tvec3 colour = A + B * cos(6.28318 * (C * t + D));\n\tcolour = pow(colour, vec3(5.0)) * 6.0;\n\n\tfragColor = vec4(colour * fade, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MltyWN.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 1012]], "test": "untested"}
{"id": "Mltyz8", "name": "Expanding Dot Grid", "author": "momoro", "description": "Practice #3", "tags": ["bookofshaders"], "likes": 14, "viewed": 327, "published": "Public", "date": "1531594152", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    float u_time = iTime;\n    \n    vec2 st = fragCoord.xy/iResolution.xy;\n\tst.x *= iResolution.x/iResolution.y;\n\tst.x -= .3;\n    \n        \n    // UNDULATING RING\n\t\n    // Coords to center\n    vec2 rst = st - vec2(.5);\n    \n    // Displace with sin to get blobby\n    rst += sin(u_time + atan(sin(u_time/2.), cos(u_time))) / 20.;\n\n\n    float ringRadius = sin(u_time)/10. + .4;\n    \n    // Black circle where outer is white\n    float outerWhite = distance(rst, vec2(0));\n\t// outerWhite -= .3*sin(atan(rst.x,rst.y)*.2);\n    \n    outerWhite = smoothstep(ringRadius-.4, ringRadius-.3, outerWhite);\n    float rc = outerWhite;\n    \n    // White circle where outer is black\n    float outerBlack = distance(rst, vec2(0)); // TODO don't replicate this \n    outerBlack = smoothstep(ringRadius,ringRadius-0.788,outerBlack);\n    //outerBlack -= sin(rst.y+.1);\n\n    \n    // Multiply to get a ring\n    rc = outerBlack * outerWhite;\n    \n    \n    \n\n    // INITIAL DOTS\n    float divisions = 30.;\n\n    // Create grid\n    vec2 dst = st * divisions;\n    \n    // Divide into squares\n    dst = mod(dst,1.);\n    \n    // Create circles\n    float c;\n    c = distance(dst, vec2(.5));\n\n    \n    // Use ring to size dots.\n    float rcClamped = clamp(rc, .01, .6);\n\tc = smoothstep(rcClamped, rcClamped+.1, c);\n    \n        \n    // COLOR\n    float inverted  = 1.0-c;\n    \n    vec3 colorA = vec3(1.000,0.082,0.621);\n    vec3 colorB = vec3(1.000,0.152,0.009);\n    vec3 cPos = mix(colorA, colorB, st.x);\n    \n    vec3 color = cPos * inverted;\n    \n    vec3 colored = color + vec3(c);\n    colored = vec3(1.) - colored;\n    \n    colored = colored * clamp(rc*2.5, .4, 1.);\n\n    fragColor = vec4(vec3(colored),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Mltyz8.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 1743]], "test": "untested"}
{"id": "MsGBDV", "name": "Light saber fight", "author": "FlorianDuf", "description": "Light saber fight fort the fun.", "tags": ["starwarslightsaber"], "likes": 11, "viewed": 618, "published": "Public", "date": "1530533711", "time_retrieved": "2021-10-01T00:00:00", "image_code": "struct Segment {\n  \n    vec2 p1;\n    vec2 p2;\n};\n\n\nfloat add(in vec3 col1, in vec3 col2)\n{\n \n   if(col1 != vec3(0.0))\n       return 0.0;\n    \n   if ( col2 != vec3(0.0) )\n       return 1.0;\n    \n    return 0.5;\n}\n\nbool intersection(in Segment s1, in Segment s2, out vec2 pres)\n{\n\n    pres = vec2(0.0);\n    \n    vec2 I = s1.p2-s1.p1;\n    vec2 J = s2.p2-s2.p1;\n    float div = I.x*J.y-I.y*J.x;\n\n    \n    if ( div == 0.0 )\n        return false;\n    \n    float m = - ( -I.x*s1.p1.y + I.x* s2.p1.y+ I.y * s1.p1.x - I.y * s2.p1.x) / div;\n    float k = - ( s1.p1.x * J.y - s2.p1.x*J.y - J.x * s1.p1.y + J.x * s2.p1.y) / div;\n    \n    if ( 0.0 < m && m < 1.0 && 0.0 < k && k < 1.0 )\n    {\n    \tpres = s1.p1 + k * I;\n    \n    \treturn true;\n    }\n    \n    return false;\n}\n\nfloat distLine(in Segment s, in vec2 p)\n{\n    vec2 p1p2 = s.p2-s.p1;\n    \n    if (p1p2 == vec2(0.0) )\n        return 0.0;\n    \n \t//return dot(p1p2, p-s.p1) / dot(p1p2, p1p2);\n    vec2 k = dot(p1p2, p-s.p1) / dot(p1p2, p1p2) * p1p2 + s.p1;\n    \n    if ( (distance(s.p1, k) + distance(s.p2, k)) >= length(p1p2) + 0.001 ) \n    \treturn min(distance(s.p1, p),distance(s.p2, p));\n\n    \n    return length((dot(p1p2, p-s.p1) / dot(p1p2, p1p2) * p1p2 + s.p1)-p);    \n}\n\nfloat dist(in vec2 uv, in vec2 p, in float level)\n{\n    float h = level;\n    uv = pow(abs(uv - p), vec2(h));\n    return pow( uv.x + uv.y, 1./h) ;  \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    vec2 uv = fragCoord/iResolution.x;\n\n    \n    \n \tfloat speed = 10.50;   \n    \n    Segment s = Segment(0.1*vec2(sin(speed*iTime*0.2415), sin(speed*iTime*0.16485))+vec2(0.1), 0.4*vec2(sin(speed*iTime*0.25), sin(speed*iTime*0.6485))+vec2(0.5));\n    vec3 col = mix(vec3(0.2, 0.5, 1.0), vec3(0.0), min(1.0,30.0*distLine(s, uv)));\n    col = mix(vec3(1.0), col, min(1.0, 100.0*distLine(s, uv)));\n    \n    Segment s2 = Segment(0.1*vec2(sin(speed*iTime*0.34985)+8.0, sin(speed*iTime*0.52144))+vec2(0.1), 0.3*vec2(sin(speed*iTime*0.3985), sin(speed*iTime*0.5214))+vec2(0.5));\n    vec3 col2 = mix(vec3(1.0, 0.1, 0.2), vec3(0.0), min(1.0, 30.0*distLine(s2, uv)));\n    col2 = mix(vec3(1.0), col2, min(1.0, 100.0*distLine(s2, uv)));\n\n    \n    col = mix(col, col2, add(col, col2) );\n    \n    \n    \n    col =  max(col, col2);\n    \n    vec2 intersec;\n    \n    if (  intersection(s, s2, intersec) )\n    {\n        \n    \tcol = min(col +  mix(vec3(0.0), vec3((sin(iTime) * 0.5 + 0.5), 0.5,1.0) ,1.0/dist(uv, intersec, 5.0 * ( 0.5 * sin(854575852656.0*iTime) + 0.55)) / 15.0), vec3(1.0));\n    }\n    \n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MsGBDV.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[51, 51, 90, 90, 211], [213, 213, 277, 277, 760], [762, 762, 803, 803, 1221], [1223, 1223, 1274, 1274, 1372], [1374, 1374, 1431, 1431, 2575]], "test": "untested"}
{"id": "MsGBWt", "name": "Pixelation Test 2", "author": "Firzen_", "description": "Seeing what I can do with pixelation", "tags": ["pixelation"], "likes": 0, "viewed": 66, "published": "Public", "date": "1530997344", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float activeSquare(vec2 squareIndex)\n{\n    if(cos(squareIndex.x)*sin(0.2f*squareIndex.x+0.1*squareIndex.y+1.*iTime)>0.5)\n        return 0.;\n    return mod(squareIndex.x+squareIndex.y + floor(2.*iTime),2.);\n}\n\nfloat pullDown(vec2 uv)\n{\n    vec2 spherePos = vec2(0.5,0.)+0.25*vec2(cos(iTime),sin(iTime));\n    float radius = 0.1f;\n    float distortion = max(0.,1.-pow(length(spherePos-uv),2.));\n    return distortion;\n}\n\nvec3 squareColor(vec2 square)\n{\n    return 0.5 + 0.5*cos(3.*floor(iTime)+square.xyx+vec3(0,2,4));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    const float scale = 20.;\n    // Normalized pixel coordinates (from 0 to 1)\n    \n    vec2 uv = fragCoord/iResolution.xy;\n    uv.y += pullDown(uv);\n    \n    vec2 intUV = floor(scale*uv);\n\n    // Time varying pixel color\n    vec3 col = squareColor(intUV);\n\n    // Output to screen\n    fragColor = vec4(col,1.0)*activeSquare(intUV);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MsGBWt.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 38, 38, 207], [209, 209, 234, 234, 416], [418, 418, 449, 449, 517], [519, 519, 576, 576, 911]], "test": "untested"}
{"id": "MsKBWV", "name": "Polar Simplex Noise", "author": "pixelfiend", "description": "Polar simplex noise\nSpeed: drag up / down\nSize: drag left / right\n", "tags": ["noise", "simplex", "polar"], "likes": 1, "viewed": 73, "published": "Public", "date": "1530642949", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//\n// Description : Array and textureless GLSL 2D/3D/4D simplex \n//               noise functions.\n//      Author : Ian McEwan, Ashima Arts.\n//  Maintainer : stegu\n//     Lastmod : 20110822 (ijm)\n//     License : Copyright (C) 2011 Ashima Arts. All rights reserved.\n//               Distributed under the MIT License. See LICENSE file.\n//               https://github.com/ashima/webgl-noise\n//               https://github.com/stegu/webgl-noise\n// \n\nvec3 mod289(vec3 x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 mod289(vec4 x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 permute(vec4 x) {\n     return mod289(((x*34.0)+1.0)*x);\n}\n\nvec4 taylorInvSqrt(vec4 r){\n  return 1.79284291400159 - 0.85373472095314 * r;\n}\n\nfloat snoise(vec3 v){ \n  const vec2  C = vec2(1.0/6.0, 1.0/3.0) ;\n  const vec4  D = vec4(0.0, 0.5, 1.0, 2.0);\n\n  // First corner\n  vec3 i  = floor(v + dot(v, C.yyy) );\n  vec3 x0 =   v - i + dot(i, C.xxx) ;\n\n  // Other corners\n  vec3 g = step(x0.yzx, x0.xyz);\n  vec3 l = 1.0 - g;\n  vec3 i1 = min( g.xyz, l.zxy );\n  vec3 i2 = max( g.xyz, l.zxy );\n\n  //   x0 = x0 - 0.0 + 0.0 * C.xxx;\n  //   x1 = x0 - i1  + 1.0 * C.xxx;\n  //   x2 = x0 - i2  + 2.0 * C.xxx;\n  //   x3 = x0 - 1.0 + 3.0 * C.xxx;\n  vec3 x1 = x0 - i1 + C.xxx;\n  vec3 x2 = x0 - i2 + C.yyy; // 2.0*C.x = 1/3 = C.y\n  vec3 x3 = x0 - D.yyy;      // -1.0+3.0*C.x = -0.5 = -D.y\n\n  // Permutations\n  i = mod289(i); \n  vec4 p = permute( permute( permute( \n             i.z + vec4(0.0, i1.z, i2.z, 1.0 ))\n           + i.y + vec4(0.0, i1.y, i2.y, 1.0 )) \n           + i.x + vec4(0.0, i1.x, i2.x, 1.0 ));\n\n  // Gradients: 7x7 points over a square, mapped onto an octahedron.\n  // The ring size 17*17 = 289 is close to a multiple of 49 (49*6 = 294)\n  float n_ = 0.142857142857; // 1.0/7.0\n  vec3  ns = n_ * D.wyz - D.xzx;\n\n  vec4 j = p - 49.0 * floor(p * ns.z * ns.z);  //  mod(p,7*7)\n\n  vec4 x_ = floor(j * ns.z);\n  vec4 y_ = floor(j - 7.0 * x_ );    // mod(j,N)\n\n  vec4 x = x_ *ns.x + ns.yyyy;\n  vec4 y = y_ *ns.x + ns.yyyy;\n  vec4 h = 1.0 - abs(x) - abs(y);\n\n  vec4 b0 = vec4( x.xy, y.xy );\n  vec4 b1 = vec4( x.zw, y.zw );\n\n  //vec4 s0 = vec4(lessThan(b0,0.0))*2.0 - 1.0;\n  //vec4 s1 = vec4(lessThan(b1,0.0))*2.0 - 1.0;\n  vec4 s0 = floor(b0)*2.0 + 1.0;\n  vec4 s1 = floor(b1)*2.0 + 1.0;\n  vec4 sh = -step(h, vec4(0.0));\n\n  vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy ;\n  vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww ;\n\n  vec3 p0 = vec3(a0.xy,h.x);\n  vec3 p1 = vec3(a0.zw,h.y);\n  vec3 p2 = vec3(a1.xy,h.z);\n  vec3 p3 = vec3(a1.zw,h.w);\n\n  //Normalise gradients\n  vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));\n  p0 *= norm.x;\n  p1 *= norm.y;\n  p2 *= norm.z;\n  p3 *= norm.w;\n\n  // Mix final noise value\n  vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n  m = m * m;\n  return 42.0 * dot( m*m, vec4( dot(p0,x0), dot(p1,x1), \n                                dot(p2,x2), dot(p3,x3) ) );\n}\n\nvec2 cartesian2Polar(vec2 fragCoord){\n    vec2 relativePos = fragCoord.xy - (iResolution.xy / 2.0);\n    \n    // mirror\n    //if(relativePos.y > 0.) relativePos.y *= -1.;\n    \n    vec2 polar;\n    polar.y = sqrt(relativePos.x * relativePos.x + relativePos.y * relativePos.y);\n    polar.y /= iResolution.x / 2.0;\n    polar.y = 1.0 - polar.y;\n\n    polar.x = atan(relativePos.y, relativePos.x);\n    polar.x -= 1.57079632679;\n    if(polar.x < 0.0){\n\t\tpolar.x += 6.28318530718;\n    }\n    polar.x /= 6.28318530718;\n    polar.x = 1.0 - polar.x;\n    return polar;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    \n    vec2 polar = cartesian2Polar(fragCoord);\n    vec2 uvMouse = iMouse.xy / iResolution.xy;\n    float size = uvMouse.x * 30. + 1.;\n    float speed = uvMouse.y * 3. + .3;\n    float val = snoise(vec3(polar.x * size, polar.y * size, iTime * speed));\n\tfragColor = vec4(val);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MsKBWV.jpg", "access": "shaders20k", "license": "mit", "functions": [[0, 450, 471, 471, 520], [522, 522, 543, 543, 592], [594, 594, 616, 616, 656], [658, 658, 685, 685, 737], [739, 739, 760, 760, 2918], [2920, 2920, 2957, 2957, 3475], [3478, 3478, 3534, 3534, 3812]], "test": "untested"}
{"id": "Mstyz8", "name": "Torus_Thingy_16", "author": "balkhan", "description": "torus", "tags": ["raymarching", "torus"], "likes": 5, "viewed": 111, "published": "Public", "date": "1532481807", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/*\n* License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n* Created by bal-khan\n*/\n\nvec2\tmarch(vec3 pos, vec3 dir);\nvec3\tcamera(vec2 uv);\nvoid\trotate(inout vec2 v, float angle);\nvec3\tcalcNormal( in vec3 pos, float e, vec3 dir);\nfloat\tloop_circle(vec3 p);\nfloat\tcircle(vec3 p, float phase);\nfloat\tsdTorus( vec3 p, vec2 t, float phase );\nfloat\tmylength(vec2 p);\nfloat\tmylength(vec3 p);\nfloat\tnrand( vec2 n );\n\nfloat \tt;\t\t\t// time\nvec3\tret_col;\t// torus color\nvec3\th; \t\t\t// light amount\n\n#define I_MAX\t\t200.\n#define E\t\t\t0.0001\n#define FAR\t\t\t110.\n#define PI\t\t\t3.14159\n#define TAU\t\t\tPI*2.\n\nvoid mainImage(out vec4 c_out, in vec2 f)\n{\n    t  = iTime*.125;\n    vec3\tcol = vec3(0., 0., 0.);\n\tvec2 R = iResolution.xy,\n          uv  = vec2(f-R/2.) / R.y;\n\tvec3\tdir = camera(uv);\n    vec3\tpos = vec3(.0, .0, 60.0);\n\n    h*=0.;\n    vec2\tinter = (march(pos, dir));\n    if (inter.y >= FAR)\n        ret_col = vec3(.90, .82, .70);\n    col.xyz = ret_col*(1.-inter.x*.005);\n    col += h*.005;\n    c_out =  vec4(col,1.0);\n}\n\n/*\n* Leon's mod polar from : https://www.shadertoy.com/view/XsByWd\n*/\n\nvec2 modA (vec2 p, float count) {\n    float an = TAU/count;\n    float a = atan(p.y,p.x)+an*.5;\n    a = mod(a, an)-an*.5;\n    return vec2(cos(a),sin(a))*length(p);\n}\n\n/*\n* end mod polar\n*/\n\nfloat\tcube(vec3 p)\n{\n\treturn max(abs(p.x), max(abs(p.y), abs(p.z)));\n}\n\nfloat\tscene(vec3 p)\n{  \n    p.z += -50.;\n    float\tvar;\n    float\tmind = 1e5;\n    float\tcage = 1e5;\n    p.z -= sin(t*2.+3.14)*4.;\n    vec3 op = p;\n    vec2 q = vec2( ( length(p.xy) )-20.,p.z);\n    \n    cage = mylength(q)-.25;\n    \n    p = op;\n    q = vec2( length(p.xz)-4., p.y );\n\n    float ball = 1e5;\n    p = op;\n    p.xz = modA(p.xz, 200.);\n    p.x -= 4.;\n    rotate(p.xy, iTime*-.25);\n    p.yx = modA(p.yx, 100.);\n    p.y -= 4.;\n\n    rotate(p.zx, PI*.25+.0*iTime);\n    ball = min(ball, (length(p.xy)-.0101) );\n    //rotate(p.zx, 1.57*.5+.0*iTime);\n    ball = min(ball, (length(p.zy)-.0101) );\n    \n    rotate(p.zx, PI*.25+.0*iTime);\n    ball = min(ball, (length(p.zy)-.0101));\n    ball = min(ball, (length(p.xy)-.0101));\n    \n    mind = min(mind, ball);\n\n    h += vec3(.50,.1250,1.)*vec3(1.)*.0125/(.001+mind*mind);\n    h -= vec3(.05,.05,1.)*vec3(1.)*.0125/(.0+mind*mind);\n    return (mind);\n}\n\nvec2\tmarch(vec3 pos, vec3 dir)\n{\n    vec2\tdist = vec2(0.0, 0.0);\n    vec3\tp = vec3(0.0, 0.0, 0.0);\n    vec2\ts = vec2(0.0, 0.0);\n\n\t    for (float i = -1.; i < I_MAX; ++i)\n\t    {\n\t    \tp = pos + dir * dist.y;\n\t        dist.x = scene(p);\n\t        dist.y += dist.x*1.; // makes artefacts disappear\n\t        if (dist.x < E || dist.y > FAR)\n            {\n                break;\n            }\n\t        s.x++;\n    }\n    s.y = dist.y;\n    return (s);\n}\n\n// Utilities\n\nfloat\tmylength(vec2 p)\n{\n\tfloat\tret;\n\n    ret = max( abs(p.x)+.5*abs(p.y), abs(p.y)+.5*abs(p.x) );\n    \n    return ret;\n}\n\nfloat\tmylength(vec3 p)\n{\n\tfloat\tret;\n\n    ret = max( abs(p.x)+.5*abs(p.y), abs(p.y)+.5*abs(p.x) );\n    ret = max(abs(p.z)+.5*abs(p.x), ret);\n    return ret;\n}\n\nvoid rotate(inout vec2 v, float angle)\n{\n\tv = vec2(cos(angle)*v.x+sin(angle)*v.y,-sin(angle)*v.x+cos(angle)*v.y);\n}\n\nvec2\trot(vec2 p, vec2 ang)\n{\n\tfloat\tc = cos(ang.x);\n    float\ts = sin(ang.y);\n    mat2\tm = mat2(c, -s, s, c);\n    \n    return (p * m);\n}\n\nvec3\tcamera(vec2 uv)\n{\n    float\t\tfov = 1.;\n\tvec3\t\tforw  = vec3(0.0, 0.0, -1.0);\n\tvec3    \tright = vec3(1.0, 0.0, 0.0);\n\tvec3    \tup    = vec3(0.0, 1.0, 0.0);\n\n    return (normalize((uv.x) * right + (uv.y) * up + fov * forw));\n}\n\nvec3 calcNormal( in vec3 pos, float e, vec3 dir)\n{\n    vec3 eps = vec3(e,0.0,0.0);\n\n    return normalize(vec3(\n           march(pos+eps.xyy, dir).y - march(pos-eps.xyy, dir).y,\n           march(pos+eps.yxy, dir).y - march(pos-eps.yxy, dir).y,\n           march(pos+eps.yyx, dir).y - march(pos-eps.yyx, dir).y ));\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Mstyz8.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[451, 616, 659, 659, 1035], [1037, 1108, 1141, 1141, 1272], [1274, 1297, 1317, 1317, 1367], [1369, 1369, 1390, 1390, 2267], [2269, 2269, 2301, 2301, 2712], [2714, 2728, 2752, 2752, 2849], [2851, 2851, 2875, 2875, 3009], [3011, 3011, 3051, 3051, 3126], [3128, 3128, 3156, 3156, 3264], [3266, 3266, 3288, 3288, 3494], [3496, 3496, 3546, 3546, 3809]], "test": "untested"}
{"id": "MsVfD3", "name": "Height map profile", "author": "guins", "description": "Elevation/Height map profile tests", "tags": ["heightmap", "displacementmap", "elevationmap"], "likes": 9, "viewed": 179, "published": "Public", "date": "1530883955", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//\n// Description : Array and textureless GLSL 2D/3D/4D simplex \n//               noise functions.\n//      Author : Ian McEwan, Ashima Arts.\n//  Maintainer : ijm\n//     Lastmod : 20110822 (ijm)\n//     License : Copyright (C) 2011 Ashima Arts. All rights reserved.\n//               Distributed under the MIT License. See LICENSE file.\n//               https://github.com/ashima/webgl-noise\n// \n\nvec3 mod289(vec3 x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 mod289(vec4 x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 permute(vec4 x) {\n     return mod289(((x*34.0)+1.0)*x);\n}\n\nvec4 taylorInvSqrt(vec4 r)\n{\n  return 1.79284291400159 - 0.85373472095314 * r;\n}\n\nfloat snoise(vec3 v)\n  { \n  const vec2  C = vec2(1.0/6.0, 1.0/3.0) ;\n  const vec4  D = vec4(0.0, 0.5, 1.0, 2.0);\n\n// First corner\n  vec3 i  = floor(v + dot(v, C.yyy) );\n  vec3 x0 =   v - i + dot(i, C.xxx) ;\n\n// Other corners\n  vec3 g = step(x0.yzx, x0.xyz);\n  vec3 l = 1.0 - g;\n  vec3 i1 = min( g.xyz, l.zxy );\n  vec3 i2 = max( g.xyz, l.zxy );\n\n  //   x0 = x0 - 0.0 + 0.0 * C.xxx;\n  //   x1 = x0 - i1  + 1.0 * C.xxx;\n  //   x2 = x0 - i2  + 2.0 * C.xxx;\n  //   x3 = x0 - 1.0 + 3.0 * C.xxx;\n  vec3 x1 = x0 - i1 + C.xxx;\n  vec3 x2 = x0 - i2 + C.yyy; // 2.0*C.x = 1/3 = C.y\n  vec3 x3 = x0 - D.yyy;      // -1.0+3.0*C.x = -0.5 = -D.y\n\n// Permutations\n  i = mod289(i); \n  vec4 p = permute( permute( permute( \n             i.z + vec4(0.0, i1.z, i2.z, 1.0 ))\n           + i.y + vec4(0.0, i1.y, i2.y, 1.0 )) \n           + i.x + vec4(0.0, i1.x, i2.x, 1.0 ));\n\n// Gradients: 7x7 points over a square, mapped onto an octahedron.\n// The ring size 17*17 = 289 is close to a multiple of 49 (49*6 = 294)\n  float n_ = 0.142857142857; // 1.0/7.0\n  vec3  ns = n_ * D.wyz - D.xzx;\n\n  vec4 j = p - 49.0 * floor(p * ns.z * ns.z);  //  mod(p,7*7)\n\n  vec4 x_ = floor(j * ns.z);\n  vec4 y_ = floor(j - 7.0 * x_ );    // mod(j,N)\n\n  vec4 x = x_ *ns.x + ns.yyyy;\n  vec4 y = y_ *ns.x + ns.yyyy;\n  vec4 h = 1.0 - abs(x) - abs(y);\n\n  vec4 b0 = vec4( x.xy, y.xy );\n  vec4 b1 = vec4( x.zw, y.zw );\n\n  //vec4 s0 = vec4(lessThan(b0,0.0))*2.0 - 1.0;\n  //vec4 s1 = vec4(lessThan(b1,0.0))*2.0 - 1.0;\n  vec4 s0 = floor(b0)*2.0 + 1.0;\n  vec4 s1 = floor(b1)*2.0 + 1.0;\n  vec4 sh = -step(h, vec4(0.0));\n\n  vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy ;\n  vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww ;\n\n  vec3 p0 = vec3(a0.xy,h.x);\n  vec3 p1 = vec3(a0.zw,h.y);\n  vec3 p2 = vec3(a1.xy,h.z);\n  vec3 p3 = vec3(a1.zw,h.w);\n\n//Normalise gradients\n  vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));\n  p0 *= norm.x;\n  p1 *= norm.y;\n  p2 *= norm.z;\n  p3 *= norm.w;\n\n// Mix final noise value\n  vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n  m = m * m;\n  return 42.0 * dot( m*m, vec4( dot(p0,x0), dot(p1,x1), \n                                dot(p2,x2), dot(p3,x3) ) );\n  }\n\n//END ASHIMA /////////////////////////////////////////////////\n\nconst float STEPS = 10.;\nconst float CUTOFF = 0.01; //depth less than this, show white wall\nconst vec2  OFFSET = vec2(0.005,0.005); //drop shadow offset\n\nvec3 hsv2rgb(vec3 c){\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nfloat getNoise(vec2 uv, float t){\n    \n    //given a uv coord and time - return a noise val in range 0 - 1\n    //using ashima noise\n    \n    //octave 1\n    float SCALE = 2.0;\n    float noise = snoise( vec3(uv.x*SCALE + t,uv.y*SCALE + t , 0));\n    \n    //octave 2 - more detail\n    SCALE = 4.0;\n    noise += snoise( vec3(uv.x*SCALE + t,uv.y*SCALE , 0))* .2 ;\n    \n    //move noise into 0 - 1 range    \n    noise = (noise/2. + 0.5);\n    \n    //make deeper rarer\n    //noise = pow(noise,2.);\n    \n    return noise;\n    \n}\n\nfloat getDepth(float n){\n \n    //given a 0-1 value return a depth,\n    //e.g. distance into the hole\n    \n    //remap remaining non-cutoff region to 0 - 1\n\tfloat d = (n - CUTOFF) / (1. - CUTOFF); \n        \n    //step it\n    d = floor(d*STEPS)/STEPS;\n    \n    return d;\n    \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.x;\n    float t = iTime * .1;    \n    vec3 col = vec3(0);\n    \n   \tfloat noise = getNoise(uv, t);\n    \n    if (noise < CUTOFF){\n        \n        //white wall\n        col = vec3(1.,0.937,0.808);//white\n        \n    }else{\n    \n\t\tfloat d = getDepth(noise);\n        \n        //calc HSV color\n        float h = d + 0.2; //rainbow hue\n        float s = 0.5;\n        float v = 0.9 - ( d*0.6); //deeper is darker\n        \n       \t//add bevel\n        \n       \t//get depth at offset position        \n        float noiseOff = getNoise(uv + OFFSET, t);\n        float dOff = getDepth(noiseOff);\n       \t\n        //if depth of this pixel (d) is less (closer) than offset pixel (dOff)\n        //then we are in shadow so darken       \n        v -= d - dOff; \n        \n        if (d == dOff)\n        {\n        \tcol = vec3(1.,0.937,0.808);//white\n        }\n        else\n        {\n            //col = hsv2rgb(vec3(0,0,1));\n        }\n           \n\t}\n    \n    //post proc\n\t//vertical gradient grey\n    //col *= 0.7 + (fragCoord.y/iResolution.y *0.3);\n    \n    //add noise texture\n    //col += (texture(iChannel0, uv * iResolution.x / 256. + iTime * 0.0).r - 0.5) * 0.05;\n    \n    fragColor = vec4(col,1.0);   \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MsVfD3.jpg", "access": "shaders20k", "license": "mit", "functions": [[0, 394, 415, 415, 464], [466, 466, 487, 487, 536], [538, 538, 560, 560, 600], [602, 602, 630, 630, 682], [684, 684, 708, 708, 2854], [2972, 3074, 3095, 3095, 3264], [3266, 3266, 3299, 3417, 3784], [3786, 3786, 3810, 3940, 4061], [4063, 4063, 4120, 4120, 5348]], "test": "untested"}
{"id": "MsyfDt", "name": "okokokok", "author": "lennyjpg", "description": "fffff", "tags": ["ffffff"], "likes": 3, "viewed": 398, "published": "Public API", "date": "1531016429", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec3 rgb2hsb( in vec3 c ){\n    vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);\n    vec4 p = mix(vec4(c.bg, K.wz),\n                 vec4(c.gb, K.xy),\n                 step(c.b, c.g));\n    vec4 q = mix(vec4(p.xyw, c.r),\n                 vec4(c.r, p.yzx),\n                 step(p.x, c.r));\n    float d = q.x - min(q.w, q.y);\n    float e = 1.0e-10;\n    return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)),\n                d / (q.x + e),\n                q.x);\n}\n#define SC(a)  vec2(sin(a),cos(a))\nvoid mainImage( out vec4 O, in vec2 f ){\n    vec2 U = (f-iMouse.xy) / iResolution.y;\n    U*=3.0;\n    vec3 c = vec3(0);\n    for(float i=2., t = iTime*.7;i<38.;i++){\n        U += i/20. * SC(i*11.1+t*.1);\n\t\tc[int(i)%3] += sin(atan(U.x,U.y) + i * 111.32 + t) * .33;\n    }\n    c += vec3(.7,.4,.4);\n    vec3 q = rgb2hsb(c);\n    \n    vec2 uv = fract((f-iMouse.xy) / iResolution.y * 10.0) ;\n    uv+= step( fract(uv.x),.5)*.5;\n    float r = 37.0/iResolution.x;\n    float e = smoothstep(r,r*0.7,length(uv-0.75));\n    \n    float grid = step( length( fract( f.xy / 150.) - .5), .01);\n    O = vec4(q + e - grid, 1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MsyfDt.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 26, 26, 456], [492, 492, 532, 532, 1097]], "test": "untested"}
{"id": "MsyfW3", "name": "dancefloor", "author": "lennyjpg", "description": "asdfasdfsa", "tags": ["asfdasf"], "likes": 8, "viewed": 588, "published": "Public API", "date": "1530801567", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define SC(a)  vec2(sin(a),cos(a))\nvoid mainImage( out vec4 O, in vec2 f ){\n    vec2 U = (f-iMouse.xy) / iResolution.y;\n    for(float i=2., t = iTime*.7;i<38.;i++){\n        U += i/20. * SC(i*11.1+t*.1);\n\t\tO[int(i)%3] += sin(atan(U.x,U.y) + i * 111.32 + t) * .33;\n    }\n    O += vec4(.7,.4,.4,0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MsyfW3.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[35, 35, 75, 75, 297]], "test": "untested"}
{"id": "Mt3cW4", "name": "Basic Voronoi, from tutorial", "author": "hascheidl", "description": "Copy of the first approach by @The_ArtOfCode, shown at https://www.youtube.com/watch?v=l-07BXzNdPw\n", "tags": ["voronoi"], "likes": 3, "viewed": 165, "published": "Public", "date": "1532599148", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/*\n * Voronoi visualization\n * Copy of the first approach by @The_ArtOfCode, shown at https://www.youtube.com/watch?v=l-07BXzNdPw\n * \n * 27.07.2018\n */\nvec2 N22(vec2 p) {\n    vec3 a = fract(p.xyx*vec3(123.34,234.34,345.65));\n    a += dot(a, a+34.45);\n    return fract(vec2(a.x*a.y, a.y * a.z));\n    \n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    float ar = iResolution.x/iResolution.y;\n    vec2 uv = (2. * fragCoord - iResolution.xy)/iResolution.y;\n    \n    float m = 0.;\n    float t = iTime;\n    float minDist = 100.;\n    \n    for(float i=1.; i<=10.; i++) {\n     vec2 n = N22(vec2(i));   \n        vec2 p = sin(n*t);\n        p.x *= ar; //aspect ratio\n        \n        float d = length(uv-p);\n        m+= smoothstep(.02, .01,d);\n        \n        if(d<minDist) {\n         minDist = d;   \n            \n        }\n    }\n\n    // Time varying pixel color\n    vec3 col = vec3(minDist);\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Mt3cW4.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 152, 170, 170, 301], [302, 302, 359, 409, 1003]], "test": "untested"}
{"id": "Mt3cWN", "name": "simple weave", "author": "liamboone", "description": "simple lines woven together", "tags": ["2d", "simple", "lines"], "likes": 4, "viewed": 143, "published": "Public", "date": "1532631191", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\nfloat checker(vec2 uv, float size)\n{\n  return mod(floor(size * uv.x) + floor(size * uv.y), 2.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (2.* fragCoord - iResolution.xy) / iResolution.y;\n    \n    vec3 color = vec3(0.9);\n    \n    float disk = mix(0.1, 1.0, smoothstep(0.0, 0.9, max(0.0, 1.0 - length(uv))));\n    \n    float all_weaves = 0.;\n    \n    float N = 4.;\n    \n    for (float i = 0.; i < N; i += 1.)\n    {\n        float d = fract((iTime * 0.1) + (i / N));\n        float size = (1. - d) * 10.;\n        float t = d * 0.5 * 3.14159;\n        vec2 st = (uv * mat2(cos(t), sin(t),\n                            -sin(t), cos(t))) - 1. / (size * 4.);\n        \n        vec2 fuzzy_lines = sin(st * size * 2. * 3.14159) * 0.5 + 0.5;\n        vec2 lines = pow(fuzzy_lines, vec2(10.));\n        vec2 dl = fwidth(lines);\n\n        vec2 mask = smoothstep(0.2 - dl, 0.2 + dl, lines);\n\n        float squares = checker(st, size);\n\n        mask = 1.0 - (vec2(squares, 1. - squares) * min(mask.x, mask.y));\n\n        vec2 weave_comps = smoothstep(0.8 - dl, 0.8 + dl, lines) * mask;\n\n        float weave = max(weave_comps.x, weave_comps.y);\n\n        weave *= disk;\n    \tall_weaves = max(weave * exp((1.-d) * - 4.), all_weaves);\n    }\n    \n    // Output to screen\n    fragColor = vec4(all_weaves * color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Mt3cWN.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 1, 37, 37, 99], [101, 101, 158, 158, 1326]], "test": "untested"}
{"id": "Mt3yDr", "name": "Intergalactic  Sunrise", "author": "JohanFlod", "description": "I tried to colorize a black and white shader I made\n\nhttps://www.shadertoy.com/view/XsKfWt\n\n", "tags": ["2d", "wave", "sunset", "sun", "water", "glsl", "ocean", "sine", "summer"], "likes": 13, "viewed": 361, "published": "Public", "date": "1532213295", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/*\n\ngreat article on how to create palettes\n\nhttp://www.iquilezles.org/www/articles/palettes/palettes.htm\n\n*/\n\n\nconst int NUM_WAVES = 5;\n\nvec3 pal( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d )\n{\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 st = fragCoord/iResolution.xy;\n    float wave_input;\n    vec3 wave_colour;\n   \tfloat wave1;\n    vec3 colour = vec3(0.5);\n    st.x=8.0*st.x-2.8;\n    st.y=5.0*st.y-1.8;\n    float combined_colour;\n    // the sun body\n    \n    float moving_sun = 2.5*abs(sin(0.2*iTime))-0.8;\n    float dist_sun = (distance(st,vec2(0.,moving_sun)));\n    float sun_colour= (smoothstep(0.1,0.55,1.-dist_sun));\n   \t\n   \n    // glow from the sun\n    float glow_size = (dist_sun/5.0);\n    float glow_frequence = abs(cos(.2*iTime));\n    float glow_intensity = abs(cos(.2*iTime));\n   \n    float strength = 0.5;\n    \n    float glow =strength*(1.- glow_intensity*glow_frequence*glow_size);\n   \n    // combine sun and the glow from the sun\n    \n    combined_colour= mix(glow,0.5+0.4*clamp(0.0,1.4,(st.y)),sun_colour);\n    \n    colour = pal(combined_colour, vec3(.7,0.8,0.5),vec3(.9,.7,0.1),vec3(.3,.2,.8),vec3(.6,.40,.30) );\n    //colour= vec3(combined_colour);\n    \n    \n  \n  \t\n    vec3 grey=vec3(.5);\n    for(int j = NUM_WAVES; j >0; j--)\n    {\n        float i = float(j);\n    \tfloat wave_input= .6/(2.5*i)*(sin(+iTime))*(sin(0.5*(i*.432)*st.x*4.+iTime*.8+st.y))-.8/i-1.+1.;\n    \twave1 = smoothstep(wave_input-0.1/i,wave_input,st.y);\n        wave_input =(1.-st.y/2.5)*(.15*i)*(1.-0.5*abs(cos(.2*iTime)));\n        wave_colour = pal(wave_input, vec3(.6,0.7,0.4),vec3(.9,.7,0.1),vec3(.3,.2,1.),vec3(.6,.40,.30) );\n        colour = mix(vec3(wave_colour),colour,vec3(wave1));\n    }\n\t\n    //colour = vec3(colour.b);\n\t\n    fragColor = vec4(colour,1.0);\n}\n\n\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Mt3yDr.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 138, 206, 206, 249], [251, 251, 308, 308, 1835]], "test": "untested"}
{"id": "MtcyDn", "name": "Cone capsule", "author": "TLC123", "description": "three bones of cone capsules special \"synaptic\" blend mode and normaldriven bump texture.\nLooping thou combinations of three blend parameters and two bump noise parameters  (roughness and depth).\nUseful for bone and exoskeleton modelling", "tags": ["capsule"], "likes": 2, "viewed": 154, "published": "Public", "date": "1532188371", "time_retrieved": "2021-10-01T00:00:00", "image_code": "   \n#ifdef GLSLVIEWER\nuniform vec3 u_eye3d;\nuniform vec3 u_centre3d;\nuniform vec3 u_up3d;\n#endif\n\n\nfloat   arandom (float aseed) {return mod( mod(aseed*43758.5453123, 1.9)+aseed* 78.233 ,1.0);}\n\nfloat value_at (float x,float y,float z) {return arandom(arandom(arandom(x)+y)+z);}\n\n\nfloat noise3d(vec3 p) {\n    \n    // single octave xyz noise\n\t  float  px= floor (p.x); \t   float    py= floor (p.y); \t   float    pz= floor (p.z);\n  \t\tfloat\tlbx= smoothstep(0.0,1.0,p.x-px);\t\n  \t\tfloat  lby= smoothstep(0.0,1.0,p.y-py);\t \n \t\t float  lbz= smoothstep(0.0,1.0,p.z-pz);\n\t  \t  float    p0 = value_at (px,  py,  pz);    float    p1 = value_at (px+1.0,py,  pz);\n      \t  float    p2 = value_at (px+1.0,py+1.0,pz);    float    p3 = value_at (px,  py+1.0,pz);\t\t\n      \t  float    p4 = value_at (px,  py,  pz+1.0);  float      p5 = value_at (px+1.0,py,  pz+1.0);\n      \t  float    p6 = value_at (px+1.0,py+1.0,pz+1.0);  float      p7 = value_at (px,  py+1.0,pz+1.0);   \t     \n          float  p01 =mix(p0,p1,lbx);\t\t\t  float  p32 =mix(p3,p2,lbx);\n    \t  float  \tp45 =mix(p4,p5,lbx);\t\t  float  \tp76 =mix(p7,p6,lbx);\n\t\t  float  \tp0132=mix(p01,p32,lby);\t\t  float  \tp4576=mix(p45,p76,lby);  \t \n    float   c1=mix(p0132,p4576,lbz);\n    return    (c1);}\n\n\nfloat  synmin(float a,float  b,float  r ,float w,float g) {\n    // drop-in function for smin  \n\t \n        float  e =   max(r*0.02,(abs(a-b)/r) );\n        return min (a,b)- max(0.01,(r*e*w*(exp(1.0-(e*g ))))/max(a,b)*0.5)\n \n            ;}\n\nfloat conecapsule2 (vec3 p, vec4 p1 ,vec4 p2  ) {\n// eats vec4 (x,y,z,r) X 2\nvec3 a=mix(p1.xyz,p2.xyz,0.15); // pull back a little from joint\nvec3 b=mix(p1.xyz,p2.xyz,0.9);\nfloat\t\td1=p1.w;\nfloat\t\td2=p2.w*0.9;\nvec3\t\tba = b - a;\nvec3\t\tpa = p - a;\n    float v= dot(pa,ba) / dot(ba,ba);\nfloat\t\th = clamp(  v,   0.0,   1.0);\nfloat\t\t\td=mix(d1,d2,  smoothstep(0.0,1.0,   h));\n     float r= d ;// / 2.0;\n \n            return length (pa - ba*h) - r;\n\n}\n\n float conecapsule (vec3 p, vec4 p1 ,vec4 p2 ,float w, float z) {\n\n    // wrapper of conecapsule to introduce some bump noise\n    \n     vec3 n=normalize(vec3 (\n     conecapsule2(p,p1,p2)-conecapsule2(p+vec3(0.01,0.0,0.0) ,p1,p2),\n       conecapsule2(p,p1,p2)-conecapsule2(p+vec3(0.0,0.01,0.0),p1,p2 ),\n      conecapsule2(p,p1,p2)-conecapsule2(p+vec3(0.0,0.0,0.01),p1,p2 )\n           ));\n \n    \nfloat bumpb=noise3d(n*w+p/(45./w))*z;//mostly normaldriven with a dash of global p\n     \nreturn conecapsule2 (p,p1,p2) +bumpb \n   ; \n}\n \n\nvec4 map(vec4 r0)\n{  vec3 p=r0.xyz ;\n \n \n // make a few points\n vec4 p1= vec4(-0.+(sin(iTime*.5+1.)+1.25)*10.,0.,0.,8.);\n vec4 p2= vec4(45.,0.,0., 7.+(sin(iTime*.7+1.)+1.)*5.);\n vec4 p1b =vec4 ( p1.x, p1.y, p1.z, 5.5+(sin(iTime*.9)+1.1)*5. );\n  vec4 p3= vec4(-10.-(cos(iTime*.5)+1.25)*10.,0.,(sin(iTime*.5))*10., 4.5+(sin(iTime*.9)+1.1)*3.0);\n  vec4 p4= vec4(-40.,-1.+(cos(iTime*.95)+1.25)*10.,-45.+ (sin(iTime*.95)+1.25)*10., 3.1+(sin(iTime*.9)+1.)*3.0);\n// connect point with conecaplsule bones\n float v1= conecapsule(\n               p, \n                p2 , p1,\n             \n                                   \n               (sin(iTime*1.5)+1.5)*3.,(sin(iTime*2.)+1.5)*0.5                   \n                );\n \n float v2= conecapsule(\n               p,                  \n                   p1b,\n                  p3,\n                                   \n               (sin(iTime*1.3)+1.5)*3.,(sin(iTime*2.1)+1.5)*0.5                   \n                );\n  float v2b= conecapsule(\n               p,                  \n                   p1b,\n                  p3,\n                                   \n               3.,2.25                  \n                );\n \n  float v3= conecapsule(\n               p,                  \n                   p3,\n                  p4,\n                                   \n               (sin(iTime*3.1)+1.5)*3.,(sin(iTime*2.4)+1.5)*0.5                   \n                );\n \n \n // synmin union \n //return vec4(  v2b,0.56,0.51,0.52);   //uncomment for single bome demo\n \n return vec4( \n      synmin(v2,  min(v1,v3),(sin(iTime*0.39)+1.1)*8.,(sin(iTime*0.71)+1.4)*8.,(sin(iTime*0.59)+1.4)*2.)\n        ,v1>v2?0.015:0.025, v2<v3?0.015:0.025, 0.013)\n               ;\n\n }\n\n\nconst vec3 bbox_min = vec3(-7.363703305156273,-7.363703305156273,-7.363703305156273);\nconst vec3 bbox_max = vec3(7.363703305156273,7.363703305156273,7.363703305156273);\n// ray marching. ro is ray origin, rd is ray direction (unit vector).\n// result is (t,r,g,b), where\n//  * t is the distance that we marched,\n//  * r,g,b is the colour of the distance field at the point we ended up at.\n//    (-1,-1,-1) means no object was hit.\nvec4 castRay( in vec3 ro, in vec3 rd )\n{\n    float tmin = 1.0;\n    float tmax = 300.0;\n   \n    float t = tmin;\n    vec3 c = vec3(-1.0,-1.0,-1.0);\n    for (int i=0; i<200; i++) {\n        float precis = 0.0005*t;\n        vec4 res = map( vec4(ro+rd*t,iTime) );\n        if (res.x < precis) {\n            c = res.yzw;\n            break;\n        }\n        t += res.x;\n        if (t > tmax) break;\n    }\n    return vec4( t, c );\n}\nvec3 calcNormal( in vec3 pos )\n{\n    vec2 e = vec2(1.0,-1.0)*0.5773*0.0005;\n    return normalize( e.xyy*map( vec4(pos + e.xyy,iTime) ).x + \n                      e.yyx*map( vec4(pos + e.yyx,iTime) ).x + \n                      e.yxy*map( vec4(pos + e.yxy,iTime) ).x + \n                      e.xxx*map( vec4(pos + e.xxx,iTime) ).x );\n}\nfloat calcAO( in vec3 pos, in vec3 nor )\n{\n    float occ = 0.0;\n    float sca = 1.0;\n    for( int i=0; i<5; i++ )\n    {\n        float hr = 0.01 + 0.12*float(i)/4.0;\n        vec3 aopos =  nor * hr + pos;\n        float dd = map( vec4(aopos,iTime) ).x;\n        occ += -(dd-hr)*sca;\n        sca *= 0.95;\n    }\n    return clamp( 1.0 - 3.0*occ, 0.0, 1.0 );    \n}\n// in ro: ray origin\n// in rd: ray direction\n// out: rgb colour\nvec3 render( in vec3 ro, in vec3 rd )\n{ \n    //vec3 col = vec3(0.7, 0.9, 1.0) +rd.z*0.8;\n    //vec3 col = vec3(0.8, 0.9, 1.0);\n    vec3 col = vec3(1.0, 1.0, 1.0);\n    vec4 res = castRay(ro,rd);\n    float t = res.x;\n    vec3 c = res.yzw;\n    if( c.x>=0.0 )\n    {\n        vec3 pos = ro + t*rd;\n        vec3 nor = calcNormal( pos );\n        vec3 ref = reflect( rd, nor );\n        \n        // material        \n        col = mix(c,normalize(c),0.42);\n\n        // lighting        \n        float occ = calcAO( pos, nor );\n        vec3  lig = normalize( ro +vec3(0,10,10) );\n        float amb = clamp( 0.5+0.5*nor.z, 0.0, 1.0 );\n        float dif = clamp( dot( nor, lig ), 0.0, 1.0 );\n        float bac = clamp( dot( nor, normalize(vec3(-lig.x,lig.y,0.0))), 0.0, 1.0 )*clamp( 1.0-pos.z,0.0,1.0);\n        float dom = smoothstep( -0.1, 0.1, ref.z );\n        float fre = pow( clamp(1.0+dot(nor,rd),0.0,1.0), 2.0 );\n        float spe = pow(clamp( dot( ref, lig ), 0.0, 1.0 ),16.0);\n        \n        vec3 lin = vec3(0.0);\n       lin += 1.30*dif*vec3(1.00,0.80,0.55);\n         lin += 2.00*spe*vec3(1.00,0.90,0.70)*dif;\n        //lin += 0.40*amb*vec3(0.40,0.60,1.00)*occ;\n        // lin += 0.50*dom*vec3(0.40,0.60,1.00)*occ;\n        lin += 0.50*bac*vec3(0.35,0.35,0.35)*occ;\n        // lin += 0.25*fre*vec3(1.00,1.00,1.00)*occ;\n        vec3 iqcol = col*lin;\n\n        //col = mix( col, vec3(0.8,0.9,1.0), 1.0-exp( -0.0002*t*t*t ) );\n        col = mix(col,iqcol, 0.6);\n    }\n\n    return vec3( clamp(col,0.0,1.0) );\n}\n// Create a matrix to transform coordinates to look towards a given point.\n// * `eye` is the position of the camera.\n// * `centre` is the position to look towards.\n// * `up` is the 'up' direction.\nmat3 look_at(vec3 eye, vec3 centre, vec3 up)\n{\n    vec3 ww = normalize(centre - eye);\n    vec3 uu = normalize(cross(ww, up));\n    vec3 vv = normalize(cross(uu, ww));\n    return mat3(uu, vv, ww);\n}\n// Generate a ray direction for ray-casting.\n// * `camera` is the camera look-at matrix.\n// * `pos` is the screen position, normally in the range -1..1\n// * `lens` is the lens length of the camera (encodes field-of-view).\n//   0 is very wide, and 2 is a good default.\nvec3 ray_direction(mat3 camera, vec2 pos, float lens)\n{\n    return normalize(camera * vec3(pos, lens));\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    const vec3 origin = (bbox_min + bbox_max) / 2.0 +vec3 (0,0,10);\n    const vec3 radius = (bbox_max - bbox_min) / 2.0;\n    float r = max(radius.x, max(radius.y, radius.z)) / 1.0;\n    vec2 p = -1.0 + 2.0 * fragCoord.xy / iResolution.xy;\n    p.x *= iResolution.x/iResolution.y;\n\n#ifdef GLSLVIEWER\n    vec3 eye = vec3(u_eye3d.x, -u_eye3d.z, u_eye3d.y)*r + origin;\n    vec3 centre = vec3(u_centre3d.x, -u_centre3d.z, u_centre3d.y)*r + origin;\n    vec3 up = vec3(u_up3d.x, -u_up3d.z, u_up3d.y);\n#else\n   \n      vec2 mouse = iMouse.xy / iResolution.xy;\n    vec3 eye = vec3 (cos (4. * mouse.x) * 67., sin (4. * mouse.x) *sin (4. * mouse.y) * 67., -cos (4. * mouse.y) * 67.);\n   // vec3 eye = vec3(sin(iTime/4.)*100., cos(iTime/4.)*90., cos(iTime/4.)*26. +10.);\n    vec3 centre = vec3(0.0, 10.0, 0.0);\n    vec3 up = eye+ vec3(0.0, 0.0, 01.0);\n\t \n#endif\n    mat3 camera = look_at(eye, centre, up);\n    vec3 dir = ray_direction(camera, p, 2.5);\n\n    vec3 col = render( eye, dir );\n    \n    // convert linear RGB to sRGB\n    col = pow(col, vec3(0.4545));\n    \n    fragColor = vec4(col,1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MtcyDn.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[99, 99, 130, 130, 193], [195, 195, 237, 237, 278], [281, 281, 304, 340, 1232], [1235, 1235, 1294, 1329, 1472], [1474, 1474, 1523, 1550, 1917], [1920, 1920, 1984, 2044, 2447], [2451, 2451, 2470, 2470, 4154], [4326, 4586, 4626, 4626, 5009], [5010, 5010, 5042, 5042, 5343], [5344, 5344, 5386, 5386, 5700], [5701, 5765, 5804, 5891, 7264], [7265, 7462, 7508, 7508, 7658], [7659, 7927, 7982, 7982, 8032], [8033, 8033, 8090, 8090, 9174]], "test": "untested"}
{"id": "MtcyW8", "name": "This copy", "author": "holloway95", "description": "cool", "tags": ["cool"], "likes": 2, "viewed": 473, "published": "Public API", "date": "1532374193", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Created by inigo quilez - iq/2013\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// See here for a tutorial on how to make this: http://www.iquilezles.org/www/articles/warp/warp.htm\n\nconst mat2 m = mat2( 0.80,  0.60, -0.60,  0.80 );\n\nfloat noise( in vec2 x )\n{\n\treturn sin(1.5*x.x)*sin(1.5*x.y);\n}\n\nfloat fbm4( vec2 p )\n{\n    float f = 0.0;\n    f += 0.5000*noise( p ); p = m*p*2.02;\n    f += 0.2500*noise( p ); p = m*p*2.03;\n    f += 0.1250*noise( p ); p = m*p*2.01;\n    f += 0.0625*noise( p );\n    return f/0.9375;\n}\n\nfloat fbm6( vec2 p )\n{\n    float f = 0.0;\n    f += 0.500000*(0.5+0.5*noise( p )); p = m*p*2.02;\n    f += 0.250000*(0.5+0.5*noise( p )); p = m*p*2.03;\n    f += 0.125000*(0.5+0.5*noise( p )); p = m*p*2.01;\n    f += 0.062500*(0.5+0.5*noise( p )); p = m*p*2.04;\n    f += 0.031250*(0.5+0.5*noise( p )); p = m*p*2.01;\n    f += 0.015625*(0.5+0.5*noise( p ));\n    return f/0.96875;\n}\n\n\nfloat func( vec2 q, out vec4 ron )\n{\n    float ql = length( q );\n    q.x += 0.05*sin(0.27*iTime*0.1+ql*4.1);\n    q.y += 0.05*sin(0.23*iTime*0.1+ql*4.3);\n    q *= 0.5;\n\n\tvec2 o = vec2(0.0);\n    o.x = 0.5 + 0.5*fbm4( vec2(2.0*q          )  );\n    o.y = 0.5 + 0.5*fbm4( vec2(2.0*q+vec2(5.2))  );\n\n\tfloat ol = length( o );\n    o.x += 0.02*sin(0.12*iTime+ol)/ol;\n    o.y += 0.02*sin(0.14*iTime+ol)/ol;\n\n    vec2 n;\n    n.x = fbm6( vec2(4.0*o+vec2(9.2))  );\n    n.y = fbm6( vec2(4.0*o+vec2(5.7))  );\n\n    vec2 p = 4.0*q + 4.0*n;\n\n    float f = 0.5 + 0.5*fbm4( p );\n\n    f = mix( f, f*f*f*3.5, f*abs(n.x) );\n\n    float g = 0.5 + 0.5*sin(4.0*p.x)*sin(4.0*p.y);\n    f *= 1.0-0.5*pow( g, 8.0 );\n\n\tron = vec4( o, n );\n\t\n    return f;\n}\n\n\n\nvec3 doMagic(vec2 p)\n{\n\tvec2 q = p*0.6;\n\n    vec4 on = vec4(0.0);\n    float f = func(q, on);\n\n\tvec3 col = vec3(0.0);\n    col = mix( vec3(0.2,0.1,0.4), vec3(0.3,0.05,0.05), f );\n    col = mix( col, vec3(0.9,0.9,0.9), dot(on.zw,on.zw) );\n    col = mix( col, vec3(0.9,0.3,0.1), 0.5*on.y*on.y );\n    col = mix( col, vec3(0.0,0.4,0.4), 0.5*smoothstep(1.2,1.3,abs(on.z)+abs(on.w)) );\n    col = clamp( col*f*2.0, 0.0, 1.0 );\n    \n\tvec3 nor = normalize( vec3( dFdx(f)*iResolution.x, 6.0, dFdy(f)*iResolution.y ) );\n\n    vec3 lig = normalize( vec3( 0.9, -0.2, -0.4 ) );\n    float dif = clamp( 0.3+0.7*dot( nor, lig ), 0.0, 1.0 );\n    vec3 bdrf;\n    bdrf  = vec3(0.70,0.90,0.95)*(nor.y*0.5+0.5);\n    bdrf += vec3(0.15,0.10,0.05)*dif;\n    col *= 1.2*bdrf;\n\tcol = 1.0-col;\n\treturn 1.1*col*col;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 q = fragCoord / iResolution.xy;\n    vec2 p = -1.0 + 2.0 * q;\n    p.x *= iResolution.x/iResolution.y;\n\n    fragColor = vec4( doMagic( p ), 1.0 );\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MtcyW8.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[125, 278, 304, 304, 341], [343, 343, 365, 365, 561], [563, 563, 585, 585, 938], [941, 941, 977, 977, 1665], [1669, 1669, 1691, 1691, 2452], [2453, 2453, 2510, 2510, 2666]], "test": "untested"}
{"id": "MtcyWr", "name": "Traveling Through Mist", "author": "Emil", "description": "A fake effect of traveling through some mist", "tags": ["3d", "noise", "horizon"], "likes": 23, "viewed": 450, "published": "Public", "date": "1532195542", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float n21 (vec3 uvw)\n{\n    return fract(sin(uvw.x*23.35661 + uvw.y*6560.65 + uvw.z*4624.165)*2459.452);\n}\n\nfloat smoothNoise (vec3 uvw)\n{\n    float fbl = n21(floor(uvw));\n    float fbr = n21(vec3(1.0,0.0,0.0)+floor(uvw));\n    float ful = n21(vec3(0.0,1.0,0.0)+floor(uvw));\n    float fur = n21(vec3(1.0,1.0,0.0)+floor(uvw));\n    \n    float bbl = n21(vec3(0.0,0.0,1.0)+floor(uvw));\n    float bbr = n21(vec3(1.0,0.0,1.0)+floor(uvw));\n    float bul = n21(vec3(0.0,1.0,1.0)+floor(uvw));\n    float bur = n21(vec3(1.0,1.0,1.0)+floor(uvw));\n    \n    uvw = fract(uvw);\n    vec3 blend = uvw;\n    blend = (blend*blend*(3.0 -2.0*blend)); // cheap smoothstep\n    \n    return mix(\tmix(mix(fbl, fbr, blend.x), mix(ful, fur, blend.x), blend.y),\n        \t\tmix(mix(bbl, bbr, blend.x), mix(bul, bur, blend.x), blend.y),\n               \tblend.z);\n}\n\nfloat perlinNoise (vec3 uvw)\n{\n    float blended = smoothNoise(uvw*4.0);\n    blended += smoothNoise(uvw*8.0)*0.5;\n    blended += smoothNoise(uvw*16.0)*0.25;\n    blended += smoothNoise(uvw*32.0)*0.125;\n    blended += smoothNoise(uvw*64.0)*0.0625;\n    \n    blended /= 2.0;\n    //blended = fract(blended*2.0)*0.5+0.5;\n    blended *= pow(0.8-abs(uvw.y),2.0);\n    return blended;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.x-0.5*vec2(1.0,(iResolution.y/iResolution.x));\n\t\n    \n    vec3 uvw = vec3(uv, iTime*0.14);\n    \n    vec3 result = vec3(0.0);\n    float moreDepth = 0.0;\n    \n    for(int i=0;i<20;i++)\n    {\n        moreDepth += 0.008;\n        result += \t\tvec3(perlinNoise(uvw*vec3(vec2(moreDepth*12.0+1.0),1.0) + vec3(0.0,0.0, moreDepth)));\n    }\n    result /= 14.0;\n    \n    result *= 2.4*(0.6-length(uvw.xy));\n    \n    fragColor = vec4(result * vec3(0.8,0.9,1.0)*1.0 + vec3(0.2,0.3,0.4)*(0.9-abs(uv.y)), 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MtcyWr.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 22, 22, 105], [107, 107, 137, 137, 828], [830, 830, 860, 860, 1206], [1208, 1208, 1265, 1265, 1797]], "test": "untested"}
{"id": "MtdcRM", "name": "rainbow explosion B (eppilepsy)", "author": "ollj", "description": "starts slow, mild eppilepsy warning", "tags": ["fractal", "explosion", "rainbow", "bipolar", "eppilepsy"], "likes": 7, "viewed": 498, "published": "Public API", "date": "1532079187", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define iterKifs 90.\n#define time iTime*2.\n\n//someone elses shader, modified by ollj\n//source lost, may evenbe be from glslsandbox.\n\n#define dd(a) dot(a,a)\nvec2 ddm(mat2 a){return vec2(dd(a[0]),dd(a[1]));}\nvec3 ddm(mat3 a){return vec3(dd(a[0]),dd(a[1]),dd(a[2]));}\nvec4 ddm(mat4 a){return vec4(dd(a[0]),dd(a[1]),dd(a[2]),dd(a[3]));}\n#define u5(a)((a)*.5+.5)\n#define u2(a)((a)*2.-1.)\nvec2 c2(vec2 a){return a*vec2(1,-1);}\nvec2 cs(vec2 a){return vec2(cos(a.x),sin(a.y));}\nfloat suv(vec2 a){return a.x+a.y;}\nfloat suv(vec3 a){return a.x+a.y+a.z;}\nvec2 suv2(vec4 a){return vec2(suv(a.xy),suv(a.zw));}//sum modulo 2\nvec4 abab(float a,float b){return vec4(a,b,a,b);}\n\nfloat evalDx(float a,vec4 b){return((a*b.w+b.z)*b.y)+b.x;}\nfloat rt(float a,vec3 b){return evalDx(a,b.yzxz);}\n\n#define ViewZoom 1.\n#define fra(u) (u-.5*iResolution.xy)*ViewZoom/iResolution.y\nvec2 fra2(vec2 u){float r=iResolution.x/iResolution.y;u-=.5;u*=ViewZoom;u.x*=r;return u;}//fra2(u)=fra(u*iResolution)\n\n/**/\n\nvoid mainImage( out vec4 O, in vec2 U ){\nvec2 m=(U.xy-iResolution.xy/2.0)/min(iResolution.y,iResolution.x)*30.\n ;mat2 w=mat2(m,m)\n ;m=(time+360.)*vec2(.1,.3)\n ;vec2 mspt=(vec2(suv(sin(m.x*vec3(1,.5,1.3)))+suv(cos(m.x*vec2(-0.4,.2)))//5x harmonics over 2 domains\n     ,suv(cos(m.x*vec3(1,.8,1.5)))+suv(sin(m.x*vec2(-1.1,.1))))+1.)*.35//...scaled back to roughly[0,1]\n ;vec3 r=vec3(0)\n ;float Z=.4+mspt.y*.3,n=.99+sin(time*.03)*.003,a=(1.-mspt.x)*.5\n ;vec2 u=cs(suv2(vec4(.024,.23,.03,.01)*abab(m.y,a)))*vec2(3.1,3.3)\n ,t=1.1*cs(suv2(vec4(.03,.01,.033,.23)*abab(m.y,a)))\n ;for(float i=0.;i<iterKifs;i++\n){vec2 p=vec2(dd(w[0]),dd(w[1]))\n  ;if(p.y>1.)w[1]/=p.y;;if(p.x>1.)w[0]/=p.x;//;w[0]=mix(w[0],1./w[0],step(1.,p.x))//<-substitution fails because of mixint 1/x\n  ;p=mix(1./p,p,step(p,vec2(1)))//;if(p>1.)p=1./p;\n  ;r.x=evalDx(r.x,vec3(p,n).yzxz)\n  ;if(i<iterKifs-1.\n ){r.y=evalDx(r.y,vec3(p,n).yzxz)\n   ;if(i<iterKifs-2.)r.z=evalDx(r.z,vec3(p,n).yzxz);}\n  ;w[0]=vec2(dot(w[0],c2(t)),dot(w[0],t.yx))*Z+vec2(.033,.14)\n  ;w[1]=vec2(dot(w[1],c2(u)),dot(w[1],u.yx))*Z-vec2(.023,.22);}\n ;vec3 s=fract(r)\n ;s-=u5(sign(mod(r,2.)-1.))*u2(s)//;s=mix(1.-s,s,step(r,vec3(1.)))\n ;O=vec4(s,1)\n/**/\n;}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MtdcRM.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[44, 156, 173, 173, 205], [206, 206, 223, 223, 264], [265, 265, 282, 282, 332], [383, 383, 399, 399, 420], [421, 421, 437, 437, 469], [470, 470, 488, 488, 504], [505, 505, 523, 523, 543], [544, 544, 562, 562, 596], [596, 611, 638, 638, 660], [662, 662, 691, 691, 720], [721, 721, 746, 746, 771], [853, 853, 871, 871, 942], [972, 978, 1018, 1018, 2164]], "test": "untested"}
{"id": "MtdczM", "name": "SubSurface cleaned", "author": "ollj", "description": "one oif my favourite sss code shaders, \"cleaned up\" and simplified, as in, no buffers.\n\nhmm, why is time frozen, some day shadertoy stopped using iGlobalTime.", "tags": ["subsurfacescattering", "sss"], "likes": 8, "viewed": 491, "published": "Public API", "date": "1532085516", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n#define NINF 65536.\n\n\n#define iGlobalTime (iTime*9.)\n\n\n//parent shader by \n//Ben Quantock 2014\n//License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n//artefacts from noise texture interpolation\n#define FAST\n\n//keys\n/*\nconst int kA=65,kB=66,kC=67,kD=68,kE=69,kF=70,kG=71,kH=72,kI=73,kJ=74,kK=75,kL=76,kM=77;\nconst int kN=78,kO=79,kP=80,kQ=81,kR=82,kS=83,kT=84,kU=85,kV=86,kW=87,kX=88,kY=89,kZ=90;\nconst int k0=48,k1=49,k2=50,k3=51,k4=52,k5=53,k6=54,k7=55,k8=56,k9=57;\nconst int kSpace=32,kLeft=37,kUp=38,kRight=39,kDown=40;\n//key is javascript keycode: http://www.webonweboff.com/tips/js/event_key_codes.aspx\nbool ReadKey(int key,bool toggle){ float keyVal=0.5;return(keyVal>.5)?true:false;}\nbool Toggle(int val){ return !ReadKey(val,true);}\n//TOGGLES:\n\n#define kAmbientOcclusion 65\n#define kReflectionOcclusion 39\n#define kSubsurface 32\n#define kLensFX 37\n#define kDarkScene 40\n*/\n\n\nconst float tau=6.2831853;\nconst float phi=1.61803398875;\nconst vec3 darkEnvBrightness=vec3(.02,.03,.05);\n\nvec3 envBrightness=vec3(1);//global var\n\nvec2 Noise(vec3 x){return vec2(.5);}//butchered bumpmapping\n/* #ifdef FAST\n ;vec3 p=floor(x);x=fract(x);x*=x*(3.-2.*x);vec2 uv=(p.xy+vec2(37.,17.)*p.z)+x.xy\n ;vec4 rg=vec4(.5);//texture2D(iChannel0,(uv+0.5)/256.0,-100.0);\n #else \n ;//high precision interpolation,if needed,requires reading from self\n ;vec4 rg=mix(mix(\n texture2D(iChannel0,(floor(uv)+0.5)/256.0,-100.0),\n texture2D(iChannel0,(floor(uv)+vec2(1,0)+0.5)/256.0,-100.0),\n fract(uv.x)),\n  mix(\n texture2D(iChannel0,(floor(uv)+vec2(0,1)+0.5)/256.0,-100.0),\n texture2D(iChannel0,(floor(uv)+1.5)/256.0,-100.0),\n fract(uv.x)),\n fract(uv.y));\n #endif \n;return mix(rg.yw,rg.xz,x.z);}*/\n\nfloat mav(vec2 a){return max(a.x,a.y);}\nfloat mav(vec4 a){return max(mav(a.xy),mav(a.zw));}\n#define miv(a)-mav(-a)\n\nvec4 octFold(vec3 p,vec2 s){return vec4(dot(p,s.xxx),dot(p,s.yyx),dot(p,s.yxy),dot(p,s.xyy));}\nfloat Oct(vec3 u){return mav(abs(octFold(u,vec2(1,-1)/sqrt(3.))));}\n\n//Ben Quantock 2014\n//License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\nfloat CubeFrame(vec3 p,float r\n){p=abs(p)\n ;float s=r*.1\n ;p-=vec3(r-s)\n ;p=mix(p,p.zyx,step(p.x,p.z))\n ;p=mix(p,p.xzy,step(p.y,p.z))\n ;p.z=max(0.,p.z)\n ;return length(p)-s;}\n\nfloat df(vec3 p){\n return miv(vec4\n(length(p-vec3(0,.48,0))-.1\n ,Oct(p-vec3(0,.2,0))-.15\n ,CubeFrame(p-vec3(0,-.05,0),.26)\n ,length(p-vec3(0,-.6,0))-.4));}\n /*\n//spiral candle has bad lipscchitz,putting sss to a stress test.\n ;p.xz=p.xz*cos(p.y*4.0)+vec2(1,-1)*p.zx*sin(p.y*4.0);\n ;return max(max(p.y-.5,-p.y-1.)\n ,(min(max(abs(p.x),abs(p.z))\n ,max(abs(p.x+p.z),abs(p.z-p.x))/sqrt(2.0))-.15)*.8);}*/\n\nvec3 Sky(vec3 ray){return envBrightness*mix(vec3(.8),vec3(0),exp2(-(1./max(ray.y,.01))*vec3(.4,.6,1.)));}\n\nfloat ss01(float a){return smoothstep(0.,1.,a);}\n\nvec3 Shade(vec3 u,vec3 ray,vec3 normal,vec3 ligDir1,vec3 ligDir2,vec3 ligCol1,vec3 ligCol2,float shadowMask1,float shadowMask2,float distance \n){vec3 amb=envBrightness*mix(vec3(.2,.27,.4),vec3(.4),(-normal.y*.5+.5))//amb\n ;//amb=mix(vec3(.03,.05,.08),vec3(.1),(-normal.y+1.0));//amb\n ;//amb occlusion,based on my DF Lighting: https://www.shadertoy.com/view/XdBGW3\n ;float aoRange=distance/20.\n ;float occlusion=max(0.,1.-df(u+normal*aoRange)/aoRange)//can be>1.0\n ;occlusion=exp2(-2.0*pow(occlusion,2.0));//tweak the curve\n \n //mat init for loops\n ;mat4 a;\n ;a[0].xyz=ligCol1\n ;a[1].xyz=ligCol2\n ;a[0].w=max(.0,dot(normal,ligDir1))\n ;a[1].w=max(.0,dot(normal,ligDir2))\n ;mat4 b;\n ;b[0].xyz=ligDir1\n ;b[1].xyz=ligDir2\n ;b[0].w=shadowMask1\n ;b[1].w=shadowMask2\n \n //acc1\n ;vec3 lig=vec3(0)//accumulator\n \n //acc2\n ;vec3 s//accumulate subsurface color\n ;float t=distance/10.//this really should be constant... right? //t\n \n //acc3\n ;float spe=Noise(u/vec3(.05,.2,.05)).x//specular\n ;float specPower=exp2(3.+5.*spe)\n \n\n ;for(int i=0;i<2;i++//for each light\n){lig+=a[i].xyz*b[i].w*a[i].w\n  ;s=s+a[i].xyz*ss01(df(u+b[i].xyz*t)/t)\n  ;a[i].xyz=a[i].xyz*b[i].w*pow(max(.0,dot(normal,normalize(b[i].xyz-ray)))*ss01(a[i].w),specPower)*specPower/32.\n ;}\n \n  ;if(true)amb*=occlusion*.8+.2//reduce occlusion to imply indirect sub surface scattering\n\n \n ;vec3 rray=reflect(ray,normal)\n ;vec3 ref=Sky(rray)\n \n ;//specular occlusion,adjust the divisor for the gradient we expect\n ;float so=max(0.,1.-df(u+rray*aoRange)/(aoRange*max(.01,dot(rray,normal))))//can be>1.0 //specOcclusion\n ;so=exp2(-2.*so*so)//tweak the curve\n ;so*=occlusion ;//prevent sparkles in heavily occluded areas\n ;if(true)ref*=so//could fire an additional ray for more accurate results\n ;float fre=pow(1.0+dot(normal,ray),5.)\n ;fre=mix(mix(.0,.01,spe),mix(.4,1.,spe),fre)\n ;//vec3 alb=vec3(1,.95,.9)\n ;vec3 alb=vec3(.7,.5,1)\n ;//vec3 alb=vec3(.5,.3,.13)\n ;vec3 c=vec3(0)\n ;//comment these out to toggle various parts of the effect\n ;lig+=amb\n ;if(true)lig+=s\n ;c=lig*alb\n ;c=mix(c,ref,fre)\n ;c+=a[0].xyz+a[1].xyz   //okay here we sum up the bugger of the foreach light loop,this is fine!\n ;return c;}\n \n \n\n\n//Isosurface Renderer\n#ifdef FAST\nconst int traceLimit=40;\nconst float traceSize=.005;\n#else\nconst int traceLimit=60;\nconst float traceSize=.002;\n#endif \n\nfloat Trace(vec3 u,vec3 d,float a,float b//ray,ray,start,end\n){float h,t=a\n ;for(int i=0;i<traceLimit;i++\n){h=df(u+t*d);if(h<traceSize||t>b)break\n  ;t=t+h;}\n ;if(t>b)return 0.0;//(...|| h>.001)\n ;return t;}\n\nfloat TraceMin(vec3 u,vec3 d,float a,float b//ray,ray,start,end\n){float Min=b\n ;float t=a\n ;float h\n ;for(int i=0;i<traceLimit;i++\n){h=df(u+t*d)\n  ;Min=min(h,Min)\n  ;if(/*h<.001 ||*/ t>b)break;\n t=t+max(h,.1);}\n ;return Min;}\n\nvec3 Normal(vec3 u,vec3 d,float t//should be able to get a good gradient with 4x sampling\n){float pitch=.2*t/iResolution.x\n #ifdef FAST\n ;pitch=max(pitch,.005)//don't sample smaller than the interpolation errors in Noise()\n #endif\n ;vec2 e=vec2(-1,1)*pitch\n ;vec3 p0=u+e.xxx,p1=u+e.xyy,p2=u+e.yxy,p3=u+e.yyx\n ;float f0=df(p0),f1=df(p1),f2=df(p2),f3=df(p3)\n ;vec3 grad=p0*f0+p1*f1+p2*f2+p3*f3-u*(f0+f1+f2+f3)\n ;grad-=max(.0,dot(grad,d))*d//prevent normals pointing away from camera(caused by precision errors)\n ;return normalize(grad);}\n\nvec3 Ray(float zoom,in vec2 fragCoord){return vec3(fragCoord.xy-iResolution.xy*.5,iResolution.x*zoom);}\n\nvec3 Rotate(inout vec3 v,vec2 a){vec4 cs=vec4(cos(a.x),sin(a.x),cos(a.y),sin(a.y))\n ;v.yz=v.yz*cs.x+v.zy*cs.y*vec2(-1,1)\n ;v.xz=v.xz*cs.z+v.zx*cs.w*vec2(1,-1)\n ;return vec3(vec2(-cs.w,-cs.z)*cs.x,cs.y).xzy;}\n\n//would love to get some disperson on this,but that means more rays\nvoid BarrelDistortion(inout vec3 d,float t){d.z/=t;d.z=(d.z*d.z-dot(d.xy,d.xy));d.z=t*sqrt(d.z);}//direction,degree_of_fisheye\n\nvec3 LensFlare(vec3 ray,vec3 lightCol,vec3 light,float lightVisible,float sky,vec2 fragCoord\n){vec2 dirtuv=fragCoord.xy/iResolution.x\n ;float dirt=1.-.5;//-texture2D(iChannel1,dirtuv).r\n ;float l=(dot(light,ray)*.5+.5)\n ;return((pow(l,30.)+.05)*dirt*.1\n  +pow(l,200.)*lightVisible+sky*pow(l,5000.))*lightCol\n  +5.*pow(smoothstep(.9999,1.,l),20.0)* smoothstep(.5,1.,lightVisible)* normalize(lightCol);}\n\n\nfloat SmoothMax(float a,float b,float smoothing\n){return a-sqrt(smoothing*smoothing+pow(max(.0,a-b),2.));}\n\nvoid mainImage(out vec4 fragColor,in vec2 fragCoord\n){if(true)envBrightness=darkEnvBrightness\n ;vec3 ray=Ray(1.0,fragCoord)\n ;if(true)BarrelDistortion(ray,.5)\n ;ray=normalize(ray)\n ;vec3 lr=ray\n ;vec2 m=vec2(0)\n ;m=.5-iMouse.yx/iResolution.yx//if(iMouse.z>0.0)\n ;float T=iGlobalTime*.1\n ;vec3 u=3.0*Rotate(ray,vec2(.2,1.0-T)+vec2(-1.0,-6.3)*m)\n ;//u+=vec3(0,.3,0)+T*vec3(0,0,-1);\n ;vec3 col\n ;vec3 lightDir1=normalize(vec3(3,1,-2))\n ;float lt=iGlobalTime\n ;vec3 lightu=vec3(cos(lt*.9),sin(lt/phi),sin(lt))*vec3(.6,1.2,.6)\n ;vec3 lightCol1=vec3(1.1,1,.9)*.7*envBrightness\n ;vec3 lightCol2=vec3(.8,.4,.2)\n ;float lightRange2=.4//distance of intensity=1.0\n ;float traceStart=.5\n ;float traceEnd=40.\n ;float t=Trace(u,ray,traceStart,traceEnd)\n ;if(t>.0\n){vec3 p=u+ray*t\n  ;vec3 lightDir2=lightu-p//shadow test\n  ;float lightIntensity2=length(lightDir2);\n  ;lightDir2/=lightIntensity2\n  ;lightIntensity2=lightRange2/(.1+lightIntensity2*lightIntensity2)\n  ;float s1=0.\n  ;s1=Trace(p,lightDir1,.05,2.)\n  ;float s2=0.\n  ;s2=Trace(p,lightDir2,.05,2.)\n  ;vec3 n=Normal(p,ray,t)\n  ;col=Shade(p,ray,n,lightDir1,lightDir2,lightCol1,lightCol2*lightIntensity2,(s1>.0)?0.:1.,(s2>.0)?0.:1.,t)\n  ;float f=200.\n  ;col=mix(vec3(.8),col,exp2(-t*vec3(.4,.6,1.)/f))\n  ;}else col=Sky(ray)\n ;if(true\n){vec3 lightDir2=lightu-u\n  ;float lightIntensity2=length(lightDir2)\n  ;lightDir2/=lightIntensity2\n  ;lightIntensity2=lightRange2/(.1+lightIntensity2*lightIntensity2)\n  ;//lens flare\n  ;float s1=TraceMin(u,lightDir1,.5,40.0)\n  ;float s2=TraceMin(u,lightDir2,.5,40.0)\n  ;col+=LensFlare(ray,lightCol1,lightDir1,smoothstep(-.04,.1,s1),step(t,.0),fragCoord)\n  ;col+=LensFlare(ray,lightCol2*lightIntensity2,lightDir2,smoothstep(-.04,.1,s2),step(t,.0),fragCoord)\n  ;col*=smoothstep(.5,.0,dot(lr.xy,lr.xy))//vignetting\n  ;//compress bright colors,(because bloom vanishes in vignette)\n  ;vec3 c=(col-1.)\n  ;c=sqrt(c*c+.05)//soft abs\n  ;col=mix(col,1.0-c,.48)//.5=never saturate,.0=linear\n  ;vec2 grainuv=fragCoord.xy+floor(iGlobalTime*60.0)*vec2(37,41)//grain\n  ;vec2 filmNoise=vec2(0.5);//texture2D(iChannel0,.5*grainuv/iChannelResolution[0].xy).rb\n  ;col*=mix(vec3(1),mix(vec3(1,.5,0),vec3(0,.5,1),filmNoise.x),.1*filmNoise.y);}\n ;//compress bright colours\n ;float l=max(col.x,max(col.y,col.z))//dot(col,normalize(vec3(2,4,1)));\n ;l=max(l,.01)//prevent div by zero,darker colours will have no curve\n ;float l2=SmoothMax(l,1.0,.01)\n ;col*=l2/l\n ;fragColor=vec4(pow(col,vec3(1./2.2)),1);}\n\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MtdczM.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1051, 1065, 1084, 1084, 1101], [1101, 1707, 1725, 1725, 1746], [1747, 1747, 1765, 1765, 1798], [1823, 1823, 1851, 1851, 1917], [1918, 1918, 1936, 1936, 1985], [1987, 2093, 2126, 2126, 2267], [2269, 2269, 2286, 2286, 2424], [2426, 2670, 2689, 2689, 2775], [2777, 2777, 2797, 2797, 2825], [2827, 2827, 2972, 2972, 4982], [4989, 5144, 5207, 5207, 5350], [5352, 5352, 5418, 5418, 5577], [5579, 5579, 5671, 5671, 6114], [6116, 6116, 6155, 6155, 6219], [6221, 6221, 6254, 6254, 6428], [6430, 6498, 6542, 6542, 6595], [6595, 6626, 6721, 6721, 7027], [7030, 7030, 7080, 7080, 7136], [7138, 7138, 7192, 7192, 9593]], "test": "untested"}
{"id": "Mtdczn", "name": "Wavy Gradient Line", "author": "momoro", "description": "2018-7-11 First shader", "tags": ["bookofshaders"], "likes": 2, "viewed": 177, "published": "Public", "date": "1531363773", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float expStep( float x, float k, float n ){\n    return exp( -k*pow(x,n) );\n}\n\nfloat parabola( float x, float k ){\n    return pow( 4.0*x*(1.0-x), k );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 st = fragCoord.xy/iResolution.xy;\n    //st.x *= u_resolution.x/u_resolution.y;\n\n    float arg = st.y;\n    \n    vec3 pct = vec3(0.);\n    \n    vec3 colorB = vec3(0.912,0.236,0.571);\n\tvec3 colorA = vec3(1.000,0.853,0.224);\n    \n    vec3 grad = mix(colorA, colorB, st.y+.1);\n    \n    \n    \n    pct.z = expStep(arg, 5., 6.0);\n\tpct.z +=  expStep(arg, 5., 3.0);\n\t//pct.z = clamp(pct.z,0.,1.);\n    \n    float freq = sin(st.x+iTime/20.)*10.;\n    float f = sin(freq*st.x+iTime)/25.+.3;\n\tfloat c = smoothstep(f-.2, f+.2, st.y);\n    \n\n    float freq2 = sin(st.x+iTime/22.)*10.;\n    float f2 = sin(freq2*st.x+iTime)/23.+.3;\n\tfloat c2 = smoothstep(f2-.2, f2+.2, 1.-st.y);\n\n    c*= c2;\n    pct.z*=c;\n    \n    vec3 color = vec3(0.000,0.000,0.000);\n    color = mix(color, grad, pct.z);\n\n    fragColor = vec4(color,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Mtdczn.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 43, 43, 76], [78, 78, 113, 113, 151], [153, 153, 210, 210, 1024]], "test": "untested"}
{"id": "MtdyDH", "name": "curl noise 测试", "author": "Kevin85304", "description": "试试curl,最终输出以速度大小为依据。", "tags": ["noisetest"], "likes": 1, "viewed": 194, "published": "Public", "date": "1532508155", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n// 1    x           y            z\n// 2    y+31.416    z-47.853    x+12.793\n// 3    z-233.145   x-113.408   y-185.31\n#define Offset3 vec2(-233.145,-133.31)\n#define Offset2 vec2(31.416,-47.853)\n#define Offset1 vec2(0.,0.)\n\n#define Offset3_x vec2(-233.145,-113.408)\n#define Offset2_x vec2(31.416,12.793)\n#define Offset1_x vec2(0.,0.)\n\n#define Offset3_3 vec3(-233.145,-113.408,-185.31)\n#define Offset2_3 vec3(31.416,-47.853,12.793)\n#define Offset1_3 vec3(0.,0.,0.)\n\n#define MOD3 vec3(.1031,.11369,.13787)\n\nvec2 hash22(vec2 p)\n{\n    p = vec2( dot(p,vec2(127.1,311.7)),\n\t\t\t  dot(p,vec2(269.5,183.3)));\n    \n    //return normalize(-1.0 + 2.0 * fract(sin(p)*43758.5453123));\n    return -1.0 + 2.0 * fract(sin(p)*43758.5453123);\n}\nvec3 hash33(vec3 p3)\n{\n\tp3 = fract(p3 * MOD3);\n    p3 += dot(p3, p3.yxz+19.19);\n    return -1.0 + 2.0 * fract(vec3((p3.x + p3.y)*p3.z, (p3.x+p3.z)*p3.y, (p3.y+p3.z)*p3.x));//-1~1\n}\n\nvec3 hash33_sin(vec3 p3)\n{\n    p3 = vec3( dot(p3,vec3(127.1,311.7, 74.7)),\n\t\t\t  dot(p3,vec3(269.5,183.3,246.1)),\n\t\t\t  dot(p3,vec3(113.5,271.9,124.6)));\n\n\treturn fract(sin(p3)*43758.5453123);\n}\n\n\nfloat simplex_noise(vec2 p)\n{\n    const float K1 = 0.366025404; // (sqrt(3)-1)/2;\n    const float K2 = 0.211324865; // (3-sqrt(3))/6;\n    \n    vec2 i = floor(p + (p.x + p.y) * K1);\n    \n    vec2 a = p - (i - (i.x + i.y) * K2);\n    vec2 o = (a.x < a.y) ? vec2(0.0, 1.0) : vec2(1.0, 0.0);\n    vec2 b = a - (o - K2);\n    vec2 c = a - (1.0 - 2.0 * K2);\n    \n    vec3 h = max(0.5 - vec3(dot(a, a), dot(b, b), dot(c, c)), 0.0);\n    vec3 n = h * h * h * h * vec3(dot(a, hash22(i)), dot(b, hash22(i + o)), dot(c, hash22(i + 1.0)));\n    \n    return dot(vec3(70.0, 70.0, 70.0), n);\n}\nfloat simplex_noise(vec3 p)\n{\n    const float K1 = 0.333333333;\n    const float K2 = 0.166666667;\n    \n    vec3 i = floor(p + (p.x + p.y + p.z) * K1);\n    vec3 d0 = p - (i - (i.x + i.y + i.z) * K2);\n    \n    // thx nikita: https://www.shadertoy.com/view/XsX3zB\n    vec3 e = step(vec3(0.0), d0 - d0.yzx);\n\tvec3 i1 = e * (1.0 - e.zxy);\n\tvec3 i2 = 1.0 - e.zxy * (1.0 - e);\n    \n    vec3 d1 = d0 - (i1 - 1.0 * K2);\n    vec3 d2 = d0 - (i2 - 2.0 * K2);\n    vec3 d3 = d0 - (1.0 - 3.0 * K2);\n    \n    vec4 h = max(0.6 - vec4(dot(d0, d0), dot(d1, d1), dot(d2, d2), dot(d3, d3)), 0.0);\n    vec4 n = h * h * h * h * vec4(dot(d0, hash33(i)), dot(d1, hash33(i + i1)), dot(d2, hash33(i + i2)), dot(d3, hash33(i + 1.0)));\n    \n    return dot(vec4(31.316), n);\n}\n\nfloat perlin_noise(vec3 p)\n{\n    vec3 pi = floor(p);\n    vec3 pf = p - pi;\n    \n    vec3 w = pf * pf * (3.0 - 2.0 * pf);\n    \n    return \tmix(\n        \t\tmix(\n                \tmix(dot(pf - vec3(0, 0, 0), hash33(pi + vec3(0, 0, 0))), \n                        dot(pf - vec3(1, 0, 0), hash33(pi + vec3(1, 0, 0))),\n                       \tw.x),\n                \tmix(dot(pf - vec3(0, 0, 1), hash33(pi + vec3(0, 0, 1))), \n                        dot(pf - vec3(1, 0, 1), hash33(pi + vec3(1, 0, 1))),\n                       \tw.x),\n                \tw.z),\n        \t\tmix(\n                    mix(dot(pf - vec3(0, 1, 0), hash33(pi + vec3(0, 1, 0))), \n                        dot(pf - vec3(1, 1, 0), hash33(pi + vec3(1, 1, 0))),\n                       \tw.x),\n                   \tmix(dot(pf - vec3(0, 1, 1), hash33(pi + vec3(0, 1, 1))), \n                        dot(pf - vec3(1, 1, 1), hash33(pi + vec3(1, 1, 1))),\n                       \tw.x),\n                \tw.z),\n    \t\t\tw.y);\n}\n\nvec3 perlin_noise_1(vec3 p)  // 返回向量插值\n{\n    vec3 pi = floor(p);\n    vec3 pf = p - pi;\n    \n    //vec3 w = pf * pf * (3.0 - 2.0 * pf);\n    vec3 w = 6.*pf*pf*pf*pf*pf-15.*pf*pf*pf*pf+10.*pf*pf*pf;\n    vec3 v_1 = length(pf - vec3(0, 0, 0))*hash33_sin(pi + vec3(0, 0, 0));\n    vec3 v_2 = length(pf - vec3(1, 0, 0))*hash33_sin(pi + vec3(1, 0, 0));\n    vec3 v_3 = length(pf - vec3(0, 0, 1))*hash33_sin(pi + vec3(0, 0, 1));\n    vec3 v_4 = length(pf - vec3(1, 0, 1))*hash33_sin(pi + vec3(1, 0, 1));\n    vec3 v_5 = length(pf - vec3(0, 1, 0))*hash33_sin(pi + vec3(0, 1, 0));\n    vec3 v_6 = length(pf - vec3(1, 1, 0))*hash33_sin(pi + vec3(1, 1, 0));\n    vec3 v_7 = length(pf - vec3(0, 1, 1))*hash33_sin(pi + vec3(0, 1, 1));\n    vec3 v_8 = length(pf - vec3(1, 1, 1))*hash33_sin(pi + vec3(1, 1, 1));\n    \n    //return v_1+v_2+v_3+v_4+v_5+v_6+v_7+v_8;\n    vec3 final = w.y*(w.z*(w.x*v_1+(1.-w.x)*v_2)+(1.-w.z)*(w.x*v_3+(1.-w.x)*v_4))+(1.-w.y)*(w.z*(w.x*v_5+(1.-w.x)*v_6)+(1.-w.z)*(w.x*v_7+(1.-w.x)*v_8));\n    return final;\n      \n}\n\nfloat noise(vec2 p)\n{\n    return simplex_noise(p);\n}\nfloat noise(vec3 p)\n{\n    return simplex_noise(p);\n}\n\nvec3 noise_v(vec3 p)\n{\n    return hash33(p);\n}\n\nfloat noise_sum(vec2 p)\n{\n    float f = 0.0;\n    p = p * 4.0;\n    f += 1.0000 * noise(p); p = 2.0 * p;\n    f += 0.5000 * noise(p); p = 2.0 * p;\n\tf += 0.2500 * noise(p); p = 2.0 * p;\n\tf += 0.1250 * noise(p); p = 2.0 * p;\n\tf += 0.0625 * noise(p); p = 2.0 * p;\n    \n    return f;\n}\n\nfloat noise_sum(vec3 p)\n{\n    float f = 0.0;\n    p = p * 4.0;\n    f += 1.0000 * noise(p); p = 2.0 * p;\n    f += 0.5000 * noise(p); p = 2.0 * p;\n\tf += 0.2500 * noise(p); p = 2.0 * p;\n\tf += 0.1250 * noise(p); p = 2.0 * p;\n\tf += 0.0625 * noise(p); p = 2.0 * p;\n    \n    return f;\n}\n\n\nvec3 noise_sum_v(vec3 p)\n{\n    vec3 f = vec3(0.0);\n    p = p * 4.0;\n    f += 1.0000 * noise_v(p); p = 2.0 * p;\n    f += 0.5000 * noise_v(p); p = 2.0 * p;\n\tf += 0.2500 * noise_v(p); p = 2.0 * p;\n\tf += 0.1250 * noise_v(p); p = 2.0 * p;\n\tf += 0.0625 * noise_v(p); p = 2.0 * p;\n    \n    return f;\n}\n\n/*vec3 potential_sum(float f_1,float f_2,float f_3)\n{\n    return vec3(f_1,f_2,f_3);\n}*/\n\nfloat calc_partialD(vec2 uv,vec2 offset,vec2 delta)\n{\n    //float f_1,f_2;\n    float f_1 = noise_sum(uv+offset+delta);\n    float f_2 = noise_sum(uv+offset-delta);\n    return (f_1-f_2)/(2.*length(delta));\n}\n\nfloat calc_partialD(vec3 uv,vec3 offset,vec3 delta)\n{\n    //float f_1,f_2;\n    float f_1 = noise_sum(uv+offset+delta);\n    float f_2 = noise_sum(uv+offset-delta);\n    return (f_1-f_2)/(2.*length(delta));\n}\n\nfloat calc_partialD_v(vec3 uv,vec3 delta,float a)\n{\n    vec3 potential_1 = noise_sum_v(uv+delta);\n    vec3 potential_2 = noise_sum_v(uv-delta);\n    vec3 D_poten = potential_1-potential_2;\n    \n    //return length((D_poten*delta)/(2.*length(delta)*length(delta)));\n    if(a == 1.)\n        return (D_poten/(2.*length(delta))).x;\n    else if(a==2.)\n        return (D_poten/(2.*length(delta))).y;\n    else if(a==3.)\n        return (D_poten/(2.*length(delta))).z;\n            \n     \n}\n\n\nvec3 calc_velocity(vec2 uv)  \n{\n    float y_3 = calc_partialD(vec2(uv.y,uv.x),Offset3,vec2(0.,0.0001));\n    float z_2 = calc_partialD(uv,Offset2,vec2(0.,0.0001));\n    float z_1 = calc_partialD(uv,Offset1,vec2(0.,0.0001));\n    \n    float x_3 = calc_partialD(vec2(uv.y,uv.x),Offset3,vec2(0.0001,0.));\n    float x_2 = calc_partialD(uv,Offset2,vec2(0.0001,0.));\n    float y_1 = calc_partialD(uv,Offset1,vec2(0.0001,0.));\n    \n    return vec3(y_3-z_2,z_1-x_3,x_2-y_1);\n}\n\nvec3 calc_velocity(vec3 p)\n{\n    // 1    x           y            z\n    // 2    y+31.416    z-47.853    x+12.793\n    // 3    z-233.145   x-113.408   y-185.31\n    float y_3 = calc_partialD(vec2(p.z,p.x),Offset3_x,vec2(0.,0.0001));\n    float z_2 = calc_partialD(vec2(p.y,p.x),Offset2_x,vec2(0.,0.0001));\n    float z_1 = calc_partialD(vec2(p.y,p.z),Offset1_x,vec2(0.,0.0001));\n    \n    float x_3 = calc_partialD(vec2(p.z,p.x),Offset3_x,vec2(0.0001,0.));\n    float x_2 = calc_partialD(vec2(p.y,p.x),Offset2_x,vec2(0.0001,0.));\n    float y_1 = calc_partialD(vec2(p.y,p.z),Offset1_x,vec2(0.0001,0.));\n    \n    return vec3(y_3-z_2,z_1-x_3,x_2-y_1);\n}\nvec3 calc_velocity_2(vec3 p)\n{\n   //vec3 potential = noise_sum(p);\n   float y_3 = calc_partialD_v(p,vec3(0.,0.0001,0.),3.);\n   float z_2 = calc_partialD_v(p,vec3(0.,0.,0.0001),2.);\n   float z_1 = calc_partialD_v(p,vec3(0.,0.,0.0001),1.);\n    \n    float x_3 = calc_partialD_v(p,vec3(0.0001,0.,0.),3.);\n    float x_2 = calc_partialD_v(p,vec3(0.0001,0.,0.),2.);\n    float y_1 = calc_partialD_v(p,vec3(0.,0.0001,0.),1.); \n    \n    return vec3(y_3-z_2,z_1-x_3,x_2-y_1);\n}\nvec3 calc_velocity_3(vec3 p)\n{\n    // 1    x           y            z\n    // 2    y+31.416    z-47.853    x+12.793\n    // 3    z-233.145   x-113.408   y-185.31\n    float y_3 = calc_partialD(vec3(p.z,p.x,p.y),Offset3_3,vec3(0.,0.0001,0.));\n    float z_2 = calc_partialD(vec3(p.y,p.x,p.z),Offset2_3,vec3(0.,0.,0.0001));\n    float z_1 = calc_partialD(vec3(p.y,p.z,p.x),Offset1_3,vec3(0.,0.,0.0001));\n    \n    float x_3 = calc_partialD(vec3(p.z,p.x,p.y),Offset3_3,vec3(0.0001,0.,0.));\n    float x_2 = calc_partialD(vec3(p.y,p.x,p.z),Offset2_3,vec3(0.0001,0.,0.));\n    float y_1 = calc_partialD(vec3(p.y,p.z,p.x),Offset1_3,vec3(0.,0.0001,0.));\n    \n    return vec3(y_3-z_2,z_1-x_3,x_2-y_1);\n}\n\n\nvec3 draw_cloud(float f)\n{\n    f = f * 0.5 + 0.5;\n    return mix(\tvec3(8.0/255.0, 65.0/255.0, 82.0/255.0),\n              \tvec3(178.0/255.0, 161.0/255.0, 205.0/255.0),\n               \tf*f);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   vec2 p = fragCoord.xy / iResolution.xy;\n    vec2 uv = p * vec2(iResolution.x/iResolution.y, 1.0);\n     float f = 0.0;\n    vec3 col = vec3(0.0, 0.0, 0.0);\n\n     //float f_1 = noise_sum(uv);                    //y,z\n   // float f_2 = noise_sum(vec2(uv.x+31.416,uv.y-47.853));        //x,z\n   // float f_3 =noise_sum(vec2(uv.y-233.145,uv.x-185.31));                //x,y\n     //col = vec3(f_1,f_2,f_3);\n    \n    //vec3 v = calc_velocity((uv+vec2(iTime/10.))/5.);\n   //vec3 v =calc_velocity(vec3(uv.x,uv.y,iTime/100.)/5.);\n    vec3 v =calc_velocity_3(vec3(uv.x,uv.y,iTime/200.));\n    //vec3 v = calc_velocity_2(vec3(uv.x,uv.y,iTime/200000.))/200.;  \n    \n    col =vec3(length(v)/64.);\n    //col =vec3(length(v)*length(v)/64./64.);\n    // f = f * 0.5 + 0.5;\n    // Output to screen\n    \n    //col = hash33_sin(vec3(uv.x,uv.y,iTime));\n    //col = noise_sum(vec3(uv.x,uv.y,iTime));\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MtdyDH.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 504, 525, 525, 723], [724, 724, 746, 746, 904], [906, 906, 932, 932, 1098], [1101, 1101, 1130, 1130, 1674], [1675, 1675, 1704, 1704, 2421], [2423, 2423, 2451, 2451, 3390], [3392, 3392, 3444, 3444, 4422], [4424, 4424, 4445, 4445, 4476], [4477, 4477, 4498, 4498, 4529], [4531, 4531, 4553, 4553, 4577], [4579, 4579, 4604, 4604, 4857], [4859, 4859, 4884, 4884, 5137], [5140, 5140, 5166, 5166, 5434], [5436, 5525, 5578, 5599, 5730], [5732, 5732, 5785, 5806, 5937], [5939, 5939, 5990, 5990, 6418], [6421, 6421, 6452, 6452, 6886], [6888, 6888, 6916, 7045, 7531], [7532, 7532, 7562, 7598, 7998], [7999, 7999, 8029, 8158, 8686], [8689, 8689, 8715, 8715, 8879], [8881, 8881, 8938, 8938, 9849]], "test": "untested"}
{"id": "MtdyRn", "name": "Dancing stickman fractal", "author": "Firzen_", "description": "I spend my time sensibly, alright?", "tags": ["fractal", "visualization", "dance"], "likes": 8, "viewed": 223, "published": "Public", "date": "1531336031", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define pi (acos(-1.))\n\nfloat leftLeg(vec2 uv)\n{\n    float lift = -texture(iChannel0, vec2(0.1,0.)).r+0.7;\n    uv.y += lift*abs(uv.x-0.5);\n    return smoothstep(0.01,0.0, abs(length(uv-vec2(0.5,0.17))-0.12)) * smoothstep(0.02, 0., -0.5+uv.x) * smoothstep(0.02,0.,0.17-uv.y);\n}\n\nfloat rightLeg(vec2 uv)\n{\n    float lift = -texture(iChannel0, vec2(0.2,0.)).r+0.7;\n    uv.y += lift*abs(uv.x-0.5);\n    return smoothstep(0.01,0.0, abs(length(uv-vec2(0.5,0.17))-0.12)) * smoothstep(0.02, 0., 0.5-uv.x) * smoothstep(0.02,0.,0.17-uv.y);\n}\n\nfloat leftArm(vec2 uv)\n{\n    float str = texture(iChannel0, vec2(0.3,0.)).r;\n    float lift = (texture(iChannel0,vec2(uv.x,1.)).r-0.5)*str;\n    uv.y += lift*pow(2.*(0.5-uv.x),1.5);\n    uv.y += texture(iChannel0, vec2(0.005,0.)).r/10.-0.05;\n    return smoothstep(0.01,0.0, abs(uv.y-0.55)) * smoothstep(0.12, 0.1, abs(uv.x-0.4));\n}\n\nfloat rightArm(vec2 uv)\n{\n    float str = texture(iChannel0, vec2(0.4,0.)).r;\n    float lift = (texture(iChannel0,vec2(uv.x,1.)).r-0.5)*str;\n    uv.y += lift*pow(2.*(uv.x-0.5),1.5);\n    uv.y += texture(iChannel0, vec2(0.005,0.)).r/10.-0.05;\n    return smoothstep(0.01,0.0, abs(uv.y-0.55)) * smoothstep(0.12, 0.1, abs(uv.x-0.6));\n}\n\nfloat torso(vec2 uv)\n{\n    float str = texture(iChannel0, vec2(0.0005,0.)).r;\n    uv.x += str*(texture(iChannel0, vec2(uv.y, 1.)).r-0.5)*max(0.,0.2-abs(uv.y-0.5));\n    return smoothstep(0.01,0.0,abs(uv.x-0.5))*smoothstep(0.22,0.2,abs(uv.y-0.5));\n}\n\nfloat head(vec2 uv)\n{\n    float bop = -texture(iChannel0, vec2(0.0005, 0.)).r/20.;\n    vec2 circ = uv-vec2(0.5, 0.7+bop);\n    float angl = (atan(circ.y,circ.x)+pi)/(2.*pi);\n    float offs = (texture(iChannel0, vec2(angl, 0.)).r-0.1)*2.*-bop;\n    return smoothstep(0.055+offs,0.05+offs,length(circ));\n}\n    \nfloat stickman(vec2 uv)\n{\n    uv = fract(3.*uv);\n    uv.y += texture(iChannel0, vec2(0.005,0.)).r/3.-0.25;\n    uv.x += texture(iChannel0, vec2(0.505,0.)).r/3.-0.1;\n    return max(leftLeg(uv), max( rightLeg(uv), max( leftArm(uv), max(rightArm(uv), max(torso(uv), head(uv))))));\n}\n\nvec3 insideColor(vec2 uv)\n{\n    return vec3(0.);\n}\n\nvec4 inside(vec2 uv)\n{\n    float counter = 0.;\n    vec2 fr = fract(uv);\n    while(counter++ < 6.)\n    {\n        if (fr.x>1./3. && fr.x < 2./3.)\n            return vec4(0., fr, counter);\n        if (fr.y>1./3. && fr.y < 2./3.)\n            return vec4(0., fr, counter);\n        fr *= 3.;\n        fr = fract(fr);\n    }\n    return vec4(1., fr, 7);\n}\n\nvec3 cellColor(float depth)\n{\n    float f = depth/10.+0.1;\n    return clamp(3.*vec3(\n        texture(iChannel0, vec2(f+0.0005, 0)).r/2.,\n        texture(iChannel0, vec2(f-0.15, 0)).r/2.,\n        texture(iChannel0, vec2(f+0.15, 0)).r/2.\n    ), 0., 1.);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    uv -= vec2(0.5);\n    uv.y *= iResolution.y/iResolution.x;\n    \n    float f = texture(iChannel0, vec2(0.0005, 0.)).r;\n    const float timeScale = 0.3;\n    \n    float t2 = timeScale*(iTime+f);\n    float t = mod(t2,2.)+1.;\n\n    // Time varying pixel color\n    vec4 stickMix = inside(uv/t);\n    float dp = pow(3., stickMix.w);\n    vec2 cel = floor((uv/t)*dp)/dp;\n    vec3 col = 0.5 + 0.5*cos(t2+23.*(cel.xyx+vec3(0,2,4)));\n    //vec3 col = 0.5*cos(t2+cel.xyx+vec3(4,2,-7)) + 0.5*cos(-t2+cel.yyx+vec3(0,1,4));\n    \n    vec2 dir = vec2(cos(t2), -1);\n    dir = normalize(dir);\n    float stick = 0.;\n    const float blurSteps = 20.;\n    const float blurScale = 0.001;\n    for(float i=0.; i<blurSteps; i++)\n    {\n        stick += stickman(stickMix.yz + (stickMix.w*f*dir*i*blurScale))*(blurSteps-i);\n    }\n    stick /= (blurSteps*(blurSteps+1.))/2.;\n\n    // Output to screen\n    fragColor = mix(vec4(col,1.),vec4(0.*(vec3(1.)-col),1.),stick);\n}", "image_inputs": [{"id": "Xs2SRt", "previewfilepath": "https://soundcloud.com/mr50music/mr-50-reeses-pieces-bristol", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0, "src": "https://soundcloud.com/mr50music/mr-50-reeses-pieces-bristol", "ctype": "musicstream"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MtdyRn.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[24, 24, 48, 48, 276], [278, 278, 303, 303, 530], [532, 532, 556, 556, 861], [863, 863, 888, 888, 1193], [1195, 1195, 1217, 1217, 1442], [1444, 1444, 1465, 1465, 1745], [1751, 1751, 1776, 1776, 2029], [2031, 2031, 2058, 2058, 2081], [2083, 2083, 2105, 2105, 2428], [2430, 2430, 2459, 2459, 2683], [2685, 2685, 2742, 2792, 3772]], "test": "untested"}
{"id": "MtdyRr", "name": "Ethereal Gradient Shape", "author": "momoro", "description": "2018-7-11 Blob", "tags": ["bookofshaders"], "likes": 9, "viewed": 227, "published": "Public", "date": "1531369155", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 st = fragCoord.xy / iResolution.xy;\n    st.x *= iResolution.x/iResolution.y;\n\tst.x -= .45;\n    \n    /////////////////////////////////////\n    /* MASK */\n    vec2 center = vec2(.5, .5);\n    float dist = distance(center, st);\n    \n    // Cool up and down movement\n    //dist -= sin(u_time+st.y*10.)/20.;\n    \n    \n    float size =  sin(iTime*2.)/8.+.5;\n\n    float offset = (sin(iTime+10.*atan(st.x, st.y))) / (size * 40.);\n\tdist += offset;\n    \n    \n    //Hard edge\n    //dist = dist < .2 ? 0. : 1.;\n\n    // Soft edge\n    float radius = sin(iTime)/20.+0.;\n    float softness = 0.315 + smoothstep(radius+.1, radius+.02, dist);\n    dist = smoothstep(radius,radius+softness, dist);\n    \n    \n    \n    /////////////////////////////////////\n    /* COLOR */\n    vec3 colA = vec3(0.915,0.045,0.037);\n    vec3 colB = vec3(0.980,0.691,0.036);\n\tvec3 colC = vec3(sin(iTime)/8.+.8,0.233,0.975);\n    \n    vec3 gradient = 2.0 * mix(colA, colB, smoothstep(0., 1., sin(iTime*3.) * st.y + .1));\n    gradient =  1.2 * mix(gradient, colC, smoothstep(0.,1., st.x));\n    \n\tvec3 color = vec3(gradient);\n    color *= (1.-dist);\n    fragColor = vec4(color,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MtdyRr.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 1201]], "test": "untested"}
{"id": "MtdyW7", "name": "Assignment5_task2_G3", "author": "wln928672785", "description": "Assignment5_task2_G3", "tags": ["2d"], "likes": 0, "viewed": 132, "published": "Public", "date": "1532933943", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Created by inigo quilez - iq/2015\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n//============================================================================\n// Constants.\n//============================================================================\nconst int NUM_LIGHTS = 2;\nconst int NUM_MATERIALS = 8;\nconst int NUM_PLANES = 5;\nconst int NUM_SPHERES = 20;\n\nconst float eradius=0.15;\n\nconst vec3 BACKGROUND_COLOR = vec3( 0.5, 0.1, 0.8 );\n\n // Vertical field-of-view angle of camera. In radians.\nconst float FOVY = 50.0 * 3.1415926535 / 180.0;\n\n// Use this for avoiding the \"epsilon problem\" or the shadow acne problem.\nconst float DEFAULT_TMIN = 10.0e-4;\n\n// Use this for tmax for non-shadow ray intersection test.\nconst float DEFAULT_TMAX = 10.0e6;\n\n// Equivalent to number of recursion levels (0 means ray-casting only).\n// We are using iterations to replace recursions.\nconst int NUM_ITERATIONS = 2;\n\nconst float PI = 3.1415926;\n\n//============================================================================\n// Define new struct types.\n//============================================================================\nstruct Ray_t {\n    vec3 o;  // Ray Origin.\n    vec3 d;  // Ray Direction. A unit vector.\n};\n\nstruct Plane_t {\n    // The plane equation is Ax + By + Cz + D = 0.\n    float A, B, C, D;\n    int materialID;\n};\n\nstruct Sphere_t {\n    vec3 center;\n    float radius;\n    int materialID;\n};\n\nstruct Light_t {\n    vec3 position;  // Point light 3D position.\n    vec3 I_a;       // For Ambient.\n    vec3 I_source;  // For Diffuse and Specular.\n};\n\nstruct Material_t {\n    vec3 k_a;   // Ambient coefficient.\n    vec3 k_d;   // Diffuse coefficient.\n    vec3 k_r;   // Reflected specular coefficient.\n    vec3 k_rg;  // Global reflection coefficient.\n    float n;    // The specular reflection exponent. Ranges from 0.0 to 128.0.\n};\n\n//----------------------------------------------------------------------------\n// The lighting model used here is similar to that on Slides 8 and 12 of\n// Lecture 11 (Ray Tracing). Here it is computed as\n//\n//     I_local = SUM_OVER_ALL_LIGHTS {\n//                   I_a * k_a +\n//                   k_shadow * I_source * [ k_d * (N.L) + k_r * (R.V)^n ]\n//               }\n// and\n//     I = I_local  +  k_rg * I_reflected\n//----------------------------------------------------------------------------\n\n\n//============================================================================\n// Global scene data.\n//============================================================================\nPlane_t Plane[NUM_PLANES];\nSphere_t Sphere[NUM_SPHERES];\nLight_t Light[NUM_LIGHTS];\nMaterial_t Material[NUM_MATERIALS];\n\n/////////////////////////////////////////////////////////////////////////////\n// Initializes the scene.\n/////////////////////////////////////////////////////////////////////////////\nvoid InitScene()\n{\n    // Horizontal plane.\n    Plane[0].A = 0.0;\n    Plane[0].B = 0.0;\n    Plane[0].C = 0.0;\n    Plane[0].D = 0.0;\n    Plane[0].materialID = 0;\n\n    // Vertical right plane.\n    Plane[1].A = 0.0;\n    Plane[1].B = 0.0;\n    Plane[1].C = 1.0;\n    Plane[1].D = 7.5;\n    Plane[1].materialID = 4;\n    \n    // Vertical left plane.\n    Plane[2].A = 1.0;\n    Plane[2].B = 0.0;\n    Plane[2].C = 0.0;\n    Plane[2].D = 7.5;\n    Plane[2].materialID = 5;\n    \n    // Vertical right plane.\n    Plane[3].A = 0.0;\n    Plane[3].B = 0.0;\n    Plane[3].C = -1.0;\n    Plane[3].D = 7.5;\n    Plane[3].materialID = 6;\n    \n    // Vertical left plane.\n    Plane[4].A = -1.0;\n    Plane[4].B = 0.0;\n    Plane[4].C = 0.0;\n    Plane[4].D = 7.5;\n    Plane[4].materialID = 7;\n\n    // Biggest sphere.\n    Sphere[0].center = vec3( 1.5*sin(iTime),  0.4,  1.5*cos(iTime) );\n    Sphere[0].radius = 0.0;\n    Sphere[0].materialID = 1;\n\n    // Circling sphere.\n    Sphere[1].center = vec3(  1.5*sin(iTime)+0.7*cos(iTime), 0.5*abs( sin(2.0 * iTime)) + 0.2, 0.7*sin(iTime)+  1.5*cos(iTime) );\n    Sphere[1].radius = 0.0;\n    Sphere[1].materialID = 2;\n    \n    // Center sphere.\n    Sphere[2].center = vec3( 0, 1.33*abs( sin(2.0*iTime+ PI/2.0))+0.3, 0 );\n    Sphere[2].radius = sin(2.0*iTime+ PI/2.0)> 0.78 ? 0.15+0.35*sin(2.0*iTime+ PI/2.0): 0.35;\n    Sphere[2].materialID = 3;\n    \n    // Circling sphere.\n    Sphere[3].center = vec3(  0,  1.5,  0 );\n    Sphere[3].radius = 0.0;\n    Sphere[3].materialID = 2;\n    \n    // First sphere.\n    Sphere[4].center = vec3(2.0-2.0*sin(2.0*iTime+ PI/2.0), 1.5*abs(sin(2.0*iTime+ PI/2.0))+0.19,  0 );\n    Sphere[4].radius = sin(iTime) > 0.0 ? 0.0 : 0.3-0.25*sin(2.0*iTime+ PI/2.0);\n    Sphere[4].materialID = 0;\n    \n    // Second sphere.\n    Sphere[5].center = vec3( (2.0-2.0*sin(2.0*iTime+ PI/2.0))*sin(PI/4.0),  1.5*abs(sin(2.0*iTime+ PI/2.0))+0.19,  -(2.0-2.0*sin(2.0*iTime+ PI/2.0))*sin(PI/4.0) );\n    Sphere[5].radius = sin(iTime) > 0.0 ? 0.0 : 0.3-0.25*sin(2.0*iTime+ PI/2.0);\n    Sphere[5].materialID = 0;\n    \n    // Third sphere.\n    Sphere[6].center = vec3(  0,  1.5*abs(sin(2.0*iTime+ PI/2.0))+0.19,  -(2.0-2.0*sin(2.0*iTime+ PI/2.0)) );\n    Sphere[6].radius = sin(iTime) > 0.0 ? 0.0 : 0.3-0.25*sin(2.0*iTime+ PI/2.0);\n    Sphere[6].materialID = 0;\n    \n    // Fourth sphere.\n    Sphere[7].center = vec3(  -(2.0-2.0*sin(2.0*iTime+ PI/2.0))*sin(PI/4.0),  1.5*abs(sin(2.0*iTime+ PI/2.0))+0.19,  -(2.0-2.0*sin(2.0*iTime+ PI/2.0))*sin(PI/4.0) );\n    Sphere[7].radius = sin(iTime) > 0.0 ? 0.0 : 0.3-0.25*sin(2.0*iTime+ PI/2.0);\n    Sphere[7].materialID = 0;\n    \n    // Fifth sphere.\n    Sphere[8].center = vec3(  -(2.0-2.0*sin(2.0*iTime+ PI/2.0)),  1.5*abs(sin(2.0*iTime+ PI/2.0))+0.19, 0.0 );\n    Sphere[8].radius = sin(iTime) > 0.0 ? 0.0 : 0.3-0.25*sin(2.0*iTime+ PI/2.0);\n    Sphere[8].materialID = 0;\n    \n    // Sixth sphere.\n    Sphere[9].center = vec3( -(2.0-2.0*sin(2.0*iTime+ PI/2.0))*sin(PI/4.0), 1.5*abs(sin(2.0*iTime+ PI/2.0))+0.19,  (2.0-2.0*sin(2.0*iTime+ PI/2.0))*sin(PI/4.0) );\n    Sphere[9].radius = sin(iTime) > 0.0 ? 0.0 : 0.3-0.25*sin(2.0*iTime+ PI/2.0);\n    Sphere[9].materialID = 0;\n    \n    // Seventh sphere.\n    Sphere[10].center = vec3(  0, 1.5*abs(sin(2.0*iTime+ PI/2.0))+0.19,  2.0-2.0*sin(2.0*iTime+ PI/2.0) );\n    Sphere[10].radius = sin(iTime) > 0.0 ? 0.0 : 0.3-0.25*sin(2.0*iTime+ PI/2.0);\n    Sphere[10].materialID = 0;\n    \n    // Eigth sphere.\n    Sphere[11].center = vec3(  (2.0-2.0*sin(2.0*iTime+ PI/2.0))*sin(PI/4.0), 1.5*abs(sin(2.0*iTime+ PI/2.0))+0.19, (2.0-2.0*sin(2.0*iTime+ PI/2.0))*sin(PI/4.0) );\n    Sphere[11].radius = sin(iTime) > 0.0 ? 0.0 : 0.3-0.25*sin(2.0*iTime+ PI/2.0);\n    Sphere[11].materialID = 0;\n    \n    // First sphere.\n    \n      // First sphere.\n    \n   // First sphere.\n    \n    if(sin(iTime)>0.0)\n    Sphere[12].center = vec3( 1.2*sin(2.0*4.0/3.0*iTime)*sin(iTime),1.5*abs(sin(2.0*iTime+ PI/2.0))+0.19,  1.2*cos(2.0*4.0/3.0*iTime)*sin(iTime));\n    else\n        Sphere[12].center = Sphere[2].center;\n    vec3 distan1=Sphere[2].center-Sphere[12].center;\n\n    Sphere[12].radius = eradius;\n    Sphere[12].materialID = 0;\n\n    // Second sphere.\n    \n    if(sin(iTime)>0.0)\n    Sphere[13].center = vec3( 1.6*sin(2.0*4.0/3.0*(iTime-PI/32.0))*sin(iTime),1.5*abs(sin(2.0*iTime+ PI/2.0))+0.19,  1.6*cos(2.0*4.0/3.0*(iTime-PI/32.0))*sin(iTime));\n    else\n        Sphere[13].center = Sphere[2].center;\n    Sphere[13].radius = eradius;\n    Sphere[13].materialID = 0;\n\n    // Third sphere.\n    if(sin(iTime)>0.0)\n    Sphere[14].center = vec3( 2.0*sin(2.0*4.0/3.0*(iTime-2.0*PI/32.0))*sin(iTime),1.5*abs(sin(2.0*iTime+ PI/2.0))+0.19,  2.0*cos(2.0*4.0/3.0*(iTime-2.0*PI/32.0))*sin(iTime));\n    else\n        Sphere[14].center = Sphere[2].center;\n    Sphere[14].radius = eradius;\n    Sphere[14].materialID = 0;\n\n    // Fourth sphere.\n    if(sin(iTime)>0.0)\n     Sphere[15].center = vec3( 2.4*sin(2.0*4.0/3.0*(iTime-3.0*PI/32.0))*sin(iTime),1.5*abs(sin(2.0*iTime+ PI/2.0))+0.19,  2.4*cos(2.0*4.0/3.0*(iTime-3.0*PI/32.0))*sin(iTime));\n    else\n        Sphere[15].center = Sphere[2].center;\n    Sphere[15].radius = eradius;\n    Sphere[15].materialID = 0;\n    \n    \n    // Fifth sphere.\n    if(sin(iTime)>0.0)\n    Sphere[16].center = vec3( 2.8*sin(2.0*4.0/3.0*(iTime-4.0*PI/32.0))*sin(iTime),1.5*abs(sin(2.0*iTime+ PI/2.0))+0.19,  2.8*cos(2.0*4.0/3.0*(iTime-4.0*PI/32.0))*sin(iTime));\n    else\n        Sphere[16].center = Sphere[2].center;\n    Sphere[16].radius = eradius;\n    Sphere[16].materialID = 0;\n\n    // Third sphere.\n    if(sin(iTime)>0.0)\n    Sphere[17].center = vec3( 3.2*sin(2.0*4.0/3.0*(iTime-5.0*PI/32.0))*sin(iTime),1.5*abs(sin(2.0*iTime+ PI/2.0))+0.19,  3.2*cos(2.0*4.0/3.0*(iTime-5.0*PI/32.0))*sin(iTime));\n    else\n        Sphere[17].center = Sphere[2].center;\n    Sphere[17].radius = eradius;\n    Sphere[17].materialID = 0;\n\n    // Fourth sphere.\n    if(sin(iTime)>0.0)\n     Sphere[18].center = vec3( 3.6*sin(2.0*4.0/3.0*(iTime-6.0*PI/32.0))*sin(iTime),1.5*abs(sin(2.0*iTime+ PI/2.0))+0.19,  3.6*cos(2.0*4.0/3.0*(iTime-6.0*PI/32.0))*sin(iTime));\n    else\n        Sphere[18].center = Sphere[2].center;\n    Sphere[18].radius = eradius;\n    Sphere[18].materialID = 0;\n\n    // Eigth sphere.\n    if(sin(iTime)>0.0)\n     Sphere[19].center = vec3( 4.0*sin(2.0*4.0/3.0*(iTime-7.0*PI/32.0))*sin(iTime),1.5*abs(sin(2.0*iTime+ PI/2.0))+0.19,  4.0*cos(2.0*4.0/3.0*(iTime-7.0*PI/32.0))*sin(iTime));\n    else\n        Sphere[19].center = Sphere[2].center;\n    Sphere[19].radius = eradius;\n    Sphere[19].materialID = 0;\n    // Silver material.\n    Material[0].k_d = vec3( 1.0, 1.0, 1.0 );\n    Material[0].k_a = 0.2 * Material[0].k_d;\n    Material[0].k_r = 2.0 * Material[0].k_d;\n    Material[0].k_rg = 0.5 * Material[0].k_r;\n    Material[0].n = 64.0;\n\n    // Gold material.\n    Material[1].k_d = vec3( 0.4, 0.6, 0.9 );\n    Material[1].k_a = 0.2 * Material[1].k_d;\n    Material[1].k_r = 2.0 * Material[1].k_d;\n    Material[1].k_rg = 0.5 * Material[1].k_r;\n    Material[1].n = 64.0;\n\n    // Green plastic material.\n    Material[2].k_d = vec3( 0.8, 0.4, 0.3 );\n    Material[2].k_a = 0.2 * Material[2].k_d;\n    Material[2].k_r = 2.0 * Material[2].k_d;\n    Material[2].k_rg = 0.5 * Material[2].k_r;\n    Material[2].n = 128.0;\n    \n    // Another plastic material.\n    Material[3].k_d = vec3( 0.8, sin(iTime), cos(iTime) );\n    Material[3].k_a = 0.2 * Material[3].k_d;\n    Material[3].k_r = 2.0 * Material[3].k_d;\n    Material[3].k_rg = 0.5 * Material[3].k_r;\n    Material[3].n = 128.0;\n    \n    // Another plastic material.\n    Material[4].k_d = vec3( 0.6, sin(iTime), 0.7+0.3*cos(iTime) );\n    Material[4].k_a = 0.2 * Material[3].k_d;\n    Material[4].k_r = 2.0 * Material[2].k_d;\n    Material[4].k_rg = 0.5 * Material[2].k_r;\n    Material[4].n = 128.0;\n    \n    // Another plastic material.\n    Material[5].k_d = vec3( sin(iTime),0.8,  0.8+0.2*cos(iTime) );\n    Material[5].k_a = 0.2 * Material[3].k_d;\n    Material[5].k_r = 2.0 * Material[2].k_d;\n    Material[5].k_rg = 0.5 * Material[2].k_r;\n    Material[5].n = 128.0;\n    \n    // Another plastic material.\n    Material[6].k_d = vec3(  sin(iTime),0.3+0.7* cos(iTime),0.7 );\n    Material[6].k_a = 0.2 * Material[3].k_d;\n    Material[6].k_r = 2.0 * Material[2].k_d;\n    Material[6].k_rg = 0.5 * Material[2].k_r;\n    Material[6].n = 128.0;\n    \n    // Another plastic material.\n    Material[7].k_d = vec3( 0.8,0.4+ 0.6*sin(iTime), 0.5+0.5*cos(iTime) );\n    Material[7].k_a = 0.2 * Material[3].k_d;\n    Material[7].k_r = 2.0 * Material[2].k_d;\n    Material[7].k_rg = 0.5 * Material[2].k_r;\n    Material[7].n = 128.0;\n\n    // Light 0.\n    Light[0].position = vec3( 0.0, 15.0, 0.0 );\n    Light[0].I_a = vec3( sin(iTime)*0.1, sin(iTime)*0.1,sin(iTime)*0.1 );\n    Light[0].I_source = vec3( 0.7, 0.7, 0.7 );\n\n    // Light 1.\n    Light[1].position = vec3( 4.0*sin(iTime), -15.0, 4.0*cos(iTime) );\n    Light[1].I_a = vec3( 0.4, 0.4, 0.4 );\n    Light[1].I_source = vec3( 0.5, 0.5, 0.5 );\n    \n}\n\n\n/////////////////////////////////////////////////////////////////////////////\n// Computes intersection between a plane and a ray.\n// Returns true if there is an intersection where the ray parameter t is\n// between tmin and tmax, otherwise returns false.\n// If there is such an intersection, outputs the value of t, the position\n// of the intersection (hitPos) and the normal vector at the intersection\n// (hitNormal).\n/////////////////////////////////////////////////////////////////////////////\nbool IntersectPlane( in Plane_t pln, in Ray_t ray, in float tmin, in float tmax,\n                     out float t, out vec3 hitPos, out vec3 hitNormal )\n{\n    vec3 N = vec3( pln.A, pln.B, pln.C );\n    float NRd = dot( N, ray.d );\n    float NRo = dot( N, ray.o );\n    float t0 = (-pln.D - NRo) / NRd;\n    if ( t0 < tmin || t0 > tmax ) return false;\n\n    // We have a hit -- output results.\n    t = t0;\n    hitPos = ray.o + t0 * ray.d;\n    hitNormal = normalize( N );\n    return true;\n}\n\n\n\n/////////////////////////////////////////////////////////////////////////////\n// Computes intersection between a plane and a ray.\n// Returns true if there is an intersection where the ray parameter t is\n// between tmin and tmax, otherwise returns false.\n/////////////////////////////////////////////////////////////////////////////\nbool IntersectPlane( in Plane_t pln, in Ray_t ray, in float tmin, in float tmax )\n{\n    vec3 N = vec3( pln.A, pln.B, pln.C );\n    float NRd = dot( N, ray.d );\n    float NRo = dot( N, ray.o );\n    float t0 = (-pln.D - NRo) / NRd;\n    if ( t0 < tmin || t0 > tmax ) return false;\n    return true;\n}\n\n\n\n/////////////////////////////////////////////////////////////////////////////\n// Computes intersection between a sphere and a ray.\n// Returns true if there is an intersection where the ray parameter t is\n// between tmin and tmax, otherwise returns false.\n// If there is one or two such intersections, outputs the value of the\n// smaller t, the position of the intersection (hitPos) and the normal\n// vector at the intersection (hitNormal).\n/////////////////////////////////////////////////////////////////////////////\nbool IntersectSphere( in Sphere_t sph, in Ray_t ray, in float tmin, in float tmax,\n                      out float t, out vec3 hitPos, out vec3 hitNormal )\n{\n    /////////////////////////////////\n    // TASK: WRITE YOUR CODE HERE. //\n    /////////////////////////////////\n    ray.o=ray.o-sph.center;\n    float t0,t1,t2;\n    float dRd = dot( ray.d, ray.d );\n    float oRo = dot(ray.o, ray.o);\n    float dRo = dot( ray.d, ray.o );\n    if((dRo*dRo-dRd*(oRo-sph.radius*sph.radius))<0.0)\n        return false;  // Replace this with your code.\n    else\n    {\n        t1=(-dRo+sqrt(dRo*dRo-dRd*(oRo-sph.radius*sph.radius)))/dRd;\n        t2=(-dRo-sqrt(dRo*dRo-dRd*(oRo-sph.radius*sph.radius)))/dRd;\n    }\n    if(t1 <= 0.0&&t2 <= 0.0)\n        return false;\n    else if(t1*t2 <= 0.0 )\n        t0=max(t1,t2);\n    else t0=min(t1,t2);\n\n    if ( t0 <=tmin || t0 >=tmax ) return false;\n    t = t0;\n    hitPos = ray.o + t0 * ray.d+sph.center;\n\n    hitNormal = normalize((ray.o + t0 * ray.d)/sqrt(oRo+dRd));\n    return true;\n\n\n}\n\n\n\n/////////////////////////////////////////////////////////////////////////////\n// Computes intersection between a sphere and a ray.\n// Returns true if there is an intersection where the ray parameter t is\n// between tmin and tmax, otherwise returns false.\n/////////////////////////////////////////////////////////////////////////////\nbool IntersectSphere( in Sphere_t sph, in Ray_t ray, in float tmin, in float tmax )\n{\n    /////////////////////////////////\n    // TASK: WRITE YOUR CODE HERE. //\n    /////////////////////////////////\n    ray.o=ray.o-sph.center;\n    float t0,t1,t2;\n    float dRd = dot( ray.d, ray.d );\n    float oRo = dot(ray.o, ray.o);\n    float dRo = dot( ray.d, ray.o );\n    if((dRo*dRo-dRd*(oRo-sph.radius*sph.radius))<0.0)\n    return false;  // Replace this with your code.\n    else\n    {\n        t1=(-dRo+sqrt(dRo*dRo-dRd*(oRo-sph.radius*sph.radius)))/dRd;\n        t2=(-dRo-sqrt(dRo*dRo-dRd*(oRo-sph.radius*sph.radius)))/dRd;\n    }\n    if(t1 <= 0.0&&t2 <= 0.0)\n        return false;\n    else if(t1*t2 <= 0.0 )\n        t0=max(t1,t2);\n    else t0=min(t1,t2);\n\n    if ( t0 <=tmin || t0 >=tmax ) return false;\n    return true;\n\n}\n\n\n/////////////////////////////////////////////////////////////////////////////\n// Computes (I_a * k_a) + k_shadow * I_source * [ k_d * (N.L) + k_r * (R.V)^n ].\n// Input vectors L, N and V are pointing AWAY from surface point.\n// Assume all vectors L, N and V are unit vectors.\n/////////////////////////////////////////////////////////////////////////////\nvec3 PhongLighting( in vec3 L, in vec3 N, in vec3 V, in bool inShadow,\n                    in Material_t mat, in Light_t light )\n{\n    if ( inShadow ) {\n        return light.I_a * mat.k_a;\n    }\n    else {\n        vec3 R = reflect( -L, N );\n        float N_dot_L = max( 0.0, dot( N, L ) );\n        float R_dot_V = max( 0.0, dot( R, V ) );\n        float R_dot_V_pow_n = ( R_dot_V == 0.0 )? 0.0 : pow( R_dot_V, mat.n );\n\n        return light.I_a * mat.k_a +\n               light.I_source * (mat.k_d * N_dot_L + mat.k_r * R_dot_V_pow_n);\n    }\n}\n\n\n/////////////////////////////////////////////////////////////////////////////\n// Casts a ray into the scene and returns color computed at the nearest\n// intersection point. The color is the sum of light from all light sources,\n// each computed using Phong Lighting Model, with consideration of\n// whether the interesection point is being shadowed from the light.\n// If there is no interesection, returns the background color, and outputs\n// hasHit as false.\n// If there is intersection, returns the computed color, and outputs\n// hasHit as true, the 3D position of the intersection (hitPos), the\n// normal vector at the intersection (hitNormal), and the k_rg value\n// of the material of the intersected object.\n/////////////////////////////////////////////////////////////////////////////\nvec3 CastRay( in Ray_t ray,\n              out bool hasHit, out vec3 hitPos, out vec3 hitNormal, out vec3 k_rg )\n{\n    // Find whether and where the ray hits some object.\n    // Take the nearest hit point.\n\n    bool hasHitSomething = false;\n    float nearest_t = DEFAULT_TMAX;   // The ray parameter t at the nearest hit point.\n    vec3 nearest_hitPos;              // 3D position of the nearest hit point.\n    vec3 nearest_hitNormal;           // Normal vector at the nearest hit point.\n    int nearest_hitMatID;             // MaterialID of the object at the nearest hit point.\n\n    float temp_t;\n    vec3 temp_hitPos;\n    vec3 temp_hitNormal;\n    bool temp_hasHit;\n\n    /////////////////////////////////\n    // TASK: WRITE YOUR CODE HERE. //\n    /////////////////////////////////\n    if (IntersectPlane(Plane[0], ray, DEFAULT_TMIN, nearest_t,\n                       nearest_t, nearest_hitPos, nearest_hitNormal)==true){\n        nearest_hitMatID = Plane[0].materialID;\n        hasHitSomething=true;\n    }\n\n    if(IntersectPlane(Plane[1], ray, DEFAULT_TMIN, nearest_t,\n                      nearest_t, nearest_hitPos, nearest_hitNormal)==true){\n\t\tnearest_hitMatID = Plane[1].materialID;\n        hasHitSomething=true;\n    }\n    \n    if(IntersectPlane(Plane[2], ray, DEFAULT_TMIN, nearest_t,\n                      nearest_t, nearest_hitPos, nearest_hitNormal)==true){\n\t\tnearest_hitMatID = Plane[2].materialID;\n        hasHitSomething=true;\n    }\n    \n    if(IntersectPlane(Plane[3], ray, DEFAULT_TMIN, nearest_t,\n                      nearest_t, nearest_hitPos, nearest_hitNormal)==true){\n\t\tnearest_hitMatID = Plane[3].materialID;\n        hasHitSomething=true;\n    }\n    \n    if(IntersectPlane(Plane[4], ray, DEFAULT_TMIN, nearest_t,\n                      nearest_t, nearest_hitPos, nearest_hitNormal)==true){\n\t\tnearest_hitMatID = Plane[4].materialID;\n        hasHitSomething=true;\n    }\n\n    if(IntersectSphere(Sphere[0], ray, DEFAULT_TMIN, nearest_t,\n                       nearest_t, nearest_hitPos, nearest_hitNormal)==true){\n        nearest_hitMatID = Sphere[0].materialID;\n        hasHitSomething=true;\n    }\n\n    if(IntersectSphere(Sphere[1], ray, DEFAULT_TMIN, nearest_t,\n                       nearest_t, nearest_hitPos, nearest_hitNormal)==true){\n        nearest_hitMatID = Sphere[1].materialID;\n        hasHitSomething=true;\n    }\n    \n    if(IntersectSphere(Sphere[2], ray, DEFAULT_TMIN, nearest_t,\n                       nearest_t, nearest_hitPos, nearest_hitNormal)==true){\n        nearest_hitMatID = Sphere[2].materialID;\n        hasHitSomething=true;\n    }\n    \n    if(IntersectSphere(Sphere[3], ray, DEFAULT_TMIN, nearest_t,\n                       nearest_t, nearest_hitPos, nearest_hitNormal)==true){\n        nearest_hitMatID = Sphere[3].materialID;\n        hasHitSomething=true;\n    }\n    \n    if(IntersectSphere(Sphere[4], ray, DEFAULT_TMIN, nearest_t,\n                       nearest_t, nearest_hitPos, nearest_hitNormal)==true){\n        nearest_hitMatID = Sphere[4].materialID;\n        hasHitSomething=true;\n    }\n    \n    if(IntersectSphere(Sphere[5], ray, DEFAULT_TMIN, nearest_t,\n                       nearest_t, nearest_hitPos, nearest_hitNormal)==true){\n        nearest_hitMatID = Sphere[5].materialID;\n        hasHitSomething=true;\n    }\n    \n    if(IntersectSphere(Sphere[6], ray, DEFAULT_TMIN, nearest_t,\n                       nearest_t, nearest_hitPos, nearest_hitNormal)==true){\n        nearest_hitMatID = Sphere[6].materialID;\n        hasHitSomething=true;\n    }\n    \n    if(IntersectSphere(Sphere[7], ray, DEFAULT_TMIN, nearest_t,\n                       nearest_t, nearest_hitPos, nearest_hitNormal)==true){\n        nearest_hitMatID = Sphere[7].materialID;\n        hasHitSomething=true;\n    }\n    \n    if(IntersectSphere(Sphere[8], ray, DEFAULT_TMIN, nearest_t,\n                       nearest_t, nearest_hitPos, nearest_hitNormal)==true){\n        nearest_hitMatID = Sphere[8].materialID;\n        hasHitSomething=true;\n    }\n    \n    if(IntersectSphere(Sphere[9], ray, DEFAULT_TMIN, nearest_t,\n                       nearest_t, nearest_hitPos, nearest_hitNormal)==true){\n        nearest_hitMatID = Sphere[9].materialID;\n        hasHitSomething=true;\n    }\n    \n    if(IntersectSphere(Sphere[10], ray, DEFAULT_TMIN, nearest_t,\n                       nearest_t, nearest_hitPos, nearest_hitNormal)==true){\n        nearest_hitMatID = Sphere[10].materialID;\n        hasHitSomething=true;\n    }\n    \n    if(IntersectSphere(Sphere[11], ray, DEFAULT_TMIN, nearest_t,\n                       nearest_t, nearest_hitPos, nearest_hitNormal)==true){\n        nearest_hitMatID = Sphere[11].materialID;\n        hasHitSomething=true;\n    }\n    \n    if(IntersectSphere(Sphere[12], ray, DEFAULT_TMIN, nearest_t,\n                       nearest_t, nearest_hitPos, nearest_hitNormal)==true){\n        nearest_hitMatID = Sphere[12].materialID;\n        hasHitSomething=true;\n    }\n    \n    if(IntersectSphere(Sphere[14], ray, DEFAULT_TMIN, nearest_t,\n                       nearest_t, nearest_hitPos, nearest_hitNormal)==true){\n        nearest_hitMatID = Sphere[14].materialID;\n        hasHitSomething=true;\n    }\n    \n    if(IntersectSphere(Sphere[15], ray, DEFAULT_TMIN, nearest_t,\n                       nearest_t, nearest_hitPos, nearest_hitNormal)==true){\n        nearest_hitMatID = Sphere[15].materialID;\n        hasHitSomething=true;\n    }\n    \n    if(IntersectSphere(Sphere[16], ray, DEFAULT_TMIN, nearest_t,\n                       nearest_t, nearest_hitPos, nearest_hitNormal)==true){\n        nearest_hitMatID = Sphere[16].materialID;\n        hasHitSomething=true;\n    }\n    \n    if(IntersectSphere(Sphere[13], ray, DEFAULT_TMIN, nearest_t,\n                       nearest_t, nearest_hitPos, nearest_hitNormal)==true){\n        nearest_hitMatID = Sphere[13].materialID;\n        hasHitSomething=true;\n    }\n    \n    if(IntersectSphere(Sphere[17], ray, DEFAULT_TMIN, nearest_t,\n                       nearest_t, nearest_hitPos, nearest_hitNormal)==true){\n        nearest_hitMatID = Sphere[17].materialID;\n        hasHitSomething=true;\n    }\n    \n    if(IntersectSphere(Sphere[18], ray, DEFAULT_TMIN, nearest_t,\n                       nearest_t, nearest_hitPos, nearest_hitNormal)==true){\n        nearest_hitMatID = Sphere[18].materialID;\n        hasHitSomething=true;\n    }\n    \n    if(IntersectSphere(Sphere[19], ray, DEFAULT_TMIN, nearest_t,\n                       nearest_t, nearest_hitPos, nearest_hitNormal)==true){\n        nearest_hitMatID = Sphere[19].materialID;\n        hasHitSomething=true;\n    }\n\n\n\n    // One of the output results.\n    hasHit = hasHitSomething;\n    if ( !hasHitSomething ) return BACKGROUND_COLOR;\n\n    vec3 I_local = vec3( 0.0 );  // Result color will be accumulated here.\n\n    /////////////////////////////////\n    // TASK: WRITE YOUR CODE HERE. //\n    /////////////////////////////////\n    Ray_t lightray0;\n    lightray0.o = nearest_hitPos;\n    lightray0.d = normalize(Light[0].position - nearest_hitPos);\n    vec3 lengray0 = Light[0].position - nearest_hitPos;\n    float t0max=length(lengray0);\n\n    Ray_t lightray1;\n    lightray1.o = nearest_hitPos;\n    lightray1.d = normalize(Light[1].position - nearest_hitPos);\n    vec3 lengray1 = nearest_hitPos - Light[1].position;\n    float t1max=length(lengray1);\n\n    bool inShadow = false;\n\n    if(IntersectSphere(Sphere[0],lightray0,DEFAULT_TMIN,t0max)||\n       IntersectSphere(Sphere[1],lightray0,DEFAULT_TMIN,t0max)||\n       IntersectSphere(Sphere[2],lightray0,DEFAULT_TMIN,t0max)||\n       IntersectSphere(Sphere[3],lightray0,DEFAULT_TMIN,t0max)||\n       IntersectSphere(Sphere[4],lightray0,DEFAULT_TMIN,t0max)||\n       IntersectSphere(Sphere[5],lightray0,DEFAULT_TMIN,t0max)||\n       IntersectSphere(Sphere[6],lightray0,DEFAULT_TMIN,t0max)||\n       IntersectSphere(Sphere[7],lightray0,DEFAULT_TMIN,t0max)||\n       IntersectSphere(Sphere[8],lightray0,DEFAULT_TMIN,t0max)||\n       IntersectSphere(Sphere[9],lightray0,DEFAULT_TMIN,t0max)||\n       IntersectSphere(Sphere[10],lightray0,DEFAULT_TMIN,t0max)||\n       IntersectSphere(Sphere[11],lightray0,DEFAULT_TMIN,t0max)||\n       IntersectSphere(Sphere[12],lightray0,DEFAULT_TMIN,t0max)||\n       IntersectSphere(Sphere[13],lightray0,DEFAULT_TMIN,t0max)||\n       IntersectSphere(Sphere[14],lightray0,DEFAULT_TMIN,t0max)||\n       IntersectSphere(Sphere[15],lightray0,DEFAULT_TMIN,t0max)||\n       IntersectSphere(Sphere[16],lightray0,DEFAULT_TMIN,t0max)||\n       IntersectSphere(Sphere[17],lightray0,DEFAULT_TMIN,t0max)||\n       IntersectSphere(Sphere[18],lightray0,DEFAULT_TMIN,t0max)||\n       IntersectSphere(Sphere[19],lightray0,DEFAULT_TMIN,t0max)||\n       IntersectPlane(Plane[0],lightray0,DEFAULT_TMIN,t0max)||\n       IntersectPlane(Plane[1],lightray0,DEFAULT_TMIN,t0max)||\n       IntersectPlane(Plane[2],lightray0,DEFAULT_TMIN,t0max)||\n       IntersectPlane(Plane[3],lightray0,DEFAULT_TMIN,t0max)||\n       IntersectPlane(Plane[4],lightray0,DEFAULT_TMIN,t0max))\n          inShadow = true;\n     I_local += PhongLighting(lightray0.d,nearest_hitNormal,-ray.d,inShadow, Material[nearest_hitMatID],Light[0] );\n\n\n    inShadow = false;\n    if(IntersectSphere(Sphere[1],lightray1,DEFAULT_TMIN,t1max)||\n       IntersectSphere(Sphere[0],lightray1,DEFAULT_TMIN,t1max)||\n       IntersectSphere(Sphere[2],lightray1,DEFAULT_TMIN,t1max)||\n       IntersectSphere(Sphere[3],lightray1,DEFAULT_TMIN,t1max)||\n       IntersectSphere(Sphere[4],lightray1,DEFAULT_TMIN,t1max)||\n       IntersectSphere(Sphere[5],lightray1,DEFAULT_TMIN,t1max)||\n       IntersectSphere(Sphere[6],lightray1,DEFAULT_TMIN,t1max)||\n       IntersectSphere(Sphere[7],lightray1,DEFAULT_TMIN,t1max)||\n       IntersectSphere(Sphere[8],lightray1,DEFAULT_TMIN,t1max)||\n       IntersectSphere(Sphere[9],lightray1,DEFAULT_TMIN,t1max)||\n       IntersectSphere(Sphere[10],lightray1,DEFAULT_TMIN,t1max)||\n       IntersectSphere(Sphere[11],lightray1,DEFAULT_TMIN,t1max)||\n       IntersectSphere(Sphere[12],lightray1,DEFAULT_TMIN,t1max)||\n       IntersectSphere(Sphere[13],lightray1,DEFAULT_TMIN,t1max)||\n       IntersectSphere(Sphere[14],lightray1,DEFAULT_TMIN,t1max)||\n       IntersectSphere(Sphere[15],lightray1,DEFAULT_TMIN,t1max)||\n       IntersectSphere(Sphere[16],lightray1,DEFAULT_TMIN,t1max)||\n       IntersectSphere(Sphere[17],lightray1,DEFAULT_TMIN,t1max)||\n       IntersectSphere(Sphere[18],lightray1,DEFAULT_TMIN,t1max)||\n       IntersectSphere(Sphere[19],lightray1,DEFAULT_TMIN,t1max)||\n       IntersectPlane(Plane[0],lightray1,DEFAULT_TMIN,t1max)||\n       IntersectPlane(Plane[1],lightray1,DEFAULT_TMIN,t1max)||\n       IntersectPlane(Plane[2],lightray1,DEFAULT_TMIN,t1max)||\n       IntersectPlane(Plane[3],lightray1,DEFAULT_TMIN,t1max)||\n       IntersectPlane(Plane[4],lightray1,DEFAULT_TMIN,t1max))\n    inShadow = true;\n\n    I_local += PhongLighting(lightray1.d,nearest_hitNormal,-ray.d,inShadow, Material[nearest_hitMatID],Light[1]);\n\n    // Populate output results.\n    hitPos = nearest_hitPos;\n    hitNormal = nearest_hitNormal;\n    k_rg = Material[nearest_hitMatID].k_rg;\n\n    return I_local;\n\n\n    // Populate output results.\n    hitPos = nearest_hitPos;\n    hitNormal = nearest_hitNormal;\n    k_rg = Material[nearest_hitMatID].k_rg;\n\n    return I_local;\n}\n\nvec3 fancyCube( sampler2D sam, in vec3 d, in float s, in float b )\n{\n    vec3 colx = texture( sam, 0.5 + s*d.yz/d.x, b ).xyz;\n    vec3 coly = texture( sam, 0.5 + s*d.zx/d.y, b ).xyz;\n    vec3 colz = texture( sam, 0.5 + s*d.xy/d.z, b ).xyz;\n    \n    vec3 n = d*d;\n    \n    return (colx*n.x + coly*n.y + colz*n.z)/(n.x+n.y+n.z);\n}\n\nvec2 hash( vec2 p ) { p=vec2(dot(p,vec2(127.1,311.7)),dot(p,vec2(269.5,183.3))); return fract(sin(p)*43758.5453); }\n\nvec2 voronoi( in vec2 x )\n{\n    vec2 n = floor( x );\n    vec2 f = fract( x );\n\n\tvec3 m = vec3( 8.0 );\n    for( int j=-1; j<=1; j++ )\n    for( int i=-1; i<=1; i++ )\n    {\n        vec2  g = vec2( float(i), float(j) );\n        vec2  o = hash( n + g );\n        vec2  r = g - f + o;\n\t\tfloat d = dot( r, r );\n        if( d<m.x )\n            m = vec3( d, o );\n    }\n\n    return vec2( sqrt(m.x), m.y+m.z );\n}\n\n//=======================================================\n\nvec3 background( in vec3 d, in vec3 l )\n{\n    vec3 col = vec3(0.0);\n         col += 0.5*pow( fancyCube( iChannel1, d, 0.05, 5.0 ).zyx, vec3(2.0) );\n         col += 0.2*pow( fancyCube( iChannel1, d, 0.10, 3.0 ).zyx, vec3(1.5) );\n         col += 0.8*vec3(0.80,0.5,0.6)*pow( fancyCube( iChannel1, d, 0.1, 0.0 ).xxx, vec3(6.0) );\n    float stars = smoothstep( 0.3, 0.7, fancyCube( iChannel1, d, 0.91, 0.0 ).x );\n\n    \n    vec3 n = abs(d);\n    n = n*n*n;\n    \n    vec2 vxy = voronoi( 50.0*d.xy );\n    vec2 vyz = voronoi( 50.0*d.yz );\n    vec2 vzx = voronoi( 50.0*d.zx );\n    vec2 r = (vyz*n.x + vzx*n.y + vxy*n.z) / (n.x+n.y+n.z);\n    col += 0.9 * stars * clamp(1.0-(3.0+r.y*5.0)*r.x,0.0,1.0);\n\n    col = 1.5*col - 0.2;\n    col += vec3(-0.05,0.1,0.0);\n\n    float s = clamp( dot(d,l), 0.0, 1.0 );\n    col += 0.4*pow(s,5.0)*vec3(1.0,0.7,0.6)*2.0;\n    col += 0.4*pow(s,64.0)*vec3(1.0,0.9,0.8)*2.0;\n    \n    return col;\n}\n\n//--------------------------------------------------------------------\n\nmat3 setCamera( in vec3 ro, in vec3 rt, in float cr )\n{\n\tvec3 cw = normalize(rt-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, -cw );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n     InitScene();\n\n    // Scale pixel 2D position such that its y coordinate is in [-1.0, 1.0].\n    vec2 pixel_pos = (2.0 * fragCoord.xy - iResolution.xy) / iResolution.y;\n\n    // Position the camera.\n    //vec3 cam_pos = vec3( 1.5+1.5*abs(sin(iTime/5.0)), 5.0, 1.5+abs(1.5*cos(iTime/5.0)) );\n    vec3 cam_pos = vec3( 4.5*sin(-1.0*iTime), 2.0, 4.5*cos(-1.0*iTime) );\n    vec3 cam_lookat = vec3( 0.0, 1.0, 0.0 );\n    vec3 cam_up_vec = vec3( 0.0, 1.0, 0.0 );\n\n    // Set up camera coordinate frame in world space.\n    vec3 cam_z_axis = normalize( cam_pos - cam_lookat );\n    vec3 cam_x_axis = normalize( cross(cam_up_vec, cam_z_axis) );\n    vec3 cam_y_axis = normalize( cross(cam_z_axis, cam_x_axis));\n\n    // Create primary ray.\n    float pixel_pos_z = -1.0 / tan(FOVY / 2.0);\n    Ray_t pRay;\n    pRay.o = cam_pos;\n    pRay.d = normalize( pixel_pos.x * cam_x_axis  +  pixel_pos.y * cam_y_axis  +  pixel_pos_z * cam_z_axis );\n\t\n    vec3 col = texture(iChannel0, fragCoord).rgb;// 获取纹理在uv出的像素颜色\n    Material[0].k_d = col;\n\n    // Start Ray Tracing.\n    // Use iterations to emulate the recursion.\n\n    vec3 I_result = vec3( 0.0 );\n    vec3 compounded_k_rg = vec3( 1.0 );\n    Ray_t nextRay = pRay;\n    \n    vec2 p = (-iResolution.xy +2.0*fragCoord.xy) / iResolution.y;\n\n    float zo = 1.0 + smoothstep( 5.0, 15.0, abs(iTime-48.0) );\n    float an = 3.0 + 0.05*iTime + 6.0*iMouse.x/iResolution.x;\n    vec3 ro = zo*vec3( 2.0*cos(an), 1.0, 2.0*sin(an) );\n    vec3 rt = vec3( 1.0, 0.0, 0.0 );\n    mat3 cam = setCamera( ro, rt, 0.35 );\n    vec3 rd = normalize( cam * vec3( p, -2.0) );\n    vec3 lig = normalize( vec3(1.0,0.2,1.0) );\n    vec3 col0 = background( rd, lig );\n    Material[7].k_d = col0;\n    Material[6].k_d = col0;\n    Material[5].k_d = col0;\n    Material[4].k_d = col0;\n\n    for ( int level = 0; level <= NUM_ITERATIONS; level++ )\n    {\n        bool hasHit;\n        vec3 hitPos, hitNormal, k_rg;\n\n        vec3 I_local = CastRay( nextRay, hasHit, hitPos, hitNormal, k_rg );\n\n        I_result += compounded_k_rg * I_local;\n\n        if ( !hasHit ) break;\n\n        compounded_k_rg *= k_rg;\n\n        nextRay = Ray_t( hitPos, normalize( reflect(nextRay.d, hitNormal) ) );\n    }\n\n    fragColor = vec4( I_result, 0.5 );\n}\n", "image_inputs": [{"id": "XsX3Rn", "previewfilepath": "/media/ap/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg", "ctype": "texture"}, {"id": "XsX3Rn", "previewfilepath": "/media/ap/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MtdyW7.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[2693, 2875, 2893, 2918, 11774], [11777, 12273, 12427, 12427, 12757], [12761, 13093, 13176, 13176, 13388], [13392, 13910, 14067, 14181, 14921], [14925, 15258, 15343, 15457, 16072], [16075, 16429, 16559, 16559, 16971], [16974, 17763, 17876, 17967, 28919], [28921, 28921, 28989, 28989, 29249], [29251, 29251, 29272, 29272, 29366], [29368, 29368, 29395, 29395, 29768], [29770, 29829, 29870, 29870, 30741], [30743, 30815, 30870, 30870, 31048], [31050, 31050, 31107, 31107, 33346]], "test": "untested"}
{"id": "MttcRr", "name": "Ray marching practice 6", "author": "lnae", "description": "trying some shapes and shadows", "tags": ["raymarching", "shadows"], "likes": 5, "viewed": 151, "published": "Public", "date": "1531377980", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define STEPS 64.\n#define EPS 0.0001\n#define EPSN 0.001\n#define PI 3.14159\n\nmat2 rot(float a){\n\treturn mat2(cos(a), -sin(a), sin(a), cos(a));\n}\n\nfloat distSphere(vec3 p, float r){\n\treturn length(p) - r;\n}\n\nvec2 repeat(vec2 p, float t){\n\tt = 2. * PI / t;\n    float angle = mod(atan(p.y, p.x), t) - 0.5 * t;\n    return length(p.xy) * vec2(cos(angle), sin(angle));\n}\n\n\nfloat distScene(vec3 pos){\n\t\n    pos.yz = rot(0.45) * pos.yz;\n    pos.y += 0.1;\n    \n    //floor\n    vec3 p = pos - vec3(0., -1.5, 0.);\n    float r = length(p.xz);\n    float dist = distSphere(p, 1.5) + 0.003 * (sin(150. * r - iTime));\n    \n    \n    //floating things\n    float time = 2. * iTime;\n    float tr = 0.15 * (0.5 + 0.5 * sin(time + 2. * PI / 3.));\n    p = pos - vec3(-0.25, tr + 0.1, 0.);\n    p.xz = rot(iTime) * p.xz;\n    p.xz = repeat(p.xz, 12.);\n    \n    float dist1 = p.y - 0.095;\n    dist1 = max(dist1, length(p.xy) - 0.1);\n    dist = min(dist, dist1);\n    \n    tr = 0.1 * (0.5 + 0.5 * sin(time));\n    p = pos - vec3(0., tr + 0.1, 0.);\n    p.xz = rot(iTime) * p.xz;\n    p.xz = repeat(p.xz, 12.);\n    p.xy = repeat(p.xy, 14.);\n    dist1 = length(p.yz) - 0.01;\n    dist1 = max(dist1, distSphere(p, 0.1));\n    dist = min(dist, dist1);\n    \n    tr = 0.1 * (0.5 + 0.5 * sin(time - 2. * PI / 3.));\n    p = pos - vec3(0.25, tr + 0.1, 0.);\n    p.xz = rot(iTime) * p.xz;\n    p.xy = repeat(p.xy, 12.);\n    dist1 = length(p.yz) - 0.02 + 0.05 * abs((fract(8. * p.x) - 0.5));\n    dist1 = max(dist1, distSphere(p, 0.1));\n    dist = min(dist, dist1);\n    \n\treturn dist;\n}\n\nvec3 getNormal(vec3 p){\n\treturn(normalize(vec3(distScene(p + vec3(EPSN, 0., 0.)) - distScene(p - vec3(EPSN, 0., 0.)),\n    \t\t\t\t\t  distScene(p + vec3(0., EPSN, 0.)) - distScene(p - vec3(0., EPSN, 0.)),\n    \t\t\t\t\t  distScene(p + vec3(0., 0., EPSN)) - distScene(p - vec3(0., 0., EPSN)))));\n}\n\nvec3 render(vec2 uv){\n\t//background\n    vec3 col = vec3(0., 0.13, 0.2);\n    \n    vec3 eye = vec3(0., 0., 5.);\n    vec3 ray = normalize(vec3(uv, 1.) - eye);\n    \n    //raymarch\n    float step, dist;\n    vec3 pos = eye;\n    bool hit = false;\n    \n    for(step = 0.; step < STEPS; step++){\n    \tdist = distScene(pos);\n        if(abs(dist) < EPS){\n        \thit = true;\n            break;\n        }\n        pos += dist * ray;\n    }\n    \n    vec3 normal = getNormal(pos);\n    \n    //shade\n    vec3 light = vec3(10., 10., 10.);\n    vec3 l = normalize(light - pos);\n    \n    if(hit){\n        col = vec3(step / STEPS, 0.3, 0.6) + 0.25 * (0.5 + 0.5 * normal);\n    \tcol *= 0.2 + 0.8 * dot(normal, l); //diffuse\n        \n        //shadow\n        vec3 p = pos + 2. * EPS * normal;\n        float shadow = 1.;\n        float totalDist = length(p - pos);\n        for(step = 0.; step < 40.; step++){\n    \t\tdist = distScene(p);\n            totalDist += dist;\n            shadow = min(shadow, 10. * dist / totalDist);\n        \tif(abs(dist) < EPS){\n                shadow = 0.;\n            \tbreak;\n        \t}\n        \tp += dist * l;\n    \t}\n        col = mix(vec3(0.1, 0.1, 0.2), col, shadow);\n    }\n    return col;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.x;\n    vec3 col = vec3(0);\n    \n    float aa = 1.;\n    for (float i = 0.; i < aa; i++){\n    \tfor (float j = 0.; j < aa; j++){\n    \t\tcol += render(uv + vec2(i, j) / (aa * iResolution.xy));\n    \t}\n    }\n    fragColor = vec4(col / (aa * aa),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MttcRr.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[76, 76, 94, 94, 143], [145, 145, 179, 179, 204], [206, 206, 235, 235, 363], [366, 366, 392, 392, 1537], [1539, 1539, 1562, 1562, 1825], [1827, 1827, 1848, 1862, 3022], [3025, 3025, 3082, 3082, 3391]], "test": "untested"}
{"id": "MttcWN", "name": "xor madness", "author": "Azorlogh", "description": "inspired by https://www.shadertoy.com/view/XlcyD8\nhash function used : https://www.shadertoy.com/view/XdGfRR", "tags": ["xor"], "likes": 13, "viewed": 234, "published": "Public", "date": "1532981672", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define UI0 1597334673U\n#define UI1 3812015801U\n#define UI2 uvec2(UI0, UI1)\n#define UI3 uvec3(UI0, UI1, 2798796415U)\n#define UIF (1. / float(0xffffffffU))\nfloat hash11(uint q)\n{\n\tuvec2 n = q * UI2;\n\tq = (n.x ^ n.y) * UI0;\n\treturn float(q) * UIF;\n}\n\n\nvoid mainImage( out vec4 O, vec2 U )\n{  \n    U -= iResolution.xy/2.;\n    O -= O;\n    \n    for (float i=1.; i<9.; i++) {\n        uvec2 p = uvec2( U * (i*.04+.96) + iTime * 80. + iMouse.xy * 10.); \n        uint temp = ( p.x + uint(10000.*i) ) \n        \t          ^  // try ^ & |\n        \t          p.y;\n  \n        O += step(.98, hash11(temp)) * vec4(1,.66,1,1) / i;\n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MttcWN.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[155, 155, 177, 177, 247], [250, 250, 288, 288, 621]], "test": "untested"}
{"id": "MttcWr", "name": "Infinite City with Shadows", "author": "uqone", "description": "Just testing it with shadows and AO.\n\nOriginal by TekF *ALL* credits go to him. https://www.shadertoy.com/view/4df3DS\n", "tags": ["city"], "likes": 17, "viewed": 553, "published": "Public API", "date": "1532298917", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Ininite City\n// Hazel Quantock - 2013\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n//\n// Original by TekF *ALL* credits go to him. https://www.shadertoy.com/view/4df3DS\n//\n\n// slightly shaky street-level view!\n//#define FIRST_PERSON\n\n\nvec2 Rand( vec2 pos )\n{\n\treturn textureLod( iChannel0, (pos+.5)/256.0, 0.0 ).xz;\n}\n\nvec3 VoronoiPoint(vec2 pos, vec2 delta )\n{\n\tconst float randScale = .8; // reduce this to remove axis-aligned hard edged errors\n\t\n\tvec2 p = floor(pos)+delta;\n\tvec2 r = (Rand(p)-.5)*randScale;\n\tvec2 c = p+.5+r;\n\t\n\t// various length calculations for different patterns\n\t//float l = length(c-pos);\n\t//float l = length(vec3(c-pos,.1));\n\tfloat l = abs(c.x-pos.x)+abs(c.y-pos.y); // more interesting shapes\n\t\n\treturn vec3(c,l);\n}\n\n// For building height I want to know which voronoi point I used\n// For side-walls I want difference between distance of closest 2 points\nvec3 Voronoi( vec2 pos )\n{\n\t// find closest & second closest points\n\tvec3 delta = vec3(-1,0,1);\n\n\t// sample surrounding points on the distorted grid\n\t// could get 2 samples for the price of one using a rotated (17,37) grid...\n\tvec3 point[9];\n\tpoint[0] = VoronoiPoint( pos, delta.xx );\n\tpoint[1] = VoronoiPoint( pos, delta.yx );\n\tpoint[2] = VoronoiPoint( pos, delta.zx );\n\tpoint[3] = VoronoiPoint( pos, delta.xy );\n\tpoint[4] = VoronoiPoint( pos, delta.yy );\n\tpoint[5] = VoronoiPoint( pos, delta.zy );\n\tpoint[6] = VoronoiPoint( pos, delta.xz );\n\tpoint[7] = VoronoiPoint( pos, delta.yz );\n\tpoint[8] = VoronoiPoint( pos, delta.zz );\n\n\tvec3 closest;\n\tclosest.z =\n\t\tmin(\n\t\t\tmin(\n\t\t\t\tmin(\n\t\t\t\t\tmin( point[0].z, point[1].z ),\n\t\t\t\t\tmin( point[2].z, point[3].z )\n\t\t\t\t), min(\n\t\t\t\t\tmin( point[4].z, point[5].z ),\n\t\t\t\t\tmin( point[6].z, point[7].z )\n\t\t\t\t)\n\t\t\t), point[8].z\n\t\t);\n\t\n\t// find second closest\n\t// maybe there's a better way to do this\n\tclosest.xy = point[8].xy;\n\tfor ( int i=0; i < 8; i++ )\n\t{\n\t\tif ( closest.z == point[i].z )\n\t\t{\n\t\t\tclosest = point[i];\n\t\t\tpoint[i] = point[8];\n\t\t}\n\t}\n\t\t\n\tfloat t;\n\tt = min(\n\t\t\tmin(\n\t\t\t\tmin( point[0].z, point[1].z ),\n\t\t\t\tmin( point[2].z, point[3].z )\n\t\t\t), min(\n\t\t\t\tmin( point[4].z, point[5].z ),\n\t\t\t\tmin( point[6].z, point[7].z )\n\t\t\t)\n\t\t);\n\n\t/*slower:\n\tfloat t2 = 9.0;\n\tvec3 closest = point[8];\n\tfor ( int i=0; i < 8; i++ )\n\t{\n\t\tif ( point[i].z < closest.z )\n\t\t{\n\t\t\tt2 = closest.z;\n\t\t\tclosest = point[i];\n\t\t}\n\t\telse if ( point[i].z < t2 )\n\t\t{\n\t\t\tt2 = point[i].z;\n\t\t}\n\t}*/\n\t\n\treturn vec3( closest.xy, t-closest.z );\n}\n\n\nfloat DistanceField( vec3 pos, float dist )\n{\n\tvec3 v = Voronoi(pos.xz);\n\tvec2 r = Rand(v.xy*4.0); // per-building seed\n\t\n\tfloat f = (.2+.3*r.y-v.z)*.5; //.7071; // correct for max gradient of voronoi x+z distance calc\n\t\n\t// random height\n\tfloat h = r.x; // v.xy is position of cell centre, use it as random seed\n\th = mix(.2,2.0,pow(h,2.0));\n\th = pos.y-h;\n\n\t// we get precision problems caused by the discontinuity in height\n\t// so clamp it near to the surface and then apply a plane at max height\t\n\th = max( min( h, .008*dist ), pos.y-2.0 );\n\n//\tf = max( f, h );\n\tif ( f > 0.0 && h > 0.0 )\n\t\tf = sqrt(f*f+h*h); // better distance computation, to reduce errors\n\telse\n\t\tf = max(f,h);\n\t\n\tf = min( f, pos.y ); // ground plane\n\t\n\treturn f;\n}\n\nfloat DistanceField( vec3 pos )\n{\n\treturn DistanceField( pos, 10.0 );\n}\n\n// normal\n// could do this analytically, by looking at the maths when comupting voronoi value\n// but the lions share of the cost is in the trace, not this, so I shalln't worry\nvec3 GetNormal( vec3 pos )\n{\n\tvec3 n;\n\tvec2 delta = vec2(0,1);\n\n\t// allow a slight curve so it looks more interesting\n\t#ifdef FIRST_PERSON\n\t\tdelta *= .004;\n\t#else\n\t\tdelta *= .04;\n\t#endif\n\t\n\tn.x = DistanceField( pos+delta.yxx ) - DistanceField( pos-delta.yxx );\n\tn.y = DistanceField( pos+delta.xyx ) - DistanceField( pos-delta.xyx );\n\tn.z = DistanceField( pos+delta.xxy ) - DistanceField( pos-delta.xxy );\n\n\t// we get some black on surfaces because of flat spots in the voronoi\n\t// fix that by giving it an arbitrary (and incorrect) normal\n\tif ( dot(n,n) == 0.0 )\n\t\tn.y += 1.0;\n\n\treturn normalize(n);\n}\n\nfloat calcOcclusion( in vec3 pos, in vec3 nor, float t )\n{\n\tfloat occ = 0.0;\n    for( int i=0; i<8; i++ )\n    {\n        float h = 0.005 + 0.25*float(i)/7.0;\n        vec3 dir = normalize( sin( float(i)*73.4 + vec3(0.0,2.1,4.2) ));\n        dir = normalize( nor + dir );\n        occ += (h-DistanceField( pos + h*dir, t ));\n    }\n    return clamp( 1.0 - 9.0*occ/8.0, 0.0, 1.0 );    \n}\n\nfloat calcShadow( in vec3 ro, in vec3 rd, float k )\n{\n    float res = 1.0;\n\n    float t = 0.1;\n    for( int i=0; i<32; i++ )\n    {\n        vec3 pos = ro + rd*t;\n        float h = DistanceField(pos, length(pos));\n        res = min( res, smoothstep(0.0,1.0,8.0*h/t) );\n        t += clamp( h, 0.05, 10.0 );\n\t\tif( res<0.01 ) break;\n    }\n    return clamp(res,0.0,1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n/*\tfloat f = Voronoi(fragCoord.xy/40.0).z;\n\tfragColor = vec4( vec3(f), 1.0 );*/\n\t\n\tvec2 mouse = iMouse.xy/iResolution.xy;\n\n\tfloat h;\n\t#ifdef FIRST_PERSON\n\t\tvec2 rot = vec2(-.2,.0)+vec2(6.28,-1.5)*mouse;\n\t\t\n\t//\tvec3 rayStart = vec3(.1,.03,.1);//vec3(0,10,0) + vec3(1,0,1)*iTime + vec3(0,-8,0)*mouse.y;\n\t//\trayStart += -10.0*vec3(sin(rot.x),0,cos(rot.x));\n\t\n\t\tvec3 rayStart = vec3(0,.03,0) + iTime*vec3(-.02,0,.02);\n\t\t// find closest road to the right\n\t\th = 1.0;\n\t\tfor ( int i=0; i < 20; i++ )\n\t\t{\n\t\t\tif ( h < .01 )\n\t\t\t\tbreak;\n\t\t\th = Voronoi( rayStart.xz ).z*.3;\n\t\t\trayStart.xz += h;\n\t\t}\n\t\n\t\tfloat zoom = .7;\n\t#else\n\t\tvec2 rot = vec2(-.2,.28)+vec2(1.6,.5)*mouse;\n\t\t\n\t\tvec3 rayStart = vec3(0,5,0) + vec3(1,0,1)*iTime + vec3(0,6,0)*mouse.y;\n\t\trayStart += -10.0*vec3(sin(rot.x),0,cos(rot.x));\n\n\t\tfloat zoom = 1.0;\n\t#endif\n\t\n\tvec3 rayDir = normalize( vec3( fragCoord.xy-iResolution.xy*.5, iResolution.x * zoom ) );\n\trayDir.yz = rayDir.yz*cos(rot.y)+rayDir.zy*sin(rot.y)*vec2(-1,1);\n\trayDir.xz = rayDir.xz*cos(rot.x)+rayDir.zx*sin(rot.x)*vec2(1,-1);\n\n\t// trace\n\tfloat t = 0.0;\n\th = 1.0;\n\tfor ( int i=0; i < 150; i++ )\n\t{\n\t\tif ( h < .001 )\n\t\t\tbreak;\n\t\t\n\t\th = DistanceField(rayStart+rayDir*t, t);\n\t\tt += h;\n\t}\n\t\n\t// shade\n\tvec3 pos = rayStart+rayDir*t;\n\tvec3 norm = GetNormal(pos);\n\tvec3 v = Voronoi(pos.xz);\n    \n\tvec2 r = Rand( v.xy ).xy;\n\tvec4 albedo = mix( mix( vec4(.4,.2,.0,0), vec4(1,1,1,0), r.x ),\n\t\t\t\t\t   mix( vec4(0,.2,.6,1), vec4(0,0,0,1), r.x ),\n\t\t\t\t\t   r.y );\n\t\n\t// floors\n\tif ( fract(pos.y*8.0) < .4 )\n\t\talbedo = mix( vec4(0,0,0,0), vec4(1,1,1,0), r.x );\n\n\t// remove reflection on rooves!\n\talbedo.w = mix ( albedo.w, 0.0, step( .2, norm.y ) );\n\t\n\t// roads\n\talbedo = mix( vec4(.05,.05,.05,0), albedo, step( .07, abs(v.z-.08) ) );\n\t\n\tvec3 lighting = max(0.0,dot(norm,normalize(vec3(-2,3,-1))))*vec3(1,.9,.8);\n\tlighting += vec3(.2); //ambient\n\t\n\tvec3 result = albedo.xyz * lighting;\n\t\n\t// reflections\n\tfloat fresnel = pow(1.0+dot(norm,rayDir),5.0);\n\tif ( fresnel > 1.0 ) fresnel = 0.0;\n\tfresnel = mix( .2, 1.0, fresnel );\n\t\n\tvec3 reflection = texture( iChannel1, reflect(rayDir,norm).xz/8.0 ).rgb*3.0;\n\t\n\tresult = mix( result, reflection, fresnel*albedo.w );\n\n\tif ( h > .01 )//&& rayDir.y > 0.0 )\n\t{\n\t\t// sky\n\t\tresult = mix( vec3(.3), vec3(.85,1.0,1.2), smoothstep( -.1,.1,rayDir.y ) );\n\t}\n\t\n\t// fake ambient occlusion\n\t//result *= mix( .2, 1.0, smoothstep( 0.0, .7, pos.y ) );\n    result *= mix( .2, 1.0, smoothstep( 0.0, .7, calcOcclusion( pos, norm, t ) ) );\n    \n    result *= mix( .2, 1.0, smoothstep( 0.0, .7, calcShadow( pos, normalize(vec3(-2,3,-1)), 32.0 ) ) );\n\t\n\t// fog\n\t//result = mix( vec3(.85,1.0,1.2), result, exp(-t*.02) );\n\t//More realistic fog\n\tresult *= pow( vec3(.7,.57,.3), vec3(t*.02) ); // absorb more blue on distant things\n\tresult += vec3(.7,.9,1.2)*(1.0-exp(-t*.02));\n\t\n\tfragColor = vec4(result,1);\n}\n", "image_inputs": [{"id": "4sfGRn", "previewfilepath": "/media/ap/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg", "ctype": "texture"}, {"id": "Xsf3zn", "previewfilepath": "/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MttcWr.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[219, 281, 304, 304, 363], [365, 365, 407, 407, 788], [790, 928, 954, 995, 2476], [2479, 2479, 2524, 2524, 3216], [3218, 3218, 3251, 3251, 3289], [3291, 3467, 3495, 3495, 4068], [4070, 4070, 4128, 4128, 4450], [4452, 4452, 4505, 4505, 4818], [4820, 4820, 4877, 4957, 7706]], "test": "untested"}
{"id": "MttczH", "name": "Polyhedral Weave", "author": "Shane", "description": "Utilizing the layout from DjinnKahn's \"Icosohedon Weave\" example to render something similar, but in a different style. I hope I did his original some justice.", "tags": ["polyhedra", "weave"], "likes": 41, "viewed": 1340, "published": "Public API", "date": "1531667913", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/*\n\n\tPolyhedral Weave\n\t----------------\n\t\n    Every now and again, someone will release a really cool -- not to mention, helpful -- \n\texample with little fanfare. One such case is DjinnKahn's \"Icosahedron Weave\" shader.\t\n\t\n\tProducing icosahedral geometry using a brute force vertice and triangle list is\n\tpretty straight forward. Folding space isn't really my thing, but that's not too\n\ttaxing either. However, I remember trying to weave something using a folding space\n\tmethod a while back and getting nowhere, and that was because when folding space\n\twith the standard algorithm you lose polarity. This became obvious to me... once \n\tsomeone with more brain power put up a polyhedral weave example. :D\n\n\tI hope I did some justice to the original. Code-wise, I didn't feel it necessary to \n\tmake many structural changes to the setup. Comparing the two examples, you can see \n\tthat DjinnKahn took a nice methodical approach, whereas I made everything up as I \n\twent along -- just for something different. :) Having said that, I did try to make up \n\tfor it by explaining a thing or two, so hopefully that'll help.\n\n\tI also wanted to produce a different capsule line look, which necessitated an\n\torthonormal approach. It's probably more expensive, but my fast machine didn't seem \n\tto notice. Having said that, I'll get in and try to speed things up later.\n\n\tUltimately, I'd like to post some more sophisticated examples, but figured I'd\n\tbetter get a polyhedral weave on the board first.\n\n\tBy the way, the \"opIcosahedronWithPolarity\" gives you triangle face information that\n\tis further subdivided into three sections, each with its own X-axis... 60 times \n\ticosahedral symmetry. Don't quote me on it, but I think the resultant object you're\n    working with is a trapezoidal (or deltoidal) hexecontahedron. If you look the object \n\tup on the net, it should make it more clear. Alternatively, you could uncomment the \n\t\"SHOW_EDGES\" and \"SHOW_FACE_SYMMETRY\" directive.\n\n\t\n\t// Based on:\n\t\n    // Not the easiest of geometry to wrap one's head around at the best of times, and \n\t// from what I understand, DjinnKahn (Tom Sirgedas) was learning about shaders and \n\t// SDF at the same time. Quite amazing.\n    Icosahedron Weave - DjinnKahn\n\thttps://www.shadertoy.com/view/Xty3Dy\n\n\tOther examples:\n\n\t// Knighty is more comfortable folding space than most. I fold space about \n    // as well as I fold laundry. :)\n\tPolyhedron again - knighty\n\thttps://www.shadertoy.com/view/XlX3zB\n\n    // Tdhooper has some awesome icosahedral examples.\n    Icosahedron twist - tdhooper\n\thttps://www.shadertoy.com/view/Mtc3RX\n\n\t// Really nice example with a different kind of weave using an alternate method to\n\t// obtain the icosahedral triangle information.\n\tmedusas hairdo with uv - flockaroo \n\thttps://www.shadertoy.com/view/ltBcDw\n\n*/\n\n#define FAR 20.\n\n// Visual guides to show the 3D weave pattern on the individual triangular faces and\n// the three repeat subregions.\n//\n// Dislays the 20 face icosahedral edges -- Not all the edges.\n//#define SHOW_EDGES\n// Combined with the above, this will show all edges. By itself, it'll produce the edges\n// (Although, not straight) of the icosahedral dual, namely, a dodecahedron.\n//#define SHOW_FACE_SYMMETRY \n// 20 face icosahedral vertices.\n//#define SHOW_VERTICES\n\n// This line emulates no polarity across the triangle face X axis... X axes, but let's\n// not confuse ourselves. :) The pattern is still interesting, but there's no weave.\n//#define NO_POLARITY\n\n\n// 2D rotation formula.\nmat2 rot2(float a){ float c = cos(a), s = sin(a); return mat2(c, s, -s, c); }\n\n// I paid hommage to the original and kept the same rotation... OK, I'm lazy. :D\nvec3 rotObj(vec3 p){\n    \n    p.yz *= rot2(iTime*.2);\n    p.zx *= rot2(iTime*.5);\n    return p;    \n}\n\n\n// There's a neat way to construct an icosohedron using three mutually perpendicular rectangular \n// planes. If you reference something along the lines of icosahedron golden rectangle, you'll \n// get a pretty good idea. There's a standard image here:\n// https://math.stackexchange.com/questions/2538184/proof-of-golden-rectangle-inside-an-icosahedron\n//\n// Anyway, even a cursory glance will give you a fair idea where the figures below originate. In \n// a vertex\\indice list environment, you could produce an icosahedron without too much trouble at \n// all. However, in a realtime raymarching situation, you need to get to the triangle face \n// information in as few operations as possible. That's achieved via a bit of space folding using \n// the same information in a different way.\n//\n// If weaving wasn't necessary, you could use the concise \"opIcosahedron\" function and be done\n// with it. Unfortunately, the \"abs\" calls throw out the triangular polarity information, which\n// you need to distinguish one side of the triangle from the other -- I wasted a lot of time not\n// realizing this until Djinn Kahn posted his example. He rewrote the folding function with an\n// additional variable to track polarity (signs) during each iteration.\n//\n// With this function, you can obtain the triangle face information and use it to render in the\n// three regions of symmetry -- each with a left and right X axis. From there, you can do whatever \n// you wish. \n\n// Vertices: vec3(0, A, B), vec3(B, 0, A), vec3(-B, 0, A).\n// Face center: (vec3(0, A, B) + vec3(0, 0, A)*2.)/3..\n// Edges: (vec3(0, A, B) + vec3(B, 0, A))/2.,  etc.\n\n\n// The following have come from DjinnKahn's \"Icosahedron Weave\" example, here:\n// https://www.shadertoy.com/view/Xty3Dy\n//\n// It works fine, just the way it is, so I only made trivial changes. I'd like to cut down the\n// number of operations in the \"opIcosahedronWithPolarity\" function, but so far, I can't see\n// a way to do that.\n\nconst float PHI = (1. + sqrt(5.))/2.;\nconst float A = PHI/sqrt(1. + PHI*PHI);\nconst float B = 1./sqrt( 1. + PHI*PHI);\nconst float J = (PHI - 1.)/2.; // .309016994375;\nconst float K = PHI/2.;        //J + .5;\nconst mat3 R0 = mat3(.5,  -K,   J   ,K ,  J, -.5   ,J , .5,  K);\nconst mat3 R1 = mat3( K,   J, -.5   ,J , .5,   K   ,.5 ,-K,  J);\nconst mat3 R2 = mat3(-J, -.5,   K  ,.5 , -K,  -J   ,K ,  J, .5);\n\n// I wanted all vertices hardcoded. The size factor effectively increases the size\n// of the weave object.\n#define size 1.25\nconst vec3 v0 = vec3(0, A, B)*size;\nconst vec3 v1 = vec3(B, 0, A)*size;\nconst vec3 v2 = vec3(-B, 0, A)*size;\n// Unlike DjinnKahn's example, I wanted to raise the center of the icosahedral triangle\n// face a bit... The \"1.06\" figure is a hack. If you want the point coplanar with the triangle, \n// take out the \"1.06\" figure. \"1.1547\" will roughly produce straight dodecahedron edges.\nconst vec3 cent = ((v0 + v1 + v2)/3.)*1.06;\n\n\n// Same as opIcosahedron, except without mirroring symmetry, so X-coordinate may be negative.\n// (note: when this is used as a distance function, it's possible that the nearest object is\n// on the opposite polarity, potentially causing a glitch).\nvec3 opIcosahedronWithPolarity(in vec3 p){\n   \n\tvec3 pol = sign(p);\n    p = R0*abs(p);\n\tpol *= sign(p);\n    p = R1*abs(p);\n\tpol *= sign(p);\n    p = R2*abs(p);\n\tpol *= sign(p);\n    vec3 ret = abs(p);\n    return ret * vec3(pol.x*pol.y*pol.z, 1, 1);\n}   \n\n/*\n// The original function -- sans polarity information -- is neat and concise.\nvec3 opIcosahedron(vec3 p){ \n  \n    p = R0*abs(p);\n    p = R1*abs(p);\n    p = R2*abs(p);\n    return abs(p);  \n} \n*/\n\n\n// A cheap orthonormal basis vector function - Taken from Nimitz's \"Cheap Orthonormal Basis\" example, then \n// modified slightly.\n//\n//Cheap orthonormal basis by nimitz\n//http://orbit.dtu.dk/fedora/objects/orbit:113874/datastreams/file_75b66578-222e-4c7d-abdf-f7e255100209/content\n//via: http://psgraphics.blogspot.pt/2014/11/making-orthonormal-basis-from-unit.html\nmat3 basis(in vec3 n){\n    \n    float a = 1./(1. + n.z);\n    float b = -n.x*n.y*a;\n    return mat3(1. - n.x*n.x*a, b, n.x, b, 1. - n.y*n.y*a, n.y, -n.x, -n.y, n.z);\n                \n}\n \n// A line segment formula that orients via an orthanormal basis. It'd be faster to use\n// IQ's 3D line segment formula, but this one allows for more interesting cross sections,\n// like hexagons and so forth.\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r, float lf){ // Length factor on the end.\n\n\n    b -= a;\n    float l = length(b);\n    \n    p = basis(normalize(b))*(p - a - b*.5);\n    \n    p = abs(p);\n    //p.x = abs(p.x - .035);\n    //return = max(length(p.xy) - r, p.z - l*lf);\n    //return max((p.x + p.y)*.7071 - r, p.z - l*lf);\n    //return max(max(p.x, p.y) - r, p.z - l*lf);\n    //return max(max(max(p.x, p.y), (p.y + p.x)*.7071) - r, p.z - l*lf);\n    return max(max(p.y*.866025 + p.x*.5, p.x) - r, p.z - l*lf);\n}\n\n\n/*\n// IQ's 3D line segment formula. Simpler and cheaper, but doesn't orient carved cross-sections.\nfloat sdCapsule(vec3 p, vec3 a, vec3 b){\n\n    vec3 pa = p - a, ba = b - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    pa = abs(pa - ba*h);\n    return length( pa );\n}\n*/\n    \nvec4 objID;\n\n\nfloat dist(vec3 p, float r){\n    \n    return length(p) - r;\n    //p = abs(p);\n    //return max(length(p.yz) - r, p.x - r);\n    //return max(max(p.x, p.y), p.z) - r;\n    \n}\n\nfloat map(in vec3 p){\n   \n    \n    // Back plane. Six units behind the center of the weaved object.\n    float pln = -p.z + 6.;\n    \n    \n    // Rotate the object.\n    p = rotObj(p);\n    \n    // DjinnKahn's icosahedral distance function that produces a triangular face\n    // and allows you to determine between the negative and positive X axis.\n    //\n    // Weaves are simple: Connect lines from one edge to another and arrange for\n    // them to cross over one another inbetween. For instance, lines from the left\n    // should meet at a join that sits lower than the join connecting lines from\n    // the other direction... With that stand icosaheron function, you can't \n    // determine which side of the face you're one, so it's not possible. \n    // Thankfully, the following contains positive and negative X values.\n    p = opIcosahedronWithPolarity(p);\n    \n    \n    #ifdef NO_POLARITY\n    // This line emulates no polarity across the triangle face X axis. The pattern is \n    // still interesting, but the weave is gone. Not accounting for X polarity was the \n    // reason my original weaving attempts using a space folding formula didn't work --\n    // It's a bit hard to use negative values when there aren't any... Thankfully, \n    // DjinnKahn was learned up much more gooderer than me. :D\n    p.x = abs(p.x);\n    #endif\n\n \n    // Some constant variables.  \n    const vec3 flip = vec3(-1, 1, 1); // Quick way to swap from one side to the other.\n    const float lw = .02; // Capsule line thickness.\n    float lf = .45; // Capsule line length factor.\n    \n    // Height difference factor: The Z coordinate pushes things in or out. To create \n    // the weave, the mid point of the lines from one direction has to be higher or \n    // lower than those coming from the other. A lower number gives a tighter -- and\n    // probably nicer looking -- weave, but I wanted the object to look like it was\n    // hacked together... Kind of like this code. :D\n    const vec3 hd = vec3(0, 0, .08); \n    \n    \n    // Three distance field values. They're distinguishable for object identification\n    // purposes.\n    float d = 1e5, d2 = 1e5, d3 = 1e5;\n    \n    \n    #ifdef SHOW_EDGES\n    // Note the \"abs(p).\" That's just a quick way to make the coordinates non-polar, which\n    // allow you to render just one point, side, etc, and have all three show up. Space\n    // folding can do your head in sometimes. :)\n    //\n    // Showing the icosahedral frame -- for those like myself who require a visual understanding \n    // of what's happening... or for those who enjoy spoiling the illusion for themselves. :)\n    d = min(d, sdCapsule(abs(p), v0, v1, .0125, .55)); // Edges.\n    #endif\n    \n    #ifdef SHOW_VERTICES\n    d2 = min(d2, length(v0 - p) - .04); // Vertices.\n    #endif\n    \n    #ifdef SHOW_FACE_SYMMETRY\n    d2 = min(d2, sdCapsule(abs(p), mix(v0, v1, .5), cent, .0125, .55)); \n    #endif\n   \n    \n    // The weave pattern: The best way to see how this works is to uncomment the \n    // \"SHOW_EDGES\" and \"SHOW_VERTICES\" directives at the top of the page.\n    // In essence, we're using the prefolded coordinate symmetry and X polarity \n    // to render three woven crosses. By the way, the easiest way to see what \n    // something does is to comment it out.\n    //\n    // One thing that can get a little confusing is that the icosahedral folding\n    // formula gives you the cordinates a triangle that is subdivided a further\n    // three times. The lines of symmetry run between the face center and the \n    // mid points between the three sides. Each of those regions has a polar\n    // X-axis. Of course, descriptions don't mean a thing until you can look at\n    // a visual, so uncomment \"SHOW_EDGES\" and \"SHOW_FACE_REGIONS.\" \n    \n    // A point 21.5% of the way from v0 along the v0-v1 edge. This is a standard\n    // way to obtain a linear position between two points.\n    vec3 a = mix(v0, v1, .425*.5);\n    // 37.5% if the way between the middle of edge v0-v2 and the triangular face center.\n    vec3 b = (mix(mix(v0, v2, .5), cent, .375));\n    vec3 mid = (mix(a, b, .5)); // Half way between points \"a\" and \"b\".\n    \n    // Render the first cross. Note that the mid point dips at the midpoint on one\n    // stoke and raises on the other.\n    d = min(d, sdCapsule(p, a, mid - hd, lw, lf));\n    d = min(d, sdCapsule(p, mid - hd, b, lw, lf));\n    d = min(d, sdCapsule(p, flip*a, flip*mid + hd, lw, lf));\n    d = min(d, sdCapsule(p, flip*mid + hd, flip*b, lw, lf));\n\n    // There are two rails in all. This is another rendered next to the first.\n    // The result is double rails.\n    vec3 a2 = (mix(v0, v1, .575*.5));\n    vec3 b2 = (mix(mix(v0, v2, .5), cent, .625));\n    vec3 mid2 = (mix(a2, b2, .5));\n    \n    d = min(d, sdCapsule(p, a2, mid2 - hd, lw, lf));\n    d = min(d, sdCapsule(p, mid2 - hd, b2, lw, lf));\n    d = min(d, sdCapsule(p, flip*a2, flip*mid2 + hd, lw, lf));\n    d = min(d, sdCapsule(p, flip*mid2 + hd, flip*b2, lw, lf)); \n    \n    const float lw2 = .035; // Thicker joiner capsule lines.\n    lf = 1.; // Longer joiner capsule lines.\n    \n    // The gold joiner capsules connecting one rail to the other.\n    d2 = min(d2, sdCapsule(abs(p), a, a2, lw2, lf));\n    d2 = min(d2, sdCapsule(abs(p), flip*b, flip*b2, lw2, lf));\n    \n    \n    // The ball bearing joiners at the mid points.\n    const float jw = .02;\n    d3 = min(d3, dist(mid - hd - p, jw));\n    d3 = min(d3, dist(mid2 - hd - p, jw));  \n    d3 = min(d3, dist(flip*mid + hd - p, jw));    \n    d3 = min(d3, dist(flip*mid2 + hd - p, jw));  \n     \n    \n    // Store the individual object values for sorting later. Sorting multiple objects\n    // inside a raymarching loop probably isn't the best idea. :)\n    objID = vec4(d, d2, d3, pln);\n    \n    return min(min(d, d2), min(d3, pln));\n}\n\n/*\n// Tetrahedral normal, to save a couple of \"map\" calls. Courtesy of IQ. In instances where there's no descernible \n// aesthetic difference between it and the six tap version, it's worth using.\nvec3 calcNormal(in vec3 p){\n\n    // Note the slightly increased sampling distance, to alleviate artifacts due to hit point inaccuracies.\n    vec2 e = vec2(0.0025, -0.0025); \n    return normalize(e.xyy * map(p + e.xyy) + e.yyx * map(p + e.yyx) + e.yxy * map(p + e.yxy) + e.xxx * map(p + e.xxx));\n}\n*/\n\n/*\n// Standard normal function. 6 taps.\nvec3 calcNormal(in vec3 p) {\n\tconst vec2 e = vec2(0.002, 0);\n\treturn normalize(vec3(map(p + e.xyy) - map(p - e.xyy), map(p + e.yxy) - map(p - e.yxy),\tmap(p + e.yyx) - map(p - e.yyx)));\n}\n*/\n\n// Normal calculation, with some edging and curvature bundled in.\nvec3 calcNormal(vec3 p, inout float edge, inout float crv, float t) { \n\t\n    // It's worth looking into using a fixed epsilon versus using an epsilon value that\n    // varies with resolution. Each affects the look in different ways. Here, I'm using\n    // a mixture. I want the lines to be thicker at larger resolutions, but not too thick.\n    // As for accounting for PPI; There's not a lot I can do about that.\n    vec2 e = vec2(2.5/mix(400., iResolution.y, .5), 0);\n\n\tfloat d1 = map(p + e.xyy), d2 = map(p - e.xyy);\n\tfloat d3 = map(p + e.yxy), d4 = map(p - e.yxy);\n\tfloat d5 = map(p + e.yyx), d6 = map(p - e.yyx);\n\tfloat d = map(p)*2.;\n\n    edge = abs(d1 + d2 - d) + abs(d3 + d4 - d) + abs(d5 + d6 - d);\n    //edge = abs(d1 + d2 + d3 + d4 + d5 + d6 - d*3.);\n    edge = smoothstep(0., 1., sqrt(edge/e.x*2.));\n/*    \n    // Wider sample spread for the curvature.\n    e = vec2(12./450., 0);\n\td1 = map(p + e.xyy), d2 = map(p - e.xyy);\n\td3 = map(p + e.yxy), d4 = map(p - e.yxy);\n\td5 = map(p + e.yyx), d6 = map(p - e.yyx);\n    crv = clamp((d1 + d2 + d3 + d4 + d5 + d6 - d*3.)*32. + .5, 0., 1.);\n*/\n    \n    e = vec2(.001, 0); //iResolution.y - Depending how you want different resolutions to look.\n\td1 = map(p + e.xyy), d2 = map(p - e.xyy);\n\td3 = map(p + e.yxy), d4 = map(p - e.yxy);\n\td5 = map(p + e.yyx), d6 = map(p - e.yyx);\n\t\n    return normalize(vec3(d1 - d2, d3 - d4, d5 - d6));\n}\n\n// Raymarching: The distance function is a little on the intensive side, so I'm \n// using as fewer iterations as necessary. Even though there's a breat, the compiler\n// still has to unroll everything, and larger numbers make a difference.\nfloat trace(in vec3 ro, in vec3 rd){\n    \n    float t = 0., d;\n    \n    for(int i = 0; i<64; i++){\n    \n        d = map(ro + rd*t);\n        if(abs(d) < .001*(1. + t*.05) || t > FAR) break;\n        t += d;\n    }\n    \n    return min(t, FAR);\n}\n\nfloat hash( float n ){ return fract(cos(n)*45758.5453); }\n\n// Ambient occlusion, for that self shadowed look. Based on the original by XT95. I love this \n// function and have been looking for an excuse to use it. For a better version, and usage, \n// refer to XT95's examples below:\n//\n// Hemispherical SDF AO - https://www.shadertoy.com/view/4sdGWN\n// Alien Cocoons - https://www.shadertoy.com/view/MsdGz2\nfloat calculateAO( in vec3 p, in vec3 n, float maxDist )\n{\n\tfloat ao = 0.0, l;\n\tconst float nbIte = 6.0;\n\t//const float falloff = 0.9;\n    for( float i=1.; i< nbIte + .5; i++ ){\n    \n        l = (i + hash(i))*.5/nbIte*maxDist;\n        ao += (l - map( p + n*l ))/(1.+ l);// / pow(1.+l, falloff);\n    }\n\t\n    return clamp( 1.-ao/nbIte, 0., 1.);\n}\n\n// The iterations should be higher for proper accuracy.\nfloat softShadow(in vec3 ro, in vec3 rd, float t, in float end, in float k){\n\n    float shade = 1.0;\n    // Increase this and the shadows will be more accurate, but more iterations slow things down.\n    const int maxIterationsShad = 24; \n\n    // The \"start\" value, or minimum, should be set to something more than the stop-threshold, so as to avoid a collision with \n    // the surface the ray is setting out from. It doesn't matter how many times I write shadow code, I always seem to forget this.\n    // If adding shadows seems to make everything look dark, that tends to be the problem.\n    float dist = .001*(1. + t*.1);\n    float stepDist = end/float(maxIterationsShad);\n\n    // Max shadow iterations - More iterations make nicer shadows, but slow things down. Obviously, the lowest \n    // number to give a decent shadow is the best one to choose. \n    for (int i=0; i<maxIterationsShad; i++){\n        // End, or maximum, should be set to the distance from the light to surface point. If you go beyond that\n        // you may hit a surface not between the surface and the light.\n        float h = map(ro + rd*dist);\n        shade = min(shade, k*h/dist);\n        //shade = min(shade, smoothstep(0.0, 1.0, k*h/dist));\n        \n        // What h combination you add to the distance depends on speed, accuracy, etc. To be honest, I find it impossible to find \n        // the perfect balance. Faster GPUs give you more options, because more shadow iterations always produce better results.\n        // Anyway, here's some posibilities. Which one you use, depends on the situation:\n        // +=max(h, 0.001), +=clamp( h, 0.01, 0.25 ), +=min( h, 0.1 ), +=stepDist, +=min(h, stepDist*2.), etc.\n        \n        dist += clamp(h, 0.01, 0.25);\n        \n        // There's some accuracy loss involved, but early exits from accumulative distance function can help.\n        if (abs(h)<0.0001 || dist > end) break; \n    }\n\n    // I usually add a bit to the final shade value, which lightens the shadow a bit. It's a preference thing. Really dark shadows \n    // look too brutal to me.\n    return min(max(shade, 0.) + 0.1, 1.0); \n}\n\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Aspect correct screen coordinates.\n    vec2 p = (fragCoord - iResolution.xy*.5) / iResolution.y;\n    \n    // Unit direction ray.\n    vec3 rd = normalize(vec3(p, 1.));\n    \n    // Ray origin, doubling as the camera postion.\n    vec3 ro = vec3(0.0, 0.0, -3.);\n    \n    // Light position. Near the camera.\n    vec3 lp = ro + vec3(0.25, 2, 0);\n    \n    // Ray march.\n    float t = trace(ro, rd);\n    \n    // Object identification: Back plane: 3, Golden joins: 2., \n    // Ball joins: 1., Silver pipes:  0.\n    float svObjID = objID.x<objID.y && objID.x<objID.z && objID.x<objID.w? 0.: \n    objID.y<objID.z && objID.y<objID.w ? 1. : objID.z<objID.w? 2. : 3.;\n\n    \n    // Initiate the scene color zero.\n    vec3 col = vec3(0);\n    \n    // Surface hit. Color it up.\n    if(t < FAR){\n    \n        // Position.\n        vec3 pos = ro + rd*t;\n        // Normal.\n        //vec3 nor = calcNormal(pos);\n        // Normal, plus edges and curvature. The latter isn't used.\n        float edge = 0., crv = 1.;\n        vec3 nor = calcNormal(pos, edge, crv, t);\n        \n        //vec3 rp = rotObj(pos);\n        \n        // Light direction vector.\n        vec3 li = lp - pos;\n        float lDist = max(length(li), .001);\n        li /= lDist;\n        \n        // Light falloff - attenuation.\n        float atten = 1.5/(1. + lDist*.05 + lDist*lDist*0.01);\n        \n        // Soft shadow and occlusion.\n        float shd = softShadow(pos + nor*.0015, li, t, lDist, 8.); // Shadows.\n        float ao = calculateAO(pos, nor, 4.);\n        \n        \n        float diff = max(dot(li, nor), .0); // Diffuse.\n        float spec = pow(max(dot(reflect(-li, nor), -rd), 0.), 16.); // Specular.\n        // Ramping up the diffuse. Sometimes, it can make things look more metallic.\n        diff = pow(diff, 4.)*2.; \n        \n        \n        float Schlick = pow( 1. - max(dot(rd, normalize(rd + li)), 0.), 5.0);\n\t\tfloat fre2 = mix(.5, 1., Schlick);  //F0 = .5.\n\t\t\n        col = vec3(.6); // Silver pipes.\n        \n        if(svObjID == 1.) { // Golden joins\n            col = vec3(1, .55, .2);\n            col = mix(col, col.yxz, rd.y*.5);\n        }\n        //if(svObjID == 2.) col = vec3(1, .55, .2).zyx/1.5; // Ball joins.\n        if(svObjID == 3.) { // Back plane.\n            \n            // Subtle blue gradient with fine lines.\n            col = vec3(1, .55, .2).zyx/7.;\n            col = mix(col, col.yxz, rd.y*.1 + .1);\n            col *= clamp(sin((pos.x - pos.y)*iResolution.y/8.)*2. + 1.5, 0., 1.)*.5 + .5;\n        }\n        \n        // Diffuse plus ambient term.\n        col *= diff + .25; \n        \n        // Specular term.\n        if(svObjID == 3.) col += vec3(1, .6, .2).zyx*spec*.25; // Less specular on the back plane.\n        else col += vec3(.5, .75, 1.)*spec*2.;\n        \n        col *= 1. - edge*.7;\n        //col = col*.7 + edge*.3;\n        \n        col *= atten*shd*ao; // Light falloff.\n        \n         \n    }\n    \n    // Screen color. Rough gamma correction. No fog or postprocessing.\n    fragColor = vec4(sqrt(clamp(col, 0., 1.)), 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MttczH.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[3487, 3511, 3530, 3530, 3588], [3590, 3671, 3691, 3691, 3772], [6693, 6940, 6982, 6982, 7188], [7392, 7758, 7780, 7780, 7941], [7944, 8152, 8212, 8241, 8670], [8673, 8977, 9005, 9005, 9148], [9150, 9150, 9171, 9249, 14927], [15657, 15723, 15792, 16135, 17105], [17107, 17346, 17382, 17382, 17587], [17589, 17589, 17611, 17611, 17646], [17648, 17995, 18053, 18053, 18339], [18341, 18397, 18473, 18473, 20518], [20523, 20523, 20580, 20622, 23621]], "test": "untested"}
{"id": "MttyDn", "name": "Practicing Modeling", "author": "Veggiebob", "description": "Practicing my modeling skills. Also learning lighting methods. Help from IQ for smooth minimums and correct cylinders. Mouseable", "tags": ["mouse", "rotate", "model", "practice", "cylinder", "reflect"], "likes": 0, "viewed": 89, "published": "Public", "date": "1532282986", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define EPSILON pow(10., -3.)\n#define bigness 0.01\n#define PI 3.1415926\nvec3 tex (vec3 p, sampler2D t){\n    vec3 t1 = texture(t, p.xy).rgb/3.;\n    t1+=texture(t, p.xz).rgb/3.;\n    t1+=texture(t, p.yz).rgb/3.;\n    return t1;\n}\nfloat align (float diff, float dim){\n    if(diff>=dim){\n        return diff-dim;\n    } else {\n        return 0.;\n    }\n}\nfloat box3D (vec3 boxPos, vec3 boxSize, vec3 pos){\n    float n = align(abs(pos.x-boxPos.x), boxSize.x)+align(abs(pos.y-boxPos.y), boxSize.y);\n    n+=align(abs(pos.z-boxPos.z), boxSize.z);//just to keep the lines short\n    return n;\n}\nfloat sphere (vec3 spherePos, vec3 pos, float radius){\n    return length(pos-spherePos)-radius;\n}\n//Credit to Inigo Quilez for original function-- http://iquilezles.org/www/articles/distfunctions/distfunctions.htm\nfloat CappedCylinder( vec3 pos, vec3 p, vec2 h )\n{\n  p = p-pos;\n  vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\nfloat cylinder (vec3 pos, vec3 p, float radius, float height){\n    vec3 diff = p-pos;\n    float yd = abs(diff.y);\n    return (length(diff.xz)-radius)+smoothstep(yd, -height*0.5, height*0.6);//+smoothstep(abs(diff.y)-height, 0., -height);\n}\nfloat doubleCone (vec3 pos, vec3 p, float radius, float height){\n    vec3 diff = p-pos;\n    float yd = abs(diff.y)-height;\n    return (length(diff.xz)-radius)-yd;\n}\n//useful functions\nvec2 rotate2D (vec2 p, float angle){\n    float a = atan(p.y, p.x)+angle;\n    float m = length(p);\n    return vec2(cos(a)*m, sin(a)*m);\n}\n//from IQ -- http://www.iquilezles.org/www/articles/smin/smin.htm\nfloat smin( float a, float b, float k)\n{\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\nfloat mymin (float a, float b, float k){\n    return min(a, b)-abs(a-b)/(k*100.);\n}\nvec4 SDF (vec3 p){\n    vec3 matCol = vec3(-1.);\n    float total = 0.;\n    \n    float sc = 0.005;\n    //modeling\n    float mainBody = box3D(vec3(0., 0., 0.48)*sc, vec3(4., 0.5, 0.9)*sc, p);\n    float trigger = box3D(vec3(3.5, 0.5, 0.28)*sc, vec3(0.5, 0.5, 1.1)*sc, p);\n    \n    float curveBody = box3D(vec3(0., 0., -0.9)*sc, vec3(3., 0.5, 0.5)*sc, p);\n    float round1 = CappedCylinder(vec3(3.0, 0., -0.4)*sc, p, vec2(1., 0.5)*sc);\n    float round2 = CappedCylinder(vec3(-3.0, 0., -0.4)*sc, p, vec2(1., 0.5)*sc);\n    \n    float homeButton = sphere(vec3(-2., -0.3+sin(iTime), 0.4)*sc, p, 0.5*sc);\n    float otherButton = sphere(vec3(-2.+sin(iTime-0.01)*1.,0., 0.4)*sc, p, 0.8*sc);\n    //distance field editing\n    \n    //green section\n    total = smin(mainBody, trigger, 0.);\n    total = min(curveBody, total);\n    round1 = min(round1, trigger);\n    total = min(total, round1);\n    total = min(total, round2);\n    total = min(total, trigger);\n    if(total<0.0001&&matCol.x<0.){\n        matCol = vec3(0.3, 1., 0.3);\n    }\n    //textured section\n    total = max(total, -otherButton);\n    if(total<0.0001&&matCol.x<0.){\n        matCol = tex(p*20., iChannel1);\n    }\n    //black section\n    total = smin(total, homeButton, 0.001);\n    if(total<0.0001&&matCol.x<0.){\n        matCol = vec3(0.);\n    }\n    return vec4(total, matCol);\n}\nvec4 trace (vec3 o, vec3 r) {\n    float t = 0.;\n    vec3 p = o;\n    for(int i = 0; i<128; i++){\n        p = o+r*t;\n        float d = SDF(p).x;\n        t+=d*0.6;\n    }\n    return vec4(p, t);\n}\n//Credit to Jamie Wong http://jamie-wong.com/2016/07/15/ray-marching-signed-distance-functions/#surface-normals-and-lighting\nvec3 estimateNormal(vec3 p) {\n    return normalize(vec3(\n        SDF(vec3(p.x + EPSILON, p.y, p.z)).x - SDF(vec3(p.x - EPSILON, p.y, p.z)).x,\n        SDF(vec3(p.x, p.y + EPSILON, p.z)).x - SDF(vec3(p.x, p.y - EPSILON, p.z)).x,\n        SDF(vec3(p.x, p.y, p.z  + EPSILON)).x - SDF(vec3(p.x, p.y, p.z - EPSILON)).x\n    ));\n}\n\n//made this one myself with some tutorials I found out there on the web\nfloat diffuseLight (vec3 p, vec3 n, vec3 r){\n    return dot(n, -r);\n}\nfloat specularLight (vec3 p, vec3 n, vec3 r){\n    vec3 nr = reflect(r, n);\n    return pow(dot(nr, -r), 2.);\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    //setup coordinates\n    vec2 mouse = iMouse.xy/iResolution.xy - vec2(0.5, 0.);\n    if(iMouse.xy == vec2(0.))mouse = vec2(0.5, 0.2);\n    mouse.x*=5.;\n    mouse.y*=2.;\n    vec2 uv = fragCoord/iResolution.xy;\n\tuv-=0.5;\n    uv.x*=iResolution.x/iResolution.y;\n    \n    //setup camera + rays\n    float angle = mouse.x;\n    float fov = 0.5;\n    float camDist = bigness*6.;\n    vec3 camera = vec3(cos(mouse.x)*camDist, 0., sin(mouse.x)*camDist);\n    vec3 ray = vec3(-cos(mouse.x+uv.x*fov)*2., uv.y, -sin(mouse.x+uv.x*fov)*2.);\n    ray = normalize(ray);\n    mouse.y-=0.5;\n    mouse.y*=-2.5;\n    camera = vec3(rotate2D(camera.xy, mouse.y), camera.z);\n    ray = vec3(rotate2D(ray.xy, mouse.y), ray.z);\n    \n    //do the raymarching\n    vec4 v = trace(camera, ray);\n    vec3 normal = estimateNormal(v.xyz);//keep here\n    vec3 col = vec3(0.);\n    //optional reflection:\n    //col = texture(iChannel0, reflect(ray, normal)).rgb*0.5;\n    col = SDF(v.xyz).yzw;//tex(v.xyz*5., iChannel1);\n    \n    //do the lighting https://learnopengl.com/Lighting/Basic-Lighting\n    col+=diffuseLight(v.xyz, normal, ray)*0.2;\n    col+=specularLight(v.xyz, normal, ray)*vec3(1., 1., 0.8)*0.3;//tint it yellow\n    col *= 1./(1.+pow(v.w*2., 10.)*0.1);//distance shading\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": "4dXGRn", "previewfilepath": "/media/ap/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg", "ctype": "texture"}, {"id": "XsX3zn", "previewfilepath": "/media/ap/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png", "ctype": "cubemap"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MttyDn.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[72, 72, 103, 103, 225], [226, 226, 262, 262, 346], [347, 347, 397, 397, 580], [581, 581, 635, 635, 678], [679, 795, 845, 845, 957], [958, 958, 1020, 1020, 1197], [1198, 1198, 1262, 1262, 1362], [1363, 1382, 1418, 1418, 1518], [1519, 1585, 1625, 1625, 1718], [1719, 1719, 1759, 1759, 1801], [1802, 1802, 1820, 1820, 3128], [3129, 3129, 3158, 3158, 3320], [3321, 3446, 3475, 3475, 3767], [3769, 3841, 3885, 3885, 3910], [3911, 3911, 3956, 3956, 4020], [4021, 4021, 4078, 4152, 5430]], "test": "untested"}
{"id": "XdGBWV", "name": "texture gen", "author": "MonterMan", "description": "texturing experiment", "tags": ["texturing"], "likes": 18, "viewed": 282, "published": "Public", "date": "1530425828", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float hash(in vec2 p)\n{\n    p = fract(p * vec2(821.35, 356.17));\n    p += dot(p, p+23.5);\n    return fract(p.x*p.y);\n}\n\nfloat noise(in vec2 p)\n{\n    vec2 ipos = floor(p);\n    vec2 fpos = fract(p);\n    \n    float a = hash(ipos + vec2(0, 0));\n    float b = hash(ipos + vec2(1, 0));\n    float c = hash(ipos + vec2(0, 1));\n    float d = hash(ipos + vec2(1, 1));\n    \n    vec2 t = smoothstep(0.0, 1.0, fpos);\n    return mix(mix(a, b, t.x), mix(c, d, t.x), t.y);\n}\n\nfloat fbm(in vec2 p)\n{\n    p += 1.13;\n    \n    float res = 0.0;\n    float amp = 0.5;\n    float freq = 2.0;\n    for (int i = 0; i < 6; ++i)\n    {\n        res += amp*noise(freq*p);\n        amp *= 0.5;\n        freq *= 2.0;\n    }\n    return res;\n}\n\nvec3 palette(float t)\n{\n    vec3 a = vec3(1, 1, 1);\n    vec3 b = vec3(0, 0.3, 0);\n    vec3 c = vec3(1, 0.7, 0);\n    vec3 d = vec3(1, 0, 0);\n    \n    if (t < 0.333)\n    {\n        return mix(a, b, 3.0*t);\n    }\n    else if (t < 0.666)\n    {\t\n        return mix(b, c, 3.0*(t - 0.3333));\n    }\n    else\n    {\n        return mix(c, d, 3.0*(t - 0.6666));\n    }\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n    float time = iTime;\n    \n    float x = fbm(uv);\n    x = fbm(uv + x - 0.01*time);\n    x = fbm(uv + x + 0.03*time);\n    \n    vec3 col = palette(x);\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XdGBWV.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 23, 23, 118], [120, 120, 144, 144, 458], [460, 460, 482, 482, 703], [705, 705, 728, 728, 1061], [1063, 1063, 1120, 1120, 1369]], "test": "untested"}
{"id": "XdGfW3", "name": "Inner", "author": "Plento", "description": "shade.\nAny tips on how to make the dark far parts look better? maybe like a simple blur? \nthank you.", "tags": ["2d", "tunnel"], "likes": 4, "viewed": 136, "published": "Public", "date": "1530680274", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define rep 0.8 // try smaller numbers around 0.2. looks cool\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = 2.0*vec2(fragCoord.xy - 0.5*iResolution.xy)/iResolution.y;\n    float mx = fragCoord.x / iMouse.y;\n    \n    vec3 pixel = vec3(0.2, 0.2, 0.2); \n    \n    vec2 h = fract(uv / length(rep * uv * uv) + iTime);\n\n    h -= 0.5;\n    \n    //pixel = mix(pixel, vec3(0.0, 1.0, 0.0), step(min(h.x, h.y) / log(length(uv * 5.5 * sin(iTime * 0.25))), 0.01));\n     pixel = mix(pixel, vec3(0.0, 1.0, 0.0), step(min(h.x, h.y) , 0.01));\n    \n    float shade = smoothstep(0.68, 0.0, h.x); // lines shadows\n   \tfloat s = smoothstep(-0.05, 0.3, length(uv * uv) * 0.5); // far dark shadow\n    vec3 s2 =  mix(vec3(1.0, 0.0, 1.0), vec3(.3, 1.0, 1.3), 0.2); // additional coloring\n    \n    fragColor = vec4(mix(pixel, s2, 0.25) * shade * s * 1.2, 1.0);\n    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XdGfW3.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[63, 63, 120, 120, 865]], "test": "untested"}
{"id": "XdGfWt", "name": "radius", "author": "lennyjpg", "description": "O", "tags": ["asdfasdf"], "likes": 3, "viewed": 296, "published": "Public API", "date": "1530928682", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define SC(a) vec2(sin(a),cos(a))\nvoid mainImage( out vec4 O, in vec2 fr ){\n    \n    vec2 r = iResolution.xy;\n    vec2 uv = fr / r.y - .5;\n    float angle = iTime + sin(iTime) + atan(uv.y, uv.x);\n    \n    float w = length(uv * 1.5);\n   float f =cos(iTime+sin(w*1.5) * 16.) * .04;\n    \n    uv += SC( angle ) * cos(angle * 3.0) * f;\n    float m = length(uv*2.5);\n\n    O += sin( 1.5 + cos( m * 10.) * 20.) * 3.;\n\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XdGfWt.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[34, 34, 75, 75, 411]], "test": "untested"}
{"id": "XdKBDc", "name": "Liquid Metal Block", "author": "rkibria", "description": "Fake metal looking effect.", "tags": ["3d", "raymarching"], "likes": 2, "viewed": 125, "published": "Public", "date": "1530837536", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/*\nThanks to\n\nhttp://jamie-wong.com/2016/07/15/ray-marching-signed-distance-functions/\nhttp://iquilezles.org/www/articles/distfunctions/distfunctions.htm\n\n*/\n\n#define MAX_MARCHING_STEPS 99\n#define EPSILON 0.07\n#define MAX_DIST 100.0\n\nfloat udBox( vec3 p, vec3 b )\n{\n  return length(max(abs(p)-b,0.0));\n}\n\nfloat sdf( vec3 p )\n{\n\tfloat d = udBox( p, vec3(4.5, 0.6, 4.5) ) ;\n    float k1 = 1.4 + (sin(0.9*iTime)+1.)/2. * 1.4;\n    float k2 = 1.3 + 0.2*sin(0.5*iTime);\n    d += 0.005 * length(p)\n        * (k2 + sin(-1.1 + k1 * p.x + 0.5 * p.y))\n        * (k2 + cos(0.6 - k1 * p.y))\n        * (k2 + sin(0.5 - k1 * p.z))\n        * sin(iTime * 3.);\n\treturn d;\n}\n\nvec3 estimateNormal(vec3 p) {\n    return normalize(vec3(\n        sdf(vec3(p.x + EPSILON, p.y, p.z)) - sdf(vec3(p.x - EPSILON, p.y, p.z)),\n        sdf(vec3(p.x, p.y + EPSILON, p.z)) - sdf(vec3(p.x, p.y - EPSILON, p.z)),\n        sdf(vec3(p.x, p.y, p.z  + EPSILON)) - sdf(vec3(p.x, p.y, p.z - EPSILON))\n    ));\n}\n\nvec3 lighting(in vec3 pos, in vec3 n)\n{\n    vec3 c = (n + 1.) / 2.;\n    vec3 a = vec3( 0.05 + max(0., dot(n, vec3(1., 0.5, 0.5)) ) );\n    a = a / ( 5. + pos.z );\n    return mix(a, c, 0.05);\n}\n\nvec3 march(in vec2 uv, in vec3 eye, in vec3 ray)\n{\n    float depth = 0.0;\n    for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n        vec3 pos = eye + depth * ray;\n        float dist = sdf( pos );\n        if( dist < EPSILON ) {\n            return lighting( pos, estimateNormal( pos ) );\n        }\n\n        depth += dist;\n\n        if ( depth >= MAX_DIST ) {\n            return mix( vec3(0.3), vec3( 0., 0., 1. ), uv.y );\n        }\n    }\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = ( fragCoord - .5 * iResolution.xy ) / iResolution.x;\n    vec3 col = vec3( 0 );\n    \n    vec3 eye = vec3(0., 1.5, -15.);\n    vec3 ray = normalize( vec3( uv, 1. ) );\n\n    col = march( uv, eye, ray );\n    \n    fragColor = vec4(sqrt(col),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XdKBDc.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 234, 265, 265, 303], [305, 305, 326, 326, 654], [656, 656, 685, 685, 965], [967, 967, 1006, 1006, 1158], [1160, 1160, 1210, 1210, 1596], [1598, 1598, 1655, 1655, 1908]], "test": "untested"}
{"id": "XdKBDV", "name": "Dancing Hills - With bonus nutty", "author": "uqone", "description": "Ok, I was bored. Really just a random copy/paste from other shaders here just for the fun of it...\nIf you can follow my code, then you are either insane or a genius, not sure which..\n\n2020/01/23 - Now with crappy volumetrics and bonus extra nuttiness!!!\n", "tags": ["sun", "mountains", "aurora", "hills"], "likes": 4, "viewed": 859, "published": "Public API", "date": "1530578912", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n#define TAU 6.2831853071\n\nvec3 Aurora(in vec2 fragCoord) \n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    \n    float o = texture(iChannel3, uv * 0.25 + vec2(0.0, iTime * 0.025)).r;\n    float d = (texture(iChannel2, uv * 0.25 - vec2(0.0, iTime * 0.02 + o * 0.02)).r * 2.0 - 1.0) * texture(iChannel0, uv * 0.25 - vec2(0.0, iTime * 0.02 + o * 0.02)).r;\n    \n    float v = uv.y + d * 0.1;\n    v = 1.0 - abs(v * 2.0 - 1.0);\n    v = pow(v, 2.0 + sin((iTime * 0.2 + d * 0.25) * TAU) * 0.5);\n    \n    vec3 color = vec3(0.0);\n    \n    float x = (1.0 - uv.x * 0.75);\n    float y = 1.0 - abs(uv.y * 2.0 - 1.0);\n    color += vec3(x * 0.75, y, x) * v;\n    \n    vec2 seed = fragCoord.xy;\n    vec2 r;\n    r.x = fract(sin((seed.x * 12.9898) + (seed.y * 78.2330)) * 43758.5453);\n    r.y = fract(sin((seed.x * 53.7842) + (seed.y * 47.5134)) * 43758.5453);\n\n    float s = mix(r.x, (sin((iTime * 2.5 + 60.0) * r.y) * 0.5 + 0.5) * ((r.y * r.y) * (r.y * r.y)), 0.04); \n    color += pow(s, 30.0) * (1.0 - v);\n    \n    return color;\n}\n\nvec3 skyColor( in vec3 rd )\n{\n    vec3 sundir = normalize( vec3(.0, .1, 1.) );\n    \n    float yd = min(rd.y, 0.);\n    rd.y = max(rd.y, 0.);\n    \n    vec3 col = vec3(0.);\n    \n    col += vec3(.4, .4 - exp( -rd.y*20. )*.3, .0) * exp(-rd.y*9.) * 2.0; // Red / Green \n    \n    float bpow = clamp(texture(iChannel3, vec2(0.0, iTime * 0.025)).r * 3.5, 0.0, 1.0);\n    \n    col += vec3(.3, .5, .6) * (1. - exp(-rd.y*8.) ) * exp(-rd.y*.9) * bpow ; // Blue\n    \n    col = mix(col*1.2, vec3(.3),  1.-exp(yd*100.)); // Fog\n    \n    col += vec3(1.0, .8, .55) * pow( max(dot(rd,sundir),0.), 15. ) * .6; // Sun\n    col += pow(max(dot(rd, sundir),0.), 150.0) *.15;\n    \n    return col;\n}\n\nvec3 sky( in vec2 fragCoord )\n{\n    //screen coords\n\tvec2 q = fragCoord.xy/iResolution.xy;\n\tvec2 v = -1.0+2.0*q;\n\tv.x *= iResolution.x/iResolution.y;\n\t\n\t//camera ray\n\tvec3 dir = normalize( vec3(v.x, v.y+.5, 1.5) );\n\t\n    //Scene\n    //vec3 col = vec3( checker(dir.xz/dir.y*.5+vec2(0.,-iTime*2.)) ) + skyColor(reflect(dir,vec3(0.,1.,0.)))*.3;\n    vec3 col = skyColor(reflect(dir,vec3(0.,1.,0.)))*.3;\n    col = mix(col, skyColor(dir), exp(-max(-v.y*9.-4.8,0.)) );\n\n    //Vignetting\n\tcol *= .7 + .3*pow(q.x*q.y*(1.-q.x)*(1.-q.y)*16., .1);\n        \n\treturn col;\n}\n\n\n//vec3 sunDir = normalize( vec3(0.15,0.7,0.65) );\nvec3 sunDir = normalize( vec3(-1.0,-0.2,0.0) );\n//vec3 sunDir = normalize( -vec3(1.15,0.7,0.65) );\n\nfloat mapBk( in vec3 pos )\n{\n    float l = length(pos.xz);\n    float f = smoothstep( 1000.0, 1500.0, l );\n    \n    float c = pow(texture( iChannel1, 0.001 + 0.00003*pos.xz ).x, 0.5);\n    float c2 = pow(texture( iChannel1, 0.001 + 0.00003*pos.xy ).x, 0.5);\n    \n    //float h = 200.0*f*texture( iChannel2, 0.001 + 0.00003*pos.xz ).x;\n    float h = 280.0*f*texture( iChannel0, 0.001 + 0.00003*pos.xz ).x * (c + c2); // mountains height\n\n    return pos.y-h;\n}\n\nvec3 calcNormalBk( in vec3 pos, in float eps )\n{\n    vec2 e = vec2(1.0,-1.0)*0.5773*eps;\n    return normalize( e.xyy*mapBk( pos + e.xyy ) + \n\t\t\t\t\t  e.yyx*mapBk( pos + e.yyx ) + \n\t\t\t\t\t  e.yxy*mapBk( pos + e.yxy ) + \n\t\t\t\t\t  e.xxx*mapBk( pos + e.xxx ) );\n}\n\nvec3 shadeBk( in vec3 ro, in vec3 rd, in float t )\n{\n    float eps = 0.005;\n    \n    vec3 pos = ro + t*rd;\n    vec3 nor = calcNormalBk( pos, eps*t );\n    float kk;\n\n    vec3 mateD = vec3(0.14,0.14,0.12);\n    mateD = mix( mateD, vec3(0.03,0.03,0.0), smoothstep(0.5,1.95, nor.y ) );\n    \n    //mateD *= 0.3;\n    //mateD *= 0.75; // brightness\n    mateD *= 0.5; // brightness\n    //mateD *= 0.25; // brightness\n    //mateD = pow(mateD * 0.3, vec3(1.1));\n  \n    mateD *= 0.1 + 2.0*texture( iChannel1, pos.xz*0.005 ).x;\n\n    //vec3 mateD = mix(texture( iChannel3, pos.xz*0.005 ).rgb, texture( iChannel1, pos.xz*0.005 ).rgb, nor.y * 0.5 + 0.5) * 0.2;\n    \n   // vec3 hal = normalize( sunDir-rd );\n        \n    float dif1 = clamp( dot(nor,sunDir), 0.0, 1.0 );\n    //float sha = calcSoftShadowBk( pos, sunDir, 16.0 );\n    //dif1 *= sha;\n\n    // sun\n    vec3 col = 8.0*vec3(1.8,1.2,0.8)*dif1;\n    // sky\n    col += 4.0*vec3(0.3,0.7,1.0)*clamp(0.2+0.8*nor.y,0.0,1.0);\n    \n    col *= mateD;\n\n    return col;\n}\n\nfloat intersectBk( in vec3 ro, in vec3 rd )\n{\n    float res = -1.0;\n\n    float maxdist = 2000.0;\n    float t = 1000.0;\n\n    for( int i=0; i<30; i++ )\n    {\n        vec3 p = ro + t*rd;\n        float h = mapBk( p );\n        res = t;\n        if( h<(0.0001*t) ||  t>maxdist ) break;\n        t += h*0.75;\n    }\n\n    if( t>maxdist ) res = -1.0;\n\n    return res;\n}\n\n#define BLOOMRAYS_STEPS\t\t\t64.0\n#define\tBLOOMRAYS_DECAY\t\t\t0.975\n#define\tBLOOMRAYS_WEIGHT\t\t0.23\n#define\tBLOOMRAYS_DENSITY\t\t1.0\n\nvec3 calcScatter(vec3 org, vec3 ro, vec3 rd) \n{\n    vec3\tlens = vec3(0.0, 0.0, 0.0);\n\tvec3\tScreenLightPos = vec3(0.0, 0.125, 0.0);//vec3(0.5);\n\tvec3\tdeltaTexCoord = (rd/*org*/ - ScreenLightPos);\n    vec3 \tpos = rd;//org;\n\n\tdeltaTexCoord *= 1.0 / float(float(BLOOMRAYS_STEPS) * BLOOMRAYS_DENSITY);\n\n\tfloat illuminationDecay = 1.0;\n\n\tfor (float g = 0.0; g < BLOOMRAYS_STEPS; g += 1.0)\n\t{\n\t\tpos -= deltaTexCoord;\n\n        float tm = intersectBk( ro, pos );\n   \t\tfloat grey = clamp(tm, 0.0, 1.0);\n        \n\t\tlens.xyz += (grey * illuminationDecay * BLOOMRAYS_WEIGHT) / (g+1.0);\n\n\t\tilluminationDecay *= BLOOMRAYS_DECAY;\n\n\t\tif (illuminationDecay <= 0.0)\n\t\t\tbreak;\n\t}\n\n\treturn vec3(1.0)-clamp(lens, 0.0, 1.0);\n}\n\nvec3 render( in vec3 ro, in vec3 rd, out float resT, vec2 fragCoord )\n{\n    resT = 10000.0;\n\tvec3 col = vec3(0.0);\n    float smp = texture(iChannel0, fragCoord/iResolution.xy).x;\n    \n    // distant mountains\n   \tfloat tm = intersectBk( ro, rd );\n   \tif( tm>-0.5  )\n   \t{\n       \tcol = shadeBk( ro, rd, tm );\n       \tfloat fa = 1.0-exp(-0.001*tm);\n       \tvec3 pos = ro + rd*tm;\n       \tfa *= exp(-0.001*pos.y);\n       \t//col = mix( col, vec3(0.4,0.5,0.65), fa );\n       \tresT = tm;\n        \n        float off = (fragCoord.y/(iResolution.y/3.0)) * 0.5 + 0.5;\n        off = pow(off, 0.75);\n        vec3 aur = clamp(Aurora(vec2(fragCoord.x, (iResolution.y / 2.0) * off)), 0.0, 1.0) * 0.25;\n        //col = (col + col + (col * aur) / 3.0);\n        vec3 aurPow = pow(col * (aur * 8.0), vec3(2.0));\n        col = clamp((col + col + aurPow) / 3.0, 0.0, 1.0);\n   \t}\n    else\n    {\n     \tvec3 sk = clamp(sky( fragCoord ), 0.0, 1.0);\n   \t\tvec3 aur = clamp(Aurora(fragCoord*(smp*0.5+0.5)), 0.0, 1.0);\n    \tvec3 sk2 = mix(aur, sk, clamp(length(aur), 0.0, 0.75));\n    \tsk = mix(sk * 0.25, clamp(sk2 * 0.333, 0.0, 1.0), clamp(length(sk2), 0.0, 1.0));\n        col = sk;\n    }\n    \n    float pw = clamp(tm * 0.0005 + 0.35, 0.0, 1.0);\n    pw = clamp(pow(pw, 8.0), 0.0, 1.0) * 1.5;\n    \n    vec3 aur2 = clamp(Aurora(fragCoord), 0.0, 1.0);\n    vec3 aur3 = clamp(Aurora(vec2(iResolution*0.5)), 0.0, 1.0) * pw;\n    vec3 vLight = calcScatter(ro + rd*tm, ro, rd) * (aur2 + aur3);\n    //return vLight;\n    return col + vLight;\n}\n\nmat3 setCamera( in vec3 ro, in vec3 rt, in float cr )\n{\n\tvec3 cw = normalize(rt-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, -cw );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\t\n    vec2 q = fragCoord/iResolution.xy;\n    vec2 p = (-iResolution.xy+2.0*fragCoord)/iResolution.y;\n\n    // camera\n    float an = 0.0;// - 1.25- 1.0*iMouse.x/iResolution.x;\n    vec3 ro = vec3(5.7*sin(an),1.6,5.7*cos(an));\n    //vec3 ta = vec3(0.0,1.6,0.0);\n    vec3 ta = vec3(0.0,2.65,0.0);\n    \n    // ray\n    mat3 ca = setCamera( ro, ta, 0.0 );\n    vec3 rd = normalize( ca * vec3(p,-5.5) );\n    \n    // render\n    float t;\n    vec3 col = clamp(render( ro, rd, t, fragCoord), 0.0, 1.0);\n\n    fragColor = vec4( col, 1.0 );\n}\n", "image_inputs": [{"id": "XdX3Rn", "previewfilepath": "/media/ap/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg", "channel": 3, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg", "ctype": "texture"}, {"id": "XsX3Rn", "previewfilepath": "/media/ap/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg", "ctype": "texture"}, {"id": "4sXGzn", "previewfilepath": "/media/ap/a6a1cf7a09adfed8c362492c88c30d74fb3d2f4f7ba180ba34b98556660fada1.mp3", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/a6a1cf7a09adfed8c362492c88c30d74fb3d2f4f7ba180ba34b98556660fada1.mp3", "ctype": "music"}, {"id": "4sf3Rr", "previewfilepath": "/media/ap/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XdKBDV.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[27, 27, 60, 60, 1011], [1013, 1013, 1042, 1042, 1684], [1686, 1686, 1717, 1737, 2245], [2346, 2398, 2426, 2426, 2854], [2856, 2856, 2904, 2904, 3109], [3111, 3111, 3163, 3163, 4110], [4112, 4112, 4157, 4157, 4469], [4597, 4597, 4644, 4644, 5300], [5302, 5302, 5373, 5373, 6807], [6809, 6809, 6864, 6864, 7042], [7044, 7044, 7101, 7101, 7626]], "test": "untested"}
{"id": "XdKfWK", "name": "rgen2 (heavy)", "author": "xinux", "description": "randomly generated 3d graph", "tags": ["random", "fixedstep", "generatedcode"], "likes": 1, "viewed": 110, "published": "Public", "date": "1530543000", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec2 pR(vec2 p, float a)\n{\np = ((p * cos(a)) + (vec2(p.y, (-p.x)) * sin(a)));\nreturn p;\n\n}\n\nvoid pRV(inout vec2 p, float a)\n{\np = ((p * cos(a)) + (vec2(p.y, (-p.x)) * sin(a)));\n\n}\n\nfloat rand1d(float n)\n{\nreturn fract((sin(n) * 43758.55));\n\n}\n\nfloat noise(vec2 uv, float intensity)\n{\nreturn min(1.0, ((1.0 / (rand1d(((uv.x * 20.0) + 1.0)) + rand1d((uv.y * 40.0)))) * intensity));\n\n}\n\nvec3 scene(float z)\n{\nvec2 uv = ((gl_FragCoord.xy - (iResolution.xy * 0.5)) / iResolution.yy);\nvec3 p = vec3(uv, z);\npRV(p.yz, (iTime * 0.2));\npRV(p.zx, (iTime * -0.4));\np = (p / smoothstep((iTime + 1.0), 0.0, 1.0));\nvec3 col;\nfloat bgl = max((tan((pR(uv, iTime).y - 3.1416)) / 2.0), 3.1416);\nbgl = clamp(bgl, 0.1, 0.15);\nfloat l = clamp(min((round(((tan(sin((pR(vec2((tan(tan(length(vec2((length(vec2((-pR(uv, tan(pR(uv, length(vec2(sin(((tan(cos((((min((tan(cos(length(vec2(pR(uv, cos(((cos(length(vec2(min(((cos((pR(vec2((pR(uv, (tan(tan(max(pR(vec2((smoothstep(smoothstep(tan((-(-(tan(smoothstep((-(tan(pR(uv, pR(vec2(cos(pR(vec2((tan(pR(uv, iTime).y) / 2.0), iTime), iTime).x), (tan(iTime) / 2.0)), iTime).x).y) / 2.0)), 0.97, 1.0)) / 2.0)))), 0.97, 1.0), 0.97, 1.0) - (p.x * 10.0)), sin((iTime *1.57))), iTime).x, pR(uv, iTime).y))) / 2.0)).y + pR(uv, iTime).y), 3.1416), iTime).x * length(p))) / (p.y * 10.0)) * (p.x * 10.0)), pR(uv, iTime).y), (p.x * 10.0)))) - pR(p.zx, iTime).y) - iTime))).x, iTime)))) / 2.0), pR(p.zx, iTime).x) * sin((iTime * 1.57))) / length(p)) * (tan(iTime) / 2.0)))) / 2.0) / pR(uv, iTime).y)), (p.y * 10.0)))).x)).x), pR(p.zx,iTime).x)) + (p.x * 10.0)), (p.z * 10.0))))) / 2.0), 3.1416), iTime).y * (p.y * 10.0)))) / 2.0) * 10.0)) / 10.0), 3.1416), 0.0, 0.95);\ncol = ((normalize(vec3(1.013968, 1.360327, 1.795099)).zxy * clamp(((1.0 / length((p - clamp(p, -0.2, 0.2)))) * 0.002), 0.0, 1.0)) * l);\nreturn col;\n\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\nvec2 uv = ((gl_FragCoord.xy - (iResolution.xy * 0.5)) / iResolution.yy);\nvec3 col = vec3(0.1);\nfor(float index = -0.5;(index < 0.5);index = (index + 0.004))\n{\ncol = (col + (scene(index) * 0.025));\n\n}\n\ncol = clamp(col, 0.0, 1.0);\ncol = (col * smoothstep(0.1, 0.3, iTime));\ncol = (col - (smoothstep(0.55, 1.3, abs(uv.x)) * 0.2));\ncol = (col - (smoothstep(0.17, 0.7, abs(uv.y)) * 0.2));\ncol = max(col, vec3(0.03));\ncol = (col + (sin((iTime * 0.4)) * 0.02));\ncol = (col + (noise(pR(uv, iTime), 0.5) * 0.04));\ncol = (col - step(0.35, abs(uv.y)));\nfragColor = vec4(col, 1.0);\n\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XdKfWK.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 26, 26, 90], [92, 92, 125, 125, 179], [181, 181, 204, 204, 242], [244, 244, 283, 283, 382], [384, 384, 405, 405, 1829], [1831, 1831, 1886, 1886, 2459]], "test": "untested"}
{"id": "XdVBWd", "name": "Cubic Bezier - 2D BBox", "author": "iq", "description": "Computing the exact bounding box to a cubic Bezier curve. Yellow: naive bbox of the 4 control points. Blue: exact/analytic bbox. Since the bezier is cubic, the bbox can be compute with a quadratic equation.", "tags": ["2d", "bezier", "cubic", "boundingbox", "bbox"], "likes": 44, "viewed": 3435, "published": "Public API", "date": "1531095087", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// The MIT License\n// Copyright © 2018 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n\n// Computes the exact axis aligned bounding box to a cubic Bezier curve. Since\n// the bezier is cubic, the bbox can be compute with a quadratic equation:\n//\n//   Yellow: naive bbox of the 4 control points\n//   Blue: exact bbox\n//\n// More info here: http://iquilezles.org/www/articles/bezierbbox/bezierbbox.htm\n//    \n// Related Shaders:\n//     Quadratic Bezier - 3D      : https://www.shadertoy.com/view/ldj3Wh\n//     Cubic     Bezier - 2D BBox : https://www.shadertoy.com/view/XdVBWd \n//     Cubic     Bezier - 3D BBox : https://www.shadertoy.com/view/MdKBWt\n//     Quadratic Bezier - 2D BBox : https://www.shadertoy.com/view/lsyfWc\n//     Quadratic Bezier - 3D BBox : https://www.shadertoy.com/view/tsBfRD\n\n\n#if 1\n// Exact BBox to a quadratic bezier\nvec4 bboxBezier(in vec2 p0, in vec2 p1, in vec2 p2, in vec2 p3 )\n{\n    // extremes\n    vec2 mi = min(p0,p3);\n    vec2 ma = max(p0,p3);\n\n    vec2 k0 = -1.0*p0 + 1.0*p1;\n    vec2 k1 =  1.0*p0 - 2.0*p1 + 1.0*p2;\n    vec2 k2 = -1.0*p0 + 3.0*p1 - 3.0*p2 + 1.0*p3;\n\n    vec2 h = k1*k1 - k0*k2;\n\n    if( h.x>0.0 )\n    {\n        h.x = sqrt(h.x);\n        //float t = (-k1.x - h.x)/k2.x;\n        float t = k0.x/(-k1.x-h.x);\n        if( t>0.0 && t<1.0 )\n        {\n            float s = 1.0-t;\n            float q = s*s*s*p0.x + 3.0*s*s*t*p1.x + 3.0*s*t*t*p2.x + t*t*t*p3.x;\n            mi.x = min(mi.x,q);\n            ma.x = max(ma.x,q);\n        }\n        //t = (-k1.x + h.x)/k2.x;\n        t = k0.x/(-k1.x+h.x);\n        if( t>0.0 && t<1.0 )\n        {\n            float s = 1.0-t;\n            float q = s*s*s*p0.x + 3.0*s*s*t*p1.x + 3.0*s*t*t*p2.x + t*t*t*p3.x;\n            mi.x = min(mi.x,q);\n            ma.x = max(ma.x,q);\n        }\n    }\n\n    if( h.y>0.0)\n    {\n        h.y = sqrt(h.y);\n        //float t = (-k1.y - h.y)/k2.y;\n        float t = k0.y/(-k1.y-h.y);\n        if( t>0.0 && t<1.0 )\n        {\n            float s = 1.0-t;\n            float q = s*s*s*p0.y + 3.0*s*s*t*p1.y + 3.0*s*t*t*p2.y + t*t*t*p3.y;\n            mi.y = min(mi.y,q);\n            ma.y = max(ma.y,q);\n        }\n        //t = (-k1.y + h.y)/k2.y;\n        t = k0.y/(-k1.y+h.y);\n        if( t>0.0 && t<1.0 )\n        {\n            float s = 1.0-t;\n            float q = s*s*s*p0.y + 3.0*s*s*t*p1.y + 3.0*s*t*t*p2.y + t*t*t*p3.y;\n            mi.y = min(mi.y,q);\n            ma.y = max(ma.y,q);\n        }\n    }\n   \n    return vec4( mi, ma );\n}\n#else\nvec4 bboxBezier(in vec2 p0, in vec2 p1, in vec2 p2, in vec2 p3 )\n{\n    // extremes\n    vec2 mi = min(p0,p3);\n    vec2 ma = max(p0,p3);\n\n    // note pascal triangle coefficnets\n    vec2 c = -1.0*p0 + 1.0*p1;\n    vec2 b =  1.0*p0 - 2.0*p1 + 1.0*p2;\n    vec2 a = -1.0*p0 + 3.0*p1 - 3.0*p2 + 1.0*p3;\n\n    vec2 h = b*b - a*c;\n\n    // real solutions\n    if( any(greaterThan(h,vec2(0.0))))\n    {\n        vec2 g = sqrt(abs(h));\n        vec2 t1 = clamp((-b - g)/a,0.0,1.0); vec2 s1 = 1.0-t1;\n        vec2 t2 = clamp((-b + g)/a,0.0,1.0); vec2 s2 = 1.0-t2;\n        vec2 q1 = s1*s1*s1*p0 + 3.0*s1*s1*t1*p1 + 3.0*s1*t1*t1*p2 + t1*t1*t1*p3;\n        vec2 q2 = s2*s2*s2*p0 + 3.0*s2*s2*t2*p1 + 3.0*s2*t2*t2*p2 + t2*t2*t2*p3;\n\n        if( h.x > 0.0 )\n        {\n            mi.x = min(mi.x,min(q1.x,q2.x));\n            ma.x = max(ma.x,max(q1.x,q2.x));\n        }\n\n        if( h.y > 0.0  )\n        {\n            mi.y = min(mi.y,min(q1.y,q2.y));\n            ma.y = max(ma.y,max(q1.y,q2.y));\n        }\n    }\n    \n    return vec4( mi, ma );\n}\n#endif\n\n// Approximated conservative BBox to a cubic bezier\nvec4 bboxBezierSimple(in vec2 p0, in vec2 p1, in vec2 p2, in vec2 p3 )\n{\n    vec2 mi = min(min(p0,p1),min(p2,p3));\n    vec2 ma = max(max(p0,p1),max(p2,p3));\n    \n    return vec4( mi, ma );\n}\n\n//---------------------------------------------------------------------------------------\n\nfloat sdBox( in vec2 p, in vec2 b ) \n{\n    vec2 q = abs(p) - b;\n    vec2 m = vec2( min(q.x,q.y), max(q.x,q.y) );\n    return (m.x > 0.0) ? length(q) : m.y; \n}\n\nfloat length2( in vec2 v ) { return dot(v,v); }\n\nfloat sdSegmentSq( in vec2 p, in vec2 a, in vec2 b )\n{\n\tvec2 pa = p-a, ba = b-a;\n\tfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n\treturn length2( pa - ba*h );\n}\n\nfloat sdSegment( in vec2 p, in vec2 a, in vec2 b )\n{\n\treturn sqrt(sdSegmentSq(p,a,b));\n}\n\n// slow, do not use in production. Can probably do better than\n// tesselation in linear segments.\nvec2 udBezier(vec2 p0, vec2 p1, vec2 p2, in vec2 p3, vec2 pos)\n{   \n    const int kNum = 50;\n    vec2 res = vec2(1e10,0.0);\n    vec2 a = p0;\n    for( int i=1; i<kNum; i++ )\n    {\n        float t = float(i)/float(kNum-1);\n        float s = 1.0-t;\n        vec2 b = p0*s*s*s + p1*3.0*s*s*t + p2*3.0*s*t*t + p3*t*t*t;\n        float d = sdSegmentSq( pos, a, b );\n        if( d<res.x ) res = vec2(d,t);\n        a = b;\n    }\n    \n    return vec2(sqrt(res.x),res.y);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //--------\n    // animate\n    //--------\n    float time = iTime*0.5 - 0.7;\n    vec2 p0 = 0.8*sin( time*0.7 + vec2(3.0,1.0) );\n    vec2 p1 = 0.8*sin( time*1.1 + vec2(0.0,6.0) );\n    vec2 p2 = 0.8*sin( time*1.3 + vec2(4.0,2.0) );\n    vec2 p3 = 0.8*sin( time*1.5 + vec2(1.0,5.0) );\n\n\t//-------------\n    // compute bbox\n\t//-------------\n    vec4 b1 = bboxBezierSimple(p0,p1,p2,p3);\n    vec4 b2 = bboxBezier(p0,p1,p2,p3);\n    \n    //--------\n    // render\n    //--------\n    \n    vec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n    float px = 2.0/iResolution.y;\n\n    // background\n    vec3 col = vec3(0.15);\n    float be = udBezier( p0, p1, p2, p3, p ).x;\n\tcol += 0.03*sin(be*150.0);\n    col *= 1.0 - 0.3*length(p);\n    \n    \n    // naive bbox\n    float d = sdBox( p-(b1.xy+b1.zw)*0.5, (b1.zw-b1.xy)*0.5 );\n    col = mix( col, vec3(1.0,0.6,0.0), 1.0-smoothstep(0.003,0.003+px,abs(d)) );\n    \n    // exact bbox\n    d = sdBox( p-(b2.xy+b2.zw)*0.5, (b2.zw-b2.xy)*0.5 );\n    col = mix( col, vec3(0.2,0.5,1.0), 1.0-smoothstep(0.003,0.003+px,abs(d)) );\n    \n    // control cage\n    d = sdSegment( p, p0, p1 );\n    col = mix( col, vec3(0.3), 1.0-smoothstep(0.003,0.003+px,d) );\n    d = sdSegment( p, p1, p2 );\n    col = mix( col, vec3(0.3), 1.0-smoothstep(0.003,0.003+px,d) );\n    d = sdSegment( p, p2, p3 );\n    col = mix( col, vec3(0.3), 1.0-smoothstep(0.003,0.003+px,d) );\n\n    // bezier\n    d = be;\n    col = mix( col, vec3(1.0), 1.0-smoothstep(0.003,0.003+px*1.5,d) );\n         \n    // control points\n    d = length(p0-p); col = mix( col, vec3(1.0), 1.0-smoothstep(0.04,0.04+px,d) );\n    d = length(p1-p); col = mix( col, vec3(1.0), 1.0-smoothstep(0.04,0.04+px,d) );\n    d = length(p2-p); col = mix( col, vec3(1.0), 1.0-smoothstep(0.04,0.04+px,d) );\n    d = length(p3-p); col = mix( col, vec3(1.0), 1.0-smoothstep(0.04,0.04+px,d) );\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XdVBWd.jpg", "access": "shaders20k", "license": "mit", "functions": [[4468, 4520, 4592, 4592, 4710], [4712, 4803, 4841, 4841, 4960], [4962, 4962, 4990, 4990, 5009], [5011, 5011, 5065, 5065, 5176], [5178, 5178, 5230, 5230, 5266], [5268, 5366, 5430, 5430, 5826], [5828, 5828, 5885, 5930, 7761]], "test": "untested"}
{"id": "XdVfW3", "name": "Mandelbrot : Smooth Coloring", "author": "Gijs", "description": "Most basic example of smooth iteration/coloring. http://www.iquilezles.org/www/articles/mset_smooth/mset_smooth.htm", "tags": ["mandelbrot", "iteration", "smooth", "coloring"], "likes": 2, "viewed": 154, "published": "Public", "date": "1531912341", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const int   MAX_ITERATIONS = 300;\nconst float BAILOUT        = 16.;\n\nfloat smooth_ite(vec2 c){\n    //calculate fractal orbit\n    vec2 z = vec2(0);\n    int N;\n    for(N=1;N<MAX_ITERATIONS && dot(z,z)<BAILOUT*BAILOUT;N++){\n        z = mat2(z,-z.y,z.x)*z+c;\n    }\n\n    //smooth iteration calculation\n    float K = float(N);\n    if(dot(z,z)>BAILOUT*BAILOUT){\n        K -= log2(log(length(z))/log(BAILOUT));\n    }\n    \n    //return palette color from smooth iteration\n    return K;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    //scale pixel such that the origin is in the middle of the screen\n    vec2 sp = (fragCoord*2.-iResolution.xy)/iResolution.y*2.;\n    \n    //animation\n    sp *= pow(.5,fract(iTime*0.05)*13.);\n    sp -= vec2(1.5019,0);\n    \n    //get smooth iteration\n    float i = smooth_ite(sp);\n    \n    vec3 col = vec3(0);\n    if(i!=float(MAX_ITERATIONS)){\n        col = vec3(cos(log(i)*3.)*.4 + .5);\n    }\n\n    fragColor = vec4(col, 0.);\n}", "image_inputs": [{"id": "4dXGR8", "previewfilepath": "/media/previz/buffer00.png", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/previz/buffer00.png", "ctype": "buffer"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XdVfW3.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[69, 69, 94, 124, 478], [481, 481, 537, 607, 966]], "test": "untested"}
{"id": "XdyBW3", "name": "shadertoy 1 v2", "author": "kylegrover", "description": "description", "tags": ["tag"], "likes": 1, "viewed": 344, "published": "Public API", "date": "1531107789", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord)\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 xy = fragCoord/iResolution.xy;\n    xy.x = abs(xy.x - 0.5);\n    xy.y = abs(xy.y - 0.5);\n    xy.x = fract(xy.x + (xy.y / 5000.0));\n//    xy.x = xy.x / iTime;\n//    xy.y = xy.y / iTime;\n\n\tfloat a = fract(sin(iTime * 11.9));\n    float b = fract(cos(iTime * 9.1));\n\n    // Time varying pixel color\n    float colg = 0.5 + 0.5*cos(iTime+xy.y + sin(abs(log(xy.x * xy.y) * iTime / 3.0) * 30.0 * (iTime / (1000.0 + iTime))));\n    float colb = tan( sin(pow(xy.x, xy.y)* iTime) + sin(pow(xy.y, xy.x)* iTime) );\n\n    float colr = sin(colg * 4.0 + (colb / 200.0));\n//    colg = sin(colg + (xy.y / (iTime * 2000.0)));\n//    colb = 1.0 - sin(colg * 4.0 + (colb / 200.0)) - sin(colg + (xy.y / (iTime * 2000.0)));\n    \n\t\n        colr = colr + step(colb, sin(iTime + xy.x / xy.y));\n        colg = step(colg, 0.5) + step(colb, 0.9);\n        colb = colb + step(colr, tan(iTime + xy.x / xy.y));\n\n    // Output to screen\n    fragColor = vec4(colr, colg, colb, 1.0); // normal output\n    \n    // fragColor = vec4(vec3(colg), 1.0); // peep the color channels\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XdyBW3.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 56, 106, 1151]], "test": "untested"}
{"id": "XdyfDm", "name": "Implicit function plotter.", "author": "olympus223", "description": "Plots an implicit function. There is still some work to be done, sharp edges don't get rendered correctly.", "tags": ["2d", "function", "plot", "implicit", "plotter"], "likes": 3, "viewed": 139, "published": "Public", "date": "1531048856", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const float PI = 3.141592;\nconst float TWOPI = 6.283184;\nconst float eps = 0.005;\nconst float scale = 15.0;\nconst float speed = 5.0;\nconst float thickness = 0.1;\n\n// Color values\nfloat hue = 0.0;\nfloat saturation = 1.0;\nfloat brightness = 0.0;\n\nfloat map(float x, float in_min, float in_max, float out_min, float out_max) {\n  return (x - in_min) * (out_max - out_min) / (in_max - in_min) + out_min;\n}\n   \nfloat f(float x, float y) { \n    //return sin(x+iTime)-y;\n\treturn sin(x + sin(y + y * sin(x + iTime)));\n    //return mod(y-sin(x), 1.0);\n    //return y - x;\n    //return sin(x-y-x*y+iTime)-y + sin(x + sin(y + y*sin(x + 2.0*iTime)));\n}\n\nfloat gx(float x, float y) {\n\tfloat dx = f(x + eps, y) - f(x - eps, y);\n    return dx / 2.0 / eps;              \n}\n\nfloat gy(float x, float y) {\n    float dy = f(x, y + eps) - f(x, y - eps);\n    return dy / 2.0 / eps;              \n}\n\nfloat dxy(float x, float y) {\n    float gx = gx(x, y);\n    float gy = gy(x, y);\n\treturn f(x, y) / sqrt(gx * gx + gy * gy);\n}\n\nfloat coverage(float dist, float radius) {\n\tradius *= 0.5;\n\treturn 1.0 - smoothstep(floor(radius), radius, dist);\n}\n\n\nbool eq(float v, float e, float eps) {\n    return v > e - eps && v < e + eps;\n}\n\nvec3 hsb_rgb(vec3 color) {\n    const vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(color.xxx + K.xyz) * 6.0 - K.www);\n    return color.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), color.y);\n}\n\nvoid drawFunction(float x, float y) {\n\tfloat dxy = dxy(x, y);\n    if (eq(dxy, 0.0, thickness)) {\n    \thue = map(x + iTime, -scale / 2.0, scale / 2.0, 0.0, 1.0);\n    \tbrightness = coverage(dxy, thickness) - 0.2;\n    \tsaturation = 1.0;        \n        /*if (eq(x,sin(iTime) * scale / 2.2,1.0)) {\n            brightness += 0.2;   \n        }*/\n    } \n}\n\nvoid taylor(float x0, float y0) {\n    float f = f(x0, y0);\n    float df = -gx(x0, y0) / gy(x0, y0);\n    \n}\n\nvoid line(float x, float y, float x0, float y0, float dxdy) {\n\tfloat f = y0 + dxdy * (x - x0) - y;   \n    float dxy =  f / sqrt(1.0 + dxdy * dxdy);\n\n    if (eq(dxy, 0.0, thickness)) {\n    \thue = map(x + iTime, -scale / 2.0, scale / 2.0, 0.0, 1.0);\n    \tbrightness = coverage(dxy, thickness) - 0.2;\n    \tsaturation = 1.0;        \n    } \n}\n\nvoid circle(float x, float y, float x0, float y0, float r) {\n    if (eq((x - x0) * (x - x0) + (y - y0) * (y - y0), 0.0, r)) {\n    \tbrightness = 1.0;\n    \tsaturation = 0.0;        \n    } \n}\n\nvoid drawAxes(float x, float y) {\n    float axesThickness = 0.02;\n    if (\n        eq(x, 0.0, axesThickness) ||\n        eq(y, 0.0, axesThickness) ||\n        eq(x * x + y * y, 0.0, axesThickness) ||\n        (eq(mod(x, 1.0), 0.0, axesThickness) && eq(y, 0.0, 6.0 * axesThickness)) ||\n        (eq(mod(y, 1.0), 0.0, axesThickness) && eq(x, 0.0, 6.0 * axesThickness))\n    ) {\n    \tbrightness = 1.0;\n        saturation = 0.0;\n    }\n}\n                   \nvoid mainImage( out vec4 fragColor, in vec2 fragCoord) {\n    \n    // Remap coordinates\n    vec2 uv = fragCoord / iResolution.xy;\n   \tfloat aspect = iResolution.y / iResolution.x;\n    float x = (uv.x - 0.5) * scale;\n    float y = (uv.y - 0.5) * scale * aspect;\n    \n    // Draw axes\n    drawAxes(x, y);\n    \n    // Draw function\n    float x0 = 0.0;\n    float y0 = sin(iTime);\n    drawFunction(x, y);\n    \n    /*float g = 1.0;\n    hue = map(mod(abs(f(x, y)), g), 0.0, g, 0.0, 1.0);\n    brightness = 1.0;*/\n    \n\tfragColor = vec4(hsb_rgb(vec3(hue, saturation, brightness)), 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XdyfDm.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[163, 245, 323, 323, 400], [405, 405, 432, 462, 639], [641, 641, 669, 669, 755], [757, 757, 785, 785, 874], [876, 876, 905, 905, 1000], [1002, 1002, 1044, 1044, 1117], [1120, 1120, 1158, 1158, 1199], [1201, 1201, 1227, 1227, 1414], [1416, 1416, 1453, 1453, 1764], [1766, 1766, 1799, 1799, 1872], [1874, 1874, 1935, 1935, 2211], [2213, 2213, 2273, 2273, 2401], [2403, 2403, 2436, 2436, 2830], [2851, 2851, 2907, 2937, 3429]], "test": "untested"}
{"id": "Xl3cDn", "name": "Prehistoric", "author": "yoyobbi", "description": "Still learning about shadertoy, inputs, etc.", "tags": ["greenscreen", "sepia", "filmgrain"], "likes": 2, "viewed": 294, "published": "Public", "date": "1532131354", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Readbackground and foreground images.\n    vec3 bg = texture(iChannel0, uv).rgb;\n    vec3 fg = texture(iChannel1, uv).rgb;\n\n    // Foreground ghosting.\n    const float ghostliness = 0.2;\n    fg = mix(fg, bg, ghostliness);\n    \n    // Greenscreen mask.\n\tfloat ref = fg.r;\n\tif(ref < fg.b) ref = fg.b;\n\tfloat amask = fg.g - ref;\n\tamask = smoothstep(0.1,0.2,amask);\n    \n    // Apply mask.\n    vec3 col = mix(fg, bg, amask);\n\n    // Sepia tone, from\n    // https://www.techrepublic.com/blog/how-do-i/how-do-i-convert-images-to-grayscale-and-sepia-tone-using-c\n\tvec3 sepia = vec3(\n        col.r * .393 + col.g *.769 + col.b * .189,\n        col.r * .349 + col.g *.686 + col.b * .168,\n\t\tcol.r * .272 + col.g *.534 + col.b * .131);\n    \n    // Film grain, from\n    // https://www.reddit.com/r/opengl/comments/1rr4fy/any_good_ways_of_generating_film_grain_noise\n    const float noiseStrength = 50.0;\n    float x = (uv.x + 4.0) * (uv.y + 4.0) * (iTime * 10.0);\n    vec3 grain = vec3(mod((mod(x, 13.0) + 1.0) * (mod(x, 123.0) + 1.0), 0.01) - 0.005) * noiseStrength;\n\n    // This one is optional, it makes a small \"tear\" every now and then\n    //if(mod(time, 100) > 98 && mod(texcoord.y, 10) > 7) grain = vec3(-3.0, -3.0, -3.0);\n    \n    // Output to screen\n    fragColor = vec4(sepia+grain,1.0);\n}", "image_inputs": [{"id": "4dfGRn", "previewfilepath": "/media/ap/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture"}, {"id": "XdXGzn", "previewfilepath": "/media/ap/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png", "ctype": "texture"}, {"id": "XdfGRr", "previewfilepath": "/media/ap/35c87bcb8d7af24c54d41122dadb619dd920646a0bd0e477e7bdc6d12876df17.webm", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/35c87bcb8d7af24c54d41122dadb619dd920646a0bd0e477e7bdc6d12876df17.webm", "ctype": "video"}, {"id": "MdjXRt", "previewfilepath": "https://soundcloud.com/drikounet/flying-in-my-dreams", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0, "src": "https://soundcloud.com/drikounet/flying-in-my-dreams", "ctype": "musicstream"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Xl3cDn.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 107, 1441]], "test": "untested"}
{"id": "Xl3cWM", "name": "Glowing Blocks", "author": "Shane", "description": "Applying some volumetric glow to a scene full of random blocky objects, just for the fun of it. Nothing that hasn't been tried before.", "tags": ["random", "volumetric", "glow", "block"], "likes": 27, "viewed": 1109, "published": "Public API", "date": "1532786300", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/*\n\n\tGlowing Blocks\n\t--------------\n\n\tApplying some volumetric glow to a scene full of random blocky objects, just for the \n\tfun of it. Nothing that hasn't been tried before.\n\n\tI'm not even sure what this is supposed to represent. I was experimenting with cheapish \n\tglow using a backlit point light, then boredom set in. Anyway, back to what I was \n\tsupposed to be coding. :) \n\n\tBy the way, uncommenting the defines \"NO_XY_ROTATION\" and \"NO_GLOW\" gives an abstract\n\tcity block appearance. At some stage, I plan to write an example that expands on that.\n\n\n\tRelated:\n\n\t// I was more focused on producing some abstract glow, but at some stage, \n    // I'd like to make a 3D version of the shader below:\n\tFavela - duvengar\n\thttps://www.shadertoy.com/view/ldGcDh\n\n*/\n\n// DIRECTIVES\n\n// The following defines enable you to change the characteristics of the scene. I prefer\n// the cleaner non-glowing look, but that'd defeat the purpose of the example. :)\n\n// Takes out the cell object rotaion, which gives it more of an abstract city block look.\n//#define NO_XY_ROTATION\n\n// Takes out the glow to focus more on the geometry.\n// Values: No glow - 0, Fiery glow - 1, Cool glow - 2.\n#define GLOW 1\n\n// Just in case the grungy texturing is too busy for your eyes, here's a cleaner look. :)\n//#define NO_TEXTURE\n\n// If you prefer circles.\n//#define DO_CIRCLES\n\n\n// Far plane.\n#define FAR 25.\n\n\n// Standard 2D rotation formula.\nmat2 r2(in float a){ float c = cos(a), s = sin(a); return mat2(c, s, -s, c); }\n\n// vec2 to vec2 hash. Cheap version using an oldschool trick. Not super trustworthy,\n// but it works well enough in a lot of situations.\nvec2 hash22(vec2 p){ \n    \n    float n = sin(dot(p, vec2(111, 157)));    \n    return fract(vec2(262144, 32768)*n); \n}\n\n// vec3 to float hash.\nfloat hash31(vec3 p){\n   \n    float n = dot(p, vec3(13.163, 157.247, 7.951)); \n    return fract(sin(n)*43758.5453); \n}\n\n\n// Tri-Planar blending function. Based on an old Nvidia tutorial by Ryan Geiss.\nvec3 tex3D( sampler2D t, in vec3 p, in vec3 n ){ \n    \n    n = max(abs(n) - .1, 0.001);\n    n /= dot(n, vec3(1));\n\tvec3 tx = texture(t, p.yz).xyz;\n    vec3 ty = texture(t, p.zx).xyz;\n    vec3 tz = texture(t, p.xy).xyz;\n    \n    // Textures are stored in sRGB (I think), so you have to convert them to linear space \n    // (squaring is a rough approximation) prior to working with them... or something like that. :)\n    // Once the final color value is gamma corrected, you should see correct looking colors.\n    return (tx*tx*n.x + ty*ty*n.y + tz*tz*n.z);\n}\n\n/*\n// Texture bump mapping. Four tri-planar lookups, or 12 texture lookups in total.\nvec3 texBump( sampler2D tx, in vec3 p, in vec3 n, float bf){\n   \n    const vec2 e = vec2(.001, 0);\n    \n    // Three gradient vectors rolled into a matrix, constructed with offset greyscale texture values.    \n    mat3 m = mat3( tex3D(tx, p - e.xyy, n), tex3D(tx, p - e.yxy, n), tex3D(tx, p - e.yyx, n));\n    \n    vec3 g = vec3(.299, .587, .114)*m; // Converting to greyscale.\n    g = (g - dot(tex3D(tx,  p , n), vec3(0.299, 0.587, 0.114)) )/e.x; g -= n*dot(n, g);\n                      \n    return normalize( n + g*bf ); // Bumped normal. \"bf\" - bump factor.\n\t\n}\n*/\n\n\n// IQ's 3D signed box formula: I tried saving calculations by using the unsigned one, and\n// couldn't figure out why the edges and a few other things weren't working. It was because\n// functions that rely on signs require signed distance fields... Who would have guessed? :D\nfloat sBox(vec3 p, vec3 b){\n\n  vec3 d = abs(p) - b;\n  return min(max(d.x, max(d.y, d.z)), 0.) + length(max(d, 0.));\n}\n\n// IQ's 2D signed box formula.\nfloat sBox(vec2 p, vec2 b){\n\n  vec2 d = abs(p) - b;\n  return min(max(d.x, d.y), 0.) + length(max(d, 0.));\n}\n\n//vec2 objID;\n\n// ID for inner or outer frame.\nvec2 oID;\n\n// The overlapping random block distance field: In order to render repeat objects that either\n// sit up against one another, or slightly overlap, you have to render more than one cell to\n// avoid artifacts. In this case, I've rendered some repeat boxy objects across the XY plane\n// with random heights. Four cells need to be considered, which means rendering everything\n// four times. This would be better unrolled, tweaked, etc, but I think it reads a little \n// better this way. Anyway, I've explained the process in other examples, like the \"Jigsaw\"\n// example, and so forth.\n\nfloat m(vec3 p){\n\n    // Warp the XY plane a bit to give the scene an undulated look.\n    p.z -= 3. + sin(p.x + p.y)*.125;\n    \n    // Box scale. If you change this, you might need to make box size changes, etc.\n    const float sc = .5;\n    \n    // Cell centering.\n    p += sc*.5;\n    \n    // The initial distance. I can't remember why I wanted this smallish amount. Usually, \n    // you'd set it to some large number.\n    float d = 0.25;\n    \n    //objID = vec2(0);\n    oID = vec2(0);\n    \n    for (int i=0; i<=1; i++){ \n        for (int j=0; j<=1; j++){ \n\n            // The cell ID.\n            vec2 ip = floor((p.xy/sc - vec2(i, j)/2.))*sc + vec2(i, j)/2.*sc;\n            // Local cell position. I remember figuring these out a while\n            // back... I'll take my own word for it. :D\n            vec3 q = vec3((mod(p.xy + vec2(i, j)/2.*sc, sc) - sc/2.), p.z);\n\n            // Two random numbers for each cell... to do some random stuff. :)\n            vec2 rnd = hash22(ip);\n\n            #ifndef NO_XY_ROTATION\n            // Random object rotation about the XY plane.\n            q.xy *= r2((dot(rnd.xy, vec2(.5)) - .5)*6.2831*.15);\n            #endif\n\n            // Another random number to be used for the heights.\n            rnd.x = fract(dot(rnd, vec2(27, 57)))*.25 + .375;\n            // Quantizing the heights -- Not absolutely necessary, but it makes things\n            // look a little neater.\n            rnd.x = floor(rnd.x*25.999)/25.; \n\n            // Also not that necessary, but it shifts the base of the objects to a level\n            // point... that is behind the scene, which means you can't see it... but I\n            // know it's there, and without this line the hidden backwall wouldn't be flat. :D\n            q -= vec3(0, 0, -rnd.x);\n\n            #ifndef DO_CIRCLES\n            // The box objects. I'm using IQ's more expensive functions, just because I need\n            // the distance fields to be more correct away from the centers to get more even\n            // looking glow.\n            float obj = sBox(q, vec3(sc/4. + .05, sc/4. + .05, rnd.x - .005)); // Outer box casing.\n            float obj2 = sBox(q, vec3(sc/4. + .01, sc/4. + .01, rnd.x)); // Inner box.\n            // Four window-like objects.\n            q.xy = abs(abs(q.xy) - .055);\n            float obj2D = sBox(q.xy, vec2(sc/4., sc/4.));\n            #else\n            // Alternative circles.\n            float obj = max(length(q.xy) - (sc/4. + .06), abs(q.z) - rnd.x + .005); // Outer.\n            float obj2 = max(length(q.xy) - (sc/4. + .02), abs(q.z) - rnd.x); // Inner.\n            q.xy = abs(abs(q.xy) - .05);\n            float obj2D = length(q.xy) - sc/4.;\n\t\t\t#endif\n            \n            \n            \n            // Combine the inner and outer boxex, then carve out the windows.\n            float obj3D = max(min(obj, obj2), -(obj2D + .0975)); \n            \n            oID = (obj3D<d)? vec2(obj, obj2) : oID; // ID for inner or outer frame.\n\n\t\t\t// Individual object ID. Not used here.\n            //objID = (obj<d)? ip : objID;\n\n            // Minimum of the four cell objects. Similar to the way Voronoi cells are handled.\n            d = min(d, obj3D);\n\n\n        }\n\t}\n  \n    \n    // Return the scene distance, and include a bit of ray shortening to avoid a few minor\n    // inconsistancies.\n    return d*.85;\n    \n}\n\n\n\n\n// Basic soft shadows.\nfloat shd(in vec3 ro, in vec3 n, in vec3 lp){\n\n    const float eps = .001;\n    \n\tfloat t = 0., shadow = 1., dt;\n    \n    ro += n*eps*1.1;\n    \n    vec3 ld = (lp - ro);\n    float lDist = length(ld);\n    ld /= lDist;\n    \n    \n    //t += hash31(ro + ld)*.005;\n    \n\tfor(int i=0; i<24; i++){\n        \n    \tdt = m(ro + ld*t);\n        \n        shadow = min(shadow, 16.*dt/t);\n         \n \t\tt += clamp(dt, .01, .25);\n        if(dt<0. || t>lDist){ break; } \n\t}\n\n\n    return max(shadow, 0.);\n    \n}\n\n// Ambient occlusion, for that self shadowed look.\n// Based on the original by IQ.\nfloat cao(in vec3 p, in vec3 n)\n{\n\tfloat sca = 1., occ = 0.0;\n    for( int i=1; i<6; i++ ){\n    \n        float hr = float(i)*.25/5.;        \n        float dd = m(p + hr*n);\n        occ += (hr - dd)*sca;\n        sca *= .7;\n    }\n    return clamp(1. - occ, 0., 1.);   \n    \n}\n\n/*\n// Standard normal function.\nvec3 nr(in vec3 p) {\n\tconst vec2 e = vec2(0.001, 0);\n\treturn normalize(vec3(m(p + e.xyy) - m(p - e.xyy), m(p + e.yxy) - m(p - e.yxy),\tm(p + e.yyx) - m(p - e.yyx)));\n}\n*/\n\n// Normal calculation, with some edging and curvature bundled in.\nvec3 nr(vec3 p, inout float edge, inout float crv, float t) { \n\t\n    // It's worth looking into using a fixed epsilon versus using an epsilon value that\n    // varies with resolution. Each affects the look in different ways. Here, I'm using\n    // a mixture. I want the lines to be thicker at larger resolutions, but not too thick.\n    // As for accounting for PPI; There's not a lot I can do about that.\n    vec2 e = vec2(3./mix(450., min(850., iResolution.y), .35), 0);//*(1. + t*t*.7);\n\n\tfloat d1 = m(p + e.xyy), d2 = m(p - e.xyy);\n\tfloat d3 = m(p + e.yxy), d4 = m(p - e.yxy);\n\tfloat d5 = m(p + e.yyx), d6 = m(p - e.yyx);\n\tfloat d = m(p)*2.;\n\n    edge = abs(d1 + d2 - d) + abs(d3 + d4 - d) + abs(d5 + d6 - d);\n    //edge = abs(d1 + d2 + d3 + d4 + d5 + d6 - d*3.);\n    edge = smoothstep(0., 1., sqrt(edge/e.x*2.));\n/*    \n    // Wider sample spread for the curvature.\n    e = vec2(12./450., 0);\n\td1 = m(p + e.xyy), d2 = m(p - e.xyy);\n\td3 = m(p + e.yxy), d4 = m(p - e.yxy);\n\td5 = m(p + e.yyx), d6 = m(p - e.yyx);\n    crv = clamp((d1 + d2 + d3 + d4 + d5 + d6 - d*3.)*32. + .5, 0., 1.);\n*/\n    \n    e = vec2(.001, 0); //iResolution.y - Depending how you want different resolutions to look.\n\td1 = m(p + e.xyy), d2 = m(p - e.xyy);\n\td3 = m(p + e.yxy), d4 = m(p - e.yxy);\n\td5 = m(p + e.yyx), d6 = m(p - e.yyx);\n\t\n    return normalize(vec3(d1 - d2, d3 - d4, d5 - d6));\n}\n\n// More concise, self contained version of IQ's original 3D noise function.\nfloat noise3D(in vec3 p){\n    \n    // Just some random figures, analogous to stride. You can change this, if you want.\n\tconst vec3 s = vec3(113, 157, 1);\n\t\n\tvec3 ip = floor(p); // Unique unit cell ID.\n    \n    // Setting up the stride vector for randomization and interpolation, kind of. \n    // All kinds of shortcuts are taken here. Refer to IQ's original formula.\n    vec4 h = vec4(0., s.yz, s.y + s.z) + dot(ip, s);\n    \n\tp -= ip; // Cell's fractional component.\n\t\n    // A bit of cubic smoothing, to give the noise that rounded look.\n    p = p*p*(3. - 2.*p);\n    \n    // Standard 3D noise stuff. Retrieving 8 random scalar values for each cube corner,\n    // then interpolating along X. There are countless ways to randomize, but this is\n    // the way most are familar with: fract(sin(x)*largeNumber).\n    h = mix(fract(sin(h)*43758.5453), fract(sin(h + s.x)*43758.5453), p.x);\n\t\n    // Interpolating along Y.\n    h.xy = mix(h.xz, h.yw, p.y);\n    \n    // Interpolating along Z, and returning the 3D noise value.\n    float n = mix(h.x, h.y, p.z); // Range: [0, 1].\n\t\n    return n; //abs(n - .5)*2.;\n}\n\n\n\nvoid mainImage(out vec4 c, in vec2 u){\n\n    // Camera and ray setup -- Note the one-line unit direction ray setup. Coyote\n    // noticed that. The front light is there too.\n    vec3 r = normalize(vec3(u - iResolution.xy*.5, iResolution.y)), \n         o = vec3( iTime*.5, iTime*.5/12.*1., 0), l = o + vec3(.5, 2., 0);\n    \n    // Tilt the scene along the YZ plane, ever so slightly.\n    r.yz *= r2(3.14159/24.);\n\n    // Ray marching... I should probalby put all this in its own function.\n    float d, t = 0.;\n    \n    // Glow. A point light is place behind the scene, it's attenuation is\n    // calculated at each point along the ray and accumulated. Pretty standard\n    // stuff. Although, most people just accumulate ray distance or scene distance\n    // values, whereas I prefer to accumulate the ray to light distance, just\n    // because I think it looks a little nicer. In this case, I'm also taking\n    // the more expensive step of smooth 3D noise attenuation to give the scene\n    // a fog-like variance.\n    float glow = 0.;\n    \n    // The second light offset. It's arranged to sit a few units back behind\n    // the scene.\n    vec3 l2Offs = vec3(.5, 1.5, 8);\n    // Counter rotating the second light direction to match the scene rotation.\n    l2Offs.yz *= r2(-3.14159/24.);\n    // The second light.\n    vec3 l2 = o + l2Offs;\n    \n    // Jittering the glow. If your glow is looking too bandy, try this.\n    // It doesn't always work, but tends to help in many instances.\n    t = hash31(r + fract(iTime));\n    \n    for(int i=0; i<80;i++){\n        \n        vec3 pp = o + r*t;\n        d = m(pp);\n        \n        \n        #if GLOW > 0\n        // Ray position to point light distance.\n        // Point-light-based glow.\n        float l2D = length(l2 - pp); //4./(1. + d*d);//\n        // Distance based falloff.\n        //float aD = abs(d);\n        //if(aD<.15) glow += 1.*(.15 - aD)/(.0001 + l2D*l2D);\n        // Accumulating the attenuation, whilst applying a little noise.\n        // There's a touch of animation as well to give the glow less of\n        // a static feel.\n        glow += .25/(.0001 + l2D)*noise3D(pp*6. + vec3(iTime, 0, iTime*.5));\n        #endif\n        \n        // The usual break conditions.\n        if(abs(d)<0.001 || t>FAR) break;\n        t += d;\n    }\n    \n    t = min(t, FAR);\n\n    // Saving the object ID. Not used here.\n    //vec2 svObjID = objID;\n    \n    // Outer or inner box identification.\n    float svOID = oID.x < oID.y ? 0. : 1.;\n    \n    // Scene color initiation.s\n    vec3 col = vec3(0);\n    \n    if(t<FAR){\n    \n        // Hit point.\n        vec3 p = o + r*t;\n        //vec3 n = nr(p);\n        // Normal, plus edges and curvature. The latter isn't used.\n        float edge = 0., crv = 1.;\n        vec3 n = nr(p, edge, crv, t);\n        \n        // Texture scale.\n        const float sz0 = 1./1.;\n        // No bump mapping -- I didn't think it added value to the scene.\n        //n = texBump(iChannel0, p*sz0, n, .005);///(1. + t/FAR)\n        \n        float sh = shd(p, n, l);\n        float ao = cao(p, n);\n        sh = min(sh + ao*.2, 1.);\n        \n        \n\n        l -= p; // Light to surface vector. Ie: Light direction vector.\n        d = max(length(l), 0.001); // Light to surface distance.\n        l /= d; // Normalizing the light direction vector.\n        \n        /////\n        // The second light behind the scene.\n        l2 -= p; // Light to surface vector. Ie: Light direction vector.\n        float d2 = max(length(l2), 0.001); // Light to surface distance.\n        l2 /= d2; // Normalizing the light direction vector.\n        float diff2 = max(dot(l2, n), 0.);\n        diff2 = pow(diff2, 4.)*2.;\n        float spec2 = pow(max(dot(reflect(l2, n), r), 0.), 32.);\n        /////\n        \n        // Object color. I applied some sporadic blue pathches, for whateverr eason. \n        // I thought the object facades looked a little too grey without it.\n        float pat = dot(sin(p*6. + cos(p.yzx*6.)), vec3(.166)) + .5;\n        pat = smoothstep(0., .25, pat - .65);\n        vec3 oCol = mix(vec3(1), vec3(2, 3, 8), pat);\n        \n        // Adding a bit of grunge. I thought a grungy facade suited the scene a little\n        // better... Plus, it's a good way to hide poor coding inconsitancies. :)\n       \n        #ifndef NO_TEXTURE\n        vec3 tx = tex3D(iChannel0, p*sz0, n);\n        tx = smoothstep(.0, .7, tx);\n        #else\n        // Some subtle noise. Less grungy, so looks a bit cleaner.\n        vec3 tx = mix(vec3(.28), vec3(.18), noise3D(p*64.)*.66 + noise3D(p*128.)*.34);\n        if(svOID < .5) tx *= 1.15;\n        #endif\n        \n        #if GLOW == 0\n        if(svOID > .5) oCol *= tx*tx*1.5;\n        else oCol *= tx*sqrt(tx)*4.; // Brighten up the outer frames.\n        #else \n        if(svOID > .5) oCol *= tx;\n        else oCol *= sqrt(tx)*1.5; // Brighten up the outer frames.\n        #endif\n        \n        \n\n        \n        float diff = max(dot(l, n), 0.); // Diffuse. \n        diff = pow(diff, 4.)*2.; // Ramping up the diffuse.\n        float spec = pow(max(dot(reflect(l, n), r), 0.), 32.); // Specular.\n        \n\t\t// Schlick approximation. I use it to tone down the specular term. It's pretty subtle,\n        // so could almost be aproximated by a constant, but I prefer it. Here, it's being\n        // used to give a sandstone consistency... It \"kind of\" works.\n\t\tfloat Schlick = pow(1. - max(dot(r, normalize(r + l)), 0.), 5.);\n\t\tfloat fre2 = mix(.5, 1., Schlick);        \n        \n        // Scene color for light one.\n        col = (oCol*(diff + .25) + vec3(.5, .7, 1)*spec*fre2*2.)*1./(1. + d*.25);\n        \n        // Scene color for light two. The effects are a little hidden by the overwhelming\n        // glow, but the specular highlights accentuate the backlit effect. Comment it out\n        // to see what I mean.\n        vec3 sCol = pow(vec3(1, 1, 1)*spec2, vec3(1, 2, 4)*2.);\n        col += (oCol*(diff2 + .0) + sCol*4.)*1./(1. + d2*.25);\n        \n        \n        // Applying the edges.\n        col *= 1. - edge*.8;\n        \n        // Applying the ambient occlusion and shadows.\n        col *= ao*sh;\n        \n        \n    }\n    \n    \n    #if GLOW > 0    \n    // Applying a fiery palatte to the glow\n    vec3 glowCol = pow(vec3(1.5, 1, 1)*glow, vec3(1, 2.75, 8));\n    // Blue glow.\n    if(GLOW == 2) glowCol = glowCol.zyx;\n    // Adding the glow to the scene. Not that it's applied outsite the the object coloring\n    // block because we need to add the glow to the empty spaces as well. When I haven't applied\n    // glow for a while, I tend to forget this. :)\n    col += glowCol*1.5 + glowCol*glowCol*1.5;\n    \n    // The fiery red is a little overwhelming, so this tones it down a bit.\n    col = mix(col, col.zyx, max(-r.y*.25 + .1, 0.));\n    #endif\n   \n    // Subtle vignette.\n    u /= iResolution.xy;\n    col *= pow(16.*u.x*u.y*(1. - u.x)*(1. - u.y) , .0625);\n    // Colored variation.\n    //col = mix(col.zyx/2., col, pow(16.*u.x*u.y*(1. - u.x)*(1. - u.y) , .125));\n\n    \n    // Rough gamma correction: The top 5 things graphics programmers forget to do. You will be \n    // shocked when you see item number 3. :D\n    //\n    // For anyone doubting the need to gamma correct, create a red to green linear gradient \n    // across the screen horizontal, gamma correct the top half only, then compare.\n    c = vec4(sqrt(max(col, 0.)), 1.);\n    \n    \n}", "image_inputs": [{"id": "4sXGRn", "previewfilepath": "/media/ap/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Xl3cWM.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1384, 1417, 1437, 1437, 1495], [1497, 1634, 1654, 1654, 1751], [1753, 1776, 1797, 1797, 1894], [1897, 1977, 2025, 2025, 2534], [3190, 3465, 3492, 3492, 3582], [3584, 3615, 3642, 3642, 3722], [3782, 4363, 4379, 4448, 7700], [7705, 7728, 7773, 7773, 8217], [8219, 8302, 8335, 8335, 8575], [8780, 8846, 8907, 9250, 10210], [10212, 10288, 10313, 10406, 11393], [11397, 11397, 11435, 11569, 18745]], "test": "untested"}
{"id": "Xl3yRr", "name": "Egg rolls", "author": "therealbnut", "description": "Concentric eggs rolling around, kinda looks like a 3d nozzle. I saw this online somewhere, and decided to replicate it in a shader. I can't remember where I first saw it, the most recent time was this:\nhttps://twitter.com/DennysDiner/status/1008785199818", "tags": ["egg", "roll"], "likes": 6, "viewed": 113, "published": "Public", "date": "1531196136", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const float K = 7.0;\nconst float L = 1.4;\nconst float M = 1.5;\n\nfloat egg(vec2 pos) {\n\tvec2 p = pos * vec2(pow(pos.y/(L*K)+1.0,M), 1.0/L);\n\treturn length(2.0 * p) - 1.0;\n}\nfloat transformedEgg(vec2 pos, vec3 t) {\n\treturn egg(pos / t.z - t.xy) * t.z;\n}\nvec2 eggOffset(float t) {\n    float s = sin(t);\n    float c = cos(t);\n    return vec2(c * pow(K / (s + K), M), s * L);\n}\n\nfloat fill(float x, float f) {\n    return clamp(x/f, 0.0, 1.0);\n}\nfloat stroke(float x, float f, float p) {\n    return fill(x + f * p, p) - fill(x - f * p, p);\n}\n\n// TODO: Egg distance function without axis bias\n// TODO: Precision offsets to take into account line width\n// TODO: Create the number of eggs in a loop.\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = 2.0 * fragCoord/iResolution.xy - 1.0;\n    vec2 sc = max(vec2(iResolution.x / iResolution.y,\n                       iResolution.y / iResolution.x),1.0);\n    uv *= sc;\n    vec2 df = 2.0 * sc / iResolution.xy;\n    float pw = length(df);\n    \n    float t = iTime * 4.0;\n    \n    vec3 a = vec3(0.0, 0.0, 1.0);\n    vec3 d = vec3(a.xy + eggOffset(t) * (0.240 * a.z), 0.65);\n    vec3 g = vec3(0.0, 0.0, 0.30);\n\n    vec3 b = mix(a, d, 0.33333);\n    vec3 c = mix(a, d, 0.66666);\n    vec3 e = mix(d, g, 0.33333);\n    vec3 f = mix(d, g, 0.66666);;\n\n    \n    float intensity = 0.0;\n    \n    intensity = max(intensity, stroke(transformedEgg(uv, a), 2.0, pw));\n    intensity = max(intensity, stroke(transformedEgg(uv, b), 2.0, pw));\n    intensity = max(intensity, stroke(transformedEgg(uv, c), 2.0, pw));\n    intensity = max(intensity, stroke(transformedEgg(uv, d), 2.0, pw));\n    intensity = max(intensity, stroke(transformedEgg(uv, e), 2.0, pw));\n    intensity = max(intensity, stroke(transformedEgg(uv, f), 2.0, pw));\n    intensity = max(intensity, stroke(transformedEgg(uv, g), 2.0, pw));\n\n    // Output to screen\n    fragColor = vec4(vec3(1) * (1.0 - intensity),1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Xl3yRr.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[64, 64, 85, 85, 171], [172, 172, 212, 212, 251], [252, 252, 277, 277, 372], [374, 374, 404, 404, 439], [440, 440, 481, 481, 535], [537, 692, 749, 749, 1923]], "test": "untested"}
{"id": "Xl3yWr", "name": "Gradation+noise.", "author": "gyabo", "description": "Gradation+noise.", "tags": ["noise", "gradation"], "likes": 2, "viewed": 139, "published": "Public", "date": "1532137257", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define LINEWIDTH (2.0 / iResolution.x)\n#define NOISEGAIN (1.0 / 256.0)\n#define RAND_MULT_PHASE 10.0\n\n\n//#define USE_MOUSE\n//#define USE_TEXTURE_NOISE\n\n#ifdef USE_TEXTURE_NOISE\nfloat rand(vec2 n) { \n\treturn texture(iChannel0, n).x;\n}\n#else //USE_TEXTURE_NOISE\nfloat rand(vec2 n) { \n\treturn fract(sin(dot(n, vec2(12.9898, 4.1))) * 43758.53);\n}\n#endif //USE_TEXTURE_NOISE\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\tvec2 uv = ( fragCoord / iResolution.xy ) * 2.0 - 1.0;\n    vec2 auv = uv * vec2(1.0, iResolution.y /  iResolution.x);\n\tvec3 basecol0 = vec3(1.0,0.1,1.0 * sin(iTime)) * 0.5;\n\tvec3 basecol1 = vec3(0.1,0.0,1.0) * 0.5;\n\n\tfloat rk = 0.0;\n\t\n    float xoffset = uv.x;\n#ifdef USE_MOUSE\n    xoffset +=  -(iMouse.x / iResolution.x) * 2.0 + 1.0;\n#endif //USE_MOUSE\n\tif(xoffset > 0.0) {\n        rk = rand(auv + iTime) * 2.0 - 1.0;\n\t}\n\t\n\tif(abs(xoffset) < LINEWIDTH) {\n\t\tfragColor.xyz = vec3(1.0);\n\t\tfragColor.a = 1.0;\n\t\treturn;\n\t}\n    float ky = 1.0 - (uv.y + rk * NOISEGAIN);\n\tvec3 col = pow(mix(basecol0, basecol1, ky), vec3(1.0 / 5.0));\n    //vec3 col = vec3(rk);\n\tfragColor = vec4(col, 1.0);\n}\n", "image_inputs": [{"id": "XsBSR3", "previewfilepath": "/media/ap/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Xl3yWr.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[350, 371, 428, 428, 1114]], "test": "untested"}
{"id": "Xl3yzM", "name": "Fundamental fractal", "author": "WingStone", "description": "reference : http://www.iquilezles.org/www/articles/distancefractals/distancefractals.htm\nhttp://math.unipa.it/~grim/Jbarrallo.PDF\n", "tags": ["fractal"], "likes": 4, "viewed": 417, "published": "Public API", "date": "1532095990", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//Select different preprocessing to get different effect\n\n//#define MANDELBROT_Distance\n//#define JULIA_Distance\n//#define JULIA_ANGLE\n//#define JULIA_GradientAngle\n//#define JULIA_Trap\n#define JULIA_Flower\n\n\nvec2 complexMul(vec2 c1, vec2 c2)\n{\n    return vec2(c1.x*c2.x - c1.y*c2.y, c1.x*c2.y+c1.y*c2.x);\n}\n\nvec2 complexDev(vec2 c1, vec2 c2)\n{\n    float len2 = c2.x*c2.x+c2.y*c2.y;\n    return vec2((c1.x*c2.x + c1.y*c2.y)/len2, (c1.y*c2.x-c1.x*c2.y)/len2);\n}\n\nvec3 getJuliaFlower(vec2 uv)\n{\n    float n = 13.0, m = 18.0;\n    //vec2 c =iMouse.xy/iResolution.y; //using mouse set \"c\"\n    vec2 c = vec2(cos(0.025*n*iTime), sin(0.025*m*iTime));\t//using time set \"c\"\n    vec2 z = uv;\n    vec2 polarZ;\n    float dist;\n    for(int i = 0; i < 32; i++)\n    {\n        z = complexMul(z,z)+ c;\n        \n        if(length(z) >128.0)\n        {\n            dist = 1.0;\n            break;\n        }\n        \n        //polar coordinate\n        vec2 nearPoint = round(z);\n        vec2 zToNear = z - nearPoint;\n        polarZ.x = length(zToNear);\n        polarZ.y = atan(zToNear.y, zToNear.x);\n        \n        polarZ.y += iTime*1.5;\n        \n        //sakura trap\n        float tmp = cos(polarZ.y*5.)*0.4;\n        tmp -= tmp>0.? 0.5/(cos(polarZ.y*5.)+abs(10.0*sin(polarZ.y*5.))) : 0.0;\n        dist = polarZ.x - sqrt(0.6 + tmp )*0.3;\n        if(dist <= 0.0)\t//enter the trap\n        {\n            break;\n        }\n    }\n   \n\n    \n    \n    vec3 color = mix(vec3(0.95,0.85,0.4), vec3(0.95,0.5,0.5), smoothstep(0.01, 0.05,polarZ.x));\n    color = mix( color, vec3(0.95,0.7,0.7), smoothstep(0.05, 0.25,polarZ.x));\n    color = mix( color, vec3(1.0,0.8,0.8), smoothstep(-0.03, 0.0,dist));\n    color =  dist <= 0.0 ? color : vec3(0.95,0.90,0.9);\n    return color;\n}\n\n//Mandelbrot use distance, this reference is https://www.shadertoy.com/view/lsX3W4\nvec3 getMandelbrotColor(vec2 uv)\n{\n    float scale = 0.25*(0.6 + 0.5*sin(iTime*0.1));\n    vec2 c = uv*scale+vec2(-0.05,.6805);\n    vec2 z = vec2(0.0,0.0);\n    vec2 dz = vec2(0.0, 0.0);\n    for(int i = 0; i < 1024; i++)\n    {\n        dz = 2.0*vec2(z.x*dz.x - z.y*dz.y, z.x*dz.y + z.y*dz.x) + vec2(1.0,.0);\n        z = vec2(z.x*z.x - z.y*z.y, 2.0*z.x*z.y) + c;\n        if(dot(z,z) > 1024.0)\n            break;\n    }\n    \n    float lz = dot(z,z);\n    float dist = 0.5*log(lz)*sqrt(lz/dot(dz,dz));\n    vec3 col = vec3(1.0)*smoothstep(0.0,0.0035*scale,dist);\n    return col;\n}\n\nvec3 getJuliaColor(vec2 uv)\n{\n    float n = 13.0, m = 18.0;\n    vec2 c = vec2(cos(0.025*n*iTime), sin(0.025*m*iTime));\n    \n    vec2 z = uv;\n    vec2 dz = vec2(1.0);\n    \n    int ite = 0;\n    for(int i = 0; i < 128; i++)\n    {\n        dz = 2.0*complexMul(dz,z);\n        z = complexMul(z,z)+ c;\n        ite = i+1;\n        \n        #ifdef JULIA_Trap\n        vec2 nearPoint = round(z);\n        if(distance(z, nearPoint) <= 0.2)\t//enter the trap\n        {\n            ite = i;\n            break;\n        }\n        #else\n        if(dot(z,z) > 128.0)\n        {\n            ite = i;\n            break;\n        }\n        #endif\n    }\n   \n    vec3 color;\n    \n    #ifdef JULIA_Trap\n    vec2 nearPoint = round(z);\n    float len = distance(z, nearPoint);\n    color = vec3(sin(len*100.0)*0.5+0.5, cos(len*100.0)*0.5+0.5, 0.3);\n\t#endif\n    \n    #ifdef JULIA_GradientAngle\n    vec2 Gdz = complexDev(dz,z);\n    float angle = atan(Gdz.y,Gdz.x);\n    color = vec3(sin(angle*5.0)*0.5+0.5, cos(angle*5.0)*0.5+0.5, 0.3);\n\t#endif\n    \n    #ifdef JULIA_ANGLE\n    float angle = atan(z.y,z.x);\n    color = vec3(sin(angle*5.0)*0.5+0.5, cos(angle*5.0)*0.5+0.5, 0.3);\n\t#endif\n    \n    #ifdef JULIA_Distance\n    float lz = dot(z,z);\n    float dist = 0.5*log(lz)*sqrt(lz/dot(dz,dz));\n    color = vec3(sin(dist*10.0)*0.5+0.5, cos(dist*10.0)*0.5+0.5, 0.3);\n\t#endif\n    \n    #ifdef JULIA_Flower\n    float lz = dot(z,z);\n    float dist = 0.5*log(lz)*sqrt(lz/dot(dz,dz));\n    color = vec3(sin(dist*10.0)*0.5+0.5, cos(dist*10.0)*0.5+0.5, 0.3);\n\t#endif\n    \n    return color;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from -1 to 1)\n    vec2 uv = (fragCoord *2.0 - iResolution.xy)/iResolution.y;\n\n    #ifdef MANDELBROT_Distance\n    vec3 col = getMandelbrotColor(uv);\n    #else\n    \n    #ifdef JULIA_Flower\n    vec3 col = getJuliaFlower(uv);\n    #else\n    vec3 col = getJuliaColor(uv);\n\t#endif\n    \n    #endif\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Xl3yzM.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[58, 209, 244, 244, 307], [309, 309, 344, 344, 459], [461, 461, 491, 491, 1740], [1742, 1825, 1859, 1859, 2396], [2398, 2398, 2427, 2427, 3938], [3940, 3940, 3997, 4048, 4381]], "test": "untested"}
{"id": "XlccWH", "name": "[SH18] Rabbit Character", "author": "fizzer", "description": "I tried to create some kind of character using signed distance fields, and came up with this rabbit.\nThis wasn't originally an SH18, but I decided to put it in (actually I hadn't realised that there is a new competition happening until after I made it).", "tags": ["sdf", "cartoon", "character", "rabbit", "sh18"], "likes": 104, "viewed": 7044, "published": "Public", "date": "1532363205", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float time;\n\n// Polynomial smooth min (k = 0.1) (from IQ)\nfloat smin( float a, float b, float k )\n{\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\n\nfloat smax(float a,float b, float k)\n{\n    return -smin(-a,-b,k);\n}\n\nmat2 rotmat(float a)\n{\n    return mat2(cos(a),sin(a),-sin(a),cos(a));\n}\n\nfloat cylinder(vec3 p,vec3 dir,float h,float r)\n{\n    float t=dot(p,dir);\n    float d=distance(p,dir*t);\n    return length(max(abs(vec2(d,t))-vec2(r,h),vec2(0)));\n    d=max(d,-t);\n    d=max(d,t-h);\n    return d;\n}\n\nfloat pupdist=1e4;\n\nfloat rabdist(vec3 p)\n{\n    float an=.5*.5*2.*6. +iMouse.x/iResolution.x*6.;\n    p.xz=mat2(cos(an),sin(an),sin(an),-cos(an))*p.xz;\n    \n    float time2=time*2.4;\n\n    p.y+=2.3;\n    p.xy*=rotmat(cos(time2+1.)*.04);\n    p.y-=2.3;\n\n    vec3 op=p;\n\n    vec3 p2=p;\n    p2.xy*=rotmat(cos(time2)*.1);\n\n    vec3 p3=p;\n    p3.xy*=rotmat(cos(time2-.0-length(p)/2.)*.13);\n\n    float d=1e4;\n    p.x=abs(p.x);\n    p2.x=abs(p2.x);\n    p3.x=abs(p3.x);\n\n    d=smin(length(p2-vec3(-.75,0.,-.1))-.4,length(p2-vec3(.75,0.,-.1))-.5,2.);\n    d=smin(d,length(p2-vec3(0,0.4,-.1))-.9,1.6);\n    d+=.1;  \n    \n    // Ears 1\n    d=smin(d,distance(vec3(.7,clamp(p3.y,0.,2.2),0.),p3.xyz)-.4,.14);   \n    d=smax(d,-(length(p3-vec3(.7,1.7,-0.5))-.5),.2);\n\n    // Neck\n    d=smin(d,distance(vec3(0.,clamp(p.y,-1.6,-1.1),0.),p.xyz)-.6,.04);   \n    \n    // Legs\n    vec3 p4=op;\n    float ld=-.75;\n    p4.y-=ld;\n    p4.yz*=rotmat(cos(time*2.+3.1415926/1.*0.)*.1);\n    p4.y+=ld;\n    p4.y-=max(0.,cos(time*2.+3.1415926/2.))*.1;\n    d=smin(d,distance(vec3(.3,clamp(p4.y,-2.6,-2.),0.),p4.xyz)-.3,.1);\n    p4=op;\n    p4.y-=ld;\n    p4.yz*=rotmat(cos(time*2.+3.1415926/1.*1.)*.1);\n    p4.y+=ld;\n    p4.y-=max(0.,cos(time*2.+3.1415926/2.+3.1415926/1.*1.))*.1;\n    d=smin(d,distance(vec3(.3,clamp(p4.y,-2.6,-2.),0.),p4.xyz*vec3(-1,1,1))-.3,.1);   \n    \n    // Belly\n    d=smin(d,distance(vec3(0.,-1.5,-.2),p)-.5+cos(time*3.)*.03,.4);   \n\n    // Ears 2\n    d=smin(d,distance(vec3(1.1,2.3,-.1),p3)-.2,.8);   \n\n    // Tail\n    d=smin(d,distance(vec3(0,-1.7,.6),p)-.3,.1);   \n\n    vec3 q=vec3(0.35,.4,-1);\n\n    if(mod(time-1.,4.)>.04)\n    {\n        d=smax(d,-(cylinder(p2-q,normalize(q-p2),.3,.1)-.0001),.05);\n        d=smin(d,(length(p2-q*.9)-.2),.24);\n\n        // Eye pupils\n        if(op.x>0.)\n            pupdist=(length(p2-vec3(.39,.32,-1.))-.2);\n        else\n            pupdist=(length(p2-vec3(.28,.32,-1.02))-.2);\n\n        d=smin(d,pupdist,.005);\n    }\n\n    // Nose\n    d=smin(d,(length(p2-vec3(0,.1,-1.02))-.2),.02);\n\n    // Mouth (two states)\n    float d3=smax(-(length(p-vec3(-.05,-.29,-1.02))-.1),-(length(p-vec3(.05,-.29,-1.02))-.1),.1);\n\n    float d2=max(p2.z,distance(p2,vec3(clamp(p2.x,0.,.3),-.2,clamp(p2.z,-2.,2.)))+.01);\n\n    float time4=time/8.;\n    float gg=smoothstep(0.,1.,clamp((min(fract(time4),1.-fract(time4))-.25)*64.,0.,1.));\n    d=smax(d,mix(-d2,d3,gg),.1);\n\n    // Tooth\n    d=min(d,(length(p-vec3(.0,-.2,-1.02))-.08));\n\n    p.y+=.2;\n    p.xy*=rotmat(.4+cos(time2*2.)*.02);\n\n    // Arms\n    float armd=smin(distance(vec3(.2,clamp(p.y,-1.8,-0.),0.),p.xyz)-.2,\n                    distance(p,vec3(0.2,-1.7,0))-.2,.2);\n\n    d=smin(d,armd,.05);   \n\n    return d;\n}\n\nfloat floordist(vec3 p)\n{\n    return p.y+2.85;\n}\n\nfloat f(vec3 p)\n{\n    return min(rabdist(p),floordist(p));\n}\n\nfloat sceneDist(vec3 p) { return f(p); }\n\nvec3 sceneNorm(vec3 p)\n{\n    vec3 e=vec3(1e-2,0,0);\n    float d = sceneDist(p);\n    return normalize(vec3(sceneDist(p + e.xyy) - d, sceneDist(p + e.yxy) - d,\n                          sceneDist(p + e.yyx) - d));\n}\n\n\n// From simon green and others\nfloat ambientOcclusion(vec3 p, vec3 n)\n{\n    const int steps = 18;\n    const float delta = 1.5;\n\n    float a = 0.0;\n    float weight = .5;\n    for(int i=1; i<=steps; i++) {\n        float d = (float(i) / float(steps)) * delta; \n        a += weight*(d - sceneDist(p + n*d));\n        weight *= 0.6;\n    }\n    return clamp(1.0 - a, 0.0, 1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord/iResolution.xy * 2. - 1.) * .75;\n    uv.x *= iResolution.x / iResolution.y;\n    vec2 vt=uv;\n    float an;\n    time=iTime;\n\n    vec3 ro=vec3(0.,-.1,-8.+iMouse.y/iResolution.y*2.);\n    vec3 rd=normalize(vec3(uv,1.8));\n\n\n    float s=20.;\n\n    // Raymarching\n    float t=4.,d=0.;\n    for(int i=0;i<100;++i)\n    {\n        d=f(ro+rd*t);\n        if(d<1e-4)break;\n        if(t>10.)break;\n        t+=d;\n    }\n\n    // Directional light\n    float d2=f(ro+rd*t+normalize(vec3(1,2,-2))*5e-2);\n    float l=.5+.5*(d2-d)/5e-2;\n\n    vec3 rp=(ro+rd*t);\n\n    vec3 n=sceneNorm(rp);\n    \n    vec3 bcol=vec3(1,.4,.18);\n    vec3 col=bcol;\n\n    if(t<10.)\n    {\n        col=vec3(mix(.1,1.,smoothstep(0.0,.01,pupdist)));\n\n\n        if(floordist(rp)<rabdist(rp))\n            col=max(mix(bcol+(.1-length(vt.xy)/3.),vec3(1),.1),0.);\n\n        col*=l;\n\n        // Some fake bounce / environment lighting\n        col+=pow(clamp(-n.y,0.,1.),2.)*bcol/1.5;\n        if(n.y<.9999)col+=pow(clamp(-rp.y-1.8,0.,1.),4.)*vec3(1,.4,.18)/3.;\n\n        if(n.y>.99999)\n        {\n            // Floor shading\n            col*=pow(ambientOcclusion(rp,n),1.);\n            col*=mix(.7,1.,smoothstep(0.,2.,length(rp.xz)));\n        }\n        else\n        {\n            // Rabbit body shading\n            vec3 r=reflect(rd,n);\n            col += step(0.5,r.y)*.2*pow(clamp(0.,1.,1.-dot(-rd,n)),2.);\n            col*=pow(ambientOcclusion(rp,n),2.);\n        }\n    }\n    else\n    \tcol=.84*max(mix(bcol+(.1-length(vt.xy)/3.),vec3(1),.1),0.);\n    \n    fragColor.rgb=max(col,0.);\n    fragColor.rgb=sqrt(fragColor.rgb+.01);\n}\n\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XlccWH.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[13, 58, 99, 99, 192], [195, 195, 233, 233, 262], [264, 264, 286, 286, 335], [337, 337, 386, 386, 550], [572, 572, 595, 595, 3215], [3217, 3217, 3242, 3242, 3265], [3267, 3267, 3284, 3284, 3327], [3329, 3329, 3354, 3354, 3369], [3371, 3371, 3395, 3395, 3584], [3587, 3618, 3658, 3658, 3958], [3960, 3960, 4017, 4017, 5606]], "test": "untested"}
{"id": "Xlccz7", "name": "Cubucious", "author": "leon", "description": "Raymarching experiment, use mouse to control camera. And tweak the code ♥ !", "tags": ["cubucious"], "likes": 41, "viewed": 1377, "published": "Public API", "date": "1531959948", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// ponk (Leon Denise) 19/07/2018\n// most lines below are from the shadertoy community\n// licensed under hippie love conspiracy\n// happy tweaking\n\n// Geometry\nfloat range = .8;\nfloat radius = .4;\nfloat blend = .3;\nconst float count = 8.;\n\n// Light\nvec3 lightPos = vec3(1, 1, 1);\nfloat specularSharpness = 10.;\nfloat glowSharpness = 1.;\n\n// Colors\nvec3 ambient = vec3(.1);\nvec3 light = vec3(0);\nvec3 specular = vec3(1);\nvec3 glow = vec3(1);\n\n// Raymarching\nconst float epsilon = .001;\nconst float steps = 30.;\nconst float far = 10.;\n#define repeat(p,r) (mod(p,r)-r/2.)\n#define sdist(p,r) (length(p)-r)\nfloat box (vec3 p, vec3 b) { vec3 d = abs(p) - b; return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0)); }\nfloat torus (vec3 p, vec2 t) { vec2 q = vec2(length(p.xz)-t.x,p.y); return length(q)-t.y; }\nfloat smoothmin (float a, float b, float r) { float h = clamp(.5+.5*(b-a)/r, 0., 1.); return mix(b, a, h)-r*h*(1.-h); }\nmat2 rot (float a) { float c=cos(a),s=sin(a); return mat2(c,-s,s,c); }\nvec3 look (vec3 eye, vec3 target, vec2 anchor) {\n\tvec3 forward = normalize(target-eye);\n\tvec3 right = normalize(cross(forward, vec3(0,1,0)));\n\tvec3 up = normalize(cross(right, forward));\n\treturn normalize(forward + right * anchor.x + up * anchor.y);\n}\n\n// Miscellaneous\n#define time iTime*.4\n#define PI 3.14159\n#define TAU 6.28318\n#define PIHALF 1.7079\n#define PIQUART 0.785397\n#define saturate(p) clamp(p,0.,1.)\nfloat random (in vec2 st) { return fract(sin(dot(st.xy, vec2(12.9898,78.233)))* 43758.5453123); }\n\nfloat geometry (vec3 pos)\n{\n    float scene = 10.;\n    vec3 p = pos;\n\tfor (float index = count; index > 0.; --index) {\n\t\tfloat ratio = index / count;\n        \n        // easing\n\t\tratio *= ratio;\n        \n        // domain reptition and translation offset\n\t\tp.xz = abs(p.xz) - range * ratio;\n        \n        // rotations\n\t\tp.xz *= rot(PIQUART);\n\t\tp.yz *= rot(time);\n\t\t//p.yx *= rot(PIHALF);\n\n\t\tscene = smoothmin(scene, box(p, vec3(radius * ratio)), blend * ratio);\n\t}\n    return scene;\n}\n\nvec3 getNormal (vec3 p) {\n    vec2 e = vec2(epsilon,0);\n    return normalize(vec3(geometry(p+e.xyy)-geometry(p-e.xyy),\n                          geometry(p+e.yxy)-geometry(p-e.yxy),\n                          geometry(p+e.yyx)-geometry(p-e.yyx)));\n}\n\nvoid raymarching (vec3 pos, vec3 ray, inout vec4 hit)\n{\n\tfloat total = 0.;\n\tfor (float i = steps; i >= 0.; --i) {\n\t\tfloat dist = geometry(pos);\n\t\tif (dist < epsilon * total || total > far) {\n\t\t\thit.xyz = pos;\n\t\t\thit.w = i/steps;\n\t\t\tbreak;\n\t\t}\n\t\ttotal += dist;\n\t\tpos += ray * dist;\n\t}\n}\n\nvoid mainImage( out vec4 color, in vec2 coordinate )\n{    \n    vec2 mouse = iMouse.xy / iResolution.xy;\n    mouse.x = (mouse.x * 2. - 1.) * PI;\n    mouse.y *= 1.5;\n    \n\tvec2 uv = (coordinate.xy-.5*iResolution.xy)/iResolution.y;\n    vec3 eye = vec3(0,2,2) * (2. - mouse.y);\n    vec3 target = vec3(0);\n\tvec4 hit;\n    \n    eye.xz *= rot(mouse.x);\n    lightPos.xz *= rot(time);\n    \n\tvec3 ray = look(eye, target, uv);\n    raymarching(eye, ray, hit);\n    \n    vec3 pos = hit.xyz;\n\tvec3 normal = getNormal(pos);\n\tvec3 lightDir = normalize(lightPos);\n\tfloat lightIntensity = clamp(dot(lightDir, normal),0.,1.);\n\tfloat specularIntensity = saturate(pow(max(0., dot(reflect(lightDir, normal), ray)), specularSharpness));\n\tfloat glowIntensity = saturate(pow(abs(1.-abs(dot(normal, ray))), glowSharpness));\n\n\tcolor.rgb = ambient + light * lightIntensity + specular * specularIntensity + glow * glowIntensity;\n\tcolor.rgb *= hit.w;\n    color.rgb *= step(length(eye-pos), far);\n\t//color.rgb = normal * .5 + .5;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Xlccz7.jpg", "access": "shaders20k", "license": "unknown-license-reference", "functions": [[440, 600, 628, 628, 711], [712, 712, 742, 742, 803], [804, 804, 849, 849, 923], [924, 924, 944, 944, 994], [995, 995, 1043, 1043, 1246], [1248, 1408, 1435, 1435, 1505], [1507, 1507, 1534, 1534, 1994], [1996, 1996, 2021, 2021, 2244], [2246, 2246, 2301, 2301, 2531], [2533, 2533, 2587, 2587, 3531]], "test": "untested"}
{"id": "XlcyR4", "name": "Mandelbrot improved", "author": "darkeclipz", "description": "smooth iteration count for mandelbrot set.", "tags": ["fractal", "mandelbrot"], "likes": 3, "viewed": 171, "published": "Public", "date": "1531656553", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Palette\n#define LN2 0.6931471806\n\nstruct palette {\n    vec3 c0, c1, c2, c3, c4;\n};\n\npalette palette_red_accented() {\n    palette p; \n    p.c0 = vec3(0,0,16)/255.;\n    p.c1 = vec3(202,202,200)/255.;\n    p.c2 = vec3(255)/255.;\n    p.c3 = vec3(182,132,107)/255.;\n    p.c4 = vec3(247,49,73)/255.;\n    return p;    \n}\n\n    \npalette palette_calm_blue() {\n    palette p; \n    p.c0 = vec3(5,8,49)/255.;\n    p.c1 = vec3(19,48,114)/255.;\n    p.c2 = vec3(213,230,247)/255.;\n    p.c3 = vec3(213,230,247)/255.;\n    p.c4 = vec3(5,8,49)/255.;\n    return p;    \n}\n    \npalette palette_green() {\n    palette p; \n    p.c0 = vec3(0,120,122)/255.;\n    p.c1 = vec3(148,235,216)/255.;\n    p.c2 = vec3(0,179,73)/255.;\n    p.c3 = vec3(0,121,57)/255.;\n    p.c4 = vec3(0,61,52)/255.;\n    return p;    \n}\n\npalette palette_blue() {\n    palette p; \n    p.c0 = vec3(0,2,5)/255.;\n    p.c1 = vec3(8,45,58)/255.;\n    p.c2 = vec3(38,116,145)/255.;\n    p.c3 = vec3(167,184,181)/255.;\n    p.c4 = vec3(207,197,188)/255.;\n    return p;    \n}\n\n// Random\n\nfloat random (in vec2 st) {\n    return fract(sin(dot(st.xy,\n                         vec2(12.9898,78.233)))*\n        43758.5453123);\n}\n\nfloat randSeed = 0.;\nvec2 nextRand2() {\n    vec2 v = vec2( randSeed++, randSeed++ );\n\treturn vec2( random( v+0.34 ), random( v+0.75 ) );    \n}\n\n// Mapping\n\nvec3 cmap( float t, palette p ) {\n    vec3 col = vec3(0);\n    col = mix( p.c0,  p.c1, smoothstep(0. , .2, t));\n    col = mix( col, p.c2, smoothstep(.2, .4 , t));\n    col = mix( col, p.c3, smoothstep(.4 , .6, t));\n    col = mix( col, p.c4, smoothstep(.6,  .8, t));\n    col = mix( col, p.c0, smoothstep(.8, 1.,  t));\n    return col;\n}\n\n//#define MAX_ITER 1024.\n#define MAX_ITER 450.\n#define THRESHOLD 4.\nfloat mandelbrot(vec2 uv) {\n    \n\tvec2 c = 2.5*(uv - vec2(.2,0)); \n    vec2 z = vec2(0); \n    float i = 0.;\n    \n    for(; ++i <= MAX_ITER ;) {\n        z = mat2(z, -z.y, z.x) * z + c;\n    \tif( dot(z,z) > THRESHOLD ) break;\n\t}\n  \n    return i - log(log(dot(z,z))/LN2)/LN2;\t\t    \n}\n\n// Main\n\n#define SAMPLES 3.\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    \n    vec2 R = iResolution.xy;\n        \n    palette pal = palette_blue();\n    \n    vec3 col = vec3(0);\n\n    for(float i=0.; i < SAMPLES; i++) {\n        vec2 p = 0.00017*(2.*fragCoord-R+nextRand2())/R.y-vec2(-0.35209,0.09199) ;\n        float orbit = mandelbrot(p) / MAX_ITER;\n    \tcol += cmap( fract(3.3* orbit + iTime/8. )-0.0001 , pal ); \n    }\n    \n    col /= SAMPLES;\n\n    fragColor = vec4(col, 1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XlcyR4.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 87, 119, 119, 315], [322, 322, 351, 351, 550], [556, 556, 581, 581, 780], [782, 782, 806, 806, 1006], [1008, 1019, 1046, 1046, 1153], [1176, 1176, 1194, 1194, 1297], [1299, 1311, 1344, 1344, 1643], [1645, 1713, 1740, 1740, 1992], [1994, 2022, 2079, 2079, 2487]], "test": "untested"}
{"id": "XlcyRN", "name": "Moire Sin", "author": "momoro", "description": "Zooming in and out of atan", "tags": ["bookofshaders"], "likes": 1, "viewed": 124, "published": "Public", "date": "1531684133", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    \n    vec2 st = fragCoord.xy/iResolution.xy;\n    st.x *= iResolution.x/iResolution.y;\n\tst.x -= 0.4;\n    \n    vec3 color = vec3(0.);\n\n    float f;\n    \n    st -=0.5;\n    float r = length(st);\n\n    f = distance(vec2(0.), st.xy);\n    \n    \n    f = sin(atan(st.x, st.y)*sin(iTime)*8000. +30.);\n    f = smoothstep(f, f-.8, r);\n    \n    color = vec3(f);\n    \n    fragColor = vec4(color,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XlcyRN.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 449]], "test": "untested"}
{"id": "XlcyWH", "name": "D15E45E", "author": "Zoz", "description": "Party coded 4k intro made at Edison 2018\n\nGroup: FEE1DEAD\nGraphics: Zoz\nMusic: Sigmund Floyd\n", "tags": ["raymarching", "4k", "spiral"], "likes": 5, "viewed": 188, "published": "Public", "date": "1532353265", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI 3.1415\n#define R(p, m) mod(p, m) - m / 2.\n#define ID(p, m) floor(p / m) \n\n#define time mod(iTime, 76.)\n\nmat3 Rotate(vec3 angles)\n{\n    vec3 c = cos(angles);\n    vec3 s = sin(angles);\n    \n    mat3 rotX = mat3( 1, 0, 0, 0,c.x,s.x, 0,-s.x, c.x);\n    mat3 rotY = mat3( c.y, 0,-s.y, 0,1,0, s.y, 0, c.y);\n    mat3 rotZ = mat3( c.z, s.z, 0,-s.z,c.z,0, 0, 0, 1);\n\n    return rotX*rotY*rotZ;\n}\n\n\n\nfloat hash(vec2 co){\n    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nfloat noise( vec2 p ) {\n    vec2 i = floor( p );\n    vec2 f = fract( p );\t\n\tvec2 u = f*f*(3.0-2.0*f);\n    return -1.0+2.0*mix( mix( hash( i + vec2(0.0,0.0) ), \n                     hash( i + vec2(1.0,0.0) ), u.x),\n                mix( hash( i + vec2(0.0,1.0) ), \n                     hash( i + vec2(1.0,1.0) ), u.x), u.y);\n}\n\n\n\n\n/**********************\n * DISTANCE FUNCTIONS *\n **********************/\n\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\nfloat sdSphere( vec3 p ) {\n \treturn length(p) - 1.;   \n}\n\n/******\n * OPS\n ******/\n\nvec2 opU(vec2 a, vec2 b) {\n \treturn a.x < b.x ? a : b;   \n}\n\n\nfloat opRep1(inout float p, float m) {\n \tfloat c = ID(p, m);\n    p = R(p, m);\n    return c;\n}\n\nvec2 opRep2(inout vec2 p, float m) {\n    vec2 c = ID(p, m);\n    p = R(p, m);\n    return c;\n}\n\n/*****************\n * MAP Functions\n *****************/\n\nfloat repid1 = 0.;\nfloat spiralRot = .5;\nfloat spiralNoise;\n    \nfloat spiral(vec3 p) {\n    //saving original coordinate space \n    vec3 po = p; \n    \n    repid1 = opRep1(p.x, 0.08); \n    repid1 = mod(repid1, 10.);\n          \n    //Spiral rotation effect\n    p = Rotate(vec3(spiralRot * sin(po.x - p.x + time * PI / 4.), 0, 0)) * p;\n    //spiral noise effect\n    p.z += mix(0., noise(p.xy * 100.) * 0.3, clamp(time - spiralNoise, 0., 1.));\n    return sdBox(p, vec3(.03, .45, .02)) - 0.002;\n}\n\nfloat repid2 = 0.;\n\nfloat frame(vec3 p) {\n \tvec3 p0 = p;\n    \n    repid2 = opRep1(p.x, .5);\n    p *= Rotate(vec3(repid2, 0, 0));\n    \n    p.y -= .25;\n    float d = .4 + 0.2 * sin(repid2);\n    return max(sdBox(p, vec3(0.02, d, d)), -sdBox(p, vec3(0.2, d - 0.02, d - 0.02)));\n}\n\nvoid camera(inout vec3 p) {\n    vec3 p1 = Rotate(vec3(0.7, 0, -PI / 8.)) * p;\n    \n    \n    vec3 p2 = Rotate(vec3(0, PI / 2., 0.)) * p;\n    vec3 p3 = Rotate(vec3(0, PI / 3., 0.)) * p;\n    p2.y -= 0.30;// - 0.25;\n \tp2.x += (time - 15.) * 1.;\n    p3.x += time - 15.;\n    \n    spiralNoise = 40.;\n    \n    if (time < 8.) {\n    \tp = p2; \n    } else if (time < 20.) {\n     \tp = p1;   \n    } else if (time < 28.) {\n     \tspiralRot =  2.;\n        p = p2;\n    } else if (time < 36.) {\n        spiralRot = 2.;\n     \tp = p1;   \n    } else if (time < 56.){\n        spiralRot = 2.;\n     \tp = p2;   \n    } else if (time < 64.) {\n     \tp = p3;   \n    } else {\n     \tp = p2;   \n    }\n   \n}\n\nvec2 map(vec3 p) {\n\n    float d;\n    vec2 t = vec2(100);\n\tvec3 p0 = p;\n    camera(p);\n    \n    \n    t = vec2(spiral(p - vec3(0, .3, 0)), 1.);\n        \n   \t//floor\n    vec3 p1 = p;\n    opRep2(p1.xz, 0.11);\n    float off = noise((p.xz - p1.xz) * 10.) * 0.05;\n\n    d = sdBox(p1 + vec3(0, .5 + off , 0), vec3(0.05)) - 0.005;\n    t = opU(t, vec2(d, 2.));\n       \n    t.x = max(t.x, (p.x - 28.));\n        \n    //frames and stuff\n    vec2 t2 = vec2(frame(p), 3);\n        \t\n    //spiral2\n        \n    vec3 off2 = vec3(-64., 2. * sin(p.x), 2. * cos(p.x));\n    vec2 s = vec2(sdBox(p + off2, \n                            vec3(10, .5, 0.1)), 4.);\n    vec3 p2 = p;\n    float b = sdBox(p2 + off2 - vec3(0, 0., 0.), vec3(12., 0.2, 0.2));\n   \ts.x = max(s.x, -b);\n        \n    t2 = opU(t2, s);\n    \t\n\t\t\n    \n    t2.x = max(t2.x, -p.x + 32.);\n       \tt = opU(t, t2);\n    \n   \n    \t//t = t2;\n\t\t\n    \n    \n    //t = opU(t, vec2(p.y + .25, 2.));\n    return t;\n}\n\nvec3 nor(vec3 p, float prec)\n{\n    vec2 e = vec2(prec, 0.);\n    \n    vec3 n;\n    \n    n.x = map(p+e.xyy).x - map(p-e.xyy).x; \n    n.y = map(p+e.yxy).x - map(p-e.yxy).x; \n    n.z = map(p+e.yyx).x - map(p-e.yyx).x;  \n    \n    return normalize(n); \n}\n\nvec2 render(vec3 o, vec3 r) {\n \tfloat t = 0.;\n    vec2 t0;\n    for (int i = 0; i < 128; i++) {\n        vec3 p = o + r * t;\n        t0 = map(p);\n        \n        if (t0.x < 0.001) break;\n        \n        t += t0.x * 0.55;\n        \n        if (t > 30.) {\n            t0.x = 30.;\n         \tbreak;       \n        }\n    }\n    \n    return vec2(t, t0.y);\n}\n\nvec3 shade(vec2 t) {\n    if (t.y == 0.) return vec3(0., 0., 0);\n    //if (t.y == 2.) return vec3(1, 0, 0);\n    \n    vec3 col = vec3(0);\n    if (t.y == 1.) {\n    \tvec3 c = repid1 == 0. ? vec3(1, 0.5, 0) : vec3(1);\n    \tcol = c;// / (t.x * t.x * .6);\n        \n    }\n    \n    return col;\n}\n\nvec3 applyFog( in vec3  rgb,       // original color of the pixel\n               in float distance ) // camera to point distance\n{\n    float fogAmount = 1.0 - exp( -distance*0.4 );\n    vec3  fogColor  = vec3(0);\n    return mix( rgb, fogColor, fogAmount );\n}\n\n\nvec3 scene1(vec3 o, vec3 r) {\n    vec3 col;\n    vec2 t = render(o, r);\n    \n    vec3 p = o + r * t.x;\n    vec3 n = nor(p, 0.001);\n    \n       \n    vec3 d = normalize(reflect(p - o, n));\n    if (t.y == 2.) {\n                \n   \t\tvec2 t1 = render(p + d * 0.02, d);\n        col = 0.3 * vec3(0.2);\n\n        col += applyFog(0.3 * shade(t1), t1.x);\n        \n    } else if (t.y == 3.) {\n        float add = 1./8. - 1./8.;\n\t  \n      //float x = clamp(floor(4. * time), 0., 8. * floor(time / 2.));\n      float x = floor(time * 4. - add) * mod(floor(time - add), 2.);  \n      col = mod(repid2 - x, 4.) == 0. ? vec3(1, .5, 0) : vec3(1, 1, 1);  \n    } else if (t.y == 4.) {\n     \t//scene 2 spiral\n        col = vec3(1);\n    }else {\n        col = shade(t);        \n    }\n    \n\n   \n    float ao = 1.;\n    for (float i = 0.; i < 6.; i++) {\n   \t\tao -= 0.3 * abs(length(n * i /16.) - map(p + n * i / 16.).x);\n    }\n    col *= ao;\n   \n    \n\tcol = applyFog(col, t.x);\n    return col;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord / iResolution.xy;\n    uv = uv * 2. - 1.;\n    uv.x *= iResolution.x / iResolution.y;\n\n    // Time varying pixel color\n    vec3 o = vec3(0, 0, -1.8);\n    vec3 r = normalize(vec3(uv, 2));\n    \n    vec3 col = mix(scene1(o, r), vec3(0), clamp((time - 75.), 0., 1.));\n\n    // Output to screen\n    fragColor = vec4(col ,1.0);\n}", "image_inputs": [{"id": "ld2Xzt", "previewfilepath": "https://soundcloud.com/gustav-nelson-schneider/d15e45e-4k", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0, "src": "https://soundcloud.com/gustav-nelson-schneider/d15e45e-4k", "ctype": "musicstream"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XlcyWH.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[115, 115, 141, 141, 396], [400, 400, 420, 420, 492], [494, 494, 517, 517, 818], [823, 898, 929, 929, 1016], [1018, 1018, 1044, 1044, 1074], [1076, 1101, 1127, 1127, 1160], [1163, 1163, 1201, 1201, 1256], [1258, 1258, 1294, 1294, 1350], [1352, 1474, 1496, 1536, 1900], [1922, 1922, 1943, 1943, 2177], [2179, 2179, 2206, 2206, 2852], [2854, 2854, 2872, 2872, 3794], [3796, 3796, 3826, 3826, 4043], [4045, 4045, 4074, 4074, 4394], [4396, 4396, 4416, 4416, 4682], [4684, 4684, 4814, 4814, 4941], [4944, 4944, 4973, 4973, 5911], [5914, 5914, 5971, 6021, 6366]], "test": "untested"}
{"id": "XldcDn", "name": "Moebius Spiral 1", "author": "emh", "description": "Moebius Spiral 1", "tags": ["spiral", "moebius"], "likes": 3, "viewed": 455, "published": "Public API", "date": "1532254485", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#ifdef GL_ES\nprecision mediump float;\n#endif\n\n#define M_PI atan(1.0) * 4.0\n\n// uniform float time;\n// uniform vec2 mouse;\n// uniform vec2 resolution;\n#define time iTime\n#define resolution iResolution.xy\n\nfloat rand(vec2 co){\n    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\n#define nfloor(v) vec2(ivec2(v))\n#define nfract(v) ( v - nfloor(v) )\n\n/*\nvec2 nfract(vec2 co) {\n\tfloat x = co.x;\n\tfloat y = co.y;\n\treturn vec2(x >= 0.0 ? x - floor(x) : x - ceil(x), y >= 0.0 ? y - floor(y) : y - ceil(y));\n}\n\nvec2 nfloor(vec2 co) {\n\tfloat x = co.x;\n\tfloat y = co.y;\n\treturn vec2(x >= 0.0 ? floor(x) : ceil(x), y >= 0.0 ? floor(y) : ceil(y));\n}\n*/\n\nfloat sinc(float t) {\n\treturn (sin(t) + 1.0) / 2.0;\n}\n\nfloat cosc(float t) {\n\treturn (cos(t) + 1.0) / 2.0;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord) {\n\tfloat t;\n\tt = time + 8.0;\n\tvec2 r = vec2(resolution.y);\n\t\n\tvec2 no = (fragCoord.xy - .5 * resolution) / resolution.y + .5;\n    // vec2 no = fragCoord.xy / resolution;\n\tvec2 o = vec2(0.0);\n\t// vec2 aspect = vec2(1.0, r.y / r.x);\n    vec2 aspect = vec2(1.0, 1.0) / 1.8;\n\tfloat sz = 0.0;\n\tfloat t2 = t;\n\tvec2 idx = vec2(0.0);\n\tvec2 boxOffset = vec2(0.0);\n\t\n\tconst int maxi = 6;\n\tfor (int i = 0; i <= maxi; i++) {\n\t\tfloat sc = exp2(float(i));\n\t\tfloat sc2 = pow(2.0, float(maxi - i + 1));\n\t\tfloat j = float(i);\n\t\tfloat maxj = float(maxi);\n\t\t\n\t\tbool gotOne = false;\n\t\t\n\t\tfor (int dx = -1; dx <= 1; dx++) {\n\t\t\tfor (int dy = -1; dy <= 1; dy++) {\n\t\t\n\t\t\t\t// vec2 to2o = nfloor(no * sc) + vec2(float(1), float(1));\n\t\t\t\tvec2 delta = vec2(float(dx), float(dy));\n\t\t\t\tvec2 to2 = nfloor(no * sc) + delta;\n\t\t\t\t\n\t\t\t\tfloat tslow = t  / 100.0;\n\t\t\t\t\n\t\t\t\tvec2 to3 = to2;\n\t\t\t\tfloat rndMove = mix(rand(to3 + floor(tslow)), rand(to3 + floor(tslow) + 1.0), fract(tslow));\n\t\t\t\tfloat rnd = rand(to2);\n\t\t\t\t\n\t\t\t\tfloat tsc = .1 * t * j / sc + rnd * 1000.0;\n\t\t\t\tvec2 bo = (i > 0 ? vec2(cosc(tsc), sinc(tsc)) : vec2(0.0));\n\t\t\t\t\n\t\t\t\tvec2 to = nfract((no + bo) * sc);\n\t\t\t\tvec2 tbo = nfract(bo * sc);\n\t\t\t\t\n\t\t\t\t// big on top\n\t\t\t\tbool check1 = length((o - 0.5) * aspect) < 0.15;\n\t\t\t\t// small on top\n\t\t\t\tbool check2 = length((to - 0.5) * aspect) > 0.15;\n\n\t\t\t\tfloat prob = 0.0;\n\t\t\t\tif (i == 0) {\n\t\t\t\t\tprob = 1.0;\n\t\t\t\t} else if (i >= 3) {\n\t\t\t\t\tprob = 0.5 / j;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tbool check = rnd < prob && sz > 1.0 && length(to - 0.5) < sinc(t * 2.5 + 1000.0 * rnd) ? check2 : check1;\n\t\t\t\t// check = check1;\n\t\t\t\tbool cutCircle = false;\n\t\t\t\tif (check) {\n\t\t\t\t\tif ((dx == 0 && dy == 0)) {\n\t\t\t\t\t\tcutCircle = false;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tcutCircle = length((tbo - 0.5) * aspect) <= 0.51;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\t\t\t\t\n\t\t\t\t// bool visible = rand(to2 + vec2(0.254, 0.2342543)) < prob;\n\t\t\t\tbool visible = !cutCircle;\n\t\t\t\tif (!visible) continue;\n\t\t\t\t\n\t\t\t\to = check ? o : to;\n\t\t\t\tsz = check ? sz : float(i + 1);\n\t\t\t\tt2 = check ? t2 : t * (rnd + 0.5) + rnd * 1000.0;\n\t\t\t\tidx = check ? idx : to2;\n\t\t\t\tboxOffset = check ? boxOffset : to;\n\t\t\t\tgotOne = gotOne || check;\n\t\t\t}\n\t\t}\n\t\tif (gotOne) {\n\t\t\t// break;\n\t\t}\n\t}\n\to = o * r - r / 2.0;\n\tt = t2;\n\t\n\t// bool cutCircle = length(boxOffset)\n\tvec2 or = o / r;\n\t\n\tif (sz > 6.0) {\n\t\tt = 8.0;\n\t}\n\t\t\n\to = vec2(length(o) / r.y - .3, atan(o.y,o.x) + fract(-t / 100.0) * 2.0 * M_PI);\n\t\n\tvec2 o2 = o;\n\t\n\tfloat width = 20.0;\n\tfloat scale = 20.0;\n\tfloat offset = 0.02;\n\t\n\to.x += 0.3;\n\t\n\tfloat y0to1 = (o.y + M_PI) / (2.0 * M_PI); // + floor(o2.x * scale);\n\to.x = (fract(o.x * scale + y0to1) + 1.0 + y0to1) / width;\n\to.x = (o.x - 0.05 * 1.5) / 0.2;\n\to.x -= (o.y + M_PI) / (8.0 * M_PI);\n\to.y *= M_PI / 2.0 + offset;\n\to.y = sin(M_PI * o.y);\n\t\n\tfloat dir = mod(floor(o2.x * scale), 2.0) == 0.0 ? 1.0 : -1.0;\n\tdir *= floor(o2.x * scale / 2.0);\n\tvec4 s = 0.08 * cos(1.5*vec4(0,1,2,3) + dir * t + o.y + cos(o.y) * cos(8.0));\n\t// s = sz > 6.0 ? vec4(1.0) : s;\n\tvec4 e = s.yzwx;\n\tvec4 f = max(o.x-s,e-o.x);\n\tvec4 color = o.x > -0.1 ? dot(clamp(f*r.y,0.,1.), 80.*(s-e)) * (s-.1) + (e - o.x) : vec4(0.0);\n\t\n\tfloat cutoff = 0.15;\n\tfragColor = o2.x + y0to1 / scale < cutoff ? color : vec4(1.0);\n\t\n\tvec2 ot = boxOffset;\n\t// gl_FragColor = vec4(ot.x, ot.y, 0.0, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XldcDn.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[76, 204, 224, 224, 296], [368, 662, 683, 683, 715], [717, 717, 738, 738, 770], [773, 773, 829, 829, 4050]], "test": "untested"}
{"id": "XldcR4", "name": "李明杰V20", "author": "leneer", "description": "h", "tags": ["h"], "likes": 4, "viewed": 263, "published": "Public", "date": "1531797557", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Bisous from Leon\n\n// Music from:\n// https://soundcloud.com/steelcitydancediscs/a-ghettohousedrummachine\n\n// heart function from:\n// https://www.desmos.com/calculator/lncpsghko4\n// text\n#define grid 16.\n#define cell 1./16.\nconst int kA=177,kB=178,kC=179,kD=180,kE=181,kF=182,kG=183,kH=184,kI=185,kJ=186,kK=187;\nconst int kL=188,kM=189,kN=190,kO=191,kP=160,kQ=161,kR=162,kS=163,kT=164,kU=165,kV=166;\nconst int kW=167,kX=168,kY=169,kZ=170,kSpace=80;\n\n\nvec2 getSymbol (int key)\n{\n\treturn vec2(mod(float(key),grid),floor(float(key)/grid));\n}\n\nvec2 getLetterUV (vec2 target, vec2 offset)\n{\n    vec2 uvLetter = target;\n    uvLetter.x = uvLetter.x * 0.45 + 0.017;\n    uvLetter += offset / grid;\n    float crop = step(target.x, cell) * step(target.y, cell);\n    crop *= step(0., target.x) * step(0., target.y);\n    return uvLetter * crop;\n}\n\nfloat getText (vec2 target)\n{\n    int symbols[] = int[] ( kB,kI,kS,kO,kU,kS );\n    int count = symbols.length();\n    vec2 space = vec2(0.5,1);\n    vec2 textUV = vec2(0);\n    for (int i = 0; i < count; ++i) {\n        vec2 offset = vec2(i,0)/grid;\n        offset.x -= float(count)/grid/2.;\n        offset.y -= cell/2.;\n    \ttextUV += getLetterUV(target - offset, getSymbol(symbols[i]));\n    }\n    return texture(iChannel3, textUV).r;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Common stuff\n    vec3 color = vec3(0);\n    float time = iTime;\n    const float pi = 3.14159;\n    const float pi2 = 3.14159 * 2.;\n    float aspect = iResolution.x / iResolution.y;\n    vec2 uv = fragCoord.xy / iResolution.xy;\n\tvec2 uvViewport = uv * 2. - 1.;\n    uvViewport.x *= aspect;\n    \n    // Displace UV\n    vec2 uvHeart = uvViewport * 2.;\n    uvHeart.x *= 0.9;\n    uvHeart += vec2(0.0, 0.25);\n    float a = pi2 * texture(iChannel0, uvViewport+vec2(0.1,0.2)*time).r;\n    a += pi2 * texture(iChannel0, uvViewport+vec2(-0.15,-0.08)*time).r;\n    a += time;\n    vec2 offset = vec2(cos(a), sin(a)) * 0.03;\n    uvHeart += offset;\n    uvHeart.y -= abs(sin(uv.x)*0.2);\n    \n    // Heart from: https://www.desmos.com/calculator/lncpsghko4\n    float thinHeart = 0.02;\n\tfloat plotter = (thinHeart/(pow(uvHeart.x,2.)*pow(uvHeart.y,3.)-(pow(pow(uvHeart.x,2.)+pow(uvHeart.y,2.)-1.,3.))));\n    float signP = sign(plotter);\n    plotter += smoothstep(0.0, 0.2, plotter);\n    plotter = abs(plotter);\n    \n    // Polar coordinates\n    float angle = atan(uvViewport.y, uvViewport.x) * 3.;\n    float radius = (length(uvViewport) - 0.5);\n    vec2 uvPolar = vec2(angle, radius);\n    uvPolar.x = mod(abs(sin(uvPolar.x)),1.);\n    uvPolar.y = uvPolar.y * 2. - 0.5;\n    \n    // Sound FFT\n    float thinSignal = 0.1;\n    plotter += -(thinSignal/(texture(iChannel2, uvPolar).r-uvPolar.y));\n    float signP2 = sign(plotter);\n    plotter = abs(plotter);\n    \n    // Background\n    float thinBack = 0.2;\n    uvPolar = vec2(angle, radius);\n    uvPolar.x *= 60.0;\n    uvPolar.y = (uvPolar.y-0.5) * 1.;\n    float fadeCenter = clamp(length(uvViewport)*2.-2.,0.,1.);\n    plotter += fadeCenter * clamp(abs(thinBack/(sin(uvPolar.x)-uvPolar.y)),0.,1.);\n    \n    // Colors\n    vec3 red = vec3(0.5,0.1,0.1);    \n    vec3 blue = vec3(0.1,0.2,0.5);  \n    vec3 yellow = vec3(0.9,0.6,0.2);\n    vec3 gray = vec3(0.2,0.2,0.25);\n    vec3 colorP = mix(red, gray, 1.-clamp(signP,0.,1.));\n    colorP = mix(colorP, yellow, 1.-clamp(signP2,0.,1.));\n    color = mix(color, colorP, plotter);\n    \n\n    \n\tfragColor = vec4(color,1.0);\n}", "image_inputs": [{"id": "4sfGRn", "previewfilepath": "/media/ap/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg", "ctype": "texture"}, {"id": "4sf3Rn", "previewfilepath": "/media/ap/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png", "ctype": "texture"}, {"id": "XdXGRr", "previewfilepath": "/presets/mic.png", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/presets/mic.png", "ctype": "mic"}, {"id": "4dXGzr", "previewfilepath": "/media/ap/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png", "channel": 3, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XldcR4.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[108, 452, 478, 478, 539], [541, 541, 586, 586, 834], [836, 836, 865, 865, 1269], [1272, 1272, 1329, 1349, 3420]], "test": "untested"}
{"id": "XldcWN", "name": "sawcos rainbow gradient scatter", "author": "ollj", "description": "the quest to making a distance field indicator smooth and directional, and as general as possible.\nalsu useful to estimate scattering for a cheesy sun.", "tags": ["sss", "sun", "gradient", "rainbow", "scatter"], "likes": 4, "viewed": 374, "published": "Public API", "date": "1532695242", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n//the shape is a placeholder for a glyph that has parametric circles/lines/width, as a placeholder for [any letter]\n//it has mirror symmetry to have dynamit width set easily.\n//it is measured twice, to aim for overlapping glyphs with different colors.\n//goal was to deferr the sqrt(), to do less sqrt, but in the end , vectorizing the sqrt is the best i could do.\n//the hart lesson here is that only with offset==0 yo can do min() before sqrt()\n//- i keep trying to delay the sqrt after the min()&max() but it results in [offset boolean algebra], likely unwanted overlapping/unions/intersections.\n\n//error, if 2 glyphs happen to have perfectly overapping segments, they have a [colring-dispute]\n//intersections are almost fine here, the dispute is the a [laplachian discontinuity]\n\n\n//2 lesons here; \n//- the min of an offset root must com eafter the a=abs(sqrt(a))-offset);ot it becomes [offset booean algebra]\n//- - cute but not wanted here.\n//if i want 2 glyphs in the same cell with 2 colors, i must to 2 times; root(vec2()); once for each offset.\n//there is no deferring of roots here, only vectrizing.\n\n#define ViewZoom 1.\n\n#define pi acos(-1.)\n#define sat(x)clamp(x,0.,1.)\n#define dd(a)dot(a,a)\n#define u5(a) ((a)*.5+.5)\n#define u2(a) ((a)*2.-1.)\n#define ss(a,u)smoothstep(a,-a,u)\n#define v0 float\n#define v1 vec2\n#define v2 vec3\n#define v3 vec4\nv0 suv(v3 a){return dot(v3(1),a);}v0 suv(v2 a){return dot(v2(1),a);}\nv0 suv(v1 a){return a.x+a.y;}//sum of vector\nv0 mav(v1 a){return max(a.y,a.x);}v0 mav(v2 a){return max(a.z,mav(a.xy));}v0 mav(v3 a){return max(mav(a.zw),mav(a.xy));}\n#define miv(a)-mav(-a)\n\n#define mad(a,b,c) ((a)*(b)+(c))\n#define ab012(a,b) mad(vec3(0,1,2),b,a)\n#define c11(a,b) clamp(a/b,-1.,1.)*b\n\n#define fra(u)(u-.5*iResolution.xy)*ViewZoom/iResolution.y\nvec2 fra2(vec2 u){float r=iResolution.x/iResolution.y;u-=.5;u*=ViewZoom;u.x*=r;return u;}//fra2(u)=fra(u*iResolution)\n\n\n\n//modulo with offset, hg_sdf\n//float pMod(float t,float d){return mod(t+d*.5,d)-d*.5;}\n//#define pMod(x,d) (mod(x+d*.5,d)-d*.5)\n\n// https://en.wikipedia.org/wiki/Error_function#Approximation_with_elementary_functions\n//float Erf(float x){float xx=x*x;float xxa=xx*.147;return sqrt(1.-exp(-xx*(xxa+4./pi)/(xxa+1.)))*sign(x);}\n//float ErfI(float x){float a=1./.147,b=2./pi/.147,u=log(1.-x*x),c=u*.5+b;return sqrt(sqrt(c*c-u*a)-c)*sign(x);}\n\n/*\n//float analstretch(float a,float b){b*=.5;return sign(a-b)*max(abs(a-b)-b,0.);} //stretch() is only stretching to positive.\n#define stretch2(a,b)sign(a)*max(abs(a)-b,0.)\n#define stretch(a,b)stretch2(a-b*.5,b*.5)\n\nvec2 glyph2(vec2 u,vec2 m){vec2 c=vec2(0)\n ;c.x=dd(vec2(abs(u.x)-m.x-m.y,stretch(u.y,m.y*3.)))\n ;c.y=dd(vec2(stretch(u.x,m.x),abs(u.y)-m.y))\n ;c.x=miv(c)\n ;u.x=abs(u.x)-m.x//+m.y //thee +m.y makes the mirror symmetry weird\n ;c.y=dd(u)\n ;return c;}\n\nvec2 glyph3(vec2 u,vec2 m){u.y-=m.y*3.-.4;u.x-=m.x*2.-.2;return glyph2(u,m);}//is the same shape as glyph2() but [a semitone higher] and offset for overlap.\nvec3 bilin(vec3 a,vec3 b,vec3 c,vec3 d,vec2 z){return mix(mix(a,b,z.x),mix(c,d,z.x),z.y);}\n\n\nvec3 glyphs(vec2 u,vec2 m\n){m.y=abs(m.y)\n ;vec3 c=vec3(1) \n //;c=glyph(u,m)\n ;vec2 n=m;\n ;n.x=abs(n.x)\n ;vec2 e=glyph2(u,n)\n ;vec2 f=glyph3(u,n)//2 different glyph shapes, but with the same prameters/offsets/radii\n ;vec4 j=vec4(e,f);j.yz=j.zy\n ;j=sqrt(j) //at least we vectorized 4 sqrt's of 2 overlapping glyphs, while maintaining egment colorID\n ;j.zw=abs(j.zw-m.y)\n ;float d1=min(j.x,j.z)\n ;float d2=min(j.y,j.w)//2 distances as if they would be a special case ofthis generalization;\n ;vec2 gt=vec2(sign(d1-d2),sign(min(j.x,j.y)-min(j.z,j.w)))*.5+.5//gt is either (0,0);(0,1);(1,0);or(1,1), fot bilinear mixing.\n ;c.x=min(d1,d2);c=c.xxx\n ;vec2 i=vec2(-1,1)*sign(m.x)*.01\n ;c=smoothstep(i.x,i.y,c)\n ;c*=bilin(vec3(1,0,0),vec3(0,1,0),vec3(0,0,1),vec3(1,1,0),gt)\n ;return c;}\n*/\n\n/*\n//general [Poeter-Duff] \"Compositing Digital Images\" siggraph 1984;\n// https://en.wikipedia.org/wiki/Alpha_compositing\n// https://doc.qt.io/archives/qq/qq17-compositionmodes.html \n//\n//#define pdC(a,b,c,d,m,f)mix(a,b,m.w)*c*d*f+pdCx(a,b,c,d,m)\nvec3 pdC(vec3 a,vec3 b,float c,float d,vec4 m,float f){\n return mix(a,b,m.w)*f*c*d\n  +b*m.z*(1.-c)\n  +a*m.y*(1.-d);}//many contextual simplifications possible.\n#define pdA(c,d,m)suv(m*vec3(c*d,c*(1.-d),d*(1.-c)))\n//#define pdA(c,d,m)m.x*c*d+m.y*c*(1.-d)+m.z*d*(1.-c)\n//\n//xor case is simpler,likely worth making it a subroutine of pdC;\n//#define pdCx(a,b,c,d,m)m.y*a*(1.-d)+m.z*b*(1.-c)\n//vec3 pdCx(vec3 a,vec3 b,float c,float d){return a*d+b*c;}\n//\nvec4 pd(vec4 a,vec4 b,vec4 m,float f){\n vec4 r=vec4(pdC(a.rgb,b.rgb,a.w,b.w,m,f),1);//ceneral case color\n r.w   =pdA(a.w,b.w,m.rgb);//general case alpha is sometimes neglible.\n return r;}\n//return a*a.w+b*b.w*(1.-a.w);//general case reduction shortcut\nvec4 sOver(vec4 a,vec4 b){return pd(a,b,vec4(1,1,1,0),1.);}\nvec4 sAtop(vec4 a,vec4 b){return pd(a,b,vec4(1,0,1,0),1.);}\nvec4 sIn (vec4 a,vec4 b){return pd(a,b,vec4(1,0,0,1),1.);}\nvec4 sXor(vec4 a,vec4 b){return pd(a,b,vec4(0,1,1,1),0.);}\nvec4 sOut(vec4 a,vec4 b){return pd(a,b,vec4(0,0,1,0),0.);}\nvec4 sCut(vec4 a,vec4 b){return pd(a,b,vec4(0,0,1,1),0.);}\n//pow(2,5)address space for 5 functions seems wastefull.\n//there is either a lot of hidden nonsense or hidden symmetry.\n//it appears there is a ot of mirror symmetry to be reduced here!\n//which then reduces it to only 6 special cases.\n// All the permutations that I tested are rather useless.\n// i need to sleep over this.\n//\n//vec4 sTest(vec4 a,vec4 b){return pd(a,b,vec4(1,0,0,0),0.);}\n//screw all the \"destination*\" functions though.,\n//... these are are all identical to \"source*\" with swapped inputs!.\n//last parameter might be a relict,obsolete.\n//as in,last is identical to first ,always?\n//and the first one basically just swaps a and b inputs?\n//no,xor is clearly different from Atop!\n/**/\n\n//i wanted a general hsv2rgb, and got sidetracked into a rainbow that pseudo-scatters and pseudo-diffracts\nvec4 mixColor(vec4 a,vec4 b,float alpha){return vec4(mix(a.rgb,b.rgb,alpha*b.a),.5);}\nfloat Plot(float x,float y){x-=y;return sat(1.-abs(x*.5/length(vec2(dFdx(x),dFdy(x)))));}\nvec4 drawCurve(vec4 a,float y,float x,vec4 b){return mixColor(a,b,Plot(x,y)*b.w);}//sOver()\nvec3 gradVis(vec3 c,vec2 u,vec2 v){vec3 d=c-u.y-.5;float a=.005\n ;c+=smoothstep(a,-a,abs(fract(v.x)-.5))//vertical white line shows interval\n ;c-=smoothstep(a,-a,abs(abs(u.y)-pi/18.75)) //horizontal black lines show visible range[0..1]\n ;c.xyz=drawCurve(vec4(c,1),u.y*2.,d.z,vec4(0,0,1,1)).xyz\n ;c.xyz=drawCurve(vec4(c,1),u.y*2.,d.y,vec4(0,1,0,1)).xyz\n ;c.xyz=drawCurve(vec4(c,1),u.y*2.,d.x,vec4(1,0,0,1)).xyz;return c;}\n\n//return y of f(u.x)which is a triangle wave,slanted sideways by u.x that is also sinusoidial continuity,but not for: 0.!=u.y!=1.\n//looks best if u.y=clamp(m.x,0.,1.)-15./iResolution.y;, for a \"smoothstepSine()wihin 1/15 subpixel.\nfloat sawCos(vec2 u){u.x=fract(u.x);u+=(1.-2.*u)*step(u.y,u.x);\n return cos(clamp(1.-u.x/u.y,0.,1.)*pi)*.5+.5;}\nfloat sawCos(float a,float b){return sawCos(vec2(a,b));}\n//this basically replaces c.g=smoothstep(aa,-aa,c.g);\nfloat sawCos(float a){return sawCos(a,1.-15./iResolution.y);}\n\nvec3 sawCos(vec3 a,vec3 b){a=fract(a);vec3 s=step(b,a);return u5(cos(sat(1.-(a-u2(a)*s)/(b-u2(b)*s))*pi));}//b range [0..1]\n//c=sawCos(vec3(u.x*10.),vec3(.25,.5,.75))\n\nvec3 rainbow(float a,float b){return abs(u2(fract(ab012(a,b))));}//tri rainbow with offsets\nvec3 rainbow2(float a,float b){return u5(cos(2.*pi*ab012(a,b)));}//cos rainbow with offsets\n//getting sawcos to generallygo from purple to purple is a challenge that i refuse for now.\nvec3 rainbow3(float a,float b){return (sawCos(ab012(a+.5,b),vec3(.75)));}//sawCos rainbow with offsets\n\n\n//good rainbow-gradients ALWAYS center green|white and border purple|black\n//m.x sets saturation==transition by shifting blue|red rang[-.1,.5]\n//m.y sets \"flimmer\", range [-.159 ... 159]\n//p is a flimmer-phase that modulates the shorter subwave of red (green) blue;try; p=1.+vec3(-1,0,1)*cos(iGlobalTime*.001)\nvec3 rainbowN(vec2 u,vec2 m,vec3 p\n){vec3 c=vec3(1)//;m=vec2(0)//simple case\n //;c=sawCos(vec3(u.x*10.),vec3(.25,.5,.75))\n ;m.x=c11(-m.x,.5)//good optional bounds, sign negation for utility.\n ;m.y=c11(m.y,.159)//decent optional bounds to stay in visible range\n ;m.y=m.y*pi+.5\n ;m.y=u5(m.y)\n ;c=rainbow3(u.x-m.x*.5,fract(m.x*.6))//the .mx/2 ensures that white/green stays centred and purple stys bordered;\n //;c=mix(c*m.y,c,cos(u.x*p*iResolution.x/4.))\n ;c=mix(c*m.y,c,sawCos(u.x*p*iResolution.x/4.,vec3(.8)))\n ;vec2 v=u\n ;u.x*=m.y\n ;float g=cos(iTime)//;g=.1//a 3rd domain as time for demoing, whould actually be constant\n ;c=gradVis(c,u,v)\n ;return c;}\n\nvoid mainImage(out vec4 O, vec2 u){\n ;u=fra(u)\n ;vec2 m=fra(iMouse.xy)//;vec2 n=fra(iMouse.zw) \n //;O=vec4(glyphs(u,m),1)\n ;vec3 p=vec3(1)\n ;float h=1.;h=cos(iTime)//demo flimmer clear rainbow with change over time\n ;p=(1.+vec3(-1,0,1)*h)*128./iResolution.x//demo flimmer clear rainbow\n ;vec3 c=rainbowN(u,m,p)\n ;O=vec4(c,1) ;}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XldcWN.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[784, 1354, 1367, 1367, 1388], [1388, 1388, 1401, 1401, 1422], [1423, 1423, 1436, 1436, 1452], [1452, 1468, 1481, 1481, 1502], [1502, 1502, 1515, 1515, 1542], [1542, 1542, 1555, 1555, 1588], [1783, 1783, 1801, 1801, 1872], [5844, 5951, 5992, 5992, 6036], [6037, 6037, 6065, 6065, 6126], [6127, 6127, 6173, 6173, 6209], [6209, 6219, 6254, 6254, 6639], [6641, 6872, 6893, 6893, 6983], [6984, 6984, 7014, 7014, 7040], [7041, 7095, 7117, 7117, 7156], [7158, 7158, 7185, 7185, 7265], [7265, 7326, 7356, 7356, 7391], [7391, 7418, 7449, 7449, 7483], [7483, 7602, 7633, 7633, 7675], [7707, 8017, 8054, 8054, 8670], [8672, 8672, 8707, 8707, 8999]], "test": "untested"}
{"id": "XldyDM", "name": "runic spiral", "author": "FabriceNeyret2", "description": "glue a simplified version of otaviogood runes + parameterized spiral.\n( mouse changes glyph seeds )", "tags": ["tuto", "short"], "likes": 5, "viewed": 467, "published": "Public API", "date": "1532877613", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float BUMP = 1.;\n\n// Glyphs simplified from \"runes\" by otaviogood. https://shadertoy.com/view/MsXSRn\n// Spiral from from https://shadertoy.com/view/XdKfz3\n\nvec2 R;\n#define S(d,r) smoothstep( r, 0., d)      // antialiased draw. r >= 1.5\n\nfloat line(vec2 p, vec2 a,vec2 b) { // from https://www.shadertoy.com/view/4dcfW8\n    p -= a, b -= a;\n\tfloat h = clamp(dot(p, b) / dot(b, b), 0., 1.);   // proj coord on line\n\treturn length(p - b * h);                         // dist to segment\n}\n\n\n// makes a rune in the 0..1 uv space. Seed is which rune to draw.\nfloat Rune(vec2 U, vec2 seed)\n{\n\tfloat d = 1e5;\n\tfor (int i = 0; i < 4; i++)\t// number of strokes\n\t{\n        vec4 pos = vec4( texture(iChannel1, (seed)    / iChannelResolution[1].xy).xy,\n\t\t                 texture(iChannel1, (seed+1.) / iChannelResolution[1].xy).xy \n                        );\n\t\tseed += 2.;\n\t\t// expand the range and mod it to get a nicely distributed random number - hopefully. :)\n\t\tpos = fract(pos * 128.);\n\n\t\t// each rune touches the edge of its box on all 4 sides\n\t\tif (i == 0) pos.y = .0;\n\t\tif (i == 1) pos.x = .999;\n\t\tif (i == 2) pos.x = .0;\n\t\tif (i == 3) pos.y = .999;\n\t\t// snap the random line endpoints to a grid 2x3\n\t\tvec4 snaps = vec4(2, 3, 2, 3);\n\t\tpos = ( floor(pos * snaps) + .5) / snaps;\t\n\n\t\td = min(d, line(U, pos.xy, pos.zw + .001) ); // closest line\n\t}\n    return S( d, max( BUMP==0. ? .1 : .2, 40./R.y) );\n}\n\n\nvoid mainImage( out vec4 O, vec2 U )\n{\n    R = iResolution.xy;\n    U = ( U+U - R ) / R.y;                           // normalized coordinates\n    U *=  mat2(cos( -iTime/4. + vec4(0,33,11,0)));   // rotation from https://www.shadertoy.com/view/XlsyWX\n    BUMP = mod(floor(iTime/3.),2.);\n    \n    // --- spiral\n    float r = .5,                                    // circle radius\n          n = 2.,                                    // glyph density\n          l = length(U),                             // polar coordinates\n          a = atan(U.y,U.x);// -iTime/4.;\n    l *= 4.;                                         // spiral zoom\n    r = l - a/6.283;                                 // ceil() = spire number\n    a += 6.283 * (ceil(r)-.5);                       // extended polar angle\n    a = a*a/2.;                                      // param along spiral : int 0..a { r(a).da }\n  //a -= iTime*4.;\n    a *= n/6.283;\n    float u = fract( a ),                            // local coordinates in\n          v = fract( r ),                            // cells along the circle\n          i = floor( a );                            // cell number\n    // ---\n    \n    v *= 1.2; R.y *= 1.2;                            // spacing\n    \n    O = .2+.7*texture(iChannel2,U/2.);               // background\n\tU = vec2(u,v);\n    if (BUMP==0.)\n        U -= .3*texture(iChannel0, vec2(a,r)*3.).xy; // (optional) distortion\n      //U -= .1*texture(iChannel0, vec2(a,r)/5.).xy; // (optional) distortion\n\n    v = Rune(  U, vec2(i,0)+iMouse.xy );\n    if (i>1.)\n        O += BUMP==0. ? -.2* v\n                      : .002* dot(vec2(dFdx(v),dFdy(v))*R.y, vec2(0,1) ) ;   \n}", "image_inputs": [{"id": "4sXGRn", "previewfilepath": "/media/ap/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg", "ctype": "texture"}, {"id": "XdXGzn", "previewfilepath": "/media/ap/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png", "ctype": "texture"}, {"id": "Xsf3Rr", "previewfilepath": "/media/ap/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XldyDM.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[18, 237, 272, 318, 483], [486, 552, 583, 583, 1395], [1398, 1398, 1436, 1436, 3053]], "test": "untested"}
{"id": "XldyzM", "name": "Landscape with holes", "author": "pthextract", "description": "Landscape with warped donuts. Buildt ontop of IQs code.", "tags": ["landscape", "iq", "donuts"], "likes": 0, "viewed": 100, "published": "Public API", "date": "1532033665", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Created by Beautypi/2015\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n\n\nfloat cosNoise( in vec2 p )\n{\n    return 0.5*( sin(p.x) + sin(p.y) );\n}\n\nconst mat2 m2 = mat2(1.6,-1.2,\n                     1.2, 1.6);\n\nfloat sdTorus( vec3 p, vec2 t )\n{\n    return .5*length(p.zx-t)-.1*sin(p.y)-.3;\n    \n\n}\n\nfloat sdTorus2( vec3 p, vec2 t )\n{\n   \n    \n  return .75*length( vec2(length(p.xz)-t.x,p.y) )-t.y;\n}\n\n\nfloat smin( float a, float b, float k )\n{\n\tfloat h = clamp( 0.5 + 0.5*(b-a)/k, 0.0, 1.0 );\n\treturn mix( b, a, h ) - k*h*(1.0-h);\n}\n\nfloat map( in vec3 pos )\n{\n    float h = 0.0;\n    vec2 q = pos.xz*0.5;\n    \n    float s = .5;\n    for( int i=0; i<12; i++ )\n    {\n        h += s*cosNoise( q ); \n        q = m2*q*0.85; \n        q += vec2(2.41,8.13);\n        s *= 0.48 + 0.2*h;\n    }\n    h *= 2.0;\n    \n    float d1 = pos.y - h;\n    \n    // rings\n    vec3 r1 = mod(5.1+pos+5.0,10.0)-5.0;\n    r1.y = pos.y-0.5 - -2.*h;//+ .2*sin( 3.0*iTime+pos.x + 3.0*pos.z);\n    float d2 =sdTorus( r1.xzy, vec2(4.0,0.7) );\n    d2=smin(d2,sdTorus2( r1.xzy, vec2(4.0,0.7) ),1.);\n    \n    return smin( d1, d2, 1.0 );\n}\n\nfloat mapH( in vec3 pos )\n{\n    float h = 0.0;\n    vec2 q = pos.xz*.5;\n    \n    float s = 0.5;\n    for( int i=0; i<12; i++ )\n    {\n        h += s*cosNoise( q ); \n        q = m2*q*0.85; \n        q += vec2(2.41,8.13);\n        s *= 0.48 + 0.2*h;\n    }\n    h *= 3.0;\n    \n    float d1 = pos.y - h;\n    \n    // rings\n    vec3 r1 = mod(2.3+pos+5.0,10.0)-5.0;\n    r1.y = pos.y-0.1 - 0.7*h;// + 0.5*sin( 3.0*iTime+pos.x + 3.0*pos.z);\n    \n    \n    \n    return smin( d1, sdTorus( r1.xzy, vec2(1.0,0.05) ), 1.0 );\n}\n\nvec3 calcNormal( in vec3 pos )\n{\n    vec2 e = vec2(1.0,-1.0) * 0.001;\n    \n    return normalize( e.xyy*mapH( pos + e.xyy ) + \n\t\t\t\t\t  e.yyx*mapH( pos + e.yyx ) + \n\t\t\t\t\t  e.yxy*mapH( pos + e.yxy ) + \n\t\t\t\t\t  e.xxx*mapH( pos + e.xxx ) );\n}\n\nfloat softShadows( in vec3 ro, in vec3 rd )\n{\n    float res = 1.0;\n    float t = 0.01;\n    for( int i=0; i<64; i++ )\n    {\n        vec3 pos = ro + rd*t;\n        float h = map( pos );\n        res = min( res, max(h,0.0)*164.0/t );\n        if( res<0.001 ) break;\n        t += h*0.5;\n    }\n    \n    return res;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 p = fragCoord.xy / iResolution.xy;\n    vec2 q = (-iResolution.xy + 2.0* fragCoord.xy) / iResolution.y;\n    \n    float ani = -20.0 + iTime*15. ;\n    \n    // ray\n    vec3 ro = vec3(-9.*cos(.3+ani/20.), 3.+ani/100.+1.36*cos(ani/10.)+3.0,-ani* 0.5 );\n    \n    float roll = (0.4+.015*cosNoise(9.*vec2(100.*ani+5.5,33.*ani)))*sin(0.05*ani);\n    q = mat2( cos(roll), -sin(roll), sin(roll), cos(roll) ) * q;\n    \n    vec3 rd = normalize( vec3(q-vec2(-0.4,0.4),-2.0) );\n    \n    vec3 col = vec3( 0.6, 0.8, 1.0 );\n    col *= 1.0 - 0.5*rd.y;\n\n    // raymarcher\n    float tmax = 99.0;\n    float t = 0.0;\n    for( int i=0; i<222; i++ )\n    {\n        vec3 pos = ro + rd*t;\n        float h = map( pos );\n        if( h<0.001 || t>tmax ) break;\n        t += h*0.5;\n    }\n\n    vec3 light = normalize( vec3( 1.0, 0.5, -1.0) );\n    // hit\n    if( t<tmax )\n    {\n        // shade and light\n        vec3 pos = ro + t*rd;\n        vec3 nor = calcNormal( pos );\n        \n        float bak = clamp( dot(nor,normalize(-vec3(light.x,0.0,light.z))), 0.0, 1.0 );\n        float dif = clamp( dot(nor,light), 0.0, 1.0 );\n        float sha =softShadows( pos+nor*.01, light );\n        vec3 lig = vec3(2.0,1.5,1.0)*dif*1.5*sha;\n             lig += vec3(0.2,0.3,0.4)*max(nor.y,0.0)*0.9;\n             lig += vec3(0.1,0.1,0.1)*bak*0.5;\n        vec3 mate = vec3(0.3,0.3,0.3)*0.5;\n        mate = mix( mate, vec3(0.2,0.15,0.1)*0.73, smoothstep( 0.7,0.9,nor.y) );\n        mate *= 0.5 + texture( iChannel0, 0.5*pos.xz ).x*1.0;\n \n        col = mate * lig;\n\n        float fog = exp( -0.0005*t*t );\n        col *= fog;\n        col += (1.0-fog)*vec3(0.5,0.6,0.7);\n    }\n\n    float sun = clamp( dot(rd,light), 0.0, 1.0 );\n    col += vec3(1.0,0.8,0.6)*0.4*pow(sun,16.0);\n    col += vec3(1.0,0.8,0.6)*0.3*pow(sun,8.0);\n    \n    col = sqrt( col );\n    \n    col *= 0.5 + 0.5*pow(16.0*p.x*p.y*(1.0-p.x)*(1.0-p.y),0.2);\n    \n    col = smoothstep( 0.0, 1.0, col );\n\n    col = mix( col, vec3(dot(col,vec3(0.33))), -0.25 );\n    \n\tfragColor = vec4( col, 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XldyzM.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0 AND proprietary-license", "functions": [[0, 99, 128, 128, 170], [236, 236, 269, 269, 322], [324, 324, 358, 358, 424], [427, 427, 468, 468, 557], [559, 559, 585, 585, 1122], [1124, 1124, 1151, 1151, 1629], [1631, 1631, 1663, 1663, 1866], [1868, 1868, 1913, 1913, 2176], [2179, 2179, 2236, 2236, 4246]], "test": "untested"}
{"id": "XltcRM", "name": "line drawing as it used to be ", "author": "JohanFlod", "description": "I was watching a Youtube video with Martijn \"The Art of Code\" Steinrucken and I got inspired to do something with the Line and DistLine functions that he used.    ", "tags": ["intro", "amiga", "c64", "demo"], "likes": 4, "viewed": 342, "published": "Public", "date": "1532029122", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n\n#define S(a,b,t) smoothstep(a,b,t)\n#define TWO_PI 6.28318530718\n#define MAX_LINES 64\n\nfloat DistLine(vec2 p, vec2 a, vec2 b){\n\tvec2 pa = p-a;\n    vec2 ba = b-a;\n    float t = clamp(dot(pa, ba)/dot(ba, ba),0., 1.);\n    return length(pa-ba*t);\n}\n\n\nfloat Line(vec2 p, vec2 a, vec2 b){\n\tfloat d = DistLine(p,a,b);\n    float m = 0.5*S(.04,.02,d);\n    \n    return m;\n}\n    \n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\n   \t//float d = DistLine(uv, vec2(0), vec2(1));\n    float m = 0.;\n    \n    uv *=5.;\n    \n    for(int i = 0;i<MAX_LINES;i++)\n    {\n        float j = float(i);\n        float max_lines = float(MAX_LINES);\n        // inner points\n        float x = 2.1*sin(iTime*.5)*sin((j*TWO_PI)/max_lines+iTime);\n  \t\tfloat y = 2.2*cos(iTime)*cos((j*TWO_PI)/max_lines+iTime);\n        // outer points\n        float x2 = 1.0*sin(iTime)*sin((j*TWO_PI)/max_lines+iTime*2.);\n  \t\tfloat y2 =1.3*cos((j*TWO_PI)/max_lines+iTime+.5);\n    \tm+=Line(uv,vec2(x,y),vec2(x2,y2));\n    }\n    vec3 col = vec3(m);\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XltcRM.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[88, 88, 127, 127, 245], [248, 248, 283, 283, 364], [371, 371, 428, 428, 1096]], "test": "untested"}
{"id": "XltyD7", "name": "SimplestDrawer", "author": "dmitrico", "description": "Just first shader", "tags": ["draw", "firstshader", "learn"], "likes": 2, "viewed": 99, "published": "Public", "date": "1532894232", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xx;\n    vec2 zw = iMouse.xy/iResolution.xx;\n    float e = 10./iResolution.x;\n\n    // Time varying pixel color\n    vec3 col ;//= vec3(0.,0.,0.);\n    if (iTime <= 1.)\n    {\n    \tcol = vec3(0.);\n        fragColor = vec4(col,1.0);\n        return;\n    }\n    if (length(uv-zw) > e)\n    {\n\t    discard;\n    }\n    col = vec3(1.,1.,1.);\n    // Output to screen\n\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XltyD7.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 107, 529]], "test": "untested"}
{"id": "XsGBDd", "name": "Smoothstep example", "author": "Lazzux", "description": "An example of smoothstepping of colors with SDF font rendering.", "tags": ["smoothstep"], "likes": 2, "viewed": 916, "published": "Public", "date": "1530970758", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec4 color1 = vec4(0.0, 0.0, 0.0, 1.0);\nvec4 color2 = vec4(1.0, 0.0, 1.0, 1.0);\nvec4 color3 = vec4(1.0, 1.0, 0.0, 1.0);\nvec4 color4 = vec4(0.0, 1.0, 1.0, 1.0);\n\nfloat edge1Pos = 0.25;\nfloat edge22Pos = 0.5;\nfloat edge3Pos = 0.75;\n\n// Change this to see how it affects the edge. Too low value = pixelated, too large value = gradients\nfloat edgeSize = 0.001;\n\nfloat pxRange = 2.0;\n\nfloat median(float r, float g, float b) {\n    return max(min(r, g), min(max(r, g), b));\n}\n\nfloat GetSDFValue(vec2 uv)\n{\n    vec2 msdfUnit = pxRange/vec2(textureSize(iChannel0, 0));\n    vec3 texel = texture(iChannel0, uv).rgb;\n    float sigDist = median(texel.r, texel.g, texel.b) - 0.5;\n    sigDist *= dot(msdfUnit, 0.5/fwidth(uv));\n    return clamp(sigDist + 0.5, 0.0, 1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    //float fromSDFTexel = uv.x;\n    float fromSDFTexel = uv.x + sin((iTime + uv.y + uv.x * cos(iTime)) * 2.0) * 0.05;\n    //float fromSDFTexel = GetSDFValue(uv); // if only there were SDF texture\n    \n    float firstColorChange = smoothstep(edge1Pos - edgeSize, edge1Pos + edgeSize, fromSDFTexel);\n    float secondColorChange = smoothstep(edge22Pos - edgeSize, edge22Pos + edgeSize, fromSDFTexel);\n    float thirdColorChange = smoothstep(edge3Pos - edgeSize, edge3Pos + edgeSize, fromSDFTexel);\n    \n    vec4 pixelColor = mix(mix(color1, color2, firstColorChange), mix(color3, color4, thirdColorChange), secondColorChange);\n\n    // Output to screen\n    fragColor = pixelColor;\n}", "image_inputs": [{"id": "4dfGRn", "previewfilepath": "/media/ap/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XsGBDd.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[231, 380, 421, 421, 469], [471, 471, 499, 499, 757], [759, 759, 816, 866, 1591]], "test": "untested"}
{"id": "XsGBWd", "name": "columns 7: twisted sinus-stars", "author": "FabriceNeyret2", "description": "sinus-stars + smoothing top. twisted along axis. \nSee comments for more accuracy ( gradient normalization + opt )\n", "tags": ["raymarching", "sdf", "short"], "likes": 1, "viewed": 359, "published": "Public API", "date": "1530958170", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// variant of https://shadertoy.com/view/4dGBWd\n// smooth op from http://iquilezles.org/www/articles/smin/smin.htm\n\n#define K 4.\n#define exp(x) exp(min(30.,x))\n#define smin(a,b) -log( exp( -K*(a) ) + exp( -K*(b) ) ) / K\n#define smax(a,b) -(smin(-(a),-(b))) \n\nvoid mainImage(out vec4 O, vec2 U) {\n    \n    float t = iTime, z,l,g=1.,i,a, r0=1.,r, h=6.;// r: radius h: height/2.\n    mat2  R = mat2( sin(t+vec4(0,33,11,0)) );\n    vec3  q = iResolution,\n          D = normalize(vec3(.3*(U+U-q.xy)/q.y, -1)),// ray direction\n          p = 30./q, q0;                         // marching point along ray\n\n    O-=O;\n    for ( O++; O.x > 0. && t > .01 ; O-=.015 ) {\n        q = p,\n        q.xz *= R, q.yz *= R,                    // rotation\n        i = 3. + floor(abs(q.x/6.))*2. + float(q.y>0.); // column id\n        q0 = q; z = q.z;\n        q.x = mod(q.x,6.)-3.,                    // repeat in x\n        q.y = abs(q.y)-5.;                       // 2 rows\n        q.z = mod(q.z,3.) - 1.5,                 // vertical blocks\n        l = length(q.xy);\n        r = r0;\n      //if (l<1.5*r) {\n        a = atan(q.y,q.x) + z;                   // twist\n        r = 1.+.2*sin(i*a);                      // radius\n        //g = 1.+.2*r0*i*1.41;                   // grad(dist) <= 1.+|dr/dzt|\n      //} else g=1.;\n            \n         \n        t = (l -r) / g;             // smooth square column radius decreasing with z\n        if (q0.y>0.) t = smax(t,abs(q.z)-1.5);   // blocks top\n        t = max(t,abs(z) -h),                    // inter range of Z\n\n        p += t*D;                                // step forward = dist to obj\n    }\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XsGBWd.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 259, 295, 295, 1625]], "test": "untested"}
{"id": "XsGfWV", "name": "ACES Cinematic Tonemapping", "author": "afl_ext", "description": "Great tonemap, check it out in your projects, adds a lot of movie-look-alike :) Top is not tonemapped, bottom is tonemapped.", "tags": ["tonemapping", "tonemap", "cinematic", "aces"], "likes": 22, "viewed": 1609, "published": "Public API", "date": "1530436580", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Based on http://www.oscars.org/science-technology/sci-tech-projects/aces\nvec3 aces_tonemap(vec3 color){\t\n\tmat3 m1 = mat3(\n        0.59719, 0.07600, 0.02840,\n        0.35458, 0.90834, 0.13383,\n        0.04823, 0.01566, 0.83777\n\t);\n\tmat3 m2 = mat3(\n        1.60475, -0.10208, -0.00327,\n        -0.53108,  1.10813, -0.07276,\n        -0.07367, -0.00605,  1.07602\n\t);\n\tvec3 v = m1 * color;    \n\tvec3 a = v * (v + 0.0245786) - 0.000090537;\n\tvec3 b = v * (0.983729 * v + 0.4329510) + 0.238081;\n\treturn pow(clamp(m2 * (a / b), 0.0, 1.0), vec3(1.0 / 2.2));\t\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 position = (fragCoord/iResolution.xy)* 2.0 - 1.0;\n    position.x += iTime * 0.2;\n\n\tvec3 color = pow(sin(position.x * 4.0 + vec3(0.0, 1.0, 2.0) * 3.1415 * 2.0 / 3.0) * 0.5 + 0.5, vec3(2.0)) * (exp(abs(position.y) * 4.0) - 1.0);;\n\n\tif(position.y < 0.0){\n\t\tcolor = aces_tonemap(color);   \n\t}\n\n\tfragColor = vec4(color,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XsGfWV.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 76, 106, 106, 553], [555, 555, 612, 612, 940]], "test": "untested"}
{"id": "XsKBDK", "name": "chipchop", "author": "lennyjpg", "description": "asasfasfdas", "tags": ["asdfasfds"], "likes": 7, "viewed": 423, "published": "Public API", "date": "1530558078", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.y -0.5;\n\n    float d = length(uv);\n    float t = iTime*0.07;\n    uv*=100.0;\n    float e = abs(uv.x) + abs(uv.y) - t;\n    float g = length(abs(uv)+1.1)*0.2;\n    float k =  fract(  sin(  fract(sin(  fract(sin( e  )) * g )) * 3.7 )*1.01)*e*sin(iTime*0.2)*5.0;\n    fragColor = vec4(k);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XsKBDK.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 377]], "test": "untested"}
{"id": "XsKBWV", "name": "Problem of Apollonius, splitview", "author": "mv", "description": "The Problem of Apollonius is a famous geometry problem from antiquity, named after Apollonius of Perga. It can be stated as \"Given three circles, find a fourth circle that is simultaneously tangent to the other circles.\" \n\nSee comments for more.", "tags": ["circles", "math", "geometry", "tangent", "split", "apollonius"], "likes": 14, "viewed": 709, "published": "Public API", "date": "1530567305", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/*\n\tThe Problem of Apollonius is a famous geometry problem from antiquity, \n    named after Apollonius of Perga. It can be stated as \n\n\t\t\"Given three circles, find a fourth circle that is simultaneously \n\t\t tangent to the other circles.\" \n\n\tThe problem is equivalent to finding the the simultaneous solution of \n    three quadratic equations:\n\n\t\t(x - x_1)² + (y - y_1)² = (r - s_1*r_1)²\n\t\t(x - x_2)² + (y - y_2)² = (r - s_2*r_2)²\n\t\t(x - x_3)² + (y - y_3)² = (r - s_3*r_3)²\n\n\tfor some combination of signs s_1, s_2 and s_3. \n\n\tThe signs decide if the tangency is *external* (i.e. the solution \n\tcircle touches the other circle on the outside), or if it is internal \n\t(i.e. the solution circle touches the other circle on the inside. \n\n\tThrough the last couple millennia a myriad of solution strategies has\n\tbeen introduced, many of them geometric (solved with a compass and\n\tstraight edge). The solution used here is a purely arithmetic one. \n\n\tFor more information on this solution strategy, see\n\t\n\t\thttps://www.sharelatex.com/read/mxqspwvsbhny\n\n\t---\n\n\tIn this shader we show all 4 solution pairs at the same time in four\n\tseparate panels. This is less cluttered than showing all 8 solutions\n\tat the same time. The two solutions in each panel is related to each\n\tother by a simple sign change, turning every externally tangent\n\tcircle into internally tangent, and vice-versa. \n\t\n\t---\n\n\tSome caveats:\n\n\t\t1. The number of unique solutions is at most 8. If some circles\n\t\t   overlap, or if the radius of one or more circles become \n\t\t   zero (a point) or infinite (a line), multiple solutions \n\t\t   become the same. \n\t\t\n\t\t2. The solution might result in a negative radius. This still\n\t\t   results in a drawable circle if one uses the absolute value,\n\t\t   but externally tangent circles becomes internally tangent, \n\t\t   and vice-versa. \n\n\t\t3. Due to the quadratic nature of the equations there are always\n\t\t   two solutions of the radius (as long as they are not complex). \n\t\t   This means that flipping all the tangency signs gives the same\n\t\t   pair of solutions, only with their order interchanged and the\n           sign flipped. \n*/\n\n// declarations\nfloat sdDisk(vec2 p, float r);\nfloat sdCircle(vec2 p, float r, float t);\n\nvec3 compose(vec3 old, vec3 col, float d);\n\nfloat perpdot(vec2 u, vec2 v);\nvoid solveApollonius(in vec2 P1,  in vec2 P2,  in vec2 P3, \n                     in float s1, in float s2, in float s3, \n                     in float R1, in float R2, in float R3, \n                     out vec2 p1, out vec2 p2, \n                     out float r1, out float r2);\n\n#define ANIMATE\n\n\n//\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    // constants\n    vec2 C1 = vec2(-0.45, -0.45);\n    vec2 C2 = vec2( 0.5, -0.55);\n    vec2 C3 = vec2( 0.0,  0.55);\n    \n    #ifdef ANIMATE\n    C1 = C1 - 0.2*vec2(sin(iTime), cos(iTime));\n\t#endif \n    \n    float R1 = 0.3;\n    float R2 = 0.4;\n    float R3 = 0.5;\n\n    // split into 4 panels, 2x2\n    vec2 res = 0.5*iResolution.xy;\n    vec2 coord = mod(fragCoord.xy, res);\n\n    // integers to identify subwindows\n    uvec2 xy = uvec2(2.0*(fragCoord.xy/iResolution.xy));\n\n    // aspect-ratio corrected position in each panel\n    vec2 uv = (2.0 * coord - res)/res.yy;\n    uv *= 1.2;\n    \n\n    // background color\n    vec3 col = vec3(1.0);\n    \n    // base circles\n    col = compose(col, vec3(0.0), sdCircle(uv - C1, R1, 0.01));\n    col = compose(col, vec3(0.0), sdCircle(uv - C2, R2, 0.01));\n    col = compose(col, vec3(0.0), sdCircle(uv - C3, R3, 0.01));\n    \n    // apollonius circles\n    vec2 p1, p2;\n    float r1, r2;\n    if (xy == uvec2(0, 0)) {\n        // blue: externally tangent to all circles\n        // red:  internally tangent to all circles\n    \tsolveApollonius(C1, C2, C3, 1.0, 1.0, 1.0, R1, R2, R3, p1, p2, r1, r2);\n    } else if (xy == uvec2(1, 0)) {\n        // blue: first circle internally tangent, rest externally tangent\n        // red:  first circle extnally tangent, rest internally tangent\n    \tsolveApollonius(C1, C2, C3, -1.0, 1.0, 1.0, R1, R2, R3, p1, p2, r1, r2);\n    } else if (xy == uvec2(0, 1)) {\n        // blue: second circle internally tangent, rest externally tangent\n        // red:  second circle extnally tangent, rest internally tangent\n    \tsolveApollonius(C1, C2, C3, 1.0, -1.0, 1.0, R1, R2, R3, p1, p2, r1, r2);\n    } else if (xy == uvec2(1, 1)) {\n        // blue: third circle internally tangent, rest externally tangent\n        // red:  third circle extnally tangent, rest internally tangent\n    \tsolveApollonius(C1, C2, C3, 1.0, 1.0, -1.0, R1, R2, R3, p1, p2, r1, r2);\n    }\n    col = compose(col, vec3(1.0, 0.0, 0.0), sdCircle(uv - p1, abs(r1), 0.01)); \n    col = compose(col, vec3(0.0, 0.0, 1.0), sdCircle(uv - p2, abs(r2), 0.01)); \n    \n    \n    // borders for each subwindow\n    if (coord.x < 1.0 || \n        coord.y < 1.0 || \n        coord.x >= res.x-2.0 || \n        coord.y >= res.y-2.0 ||\n        fragCoord.x < 3.0 || \n        fragCoord.y < 3.0 || \n        fragCoord.x >= iResolution.x-3.0 || \n        fragCoord.y >= iResolution.y-3.0) {\n    \tcol = vec3(0.0);   \n    }\n    \n    fragColor = vec4(col,1.0);\n}\n\n\n//\nfloat sdDisk(vec2 p, float r) {\n    return length(p) - r;\n}\n\nfloat sdCircle(vec2 p, float r, float t) {\n    return abs(length(p) - r) - t;\n}\n\nvec3 compose(vec3 old, vec3 col, float d) {\n    float w = 1.5*fwidth(d);\n    float s = smoothstep(-w/2.0, w/2.0, d);\n    return old*s + col*(1.0 - s);\n}\n\n\nfloat perpdot(vec2 u, vec2 v) {\n \treturn u.x*v.y - u.y*v.x;   \n}\n\nvoid solveApollonius(in vec2 P1,  in vec2 P2,  in vec2 P3, \n                     in float s1, in float s2, in float s3, \n                     in float R1, in float R2, in float R3, \n                     out vec2 p1, out vec2 p2, \n                     out float r1, out float r2) {\n    // see https://www.sharelatex.com/read/mxqspwvsbhny\n    \n    // NOTE: optimized by shifting one of the points to the origin\n    P1 = P1 - P3;\n    P2 = P2 - P3;\n    \n    float A1 = (dot(P1, P1) - R1*R1 + R3*R3)/2.0;\n    float A2 = (dot(P2, P2) - R2*R2 + R3*R3)/2.0;\n    \n    float B1 = (s1*R1 - s3*R3);\n    float B2 = (s2*R2 - s3*R3);\n    \n    float D = perpdot(P1, P2);\n    \n    float M = (A1*P2.y - A2*P1.y)/D;\n    float N = (B1*P2.y - B2*P1.y)/D;\n    float P = (-A1*P2.x + A2*P1.x)/D;\n    float Q = (-B1*P2.x + B2*P1.x)/D;\n    \n    float a = N*N + Q*Q - 1.0;\n    float b = 2.0*(M*N + P*Q + s3*R3);\n    float c = M*M + P*P - R3*R3;\n    \n    // WARNING: Complex solutions? \n    r1 = (-b - sqrt(b*b - 4.0*a*c))/(2.0*a);\n    r2 = (-b + sqrt(b*b - 4.0*a*c))/(2.0*a);\n    \n    p1 = P3 + vec2(M + N*r1, P + Q*r1);\n    p2 = P3 + vec2(M + N*r2, P + Q*r2);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XsKBWV.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[2609, 2612, 2669, 2686, 5123], [5126, 5129, 5160, 5160, 5188], [5190, 5190, 5232, 5232, 5269], [5271, 5271, 5314, 5314, 5423], [5426, 5426, 5457, 5457, 5490], [5492, 5492, 5772, 5900, 6627]], "test": "untested"}
{"id": "XsKfD3", "name": "Wave Function", "author": "Nischi", "description": "Basic Sinus of time and x-coordinate", "tags": ["sinus"], "likes": 2, "viewed": 160, "published": "Public", "date": "1530813679", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Wave Coefficients\nfloat k = 4.;\nfloat w = 5.;\nfloat A = 0.3;\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (x: from -pi to pi, y: from -1 to 1)\n    float pi = acos(-1.);\n    vec2 uv = (2.*fragCoord-iResolution.xy)/iResolution.xy*vec2(pi,1);\n    \n    //Plot of the Wave\n    float dWave = A*sin(w*iTime-k*uv.x)-uv.y;\n    bool thisPixelIsColored = abs(dWave)<0.03;\n\n    // Output to screen\n    fragColor = vec4(0,vec2(thisPixelIsColored),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XsKfD3.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 67, 124, 197, 496]], "test": "untested"}
{"id": "XsKfWt", "name": "Sunrise Sunset and Sine Waves", "author": "JohanFlod", "description": "continued work on the parallax waves. ", "tags": ["2d", "waves", "fun", "summer"], "likes": 7, "viewed": 230, "published": "Public", "date": "1531051843", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\nconst int NUM_WAVES = 5;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 st = fragCoord/iResolution.xy;\n    \n   \tfloat wave1;\n    vec3 colour = vec3(0.5);\n    st.x=8.0*st.x-2.8;\n    st.y=5.0*st.y-1.8;\n    float combined_colour;\n    // the sun body\n    \n    float moving_sun = 2.5*abs(sin(0.2*iTime))-0.8;\n    float dist_sun = (distance(st,vec2(0.,moving_sun)));\n    float sun_colour= (smoothstep(0.2,0.55,1.-dist_sun));\n   \t\n   \n    // glow from the sun\n    float glow_size = (dist_sun/3.0);\n    float glow_frequence = abs(cos(.2*iTime));\n    float glow_intensity = abs(cos(.2*iTime));\n   \n    float strength = 0.5;\n    \n    float glow =strength*(1.- glow_intensity*glow_frequence*glow_size);\n   \n    // combine sun and the glow from the sun\n    \n    combined_colour= mix(glow,0.6+0.9*st.y/2.5,sun_colour);\n    colour= vec3(combined_colour);\n    \n  \n  \t\n    vec3 grey=vec3(.5);\n    for(int j = NUM_WAVES; j >0; j--)\n    {\n        float i = float(j);\n    \tfloat wave_input= .6/(2.5*i)*(sin(+iTime))*(sin(0.5*(i*.432)*st.x*4.+iTime*.8+st.y))-.8/i-1.+1.;\n    \twave1 = smoothstep(wave_input-0.1/i,wave_input,st.y);\n        colour.b = mix((1.-st.y/2.5)*(.15*i)*(1.-0.5*abs(cos(.2*iTime))),colour.b,wave1);\n    }\n\t\n    colour = vec3(colour.b);\n\t\n    fragColor = vec4(colour,1.0);\n}\n\n\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XsKfWt.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[27, 27, 84, 84, 1296]], "test": "untested"}
{"id": "XsyfDK", "name": "Distorted rectangle zoom ", "author": "JohanFlod", "description": "Doing \"blur\" with a smoothstep function. Not correct but it is fast :) ", "tags": ["zoom", "rectangle"], "likes": 1, "viewed": 79, "published": "Public", "date": "1530409221", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec2 uv;\nvec3 color;\nfloat speed = 10.;\n#define PI 3.14159265359\n\nvec3 rectangle(in vec2 size,in vec3 colour)\n{\n\tsize = 2.5 - size;\n    float dist = (distance(uv,vec2(2.5)))/2.5; \n    dist/=2.5;\n    \n    vec2 bl = smoothstep(size-dist,size+dist,uv);\n    vec2 tr = smoothstep(size-dist,size+dist,5.0-uv);\n  \n    return vec3(bl.x * bl.y * tr.x * tr.y*colour);\n\t\n}\n\nmat2 rotate2d(float _angle){\n    return mat2(cos(_angle),-sin(_angle),\n                sin(_angle),cos(_angle));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    uv = fragCoord.xy/iResolution.xy;\n    uv*=5.0;\n\t\n    vec2 size;\n    vec2 size2;\n    vec2 size3;\n    vec3 grey = vec3(0.5);\n    \n    size.y = 2.5*fract(iTime/5.0);\n    size.x = 2.5*fract(iTime/5.0);\n    \n    size2.y = 2.5*fract(iTime/5.+.33);\n    size2.x = 2.5*fract(iTime/5.+.33);\n    \n    size3.y = 2.5*fract(iTime/5.+.66);\n    size3.x = 2.5*fract(iTime/5.+.66);\n    \n    // move space from the center to the vec2(0.0)\n    uv -= vec2(1.8);\n    // rotate the space\n    \n   \n    \n    float dist = distance(uv,vec2(2.5)); \n    dist/=2.5;\n    uv = rotate2d((iTime))  * uv;\n    uv = rotate2d((0.5*dist))  * uv;\n    \n    // move it back to the original place\n    uv += vec2(1.8);\n    \n    vec3 red = vec3((2.5-size.y)/2.5,0.,0.0);\n\tvec3 red_rectangle = rectangle(size, red);\n\t\n    vec3 green = vec3(0.0,(2.5-size2.y)/2.5,0.0);\n    vec3 green_rectangle = rectangle(size2, green);\n    \n    vec3 blue = vec3(0.0,0.0,(2.5-size3.y)/2.5);\n    vec3 blue_rectangle = rectangle(size3, blue);\n    \n    fragColor = vec4(grey+red_rectangle+blue_rectangle+green_rectangle,1.0);\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XsyfDK.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[66, 66, 111, 111, 361], [363, 363, 391, 391, 477], [479, 479, 536, 586, 1652]], "test": "untested"}
{"id": "Xt3cRB", "name": "Colores", "author": "DjNaxx", "description": "Cambio de colores", "tags": ["colores"], "likes": 0, "viewed": 65, "published": "Public", "date": "1532960953", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Time varying pixel color\n    vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Xt3cRB.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 107, 294]], "test": "untested"}
{"id": "Xt3yzM", "name": "noise and lines", "author": "lnae", "description": "Some tests. I want to try more noise-based patterns :)", "tags": ["2d", "noise"], "likes": 10, "viewed": 396, "published": "Public API", "date": "1531919904", "time_retrieved": "2021-10-01T00:00:00", "image_code": "mat2 rot(float a){\n\treturn mat2(cos(a), -sin(a), sin(a), cos(a));\n}\n\nfloat hash(vec2 uv){\n\treturn fract(12345. * sin(dot(uv, vec2(12.34, 56.78))));\n}\n\nfloat noise(vec2 uv){\n    vec2 f = fract(uv);\n    f = f * f * (3. - 2. * f);\n    vec2 p = floor(uv);\n    float res = mix(mix(hash(p), hash(p + vec2(1., 0.)), f.x),\n                    mix(hash(p + vec2(0., 1.)), hash(p + vec2(1., 1.)), f.x),\n                    f.y);\n\treturn res;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.x;\n\t\n    float k = 2.;\n    vec2 uvNoise = rot(k + 0.00001 * iTime) * uv * 10. + 0.2 * iTime;\n    float res = 0.;\n   \tfloat c = 0.5;\n    \n    for(int i = 0; i < 10; i++){\n    \tres += c * noise(uvNoise);\n        c /= 2.;\n        uvNoise = rot(k + 0.00001 * iTime) * k * uvNoise + k + iTime;\n    }\n    //res -= 0.5;\n    uv = rot(1.5 * noise(uv * 5. + 0.1 * iTime)) * uv;\n    float line = smoothstep(0., 1., abs(sin(70. * uv.x) + res));\n    line = smoothstep(0., 1., line);\n\n    vec3 col = vec3(line);\n    //vec3 col = vec3(res);\n\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Xt3yzM.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 18, 18, 67], [69, 69, 89, 89, 149], [151, 151, 172, 172, 433], [435, 435, 492, 492, 1115]], "test": "untested"}
{"id": "XtccDr", "name": "Ant", "author": "TLC123", "description": "exoskeleton wit special blend and normal driven noise bumps.\nvery low fps - dropped the bump texture\nI wish it was black", "tags": ["bug", "ant"], "likes": 8, "viewed": 181, "published": "Public", "date": "1532174929", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//Raycaster code credit to Inigo Quilez\n\n vec4 NormQuat(vec4 q)\n{\n    float lenSQ = dot(q, q);\n    float invLenSQ = 1./lenSQ;\n    return q*invLenSQ;\n}\n\nvec4 BuildQuat(vec3 axis, float angle)\n{\n    angle *= 0.5;\n    float s = sin(angle);\n    return NormQuat(vec4(axis*s, cos(angle)));\n}\n\nvec4 MulQuat(vec4 q1, vec4 q2)\n{\n    vec4 res = vec4(0.);\n    res.w   = q1.w*q2.w - dot(q1.xyz, q2.xyz);\n    res.xyz = q1.w*q2.xyz + q2.w*q1.xyz + cross(q1.xyz, q2.xyz);\n    return NormQuat(res);\n}\n\n \n    \nvec3 Rotate(vec4 q, vec3 v)\n{\n    vec3 t = 2.*cross(q.xyz, v);\n    return v + q.w*t + cross(q.xyz, t);\n}\n\n\n\nfloat fromTo(vec3 p,vec3 q)\n{\nreturn acos(dot(p,q));\n\n}\n\nvec4 quatLookAt(vec3 forward,vec3 up){\n    forward=normalize(forward);\n    up=normalize(up);\nreturn BuildQuat(cross(forward,up),fromTo(forward,up));\n}\n\n\nfloat   arandom (float aseed) {return mod( mod(aseed*43758.5453123, 1.9)+aseed* 78.233 ,1.0);}\n\nfloat value_at (float x,float y,float z) {return arandom(arandom(arandom(x)+y)+z);}\n\n\nfloat noise3d(vec3 p) {\n\t  float  px= floor (p.x); \t   float    py= floor (p.y); \t   float    pz= floor (p.z);\n  \t\tfloat\tlbx= smoothstep(0.0,1.0,p.x-px);\t\n  \t\tfloat  lby= smoothstep(0.0,1.0,p.y-py);\t \n \t\t float  lbz= smoothstep(0.0,1.0,p.z-pz);\n\t  \t  float    p0 = value_at (px,  py,  pz);    float    p1 = value_at (px+1.0,py,  pz);\n      \t  float    p2 = value_at (px+1.0,py+1.0,pz);    float    p3 = value_at (px,  py+1.0,pz);\t\t\n      \t  float    p4 = value_at (px,  py,  pz+1.0);  float      p5 = value_at (px+1.0,py,  pz+1.0);\n      \t  float    p6 = value_at (px+1.0,py+1.0,pz+1.0);  float      p7 = value_at (px,  py+1.0,pz+1.0);   \t     \n          float  p01 =mix(p0,p1,lbx);\t\t\t  float  p32 =mix(p3,p2,lbx);\n    \t  float  \tp45 =mix(p4,p5,lbx);\t\t  float  \tp76 =mix(p7,p6,lbx);\n\t\t  float  \tp0132=mix(p01,p32,lby);\t\t  float  \tp4576=mix(p45,p76,lby);  \t \n    float   c1=mix(p0132,p4576,lbz);\n    return    (c1);}\n\n\n\nfloat  synmin(float a,float  b,float  r) {\n\t \n        float  e =   max(r*0.02,(abs(a-b)/r) );\n        return min (a,b)- max(0.01,(r*e*0.75*(exp(1.0-(e*2.5 ))))/max(a,b)*0.5)\n \n            ;}\n\nfloat conecapsule (vec3 p, vec4 p1 ,vec4 p2,float w,float z ) {\nvec3 a=mix(p1.xyz,p2.xyz,0.1);\nvec3 b=mix(p1.xyz,p2.xyz,0.9);\nfloat\t\td1=p1.w;\nfloat\t\td2=p2.w*0.9;\nvec3\t\tba = b - a;\nvec3\t\tpa = p - a;\n    float v= dot(pa,ba) / dot(ba,ba);\nfloat\t\th = clamp(  v,   0.0,   1.0);\nfloat\t\t\td=mix(d1,d2,  smoothstep(0.0,1.0,   h));\n     float r= d ;// / 2.0;\n \n            return length (pa - ba*h) - r;\n\n}\n\n//float conecapsule (vec3 p, vec4 p1 ,vec4 p2 ,float w, float z) {\n\n    \n    \n     // vec3 n=normalize(vec3 (\n     // conecapsule2(p,p1,p2)-conecapsule2(p+vec3(0.001,0.0,0.0) ,p1,p2),\n    //  conecapsule2(p,p1,p2)-conecapsule2(p+vec3(0.0,0.001,0.0),p1,p2 ),\n   //   conecapsule2(p,p1,p2)-conecapsule2(p+vec3(0.0,0.0,0.001),p1,p2 )\n           //   ));\n \n    \n //float bumpb=noise3d(n*w)*z;\n     \n//return conecapsule2 (p,p1,p2) \n //   ; \n//}\n\nfloat antbody(vec3 p)\n{\n    \n    //body defines as basically a string of sticks and spheres. little more to it ofc\nvec4[] body= vec4[](vec4(-5,0,0,1),vec4(-4,0,1,2),vec4(-2,0,2,3),vec4(0,0,2,3),vec4(3,0,2,1),vec4(4,0,1,1),vec4(7,0,4,3),vec4(9,0,5,3),vec4(12,0,4,1),vec4(14,0.5,4,3),vec4(15,2,2,1),vec4(16,0.7,-0.5,0.5));\n\n    \n float oddbod=   \n            min(conecapsule (p, body[1] , body[2] ,2.0,0.125  ),\n            min(conecapsule (p, body[3] , body[4] ,2.0,0.125),\n            min(conecapsule (p, body[5] , body[6] ,2.0,0.125),\n                     min(conecapsule (p, body[9] , body[10] ,2.0,0.125),\n            conecapsule (p, body[7] , body[8] ,2.0,0.25) \n  ))))         ; \n     float evebod=  \n           min(conecapsule (p, body[0] , body[1] ,2.0,0.125),\n            min(conecapsule (p, body[2] , body[3] ,2.0,0.125),\n            min(conecapsule (p, body[4] , body[5] ,2.0,0.125),\n            min(conecapsule (p, body[6] , body[7] ,2.0,0.125),\n            min(conecapsule (p, body[8] , body[9] ,2.0,0.125),\n       \n\n              conecapsule (p, body[10] , body[11] ,2.0,0.125)\n  )))))        ; \n    \n return synmin (oddbod,evebod,0.60);\n\n}\n\n\nfloat antenna(vec3 p)\n{\nvec4[] ant1= vec4[](vec4(14.4062,0.35,5.21244,0.525),vec4(16.4468,1.52811,7.89352,0.49),vec4(18.9311,2.96244,8.66218,0.525),vec4(20.728,3.99987,6.65596,0.525),vec4(21.4749,4.43109,5.34974,0.52));\n float oddant1=   \n            min(conecapsule (p, ant1[1] , ant1[2] ,1.0,0.06),\n             (conecapsule (p, ant1[3] , ant1[4] ,1.0,0.06)\n       ))         ; \n     float eveant1=  \n           min(conecapsule (p, ant1[0] , ant1[1] ,1.0,0.06),\n             (conecapsule (p, ant1[2] , ant1[3] ,1.0,0.06) \n  ))        ; \n    \n    \n\n  return  synmin  (oddant1,eveant1,0.30);\n}\n\nfloat antleg1(vec3 p)\n{\nvec4[] leg1= vec4[](vec4(5.5,0.0,2.5,0.5),vec4(7.03209,1.28558,0.5,0.75),vec4(11.8623,6.49951,2.0,1.0),vec4(11.8623,4.49951,-3.5,0.75),vec4(13.944,5.78509,-5.75,0.65),vec4(15,6.42788,-6,0.5));\n float oddleg1=   \n            min(conecapsule (p, leg1[1] , leg1[2] ,3.0,0.135 ),\n             (conecapsule (p, leg1[3] , leg1[4] ,3.0,0.135 )\n       ))         ; \n     float eveleg1=  \n           min(conecapsule (p, leg1[0] , leg1[1] ,3.0,0.135 ),\n           min(conecapsule (p, leg1[2] , leg1[3] ,3.0,0.135 ),\n             (conecapsule (p, leg1[4] , leg1[5] ,3.0,0.135 ) \n  )))        ; \n    \n    \n\n  return  synmin  (oddleg1,eveleg1,0.50);\n}\nfloat antleg2(vec3 p)\n{\nvec4[] leg1= vec4[](vec4(4.75,0,1.75,0.5),vec4(4.75,2.31691,0.127681,0.75),vec4(4.75,6.89365,2.96554,1),vec4(4.75,7.93554,-2.94331,0.75),vec4(4.75,10.4261,-5.55044,0.75),vec4(4.75,11.4977,-5.86919,0.5));\n float oddleg1=   \n            min(conecapsule (p, leg1[1] , leg1[2] ,3.0,0.135 ),\n             (conecapsule (p, leg1[3] , leg1[4] ,3.0,0.135 )\n       ))         ; \n     float eveleg1=  \n           min(conecapsule (p, leg1[0] , leg1[1] ,3.0,0.135 ),\n           min(conecapsule (p, leg1[2] , leg1[3] ,3.0,0.135 ),\n             (conecapsule (p, leg1[4] , leg1[5] ,3.0,0.135 ) \n  )))        ; \n    \n    \n\n  return  synmin  (oddleg1,eveleg1,0.50);\n}\nfloat antleg3(vec3 p)\n{\nvec4[] leg1= vec4[](vec4(3.5,0.2,0.25,0.5),vec4(1.72499,3.691,-0.26813,0.75),vec4(-3.8651,6.7605,2.8302,1),vec4(-4.66323,6.43022,-3.07865,0.75),vec4(-7.02376,8.41093,-5.58159,0.75),vec4(-8.071,9.28967,-5.84825,0.5));\n float oddleg1=   \n            min(conecapsule (p, leg1[1] , leg1[2] ,3.0,0.135 ),\n             (conecapsule (p, leg1[3] , leg1[4] ,3.0,0.135 )\n       ))         ; \n     float eveleg1=  \n           min(conecapsule (p, leg1[0] , leg1[1] ,3.0,0.135 ),\n           min(conecapsule (p, leg1[2] , leg1[3] ,3.0,0.135 ),\n             (conecapsule (p, leg1[4] , leg1[5] ,3.0,0.135 ) \n  )))        ; \n    \n    \n\n  return  synmin  (oddleg1,eveleg1,0.50);\n}\n\n\nfloat legasm(vec3 p)\n{\n\nreturn\n    min(antenna(p),\n    min(antleg1(p),\n    min(antleg2(p),\n           antleg3(p)\n          \n          )));\n\n}\n        \n\nfloat ant(vec3 p)\n{\n    p=vec3(p.x,abs(p.y),p.z);\n  \n\n      \n    return synmin(antbody(p) ,legasm(p) ,0.60);\n    \n} \n\nvec4 map(vec4 r0)\n{  \n    vec3 p=r0.xyz ;\n    vec4 Q1 = quatLookAt(vec3(sin(iTime),1.,cos(iTime)),vec3(0,1,0));    \n    vec4 Q2 =quatLookAt(vec3(sin(2.*iTime),1.,cos(3.*iTime)),vec3(0,1,0));    \n    vec4 Q=MulQuat(Q1,Q2);\n    p=Rotate(Q, p);\n    \n    \n\n    //  vec3 n=normalize(vec3 (\n      //ant(p )-ant(p+vec3(0.001,0.0,0.0)  ),\n      //ant(p )-ant(p+vec3(0.0,0.001,0.0) ),\n    //ant(p )-ant(p+vec3(0.0,0.0,0.001)  )\n        //     ));\n \n    float bumpb=noise3d(p.yzx*4.5)*0.1;\n    return vec4(ant(p)\n                +abs(bumpb)\n                ,0.047/max( 1.,abs(p.z/4.)), 0.037/max( 1.,abs(p.z/3.)), 0.032/max( 1.,abs(p.x/2.)));\n }\n\n\n\n//Raycaster code credit to Inigo Quilez\n\n\nconst vec3 bbox_min = vec3(-7.363703305156273,-7.363703305156273,-7.363703305156273);\nconst vec3 bbox_max = vec3(7.363703305156273,7.363703305156273,7.363703305156273);\n// ray marching. ro is ray origin, rd is ray direction (unit vector).\n// result is (t,r,g,b), where\n//  * t is the distance that we marched,\n//  * r,g,b is the colour of the distance field at the point we ended up at.\n//    (-1,-1,-1) means no object was hit.\nvec4 castRay( in vec3 ro, in vec3 rd )\n{\n    float tmin = 1.0;\n    float tmax = 100.0;\n   \n    float t = tmin;\n    vec3 c = vec3(-1.0,-1.0,-1.0);\n    for (int i=0; i<200; i++) {\n        float precis = 0.0005*t;\n        vec4 res = map( vec4(ro+rd*t,iTime) );\n        if (res.x < precis) {\n            c = res.yzw;\n            break;\n        }\n        t += res.x;\n        if (t > tmax) break;\n    }\n    return vec4( t, c );\n}\nvec3 calcNormal( in vec3 pos )\n{\n    vec2 e = vec2(1.0,-1.0)*0.5773*0.0005;\n    return normalize( e.xyy*map( vec4(pos + e.xyy,iTime) ).x + \n                      e.yyx*map( vec4(pos + e.yyx,iTime) ).x + \n                      e.yxy*map( vec4(pos + e.yxy,iTime) ).x + \n                      e.xxx*map( vec4(pos + e.xxx,iTime) ).x );\n}\nfloat calcAO( in vec3 pos, in vec3 nor )\n{\n    float occ = 0.0;\n    float sca = 1.0;\n    for( int i=0; i<5; i++ )\n    {\n        float hr = 0.01 + 0.12*float(i)/4.0;\n        vec3 aopos =  nor * hr + pos;\n        float dd = map( vec4(aopos,iTime) ).x;\n        occ += -(dd-hr)*sca;\n        sca *= 0.95;\n    }\n    return clamp( 1.0 - 3.0*occ, 0.0, 1.0 );    \n}\n// in ro: ray origin\n// in rd: ray direction\n// out: rgb colour\nvec3 render( in vec3 ro, in vec3 rd )\n{ \n    //vec3 col = vec3(0.7, 0.9, 1.0) +rd.z*0.8;\n    //vec3 col = vec3(0.8, 0.9, 1.0);\n    vec3 col = vec3(1.0, 1.0, 1.0);\n    vec4 res = castRay(ro,rd);\n    float t = res.x;\n    vec3 c = res.yzw;\n    if( c.x>=0.0 )\n    {\n        vec3 pos = ro + t*rd;\n        vec3 nor = calcNormal( pos );\n        vec3 ref = reflect( rd, nor );\n        \n        // material        \n        col = mix(c,normalize(c),0.12)*0.34;\n\n        // lighting        \n        float occ = calcAO( pos, nor );\n        vec3  lig1 = normalize( vec3(-0.8, 0.3, 0.5) );\n        vec3  lig2 = normalize( vec3(0.8, 0.3, 0.5) );\n        float amb = clamp( 0.5+0.5*nor.z, 0.0, 1.0 );\n        float dif1 = clamp( dot( nor, lig1 ), 0.0, 1.0 );\n        float dif2 = clamp( dot( nor, lig2 ), 0.0, 1.0 );\n        float bac = clamp( dot( nor, normalize(vec3(-lig1.x,lig1.y,0.0))), 0.0, 1.0 )*clamp( 1.0-pos.z,0.0,1.0);\n        float dom = smoothstep( -0.1, 0.1, ref.z );\n        float fre = pow( clamp(1.0+dot(nor,rd),0.0,1.0), 2.0 );\n        float spe1 = pow(clamp( dot( ref, lig1 ), 0.0, 1.0 ),32.0);\n        float spe2 = pow(clamp( dot( ref, lig2 ), 0.0, 1.0 ),32.0);\n        \n        vec3 lin = vec3(0.0);\n        lin += 4.30*dif1*vec3(1.00,0.80,0.55);\n        lin += 4.30*dif2*vec3(1.00,0.80,0.55);\n        lin += 14.00*spe1*vec3(1.00,0.90,0.70)*dif1;\n        lin += 14.00*spe2*vec3(0.50,0.90,1.0)*dif2;\n        lin += 0.9*amb*vec3(0.40,0.60,1.00)*occ;\n        lin += 0.50*dom*vec3(0.40,0.60,1.00)*occ;\n        lin += 0.20*bac*vec3(0.935,0.935,0.935)*occ;\n        lin += 0.25*fre*vec3(1.00,1.00,1.00)*occ;\n        vec3 iqcol = col*lin;\n\n        //col = mix( col, vec3(0.8,0.9,1.0), 1.0-exp( -0.0002*t*t*t ) );\n        col = mix(col,iqcol, 0.64);\n    }\n\n    return vec3( clamp(col,0.0,1.0) );\n}\n// Create a matrix to transform coordinates to look towards a given point.\n// * `eye` is the position of the camera.\n// * `centre` is the position to look towards.\n// * `up` is the 'up' direction.\nmat3 look_at(vec3 eye, vec3 centre, vec3 up)\n{\n    vec3 ww = normalize(centre - eye);\n    vec3 uu = normalize(cross(ww, up));\n    vec3 vv = normalize(cross(uu, ww));\n    return mat3(uu, vv, ww);\n}\n// Generate a ray direction for ray-casting.\n// * `camera` is the camera look-at matrix.\n// * `pos` is the screen position, normally in the range -1..1\n// * `lens` is the lens length of the camera (encodes field-of-view).\n//   0 is very wide, and 2 is a good default.\nvec3 ray_direction(mat3 camera, vec2 pos, float lens)\n{\n    return normalize(camera * vec3(pos, lens));\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    const vec3 origin = (bbox_min + bbox_max) / 2.0 +vec3 (0,0,10);\n    const vec3 radius = (bbox_max - bbox_min) / 2.0;\n    float r = max(radius.x, max(radius.y, radius.z)) / 1.0;\n    vec2 p = -1.0 + 2.0 * fragCoord.xy / iResolution.xy;\n    p.x *= iResolution.x/iResolution.y;\n \n      vec2 mouse = iMouse.xy / iResolution.xy;\n      //  vec3 eye = vec3 (cos (4. * mouse.x) * 67., sin (4. * mouse.x) *sin (4. * mouse.y) * 67., -cos (4. * mouse.y) * 67.);\nvec3 eye = vec3(sin( 2.)*26., cos( 3.)*20., cos( 5.)*4.+4.);\n    vec3 centre = vec3(-1.0, 0.0, 1.0);\n    vec3 up = eye+ vec3(0.0, 0.0, 1.0);\n\t \n \n    mat3 camera = look_at(eye, centre, up);\n    vec3 dir = ray_direction(camera, p, 2.5);\n\n    vec3 col = render( eye, dir );\n    \n    // convert linear RGB to sRGB\n    col = pow(col, vec3(0.4545));\n    \n    fragColor = vec4(col,1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XtccDr.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 42, 65, 65, 150], [152, 152, 192, 192, 285], [287, 287, 319, 319, 484], [493, 493, 522, 522, 597], [601, 601, 630, 630, 656], [658, 658, 696, 696, 808], [811, 811, 842, 842, 905], [907, 907, 949, 949, 990], [993, 993, 1016, 1016, 1908], [1912, 1912, 1954, 1954, 2102], [2104, 2104, 2167, 2167, 2500], [2897, 2944, 2967, 3058, 4097], [4100, 4100, 4123, 4123, 4693], [4695, 4695, 4718, 4718, 5357], [5358, 5358, 5381, 5381, 6031], [6032, 6032, 6055, 6055, 6718], [6721, 6721, 6743, 6743, 6862], [6873, 6873, 6892, 6892, 6988], [6991, 6991, 7010, 7010, 7626], [7841, 8101, 8141, 8141, 8524], [8525, 8525, 8557, 8557, 8858], [8859, 8859, 8901, 8901, 9215], [9216, 9280, 9319, 9406, 11073], [11074, 11271, 11317, 11317, 11467], [11468, 11736, 11791, 11791, 11841], [11842, 11842, 11899, 11899, 12736]], "test": "untested"}
{"id": "XtccR8", "name": "syltefar-twisted", "author": "syltefar", "description": "Ray marched twisted shape", "tags": ["sdf"], "likes": 3, "viewed": 64, "published": "Public", "date": "1531407907", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float sdf(vec3 pos, float time)\n{\n    vec2 polar;\n    vec3 local_sp = pos;\n    polar.y = atan(local_sp.z, local_sp.x);\n    float xzLen = sqrt(local_sp.x * local_sp.x + local_sp.z * local_sp.z);\n    polar.x = atan(xzLen, -local_sp.y);\n    \n    return length(pos) - 0.7\n        - (sin(polar.x*8.0+polar.y*8.0+time) * 0.5 + 0.5)*0.1\n        ;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    const float gradient_offset = 0.0001;\n    const float MIN_DIST = 0.01;\n    const float MAX_DIST = 200.0;\n    \n    vec2 uv = fragCoord.xy / iResolution.yy * 2.0;\n    vec3 start_pos = vec3(uv.x-1.0, uv.y-1.0, 0.0);\n    vec3 camera = vec3(0.0, 0.0,-100.0);\n    vec3 direction = normalize(start_pos - camera);\n\n    vec3 pos = start_pos + vec3(-0.8, 0.0, -0.7);\n    \n    // ray marching\n    float d = 10.0;\n    for(int i =0; i < 32; i++) {\n\t  d = sdf(pos, iTime );\n\t  pos += direction * d;\n\t  if(d < MIN_DIST || d > MAX_DIST) break;\n    }\n\n    float r = 0.0, g = 0.0, b = 0.0;\n    \n    if(d<=MIN_DIST) {\n\n\t  // estimate normal based on finite difference approx of gradient\n\t  vec3 gradient = sdf(pos, iTime) - vec3(\n\t      sdf(pos + vec3(gradient_offset,.000,.000), iTime),\n\t      sdf(pos + vec3(.000,gradient_offset,.000), iTime),\n\t      sdf(pos + vec3(.000,.000,gradient_offset), iTime)\n\t      );\n      \t  vec3 normal = normalize( gradient );\n\n\t  // red diffuse light\n\t  r = dot( normal, normalize(vec3(2.0,-4.0,+0.5))) * 0.9;\n\t  // green diffuse light\n\t  g = dot( normal, normalize(vec3(-0.4,0.4,+0.4))) * 0.2;\n\t  // blue diffuse light\n\t  b = dot( normal, normalize(vec3(0.9,-0.3,+0.4))) * 0.5;\n    }\n    fragColor = vec4(r, g, b, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XtccR8.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 33, 33, 341], [343, 343, 400, 400, 1641]], "test": "untested"}
{"id": "XtccW7", "name": "Animated Palmtree", "author": "leacasas", "description": "Following the tutorial by the master Iñigo Quilez", "tags": ["tree", "shader", "palm"], "likes": 1, "viewed": 87, "published": "Public", "date": "1532794600", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 q = uv - vec2(.32 + sin(iTime)*0.025*uv.y, .65);\n        \n    vec3 col = 0.5 + 0.5*cos(iTime-uv.y-vec3(0,2,4));\n    \n    float r = 0.2 + 0.1 * cos(atan(q.y, q.x)*11.0 + 13.0 * q.x + sin(iTime));\n    col *= smoothstep(r, r+0.005, length(q));\n    r = 0.0225;\n    r += 0.002 * cos(80.0*q.y);\n    r += exp(-100.0*uv.y);\n    col *= 1.0 - (1.0 - smoothstep(r, r+0.0025, abs(q.x - .21*sin(2.2*q.y))))*(1.0 - smoothstep(0.0, 0.1, q.y));\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XtccW7.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 593]], "test": "untested"}
{"id": "Xtccz4", "name": "CRT - effect", "author": "luka712", "description": "First time doing CRT effect. ", "tags": ["crteffect"], "likes": 2, "viewed": 1315, "published": "Public API", "date": "1531730346", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\nvec2 crt_coords(vec2 uv, float bend)\n{\n\tuv -= 0.5;\n    uv *= 2.;\n    uv.x *= 1. + pow(abs(uv.y)/bend, 2.);\n    uv.y *= 1. + pow(abs(uv.x)/bend, 2.);\n    \n    uv /= 2.5;\n    return uv + .5;\n}\n\nfloat vignette(vec2 uv, float size, float smoothness, float edgeRounding)\n{\n \tuv -= .5;\n    uv *= size;\n    float amount = sqrt(pow(abs(uv.x), edgeRounding) + pow(abs(uv.y), edgeRounding));\n    amount = 1. - amount;\n    return smoothstep(0., smoothness, amount);\n}\n\nfloat scanline(vec2 uv, float lines, float speed)\n{\n    return sin(uv.y * lines + iTime * speed);\n}\n\nfloat random(vec2 uv)\n{\n \treturn fract(sin(dot(uv, vec2(15.5151, 42.2561))) * 12341.14122 * sin(iTime * 0.03));   \n}\n\nfloat noise(vec2 uv)\n{\n \tvec2 i = floor(uv);\n    vec2 f = fract(uv);\n    \n    float a = random(i);\n    float b = random(i + vec2(1.,0.));\n\tfloat c = random(i + vec2(0., 1.));\n    float d = random(i + vec2(1.));\n    \n    vec2 u = smoothstep(0., 1., f);\n    \n    return mix(a,b, u.x) + (c - a) * u.y * (1. - u.x) + (d - b) * u.x * u.y; \n                     \n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    vec2 crt_uv = crt_coords(uv, 4.);\n    \n    float s1 = scanline(uv, 200., -10.);\n    float s2 = scanline(uv, 20., -3.);\n    \n    vec4 col;\n    col.r = texture(iChannel0, crt_uv + vec2(0., 0.01)).r;\n    col.g = texture(iChannel0, crt_uv).r;\n    col.b = texture(iChannel0, crt_uv + vec2(0., -0.01)).b;\n    col.a = texture(iChannel0, crt_uv).a;\n    \n    col = mix(col, vec4(s1 + s2), 0.05);\n\tfragColor = mix(col, vec4(noise(uv * 75.)), 0.05) * vignette(uv, 1.9, .6, 8.);;\n}", "image_inputs": [{"id": "4sX3Rn", "previewfilepath": "/media/ap/c3a071ecf273428bc72fc72b2dd972671de8da420a2d4f917b75d20e1c24b34c.ogv", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/c3a071ecf273428bc72fc72b2dd972671de8da420a2d4f917b75d20e1c24b34c.ogv", "ctype": "video"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Xtccz4.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 1, 39, 39, 191], [193, 193, 268, 268, 457], [459, 459, 510, 510, 558], [560, 560, 583, 583, 676], [678, 678, 700, 700, 1036], [1039, 1039, 1096, 1096, 1615]], "test": "untested"}
{"id": "XtcyD7", "name": "Fun with raymarching", "author": "leacasas", "description": "I keep learning ray marching. Building primitives and applying operations to it (repetition and rotation).", "tags": ["raymarching"], "likes": 9, "viewed": 125, "published": "Public", "date": "1532799863", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage(out vec4 fragColor,in vec2 fragCoord) {\n    vec2 uv=(fragCoord/iResolution.xy)*2.-1.;\n    uv.x*=iResolution.x/iResolution.y;\n    vec3 k=vec3(2.,2.,2.);\n    float t=0.;\n    for(int i=0;i<64;++i){\n        vec3 q=mod(vec3(cos(iTime),sin(iTime),iTime*.3)+normalize(vec3(uv,1.))*t,k)-.5*k;\n    \tq.xy*=mat2(cos(iTime),-sin(iTime),sin(iTime),cos(iTime));\n        t+=length(max(abs(q)-vec3(.1,.2,.5),.0))*.5;\n    }\n    vec3 c=vec3(1./t);\n    fragColor=vec4(c.x,c.y,c.z*.5,1.);\n}\n/*\n// GregRostami's version from the comments (235 chars !)\n#define mainImage(o,U)\n    vec3 R = iResolution, q;\n    float t = 0., T = iTime;\n    while(o.a++<64.)\n        q = mod(vec3(cos(T),sin(T),T*.3) + vec3((U+U-R.xy)/R.y, 1)*t, 2.) - 1.,\n    \tq.xy *= mat2( cos(T + vec4(0,33,55,0)) ),\n        t += length( max(abs(q)-vec3(.1,.2,.5),.0) )*.5;\n    o += .8/t;\n    o.z *= .5\n*/", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XtcyD7.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 54, 54, 485]], "test": "untested"}
{"id": "XtdyDn", "name": "Quadratic Bezier dist - cleanup", "author": "FabriceNeyret2", "description": "Cleanup of \"Bezier DistanceGlow\" by bloxard. [url]https://shadertoy.com/view/XdB3Ww[/url]", "tags": ["cardanosmethod", "bezierspline", "quadraticbezier"], "likes": 9, "viewed": 1050, "published": "Public API", "date": "1532249421", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// cleanup of \"Bezier DistanceGlow\" by bloxard. https://shadertoy.com/view/XdB3Ww\n\n\n//Find roots using Cardano's method. http://en.wikipedia.org/wiki/Cubic_function#Cardano.27s_method\nvec2 solveCubic2(vec3 a)\n{\n\tfloat p  = a.y - a.x*a.x/3.,\n\t      p3 = p*p*p,\n\t      q  = a.x* ( 2.*a.x*a.x - 9.*a.y ) /27. + a.z,\n\t      d  = q*q + 4.*p3/27.;\n    \n\tif(d>0.) {\n\t\tvec2 x = ( vec2(1,-1)*sqrt(d) -q ) *.5;\n        x = sign(x) * pow( abs(x) , vec2(1./3.) );\n  \t\treturn vec2( x.x+x.y -a.x/3. );\n  \t}\n    \n \tfloat v = acos( -sqrt(-27./p3)*q*.5 ) / 3.,\n \t      m = cos(v),\n \t      n = sin(v)*sqrt(3.);\n\n\treturn vec2(m+m,-n-m) * sqrt(-p/3.) - a.x/3.;\n}\n\n// How to solve the equation below can be seen on this image.\n// http://www.perbloksgaard.dk/research/DistanceToQuadraticBezier.jpg\n#define dd(a) dot(a,a)\n\nfloat dQBezier(vec2 p, vec2 a, vec2 b, vec2 c)\n{\n\tb = mix( b+vec2(1e-4), b, abs(sign(b*2.-a-c)) );\n\tvec2 A = b-a,\n\t     B = c-b-A,\n\t     C = p-a,\n\t     D = A*2.,\n\tP = solveCubic2( vec3(-3.*dot(A,B), dot(C,B)-2.*dd(A), dot(C,A))/-dd(B) );\n    P = clamp( P,0.,1.); // curve parameterization\n\n\treturn sqrt( min( dd( (D+B*P.x)*P.x -C ),\n                      dd( (D+B*P.y)*P.y -C )));\n}\n\n\n#define rot(a) mat2(cos(a),sin(a),-sin(a),cos(a) )\n\nvoid mainImage( out vec4 O, vec2 u )\n{\n    float t = iTime; \n    vec2 R =   iResolution.xy,\n         U = ( u - R*.5 ) / R.y;\n    \n\tvec2 p0 = vec2(-cos(t*.5)   , sin(t*0.9) ) *.4,\n\t     p1 = vec2(-cos(t*2.3)  , sin(t*1.1) ),\n\t     p2 = vec2(cos(t*1.3)*.4, -sin(t*.3)*.3 );\n\n\tp0 *= rot( sin(t) -t );\n\tp1 *= rot( sin(t*.7) );\n\tp2 *= rot( cos(t*1.8) +t );\n\n\tfloat d = dQBezier(U,p0,p1,p2);\n  \n\tO = vec4(smoothstep(1.5,0., (d-10./R.y)/fwidth(d) ) );\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XtdyDn.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[84, 184, 210, 210, 642], [644, 800, 848, 848, 1182], [1237, 1237, 1275, 1275, 1683]], "test": "untested"}
{"id": "XtdyR8", "name": "Desk", "author": "Hsiett", "description": "Just for fun. Shade a desk based on https://www.shadertoy.com/view/XllBD2", "tags": ["cube", "fun", "desk"], "likes": 1, "viewed": 84, "published": "Public", "date": "1531544055", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Created by genis sole - 2017\n// License Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International.\n// \n\n//Adapted from:\n//https://www.shadertoy.com/view/XllBD2\n\n\n//David Hoskins hash: https://www.shadertoy.com/view/4djSRW \nfloat hash11(float p)\n{\n\tvec3 p3  = fract(vec3(p) * .1031);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z)*2.0 - 1.0;\n}\n\nfloat gnoise(float p) \n{\n    float i = floor(p);\n\tfloat f = fract(p);\n    \n    float a = dot(hash11(i), f);\n    float b = dot(hash11(i + 1.0), f - 1.0);\n    \n    float u = smoothstep(0.0, 1.0, f);\n    return mix(a, b, u);\n}\n\nfloat segment(vec2 uv, float e, vec2 a, vec2 b)  {         \n    b -= a;\n    uv -= a;\n    return smoothstep(0.0003, 0.0003 + 1.5*e, \n                      length( uv - b * clamp(dot(b, uv) / dot(b, b), 0.0, 1.0)));\n}\n\nfloat point(vec2 uv, float e, vec2 p) \n{\n\treturn smoothstep(0.002, 0.002 + 1.5*e, length(uv - p)); \n}\n\n//v1->v2->v3->v4 in clock order or counter-clock order.\nvec3 surface(vec2 uv, vec2 v1, vec2 v2, vec2 v3, vec2 v4)\n{\t\n    vec3 vside1=cross(vec3(uv-v1,0),vec3(v2-v1,0));\n    vec3 vside2=cross(vec3(uv-v2,0),vec3(v3-v2,0));\n    vec3 vside3=cross(vec3(uv-v3,0),vec3(v4-v3,0));\n    vec3 vside4=cross(vec3(uv-v4,0),vec3(v1-v4,0));\n    \n    if(sign(dot(vside1,vside2))==sign(dot(vside2,vside3))&&\n       sign(dot(vside3,vside4))==sign(dot(vside2,vside3)))\n    {\n       return vec3(0.8,0.8,0.8);   \n    }\n    \n    return vec3(0.0,0.0,0.0);\n}\n\nvec2 transform(vec3 p, vec4 q) \n{\n    p += 2.0 * cross(q.xyz, cross(q.xyz, p) + q.w * p);\n    return p.xy / (p.z + 10.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tfloat e = 1.0 / iResolution.x;\n    vec2 uv = (fragCoord - iResolution.xy*0.5) * e;\n    \n    float t = iTime*0.3;//74.50: a steady desk;\n    \n    vec3 a = vec3(gnoise(t + 2.0) * 3.1, \n                  gnoise(t + 6.0) * 3.5, \n                  gnoise(t + 4.0) * 3.2);\n    float s = clamp((gnoise(t + 10.0) + 0.5), -1.0, 1.0);\n    vec4 q = normalize(vec4(a * s, sqrt(1.0 - s*s))); \n    \n    vec2 b1 = transform(vec3(-1.0, -1.0, -1.0), q);\n    vec2 b2 = transform(vec3(-1.0, -1.0,  1.0), q);\n    vec2 b3 = transform(vec3( 1.0, -1.0,  1.0), q);\n    vec2 b4 = transform(vec3( 1.0, -1.0, -1.0), q);\n   \n    vec2 t1 = transform(vec3(-1.0, 1.0, -1.0), q);\n    vec2 t2 = transform(vec3(-1.0, 1.0,  1.0), q);\n    vec2 t3 = transform(vec3( 1.0, 1.0,  1.0), q);\n    vec2 t4 = transform(vec3( 1.0, 1.0, -1.0), q);\n    \n    vec2 o = transform(vec3(0.0), q);\n    \n    float v = 1.0;\n    //v *= segment(uv, e, b1, b2);\n    //v *= segment(uv, e, b2, b3);\n    //v *= segment(uv, e, b3, b4);\n    //v *= segment(uv, e, b4, b1);\n    \n    v *= segment(uv, e, t1, t2);\n    v *= segment(uv, e, t2, t3);\n    v *= segment(uv, e, t3, t4);\n    v *= segment(uv, e, t4, t1);\n    \n    v *= segment(uv, e, b1, t1);\n    v *= segment(uv, e, b2, t2);\n    v *= segment(uv, e, b3, t3);\n    v *= segment(uv, e, b4, t4);\n    \n    v *= point(uv, e, b1);\n    v *= point(uv, e, b2);\n    v *= point(uv, e, b3);\n    v *= point(uv, e, b4);\n    \n    v *= point(uv, e, t1);\n    v *= point(uv, e, t2);\n    v *= point(uv, e, t3);\n    v *= point(uv, e, t4);\n    //v *= point(uv, e, o);\n    \n    \n    vec3 faceColor=vec3(0.0,0.0,0.0);\n    \n    //fill the desk surface\n    faceColor=surface(uv,t1,t2,t3,t4);\n    \n\n    fragColor = vec4(vec3(sqrt(v))-faceColor, 1.0); \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XtdyR8.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0 AND proprietary-license", "functions": [[179, 240, 263, 263, 386], [388, 388, 412, 412, 611], [613, 613, 663, 663, 828], [830, 830, 870, 870, 931], [933, 989, 1048, 1048, 1466], [1468, 1468, 1501, 1501, 1591], [1593, 1593, 1650, 1650, 3368]], "test": "untested"}
{"id": "XtdyRr", "name": "Hello-Shadertoy", "author": "eqs", "description": "This is my first shader on Shadertoy.", "tags": ["shape"], "likes": 2, "viewed": 439, "published": "Public", "date": "1531316337", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    float aspectRatio = iResolution.x / iResolution.y;\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 pt = uv - 0.5;\n    pt.x *= aspectRatio;\n\t\n    float a = atan(pt.y / pt.x);\n    \n    float r1 = length(pt) + 0.025 * sin(a * 10.0 + iTime * 2.0);\n    float f1 = pow(sin(r1 * 10.0 - iTime + 1.5 * sin(iTime * 0.1)), 6.0);\n    float r2 = length(pt) + 0.025 * sin(a * 12.0 - iTime * 6.0);\n    float f2 = pow(sin(r2 * 10.0 - iTime + 0.5 * sin(iTime)), 6.0);\n    float r3 = length(pt) + 0.025 * sin(a * 6.0 - iTime * 6.0);\n    float f3 = pow(sin(r3 * 10.0 - iTime + sin(iTime * 1.5)), 6.0);\n    \n    \n    vec3 col = vec3(f1, f2, f3);\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XtdyRr.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 107, 796]], "test": "untested"}
{"id": "XttcD4", "name": "bezier smoothmirror kifs rope", "author": "ollj", "description": "mouse does things\ntime interpolates 2 linear extreme cases with a quadratic bezier (solves for 2 of 3 roots)\n\nmaybe use this function instead of length() for a kifs, to make the sharp corners of a kaleidoscopic image rounder.\nor as jumpriope", "tags": ["bezier", "rainbow", "rope"], "likes": 3, "viewed": 415, "published": "Public API", "date": "1532686720", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n\n//sign 2d quadratiic bezier distance scaled-almostidentity\n\n//parent: https://www.shadertoy.com/view/4ddXRH  \n//2d shape bezier fast old\n//based on:\n//-Adam Simmons(@adamjsimmons)2015: Signed Distance to a Quadratic Bezier Curve\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n// Playing around with beziers,trying to find a way to get a bounding area \n// so I can limit where the more complex part of the rootsolver is run. \n// No luck so far.\n//\n// Inspired by http://www.pouet.net/topic.php?which=9119\n// and various shaders by iq,T21,and demofox\n\n\n//in the end ,a  cos(a)*b should be the best solution.\n//in the end ,a  cos(a)*b should be the best solution.\n//in the end ,a  cos(a)*b should be the best solution.\n\n//View.Zoom\n#define ViewZoom 1.\n//View.Frame\n#define fra(u)(u-.5*iResolution.xy)*ViewZoom/iResolution.y\n\n#define u5(a)((a)*.5+.5)\n#define sat(a)clamp(a,0.,1.)\n#define dd(a)dot(a,a)\nfloat suv(vec2 a){return a.x+a.y;}\nfloat miv(vec2 a){return min(a.x,a.y);}\nfloat miv(vec3 a){return min(miv(a.xy),a.z);}\nfloat miv(vec4 a){return min(miv(a.xy),miv(a.zw));}\nvec4 minx(vec4 a,vec4 b){return mix(b,a,step(a.x,b.x));}//return the vec4 with the smaller .x\n\n//for rainbow gradient:\n//hermite interpolation core\n#define h3(r)r*r*(3.-2.*r)\nvec3 hue2rgb(float h){return sat(abs(mod(h*6.+vec3(0,4,2),6.)-3.)-1.);}//return rgb of hue[0..1]\n//iq.HSV.Smooth: https://www.shadertoy.com/view/MsS3Wc\nvec3 hsv2rgb(in vec3 c){vec3 r=hue2rgb(c.x);return c.z*mix(vec3(1),h3(r),c.y);}//return rgb of hsv\n\n//distance to line segment dot()/dd()approach.\nfloat sdSegment(vec2 a,vec2 b,vec2 p){b-=a;p-=a;return length(b*sat(dot(p,b)/dd(b))-p);}//return distance to line segment,unsigned,sides are not distinguished\n//float sdSegment(vec2 a,vec2 b,vec2 p){a-=p;b-=p;vec2 c=b-a;return length(a+c*sat(-dot(a,c)/dd(c)));}//return distance to line segment,unsigned,sides are not distinguished\n\n//----trace plane,in n dimensions==solve linear equation:\n//[t]RayDirection.normalize()d!! //[u]RayOrigin \n//[n]PlaneNormal .normalize()d!! //[o]PlaneOrigin==distance of plane to local coordinate origin vecN(0)\n//return distacne from [u] to intersection of ray with plane;;To offset the plane,-offset Rayorigin instead;u=u-n*o\n#define gPRxZ(n,u,t)-(dot(n,u)/dot(n,t))//second life wiki geometric,see gPRxZ()\n//return intersection of rayOrigin=u,raydirection=normalize(t),PlaneNormal=normalize(n),Plane_Distance-To_vecN(0)=o //offset sign flipped!!!\n#define slo(u,t,n,o)(u)-(t)*(dot(n,(u)+(n)*(o))/dot(n,t))\n#define sl(u,t,n)(u)-(t)*(dot(n,u)/dot(n,t))\n//get [y] of(bi)quadratic f(t);\nvec2 EvalQuadratic(vec2 A,vec2 B,vec2 C,float t){float u=1.-t;return u*u*A+2.*u*t*B+t*t*C;}\n//\n//--root solving calculates where a polynomial intersects with f(x)=0;\n//the smallest(positive)(non-imaginary)root is relevant for raytracing.\n//differentials anf quotients of 2 polynomials(long division)is relevant for bounts of rootsa of higher degree polynomials here.\n//solve linear;y=a+b*x ;for roots ;y=0;assert b!=0;\nfloat solveLinear(float a,float b){return -a/b;}//0.=a+b*x;/b  0.=a/b+x;-a/b;x=-a/b;\n//Solving a linear equation   ,and generalizing for more domains,you solve where a straight line intersects ANY hyperplane.\n//Solving a quadratic equation,and generalizing for more domains,you solve where a parabola intersects ANY hyperplane.\n//this is relatively simple;with a dot()/dot()projection,becoming equal to tracing a plane.\n// Solve cubic equation for roots\nvec3 solveCubic(vec3 a){float p=a.y-a.x*a.x/3.,p3=p*p*p,q=a.x*(2.*a.x*a.x-9.*a.y)/27.+a.z,d=q*q+4.*p3/27.,o=-a.x/3.\n;if(d>=.0){vec2 v=(vec2(1,-1)*sqrt(d)-q)/2.;return vec3(o+suv(sign(v)*pow(abs(v),vec2(1./3.))));}\n;float v=acos(-sqrt(-27./p3)*q*.5)/3.,m=cos(v),n=sin(v)*sqrt(3.);return vec3(m+m,-n-m,n-m)*sqrt(-p/3.)+o;}\n//while the 3rd root is rarely needed,n and m are already calculated,this just adds 1sub();\n//return if roughly equal within absolute bounds. //not sure if this is GENERALLY good,but its fine for my special case.\nbool rea(float s,float b,float e){b-=s;return(abs(s-.5*b)*e<abs(b));}//return(abs(b-a*.5)<a*e);//return(s<b-e||s>b+e);\n//return the signed(positive.y has a negative sign)distance from a point to a quadratic bezier curve\nfloat sdBezierS(vec2 A,vec2 B,vec2 C,vec2 p){\n//;vec2 D=A+B+C;if(D.x==D.y)return sdSegment(A,B,p);//if colinear,treat as line segment(not correct,not conform to signing)\n//;B=mix(B+vec2(1e-4),B,abs(sign(B*2.-A-C)))//force non-colinear,but there should be better solution to it.\n//;if(!(rea(A.y,C.y,.0001)))return sdSegment(A,C,p);//the used function is likely not generally correct,it is an unsigned segment!\n;vec2 a=B-A,b=A-B*2.+C,c=a*2.,d=A-p\n;vec2 t=sat(solveCubic(vec3(3.*dot(a,b),2.*dd(a)+dot(d,b),dot(d,a))/dd(b))).xy\n;vec2 d1=d+(c+b*t.x)*t.x,d2=d+(c+b*t.y)*t.y;\n;vec4 r=minx(vec4(dd(d1),t.x,d1),vec4(dd(d2),t.y,d2));\n;vec2 g=2.*b*r.y+c;\n;float s=sign(g.y*r.z-g.x*r.w);\n;return s*sqrt(min(dd(A+(c+b*t.x)*t.x-p),dd(A+(c+b*t.y)*t.y-p)));}\n//\n//above is signed,below is unsigned\n//return unsigned(always positive)distance from a point to a quadratic bezier curve\nfloat sdBezier(vec2 A,vec2 B,vec2 C,vec2 p){\n//;vec2 D=A+B+C;if(D.x==D.y)return sdSegment(A,B,p);//if colinear,treat as line segment(not correct,not conform to signing)\n//;B=mix(B+vec2(1e-4),B,abs(sign(B*2.-A-C)))//force non-colinear,but there should be better solution to it.\n;if(!(rea(A.y,C.y,.001)))return sdSegment(A,C,p);//this is fine,not great,but a good enough upper bound to swiwch to linear.\n;vec2 a=B-A,b=A-B*2.+C,c=a*2.,d=A-p\n;vec2 t=sat(solveCubic(vec3(3.*dot(a,b),2.*dd(a)+dot(d,b),dot(d,a))/dd(b))).xy\n;return sqrt(min(dd(A+(c+b*t.x)*t.x-p),dd(A+(c+b*t.y)*t.y-p)));}\n//\n//above is the older analytic-bezier root-solver,and it seems that its 3rd root is not needed for the constrains of this shader.\n//bu the 3rd root is relevant for some other less constrained cases?\n//\n//bewlow is a faster 2 root bezier solver,but it doesnt stop at the ControlPoints A or B,and the wrapAround sis bad here.\n//it breaks trough the contrains of the above,and ignores them.\n//return signed distance from a point to a bezier curve without clamping,2 roots are not enough here?\nfloat sdBezier2(vec2 A,vec2 B,vec2 C,vec2 p){   \n//;vec2 D=A+B+C;if(D.x==D.y)return sdSegment(A,B,p);//if colinear,treat as line segment(not correct,not conform to signing)\n//;B=mix(B+vec2(1e-4),B,abs(sign(B*2.0-A-C)));//force non-colinear,but there should be better solution to it.\n;vec2 a=B-A,b=A-B*2.0 + C,c=a*2.0,d=A-p;\n;vec2 t=solveCubic(vec3(3.*dot(a,b),2.*dot(a,a)+dot(d,b),dot(d,a))/dd(b)).xy;\n;vec2 dp1=d+(c+b*t.x)*t.x\n;vec2 dp2=d+(c+b*t.y)*t.y\n;vec4 r=minx(vec4(dd(dp1),t.x,dp1),vec4(dd(dp2),t.y,dp2))\n;vec2 g=2.*b*r.y + c\n;return sqrt(r.x)\n;float s=sign(g.x*r.w-g.y*r.z)\n;return s*sqrt(r.x);}\n\n \nvoid mainImage(out vec4 fragColor,in vec2 fragCoord)\n{vec2 p=fra(fragCoord.xy)//(2.0*fragCoord.xy-iResolution.xy)/iResolution.y;\n;vec4 m=vec4(fra(iMouse.xy),fra(iMouse.zw));\n;p.x=abs(p.x);//optional mirror symmetry demo\n;m.x=abs(m.x);//optional mirror symmetry demo\n;vec2 N=m.xy*.5\n;vec2 C=N*2.;\n//;float o=.5//height ooffset\n;float o=(sl(N,N-C,vec2(1,0))).x;o=mix(o,m.y,-u5(cos(iTime)))//mix smoothness for identity lines\n;vec2 A=vec2(0,-o);\n;vec2 B=slo(N,N-C,vec2(0,1),o);//;B=solveLinear2d(m.xy*2.,m.xy*2.-C);\n;float d=sdBezier(A,B,C,p);\nd=abs(d*9.-.05);\n;fragColor=vec4(vec3(smoothstep(.05,0.,d))+hue2rgb(d)*.1*fract(log(d)-iTime*.1),1.);\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XttcD4.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[790, 939, 957, 957, 973], [974, 974, 992, 992, 1013], [1014, 1014, 1032, 1032, 1059], [1060, 1060, 1078, 1078, 1111], [1112, 1112, 1137, 1137, 1168], [1207, 1287, 1309, 1309, 1358], [1358, 1439, 1463, 1463, 1518], [1539, 1586, 1624, 1624, 1674], [2571, 2603, 2652, 2652, 2694], [2695, 3022, 3057, 3057, 3070], [3070, 3476, 3500, 3500, 3796], [3797, 4010, 4044, 4044, 4079], [4079, 4230, 4275, 4638, 4972], [4973, 5096, 5140, 5372, 5677], [5678, 6170, 6215, 6452, 6773], [6777, 6777, 6831, 6831, 7421]], "test": "untested"}
{"id": "XttcRH", "name": "Rapid Cross title screen", "author": "kuyuri_iroha", "description": "This fragment shader is used Rapid Cross for title screen.\nGitHub: https://github.com/Kuyuri-Iroha/RapidCross", "tags": ["raymarching"], "likes": 0, "viewed": 115, "published": "Public", "date": "1531555600", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\nconst float PI = 3.14159265f;\nconst vec3 X_AXIS = vec3(1.0f, 0.0f, 0.0f);\nconst vec3 Y_AXIS = vec3(0.0f, 1.0f, 0.0f);\nconst vec3 Z_AXIS = vec3(0.0f, 0.0f, 1.0f);\nconst float angle = 30.0f;\nconst float fov = angle * 0.5f * PI / 180.0f;\nconst vec3 initCam = vec3(-0.5f, 0.0f, 3.0f);\nconst vec3 lightDir = normalize(vec3(0.3f, -2.0f, 1.0f));\n\nvec3 rotate(vec3 pos, float angle, vec3 axis)\n{\n    vec3 a = normalize(axis);\n    float s = sin(angle);\n    float c = cos(angle);\n    float r = 1.0f - c;\n    \n    mat3 m = mat3(\n        a.x * a.x * r + c,\n        a.y * a.x * r + a.z * s,\n        a.z * a.x * r - a.y * s,\n        a.x * a.y * r - a.z * s,\n        a.y * a.y * r + c,\n        a.z * a.y * r + a.x * s,\n        a.x * a.z * r + a.y * s,\n        a.y * a.z * r - a.x * s,\n        a.z * a.z * r + c\n    );\n    return m * pos;\n}\n\nvec3 trans(vec3 pos)\n{\n    return vec3(\n        mod(pos.x, 6.0f) - 2.5f,\n        mod(pos.y, 5.0f) - 2.5f, \n        mod(pos.z, 8.0f) - 2.5f\n    );\n}\n\nfloat distanceFunc(vec3 ray)\n{\n    vec3 transRay = trans(ray);\n    vec3 q = abs( abs( rotate( rotate( transRay, -iTime, -Y_AXIS ), -iTime, -X_AXIS ) ) );\n    return length( max( q - vec3(0.5f, 0.5f, 0.5f), 0.0f ) );\n}\n\nvec3 normal(vec3 ray)\n{\n    float delta = 0.0001;\n    vec3 deltaX = X_AXIS * delta;\n    vec3 deltaY = Y_AXIS * delta;\n    vec3 deltaZ = Z_AXIS * delta;\n    \n    return normalize( vec3(\n        distanceFunc( ray + deltaX) - distanceFunc( ray - deltaX),\n        distanceFunc( ray + deltaY) - distanceFunc( ray - deltaY),\n        distanceFunc( ray + deltaZ) - distanceFunc( ray - deltaZ)\n    ) );\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    vec3 color = vec3(0.0f, 0.0f, 0.0f);\n    \n    vec2 pos = vec2( (uv.x * 2.0f - 1.0f) * (16.0f / 9.0f), (uv.y * 2.0f - 1.0f) * 9.0f / 9.0f);\n    \n    vec3 cam = initCam;\n    cam.z = mod( -iTime, 20.0f ) * 10.0f;\n    \n    vec3 rayDir = normalize( vec3( sin(fov) * pos.x, sin(fov) * pos.y, -cos(fov) ) );\n\n    float dist = 0.0f;\n    float len = 0.0f;\n    vec3 ray = cam;\n    //Raymarching\n    for(int i=0; i<126; i++)\n    {\n        dist = distanceFunc(ray);\n        len += dist;\n        ray = cam + rayDir * len;\n    }\n    \n    //Hit\n    if( abs( dist ) < 0.001f)\n    {\n        vec3 n = normal(ray);\n        float diff = clamp( dot( lightDir , n ), 0.015f, 0.5f);\n        color = vec3( diff, diff, diff );\n    }\n    //No hit\n    else\n    {\n        color = vec3( 0.0f, 0.0f, 0.0f);\n    }\n    \n    color = color + 0.4f;\n\n    // Output to screen\n    fragColor = vec4(color,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XttcRH.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[341, 341, 388, 388, 825], [827, 827, 849, 849, 974], [976, 976, 1006, 1006, 1193], [1195, 1195, 1218, 1218, 1590], [1593, 1593, 1650, 1700, 2618]], "test": "untested"}
{"id": "XttyW8", "name": "Lines Over Time", "author": "jonobr1", "description": "Simple lines animate horizontally across the canvas over time.", "tags": ["2d", "lines", "bw", "white", "black", "whatyoudontknow"], "likes": 5, "viewed": 414, "published": "Public API", "date": "1532412368", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const float PI = 3.141592653589793;\n\n/**\n * Sinusoidal InOut Easing Curve\n */\nfloat easing( in float k )\n{\n    // return 1.0 - cos( k * PI / 2.0 ); // EaseIn\n    // return sin( k * PI / 2.0 ); // EaseOut\n    return 0.5 * ( 1.0 - cos( PI * k ) ); // EaseInOut\n}\n\nfloat line( in float x, in float axis, in float linewidth ) {\n\n    x *= ( 1.0 + linewidth );\n    x -= linewidth / 2.0;\n    \n    float t = 1.0 - distance( x, axis );\n    t = step( t, 1.0 - linewidth );\n    t = 1.0 - t;\n    \n    return t;\n\n}\n\nfloat easedLine( in float x, in float axis, in float linewidth ) {\n\n    // Vary linewidth based on x position.\n    linewidth *= pow( 1.0 + sin( axis * PI ), 2.0 );\n\tx = pow( easing( x ), 2.0 );\n\n    return line( x, axis, linewidth );\n\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    vec2 uv = fragCoord / iResolution.xy;\n\tfloat now = mod( float( iTime / 2.0 ), 1.0 );\n\tfloat linewidth = 0.0025;\n    \n    float f = 0.0;\n    float amount = 20.0;\n    \n    for ( float i = 1.0; i < amount; i ++ ) {\n\n        float pct = i / amount;\n        float pos = 1.0 - pow( 1.0 - pow( now, 1.0 ), 8.0 * pct );\n\n        f += line( pct * 2.0, uv.x, linewidth );\n        f += easedLine( pos, uv.y, linewidth );\n\n    }\n    \n    // f = 1.0 - f; // Uncomment this line for black lines on white canvas.\n\n    fragColor = vec4( f );\n\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XttyW8.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[37, 78, 106, 203, 260], [262, 262, 323, 323, 501], [503, 503, 569, 613, 739], [741, 741, 798, 798, 1332]], "test": "untested"}
{"id": "XttyWN", "name": "quartic root ellipse visualize", "author": "ollj", "description": "mouse does things\nanalytic distance to ellipse\nslightly improved with mirror symmetry to mirror for highest precision segments.\nimproved a lot in its vis style", "tags": ["ellipse", "analytic", "quintic", "4", "analysis", "roots", "fourroots"], "likes": 4, "viewed": 506, "published": "Public API", "date": "1532689673", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//self:https://www.shadertoy.com/view/XttyWN\n//parent https://www.shadertoy.com/view/4dVcR1\n/*\nfloat miv(vec2 a){return min(a.x,a.y);}float miv(vec4 a){return min(miv(a.xy),miv(a.zw));}\nfloat getSmallestPos(vec4 a){//return position of smallest value[0..3] \n if(all(lessThan(a.xxx,a.yzw)))return 0.;\n if(all(lessThan(a.yy,a.zw)))return 1.;\n return mix(2.,3.,step(a.z,a.w));}\nfloat getSmallestPosPositive(vec4 a){return getSmallestPos(mix(a,vec4(infinity),step(a,vec4(0))));}//return position of smallest positive value[0..3] \n\nvec2 smaller_x(vec2 a,vec2 b){return mix(b,a,step(a.x,b.x));}\n*/\n//largest positive value,the concept of infinity is quite nonsensical in terms of hillbert-address-space,this just makes it \"newbie friendly\"\n//#define infinity 10000.\n\n\n//Ellipse quartic ,by mattz\n//improved by @ollj\n//parent https://www.shadertoy.com/view/4dVcR1\n//License: Creative Commons Attribution ShareAlike 4.0 https://creativecommons.org/licenses/by-sa/4.0/\n//analytic distance to ellipse,2 or 4 points on an ellipse whos differential is permendicular.\n//Each point corresponds to one of 4 possible roots of a quartic(4th degree polynomial)plotted below the ellipse to scale.\n//Shows relationship between [distance of point to ellipse] and [its quartic roots]\n#define sat(a)clamp(a,0.,1.)\n#define dd(a)dot(a,a)\n#define ss10(a)smoothstep(1.,0.,a)\nfloat suv(vec2 a){return a.x+a.y;}\n//closed-form solver(without special-case checks)from  https://www.shadertoy.com/view/XdKyRR  \nvec4 solve_quartic(vec4 p){\n ;float quadrant=sign(p.x),s=p.w// form resolvent cubic and solve it to obtain one real root\n ,j=p.x*p.z-4.*p.w,k=4.*p.y*p.w-p.z*p.z-p.x*p.x*p.w,b=(-2.*p.y*p.y*p.y+9.*p.y*j+27.*k)/27.//coefficients of normal form\n ,delta1=b*b/4.,a=(3.*j-p.y*p.y)/3.,delta2=a*a*a/27.,z1\n ;if(delta1+delta2<0.)z1=2.*sqrt(-a/3.)*cos(acos(-sign(b)*sqrt(delta1/-delta2))/3.)\n ;else    z1=suv(pow(abs(-.5*b+vec2(1,-1)*sqrt(max(delta1+delta2,0.))),vec2(1./3.)))//sum of 2 cubic roots\n ;z1+=p.y/3. // shift back from normal form to root of resolvent cubic\n ;float R2=p.x*p.x/4.-p.y+z1//form quartic roots from resolvent cubic root\n ;bool R_ok=(R2>=0.);float R=sqrt(max(R2,0.)),foo,bar\n ;if(R==0.//i do not call this elegant!\n ){float z124s=z1*z1-4.*p.w;R_ok=R_ok &&(z124s>=0.);foo=3.*p.x*p.x/4.-2.*p.y   ;bar=2.*sqrt(max(z124s,0.))\n ;}else{           ;foo=3.*p.x*p.x/4.-R2-2.*p.y;bar=(4.*p.x*p.y-8.*p.z-p.x*p.x*p.x)/(4.*R);}\n ;float D=sqrt(max(foo+bar,0.)),E=sqrt(max(foo-bar,0.));vec4 roots=vec4(-p.x/4.)+.5*vec4(R+D,R-D,-R+E,-R-E)\n ;roots=mix(roots,roots.xzyw,step(sign(p.x),0.))//optional root sorting within homotopy\n ;return roots;}\n\n//vec2 from_angle(float t){return vec2(cos(t),sin(t));}//angle2Normal\nvec2 from_cos(float u){u=clamp(u,-1.,1.);return vec2(u,sqrt(1.-u*u));}//cos2normal\nvec2 perp(vec2 v){return vec2(-v.y,v.x);}\nfloat ellipse_dist(vec2 p,vec2 ab,out vec4 coeffs,out vec4 roots,out bool is_circle,out int k\n){float sig=sign(p.y);p.y=abs(p.y);vec2 ds=vec2(1e5,-1)//signed distance\n ;is_circle=abs((ab.x-ab.y)/ab.x)<1e-2//is important for precision reasons,is a useful BVH-shortcut.\n ;if(is_circle//near-circles are special quadratic case of a quartic ellipse\n){float dc=length(p)-ab.x;float u=normalize(p).x;roots=vec4(u,0,0,-u);coeffs=vec4(0,1,0,-u*u);ds=vec2(abs(dc),dc)\n ;}else{//ellipse\n  //formulate quartic polynomial of ellipse. solve for position u=cos(theta)along ellipse \n  //so that the tangent at the point [a*u,b*sqrt(1-u^2)] is perpendicular to the displacement between p and the point itself\n  //this gets 2 or 4 solutions. we need to inspect each of them in the arc case\n  ;float l=ab.y*ab.y-ab.x*ab.x,ax=ab.x*p.x/l,by=ab.y*p.y/l,a2x2=ax*ax,b2y2=by*by\n  ;coeffs=vec4(2.*ax,(a2x2+b2y2)-1.,-2.*ax,-a2x2)// vector of polynomial coefficients\n  ;roots=solve_quartic(coeffs)// solve for up to 4 roots \n  ;roots=mix(roots.xzyw,roots,step(-sig,0.))//optional root sorting within homotopy,green always on top,disregarding u.y\n  ;roots=mix(roots,roots.xzyw,step(ab.y,ab.x))//optional root sorting within homotopy,green always on top,disregarding ellypsoid/ratio.\n  ;for(int i=0;i<4;++i//for each root\n ){vec2 c=ab*from_cos(roots[i])// get absolute distance to the closest point on the ellipse,as well as its sign\n   ;vec2 b=vec2(length(p-c),dot(p-c,c))\n   ;float s=sign(ds.x-b.x)*.5+.5\n   ;k=k+i*int(s)\n   ;ds=mix(ds,b,s)\n ;}}return ds.x*sign(ds.y);}\n\nfloat dline(vec2 p,vec2 a,vec2 b,float d// distance to(optionally dashed)line\n){p-=a;b-=a;float l2=dd(b),u=sat(dot(p,b)/l2),l=length(p-u*b)\n ;if(d!=0.){l=max(l,-sin(u*sqrt(l2)/d)*d);}return l;}\nfloat poly3(vec4 p,float x){return((p.x*x+p.y)*x+p.z)*x+p.w;}// evaluate cubic(first derivative of poly4)\nfloat poly4(vec4 p,float x){return(((x+p.x)*x+p.y)*x+p.z)*x+p.w;}//evaluate a quartic,first coefficient==1 \n// given point p,function value at p.x and function derivative at p.x\n//,get estimated distance to curve of function plot.\nfloat dist_to_plot(vec2 p,vec2 fdf){vec2 p0=vec2(p.x,fdf.x);vec2 n=normalize(vec2(-fdf.y,1));return abs(dot(p-p0,n));}\n//iq.HSV.Smooth: https://www.shadertoy.com/view/MsS3Wc\nvec3 hsv2rgb(in vec3 c){vec3 r=sat(abs(mod(c.x*6.+vec3(0,4,2),6.)-3.)-1.);\n return c.z*mix(vec3(1.),r*r*(3.-2.*r),c.y);}//is hermite,quadratic with 1 duplicitiy\nvec3 colorMeIrrationally(float a){a*=(sqrt(5.)*.5+.5);a=fract(a);return hsv2rgb(vec3(a,1,1));}\nvec3 colorMeIrrationally(int a){return colorMeIrrationally(float(a));}\n\nvoid mainImage(out vec4 O,vec2 fragCoord\n){float e_px_per_unit=iResolution.y/3.//set up ellipse drawing\n ;vec2 pctr=iResolution.xy*vec2(.5,.65)\n ;vec2 u=(fragCoord.xy-pctr)/e_px_per_unit // frag coords relative to ellipse\n ;vec2 q=(iMouse.xy/iResolution.xy-vec2(.5,.65))*3.//vec2(.5,.2)// white dot\n ;q.x*=iResolution.x/iResolution.y\n //;if(max(iMouse.x,iMouse.y)>20.){q=(iMouse.xy-pctr)/e_px_per_unit;}//disabled for mouse ui debug\n ;float time=iTime*.25+4.4//;time=0.//debug overwrite\n ;vec2 ab=vec2(cos(time+1.2)*.6+.8,sin(time*.7-.5)*.2+.6)// ellipse radii\n ,ww=-abs(u)//fixes diagonal jittering due to prexision loss in one end,by utilizing mirror symmetry homotopy.\n ,deg45=ww*mat2(1,1,-1,1)//this scales by sqrt(2),so you can undo this by multiplying bxy *=sqrt(.5)\n ,w=ww,ba=ab\n ;if(sign(deg45.x*deg45.y)>0.){ba=ab.yx;w=ww.yx;}//a fix for near circular cases and u.x close to 0.\n ;if(abs(w.y)<.1){w.y+=1./iResolution.y;}//very lazy evasion for near-divisions-by-0,we just jump 1 fragment to the side.\n ;if(abs(w.x)<.1){w.x+=1./iResolution.x;}//very lazy evasion for near-divisions-by-0,we just jump 1 fragment to the side.\n //this only stays unnoticed because the ellipse is very round(is still pretty bad for normals/reflections)\n //this basically splits 1 discontinuity(that should not exist)in 2 discontinuities(that are less apparent)\n ;vec4 coeffs,coeffs2,roots,roots2;bool is_circle;int j;int k//some debugging junk left in here\n //oh boy,we once to this for ONE specific point,and once for the UV\n ;float d=ellipse_dist(w,ba,coeffs2,roots2,is_circle,j)//to fragment pos,to actually calculate an ellipse\n //;q.y=0.//border case debug overwrite,is flickering-hell on the visualization,due to arbitiary root-sorting due to precision loss\n //;q.y=0. //leads to root-duplicity within a quartic.\n //;q.x=0.//border case debug overwrite,is flickering-hell on the visualization;root duplicity AND morror symmetry at x=0;\n //;q=vec2(0)//this does not flicker for me,but i expected flicker.\n ;ellipse_dist(q,ab,coeffs,roots,is_circle,k)//for debug vis,we calculate the same for a mouse pos input\n // get initial ellipse distance for shading background and drawing ellipse\n ;float g_px_per_unit=iResolution.x/2.75//set graph \n ;vec2 v=(fragCoord.xy-vec2(.5,.2)*iResolution.xy)/g_px_per_unit//frag coords relative to graph\n ;vec4 pder=vec4(4,3,2,1)*vec4(1,coeffs.xyz)//get derivative polynomial\n ;float rara=1.5/ab.x//the squash is real.\n ;v.x*=1.5/ab.x//scale v to match axial-scaling to ellipse.x\n ;vec2 fdf=vec2(poly4(coeffs,v.x),poly3(pder,v.x))//evaluate quartic & derivative\n ;fdf*=.1//debug squash graph to fit in screenspace\n ;if(is_circle){pder.x=0.;fdf=vec2(poly3(coeffs,v.x),poly3(pder,v.x));}//circle case,quartic collapses to quadratic\n //;float dwhite=abs(d)*e_px_per_unit-.75// dist to ellipse & markers\n ;float dwhite=1.//debug overwrite,exclude the ellipse shape from dwhite,this is actually better.\n ,dq=length(u-q)*e_px_per_unit-5.// dist to draggable dot\n ,dplot=dist_to_plot(v*rara,20.*fdf*rara)*g_px_per_unit/rara//distance to gray graph line\n ,ddot=length(u-q)*e_px_per_unit-7.//distance to dark dot outlines by ellipse\n ;vec4 d_ellipse_root=vec4(1e9),d_axis_root=vec4(1e9)//distances to colored points on ellipse/x-axis\n ;vec3 dcol=vec3(1)\n ;vec4 alph=vec4(.1)\n ;for(int i=0;i<4;++i//for each potential root\n){vec2 uv=from_cos(roots[i])//create point on unit circle\n  ;vec3 uvmin=vec3(1e5)\n  ;for(int j=0;j<2;++j// test against both pos & neg. y\n ){vec2 e=ab*uv,t=.5*(ab*perp(uv))// ellipse point// tangent\n   ;vec3 uvd=vec3(uv,abs(dot(t,q-e)))\n   ;if(uvd.z<uvmin.z)uvmin=uvd\n   ;uv.y=-uv.y // test other sign next\n  ;}\n ;if(true//uvmin.z<1e-3//the angle has some tolerance to the tangent,but if the angle is outside of that tolerance,it is just not shown.\n){uv=uvmin.xy//reconstruct unit circle point,ellipse point,tangent \n  ;vec2 e=ab*uv,t=.5*(ab*perp(uv))\n  ;v.x/=rara\n  ;float edst=length(u-e)*e_px_per_unit-5.//distance to point on ellipse\n  ,pdst=(length(v-vec2(roots[i]/rara,0.))*g_px_per_unit)-5.// distance to root on x-axis\n  ;v.x*=rara\n  ;d_ellipse_root[i]=min(d_ellipse_root[i],edst)//is a vec4,this is fine\n  ;d_axis_root[i]=min(d_axis_root[i],pdst)//is a vec4,this is fine\n  ;dplot=min(dplot,pdst-2.)\n  ;ddot=min(ddot,edst-2.)\n  ;vec3 irr=colorMeIrrationally(i);\n  ;float ass=min(dline(u,q,e,1./e_px_per_unit),dline(u,e-t,e+t,0.))*e_px_per_unit-.25\n  ;dcol=mix(dcol,irr,step(ass,dwhite))//this could be alpha compisitioning instead.\n  ;dwhite=min(dwhite,ass)\n  //;if(uvmin.z<1e-3)\n  ;alph[i]=mix(2.,.0,smoothstep(-.01,.01,uvmin.z));\n ;}}\n ;const vec3 axis_color=vec3(.12,.15,.25)//draw\n //;vec3 c=mix(vec3(.2),vec3(.6),vec3(deb1))// bg color\n ;vec3 c=vec3(.4)\n //;c=vec3(.4)*dcol//nope,but awesome in its own right\n //;c=mix(c,c,.2+deb1*.5)\n //;c=colorMeIrrationally(getSmallestPosPositive(roots2))\n ;c*=.95+.05*cos(60.*d)//ellipse isolines\n ;vec2 g=abs(v-.25*floor(4.*v+0.5))//squares\n //;c=mix(c,axis_color,0.5*ss10(min(g.x,g.y)*g_px_per_unit))\n ;c=mix(c,axis_color,ss10(abs(v.y)*g_px_per_unit-1.))// x-axis \n ;c=mix(c,vec3(.025),ss10(dplot-1.))//plot graph over x\n ;c=mix(c,vec3(0),.6*exp(-.5*dwhite)*dcol)//slight dark shadow/glow for ellipse figure\n ;c=mix(c,vec3(1),smoothstep(.5,-.5,smoothstep(-.05,.05,abs(d)-.075)))//ellipse figure better estimate\n //;c=max(c,vec3(smoothstep(.01,-.01,abs(d)-.1)))\n ;float hair=4./max(iResolution.x,iResolution.y)\n ;c+=vec3(smoothstep(hair,-hair,abs(d)))//debug core shape hairline overlay,if this is visible with minimal moire,all is fine\n //;c=mix(c,vec3(.025),ss10(ddot)*dcol)//dark dot outlines \n ;for(int i=0;i<4;++i\n){vec3 d=colorMeIrrationally(i)\n  //for the below line the alph[i] params are sometimes sorted poorly,and should be alph=alph.xzyw in some cases.\n  //;alph=mix(alph,alph.xzyw,step(u.x,0.))\n  //;alph=mix(alph,alph.xzyw,step(0.,u.y))\n  //this is rare and not too much of a visual error in the debugger.\n  //;c=mix(c,vec3(alph[i]),ss10(dwhite)*dcol)//ellipse figure //dwhite is actually a low precision estimate.\n  ;c=mix(c,vec3(1),ss10(dwhite)*dcol)//ellipse figure //dwhite is actually a low precision estimate.\n  ;c=mix(c,d,ss10(d_axis_root[i])*alph[i])//roots on x-axis\n  ;c=mix(c,d,ss10(d_ellipse_root[i])*alph[i])//roots on ellipse\n  ;}\n //;c=mix(c,vec3(.025),ss10(dq-2.));c=mix(c,vec3(1),ss10(dq))//draggable dot and itsoutline\n //;c=pow(c,vec3(1./2.2))//gamma correction\n ;O=vec4(c,1);}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XttyWN.jpg", "access": "shaders20k", "license": "cc-by-sa-4.0", "functions": [[762, 1348, 1366, 1366, 1382], [1383, 1478, 1505, 1505, 2618], [2620, 2690, 2713, 2713, 2760], [2760, 2773, 2791, 2791, 2814], [2815, 2815, 2911, 2911, 4357], [4359, 4359, 4439, 4439, 4552], [4553, 4553, 4581, 4581, 4614], [4614, 4659, 4687, 4687, 4724], [4724, 4890, 4926, 4926, 5008], [5009, 5064, 5088, 5088, 5184], [5184, 5225, 5259, 5259, 5319], [5320, 5320, 5352, 5352, 5390], [5392, 5392, 5435, 5435, 11789]], "test": "untested"}
{"id": "XttyWr", "name": "Moebius Spiral 2", "author": "emh", "description": "Moebius Spiral 2", "tags": ["spiral", "moebius"], "likes": 2, "viewed": 328, "published": "Public API", "date": "1532254713", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#ifdef GL_ES\nprecision mediump float;\n#endif\n\n#define M_PI atan(1.0) * 4.0\n\n#define time iTime\n#define resolution iResolution.xy\n\nfloat rand(vec2 co){\n    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nvec2 nfract(vec2 co) {\n\tfloat x = co.x;\n\tfloat y = co.y;\n\treturn vec2(x >= 0.0 ? x - floor(x) : x - ceil(x), y >= 0.0 ? y - floor(y) : y - ceil(y));\n}\n\nvec2 nfloor(vec2 co) {\n\tfloat x = co.x;\n\tfloat y = co.y;\n\treturn vec2(x >= 0.0 ? floor(x) : ceil(x), y >= 0.0 ? floor(y) : ceil(y));\n}\n\nfloat sinc(float t) {\n\treturn (sin(t) + 1.0) / 2.0;\n}\n\nfloat cosc(float t) {\n\treturn (cos(t) + 1.0) / 2.0;\n}\n\n\nvec2 rndstep(vec2 p, int i) {\n\tvec2 seed = vec2(0.2342352, 0.4234254);\n\tfloat pwr = sinc(float(i));\n\tvec2 p1 = p * pwr; //vec2(pow(seed.x, pwr), pow(seed.y, pwr));\n\treturn p1;\n}\n\nfloat DistToLine(vec2 pt1, vec2 pt2, vec2 testPt)\n{\n  vec2 lineDir = pt2 - pt1;\n  vec2 perpDir = vec2(lineDir.y, -lineDir.x);\n  vec2 dirToPt1 = pt1 - testPt;\n  return abs(dot(normalize(perpDir), dirToPt1));\n}\n\nfloat drawLine(vec2 p1, vec2 p2, vec2 uv, float Thickness) {\n  float a = abs(distance(p1, uv));\n  float b = abs(distance(p2, uv));\n  float c = abs(distance(p1, p2));\n\n  if ( a >= c || b >=  c ) return 0.0;\n\n  float p = (a + b + c) * 0.5;\n\n  // median to (p1, p2) vector\n  float h = 2.0 / c * sqrt( p * ( p - a) * ( p - b) * ( p - c));\n\n  return mix(1.0, 0.0, smoothstep(0.5 * Thickness, 1.5 * Thickness, h));\n}\n\nvoid main2(vec2 uv, out vec4 fragColor, in vec2 fragCoord ) {\n\tfloat t = time + 8.0;\n\tvec2 r = resolution;\n\t\n\tvec2 no = uv;\n\tvec2 o = vec2(0.0);\n\tvec2 aspect = vec2(1.0, r.y / r.x);\n\tfloat sz = 0.0;\n\tfloat t2 = t;\n\tvec2 idx = vec2(0.0);\n\tvec2 boxOffset = vec2(0.0);\n\t\n\to = no * r - r / 2.0;\n\tt = t2;\n\t\n\t// bool cutCircle = length(boxOffset)\n\tvec2 or = o / r;\n\t\n\tif (sz > 6.0) {\n\t\tt = 8.0;\n\t}\n\t\t\n\to = vec2(length(o) / r.y - .3, atan(o.y,o.x) + fract(-t / 100.0) * 2.0 * M_PI);\n\t\n\tvec2 o2 = o;\n\t\n\tfloat width = 20.0;\n\tfloat scale = 20.0;\n\tfloat offset = 0.02;\n\t\n\to.x += 0.3;\n\t\n\tfloat y0to1 = (o.y + M_PI) / (2.0 * M_PI); // + floor(o2.x * scale);\n\to.x = (fract(o.x * scale + y0to1) + 1.0 + y0to1) / width;\n\to.x = (o.x - 0.05 * 1.5) / 0.2;\n\to.x -= (o.y + M_PI) / (8.0 * M_PI);\n\to.y *= M_PI / 2.0 + offset;\n\to.y = sin(M_PI * o.y);\n\t\n\tfloat dir = mod(floor(o2.x * scale), 2.0) == 0.0 ? 1.0 : -1.0;\n\tdir *= floor(o2.x * scale / 2.0);\n\tvec4 s = 0.08 * cos(1.5*vec4(0,1,2,3) + dir * t + o.y + cos(o.y) * cos(8.0));\n\t// s = sz > 6.0 ? vec4(1.0) : s;\n\tvec4 e = s.yzwx;\n\tvec4 f = max(o.x-s,e-o.x);\n\tvec4 color = o.x > -0.1 ? dot(clamp(f*r.y,0.,1.), 80.*(s-e)) * (s-.1) + (e - o.x) : vec4(0.0);\n\t\n\tfloat cutoff = 0.15;\n\tfragColor = o2.x + y0to1 / scale < cutoff ? color : vec4(1.0);\n\t\n\tvec2 ot = boxOffset;\n\t// gl_FragColor = vec4(ot.x, ot.y, 0.0, 1.0);\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\n\tvec2 position = ( gl_FragCoord.xy / resolution.xy );\n\n\tvec2 o = vec2(0.0);\n\t\n\tvec2 no = position;\n\tfloat t = time + 8.0;\n\tvec2 aspect2 = vec2(1.0, resolution.y / resolution.x);\n\tfloat sz2 = 0.0;\n\tfloat t2 = t;\n\tvec2 idx = vec2(0.0);\n\tvec2 boxOffset = vec2(0.0);\n\n\tconst int maxi2 = 6;\n\tfor (int i = 0; i <= maxi2; i++) {\n\t\tfloat sc = pow(2.0, float(i));\n\t\tfloat sc2 = pow(2.0, float(maxi2 - i + 1));\n\t\tfloat j = float(i);\n\t\tfloat maxj = float(maxi2);\n\t\t\n\t\tbool gotOne = false;\n\t\t\n\t\tvec2 to2 = nfloor(no * sc);\n\t\t\n\t\tfloat tslow = t  / 100.0;\n\t\t\n\t\tvec2 to3 = to2;\n\t\tfloat rndMove = mix(rand(to3 + floor(tslow)), rand(to3 + floor(tslow) + 1.0), fract(tslow));\n\t\tfloat rnd = rand(to2);\n\t\t\n\t\tfloat tsc = .1 * t * j / sc + rnd * 1000.0;\n\t\tvec2 bo = 0.0 * (i > 0 ? vec2(cosc(tsc), sinc(tsc)) : vec2(0.0));\n\t\t\n\t\tvec2 to = nfract((no + bo) * sc);\n\t\tvec2 tbo = nfract(bo * sc);\n\t\t\n\t\t// big on top\n\t\tbool check1 = length((o - 0.5) * aspect2) < 0.15;\n\t\t// small on top\n\t\tbool check2 = length((to - 0.5) * aspect2) > 0.15;\n\n\t\tfloat prob = 0.0;\n\t\tif (i == 0) {\n\t\t\tprob = 1.0;\n\t\t} else if (i >= 3) {\n\t\t\tprob = 0.5 / j;\n\t\t}\n\t\t\n\t\tbool check = rnd < prob && sz2 > 1.0 && length(to - 0.5) < sinc(t * 2.5 + 1000.0 * rnd) ? check2 : check1;\n\t\t// check = check1;\n\t\tbool cutCircle = false;\n\t\tif (check) {\n\t\t\tcutCircle = length((tbo - 0.5) * aspect2) <= 0.51;\n\t\t}\n\t\t\t\t\t\t\n\t\t// bool visible = rand(to2 + vec2(0.254, 0.2342543)) < prob;\n\t\tbool visible = !cutCircle;\n\t\t// if (!visible) continue;\n\t\t\n\t\to = check ? o : to;\n\t\tsz2 = check ? sz2 : float(i + 1);\n\t\tt2 = check ? t2 : t * (rnd + 0.5) + rnd * 1000.0;\n\t\tidx = check ? idx : to2;\n\t\tboxOffset = check ? boxOffset : to;\n\t\tgotOne = gotOne || check;\n\n\t\tif (gotOne) {\n\t\t\t// break;\n\t\t}\n\t}\n\t\n\t// vec2 orepeat = o * resolution - resolution / 2.0;\n\tvec2 orepeat = o;\n\t//float gsc = 0.5;\n\to = (no - 0.5) * 1.5 + 0.5;\n\t\n\tvec2 aspect = vec2(resolution.x / resolution.y, 1.0);\n\t\n\tvec2 p = vec2(0.189346713, 0.1982346);\n\t\n\tvec2 oc = vec2(length(o - 0.5), atan(o.y - 0.5, o.x - 0.5));\n\t\n\tfloat scale = 50.0;\n\t\n\tfloat r = 0.0;\n\tfloat g = 0.0;\n\tfloat b = 0.0;\n\t\n\tconst int pts = 2;\n\tfloat v1 = rand(floor(rndstep(p, 0) * scale));\n\tfloat v2 = rand(floor(rndstep(p, 1) * scale));\n\tfloat v3 = rand(floor(rndstep(p, 2) * scale));\n\tfloat v4 = rand(floor(rndstep(p, 3) * scale));\n\tconst int maxi = 20;\n\t\n\tfor (int i = 1; i <= maxi; i++) {\n\t\t//int j = int(mod(float(i), float(maxi)));\n\t\tfloat v5 = rand(floor(rndstep(p, i * pts + 2) * scale));\n\t\tfloat v6 = rand(floor(rndstep(p, i * pts + 3) * scale));\n\t\tif (i == maxi - 1) {\n\t\t\tv5 = rand(floor(rndstep(p, 0) * scale));\n\t\t\tv6 = rand(floor(rndstep(p, 1) * scale));\n\t\t}\n\t\tif (i == maxi) {\n\t\t\tv5 = rand(floor(rndstep(p, 2) * scale));\n\t\t\tv6 = rand(floor(rndstep(p, 3) * scale));\n\t\t}\n\t\t\n\t\t\n\t\tvec2 v12 = vec2(v1, v2);\n\t\tvec2 v34 = vec2(v3, v4);\n\t\tvec2 v56 = vec2(v5, v6);\n\t\t\n\t\t// v34 += 0.1 * (v56 - v12);\n\t\tb += drawLine(v12, v34, o, 0.003);\n\t\tfloat ti = time / 2.0;\n\t\tfloat tflen = 0.1;\n\t\tfloat tf = fract(ti);\n\t\tint t = int(mod(ti, float(maxi)));\n\t\t\n\t\tvec2 v = (v34 - v12);\n\t\tvec2 w = (v56 - v34);\n\t\t\n\t\ttflen /= length(v);\n\t\tvec2 endpoint = v12 + min(1.0, tf + tflen) * v;\n\t\tr += drawLine(v12 + tf * v, endpoint, o, 0.006);\n\t\t\n\t\tfloat d1 = length(v12 + tf * v - o);\n\t\tfloat d2 = 0.0;\n\t\tvec2 p1 = v12 + tf * v;\n\t\tvec2 p2 = vec2(0.0);\n\t\tfloat sz = 0.05;\n\n\t\tbool allInOne = tf + tflen < 1.0;\n\t\t\n\t\tif (allInOne) {\n\t\t\td2 = length(endpoint - o);\n\t\t\tp2 = endpoint;\n\t\t\t\n\t\t\td2 = length(endpoint - o);\n\t\t\tp2 = endpoint;\n\t\t}\n\t\t\n\t\tfloat tf2len = tflen - (min(1.0, tf + tflen) - tf);\n\t\ttf2len *= length(v) / length(w);\n\t\tif (i <= maxi) {\n\t\t\tr += drawLine(v34, v34 + tf2len * w, o, 0.006);\n\t\t\t\n\t\t\tif (!allInOne) {\n\t\t\t\td2 = length(v34 + tf2len * w - o);\n\t\t\t\tp2 = v34 + tf2len * w;\n\t\t\t}\n\t\t}\n\t\t\n\t\tvec2 mid1 = mix(v12, v34, tf + 0.5);\n\t\tvec2 mid2 = mix(v34, v56, tf - 0.5);\n\t\tvec2 mid = mix(mid1, mid2, tf);\n\t\t\n\t\tfor (int j = 0; j < 4; j++) {\n\t\t\n\t\t\tfloat th = sin(time / 1.0 + float(j));\n\t\t\tvec2 mid = (mid - 0.5) * mat2(cos(th), -sin(th), sin(th), cos(th)) + 0.5;\n\t\t\t\n\t\t\tfloat d = length((mid - o) * aspect);\n\t\t\tif (i <= maxi) {\n\t\t\t\tg += d < sz ? d / sz : 0.0;\n\t\t\t\tif (d < sz) {\n\t\t\t\t\tfloat sc = sz * 2.8;\n\t\t\t\t\tvec2 uv = (mid - o) / sc + 0.5;\n\t\t\t\t\t\n\t\t\t\t\t\t// vec2 offset = 0.0 * vec2(float(j));\n\t\t\t\t\tmain2(uv, fragColor, fragCoord);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t// g += d1 < sz ? d1 / sz : 0.0;\n\t\t// g += d2 < sz ? d2 / sz : 0.0;\n\t\t\t\t\n\t\tv1 = v3;\n\t\tv2 = v4;\n\t\tv3 = v5;\n\t\tv4 = v6;\n\t}\n\t\n\tif (g == 0.0) {\n\t\tmain2(orepeat, fragColor, fragCoord);\n\t}\n\t\n\t// g = g > 0.0 ? 1.0 - g: 0.0;\n\t/*if (g > 0.0) {\n\t\tmain2(o);\n\t}*/\n\t\n\t// gl_FragColor += vec4(1.0 * r, 0.0, b, 1.0);\n\t// gl_FragColor = vec4(o.x, 0.0, o.y, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XttyWr.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[130, 130, 150, 150, 222], [224, 224, 246, 246, 374], [376, 376, 398, 398, 510], [512, 512, 533, 533, 565], [567, 567, 588, 588, 620], [623, 623, 652, 652, 800], [802, 802, 853, 853, 1010], [1012, 1012, 1072, 1072, 1422], [1424, 1424, 1485, 1485, 2767], [2771, 2771, 2828, 2828, 7460]], "test": "untested"}
{"id": "Xttyzn", "name": "李明杰V18", "author": "leneer", "description": "r", "tags": ["r"], "likes": 2, "viewed": 717, "published": "Public", "date": "1531294427", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//Britbot by eiffie\n//A little bit like mode7 from poljere https://www.shadertoy.com/view/ltsGWn\n//...and a lot of tunnel from iq https://www.shadertoy.com/view/Ms2SWW\n\n#define PI 3.14159\nvec3 tunnel(vec3 rd){\n\tvec2 uv=rd.xy/rd.z;\n\tfloat tm=iTime*sign(rd.z)*1.5;\n\tfloat pw=0.5+pow(min(abs(sin(tm*0.1))+0.25,1.0),16.0)*16.0;\n\tfloat r=pow(pow(uv.x*uv.x,pw)+pow(uv.y*uv.y,pw),0.5/pw);\n\tfloat x;\n\tfor(int i=1;i<10;i++){//what kind of maths are these?\n\t\tx=uv.x+sin((0.5/r+0.5*tm)*2.0)*float(i)*float(i)*0.001;\n        pw=0.5+pow(min(abs(sin((tm+max(1.0-r,0.0))*0.1))+0.25,1.0),16.0)*16.0;\n\t\tr=pow(pow(x*x,pw)+pow(uv.y*uv.y,pw),0.5/pw);\n\t}\n\tuv.x=x;\n\tfloat a=atan(uv.y,uv.x)/3.14159;\n\tvec2 p=vec2(0.5/r+0.5*tm,a)*8.0;\n\tp.y*=sign(uv.x);\n\tvec2 c=floor(p);\n\tp=fract(p);\n\tp.x=pow(p.x,clamp(abs(rd.z)+pw/16.0,1.0,2.0));\n\tuv=p;\n\tuv=2.0*(uv-0.5);\n\tfloat r2=pow(pow(uv.x*uv.x,pw)+pow(uv.y*uv.y,pw),0.5/pw);\n\tp=clamp(p*1.5-0.25,0.0,1.0);\n\tvec3 col=vec3(0.5)+0.5*sin(vec3(c.xy,c.x+c.y));\n    if((a<0.25 && a>-0.25) || a<-0.75 || a>0.75){\n        float d=max(abs(p.x-0.5),abs(p.y-0.5))-0.5;\n        if(d<0.0){//min(p.x,p.y)>0.0 && max(p.x,p.y)<1.0){\n        \tif(rd.z<0.0)p.y=1.0-p.y;\n\t\t\tcol=mix(col,texture(iChannel0,p).rgb,smoothstep(0.0,0.05,-d));\n        }\n    }\n\tcol*=2.0*pow(r,1.75)*clamp(3.0-r2*3.0,0.0,1.0);\n\tif(col!=col)col=vec3(0.0);\n\treturn clamp(col,0.0,1.0);\n}\nmat3 lookat(vec3 fw, vec3 up){\n\tfw=normalize(fw);vec3 rt=normalize(cross(fw,normalize(up)));return mat3(rt,cross(rt,fw),fw);\n}\nstruct intersect{float t, d; vec3 N;}I1,I2; \nvoid zStack(intersect I, float px){\n\tif(I.t<=0.0 || I.d>px*I.t)return;\n\tif(I.t<I1.t){I2=I1;I1=I;}\n\telse if(I.t<I2.t)I2=I;\n}\n#define maxDepth 10.0\n//pS=p1-ro, pD=p2-p1 Hopefully no one thinks this actually works!\nintersect Segment(in vec3 pS, in vec3 pD, in float r, in vec3 rd){//mod from iq's\n\tintersect intr=intersect(0.0,maxDepth,vec3(0.0));\n\tfloat d=dot(rd,pD);\n\tfloat t=clamp((dot(rd,pS)*d-dot(pS,pD))/(dot(pD,pD)-d*d),0.0,1.0);\n\tpS+=pD*t;\n\tintr.N=-pS;\n\tfloat b=dot(pS,rd);\n\tfloat h=b*b-dot(pS,pS);\n\td=sqrt(max(0.0,-h))-r;\n\tintr.d=max(0.0,d);\n\tintr.t=b+min(d,0.0)-sqrt(max(0.0,h+r*r));\n\treturn intr;\n\t//dist: intr.t\n\t//aa/dof: clamp(intr.d/(px*intr.t),0.0,1.0);\n\t//shad: clamp(k*intr.d/intr.t,0.0,1.0);\n\t//normal: normalize(rd*intr.t+intr.N);\n}\nvec3 Light(intersect I, vec3 rd, float px, vec3 col){\n\tfloat aac=1.0-clamp(I.d/(px*I.t),0.0,1.0);\n\tif(aac>0.0){\n\t\tvec3 N=normalize(rd*I.t+I.N);\n\t\tvec3 L=normalize(vec3(0.5,0.8,0.4));\n\t\tvec3 R=reflect(rd,N);\n\t\tcol=mix(col,(vec3(1.0,0.3,0.4)+0.2*tunnel(R))*(0.5+0.5*dot(L,N)),aac);\n\t}\n\treturn col;\n}\nvec3 jsolve( vec3 a, vec3 b, float ln, vec3 rt )//mod from iq's\n{//simple joint with equal lengths\n\tvec3 p=b-a,q=p*0.5;\n\treturn a+q+sqrt(max(0.0,ln*ln-dot(q,q)))*normalize(cross(p,rt));\n}\nvec3 britbot(vec3 ro, vec3 rd, vec3 col){\n\tfloat px=2.5/iResolution.y,tm=iTime*10.0;\n\tI1.t=I2.t=I1.d=I2.d=maxDepth;\n\tfloat ct=cos(tm),st=sin(tm),st2=sin(tm*0.3);\n\tfloat h=(ct+st)*ct*-0.25;\n\tvec3 b1=vec3(0.0,h,0.0),b2=vec3(st2*0.2,-0.75+h,-0.2);\n\t\n\tvec3 le,lh=vec3(-0.75+0.1*st,-0.4-0.2*ct,0.3-0.3*ct),re,rh=vec3(0.75+0.1*st,-0.4-0.2*st,0.3+0.3*ct);\n\tvec3 lk,lf=vec3(-0.25,-2.0+max(0.0,ct*0.5),-0.25+0.4*st),rk,rf=vec3(0.25,-2.0+max(0.0,-ct*0.5),-0.25-0.4*st);\n\tvec3 rt=normalize(vec3(1.0+0.4*st2,-0.4*st2,0.0));\n\tle=jsolve(b1,lh,0.6,rt.yxz);\n\tre=jsolve(b1,rh,0.6,-rt.yxz);\n\tlk=jsolve(b2,lf,0.7,rt);\n\trk=jsolve(b2,rf,0.7,rt);\n\tfloat TR=0.15;\n\tvec3 n=vec3(TR,0.0,-TR*0.5);\n\tzStack(Segment(b1-ro,b2-b1,TR,rd),px);\n\tTR*=0.75;\n\tzStack(Segment(lk-ro,b2-n.xyy-lk,TR,rd),px);\n\tzStack(Segment(rk-ro,b2+n.xyy-rk,TR,rd),px);\n\tTR*=0.75;\n\tzStack(Segment(lf-ro,lk-lf,TR,rd),px);\n\tzStack(Segment(rf-ro,rk-rf,TR,rd),px);\n\tTR*=0.75;\n\tzStack(Segment(le-ro,b1-n.xyy-le,TR,rd),px);\n\tzStack(Segment(re-ro,b1+n.xyy-re,TR,rd),px);\n\tTR*=0.75;\n\tzStack(Segment(lh-ro,le-lh,TR,rd),px);\n\tzStack(Segment(rh-ro,re-rh,TR,rd),px);\n\tTR*=0.75;\n\tmat3 mx=lookat(vec3(st2*ct,0.25*(st2+st),1.0),vec3(0.25*st2*st,1.0,0.25*st2*ct));\n\tvec3 n1=vec3(0.0,0.25+h,0.0)*mx,h1=vec3(-0.4,0.25+h,0.0)*mx,h2=vec3(-0.4,0.75+h,0.0)*mx;\n\tvec3 h3=vec3(0.4,0.75+h,0.0)*mx,h4=vec3(0.4,0.25+h,0.0)*mx;\n\t\n\tn=vec3(0.0,0.0,1.0)*mx;\n\tfloat t=-dot(n,ro)/dot(n,rd);\n\tif(t>0.0){\n\t\tvec3 p=mx*(ro+rd*t);\n\t\tp.y-=h;\n\t\tif(p.x>-0.4 && p.x<0.4 && p.y>0.25 && p.y<0.75){\n\t\t\tcol=texture(iChannel0,vec2(1.25,2.0)*(p.xy+vec2(0.4,-0.25))).rgb;\n\t\t}\n\t}\n\tzStack(Segment(b1-ro,n1-b1,TR,rd),px);\n\tzStack(Segment(h1-ro,h2-h1,TR,rd),px);\n\tzStack(Segment(h2-ro,h3-h2,TR,rd),px);\n\tzStack(Segment(h3-ro,h4-h3,TR,rd),px);\n\tzStack(Segment(h1-ro,h4-h1,TR,rd),px);\n\t\n\tcol=Light(I2,rd,px,col);\n\tcol=Light(I1,rd,px,col);\n\treturn col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = (2.0*fragCoord.xy-iResolution.xy)/ iResolution.y;\n\tfloat tm=iTime*0.1;\n\tvec3 ro=vec3(sin(tm),0.0,cos(tm)*3.0);\n\ttm=abs(sin(tm*1.5));\n\tvec3 up=vec3(1.0-tm,1.0,0.0);\n\tvec3 rd=lookat(-ro,up)*normalize(vec3(uv,1.0));\n \tvec3 col=tunnel(rd);\n\tcol=britbot(ro,rd,col);\n\tfragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": "4sXGRn", "previewfilepath": "/media/ap/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Xttyzn.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 188, 209, 209, 1354], [1355, 1355, 1385, 1385, 1481], [1527, 1527, 1562, 1562, 1650], [1673, 1739, 1805, 1820, 2276], [2277, 2277, 2330, 2330, 2574], [2575, 2575, 2640, 2673, 2762], [2763, 2763, 2804, 2804, 4605], [4607, 4607, 4664, 4664, 4966]], "test": "untested"}
